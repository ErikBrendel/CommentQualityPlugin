# id;timestamp;commentText;codeText;commentWords;codeWords
TransactionalTestExecutionListener -> protected final boolean isDefaultRollback(TestContext testContext) throws Exception;1328020251;Determine whether or not to rollback transactions by default for the_supplied {@link TestContext test context}._@param testContext the test context for which the default rollback flag_should be retrieved_@return the <em>default rollback</em> flag for the supplied test context_@throws Exception if an error occurs while determining the default rollback flag;protected final boolean isDefaultRollback(TestContext testContext) throws Exception {_		return retrieveConfigurationAttributes(testContext).isDefaultRollback()__	};determine,whether,or,not,to,rollback,transactions,by,default,for,the,supplied,link,test,context,test,context,param,test,context,the,test,context,for,which,the,default,rollback,flag,should,be,retrieved,return,the,em,default,rollback,em,flag,for,the,supplied,test,context,throws,exception,if,an,error,occurs,while,determining,the,default,rollback,flag;protected,final,boolean,is,default,rollback,test,context,test,context,throws,exception,return,retrieve,configuration,attributes,test,context,is,default,rollback
TransactionalTestExecutionListener -> protected final boolean isDefaultRollback(TestContext testContext) throws Exception;1337516454;Determine whether or not to rollback transactions by default for the_supplied {@link TestContext test context}._@param testContext the test context for which the default rollback flag_should be retrieved_@return the <em>default rollback</em> flag for the supplied test context_@throws Exception if an error occurs while determining the default rollback flag;protected final boolean isDefaultRollback(TestContext testContext) throws Exception {_		return retrieveConfigurationAttributes(testContext).isDefaultRollback()__	};determine,whether,or,not,to,rollback,transactions,by,default,for,the,supplied,link,test,context,test,context,param,test,context,the,test,context,for,which,the,default,rollback,flag,should,be,retrieved,return,the,em,default,rollback,em,flag,for,the,supplied,test,context,throws,exception,if,an,error,occurs,while,determining,the,default,rollback,flag;protected,final,boolean,is,default,rollback,test,context,test,context,throws,exception,return,retrieve,configuration,attributes,test,context,is,default,rollback
TransactionalTestExecutionListener -> protected final boolean isDefaultRollback(TestContext testContext) throws Exception;1338031377;Determine whether or not to rollback transactions by default for the_supplied {@link TestContext test context}._@param testContext the test context for which the default rollback flag_should be retrieved_@return the <em>default rollback</em> flag for the supplied test context_@throws Exception if an error occurs while determining the default rollback flag;protected final boolean isDefaultRollback(TestContext testContext) throws Exception {_		return retrieveConfigurationAttributes(testContext).isDefaultRollback()__	};determine,whether,or,not,to,rollback,transactions,by,default,for,the,supplied,link,test,context,test,context,param,test,context,the,test,context,for,which,the,default,rollback,flag,should,be,retrieved,return,the,em,default,rollback,em,flag,for,the,supplied,test,context,throws,exception,if,an,error,occurs,while,determining,the,default,rollback,flag;protected,final,boolean,is,default,rollback,test,context,test,context,throws,exception,return,retrieve,configuration,attributes,test,context,is,default,rollback
TransactionalTestExecutionListener -> protected final boolean isDefaultRollback(TestContext testContext) throws Exception;1343426806;Determine whether or not to rollback transactions by default for the_supplied {@link TestContext test context}._@param testContext the test context for which the default rollback flag_should be retrieved_@return the <em>default rollback</em> flag for the supplied test context_@throws Exception if an error occurs while determining the default rollback flag;protected final boolean isDefaultRollback(TestContext testContext) throws Exception {_		return retrieveConfigurationAttributes(testContext).isDefaultRollback()__	};determine,whether,or,not,to,rollback,transactions,by,default,for,the,supplied,link,test,context,test,context,param,test,context,the,test,context,for,which,the,default,rollback,flag,should,be,retrieved,return,the,em,default,rollback,em,flag,for,the,supplied,test,context,throws,exception,if,an,error,occurs,while,determining,the,default,rollback,flag;protected,final,boolean,is,default,rollback,test,context,test,context,throws,exception,return,retrieve,configuration,attributes,test,context,is,default,rollback
TransactionalTestExecutionListener -> protected final boolean isDefaultRollback(TestContext testContext) throws Exception;1343431472;Determine whether or not to rollback transactions by default for the_supplied {@link TestContext test context}._@param testContext the test context for which the default rollback flag_should be retrieved_@return the <em>default rollback</em> flag for the supplied test context_@throws Exception if an error occurs while determining the default rollback flag;protected final boolean isDefaultRollback(TestContext testContext) throws Exception {_		return retrieveConfigurationAttributes(testContext).isDefaultRollback()__	};determine,whether,or,not,to,rollback,transactions,by,default,for,the,supplied,link,test,context,test,context,param,test,context,the,test,context,for,which,the,default,rollback,flag,should,be,retrieved,return,the,em,default,rollback,em,flag,for,the,supplied,test,context,throws,exception,if,an,error,occurs,while,determining,the,default,rollback,flag;protected,final,boolean,is,default,rollback,test,context,test,context,throws,exception,return,retrieve,configuration,attributes,test,context,is,default,rollback
TransactionalTestExecutionListener -> protected final boolean isDefaultRollback(TestContext testContext) throws Exception;1354571539;Determine whether or not to rollback transactions by default for the_supplied {@link TestContext test context}._@param testContext the test context for which the default rollback flag_should be retrieved_@return the <em>default rollback</em> flag for the supplied test context_@throws Exception if an error occurs while determining the default rollback flag;protected final boolean isDefaultRollback(TestContext testContext) throws Exception {_		return retrieveConfigurationAttributes(testContext).isDefaultRollback()__	};determine,whether,or,not,to,rollback,transactions,by,default,for,the,supplied,link,test,context,test,context,param,test,context,the,test,context,for,which,the,default,rollback,flag,should,be,retrieved,return,the,em,default,rollback,em,flag,for,the,supplied,test,context,throws,exception,if,an,error,occurs,while,determining,the,default,rollback,flag;protected,final,boolean,is,default,rollback,test,context,test,context,throws,exception,return,retrieve,configuration,attributes,test,context,is,default,rollback
TransactionalTestExecutionListener -> protected final boolean isDefaultRollback(TestContext testContext) throws Exception;1355352386;Determine whether or not to rollback transactions by default for the_supplied {@link TestContext test context}._@param testContext the test context for which the default rollback flag_should be retrieved_@return the <em>default rollback</em> flag for the supplied test context_@throws Exception if an error occurs while determining the default rollback flag;protected final boolean isDefaultRollback(TestContext testContext) throws Exception {_		return retrieveConfigurationAttributes(testContext).isDefaultRollback()__	};determine,whether,or,not,to,rollback,transactions,by,default,for,the,supplied,link,test,context,test,context,param,test,context,the,test,context,for,which,the,default,rollback,flag,should,be,retrieved,return,the,em,default,rollback,em,flag,for,the,supplied,test,context,throws,exception,if,an,error,occurs,while,determining,the,default,rollback,flag;protected,final,boolean,is,default,rollback,test,context,test,context,throws,exception,return,retrieve,configuration,attributes,test,context,is,default,rollback
TransactionalTestExecutionListener -> protected final boolean isDefaultRollback(TestContext testContext) throws Exception;1356735495;Determine whether or not to rollback transactions by default for the_supplied {@link TestContext test context}._@param testContext the test context for which the default rollback flag_should be retrieved_@return the <em>default rollback</em> flag for the supplied test context_@throws Exception if an error occurs while determining the default rollback flag;protected final boolean isDefaultRollback(TestContext testContext) throws Exception {_		return retrieveConfigurationAttributes(testContext).isDefaultRollback()__	};determine,whether,or,not,to,rollback,transactions,by,default,for,the,supplied,link,test,context,test,context,param,test,context,the,test,context,for,which,the,default,rollback,flag,should,be,retrieved,return,the,em,default,rollback,em,flag,for,the,supplied,test,context,throws,exception,if,an,error,occurs,while,determining,the,default,rollback,flag;protected,final,boolean,is,default,rollback,test,context,test,context,throws,exception,return,retrieve,configuration,attributes,test,context,is,default,rollback
TransactionalTestExecutionListener -> protected final boolean isDefaultRollback(TestContext testContext) throws Exception;1357119239;Determine whether or not to rollback transactions by default for the_supplied {@link TestContext test context}._@param testContext the test context for which the default rollback flag_should be retrieved_@return the <em>default rollback</em> flag for the supplied test context_@throws Exception if an error occurs while determining the default rollback flag;protected final boolean isDefaultRollback(TestContext testContext) throws Exception {_		return retrieveConfigurationAttributes(testContext).isDefaultRollback()__	};determine,whether,or,not,to,rollback,transactions,by,default,for,the,supplied,link,test,context,test,context,param,test,context,the,test,context,for,which,the,default,rollback,flag,should,be,retrieved,return,the,em,default,rollback,em,flag,for,the,supplied,test,context,throws,exception,if,an,error,occurs,while,determining,the,default,rollback,flag;protected,final,boolean,is,default,rollback,test,context,test,context,throws,exception,return,retrieve,configuration,attributes,test,context,is,default,rollback
TransactionalTestExecutionListener -> protected final boolean isDefaultRollback(TestContext testContext) throws Exception;1367163114;Determine whether or not to rollback transactions by default for the_supplied {@link TestContext test context}._@param testContext the test context for which the default rollback flag_should be retrieved_@return the <em>default rollback</em> flag for the supplied test context_@throws Exception if an error occurs while determining the default rollback flag;protected final boolean isDefaultRollback(TestContext testContext) throws Exception {_		return retrieveConfigurationAttributes(testContext).isDefaultRollback()__	};determine,whether,or,not,to,rollback,transactions,by,default,for,the,supplied,link,test,context,test,context,param,test,context,the,test,context,for,which,the,default,rollback,flag,should,be,retrieved,return,the,em,default,rollback,em,flag,for,the,supplied,test,context,throws,exception,if,an,error,occurs,while,determining,the,default,rollback,flag;protected,final,boolean,is,default,rollback,test,context,test,context,throws,exception,return,retrieve,configuration,attributes,test,context,is,default,rollback
TransactionalTestExecutionListener -> protected final boolean isDefaultRollback(TestContext testContext) throws Exception;1367873075;Determine whether or not to rollback transactions by default for the_supplied {@link TestContext test context}._@param testContext the test context for which the default rollback flag_should be retrieved_@return the <em>default rollback</em> flag for the supplied test context_@throws Exception if an error occurs while determining the default rollback flag;protected final boolean isDefaultRollback(TestContext testContext) throws Exception {_		return retrieveConfigurationAttributes(testContext).isDefaultRollback()__	};determine,whether,or,not,to,rollback,transactions,by,default,for,the,supplied,link,test,context,test,context,param,test,context,the,test,context,for,which,the,default,rollback,flag,should,be,retrieved,return,the,em,default,rollback,em,flag,for,the,supplied,test,context,throws,exception,if,an,error,occurs,while,determining,the,default,rollback,flag;protected,final,boolean,is,default,rollback,test,context,test,context,throws,exception,return,retrieve,configuration,attributes,test,context,is,default,rollback
TransactionalTestExecutionListener -> protected final boolean isDefaultRollback(TestContext testContext) throws Exception;1368482696;Determine whether or not to rollback transactions by default for the_supplied {@link TestContext test context}._@param testContext the test context for which the default rollback flag_should be retrieved_@return the <em>default rollback</em> flag for the supplied test context_@throws Exception if an error occurs while determining the default rollback flag;protected final boolean isDefaultRollback(TestContext testContext) throws Exception {_		return retrieveConfigurationAttributes(testContext).isDefaultRollback()__	};determine,whether,or,not,to,rollback,transactions,by,default,for,the,supplied,link,test,context,test,context,param,test,context,the,test,context,for,which,the,default,rollback,flag,should,be,retrieved,return,the,em,default,rollback,em,flag,for,the,supplied,test,context,throws,exception,if,an,error,occurs,while,determining,the,default,rollback,flag;protected,final,boolean,is,default,rollback,test,context,test,context,throws,exception,return,retrieve,configuration,attributes,test,context,is,default,rollback
TransactionalTestExecutionListener -> protected final boolean isDefaultRollback(TestContext testContext) throws Exception;1382920864;Determine whether or not to rollback transactions by default for the_supplied {@link TestContext test context}._@param testContext the test context for which the default rollback flag_should be retrieved_@return the <em>default rollback</em> flag for the supplied test context_@throws Exception if an error occurs while determining the default rollback flag;protected final boolean isDefaultRollback(TestContext testContext) throws Exception {_		return retrieveConfigurationAttributes(testContext).isDefaultRollback()__	};determine,whether,or,not,to,rollback,transactions,by,default,for,the,supplied,link,test,context,test,context,param,test,context,the,test,context,for,which,the,default,rollback,flag,should,be,retrieved,return,the,em,default,rollback,em,flag,for,the,supplied,test,context,throws,exception,if,an,error,occurs,while,determining,the,default,rollback,flag;protected,final,boolean,is,default,rollback,test,context,test,context,throws,exception,return,retrieve,configuration,attributes,test,context,is,default,rollback
TransactionalTestExecutionListener -> protected final boolean isDefaultRollback(TestContext testContext) throws Exception;1385499540;Determine whether or not to rollback transactions by default for the_supplied {@link TestContext test context}._@param testContext the test context for which the default rollback flag_should be retrieved_@return the <em>default rollback</em> flag for the supplied test context_@throws Exception if an error occurs while determining the default rollback flag;protected final boolean isDefaultRollback(TestContext testContext) throws Exception {_		return retrieveConfigurationAttributes(testContext).isDefaultRollback()__	};determine,whether,or,not,to,rollback,transactions,by,default,for,the,supplied,link,test,context,test,context,param,test,context,the,test,context,for,which,the,default,rollback,flag,should,be,retrieved,return,the,em,default,rollback,em,flag,for,the,supplied,test,context,throws,exception,if,an,error,occurs,while,determining,the,default,rollback,flag;protected,final,boolean,is,default,rollback,test,context,test,context,throws,exception,return,retrieve,configuration,attributes,test,context,is,default,rollback
TransactionalTestExecutionListener -> protected final boolean isDefaultRollback(TestContext testContext) throws Exception;1389966876;Determine whether or not to rollback transactions by default for the_supplied {@link TestContext test context}._@param testContext the test context for which the default rollback flag_should be retrieved_@return the <em>default rollback</em> flag for the supplied test context_@throws Exception if an error occurs while determining the default rollback flag;protected final boolean isDefaultRollback(TestContext testContext) throws Exception {_		return retrieveConfigurationAttributes(testContext).isDefaultRollback()__	};determine,whether,or,not,to,rollback,transactions,by,default,for,the,supplied,link,test,context,test,context,param,test,context,the,test,context,for,which,the,default,rollback,flag,should,be,retrieved,return,the,em,default,rollback,em,flag,for,the,supplied,test,context,throws,exception,if,an,error,occurs,while,determining,the,default,rollback,flag;protected,final,boolean,is,default,rollback,test,context,test,context,throws,exception,return,retrieve,configuration,attributes,test,context,is,default,rollback
TransactionalTestExecutionListener -> protected final boolean isDefaultRollback(TestContext testContext) throws Exception;1401991965;Determine whether or not to rollback transactions by default for the_supplied {@link TestContext test context}._@param testContext the test context for which the default rollback flag_should be retrieved_@return the <em>default rollback</em> flag for the supplied test context_@throws Exception if an error occurs while determining the default rollback flag;protected final boolean isDefaultRollback(TestContext testContext) throws Exception {_		return retrieveConfigurationAttributes(testContext).isDefaultRollback()__	};determine,whether,or,not,to,rollback,transactions,by,default,for,the,supplied,link,test,context,test,context,param,test,context,the,test,context,for,which,the,default,rollback,flag,should,be,retrieved,return,the,em,default,rollback,em,flag,for,the,supplied,test,context,throws,exception,if,an,error,occurs,while,determining,the,default,rollback,flag;protected,final,boolean,is,default,rollback,test,context,test,context,throws,exception,return,retrieve,configuration,attributes,test,context,is,default,rollback
TransactionalTestExecutionListener -> protected final boolean isDefaultRollback(TestContext testContext) throws Exception;1404334604;Determine whether or not to rollback transactions by default for the_supplied {@link TestContext test context}._@param testContext the test context for which the default rollback flag_should be retrieved_@return the <em>default rollback</em> flag for the supplied test context_@throws Exception if an error occurs while determining the default rollback flag;protected final boolean isDefaultRollback(TestContext testContext) throws Exception {_		return retrieveConfigurationAttributes(testContext).isDefaultRollback()__	};determine,whether,or,not,to,rollback,transactions,by,default,for,the,supplied,link,test,context,test,context,param,test,context,the,test,context,for,which,the,default,rollback,flag,should,be,retrieved,return,the,em,default,rollback,em,flag,for,the,supplied,test,context,throws,exception,if,an,error,occurs,while,determining,the,default,rollback,flag;protected,final,boolean,is,default,rollback,test,context,test,context,throws,exception,return,retrieve,configuration,attributes,test,context,is,default,rollback
TransactionalTestExecutionListener -> protected final boolean isDefaultRollback(TestContext testContext) throws Exception;1405645143;Determine whether or not to rollback transactions by default for the_supplied {@link TestContext test context}._@param testContext the test context for which the default rollback flag_should be retrieved_@return the <em>default rollback</em> flag for the supplied test context_@throws Exception if an error occurs while determining the default rollback flag;protected final boolean isDefaultRollback(TestContext testContext) throws Exception {_		return retrieveConfigurationAttributes(testContext).isDefaultRollback()__	};determine,whether,or,not,to,rollback,transactions,by,default,for,the,supplied,link,test,context,test,context,param,test,context,the,test,context,for,which,the,default,rollback,flag,should,be,retrieved,return,the,em,default,rollback,em,flag,for,the,supplied,test,context,throws,exception,if,an,error,occurs,while,determining,the,default,rollback,flag;protected,final,boolean,is,default,rollback,test,context,test,context,throws,exception,return,retrieve,configuration,attributes,test,context,is,default,rollback
TransactionalTestExecutionListener -> protected final boolean isDefaultRollback(TestContext testContext) throws Exception;1405698612;Determine whether or not to rollback transactions by default for the_supplied {@link TestContext test context}._@param testContext the test context for which the default rollback flag_should be retrieved_@return the <em>default rollback</em> flag for the supplied test context_@throws Exception if an error occurs while determining the default rollback flag;protected final boolean isDefaultRollback(TestContext testContext) throws Exception {_		return retrieveConfigurationAttributes(testContext).isDefaultRollback()__	};determine,whether,or,not,to,rollback,transactions,by,default,for,the,supplied,link,test,context,test,context,param,test,context,the,test,context,for,which,the,default,rollback,flag,should,be,retrieved,return,the,em,default,rollback,em,flag,for,the,supplied,test,context,throws,exception,if,an,error,occurs,while,determining,the,default,rollback,flag;protected,final,boolean,is,default,rollback,test,context,test,context,throws,exception,return,retrieve,configuration,attributes,test,context,is,default,rollback
TransactionalTestExecutionListener -> protected final boolean isDefaultRollback(TestContext testContext) throws Exception;1405759527;Determine whether or not to rollback transactions by default for the_supplied {@link TestContext test context}._@param testContext the test context for which the default rollback flag_should be retrieved_@return the <em>default rollback</em> flag for the supplied test context_@throws Exception if an error occurs while determining the default rollback flag;protected final boolean isDefaultRollback(TestContext testContext) throws Exception {_		return retrieveConfigurationAttributes(testContext).isDefaultRollback()__	};determine,whether,or,not,to,rollback,transactions,by,default,for,the,supplied,link,test,context,test,context,param,test,context,the,test,context,for,which,the,default,rollback,flag,should,be,retrieved,return,the,em,default,rollback,em,flag,for,the,supplied,test,context,throws,exception,if,an,error,occurs,while,determining,the,default,rollback,flag;protected,final,boolean,is,default,rollback,test,context,test,context,throws,exception,return,retrieve,configuration,attributes,test,context,is,default,rollback
TransactionalTestExecutionListener -> protected final boolean isDefaultRollback(TestContext testContext) throws Exception;1405759966;Determine whether or not to rollback transactions by default for the_supplied {@link TestContext test context}._@param testContext the test context for which the default rollback flag_should be retrieved_@return the <em>default rollback</em> flag for the supplied test context_@throws Exception if an error occurs while determining the default rollback flag;protected final boolean isDefaultRollback(TestContext testContext) throws Exception {_		return retrieveConfigurationAttributes(testContext).isDefaultRollback()__	};determine,whether,or,not,to,rollback,transactions,by,default,for,the,supplied,link,test,context,test,context,param,test,context,the,test,context,for,which,the,default,rollback,flag,should,be,retrieved,return,the,em,default,rollback,em,flag,for,the,supplied,test,context,throws,exception,if,an,error,occurs,while,determining,the,default,rollback,flag;protected,final,boolean,is,default,rollback,test,context,test,context,throws,exception,return,retrieve,configuration,attributes,test,context,is,default,rollback
TransactionalTestExecutionListener -> protected final boolean isDefaultRollback(TestContext testContext) throws Exception;1406218418;Determine whether or not to rollback transactions by default for the_supplied {@link TestContext test context}._@param testContext the test context for which the default rollback flag_should be retrieved_@return the <em>default rollback</em> flag for the supplied test context_@throws Exception if an error occurs while determining the default rollback flag;protected final boolean isDefaultRollback(TestContext testContext) throws Exception {_		return retrieveConfigurationAttributes(testContext).isDefaultRollback()__	};determine,whether,or,not,to,rollback,transactions,by,default,for,the,supplied,link,test,context,test,context,param,test,context,the,test,context,for,which,the,default,rollback,flag,should,be,retrieved,return,the,em,default,rollback,em,flag,for,the,supplied,test,context,throws,exception,if,an,error,occurs,while,determining,the,default,rollback,flag;protected,final,boolean,is,default,rollback,test,context,test,context,throws,exception,return,retrieve,configuration,attributes,test,context,is,default,rollback
TransactionalTestExecutionListener -> protected final boolean isDefaultRollback(TestContext testContext) throws Exception;1407419079;Determine whether or not to rollback transactions by default for the_supplied {@link TestContext test context}._@param testContext the test context for which the default rollback flag_should be retrieved_@return the <em>default rollback</em> flag for the supplied test context_@throws Exception if an error occurs while determining the default rollback flag;protected final boolean isDefaultRollback(TestContext testContext) throws Exception {_		return retrieveConfigurationAttributes(testContext).isDefaultRollback()__	};determine,whether,or,not,to,rollback,transactions,by,default,for,the,supplied,link,test,context,test,context,param,test,context,the,test,context,for,which,the,default,rollback,flag,should,be,retrieved,return,the,em,default,rollback,em,flag,for,the,supplied,test,context,throws,exception,if,an,error,occurs,while,determining,the,default,rollback,flag;protected,final,boolean,is,default,rollback,test,context,test,context,throws,exception,return,retrieve,configuration,attributes,test,context,is,default,rollback
TransactionalTestExecutionListener -> protected final boolean isDefaultRollback(TestContext testContext) throws Exception;1408048216;Determine whether or not to rollback transactions by default for the_supplied {@link TestContext test context}._@param testContext the test context for which the default rollback flag_should be retrieved_@return the <em>default rollback</em> flag for the supplied test context_@throws Exception if an error occurs while determining the default rollback flag;protected final boolean isDefaultRollback(TestContext testContext) throws Exception {_		return retrieveConfigurationAttributes(testContext).isDefaultRollback()__	};determine,whether,or,not,to,rollback,transactions,by,default,for,the,supplied,link,test,context,test,context,param,test,context,the,test,context,for,which,the,default,rollback,flag,should,be,retrieved,return,the,em,default,rollback,em,flag,for,the,supplied,test,context,throws,exception,if,an,error,occurs,while,determining,the,default,rollback,flag;protected,final,boolean,is,default,rollback,test,context,test,context,throws,exception,return,retrieve,configuration,attributes,test,context,is,default,rollback
TransactionalTestExecutionListener -> protected final boolean isDefaultRollback(TestContext testContext) throws Exception;1413848647;Determine whether or not to rollback transactions by default for the_supplied {@link TestContext test context}._@param testContext the test context for which the default rollback flag_should be retrieved_@return the <em>default rollback</em> flag for the supplied test context_@throws Exception if an error occurs while determining the default rollback flag;protected final boolean isDefaultRollback(TestContext testContext) throws Exception {_		return retrieveConfigurationAttributes(testContext).isDefaultRollback()__	};determine,whether,or,not,to,rollback,transactions,by,default,for,the,supplied,link,test,context,test,context,param,test,context,the,test,context,for,which,the,default,rollback,flag,should,be,retrieved,return,the,em,default,rollback,em,flag,for,the,supplied,test,context,throws,exception,if,an,error,occurs,while,determining,the,default,rollback,flag;protected,final,boolean,is,default,rollback,test,context,test,context,throws,exception,return,retrieve,configuration,attributes,test,context,is,default,rollback
TransactionalTestExecutionListener -> protected final boolean isDefaultRollback(TestContext testContext) throws Exception;1431568199;Determine whether or not to rollback transactions by default for the_supplied {@link TestContext test context}._@param testContext the test context for which the default rollback flag_should be retrieved_@return the <em>default rollback</em> flag for the supplied test context_@throws Exception if an error occurs while determining the default rollback flag;protected final boolean isDefaultRollback(TestContext testContext) throws Exception {_		return retrieveConfigurationAttributes(testContext).isDefaultRollback()__	};determine,whether,or,not,to,rollback,transactions,by,default,for,the,supplied,link,test,context,test,context,param,test,context,the,test,context,for,which,the,default,rollback,flag,should,be,retrieved,return,the,em,default,rollback,em,flag,for,the,supplied,test,context,throws,exception,if,an,error,occurs,while,determining,the,default,rollback,flag;protected,final,boolean,is,default,rollback,test,context,test,context,throws,exception,return,retrieve,configuration,attributes,test,context,is,default,rollback
TransactionalTestExecutionListener -> protected final boolean isDefaultRollback(TestContext testContext) throws Exception;1432125256;Determine whether or not to rollback transactions by default for the_supplied {@link TestContext test context}._@param testContext the test context for which the default rollback flag_should be retrieved_@return the <em>default rollback</em> flag for the supplied test context_@throws Exception if an error occurs while determining the default rollback flag;protected final boolean isDefaultRollback(TestContext testContext) throws Exception {_		return retrieveConfigurationAttributes(testContext).isDefaultRollback()__	};determine,whether,or,not,to,rollback,transactions,by,default,for,the,supplied,link,test,context,test,context,param,test,context,the,test,context,for,which,the,default,rollback,flag,should,be,retrieved,return,the,em,default,rollback,em,flag,for,the,supplied,test,context,throws,exception,if,an,error,occurs,while,determining,the,default,rollback,flag;protected,final,boolean,is,default,rollback,test,context,test,context,throws,exception,return,retrieve,configuration,attributes,test,context,is,default,rollback
TransactionalTestExecutionListener -> protected final boolean isDefaultRollback(TestContext testContext) throws Exception;1432856630;Determine whether or not to rollback transactions by default for the_supplied {@link TestContext test context}._@param testContext the test context for which the default rollback flag_should be retrieved_@return the <em>default rollback</em> flag for the supplied test context_@throws Exception if an error occurs while determining the default rollback flag;protected final boolean isDefaultRollback(TestContext testContext) throws Exception {_		return retrieveConfigurationAttributes(testContext).isDefaultRollback()__	};determine,whether,or,not,to,rollback,transactions,by,default,for,the,supplied,link,test,context,test,context,param,test,context,the,test,context,for,which,the,default,rollback,flag,should,be,retrieved,return,the,em,default,rollback,em,flag,for,the,supplied,test,context,throws,exception,if,an,error,occurs,while,determining,the,default,rollback,flag;protected,final,boolean,is,default,rollback,test,context,test,context,throws,exception,return,retrieve,configuration,attributes,test,context,is,default,rollback
TransactionalTestExecutionListener -> protected final boolean isDefaultRollback(TestContext testContext) throws Exception;1434234880;Determine whether or not to rollback transactions by default for the_supplied {@link TestContext test context}._@param testContext the test context for which the default rollback flag_should be retrieved_@return the <em>default rollback</em> flag for the supplied test context_@throws Exception if an error occurs while determining the default rollback flag;protected final boolean isDefaultRollback(TestContext testContext) throws Exception {_		return retrieveConfigurationAttributes(testContext).isDefaultRollback()__	};determine,whether,or,not,to,rollback,transactions,by,default,for,the,supplied,link,test,context,test,context,param,test,context,the,test,context,for,which,the,default,rollback,flag,should,be,retrieved,return,the,em,default,rollback,em,flag,for,the,supplied,test,context,throws,exception,if,an,error,occurs,while,determining,the,default,rollback,flag;protected,final,boolean,is,default,rollback,test,context,test,context,throws,exception,return,retrieve,configuration,attributes,test,context,is,default,rollback
TransactionalTestExecutionListener -> protected final boolean isDefaultRollback(TestContext testContext) throws Exception;1434720443;Determine whether or not to rollback transactions by default for the_supplied {@link TestContext test context}._@param testContext the test context for which the default rollback flag_should be retrieved_@return the <em>default rollback</em> flag for the supplied test context_@throws Exception if an error occurs while determining the default rollback flag;protected final boolean isDefaultRollback(TestContext testContext) throws Exception {_		return retrieveConfigurationAttributes(testContext).isDefaultRollback()__	};determine,whether,or,not,to,rollback,transactions,by,default,for,the,supplied,link,test,context,test,context,param,test,context,the,test,context,for,which,the,default,rollback,flag,should,be,retrieved,return,the,em,default,rollback,em,flag,for,the,supplied,test,context,throws,exception,if,an,error,occurs,while,determining,the,default,rollback,flag;protected,final,boolean,is,default,rollback,test,context,test,context,throws,exception,return,retrieve,configuration,attributes,test,context,is,default,rollback
TransactionalTestExecutionListener -> protected final boolean isDefaultRollback(TestContext testContext) throws Exception;1434817656;Determine whether or not to rollback transactions by default for the_supplied {@link TestContext test context}._@param testContext the test context for which the default rollback flag_should be retrieved_@return the <em>default rollback</em> flag for the supplied test context_@throws Exception if an error occurs while determining the default rollback flag;protected final boolean isDefaultRollback(TestContext testContext) throws Exception {_		return retrieveConfigurationAttributes(testContext).isDefaultRollback()__	};determine,whether,or,not,to,rollback,transactions,by,default,for,the,supplied,link,test,context,test,context,param,test,context,the,test,context,for,which,the,default,rollback,flag,should,be,retrieved,return,the,em,default,rollback,em,flag,for,the,supplied,test,context,throws,exception,if,an,error,occurs,while,determining,the,default,rollback,flag;protected,final,boolean,is,default,rollback,test,context,test,context,throws,exception,return,retrieve,configuration,attributes,test,context,is,default,rollback
TransactionalTestExecutionListener -> protected final boolean isDefaultRollback(TestContext testContext) throws Exception;1437841346;Determine whether or not to rollback transactions by default for the_supplied {@linkplain TestContext test context}._<p>Supports {@link Rollback @Rollback} or_{@link TransactionConfiguration @TransactionConfiguration} at the_class-level._@param testContext the test context for which the default rollback flag_should be retrieved_@return the <em>default rollback</em> flag for the supplied test context_@throws Exception if an error occurs while determining the default rollback flag;protected final boolean isDefaultRollback(TestContext testContext) throws Exception {_		Class<?> testClass = testContext.getTestClass()__		Rollback rollback = findAnnotation(testClass, Rollback.class)__		boolean rollbackPresent = (rollback != null)__		TransactionConfigurationAttributes txConfigAttributes = retrieveConfigurationAttributes(testContext)___		if (rollbackPresent && txConfigAttributes != defaultTxConfigAttributes) {_			throw new IllegalStateException(String.format("Test class [%s] is annotated with both @Rollback "_					+ "and @TransactionConfiguration, but only one is permitted.", testClass.getName()))__		}__		if (rollbackPresent) {_			boolean defaultRollback = rollback.value()__			if (logger.isDebugEnabled()) {_				logger.debug(String.format("Retrieved default @Rollback(%s) for test class [%s].", defaultRollback,_					testClass.getName()))__			}_			return defaultRollback__		}__		_		return txConfigAttributes.isDefaultRollback()__	};determine,whether,or,not,to,rollback,transactions,by,default,for,the,supplied,linkplain,test,context,test,context,p,supports,link,rollback,rollback,or,link,transaction,configuration,transaction,configuration,at,the,class,level,param,test,context,the,test,context,for,which,the,default,rollback,flag,should,be,retrieved,return,the,em,default,rollback,em,flag,for,the,supplied,test,context,throws,exception,if,an,error,occurs,while,determining,the,default,rollback,flag;protected,final,boolean,is,default,rollback,test,context,test,context,throws,exception,class,test,class,test,context,get,test,class,rollback,rollback,find,annotation,test,class,rollback,class,boolean,rollback,present,rollback,null,transaction,configuration,attributes,tx,config,attributes,retrieve,configuration,attributes,test,context,if,rollback,present,tx,config,attributes,default,tx,config,attributes,throw,new,illegal,state,exception,string,format,test,class,s,is,annotated,with,both,rollback,and,transaction,configuration,but,only,one,is,permitted,test,class,get,name,if,rollback,present,boolean,default,rollback,rollback,value,if,logger,is,debug,enabled,logger,debug,string,format,retrieved,default,rollback,s,for,test,class,s,default,rollback,test,class,get,name,return,default,rollback,return,tx,config,attributes,is,default,rollback
TransactionalTestExecutionListener -> protected final boolean isDefaultRollback(TestContext testContext) throws Exception;1437851372;Determine whether or not to rollback transactions by default for the_supplied {@linkplain TestContext test context}._<p>Supports {@link Rollback @Rollback} or_{@link TransactionConfiguration @TransactionConfiguration} at the_class-level._@param testContext the test context for which the default rollback flag_should be retrieved_@return the <em>default rollback</em> flag for the supplied test context_@throws Exception if an error occurs while determining the default rollback flag;protected final boolean isDefaultRollback(TestContext testContext) throws Exception {_		Class<?> testClass = testContext.getTestClass()__		Rollback rollback = findAnnotation(testClass, Rollback.class)__		boolean rollbackPresent = (rollback != null)__		TransactionConfigurationAttributes txConfigAttributes = retrieveConfigurationAttributes(testContext)___		if (rollbackPresent && txConfigAttributes != defaultTxConfigAttributes) {_			throw new IllegalStateException(String.format("Test class [%s] is annotated with both @Rollback "_					+ "and @TransactionConfiguration, but only one is permitted.", testClass.getName()))__		}__		if (rollbackPresent) {_			boolean defaultRollback = rollback.value()__			if (logger.isDebugEnabled()) {_				logger.debug(String.format("Retrieved default @Rollback(%s) for test class [%s].", defaultRollback,_					testClass.getName()))__			}_			return defaultRollback__		}__		_		return txConfigAttributes.isDefaultRollback()__	};determine,whether,or,not,to,rollback,transactions,by,default,for,the,supplied,linkplain,test,context,test,context,p,supports,link,rollback,rollback,or,link,transaction,configuration,transaction,configuration,at,the,class,level,param,test,context,the,test,context,for,which,the,default,rollback,flag,should,be,retrieved,return,the,em,default,rollback,em,flag,for,the,supplied,test,context,throws,exception,if,an,error,occurs,while,determining,the,default,rollback,flag;protected,final,boolean,is,default,rollback,test,context,test,context,throws,exception,class,test,class,test,context,get,test,class,rollback,rollback,find,annotation,test,class,rollback,class,boolean,rollback,present,rollback,null,transaction,configuration,attributes,tx,config,attributes,retrieve,configuration,attributes,test,context,if,rollback,present,tx,config,attributes,default,tx,config,attributes,throw,new,illegal,state,exception,string,format,test,class,s,is,annotated,with,both,rollback,and,transaction,configuration,but,only,one,is,permitted,test,class,get,name,if,rollback,present,boolean,default,rollback,rollback,value,if,logger,is,debug,enabled,logger,debug,string,format,retrieved,default,rollback,s,for,test,class,s,default,rollback,test,class,get,name,return,default,rollback,return,tx,config,attributes,is,default,rollback
TransactionalTestExecutionListener -> protected final boolean isDefaultRollback(TestContext testContext) throws Exception;1467994604;Determine whether or not to rollback transactions by default for the_supplied {@linkplain TestContext test context}._<p>Supports {@link Rollback @Rollback} or {@link Commit @Commit} at the_class-level._@param testContext the test context for which the default rollback flag_should be retrieved_@return the <em>default rollback</em> flag for the supplied test context_@throws Exception if an error occurs while determining the default rollback flag;protected final boolean isDefaultRollback(TestContext testContext) throws Exception {_		Class<?> testClass = testContext.getTestClass()__		Rollback rollback = AnnotatedElementUtils.findMergedAnnotation(testClass, Rollback.class)__		boolean rollbackPresent = (rollback != null)___		if (rollbackPresent) {_			boolean defaultRollback = rollback.value()__			if (logger.isDebugEnabled()) {_				logger.debug(String.format("Retrieved default @Rollback(%s) for test class [%s].", defaultRollback,_					testClass.getName()))__			}_			return defaultRollback__		}__		_		return true__	};determine,whether,or,not,to,rollback,transactions,by,default,for,the,supplied,linkplain,test,context,test,context,p,supports,link,rollback,rollback,or,link,commit,commit,at,the,class,level,param,test,context,the,test,context,for,which,the,default,rollback,flag,should,be,retrieved,return,the,em,default,rollback,em,flag,for,the,supplied,test,context,throws,exception,if,an,error,occurs,while,determining,the,default,rollback,flag;protected,final,boolean,is,default,rollback,test,context,test,context,throws,exception,class,test,class,test,context,get,test,class,rollback,rollback,annotated,element,utils,find,merged,annotation,test,class,rollback,class,boolean,rollback,present,rollback,null,if,rollback,present,boolean,default,rollback,rollback,value,if,logger,is,debug,enabled,logger,debug,string,format,retrieved,default,rollback,s,for,test,class,s,default,rollback,test,class,get,name,return,default,rollback,return,true
TransactionalTestExecutionListener -> protected final boolean isDefaultRollback(TestContext testContext) throws Exception;1468334463;Determine whether or not to rollback transactions by default for the_supplied {@linkplain TestContext test context}._<p>Supports {@link Rollback @Rollback} or {@link Commit @Commit} at the_class-level._@param testContext the test context for which the default rollback flag_should be retrieved_@return the <em>default rollback</em> flag for the supplied test context_@throws Exception if an error occurs while determining the default rollback flag;protected final boolean isDefaultRollback(TestContext testContext) throws Exception {_		Class<?> testClass = testContext.getTestClass()__		Rollback rollback = AnnotatedElementUtils.findMergedAnnotation(testClass, Rollback.class)__		boolean rollbackPresent = (rollback != null)___		if (rollbackPresent) {_			boolean defaultRollback = rollback.value()__			if (logger.isDebugEnabled()) {_				logger.debug(String.format("Retrieved default @Rollback(%s) for test class [%s].", defaultRollback,_					testClass.getName()))__			}_			return defaultRollback__		}__		_		return true__	};determine,whether,or,not,to,rollback,transactions,by,default,for,the,supplied,linkplain,test,context,test,context,p,supports,link,rollback,rollback,or,link,commit,commit,at,the,class,level,param,test,context,the,test,context,for,which,the,default,rollback,flag,should,be,retrieved,return,the,em,default,rollback,em,flag,for,the,supplied,test,context,throws,exception,if,an,error,occurs,while,determining,the,default,rollback,flag;protected,final,boolean,is,default,rollback,test,context,test,context,throws,exception,class,test,class,test,context,get,test,class,rollback,rollback,annotated,element,utils,find,merged,annotation,test,class,rollback,class,boolean,rollback,present,rollback,null,if,rollback,present,boolean,default,rollback,rollback,value,if,logger,is,debug,enabled,logger,debug,string,format,retrieved,default,rollback,s,for,test,class,s,default,rollback,test,class,get,name,return,default,rollback,return,true
TransactionalTestExecutionListener -> protected final boolean isDefaultRollback(TestContext testContext) throws Exception;1496955179;Determine whether or not to rollback transactions by default for the_supplied {@linkplain TestContext test context}._<p>Supports {@link Rollback @Rollback} or {@link Commit @Commit} at the_class-level._@param testContext the test context for which the default rollback flag_should be retrieved_@return the <em>default rollback</em> flag for the supplied test context_@throws Exception if an error occurs while determining the default rollback flag;protected final boolean isDefaultRollback(TestContext testContext) throws Exception {_		Class<?> testClass = testContext.getTestClass()__		Rollback rollback = AnnotatedElementUtils.findMergedAnnotation(testClass, Rollback.class)__		boolean rollbackPresent = (rollback != null)___		if (rollbackPresent) {_			boolean defaultRollback = rollback.value()__			if (logger.isDebugEnabled()) {_				logger.debug(String.format("Retrieved default @Rollback(%s) for test class [%s].", defaultRollback,_					testClass.getName()))__			}_			return defaultRollback__		}__		_		return true__	};determine,whether,or,not,to,rollback,transactions,by,default,for,the,supplied,linkplain,test,context,test,context,p,supports,link,rollback,rollback,or,link,commit,commit,at,the,class,level,param,test,context,the,test,context,for,which,the,default,rollback,flag,should,be,retrieved,return,the,em,default,rollback,em,flag,for,the,supplied,test,context,throws,exception,if,an,error,occurs,while,determining,the,default,rollback,flag;protected,final,boolean,is,default,rollback,test,context,test,context,throws,exception,class,test,class,test,context,get,test,class,rollback,rollback,annotated,element,utils,find,merged,annotation,test,class,rollback,class,boolean,rollback,present,rollback,null,if,rollback,present,boolean,default,rollback,rollback,value,if,logger,is,debug,enabled,logger,debug,string,format,retrieved,default,rollback,s,for,test,class,s,default,rollback,test,class,get,name,return,default,rollback,return,true
TransactionalTestExecutionListener -> protected final boolean isDefaultRollback(TestContext testContext) throws Exception;1498780456;Determine whether or not to rollback transactions by default for the_supplied {@linkplain TestContext test context}._<p>Supports {@link Rollback @Rollback} or {@link Commit @Commit} at the_class-level._@param testContext the test context for which the default rollback flag_should be retrieved_@return the <em>default rollback</em> flag for the supplied test context_@throws Exception if an error occurs while determining the default rollback flag;protected final boolean isDefaultRollback(TestContext testContext) throws Exception {_		Class<?> testClass = testContext.getTestClass()__		Rollback rollback = AnnotatedElementUtils.findMergedAnnotation(testClass, Rollback.class)__		boolean rollbackPresent = (rollback != null)___		if (rollbackPresent) {_			boolean defaultRollback = rollback.value()__			if (logger.isDebugEnabled()) {_				logger.debug(String.format("Retrieved default @Rollback(%s) for test class [%s].", defaultRollback,_					testClass.getName()))__			}_			return defaultRollback__		}__		_		return true__	};determine,whether,or,not,to,rollback,transactions,by,default,for,the,supplied,linkplain,test,context,test,context,p,supports,link,rollback,rollback,or,link,commit,commit,at,the,class,level,param,test,context,the,test,context,for,which,the,default,rollback,flag,should,be,retrieved,return,the,em,default,rollback,em,flag,for,the,supplied,test,context,throws,exception,if,an,error,occurs,while,determining,the,default,rollback,flag;protected,final,boolean,is,default,rollback,test,context,test,context,throws,exception,class,test,class,test,context,get,test,class,rollback,rollback,annotated,element,utils,find,merged,annotation,test,class,rollback,class,boolean,rollback,present,rollback,null,if,rollback,present,boolean,default,rollback,rollback,value,if,logger,is,debug,enabled,logger,debug,string,format,retrieved,default,rollback,s,for,test,class,s,default,rollback,test,class,get,name,return,default,rollback,return,true
TransactionalTestExecutionListener -> protected final boolean isDefaultRollback(TestContext testContext) throws Exception;1520251235;Determine whether or not to rollback transactions by default for the_supplied {@linkplain TestContext test context}._<p>Supports {@link Rollback @Rollback} or {@link Commit @Commit} at the_class-level._@param testContext the test context for which the default rollback flag_should be retrieved_@return the <em>default rollback</em> flag for the supplied test context_@throws Exception if an error occurs while determining the default rollback flag;protected final boolean isDefaultRollback(TestContext testContext) throws Exception {_		Class<?> testClass = testContext.getTestClass()__		Rollback rollback = AnnotatedElementUtils.findMergedAnnotation(testClass, Rollback.class)__		boolean rollbackPresent = (rollback != null)___		if (rollbackPresent) {_			boolean defaultRollback = rollback.value()__			if (logger.isDebugEnabled()) {_				logger.debug(String.format("Retrieved default @Rollback(%s) for test class [%s].",_						defaultRollback, testClass.getName()))__			}_			return defaultRollback__		}__		_		return true__	};determine,whether,or,not,to,rollback,transactions,by,default,for,the,supplied,linkplain,test,context,test,context,p,supports,link,rollback,rollback,or,link,commit,commit,at,the,class,level,param,test,context,the,test,context,for,which,the,default,rollback,flag,should,be,retrieved,return,the,em,default,rollback,em,flag,for,the,supplied,test,context,throws,exception,if,an,error,occurs,while,determining,the,default,rollback,flag;protected,final,boolean,is,default,rollback,test,context,test,context,throws,exception,class,test,class,test,context,get,test,class,rollback,rollback,annotated,element,utils,find,merged,annotation,test,class,rollback,class,boolean,rollback,present,rollback,null,if,rollback,present,boolean,default,rollback,rollback,value,if,logger,is,debug,enabled,logger,debug,string,format,retrieved,default,rollback,s,for,test,class,s,default,rollback,test,class,get,name,return,default,rollback,return,true
TransactionalTestExecutionListener -> protected PlatformTransactionManager getTransactionManager(TestContext testContext, String qualifier);1382920864;Get the {@link PlatformTransactionManager transaction manager} to use_for the supplied {@link TestContext test context} and {@code qualifier}._<p>Delegates to {@link #getTransactionManager(TestContext)} if the_supplied {@code qualifier} is {@code null} or empty._@param testContext the test context for which the transaction manager_should be retrieved_@param qualifier the qualifier for selecting between multiple bean matches__may be {@code null} or empty_@return the transaction manager to use, or {@code null} if not found_@throws BeansException if an error occurs while retrieving the transaction manager_@see #getTransactionManager(TestContext);protected PlatformTransactionManager getTransactionManager(TestContext testContext, String qualifier) {_		_		if (StringUtils.hasText(qualifier)) {_			try {_				_				_				_				BeanFactory bf = testContext.getApplicationContext().getAutowireCapableBeanFactory()___				return BeanFactoryAnnotationUtils.qualifiedBeanOfType(bf, PlatformTransactionManager.class, qualifier)__			}_			catch (RuntimeException ex) {_				if (logger.isWarnEnabled()) {_					logger.warn("Caught exception while retrieving transaction manager for test context " + testContext_							+ " and qualifier [" + qualifier + "]", ex)__				}_				throw ex__			}_		}__		_		return getTransactionManager(testContext)__	};get,the,link,platform,transaction,manager,transaction,manager,to,use,for,the,supplied,link,test,context,test,context,and,code,qualifier,p,delegates,to,link,get,transaction,manager,test,context,if,the,supplied,code,qualifier,is,code,null,or,empty,param,test,context,the,test,context,for,which,the,transaction,manager,should,be,retrieved,param,qualifier,the,qualifier,for,selecting,between,multiple,bean,matches,may,be,code,null,or,empty,return,the,transaction,manager,to,use,or,code,null,if,not,found,throws,beans,exception,if,an,error,occurs,while,retrieving,the,transaction,manager,see,get,transaction,manager,test,context;protected,platform,transaction,manager,get,transaction,manager,test,context,test,context,string,qualifier,if,string,utils,has,text,qualifier,try,bean,factory,bf,test,context,get,application,context,get,autowire,capable,bean,factory,return,bean,factory,annotation,utils,qualified,bean,of,type,bf,platform,transaction,manager,class,qualifier,catch,runtime,exception,ex,if,logger,is,warn,enabled,logger,warn,caught,exception,while,retrieving,transaction,manager,for,test,context,test,context,and,qualifier,qualifier,ex,throw,ex,return,get,transaction,manager,test,context
TransactionalTestExecutionListener -> protected PlatformTransactionManager getTransactionManager(TestContext testContext, String qualifier);1385499540;Get the {@link PlatformTransactionManager transaction manager} to use_for the supplied {@link TestContext test context} and {@code qualifier}._<p>Delegates to {@link #getTransactionManager(TestContext)} if the_supplied {@code qualifier} is {@code null} or empty._@param testContext the test context for which the transaction manager_should be retrieved_@param qualifier the qualifier for selecting between multiple bean matches__may be {@code null} or empty_@return the transaction manager to use, or {@code null} if not found_@throws BeansException if an error occurs while retrieving the transaction manager_@see #getTransactionManager(TestContext);protected PlatformTransactionManager getTransactionManager(TestContext testContext, String qualifier) {_		_		if (StringUtils.hasText(qualifier)) {_			try {_				_				_				_				BeanFactory bf = testContext.getApplicationContext().getAutowireCapableBeanFactory()___				return BeanFactoryAnnotationUtils.qualifiedBeanOfType(bf, PlatformTransactionManager.class, qualifier)__			}_			catch (RuntimeException ex) {_				if (logger.isWarnEnabled()) {_					logger.warn("Caught exception while retrieving transaction manager for test context " + testContext_							+ " and qualifier [" + qualifier + "]", ex)__				}_				throw ex__			}_		}__		_		return getTransactionManager(testContext)__	};get,the,link,platform,transaction,manager,transaction,manager,to,use,for,the,supplied,link,test,context,test,context,and,code,qualifier,p,delegates,to,link,get,transaction,manager,test,context,if,the,supplied,code,qualifier,is,code,null,or,empty,param,test,context,the,test,context,for,which,the,transaction,manager,should,be,retrieved,param,qualifier,the,qualifier,for,selecting,between,multiple,bean,matches,may,be,code,null,or,empty,return,the,transaction,manager,to,use,or,code,null,if,not,found,throws,beans,exception,if,an,error,occurs,while,retrieving,the,transaction,manager,see,get,transaction,manager,test,context;protected,platform,transaction,manager,get,transaction,manager,test,context,test,context,string,qualifier,if,string,utils,has,text,qualifier,try,bean,factory,bf,test,context,get,application,context,get,autowire,capable,bean,factory,return,bean,factory,annotation,utils,qualified,bean,of,type,bf,platform,transaction,manager,class,qualifier,catch,runtime,exception,ex,if,logger,is,warn,enabled,logger,warn,caught,exception,while,retrieving,transaction,manager,for,test,context,test,context,and,qualifier,qualifier,ex,throw,ex,return,get,transaction,manager,test,context
TransactionalTestExecutionListener -> protected PlatformTransactionManager getTransactionManager(TestContext testContext, String qualifier);1389966876;Get the {@link PlatformTransactionManager transaction manager} to use_for the supplied {@link TestContext test context} and {@code qualifier}._<p>Delegates to {@link #getTransactionManager(TestContext)} if the_supplied {@code qualifier} is {@code null} or empty._@param testContext the test context for which the transaction manager_should be retrieved_@param qualifier the qualifier for selecting between multiple bean matches__may be {@code null} or empty_@return the transaction manager to use, or {@code null} if not found_@throws BeansException if an error occurs while retrieving the transaction manager_@see #getTransactionManager(TestContext);protected PlatformTransactionManager getTransactionManager(TestContext testContext, String qualifier) {_		_		if (StringUtils.hasText(qualifier)) {_			try {_				_				_				_				BeanFactory bf = testContext.getApplicationContext().getAutowireCapableBeanFactory()___				return BeanFactoryAnnotationUtils.qualifiedBeanOfType(bf, PlatformTransactionManager.class, qualifier)__			}_			catch (RuntimeException ex) {_				if (logger.isWarnEnabled()) {_					logger.warn("Caught exception while retrieving transaction manager for test context " + testContext_							+ " and qualifier [" + qualifier + "]", ex)__				}_				throw ex__			}_		}__		_		return getTransactionManager(testContext)__	};get,the,link,platform,transaction,manager,transaction,manager,to,use,for,the,supplied,link,test,context,test,context,and,code,qualifier,p,delegates,to,link,get,transaction,manager,test,context,if,the,supplied,code,qualifier,is,code,null,or,empty,param,test,context,the,test,context,for,which,the,transaction,manager,should,be,retrieved,param,qualifier,the,qualifier,for,selecting,between,multiple,bean,matches,may,be,code,null,or,empty,return,the,transaction,manager,to,use,or,code,null,if,not,found,throws,beans,exception,if,an,error,occurs,while,retrieving,the,transaction,manager,see,get,transaction,manager,test,context;protected,platform,transaction,manager,get,transaction,manager,test,context,test,context,string,qualifier,if,string,utils,has,text,qualifier,try,bean,factory,bf,test,context,get,application,context,get,autowire,capable,bean,factory,return,bean,factory,annotation,utils,qualified,bean,of,type,bf,platform,transaction,manager,class,qualifier,catch,runtime,exception,ex,if,logger,is,warn,enabled,logger,warn,caught,exception,while,retrieving,transaction,manager,for,test,context,test,context,and,qualifier,qualifier,ex,throw,ex,return,get,transaction,manager,test,context
TransactionalTestExecutionListener -> protected PlatformTransactionManager getTransactionManager(TestContext testContext, String qualifier);1401991965;Get the {@link PlatformTransactionManager transaction manager} to use_for the supplied {@linkplain TestContext test context} and {@code qualifier}._<p>Delegates to {@link #getTransactionManager(TestContext)} if the_supplied {@code qualifier} is {@code null} or empty._@param testContext the test context for which the transaction manager_should be retrieved_@param qualifier the qualifier for selecting between multiple bean matches__may be {@code null} or empty_@return the transaction manager to use, or {@code null} if not found_@throws BeansException if an error occurs while retrieving the transaction manager_@see #getTransactionManager(TestContext);protected PlatformTransactionManager getTransactionManager(TestContext testContext, String qualifier) {_		_		if (StringUtils.hasText(qualifier)) {_			try {_				_				_				_				BeanFactory bf = testContext.getApplicationContext().getAutowireCapableBeanFactory()___				return BeanFactoryAnnotationUtils.qualifiedBeanOfType(bf, PlatformTransactionManager.class, qualifier)__			}_			catch (RuntimeException ex) {_				if (logger.isWarnEnabled()) {_					logger.warn("Caught exception while retrieving transaction manager for test context " + testContext_							+ " and qualifier [" + qualifier + "]", ex)__				}_				throw ex__			}_		}__		_		return getTransactionManager(testContext)__	};get,the,link,platform,transaction,manager,transaction,manager,to,use,for,the,supplied,linkplain,test,context,test,context,and,code,qualifier,p,delegates,to,link,get,transaction,manager,test,context,if,the,supplied,code,qualifier,is,code,null,or,empty,param,test,context,the,test,context,for,which,the,transaction,manager,should,be,retrieved,param,qualifier,the,qualifier,for,selecting,between,multiple,bean,matches,may,be,code,null,or,empty,return,the,transaction,manager,to,use,or,code,null,if,not,found,throws,beans,exception,if,an,error,occurs,while,retrieving,the,transaction,manager,see,get,transaction,manager,test,context;protected,platform,transaction,manager,get,transaction,manager,test,context,test,context,string,qualifier,if,string,utils,has,text,qualifier,try,bean,factory,bf,test,context,get,application,context,get,autowire,capable,bean,factory,return,bean,factory,annotation,utils,qualified,bean,of,type,bf,platform,transaction,manager,class,qualifier,catch,runtime,exception,ex,if,logger,is,warn,enabled,logger,warn,caught,exception,while,retrieving,transaction,manager,for,test,context,test,context,and,qualifier,qualifier,ex,throw,ex,return,get,transaction,manager,test,context
TransactionalTestExecutionListener -> protected PlatformTransactionManager getTransactionManager(TestContext testContext, String qualifier);1404334604;Get the {@link PlatformTransactionManager transaction manager} to use_for the supplied {@linkplain TestContext test context} and {@code qualifier}._<p>Delegates to {@link #getTransactionManager(TestContext)} if the_supplied {@code qualifier} is {@code null} or empty._@param testContext the test context for which the transaction manager_should be retrieved_@param qualifier the qualifier for selecting between multiple bean matches__may be {@code null} or empty_@return the transaction manager to use, or {@code null} if not found_@throws BeansException if an error occurs while retrieving the transaction manager_@see #getTransactionManager(TestContext);protected PlatformTransactionManager getTransactionManager(TestContext testContext, String qualifier) {_		_		if (StringUtils.hasText(qualifier)) {_			try {_				_				_				_				BeanFactory bf = testContext.getApplicationContext().getAutowireCapableBeanFactory()___				return BeanFactoryAnnotationUtils.qualifiedBeanOfType(bf, PlatformTransactionManager.class, qualifier)__			}_			catch (RuntimeException ex) {_				if (logger.isWarnEnabled()) {_					logger.warn("Caught exception while retrieving transaction manager for test context " + testContext_							+ " and qualifier [" + qualifier + "]", ex)__				}_				throw ex__			}_		}__		_		return getTransactionManager(testContext)__	};get,the,link,platform,transaction,manager,transaction,manager,to,use,for,the,supplied,linkplain,test,context,test,context,and,code,qualifier,p,delegates,to,link,get,transaction,manager,test,context,if,the,supplied,code,qualifier,is,code,null,or,empty,param,test,context,the,test,context,for,which,the,transaction,manager,should,be,retrieved,param,qualifier,the,qualifier,for,selecting,between,multiple,bean,matches,may,be,code,null,or,empty,return,the,transaction,manager,to,use,or,code,null,if,not,found,throws,beans,exception,if,an,error,occurs,while,retrieving,the,transaction,manager,see,get,transaction,manager,test,context;protected,platform,transaction,manager,get,transaction,manager,test,context,test,context,string,qualifier,if,string,utils,has,text,qualifier,try,bean,factory,bf,test,context,get,application,context,get,autowire,capable,bean,factory,return,bean,factory,annotation,utils,qualified,bean,of,type,bf,platform,transaction,manager,class,qualifier,catch,runtime,exception,ex,if,logger,is,warn,enabled,logger,warn,caught,exception,while,retrieving,transaction,manager,for,test,context,test,context,and,qualifier,qualifier,ex,throw,ex,return,get,transaction,manager,test,context
TransactionalTestExecutionListener -> protected PlatformTransactionManager getTransactionManager(TestContext testContext, String qualifier);1405645143;Get the {@link PlatformTransactionManager transaction manager} to use_for the supplied {@linkplain TestContext test context} and {@code qualifier}._<p>Delegates to {@link #getTransactionManager(TestContext)} if the_supplied {@code qualifier} is {@code null} or empty._@param testContext the test context for which the transaction manager_should be retrieved_@param qualifier the qualifier for selecting between multiple bean matches__may be {@code null} or empty_@return the transaction manager to use, or {@code null} if not found_@throws BeansException if an error occurs while retrieving the transaction manager_@see #getTransactionManager(TestContext);protected PlatformTransactionManager getTransactionManager(TestContext testContext, String qualifier) {_		_		if (StringUtils.hasText(qualifier)) {_			try {_				_				_				_				BeanFactory bf = testContext.getApplicationContext().getAutowireCapableBeanFactory()___				return BeanFactoryAnnotationUtils.qualifiedBeanOfType(bf, PlatformTransactionManager.class, qualifier)__			}_			catch (RuntimeException ex) {_				if (logger.isWarnEnabled()) {_					logger.warn(_						String.format(_							"Caught exception while retrieving transaction manager with qualifier '%s' for test context %s",_							qualifier, testContext), ex)__				}_				throw ex__			}_		}__		_		return getTransactionManager(testContext)__	};get,the,link,platform,transaction,manager,transaction,manager,to,use,for,the,supplied,linkplain,test,context,test,context,and,code,qualifier,p,delegates,to,link,get,transaction,manager,test,context,if,the,supplied,code,qualifier,is,code,null,or,empty,param,test,context,the,test,context,for,which,the,transaction,manager,should,be,retrieved,param,qualifier,the,qualifier,for,selecting,between,multiple,bean,matches,may,be,code,null,or,empty,return,the,transaction,manager,to,use,or,code,null,if,not,found,throws,beans,exception,if,an,error,occurs,while,retrieving,the,transaction,manager,see,get,transaction,manager,test,context;protected,platform,transaction,manager,get,transaction,manager,test,context,test,context,string,qualifier,if,string,utils,has,text,qualifier,try,bean,factory,bf,test,context,get,application,context,get,autowire,capable,bean,factory,return,bean,factory,annotation,utils,qualified,bean,of,type,bf,platform,transaction,manager,class,qualifier,catch,runtime,exception,ex,if,logger,is,warn,enabled,logger,warn,string,format,caught,exception,while,retrieving,transaction,manager,with,qualifier,s,for,test,context,s,qualifier,test,context,ex,throw,ex,return,get,transaction,manager,test,context
TransactionalTestExecutionListener -> protected PlatformTransactionManager getTransactionManager(TestContext testContext, String qualifier);1405698612;Get the {@link PlatformTransactionManager transaction manager} to use_for the supplied {@linkplain TestContext test context} and {@code qualifier}._<p>Delegates to {@link #getTransactionManager(TestContext)} if the_supplied {@code qualifier} is {@code null} or empty._@param testContext the test context for which the transaction manager_should be retrieved_@param qualifier the qualifier for selecting between multiple bean matches__may be {@code null} or empty_@return the transaction manager to use, or {@code null} if not found_@throws BeansException if an error occurs while retrieving the transaction manager_@see #getTransactionManager(TestContext);protected PlatformTransactionManager getTransactionManager(TestContext testContext, String qualifier) {_		_		if (StringUtils.hasText(qualifier)) {_			try {_				_				_				_				BeanFactory bf = testContext.getApplicationContext().getAutowireCapableBeanFactory()___				return BeanFactoryAnnotationUtils.qualifiedBeanOfType(bf, PlatformTransactionManager.class, qualifier)__			}_			catch (RuntimeException ex) {_				if (logger.isWarnEnabled()) {_					logger.warn(_						String.format(_							"Caught exception while retrieving transaction manager with qualifier '%s' for test context %s",_							qualifier, testContext), ex)__				}_				throw ex__			}_		}__		_		return getTransactionManager(testContext)__	};get,the,link,platform,transaction,manager,transaction,manager,to,use,for,the,supplied,linkplain,test,context,test,context,and,code,qualifier,p,delegates,to,link,get,transaction,manager,test,context,if,the,supplied,code,qualifier,is,code,null,or,empty,param,test,context,the,test,context,for,which,the,transaction,manager,should,be,retrieved,param,qualifier,the,qualifier,for,selecting,between,multiple,bean,matches,may,be,code,null,or,empty,return,the,transaction,manager,to,use,or,code,null,if,not,found,throws,beans,exception,if,an,error,occurs,while,retrieving,the,transaction,manager,see,get,transaction,manager,test,context;protected,platform,transaction,manager,get,transaction,manager,test,context,test,context,string,qualifier,if,string,utils,has,text,qualifier,try,bean,factory,bf,test,context,get,application,context,get,autowire,capable,bean,factory,return,bean,factory,annotation,utils,qualified,bean,of,type,bf,platform,transaction,manager,class,qualifier,catch,runtime,exception,ex,if,logger,is,warn,enabled,logger,warn,string,format,caught,exception,while,retrieving,transaction,manager,with,qualifier,s,for,test,context,s,qualifier,test,context,ex,throw,ex,return,get,transaction,manager,test,context
TransactionalTestExecutionListener -> protected PlatformTransactionManager getTransactionManager(TestContext testContext, String qualifier);1405759527;Get the {@link PlatformTransactionManager transaction manager} to use_for the supplied {@linkplain TestContext test context} and {@code qualifier}._<p>Delegates to {@link #getTransactionManager(TestContext)} if the_supplied {@code qualifier} is {@code null} or empty._@param testContext the test context for which the transaction manager_should be retrieved_@param qualifier the qualifier for selecting between multiple bean matches__may be {@code null} or empty_@return the transaction manager to use, or {@code null} if not found_@throws BeansException if an error occurs while retrieving the transaction manager_@see #getTransactionManager(TestContext);protected PlatformTransactionManager getTransactionManager(TestContext testContext, String qualifier) {_		_		if (StringUtils.hasText(qualifier)) {_			try {_				_				_				_				BeanFactory bf = testContext.getApplicationContext().getAutowireCapableBeanFactory()___				return BeanFactoryAnnotationUtils.qualifiedBeanOfType(bf, PlatformTransactionManager.class, qualifier)__			}_			catch (RuntimeException ex) {_				if (logger.isWarnEnabled()) {_					logger.warn(_						String.format(_							"Caught exception while retrieving transaction manager with qualifier '%s' for test context %s",_							qualifier, testContext), ex)__				}_				throw ex__			}_		}__		_		return getTransactionManager(testContext)__	};get,the,link,platform,transaction,manager,transaction,manager,to,use,for,the,supplied,linkplain,test,context,test,context,and,code,qualifier,p,delegates,to,link,get,transaction,manager,test,context,if,the,supplied,code,qualifier,is,code,null,or,empty,param,test,context,the,test,context,for,which,the,transaction,manager,should,be,retrieved,param,qualifier,the,qualifier,for,selecting,between,multiple,bean,matches,may,be,code,null,or,empty,return,the,transaction,manager,to,use,or,code,null,if,not,found,throws,beans,exception,if,an,error,occurs,while,retrieving,the,transaction,manager,see,get,transaction,manager,test,context;protected,platform,transaction,manager,get,transaction,manager,test,context,test,context,string,qualifier,if,string,utils,has,text,qualifier,try,bean,factory,bf,test,context,get,application,context,get,autowire,capable,bean,factory,return,bean,factory,annotation,utils,qualified,bean,of,type,bf,platform,transaction,manager,class,qualifier,catch,runtime,exception,ex,if,logger,is,warn,enabled,logger,warn,string,format,caught,exception,while,retrieving,transaction,manager,with,qualifier,s,for,test,context,s,qualifier,test,context,ex,throw,ex,return,get,transaction,manager,test,context
TransactionalTestExecutionListener -> protected PlatformTransactionManager getTransactionManager(TestContext testContext, String qualifier);1405759966;Get the {@link PlatformTransactionManager transaction manager} to use_for the supplied {@linkplain TestContext test context} and {@code qualifier}._<p>Delegates to {@link #getTransactionManager(TestContext)} if the_supplied {@code qualifier} is {@code null} or empty._@param testContext the test context for which the transaction manager_should be retrieved_@param qualifier the qualifier for selecting between multiple bean matches__may be {@code null} or empty_@return the transaction manager to use, or {@code null} if not found_@throws BeansException if an error occurs while retrieving the transaction manager_@see #getTransactionManager(TestContext);protected PlatformTransactionManager getTransactionManager(TestContext testContext, String qualifier) {_		_		if (StringUtils.hasText(qualifier)) {_			try {_				_				_				_				BeanFactory bf = testContext.getApplicationContext().getAutowireCapableBeanFactory()___				return BeanFactoryAnnotationUtils.qualifiedBeanOfType(bf, PlatformTransactionManager.class, qualifier)__			}_			catch (RuntimeException ex) {_				if (logger.isWarnEnabled()) {_					logger.warn(_						String.format(_							"Caught exception while retrieving transaction manager with qualifier '%s' for test context %s",_							qualifier, testContext), ex)__				}_				throw ex__			}_		}__		_		return getTransactionManager(testContext)__	};get,the,link,platform,transaction,manager,transaction,manager,to,use,for,the,supplied,linkplain,test,context,test,context,and,code,qualifier,p,delegates,to,link,get,transaction,manager,test,context,if,the,supplied,code,qualifier,is,code,null,or,empty,param,test,context,the,test,context,for,which,the,transaction,manager,should,be,retrieved,param,qualifier,the,qualifier,for,selecting,between,multiple,bean,matches,may,be,code,null,or,empty,return,the,transaction,manager,to,use,or,code,null,if,not,found,throws,beans,exception,if,an,error,occurs,while,retrieving,the,transaction,manager,see,get,transaction,manager,test,context;protected,platform,transaction,manager,get,transaction,manager,test,context,test,context,string,qualifier,if,string,utils,has,text,qualifier,try,bean,factory,bf,test,context,get,application,context,get,autowire,capable,bean,factory,return,bean,factory,annotation,utils,qualified,bean,of,type,bf,platform,transaction,manager,class,qualifier,catch,runtime,exception,ex,if,logger,is,warn,enabled,logger,warn,string,format,caught,exception,while,retrieving,transaction,manager,with,qualifier,s,for,test,context,s,qualifier,test,context,ex,throw,ex,return,get,transaction,manager,test,context
TransactionalTestExecutionListener -> protected PlatformTransactionManager getTransactionManager(TestContext testContext, String qualifier);1406218418;Get the {@link PlatformTransactionManager transaction manager} to use_for the supplied {@linkplain TestContext test context} and {@code qualifier}._<p>Delegates to {@link #getTransactionManager(TestContext)} if the_supplied {@code qualifier} is {@code null} or empty._@param testContext the test context for which the transaction manager_should be retrieved_@param qualifier the qualifier for selecting between multiple bean matches__may be {@code null} or empty_@return the transaction manager to use, or {@code null} if not found_@throws BeansException if an error occurs while retrieving the transaction manager_@see #getTransactionManager(TestContext);protected PlatformTransactionManager getTransactionManager(TestContext testContext, String qualifier) {_		_		if (StringUtils.hasText(qualifier)) {_			try {_				_				_				_				BeanFactory bf = testContext.getApplicationContext().getAutowireCapableBeanFactory()___				return BeanFactoryAnnotationUtils.qualifiedBeanOfType(bf, PlatformTransactionManager.class, qualifier)__			}_			catch (RuntimeException ex) {_				if (logger.isWarnEnabled()) {_					logger.warn(_						String.format(_							"Caught exception while retrieving transaction manager with qualifier '%s' for test context %s",_							qualifier, testContext), ex)__				}_				throw ex__			}_		}__		_		return getTransactionManager(testContext)__	};get,the,link,platform,transaction,manager,transaction,manager,to,use,for,the,supplied,linkplain,test,context,test,context,and,code,qualifier,p,delegates,to,link,get,transaction,manager,test,context,if,the,supplied,code,qualifier,is,code,null,or,empty,param,test,context,the,test,context,for,which,the,transaction,manager,should,be,retrieved,param,qualifier,the,qualifier,for,selecting,between,multiple,bean,matches,may,be,code,null,or,empty,return,the,transaction,manager,to,use,or,code,null,if,not,found,throws,beans,exception,if,an,error,occurs,while,retrieving,the,transaction,manager,see,get,transaction,manager,test,context;protected,platform,transaction,manager,get,transaction,manager,test,context,test,context,string,qualifier,if,string,utils,has,text,qualifier,try,bean,factory,bf,test,context,get,application,context,get,autowire,capable,bean,factory,return,bean,factory,annotation,utils,qualified,bean,of,type,bf,platform,transaction,manager,class,qualifier,catch,runtime,exception,ex,if,logger,is,warn,enabled,logger,warn,string,format,caught,exception,while,retrieving,transaction,manager,with,qualifier,s,for,test,context,s,qualifier,test,context,ex,throw,ex,return,get,transaction,manager,test,context
TransactionalTestExecutionListener -> protected PlatformTransactionManager getTransactionManager(TestContext testContext, String qualifier);1407419079;Get the {@link PlatformTransactionManager transaction manager} to use_for the supplied {@linkplain TestContext test context} and {@code qualifier}._<p>Delegates to {@link #getTransactionManager(TestContext)} if the_supplied {@code qualifier} is {@code null} or empty._@param testContext the test context for which the transaction manager_should be retrieved_@param qualifier the qualifier for selecting between multiple bean matches__may be {@code null} or empty_@return the transaction manager to use, or {@code null} if not found_@throws BeansException if an error occurs while retrieving the transaction manager_@see #getTransactionManager(TestContext);protected PlatformTransactionManager getTransactionManager(TestContext testContext, String qualifier) {_		_		if (StringUtils.hasText(qualifier)) {_			try {_				_				_				_				BeanFactory bf = testContext.getApplicationContext().getAutowireCapableBeanFactory()___				return BeanFactoryAnnotationUtils.qualifiedBeanOfType(bf, PlatformTransactionManager.class, qualifier)__			}_			catch (RuntimeException ex) {_				if (logger.isWarnEnabled()) {_					logger.warn(_						String.format(_							"Caught exception while retrieving transaction manager with qualifier '%s' for test context %s",_							qualifier, testContext), ex)__				}_				throw ex__			}_		}__		_		return getTransactionManager(testContext)__	};get,the,link,platform,transaction,manager,transaction,manager,to,use,for,the,supplied,linkplain,test,context,test,context,and,code,qualifier,p,delegates,to,link,get,transaction,manager,test,context,if,the,supplied,code,qualifier,is,code,null,or,empty,param,test,context,the,test,context,for,which,the,transaction,manager,should,be,retrieved,param,qualifier,the,qualifier,for,selecting,between,multiple,bean,matches,may,be,code,null,or,empty,return,the,transaction,manager,to,use,or,code,null,if,not,found,throws,beans,exception,if,an,error,occurs,while,retrieving,the,transaction,manager,see,get,transaction,manager,test,context;protected,platform,transaction,manager,get,transaction,manager,test,context,test,context,string,qualifier,if,string,utils,has,text,qualifier,try,bean,factory,bf,test,context,get,application,context,get,autowire,capable,bean,factory,return,bean,factory,annotation,utils,qualified,bean,of,type,bf,platform,transaction,manager,class,qualifier,catch,runtime,exception,ex,if,logger,is,warn,enabled,logger,warn,string,format,caught,exception,while,retrieving,transaction,manager,with,qualifier,s,for,test,context,s,qualifier,test,context,ex,throw,ex,return,get,transaction,manager,test,context
TransactionalTestExecutionListener -> protected PlatformTransactionManager getTransactionManager(TestContext testContext, String qualifier);1408048216;Get the {@link PlatformTransactionManager transaction manager} to use_for the supplied {@linkplain TestContext test context} and {@code qualifier}._<p>Delegates to {@link #getTransactionManager(TestContext)} if the_supplied {@code qualifier} is {@code null} or empty._@param testContext the test context for which the transaction manager_should be retrieved_@param qualifier the qualifier for selecting between multiple bean matches__may be {@code null} or empty_@return the transaction manager to use, or {@code null} if not found_@throws BeansException if an error occurs while retrieving the transaction manager_@see #getTransactionManager(TestContext);protected PlatformTransactionManager getTransactionManager(TestContext testContext, String qualifier) {_		_		if (StringUtils.hasText(qualifier)) {_			try {_				_				_				_				BeanFactory bf = testContext.getApplicationContext().getAutowireCapableBeanFactory()___				return BeanFactoryAnnotationUtils.qualifiedBeanOfType(bf, PlatformTransactionManager.class, qualifier)__			}_			catch (RuntimeException ex) {_				if (logger.isWarnEnabled()) {_					logger.warn(_						String.format(_							"Caught exception while retrieving transaction manager with qualifier '%s' for test context %s",_							qualifier, testContext), ex)__				}_				throw ex__			}_		}__		_		return getTransactionManager(testContext)__	};get,the,link,platform,transaction,manager,transaction,manager,to,use,for,the,supplied,linkplain,test,context,test,context,and,code,qualifier,p,delegates,to,link,get,transaction,manager,test,context,if,the,supplied,code,qualifier,is,code,null,or,empty,param,test,context,the,test,context,for,which,the,transaction,manager,should,be,retrieved,param,qualifier,the,qualifier,for,selecting,between,multiple,bean,matches,may,be,code,null,or,empty,return,the,transaction,manager,to,use,or,code,null,if,not,found,throws,beans,exception,if,an,error,occurs,while,retrieving,the,transaction,manager,see,get,transaction,manager,test,context;protected,platform,transaction,manager,get,transaction,manager,test,context,test,context,string,qualifier,if,string,utils,has,text,qualifier,try,bean,factory,bf,test,context,get,application,context,get,autowire,capable,bean,factory,return,bean,factory,annotation,utils,qualified,bean,of,type,bf,platform,transaction,manager,class,qualifier,catch,runtime,exception,ex,if,logger,is,warn,enabled,logger,warn,string,format,caught,exception,while,retrieving,transaction,manager,with,qualifier,s,for,test,context,s,qualifier,test,context,ex,throw,ex,return,get,transaction,manager,test,context
TransactionalTestExecutionListener -> protected PlatformTransactionManager getTransactionManager(TestContext testContext, String qualifier);1413848647;Get the {@link PlatformTransactionManager transaction manager} to use_for the supplied {@linkplain TestContext test context} and {@code qualifier}._<p>Delegates to {@link #getTransactionManager(TestContext)} if the_supplied {@code qualifier} is {@code null} or empty._@param testContext the test context for which the transaction manager_should be retrieved_@param qualifier the qualifier for selecting between multiple bean matches__may be {@code null} or empty_@return the transaction manager to use, or {@code null} if not found_@throws BeansException if an error occurs while retrieving the transaction manager_@see #getTransactionManager(TestContext);protected PlatformTransactionManager getTransactionManager(TestContext testContext, String qualifier) {_		_		if (StringUtils.hasText(qualifier)) {_			try {_				_				_				_				BeanFactory bf = testContext.getApplicationContext().getAutowireCapableBeanFactory()___				return BeanFactoryAnnotationUtils.qualifiedBeanOfType(bf, PlatformTransactionManager.class, qualifier)__			}_			catch (RuntimeException ex) {_				if (logger.isWarnEnabled()) {_					logger.warn(_						String.format(_							"Caught exception while retrieving transaction manager with qualifier '%s' for test context %s",_							qualifier, testContext), ex)__				}_				throw ex__			}_		}__		_		return getTransactionManager(testContext)__	};get,the,link,platform,transaction,manager,transaction,manager,to,use,for,the,supplied,linkplain,test,context,test,context,and,code,qualifier,p,delegates,to,link,get,transaction,manager,test,context,if,the,supplied,code,qualifier,is,code,null,or,empty,param,test,context,the,test,context,for,which,the,transaction,manager,should,be,retrieved,param,qualifier,the,qualifier,for,selecting,between,multiple,bean,matches,may,be,code,null,or,empty,return,the,transaction,manager,to,use,or,code,null,if,not,found,throws,beans,exception,if,an,error,occurs,while,retrieving,the,transaction,manager,see,get,transaction,manager,test,context;protected,platform,transaction,manager,get,transaction,manager,test,context,test,context,string,qualifier,if,string,utils,has,text,qualifier,try,bean,factory,bf,test,context,get,application,context,get,autowire,capable,bean,factory,return,bean,factory,annotation,utils,qualified,bean,of,type,bf,platform,transaction,manager,class,qualifier,catch,runtime,exception,ex,if,logger,is,warn,enabled,logger,warn,string,format,caught,exception,while,retrieving,transaction,manager,with,qualifier,s,for,test,context,s,qualifier,test,context,ex,throw,ex,return,get,transaction,manager,test,context
TransactionalTestExecutionListener -> protected PlatformTransactionManager getTransactionManager(TestContext testContext, String qualifier);1431568199;Get the {@link PlatformTransactionManager transaction manager} to use_for the supplied {@linkplain TestContext test context} and {@code qualifier}._<p>Delegates to {@link #getTransactionManager(TestContext)} if the_supplied {@code qualifier} is {@code null} or empty._@param testContext the test context for which the transaction manager_should be retrieved_@param qualifier the qualifier for selecting between multiple bean matches__may be {@code null} or empty_@return the transaction manager to use, or {@code null} if not found_@throws BeansException if an error occurs while retrieving the transaction manager_@see #getTransactionManager(TestContext);protected PlatformTransactionManager getTransactionManager(TestContext testContext, String qualifier) {_		_		if (StringUtils.hasText(qualifier)) {_			try {_				_				_				_				BeanFactory bf = testContext.getApplicationContext().getAutowireCapableBeanFactory()___				return BeanFactoryAnnotationUtils.qualifiedBeanOfType(bf, PlatformTransactionManager.class, qualifier)__			}_			catch (RuntimeException ex) {_				if (logger.isWarnEnabled()) {_					logger.warn(_						String.format(_							"Caught exception while retrieving transaction manager with qualifier '%s' for test context %s",_							qualifier, testContext), ex)__				}_				throw ex__			}_		}__		_		return getTransactionManager(testContext)__	};get,the,link,platform,transaction,manager,transaction,manager,to,use,for,the,supplied,linkplain,test,context,test,context,and,code,qualifier,p,delegates,to,link,get,transaction,manager,test,context,if,the,supplied,code,qualifier,is,code,null,or,empty,param,test,context,the,test,context,for,which,the,transaction,manager,should,be,retrieved,param,qualifier,the,qualifier,for,selecting,between,multiple,bean,matches,may,be,code,null,or,empty,return,the,transaction,manager,to,use,or,code,null,if,not,found,throws,beans,exception,if,an,error,occurs,while,retrieving,the,transaction,manager,see,get,transaction,manager,test,context;protected,platform,transaction,manager,get,transaction,manager,test,context,test,context,string,qualifier,if,string,utils,has,text,qualifier,try,bean,factory,bf,test,context,get,application,context,get,autowire,capable,bean,factory,return,bean,factory,annotation,utils,qualified,bean,of,type,bf,platform,transaction,manager,class,qualifier,catch,runtime,exception,ex,if,logger,is,warn,enabled,logger,warn,string,format,caught,exception,while,retrieving,transaction,manager,with,qualifier,s,for,test,context,s,qualifier,test,context,ex,throw,ex,return,get,transaction,manager,test,context
TransactionalTestExecutionListener -> protected PlatformTransactionManager getTransactionManager(TestContext testContext, String qualifier);1432125256;Get the {@link PlatformTransactionManager transaction manager} to use_for the supplied {@linkplain TestContext test context} and {@code qualifier}._<p>Delegates to {@link #getTransactionManager(TestContext)} if the_supplied {@code qualifier} is {@code null} or empty._@param testContext the test context for which the transaction manager_should be retrieved_@param qualifier the qualifier for selecting between multiple bean matches__may be {@code null} or empty_@return the transaction manager to use, or {@code null} if not found_@throws BeansException if an error occurs while retrieving the transaction manager_@see #getTransactionManager(TestContext);protected PlatformTransactionManager getTransactionManager(TestContext testContext, String qualifier) {_		_		if (StringUtils.hasText(qualifier)) {_			try {_				_				_				_				BeanFactory bf = testContext.getApplicationContext().getAutowireCapableBeanFactory()___				return BeanFactoryAnnotationUtils.qualifiedBeanOfType(bf, PlatformTransactionManager.class, qualifier)__			}_			catch (RuntimeException ex) {_				if (logger.isWarnEnabled()) {_					logger.warn(_						String.format(_							"Caught exception while retrieving transaction manager with qualifier '%s' for test context %s",_							qualifier, testContext), ex)__				}_				throw ex__			}_		}__		_		return getTransactionManager(testContext)__	};get,the,link,platform,transaction,manager,transaction,manager,to,use,for,the,supplied,linkplain,test,context,test,context,and,code,qualifier,p,delegates,to,link,get,transaction,manager,test,context,if,the,supplied,code,qualifier,is,code,null,or,empty,param,test,context,the,test,context,for,which,the,transaction,manager,should,be,retrieved,param,qualifier,the,qualifier,for,selecting,between,multiple,bean,matches,may,be,code,null,or,empty,return,the,transaction,manager,to,use,or,code,null,if,not,found,throws,beans,exception,if,an,error,occurs,while,retrieving,the,transaction,manager,see,get,transaction,manager,test,context;protected,platform,transaction,manager,get,transaction,manager,test,context,test,context,string,qualifier,if,string,utils,has,text,qualifier,try,bean,factory,bf,test,context,get,application,context,get,autowire,capable,bean,factory,return,bean,factory,annotation,utils,qualified,bean,of,type,bf,platform,transaction,manager,class,qualifier,catch,runtime,exception,ex,if,logger,is,warn,enabled,logger,warn,string,format,caught,exception,while,retrieving,transaction,manager,with,qualifier,s,for,test,context,s,qualifier,test,context,ex,throw,ex,return,get,transaction,manager,test,context
TransactionalTestExecutionListener -> protected PlatformTransactionManager getTransactionManager(TestContext testContext, String qualifier);1432856630;Get the {@link PlatformTransactionManager transaction manager} to use_for the supplied {@linkplain TestContext test context} and {@code qualifier}._<p>Delegates to {@link #getTransactionManager(TestContext)} if the_supplied {@code qualifier} is {@code null} or empty._@param testContext the test context for which the transaction manager_should be retrieved_@param qualifier the qualifier for selecting between multiple bean matches__may be {@code null} or empty_@return the transaction manager to use, or {@code null} if not found_@throws BeansException if an error occurs while retrieving the transaction manager_@see #getTransactionManager(TestContext);protected PlatformTransactionManager getTransactionManager(TestContext testContext, String qualifier) {_		_		if (StringUtils.hasText(qualifier)) {_			try {_				_				_				_				BeanFactory bf = testContext.getApplicationContext().getAutowireCapableBeanFactory()___				return BeanFactoryAnnotationUtils.qualifiedBeanOfType(bf, PlatformTransactionManager.class, qualifier)__			}_			catch (RuntimeException ex) {_				if (logger.isWarnEnabled()) {_					logger.warn(_						String.format(_							"Caught exception while retrieving transaction manager with qualifier '%s' for test context %s",_							qualifier, testContext), ex)__				}_				throw ex__			}_		}__		_		return getTransactionManager(testContext)__	};get,the,link,platform,transaction,manager,transaction,manager,to,use,for,the,supplied,linkplain,test,context,test,context,and,code,qualifier,p,delegates,to,link,get,transaction,manager,test,context,if,the,supplied,code,qualifier,is,code,null,or,empty,param,test,context,the,test,context,for,which,the,transaction,manager,should,be,retrieved,param,qualifier,the,qualifier,for,selecting,between,multiple,bean,matches,may,be,code,null,or,empty,return,the,transaction,manager,to,use,or,code,null,if,not,found,throws,beans,exception,if,an,error,occurs,while,retrieving,the,transaction,manager,see,get,transaction,manager,test,context;protected,platform,transaction,manager,get,transaction,manager,test,context,test,context,string,qualifier,if,string,utils,has,text,qualifier,try,bean,factory,bf,test,context,get,application,context,get,autowire,capable,bean,factory,return,bean,factory,annotation,utils,qualified,bean,of,type,bf,platform,transaction,manager,class,qualifier,catch,runtime,exception,ex,if,logger,is,warn,enabled,logger,warn,string,format,caught,exception,while,retrieving,transaction,manager,with,qualifier,s,for,test,context,s,qualifier,test,context,ex,throw,ex,return,get,transaction,manager,test,context
TransactionalTestExecutionListener -> protected PlatformTransactionManager getTransactionManager(TestContext testContext, String qualifier);1434234880;Get the {@link PlatformTransactionManager transaction manager} to use_for the supplied {@linkplain TestContext test context} and {@code qualifier}._<p>Delegates to {@link #getTransactionManager(TestContext)} if the_supplied {@code qualifier} is {@code null} or empty._@param testContext the test context for which the transaction manager_should be retrieved_@param qualifier the qualifier for selecting between multiple bean matches__may be {@code null} or empty_@return the transaction manager to use, or {@code null} if not found_@throws BeansException if an error occurs while retrieving the transaction manager_@see #getTransactionManager(TestContext);protected PlatformTransactionManager getTransactionManager(TestContext testContext, String qualifier) {_		_		if (StringUtils.hasText(qualifier)) {_			try {_				_				_				_				BeanFactory bf = testContext.getApplicationContext().getAutowireCapableBeanFactory()___				return BeanFactoryAnnotationUtils.qualifiedBeanOfType(bf, PlatformTransactionManager.class, qualifier)__			}_			catch (RuntimeException ex) {_				if (logger.isWarnEnabled()) {_					logger.warn(_						String.format(_							"Caught exception while retrieving transaction manager with qualifier '%s' for test context %s",_							qualifier, testContext), ex)__				}_				throw ex__			}_		}__		_		return getTransactionManager(testContext)__	};get,the,link,platform,transaction,manager,transaction,manager,to,use,for,the,supplied,linkplain,test,context,test,context,and,code,qualifier,p,delegates,to,link,get,transaction,manager,test,context,if,the,supplied,code,qualifier,is,code,null,or,empty,param,test,context,the,test,context,for,which,the,transaction,manager,should,be,retrieved,param,qualifier,the,qualifier,for,selecting,between,multiple,bean,matches,may,be,code,null,or,empty,return,the,transaction,manager,to,use,or,code,null,if,not,found,throws,beans,exception,if,an,error,occurs,while,retrieving,the,transaction,manager,see,get,transaction,manager,test,context;protected,platform,transaction,manager,get,transaction,manager,test,context,test,context,string,qualifier,if,string,utils,has,text,qualifier,try,bean,factory,bf,test,context,get,application,context,get,autowire,capable,bean,factory,return,bean,factory,annotation,utils,qualified,bean,of,type,bf,platform,transaction,manager,class,qualifier,catch,runtime,exception,ex,if,logger,is,warn,enabled,logger,warn,string,format,caught,exception,while,retrieving,transaction,manager,with,qualifier,s,for,test,context,s,qualifier,test,context,ex,throw,ex,return,get,transaction,manager,test,context
TransactionalTestExecutionListener -> protected PlatformTransactionManager getTransactionManager(TestContext testContext, String qualifier);1434720443;Get the {@link PlatformTransactionManager transaction manager} to use_for the supplied {@linkplain TestContext test context} and {@code qualifier}._<p>Delegates to {@link #getTransactionManager(TestContext)} if the_supplied {@code qualifier} is {@code null} or empty._@param testContext the test context for which the transaction manager_should be retrieved_@param qualifier the qualifier for selecting between multiple bean matches__may be {@code null} or empty_@return the transaction manager to use, or {@code null} if not found_@throws BeansException if an error occurs while retrieving the transaction manager_@see #getTransactionManager(TestContext);protected PlatformTransactionManager getTransactionManager(TestContext testContext, String qualifier) {_		_		if (StringUtils.hasText(qualifier)) {_			try {_				_				_				_				BeanFactory bf = testContext.getApplicationContext().getAutowireCapableBeanFactory()___				return BeanFactoryAnnotationUtils.qualifiedBeanOfType(bf, PlatformTransactionManager.class, qualifier)__			}_			catch (RuntimeException ex) {_				if (logger.isWarnEnabled()) {_					logger.warn(_						String.format(_							"Caught exception while retrieving transaction manager with qualifier '%s' for test context %s",_							qualifier, testContext), ex)__				}_				throw ex__			}_		}__		_		return getTransactionManager(testContext)__	};get,the,link,platform,transaction,manager,transaction,manager,to,use,for,the,supplied,linkplain,test,context,test,context,and,code,qualifier,p,delegates,to,link,get,transaction,manager,test,context,if,the,supplied,code,qualifier,is,code,null,or,empty,param,test,context,the,test,context,for,which,the,transaction,manager,should,be,retrieved,param,qualifier,the,qualifier,for,selecting,between,multiple,bean,matches,may,be,code,null,or,empty,return,the,transaction,manager,to,use,or,code,null,if,not,found,throws,beans,exception,if,an,error,occurs,while,retrieving,the,transaction,manager,see,get,transaction,manager,test,context;protected,platform,transaction,manager,get,transaction,manager,test,context,test,context,string,qualifier,if,string,utils,has,text,qualifier,try,bean,factory,bf,test,context,get,application,context,get,autowire,capable,bean,factory,return,bean,factory,annotation,utils,qualified,bean,of,type,bf,platform,transaction,manager,class,qualifier,catch,runtime,exception,ex,if,logger,is,warn,enabled,logger,warn,string,format,caught,exception,while,retrieving,transaction,manager,with,qualifier,s,for,test,context,s,qualifier,test,context,ex,throw,ex,return,get,transaction,manager,test,context
TransactionalTestExecutionListener -> protected PlatformTransactionManager getTransactionManager(TestContext testContext, String qualifier);1434817656;Get the {@link PlatformTransactionManager transaction manager} to use_for the supplied {@linkplain TestContext test context} and {@code qualifier}._<p>Delegates to {@link #getTransactionManager(TestContext)} if the_supplied {@code qualifier} is {@code null} or empty._@param testContext the test context for which the transaction manager_should be retrieved_@param qualifier the qualifier for selecting between multiple bean matches__may be {@code null} or empty_@return the transaction manager to use, or {@code null} if not found_@throws BeansException if an error occurs while retrieving the transaction manager_@see #getTransactionManager(TestContext);protected PlatformTransactionManager getTransactionManager(TestContext testContext, String qualifier) {_		_		if (StringUtils.hasText(qualifier)) {_			try {_				_				_				_				BeanFactory bf = testContext.getApplicationContext().getAutowireCapableBeanFactory()___				return BeanFactoryAnnotationUtils.qualifiedBeanOfType(bf, PlatformTransactionManager.class, qualifier)__			}_			catch (RuntimeException ex) {_				if (logger.isWarnEnabled()) {_					logger.warn(_						String.format(_							"Caught exception while retrieving transaction manager with qualifier '%s' for test context %s",_							qualifier, testContext), ex)__				}_				throw ex__			}_		}__		_		return getTransactionManager(testContext)__	};get,the,link,platform,transaction,manager,transaction,manager,to,use,for,the,supplied,linkplain,test,context,test,context,and,code,qualifier,p,delegates,to,link,get,transaction,manager,test,context,if,the,supplied,code,qualifier,is,code,null,or,empty,param,test,context,the,test,context,for,which,the,transaction,manager,should,be,retrieved,param,qualifier,the,qualifier,for,selecting,between,multiple,bean,matches,may,be,code,null,or,empty,return,the,transaction,manager,to,use,or,code,null,if,not,found,throws,beans,exception,if,an,error,occurs,while,retrieving,the,transaction,manager,see,get,transaction,manager,test,context;protected,platform,transaction,manager,get,transaction,manager,test,context,test,context,string,qualifier,if,string,utils,has,text,qualifier,try,bean,factory,bf,test,context,get,application,context,get,autowire,capable,bean,factory,return,bean,factory,annotation,utils,qualified,bean,of,type,bf,platform,transaction,manager,class,qualifier,catch,runtime,exception,ex,if,logger,is,warn,enabled,logger,warn,string,format,caught,exception,while,retrieving,transaction,manager,with,qualifier,s,for,test,context,s,qualifier,test,context,ex,throw,ex,return,get,transaction,manager,test,context
TransactionalTestExecutionListener -> protected PlatformTransactionManager getTransactionManager(TestContext testContext, String qualifier);1437841346;Get the {@linkplain PlatformTransactionManager transaction manager} to use_for the supplied {@linkplain TestContext test context} and {@code qualifier}._<p>Delegates to {@link #getTransactionManager(TestContext)} if the_supplied {@code qualifier} is {@code null} or empty._@param testContext the test context for which the transaction manager_should be retrieved_@param qualifier the qualifier for selecting between multiple bean matches__may be {@code null} or empty_@return the transaction manager to use, or {@code null} if not found_@throws BeansException if an error occurs while retrieving the transaction manager_@see #getTransactionManager(TestContext);protected PlatformTransactionManager getTransactionManager(TestContext testContext, String qualifier) {_		_		if (StringUtils.hasText(qualifier)) {_			try {_				_				_				_				BeanFactory bf = testContext.getApplicationContext().getAutowireCapableBeanFactory()___				return BeanFactoryAnnotationUtils.qualifiedBeanOfType(bf, PlatformTransactionManager.class, qualifier)__			}_			catch (RuntimeException ex) {_				if (logger.isWarnEnabled()) {_					logger.warn(_						String.format(_							"Caught exception while retrieving transaction manager with qualifier '%s' for test context %s",_							qualifier, testContext), ex)__				}_				throw ex__			}_		}__		_		return getTransactionManager(testContext)__	};get,the,linkplain,platform,transaction,manager,transaction,manager,to,use,for,the,supplied,linkplain,test,context,test,context,and,code,qualifier,p,delegates,to,link,get,transaction,manager,test,context,if,the,supplied,code,qualifier,is,code,null,or,empty,param,test,context,the,test,context,for,which,the,transaction,manager,should,be,retrieved,param,qualifier,the,qualifier,for,selecting,between,multiple,bean,matches,may,be,code,null,or,empty,return,the,transaction,manager,to,use,or,code,null,if,not,found,throws,beans,exception,if,an,error,occurs,while,retrieving,the,transaction,manager,see,get,transaction,manager,test,context;protected,platform,transaction,manager,get,transaction,manager,test,context,test,context,string,qualifier,if,string,utils,has,text,qualifier,try,bean,factory,bf,test,context,get,application,context,get,autowire,capable,bean,factory,return,bean,factory,annotation,utils,qualified,bean,of,type,bf,platform,transaction,manager,class,qualifier,catch,runtime,exception,ex,if,logger,is,warn,enabled,logger,warn,string,format,caught,exception,while,retrieving,transaction,manager,with,qualifier,s,for,test,context,s,qualifier,test,context,ex,throw,ex,return,get,transaction,manager,test,context
TransactionalTestExecutionListener -> protected PlatformTransactionManager getTransactionManager(TestContext testContext, String qualifier);1437851372;Get the {@linkplain PlatformTransactionManager transaction manager} to use_for the supplied {@linkplain TestContext test context} and {@code qualifier}._<p>Delegates to {@link #getTransactionManager(TestContext)} if the_supplied {@code qualifier} is {@code null} or empty._@param testContext the test context for which the transaction manager_should be retrieved_@param qualifier the qualifier for selecting between multiple bean matches__may be {@code null} or empty_@return the transaction manager to use, or {@code null} if not found_@throws BeansException if an error occurs while retrieving the transaction manager_@see #getTransactionManager(TestContext);protected PlatformTransactionManager getTransactionManager(TestContext testContext, String qualifier) {_		_		if (StringUtils.hasText(qualifier)) {_			try {_				_				_				_				BeanFactory bf = testContext.getApplicationContext().getAutowireCapableBeanFactory()___				return BeanFactoryAnnotationUtils.qualifiedBeanOfType(bf, PlatformTransactionManager.class, qualifier)__			}_			catch (RuntimeException ex) {_				if (logger.isWarnEnabled()) {_					logger.warn(_						String.format(_							"Caught exception while retrieving transaction manager with qualifier '%s' for test context %s",_							qualifier, testContext), ex)__				}_				throw ex__			}_		}__		_		return getTransactionManager(testContext)__	};get,the,linkplain,platform,transaction,manager,transaction,manager,to,use,for,the,supplied,linkplain,test,context,test,context,and,code,qualifier,p,delegates,to,link,get,transaction,manager,test,context,if,the,supplied,code,qualifier,is,code,null,or,empty,param,test,context,the,test,context,for,which,the,transaction,manager,should,be,retrieved,param,qualifier,the,qualifier,for,selecting,between,multiple,bean,matches,may,be,code,null,or,empty,return,the,transaction,manager,to,use,or,code,null,if,not,found,throws,beans,exception,if,an,error,occurs,while,retrieving,the,transaction,manager,see,get,transaction,manager,test,context;protected,platform,transaction,manager,get,transaction,manager,test,context,test,context,string,qualifier,if,string,utils,has,text,qualifier,try,bean,factory,bf,test,context,get,application,context,get,autowire,capable,bean,factory,return,bean,factory,annotation,utils,qualified,bean,of,type,bf,platform,transaction,manager,class,qualifier,catch,runtime,exception,ex,if,logger,is,warn,enabled,logger,warn,string,format,caught,exception,while,retrieving,transaction,manager,with,qualifier,s,for,test,context,s,qualifier,test,context,ex,throw,ex,return,get,transaction,manager,test,context
TransactionalTestExecutionListener -> protected PlatformTransactionManager getTransactionManager(TestContext testContext, String qualifier);1437852597;Get the {@linkplain PlatformTransactionManager transaction manager} to use_for the supplied {@linkplain TestContext test context} and {@code qualifier}._<p>Delegates to {@link #getTransactionManager(TestContext)} if the_supplied {@code qualifier} is {@code null} or empty._@param testContext the test context for which the transaction manager_should be retrieved_@param qualifier the qualifier for selecting between multiple bean matches__may be {@code null} or empty_@return the transaction manager to use, or {@code null} if not found_@throws BeansException if an error occurs while retrieving the transaction manager_@see #getTransactionManager(TestContext);protected PlatformTransactionManager getTransactionManager(TestContext testContext, String qualifier) {_		_		if (StringUtils.hasText(qualifier)) {_			try {_				_				_				_				BeanFactory bf = testContext.getApplicationContext().getAutowireCapableBeanFactory()___				return BeanFactoryAnnotationUtils.qualifiedBeanOfType(bf, PlatformTransactionManager.class, qualifier)__			}_			catch (RuntimeException ex) {_				if (logger.isWarnEnabled()) {_					logger.warn(_						String.format(_							"Caught exception while retrieving transaction manager with qualifier '%s' for test context %s",_							qualifier, testContext), ex)__				}_				throw ex__			}_		}__		_		return getTransactionManager(testContext)__	};get,the,linkplain,platform,transaction,manager,transaction,manager,to,use,for,the,supplied,linkplain,test,context,test,context,and,code,qualifier,p,delegates,to,link,get,transaction,manager,test,context,if,the,supplied,code,qualifier,is,code,null,or,empty,param,test,context,the,test,context,for,which,the,transaction,manager,should,be,retrieved,param,qualifier,the,qualifier,for,selecting,between,multiple,bean,matches,may,be,code,null,or,empty,return,the,transaction,manager,to,use,or,code,null,if,not,found,throws,beans,exception,if,an,error,occurs,while,retrieving,the,transaction,manager,see,get,transaction,manager,test,context;protected,platform,transaction,manager,get,transaction,manager,test,context,test,context,string,qualifier,if,string,utils,has,text,qualifier,try,bean,factory,bf,test,context,get,application,context,get,autowire,capable,bean,factory,return,bean,factory,annotation,utils,qualified,bean,of,type,bf,platform,transaction,manager,class,qualifier,catch,runtime,exception,ex,if,logger,is,warn,enabled,logger,warn,string,format,caught,exception,while,retrieving,transaction,manager,with,qualifier,s,for,test,context,s,qualifier,test,context,ex,throw,ex,return,get,transaction,manager,test,context
TransactionalTestExecutionListener -> protected PlatformTransactionManager getTransactionManager(TestContext testContext, String qualifier);1454507787;Get the {@linkplain PlatformTransactionManager transaction manager} to use_for the supplied {@linkplain TestContext test context} and {@code qualifier}._<p>Delegates to {@link #getTransactionManager(TestContext)} if the_supplied {@code qualifier} is {@code null} or empty._@param testContext the test context for which the transaction manager_should be retrieved_@param qualifier the qualifier for selecting between multiple bean matches__may be {@code null} or empty_@return the transaction manager to use, or {@code null} if not found_@throws BeansException if an error occurs while retrieving the transaction manager_@see #getTransactionManager(TestContext);protected PlatformTransactionManager getTransactionManager(TestContext testContext, String qualifier) {_		_		if (StringUtils.hasText(qualifier)) {_			try {_				_				_				_				BeanFactory bf = testContext.getApplicationContext().getAutowireCapableBeanFactory()___				return BeanFactoryAnnotationUtils.qualifiedBeanOfType(bf, PlatformTransactionManager.class, qualifier)__			}_			catch (RuntimeException ex) {_				if (logger.isWarnEnabled()) {_					logger.warn(_						String.format(_							"Caught exception while retrieving transaction manager with qualifier '%s' for test context %s",_							qualifier, testContext), ex)__				}_				throw ex__			}_		}__		_		return getTransactionManager(testContext)__	};get,the,linkplain,platform,transaction,manager,transaction,manager,to,use,for,the,supplied,linkplain,test,context,test,context,and,code,qualifier,p,delegates,to,link,get,transaction,manager,test,context,if,the,supplied,code,qualifier,is,code,null,or,empty,param,test,context,the,test,context,for,which,the,transaction,manager,should,be,retrieved,param,qualifier,the,qualifier,for,selecting,between,multiple,bean,matches,may,be,code,null,or,empty,return,the,transaction,manager,to,use,or,code,null,if,not,found,throws,beans,exception,if,an,error,occurs,while,retrieving,the,transaction,manager,see,get,transaction,manager,test,context;protected,platform,transaction,manager,get,transaction,manager,test,context,test,context,string,qualifier,if,string,utils,has,text,qualifier,try,bean,factory,bf,test,context,get,application,context,get,autowire,capable,bean,factory,return,bean,factory,annotation,utils,qualified,bean,of,type,bf,platform,transaction,manager,class,qualifier,catch,runtime,exception,ex,if,logger,is,warn,enabled,logger,warn,string,format,caught,exception,while,retrieving,transaction,manager,with,qualifier,s,for,test,context,s,qualifier,test,context,ex,throw,ex,return,get,transaction,manager,test,context
TransactionalTestExecutionListener -> protected PlatformTransactionManager getTransactionManager(TestContext testContext, String qualifier);1456702967;Get the {@linkplain PlatformTransactionManager transaction manager} to use_for the supplied {@linkplain TestContext test context} and {@code qualifier}._<p>Delegates to {@link #getTransactionManager(TestContext)} if the_supplied {@code qualifier} is {@code null} or empty._@param testContext the test context for which the transaction manager_should be retrieved_@param qualifier the qualifier for selecting between multiple bean matches__may be {@code null} or empty_@return the transaction manager to use, or {@code null} if not found_@throws BeansException if an error occurs while retrieving the transaction manager_@see #getTransactionManager(TestContext);protected PlatformTransactionManager getTransactionManager(TestContext testContext, String qualifier) {_		_		if (StringUtils.hasText(qualifier)) {_			try {_				_				_				_				BeanFactory bf = testContext.getApplicationContext().getAutowireCapableBeanFactory()___				return BeanFactoryAnnotationUtils.qualifiedBeanOfType(bf, PlatformTransactionManager.class, qualifier)__			}_			catch (RuntimeException ex) {_				if (logger.isWarnEnabled()) {_					logger.warn(_						String.format(_							"Caught exception while retrieving transaction manager with qualifier '%s' for test context %s",_							qualifier, testContext), ex)__				}_				throw ex__			}_		}__		_		return getTransactionManager(testContext)__	};get,the,linkplain,platform,transaction,manager,transaction,manager,to,use,for,the,supplied,linkplain,test,context,test,context,and,code,qualifier,p,delegates,to,link,get,transaction,manager,test,context,if,the,supplied,code,qualifier,is,code,null,or,empty,param,test,context,the,test,context,for,which,the,transaction,manager,should,be,retrieved,param,qualifier,the,qualifier,for,selecting,between,multiple,bean,matches,may,be,code,null,or,empty,return,the,transaction,manager,to,use,or,code,null,if,not,found,throws,beans,exception,if,an,error,occurs,while,retrieving,the,transaction,manager,see,get,transaction,manager,test,context;protected,platform,transaction,manager,get,transaction,manager,test,context,test,context,string,qualifier,if,string,utils,has,text,qualifier,try,bean,factory,bf,test,context,get,application,context,get,autowire,capable,bean,factory,return,bean,factory,annotation,utils,qualified,bean,of,type,bf,platform,transaction,manager,class,qualifier,catch,runtime,exception,ex,if,logger,is,warn,enabled,logger,warn,string,format,caught,exception,while,retrieving,transaction,manager,with,qualifier,s,for,test,context,s,qualifier,test,context,ex,throw,ex,return,get,transaction,manager,test,context
TransactionalTestExecutionListener -> protected PlatformTransactionManager getTransactionManager(TestContext testContext, String qualifier);1456756222;Get the {@linkplain PlatformTransactionManager transaction manager} to use_for the supplied {@linkplain TestContext test context} and {@code qualifier}._<p>Delegates to {@link #getTransactionManager(TestContext)} if the_supplied {@code qualifier} is {@code null} or empty._@param testContext the test context for which the transaction manager_should be retrieved_@param qualifier the qualifier for selecting between multiple bean matches__may be {@code null} or empty_@return the transaction manager to use, or {@code null} if not found_@throws BeansException if an error occurs while retrieving the transaction manager_@see #getTransactionManager(TestContext);protected PlatformTransactionManager getTransactionManager(TestContext testContext, String qualifier) {_		_		if (StringUtils.hasText(qualifier)) {_			try {_				_				_				_				BeanFactory bf = testContext.getApplicationContext().getAutowireCapableBeanFactory()___				return BeanFactoryAnnotationUtils.qualifiedBeanOfType(bf, PlatformTransactionManager.class, qualifier)__			}_			catch (RuntimeException ex) {_				if (logger.isWarnEnabled()) {_					logger.warn(_						String.format(_							"Caught exception while retrieving transaction manager with qualifier '%s' for test context %s",_							qualifier, testContext), ex)__				}_				throw ex__			}_		}__		_		return getTransactionManager(testContext)__	};get,the,linkplain,platform,transaction,manager,transaction,manager,to,use,for,the,supplied,linkplain,test,context,test,context,and,code,qualifier,p,delegates,to,link,get,transaction,manager,test,context,if,the,supplied,code,qualifier,is,code,null,or,empty,param,test,context,the,test,context,for,which,the,transaction,manager,should,be,retrieved,param,qualifier,the,qualifier,for,selecting,between,multiple,bean,matches,may,be,code,null,or,empty,return,the,transaction,manager,to,use,or,code,null,if,not,found,throws,beans,exception,if,an,error,occurs,while,retrieving,the,transaction,manager,see,get,transaction,manager,test,context;protected,platform,transaction,manager,get,transaction,manager,test,context,test,context,string,qualifier,if,string,utils,has,text,qualifier,try,bean,factory,bf,test,context,get,application,context,get,autowire,capable,bean,factory,return,bean,factory,annotation,utils,qualified,bean,of,type,bf,platform,transaction,manager,class,qualifier,catch,runtime,exception,ex,if,logger,is,warn,enabled,logger,warn,string,format,caught,exception,while,retrieving,transaction,manager,with,qualifier,s,for,test,context,s,qualifier,test,context,ex,throw,ex,return,get,transaction,manager,test,context
TransactionalTestExecutionListener -> protected PlatformTransactionManager getTransactionManager(TestContext testContext, String qualifier);1456756222;Get the {@linkplain PlatformTransactionManager transaction manager} to use_for the supplied {@linkplain TestContext test context} and {@code qualifier}._<p>Delegates to {@link #getTransactionManager(TestContext)} if the_supplied {@code qualifier} is {@code null} or empty._@param testContext the test context for which the transaction manager_should be retrieved_@param qualifier the qualifier for selecting between multiple bean matches__may be {@code null} or empty_@return the transaction manager to use, or {@code null} if not found_@throws BeansException if an error occurs while retrieving the transaction manager_@see #getTransactionManager(TestContext);protected PlatformTransactionManager getTransactionManager(TestContext testContext, String qualifier) {_		_		if (StringUtils.hasText(qualifier)) {_			try {_				_				_				_				BeanFactory bf = testContext.getApplicationContext().getAutowireCapableBeanFactory()___				return BeanFactoryAnnotationUtils.qualifiedBeanOfType(bf, PlatformTransactionManager.class, qualifier)__			}_			catch (RuntimeException ex) {_				if (logger.isWarnEnabled()) {_					logger.warn(_						String.format(_							"Caught exception while retrieving transaction manager with qualifier '%s' for test context %s",_							qualifier, testContext), ex)__				}_				throw ex__			}_		}__		_		return getTransactionManager(testContext)__	};get,the,linkplain,platform,transaction,manager,transaction,manager,to,use,for,the,supplied,linkplain,test,context,test,context,and,code,qualifier,p,delegates,to,link,get,transaction,manager,test,context,if,the,supplied,code,qualifier,is,code,null,or,empty,param,test,context,the,test,context,for,which,the,transaction,manager,should,be,retrieved,param,qualifier,the,qualifier,for,selecting,between,multiple,bean,matches,may,be,code,null,or,empty,return,the,transaction,manager,to,use,or,code,null,if,not,found,throws,beans,exception,if,an,error,occurs,while,retrieving,the,transaction,manager,see,get,transaction,manager,test,context;protected,platform,transaction,manager,get,transaction,manager,test,context,test,context,string,qualifier,if,string,utils,has,text,qualifier,try,bean,factory,bf,test,context,get,application,context,get,autowire,capable,bean,factory,return,bean,factory,annotation,utils,qualified,bean,of,type,bf,platform,transaction,manager,class,qualifier,catch,runtime,exception,ex,if,logger,is,warn,enabled,logger,warn,string,format,caught,exception,while,retrieving,transaction,manager,with,qualifier,s,for,test,context,s,qualifier,test,context,ex,throw,ex,return,get,transaction,manager,test,context
TransactionalTestExecutionListener -> protected PlatformTransactionManager getTransactionManager(TestContext testContext, String qualifier);1458754760;Get the {@linkplain PlatformTransactionManager transaction manager} to use_for the supplied {@linkplain TestContext test context} and {@code qualifier}._<p>Delegates to {@link #getTransactionManager(TestContext)} if the_supplied {@code qualifier} is {@code null} or empty._@param testContext the test context for which the transaction manager_should be retrieved_@param qualifier the qualifier for selecting between multiple bean matches__may be {@code null} or empty_@return the transaction manager to use, or {@code null} if not found_@throws BeansException if an error occurs while retrieving the transaction manager_@see #getTransactionManager(TestContext);protected PlatformTransactionManager getTransactionManager(TestContext testContext, String qualifier) {_		_		if (StringUtils.hasText(qualifier)) {_			try {_				_				_				BeanFactory bf = testContext.getApplicationContext().getAutowireCapableBeanFactory()___				return BeanFactoryAnnotationUtils.qualifiedBeanOfType(bf, PlatformTransactionManager.class, qualifier)__			}_			catch (RuntimeException ex) {_				if (logger.isWarnEnabled()) {_					logger.warn(String.format(_							"Caught exception while retrieving transaction manager with qualifier '%s' for test context %s",_							qualifier, testContext), ex)__				}_				throw ex__			}_		}__		_		return getTransactionManager(testContext)__	};get,the,linkplain,platform,transaction,manager,transaction,manager,to,use,for,the,supplied,linkplain,test,context,test,context,and,code,qualifier,p,delegates,to,link,get,transaction,manager,test,context,if,the,supplied,code,qualifier,is,code,null,or,empty,param,test,context,the,test,context,for,which,the,transaction,manager,should,be,retrieved,param,qualifier,the,qualifier,for,selecting,between,multiple,bean,matches,may,be,code,null,or,empty,return,the,transaction,manager,to,use,or,code,null,if,not,found,throws,beans,exception,if,an,error,occurs,while,retrieving,the,transaction,manager,see,get,transaction,manager,test,context;protected,platform,transaction,manager,get,transaction,manager,test,context,test,context,string,qualifier,if,string,utils,has,text,qualifier,try,bean,factory,bf,test,context,get,application,context,get,autowire,capable,bean,factory,return,bean,factory,annotation,utils,qualified,bean,of,type,bf,platform,transaction,manager,class,qualifier,catch,runtime,exception,ex,if,logger,is,warn,enabled,logger,warn,string,format,caught,exception,while,retrieving,transaction,manager,with,qualifier,s,for,test,context,s,qualifier,test,context,ex,throw,ex,return,get,transaction,manager,test,context
TransactionalTestExecutionListener -> protected PlatformTransactionManager getTransactionManager(TestContext testContext, String qualifier);1462294651;Get the {@linkplain PlatformTransactionManager transaction manager} to use_for the supplied {@linkplain TestContext test context} and {@code qualifier}._<p>Delegates to {@link #getTransactionManager(TestContext)} if the_supplied {@code qualifier} is {@code null} or empty._@param testContext the test context for which the transaction manager_should be retrieved_@param qualifier the qualifier for selecting between multiple bean matches__may be {@code null} or empty_@return the transaction manager to use, or {@code null} if not found_@throws BeansException if an error occurs while retrieving the transaction manager_@see #getTransactionManager(TestContext);protected PlatformTransactionManager getTransactionManager(TestContext testContext, String qualifier) {_		_		if (StringUtils.hasText(qualifier)) {_			try {_				_				_				BeanFactory bf = testContext.getApplicationContext().getAutowireCapableBeanFactory()___				return BeanFactoryAnnotationUtils.qualifiedBeanOfType(bf, PlatformTransactionManager.class, qualifier)__			}_			catch (RuntimeException ex) {_				if (logger.isWarnEnabled()) {_					logger.warn(String.format(_							"Caught exception while retrieving transaction manager with qualifier '%s' for test context %s",_							qualifier, testContext), ex)__				}_				throw ex__			}_		}__		_		return getTransactionManager(testContext)__	};get,the,linkplain,platform,transaction,manager,transaction,manager,to,use,for,the,supplied,linkplain,test,context,test,context,and,code,qualifier,p,delegates,to,link,get,transaction,manager,test,context,if,the,supplied,code,qualifier,is,code,null,or,empty,param,test,context,the,test,context,for,which,the,transaction,manager,should,be,retrieved,param,qualifier,the,qualifier,for,selecting,between,multiple,bean,matches,may,be,code,null,or,empty,return,the,transaction,manager,to,use,or,code,null,if,not,found,throws,beans,exception,if,an,error,occurs,while,retrieving,the,transaction,manager,see,get,transaction,manager,test,context;protected,platform,transaction,manager,get,transaction,manager,test,context,test,context,string,qualifier,if,string,utils,has,text,qualifier,try,bean,factory,bf,test,context,get,application,context,get,autowire,capable,bean,factory,return,bean,factory,annotation,utils,qualified,bean,of,type,bf,platform,transaction,manager,class,qualifier,catch,runtime,exception,ex,if,logger,is,warn,enabled,logger,warn,string,format,caught,exception,while,retrieving,transaction,manager,with,qualifier,s,for,test,context,s,qualifier,test,context,ex,throw,ex,return,get,transaction,manager,test,context
TransactionalTestExecutionListener -> protected PlatformTransactionManager getTransactionManager(TestContext testContext, String qualifier);1462299971;Get the {@linkplain PlatformTransactionManager transaction manager} to use_for the supplied {@linkplain TestContext test context} and {@code qualifier}._<p>Delegates to {@link #getTransactionManager(TestContext)} if the_supplied {@code qualifier} is {@code null} or empty._@param testContext the test context for which the transaction manager_should be retrieved_@param qualifier the qualifier for selecting between multiple bean matches__may be {@code null} or empty_@return the transaction manager to use, or {@code null} if not found_@throws BeansException if an error occurs while retrieving the transaction manager_@see #getTransactionManager(TestContext);protected PlatformTransactionManager getTransactionManager(TestContext testContext, String qualifier) {_		_		if (StringUtils.hasText(qualifier)) {_			try {_				_				_				BeanFactory bf = testContext.getApplicationContext().getAutowireCapableBeanFactory()___				return BeanFactoryAnnotationUtils.qualifiedBeanOfType(bf, PlatformTransactionManager.class, qualifier)__			}_			catch (RuntimeException ex) {_				if (logger.isWarnEnabled()) {_					logger.warn(String.format(_							"Caught exception while retrieving transaction manager with qualifier '%s' for test context %s",_							qualifier, testContext), ex)__				}_				throw ex__			}_		}__		_		return getTransactionManager(testContext)__	};get,the,linkplain,platform,transaction,manager,transaction,manager,to,use,for,the,supplied,linkplain,test,context,test,context,and,code,qualifier,p,delegates,to,link,get,transaction,manager,test,context,if,the,supplied,code,qualifier,is,code,null,or,empty,param,test,context,the,test,context,for,which,the,transaction,manager,should,be,retrieved,param,qualifier,the,qualifier,for,selecting,between,multiple,bean,matches,may,be,code,null,or,empty,return,the,transaction,manager,to,use,or,code,null,if,not,found,throws,beans,exception,if,an,error,occurs,while,retrieving,the,transaction,manager,see,get,transaction,manager,test,context;protected,platform,transaction,manager,get,transaction,manager,test,context,test,context,string,qualifier,if,string,utils,has,text,qualifier,try,bean,factory,bf,test,context,get,application,context,get,autowire,capable,bean,factory,return,bean,factory,annotation,utils,qualified,bean,of,type,bf,platform,transaction,manager,class,qualifier,catch,runtime,exception,ex,if,logger,is,warn,enabled,logger,warn,string,format,caught,exception,while,retrieving,transaction,manager,with,qualifier,s,for,test,context,s,qualifier,test,context,ex,throw,ex,return,get,transaction,manager,test,context
TransactionalTestExecutionListener -> protected PlatformTransactionManager getTransactionManager(TestContext testContext, String qualifier);1467730834;Get the {@linkplain PlatformTransactionManager transaction manager} to use_for the supplied {@linkplain TestContext test context} and {@code qualifier}._<p>Delegates to {@link #getTransactionManager(TestContext)} if the_supplied {@code qualifier} is {@code null} or empty._@param testContext the test context for which the transaction manager_should be retrieved_@param qualifier the qualifier for selecting between multiple bean matches__may be {@code null} or empty_@return the transaction manager to use, or {@code null} if not found_@throws BeansException if an error occurs while retrieving the transaction manager_@see #getTransactionManager(TestContext);protected PlatformTransactionManager getTransactionManager(TestContext testContext, String qualifier) {_		_		if (StringUtils.hasText(qualifier)) {_			try {_				_				_				BeanFactory bf = testContext.getApplicationContext().getAutowireCapableBeanFactory()___				return BeanFactoryAnnotationUtils.qualifiedBeanOfType(bf, PlatformTransactionManager.class, qualifier)__			}_			catch (RuntimeException ex) {_				if (logger.isWarnEnabled()) {_					logger.warn(String.format(_							"Caught exception while retrieving transaction manager with qualifier '%s' for test context %s",_							qualifier, testContext), ex)__				}_				throw ex__			}_		}__		_		return getTransactionManager(testContext)__	};get,the,linkplain,platform,transaction,manager,transaction,manager,to,use,for,the,supplied,linkplain,test,context,test,context,and,code,qualifier,p,delegates,to,link,get,transaction,manager,test,context,if,the,supplied,code,qualifier,is,code,null,or,empty,param,test,context,the,test,context,for,which,the,transaction,manager,should,be,retrieved,param,qualifier,the,qualifier,for,selecting,between,multiple,bean,matches,may,be,code,null,or,empty,return,the,transaction,manager,to,use,or,code,null,if,not,found,throws,beans,exception,if,an,error,occurs,while,retrieving,the,transaction,manager,see,get,transaction,manager,test,context;protected,platform,transaction,manager,get,transaction,manager,test,context,test,context,string,qualifier,if,string,utils,has,text,qualifier,try,bean,factory,bf,test,context,get,application,context,get,autowire,capable,bean,factory,return,bean,factory,annotation,utils,qualified,bean,of,type,bf,platform,transaction,manager,class,qualifier,catch,runtime,exception,ex,if,logger,is,warn,enabled,logger,warn,string,format,caught,exception,while,retrieving,transaction,manager,with,qualifier,s,for,test,context,s,qualifier,test,context,ex,throw,ex,return,get,transaction,manager,test,context
TransactionalTestExecutionListener -> protected PlatformTransactionManager getTransactionManager(TestContext testContext, String qualifier);1467992320;Get the {@linkplain PlatformTransactionManager transaction manager} to use_for the supplied {@linkplain TestContext test context} and {@code qualifier}._<p>Delegates to {@link #getTransactionManager(TestContext)} if the_supplied {@code qualifier} is {@code null} or empty._@param testContext the test context for which the transaction manager_should be retrieved_@param qualifier the qualifier for selecting between multiple bean matches__may be {@code null} or empty_@return the transaction manager to use, or {@code null} if not found_@throws BeansException if an error occurs while retrieving the transaction manager_@see #getTransactionManager(TestContext);protected PlatformTransactionManager getTransactionManager(TestContext testContext, String qualifier) {_		_		if (StringUtils.hasText(qualifier)) {_			try {_				_				_				BeanFactory bf = testContext.getApplicationContext().getAutowireCapableBeanFactory()___				return BeanFactoryAnnotationUtils.qualifiedBeanOfType(bf, PlatformTransactionManager.class, qualifier)__			}_			catch (RuntimeException ex) {_				if (logger.isWarnEnabled()) {_					logger.warn(String.format(_							"Caught exception while retrieving transaction manager with qualifier '%s' for test context %s",_							qualifier, testContext), ex)__				}_				throw ex__			}_		}__		_		return getTransactionManager(testContext)__	};get,the,linkplain,platform,transaction,manager,transaction,manager,to,use,for,the,supplied,linkplain,test,context,test,context,and,code,qualifier,p,delegates,to,link,get,transaction,manager,test,context,if,the,supplied,code,qualifier,is,code,null,or,empty,param,test,context,the,test,context,for,which,the,transaction,manager,should,be,retrieved,param,qualifier,the,qualifier,for,selecting,between,multiple,bean,matches,may,be,code,null,or,empty,return,the,transaction,manager,to,use,or,code,null,if,not,found,throws,beans,exception,if,an,error,occurs,while,retrieving,the,transaction,manager,see,get,transaction,manager,test,context;protected,platform,transaction,manager,get,transaction,manager,test,context,test,context,string,qualifier,if,string,utils,has,text,qualifier,try,bean,factory,bf,test,context,get,application,context,get,autowire,capable,bean,factory,return,bean,factory,annotation,utils,qualified,bean,of,type,bf,platform,transaction,manager,class,qualifier,catch,runtime,exception,ex,if,logger,is,warn,enabled,logger,warn,string,format,caught,exception,while,retrieving,transaction,manager,with,qualifier,s,for,test,context,s,qualifier,test,context,ex,throw,ex,return,get,transaction,manager,test,context
TransactionalTestExecutionListener -> protected PlatformTransactionManager getTransactionManager(TestContext testContext, String qualifier);1467992442;Get the {@linkplain PlatformTransactionManager transaction manager} to use_for the supplied {@linkplain TestContext test context} and {@code qualifier}._<p>Delegates to {@link #getTransactionManager(TestContext)} if the_supplied {@code qualifier} is {@code null} or empty._@param testContext the test context for which the transaction manager_should be retrieved_@param qualifier the qualifier for selecting between multiple bean matches__may be {@code null} or empty_@return the transaction manager to use, or {@code null} if not found_@throws BeansException if an error occurs while retrieving the transaction manager_@see #getTransactionManager(TestContext);protected PlatformTransactionManager getTransactionManager(TestContext testContext, String qualifier) {_		_		if (StringUtils.hasText(qualifier)) {_			try {_				_				_				BeanFactory bf = testContext.getApplicationContext().getAutowireCapableBeanFactory()___				return BeanFactoryAnnotationUtils.qualifiedBeanOfType(bf, PlatformTransactionManager.class, qualifier)__			}_			catch (RuntimeException ex) {_				if (logger.isWarnEnabled()) {_					logger.warn(String.format(_							"Caught exception while retrieving transaction manager with qualifier '%s' for test context %s",_							qualifier, testContext), ex)__				}_				throw ex__			}_		}__		_		return getTransactionManager(testContext)__	};get,the,linkplain,platform,transaction,manager,transaction,manager,to,use,for,the,supplied,linkplain,test,context,test,context,and,code,qualifier,p,delegates,to,link,get,transaction,manager,test,context,if,the,supplied,code,qualifier,is,code,null,or,empty,param,test,context,the,test,context,for,which,the,transaction,manager,should,be,retrieved,param,qualifier,the,qualifier,for,selecting,between,multiple,bean,matches,may,be,code,null,or,empty,return,the,transaction,manager,to,use,or,code,null,if,not,found,throws,beans,exception,if,an,error,occurs,while,retrieving,the,transaction,manager,see,get,transaction,manager,test,context;protected,platform,transaction,manager,get,transaction,manager,test,context,test,context,string,qualifier,if,string,utils,has,text,qualifier,try,bean,factory,bf,test,context,get,application,context,get,autowire,capable,bean,factory,return,bean,factory,annotation,utils,qualified,bean,of,type,bf,platform,transaction,manager,class,qualifier,catch,runtime,exception,ex,if,logger,is,warn,enabled,logger,warn,string,format,caught,exception,while,retrieving,transaction,manager,with,qualifier,s,for,test,context,s,qualifier,test,context,ex,throw,ex,return,get,transaction,manager,test,context
TransactionalTestExecutionListener -> protected PlatformTransactionManager getTransactionManager(TestContext testContext, String qualifier);1467994604;Get the {@linkplain PlatformTransactionManager transaction manager} to use_for the supplied {@linkplain TestContext test context} and {@code qualifier}._<p>Delegates to {@link #getTransactionManager(TestContext)} if the_supplied {@code qualifier} is {@code null} or empty._@param testContext the test context for which the transaction manager_should be retrieved_@param qualifier the qualifier for selecting between multiple bean matches__may be {@code null} or empty_@return the transaction manager to use, or {@code null} if not found_@throws BeansException if an error occurs while retrieving the transaction manager_@see #getTransactionManager(TestContext);protected PlatformTransactionManager getTransactionManager(TestContext testContext, String qualifier) {_		_		if (StringUtils.hasText(qualifier)) {_			try {_				_				_				BeanFactory bf = testContext.getApplicationContext().getAutowireCapableBeanFactory()___				return BeanFactoryAnnotationUtils.qualifiedBeanOfType(bf, PlatformTransactionManager.class, qualifier)__			}_			catch (RuntimeException ex) {_				if (logger.isWarnEnabled()) {_					logger.warn(String.format(_							"Caught exception while retrieving transaction manager with qualifier '%s' for test context %s",_							qualifier, testContext), ex)__				}_				throw ex__			}_		}__		_		return getTransactionManager(testContext)__	};get,the,linkplain,platform,transaction,manager,transaction,manager,to,use,for,the,supplied,linkplain,test,context,test,context,and,code,qualifier,p,delegates,to,link,get,transaction,manager,test,context,if,the,supplied,code,qualifier,is,code,null,or,empty,param,test,context,the,test,context,for,which,the,transaction,manager,should,be,retrieved,param,qualifier,the,qualifier,for,selecting,between,multiple,bean,matches,may,be,code,null,or,empty,return,the,transaction,manager,to,use,or,code,null,if,not,found,throws,beans,exception,if,an,error,occurs,while,retrieving,the,transaction,manager,see,get,transaction,manager,test,context;protected,platform,transaction,manager,get,transaction,manager,test,context,test,context,string,qualifier,if,string,utils,has,text,qualifier,try,bean,factory,bf,test,context,get,application,context,get,autowire,capable,bean,factory,return,bean,factory,annotation,utils,qualified,bean,of,type,bf,platform,transaction,manager,class,qualifier,catch,runtime,exception,ex,if,logger,is,warn,enabled,logger,warn,string,format,caught,exception,while,retrieving,transaction,manager,with,qualifier,s,for,test,context,s,qualifier,test,context,ex,throw,ex,return,get,transaction,manager,test,context
TransactionalTestExecutionListener -> protected PlatformTransactionManager getTransactionManager(TestContext testContext, String qualifier);1468334463;Get the {@linkplain PlatformTransactionManager transaction manager} to use_for the supplied {@linkplain TestContext test context} and {@code qualifier}._<p>Delegates to {@link #getTransactionManager(TestContext)} if the_supplied {@code qualifier} is {@code null} or empty._@param testContext the test context for which the transaction manager_should be retrieved_@param qualifier the qualifier for selecting between multiple bean matches__may be {@code null} or empty_@return the transaction manager to use, or {@code null} if not found_@throws BeansException if an error occurs while retrieving the transaction manager_@see #getTransactionManager(TestContext);protected PlatformTransactionManager getTransactionManager(TestContext testContext, String qualifier) {_		_		if (StringUtils.hasText(qualifier)) {_			try {_				_				_				BeanFactory bf = testContext.getApplicationContext().getAutowireCapableBeanFactory()___				return BeanFactoryAnnotationUtils.qualifiedBeanOfType(bf, PlatformTransactionManager.class, qualifier)__			}_			catch (RuntimeException ex) {_				if (logger.isWarnEnabled()) {_					logger.warn(String.format(_							"Caught exception while retrieving transaction manager with qualifier '%s' for test context %s",_							qualifier, testContext), ex)__				}_				throw ex__			}_		}__		_		return getTransactionManager(testContext)__	};get,the,linkplain,platform,transaction,manager,transaction,manager,to,use,for,the,supplied,linkplain,test,context,test,context,and,code,qualifier,p,delegates,to,link,get,transaction,manager,test,context,if,the,supplied,code,qualifier,is,code,null,or,empty,param,test,context,the,test,context,for,which,the,transaction,manager,should,be,retrieved,param,qualifier,the,qualifier,for,selecting,between,multiple,bean,matches,may,be,code,null,or,empty,return,the,transaction,manager,to,use,or,code,null,if,not,found,throws,beans,exception,if,an,error,occurs,while,retrieving,the,transaction,manager,see,get,transaction,manager,test,context;protected,platform,transaction,manager,get,transaction,manager,test,context,test,context,string,qualifier,if,string,utils,has,text,qualifier,try,bean,factory,bf,test,context,get,application,context,get,autowire,capable,bean,factory,return,bean,factory,annotation,utils,qualified,bean,of,type,bf,platform,transaction,manager,class,qualifier,catch,runtime,exception,ex,if,logger,is,warn,enabled,logger,warn,string,format,caught,exception,while,retrieving,transaction,manager,with,qualifier,s,for,test,context,s,qualifier,test,context,ex,throw,ex,return,get,transaction,manager,test,context
TransactionalTestExecutionListener -> protected PlatformTransactionManager getTransactionManager(TestContext testContext);1382920864;Get the {@link PlatformTransactionManager transaction manager} to use_for the supplied {@link TestContext test context}._@param testContext the test context for which the transaction manager_should be retrieved_@return the transaction manager to use, or {@code null} if not found_@throws BeansException if an error occurs while retrieving the transaction manager_@see #getTransactionManager(TestContext, String);protected PlatformTransactionManager getTransactionManager(TestContext testContext) {_		BeanFactory bf = testContext.getApplicationContext().getAutowireCapableBeanFactory()__		String tmName = retrieveConfigurationAttributes(testContext).getTransactionManagerName()___		try {_			_			if (StringUtils.hasText(tmName) && !DEFAULT_TRANSACTION_MANAGER_NAME.equals(tmName)) {_				return bf.getBean(tmName, PlatformTransactionManager.class)__			}__			if (bf instanceof ListableBeanFactory) {_				ListableBeanFactory lbf = (ListableBeanFactory) bf___				_				Map<String, PlatformTransactionManager> txMgrs = BeanFactoryUtils.beansOfTypeIncludingAncestors(lbf,_					PlatformTransactionManager.class)__				if (txMgrs.size() == 1) {_					return txMgrs.values().iterator().next()__				}__				_				Map<String, TransactionManagementConfigurer> configurers = BeanFactoryUtils.beansOfTypeIncludingAncestors(_					lbf, TransactionManagementConfigurer.class)__				if (configurers.size() > 1) {_					throw new IllegalStateException(_						"Only one TransactionManagementConfigurer may exist in the ApplicationContext")__				}_				if (configurers.size() == 1) {_					return configurers.values().iterator().next().annotationDrivenTransactionManager()__				}_			}__			_			return bf.getBean(DEFAULT_TRANSACTION_MANAGER_NAME, PlatformTransactionManager.class)___		}_		catch (BeansException ex) {_			if (logger.isWarnEnabled()) {_				logger.warn("Caught exception while retrieving transaction manager for test context " + testContext, ex)__			}_			throw ex__		}_	};get,the,link,platform,transaction,manager,transaction,manager,to,use,for,the,supplied,link,test,context,test,context,param,test,context,the,test,context,for,which,the,transaction,manager,should,be,retrieved,return,the,transaction,manager,to,use,or,code,null,if,not,found,throws,beans,exception,if,an,error,occurs,while,retrieving,the,transaction,manager,see,get,transaction,manager,test,context,string;protected,platform,transaction,manager,get,transaction,manager,test,context,test,context,bean,factory,bf,test,context,get,application,context,get,autowire,capable,bean,factory,string,tm,name,retrieve,configuration,attributes,test,context,get,transaction,manager,name,try,if,string,utils,has,text,tm,name,equals,tm,name,return,bf,get,bean,tm,name,platform,transaction,manager,class,if,bf,instanceof,listable,bean,factory,listable,bean,factory,lbf,listable,bean,factory,bf,map,string,platform,transaction,manager,tx,mgrs,bean,factory,utils,beans,of,type,including,ancestors,lbf,platform,transaction,manager,class,if,tx,mgrs,size,1,return,tx,mgrs,values,iterator,next,map,string,transaction,management,configurer,configurers,bean,factory,utils,beans,of,type,including,ancestors,lbf,transaction,management,configurer,class,if,configurers,size,1,throw,new,illegal,state,exception,only,one,transaction,management,configurer,may,exist,in,the,application,context,if,configurers,size,1,return,configurers,values,iterator,next,annotation,driven,transaction,manager,return,bf,get,bean,platform,transaction,manager,class,catch,beans,exception,ex,if,logger,is,warn,enabled,logger,warn,caught,exception,while,retrieving,transaction,manager,for,test,context,test,context,ex,throw,ex
TransactionalTestExecutionListener -> protected PlatformTransactionManager getTransactionManager(TestContext testContext);1385499540;Get the {@link PlatformTransactionManager transaction manager} to use_for the supplied {@link TestContext test context}._@param testContext the test context for which the transaction manager_should be retrieved_@return the transaction manager to use, or {@code null} if not found_@throws BeansException if an error occurs while retrieving the transaction manager_@see #getTransactionManager(TestContext, String);protected PlatformTransactionManager getTransactionManager(TestContext testContext) {_		BeanFactory bf = testContext.getApplicationContext().getAutowireCapableBeanFactory()__		String tmName = retrieveConfigurationAttributes(testContext).getTransactionManagerName()___		try {_			_			if (StringUtils.hasText(tmName) && !DEFAULT_TRANSACTION_MANAGER_NAME.equals(tmName)) {_				return bf.getBean(tmName, PlatformTransactionManager.class)__			}__			if (bf instanceof ListableBeanFactory) {_				ListableBeanFactory lbf = (ListableBeanFactory) bf___				_				Map<String, PlatformTransactionManager> txMgrs = BeanFactoryUtils.beansOfTypeIncludingAncestors(lbf,_					PlatformTransactionManager.class)__				if (txMgrs.size() == 1) {_					return txMgrs.values().iterator().next()__				}__				_				Map<String, TransactionManagementConfigurer> configurers = BeanFactoryUtils.beansOfTypeIncludingAncestors(_					lbf, TransactionManagementConfigurer.class)__				if (configurers.size() > 1) {_					throw new IllegalStateException(_						"Only one TransactionManagementConfigurer may exist in the ApplicationContext")__				}_				if (configurers.size() == 1) {_					return configurers.values().iterator().next().annotationDrivenTransactionManager()__				}_			}__			_			return bf.getBean(DEFAULT_TRANSACTION_MANAGER_NAME, PlatformTransactionManager.class)___		}_		catch (BeansException ex) {_			if (logger.isWarnEnabled()) {_				logger.warn("Caught exception while retrieving transaction manager for test context " + testContext, ex)__			}_			throw ex__		}_	};get,the,link,platform,transaction,manager,transaction,manager,to,use,for,the,supplied,link,test,context,test,context,param,test,context,the,test,context,for,which,the,transaction,manager,should,be,retrieved,return,the,transaction,manager,to,use,or,code,null,if,not,found,throws,beans,exception,if,an,error,occurs,while,retrieving,the,transaction,manager,see,get,transaction,manager,test,context,string;protected,platform,transaction,manager,get,transaction,manager,test,context,test,context,bean,factory,bf,test,context,get,application,context,get,autowire,capable,bean,factory,string,tm,name,retrieve,configuration,attributes,test,context,get,transaction,manager,name,try,if,string,utils,has,text,tm,name,equals,tm,name,return,bf,get,bean,tm,name,platform,transaction,manager,class,if,bf,instanceof,listable,bean,factory,listable,bean,factory,lbf,listable,bean,factory,bf,map,string,platform,transaction,manager,tx,mgrs,bean,factory,utils,beans,of,type,including,ancestors,lbf,platform,transaction,manager,class,if,tx,mgrs,size,1,return,tx,mgrs,values,iterator,next,map,string,transaction,management,configurer,configurers,bean,factory,utils,beans,of,type,including,ancestors,lbf,transaction,management,configurer,class,if,configurers,size,1,throw,new,illegal,state,exception,only,one,transaction,management,configurer,may,exist,in,the,application,context,if,configurers,size,1,return,configurers,values,iterator,next,annotation,driven,transaction,manager,return,bf,get,bean,platform,transaction,manager,class,catch,beans,exception,ex,if,logger,is,warn,enabled,logger,warn,caught,exception,while,retrieving,transaction,manager,for,test,context,test,context,ex,throw,ex
TransactionalTestExecutionListener -> protected PlatformTransactionManager getTransactionManager(TestContext testContext);1389966876;Get the {@link PlatformTransactionManager transaction manager} to use_for the supplied {@link TestContext test context}._@param testContext the test context for which the transaction manager_should be retrieved_@return the transaction manager to use, or {@code null} if not found_@throws BeansException if an error occurs while retrieving the transaction manager_@see #getTransactionManager(TestContext, String);protected PlatformTransactionManager getTransactionManager(TestContext testContext) {_		BeanFactory bf = testContext.getApplicationContext().getAutowireCapableBeanFactory()__		String tmName = retrieveConfigurationAttributes(testContext).getTransactionManagerName()___		try {_			_			if (StringUtils.hasText(tmName) && !DEFAULT_TRANSACTION_MANAGER_NAME.equals(tmName)) {_				return bf.getBean(tmName, PlatformTransactionManager.class)__			}__			if (bf instanceof ListableBeanFactory) {_				ListableBeanFactory lbf = (ListableBeanFactory) bf___				_				Map<String, PlatformTransactionManager> txMgrs = BeanFactoryUtils.beansOfTypeIncludingAncestors(lbf,_					PlatformTransactionManager.class)__				if (txMgrs.size() == 1) {_					return txMgrs.values().iterator().next()__				}__				_				Map<String, TransactionManagementConfigurer> configurers = BeanFactoryUtils.beansOfTypeIncludingAncestors(_					lbf, TransactionManagementConfigurer.class)__				if (configurers.size() > 1) {_					throw new IllegalStateException(_						"Only one TransactionManagementConfigurer may exist in the ApplicationContext")__				}_				if (configurers.size() == 1) {_					return configurers.values().iterator().next().annotationDrivenTransactionManager()__				}_			}__			_			return bf.getBean(DEFAULT_TRANSACTION_MANAGER_NAME, PlatformTransactionManager.class)___		}_		catch (BeansException ex) {_			if (logger.isWarnEnabled()) {_				logger.warn("Caught exception while retrieving transaction manager for test context " + testContext, ex)__			}_			throw ex__		}_	};get,the,link,platform,transaction,manager,transaction,manager,to,use,for,the,supplied,link,test,context,test,context,param,test,context,the,test,context,for,which,the,transaction,manager,should,be,retrieved,return,the,transaction,manager,to,use,or,code,null,if,not,found,throws,beans,exception,if,an,error,occurs,while,retrieving,the,transaction,manager,see,get,transaction,manager,test,context,string;protected,platform,transaction,manager,get,transaction,manager,test,context,test,context,bean,factory,bf,test,context,get,application,context,get,autowire,capable,bean,factory,string,tm,name,retrieve,configuration,attributes,test,context,get,transaction,manager,name,try,if,string,utils,has,text,tm,name,equals,tm,name,return,bf,get,bean,tm,name,platform,transaction,manager,class,if,bf,instanceof,listable,bean,factory,listable,bean,factory,lbf,listable,bean,factory,bf,map,string,platform,transaction,manager,tx,mgrs,bean,factory,utils,beans,of,type,including,ancestors,lbf,platform,transaction,manager,class,if,tx,mgrs,size,1,return,tx,mgrs,values,iterator,next,map,string,transaction,management,configurer,configurers,bean,factory,utils,beans,of,type,including,ancestors,lbf,transaction,management,configurer,class,if,configurers,size,1,throw,new,illegal,state,exception,only,one,transaction,management,configurer,may,exist,in,the,application,context,if,configurers,size,1,return,configurers,values,iterator,next,annotation,driven,transaction,manager,return,bf,get,bean,platform,transaction,manager,class,catch,beans,exception,ex,if,logger,is,warn,enabled,logger,warn,caught,exception,while,retrieving,transaction,manager,for,test,context,test,context,ex,throw,ex
TransactionalTestExecutionListener -> protected PlatformTransactionManager getTransactionManager(TestContext testContext);1401991965;Get the {@link PlatformTransactionManager transaction manager} to use_for the supplied {@link TestContext test context}._<p>The default implementation simply delegates to_{@link TestContextTransactionUtils#retrieveTransactionManager}._@param testContext the test context for which the transaction manager_should be retrieved_@return the transaction manager to use, or {@code null} if not found_@throws BeansException if an error occurs while retrieving the transaction manager_@see #getTransactionManager(TestContext, String);protected PlatformTransactionManager getTransactionManager(TestContext testContext) {_		String tmName = retrieveConfigurationAttributes(testContext).getTransactionManagerName()__		return TestContextTransactionUtils.retrieveTransactionManager(testContext, tmName)__	};get,the,link,platform,transaction,manager,transaction,manager,to,use,for,the,supplied,link,test,context,test,context,p,the,default,implementation,simply,delegates,to,link,test,context,transaction,utils,retrieve,transaction,manager,param,test,context,the,test,context,for,which,the,transaction,manager,should,be,retrieved,return,the,transaction,manager,to,use,or,code,null,if,not,found,throws,beans,exception,if,an,error,occurs,while,retrieving,the,transaction,manager,see,get,transaction,manager,test,context,string;protected,platform,transaction,manager,get,transaction,manager,test,context,test,context,string,tm,name,retrieve,configuration,attributes,test,context,get,transaction,manager,name,return,test,context,transaction,utils,retrieve,transaction,manager,test,context,tm,name
TransactionalTestExecutionListener -> protected PlatformTransactionManager getTransactionManager(TestContext testContext);1404334604;Get the {@link PlatformTransactionManager transaction manager} to use_for the supplied {@link TestContext test context}._<p>The default implementation simply delegates to_{@link TestContextTransactionUtils#retrieveTransactionManager}._@param testContext the test context for which the transaction manager_should be retrieved_@return the transaction manager to use, or {@code null} if not found_@throws BeansException if an error occurs while retrieving the transaction manager_@see #getTransactionManager(TestContext, String);protected PlatformTransactionManager getTransactionManager(TestContext testContext) {_		String tmName = retrieveConfigurationAttributes(testContext).getTransactionManagerName()__		return TestContextTransactionUtils.retrieveTransactionManager(testContext, tmName)__	};get,the,link,platform,transaction,manager,transaction,manager,to,use,for,the,supplied,link,test,context,test,context,p,the,default,implementation,simply,delegates,to,link,test,context,transaction,utils,retrieve,transaction,manager,param,test,context,the,test,context,for,which,the,transaction,manager,should,be,retrieved,return,the,transaction,manager,to,use,or,code,null,if,not,found,throws,beans,exception,if,an,error,occurs,while,retrieving,the,transaction,manager,see,get,transaction,manager,test,context,string;protected,platform,transaction,manager,get,transaction,manager,test,context,test,context,string,tm,name,retrieve,configuration,attributes,test,context,get,transaction,manager,name,return,test,context,transaction,utils,retrieve,transaction,manager,test,context,tm,name
TransactionalTestExecutionListener -> protected PlatformTransactionManager getTransactionManager(TestContext testContext);1405645143;Get the {@link PlatformTransactionManager transaction manager} to use_for the supplied {@link TestContext test context}._<p>The default implementation simply delegates to_{@link TestContextTransactionUtils#retrieveTransactionManager}._@param testContext the test context for which the transaction manager_should be retrieved_@return the transaction manager to use, or {@code null} if not found_@throws BeansException if an error occurs while retrieving an explicitly_named transaction manager_@see #getTransactionManager(TestContext, String);protected PlatformTransactionManager getTransactionManager(TestContext testContext) {_		String tmName = retrieveConfigurationAttributes(testContext).getTransactionManagerName()__		return TestContextTransactionUtils.retrieveTransactionManager(testContext, tmName)__	};get,the,link,platform,transaction,manager,transaction,manager,to,use,for,the,supplied,link,test,context,test,context,p,the,default,implementation,simply,delegates,to,link,test,context,transaction,utils,retrieve,transaction,manager,param,test,context,the,test,context,for,which,the,transaction,manager,should,be,retrieved,return,the,transaction,manager,to,use,or,code,null,if,not,found,throws,beans,exception,if,an,error,occurs,while,retrieving,an,explicitly,named,transaction,manager,see,get,transaction,manager,test,context,string;protected,platform,transaction,manager,get,transaction,manager,test,context,test,context,string,tm,name,retrieve,configuration,attributes,test,context,get,transaction,manager,name,return,test,context,transaction,utils,retrieve,transaction,manager,test,context,tm,name
TransactionalTestExecutionListener -> protected PlatformTransactionManager getTransactionManager(TestContext testContext);1405698612;Get the {@link PlatformTransactionManager transaction manager} to use_for the supplied {@link TestContext test context}._<p>The default implementation simply delegates to_{@link TestContextTransactionUtils#retrieveTransactionManager}._@param testContext the test context for which the transaction manager_should be retrieved_@return the transaction manager to use, or {@code null} if not found_@throws BeansException if an error occurs while retrieving an explicitly_named transaction manager_@see #getTransactionManager(TestContext, String);protected PlatformTransactionManager getTransactionManager(TestContext testContext) {_		String tmName = retrieveConfigurationAttributes(testContext).getTransactionManagerName()__		return TestContextTransactionUtils.retrieveTransactionManager(testContext, tmName)__	};get,the,link,platform,transaction,manager,transaction,manager,to,use,for,the,supplied,link,test,context,test,context,p,the,default,implementation,simply,delegates,to,link,test,context,transaction,utils,retrieve,transaction,manager,param,test,context,the,test,context,for,which,the,transaction,manager,should,be,retrieved,return,the,transaction,manager,to,use,or,code,null,if,not,found,throws,beans,exception,if,an,error,occurs,while,retrieving,an,explicitly,named,transaction,manager,see,get,transaction,manager,test,context,string;protected,platform,transaction,manager,get,transaction,manager,test,context,test,context,string,tm,name,retrieve,configuration,attributes,test,context,get,transaction,manager,name,return,test,context,transaction,utils,retrieve,transaction,manager,test,context,tm,name
TransactionalTestExecutionListener -> protected PlatformTransactionManager getTransactionManager(TestContext testContext);1405759527;Get the {@link PlatformTransactionManager transaction manager} to use_for the supplied {@link TestContext test context}._<p>The default implementation simply delegates to_{@link TestContextTransactionUtils#retrieveTransactionManager}._@param testContext the test context for which the transaction manager_should be retrieved_@return the transaction manager to use, or {@code null} if not found_@throws BeansException if an error occurs while retrieving an explicitly_named transaction manager_@see #getTransactionManager(TestContext, String);protected PlatformTransactionManager getTransactionManager(TestContext testContext) {_		String tmName = retrieveConfigurationAttributes(testContext).getTransactionManagerName()__		return TestContextTransactionUtils.retrieveTransactionManager(testContext, tmName)__	};get,the,link,platform,transaction,manager,transaction,manager,to,use,for,the,supplied,link,test,context,test,context,p,the,default,implementation,simply,delegates,to,link,test,context,transaction,utils,retrieve,transaction,manager,param,test,context,the,test,context,for,which,the,transaction,manager,should,be,retrieved,return,the,transaction,manager,to,use,or,code,null,if,not,found,throws,beans,exception,if,an,error,occurs,while,retrieving,an,explicitly,named,transaction,manager,see,get,transaction,manager,test,context,string;protected,platform,transaction,manager,get,transaction,manager,test,context,test,context,string,tm,name,retrieve,configuration,attributes,test,context,get,transaction,manager,name,return,test,context,transaction,utils,retrieve,transaction,manager,test,context,tm,name
TransactionalTestExecutionListener -> protected PlatformTransactionManager getTransactionManager(TestContext testContext);1405759966;Get the {@link PlatformTransactionManager transaction manager} to use_for the supplied {@link TestContext test context}._<p>The default implementation simply delegates to_{@link TestContextTransactionUtils#retrieveTransactionManager}._@param testContext the test context for which the transaction manager_should be retrieved_@return the transaction manager to use, or {@code null} if not found_@throws BeansException if an error occurs while retrieving an explicitly_named transaction manager_@see #getTransactionManager(TestContext, String);protected PlatformTransactionManager getTransactionManager(TestContext testContext) {_		String tmName = retrieveConfigurationAttributes(testContext).getTransactionManagerName()__		return TestContextTransactionUtils.retrieveTransactionManager(testContext, tmName)__	};get,the,link,platform,transaction,manager,transaction,manager,to,use,for,the,supplied,link,test,context,test,context,p,the,default,implementation,simply,delegates,to,link,test,context,transaction,utils,retrieve,transaction,manager,param,test,context,the,test,context,for,which,the,transaction,manager,should,be,retrieved,return,the,transaction,manager,to,use,or,code,null,if,not,found,throws,beans,exception,if,an,error,occurs,while,retrieving,an,explicitly,named,transaction,manager,see,get,transaction,manager,test,context,string;protected,platform,transaction,manager,get,transaction,manager,test,context,test,context,string,tm,name,retrieve,configuration,attributes,test,context,get,transaction,manager,name,return,test,context,transaction,utils,retrieve,transaction,manager,test,context,tm,name
TransactionalTestExecutionListener -> protected PlatformTransactionManager getTransactionManager(TestContext testContext);1406218418;Get the {@link PlatformTransactionManager transaction manager} to use_for the supplied {@link TestContext test context}._<p>The default implementation simply delegates to_{@link TestContextTransactionUtils#retrieveTransactionManager}._@param testContext the test context for which the transaction manager_should be retrieved_@return the transaction manager to use, or {@code null} if not found_@throws BeansException if an error occurs while retrieving an explicitly_named transaction manager_@see #getTransactionManager(TestContext, String);protected PlatformTransactionManager getTransactionManager(TestContext testContext) {_		String tmName = retrieveConfigurationAttributes(testContext).getTransactionManagerName()__		return TestContextTransactionUtils.retrieveTransactionManager(testContext, tmName)__	};get,the,link,platform,transaction,manager,transaction,manager,to,use,for,the,supplied,link,test,context,test,context,p,the,default,implementation,simply,delegates,to,link,test,context,transaction,utils,retrieve,transaction,manager,param,test,context,the,test,context,for,which,the,transaction,manager,should,be,retrieved,return,the,transaction,manager,to,use,or,code,null,if,not,found,throws,beans,exception,if,an,error,occurs,while,retrieving,an,explicitly,named,transaction,manager,see,get,transaction,manager,test,context,string;protected,platform,transaction,manager,get,transaction,manager,test,context,test,context,string,tm,name,retrieve,configuration,attributes,test,context,get,transaction,manager,name,return,test,context,transaction,utils,retrieve,transaction,manager,test,context,tm,name
TransactionalTestExecutionListener -> protected PlatformTransactionManager getTransactionManager(TestContext testContext);1407419079;Get the {@link PlatformTransactionManager transaction manager} to use_for the supplied {@link TestContext test context}._<p>The default implementation simply delegates to_{@link TestContextTransactionUtils#retrieveTransactionManager}._@param testContext the test context for which the transaction manager_should be retrieved_@return the transaction manager to use, or {@code null} if not found_@throws BeansException if an error occurs while retrieving an explicitly_named transaction manager_@see #getTransactionManager(TestContext, String);protected PlatformTransactionManager getTransactionManager(TestContext testContext) {_		String tmName = retrieveConfigurationAttributes(testContext).getTransactionManagerName()__		return TestContextTransactionUtils.retrieveTransactionManager(testContext, tmName)__	};get,the,link,platform,transaction,manager,transaction,manager,to,use,for,the,supplied,link,test,context,test,context,p,the,default,implementation,simply,delegates,to,link,test,context,transaction,utils,retrieve,transaction,manager,param,test,context,the,test,context,for,which,the,transaction,manager,should,be,retrieved,return,the,transaction,manager,to,use,or,code,null,if,not,found,throws,beans,exception,if,an,error,occurs,while,retrieving,an,explicitly,named,transaction,manager,see,get,transaction,manager,test,context,string;protected,platform,transaction,manager,get,transaction,manager,test,context,test,context,string,tm,name,retrieve,configuration,attributes,test,context,get,transaction,manager,name,return,test,context,transaction,utils,retrieve,transaction,manager,test,context,tm,name
TransactionalTestExecutionListener -> protected PlatformTransactionManager getTransactionManager(TestContext testContext);1408048216;Get the {@link PlatformTransactionManager transaction manager} to use_for the supplied {@link TestContext test context}._<p>The default implementation simply delegates to_{@link TestContextTransactionUtils#retrieveTransactionManager}._@param testContext the test context for which the transaction manager_should be retrieved_@return the transaction manager to use, or {@code null} if not found_@throws BeansException if an error occurs while retrieving an explicitly_named transaction manager_@see #getTransactionManager(TestContext, String);protected PlatformTransactionManager getTransactionManager(TestContext testContext) {_		String tmName = retrieveConfigurationAttributes(testContext).getTransactionManagerName()__		return TestContextTransactionUtils.retrieveTransactionManager(testContext, tmName)__	};get,the,link,platform,transaction,manager,transaction,manager,to,use,for,the,supplied,link,test,context,test,context,p,the,default,implementation,simply,delegates,to,link,test,context,transaction,utils,retrieve,transaction,manager,param,test,context,the,test,context,for,which,the,transaction,manager,should,be,retrieved,return,the,transaction,manager,to,use,or,code,null,if,not,found,throws,beans,exception,if,an,error,occurs,while,retrieving,an,explicitly,named,transaction,manager,see,get,transaction,manager,test,context,string;protected,platform,transaction,manager,get,transaction,manager,test,context,test,context,string,tm,name,retrieve,configuration,attributes,test,context,get,transaction,manager,name,return,test,context,transaction,utils,retrieve,transaction,manager,test,context,tm,name
TransactionalTestExecutionListener -> protected PlatformTransactionManager getTransactionManager(TestContext testContext);1413848647;Get the {@link PlatformTransactionManager transaction manager} to use_for the supplied {@link TestContext test context}._<p>The default implementation simply delegates to_{@link TestContextTransactionUtils#retrieveTransactionManager}._@param testContext the test context for which the transaction manager_should be retrieved_@return the transaction manager to use, or {@code null} if not found_@throws BeansException if an error occurs while retrieving an explicitly_named transaction manager_@see #getTransactionManager(TestContext, String);protected PlatformTransactionManager getTransactionManager(TestContext testContext) {_		String tmName = retrieveConfigurationAttributes(testContext).getTransactionManagerName()__		return TestContextTransactionUtils.retrieveTransactionManager(testContext, tmName)__	};get,the,link,platform,transaction,manager,transaction,manager,to,use,for,the,supplied,link,test,context,test,context,p,the,default,implementation,simply,delegates,to,link,test,context,transaction,utils,retrieve,transaction,manager,param,test,context,the,test,context,for,which,the,transaction,manager,should,be,retrieved,return,the,transaction,manager,to,use,or,code,null,if,not,found,throws,beans,exception,if,an,error,occurs,while,retrieving,an,explicitly,named,transaction,manager,see,get,transaction,manager,test,context,string;protected,platform,transaction,manager,get,transaction,manager,test,context,test,context,string,tm,name,retrieve,configuration,attributes,test,context,get,transaction,manager,name,return,test,context,transaction,utils,retrieve,transaction,manager,test,context,tm,name
TransactionalTestExecutionListener -> protected PlatformTransactionManager getTransactionManager(TestContext testContext);1431568199;Get the {@link PlatformTransactionManager transaction manager} to use_for the supplied {@link TestContext test context}._<p>The default implementation simply delegates to_{@link TestContextTransactionUtils#retrieveTransactionManager}._@param testContext the test context for which the transaction manager_should be retrieved_@return the transaction manager to use, or {@code null} if not found_@throws BeansException if an error occurs while retrieving an explicitly_named transaction manager_@see #getTransactionManager(TestContext, String);protected PlatformTransactionManager getTransactionManager(TestContext testContext) {_		String tmName = retrieveConfigurationAttributes(testContext).getTransactionManagerName()__		return TestContextTransactionUtils.retrieveTransactionManager(testContext, tmName)__	};get,the,link,platform,transaction,manager,transaction,manager,to,use,for,the,supplied,link,test,context,test,context,p,the,default,implementation,simply,delegates,to,link,test,context,transaction,utils,retrieve,transaction,manager,param,test,context,the,test,context,for,which,the,transaction,manager,should,be,retrieved,return,the,transaction,manager,to,use,or,code,null,if,not,found,throws,beans,exception,if,an,error,occurs,while,retrieving,an,explicitly,named,transaction,manager,see,get,transaction,manager,test,context,string;protected,platform,transaction,manager,get,transaction,manager,test,context,test,context,string,tm,name,retrieve,configuration,attributes,test,context,get,transaction,manager,name,return,test,context,transaction,utils,retrieve,transaction,manager,test,context,tm,name
TransactionalTestExecutionListener -> protected PlatformTransactionManager getTransactionManager(TestContext testContext);1432125256;Get the {@link PlatformTransactionManager transaction manager} to use_for the supplied {@link TestContext test context}._<p>The default implementation simply delegates to_{@link TestContextTransactionUtils#retrieveTransactionManager}._@param testContext the test context for which the transaction manager_should be retrieved_@return the transaction manager to use, or {@code null} if not found_@throws BeansException if an error occurs while retrieving an explicitly_named transaction manager_@see #getTransactionManager(TestContext, String);protected PlatformTransactionManager getTransactionManager(TestContext testContext) {_		String tmName = retrieveConfigurationAttributes(testContext).getTransactionManagerName()__		return TestContextTransactionUtils.retrieveTransactionManager(testContext, tmName)__	};get,the,link,platform,transaction,manager,transaction,manager,to,use,for,the,supplied,link,test,context,test,context,p,the,default,implementation,simply,delegates,to,link,test,context,transaction,utils,retrieve,transaction,manager,param,test,context,the,test,context,for,which,the,transaction,manager,should,be,retrieved,return,the,transaction,manager,to,use,or,code,null,if,not,found,throws,beans,exception,if,an,error,occurs,while,retrieving,an,explicitly,named,transaction,manager,see,get,transaction,manager,test,context,string;protected,platform,transaction,manager,get,transaction,manager,test,context,test,context,string,tm,name,retrieve,configuration,attributes,test,context,get,transaction,manager,name,return,test,context,transaction,utils,retrieve,transaction,manager,test,context,tm,name
TransactionalTestExecutionListener -> protected PlatformTransactionManager getTransactionManager(TestContext testContext);1432856630;Get the {@link PlatformTransactionManager transaction manager} to use_for the supplied {@link TestContext test context}._<p>The default implementation simply delegates to_{@link TestContextTransactionUtils#retrieveTransactionManager}._@param testContext the test context for which the transaction manager_should be retrieved_@return the transaction manager to use, or {@code null} if not found_@throws BeansException if an error occurs while retrieving an explicitly_named transaction manager_@see #getTransactionManager(TestContext, String);protected PlatformTransactionManager getTransactionManager(TestContext testContext) {_		String tmName = retrieveConfigurationAttributes(testContext).getTransactionManagerName()__		return TestContextTransactionUtils.retrieveTransactionManager(testContext, tmName)__	};get,the,link,platform,transaction,manager,transaction,manager,to,use,for,the,supplied,link,test,context,test,context,p,the,default,implementation,simply,delegates,to,link,test,context,transaction,utils,retrieve,transaction,manager,param,test,context,the,test,context,for,which,the,transaction,manager,should,be,retrieved,return,the,transaction,manager,to,use,or,code,null,if,not,found,throws,beans,exception,if,an,error,occurs,while,retrieving,an,explicitly,named,transaction,manager,see,get,transaction,manager,test,context,string;protected,platform,transaction,manager,get,transaction,manager,test,context,test,context,string,tm,name,retrieve,configuration,attributes,test,context,get,transaction,manager,name,return,test,context,transaction,utils,retrieve,transaction,manager,test,context,tm,name
TransactionalTestExecutionListener -> protected PlatformTransactionManager getTransactionManager(TestContext testContext);1434234880;Get the {@link PlatformTransactionManager transaction manager} to use_for the supplied {@link TestContext test context}._<p>The default implementation simply delegates to_{@link TestContextTransactionUtils#retrieveTransactionManager}._@param testContext the test context for which the transaction manager_should be retrieved_@return the transaction manager to use, or {@code null} if not found_@throws BeansException if an error occurs while retrieving an explicitly_named transaction manager_@see #getTransactionManager(TestContext, String);protected PlatformTransactionManager getTransactionManager(TestContext testContext) {_		String tmName = retrieveConfigurationAttributes(testContext).getTransactionManagerName()__		return TestContextTransactionUtils.retrieveTransactionManager(testContext, tmName)__	};get,the,link,platform,transaction,manager,transaction,manager,to,use,for,the,supplied,link,test,context,test,context,p,the,default,implementation,simply,delegates,to,link,test,context,transaction,utils,retrieve,transaction,manager,param,test,context,the,test,context,for,which,the,transaction,manager,should,be,retrieved,return,the,transaction,manager,to,use,or,code,null,if,not,found,throws,beans,exception,if,an,error,occurs,while,retrieving,an,explicitly,named,transaction,manager,see,get,transaction,manager,test,context,string;protected,platform,transaction,manager,get,transaction,manager,test,context,test,context,string,tm,name,retrieve,configuration,attributes,test,context,get,transaction,manager,name,return,test,context,transaction,utils,retrieve,transaction,manager,test,context,tm,name
TransactionalTestExecutionListener -> protected PlatformTransactionManager getTransactionManager(TestContext testContext);1434720443;Get the {@link PlatformTransactionManager transaction manager} to use_for the supplied {@link TestContext test context}._<p>The default implementation simply delegates to_{@link TestContextTransactionUtils#retrieveTransactionManager}._@param testContext the test context for which the transaction manager_should be retrieved_@return the transaction manager to use, or {@code null} if not found_@throws BeansException if an error occurs while retrieving an explicitly_named transaction manager_@see #getTransactionManager(TestContext, String);protected PlatformTransactionManager getTransactionManager(TestContext testContext) {_		String tmName = retrieveConfigurationAttributes(testContext).getTransactionManagerName()__		return TestContextTransactionUtils.retrieveTransactionManager(testContext, tmName)__	};get,the,link,platform,transaction,manager,transaction,manager,to,use,for,the,supplied,link,test,context,test,context,p,the,default,implementation,simply,delegates,to,link,test,context,transaction,utils,retrieve,transaction,manager,param,test,context,the,test,context,for,which,the,transaction,manager,should,be,retrieved,return,the,transaction,manager,to,use,or,code,null,if,not,found,throws,beans,exception,if,an,error,occurs,while,retrieving,an,explicitly,named,transaction,manager,see,get,transaction,manager,test,context,string;protected,platform,transaction,manager,get,transaction,manager,test,context,test,context,string,tm,name,retrieve,configuration,attributes,test,context,get,transaction,manager,name,return,test,context,transaction,utils,retrieve,transaction,manager,test,context,tm,name
TransactionalTestExecutionListener -> protected PlatformTransactionManager getTransactionManager(TestContext testContext);1434817656;Get the {@link PlatformTransactionManager transaction manager} to use_for the supplied {@link TestContext test context}._<p>The default implementation simply delegates to_{@link TestContextTransactionUtils#retrieveTransactionManager}._@param testContext the test context for which the transaction manager_should be retrieved_@return the transaction manager to use, or {@code null} if not found_@throws BeansException if an error occurs while retrieving an explicitly_named transaction manager_@see #getTransactionManager(TestContext, String);protected PlatformTransactionManager getTransactionManager(TestContext testContext) {_		String tmName = retrieveConfigurationAttributes(testContext).getTransactionManagerName()__		return TestContextTransactionUtils.retrieveTransactionManager(testContext, tmName)__	};get,the,link,platform,transaction,manager,transaction,manager,to,use,for,the,supplied,link,test,context,test,context,p,the,default,implementation,simply,delegates,to,link,test,context,transaction,utils,retrieve,transaction,manager,param,test,context,the,test,context,for,which,the,transaction,manager,should,be,retrieved,return,the,transaction,manager,to,use,or,code,null,if,not,found,throws,beans,exception,if,an,error,occurs,while,retrieving,an,explicitly,named,transaction,manager,see,get,transaction,manager,test,context,string;protected,platform,transaction,manager,get,transaction,manager,test,context,test,context,string,tm,name,retrieve,configuration,attributes,test,context,get,transaction,manager,name,return,test,context,transaction,utils,retrieve,transaction,manager,test,context,tm,name
TransactionalTestExecutionListener -> protected PlatformTransactionManager getTransactionManager(TestContext testContext);1437841346;Get the {@linkplain PlatformTransactionManager transaction manager}_to use for the supplied {@linkplain TestContext test context}._<p>The default implementation simply delegates to_{@link TestContextTransactionUtils#retrieveTransactionManager}._@param testContext the test context for which the transaction manager_should be retrieved_@return the transaction manager to use, or {@code null} if not found_@throws BeansException if an error occurs while retrieving an explicitly_named transaction manager_@throws IllegalStateException if more than one TransactionManagementConfigurer_exists in the ApplicationContext_@see #getTransactionManager(TestContext, String);protected PlatformTransactionManager getTransactionManager(TestContext testContext) {_		String tmName = retrieveConfigurationAttributes(testContext).getTransactionManagerName()__		return TestContextTransactionUtils.retrieveTransactionManager(testContext, tmName)__	};get,the,linkplain,platform,transaction,manager,transaction,manager,to,use,for,the,supplied,linkplain,test,context,test,context,p,the,default,implementation,simply,delegates,to,link,test,context,transaction,utils,retrieve,transaction,manager,param,test,context,the,test,context,for,which,the,transaction,manager,should,be,retrieved,return,the,transaction,manager,to,use,or,code,null,if,not,found,throws,beans,exception,if,an,error,occurs,while,retrieving,an,explicitly,named,transaction,manager,throws,illegal,state,exception,if,more,than,one,transaction,management,configurer,exists,in,the,application,context,see,get,transaction,manager,test,context,string;protected,platform,transaction,manager,get,transaction,manager,test,context,test,context,string,tm,name,retrieve,configuration,attributes,test,context,get,transaction,manager,name,return,test,context,transaction,utils,retrieve,transaction,manager,test,context,tm,name
TransactionalTestExecutionListener -> protected PlatformTransactionManager getTransactionManager(TestContext testContext);1437851372;Get the {@linkplain PlatformTransactionManager transaction manager}_to use for the supplied {@linkplain TestContext test context}._<p>The default implementation simply delegates to_{@link TestContextTransactionUtils#retrieveTransactionManager}._@param testContext the test context for which the transaction manager_should be retrieved_@return the transaction manager to use, or {@code null} if not found_@throws BeansException if an error occurs while retrieving an explicitly_named transaction manager_@throws IllegalStateException if more than one TransactionManagementConfigurer_exists in the ApplicationContext_@see #getTransactionManager(TestContext, String);protected PlatformTransactionManager getTransactionManager(TestContext testContext) {_		String tmName = retrieveConfigurationAttributes(testContext).getTransactionManagerName()__		return TestContextTransactionUtils.retrieveTransactionManager(testContext, tmName)__	};get,the,linkplain,platform,transaction,manager,transaction,manager,to,use,for,the,supplied,linkplain,test,context,test,context,p,the,default,implementation,simply,delegates,to,link,test,context,transaction,utils,retrieve,transaction,manager,param,test,context,the,test,context,for,which,the,transaction,manager,should,be,retrieved,return,the,transaction,manager,to,use,or,code,null,if,not,found,throws,beans,exception,if,an,error,occurs,while,retrieving,an,explicitly,named,transaction,manager,throws,illegal,state,exception,if,more,than,one,transaction,management,configurer,exists,in,the,application,context,see,get,transaction,manager,test,context,string;protected,platform,transaction,manager,get,transaction,manager,test,context,test,context,string,tm,name,retrieve,configuration,attributes,test,context,get,transaction,manager,name,return,test,context,transaction,utils,retrieve,transaction,manager,test,context,tm,name
TransactionalTestExecutionListener -> protected PlatformTransactionManager getTransactionManager(TestContext testContext);1437852597;Get the {@linkplain PlatformTransactionManager transaction manager}_to use for the supplied {@linkplain TestContext test context}._<p>The default implementation simply delegates to_{@link TestContextTransactionUtils#retrieveTransactionManager}._@param testContext the test context for which the transaction manager_should be retrieved_@return the transaction manager to use, or {@code null} if not found_@throws BeansException if an error occurs while retrieving an explicitly_named transaction manager_@throws IllegalStateException if more than one TransactionManagementConfigurer_exists in the ApplicationContext_@see #getTransactionManager(TestContext, String);protected PlatformTransactionManager getTransactionManager(TestContext testContext) {_		@SuppressWarnings("deprecation")_		String tmName = retrieveConfigurationAttributes(testContext).getTransactionManagerName()__		return TestContextTransactionUtils.retrieveTransactionManager(testContext, tmName)__	};get,the,linkplain,platform,transaction,manager,transaction,manager,to,use,for,the,supplied,linkplain,test,context,test,context,p,the,default,implementation,simply,delegates,to,link,test,context,transaction,utils,retrieve,transaction,manager,param,test,context,the,test,context,for,which,the,transaction,manager,should,be,retrieved,return,the,transaction,manager,to,use,or,code,null,if,not,found,throws,beans,exception,if,an,error,occurs,while,retrieving,an,explicitly,named,transaction,manager,throws,illegal,state,exception,if,more,than,one,transaction,management,configurer,exists,in,the,application,context,see,get,transaction,manager,test,context,string;protected,platform,transaction,manager,get,transaction,manager,test,context,test,context,suppress,warnings,deprecation,string,tm,name,retrieve,configuration,attributes,test,context,get,transaction,manager,name,return,test,context,transaction,utils,retrieve,transaction,manager,test,context,tm,name
TransactionalTestExecutionListener -> protected PlatformTransactionManager getTransactionManager(TestContext testContext);1454507787;Get the {@linkplain PlatformTransactionManager transaction manager}_to use for the supplied {@linkplain TestContext test context}._<p>The default implementation simply delegates to_{@link TestContextTransactionUtils#retrieveTransactionManager}._@param testContext the test context for which the transaction manager_should be retrieved_@return the transaction manager to use, or {@code null} if not found_@throws BeansException if an error occurs while retrieving an explicitly_named transaction manager_@throws IllegalStateException if more than one TransactionManagementConfigurer_exists in the ApplicationContext_@see #getTransactionManager(TestContext, String);protected PlatformTransactionManager getTransactionManager(TestContext testContext) {_		@SuppressWarnings("deprecation")_		String tmName = retrieveConfigurationAttributes(testContext).getTransactionManagerName()__		return TestContextTransactionUtils.retrieveTransactionManager(testContext, tmName)__	};get,the,linkplain,platform,transaction,manager,transaction,manager,to,use,for,the,supplied,linkplain,test,context,test,context,p,the,default,implementation,simply,delegates,to,link,test,context,transaction,utils,retrieve,transaction,manager,param,test,context,the,test,context,for,which,the,transaction,manager,should,be,retrieved,return,the,transaction,manager,to,use,or,code,null,if,not,found,throws,beans,exception,if,an,error,occurs,while,retrieving,an,explicitly,named,transaction,manager,throws,illegal,state,exception,if,more,than,one,transaction,management,configurer,exists,in,the,application,context,see,get,transaction,manager,test,context,string;protected,platform,transaction,manager,get,transaction,manager,test,context,test,context,suppress,warnings,deprecation,string,tm,name,retrieve,configuration,attributes,test,context,get,transaction,manager,name,return,test,context,transaction,utils,retrieve,transaction,manager,test,context,tm,name
TransactionalTestExecutionListener -> protected PlatformTransactionManager getTransactionManager(TestContext testContext);1456702967;Get the {@linkplain PlatformTransactionManager transaction manager}_to use for the supplied {@linkplain TestContext test context}._<p>The default implementation simply delegates to_{@link TestContextTransactionUtils#retrieveTransactionManager}._@param testContext the test context for which the transaction manager_should be retrieved_@return the transaction manager to use, or {@code null} if not found_@throws BeansException if an error occurs while retrieving an explicitly_named transaction manager_@throws IllegalStateException if more than one TransactionManagementConfigurer_exists in the ApplicationContext_@see #getTransactionManager(TestContext, String);protected PlatformTransactionManager getTransactionManager(TestContext testContext) {_		@SuppressWarnings("deprecation")_		String tmName = retrieveConfigurationAttributes(testContext).getTransactionManagerName()__		return TestContextTransactionUtils.retrieveTransactionManager(testContext, tmName)__	};get,the,linkplain,platform,transaction,manager,transaction,manager,to,use,for,the,supplied,linkplain,test,context,test,context,p,the,default,implementation,simply,delegates,to,link,test,context,transaction,utils,retrieve,transaction,manager,param,test,context,the,test,context,for,which,the,transaction,manager,should,be,retrieved,return,the,transaction,manager,to,use,or,code,null,if,not,found,throws,beans,exception,if,an,error,occurs,while,retrieving,an,explicitly,named,transaction,manager,throws,illegal,state,exception,if,more,than,one,transaction,management,configurer,exists,in,the,application,context,see,get,transaction,manager,test,context,string;protected,platform,transaction,manager,get,transaction,manager,test,context,test,context,suppress,warnings,deprecation,string,tm,name,retrieve,configuration,attributes,test,context,get,transaction,manager,name,return,test,context,transaction,utils,retrieve,transaction,manager,test,context,tm,name
TransactionalTestExecutionListener -> protected PlatformTransactionManager getTransactionManager(TestContext testContext);1456756222;Get the {@linkplain PlatformTransactionManager transaction manager}_to use for the supplied {@linkplain TestContext test context}._<p>The default implementation simply delegates to_{@link TestContextTransactionUtils#retrieveTransactionManager}._@param testContext the test context for which the transaction manager_should be retrieved_@return the transaction manager to use, or {@code null} if not found_@throws BeansException if an error occurs while retrieving an explicitly_named transaction manager_@throws IllegalStateException if more than one TransactionManagementConfigurer_exists in the ApplicationContext_@see #getTransactionManager(TestContext, String);protected PlatformTransactionManager getTransactionManager(TestContext testContext) {_		@SuppressWarnings("deprecation")_		String tmName = retrieveConfigurationAttributes(testContext).getTransactionManagerName()__		return TestContextTransactionUtils.retrieveTransactionManager(testContext, tmName)__	};get,the,linkplain,platform,transaction,manager,transaction,manager,to,use,for,the,supplied,linkplain,test,context,test,context,p,the,default,implementation,simply,delegates,to,link,test,context,transaction,utils,retrieve,transaction,manager,param,test,context,the,test,context,for,which,the,transaction,manager,should,be,retrieved,return,the,transaction,manager,to,use,or,code,null,if,not,found,throws,beans,exception,if,an,error,occurs,while,retrieving,an,explicitly,named,transaction,manager,throws,illegal,state,exception,if,more,than,one,transaction,management,configurer,exists,in,the,application,context,see,get,transaction,manager,test,context,string;protected,platform,transaction,manager,get,transaction,manager,test,context,test,context,suppress,warnings,deprecation,string,tm,name,retrieve,configuration,attributes,test,context,get,transaction,manager,name,return,test,context,transaction,utils,retrieve,transaction,manager,test,context,tm,name
TransactionalTestExecutionListener -> protected PlatformTransactionManager getTransactionManager(TestContext testContext);1456756222;Get the {@linkplain PlatformTransactionManager transaction manager}_to use for the supplied {@linkplain TestContext test context}._<p>The default implementation simply delegates to_{@link TestContextTransactionUtils#retrieveTransactionManager}._@param testContext the test context for which the transaction manager_should be retrieved_@return the transaction manager to use, or {@code null} if not found_@throws BeansException if an error occurs while retrieving an explicitly_named transaction manager_@throws IllegalStateException if more than one TransactionManagementConfigurer_exists in the ApplicationContext_@see #getTransactionManager(TestContext, String);protected PlatformTransactionManager getTransactionManager(TestContext testContext) {_		@SuppressWarnings("deprecation")_		String tmName = retrieveConfigurationAttributes(testContext).getTransactionManagerName()__		return TestContextTransactionUtils.retrieveTransactionManager(testContext, tmName)__	};get,the,linkplain,platform,transaction,manager,transaction,manager,to,use,for,the,supplied,linkplain,test,context,test,context,p,the,default,implementation,simply,delegates,to,link,test,context,transaction,utils,retrieve,transaction,manager,param,test,context,the,test,context,for,which,the,transaction,manager,should,be,retrieved,return,the,transaction,manager,to,use,or,code,null,if,not,found,throws,beans,exception,if,an,error,occurs,while,retrieving,an,explicitly,named,transaction,manager,throws,illegal,state,exception,if,more,than,one,transaction,management,configurer,exists,in,the,application,context,see,get,transaction,manager,test,context,string;protected,platform,transaction,manager,get,transaction,manager,test,context,test,context,suppress,warnings,deprecation,string,tm,name,retrieve,configuration,attributes,test,context,get,transaction,manager,name,return,test,context,transaction,utils,retrieve,transaction,manager,test,context,tm,name
TransactionalTestExecutionListener -> protected PlatformTransactionManager getTransactionManager(TestContext testContext);1458754760;Get the {@linkplain PlatformTransactionManager transaction manager}_to use for the supplied {@linkplain TestContext test context}._<p>The default implementation simply delegates to_{@link TestContextTransactionUtils#retrieveTransactionManager}._@param testContext the test context for which the transaction manager_should be retrieved_@return the transaction manager to use, or {@code null} if not found_@throws BeansException if an error occurs while retrieving an explicitly_named transaction manager_@throws IllegalStateException if more than one TransactionManagementConfigurer_exists in the ApplicationContext_@see #getTransactionManager(TestContext, String);protected PlatformTransactionManager getTransactionManager(TestContext testContext) {_		@SuppressWarnings("deprecation")_		String tmName = retrieveConfigurationAttributes(testContext).getTransactionManagerName()__		return TestContextTransactionUtils.retrieveTransactionManager(testContext, tmName)__	};get,the,linkplain,platform,transaction,manager,transaction,manager,to,use,for,the,supplied,linkplain,test,context,test,context,p,the,default,implementation,simply,delegates,to,link,test,context,transaction,utils,retrieve,transaction,manager,param,test,context,the,test,context,for,which,the,transaction,manager,should,be,retrieved,return,the,transaction,manager,to,use,or,code,null,if,not,found,throws,beans,exception,if,an,error,occurs,while,retrieving,an,explicitly,named,transaction,manager,throws,illegal,state,exception,if,more,than,one,transaction,management,configurer,exists,in,the,application,context,see,get,transaction,manager,test,context,string;protected,platform,transaction,manager,get,transaction,manager,test,context,test,context,suppress,warnings,deprecation,string,tm,name,retrieve,configuration,attributes,test,context,get,transaction,manager,name,return,test,context,transaction,utils,retrieve,transaction,manager,test,context,tm,name
TransactionalTestExecutionListener -> protected PlatformTransactionManager getTransactionManager(TestContext testContext);1462294651;Get the {@linkplain PlatformTransactionManager transaction manager}_to use for the supplied {@linkplain TestContext test context}._<p>The default implementation simply delegates to_{@link TestContextTransactionUtils#retrieveTransactionManager}._@param testContext the test context for which the transaction manager_should be retrieved_@return the transaction manager to use, or {@code null} if not found_@throws BeansException if an error occurs while retrieving an explicitly_named transaction manager_@throws IllegalStateException if more than one TransactionManagementConfigurer_exists in the ApplicationContext_@see #getTransactionManager(TestContext, String);protected PlatformTransactionManager getTransactionManager(TestContext testContext) {_		@SuppressWarnings("deprecation")_		String tmName = retrieveConfigurationAttributes(testContext).getTransactionManagerName()__		return TestContextTransactionUtils.retrieveTransactionManager(testContext, tmName)__	};get,the,linkplain,platform,transaction,manager,transaction,manager,to,use,for,the,supplied,linkplain,test,context,test,context,p,the,default,implementation,simply,delegates,to,link,test,context,transaction,utils,retrieve,transaction,manager,param,test,context,the,test,context,for,which,the,transaction,manager,should,be,retrieved,return,the,transaction,manager,to,use,or,code,null,if,not,found,throws,beans,exception,if,an,error,occurs,while,retrieving,an,explicitly,named,transaction,manager,throws,illegal,state,exception,if,more,than,one,transaction,management,configurer,exists,in,the,application,context,see,get,transaction,manager,test,context,string;protected,platform,transaction,manager,get,transaction,manager,test,context,test,context,suppress,warnings,deprecation,string,tm,name,retrieve,configuration,attributes,test,context,get,transaction,manager,name,return,test,context,transaction,utils,retrieve,transaction,manager,test,context,tm,name
TransactionalTestExecutionListener -> protected PlatformTransactionManager getTransactionManager(TestContext testContext);1462299971;Get the {@linkplain PlatformTransactionManager transaction manager}_to use for the supplied {@linkplain TestContext test context}._<p>The default implementation simply delegates to_{@link TestContextTransactionUtils#retrieveTransactionManager}._@param testContext the test context for which the transaction manager_should be retrieved_@return the transaction manager to use, or {@code null} if not found_@throws BeansException if an error occurs while retrieving an explicitly_named transaction manager_@throws IllegalStateException if more than one TransactionManagementConfigurer_exists in the ApplicationContext_@see #getTransactionManager(TestContext, String);protected PlatformTransactionManager getTransactionManager(TestContext testContext) {_		@SuppressWarnings("deprecation")_		String tmName = retrieveConfigurationAttributes(testContext).getTransactionManagerName()__		return TestContextTransactionUtils.retrieveTransactionManager(testContext, tmName)__	};get,the,linkplain,platform,transaction,manager,transaction,manager,to,use,for,the,supplied,linkplain,test,context,test,context,p,the,default,implementation,simply,delegates,to,link,test,context,transaction,utils,retrieve,transaction,manager,param,test,context,the,test,context,for,which,the,transaction,manager,should,be,retrieved,return,the,transaction,manager,to,use,or,code,null,if,not,found,throws,beans,exception,if,an,error,occurs,while,retrieving,an,explicitly,named,transaction,manager,throws,illegal,state,exception,if,more,than,one,transaction,management,configurer,exists,in,the,application,context,see,get,transaction,manager,test,context,string;protected,platform,transaction,manager,get,transaction,manager,test,context,test,context,suppress,warnings,deprecation,string,tm,name,retrieve,configuration,attributes,test,context,get,transaction,manager,name,return,test,context,transaction,utils,retrieve,transaction,manager,test,context,tm,name
TransactionalTestExecutionListener -> protected PlatformTransactionManager getTransactionManager(TestContext testContext);1467730834;Get the {@linkplain PlatformTransactionManager transaction manager}_to use for the supplied {@linkplain TestContext test context}._<p>The default implementation simply delegates to_{@link TestContextTransactionUtils#retrieveTransactionManager}._@param testContext the test context for which the transaction manager_should be retrieved_@return the transaction manager to use, or {@code null} if not found_@throws BeansException if an error occurs while retrieving an explicitly_named transaction manager_@throws IllegalStateException if more than one TransactionManagementConfigurer_exists in the ApplicationContext_@see #getTransactionManager(TestContext, String);protected PlatformTransactionManager getTransactionManager(TestContext testContext) {_		@SuppressWarnings("deprecation")_		String tmName = retrieveConfigurationAttributes(testContext).getTransactionManagerName()__		return TestContextTransactionUtils.retrieveTransactionManager(testContext, tmName)__	};get,the,linkplain,platform,transaction,manager,transaction,manager,to,use,for,the,supplied,linkplain,test,context,test,context,p,the,default,implementation,simply,delegates,to,link,test,context,transaction,utils,retrieve,transaction,manager,param,test,context,the,test,context,for,which,the,transaction,manager,should,be,retrieved,return,the,transaction,manager,to,use,or,code,null,if,not,found,throws,beans,exception,if,an,error,occurs,while,retrieving,an,explicitly,named,transaction,manager,throws,illegal,state,exception,if,more,than,one,transaction,management,configurer,exists,in,the,application,context,see,get,transaction,manager,test,context,string;protected,platform,transaction,manager,get,transaction,manager,test,context,test,context,suppress,warnings,deprecation,string,tm,name,retrieve,configuration,attributes,test,context,get,transaction,manager,name,return,test,context,transaction,utils,retrieve,transaction,manager,test,context,tm,name
TransactionalTestExecutionListener -> protected PlatformTransactionManager getTransactionManager(TestContext testContext);1467992320;Get the {@linkplain PlatformTransactionManager transaction manager}_to use for the supplied {@linkplain TestContext test context}._<p>The default implementation simply delegates to_{@link TestContextTransactionUtils#retrieveTransactionManager}._@param testContext the test context for which the transaction manager_should be retrieved_@return the transaction manager to use, or {@code null} if not found_@throws BeansException if an error occurs while retrieving an explicitly_named transaction manager_@throws IllegalStateException if more than one TransactionManagementConfigurer_exists in the ApplicationContext_@see #getTransactionManager(TestContext, String);protected PlatformTransactionManager getTransactionManager(TestContext testContext) {_		@SuppressWarnings("deprecation")_		String tmName = retrieveConfigurationAttributes(testContext).getTransactionManagerName()__		return TestContextTransactionUtils.retrieveTransactionManager(testContext, tmName)__	};get,the,linkplain,platform,transaction,manager,transaction,manager,to,use,for,the,supplied,linkplain,test,context,test,context,p,the,default,implementation,simply,delegates,to,link,test,context,transaction,utils,retrieve,transaction,manager,param,test,context,the,test,context,for,which,the,transaction,manager,should,be,retrieved,return,the,transaction,manager,to,use,or,code,null,if,not,found,throws,beans,exception,if,an,error,occurs,while,retrieving,an,explicitly,named,transaction,manager,throws,illegal,state,exception,if,more,than,one,transaction,management,configurer,exists,in,the,application,context,see,get,transaction,manager,test,context,string;protected,platform,transaction,manager,get,transaction,manager,test,context,test,context,suppress,warnings,deprecation,string,tm,name,retrieve,configuration,attributes,test,context,get,transaction,manager,name,return,test,context,transaction,utils,retrieve,transaction,manager,test,context,tm,name
TransactionalTestExecutionListener -> protected PlatformTransactionManager getTransactionManager(TestContext testContext);1467992442;Get the {@linkplain PlatformTransactionManager transaction manager}_to use for the supplied {@linkplain TestContext test context}._<p>The default implementation simply delegates to_{@link TestContextTransactionUtils#retrieveTransactionManager}._@param testContext the test context for which the transaction manager_should be retrieved_@return the transaction manager to use, or {@code null} if not found_@throws BeansException if an error occurs while retrieving an explicitly_named transaction manager_@throws IllegalStateException if more than one TransactionManagementConfigurer_exists in the ApplicationContext_@see #getTransactionManager(TestContext, String);protected PlatformTransactionManager getTransactionManager(TestContext testContext) {_		@SuppressWarnings("deprecation")_		String tmName = retrieveConfigurationAttributes(testContext).getTransactionManagerName()__		return TestContextTransactionUtils.retrieveTransactionManager(testContext, tmName)__	};get,the,linkplain,platform,transaction,manager,transaction,manager,to,use,for,the,supplied,linkplain,test,context,test,context,p,the,default,implementation,simply,delegates,to,link,test,context,transaction,utils,retrieve,transaction,manager,param,test,context,the,test,context,for,which,the,transaction,manager,should,be,retrieved,return,the,transaction,manager,to,use,or,code,null,if,not,found,throws,beans,exception,if,an,error,occurs,while,retrieving,an,explicitly,named,transaction,manager,throws,illegal,state,exception,if,more,than,one,transaction,management,configurer,exists,in,the,application,context,see,get,transaction,manager,test,context,string;protected,platform,transaction,manager,get,transaction,manager,test,context,test,context,suppress,warnings,deprecation,string,tm,name,retrieve,configuration,attributes,test,context,get,transaction,manager,name,return,test,context,transaction,utils,retrieve,transaction,manager,test,context,tm,name
TransactionalTestExecutionListener -> protected PlatformTransactionManager getTransactionManager(TestContext testContext);1467994604;Get the {@linkplain PlatformTransactionManager transaction manager}_to use for the supplied {@linkplain TestContext test context}._<p>The default implementation simply delegates to_{@link TestContextTransactionUtils#retrieveTransactionManager}._@param testContext the test context for which the transaction manager_should be retrieved_@return the transaction manager to use, or {@code null} if not found_@throws BeansException if an error occurs while retrieving an explicitly_named transaction manager_@throws IllegalStateException if more than one TransactionManagementConfigurer_exists in the ApplicationContext_@see #getTransactionManager(TestContext, String);protected PlatformTransactionManager getTransactionManager(TestContext testContext) {_		return TestContextTransactionUtils.retrieveTransactionManager(testContext, null)__	};get,the,linkplain,platform,transaction,manager,transaction,manager,to,use,for,the,supplied,linkplain,test,context,test,context,p,the,default,implementation,simply,delegates,to,link,test,context,transaction,utils,retrieve,transaction,manager,param,test,context,the,test,context,for,which,the,transaction,manager,should,be,retrieved,return,the,transaction,manager,to,use,or,code,null,if,not,found,throws,beans,exception,if,an,error,occurs,while,retrieving,an,explicitly,named,transaction,manager,throws,illegal,state,exception,if,more,than,one,transaction,management,configurer,exists,in,the,application,context,see,get,transaction,manager,test,context,string;protected,platform,transaction,manager,get,transaction,manager,test,context,test,context,return,test,context,transaction,utils,retrieve,transaction,manager,test,context,null
TransactionalTestExecutionListener -> protected PlatformTransactionManager getTransactionManager(TestContext testContext);1468334463;Get the {@linkplain PlatformTransactionManager transaction manager}_to use for the supplied {@linkplain TestContext test context}._<p>The default implementation simply delegates to_{@link TestContextTransactionUtils#retrieveTransactionManager}._@param testContext the test context for which the transaction manager_should be retrieved_@return the transaction manager to use, or {@code null} if not found_@throws BeansException if an error occurs while retrieving an explicitly_named transaction manager_@throws IllegalStateException if more than one TransactionManagementConfigurer_exists in the ApplicationContext_@see #getTransactionManager(TestContext, String);protected PlatformTransactionManager getTransactionManager(TestContext testContext) {_		return TestContextTransactionUtils.retrieveTransactionManager(testContext, null)__	};get,the,linkplain,platform,transaction,manager,transaction,manager,to,use,for,the,supplied,linkplain,test,context,test,context,p,the,default,implementation,simply,delegates,to,link,test,context,transaction,utils,retrieve,transaction,manager,param,test,context,the,test,context,for,which,the,transaction,manager,should,be,retrieved,return,the,transaction,manager,to,use,or,code,null,if,not,found,throws,beans,exception,if,an,error,occurs,while,retrieving,an,explicitly,named,transaction,manager,throws,illegal,state,exception,if,more,than,one,transaction,management,configurer,exists,in,the,application,context,see,get,transaction,manager,test,context,string;protected,platform,transaction,manager,get,transaction,manager,test,context,test,context,return,test,context,transaction,utils,retrieve,transaction,manager,test,context,null
TransactionalTestExecutionListener -> private List<Method> getAnnotatedMethods(Class<?> clazz, Class<? extends Annotation> annotationType);1328020251;Gets all methods in the supplied {@link Class class} and its superclasses_which are annotated with the supplied <code>annotationType</code> but_which are not <em>shadowed</em> by methods overridden in subclasses._<p>Note: This code has been borrowed from_{@link org.junit.internal.runners.TestClass#getAnnotatedMethods(Class)}_and adapted._@param clazz the class for which to retrieve the annotated methods_@param annotationType the annotation type for which to search_@return all annotated methods in the supplied class and its superclasses;private List<Method> getAnnotatedMethods(Class<?> clazz, Class<? extends Annotation> annotationType) {_		List<Method> results = new ArrayList<Method>()__		for (Class<?> eachClass : getSuperClasses(clazz)) {_			Method[] methods = eachClass.getDeclaredMethods()__			for (Method eachMethod : methods) {_				Annotation annotation = eachMethod.getAnnotation(annotationType)__				if (annotation != null && !isShadowed(eachMethod, results)) {_					results.add(eachMethod)__				}_			}_		}_		return results__	};gets,all,methods,in,the,supplied,link,class,class,and,its,superclasses,which,are,annotated,with,the,supplied,code,annotation,type,code,but,which,are,not,em,shadowed,em,by,methods,overridden,in,subclasses,p,note,this,code,has,been,borrowed,from,link,org,junit,internal,runners,test,class,get,annotated,methods,class,and,adapted,param,clazz,the,class,for,which,to,retrieve,the,annotated,methods,param,annotation,type,the,annotation,type,for,which,to,search,return,all,annotated,methods,in,the,supplied,class,and,its,superclasses;private,list,method,get,annotated,methods,class,clazz,class,extends,annotation,annotation,type,list,method,results,new,array,list,method,for,class,each,class,get,super,classes,clazz,method,methods,each,class,get,declared,methods,for,method,each,method,methods,annotation,annotation,each,method,get,annotation,annotation,type,if,annotation,null,is,shadowed,each,method,results,results,add,each,method,return,results
TransactionalTestExecutionListener -> private List<Method> getAnnotatedMethods(Class<?> clazz, Class<? extends Annotation> annotationType);1337516454;Gets all methods in the supplied {@link Class class} and its superclasses_which are annotated with the supplied <code>annotationType</code> but_which are not <em>shadowed</em> by methods overridden in subclasses._<p>Note: This code has been borrowed from_{@link org.junit.internal.runners.TestClass#getAnnotatedMethods(Class)}_and adapted._@param clazz the class for which to retrieve the annotated methods_@param annotationType the annotation type for which to search_@return all annotated methods in the supplied class and its superclasses;private List<Method> getAnnotatedMethods(Class<?> clazz, Class<? extends Annotation> annotationType) {_		List<Method> results = new ArrayList<Method>()__		for (Class<?> eachClass : getSuperClasses(clazz)) {_			Method[] methods = eachClass.getDeclaredMethods()__			for (Method eachMethod : methods) {_				Annotation annotation = eachMethod.getAnnotation(annotationType)__				if (annotation != null && !isShadowed(eachMethod, results)) {_					results.add(eachMethod)__				}_			}_		}_		return results__	};gets,all,methods,in,the,supplied,link,class,class,and,its,superclasses,which,are,annotated,with,the,supplied,code,annotation,type,code,but,which,are,not,em,shadowed,em,by,methods,overridden,in,subclasses,p,note,this,code,has,been,borrowed,from,link,org,junit,internal,runners,test,class,get,annotated,methods,class,and,adapted,param,clazz,the,class,for,which,to,retrieve,the,annotated,methods,param,annotation,type,the,annotation,type,for,which,to,search,return,all,annotated,methods,in,the,supplied,class,and,its,superclasses;private,list,method,get,annotated,methods,class,clazz,class,extends,annotation,annotation,type,list,method,results,new,array,list,method,for,class,each,class,get,super,classes,clazz,method,methods,each,class,get,declared,methods,for,method,each,method,methods,annotation,annotation,each,method,get,annotation,annotation,type,if,annotation,null,is,shadowed,each,method,results,results,add,each,method,return,results
TransactionalTestExecutionListener -> private List<Method> getAnnotatedMethods(Class<?> clazz, Class<? extends Annotation> annotationType);1338031377;Gets all methods in the supplied {@link Class class} and its superclasses_which are annotated with the supplied <code>annotationType</code> but_which are not <em>shadowed</em> by methods overridden in subclasses._<p>Note: This code has been borrowed from_{@link org.junit.internal.runners.TestClass#getAnnotatedMethods(Class)}_and adapted._@param clazz the class for which to retrieve the annotated methods_@param annotationType the annotation type for which to search_@return all annotated methods in the supplied class and its superclasses;private List<Method> getAnnotatedMethods(Class<?> clazz, Class<? extends Annotation> annotationType) {_		List<Method> results = new ArrayList<Method>()__		for (Class<?> eachClass : getSuperClasses(clazz)) {_			Method[] methods = eachClass.getDeclaredMethods()__			for (Method eachMethod : methods) {_				Annotation annotation = eachMethod.getAnnotation(annotationType)__				if (annotation != null && !isShadowed(eachMethod, results)) {_					results.add(eachMethod)__				}_			}_		}_		return results__	};gets,all,methods,in,the,supplied,link,class,class,and,its,superclasses,which,are,annotated,with,the,supplied,code,annotation,type,code,but,which,are,not,em,shadowed,em,by,methods,overridden,in,subclasses,p,note,this,code,has,been,borrowed,from,link,org,junit,internal,runners,test,class,get,annotated,methods,class,and,adapted,param,clazz,the,class,for,which,to,retrieve,the,annotated,methods,param,annotation,type,the,annotation,type,for,which,to,search,return,all,annotated,methods,in,the,supplied,class,and,its,superclasses;private,list,method,get,annotated,methods,class,clazz,class,extends,annotation,annotation,type,list,method,results,new,array,list,method,for,class,each,class,get,super,classes,clazz,method,methods,each,class,get,declared,methods,for,method,each,method,methods,annotation,annotation,each,method,get,annotation,annotation,type,if,annotation,null,is,shadowed,each,method,results,results,add,each,method,return,results
TransactionalTestExecutionListener -> private List<Method> getAnnotatedMethods(Class<?> clazz, Class<? extends Annotation> annotationType);1343426806;Gets all methods in the supplied {@link Class class} and its superclasses_which are annotated with the supplied <code>annotationType</code> but_which are not <em>shadowed</em> by methods overridden in subclasses._<p>Note: This code has been borrowed from_{@link org.junit.internal.runners.TestClass#getAnnotatedMethods(Class)}_and adapted._@param clazz the class for which to retrieve the annotated methods_@param annotationType the annotation type for which to search_@return all annotated methods in the supplied class and its superclasses;private List<Method> getAnnotatedMethods(Class<?> clazz, Class<? extends Annotation> annotationType) {_		List<Method> results = new ArrayList<Method>()__		for (Class<?> eachClass : getSuperClasses(clazz)) {_			Method[] methods = eachClass.getDeclaredMethods()__			for (Method eachMethod : methods) {_				Annotation annotation = eachMethod.getAnnotation(annotationType)__				if (annotation != null && !isShadowed(eachMethod, results)) {_					results.add(eachMethod)__				}_			}_		}_		return results__	};gets,all,methods,in,the,supplied,link,class,class,and,its,superclasses,which,are,annotated,with,the,supplied,code,annotation,type,code,but,which,are,not,em,shadowed,em,by,methods,overridden,in,subclasses,p,note,this,code,has,been,borrowed,from,link,org,junit,internal,runners,test,class,get,annotated,methods,class,and,adapted,param,clazz,the,class,for,which,to,retrieve,the,annotated,methods,param,annotation,type,the,annotation,type,for,which,to,search,return,all,annotated,methods,in,the,supplied,class,and,its,superclasses;private,list,method,get,annotated,methods,class,clazz,class,extends,annotation,annotation,type,list,method,results,new,array,list,method,for,class,each,class,get,super,classes,clazz,method,methods,each,class,get,declared,methods,for,method,each,method,methods,annotation,annotation,each,method,get,annotation,annotation,type,if,annotation,null,is,shadowed,each,method,results,results,add,each,method,return,results
TransactionalTestExecutionListener -> private List<Method> getAnnotatedMethods(Class<?> clazz, Class<? extends Annotation> annotationType);1343431472;Gets all methods in the supplied {@link Class class} and its superclasses_which are annotated with the supplied <code>annotationType</code> but_which are not <em>shadowed</em> by methods overridden in subclasses._<p>Note: This code has been borrowed from_{@link org.junit.internal.runners.TestClass#getAnnotatedMethods(Class)}_and adapted._@param clazz the class for which to retrieve the annotated methods_@param annotationType the annotation type for which to search_@return all annotated methods in the supplied class and its superclasses;private List<Method> getAnnotatedMethods(Class<?> clazz, Class<? extends Annotation> annotationType) {_		List<Method> results = new ArrayList<Method>()__		for (Class<?> eachClass : getSuperClasses(clazz)) {_			Method[] methods = eachClass.getDeclaredMethods()__			for (Method eachMethod : methods) {_				Annotation annotation = eachMethod.getAnnotation(annotationType)__				if (annotation != null && !isShadowed(eachMethod, results)) {_					results.add(eachMethod)__				}_			}_		}_		return results__	};gets,all,methods,in,the,supplied,link,class,class,and,its,superclasses,which,are,annotated,with,the,supplied,code,annotation,type,code,but,which,are,not,em,shadowed,em,by,methods,overridden,in,subclasses,p,note,this,code,has,been,borrowed,from,link,org,junit,internal,runners,test,class,get,annotated,methods,class,and,adapted,param,clazz,the,class,for,which,to,retrieve,the,annotated,methods,param,annotation,type,the,annotation,type,for,which,to,search,return,all,annotated,methods,in,the,supplied,class,and,its,superclasses;private,list,method,get,annotated,methods,class,clazz,class,extends,annotation,annotation,type,list,method,results,new,array,list,method,for,class,each,class,get,super,classes,clazz,method,methods,each,class,get,declared,methods,for,method,each,method,methods,annotation,annotation,each,method,get,annotation,annotation,type,if,annotation,null,is,shadowed,each,method,results,results,add,each,method,return,results
TransactionalTestExecutionListener -> private List<Method> getAnnotatedMethods(Class<?> clazz, Class<? extends Annotation> annotationType);1354571539;Gets all methods in the supplied {@link Class class} and its superclasses_which are annotated with the supplied <code>annotationType</code> but_which are not <em>shadowed</em> by methods overridden in subclasses._<p>Note: This code has been borrowed from_{@link org.junit.internal.runners.TestClass#getAnnotatedMethods(Class)}_and adapted._@param clazz the class for which to retrieve the annotated methods_@param annotationType the annotation type for which to search_@return all annotated methods in the supplied class and its superclasses;private List<Method> getAnnotatedMethods(Class<?> clazz, Class<? extends Annotation> annotationType) {_		List<Method> results = new ArrayList<Method>()__		for (Class<?> eachClass : getSuperClasses(clazz)) {_			Method[] methods = eachClass.getDeclaredMethods()__			for (Method eachMethod : methods) {_				Annotation annotation = eachMethod.getAnnotation(annotationType)__				if (annotation != null && !isShadowed(eachMethod, results)) {_					results.add(eachMethod)__				}_			}_		}_		return results__	};gets,all,methods,in,the,supplied,link,class,class,and,its,superclasses,which,are,annotated,with,the,supplied,code,annotation,type,code,but,which,are,not,em,shadowed,em,by,methods,overridden,in,subclasses,p,note,this,code,has,been,borrowed,from,link,org,junit,internal,runners,test,class,get,annotated,methods,class,and,adapted,param,clazz,the,class,for,which,to,retrieve,the,annotated,methods,param,annotation,type,the,annotation,type,for,which,to,search,return,all,annotated,methods,in,the,supplied,class,and,its,superclasses;private,list,method,get,annotated,methods,class,clazz,class,extends,annotation,annotation,type,list,method,results,new,array,list,method,for,class,each,class,get,super,classes,clazz,method,methods,each,class,get,declared,methods,for,method,each,method,methods,annotation,annotation,each,method,get,annotation,annotation,type,if,annotation,null,is,shadowed,each,method,results,results,add,each,method,return,results
TransactionalTestExecutionListener -> private List<Method> getAnnotatedMethods(Class<?> clazz, Class<? extends Annotation> annotationType);1355352386;Gets all methods in the supplied {@link Class class} and its superclasses_which are annotated with the supplied <code>annotationType</code> but_which are not <em>shadowed</em> by methods overridden in subclasses._<p>Note: This code has been borrowed from_{@link org.junit.internal.runners.TestClass#getAnnotatedMethods(Class)}_and adapted._@param clazz the class for which to retrieve the annotated methods_@param annotationType the annotation type for which to search_@return all annotated methods in the supplied class and its superclasses;private List<Method> getAnnotatedMethods(Class<?> clazz, Class<? extends Annotation> annotationType) {_		List<Method> results = new ArrayList<Method>()__		for (Class<?> eachClass : getSuperClasses(clazz)) {_			Method[] methods = eachClass.getDeclaredMethods()__			for (Method eachMethod : methods) {_				Annotation annotation = eachMethod.getAnnotation(annotationType)__				if (annotation != null && !isShadowed(eachMethod, results)) {_					results.add(eachMethod)__				}_			}_		}_		return results__	};gets,all,methods,in,the,supplied,link,class,class,and,its,superclasses,which,are,annotated,with,the,supplied,code,annotation,type,code,but,which,are,not,em,shadowed,em,by,methods,overridden,in,subclasses,p,note,this,code,has,been,borrowed,from,link,org,junit,internal,runners,test,class,get,annotated,methods,class,and,adapted,param,clazz,the,class,for,which,to,retrieve,the,annotated,methods,param,annotation,type,the,annotation,type,for,which,to,search,return,all,annotated,methods,in,the,supplied,class,and,its,superclasses;private,list,method,get,annotated,methods,class,clazz,class,extends,annotation,annotation,type,list,method,results,new,array,list,method,for,class,each,class,get,super,classes,clazz,method,methods,each,class,get,declared,methods,for,method,each,method,methods,annotation,annotation,each,method,get,annotation,annotation,type,if,annotation,null,is,shadowed,each,method,results,results,add,each,method,return,results
TransactionalTestExecutionListener -> private List<Method> getAnnotatedMethods(Class<?> clazz, Class<? extends Annotation> annotationType);1356735495;Gets all methods in the supplied {@link Class class} and its superclasses_which are annotated with the supplied {@code annotationType} but_which are not <em>shadowed</em> by methods overridden in subclasses._<p>Note: This code has been borrowed from_{@link org.junit.internal.runners.TestClass#getAnnotatedMethods(Class)}_and adapted._@param clazz the class for which to retrieve the annotated methods_@param annotationType the annotation type for which to search_@return all annotated methods in the supplied class and its superclasses;private List<Method> getAnnotatedMethods(Class<?> clazz, Class<? extends Annotation> annotationType) {_		List<Method> results = new ArrayList<Method>()__		for (Class<?> eachClass : getSuperClasses(clazz)) {_			Method[] methods = eachClass.getDeclaredMethods()__			for (Method eachMethod : methods) {_				Annotation annotation = eachMethod.getAnnotation(annotationType)__				if (annotation != null && !isShadowed(eachMethod, results)) {_					results.add(eachMethod)__				}_			}_		}_		return results__	};gets,all,methods,in,the,supplied,link,class,class,and,its,superclasses,which,are,annotated,with,the,supplied,code,annotation,type,but,which,are,not,em,shadowed,em,by,methods,overridden,in,subclasses,p,note,this,code,has,been,borrowed,from,link,org,junit,internal,runners,test,class,get,annotated,methods,class,and,adapted,param,clazz,the,class,for,which,to,retrieve,the,annotated,methods,param,annotation,type,the,annotation,type,for,which,to,search,return,all,annotated,methods,in,the,supplied,class,and,its,superclasses;private,list,method,get,annotated,methods,class,clazz,class,extends,annotation,annotation,type,list,method,results,new,array,list,method,for,class,each,class,get,super,classes,clazz,method,methods,each,class,get,declared,methods,for,method,each,method,methods,annotation,annotation,each,method,get,annotation,annotation,type,if,annotation,null,is,shadowed,each,method,results,results,add,each,method,return,results
TransactionalTestExecutionListener -> private List<Method> getAnnotatedMethods(Class<?> clazz, Class<? extends Annotation> annotationType);1357119239;Gets all methods in the supplied {@link Class class} and its superclasses_which are annotated with the supplied {@code annotationType} but_which are not <em>shadowed</em> by methods overridden in subclasses._<p>Note: This code has been borrowed from_{@link org.junit.internal.runners.TestClass#getAnnotatedMethods(Class)}_and adapted._@param clazz the class for which to retrieve the annotated methods_@param annotationType the annotation type for which to search_@return all annotated methods in the supplied class and its superclasses;private List<Method> getAnnotatedMethods(Class<?> clazz, Class<? extends Annotation> annotationType) {_		List<Method> results = new ArrayList<Method>()__		for (Class<?> eachClass : getSuperClasses(clazz)) {_			Method[] methods = eachClass.getDeclaredMethods()__			for (Method eachMethod : methods) {_				Annotation annotation = eachMethod.getAnnotation(annotationType)__				if (annotation != null && !isShadowed(eachMethod, results)) {_					results.add(eachMethod)__				}_			}_		}_		return results__	};gets,all,methods,in,the,supplied,link,class,class,and,its,superclasses,which,are,annotated,with,the,supplied,code,annotation,type,but,which,are,not,em,shadowed,em,by,methods,overridden,in,subclasses,p,note,this,code,has,been,borrowed,from,link,org,junit,internal,runners,test,class,get,annotated,methods,class,and,adapted,param,clazz,the,class,for,which,to,retrieve,the,annotated,methods,param,annotation,type,the,annotation,type,for,which,to,search,return,all,annotated,methods,in,the,supplied,class,and,its,superclasses;private,list,method,get,annotated,methods,class,clazz,class,extends,annotation,annotation,type,list,method,results,new,array,list,method,for,class,each,class,get,super,classes,clazz,method,methods,each,class,get,declared,methods,for,method,each,method,methods,annotation,annotation,each,method,get,annotation,annotation,type,if,annotation,null,is,shadowed,each,method,results,results,add,each,method,return,results
TransactionalTestExecutionListener -> private List<Method> getAnnotatedMethods(Class<?> clazz, Class<? extends Annotation> annotationType);1367163114;Gets all methods in the supplied {@link Class class} and its superclasses_which are annotated with the supplied {@code annotationType} but_which are not <em>shadowed</em> by methods overridden in subclasses._<p>Note: This code has been borrowed from_{@link org.junit.internal.runners.TestClass#getAnnotatedMethods(Class)}_and adapted._@param clazz the class for which to retrieve the annotated methods_@param annotationType the annotation type for which to search_@return all annotated methods in the supplied class and its superclasses;private List<Method> getAnnotatedMethods(Class<?> clazz, Class<? extends Annotation> annotationType) {_		List<Method> results = new ArrayList<Method>()__		for (Class<?> eachClass : getSuperClasses(clazz)) {_			Method[] methods = eachClass.getDeclaredMethods()__			for (Method eachMethod : methods) {_				Annotation annotation = eachMethod.getAnnotation(annotationType)__				if (annotation != null && !isShadowed(eachMethod, results)) {_					results.add(eachMethod)__				}_			}_		}_		return results__	};gets,all,methods,in,the,supplied,link,class,class,and,its,superclasses,which,are,annotated,with,the,supplied,code,annotation,type,but,which,are,not,em,shadowed,em,by,methods,overridden,in,subclasses,p,note,this,code,has,been,borrowed,from,link,org,junit,internal,runners,test,class,get,annotated,methods,class,and,adapted,param,clazz,the,class,for,which,to,retrieve,the,annotated,methods,param,annotation,type,the,annotation,type,for,which,to,search,return,all,annotated,methods,in,the,supplied,class,and,its,superclasses;private,list,method,get,annotated,methods,class,clazz,class,extends,annotation,annotation,type,list,method,results,new,array,list,method,for,class,each,class,get,super,classes,clazz,method,methods,each,class,get,declared,methods,for,method,each,method,methods,annotation,annotation,each,method,get,annotation,annotation,type,if,annotation,null,is,shadowed,each,method,results,results,add,each,method,return,results
TransactionalTestExecutionListener -> private List<Method> getAnnotatedMethods(Class<?> clazz, Class<? extends Annotation> annotationType);1367873075;Gets all methods in the supplied {@link Class class} and its superclasses_which are annotated with the supplied {@code annotationType} but_which are not <em>shadowed</em> by methods overridden in subclasses._<p>Note: This code has been borrowed from_{@link org.junit.internal.runners.TestClass#getAnnotatedMethods(Class)}_and adapted._@param clazz the class for which to retrieve the annotated methods_@param annotationType the annotation type for which to search_@return all annotated methods in the supplied class and its superclasses;private List<Method> getAnnotatedMethods(Class<?> clazz, Class<? extends Annotation> annotationType) {_		List<Method> results = new ArrayList<Method>()__		for (Class<?> eachClass : getSuperClasses(clazz)) {_			Method[] methods = eachClass.getDeclaredMethods()__			for (Method eachMethod : methods) {_				Annotation annotation = eachMethod.getAnnotation(annotationType)__				if (annotation != null && !isShadowed(eachMethod, results)) {_					results.add(eachMethod)__				}_			}_		}_		return results__	};gets,all,methods,in,the,supplied,link,class,class,and,its,superclasses,which,are,annotated,with,the,supplied,code,annotation,type,but,which,are,not,em,shadowed,em,by,methods,overridden,in,subclasses,p,note,this,code,has,been,borrowed,from,link,org,junit,internal,runners,test,class,get,annotated,methods,class,and,adapted,param,clazz,the,class,for,which,to,retrieve,the,annotated,methods,param,annotation,type,the,annotation,type,for,which,to,search,return,all,annotated,methods,in,the,supplied,class,and,its,superclasses;private,list,method,get,annotated,methods,class,clazz,class,extends,annotation,annotation,type,list,method,results,new,array,list,method,for,class,each,class,get,super,classes,clazz,method,methods,each,class,get,declared,methods,for,method,each,method,methods,annotation,annotation,each,method,get,annotation,annotation,type,if,annotation,null,is,shadowed,each,method,results,results,add,each,method,return,results
TransactionalTestExecutionListener -> private List<Method> getAnnotatedMethods(Class<?> clazz, Class<? extends Annotation> annotationType);1368482696;Gets all methods in the supplied {@link Class class} and its superclasses_which are annotated with the supplied {@code annotationType} but_which are not <em>shadowed</em> by methods overridden in subclasses._<p>Note: This code has been borrowed from_{@link org.junit.internal.runners.TestClass#getAnnotatedMethods(Class)}_and adapted._@param clazz the class for which to retrieve the annotated methods_@param annotationType the annotation type for which to search_@return all annotated methods in the supplied class and its superclasses;private List<Method> getAnnotatedMethods(Class<?> clazz, Class<? extends Annotation> annotationType) {_		List<Method> results = new ArrayList<Method>()__		for (Class<?> eachClass : getSuperClasses(clazz)) {_			Method[] methods = eachClass.getDeclaredMethods()__			for (Method eachMethod : methods) {_				Annotation annotation = eachMethod.getAnnotation(annotationType)__				if (annotation != null && !isShadowed(eachMethod, results)) {_					results.add(eachMethod)__				}_			}_		}_		return results__	};gets,all,methods,in,the,supplied,link,class,class,and,its,superclasses,which,are,annotated,with,the,supplied,code,annotation,type,but,which,are,not,em,shadowed,em,by,methods,overridden,in,subclasses,p,note,this,code,has,been,borrowed,from,link,org,junit,internal,runners,test,class,get,annotated,methods,class,and,adapted,param,clazz,the,class,for,which,to,retrieve,the,annotated,methods,param,annotation,type,the,annotation,type,for,which,to,search,return,all,annotated,methods,in,the,supplied,class,and,its,superclasses;private,list,method,get,annotated,methods,class,clazz,class,extends,annotation,annotation,type,list,method,results,new,array,list,method,for,class,each,class,get,super,classes,clazz,method,methods,each,class,get,declared,methods,for,method,each,method,methods,annotation,annotation,each,method,get,annotation,annotation,type,if,annotation,null,is,shadowed,each,method,results,results,add,each,method,return,results
TransactionalTestExecutionListener -> private List<Method> getAnnotatedMethods(Class<?> clazz, Class<? extends Annotation> annotationType);1382920864;Gets all methods in the supplied {@link Class class} and its superclasses_which are annotated with the supplied {@code annotationType} but_which are not <em>shadowed</em> by methods overridden in subclasses._<p>Note: This code has been borrowed from_{@link org.junit.internal.runners.TestClass#getAnnotatedMethods(Class)}_and adapted._@param clazz the class for which to retrieve the annotated methods_@param annotationType the annotation type for which to search_@return all annotated methods in the supplied class and its superclasses;private List<Method> getAnnotatedMethods(Class<?> clazz, Class<? extends Annotation> annotationType) {_		List<Method> results = new ArrayList<Method>()__		for (Class<?> current : getSuperClasses(clazz)) {_			for (Method method : current.getDeclaredMethods()) {_				Annotation annotation = getAnnotation(method, annotationType)__				if (annotation != null && !isShadowed(method, results)) {_					results.add(method)__				}_			}_		}_		return results__	};gets,all,methods,in,the,supplied,link,class,class,and,its,superclasses,which,are,annotated,with,the,supplied,code,annotation,type,but,which,are,not,em,shadowed,em,by,methods,overridden,in,subclasses,p,note,this,code,has,been,borrowed,from,link,org,junit,internal,runners,test,class,get,annotated,methods,class,and,adapted,param,clazz,the,class,for,which,to,retrieve,the,annotated,methods,param,annotation,type,the,annotation,type,for,which,to,search,return,all,annotated,methods,in,the,supplied,class,and,its,superclasses;private,list,method,get,annotated,methods,class,clazz,class,extends,annotation,annotation,type,list,method,results,new,array,list,method,for,class,current,get,super,classes,clazz,for,method,method,current,get,declared,methods,annotation,annotation,get,annotation,method,annotation,type,if,annotation,null,is,shadowed,method,results,results,add,method,return,results
TransactionalTestExecutionListener -> private List<Method> getAnnotatedMethods(Class<?> clazz, Class<? extends Annotation> annotationType);1385499540;Gets all methods in the supplied {@link Class class} and its superclasses_which are annotated with the supplied {@code annotationType} but_which are not <em>shadowed</em> by methods overridden in subclasses._<p>Note: This code has been borrowed from_{@link org.junit.internal.runners.TestClass#getAnnotatedMethods(Class)}_and adapted._@param clazz the class for which to retrieve the annotated methods_@param annotationType the annotation type for which to search_@return all annotated methods in the supplied class and its superclasses;private List<Method> getAnnotatedMethods(Class<?> clazz, Class<? extends Annotation> annotationType) {_		List<Method> results = new ArrayList<Method>()__		for (Class<?> current : getSuperClasses(clazz)) {_			for (Method method : current.getDeclaredMethods()) {_				Annotation annotation = getAnnotation(method, annotationType)__				if (annotation != null && !isShadowed(method, results)) {_					results.add(method)__				}_			}_		}_		return results__	};gets,all,methods,in,the,supplied,link,class,class,and,its,superclasses,which,are,annotated,with,the,supplied,code,annotation,type,but,which,are,not,em,shadowed,em,by,methods,overridden,in,subclasses,p,note,this,code,has,been,borrowed,from,link,org,junit,internal,runners,test,class,get,annotated,methods,class,and,adapted,param,clazz,the,class,for,which,to,retrieve,the,annotated,methods,param,annotation,type,the,annotation,type,for,which,to,search,return,all,annotated,methods,in,the,supplied,class,and,its,superclasses;private,list,method,get,annotated,methods,class,clazz,class,extends,annotation,annotation,type,list,method,results,new,array,list,method,for,class,current,get,super,classes,clazz,for,method,method,current,get,declared,methods,annotation,annotation,get,annotation,method,annotation,type,if,annotation,null,is,shadowed,method,results,results,add,method,return,results
TransactionalTestExecutionListener -> private List<Method> getAnnotatedMethods(Class<?> clazz, Class<? extends Annotation> annotationType);1389966876;Gets all methods in the supplied {@link Class class} and its superclasses_which are annotated with the supplied {@code annotationType} but_which are not <em>shadowed</em> by methods overridden in subclasses._<p>Note: This code has been borrowed from_{@link org.junit.internal.runners.TestClass#getAnnotatedMethods(Class)}_and adapted._@param clazz the class for which to retrieve the annotated methods_@param annotationType the annotation type for which to search_@return all annotated methods in the supplied class and its superclasses;private List<Method> getAnnotatedMethods(Class<?> clazz, Class<? extends Annotation> annotationType) {_		List<Method> results = new ArrayList<Method>()__		for (Class<?> current : getSuperClasses(clazz)) {_			for (Method method : current.getDeclaredMethods()) {_				Annotation annotation = getAnnotation(method, annotationType)__				if (annotation != null && !isShadowed(method, results)) {_					results.add(method)__				}_			}_		}_		return results__	};gets,all,methods,in,the,supplied,link,class,class,and,its,superclasses,which,are,annotated,with,the,supplied,code,annotation,type,but,which,are,not,em,shadowed,em,by,methods,overridden,in,subclasses,p,note,this,code,has,been,borrowed,from,link,org,junit,internal,runners,test,class,get,annotated,methods,class,and,adapted,param,clazz,the,class,for,which,to,retrieve,the,annotated,methods,param,annotation,type,the,annotation,type,for,which,to,search,return,all,annotated,methods,in,the,supplied,class,and,its,superclasses;private,list,method,get,annotated,methods,class,clazz,class,extends,annotation,annotation,type,list,method,results,new,array,list,method,for,class,current,get,super,classes,clazz,for,method,method,current,get,declared,methods,annotation,annotation,get,annotation,method,annotation,type,if,annotation,null,is,shadowed,method,results,results,add,method,return,results
TransactionalTestExecutionListener -> private List<Method> getAnnotatedMethods(Class<?> clazz, Class<? extends Annotation> annotationType);1401991965;Gets all methods in the supplied {@link Class class} and its superclasses_which are annotated with the supplied {@code annotationType} but_which are not <em>shadowed</em> by methods overridden in subclasses._<p>Note: This code has been borrowed from_{@link org.junit.internal.runners.TestClass#getAnnotatedMethods(Class)}_and adapted._@param clazz the class for which to retrieve the annotated methods_@param annotationType the annotation type for which to search_@return all annotated methods in the supplied class and its superclasses;private List<Method> getAnnotatedMethods(Class<?> clazz, Class<? extends Annotation> annotationType) {_		List<Method> results = new ArrayList<Method>()__		for (Class<?> current : getSuperClasses(clazz)) {_			for (Method method : current.getDeclaredMethods()) {_				Annotation annotation = getAnnotation(method, annotationType)__				if (annotation != null && !isShadowed(method, results)) {_					results.add(method)__				}_			}_		}_		return results__	};gets,all,methods,in,the,supplied,link,class,class,and,its,superclasses,which,are,annotated,with,the,supplied,code,annotation,type,but,which,are,not,em,shadowed,em,by,methods,overridden,in,subclasses,p,note,this,code,has,been,borrowed,from,link,org,junit,internal,runners,test,class,get,annotated,methods,class,and,adapted,param,clazz,the,class,for,which,to,retrieve,the,annotated,methods,param,annotation,type,the,annotation,type,for,which,to,search,return,all,annotated,methods,in,the,supplied,class,and,its,superclasses;private,list,method,get,annotated,methods,class,clazz,class,extends,annotation,annotation,type,list,method,results,new,array,list,method,for,class,current,get,super,classes,clazz,for,method,method,current,get,declared,methods,annotation,annotation,get,annotation,method,annotation,type,if,annotation,null,is,shadowed,method,results,results,add,method,return,results
TransactionalTestExecutionListener -> private List<Method> getAnnotatedMethods(Class<?> clazz, Class<? extends Annotation> annotationType);1404334604;Gets all methods in the supplied {@link Class class} and its superclasses_which are annotated with the supplied {@code annotationType} but_which are not <em>shadowed</em> by methods overridden in subclasses._<p>Note: This code has been borrowed from_{@link org.junit.internal.runners.TestClass#getAnnotatedMethods(Class)}_and adapted._@param clazz the class for which to retrieve the annotated methods_@param annotationType the annotation type for which to search_@return all annotated methods in the supplied class and its superclasses;private List<Method> getAnnotatedMethods(Class<?> clazz, Class<? extends Annotation> annotationType) {_		List<Method> results = new ArrayList<Method>()__		for (Class<?> current : getSuperClasses(clazz)) {_			for (Method method : current.getDeclaredMethods()) {_				Annotation annotation = getAnnotation(method, annotationType)__				if (annotation != null && !isShadowed(method, results)) {_					results.add(method)__				}_			}_		}_		return results__	};gets,all,methods,in,the,supplied,link,class,class,and,its,superclasses,which,are,annotated,with,the,supplied,code,annotation,type,but,which,are,not,em,shadowed,em,by,methods,overridden,in,subclasses,p,note,this,code,has,been,borrowed,from,link,org,junit,internal,runners,test,class,get,annotated,methods,class,and,adapted,param,clazz,the,class,for,which,to,retrieve,the,annotated,methods,param,annotation,type,the,annotation,type,for,which,to,search,return,all,annotated,methods,in,the,supplied,class,and,its,superclasses;private,list,method,get,annotated,methods,class,clazz,class,extends,annotation,annotation,type,list,method,results,new,array,list,method,for,class,current,get,super,classes,clazz,for,method,method,current,get,declared,methods,annotation,annotation,get,annotation,method,annotation,type,if,annotation,null,is,shadowed,method,results,results,add,method,return,results
TransactionalTestExecutionListener -> private List<Method> getAnnotatedMethods(Class<?> clazz, Class<? extends Annotation> annotationType);1405645143;Gets all methods in the supplied {@link Class class} and its superclasses_which are annotated with the supplied {@code annotationType} but_which are not <em>shadowed</em> by methods overridden in subclasses._<p>Note: This code has been borrowed from_{@link org.junit.internal.runners.TestClass#getAnnotatedMethods(Class)}_and adapted._@param clazz the class for which to retrieve the annotated methods_@param annotationType the annotation type for which to search_@return all annotated methods in the supplied class and its superclasses;private List<Method> getAnnotatedMethods(Class<?> clazz, Class<? extends Annotation> annotationType) {_		List<Method> results = new ArrayList<Method>()__		for (Class<?> current : getSuperClasses(clazz)) {_			for (Method method : current.getDeclaredMethods()) {_				Annotation annotation = getAnnotation(method, annotationType)__				if (annotation != null && !isShadowed(method, results)) {_					results.add(method)__				}_			}_		}_		return results__	};gets,all,methods,in,the,supplied,link,class,class,and,its,superclasses,which,are,annotated,with,the,supplied,code,annotation,type,but,which,are,not,em,shadowed,em,by,methods,overridden,in,subclasses,p,note,this,code,has,been,borrowed,from,link,org,junit,internal,runners,test,class,get,annotated,methods,class,and,adapted,param,clazz,the,class,for,which,to,retrieve,the,annotated,methods,param,annotation,type,the,annotation,type,for,which,to,search,return,all,annotated,methods,in,the,supplied,class,and,its,superclasses;private,list,method,get,annotated,methods,class,clazz,class,extends,annotation,annotation,type,list,method,results,new,array,list,method,for,class,current,get,super,classes,clazz,for,method,method,current,get,declared,methods,annotation,annotation,get,annotation,method,annotation,type,if,annotation,null,is,shadowed,method,results,results,add,method,return,results
TransactionalTestExecutionListener -> private List<Method> getAnnotatedMethods(Class<?> clazz, Class<? extends Annotation> annotationType);1405698612;Gets all methods in the supplied {@link Class class} and its superclasses_which are annotated with the supplied {@code annotationType} but_which are not <em>shadowed</em> by methods overridden in subclasses._<p>Note: This code has been borrowed from_{@link org.junit.internal.runners.TestClass#getAnnotatedMethods(Class)}_and adapted._@param clazz the class for which to retrieve the annotated methods_@param annotationType the annotation type for which to search_@return all annotated methods in the supplied class and its superclasses;private List<Method> getAnnotatedMethods(Class<?> clazz, Class<? extends Annotation> annotationType) {_		List<Method> results = new ArrayList<Method>()__		for (Class<?> current : getSuperClasses(clazz)) {_			for (Method method : current.getDeclaredMethods()) {_				Annotation annotation = getAnnotation(method, annotationType)__				if (annotation != null && !isShadowed(method, results)) {_					results.add(method)__				}_			}_		}_		return results__	};gets,all,methods,in,the,supplied,link,class,class,and,its,superclasses,which,are,annotated,with,the,supplied,code,annotation,type,but,which,are,not,em,shadowed,em,by,methods,overridden,in,subclasses,p,note,this,code,has,been,borrowed,from,link,org,junit,internal,runners,test,class,get,annotated,methods,class,and,adapted,param,clazz,the,class,for,which,to,retrieve,the,annotated,methods,param,annotation,type,the,annotation,type,for,which,to,search,return,all,annotated,methods,in,the,supplied,class,and,its,superclasses;private,list,method,get,annotated,methods,class,clazz,class,extends,annotation,annotation,type,list,method,results,new,array,list,method,for,class,current,get,super,classes,clazz,for,method,method,current,get,declared,methods,annotation,annotation,get,annotation,method,annotation,type,if,annotation,null,is,shadowed,method,results,results,add,method,return,results
TransactionalTestExecutionListener -> private List<Method> getAnnotatedMethods(Class<?> clazz, Class<? extends Annotation> annotationType);1405759527;Gets all methods in the supplied {@link Class class} and its superclasses_which are annotated with the supplied {@code annotationType} but_which are not <em>shadowed</em> by methods overridden in subclasses._<p>Note: This code has been borrowed from_{@link org.junit.internal.runners.TestClass#getAnnotatedMethods(Class)}_and adapted._@param clazz the class for which to retrieve the annotated methods_@param annotationType the annotation type for which to search_@return all annotated methods in the supplied class and its superclasses;private List<Method> getAnnotatedMethods(Class<?> clazz, Class<? extends Annotation> annotationType) {_		List<Method> results = new ArrayList<Method>()__		for (Class<?> current : getSuperClasses(clazz)) {_			for (Method method : current.getDeclaredMethods()) {_				Annotation annotation = getAnnotation(method, annotationType)__				if (annotation != null && !isShadowed(method, results)) {_					results.add(method)__				}_			}_		}_		return results__	};gets,all,methods,in,the,supplied,link,class,class,and,its,superclasses,which,are,annotated,with,the,supplied,code,annotation,type,but,which,are,not,em,shadowed,em,by,methods,overridden,in,subclasses,p,note,this,code,has,been,borrowed,from,link,org,junit,internal,runners,test,class,get,annotated,methods,class,and,adapted,param,clazz,the,class,for,which,to,retrieve,the,annotated,methods,param,annotation,type,the,annotation,type,for,which,to,search,return,all,annotated,methods,in,the,supplied,class,and,its,superclasses;private,list,method,get,annotated,methods,class,clazz,class,extends,annotation,annotation,type,list,method,results,new,array,list,method,for,class,current,get,super,classes,clazz,for,method,method,current,get,declared,methods,annotation,annotation,get,annotation,method,annotation,type,if,annotation,null,is,shadowed,method,results,results,add,method,return,results
TransactionalTestExecutionListener -> private List<Method> getAnnotatedMethods(Class<?> clazz, Class<? extends Annotation> annotationType);1405759966;Gets all methods in the supplied {@link Class class} and its superclasses_which are annotated with the supplied {@code annotationType} but_which are not <em>shadowed</em> by methods overridden in subclasses._<p>Note: This code has been borrowed from_{@link org.junit.internal.runners.TestClass#getAnnotatedMethods(Class)}_and adapted._@param clazz the class for which to retrieve the annotated methods_@param annotationType the annotation type for which to search_@return all annotated methods in the supplied class and its superclasses;private List<Method> getAnnotatedMethods(Class<?> clazz, Class<? extends Annotation> annotationType) {_		List<Method> results = new ArrayList<Method>()__		for (Class<?> current : getSuperClasses(clazz)) {_			for (Method method : current.getDeclaredMethods()) {_				Annotation annotation = getAnnotation(method, annotationType)__				if (annotation != null && !isShadowed(method, results)) {_					results.add(method)__				}_			}_		}_		return results__	};gets,all,methods,in,the,supplied,link,class,class,and,its,superclasses,which,are,annotated,with,the,supplied,code,annotation,type,but,which,are,not,em,shadowed,em,by,methods,overridden,in,subclasses,p,note,this,code,has,been,borrowed,from,link,org,junit,internal,runners,test,class,get,annotated,methods,class,and,adapted,param,clazz,the,class,for,which,to,retrieve,the,annotated,methods,param,annotation,type,the,annotation,type,for,which,to,search,return,all,annotated,methods,in,the,supplied,class,and,its,superclasses;private,list,method,get,annotated,methods,class,clazz,class,extends,annotation,annotation,type,list,method,results,new,array,list,method,for,class,current,get,super,classes,clazz,for,method,method,current,get,declared,methods,annotation,annotation,get,annotation,method,annotation,type,if,annotation,null,is,shadowed,method,results,results,add,method,return,results
TransactionalTestExecutionListener -> private List<Method> getAnnotatedMethods(Class<?> clazz, Class<? extends Annotation> annotationType);1406218418;Gets all methods in the supplied {@link Class class} and its superclasses_which are annotated with the supplied {@code annotationType} but_which are not <em>shadowed</em> by methods overridden in subclasses._<p>Note: This code has been borrowed from_{@link org.junit.internal.runners.TestClass#getAnnotatedMethods(Class)}_and adapted._@param clazz the class for which to retrieve the annotated methods_@param annotationType the annotation type for which to search_@return all annotated methods in the supplied class and its superclasses;private List<Method> getAnnotatedMethods(Class<?> clazz, Class<? extends Annotation> annotationType) {_		List<Method> results = new ArrayList<Method>()__		for (Class<?> current : getSuperClasses(clazz)) {_			for (Method method : current.getDeclaredMethods()) {_				Annotation annotation = getAnnotation(method, annotationType)__				if (annotation != null && !isShadowed(method, results)) {_					results.add(method)__				}_			}_		}_		return results__	};gets,all,methods,in,the,supplied,link,class,class,and,its,superclasses,which,are,annotated,with,the,supplied,code,annotation,type,but,which,are,not,em,shadowed,em,by,methods,overridden,in,subclasses,p,note,this,code,has,been,borrowed,from,link,org,junit,internal,runners,test,class,get,annotated,methods,class,and,adapted,param,clazz,the,class,for,which,to,retrieve,the,annotated,methods,param,annotation,type,the,annotation,type,for,which,to,search,return,all,annotated,methods,in,the,supplied,class,and,its,superclasses;private,list,method,get,annotated,methods,class,clazz,class,extends,annotation,annotation,type,list,method,results,new,array,list,method,for,class,current,get,super,classes,clazz,for,method,method,current,get,declared,methods,annotation,annotation,get,annotation,method,annotation,type,if,annotation,null,is,shadowed,method,results,results,add,method,return,results
TransactionalTestExecutionListener -> private List<Method> getAnnotatedMethods(Class<?> clazz, Class<? extends Annotation> annotationType);1407419079;Gets all methods in the supplied {@link Class class} and its superclasses_which are annotated with the supplied {@code annotationType} but_which are not <em>shadowed</em> by methods overridden in subclasses._<p>Note: This code has been borrowed from_{@link org.junit.internal.runners.TestClass#getAnnotatedMethods(Class)}_and adapted._@param clazz the class for which to retrieve the annotated methods_@param annotationType the annotation type for which to search_@return all annotated methods in the supplied class and its superclasses;private List<Method> getAnnotatedMethods(Class<?> clazz, Class<? extends Annotation> annotationType) {_		List<Method> results = new ArrayList<Method>()__		for (Class<?> current : getSuperClasses(clazz)) {_			for (Method method : current.getDeclaredMethods()) {_				Annotation annotation = getAnnotation(method, annotationType)__				if (annotation != null && !isShadowed(method, results)) {_					results.add(method)__				}_			}_		}_		return results__	};gets,all,methods,in,the,supplied,link,class,class,and,its,superclasses,which,are,annotated,with,the,supplied,code,annotation,type,but,which,are,not,em,shadowed,em,by,methods,overridden,in,subclasses,p,note,this,code,has,been,borrowed,from,link,org,junit,internal,runners,test,class,get,annotated,methods,class,and,adapted,param,clazz,the,class,for,which,to,retrieve,the,annotated,methods,param,annotation,type,the,annotation,type,for,which,to,search,return,all,annotated,methods,in,the,supplied,class,and,its,superclasses;private,list,method,get,annotated,methods,class,clazz,class,extends,annotation,annotation,type,list,method,results,new,array,list,method,for,class,current,get,super,classes,clazz,for,method,method,current,get,declared,methods,annotation,annotation,get,annotation,method,annotation,type,if,annotation,null,is,shadowed,method,results,results,add,method,return,results
TransactionalTestExecutionListener -> private List<Method> getAnnotatedMethods(Class<?> clazz, Class<? extends Annotation> annotationType);1408048216;Gets all methods in the supplied {@link Class class} and its superclasses_which are annotated with the supplied {@code annotationType} but_which are not <em>shadowed</em> by methods overridden in subclasses._<p>Note: This code has been borrowed from_{@link org.junit.internal.runners.TestClass#getAnnotatedMethods(Class)}_and adapted._@param clazz the class for which to retrieve the annotated methods_@param annotationType the annotation type for which to search_@return all annotated methods in the supplied class and its superclasses;private List<Method> getAnnotatedMethods(Class<?> clazz, Class<? extends Annotation> annotationType) {_		List<Method> results = new ArrayList<Method>()__		for (Class<?> current : getSuperClasses(clazz)) {_			for (Method method : current.getDeclaredMethods()) {_				Annotation annotation = getAnnotation(method, annotationType)__				if (annotation != null && !isShadowed(method, results)) {_					results.add(method)__				}_			}_		}_		return results__	};gets,all,methods,in,the,supplied,link,class,class,and,its,superclasses,which,are,annotated,with,the,supplied,code,annotation,type,but,which,are,not,em,shadowed,em,by,methods,overridden,in,subclasses,p,note,this,code,has,been,borrowed,from,link,org,junit,internal,runners,test,class,get,annotated,methods,class,and,adapted,param,clazz,the,class,for,which,to,retrieve,the,annotated,methods,param,annotation,type,the,annotation,type,for,which,to,search,return,all,annotated,methods,in,the,supplied,class,and,its,superclasses;private,list,method,get,annotated,methods,class,clazz,class,extends,annotation,annotation,type,list,method,results,new,array,list,method,for,class,current,get,super,classes,clazz,for,method,method,current,get,declared,methods,annotation,annotation,get,annotation,method,annotation,type,if,annotation,null,is,shadowed,method,results,results,add,method,return,results
TransactionalTestExecutionListener -> private List<Method> getAnnotatedMethods(Class<?> clazz, Class<? extends Annotation> annotationType);1413848647;Gets all methods in the supplied {@link Class class} and its superclasses_which are annotated with the supplied {@code annotationType} but_which are not <em>shadowed</em> by methods overridden in subclasses._<p>Note: This code has been borrowed from_{@link org.junit.internal.runners.TestClass#getAnnotatedMethods(Class)}_and adapted._@param clazz the class for which to retrieve the annotated methods_@param annotationType the annotation type for which to search_@return all annotated methods in the supplied class and its superclasses;private List<Method> getAnnotatedMethods(Class<?> clazz, Class<? extends Annotation> annotationType) {_		List<Method> results = new ArrayList<Method>()__		for (Class<?> current : getSuperClasses(clazz)) {_			for (Method method : current.getDeclaredMethods()) {_				Annotation annotation = getAnnotation(method, annotationType)__				if (annotation != null && !isShadowed(method, results)) {_					results.add(method)__				}_			}_		}_		return results__	};gets,all,methods,in,the,supplied,link,class,class,and,its,superclasses,which,are,annotated,with,the,supplied,code,annotation,type,but,which,are,not,em,shadowed,em,by,methods,overridden,in,subclasses,p,note,this,code,has,been,borrowed,from,link,org,junit,internal,runners,test,class,get,annotated,methods,class,and,adapted,param,clazz,the,class,for,which,to,retrieve,the,annotated,methods,param,annotation,type,the,annotation,type,for,which,to,search,return,all,annotated,methods,in,the,supplied,class,and,its,superclasses;private,list,method,get,annotated,methods,class,clazz,class,extends,annotation,annotation,type,list,method,results,new,array,list,method,for,class,current,get,super,classes,clazz,for,method,method,current,get,declared,methods,annotation,annotation,get,annotation,method,annotation,type,if,annotation,null,is,shadowed,method,results,results,add,method,return,results
TransactionalTestExecutionListener -> private List<Method> getAnnotatedMethods(Class<?> clazz, Class<? extends Annotation> annotationType);1431568199;Gets all methods in the supplied {@link Class class} and its superclasses_which are annotated with the supplied {@code annotationType} but_which are not <em>shadowed</em> by methods overridden in subclasses._<p>Note: This code has been borrowed from_{@link org.junit.internal.runners.TestClass#getAnnotatedMethods(Class)}_and adapted._@param clazz the class for which to retrieve the annotated methods_@param annotationType the annotation type for which to search_@return all annotated methods in the supplied class and its superclasses;private List<Method> getAnnotatedMethods(Class<?> clazz, Class<? extends Annotation> annotationType) {_		List<Method> results = new ArrayList<Method>()__		for (Class<?> current : getSuperClasses(clazz)) {_			for (Method method : current.getDeclaredMethods()) {_				Annotation annotation = getAnnotation(method, annotationType)__				if (annotation != null && !isShadowed(method, results)) {_					results.add(method)__				}_			}_		}_		return results__	};gets,all,methods,in,the,supplied,link,class,class,and,its,superclasses,which,are,annotated,with,the,supplied,code,annotation,type,but,which,are,not,em,shadowed,em,by,methods,overridden,in,subclasses,p,note,this,code,has,been,borrowed,from,link,org,junit,internal,runners,test,class,get,annotated,methods,class,and,adapted,param,clazz,the,class,for,which,to,retrieve,the,annotated,methods,param,annotation,type,the,annotation,type,for,which,to,search,return,all,annotated,methods,in,the,supplied,class,and,its,superclasses;private,list,method,get,annotated,methods,class,clazz,class,extends,annotation,annotation,type,list,method,results,new,array,list,method,for,class,current,get,super,classes,clazz,for,method,method,current,get,declared,methods,annotation,annotation,get,annotation,method,annotation,type,if,annotation,null,is,shadowed,method,results,results,add,method,return,results
TransactionalTestExecutionListener -> private List<Method> getAnnotatedMethods(Class<?> clazz, Class<? extends Annotation> annotationType);1432125256;Gets all methods in the supplied {@link Class class} and its superclasses_which are annotated with the supplied {@code annotationType} but_which are not <em>shadowed</em> by methods overridden in subclasses._<p>Note: This code has been borrowed from_{@link org.junit.internal.runners.TestClass#getAnnotatedMethods(Class)}_and adapted._@param clazz the class for which to retrieve the annotated methods_@param annotationType the annotation type for which to search_@return all annotated methods in the supplied class and its superclasses;private List<Method> getAnnotatedMethods(Class<?> clazz, Class<? extends Annotation> annotationType) {_		List<Method> results = new ArrayList<Method>()__		for (Class<?> current : getSuperClasses(clazz)) {_			for (Method method : current.getDeclaredMethods()) {_				Annotation annotation = getAnnotation(method, annotationType)__				if (annotation != null && !isShadowed(method, results)) {_					results.add(method)__				}_			}_		}_		return results__	};gets,all,methods,in,the,supplied,link,class,class,and,its,superclasses,which,are,annotated,with,the,supplied,code,annotation,type,but,which,are,not,em,shadowed,em,by,methods,overridden,in,subclasses,p,note,this,code,has,been,borrowed,from,link,org,junit,internal,runners,test,class,get,annotated,methods,class,and,adapted,param,clazz,the,class,for,which,to,retrieve,the,annotated,methods,param,annotation,type,the,annotation,type,for,which,to,search,return,all,annotated,methods,in,the,supplied,class,and,its,superclasses;private,list,method,get,annotated,methods,class,clazz,class,extends,annotation,annotation,type,list,method,results,new,array,list,method,for,class,current,get,super,classes,clazz,for,method,method,current,get,declared,methods,annotation,annotation,get,annotation,method,annotation,type,if,annotation,null,is,shadowed,method,results,results,add,method,return,results
TransactionalTestExecutionListener -> private List<Method> getAnnotatedMethods(Class<?> clazz, Class<? extends Annotation> annotationType);1432856630;Gets all methods in the supplied {@link Class class} and its superclasses_which are annotated with the supplied {@code annotationType} but_which are not <em>shadowed</em> by methods overridden in subclasses._<p>Note: This code has been borrowed from_{@link org.junit.internal.runners.TestClass#getAnnotatedMethods(Class)}_and adapted._@param clazz the class for which to retrieve the annotated methods_@param annotationType the annotation type for which to search_@return all annotated methods in the supplied class and its superclasses;private List<Method> getAnnotatedMethods(Class<?> clazz, Class<? extends Annotation> annotationType) {_		List<Method> results = new ArrayList<Method>()__		for (Class<?> current : getSuperClasses(clazz)) {_			for (Method method : current.getDeclaredMethods()) {_				Annotation annotation = getAnnotation(method, annotationType)__				if (annotation != null && !isShadowed(method, results)) {_					results.add(method)__				}_			}_		}_		return results__	};gets,all,methods,in,the,supplied,link,class,class,and,its,superclasses,which,are,annotated,with,the,supplied,code,annotation,type,but,which,are,not,em,shadowed,em,by,methods,overridden,in,subclasses,p,note,this,code,has,been,borrowed,from,link,org,junit,internal,runners,test,class,get,annotated,methods,class,and,adapted,param,clazz,the,class,for,which,to,retrieve,the,annotated,methods,param,annotation,type,the,annotation,type,for,which,to,search,return,all,annotated,methods,in,the,supplied,class,and,its,superclasses;private,list,method,get,annotated,methods,class,clazz,class,extends,annotation,annotation,type,list,method,results,new,array,list,method,for,class,current,get,super,classes,clazz,for,method,method,current,get,declared,methods,annotation,annotation,get,annotation,method,annotation,type,if,annotation,null,is,shadowed,method,results,results,add,method,return,results
TransactionalTestExecutionListener -> private List<Method> getAnnotatedMethods(Class<?> clazz, Class<? extends Annotation> annotationType);1434234880;Gets all methods in the supplied {@link Class class} and its superclasses_which are annotated with the supplied {@code annotationType} but_which are not <em>shadowed</em> by methods overridden in subclasses._<p>Note: This code has been borrowed from_{@link org.junit.internal.runners.TestClass#getAnnotatedMethods(Class)}_and adapted._@param clazz the class for which to retrieve the annotated methods_@param annotationType the annotation type for which to search_@return all annotated methods in the supplied class and its superclasses;private List<Method> getAnnotatedMethods(Class<?> clazz, Class<? extends Annotation> annotationType) {_		List<Method> results = new ArrayList<Method>()__		for (Class<?> current : getSuperClasses(clazz)) {_			for (Method method : current.getDeclaredMethods()) {_				Annotation annotation = getAnnotation(method, annotationType)__				if (annotation != null && !isShadowed(method, results)) {_					results.add(method)__				}_			}_		}_		return results__	};gets,all,methods,in,the,supplied,link,class,class,and,its,superclasses,which,are,annotated,with,the,supplied,code,annotation,type,but,which,are,not,em,shadowed,em,by,methods,overridden,in,subclasses,p,note,this,code,has,been,borrowed,from,link,org,junit,internal,runners,test,class,get,annotated,methods,class,and,adapted,param,clazz,the,class,for,which,to,retrieve,the,annotated,methods,param,annotation,type,the,annotation,type,for,which,to,search,return,all,annotated,methods,in,the,supplied,class,and,its,superclasses;private,list,method,get,annotated,methods,class,clazz,class,extends,annotation,annotation,type,list,method,results,new,array,list,method,for,class,current,get,super,classes,clazz,for,method,method,current,get,declared,methods,annotation,annotation,get,annotation,method,annotation,type,if,annotation,null,is,shadowed,method,results,results,add,method,return,results
TransactionalTestExecutionListener -> private List<Method> getAnnotatedMethods(Class<?> clazz, Class<? extends Annotation> annotationType);1434720443;Gets all methods in the supplied {@link Class class} and its superclasses_which are annotated with the supplied {@code annotationType} but_which are not <em>shadowed</em> by methods overridden in subclasses._<p>Note: This code has been borrowed from_{@link org.junit.internal.runners.TestClass#getAnnotatedMethods(Class)}_and adapted._@param clazz the class for which to retrieve the annotated methods_@param annotationType the annotation type for which to search_@return all annotated methods in the supplied class and its superclasses;private List<Method> getAnnotatedMethods(Class<?> clazz, Class<? extends Annotation> annotationType) {_		List<Method> results = new ArrayList<Method>()__		for (Class<?> current : getSuperClasses(clazz)) {_			for (Method method : current.getDeclaredMethods()) {_				Annotation annotation = getAnnotation(method, annotationType)__				if (annotation != null && !isShadowed(method, results)) {_					results.add(method)__				}_			}_		}_		return results__	};gets,all,methods,in,the,supplied,link,class,class,and,its,superclasses,which,are,annotated,with,the,supplied,code,annotation,type,but,which,are,not,em,shadowed,em,by,methods,overridden,in,subclasses,p,note,this,code,has,been,borrowed,from,link,org,junit,internal,runners,test,class,get,annotated,methods,class,and,adapted,param,clazz,the,class,for,which,to,retrieve,the,annotated,methods,param,annotation,type,the,annotation,type,for,which,to,search,return,all,annotated,methods,in,the,supplied,class,and,its,superclasses;private,list,method,get,annotated,methods,class,clazz,class,extends,annotation,annotation,type,list,method,results,new,array,list,method,for,class,current,get,super,classes,clazz,for,method,method,current,get,declared,methods,annotation,annotation,get,annotation,method,annotation,type,if,annotation,null,is,shadowed,method,results,results,add,method,return,results
TransactionalTestExecutionListener -> private List<Method> getAnnotatedMethods(Class<?> clazz, Class<? extends Annotation> annotationType);1434817656;Gets all methods in the supplied {@link Class class} and its superclasses_which are annotated with the supplied {@code annotationType} but_which are not <em>shadowed</em> by methods overridden in subclasses._<p>Note: This code has been borrowed from_{@link org.junit.internal.runners.TestClass#getAnnotatedMethods(Class)}_and adapted._@param clazz the class for which to retrieve the annotated methods_@param annotationType the annotation type for which to search_@return all annotated methods in the supplied class and its superclasses;private List<Method> getAnnotatedMethods(Class<?> clazz, Class<? extends Annotation> annotationType) {_		List<Method> results = new ArrayList<Method>()__		for (Class<?> current : getSuperClasses(clazz)) {_			for (Method method : current.getDeclaredMethods()) {_				Annotation annotation = getAnnotation(method, annotationType)__				if (annotation != null && !isShadowed(method, results)) {_					results.add(method)__				}_			}_		}_		return results__	};gets,all,methods,in,the,supplied,link,class,class,and,its,superclasses,which,are,annotated,with,the,supplied,code,annotation,type,but,which,are,not,em,shadowed,em,by,methods,overridden,in,subclasses,p,note,this,code,has,been,borrowed,from,link,org,junit,internal,runners,test,class,get,annotated,methods,class,and,adapted,param,clazz,the,class,for,which,to,retrieve,the,annotated,methods,param,annotation,type,the,annotation,type,for,which,to,search,return,all,annotated,methods,in,the,supplied,class,and,its,superclasses;private,list,method,get,annotated,methods,class,clazz,class,extends,annotation,annotation,type,list,method,results,new,array,list,method,for,class,current,get,super,classes,clazz,for,method,method,current,get,declared,methods,annotation,annotation,get,annotation,method,annotation,type,if,annotation,null,is,shadowed,method,results,results,add,method,return,results
TransactionalTestExecutionListener -> private List<Method> getAnnotatedMethods(Class<?> clazz, Class<? extends Annotation> annotationType);1437841346;Gets all methods in the supplied {@link Class class} and its superclasses_which are annotated with the supplied {@code annotationType} but_which are not <em>shadowed</em> by methods overridden in subclasses._<p>Note: This code has been borrowed from_{@link org.junit.internal.runners.TestClass#getAnnotatedMethods(Class)}_and adapted._@param clazz the class for which to retrieve the annotated methods_@param annotationType the annotation type for which to search_@return all annotated methods in the supplied class and its superclasses;private List<Method> getAnnotatedMethods(Class<?> clazz, Class<? extends Annotation> annotationType) {_		List<Method> results = new ArrayList<Method>()__		for (Class<?> current : getSuperClasses(clazz)) {_			for (Method method : current.getDeclaredMethods()) {_				Annotation annotation = getAnnotation(method, annotationType)__				if (annotation != null && !isShadowed(method, results)) {_					results.add(method)__				}_			}_		}_		return results__	};gets,all,methods,in,the,supplied,link,class,class,and,its,superclasses,which,are,annotated,with,the,supplied,code,annotation,type,but,which,are,not,em,shadowed,em,by,methods,overridden,in,subclasses,p,note,this,code,has,been,borrowed,from,link,org,junit,internal,runners,test,class,get,annotated,methods,class,and,adapted,param,clazz,the,class,for,which,to,retrieve,the,annotated,methods,param,annotation,type,the,annotation,type,for,which,to,search,return,all,annotated,methods,in,the,supplied,class,and,its,superclasses;private,list,method,get,annotated,methods,class,clazz,class,extends,annotation,annotation,type,list,method,results,new,array,list,method,for,class,current,get,super,classes,clazz,for,method,method,current,get,declared,methods,annotation,annotation,get,annotation,method,annotation,type,if,annotation,null,is,shadowed,method,results,results,add,method,return,results
TransactionalTestExecutionListener -> private List<Method> getAnnotatedMethods(Class<?> clazz, Class<? extends Annotation> annotationType);1437851372;Gets all methods in the supplied {@link Class class} and its superclasses_which are annotated with the supplied {@code annotationType} but_which are not <em>shadowed</em> by methods overridden in subclasses._<p>Note: This code has been borrowed from_{@link org.junit.internal.runners.TestClass#getAnnotatedMethods(Class)}_and adapted._@param clazz the class for which to retrieve the annotated methods_@param annotationType the annotation type for which to search_@return all annotated methods in the supplied class and its superclasses;private List<Method> getAnnotatedMethods(Class<?> clazz, Class<? extends Annotation> annotationType) {_		List<Method> results = new ArrayList<Method>()__		for (Class<?> current : getSuperClasses(clazz)) {_			for (Method method : current.getDeclaredMethods()) {_				Annotation annotation = getAnnotation(method, annotationType)__				if (annotation != null && !isShadowed(method, results)) {_					results.add(method)__				}_			}_		}_		return results__	};gets,all,methods,in,the,supplied,link,class,class,and,its,superclasses,which,are,annotated,with,the,supplied,code,annotation,type,but,which,are,not,em,shadowed,em,by,methods,overridden,in,subclasses,p,note,this,code,has,been,borrowed,from,link,org,junit,internal,runners,test,class,get,annotated,methods,class,and,adapted,param,clazz,the,class,for,which,to,retrieve,the,annotated,methods,param,annotation,type,the,annotation,type,for,which,to,search,return,all,annotated,methods,in,the,supplied,class,and,its,superclasses;private,list,method,get,annotated,methods,class,clazz,class,extends,annotation,annotation,type,list,method,results,new,array,list,method,for,class,current,get,super,classes,clazz,for,method,method,current,get,declared,methods,annotation,annotation,get,annotation,method,annotation,type,if,annotation,null,is,shadowed,method,results,results,add,method,return,results
TransactionalTestExecutionListener -> private List<Method> getAnnotatedMethods(Class<?> clazz, Class<? extends Annotation> annotationType);1437852597;Gets all methods in the supplied {@link Class class} and its superclasses_which are annotated with the supplied {@code annotationType} but_which are not <em>shadowed</em> by methods overridden in subclasses._<p>Note: This code has been borrowed from_{@link org.junit.internal.runners.TestClass#getAnnotatedMethods(Class)}_and adapted._@param clazz the class for which to retrieve the annotated methods_@param annotationType the annotation type for which to search_@return all annotated methods in the supplied class and its superclasses;private List<Method> getAnnotatedMethods(Class<?> clazz, Class<? extends Annotation> annotationType) {_		List<Method> results = new ArrayList<Method>()__		for (Class<?> current : getSuperClasses(clazz)) {_			for (Method method : current.getDeclaredMethods()) {_				Annotation annotation = getAnnotation(method, annotationType)__				if (annotation != null && !isShadowed(method, results)) {_					results.add(method)__				}_			}_		}_		return results__	};gets,all,methods,in,the,supplied,link,class,class,and,its,superclasses,which,are,annotated,with,the,supplied,code,annotation,type,but,which,are,not,em,shadowed,em,by,methods,overridden,in,subclasses,p,note,this,code,has,been,borrowed,from,link,org,junit,internal,runners,test,class,get,annotated,methods,class,and,adapted,param,clazz,the,class,for,which,to,retrieve,the,annotated,methods,param,annotation,type,the,annotation,type,for,which,to,search,return,all,annotated,methods,in,the,supplied,class,and,its,superclasses;private,list,method,get,annotated,methods,class,clazz,class,extends,annotation,annotation,type,list,method,results,new,array,list,method,for,class,current,get,super,classes,clazz,for,method,method,current,get,declared,methods,annotation,annotation,get,annotation,method,annotation,type,if,annotation,null,is,shadowed,method,results,results,add,method,return,results
TransactionalTestExecutionListener -> private List<Method> getAnnotatedMethods(Class<?> clazz, Class<? extends Annotation> annotationType);1454507787;Gets all methods in the supplied {@link Class class} and its superclasses_which are annotated with the supplied {@code annotationType} but_which are not <em>shadowed</em> by methods overridden in subclasses._<p>Note: This code has been borrowed from_{@link org.junit.internal.runners.TestClass#getAnnotatedMethods(Class)}_and adapted._@param clazz the class for which to retrieve the annotated methods_@param annotationType the annotation type for which to search_@return all annotated methods in the supplied class and its superclasses;private List<Method> getAnnotatedMethods(Class<?> clazz, Class<? extends Annotation> annotationType) {_		List<Method> results = new ArrayList<Method>()__		for (Class<?> current : getSuperClasses(clazz)) {_			for (Method method : current.getDeclaredMethods()) {_				Annotation annotation = getAnnotation(method, annotationType)__				if (annotation != null && !isShadowed(method, results)) {_					results.add(method)__				}_			}_		}_		return results__	};gets,all,methods,in,the,supplied,link,class,class,and,its,superclasses,which,are,annotated,with,the,supplied,code,annotation,type,but,which,are,not,em,shadowed,em,by,methods,overridden,in,subclasses,p,note,this,code,has,been,borrowed,from,link,org,junit,internal,runners,test,class,get,annotated,methods,class,and,adapted,param,clazz,the,class,for,which,to,retrieve,the,annotated,methods,param,annotation,type,the,annotation,type,for,which,to,search,return,all,annotated,methods,in,the,supplied,class,and,its,superclasses;private,list,method,get,annotated,methods,class,clazz,class,extends,annotation,annotation,type,list,method,results,new,array,list,method,for,class,current,get,super,classes,clazz,for,method,method,current,get,declared,methods,annotation,annotation,get,annotation,method,annotation,type,if,annotation,null,is,shadowed,method,results,results,add,method,return,results
TransactionalTestExecutionListener -> private List<Method> getAnnotatedMethods(Class<?> clazz, Class<? extends Annotation> annotationType);1456702967;Gets all methods in the supplied {@link Class class} and its superclasses_which are annotated with the supplied {@code annotationType} but_which are not <em>shadowed</em> by methods overridden in subclasses._<p>Note: This code has been borrowed from_{@link org.junit.internal.runners.TestClass#getAnnotatedMethods(Class)}_and adapted._@param clazz the class for which to retrieve the annotated methods_@param annotationType the annotation type for which to search_@return all annotated methods in the supplied class and its superclasses;private List<Method> getAnnotatedMethods(Class<?> clazz, Class<? extends Annotation> annotationType) {_		List<Method> results = new ArrayList<Method>()__		for (Class<?> current : getSuperClasses(clazz)) {_			for (Method method : current.getDeclaredMethods()) {_				Annotation annotation = getAnnotation(method, annotationType)__				if (annotation != null && !isShadowed(method, results)) {_					results.add(method)__				}_			}_		}_		return results__	};gets,all,methods,in,the,supplied,link,class,class,and,its,superclasses,which,are,annotated,with,the,supplied,code,annotation,type,but,which,are,not,em,shadowed,em,by,methods,overridden,in,subclasses,p,note,this,code,has,been,borrowed,from,link,org,junit,internal,runners,test,class,get,annotated,methods,class,and,adapted,param,clazz,the,class,for,which,to,retrieve,the,annotated,methods,param,annotation,type,the,annotation,type,for,which,to,search,return,all,annotated,methods,in,the,supplied,class,and,its,superclasses;private,list,method,get,annotated,methods,class,clazz,class,extends,annotation,annotation,type,list,method,results,new,array,list,method,for,class,current,get,super,classes,clazz,for,method,method,current,get,declared,methods,annotation,annotation,get,annotation,method,annotation,type,if,annotation,null,is,shadowed,method,results,results,add,method,return,results
TransactionalTestExecutionListener -> private List<Method> getAnnotatedMethods(Class<?> clazz, Class<? extends Annotation> annotationType);1456756222;Gets all methods in the supplied {@link Class class} and its superclasses_which are annotated with the supplied {@code annotationType} but_which are not <em>shadowed</em> by methods overridden in subclasses._<p>Note: This code has been borrowed from_{@link org.junit.internal.runners.TestClass#getAnnotatedMethods(Class)}_and adapted._@param clazz the class for which to retrieve the annotated methods_@param annotationType the annotation type for which to search_@return all annotated methods in the supplied class and its superclasses;private List<Method> getAnnotatedMethods(Class<?> clazz, Class<? extends Annotation> annotationType) {_		List<Method> results = new ArrayList<Method>()__		for (Class<?> current : getSuperClasses(clazz)) {_			for (Method method : current.getDeclaredMethods()) {_				Annotation annotation = getAnnotation(method, annotationType)__				if (annotation != null && !isShadowed(method, results)) {_					results.add(method)__				}_			}_		}_		return results__	};gets,all,methods,in,the,supplied,link,class,class,and,its,superclasses,which,are,annotated,with,the,supplied,code,annotation,type,but,which,are,not,em,shadowed,em,by,methods,overridden,in,subclasses,p,note,this,code,has,been,borrowed,from,link,org,junit,internal,runners,test,class,get,annotated,methods,class,and,adapted,param,clazz,the,class,for,which,to,retrieve,the,annotated,methods,param,annotation,type,the,annotation,type,for,which,to,search,return,all,annotated,methods,in,the,supplied,class,and,its,superclasses;private,list,method,get,annotated,methods,class,clazz,class,extends,annotation,annotation,type,list,method,results,new,array,list,method,for,class,current,get,super,classes,clazz,for,method,method,current,get,declared,methods,annotation,annotation,get,annotation,method,annotation,type,if,annotation,null,is,shadowed,method,results,results,add,method,return,results
TransactionalTestExecutionListener -> private List<Method> getAnnotatedMethods(Class<?> clazz, Class<? extends Annotation> annotationType);1456756222;Gets all methods in the supplied {@link Class class} and its superclasses_which are annotated with the supplied {@code annotationType} but_which are not <em>shadowed</em> by methods overridden in subclasses._<p>Note: This code has been borrowed from_{@link org.junit.internal.runners.TestClass#getAnnotatedMethods(Class)}_and adapted._@param clazz the class for which to retrieve the annotated methods_@param annotationType the annotation type for which to search_@return all annotated methods in the supplied class and its superclasses;private List<Method> getAnnotatedMethods(Class<?> clazz, Class<? extends Annotation> annotationType) {_		List<Method> results = new ArrayList<Method>()__		for (Class<?> current : getSuperClasses(clazz)) {_			for (Method method : current.getDeclaredMethods()) {_				Annotation annotation = getAnnotation(method, annotationType)__				if (annotation != null && !isShadowed(method, results)) {_					results.add(method)__				}_			}_		}_		return results__	};gets,all,methods,in,the,supplied,link,class,class,and,its,superclasses,which,are,annotated,with,the,supplied,code,annotation,type,but,which,are,not,em,shadowed,em,by,methods,overridden,in,subclasses,p,note,this,code,has,been,borrowed,from,link,org,junit,internal,runners,test,class,get,annotated,methods,class,and,adapted,param,clazz,the,class,for,which,to,retrieve,the,annotated,methods,param,annotation,type,the,annotation,type,for,which,to,search,return,all,annotated,methods,in,the,supplied,class,and,its,superclasses;private,list,method,get,annotated,methods,class,clazz,class,extends,annotation,annotation,type,list,method,results,new,array,list,method,for,class,current,get,super,classes,clazz,for,method,method,current,get,declared,methods,annotation,annotation,get,annotation,method,annotation,type,if,annotation,null,is,shadowed,method,results,results,add,method,return,results
TransactionalTestExecutionListener -> private List<Method> getAnnotatedMethods(Class<?> clazz, Class<? extends Annotation> annotationType);1458754760;Gets all methods in the supplied {@link Class class} and its superclasses_which are annotated with the supplied {@code annotationType} but_which are not <em>shadowed</em> by methods overridden in subclasses._<p>Note: This code has been borrowed from_{@link org.junit.internal.runners.TestClass#getAnnotatedMethods(Class)}_and adapted._@param clazz the class for which to retrieve the annotated methods_@param annotationType the annotation type for which to search_@return all annotated methods in the supplied class and its superclasses;private List<Method> getAnnotatedMethods(Class<?> clazz, Class<? extends Annotation> annotationType) {_		List<Method> results = new ArrayList<Method>()__		for (Class<?> current : getSuperClasses(clazz)) {_			for (Method method : current.getDeclaredMethods()) {_				Annotation annotation = AnnotationUtils.getAnnotation(method, annotationType)__				if (annotation != null && !isShadowed(method, results)) {_					results.add(method)__				}_			}_		}_		return results__	};gets,all,methods,in,the,supplied,link,class,class,and,its,superclasses,which,are,annotated,with,the,supplied,code,annotation,type,but,which,are,not,em,shadowed,em,by,methods,overridden,in,subclasses,p,note,this,code,has,been,borrowed,from,link,org,junit,internal,runners,test,class,get,annotated,methods,class,and,adapted,param,clazz,the,class,for,which,to,retrieve,the,annotated,methods,param,annotation,type,the,annotation,type,for,which,to,search,return,all,annotated,methods,in,the,supplied,class,and,its,superclasses;private,list,method,get,annotated,methods,class,clazz,class,extends,annotation,annotation,type,list,method,results,new,array,list,method,for,class,current,get,super,classes,clazz,for,method,method,current,get,declared,methods,annotation,annotation,annotation,utils,get,annotation,method,annotation,type,if,annotation,null,is,shadowed,method,results,results,add,method,return,results
TransactionalTestExecutionListener -> private List<Method> getAnnotatedMethods(Class<?> clazz, Class<? extends Annotation> annotationType);1462294651;Get all methods in the supplied {@link Class class} and its superclasses_which are annotated with the supplied {@code annotationType} but_which are not <em>shadowed</em> by methods overridden in subclasses._<p>Default methods on interfaces are also detected._@param clazz the class for which to retrieve the annotated methods_@param annotationType the annotation type for which to search_@return all annotated methods in the supplied class and its superclasses_as well as annotated interface default methods;private List<Method> getAnnotatedMethods(Class<?> clazz, Class<? extends Annotation> annotationType) {_		List<Method> methods = new ArrayList<Method>(4)__		for (Method method : ReflectionUtils.getUniqueDeclaredMethods(clazz)) {_			if (AnnotationUtils.getAnnotation(method, annotationType) != null) {_				methods.add(method)__			}_		}_		return methods__	};get,all,methods,in,the,supplied,link,class,class,and,its,superclasses,which,are,annotated,with,the,supplied,code,annotation,type,but,which,are,not,em,shadowed,em,by,methods,overridden,in,subclasses,p,default,methods,on,interfaces,are,also,detected,param,clazz,the,class,for,which,to,retrieve,the,annotated,methods,param,annotation,type,the,annotation,type,for,which,to,search,return,all,annotated,methods,in,the,supplied,class,and,its,superclasses,as,well,as,annotated,interface,default,methods;private,list,method,get,annotated,methods,class,clazz,class,extends,annotation,annotation,type,list,method,methods,new,array,list,method,4,for,method,method,reflection,utils,get,unique,declared,methods,clazz,if,annotation,utils,get,annotation,method,annotation,type,null,methods,add,method,return,methods
TransactionalTestExecutionListener -> private List<Method> getAnnotatedMethods(Class<?> clazz, Class<? extends Annotation> annotationType);1462299971;Get all methods in the supplied {@link Class class} and its superclasses_which are annotated with the supplied {@code annotationType} but_which are not <em>shadowed</em> by methods overridden in subclasses._<p>Default methods on interfaces are also detected._@param clazz the class for which to retrieve the annotated methods_@param annotationType the annotation type for which to search_@return all annotated methods in the supplied class and its superclasses_as well as annotated interface default methods;private List<Method> getAnnotatedMethods(Class<?> clazz, Class<? extends Annotation> annotationType) {_		List<Method> methods = new ArrayList<Method>(4)__		for (Method method : ReflectionUtils.getUniqueDeclaredMethods(clazz)) {_			if (AnnotationUtils.getAnnotation(method, annotationType) != null) {_				methods.add(method)__			}_		}_		return methods__	};get,all,methods,in,the,supplied,link,class,class,and,its,superclasses,which,are,annotated,with,the,supplied,code,annotation,type,but,which,are,not,em,shadowed,em,by,methods,overridden,in,subclasses,p,default,methods,on,interfaces,are,also,detected,param,clazz,the,class,for,which,to,retrieve,the,annotated,methods,param,annotation,type,the,annotation,type,for,which,to,search,return,all,annotated,methods,in,the,supplied,class,and,its,superclasses,as,well,as,annotated,interface,default,methods;private,list,method,get,annotated,methods,class,clazz,class,extends,annotation,annotation,type,list,method,methods,new,array,list,method,4,for,method,method,reflection,utils,get,unique,declared,methods,clazz,if,annotation,utils,get,annotation,method,annotation,type,null,methods,add,method,return,methods
TransactionalTestExecutionListener -> private List<Method> getAnnotatedMethods(Class<?> clazz, Class<? extends Annotation> annotationType);1467730834;Get all methods in the supplied {@link Class class} and its superclasses_which are annotated with the supplied {@code annotationType} but_which are not <em>shadowed</em> by methods overridden in subclasses._<p>Default methods on interfaces are also detected._@param clazz the class for which to retrieve the annotated methods_@param annotationType the annotation type for which to search_@return all annotated methods in the supplied class and its superclasses_as well as annotated interface default methods;private List<Method> getAnnotatedMethods(Class<?> clazz, Class<? extends Annotation> annotationType) {_		List<Method> methods = new ArrayList<>(4)__		for (Method method : ReflectionUtils.getUniqueDeclaredMethods(clazz)) {_			if (AnnotationUtils.getAnnotation(method, annotationType) != null) {_				methods.add(method)__			}_		}_		return methods__	};get,all,methods,in,the,supplied,link,class,class,and,its,superclasses,which,are,annotated,with,the,supplied,code,annotation,type,but,which,are,not,em,shadowed,em,by,methods,overridden,in,subclasses,p,default,methods,on,interfaces,are,also,detected,param,clazz,the,class,for,which,to,retrieve,the,annotated,methods,param,annotation,type,the,annotation,type,for,which,to,search,return,all,annotated,methods,in,the,supplied,class,and,its,superclasses,as,well,as,annotated,interface,default,methods;private,list,method,get,annotated,methods,class,clazz,class,extends,annotation,annotation,type,list,method,methods,new,array,list,4,for,method,method,reflection,utils,get,unique,declared,methods,clazz,if,annotation,utils,get,annotation,method,annotation,type,null,methods,add,method,return,methods
TransactionalTestExecutionListener -> private List<Method> getAnnotatedMethods(Class<?> clazz, Class<? extends Annotation> annotationType);1467992320;Get all methods in the supplied {@link Class class} and its superclasses_which are annotated with the supplied {@code annotationType} but_which are not <em>shadowed</em> by methods overridden in subclasses._<p>Default methods on interfaces are also detected._@param clazz the class for which to retrieve the annotated methods_@param annotationType the annotation type for which to search_@return all annotated methods in the supplied class and its superclasses_as well as annotated interface default methods;private List<Method> getAnnotatedMethods(Class<?> clazz, Class<? extends Annotation> annotationType) {_		return Arrays.stream(ReflectionUtils.getUniqueDeclaredMethods(clazz))_				.filter(method -> AnnotatedElementUtils.hasAnnotation(method, annotationType))_				.collect(Collectors.toList())__	};get,all,methods,in,the,supplied,link,class,class,and,its,superclasses,which,are,annotated,with,the,supplied,code,annotation,type,but,which,are,not,em,shadowed,em,by,methods,overridden,in,subclasses,p,default,methods,on,interfaces,are,also,detected,param,clazz,the,class,for,which,to,retrieve,the,annotated,methods,param,annotation,type,the,annotation,type,for,which,to,search,return,all,annotated,methods,in,the,supplied,class,and,its,superclasses,as,well,as,annotated,interface,default,methods;private,list,method,get,annotated,methods,class,clazz,class,extends,annotation,annotation,type,return,arrays,stream,reflection,utils,get,unique,declared,methods,clazz,filter,method,annotated,element,utils,has,annotation,method,annotation,type,collect,collectors,to,list
TransactionalTestExecutionListener -> private List<Method> getAnnotatedMethods(Class<?> clazz, Class<? extends Annotation> annotationType);1467992442;Get all methods in the supplied {@link Class class} and its superclasses_which are annotated with the supplied {@code annotationType} but_which are not <em>shadowed</em> by methods overridden in subclasses._<p>Default methods on interfaces are also detected._@param clazz the class for which to retrieve the annotated methods_@param annotationType the annotation type for which to search_@return all annotated methods in the supplied class and its superclasses_as well as annotated interface default methods;private List<Method> getAnnotatedMethods(Class<?> clazz, Class<? extends Annotation> annotationType) {_		return Arrays.stream(ReflectionUtils.getUniqueDeclaredMethods(clazz))_				.filter(method -> AnnotatedElementUtils.hasAnnotation(method, annotationType))_				.collect(Collectors.toList())__	};get,all,methods,in,the,supplied,link,class,class,and,its,superclasses,which,are,annotated,with,the,supplied,code,annotation,type,but,which,are,not,em,shadowed,em,by,methods,overridden,in,subclasses,p,default,methods,on,interfaces,are,also,detected,param,clazz,the,class,for,which,to,retrieve,the,annotated,methods,param,annotation,type,the,annotation,type,for,which,to,search,return,all,annotated,methods,in,the,supplied,class,and,its,superclasses,as,well,as,annotated,interface,default,methods;private,list,method,get,annotated,methods,class,clazz,class,extends,annotation,annotation,type,return,arrays,stream,reflection,utils,get,unique,declared,methods,clazz,filter,method,annotated,element,utils,has,annotation,method,annotation,type,collect,collectors,to,list
TransactionalTestExecutionListener -> private List<Method> getAnnotatedMethods(Class<?> clazz, Class<? extends Annotation> annotationType);1467994604;Get all methods in the supplied {@link Class class} and its superclasses_which are annotated with the supplied {@code annotationType} but_which are not <em>shadowed</em> by methods overridden in subclasses._<p>Default methods on interfaces are also detected._@param clazz the class for which to retrieve the annotated methods_@param annotationType the annotation type for which to search_@return all annotated methods in the supplied class and its superclasses_as well as annotated interface default methods;private List<Method> getAnnotatedMethods(Class<?> clazz, Class<? extends Annotation> annotationType) {_		return Arrays.stream(ReflectionUtils.getUniqueDeclaredMethods(clazz))_				.filter(method -> AnnotatedElementUtils.hasAnnotation(method, annotationType))_				.collect(Collectors.toList())__	};get,all,methods,in,the,supplied,link,class,class,and,its,superclasses,which,are,annotated,with,the,supplied,code,annotation,type,but,which,are,not,em,shadowed,em,by,methods,overridden,in,subclasses,p,default,methods,on,interfaces,are,also,detected,param,clazz,the,class,for,which,to,retrieve,the,annotated,methods,param,annotation,type,the,annotation,type,for,which,to,search,return,all,annotated,methods,in,the,supplied,class,and,its,superclasses,as,well,as,annotated,interface,default,methods;private,list,method,get,annotated,methods,class,clazz,class,extends,annotation,annotation,type,return,arrays,stream,reflection,utils,get,unique,declared,methods,clazz,filter,method,annotated,element,utils,has,annotation,method,annotation,type,collect,collectors,to,list
TransactionalTestExecutionListener -> private List<Method> getAnnotatedMethods(Class<?> clazz, Class<? extends Annotation> annotationType);1468334463;Get all methods in the supplied {@link Class class} and its superclasses_which are annotated with the supplied {@code annotationType} but_which are not <em>shadowed</em> by methods overridden in subclasses._<p>Default methods on interfaces are also detected._@param clazz the class for which to retrieve the annotated methods_@param annotationType the annotation type for which to search_@return all annotated methods in the supplied class and its superclasses_as well as annotated interface default methods;private List<Method> getAnnotatedMethods(Class<?> clazz, Class<? extends Annotation> annotationType) {_		return Arrays.stream(ReflectionUtils.getUniqueDeclaredMethods(clazz))_				.filter(method -> AnnotatedElementUtils.hasAnnotation(method, annotationType))_				.collect(Collectors.toList())__	};get,all,methods,in,the,supplied,link,class,class,and,its,superclasses,which,are,annotated,with,the,supplied,code,annotation,type,but,which,are,not,em,shadowed,em,by,methods,overridden,in,subclasses,p,default,methods,on,interfaces,are,also,detected,param,clazz,the,class,for,which,to,retrieve,the,annotated,methods,param,annotation,type,the,annotation,type,for,which,to,search,return,all,annotated,methods,in,the,supplied,class,and,its,superclasses,as,well,as,annotated,interface,default,methods;private,list,method,get,annotated,methods,class,clazz,class,extends,annotation,annotation,type,return,arrays,stream,reflection,utils,get,unique,declared,methods,clazz,filter,method,annotated,element,utils,has,annotation,method,annotation,type,collect,collectors,to,list
TransactionalTestExecutionListener -> private List<Method> getAnnotatedMethods(Class<?> clazz, Class<? extends Annotation> annotationType);1496955179;Get all methods in the supplied {@link Class class} and its superclasses_which are annotated with the supplied {@code annotationType} but_which are not <em>shadowed</em> by methods overridden in subclasses._<p>Default methods on interfaces are also detected._@param clazz the class for which to retrieve the annotated methods_@param annotationType the annotation type for which to search_@return all annotated methods in the supplied class and its superclasses_as well as annotated interface default methods;private List<Method> getAnnotatedMethods(Class<?> clazz, Class<? extends Annotation> annotationType) {_		return Arrays.stream(ReflectionUtils.getUniqueDeclaredMethods(clazz))_				.filter(method -> AnnotatedElementUtils.hasAnnotation(method, annotationType))_				.collect(Collectors.toList())__	};get,all,methods,in,the,supplied,link,class,class,and,its,superclasses,which,are,annotated,with,the,supplied,code,annotation,type,but,which,are,not,em,shadowed,em,by,methods,overridden,in,subclasses,p,default,methods,on,interfaces,are,also,detected,param,clazz,the,class,for,which,to,retrieve,the,annotated,methods,param,annotation,type,the,annotation,type,for,which,to,search,return,all,annotated,methods,in,the,supplied,class,and,its,superclasses,as,well,as,annotated,interface,default,methods;private,list,method,get,annotated,methods,class,clazz,class,extends,annotation,annotation,type,return,arrays,stream,reflection,utils,get,unique,declared,methods,clazz,filter,method,annotated,element,utils,has,annotation,method,annotation,type,collect,collectors,to,list
TransactionalTestExecutionListener -> private List<Method> getAnnotatedMethods(Class<?> clazz, Class<? extends Annotation> annotationType);1498780456;Get all methods in the supplied {@link Class class} and its superclasses_which are annotated with the supplied {@code annotationType} but_which are not <em>shadowed</em> by methods overridden in subclasses._<p>Default methods on interfaces are also detected._@param clazz the class for which to retrieve the annotated methods_@param annotationType the annotation type for which to search_@return all annotated methods in the supplied class and its superclasses_as well as annotated interface default methods;private List<Method> getAnnotatedMethods(Class<?> clazz, Class<? extends Annotation> annotationType) {_		return Arrays.stream(ReflectionUtils.getUniqueDeclaredMethods(clazz))_				.filter(method -> AnnotatedElementUtils.hasAnnotation(method, annotationType))_				.collect(Collectors.toList())__	};get,all,methods,in,the,supplied,link,class,class,and,its,superclasses,which,are,annotated,with,the,supplied,code,annotation,type,but,which,are,not,em,shadowed,em,by,methods,overridden,in,subclasses,p,default,methods,on,interfaces,are,also,detected,param,clazz,the,class,for,which,to,retrieve,the,annotated,methods,param,annotation,type,the,annotation,type,for,which,to,search,return,all,annotated,methods,in,the,supplied,class,and,its,superclasses,as,well,as,annotated,interface,default,methods;private,list,method,get,annotated,methods,class,clazz,class,extends,annotation,annotation,type,return,arrays,stream,reflection,utils,get,unique,declared,methods,clazz,filter,method,annotated,element,utils,has,annotation,method,annotation,type,collect,collectors,to,list
TransactionalTestExecutionListener -> private List<Method> getAnnotatedMethods(Class<?> clazz, Class<? extends Annotation> annotationType);1520251235;Get all methods in the supplied {@link Class class} and its superclasses_which are annotated with the supplied {@code annotationType} but_which are not <em>shadowed</em> by methods overridden in subclasses._<p>Default methods on interfaces are also detected._@param clazz the class for which to retrieve the annotated methods_@param annotationType the annotation type for which to search_@return all annotated methods in the supplied class and its superclasses_as well as annotated interface default methods;private List<Method> getAnnotatedMethods(Class<?> clazz, Class<? extends Annotation> annotationType) {_		return Arrays.stream(ReflectionUtils.getUniqueDeclaredMethods(clazz))_				.filter(method -> AnnotatedElementUtils.hasAnnotation(method, annotationType))_				.collect(Collectors.toList())__	};get,all,methods,in,the,supplied,link,class,class,and,its,superclasses,which,are,annotated,with,the,supplied,code,annotation,type,but,which,are,not,em,shadowed,em,by,methods,overridden,in,subclasses,p,default,methods,on,interfaces,are,also,detected,param,clazz,the,class,for,which,to,retrieve,the,annotated,methods,param,annotation,type,the,annotation,type,for,which,to,search,return,all,annotated,methods,in,the,supplied,class,and,its,superclasses,as,well,as,annotated,interface,default,methods;private,list,method,get,annotated,methods,class,clazz,class,extends,annotation,annotation,type,return,arrays,stream,reflection,utils,get,unique,declared,methods,clazz,filter,method,annotated,element,utils,has,annotation,method,annotation,type,collect,collectors,to,list
TransactionalTestExecutionListener -> @Override 	public final int getOrder();1408048216;Returns {@code 4000}.;@Override_	public final int getOrder() {_		return 4000__	};returns,code,4000;override,public,final,int,get,order,return,4000
TransactionalTestExecutionListener -> @Override 	public final int getOrder();1413848647;Returns {@code 4000}.;@Override_	public final int getOrder() {_		return 4000__	};returns,code,4000;override,public,final,int,get,order,return,4000
TransactionalTestExecutionListener -> @Override 	public final int getOrder();1431568199;Returns {@code 4000}.;@Override_	public final int getOrder() {_		return 4000__	};returns,code,4000;override,public,final,int,get,order,return,4000
TransactionalTestExecutionListener -> @Override 	public final int getOrder();1432125256;Returns {@code 4000}.;@Override_	public final int getOrder() {_		return 4000__	};returns,code,4000;override,public,final,int,get,order,return,4000
TransactionalTestExecutionListener -> @Override 	public final int getOrder();1432856630;Returns {@code 4000}.;@Override_	public final int getOrder() {_		return 4000__	};returns,code,4000;override,public,final,int,get,order,return,4000
TransactionalTestExecutionListener -> @Override 	public final int getOrder();1434234880;Returns {@code 4000}.;@Override_	public final int getOrder() {_		return 4000__	};returns,code,4000;override,public,final,int,get,order,return,4000
TransactionalTestExecutionListener -> @Override 	public final int getOrder();1434720443;Returns {@code 4000}.;@Override_	public final int getOrder() {_		return 4000__	};returns,code,4000;override,public,final,int,get,order,return,4000
TransactionalTestExecutionListener -> @Override 	public final int getOrder();1434817656;Returns {@code 4000}.;@Override_	public final int getOrder() {_		return 4000__	};returns,code,4000;override,public,final,int,get,order,return,4000
TransactionalTestExecutionListener -> @Override 	public final int getOrder();1437841346;Returns {@code 4000}.;@Override_	public final int getOrder() {_		return 4000__	};returns,code,4000;override,public,final,int,get,order,return,4000
TransactionalTestExecutionListener -> @Override 	public final int getOrder();1437851372;Returns {@code 4000}.;@Override_	public final int getOrder() {_		return 4000__	};returns,code,4000;override,public,final,int,get,order,return,4000
TransactionalTestExecutionListener -> @Override 	public final int getOrder();1437852597;Returns {@code 4000}.;@Override_	public final int getOrder() {_		return 4000__	};returns,code,4000;override,public,final,int,get,order,return,4000
TransactionalTestExecutionListener -> @Override 	public final int getOrder();1454507787;Returns {@code 4000}.;@Override_	public final int getOrder() {_		return 4000__	};returns,code,4000;override,public,final,int,get,order,return,4000
TransactionalTestExecutionListener -> @Override 	public final int getOrder();1456702967;Returns {@code 4000}.;@Override_	public final int getOrder() {_		return 4000__	};returns,code,4000;override,public,final,int,get,order,return,4000
TransactionalTestExecutionListener -> @Override 	public final int getOrder();1456756222;Returns {@code 4000}.;@Override_	public final int getOrder() {_		return 4000__	};returns,code,4000;override,public,final,int,get,order,return,4000
TransactionalTestExecutionListener -> @Override 	public final int getOrder();1456756222;Returns {@code 4000}.;@Override_	public final int getOrder() {_		return 4000__	};returns,code,4000;override,public,final,int,get,order,return,4000
TransactionalTestExecutionListener -> @Override 	public final int getOrder();1458754760;Returns {@code 4000}.;@Override_	public final int getOrder() {_		return 4000__	};returns,code,4000;override,public,final,int,get,order,return,4000
TransactionalTestExecutionListener -> @Override 	public final int getOrder();1462294651;Returns {@code 4000}.;@Override_	public final int getOrder() {_		return 4000__	};returns,code,4000;override,public,final,int,get,order,return,4000
TransactionalTestExecutionListener -> @Override 	public final int getOrder();1462299971;Returns {@code 4000}.;@Override_	public final int getOrder() {_		return 4000__	};returns,code,4000;override,public,final,int,get,order,return,4000
TransactionalTestExecutionListener -> @Override 	public final int getOrder();1467730834;Returns {@code 4000}.;@Override_	public final int getOrder() {_		return 4000__	};returns,code,4000;override,public,final,int,get,order,return,4000
TransactionalTestExecutionListener -> @Override 	public final int getOrder();1467992320;Returns {@code 4000}.;@Override_	public final int getOrder() {_		return 4000__	};returns,code,4000;override,public,final,int,get,order,return,4000
TransactionalTestExecutionListener -> @Override 	public final int getOrder();1467992442;Returns {@code 4000}.;@Override_	public final int getOrder() {_		return 4000__	};returns,code,4000;override,public,final,int,get,order,return,4000
TransactionalTestExecutionListener -> @Override 	public final int getOrder();1467994604;Returns {@code 4000}.;@Override_	public final int getOrder() {_		return 4000__	};returns,code,4000;override,public,final,int,get,order,return,4000
TransactionalTestExecutionListener -> @Override 	public final int getOrder();1468334463;Returns {@code 4000}.;@Override_	public final int getOrder() {_		return 4000__	};returns,code,4000;override,public,final,int,get,order,return,4000
TransactionalTestExecutionListener -> @Override 	public final int getOrder();1496955179;Returns {@code 4000}.;@Override_	public final int getOrder() {_		return 4000__	};returns,code,4000;override,public,final,int,get,order,return,4000
TransactionalTestExecutionListener -> @Override 	public final int getOrder();1498780456;Returns {@code 4000}.;@Override_	public final int getOrder() {_		return 4000__	};returns,code,4000;override,public,final,int,get,order,return,4000
TransactionalTestExecutionListener -> @Override 	public final int getOrder();1520251235;Returns {@code 4000}.;@Override_	public final int getOrder() {_		return 4000__	};returns,code,4000;override,public,final,int,get,order,return,4000
TransactionalTestExecutionListener -> @SuppressWarnings("deprecation") 	protected final boolean isDefaultRollback(TestContext testContext) throws Exception;1437852597;Determine whether or not to rollback transactions by default for the_supplied {@linkplain TestContext test context}._<p>Supports {@link Rollback @Rollback} or_{@link TransactionConfiguration @TransactionConfiguration} at the_class-level._@param testContext the test context for which the default rollback flag_should be retrieved_@return the <em>default rollback</em> flag for the supplied test context_@throws Exception if an error occurs while determining the default rollback flag;@SuppressWarnings("deprecation")_	protected final boolean isDefaultRollback(TestContext testContext) throws Exception {_		Class<?> testClass = testContext.getTestClass()__		Rollback rollback = findAnnotation(testClass, Rollback.class)__		boolean rollbackPresent = (rollback != null)__		TransactionConfigurationAttributes txConfigAttributes = retrieveConfigurationAttributes(testContext)___		if (rollbackPresent && txConfigAttributes != defaultTxConfigAttributes) {_			throw new IllegalStateException(String.format("Test class [%s] is annotated with both @Rollback "_					+ "and @TransactionConfiguration, but only one is permitted.", testClass.getName()))__		}__		if (rollbackPresent) {_			boolean defaultRollback = rollback.value()__			if (logger.isDebugEnabled()) {_				logger.debug(String.format("Retrieved default @Rollback(%s) for test class [%s].", defaultRollback,_					testClass.getName()))__			}_			return defaultRollback__		}__		_		return txConfigAttributes.isDefaultRollback()__	};determine,whether,or,not,to,rollback,transactions,by,default,for,the,supplied,linkplain,test,context,test,context,p,supports,link,rollback,rollback,or,link,transaction,configuration,transaction,configuration,at,the,class,level,param,test,context,the,test,context,for,which,the,default,rollback,flag,should,be,retrieved,return,the,em,default,rollback,em,flag,for,the,supplied,test,context,throws,exception,if,an,error,occurs,while,determining,the,default,rollback,flag;suppress,warnings,deprecation,protected,final,boolean,is,default,rollback,test,context,test,context,throws,exception,class,test,class,test,context,get,test,class,rollback,rollback,find,annotation,test,class,rollback,class,boolean,rollback,present,rollback,null,transaction,configuration,attributes,tx,config,attributes,retrieve,configuration,attributes,test,context,if,rollback,present,tx,config,attributes,default,tx,config,attributes,throw,new,illegal,state,exception,string,format,test,class,s,is,annotated,with,both,rollback,and,transaction,configuration,but,only,one,is,permitted,test,class,get,name,if,rollback,present,boolean,default,rollback,rollback,value,if,logger,is,debug,enabled,logger,debug,string,format,retrieved,default,rollback,s,for,test,class,s,default,rollback,test,class,get,name,return,default,rollback,return,tx,config,attributes,is,default,rollback
TransactionalTestExecutionListener -> @SuppressWarnings("deprecation") 	protected final boolean isDefaultRollback(TestContext testContext) throws Exception;1454507787;Determine whether or not to rollback transactions by default for the_supplied {@linkplain TestContext test context}._<p>Supports {@link Rollback @Rollback} or_{@link TransactionConfiguration @TransactionConfiguration} at the_class-level._@param testContext the test context for which the default rollback flag_should be retrieved_@return the <em>default rollback</em> flag for the supplied test context_@throws Exception if an error occurs while determining the default rollback flag;@SuppressWarnings("deprecation")_	protected final boolean isDefaultRollback(TestContext testContext) throws Exception {_		Class<?> testClass = testContext.getTestClass()__		Rollback rollback = findAnnotation(testClass, Rollback.class)__		boolean rollbackPresent = (rollback != null)__		TransactionConfigurationAttributes txConfigAttributes = retrieveConfigurationAttributes(testContext)___		if (rollbackPresent && txConfigAttributes != defaultTxConfigAttributes) {_			throw new IllegalStateException(String.format("Test class [%s] is annotated with both @Rollback "_					+ "and @TransactionConfiguration, but only one is permitted.", testClass.getName()))__		}__		if (rollbackPresent) {_			boolean defaultRollback = rollback.value()__			if (logger.isDebugEnabled()) {_				logger.debug(String.format("Retrieved default @Rollback(%s) for test class [%s].", defaultRollback,_					testClass.getName()))__			}_			return defaultRollback__		}__		_		return txConfigAttributes.isDefaultRollback()__	};determine,whether,or,not,to,rollback,transactions,by,default,for,the,supplied,linkplain,test,context,test,context,p,supports,link,rollback,rollback,or,link,transaction,configuration,transaction,configuration,at,the,class,level,param,test,context,the,test,context,for,which,the,default,rollback,flag,should,be,retrieved,return,the,em,default,rollback,em,flag,for,the,supplied,test,context,throws,exception,if,an,error,occurs,while,determining,the,default,rollback,flag;suppress,warnings,deprecation,protected,final,boolean,is,default,rollback,test,context,test,context,throws,exception,class,test,class,test,context,get,test,class,rollback,rollback,find,annotation,test,class,rollback,class,boolean,rollback,present,rollback,null,transaction,configuration,attributes,tx,config,attributes,retrieve,configuration,attributes,test,context,if,rollback,present,tx,config,attributes,default,tx,config,attributes,throw,new,illegal,state,exception,string,format,test,class,s,is,annotated,with,both,rollback,and,transaction,configuration,but,only,one,is,permitted,test,class,get,name,if,rollback,present,boolean,default,rollback,rollback,value,if,logger,is,debug,enabled,logger,debug,string,format,retrieved,default,rollback,s,for,test,class,s,default,rollback,test,class,get,name,return,default,rollback,return,tx,config,attributes,is,default,rollback
TransactionalTestExecutionListener -> @SuppressWarnings("deprecation") 	protected final boolean isDefaultRollback(TestContext testContext) throws Exception;1456702967;Determine whether or not to rollback transactions by default for the_supplied {@linkplain TestContext test context}._<p>Supports {@link Rollback @Rollback} or_{@link TransactionConfiguration @TransactionConfiguration} at the_class-level._@param testContext the test context for which the default rollback flag_should be retrieved_@return the <em>default rollback</em> flag for the supplied test context_@throws Exception if an error occurs while determining the default rollback flag;@SuppressWarnings("deprecation")_	protected final boolean isDefaultRollback(TestContext testContext) throws Exception {_		Class<?> testClass = testContext.getTestClass()__		Rollback rollback = findAnnotation(testClass, Rollback.class)__		boolean rollbackPresent = (rollback != null)__		TransactionConfigurationAttributes txConfigAttributes = retrieveConfigurationAttributes(testContext)___		if (rollbackPresent && txConfigAttributes != defaultTxConfigAttributes) {_			throw new IllegalStateException(String.format("Test class [%s] is annotated with both @Rollback "_					+ "and @TransactionConfiguration, but only one is permitted.", testClass.getName()))__		}__		if (rollbackPresent) {_			boolean defaultRollback = rollback.value()__			if (logger.isDebugEnabled()) {_				logger.debug(String.format("Retrieved default @Rollback(%s) for test class [%s].", defaultRollback,_					testClass.getName()))__			}_			return defaultRollback__		}__		_		return txConfigAttributes.isDefaultRollback()__	};determine,whether,or,not,to,rollback,transactions,by,default,for,the,supplied,linkplain,test,context,test,context,p,supports,link,rollback,rollback,or,link,transaction,configuration,transaction,configuration,at,the,class,level,param,test,context,the,test,context,for,which,the,default,rollback,flag,should,be,retrieved,return,the,em,default,rollback,em,flag,for,the,supplied,test,context,throws,exception,if,an,error,occurs,while,determining,the,default,rollback,flag;suppress,warnings,deprecation,protected,final,boolean,is,default,rollback,test,context,test,context,throws,exception,class,test,class,test,context,get,test,class,rollback,rollback,find,annotation,test,class,rollback,class,boolean,rollback,present,rollback,null,transaction,configuration,attributes,tx,config,attributes,retrieve,configuration,attributes,test,context,if,rollback,present,tx,config,attributes,default,tx,config,attributes,throw,new,illegal,state,exception,string,format,test,class,s,is,annotated,with,both,rollback,and,transaction,configuration,but,only,one,is,permitted,test,class,get,name,if,rollback,present,boolean,default,rollback,rollback,value,if,logger,is,debug,enabled,logger,debug,string,format,retrieved,default,rollback,s,for,test,class,s,default,rollback,test,class,get,name,return,default,rollback,return,tx,config,attributes,is,default,rollback
TransactionalTestExecutionListener -> @SuppressWarnings("deprecation") 	protected final boolean isDefaultRollback(TestContext testContext) throws Exception;1456756222;Determine whether or not to rollback transactions by default for the_supplied {@linkplain TestContext test context}._<p>Supports {@link Rollback @Rollback} or_{@link TransactionConfiguration @TransactionConfiguration} at the_class-level._@param testContext the test context for which the default rollback flag_should be retrieved_@return the <em>default rollback</em> flag for the supplied test context_@throws Exception if an error occurs while determining the default rollback flag;@SuppressWarnings("deprecation")_	protected final boolean isDefaultRollback(TestContext testContext) throws Exception {_		Class<?> testClass = testContext.getTestClass()__		Rollback rollback = findAnnotation(testClass, Rollback.class)__		boolean rollbackPresent = (rollback != null)__		TransactionConfigurationAttributes txConfigAttributes = retrieveConfigurationAttributes(testContext)___		if (rollbackPresent && txConfigAttributes != defaultTxConfigAttributes) {_			throw new IllegalStateException(String.format("Test class [%s] is annotated with both @Rollback "_					+ "and @TransactionConfiguration, but only one is permitted.", testClass.getName()))__		}__		if (rollbackPresent) {_			boolean defaultRollback = rollback.value()__			if (logger.isDebugEnabled()) {_				logger.debug(String.format("Retrieved default @Rollback(%s) for test class [%s].", defaultRollback,_					testClass.getName()))__			}_			return defaultRollback__		}__		_		return txConfigAttributes.isDefaultRollback()__	};determine,whether,or,not,to,rollback,transactions,by,default,for,the,supplied,linkplain,test,context,test,context,p,supports,link,rollback,rollback,or,link,transaction,configuration,transaction,configuration,at,the,class,level,param,test,context,the,test,context,for,which,the,default,rollback,flag,should,be,retrieved,return,the,em,default,rollback,em,flag,for,the,supplied,test,context,throws,exception,if,an,error,occurs,while,determining,the,default,rollback,flag;suppress,warnings,deprecation,protected,final,boolean,is,default,rollback,test,context,test,context,throws,exception,class,test,class,test,context,get,test,class,rollback,rollback,find,annotation,test,class,rollback,class,boolean,rollback,present,rollback,null,transaction,configuration,attributes,tx,config,attributes,retrieve,configuration,attributes,test,context,if,rollback,present,tx,config,attributes,default,tx,config,attributes,throw,new,illegal,state,exception,string,format,test,class,s,is,annotated,with,both,rollback,and,transaction,configuration,but,only,one,is,permitted,test,class,get,name,if,rollback,present,boolean,default,rollback,rollback,value,if,logger,is,debug,enabled,logger,debug,string,format,retrieved,default,rollback,s,for,test,class,s,default,rollback,test,class,get,name,return,default,rollback,return,tx,config,attributes,is,default,rollback
TransactionalTestExecutionListener -> @SuppressWarnings("deprecation") 	protected final boolean isDefaultRollback(TestContext testContext) throws Exception;1456756222;Determine whether or not to rollback transactions by default for the_supplied {@linkplain TestContext test context}._<p>Supports {@link Rollback @Rollback} or_{@link TransactionConfiguration @TransactionConfiguration} at the_class-level._@param testContext the test context for which the default rollback flag_should be retrieved_@return the <em>default rollback</em> flag for the supplied test context_@throws Exception if an error occurs while determining the default rollback flag;@SuppressWarnings("deprecation")_	protected final boolean isDefaultRollback(TestContext testContext) throws Exception {_		Class<?> testClass = testContext.getTestClass()__		Rollback rollback = findAnnotation(testClass, Rollback.class)__		boolean rollbackPresent = (rollback != null)__		TransactionConfigurationAttributes txConfigAttributes = retrieveConfigurationAttributes(testContext)___		if (rollbackPresent && txConfigAttributes != defaultTxConfigAttributes) {_			throw new IllegalStateException(String.format("Test class [%s] is annotated with both @Rollback "_					+ "and @TransactionConfiguration, but only one is permitted.", testClass.getName()))__		}__		if (rollbackPresent) {_			boolean defaultRollback = rollback.value()__			if (logger.isDebugEnabled()) {_				logger.debug(String.format("Retrieved default @Rollback(%s) for test class [%s].", defaultRollback,_					testClass.getName()))__			}_			return defaultRollback__		}__		_		return txConfigAttributes.isDefaultRollback()__	};determine,whether,or,not,to,rollback,transactions,by,default,for,the,supplied,linkplain,test,context,test,context,p,supports,link,rollback,rollback,or,link,transaction,configuration,transaction,configuration,at,the,class,level,param,test,context,the,test,context,for,which,the,default,rollback,flag,should,be,retrieved,return,the,em,default,rollback,em,flag,for,the,supplied,test,context,throws,exception,if,an,error,occurs,while,determining,the,default,rollback,flag;suppress,warnings,deprecation,protected,final,boolean,is,default,rollback,test,context,test,context,throws,exception,class,test,class,test,context,get,test,class,rollback,rollback,find,annotation,test,class,rollback,class,boolean,rollback,present,rollback,null,transaction,configuration,attributes,tx,config,attributes,retrieve,configuration,attributes,test,context,if,rollback,present,tx,config,attributes,default,tx,config,attributes,throw,new,illegal,state,exception,string,format,test,class,s,is,annotated,with,both,rollback,and,transaction,configuration,but,only,one,is,permitted,test,class,get,name,if,rollback,present,boolean,default,rollback,rollback,value,if,logger,is,debug,enabled,logger,debug,string,format,retrieved,default,rollback,s,for,test,class,s,default,rollback,test,class,get,name,return,default,rollback,return,tx,config,attributes,is,default,rollback
TransactionalTestExecutionListener -> @SuppressWarnings("deprecation") 	protected final boolean isDefaultRollback(TestContext testContext) throws Exception;1458754760;Determine whether or not to rollback transactions by default for the_supplied {@linkplain TestContext test context}._<p>Supports {@link Rollback @Rollback} or_{@link TransactionConfiguration @TransactionConfiguration} at the_class-level._@param testContext the test context for which the default rollback flag_should be retrieved_@return the <em>default rollback</em> flag for the supplied test context_@throws Exception if an error occurs while determining the default rollback flag;@SuppressWarnings("deprecation")_	protected final boolean isDefaultRollback(TestContext testContext) throws Exception {_		Class<?> testClass = testContext.getTestClass()__		Rollback rollback = AnnotatedElementUtils.findMergedAnnotation(testClass, Rollback.class)__		boolean rollbackPresent = (rollback != null)__		TransactionConfigurationAttributes txConfigAttributes = retrieveConfigurationAttributes(testContext)___		if (rollbackPresent && txConfigAttributes != defaultTxConfigAttributes) {_			throw new IllegalStateException(String.format("Test class [%s] is annotated with both @Rollback "_					+ "and @TransactionConfiguration, but only one is permitted.", testClass.getName()))__		}__		if (rollbackPresent) {_			boolean defaultRollback = rollback.value()__			if (logger.isDebugEnabled()) {_				logger.debug(String.format("Retrieved default @Rollback(%s) for test class [%s].", defaultRollback,_					testClass.getName()))__			}_			return defaultRollback__		}__		_		return txConfigAttributes.isDefaultRollback()__	};determine,whether,or,not,to,rollback,transactions,by,default,for,the,supplied,linkplain,test,context,test,context,p,supports,link,rollback,rollback,or,link,transaction,configuration,transaction,configuration,at,the,class,level,param,test,context,the,test,context,for,which,the,default,rollback,flag,should,be,retrieved,return,the,em,default,rollback,em,flag,for,the,supplied,test,context,throws,exception,if,an,error,occurs,while,determining,the,default,rollback,flag;suppress,warnings,deprecation,protected,final,boolean,is,default,rollback,test,context,test,context,throws,exception,class,test,class,test,context,get,test,class,rollback,rollback,annotated,element,utils,find,merged,annotation,test,class,rollback,class,boolean,rollback,present,rollback,null,transaction,configuration,attributes,tx,config,attributes,retrieve,configuration,attributes,test,context,if,rollback,present,tx,config,attributes,default,tx,config,attributes,throw,new,illegal,state,exception,string,format,test,class,s,is,annotated,with,both,rollback,and,transaction,configuration,but,only,one,is,permitted,test,class,get,name,if,rollback,present,boolean,default,rollback,rollback,value,if,logger,is,debug,enabled,logger,debug,string,format,retrieved,default,rollback,s,for,test,class,s,default,rollback,test,class,get,name,return,default,rollback,return,tx,config,attributes,is,default,rollback
TransactionalTestExecutionListener -> @SuppressWarnings("deprecation") 	protected final boolean isDefaultRollback(TestContext testContext) throws Exception;1462294651;Determine whether or not to rollback transactions by default for the_supplied {@linkplain TestContext test context}._<p>Supports {@link Rollback @Rollback} or_{@link TransactionConfiguration @TransactionConfiguration} at the_class-level._@param testContext the test context for which the default rollback flag_should be retrieved_@return the <em>default rollback</em> flag for the supplied test context_@throws Exception if an error occurs while determining the default rollback flag;@SuppressWarnings("deprecation")_	protected final boolean isDefaultRollback(TestContext testContext) throws Exception {_		Class<?> testClass = testContext.getTestClass()__		Rollback rollback = AnnotatedElementUtils.findMergedAnnotation(testClass, Rollback.class)__		boolean rollbackPresent = (rollback != null)__		TransactionConfigurationAttributes txConfigAttributes = retrieveConfigurationAttributes(testContext)___		if (rollbackPresent && txConfigAttributes != defaultTxConfigAttributes) {_			throw new IllegalStateException(String.format("Test class [%s] is annotated with both @Rollback "_					+ "and @TransactionConfiguration, but only one is permitted.", testClass.getName()))__		}__		if (rollbackPresent) {_			boolean defaultRollback = rollback.value()__			if (logger.isDebugEnabled()) {_				logger.debug(String.format("Retrieved default @Rollback(%s) for test class [%s].", defaultRollback,_					testClass.getName()))__			}_			return defaultRollback__		}__		_		return txConfigAttributes.isDefaultRollback()__	};determine,whether,or,not,to,rollback,transactions,by,default,for,the,supplied,linkplain,test,context,test,context,p,supports,link,rollback,rollback,or,link,transaction,configuration,transaction,configuration,at,the,class,level,param,test,context,the,test,context,for,which,the,default,rollback,flag,should,be,retrieved,return,the,em,default,rollback,em,flag,for,the,supplied,test,context,throws,exception,if,an,error,occurs,while,determining,the,default,rollback,flag;suppress,warnings,deprecation,protected,final,boolean,is,default,rollback,test,context,test,context,throws,exception,class,test,class,test,context,get,test,class,rollback,rollback,annotated,element,utils,find,merged,annotation,test,class,rollback,class,boolean,rollback,present,rollback,null,transaction,configuration,attributes,tx,config,attributes,retrieve,configuration,attributes,test,context,if,rollback,present,tx,config,attributes,default,tx,config,attributes,throw,new,illegal,state,exception,string,format,test,class,s,is,annotated,with,both,rollback,and,transaction,configuration,but,only,one,is,permitted,test,class,get,name,if,rollback,present,boolean,default,rollback,rollback,value,if,logger,is,debug,enabled,logger,debug,string,format,retrieved,default,rollback,s,for,test,class,s,default,rollback,test,class,get,name,return,default,rollback,return,tx,config,attributes,is,default,rollback
TransactionalTestExecutionListener -> @SuppressWarnings("deprecation") 	protected final boolean isDefaultRollback(TestContext testContext) throws Exception;1462299971;Determine whether or not to rollback transactions by default for the_supplied {@linkplain TestContext test context}._<p>Supports {@link Rollback @Rollback}, {@link Commit @Commit}, or_{@link TransactionConfiguration @TransactionConfiguration} at the_class-level._@param testContext the test context for which the default rollback flag_should be retrieved_@return the <em>default rollback</em> flag for the supplied test context_@throws Exception if an error occurs while determining the default rollback flag;@SuppressWarnings("deprecation")_	protected final boolean isDefaultRollback(TestContext testContext) throws Exception {_		Class<?> testClass = testContext.getTestClass()__		Rollback rollback = AnnotatedElementUtils.findMergedAnnotation(testClass, Rollback.class)__		boolean rollbackPresent = (rollback != null)__		TransactionConfigurationAttributes txConfigAttributes = retrieveConfigurationAttributes(testContext)___		if (rollbackPresent && txConfigAttributes != defaultTxConfigAttributes) {_			throw new IllegalStateException(String.format("Test class [%s] is annotated with both @Rollback "_					+ "and @TransactionConfiguration, but only one is permitted.", testClass.getName()))__		}__		if (rollbackPresent) {_			boolean defaultRollback = rollback.value()__			if (logger.isDebugEnabled()) {_				logger.debug(String.format("Retrieved default @Rollback(%s) for test class [%s].", defaultRollback,_					testClass.getName()))__			}_			return defaultRollback__		}__		_		return txConfigAttributes.isDefaultRollback()__	};determine,whether,or,not,to,rollback,transactions,by,default,for,the,supplied,linkplain,test,context,test,context,p,supports,link,rollback,rollback,link,commit,commit,or,link,transaction,configuration,transaction,configuration,at,the,class,level,param,test,context,the,test,context,for,which,the,default,rollback,flag,should,be,retrieved,return,the,em,default,rollback,em,flag,for,the,supplied,test,context,throws,exception,if,an,error,occurs,while,determining,the,default,rollback,flag;suppress,warnings,deprecation,protected,final,boolean,is,default,rollback,test,context,test,context,throws,exception,class,test,class,test,context,get,test,class,rollback,rollback,annotated,element,utils,find,merged,annotation,test,class,rollback,class,boolean,rollback,present,rollback,null,transaction,configuration,attributes,tx,config,attributes,retrieve,configuration,attributes,test,context,if,rollback,present,tx,config,attributes,default,tx,config,attributes,throw,new,illegal,state,exception,string,format,test,class,s,is,annotated,with,both,rollback,and,transaction,configuration,but,only,one,is,permitted,test,class,get,name,if,rollback,present,boolean,default,rollback,rollback,value,if,logger,is,debug,enabled,logger,debug,string,format,retrieved,default,rollback,s,for,test,class,s,default,rollback,test,class,get,name,return,default,rollback,return,tx,config,attributes,is,default,rollback
TransactionalTestExecutionListener -> @SuppressWarnings("deprecation") 	protected final boolean isDefaultRollback(TestContext testContext) throws Exception;1467730834;Determine whether or not to rollback transactions by default for the_supplied {@linkplain TestContext test context}._<p>Supports {@link Rollback @Rollback}, {@link Commit @Commit}, or_{@link TransactionConfiguration @TransactionConfiguration} at the_class-level._@param testContext the test context for which the default rollback flag_should be retrieved_@return the <em>default rollback</em> flag for the supplied test context_@throws Exception if an error occurs while determining the default rollback flag;@SuppressWarnings("deprecation")_	protected final boolean isDefaultRollback(TestContext testContext) throws Exception {_		Class<?> testClass = testContext.getTestClass()__		Rollback rollback = AnnotatedElementUtils.findMergedAnnotation(testClass, Rollback.class)__		boolean rollbackPresent = (rollback != null)__		TransactionConfigurationAttributes txConfigAttributes = retrieveConfigurationAttributes(testContext)___		if (rollbackPresent && txConfigAttributes != defaultTxConfigAttributes) {_			throw new IllegalStateException(String.format("Test class [%s] is annotated with both @Rollback "_					+ "and @TransactionConfiguration, but only one is permitted.", testClass.getName()))__		}__		if (rollbackPresent) {_			boolean defaultRollback = rollback.value()__			if (logger.isDebugEnabled()) {_				logger.debug(String.format("Retrieved default @Rollback(%s) for test class [%s].", defaultRollback,_					testClass.getName()))__			}_			return defaultRollback__		}__		_		return txConfigAttributes.isDefaultRollback()__	};determine,whether,or,not,to,rollback,transactions,by,default,for,the,supplied,linkplain,test,context,test,context,p,supports,link,rollback,rollback,link,commit,commit,or,link,transaction,configuration,transaction,configuration,at,the,class,level,param,test,context,the,test,context,for,which,the,default,rollback,flag,should,be,retrieved,return,the,em,default,rollback,em,flag,for,the,supplied,test,context,throws,exception,if,an,error,occurs,while,determining,the,default,rollback,flag;suppress,warnings,deprecation,protected,final,boolean,is,default,rollback,test,context,test,context,throws,exception,class,test,class,test,context,get,test,class,rollback,rollback,annotated,element,utils,find,merged,annotation,test,class,rollback,class,boolean,rollback,present,rollback,null,transaction,configuration,attributes,tx,config,attributes,retrieve,configuration,attributes,test,context,if,rollback,present,tx,config,attributes,default,tx,config,attributes,throw,new,illegal,state,exception,string,format,test,class,s,is,annotated,with,both,rollback,and,transaction,configuration,but,only,one,is,permitted,test,class,get,name,if,rollback,present,boolean,default,rollback,rollback,value,if,logger,is,debug,enabled,logger,debug,string,format,retrieved,default,rollback,s,for,test,class,s,default,rollback,test,class,get,name,return,default,rollback,return,tx,config,attributes,is,default,rollback
TransactionalTestExecutionListener -> @SuppressWarnings("deprecation") 	protected final boolean isDefaultRollback(TestContext testContext) throws Exception;1467992320;Determine whether or not to rollback transactions by default for the_supplied {@linkplain TestContext test context}._<p>Supports {@link Rollback @Rollback}, {@link Commit @Commit}, or_{@link TransactionConfiguration @TransactionConfiguration} at the_class-level._@param testContext the test context for which the default rollback flag_should be retrieved_@return the <em>default rollback</em> flag for the supplied test context_@throws Exception if an error occurs while determining the default rollback flag;@SuppressWarnings("deprecation")_	protected final boolean isDefaultRollback(TestContext testContext) throws Exception {_		Class<?> testClass = testContext.getTestClass()__		Rollback rollback = AnnotatedElementUtils.findMergedAnnotation(testClass, Rollback.class)__		boolean rollbackPresent = (rollback != null)__		TransactionConfigurationAttributes txConfigAttributes = retrieveConfigurationAttributes(testContext)___		if (rollbackPresent && txConfigAttributes != defaultTxConfigAttributes) {_			throw new IllegalStateException(String.format("Test class [%s] is annotated with both @Rollback "_					+ "and @TransactionConfiguration, but only one is permitted.", testClass.getName()))__		}__		if (rollbackPresent) {_			boolean defaultRollback = rollback.value()__			if (logger.isDebugEnabled()) {_				logger.debug(String.format("Retrieved default @Rollback(%s) for test class [%s].", defaultRollback,_					testClass.getName()))__			}_			return defaultRollback__		}__		_		return txConfigAttributes.isDefaultRollback()__	};determine,whether,or,not,to,rollback,transactions,by,default,for,the,supplied,linkplain,test,context,test,context,p,supports,link,rollback,rollback,link,commit,commit,or,link,transaction,configuration,transaction,configuration,at,the,class,level,param,test,context,the,test,context,for,which,the,default,rollback,flag,should,be,retrieved,return,the,em,default,rollback,em,flag,for,the,supplied,test,context,throws,exception,if,an,error,occurs,while,determining,the,default,rollback,flag;suppress,warnings,deprecation,protected,final,boolean,is,default,rollback,test,context,test,context,throws,exception,class,test,class,test,context,get,test,class,rollback,rollback,annotated,element,utils,find,merged,annotation,test,class,rollback,class,boolean,rollback,present,rollback,null,transaction,configuration,attributes,tx,config,attributes,retrieve,configuration,attributes,test,context,if,rollback,present,tx,config,attributes,default,tx,config,attributes,throw,new,illegal,state,exception,string,format,test,class,s,is,annotated,with,both,rollback,and,transaction,configuration,but,only,one,is,permitted,test,class,get,name,if,rollback,present,boolean,default,rollback,rollback,value,if,logger,is,debug,enabled,logger,debug,string,format,retrieved,default,rollback,s,for,test,class,s,default,rollback,test,class,get,name,return,default,rollback,return,tx,config,attributes,is,default,rollback
TransactionalTestExecutionListener -> @SuppressWarnings("deprecation") 	protected final boolean isDefaultRollback(TestContext testContext) throws Exception;1467992442;Determine whether or not to rollback transactions by default for the_supplied {@linkplain TestContext test context}._<p>Supports {@link Rollback @Rollback}, {@link Commit @Commit}, or_{@link TransactionConfiguration @TransactionConfiguration} at the_class-level._@param testContext the test context for which the default rollback flag_should be retrieved_@return the <em>default rollback</em> flag for the supplied test context_@throws Exception if an error occurs while determining the default rollback flag;@SuppressWarnings("deprecation")_	protected final boolean isDefaultRollback(TestContext testContext) throws Exception {_		Class<?> testClass = testContext.getTestClass()__		Rollback rollback = AnnotatedElementUtils.findMergedAnnotation(testClass, Rollback.class)__		boolean rollbackPresent = (rollback != null)__		TransactionConfigurationAttributes txConfigAttributes = retrieveConfigurationAttributes(testContext)___		if (rollbackPresent && txConfigAttributes != defaultTxConfigAttributes) {_			throw new IllegalStateException(String.format("Test class [%s] is annotated with both @Rollback "_					+ "and @TransactionConfiguration, but only one is permitted.", testClass.getName()))__		}__		if (rollbackPresent) {_			boolean defaultRollback = rollback.value()__			if (logger.isDebugEnabled()) {_				logger.debug(String.format("Retrieved default @Rollback(%s) for test class [%s].", defaultRollback,_					testClass.getName()))__			}_			return defaultRollback__		}__		_		return txConfigAttributes.isDefaultRollback()__	};determine,whether,or,not,to,rollback,transactions,by,default,for,the,supplied,linkplain,test,context,test,context,p,supports,link,rollback,rollback,link,commit,commit,or,link,transaction,configuration,transaction,configuration,at,the,class,level,param,test,context,the,test,context,for,which,the,default,rollback,flag,should,be,retrieved,return,the,em,default,rollback,em,flag,for,the,supplied,test,context,throws,exception,if,an,error,occurs,while,determining,the,default,rollback,flag;suppress,warnings,deprecation,protected,final,boolean,is,default,rollback,test,context,test,context,throws,exception,class,test,class,test,context,get,test,class,rollback,rollback,annotated,element,utils,find,merged,annotation,test,class,rollback,class,boolean,rollback,present,rollback,null,transaction,configuration,attributes,tx,config,attributes,retrieve,configuration,attributes,test,context,if,rollback,present,tx,config,attributes,default,tx,config,attributes,throw,new,illegal,state,exception,string,format,test,class,s,is,annotated,with,both,rollback,and,transaction,configuration,but,only,one,is,permitted,test,class,get,name,if,rollback,present,boolean,default,rollback,rollback,value,if,logger,is,debug,enabled,logger,debug,string,format,retrieved,default,rollback,s,for,test,class,s,default,rollback,test,class,get,name,return,default,rollback,return,tx,config,attributes,is,default,rollback
TransactionalTestExecutionListener -> private boolean isShadowed(Method method, List<Method> previousMethods);1328020251;Determines if the supplied {@link Method method} is <em>shadowed</em>_by a method in supplied {@link List list} of previous methods._<p>Note: This code has been borrowed from_{@link org.junit.internal.runners.TestClass#isShadowed(Method,List)}._@param method the method to check for shadowing_@param previousMethods the list of methods which have previously been processed_@return <code>true</code> if the supplied method is shadowed by a_method in the <code>previousMethods</code> list;private boolean isShadowed(Method method, List<Method> previousMethods) {_		for (Method each : previousMethods) {_			if (isShadowed(method, each)) {_				return true__			}_		}_		return false__	};determines,if,the,supplied,link,method,method,is,em,shadowed,em,by,a,method,in,supplied,link,list,list,of,previous,methods,p,note,this,code,has,been,borrowed,from,link,org,junit,internal,runners,test,class,is,shadowed,method,list,param,method,the,method,to,check,for,shadowing,param,previous,methods,the,list,of,methods,which,have,previously,been,processed,return,code,true,code,if,the,supplied,method,is,shadowed,by,a,method,in,the,code,previous,methods,code,list;private,boolean,is,shadowed,method,method,list,method,previous,methods,for,method,each,previous,methods,if,is,shadowed,method,each,return,true,return,false
TransactionalTestExecutionListener -> private boolean isShadowed(Method method, List<Method> previousMethods);1337516454;Determines if the supplied {@link Method method} is <em>shadowed</em>_by a method in supplied {@link List list} of previous methods._<p>Note: This code has been borrowed from_{@link org.junit.internal.runners.TestClass#isShadowed(Method,List)}._@param method the method to check for shadowing_@param previousMethods the list of methods which have previously been processed_@return <code>true</code> if the supplied method is shadowed by a_method in the <code>previousMethods</code> list;private boolean isShadowed(Method method, List<Method> previousMethods) {_		for (Method each : previousMethods) {_			if (isShadowed(method, each)) {_				return true__			}_		}_		return false__	};determines,if,the,supplied,link,method,method,is,em,shadowed,em,by,a,method,in,supplied,link,list,list,of,previous,methods,p,note,this,code,has,been,borrowed,from,link,org,junit,internal,runners,test,class,is,shadowed,method,list,param,method,the,method,to,check,for,shadowing,param,previous,methods,the,list,of,methods,which,have,previously,been,processed,return,code,true,code,if,the,supplied,method,is,shadowed,by,a,method,in,the,code,previous,methods,code,list;private,boolean,is,shadowed,method,method,list,method,previous,methods,for,method,each,previous,methods,if,is,shadowed,method,each,return,true,return,false
TransactionalTestExecutionListener -> private boolean isShadowed(Method method, List<Method> previousMethods);1338031377;Determines if the supplied {@link Method method} is <em>shadowed</em>_by a method in supplied {@link List list} of previous methods._<p>Note: This code has been borrowed from_{@link org.junit.internal.runners.TestClass#isShadowed(Method,List)}._@param method the method to check for shadowing_@param previousMethods the list of methods which have previously been processed_@return <code>true</code> if the supplied method is shadowed by a_method in the <code>previousMethods</code> list;private boolean isShadowed(Method method, List<Method> previousMethods) {_		for (Method each : previousMethods) {_			if (isShadowed(method, each)) {_				return true__			}_		}_		return false__	};determines,if,the,supplied,link,method,method,is,em,shadowed,em,by,a,method,in,supplied,link,list,list,of,previous,methods,p,note,this,code,has,been,borrowed,from,link,org,junit,internal,runners,test,class,is,shadowed,method,list,param,method,the,method,to,check,for,shadowing,param,previous,methods,the,list,of,methods,which,have,previously,been,processed,return,code,true,code,if,the,supplied,method,is,shadowed,by,a,method,in,the,code,previous,methods,code,list;private,boolean,is,shadowed,method,method,list,method,previous,methods,for,method,each,previous,methods,if,is,shadowed,method,each,return,true,return,false
TransactionalTestExecutionListener -> private boolean isShadowed(Method method, List<Method> previousMethods);1343426806;Determines if the supplied {@link Method method} is <em>shadowed</em>_by a method in supplied {@link List list} of previous methods._<p>Note: This code has been borrowed from_{@link org.junit.internal.runners.TestClass#isShadowed(Method,List)}._@param method the method to check for shadowing_@param previousMethods the list of methods which have previously been processed_@return <code>true</code> if the supplied method is shadowed by a_method in the <code>previousMethods</code> list;private boolean isShadowed(Method method, List<Method> previousMethods) {_		for (Method each : previousMethods) {_			if (isShadowed(method, each)) {_				return true__			}_		}_		return false__	};determines,if,the,supplied,link,method,method,is,em,shadowed,em,by,a,method,in,supplied,link,list,list,of,previous,methods,p,note,this,code,has,been,borrowed,from,link,org,junit,internal,runners,test,class,is,shadowed,method,list,param,method,the,method,to,check,for,shadowing,param,previous,methods,the,list,of,methods,which,have,previously,been,processed,return,code,true,code,if,the,supplied,method,is,shadowed,by,a,method,in,the,code,previous,methods,code,list;private,boolean,is,shadowed,method,method,list,method,previous,methods,for,method,each,previous,methods,if,is,shadowed,method,each,return,true,return,false
TransactionalTestExecutionListener -> private boolean isShadowed(Method method, List<Method> previousMethods);1343431472;Determines if the supplied {@link Method method} is <em>shadowed</em>_by a method in supplied {@link List list} of previous methods._<p>Note: This code has been borrowed from_{@link org.junit.internal.runners.TestClass#isShadowed(Method,List)}._@param method the method to check for shadowing_@param previousMethods the list of methods which have previously been processed_@return <code>true</code> if the supplied method is shadowed by a_method in the <code>previousMethods</code> list;private boolean isShadowed(Method method, List<Method> previousMethods) {_		for (Method each : previousMethods) {_			if (isShadowed(method, each)) {_				return true__			}_		}_		return false__	};determines,if,the,supplied,link,method,method,is,em,shadowed,em,by,a,method,in,supplied,link,list,list,of,previous,methods,p,note,this,code,has,been,borrowed,from,link,org,junit,internal,runners,test,class,is,shadowed,method,list,param,method,the,method,to,check,for,shadowing,param,previous,methods,the,list,of,methods,which,have,previously,been,processed,return,code,true,code,if,the,supplied,method,is,shadowed,by,a,method,in,the,code,previous,methods,code,list;private,boolean,is,shadowed,method,method,list,method,previous,methods,for,method,each,previous,methods,if,is,shadowed,method,each,return,true,return,false
TransactionalTestExecutionListener -> private boolean isShadowed(Method method, List<Method> previousMethods);1354571539;Determines if the supplied {@link Method method} is <em>shadowed</em>_by a method in supplied {@link List list} of previous methods._<p>Note: This code has been borrowed from_{@link org.junit.internal.runners.TestClass#isShadowed(Method,List)}._@param method the method to check for shadowing_@param previousMethods the list of methods which have previously been processed_@return <code>true</code> if the supplied method is shadowed by a_method in the <code>previousMethods</code> list;private boolean isShadowed(Method method, List<Method> previousMethods) {_		for (Method each : previousMethods) {_			if (isShadowed(method, each)) {_				return true__			}_		}_		return false__	};determines,if,the,supplied,link,method,method,is,em,shadowed,em,by,a,method,in,supplied,link,list,list,of,previous,methods,p,note,this,code,has,been,borrowed,from,link,org,junit,internal,runners,test,class,is,shadowed,method,list,param,method,the,method,to,check,for,shadowing,param,previous,methods,the,list,of,methods,which,have,previously,been,processed,return,code,true,code,if,the,supplied,method,is,shadowed,by,a,method,in,the,code,previous,methods,code,list;private,boolean,is,shadowed,method,method,list,method,previous,methods,for,method,each,previous,methods,if,is,shadowed,method,each,return,true,return,false
TransactionalTestExecutionListener -> private boolean isShadowed(Method method, List<Method> previousMethods);1355352386;Determines if the supplied {@link Method method} is <em>shadowed</em>_by a method in supplied {@link List list} of previous methods._<p>Note: This code has been borrowed from_{@link org.junit.internal.runners.TestClass#isShadowed(Method,List)}._@param method the method to check for shadowing_@param previousMethods the list of methods which have previously been processed_@return <code>true</code> if the supplied method is shadowed by a_method in the <code>previousMethods</code> list;private boolean isShadowed(Method method, List<Method> previousMethods) {_		for (Method each : previousMethods) {_			if (isShadowed(method, each)) {_				return true__			}_		}_		return false__	};determines,if,the,supplied,link,method,method,is,em,shadowed,em,by,a,method,in,supplied,link,list,list,of,previous,methods,p,note,this,code,has,been,borrowed,from,link,org,junit,internal,runners,test,class,is,shadowed,method,list,param,method,the,method,to,check,for,shadowing,param,previous,methods,the,list,of,methods,which,have,previously,been,processed,return,code,true,code,if,the,supplied,method,is,shadowed,by,a,method,in,the,code,previous,methods,code,list;private,boolean,is,shadowed,method,method,list,method,previous,methods,for,method,each,previous,methods,if,is,shadowed,method,each,return,true,return,false
TransactionalTestExecutionListener -> private boolean isShadowed(Method method, List<Method> previousMethods);1356735495;Determines if the supplied {@link Method method} is <em>shadowed</em>_by a method in supplied {@link List list} of previous methods._<p>Note: This code has been borrowed from_{@link org.junit.internal.runners.TestClass#isShadowed(Method, List)}._@param method the method to check for shadowing_@param previousMethods the list of methods which have previously been processed_@return {@code true} if the supplied method is shadowed by a_method in the {@code previousMethods} list;private boolean isShadowed(Method method, List<Method> previousMethods) {_		for (Method each : previousMethods) {_			if (isShadowed(method, each)) {_				return true__			}_		}_		return false__	};determines,if,the,supplied,link,method,method,is,em,shadowed,em,by,a,method,in,supplied,link,list,list,of,previous,methods,p,note,this,code,has,been,borrowed,from,link,org,junit,internal,runners,test,class,is,shadowed,method,list,param,method,the,method,to,check,for,shadowing,param,previous,methods,the,list,of,methods,which,have,previously,been,processed,return,code,true,if,the,supplied,method,is,shadowed,by,a,method,in,the,code,previous,methods,list;private,boolean,is,shadowed,method,method,list,method,previous,methods,for,method,each,previous,methods,if,is,shadowed,method,each,return,true,return,false
TransactionalTestExecutionListener -> private boolean isShadowed(Method method, List<Method> previousMethods);1357119239;Determines if the supplied {@link Method method} is <em>shadowed</em>_by a method in supplied {@link List list} of previous methods._<p>Note: This code has been borrowed from_{@link org.junit.internal.runners.TestClass#isShadowed(Method, List)}._@param method the method to check for shadowing_@param previousMethods the list of methods which have previously been processed_@return {@code true} if the supplied method is shadowed by a_method in the {@code previousMethods} list;private boolean isShadowed(Method method, List<Method> previousMethods) {_		for (Method each : previousMethods) {_			if (isShadowed(method, each)) {_				return true__			}_		}_		return false__	};determines,if,the,supplied,link,method,method,is,em,shadowed,em,by,a,method,in,supplied,link,list,list,of,previous,methods,p,note,this,code,has,been,borrowed,from,link,org,junit,internal,runners,test,class,is,shadowed,method,list,param,method,the,method,to,check,for,shadowing,param,previous,methods,the,list,of,methods,which,have,previously,been,processed,return,code,true,if,the,supplied,method,is,shadowed,by,a,method,in,the,code,previous,methods,list;private,boolean,is,shadowed,method,method,list,method,previous,methods,for,method,each,previous,methods,if,is,shadowed,method,each,return,true,return,false
TransactionalTestExecutionListener -> private boolean isShadowed(Method method, List<Method> previousMethods);1367163114;Determines if the supplied {@link Method method} is <em>shadowed</em>_by a method in supplied {@link List list} of previous methods._<p>Note: This code has been borrowed from_{@link org.junit.internal.runners.TestClass#isShadowed(Method, List)}._@param method the method to check for shadowing_@param previousMethods the list of methods which have previously been processed_@return {@code true} if the supplied method is shadowed by a_method in the {@code previousMethods} list;private boolean isShadowed(Method method, List<Method> previousMethods) {_		for (Method each : previousMethods) {_			if (isShadowed(method, each)) {_				return true__			}_		}_		return false__	};determines,if,the,supplied,link,method,method,is,em,shadowed,em,by,a,method,in,supplied,link,list,list,of,previous,methods,p,note,this,code,has,been,borrowed,from,link,org,junit,internal,runners,test,class,is,shadowed,method,list,param,method,the,method,to,check,for,shadowing,param,previous,methods,the,list,of,methods,which,have,previously,been,processed,return,code,true,if,the,supplied,method,is,shadowed,by,a,method,in,the,code,previous,methods,list;private,boolean,is,shadowed,method,method,list,method,previous,methods,for,method,each,previous,methods,if,is,shadowed,method,each,return,true,return,false
TransactionalTestExecutionListener -> private boolean isShadowed(Method method, List<Method> previousMethods);1367873075;Determines if the supplied {@link Method method} is <em>shadowed</em>_by a method in supplied {@link List list} of previous methods._<p>Note: This code has been borrowed from_{@link org.junit.internal.runners.TestClass#isShadowed(Method, List)}._@param method the method to check for shadowing_@param previousMethods the list of methods which have previously been processed_@return {@code true} if the supplied method is shadowed by a_method in the {@code previousMethods} list;private boolean isShadowed(Method method, List<Method> previousMethods) {_		for (Method each : previousMethods) {_			if (isShadowed(method, each)) {_				return true__			}_		}_		return false__	};determines,if,the,supplied,link,method,method,is,em,shadowed,em,by,a,method,in,supplied,link,list,list,of,previous,methods,p,note,this,code,has,been,borrowed,from,link,org,junit,internal,runners,test,class,is,shadowed,method,list,param,method,the,method,to,check,for,shadowing,param,previous,methods,the,list,of,methods,which,have,previously,been,processed,return,code,true,if,the,supplied,method,is,shadowed,by,a,method,in,the,code,previous,methods,list;private,boolean,is,shadowed,method,method,list,method,previous,methods,for,method,each,previous,methods,if,is,shadowed,method,each,return,true,return,false
TransactionalTestExecutionListener -> private boolean isShadowed(Method method, List<Method> previousMethods);1368482696;Determines if the supplied {@link Method method} is <em>shadowed</em>_by a method in supplied {@link List list} of previous methods._<p>Note: This code has been borrowed from_{@link org.junit.internal.runners.TestClass#isShadowed(Method, List)}._@param method the method to check for shadowing_@param previousMethods the list of methods which have previously been processed_@return {@code true} if the supplied method is shadowed by a_method in the {@code previousMethods} list;private boolean isShadowed(Method method, List<Method> previousMethods) {_		for (Method each : previousMethods) {_			if (isShadowed(method, each)) {_				return true__			}_		}_		return false__	};determines,if,the,supplied,link,method,method,is,em,shadowed,em,by,a,method,in,supplied,link,list,list,of,previous,methods,p,note,this,code,has,been,borrowed,from,link,org,junit,internal,runners,test,class,is,shadowed,method,list,param,method,the,method,to,check,for,shadowing,param,previous,methods,the,list,of,methods,which,have,previously,been,processed,return,code,true,if,the,supplied,method,is,shadowed,by,a,method,in,the,code,previous,methods,list;private,boolean,is,shadowed,method,method,list,method,previous,methods,for,method,each,previous,methods,if,is,shadowed,method,each,return,true,return,false
TransactionalTestExecutionListener -> private boolean isShadowed(Method method, List<Method> previousMethods);1382920864;Determine if the supplied {@link Method method} is <em>shadowed</em> by_a method in the supplied {@link List list} of previous methods._<p>Note: This code has been borrowed from_{@link org.junit.internal.runners.TestClass#isShadowed(Method, List)}._@param method the method to check for shadowing_@param previousMethods the list of methods which have previously been processed_@return {@code true} if the supplied method is shadowed by a_method in the {@code previousMethods} list;private boolean isShadowed(Method method, List<Method> previousMethods) {_		for (Method each : previousMethods) {_			if (isShadowed(method, each)) {_				return true__			}_		}_		return false__	};determine,if,the,supplied,link,method,method,is,em,shadowed,em,by,a,method,in,the,supplied,link,list,list,of,previous,methods,p,note,this,code,has,been,borrowed,from,link,org,junit,internal,runners,test,class,is,shadowed,method,list,param,method,the,method,to,check,for,shadowing,param,previous,methods,the,list,of,methods,which,have,previously,been,processed,return,code,true,if,the,supplied,method,is,shadowed,by,a,method,in,the,code,previous,methods,list;private,boolean,is,shadowed,method,method,list,method,previous,methods,for,method,each,previous,methods,if,is,shadowed,method,each,return,true,return,false
TransactionalTestExecutionListener -> private boolean isShadowed(Method method, List<Method> previousMethods);1385499540;Determine if the supplied {@link Method method} is <em>shadowed</em> by_a method in the supplied {@link List list} of previous methods._<p>Note: This code has been borrowed from_{@link org.junit.internal.runners.TestClass#isShadowed(Method, List)}._@param method the method to check for shadowing_@param previousMethods the list of methods which have previously been processed_@return {@code true} if the supplied method is shadowed by a_method in the {@code previousMethods} list;private boolean isShadowed(Method method, List<Method> previousMethods) {_		for (Method each : previousMethods) {_			if (isShadowed(method, each)) {_				return true__			}_		}_		return false__	};determine,if,the,supplied,link,method,method,is,em,shadowed,em,by,a,method,in,the,supplied,link,list,list,of,previous,methods,p,note,this,code,has,been,borrowed,from,link,org,junit,internal,runners,test,class,is,shadowed,method,list,param,method,the,method,to,check,for,shadowing,param,previous,methods,the,list,of,methods,which,have,previously,been,processed,return,code,true,if,the,supplied,method,is,shadowed,by,a,method,in,the,code,previous,methods,list;private,boolean,is,shadowed,method,method,list,method,previous,methods,for,method,each,previous,methods,if,is,shadowed,method,each,return,true,return,false
TransactionalTestExecutionListener -> private boolean isShadowed(Method method, List<Method> previousMethods);1389966876;Determine if the supplied {@link Method method} is <em>shadowed</em> by_a method in the supplied {@link List list} of previous methods._<p>Note: This code has been borrowed from_{@link org.junit.internal.runners.TestClass#isShadowed(Method, List)}._@param method the method to check for shadowing_@param previousMethods the list of methods which have previously been processed_@return {@code true} if the supplied method is shadowed by a_method in the {@code previousMethods} list;private boolean isShadowed(Method method, List<Method> previousMethods) {_		for (Method each : previousMethods) {_			if (isShadowed(method, each)) {_				return true__			}_		}_		return false__	};determine,if,the,supplied,link,method,method,is,em,shadowed,em,by,a,method,in,the,supplied,link,list,list,of,previous,methods,p,note,this,code,has,been,borrowed,from,link,org,junit,internal,runners,test,class,is,shadowed,method,list,param,method,the,method,to,check,for,shadowing,param,previous,methods,the,list,of,methods,which,have,previously,been,processed,return,code,true,if,the,supplied,method,is,shadowed,by,a,method,in,the,code,previous,methods,list;private,boolean,is,shadowed,method,method,list,method,previous,methods,for,method,each,previous,methods,if,is,shadowed,method,each,return,true,return,false
TransactionalTestExecutionListener -> private boolean isShadowed(Method method, List<Method> previousMethods);1401991965;Determine if the supplied {@link Method method} is <em>shadowed</em> by_a method in the supplied {@link List list} of previous methods._<p>Note: This code has been borrowed from_{@link org.junit.internal.runners.TestClass#isShadowed(Method, List)}._@param method the method to check for shadowing_@param previousMethods the list of methods which have previously been processed_@return {@code true} if the supplied method is shadowed by a_method in the {@code previousMethods} list;private boolean isShadowed(Method method, List<Method> previousMethods) {_		for (Method each : previousMethods) {_			if (isShadowed(method, each)) {_				return true__			}_		}_		return false__	};determine,if,the,supplied,link,method,method,is,em,shadowed,em,by,a,method,in,the,supplied,link,list,list,of,previous,methods,p,note,this,code,has,been,borrowed,from,link,org,junit,internal,runners,test,class,is,shadowed,method,list,param,method,the,method,to,check,for,shadowing,param,previous,methods,the,list,of,methods,which,have,previously,been,processed,return,code,true,if,the,supplied,method,is,shadowed,by,a,method,in,the,code,previous,methods,list;private,boolean,is,shadowed,method,method,list,method,previous,methods,for,method,each,previous,methods,if,is,shadowed,method,each,return,true,return,false
TransactionalTestExecutionListener -> private boolean isShadowed(Method method, List<Method> previousMethods);1404334604;Determine if the supplied {@link Method method} is <em>shadowed</em> by_a method in the supplied {@link List list} of previous methods._<p>Note: This code has been borrowed from_{@link org.junit.internal.runners.TestClass#isShadowed(Method, List)}._@param method the method to check for shadowing_@param previousMethods the list of methods which have previously been processed_@return {@code true} if the supplied method is shadowed by a_method in the {@code previousMethods} list;private boolean isShadowed(Method method, List<Method> previousMethods) {_		for (Method each : previousMethods) {_			if (isShadowed(method, each)) {_				return true__			}_		}_		return false__	};determine,if,the,supplied,link,method,method,is,em,shadowed,em,by,a,method,in,the,supplied,link,list,list,of,previous,methods,p,note,this,code,has,been,borrowed,from,link,org,junit,internal,runners,test,class,is,shadowed,method,list,param,method,the,method,to,check,for,shadowing,param,previous,methods,the,list,of,methods,which,have,previously,been,processed,return,code,true,if,the,supplied,method,is,shadowed,by,a,method,in,the,code,previous,methods,list;private,boolean,is,shadowed,method,method,list,method,previous,methods,for,method,each,previous,methods,if,is,shadowed,method,each,return,true,return,false
TransactionalTestExecutionListener -> private boolean isShadowed(Method method, List<Method> previousMethods);1405645143;Determine if the supplied {@link Method method} is <em>shadowed</em> by_a method in the supplied {@link List list} of previous methods._<p>Note: This code has been borrowed from_{@link org.junit.internal.runners.TestClass#isShadowed(Method, List)}._@param method the method to check for shadowing_@param previousMethods the list of methods which have previously been processed_@return {@code true} if the supplied method is shadowed by a_method in the {@code previousMethods} list;private boolean isShadowed(Method method, List<Method> previousMethods) {_		for (Method each : previousMethods) {_			if (isShadowed(method, each)) {_				return true__			}_		}_		return false__	};determine,if,the,supplied,link,method,method,is,em,shadowed,em,by,a,method,in,the,supplied,link,list,list,of,previous,methods,p,note,this,code,has,been,borrowed,from,link,org,junit,internal,runners,test,class,is,shadowed,method,list,param,method,the,method,to,check,for,shadowing,param,previous,methods,the,list,of,methods,which,have,previously,been,processed,return,code,true,if,the,supplied,method,is,shadowed,by,a,method,in,the,code,previous,methods,list;private,boolean,is,shadowed,method,method,list,method,previous,methods,for,method,each,previous,methods,if,is,shadowed,method,each,return,true,return,false
TransactionalTestExecutionListener -> private boolean isShadowed(Method method, List<Method> previousMethods);1405698612;Determine if the supplied {@link Method method} is <em>shadowed</em> by_a method in the supplied {@link List list} of previous methods._<p>Note: This code has been borrowed from_{@link org.junit.internal.runners.TestClass#isShadowed(Method, List)}._@param method the method to check for shadowing_@param previousMethods the list of methods which have previously been processed_@return {@code true} if the supplied method is shadowed by a_method in the {@code previousMethods} list;private boolean isShadowed(Method method, List<Method> previousMethods) {_		for (Method each : previousMethods) {_			if (isShadowed(method, each)) {_				return true__			}_		}_		return false__	};determine,if,the,supplied,link,method,method,is,em,shadowed,em,by,a,method,in,the,supplied,link,list,list,of,previous,methods,p,note,this,code,has,been,borrowed,from,link,org,junit,internal,runners,test,class,is,shadowed,method,list,param,method,the,method,to,check,for,shadowing,param,previous,methods,the,list,of,methods,which,have,previously,been,processed,return,code,true,if,the,supplied,method,is,shadowed,by,a,method,in,the,code,previous,methods,list;private,boolean,is,shadowed,method,method,list,method,previous,methods,for,method,each,previous,methods,if,is,shadowed,method,each,return,true,return,false
TransactionalTestExecutionListener -> private boolean isShadowed(Method method, List<Method> previousMethods);1405759527;Determine if the supplied {@link Method method} is <em>shadowed</em> by_a method in the supplied {@link List list} of previous methods._<p>Note: This code has been borrowed from_{@link org.junit.internal.runners.TestClass#isShadowed(Method, List)}._@param method the method to check for shadowing_@param previousMethods the list of methods which have previously been processed_@return {@code true} if the supplied method is shadowed by a_method in the {@code previousMethods} list;private boolean isShadowed(Method method, List<Method> previousMethods) {_		for (Method each : previousMethods) {_			if (isShadowed(method, each)) {_				return true__			}_		}_		return false__	};determine,if,the,supplied,link,method,method,is,em,shadowed,em,by,a,method,in,the,supplied,link,list,list,of,previous,methods,p,note,this,code,has,been,borrowed,from,link,org,junit,internal,runners,test,class,is,shadowed,method,list,param,method,the,method,to,check,for,shadowing,param,previous,methods,the,list,of,methods,which,have,previously,been,processed,return,code,true,if,the,supplied,method,is,shadowed,by,a,method,in,the,code,previous,methods,list;private,boolean,is,shadowed,method,method,list,method,previous,methods,for,method,each,previous,methods,if,is,shadowed,method,each,return,true,return,false
TransactionalTestExecutionListener -> private boolean isShadowed(Method method, List<Method> previousMethods);1405759966;Determine if the supplied {@link Method method} is <em>shadowed</em> by_a method in the supplied {@link List list} of previous methods._<p>Note: This code has been borrowed from_{@link org.junit.internal.runners.TestClass#isShadowed(Method, List)}._@param method the method to check for shadowing_@param previousMethods the list of methods which have previously been processed_@return {@code true} if the supplied method is shadowed by a_method in the {@code previousMethods} list;private boolean isShadowed(Method method, List<Method> previousMethods) {_		for (Method each : previousMethods) {_			if (isShadowed(method, each)) {_				return true__			}_		}_		return false__	};determine,if,the,supplied,link,method,method,is,em,shadowed,em,by,a,method,in,the,supplied,link,list,list,of,previous,methods,p,note,this,code,has,been,borrowed,from,link,org,junit,internal,runners,test,class,is,shadowed,method,list,param,method,the,method,to,check,for,shadowing,param,previous,methods,the,list,of,methods,which,have,previously,been,processed,return,code,true,if,the,supplied,method,is,shadowed,by,a,method,in,the,code,previous,methods,list;private,boolean,is,shadowed,method,method,list,method,previous,methods,for,method,each,previous,methods,if,is,shadowed,method,each,return,true,return,false
TransactionalTestExecutionListener -> private boolean isShadowed(Method method, List<Method> previousMethods);1406218418;Determine if the supplied {@link Method method} is <em>shadowed</em> by_a method in the supplied {@link List list} of previous methods._<p>Note: This code has been borrowed from_{@link org.junit.internal.runners.TestClass#isShadowed(Method, List)}._@param method the method to check for shadowing_@param previousMethods the list of methods which have previously been processed_@return {@code true} if the supplied method is shadowed by a_method in the {@code previousMethods} list;private boolean isShadowed(Method method, List<Method> previousMethods) {_		for (Method each : previousMethods) {_			if (isShadowed(method, each)) {_				return true__			}_		}_		return false__	};determine,if,the,supplied,link,method,method,is,em,shadowed,em,by,a,method,in,the,supplied,link,list,list,of,previous,methods,p,note,this,code,has,been,borrowed,from,link,org,junit,internal,runners,test,class,is,shadowed,method,list,param,method,the,method,to,check,for,shadowing,param,previous,methods,the,list,of,methods,which,have,previously,been,processed,return,code,true,if,the,supplied,method,is,shadowed,by,a,method,in,the,code,previous,methods,list;private,boolean,is,shadowed,method,method,list,method,previous,methods,for,method,each,previous,methods,if,is,shadowed,method,each,return,true,return,false
TransactionalTestExecutionListener -> private boolean isShadowed(Method method, List<Method> previousMethods);1407419079;Determine if the supplied {@link Method method} is <em>shadowed</em> by_a method in the supplied {@link List list} of previous methods._<p>Note: This code has been borrowed from_{@link org.junit.internal.runners.TestClass#isShadowed(Method, List)}._@param method the method to check for shadowing_@param previousMethods the list of methods which have previously been processed_@return {@code true} if the supplied method is shadowed by a_method in the {@code previousMethods} list;private boolean isShadowed(Method method, List<Method> previousMethods) {_		for (Method each : previousMethods) {_			if (isShadowed(method, each)) {_				return true__			}_		}_		return false__	};determine,if,the,supplied,link,method,method,is,em,shadowed,em,by,a,method,in,the,supplied,link,list,list,of,previous,methods,p,note,this,code,has,been,borrowed,from,link,org,junit,internal,runners,test,class,is,shadowed,method,list,param,method,the,method,to,check,for,shadowing,param,previous,methods,the,list,of,methods,which,have,previously,been,processed,return,code,true,if,the,supplied,method,is,shadowed,by,a,method,in,the,code,previous,methods,list;private,boolean,is,shadowed,method,method,list,method,previous,methods,for,method,each,previous,methods,if,is,shadowed,method,each,return,true,return,false
TransactionalTestExecutionListener -> private boolean isShadowed(Method method, List<Method> previousMethods);1408048216;Determine if the supplied {@link Method method} is <em>shadowed</em> by_a method in the supplied {@link List list} of previous methods._<p>Note: This code has been borrowed from_{@link org.junit.internal.runners.TestClass#isShadowed(Method, List)}._@param method the method to check for shadowing_@param previousMethods the list of methods which have previously been processed_@return {@code true} if the supplied method is shadowed by a_method in the {@code previousMethods} list;private boolean isShadowed(Method method, List<Method> previousMethods) {_		for (Method each : previousMethods) {_			if (isShadowed(method, each)) {_				return true__			}_		}_		return false__	};determine,if,the,supplied,link,method,method,is,em,shadowed,em,by,a,method,in,the,supplied,link,list,list,of,previous,methods,p,note,this,code,has,been,borrowed,from,link,org,junit,internal,runners,test,class,is,shadowed,method,list,param,method,the,method,to,check,for,shadowing,param,previous,methods,the,list,of,methods,which,have,previously,been,processed,return,code,true,if,the,supplied,method,is,shadowed,by,a,method,in,the,code,previous,methods,list;private,boolean,is,shadowed,method,method,list,method,previous,methods,for,method,each,previous,methods,if,is,shadowed,method,each,return,true,return,false
TransactionalTestExecutionListener -> private boolean isShadowed(Method method, List<Method> previousMethods);1413848647;Determine if the supplied {@link Method method} is <em>shadowed</em> by_a method in the supplied {@link List list} of previous methods._<p>Note: This code has been borrowed from_{@link org.junit.internal.runners.TestClass#isShadowed(Method, List)}._@param method the method to check for shadowing_@param previousMethods the list of methods which have previously been processed_@return {@code true} if the supplied method is shadowed by a_method in the {@code previousMethods} list;private boolean isShadowed(Method method, List<Method> previousMethods) {_		for (Method each : previousMethods) {_			if (isShadowed(method, each)) {_				return true__			}_		}_		return false__	};determine,if,the,supplied,link,method,method,is,em,shadowed,em,by,a,method,in,the,supplied,link,list,list,of,previous,methods,p,note,this,code,has,been,borrowed,from,link,org,junit,internal,runners,test,class,is,shadowed,method,list,param,method,the,method,to,check,for,shadowing,param,previous,methods,the,list,of,methods,which,have,previously,been,processed,return,code,true,if,the,supplied,method,is,shadowed,by,a,method,in,the,code,previous,methods,list;private,boolean,is,shadowed,method,method,list,method,previous,methods,for,method,each,previous,methods,if,is,shadowed,method,each,return,true,return,false
TransactionalTestExecutionListener -> private boolean isShadowed(Method method, List<Method> previousMethods);1431568199;Determine if the supplied {@link Method method} is <em>shadowed</em> by_a method in the supplied {@link List list} of previous methods._<p>Note: This code has been borrowed from_{@link org.junit.internal.runners.TestClass#isShadowed(Method, List)}._@param method the method to check for shadowing_@param previousMethods the list of methods which have previously been processed_@return {@code true} if the supplied method is shadowed by a_method in the {@code previousMethods} list;private boolean isShadowed(Method method, List<Method> previousMethods) {_		for (Method each : previousMethods) {_			if (isShadowed(method, each)) {_				return true__			}_		}_		return false__	};determine,if,the,supplied,link,method,method,is,em,shadowed,em,by,a,method,in,the,supplied,link,list,list,of,previous,methods,p,note,this,code,has,been,borrowed,from,link,org,junit,internal,runners,test,class,is,shadowed,method,list,param,method,the,method,to,check,for,shadowing,param,previous,methods,the,list,of,methods,which,have,previously,been,processed,return,code,true,if,the,supplied,method,is,shadowed,by,a,method,in,the,code,previous,methods,list;private,boolean,is,shadowed,method,method,list,method,previous,methods,for,method,each,previous,methods,if,is,shadowed,method,each,return,true,return,false
TransactionalTestExecutionListener -> private boolean isShadowed(Method method, List<Method> previousMethods);1432125256;Determine if the supplied {@link Method method} is <em>shadowed</em> by_a method in the supplied {@link List list} of previous methods._<p>Note: This code has been borrowed from_{@link org.junit.internal.runners.TestClass#isShadowed(Method, List)}._@param method the method to check for shadowing_@param previousMethods the list of methods which have previously been processed_@return {@code true} if the supplied method is shadowed by a_method in the {@code previousMethods} list;private boolean isShadowed(Method method, List<Method> previousMethods) {_		for (Method each : previousMethods) {_			if (isShadowed(method, each)) {_				return true__			}_		}_		return false__	};determine,if,the,supplied,link,method,method,is,em,shadowed,em,by,a,method,in,the,supplied,link,list,list,of,previous,methods,p,note,this,code,has,been,borrowed,from,link,org,junit,internal,runners,test,class,is,shadowed,method,list,param,method,the,method,to,check,for,shadowing,param,previous,methods,the,list,of,methods,which,have,previously,been,processed,return,code,true,if,the,supplied,method,is,shadowed,by,a,method,in,the,code,previous,methods,list;private,boolean,is,shadowed,method,method,list,method,previous,methods,for,method,each,previous,methods,if,is,shadowed,method,each,return,true,return,false
TransactionalTestExecutionListener -> private boolean isShadowed(Method method, List<Method> previousMethods);1432856630;Determine if the supplied {@link Method method} is <em>shadowed</em> by_a method in the supplied {@link List list} of previous methods._<p>Note: This code has been borrowed from_{@link org.junit.internal.runners.TestClass#isShadowed(Method, List)}._@param method the method to check for shadowing_@param previousMethods the list of methods which have previously been processed_@return {@code true} if the supplied method is shadowed by a_method in the {@code previousMethods} list;private boolean isShadowed(Method method, List<Method> previousMethods) {_		for (Method each : previousMethods) {_			if (isShadowed(method, each)) {_				return true__			}_		}_		return false__	};determine,if,the,supplied,link,method,method,is,em,shadowed,em,by,a,method,in,the,supplied,link,list,list,of,previous,methods,p,note,this,code,has,been,borrowed,from,link,org,junit,internal,runners,test,class,is,shadowed,method,list,param,method,the,method,to,check,for,shadowing,param,previous,methods,the,list,of,methods,which,have,previously,been,processed,return,code,true,if,the,supplied,method,is,shadowed,by,a,method,in,the,code,previous,methods,list;private,boolean,is,shadowed,method,method,list,method,previous,methods,for,method,each,previous,methods,if,is,shadowed,method,each,return,true,return,false
TransactionalTestExecutionListener -> private boolean isShadowed(Method method, List<Method> previousMethods);1434234880;Determine if the supplied {@link Method method} is <em>shadowed</em> by_a method in the supplied {@link List list} of previous methods._<p>Note: This code has been borrowed from_{@link org.junit.internal.runners.TestClass#isShadowed(Method, List)}._@param method the method to check for shadowing_@param previousMethods the list of methods which have previously been processed_@return {@code true} if the supplied method is shadowed by a_method in the {@code previousMethods} list;private boolean isShadowed(Method method, List<Method> previousMethods) {_		for (Method each : previousMethods) {_			if (isShadowed(method, each)) {_				return true__			}_		}_		return false__	};determine,if,the,supplied,link,method,method,is,em,shadowed,em,by,a,method,in,the,supplied,link,list,list,of,previous,methods,p,note,this,code,has,been,borrowed,from,link,org,junit,internal,runners,test,class,is,shadowed,method,list,param,method,the,method,to,check,for,shadowing,param,previous,methods,the,list,of,methods,which,have,previously,been,processed,return,code,true,if,the,supplied,method,is,shadowed,by,a,method,in,the,code,previous,methods,list;private,boolean,is,shadowed,method,method,list,method,previous,methods,for,method,each,previous,methods,if,is,shadowed,method,each,return,true,return,false
TransactionalTestExecutionListener -> private boolean isShadowed(Method method, List<Method> previousMethods);1434720443;Determine if the supplied {@link Method method} is <em>shadowed</em> by_a method in the supplied {@link List list} of previous methods._<p>Note: This code has been borrowed from_{@link org.junit.internal.runners.TestClass#isShadowed(Method, List)}._@param method the method to check for shadowing_@param previousMethods the list of methods which have previously been processed_@return {@code true} if the supplied method is shadowed by a_method in the {@code previousMethods} list;private boolean isShadowed(Method method, List<Method> previousMethods) {_		for (Method each : previousMethods) {_			if (isShadowed(method, each)) {_				return true__			}_		}_		return false__	};determine,if,the,supplied,link,method,method,is,em,shadowed,em,by,a,method,in,the,supplied,link,list,list,of,previous,methods,p,note,this,code,has,been,borrowed,from,link,org,junit,internal,runners,test,class,is,shadowed,method,list,param,method,the,method,to,check,for,shadowing,param,previous,methods,the,list,of,methods,which,have,previously,been,processed,return,code,true,if,the,supplied,method,is,shadowed,by,a,method,in,the,code,previous,methods,list;private,boolean,is,shadowed,method,method,list,method,previous,methods,for,method,each,previous,methods,if,is,shadowed,method,each,return,true,return,false
TransactionalTestExecutionListener -> private boolean isShadowed(Method method, List<Method> previousMethods);1434817656;Determine if the supplied {@link Method method} is <em>shadowed</em> by_a method in the supplied {@link List list} of previous methods._<p>Note: This code has been borrowed from_{@link org.junit.internal.runners.TestClass#isShadowed(Method, List)}._@param method the method to check for shadowing_@param previousMethods the list of methods which have previously been processed_@return {@code true} if the supplied method is shadowed by a_method in the {@code previousMethods} list;private boolean isShadowed(Method method, List<Method> previousMethods) {_		for (Method each : previousMethods) {_			if (isShadowed(method, each)) {_				return true__			}_		}_		return false__	};determine,if,the,supplied,link,method,method,is,em,shadowed,em,by,a,method,in,the,supplied,link,list,list,of,previous,methods,p,note,this,code,has,been,borrowed,from,link,org,junit,internal,runners,test,class,is,shadowed,method,list,param,method,the,method,to,check,for,shadowing,param,previous,methods,the,list,of,methods,which,have,previously,been,processed,return,code,true,if,the,supplied,method,is,shadowed,by,a,method,in,the,code,previous,methods,list;private,boolean,is,shadowed,method,method,list,method,previous,methods,for,method,each,previous,methods,if,is,shadowed,method,each,return,true,return,false
TransactionalTestExecutionListener -> private boolean isShadowed(Method method, List<Method> previousMethods);1437841346;Determine if the supplied {@link Method method} is <em>shadowed</em> by_a method in the supplied {@link List list} of previous methods._<p>Note: This code has been borrowed from_{@link org.junit.internal.runners.TestClass#isShadowed(Method, List)}._@param method the method to check for shadowing_@param previousMethods the list of methods which have previously been processed_@return {@code true} if the supplied method is shadowed by a_method in the {@code previousMethods} list;private boolean isShadowed(Method method, List<Method> previousMethods) {_		for (Method each : previousMethods) {_			if (isShadowed(method, each)) {_				return true__			}_		}_		return false__	};determine,if,the,supplied,link,method,method,is,em,shadowed,em,by,a,method,in,the,supplied,link,list,list,of,previous,methods,p,note,this,code,has,been,borrowed,from,link,org,junit,internal,runners,test,class,is,shadowed,method,list,param,method,the,method,to,check,for,shadowing,param,previous,methods,the,list,of,methods,which,have,previously,been,processed,return,code,true,if,the,supplied,method,is,shadowed,by,a,method,in,the,code,previous,methods,list;private,boolean,is,shadowed,method,method,list,method,previous,methods,for,method,each,previous,methods,if,is,shadowed,method,each,return,true,return,false
TransactionalTestExecutionListener -> private boolean isShadowed(Method method, List<Method> previousMethods);1437851372;Determine if the supplied {@link Method method} is <em>shadowed</em> by_a method in the supplied {@link List list} of previous methods._<p>Note: This code has been borrowed from_{@link org.junit.internal.runners.TestClass#isShadowed(Method, List)}._@param method the method to check for shadowing_@param previousMethods the list of methods which have previously been processed_@return {@code true} if the supplied method is shadowed by a_method in the {@code previousMethods} list;private boolean isShadowed(Method method, List<Method> previousMethods) {_		for (Method each : previousMethods) {_			if (isShadowed(method, each)) {_				return true__			}_		}_		return false__	};determine,if,the,supplied,link,method,method,is,em,shadowed,em,by,a,method,in,the,supplied,link,list,list,of,previous,methods,p,note,this,code,has,been,borrowed,from,link,org,junit,internal,runners,test,class,is,shadowed,method,list,param,method,the,method,to,check,for,shadowing,param,previous,methods,the,list,of,methods,which,have,previously,been,processed,return,code,true,if,the,supplied,method,is,shadowed,by,a,method,in,the,code,previous,methods,list;private,boolean,is,shadowed,method,method,list,method,previous,methods,for,method,each,previous,methods,if,is,shadowed,method,each,return,true,return,false
TransactionalTestExecutionListener -> private boolean isShadowed(Method method, List<Method> previousMethods);1437852597;Determine if the supplied {@link Method method} is <em>shadowed</em> by_a method in the supplied {@link List list} of previous methods._<p>Note: This code has been borrowed from_{@link org.junit.internal.runners.TestClass#isShadowed(Method, List)}._@param method the method to check for shadowing_@param previousMethods the list of methods which have previously been processed_@return {@code true} if the supplied method is shadowed by a_method in the {@code previousMethods} list;private boolean isShadowed(Method method, List<Method> previousMethods) {_		for (Method each : previousMethods) {_			if (isShadowed(method, each)) {_				return true__			}_		}_		return false__	};determine,if,the,supplied,link,method,method,is,em,shadowed,em,by,a,method,in,the,supplied,link,list,list,of,previous,methods,p,note,this,code,has,been,borrowed,from,link,org,junit,internal,runners,test,class,is,shadowed,method,list,param,method,the,method,to,check,for,shadowing,param,previous,methods,the,list,of,methods,which,have,previously,been,processed,return,code,true,if,the,supplied,method,is,shadowed,by,a,method,in,the,code,previous,methods,list;private,boolean,is,shadowed,method,method,list,method,previous,methods,for,method,each,previous,methods,if,is,shadowed,method,each,return,true,return,false
TransactionalTestExecutionListener -> private boolean isShadowed(Method method, List<Method> previousMethods);1454507787;Determine if the supplied {@link Method method} is <em>shadowed</em> by_a method in the supplied {@link List list} of previous methods._<p>Note: This code has been borrowed from_{@link org.junit.internal.runners.TestClass#isShadowed(Method, List)}._@param method the method to check for shadowing_@param previousMethods the list of methods which have previously been processed_@return {@code true} if the supplied method is shadowed by a_method in the {@code previousMethods} list;private boolean isShadowed(Method method, List<Method> previousMethods) {_		for (Method each : previousMethods) {_			if (isShadowed(method, each)) {_				return true__			}_		}_		return false__	};determine,if,the,supplied,link,method,method,is,em,shadowed,em,by,a,method,in,the,supplied,link,list,list,of,previous,methods,p,note,this,code,has,been,borrowed,from,link,org,junit,internal,runners,test,class,is,shadowed,method,list,param,method,the,method,to,check,for,shadowing,param,previous,methods,the,list,of,methods,which,have,previously,been,processed,return,code,true,if,the,supplied,method,is,shadowed,by,a,method,in,the,code,previous,methods,list;private,boolean,is,shadowed,method,method,list,method,previous,methods,for,method,each,previous,methods,if,is,shadowed,method,each,return,true,return,false
TransactionalTestExecutionListener -> private boolean isShadowed(Method method, List<Method> previousMethods);1456702967;Determine if the supplied {@link Method method} is <em>shadowed</em> by_a method in the supplied {@link List list} of previous methods._<p>Note: This code has been borrowed from_{@link org.junit.internal.runners.TestClass#isShadowed(Method, List)}._@param method the method to check for shadowing_@param previousMethods the list of methods which have previously been processed_@return {@code true} if the supplied method is shadowed by a_method in the {@code previousMethods} list;private boolean isShadowed(Method method, List<Method> previousMethods) {_		for (Method each : previousMethods) {_			if (isShadowed(method, each)) {_				return true__			}_		}_		return false__	};determine,if,the,supplied,link,method,method,is,em,shadowed,em,by,a,method,in,the,supplied,link,list,list,of,previous,methods,p,note,this,code,has,been,borrowed,from,link,org,junit,internal,runners,test,class,is,shadowed,method,list,param,method,the,method,to,check,for,shadowing,param,previous,methods,the,list,of,methods,which,have,previously,been,processed,return,code,true,if,the,supplied,method,is,shadowed,by,a,method,in,the,code,previous,methods,list;private,boolean,is,shadowed,method,method,list,method,previous,methods,for,method,each,previous,methods,if,is,shadowed,method,each,return,true,return,false
TransactionalTestExecutionListener -> private boolean isShadowed(Method method, List<Method> previousMethods);1456756222;Determine if the supplied {@link Method method} is <em>shadowed</em> by_a method in the supplied {@link List list} of previous methods._<p>Note: This code has been borrowed from_{@link org.junit.internal.runners.TestClass#isShadowed(Method, List)}._@param method the method to check for shadowing_@param previousMethods the list of methods which have previously been processed_@return {@code true} if the supplied method is shadowed by a_method in the {@code previousMethods} list;private boolean isShadowed(Method method, List<Method> previousMethods) {_		for (Method each : previousMethods) {_			if (isShadowed(method, each)) {_				return true__			}_		}_		return false__	};determine,if,the,supplied,link,method,method,is,em,shadowed,em,by,a,method,in,the,supplied,link,list,list,of,previous,methods,p,note,this,code,has,been,borrowed,from,link,org,junit,internal,runners,test,class,is,shadowed,method,list,param,method,the,method,to,check,for,shadowing,param,previous,methods,the,list,of,methods,which,have,previously,been,processed,return,code,true,if,the,supplied,method,is,shadowed,by,a,method,in,the,code,previous,methods,list;private,boolean,is,shadowed,method,method,list,method,previous,methods,for,method,each,previous,methods,if,is,shadowed,method,each,return,true,return,false
TransactionalTestExecutionListener -> private boolean isShadowed(Method method, List<Method> previousMethods);1456756222;Determine if the supplied {@link Method method} is <em>shadowed</em> by_a method in the supplied {@link List list} of previous methods._<p>Note: This code has been borrowed from_{@link org.junit.internal.runners.TestClass#isShadowed(Method, List)}._@param method the method to check for shadowing_@param previousMethods the list of methods which have previously been processed_@return {@code true} if the supplied method is shadowed by a_method in the {@code previousMethods} list;private boolean isShadowed(Method method, List<Method> previousMethods) {_		for (Method each : previousMethods) {_			if (isShadowed(method, each)) {_				return true__			}_		}_		return false__	};determine,if,the,supplied,link,method,method,is,em,shadowed,em,by,a,method,in,the,supplied,link,list,list,of,previous,methods,p,note,this,code,has,been,borrowed,from,link,org,junit,internal,runners,test,class,is,shadowed,method,list,param,method,the,method,to,check,for,shadowing,param,previous,methods,the,list,of,methods,which,have,previously,been,processed,return,code,true,if,the,supplied,method,is,shadowed,by,a,method,in,the,code,previous,methods,list;private,boolean,is,shadowed,method,method,list,method,previous,methods,for,method,each,previous,methods,if,is,shadowed,method,each,return,true,return,false
TransactionalTestExecutionListener -> private boolean isShadowed(Method method, List<Method> previousMethods);1458754760;Determine if the supplied {@link Method method} is <em>shadowed</em> by_a method in the supplied {@link List list} of previous methods._<p>Note: This code has been borrowed from_{@link org.junit.internal.runners.TestClass#isShadowed(Method, List)}._@param method the method to check for shadowing_@param previousMethods the list of methods which have previously been processed_@return {@code true} if the supplied method is shadowed by a_method in the {@code previousMethods} list;private boolean isShadowed(Method method, List<Method> previousMethods) {_		for (Method each : previousMethods) {_			if (isShadowed(method, each)) {_				return true__			}_		}_		return false__	};determine,if,the,supplied,link,method,method,is,em,shadowed,em,by,a,method,in,the,supplied,link,list,list,of,previous,methods,p,note,this,code,has,been,borrowed,from,link,org,junit,internal,runners,test,class,is,shadowed,method,list,param,method,the,method,to,check,for,shadowing,param,previous,methods,the,list,of,methods,which,have,previously,been,processed,return,code,true,if,the,supplied,method,is,shadowed,by,a,method,in,the,code,previous,methods,list;private,boolean,is,shadowed,method,method,list,method,previous,methods,for,method,each,previous,methods,if,is,shadowed,method,each,return,true,return,false
TransactionalTestExecutionListener -> private void startNewTransaction(TestContext testContext, TransactionContext txContext) throws Exception;1328020251;Start a new transaction for the supplied {@link TestContext test context}._<p>Only call this method if {@link #endTransaction} has been called or if no_transaction has been previously started._@param testContext the current test context_@throws TransactionException if starting the transaction fails_@throws Exception if an error occurs while retrieving the transaction manager;private void startNewTransaction(TestContext testContext, TransactionContext txContext) throws Exception {_		txContext.startTransaction()__		++this.transactionsStarted__		if (logger.isInfoEnabled()) {_			logger.info("Began transaction (" + this.transactionsStarted + "): transaction manager ["_					+ txContext.transactionManager + "]_ rollback [" + isRollback(testContext) + "]")__		}_	};start,a,new,transaction,for,the,supplied,link,test,context,test,context,p,only,call,this,method,if,link,end,transaction,has,been,called,or,if,no,transaction,has,been,previously,started,param,test,context,the,current,test,context,throws,transaction,exception,if,starting,the,transaction,fails,throws,exception,if,an,error,occurs,while,retrieving,the,transaction,manager;private,void,start,new,transaction,test,context,test,context,transaction,context,tx,context,throws,exception,tx,context,start,transaction,this,transactions,started,if,logger,is,info,enabled,logger,info,began,transaction,this,transactions,started,transaction,manager,tx,context,transaction,manager,rollback,is,rollback,test,context
TransactionalTestExecutionListener -> private void startNewTransaction(TestContext testContext, TransactionContext txContext) throws Exception;1337516454;Start a new transaction for the supplied {@link TestContext test context}._<p>Only call this method if {@link #endTransaction} has been called or if no_transaction has been previously started._@param testContext the current test context_@throws TransactionException if starting the transaction fails_@throws Exception if an error occurs while retrieving the transaction manager;private void startNewTransaction(TestContext testContext, TransactionContext txContext) throws Exception {_		txContext.startTransaction()__		++this.transactionsStarted__		if (logger.isInfoEnabled()) {_			logger.info("Began transaction (" + this.transactionsStarted + "): transaction manager ["_					+ txContext.transactionManager + "]_ rollback [" + isRollback(testContext) + "]")__		}_	};start,a,new,transaction,for,the,supplied,link,test,context,test,context,p,only,call,this,method,if,link,end,transaction,has,been,called,or,if,no,transaction,has,been,previously,started,param,test,context,the,current,test,context,throws,transaction,exception,if,starting,the,transaction,fails,throws,exception,if,an,error,occurs,while,retrieving,the,transaction,manager;private,void,start,new,transaction,test,context,test,context,transaction,context,tx,context,throws,exception,tx,context,start,transaction,this,transactions,started,if,logger,is,info,enabled,logger,info,began,transaction,this,transactions,started,transaction,manager,tx,context,transaction,manager,rollback,is,rollback,test,context
TransactionalTestExecutionListener -> private void startNewTransaction(TestContext testContext, TransactionContext txContext) throws Exception;1338031377;Start a new transaction for the supplied {@link TestContext test context}._<p>Only call this method if {@link #endTransaction} has been called or if no_transaction has been previously started._@param testContext the current test context_@throws TransactionException if starting the transaction fails_@throws Exception if an error occurs while retrieving the transaction manager;private void startNewTransaction(TestContext testContext, TransactionContext txContext) throws Exception {_		txContext.startTransaction()__		++this.transactionsStarted__		if (logger.isInfoEnabled()) {_			logger.info("Began transaction (" + this.transactionsStarted + "): transaction manager ["_					+ txContext.transactionManager + "]_ rollback [" + isRollback(testContext) + "]")__		}_	};start,a,new,transaction,for,the,supplied,link,test,context,test,context,p,only,call,this,method,if,link,end,transaction,has,been,called,or,if,no,transaction,has,been,previously,started,param,test,context,the,current,test,context,throws,transaction,exception,if,starting,the,transaction,fails,throws,exception,if,an,error,occurs,while,retrieving,the,transaction,manager;private,void,start,new,transaction,test,context,test,context,transaction,context,tx,context,throws,exception,tx,context,start,transaction,this,transactions,started,if,logger,is,info,enabled,logger,info,began,transaction,this,transactions,started,transaction,manager,tx,context,transaction,manager,rollback,is,rollback,test,context
TransactionalTestExecutionListener -> private void startNewTransaction(TestContext testContext, TransactionContext txContext) throws Exception;1343426806;Start a new transaction for the supplied {@link TestContext test context}._<p>Only call this method if {@link #endTransaction} has been called or if no_transaction has been previously started._@param testContext the current test context_@throws TransactionException if starting the transaction fails_@throws Exception if an error occurs while retrieving the transaction manager;private void startNewTransaction(TestContext testContext, TransactionContext txContext) throws Exception {_		txContext.startTransaction()__		++this.transactionsStarted__		if (logger.isInfoEnabled()) {_			logger.info("Began transaction (" + this.transactionsStarted + "): transaction manager ["_					+ txContext.transactionManager + "]_ rollback [" + isRollback(testContext) + "]")__		}_	};start,a,new,transaction,for,the,supplied,link,test,context,test,context,p,only,call,this,method,if,link,end,transaction,has,been,called,or,if,no,transaction,has,been,previously,started,param,test,context,the,current,test,context,throws,transaction,exception,if,starting,the,transaction,fails,throws,exception,if,an,error,occurs,while,retrieving,the,transaction,manager;private,void,start,new,transaction,test,context,test,context,transaction,context,tx,context,throws,exception,tx,context,start,transaction,this,transactions,started,if,logger,is,info,enabled,logger,info,began,transaction,this,transactions,started,transaction,manager,tx,context,transaction,manager,rollback,is,rollback,test,context
TransactionalTestExecutionListener -> private void startNewTransaction(TestContext testContext, TransactionContext txContext) throws Exception;1343431472;Start a new transaction for the supplied {@link TestContext test context}._<p>Only call this method if {@link #endTransaction} has been called or if no_transaction has been previously started._@param testContext the current test context_@throws TransactionException if starting the transaction fails_@throws Exception if an error occurs while retrieving the transaction manager;private void startNewTransaction(TestContext testContext, TransactionContext txContext) throws Exception {_		txContext.startTransaction()__		++this.transactionsStarted__		if (logger.isInfoEnabled()) {_			logger.info("Began transaction (" + this.transactionsStarted + "): transaction manager ["_					+ txContext.transactionManager + "]_ rollback [" + isRollback(testContext) + "]")__		}_	};start,a,new,transaction,for,the,supplied,link,test,context,test,context,p,only,call,this,method,if,link,end,transaction,has,been,called,or,if,no,transaction,has,been,previously,started,param,test,context,the,current,test,context,throws,transaction,exception,if,starting,the,transaction,fails,throws,exception,if,an,error,occurs,while,retrieving,the,transaction,manager;private,void,start,new,transaction,test,context,test,context,transaction,context,tx,context,throws,exception,tx,context,start,transaction,this,transactions,started,if,logger,is,info,enabled,logger,info,began,transaction,this,transactions,started,transaction,manager,tx,context,transaction,manager,rollback,is,rollback,test,context
TransactionalTestExecutionListener -> private void startNewTransaction(TestContext testContext, TransactionContext txContext) throws Exception;1354571539;Start a new transaction for the supplied {@link TestContext test context}._<p>Only call this method if {@link #endTransaction} has been called or if no_transaction has been previously started._@param testContext the current test context_@throws TransactionException if starting the transaction fails_@throws Exception if an error occurs while retrieving the transaction manager;private void startNewTransaction(TestContext testContext, TransactionContext txContext) throws Exception {_		txContext.startTransaction()__		++this.transactionsStarted__		if (logger.isInfoEnabled()) {_			logger.info("Began transaction (" + this.transactionsStarted + "): transaction manager ["_					+ txContext.transactionManager + "]_ rollback [" + isRollback(testContext) + "]")__		}_	};start,a,new,transaction,for,the,supplied,link,test,context,test,context,p,only,call,this,method,if,link,end,transaction,has,been,called,or,if,no,transaction,has,been,previously,started,param,test,context,the,current,test,context,throws,transaction,exception,if,starting,the,transaction,fails,throws,exception,if,an,error,occurs,while,retrieving,the,transaction,manager;private,void,start,new,transaction,test,context,test,context,transaction,context,tx,context,throws,exception,tx,context,start,transaction,this,transactions,started,if,logger,is,info,enabled,logger,info,began,transaction,this,transactions,started,transaction,manager,tx,context,transaction,manager,rollback,is,rollback,test,context
TransactionalTestExecutionListener -> private void startNewTransaction(TestContext testContext, TransactionContext txContext) throws Exception;1355352386;Start a new transaction for the supplied {@link TestContext test context}._<p>Only call this method if {@link #endTransaction} has been called or if no_transaction has been previously started._@param testContext the current test context_@throws TransactionException if starting the transaction fails_@throws Exception if an error occurs while retrieving the transaction manager;private void startNewTransaction(TestContext testContext, TransactionContext txContext) throws Exception {_		txContext.startTransaction()__		++this.transactionsStarted__		if (logger.isInfoEnabled()) {_			logger.info("Began transaction (" + this.transactionsStarted + "): transaction manager ["_					+ txContext.transactionManager + "]_ rollback [" + isRollback(testContext) + "]")__		}_	};start,a,new,transaction,for,the,supplied,link,test,context,test,context,p,only,call,this,method,if,link,end,transaction,has,been,called,or,if,no,transaction,has,been,previously,started,param,test,context,the,current,test,context,throws,transaction,exception,if,starting,the,transaction,fails,throws,exception,if,an,error,occurs,while,retrieving,the,transaction,manager;private,void,start,new,transaction,test,context,test,context,transaction,context,tx,context,throws,exception,tx,context,start,transaction,this,transactions,started,if,logger,is,info,enabled,logger,info,began,transaction,this,transactions,started,transaction,manager,tx,context,transaction,manager,rollback,is,rollback,test,context
TransactionalTestExecutionListener -> private void startNewTransaction(TestContext testContext, TransactionContext txContext) throws Exception;1356735495;Start a new transaction for the supplied {@link TestContext test context}._<p>Only call this method if {@link #endTransaction} has been called or if no_transaction has been previously started._@param testContext the current test context_@throws TransactionException if starting the transaction fails_@throws Exception if an error occurs while retrieving the transaction manager;private void startNewTransaction(TestContext testContext, TransactionContext txContext) throws Exception {_		txContext.startTransaction()__		++this.transactionsStarted__		if (logger.isInfoEnabled()) {_			logger.info("Began transaction (" + this.transactionsStarted + "): transaction manager ["_					+ txContext.transactionManager + "]_ rollback [" + isRollback(testContext) + "]")__		}_	};start,a,new,transaction,for,the,supplied,link,test,context,test,context,p,only,call,this,method,if,link,end,transaction,has,been,called,or,if,no,transaction,has,been,previously,started,param,test,context,the,current,test,context,throws,transaction,exception,if,starting,the,transaction,fails,throws,exception,if,an,error,occurs,while,retrieving,the,transaction,manager;private,void,start,new,transaction,test,context,test,context,transaction,context,tx,context,throws,exception,tx,context,start,transaction,this,transactions,started,if,logger,is,info,enabled,logger,info,began,transaction,this,transactions,started,transaction,manager,tx,context,transaction,manager,rollback,is,rollback,test,context
TransactionalTestExecutionListener -> private void startNewTransaction(TestContext testContext, TransactionContext txContext) throws Exception;1357119239;Start a new transaction for the supplied {@link TestContext test context}._<p>Only call this method if {@link #endTransaction} has been called or if no_transaction has been previously started._@param testContext the current test context_@throws TransactionException if starting the transaction fails_@throws Exception if an error occurs while retrieving the transaction manager;private void startNewTransaction(TestContext testContext, TransactionContext txContext) throws Exception {_		txContext.startTransaction()__		++this.transactionsStarted__		if (logger.isInfoEnabled()) {_			logger.info("Began transaction (" + this.transactionsStarted + "): transaction manager ["_					+ txContext.transactionManager + "]_ rollback [" + isRollback(testContext) + "]")__		}_	};start,a,new,transaction,for,the,supplied,link,test,context,test,context,p,only,call,this,method,if,link,end,transaction,has,been,called,or,if,no,transaction,has,been,previously,started,param,test,context,the,current,test,context,throws,transaction,exception,if,starting,the,transaction,fails,throws,exception,if,an,error,occurs,while,retrieving,the,transaction,manager;private,void,start,new,transaction,test,context,test,context,transaction,context,tx,context,throws,exception,tx,context,start,transaction,this,transactions,started,if,logger,is,info,enabled,logger,info,began,transaction,this,transactions,started,transaction,manager,tx,context,transaction,manager,rollback,is,rollback,test,context
TransactionalTestExecutionListener -> private void startNewTransaction(TestContext testContext, TransactionContext txContext) throws Exception;1367163114;Start a new transaction for the supplied {@link TestContext test context}._<p>Only call this method if {@link #endTransaction} has been called or if no_transaction has been previously started._@param testContext the current test context_@throws TransactionException if starting the transaction fails_@throws Exception if an error occurs while retrieving the transaction manager;private void startNewTransaction(TestContext testContext, TransactionContext txContext) throws Exception {_		txContext.startTransaction()__		++this.transactionsStarted__		if (logger.isInfoEnabled()) {_			logger.info("Began transaction (" + this.transactionsStarted + "): transaction manager ["_					+ txContext.transactionManager + "]_ rollback [" + isRollback(testContext) + "]")__		}_	};start,a,new,transaction,for,the,supplied,link,test,context,test,context,p,only,call,this,method,if,link,end,transaction,has,been,called,or,if,no,transaction,has,been,previously,started,param,test,context,the,current,test,context,throws,transaction,exception,if,starting,the,transaction,fails,throws,exception,if,an,error,occurs,while,retrieving,the,transaction,manager;private,void,start,new,transaction,test,context,test,context,transaction,context,tx,context,throws,exception,tx,context,start,transaction,this,transactions,started,if,logger,is,info,enabled,logger,info,began,transaction,this,transactions,started,transaction,manager,tx,context,transaction,manager,rollback,is,rollback,test,context
TransactionalTestExecutionListener -> private void startNewTransaction(TestContext testContext, TransactionContext txContext) throws Exception;1367873075;Start a new transaction for the supplied {@link TestContext test context}._<p>Only call this method if {@link #endTransaction} has been called or if no_transaction has been previously started._@param testContext the current test context_@throws TransactionException if starting the transaction fails_@throws Exception if an error occurs while retrieving the transaction manager;private void startNewTransaction(TestContext testContext, TransactionContext txContext) throws Exception {_		txContext.startTransaction()__		++this.transactionsStarted__		if (logger.isInfoEnabled()) {_			logger.info("Began transaction (" + this.transactionsStarted + "): transaction manager ["_					+ txContext.transactionManager + "]_ rollback [" + isRollback(testContext) + "]")__		}_	};start,a,new,transaction,for,the,supplied,link,test,context,test,context,p,only,call,this,method,if,link,end,transaction,has,been,called,or,if,no,transaction,has,been,previously,started,param,test,context,the,current,test,context,throws,transaction,exception,if,starting,the,transaction,fails,throws,exception,if,an,error,occurs,while,retrieving,the,transaction,manager;private,void,start,new,transaction,test,context,test,context,transaction,context,tx,context,throws,exception,tx,context,start,transaction,this,transactions,started,if,logger,is,info,enabled,logger,info,began,transaction,this,transactions,started,transaction,manager,tx,context,transaction,manager,rollback,is,rollback,test,context
TransactionalTestExecutionListener -> private void startNewTransaction(TestContext testContext, TransactionContext txContext) throws Exception;1368482696;Start a new transaction for the supplied {@link TestContext test context}._<p>Only call this method if {@link #endTransaction} has been called or if no_transaction has been previously started._@param testContext the current test context_@throws TransactionException if starting the transaction fails_@throws Exception if an error occurs while retrieving the transaction manager;private void startNewTransaction(TestContext testContext, TransactionContext txContext) throws Exception {_		txContext.startTransaction()__		++this.transactionsStarted__		if (logger.isInfoEnabled()) {_			logger.info("Began transaction (" + this.transactionsStarted + "): transaction manager ["_					+ txContext.transactionManager + "]_ rollback [" + isRollback(testContext) + "]")__		}_	};start,a,new,transaction,for,the,supplied,link,test,context,test,context,p,only,call,this,method,if,link,end,transaction,has,been,called,or,if,no,transaction,has,been,previously,started,param,test,context,the,current,test,context,throws,transaction,exception,if,starting,the,transaction,fails,throws,exception,if,an,error,occurs,while,retrieving,the,transaction,manager;private,void,start,new,transaction,test,context,test,context,transaction,context,tx,context,throws,exception,tx,context,start,transaction,this,transactions,started,if,logger,is,info,enabled,logger,info,began,transaction,this,transactions,started,transaction,manager,tx,context,transaction,manager,rollback,is,rollback,test,context
TransactionalTestExecutionListener -> private void startNewTransaction(TestContext testContext, TransactionContext txContext) throws Exception;1382920864;Start a new transaction for the supplied {@link TestContext test context}._<p>Only call this method if {@link #endTransaction} has been called or if no_transaction has been previously started._@param testContext the current test context_@throws TransactionException if starting the transaction fails_@throws Exception if an error occurs while retrieving the transaction manager;private void startNewTransaction(TestContext testContext, TransactionContext txContext) throws Exception {_		txContext.startTransaction()__		++this.transactionsStarted__		if (logger.isInfoEnabled()) {_			logger.info("Began transaction (" + this.transactionsStarted + "): transaction manager ["_					+ txContext.transactionManager + "]_ rollback [" + isRollback(testContext) + "]")__		}_	};start,a,new,transaction,for,the,supplied,link,test,context,test,context,p,only,call,this,method,if,link,end,transaction,has,been,called,or,if,no,transaction,has,been,previously,started,param,test,context,the,current,test,context,throws,transaction,exception,if,starting,the,transaction,fails,throws,exception,if,an,error,occurs,while,retrieving,the,transaction,manager;private,void,start,new,transaction,test,context,test,context,transaction,context,tx,context,throws,exception,tx,context,start,transaction,this,transactions,started,if,logger,is,info,enabled,logger,info,began,transaction,this,transactions,started,transaction,manager,tx,context,transaction,manager,rollback,is,rollback,test,context
TransactionalTestExecutionListener -> private void startNewTransaction(TestContext testContext, TransactionContext txContext) throws Exception;1385499540;Start a new transaction for the supplied {@link TestContext test context}._<p>Only call this method if {@link #endTransaction} has been called or if no_transaction has been previously started._@param testContext the current test context_@throws TransactionException if starting the transaction fails_@throws Exception if an error occurs while retrieving the transaction manager;private void startNewTransaction(TestContext testContext, TransactionContext txContext) throws Exception {_		txContext.startTransaction()__		++this.transactionsStarted__		if (logger.isInfoEnabled()) {_			logger.info("Began transaction (" + this.transactionsStarted + "): transaction manager ["_					+ txContext.transactionManager + "]_ rollback [" + isRollback(testContext) + "]")__		}_	};start,a,new,transaction,for,the,supplied,link,test,context,test,context,p,only,call,this,method,if,link,end,transaction,has,been,called,or,if,no,transaction,has,been,previously,started,param,test,context,the,current,test,context,throws,transaction,exception,if,starting,the,transaction,fails,throws,exception,if,an,error,occurs,while,retrieving,the,transaction,manager;private,void,start,new,transaction,test,context,test,context,transaction,context,tx,context,throws,exception,tx,context,start,transaction,this,transactions,started,if,logger,is,info,enabled,logger,info,began,transaction,this,transactions,started,transaction,manager,tx,context,transaction,manager,rollback,is,rollback,test,context
TransactionalTestExecutionListener -> private void startNewTransaction(TestContext testContext, TransactionContext txContext) throws Exception;1389966876;Start a new transaction for the supplied {@link TestContext test context}._<p>Only call this method if {@link #endTransaction} has been called or if no_transaction has been previously started._@param testContext the current test context_@throws TransactionException if starting the transaction fails_@throws Exception if an error occurs while retrieving the transaction manager;private void startNewTransaction(TestContext testContext, TransactionContext txContext) throws Exception {_		txContext.startTransaction()__		++this.transactionsStarted__		if (logger.isInfoEnabled()) {_			logger.info(String.format(_				"Began transaction (%s) for test context %s_ transaction manager [%s]_ rollback [%s]",_				this.transactionsStarted, testContext, txContext.transactionManager, isRollback(testContext)))__		}_	};start,a,new,transaction,for,the,supplied,link,test,context,test,context,p,only,call,this,method,if,link,end,transaction,has,been,called,or,if,no,transaction,has,been,previously,started,param,test,context,the,current,test,context,throws,transaction,exception,if,starting,the,transaction,fails,throws,exception,if,an,error,occurs,while,retrieving,the,transaction,manager;private,void,start,new,transaction,test,context,test,context,transaction,context,tx,context,throws,exception,tx,context,start,transaction,this,transactions,started,if,logger,is,info,enabled,logger,info,string,format,began,transaction,s,for,test,context,s,transaction,manager,s,rollback,s,this,transactions,started,test,context,tx,context,transaction,manager,is,rollback,test,context
TransactionalTestExecutionListener -> private void startNewTransaction(TestContext testContext, TransactionContext txContext) throws Exception;1401991965;Start a new transaction for the supplied {@link TestContext test context}._<p>Only call this method if {@link #endTransaction} has been called or if no_transaction has been previously started._@param testContext the current test context_@throws TransactionException if starting the transaction fails_@throws Exception if an error occurs while retrieving the transaction manager;private void startNewTransaction(TestContext testContext, TransactionContext txContext) throws Exception {_		txContext.startTransaction()__		++this.transactionsStarted__		if (logger.isInfoEnabled()) {_			logger.info(String.format(_				"Began transaction (%s) for test context %s_ transaction manager [%s]_ rollback [%s]",_				this.transactionsStarted, testContext, txContext.transactionManager, isRollback(testContext)))__		}_	};start,a,new,transaction,for,the,supplied,link,test,context,test,context,p,only,call,this,method,if,link,end,transaction,has,been,called,or,if,no,transaction,has,been,previously,started,param,test,context,the,current,test,context,throws,transaction,exception,if,starting,the,transaction,fails,throws,exception,if,an,error,occurs,while,retrieving,the,transaction,manager;private,void,start,new,transaction,test,context,test,context,transaction,context,tx,context,throws,exception,tx,context,start,transaction,this,transactions,started,if,logger,is,info,enabled,logger,info,string,format,began,transaction,s,for,test,context,s,transaction,manager,s,rollback,s,this,transactions,started,test,context,tx,context,transaction,manager,is,rollback,test,context
TransactionalTestExecutionListener -> @Nullable 	protected PlatformTransactionManager getTransactionManager(TestContext testContext, @Nullable String qualifier);1498780456;Get the {@linkplain PlatformTransactionManager transaction manager} to use_for the supplied {@linkplain TestContext test context} and {@code qualifier}._<p>Delegates to {@link #getTransactionManager(TestContext)} if the_supplied {@code qualifier} is {@code null} or empty._@param testContext the test context for which the transaction manager_should be retrieved_@param qualifier the qualifier for selecting between multiple bean matches__may be {@code null} or empty_@return the transaction manager to use, or {@code null} if not found_@throws BeansException if an error occurs while retrieving the transaction manager_@see #getTransactionManager(TestContext);@Nullable_	protected PlatformTransactionManager getTransactionManager(TestContext testContext, @Nullable String qualifier) {_		_		if (StringUtils.hasText(qualifier)) {_			try {_				_				_				BeanFactory bf = testContext.getApplicationContext().getAutowireCapableBeanFactory()___				return BeanFactoryAnnotationUtils.qualifiedBeanOfType(bf, PlatformTransactionManager.class, qualifier)__			}_			catch (RuntimeException ex) {_				if (logger.isWarnEnabled()) {_					logger.warn(String.format(_							"Caught exception while retrieving transaction manager with qualifier '%s' for test context %s",_							qualifier, testContext), ex)__				}_				throw ex__			}_		}__		_		return getTransactionManager(testContext)__	};get,the,linkplain,platform,transaction,manager,transaction,manager,to,use,for,the,supplied,linkplain,test,context,test,context,and,code,qualifier,p,delegates,to,link,get,transaction,manager,test,context,if,the,supplied,code,qualifier,is,code,null,or,empty,param,test,context,the,test,context,for,which,the,transaction,manager,should,be,retrieved,param,qualifier,the,qualifier,for,selecting,between,multiple,bean,matches,may,be,code,null,or,empty,return,the,transaction,manager,to,use,or,code,null,if,not,found,throws,beans,exception,if,an,error,occurs,while,retrieving,the,transaction,manager,see,get,transaction,manager,test,context;nullable,protected,platform,transaction,manager,get,transaction,manager,test,context,test,context,nullable,string,qualifier,if,string,utils,has,text,qualifier,try,bean,factory,bf,test,context,get,application,context,get,autowire,capable,bean,factory,return,bean,factory,annotation,utils,qualified,bean,of,type,bf,platform,transaction,manager,class,qualifier,catch,runtime,exception,ex,if,logger,is,warn,enabled,logger,warn,string,format,caught,exception,while,retrieving,transaction,manager,with,qualifier,s,for,test,context,s,qualifier,test,context,ex,throw,ex,return,get,transaction,manager,test,context
TransactionalTestExecutionListener -> @Nullable 	protected PlatformTransactionManager getTransactionManager(TestContext testContext, @Nullable String qualifier);1520251235;Get the {@linkplain PlatformTransactionManager transaction manager} to use_for the supplied {@linkplain TestContext test context} and {@code qualifier}._<p>Delegates to {@link #getTransactionManager(TestContext)} if the_supplied {@code qualifier} is {@code null} or empty._@param testContext the test context for which the transaction manager_should be retrieved_@param qualifier the qualifier for selecting between multiple bean matches__may be {@code null} or empty_@return the transaction manager to use, or {@code null} if not found_@throws BeansException if an error occurs while retrieving the transaction manager_@see #getTransactionManager(TestContext);@Nullable_	protected PlatformTransactionManager getTransactionManager(TestContext testContext, @Nullable String qualifier) {_		_		if (StringUtils.hasText(qualifier)) {_			try {_				_				_				BeanFactory bf = testContext.getApplicationContext().getAutowireCapableBeanFactory()___				return BeanFactoryAnnotationUtils.qualifiedBeanOfType(bf, PlatformTransactionManager.class, qualifier)__			}_			catch (RuntimeException ex) {_				if (logger.isWarnEnabled()) {_					logger.warn(String.format(_							"Caught exception while retrieving transaction manager with qualifier '%s' for test context %s",_							qualifier, testContext), ex)__				}_				throw ex__			}_		}__		_		return getTransactionManager(testContext)__	};get,the,linkplain,platform,transaction,manager,transaction,manager,to,use,for,the,supplied,linkplain,test,context,test,context,and,code,qualifier,p,delegates,to,link,get,transaction,manager,test,context,if,the,supplied,code,qualifier,is,code,null,or,empty,param,test,context,the,test,context,for,which,the,transaction,manager,should,be,retrieved,param,qualifier,the,qualifier,for,selecting,between,multiple,bean,matches,may,be,code,null,or,empty,return,the,transaction,manager,to,use,or,code,null,if,not,found,throws,beans,exception,if,an,error,occurs,while,retrieving,the,transaction,manager,see,get,transaction,manager,test,context;nullable,protected,platform,transaction,manager,get,transaction,manager,test,context,test,context,nullable,string,qualifier,if,string,utils,has,text,qualifier,try,bean,factory,bf,test,context,get,application,context,get,autowire,capable,bean,factory,return,bean,factory,annotation,utils,qualified,bean,of,type,bf,platform,transaction,manager,class,qualifier,catch,runtime,exception,ex,if,logger,is,warn,enabled,logger,warn,string,format,caught,exception,while,retrieving,transaction,manager,with,qualifier,s,for,test,context,s,qualifier,test,context,ex,throw,ex,return,get,transaction,manager,test,context
TransactionalTestExecutionListener -> protected final PlatformTransactionManager getTransactionManager(TestContext testContext, String qualifier);1343426806;Get the {@link PlatformTransactionManager transaction manager} to use_for the supplied {@link TestContext test context} and {@code qualifier}._<p>Delegates to {@link #getTransactionManager(TestContext)} if the_supplied {@code qualifier} is <code>null</code> or empty._@param testContext the test context for which the transaction manager_should be retrieved_@param qualifier the qualifier for selecting between multiple bean matches__may be <code>null</code> or empty_@return the transaction manager to use, or <code>null</code> if not found_@throws BeansException if an error occurs while retrieving the transaction manager_@see #getTransactionManager(TestContext);protected final PlatformTransactionManager getTransactionManager(TestContext testContext, String qualifier) {_		_		if (StringUtils.hasText(qualifier)) {_			try {_				_				_				_				BeanFactory bf = testContext.getApplicationContext().getAutowireCapableBeanFactory()___				return BeanFactoryAnnotationUtils.qualifiedBeanOfType(bf, PlatformTransactionManager.class, qualifier)__			} catch (RuntimeException ex) {_				if (logger.isWarnEnabled()) {_					logger.warn("Caught exception while retrieving transaction manager for test context " + testContext_							+ " and qualifier [" + qualifier + "]", ex)__				}_				throw ex__			}_		}__		_		return getTransactionManager(testContext)__	};get,the,link,platform,transaction,manager,transaction,manager,to,use,for,the,supplied,link,test,context,test,context,and,code,qualifier,p,delegates,to,link,get,transaction,manager,test,context,if,the,supplied,code,qualifier,is,code,null,code,or,empty,param,test,context,the,test,context,for,which,the,transaction,manager,should,be,retrieved,param,qualifier,the,qualifier,for,selecting,between,multiple,bean,matches,may,be,code,null,code,or,empty,return,the,transaction,manager,to,use,or,code,null,code,if,not,found,throws,beans,exception,if,an,error,occurs,while,retrieving,the,transaction,manager,see,get,transaction,manager,test,context;protected,final,platform,transaction,manager,get,transaction,manager,test,context,test,context,string,qualifier,if,string,utils,has,text,qualifier,try,bean,factory,bf,test,context,get,application,context,get,autowire,capable,bean,factory,return,bean,factory,annotation,utils,qualified,bean,of,type,bf,platform,transaction,manager,class,qualifier,catch,runtime,exception,ex,if,logger,is,warn,enabled,logger,warn,caught,exception,while,retrieving,transaction,manager,for,test,context,test,context,and,qualifier,qualifier,ex,throw,ex,return,get,transaction,manager,test,context
TransactionalTestExecutionListener -> protected final PlatformTransactionManager getTransactionManager(TestContext testContext, String qualifier);1343431472;Get the {@link PlatformTransactionManager transaction manager} to use_for the supplied {@link TestContext test context} and {@code qualifier}._<p>Delegates to {@link #getTransactionManager(TestContext)} if the_supplied {@code qualifier} is <code>null</code> or empty._@param testContext the test context for which the transaction manager_should be retrieved_@param qualifier the qualifier for selecting between multiple bean matches__may be <code>null</code> or empty_@return the transaction manager to use, or <code>null</code> if not found_@throws BeansException if an error occurs while retrieving the transaction manager_@see #getTransactionManager(TestContext);protected final PlatformTransactionManager getTransactionManager(TestContext testContext, String qualifier) {_		_		if (StringUtils.hasText(qualifier)) {_			try {_				_				_				_				BeanFactory bf = testContext.getApplicationContext().getAutowireCapableBeanFactory()___				return BeanFactoryAnnotationUtils.qualifiedBeanOfType(bf, PlatformTransactionManager.class, qualifier)__			} catch (RuntimeException ex) {_				if (logger.isWarnEnabled()) {_					logger.warn("Caught exception while retrieving transaction manager for test context " + testContext_							+ " and qualifier [" + qualifier + "]", ex)__				}_				throw ex__			}_		}__		_		return getTransactionManager(testContext)__	};get,the,link,platform,transaction,manager,transaction,manager,to,use,for,the,supplied,link,test,context,test,context,and,code,qualifier,p,delegates,to,link,get,transaction,manager,test,context,if,the,supplied,code,qualifier,is,code,null,code,or,empty,param,test,context,the,test,context,for,which,the,transaction,manager,should,be,retrieved,param,qualifier,the,qualifier,for,selecting,between,multiple,bean,matches,may,be,code,null,code,or,empty,return,the,transaction,manager,to,use,or,code,null,code,if,not,found,throws,beans,exception,if,an,error,occurs,while,retrieving,the,transaction,manager,see,get,transaction,manager,test,context;protected,final,platform,transaction,manager,get,transaction,manager,test,context,test,context,string,qualifier,if,string,utils,has,text,qualifier,try,bean,factory,bf,test,context,get,application,context,get,autowire,capable,bean,factory,return,bean,factory,annotation,utils,qualified,bean,of,type,bf,platform,transaction,manager,class,qualifier,catch,runtime,exception,ex,if,logger,is,warn,enabled,logger,warn,caught,exception,while,retrieving,transaction,manager,for,test,context,test,context,and,qualifier,qualifier,ex,throw,ex,return,get,transaction,manager,test,context
TransactionalTestExecutionListener -> protected final PlatformTransactionManager getTransactionManager(TestContext testContext, String qualifier);1354571539;Get the {@link PlatformTransactionManager transaction manager} to use_for the supplied {@link TestContext test context} and {@code qualifier}._<p>Delegates to {@link #getTransactionManager(TestContext)} if the_supplied {@code qualifier} is <code>null</code> or empty._@param testContext the test context for which the transaction manager_should be retrieved_@param qualifier the qualifier for selecting between multiple bean matches__may be <code>null</code> or empty_@return the transaction manager to use, or <code>null</code> if not found_@throws BeansException if an error occurs while retrieving the transaction manager_@see #getTransactionManager(TestContext);protected final PlatformTransactionManager getTransactionManager(TestContext testContext, String qualifier) {_		_		if (StringUtils.hasText(qualifier)) {_			try {_				_				_				_				BeanFactory bf = testContext.getApplicationContext().getAutowireCapableBeanFactory()___				return BeanFactoryAnnotationUtils.qualifiedBeanOfType(bf, PlatformTransactionManager.class, qualifier)__			} catch (RuntimeException ex) {_				if (logger.isWarnEnabled()) {_					logger.warn("Caught exception while retrieving transaction manager for test context " + testContext_							+ " and qualifier [" + qualifier + "]", ex)__				}_				throw ex__			}_		}__		_		return getTransactionManager(testContext)__	};get,the,link,platform,transaction,manager,transaction,manager,to,use,for,the,supplied,link,test,context,test,context,and,code,qualifier,p,delegates,to,link,get,transaction,manager,test,context,if,the,supplied,code,qualifier,is,code,null,code,or,empty,param,test,context,the,test,context,for,which,the,transaction,manager,should,be,retrieved,param,qualifier,the,qualifier,for,selecting,between,multiple,bean,matches,may,be,code,null,code,or,empty,return,the,transaction,manager,to,use,or,code,null,code,if,not,found,throws,beans,exception,if,an,error,occurs,while,retrieving,the,transaction,manager,see,get,transaction,manager,test,context;protected,final,platform,transaction,manager,get,transaction,manager,test,context,test,context,string,qualifier,if,string,utils,has,text,qualifier,try,bean,factory,bf,test,context,get,application,context,get,autowire,capable,bean,factory,return,bean,factory,annotation,utils,qualified,bean,of,type,bf,platform,transaction,manager,class,qualifier,catch,runtime,exception,ex,if,logger,is,warn,enabled,logger,warn,caught,exception,while,retrieving,transaction,manager,for,test,context,test,context,and,qualifier,qualifier,ex,throw,ex,return,get,transaction,manager,test,context
TransactionalTestExecutionListener -> protected final PlatformTransactionManager getTransactionManager(TestContext testContext, String qualifier);1355352386;Get the {@link PlatformTransactionManager transaction manager} to use_for the supplied {@link TestContext test context} and {@code qualifier}._<p>Delegates to {@link #getTransactionManager(TestContext)} if the_supplied {@code qualifier} is <code>null</code> or empty._@param testContext the test context for which the transaction manager_should be retrieved_@param qualifier the qualifier for selecting between multiple bean matches__may be <code>null</code> or empty_@return the transaction manager to use, or <code>null</code> if not found_@throws BeansException if an error occurs while retrieving the transaction manager_@see #getTransactionManager(TestContext);protected final PlatformTransactionManager getTransactionManager(TestContext testContext, String qualifier) {_		_		if (StringUtils.hasText(qualifier)) {_			try {_				_				_				_				BeanFactory bf = testContext.getApplicationContext().getAutowireCapableBeanFactory()___				return BeanFactoryAnnotationUtils.qualifiedBeanOfType(bf, PlatformTransactionManager.class, qualifier)__			} catch (RuntimeException ex) {_				if (logger.isWarnEnabled()) {_					logger.warn("Caught exception while retrieving transaction manager for test context " + testContext_							+ " and qualifier [" + qualifier + "]", ex)__				}_				throw ex__			}_		}__		_		return getTransactionManager(testContext)__	};get,the,link,platform,transaction,manager,transaction,manager,to,use,for,the,supplied,link,test,context,test,context,and,code,qualifier,p,delegates,to,link,get,transaction,manager,test,context,if,the,supplied,code,qualifier,is,code,null,code,or,empty,param,test,context,the,test,context,for,which,the,transaction,manager,should,be,retrieved,param,qualifier,the,qualifier,for,selecting,between,multiple,bean,matches,may,be,code,null,code,or,empty,return,the,transaction,manager,to,use,or,code,null,code,if,not,found,throws,beans,exception,if,an,error,occurs,while,retrieving,the,transaction,manager,see,get,transaction,manager,test,context;protected,final,platform,transaction,manager,get,transaction,manager,test,context,test,context,string,qualifier,if,string,utils,has,text,qualifier,try,bean,factory,bf,test,context,get,application,context,get,autowire,capable,bean,factory,return,bean,factory,annotation,utils,qualified,bean,of,type,bf,platform,transaction,manager,class,qualifier,catch,runtime,exception,ex,if,logger,is,warn,enabled,logger,warn,caught,exception,while,retrieving,transaction,manager,for,test,context,test,context,and,qualifier,qualifier,ex,throw,ex,return,get,transaction,manager,test,context
TransactionalTestExecutionListener -> protected final PlatformTransactionManager getTransactionManager(TestContext testContext, String qualifier);1356735495;Get the {@link PlatformTransactionManager transaction manager} to use_for the supplied {@link TestContext test context} and {@code qualifier}._<p>Delegates to {@link #getTransactionManager(TestContext)} if the_supplied {@code qualifier} is {@code null} or empty._@param testContext the test context for which the transaction manager_should be retrieved_@param qualifier the qualifier for selecting between multiple bean matches__may be {@code null} or empty_@return the transaction manager to use, or {@code null} if not found_@throws BeansException if an error occurs while retrieving the transaction manager_@see #getTransactionManager(TestContext);protected final PlatformTransactionManager getTransactionManager(TestContext testContext, String qualifier) {_		_		if (StringUtils.hasText(qualifier)) {_			try {_				_				_				_				BeanFactory bf = testContext.getApplicationContext().getAutowireCapableBeanFactory()___				return BeanFactoryAnnotationUtils.qualifiedBeanOfType(bf, PlatformTransactionManager.class, qualifier)__			} catch (RuntimeException ex) {_				if (logger.isWarnEnabled()) {_					logger.warn("Caught exception while retrieving transaction manager for test context " + testContext_							+ " and qualifier [" + qualifier + "]", ex)__				}_				throw ex__			}_		}__		_		return getTransactionManager(testContext)__	};get,the,link,platform,transaction,manager,transaction,manager,to,use,for,the,supplied,link,test,context,test,context,and,code,qualifier,p,delegates,to,link,get,transaction,manager,test,context,if,the,supplied,code,qualifier,is,code,null,or,empty,param,test,context,the,test,context,for,which,the,transaction,manager,should,be,retrieved,param,qualifier,the,qualifier,for,selecting,between,multiple,bean,matches,may,be,code,null,or,empty,return,the,transaction,manager,to,use,or,code,null,if,not,found,throws,beans,exception,if,an,error,occurs,while,retrieving,the,transaction,manager,see,get,transaction,manager,test,context;protected,final,platform,transaction,manager,get,transaction,manager,test,context,test,context,string,qualifier,if,string,utils,has,text,qualifier,try,bean,factory,bf,test,context,get,application,context,get,autowire,capable,bean,factory,return,bean,factory,annotation,utils,qualified,bean,of,type,bf,platform,transaction,manager,class,qualifier,catch,runtime,exception,ex,if,logger,is,warn,enabled,logger,warn,caught,exception,while,retrieving,transaction,manager,for,test,context,test,context,and,qualifier,qualifier,ex,throw,ex,return,get,transaction,manager,test,context
TransactionalTestExecutionListener -> protected final PlatformTransactionManager getTransactionManager(TestContext testContext, String qualifier);1357119239;Get the {@link PlatformTransactionManager transaction manager} to use_for the supplied {@link TestContext test context} and {@code qualifier}._<p>Delegates to {@link #getTransactionManager(TestContext)} if the_supplied {@code qualifier} is {@code null} or empty._@param testContext the test context for which the transaction manager_should be retrieved_@param qualifier the qualifier for selecting between multiple bean matches__may be {@code null} or empty_@return the transaction manager to use, or {@code null} if not found_@throws BeansException if an error occurs while retrieving the transaction manager_@see #getTransactionManager(TestContext);protected final PlatformTransactionManager getTransactionManager(TestContext testContext, String qualifier) {_		_		if (StringUtils.hasText(qualifier)) {_			try {_				_				_				_				BeanFactory bf = testContext.getApplicationContext().getAutowireCapableBeanFactory()___				return BeanFactoryAnnotationUtils.qualifiedBeanOfType(bf, PlatformTransactionManager.class, qualifier)__			} catch (RuntimeException ex) {_				if (logger.isWarnEnabled()) {_					logger.warn("Caught exception while retrieving transaction manager for test context " + testContext_							+ " and qualifier [" + qualifier + "]", ex)__				}_				throw ex__			}_		}__		_		return getTransactionManager(testContext)__	};get,the,link,platform,transaction,manager,transaction,manager,to,use,for,the,supplied,link,test,context,test,context,and,code,qualifier,p,delegates,to,link,get,transaction,manager,test,context,if,the,supplied,code,qualifier,is,code,null,or,empty,param,test,context,the,test,context,for,which,the,transaction,manager,should,be,retrieved,param,qualifier,the,qualifier,for,selecting,between,multiple,bean,matches,may,be,code,null,or,empty,return,the,transaction,manager,to,use,or,code,null,if,not,found,throws,beans,exception,if,an,error,occurs,while,retrieving,the,transaction,manager,see,get,transaction,manager,test,context;protected,final,platform,transaction,manager,get,transaction,manager,test,context,test,context,string,qualifier,if,string,utils,has,text,qualifier,try,bean,factory,bf,test,context,get,application,context,get,autowire,capable,bean,factory,return,bean,factory,annotation,utils,qualified,bean,of,type,bf,platform,transaction,manager,class,qualifier,catch,runtime,exception,ex,if,logger,is,warn,enabled,logger,warn,caught,exception,while,retrieving,transaction,manager,for,test,context,test,context,and,qualifier,qualifier,ex,throw,ex,return,get,transaction,manager,test,context
TransactionalTestExecutionListener -> protected final PlatformTransactionManager getTransactionManager(TestContext testContext, String qualifier);1367163114;Get the {@link PlatformTransactionManager transaction manager} to use_for the supplied {@link TestContext test context} and {@code qualifier}._<p>Delegates to {@link #getTransactionManager(TestContext)} if the_supplied {@code qualifier} is {@code null} or empty._@param testContext the test context for which the transaction manager_should be retrieved_@param qualifier the qualifier for selecting between multiple bean matches__may be {@code null} or empty_@return the transaction manager to use, or {@code null} if not found_@throws BeansException if an error occurs while retrieving the transaction manager_@see #getTransactionManager(TestContext);protected final PlatformTransactionManager getTransactionManager(TestContext testContext, String qualifier) {_		_		if (StringUtils.hasText(qualifier)) {_			try {_				_				_				_				BeanFactory bf = testContext.getApplicationContext().getAutowireCapableBeanFactory()___				return BeanFactoryAnnotationUtils.qualifiedBeanOfType(bf, PlatformTransactionManager.class, qualifier)__			} catch (RuntimeException ex) {_				if (logger.isWarnEnabled()) {_					logger.warn("Caught exception while retrieving transaction manager for test context " + testContext_							+ " and qualifier [" + qualifier + "]", ex)__				}_				throw ex__			}_		}__		_		return getTransactionManager(testContext)__	};get,the,link,platform,transaction,manager,transaction,manager,to,use,for,the,supplied,link,test,context,test,context,and,code,qualifier,p,delegates,to,link,get,transaction,manager,test,context,if,the,supplied,code,qualifier,is,code,null,or,empty,param,test,context,the,test,context,for,which,the,transaction,manager,should,be,retrieved,param,qualifier,the,qualifier,for,selecting,between,multiple,bean,matches,may,be,code,null,or,empty,return,the,transaction,manager,to,use,or,code,null,if,not,found,throws,beans,exception,if,an,error,occurs,while,retrieving,the,transaction,manager,see,get,transaction,manager,test,context;protected,final,platform,transaction,manager,get,transaction,manager,test,context,test,context,string,qualifier,if,string,utils,has,text,qualifier,try,bean,factory,bf,test,context,get,application,context,get,autowire,capable,bean,factory,return,bean,factory,annotation,utils,qualified,bean,of,type,bf,platform,transaction,manager,class,qualifier,catch,runtime,exception,ex,if,logger,is,warn,enabled,logger,warn,caught,exception,while,retrieving,transaction,manager,for,test,context,test,context,and,qualifier,qualifier,ex,throw,ex,return,get,transaction,manager,test,context
TransactionalTestExecutionListener -> protected final PlatformTransactionManager getTransactionManager(TestContext testContext, String qualifier);1367873075;Get the {@link PlatformTransactionManager transaction manager} to use_for the supplied {@link TestContext test context} and {@code qualifier}._<p>Delegates to {@link #getTransactionManager(TestContext)} if the_supplied {@code qualifier} is {@code null} or empty._@param testContext the test context for which the transaction manager_should be retrieved_@param qualifier the qualifier for selecting between multiple bean matches__may be {@code null} or empty_@return the transaction manager to use, or {@code null} if not found_@throws BeansException if an error occurs while retrieving the transaction manager_@see #getTransactionManager(TestContext);protected final PlatformTransactionManager getTransactionManager(TestContext testContext, String qualifier) {_		_		if (StringUtils.hasText(qualifier)) {_			try {_				_				_				_				BeanFactory bf = testContext.getApplicationContext().getAutowireCapableBeanFactory()___				return BeanFactoryAnnotationUtils.qualifiedBeanOfType(bf, PlatformTransactionManager.class, qualifier)__			} catch (RuntimeException ex) {_				if (logger.isWarnEnabled()) {_					logger.warn("Caught exception while retrieving transaction manager for test context " + testContext_							+ " and qualifier [" + qualifier + "]", ex)__				}_				throw ex__			}_		}__		_		return getTransactionManager(testContext)__	};get,the,link,platform,transaction,manager,transaction,manager,to,use,for,the,supplied,link,test,context,test,context,and,code,qualifier,p,delegates,to,link,get,transaction,manager,test,context,if,the,supplied,code,qualifier,is,code,null,or,empty,param,test,context,the,test,context,for,which,the,transaction,manager,should,be,retrieved,param,qualifier,the,qualifier,for,selecting,between,multiple,bean,matches,may,be,code,null,or,empty,return,the,transaction,manager,to,use,or,code,null,if,not,found,throws,beans,exception,if,an,error,occurs,while,retrieving,the,transaction,manager,see,get,transaction,manager,test,context;protected,final,platform,transaction,manager,get,transaction,manager,test,context,test,context,string,qualifier,if,string,utils,has,text,qualifier,try,bean,factory,bf,test,context,get,application,context,get,autowire,capable,bean,factory,return,bean,factory,annotation,utils,qualified,bean,of,type,bf,platform,transaction,manager,class,qualifier,catch,runtime,exception,ex,if,logger,is,warn,enabled,logger,warn,caught,exception,while,retrieving,transaction,manager,for,test,context,test,context,and,qualifier,qualifier,ex,throw,ex,return,get,transaction,manager,test,context
TransactionalTestExecutionListener -> protected final PlatformTransactionManager getTransactionManager(TestContext testContext, String qualifier);1368482696;Get the {@link PlatformTransactionManager transaction manager} to use_for the supplied {@link TestContext test context} and {@code qualifier}._<p>Delegates to {@link #getTransactionManager(TestContext)} if the_supplied {@code qualifier} is {@code null} or empty._@param testContext the test context for which the transaction manager_should be retrieved_@param qualifier the qualifier for selecting between multiple bean matches__may be {@code null} or empty_@return the transaction manager to use, or {@code null} if not found_@throws BeansException if an error occurs while retrieving the transaction manager_@see #getTransactionManager(TestContext);protected final PlatformTransactionManager getTransactionManager(TestContext testContext, String qualifier) {_		_		if (StringUtils.hasText(qualifier)) {_			try {_				_				_				_				BeanFactory bf = testContext.getApplicationContext().getAutowireCapableBeanFactory()___				return BeanFactoryAnnotationUtils.qualifiedBeanOfType(bf, PlatformTransactionManager.class, qualifier)__			} catch (RuntimeException ex) {_				if (logger.isWarnEnabled()) {_					logger.warn("Caught exception while retrieving transaction manager for test context " + testContext_							+ " and qualifier [" + qualifier + "]", ex)__				}_				throw ex__			}_		}__		_		return getTransactionManager(testContext)__	};get,the,link,platform,transaction,manager,transaction,manager,to,use,for,the,supplied,link,test,context,test,context,and,code,qualifier,p,delegates,to,link,get,transaction,manager,test,context,if,the,supplied,code,qualifier,is,code,null,or,empty,param,test,context,the,test,context,for,which,the,transaction,manager,should,be,retrieved,param,qualifier,the,qualifier,for,selecting,between,multiple,bean,matches,may,be,code,null,or,empty,return,the,transaction,manager,to,use,or,code,null,if,not,found,throws,beans,exception,if,an,error,occurs,while,retrieving,the,transaction,manager,see,get,transaction,manager,test,context;protected,final,platform,transaction,manager,get,transaction,manager,test,context,test,context,string,qualifier,if,string,utils,has,text,qualifier,try,bean,factory,bf,test,context,get,application,context,get,autowire,capable,bean,factory,return,bean,factory,annotation,utils,qualified,bean,of,type,bf,platform,transaction,manager,class,qualifier,catch,runtime,exception,ex,if,logger,is,warn,enabled,logger,warn,caught,exception,while,retrieving,transaction,manager,for,test,context,test,context,and,qualifier,qualifier,ex,throw,ex,return,get,transaction,manager,test,context
TransactionalTestExecutionListener -> private TransactionConfigurationAttributes retrieveConfigurationAttributes(TestContext testContext);1328020251;Retrieves the {@link TransactionConfigurationAttributes} for the_specified {@link Class class} which may optionally declare or inherit a_{@link TransactionConfiguration &#064_TransactionConfiguration}. If a_{@link TransactionConfiguration} annotation is not present for the_supplied class, the <em>default values</em> for attributes defined in_{@link TransactionConfiguration} will be used instead._@param clazz the Class object corresponding to the test class for which_the configuration attributes should be retrieved_@return a new TransactionConfigurationAttributes instance;private TransactionConfigurationAttributes retrieveConfigurationAttributes(TestContext testContext) {_		if (this.configurationAttributes == null) {_			Class<?> clazz = testContext.getTestClass()__			Class<TransactionConfiguration> annotationType = TransactionConfiguration.class__			TransactionConfiguration config = clazz.getAnnotation(annotationType)__			if (logger.isDebugEnabled()) {_				logger.debug("Retrieved @TransactionConfiguration [" + config + "] for test class [" + clazz + "]")__			}__			String transactionManagerName__			boolean defaultRollback__			if (config != null) {_				transactionManagerName = config.transactionManager()__				defaultRollback = config.defaultRollback()__			}_			else {_				transactionManagerName = (String) AnnotationUtils.getDefaultValue(annotationType, "transactionManager")__				defaultRollback = (Boolean) AnnotationUtils.getDefaultValue(annotationType, "defaultRollback")__			}__			TransactionConfigurationAttributes configAttributes = new TransactionConfigurationAttributes(_				transactionManagerName, defaultRollback)__			if (logger.isDebugEnabled()) {_				logger.debug("Retrieved TransactionConfigurationAttributes [" + configAttributes + "] for class ["_						+ clazz + "]")__			}_			this.configurationAttributes = configAttributes__		}_		return this.configurationAttributes__	};retrieves,the,link,transaction,configuration,attributes,for,the,specified,link,class,class,which,may,optionally,declare,or,inherit,a,link,transaction,configuration,064,transaction,configuration,if,a,link,transaction,configuration,annotation,is,not,present,for,the,supplied,class,the,em,default,values,em,for,attributes,defined,in,link,transaction,configuration,will,be,used,instead,param,clazz,the,class,object,corresponding,to,the,test,class,for,which,the,configuration,attributes,should,be,retrieved,return,a,new,transaction,configuration,attributes,instance;private,transaction,configuration,attributes,retrieve,configuration,attributes,test,context,test,context,if,this,configuration,attributes,null,class,clazz,test,context,get,test,class,class,transaction,configuration,annotation,type,transaction,configuration,class,transaction,configuration,config,clazz,get,annotation,annotation,type,if,logger,is,debug,enabled,logger,debug,retrieved,transaction,configuration,config,for,test,class,clazz,string,transaction,manager,name,boolean,default,rollback,if,config,null,transaction,manager,name,config,transaction,manager,default,rollback,config,default,rollback,else,transaction,manager,name,string,annotation,utils,get,default,value,annotation,type,transaction,manager,default,rollback,boolean,annotation,utils,get,default,value,annotation,type,default,rollback,transaction,configuration,attributes,config,attributes,new,transaction,configuration,attributes,transaction,manager,name,default,rollback,if,logger,is,debug,enabled,logger,debug,retrieved,transaction,configuration,attributes,config,attributes,for,class,clazz,this,configuration,attributes,config,attributes,return,this,configuration,attributes
TransactionalTestExecutionListener -> private TransactionConfigurationAttributes retrieveConfigurationAttributes(TestContext testContext);1337516454;Retrieves the {@link TransactionConfigurationAttributes} for the_specified {@link Class class} which may optionally declare or inherit a_{@link TransactionConfiguration &#064_TransactionConfiguration}. If a_{@link TransactionConfiguration} annotation is not present for the_supplied class, the <em>default values</em> for attributes defined in_{@link TransactionConfiguration} will be used instead._@param clazz the Class object corresponding to the test class for which_the configuration attributes should be retrieved_@return a new TransactionConfigurationAttributes instance;private TransactionConfigurationAttributes retrieveConfigurationAttributes(TestContext testContext) {_		if (this.configurationAttributes == null) {_			Class<?> clazz = testContext.getTestClass()__			Class<TransactionConfiguration> annotationType = TransactionConfiguration.class__			TransactionConfiguration config = clazz.getAnnotation(annotationType)__			if (logger.isDebugEnabled()) {_				logger.debug("Retrieved @TransactionConfiguration [" + config + "] for test class [" + clazz + "]")__			}__			String transactionManagerName__			boolean defaultRollback__			if (config != null) {_				transactionManagerName = config.transactionManager()__				defaultRollback = config.defaultRollback()__			}_			else {_				transactionManagerName = (String) AnnotationUtils.getDefaultValue(annotationType, "transactionManager")__				defaultRollback = (Boolean) AnnotationUtils.getDefaultValue(annotationType, "defaultRollback")__			}__			TransactionConfigurationAttributes configAttributes = new TransactionConfigurationAttributes(_				transactionManagerName, defaultRollback)__			if (logger.isDebugEnabled()) {_				logger.debug("Retrieved TransactionConfigurationAttributes [" + configAttributes + "] for class ["_						+ clazz + "]")__			}_			this.configurationAttributes = configAttributes__		}_		return this.configurationAttributes__	};retrieves,the,link,transaction,configuration,attributes,for,the,specified,link,class,class,which,may,optionally,declare,or,inherit,a,link,transaction,configuration,064,transaction,configuration,if,a,link,transaction,configuration,annotation,is,not,present,for,the,supplied,class,the,em,default,values,em,for,attributes,defined,in,link,transaction,configuration,will,be,used,instead,param,clazz,the,class,object,corresponding,to,the,test,class,for,which,the,configuration,attributes,should,be,retrieved,return,a,new,transaction,configuration,attributes,instance;private,transaction,configuration,attributes,retrieve,configuration,attributes,test,context,test,context,if,this,configuration,attributes,null,class,clazz,test,context,get,test,class,class,transaction,configuration,annotation,type,transaction,configuration,class,transaction,configuration,config,clazz,get,annotation,annotation,type,if,logger,is,debug,enabled,logger,debug,retrieved,transaction,configuration,config,for,test,class,clazz,string,transaction,manager,name,boolean,default,rollback,if,config,null,transaction,manager,name,config,transaction,manager,default,rollback,config,default,rollback,else,transaction,manager,name,string,annotation,utils,get,default,value,annotation,type,transaction,manager,default,rollback,boolean,annotation,utils,get,default,value,annotation,type,default,rollback,transaction,configuration,attributes,config,attributes,new,transaction,configuration,attributes,transaction,manager,name,default,rollback,if,logger,is,debug,enabled,logger,debug,retrieved,transaction,configuration,attributes,config,attributes,for,class,clazz,this,configuration,attributes,config,attributes,return,this,configuration,attributes
TransactionalTestExecutionListener -> private TransactionConfigurationAttributes retrieveConfigurationAttributes(TestContext testContext);1338031377;Retrieves the {@link TransactionConfigurationAttributes} for the_specified {@link Class class} which may optionally declare or inherit a_{@link TransactionConfiguration &#064_TransactionConfiguration}. If a_{@link TransactionConfiguration} annotation is not present for the_supplied class, the <em>default values</em> for attributes defined in_{@link TransactionConfiguration} will be used instead._@param clazz the Class object corresponding to the test class for which_the configuration attributes should be retrieved_@return a new TransactionConfigurationAttributes instance;private TransactionConfigurationAttributes retrieveConfigurationAttributes(TestContext testContext) {_		if (this.configurationAttributes == null) {_			Class<?> clazz = testContext.getTestClass()__			Class<TransactionConfiguration> annotationType = TransactionConfiguration.class__			TransactionConfiguration config = clazz.getAnnotation(annotationType)__			if (logger.isDebugEnabled()) {_				logger.debug("Retrieved @TransactionConfiguration [" + config + "] for test class [" + clazz + "]")__			}__			String transactionManagerName__			boolean defaultRollback__			if (config != null) {_				transactionManagerName = config.transactionManager()__				defaultRollback = config.defaultRollback()__			}_			else {_				transactionManagerName = (String) AnnotationUtils.getDefaultValue(annotationType, "transactionManager")__				defaultRollback = (Boolean) AnnotationUtils.getDefaultValue(annotationType, "defaultRollback")__			}__			TransactionConfigurationAttributes configAttributes = new TransactionConfigurationAttributes(_				transactionManagerName, defaultRollback)__			if (logger.isDebugEnabled()) {_				logger.debug("Retrieved TransactionConfigurationAttributes [" + configAttributes + "] for class ["_						+ clazz + "]")__			}_			this.configurationAttributes = configAttributes__		}_		return this.configurationAttributes__	};retrieves,the,link,transaction,configuration,attributes,for,the,specified,link,class,class,which,may,optionally,declare,or,inherit,a,link,transaction,configuration,064,transaction,configuration,if,a,link,transaction,configuration,annotation,is,not,present,for,the,supplied,class,the,em,default,values,em,for,attributes,defined,in,link,transaction,configuration,will,be,used,instead,param,clazz,the,class,object,corresponding,to,the,test,class,for,which,the,configuration,attributes,should,be,retrieved,return,a,new,transaction,configuration,attributes,instance;private,transaction,configuration,attributes,retrieve,configuration,attributes,test,context,test,context,if,this,configuration,attributes,null,class,clazz,test,context,get,test,class,class,transaction,configuration,annotation,type,transaction,configuration,class,transaction,configuration,config,clazz,get,annotation,annotation,type,if,logger,is,debug,enabled,logger,debug,retrieved,transaction,configuration,config,for,test,class,clazz,string,transaction,manager,name,boolean,default,rollback,if,config,null,transaction,manager,name,config,transaction,manager,default,rollback,config,default,rollback,else,transaction,manager,name,string,annotation,utils,get,default,value,annotation,type,transaction,manager,default,rollback,boolean,annotation,utils,get,default,value,annotation,type,default,rollback,transaction,configuration,attributes,config,attributes,new,transaction,configuration,attributes,transaction,manager,name,default,rollback,if,logger,is,debug,enabled,logger,debug,retrieved,transaction,configuration,attributes,config,attributes,for,class,clazz,this,configuration,attributes,config,attributes,return,this,configuration,attributes
TransactionalTestExecutionListener -> private TransactionConfigurationAttributes retrieveConfigurationAttributes(TestContext testContext);1343426806;Retrieves the {@link TransactionConfigurationAttributes} for the_specified {@link Class class} which may optionally declare or inherit_{@link TransactionConfiguration &#064_TransactionConfiguration}. If_{@code &#064_TransactionConfiguration} is not present for the supplied_class, the <em>default values</em> for attributes defined in_{@code &#064_TransactionConfiguration} will be used instead._@param testContext the test context for which the configuration_attributes should be retrieved_@return a new TransactionConfigurationAttributes instance;private TransactionConfigurationAttributes retrieveConfigurationAttributes(TestContext testContext) {_		if (this.configurationAttributes == null) {_			Class<?> clazz = testContext.getTestClass()__			TransactionConfiguration config = clazz.getAnnotation(TransactionConfiguration.class)__			if (logger.isDebugEnabled()) {_				logger.debug("Retrieved @TransactionConfiguration [" + config + "] for test class [" + clazz + "]")__			}__			String transactionManagerName__			boolean defaultRollback__			if (config != null) {_				transactionManagerName = config.transactionManager()__				defaultRollback = config.defaultRollback()__			}_			else {_				transactionManagerName = DEFAULT_TRANSACTION_MANAGER_NAME__				defaultRollback = DEFAULT_DEFAULT_ROLLBACK__			}__			TransactionConfigurationAttributes configAttributes = new TransactionConfigurationAttributes(_				transactionManagerName, defaultRollback)__			if (logger.isDebugEnabled()) {_				logger.debug("Retrieved TransactionConfigurationAttributes " + configAttributes + " for class ["_						+ clazz + "]")__			}_			this.configurationAttributes = configAttributes__		}_		return this.configurationAttributes__	};retrieves,the,link,transaction,configuration,attributes,for,the,specified,link,class,class,which,may,optionally,declare,or,inherit,link,transaction,configuration,064,transaction,configuration,if,code,064,transaction,configuration,is,not,present,for,the,supplied,class,the,em,default,values,em,for,attributes,defined,in,code,064,transaction,configuration,will,be,used,instead,param,test,context,the,test,context,for,which,the,configuration,attributes,should,be,retrieved,return,a,new,transaction,configuration,attributes,instance;private,transaction,configuration,attributes,retrieve,configuration,attributes,test,context,test,context,if,this,configuration,attributes,null,class,clazz,test,context,get,test,class,transaction,configuration,config,clazz,get,annotation,transaction,configuration,class,if,logger,is,debug,enabled,logger,debug,retrieved,transaction,configuration,config,for,test,class,clazz,string,transaction,manager,name,boolean,default,rollback,if,config,null,transaction,manager,name,config,transaction,manager,default,rollback,config,default,rollback,else,transaction,manager,name,default,rollback,transaction,configuration,attributes,config,attributes,new,transaction,configuration,attributes,transaction,manager,name,default,rollback,if,logger,is,debug,enabled,logger,debug,retrieved,transaction,configuration,attributes,config,attributes,for,class,clazz,this,configuration,attributes,config,attributes,return,this,configuration,attributes
TransactionalTestExecutionListener -> private TransactionConfigurationAttributes retrieveConfigurationAttributes(TestContext testContext);1343431472;Retrieves the {@link TransactionConfigurationAttributes} for the_specified {@link Class class} which may optionally declare or inherit_{@link TransactionConfiguration &#064_TransactionConfiguration}. If_{@code &#064_TransactionConfiguration} is not present for the supplied_class, the <em>default values</em> for attributes defined in_{@code &#064_TransactionConfiguration} will be used instead._@param testContext the test context for which the configuration_attributes should be retrieved_@return a new TransactionConfigurationAttributes instance;private TransactionConfigurationAttributes retrieveConfigurationAttributes(TestContext testContext) {_		if (this.configurationAttributes == null) {_			Class<?> clazz = testContext.getTestClass()__			TransactionConfiguration config = clazz.getAnnotation(TransactionConfiguration.class)__			if (logger.isDebugEnabled()) {_				logger.debug("Retrieved @TransactionConfiguration [" + config + "] for test class [" + clazz + "]")__			}__			String transactionManagerName__			boolean defaultRollback__			if (config != null) {_				transactionManagerName = config.transactionManager()__				defaultRollback = config.defaultRollback()__			}_			else {_				transactionManagerName = DEFAULT_TRANSACTION_MANAGER_NAME__				defaultRollback = DEFAULT_DEFAULT_ROLLBACK__			}__			TransactionConfigurationAttributes configAttributes = new TransactionConfigurationAttributes(_				transactionManagerName, defaultRollback)__			if (logger.isDebugEnabled()) {_				logger.debug("Retrieved TransactionConfigurationAttributes " + configAttributes + " for class ["_						+ clazz + "]")__			}_			this.configurationAttributes = configAttributes__		}_		return this.configurationAttributes__	};retrieves,the,link,transaction,configuration,attributes,for,the,specified,link,class,class,which,may,optionally,declare,or,inherit,link,transaction,configuration,064,transaction,configuration,if,code,064,transaction,configuration,is,not,present,for,the,supplied,class,the,em,default,values,em,for,attributes,defined,in,code,064,transaction,configuration,will,be,used,instead,param,test,context,the,test,context,for,which,the,configuration,attributes,should,be,retrieved,return,a,new,transaction,configuration,attributes,instance;private,transaction,configuration,attributes,retrieve,configuration,attributes,test,context,test,context,if,this,configuration,attributes,null,class,clazz,test,context,get,test,class,transaction,configuration,config,clazz,get,annotation,transaction,configuration,class,if,logger,is,debug,enabled,logger,debug,retrieved,transaction,configuration,config,for,test,class,clazz,string,transaction,manager,name,boolean,default,rollback,if,config,null,transaction,manager,name,config,transaction,manager,default,rollback,config,default,rollback,else,transaction,manager,name,default,rollback,transaction,configuration,attributes,config,attributes,new,transaction,configuration,attributes,transaction,manager,name,default,rollback,if,logger,is,debug,enabled,logger,debug,retrieved,transaction,configuration,attributes,config,attributes,for,class,clazz,this,configuration,attributes,config,attributes,return,this,configuration,attributes
TransactionalTestExecutionListener -> private TransactionConfigurationAttributes retrieveConfigurationAttributes(TestContext testContext);1354571539;Retrieves the {@link TransactionConfigurationAttributes} for the_specified {@link Class class} which may optionally declare or inherit_{@link TransactionConfiguration &#064_TransactionConfiguration}. If_{@code @TransactionConfiguration} is not present for the supplied_class, the <em>default values</em> for attributes defined in_{@code @TransactionConfiguration} will be used instead._@param testContext the test context for which the configuration_attributes should be retrieved_@return a new TransactionConfigurationAttributes instance;private TransactionConfigurationAttributes retrieveConfigurationAttributes(TestContext testContext) {_		if (this.configurationAttributes == null) {_			Class<?> clazz = testContext.getTestClass()__			TransactionConfiguration config = clazz.getAnnotation(TransactionConfiguration.class)__			if (logger.isDebugEnabled()) {_				logger.debug("Retrieved @TransactionConfiguration [" + config + "] for test class [" + clazz + "]")__			}__			String transactionManagerName__			boolean defaultRollback__			if (config != null) {_				transactionManagerName = config.transactionManager()__				defaultRollback = config.defaultRollback()__			}_			else {_				transactionManagerName = DEFAULT_TRANSACTION_MANAGER_NAME__				defaultRollback = DEFAULT_DEFAULT_ROLLBACK__			}__			TransactionConfigurationAttributes configAttributes = new TransactionConfigurationAttributes(_				transactionManagerName, defaultRollback)__			if (logger.isDebugEnabled()) {_				logger.debug("Retrieved TransactionConfigurationAttributes " + configAttributes + " for class ["_						+ clazz + "]")__			}_			this.configurationAttributes = configAttributes__		}_		return this.configurationAttributes__	};retrieves,the,link,transaction,configuration,attributes,for,the,specified,link,class,class,which,may,optionally,declare,or,inherit,link,transaction,configuration,064,transaction,configuration,if,code,transaction,configuration,is,not,present,for,the,supplied,class,the,em,default,values,em,for,attributes,defined,in,code,transaction,configuration,will,be,used,instead,param,test,context,the,test,context,for,which,the,configuration,attributes,should,be,retrieved,return,a,new,transaction,configuration,attributes,instance;private,transaction,configuration,attributes,retrieve,configuration,attributes,test,context,test,context,if,this,configuration,attributes,null,class,clazz,test,context,get,test,class,transaction,configuration,config,clazz,get,annotation,transaction,configuration,class,if,logger,is,debug,enabled,logger,debug,retrieved,transaction,configuration,config,for,test,class,clazz,string,transaction,manager,name,boolean,default,rollback,if,config,null,transaction,manager,name,config,transaction,manager,default,rollback,config,default,rollback,else,transaction,manager,name,default,rollback,transaction,configuration,attributes,config,attributes,new,transaction,configuration,attributes,transaction,manager,name,default,rollback,if,logger,is,debug,enabled,logger,debug,retrieved,transaction,configuration,attributes,config,attributes,for,class,clazz,this,configuration,attributes,config,attributes,return,this,configuration,attributes
TransactionalTestExecutionListener -> private TransactionConfigurationAttributes retrieveConfigurationAttributes(TestContext testContext);1355352386;Retrieves the {@link TransactionConfigurationAttributes} for the_specified {@link Class class} which may optionally declare or inherit_{@link TransactionConfiguration &#064_TransactionConfiguration}. If_{@code @TransactionConfiguration} is not present for the supplied_class, the <em>default values</em> for attributes defined in_{@code @TransactionConfiguration} will be used instead._@param testContext the test context for which the configuration_attributes should be retrieved_@return a new TransactionConfigurationAttributes instance;private TransactionConfigurationAttributes retrieveConfigurationAttributes(TestContext testContext) {_		if (this.configurationAttributes == null) {_			Class<?> clazz = testContext.getTestClass()__			TransactionConfiguration config = clazz.getAnnotation(TransactionConfiguration.class)__			if (logger.isDebugEnabled()) {_				logger.debug("Retrieved @TransactionConfiguration [" + config + "] for test class [" + clazz + "]")__			}__			String transactionManagerName__			boolean defaultRollback__			if (config != null) {_				transactionManagerName = config.transactionManager()__				defaultRollback = config.defaultRollback()__			}_			else {_				transactionManagerName = DEFAULT_TRANSACTION_MANAGER_NAME__				defaultRollback = DEFAULT_DEFAULT_ROLLBACK__			}__			TransactionConfigurationAttributes configAttributes = new TransactionConfigurationAttributes(_				transactionManagerName, defaultRollback)__			if (logger.isDebugEnabled()) {_				logger.debug("Retrieved TransactionConfigurationAttributes " + configAttributes + " for class ["_						+ clazz + "]")__			}_			this.configurationAttributes = configAttributes__		}_		return this.configurationAttributes__	};retrieves,the,link,transaction,configuration,attributes,for,the,specified,link,class,class,which,may,optionally,declare,or,inherit,link,transaction,configuration,064,transaction,configuration,if,code,transaction,configuration,is,not,present,for,the,supplied,class,the,em,default,values,em,for,attributes,defined,in,code,transaction,configuration,will,be,used,instead,param,test,context,the,test,context,for,which,the,configuration,attributes,should,be,retrieved,return,a,new,transaction,configuration,attributes,instance;private,transaction,configuration,attributes,retrieve,configuration,attributes,test,context,test,context,if,this,configuration,attributes,null,class,clazz,test,context,get,test,class,transaction,configuration,config,clazz,get,annotation,transaction,configuration,class,if,logger,is,debug,enabled,logger,debug,retrieved,transaction,configuration,config,for,test,class,clazz,string,transaction,manager,name,boolean,default,rollback,if,config,null,transaction,manager,name,config,transaction,manager,default,rollback,config,default,rollback,else,transaction,manager,name,default,rollback,transaction,configuration,attributes,config,attributes,new,transaction,configuration,attributes,transaction,manager,name,default,rollback,if,logger,is,debug,enabled,logger,debug,retrieved,transaction,configuration,attributes,config,attributes,for,class,clazz,this,configuration,attributes,config,attributes,return,this,configuration,attributes
TransactionalTestExecutionListener -> private TransactionConfigurationAttributes retrieveConfigurationAttributes(TestContext testContext);1356735495;Retrieves the {@link TransactionConfigurationAttributes} for the_specified {@link Class class} which may optionally declare or inherit_{@link TransactionConfiguration &#064_TransactionConfiguration}. If_{@code @TransactionConfiguration} is not present for the supplied_class, the <em>default values</em> for attributes defined in_{@code @TransactionConfiguration} will be used instead._@param testContext the test context for which the configuration_attributes should be retrieved_@return a new TransactionConfigurationAttributes instance;private TransactionConfigurationAttributes retrieveConfigurationAttributes(TestContext testContext) {_		if (this.configurationAttributes == null) {_			Class<?> clazz = testContext.getTestClass()__			TransactionConfiguration config = clazz.getAnnotation(TransactionConfiguration.class)__			if (logger.isDebugEnabled()) {_				logger.debug("Retrieved @TransactionConfiguration [" + config + "] for test class [" + clazz + "]")__			}__			String transactionManagerName__			boolean defaultRollback__			if (config != null) {_				transactionManagerName = config.transactionManager()__				defaultRollback = config.defaultRollback()__			}_			else {_				transactionManagerName = DEFAULT_TRANSACTION_MANAGER_NAME__				defaultRollback = DEFAULT_DEFAULT_ROLLBACK__			}__			TransactionConfigurationAttributes configAttributes = new TransactionConfigurationAttributes(_				transactionManagerName, defaultRollback)__			if (logger.isDebugEnabled()) {_				logger.debug("Retrieved TransactionConfigurationAttributes " + configAttributes + " for class ["_						+ clazz + "]")__			}_			this.configurationAttributes = configAttributes__		}_		return this.configurationAttributes__	};retrieves,the,link,transaction,configuration,attributes,for,the,specified,link,class,class,which,may,optionally,declare,or,inherit,link,transaction,configuration,064,transaction,configuration,if,code,transaction,configuration,is,not,present,for,the,supplied,class,the,em,default,values,em,for,attributes,defined,in,code,transaction,configuration,will,be,used,instead,param,test,context,the,test,context,for,which,the,configuration,attributes,should,be,retrieved,return,a,new,transaction,configuration,attributes,instance;private,transaction,configuration,attributes,retrieve,configuration,attributes,test,context,test,context,if,this,configuration,attributes,null,class,clazz,test,context,get,test,class,transaction,configuration,config,clazz,get,annotation,transaction,configuration,class,if,logger,is,debug,enabled,logger,debug,retrieved,transaction,configuration,config,for,test,class,clazz,string,transaction,manager,name,boolean,default,rollback,if,config,null,transaction,manager,name,config,transaction,manager,default,rollback,config,default,rollback,else,transaction,manager,name,default,rollback,transaction,configuration,attributes,config,attributes,new,transaction,configuration,attributes,transaction,manager,name,default,rollback,if,logger,is,debug,enabled,logger,debug,retrieved,transaction,configuration,attributes,config,attributes,for,class,clazz,this,configuration,attributes,config,attributes,return,this,configuration,attributes
TransactionalTestExecutionListener -> private TransactionConfigurationAttributes retrieveConfigurationAttributes(TestContext testContext);1357119239;Retrieves the {@link TransactionConfigurationAttributes} for the_specified {@link Class class} which may optionally declare or inherit_{@link TransactionConfiguration &#064_TransactionConfiguration}. If_{@code @TransactionConfiguration} is not present for the supplied_class, the <em>default values</em> for attributes defined in_{@code @TransactionConfiguration} will be used instead._@param testContext the test context for which the configuration_attributes should be retrieved_@return a new TransactionConfigurationAttributes instance;private TransactionConfigurationAttributes retrieveConfigurationAttributes(TestContext testContext) {_		if (this.configurationAttributes == null) {_			Class<?> clazz = testContext.getTestClass()__			TransactionConfiguration config = clazz.getAnnotation(TransactionConfiguration.class)__			if (logger.isDebugEnabled()) {_				logger.debug("Retrieved @TransactionConfiguration [" + config + "] for test class [" + clazz + "]")__			}__			String transactionManagerName__			boolean defaultRollback__			if (config != null) {_				transactionManagerName = config.transactionManager()__				defaultRollback = config.defaultRollback()__			}_			else {_				transactionManagerName = DEFAULT_TRANSACTION_MANAGER_NAME__				defaultRollback = DEFAULT_DEFAULT_ROLLBACK__			}__			TransactionConfigurationAttributes configAttributes = new TransactionConfigurationAttributes(_				transactionManagerName, defaultRollback)__			if (logger.isDebugEnabled()) {_				logger.debug("Retrieved TransactionConfigurationAttributes " + configAttributes + " for class ["_						+ clazz + "]")__			}_			this.configurationAttributes = configAttributes__		}_		return this.configurationAttributes__	};retrieves,the,link,transaction,configuration,attributes,for,the,specified,link,class,class,which,may,optionally,declare,or,inherit,link,transaction,configuration,064,transaction,configuration,if,code,transaction,configuration,is,not,present,for,the,supplied,class,the,em,default,values,em,for,attributes,defined,in,code,transaction,configuration,will,be,used,instead,param,test,context,the,test,context,for,which,the,configuration,attributes,should,be,retrieved,return,a,new,transaction,configuration,attributes,instance;private,transaction,configuration,attributes,retrieve,configuration,attributes,test,context,test,context,if,this,configuration,attributes,null,class,clazz,test,context,get,test,class,transaction,configuration,config,clazz,get,annotation,transaction,configuration,class,if,logger,is,debug,enabled,logger,debug,retrieved,transaction,configuration,config,for,test,class,clazz,string,transaction,manager,name,boolean,default,rollback,if,config,null,transaction,manager,name,config,transaction,manager,default,rollback,config,default,rollback,else,transaction,manager,name,default,rollback,transaction,configuration,attributes,config,attributes,new,transaction,configuration,attributes,transaction,manager,name,default,rollback,if,logger,is,debug,enabled,logger,debug,retrieved,transaction,configuration,attributes,config,attributes,for,class,clazz,this,configuration,attributes,config,attributes,return,this,configuration,attributes
TransactionalTestExecutionListener -> private TransactionConfigurationAttributes retrieveConfigurationAttributes(TestContext testContext);1367163114;Retrieves the {@link TransactionConfigurationAttributes} for the_specified {@link Class class} which may optionally declare or inherit_{@link TransactionConfiguration &#064_TransactionConfiguration}. If_{@code @TransactionConfiguration} is not present for the supplied_class, the <em>default values</em> for attributes defined in_{@code @TransactionConfiguration} will be used instead._@param testContext the test context for which the configuration_attributes should be retrieved_@return a new TransactionConfigurationAttributes instance;private TransactionConfigurationAttributes retrieveConfigurationAttributes(TestContext testContext) {_		if (this.configurationAttributes == null) {_			Class<?> clazz = testContext.getTestClass()__			TransactionConfiguration config = clazz.getAnnotation(TransactionConfiguration.class)__			if (logger.isDebugEnabled()) {_				logger.debug("Retrieved @TransactionConfiguration [" + config + "] for test class [" + clazz + "]")__			}__			String transactionManagerName__			boolean defaultRollback__			if (config != null) {_				transactionManagerName = config.transactionManager()__				defaultRollback = config.defaultRollback()__			}_			else {_				transactionManagerName = DEFAULT_TRANSACTION_MANAGER_NAME__				defaultRollback = DEFAULT_DEFAULT_ROLLBACK__			}__			TransactionConfigurationAttributes configAttributes = new TransactionConfigurationAttributes(_				transactionManagerName, defaultRollback)__			if (logger.isDebugEnabled()) {_				logger.debug("Retrieved TransactionConfigurationAttributes " + configAttributes + " for class ["_						+ clazz + "]")__			}_			this.configurationAttributes = configAttributes__		}_		return this.configurationAttributes__	};retrieves,the,link,transaction,configuration,attributes,for,the,specified,link,class,class,which,may,optionally,declare,or,inherit,link,transaction,configuration,064,transaction,configuration,if,code,transaction,configuration,is,not,present,for,the,supplied,class,the,em,default,values,em,for,attributes,defined,in,code,transaction,configuration,will,be,used,instead,param,test,context,the,test,context,for,which,the,configuration,attributes,should,be,retrieved,return,a,new,transaction,configuration,attributes,instance;private,transaction,configuration,attributes,retrieve,configuration,attributes,test,context,test,context,if,this,configuration,attributes,null,class,clazz,test,context,get,test,class,transaction,configuration,config,clazz,get,annotation,transaction,configuration,class,if,logger,is,debug,enabled,logger,debug,retrieved,transaction,configuration,config,for,test,class,clazz,string,transaction,manager,name,boolean,default,rollback,if,config,null,transaction,manager,name,config,transaction,manager,default,rollback,config,default,rollback,else,transaction,manager,name,default,rollback,transaction,configuration,attributes,config,attributes,new,transaction,configuration,attributes,transaction,manager,name,default,rollback,if,logger,is,debug,enabled,logger,debug,retrieved,transaction,configuration,attributes,config,attributes,for,class,clazz,this,configuration,attributes,config,attributes,return,this,configuration,attributes
TransactionalTestExecutionListener -> private TransactionConfigurationAttributes retrieveConfigurationAttributes(TestContext testContext);1367873075;Retrieves the {@link TransactionConfigurationAttributes} for the_specified {@link Class class} which may optionally declare or inherit_{@link TransactionConfiguration &#064_TransactionConfiguration}. If_{@code @TransactionConfiguration} is not present for the supplied_class, the <em>default values</em> for attributes defined in_{@code @TransactionConfiguration} will be used instead._@param testContext the test context for which the configuration_attributes should be retrieved_@return a new TransactionConfigurationAttributes instance;private TransactionConfigurationAttributes retrieveConfigurationAttributes(TestContext testContext) {_		if (this.configurationAttributes == null) {_			Class<?> clazz = testContext.getTestClass()__			TransactionConfiguration config = clazz.getAnnotation(TransactionConfiguration.class)__			if (logger.isDebugEnabled()) {_				logger.debug("Retrieved @TransactionConfiguration [" + config + "] for test class [" + clazz + "]")__			}__			String transactionManagerName__			boolean defaultRollback__			if (config != null) {_				transactionManagerName = config.transactionManager()__				defaultRollback = config.defaultRollback()__			}_			else {_				transactionManagerName = DEFAULT_TRANSACTION_MANAGER_NAME__				defaultRollback = DEFAULT_DEFAULT_ROLLBACK__			}__			TransactionConfigurationAttributes configAttributes = new TransactionConfigurationAttributes(_				transactionManagerName, defaultRollback)__			if (logger.isDebugEnabled()) {_				logger.debug("Retrieved TransactionConfigurationAttributes " + configAttributes + " for class ["_						+ clazz + "]")__			}_			this.configurationAttributes = configAttributes__		}_		return this.configurationAttributes__	};retrieves,the,link,transaction,configuration,attributes,for,the,specified,link,class,class,which,may,optionally,declare,or,inherit,link,transaction,configuration,064,transaction,configuration,if,code,transaction,configuration,is,not,present,for,the,supplied,class,the,em,default,values,em,for,attributes,defined,in,code,transaction,configuration,will,be,used,instead,param,test,context,the,test,context,for,which,the,configuration,attributes,should,be,retrieved,return,a,new,transaction,configuration,attributes,instance;private,transaction,configuration,attributes,retrieve,configuration,attributes,test,context,test,context,if,this,configuration,attributes,null,class,clazz,test,context,get,test,class,transaction,configuration,config,clazz,get,annotation,transaction,configuration,class,if,logger,is,debug,enabled,logger,debug,retrieved,transaction,configuration,config,for,test,class,clazz,string,transaction,manager,name,boolean,default,rollback,if,config,null,transaction,manager,name,config,transaction,manager,default,rollback,config,default,rollback,else,transaction,manager,name,default,rollback,transaction,configuration,attributes,config,attributes,new,transaction,configuration,attributes,transaction,manager,name,default,rollback,if,logger,is,debug,enabled,logger,debug,retrieved,transaction,configuration,attributes,config,attributes,for,class,clazz,this,configuration,attributes,config,attributes,return,this,configuration,attributes
TransactionalTestExecutionListener -> private TransactionConfigurationAttributes retrieveConfigurationAttributes(TestContext testContext);1368482696;Retrieves the {@link TransactionConfigurationAttributes} for the_specified {@link Class class} which may optionally declare or inherit_{@link TransactionConfiguration &#064_TransactionConfiguration}. If_{@code @TransactionConfiguration} is not present for the supplied_class, the <em>default values</em> for attributes defined in_{@code @TransactionConfiguration} will be used instead._@param testContext the test context for which the configuration_attributes should be retrieved_@return a new TransactionConfigurationAttributes instance;private TransactionConfigurationAttributes retrieveConfigurationAttributes(TestContext testContext) {_		if (this.configurationAttributes == null) {_			Class<?> clazz = testContext.getTestClass()__			TransactionConfiguration config = clazz.getAnnotation(TransactionConfiguration.class)__			if (logger.isDebugEnabled()) {_				logger.debug("Retrieved @TransactionConfiguration [" + config + "] for test class [" + clazz + "]")__			}__			String transactionManagerName__			boolean defaultRollback__			if (config != null) {_				transactionManagerName = config.transactionManager()__				defaultRollback = config.defaultRollback()__			}_			else {_				transactionManagerName = DEFAULT_TRANSACTION_MANAGER_NAME__				defaultRollback = DEFAULT_DEFAULT_ROLLBACK__			}__			TransactionConfigurationAttributes configAttributes = new TransactionConfigurationAttributes(_				transactionManagerName, defaultRollback)__			if (logger.isDebugEnabled()) {_				logger.debug("Retrieved TransactionConfigurationAttributes " + configAttributes + " for class ["_						+ clazz + "]")__			}_			this.configurationAttributes = configAttributes__		}_		return this.configurationAttributes__	};retrieves,the,link,transaction,configuration,attributes,for,the,specified,link,class,class,which,may,optionally,declare,or,inherit,link,transaction,configuration,064,transaction,configuration,if,code,transaction,configuration,is,not,present,for,the,supplied,class,the,em,default,values,em,for,attributes,defined,in,code,transaction,configuration,will,be,used,instead,param,test,context,the,test,context,for,which,the,configuration,attributes,should,be,retrieved,return,a,new,transaction,configuration,attributes,instance;private,transaction,configuration,attributes,retrieve,configuration,attributes,test,context,test,context,if,this,configuration,attributes,null,class,clazz,test,context,get,test,class,transaction,configuration,config,clazz,get,annotation,transaction,configuration,class,if,logger,is,debug,enabled,logger,debug,retrieved,transaction,configuration,config,for,test,class,clazz,string,transaction,manager,name,boolean,default,rollback,if,config,null,transaction,manager,name,config,transaction,manager,default,rollback,config,default,rollback,else,transaction,manager,name,default,rollback,transaction,configuration,attributes,config,attributes,new,transaction,configuration,attributes,transaction,manager,name,default,rollback,if,logger,is,debug,enabled,logger,debug,retrieved,transaction,configuration,attributes,config,attributes,for,class,clazz,this,configuration,attributes,config,attributes,return,this,configuration,attributes
TransactionalTestExecutionListener -> private TransactionConfigurationAttributes retrieveConfigurationAttributes(TestContext testContext);1382920864;Retrieves the {@link TransactionConfigurationAttributes} for the_specified {@link Class class} which may optionally declare or inherit_{@link TransactionConfiguration &#064_TransactionConfiguration}. If_{@code @TransactionConfiguration} is not present for the supplied_class, the <em>default values</em> for attributes defined in_{@code @TransactionConfiguration} will be used instead._@param testContext the test context for which the configuration_attributes should be retrieved_@return a new TransactionConfigurationAttributes instance;private TransactionConfigurationAttributes retrieveConfigurationAttributes(TestContext testContext) {_		if (this.configurationAttributes == null) {_			Class<?> clazz = testContext.getTestClass()__			TransactionConfiguration config = findAnnotation(clazz, TransactionConfiguration.class)__			if (logger.isDebugEnabled()) {_				logger.debug("Retrieved @TransactionConfiguration [" + config + "] for test class [" + clazz + "]")__			}__			String transactionManagerName__			boolean defaultRollback__			if (config != null) {_				transactionManagerName = config.transactionManager()__				defaultRollback = config.defaultRollback()__			}_			else {_				transactionManagerName = DEFAULT_TRANSACTION_MANAGER_NAME__				defaultRollback = DEFAULT_DEFAULT_ROLLBACK__			}__			TransactionConfigurationAttributes configAttributes = new TransactionConfigurationAttributes(_				transactionManagerName, defaultRollback)__			if (logger.isDebugEnabled()) {_				logger.debug("Retrieved TransactionConfigurationAttributes " + configAttributes + " for class ["_						+ clazz + "]")__			}_			this.configurationAttributes = configAttributes__		}_		return this.configurationAttributes__	};retrieves,the,link,transaction,configuration,attributes,for,the,specified,link,class,class,which,may,optionally,declare,or,inherit,link,transaction,configuration,064,transaction,configuration,if,code,transaction,configuration,is,not,present,for,the,supplied,class,the,em,default,values,em,for,attributes,defined,in,code,transaction,configuration,will,be,used,instead,param,test,context,the,test,context,for,which,the,configuration,attributes,should,be,retrieved,return,a,new,transaction,configuration,attributes,instance;private,transaction,configuration,attributes,retrieve,configuration,attributes,test,context,test,context,if,this,configuration,attributes,null,class,clazz,test,context,get,test,class,transaction,configuration,config,find,annotation,clazz,transaction,configuration,class,if,logger,is,debug,enabled,logger,debug,retrieved,transaction,configuration,config,for,test,class,clazz,string,transaction,manager,name,boolean,default,rollback,if,config,null,transaction,manager,name,config,transaction,manager,default,rollback,config,default,rollback,else,transaction,manager,name,default,rollback,transaction,configuration,attributes,config,attributes,new,transaction,configuration,attributes,transaction,manager,name,default,rollback,if,logger,is,debug,enabled,logger,debug,retrieved,transaction,configuration,attributes,config,attributes,for,class,clazz,this,configuration,attributes,config,attributes,return,this,configuration,attributes
TransactionalTestExecutionListener -> protected void runAfterTransactionMethods(TestContext testContext) throws Exception;1328020251;Run all {@link AfterTransaction &#064_AfterTransaction methods} for the_specified {@link TestContext test context}. If one of the methods fails,_the caught exception will be logged as an error, and the remaining_methods will be given a chance to execute. After all methods have_executed, the first caught exception, if any, will be rethrown._@param testContext the current test context;protected void runAfterTransactionMethods(TestContext testContext) throws Exception {_		Throwable afterTransactionException = null___		List<Method> methods = getAnnotatedMethods(testContext.getTestClass(), AfterTransaction.class)__		for (Method method : methods) {_			try {_				if (logger.isDebugEnabled()) {_					logger.debug("Executing @AfterTransaction method [" + method + "] for test context [" + testContext_							+ "]")__				}_				method.invoke(testContext.getTestInstance())__			}_			catch (InvocationTargetException ex) {_				Throwable targetException = ex.getTargetException()__				if (afterTransactionException == null) {_					afterTransactionException = targetException__				}_				logger.error("Exception encountered while executing @AfterTransaction method [" + method_						+ "] for test context [" + testContext + "]", targetException)__			}_			catch (Exception ex) {_				if (afterTransactionException == null) {_					afterTransactionException = ex__				}_				logger.error("Exception encountered while executing @AfterTransaction method [" + method_						+ "] for test context [" + testContext + "]", ex)__			}_		}__		if (afterTransactionException != null) {_			ReflectionUtils.rethrowException(afterTransactionException)__		}_	};run,all,link,after,transaction,064,after,transaction,methods,for,the,specified,link,test,context,test,context,if,one,of,the,methods,fails,the,caught,exception,will,be,logged,as,an,error,and,the,remaining,methods,will,be,given,a,chance,to,execute,after,all,methods,have,executed,the,first,caught,exception,if,any,will,be,rethrown,param,test,context,the,current,test,context;protected,void,run,after,transaction,methods,test,context,test,context,throws,exception,throwable,after,transaction,exception,null,list,method,methods,get,annotated,methods,test,context,get,test,class,after,transaction,class,for,method,method,methods,try,if,logger,is,debug,enabled,logger,debug,executing,after,transaction,method,method,for,test,context,test,context,method,invoke,test,context,get,test,instance,catch,invocation,target,exception,ex,throwable,target,exception,ex,get,target,exception,if,after,transaction,exception,null,after,transaction,exception,target,exception,logger,error,exception,encountered,while,executing,after,transaction,method,method,for,test,context,test,context,target,exception,catch,exception,ex,if,after,transaction,exception,null,after,transaction,exception,ex,logger,error,exception,encountered,while,executing,after,transaction,method,method,for,test,context,test,context,ex,if,after,transaction,exception,null,reflection,utils,rethrow,exception,after,transaction,exception
TransactionalTestExecutionListener -> protected void runAfterTransactionMethods(TestContext testContext) throws Exception;1337516454;Run all {@link AfterTransaction &#064_AfterTransaction methods} for the_specified {@link TestContext test context}. If one of the methods fails,_the caught exception will be logged as an error, and the remaining_methods will be given a chance to execute. After all methods have_executed, the first caught exception, if any, will be rethrown._@param testContext the current test context;protected void runAfterTransactionMethods(TestContext testContext) throws Exception {_		Throwable afterTransactionException = null___		List<Method> methods = getAnnotatedMethods(testContext.getTestClass(), AfterTransaction.class)__		for (Method method : methods) {_			try {_				if (logger.isDebugEnabled()) {_					logger.debug("Executing @AfterTransaction method [" + method + "] for test context [" + testContext_							+ "]")__				}_				method.invoke(testContext.getTestInstance())__			}_			catch (InvocationTargetException ex) {_				Throwable targetException = ex.getTargetException()__				if (afterTransactionException == null) {_					afterTransactionException = targetException__				}_				logger.error("Exception encountered while executing @AfterTransaction method [" + method_						+ "] for test context [" + testContext + "]", targetException)__			}_			catch (Exception ex) {_				if (afterTransactionException == null) {_					afterTransactionException = ex__				}_				logger.error("Exception encountered while executing @AfterTransaction method [" + method_						+ "] for test context [" + testContext + "]", ex)__			}_		}__		if (afterTransactionException != null) {_			ReflectionUtils.rethrowException(afterTransactionException)__		}_	};run,all,link,after,transaction,064,after,transaction,methods,for,the,specified,link,test,context,test,context,if,one,of,the,methods,fails,the,caught,exception,will,be,logged,as,an,error,and,the,remaining,methods,will,be,given,a,chance,to,execute,after,all,methods,have,executed,the,first,caught,exception,if,any,will,be,rethrown,param,test,context,the,current,test,context;protected,void,run,after,transaction,methods,test,context,test,context,throws,exception,throwable,after,transaction,exception,null,list,method,methods,get,annotated,methods,test,context,get,test,class,after,transaction,class,for,method,method,methods,try,if,logger,is,debug,enabled,logger,debug,executing,after,transaction,method,method,for,test,context,test,context,method,invoke,test,context,get,test,instance,catch,invocation,target,exception,ex,throwable,target,exception,ex,get,target,exception,if,after,transaction,exception,null,after,transaction,exception,target,exception,logger,error,exception,encountered,while,executing,after,transaction,method,method,for,test,context,test,context,target,exception,catch,exception,ex,if,after,transaction,exception,null,after,transaction,exception,ex,logger,error,exception,encountered,while,executing,after,transaction,method,method,for,test,context,test,context,ex,if,after,transaction,exception,null,reflection,utils,rethrow,exception,after,transaction,exception
TransactionalTestExecutionListener -> protected void runAfterTransactionMethods(TestContext testContext) throws Exception;1338031377;Run all {@link AfterTransaction &#064_AfterTransaction methods} for the_specified {@link TestContext test context}. If one of the methods fails,_the caught exception will be logged as an error, and the remaining_methods will be given a chance to execute. After all methods have_executed, the first caught exception, if any, will be rethrown._@param testContext the current test context;protected void runAfterTransactionMethods(TestContext testContext) throws Exception {_		Throwable afterTransactionException = null___		List<Method> methods = getAnnotatedMethods(testContext.getTestClass(), AfterTransaction.class)__		for (Method method : methods) {_			try {_				if (logger.isDebugEnabled()) {_					logger.debug("Executing @AfterTransaction method [" + method + "] for test context [" + testContext_							+ "]")__				}_				method.invoke(testContext.getTestInstance())__			}_			catch (InvocationTargetException ex) {_				Throwable targetException = ex.getTargetException()__				if (afterTransactionException == null) {_					afterTransactionException = targetException__				}_				logger.error("Exception encountered while executing @AfterTransaction method [" + method_						+ "] for test context [" + testContext + "]", targetException)__			}_			catch (Exception ex) {_				if (afterTransactionException == null) {_					afterTransactionException = ex__				}_				logger.error("Exception encountered while executing @AfterTransaction method [" + method_						+ "] for test context [" + testContext + "]", ex)__			}_		}__		if (afterTransactionException != null) {_			ReflectionUtils.rethrowException(afterTransactionException)__		}_	};run,all,link,after,transaction,064,after,transaction,methods,for,the,specified,link,test,context,test,context,if,one,of,the,methods,fails,the,caught,exception,will,be,logged,as,an,error,and,the,remaining,methods,will,be,given,a,chance,to,execute,after,all,methods,have,executed,the,first,caught,exception,if,any,will,be,rethrown,param,test,context,the,current,test,context;protected,void,run,after,transaction,methods,test,context,test,context,throws,exception,throwable,after,transaction,exception,null,list,method,methods,get,annotated,methods,test,context,get,test,class,after,transaction,class,for,method,method,methods,try,if,logger,is,debug,enabled,logger,debug,executing,after,transaction,method,method,for,test,context,test,context,method,invoke,test,context,get,test,instance,catch,invocation,target,exception,ex,throwable,target,exception,ex,get,target,exception,if,after,transaction,exception,null,after,transaction,exception,target,exception,logger,error,exception,encountered,while,executing,after,transaction,method,method,for,test,context,test,context,target,exception,catch,exception,ex,if,after,transaction,exception,null,after,transaction,exception,ex,logger,error,exception,encountered,while,executing,after,transaction,method,method,for,test,context,test,context,ex,if,after,transaction,exception,null,reflection,utils,rethrow,exception,after,transaction,exception
TransactionalTestExecutionListener -> protected void runAfterTransactionMethods(TestContext testContext) throws Exception;1343426806;Run all {@link AfterTransaction &#064_AfterTransaction methods} for the_specified {@link TestContext test context}. If one of the methods fails,_the caught exception will be logged as an error, and the remaining_methods will be given a chance to execute. After all methods have_executed, the first caught exception, if any, will be rethrown._@param testContext the current test context;protected void runAfterTransactionMethods(TestContext testContext) throws Exception {_		Throwable afterTransactionException = null___		List<Method> methods = getAnnotatedMethods(testContext.getTestClass(), AfterTransaction.class)__		for (Method method : methods) {_			try {_				if (logger.isDebugEnabled()) {_					logger.debug("Executing @AfterTransaction method [" + method + "] for test context " + testContext)__				}_				method.invoke(testContext.getTestInstance())__			}_			catch (InvocationTargetException ex) {_				Throwable targetException = ex.getTargetException()__				if (afterTransactionException == null) {_					afterTransactionException = targetException__				}_				logger.error("Exception encountered while executing @AfterTransaction method [" + method_						+ "] for test context " + testContext, targetException)__			}_			catch (Exception ex) {_				if (afterTransactionException == null) {_					afterTransactionException = ex__				}_				logger.error("Exception encountered while executing @AfterTransaction method [" + method_						+ "] for test context " + testContext, ex)__			}_		}__		if (afterTransactionException != null) {_			ReflectionUtils.rethrowException(afterTransactionException)__		}_	};run,all,link,after,transaction,064,after,transaction,methods,for,the,specified,link,test,context,test,context,if,one,of,the,methods,fails,the,caught,exception,will,be,logged,as,an,error,and,the,remaining,methods,will,be,given,a,chance,to,execute,after,all,methods,have,executed,the,first,caught,exception,if,any,will,be,rethrown,param,test,context,the,current,test,context;protected,void,run,after,transaction,methods,test,context,test,context,throws,exception,throwable,after,transaction,exception,null,list,method,methods,get,annotated,methods,test,context,get,test,class,after,transaction,class,for,method,method,methods,try,if,logger,is,debug,enabled,logger,debug,executing,after,transaction,method,method,for,test,context,test,context,method,invoke,test,context,get,test,instance,catch,invocation,target,exception,ex,throwable,target,exception,ex,get,target,exception,if,after,transaction,exception,null,after,transaction,exception,target,exception,logger,error,exception,encountered,while,executing,after,transaction,method,method,for,test,context,test,context,target,exception,catch,exception,ex,if,after,transaction,exception,null,after,transaction,exception,ex,logger,error,exception,encountered,while,executing,after,transaction,method,method,for,test,context,test,context,ex,if,after,transaction,exception,null,reflection,utils,rethrow,exception,after,transaction,exception
TransactionalTestExecutionListener -> protected void runAfterTransactionMethods(TestContext testContext) throws Exception;1343431472;Run all {@link AfterTransaction &#064_AfterTransaction methods} for the_specified {@link TestContext test context}. If one of the methods fails,_the caught exception will be logged as an error, and the remaining_methods will be given a chance to execute. After all methods have_executed, the first caught exception, if any, will be rethrown._@param testContext the current test context;protected void runAfterTransactionMethods(TestContext testContext) throws Exception {_		Throwable afterTransactionException = null___		List<Method> methods = getAnnotatedMethods(testContext.getTestClass(), AfterTransaction.class)__		for (Method method : methods) {_			try {_				if (logger.isDebugEnabled()) {_					logger.debug("Executing @AfterTransaction method [" + method + "] for test context " + testContext)__				}_				method.invoke(testContext.getTestInstance())__			}_			catch (InvocationTargetException ex) {_				Throwable targetException = ex.getTargetException()__				if (afterTransactionException == null) {_					afterTransactionException = targetException__				}_				logger.error("Exception encountered while executing @AfterTransaction method [" + method_						+ "] for test context " + testContext, targetException)__			}_			catch (Exception ex) {_				if (afterTransactionException == null) {_					afterTransactionException = ex__				}_				logger.error("Exception encountered while executing @AfterTransaction method [" + method_						+ "] for test context " + testContext, ex)__			}_		}__		if (afterTransactionException != null) {_			ReflectionUtils.rethrowException(afterTransactionException)__		}_	};run,all,link,after,transaction,064,after,transaction,methods,for,the,specified,link,test,context,test,context,if,one,of,the,methods,fails,the,caught,exception,will,be,logged,as,an,error,and,the,remaining,methods,will,be,given,a,chance,to,execute,after,all,methods,have,executed,the,first,caught,exception,if,any,will,be,rethrown,param,test,context,the,current,test,context;protected,void,run,after,transaction,methods,test,context,test,context,throws,exception,throwable,after,transaction,exception,null,list,method,methods,get,annotated,methods,test,context,get,test,class,after,transaction,class,for,method,method,methods,try,if,logger,is,debug,enabled,logger,debug,executing,after,transaction,method,method,for,test,context,test,context,method,invoke,test,context,get,test,instance,catch,invocation,target,exception,ex,throwable,target,exception,ex,get,target,exception,if,after,transaction,exception,null,after,transaction,exception,target,exception,logger,error,exception,encountered,while,executing,after,transaction,method,method,for,test,context,test,context,target,exception,catch,exception,ex,if,after,transaction,exception,null,after,transaction,exception,ex,logger,error,exception,encountered,while,executing,after,transaction,method,method,for,test,context,test,context,ex,if,after,transaction,exception,null,reflection,utils,rethrow,exception,after,transaction,exception
TransactionalTestExecutionListener -> protected void runAfterTransactionMethods(TestContext testContext) throws Exception;1354571539;Run all {@link AfterTransaction &#064_AfterTransaction methods} for the_specified {@link TestContext test context}. If one of the methods fails,_the caught exception will be logged as an error, and the remaining_methods will be given a chance to execute. After all methods have_executed, the first caught exception, if any, will be rethrown._@param testContext the current test context;protected void runAfterTransactionMethods(TestContext testContext) throws Exception {_		Throwable afterTransactionException = null___		List<Method> methods = getAnnotatedMethods(testContext.getTestClass(), AfterTransaction.class)__		for (Method method : methods) {_			try {_				if (logger.isDebugEnabled()) {_					logger.debug("Executing @AfterTransaction method [" + method + "] for test context " + testContext)__				}_				method.invoke(testContext.getTestInstance())__			}_			catch (InvocationTargetException ex) {_				Throwable targetException = ex.getTargetException()__				if (afterTransactionException == null) {_					afterTransactionException = targetException__				}_				logger.error("Exception encountered while executing @AfterTransaction method [" + method_						+ "] for test context " + testContext, targetException)__			}_			catch (Exception ex) {_				if (afterTransactionException == null) {_					afterTransactionException = ex__				}_				logger.error("Exception encountered while executing @AfterTransaction method [" + method_						+ "] for test context " + testContext, ex)__			}_		}__		if (afterTransactionException != null) {_			ReflectionUtils.rethrowException(afterTransactionException)__		}_	};run,all,link,after,transaction,064,after,transaction,methods,for,the,specified,link,test,context,test,context,if,one,of,the,methods,fails,the,caught,exception,will,be,logged,as,an,error,and,the,remaining,methods,will,be,given,a,chance,to,execute,after,all,methods,have,executed,the,first,caught,exception,if,any,will,be,rethrown,param,test,context,the,current,test,context;protected,void,run,after,transaction,methods,test,context,test,context,throws,exception,throwable,after,transaction,exception,null,list,method,methods,get,annotated,methods,test,context,get,test,class,after,transaction,class,for,method,method,methods,try,if,logger,is,debug,enabled,logger,debug,executing,after,transaction,method,method,for,test,context,test,context,method,invoke,test,context,get,test,instance,catch,invocation,target,exception,ex,throwable,target,exception,ex,get,target,exception,if,after,transaction,exception,null,after,transaction,exception,target,exception,logger,error,exception,encountered,while,executing,after,transaction,method,method,for,test,context,test,context,target,exception,catch,exception,ex,if,after,transaction,exception,null,after,transaction,exception,ex,logger,error,exception,encountered,while,executing,after,transaction,method,method,for,test,context,test,context,ex,if,after,transaction,exception,null,reflection,utils,rethrow,exception,after,transaction,exception
TransactionalTestExecutionListener -> protected void runAfterTransactionMethods(TestContext testContext) throws Exception;1355352386;Run all {@link AfterTransaction &#064_AfterTransaction methods} for the_specified {@link TestContext test context}. If one of the methods fails,_the caught exception will be logged as an error, and the remaining_methods will be given a chance to execute. After all methods have_executed, the first caught exception, if any, will be rethrown._@param testContext the current test context;protected void runAfterTransactionMethods(TestContext testContext) throws Exception {_		Throwable afterTransactionException = null___		List<Method> methods = getAnnotatedMethods(testContext.getTestClass(), AfterTransaction.class)__		for (Method method : methods) {_			try {_				if (logger.isDebugEnabled()) {_					logger.debug("Executing @AfterTransaction method [" + method + "] for test context " + testContext)__				}_				method.invoke(testContext.getTestInstance())__			}_			catch (InvocationTargetException ex) {_				Throwable targetException = ex.getTargetException()__				if (afterTransactionException == null) {_					afterTransactionException = targetException__				}_				logger.error("Exception encountered while executing @AfterTransaction method [" + method_						+ "] for test context " + testContext, targetException)__			}_			catch (Exception ex) {_				if (afterTransactionException == null) {_					afterTransactionException = ex__				}_				logger.error("Exception encountered while executing @AfterTransaction method [" + method_						+ "] for test context " + testContext, ex)__			}_		}__		if (afterTransactionException != null) {_			ReflectionUtils.rethrowException(afterTransactionException)__		}_	};run,all,link,after,transaction,064,after,transaction,methods,for,the,specified,link,test,context,test,context,if,one,of,the,methods,fails,the,caught,exception,will,be,logged,as,an,error,and,the,remaining,methods,will,be,given,a,chance,to,execute,after,all,methods,have,executed,the,first,caught,exception,if,any,will,be,rethrown,param,test,context,the,current,test,context;protected,void,run,after,transaction,methods,test,context,test,context,throws,exception,throwable,after,transaction,exception,null,list,method,methods,get,annotated,methods,test,context,get,test,class,after,transaction,class,for,method,method,methods,try,if,logger,is,debug,enabled,logger,debug,executing,after,transaction,method,method,for,test,context,test,context,method,invoke,test,context,get,test,instance,catch,invocation,target,exception,ex,throwable,target,exception,ex,get,target,exception,if,after,transaction,exception,null,after,transaction,exception,target,exception,logger,error,exception,encountered,while,executing,after,transaction,method,method,for,test,context,test,context,target,exception,catch,exception,ex,if,after,transaction,exception,null,after,transaction,exception,ex,logger,error,exception,encountered,while,executing,after,transaction,method,method,for,test,context,test,context,ex,if,after,transaction,exception,null,reflection,utils,rethrow,exception,after,transaction,exception
TransactionalTestExecutionListener -> protected void runAfterTransactionMethods(TestContext testContext) throws Exception;1356735495;Run all {@link AfterTransaction &#064_AfterTransaction methods} for the_specified {@link TestContext test context}. If one of the methods fails,_the caught exception will be logged as an error, and the remaining_methods will be given a chance to execute. After all methods have_executed, the first caught exception, if any, will be rethrown._@param testContext the current test context;protected void runAfterTransactionMethods(TestContext testContext) throws Exception {_		Throwable afterTransactionException = null___		List<Method> methods = getAnnotatedMethods(testContext.getTestClass(), AfterTransaction.class)__		for (Method method : methods) {_			try {_				if (logger.isDebugEnabled()) {_					logger.debug("Executing @AfterTransaction method [" + method + "] for test context " + testContext)__				}_				method.invoke(testContext.getTestInstance())__			}_			catch (InvocationTargetException ex) {_				Throwable targetException = ex.getTargetException()__				if (afterTransactionException == null) {_					afterTransactionException = targetException__				}_				logger.error("Exception encountered while executing @AfterTransaction method [" + method_						+ "] for test context " + testContext, targetException)__			}_			catch (Exception ex) {_				if (afterTransactionException == null) {_					afterTransactionException = ex__				}_				logger.error("Exception encountered while executing @AfterTransaction method [" + method_						+ "] for test context " + testContext, ex)__			}_		}__		if (afterTransactionException != null) {_			ReflectionUtils.rethrowException(afterTransactionException)__		}_	};run,all,link,after,transaction,064,after,transaction,methods,for,the,specified,link,test,context,test,context,if,one,of,the,methods,fails,the,caught,exception,will,be,logged,as,an,error,and,the,remaining,methods,will,be,given,a,chance,to,execute,after,all,methods,have,executed,the,first,caught,exception,if,any,will,be,rethrown,param,test,context,the,current,test,context;protected,void,run,after,transaction,methods,test,context,test,context,throws,exception,throwable,after,transaction,exception,null,list,method,methods,get,annotated,methods,test,context,get,test,class,after,transaction,class,for,method,method,methods,try,if,logger,is,debug,enabled,logger,debug,executing,after,transaction,method,method,for,test,context,test,context,method,invoke,test,context,get,test,instance,catch,invocation,target,exception,ex,throwable,target,exception,ex,get,target,exception,if,after,transaction,exception,null,after,transaction,exception,target,exception,logger,error,exception,encountered,while,executing,after,transaction,method,method,for,test,context,test,context,target,exception,catch,exception,ex,if,after,transaction,exception,null,after,transaction,exception,ex,logger,error,exception,encountered,while,executing,after,transaction,method,method,for,test,context,test,context,ex,if,after,transaction,exception,null,reflection,utils,rethrow,exception,after,transaction,exception
TransactionalTestExecutionListener -> protected void runAfterTransactionMethods(TestContext testContext) throws Exception;1357119239;Run all {@link AfterTransaction &#064_AfterTransaction methods} for the_specified {@link TestContext test context}. If one of the methods fails,_the caught exception will be logged as an error, and the remaining_methods will be given a chance to execute. After all methods have_executed, the first caught exception, if any, will be rethrown._@param testContext the current test context;protected void runAfterTransactionMethods(TestContext testContext) throws Exception {_		Throwable afterTransactionException = null___		List<Method> methods = getAnnotatedMethods(testContext.getTestClass(), AfterTransaction.class)__		for (Method method : methods) {_			try {_				if (logger.isDebugEnabled()) {_					logger.debug("Executing @AfterTransaction method [" + method + "] for test context " + testContext)__				}_				method.invoke(testContext.getTestInstance())__			}_			catch (InvocationTargetException ex) {_				Throwable targetException = ex.getTargetException()__				if (afterTransactionException == null) {_					afterTransactionException = targetException__				}_				logger.error("Exception encountered while executing @AfterTransaction method [" + method_						+ "] for test context " + testContext, targetException)__			}_			catch (Exception ex) {_				if (afterTransactionException == null) {_					afterTransactionException = ex__				}_				logger.error("Exception encountered while executing @AfterTransaction method [" + method_						+ "] for test context " + testContext, ex)__			}_		}__		if (afterTransactionException != null) {_			ReflectionUtils.rethrowException(afterTransactionException)__		}_	};run,all,link,after,transaction,064,after,transaction,methods,for,the,specified,link,test,context,test,context,if,one,of,the,methods,fails,the,caught,exception,will,be,logged,as,an,error,and,the,remaining,methods,will,be,given,a,chance,to,execute,after,all,methods,have,executed,the,first,caught,exception,if,any,will,be,rethrown,param,test,context,the,current,test,context;protected,void,run,after,transaction,methods,test,context,test,context,throws,exception,throwable,after,transaction,exception,null,list,method,methods,get,annotated,methods,test,context,get,test,class,after,transaction,class,for,method,method,methods,try,if,logger,is,debug,enabled,logger,debug,executing,after,transaction,method,method,for,test,context,test,context,method,invoke,test,context,get,test,instance,catch,invocation,target,exception,ex,throwable,target,exception,ex,get,target,exception,if,after,transaction,exception,null,after,transaction,exception,target,exception,logger,error,exception,encountered,while,executing,after,transaction,method,method,for,test,context,test,context,target,exception,catch,exception,ex,if,after,transaction,exception,null,after,transaction,exception,ex,logger,error,exception,encountered,while,executing,after,transaction,method,method,for,test,context,test,context,ex,if,after,transaction,exception,null,reflection,utils,rethrow,exception,after,transaction,exception
TransactionalTestExecutionListener -> protected void runAfterTransactionMethods(TestContext testContext) throws Exception;1367163114;Run all {@link AfterTransaction &#064_AfterTransaction methods} for the_specified {@link TestContext test context}. If one of the methods fails,_the caught exception will be logged as an error, and the remaining_methods will be given a chance to execute. After all methods have_executed, the first caught exception, if any, will be rethrown._@param testContext the current test context;protected void runAfterTransactionMethods(TestContext testContext) throws Exception {_		Throwable afterTransactionException = null___		List<Method> methods = getAnnotatedMethods(testContext.getTestClass(), AfterTransaction.class)__		for (Method method : methods) {_			try {_				if (logger.isDebugEnabled()) {_					logger.debug("Executing @AfterTransaction method [" + method + "] for test context " + testContext)__				}_				method.invoke(testContext.getTestInstance())__			}_			catch (InvocationTargetException ex) {_				Throwable targetException = ex.getTargetException()__				if (afterTransactionException == null) {_					afterTransactionException = targetException__				}_				logger.error("Exception encountered while executing @AfterTransaction method [" + method_						+ "] for test context " + testContext, targetException)__			}_			catch (Exception ex) {_				if (afterTransactionException == null) {_					afterTransactionException = ex__				}_				logger.error("Exception encountered while executing @AfterTransaction method [" + method_						+ "] for test context " + testContext, ex)__			}_		}__		if (afterTransactionException != null) {_			ReflectionUtils.rethrowException(afterTransactionException)__		}_	};run,all,link,after,transaction,064,after,transaction,methods,for,the,specified,link,test,context,test,context,if,one,of,the,methods,fails,the,caught,exception,will,be,logged,as,an,error,and,the,remaining,methods,will,be,given,a,chance,to,execute,after,all,methods,have,executed,the,first,caught,exception,if,any,will,be,rethrown,param,test,context,the,current,test,context;protected,void,run,after,transaction,methods,test,context,test,context,throws,exception,throwable,after,transaction,exception,null,list,method,methods,get,annotated,methods,test,context,get,test,class,after,transaction,class,for,method,method,methods,try,if,logger,is,debug,enabled,logger,debug,executing,after,transaction,method,method,for,test,context,test,context,method,invoke,test,context,get,test,instance,catch,invocation,target,exception,ex,throwable,target,exception,ex,get,target,exception,if,after,transaction,exception,null,after,transaction,exception,target,exception,logger,error,exception,encountered,while,executing,after,transaction,method,method,for,test,context,test,context,target,exception,catch,exception,ex,if,after,transaction,exception,null,after,transaction,exception,ex,logger,error,exception,encountered,while,executing,after,transaction,method,method,for,test,context,test,context,ex,if,after,transaction,exception,null,reflection,utils,rethrow,exception,after,transaction,exception
TransactionalTestExecutionListener -> protected void runAfterTransactionMethods(TestContext testContext) throws Exception;1367873075;Run all {@link AfterTransaction &#064_AfterTransaction methods} for the_specified {@link TestContext test context}. If one of the methods fails,_the caught exception will be logged as an error, and the remaining_methods will be given a chance to execute. After all methods have_executed, the first caught exception, if any, will be rethrown._@param testContext the current test context;protected void runAfterTransactionMethods(TestContext testContext) throws Exception {_		Throwable afterTransactionException = null___		List<Method> methods = getAnnotatedMethods(testContext.getTestClass(), AfterTransaction.class)__		for (Method method : methods) {_			try {_				if (logger.isDebugEnabled()) {_					logger.debug("Executing @AfterTransaction method [" + method + "] for test context " + testContext)__				}_				method.invoke(testContext.getTestInstance())__			}_			catch (InvocationTargetException ex) {_				Throwable targetException = ex.getTargetException()__				if (afterTransactionException == null) {_					afterTransactionException = targetException__				}_				logger.error("Exception encountered while executing @AfterTransaction method [" + method_						+ "] for test context " + testContext, targetException)__			}_			catch (Exception ex) {_				if (afterTransactionException == null) {_					afterTransactionException = ex__				}_				logger.error("Exception encountered while executing @AfterTransaction method [" + method_						+ "] for test context " + testContext, ex)__			}_		}__		if (afterTransactionException != null) {_			ReflectionUtils.rethrowException(afterTransactionException)__		}_	};run,all,link,after,transaction,064,after,transaction,methods,for,the,specified,link,test,context,test,context,if,one,of,the,methods,fails,the,caught,exception,will,be,logged,as,an,error,and,the,remaining,methods,will,be,given,a,chance,to,execute,after,all,methods,have,executed,the,first,caught,exception,if,any,will,be,rethrown,param,test,context,the,current,test,context;protected,void,run,after,transaction,methods,test,context,test,context,throws,exception,throwable,after,transaction,exception,null,list,method,methods,get,annotated,methods,test,context,get,test,class,after,transaction,class,for,method,method,methods,try,if,logger,is,debug,enabled,logger,debug,executing,after,transaction,method,method,for,test,context,test,context,method,invoke,test,context,get,test,instance,catch,invocation,target,exception,ex,throwable,target,exception,ex,get,target,exception,if,after,transaction,exception,null,after,transaction,exception,target,exception,logger,error,exception,encountered,while,executing,after,transaction,method,method,for,test,context,test,context,target,exception,catch,exception,ex,if,after,transaction,exception,null,after,transaction,exception,ex,logger,error,exception,encountered,while,executing,after,transaction,method,method,for,test,context,test,context,ex,if,after,transaction,exception,null,reflection,utils,rethrow,exception,after,transaction,exception
TransactionalTestExecutionListener -> protected void runAfterTransactionMethods(TestContext testContext) throws Exception;1368482696;Run all {@link AfterTransaction &#064_AfterTransaction methods} for the_specified {@link TestContext test context}. If one of the methods fails,_the caught exception will be logged as an error, and the remaining_methods will be given a chance to execute. After all methods have_executed, the first caught exception, if any, will be rethrown._@param testContext the current test context;protected void runAfterTransactionMethods(TestContext testContext) throws Exception {_		Throwable afterTransactionException = null___		List<Method> methods = getAnnotatedMethods(testContext.getTestClass(), AfterTransaction.class)__		for (Method method : methods) {_			try {_				if (logger.isDebugEnabled()) {_					logger.debug("Executing @AfterTransaction method [" + method + "] for test context " + testContext)__				}_				method.invoke(testContext.getTestInstance())__			}_			catch (InvocationTargetException ex) {_				Throwable targetException = ex.getTargetException()__				if (afterTransactionException == null) {_					afterTransactionException = targetException__				}_				logger.error("Exception encountered while executing @AfterTransaction method [" + method_						+ "] for test context " + testContext, targetException)__			}_			catch (Exception ex) {_				if (afterTransactionException == null) {_					afterTransactionException = ex__				}_				logger.error("Exception encountered while executing @AfterTransaction method [" + method_						+ "] for test context " + testContext, ex)__			}_		}__		if (afterTransactionException != null) {_			ReflectionUtils.rethrowException(afterTransactionException)__		}_	};run,all,link,after,transaction,064,after,transaction,methods,for,the,specified,link,test,context,test,context,if,one,of,the,methods,fails,the,caught,exception,will,be,logged,as,an,error,and,the,remaining,methods,will,be,given,a,chance,to,execute,after,all,methods,have,executed,the,first,caught,exception,if,any,will,be,rethrown,param,test,context,the,current,test,context;protected,void,run,after,transaction,methods,test,context,test,context,throws,exception,throwable,after,transaction,exception,null,list,method,methods,get,annotated,methods,test,context,get,test,class,after,transaction,class,for,method,method,methods,try,if,logger,is,debug,enabled,logger,debug,executing,after,transaction,method,method,for,test,context,test,context,method,invoke,test,context,get,test,instance,catch,invocation,target,exception,ex,throwable,target,exception,ex,get,target,exception,if,after,transaction,exception,null,after,transaction,exception,target,exception,logger,error,exception,encountered,while,executing,after,transaction,method,method,for,test,context,test,context,target,exception,catch,exception,ex,if,after,transaction,exception,null,after,transaction,exception,ex,logger,error,exception,encountered,while,executing,after,transaction,method,method,for,test,context,test,context,ex,if,after,transaction,exception,null,reflection,utils,rethrow,exception,after,transaction,exception
TransactionalTestExecutionListener -> protected void runAfterTransactionMethods(TestContext testContext) throws Exception;1382920864;Run all {@link AfterTransaction &#064_AfterTransaction methods} for the_specified {@link TestContext test context}. If one of the methods fails,_the caught exception will be logged as an error, and the remaining_methods will be given a chance to execute. After all methods have_executed, the first caught exception, if any, will be rethrown._@param testContext the current test context;protected void runAfterTransactionMethods(TestContext testContext) throws Exception {_		Throwable afterTransactionException = null___		List<Method> methods = getAnnotatedMethods(testContext.getTestClass(), AfterTransaction.class)__		for (Method method : methods) {_			try {_				if (logger.isDebugEnabled()) {_					logger.debug("Executing @AfterTransaction method [" + method + "] for test context " + testContext)__				}_				method.invoke(testContext.getTestInstance())__			}_			catch (InvocationTargetException ex) {_				Throwable targetException = ex.getTargetException()__				if (afterTransactionException == null) {_					afterTransactionException = targetException__				}_				logger.error("Exception encountered while executing @AfterTransaction method [" + method_						+ "] for test context " + testContext, targetException)__			}_			catch (Exception ex) {_				if (afterTransactionException == null) {_					afterTransactionException = ex__				}_				logger.error("Exception encountered while executing @AfterTransaction method [" + method_						+ "] for test context " + testContext, ex)__			}_		}__		if (afterTransactionException != null) {_			ReflectionUtils.rethrowException(afterTransactionException)__		}_	};run,all,link,after,transaction,064,after,transaction,methods,for,the,specified,link,test,context,test,context,if,one,of,the,methods,fails,the,caught,exception,will,be,logged,as,an,error,and,the,remaining,methods,will,be,given,a,chance,to,execute,after,all,methods,have,executed,the,first,caught,exception,if,any,will,be,rethrown,param,test,context,the,current,test,context;protected,void,run,after,transaction,methods,test,context,test,context,throws,exception,throwable,after,transaction,exception,null,list,method,methods,get,annotated,methods,test,context,get,test,class,after,transaction,class,for,method,method,methods,try,if,logger,is,debug,enabled,logger,debug,executing,after,transaction,method,method,for,test,context,test,context,method,invoke,test,context,get,test,instance,catch,invocation,target,exception,ex,throwable,target,exception,ex,get,target,exception,if,after,transaction,exception,null,after,transaction,exception,target,exception,logger,error,exception,encountered,while,executing,after,transaction,method,method,for,test,context,test,context,target,exception,catch,exception,ex,if,after,transaction,exception,null,after,transaction,exception,ex,logger,error,exception,encountered,while,executing,after,transaction,method,method,for,test,context,test,context,ex,if,after,transaction,exception,null,reflection,utils,rethrow,exception,after,transaction,exception
TransactionalTestExecutionListener -> protected void runAfterTransactionMethods(TestContext testContext) throws Exception;1385499540;Run all {@link AfterTransaction &#064_AfterTransaction methods} for the_specified {@link TestContext test context}. If one of the methods fails,_the caught exception will be logged as an error, and the remaining_methods will be given a chance to execute. After all methods have_executed, the first caught exception, if any, will be rethrown._@param testContext the current test context;protected void runAfterTransactionMethods(TestContext testContext) throws Exception {_		Throwable afterTransactionException = null___		List<Method> methods = getAnnotatedMethods(testContext.getTestClass(), AfterTransaction.class)__		for (Method method : methods) {_			try {_				if (logger.isDebugEnabled()) {_					logger.debug("Executing @AfterTransaction method [" + method + "] for test context " + testContext)__				}_				method.invoke(testContext.getTestInstance())__			}_			catch (InvocationTargetException ex) {_				Throwable targetException = ex.getTargetException()__				if (afterTransactionException == null) {_					afterTransactionException = targetException__				}_				logger.error("Exception encountered while executing @AfterTransaction method [" + method_						+ "] for test context " + testContext, targetException)__			}_			catch (Exception ex) {_				if (afterTransactionException == null) {_					afterTransactionException = ex__				}_				logger.error("Exception encountered while executing @AfterTransaction method [" + method_						+ "] for test context " + testContext, ex)__			}_		}__		if (afterTransactionException != null) {_			ReflectionUtils.rethrowException(afterTransactionException)__		}_	};run,all,link,after,transaction,064,after,transaction,methods,for,the,specified,link,test,context,test,context,if,one,of,the,methods,fails,the,caught,exception,will,be,logged,as,an,error,and,the,remaining,methods,will,be,given,a,chance,to,execute,after,all,methods,have,executed,the,first,caught,exception,if,any,will,be,rethrown,param,test,context,the,current,test,context;protected,void,run,after,transaction,methods,test,context,test,context,throws,exception,throwable,after,transaction,exception,null,list,method,methods,get,annotated,methods,test,context,get,test,class,after,transaction,class,for,method,method,methods,try,if,logger,is,debug,enabled,logger,debug,executing,after,transaction,method,method,for,test,context,test,context,method,invoke,test,context,get,test,instance,catch,invocation,target,exception,ex,throwable,target,exception,ex,get,target,exception,if,after,transaction,exception,null,after,transaction,exception,target,exception,logger,error,exception,encountered,while,executing,after,transaction,method,method,for,test,context,test,context,target,exception,catch,exception,ex,if,after,transaction,exception,null,after,transaction,exception,ex,logger,error,exception,encountered,while,executing,after,transaction,method,method,for,test,context,test,context,ex,if,after,transaction,exception,null,reflection,utils,rethrow,exception,after,transaction,exception
TransactionalTestExecutionListener -> protected void runAfterTransactionMethods(TestContext testContext) throws Exception;1389966876;Run all {@link AfterTransaction &#064_AfterTransaction methods} for the_specified {@link TestContext test context}. If one of the methods fails,_the caught exception will be logged as an error, and the remaining_methods will be given a chance to execute. After all methods have_executed, the first caught exception, if any, will be rethrown._@param testContext the current test context;protected void runAfterTransactionMethods(TestContext testContext) throws Exception {_		Throwable afterTransactionException = null___		List<Method> methods = getAnnotatedMethods(testContext.getTestClass(), AfterTransaction.class)__		for (Method method : methods) {_			try {_				if (logger.isDebugEnabled()) {_					logger.debug("Executing @AfterTransaction method [" + method + "] for test context " + testContext)__				}_				method.invoke(testContext.getTestInstance())__			}_			catch (InvocationTargetException ex) {_				Throwable targetException = ex.getTargetException()__				if (afterTransactionException == null) {_					afterTransactionException = targetException__				}_				logger.error("Exception encountered while executing @AfterTransaction method [" + method_						+ "] for test context " + testContext, targetException)__			}_			catch (Exception ex) {_				if (afterTransactionException == null) {_					afterTransactionException = ex__				}_				logger.error("Exception encountered while executing @AfterTransaction method [" + method_						+ "] for test context " + testContext, ex)__			}_		}__		if (afterTransactionException != null) {_			ReflectionUtils.rethrowException(afterTransactionException)__		}_	};run,all,link,after,transaction,064,after,transaction,methods,for,the,specified,link,test,context,test,context,if,one,of,the,methods,fails,the,caught,exception,will,be,logged,as,an,error,and,the,remaining,methods,will,be,given,a,chance,to,execute,after,all,methods,have,executed,the,first,caught,exception,if,any,will,be,rethrown,param,test,context,the,current,test,context;protected,void,run,after,transaction,methods,test,context,test,context,throws,exception,throwable,after,transaction,exception,null,list,method,methods,get,annotated,methods,test,context,get,test,class,after,transaction,class,for,method,method,methods,try,if,logger,is,debug,enabled,logger,debug,executing,after,transaction,method,method,for,test,context,test,context,method,invoke,test,context,get,test,instance,catch,invocation,target,exception,ex,throwable,target,exception,ex,get,target,exception,if,after,transaction,exception,null,after,transaction,exception,target,exception,logger,error,exception,encountered,while,executing,after,transaction,method,method,for,test,context,test,context,target,exception,catch,exception,ex,if,after,transaction,exception,null,after,transaction,exception,ex,logger,error,exception,encountered,while,executing,after,transaction,method,method,for,test,context,test,context,ex,if,after,transaction,exception,null,reflection,utils,rethrow,exception,after,transaction,exception
TransactionalTestExecutionListener -> protected void runAfterTransactionMethods(TestContext testContext) throws Exception;1401991965;Run all {@link AfterTransaction &#064_AfterTransaction methods} for the_specified {@link TestContext test context}. If one of the methods fails,_the caught exception will be logged as an error, and the remaining_methods will be given a chance to execute. After all methods have_executed, the first caught exception, if any, will be rethrown._@param testContext the current test context;protected void runAfterTransactionMethods(TestContext testContext) throws Exception {_		Throwable afterTransactionException = null___		List<Method> methods = getAnnotatedMethods(testContext.getTestClass(), AfterTransaction.class)__		for (Method method : methods) {_			try {_				if (logger.isDebugEnabled()) {_					logger.debug("Executing @AfterTransaction method [" + method + "] for test context " + testContext)__				}_				method.invoke(testContext.getTestInstance())__			}_			catch (InvocationTargetException ex) {_				Throwable targetException = ex.getTargetException()__				if (afterTransactionException == null) {_					afterTransactionException = targetException__				}_				logger.error("Exception encountered while executing @AfterTransaction method [" + method_						+ "] for test context " + testContext, targetException)__			}_			catch (Exception ex) {_				if (afterTransactionException == null) {_					afterTransactionException = ex__				}_				logger.error("Exception encountered while executing @AfterTransaction method [" + method_						+ "] for test context " + testContext, ex)__			}_		}__		if (afterTransactionException != null) {_			ReflectionUtils.rethrowException(afterTransactionException)__		}_	};run,all,link,after,transaction,064,after,transaction,methods,for,the,specified,link,test,context,test,context,if,one,of,the,methods,fails,the,caught,exception,will,be,logged,as,an,error,and,the,remaining,methods,will,be,given,a,chance,to,execute,after,all,methods,have,executed,the,first,caught,exception,if,any,will,be,rethrown,param,test,context,the,current,test,context;protected,void,run,after,transaction,methods,test,context,test,context,throws,exception,throwable,after,transaction,exception,null,list,method,methods,get,annotated,methods,test,context,get,test,class,after,transaction,class,for,method,method,methods,try,if,logger,is,debug,enabled,logger,debug,executing,after,transaction,method,method,for,test,context,test,context,method,invoke,test,context,get,test,instance,catch,invocation,target,exception,ex,throwable,target,exception,ex,get,target,exception,if,after,transaction,exception,null,after,transaction,exception,target,exception,logger,error,exception,encountered,while,executing,after,transaction,method,method,for,test,context,test,context,target,exception,catch,exception,ex,if,after,transaction,exception,null,after,transaction,exception,ex,logger,error,exception,encountered,while,executing,after,transaction,method,method,for,test,context,test,context,ex,if,after,transaction,exception,null,reflection,utils,rethrow,exception,after,transaction,exception
TransactionalTestExecutionListener -> protected void runAfterTransactionMethods(TestContext testContext) throws Exception;1404334604;Run all {@link AfterTransaction @AfterTransaction} methods for the_specified {@link TestContext test context}. If one of the methods fails,_the caught exception will be logged as an error, and the remaining_methods will be given a chance to execute. After all methods have_executed, the first caught exception, if any, will be rethrown._@param testContext the current test context;protected void runAfterTransactionMethods(TestContext testContext) throws Exception {_		Throwable afterTransactionException = null___		List<Method> methods = getAnnotatedMethods(testContext.getTestClass(), AfterTransaction.class)__		for (Method method : methods) {_			try {_				if (logger.isDebugEnabled()) {_					logger.debug("Executing @AfterTransaction method [" + method + "] for test context " + testContext)__				}_				method.invoke(testContext.getTestInstance())__			}_			catch (InvocationTargetException ex) {_				Throwable targetException = ex.getTargetException()__				if (afterTransactionException == null) {_					afterTransactionException = targetException__				}_				logger.error("Exception encountered while executing @AfterTransaction method [" + method_						+ "] for test context " + testContext, targetException)__			}_			catch (Exception ex) {_				if (afterTransactionException == null) {_					afterTransactionException = ex__				}_				logger.error("Exception encountered while executing @AfterTransaction method [" + method_						+ "] for test context " + testContext, ex)__			}_		}__		if (afterTransactionException != null) {_			ReflectionUtils.rethrowException(afterTransactionException)__		}_	};run,all,link,after,transaction,after,transaction,methods,for,the,specified,link,test,context,test,context,if,one,of,the,methods,fails,the,caught,exception,will,be,logged,as,an,error,and,the,remaining,methods,will,be,given,a,chance,to,execute,after,all,methods,have,executed,the,first,caught,exception,if,any,will,be,rethrown,param,test,context,the,current,test,context;protected,void,run,after,transaction,methods,test,context,test,context,throws,exception,throwable,after,transaction,exception,null,list,method,methods,get,annotated,methods,test,context,get,test,class,after,transaction,class,for,method,method,methods,try,if,logger,is,debug,enabled,logger,debug,executing,after,transaction,method,method,for,test,context,test,context,method,invoke,test,context,get,test,instance,catch,invocation,target,exception,ex,throwable,target,exception,ex,get,target,exception,if,after,transaction,exception,null,after,transaction,exception,target,exception,logger,error,exception,encountered,while,executing,after,transaction,method,method,for,test,context,test,context,target,exception,catch,exception,ex,if,after,transaction,exception,null,after,transaction,exception,ex,logger,error,exception,encountered,while,executing,after,transaction,method,method,for,test,context,test,context,ex,if,after,transaction,exception,null,reflection,utils,rethrow,exception,after,transaction,exception
TransactionalTestExecutionListener -> protected void runAfterTransactionMethods(TestContext testContext) throws Exception;1405645143;Run all {@link AfterTransaction @AfterTransaction} methods for the_specified {@link TestContext test context}. If one of the methods fails,_the caught exception will be logged as an error, and the remaining_methods will be given a chance to execute. After all methods have_executed, the first caught exception, if any, will be rethrown._@param testContext the current test context;protected void runAfterTransactionMethods(TestContext testContext) throws Exception {_		Throwable afterTransactionException = null___		List<Method> methods = getAnnotatedMethods(testContext.getTestClass(), AfterTransaction.class)__		for (Method method : methods) {_			try {_				if (logger.isDebugEnabled()) {_					logger.debug("Executing @AfterTransaction method [" + method + "] for test context " + testContext)__				}_				method.invoke(testContext.getTestInstance())__			}_			catch (InvocationTargetException ex) {_				Throwable targetException = ex.getTargetException()__				if (afterTransactionException == null) {_					afterTransactionException = targetException__				}_				logger.error("Exception encountered while executing @AfterTransaction method [" + method_						+ "] for test context " + testContext, targetException)__			}_			catch (Exception ex) {_				if (afterTransactionException == null) {_					afterTransactionException = ex__				}_				logger.error("Exception encountered while executing @AfterTransaction method [" + method_						+ "] for test context " + testContext, ex)__			}_		}__		if (afterTransactionException != null) {_			ReflectionUtils.rethrowException(afterTransactionException)__		}_	};run,all,link,after,transaction,after,transaction,methods,for,the,specified,link,test,context,test,context,if,one,of,the,methods,fails,the,caught,exception,will,be,logged,as,an,error,and,the,remaining,methods,will,be,given,a,chance,to,execute,after,all,methods,have,executed,the,first,caught,exception,if,any,will,be,rethrown,param,test,context,the,current,test,context;protected,void,run,after,transaction,methods,test,context,test,context,throws,exception,throwable,after,transaction,exception,null,list,method,methods,get,annotated,methods,test,context,get,test,class,after,transaction,class,for,method,method,methods,try,if,logger,is,debug,enabled,logger,debug,executing,after,transaction,method,method,for,test,context,test,context,method,invoke,test,context,get,test,instance,catch,invocation,target,exception,ex,throwable,target,exception,ex,get,target,exception,if,after,transaction,exception,null,after,transaction,exception,target,exception,logger,error,exception,encountered,while,executing,after,transaction,method,method,for,test,context,test,context,target,exception,catch,exception,ex,if,after,transaction,exception,null,after,transaction,exception,ex,logger,error,exception,encountered,while,executing,after,transaction,method,method,for,test,context,test,context,ex,if,after,transaction,exception,null,reflection,utils,rethrow,exception,after,transaction,exception
TransactionalTestExecutionListener -> protected void runAfterTransactionMethods(TestContext testContext) throws Exception;1405698612;Run all {@link AfterTransaction @AfterTransaction} methods for the_specified {@link TestContext test context}. If one of the methods fails,_the caught exception will be logged as an error, and the remaining_methods will be given a chance to execute. After all methods have_executed, the first caught exception, if any, will be rethrown._@param testContext the current test context;protected void runAfterTransactionMethods(TestContext testContext) throws Exception {_		Throwable afterTransactionException = null___		List<Method> methods = getAnnotatedMethods(testContext.getTestClass(), AfterTransaction.class)__		for (Method method : methods) {_			try {_				if (logger.isDebugEnabled()) {_					logger.debug("Executing @AfterTransaction method [" + method + "] for test context " + testContext)__				}_				method.invoke(testContext.getTestInstance())__			}_			catch (InvocationTargetException ex) {_				Throwable targetException = ex.getTargetException()__				if (afterTransactionException == null) {_					afterTransactionException = targetException__				}_				logger.error("Exception encountered while executing @AfterTransaction method [" + method_						+ "] for test context " + testContext, targetException)__			}_			catch (Exception ex) {_				if (afterTransactionException == null) {_					afterTransactionException = ex__				}_				logger.error("Exception encountered while executing @AfterTransaction method [" + method_						+ "] for test context " + testContext, ex)__			}_		}__		if (afterTransactionException != null) {_			ReflectionUtils.rethrowException(afterTransactionException)__		}_	};run,all,link,after,transaction,after,transaction,methods,for,the,specified,link,test,context,test,context,if,one,of,the,methods,fails,the,caught,exception,will,be,logged,as,an,error,and,the,remaining,methods,will,be,given,a,chance,to,execute,after,all,methods,have,executed,the,first,caught,exception,if,any,will,be,rethrown,param,test,context,the,current,test,context;protected,void,run,after,transaction,methods,test,context,test,context,throws,exception,throwable,after,transaction,exception,null,list,method,methods,get,annotated,methods,test,context,get,test,class,after,transaction,class,for,method,method,methods,try,if,logger,is,debug,enabled,logger,debug,executing,after,transaction,method,method,for,test,context,test,context,method,invoke,test,context,get,test,instance,catch,invocation,target,exception,ex,throwable,target,exception,ex,get,target,exception,if,after,transaction,exception,null,after,transaction,exception,target,exception,logger,error,exception,encountered,while,executing,after,transaction,method,method,for,test,context,test,context,target,exception,catch,exception,ex,if,after,transaction,exception,null,after,transaction,exception,ex,logger,error,exception,encountered,while,executing,after,transaction,method,method,for,test,context,test,context,ex,if,after,transaction,exception,null,reflection,utils,rethrow,exception,after,transaction,exception
TransactionalTestExecutionListener -> protected void runAfterTransactionMethods(TestContext testContext) throws Exception;1405759527;Run all {@link AfterTransaction @AfterTransaction} methods for the_specified {@link TestContext test context}. If one of the methods fails,_the caught exception will be logged as an error, and the remaining_methods will be given a chance to execute. After all methods have_executed, the first caught exception, if any, will be rethrown._@param testContext the current test context;protected void runAfterTransactionMethods(TestContext testContext) throws Exception {_		Throwable afterTransactionException = null___		List<Method> methods = getAnnotatedMethods(testContext.getTestClass(), AfterTransaction.class)__		for (Method method : methods) {_			try {_				if (logger.isDebugEnabled()) {_					logger.debug("Executing @AfterTransaction method [" + method + "] for test context " + testContext)__				}_				method.invoke(testContext.getTestInstance())__			}_			catch (InvocationTargetException ex) {_				Throwable targetException = ex.getTargetException()__				if (afterTransactionException == null) {_					afterTransactionException = targetException__				}_				logger.error("Exception encountered while executing @AfterTransaction method [" + method_						+ "] for test context " + testContext, targetException)__			}_			catch (Exception ex) {_				if (afterTransactionException == null) {_					afterTransactionException = ex__				}_				logger.error("Exception encountered while executing @AfterTransaction method [" + method_						+ "] for test context " + testContext, ex)__			}_		}__		if (afterTransactionException != null) {_			ReflectionUtils.rethrowException(afterTransactionException)__		}_	};run,all,link,after,transaction,after,transaction,methods,for,the,specified,link,test,context,test,context,if,one,of,the,methods,fails,the,caught,exception,will,be,logged,as,an,error,and,the,remaining,methods,will,be,given,a,chance,to,execute,after,all,methods,have,executed,the,first,caught,exception,if,any,will,be,rethrown,param,test,context,the,current,test,context;protected,void,run,after,transaction,methods,test,context,test,context,throws,exception,throwable,after,transaction,exception,null,list,method,methods,get,annotated,methods,test,context,get,test,class,after,transaction,class,for,method,method,methods,try,if,logger,is,debug,enabled,logger,debug,executing,after,transaction,method,method,for,test,context,test,context,method,invoke,test,context,get,test,instance,catch,invocation,target,exception,ex,throwable,target,exception,ex,get,target,exception,if,after,transaction,exception,null,after,transaction,exception,target,exception,logger,error,exception,encountered,while,executing,after,transaction,method,method,for,test,context,test,context,target,exception,catch,exception,ex,if,after,transaction,exception,null,after,transaction,exception,ex,logger,error,exception,encountered,while,executing,after,transaction,method,method,for,test,context,test,context,ex,if,after,transaction,exception,null,reflection,utils,rethrow,exception,after,transaction,exception
TransactionalTestExecutionListener -> protected void runAfterTransactionMethods(TestContext testContext) throws Exception;1405759966;Run all {@link AfterTransaction @AfterTransaction} methods for the_specified {@link TestContext test context}. If one of the methods fails,_the caught exception will be logged as an error, and the remaining_methods will be given a chance to execute. After all methods have_executed, the first caught exception, if any, will be rethrown._@param testContext the current test context;protected void runAfterTransactionMethods(TestContext testContext) throws Exception {_		Throwable afterTransactionException = null___		List<Method> methods = getAnnotatedMethods(testContext.getTestClass(), AfterTransaction.class)__		for (Method method : methods) {_			try {_				if (logger.isDebugEnabled()) {_					logger.debug("Executing @AfterTransaction method [" + method + "] for test context " + testContext)__				}_				method.invoke(testContext.getTestInstance())__			}_			catch (InvocationTargetException ex) {_				Throwable targetException = ex.getTargetException()__				if (afterTransactionException == null) {_					afterTransactionException = targetException__				}_				logger.error("Exception encountered while executing @AfterTransaction method [" + method_						+ "] for test context " + testContext, targetException)__			}_			catch (Exception ex) {_				if (afterTransactionException == null) {_					afterTransactionException = ex__				}_				logger.error("Exception encountered while executing @AfterTransaction method [" + method_						+ "] for test context " + testContext, ex)__			}_		}__		if (afterTransactionException != null) {_			ReflectionUtils.rethrowException(afterTransactionException)__		}_	};run,all,link,after,transaction,after,transaction,methods,for,the,specified,link,test,context,test,context,if,one,of,the,methods,fails,the,caught,exception,will,be,logged,as,an,error,and,the,remaining,methods,will,be,given,a,chance,to,execute,after,all,methods,have,executed,the,first,caught,exception,if,any,will,be,rethrown,param,test,context,the,current,test,context;protected,void,run,after,transaction,methods,test,context,test,context,throws,exception,throwable,after,transaction,exception,null,list,method,methods,get,annotated,methods,test,context,get,test,class,after,transaction,class,for,method,method,methods,try,if,logger,is,debug,enabled,logger,debug,executing,after,transaction,method,method,for,test,context,test,context,method,invoke,test,context,get,test,instance,catch,invocation,target,exception,ex,throwable,target,exception,ex,get,target,exception,if,after,transaction,exception,null,after,transaction,exception,target,exception,logger,error,exception,encountered,while,executing,after,transaction,method,method,for,test,context,test,context,target,exception,catch,exception,ex,if,after,transaction,exception,null,after,transaction,exception,ex,logger,error,exception,encountered,while,executing,after,transaction,method,method,for,test,context,test,context,ex,if,after,transaction,exception,null,reflection,utils,rethrow,exception,after,transaction,exception
TransactionalTestExecutionListener -> protected void runAfterTransactionMethods(TestContext testContext) throws Exception;1406218418;Run all {@link AfterTransaction @AfterTransaction} methods for the_specified {@link TestContext test context}. If one of the methods fails,_the caught exception will be logged as an error, and the remaining_methods will be given a chance to execute. After all methods have_executed, the first caught exception, if any, will be rethrown._@param testContext the current test context;protected void runAfterTransactionMethods(TestContext testContext) throws Exception {_		Throwable afterTransactionException = null___		List<Method> methods = getAnnotatedMethods(testContext.getTestClass(), AfterTransaction.class)__		for (Method method : methods) {_			try {_				if (logger.isDebugEnabled()) {_					logger.debug("Executing @AfterTransaction method [" + method + "] for test context " + testContext)__				}_				method.invoke(testContext.getTestInstance())__			}_			catch (InvocationTargetException ex) {_				Throwable targetException = ex.getTargetException()__				if (afterTransactionException == null) {_					afterTransactionException = targetException__				}_				logger.error("Exception encountered while executing @AfterTransaction method [" + method_						+ "] for test context " + testContext, targetException)__			}_			catch (Exception ex) {_				if (afterTransactionException == null) {_					afterTransactionException = ex__				}_				logger.error("Exception encountered while executing @AfterTransaction method [" + method_						+ "] for test context " + testContext, ex)__			}_		}__		if (afterTransactionException != null) {_			ReflectionUtils.rethrowException(afterTransactionException)__		}_	};run,all,link,after,transaction,after,transaction,methods,for,the,specified,link,test,context,test,context,if,one,of,the,methods,fails,the,caught,exception,will,be,logged,as,an,error,and,the,remaining,methods,will,be,given,a,chance,to,execute,after,all,methods,have,executed,the,first,caught,exception,if,any,will,be,rethrown,param,test,context,the,current,test,context;protected,void,run,after,transaction,methods,test,context,test,context,throws,exception,throwable,after,transaction,exception,null,list,method,methods,get,annotated,methods,test,context,get,test,class,after,transaction,class,for,method,method,methods,try,if,logger,is,debug,enabled,logger,debug,executing,after,transaction,method,method,for,test,context,test,context,method,invoke,test,context,get,test,instance,catch,invocation,target,exception,ex,throwable,target,exception,ex,get,target,exception,if,after,transaction,exception,null,after,transaction,exception,target,exception,logger,error,exception,encountered,while,executing,after,transaction,method,method,for,test,context,test,context,target,exception,catch,exception,ex,if,after,transaction,exception,null,after,transaction,exception,ex,logger,error,exception,encountered,while,executing,after,transaction,method,method,for,test,context,test,context,ex,if,after,transaction,exception,null,reflection,utils,rethrow,exception,after,transaction,exception
TransactionalTestExecutionListener -> protected void runAfterTransactionMethods(TestContext testContext) throws Exception;1407419079;Run all {@link AfterTransaction @AfterTransaction} methods for the_specified {@link TestContext test context}. If one of the methods fails,_the caught exception will be logged as an error, and the remaining_methods will be given a chance to execute. After all methods have_executed, the first caught exception, if any, will be rethrown._@param testContext the current test context;protected void runAfterTransactionMethods(TestContext testContext) throws Exception {_		Throwable afterTransactionException = null___		List<Method> methods = getAnnotatedMethods(testContext.getTestClass(), AfterTransaction.class)__		for (Method method : methods) {_			try {_				if (logger.isDebugEnabled()) {_					logger.debug("Executing @AfterTransaction method [" + method + "] for test context " + testContext)__				}_				method.invoke(testContext.getTestInstance())__			}_			catch (InvocationTargetException ex) {_				Throwable targetException = ex.getTargetException()__				if (afterTransactionException == null) {_					afterTransactionException = targetException__				}_				logger.error("Exception encountered while executing @AfterTransaction method [" + method_						+ "] for test context " + testContext, targetException)__			}_			catch (Exception ex) {_				if (afterTransactionException == null) {_					afterTransactionException = ex__				}_				logger.error("Exception encountered while executing @AfterTransaction method [" + method_						+ "] for test context " + testContext, ex)__			}_		}__		if (afterTransactionException != null) {_			ReflectionUtils.rethrowException(afterTransactionException)__		}_	};run,all,link,after,transaction,after,transaction,methods,for,the,specified,link,test,context,test,context,if,one,of,the,methods,fails,the,caught,exception,will,be,logged,as,an,error,and,the,remaining,methods,will,be,given,a,chance,to,execute,after,all,methods,have,executed,the,first,caught,exception,if,any,will,be,rethrown,param,test,context,the,current,test,context;protected,void,run,after,transaction,methods,test,context,test,context,throws,exception,throwable,after,transaction,exception,null,list,method,methods,get,annotated,methods,test,context,get,test,class,after,transaction,class,for,method,method,methods,try,if,logger,is,debug,enabled,logger,debug,executing,after,transaction,method,method,for,test,context,test,context,method,invoke,test,context,get,test,instance,catch,invocation,target,exception,ex,throwable,target,exception,ex,get,target,exception,if,after,transaction,exception,null,after,transaction,exception,target,exception,logger,error,exception,encountered,while,executing,after,transaction,method,method,for,test,context,test,context,target,exception,catch,exception,ex,if,after,transaction,exception,null,after,transaction,exception,ex,logger,error,exception,encountered,while,executing,after,transaction,method,method,for,test,context,test,context,ex,if,after,transaction,exception,null,reflection,utils,rethrow,exception,after,transaction,exception
TransactionalTestExecutionListener -> protected void runAfterTransactionMethods(TestContext testContext) throws Exception;1408048216;Run all {@link AfterTransaction @AfterTransaction} methods for the_specified {@link TestContext test context}. If one of the methods fails,_the caught exception will be logged as an error, and the remaining_methods will be given a chance to execute. After all methods have_executed, the first caught exception, if any, will be rethrown._@param testContext the current test context;protected void runAfterTransactionMethods(TestContext testContext) throws Exception {_		Throwable afterTransactionException = null___		List<Method> methods = getAnnotatedMethods(testContext.getTestClass(), AfterTransaction.class)__		for (Method method : methods) {_			try {_				if (logger.isDebugEnabled()) {_					logger.debug("Executing @AfterTransaction method [" + method + "] for test context " + testContext)__				}_				method.invoke(testContext.getTestInstance())__			}_			catch (InvocationTargetException ex) {_				Throwable targetException = ex.getTargetException()__				if (afterTransactionException == null) {_					afterTransactionException = targetException__				}_				logger.error("Exception encountered while executing @AfterTransaction method [" + method_						+ "] for test context " + testContext, targetException)__			}_			catch (Exception ex) {_				if (afterTransactionException == null) {_					afterTransactionException = ex__				}_				logger.error("Exception encountered while executing @AfterTransaction method [" + method_						+ "] for test context " + testContext, ex)__			}_		}__		if (afterTransactionException != null) {_			ReflectionUtils.rethrowException(afterTransactionException)__		}_	};run,all,link,after,transaction,after,transaction,methods,for,the,specified,link,test,context,test,context,if,one,of,the,methods,fails,the,caught,exception,will,be,logged,as,an,error,and,the,remaining,methods,will,be,given,a,chance,to,execute,after,all,methods,have,executed,the,first,caught,exception,if,any,will,be,rethrown,param,test,context,the,current,test,context;protected,void,run,after,transaction,methods,test,context,test,context,throws,exception,throwable,after,transaction,exception,null,list,method,methods,get,annotated,methods,test,context,get,test,class,after,transaction,class,for,method,method,methods,try,if,logger,is,debug,enabled,logger,debug,executing,after,transaction,method,method,for,test,context,test,context,method,invoke,test,context,get,test,instance,catch,invocation,target,exception,ex,throwable,target,exception,ex,get,target,exception,if,after,transaction,exception,null,after,transaction,exception,target,exception,logger,error,exception,encountered,while,executing,after,transaction,method,method,for,test,context,test,context,target,exception,catch,exception,ex,if,after,transaction,exception,null,after,transaction,exception,ex,logger,error,exception,encountered,while,executing,after,transaction,method,method,for,test,context,test,context,ex,if,after,transaction,exception,null,reflection,utils,rethrow,exception,after,transaction,exception
TransactionalTestExecutionListener -> protected void runAfterTransactionMethods(TestContext testContext) throws Exception;1413848647;Run all {@link AfterTransaction @AfterTransaction} methods for the_specified {@link TestContext test context}. If one of the methods fails,_the caught exception will be logged as an error, and the remaining_methods will be given a chance to execute. After all methods have_executed, the first caught exception, if any, will be rethrown._@param testContext the current test context;protected void runAfterTransactionMethods(TestContext testContext) throws Exception {_		Throwable afterTransactionException = null___		List<Method> methods = getAnnotatedMethods(testContext.getTestClass(), AfterTransaction.class)__		for (Method method : methods) {_			try {_				if (logger.isDebugEnabled()) {_					logger.debug("Executing @AfterTransaction method [" + method + "] for test context " + testContext)__				}_				method.invoke(testContext.getTestInstance())__			}_			catch (InvocationTargetException ex) {_				Throwable targetException = ex.getTargetException()__				if (afterTransactionException == null) {_					afterTransactionException = targetException__				}_				logger.error("Exception encountered while executing @AfterTransaction method [" + method_						+ "] for test context " + testContext, targetException)__			}_			catch (Exception ex) {_				if (afterTransactionException == null) {_					afterTransactionException = ex__				}_				logger.error("Exception encountered while executing @AfterTransaction method [" + method_						+ "] for test context " + testContext, ex)__			}_		}__		if (afterTransactionException != null) {_			ReflectionUtils.rethrowException(afterTransactionException)__		}_	};run,all,link,after,transaction,after,transaction,methods,for,the,specified,link,test,context,test,context,if,one,of,the,methods,fails,the,caught,exception,will,be,logged,as,an,error,and,the,remaining,methods,will,be,given,a,chance,to,execute,after,all,methods,have,executed,the,first,caught,exception,if,any,will,be,rethrown,param,test,context,the,current,test,context;protected,void,run,after,transaction,methods,test,context,test,context,throws,exception,throwable,after,transaction,exception,null,list,method,methods,get,annotated,methods,test,context,get,test,class,after,transaction,class,for,method,method,methods,try,if,logger,is,debug,enabled,logger,debug,executing,after,transaction,method,method,for,test,context,test,context,method,invoke,test,context,get,test,instance,catch,invocation,target,exception,ex,throwable,target,exception,ex,get,target,exception,if,after,transaction,exception,null,after,transaction,exception,target,exception,logger,error,exception,encountered,while,executing,after,transaction,method,method,for,test,context,test,context,target,exception,catch,exception,ex,if,after,transaction,exception,null,after,transaction,exception,ex,logger,error,exception,encountered,while,executing,after,transaction,method,method,for,test,context,test,context,ex,if,after,transaction,exception,null,reflection,utils,rethrow,exception,after,transaction,exception
TransactionalTestExecutionListener -> protected void runAfterTransactionMethods(TestContext testContext) throws Exception;1431568199;Run all {@link AfterTransaction @AfterTransaction} methods for the_specified {@link TestContext test context}. If one of the methods fails,_the caught exception will be logged as an error, and the remaining_methods will be given a chance to execute. After all methods have_executed, the first caught exception, if any, will be rethrown._@param testContext the current test context;protected void runAfterTransactionMethods(TestContext testContext) throws Exception {_		Throwable afterTransactionException = null___		List<Method> methods = getAnnotatedMethods(testContext.getTestClass(), AfterTransaction.class)__		for (Method method : methods) {_			try {_				if (logger.isDebugEnabled()) {_					logger.debug("Executing @AfterTransaction method [" + method + "] for test context " + testContext)__				}_				method.invoke(testContext.getTestInstance())__			}_			catch (InvocationTargetException ex) {_				Throwable targetException = ex.getTargetException()__				if (afterTransactionException == null) {_					afterTransactionException = targetException__				}_				logger.error("Exception encountered while executing @AfterTransaction method [" + method_						+ "] for test context " + testContext, targetException)__			}_			catch (Exception ex) {_				if (afterTransactionException == null) {_					afterTransactionException = ex__				}_				logger.error("Exception encountered while executing @AfterTransaction method [" + method_						+ "] for test context " + testContext, ex)__			}_		}__		if (afterTransactionException != null) {_			ReflectionUtils.rethrowException(afterTransactionException)__		}_	};run,all,link,after,transaction,after,transaction,methods,for,the,specified,link,test,context,test,context,if,one,of,the,methods,fails,the,caught,exception,will,be,logged,as,an,error,and,the,remaining,methods,will,be,given,a,chance,to,execute,after,all,methods,have,executed,the,first,caught,exception,if,any,will,be,rethrown,param,test,context,the,current,test,context;protected,void,run,after,transaction,methods,test,context,test,context,throws,exception,throwable,after,transaction,exception,null,list,method,methods,get,annotated,methods,test,context,get,test,class,after,transaction,class,for,method,method,methods,try,if,logger,is,debug,enabled,logger,debug,executing,after,transaction,method,method,for,test,context,test,context,method,invoke,test,context,get,test,instance,catch,invocation,target,exception,ex,throwable,target,exception,ex,get,target,exception,if,after,transaction,exception,null,after,transaction,exception,target,exception,logger,error,exception,encountered,while,executing,after,transaction,method,method,for,test,context,test,context,target,exception,catch,exception,ex,if,after,transaction,exception,null,after,transaction,exception,ex,logger,error,exception,encountered,while,executing,after,transaction,method,method,for,test,context,test,context,ex,if,after,transaction,exception,null,reflection,utils,rethrow,exception,after,transaction,exception
TransactionalTestExecutionListener -> protected void runAfterTransactionMethods(TestContext testContext) throws Exception;1432125256;Run all {@link AfterTransaction @AfterTransaction} methods for the_specified {@link TestContext test context}. If one of the methods fails,_the caught exception will be logged as an error, and the remaining_methods will be given a chance to execute. After all methods have_executed, the first caught exception, if any, will be rethrown._@param testContext the current test context;protected void runAfterTransactionMethods(TestContext testContext) throws Exception {_		Throwable afterTransactionException = null___		List<Method> methods = getAnnotatedMethods(testContext.getTestClass(), AfterTransaction.class)__		for (Method method : methods) {_			try {_				if (logger.isDebugEnabled()) {_					logger.debug("Executing @AfterTransaction method [" + method + "] for test context " + testContext)__				}_				method.invoke(testContext.getTestInstance())__			}_			catch (InvocationTargetException ex) {_				Throwable targetException = ex.getTargetException()__				if (afterTransactionException == null) {_					afterTransactionException = targetException__				}_				logger.error("Exception encountered while executing @AfterTransaction method [" + method_						+ "] for test context " + testContext, targetException)__			}_			catch (Exception ex) {_				if (afterTransactionException == null) {_					afterTransactionException = ex__				}_				logger.error("Exception encountered while executing @AfterTransaction method [" + method_						+ "] for test context " + testContext, ex)__			}_		}__		if (afterTransactionException != null) {_			ReflectionUtils.rethrowException(afterTransactionException)__		}_	};run,all,link,after,transaction,after,transaction,methods,for,the,specified,link,test,context,test,context,if,one,of,the,methods,fails,the,caught,exception,will,be,logged,as,an,error,and,the,remaining,methods,will,be,given,a,chance,to,execute,after,all,methods,have,executed,the,first,caught,exception,if,any,will,be,rethrown,param,test,context,the,current,test,context;protected,void,run,after,transaction,methods,test,context,test,context,throws,exception,throwable,after,transaction,exception,null,list,method,methods,get,annotated,methods,test,context,get,test,class,after,transaction,class,for,method,method,methods,try,if,logger,is,debug,enabled,logger,debug,executing,after,transaction,method,method,for,test,context,test,context,method,invoke,test,context,get,test,instance,catch,invocation,target,exception,ex,throwable,target,exception,ex,get,target,exception,if,after,transaction,exception,null,after,transaction,exception,target,exception,logger,error,exception,encountered,while,executing,after,transaction,method,method,for,test,context,test,context,target,exception,catch,exception,ex,if,after,transaction,exception,null,after,transaction,exception,ex,logger,error,exception,encountered,while,executing,after,transaction,method,method,for,test,context,test,context,ex,if,after,transaction,exception,null,reflection,utils,rethrow,exception,after,transaction,exception
TransactionalTestExecutionListener -> protected void runAfterTransactionMethods(TestContext testContext) throws Exception;1432856630;Run all {@link AfterTransaction @AfterTransaction} methods for the_specified {@link TestContext test context}. If one of the methods fails,_the caught exception will be logged as an error, and the remaining_methods will be given a chance to execute. After all methods have_executed, the first caught exception, if any, will be rethrown._@param testContext the current test context;protected void runAfterTransactionMethods(TestContext testContext) throws Exception {_		Throwable afterTransactionException = null___		List<Method> methods = getAnnotatedMethods(testContext.getTestClass(), AfterTransaction.class)__		for (Method method : methods) {_			try {_				if (logger.isDebugEnabled()) {_					logger.debug("Executing @AfterTransaction method [" + method + "] for test context " + testContext)__				}_				method.invoke(testContext.getTestInstance())__			}_			catch (InvocationTargetException ex) {_				Throwable targetException = ex.getTargetException()__				if (afterTransactionException == null) {_					afterTransactionException = targetException__				}_				logger.error("Exception encountered while executing @AfterTransaction method [" + method_						+ "] for test context " + testContext, targetException)__			}_			catch (Exception ex) {_				if (afterTransactionException == null) {_					afterTransactionException = ex__				}_				logger.error("Exception encountered while executing @AfterTransaction method [" + method_						+ "] for test context " + testContext, ex)__			}_		}__		if (afterTransactionException != null) {_			ReflectionUtils.rethrowException(afterTransactionException)__		}_	};run,all,link,after,transaction,after,transaction,methods,for,the,specified,link,test,context,test,context,if,one,of,the,methods,fails,the,caught,exception,will,be,logged,as,an,error,and,the,remaining,methods,will,be,given,a,chance,to,execute,after,all,methods,have,executed,the,first,caught,exception,if,any,will,be,rethrown,param,test,context,the,current,test,context;protected,void,run,after,transaction,methods,test,context,test,context,throws,exception,throwable,after,transaction,exception,null,list,method,methods,get,annotated,methods,test,context,get,test,class,after,transaction,class,for,method,method,methods,try,if,logger,is,debug,enabled,logger,debug,executing,after,transaction,method,method,for,test,context,test,context,method,invoke,test,context,get,test,instance,catch,invocation,target,exception,ex,throwable,target,exception,ex,get,target,exception,if,after,transaction,exception,null,after,transaction,exception,target,exception,logger,error,exception,encountered,while,executing,after,transaction,method,method,for,test,context,test,context,target,exception,catch,exception,ex,if,after,transaction,exception,null,after,transaction,exception,ex,logger,error,exception,encountered,while,executing,after,transaction,method,method,for,test,context,test,context,ex,if,after,transaction,exception,null,reflection,utils,rethrow,exception,after,transaction,exception
TransactionalTestExecutionListener -> protected void runAfterTransactionMethods(TestContext testContext) throws Exception;1434234880;Run all {@link AfterTransaction @AfterTransaction} methods for the_specified {@link TestContext test context}. If one of the methods fails,_the caught exception will be logged as an error, and the remaining_methods will be given a chance to execute. After all methods have_executed, the first caught exception, if any, will be rethrown._@param testContext the current test context;protected void runAfterTransactionMethods(TestContext testContext) throws Exception {_		Throwable afterTransactionException = null___		List<Method> methods = getAnnotatedMethods(testContext.getTestClass(), AfterTransaction.class)__		for (Method method : methods) {_			try {_				if (logger.isDebugEnabled()) {_					logger.debug("Executing @AfterTransaction method [" + method + "] for test context " + testContext)__				}_				method.invoke(testContext.getTestInstance())__			}_			catch (InvocationTargetException ex) {_				Throwable targetException = ex.getTargetException()__				if (afterTransactionException == null) {_					afterTransactionException = targetException__				}_				logger.error("Exception encountered while executing @AfterTransaction method [" + method_						+ "] for test context " + testContext, targetException)__			}_			catch (Exception ex) {_				if (afterTransactionException == null) {_					afterTransactionException = ex__				}_				logger.error("Exception encountered while executing @AfterTransaction method [" + method_						+ "] for test context " + testContext, ex)__			}_		}__		if (afterTransactionException != null) {_			ReflectionUtils.rethrowException(afterTransactionException)__		}_	};run,all,link,after,transaction,after,transaction,methods,for,the,specified,link,test,context,test,context,if,one,of,the,methods,fails,the,caught,exception,will,be,logged,as,an,error,and,the,remaining,methods,will,be,given,a,chance,to,execute,after,all,methods,have,executed,the,first,caught,exception,if,any,will,be,rethrown,param,test,context,the,current,test,context;protected,void,run,after,transaction,methods,test,context,test,context,throws,exception,throwable,after,transaction,exception,null,list,method,methods,get,annotated,methods,test,context,get,test,class,after,transaction,class,for,method,method,methods,try,if,logger,is,debug,enabled,logger,debug,executing,after,transaction,method,method,for,test,context,test,context,method,invoke,test,context,get,test,instance,catch,invocation,target,exception,ex,throwable,target,exception,ex,get,target,exception,if,after,transaction,exception,null,after,transaction,exception,target,exception,logger,error,exception,encountered,while,executing,after,transaction,method,method,for,test,context,test,context,target,exception,catch,exception,ex,if,after,transaction,exception,null,after,transaction,exception,ex,logger,error,exception,encountered,while,executing,after,transaction,method,method,for,test,context,test,context,ex,if,after,transaction,exception,null,reflection,utils,rethrow,exception,after,transaction,exception
TransactionalTestExecutionListener -> protected void runAfterTransactionMethods(TestContext testContext) throws Exception;1434720443;Run all {@link AfterTransaction @AfterTransaction} methods for the_specified {@link TestContext test context}. If one of the methods fails,_the caught exception will be logged as an error, and the remaining_methods will be given a chance to execute. After all methods have_executed, the first caught exception, if any, will be rethrown._@param testContext the current test context;protected void runAfterTransactionMethods(TestContext testContext) throws Exception {_		Throwable afterTransactionException = null___		List<Method> methods = getAnnotatedMethods(testContext.getTestClass(), AfterTransaction.class)__		for (Method method : methods) {_			try {_				if (logger.isDebugEnabled()) {_					logger.debug("Executing @AfterTransaction method [" + method + "] for test context " + testContext)__				}_				method.invoke(testContext.getTestInstance())__			}_			catch (InvocationTargetException ex) {_				Throwable targetException = ex.getTargetException()__				if (afterTransactionException == null) {_					afterTransactionException = targetException__				}_				logger.error("Exception encountered while executing @AfterTransaction method [" + method_						+ "] for test context " + testContext, targetException)__			}_			catch (Exception ex) {_				if (afterTransactionException == null) {_					afterTransactionException = ex__				}_				logger.error("Exception encountered while executing @AfterTransaction method [" + method_						+ "] for test context " + testContext, ex)__			}_		}__		if (afterTransactionException != null) {_			ReflectionUtils.rethrowException(afterTransactionException)__		}_	};run,all,link,after,transaction,after,transaction,methods,for,the,specified,link,test,context,test,context,if,one,of,the,methods,fails,the,caught,exception,will,be,logged,as,an,error,and,the,remaining,methods,will,be,given,a,chance,to,execute,after,all,methods,have,executed,the,first,caught,exception,if,any,will,be,rethrown,param,test,context,the,current,test,context;protected,void,run,after,transaction,methods,test,context,test,context,throws,exception,throwable,after,transaction,exception,null,list,method,methods,get,annotated,methods,test,context,get,test,class,after,transaction,class,for,method,method,methods,try,if,logger,is,debug,enabled,logger,debug,executing,after,transaction,method,method,for,test,context,test,context,method,invoke,test,context,get,test,instance,catch,invocation,target,exception,ex,throwable,target,exception,ex,get,target,exception,if,after,transaction,exception,null,after,transaction,exception,target,exception,logger,error,exception,encountered,while,executing,after,transaction,method,method,for,test,context,test,context,target,exception,catch,exception,ex,if,after,transaction,exception,null,after,transaction,exception,ex,logger,error,exception,encountered,while,executing,after,transaction,method,method,for,test,context,test,context,ex,if,after,transaction,exception,null,reflection,utils,rethrow,exception,after,transaction,exception
TransactionalTestExecutionListener -> protected void runAfterTransactionMethods(TestContext testContext) throws Exception;1434817656;Run all {@link AfterTransaction @AfterTransaction} methods for the_specified {@link TestContext test context}. If one of the methods fails,_the caught exception will be logged as an error, and the remaining_methods will be given a chance to execute. After all methods have_executed, the first caught exception, if any, will be rethrown._@param testContext the current test context;protected void runAfterTransactionMethods(TestContext testContext) throws Exception {_		Throwable afterTransactionException = null___		List<Method> methods = getAnnotatedMethods(testContext.getTestClass(), AfterTransaction.class)__		for (Method method : methods) {_			try {_				if (logger.isDebugEnabled()) {_					logger.debug("Executing @AfterTransaction method [" + method + "] for test context " + testContext)__				}_				method.invoke(testContext.getTestInstance())__			}_			catch (InvocationTargetException ex) {_				Throwable targetException = ex.getTargetException()__				if (afterTransactionException == null) {_					afterTransactionException = targetException__				}_				logger.error("Exception encountered while executing @AfterTransaction method [" + method_						+ "] for test context " + testContext, targetException)__			}_			catch (Exception ex) {_				if (afterTransactionException == null) {_					afterTransactionException = ex__				}_				logger.error("Exception encountered while executing @AfterTransaction method [" + method_						+ "] for test context " + testContext, ex)__			}_		}__		if (afterTransactionException != null) {_			ReflectionUtils.rethrowException(afterTransactionException)__		}_	};run,all,link,after,transaction,after,transaction,methods,for,the,specified,link,test,context,test,context,if,one,of,the,methods,fails,the,caught,exception,will,be,logged,as,an,error,and,the,remaining,methods,will,be,given,a,chance,to,execute,after,all,methods,have,executed,the,first,caught,exception,if,any,will,be,rethrown,param,test,context,the,current,test,context;protected,void,run,after,transaction,methods,test,context,test,context,throws,exception,throwable,after,transaction,exception,null,list,method,methods,get,annotated,methods,test,context,get,test,class,after,transaction,class,for,method,method,methods,try,if,logger,is,debug,enabled,logger,debug,executing,after,transaction,method,method,for,test,context,test,context,method,invoke,test,context,get,test,instance,catch,invocation,target,exception,ex,throwable,target,exception,ex,get,target,exception,if,after,transaction,exception,null,after,transaction,exception,target,exception,logger,error,exception,encountered,while,executing,after,transaction,method,method,for,test,context,test,context,target,exception,catch,exception,ex,if,after,transaction,exception,null,after,transaction,exception,ex,logger,error,exception,encountered,while,executing,after,transaction,method,method,for,test,context,test,context,ex,if,after,transaction,exception,null,reflection,utils,rethrow,exception,after,transaction,exception
TransactionalTestExecutionListener -> protected void runAfterTransactionMethods(TestContext testContext) throws Exception;1437841346;Run all {@link AfterTransaction @AfterTransaction} methods for the_specified {@linkplain TestContext test context}. If one of the methods_fails, the caught exception will be logged as an error, and the remaining_methods will be given a chance to execute. After all methods have_executed, the first caught exception, if any, will be rethrown._@param testContext the current test context;protected void runAfterTransactionMethods(TestContext testContext) throws Exception {_		Throwable afterTransactionException = null___		List<Method> methods = getAnnotatedMethods(testContext.getTestClass(), AfterTransaction.class)__		for (Method method : methods) {_			try {_				if (logger.isDebugEnabled()) {_					logger.debug("Executing @AfterTransaction method [" + method + "] for test context " + testContext)__				}_				method.invoke(testContext.getTestInstance())__			}_			catch (InvocationTargetException ex) {_				Throwable targetException = ex.getTargetException()__				if (afterTransactionException == null) {_					afterTransactionException = targetException__				}_				logger.error("Exception encountered while executing @AfterTransaction method [" + method_						+ "] for test context " + testContext, targetException)__			}_			catch (Exception ex) {_				if (afterTransactionException == null) {_					afterTransactionException = ex__				}_				logger.error("Exception encountered while executing @AfterTransaction method [" + method_						+ "] for test context " + testContext, ex)__			}_		}__		if (afterTransactionException != null) {_			ReflectionUtils.rethrowException(afterTransactionException)__		}_	};run,all,link,after,transaction,after,transaction,methods,for,the,specified,linkplain,test,context,test,context,if,one,of,the,methods,fails,the,caught,exception,will,be,logged,as,an,error,and,the,remaining,methods,will,be,given,a,chance,to,execute,after,all,methods,have,executed,the,first,caught,exception,if,any,will,be,rethrown,param,test,context,the,current,test,context;protected,void,run,after,transaction,methods,test,context,test,context,throws,exception,throwable,after,transaction,exception,null,list,method,methods,get,annotated,methods,test,context,get,test,class,after,transaction,class,for,method,method,methods,try,if,logger,is,debug,enabled,logger,debug,executing,after,transaction,method,method,for,test,context,test,context,method,invoke,test,context,get,test,instance,catch,invocation,target,exception,ex,throwable,target,exception,ex,get,target,exception,if,after,transaction,exception,null,after,transaction,exception,target,exception,logger,error,exception,encountered,while,executing,after,transaction,method,method,for,test,context,test,context,target,exception,catch,exception,ex,if,after,transaction,exception,null,after,transaction,exception,ex,logger,error,exception,encountered,while,executing,after,transaction,method,method,for,test,context,test,context,ex,if,after,transaction,exception,null,reflection,utils,rethrow,exception,after,transaction,exception
TransactionalTestExecutionListener -> protected void runAfterTransactionMethods(TestContext testContext) throws Exception;1437851372;Run all {@link AfterTransaction @AfterTransaction} methods for the_specified {@linkplain TestContext test context}. If one of the methods_fails, the caught exception will be logged as an error, and the remaining_methods will be given a chance to execute. After all methods have_executed, the first caught exception, if any, will be rethrown._@param testContext the current test context;protected void runAfterTransactionMethods(TestContext testContext) throws Exception {_		Throwable afterTransactionException = null___		List<Method> methods = getAnnotatedMethods(testContext.getTestClass(), AfterTransaction.class)__		for (Method method : methods) {_			try {_				if (logger.isDebugEnabled()) {_					logger.debug("Executing @AfterTransaction method [" + method + "] for test context " + testContext)__				}_				method.invoke(testContext.getTestInstance())__			}_			catch (InvocationTargetException ex) {_				Throwable targetException = ex.getTargetException()__				if (afterTransactionException == null) {_					afterTransactionException = targetException__				}_				logger.error("Exception encountered while executing @AfterTransaction method [" + method_						+ "] for test context " + testContext, targetException)__			}_			catch (Exception ex) {_				if (afterTransactionException == null) {_					afterTransactionException = ex__				}_				logger.error("Exception encountered while executing @AfterTransaction method [" + method_						+ "] for test context " + testContext, ex)__			}_		}__		if (afterTransactionException != null) {_			ReflectionUtils.rethrowException(afterTransactionException)__		}_	};run,all,link,after,transaction,after,transaction,methods,for,the,specified,linkplain,test,context,test,context,if,one,of,the,methods,fails,the,caught,exception,will,be,logged,as,an,error,and,the,remaining,methods,will,be,given,a,chance,to,execute,after,all,methods,have,executed,the,first,caught,exception,if,any,will,be,rethrown,param,test,context,the,current,test,context;protected,void,run,after,transaction,methods,test,context,test,context,throws,exception,throwable,after,transaction,exception,null,list,method,methods,get,annotated,methods,test,context,get,test,class,after,transaction,class,for,method,method,methods,try,if,logger,is,debug,enabled,logger,debug,executing,after,transaction,method,method,for,test,context,test,context,method,invoke,test,context,get,test,instance,catch,invocation,target,exception,ex,throwable,target,exception,ex,get,target,exception,if,after,transaction,exception,null,after,transaction,exception,target,exception,logger,error,exception,encountered,while,executing,after,transaction,method,method,for,test,context,test,context,target,exception,catch,exception,ex,if,after,transaction,exception,null,after,transaction,exception,ex,logger,error,exception,encountered,while,executing,after,transaction,method,method,for,test,context,test,context,ex,if,after,transaction,exception,null,reflection,utils,rethrow,exception,after,transaction,exception
TransactionalTestExecutionListener -> protected void runAfterTransactionMethods(TestContext testContext) throws Exception;1437852597;Run all {@link AfterTransaction @AfterTransaction} methods for the_specified {@linkplain TestContext test context}. If one of the methods_fails, the caught exception will be logged as an error, and the remaining_methods will be given a chance to execute. After all methods have_executed, the first caught exception, if any, will be rethrown._@param testContext the current test context;protected void runAfterTransactionMethods(TestContext testContext) throws Exception {_		Throwable afterTransactionException = null___		List<Method> methods = getAnnotatedMethods(testContext.getTestClass(), AfterTransaction.class)__		for (Method method : methods) {_			try {_				if (logger.isDebugEnabled()) {_					logger.debug("Executing @AfterTransaction method [" + method + "] for test context " + testContext)__				}_				method.invoke(testContext.getTestInstance())__			}_			catch (InvocationTargetException ex) {_				Throwable targetException = ex.getTargetException()__				if (afterTransactionException == null) {_					afterTransactionException = targetException__				}_				logger.error("Exception encountered while executing @AfterTransaction method [" + method_						+ "] for test context " + testContext, targetException)__			}_			catch (Exception ex) {_				if (afterTransactionException == null) {_					afterTransactionException = ex__				}_				logger.error("Exception encountered while executing @AfterTransaction method [" + method_						+ "] for test context " + testContext, ex)__			}_		}__		if (afterTransactionException != null) {_			ReflectionUtils.rethrowException(afterTransactionException)__		}_	};run,all,link,after,transaction,after,transaction,methods,for,the,specified,linkplain,test,context,test,context,if,one,of,the,methods,fails,the,caught,exception,will,be,logged,as,an,error,and,the,remaining,methods,will,be,given,a,chance,to,execute,after,all,methods,have,executed,the,first,caught,exception,if,any,will,be,rethrown,param,test,context,the,current,test,context;protected,void,run,after,transaction,methods,test,context,test,context,throws,exception,throwable,after,transaction,exception,null,list,method,methods,get,annotated,methods,test,context,get,test,class,after,transaction,class,for,method,method,methods,try,if,logger,is,debug,enabled,logger,debug,executing,after,transaction,method,method,for,test,context,test,context,method,invoke,test,context,get,test,instance,catch,invocation,target,exception,ex,throwable,target,exception,ex,get,target,exception,if,after,transaction,exception,null,after,transaction,exception,target,exception,logger,error,exception,encountered,while,executing,after,transaction,method,method,for,test,context,test,context,target,exception,catch,exception,ex,if,after,transaction,exception,null,after,transaction,exception,ex,logger,error,exception,encountered,while,executing,after,transaction,method,method,for,test,context,test,context,ex,if,after,transaction,exception,null,reflection,utils,rethrow,exception,after,transaction,exception
TransactionalTestExecutionListener -> protected void runAfterTransactionMethods(TestContext testContext) throws Exception;1454507787;Run all {@link AfterTransaction @AfterTransaction} methods for the_specified {@linkplain TestContext test context}. If one of the methods_fails, the caught exception will be logged as an error, and the remaining_methods will be given a chance to execute. After all methods have_executed, the first caught exception, if any, will be rethrown._@param testContext the current test context;protected void runAfterTransactionMethods(TestContext testContext) throws Exception {_		Throwable afterTransactionException = null___		List<Method> methods = getAnnotatedMethods(testContext.getTestClass(), AfterTransaction.class)__		for (Method method : methods) {_			try {_				if (logger.isDebugEnabled()) {_					logger.debug("Executing @AfterTransaction method [" + method + "] for test context " + testContext)__				}_				method.invoke(testContext.getTestInstance())__			}_			catch (InvocationTargetException ex) {_				Throwable targetException = ex.getTargetException()__				if (afterTransactionException == null) {_					afterTransactionException = targetException__				}_				logger.error("Exception encountered while executing @AfterTransaction method [" + method_						+ "] for test context " + testContext, targetException)__			}_			catch (Exception ex) {_				if (afterTransactionException == null) {_					afterTransactionException = ex__				}_				logger.error("Exception encountered while executing @AfterTransaction method [" + method_						+ "] for test context " + testContext, ex)__			}_		}__		if (afterTransactionException != null) {_			ReflectionUtils.rethrowException(afterTransactionException)__		}_	};run,all,link,after,transaction,after,transaction,methods,for,the,specified,linkplain,test,context,test,context,if,one,of,the,methods,fails,the,caught,exception,will,be,logged,as,an,error,and,the,remaining,methods,will,be,given,a,chance,to,execute,after,all,methods,have,executed,the,first,caught,exception,if,any,will,be,rethrown,param,test,context,the,current,test,context;protected,void,run,after,transaction,methods,test,context,test,context,throws,exception,throwable,after,transaction,exception,null,list,method,methods,get,annotated,methods,test,context,get,test,class,after,transaction,class,for,method,method,methods,try,if,logger,is,debug,enabled,logger,debug,executing,after,transaction,method,method,for,test,context,test,context,method,invoke,test,context,get,test,instance,catch,invocation,target,exception,ex,throwable,target,exception,ex,get,target,exception,if,after,transaction,exception,null,after,transaction,exception,target,exception,logger,error,exception,encountered,while,executing,after,transaction,method,method,for,test,context,test,context,target,exception,catch,exception,ex,if,after,transaction,exception,null,after,transaction,exception,ex,logger,error,exception,encountered,while,executing,after,transaction,method,method,for,test,context,test,context,ex,if,after,transaction,exception,null,reflection,utils,rethrow,exception,after,transaction,exception
TransactionalTestExecutionListener -> protected void runAfterTransactionMethods(TestContext testContext) throws Exception;1456702967;Run all {@link AfterTransaction @AfterTransaction} methods for the_specified {@linkplain TestContext test context}. If one of the methods_fails, the caught exception will be logged as an error, and the remaining_methods will be given a chance to execute. After all methods have_executed, the first caught exception, if any, will be rethrown._@param testContext the current test context;protected void runAfterTransactionMethods(TestContext testContext) throws Exception {_		Throwable afterTransactionException = null___		List<Method> methods = getAnnotatedMethods(testContext.getTestClass(), AfterTransaction.class)__		for (Method method : methods) {_			try {_				if (logger.isDebugEnabled()) {_					logger.debug("Executing @AfterTransaction method [" + method + "] for test context " + testContext)__				}_				ReflectionUtils.makeAccessible(method)__				method.invoke(testContext.getTestInstance())__			}_			catch (InvocationTargetException ex) {_				Throwable targetException = ex.getTargetException()__				if (afterTransactionException == null) {_					afterTransactionException = targetException__				}_				logger.error("Exception encountered while executing @AfterTransaction method [" + method_						+ "] for test context " + testContext, targetException)__			}_			catch (Exception ex) {_				if (afterTransactionException == null) {_					afterTransactionException = ex__				}_				logger.error("Exception encountered while executing @AfterTransaction method [" + method_						+ "] for test context " + testContext, ex)__			}_		}__		if (afterTransactionException != null) {_			ReflectionUtils.rethrowException(afterTransactionException)__		}_	};run,all,link,after,transaction,after,transaction,methods,for,the,specified,linkplain,test,context,test,context,if,one,of,the,methods,fails,the,caught,exception,will,be,logged,as,an,error,and,the,remaining,methods,will,be,given,a,chance,to,execute,after,all,methods,have,executed,the,first,caught,exception,if,any,will,be,rethrown,param,test,context,the,current,test,context;protected,void,run,after,transaction,methods,test,context,test,context,throws,exception,throwable,after,transaction,exception,null,list,method,methods,get,annotated,methods,test,context,get,test,class,after,transaction,class,for,method,method,methods,try,if,logger,is,debug,enabled,logger,debug,executing,after,transaction,method,method,for,test,context,test,context,reflection,utils,make,accessible,method,method,invoke,test,context,get,test,instance,catch,invocation,target,exception,ex,throwable,target,exception,ex,get,target,exception,if,after,transaction,exception,null,after,transaction,exception,target,exception,logger,error,exception,encountered,while,executing,after,transaction,method,method,for,test,context,test,context,target,exception,catch,exception,ex,if,after,transaction,exception,null,after,transaction,exception,ex,logger,error,exception,encountered,while,executing,after,transaction,method,method,for,test,context,test,context,ex,if,after,transaction,exception,null,reflection,utils,rethrow,exception,after,transaction,exception
TransactionalTestExecutionListener -> protected void runAfterTransactionMethods(TestContext testContext) throws Exception;1456756222;Run all {@link AfterTransaction @AfterTransaction} methods for the_specified {@linkplain TestContext test context}. If one of the methods_fails, the caught exception will be logged as an error, and the remaining_methods will be given a chance to execute. After all methods have_executed, the first caught exception, if any, will be rethrown._@param testContext the current test context;protected void runAfterTransactionMethods(TestContext testContext) throws Exception {_		Throwable afterTransactionException = null___		List<Method> methods = getAnnotatedMethods(testContext.getTestClass(), AfterTransaction.class)__		for (Method method : methods) {_			try {_				if (logger.isDebugEnabled()) {_					logger.debug("Executing @AfterTransaction method [" + method + "] for test context " + testContext)__				}_				ReflectionUtils.makeAccessible(method)__				method.invoke(testContext.getTestInstance())__			}_			catch (InvocationTargetException ex) {_				Throwable targetException = ex.getTargetException()__				if (afterTransactionException == null) {_					afterTransactionException = targetException__				}_				logger.error("Exception encountered while executing @AfterTransaction method [" + method_						+ "] for test context " + testContext, targetException)__			}_			catch (Exception ex) {_				if (afterTransactionException == null) {_					afterTransactionException = ex__				}_				logger.error("Exception encountered while executing @AfterTransaction method [" + method_						+ "] for test context " + testContext, ex)__			}_		}__		if (afterTransactionException != null) {_			ReflectionUtils.rethrowException(afterTransactionException)__		}_	};run,all,link,after,transaction,after,transaction,methods,for,the,specified,linkplain,test,context,test,context,if,one,of,the,methods,fails,the,caught,exception,will,be,logged,as,an,error,and,the,remaining,methods,will,be,given,a,chance,to,execute,after,all,methods,have,executed,the,first,caught,exception,if,any,will,be,rethrown,param,test,context,the,current,test,context;protected,void,run,after,transaction,methods,test,context,test,context,throws,exception,throwable,after,transaction,exception,null,list,method,methods,get,annotated,methods,test,context,get,test,class,after,transaction,class,for,method,method,methods,try,if,logger,is,debug,enabled,logger,debug,executing,after,transaction,method,method,for,test,context,test,context,reflection,utils,make,accessible,method,method,invoke,test,context,get,test,instance,catch,invocation,target,exception,ex,throwable,target,exception,ex,get,target,exception,if,after,transaction,exception,null,after,transaction,exception,target,exception,logger,error,exception,encountered,while,executing,after,transaction,method,method,for,test,context,test,context,target,exception,catch,exception,ex,if,after,transaction,exception,null,after,transaction,exception,ex,logger,error,exception,encountered,while,executing,after,transaction,method,method,for,test,context,test,context,ex,if,after,transaction,exception,null,reflection,utils,rethrow,exception,after,transaction,exception
TransactionalTestExecutionListener -> protected void runAfterTransactionMethods(TestContext testContext) throws Exception;1456756222;Run all {@link AfterTransaction @AfterTransaction} methods for the_specified {@linkplain TestContext test context}. If one of the methods_fails, the caught exception will be logged as an error, and the remaining_methods will be given a chance to execute. After all methods have_executed, the first caught exception, if any, will be rethrown._@param testContext the current test context;protected void runAfterTransactionMethods(TestContext testContext) throws Exception {_		Throwable afterTransactionException = null___		List<Method> methods = getAnnotatedMethods(testContext.getTestClass(), AfterTransaction.class)__		for (Method method : methods) {_			try {_				if (logger.isDebugEnabled()) {_					logger.debug("Executing @AfterTransaction method [" + method + "] for test context " + testContext)__				}_				ReflectionUtils.makeAccessible(method)__				method.invoke(testContext.getTestInstance())__			}_			catch (InvocationTargetException ex) {_				Throwable targetException = ex.getTargetException()__				if (afterTransactionException == null) {_					afterTransactionException = targetException__				}_				logger.error("Exception encountered while executing @AfterTransaction method [" + method_						+ "] for test context " + testContext, targetException)__			}_			catch (Exception ex) {_				if (afterTransactionException == null) {_					afterTransactionException = ex__				}_				logger.error("Exception encountered while executing @AfterTransaction method [" + method_						+ "] for test context " + testContext, ex)__			}_		}__		if (afterTransactionException != null) {_			ReflectionUtils.rethrowException(afterTransactionException)__		}_	};run,all,link,after,transaction,after,transaction,methods,for,the,specified,linkplain,test,context,test,context,if,one,of,the,methods,fails,the,caught,exception,will,be,logged,as,an,error,and,the,remaining,methods,will,be,given,a,chance,to,execute,after,all,methods,have,executed,the,first,caught,exception,if,any,will,be,rethrown,param,test,context,the,current,test,context;protected,void,run,after,transaction,methods,test,context,test,context,throws,exception,throwable,after,transaction,exception,null,list,method,methods,get,annotated,methods,test,context,get,test,class,after,transaction,class,for,method,method,methods,try,if,logger,is,debug,enabled,logger,debug,executing,after,transaction,method,method,for,test,context,test,context,reflection,utils,make,accessible,method,method,invoke,test,context,get,test,instance,catch,invocation,target,exception,ex,throwable,target,exception,ex,get,target,exception,if,after,transaction,exception,null,after,transaction,exception,target,exception,logger,error,exception,encountered,while,executing,after,transaction,method,method,for,test,context,test,context,target,exception,catch,exception,ex,if,after,transaction,exception,null,after,transaction,exception,ex,logger,error,exception,encountered,while,executing,after,transaction,method,method,for,test,context,test,context,ex,if,after,transaction,exception,null,reflection,utils,rethrow,exception,after,transaction,exception
TransactionalTestExecutionListener -> protected void runAfterTransactionMethods(TestContext testContext) throws Exception;1458754760;Run all {@link AfterTransaction @AfterTransaction} methods for the_specified {@linkplain TestContext test context}. If one of the methods_fails, the caught exception will be logged as an error, and the remaining_methods will be given a chance to execute. After all methods have_executed, the first caught exception, if any, will be rethrown._@param testContext the current test context;protected void runAfterTransactionMethods(TestContext testContext) throws Exception {_		Throwable afterTransactionException = null___		List<Method> methods = getAnnotatedMethods(testContext.getTestClass(), AfterTransaction.class)__		for (Method method : methods) {_			try {_				if (logger.isDebugEnabled()) {_					logger.debug("Executing @AfterTransaction method [" + method + "] for test context " + testContext)__				}_				ReflectionUtils.makeAccessible(method)__				method.invoke(testContext.getTestInstance())__			}_			catch (InvocationTargetException ex) {_				Throwable targetException = ex.getTargetException()__				if (afterTransactionException == null) {_					afterTransactionException = targetException__				}_				logger.error("Exception encountered while executing @AfterTransaction method [" + method +_						"] for test context " + testContext, targetException)__			}_			catch (Exception ex) {_				if (afterTransactionException == null) {_					afterTransactionException = ex__				}_				logger.error("Exception encountered while executing @AfterTransaction method [" + method +_						"] for test context " + testContext, ex)__			}_		}__		if (afterTransactionException != null) {_			ReflectionUtils.rethrowException(afterTransactionException)__		}_	};run,all,link,after,transaction,after,transaction,methods,for,the,specified,linkplain,test,context,test,context,if,one,of,the,methods,fails,the,caught,exception,will,be,logged,as,an,error,and,the,remaining,methods,will,be,given,a,chance,to,execute,after,all,methods,have,executed,the,first,caught,exception,if,any,will,be,rethrown,param,test,context,the,current,test,context;protected,void,run,after,transaction,methods,test,context,test,context,throws,exception,throwable,after,transaction,exception,null,list,method,methods,get,annotated,methods,test,context,get,test,class,after,transaction,class,for,method,method,methods,try,if,logger,is,debug,enabled,logger,debug,executing,after,transaction,method,method,for,test,context,test,context,reflection,utils,make,accessible,method,method,invoke,test,context,get,test,instance,catch,invocation,target,exception,ex,throwable,target,exception,ex,get,target,exception,if,after,transaction,exception,null,after,transaction,exception,target,exception,logger,error,exception,encountered,while,executing,after,transaction,method,method,for,test,context,test,context,target,exception,catch,exception,ex,if,after,transaction,exception,null,after,transaction,exception,ex,logger,error,exception,encountered,while,executing,after,transaction,method,method,for,test,context,test,context,ex,if,after,transaction,exception,null,reflection,utils,rethrow,exception,after,transaction,exception
TransactionalTestExecutionListener -> protected void runAfterTransactionMethods(TestContext testContext) throws Exception;1462294651;Run all {@link AfterTransaction @AfterTransaction} methods for the_specified {@linkplain TestContext test context}. If one of the methods_fails, the caught exception will be logged as an error, and the remaining_methods will be given a chance to execute. After all methods have_executed, the first caught exception, if any, will be rethrown._@param testContext the current test context;protected void runAfterTransactionMethods(TestContext testContext) throws Exception {_		Throwable afterTransactionException = null___		List<Method> methods = getAnnotatedMethods(testContext.getTestClass(), AfterTransaction.class)__		for (Method method : methods) {_			try {_				if (logger.isDebugEnabled()) {_					logger.debug("Executing @AfterTransaction method [" + method + "] for test context " + testContext)__				}_				ReflectionUtils.makeAccessible(method)__				method.invoke(testContext.getTestInstance())__			}_			catch (InvocationTargetException ex) {_				Throwable targetException = ex.getTargetException()__				if (afterTransactionException == null) {_					afterTransactionException = targetException__				}_				logger.error("Exception encountered while executing @AfterTransaction method [" + method +_						"] for test context " + testContext, targetException)__			}_			catch (Exception ex) {_				if (afterTransactionException == null) {_					afterTransactionException = ex__				}_				logger.error("Exception encountered while executing @AfterTransaction method [" + method +_						"] for test context " + testContext, ex)__			}_		}__		if (afterTransactionException != null) {_			ReflectionUtils.rethrowException(afterTransactionException)__		}_	};run,all,link,after,transaction,after,transaction,methods,for,the,specified,linkplain,test,context,test,context,if,one,of,the,methods,fails,the,caught,exception,will,be,logged,as,an,error,and,the,remaining,methods,will,be,given,a,chance,to,execute,after,all,methods,have,executed,the,first,caught,exception,if,any,will,be,rethrown,param,test,context,the,current,test,context;protected,void,run,after,transaction,methods,test,context,test,context,throws,exception,throwable,after,transaction,exception,null,list,method,methods,get,annotated,methods,test,context,get,test,class,after,transaction,class,for,method,method,methods,try,if,logger,is,debug,enabled,logger,debug,executing,after,transaction,method,method,for,test,context,test,context,reflection,utils,make,accessible,method,method,invoke,test,context,get,test,instance,catch,invocation,target,exception,ex,throwable,target,exception,ex,get,target,exception,if,after,transaction,exception,null,after,transaction,exception,target,exception,logger,error,exception,encountered,while,executing,after,transaction,method,method,for,test,context,test,context,target,exception,catch,exception,ex,if,after,transaction,exception,null,after,transaction,exception,ex,logger,error,exception,encountered,while,executing,after,transaction,method,method,for,test,context,test,context,ex,if,after,transaction,exception,null,reflection,utils,rethrow,exception,after,transaction,exception
TransactionalTestExecutionListener -> protected void runAfterTransactionMethods(TestContext testContext) throws Exception;1462299971;Run all {@link AfterTransaction @AfterTransaction} methods for the_specified {@linkplain TestContext test context}. If one of the methods_fails, the caught exception will be logged as an error, and the remaining_methods will be given a chance to execute. After all methods have_executed, the first caught exception, if any, will be rethrown._@param testContext the current test context;protected void runAfterTransactionMethods(TestContext testContext) throws Exception {_		Throwable afterTransactionException = null___		List<Method> methods = getAnnotatedMethods(testContext.getTestClass(), AfterTransaction.class)__		for (Method method : methods) {_			try {_				if (logger.isDebugEnabled()) {_					logger.debug("Executing @AfterTransaction method [" + method + "] for test context " + testContext)__				}_				ReflectionUtils.makeAccessible(method)__				method.invoke(testContext.getTestInstance())__			}_			catch (InvocationTargetException ex) {_				Throwable targetException = ex.getTargetException()__				if (afterTransactionException == null) {_					afterTransactionException = targetException__				}_				logger.error("Exception encountered while executing @AfterTransaction method [" + method +_						"] for test context " + testContext, targetException)__			}_			catch (Exception ex) {_				if (afterTransactionException == null) {_					afterTransactionException = ex__				}_				logger.error("Exception encountered while executing @AfterTransaction method [" + method +_						"] for test context " + testContext, ex)__			}_		}__		if (afterTransactionException != null) {_			ReflectionUtils.rethrowException(afterTransactionException)__		}_	};run,all,link,after,transaction,after,transaction,methods,for,the,specified,linkplain,test,context,test,context,if,one,of,the,methods,fails,the,caught,exception,will,be,logged,as,an,error,and,the,remaining,methods,will,be,given,a,chance,to,execute,after,all,methods,have,executed,the,first,caught,exception,if,any,will,be,rethrown,param,test,context,the,current,test,context;protected,void,run,after,transaction,methods,test,context,test,context,throws,exception,throwable,after,transaction,exception,null,list,method,methods,get,annotated,methods,test,context,get,test,class,after,transaction,class,for,method,method,methods,try,if,logger,is,debug,enabled,logger,debug,executing,after,transaction,method,method,for,test,context,test,context,reflection,utils,make,accessible,method,method,invoke,test,context,get,test,instance,catch,invocation,target,exception,ex,throwable,target,exception,ex,get,target,exception,if,after,transaction,exception,null,after,transaction,exception,target,exception,logger,error,exception,encountered,while,executing,after,transaction,method,method,for,test,context,test,context,target,exception,catch,exception,ex,if,after,transaction,exception,null,after,transaction,exception,ex,logger,error,exception,encountered,while,executing,after,transaction,method,method,for,test,context,test,context,ex,if,after,transaction,exception,null,reflection,utils,rethrow,exception,after,transaction,exception
TransactionalTestExecutionListener -> protected void runAfterTransactionMethods(TestContext testContext) throws Exception;1467730834;Run all {@link AfterTransaction @AfterTransaction} methods for the_specified {@linkplain TestContext test context}. If one of the methods_fails, the caught exception will be logged as an error, and the remaining_methods will be given a chance to execute. After all methods have_executed, the first caught exception, if any, will be rethrown._@param testContext the current test context;protected void runAfterTransactionMethods(TestContext testContext) throws Exception {_		Throwable afterTransactionException = null___		List<Method> methods = getAnnotatedMethods(testContext.getTestClass(), AfterTransaction.class)__		for (Method method : methods) {_			try {_				if (logger.isDebugEnabled()) {_					logger.debug("Executing @AfterTransaction method [" + method + "] for test context " + testContext)__				}_				ReflectionUtils.makeAccessible(method)__				method.invoke(testContext.getTestInstance())__			}_			catch (InvocationTargetException ex) {_				Throwable targetException = ex.getTargetException()__				if (afterTransactionException == null) {_					afterTransactionException = targetException__				}_				logger.error("Exception encountered while executing @AfterTransaction method [" + method +_						"] for test context " + testContext, targetException)__			}_			catch (Exception ex) {_				if (afterTransactionException == null) {_					afterTransactionException = ex__				}_				logger.error("Exception encountered while executing @AfterTransaction method [" + method +_						"] for test context " + testContext, ex)__			}_		}__		if (afterTransactionException != null) {_			ReflectionUtils.rethrowException(afterTransactionException)__		}_	};run,all,link,after,transaction,after,transaction,methods,for,the,specified,linkplain,test,context,test,context,if,one,of,the,methods,fails,the,caught,exception,will,be,logged,as,an,error,and,the,remaining,methods,will,be,given,a,chance,to,execute,after,all,methods,have,executed,the,first,caught,exception,if,any,will,be,rethrown,param,test,context,the,current,test,context;protected,void,run,after,transaction,methods,test,context,test,context,throws,exception,throwable,after,transaction,exception,null,list,method,methods,get,annotated,methods,test,context,get,test,class,after,transaction,class,for,method,method,methods,try,if,logger,is,debug,enabled,logger,debug,executing,after,transaction,method,method,for,test,context,test,context,reflection,utils,make,accessible,method,method,invoke,test,context,get,test,instance,catch,invocation,target,exception,ex,throwable,target,exception,ex,get,target,exception,if,after,transaction,exception,null,after,transaction,exception,target,exception,logger,error,exception,encountered,while,executing,after,transaction,method,method,for,test,context,test,context,target,exception,catch,exception,ex,if,after,transaction,exception,null,after,transaction,exception,ex,logger,error,exception,encountered,while,executing,after,transaction,method,method,for,test,context,test,context,ex,if,after,transaction,exception,null,reflection,utils,rethrow,exception,after,transaction,exception
TransactionalTestExecutionListener -> protected void runAfterTransactionMethods(TestContext testContext) throws Exception;1467992320;Run all {@link AfterTransaction @AfterTransaction} methods for the_specified {@linkplain TestContext test context}. If one of the methods_fails, the caught exception will be logged as an error, and the remaining_methods will be given a chance to execute. After all methods have_executed, the first caught exception, if any, will be rethrown._@param testContext the current test context;protected void runAfterTransactionMethods(TestContext testContext) throws Exception {_		Throwable afterTransactionException = null___		List<Method> methods = getAnnotatedMethods(testContext.getTestClass(), AfterTransaction.class)__		for (Method method : methods) {_			try {_				if (logger.isDebugEnabled()) {_					logger.debug("Executing @AfterTransaction method [" + method + "] for test context " + testContext)__				}_				ReflectionUtils.makeAccessible(method)__				method.invoke(testContext.getTestInstance())__			}_			catch (InvocationTargetException ex) {_				Throwable targetException = ex.getTargetException()__				if (afterTransactionException == null) {_					afterTransactionException = targetException__				}_				logger.error("Exception encountered while executing @AfterTransaction method [" + method +_						"] for test context " + testContext, targetException)__			}_			catch (Exception ex) {_				if (afterTransactionException == null) {_					afterTransactionException = ex__				}_				logger.error("Exception encountered while executing @AfterTransaction method [" + method +_						"] for test context " + testContext, ex)__			}_		}__		if (afterTransactionException != null) {_			ReflectionUtils.rethrowException(afterTransactionException)__		}_	};run,all,link,after,transaction,after,transaction,methods,for,the,specified,linkplain,test,context,test,context,if,one,of,the,methods,fails,the,caught,exception,will,be,logged,as,an,error,and,the,remaining,methods,will,be,given,a,chance,to,execute,after,all,methods,have,executed,the,first,caught,exception,if,any,will,be,rethrown,param,test,context,the,current,test,context;protected,void,run,after,transaction,methods,test,context,test,context,throws,exception,throwable,after,transaction,exception,null,list,method,methods,get,annotated,methods,test,context,get,test,class,after,transaction,class,for,method,method,methods,try,if,logger,is,debug,enabled,logger,debug,executing,after,transaction,method,method,for,test,context,test,context,reflection,utils,make,accessible,method,method,invoke,test,context,get,test,instance,catch,invocation,target,exception,ex,throwable,target,exception,ex,get,target,exception,if,after,transaction,exception,null,after,transaction,exception,target,exception,logger,error,exception,encountered,while,executing,after,transaction,method,method,for,test,context,test,context,target,exception,catch,exception,ex,if,after,transaction,exception,null,after,transaction,exception,ex,logger,error,exception,encountered,while,executing,after,transaction,method,method,for,test,context,test,context,ex,if,after,transaction,exception,null,reflection,utils,rethrow,exception,after,transaction,exception
TransactionalTestExecutionListener -> protected void runAfterTransactionMethods(TestContext testContext) throws Exception;1467992442;Run all {@link AfterTransaction @AfterTransaction} methods for the_specified {@linkplain TestContext test context}. If one of the methods_fails, the caught exception will be logged as an error, and the remaining_methods will be given a chance to execute. After all methods have_executed, the first caught exception, if any, will be rethrown._@param testContext the current test context;protected void runAfterTransactionMethods(TestContext testContext) throws Exception {_		Throwable afterTransactionException = null___		List<Method> methods = getAnnotatedMethods(testContext.getTestClass(), AfterTransaction.class)__		for (Method method : methods) {_			try {_				if (logger.isDebugEnabled()) {_					logger.debug("Executing @AfterTransaction method [" + method + "] for test context " + testContext)__				}_				ReflectionUtils.makeAccessible(method)__				method.invoke(testContext.getTestInstance())__			}_			catch (InvocationTargetException ex) {_				Throwable targetException = ex.getTargetException()__				if (afterTransactionException == null) {_					afterTransactionException = targetException__				}_				logger.error("Exception encountered while executing @AfterTransaction method [" + method +_						"] for test context " + testContext, targetException)__			}_			catch (Exception ex) {_				if (afterTransactionException == null) {_					afterTransactionException = ex__				}_				logger.error("Exception encountered while executing @AfterTransaction method [" + method +_						"] for test context " + testContext, ex)__			}_		}__		if (afterTransactionException != null) {_			ReflectionUtils.rethrowException(afterTransactionException)__		}_	};run,all,link,after,transaction,after,transaction,methods,for,the,specified,linkplain,test,context,test,context,if,one,of,the,methods,fails,the,caught,exception,will,be,logged,as,an,error,and,the,remaining,methods,will,be,given,a,chance,to,execute,after,all,methods,have,executed,the,first,caught,exception,if,any,will,be,rethrown,param,test,context,the,current,test,context;protected,void,run,after,transaction,methods,test,context,test,context,throws,exception,throwable,after,transaction,exception,null,list,method,methods,get,annotated,methods,test,context,get,test,class,after,transaction,class,for,method,method,methods,try,if,logger,is,debug,enabled,logger,debug,executing,after,transaction,method,method,for,test,context,test,context,reflection,utils,make,accessible,method,method,invoke,test,context,get,test,instance,catch,invocation,target,exception,ex,throwable,target,exception,ex,get,target,exception,if,after,transaction,exception,null,after,transaction,exception,target,exception,logger,error,exception,encountered,while,executing,after,transaction,method,method,for,test,context,test,context,target,exception,catch,exception,ex,if,after,transaction,exception,null,after,transaction,exception,ex,logger,error,exception,encountered,while,executing,after,transaction,method,method,for,test,context,test,context,ex,if,after,transaction,exception,null,reflection,utils,rethrow,exception,after,transaction,exception
TransactionalTestExecutionListener -> protected void runAfterTransactionMethods(TestContext testContext) throws Exception;1467994604;Run all {@link AfterTransaction @AfterTransaction} methods for the_specified {@linkplain TestContext test context}. If one of the methods_fails, the caught exception will be logged as an error, and the remaining_methods will be given a chance to execute. After all methods have_executed, the first caught exception, if any, will be rethrown._@param testContext the current test context;protected void runAfterTransactionMethods(TestContext testContext) throws Exception {_		Throwable afterTransactionException = null___		List<Method> methods = getAnnotatedMethods(testContext.getTestClass(), AfterTransaction.class)__		for (Method method : methods) {_			try {_				if (logger.isDebugEnabled()) {_					logger.debug("Executing @AfterTransaction method [" + method + "] for test context " + testContext)__				}_				ReflectionUtils.makeAccessible(method)__				method.invoke(testContext.getTestInstance())__			}_			catch (InvocationTargetException ex) {_				Throwable targetException = ex.getTargetException()__				if (afterTransactionException == null) {_					afterTransactionException = targetException__				}_				logger.error("Exception encountered while executing @AfterTransaction method [" + method +_						"] for test context " + testContext, targetException)__			}_			catch (Exception ex) {_				if (afterTransactionException == null) {_					afterTransactionException = ex__				}_				logger.error("Exception encountered while executing @AfterTransaction method [" + method +_						"] for test context " + testContext, ex)__			}_		}__		if (afterTransactionException != null) {_			ReflectionUtils.rethrowException(afterTransactionException)__		}_	};run,all,link,after,transaction,after,transaction,methods,for,the,specified,linkplain,test,context,test,context,if,one,of,the,methods,fails,the,caught,exception,will,be,logged,as,an,error,and,the,remaining,methods,will,be,given,a,chance,to,execute,after,all,methods,have,executed,the,first,caught,exception,if,any,will,be,rethrown,param,test,context,the,current,test,context;protected,void,run,after,transaction,methods,test,context,test,context,throws,exception,throwable,after,transaction,exception,null,list,method,methods,get,annotated,methods,test,context,get,test,class,after,transaction,class,for,method,method,methods,try,if,logger,is,debug,enabled,logger,debug,executing,after,transaction,method,method,for,test,context,test,context,reflection,utils,make,accessible,method,method,invoke,test,context,get,test,instance,catch,invocation,target,exception,ex,throwable,target,exception,ex,get,target,exception,if,after,transaction,exception,null,after,transaction,exception,target,exception,logger,error,exception,encountered,while,executing,after,transaction,method,method,for,test,context,test,context,target,exception,catch,exception,ex,if,after,transaction,exception,null,after,transaction,exception,ex,logger,error,exception,encountered,while,executing,after,transaction,method,method,for,test,context,test,context,ex,if,after,transaction,exception,null,reflection,utils,rethrow,exception,after,transaction,exception
TransactionalTestExecutionListener -> protected void runAfterTransactionMethods(TestContext testContext) throws Exception;1468334463;Run all {@link AfterTransaction @AfterTransaction} methods for the_specified {@linkplain TestContext test context}. If one of the methods_fails, the caught exception will be logged as an error, and the remaining_methods will be given a chance to execute. After all methods have_executed, the first caught exception, if any, will be rethrown._@param testContext the current test context;protected void runAfterTransactionMethods(TestContext testContext) throws Exception {_		Throwable afterTransactionException = null___		List<Method> methods = getAnnotatedMethods(testContext.getTestClass(), AfterTransaction.class)__		for (Method method : methods) {_			try {_				if (logger.isDebugEnabled()) {_					logger.debug("Executing @AfterTransaction method [" + method + "] for test context " + testContext)__				}_				ReflectionUtils.makeAccessible(method)__				method.invoke(testContext.getTestInstance())__			}_			catch (InvocationTargetException ex) {_				Throwable targetException = ex.getTargetException()__				if (afterTransactionException == null) {_					afterTransactionException = targetException__				}_				logger.error("Exception encountered while executing @AfterTransaction method [" + method +_						"] for test context " + testContext, targetException)__			}_			catch (Exception ex) {_				if (afterTransactionException == null) {_					afterTransactionException = ex__				}_				logger.error("Exception encountered while executing @AfterTransaction method [" + method +_						"] for test context " + testContext, ex)__			}_		}__		if (afterTransactionException != null) {_			ReflectionUtils.rethrowException(afterTransactionException)__		}_	};run,all,link,after,transaction,after,transaction,methods,for,the,specified,linkplain,test,context,test,context,if,one,of,the,methods,fails,the,caught,exception,will,be,logged,as,an,error,and,the,remaining,methods,will,be,given,a,chance,to,execute,after,all,methods,have,executed,the,first,caught,exception,if,any,will,be,rethrown,param,test,context,the,current,test,context;protected,void,run,after,transaction,methods,test,context,test,context,throws,exception,throwable,after,transaction,exception,null,list,method,methods,get,annotated,methods,test,context,get,test,class,after,transaction,class,for,method,method,methods,try,if,logger,is,debug,enabled,logger,debug,executing,after,transaction,method,method,for,test,context,test,context,reflection,utils,make,accessible,method,method,invoke,test,context,get,test,instance,catch,invocation,target,exception,ex,throwable,target,exception,ex,get,target,exception,if,after,transaction,exception,null,after,transaction,exception,target,exception,logger,error,exception,encountered,while,executing,after,transaction,method,method,for,test,context,test,context,target,exception,catch,exception,ex,if,after,transaction,exception,null,after,transaction,exception,ex,logger,error,exception,encountered,while,executing,after,transaction,method,method,for,test,context,test,context,ex,if,after,transaction,exception,null,reflection,utils,rethrow,exception,after,transaction,exception
TransactionalTestExecutionListener -> protected void runAfterTransactionMethods(TestContext testContext) throws Exception;1496955179;Run all {@link AfterTransaction @AfterTransaction} methods for the_specified {@linkplain TestContext test context}. If one of the methods_fails, the caught exception will be logged as an error, and the remaining_methods will be given a chance to execute. After all methods have_executed, the first caught exception, if any, will be rethrown._@param testContext the current test context;protected void runAfterTransactionMethods(TestContext testContext) throws Exception {_		Throwable afterTransactionException = null___		List<Method> methods = getAnnotatedMethods(testContext.getTestClass(), AfterTransaction.class)__		for (Method method : methods) {_			try {_				if (logger.isDebugEnabled()) {_					logger.debug("Executing @AfterTransaction method [" + method + "] for test context " + testContext)__				}_				ReflectionUtils.makeAccessible(method)__				method.invoke(testContext.getTestInstance())__			}_			catch (InvocationTargetException ex) {_				Throwable targetException = ex.getTargetException()__				if (afterTransactionException == null) {_					afterTransactionException = targetException__				}_				logger.error("Exception encountered while executing @AfterTransaction method [" + method +_						"] for test context " + testContext, targetException)__			}_			catch (Exception ex) {_				if (afterTransactionException == null) {_					afterTransactionException = ex__				}_				logger.error("Exception encountered while executing @AfterTransaction method [" + method +_						"] for test context " + testContext, ex)__			}_		}__		if (afterTransactionException != null) {_			ReflectionUtils.rethrowException(afterTransactionException)__		}_	};run,all,link,after,transaction,after,transaction,methods,for,the,specified,linkplain,test,context,test,context,if,one,of,the,methods,fails,the,caught,exception,will,be,logged,as,an,error,and,the,remaining,methods,will,be,given,a,chance,to,execute,after,all,methods,have,executed,the,first,caught,exception,if,any,will,be,rethrown,param,test,context,the,current,test,context;protected,void,run,after,transaction,methods,test,context,test,context,throws,exception,throwable,after,transaction,exception,null,list,method,methods,get,annotated,methods,test,context,get,test,class,after,transaction,class,for,method,method,methods,try,if,logger,is,debug,enabled,logger,debug,executing,after,transaction,method,method,for,test,context,test,context,reflection,utils,make,accessible,method,method,invoke,test,context,get,test,instance,catch,invocation,target,exception,ex,throwable,target,exception,ex,get,target,exception,if,after,transaction,exception,null,after,transaction,exception,target,exception,logger,error,exception,encountered,while,executing,after,transaction,method,method,for,test,context,test,context,target,exception,catch,exception,ex,if,after,transaction,exception,null,after,transaction,exception,ex,logger,error,exception,encountered,while,executing,after,transaction,method,method,for,test,context,test,context,ex,if,after,transaction,exception,null,reflection,utils,rethrow,exception,after,transaction,exception
TransactionalTestExecutionListener -> protected void runAfterTransactionMethods(TestContext testContext) throws Exception;1498780456;Run all {@link AfterTransaction @AfterTransaction} methods for the_specified {@linkplain TestContext test context}. If one of the methods_fails, the caught exception will be logged as an error, and the remaining_methods will be given a chance to execute. After all methods have_executed, the first caught exception, if any, will be rethrown._@param testContext the current test context;protected void runAfterTransactionMethods(TestContext testContext) throws Exception {_		Throwable afterTransactionException = null___		List<Method> methods = getAnnotatedMethods(testContext.getTestClass(), AfterTransaction.class)__		for (Method method : methods) {_			try {_				if (logger.isDebugEnabled()) {_					logger.debug("Executing @AfterTransaction method [" + method + "] for test context " + testContext)__				}_				ReflectionUtils.makeAccessible(method)__				method.invoke(testContext.getTestInstance())__			}_			catch (InvocationTargetException ex) {_				Throwable targetException = ex.getTargetException()__				if (afterTransactionException == null) {_					afterTransactionException = targetException__				}_				logger.error("Exception encountered while executing @AfterTransaction method [" + method +_						"] for test context " + testContext, targetException)__			}_			catch (Exception ex) {_				if (afterTransactionException == null) {_					afterTransactionException = ex__				}_				logger.error("Exception encountered while executing @AfterTransaction method [" + method +_						"] for test context " + testContext, ex)__			}_		}__		if (afterTransactionException != null) {_			ReflectionUtils.rethrowException(afterTransactionException)__		}_	};run,all,link,after,transaction,after,transaction,methods,for,the,specified,linkplain,test,context,test,context,if,one,of,the,methods,fails,the,caught,exception,will,be,logged,as,an,error,and,the,remaining,methods,will,be,given,a,chance,to,execute,after,all,methods,have,executed,the,first,caught,exception,if,any,will,be,rethrown,param,test,context,the,current,test,context;protected,void,run,after,transaction,methods,test,context,test,context,throws,exception,throwable,after,transaction,exception,null,list,method,methods,get,annotated,methods,test,context,get,test,class,after,transaction,class,for,method,method,methods,try,if,logger,is,debug,enabled,logger,debug,executing,after,transaction,method,method,for,test,context,test,context,reflection,utils,make,accessible,method,method,invoke,test,context,get,test,instance,catch,invocation,target,exception,ex,throwable,target,exception,ex,get,target,exception,if,after,transaction,exception,null,after,transaction,exception,target,exception,logger,error,exception,encountered,while,executing,after,transaction,method,method,for,test,context,test,context,target,exception,catch,exception,ex,if,after,transaction,exception,null,after,transaction,exception,ex,logger,error,exception,encountered,while,executing,after,transaction,method,method,for,test,context,test,context,ex,if,after,transaction,exception,null,reflection,utils,rethrow,exception,after,transaction,exception
TransactionalTestExecutionListener -> protected void runAfterTransactionMethods(TestContext testContext) throws Exception;1520251235;Run all {@link AfterTransaction @AfterTransaction} methods for the_specified {@linkplain TestContext test context}. If one of the methods_fails, the caught exception will be logged as an error, and the remaining_methods will be given a chance to execute. After all methods have_executed, the first caught exception, if any, will be rethrown._@param testContext the current test context;protected void runAfterTransactionMethods(TestContext testContext) throws Exception {_		Throwable afterTransactionException = null___		List<Method> methods = getAnnotatedMethods(testContext.getTestClass(), AfterTransaction.class)__		for (Method method : methods) {_			try {_				if (logger.isDebugEnabled()) {_					logger.debug("Executing @AfterTransaction method [" + method + "] for test context " + testContext)__				}_				ReflectionUtils.makeAccessible(method)__				method.invoke(testContext.getTestInstance())__			}_			catch (InvocationTargetException ex) {_				Throwable targetException = ex.getTargetException()__				if (afterTransactionException == null) {_					afterTransactionException = targetException__				}_				logger.error("Exception encountered while executing @AfterTransaction method [" + method +_						"] for test context " + testContext, targetException)__			}_			catch (Exception ex) {_				if (afterTransactionException == null) {_					afterTransactionException = ex__				}_				logger.error("Exception encountered while executing @AfterTransaction method [" + method +_						"] for test context " + testContext, ex)__			}_		}__		if (afterTransactionException != null) {_			ReflectionUtils.rethrowException(afterTransactionException)__		}_	};run,all,link,after,transaction,after,transaction,methods,for,the,specified,linkplain,test,context,test,context,if,one,of,the,methods,fails,the,caught,exception,will,be,logged,as,an,error,and,the,remaining,methods,will,be,given,a,chance,to,execute,after,all,methods,have,executed,the,first,caught,exception,if,any,will,be,rethrown,param,test,context,the,current,test,context;protected,void,run,after,transaction,methods,test,context,test,context,throws,exception,throwable,after,transaction,exception,null,list,method,methods,get,annotated,methods,test,context,get,test,class,after,transaction,class,for,method,method,methods,try,if,logger,is,debug,enabled,logger,debug,executing,after,transaction,method,method,for,test,context,test,context,reflection,utils,make,accessible,method,method,invoke,test,context,get,test,instance,catch,invocation,target,exception,ex,throwable,target,exception,ex,get,target,exception,if,after,transaction,exception,null,after,transaction,exception,target,exception,logger,error,exception,encountered,while,executing,after,transaction,method,method,for,test,context,test,context,target,exception,catch,exception,ex,if,after,transaction,exception,null,after,transaction,exception,ex,logger,error,exception,encountered,while,executing,after,transaction,method,method,for,test,context,test,context,ex,if,after,transaction,exception,null,reflection,utils,rethrow,exception,after,transaction,exception
TransactionalTestExecutionListener -> private boolean isShadowed(Method current, Method previous);1328020251;Determines if the supplied {@link Method current method} is_<em>shadowed</em> by a {@link Method previous method}._<p>Note: This code has been borrowed from_{@link org.junit.internal.runners.TestClass#isShadowed(Method,Method)}._@param current the current method_@param previous the previous method_@return <code>true</code> if the previous method shadows the current one;private boolean isShadowed(Method current, Method previous) {_		if (!previous.getName().equals(current.getName())) {_			return false__		}_		if (previous.getParameterTypes().length != current.getParameterTypes().length) {_			return false__		}_		for (int i = 0_ i < previous.getParameterTypes().length_ i++) {_			if (!previous.getParameterTypes()[i].equals(current.getParameterTypes()[i])) {_				return false__			}_		}_		return true__	};determines,if,the,supplied,link,method,current,method,is,em,shadowed,em,by,a,link,method,previous,method,p,note,this,code,has,been,borrowed,from,link,org,junit,internal,runners,test,class,is,shadowed,method,method,param,current,the,current,method,param,previous,the,previous,method,return,code,true,code,if,the,previous,method,shadows,the,current,one;private,boolean,is,shadowed,method,current,method,previous,if,previous,get,name,equals,current,get,name,return,false,if,previous,get,parameter,types,length,current,get,parameter,types,length,return,false,for,int,i,0,i,previous,get,parameter,types,length,i,if,previous,get,parameter,types,i,equals,current,get,parameter,types,i,return,false,return,true
TransactionalTestExecutionListener -> private boolean isShadowed(Method current, Method previous);1337516454;Determines if the supplied {@link Method current method} is_<em>shadowed</em> by a {@link Method previous method}._<p>Note: This code has been borrowed from_{@link org.junit.internal.runners.TestClass#isShadowed(Method,Method)}._@param current the current method_@param previous the previous method_@return <code>true</code> if the previous method shadows the current one;private boolean isShadowed(Method current, Method previous) {_		if (!previous.getName().equals(current.getName())) {_			return false__		}_		if (previous.getParameterTypes().length != current.getParameterTypes().length) {_			return false__		}_		for (int i = 0_ i < previous.getParameterTypes().length_ i++) {_			if (!previous.getParameterTypes()[i].equals(current.getParameterTypes()[i])) {_				return false__			}_		}_		return true__	};determines,if,the,supplied,link,method,current,method,is,em,shadowed,em,by,a,link,method,previous,method,p,note,this,code,has,been,borrowed,from,link,org,junit,internal,runners,test,class,is,shadowed,method,method,param,current,the,current,method,param,previous,the,previous,method,return,code,true,code,if,the,previous,method,shadows,the,current,one;private,boolean,is,shadowed,method,current,method,previous,if,previous,get,name,equals,current,get,name,return,false,if,previous,get,parameter,types,length,current,get,parameter,types,length,return,false,for,int,i,0,i,previous,get,parameter,types,length,i,if,previous,get,parameter,types,i,equals,current,get,parameter,types,i,return,false,return,true
TransactionalTestExecutionListener -> private boolean isShadowed(Method current, Method previous);1338031377;Determines if the supplied {@link Method current method} is_<em>shadowed</em> by a {@link Method previous method}._<p>Note: This code has been borrowed from_{@link org.junit.internal.runners.TestClass#isShadowed(Method,Method)}._@param current the current method_@param previous the previous method_@return <code>true</code> if the previous method shadows the current one;private boolean isShadowed(Method current, Method previous) {_		if (!previous.getName().equals(current.getName())) {_			return false__		}_		if (previous.getParameterTypes().length != current.getParameterTypes().length) {_			return false__		}_		for (int i = 0_ i < previous.getParameterTypes().length_ i++) {_			if (!previous.getParameterTypes()[i].equals(current.getParameterTypes()[i])) {_				return false__			}_		}_		return true__	};determines,if,the,supplied,link,method,current,method,is,em,shadowed,em,by,a,link,method,previous,method,p,note,this,code,has,been,borrowed,from,link,org,junit,internal,runners,test,class,is,shadowed,method,method,param,current,the,current,method,param,previous,the,previous,method,return,code,true,code,if,the,previous,method,shadows,the,current,one;private,boolean,is,shadowed,method,current,method,previous,if,previous,get,name,equals,current,get,name,return,false,if,previous,get,parameter,types,length,current,get,parameter,types,length,return,false,for,int,i,0,i,previous,get,parameter,types,length,i,if,previous,get,parameter,types,i,equals,current,get,parameter,types,i,return,false,return,true
TransactionalTestExecutionListener -> private boolean isShadowed(Method current, Method previous);1343426806;Determines if the supplied {@link Method current method} is_<em>shadowed</em> by a {@link Method previous method}._<p>Note: This code has been borrowed from_{@link org.junit.internal.runners.TestClass#isShadowed(Method,Method)}._@param current the current method_@param previous the previous method_@return <code>true</code> if the previous method shadows the current one;private boolean isShadowed(Method current, Method previous) {_		if (!previous.getName().equals(current.getName())) {_			return false__		}_		if (previous.getParameterTypes().length != current.getParameterTypes().length) {_			return false__		}_		for (int i = 0_ i < previous.getParameterTypes().length_ i++) {_			if (!previous.getParameterTypes()[i].equals(current.getParameterTypes()[i])) {_				return false__			}_		}_		return true__	};determines,if,the,supplied,link,method,current,method,is,em,shadowed,em,by,a,link,method,previous,method,p,note,this,code,has,been,borrowed,from,link,org,junit,internal,runners,test,class,is,shadowed,method,method,param,current,the,current,method,param,previous,the,previous,method,return,code,true,code,if,the,previous,method,shadows,the,current,one;private,boolean,is,shadowed,method,current,method,previous,if,previous,get,name,equals,current,get,name,return,false,if,previous,get,parameter,types,length,current,get,parameter,types,length,return,false,for,int,i,0,i,previous,get,parameter,types,length,i,if,previous,get,parameter,types,i,equals,current,get,parameter,types,i,return,false,return,true
TransactionalTestExecutionListener -> private boolean isShadowed(Method current, Method previous);1343431472;Determines if the supplied {@link Method current method} is_<em>shadowed</em> by a {@link Method previous method}._<p>Note: This code has been borrowed from_{@link org.junit.internal.runners.TestClass#isShadowed(Method,Method)}._@param current the current method_@param previous the previous method_@return <code>true</code> if the previous method shadows the current one;private boolean isShadowed(Method current, Method previous) {_		if (!previous.getName().equals(current.getName())) {_			return false__		}_		if (previous.getParameterTypes().length != current.getParameterTypes().length) {_			return false__		}_		for (int i = 0_ i < previous.getParameterTypes().length_ i++) {_			if (!previous.getParameterTypes()[i].equals(current.getParameterTypes()[i])) {_				return false__			}_		}_		return true__	};determines,if,the,supplied,link,method,current,method,is,em,shadowed,em,by,a,link,method,previous,method,p,note,this,code,has,been,borrowed,from,link,org,junit,internal,runners,test,class,is,shadowed,method,method,param,current,the,current,method,param,previous,the,previous,method,return,code,true,code,if,the,previous,method,shadows,the,current,one;private,boolean,is,shadowed,method,current,method,previous,if,previous,get,name,equals,current,get,name,return,false,if,previous,get,parameter,types,length,current,get,parameter,types,length,return,false,for,int,i,0,i,previous,get,parameter,types,length,i,if,previous,get,parameter,types,i,equals,current,get,parameter,types,i,return,false,return,true
TransactionalTestExecutionListener -> private boolean isShadowed(Method current, Method previous);1354571539;Determines if the supplied {@link Method current method} is_<em>shadowed</em> by a {@link Method previous method}._<p>Note: This code has been borrowed from_{@link org.junit.internal.runners.TestClass#isShadowed(Method,Method)}._@param current the current method_@param previous the previous method_@return <code>true</code> if the previous method shadows the current one;private boolean isShadowed(Method current, Method previous) {_		if (!previous.getName().equals(current.getName())) {_			return false__		}_		if (previous.getParameterTypes().length != current.getParameterTypes().length) {_			return false__		}_		for (int i = 0_ i < previous.getParameterTypes().length_ i++) {_			if (!previous.getParameterTypes()[i].equals(current.getParameterTypes()[i])) {_				return false__			}_		}_		return true__	};determines,if,the,supplied,link,method,current,method,is,em,shadowed,em,by,a,link,method,previous,method,p,note,this,code,has,been,borrowed,from,link,org,junit,internal,runners,test,class,is,shadowed,method,method,param,current,the,current,method,param,previous,the,previous,method,return,code,true,code,if,the,previous,method,shadows,the,current,one;private,boolean,is,shadowed,method,current,method,previous,if,previous,get,name,equals,current,get,name,return,false,if,previous,get,parameter,types,length,current,get,parameter,types,length,return,false,for,int,i,0,i,previous,get,parameter,types,length,i,if,previous,get,parameter,types,i,equals,current,get,parameter,types,i,return,false,return,true
TransactionalTestExecutionListener -> private boolean isShadowed(Method current, Method previous);1355352386;Determines if the supplied {@link Method current method} is_<em>shadowed</em> by a {@link Method previous method}._<p>Note: This code has been borrowed from_{@link org.junit.internal.runners.TestClass#isShadowed(Method,Method)}._@param current the current method_@param previous the previous method_@return <code>true</code> if the previous method shadows the current one;private boolean isShadowed(Method current, Method previous) {_		if (!previous.getName().equals(current.getName())) {_			return false__		}_		if (previous.getParameterTypes().length != current.getParameterTypes().length) {_			return false__		}_		for (int i = 0_ i < previous.getParameterTypes().length_ i++) {_			if (!previous.getParameterTypes()[i].equals(current.getParameterTypes()[i])) {_				return false__			}_		}_		return true__	};determines,if,the,supplied,link,method,current,method,is,em,shadowed,em,by,a,link,method,previous,method,p,note,this,code,has,been,borrowed,from,link,org,junit,internal,runners,test,class,is,shadowed,method,method,param,current,the,current,method,param,previous,the,previous,method,return,code,true,code,if,the,previous,method,shadows,the,current,one;private,boolean,is,shadowed,method,current,method,previous,if,previous,get,name,equals,current,get,name,return,false,if,previous,get,parameter,types,length,current,get,parameter,types,length,return,false,for,int,i,0,i,previous,get,parameter,types,length,i,if,previous,get,parameter,types,i,equals,current,get,parameter,types,i,return,false,return,true
TransactionalTestExecutionListener -> private boolean isShadowed(Method current, Method previous);1356735495;Determines if the supplied {@link Method current method} is_<em>shadowed</em> by a {@link Method previous method}._<p>Note: This code has been borrowed from_{@link org.junit.internal.runners.TestClass#isShadowed(Method, Method)}._@param current the current method_@param previous the previous method_@return {@code true} if the previous method shadows the current one;private boolean isShadowed(Method current, Method previous) {_		if (!previous.getName().equals(current.getName())) {_			return false__		}_		if (previous.getParameterTypes().length != current.getParameterTypes().length) {_			return false__		}_		for (int i = 0_ i < previous.getParameterTypes().length_ i++) {_			if (!previous.getParameterTypes()[i].equals(current.getParameterTypes()[i])) {_				return false__			}_		}_		return true__	};determines,if,the,supplied,link,method,current,method,is,em,shadowed,em,by,a,link,method,previous,method,p,note,this,code,has,been,borrowed,from,link,org,junit,internal,runners,test,class,is,shadowed,method,method,param,current,the,current,method,param,previous,the,previous,method,return,code,true,if,the,previous,method,shadows,the,current,one;private,boolean,is,shadowed,method,current,method,previous,if,previous,get,name,equals,current,get,name,return,false,if,previous,get,parameter,types,length,current,get,parameter,types,length,return,false,for,int,i,0,i,previous,get,parameter,types,length,i,if,previous,get,parameter,types,i,equals,current,get,parameter,types,i,return,false,return,true
TransactionalTestExecutionListener -> private boolean isShadowed(Method current, Method previous);1357119239;Determines if the supplied {@link Method current method} is_<em>shadowed</em> by a {@link Method previous method}._<p>Note: This code has been borrowed from_{@link org.junit.internal.runners.TestClass#isShadowed(Method, Method)}._@param current the current method_@param previous the previous method_@return {@code true} if the previous method shadows the current one;private boolean isShadowed(Method current, Method previous) {_		if (!previous.getName().equals(current.getName())) {_			return false__		}_		if (previous.getParameterTypes().length != current.getParameterTypes().length) {_			return false__		}_		for (int i = 0_ i < previous.getParameterTypes().length_ i++) {_			if (!previous.getParameterTypes()[i].equals(current.getParameterTypes()[i])) {_				return false__			}_		}_		return true__	};determines,if,the,supplied,link,method,current,method,is,em,shadowed,em,by,a,link,method,previous,method,p,note,this,code,has,been,borrowed,from,link,org,junit,internal,runners,test,class,is,shadowed,method,method,param,current,the,current,method,param,previous,the,previous,method,return,code,true,if,the,previous,method,shadows,the,current,one;private,boolean,is,shadowed,method,current,method,previous,if,previous,get,name,equals,current,get,name,return,false,if,previous,get,parameter,types,length,current,get,parameter,types,length,return,false,for,int,i,0,i,previous,get,parameter,types,length,i,if,previous,get,parameter,types,i,equals,current,get,parameter,types,i,return,false,return,true
TransactionalTestExecutionListener -> private boolean isShadowed(Method current, Method previous);1367163114;Determines if the supplied {@link Method current method} is_<em>shadowed</em> by a {@link Method previous method}._<p>Note: This code has been borrowed from_{@link org.junit.internal.runners.TestClass#isShadowed(Method, Method)}._@param current the current method_@param previous the previous method_@return {@code true} if the previous method shadows the current one;private boolean isShadowed(Method current, Method previous) {_		if (!previous.getName().equals(current.getName())) {_			return false__		}_		if (previous.getParameterTypes().length != current.getParameterTypes().length) {_			return false__		}_		for (int i = 0_ i < previous.getParameterTypes().length_ i++) {_			if (!previous.getParameterTypes()[i].equals(current.getParameterTypes()[i])) {_				return false__			}_		}_		return true__	};determines,if,the,supplied,link,method,current,method,is,em,shadowed,em,by,a,link,method,previous,method,p,note,this,code,has,been,borrowed,from,link,org,junit,internal,runners,test,class,is,shadowed,method,method,param,current,the,current,method,param,previous,the,previous,method,return,code,true,if,the,previous,method,shadows,the,current,one;private,boolean,is,shadowed,method,current,method,previous,if,previous,get,name,equals,current,get,name,return,false,if,previous,get,parameter,types,length,current,get,parameter,types,length,return,false,for,int,i,0,i,previous,get,parameter,types,length,i,if,previous,get,parameter,types,i,equals,current,get,parameter,types,i,return,false,return,true
TransactionalTestExecutionListener -> private boolean isShadowed(Method current, Method previous);1367873075;Determines if the supplied {@link Method current method} is_<em>shadowed</em> by a {@link Method previous method}._<p>Note: This code has been borrowed from_{@link org.junit.internal.runners.TestClass#isShadowed(Method, Method)}._@param current the current method_@param previous the previous method_@return {@code true} if the previous method shadows the current one;private boolean isShadowed(Method current, Method previous) {_		if (!previous.getName().equals(current.getName())) {_			return false__		}_		if (previous.getParameterTypes().length != current.getParameterTypes().length) {_			return false__		}_		for (int i = 0_ i < previous.getParameterTypes().length_ i++) {_			if (!previous.getParameterTypes()[i].equals(current.getParameterTypes()[i])) {_				return false__			}_		}_		return true__	};determines,if,the,supplied,link,method,current,method,is,em,shadowed,em,by,a,link,method,previous,method,p,note,this,code,has,been,borrowed,from,link,org,junit,internal,runners,test,class,is,shadowed,method,method,param,current,the,current,method,param,previous,the,previous,method,return,code,true,if,the,previous,method,shadows,the,current,one;private,boolean,is,shadowed,method,current,method,previous,if,previous,get,name,equals,current,get,name,return,false,if,previous,get,parameter,types,length,current,get,parameter,types,length,return,false,for,int,i,0,i,previous,get,parameter,types,length,i,if,previous,get,parameter,types,i,equals,current,get,parameter,types,i,return,false,return,true
TransactionalTestExecutionListener -> private boolean isShadowed(Method current, Method previous);1368482696;Determines if the supplied {@link Method current method} is_<em>shadowed</em> by a {@link Method previous method}._<p>Note: This code has been borrowed from_{@link org.junit.internal.runners.TestClass#isShadowed(Method, Method)}._@param current the current method_@param previous the previous method_@return {@code true} if the previous method shadows the current one;private boolean isShadowed(Method current, Method previous) {_		if (!previous.getName().equals(current.getName())) {_			return false__		}_		if (previous.getParameterTypes().length != current.getParameterTypes().length) {_			return false__		}_		for (int i = 0_ i < previous.getParameterTypes().length_ i++) {_			if (!previous.getParameterTypes()[i].equals(current.getParameterTypes()[i])) {_				return false__			}_		}_		return true__	};determines,if,the,supplied,link,method,current,method,is,em,shadowed,em,by,a,link,method,previous,method,p,note,this,code,has,been,borrowed,from,link,org,junit,internal,runners,test,class,is,shadowed,method,method,param,current,the,current,method,param,previous,the,previous,method,return,code,true,if,the,previous,method,shadows,the,current,one;private,boolean,is,shadowed,method,current,method,previous,if,previous,get,name,equals,current,get,name,return,false,if,previous,get,parameter,types,length,current,get,parameter,types,length,return,false,for,int,i,0,i,previous,get,parameter,types,length,i,if,previous,get,parameter,types,i,equals,current,get,parameter,types,i,return,false,return,true
TransactionalTestExecutionListener -> private boolean isShadowed(Method current, Method previous);1382920864;Determine if the supplied {@link Method current method} is <em>shadowed</em>_by a {@link Method previous method}._<p>Note: This code has been borrowed from_{@link org.junit.internal.runners.TestClass#isShadowed(Method, Method)}._@param current the current method_@param previous the previous method_@return {@code true} if the previous method shadows the current one;private boolean isShadowed(Method current, Method previous) {_		if (!previous.getName().equals(current.getName())) {_			return false__		}_		if (previous.getParameterTypes().length != current.getParameterTypes().length) {_			return false__		}_		for (int i = 0_ i < previous.getParameterTypes().length_ i++) {_			if (!previous.getParameterTypes()[i].equals(current.getParameterTypes()[i])) {_				return false__			}_		}_		return true__	};determine,if,the,supplied,link,method,current,method,is,em,shadowed,em,by,a,link,method,previous,method,p,note,this,code,has,been,borrowed,from,link,org,junit,internal,runners,test,class,is,shadowed,method,method,param,current,the,current,method,param,previous,the,previous,method,return,code,true,if,the,previous,method,shadows,the,current,one;private,boolean,is,shadowed,method,current,method,previous,if,previous,get,name,equals,current,get,name,return,false,if,previous,get,parameter,types,length,current,get,parameter,types,length,return,false,for,int,i,0,i,previous,get,parameter,types,length,i,if,previous,get,parameter,types,i,equals,current,get,parameter,types,i,return,false,return,true
TransactionalTestExecutionListener -> private boolean isShadowed(Method current, Method previous);1385499540;Determine if the supplied {@link Method current method} is <em>shadowed</em>_by a {@link Method previous method}._<p>Note: This code has been borrowed from_{@link org.junit.internal.runners.TestClass#isShadowed(Method, Method)}._@param current the current method_@param previous the previous method_@return {@code true} if the previous method shadows the current one;private boolean isShadowed(Method current, Method previous) {_		if (!previous.getName().equals(current.getName())) {_			return false__		}_		if (previous.getParameterTypes().length != current.getParameterTypes().length) {_			return false__		}_		for (int i = 0_ i < previous.getParameterTypes().length_ i++) {_			if (!previous.getParameterTypes()[i].equals(current.getParameterTypes()[i])) {_				return false__			}_		}_		return true__	};determine,if,the,supplied,link,method,current,method,is,em,shadowed,em,by,a,link,method,previous,method,p,note,this,code,has,been,borrowed,from,link,org,junit,internal,runners,test,class,is,shadowed,method,method,param,current,the,current,method,param,previous,the,previous,method,return,code,true,if,the,previous,method,shadows,the,current,one;private,boolean,is,shadowed,method,current,method,previous,if,previous,get,name,equals,current,get,name,return,false,if,previous,get,parameter,types,length,current,get,parameter,types,length,return,false,for,int,i,0,i,previous,get,parameter,types,length,i,if,previous,get,parameter,types,i,equals,current,get,parameter,types,i,return,false,return,true
TransactionalTestExecutionListener -> private boolean isShadowed(Method current, Method previous);1389966876;Determine if the supplied {@link Method current method} is <em>shadowed</em>_by a {@link Method previous method}._<p>Note: This code has been borrowed from_{@link org.junit.internal.runners.TestClass#isShadowed(Method, Method)}._@param current the current method_@param previous the previous method_@return {@code true} if the previous method shadows the current one;private boolean isShadowed(Method current, Method previous) {_		if (!previous.getName().equals(current.getName())) {_			return false__		}_		if (previous.getParameterTypes().length != current.getParameterTypes().length) {_			return false__		}_		for (int i = 0_ i < previous.getParameterTypes().length_ i++) {_			if (!previous.getParameterTypes()[i].equals(current.getParameterTypes()[i])) {_				return false__			}_		}_		return true__	};determine,if,the,supplied,link,method,current,method,is,em,shadowed,em,by,a,link,method,previous,method,p,note,this,code,has,been,borrowed,from,link,org,junit,internal,runners,test,class,is,shadowed,method,method,param,current,the,current,method,param,previous,the,previous,method,return,code,true,if,the,previous,method,shadows,the,current,one;private,boolean,is,shadowed,method,current,method,previous,if,previous,get,name,equals,current,get,name,return,false,if,previous,get,parameter,types,length,current,get,parameter,types,length,return,false,for,int,i,0,i,previous,get,parameter,types,length,i,if,previous,get,parameter,types,i,equals,current,get,parameter,types,i,return,false,return,true
TransactionalTestExecutionListener -> private boolean isShadowed(Method current, Method previous);1401991965;Determine if the supplied {@link Method current method} is <em>shadowed</em>_by a {@link Method previous method}._<p>Note: This code has been borrowed from_{@link org.junit.internal.runners.TestClass#isShadowed(Method, Method)}._@param current the current method_@param previous the previous method_@return {@code true} if the previous method shadows the current one;private boolean isShadowed(Method current, Method previous) {_		if (!previous.getName().equals(current.getName())) {_			return false__		}_		if (previous.getParameterTypes().length != current.getParameterTypes().length) {_			return false__		}_		for (int i = 0_ i < previous.getParameterTypes().length_ i++) {_			if (!previous.getParameterTypes()[i].equals(current.getParameterTypes()[i])) {_				return false__			}_		}_		return true__	};determine,if,the,supplied,link,method,current,method,is,em,shadowed,em,by,a,link,method,previous,method,p,note,this,code,has,been,borrowed,from,link,org,junit,internal,runners,test,class,is,shadowed,method,method,param,current,the,current,method,param,previous,the,previous,method,return,code,true,if,the,previous,method,shadows,the,current,one;private,boolean,is,shadowed,method,current,method,previous,if,previous,get,name,equals,current,get,name,return,false,if,previous,get,parameter,types,length,current,get,parameter,types,length,return,false,for,int,i,0,i,previous,get,parameter,types,length,i,if,previous,get,parameter,types,i,equals,current,get,parameter,types,i,return,false,return,true
TransactionalTestExecutionListener -> private boolean isShadowed(Method current, Method previous);1404334604;Determine if the supplied {@link Method current method} is <em>shadowed</em>_by a {@link Method previous method}._<p>Note: This code has been borrowed from_{@link org.junit.internal.runners.TestClass#isShadowed(Method, Method)}._@param current the current method_@param previous the previous method_@return {@code true} if the previous method shadows the current one;private boolean isShadowed(Method current, Method previous) {_		if (!previous.getName().equals(current.getName())) {_			return false__		}_		if (previous.getParameterTypes().length != current.getParameterTypes().length) {_			return false__		}_		for (int i = 0_ i < previous.getParameterTypes().length_ i++) {_			if (!previous.getParameterTypes()[i].equals(current.getParameterTypes()[i])) {_				return false__			}_		}_		return true__	};determine,if,the,supplied,link,method,current,method,is,em,shadowed,em,by,a,link,method,previous,method,p,note,this,code,has,been,borrowed,from,link,org,junit,internal,runners,test,class,is,shadowed,method,method,param,current,the,current,method,param,previous,the,previous,method,return,code,true,if,the,previous,method,shadows,the,current,one;private,boolean,is,shadowed,method,current,method,previous,if,previous,get,name,equals,current,get,name,return,false,if,previous,get,parameter,types,length,current,get,parameter,types,length,return,false,for,int,i,0,i,previous,get,parameter,types,length,i,if,previous,get,parameter,types,i,equals,current,get,parameter,types,i,return,false,return,true
TransactionalTestExecutionListener -> private boolean isShadowed(Method current, Method previous);1405645143;Determine if the supplied {@link Method current method} is <em>shadowed</em>_by a {@link Method previous method}._<p>Note: This code has been borrowed from_{@link org.junit.internal.runners.TestClass#isShadowed(Method, Method)}._@param current the current method_@param previous the previous method_@return {@code true} if the previous method shadows the current one;private boolean isShadowed(Method current, Method previous) {_		if (!previous.getName().equals(current.getName())) {_			return false__		}_		if (previous.getParameterTypes().length != current.getParameterTypes().length) {_			return false__		}_		for (int i = 0_ i < previous.getParameterTypes().length_ i++) {_			if (!previous.getParameterTypes()[i].equals(current.getParameterTypes()[i])) {_				return false__			}_		}_		return true__	};determine,if,the,supplied,link,method,current,method,is,em,shadowed,em,by,a,link,method,previous,method,p,note,this,code,has,been,borrowed,from,link,org,junit,internal,runners,test,class,is,shadowed,method,method,param,current,the,current,method,param,previous,the,previous,method,return,code,true,if,the,previous,method,shadows,the,current,one;private,boolean,is,shadowed,method,current,method,previous,if,previous,get,name,equals,current,get,name,return,false,if,previous,get,parameter,types,length,current,get,parameter,types,length,return,false,for,int,i,0,i,previous,get,parameter,types,length,i,if,previous,get,parameter,types,i,equals,current,get,parameter,types,i,return,false,return,true
TransactionalTestExecutionListener -> private boolean isShadowed(Method current, Method previous);1405698612;Determine if the supplied {@link Method current method} is <em>shadowed</em>_by a {@link Method previous method}._<p>Note: This code has been borrowed from_{@link org.junit.internal.runners.TestClass#isShadowed(Method, Method)}._@param current the current method_@param previous the previous method_@return {@code true} if the previous method shadows the current one;private boolean isShadowed(Method current, Method previous) {_		if (!previous.getName().equals(current.getName())) {_			return false__		}_		if (previous.getParameterTypes().length != current.getParameterTypes().length) {_			return false__		}_		for (int i = 0_ i < previous.getParameterTypes().length_ i++) {_			if (!previous.getParameterTypes()[i].equals(current.getParameterTypes()[i])) {_				return false__			}_		}_		return true__	};determine,if,the,supplied,link,method,current,method,is,em,shadowed,em,by,a,link,method,previous,method,p,note,this,code,has,been,borrowed,from,link,org,junit,internal,runners,test,class,is,shadowed,method,method,param,current,the,current,method,param,previous,the,previous,method,return,code,true,if,the,previous,method,shadows,the,current,one;private,boolean,is,shadowed,method,current,method,previous,if,previous,get,name,equals,current,get,name,return,false,if,previous,get,parameter,types,length,current,get,parameter,types,length,return,false,for,int,i,0,i,previous,get,parameter,types,length,i,if,previous,get,parameter,types,i,equals,current,get,parameter,types,i,return,false,return,true
TransactionalTestExecutionListener -> private boolean isShadowed(Method current, Method previous);1405759527;Determine if the supplied {@link Method current method} is <em>shadowed</em>_by a {@link Method previous method}._<p>Note: This code has been borrowed from_{@link org.junit.internal.runners.TestClass#isShadowed(Method, Method)}._@param current the current method_@param previous the previous method_@return {@code true} if the previous method shadows the current one;private boolean isShadowed(Method current, Method previous) {_		if (!previous.getName().equals(current.getName())) {_			return false__		}_		if (previous.getParameterTypes().length != current.getParameterTypes().length) {_			return false__		}_		for (int i = 0_ i < previous.getParameterTypes().length_ i++) {_			if (!previous.getParameterTypes()[i].equals(current.getParameterTypes()[i])) {_				return false__			}_		}_		return true__	};determine,if,the,supplied,link,method,current,method,is,em,shadowed,em,by,a,link,method,previous,method,p,note,this,code,has,been,borrowed,from,link,org,junit,internal,runners,test,class,is,shadowed,method,method,param,current,the,current,method,param,previous,the,previous,method,return,code,true,if,the,previous,method,shadows,the,current,one;private,boolean,is,shadowed,method,current,method,previous,if,previous,get,name,equals,current,get,name,return,false,if,previous,get,parameter,types,length,current,get,parameter,types,length,return,false,for,int,i,0,i,previous,get,parameter,types,length,i,if,previous,get,parameter,types,i,equals,current,get,parameter,types,i,return,false,return,true
TransactionalTestExecutionListener -> private boolean isShadowed(Method current, Method previous);1405759966;Determine if the supplied {@link Method current method} is <em>shadowed</em>_by a {@link Method previous method}._<p>Note: This code has been borrowed from_{@link org.junit.internal.runners.TestClass#isShadowed(Method, Method)}._@param current the current method_@param previous the previous method_@return {@code true} if the previous method shadows the current one;private boolean isShadowed(Method current, Method previous) {_		if (!previous.getName().equals(current.getName())) {_			return false__		}_		if (previous.getParameterTypes().length != current.getParameterTypes().length) {_			return false__		}_		for (int i = 0_ i < previous.getParameterTypes().length_ i++) {_			if (!previous.getParameterTypes()[i].equals(current.getParameterTypes()[i])) {_				return false__			}_		}_		return true__	};determine,if,the,supplied,link,method,current,method,is,em,shadowed,em,by,a,link,method,previous,method,p,note,this,code,has,been,borrowed,from,link,org,junit,internal,runners,test,class,is,shadowed,method,method,param,current,the,current,method,param,previous,the,previous,method,return,code,true,if,the,previous,method,shadows,the,current,one;private,boolean,is,shadowed,method,current,method,previous,if,previous,get,name,equals,current,get,name,return,false,if,previous,get,parameter,types,length,current,get,parameter,types,length,return,false,for,int,i,0,i,previous,get,parameter,types,length,i,if,previous,get,parameter,types,i,equals,current,get,parameter,types,i,return,false,return,true
TransactionalTestExecutionListener -> private boolean isShadowed(Method current, Method previous);1406218418;Determine if the supplied {@link Method current method} is <em>shadowed</em>_by a {@link Method previous method}._<p>Note: This code has been borrowed from_{@link org.junit.internal.runners.TestClass#isShadowed(Method, Method)}._@param current the current method_@param previous the previous method_@return {@code true} if the previous method shadows the current one;private boolean isShadowed(Method current, Method previous) {_		if (!previous.getName().equals(current.getName())) {_			return false__		}_		if (previous.getParameterTypes().length != current.getParameterTypes().length) {_			return false__		}_		for (int i = 0_ i < previous.getParameterTypes().length_ i++) {_			if (!previous.getParameterTypes()[i].equals(current.getParameterTypes()[i])) {_				return false__			}_		}_		return true__	};determine,if,the,supplied,link,method,current,method,is,em,shadowed,em,by,a,link,method,previous,method,p,note,this,code,has,been,borrowed,from,link,org,junit,internal,runners,test,class,is,shadowed,method,method,param,current,the,current,method,param,previous,the,previous,method,return,code,true,if,the,previous,method,shadows,the,current,one;private,boolean,is,shadowed,method,current,method,previous,if,previous,get,name,equals,current,get,name,return,false,if,previous,get,parameter,types,length,current,get,parameter,types,length,return,false,for,int,i,0,i,previous,get,parameter,types,length,i,if,previous,get,parameter,types,i,equals,current,get,parameter,types,i,return,false,return,true
TransactionalTestExecutionListener -> private boolean isShadowed(Method current, Method previous);1407419079;Determine if the supplied {@link Method current method} is <em>shadowed</em>_by a {@link Method previous method}._<p>Note: This code has been borrowed from_{@link org.junit.internal.runners.TestClass#isShadowed(Method, Method)}._@param current the current method_@param previous the previous method_@return {@code true} if the previous method shadows the current one;private boolean isShadowed(Method current, Method previous) {_		if (!previous.getName().equals(current.getName())) {_			return false__		}_		if (previous.getParameterTypes().length != current.getParameterTypes().length) {_			return false__		}_		for (int i = 0_ i < previous.getParameterTypes().length_ i++) {_			if (!previous.getParameterTypes()[i].equals(current.getParameterTypes()[i])) {_				return false__			}_		}_		return true__	};determine,if,the,supplied,link,method,current,method,is,em,shadowed,em,by,a,link,method,previous,method,p,note,this,code,has,been,borrowed,from,link,org,junit,internal,runners,test,class,is,shadowed,method,method,param,current,the,current,method,param,previous,the,previous,method,return,code,true,if,the,previous,method,shadows,the,current,one;private,boolean,is,shadowed,method,current,method,previous,if,previous,get,name,equals,current,get,name,return,false,if,previous,get,parameter,types,length,current,get,parameter,types,length,return,false,for,int,i,0,i,previous,get,parameter,types,length,i,if,previous,get,parameter,types,i,equals,current,get,parameter,types,i,return,false,return,true
TransactionalTestExecutionListener -> private boolean isShadowed(Method current, Method previous);1408048216;Determine if the supplied {@link Method current method} is <em>shadowed</em>_by a {@link Method previous method}._<p>Note: This code has been borrowed from_{@link org.junit.internal.runners.TestClass#isShadowed(Method, Method)}._@param current the current method_@param previous the previous method_@return {@code true} if the previous method shadows the current one;private boolean isShadowed(Method current, Method previous) {_		if (!previous.getName().equals(current.getName())) {_			return false__		}_		if (previous.getParameterTypes().length != current.getParameterTypes().length) {_			return false__		}_		for (int i = 0_ i < previous.getParameterTypes().length_ i++) {_			if (!previous.getParameterTypes()[i].equals(current.getParameterTypes()[i])) {_				return false__			}_		}_		return true__	};determine,if,the,supplied,link,method,current,method,is,em,shadowed,em,by,a,link,method,previous,method,p,note,this,code,has,been,borrowed,from,link,org,junit,internal,runners,test,class,is,shadowed,method,method,param,current,the,current,method,param,previous,the,previous,method,return,code,true,if,the,previous,method,shadows,the,current,one;private,boolean,is,shadowed,method,current,method,previous,if,previous,get,name,equals,current,get,name,return,false,if,previous,get,parameter,types,length,current,get,parameter,types,length,return,false,for,int,i,0,i,previous,get,parameter,types,length,i,if,previous,get,parameter,types,i,equals,current,get,parameter,types,i,return,false,return,true
TransactionalTestExecutionListener -> private boolean isShadowed(Method current, Method previous);1413848647;Determine if the supplied {@link Method current method} is <em>shadowed</em>_by a {@link Method previous method}._<p>Note: This code has been borrowed from_{@link org.junit.internal.runners.TestClass#isShadowed(Method, Method)}._@param current the current method_@param previous the previous method_@return {@code true} if the previous method shadows the current one;private boolean isShadowed(Method current, Method previous) {_		if (!previous.getName().equals(current.getName())) {_			return false__		}_		if (previous.getParameterTypes().length != current.getParameterTypes().length) {_			return false__		}_		for (int i = 0_ i < previous.getParameterTypes().length_ i++) {_			if (!previous.getParameterTypes()[i].equals(current.getParameterTypes()[i])) {_				return false__			}_		}_		return true__	};determine,if,the,supplied,link,method,current,method,is,em,shadowed,em,by,a,link,method,previous,method,p,note,this,code,has,been,borrowed,from,link,org,junit,internal,runners,test,class,is,shadowed,method,method,param,current,the,current,method,param,previous,the,previous,method,return,code,true,if,the,previous,method,shadows,the,current,one;private,boolean,is,shadowed,method,current,method,previous,if,previous,get,name,equals,current,get,name,return,false,if,previous,get,parameter,types,length,current,get,parameter,types,length,return,false,for,int,i,0,i,previous,get,parameter,types,length,i,if,previous,get,parameter,types,i,equals,current,get,parameter,types,i,return,false,return,true
TransactionalTestExecutionListener -> private boolean isShadowed(Method current, Method previous);1431568199;Determine if the supplied {@link Method current method} is <em>shadowed</em>_by a {@link Method previous method}._<p>Note: This code has been borrowed from_{@link org.junit.internal.runners.TestClass#isShadowed(Method, Method)}._@param current the current method_@param previous the previous method_@return {@code true} if the previous method shadows the current one;private boolean isShadowed(Method current, Method previous) {_		if (!previous.getName().equals(current.getName())) {_			return false__		}_		if (previous.getParameterTypes().length != current.getParameterTypes().length) {_			return false__		}_		for (int i = 0_ i < previous.getParameterTypes().length_ i++) {_			if (!previous.getParameterTypes()[i].equals(current.getParameterTypes()[i])) {_				return false__			}_		}_		return true__	};determine,if,the,supplied,link,method,current,method,is,em,shadowed,em,by,a,link,method,previous,method,p,note,this,code,has,been,borrowed,from,link,org,junit,internal,runners,test,class,is,shadowed,method,method,param,current,the,current,method,param,previous,the,previous,method,return,code,true,if,the,previous,method,shadows,the,current,one;private,boolean,is,shadowed,method,current,method,previous,if,previous,get,name,equals,current,get,name,return,false,if,previous,get,parameter,types,length,current,get,parameter,types,length,return,false,for,int,i,0,i,previous,get,parameter,types,length,i,if,previous,get,parameter,types,i,equals,current,get,parameter,types,i,return,false,return,true
TransactionalTestExecutionListener -> private boolean isShadowed(Method current, Method previous);1432125256;Determine if the supplied {@link Method current method} is <em>shadowed</em>_by a {@link Method previous method}._<p>Note: This code has been borrowed from_{@link org.junit.internal.runners.TestClass#isShadowed(Method, Method)}._@param current the current method_@param previous the previous method_@return {@code true} if the previous method shadows the current one;private boolean isShadowed(Method current, Method previous) {_		if (!previous.getName().equals(current.getName())) {_			return false__		}_		if (previous.getParameterTypes().length != current.getParameterTypes().length) {_			return false__		}_		for (int i = 0_ i < previous.getParameterTypes().length_ i++) {_			if (!previous.getParameterTypes()[i].equals(current.getParameterTypes()[i])) {_				return false__			}_		}_		return true__	};determine,if,the,supplied,link,method,current,method,is,em,shadowed,em,by,a,link,method,previous,method,p,note,this,code,has,been,borrowed,from,link,org,junit,internal,runners,test,class,is,shadowed,method,method,param,current,the,current,method,param,previous,the,previous,method,return,code,true,if,the,previous,method,shadows,the,current,one;private,boolean,is,shadowed,method,current,method,previous,if,previous,get,name,equals,current,get,name,return,false,if,previous,get,parameter,types,length,current,get,parameter,types,length,return,false,for,int,i,0,i,previous,get,parameter,types,length,i,if,previous,get,parameter,types,i,equals,current,get,parameter,types,i,return,false,return,true
TransactionalTestExecutionListener -> private boolean isShadowed(Method current, Method previous);1432856630;Determine if the supplied {@link Method current method} is <em>shadowed</em>_by a {@link Method previous method}._<p>Note: This code has been borrowed from_{@link org.junit.internal.runners.TestClass#isShadowed(Method, Method)}._@param current the current method_@param previous the previous method_@return {@code true} if the previous method shadows the current one;private boolean isShadowed(Method current, Method previous) {_		if (!previous.getName().equals(current.getName())) {_			return false__		}_		if (previous.getParameterTypes().length != current.getParameterTypes().length) {_			return false__		}_		for (int i = 0_ i < previous.getParameterTypes().length_ i++) {_			if (!previous.getParameterTypes()[i].equals(current.getParameterTypes()[i])) {_				return false__			}_		}_		return true__	};determine,if,the,supplied,link,method,current,method,is,em,shadowed,em,by,a,link,method,previous,method,p,note,this,code,has,been,borrowed,from,link,org,junit,internal,runners,test,class,is,shadowed,method,method,param,current,the,current,method,param,previous,the,previous,method,return,code,true,if,the,previous,method,shadows,the,current,one;private,boolean,is,shadowed,method,current,method,previous,if,previous,get,name,equals,current,get,name,return,false,if,previous,get,parameter,types,length,current,get,parameter,types,length,return,false,for,int,i,0,i,previous,get,parameter,types,length,i,if,previous,get,parameter,types,i,equals,current,get,parameter,types,i,return,false,return,true
TransactionalTestExecutionListener -> private boolean isShadowed(Method current, Method previous);1434234880;Determine if the supplied {@link Method current method} is <em>shadowed</em>_by a {@link Method previous method}._<p>Note: This code has been borrowed from_{@link org.junit.internal.runners.TestClass#isShadowed(Method, Method)}._@param current the current method_@param previous the previous method_@return {@code true} if the previous method shadows the current one;private boolean isShadowed(Method current, Method previous) {_		if (!previous.getName().equals(current.getName())) {_			return false__		}_		if (previous.getParameterTypes().length != current.getParameterTypes().length) {_			return false__		}_		for (int i = 0_ i < previous.getParameterTypes().length_ i++) {_			if (!previous.getParameterTypes()[i].equals(current.getParameterTypes()[i])) {_				return false__			}_		}_		return true__	};determine,if,the,supplied,link,method,current,method,is,em,shadowed,em,by,a,link,method,previous,method,p,note,this,code,has,been,borrowed,from,link,org,junit,internal,runners,test,class,is,shadowed,method,method,param,current,the,current,method,param,previous,the,previous,method,return,code,true,if,the,previous,method,shadows,the,current,one;private,boolean,is,shadowed,method,current,method,previous,if,previous,get,name,equals,current,get,name,return,false,if,previous,get,parameter,types,length,current,get,parameter,types,length,return,false,for,int,i,0,i,previous,get,parameter,types,length,i,if,previous,get,parameter,types,i,equals,current,get,parameter,types,i,return,false,return,true
TransactionalTestExecutionListener -> private boolean isShadowed(Method current, Method previous);1434720443;Determine if the supplied {@link Method current method} is <em>shadowed</em>_by a {@link Method previous method}._<p>Note: This code has been borrowed from_{@link org.junit.internal.runners.TestClass#isShadowed(Method, Method)}._@param current the current method_@param previous the previous method_@return {@code true} if the previous method shadows the current one;private boolean isShadowed(Method current, Method previous) {_		if (!previous.getName().equals(current.getName())) {_			return false__		}_		if (previous.getParameterTypes().length != current.getParameterTypes().length) {_			return false__		}_		for (int i = 0_ i < previous.getParameterTypes().length_ i++) {_			if (!previous.getParameterTypes()[i].equals(current.getParameterTypes()[i])) {_				return false__			}_		}_		return true__	};determine,if,the,supplied,link,method,current,method,is,em,shadowed,em,by,a,link,method,previous,method,p,note,this,code,has,been,borrowed,from,link,org,junit,internal,runners,test,class,is,shadowed,method,method,param,current,the,current,method,param,previous,the,previous,method,return,code,true,if,the,previous,method,shadows,the,current,one;private,boolean,is,shadowed,method,current,method,previous,if,previous,get,name,equals,current,get,name,return,false,if,previous,get,parameter,types,length,current,get,parameter,types,length,return,false,for,int,i,0,i,previous,get,parameter,types,length,i,if,previous,get,parameter,types,i,equals,current,get,parameter,types,i,return,false,return,true
TransactionalTestExecutionListener -> private boolean isShadowed(Method current, Method previous);1434817656;Determine if the supplied {@link Method current method} is <em>shadowed</em>_by a {@link Method previous method}._<p>Note: This code has been borrowed from_{@link org.junit.internal.runners.TestClass#isShadowed(Method, Method)}._@param current the current method_@param previous the previous method_@return {@code true} if the previous method shadows the current one;private boolean isShadowed(Method current, Method previous) {_		if (!previous.getName().equals(current.getName())) {_			return false__		}_		if (previous.getParameterTypes().length != current.getParameterTypes().length) {_			return false__		}_		for (int i = 0_ i < previous.getParameterTypes().length_ i++) {_			if (!previous.getParameterTypes()[i].equals(current.getParameterTypes()[i])) {_				return false__			}_		}_		return true__	};determine,if,the,supplied,link,method,current,method,is,em,shadowed,em,by,a,link,method,previous,method,p,note,this,code,has,been,borrowed,from,link,org,junit,internal,runners,test,class,is,shadowed,method,method,param,current,the,current,method,param,previous,the,previous,method,return,code,true,if,the,previous,method,shadows,the,current,one;private,boolean,is,shadowed,method,current,method,previous,if,previous,get,name,equals,current,get,name,return,false,if,previous,get,parameter,types,length,current,get,parameter,types,length,return,false,for,int,i,0,i,previous,get,parameter,types,length,i,if,previous,get,parameter,types,i,equals,current,get,parameter,types,i,return,false,return,true
TransactionalTestExecutionListener -> private boolean isShadowed(Method current, Method previous);1437841346;Determine if the supplied {@linkplain Method current method} is_<em>shadowed</em> by a {@linkplain Method previous method}._<p>Note: This code has been borrowed from_{@link org.junit.internal.runners.TestClass#isShadowed(Method, Method)}._@param current the current method_@param previous the previous method_@return {@code true} if the previous method shadows the current one;private boolean isShadowed(Method current, Method previous) {_		if (!previous.getName().equals(current.getName())) {_			return false__		}_		if (previous.getParameterTypes().length != current.getParameterTypes().length) {_			return false__		}_		for (int i = 0_ i < previous.getParameterTypes().length_ i++) {_			if (!previous.getParameterTypes()[i].equals(current.getParameterTypes()[i])) {_				return false__			}_		}_		return true__	};determine,if,the,supplied,linkplain,method,current,method,is,em,shadowed,em,by,a,linkplain,method,previous,method,p,note,this,code,has,been,borrowed,from,link,org,junit,internal,runners,test,class,is,shadowed,method,method,param,current,the,current,method,param,previous,the,previous,method,return,code,true,if,the,previous,method,shadows,the,current,one;private,boolean,is,shadowed,method,current,method,previous,if,previous,get,name,equals,current,get,name,return,false,if,previous,get,parameter,types,length,current,get,parameter,types,length,return,false,for,int,i,0,i,previous,get,parameter,types,length,i,if,previous,get,parameter,types,i,equals,current,get,parameter,types,i,return,false,return,true
TransactionalTestExecutionListener -> private boolean isShadowed(Method current, Method previous);1437851372;Determine if the supplied {@linkplain Method current method} is_<em>shadowed</em> by a {@linkplain Method previous method}._<p>Note: This code has been borrowed from_{@link org.junit.internal.runners.TestClass#isShadowed(Method, Method)}._@param current the current method_@param previous the previous method_@return {@code true} if the previous method shadows the current one;private boolean isShadowed(Method current, Method previous) {_		if (!previous.getName().equals(current.getName())) {_			return false__		}_		if (previous.getParameterTypes().length != current.getParameterTypes().length) {_			return false__		}_		for (int i = 0_ i < previous.getParameterTypes().length_ i++) {_			if (!previous.getParameterTypes()[i].equals(current.getParameterTypes()[i])) {_				return false__			}_		}_		return true__	};determine,if,the,supplied,linkplain,method,current,method,is,em,shadowed,em,by,a,linkplain,method,previous,method,p,note,this,code,has,been,borrowed,from,link,org,junit,internal,runners,test,class,is,shadowed,method,method,param,current,the,current,method,param,previous,the,previous,method,return,code,true,if,the,previous,method,shadows,the,current,one;private,boolean,is,shadowed,method,current,method,previous,if,previous,get,name,equals,current,get,name,return,false,if,previous,get,parameter,types,length,current,get,parameter,types,length,return,false,for,int,i,0,i,previous,get,parameter,types,length,i,if,previous,get,parameter,types,i,equals,current,get,parameter,types,i,return,false,return,true
TransactionalTestExecutionListener -> private boolean isShadowed(Method current, Method previous);1437852597;Determine if the supplied {@linkplain Method current method} is_<em>shadowed</em> by a {@linkplain Method previous method}._<p>Note: This code has been borrowed from_{@link org.junit.internal.runners.TestClass#isShadowed(Method, Method)}._@param current the current method_@param previous the previous method_@return {@code true} if the previous method shadows the current one;private boolean isShadowed(Method current, Method previous) {_		if (!previous.getName().equals(current.getName())) {_			return false__		}_		if (previous.getParameterTypes().length != current.getParameterTypes().length) {_			return false__		}_		for (int i = 0_ i < previous.getParameterTypes().length_ i++) {_			if (!previous.getParameterTypes()[i].equals(current.getParameterTypes()[i])) {_				return false__			}_		}_		return true__	};determine,if,the,supplied,linkplain,method,current,method,is,em,shadowed,em,by,a,linkplain,method,previous,method,p,note,this,code,has,been,borrowed,from,link,org,junit,internal,runners,test,class,is,shadowed,method,method,param,current,the,current,method,param,previous,the,previous,method,return,code,true,if,the,previous,method,shadows,the,current,one;private,boolean,is,shadowed,method,current,method,previous,if,previous,get,name,equals,current,get,name,return,false,if,previous,get,parameter,types,length,current,get,parameter,types,length,return,false,for,int,i,0,i,previous,get,parameter,types,length,i,if,previous,get,parameter,types,i,equals,current,get,parameter,types,i,return,false,return,true
TransactionalTestExecutionListener -> private boolean isShadowed(Method current, Method previous);1454507787;Determine if the supplied {@linkplain Method current method} is_<em>shadowed</em> by a {@linkplain Method previous method}._<p>Note: This code has been borrowed from_{@link org.junit.internal.runners.TestClass#isShadowed(Method, Method)}._@param current the current method_@param previous the previous method_@return {@code true} if the previous method shadows the current one;private boolean isShadowed(Method current, Method previous) {_		if (!previous.getName().equals(current.getName())) {_			return false__		}_		if (previous.getParameterTypes().length != current.getParameterTypes().length) {_			return false__		}_		for (int i = 0_ i < previous.getParameterTypes().length_ i++) {_			if (!previous.getParameterTypes()[i].equals(current.getParameterTypes()[i])) {_				return false__			}_		}_		return true__	};determine,if,the,supplied,linkplain,method,current,method,is,em,shadowed,em,by,a,linkplain,method,previous,method,p,note,this,code,has,been,borrowed,from,link,org,junit,internal,runners,test,class,is,shadowed,method,method,param,current,the,current,method,param,previous,the,previous,method,return,code,true,if,the,previous,method,shadows,the,current,one;private,boolean,is,shadowed,method,current,method,previous,if,previous,get,name,equals,current,get,name,return,false,if,previous,get,parameter,types,length,current,get,parameter,types,length,return,false,for,int,i,0,i,previous,get,parameter,types,length,i,if,previous,get,parameter,types,i,equals,current,get,parameter,types,i,return,false,return,true
TransactionalTestExecutionListener -> private boolean isShadowed(Method current, Method previous);1456702967;Determine if the supplied {@linkplain Method current method} is_<em>shadowed</em> by a {@linkplain Method previous method}._<p>Note: This code has been borrowed from_{@link org.junit.internal.runners.TestClass#isShadowed(Method, Method)}._@param current the current method_@param previous the previous method_@return {@code true} if the previous method shadows the current one;private boolean isShadowed(Method current, Method previous) {_		if (!previous.getName().equals(current.getName())) {_			return false__		}_		if (previous.getParameterTypes().length != current.getParameterTypes().length) {_			return false__		}_		for (int i = 0_ i < previous.getParameterTypes().length_ i++) {_			if (!previous.getParameterTypes()[i].equals(current.getParameterTypes()[i])) {_				return false__			}_		}_		return true__	};determine,if,the,supplied,linkplain,method,current,method,is,em,shadowed,em,by,a,linkplain,method,previous,method,p,note,this,code,has,been,borrowed,from,link,org,junit,internal,runners,test,class,is,shadowed,method,method,param,current,the,current,method,param,previous,the,previous,method,return,code,true,if,the,previous,method,shadows,the,current,one;private,boolean,is,shadowed,method,current,method,previous,if,previous,get,name,equals,current,get,name,return,false,if,previous,get,parameter,types,length,current,get,parameter,types,length,return,false,for,int,i,0,i,previous,get,parameter,types,length,i,if,previous,get,parameter,types,i,equals,current,get,parameter,types,i,return,false,return,true
TransactionalTestExecutionListener -> private boolean isShadowed(Method current, Method previous);1456756222;Determine if the supplied {@linkplain Method current method} is_<em>shadowed</em> by a {@linkplain Method previous method}._<p>Note: This code has been borrowed from_{@link org.junit.internal.runners.TestClass#isShadowed(Method, Method)}._@param current the current method_@param previous the previous method_@return {@code true} if the previous method shadows the current one;private boolean isShadowed(Method current, Method previous) {_		if (!previous.getName().equals(current.getName())) {_			return false__		}_		if (previous.getParameterTypes().length != current.getParameterTypes().length) {_			return false__		}_		for (int i = 0_ i < previous.getParameterTypes().length_ i++) {_			if (!previous.getParameterTypes()[i].equals(current.getParameterTypes()[i])) {_				return false__			}_		}_		return true__	};determine,if,the,supplied,linkplain,method,current,method,is,em,shadowed,em,by,a,linkplain,method,previous,method,p,note,this,code,has,been,borrowed,from,link,org,junit,internal,runners,test,class,is,shadowed,method,method,param,current,the,current,method,param,previous,the,previous,method,return,code,true,if,the,previous,method,shadows,the,current,one;private,boolean,is,shadowed,method,current,method,previous,if,previous,get,name,equals,current,get,name,return,false,if,previous,get,parameter,types,length,current,get,parameter,types,length,return,false,for,int,i,0,i,previous,get,parameter,types,length,i,if,previous,get,parameter,types,i,equals,current,get,parameter,types,i,return,false,return,true
TransactionalTestExecutionListener -> private boolean isShadowed(Method current, Method previous);1456756222;Determine if the supplied {@linkplain Method current method} is_<em>shadowed</em> by a {@linkplain Method previous method}._<p>Note: This code has been borrowed from_{@link org.junit.internal.runners.TestClass#isShadowed(Method, Method)}._@param current the current method_@param previous the previous method_@return {@code true} if the previous method shadows the current one;private boolean isShadowed(Method current, Method previous) {_		if (!previous.getName().equals(current.getName())) {_			return false__		}_		if (previous.getParameterTypes().length != current.getParameterTypes().length) {_			return false__		}_		for (int i = 0_ i < previous.getParameterTypes().length_ i++) {_			if (!previous.getParameterTypes()[i].equals(current.getParameterTypes()[i])) {_				return false__			}_		}_		return true__	};determine,if,the,supplied,linkplain,method,current,method,is,em,shadowed,em,by,a,linkplain,method,previous,method,p,note,this,code,has,been,borrowed,from,link,org,junit,internal,runners,test,class,is,shadowed,method,method,param,current,the,current,method,param,previous,the,previous,method,return,code,true,if,the,previous,method,shadows,the,current,one;private,boolean,is,shadowed,method,current,method,previous,if,previous,get,name,equals,current,get,name,return,false,if,previous,get,parameter,types,length,current,get,parameter,types,length,return,false,for,int,i,0,i,previous,get,parameter,types,length,i,if,previous,get,parameter,types,i,equals,current,get,parameter,types,i,return,false,return,true
TransactionalTestExecutionListener -> private boolean isShadowed(Method current, Method previous);1458754760;Determine if the supplied {@linkplain Method current method} is_<em>shadowed</em> by a {@linkplain Method previous method}._<p>Note: This code has been borrowed from_{@link org.junit.internal.runners.TestClass#isShadowed(Method, Method)}._@param current the current method_@param previous the previous method_@return {@code true} if the previous method shadows the current one;private boolean isShadowed(Method current, Method previous) {_		if (!previous.getName().equals(current.getName())) {_			return false__		}_		if (previous.getParameterTypes().length != current.getParameterTypes().length) {_			return false__		}_		for (int i = 0_ i < previous.getParameterTypes().length_ i++) {_			if (!previous.getParameterTypes()[i].equals(current.getParameterTypes()[i])) {_				return false__			}_		}_		return true__	};determine,if,the,supplied,linkplain,method,current,method,is,em,shadowed,em,by,a,linkplain,method,previous,method,p,note,this,code,has,been,borrowed,from,link,org,junit,internal,runners,test,class,is,shadowed,method,method,param,current,the,current,method,param,previous,the,previous,method,return,code,true,if,the,previous,method,shadows,the,current,one;private,boolean,is,shadowed,method,current,method,previous,if,previous,get,name,equals,current,get,name,return,false,if,previous,get,parameter,types,length,current,get,parameter,types,length,return,false,for,int,i,0,i,previous,get,parameter,types,length,i,if,previous,get,parameter,types,i,equals,current,get,parameter,types,i,return,false,return,true
TransactionalTestExecutionListener -> protected void runBeforeTransactionMethods(TestContext testContext) throws Exception;1328020251;Run all {@link BeforeTransaction &#064_BeforeTransaction methods} for the_specified {@link TestContext test context}. If one of the methods fails,_however, the caught exception will be rethrown in a wrapped_{@link RuntimeException}, and the remaining methods will <strong>not</strong>_be given a chance to execute._@param testContext the current test context;protected void runBeforeTransactionMethods(TestContext testContext) throws Exception {_		try {_			List<Method> methods = getAnnotatedMethods(testContext.getTestClass(), BeforeTransaction.class)__			Collections.reverse(methods)__			for (Method method : methods) {_				if (logger.isDebugEnabled()) {_					logger.debug("Executing @BeforeTransaction method [" + method + "] for test context ["_							+ testContext + "]")__				}_				method.invoke(testContext.getTestInstance())__			}_		}_		catch (InvocationTargetException ex) {_			logger.error("Exception encountered while executing @BeforeTransaction methods for test context ["_					+ testContext + "]", ex.getTargetException())__			ReflectionUtils.rethrowException(ex.getTargetException())__		}_	};run,all,link,before,transaction,064,before,transaction,methods,for,the,specified,link,test,context,test,context,if,one,of,the,methods,fails,however,the,caught,exception,will,be,rethrown,in,a,wrapped,link,runtime,exception,and,the,remaining,methods,will,strong,not,strong,be,given,a,chance,to,execute,param,test,context,the,current,test,context;protected,void,run,before,transaction,methods,test,context,test,context,throws,exception,try,list,method,methods,get,annotated,methods,test,context,get,test,class,before,transaction,class,collections,reverse,methods,for,method,method,methods,if,logger,is,debug,enabled,logger,debug,executing,before,transaction,method,method,for,test,context,test,context,method,invoke,test,context,get,test,instance,catch,invocation,target,exception,ex,logger,error,exception,encountered,while,executing,before,transaction,methods,for,test,context,test,context,ex,get,target,exception,reflection,utils,rethrow,exception,ex,get,target,exception
TransactionalTestExecutionListener -> protected void runBeforeTransactionMethods(TestContext testContext) throws Exception;1337516454;Run all {@link BeforeTransaction &#064_BeforeTransaction methods} for the_specified {@link TestContext test context}. If one of the methods fails,_however, the caught exception will be rethrown in a wrapped_{@link RuntimeException}, and the remaining methods will <strong>not</strong>_be given a chance to execute._@param testContext the current test context;protected void runBeforeTransactionMethods(TestContext testContext) throws Exception {_		try {_			List<Method> methods = getAnnotatedMethods(testContext.getTestClass(), BeforeTransaction.class)__			Collections.reverse(methods)__			for (Method method : methods) {_				if (logger.isDebugEnabled()) {_					logger.debug("Executing @BeforeTransaction method [" + method + "] for test context ["_							+ testContext + "]")__				}_				method.invoke(testContext.getTestInstance())__			}_		}_		catch (InvocationTargetException ex) {_			logger.error("Exception encountered while executing @BeforeTransaction methods for test context ["_					+ testContext + "]", ex.getTargetException())__			ReflectionUtils.rethrowException(ex.getTargetException())__		}_	};run,all,link,before,transaction,064,before,transaction,methods,for,the,specified,link,test,context,test,context,if,one,of,the,methods,fails,however,the,caught,exception,will,be,rethrown,in,a,wrapped,link,runtime,exception,and,the,remaining,methods,will,strong,not,strong,be,given,a,chance,to,execute,param,test,context,the,current,test,context;protected,void,run,before,transaction,methods,test,context,test,context,throws,exception,try,list,method,methods,get,annotated,methods,test,context,get,test,class,before,transaction,class,collections,reverse,methods,for,method,method,methods,if,logger,is,debug,enabled,logger,debug,executing,before,transaction,method,method,for,test,context,test,context,method,invoke,test,context,get,test,instance,catch,invocation,target,exception,ex,logger,error,exception,encountered,while,executing,before,transaction,methods,for,test,context,test,context,ex,get,target,exception,reflection,utils,rethrow,exception,ex,get,target,exception
TransactionalTestExecutionListener -> protected void runBeforeTransactionMethods(TestContext testContext) throws Exception;1338031377;Run all {@link BeforeTransaction &#064_BeforeTransaction methods} for the_specified {@link TestContext test context}. If one of the methods fails,_however, the caught exception will be rethrown in a wrapped_{@link RuntimeException}, and the remaining methods will <strong>not</strong>_be given a chance to execute._@param testContext the current test context;protected void runBeforeTransactionMethods(TestContext testContext) throws Exception {_		try {_			List<Method> methods = getAnnotatedMethods(testContext.getTestClass(), BeforeTransaction.class)__			Collections.reverse(methods)__			for (Method method : methods) {_				if (logger.isDebugEnabled()) {_					logger.debug("Executing @BeforeTransaction method [" + method + "] for test context ["_							+ testContext + "]")__				}_				method.invoke(testContext.getTestInstance())__			}_		}_		catch (InvocationTargetException ex) {_			logger.error("Exception encountered while executing @BeforeTransaction methods for test context ["_					+ testContext + "]", ex.getTargetException())__			ReflectionUtils.rethrowException(ex.getTargetException())__		}_	};run,all,link,before,transaction,064,before,transaction,methods,for,the,specified,link,test,context,test,context,if,one,of,the,methods,fails,however,the,caught,exception,will,be,rethrown,in,a,wrapped,link,runtime,exception,and,the,remaining,methods,will,strong,not,strong,be,given,a,chance,to,execute,param,test,context,the,current,test,context;protected,void,run,before,transaction,methods,test,context,test,context,throws,exception,try,list,method,methods,get,annotated,methods,test,context,get,test,class,before,transaction,class,collections,reverse,methods,for,method,method,methods,if,logger,is,debug,enabled,logger,debug,executing,before,transaction,method,method,for,test,context,test,context,method,invoke,test,context,get,test,instance,catch,invocation,target,exception,ex,logger,error,exception,encountered,while,executing,before,transaction,methods,for,test,context,test,context,ex,get,target,exception,reflection,utils,rethrow,exception,ex,get,target,exception
TransactionalTestExecutionListener -> protected void runBeforeTransactionMethods(TestContext testContext) throws Exception;1343426806;Run all {@link BeforeTransaction &#064_BeforeTransaction methods} for the_specified {@link TestContext test context}. If one of the methods fails,_however, the caught exception will be rethrown in a wrapped_{@link RuntimeException}, and the remaining methods will <strong>not</strong>_be given a chance to execute._@param testContext the current test context;protected void runBeforeTransactionMethods(TestContext testContext) throws Exception {_		try {_			List<Method> methods = getAnnotatedMethods(testContext.getTestClass(), BeforeTransaction.class)__			Collections.reverse(methods)__			for (Method method : methods) {_				if (logger.isDebugEnabled()) {_					logger.debug("Executing @BeforeTransaction method [" + method + "] for test context " + testContext)__				}_				method.invoke(testContext.getTestInstance())__			}_		}_		catch (InvocationTargetException ex) {_			logger.error("Exception encountered while executing @BeforeTransaction methods for test context "_					+ testContext + ".", ex.getTargetException())__			ReflectionUtils.rethrowException(ex.getTargetException())__		}_	};run,all,link,before,transaction,064,before,transaction,methods,for,the,specified,link,test,context,test,context,if,one,of,the,methods,fails,however,the,caught,exception,will,be,rethrown,in,a,wrapped,link,runtime,exception,and,the,remaining,methods,will,strong,not,strong,be,given,a,chance,to,execute,param,test,context,the,current,test,context;protected,void,run,before,transaction,methods,test,context,test,context,throws,exception,try,list,method,methods,get,annotated,methods,test,context,get,test,class,before,transaction,class,collections,reverse,methods,for,method,method,methods,if,logger,is,debug,enabled,logger,debug,executing,before,transaction,method,method,for,test,context,test,context,method,invoke,test,context,get,test,instance,catch,invocation,target,exception,ex,logger,error,exception,encountered,while,executing,before,transaction,methods,for,test,context,test,context,ex,get,target,exception,reflection,utils,rethrow,exception,ex,get,target,exception
TransactionalTestExecutionListener -> protected void runBeforeTransactionMethods(TestContext testContext) throws Exception;1343431472;Run all {@link BeforeTransaction &#064_BeforeTransaction methods} for the_specified {@link TestContext test context}. If one of the methods fails,_however, the caught exception will be rethrown in a wrapped_{@link RuntimeException}, and the remaining methods will <strong>not</strong>_be given a chance to execute._@param testContext the current test context;protected void runBeforeTransactionMethods(TestContext testContext) throws Exception {_		try {_			List<Method> methods = getAnnotatedMethods(testContext.getTestClass(), BeforeTransaction.class)__			Collections.reverse(methods)__			for (Method method : methods) {_				if (logger.isDebugEnabled()) {_					logger.debug("Executing @BeforeTransaction method [" + method + "] for test context " + testContext)__				}_				method.invoke(testContext.getTestInstance())__			}_		}_		catch (InvocationTargetException ex) {_			logger.error("Exception encountered while executing @BeforeTransaction methods for test context "_					+ testContext + ".", ex.getTargetException())__			ReflectionUtils.rethrowException(ex.getTargetException())__		}_	};run,all,link,before,transaction,064,before,transaction,methods,for,the,specified,link,test,context,test,context,if,one,of,the,methods,fails,however,the,caught,exception,will,be,rethrown,in,a,wrapped,link,runtime,exception,and,the,remaining,methods,will,strong,not,strong,be,given,a,chance,to,execute,param,test,context,the,current,test,context;protected,void,run,before,transaction,methods,test,context,test,context,throws,exception,try,list,method,methods,get,annotated,methods,test,context,get,test,class,before,transaction,class,collections,reverse,methods,for,method,method,methods,if,logger,is,debug,enabled,logger,debug,executing,before,transaction,method,method,for,test,context,test,context,method,invoke,test,context,get,test,instance,catch,invocation,target,exception,ex,logger,error,exception,encountered,while,executing,before,transaction,methods,for,test,context,test,context,ex,get,target,exception,reflection,utils,rethrow,exception,ex,get,target,exception
TransactionalTestExecutionListener -> protected void runBeforeTransactionMethods(TestContext testContext) throws Exception;1354571539;Run all {@link BeforeTransaction &#064_BeforeTransaction methods} for the_specified {@link TestContext test context}. If one of the methods fails,_however, the caught exception will be rethrown in a wrapped_{@link RuntimeException}, and the remaining methods will <strong>not</strong>_be given a chance to execute._@param testContext the current test context;protected void runBeforeTransactionMethods(TestContext testContext) throws Exception {_		try {_			List<Method> methods = getAnnotatedMethods(testContext.getTestClass(), BeforeTransaction.class)__			Collections.reverse(methods)__			for (Method method : methods) {_				if (logger.isDebugEnabled()) {_					logger.debug("Executing @BeforeTransaction method [" + method + "] for test context " + testContext)__				}_				method.invoke(testContext.getTestInstance())__			}_		}_		catch (InvocationTargetException ex) {_			logger.error("Exception encountered while executing @BeforeTransaction methods for test context "_					+ testContext + ".", ex.getTargetException())__			ReflectionUtils.rethrowException(ex.getTargetException())__		}_	};run,all,link,before,transaction,064,before,transaction,methods,for,the,specified,link,test,context,test,context,if,one,of,the,methods,fails,however,the,caught,exception,will,be,rethrown,in,a,wrapped,link,runtime,exception,and,the,remaining,methods,will,strong,not,strong,be,given,a,chance,to,execute,param,test,context,the,current,test,context;protected,void,run,before,transaction,methods,test,context,test,context,throws,exception,try,list,method,methods,get,annotated,methods,test,context,get,test,class,before,transaction,class,collections,reverse,methods,for,method,method,methods,if,logger,is,debug,enabled,logger,debug,executing,before,transaction,method,method,for,test,context,test,context,method,invoke,test,context,get,test,instance,catch,invocation,target,exception,ex,logger,error,exception,encountered,while,executing,before,transaction,methods,for,test,context,test,context,ex,get,target,exception,reflection,utils,rethrow,exception,ex,get,target,exception
TransactionalTestExecutionListener -> protected void runBeforeTransactionMethods(TestContext testContext) throws Exception;1355352386;Run all {@link BeforeTransaction &#064_BeforeTransaction methods} for the_specified {@link TestContext test context}. If one of the methods fails,_however, the caught exception will be rethrown in a wrapped_{@link RuntimeException}, and the remaining methods will <strong>not</strong>_be given a chance to execute._@param testContext the current test context;protected void runBeforeTransactionMethods(TestContext testContext) throws Exception {_		try {_			List<Method> methods = getAnnotatedMethods(testContext.getTestClass(), BeforeTransaction.class)__			Collections.reverse(methods)__			for (Method method : methods) {_				if (logger.isDebugEnabled()) {_					logger.debug("Executing @BeforeTransaction method [" + method + "] for test context " + testContext)__				}_				method.invoke(testContext.getTestInstance())__			}_		}_		catch (InvocationTargetException ex) {_			logger.error("Exception encountered while executing @BeforeTransaction methods for test context "_					+ testContext + ".", ex.getTargetException())__			ReflectionUtils.rethrowException(ex.getTargetException())__		}_	};run,all,link,before,transaction,064,before,transaction,methods,for,the,specified,link,test,context,test,context,if,one,of,the,methods,fails,however,the,caught,exception,will,be,rethrown,in,a,wrapped,link,runtime,exception,and,the,remaining,methods,will,strong,not,strong,be,given,a,chance,to,execute,param,test,context,the,current,test,context;protected,void,run,before,transaction,methods,test,context,test,context,throws,exception,try,list,method,methods,get,annotated,methods,test,context,get,test,class,before,transaction,class,collections,reverse,methods,for,method,method,methods,if,logger,is,debug,enabled,logger,debug,executing,before,transaction,method,method,for,test,context,test,context,method,invoke,test,context,get,test,instance,catch,invocation,target,exception,ex,logger,error,exception,encountered,while,executing,before,transaction,methods,for,test,context,test,context,ex,get,target,exception,reflection,utils,rethrow,exception,ex,get,target,exception
TransactionalTestExecutionListener -> protected void runBeforeTransactionMethods(TestContext testContext) throws Exception;1356735495;Run all {@link BeforeTransaction &#064_BeforeTransaction methods} for the_specified {@link TestContext test context}. If one of the methods fails,_however, the caught exception will be rethrown in a wrapped_{@link RuntimeException}, and the remaining methods will <strong>not</strong>_be given a chance to execute._@param testContext the current test context;protected void runBeforeTransactionMethods(TestContext testContext) throws Exception {_		try {_			List<Method> methods = getAnnotatedMethods(testContext.getTestClass(), BeforeTransaction.class)__			Collections.reverse(methods)__			for (Method method : methods) {_				if (logger.isDebugEnabled()) {_					logger.debug("Executing @BeforeTransaction method [" + method + "] for test context " + testContext)__				}_				method.invoke(testContext.getTestInstance())__			}_		}_		catch (InvocationTargetException ex) {_			logger.error("Exception encountered while executing @BeforeTransaction methods for test context "_					+ testContext + ".", ex.getTargetException())__			ReflectionUtils.rethrowException(ex.getTargetException())__		}_	};run,all,link,before,transaction,064,before,transaction,methods,for,the,specified,link,test,context,test,context,if,one,of,the,methods,fails,however,the,caught,exception,will,be,rethrown,in,a,wrapped,link,runtime,exception,and,the,remaining,methods,will,strong,not,strong,be,given,a,chance,to,execute,param,test,context,the,current,test,context;protected,void,run,before,transaction,methods,test,context,test,context,throws,exception,try,list,method,methods,get,annotated,methods,test,context,get,test,class,before,transaction,class,collections,reverse,methods,for,method,method,methods,if,logger,is,debug,enabled,logger,debug,executing,before,transaction,method,method,for,test,context,test,context,method,invoke,test,context,get,test,instance,catch,invocation,target,exception,ex,logger,error,exception,encountered,while,executing,before,transaction,methods,for,test,context,test,context,ex,get,target,exception,reflection,utils,rethrow,exception,ex,get,target,exception
TransactionalTestExecutionListener -> protected void runBeforeTransactionMethods(TestContext testContext) throws Exception;1357119239;Run all {@link BeforeTransaction &#064_BeforeTransaction methods} for the_specified {@link TestContext test context}. If one of the methods fails,_however, the caught exception will be rethrown in a wrapped_{@link RuntimeException}, and the remaining methods will <strong>not</strong>_be given a chance to execute._@param testContext the current test context;protected void runBeforeTransactionMethods(TestContext testContext) throws Exception {_		try {_			List<Method> methods = getAnnotatedMethods(testContext.getTestClass(), BeforeTransaction.class)__			Collections.reverse(methods)__			for (Method method : methods) {_				if (logger.isDebugEnabled()) {_					logger.debug("Executing @BeforeTransaction method [" + method + "] for test context " + testContext)__				}_				method.invoke(testContext.getTestInstance())__			}_		}_		catch (InvocationTargetException ex) {_			logger.error("Exception encountered while executing @BeforeTransaction methods for test context "_					+ testContext + ".", ex.getTargetException())__			ReflectionUtils.rethrowException(ex.getTargetException())__		}_	};run,all,link,before,transaction,064,before,transaction,methods,for,the,specified,link,test,context,test,context,if,one,of,the,methods,fails,however,the,caught,exception,will,be,rethrown,in,a,wrapped,link,runtime,exception,and,the,remaining,methods,will,strong,not,strong,be,given,a,chance,to,execute,param,test,context,the,current,test,context;protected,void,run,before,transaction,methods,test,context,test,context,throws,exception,try,list,method,methods,get,annotated,methods,test,context,get,test,class,before,transaction,class,collections,reverse,methods,for,method,method,methods,if,logger,is,debug,enabled,logger,debug,executing,before,transaction,method,method,for,test,context,test,context,method,invoke,test,context,get,test,instance,catch,invocation,target,exception,ex,logger,error,exception,encountered,while,executing,before,transaction,methods,for,test,context,test,context,ex,get,target,exception,reflection,utils,rethrow,exception,ex,get,target,exception
TransactionalTestExecutionListener -> protected void runBeforeTransactionMethods(TestContext testContext) throws Exception;1367163114;Run all {@link BeforeTransaction &#064_BeforeTransaction methods} for the_specified {@link TestContext test context}. If one of the methods fails,_however, the caught exception will be rethrown in a wrapped_{@link RuntimeException}, and the remaining methods will <strong>not</strong>_be given a chance to execute._@param testContext the current test context;protected void runBeforeTransactionMethods(TestContext testContext) throws Exception {_		try {_			List<Method> methods = getAnnotatedMethods(testContext.getTestClass(), BeforeTransaction.class)__			Collections.reverse(methods)__			for (Method method : methods) {_				if (logger.isDebugEnabled()) {_					logger.debug("Executing @BeforeTransaction method [" + method + "] for test context " + testContext)__				}_				method.invoke(testContext.getTestInstance())__			}_		}_		catch (InvocationTargetException ex) {_			logger.error("Exception encountered while executing @BeforeTransaction methods for test context "_					+ testContext + ".", ex.getTargetException())__			ReflectionUtils.rethrowException(ex.getTargetException())__		}_	};run,all,link,before,transaction,064,before,transaction,methods,for,the,specified,link,test,context,test,context,if,one,of,the,methods,fails,however,the,caught,exception,will,be,rethrown,in,a,wrapped,link,runtime,exception,and,the,remaining,methods,will,strong,not,strong,be,given,a,chance,to,execute,param,test,context,the,current,test,context;protected,void,run,before,transaction,methods,test,context,test,context,throws,exception,try,list,method,methods,get,annotated,methods,test,context,get,test,class,before,transaction,class,collections,reverse,methods,for,method,method,methods,if,logger,is,debug,enabled,logger,debug,executing,before,transaction,method,method,for,test,context,test,context,method,invoke,test,context,get,test,instance,catch,invocation,target,exception,ex,logger,error,exception,encountered,while,executing,before,transaction,methods,for,test,context,test,context,ex,get,target,exception,reflection,utils,rethrow,exception,ex,get,target,exception
TransactionalTestExecutionListener -> protected void runBeforeTransactionMethods(TestContext testContext) throws Exception;1367873075;Run all {@link BeforeTransaction &#064_BeforeTransaction methods} for the_specified {@link TestContext test context}. If one of the methods fails,_however, the caught exception will be rethrown in a wrapped_{@link RuntimeException}, and the remaining methods will <strong>not</strong>_be given a chance to execute._@param testContext the current test context;protected void runBeforeTransactionMethods(TestContext testContext) throws Exception {_		try {_			List<Method> methods = getAnnotatedMethods(testContext.getTestClass(), BeforeTransaction.class)__			Collections.reverse(methods)__			for (Method method : methods) {_				if (logger.isDebugEnabled()) {_					logger.debug("Executing @BeforeTransaction method [" + method + "] for test context " + testContext)__				}_				method.invoke(testContext.getTestInstance())__			}_		}_		catch (InvocationTargetException ex) {_			logger.error("Exception encountered while executing @BeforeTransaction methods for test context "_					+ testContext + ".", ex.getTargetException())__			ReflectionUtils.rethrowException(ex.getTargetException())__		}_	};run,all,link,before,transaction,064,before,transaction,methods,for,the,specified,link,test,context,test,context,if,one,of,the,methods,fails,however,the,caught,exception,will,be,rethrown,in,a,wrapped,link,runtime,exception,and,the,remaining,methods,will,strong,not,strong,be,given,a,chance,to,execute,param,test,context,the,current,test,context;protected,void,run,before,transaction,methods,test,context,test,context,throws,exception,try,list,method,methods,get,annotated,methods,test,context,get,test,class,before,transaction,class,collections,reverse,methods,for,method,method,methods,if,logger,is,debug,enabled,logger,debug,executing,before,transaction,method,method,for,test,context,test,context,method,invoke,test,context,get,test,instance,catch,invocation,target,exception,ex,logger,error,exception,encountered,while,executing,before,transaction,methods,for,test,context,test,context,ex,get,target,exception,reflection,utils,rethrow,exception,ex,get,target,exception
TransactionalTestExecutionListener -> protected void runBeforeTransactionMethods(TestContext testContext) throws Exception;1368482696;Run all {@link BeforeTransaction &#064_BeforeTransaction methods} for the_specified {@link TestContext test context}. If one of the methods fails,_however, the caught exception will be rethrown in a wrapped_{@link RuntimeException}, and the remaining methods will <strong>not</strong>_be given a chance to execute._@param testContext the current test context;protected void runBeforeTransactionMethods(TestContext testContext) throws Exception {_		try {_			List<Method> methods = getAnnotatedMethods(testContext.getTestClass(), BeforeTransaction.class)__			Collections.reverse(methods)__			for (Method method : methods) {_				if (logger.isDebugEnabled()) {_					logger.debug("Executing @BeforeTransaction method [" + method + "] for test context " + testContext)__				}_				method.invoke(testContext.getTestInstance())__			}_		}_		catch (InvocationTargetException ex) {_			logger.error("Exception encountered while executing @BeforeTransaction methods for test context "_					+ testContext + ".", ex.getTargetException())__			ReflectionUtils.rethrowException(ex.getTargetException())__		}_	};run,all,link,before,transaction,064,before,transaction,methods,for,the,specified,link,test,context,test,context,if,one,of,the,methods,fails,however,the,caught,exception,will,be,rethrown,in,a,wrapped,link,runtime,exception,and,the,remaining,methods,will,strong,not,strong,be,given,a,chance,to,execute,param,test,context,the,current,test,context;protected,void,run,before,transaction,methods,test,context,test,context,throws,exception,try,list,method,methods,get,annotated,methods,test,context,get,test,class,before,transaction,class,collections,reverse,methods,for,method,method,methods,if,logger,is,debug,enabled,logger,debug,executing,before,transaction,method,method,for,test,context,test,context,method,invoke,test,context,get,test,instance,catch,invocation,target,exception,ex,logger,error,exception,encountered,while,executing,before,transaction,methods,for,test,context,test,context,ex,get,target,exception,reflection,utils,rethrow,exception,ex,get,target,exception
TransactionalTestExecutionListener -> protected void runBeforeTransactionMethods(TestContext testContext) throws Exception;1382920864;Run all {@link BeforeTransaction &#064_BeforeTransaction methods} for the_specified {@link TestContext test context}. If one of the methods fails,_however, the caught exception will be rethrown in a wrapped_{@link RuntimeException}, and the remaining methods will <strong>not</strong>_be given a chance to execute._@param testContext the current test context;protected void runBeforeTransactionMethods(TestContext testContext) throws Exception {_		try {_			List<Method> methods = getAnnotatedMethods(testContext.getTestClass(), BeforeTransaction.class)__			Collections.reverse(methods)__			for (Method method : methods) {_				if (logger.isDebugEnabled()) {_					logger.debug("Executing @BeforeTransaction method [" + method + "] for test context " + testContext)__				}_				method.invoke(testContext.getTestInstance())__			}_		}_		catch (InvocationTargetException ex) {_			logger.error("Exception encountered while executing @BeforeTransaction methods for test context "_					+ testContext + ".", ex.getTargetException())__			ReflectionUtils.rethrowException(ex.getTargetException())__		}_	};run,all,link,before,transaction,064,before,transaction,methods,for,the,specified,link,test,context,test,context,if,one,of,the,methods,fails,however,the,caught,exception,will,be,rethrown,in,a,wrapped,link,runtime,exception,and,the,remaining,methods,will,strong,not,strong,be,given,a,chance,to,execute,param,test,context,the,current,test,context;protected,void,run,before,transaction,methods,test,context,test,context,throws,exception,try,list,method,methods,get,annotated,methods,test,context,get,test,class,before,transaction,class,collections,reverse,methods,for,method,method,methods,if,logger,is,debug,enabled,logger,debug,executing,before,transaction,method,method,for,test,context,test,context,method,invoke,test,context,get,test,instance,catch,invocation,target,exception,ex,logger,error,exception,encountered,while,executing,before,transaction,methods,for,test,context,test,context,ex,get,target,exception,reflection,utils,rethrow,exception,ex,get,target,exception
TransactionalTestExecutionListener -> protected void runBeforeTransactionMethods(TestContext testContext) throws Exception;1385499540;Run all {@link BeforeTransaction &#064_BeforeTransaction methods} for the_specified {@link TestContext test context}. If one of the methods fails,_however, the caught exception will be rethrown in a wrapped_{@link RuntimeException}, and the remaining methods will <strong>not</strong>_be given a chance to execute._@param testContext the current test context;protected void runBeforeTransactionMethods(TestContext testContext) throws Exception {_		try {_			List<Method> methods = getAnnotatedMethods(testContext.getTestClass(), BeforeTransaction.class)__			Collections.reverse(methods)__			for (Method method : methods) {_				if (logger.isDebugEnabled()) {_					logger.debug("Executing @BeforeTransaction method [" + method + "] for test context " + testContext)__				}_				method.invoke(testContext.getTestInstance())__			}_		}_		catch (InvocationTargetException ex) {_			logger.error("Exception encountered while executing @BeforeTransaction methods for test context "_					+ testContext + ".", ex.getTargetException())__			ReflectionUtils.rethrowException(ex.getTargetException())__		}_	};run,all,link,before,transaction,064,before,transaction,methods,for,the,specified,link,test,context,test,context,if,one,of,the,methods,fails,however,the,caught,exception,will,be,rethrown,in,a,wrapped,link,runtime,exception,and,the,remaining,methods,will,strong,not,strong,be,given,a,chance,to,execute,param,test,context,the,current,test,context;protected,void,run,before,transaction,methods,test,context,test,context,throws,exception,try,list,method,methods,get,annotated,methods,test,context,get,test,class,before,transaction,class,collections,reverse,methods,for,method,method,methods,if,logger,is,debug,enabled,logger,debug,executing,before,transaction,method,method,for,test,context,test,context,method,invoke,test,context,get,test,instance,catch,invocation,target,exception,ex,logger,error,exception,encountered,while,executing,before,transaction,methods,for,test,context,test,context,ex,get,target,exception,reflection,utils,rethrow,exception,ex,get,target,exception
TransactionalTestExecutionListener -> protected void runBeforeTransactionMethods(TestContext testContext) throws Exception;1389966876;Run all {@link BeforeTransaction &#064_BeforeTransaction methods} for the_specified {@link TestContext test context}. If one of the methods fails,_however, the caught exception will be rethrown in a wrapped_{@link RuntimeException}, and the remaining methods will <strong>not</strong>_be given a chance to execute._@param testContext the current test context;protected void runBeforeTransactionMethods(TestContext testContext) throws Exception {_		try {_			List<Method> methods = getAnnotatedMethods(testContext.getTestClass(), BeforeTransaction.class)__			Collections.reverse(methods)__			for (Method method : methods) {_				if (logger.isDebugEnabled()) {_					logger.debug("Executing @BeforeTransaction method [" + method + "] for test context " + testContext)__				}_				method.invoke(testContext.getTestInstance())__			}_		}_		catch (InvocationTargetException ex) {_			logger.error("Exception encountered while executing @BeforeTransaction methods for test context "_					+ testContext + ".", ex.getTargetException())__			ReflectionUtils.rethrowException(ex.getTargetException())__		}_	};run,all,link,before,transaction,064,before,transaction,methods,for,the,specified,link,test,context,test,context,if,one,of,the,methods,fails,however,the,caught,exception,will,be,rethrown,in,a,wrapped,link,runtime,exception,and,the,remaining,methods,will,strong,not,strong,be,given,a,chance,to,execute,param,test,context,the,current,test,context;protected,void,run,before,transaction,methods,test,context,test,context,throws,exception,try,list,method,methods,get,annotated,methods,test,context,get,test,class,before,transaction,class,collections,reverse,methods,for,method,method,methods,if,logger,is,debug,enabled,logger,debug,executing,before,transaction,method,method,for,test,context,test,context,method,invoke,test,context,get,test,instance,catch,invocation,target,exception,ex,logger,error,exception,encountered,while,executing,before,transaction,methods,for,test,context,test,context,ex,get,target,exception,reflection,utils,rethrow,exception,ex,get,target,exception
TransactionalTestExecutionListener -> protected void runBeforeTransactionMethods(TestContext testContext) throws Exception;1401991965;Run all {@link BeforeTransaction &#064_BeforeTransaction methods} for the_specified {@link TestContext test context}. If one of the methods fails,_however, the caught exception will be rethrown in a wrapped_{@link RuntimeException}, and the remaining methods will <strong>not</strong>_be given a chance to execute._@param testContext the current test context;protected void runBeforeTransactionMethods(TestContext testContext) throws Exception {_		try {_			List<Method> methods = getAnnotatedMethods(testContext.getTestClass(), BeforeTransaction.class)__			Collections.reverse(methods)__			for (Method method : methods) {_				if (logger.isDebugEnabled()) {_					logger.debug("Executing @BeforeTransaction method [" + method + "] for test context " + testContext)__				}_				method.invoke(testContext.getTestInstance())__			}_		}_		catch (InvocationTargetException ex) {_			logger.error("Exception encountered while executing @BeforeTransaction methods for test context "_					+ testContext + ".", ex.getTargetException())__			ReflectionUtils.rethrowException(ex.getTargetException())__		}_	};run,all,link,before,transaction,064,before,transaction,methods,for,the,specified,link,test,context,test,context,if,one,of,the,methods,fails,however,the,caught,exception,will,be,rethrown,in,a,wrapped,link,runtime,exception,and,the,remaining,methods,will,strong,not,strong,be,given,a,chance,to,execute,param,test,context,the,current,test,context;protected,void,run,before,transaction,methods,test,context,test,context,throws,exception,try,list,method,methods,get,annotated,methods,test,context,get,test,class,before,transaction,class,collections,reverse,methods,for,method,method,methods,if,logger,is,debug,enabled,logger,debug,executing,before,transaction,method,method,for,test,context,test,context,method,invoke,test,context,get,test,instance,catch,invocation,target,exception,ex,logger,error,exception,encountered,while,executing,before,transaction,methods,for,test,context,test,context,ex,get,target,exception,reflection,utils,rethrow,exception,ex,get,target,exception
TransactionalTestExecutionListener -> protected void runBeforeTransactionMethods(TestContext testContext) throws Exception;1404334604;Run all {@link BeforeTransaction @BeforeTransaction} methods for the_specified {@link TestContext test context}. If one of the methods fails,_however, the caught exception will be rethrown in a wrapped_{@link RuntimeException}, and the remaining methods will <strong>not</strong>_be given a chance to execute._@param testContext the current test context;protected void runBeforeTransactionMethods(TestContext testContext) throws Exception {_		try {_			List<Method> methods = getAnnotatedMethods(testContext.getTestClass(), BeforeTransaction.class)__			Collections.reverse(methods)__			for (Method method : methods) {_				if (logger.isDebugEnabled()) {_					logger.debug("Executing @BeforeTransaction method [" + method + "] for test context " + testContext)__				}_				method.invoke(testContext.getTestInstance())__			}_		}_		catch (InvocationTargetException ex) {_			logger.error("Exception encountered while executing @BeforeTransaction methods for test context "_					+ testContext + ".", ex.getTargetException())__			ReflectionUtils.rethrowException(ex.getTargetException())__		}_	};run,all,link,before,transaction,before,transaction,methods,for,the,specified,link,test,context,test,context,if,one,of,the,methods,fails,however,the,caught,exception,will,be,rethrown,in,a,wrapped,link,runtime,exception,and,the,remaining,methods,will,strong,not,strong,be,given,a,chance,to,execute,param,test,context,the,current,test,context;protected,void,run,before,transaction,methods,test,context,test,context,throws,exception,try,list,method,methods,get,annotated,methods,test,context,get,test,class,before,transaction,class,collections,reverse,methods,for,method,method,methods,if,logger,is,debug,enabled,logger,debug,executing,before,transaction,method,method,for,test,context,test,context,method,invoke,test,context,get,test,instance,catch,invocation,target,exception,ex,logger,error,exception,encountered,while,executing,before,transaction,methods,for,test,context,test,context,ex,get,target,exception,reflection,utils,rethrow,exception,ex,get,target,exception
TransactionalTestExecutionListener -> protected void runBeforeTransactionMethods(TestContext testContext) throws Exception;1405645143;Run all {@link BeforeTransaction @BeforeTransaction} methods for the_specified {@link TestContext test context}. If one of the methods fails,_however, the caught exception will be rethrown in a wrapped_{@link RuntimeException}, and the remaining methods will <strong>not</strong>_be given a chance to execute._@param testContext the current test context;protected void runBeforeTransactionMethods(TestContext testContext) throws Exception {_		try {_			List<Method> methods = getAnnotatedMethods(testContext.getTestClass(), BeforeTransaction.class)__			Collections.reverse(methods)__			for (Method method : methods) {_				if (logger.isDebugEnabled()) {_					logger.debug("Executing @BeforeTransaction method [" + method + "] for test context " + testContext)__				}_				method.invoke(testContext.getTestInstance())__			}_		}_		catch (InvocationTargetException ex) {_			logger.error("Exception encountered while executing @BeforeTransaction methods for test context "_					+ testContext + ".", ex.getTargetException())__			ReflectionUtils.rethrowException(ex.getTargetException())__		}_	};run,all,link,before,transaction,before,transaction,methods,for,the,specified,link,test,context,test,context,if,one,of,the,methods,fails,however,the,caught,exception,will,be,rethrown,in,a,wrapped,link,runtime,exception,and,the,remaining,methods,will,strong,not,strong,be,given,a,chance,to,execute,param,test,context,the,current,test,context;protected,void,run,before,transaction,methods,test,context,test,context,throws,exception,try,list,method,methods,get,annotated,methods,test,context,get,test,class,before,transaction,class,collections,reverse,methods,for,method,method,methods,if,logger,is,debug,enabled,logger,debug,executing,before,transaction,method,method,for,test,context,test,context,method,invoke,test,context,get,test,instance,catch,invocation,target,exception,ex,logger,error,exception,encountered,while,executing,before,transaction,methods,for,test,context,test,context,ex,get,target,exception,reflection,utils,rethrow,exception,ex,get,target,exception
TransactionalTestExecutionListener -> protected void runBeforeTransactionMethods(TestContext testContext) throws Exception;1405698612;Run all {@link BeforeTransaction @BeforeTransaction} methods for the_specified {@link TestContext test context}. If one of the methods fails,_however, the caught exception will be rethrown in a wrapped_{@link RuntimeException}, and the remaining methods will <strong>not</strong>_be given a chance to execute._@param testContext the current test context;protected void runBeforeTransactionMethods(TestContext testContext) throws Exception {_		try {_			List<Method> methods = getAnnotatedMethods(testContext.getTestClass(), BeforeTransaction.class)__			Collections.reverse(methods)__			for (Method method : methods) {_				if (logger.isDebugEnabled()) {_					logger.debug("Executing @BeforeTransaction method [" + method + "] for test context " + testContext)__				}_				method.invoke(testContext.getTestInstance())__			}_		}_		catch (InvocationTargetException ex) {_			logger.error("Exception encountered while executing @BeforeTransaction methods for test context "_					+ testContext + ".", ex.getTargetException())__			ReflectionUtils.rethrowException(ex.getTargetException())__		}_	};run,all,link,before,transaction,before,transaction,methods,for,the,specified,link,test,context,test,context,if,one,of,the,methods,fails,however,the,caught,exception,will,be,rethrown,in,a,wrapped,link,runtime,exception,and,the,remaining,methods,will,strong,not,strong,be,given,a,chance,to,execute,param,test,context,the,current,test,context;protected,void,run,before,transaction,methods,test,context,test,context,throws,exception,try,list,method,methods,get,annotated,methods,test,context,get,test,class,before,transaction,class,collections,reverse,methods,for,method,method,methods,if,logger,is,debug,enabled,logger,debug,executing,before,transaction,method,method,for,test,context,test,context,method,invoke,test,context,get,test,instance,catch,invocation,target,exception,ex,logger,error,exception,encountered,while,executing,before,transaction,methods,for,test,context,test,context,ex,get,target,exception,reflection,utils,rethrow,exception,ex,get,target,exception
TransactionalTestExecutionListener -> protected void runBeforeTransactionMethods(TestContext testContext) throws Exception;1405759527;Run all {@link BeforeTransaction @BeforeTransaction} methods for the_specified {@link TestContext test context}. If one of the methods fails,_however, the caught exception will be rethrown in a wrapped_{@link RuntimeException}, and the remaining methods will <strong>not</strong>_be given a chance to execute._@param testContext the current test context;protected void runBeforeTransactionMethods(TestContext testContext) throws Exception {_		try {_			List<Method> methods = getAnnotatedMethods(testContext.getTestClass(), BeforeTransaction.class)__			Collections.reverse(methods)__			for (Method method : methods) {_				if (logger.isDebugEnabled()) {_					logger.debug("Executing @BeforeTransaction method [" + method + "] for test context " + testContext)__				}_				method.invoke(testContext.getTestInstance())__			}_		}_		catch (InvocationTargetException ex) {_			logger.error("Exception encountered while executing @BeforeTransaction methods for test context "_					+ testContext + ".", ex.getTargetException())__			ReflectionUtils.rethrowException(ex.getTargetException())__		}_	};run,all,link,before,transaction,before,transaction,methods,for,the,specified,link,test,context,test,context,if,one,of,the,methods,fails,however,the,caught,exception,will,be,rethrown,in,a,wrapped,link,runtime,exception,and,the,remaining,methods,will,strong,not,strong,be,given,a,chance,to,execute,param,test,context,the,current,test,context;protected,void,run,before,transaction,methods,test,context,test,context,throws,exception,try,list,method,methods,get,annotated,methods,test,context,get,test,class,before,transaction,class,collections,reverse,methods,for,method,method,methods,if,logger,is,debug,enabled,logger,debug,executing,before,transaction,method,method,for,test,context,test,context,method,invoke,test,context,get,test,instance,catch,invocation,target,exception,ex,logger,error,exception,encountered,while,executing,before,transaction,methods,for,test,context,test,context,ex,get,target,exception,reflection,utils,rethrow,exception,ex,get,target,exception
TransactionalTestExecutionListener -> protected void runBeforeTransactionMethods(TestContext testContext) throws Exception;1405759966;Run all {@link BeforeTransaction @BeforeTransaction} methods for the_specified {@link TestContext test context}. If one of the methods fails,_however, the caught exception will be rethrown in a wrapped_{@link RuntimeException}, and the remaining methods will <strong>not</strong>_be given a chance to execute._@param testContext the current test context;protected void runBeforeTransactionMethods(TestContext testContext) throws Exception {_		try {_			List<Method> methods = getAnnotatedMethods(testContext.getTestClass(), BeforeTransaction.class)__			Collections.reverse(methods)__			for (Method method : methods) {_				if (logger.isDebugEnabled()) {_					logger.debug("Executing @BeforeTransaction method [" + method + "] for test context " + testContext)__				}_				method.invoke(testContext.getTestInstance())__			}_		}_		catch (InvocationTargetException ex) {_			logger.error("Exception encountered while executing @BeforeTransaction methods for test context "_					+ testContext + ".", ex.getTargetException())__			ReflectionUtils.rethrowException(ex.getTargetException())__		}_	};run,all,link,before,transaction,before,transaction,methods,for,the,specified,link,test,context,test,context,if,one,of,the,methods,fails,however,the,caught,exception,will,be,rethrown,in,a,wrapped,link,runtime,exception,and,the,remaining,methods,will,strong,not,strong,be,given,a,chance,to,execute,param,test,context,the,current,test,context;protected,void,run,before,transaction,methods,test,context,test,context,throws,exception,try,list,method,methods,get,annotated,methods,test,context,get,test,class,before,transaction,class,collections,reverse,methods,for,method,method,methods,if,logger,is,debug,enabled,logger,debug,executing,before,transaction,method,method,for,test,context,test,context,method,invoke,test,context,get,test,instance,catch,invocation,target,exception,ex,logger,error,exception,encountered,while,executing,before,transaction,methods,for,test,context,test,context,ex,get,target,exception,reflection,utils,rethrow,exception,ex,get,target,exception
TransactionalTestExecutionListener -> protected void runBeforeTransactionMethods(TestContext testContext) throws Exception;1406218418;Run all {@link BeforeTransaction @BeforeTransaction} methods for the_specified {@link TestContext test context}. If one of the methods fails,_however, the caught exception will be rethrown in a wrapped_{@link RuntimeException}, and the remaining methods will <strong>not</strong>_be given a chance to execute._@param testContext the current test context;protected void runBeforeTransactionMethods(TestContext testContext) throws Exception {_		try {_			List<Method> methods = getAnnotatedMethods(testContext.getTestClass(), BeforeTransaction.class)__			Collections.reverse(methods)__			for (Method method : methods) {_				if (logger.isDebugEnabled()) {_					logger.debug("Executing @BeforeTransaction method [" + method + "] for test context " + testContext)__				}_				method.invoke(testContext.getTestInstance())__			}_		}_		catch (InvocationTargetException ex) {_			logger.error("Exception encountered while executing @BeforeTransaction methods for test context "_					+ testContext + ".", ex.getTargetException())__			ReflectionUtils.rethrowException(ex.getTargetException())__		}_	};run,all,link,before,transaction,before,transaction,methods,for,the,specified,link,test,context,test,context,if,one,of,the,methods,fails,however,the,caught,exception,will,be,rethrown,in,a,wrapped,link,runtime,exception,and,the,remaining,methods,will,strong,not,strong,be,given,a,chance,to,execute,param,test,context,the,current,test,context;protected,void,run,before,transaction,methods,test,context,test,context,throws,exception,try,list,method,methods,get,annotated,methods,test,context,get,test,class,before,transaction,class,collections,reverse,methods,for,method,method,methods,if,logger,is,debug,enabled,logger,debug,executing,before,transaction,method,method,for,test,context,test,context,method,invoke,test,context,get,test,instance,catch,invocation,target,exception,ex,logger,error,exception,encountered,while,executing,before,transaction,methods,for,test,context,test,context,ex,get,target,exception,reflection,utils,rethrow,exception,ex,get,target,exception
TransactionalTestExecutionListener -> protected void runBeforeTransactionMethods(TestContext testContext) throws Exception;1407419079;Run all {@link BeforeTransaction @BeforeTransaction} methods for the_specified {@link TestContext test context}. If one of the methods fails,_however, the caught exception will be rethrown in a wrapped_{@link RuntimeException}, and the remaining methods will <strong>not</strong>_be given a chance to execute._@param testContext the current test context;protected void runBeforeTransactionMethods(TestContext testContext) throws Exception {_		try {_			List<Method> methods = getAnnotatedMethods(testContext.getTestClass(), BeforeTransaction.class)__			Collections.reverse(methods)__			for (Method method : methods) {_				if (logger.isDebugEnabled()) {_					logger.debug("Executing @BeforeTransaction method [" + method + "] for test context " + testContext)__				}_				method.invoke(testContext.getTestInstance())__			}_		}_		catch (InvocationTargetException ex) {_			logger.error("Exception encountered while executing @BeforeTransaction methods for test context "_					+ testContext + ".", ex.getTargetException())__			ReflectionUtils.rethrowException(ex.getTargetException())__		}_	};run,all,link,before,transaction,before,transaction,methods,for,the,specified,link,test,context,test,context,if,one,of,the,methods,fails,however,the,caught,exception,will,be,rethrown,in,a,wrapped,link,runtime,exception,and,the,remaining,methods,will,strong,not,strong,be,given,a,chance,to,execute,param,test,context,the,current,test,context;protected,void,run,before,transaction,methods,test,context,test,context,throws,exception,try,list,method,methods,get,annotated,methods,test,context,get,test,class,before,transaction,class,collections,reverse,methods,for,method,method,methods,if,logger,is,debug,enabled,logger,debug,executing,before,transaction,method,method,for,test,context,test,context,method,invoke,test,context,get,test,instance,catch,invocation,target,exception,ex,logger,error,exception,encountered,while,executing,before,transaction,methods,for,test,context,test,context,ex,get,target,exception,reflection,utils,rethrow,exception,ex,get,target,exception
TransactionalTestExecutionListener -> protected void runBeforeTransactionMethods(TestContext testContext) throws Exception;1408048216;Run all {@link BeforeTransaction @BeforeTransaction} methods for the_specified {@link TestContext test context}. If one of the methods fails,_however, the caught exception will be rethrown in a wrapped_{@link RuntimeException}, and the remaining methods will <strong>not</strong>_be given a chance to execute._@param testContext the current test context;protected void runBeforeTransactionMethods(TestContext testContext) throws Exception {_		try {_			List<Method> methods = getAnnotatedMethods(testContext.getTestClass(), BeforeTransaction.class)__			Collections.reverse(methods)__			for (Method method : methods) {_				if (logger.isDebugEnabled()) {_					logger.debug("Executing @BeforeTransaction method [" + method + "] for test context " + testContext)__				}_				method.invoke(testContext.getTestInstance())__			}_		}_		catch (InvocationTargetException ex) {_			logger.error("Exception encountered while executing @BeforeTransaction methods for test context "_					+ testContext + ".", ex.getTargetException())__			ReflectionUtils.rethrowException(ex.getTargetException())__		}_	};run,all,link,before,transaction,before,transaction,methods,for,the,specified,link,test,context,test,context,if,one,of,the,methods,fails,however,the,caught,exception,will,be,rethrown,in,a,wrapped,link,runtime,exception,and,the,remaining,methods,will,strong,not,strong,be,given,a,chance,to,execute,param,test,context,the,current,test,context;protected,void,run,before,transaction,methods,test,context,test,context,throws,exception,try,list,method,methods,get,annotated,methods,test,context,get,test,class,before,transaction,class,collections,reverse,methods,for,method,method,methods,if,logger,is,debug,enabled,logger,debug,executing,before,transaction,method,method,for,test,context,test,context,method,invoke,test,context,get,test,instance,catch,invocation,target,exception,ex,logger,error,exception,encountered,while,executing,before,transaction,methods,for,test,context,test,context,ex,get,target,exception,reflection,utils,rethrow,exception,ex,get,target,exception
TransactionalTestExecutionListener -> protected void runBeforeTransactionMethods(TestContext testContext) throws Exception;1413848647;Run all {@link BeforeTransaction @BeforeTransaction} methods for the_specified {@link TestContext test context}. If one of the methods fails,_however, the caught exception will be rethrown in a wrapped_{@link RuntimeException}, and the remaining methods will <strong>not</strong>_be given a chance to execute._@param testContext the current test context;protected void runBeforeTransactionMethods(TestContext testContext) throws Exception {_		try {_			List<Method> methods = getAnnotatedMethods(testContext.getTestClass(), BeforeTransaction.class)__			Collections.reverse(methods)__			for (Method method : methods) {_				if (logger.isDebugEnabled()) {_					logger.debug("Executing @BeforeTransaction method [" + method + "] for test context " + testContext)__				}_				method.invoke(testContext.getTestInstance())__			}_		}_		catch (InvocationTargetException ex) {_			logger.error("Exception encountered while executing @BeforeTransaction methods for test context "_					+ testContext + ".", ex.getTargetException())__			ReflectionUtils.rethrowException(ex.getTargetException())__		}_	};run,all,link,before,transaction,before,transaction,methods,for,the,specified,link,test,context,test,context,if,one,of,the,methods,fails,however,the,caught,exception,will,be,rethrown,in,a,wrapped,link,runtime,exception,and,the,remaining,methods,will,strong,not,strong,be,given,a,chance,to,execute,param,test,context,the,current,test,context;protected,void,run,before,transaction,methods,test,context,test,context,throws,exception,try,list,method,methods,get,annotated,methods,test,context,get,test,class,before,transaction,class,collections,reverse,methods,for,method,method,methods,if,logger,is,debug,enabled,logger,debug,executing,before,transaction,method,method,for,test,context,test,context,method,invoke,test,context,get,test,instance,catch,invocation,target,exception,ex,logger,error,exception,encountered,while,executing,before,transaction,methods,for,test,context,test,context,ex,get,target,exception,reflection,utils,rethrow,exception,ex,get,target,exception
TransactionalTestExecutionListener -> protected void runBeforeTransactionMethods(TestContext testContext) throws Exception;1431568199;Run all {@link BeforeTransaction @BeforeTransaction} methods for the_specified {@link TestContext test context}. If one of the methods fails,_however, the caught exception will be rethrown in a wrapped_{@link RuntimeException}, and the remaining methods will <strong>not</strong>_be given a chance to execute._@param testContext the current test context;protected void runBeforeTransactionMethods(TestContext testContext) throws Exception {_		try {_			List<Method> methods = getAnnotatedMethods(testContext.getTestClass(), BeforeTransaction.class)__			Collections.reverse(methods)__			for (Method method : methods) {_				if (logger.isDebugEnabled()) {_					logger.debug("Executing @BeforeTransaction method [" + method + "] for test context " + testContext)__				}_				method.invoke(testContext.getTestInstance())__			}_		}_		catch (InvocationTargetException ex) {_			logger.error("Exception encountered while executing @BeforeTransaction methods for test context "_					+ testContext + ".", ex.getTargetException())__			ReflectionUtils.rethrowException(ex.getTargetException())__		}_	};run,all,link,before,transaction,before,transaction,methods,for,the,specified,link,test,context,test,context,if,one,of,the,methods,fails,however,the,caught,exception,will,be,rethrown,in,a,wrapped,link,runtime,exception,and,the,remaining,methods,will,strong,not,strong,be,given,a,chance,to,execute,param,test,context,the,current,test,context;protected,void,run,before,transaction,methods,test,context,test,context,throws,exception,try,list,method,methods,get,annotated,methods,test,context,get,test,class,before,transaction,class,collections,reverse,methods,for,method,method,methods,if,logger,is,debug,enabled,logger,debug,executing,before,transaction,method,method,for,test,context,test,context,method,invoke,test,context,get,test,instance,catch,invocation,target,exception,ex,logger,error,exception,encountered,while,executing,before,transaction,methods,for,test,context,test,context,ex,get,target,exception,reflection,utils,rethrow,exception,ex,get,target,exception
TransactionalTestExecutionListener -> protected void runBeforeTransactionMethods(TestContext testContext) throws Exception;1432125256;Run all {@link BeforeTransaction @BeforeTransaction} methods for the_specified {@link TestContext test context}. If one of the methods fails,_however, the caught exception will be rethrown in a wrapped_{@link RuntimeException}, and the remaining methods will <strong>not</strong>_be given a chance to execute._@param testContext the current test context;protected void runBeforeTransactionMethods(TestContext testContext) throws Exception {_		try {_			List<Method> methods = getAnnotatedMethods(testContext.getTestClass(), BeforeTransaction.class)__			Collections.reverse(methods)__			for (Method method : methods) {_				if (logger.isDebugEnabled()) {_					logger.debug("Executing @BeforeTransaction method [" + method + "] for test context " + testContext)__				}_				method.invoke(testContext.getTestInstance())__			}_		}_		catch (InvocationTargetException ex) {_			logger.error("Exception encountered while executing @BeforeTransaction methods for test context "_					+ testContext + ".", ex.getTargetException())__			ReflectionUtils.rethrowException(ex.getTargetException())__		}_	};run,all,link,before,transaction,before,transaction,methods,for,the,specified,link,test,context,test,context,if,one,of,the,methods,fails,however,the,caught,exception,will,be,rethrown,in,a,wrapped,link,runtime,exception,and,the,remaining,methods,will,strong,not,strong,be,given,a,chance,to,execute,param,test,context,the,current,test,context;protected,void,run,before,transaction,methods,test,context,test,context,throws,exception,try,list,method,methods,get,annotated,methods,test,context,get,test,class,before,transaction,class,collections,reverse,methods,for,method,method,methods,if,logger,is,debug,enabled,logger,debug,executing,before,transaction,method,method,for,test,context,test,context,method,invoke,test,context,get,test,instance,catch,invocation,target,exception,ex,logger,error,exception,encountered,while,executing,before,transaction,methods,for,test,context,test,context,ex,get,target,exception,reflection,utils,rethrow,exception,ex,get,target,exception
TransactionalTestExecutionListener -> protected void runBeforeTransactionMethods(TestContext testContext) throws Exception;1432856630;Run all {@link BeforeTransaction @BeforeTransaction} methods for the_specified {@link TestContext test context}. If one of the methods fails,_however, the caught exception will be rethrown in a wrapped_{@link RuntimeException}, and the remaining methods will <strong>not</strong>_be given a chance to execute._@param testContext the current test context;protected void runBeforeTransactionMethods(TestContext testContext) throws Exception {_		try {_			List<Method> methods = getAnnotatedMethods(testContext.getTestClass(), BeforeTransaction.class)__			Collections.reverse(methods)__			for (Method method : methods) {_				if (logger.isDebugEnabled()) {_					logger.debug("Executing @BeforeTransaction method [" + method + "] for test context " + testContext)__				}_				method.invoke(testContext.getTestInstance())__			}_		}_		catch (InvocationTargetException ex) {_			logger.error("Exception encountered while executing @BeforeTransaction methods for test context "_					+ testContext + ".", ex.getTargetException())__			ReflectionUtils.rethrowException(ex.getTargetException())__		}_	};run,all,link,before,transaction,before,transaction,methods,for,the,specified,link,test,context,test,context,if,one,of,the,methods,fails,however,the,caught,exception,will,be,rethrown,in,a,wrapped,link,runtime,exception,and,the,remaining,methods,will,strong,not,strong,be,given,a,chance,to,execute,param,test,context,the,current,test,context;protected,void,run,before,transaction,methods,test,context,test,context,throws,exception,try,list,method,methods,get,annotated,methods,test,context,get,test,class,before,transaction,class,collections,reverse,methods,for,method,method,methods,if,logger,is,debug,enabled,logger,debug,executing,before,transaction,method,method,for,test,context,test,context,method,invoke,test,context,get,test,instance,catch,invocation,target,exception,ex,logger,error,exception,encountered,while,executing,before,transaction,methods,for,test,context,test,context,ex,get,target,exception,reflection,utils,rethrow,exception,ex,get,target,exception
TransactionalTestExecutionListener -> protected void runBeforeTransactionMethods(TestContext testContext) throws Exception;1434234880;Run all {@link BeforeTransaction @BeforeTransaction} methods for the_specified {@link TestContext test context}. If one of the methods fails,_however, the caught exception will be rethrown in a wrapped_{@link RuntimeException}, and the remaining methods will <strong>not</strong>_be given a chance to execute._@param testContext the current test context;protected void runBeforeTransactionMethods(TestContext testContext) throws Exception {_		try {_			List<Method> methods = getAnnotatedMethods(testContext.getTestClass(), BeforeTransaction.class)__			Collections.reverse(methods)__			for (Method method : methods) {_				if (logger.isDebugEnabled()) {_					logger.debug("Executing @BeforeTransaction method [" + method + "] for test context " + testContext)__				}_				method.invoke(testContext.getTestInstance())__			}_		}_		catch (InvocationTargetException ex) {_			logger.error("Exception encountered while executing @BeforeTransaction methods for test context "_					+ testContext + ".", ex.getTargetException())__			ReflectionUtils.rethrowException(ex.getTargetException())__		}_	};run,all,link,before,transaction,before,transaction,methods,for,the,specified,link,test,context,test,context,if,one,of,the,methods,fails,however,the,caught,exception,will,be,rethrown,in,a,wrapped,link,runtime,exception,and,the,remaining,methods,will,strong,not,strong,be,given,a,chance,to,execute,param,test,context,the,current,test,context;protected,void,run,before,transaction,methods,test,context,test,context,throws,exception,try,list,method,methods,get,annotated,methods,test,context,get,test,class,before,transaction,class,collections,reverse,methods,for,method,method,methods,if,logger,is,debug,enabled,logger,debug,executing,before,transaction,method,method,for,test,context,test,context,method,invoke,test,context,get,test,instance,catch,invocation,target,exception,ex,logger,error,exception,encountered,while,executing,before,transaction,methods,for,test,context,test,context,ex,get,target,exception,reflection,utils,rethrow,exception,ex,get,target,exception
TransactionalTestExecutionListener -> protected void runBeforeTransactionMethods(TestContext testContext) throws Exception;1434720443;Run all {@link BeforeTransaction @BeforeTransaction} methods for the_specified {@link TestContext test context}. If one of the methods fails,_however, the caught exception will be rethrown in a wrapped_{@link RuntimeException}, and the remaining methods will <strong>not</strong>_be given a chance to execute._@param testContext the current test context;protected void runBeforeTransactionMethods(TestContext testContext) throws Exception {_		try {_			List<Method> methods = getAnnotatedMethods(testContext.getTestClass(), BeforeTransaction.class)__			Collections.reverse(methods)__			for (Method method : methods) {_				if (logger.isDebugEnabled()) {_					logger.debug("Executing @BeforeTransaction method [" + method + "] for test context " + testContext)__				}_				method.invoke(testContext.getTestInstance())__			}_		}_		catch (InvocationTargetException ex) {_			logger.error("Exception encountered while executing @BeforeTransaction methods for test context "_					+ testContext + ".", ex.getTargetException())__			ReflectionUtils.rethrowException(ex.getTargetException())__		}_	};run,all,link,before,transaction,before,transaction,methods,for,the,specified,link,test,context,test,context,if,one,of,the,methods,fails,however,the,caught,exception,will,be,rethrown,in,a,wrapped,link,runtime,exception,and,the,remaining,methods,will,strong,not,strong,be,given,a,chance,to,execute,param,test,context,the,current,test,context;protected,void,run,before,transaction,methods,test,context,test,context,throws,exception,try,list,method,methods,get,annotated,methods,test,context,get,test,class,before,transaction,class,collections,reverse,methods,for,method,method,methods,if,logger,is,debug,enabled,logger,debug,executing,before,transaction,method,method,for,test,context,test,context,method,invoke,test,context,get,test,instance,catch,invocation,target,exception,ex,logger,error,exception,encountered,while,executing,before,transaction,methods,for,test,context,test,context,ex,get,target,exception,reflection,utils,rethrow,exception,ex,get,target,exception
TransactionalTestExecutionListener -> protected void runBeforeTransactionMethods(TestContext testContext) throws Exception;1434817656;Run all {@link BeforeTransaction @BeforeTransaction} methods for the_specified {@link TestContext test context}. If one of the methods fails,_however, the caught exception will be rethrown in a wrapped_{@link RuntimeException}, and the remaining methods will <strong>not</strong>_be given a chance to execute._@param testContext the current test context;protected void runBeforeTransactionMethods(TestContext testContext) throws Exception {_		try {_			List<Method> methods = getAnnotatedMethods(testContext.getTestClass(), BeforeTransaction.class)__			Collections.reverse(methods)__			for (Method method : methods) {_				if (logger.isDebugEnabled()) {_					logger.debug("Executing @BeforeTransaction method [" + method + "] for test context " + testContext)__				}_				method.invoke(testContext.getTestInstance())__			}_		}_		catch (InvocationTargetException ex) {_			logger.error("Exception encountered while executing @BeforeTransaction methods for test context "_					+ testContext + ".", ex.getTargetException())__			ReflectionUtils.rethrowException(ex.getTargetException())__		}_	};run,all,link,before,transaction,before,transaction,methods,for,the,specified,link,test,context,test,context,if,one,of,the,methods,fails,however,the,caught,exception,will,be,rethrown,in,a,wrapped,link,runtime,exception,and,the,remaining,methods,will,strong,not,strong,be,given,a,chance,to,execute,param,test,context,the,current,test,context;protected,void,run,before,transaction,methods,test,context,test,context,throws,exception,try,list,method,methods,get,annotated,methods,test,context,get,test,class,before,transaction,class,collections,reverse,methods,for,method,method,methods,if,logger,is,debug,enabled,logger,debug,executing,before,transaction,method,method,for,test,context,test,context,method,invoke,test,context,get,test,instance,catch,invocation,target,exception,ex,logger,error,exception,encountered,while,executing,before,transaction,methods,for,test,context,test,context,ex,get,target,exception,reflection,utils,rethrow,exception,ex,get,target,exception
TransactionalTestExecutionListener -> protected void runBeforeTransactionMethods(TestContext testContext) throws Exception;1437841346;Run all {@link BeforeTransaction @BeforeTransaction} methods for the_specified {@linkplain TestContext test context}. If one of the methods_fails, however, the caught exception will be rethrown in a wrapped_{@link RuntimeException}, and the remaining methods will <strong>not</strong>_be given a chance to execute._@param testContext the current test context;protected void runBeforeTransactionMethods(TestContext testContext) throws Exception {_		try {_			List<Method> methods = getAnnotatedMethods(testContext.getTestClass(), BeforeTransaction.class)__			Collections.reverse(methods)__			for (Method method : methods) {_				if (logger.isDebugEnabled()) {_					logger.debug("Executing @BeforeTransaction method [" + method + "] for test context " + testContext)__				}_				method.invoke(testContext.getTestInstance())__			}_		}_		catch (InvocationTargetException ex) {_			logger.error("Exception encountered while executing @BeforeTransaction methods for test context "_					+ testContext + ".", ex.getTargetException())__			ReflectionUtils.rethrowException(ex.getTargetException())__		}_	};run,all,link,before,transaction,before,transaction,methods,for,the,specified,linkplain,test,context,test,context,if,one,of,the,methods,fails,however,the,caught,exception,will,be,rethrown,in,a,wrapped,link,runtime,exception,and,the,remaining,methods,will,strong,not,strong,be,given,a,chance,to,execute,param,test,context,the,current,test,context;protected,void,run,before,transaction,methods,test,context,test,context,throws,exception,try,list,method,methods,get,annotated,methods,test,context,get,test,class,before,transaction,class,collections,reverse,methods,for,method,method,methods,if,logger,is,debug,enabled,logger,debug,executing,before,transaction,method,method,for,test,context,test,context,method,invoke,test,context,get,test,instance,catch,invocation,target,exception,ex,logger,error,exception,encountered,while,executing,before,transaction,methods,for,test,context,test,context,ex,get,target,exception,reflection,utils,rethrow,exception,ex,get,target,exception
TransactionalTestExecutionListener -> protected void runBeforeTransactionMethods(TestContext testContext) throws Exception;1437851372;Run all {@link BeforeTransaction @BeforeTransaction} methods for the_specified {@linkplain TestContext test context}. If one of the methods_fails, however, the caught exception will be rethrown in a wrapped_{@link RuntimeException}, and the remaining methods will <strong>not</strong>_be given a chance to execute._@param testContext the current test context;protected void runBeforeTransactionMethods(TestContext testContext) throws Exception {_		try {_			List<Method> methods = getAnnotatedMethods(testContext.getTestClass(), BeforeTransaction.class)__			Collections.reverse(methods)__			for (Method method : methods) {_				if (logger.isDebugEnabled()) {_					logger.debug("Executing @BeforeTransaction method [" + method + "] for test context " + testContext)__				}_				method.invoke(testContext.getTestInstance())__			}_		}_		catch (InvocationTargetException ex) {_			logger.error("Exception encountered while executing @BeforeTransaction methods for test context "_					+ testContext + ".", ex.getTargetException())__			ReflectionUtils.rethrowException(ex.getTargetException())__		}_	};run,all,link,before,transaction,before,transaction,methods,for,the,specified,linkplain,test,context,test,context,if,one,of,the,methods,fails,however,the,caught,exception,will,be,rethrown,in,a,wrapped,link,runtime,exception,and,the,remaining,methods,will,strong,not,strong,be,given,a,chance,to,execute,param,test,context,the,current,test,context;protected,void,run,before,transaction,methods,test,context,test,context,throws,exception,try,list,method,methods,get,annotated,methods,test,context,get,test,class,before,transaction,class,collections,reverse,methods,for,method,method,methods,if,logger,is,debug,enabled,logger,debug,executing,before,transaction,method,method,for,test,context,test,context,method,invoke,test,context,get,test,instance,catch,invocation,target,exception,ex,logger,error,exception,encountered,while,executing,before,transaction,methods,for,test,context,test,context,ex,get,target,exception,reflection,utils,rethrow,exception,ex,get,target,exception
TransactionalTestExecutionListener -> protected void runBeforeTransactionMethods(TestContext testContext) throws Exception;1437852597;Run all {@link BeforeTransaction @BeforeTransaction} methods for the_specified {@linkplain TestContext test context}. If one of the methods_fails, however, the caught exception will be rethrown in a wrapped_{@link RuntimeException}, and the remaining methods will <strong>not</strong>_be given a chance to execute._@param testContext the current test context;protected void runBeforeTransactionMethods(TestContext testContext) throws Exception {_		try {_			List<Method> methods = getAnnotatedMethods(testContext.getTestClass(), BeforeTransaction.class)__			Collections.reverse(methods)__			for (Method method : methods) {_				if (logger.isDebugEnabled()) {_					logger.debug("Executing @BeforeTransaction method [" + method + "] for test context " + testContext)__				}_				method.invoke(testContext.getTestInstance())__			}_		}_		catch (InvocationTargetException ex) {_			logger.error("Exception encountered while executing @BeforeTransaction methods for test context "_					+ testContext + ".", ex.getTargetException())__			ReflectionUtils.rethrowException(ex.getTargetException())__		}_	};run,all,link,before,transaction,before,transaction,methods,for,the,specified,linkplain,test,context,test,context,if,one,of,the,methods,fails,however,the,caught,exception,will,be,rethrown,in,a,wrapped,link,runtime,exception,and,the,remaining,methods,will,strong,not,strong,be,given,a,chance,to,execute,param,test,context,the,current,test,context;protected,void,run,before,transaction,methods,test,context,test,context,throws,exception,try,list,method,methods,get,annotated,methods,test,context,get,test,class,before,transaction,class,collections,reverse,methods,for,method,method,methods,if,logger,is,debug,enabled,logger,debug,executing,before,transaction,method,method,for,test,context,test,context,method,invoke,test,context,get,test,instance,catch,invocation,target,exception,ex,logger,error,exception,encountered,while,executing,before,transaction,methods,for,test,context,test,context,ex,get,target,exception,reflection,utils,rethrow,exception,ex,get,target,exception
TransactionalTestExecutionListener -> protected void runBeforeTransactionMethods(TestContext testContext) throws Exception;1454507787;Run all {@link BeforeTransaction @BeforeTransaction} methods for the_specified {@linkplain TestContext test context}. If one of the methods_fails, however, the caught exception will be rethrown in a wrapped_{@link RuntimeException}, and the remaining methods will <strong>not</strong>_be given a chance to execute._@param testContext the current test context;protected void runBeforeTransactionMethods(TestContext testContext) throws Exception {_		try {_			List<Method> methods = getAnnotatedMethods(testContext.getTestClass(), BeforeTransaction.class)__			Collections.reverse(methods)__			for (Method method : methods) {_				if (logger.isDebugEnabled()) {_					logger.debug("Executing @BeforeTransaction method [" + method + "] for test context " + testContext)__				}_				method.invoke(testContext.getTestInstance())__			}_		}_		catch (InvocationTargetException ex) {_			logger.error("Exception encountered while executing @BeforeTransaction methods for test context "_					+ testContext + ".", ex.getTargetException())__			ReflectionUtils.rethrowException(ex.getTargetException())__		}_	};run,all,link,before,transaction,before,transaction,methods,for,the,specified,linkplain,test,context,test,context,if,one,of,the,methods,fails,however,the,caught,exception,will,be,rethrown,in,a,wrapped,link,runtime,exception,and,the,remaining,methods,will,strong,not,strong,be,given,a,chance,to,execute,param,test,context,the,current,test,context;protected,void,run,before,transaction,methods,test,context,test,context,throws,exception,try,list,method,methods,get,annotated,methods,test,context,get,test,class,before,transaction,class,collections,reverse,methods,for,method,method,methods,if,logger,is,debug,enabled,logger,debug,executing,before,transaction,method,method,for,test,context,test,context,method,invoke,test,context,get,test,instance,catch,invocation,target,exception,ex,logger,error,exception,encountered,while,executing,before,transaction,methods,for,test,context,test,context,ex,get,target,exception,reflection,utils,rethrow,exception,ex,get,target,exception
TransactionalTestExecutionListener -> protected void runBeforeTransactionMethods(TestContext testContext) throws Exception;1456702967;Run all {@link BeforeTransaction @BeforeTransaction} methods for the_specified {@linkplain TestContext test context}. If one of the methods_fails, however, the caught exception will be rethrown in a wrapped_{@link RuntimeException}, and the remaining methods will <strong>not</strong>_be given a chance to execute._@param testContext the current test context;protected void runBeforeTransactionMethods(TestContext testContext) throws Exception {_		try {_			List<Method> methods = getAnnotatedMethods(testContext.getTestClass(), BeforeTransaction.class)__			Collections.reverse(methods)__			for (Method method : methods) {_				if (logger.isDebugEnabled()) {_					logger.debug("Executing @BeforeTransaction method [" + method + "] for test context " + testContext)__				}_				ReflectionUtils.makeAccessible(method)__				method.invoke(testContext.getTestInstance())__			}_		}_		catch (InvocationTargetException ex) {_			logger.error("Exception encountered while executing @BeforeTransaction methods for test context "_					+ testContext + ".", ex.getTargetException())__			ReflectionUtils.rethrowException(ex.getTargetException())__		}_	};run,all,link,before,transaction,before,transaction,methods,for,the,specified,linkplain,test,context,test,context,if,one,of,the,methods,fails,however,the,caught,exception,will,be,rethrown,in,a,wrapped,link,runtime,exception,and,the,remaining,methods,will,strong,not,strong,be,given,a,chance,to,execute,param,test,context,the,current,test,context;protected,void,run,before,transaction,methods,test,context,test,context,throws,exception,try,list,method,methods,get,annotated,methods,test,context,get,test,class,before,transaction,class,collections,reverse,methods,for,method,method,methods,if,logger,is,debug,enabled,logger,debug,executing,before,transaction,method,method,for,test,context,test,context,reflection,utils,make,accessible,method,method,invoke,test,context,get,test,instance,catch,invocation,target,exception,ex,logger,error,exception,encountered,while,executing,before,transaction,methods,for,test,context,test,context,ex,get,target,exception,reflection,utils,rethrow,exception,ex,get,target,exception
TransactionalTestExecutionListener -> protected void runBeforeTransactionMethods(TestContext testContext) throws Exception;1456756222;Run all {@link BeforeTransaction @BeforeTransaction} methods for the_specified {@linkplain TestContext test context}. If one of the methods_fails, however, the caught exception will be rethrown in a wrapped_{@link RuntimeException}, and the remaining methods will <strong>not</strong>_be given a chance to execute._@param testContext the current test context;protected void runBeforeTransactionMethods(TestContext testContext) throws Exception {_		try {_			List<Method> methods = getAnnotatedMethods(testContext.getTestClass(), BeforeTransaction.class)__			Collections.reverse(methods)__			for (Method method : methods) {_				if (logger.isDebugEnabled()) {_					logger.debug("Executing @BeforeTransaction method [" + method + "] for test context " + testContext)__				}_				ReflectionUtils.makeAccessible(method)__				method.invoke(testContext.getTestInstance())__			}_		}_		catch (InvocationTargetException ex) {_			logger.error("Exception encountered while executing @BeforeTransaction methods for test context "_					+ testContext + ".", ex.getTargetException())__			ReflectionUtils.rethrowException(ex.getTargetException())__		}_	};run,all,link,before,transaction,before,transaction,methods,for,the,specified,linkplain,test,context,test,context,if,one,of,the,methods,fails,however,the,caught,exception,will,be,rethrown,in,a,wrapped,link,runtime,exception,and,the,remaining,methods,will,strong,not,strong,be,given,a,chance,to,execute,param,test,context,the,current,test,context;protected,void,run,before,transaction,methods,test,context,test,context,throws,exception,try,list,method,methods,get,annotated,methods,test,context,get,test,class,before,transaction,class,collections,reverse,methods,for,method,method,methods,if,logger,is,debug,enabled,logger,debug,executing,before,transaction,method,method,for,test,context,test,context,reflection,utils,make,accessible,method,method,invoke,test,context,get,test,instance,catch,invocation,target,exception,ex,logger,error,exception,encountered,while,executing,before,transaction,methods,for,test,context,test,context,ex,get,target,exception,reflection,utils,rethrow,exception,ex,get,target,exception
TransactionalTestExecutionListener -> protected void runBeforeTransactionMethods(TestContext testContext) throws Exception;1456756222;Run all {@link BeforeTransaction @BeforeTransaction} methods for the_specified {@linkplain TestContext test context}. If one of the methods_fails, however, the caught exception will be rethrown in a wrapped_{@link RuntimeException}, and the remaining methods will <strong>not</strong>_be given a chance to execute._@param testContext the current test context;protected void runBeforeTransactionMethods(TestContext testContext) throws Exception {_		try {_			List<Method> methods = getAnnotatedMethods(testContext.getTestClass(), BeforeTransaction.class)__			Collections.reverse(methods)__			for (Method method : methods) {_				if (logger.isDebugEnabled()) {_					logger.debug("Executing @BeforeTransaction method [" + method + "] for test context " + testContext)__				}_				ReflectionUtils.makeAccessible(method)__				method.invoke(testContext.getTestInstance())__			}_		}_		catch (InvocationTargetException ex) {_			logger.error("Exception encountered while executing @BeforeTransaction methods for test context "_					+ testContext + ".", ex.getTargetException())__			ReflectionUtils.rethrowException(ex.getTargetException())__		}_	};run,all,link,before,transaction,before,transaction,methods,for,the,specified,linkplain,test,context,test,context,if,one,of,the,methods,fails,however,the,caught,exception,will,be,rethrown,in,a,wrapped,link,runtime,exception,and,the,remaining,methods,will,strong,not,strong,be,given,a,chance,to,execute,param,test,context,the,current,test,context;protected,void,run,before,transaction,methods,test,context,test,context,throws,exception,try,list,method,methods,get,annotated,methods,test,context,get,test,class,before,transaction,class,collections,reverse,methods,for,method,method,methods,if,logger,is,debug,enabled,logger,debug,executing,before,transaction,method,method,for,test,context,test,context,reflection,utils,make,accessible,method,method,invoke,test,context,get,test,instance,catch,invocation,target,exception,ex,logger,error,exception,encountered,while,executing,before,transaction,methods,for,test,context,test,context,ex,get,target,exception,reflection,utils,rethrow,exception,ex,get,target,exception
TransactionalTestExecutionListener -> protected void runBeforeTransactionMethods(TestContext testContext) throws Exception;1458754760;Run all {@link BeforeTransaction @BeforeTransaction} methods for the_specified {@linkplain TestContext test context}. If one of the methods_fails, however, the caught exception will be rethrown in a wrapped_{@link RuntimeException}, and the remaining methods will <strong>not</strong>_be given a chance to execute._@param testContext the current test context;protected void runBeforeTransactionMethods(TestContext testContext) throws Exception {_		try {_			List<Method> methods = getAnnotatedMethods(testContext.getTestClass(), BeforeTransaction.class)__			Collections.reverse(methods)__			for (Method method : methods) {_				if (logger.isDebugEnabled()) {_					logger.debug("Executing @BeforeTransaction method [" + method + "] for test context " + testContext)__				}_				ReflectionUtils.makeAccessible(method)__				method.invoke(testContext.getTestInstance())__			}_		}_		catch (InvocationTargetException ex) {_			if (logger.isErrorEnabled()) {_				logger.error("Exception encountered while executing @BeforeTransaction methods for test context " +_						testContext + ".", ex.getTargetException())__			}_			ReflectionUtils.rethrowException(ex.getTargetException())__		}_	};run,all,link,before,transaction,before,transaction,methods,for,the,specified,linkplain,test,context,test,context,if,one,of,the,methods,fails,however,the,caught,exception,will,be,rethrown,in,a,wrapped,link,runtime,exception,and,the,remaining,methods,will,strong,not,strong,be,given,a,chance,to,execute,param,test,context,the,current,test,context;protected,void,run,before,transaction,methods,test,context,test,context,throws,exception,try,list,method,methods,get,annotated,methods,test,context,get,test,class,before,transaction,class,collections,reverse,methods,for,method,method,methods,if,logger,is,debug,enabled,logger,debug,executing,before,transaction,method,method,for,test,context,test,context,reflection,utils,make,accessible,method,method,invoke,test,context,get,test,instance,catch,invocation,target,exception,ex,if,logger,is,error,enabled,logger,error,exception,encountered,while,executing,before,transaction,methods,for,test,context,test,context,ex,get,target,exception,reflection,utils,rethrow,exception,ex,get,target,exception
TransactionalTestExecutionListener -> protected void runBeforeTransactionMethods(TestContext testContext) throws Exception;1462294651;Run all {@link BeforeTransaction @BeforeTransaction} methods for the_specified {@linkplain TestContext test context}. If one of the methods_fails, however, the caught exception will be rethrown in a wrapped_{@link RuntimeException}, and the remaining methods will <strong>not</strong>_be given a chance to execute._@param testContext the current test context;protected void runBeforeTransactionMethods(TestContext testContext) throws Exception {_		try {_			List<Method> methods = getAnnotatedMethods(testContext.getTestClass(), BeforeTransaction.class)__			Collections.reverse(methods)__			for (Method method : methods) {_				if (logger.isDebugEnabled()) {_					logger.debug("Executing @BeforeTransaction method [" + method + "] for test context " + testContext)__				}_				ReflectionUtils.makeAccessible(method)__				method.invoke(testContext.getTestInstance())__			}_		}_		catch (InvocationTargetException ex) {_			if (logger.isErrorEnabled()) {_				logger.error("Exception encountered while executing @BeforeTransaction methods for test context " +_						testContext + ".", ex.getTargetException())__			}_			ReflectionUtils.rethrowException(ex.getTargetException())__		}_	};run,all,link,before,transaction,before,transaction,methods,for,the,specified,linkplain,test,context,test,context,if,one,of,the,methods,fails,however,the,caught,exception,will,be,rethrown,in,a,wrapped,link,runtime,exception,and,the,remaining,methods,will,strong,not,strong,be,given,a,chance,to,execute,param,test,context,the,current,test,context;protected,void,run,before,transaction,methods,test,context,test,context,throws,exception,try,list,method,methods,get,annotated,methods,test,context,get,test,class,before,transaction,class,collections,reverse,methods,for,method,method,methods,if,logger,is,debug,enabled,logger,debug,executing,before,transaction,method,method,for,test,context,test,context,reflection,utils,make,accessible,method,method,invoke,test,context,get,test,instance,catch,invocation,target,exception,ex,if,logger,is,error,enabled,logger,error,exception,encountered,while,executing,before,transaction,methods,for,test,context,test,context,ex,get,target,exception,reflection,utils,rethrow,exception,ex,get,target,exception
TransactionalTestExecutionListener -> protected void runBeforeTransactionMethods(TestContext testContext) throws Exception;1462299971;Run all {@link BeforeTransaction @BeforeTransaction} methods for the_specified {@linkplain TestContext test context}. If one of the methods_fails, however, the caught exception will be rethrown in a wrapped_{@link RuntimeException}, and the remaining methods will <strong>not</strong>_be given a chance to execute._@param testContext the current test context;protected void runBeforeTransactionMethods(TestContext testContext) throws Exception {_		try {_			List<Method> methods = getAnnotatedMethods(testContext.getTestClass(), BeforeTransaction.class)__			Collections.reverse(methods)__			for (Method method : methods) {_				if (logger.isDebugEnabled()) {_					logger.debug("Executing @BeforeTransaction method [" + method + "] for test context " + testContext)__				}_				ReflectionUtils.makeAccessible(method)__				method.invoke(testContext.getTestInstance())__			}_		}_		catch (InvocationTargetException ex) {_			if (logger.isErrorEnabled()) {_				logger.error("Exception encountered while executing @BeforeTransaction methods for test context " +_						testContext + ".", ex.getTargetException())__			}_			ReflectionUtils.rethrowException(ex.getTargetException())__		}_	};run,all,link,before,transaction,before,transaction,methods,for,the,specified,linkplain,test,context,test,context,if,one,of,the,methods,fails,however,the,caught,exception,will,be,rethrown,in,a,wrapped,link,runtime,exception,and,the,remaining,methods,will,strong,not,strong,be,given,a,chance,to,execute,param,test,context,the,current,test,context;protected,void,run,before,transaction,methods,test,context,test,context,throws,exception,try,list,method,methods,get,annotated,methods,test,context,get,test,class,before,transaction,class,collections,reverse,methods,for,method,method,methods,if,logger,is,debug,enabled,logger,debug,executing,before,transaction,method,method,for,test,context,test,context,reflection,utils,make,accessible,method,method,invoke,test,context,get,test,instance,catch,invocation,target,exception,ex,if,logger,is,error,enabled,logger,error,exception,encountered,while,executing,before,transaction,methods,for,test,context,test,context,ex,get,target,exception,reflection,utils,rethrow,exception,ex,get,target,exception
TransactionalTestExecutionListener -> protected void runBeforeTransactionMethods(TestContext testContext) throws Exception;1467730834;Run all {@link BeforeTransaction @BeforeTransaction} methods for the_specified {@linkplain TestContext test context}. If one of the methods_fails, however, the caught exception will be rethrown in a wrapped_{@link RuntimeException}, and the remaining methods will <strong>not</strong>_be given a chance to execute._@param testContext the current test context;protected void runBeforeTransactionMethods(TestContext testContext) throws Exception {_		try {_			List<Method> methods = getAnnotatedMethods(testContext.getTestClass(), BeforeTransaction.class)__			Collections.reverse(methods)__			for (Method method : methods) {_				if (logger.isDebugEnabled()) {_					logger.debug("Executing @BeforeTransaction method [" + method + "] for test context " + testContext)__				}_				ReflectionUtils.makeAccessible(method)__				method.invoke(testContext.getTestInstance())__			}_		}_		catch (InvocationTargetException ex) {_			if (logger.isErrorEnabled()) {_				logger.error("Exception encountered while executing @BeforeTransaction methods for test context " +_						testContext + ".", ex.getTargetException())__			}_			ReflectionUtils.rethrowException(ex.getTargetException())__		}_	};run,all,link,before,transaction,before,transaction,methods,for,the,specified,linkplain,test,context,test,context,if,one,of,the,methods,fails,however,the,caught,exception,will,be,rethrown,in,a,wrapped,link,runtime,exception,and,the,remaining,methods,will,strong,not,strong,be,given,a,chance,to,execute,param,test,context,the,current,test,context;protected,void,run,before,transaction,methods,test,context,test,context,throws,exception,try,list,method,methods,get,annotated,methods,test,context,get,test,class,before,transaction,class,collections,reverse,methods,for,method,method,methods,if,logger,is,debug,enabled,logger,debug,executing,before,transaction,method,method,for,test,context,test,context,reflection,utils,make,accessible,method,method,invoke,test,context,get,test,instance,catch,invocation,target,exception,ex,if,logger,is,error,enabled,logger,error,exception,encountered,while,executing,before,transaction,methods,for,test,context,test,context,ex,get,target,exception,reflection,utils,rethrow,exception,ex,get,target,exception
TransactionalTestExecutionListener -> protected void runBeforeTransactionMethods(TestContext testContext) throws Exception;1467992320;Run all {@link BeforeTransaction @BeforeTransaction} methods for the_specified {@linkplain TestContext test context}. If one of the methods_fails, however, the caught exception will be rethrown in a wrapped_{@link RuntimeException}, and the remaining methods will <strong>not</strong>_be given a chance to execute._@param testContext the current test context;protected void runBeforeTransactionMethods(TestContext testContext) throws Exception {_		try {_			List<Method> methods = getAnnotatedMethods(testContext.getTestClass(), BeforeTransaction.class)__			Collections.reverse(methods)__			for (Method method : methods) {_				if (logger.isDebugEnabled()) {_					logger.debug("Executing @BeforeTransaction method [" + method + "] for test context " + testContext)__				}_				ReflectionUtils.makeAccessible(method)__				method.invoke(testContext.getTestInstance())__			}_		}_		catch (InvocationTargetException ex) {_			if (logger.isErrorEnabled()) {_				logger.error("Exception encountered while executing @BeforeTransaction methods for test context " +_						testContext + ".", ex.getTargetException())__			}_			ReflectionUtils.rethrowException(ex.getTargetException())__		}_	};run,all,link,before,transaction,before,transaction,methods,for,the,specified,linkplain,test,context,test,context,if,one,of,the,methods,fails,however,the,caught,exception,will,be,rethrown,in,a,wrapped,link,runtime,exception,and,the,remaining,methods,will,strong,not,strong,be,given,a,chance,to,execute,param,test,context,the,current,test,context;protected,void,run,before,transaction,methods,test,context,test,context,throws,exception,try,list,method,methods,get,annotated,methods,test,context,get,test,class,before,transaction,class,collections,reverse,methods,for,method,method,methods,if,logger,is,debug,enabled,logger,debug,executing,before,transaction,method,method,for,test,context,test,context,reflection,utils,make,accessible,method,method,invoke,test,context,get,test,instance,catch,invocation,target,exception,ex,if,logger,is,error,enabled,logger,error,exception,encountered,while,executing,before,transaction,methods,for,test,context,test,context,ex,get,target,exception,reflection,utils,rethrow,exception,ex,get,target,exception
TransactionalTestExecutionListener -> protected void runBeforeTransactionMethods(TestContext testContext) throws Exception;1467992442;Run all {@link BeforeTransaction @BeforeTransaction} methods for the_specified {@linkplain TestContext test context}. If one of the methods_fails, however, the caught exception will be rethrown in a wrapped_{@link RuntimeException}, and the remaining methods will <strong>not</strong>_be given a chance to execute._@param testContext the current test context;protected void runBeforeTransactionMethods(TestContext testContext) throws Exception {_		try {_			List<Method> methods = getAnnotatedMethods(testContext.getTestClass(), BeforeTransaction.class)__			Collections.reverse(methods)__			for (Method method : methods) {_				if (logger.isDebugEnabled()) {_					logger.debug("Executing @BeforeTransaction method [" + method + "] for test context " + testContext)__				}_				ReflectionUtils.makeAccessible(method)__				method.invoke(testContext.getTestInstance())__			}_		}_		catch (InvocationTargetException ex) {_			if (logger.isErrorEnabled()) {_				logger.error("Exception encountered while executing @BeforeTransaction methods for test context " +_						testContext + ".", ex.getTargetException())__			}_			ReflectionUtils.rethrowException(ex.getTargetException())__		}_	};run,all,link,before,transaction,before,transaction,methods,for,the,specified,linkplain,test,context,test,context,if,one,of,the,methods,fails,however,the,caught,exception,will,be,rethrown,in,a,wrapped,link,runtime,exception,and,the,remaining,methods,will,strong,not,strong,be,given,a,chance,to,execute,param,test,context,the,current,test,context;protected,void,run,before,transaction,methods,test,context,test,context,throws,exception,try,list,method,methods,get,annotated,methods,test,context,get,test,class,before,transaction,class,collections,reverse,methods,for,method,method,methods,if,logger,is,debug,enabled,logger,debug,executing,before,transaction,method,method,for,test,context,test,context,reflection,utils,make,accessible,method,method,invoke,test,context,get,test,instance,catch,invocation,target,exception,ex,if,logger,is,error,enabled,logger,error,exception,encountered,while,executing,before,transaction,methods,for,test,context,test,context,ex,get,target,exception,reflection,utils,rethrow,exception,ex,get,target,exception
TransactionalTestExecutionListener -> protected void runBeforeTransactionMethods(TestContext testContext) throws Exception;1467994604;Run all {@link BeforeTransaction @BeforeTransaction} methods for the_specified {@linkplain TestContext test context}. If one of the methods_fails, however, the caught exception will be rethrown in a wrapped_{@link RuntimeException}, and the remaining methods will <strong>not</strong>_be given a chance to execute._@param testContext the current test context;protected void runBeforeTransactionMethods(TestContext testContext) throws Exception {_		try {_			List<Method> methods = getAnnotatedMethods(testContext.getTestClass(), BeforeTransaction.class)__			Collections.reverse(methods)__			for (Method method : methods) {_				if (logger.isDebugEnabled()) {_					logger.debug("Executing @BeforeTransaction method [" + method + "] for test context " + testContext)__				}_				ReflectionUtils.makeAccessible(method)__				method.invoke(testContext.getTestInstance())__			}_		}_		catch (InvocationTargetException ex) {_			if (logger.isErrorEnabled()) {_				logger.error("Exception encountered while executing @BeforeTransaction methods for test context " +_						testContext + ".", ex.getTargetException())__			}_			ReflectionUtils.rethrowException(ex.getTargetException())__		}_	};run,all,link,before,transaction,before,transaction,methods,for,the,specified,linkplain,test,context,test,context,if,one,of,the,methods,fails,however,the,caught,exception,will,be,rethrown,in,a,wrapped,link,runtime,exception,and,the,remaining,methods,will,strong,not,strong,be,given,a,chance,to,execute,param,test,context,the,current,test,context;protected,void,run,before,transaction,methods,test,context,test,context,throws,exception,try,list,method,methods,get,annotated,methods,test,context,get,test,class,before,transaction,class,collections,reverse,methods,for,method,method,methods,if,logger,is,debug,enabled,logger,debug,executing,before,transaction,method,method,for,test,context,test,context,reflection,utils,make,accessible,method,method,invoke,test,context,get,test,instance,catch,invocation,target,exception,ex,if,logger,is,error,enabled,logger,error,exception,encountered,while,executing,before,transaction,methods,for,test,context,test,context,ex,get,target,exception,reflection,utils,rethrow,exception,ex,get,target,exception
TransactionalTestExecutionListener -> protected void runBeforeTransactionMethods(TestContext testContext) throws Exception;1468334463;Run all {@link BeforeTransaction @BeforeTransaction} methods for the_specified {@linkplain TestContext test context}. If one of the methods_fails, however, the caught exception will be rethrown in a wrapped_{@link RuntimeException}, and the remaining methods will <strong>not</strong>_be given a chance to execute._@param testContext the current test context;protected void runBeforeTransactionMethods(TestContext testContext) throws Exception {_		try {_			List<Method> methods = getAnnotatedMethods(testContext.getTestClass(), BeforeTransaction.class)__			Collections.reverse(methods)__			for (Method method : methods) {_				if (logger.isDebugEnabled()) {_					logger.debug("Executing @BeforeTransaction method [" + method + "] for test context " + testContext)__				}_				ReflectionUtils.makeAccessible(method)__				method.invoke(testContext.getTestInstance())__			}_		}_		catch (InvocationTargetException ex) {_			if (logger.isErrorEnabled()) {_				logger.error("Exception encountered while executing @BeforeTransaction methods for test context " +_						testContext + ".", ex.getTargetException())__			}_			ReflectionUtils.rethrowException(ex.getTargetException())__		}_	};run,all,link,before,transaction,before,transaction,methods,for,the,specified,linkplain,test,context,test,context,if,one,of,the,methods,fails,however,the,caught,exception,will,be,rethrown,in,a,wrapped,link,runtime,exception,and,the,remaining,methods,will,strong,not,strong,be,given,a,chance,to,execute,param,test,context,the,current,test,context;protected,void,run,before,transaction,methods,test,context,test,context,throws,exception,try,list,method,methods,get,annotated,methods,test,context,get,test,class,before,transaction,class,collections,reverse,methods,for,method,method,methods,if,logger,is,debug,enabled,logger,debug,executing,before,transaction,method,method,for,test,context,test,context,reflection,utils,make,accessible,method,method,invoke,test,context,get,test,instance,catch,invocation,target,exception,ex,if,logger,is,error,enabled,logger,error,exception,encountered,while,executing,before,transaction,methods,for,test,context,test,context,ex,get,target,exception,reflection,utils,rethrow,exception,ex,get,target,exception
TransactionalTestExecutionListener -> protected void runBeforeTransactionMethods(TestContext testContext) throws Exception;1496955179;Run all {@link BeforeTransaction @BeforeTransaction} methods for the_specified {@linkplain TestContext test context}. If one of the methods_fails, however, the caught exception will be rethrown in a wrapped_{@link RuntimeException}, and the remaining methods will <strong>not</strong>_be given a chance to execute._@param testContext the current test context;protected void runBeforeTransactionMethods(TestContext testContext) throws Exception {_		try {_			List<Method> methods = getAnnotatedMethods(testContext.getTestClass(), BeforeTransaction.class)__			Collections.reverse(methods)__			for (Method method : methods) {_				if (logger.isDebugEnabled()) {_					logger.debug("Executing @BeforeTransaction method [" + method + "] for test context " + testContext)__				}_				ReflectionUtils.makeAccessible(method)__				method.invoke(testContext.getTestInstance())__			}_		}_		catch (InvocationTargetException ex) {_			if (logger.isErrorEnabled()) {_				logger.error("Exception encountered while executing @BeforeTransaction methods for test context " +_						testContext + ".", ex.getTargetException())__			}_			ReflectionUtils.rethrowException(ex.getTargetException())__		}_	};run,all,link,before,transaction,before,transaction,methods,for,the,specified,linkplain,test,context,test,context,if,one,of,the,methods,fails,however,the,caught,exception,will,be,rethrown,in,a,wrapped,link,runtime,exception,and,the,remaining,methods,will,strong,not,strong,be,given,a,chance,to,execute,param,test,context,the,current,test,context;protected,void,run,before,transaction,methods,test,context,test,context,throws,exception,try,list,method,methods,get,annotated,methods,test,context,get,test,class,before,transaction,class,collections,reverse,methods,for,method,method,methods,if,logger,is,debug,enabled,logger,debug,executing,before,transaction,method,method,for,test,context,test,context,reflection,utils,make,accessible,method,method,invoke,test,context,get,test,instance,catch,invocation,target,exception,ex,if,logger,is,error,enabled,logger,error,exception,encountered,while,executing,before,transaction,methods,for,test,context,test,context,ex,get,target,exception,reflection,utils,rethrow,exception,ex,get,target,exception
TransactionalTestExecutionListener -> protected void runBeforeTransactionMethods(TestContext testContext) throws Exception;1498780456;Run all {@link BeforeTransaction @BeforeTransaction} methods for the_specified {@linkplain TestContext test context}. If one of the methods_fails, however, the caught exception will be rethrown in a wrapped_{@link RuntimeException}, and the remaining methods will <strong>not</strong>_be given a chance to execute._@param testContext the current test context;protected void runBeforeTransactionMethods(TestContext testContext) throws Exception {_		try {_			List<Method> methods = getAnnotatedMethods(testContext.getTestClass(), BeforeTransaction.class)__			Collections.reverse(methods)__			for (Method method : methods) {_				if (logger.isDebugEnabled()) {_					logger.debug("Executing @BeforeTransaction method [" + method + "] for test context " + testContext)__				}_				ReflectionUtils.makeAccessible(method)__				method.invoke(testContext.getTestInstance())__			}_		}_		catch (InvocationTargetException ex) {_			if (logger.isErrorEnabled()) {_				logger.error("Exception encountered while executing @BeforeTransaction methods for test context " +_						testContext + ".", ex.getTargetException())__			}_			ReflectionUtils.rethrowException(ex.getTargetException())__		}_	};run,all,link,before,transaction,before,transaction,methods,for,the,specified,linkplain,test,context,test,context,if,one,of,the,methods,fails,however,the,caught,exception,will,be,rethrown,in,a,wrapped,link,runtime,exception,and,the,remaining,methods,will,strong,not,strong,be,given,a,chance,to,execute,param,test,context,the,current,test,context;protected,void,run,before,transaction,methods,test,context,test,context,throws,exception,try,list,method,methods,get,annotated,methods,test,context,get,test,class,before,transaction,class,collections,reverse,methods,for,method,method,methods,if,logger,is,debug,enabled,logger,debug,executing,before,transaction,method,method,for,test,context,test,context,reflection,utils,make,accessible,method,method,invoke,test,context,get,test,instance,catch,invocation,target,exception,ex,if,logger,is,error,enabled,logger,error,exception,encountered,while,executing,before,transaction,methods,for,test,context,test,context,ex,get,target,exception,reflection,utils,rethrow,exception,ex,get,target,exception
TransactionalTestExecutionListener -> protected void runBeforeTransactionMethods(TestContext testContext) throws Exception;1520251235;Run all {@link BeforeTransaction @BeforeTransaction} methods for the_specified {@linkplain TestContext test context}. If one of the methods_fails, however, the caught exception will be rethrown in a wrapped_{@link RuntimeException}, and the remaining methods will <strong>not</strong>_be given a chance to execute._@param testContext the current test context;protected void runBeforeTransactionMethods(TestContext testContext) throws Exception {_		try {_			List<Method> methods = getAnnotatedMethods(testContext.getTestClass(), BeforeTransaction.class)__			Collections.reverse(methods)__			for (Method method : methods) {_				if (logger.isDebugEnabled()) {_					logger.debug("Executing @BeforeTransaction method [" + method + "] for test context " + testContext)__				}_				ReflectionUtils.makeAccessible(method)__				method.invoke(testContext.getTestInstance())__			}_		}_		catch (InvocationTargetException ex) {_			if (logger.isErrorEnabled()) {_				logger.error("Exception encountered while executing @BeforeTransaction methods for test context " +_						testContext + ".", ex.getTargetException())__			}_			ReflectionUtils.rethrowException(ex.getTargetException())__		}_	};run,all,link,before,transaction,before,transaction,methods,for,the,specified,linkplain,test,context,test,context,if,one,of,the,methods,fails,however,the,caught,exception,will,be,rethrown,in,a,wrapped,link,runtime,exception,and,the,remaining,methods,will,strong,not,strong,be,given,a,chance,to,execute,param,test,context,the,current,test,context;protected,void,run,before,transaction,methods,test,context,test,context,throws,exception,try,list,method,methods,get,annotated,methods,test,context,get,test,class,before,transaction,class,collections,reverse,methods,for,method,method,methods,if,logger,is,debug,enabled,logger,debug,executing,before,transaction,method,method,for,test,context,test,context,reflection,utils,make,accessible,method,method,invoke,test,context,get,test,instance,catch,invocation,target,exception,ex,if,logger,is,error,enabled,logger,error,exception,encountered,while,executing,before,transaction,methods,for,test,context,test,context,ex,get,target,exception,reflection,utils,rethrow,exception,ex,get,target,exception
TransactionalTestExecutionListener -> private void endTransaction(TestContext testContext, TransactionContext txContext) throws Exception;1328020251;Immediately force a <em>commit</em> or <em>rollback</em> of the_transaction for the supplied {@link TestContext test context}, according_to the commit and rollback flags._@param testContext the current test context_@throws Exception if an error occurs while retrieving the transaction manager;private void endTransaction(TestContext testContext, TransactionContext txContext) throws Exception {_		boolean rollback = isRollback(testContext)__		if (logger.isTraceEnabled()) {_			logger.trace("Ending transaction for test context [" + testContext + "]_ transaction manager ["_					+ txContext.transactionStatus + "]_ rollback [" + rollback + "]")__		}_		txContext.endTransaction(rollback)__		if (logger.isInfoEnabled()) {_			logger.info((rollback ? "Rolled back" : "Committed")_					+ " transaction after test execution for test context [" + testContext + "]")__		}_	};immediately,force,a,em,commit,em,or,em,rollback,em,of,the,transaction,for,the,supplied,link,test,context,test,context,according,to,the,commit,and,rollback,flags,param,test,context,the,current,test,context,throws,exception,if,an,error,occurs,while,retrieving,the,transaction,manager;private,void,end,transaction,test,context,test,context,transaction,context,tx,context,throws,exception,boolean,rollback,is,rollback,test,context,if,logger,is,trace,enabled,logger,trace,ending,transaction,for,test,context,test,context,transaction,manager,tx,context,transaction,status,rollback,rollback,tx,context,end,transaction,rollback,if,logger,is,info,enabled,logger,info,rollback,rolled,back,committed,transaction,after,test,execution,for,test,context,test,context
TransactionalTestExecutionListener -> private void endTransaction(TestContext testContext, TransactionContext txContext) throws Exception;1337516454;Immediately force a <em>commit</em> or <em>rollback</em> of the_transaction for the supplied {@link TestContext test context}, according_to the commit and rollback flags._@param testContext the current test context_@throws Exception if an error occurs while retrieving the transaction manager;private void endTransaction(TestContext testContext, TransactionContext txContext) throws Exception {_		boolean rollback = isRollback(testContext)__		if (logger.isTraceEnabled()) {_			logger.trace("Ending transaction for test context [" + testContext + "]_ transaction manager ["_					+ txContext.transactionStatus + "]_ rollback [" + rollback + "]")__		}_		txContext.endTransaction(rollback)__		if (logger.isInfoEnabled()) {_			logger.info((rollback ? "Rolled back" : "Committed")_					+ " transaction after test execution for test context [" + testContext + "]")__		}_	};immediately,force,a,em,commit,em,or,em,rollback,em,of,the,transaction,for,the,supplied,link,test,context,test,context,according,to,the,commit,and,rollback,flags,param,test,context,the,current,test,context,throws,exception,if,an,error,occurs,while,retrieving,the,transaction,manager;private,void,end,transaction,test,context,test,context,transaction,context,tx,context,throws,exception,boolean,rollback,is,rollback,test,context,if,logger,is,trace,enabled,logger,trace,ending,transaction,for,test,context,test,context,transaction,manager,tx,context,transaction,status,rollback,rollback,tx,context,end,transaction,rollback,if,logger,is,info,enabled,logger,info,rollback,rolled,back,committed,transaction,after,test,execution,for,test,context,test,context
TransactionalTestExecutionListener -> private void endTransaction(TestContext testContext, TransactionContext txContext) throws Exception;1338031377;Immediately force a <em>commit</em> or <em>rollback</em> of the_transaction for the supplied {@link TestContext test context}, according_to the commit and rollback flags._@param testContext the current test context_@throws Exception if an error occurs while retrieving the transaction manager;private void endTransaction(TestContext testContext, TransactionContext txContext) throws Exception {_		boolean rollback = isRollback(testContext)__		if (logger.isTraceEnabled()) {_			logger.trace("Ending transaction for test context [" + testContext + "]_ transaction manager ["_					+ txContext.transactionStatus + "]_ rollback [" + rollback + "]")__		}_		txContext.endTransaction(rollback)__		if (logger.isInfoEnabled()) {_			logger.info((rollback ? "Rolled back" : "Committed")_					+ " transaction after test execution for test context [" + testContext + "]")__		}_	};immediately,force,a,em,commit,em,or,em,rollback,em,of,the,transaction,for,the,supplied,link,test,context,test,context,according,to,the,commit,and,rollback,flags,param,test,context,the,current,test,context,throws,exception,if,an,error,occurs,while,retrieving,the,transaction,manager;private,void,end,transaction,test,context,test,context,transaction,context,tx,context,throws,exception,boolean,rollback,is,rollback,test,context,if,logger,is,trace,enabled,logger,trace,ending,transaction,for,test,context,test,context,transaction,manager,tx,context,transaction,status,rollback,rollback,tx,context,end,transaction,rollback,if,logger,is,info,enabled,logger,info,rollback,rolled,back,committed,transaction,after,test,execution,for,test,context,test,context
TransactionalTestExecutionListener -> private void endTransaction(TestContext testContext, TransactionContext txContext) throws Exception;1343426806;Immediately force a <em>commit</em> or <em>rollback</em> of the_transaction for the supplied {@link TestContext test context}, according_to the commit and rollback flags._@param testContext the current test context_@throws Exception if an error occurs while retrieving the transaction manager;private void endTransaction(TestContext testContext, TransactionContext txContext) throws Exception {_		boolean rollback = isRollback(testContext)__		if (logger.isTraceEnabled()) {_			logger.trace("Ending transaction for test context " + testContext + "_ transaction manager ["_					+ txContext.transactionStatus + "]_ rollback [" + rollback + "]")__		}_		txContext.endTransaction(rollback)__		if (logger.isInfoEnabled()) {_			logger.info((rollback ? "Rolled back" : "Committed")_					+ " transaction after test execution for test context " + testContext)__		}_	};immediately,force,a,em,commit,em,or,em,rollback,em,of,the,transaction,for,the,supplied,link,test,context,test,context,according,to,the,commit,and,rollback,flags,param,test,context,the,current,test,context,throws,exception,if,an,error,occurs,while,retrieving,the,transaction,manager;private,void,end,transaction,test,context,test,context,transaction,context,tx,context,throws,exception,boolean,rollback,is,rollback,test,context,if,logger,is,trace,enabled,logger,trace,ending,transaction,for,test,context,test,context,transaction,manager,tx,context,transaction,status,rollback,rollback,tx,context,end,transaction,rollback,if,logger,is,info,enabled,logger,info,rollback,rolled,back,committed,transaction,after,test,execution,for,test,context,test,context
TransactionalTestExecutionListener -> private void endTransaction(TestContext testContext, TransactionContext txContext) throws Exception;1343431472;Immediately force a <em>commit</em> or <em>rollback</em> of the_transaction for the supplied {@link TestContext test context}, according_to the commit and rollback flags._@param testContext the current test context_@throws Exception if an error occurs while retrieving the transaction manager;private void endTransaction(TestContext testContext, TransactionContext txContext) throws Exception {_		boolean rollback = isRollback(testContext)__		if (logger.isTraceEnabled()) {_			logger.trace("Ending transaction for test context " + testContext + "_ transaction manager ["_					+ txContext.transactionStatus + "]_ rollback [" + rollback + "]")__		}_		txContext.endTransaction(rollback)__		if (logger.isInfoEnabled()) {_			logger.info((rollback ? "Rolled back" : "Committed")_					+ " transaction after test execution for test context " + testContext)__		}_	};immediately,force,a,em,commit,em,or,em,rollback,em,of,the,transaction,for,the,supplied,link,test,context,test,context,according,to,the,commit,and,rollback,flags,param,test,context,the,current,test,context,throws,exception,if,an,error,occurs,while,retrieving,the,transaction,manager;private,void,end,transaction,test,context,test,context,transaction,context,tx,context,throws,exception,boolean,rollback,is,rollback,test,context,if,logger,is,trace,enabled,logger,trace,ending,transaction,for,test,context,test,context,transaction,manager,tx,context,transaction,status,rollback,rollback,tx,context,end,transaction,rollback,if,logger,is,info,enabled,logger,info,rollback,rolled,back,committed,transaction,after,test,execution,for,test,context,test,context
TransactionalTestExecutionListener -> private void endTransaction(TestContext testContext, TransactionContext txContext) throws Exception;1354571539;Immediately force a <em>commit</em> or <em>rollback</em> of the_transaction for the supplied {@link TestContext test context}, according_to the commit and rollback flags._@param testContext the current test context_@throws Exception if an error occurs while retrieving the transaction manager;private void endTransaction(TestContext testContext, TransactionContext txContext) throws Exception {_		boolean rollback = isRollback(testContext)__		if (logger.isTraceEnabled()) {_			logger.trace("Ending transaction for test context " + testContext + "_ transaction manager ["_					+ txContext.transactionStatus + "]_ rollback [" + rollback + "]")__		}_		txContext.endTransaction(rollback)__		if (logger.isInfoEnabled()) {_			logger.info((rollback ? "Rolled back" : "Committed")_					+ " transaction after test execution for test context " + testContext)__		}_	};immediately,force,a,em,commit,em,or,em,rollback,em,of,the,transaction,for,the,supplied,link,test,context,test,context,according,to,the,commit,and,rollback,flags,param,test,context,the,current,test,context,throws,exception,if,an,error,occurs,while,retrieving,the,transaction,manager;private,void,end,transaction,test,context,test,context,transaction,context,tx,context,throws,exception,boolean,rollback,is,rollback,test,context,if,logger,is,trace,enabled,logger,trace,ending,transaction,for,test,context,test,context,transaction,manager,tx,context,transaction,status,rollback,rollback,tx,context,end,transaction,rollback,if,logger,is,info,enabled,logger,info,rollback,rolled,back,committed,transaction,after,test,execution,for,test,context,test,context
TransactionalTestExecutionListener -> private void endTransaction(TestContext testContext, TransactionContext txContext) throws Exception;1355352386;Immediately force a <em>commit</em> or <em>rollback</em> of the_transaction for the supplied {@link TestContext test context}, according_to the commit and rollback flags._@param testContext the current test context_@throws Exception if an error occurs while retrieving the transaction manager;private void endTransaction(TestContext testContext, TransactionContext txContext) throws Exception {_		boolean rollback = isRollback(testContext)__		if (logger.isTraceEnabled()) {_			logger.trace("Ending transaction for test context " + testContext + "_ transaction manager ["_					+ txContext.transactionStatus + "]_ rollback [" + rollback + "]")__		}_		txContext.endTransaction(rollback)__		if (logger.isInfoEnabled()) {_			logger.info((rollback ? "Rolled back" : "Committed")_					+ " transaction after test execution for test context " + testContext)__		}_	};immediately,force,a,em,commit,em,or,em,rollback,em,of,the,transaction,for,the,supplied,link,test,context,test,context,according,to,the,commit,and,rollback,flags,param,test,context,the,current,test,context,throws,exception,if,an,error,occurs,while,retrieving,the,transaction,manager;private,void,end,transaction,test,context,test,context,transaction,context,tx,context,throws,exception,boolean,rollback,is,rollback,test,context,if,logger,is,trace,enabled,logger,trace,ending,transaction,for,test,context,test,context,transaction,manager,tx,context,transaction,status,rollback,rollback,tx,context,end,transaction,rollback,if,logger,is,info,enabled,logger,info,rollback,rolled,back,committed,transaction,after,test,execution,for,test,context,test,context
TransactionalTestExecutionListener -> private void endTransaction(TestContext testContext, TransactionContext txContext) throws Exception;1356735495;Immediately force a <em>commit</em> or <em>rollback</em> of the_transaction for the supplied {@link TestContext test context}, according_to the commit and rollback flags._@param testContext the current test context_@throws Exception if an error occurs while retrieving the transaction manager;private void endTransaction(TestContext testContext, TransactionContext txContext) throws Exception {_		boolean rollback = isRollback(testContext)__		if (logger.isTraceEnabled()) {_			logger.trace("Ending transaction for test context " + testContext + "_ transaction manager ["_					+ txContext.transactionStatus + "]_ rollback [" + rollback + "]")__		}_		txContext.endTransaction(rollback)__		if (logger.isInfoEnabled()) {_			logger.info((rollback ? "Rolled back" : "Committed")_					+ " transaction after test execution for test context " + testContext)__		}_	};immediately,force,a,em,commit,em,or,em,rollback,em,of,the,transaction,for,the,supplied,link,test,context,test,context,according,to,the,commit,and,rollback,flags,param,test,context,the,current,test,context,throws,exception,if,an,error,occurs,while,retrieving,the,transaction,manager;private,void,end,transaction,test,context,test,context,transaction,context,tx,context,throws,exception,boolean,rollback,is,rollback,test,context,if,logger,is,trace,enabled,logger,trace,ending,transaction,for,test,context,test,context,transaction,manager,tx,context,transaction,status,rollback,rollback,tx,context,end,transaction,rollback,if,logger,is,info,enabled,logger,info,rollback,rolled,back,committed,transaction,after,test,execution,for,test,context,test,context
TransactionalTestExecutionListener -> private void endTransaction(TestContext testContext, TransactionContext txContext) throws Exception;1357119239;Immediately force a <em>commit</em> or <em>rollback</em> of the_transaction for the supplied {@link TestContext test context}, according_to the commit and rollback flags._@param testContext the current test context_@throws Exception if an error occurs while retrieving the transaction manager;private void endTransaction(TestContext testContext, TransactionContext txContext) throws Exception {_		boolean rollback = isRollback(testContext)__		if (logger.isTraceEnabled()) {_			logger.trace("Ending transaction for test context " + testContext + "_ transaction manager ["_					+ txContext.transactionStatus + "]_ rollback [" + rollback + "]")__		}_		txContext.endTransaction(rollback)__		if (logger.isInfoEnabled()) {_			logger.info((rollback ? "Rolled back" : "Committed")_					+ " transaction after test execution for test context " + testContext)__		}_	};immediately,force,a,em,commit,em,or,em,rollback,em,of,the,transaction,for,the,supplied,link,test,context,test,context,according,to,the,commit,and,rollback,flags,param,test,context,the,current,test,context,throws,exception,if,an,error,occurs,while,retrieving,the,transaction,manager;private,void,end,transaction,test,context,test,context,transaction,context,tx,context,throws,exception,boolean,rollback,is,rollback,test,context,if,logger,is,trace,enabled,logger,trace,ending,transaction,for,test,context,test,context,transaction,manager,tx,context,transaction,status,rollback,rollback,tx,context,end,transaction,rollback,if,logger,is,info,enabled,logger,info,rollback,rolled,back,committed,transaction,after,test,execution,for,test,context,test,context
TransactionalTestExecutionListener -> private void endTransaction(TestContext testContext, TransactionContext txContext) throws Exception;1367163114;Immediately force a <em>commit</em> or <em>rollback</em> of the_transaction for the supplied {@link TestContext test context}, according_to the commit and rollback flags._@param testContext the current test context_@throws Exception if an error occurs while retrieving the transaction manager;private void endTransaction(TestContext testContext, TransactionContext txContext) throws Exception {_		boolean rollback = isRollback(testContext)__		if (logger.isTraceEnabled()) {_			logger.trace("Ending transaction for test context " + testContext + "_ transaction manager ["_					+ txContext.transactionStatus + "]_ rollback [" + rollback + "]")__		}_		txContext.endTransaction(rollback)__		if (logger.isInfoEnabled()) {_			logger.info((rollback ? "Rolled back" : "Committed")_					+ " transaction after test execution for test context " + testContext)__		}_	};immediately,force,a,em,commit,em,or,em,rollback,em,of,the,transaction,for,the,supplied,link,test,context,test,context,according,to,the,commit,and,rollback,flags,param,test,context,the,current,test,context,throws,exception,if,an,error,occurs,while,retrieving,the,transaction,manager;private,void,end,transaction,test,context,test,context,transaction,context,tx,context,throws,exception,boolean,rollback,is,rollback,test,context,if,logger,is,trace,enabled,logger,trace,ending,transaction,for,test,context,test,context,transaction,manager,tx,context,transaction,status,rollback,rollback,tx,context,end,transaction,rollback,if,logger,is,info,enabled,logger,info,rollback,rolled,back,committed,transaction,after,test,execution,for,test,context,test,context
TransactionalTestExecutionListener -> private void endTransaction(TestContext testContext, TransactionContext txContext) throws Exception;1367873075;Immediately force a <em>commit</em> or <em>rollback</em> of the_transaction for the supplied {@link TestContext test context}, according_to the commit and rollback flags._@param testContext the current test context_@throws Exception if an error occurs while retrieving the transaction manager;private void endTransaction(TestContext testContext, TransactionContext txContext) throws Exception {_		boolean rollback = isRollback(testContext)__		if (logger.isTraceEnabled()) {_			logger.trace("Ending transaction for test context " + testContext + "_ transaction manager ["_					+ txContext.transactionStatus + "]_ rollback [" + rollback + "]")__		}_		txContext.endTransaction(rollback)__		if (logger.isInfoEnabled()) {_			logger.info((rollback ? "Rolled back" : "Committed")_					+ " transaction after test execution for test context " + testContext)__		}_	};immediately,force,a,em,commit,em,or,em,rollback,em,of,the,transaction,for,the,supplied,link,test,context,test,context,according,to,the,commit,and,rollback,flags,param,test,context,the,current,test,context,throws,exception,if,an,error,occurs,while,retrieving,the,transaction,manager;private,void,end,transaction,test,context,test,context,transaction,context,tx,context,throws,exception,boolean,rollback,is,rollback,test,context,if,logger,is,trace,enabled,logger,trace,ending,transaction,for,test,context,test,context,transaction,manager,tx,context,transaction,status,rollback,rollback,tx,context,end,transaction,rollback,if,logger,is,info,enabled,logger,info,rollback,rolled,back,committed,transaction,after,test,execution,for,test,context,test,context
TransactionalTestExecutionListener -> private void endTransaction(TestContext testContext, TransactionContext txContext) throws Exception;1368482696;Immediately force a <em>commit</em> or <em>rollback</em> of the_transaction for the supplied {@link TestContext test context}, according_to the commit and rollback flags._@param testContext the current test context_@throws Exception if an error occurs while retrieving the transaction manager;private void endTransaction(TestContext testContext, TransactionContext txContext) throws Exception {_		boolean rollback = isRollback(testContext)__		if (logger.isTraceEnabled()) {_			logger.trace("Ending transaction for test context " + testContext + "_ transaction manager ["_					+ txContext.transactionStatus + "]_ rollback [" + rollback + "]")__		}_		txContext.endTransaction(rollback)__		if (logger.isInfoEnabled()) {_			logger.info((rollback ? "Rolled back" : "Committed")_					+ " transaction after test execution for test context " + testContext)__		}_	};immediately,force,a,em,commit,em,or,em,rollback,em,of,the,transaction,for,the,supplied,link,test,context,test,context,according,to,the,commit,and,rollback,flags,param,test,context,the,current,test,context,throws,exception,if,an,error,occurs,while,retrieving,the,transaction,manager;private,void,end,transaction,test,context,test,context,transaction,context,tx,context,throws,exception,boolean,rollback,is,rollback,test,context,if,logger,is,trace,enabled,logger,trace,ending,transaction,for,test,context,test,context,transaction,manager,tx,context,transaction,status,rollback,rollback,tx,context,end,transaction,rollback,if,logger,is,info,enabled,logger,info,rollback,rolled,back,committed,transaction,after,test,execution,for,test,context,test,context
TransactionalTestExecutionListener -> private void endTransaction(TestContext testContext, TransactionContext txContext) throws Exception;1382920864;Immediately force a <em>commit</em> or <em>rollback</em> of the_transaction for the supplied {@link TestContext test context}, according_to the commit and rollback flags._@param testContext the current test context_@throws Exception if an error occurs while retrieving the transaction manager;private void endTransaction(TestContext testContext, TransactionContext txContext) throws Exception {_		boolean rollback = isRollback(testContext)__		if (logger.isTraceEnabled()) {_			logger.trace("Ending transaction for test context " + testContext + "_ transaction manager ["_					+ txContext.transactionStatus + "]_ rollback [" + rollback + "]")__		}_		txContext.endTransaction(rollback)__		if (logger.isInfoEnabled()) {_			logger.info((rollback ? "Rolled back" : "Committed")_					+ " transaction after test execution for test context " + testContext)__		}_	};immediately,force,a,em,commit,em,or,em,rollback,em,of,the,transaction,for,the,supplied,link,test,context,test,context,according,to,the,commit,and,rollback,flags,param,test,context,the,current,test,context,throws,exception,if,an,error,occurs,while,retrieving,the,transaction,manager;private,void,end,transaction,test,context,test,context,transaction,context,tx,context,throws,exception,boolean,rollback,is,rollback,test,context,if,logger,is,trace,enabled,logger,trace,ending,transaction,for,test,context,test,context,transaction,manager,tx,context,transaction,status,rollback,rollback,tx,context,end,transaction,rollback,if,logger,is,info,enabled,logger,info,rollback,rolled,back,committed,transaction,after,test,execution,for,test,context,test,context
TransactionalTestExecutionListener -> private void endTransaction(TestContext testContext, TransactionContext txContext) throws Exception;1385499540;Immediately force a <em>commit</em> or <em>rollback</em> of the_transaction for the supplied {@link TestContext test context}, according_to the commit and rollback flags._@param testContext the current test context_@throws Exception if an error occurs while retrieving the transaction manager;private void endTransaction(TestContext testContext, TransactionContext txContext) throws Exception {_		boolean rollback = isRollback(testContext)__		if (logger.isTraceEnabled()) {_			logger.trace("Ending transaction for test context " + testContext + "_ transaction manager ["_					+ txContext.transactionStatus + "]_ rollback [" + rollback + "]")__		}_		txContext.endTransaction(rollback)__		if (logger.isInfoEnabled()) {_			logger.info((rollback ? "Rolled back" : "Committed")_					+ " transaction after test execution for test context " + testContext)__		}_	};immediately,force,a,em,commit,em,or,em,rollback,em,of,the,transaction,for,the,supplied,link,test,context,test,context,according,to,the,commit,and,rollback,flags,param,test,context,the,current,test,context,throws,exception,if,an,error,occurs,while,retrieving,the,transaction,manager;private,void,end,transaction,test,context,test,context,transaction,context,tx,context,throws,exception,boolean,rollback,is,rollback,test,context,if,logger,is,trace,enabled,logger,trace,ending,transaction,for,test,context,test,context,transaction,manager,tx,context,transaction,status,rollback,rollback,tx,context,end,transaction,rollback,if,logger,is,info,enabled,logger,info,rollback,rolled,back,committed,transaction,after,test,execution,for,test,context,test,context
TransactionalTestExecutionListener -> private void endTransaction(TestContext testContext, TransactionContext txContext) throws Exception;1389966876;Immediately force a <em>commit</em> or <em>rollback</em> of the_transaction for the supplied {@link TestContext test context}, according_to the commit and rollback flags._@param testContext the current test context_@throws Exception if an error occurs while retrieving the transaction manager;private void endTransaction(TestContext testContext, TransactionContext txContext) throws Exception {_		boolean rollback = isRollback(testContext)__		if (logger.isTraceEnabled()) {_			logger.trace(String.format(_				"Ending transaction for test context %s_ transaction status [%s]_ rollback [%s]", testContext,_				txContext.transactionStatus, rollback))__		}_		txContext.endTransaction(rollback)__		if (logger.isInfoEnabled()) {_			logger.info((rollback ? "Rolled back" : "Committed")_					+ " transaction after test execution for test context " + testContext)__		}_	};immediately,force,a,em,commit,em,or,em,rollback,em,of,the,transaction,for,the,supplied,link,test,context,test,context,according,to,the,commit,and,rollback,flags,param,test,context,the,current,test,context,throws,exception,if,an,error,occurs,while,retrieving,the,transaction,manager;private,void,end,transaction,test,context,test,context,transaction,context,tx,context,throws,exception,boolean,rollback,is,rollback,test,context,if,logger,is,trace,enabled,logger,trace,string,format,ending,transaction,for,test,context,s,transaction,status,s,rollback,s,test,context,tx,context,transaction,status,rollback,tx,context,end,transaction,rollback,if,logger,is,info,enabled,logger,info,rollback,rolled,back,committed,transaction,after,test,execution,for,test,context,test,context
TransactionalTestExecutionListener -> private void endTransaction(TestContext testContext, TransactionContext txContext) throws Exception;1401991965;Immediately force a <em>commit</em> or <em>rollback</em> of the_transaction for the supplied {@link TestContext test context}, according_to the commit and rollback flags._@param testContext the current test context_@throws Exception if an error occurs while retrieving the transaction manager;private void endTransaction(TestContext testContext, TransactionContext txContext) throws Exception {_		boolean rollback = isRollback(testContext)__		if (logger.isTraceEnabled()) {_			logger.trace(String.format(_				"Ending transaction for test context %s_ transaction status [%s]_ rollback [%s]", testContext,_				txContext.transactionStatus, rollback))__		}_		txContext.endTransaction(rollback)__		if (logger.isInfoEnabled()) {_			logger.info((rollback ? "Rolled back" : "Committed")_					+ " transaction after test execution for test context " + testContext)__		}_	};immediately,force,a,em,commit,em,or,em,rollback,em,of,the,transaction,for,the,supplied,link,test,context,test,context,according,to,the,commit,and,rollback,flags,param,test,context,the,current,test,context,throws,exception,if,an,error,occurs,while,retrieving,the,transaction,manager;private,void,end,transaction,test,context,test,context,transaction,context,tx,context,throws,exception,boolean,rollback,is,rollback,test,context,if,logger,is,trace,enabled,logger,trace,string,format,ending,transaction,for,test,context,s,transaction,status,s,rollback,s,test,context,tx,context,transaction,status,rollback,tx,context,end,transaction,rollback,if,logger,is,info,enabled,logger,info,rollback,rolled,back,committed,transaction,after,test,execution,for,test,context,test,context
TransactionalTestExecutionListener -> @Override 	public void beforeTestMethod(final TestContext testContext) throws Exception;1401991965;If the test method of the supplied {@link TestContext test context} is_configured to run within a transaction, this method will run_{@link BeforeTransaction &#064_BeforeTransaction methods} and start a new_transaction._<p>Note that if a {@code @BeforeTransaction} method fails, any remaining_{@code @BeforeTransaction} methods will not be invoked, and a transaction_will not be started._@see org.springframework.transaction.annotation.Transactional_@see #getTransactionManager(TestContext, String);@Override_	public void beforeTestMethod(final TestContext testContext) throws Exception {_		final Method testMethod = testContext.getTestMethod()__		final Class<?> testClass = testContext.getTestClass()__		Assert.notNull(testMethod, "The test method of the supplied TestContext must not be null")___		if (this.transactionContextCache.remove(testMethod) != null) {_			throw new IllegalStateException("Cannot start new transaction without ending existing transaction: "_					+ "Invoke endTransaction() before startNewTransaction().")__		}__		PlatformTransactionManager tm = null__		TransactionAttribute transactionAttribute = this.attributeSource.getTransactionAttribute(testMethod, testClass)___		if (transactionAttribute != null) {_			transactionAttribute = TestContextTransactionUtils.createDelegatingTransactionAttribute(testContext,_				transactionAttribute)___			if (logger.isDebugEnabled()) {_				logger.debug("Explicit transaction definition [" + transactionAttribute + "] found for test context "_						+ testContext)__			}__			if (transactionAttribute.getPropagationBehavior() == TransactionDefinition.PROPAGATION_NOT_SUPPORTED) {_				return__			}__			tm = getTransactionManager(testContext, transactionAttribute.getQualifier())__		}__		if (tm != null) {_			TransactionContext txContext = new TransactionContext(tm, transactionAttribute)__			runBeforeTransactionMethods(testContext)__			startNewTransaction(testContext, txContext)__			this.transactionContextCache.put(testMethod, txContext)__		}_	};if,the,test,method,of,the,supplied,link,test,context,test,context,is,configured,to,run,within,a,transaction,this,method,will,run,link,before,transaction,064,before,transaction,methods,and,start,a,new,transaction,p,note,that,if,a,code,before,transaction,method,fails,any,remaining,code,before,transaction,methods,will,not,be,invoked,and,a,transaction,will,not,be,started,see,org,springframework,transaction,annotation,transactional,see,get,transaction,manager,test,context,string;override,public,void,before,test,method,final,test,context,test,context,throws,exception,final,method,test,method,test,context,get,test,method,final,class,test,class,test,context,get,test,class,assert,not,null,test,method,the,test,method,of,the,supplied,test,context,must,not,be,null,if,this,transaction,context,cache,remove,test,method,null,throw,new,illegal,state,exception,cannot,start,new,transaction,without,ending,existing,transaction,invoke,end,transaction,before,start,new,transaction,platform,transaction,manager,tm,null,transaction,attribute,transaction,attribute,this,attribute,source,get,transaction,attribute,test,method,test,class,if,transaction,attribute,null,transaction,attribute,test,context,transaction,utils,create,delegating,transaction,attribute,test,context,transaction,attribute,if,logger,is,debug,enabled,logger,debug,explicit,transaction,definition,transaction,attribute,found,for,test,context,test,context,if,transaction,attribute,get,propagation,behavior,transaction,definition,return,tm,get,transaction,manager,test,context,transaction,attribute,get,qualifier,if,tm,null,transaction,context,tx,context,new,transaction,context,tm,transaction,attribute,run,before,transaction,methods,test,context,start,new,transaction,test,context,tx,context,this,transaction,context,cache,put,test,method,tx,context
TransactionalTestExecutionListener -> @Override 	public void beforeTestMethod(final TestContext testContext) throws Exception;1404334604;If the test method of the supplied {@linkplain TestContext test context}_is configured to run within a transaction, this method will run_{@link BeforeTransaction @BeforeTransaction} methods and start a new_transaction._<p>Note that if a {@code @BeforeTransaction} method fails, any remaining_{@code @BeforeTransaction} methods will not be invoked, and a transaction_will not be started._@see org.springframework.transaction.annotation.Transactional_@see #getTransactionManager(TestContext, String);@Override_	public void beforeTestMethod(final TestContext testContext) throws Exception {_		final Method testMethod = testContext.getTestMethod()__		final Class<?> testClass = testContext.getTestClass()__		Assert.notNull(testMethod, "The test method of the supplied TestContext must not be null")___		TransactionContext txContext = TransactionContextHolder.removeCurrentTransactionContext()__		if (txContext != null) {_			throw new IllegalStateException("Cannot start a new transaction without ending the existing transaction.")__		}__		PlatformTransactionManager tm = null__		TransactionAttribute transactionAttribute = this.attributeSource.getTransactionAttribute(testMethod, testClass)___		if (transactionAttribute != null) {_			transactionAttribute = TestContextTransactionUtils.createDelegatingTransactionAttribute(testContext,_				transactionAttribute)___			if (logger.isDebugEnabled()) {_				logger.debug("Explicit transaction definition [" + transactionAttribute + "] found for test context "_						+ testContext)__			}__			if (transactionAttribute.getPropagationBehavior() == TransactionDefinition.PROPAGATION_NOT_SUPPORTED) {_				return__			}__			tm = getTransactionManager(testContext, transactionAttribute.getQualifier())__		}__		if (tm != null) {_			txContext = new TransactionContext(testContext, tm, transactionAttribute, isRollback(testContext))__			runBeforeTransactionMethods(testContext)__			txContext.startTransaction()__			TransactionContextHolder.setCurrentTransactionContext(txContext)__		}_	};if,the,test,method,of,the,supplied,linkplain,test,context,test,context,is,configured,to,run,within,a,transaction,this,method,will,run,link,before,transaction,before,transaction,methods,and,start,a,new,transaction,p,note,that,if,a,code,before,transaction,method,fails,any,remaining,code,before,transaction,methods,will,not,be,invoked,and,a,transaction,will,not,be,started,see,org,springframework,transaction,annotation,transactional,see,get,transaction,manager,test,context,string;override,public,void,before,test,method,final,test,context,test,context,throws,exception,final,method,test,method,test,context,get,test,method,final,class,test,class,test,context,get,test,class,assert,not,null,test,method,the,test,method,of,the,supplied,test,context,must,not,be,null,transaction,context,tx,context,transaction,context,holder,remove,current,transaction,context,if,tx,context,null,throw,new,illegal,state,exception,cannot,start,a,new,transaction,without,ending,the,existing,transaction,platform,transaction,manager,tm,null,transaction,attribute,transaction,attribute,this,attribute,source,get,transaction,attribute,test,method,test,class,if,transaction,attribute,null,transaction,attribute,test,context,transaction,utils,create,delegating,transaction,attribute,test,context,transaction,attribute,if,logger,is,debug,enabled,logger,debug,explicit,transaction,definition,transaction,attribute,found,for,test,context,test,context,if,transaction,attribute,get,propagation,behavior,transaction,definition,return,tm,get,transaction,manager,test,context,transaction,attribute,get,qualifier,if,tm,null,tx,context,new,transaction,context,test,context,tm,transaction,attribute,is,rollback,test,context,run,before,transaction,methods,test,context,tx,context,start,transaction,transaction,context,holder,set,current,transaction,context,tx,context
TransactionalTestExecutionListener -> @Override 	public void beforeTestMethod(final TestContext testContext) throws Exception;1405645143;If the test method of the supplied {@linkplain TestContext test context}_is configured to run within a transaction, this method will run_{@link BeforeTransaction @BeforeTransaction} methods and start a new_transaction._<p>Note that if a {@code @BeforeTransaction} method fails, any remaining_{@code @BeforeTransaction} methods will not be invoked, and a transaction_will not be started._@see org.springframework.transaction.annotation.Transactional_@see #getTransactionManager(TestContext, String);@Override_	public void beforeTestMethod(final TestContext testContext) throws Exception {_		final Method testMethod = testContext.getTestMethod()__		final Class<?> testClass = testContext.getTestClass()__		Assert.notNull(testMethod, "The test method of the supplied TestContext must not be null")___		TransactionContext txContext = TransactionContextHolder.removeCurrentTransactionContext()__		if (txContext != null) {_			throw new IllegalStateException("Cannot start a new transaction without ending the existing transaction.")__		}__		PlatformTransactionManager tm = null__		TransactionAttribute transactionAttribute = this.attributeSource.getTransactionAttribute(testMethod, testClass)___		if (transactionAttribute != null) {_			transactionAttribute = TestContextTransactionUtils.createDelegatingTransactionAttribute(testContext,_				transactionAttribute)___			if (logger.isDebugEnabled()) {_				logger.debug("Explicit transaction definition [" + transactionAttribute + "] found for test context "_						+ testContext)__			}__			if (transactionAttribute.getPropagationBehavior() == TransactionDefinition.PROPAGATION_NOT_SUPPORTED) {_				return__			}__			tm = getTransactionManager(testContext, transactionAttribute.getQualifier())__		}__		if (tm != null) {_			txContext = new TransactionContext(testContext, tm, transactionAttribute, isRollback(testContext))__			runBeforeTransactionMethods(testContext)__			txContext.startTransaction()__			TransactionContextHolder.setCurrentTransactionContext(txContext)__		}_	};if,the,test,method,of,the,supplied,linkplain,test,context,test,context,is,configured,to,run,within,a,transaction,this,method,will,run,link,before,transaction,before,transaction,methods,and,start,a,new,transaction,p,note,that,if,a,code,before,transaction,method,fails,any,remaining,code,before,transaction,methods,will,not,be,invoked,and,a,transaction,will,not,be,started,see,org,springframework,transaction,annotation,transactional,see,get,transaction,manager,test,context,string;override,public,void,before,test,method,final,test,context,test,context,throws,exception,final,method,test,method,test,context,get,test,method,final,class,test,class,test,context,get,test,class,assert,not,null,test,method,the,test,method,of,the,supplied,test,context,must,not,be,null,transaction,context,tx,context,transaction,context,holder,remove,current,transaction,context,if,tx,context,null,throw,new,illegal,state,exception,cannot,start,a,new,transaction,without,ending,the,existing,transaction,platform,transaction,manager,tm,null,transaction,attribute,transaction,attribute,this,attribute,source,get,transaction,attribute,test,method,test,class,if,transaction,attribute,null,transaction,attribute,test,context,transaction,utils,create,delegating,transaction,attribute,test,context,transaction,attribute,if,logger,is,debug,enabled,logger,debug,explicit,transaction,definition,transaction,attribute,found,for,test,context,test,context,if,transaction,attribute,get,propagation,behavior,transaction,definition,return,tm,get,transaction,manager,test,context,transaction,attribute,get,qualifier,if,tm,null,tx,context,new,transaction,context,test,context,tm,transaction,attribute,is,rollback,test,context,run,before,transaction,methods,test,context,tx,context,start,transaction,transaction,context,holder,set,current,transaction,context,tx,context
TransactionalTestExecutionListener -> @Override 	public void beforeTestMethod(final TestContext testContext) throws Exception;1405698612;If the test method of the supplied {@linkplain TestContext test context}_is configured to run within a transaction, this method will run_{@link BeforeTransaction @BeforeTransaction} methods and start a new_transaction._<p>Note that if a {@code @BeforeTransaction} method fails, any remaining_{@code @BeforeTransaction} methods will not be invoked, and a transaction_will not be started._@see org.springframework.transaction.annotation.Transactional_@see #getTransactionManager(TestContext, String);@Override_	public void beforeTestMethod(final TestContext testContext) throws Exception {_		final Method testMethod = testContext.getTestMethod()__		final Class<?> testClass = testContext.getTestClass()__		Assert.notNull(testMethod, "The test method of the supplied TestContext must not be null")___		TransactionContext txContext = TransactionContextHolder.removeCurrentTransactionContext()__		if (txContext != null) {_			throw new IllegalStateException("Cannot start a new transaction without ending the existing transaction.")__		}__		PlatformTransactionManager tm = null__		TransactionAttribute transactionAttribute = this.attributeSource.getTransactionAttribute(testMethod, testClass)___		if (transactionAttribute != null) {_			transactionAttribute = TestContextTransactionUtils.createDelegatingTransactionAttribute(testContext,_				transactionAttribute)___			if (logger.isDebugEnabled()) {_				logger.debug("Explicit transaction definition [" + transactionAttribute + "] found for test context "_						+ testContext)__			}__			if (transactionAttribute.getPropagationBehavior() == TransactionDefinition.PROPAGATION_NOT_SUPPORTED) {_				return__			}__			tm = getTransactionManager(testContext, transactionAttribute.getQualifier())__		}__		if (tm != null) {_			txContext = new TransactionContext(testContext, tm, transactionAttribute, isRollback(testContext))__			runBeforeTransactionMethods(testContext)__			txContext.startTransaction()__			TransactionContextHolder.setCurrentTransactionContext(txContext)__		}_	};if,the,test,method,of,the,supplied,linkplain,test,context,test,context,is,configured,to,run,within,a,transaction,this,method,will,run,link,before,transaction,before,transaction,methods,and,start,a,new,transaction,p,note,that,if,a,code,before,transaction,method,fails,any,remaining,code,before,transaction,methods,will,not,be,invoked,and,a,transaction,will,not,be,started,see,org,springframework,transaction,annotation,transactional,see,get,transaction,manager,test,context,string;override,public,void,before,test,method,final,test,context,test,context,throws,exception,final,method,test,method,test,context,get,test,method,final,class,test,class,test,context,get,test,class,assert,not,null,test,method,the,test,method,of,the,supplied,test,context,must,not,be,null,transaction,context,tx,context,transaction,context,holder,remove,current,transaction,context,if,tx,context,null,throw,new,illegal,state,exception,cannot,start,a,new,transaction,without,ending,the,existing,transaction,platform,transaction,manager,tm,null,transaction,attribute,transaction,attribute,this,attribute,source,get,transaction,attribute,test,method,test,class,if,transaction,attribute,null,transaction,attribute,test,context,transaction,utils,create,delegating,transaction,attribute,test,context,transaction,attribute,if,logger,is,debug,enabled,logger,debug,explicit,transaction,definition,transaction,attribute,found,for,test,context,test,context,if,transaction,attribute,get,propagation,behavior,transaction,definition,return,tm,get,transaction,manager,test,context,transaction,attribute,get,qualifier,if,tm,null,tx,context,new,transaction,context,test,context,tm,transaction,attribute,is,rollback,test,context,run,before,transaction,methods,test,context,tx,context,start,transaction,transaction,context,holder,set,current,transaction,context,tx,context
TransactionalTestExecutionListener -> @Override 	public void beforeTestMethod(final TestContext testContext) throws Exception;1405759527;If the test method of the supplied {@linkplain TestContext test context}_is configured to run within a transaction, this method will run_{@link BeforeTransaction @BeforeTransaction} methods and start a new_transaction._<p>Note that if a {@code @BeforeTransaction} method fails, any remaining_{@code @BeforeTransaction} methods will not be invoked, and a transaction_will not be started._@see org.springframework.transaction.annotation.Transactional_@see #getTransactionManager(TestContext, String);@Override_	public void beforeTestMethod(final TestContext testContext) throws Exception {_		final Method testMethod = testContext.getTestMethod()__		final Class<?> testClass = testContext.getTestClass()__		Assert.notNull(testMethod, "The test method of the supplied TestContext must not be null")___		TransactionContext txContext = TransactionContextHolder.removeCurrentTransactionContext()__		if (txContext != null) {_			throw new IllegalStateException("Cannot start a new transaction without ending the existing transaction.")__		}__		PlatformTransactionManager tm = null__		TransactionAttribute transactionAttribute = this.attributeSource.getTransactionAttribute(testMethod, testClass)___		if (transactionAttribute != null) {_			transactionAttribute = TestContextTransactionUtils.createDelegatingTransactionAttribute(testContext,_				transactionAttribute)___			if (logger.isDebugEnabled()) {_				logger.debug("Explicit transaction definition [" + transactionAttribute + "] found for test context "_						+ testContext)__			}__			if (transactionAttribute.getPropagationBehavior() == TransactionDefinition.PROPAGATION_NOT_SUPPORTED) {_				return__			}__			tm = getTransactionManager(testContext, transactionAttribute.getQualifier())__		}__		if (tm != null) {_			txContext = new TransactionContext(testContext, tm, transactionAttribute, isRollback(testContext))__			runBeforeTransactionMethods(testContext)__			txContext.startTransaction()__			TransactionContextHolder.setCurrentTransactionContext(txContext)__		}_	};if,the,test,method,of,the,supplied,linkplain,test,context,test,context,is,configured,to,run,within,a,transaction,this,method,will,run,link,before,transaction,before,transaction,methods,and,start,a,new,transaction,p,note,that,if,a,code,before,transaction,method,fails,any,remaining,code,before,transaction,methods,will,not,be,invoked,and,a,transaction,will,not,be,started,see,org,springframework,transaction,annotation,transactional,see,get,transaction,manager,test,context,string;override,public,void,before,test,method,final,test,context,test,context,throws,exception,final,method,test,method,test,context,get,test,method,final,class,test,class,test,context,get,test,class,assert,not,null,test,method,the,test,method,of,the,supplied,test,context,must,not,be,null,transaction,context,tx,context,transaction,context,holder,remove,current,transaction,context,if,tx,context,null,throw,new,illegal,state,exception,cannot,start,a,new,transaction,without,ending,the,existing,transaction,platform,transaction,manager,tm,null,transaction,attribute,transaction,attribute,this,attribute,source,get,transaction,attribute,test,method,test,class,if,transaction,attribute,null,transaction,attribute,test,context,transaction,utils,create,delegating,transaction,attribute,test,context,transaction,attribute,if,logger,is,debug,enabled,logger,debug,explicit,transaction,definition,transaction,attribute,found,for,test,context,test,context,if,transaction,attribute,get,propagation,behavior,transaction,definition,return,tm,get,transaction,manager,test,context,transaction,attribute,get,qualifier,if,tm,null,tx,context,new,transaction,context,test,context,tm,transaction,attribute,is,rollback,test,context,run,before,transaction,methods,test,context,tx,context,start,transaction,transaction,context,holder,set,current,transaction,context,tx,context
TransactionalTestExecutionListener -> @Override 	public void beforeTestMethod(final TestContext testContext) throws Exception;1405759966;If the test method of the supplied {@linkplain TestContext test context}_is configured to run within a transaction, this method will run_{@link BeforeTransaction @BeforeTransaction} methods and start a new_transaction._<p>Note that if a {@code @BeforeTransaction} method fails, any remaining_{@code @BeforeTransaction} methods will not be invoked, and a transaction_will not be started._@see org.springframework.transaction.annotation.Transactional_@see #getTransactionManager(TestContext, String);@Override_	public void beforeTestMethod(final TestContext testContext) throws Exception {_		final Method testMethod = testContext.getTestMethod()__		final Class<?> testClass = testContext.getTestClass()__		Assert.notNull(testMethod, "The test method of the supplied TestContext must not be null")___		TransactionContext txContext = TransactionContextHolder.removeCurrentTransactionContext()__		if (txContext != null) {_			throw new IllegalStateException("Cannot start a new transaction without ending the existing transaction.")__		}__		PlatformTransactionManager tm = null__		TransactionAttribute transactionAttribute = this.attributeSource.getTransactionAttribute(testMethod, testClass)___		if (transactionAttribute != null) {_			transactionAttribute = TestContextTransactionUtils.createDelegatingTransactionAttribute(testContext,_				transactionAttribute)___			if (logger.isDebugEnabled()) {_				logger.debug("Explicit transaction definition [" + transactionAttribute + "] found for test context "_						+ testContext)__			}__			if (transactionAttribute.getPropagationBehavior() == TransactionDefinition.PROPAGATION_NOT_SUPPORTED) {_				return__			}__			tm = getTransactionManager(testContext, transactionAttribute.getQualifier())__		}__		if (tm != null) {_			txContext = new TransactionContext(testContext, tm, transactionAttribute, isRollback(testContext))__			runBeforeTransactionMethods(testContext)__			txContext.startTransaction()__			TransactionContextHolder.setCurrentTransactionContext(txContext)__		}_	};if,the,test,method,of,the,supplied,linkplain,test,context,test,context,is,configured,to,run,within,a,transaction,this,method,will,run,link,before,transaction,before,transaction,methods,and,start,a,new,transaction,p,note,that,if,a,code,before,transaction,method,fails,any,remaining,code,before,transaction,methods,will,not,be,invoked,and,a,transaction,will,not,be,started,see,org,springframework,transaction,annotation,transactional,see,get,transaction,manager,test,context,string;override,public,void,before,test,method,final,test,context,test,context,throws,exception,final,method,test,method,test,context,get,test,method,final,class,test,class,test,context,get,test,class,assert,not,null,test,method,the,test,method,of,the,supplied,test,context,must,not,be,null,transaction,context,tx,context,transaction,context,holder,remove,current,transaction,context,if,tx,context,null,throw,new,illegal,state,exception,cannot,start,a,new,transaction,without,ending,the,existing,transaction,platform,transaction,manager,tm,null,transaction,attribute,transaction,attribute,this,attribute,source,get,transaction,attribute,test,method,test,class,if,transaction,attribute,null,transaction,attribute,test,context,transaction,utils,create,delegating,transaction,attribute,test,context,transaction,attribute,if,logger,is,debug,enabled,logger,debug,explicit,transaction,definition,transaction,attribute,found,for,test,context,test,context,if,transaction,attribute,get,propagation,behavior,transaction,definition,return,tm,get,transaction,manager,test,context,transaction,attribute,get,qualifier,if,tm,null,tx,context,new,transaction,context,test,context,tm,transaction,attribute,is,rollback,test,context,run,before,transaction,methods,test,context,tx,context,start,transaction,transaction,context,holder,set,current,transaction,context,tx,context
TransactionalTestExecutionListener -> @Override 	public void beforeTestMethod(final TestContext testContext) throws Exception;1406218418;If the test method of the supplied {@linkplain TestContext test context}_is configured to run within a transaction, this method will run_{@link BeforeTransaction @BeforeTransaction} methods and start a new_transaction._<p>Note that if a {@code @BeforeTransaction} method fails, any remaining_{@code @BeforeTransaction} methods will not be invoked, and a transaction_will not be started._@see org.springframework.transaction.annotation.Transactional_@see #getTransactionManager(TestContext, String);@Override_	public void beforeTestMethod(final TestContext testContext) throws Exception {_		final Method testMethod = testContext.getTestMethod()__		final Class<?> testClass = testContext.getTestClass()__		Assert.notNull(testMethod, "The test method of the supplied TestContext must not be null")___		TransactionContext txContext = TransactionContextHolder.removeCurrentTransactionContext()__		if (txContext != null) {_			throw new IllegalStateException("Cannot start a new transaction without ending the existing transaction.")__		}__		PlatformTransactionManager tm = null__		TransactionAttribute transactionAttribute = this.attributeSource.getTransactionAttribute(testMethod, testClass)___		if (transactionAttribute != null) {_			transactionAttribute = TestContextTransactionUtils.createDelegatingTransactionAttribute(testContext,_				transactionAttribute)___			if (logger.isDebugEnabled()) {_				logger.debug("Explicit transaction definition [" + transactionAttribute + "] found for test context "_						+ testContext)__			}__			if (transactionAttribute.getPropagationBehavior() == TransactionDefinition.PROPAGATION_NOT_SUPPORTED) {_				return__			}__			tm = getTransactionManager(testContext, transactionAttribute.getQualifier())__		}__		if (tm != null) {_			txContext = new TransactionContext(testContext, tm, transactionAttribute, isRollback(testContext))__			runBeforeTransactionMethods(testContext)__			txContext.startTransaction()__			TransactionContextHolder.setCurrentTransactionContext(txContext)__		}_	};if,the,test,method,of,the,supplied,linkplain,test,context,test,context,is,configured,to,run,within,a,transaction,this,method,will,run,link,before,transaction,before,transaction,methods,and,start,a,new,transaction,p,note,that,if,a,code,before,transaction,method,fails,any,remaining,code,before,transaction,methods,will,not,be,invoked,and,a,transaction,will,not,be,started,see,org,springframework,transaction,annotation,transactional,see,get,transaction,manager,test,context,string;override,public,void,before,test,method,final,test,context,test,context,throws,exception,final,method,test,method,test,context,get,test,method,final,class,test,class,test,context,get,test,class,assert,not,null,test,method,the,test,method,of,the,supplied,test,context,must,not,be,null,transaction,context,tx,context,transaction,context,holder,remove,current,transaction,context,if,tx,context,null,throw,new,illegal,state,exception,cannot,start,a,new,transaction,without,ending,the,existing,transaction,platform,transaction,manager,tm,null,transaction,attribute,transaction,attribute,this,attribute,source,get,transaction,attribute,test,method,test,class,if,transaction,attribute,null,transaction,attribute,test,context,transaction,utils,create,delegating,transaction,attribute,test,context,transaction,attribute,if,logger,is,debug,enabled,logger,debug,explicit,transaction,definition,transaction,attribute,found,for,test,context,test,context,if,transaction,attribute,get,propagation,behavior,transaction,definition,return,tm,get,transaction,manager,test,context,transaction,attribute,get,qualifier,if,tm,null,tx,context,new,transaction,context,test,context,tm,transaction,attribute,is,rollback,test,context,run,before,transaction,methods,test,context,tx,context,start,transaction,transaction,context,holder,set,current,transaction,context,tx,context
TransactionalTestExecutionListener -> @Override 	public void beforeTestMethod(final TestContext testContext) throws Exception;1407419079;If the test method of the supplied {@linkplain TestContext test context}_is configured to run within a transaction, this method will run_{@link BeforeTransaction @BeforeTransaction} methods and start a new_transaction._<p>Note that if a {@code @BeforeTransaction} method fails, any remaining_{@code @BeforeTransaction} methods will not be invoked, and a transaction_will not be started._@see org.springframework.transaction.annotation.Transactional_@see #getTransactionManager(TestContext, String);@Override_	public void beforeTestMethod(final TestContext testContext) throws Exception {_		final Method testMethod = testContext.getTestMethod()__		final Class<?> testClass = testContext.getTestClass()__		Assert.notNull(testMethod, "The test method of the supplied TestContext must not be null")___		TransactionContext txContext = TransactionContextHolder.removeCurrentTransactionContext()__		if (txContext != null) {_			throw new IllegalStateException("Cannot start a new transaction without ending the existing transaction.")__		}__		PlatformTransactionManager tm = null__		TransactionAttribute transactionAttribute = this.attributeSource.getTransactionAttribute(testMethod, testClass)___		if (transactionAttribute != null) {_			transactionAttribute = TestContextTransactionUtils.createDelegatingTransactionAttribute(testContext,_				transactionAttribute)___			if (logger.isDebugEnabled()) {_				logger.debug("Explicit transaction definition [" + transactionAttribute + "] found for test context "_						+ testContext)__			}__			if (transactionAttribute.getPropagationBehavior() == TransactionDefinition.PROPAGATION_NOT_SUPPORTED) {_				return__			}__			tm = getTransactionManager(testContext, transactionAttribute.getQualifier())__		}__		if (tm != null) {_			txContext = new TransactionContext(testContext, tm, transactionAttribute, isRollback(testContext))__			runBeforeTransactionMethods(testContext)__			txContext.startTransaction()__			TransactionContextHolder.setCurrentTransactionContext(txContext)__		}_	};if,the,test,method,of,the,supplied,linkplain,test,context,test,context,is,configured,to,run,within,a,transaction,this,method,will,run,link,before,transaction,before,transaction,methods,and,start,a,new,transaction,p,note,that,if,a,code,before,transaction,method,fails,any,remaining,code,before,transaction,methods,will,not,be,invoked,and,a,transaction,will,not,be,started,see,org,springframework,transaction,annotation,transactional,see,get,transaction,manager,test,context,string;override,public,void,before,test,method,final,test,context,test,context,throws,exception,final,method,test,method,test,context,get,test,method,final,class,test,class,test,context,get,test,class,assert,not,null,test,method,the,test,method,of,the,supplied,test,context,must,not,be,null,transaction,context,tx,context,transaction,context,holder,remove,current,transaction,context,if,tx,context,null,throw,new,illegal,state,exception,cannot,start,a,new,transaction,without,ending,the,existing,transaction,platform,transaction,manager,tm,null,transaction,attribute,transaction,attribute,this,attribute,source,get,transaction,attribute,test,method,test,class,if,transaction,attribute,null,transaction,attribute,test,context,transaction,utils,create,delegating,transaction,attribute,test,context,transaction,attribute,if,logger,is,debug,enabled,logger,debug,explicit,transaction,definition,transaction,attribute,found,for,test,context,test,context,if,transaction,attribute,get,propagation,behavior,transaction,definition,return,tm,get,transaction,manager,test,context,transaction,attribute,get,qualifier,if,tm,null,tx,context,new,transaction,context,test,context,tm,transaction,attribute,is,rollback,test,context,run,before,transaction,methods,test,context,tx,context,start,transaction,transaction,context,holder,set,current,transaction,context,tx,context
TransactionalTestExecutionListener -> @Override 	public void beforeTestMethod(final TestContext testContext) throws Exception;1408048216;If the test method of the supplied {@linkplain TestContext test context}_is configured to run within a transaction, this method will run_{@link BeforeTransaction @BeforeTransaction} methods and start a new_transaction._<p>Note that if a {@code @BeforeTransaction} method fails, any remaining_{@code @BeforeTransaction} methods will not be invoked, and a transaction_will not be started._@see org.springframework.transaction.annotation.Transactional_@see #getTransactionManager(TestContext, String);@Override_	public void beforeTestMethod(final TestContext testContext) throws Exception {_		final Method testMethod = testContext.getTestMethod()__		final Class<?> testClass = testContext.getTestClass()__		Assert.notNull(testMethod, "The test method of the supplied TestContext must not be null")___		TransactionContext txContext = TransactionContextHolder.removeCurrentTransactionContext()__		if (txContext != null) {_			throw new IllegalStateException("Cannot start a new transaction without ending the existing transaction.")__		}__		PlatformTransactionManager tm = null__		TransactionAttribute transactionAttribute = this.attributeSource.getTransactionAttribute(testMethod, testClass)___		if (transactionAttribute != null) {_			transactionAttribute = TestContextTransactionUtils.createDelegatingTransactionAttribute(testContext,_				transactionAttribute)___			if (logger.isDebugEnabled()) {_				logger.debug("Explicit transaction definition [" + transactionAttribute + "] found for test context "_						+ testContext)__			}__			if (transactionAttribute.getPropagationBehavior() == TransactionDefinition.PROPAGATION_NOT_SUPPORTED) {_				return__			}__			tm = getTransactionManager(testContext, transactionAttribute.getQualifier())__		}__		if (tm != null) {_			txContext = new TransactionContext(testContext, tm, transactionAttribute, isRollback(testContext))__			runBeforeTransactionMethods(testContext)__			txContext.startTransaction()__			TransactionContextHolder.setCurrentTransactionContext(txContext)__		}_	};if,the,test,method,of,the,supplied,linkplain,test,context,test,context,is,configured,to,run,within,a,transaction,this,method,will,run,link,before,transaction,before,transaction,methods,and,start,a,new,transaction,p,note,that,if,a,code,before,transaction,method,fails,any,remaining,code,before,transaction,methods,will,not,be,invoked,and,a,transaction,will,not,be,started,see,org,springframework,transaction,annotation,transactional,see,get,transaction,manager,test,context,string;override,public,void,before,test,method,final,test,context,test,context,throws,exception,final,method,test,method,test,context,get,test,method,final,class,test,class,test,context,get,test,class,assert,not,null,test,method,the,test,method,of,the,supplied,test,context,must,not,be,null,transaction,context,tx,context,transaction,context,holder,remove,current,transaction,context,if,tx,context,null,throw,new,illegal,state,exception,cannot,start,a,new,transaction,without,ending,the,existing,transaction,platform,transaction,manager,tm,null,transaction,attribute,transaction,attribute,this,attribute,source,get,transaction,attribute,test,method,test,class,if,transaction,attribute,null,transaction,attribute,test,context,transaction,utils,create,delegating,transaction,attribute,test,context,transaction,attribute,if,logger,is,debug,enabled,logger,debug,explicit,transaction,definition,transaction,attribute,found,for,test,context,test,context,if,transaction,attribute,get,propagation,behavior,transaction,definition,return,tm,get,transaction,manager,test,context,transaction,attribute,get,qualifier,if,tm,null,tx,context,new,transaction,context,test,context,tm,transaction,attribute,is,rollback,test,context,run,before,transaction,methods,test,context,tx,context,start,transaction,transaction,context,holder,set,current,transaction,context,tx,context
TransactionalTestExecutionListener -> @Override 	public void beforeTestMethod(final TestContext testContext) throws Exception;1413848647;If the test method of the supplied {@linkplain TestContext test context}_is configured to run within a transaction, this method will run_{@link BeforeTransaction @BeforeTransaction} methods and start a new_transaction._<p>Note that if a {@code @BeforeTransaction} method fails, any remaining_{@code @BeforeTransaction} methods will not be invoked, and a transaction_will not be started._@see org.springframework.transaction.annotation.Transactional_@see #getTransactionManager(TestContext, String);@Override_	public void beforeTestMethod(final TestContext testContext) throws Exception {_		final Method testMethod = testContext.getTestMethod()__		final Class<?> testClass = testContext.getTestClass()__		Assert.notNull(testMethod, "The test method of the supplied TestContext must not be null")___		TransactionContext txContext = TransactionContextHolder.removeCurrentTransactionContext()__		if (txContext != null) {_			throw new IllegalStateException("Cannot start a new transaction without ending the existing transaction.")__		}__		PlatformTransactionManager tm = null__		TransactionAttribute transactionAttribute = this.attributeSource.getTransactionAttribute(testMethod, testClass)___		if (transactionAttribute != null) {_			transactionAttribute = TestContextTransactionUtils.createDelegatingTransactionAttribute(testContext,_				transactionAttribute)___			if (logger.isDebugEnabled()) {_				logger.debug("Explicit transaction definition [" + transactionAttribute + "] found for test context "_						+ testContext)__			}__			if (transactionAttribute.getPropagationBehavior() == TransactionDefinition.PROPAGATION_NOT_SUPPORTED) {_				return__			}__			tm = getTransactionManager(testContext, transactionAttribute.getQualifier())__		}__		if (tm != null) {_			txContext = new TransactionContext(testContext, tm, transactionAttribute, isRollback(testContext))__			runBeforeTransactionMethods(testContext)__			txContext.startTransaction()__			TransactionContextHolder.setCurrentTransactionContext(txContext)__		}_	};if,the,test,method,of,the,supplied,linkplain,test,context,test,context,is,configured,to,run,within,a,transaction,this,method,will,run,link,before,transaction,before,transaction,methods,and,start,a,new,transaction,p,note,that,if,a,code,before,transaction,method,fails,any,remaining,code,before,transaction,methods,will,not,be,invoked,and,a,transaction,will,not,be,started,see,org,springframework,transaction,annotation,transactional,see,get,transaction,manager,test,context,string;override,public,void,before,test,method,final,test,context,test,context,throws,exception,final,method,test,method,test,context,get,test,method,final,class,test,class,test,context,get,test,class,assert,not,null,test,method,the,test,method,of,the,supplied,test,context,must,not,be,null,transaction,context,tx,context,transaction,context,holder,remove,current,transaction,context,if,tx,context,null,throw,new,illegal,state,exception,cannot,start,a,new,transaction,without,ending,the,existing,transaction,platform,transaction,manager,tm,null,transaction,attribute,transaction,attribute,this,attribute,source,get,transaction,attribute,test,method,test,class,if,transaction,attribute,null,transaction,attribute,test,context,transaction,utils,create,delegating,transaction,attribute,test,context,transaction,attribute,if,logger,is,debug,enabled,logger,debug,explicit,transaction,definition,transaction,attribute,found,for,test,context,test,context,if,transaction,attribute,get,propagation,behavior,transaction,definition,return,tm,get,transaction,manager,test,context,transaction,attribute,get,qualifier,if,tm,null,tx,context,new,transaction,context,test,context,tm,transaction,attribute,is,rollback,test,context,run,before,transaction,methods,test,context,tx,context,start,transaction,transaction,context,holder,set,current,transaction,context,tx,context
TransactionalTestExecutionListener -> @Override 	public void beforeTestMethod(final TestContext testContext) throws Exception;1431568199;If the test method of the supplied {@linkplain TestContext test context}_is configured to run within a transaction, this method will run_{@link BeforeTransaction @BeforeTransaction} methods and start a new_transaction._<p>Note that if a {@code @BeforeTransaction} method fails, any remaining_{@code @BeforeTransaction} methods will not be invoked, and a transaction_will not be started._@see org.springframework.transaction.annotation.Transactional_@see #getTransactionManager(TestContext, String);@Override_	public void beforeTestMethod(final TestContext testContext) throws Exception {_		final Method testMethod = testContext.getTestMethod()__		final Class<?> testClass = testContext.getTestClass()__		Assert.notNull(testMethod, "The test method of the supplied TestContext must not be null")___		TransactionContext txContext = TransactionContextHolder.removeCurrentTransactionContext()__		if (txContext != null) {_			throw new IllegalStateException("Cannot start a new transaction without ending the existing transaction.")__		}__		PlatformTransactionManager tm = null__		TransactionAttribute transactionAttribute = this.attributeSource.getTransactionAttribute(testMethod, testClass)___		if (transactionAttribute != null) {_			transactionAttribute = TestContextTransactionUtils.createDelegatingTransactionAttribute(testContext,_				transactionAttribute)___			if (logger.isDebugEnabled()) {_				logger.debug("Explicit transaction definition [" + transactionAttribute + "] found for test context "_						+ testContext)__			}__			if (transactionAttribute.getPropagationBehavior() == TransactionDefinition.PROPAGATION_NOT_SUPPORTED) {_				return__			}__			tm = getTransactionManager(testContext, transactionAttribute.getQualifier())__		}__		if (tm != null) {_			txContext = new TransactionContext(testContext, tm, transactionAttribute, isRollback(testContext))__			runBeforeTransactionMethods(testContext)__			txContext.startTransaction()__			TransactionContextHolder.setCurrentTransactionContext(txContext)__		}_	};if,the,test,method,of,the,supplied,linkplain,test,context,test,context,is,configured,to,run,within,a,transaction,this,method,will,run,link,before,transaction,before,transaction,methods,and,start,a,new,transaction,p,note,that,if,a,code,before,transaction,method,fails,any,remaining,code,before,transaction,methods,will,not,be,invoked,and,a,transaction,will,not,be,started,see,org,springframework,transaction,annotation,transactional,see,get,transaction,manager,test,context,string;override,public,void,before,test,method,final,test,context,test,context,throws,exception,final,method,test,method,test,context,get,test,method,final,class,test,class,test,context,get,test,class,assert,not,null,test,method,the,test,method,of,the,supplied,test,context,must,not,be,null,transaction,context,tx,context,transaction,context,holder,remove,current,transaction,context,if,tx,context,null,throw,new,illegal,state,exception,cannot,start,a,new,transaction,without,ending,the,existing,transaction,platform,transaction,manager,tm,null,transaction,attribute,transaction,attribute,this,attribute,source,get,transaction,attribute,test,method,test,class,if,transaction,attribute,null,transaction,attribute,test,context,transaction,utils,create,delegating,transaction,attribute,test,context,transaction,attribute,if,logger,is,debug,enabled,logger,debug,explicit,transaction,definition,transaction,attribute,found,for,test,context,test,context,if,transaction,attribute,get,propagation,behavior,transaction,definition,return,tm,get,transaction,manager,test,context,transaction,attribute,get,qualifier,if,tm,null,tx,context,new,transaction,context,test,context,tm,transaction,attribute,is,rollback,test,context,run,before,transaction,methods,test,context,tx,context,start,transaction,transaction,context,holder,set,current,transaction,context,tx,context
TransactionalTestExecutionListener -> @Override 	public void beforeTestMethod(final TestContext testContext) throws Exception;1432125256;If the test method of the supplied {@linkplain TestContext test context}_is configured to run within a transaction, this method will run_{@link BeforeTransaction @BeforeTransaction} methods and start a new_transaction._<p>Note that if a {@code @BeforeTransaction} method fails, any remaining_{@code @BeforeTransaction} methods will not be invoked, and a transaction_will not be started._@see org.springframework.transaction.annotation.Transactional_@see #getTransactionManager(TestContext, String);@Override_	public void beforeTestMethod(final TestContext testContext) throws Exception {_		final Method testMethod = testContext.getTestMethod()__		final Class<?> testClass = testContext.getTestClass()__		Assert.notNull(testMethod, "The test method of the supplied TestContext must not be null")___		TransactionContext txContext = TransactionContextHolder.removeCurrentTransactionContext()__		if (txContext != null) {_			throw new IllegalStateException("Cannot start a new transaction without ending the existing transaction.")__		}__		PlatformTransactionManager tm = null__		TransactionAttribute transactionAttribute = this.attributeSource.getTransactionAttribute(testMethod, testClass)___		if (transactionAttribute != null) {_			transactionAttribute = TestContextTransactionUtils.createDelegatingTransactionAttribute(testContext,_				transactionAttribute)___			if (logger.isDebugEnabled()) {_				logger.debug("Explicit transaction definition [" + transactionAttribute + "] found for test context "_						+ testContext)__			}__			if (transactionAttribute.getPropagationBehavior() == TransactionDefinition.PROPAGATION_NOT_SUPPORTED) {_				return__			}__			tm = getTransactionManager(testContext, transactionAttribute.getQualifier())__		}__		if (tm != null) {_			txContext = new TransactionContext(testContext, tm, transactionAttribute, isRollback(testContext))__			runBeforeTransactionMethods(testContext)__			txContext.startTransaction()__			TransactionContextHolder.setCurrentTransactionContext(txContext)__		}_	};if,the,test,method,of,the,supplied,linkplain,test,context,test,context,is,configured,to,run,within,a,transaction,this,method,will,run,link,before,transaction,before,transaction,methods,and,start,a,new,transaction,p,note,that,if,a,code,before,transaction,method,fails,any,remaining,code,before,transaction,methods,will,not,be,invoked,and,a,transaction,will,not,be,started,see,org,springframework,transaction,annotation,transactional,see,get,transaction,manager,test,context,string;override,public,void,before,test,method,final,test,context,test,context,throws,exception,final,method,test,method,test,context,get,test,method,final,class,test,class,test,context,get,test,class,assert,not,null,test,method,the,test,method,of,the,supplied,test,context,must,not,be,null,transaction,context,tx,context,transaction,context,holder,remove,current,transaction,context,if,tx,context,null,throw,new,illegal,state,exception,cannot,start,a,new,transaction,without,ending,the,existing,transaction,platform,transaction,manager,tm,null,transaction,attribute,transaction,attribute,this,attribute,source,get,transaction,attribute,test,method,test,class,if,transaction,attribute,null,transaction,attribute,test,context,transaction,utils,create,delegating,transaction,attribute,test,context,transaction,attribute,if,logger,is,debug,enabled,logger,debug,explicit,transaction,definition,transaction,attribute,found,for,test,context,test,context,if,transaction,attribute,get,propagation,behavior,transaction,definition,return,tm,get,transaction,manager,test,context,transaction,attribute,get,qualifier,if,tm,null,tx,context,new,transaction,context,test,context,tm,transaction,attribute,is,rollback,test,context,run,before,transaction,methods,test,context,tx,context,start,transaction,transaction,context,holder,set,current,transaction,context,tx,context
TransactionalTestExecutionListener -> @Override 	public void beforeTestMethod(final TestContext testContext) throws Exception;1432856630;If the test method of the supplied {@linkplain TestContext test context}_is configured to run within a transaction, this method will run_{@link BeforeTransaction @BeforeTransaction} methods and start a new_transaction._<p>Note that if a {@code @BeforeTransaction} method fails, any remaining_{@code @BeforeTransaction} methods will not be invoked, and a transaction_will not be started._@see org.springframework.transaction.annotation.Transactional_@see #getTransactionManager(TestContext, String);@Override_	public void beforeTestMethod(final TestContext testContext) throws Exception {_		final Method testMethod = testContext.getTestMethod()__		final Class<?> testClass = testContext.getTestClass()__		Assert.notNull(testMethod, "The test method of the supplied TestContext must not be null")___		TransactionContext txContext = TransactionContextHolder.removeCurrentTransactionContext()__		if (txContext != null) {_			throw new IllegalStateException("Cannot start a new transaction without ending the existing transaction.")__		}__		PlatformTransactionManager tm = null__		TransactionAttribute transactionAttribute = this.attributeSource.getTransactionAttribute(testMethod, testClass)___		if (transactionAttribute != null) {_			transactionAttribute = TestContextTransactionUtils.createDelegatingTransactionAttribute(testContext,_				transactionAttribute)___			if (logger.isDebugEnabled()) {_				logger.debug("Explicit transaction definition [" + transactionAttribute + "] found for test context "_						+ testContext)__			}__			if (transactionAttribute.getPropagationBehavior() == TransactionDefinition.PROPAGATION_NOT_SUPPORTED) {_				return__			}__			tm = getTransactionManager(testContext, transactionAttribute.getQualifier())__		}__		if (tm != null) {_			txContext = new TransactionContext(testContext, tm, transactionAttribute, isRollback(testContext))__			runBeforeTransactionMethods(testContext)__			txContext.startTransaction()__			TransactionContextHolder.setCurrentTransactionContext(txContext)__		}_	};if,the,test,method,of,the,supplied,linkplain,test,context,test,context,is,configured,to,run,within,a,transaction,this,method,will,run,link,before,transaction,before,transaction,methods,and,start,a,new,transaction,p,note,that,if,a,code,before,transaction,method,fails,any,remaining,code,before,transaction,methods,will,not,be,invoked,and,a,transaction,will,not,be,started,see,org,springframework,transaction,annotation,transactional,see,get,transaction,manager,test,context,string;override,public,void,before,test,method,final,test,context,test,context,throws,exception,final,method,test,method,test,context,get,test,method,final,class,test,class,test,context,get,test,class,assert,not,null,test,method,the,test,method,of,the,supplied,test,context,must,not,be,null,transaction,context,tx,context,transaction,context,holder,remove,current,transaction,context,if,tx,context,null,throw,new,illegal,state,exception,cannot,start,a,new,transaction,without,ending,the,existing,transaction,platform,transaction,manager,tm,null,transaction,attribute,transaction,attribute,this,attribute,source,get,transaction,attribute,test,method,test,class,if,transaction,attribute,null,transaction,attribute,test,context,transaction,utils,create,delegating,transaction,attribute,test,context,transaction,attribute,if,logger,is,debug,enabled,logger,debug,explicit,transaction,definition,transaction,attribute,found,for,test,context,test,context,if,transaction,attribute,get,propagation,behavior,transaction,definition,return,tm,get,transaction,manager,test,context,transaction,attribute,get,qualifier,if,tm,null,tx,context,new,transaction,context,test,context,tm,transaction,attribute,is,rollback,test,context,run,before,transaction,methods,test,context,tx,context,start,transaction,transaction,context,holder,set,current,transaction,context,tx,context
TransactionalTestExecutionListener -> @Override 	public void beforeTestMethod(final TestContext testContext) throws Exception;1434234880;If the test method of the supplied {@linkplain TestContext test context}_is configured to run within a transaction, this method will run_{@link BeforeTransaction @BeforeTransaction} methods and start a new_transaction._<p>Note that if a {@code @BeforeTransaction} method fails, any remaining_{@code @BeforeTransaction} methods will not be invoked, and a transaction_will not be started._@see org.springframework.transaction.annotation.Transactional_@see #getTransactionManager(TestContext, String);@Override_	public void beforeTestMethod(final TestContext testContext) throws Exception {_		final Method testMethod = testContext.getTestMethod()__		final Class<?> testClass = testContext.getTestClass()__		Assert.notNull(testMethod, "The test method of the supplied TestContext must not be null")___		TransactionContext txContext = TransactionContextHolder.removeCurrentTransactionContext()__		if (txContext != null) {_			throw new IllegalStateException("Cannot start a new transaction without ending the existing transaction.")__		}__		PlatformTransactionManager tm = null__		TransactionAttribute transactionAttribute = this.attributeSource.getTransactionAttribute(testMethod, testClass)___		if (transactionAttribute != null) {_			transactionAttribute = TestContextTransactionUtils.createDelegatingTransactionAttribute(testContext,_				transactionAttribute)___			if (logger.isDebugEnabled()) {_				logger.debug("Explicit transaction definition [" + transactionAttribute + "] found for test context "_						+ testContext)__			}__			if (transactionAttribute.getPropagationBehavior() == TransactionDefinition.PROPAGATION_NOT_SUPPORTED) {_				return__			}__			tm = getTransactionManager(testContext, transactionAttribute.getQualifier())__		}__		if (tm != null) {_			txContext = new TransactionContext(testContext, tm, transactionAttribute, isRollback(testContext))__			runBeforeTransactionMethods(testContext)__			txContext.startTransaction()__			TransactionContextHolder.setCurrentTransactionContext(txContext)__		}_	};if,the,test,method,of,the,supplied,linkplain,test,context,test,context,is,configured,to,run,within,a,transaction,this,method,will,run,link,before,transaction,before,transaction,methods,and,start,a,new,transaction,p,note,that,if,a,code,before,transaction,method,fails,any,remaining,code,before,transaction,methods,will,not,be,invoked,and,a,transaction,will,not,be,started,see,org,springframework,transaction,annotation,transactional,see,get,transaction,manager,test,context,string;override,public,void,before,test,method,final,test,context,test,context,throws,exception,final,method,test,method,test,context,get,test,method,final,class,test,class,test,context,get,test,class,assert,not,null,test,method,the,test,method,of,the,supplied,test,context,must,not,be,null,transaction,context,tx,context,transaction,context,holder,remove,current,transaction,context,if,tx,context,null,throw,new,illegal,state,exception,cannot,start,a,new,transaction,without,ending,the,existing,transaction,platform,transaction,manager,tm,null,transaction,attribute,transaction,attribute,this,attribute,source,get,transaction,attribute,test,method,test,class,if,transaction,attribute,null,transaction,attribute,test,context,transaction,utils,create,delegating,transaction,attribute,test,context,transaction,attribute,if,logger,is,debug,enabled,logger,debug,explicit,transaction,definition,transaction,attribute,found,for,test,context,test,context,if,transaction,attribute,get,propagation,behavior,transaction,definition,return,tm,get,transaction,manager,test,context,transaction,attribute,get,qualifier,if,tm,null,tx,context,new,transaction,context,test,context,tm,transaction,attribute,is,rollback,test,context,run,before,transaction,methods,test,context,tx,context,start,transaction,transaction,context,holder,set,current,transaction,context,tx,context
TransactionalTestExecutionListener -> @Override 	public void beforeTestMethod(final TestContext testContext) throws Exception;1434720443;If the test method of the supplied {@linkplain TestContext test context}_is configured to run within a transaction, this method will run_{@link BeforeTransaction @BeforeTransaction} methods and start a new_transaction._<p>Note that if a {@code @BeforeTransaction} method fails, any remaining_{@code @BeforeTransaction} methods will not be invoked, and a transaction_will not be started._@see org.springframework.transaction.annotation.Transactional_@see #getTransactionManager(TestContext, String);@Override_	public void beforeTestMethod(final TestContext testContext) throws Exception {_		final Method testMethod = testContext.getTestMethod()__		final Class<?> testClass = testContext.getTestClass()__		Assert.notNull(testMethod, "The test method of the supplied TestContext must not be null")___		TransactionContext txContext = TransactionContextHolder.removeCurrentTransactionContext()__		if (txContext != null) {_			throw new IllegalStateException("Cannot start a new transaction without ending the existing transaction.")__		}__		PlatformTransactionManager tm = null__		TransactionAttribute transactionAttribute = this.attributeSource.getTransactionAttribute(testMethod, testClass)___		if (transactionAttribute != null) {_			transactionAttribute = TestContextTransactionUtils.createDelegatingTransactionAttribute(testContext,_				transactionAttribute)___			if (logger.isDebugEnabled()) {_				logger.debug("Explicit transaction definition [" + transactionAttribute + "] found for test context "_						+ testContext)__			}__			if (transactionAttribute.getPropagationBehavior() == TransactionDefinition.PROPAGATION_NOT_SUPPORTED) {_				return__			}__			tm = getTransactionManager(testContext, transactionAttribute.getQualifier())__		}__		if (tm != null) {_			txContext = new TransactionContext(testContext, tm, transactionAttribute, isRollback(testContext))__			runBeforeTransactionMethods(testContext)__			txContext.startTransaction()__			TransactionContextHolder.setCurrentTransactionContext(txContext)__		}_	};if,the,test,method,of,the,supplied,linkplain,test,context,test,context,is,configured,to,run,within,a,transaction,this,method,will,run,link,before,transaction,before,transaction,methods,and,start,a,new,transaction,p,note,that,if,a,code,before,transaction,method,fails,any,remaining,code,before,transaction,methods,will,not,be,invoked,and,a,transaction,will,not,be,started,see,org,springframework,transaction,annotation,transactional,see,get,transaction,manager,test,context,string;override,public,void,before,test,method,final,test,context,test,context,throws,exception,final,method,test,method,test,context,get,test,method,final,class,test,class,test,context,get,test,class,assert,not,null,test,method,the,test,method,of,the,supplied,test,context,must,not,be,null,transaction,context,tx,context,transaction,context,holder,remove,current,transaction,context,if,tx,context,null,throw,new,illegal,state,exception,cannot,start,a,new,transaction,without,ending,the,existing,transaction,platform,transaction,manager,tm,null,transaction,attribute,transaction,attribute,this,attribute,source,get,transaction,attribute,test,method,test,class,if,transaction,attribute,null,transaction,attribute,test,context,transaction,utils,create,delegating,transaction,attribute,test,context,transaction,attribute,if,logger,is,debug,enabled,logger,debug,explicit,transaction,definition,transaction,attribute,found,for,test,context,test,context,if,transaction,attribute,get,propagation,behavior,transaction,definition,return,tm,get,transaction,manager,test,context,transaction,attribute,get,qualifier,if,tm,null,tx,context,new,transaction,context,test,context,tm,transaction,attribute,is,rollback,test,context,run,before,transaction,methods,test,context,tx,context,start,transaction,transaction,context,holder,set,current,transaction,context,tx,context
TransactionalTestExecutionListener -> @Override 	public void beforeTestMethod(final TestContext testContext) throws Exception;1434817656;If the test method of the supplied {@linkplain TestContext test context}_is configured to run within a transaction, this method will run_{@link BeforeTransaction @BeforeTransaction} methods and start a new_transaction._<p>Note that if a {@code @BeforeTransaction} method fails, any remaining_{@code @BeforeTransaction} methods will not be invoked, and a transaction_will not be started._@see org.springframework.transaction.annotation.Transactional_@see #getTransactionManager(TestContext, String);@Override_	public void beforeTestMethod(final TestContext testContext) throws Exception {_		final Method testMethod = testContext.getTestMethod()__		final Class<?> testClass = testContext.getTestClass()__		Assert.notNull(testMethod, "The test method of the supplied TestContext must not be null")___		TransactionContext txContext = TransactionContextHolder.removeCurrentTransactionContext()__		if (txContext != null) {_			throw new IllegalStateException("Cannot start a new transaction without ending the existing transaction.")__		}__		PlatformTransactionManager tm = null__		TransactionAttribute transactionAttribute = this.attributeSource.getTransactionAttribute(testMethod, testClass)___		if (transactionAttribute != null) {_			transactionAttribute = TestContextTransactionUtils.createDelegatingTransactionAttribute(testContext,_				transactionAttribute)___			if (logger.isDebugEnabled()) {_				logger.debug("Explicit transaction definition [" + transactionAttribute + "] found for test context "_						+ testContext)__			}__			if (transactionAttribute.getPropagationBehavior() == TransactionDefinition.PROPAGATION_NOT_SUPPORTED) {_				return__			}__			tm = getTransactionManager(testContext, transactionAttribute.getQualifier())__		}__		if (tm != null) {_			txContext = new TransactionContext(testContext, tm, transactionAttribute, isRollback(testContext))__			runBeforeTransactionMethods(testContext)__			txContext.startTransaction()__			TransactionContextHolder.setCurrentTransactionContext(txContext)__		}_	};if,the,test,method,of,the,supplied,linkplain,test,context,test,context,is,configured,to,run,within,a,transaction,this,method,will,run,link,before,transaction,before,transaction,methods,and,start,a,new,transaction,p,note,that,if,a,code,before,transaction,method,fails,any,remaining,code,before,transaction,methods,will,not,be,invoked,and,a,transaction,will,not,be,started,see,org,springframework,transaction,annotation,transactional,see,get,transaction,manager,test,context,string;override,public,void,before,test,method,final,test,context,test,context,throws,exception,final,method,test,method,test,context,get,test,method,final,class,test,class,test,context,get,test,class,assert,not,null,test,method,the,test,method,of,the,supplied,test,context,must,not,be,null,transaction,context,tx,context,transaction,context,holder,remove,current,transaction,context,if,tx,context,null,throw,new,illegal,state,exception,cannot,start,a,new,transaction,without,ending,the,existing,transaction,platform,transaction,manager,tm,null,transaction,attribute,transaction,attribute,this,attribute,source,get,transaction,attribute,test,method,test,class,if,transaction,attribute,null,transaction,attribute,test,context,transaction,utils,create,delegating,transaction,attribute,test,context,transaction,attribute,if,logger,is,debug,enabled,logger,debug,explicit,transaction,definition,transaction,attribute,found,for,test,context,test,context,if,transaction,attribute,get,propagation,behavior,transaction,definition,return,tm,get,transaction,manager,test,context,transaction,attribute,get,qualifier,if,tm,null,tx,context,new,transaction,context,test,context,tm,transaction,attribute,is,rollback,test,context,run,before,transaction,methods,test,context,tx,context,start,transaction,transaction,context,holder,set,current,transaction,context,tx,context
TransactionalTestExecutionListener -> @Override 	public void beforeTestMethod(final TestContext testContext) throws Exception;1437841346;If the test method of the supplied {@linkplain TestContext test context}_is configured to run within a transaction, this method will run_{@link BeforeTransaction @BeforeTransaction} methods and start a new_transaction._<p>Note that if a {@code @BeforeTransaction} method fails, any remaining_{@code @BeforeTransaction} methods will not be invoked, and a transaction_will not be started._@see org.springframework.transaction.annotation.Transactional_@see #getTransactionManager(TestContext, String);@Override_	public void beforeTestMethod(final TestContext testContext) throws Exception {_		final Method testMethod = testContext.getTestMethod()__		final Class<?> testClass = testContext.getTestClass()__		Assert.notNull(testMethod, "The test method of the supplied TestContext must not be null")___		TransactionContext txContext = TransactionContextHolder.removeCurrentTransactionContext()__		if (txContext != null) {_			throw new IllegalStateException("Cannot start a new transaction without ending the existing transaction.")__		}__		PlatformTransactionManager tm = null__		TransactionAttribute transactionAttribute = this.attributeSource.getTransactionAttribute(testMethod, testClass)___		if (transactionAttribute != null) {_			transactionAttribute = TestContextTransactionUtils.createDelegatingTransactionAttribute(testContext,_				transactionAttribute)___			if (logger.isDebugEnabled()) {_				logger.debug("Explicit transaction definition [" + transactionAttribute + "] found for test context "_						+ testContext)__			}__			if (transactionAttribute.getPropagationBehavior() == TransactionDefinition.PROPAGATION_NOT_SUPPORTED) {_				return__			}__			tm = getTransactionManager(testContext, transactionAttribute.getQualifier())__		}__		if (tm != null) {_			txContext = new TransactionContext(testContext, tm, transactionAttribute, isRollback(testContext))__			runBeforeTransactionMethods(testContext)__			txContext.startTransaction()__			TransactionContextHolder.setCurrentTransactionContext(txContext)__		}_	};if,the,test,method,of,the,supplied,linkplain,test,context,test,context,is,configured,to,run,within,a,transaction,this,method,will,run,link,before,transaction,before,transaction,methods,and,start,a,new,transaction,p,note,that,if,a,code,before,transaction,method,fails,any,remaining,code,before,transaction,methods,will,not,be,invoked,and,a,transaction,will,not,be,started,see,org,springframework,transaction,annotation,transactional,see,get,transaction,manager,test,context,string;override,public,void,before,test,method,final,test,context,test,context,throws,exception,final,method,test,method,test,context,get,test,method,final,class,test,class,test,context,get,test,class,assert,not,null,test,method,the,test,method,of,the,supplied,test,context,must,not,be,null,transaction,context,tx,context,transaction,context,holder,remove,current,transaction,context,if,tx,context,null,throw,new,illegal,state,exception,cannot,start,a,new,transaction,without,ending,the,existing,transaction,platform,transaction,manager,tm,null,transaction,attribute,transaction,attribute,this,attribute,source,get,transaction,attribute,test,method,test,class,if,transaction,attribute,null,transaction,attribute,test,context,transaction,utils,create,delegating,transaction,attribute,test,context,transaction,attribute,if,logger,is,debug,enabled,logger,debug,explicit,transaction,definition,transaction,attribute,found,for,test,context,test,context,if,transaction,attribute,get,propagation,behavior,transaction,definition,return,tm,get,transaction,manager,test,context,transaction,attribute,get,qualifier,if,tm,null,tx,context,new,transaction,context,test,context,tm,transaction,attribute,is,rollback,test,context,run,before,transaction,methods,test,context,tx,context,start,transaction,transaction,context,holder,set,current,transaction,context,tx,context
TransactionalTestExecutionListener -> @Override 	public void beforeTestMethod(final TestContext testContext) throws Exception;1437851372;If the test method of the supplied {@linkplain TestContext test context}_is configured to run within a transaction, this method will run_{@link BeforeTransaction @BeforeTransaction} methods and start a new_transaction._<p>Note that if a {@code @BeforeTransaction} method fails, any remaining_{@code @BeforeTransaction} methods will not be invoked, and a transaction_will not be started._@see org.springframework.transaction.annotation.Transactional_@see #getTransactionManager(TestContext, String);@Override_	public void beforeTestMethod(final TestContext testContext) throws Exception {_		final Method testMethod = testContext.getTestMethod()__		final Class<?> testClass = testContext.getTestClass()__		Assert.notNull(testMethod, "The test method of the supplied TestContext must not be null")___		TransactionContext txContext = TransactionContextHolder.removeCurrentTransactionContext()__		if (txContext != null) {_			throw new IllegalStateException("Cannot start a new transaction without ending the existing transaction.")__		}__		PlatformTransactionManager tm = null__		TransactionAttribute transactionAttribute = this.attributeSource.getTransactionAttribute(testMethod, testClass)___		if (transactionAttribute != null) {_			transactionAttribute = TestContextTransactionUtils.createDelegatingTransactionAttribute(testContext,_				transactionAttribute)___			if (logger.isDebugEnabled()) {_				logger.debug("Explicit transaction definition [" + transactionAttribute + "] found for test context "_						+ testContext)__			}__			if (transactionAttribute.getPropagationBehavior() == TransactionDefinition.PROPAGATION_NOT_SUPPORTED) {_				return__			}__			tm = getTransactionManager(testContext, transactionAttribute.getQualifier())__		}__		if (tm != null) {_			txContext = new TransactionContext(testContext, tm, transactionAttribute, isRollback(testContext))__			runBeforeTransactionMethods(testContext)__			txContext.startTransaction()__			TransactionContextHolder.setCurrentTransactionContext(txContext)__		}_	};if,the,test,method,of,the,supplied,linkplain,test,context,test,context,is,configured,to,run,within,a,transaction,this,method,will,run,link,before,transaction,before,transaction,methods,and,start,a,new,transaction,p,note,that,if,a,code,before,transaction,method,fails,any,remaining,code,before,transaction,methods,will,not,be,invoked,and,a,transaction,will,not,be,started,see,org,springframework,transaction,annotation,transactional,see,get,transaction,manager,test,context,string;override,public,void,before,test,method,final,test,context,test,context,throws,exception,final,method,test,method,test,context,get,test,method,final,class,test,class,test,context,get,test,class,assert,not,null,test,method,the,test,method,of,the,supplied,test,context,must,not,be,null,transaction,context,tx,context,transaction,context,holder,remove,current,transaction,context,if,tx,context,null,throw,new,illegal,state,exception,cannot,start,a,new,transaction,without,ending,the,existing,transaction,platform,transaction,manager,tm,null,transaction,attribute,transaction,attribute,this,attribute,source,get,transaction,attribute,test,method,test,class,if,transaction,attribute,null,transaction,attribute,test,context,transaction,utils,create,delegating,transaction,attribute,test,context,transaction,attribute,if,logger,is,debug,enabled,logger,debug,explicit,transaction,definition,transaction,attribute,found,for,test,context,test,context,if,transaction,attribute,get,propagation,behavior,transaction,definition,return,tm,get,transaction,manager,test,context,transaction,attribute,get,qualifier,if,tm,null,tx,context,new,transaction,context,test,context,tm,transaction,attribute,is,rollback,test,context,run,before,transaction,methods,test,context,tx,context,start,transaction,transaction,context,holder,set,current,transaction,context,tx,context
TransactionalTestExecutionListener -> @Override 	public void beforeTestMethod(final TestContext testContext) throws Exception;1437852597;If the test method of the supplied {@linkplain TestContext test context}_is configured to run within a transaction, this method will run_{@link BeforeTransaction @BeforeTransaction} methods and start a new_transaction._<p>Note that if a {@code @BeforeTransaction} method fails, any remaining_{@code @BeforeTransaction} methods will not be invoked, and a transaction_will not be started._@see org.springframework.transaction.annotation.Transactional_@see #getTransactionManager(TestContext, String);@Override_	public void beforeTestMethod(final TestContext testContext) throws Exception {_		final Method testMethod = testContext.getTestMethod()__		final Class<?> testClass = testContext.getTestClass()__		Assert.notNull(testMethod, "The test method of the supplied TestContext must not be null")___		TransactionContext txContext = TransactionContextHolder.removeCurrentTransactionContext()__		if (txContext != null) {_			throw new IllegalStateException("Cannot start a new transaction without ending the existing transaction.")__		}__		PlatformTransactionManager tm = null__		TransactionAttribute transactionAttribute = this.attributeSource.getTransactionAttribute(testMethod, testClass)___		if (transactionAttribute != null) {_			transactionAttribute = TestContextTransactionUtils.createDelegatingTransactionAttribute(testContext,_				transactionAttribute)___			if (logger.isDebugEnabled()) {_				logger.debug("Explicit transaction definition [" + transactionAttribute + "] found for test context "_						+ testContext)__			}__			if (transactionAttribute.getPropagationBehavior() == TransactionDefinition.PROPAGATION_NOT_SUPPORTED) {_				return__			}__			tm = getTransactionManager(testContext, transactionAttribute.getQualifier())__		}__		if (tm != null) {_			txContext = new TransactionContext(testContext, tm, transactionAttribute, isRollback(testContext))__			runBeforeTransactionMethods(testContext)__			txContext.startTransaction()__			TransactionContextHolder.setCurrentTransactionContext(txContext)__		}_	};if,the,test,method,of,the,supplied,linkplain,test,context,test,context,is,configured,to,run,within,a,transaction,this,method,will,run,link,before,transaction,before,transaction,methods,and,start,a,new,transaction,p,note,that,if,a,code,before,transaction,method,fails,any,remaining,code,before,transaction,methods,will,not,be,invoked,and,a,transaction,will,not,be,started,see,org,springframework,transaction,annotation,transactional,see,get,transaction,manager,test,context,string;override,public,void,before,test,method,final,test,context,test,context,throws,exception,final,method,test,method,test,context,get,test,method,final,class,test,class,test,context,get,test,class,assert,not,null,test,method,the,test,method,of,the,supplied,test,context,must,not,be,null,transaction,context,tx,context,transaction,context,holder,remove,current,transaction,context,if,tx,context,null,throw,new,illegal,state,exception,cannot,start,a,new,transaction,without,ending,the,existing,transaction,platform,transaction,manager,tm,null,transaction,attribute,transaction,attribute,this,attribute,source,get,transaction,attribute,test,method,test,class,if,transaction,attribute,null,transaction,attribute,test,context,transaction,utils,create,delegating,transaction,attribute,test,context,transaction,attribute,if,logger,is,debug,enabled,logger,debug,explicit,transaction,definition,transaction,attribute,found,for,test,context,test,context,if,transaction,attribute,get,propagation,behavior,transaction,definition,return,tm,get,transaction,manager,test,context,transaction,attribute,get,qualifier,if,tm,null,tx,context,new,transaction,context,test,context,tm,transaction,attribute,is,rollback,test,context,run,before,transaction,methods,test,context,tx,context,start,transaction,transaction,context,holder,set,current,transaction,context,tx,context
TransactionalTestExecutionListener -> @Override 	public void beforeTestMethod(final TestContext testContext) throws Exception;1454507787;If the test method of the supplied {@linkplain TestContext test context}_is configured to run within a transaction, this method will run_{@link BeforeTransaction @BeforeTransaction} methods and start a new_transaction._<p>Note that if a {@code @BeforeTransaction} method fails, any remaining_{@code @BeforeTransaction} methods will not be invoked, and a transaction_will not be started._@see org.springframework.transaction.annotation.Transactional_@see #getTransactionManager(TestContext, String);@Override_	public void beforeTestMethod(final TestContext testContext) throws Exception {_		final Method testMethod = testContext.getTestMethod()__		final Class<?> testClass = testContext.getTestClass()__		Assert.notNull(testMethod, "The test method of the supplied TestContext must not be null")___		TransactionContext txContext = TransactionContextHolder.removeCurrentTransactionContext()__		if (txContext != null) {_			throw new IllegalStateException("Cannot start a new transaction without ending the existing transaction.")__		}__		PlatformTransactionManager tm = null__		TransactionAttribute transactionAttribute = this.attributeSource.getTransactionAttribute(testMethod, testClass)___		if (transactionAttribute != null) {_			transactionAttribute = TestContextTransactionUtils.createDelegatingTransactionAttribute(testContext,_				transactionAttribute)___			if (logger.isDebugEnabled()) {_				logger.debug("Explicit transaction definition [" + transactionAttribute + "] found for test context "_						+ testContext)__			}__			if (transactionAttribute.getPropagationBehavior() == TransactionDefinition.PROPAGATION_NOT_SUPPORTED) {_				return__			}__			tm = getTransactionManager(testContext, transactionAttribute.getQualifier())___			if (tm == null) {_				throw new IllegalStateException(String.format(_					"Failed to retrieve PlatformTransactionManager for @Transactional test for test context %s.",_					testContext))__			}_		}__		if (tm != null) {_			txContext = new TransactionContext(testContext, tm, transactionAttribute, isRollback(testContext))__			runBeforeTransactionMethods(testContext)__			txContext.startTransaction()__			TransactionContextHolder.setCurrentTransactionContext(txContext)__		}_	};if,the,test,method,of,the,supplied,linkplain,test,context,test,context,is,configured,to,run,within,a,transaction,this,method,will,run,link,before,transaction,before,transaction,methods,and,start,a,new,transaction,p,note,that,if,a,code,before,transaction,method,fails,any,remaining,code,before,transaction,methods,will,not,be,invoked,and,a,transaction,will,not,be,started,see,org,springframework,transaction,annotation,transactional,see,get,transaction,manager,test,context,string;override,public,void,before,test,method,final,test,context,test,context,throws,exception,final,method,test,method,test,context,get,test,method,final,class,test,class,test,context,get,test,class,assert,not,null,test,method,the,test,method,of,the,supplied,test,context,must,not,be,null,transaction,context,tx,context,transaction,context,holder,remove,current,transaction,context,if,tx,context,null,throw,new,illegal,state,exception,cannot,start,a,new,transaction,without,ending,the,existing,transaction,platform,transaction,manager,tm,null,transaction,attribute,transaction,attribute,this,attribute,source,get,transaction,attribute,test,method,test,class,if,transaction,attribute,null,transaction,attribute,test,context,transaction,utils,create,delegating,transaction,attribute,test,context,transaction,attribute,if,logger,is,debug,enabled,logger,debug,explicit,transaction,definition,transaction,attribute,found,for,test,context,test,context,if,transaction,attribute,get,propagation,behavior,transaction,definition,return,tm,get,transaction,manager,test,context,transaction,attribute,get,qualifier,if,tm,null,throw,new,illegal,state,exception,string,format,failed,to,retrieve,platform,transaction,manager,for,transactional,test,for,test,context,s,test,context,if,tm,null,tx,context,new,transaction,context,test,context,tm,transaction,attribute,is,rollback,test,context,run,before,transaction,methods,test,context,tx,context,start,transaction,transaction,context,holder,set,current,transaction,context,tx,context
TransactionalTestExecutionListener -> @Override 	public void beforeTestMethod(final TestContext testContext) throws Exception;1456702967;If the test method of the supplied {@linkplain TestContext test context}_is configured to run within a transaction, this method will run_{@link BeforeTransaction @BeforeTransaction} methods and start a new_transaction._<p>Note that if a {@code @BeforeTransaction} method fails, any remaining_{@code @BeforeTransaction} methods will not be invoked, and a transaction_will not be started._@see org.springframework.transaction.annotation.Transactional_@see #getTransactionManager(TestContext, String);@Override_	public void beforeTestMethod(final TestContext testContext) throws Exception {_		final Method testMethod = testContext.getTestMethod()__		final Class<?> testClass = testContext.getTestClass()__		Assert.notNull(testMethod, "The test method of the supplied TestContext must not be null")___		TransactionContext txContext = TransactionContextHolder.removeCurrentTransactionContext()__		if (txContext != null) {_			throw new IllegalStateException("Cannot start a new transaction without ending the existing transaction.")__		}__		PlatformTransactionManager tm = null__		TransactionAttribute transactionAttribute = this.attributeSource.getTransactionAttribute(testMethod, testClass)___		if (transactionAttribute != null) {_			transactionAttribute = TestContextTransactionUtils.createDelegatingTransactionAttribute(testContext,_				transactionAttribute)___			if (logger.isDebugEnabled()) {_				logger.debug("Explicit transaction definition [" + transactionAttribute + "] found for test context "_						+ testContext)__			}__			if (transactionAttribute.getPropagationBehavior() == TransactionDefinition.PROPAGATION_NOT_SUPPORTED) {_				return__			}__			tm = getTransactionManager(testContext, transactionAttribute.getQualifier())___			if (tm == null) {_				throw new IllegalStateException(String.format(_					"Failed to retrieve PlatformTransactionManager for @Transactional test for test context %s.",_					testContext))__			}_		}__		if (tm != null) {_			txContext = new TransactionContext(testContext, tm, transactionAttribute, isRollback(testContext))__			runBeforeTransactionMethods(testContext)__			txContext.startTransaction()__			TransactionContextHolder.setCurrentTransactionContext(txContext)__		}_	};if,the,test,method,of,the,supplied,linkplain,test,context,test,context,is,configured,to,run,within,a,transaction,this,method,will,run,link,before,transaction,before,transaction,methods,and,start,a,new,transaction,p,note,that,if,a,code,before,transaction,method,fails,any,remaining,code,before,transaction,methods,will,not,be,invoked,and,a,transaction,will,not,be,started,see,org,springframework,transaction,annotation,transactional,see,get,transaction,manager,test,context,string;override,public,void,before,test,method,final,test,context,test,context,throws,exception,final,method,test,method,test,context,get,test,method,final,class,test,class,test,context,get,test,class,assert,not,null,test,method,the,test,method,of,the,supplied,test,context,must,not,be,null,transaction,context,tx,context,transaction,context,holder,remove,current,transaction,context,if,tx,context,null,throw,new,illegal,state,exception,cannot,start,a,new,transaction,without,ending,the,existing,transaction,platform,transaction,manager,tm,null,transaction,attribute,transaction,attribute,this,attribute,source,get,transaction,attribute,test,method,test,class,if,transaction,attribute,null,transaction,attribute,test,context,transaction,utils,create,delegating,transaction,attribute,test,context,transaction,attribute,if,logger,is,debug,enabled,logger,debug,explicit,transaction,definition,transaction,attribute,found,for,test,context,test,context,if,transaction,attribute,get,propagation,behavior,transaction,definition,return,tm,get,transaction,manager,test,context,transaction,attribute,get,qualifier,if,tm,null,throw,new,illegal,state,exception,string,format,failed,to,retrieve,platform,transaction,manager,for,transactional,test,for,test,context,s,test,context,if,tm,null,tx,context,new,transaction,context,test,context,tm,transaction,attribute,is,rollback,test,context,run,before,transaction,methods,test,context,tx,context,start,transaction,transaction,context,holder,set,current,transaction,context,tx,context
TransactionalTestExecutionListener -> @Override 	public void beforeTestMethod(final TestContext testContext) throws Exception;1456756222;If the test method of the supplied {@linkplain TestContext test context}_is configured to run within a transaction, this method will run_{@link BeforeTransaction @BeforeTransaction} methods and start a new_transaction._<p>Note that if a {@code @BeforeTransaction} method fails, any remaining_{@code @BeforeTransaction} methods will not be invoked, and a transaction_will not be started._@see org.springframework.transaction.annotation.Transactional_@see #getTransactionManager(TestContext, String);@Override_	public void beforeTestMethod(final TestContext testContext) throws Exception {_		final Method testMethod = testContext.getTestMethod()__		final Class<?> testClass = testContext.getTestClass()__		Assert.notNull(testMethod, "The test method of the supplied TestContext must not be null")___		TransactionContext txContext = TransactionContextHolder.removeCurrentTransactionContext()__		if (txContext != null) {_			throw new IllegalStateException("Cannot start a new transaction without ending the existing transaction.")__		}__		PlatformTransactionManager tm = null__		TransactionAttribute transactionAttribute = this.attributeSource.getTransactionAttribute(testMethod, testClass)___		if (transactionAttribute != null) {_			transactionAttribute = TestContextTransactionUtils.createDelegatingTransactionAttribute(testContext,_				transactionAttribute)___			if (logger.isDebugEnabled()) {_				logger.debug("Explicit transaction definition [" + transactionAttribute + "] found for test context "_						+ testContext)__			}__			if (transactionAttribute.getPropagationBehavior() == TransactionDefinition.PROPAGATION_NOT_SUPPORTED) {_				return__			}__			tm = getTransactionManager(testContext, transactionAttribute.getQualifier())___			if (tm == null) {_				throw new IllegalStateException(String.format(_					"Failed to retrieve PlatformTransactionManager for @Transactional test for test context %s.",_					testContext))__			}_		}__		if (tm != null) {_			txContext = new TransactionContext(testContext, tm, transactionAttribute, isRollback(testContext))__			runBeforeTransactionMethods(testContext)__			txContext.startTransaction()__			TransactionContextHolder.setCurrentTransactionContext(txContext)__		}_	};if,the,test,method,of,the,supplied,linkplain,test,context,test,context,is,configured,to,run,within,a,transaction,this,method,will,run,link,before,transaction,before,transaction,methods,and,start,a,new,transaction,p,note,that,if,a,code,before,transaction,method,fails,any,remaining,code,before,transaction,methods,will,not,be,invoked,and,a,transaction,will,not,be,started,see,org,springframework,transaction,annotation,transactional,see,get,transaction,manager,test,context,string;override,public,void,before,test,method,final,test,context,test,context,throws,exception,final,method,test,method,test,context,get,test,method,final,class,test,class,test,context,get,test,class,assert,not,null,test,method,the,test,method,of,the,supplied,test,context,must,not,be,null,transaction,context,tx,context,transaction,context,holder,remove,current,transaction,context,if,tx,context,null,throw,new,illegal,state,exception,cannot,start,a,new,transaction,without,ending,the,existing,transaction,platform,transaction,manager,tm,null,transaction,attribute,transaction,attribute,this,attribute,source,get,transaction,attribute,test,method,test,class,if,transaction,attribute,null,transaction,attribute,test,context,transaction,utils,create,delegating,transaction,attribute,test,context,transaction,attribute,if,logger,is,debug,enabled,logger,debug,explicit,transaction,definition,transaction,attribute,found,for,test,context,test,context,if,transaction,attribute,get,propagation,behavior,transaction,definition,return,tm,get,transaction,manager,test,context,transaction,attribute,get,qualifier,if,tm,null,throw,new,illegal,state,exception,string,format,failed,to,retrieve,platform,transaction,manager,for,transactional,test,for,test,context,s,test,context,if,tm,null,tx,context,new,transaction,context,test,context,tm,transaction,attribute,is,rollback,test,context,run,before,transaction,methods,test,context,tx,context,start,transaction,transaction,context,holder,set,current,transaction,context,tx,context
TransactionalTestExecutionListener -> @Override 	public void beforeTestMethod(final TestContext testContext) throws Exception;1456756222;If the test method of the supplied {@linkplain TestContext test context}_is configured to run within a transaction, this method will run_{@link BeforeTransaction @BeforeTransaction} methods and start a new_transaction._<p>Note that if a {@code @BeforeTransaction} method fails, any remaining_{@code @BeforeTransaction} methods will not be invoked, and a transaction_will not be started._@see org.springframework.transaction.annotation.Transactional_@see #getTransactionManager(TestContext, String);@Override_	public void beforeTestMethod(final TestContext testContext) throws Exception {_		final Method testMethod = testContext.getTestMethod()__		final Class<?> testClass = testContext.getTestClass()__		Assert.notNull(testMethod, "The test method of the supplied TestContext must not be null")___		TransactionContext txContext = TransactionContextHolder.removeCurrentTransactionContext()__		if (txContext != null) {_			throw new IllegalStateException("Cannot start a new transaction without ending the existing transaction.")__		}__		PlatformTransactionManager tm = null__		TransactionAttribute transactionAttribute = this.attributeSource.getTransactionAttribute(testMethod, testClass)___		if (transactionAttribute != null) {_			transactionAttribute = TestContextTransactionUtils.createDelegatingTransactionAttribute(testContext,_				transactionAttribute)___			if (logger.isDebugEnabled()) {_				logger.debug("Explicit transaction definition [" + transactionAttribute + "] found for test context "_						+ testContext)__			}__			if (transactionAttribute.getPropagationBehavior() == TransactionDefinition.PROPAGATION_NOT_SUPPORTED) {_				return__			}__			tm = getTransactionManager(testContext, transactionAttribute.getQualifier())___			if (tm == null) {_				throw new IllegalStateException(String.format(_					"Failed to retrieve PlatformTransactionManager for @Transactional test for test context %s.",_					testContext))__			}_		}__		if (tm != null) {_			txContext = new TransactionContext(testContext, tm, transactionAttribute, isRollback(testContext))__			runBeforeTransactionMethods(testContext)__			txContext.startTransaction()__			TransactionContextHolder.setCurrentTransactionContext(txContext)__		}_	};if,the,test,method,of,the,supplied,linkplain,test,context,test,context,is,configured,to,run,within,a,transaction,this,method,will,run,link,before,transaction,before,transaction,methods,and,start,a,new,transaction,p,note,that,if,a,code,before,transaction,method,fails,any,remaining,code,before,transaction,methods,will,not,be,invoked,and,a,transaction,will,not,be,started,see,org,springframework,transaction,annotation,transactional,see,get,transaction,manager,test,context,string;override,public,void,before,test,method,final,test,context,test,context,throws,exception,final,method,test,method,test,context,get,test,method,final,class,test,class,test,context,get,test,class,assert,not,null,test,method,the,test,method,of,the,supplied,test,context,must,not,be,null,transaction,context,tx,context,transaction,context,holder,remove,current,transaction,context,if,tx,context,null,throw,new,illegal,state,exception,cannot,start,a,new,transaction,without,ending,the,existing,transaction,platform,transaction,manager,tm,null,transaction,attribute,transaction,attribute,this,attribute,source,get,transaction,attribute,test,method,test,class,if,transaction,attribute,null,transaction,attribute,test,context,transaction,utils,create,delegating,transaction,attribute,test,context,transaction,attribute,if,logger,is,debug,enabled,logger,debug,explicit,transaction,definition,transaction,attribute,found,for,test,context,test,context,if,transaction,attribute,get,propagation,behavior,transaction,definition,return,tm,get,transaction,manager,test,context,transaction,attribute,get,qualifier,if,tm,null,throw,new,illegal,state,exception,string,format,failed,to,retrieve,platform,transaction,manager,for,transactional,test,for,test,context,s,test,context,if,tm,null,tx,context,new,transaction,context,test,context,tm,transaction,attribute,is,rollback,test,context,run,before,transaction,methods,test,context,tx,context,start,transaction,transaction,context,holder,set,current,transaction,context,tx,context
TransactionalTestExecutionListener -> @Override 	public void beforeTestMethod(final TestContext testContext) throws Exception;1458754760;If the test method of the supplied {@linkplain TestContext test context}_is configured to run within a transaction, this method will run_{@link BeforeTransaction @BeforeTransaction} methods and start a new_transaction._<p>Note that if a {@code @BeforeTransaction} method fails, any remaining_{@code @BeforeTransaction} methods will not be invoked, and a transaction_will not be started._@see org.springframework.transaction.annotation.Transactional_@see #getTransactionManager(TestContext, String);@Override_	public void beforeTestMethod(final TestContext testContext) throws Exception {_		final Method testMethod = testContext.getTestMethod()__		final Class<?> testClass = testContext.getTestClass()__		Assert.notNull(testMethod, "The test method of the supplied TestContext must not be null")___		TransactionContext txContext = TransactionContextHolder.removeCurrentTransactionContext()__		if (txContext != null) {_			throw new IllegalStateException("Cannot start a new transaction without ending the existing transaction.")__		}__		PlatformTransactionManager tm = null__		TransactionAttribute transactionAttribute = this.attributeSource.getTransactionAttribute(testMethod, testClass)___		if (transactionAttribute != null) {_			transactionAttribute = TestContextTransactionUtils.createDelegatingTransactionAttribute(testContext,_				transactionAttribute)___			if (logger.isDebugEnabled()) {_				logger.debug("Explicit transaction definition [" + transactionAttribute + "] found for test context " +_						testContext)__			}__			if (transactionAttribute.getPropagationBehavior() == TransactionDefinition.PROPAGATION_NOT_SUPPORTED) {_				return__			}__			tm = getTransactionManager(testContext, transactionAttribute.getQualifier())___			if (tm == null) {_				throw new IllegalStateException(String.format(_						"Failed to retrieve PlatformTransactionManager for @Transactional test for test context %s.",_						testContext))__			}_		}__		if (tm != null) {_			txContext = new TransactionContext(testContext, tm, transactionAttribute, isRollback(testContext))__			runBeforeTransactionMethods(testContext)__			txContext.startTransaction()__			TransactionContextHolder.setCurrentTransactionContext(txContext)__		}_	};if,the,test,method,of,the,supplied,linkplain,test,context,test,context,is,configured,to,run,within,a,transaction,this,method,will,run,link,before,transaction,before,transaction,methods,and,start,a,new,transaction,p,note,that,if,a,code,before,transaction,method,fails,any,remaining,code,before,transaction,methods,will,not,be,invoked,and,a,transaction,will,not,be,started,see,org,springframework,transaction,annotation,transactional,see,get,transaction,manager,test,context,string;override,public,void,before,test,method,final,test,context,test,context,throws,exception,final,method,test,method,test,context,get,test,method,final,class,test,class,test,context,get,test,class,assert,not,null,test,method,the,test,method,of,the,supplied,test,context,must,not,be,null,transaction,context,tx,context,transaction,context,holder,remove,current,transaction,context,if,tx,context,null,throw,new,illegal,state,exception,cannot,start,a,new,transaction,without,ending,the,existing,transaction,platform,transaction,manager,tm,null,transaction,attribute,transaction,attribute,this,attribute,source,get,transaction,attribute,test,method,test,class,if,transaction,attribute,null,transaction,attribute,test,context,transaction,utils,create,delegating,transaction,attribute,test,context,transaction,attribute,if,logger,is,debug,enabled,logger,debug,explicit,transaction,definition,transaction,attribute,found,for,test,context,test,context,if,transaction,attribute,get,propagation,behavior,transaction,definition,return,tm,get,transaction,manager,test,context,transaction,attribute,get,qualifier,if,tm,null,throw,new,illegal,state,exception,string,format,failed,to,retrieve,platform,transaction,manager,for,transactional,test,for,test,context,s,test,context,if,tm,null,tx,context,new,transaction,context,test,context,tm,transaction,attribute,is,rollback,test,context,run,before,transaction,methods,test,context,tx,context,start,transaction,transaction,context,holder,set,current,transaction,context,tx,context
TransactionalTestExecutionListener -> @Override 	public void beforeTestMethod(final TestContext testContext) throws Exception;1462294651;If the test method of the supplied {@linkplain TestContext test context}_is configured to run within a transaction, this method will run_{@link BeforeTransaction @BeforeTransaction} methods and start a new_transaction._<p>Note that if a {@code @BeforeTransaction} method fails, any remaining_{@code @BeforeTransaction} methods will not be invoked, and a transaction_will not be started._@see org.springframework.transaction.annotation.Transactional_@see #getTransactionManager(TestContext, String);@Override_	public void beforeTestMethod(final TestContext testContext) throws Exception {_		final Method testMethod = testContext.getTestMethod()__		final Class<?> testClass = testContext.getTestClass()__		Assert.notNull(testMethod, "The test method of the supplied TestContext must not be null")___		TransactionContext txContext = TransactionContextHolder.removeCurrentTransactionContext()__		if (txContext != null) {_			throw new IllegalStateException("Cannot start a new transaction without ending the existing transaction.")__		}__		PlatformTransactionManager tm = null__		TransactionAttribute transactionAttribute = this.attributeSource.getTransactionAttribute(testMethod, testClass)___		if (transactionAttribute != null) {_			transactionAttribute = TestContextTransactionUtils.createDelegatingTransactionAttribute(testContext,_				transactionAttribute)___			if (logger.isDebugEnabled()) {_				logger.debug("Explicit transaction definition [" + transactionAttribute + "] found for test context " +_						testContext)__			}__			if (transactionAttribute.getPropagationBehavior() == TransactionDefinition.PROPAGATION_NOT_SUPPORTED) {_				return__			}__			tm = getTransactionManager(testContext, transactionAttribute.getQualifier())___			if (tm == null) {_				throw new IllegalStateException(String.format(_						"Failed to retrieve PlatformTransactionManager for @Transactional test for test context %s.",_						testContext))__			}_		}__		if (tm != null) {_			txContext = new TransactionContext(testContext, tm, transactionAttribute, isRollback(testContext))__			runBeforeTransactionMethods(testContext)__			txContext.startTransaction()__			TransactionContextHolder.setCurrentTransactionContext(txContext)__		}_	};if,the,test,method,of,the,supplied,linkplain,test,context,test,context,is,configured,to,run,within,a,transaction,this,method,will,run,link,before,transaction,before,transaction,methods,and,start,a,new,transaction,p,note,that,if,a,code,before,transaction,method,fails,any,remaining,code,before,transaction,methods,will,not,be,invoked,and,a,transaction,will,not,be,started,see,org,springframework,transaction,annotation,transactional,see,get,transaction,manager,test,context,string;override,public,void,before,test,method,final,test,context,test,context,throws,exception,final,method,test,method,test,context,get,test,method,final,class,test,class,test,context,get,test,class,assert,not,null,test,method,the,test,method,of,the,supplied,test,context,must,not,be,null,transaction,context,tx,context,transaction,context,holder,remove,current,transaction,context,if,tx,context,null,throw,new,illegal,state,exception,cannot,start,a,new,transaction,without,ending,the,existing,transaction,platform,transaction,manager,tm,null,transaction,attribute,transaction,attribute,this,attribute,source,get,transaction,attribute,test,method,test,class,if,transaction,attribute,null,transaction,attribute,test,context,transaction,utils,create,delegating,transaction,attribute,test,context,transaction,attribute,if,logger,is,debug,enabled,logger,debug,explicit,transaction,definition,transaction,attribute,found,for,test,context,test,context,if,transaction,attribute,get,propagation,behavior,transaction,definition,return,tm,get,transaction,manager,test,context,transaction,attribute,get,qualifier,if,tm,null,throw,new,illegal,state,exception,string,format,failed,to,retrieve,platform,transaction,manager,for,transactional,test,for,test,context,s,test,context,if,tm,null,tx,context,new,transaction,context,test,context,tm,transaction,attribute,is,rollback,test,context,run,before,transaction,methods,test,context,tx,context,start,transaction,transaction,context,holder,set,current,transaction,context,tx,context
TransactionalTestExecutionListener -> @Override 	public void beforeTestMethod(final TestContext testContext) throws Exception;1462299971;If the test method of the supplied {@linkplain TestContext test context}_is configured to run within a transaction, this method will run_{@link BeforeTransaction @BeforeTransaction} methods and start a new_transaction._<p>Note that if a {@code @BeforeTransaction} method fails, any remaining_{@code @BeforeTransaction} methods will not be invoked, and a transaction_will not be started._@see org.springframework.transaction.annotation.Transactional_@see #getTransactionManager(TestContext, String);@Override_	public void beforeTestMethod(final TestContext testContext) throws Exception {_		final Method testMethod = testContext.getTestMethod()__		final Class<?> testClass = testContext.getTestClass()__		Assert.notNull(testMethod, "The test method of the supplied TestContext must not be null")___		TransactionContext txContext = TransactionContextHolder.removeCurrentTransactionContext()__		if (txContext != null) {_			throw new IllegalStateException("Cannot start a new transaction without ending the existing transaction.")__		}__		PlatformTransactionManager tm = null__		TransactionAttribute transactionAttribute = this.attributeSource.getTransactionAttribute(testMethod, testClass)___		if (transactionAttribute != null) {_			transactionAttribute = TestContextTransactionUtils.createDelegatingTransactionAttribute(testContext,_				transactionAttribute)___			if (logger.isDebugEnabled()) {_				logger.debug("Explicit transaction definition [" + transactionAttribute + "] found for test context " +_						testContext)__			}__			if (transactionAttribute.getPropagationBehavior() == TransactionDefinition.PROPAGATION_NOT_SUPPORTED) {_				return__			}__			tm = getTransactionManager(testContext, transactionAttribute.getQualifier())___			if (tm == null) {_				throw new IllegalStateException(String.format(_						"Failed to retrieve PlatformTransactionManager for @Transactional test for test context %s.",_						testContext))__			}_		}__		if (tm != null) {_			txContext = new TransactionContext(testContext, tm, transactionAttribute, isRollback(testContext))__			runBeforeTransactionMethods(testContext)__			txContext.startTransaction()__			TransactionContextHolder.setCurrentTransactionContext(txContext)__		}_	};if,the,test,method,of,the,supplied,linkplain,test,context,test,context,is,configured,to,run,within,a,transaction,this,method,will,run,link,before,transaction,before,transaction,methods,and,start,a,new,transaction,p,note,that,if,a,code,before,transaction,method,fails,any,remaining,code,before,transaction,methods,will,not,be,invoked,and,a,transaction,will,not,be,started,see,org,springframework,transaction,annotation,transactional,see,get,transaction,manager,test,context,string;override,public,void,before,test,method,final,test,context,test,context,throws,exception,final,method,test,method,test,context,get,test,method,final,class,test,class,test,context,get,test,class,assert,not,null,test,method,the,test,method,of,the,supplied,test,context,must,not,be,null,transaction,context,tx,context,transaction,context,holder,remove,current,transaction,context,if,tx,context,null,throw,new,illegal,state,exception,cannot,start,a,new,transaction,without,ending,the,existing,transaction,platform,transaction,manager,tm,null,transaction,attribute,transaction,attribute,this,attribute,source,get,transaction,attribute,test,method,test,class,if,transaction,attribute,null,transaction,attribute,test,context,transaction,utils,create,delegating,transaction,attribute,test,context,transaction,attribute,if,logger,is,debug,enabled,logger,debug,explicit,transaction,definition,transaction,attribute,found,for,test,context,test,context,if,transaction,attribute,get,propagation,behavior,transaction,definition,return,tm,get,transaction,manager,test,context,transaction,attribute,get,qualifier,if,tm,null,throw,new,illegal,state,exception,string,format,failed,to,retrieve,platform,transaction,manager,for,transactional,test,for,test,context,s,test,context,if,tm,null,tx,context,new,transaction,context,test,context,tm,transaction,attribute,is,rollback,test,context,run,before,transaction,methods,test,context,tx,context,start,transaction,transaction,context,holder,set,current,transaction,context,tx,context
TransactionalTestExecutionListener -> @Override 	public void beforeTestMethod(final TestContext testContext) throws Exception;1467730834;If the test method of the supplied {@linkplain TestContext test context}_is configured to run within a transaction, this method will run_{@link BeforeTransaction @BeforeTransaction} methods and start a new_transaction._<p>Note that if a {@code @BeforeTransaction} method fails, any remaining_{@code @BeforeTransaction} methods will not be invoked, and a transaction_will not be started._@see org.springframework.transaction.annotation.Transactional_@see #getTransactionManager(TestContext, String);@Override_	public void beforeTestMethod(final TestContext testContext) throws Exception {_		final Method testMethod = testContext.getTestMethod()__		final Class<?> testClass = testContext.getTestClass()__		Assert.notNull(testMethod, "The test method of the supplied TestContext must not be null")___		TransactionContext txContext = TransactionContextHolder.removeCurrentTransactionContext()__		if (txContext != null) {_			throw new IllegalStateException("Cannot start a new transaction without ending the existing transaction.")__		}__		PlatformTransactionManager tm = null__		TransactionAttribute transactionAttribute = this.attributeSource.getTransactionAttribute(testMethod, testClass)___		if (transactionAttribute != null) {_			transactionAttribute = TestContextTransactionUtils.createDelegatingTransactionAttribute(testContext,_				transactionAttribute)___			if (logger.isDebugEnabled()) {_				logger.debug("Explicit transaction definition [" + transactionAttribute + "] found for test context " +_						testContext)__			}__			if (transactionAttribute.getPropagationBehavior() == TransactionDefinition.PROPAGATION_NOT_SUPPORTED) {_				return__			}__			tm = getTransactionManager(testContext, transactionAttribute.getQualifier())___			if (tm == null) {_				throw new IllegalStateException(String.format(_						"Failed to retrieve PlatformTransactionManager for @Transactional test for test context %s.",_						testContext))__			}_		}__		if (tm != null) {_			txContext = new TransactionContext(testContext, tm, transactionAttribute, isRollback(testContext))__			runBeforeTransactionMethods(testContext)__			txContext.startTransaction()__			TransactionContextHolder.setCurrentTransactionContext(txContext)__		}_	};if,the,test,method,of,the,supplied,linkplain,test,context,test,context,is,configured,to,run,within,a,transaction,this,method,will,run,link,before,transaction,before,transaction,methods,and,start,a,new,transaction,p,note,that,if,a,code,before,transaction,method,fails,any,remaining,code,before,transaction,methods,will,not,be,invoked,and,a,transaction,will,not,be,started,see,org,springframework,transaction,annotation,transactional,see,get,transaction,manager,test,context,string;override,public,void,before,test,method,final,test,context,test,context,throws,exception,final,method,test,method,test,context,get,test,method,final,class,test,class,test,context,get,test,class,assert,not,null,test,method,the,test,method,of,the,supplied,test,context,must,not,be,null,transaction,context,tx,context,transaction,context,holder,remove,current,transaction,context,if,tx,context,null,throw,new,illegal,state,exception,cannot,start,a,new,transaction,without,ending,the,existing,transaction,platform,transaction,manager,tm,null,transaction,attribute,transaction,attribute,this,attribute,source,get,transaction,attribute,test,method,test,class,if,transaction,attribute,null,transaction,attribute,test,context,transaction,utils,create,delegating,transaction,attribute,test,context,transaction,attribute,if,logger,is,debug,enabled,logger,debug,explicit,transaction,definition,transaction,attribute,found,for,test,context,test,context,if,transaction,attribute,get,propagation,behavior,transaction,definition,return,tm,get,transaction,manager,test,context,transaction,attribute,get,qualifier,if,tm,null,throw,new,illegal,state,exception,string,format,failed,to,retrieve,platform,transaction,manager,for,transactional,test,for,test,context,s,test,context,if,tm,null,tx,context,new,transaction,context,test,context,tm,transaction,attribute,is,rollback,test,context,run,before,transaction,methods,test,context,tx,context,start,transaction,transaction,context,holder,set,current,transaction,context,tx,context
TransactionalTestExecutionListener -> @Override 	public void beforeTestMethod(final TestContext testContext) throws Exception;1467992320;If the test method of the supplied {@linkplain TestContext test context}_is configured to run within a transaction, this method will run_{@link BeforeTransaction @BeforeTransaction} methods and start a new_transaction._<p>Note that if a {@code @BeforeTransaction} method fails, any remaining_{@code @BeforeTransaction} methods will not be invoked, and a transaction_will not be started._@see org.springframework.transaction.annotation.Transactional_@see #getTransactionManager(TestContext, String);@Override_	public void beforeTestMethod(final TestContext testContext) throws Exception {_		final Method testMethod = testContext.getTestMethod()__		final Class<?> testClass = testContext.getTestClass()__		Assert.notNull(testMethod, "The test method of the supplied TestContext must not be null")___		TransactionContext txContext = TransactionContextHolder.removeCurrentTransactionContext()__		if (txContext != null) {_			throw new IllegalStateException("Cannot start a new transaction without ending the existing transaction.")__		}__		PlatformTransactionManager tm = null__		TransactionAttribute transactionAttribute = this.attributeSource.getTransactionAttribute(testMethod, testClass)___		if (transactionAttribute != null) {_			transactionAttribute = TestContextTransactionUtils.createDelegatingTransactionAttribute(testContext,_				transactionAttribute)___			if (logger.isDebugEnabled()) {_				logger.debug("Explicit transaction definition [" + transactionAttribute + "] found for test context " +_						testContext)__			}__			if (transactionAttribute.getPropagationBehavior() == TransactionDefinition.PROPAGATION_NOT_SUPPORTED) {_				return__			}__			tm = getTransactionManager(testContext, transactionAttribute.getQualifier())___			if (tm == null) {_				throw new IllegalStateException(String.format(_						"Failed to retrieve PlatformTransactionManager for @Transactional test for test context %s.",_						testContext))__			}_		}__		if (tm != null) {_			txContext = new TransactionContext(testContext, tm, transactionAttribute, isRollback(testContext))__			runBeforeTransactionMethods(testContext)__			txContext.startTransaction()__			TransactionContextHolder.setCurrentTransactionContext(txContext)__		}_	};if,the,test,method,of,the,supplied,linkplain,test,context,test,context,is,configured,to,run,within,a,transaction,this,method,will,run,link,before,transaction,before,transaction,methods,and,start,a,new,transaction,p,note,that,if,a,code,before,transaction,method,fails,any,remaining,code,before,transaction,methods,will,not,be,invoked,and,a,transaction,will,not,be,started,see,org,springframework,transaction,annotation,transactional,see,get,transaction,manager,test,context,string;override,public,void,before,test,method,final,test,context,test,context,throws,exception,final,method,test,method,test,context,get,test,method,final,class,test,class,test,context,get,test,class,assert,not,null,test,method,the,test,method,of,the,supplied,test,context,must,not,be,null,transaction,context,tx,context,transaction,context,holder,remove,current,transaction,context,if,tx,context,null,throw,new,illegal,state,exception,cannot,start,a,new,transaction,without,ending,the,existing,transaction,platform,transaction,manager,tm,null,transaction,attribute,transaction,attribute,this,attribute,source,get,transaction,attribute,test,method,test,class,if,transaction,attribute,null,transaction,attribute,test,context,transaction,utils,create,delegating,transaction,attribute,test,context,transaction,attribute,if,logger,is,debug,enabled,logger,debug,explicit,transaction,definition,transaction,attribute,found,for,test,context,test,context,if,transaction,attribute,get,propagation,behavior,transaction,definition,return,tm,get,transaction,manager,test,context,transaction,attribute,get,qualifier,if,tm,null,throw,new,illegal,state,exception,string,format,failed,to,retrieve,platform,transaction,manager,for,transactional,test,for,test,context,s,test,context,if,tm,null,tx,context,new,transaction,context,test,context,tm,transaction,attribute,is,rollback,test,context,run,before,transaction,methods,test,context,tx,context,start,transaction,transaction,context,holder,set,current,transaction,context,tx,context
TransactionalTestExecutionListener -> @Override 	public void beforeTestMethod(final TestContext testContext) throws Exception;1467992442;If the test method of the supplied {@linkplain TestContext test context}_is configured to run within a transaction, this method will run_{@link BeforeTransaction @BeforeTransaction} methods and start a new_transaction._<p>Note that if a {@code @BeforeTransaction} method fails, any remaining_{@code @BeforeTransaction} methods will not be invoked, and a transaction_will not be started._@see org.springframework.transaction.annotation.Transactional_@see #getTransactionManager(TestContext, String);@Override_	public void beforeTestMethod(final TestContext testContext) throws Exception {_		final Method testMethod = testContext.getTestMethod()__		final Class<?> testClass = testContext.getTestClass()__		Assert.notNull(testMethod, "The test method of the supplied TestContext must not be null")___		TransactionContext txContext = TransactionContextHolder.removeCurrentTransactionContext()__		if (txContext != null) {_			throw new IllegalStateException("Cannot start a new transaction without ending the existing transaction.")__		}__		PlatformTransactionManager tm = null__		TransactionAttribute transactionAttribute = this.attributeSource.getTransactionAttribute(testMethod, testClass)___		if (transactionAttribute != null) {_			transactionAttribute = TestContextTransactionUtils.createDelegatingTransactionAttribute(testContext,_				transactionAttribute)___			if (logger.isDebugEnabled()) {_				logger.debug("Explicit transaction definition [" + transactionAttribute + "] found for test context " +_						testContext)__			}__			if (transactionAttribute.getPropagationBehavior() == TransactionDefinition.PROPAGATION_NOT_SUPPORTED) {_				return__			}__			tm = getTransactionManager(testContext, transactionAttribute.getQualifier())___			if (tm == null) {_				throw new IllegalStateException(String.format(_						"Failed to retrieve PlatformTransactionManager for @Transactional test for test context %s.",_						testContext))__			}_		}__		if (tm != null) {_			txContext = new TransactionContext(testContext, tm, transactionAttribute, isRollback(testContext))__			runBeforeTransactionMethods(testContext)__			txContext.startTransaction()__			TransactionContextHolder.setCurrentTransactionContext(txContext)__		}_	};if,the,test,method,of,the,supplied,linkplain,test,context,test,context,is,configured,to,run,within,a,transaction,this,method,will,run,link,before,transaction,before,transaction,methods,and,start,a,new,transaction,p,note,that,if,a,code,before,transaction,method,fails,any,remaining,code,before,transaction,methods,will,not,be,invoked,and,a,transaction,will,not,be,started,see,org,springframework,transaction,annotation,transactional,see,get,transaction,manager,test,context,string;override,public,void,before,test,method,final,test,context,test,context,throws,exception,final,method,test,method,test,context,get,test,method,final,class,test,class,test,context,get,test,class,assert,not,null,test,method,the,test,method,of,the,supplied,test,context,must,not,be,null,transaction,context,tx,context,transaction,context,holder,remove,current,transaction,context,if,tx,context,null,throw,new,illegal,state,exception,cannot,start,a,new,transaction,without,ending,the,existing,transaction,platform,transaction,manager,tm,null,transaction,attribute,transaction,attribute,this,attribute,source,get,transaction,attribute,test,method,test,class,if,transaction,attribute,null,transaction,attribute,test,context,transaction,utils,create,delegating,transaction,attribute,test,context,transaction,attribute,if,logger,is,debug,enabled,logger,debug,explicit,transaction,definition,transaction,attribute,found,for,test,context,test,context,if,transaction,attribute,get,propagation,behavior,transaction,definition,return,tm,get,transaction,manager,test,context,transaction,attribute,get,qualifier,if,tm,null,throw,new,illegal,state,exception,string,format,failed,to,retrieve,platform,transaction,manager,for,transactional,test,for,test,context,s,test,context,if,tm,null,tx,context,new,transaction,context,test,context,tm,transaction,attribute,is,rollback,test,context,run,before,transaction,methods,test,context,tx,context,start,transaction,transaction,context,holder,set,current,transaction,context,tx,context
TransactionalTestExecutionListener -> @Override 	public void beforeTestMethod(final TestContext testContext) throws Exception;1467994604;If the test method of the supplied {@linkplain TestContext test context}_is configured to run within a transaction, this method will run_{@link BeforeTransaction @BeforeTransaction} methods and start a new_transaction._<p>Note that if a {@code @BeforeTransaction} method fails, any remaining_{@code @BeforeTransaction} methods will not be invoked, and a transaction_will not be started._@see org.springframework.transaction.annotation.Transactional_@see #getTransactionManager(TestContext, String);@Override_	public void beforeTestMethod(final TestContext testContext) throws Exception {_		final Method testMethod = testContext.getTestMethod()__		final Class<?> testClass = testContext.getTestClass()__		Assert.notNull(testMethod, "The test method of the supplied TestContext must not be null")___		TransactionContext txContext = TransactionContextHolder.removeCurrentTransactionContext()__		if (txContext != null) {_			throw new IllegalStateException("Cannot start a new transaction without ending the existing transaction.")__		}__		PlatformTransactionManager tm = null__		TransactionAttribute transactionAttribute = this.attributeSource.getTransactionAttribute(testMethod, testClass)___		if (transactionAttribute != null) {_			transactionAttribute = TestContextTransactionUtils.createDelegatingTransactionAttribute(testContext,_				transactionAttribute)___			if (logger.isDebugEnabled()) {_				logger.debug("Explicit transaction definition [" + transactionAttribute + "] found for test context " +_						testContext)__			}__			if (transactionAttribute.getPropagationBehavior() == TransactionDefinition.PROPAGATION_NOT_SUPPORTED) {_				return__			}__			tm = getTransactionManager(testContext, transactionAttribute.getQualifier())___			if (tm == null) {_				throw new IllegalStateException(String.format(_						"Failed to retrieve PlatformTransactionManager for @Transactional test for test context %s.",_						testContext))__			}_		}__		if (tm != null) {_			txContext = new TransactionContext(testContext, tm, transactionAttribute, isRollback(testContext))__			runBeforeTransactionMethods(testContext)__			txContext.startTransaction()__			TransactionContextHolder.setCurrentTransactionContext(txContext)__		}_	};if,the,test,method,of,the,supplied,linkplain,test,context,test,context,is,configured,to,run,within,a,transaction,this,method,will,run,link,before,transaction,before,transaction,methods,and,start,a,new,transaction,p,note,that,if,a,code,before,transaction,method,fails,any,remaining,code,before,transaction,methods,will,not,be,invoked,and,a,transaction,will,not,be,started,see,org,springframework,transaction,annotation,transactional,see,get,transaction,manager,test,context,string;override,public,void,before,test,method,final,test,context,test,context,throws,exception,final,method,test,method,test,context,get,test,method,final,class,test,class,test,context,get,test,class,assert,not,null,test,method,the,test,method,of,the,supplied,test,context,must,not,be,null,transaction,context,tx,context,transaction,context,holder,remove,current,transaction,context,if,tx,context,null,throw,new,illegal,state,exception,cannot,start,a,new,transaction,without,ending,the,existing,transaction,platform,transaction,manager,tm,null,transaction,attribute,transaction,attribute,this,attribute,source,get,transaction,attribute,test,method,test,class,if,transaction,attribute,null,transaction,attribute,test,context,transaction,utils,create,delegating,transaction,attribute,test,context,transaction,attribute,if,logger,is,debug,enabled,logger,debug,explicit,transaction,definition,transaction,attribute,found,for,test,context,test,context,if,transaction,attribute,get,propagation,behavior,transaction,definition,return,tm,get,transaction,manager,test,context,transaction,attribute,get,qualifier,if,tm,null,throw,new,illegal,state,exception,string,format,failed,to,retrieve,platform,transaction,manager,for,transactional,test,for,test,context,s,test,context,if,tm,null,tx,context,new,transaction,context,test,context,tm,transaction,attribute,is,rollback,test,context,run,before,transaction,methods,test,context,tx,context,start,transaction,transaction,context,holder,set,current,transaction,context,tx,context
TransactionalTestExecutionListener -> @Override 	public void beforeTestMethod(final TestContext testContext) throws Exception;1468334463;If the test method of the supplied {@linkplain TestContext test context}_is configured to run within a transaction, this method will run_{@link BeforeTransaction @BeforeTransaction} methods and start a new_transaction._<p>Note that if a {@code @BeforeTransaction} method fails, any remaining_{@code @BeforeTransaction} methods will not be invoked, and a transaction_will not be started._@see org.springframework.transaction.annotation.Transactional_@see #getTransactionManager(TestContext, String);@Override_	public void beforeTestMethod(final TestContext testContext) throws Exception {_		final Method testMethod = testContext.getTestMethod()__		final Class<?> testClass = testContext.getTestClass()__		Assert.notNull(testMethod, "The test method of the supplied TestContext must not be null")___		TransactionContext txContext = TransactionContextHolder.removeCurrentTransactionContext()__		Assert.state(txContext == null, "Cannot start a new transaction without ending the existing transaction.")___		PlatformTransactionManager tm = null__		TransactionAttribute transactionAttribute = this.attributeSource.getTransactionAttribute(testMethod, testClass)___		if (transactionAttribute != null) {_			transactionAttribute = TestContextTransactionUtils.createDelegatingTransactionAttribute(testContext,_				transactionAttribute)___			if (logger.isDebugEnabled()) {_				logger.debug("Explicit transaction definition [" + transactionAttribute + "] found for test context " +_						testContext)__			}__			if (transactionAttribute.getPropagationBehavior() == TransactionDefinition.PROPAGATION_NOT_SUPPORTED) {_				return__			}__			tm = getTransactionManager(testContext, transactionAttribute.getQualifier())___			Assert.state(tm != null, () -> String.format(_					"Failed to retrieve PlatformTransactionManager for @Transactional test for test context %s.",_					testContext))__		}__		if (tm != null) {_			txContext = new TransactionContext(testContext, tm, transactionAttribute, isRollback(testContext))__			runBeforeTransactionMethods(testContext)__			txContext.startTransaction()__			TransactionContextHolder.setCurrentTransactionContext(txContext)__		}_	};if,the,test,method,of,the,supplied,linkplain,test,context,test,context,is,configured,to,run,within,a,transaction,this,method,will,run,link,before,transaction,before,transaction,methods,and,start,a,new,transaction,p,note,that,if,a,code,before,transaction,method,fails,any,remaining,code,before,transaction,methods,will,not,be,invoked,and,a,transaction,will,not,be,started,see,org,springframework,transaction,annotation,transactional,see,get,transaction,manager,test,context,string;override,public,void,before,test,method,final,test,context,test,context,throws,exception,final,method,test,method,test,context,get,test,method,final,class,test,class,test,context,get,test,class,assert,not,null,test,method,the,test,method,of,the,supplied,test,context,must,not,be,null,transaction,context,tx,context,transaction,context,holder,remove,current,transaction,context,assert,state,tx,context,null,cannot,start,a,new,transaction,without,ending,the,existing,transaction,platform,transaction,manager,tm,null,transaction,attribute,transaction,attribute,this,attribute,source,get,transaction,attribute,test,method,test,class,if,transaction,attribute,null,transaction,attribute,test,context,transaction,utils,create,delegating,transaction,attribute,test,context,transaction,attribute,if,logger,is,debug,enabled,logger,debug,explicit,transaction,definition,transaction,attribute,found,for,test,context,test,context,if,transaction,attribute,get,propagation,behavior,transaction,definition,return,tm,get,transaction,manager,test,context,transaction,attribute,get,qualifier,assert,state,tm,null,string,format,failed,to,retrieve,platform,transaction,manager,for,transactional,test,for,test,context,s,test,context,if,tm,null,tx,context,new,transaction,context,test,context,tm,transaction,attribute,is,rollback,test,context,run,before,transaction,methods,test,context,tx,context,start,transaction,transaction,context,holder,set,current,transaction,context,tx,context
TransactionalTestExecutionListener -> @Override 	public void beforeTestMethod(final TestContext testContext) throws Exception;1496955179;If the test method of the supplied {@linkplain TestContext test context}_is configured to run within a transaction, this method will run_{@link BeforeTransaction @BeforeTransaction} methods and start a new_transaction._<p>Note that if a {@code @BeforeTransaction} method fails, any remaining_{@code @BeforeTransaction} methods will not be invoked, and a transaction_will not be started._@see org.springframework.transaction.annotation.Transactional_@see #getTransactionManager(TestContext, String);@Override_	public void beforeTestMethod(final TestContext testContext) throws Exception {_		Method testMethod = testContext.getTestMethod()__		Class<?> testClass = testContext.getTestClass()__		Assert.notNull(testMethod, "The test method of the supplied TestContext must not be null")___		TransactionContext txContext = TransactionContextHolder.removeCurrentTransactionContext()__		Assert.state(txContext == null, "Cannot start a new transaction without ending the existing transaction.")___		PlatformTransactionManager tm = null__		TransactionAttribute transactionAttribute = this.attributeSource.getTransactionAttribute(testMethod, testClass)___		if (transactionAttribute != null) {_			transactionAttribute = TestContextTransactionUtils.createDelegatingTransactionAttribute(testContext,_				transactionAttribute)___			if (logger.isDebugEnabled()) {_				logger.debug("Explicit transaction definition [" + transactionAttribute + "] found for test context " +_						testContext)__			}__			if (transactionAttribute.getPropagationBehavior() == TransactionDefinition.PROPAGATION_NOT_SUPPORTED) {_				return__			}__			tm = getTransactionManager(testContext, transactionAttribute.getQualifier())__			Assert.state(tm != null, () -> String.format(_					"Failed to retrieve PlatformTransactionManager for @Transactional test for test context %s.",_					testContext))__		}__		if (tm != null) {_			txContext = new TransactionContext(testContext, tm, transactionAttribute, isRollback(testContext))__			runBeforeTransactionMethods(testContext)__			txContext.startTransaction()__			TransactionContextHolder.setCurrentTransactionContext(txContext)__		}_	};if,the,test,method,of,the,supplied,linkplain,test,context,test,context,is,configured,to,run,within,a,transaction,this,method,will,run,link,before,transaction,before,transaction,methods,and,start,a,new,transaction,p,note,that,if,a,code,before,transaction,method,fails,any,remaining,code,before,transaction,methods,will,not,be,invoked,and,a,transaction,will,not,be,started,see,org,springframework,transaction,annotation,transactional,see,get,transaction,manager,test,context,string;override,public,void,before,test,method,final,test,context,test,context,throws,exception,method,test,method,test,context,get,test,method,class,test,class,test,context,get,test,class,assert,not,null,test,method,the,test,method,of,the,supplied,test,context,must,not,be,null,transaction,context,tx,context,transaction,context,holder,remove,current,transaction,context,assert,state,tx,context,null,cannot,start,a,new,transaction,without,ending,the,existing,transaction,platform,transaction,manager,tm,null,transaction,attribute,transaction,attribute,this,attribute,source,get,transaction,attribute,test,method,test,class,if,transaction,attribute,null,transaction,attribute,test,context,transaction,utils,create,delegating,transaction,attribute,test,context,transaction,attribute,if,logger,is,debug,enabled,logger,debug,explicit,transaction,definition,transaction,attribute,found,for,test,context,test,context,if,transaction,attribute,get,propagation,behavior,transaction,definition,return,tm,get,transaction,manager,test,context,transaction,attribute,get,qualifier,assert,state,tm,null,string,format,failed,to,retrieve,platform,transaction,manager,for,transactional,test,for,test,context,s,test,context,if,tm,null,tx,context,new,transaction,context,test,context,tm,transaction,attribute,is,rollback,test,context,run,before,transaction,methods,test,context,tx,context,start,transaction,transaction,context,holder,set,current,transaction,context,tx,context
TransactionalTestExecutionListener -> @Override 	public void beforeTestMethod(final TestContext testContext) throws Exception;1498780456;If the test method of the supplied {@linkplain TestContext test context}_is configured to run within a transaction, this method will run_{@link BeforeTransaction @BeforeTransaction} methods and start a new_transaction._<p>Note that if a {@code @BeforeTransaction} method fails, any remaining_{@code @BeforeTransaction} methods will not be invoked, and a transaction_will not be started._@see org.springframework.transaction.annotation.Transactional_@see #getTransactionManager(TestContext, String);@Override_	public void beforeTestMethod(final TestContext testContext) throws Exception {_		Method testMethod = testContext.getTestMethod()__		Class<?> testClass = testContext.getTestClass()__		Assert.notNull(testMethod, "The test method of the supplied TestContext must not be null")___		TransactionContext txContext = TransactionContextHolder.removeCurrentTransactionContext()__		Assert.state(txContext == null, "Cannot start a new transaction without ending the existing transaction.")___		PlatformTransactionManager tm = null__		TransactionAttribute transactionAttribute = this.attributeSource.getTransactionAttribute(testMethod, testClass)___		if (transactionAttribute != null) {_			transactionAttribute = TestContextTransactionUtils.createDelegatingTransactionAttribute(testContext,_				transactionAttribute)___			if (logger.isDebugEnabled()) {_				logger.debug("Explicit transaction definition [" + transactionAttribute + "] found for test context " +_						testContext)__			}__			if (transactionAttribute.getPropagationBehavior() == TransactionDefinition.PROPAGATION_NOT_SUPPORTED) {_				return__			}__			tm = getTransactionManager(testContext, transactionAttribute.getQualifier())__			Assert.state(tm != null, () -> String.format(_					"Failed to retrieve PlatformTransactionManager for @Transactional test for test context %s.",_					testContext))__		}__		if (tm != null) {_			txContext = new TransactionContext(testContext, tm, transactionAttribute, isRollback(testContext))__			runBeforeTransactionMethods(testContext)__			txContext.startTransaction()__			TransactionContextHolder.setCurrentTransactionContext(txContext)__		}_	};if,the,test,method,of,the,supplied,linkplain,test,context,test,context,is,configured,to,run,within,a,transaction,this,method,will,run,link,before,transaction,before,transaction,methods,and,start,a,new,transaction,p,note,that,if,a,code,before,transaction,method,fails,any,remaining,code,before,transaction,methods,will,not,be,invoked,and,a,transaction,will,not,be,started,see,org,springframework,transaction,annotation,transactional,see,get,transaction,manager,test,context,string;override,public,void,before,test,method,final,test,context,test,context,throws,exception,method,test,method,test,context,get,test,method,class,test,class,test,context,get,test,class,assert,not,null,test,method,the,test,method,of,the,supplied,test,context,must,not,be,null,transaction,context,tx,context,transaction,context,holder,remove,current,transaction,context,assert,state,tx,context,null,cannot,start,a,new,transaction,without,ending,the,existing,transaction,platform,transaction,manager,tm,null,transaction,attribute,transaction,attribute,this,attribute,source,get,transaction,attribute,test,method,test,class,if,transaction,attribute,null,transaction,attribute,test,context,transaction,utils,create,delegating,transaction,attribute,test,context,transaction,attribute,if,logger,is,debug,enabled,logger,debug,explicit,transaction,definition,transaction,attribute,found,for,test,context,test,context,if,transaction,attribute,get,propagation,behavior,transaction,definition,return,tm,get,transaction,manager,test,context,transaction,attribute,get,qualifier,assert,state,tm,null,string,format,failed,to,retrieve,platform,transaction,manager,for,transactional,test,for,test,context,s,test,context,if,tm,null,tx,context,new,transaction,context,test,context,tm,transaction,attribute,is,rollback,test,context,run,before,transaction,methods,test,context,tx,context,start,transaction,transaction,context,holder,set,current,transaction,context,tx,context
TransactionalTestExecutionListener -> @Override 	public void beforeTestMethod(final TestContext testContext) throws Exception;1520251235;If the test method of the supplied {@linkplain TestContext test context}_is configured to run within a transaction, this method will run_{@link BeforeTransaction @BeforeTransaction} methods and start a new_transaction._<p>Note that if a {@code @BeforeTransaction} method fails, any remaining_{@code @BeforeTransaction} methods will not be invoked, and a transaction_will not be started._@see org.springframework.transaction.annotation.Transactional_@see #getTransactionManager(TestContext, String);@Override_	public void beforeTestMethod(final TestContext testContext) throws Exception {_		Method testMethod = testContext.getTestMethod()__		Class<?> testClass = testContext.getTestClass()__		Assert.notNull(testMethod, "Test method of supplied TestContext must not be null")___		TransactionContext txContext = TransactionContextHolder.removeCurrentTransactionContext()__		Assert.state(txContext == null, "Cannot start new transaction without ending existing transaction")___		PlatformTransactionManager tm = null__		TransactionAttribute transactionAttribute = this.attributeSource.getTransactionAttribute(testMethod, testClass)___		if (transactionAttribute != null) {_			transactionAttribute = TestContextTransactionUtils.createDelegatingTransactionAttribute(testContext,_				transactionAttribute)___			if (logger.isDebugEnabled()) {_				logger.debug("Explicit transaction definition [" + transactionAttribute +_						"] found for test context " + testContext)__			}__			if (transactionAttribute.getPropagationBehavior() == TransactionDefinition.PROPAGATION_NOT_SUPPORTED) {_				return__			}__			tm = getTransactionManager(testContext, transactionAttribute.getQualifier())__			Assert.state(tm != null,_					() -> "Failed to retrieve PlatformTransactionManager for @Transactional test: " + testContext)__		}__		if (tm != null) {_			txContext = new TransactionContext(testContext, tm, transactionAttribute, isRollback(testContext))__			runBeforeTransactionMethods(testContext)__			txContext.startTransaction()__			TransactionContextHolder.setCurrentTransactionContext(txContext)__		}_	};if,the,test,method,of,the,supplied,linkplain,test,context,test,context,is,configured,to,run,within,a,transaction,this,method,will,run,link,before,transaction,before,transaction,methods,and,start,a,new,transaction,p,note,that,if,a,code,before,transaction,method,fails,any,remaining,code,before,transaction,methods,will,not,be,invoked,and,a,transaction,will,not,be,started,see,org,springframework,transaction,annotation,transactional,see,get,transaction,manager,test,context,string;override,public,void,before,test,method,final,test,context,test,context,throws,exception,method,test,method,test,context,get,test,method,class,test,class,test,context,get,test,class,assert,not,null,test,method,test,method,of,supplied,test,context,must,not,be,null,transaction,context,tx,context,transaction,context,holder,remove,current,transaction,context,assert,state,tx,context,null,cannot,start,new,transaction,without,ending,existing,transaction,platform,transaction,manager,tm,null,transaction,attribute,transaction,attribute,this,attribute,source,get,transaction,attribute,test,method,test,class,if,transaction,attribute,null,transaction,attribute,test,context,transaction,utils,create,delegating,transaction,attribute,test,context,transaction,attribute,if,logger,is,debug,enabled,logger,debug,explicit,transaction,definition,transaction,attribute,found,for,test,context,test,context,if,transaction,attribute,get,propagation,behavior,transaction,definition,return,tm,get,transaction,manager,test,context,transaction,attribute,get,qualifier,assert,state,tm,null,failed,to,retrieve,platform,transaction,manager,for,transactional,test,test,context,if,tm,null,tx,context,new,transaction,context,test,context,tm,transaction,attribute,is,rollback,test,context,run,before,transaction,methods,test,context,tx,context,start,transaction,transaction,context,holder,set,current,transaction,context,tx,context
TransactionalTestExecutionListener -> @SuppressWarnings("serial") 	@Override 	public void beforeTestMethod(TestContext testContext) throws Exception;1328020251;If the test method of the supplied {@link TestContext test context} is_configured to run within a transaction, this method will run_{@link BeforeTransaction &#064_BeforeTransaction methods} and start a new_transaction._<p>Note that if a {@link BeforeTransaction &#064_BeforeTransaction method} fails,_remaining {@link BeforeTransaction &#064_BeforeTransaction methods} will not_be invoked, and a transaction will not be started._@see org.springframework.transaction.annotation.Transactional_@see org.springframework.test.annotation.NotTransactional;@SuppressWarnings("serial")_	@Override_	public void beforeTestMethod(TestContext testContext) throws Exception {_		final Method testMethod = testContext.getTestMethod()__		Assert.notNull(testMethod, "The test method of the supplied TestContext must not be null")___		if (this.transactionContextCache.remove(testMethod) != null) {_			throw new IllegalStateException("Cannot start new transaction without ending existing transaction: "_					+ "Invoke endTransaction() before startNewTransaction().")__		}__		if (testMethod.isAnnotationPresent(NotTransactional.class)) {_			return__		}__		TransactionAttribute transactionAttribute = this.attributeSource.getTransactionAttribute(testMethod,_			testContext.getTestClass())__		TransactionDefinition transactionDefinition = null__		if (transactionAttribute != null) {_			transactionDefinition = new DelegatingTransactionAttribute(transactionAttribute) {__				public String getName() {_					return testMethod.getName()__				}_			}__		}__		if (transactionDefinition != null) {_			if (logger.isDebugEnabled()) {_				logger.debug("Explicit transaction definition [" + transactionDefinition + "] found for test context ["_						+ testContext + "]")__			}_			String qualifier = transactionAttribute.getQualifier()__			PlatformTransactionManager tm__			if (StringUtils.hasLength(qualifier)) {_				_				_				_				BeanFactory bf = testContext.getApplicationContext().getAutowireCapableBeanFactory()__				tm = TransactionAspectUtils.getTransactionManager(bf, qualifier)__			}_			else {_				tm = getTransactionManager(testContext)__			}_			TransactionContext txContext = new TransactionContext(tm, transactionDefinition)__			runBeforeTransactionMethods(testContext)__			startNewTransaction(testContext, txContext)__			this.transactionContextCache.put(testMethod, txContext)__		}_	};if,the,test,method,of,the,supplied,link,test,context,test,context,is,configured,to,run,within,a,transaction,this,method,will,run,link,before,transaction,064,before,transaction,methods,and,start,a,new,transaction,p,note,that,if,a,link,before,transaction,064,before,transaction,method,fails,remaining,link,before,transaction,064,before,transaction,methods,will,not,be,invoked,and,a,transaction,will,not,be,started,see,org,springframework,transaction,annotation,transactional,see,org,springframework,test,annotation,not,transactional;suppress,warnings,serial,override,public,void,before,test,method,test,context,test,context,throws,exception,final,method,test,method,test,context,get,test,method,assert,not,null,test,method,the,test,method,of,the,supplied,test,context,must,not,be,null,if,this,transaction,context,cache,remove,test,method,null,throw,new,illegal,state,exception,cannot,start,new,transaction,without,ending,existing,transaction,invoke,end,transaction,before,start,new,transaction,if,test,method,is,annotation,present,not,transactional,class,return,transaction,attribute,transaction,attribute,this,attribute,source,get,transaction,attribute,test,method,test,context,get,test,class,transaction,definition,transaction,definition,null,if,transaction,attribute,null,transaction,definition,new,delegating,transaction,attribute,transaction,attribute,public,string,get,name,return,test,method,get,name,if,transaction,definition,null,if,logger,is,debug,enabled,logger,debug,explicit,transaction,definition,transaction,definition,found,for,test,context,test,context,string,qualifier,transaction,attribute,get,qualifier,platform,transaction,manager,tm,if,string,utils,has,length,qualifier,bean,factory,bf,test,context,get,application,context,get,autowire,capable,bean,factory,tm,transaction,aspect,utils,get,transaction,manager,bf,qualifier,else,tm,get,transaction,manager,test,context,transaction,context,tx,context,new,transaction,context,tm,transaction,definition,run,before,transaction,methods,test,context,start,new,transaction,test,context,tx,context,this,transaction,context,cache,put,test,method,tx,context
TransactionalTestExecutionListener -> @SuppressWarnings("serial") 	@Override 	public void beforeTestMethod(TestContext testContext) throws Exception;1337516454;If the test method of the supplied {@link TestContext test context} is_configured to run within a transaction, this method will run_{@link BeforeTransaction &#064_BeforeTransaction methods} and start a new_transaction._<p>Note that if a {@link BeforeTransaction &#064_BeforeTransaction method} fails,_remaining {@link BeforeTransaction &#064_BeforeTransaction methods} will not_be invoked, and a transaction will not be started._@see org.springframework.transaction.annotation.Transactional_@see org.springframework.test.annotation.NotTransactional;@SuppressWarnings("serial")_	@Override_	public void beforeTestMethod(TestContext testContext) throws Exception {_		final Method testMethod = testContext.getTestMethod()__		Assert.notNull(testMethod, "The test method of the supplied TestContext must not be null")___		if (this.transactionContextCache.remove(testMethod) != null) {_			throw new IllegalStateException("Cannot start new transaction without ending existing transaction: "_					+ "Invoke endTransaction() before startNewTransaction().")__		}__		if (testMethod.isAnnotationPresent(NotTransactional.class)) {_			return__		}__		TransactionAttribute transactionAttribute = this.attributeSource.getTransactionAttribute(testMethod,_			testContext.getTestClass())__		TransactionDefinition transactionDefinition = null__		if (transactionAttribute != null) {_			transactionDefinition = new DelegatingTransactionAttribute(transactionAttribute) {__				public String getName() {_					return testMethod.getName()__				}_			}__		}__		if (transactionDefinition != null) {_			if (logger.isDebugEnabled()) {_				logger.debug("Explicit transaction definition [" + transactionDefinition + "] found for test context ["_						+ testContext + "]")__			}_			String qualifier = transactionAttribute.getQualifier()__			PlatformTransactionManager tm__			if (StringUtils.hasLength(qualifier)) {_				_				_				_				BeanFactory bf = testContext.getApplicationContext().getAutowireCapableBeanFactory()__				tm = BeanFactoryUtils.qualifiedBeanOfType(bf, PlatformTransactionManager.class, qualifier)__			}_			else {_				tm = getTransactionManager(testContext)__			}_			TransactionContext txContext = new TransactionContext(tm, transactionDefinition)__			runBeforeTransactionMethods(testContext)__			startNewTransaction(testContext, txContext)__			this.transactionContextCache.put(testMethod, txContext)__		}_	};if,the,test,method,of,the,supplied,link,test,context,test,context,is,configured,to,run,within,a,transaction,this,method,will,run,link,before,transaction,064,before,transaction,methods,and,start,a,new,transaction,p,note,that,if,a,link,before,transaction,064,before,transaction,method,fails,remaining,link,before,transaction,064,before,transaction,methods,will,not,be,invoked,and,a,transaction,will,not,be,started,see,org,springframework,transaction,annotation,transactional,see,org,springframework,test,annotation,not,transactional;suppress,warnings,serial,override,public,void,before,test,method,test,context,test,context,throws,exception,final,method,test,method,test,context,get,test,method,assert,not,null,test,method,the,test,method,of,the,supplied,test,context,must,not,be,null,if,this,transaction,context,cache,remove,test,method,null,throw,new,illegal,state,exception,cannot,start,new,transaction,without,ending,existing,transaction,invoke,end,transaction,before,start,new,transaction,if,test,method,is,annotation,present,not,transactional,class,return,transaction,attribute,transaction,attribute,this,attribute,source,get,transaction,attribute,test,method,test,context,get,test,class,transaction,definition,transaction,definition,null,if,transaction,attribute,null,transaction,definition,new,delegating,transaction,attribute,transaction,attribute,public,string,get,name,return,test,method,get,name,if,transaction,definition,null,if,logger,is,debug,enabled,logger,debug,explicit,transaction,definition,transaction,definition,found,for,test,context,test,context,string,qualifier,transaction,attribute,get,qualifier,platform,transaction,manager,tm,if,string,utils,has,length,qualifier,bean,factory,bf,test,context,get,application,context,get,autowire,capable,bean,factory,tm,bean,factory,utils,qualified,bean,of,type,bf,platform,transaction,manager,class,qualifier,else,tm,get,transaction,manager,test,context,transaction,context,tx,context,new,transaction,context,tm,transaction,definition,run,before,transaction,methods,test,context,start,new,transaction,test,context,tx,context,this,transaction,context,cache,put,test,method,tx,context
TransactionalTestExecutionListener -> @SuppressWarnings("serial") 	@Override 	public void beforeTestMethod(TestContext testContext) throws Exception;1338031377;If the test method of the supplied {@link TestContext test context} is_configured to run within a transaction, this method will run_{@link BeforeTransaction &#064_BeforeTransaction methods} and start a new_transaction._<p>Note that if a {@link BeforeTransaction &#064_BeforeTransaction method} fails,_remaining {@link BeforeTransaction &#064_BeforeTransaction methods} will not_be invoked, and a transaction will not be started._@see org.springframework.transaction.annotation.Transactional_@see org.springframework.test.annotation.NotTransactional;@SuppressWarnings("serial")_	@Override_	public void beforeTestMethod(TestContext testContext) throws Exception {_		final Method testMethod = testContext.getTestMethod()__		Assert.notNull(testMethod, "The test method of the supplied TestContext must not be null")___		if (this.transactionContextCache.remove(testMethod) != null) {_			throw new IllegalStateException("Cannot start new transaction without ending existing transaction: "_					+ "Invoke endTransaction() before startNewTransaction().")__		}__		if (testMethod.isAnnotationPresent(NotTransactional.class)) {_			return__		}__		TransactionAttribute transactionAttribute = this.attributeSource.getTransactionAttribute(testMethod,_			testContext.getTestClass())__		TransactionDefinition transactionDefinition = null__		if (transactionAttribute != null) {_			transactionDefinition = new DelegatingTransactionAttribute(transactionAttribute) {__				public String getName() {_					return testMethod.getName()__				}_			}__		}__		if (transactionDefinition != null) {_			if (logger.isDebugEnabled()) {_				logger.debug("Explicit transaction definition [" + transactionDefinition + "] found for test context ["_						+ testContext + "]")__			}_			String qualifier = transactionAttribute.getQualifier()__			PlatformTransactionManager tm__			if (StringUtils.hasLength(qualifier)) {_				_				_				_				BeanFactory bf = testContext.getApplicationContext().getAutowireCapableBeanFactory()__				tm = BeanFactoryAnnotationUtils.qualifiedBeanOfType(bf, PlatformTransactionManager.class, qualifier)__			}_			else {_				tm = getTransactionManager(testContext)__			}_			TransactionContext txContext = new TransactionContext(tm, transactionDefinition)__			runBeforeTransactionMethods(testContext)__			startNewTransaction(testContext, txContext)__			this.transactionContextCache.put(testMethod, txContext)__		}_	};if,the,test,method,of,the,supplied,link,test,context,test,context,is,configured,to,run,within,a,transaction,this,method,will,run,link,before,transaction,064,before,transaction,methods,and,start,a,new,transaction,p,note,that,if,a,link,before,transaction,064,before,transaction,method,fails,remaining,link,before,transaction,064,before,transaction,methods,will,not,be,invoked,and,a,transaction,will,not,be,started,see,org,springframework,transaction,annotation,transactional,see,org,springframework,test,annotation,not,transactional;suppress,warnings,serial,override,public,void,before,test,method,test,context,test,context,throws,exception,final,method,test,method,test,context,get,test,method,assert,not,null,test,method,the,test,method,of,the,supplied,test,context,must,not,be,null,if,this,transaction,context,cache,remove,test,method,null,throw,new,illegal,state,exception,cannot,start,new,transaction,without,ending,existing,transaction,invoke,end,transaction,before,start,new,transaction,if,test,method,is,annotation,present,not,transactional,class,return,transaction,attribute,transaction,attribute,this,attribute,source,get,transaction,attribute,test,method,test,context,get,test,class,transaction,definition,transaction,definition,null,if,transaction,attribute,null,transaction,definition,new,delegating,transaction,attribute,transaction,attribute,public,string,get,name,return,test,method,get,name,if,transaction,definition,null,if,logger,is,debug,enabled,logger,debug,explicit,transaction,definition,transaction,definition,found,for,test,context,test,context,string,qualifier,transaction,attribute,get,qualifier,platform,transaction,manager,tm,if,string,utils,has,length,qualifier,bean,factory,bf,test,context,get,application,context,get,autowire,capable,bean,factory,tm,bean,factory,annotation,utils,qualified,bean,of,type,bf,platform,transaction,manager,class,qualifier,else,tm,get,transaction,manager,test,context,transaction,context,tx,context,new,transaction,context,tm,transaction,definition,run,before,transaction,methods,test,context,start,new,transaction,test,context,tx,context,this,transaction,context,cache,put,test,method,tx,context
TransactionalTestExecutionListener -> @SuppressWarnings("serial") 	@Override 	public void beforeTestMethod(TestContext testContext) throws Exception;1343426806;If the test method of the supplied {@link TestContext test context} is_configured to run within a transaction, this method will run_{@link BeforeTransaction &#064_BeforeTransaction methods} and start a new_transaction._<p>Note that if a {@code BeforeTransaction &#064_BeforeTransaction method} fails,_remaining {@code BeforeTransaction &#064_BeforeTransaction methods} will not_be invoked, and a transaction will not be started._@see org.springframework.transaction.annotation.Transactional_@see org.springframework.test.annotation.NotTransactional_@see #getTransactionManager(TestContext, String);@SuppressWarnings("serial")_	@Override_	public void beforeTestMethod(TestContext testContext) throws Exception {_		final Method testMethod = testContext.getTestMethod()__		Assert.notNull(testMethod, "The test method of the supplied TestContext must not be null")___		if (this.transactionContextCache.remove(testMethod) != null) {_			throw new IllegalStateException("Cannot start new transaction without ending existing transaction: "_					+ "Invoke endTransaction() before startNewTransaction().")__		}__		if (testMethod.isAnnotationPresent(NotTransactional.class)) {_			return__		}__		PlatformTransactionManager tm = null__		TransactionAttribute transactionAttribute = this.attributeSource.getTransactionAttribute(testMethod,_			testContext.getTestClass())___		if (transactionAttribute != null) {_			transactionAttribute = new DelegatingTransactionAttribute(transactionAttribute) {__				public String getName() {_					return testMethod.getName()__				}_			}___			if (logger.isDebugEnabled()) {_				logger.debug("Explicit transaction definition [" + transactionAttribute + "] found for test context "_						+ testContext)__			}_			tm = getTransactionManager(testContext, transactionAttribute.getQualifier())__		}__		if (tm != null) {_			TransactionContext txContext = new TransactionContext(tm, transactionAttribute)__			runBeforeTransactionMethods(testContext)__			startNewTransaction(testContext, txContext)__			this.transactionContextCache.put(testMethod, txContext)__		}_	};if,the,test,method,of,the,supplied,link,test,context,test,context,is,configured,to,run,within,a,transaction,this,method,will,run,link,before,transaction,064,before,transaction,methods,and,start,a,new,transaction,p,note,that,if,a,code,before,transaction,064,before,transaction,method,fails,remaining,code,before,transaction,064,before,transaction,methods,will,not,be,invoked,and,a,transaction,will,not,be,started,see,org,springframework,transaction,annotation,transactional,see,org,springframework,test,annotation,not,transactional,see,get,transaction,manager,test,context,string;suppress,warnings,serial,override,public,void,before,test,method,test,context,test,context,throws,exception,final,method,test,method,test,context,get,test,method,assert,not,null,test,method,the,test,method,of,the,supplied,test,context,must,not,be,null,if,this,transaction,context,cache,remove,test,method,null,throw,new,illegal,state,exception,cannot,start,new,transaction,without,ending,existing,transaction,invoke,end,transaction,before,start,new,transaction,if,test,method,is,annotation,present,not,transactional,class,return,platform,transaction,manager,tm,null,transaction,attribute,transaction,attribute,this,attribute,source,get,transaction,attribute,test,method,test,context,get,test,class,if,transaction,attribute,null,transaction,attribute,new,delegating,transaction,attribute,transaction,attribute,public,string,get,name,return,test,method,get,name,if,logger,is,debug,enabled,logger,debug,explicit,transaction,definition,transaction,attribute,found,for,test,context,test,context,tm,get,transaction,manager,test,context,transaction,attribute,get,qualifier,if,tm,null,transaction,context,tx,context,new,transaction,context,tm,transaction,attribute,run,before,transaction,methods,test,context,start,new,transaction,test,context,tx,context,this,transaction,context,cache,put,test,method,tx,context
TransactionalTestExecutionListener -> @SuppressWarnings("serial") 	@Override 	public void beforeTestMethod(TestContext testContext) throws Exception;1343431472;If the test method of the supplied {@link TestContext test context} is_configured to run within a transaction, this method will run_{@link BeforeTransaction &#064_BeforeTransaction methods} and start a new_transaction._<p>Note that if a {@code BeforeTransaction &#064_BeforeTransaction method} fails,_remaining {@code BeforeTransaction &#064_BeforeTransaction methods} will not_be invoked, and a transaction will not be started._@see org.springframework.transaction.annotation.Transactional_@see org.springframework.test.annotation.NotTransactional_@see #getTransactionManager(TestContext, String);@SuppressWarnings("serial")_	@Override_	public void beforeTestMethod(TestContext testContext) throws Exception {_		final Method testMethod = testContext.getTestMethod()__		Assert.notNull(testMethod, "The test method of the supplied TestContext must not be null")___		if (this.transactionContextCache.remove(testMethod) != null) {_			throw new IllegalStateException("Cannot start new transaction without ending existing transaction: "_					+ "Invoke endTransaction() before startNewTransaction().")__		}__		if (testMethod.isAnnotationPresent(NotTransactional.class)) {_			return__		}__		PlatformTransactionManager tm = null__		TransactionAttribute transactionAttribute = this.attributeSource.getTransactionAttribute(testMethod,_			testContext.getTestClass())___		if (transactionAttribute != null) {_			transactionAttribute = new DelegatingTransactionAttribute(transactionAttribute) {__				public String getName() {_					return testMethod.getName()__				}_			}___			if (logger.isDebugEnabled()) {_				logger.debug("Explicit transaction definition [" + transactionAttribute + "] found for test context "_						+ testContext)__			}_			tm = getTransactionManager(testContext, transactionAttribute.getQualifier())__		}__		if (tm != null) {_			TransactionContext txContext = new TransactionContext(tm, transactionAttribute)__			runBeforeTransactionMethods(testContext)__			startNewTransaction(testContext, txContext)__			this.transactionContextCache.put(testMethod, txContext)__		}_	};if,the,test,method,of,the,supplied,link,test,context,test,context,is,configured,to,run,within,a,transaction,this,method,will,run,link,before,transaction,064,before,transaction,methods,and,start,a,new,transaction,p,note,that,if,a,code,before,transaction,064,before,transaction,method,fails,remaining,code,before,transaction,064,before,transaction,methods,will,not,be,invoked,and,a,transaction,will,not,be,started,see,org,springframework,transaction,annotation,transactional,see,org,springframework,test,annotation,not,transactional,see,get,transaction,manager,test,context,string;suppress,warnings,serial,override,public,void,before,test,method,test,context,test,context,throws,exception,final,method,test,method,test,context,get,test,method,assert,not,null,test,method,the,test,method,of,the,supplied,test,context,must,not,be,null,if,this,transaction,context,cache,remove,test,method,null,throw,new,illegal,state,exception,cannot,start,new,transaction,without,ending,existing,transaction,invoke,end,transaction,before,start,new,transaction,if,test,method,is,annotation,present,not,transactional,class,return,platform,transaction,manager,tm,null,transaction,attribute,transaction,attribute,this,attribute,source,get,transaction,attribute,test,method,test,context,get,test,class,if,transaction,attribute,null,transaction,attribute,new,delegating,transaction,attribute,transaction,attribute,public,string,get,name,return,test,method,get,name,if,logger,is,debug,enabled,logger,debug,explicit,transaction,definition,transaction,attribute,found,for,test,context,test,context,tm,get,transaction,manager,test,context,transaction,attribute,get,qualifier,if,tm,null,transaction,context,tx,context,new,transaction,context,tm,transaction,attribute,run,before,transaction,methods,test,context,start,new,transaction,test,context,tx,context,this,transaction,context,cache,put,test,method,tx,context
TransactionalTestExecutionListener -> @SuppressWarnings("serial") 	@Override 	public void beforeTestMethod(TestContext testContext) throws Exception;1354571539;If the test method of the supplied {@link TestContext test context} is_configured to run within a transaction, this method will run_{@link BeforeTransaction &#064_BeforeTransaction methods} and start a new_transaction._<p>Note that if a {@code @BeforeTransaction} method fails, any remaining_{@code @BeforeTransaction} methods will not be invoked, and a transaction_will not be started._@see org.springframework.transaction.annotation.Transactional_@see org.springframework.test.annotation.NotTransactional_@see #getTransactionManager(TestContext, String);@SuppressWarnings("serial")_	@Override_	public void beforeTestMethod(TestContext testContext) throws Exception {_		final Method testMethod = testContext.getTestMethod()__		Assert.notNull(testMethod, "The test method of the supplied TestContext must not be null")___		if (this.transactionContextCache.remove(testMethod) != null) {_			throw new IllegalStateException("Cannot start new transaction without ending existing transaction: "_					+ "Invoke endTransaction() before startNewTransaction().")__		}__		if (testMethod.isAnnotationPresent(NotTransactional.class)) {_			return__		}__		PlatformTransactionManager tm = null__		TransactionAttribute transactionAttribute = this.attributeSource.getTransactionAttribute(testMethod,_			testContext.getTestClass())___		if (transactionAttribute != null) {_			transactionAttribute = new DelegatingTransactionAttribute(transactionAttribute) {__				public String getName() {_					return testMethod.getName()__				}_			}___			if (logger.isDebugEnabled()) {_				logger.debug("Explicit transaction definition [" + transactionAttribute + "] found for test context "_						+ testContext)__			}_			tm = getTransactionManager(testContext, transactionAttribute.getQualifier())__		}__		if (tm != null) {_			TransactionContext txContext = new TransactionContext(tm, transactionAttribute)__			runBeforeTransactionMethods(testContext)__			startNewTransaction(testContext, txContext)__			this.transactionContextCache.put(testMethod, txContext)__		}_	};if,the,test,method,of,the,supplied,link,test,context,test,context,is,configured,to,run,within,a,transaction,this,method,will,run,link,before,transaction,064,before,transaction,methods,and,start,a,new,transaction,p,note,that,if,a,code,before,transaction,method,fails,any,remaining,code,before,transaction,methods,will,not,be,invoked,and,a,transaction,will,not,be,started,see,org,springframework,transaction,annotation,transactional,see,org,springframework,test,annotation,not,transactional,see,get,transaction,manager,test,context,string;suppress,warnings,serial,override,public,void,before,test,method,test,context,test,context,throws,exception,final,method,test,method,test,context,get,test,method,assert,not,null,test,method,the,test,method,of,the,supplied,test,context,must,not,be,null,if,this,transaction,context,cache,remove,test,method,null,throw,new,illegal,state,exception,cannot,start,new,transaction,without,ending,existing,transaction,invoke,end,transaction,before,start,new,transaction,if,test,method,is,annotation,present,not,transactional,class,return,platform,transaction,manager,tm,null,transaction,attribute,transaction,attribute,this,attribute,source,get,transaction,attribute,test,method,test,context,get,test,class,if,transaction,attribute,null,transaction,attribute,new,delegating,transaction,attribute,transaction,attribute,public,string,get,name,return,test,method,get,name,if,logger,is,debug,enabled,logger,debug,explicit,transaction,definition,transaction,attribute,found,for,test,context,test,context,tm,get,transaction,manager,test,context,transaction,attribute,get,qualifier,if,tm,null,transaction,context,tx,context,new,transaction,context,tm,transaction,attribute,run,before,transaction,methods,test,context,start,new,transaction,test,context,tx,context,this,transaction,context,cache,put,test,method,tx,context
TransactionalTestExecutionListener -> @SuppressWarnings("serial") 	@Override 	public void beforeTestMethod(TestContext testContext) throws Exception;1355352386;If the test method of the supplied {@link TestContext test context} is_configured to run within a transaction, this method will run_{@link BeforeTransaction &#064_BeforeTransaction methods} and start a new_transaction._<p>Note that if a {@code @BeforeTransaction} method fails, any remaining_{@code @BeforeTransaction} methods will not be invoked, and a transaction_will not be started._@see org.springframework.transaction.annotation.Transactional_@see org.springframework.test.annotation.NotTransactional_@see #getTransactionManager(TestContext, String);@SuppressWarnings("serial")_	@Override_	public void beforeTestMethod(TestContext testContext) throws Exception {_		final Method testMethod = testContext.getTestMethod()__		Assert.notNull(testMethod, "The test method of the supplied TestContext must not be null")___		if (this.transactionContextCache.remove(testMethod) != null) {_			throw new IllegalStateException("Cannot start new transaction without ending existing transaction: "_					+ "Invoke endTransaction() before startNewTransaction().")__		}__		if (testMethod.isAnnotationPresent(NotTransactional.class)) {_			return__		}__		PlatformTransactionManager tm = null__		TransactionAttribute transactionAttribute = this.attributeSource.getTransactionAttribute(testMethod,_			testContext.getTestClass())___		if (transactionAttribute != null) {_			transactionAttribute = new DelegatingTransactionAttribute(transactionAttribute) {__				public String getName() {_					return testMethod.getName()__				}_			}___			if (logger.isDebugEnabled()) {_				logger.debug("Explicit transaction definition [" + transactionAttribute + "] found for test context "_						+ testContext)__			}_			tm = getTransactionManager(testContext, transactionAttribute.getQualifier())__		}__		if (tm != null) {_			TransactionContext txContext = new TransactionContext(tm, transactionAttribute)__			runBeforeTransactionMethods(testContext)__			startNewTransaction(testContext, txContext)__			this.transactionContextCache.put(testMethod, txContext)__		}_	};if,the,test,method,of,the,supplied,link,test,context,test,context,is,configured,to,run,within,a,transaction,this,method,will,run,link,before,transaction,064,before,transaction,methods,and,start,a,new,transaction,p,note,that,if,a,code,before,transaction,method,fails,any,remaining,code,before,transaction,methods,will,not,be,invoked,and,a,transaction,will,not,be,started,see,org,springframework,transaction,annotation,transactional,see,org,springframework,test,annotation,not,transactional,see,get,transaction,manager,test,context,string;suppress,warnings,serial,override,public,void,before,test,method,test,context,test,context,throws,exception,final,method,test,method,test,context,get,test,method,assert,not,null,test,method,the,test,method,of,the,supplied,test,context,must,not,be,null,if,this,transaction,context,cache,remove,test,method,null,throw,new,illegal,state,exception,cannot,start,new,transaction,without,ending,existing,transaction,invoke,end,transaction,before,start,new,transaction,if,test,method,is,annotation,present,not,transactional,class,return,platform,transaction,manager,tm,null,transaction,attribute,transaction,attribute,this,attribute,source,get,transaction,attribute,test,method,test,context,get,test,class,if,transaction,attribute,null,transaction,attribute,new,delegating,transaction,attribute,transaction,attribute,public,string,get,name,return,test,method,get,name,if,logger,is,debug,enabled,logger,debug,explicit,transaction,definition,transaction,attribute,found,for,test,context,test,context,tm,get,transaction,manager,test,context,transaction,attribute,get,qualifier,if,tm,null,transaction,context,tx,context,new,transaction,context,tm,transaction,attribute,run,before,transaction,methods,test,context,start,new,transaction,test,context,tx,context,this,transaction,context,cache,put,test,method,tx,context
TransactionalTestExecutionListener -> @SuppressWarnings("serial") 	@Override 	public void beforeTestMethod(TestContext testContext) throws Exception;1356735495;If the test method of the supplied {@link TestContext test context} is_configured to run within a transaction, this method will run_{@link BeforeTransaction &#064_BeforeTransaction methods} and start a new_transaction._<p>Note that if a {@code @BeforeTransaction} method fails, any remaining_{@code @BeforeTransaction} methods will not be invoked, and a transaction_will not be started._@see org.springframework.transaction.annotation.Transactional_@see org.springframework.test.annotation.NotTransactional_@see #getTransactionManager(TestContext, String);@SuppressWarnings("serial")_	@Override_	public void beforeTestMethod(TestContext testContext) throws Exception {_		final Method testMethod = testContext.getTestMethod()__		Assert.notNull(testMethod, "The test method of the supplied TestContext must not be null")___		if (this.transactionContextCache.remove(testMethod) != null) {_			throw new IllegalStateException("Cannot start new transaction without ending existing transaction: "_					+ "Invoke endTransaction() before startNewTransaction().")__		}__		if (testMethod.isAnnotationPresent(NotTransactional.class)) {_			return__		}__		PlatformTransactionManager tm = null__		TransactionAttribute transactionAttribute = this.attributeSource.getTransactionAttribute(testMethod,_			testContext.getTestClass())___		if (transactionAttribute != null) {_			transactionAttribute = new DelegatingTransactionAttribute(transactionAttribute) {__				@Override_				public String getName() {_					return testMethod.getName()__				}_			}___			if (logger.isDebugEnabled()) {_				logger.debug("Explicit transaction definition [" + transactionAttribute + "] found for test context "_						+ testContext)__			}_			tm = getTransactionManager(testContext, transactionAttribute.getQualifier())__		}__		if (tm != null) {_			TransactionContext txContext = new TransactionContext(tm, transactionAttribute)__			runBeforeTransactionMethods(testContext)__			startNewTransaction(testContext, txContext)__			this.transactionContextCache.put(testMethod, txContext)__		}_	};if,the,test,method,of,the,supplied,link,test,context,test,context,is,configured,to,run,within,a,transaction,this,method,will,run,link,before,transaction,064,before,transaction,methods,and,start,a,new,transaction,p,note,that,if,a,code,before,transaction,method,fails,any,remaining,code,before,transaction,methods,will,not,be,invoked,and,a,transaction,will,not,be,started,see,org,springframework,transaction,annotation,transactional,see,org,springframework,test,annotation,not,transactional,see,get,transaction,manager,test,context,string;suppress,warnings,serial,override,public,void,before,test,method,test,context,test,context,throws,exception,final,method,test,method,test,context,get,test,method,assert,not,null,test,method,the,test,method,of,the,supplied,test,context,must,not,be,null,if,this,transaction,context,cache,remove,test,method,null,throw,new,illegal,state,exception,cannot,start,new,transaction,without,ending,existing,transaction,invoke,end,transaction,before,start,new,transaction,if,test,method,is,annotation,present,not,transactional,class,return,platform,transaction,manager,tm,null,transaction,attribute,transaction,attribute,this,attribute,source,get,transaction,attribute,test,method,test,context,get,test,class,if,transaction,attribute,null,transaction,attribute,new,delegating,transaction,attribute,transaction,attribute,override,public,string,get,name,return,test,method,get,name,if,logger,is,debug,enabled,logger,debug,explicit,transaction,definition,transaction,attribute,found,for,test,context,test,context,tm,get,transaction,manager,test,context,transaction,attribute,get,qualifier,if,tm,null,transaction,context,tx,context,new,transaction,context,tm,transaction,attribute,run,before,transaction,methods,test,context,start,new,transaction,test,context,tx,context,this,transaction,context,cache,put,test,method,tx,context
TransactionalTestExecutionListener -> @SuppressWarnings("serial") 	@Override 	public void beforeTestMethod(TestContext testContext) throws Exception;1357119239;If the test method of the supplied {@link TestContext test context} is_configured to run within a transaction, this method will run_{@link BeforeTransaction &#064_BeforeTransaction methods} and start a new_transaction._<p>Note that if a {@code @BeforeTransaction} method fails, any remaining_{@code @BeforeTransaction} methods will not be invoked, and a transaction_will not be started._@see org.springframework.transaction.annotation.Transactional_@see org.springframework.test.annotation.NotTransactional_@see #getTransactionManager(TestContext, String);@SuppressWarnings("serial")_	@Override_	public void beforeTestMethod(TestContext testContext) throws Exception {_		final Method testMethod = testContext.getTestMethod()__		Assert.notNull(testMethod, "The test method of the supplied TestContext must not be null")___		if (this.transactionContextCache.remove(testMethod) != null) {_			throw new IllegalStateException("Cannot start new transaction without ending existing transaction: "_					+ "Invoke endTransaction() before startNewTransaction().")__		}__		if (testMethod.isAnnotationPresent(NotTransactional.class)) {_			return__		}__		PlatformTransactionManager tm = null__		TransactionAttribute transactionAttribute = this.attributeSource.getTransactionAttribute(testMethod,_			testContext.getTestClass())___		if (transactionAttribute != null) {_			transactionAttribute = new DelegatingTransactionAttribute(transactionAttribute) {__				public String getName() {_					return testMethod.getName()__				}_			}___			if (logger.isDebugEnabled()) {_				logger.debug("Explicit transaction definition [" + transactionAttribute + "] found for test context "_						+ testContext)__			}_			tm = getTransactionManager(testContext, transactionAttribute.getQualifier())__		}__		if (tm != null) {_			TransactionContext txContext = new TransactionContext(tm, transactionAttribute)__			runBeforeTransactionMethods(testContext)__			startNewTransaction(testContext, txContext)__			this.transactionContextCache.put(testMethod, txContext)__		}_	};if,the,test,method,of,the,supplied,link,test,context,test,context,is,configured,to,run,within,a,transaction,this,method,will,run,link,before,transaction,064,before,transaction,methods,and,start,a,new,transaction,p,note,that,if,a,code,before,transaction,method,fails,any,remaining,code,before,transaction,methods,will,not,be,invoked,and,a,transaction,will,not,be,started,see,org,springframework,transaction,annotation,transactional,see,org,springframework,test,annotation,not,transactional,see,get,transaction,manager,test,context,string;suppress,warnings,serial,override,public,void,before,test,method,test,context,test,context,throws,exception,final,method,test,method,test,context,get,test,method,assert,not,null,test,method,the,test,method,of,the,supplied,test,context,must,not,be,null,if,this,transaction,context,cache,remove,test,method,null,throw,new,illegal,state,exception,cannot,start,new,transaction,without,ending,existing,transaction,invoke,end,transaction,before,start,new,transaction,if,test,method,is,annotation,present,not,transactional,class,return,platform,transaction,manager,tm,null,transaction,attribute,transaction,attribute,this,attribute,source,get,transaction,attribute,test,method,test,context,get,test,class,if,transaction,attribute,null,transaction,attribute,new,delegating,transaction,attribute,transaction,attribute,public,string,get,name,return,test,method,get,name,if,logger,is,debug,enabled,logger,debug,explicit,transaction,definition,transaction,attribute,found,for,test,context,test,context,tm,get,transaction,manager,test,context,transaction,attribute,get,qualifier,if,tm,null,transaction,context,tx,context,new,transaction,context,tm,transaction,attribute,run,before,transaction,methods,test,context,start,new,transaction,test,context,tx,context,this,transaction,context,cache,put,test,method,tx,context
TransactionalTestExecutionListener -> @SuppressWarnings("serial") 	@Override 	public void beforeTestMethod(TestContext testContext) throws Exception;1367163114;If the test method of the supplied {@link TestContext test context} is_configured to run within a transaction, this method will run_{@link BeforeTransaction &#064_BeforeTransaction methods} and start a new_transaction._<p>Note that if a {@code @BeforeTransaction} method fails, any remaining_{@code @BeforeTransaction} methods will not be invoked, and a transaction_will not be started._@see org.springframework.transaction.annotation.Transactional_@see #getTransactionManager(TestContext, String);@SuppressWarnings("serial")_	@Override_	public void beforeTestMethod(TestContext testContext) throws Exception {_		final Method testMethod = testContext.getTestMethod()__		Assert.notNull(testMethod, "The test method of the supplied TestContext must not be null")___		if (this.transactionContextCache.remove(testMethod) != null) {_			throw new IllegalStateException("Cannot start new transaction without ending existing transaction: "_					+ "Invoke endTransaction() before startNewTransaction().")__		}__		PlatformTransactionManager tm = null__		TransactionAttribute transactionAttribute = this.attributeSource.getTransactionAttribute(testMethod,_			testContext.getTestClass())___		if (transactionAttribute != null) {_			transactionAttribute = new DelegatingTransactionAttribute(transactionAttribute) {__				public String getName() {_					return testMethod.getName()__				}_			}___			if (logger.isDebugEnabled()) {_				logger.debug("Explicit transaction definition [" + transactionAttribute + "] found for test context "_						+ testContext)__			}__            if (transactionAttribute.getPropagationBehavior() == TransactionDefinition.PROPAGATION_NOT_SUPPORTED) {_                return__            }__            tm = getTransactionManager(testContext, transactionAttribute.getQualifier())__        }__        if (tm != null) {_			TransactionContext txContext = new TransactionContext(tm, transactionAttribute)__			runBeforeTransactionMethods(testContext)__			startNewTransaction(testContext, txContext)__			this.transactionContextCache.put(testMethod, txContext)__		}_	};if,the,test,method,of,the,supplied,link,test,context,test,context,is,configured,to,run,within,a,transaction,this,method,will,run,link,before,transaction,064,before,transaction,methods,and,start,a,new,transaction,p,note,that,if,a,code,before,transaction,method,fails,any,remaining,code,before,transaction,methods,will,not,be,invoked,and,a,transaction,will,not,be,started,see,org,springframework,transaction,annotation,transactional,see,get,transaction,manager,test,context,string;suppress,warnings,serial,override,public,void,before,test,method,test,context,test,context,throws,exception,final,method,test,method,test,context,get,test,method,assert,not,null,test,method,the,test,method,of,the,supplied,test,context,must,not,be,null,if,this,transaction,context,cache,remove,test,method,null,throw,new,illegal,state,exception,cannot,start,new,transaction,without,ending,existing,transaction,invoke,end,transaction,before,start,new,transaction,platform,transaction,manager,tm,null,transaction,attribute,transaction,attribute,this,attribute,source,get,transaction,attribute,test,method,test,context,get,test,class,if,transaction,attribute,null,transaction,attribute,new,delegating,transaction,attribute,transaction,attribute,public,string,get,name,return,test,method,get,name,if,logger,is,debug,enabled,logger,debug,explicit,transaction,definition,transaction,attribute,found,for,test,context,test,context,if,transaction,attribute,get,propagation,behavior,transaction,definition,return,tm,get,transaction,manager,test,context,transaction,attribute,get,qualifier,if,tm,null,transaction,context,tx,context,new,transaction,context,tm,transaction,attribute,run,before,transaction,methods,test,context,start,new,transaction,test,context,tx,context,this,transaction,context,cache,put,test,method,tx,context
TransactionalTestExecutionListener -> @SuppressWarnings("serial") 	@Override 	public void beforeTestMethod(TestContext testContext) throws Exception;1367873075;If the test method of the supplied {@link TestContext test context} is_configured to run within a transaction, this method will run_{@link BeforeTransaction &#064_BeforeTransaction methods} and start a new_transaction._<p>Note that if a {@code @BeforeTransaction} method fails, any remaining_{@code @BeforeTransaction} methods will not be invoked, and a transaction_will not be started._@see org.springframework.transaction.annotation.Transactional_@see #getTransactionManager(TestContext, String);@SuppressWarnings("serial")_	@Override_	public void beforeTestMethod(TestContext testContext) throws Exception {_		final Method testMethod = testContext.getTestMethod()__		Assert.notNull(testMethod, "The test method of the supplied TestContext must not be null")___		if (this.transactionContextCache.remove(testMethod) != null) {_			throw new IllegalStateException("Cannot start new transaction without ending existing transaction: "_					+ "Invoke endTransaction() before startNewTransaction().")__		}__		PlatformTransactionManager tm = null__		TransactionAttribute transactionAttribute = this.attributeSource.getTransactionAttribute(testMethod,_			testContext.getTestClass())___		if (transactionAttribute != null) {_			transactionAttribute = new DelegatingTransactionAttribute(transactionAttribute) {__				public String getName() {_					return testMethod.getName()__				}_			}___			if (logger.isDebugEnabled()) {_				logger.debug("Explicit transaction definition [" + transactionAttribute + "] found for test context "_						+ testContext)__			}__            if (transactionAttribute.getPropagationBehavior() == TransactionDefinition.PROPAGATION_NOT_SUPPORTED) {_                return__            }__            tm = getTransactionManager(testContext, transactionAttribute.getQualifier())__        }__        if (tm != null) {_			TransactionContext txContext = new TransactionContext(tm, transactionAttribute)__			runBeforeTransactionMethods(testContext)__			startNewTransaction(testContext, txContext)__			this.transactionContextCache.put(testMethod, txContext)__		}_	};if,the,test,method,of,the,supplied,link,test,context,test,context,is,configured,to,run,within,a,transaction,this,method,will,run,link,before,transaction,064,before,transaction,methods,and,start,a,new,transaction,p,note,that,if,a,code,before,transaction,method,fails,any,remaining,code,before,transaction,methods,will,not,be,invoked,and,a,transaction,will,not,be,started,see,org,springframework,transaction,annotation,transactional,see,get,transaction,manager,test,context,string;suppress,warnings,serial,override,public,void,before,test,method,test,context,test,context,throws,exception,final,method,test,method,test,context,get,test,method,assert,not,null,test,method,the,test,method,of,the,supplied,test,context,must,not,be,null,if,this,transaction,context,cache,remove,test,method,null,throw,new,illegal,state,exception,cannot,start,new,transaction,without,ending,existing,transaction,invoke,end,transaction,before,start,new,transaction,platform,transaction,manager,tm,null,transaction,attribute,transaction,attribute,this,attribute,source,get,transaction,attribute,test,method,test,context,get,test,class,if,transaction,attribute,null,transaction,attribute,new,delegating,transaction,attribute,transaction,attribute,public,string,get,name,return,test,method,get,name,if,logger,is,debug,enabled,logger,debug,explicit,transaction,definition,transaction,attribute,found,for,test,context,test,context,if,transaction,attribute,get,propagation,behavior,transaction,definition,return,tm,get,transaction,manager,test,context,transaction,attribute,get,qualifier,if,tm,null,transaction,context,tx,context,new,transaction,context,tm,transaction,attribute,run,before,transaction,methods,test,context,start,new,transaction,test,context,tx,context,this,transaction,context,cache,put,test,method,tx,context
TransactionalTestExecutionListener -> @SuppressWarnings("serial") 	@Override 	public void beforeTestMethod(TestContext testContext) throws Exception;1368482696;If the test method of the supplied {@link TestContext test context} is_configured to run within a transaction, this method will run_{@link BeforeTransaction &#064_BeforeTransaction methods} and start a new_transaction._<p>Note that if a {@code @BeforeTransaction} method fails, any remaining_{@code @BeforeTransaction} methods will not be invoked, and a transaction_will not be started._@see org.springframework.transaction.annotation.Transactional_@see #getTransactionManager(TestContext, String);@SuppressWarnings("serial")_	@Override_	public void beforeTestMethod(TestContext testContext) throws Exception {_		final Method testMethod = testContext.getTestMethod()__		Assert.notNull(testMethod, "The test method of the supplied TestContext must not be null")___		if (this.transactionContextCache.remove(testMethod) != null) {_			throw new IllegalStateException("Cannot start new transaction without ending existing transaction: "_					+ "Invoke endTransaction() before startNewTransaction().")__		}__		PlatformTransactionManager tm = null__		TransactionAttribute transactionAttribute = this.attributeSource.getTransactionAttribute(testMethod,_			testContext.getTestClass())___		if (transactionAttribute != null) {_			transactionAttribute = new DelegatingTransactionAttribute(transactionAttribute) {__				@Override_				public String getName() {_					return testMethod.getName()__				}_			}___			if (logger.isDebugEnabled()) {_				logger.debug("Explicit transaction definition [" + transactionAttribute + "] found for test context "_						+ testContext)__			}__            if (transactionAttribute.getPropagationBehavior() == TransactionDefinition.PROPAGATION_NOT_SUPPORTED) {_                return__            }__            tm = getTransactionManager(testContext, transactionAttribute.getQualifier())__        }__        if (tm != null) {_			TransactionContext txContext = new TransactionContext(tm, transactionAttribute)__			runBeforeTransactionMethods(testContext)__			startNewTransaction(testContext, txContext)__			this.transactionContextCache.put(testMethod, txContext)__		}_	};if,the,test,method,of,the,supplied,link,test,context,test,context,is,configured,to,run,within,a,transaction,this,method,will,run,link,before,transaction,064,before,transaction,methods,and,start,a,new,transaction,p,note,that,if,a,code,before,transaction,method,fails,any,remaining,code,before,transaction,methods,will,not,be,invoked,and,a,transaction,will,not,be,started,see,org,springframework,transaction,annotation,transactional,see,get,transaction,manager,test,context,string;suppress,warnings,serial,override,public,void,before,test,method,test,context,test,context,throws,exception,final,method,test,method,test,context,get,test,method,assert,not,null,test,method,the,test,method,of,the,supplied,test,context,must,not,be,null,if,this,transaction,context,cache,remove,test,method,null,throw,new,illegal,state,exception,cannot,start,new,transaction,without,ending,existing,transaction,invoke,end,transaction,before,start,new,transaction,platform,transaction,manager,tm,null,transaction,attribute,transaction,attribute,this,attribute,source,get,transaction,attribute,test,method,test,context,get,test,class,if,transaction,attribute,null,transaction,attribute,new,delegating,transaction,attribute,transaction,attribute,override,public,string,get,name,return,test,method,get,name,if,logger,is,debug,enabled,logger,debug,explicit,transaction,definition,transaction,attribute,found,for,test,context,test,context,if,transaction,attribute,get,propagation,behavior,transaction,definition,return,tm,get,transaction,manager,test,context,transaction,attribute,get,qualifier,if,tm,null,transaction,context,tx,context,new,transaction,context,tm,transaction,attribute,run,before,transaction,methods,test,context,start,new,transaction,test,context,tx,context,this,transaction,context,cache,put,test,method,tx,context
TransactionalTestExecutionListener -> @SuppressWarnings("serial") 	@Override 	public void beforeTestMethod(TestContext testContext) throws Exception;1382920864;If the test method of the supplied {@link TestContext test context} is_configured to run within a transaction, this method will run_{@link BeforeTransaction &#064_BeforeTransaction methods} and start a new_transaction._<p>Note that if a {@code @BeforeTransaction} method fails, any remaining_{@code @BeforeTransaction} methods will not be invoked, and a transaction_will not be started._@see org.springframework.transaction.annotation.Transactional_@see #getTransactionManager(TestContext, String);@SuppressWarnings("serial")_	@Override_	public void beforeTestMethod(TestContext testContext) throws Exception {_		final Method testMethod = testContext.getTestMethod()__		Assert.notNull(testMethod, "The test method of the supplied TestContext must not be null")___		if (this.transactionContextCache.remove(testMethod) != null) {_			throw new IllegalStateException("Cannot start new transaction without ending existing transaction: "_					+ "Invoke endTransaction() before startNewTransaction().")__		}__		PlatformTransactionManager tm = null__		TransactionAttribute transactionAttribute = this.attributeSource.getTransactionAttribute(testMethod,_			testContext.getTestClass())___		if (transactionAttribute != null) {_			transactionAttribute = new DelegatingTransactionAttribute(transactionAttribute) {__				@Override_				public String getName() {_					return testMethod.getName()__				}_			}___			if (logger.isDebugEnabled()) {_				logger.debug("Explicit transaction definition [" + transactionAttribute + "] found for test context "_						+ testContext)__			}__			if (transactionAttribute.getPropagationBehavior() == TransactionDefinition.PROPAGATION_NOT_SUPPORTED) {_				return__			}__			tm = getTransactionManager(testContext, transactionAttribute.getQualifier())__		}__		if (tm != null) {_			TransactionContext txContext = new TransactionContext(tm, transactionAttribute)__			runBeforeTransactionMethods(testContext)__			startNewTransaction(testContext, txContext)__			this.transactionContextCache.put(testMethod, txContext)__		}_	};if,the,test,method,of,the,supplied,link,test,context,test,context,is,configured,to,run,within,a,transaction,this,method,will,run,link,before,transaction,064,before,transaction,methods,and,start,a,new,transaction,p,note,that,if,a,code,before,transaction,method,fails,any,remaining,code,before,transaction,methods,will,not,be,invoked,and,a,transaction,will,not,be,started,see,org,springframework,transaction,annotation,transactional,see,get,transaction,manager,test,context,string;suppress,warnings,serial,override,public,void,before,test,method,test,context,test,context,throws,exception,final,method,test,method,test,context,get,test,method,assert,not,null,test,method,the,test,method,of,the,supplied,test,context,must,not,be,null,if,this,transaction,context,cache,remove,test,method,null,throw,new,illegal,state,exception,cannot,start,new,transaction,without,ending,existing,transaction,invoke,end,transaction,before,start,new,transaction,platform,transaction,manager,tm,null,transaction,attribute,transaction,attribute,this,attribute,source,get,transaction,attribute,test,method,test,context,get,test,class,if,transaction,attribute,null,transaction,attribute,new,delegating,transaction,attribute,transaction,attribute,override,public,string,get,name,return,test,method,get,name,if,logger,is,debug,enabled,logger,debug,explicit,transaction,definition,transaction,attribute,found,for,test,context,test,context,if,transaction,attribute,get,propagation,behavior,transaction,definition,return,tm,get,transaction,manager,test,context,transaction,attribute,get,qualifier,if,tm,null,transaction,context,tx,context,new,transaction,context,tm,transaction,attribute,run,before,transaction,methods,test,context,start,new,transaction,test,context,tx,context,this,transaction,context,cache,put,test,method,tx,context
TransactionalTestExecutionListener -> @SuppressWarnings("serial") 	@Override 	public void beforeTestMethod(TestContext testContext) throws Exception;1385499540;If the test method of the supplied {@link TestContext test context} is_configured to run within a transaction, this method will run_{@link BeforeTransaction &#064_BeforeTransaction methods} and start a new_transaction._<p>Note that if a {@code @BeforeTransaction} method fails, any remaining_{@code @BeforeTransaction} methods will not be invoked, and a transaction_will not be started._@see org.springframework.transaction.annotation.Transactional_@see #getTransactionManager(TestContext, String);@SuppressWarnings("serial")_	@Override_	public void beforeTestMethod(TestContext testContext) throws Exception {_		final Method testMethod = testContext.getTestMethod()__		Assert.notNull(testMethod, "The test method of the supplied TestContext must not be null")___		if (this.transactionContextCache.remove(testMethod) != null) {_			throw new IllegalStateException("Cannot start new transaction without ending existing transaction: "_					+ "Invoke endTransaction() before startNewTransaction().")__		}__		PlatformTransactionManager tm = null__		TransactionAttribute transactionAttribute = this.attributeSource.getTransactionAttribute(testMethod,_			testContext.getTestClass())___		if (transactionAttribute != null) {_			transactionAttribute = new DelegatingTransactionAttribute(transactionAttribute) {__				@Override_				public String getName() {_					return testMethod.getName()__				}_			}___			if (logger.isDebugEnabled()) {_				logger.debug("Explicit transaction definition [" + transactionAttribute + "] found for test context "_						+ testContext)__			}__			if (transactionAttribute.getPropagationBehavior() == TransactionDefinition.PROPAGATION_NOT_SUPPORTED) {_				return__			}__			tm = getTransactionManager(testContext, transactionAttribute.getQualifier())__		}__		if (tm != null) {_			TransactionContext txContext = new TransactionContext(tm, transactionAttribute)__			runBeforeTransactionMethods(testContext)__			startNewTransaction(testContext, txContext)__			this.transactionContextCache.put(testMethod, txContext)__		}_	};if,the,test,method,of,the,supplied,link,test,context,test,context,is,configured,to,run,within,a,transaction,this,method,will,run,link,before,transaction,064,before,transaction,methods,and,start,a,new,transaction,p,note,that,if,a,code,before,transaction,method,fails,any,remaining,code,before,transaction,methods,will,not,be,invoked,and,a,transaction,will,not,be,started,see,org,springframework,transaction,annotation,transactional,see,get,transaction,manager,test,context,string;suppress,warnings,serial,override,public,void,before,test,method,test,context,test,context,throws,exception,final,method,test,method,test,context,get,test,method,assert,not,null,test,method,the,test,method,of,the,supplied,test,context,must,not,be,null,if,this,transaction,context,cache,remove,test,method,null,throw,new,illegal,state,exception,cannot,start,new,transaction,without,ending,existing,transaction,invoke,end,transaction,before,start,new,transaction,platform,transaction,manager,tm,null,transaction,attribute,transaction,attribute,this,attribute,source,get,transaction,attribute,test,method,test,context,get,test,class,if,transaction,attribute,null,transaction,attribute,new,delegating,transaction,attribute,transaction,attribute,override,public,string,get,name,return,test,method,get,name,if,logger,is,debug,enabled,logger,debug,explicit,transaction,definition,transaction,attribute,found,for,test,context,test,context,if,transaction,attribute,get,propagation,behavior,transaction,definition,return,tm,get,transaction,manager,test,context,transaction,attribute,get,qualifier,if,tm,null,transaction,context,tx,context,new,transaction,context,tm,transaction,attribute,run,before,transaction,methods,test,context,start,new,transaction,test,context,tx,context,this,transaction,context,cache,put,test,method,tx,context
TransactionalTestExecutionListener -> @SuppressWarnings("serial") 	@Override 	public void beforeTestMethod(TestContext testContext) throws Exception;1389966876;If the test method of the supplied {@link TestContext test context} is_configured to run within a transaction, this method will run_{@link BeforeTransaction &#064_BeforeTransaction methods} and start a new_transaction._<p>Note that if a {@code @BeforeTransaction} method fails, any remaining_{@code @BeforeTransaction} methods will not be invoked, and a transaction_will not be started._@see org.springframework.transaction.annotation.Transactional_@see #getTransactionManager(TestContext, String);@SuppressWarnings("serial")_	@Override_	public void beforeTestMethod(TestContext testContext) throws Exception {_		final Method testMethod = testContext.getTestMethod()__		Assert.notNull(testMethod, "The test method of the supplied TestContext must not be null")___		if (this.transactionContextCache.remove(testMethod) != null) {_			throw new IllegalStateException("Cannot start new transaction without ending existing transaction: "_					+ "Invoke endTransaction() before startNewTransaction().")__		}__		PlatformTransactionManager tm = null__		TransactionAttribute transactionAttribute = this.attributeSource.getTransactionAttribute(testMethod,_			testContext.getTestClass())___		if (transactionAttribute != null) {_			transactionAttribute = new DelegatingTransactionAttribute(transactionAttribute) {__				@Override_				public String getName() {_					return testMethod.getName()__				}_			}___			if (logger.isDebugEnabled()) {_				logger.debug("Explicit transaction definition [" + transactionAttribute + "] found for test context "_						+ testContext)__			}__			if (transactionAttribute.getPropagationBehavior() == TransactionDefinition.PROPAGATION_NOT_SUPPORTED) {_				return__			}__			tm = getTransactionManager(testContext, transactionAttribute.getQualifier())__		}__		if (tm != null) {_			TransactionContext txContext = new TransactionContext(tm, transactionAttribute)__			runBeforeTransactionMethods(testContext)__			startNewTransaction(testContext, txContext)__			this.transactionContextCache.put(testMethod, txContext)__		}_	};if,the,test,method,of,the,supplied,link,test,context,test,context,is,configured,to,run,within,a,transaction,this,method,will,run,link,before,transaction,064,before,transaction,methods,and,start,a,new,transaction,p,note,that,if,a,code,before,transaction,method,fails,any,remaining,code,before,transaction,methods,will,not,be,invoked,and,a,transaction,will,not,be,started,see,org,springframework,transaction,annotation,transactional,see,get,transaction,manager,test,context,string;suppress,warnings,serial,override,public,void,before,test,method,test,context,test,context,throws,exception,final,method,test,method,test,context,get,test,method,assert,not,null,test,method,the,test,method,of,the,supplied,test,context,must,not,be,null,if,this,transaction,context,cache,remove,test,method,null,throw,new,illegal,state,exception,cannot,start,new,transaction,without,ending,existing,transaction,invoke,end,transaction,before,start,new,transaction,platform,transaction,manager,tm,null,transaction,attribute,transaction,attribute,this,attribute,source,get,transaction,attribute,test,method,test,context,get,test,class,if,transaction,attribute,null,transaction,attribute,new,delegating,transaction,attribute,transaction,attribute,override,public,string,get,name,return,test,method,get,name,if,logger,is,debug,enabled,logger,debug,explicit,transaction,definition,transaction,attribute,found,for,test,context,test,context,if,transaction,attribute,get,propagation,behavior,transaction,definition,return,tm,get,transaction,manager,test,context,transaction,attribute,get,qualifier,if,tm,null,transaction,context,tx,context,new,transaction,context,tm,transaction,attribute,run,before,transaction,methods,test,context,start,new,transaction,test,context,tx,context,this,transaction,context,cache,put,test,method,tx,context
TransactionalTestExecutionListener -> protected final boolean isRollback(TestContext testContext) throws Exception;1328020251;Determine whether or not to rollback transactions for the supplied_{@link TestContext test context} by taking into consideration the_{@link #isDefaultRollback(TestContext) default rollback} flag and a_possible method-level override via the {@link Rollback} annotation._@param testContext the test context for which the rollback flag_should be retrieved_@return the <em>rollback</em> flag for the supplied test context_@throws Exception if an error occurs while determining the rollback flag;protected final boolean isRollback(TestContext testContext) throws Exception {_		boolean rollback = isDefaultRollback(testContext)__		Rollback rollbackAnnotation = testContext.getTestMethod().getAnnotation(Rollback.class)__		if (rollbackAnnotation != null) {_			boolean rollbackOverride = rollbackAnnotation.value()__			if (logger.isDebugEnabled()) {_				logger.debug("Method-level @Rollback(" + rollbackOverride + ") overrides default rollback [" + rollback_						+ "] for test context [" + testContext + "]")__			}_			rollback = rollbackOverride__		}_		else {_			if (logger.isDebugEnabled()) {_				logger.debug("No method-level @Rollback override: using default rollback [" + rollback_						+ "] for test context [" + testContext + "]")__			}_		}_		return rollback__	};determine,whether,or,not,to,rollback,transactions,for,the,supplied,link,test,context,test,context,by,taking,into,consideration,the,link,is,default,rollback,test,context,default,rollback,flag,and,a,possible,method,level,override,via,the,link,rollback,annotation,param,test,context,the,test,context,for,which,the,rollback,flag,should,be,retrieved,return,the,em,rollback,em,flag,for,the,supplied,test,context,throws,exception,if,an,error,occurs,while,determining,the,rollback,flag;protected,final,boolean,is,rollback,test,context,test,context,throws,exception,boolean,rollback,is,default,rollback,test,context,rollback,rollback,annotation,test,context,get,test,method,get,annotation,rollback,class,if,rollback,annotation,null,boolean,rollback,override,rollback,annotation,value,if,logger,is,debug,enabled,logger,debug,method,level,rollback,rollback,override,overrides,default,rollback,rollback,for,test,context,test,context,rollback,rollback,override,else,if,logger,is,debug,enabled,logger,debug,no,method,level,rollback,override,using,default,rollback,rollback,for,test,context,test,context,return,rollback
TransactionalTestExecutionListener -> protected final boolean isRollback(TestContext testContext) throws Exception;1337516454;Determine whether or not to rollback transactions for the supplied_{@link TestContext test context} by taking into consideration the_{@link #isDefaultRollback(TestContext) default rollback} flag and a_possible method-level override via the {@link Rollback} annotation._@param testContext the test context for which the rollback flag_should be retrieved_@return the <em>rollback</em> flag for the supplied test context_@throws Exception if an error occurs while determining the rollback flag;protected final boolean isRollback(TestContext testContext) throws Exception {_		boolean rollback = isDefaultRollback(testContext)__		Rollback rollbackAnnotation = testContext.getTestMethod().getAnnotation(Rollback.class)__		if (rollbackAnnotation != null) {_			boolean rollbackOverride = rollbackAnnotation.value()__			if (logger.isDebugEnabled()) {_				logger.debug("Method-level @Rollback(" + rollbackOverride + ") overrides default rollback [" + rollback_						+ "] for test context [" + testContext + "]")__			}_			rollback = rollbackOverride__		}_		else {_			if (logger.isDebugEnabled()) {_				logger.debug("No method-level @Rollback override: using default rollback [" + rollback_						+ "] for test context [" + testContext + "]")__			}_		}_		return rollback__	};determine,whether,or,not,to,rollback,transactions,for,the,supplied,link,test,context,test,context,by,taking,into,consideration,the,link,is,default,rollback,test,context,default,rollback,flag,and,a,possible,method,level,override,via,the,link,rollback,annotation,param,test,context,the,test,context,for,which,the,rollback,flag,should,be,retrieved,return,the,em,rollback,em,flag,for,the,supplied,test,context,throws,exception,if,an,error,occurs,while,determining,the,rollback,flag;protected,final,boolean,is,rollback,test,context,test,context,throws,exception,boolean,rollback,is,default,rollback,test,context,rollback,rollback,annotation,test,context,get,test,method,get,annotation,rollback,class,if,rollback,annotation,null,boolean,rollback,override,rollback,annotation,value,if,logger,is,debug,enabled,logger,debug,method,level,rollback,rollback,override,overrides,default,rollback,rollback,for,test,context,test,context,rollback,rollback,override,else,if,logger,is,debug,enabled,logger,debug,no,method,level,rollback,override,using,default,rollback,rollback,for,test,context,test,context,return,rollback
TransactionalTestExecutionListener -> protected final boolean isRollback(TestContext testContext) throws Exception;1338031377;Determine whether or not to rollback transactions for the supplied_{@link TestContext test context} by taking into consideration the_{@link #isDefaultRollback(TestContext) default rollback} flag and a_possible method-level override via the {@link Rollback} annotation._@param testContext the test context for which the rollback flag_should be retrieved_@return the <em>rollback</em> flag for the supplied test context_@throws Exception if an error occurs while determining the rollback flag;protected final boolean isRollback(TestContext testContext) throws Exception {_		boolean rollback = isDefaultRollback(testContext)__		Rollback rollbackAnnotation = testContext.getTestMethod().getAnnotation(Rollback.class)__		if (rollbackAnnotation != null) {_			boolean rollbackOverride = rollbackAnnotation.value()__			if (logger.isDebugEnabled()) {_				logger.debug("Method-level @Rollback(" + rollbackOverride + ") overrides default rollback [" + rollback_						+ "] for test context [" + testContext + "]")__			}_			rollback = rollbackOverride__		}_		else {_			if (logger.isDebugEnabled()) {_				logger.debug("No method-level @Rollback override: using default rollback [" + rollback_						+ "] for test context [" + testContext + "]")__			}_		}_		return rollback__	};determine,whether,or,not,to,rollback,transactions,for,the,supplied,link,test,context,test,context,by,taking,into,consideration,the,link,is,default,rollback,test,context,default,rollback,flag,and,a,possible,method,level,override,via,the,link,rollback,annotation,param,test,context,the,test,context,for,which,the,rollback,flag,should,be,retrieved,return,the,em,rollback,em,flag,for,the,supplied,test,context,throws,exception,if,an,error,occurs,while,determining,the,rollback,flag;protected,final,boolean,is,rollback,test,context,test,context,throws,exception,boolean,rollback,is,default,rollback,test,context,rollback,rollback,annotation,test,context,get,test,method,get,annotation,rollback,class,if,rollback,annotation,null,boolean,rollback,override,rollback,annotation,value,if,logger,is,debug,enabled,logger,debug,method,level,rollback,rollback,override,overrides,default,rollback,rollback,for,test,context,test,context,rollback,rollback,override,else,if,logger,is,debug,enabled,logger,debug,no,method,level,rollback,override,using,default,rollback,rollback,for,test,context,test,context,return,rollback
TransactionalTestExecutionListener -> protected final boolean isRollback(TestContext testContext) throws Exception;1343426806;Determine whether or not to rollback transactions for the supplied_{@link TestContext test context} by taking into consideration the_{@link #isDefaultRollback(TestContext) default rollback} flag and a_possible method-level override via the {@link Rollback} annotation._@param testContext the test context for which the rollback flag_should be retrieved_@return the <em>rollback</em> flag for the supplied test context_@throws Exception if an error occurs while determining the rollback flag;protected final boolean isRollback(TestContext testContext) throws Exception {_		boolean rollback = isDefaultRollback(testContext)__		Rollback rollbackAnnotation = testContext.getTestMethod().getAnnotation(Rollback.class)__		if (rollbackAnnotation != null) {_			boolean rollbackOverride = rollbackAnnotation.value()__			if (logger.isDebugEnabled()) {_				logger.debug("Method-level @Rollback(" + rollbackOverride + ") overrides default rollback [" + rollback_						+ "] for test context " + testContext)__			}_			rollback = rollbackOverride__		}_		else {_			if (logger.isDebugEnabled()) {_				logger.debug("No method-level @Rollback override: using default rollback [" + rollback_						+ "] for test context " + testContext)__			}_		}_		return rollback__	};determine,whether,or,not,to,rollback,transactions,for,the,supplied,link,test,context,test,context,by,taking,into,consideration,the,link,is,default,rollback,test,context,default,rollback,flag,and,a,possible,method,level,override,via,the,link,rollback,annotation,param,test,context,the,test,context,for,which,the,rollback,flag,should,be,retrieved,return,the,em,rollback,em,flag,for,the,supplied,test,context,throws,exception,if,an,error,occurs,while,determining,the,rollback,flag;protected,final,boolean,is,rollback,test,context,test,context,throws,exception,boolean,rollback,is,default,rollback,test,context,rollback,rollback,annotation,test,context,get,test,method,get,annotation,rollback,class,if,rollback,annotation,null,boolean,rollback,override,rollback,annotation,value,if,logger,is,debug,enabled,logger,debug,method,level,rollback,rollback,override,overrides,default,rollback,rollback,for,test,context,test,context,rollback,rollback,override,else,if,logger,is,debug,enabled,logger,debug,no,method,level,rollback,override,using,default,rollback,rollback,for,test,context,test,context,return,rollback
TransactionalTestExecutionListener -> protected final boolean isRollback(TestContext testContext) throws Exception;1343431472;Determine whether or not to rollback transactions for the supplied_{@link TestContext test context} by taking into consideration the_{@link #isDefaultRollback(TestContext) default rollback} flag and a_possible method-level override via the {@link Rollback} annotation._@param testContext the test context for which the rollback flag_should be retrieved_@return the <em>rollback</em> flag for the supplied test context_@throws Exception if an error occurs while determining the rollback flag;protected final boolean isRollback(TestContext testContext) throws Exception {_		boolean rollback = isDefaultRollback(testContext)__		Rollback rollbackAnnotation = testContext.getTestMethod().getAnnotation(Rollback.class)__		if (rollbackAnnotation != null) {_			boolean rollbackOverride = rollbackAnnotation.value()__			if (logger.isDebugEnabled()) {_				logger.debug("Method-level @Rollback(" + rollbackOverride + ") overrides default rollback [" + rollback_						+ "] for test context " + testContext)__			}_			rollback = rollbackOverride__		}_		else {_			if (logger.isDebugEnabled()) {_				logger.debug("No method-level @Rollback override: using default rollback [" + rollback_						+ "] for test context " + testContext)__			}_		}_		return rollback__	};determine,whether,or,not,to,rollback,transactions,for,the,supplied,link,test,context,test,context,by,taking,into,consideration,the,link,is,default,rollback,test,context,default,rollback,flag,and,a,possible,method,level,override,via,the,link,rollback,annotation,param,test,context,the,test,context,for,which,the,rollback,flag,should,be,retrieved,return,the,em,rollback,em,flag,for,the,supplied,test,context,throws,exception,if,an,error,occurs,while,determining,the,rollback,flag;protected,final,boolean,is,rollback,test,context,test,context,throws,exception,boolean,rollback,is,default,rollback,test,context,rollback,rollback,annotation,test,context,get,test,method,get,annotation,rollback,class,if,rollback,annotation,null,boolean,rollback,override,rollback,annotation,value,if,logger,is,debug,enabled,logger,debug,method,level,rollback,rollback,override,overrides,default,rollback,rollback,for,test,context,test,context,rollback,rollback,override,else,if,logger,is,debug,enabled,logger,debug,no,method,level,rollback,override,using,default,rollback,rollback,for,test,context,test,context,return,rollback
TransactionalTestExecutionListener -> protected final boolean isRollback(TestContext testContext) throws Exception;1354571539;Determine whether or not to rollback transactions for the supplied_{@link TestContext test context} by taking into consideration the_{@link #isDefaultRollback(TestContext) default rollback} flag and a_possible method-level override via the {@link Rollback} annotation._@param testContext the test context for which the rollback flag_should be retrieved_@return the <em>rollback</em> flag for the supplied test context_@throws Exception if an error occurs while determining the rollback flag;protected final boolean isRollback(TestContext testContext) throws Exception {_		boolean rollback = isDefaultRollback(testContext)__		Rollback rollbackAnnotation = testContext.getTestMethod().getAnnotation(Rollback.class)__		if (rollbackAnnotation != null) {_			boolean rollbackOverride = rollbackAnnotation.value()__			if (logger.isDebugEnabled()) {_				logger.debug("Method-level @Rollback(" + rollbackOverride + ") overrides default rollback [" + rollback_						+ "] for test context " + testContext)__			}_			rollback = rollbackOverride__		}_		else {_			if (logger.isDebugEnabled()) {_				logger.debug("No method-level @Rollback override: using default rollback [" + rollback_						+ "] for test context " + testContext)__			}_		}_		return rollback__	};determine,whether,or,not,to,rollback,transactions,for,the,supplied,link,test,context,test,context,by,taking,into,consideration,the,link,is,default,rollback,test,context,default,rollback,flag,and,a,possible,method,level,override,via,the,link,rollback,annotation,param,test,context,the,test,context,for,which,the,rollback,flag,should,be,retrieved,return,the,em,rollback,em,flag,for,the,supplied,test,context,throws,exception,if,an,error,occurs,while,determining,the,rollback,flag;protected,final,boolean,is,rollback,test,context,test,context,throws,exception,boolean,rollback,is,default,rollback,test,context,rollback,rollback,annotation,test,context,get,test,method,get,annotation,rollback,class,if,rollback,annotation,null,boolean,rollback,override,rollback,annotation,value,if,logger,is,debug,enabled,logger,debug,method,level,rollback,rollback,override,overrides,default,rollback,rollback,for,test,context,test,context,rollback,rollback,override,else,if,logger,is,debug,enabled,logger,debug,no,method,level,rollback,override,using,default,rollback,rollback,for,test,context,test,context,return,rollback
TransactionalTestExecutionListener -> protected final boolean isRollback(TestContext testContext) throws Exception;1355352386;Determine whether or not to rollback transactions for the supplied_{@link TestContext test context} by taking into consideration the_{@link #isDefaultRollback(TestContext) default rollback} flag and a_possible method-level override via the {@link Rollback} annotation._@param testContext the test context for which the rollback flag_should be retrieved_@return the <em>rollback</em> flag for the supplied test context_@throws Exception if an error occurs while determining the rollback flag;protected final boolean isRollback(TestContext testContext) throws Exception {_		boolean rollback = isDefaultRollback(testContext)__		Rollback rollbackAnnotation = testContext.getTestMethod().getAnnotation(Rollback.class)__		if (rollbackAnnotation != null) {_			boolean rollbackOverride = rollbackAnnotation.value()__			if (logger.isDebugEnabled()) {_				logger.debug("Method-level @Rollback(" + rollbackOverride + ") overrides default rollback [" + rollback_						+ "] for test context " + testContext)__			}_			rollback = rollbackOverride__		}_		else {_			if (logger.isDebugEnabled()) {_				logger.debug("No method-level @Rollback override: using default rollback [" + rollback_						+ "] for test context " + testContext)__			}_		}_		return rollback__	};determine,whether,or,not,to,rollback,transactions,for,the,supplied,link,test,context,test,context,by,taking,into,consideration,the,link,is,default,rollback,test,context,default,rollback,flag,and,a,possible,method,level,override,via,the,link,rollback,annotation,param,test,context,the,test,context,for,which,the,rollback,flag,should,be,retrieved,return,the,em,rollback,em,flag,for,the,supplied,test,context,throws,exception,if,an,error,occurs,while,determining,the,rollback,flag;protected,final,boolean,is,rollback,test,context,test,context,throws,exception,boolean,rollback,is,default,rollback,test,context,rollback,rollback,annotation,test,context,get,test,method,get,annotation,rollback,class,if,rollback,annotation,null,boolean,rollback,override,rollback,annotation,value,if,logger,is,debug,enabled,logger,debug,method,level,rollback,rollback,override,overrides,default,rollback,rollback,for,test,context,test,context,rollback,rollback,override,else,if,logger,is,debug,enabled,logger,debug,no,method,level,rollback,override,using,default,rollback,rollback,for,test,context,test,context,return,rollback
TransactionalTestExecutionListener -> protected final boolean isRollback(TestContext testContext) throws Exception;1356735495;Determine whether or not to rollback transactions for the supplied_{@link TestContext test context} by taking into consideration the_{@link #isDefaultRollback(TestContext) default rollback} flag and a_possible method-level override via the {@link Rollback} annotation._@param testContext the test context for which the rollback flag_should be retrieved_@return the <em>rollback</em> flag for the supplied test context_@throws Exception if an error occurs while determining the rollback flag;protected final boolean isRollback(TestContext testContext) throws Exception {_		boolean rollback = isDefaultRollback(testContext)__		Rollback rollbackAnnotation = testContext.getTestMethod().getAnnotation(Rollback.class)__		if (rollbackAnnotation != null) {_			boolean rollbackOverride = rollbackAnnotation.value()__			if (logger.isDebugEnabled()) {_				logger.debug("Method-level @Rollback(" + rollbackOverride + ") overrides default rollback [" + rollback_						+ "] for test context " + testContext)__			}_			rollback = rollbackOverride__		}_		else {_			if (logger.isDebugEnabled()) {_				logger.debug("No method-level @Rollback override: using default rollback [" + rollback_						+ "] for test context " + testContext)__			}_		}_		return rollback__	};determine,whether,or,not,to,rollback,transactions,for,the,supplied,link,test,context,test,context,by,taking,into,consideration,the,link,is,default,rollback,test,context,default,rollback,flag,and,a,possible,method,level,override,via,the,link,rollback,annotation,param,test,context,the,test,context,for,which,the,rollback,flag,should,be,retrieved,return,the,em,rollback,em,flag,for,the,supplied,test,context,throws,exception,if,an,error,occurs,while,determining,the,rollback,flag;protected,final,boolean,is,rollback,test,context,test,context,throws,exception,boolean,rollback,is,default,rollback,test,context,rollback,rollback,annotation,test,context,get,test,method,get,annotation,rollback,class,if,rollback,annotation,null,boolean,rollback,override,rollback,annotation,value,if,logger,is,debug,enabled,logger,debug,method,level,rollback,rollback,override,overrides,default,rollback,rollback,for,test,context,test,context,rollback,rollback,override,else,if,logger,is,debug,enabled,logger,debug,no,method,level,rollback,override,using,default,rollback,rollback,for,test,context,test,context,return,rollback
TransactionalTestExecutionListener -> protected final boolean isRollback(TestContext testContext) throws Exception;1357119239;Determine whether or not to rollback transactions for the supplied_{@link TestContext test context} by taking into consideration the_{@link #isDefaultRollback(TestContext) default rollback} flag and a_possible method-level override via the {@link Rollback} annotation._@param testContext the test context for which the rollback flag_should be retrieved_@return the <em>rollback</em> flag for the supplied test context_@throws Exception if an error occurs while determining the rollback flag;protected final boolean isRollback(TestContext testContext) throws Exception {_		boolean rollback = isDefaultRollback(testContext)__		Rollback rollbackAnnotation = testContext.getTestMethod().getAnnotation(Rollback.class)__		if (rollbackAnnotation != null) {_			boolean rollbackOverride = rollbackAnnotation.value()__			if (logger.isDebugEnabled()) {_				logger.debug("Method-level @Rollback(" + rollbackOverride + ") overrides default rollback [" + rollback_						+ "] for test context " + testContext)__			}_			rollback = rollbackOverride__		}_		else {_			if (logger.isDebugEnabled()) {_				logger.debug("No method-level @Rollback override: using default rollback [" + rollback_						+ "] for test context " + testContext)__			}_		}_		return rollback__	};determine,whether,or,not,to,rollback,transactions,for,the,supplied,link,test,context,test,context,by,taking,into,consideration,the,link,is,default,rollback,test,context,default,rollback,flag,and,a,possible,method,level,override,via,the,link,rollback,annotation,param,test,context,the,test,context,for,which,the,rollback,flag,should,be,retrieved,return,the,em,rollback,em,flag,for,the,supplied,test,context,throws,exception,if,an,error,occurs,while,determining,the,rollback,flag;protected,final,boolean,is,rollback,test,context,test,context,throws,exception,boolean,rollback,is,default,rollback,test,context,rollback,rollback,annotation,test,context,get,test,method,get,annotation,rollback,class,if,rollback,annotation,null,boolean,rollback,override,rollback,annotation,value,if,logger,is,debug,enabled,logger,debug,method,level,rollback,rollback,override,overrides,default,rollback,rollback,for,test,context,test,context,rollback,rollback,override,else,if,logger,is,debug,enabled,logger,debug,no,method,level,rollback,override,using,default,rollback,rollback,for,test,context,test,context,return,rollback
TransactionalTestExecutionListener -> protected final boolean isRollback(TestContext testContext) throws Exception;1367163114;Determine whether or not to rollback transactions for the supplied_{@link TestContext test context} by taking into consideration the_{@link #isDefaultRollback(TestContext) default rollback} flag and a_possible method-level override via the {@link Rollback} annotation._@param testContext the test context for which the rollback flag_should be retrieved_@return the <em>rollback</em> flag for the supplied test context_@throws Exception if an error occurs while determining the rollback flag;protected final boolean isRollback(TestContext testContext) throws Exception {_		boolean rollback = isDefaultRollback(testContext)__		Rollback rollbackAnnotation = testContext.getTestMethod().getAnnotation(Rollback.class)__		if (rollbackAnnotation != null) {_			boolean rollbackOverride = rollbackAnnotation.value()__			if (logger.isDebugEnabled()) {_				logger.debug("Method-level @Rollback(" + rollbackOverride + ") overrides default rollback [" + rollback_						+ "] for test context " + testContext)__			}_			rollback = rollbackOverride__		}_		else {_			if (logger.isDebugEnabled()) {_				logger.debug("No method-level @Rollback override: using default rollback [" + rollback_						+ "] for test context " + testContext)__			}_		}_		return rollback__	};determine,whether,or,not,to,rollback,transactions,for,the,supplied,link,test,context,test,context,by,taking,into,consideration,the,link,is,default,rollback,test,context,default,rollback,flag,and,a,possible,method,level,override,via,the,link,rollback,annotation,param,test,context,the,test,context,for,which,the,rollback,flag,should,be,retrieved,return,the,em,rollback,em,flag,for,the,supplied,test,context,throws,exception,if,an,error,occurs,while,determining,the,rollback,flag;protected,final,boolean,is,rollback,test,context,test,context,throws,exception,boolean,rollback,is,default,rollback,test,context,rollback,rollback,annotation,test,context,get,test,method,get,annotation,rollback,class,if,rollback,annotation,null,boolean,rollback,override,rollback,annotation,value,if,logger,is,debug,enabled,logger,debug,method,level,rollback,rollback,override,overrides,default,rollback,rollback,for,test,context,test,context,rollback,rollback,override,else,if,logger,is,debug,enabled,logger,debug,no,method,level,rollback,override,using,default,rollback,rollback,for,test,context,test,context,return,rollback
TransactionalTestExecutionListener -> protected final boolean isRollback(TestContext testContext) throws Exception;1367873075;Determine whether or not to rollback transactions for the supplied_{@link TestContext test context} by taking into consideration the_{@link #isDefaultRollback(TestContext) default rollback} flag and a_possible method-level override via the {@link Rollback} annotation._@param testContext the test context for which the rollback flag_should be retrieved_@return the <em>rollback</em> flag for the supplied test context_@throws Exception if an error occurs while determining the rollback flag;protected final boolean isRollback(TestContext testContext) throws Exception {_		boolean rollback = isDefaultRollback(testContext)__		Rollback rollbackAnnotation = testContext.getTestMethod().getAnnotation(Rollback.class)__		if (rollbackAnnotation != null) {_			boolean rollbackOverride = rollbackAnnotation.value()__			if (logger.isDebugEnabled()) {_				logger.debug("Method-level @Rollback(" + rollbackOverride + ") overrides default rollback [" + rollback_						+ "] for test context " + testContext)__			}_			rollback = rollbackOverride__		}_		else {_			if (logger.isDebugEnabled()) {_				logger.debug("No method-level @Rollback override: using default rollback [" + rollback_						+ "] for test context " + testContext)__			}_		}_		return rollback__	};determine,whether,or,not,to,rollback,transactions,for,the,supplied,link,test,context,test,context,by,taking,into,consideration,the,link,is,default,rollback,test,context,default,rollback,flag,and,a,possible,method,level,override,via,the,link,rollback,annotation,param,test,context,the,test,context,for,which,the,rollback,flag,should,be,retrieved,return,the,em,rollback,em,flag,for,the,supplied,test,context,throws,exception,if,an,error,occurs,while,determining,the,rollback,flag;protected,final,boolean,is,rollback,test,context,test,context,throws,exception,boolean,rollback,is,default,rollback,test,context,rollback,rollback,annotation,test,context,get,test,method,get,annotation,rollback,class,if,rollback,annotation,null,boolean,rollback,override,rollback,annotation,value,if,logger,is,debug,enabled,logger,debug,method,level,rollback,rollback,override,overrides,default,rollback,rollback,for,test,context,test,context,rollback,rollback,override,else,if,logger,is,debug,enabled,logger,debug,no,method,level,rollback,override,using,default,rollback,rollback,for,test,context,test,context,return,rollback
TransactionalTestExecutionListener -> protected final boolean isRollback(TestContext testContext) throws Exception;1368482696;Determine whether or not to rollback transactions for the supplied_{@link TestContext test context} by taking into consideration the_{@link #isDefaultRollback(TestContext) default rollback} flag and a_possible method-level override via the {@link Rollback} annotation._@param testContext the test context for which the rollback flag_should be retrieved_@return the <em>rollback</em> flag for the supplied test context_@throws Exception if an error occurs while determining the rollback flag;protected final boolean isRollback(TestContext testContext) throws Exception {_		boolean rollback = isDefaultRollback(testContext)__		Rollback rollbackAnnotation = testContext.getTestMethod().getAnnotation(Rollback.class)__		if (rollbackAnnotation != null) {_			boolean rollbackOverride = rollbackAnnotation.value()__			if (logger.isDebugEnabled()) {_				logger.debug("Method-level @Rollback(" + rollbackOverride + ") overrides default rollback [" + rollback_						+ "] for test context " + testContext)__			}_			rollback = rollbackOverride__		}_		else {_			if (logger.isDebugEnabled()) {_				logger.debug("No method-level @Rollback override: using default rollback [" + rollback_						+ "] for test context " + testContext)__			}_		}_		return rollback__	};determine,whether,or,not,to,rollback,transactions,for,the,supplied,link,test,context,test,context,by,taking,into,consideration,the,link,is,default,rollback,test,context,default,rollback,flag,and,a,possible,method,level,override,via,the,link,rollback,annotation,param,test,context,the,test,context,for,which,the,rollback,flag,should,be,retrieved,return,the,em,rollback,em,flag,for,the,supplied,test,context,throws,exception,if,an,error,occurs,while,determining,the,rollback,flag;protected,final,boolean,is,rollback,test,context,test,context,throws,exception,boolean,rollback,is,default,rollback,test,context,rollback,rollback,annotation,test,context,get,test,method,get,annotation,rollback,class,if,rollback,annotation,null,boolean,rollback,override,rollback,annotation,value,if,logger,is,debug,enabled,logger,debug,method,level,rollback,rollback,override,overrides,default,rollback,rollback,for,test,context,test,context,rollback,rollback,override,else,if,logger,is,debug,enabled,logger,debug,no,method,level,rollback,override,using,default,rollback,rollback,for,test,context,test,context,return,rollback
TransactionalTestExecutionListener -> protected final boolean isRollback(TestContext testContext) throws Exception;1382920864;Determine whether or not to rollback transactions for the supplied_{@link TestContext test context} by taking into consideration the_{@link #isDefaultRollback(TestContext) default rollback} flag and a_possible method-level override via the {@link Rollback} annotation._@param testContext the test context for which the rollback flag_should be retrieved_@return the <em>rollback</em> flag for the supplied test context_@throws Exception if an error occurs while determining the rollback flag;protected final boolean isRollback(TestContext testContext) throws Exception {_		boolean rollback = isDefaultRollback(testContext)__		Rollback rollbackAnnotation = findAnnotation(testContext.getTestMethod(), Rollback.class)__		if (rollbackAnnotation != null) {_			boolean rollbackOverride = rollbackAnnotation.value()__			if (logger.isDebugEnabled()) {_				logger.debug("Method-level @Rollback(" + rollbackOverride + ") overrides default rollback [" + rollback_						+ "] for test context " + testContext)__			}_			rollback = rollbackOverride__		}_		else {_			if (logger.isDebugEnabled()) {_				logger.debug("No method-level @Rollback override: using default rollback [" + rollback_						+ "] for test context " + testContext)__			}_		}_		return rollback__	};determine,whether,or,not,to,rollback,transactions,for,the,supplied,link,test,context,test,context,by,taking,into,consideration,the,link,is,default,rollback,test,context,default,rollback,flag,and,a,possible,method,level,override,via,the,link,rollback,annotation,param,test,context,the,test,context,for,which,the,rollback,flag,should,be,retrieved,return,the,em,rollback,em,flag,for,the,supplied,test,context,throws,exception,if,an,error,occurs,while,determining,the,rollback,flag;protected,final,boolean,is,rollback,test,context,test,context,throws,exception,boolean,rollback,is,default,rollback,test,context,rollback,rollback,annotation,find,annotation,test,context,get,test,method,rollback,class,if,rollback,annotation,null,boolean,rollback,override,rollback,annotation,value,if,logger,is,debug,enabled,logger,debug,method,level,rollback,rollback,override,overrides,default,rollback,rollback,for,test,context,test,context,rollback,rollback,override,else,if,logger,is,debug,enabled,logger,debug,no,method,level,rollback,override,using,default,rollback,rollback,for,test,context,test,context,return,rollback
TransactionalTestExecutionListener -> protected final boolean isRollback(TestContext testContext) throws Exception;1385499540;Determine whether or not to rollback transactions for the supplied_{@link TestContext test context} by taking into consideration the_{@link #isDefaultRollback(TestContext) default rollback} flag and a_possible method-level override via the {@link Rollback} annotation._@param testContext the test context for which the rollback flag_should be retrieved_@return the <em>rollback</em> flag for the supplied test context_@throws Exception if an error occurs while determining the rollback flag;protected final boolean isRollback(TestContext testContext) throws Exception {_		boolean rollback = isDefaultRollback(testContext)__		Rollback rollbackAnnotation = findAnnotation(testContext.getTestMethod(), Rollback.class)__		if (rollbackAnnotation != null) {_			boolean rollbackOverride = rollbackAnnotation.value()__			if (logger.isDebugEnabled()) {_				logger.debug(String.format(_					"Method-level @Rollback(%s) overrides default rollback [%s] for test context %s.",_					rollbackOverride, rollback, testContext))__			}_			rollback = rollbackOverride__		}_		else {_			if (logger.isDebugEnabled()) {_				logger.debug(String.format(_					"No method-level @Rollback override: using default rollback [%s] for test context %s.", rollback,_					testContext))__			}_		}_		return rollback__	};determine,whether,or,not,to,rollback,transactions,for,the,supplied,link,test,context,test,context,by,taking,into,consideration,the,link,is,default,rollback,test,context,default,rollback,flag,and,a,possible,method,level,override,via,the,link,rollback,annotation,param,test,context,the,test,context,for,which,the,rollback,flag,should,be,retrieved,return,the,em,rollback,em,flag,for,the,supplied,test,context,throws,exception,if,an,error,occurs,while,determining,the,rollback,flag;protected,final,boolean,is,rollback,test,context,test,context,throws,exception,boolean,rollback,is,default,rollback,test,context,rollback,rollback,annotation,find,annotation,test,context,get,test,method,rollback,class,if,rollback,annotation,null,boolean,rollback,override,rollback,annotation,value,if,logger,is,debug,enabled,logger,debug,string,format,method,level,rollback,s,overrides,default,rollback,s,for,test,context,s,rollback,override,rollback,test,context,rollback,rollback,override,else,if,logger,is,debug,enabled,logger,debug,string,format,no,method,level,rollback,override,using,default,rollback,s,for,test,context,s,rollback,test,context,return,rollback
TransactionalTestExecutionListener -> protected final boolean isRollback(TestContext testContext) throws Exception;1389966876;Determine whether or not to rollback transactions for the supplied_{@link TestContext test context} by taking into consideration the_{@link #isDefaultRollback(TestContext) default rollback} flag and a_possible method-level override via the {@link Rollback} annotation._@param testContext the test context for which the rollback flag_should be retrieved_@return the <em>rollback</em> flag for the supplied test context_@throws Exception if an error occurs while determining the rollback flag;protected final boolean isRollback(TestContext testContext) throws Exception {_		boolean rollback = isDefaultRollback(testContext)__		Rollback rollbackAnnotation = findAnnotation(testContext.getTestMethod(), Rollback.class)__		if (rollbackAnnotation != null) {_			boolean rollbackOverride = rollbackAnnotation.value()__			if (logger.isDebugEnabled()) {_				logger.debug(String.format(_					"Method-level @Rollback(%s) overrides default rollback [%s] for test context %s.",_					rollbackOverride, rollback, testContext))__			}_			rollback = rollbackOverride__		}_		else {_			if (logger.isDebugEnabled()) {_				logger.debug(String.format(_					"No method-level @Rollback override: using default rollback [%s] for test context %s.", rollback,_					testContext))__			}_		}_		return rollback__	};determine,whether,or,not,to,rollback,transactions,for,the,supplied,link,test,context,test,context,by,taking,into,consideration,the,link,is,default,rollback,test,context,default,rollback,flag,and,a,possible,method,level,override,via,the,link,rollback,annotation,param,test,context,the,test,context,for,which,the,rollback,flag,should,be,retrieved,return,the,em,rollback,em,flag,for,the,supplied,test,context,throws,exception,if,an,error,occurs,while,determining,the,rollback,flag;protected,final,boolean,is,rollback,test,context,test,context,throws,exception,boolean,rollback,is,default,rollback,test,context,rollback,rollback,annotation,find,annotation,test,context,get,test,method,rollback,class,if,rollback,annotation,null,boolean,rollback,override,rollback,annotation,value,if,logger,is,debug,enabled,logger,debug,string,format,method,level,rollback,s,overrides,default,rollback,s,for,test,context,s,rollback,override,rollback,test,context,rollback,rollback,override,else,if,logger,is,debug,enabled,logger,debug,string,format,no,method,level,rollback,override,using,default,rollback,s,for,test,context,s,rollback,test,context,return,rollback
TransactionalTestExecutionListener -> protected final boolean isRollback(TestContext testContext) throws Exception;1401991965;Determine whether or not to rollback transactions for the supplied_{@link TestContext test context} by taking into consideration the_{@link #isDefaultRollback(TestContext) default rollback} flag and a_possible method-level override via the {@link Rollback} annotation._@param testContext the test context for which the rollback flag_should be retrieved_@return the <em>rollback</em> flag for the supplied test context_@throws Exception if an error occurs while determining the rollback flag;protected final boolean isRollback(TestContext testContext) throws Exception {_		boolean rollback = isDefaultRollback(testContext)__		Rollback rollbackAnnotation = findAnnotation(testContext.getTestMethod(), Rollback.class)__		if (rollbackAnnotation != null) {_			boolean rollbackOverride = rollbackAnnotation.value()__			if (logger.isDebugEnabled()) {_				logger.debug(String.format(_					"Method-level @Rollback(%s) overrides default rollback [%s] for test context %s.",_					rollbackOverride, rollback, testContext))__			}_			rollback = rollbackOverride__		}_		else {_			if (logger.isDebugEnabled()) {_				logger.debug(String.format(_					"No method-level @Rollback override: using default rollback [%s] for test context %s.", rollback,_					testContext))__			}_		}_		return rollback__	};determine,whether,or,not,to,rollback,transactions,for,the,supplied,link,test,context,test,context,by,taking,into,consideration,the,link,is,default,rollback,test,context,default,rollback,flag,and,a,possible,method,level,override,via,the,link,rollback,annotation,param,test,context,the,test,context,for,which,the,rollback,flag,should,be,retrieved,return,the,em,rollback,em,flag,for,the,supplied,test,context,throws,exception,if,an,error,occurs,while,determining,the,rollback,flag;protected,final,boolean,is,rollback,test,context,test,context,throws,exception,boolean,rollback,is,default,rollback,test,context,rollback,rollback,annotation,find,annotation,test,context,get,test,method,rollback,class,if,rollback,annotation,null,boolean,rollback,override,rollback,annotation,value,if,logger,is,debug,enabled,logger,debug,string,format,method,level,rollback,s,overrides,default,rollback,s,for,test,context,s,rollback,override,rollback,test,context,rollback,rollback,override,else,if,logger,is,debug,enabled,logger,debug,string,format,no,method,level,rollback,override,using,default,rollback,s,for,test,context,s,rollback,test,context,return,rollback
TransactionalTestExecutionListener -> protected final boolean isRollback(TestContext testContext) throws Exception;1404334604;Determine whether or not to rollback transactions for the supplied_{@link TestContext test context} by taking into consideration the_{@link #isDefaultRollback(TestContext) default rollback} flag and a_possible method-level override via the {@link Rollback} annotation._@param testContext the test context for which the rollback flag_should be retrieved_@return the <em>rollback</em> flag for the supplied test context_@throws Exception if an error occurs while determining the rollback flag;protected final boolean isRollback(TestContext testContext) throws Exception {_		boolean rollback = isDefaultRollback(testContext)__		Rollback rollbackAnnotation = findAnnotation(testContext.getTestMethod(), Rollback.class)__		if (rollbackAnnotation != null) {_			boolean rollbackOverride = rollbackAnnotation.value()__			if (logger.isDebugEnabled()) {_				logger.debug(String.format(_					"Method-level @Rollback(%s) overrides default rollback [%s] for test context %s.",_					rollbackOverride, rollback, testContext))__			}_			rollback = rollbackOverride__		}_		else {_			if (logger.isDebugEnabled()) {_				logger.debug(String.format(_					"No method-level @Rollback override: using default rollback [%s] for test context %s.", rollback,_					testContext))__			}_		}_		return rollback__	};determine,whether,or,not,to,rollback,transactions,for,the,supplied,link,test,context,test,context,by,taking,into,consideration,the,link,is,default,rollback,test,context,default,rollback,flag,and,a,possible,method,level,override,via,the,link,rollback,annotation,param,test,context,the,test,context,for,which,the,rollback,flag,should,be,retrieved,return,the,em,rollback,em,flag,for,the,supplied,test,context,throws,exception,if,an,error,occurs,while,determining,the,rollback,flag;protected,final,boolean,is,rollback,test,context,test,context,throws,exception,boolean,rollback,is,default,rollback,test,context,rollback,rollback,annotation,find,annotation,test,context,get,test,method,rollback,class,if,rollback,annotation,null,boolean,rollback,override,rollback,annotation,value,if,logger,is,debug,enabled,logger,debug,string,format,method,level,rollback,s,overrides,default,rollback,s,for,test,context,s,rollback,override,rollback,test,context,rollback,rollback,override,else,if,logger,is,debug,enabled,logger,debug,string,format,no,method,level,rollback,override,using,default,rollback,s,for,test,context,s,rollback,test,context,return,rollback
TransactionalTestExecutionListener -> protected final boolean isRollback(TestContext testContext) throws Exception;1405645143;Determine whether or not to rollback transactions for the supplied_{@link TestContext test context} by taking into consideration the_{@link #isDefaultRollback(TestContext) default rollback} flag and a_possible method-level override via the {@link Rollback} annotation._@param testContext the test context for which the rollback flag_should be retrieved_@return the <em>rollback</em> flag for the supplied test context_@throws Exception if an error occurs while determining the rollback flag;protected final boolean isRollback(TestContext testContext) throws Exception {_		boolean rollback = isDefaultRollback(testContext)__		Rollback rollbackAnnotation = findAnnotation(testContext.getTestMethod(), Rollback.class)__		if (rollbackAnnotation != null) {_			boolean rollbackOverride = rollbackAnnotation.value()__			if (logger.isDebugEnabled()) {_				logger.debug(String.format(_					"Method-level @Rollback(%s) overrides default rollback [%s] for test context %s.",_					rollbackOverride, rollback, testContext))__			}_			rollback = rollbackOverride__		}_		else {_			if (logger.isDebugEnabled()) {_				logger.debug(String.format(_					"No method-level @Rollback override: using default rollback [%s] for test context %s.", rollback,_					testContext))__			}_		}_		return rollback__	};determine,whether,or,not,to,rollback,transactions,for,the,supplied,link,test,context,test,context,by,taking,into,consideration,the,link,is,default,rollback,test,context,default,rollback,flag,and,a,possible,method,level,override,via,the,link,rollback,annotation,param,test,context,the,test,context,for,which,the,rollback,flag,should,be,retrieved,return,the,em,rollback,em,flag,for,the,supplied,test,context,throws,exception,if,an,error,occurs,while,determining,the,rollback,flag;protected,final,boolean,is,rollback,test,context,test,context,throws,exception,boolean,rollback,is,default,rollback,test,context,rollback,rollback,annotation,find,annotation,test,context,get,test,method,rollback,class,if,rollback,annotation,null,boolean,rollback,override,rollback,annotation,value,if,logger,is,debug,enabled,logger,debug,string,format,method,level,rollback,s,overrides,default,rollback,s,for,test,context,s,rollback,override,rollback,test,context,rollback,rollback,override,else,if,logger,is,debug,enabled,logger,debug,string,format,no,method,level,rollback,override,using,default,rollback,s,for,test,context,s,rollback,test,context,return,rollback
TransactionalTestExecutionListener -> protected final boolean isRollback(TestContext testContext) throws Exception;1405698612;Determine whether or not to rollback transactions for the supplied_{@link TestContext test context} by taking into consideration the_{@link #isDefaultRollback(TestContext) default rollback} flag and a_possible method-level override via the {@link Rollback} annotation._@param testContext the test context for which the rollback flag_should be retrieved_@return the <em>rollback</em> flag for the supplied test context_@throws Exception if an error occurs while determining the rollback flag;protected final boolean isRollback(TestContext testContext) throws Exception {_		boolean rollback = isDefaultRollback(testContext)__		Rollback rollbackAnnotation = findAnnotation(testContext.getTestMethod(), Rollback.class)__		if (rollbackAnnotation != null) {_			boolean rollbackOverride = rollbackAnnotation.value()__			if (logger.isDebugEnabled()) {_				logger.debug(String.format(_					"Method-level @Rollback(%s) overrides default rollback [%s] for test context %s.",_					rollbackOverride, rollback, testContext))__			}_			rollback = rollbackOverride__		}_		else {_			if (logger.isDebugEnabled()) {_				logger.debug(String.format(_					"No method-level @Rollback override: using default rollback [%s] for test context %s.", rollback,_					testContext))__			}_		}_		return rollback__	};determine,whether,or,not,to,rollback,transactions,for,the,supplied,link,test,context,test,context,by,taking,into,consideration,the,link,is,default,rollback,test,context,default,rollback,flag,and,a,possible,method,level,override,via,the,link,rollback,annotation,param,test,context,the,test,context,for,which,the,rollback,flag,should,be,retrieved,return,the,em,rollback,em,flag,for,the,supplied,test,context,throws,exception,if,an,error,occurs,while,determining,the,rollback,flag;protected,final,boolean,is,rollback,test,context,test,context,throws,exception,boolean,rollback,is,default,rollback,test,context,rollback,rollback,annotation,find,annotation,test,context,get,test,method,rollback,class,if,rollback,annotation,null,boolean,rollback,override,rollback,annotation,value,if,logger,is,debug,enabled,logger,debug,string,format,method,level,rollback,s,overrides,default,rollback,s,for,test,context,s,rollback,override,rollback,test,context,rollback,rollback,override,else,if,logger,is,debug,enabled,logger,debug,string,format,no,method,level,rollback,override,using,default,rollback,s,for,test,context,s,rollback,test,context,return,rollback
TransactionalTestExecutionListener -> protected final boolean isRollback(TestContext testContext) throws Exception;1405759527;Determine whether or not to rollback transactions for the supplied_{@link TestContext test context} by taking into consideration the_{@link #isDefaultRollback(TestContext) default rollback} flag and a_possible method-level override via the {@link Rollback} annotation._@param testContext the test context for which the rollback flag_should be retrieved_@return the <em>rollback</em> flag for the supplied test context_@throws Exception if an error occurs while determining the rollback flag;protected final boolean isRollback(TestContext testContext) throws Exception {_		boolean rollback = isDefaultRollback(testContext)__		Rollback rollbackAnnotation = findAnnotation(testContext.getTestMethod(), Rollback.class)__		if (rollbackAnnotation != null) {_			boolean rollbackOverride = rollbackAnnotation.value()__			if (logger.isDebugEnabled()) {_				logger.debug(String.format(_					"Method-level @Rollback(%s) overrides default rollback [%s] for test context %s.",_					rollbackOverride, rollback, testContext))__			}_			rollback = rollbackOverride__		}_		else {_			if (logger.isDebugEnabled()) {_				logger.debug(String.format(_					"No method-level @Rollback override: using default rollback [%s] for test context %s.", rollback,_					testContext))__			}_		}_		return rollback__	};determine,whether,or,not,to,rollback,transactions,for,the,supplied,link,test,context,test,context,by,taking,into,consideration,the,link,is,default,rollback,test,context,default,rollback,flag,and,a,possible,method,level,override,via,the,link,rollback,annotation,param,test,context,the,test,context,for,which,the,rollback,flag,should,be,retrieved,return,the,em,rollback,em,flag,for,the,supplied,test,context,throws,exception,if,an,error,occurs,while,determining,the,rollback,flag;protected,final,boolean,is,rollback,test,context,test,context,throws,exception,boolean,rollback,is,default,rollback,test,context,rollback,rollback,annotation,find,annotation,test,context,get,test,method,rollback,class,if,rollback,annotation,null,boolean,rollback,override,rollback,annotation,value,if,logger,is,debug,enabled,logger,debug,string,format,method,level,rollback,s,overrides,default,rollback,s,for,test,context,s,rollback,override,rollback,test,context,rollback,rollback,override,else,if,logger,is,debug,enabled,logger,debug,string,format,no,method,level,rollback,override,using,default,rollback,s,for,test,context,s,rollback,test,context,return,rollback
TransactionalTestExecutionListener -> protected final boolean isRollback(TestContext testContext) throws Exception;1405759966;Determine whether or not to rollback transactions for the supplied_{@link TestContext test context} by taking into consideration the_{@link #isDefaultRollback(TestContext) default rollback} flag and a_possible method-level override via the {@link Rollback} annotation._@param testContext the test context for which the rollback flag_should be retrieved_@return the <em>rollback</em> flag for the supplied test context_@throws Exception if an error occurs while determining the rollback flag;protected final boolean isRollback(TestContext testContext) throws Exception {_		boolean rollback = isDefaultRollback(testContext)__		Rollback rollbackAnnotation = findAnnotation(testContext.getTestMethod(), Rollback.class)__		if (rollbackAnnotation != null) {_			boolean rollbackOverride = rollbackAnnotation.value()__			if (logger.isDebugEnabled()) {_				logger.debug(String.format(_					"Method-level @Rollback(%s) overrides default rollback [%s] for test context %s.",_					rollbackOverride, rollback, testContext))__			}_			rollback = rollbackOverride__		}_		else {_			if (logger.isDebugEnabled()) {_				logger.debug(String.format(_					"No method-level @Rollback override: using default rollback [%s] for test context %s.", rollback,_					testContext))__			}_		}_		return rollback__	};determine,whether,or,not,to,rollback,transactions,for,the,supplied,link,test,context,test,context,by,taking,into,consideration,the,link,is,default,rollback,test,context,default,rollback,flag,and,a,possible,method,level,override,via,the,link,rollback,annotation,param,test,context,the,test,context,for,which,the,rollback,flag,should,be,retrieved,return,the,em,rollback,em,flag,for,the,supplied,test,context,throws,exception,if,an,error,occurs,while,determining,the,rollback,flag;protected,final,boolean,is,rollback,test,context,test,context,throws,exception,boolean,rollback,is,default,rollback,test,context,rollback,rollback,annotation,find,annotation,test,context,get,test,method,rollback,class,if,rollback,annotation,null,boolean,rollback,override,rollback,annotation,value,if,logger,is,debug,enabled,logger,debug,string,format,method,level,rollback,s,overrides,default,rollback,s,for,test,context,s,rollback,override,rollback,test,context,rollback,rollback,override,else,if,logger,is,debug,enabled,logger,debug,string,format,no,method,level,rollback,override,using,default,rollback,s,for,test,context,s,rollback,test,context,return,rollback
TransactionalTestExecutionListener -> protected final boolean isRollback(TestContext testContext) throws Exception;1406218418;Determine whether or not to rollback transactions for the supplied_{@link TestContext test context} by taking into consideration the_{@link #isDefaultRollback(TestContext) default rollback} flag and a_possible method-level override via the {@link Rollback} annotation._@param testContext the test context for which the rollback flag_should be retrieved_@return the <em>rollback</em> flag for the supplied test context_@throws Exception if an error occurs while determining the rollback flag;protected final boolean isRollback(TestContext testContext) throws Exception {_		boolean rollback = isDefaultRollback(testContext)__		Rollback rollbackAnnotation = findAnnotation(testContext.getTestMethod(), Rollback.class)__		if (rollbackAnnotation != null) {_			boolean rollbackOverride = rollbackAnnotation.value()__			if (logger.isDebugEnabled()) {_				logger.debug(String.format(_					"Method-level @Rollback(%s) overrides default rollback [%s] for test context %s.",_					rollbackOverride, rollback, testContext))__			}_			rollback = rollbackOverride__		}_		else {_			if (logger.isDebugEnabled()) {_				logger.debug(String.format(_					"No method-level @Rollback override: using default rollback [%s] for test context %s.", rollback,_					testContext))__			}_		}_		return rollback__	};determine,whether,or,not,to,rollback,transactions,for,the,supplied,link,test,context,test,context,by,taking,into,consideration,the,link,is,default,rollback,test,context,default,rollback,flag,and,a,possible,method,level,override,via,the,link,rollback,annotation,param,test,context,the,test,context,for,which,the,rollback,flag,should,be,retrieved,return,the,em,rollback,em,flag,for,the,supplied,test,context,throws,exception,if,an,error,occurs,while,determining,the,rollback,flag;protected,final,boolean,is,rollback,test,context,test,context,throws,exception,boolean,rollback,is,default,rollback,test,context,rollback,rollback,annotation,find,annotation,test,context,get,test,method,rollback,class,if,rollback,annotation,null,boolean,rollback,override,rollback,annotation,value,if,logger,is,debug,enabled,logger,debug,string,format,method,level,rollback,s,overrides,default,rollback,s,for,test,context,s,rollback,override,rollback,test,context,rollback,rollback,override,else,if,logger,is,debug,enabled,logger,debug,string,format,no,method,level,rollback,override,using,default,rollback,s,for,test,context,s,rollback,test,context,return,rollback
TransactionalTestExecutionListener -> protected final boolean isRollback(TestContext testContext) throws Exception;1407419079;Determine whether or not to rollback transactions for the supplied_{@link TestContext test context} by taking into consideration the_{@link #isDefaultRollback(TestContext) default rollback} flag and a_possible method-level override via the {@link Rollback} annotation._@param testContext the test context for which the rollback flag_should be retrieved_@return the <em>rollback</em> flag for the supplied test context_@throws Exception if an error occurs while determining the rollback flag;protected final boolean isRollback(TestContext testContext) throws Exception {_		boolean rollback = isDefaultRollback(testContext)__		Rollback rollbackAnnotation = findAnnotation(testContext.getTestMethod(), Rollback.class)__		if (rollbackAnnotation != null) {_			boolean rollbackOverride = rollbackAnnotation.value()__			if (logger.isDebugEnabled()) {_				logger.debug(String.format(_					"Method-level @Rollback(%s) overrides default rollback [%s] for test context %s.",_					rollbackOverride, rollback, testContext))__			}_			rollback = rollbackOverride__		}_		else {_			if (logger.isDebugEnabled()) {_				logger.debug(String.format(_					"No method-level @Rollback override: using default rollback [%s] for test context %s.", rollback,_					testContext))__			}_		}_		return rollback__	};determine,whether,or,not,to,rollback,transactions,for,the,supplied,link,test,context,test,context,by,taking,into,consideration,the,link,is,default,rollback,test,context,default,rollback,flag,and,a,possible,method,level,override,via,the,link,rollback,annotation,param,test,context,the,test,context,for,which,the,rollback,flag,should,be,retrieved,return,the,em,rollback,em,flag,for,the,supplied,test,context,throws,exception,if,an,error,occurs,while,determining,the,rollback,flag;protected,final,boolean,is,rollback,test,context,test,context,throws,exception,boolean,rollback,is,default,rollback,test,context,rollback,rollback,annotation,find,annotation,test,context,get,test,method,rollback,class,if,rollback,annotation,null,boolean,rollback,override,rollback,annotation,value,if,logger,is,debug,enabled,logger,debug,string,format,method,level,rollback,s,overrides,default,rollback,s,for,test,context,s,rollback,override,rollback,test,context,rollback,rollback,override,else,if,logger,is,debug,enabled,logger,debug,string,format,no,method,level,rollback,override,using,default,rollback,s,for,test,context,s,rollback,test,context,return,rollback
TransactionalTestExecutionListener -> protected final boolean isRollback(TestContext testContext) throws Exception;1408048216;Determine whether or not to rollback transactions for the supplied_{@link TestContext test context} by taking into consideration the_{@link #isDefaultRollback(TestContext) default rollback} flag and a_possible method-level override via the {@link Rollback} annotation._@param testContext the test context for which the rollback flag_should be retrieved_@return the <em>rollback</em> flag for the supplied test context_@throws Exception if an error occurs while determining the rollback flag;protected final boolean isRollback(TestContext testContext) throws Exception {_		boolean rollback = isDefaultRollback(testContext)__		Rollback rollbackAnnotation = findAnnotation(testContext.getTestMethod(), Rollback.class)__		if (rollbackAnnotation != null) {_			boolean rollbackOverride = rollbackAnnotation.value()__			if (logger.isDebugEnabled()) {_				logger.debug(String.format(_					"Method-level @Rollback(%s) overrides default rollback [%s] for test context %s.",_					rollbackOverride, rollback, testContext))__			}_			rollback = rollbackOverride__		}_		else {_			if (logger.isDebugEnabled()) {_				logger.debug(String.format(_					"No method-level @Rollback override: using default rollback [%s] for test context %s.", rollback,_					testContext))__			}_		}_		return rollback__	};determine,whether,or,not,to,rollback,transactions,for,the,supplied,link,test,context,test,context,by,taking,into,consideration,the,link,is,default,rollback,test,context,default,rollback,flag,and,a,possible,method,level,override,via,the,link,rollback,annotation,param,test,context,the,test,context,for,which,the,rollback,flag,should,be,retrieved,return,the,em,rollback,em,flag,for,the,supplied,test,context,throws,exception,if,an,error,occurs,while,determining,the,rollback,flag;protected,final,boolean,is,rollback,test,context,test,context,throws,exception,boolean,rollback,is,default,rollback,test,context,rollback,rollback,annotation,find,annotation,test,context,get,test,method,rollback,class,if,rollback,annotation,null,boolean,rollback,override,rollback,annotation,value,if,logger,is,debug,enabled,logger,debug,string,format,method,level,rollback,s,overrides,default,rollback,s,for,test,context,s,rollback,override,rollback,test,context,rollback,rollback,override,else,if,logger,is,debug,enabled,logger,debug,string,format,no,method,level,rollback,override,using,default,rollback,s,for,test,context,s,rollback,test,context,return,rollback
TransactionalTestExecutionListener -> protected final boolean isRollback(TestContext testContext) throws Exception;1413848647;Determine whether or not to rollback transactions for the supplied_{@link TestContext test context} by taking into consideration the_{@link #isDefaultRollback(TestContext) default rollback} flag and a_possible method-level override via the {@link Rollback} annotation._@param testContext the test context for which the rollback flag_should be retrieved_@return the <em>rollback</em> flag for the supplied test context_@throws Exception if an error occurs while determining the rollback flag;protected final boolean isRollback(TestContext testContext) throws Exception {_		boolean rollback = isDefaultRollback(testContext)__		Rollback rollbackAnnotation = findAnnotation(testContext.getTestMethod(), Rollback.class)__		if (rollbackAnnotation != null) {_			boolean rollbackOverride = rollbackAnnotation.value()__			if (logger.isDebugEnabled()) {_				logger.debug(String.format(_					"Method-level @Rollback(%s) overrides default rollback [%s] for test context %s.",_					rollbackOverride, rollback, testContext))__			}_			rollback = rollbackOverride__		}_		else {_			if (logger.isDebugEnabled()) {_				logger.debug(String.format(_					"No method-level @Rollback override: using default rollback [%s] for test context %s.", rollback,_					testContext))__			}_		}_		return rollback__	};determine,whether,or,not,to,rollback,transactions,for,the,supplied,link,test,context,test,context,by,taking,into,consideration,the,link,is,default,rollback,test,context,default,rollback,flag,and,a,possible,method,level,override,via,the,link,rollback,annotation,param,test,context,the,test,context,for,which,the,rollback,flag,should,be,retrieved,return,the,em,rollback,em,flag,for,the,supplied,test,context,throws,exception,if,an,error,occurs,while,determining,the,rollback,flag;protected,final,boolean,is,rollback,test,context,test,context,throws,exception,boolean,rollback,is,default,rollback,test,context,rollback,rollback,annotation,find,annotation,test,context,get,test,method,rollback,class,if,rollback,annotation,null,boolean,rollback,override,rollback,annotation,value,if,logger,is,debug,enabled,logger,debug,string,format,method,level,rollback,s,overrides,default,rollback,s,for,test,context,s,rollback,override,rollback,test,context,rollback,rollback,override,else,if,logger,is,debug,enabled,logger,debug,string,format,no,method,level,rollback,override,using,default,rollback,s,for,test,context,s,rollback,test,context,return,rollback
TransactionalTestExecutionListener -> protected final boolean isRollback(TestContext testContext) throws Exception;1431568199;Determine whether or not to rollback transactions for the supplied_{@link TestContext test context} by taking into consideration the_{@link #isDefaultRollback(TestContext) default rollback} flag and a_possible method-level override via the {@link Rollback} annotation._@param testContext the test context for which the rollback flag_should be retrieved_@return the <em>rollback</em> flag for the supplied test context_@throws Exception if an error occurs while determining the rollback flag;protected final boolean isRollback(TestContext testContext) throws Exception {_		boolean rollback = isDefaultRollback(testContext)__		Rollback rollbackAnnotation = findAnnotation(testContext.getTestMethod(), Rollback.class)__		if (rollbackAnnotation != null) {_			boolean rollbackOverride = rollbackAnnotation.value()__			if (logger.isDebugEnabled()) {_				logger.debug(String.format(_					"Method-level @Rollback(%s) overrides default rollback [%s] for test context %s.",_					rollbackOverride, rollback, testContext))__			}_			rollback = rollbackOverride__		}_		else {_			if (logger.isDebugEnabled()) {_				logger.debug(String.format(_					"No method-level @Rollback override: using default rollback [%s] for test context %s.", rollback,_					testContext))__			}_		}_		return rollback__	};determine,whether,or,not,to,rollback,transactions,for,the,supplied,link,test,context,test,context,by,taking,into,consideration,the,link,is,default,rollback,test,context,default,rollback,flag,and,a,possible,method,level,override,via,the,link,rollback,annotation,param,test,context,the,test,context,for,which,the,rollback,flag,should,be,retrieved,return,the,em,rollback,em,flag,for,the,supplied,test,context,throws,exception,if,an,error,occurs,while,determining,the,rollback,flag;protected,final,boolean,is,rollback,test,context,test,context,throws,exception,boolean,rollback,is,default,rollback,test,context,rollback,rollback,annotation,find,annotation,test,context,get,test,method,rollback,class,if,rollback,annotation,null,boolean,rollback,override,rollback,annotation,value,if,logger,is,debug,enabled,logger,debug,string,format,method,level,rollback,s,overrides,default,rollback,s,for,test,context,s,rollback,override,rollback,test,context,rollback,rollback,override,else,if,logger,is,debug,enabled,logger,debug,string,format,no,method,level,rollback,override,using,default,rollback,s,for,test,context,s,rollback,test,context,return,rollback
TransactionalTestExecutionListener -> protected final boolean isRollback(TestContext testContext) throws Exception;1432125256;Determine whether or not to rollback transactions for the supplied_{@link TestContext test context} by taking into consideration the_{@link #isDefaultRollback(TestContext) default rollback} flag and a_possible method-level override via the {@link Rollback} annotation._@param testContext the test context for which the rollback flag_should be retrieved_@return the <em>rollback</em> flag for the supplied test context_@throws Exception if an error occurs while determining the rollback flag;protected final boolean isRollback(TestContext testContext) throws Exception {_		boolean rollback = isDefaultRollback(testContext)__		Rollback rollbackAnnotation = findAnnotation(testContext.getTestMethod(), Rollback.class)__		if (rollbackAnnotation != null) {_			boolean rollbackOverride = rollbackAnnotation.value()__			if (logger.isDebugEnabled()) {_				logger.debug(String.format(_					"Method-level @Rollback(%s) overrides default rollback [%s] for test context %s.",_					rollbackOverride, rollback, testContext))__			}_			rollback = rollbackOverride__		}_		else {_			if (logger.isDebugEnabled()) {_				logger.debug(String.format(_					"No method-level @Rollback override: using default rollback [%s] for test context %s.", rollback,_					testContext))__			}_		}_		return rollback__	};determine,whether,or,not,to,rollback,transactions,for,the,supplied,link,test,context,test,context,by,taking,into,consideration,the,link,is,default,rollback,test,context,default,rollback,flag,and,a,possible,method,level,override,via,the,link,rollback,annotation,param,test,context,the,test,context,for,which,the,rollback,flag,should,be,retrieved,return,the,em,rollback,em,flag,for,the,supplied,test,context,throws,exception,if,an,error,occurs,while,determining,the,rollback,flag;protected,final,boolean,is,rollback,test,context,test,context,throws,exception,boolean,rollback,is,default,rollback,test,context,rollback,rollback,annotation,find,annotation,test,context,get,test,method,rollback,class,if,rollback,annotation,null,boolean,rollback,override,rollback,annotation,value,if,logger,is,debug,enabled,logger,debug,string,format,method,level,rollback,s,overrides,default,rollback,s,for,test,context,s,rollback,override,rollback,test,context,rollback,rollback,override,else,if,logger,is,debug,enabled,logger,debug,string,format,no,method,level,rollback,override,using,default,rollback,s,for,test,context,s,rollback,test,context,return,rollback
TransactionalTestExecutionListener -> protected final boolean isRollback(TestContext testContext) throws Exception;1432856630;Determine whether or not to rollback transactions for the supplied_{@link TestContext test context} by taking into consideration the_{@link #isDefaultRollback(TestContext) default rollback} flag and a_possible method-level override via the {@link Rollback} annotation._@param testContext the test context for which the rollback flag_should be retrieved_@return the <em>rollback</em> flag for the supplied test context_@throws Exception if an error occurs while determining the rollback flag;protected final boolean isRollback(TestContext testContext) throws Exception {_		boolean rollback = isDefaultRollback(testContext)__		Rollback rollbackAnnotation = findAnnotation(testContext.getTestMethod(), Rollback.class)__		if (rollbackAnnotation != null) {_			boolean rollbackOverride = rollbackAnnotation.value()__			if (logger.isDebugEnabled()) {_				logger.debug(String.format(_					"Method-level @Rollback(%s) overrides default rollback [%s] for test context %s.",_					rollbackOverride, rollback, testContext))__			}_			rollback = rollbackOverride__		}_		else {_			if (logger.isDebugEnabled()) {_				logger.debug(String.format(_					"No method-level @Rollback override: using default rollback [%s] for test context %s.", rollback,_					testContext))__			}_		}_		return rollback__	};determine,whether,or,not,to,rollback,transactions,for,the,supplied,link,test,context,test,context,by,taking,into,consideration,the,link,is,default,rollback,test,context,default,rollback,flag,and,a,possible,method,level,override,via,the,link,rollback,annotation,param,test,context,the,test,context,for,which,the,rollback,flag,should,be,retrieved,return,the,em,rollback,em,flag,for,the,supplied,test,context,throws,exception,if,an,error,occurs,while,determining,the,rollback,flag;protected,final,boolean,is,rollback,test,context,test,context,throws,exception,boolean,rollback,is,default,rollback,test,context,rollback,rollback,annotation,find,annotation,test,context,get,test,method,rollback,class,if,rollback,annotation,null,boolean,rollback,override,rollback,annotation,value,if,logger,is,debug,enabled,logger,debug,string,format,method,level,rollback,s,overrides,default,rollback,s,for,test,context,s,rollback,override,rollback,test,context,rollback,rollback,override,else,if,logger,is,debug,enabled,logger,debug,string,format,no,method,level,rollback,override,using,default,rollback,s,for,test,context,s,rollback,test,context,return,rollback
TransactionalTestExecutionListener -> protected final boolean isRollback(TestContext testContext) throws Exception;1434234880;Determine whether or not to rollback transactions for the supplied_{@link TestContext test context} by taking into consideration the_{@link #isDefaultRollback(TestContext) default rollback} flag and a_possible method-level override via the {@link Rollback} annotation._@param testContext the test context for which the rollback flag_should be retrieved_@return the <em>rollback</em> flag for the supplied test context_@throws Exception if an error occurs while determining the rollback flag;protected final boolean isRollback(TestContext testContext) throws Exception {_		boolean rollback = isDefaultRollback(testContext)__		Rollback rollbackAnnotation = findAnnotation(testContext.getTestMethod(), Rollback.class)__		if (rollbackAnnotation != null) {_			boolean rollbackOverride = rollbackAnnotation.value()__			if (logger.isDebugEnabled()) {_				logger.debug(String.format(_					"Method-level @Rollback(%s) overrides default rollback [%s] for test context %s.",_					rollbackOverride, rollback, testContext))__			}_			rollback = rollbackOverride__		}_		else {_			if (logger.isDebugEnabled()) {_				logger.debug(String.format(_					"No method-level @Rollback override: using default rollback [%s] for test context %s.", rollback,_					testContext))__			}_		}_		return rollback__	};determine,whether,or,not,to,rollback,transactions,for,the,supplied,link,test,context,test,context,by,taking,into,consideration,the,link,is,default,rollback,test,context,default,rollback,flag,and,a,possible,method,level,override,via,the,link,rollback,annotation,param,test,context,the,test,context,for,which,the,rollback,flag,should,be,retrieved,return,the,em,rollback,em,flag,for,the,supplied,test,context,throws,exception,if,an,error,occurs,while,determining,the,rollback,flag;protected,final,boolean,is,rollback,test,context,test,context,throws,exception,boolean,rollback,is,default,rollback,test,context,rollback,rollback,annotation,find,annotation,test,context,get,test,method,rollback,class,if,rollback,annotation,null,boolean,rollback,override,rollback,annotation,value,if,logger,is,debug,enabled,logger,debug,string,format,method,level,rollback,s,overrides,default,rollback,s,for,test,context,s,rollback,override,rollback,test,context,rollback,rollback,override,else,if,logger,is,debug,enabled,logger,debug,string,format,no,method,level,rollback,override,using,default,rollback,s,for,test,context,s,rollback,test,context,return,rollback
TransactionalTestExecutionListener -> protected final boolean isRollback(TestContext testContext) throws Exception;1434720443;Determine whether or not to rollback transactions for the supplied_{@link TestContext test context} by taking into consideration the_{@link #isDefaultRollback(TestContext) default rollback} flag and a_possible method-level override via the {@link Rollback} annotation._@param testContext the test context for which the rollback flag_should be retrieved_@return the <em>rollback</em> flag for the supplied test context_@throws Exception if an error occurs while determining the rollback flag;protected final boolean isRollback(TestContext testContext) throws Exception {_		boolean rollback = isDefaultRollback(testContext)__		Rollback rollbackAnnotation = findAnnotation(testContext.getTestMethod(), Rollback.class)__		if (rollbackAnnotation != null) {_			boolean rollbackOverride = rollbackAnnotation.value()__			if (logger.isDebugEnabled()) {_				logger.debug(String.format(_					"Method-level @Rollback(%s) overrides default rollback [%s] for test context %s.",_					rollbackOverride, rollback, testContext))__			}_			rollback = rollbackOverride__		}_		else {_			if (logger.isDebugEnabled()) {_				logger.debug(String.format(_					"No method-level @Rollback override: using default rollback [%s] for test context %s.", rollback,_					testContext))__			}_		}_		return rollback__	};determine,whether,or,not,to,rollback,transactions,for,the,supplied,link,test,context,test,context,by,taking,into,consideration,the,link,is,default,rollback,test,context,default,rollback,flag,and,a,possible,method,level,override,via,the,link,rollback,annotation,param,test,context,the,test,context,for,which,the,rollback,flag,should,be,retrieved,return,the,em,rollback,em,flag,for,the,supplied,test,context,throws,exception,if,an,error,occurs,while,determining,the,rollback,flag;protected,final,boolean,is,rollback,test,context,test,context,throws,exception,boolean,rollback,is,default,rollback,test,context,rollback,rollback,annotation,find,annotation,test,context,get,test,method,rollback,class,if,rollback,annotation,null,boolean,rollback,override,rollback,annotation,value,if,logger,is,debug,enabled,logger,debug,string,format,method,level,rollback,s,overrides,default,rollback,s,for,test,context,s,rollback,override,rollback,test,context,rollback,rollback,override,else,if,logger,is,debug,enabled,logger,debug,string,format,no,method,level,rollback,override,using,default,rollback,s,for,test,context,s,rollback,test,context,return,rollback
TransactionalTestExecutionListener -> protected final boolean isRollback(TestContext testContext) throws Exception;1434817656;Determine whether or not to rollback transactions for the supplied_{@link TestContext test context} by taking into consideration the_{@link #isDefaultRollback(TestContext) default rollback} flag and a_possible method-level override via the {@link Rollback} annotation._@param testContext the test context for which the rollback flag_should be retrieved_@return the <em>rollback</em> flag for the supplied test context_@throws Exception if an error occurs while determining the rollback flag;protected final boolean isRollback(TestContext testContext) throws Exception {_		boolean rollback = isDefaultRollback(testContext)__		Rollback rollbackAnnotation = findAnnotation(testContext.getTestMethod(), Rollback.class)__		if (rollbackAnnotation != null) {_			boolean rollbackOverride = rollbackAnnotation.value()__			if (logger.isDebugEnabled()) {_				logger.debug(String.format(_					"Method-level @Rollback(%s) overrides default rollback [%s] for test context %s.",_					rollbackOverride, rollback, testContext))__			}_			rollback = rollbackOverride__		}_		else {_			if (logger.isDebugEnabled()) {_				logger.debug(String.format(_					"No method-level @Rollback override: using default rollback [%s] for test context %s.", rollback,_					testContext))__			}_		}_		return rollback__	};determine,whether,or,not,to,rollback,transactions,for,the,supplied,link,test,context,test,context,by,taking,into,consideration,the,link,is,default,rollback,test,context,default,rollback,flag,and,a,possible,method,level,override,via,the,link,rollback,annotation,param,test,context,the,test,context,for,which,the,rollback,flag,should,be,retrieved,return,the,em,rollback,em,flag,for,the,supplied,test,context,throws,exception,if,an,error,occurs,while,determining,the,rollback,flag;protected,final,boolean,is,rollback,test,context,test,context,throws,exception,boolean,rollback,is,default,rollback,test,context,rollback,rollback,annotation,find,annotation,test,context,get,test,method,rollback,class,if,rollback,annotation,null,boolean,rollback,override,rollback,annotation,value,if,logger,is,debug,enabled,logger,debug,string,format,method,level,rollback,s,overrides,default,rollback,s,for,test,context,s,rollback,override,rollback,test,context,rollback,rollback,override,else,if,logger,is,debug,enabled,logger,debug,string,format,no,method,level,rollback,override,using,default,rollback,s,for,test,context,s,rollback,test,context,return,rollback
TransactionalTestExecutionListener -> protected final boolean isRollback(TestContext testContext) throws Exception;1437841346;Determine whether or not to rollback transactions for the supplied_{@linkplain TestContext test context} by taking into consideration the_{@linkplain #isDefaultRollback(TestContext) default rollback} flag and a_possible method-level override via the {@link Rollback @Rollback}_annotation._@param testContext the test context for which the rollback flag_should be retrieved_@return the <em>rollback</em> flag for the supplied test context_@throws Exception if an error occurs while determining the rollback flag;protected final boolean isRollback(TestContext testContext) throws Exception {_		boolean rollback = isDefaultRollback(testContext)__		Rollback rollbackAnnotation = findAnnotation(testContext.getTestMethod(), Rollback.class)__		if (rollbackAnnotation != null) {_			boolean rollbackOverride = rollbackAnnotation.value()__			if (logger.isDebugEnabled()) {_				logger.debug(String.format(_					"Method-level @Rollback(%s) overrides default rollback [%s] for test context %s.",_					rollbackOverride, rollback, testContext))__			}_			rollback = rollbackOverride__		}_		else {_			if (logger.isDebugEnabled()) {_				logger.debug(String.format(_					"No method-level @Rollback override: using default rollback [%s] for test context %s.", rollback,_					testContext))__			}_		}_		return rollback__	};determine,whether,or,not,to,rollback,transactions,for,the,supplied,linkplain,test,context,test,context,by,taking,into,consideration,the,linkplain,is,default,rollback,test,context,default,rollback,flag,and,a,possible,method,level,override,via,the,link,rollback,rollback,annotation,param,test,context,the,test,context,for,which,the,rollback,flag,should,be,retrieved,return,the,em,rollback,em,flag,for,the,supplied,test,context,throws,exception,if,an,error,occurs,while,determining,the,rollback,flag;protected,final,boolean,is,rollback,test,context,test,context,throws,exception,boolean,rollback,is,default,rollback,test,context,rollback,rollback,annotation,find,annotation,test,context,get,test,method,rollback,class,if,rollback,annotation,null,boolean,rollback,override,rollback,annotation,value,if,logger,is,debug,enabled,logger,debug,string,format,method,level,rollback,s,overrides,default,rollback,s,for,test,context,s,rollback,override,rollback,test,context,rollback,rollback,override,else,if,logger,is,debug,enabled,logger,debug,string,format,no,method,level,rollback,override,using,default,rollback,s,for,test,context,s,rollback,test,context,return,rollback
TransactionalTestExecutionListener -> protected final boolean isRollback(TestContext testContext) throws Exception;1437851372;Determine whether or not to rollback transactions for the supplied_{@linkplain TestContext test context} by taking into consideration the_{@linkplain #isDefaultRollback(TestContext) default rollback} flag and a_possible method-level override via the {@link Rollback @Rollback}_annotation._@param testContext the test context for which the rollback flag_should be retrieved_@return the <em>rollback</em> flag for the supplied test context_@throws Exception if an error occurs while determining the rollback flag;protected final boolean isRollback(TestContext testContext) throws Exception {_		boolean rollback = isDefaultRollback(testContext)__		Rollback rollbackAnnotation = findAnnotation(testContext.getTestMethod(), Rollback.class)__		if (rollbackAnnotation != null) {_			boolean rollbackOverride = rollbackAnnotation.value()__			if (logger.isDebugEnabled()) {_				logger.debug(String.format(_					"Method-level @Rollback(%s) overrides default rollback [%s] for test context %s.",_					rollbackOverride, rollback, testContext))__			}_			rollback = rollbackOverride__		}_		else {_			if (logger.isDebugEnabled()) {_				logger.debug(String.format(_					"No method-level @Rollback override: using default rollback [%s] for test context %s.", rollback,_					testContext))__			}_		}_		return rollback__	};determine,whether,or,not,to,rollback,transactions,for,the,supplied,linkplain,test,context,test,context,by,taking,into,consideration,the,linkplain,is,default,rollback,test,context,default,rollback,flag,and,a,possible,method,level,override,via,the,link,rollback,rollback,annotation,param,test,context,the,test,context,for,which,the,rollback,flag,should,be,retrieved,return,the,em,rollback,em,flag,for,the,supplied,test,context,throws,exception,if,an,error,occurs,while,determining,the,rollback,flag;protected,final,boolean,is,rollback,test,context,test,context,throws,exception,boolean,rollback,is,default,rollback,test,context,rollback,rollback,annotation,find,annotation,test,context,get,test,method,rollback,class,if,rollback,annotation,null,boolean,rollback,override,rollback,annotation,value,if,logger,is,debug,enabled,logger,debug,string,format,method,level,rollback,s,overrides,default,rollback,s,for,test,context,s,rollback,override,rollback,test,context,rollback,rollback,override,else,if,logger,is,debug,enabled,logger,debug,string,format,no,method,level,rollback,override,using,default,rollback,s,for,test,context,s,rollback,test,context,return,rollback
TransactionalTestExecutionListener -> protected final boolean isRollback(TestContext testContext) throws Exception;1437852597;Determine whether or not to rollback transactions for the supplied_{@linkplain TestContext test context} by taking into consideration the_{@linkplain #isDefaultRollback(TestContext) default rollback} flag and a_possible method-level override via the {@link Rollback @Rollback}_annotation._@param testContext the test context for which the rollback flag_should be retrieved_@return the <em>rollback</em> flag for the supplied test context_@throws Exception if an error occurs while determining the rollback flag;protected final boolean isRollback(TestContext testContext) throws Exception {_		boolean rollback = isDefaultRollback(testContext)__		Rollback rollbackAnnotation = findAnnotation(testContext.getTestMethod(), Rollback.class)__		if (rollbackAnnotation != null) {_			boolean rollbackOverride = rollbackAnnotation.value()__			if (logger.isDebugEnabled()) {_				logger.debug(String.format(_					"Method-level @Rollback(%s) overrides default rollback [%s] for test context %s.",_					rollbackOverride, rollback, testContext))__			}_			rollback = rollbackOverride__		}_		else {_			if (logger.isDebugEnabled()) {_				logger.debug(String.format(_					"No method-level @Rollback override: using default rollback [%s] for test context %s.", rollback,_					testContext))__			}_		}_		return rollback__	};determine,whether,or,not,to,rollback,transactions,for,the,supplied,linkplain,test,context,test,context,by,taking,into,consideration,the,linkplain,is,default,rollback,test,context,default,rollback,flag,and,a,possible,method,level,override,via,the,link,rollback,rollback,annotation,param,test,context,the,test,context,for,which,the,rollback,flag,should,be,retrieved,return,the,em,rollback,em,flag,for,the,supplied,test,context,throws,exception,if,an,error,occurs,while,determining,the,rollback,flag;protected,final,boolean,is,rollback,test,context,test,context,throws,exception,boolean,rollback,is,default,rollback,test,context,rollback,rollback,annotation,find,annotation,test,context,get,test,method,rollback,class,if,rollback,annotation,null,boolean,rollback,override,rollback,annotation,value,if,logger,is,debug,enabled,logger,debug,string,format,method,level,rollback,s,overrides,default,rollback,s,for,test,context,s,rollback,override,rollback,test,context,rollback,rollback,override,else,if,logger,is,debug,enabled,logger,debug,string,format,no,method,level,rollback,override,using,default,rollback,s,for,test,context,s,rollback,test,context,return,rollback
TransactionalTestExecutionListener -> protected final boolean isRollback(TestContext testContext) throws Exception;1454507787;Determine whether or not to rollback transactions for the supplied_{@linkplain TestContext test context} by taking into consideration the_{@linkplain #isDefaultRollback(TestContext) default rollback} flag and a_possible method-level override via the {@link Rollback @Rollback}_annotation._@param testContext the test context for which the rollback flag_should be retrieved_@return the <em>rollback</em> flag for the supplied test context_@throws Exception if an error occurs while determining the rollback flag;protected final boolean isRollback(TestContext testContext) throws Exception {_		boolean rollback = isDefaultRollback(testContext)__		Rollback rollbackAnnotation = findAnnotation(testContext.getTestMethod(), Rollback.class)__		if (rollbackAnnotation != null) {_			boolean rollbackOverride = rollbackAnnotation.value()__			if (logger.isDebugEnabled()) {_				logger.debug(String.format(_					"Method-level @Rollback(%s) overrides default rollback [%s] for test context %s.",_					rollbackOverride, rollback, testContext))__			}_			rollback = rollbackOverride__		}_		else {_			if (logger.isDebugEnabled()) {_				logger.debug(String.format(_					"No method-level @Rollback override: using default rollback [%s] for test context %s.", rollback,_					testContext))__			}_		}_		return rollback__	};determine,whether,or,not,to,rollback,transactions,for,the,supplied,linkplain,test,context,test,context,by,taking,into,consideration,the,linkplain,is,default,rollback,test,context,default,rollback,flag,and,a,possible,method,level,override,via,the,link,rollback,rollback,annotation,param,test,context,the,test,context,for,which,the,rollback,flag,should,be,retrieved,return,the,em,rollback,em,flag,for,the,supplied,test,context,throws,exception,if,an,error,occurs,while,determining,the,rollback,flag;protected,final,boolean,is,rollback,test,context,test,context,throws,exception,boolean,rollback,is,default,rollback,test,context,rollback,rollback,annotation,find,annotation,test,context,get,test,method,rollback,class,if,rollback,annotation,null,boolean,rollback,override,rollback,annotation,value,if,logger,is,debug,enabled,logger,debug,string,format,method,level,rollback,s,overrides,default,rollback,s,for,test,context,s,rollback,override,rollback,test,context,rollback,rollback,override,else,if,logger,is,debug,enabled,logger,debug,string,format,no,method,level,rollback,override,using,default,rollback,s,for,test,context,s,rollback,test,context,return,rollback
TransactionalTestExecutionListener -> protected final boolean isRollback(TestContext testContext) throws Exception;1456702967;Determine whether or not to rollback transactions for the supplied_{@linkplain TestContext test context} by taking into consideration the_{@linkplain #isDefaultRollback(TestContext) default rollback} flag and a_possible method-level override via the {@link Rollback @Rollback}_annotation._@param testContext the test context for which the rollback flag_should be retrieved_@return the <em>rollback</em> flag for the supplied test context_@throws Exception if an error occurs while determining the rollback flag;protected final boolean isRollback(TestContext testContext) throws Exception {_		boolean rollback = isDefaultRollback(testContext)__		Rollback rollbackAnnotation = findAnnotation(testContext.getTestMethod(), Rollback.class)__		if (rollbackAnnotation != null) {_			boolean rollbackOverride = rollbackAnnotation.value()__			if (logger.isDebugEnabled()) {_				logger.debug(String.format(_					"Method-level @Rollback(%s) overrides default rollback [%s] for test context %s.",_					rollbackOverride, rollback, testContext))__			}_			rollback = rollbackOverride__		}_		else {_			if (logger.isDebugEnabled()) {_				logger.debug(String.format(_					"No method-level @Rollback override: using default rollback [%s] for test context %s.", rollback,_					testContext))__			}_		}_		return rollback__	};determine,whether,or,not,to,rollback,transactions,for,the,supplied,linkplain,test,context,test,context,by,taking,into,consideration,the,linkplain,is,default,rollback,test,context,default,rollback,flag,and,a,possible,method,level,override,via,the,link,rollback,rollback,annotation,param,test,context,the,test,context,for,which,the,rollback,flag,should,be,retrieved,return,the,em,rollback,em,flag,for,the,supplied,test,context,throws,exception,if,an,error,occurs,while,determining,the,rollback,flag;protected,final,boolean,is,rollback,test,context,test,context,throws,exception,boolean,rollback,is,default,rollback,test,context,rollback,rollback,annotation,find,annotation,test,context,get,test,method,rollback,class,if,rollback,annotation,null,boolean,rollback,override,rollback,annotation,value,if,logger,is,debug,enabled,logger,debug,string,format,method,level,rollback,s,overrides,default,rollback,s,for,test,context,s,rollback,override,rollback,test,context,rollback,rollback,override,else,if,logger,is,debug,enabled,logger,debug,string,format,no,method,level,rollback,override,using,default,rollback,s,for,test,context,s,rollback,test,context,return,rollback
TransactionalTestExecutionListener -> protected final boolean isRollback(TestContext testContext) throws Exception;1456756222;Determine whether or not to rollback transactions for the supplied_{@linkplain TestContext test context} by taking into consideration the_{@linkplain #isDefaultRollback(TestContext) default rollback} flag and a_possible method-level override via the {@link Rollback @Rollback}_annotation._@param testContext the test context for which the rollback flag_should be retrieved_@return the <em>rollback</em> flag for the supplied test context_@throws Exception if an error occurs while determining the rollback flag;protected final boolean isRollback(TestContext testContext) throws Exception {_		boolean rollback = isDefaultRollback(testContext)__		Rollback rollbackAnnotation = findAnnotation(testContext.getTestMethod(), Rollback.class)__		if (rollbackAnnotation != null) {_			boolean rollbackOverride = rollbackAnnotation.value()__			if (logger.isDebugEnabled()) {_				logger.debug(String.format(_					"Method-level @Rollback(%s) overrides default rollback [%s] for test context %s.",_					rollbackOverride, rollback, testContext))__			}_			rollback = rollbackOverride__		}_		else {_			if (logger.isDebugEnabled()) {_				logger.debug(String.format(_					"No method-level @Rollback override: using default rollback [%s] for test context %s.", rollback,_					testContext))__			}_		}_		return rollback__	};determine,whether,or,not,to,rollback,transactions,for,the,supplied,linkplain,test,context,test,context,by,taking,into,consideration,the,linkplain,is,default,rollback,test,context,default,rollback,flag,and,a,possible,method,level,override,via,the,link,rollback,rollback,annotation,param,test,context,the,test,context,for,which,the,rollback,flag,should,be,retrieved,return,the,em,rollback,em,flag,for,the,supplied,test,context,throws,exception,if,an,error,occurs,while,determining,the,rollback,flag;protected,final,boolean,is,rollback,test,context,test,context,throws,exception,boolean,rollback,is,default,rollback,test,context,rollback,rollback,annotation,find,annotation,test,context,get,test,method,rollback,class,if,rollback,annotation,null,boolean,rollback,override,rollback,annotation,value,if,logger,is,debug,enabled,logger,debug,string,format,method,level,rollback,s,overrides,default,rollback,s,for,test,context,s,rollback,override,rollback,test,context,rollback,rollback,override,else,if,logger,is,debug,enabled,logger,debug,string,format,no,method,level,rollback,override,using,default,rollback,s,for,test,context,s,rollback,test,context,return,rollback
TransactionalTestExecutionListener -> protected final boolean isRollback(TestContext testContext) throws Exception;1456756222;Determine whether or not to rollback transactions for the supplied_{@linkplain TestContext test context} by taking into consideration the_{@linkplain #isDefaultRollback(TestContext) default rollback} flag and a_possible method-level override via the {@link Rollback @Rollback}_annotation._@param testContext the test context for which the rollback flag_should be retrieved_@return the <em>rollback</em> flag for the supplied test context_@throws Exception if an error occurs while determining the rollback flag;protected final boolean isRollback(TestContext testContext) throws Exception {_		boolean rollback = isDefaultRollback(testContext)__		Rollback rollbackAnnotation = findAnnotation(testContext.getTestMethod(), Rollback.class)__		if (rollbackAnnotation != null) {_			boolean rollbackOverride = rollbackAnnotation.value()__			if (logger.isDebugEnabled()) {_				logger.debug(String.format(_					"Method-level @Rollback(%s) overrides default rollback [%s] for test context %s.",_					rollbackOverride, rollback, testContext))__			}_			rollback = rollbackOverride__		}_		else {_			if (logger.isDebugEnabled()) {_				logger.debug(String.format(_					"No method-level @Rollback override: using default rollback [%s] for test context %s.", rollback,_					testContext))__			}_		}_		return rollback__	};determine,whether,or,not,to,rollback,transactions,for,the,supplied,linkplain,test,context,test,context,by,taking,into,consideration,the,linkplain,is,default,rollback,test,context,default,rollback,flag,and,a,possible,method,level,override,via,the,link,rollback,rollback,annotation,param,test,context,the,test,context,for,which,the,rollback,flag,should,be,retrieved,return,the,em,rollback,em,flag,for,the,supplied,test,context,throws,exception,if,an,error,occurs,while,determining,the,rollback,flag;protected,final,boolean,is,rollback,test,context,test,context,throws,exception,boolean,rollback,is,default,rollback,test,context,rollback,rollback,annotation,find,annotation,test,context,get,test,method,rollback,class,if,rollback,annotation,null,boolean,rollback,override,rollback,annotation,value,if,logger,is,debug,enabled,logger,debug,string,format,method,level,rollback,s,overrides,default,rollback,s,for,test,context,s,rollback,override,rollback,test,context,rollback,rollback,override,else,if,logger,is,debug,enabled,logger,debug,string,format,no,method,level,rollback,override,using,default,rollback,s,for,test,context,s,rollback,test,context,return,rollback
TransactionalTestExecutionListener -> protected final boolean isRollback(TestContext testContext) throws Exception;1458754760;Determine whether or not to rollback transactions for the supplied_{@linkplain TestContext test context} by taking into consideration the_{@linkplain #isDefaultRollback(TestContext) default rollback} flag and a_possible method-level override via the {@link Rollback @Rollback}_annotation._@param testContext the test context for which the rollback flag_should be retrieved_@return the <em>rollback</em> flag for the supplied test context_@throws Exception if an error occurs while determining the rollback flag;protected final boolean isRollback(TestContext testContext) throws Exception {_		boolean rollback = isDefaultRollback(testContext)__		Rollback rollbackAnnotation =_				AnnotatedElementUtils.findMergedAnnotation(testContext.getTestMethod(), Rollback.class)__		if (rollbackAnnotation != null) {_			boolean rollbackOverride = rollbackAnnotation.value()__			if (logger.isDebugEnabled()) {_				logger.debug(String.format(_						"Method-level @Rollback(%s) overrides default rollback [%s] for test context %s.",_						rollbackOverride, rollback, testContext))__			}_			rollback = rollbackOverride__		}_		else {_			if (logger.isDebugEnabled()) {_				logger.debug(String.format(_						"No method-level @Rollback override: using default rollback [%s] for test context %s.",_						rollback, testContext))__			}_		}_		return rollback__	};determine,whether,or,not,to,rollback,transactions,for,the,supplied,linkplain,test,context,test,context,by,taking,into,consideration,the,linkplain,is,default,rollback,test,context,default,rollback,flag,and,a,possible,method,level,override,via,the,link,rollback,rollback,annotation,param,test,context,the,test,context,for,which,the,rollback,flag,should,be,retrieved,return,the,em,rollback,em,flag,for,the,supplied,test,context,throws,exception,if,an,error,occurs,while,determining,the,rollback,flag;protected,final,boolean,is,rollback,test,context,test,context,throws,exception,boolean,rollback,is,default,rollback,test,context,rollback,rollback,annotation,annotated,element,utils,find,merged,annotation,test,context,get,test,method,rollback,class,if,rollback,annotation,null,boolean,rollback,override,rollback,annotation,value,if,logger,is,debug,enabled,logger,debug,string,format,method,level,rollback,s,overrides,default,rollback,s,for,test,context,s,rollback,override,rollback,test,context,rollback,rollback,override,else,if,logger,is,debug,enabled,logger,debug,string,format,no,method,level,rollback,override,using,default,rollback,s,for,test,context,s,rollback,test,context,return,rollback
TransactionalTestExecutionListener -> protected final boolean isRollback(TestContext testContext) throws Exception;1462294651;Determine whether or not to rollback transactions for the supplied_{@linkplain TestContext test context} by taking into consideration the_{@linkplain #isDefaultRollback(TestContext) default rollback} flag and a_possible method-level override via the {@link Rollback @Rollback}_annotation._@param testContext the test context for which the rollback flag_should be retrieved_@return the <em>rollback</em> flag for the supplied test context_@throws Exception if an error occurs while determining the rollback flag;protected final boolean isRollback(TestContext testContext) throws Exception {_		boolean rollback = isDefaultRollback(testContext)__		Rollback rollbackAnnotation =_				AnnotatedElementUtils.findMergedAnnotation(testContext.getTestMethod(), Rollback.class)__		if (rollbackAnnotation != null) {_			boolean rollbackOverride = rollbackAnnotation.value()__			if (logger.isDebugEnabled()) {_				logger.debug(String.format(_						"Method-level @Rollback(%s) overrides default rollback [%s] for test context %s.",_						rollbackOverride, rollback, testContext))__			}_			rollback = rollbackOverride__		}_		else {_			if (logger.isDebugEnabled()) {_				logger.debug(String.format(_						"No method-level @Rollback override: using default rollback [%s] for test context %s.",_						rollback, testContext))__			}_		}_		return rollback__	};determine,whether,or,not,to,rollback,transactions,for,the,supplied,linkplain,test,context,test,context,by,taking,into,consideration,the,linkplain,is,default,rollback,test,context,default,rollback,flag,and,a,possible,method,level,override,via,the,link,rollback,rollback,annotation,param,test,context,the,test,context,for,which,the,rollback,flag,should,be,retrieved,return,the,em,rollback,em,flag,for,the,supplied,test,context,throws,exception,if,an,error,occurs,while,determining,the,rollback,flag;protected,final,boolean,is,rollback,test,context,test,context,throws,exception,boolean,rollback,is,default,rollback,test,context,rollback,rollback,annotation,annotated,element,utils,find,merged,annotation,test,context,get,test,method,rollback,class,if,rollback,annotation,null,boolean,rollback,override,rollback,annotation,value,if,logger,is,debug,enabled,logger,debug,string,format,method,level,rollback,s,overrides,default,rollback,s,for,test,context,s,rollback,override,rollback,test,context,rollback,rollback,override,else,if,logger,is,debug,enabled,logger,debug,string,format,no,method,level,rollback,override,using,default,rollback,s,for,test,context,s,rollback,test,context,return,rollback
TransactionalTestExecutionListener -> protected final boolean isRollback(TestContext testContext) throws Exception;1462299971;Determine whether or not to rollback transactions for the supplied_{@linkplain TestContext test context} by taking into consideration the_{@linkplain #isDefaultRollback(TestContext) default rollback} flag and a_possible method-level override via the {@link Rollback @Rollback}_annotation._@param testContext the test context for which the rollback flag_should be retrieved_@return the <em>rollback</em> flag for the supplied test context_@throws Exception if an error occurs while determining the rollback flag;protected final boolean isRollback(TestContext testContext) throws Exception {_		boolean rollback = isDefaultRollback(testContext)__		Rollback rollbackAnnotation =_				AnnotatedElementUtils.findMergedAnnotation(testContext.getTestMethod(), Rollback.class)__		if (rollbackAnnotation != null) {_			boolean rollbackOverride = rollbackAnnotation.value()__			if (logger.isDebugEnabled()) {_				logger.debug(String.format(_						"Method-level @Rollback(%s) overrides default rollback [%s] for test context %s.",_						rollbackOverride, rollback, testContext))__			}_			rollback = rollbackOverride__		}_		else {_			if (logger.isDebugEnabled()) {_				logger.debug(String.format(_						"No method-level @Rollback override: using default rollback [%s] for test context %s.",_						rollback, testContext))__			}_		}_		return rollback__	};determine,whether,or,not,to,rollback,transactions,for,the,supplied,linkplain,test,context,test,context,by,taking,into,consideration,the,linkplain,is,default,rollback,test,context,default,rollback,flag,and,a,possible,method,level,override,via,the,link,rollback,rollback,annotation,param,test,context,the,test,context,for,which,the,rollback,flag,should,be,retrieved,return,the,em,rollback,em,flag,for,the,supplied,test,context,throws,exception,if,an,error,occurs,while,determining,the,rollback,flag;protected,final,boolean,is,rollback,test,context,test,context,throws,exception,boolean,rollback,is,default,rollback,test,context,rollback,rollback,annotation,annotated,element,utils,find,merged,annotation,test,context,get,test,method,rollback,class,if,rollback,annotation,null,boolean,rollback,override,rollback,annotation,value,if,logger,is,debug,enabled,logger,debug,string,format,method,level,rollback,s,overrides,default,rollback,s,for,test,context,s,rollback,override,rollback,test,context,rollback,rollback,override,else,if,logger,is,debug,enabled,logger,debug,string,format,no,method,level,rollback,override,using,default,rollback,s,for,test,context,s,rollback,test,context,return,rollback
TransactionalTestExecutionListener -> protected final boolean isRollback(TestContext testContext) throws Exception;1467730834;Determine whether or not to rollback transactions for the supplied_{@linkplain TestContext test context} by taking into consideration the_{@linkplain #isDefaultRollback(TestContext) default rollback} flag and a_possible method-level override via the {@link Rollback @Rollback}_annotation._@param testContext the test context for which the rollback flag_should be retrieved_@return the <em>rollback</em> flag for the supplied test context_@throws Exception if an error occurs while determining the rollback flag;protected final boolean isRollback(TestContext testContext) throws Exception {_		boolean rollback = isDefaultRollback(testContext)__		Rollback rollbackAnnotation =_				AnnotatedElementUtils.findMergedAnnotation(testContext.getTestMethod(), Rollback.class)__		if (rollbackAnnotation != null) {_			boolean rollbackOverride = rollbackAnnotation.value()__			if (logger.isDebugEnabled()) {_				logger.debug(String.format(_						"Method-level @Rollback(%s) overrides default rollback [%s] for test context %s.",_						rollbackOverride, rollback, testContext))__			}_			rollback = rollbackOverride__		}_		else {_			if (logger.isDebugEnabled()) {_				logger.debug(String.format(_						"No method-level @Rollback override: using default rollback [%s] for test context %s.",_						rollback, testContext))__			}_		}_		return rollback__	};determine,whether,or,not,to,rollback,transactions,for,the,supplied,linkplain,test,context,test,context,by,taking,into,consideration,the,linkplain,is,default,rollback,test,context,default,rollback,flag,and,a,possible,method,level,override,via,the,link,rollback,rollback,annotation,param,test,context,the,test,context,for,which,the,rollback,flag,should,be,retrieved,return,the,em,rollback,em,flag,for,the,supplied,test,context,throws,exception,if,an,error,occurs,while,determining,the,rollback,flag;protected,final,boolean,is,rollback,test,context,test,context,throws,exception,boolean,rollback,is,default,rollback,test,context,rollback,rollback,annotation,annotated,element,utils,find,merged,annotation,test,context,get,test,method,rollback,class,if,rollback,annotation,null,boolean,rollback,override,rollback,annotation,value,if,logger,is,debug,enabled,logger,debug,string,format,method,level,rollback,s,overrides,default,rollback,s,for,test,context,s,rollback,override,rollback,test,context,rollback,rollback,override,else,if,logger,is,debug,enabled,logger,debug,string,format,no,method,level,rollback,override,using,default,rollback,s,for,test,context,s,rollback,test,context,return,rollback
TransactionalTestExecutionListener -> protected final boolean isRollback(TestContext testContext) throws Exception;1467992320;Determine whether or not to rollback transactions for the supplied_{@linkplain TestContext test context} by taking into consideration the_{@linkplain #isDefaultRollback(TestContext) default rollback} flag and a_possible method-level override via the {@link Rollback @Rollback}_annotation._@param testContext the test context for which the rollback flag_should be retrieved_@return the <em>rollback</em> flag for the supplied test context_@throws Exception if an error occurs while determining the rollback flag;protected final boolean isRollback(TestContext testContext) throws Exception {_		boolean rollback = isDefaultRollback(testContext)__		Rollback rollbackAnnotation =_				AnnotatedElementUtils.findMergedAnnotation(testContext.getTestMethod(), Rollback.class)__		if (rollbackAnnotation != null) {_			boolean rollbackOverride = rollbackAnnotation.value()__			if (logger.isDebugEnabled()) {_				logger.debug(String.format(_						"Method-level @Rollback(%s) overrides default rollback [%s] for test context %s.",_						rollbackOverride, rollback, testContext))__			}_			rollback = rollbackOverride__		}_		else {_			if (logger.isDebugEnabled()) {_				logger.debug(String.format(_						"No method-level @Rollback override: using default rollback [%s] for test context %s.",_						rollback, testContext))__			}_		}_		return rollback__	};determine,whether,or,not,to,rollback,transactions,for,the,supplied,linkplain,test,context,test,context,by,taking,into,consideration,the,linkplain,is,default,rollback,test,context,default,rollback,flag,and,a,possible,method,level,override,via,the,link,rollback,rollback,annotation,param,test,context,the,test,context,for,which,the,rollback,flag,should,be,retrieved,return,the,em,rollback,em,flag,for,the,supplied,test,context,throws,exception,if,an,error,occurs,while,determining,the,rollback,flag;protected,final,boolean,is,rollback,test,context,test,context,throws,exception,boolean,rollback,is,default,rollback,test,context,rollback,rollback,annotation,annotated,element,utils,find,merged,annotation,test,context,get,test,method,rollback,class,if,rollback,annotation,null,boolean,rollback,override,rollback,annotation,value,if,logger,is,debug,enabled,logger,debug,string,format,method,level,rollback,s,overrides,default,rollback,s,for,test,context,s,rollback,override,rollback,test,context,rollback,rollback,override,else,if,logger,is,debug,enabled,logger,debug,string,format,no,method,level,rollback,override,using,default,rollback,s,for,test,context,s,rollback,test,context,return,rollback
TransactionalTestExecutionListener -> protected final boolean isRollback(TestContext testContext) throws Exception;1467992442;Determine whether or not to rollback transactions for the supplied_{@linkplain TestContext test context} by taking into consideration the_{@linkplain #isDefaultRollback(TestContext) default rollback} flag and a_possible method-level override via the {@link Rollback @Rollback}_annotation._@param testContext the test context for which the rollback flag_should be retrieved_@return the <em>rollback</em> flag for the supplied test context_@throws Exception if an error occurs while determining the rollback flag;protected final boolean isRollback(TestContext testContext) throws Exception {_		boolean rollback = isDefaultRollback(testContext)__		Rollback rollbackAnnotation =_				AnnotatedElementUtils.findMergedAnnotation(testContext.getTestMethod(), Rollback.class)__		if (rollbackAnnotation != null) {_			boolean rollbackOverride = rollbackAnnotation.value()__			if (logger.isDebugEnabled()) {_				logger.debug(String.format(_						"Method-level @Rollback(%s) overrides default rollback [%s] for test context %s.",_						rollbackOverride, rollback, testContext))__			}_			rollback = rollbackOverride__		}_		else {_			if (logger.isDebugEnabled()) {_				logger.debug(String.format(_						"No method-level @Rollback override: using default rollback [%s] for test context %s.",_						rollback, testContext))__			}_		}_		return rollback__	};determine,whether,or,not,to,rollback,transactions,for,the,supplied,linkplain,test,context,test,context,by,taking,into,consideration,the,linkplain,is,default,rollback,test,context,default,rollback,flag,and,a,possible,method,level,override,via,the,link,rollback,rollback,annotation,param,test,context,the,test,context,for,which,the,rollback,flag,should,be,retrieved,return,the,em,rollback,em,flag,for,the,supplied,test,context,throws,exception,if,an,error,occurs,while,determining,the,rollback,flag;protected,final,boolean,is,rollback,test,context,test,context,throws,exception,boolean,rollback,is,default,rollback,test,context,rollback,rollback,annotation,annotated,element,utils,find,merged,annotation,test,context,get,test,method,rollback,class,if,rollback,annotation,null,boolean,rollback,override,rollback,annotation,value,if,logger,is,debug,enabled,logger,debug,string,format,method,level,rollback,s,overrides,default,rollback,s,for,test,context,s,rollback,override,rollback,test,context,rollback,rollback,override,else,if,logger,is,debug,enabled,logger,debug,string,format,no,method,level,rollback,override,using,default,rollback,s,for,test,context,s,rollback,test,context,return,rollback
TransactionalTestExecutionListener -> protected final boolean isRollback(TestContext testContext) throws Exception;1467994604;Determine whether or not to rollback transactions for the supplied_{@linkplain TestContext test context} by taking into consideration the_{@linkplain #isDefaultRollback(TestContext) default rollback} flag and a_possible method-level override via the {@link Rollback @Rollback}_annotation._@param testContext the test context for which the rollback flag_should be retrieved_@return the <em>rollback</em> flag for the supplied test context_@throws Exception if an error occurs while determining the rollback flag;protected final boolean isRollback(TestContext testContext) throws Exception {_		boolean rollback = isDefaultRollback(testContext)__		Rollback rollbackAnnotation =_				AnnotatedElementUtils.findMergedAnnotation(testContext.getTestMethod(), Rollback.class)__		if (rollbackAnnotation != null) {_			boolean rollbackOverride = rollbackAnnotation.value()__			if (logger.isDebugEnabled()) {_				logger.debug(String.format(_						"Method-level @Rollback(%s) overrides default rollback [%s] for test context %s.",_						rollbackOverride, rollback, testContext))__			}_			rollback = rollbackOverride__		}_		else {_			if (logger.isDebugEnabled()) {_				logger.debug(String.format(_						"No method-level @Rollback override: using default rollback [%s] for test context %s.",_						rollback, testContext))__			}_		}_		return rollback__	};determine,whether,or,not,to,rollback,transactions,for,the,supplied,linkplain,test,context,test,context,by,taking,into,consideration,the,linkplain,is,default,rollback,test,context,default,rollback,flag,and,a,possible,method,level,override,via,the,link,rollback,rollback,annotation,param,test,context,the,test,context,for,which,the,rollback,flag,should,be,retrieved,return,the,em,rollback,em,flag,for,the,supplied,test,context,throws,exception,if,an,error,occurs,while,determining,the,rollback,flag;protected,final,boolean,is,rollback,test,context,test,context,throws,exception,boolean,rollback,is,default,rollback,test,context,rollback,rollback,annotation,annotated,element,utils,find,merged,annotation,test,context,get,test,method,rollback,class,if,rollback,annotation,null,boolean,rollback,override,rollback,annotation,value,if,logger,is,debug,enabled,logger,debug,string,format,method,level,rollback,s,overrides,default,rollback,s,for,test,context,s,rollback,override,rollback,test,context,rollback,rollback,override,else,if,logger,is,debug,enabled,logger,debug,string,format,no,method,level,rollback,override,using,default,rollback,s,for,test,context,s,rollback,test,context,return,rollback
TransactionalTestExecutionListener -> protected final boolean isRollback(TestContext testContext) throws Exception;1468334463;Determine whether or not to rollback transactions for the supplied_{@linkplain TestContext test context} by taking into consideration the_{@linkplain #isDefaultRollback(TestContext) default rollback} flag and a_possible method-level override via the {@link Rollback @Rollback}_annotation._@param testContext the test context for which the rollback flag_should be retrieved_@return the <em>rollback</em> flag for the supplied test context_@throws Exception if an error occurs while determining the rollback flag;protected final boolean isRollback(TestContext testContext) throws Exception {_		boolean rollback = isDefaultRollback(testContext)__		Rollback rollbackAnnotation =_				AnnotatedElementUtils.findMergedAnnotation(testContext.getTestMethod(), Rollback.class)__		if (rollbackAnnotation != null) {_			boolean rollbackOverride = rollbackAnnotation.value()__			if (logger.isDebugEnabled()) {_				logger.debug(String.format(_						"Method-level @Rollback(%s) overrides default rollback [%s] for test context %s.",_						rollbackOverride, rollback, testContext))__			}_			rollback = rollbackOverride__		}_		else {_			if (logger.isDebugEnabled()) {_				logger.debug(String.format(_						"No method-level @Rollback override: using default rollback [%s] for test context %s.",_						rollback, testContext))__			}_		}_		return rollback__	};determine,whether,or,not,to,rollback,transactions,for,the,supplied,linkplain,test,context,test,context,by,taking,into,consideration,the,linkplain,is,default,rollback,test,context,default,rollback,flag,and,a,possible,method,level,override,via,the,link,rollback,rollback,annotation,param,test,context,the,test,context,for,which,the,rollback,flag,should,be,retrieved,return,the,em,rollback,em,flag,for,the,supplied,test,context,throws,exception,if,an,error,occurs,while,determining,the,rollback,flag;protected,final,boolean,is,rollback,test,context,test,context,throws,exception,boolean,rollback,is,default,rollback,test,context,rollback,rollback,annotation,annotated,element,utils,find,merged,annotation,test,context,get,test,method,rollback,class,if,rollback,annotation,null,boolean,rollback,override,rollback,annotation,value,if,logger,is,debug,enabled,logger,debug,string,format,method,level,rollback,s,overrides,default,rollback,s,for,test,context,s,rollback,override,rollback,test,context,rollback,rollback,override,else,if,logger,is,debug,enabled,logger,debug,string,format,no,method,level,rollback,override,using,default,rollback,s,for,test,context,s,rollback,test,context,return,rollback
TransactionalTestExecutionListener -> protected final boolean isRollback(TestContext testContext) throws Exception;1496955179;Determine whether or not to rollback transactions for the supplied_{@linkplain TestContext test context} by taking into consideration the_{@linkplain #isDefaultRollback(TestContext) default rollback} flag and a_possible method-level override via the {@link Rollback @Rollback}_annotation._@param testContext the test context for which the rollback flag_should be retrieved_@return the <em>rollback</em> flag for the supplied test context_@throws Exception if an error occurs while determining the rollback flag;protected final boolean isRollback(TestContext testContext) throws Exception {_		boolean rollback = isDefaultRollback(testContext)__		Rollback rollbackAnnotation =_				AnnotatedElementUtils.findMergedAnnotation(testContext.getTestMethod(), Rollback.class)__		if (rollbackAnnotation != null) {_			boolean rollbackOverride = rollbackAnnotation.value()__			if (logger.isDebugEnabled()) {_				logger.debug(String.format(_						"Method-level @Rollback(%s) overrides default rollback [%s] for test context %s.",_						rollbackOverride, rollback, testContext))__			}_			rollback = rollbackOverride__		}_		else {_			if (logger.isDebugEnabled()) {_				logger.debug(String.format(_						"No method-level @Rollback override: using default rollback [%s] for test context %s.",_						rollback, testContext))__			}_		}_		return rollback__	};determine,whether,or,not,to,rollback,transactions,for,the,supplied,linkplain,test,context,test,context,by,taking,into,consideration,the,linkplain,is,default,rollback,test,context,default,rollback,flag,and,a,possible,method,level,override,via,the,link,rollback,rollback,annotation,param,test,context,the,test,context,for,which,the,rollback,flag,should,be,retrieved,return,the,em,rollback,em,flag,for,the,supplied,test,context,throws,exception,if,an,error,occurs,while,determining,the,rollback,flag;protected,final,boolean,is,rollback,test,context,test,context,throws,exception,boolean,rollback,is,default,rollback,test,context,rollback,rollback,annotation,annotated,element,utils,find,merged,annotation,test,context,get,test,method,rollback,class,if,rollback,annotation,null,boolean,rollback,override,rollback,annotation,value,if,logger,is,debug,enabled,logger,debug,string,format,method,level,rollback,s,overrides,default,rollback,s,for,test,context,s,rollback,override,rollback,test,context,rollback,rollback,override,else,if,logger,is,debug,enabled,logger,debug,string,format,no,method,level,rollback,override,using,default,rollback,s,for,test,context,s,rollback,test,context,return,rollback
TransactionalTestExecutionListener -> protected final boolean isRollback(TestContext testContext) throws Exception;1498780456;Determine whether or not to rollback transactions for the supplied_{@linkplain TestContext test context} by taking into consideration the_{@linkplain #isDefaultRollback(TestContext) default rollback} flag and a_possible method-level override via the {@link Rollback @Rollback}_annotation._@param testContext the test context for which the rollback flag_should be retrieved_@return the <em>rollback</em> flag for the supplied test context_@throws Exception if an error occurs while determining the rollback flag;protected final boolean isRollback(TestContext testContext) throws Exception {_		boolean rollback = isDefaultRollback(testContext)__		Rollback rollbackAnnotation =_				AnnotatedElementUtils.findMergedAnnotation(testContext.getTestMethod(), Rollback.class)__		if (rollbackAnnotation != null) {_			boolean rollbackOverride = rollbackAnnotation.value()__			if (logger.isDebugEnabled()) {_				logger.debug(String.format(_						"Method-level @Rollback(%s) overrides default rollback [%s] for test context %s.",_						rollbackOverride, rollback, testContext))__			}_			rollback = rollbackOverride__		}_		else {_			if (logger.isDebugEnabled()) {_				logger.debug(String.format(_						"No method-level @Rollback override: using default rollback [%s] for test context %s.",_						rollback, testContext))__			}_		}_		return rollback__	};determine,whether,or,not,to,rollback,transactions,for,the,supplied,linkplain,test,context,test,context,by,taking,into,consideration,the,linkplain,is,default,rollback,test,context,default,rollback,flag,and,a,possible,method,level,override,via,the,link,rollback,rollback,annotation,param,test,context,the,test,context,for,which,the,rollback,flag,should,be,retrieved,return,the,em,rollback,em,flag,for,the,supplied,test,context,throws,exception,if,an,error,occurs,while,determining,the,rollback,flag;protected,final,boolean,is,rollback,test,context,test,context,throws,exception,boolean,rollback,is,default,rollback,test,context,rollback,rollback,annotation,annotated,element,utils,find,merged,annotation,test,context,get,test,method,rollback,class,if,rollback,annotation,null,boolean,rollback,override,rollback,annotation,value,if,logger,is,debug,enabled,logger,debug,string,format,method,level,rollback,s,overrides,default,rollback,s,for,test,context,s,rollback,override,rollback,test,context,rollback,rollback,override,else,if,logger,is,debug,enabled,logger,debug,string,format,no,method,level,rollback,override,using,default,rollback,s,for,test,context,s,rollback,test,context,return,rollback
TransactionalTestExecutionListener -> protected final boolean isRollback(TestContext testContext) throws Exception;1520251235;Determine whether or not to rollback transactions for the supplied_{@linkplain TestContext test context} by taking into consideration the_{@linkplain #isDefaultRollback(TestContext) default rollback} flag and a_possible method-level override via the {@link Rollback @Rollback}_annotation._@param testContext the test context for which the rollback flag_should be retrieved_@return the <em>rollback</em> flag for the supplied test context_@throws Exception if an error occurs while determining the rollback flag;protected final boolean isRollback(TestContext testContext) throws Exception {_		boolean rollback = isDefaultRollback(testContext)__		Rollback rollbackAnnotation =_				AnnotatedElementUtils.findMergedAnnotation(testContext.getTestMethod(), Rollback.class)__		if (rollbackAnnotation != null) {_			boolean rollbackOverride = rollbackAnnotation.value()__			if (logger.isDebugEnabled()) {_				logger.debug(String.format(_						"Method-level @Rollback(%s) overrides default rollback [%s] for test context %s.",_						rollbackOverride, rollback, testContext))__			}_			rollback = rollbackOverride__		}_		else {_			if (logger.isDebugEnabled()) {_				logger.debug(String.format(_						"No method-level @Rollback override: using default rollback [%s] for test context %s.",_						rollback, testContext))__			}_		}_		return rollback__	};determine,whether,or,not,to,rollback,transactions,for,the,supplied,linkplain,test,context,test,context,by,taking,into,consideration,the,linkplain,is,default,rollback,test,context,default,rollback,flag,and,a,possible,method,level,override,via,the,link,rollback,rollback,annotation,param,test,context,the,test,context,for,which,the,rollback,flag,should,be,retrieved,return,the,em,rollback,em,flag,for,the,supplied,test,context,throws,exception,if,an,error,occurs,while,determining,the,rollback,flag;protected,final,boolean,is,rollback,test,context,test,context,throws,exception,boolean,rollback,is,default,rollback,test,context,rollback,rollback,annotation,annotated,element,utils,find,merged,annotation,test,context,get,test,method,rollback,class,if,rollback,annotation,null,boolean,rollback,override,rollback,annotation,value,if,logger,is,debug,enabled,logger,debug,string,format,method,level,rollback,s,overrides,default,rollback,s,for,test,context,s,rollback,override,rollback,test,context,rollback,rollback,override,else,if,logger,is,debug,enabled,logger,debug,string,format,no,method,level,rollback,override,using,default,rollback,s,for,test,context,s,rollback,test,context,return,rollback
TransactionalTestExecutionListener -> protected final PlatformTransactionManager getTransactionManager(TestContext testContext);1328020251;Get the {@link PlatformTransactionManager transaction manager} to use_for the supplied {@link TestContext test context}._@param testContext the test context for which the transaction manager_should be retrieved_@return the transaction manager to use, or <code>null</code> if not found_@throws BeansException if an error occurs while retrieving the transaction manager;protected final PlatformTransactionManager getTransactionManager(TestContext testContext) {_		String tmName = retrieveConfigurationAttributes(testContext).getTransactionManagerName()__		try {_			return testContext.getApplicationContext().getBean(tmName, PlatformTransactionManager.class)__		}_		catch (BeansException ex) {_			if (logger.isWarnEnabled()) {_				logger.warn("Caught exception while retrieving transaction manager with bean name [" + tmName_						+ "] for test context [" + testContext + "]", ex)__			}_			throw ex__		}_	};get,the,link,platform,transaction,manager,transaction,manager,to,use,for,the,supplied,link,test,context,test,context,param,test,context,the,test,context,for,which,the,transaction,manager,should,be,retrieved,return,the,transaction,manager,to,use,or,code,null,code,if,not,found,throws,beans,exception,if,an,error,occurs,while,retrieving,the,transaction,manager;protected,final,platform,transaction,manager,get,transaction,manager,test,context,test,context,string,tm,name,retrieve,configuration,attributes,test,context,get,transaction,manager,name,try,return,test,context,get,application,context,get,bean,tm,name,platform,transaction,manager,class,catch,beans,exception,ex,if,logger,is,warn,enabled,logger,warn,caught,exception,while,retrieving,transaction,manager,with,bean,name,tm,name,for,test,context,test,context,ex,throw,ex
TransactionalTestExecutionListener -> protected final PlatformTransactionManager getTransactionManager(TestContext testContext);1337516454;Get the {@link PlatformTransactionManager transaction manager} to use_for the supplied {@link TestContext test context}._@param testContext the test context for which the transaction manager_should be retrieved_@return the transaction manager to use, or <code>null</code> if not found_@throws BeansException if an error occurs while retrieving the transaction manager;protected final PlatformTransactionManager getTransactionManager(TestContext testContext) {_		String tmName = retrieveConfigurationAttributes(testContext).getTransactionManagerName()__		try {_			return testContext.getApplicationContext().getBean(tmName, PlatformTransactionManager.class)__		}_		catch (BeansException ex) {_			if (logger.isWarnEnabled()) {_				logger.warn("Caught exception while retrieving transaction manager with bean name [" + tmName_						+ "] for test context [" + testContext + "]", ex)__			}_			throw ex__		}_	};get,the,link,platform,transaction,manager,transaction,manager,to,use,for,the,supplied,link,test,context,test,context,param,test,context,the,test,context,for,which,the,transaction,manager,should,be,retrieved,return,the,transaction,manager,to,use,or,code,null,code,if,not,found,throws,beans,exception,if,an,error,occurs,while,retrieving,the,transaction,manager;protected,final,platform,transaction,manager,get,transaction,manager,test,context,test,context,string,tm,name,retrieve,configuration,attributes,test,context,get,transaction,manager,name,try,return,test,context,get,application,context,get,bean,tm,name,platform,transaction,manager,class,catch,beans,exception,ex,if,logger,is,warn,enabled,logger,warn,caught,exception,while,retrieving,transaction,manager,with,bean,name,tm,name,for,test,context,test,context,ex,throw,ex
TransactionalTestExecutionListener -> protected final PlatformTransactionManager getTransactionManager(TestContext testContext);1338031377;Get the {@link PlatformTransactionManager transaction manager} to use_for the supplied {@link TestContext test context}._@param testContext the test context for which the transaction manager_should be retrieved_@return the transaction manager to use, or <code>null</code> if not found_@throws BeansException if an error occurs while retrieving the transaction manager;protected final PlatformTransactionManager getTransactionManager(TestContext testContext) {_		String tmName = retrieveConfigurationAttributes(testContext).getTransactionManagerName()__		try {_			return testContext.getApplicationContext().getBean(tmName, PlatformTransactionManager.class)__		}_		catch (BeansException ex) {_			if (logger.isWarnEnabled()) {_				logger.warn("Caught exception while retrieving transaction manager with bean name [" + tmName_						+ "] for test context [" + testContext + "]", ex)__			}_			throw ex__		}_	};get,the,link,platform,transaction,manager,transaction,manager,to,use,for,the,supplied,link,test,context,test,context,param,test,context,the,test,context,for,which,the,transaction,manager,should,be,retrieved,return,the,transaction,manager,to,use,or,code,null,code,if,not,found,throws,beans,exception,if,an,error,occurs,while,retrieving,the,transaction,manager;protected,final,platform,transaction,manager,get,transaction,manager,test,context,test,context,string,tm,name,retrieve,configuration,attributes,test,context,get,transaction,manager,name,try,return,test,context,get,application,context,get,bean,tm,name,platform,transaction,manager,class,catch,beans,exception,ex,if,logger,is,warn,enabled,logger,warn,caught,exception,while,retrieving,transaction,manager,with,bean,name,tm,name,for,test,context,test,context,ex,throw,ex
TransactionalTestExecutionListener -> protected final PlatformTransactionManager getTransactionManager(TestContext testContext);1343426806;Get the {@link PlatformTransactionManager transaction manager} to use_for the supplied {@link TestContext test context}._@param testContext the test context for which the transaction manager_should be retrieved_@return the transaction manager to use, or <code>null</code> if not found_@throws BeansException if an error occurs while retrieving the transaction manager_@see #getTransactionManager(TestContext, String);protected final PlatformTransactionManager getTransactionManager(TestContext testContext) {_		BeanFactory bf = testContext.getApplicationContext().getAutowireCapableBeanFactory()__		String tmName = retrieveConfigurationAttributes(testContext).getTransactionManagerName()___		try {_			_			if (StringUtils.hasText(tmName) && !DEFAULT_TRANSACTION_MANAGER_NAME.equals(tmName)) {_				return bf.getBean(tmName, PlatformTransactionManager.class)__			}__			_			if (bf instanceof ListableBeanFactory) {_				ListableBeanFactory lbf = (ListableBeanFactory) bf__				Map<String, PlatformTransactionManager> beansOfType = BeanFactoryUtils.beansOfTypeIncludingAncestors(_					lbf, PlatformTransactionManager.class)__				if (beansOfType.size() == 1) {_					return beansOfType.values().iterator().next()__				}_			}__			_			return bf.getBean(DEFAULT_TRANSACTION_MANAGER_NAME, PlatformTransactionManager.class)___		} catch (BeansException ex) {_			if (logger.isWarnEnabled()) {_				logger.warn("Caught exception while retrieving transaction manager for test context " + testContext, ex)__			}_			throw ex__		}_	};get,the,link,platform,transaction,manager,transaction,manager,to,use,for,the,supplied,link,test,context,test,context,param,test,context,the,test,context,for,which,the,transaction,manager,should,be,retrieved,return,the,transaction,manager,to,use,or,code,null,code,if,not,found,throws,beans,exception,if,an,error,occurs,while,retrieving,the,transaction,manager,see,get,transaction,manager,test,context,string;protected,final,platform,transaction,manager,get,transaction,manager,test,context,test,context,bean,factory,bf,test,context,get,application,context,get,autowire,capable,bean,factory,string,tm,name,retrieve,configuration,attributes,test,context,get,transaction,manager,name,try,if,string,utils,has,text,tm,name,equals,tm,name,return,bf,get,bean,tm,name,platform,transaction,manager,class,if,bf,instanceof,listable,bean,factory,listable,bean,factory,lbf,listable,bean,factory,bf,map,string,platform,transaction,manager,beans,of,type,bean,factory,utils,beans,of,type,including,ancestors,lbf,platform,transaction,manager,class,if,beans,of,type,size,1,return,beans,of,type,values,iterator,next,return,bf,get,bean,platform,transaction,manager,class,catch,beans,exception,ex,if,logger,is,warn,enabled,logger,warn,caught,exception,while,retrieving,transaction,manager,for,test,context,test,context,ex,throw,ex
TransactionalTestExecutionListener -> protected final PlatformTransactionManager getTransactionManager(TestContext testContext);1343431472;Get the {@link PlatformTransactionManager transaction manager} to use_for the supplied {@link TestContext test context}._@param testContext the test context for which the transaction manager_should be retrieved_@return the transaction manager to use, or <code>null</code> if not found_@throws BeansException if an error occurs while retrieving the transaction manager_@see #getTransactionManager(TestContext, String);protected final PlatformTransactionManager getTransactionManager(TestContext testContext) {_		BeanFactory bf = testContext.getApplicationContext().getAutowireCapableBeanFactory()__		String tmName = retrieveConfigurationAttributes(testContext).getTransactionManagerName()___		try {_			_			if (StringUtils.hasText(tmName) && !DEFAULT_TRANSACTION_MANAGER_NAME.equals(tmName)) {_				return bf.getBean(tmName, PlatformTransactionManager.class)__			}__			if (bf instanceof ListableBeanFactory) {_				ListableBeanFactory lbf = (ListableBeanFactory) bf___				_				Map<String, PlatformTransactionManager> txMgrs = BeanFactoryUtils.beansOfTypeIncludingAncestors(_					lbf, PlatformTransactionManager.class)__				if (txMgrs.size() == 1) {_					return txMgrs.values().iterator().next()__				}__				_				Map<String, TransactionManagementConfigurer> configurers = BeanFactoryUtils.beansOfTypeIncludingAncestors(_					lbf, TransactionManagementConfigurer.class)__				if (configurers.size() > 1) {_					throw new IllegalStateException(_						"Only one TransactionManagementConfigurer may exist in the ApplicationContext")__				}_				if (configurers.size() == 1) {_					return configurers.values().iterator().next().annotationDrivenTransactionManager()__				}_			}__			_			return bf.getBean(DEFAULT_TRANSACTION_MANAGER_NAME, PlatformTransactionManager.class)___		} catch (BeansException ex) {_			if (logger.isWarnEnabled()) {_				logger.warn("Caught exception while retrieving transaction manager for test context " + testContext, ex)__			}_			throw ex__		}_	};get,the,link,platform,transaction,manager,transaction,manager,to,use,for,the,supplied,link,test,context,test,context,param,test,context,the,test,context,for,which,the,transaction,manager,should,be,retrieved,return,the,transaction,manager,to,use,or,code,null,code,if,not,found,throws,beans,exception,if,an,error,occurs,while,retrieving,the,transaction,manager,see,get,transaction,manager,test,context,string;protected,final,platform,transaction,manager,get,transaction,manager,test,context,test,context,bean,factory,bf,test,context,get,application,context,get,autowire,capable,bean,factory,string,tm,name,retrieve,configuration,attributes,test,context,get,transaction,manager,name,try,if,string,utils,has,text,tm,name,equals,tm,name,return,bf,get,bean,tm,name,platform,transaction,manager,class,if,bf,instanceof,listable,bean,factory,listable,bean,factory,lbf,listable,bean,factory,bf,map,string,platform,transaction,manager,tx,mgrs,bean,factory,utils,beans,of,type,including,ancestors,lbf,platform,transaction,manager,class,if,tx,mgrs,size,1,return,tx,mgrs,values,iterator,next,map,string,transaction,management,configurer,configurers,bean,factory,utils,beans,of,type,including,ancestors,lbf,transaction,management,configurer,class,if,configurers,size,1,throw,new,illegal,state,exception,only,one,transaction,management,configurer,may,exist,in,the,application,context,if,configurers,size,1,return,configurers,values,iterator,next,annotation,driven,transaction,manager,return,bf,get,bean,platform,transaction,manager,class,catch,beans,exception,ex,if,logger,is,warn,enabled,logger,warn,caught,exception,while,retrieving,transaction,manager,for,test,context,test,context,ex,throw,ex
TransactionalTestExecutionListener -> protected final PlatformTransactionManager getTransactionManager(TestContext testContext);1354571539;Get the {@link PlatformTransactionManager transaction manager} to use_for the supplied {@link TestContext test context}._@param testContext the test context for which the transaction manager_should be retrieved_@return the transaction manager to use, or <code>null</code> if not found_@throws BeansException if an error occurs while retrieving the transaction manager_@see #getTransactionManager(TestContext, String);protected final PlatformTransactionManager getTransactionManager(TestContext testContext) {_		BeanFactory bf = testContext.getApplicationContext().getAutowireCapableBeanFactory()__		String tmName = retrieveConfigurationAttributes(testContext).getTransactionManagerName()___		try {_			_			if (StringUtils.hasText(tmName) && !DEFAULT_TRANSACTION_MANAGER_NAME.equals(tmName)) {_				return bf.getBean(tmName, PlatformTransactionManager.class)__			}__			if (bf instanceof ListableBeanFactory) {_				ListableBeanFactory lbf = (ListableBeanFactory) bf___				_				Map<String, PlatformTransactionManager> txMgrs = BeanFactoryUtils.beansOfTypeIncludingAncestors(_					lbf, PlatformTransactionManager.class)__				if (txMgrs.size() == 1) {_					return txMgrs.values().iterator().next()__				}__				_				Map<String, TransactionManagementConfigurer> configurers = BeanFactoryUtils.beansOfTypeIncludingAncestors(_					lbf, TransactionManagementConfigurer.class)__				if (configurers.size() > 1) {_					throw new IllegalStateException(_						"Only one TransactionManagementConfigurer may exist in the ApplicationContext")__				}_				if (configurers.size() == 1) {_					return configurers.values().iterator().next().annotationDrivenTransactionManager()__				}_			}__			_			return bf.getBean(DEFAULT_TRANSACTION_MANAGER_NAME, PlatformTransactionManager.class)___		} catch (BeansException ex) {_			if (logger.isWarnEnabled()) {_				logger.warn("Caught exception while retrieving transaction manager for test context " + testContext, ex)__			}_			throw ex__		}_	};get,the,link,platform,transaction,manager,transaction,manager,to,use,for,the,supplied,link,test,context,test,context,param,test,context,the,test,context,for,which,the,transaction,manager,should,be,retrieved,return,the,transaction,manager,to,use,or,code,null,code,if,not,found,throws,beans,exception,if,an,error,occurs,while,retrieving,the,transaction,manager,see,get,transaction,manager,test,context,string;protected,final,platform,transaction,manager,get,transaction,manager,test,context,test,context,bean,factory,bf,test,context,get,application,context,get,autowire,capable,bean,factory,string,tm,name,retrieve,configuration,attributes,test,context,get,transaction,manager,name,try,if,string,utils,has,text,tm,name,equals,tm,name,return,bf,get,bean,tm,name,platform,transaction,manager,class,if,bf,instanceof,listable,bean,factory,listable,bean,factory,lbf,listable,bean,factory,bf,map,string,platform,transaction,manager,tx,mgrs,bean,factory,utils,beans,of,type,including,ancestors,lbf,platform,transaction,manager,class,if,tx,mgrs,size,1,return,tx,mgrs,values,iterator,next,map,string,transaction,management,configurer,configurers,bean,factory,utils,beans,of,type,including,ancestors,lbf,transaction,management,configurer,class,if,configurers,size,1,throw,new,illegal,state,exception,only,one,transaction,management,configurer,may,exist,in,the,application,context,if,configurers,size,1,return,configurers,values,iterator,next,annotation,driven,transaction,manager,return,bf,get,bean,platform,transaction,manager,class,catch,beans,exception,ex,if,logger,is,warn,enabled,logger,warn,caught,exception,while,retrieving,transaction,manager,for,test,context,test,context,ex,throw,ex
TransactionalTestExecutionListener -> protected final PlatformTransactionManager getTransactionManager(TestContext testContext);1355352386;Get the {@link PlatformTransactionManager transaction manager} to use_for the supplied {@link TestContext test context}._@param testContext the test context for which the transaction manager_should be retrieved_@return the transaction manager to use, or <code>null</code> if not found_@throws BeansException if an error occurs while retrieving the transaction manager_@see #getTransactionManager(TestContext, String);protected final PlatformTransactionManager getTransactionManager(TestContext testContext) {_		BeanFactory bf = testContext.getApplicationContext().getAutowireCapableBeanFactory()__		String tmName = retrieveConfigurationAttributes(testContext).getTransactionManagerName()___		try {_			_			if (StringUtils.hasText(tmName) && !DEFAULT_TRANSACTION_MANAGER_NAME.equals(tmName)) {_				return bf.getBean(tmName, PlatformTransactionManager.class)__			}__			if (bf instanceof ListableBeanFactory) {_				ListableBeanFactory lbf = (ListableBeanFactory) bf___				_				Map<String, PlatformTransactionManager> txMgrs = BeanFactoryUtils.beansOfTypeIncludingAncestors(_					lbf, PlatformTransactionManager.class)__				if (txMgrs.size() == 1) {_					return txMgrs.values().iterator().next()__				}__				_				Map<String, TransactionManagementConfigurer> configurers = BeanFactoryUtils.beansOfTypeIncludingAncestors(_					lbf, TransactionManagementConfigurer.class)__				if (configurers.size() > 1) {_					throw new IllegalStateException(_						"Only one TransactionManagementConfigurer may exist in the ApplicationContext")__				}_				if (configurers.size() == 1) {_					return configurers.values().iterator().next().annotationDrivenTransactionManager()__				}_			}__			_			return bf.getBean(DEFAULT_TRANSACTION_MANAGER_NAME, PlatformTransactionManager.class)___		} catch (BeansException ex) {_			if (logger.isWarnEnabled()) {_				logger.warn("Caught exception while retrieving transaction manager for test context " + testContext, ex)__			}_			throw ex__		}_	};get,the,link,platform,transaction,manager,transaction,manager,to,use,for,the,supplied,link,test,context,test,context,param,test,context,the,test,context,for,which,the,transaction,manager,should,be,retrieved,return,the,transaction,manager,to,use,or,code,null,code,if,not,found,throws,beans,exception,if,an,error,occurs,while,retrieving,the,transaction,manager,see,get,transaction,manager,test,context,string;protected,final,platform,transaction,manager,get,transaction,manager,test,context,test,context,bean,factory,bf,test,context,get,application,context,get,autowire,capable,bean,factory,string,tm,name,retrieve,configuration,attributes,test,context,get,transaction,manager,name,try,if,string,utils,has,text,tm,name,equals,tm,name,return,bf,get,bean,tm,name,platform,transaction,manager,class,if,bf,instanceof,listable,bean,factory,listable,bean,factory,lbf,listable,bean,factory,bf,map,string,platform,transaction,manager,tx,mgrs,bean,factory,utils,beans,of,type,including,ancestors,lbf,platform,transaction,manager,class,if,tx,mgrs,size,1,return,tx,mgrs,values,iterator,next,map,string,transaction,management,configurer,configurers,bean,factory,utils,beans,of,type,including,ancestors,lbf,transaction,management,configurer,class,if,configurers,size,1,throw,new,illegal,state,exception,only,one,transaction,management,configurer,may,exist,in,the,application,context,if,configurers,size,1,return,configurers,values,iterator,next,annotation,driven,transaction,manager,return,bf,get,bean,platform,transaction,manager,class,catch,beans,exception,ex,if,logger,is,warn,enabled,logger,warn,caught,exception,while,retrieving,transaction,manager,for,test,context,test,context,ex,throw,ex
TransactionalTestExecutionListener -> protected final PlatformTransactionManager getTransactionManager(TestContext testContext);1356735495;Get the {@link PlatformTransactionManager transaction manager} to use_for the supplied {@link TestContext test context}._@param testContext the test context for which the transaction manager_should be retrieved_@return the transaction manager to use, or {@code null} if not found_@throws BeansException if an error occurs while retrieving the transaction manager_@see #getTransactionManager(TestContext, String);protected final PlatformTransactionManager getTransactionManager(TestContext testContext) {_		BeanFactory bf = testContext.getApplicationContext().getAutowireCapableBeanFactory()__		String tmName = retrieveConfigurationAttributes(testContext).getTransactionManagerName()___		try {_			_			if (StringUtils.hasText(tmName) && !DEFAULT_TRANSACTION_MANAGER_NAME.equals(tmName)) {_				return bf.getBean(tmName, PlatformTransactionManager.class)__			}__			if (bf instanceof ListableBeanFactory) {_				ListableBeanFactory lbf = (ListableBeanFactory) bf___				_				Map<String, PlatformTransactionManager> txMgrs = BeanFactoryUtils.beansOfTypeIncludingAncestors(_					lbf, PlatformTransactionManager.class)__				if (txMgrs.size() == 1) {_					return txMgrs.values().iterator().next()__				}__				_				Map<String, TransactionManagementConfigurer> configurers = BeanFactoryUtils.beansOfTypeIncludingAncestors(_					lbf, TransactionManagementConfigurer.class)__				if (configurers.size() > 1) {_					throw new IllegalStateException(_						"Only one TransactionManagementConfigurer may exist in the ApplicationContext")__				}_				if (configurers.size() == 1) {_					return configurers.values().iterator().next().annotationDrivenTransactionManager()__				}_			}__			_			return bf.getBean(DEFAULT_TRANSACTION_MANAGER_NAME, PlatformTransactionManager.class)___		} catch (BeansException ex) {_			if (logger.isWarnEnabled()) {_				logger.warn("Caught exception while retrieving transaction manager for test context " + testContext, ex)__			}_			throw ex__		}_	};get,the,link,platform,transaction,manager,transaction,manager,to,use,for,the,supplied,link,test,context,test,context,param,test,context,the,test,context,for,which,the,transaction,manager,should,be,retrieved,return,the,transaction,manager,to,use,or,code,null,if,not,found,throws,beans,exception,if,an,error,occurs,while,retrieving,the,transaction,manager,see,get,transaction,manager,test,context,string;protected,final,platform,transaction,manager,get,transaction,manager,test,context,test,context,bean,factory,bf,test,context,get,application,context,get,autowire,capable,bean,factory,string,tm,name,retrieve,configuration,attributes,test,context,get,transaction,manager,name,try,if,string,utils,has,text,tm,name,equals,tm,name,return,bf,get,bean,tm,name,platform,transaction,manager,class,if,bf,instanceof,listable,bean,factory,listable,bean,factory,lbf,listable,bean,factory,bf,map,string,platform,transaction,manager,tx,mgrs,bean,factory,utils,beans,of,type,including,ancestors,lbf,platform,transaction,manager,class,if,tx,mgrs,size,1,return,tx,mgrs,values,iterator,next,map,string,transaction,management,configurer,configurers,bean,factory,utils,beans,of,type,including,ancestors,lbf,transaction,management,configurer,class,if,configurers,size,1,throw,new,illegal,state,exception,only,one,transaction,management,configurer,may,exist,in,the,application,context,if,configurers,size,1,return,configurers,values,iterator,next,annotation,driven,transaction,manager,return,bf,get,bean,platform,transaction,manager,class,catch,beans,exception,ex,if,logger,is,warn,enabled,logger,warn,caught,exception,while,retrieving,transaction,manager,for,test,context,test,context,ex,throw,ex
TransactionalTestExecutionListener -> protected final PlatformTransactionManager getTransactionManager(TestContext testContext);1357119239;Get the {@link PlatformTransactionManager transaction manager} to use_for the supplied {@link TestContext test context}._@param testContext the test context for which the transaction manager_should be retrieved_@return the transaction manager to use, or {@code null} if not found_@throws BeansException if an error occurs while retrieving the transaction manager_@see #getTransactionManager(TestContext, String);protected final PlatformTransactionManager getTransactionManager(TestContext testContext) {_		BeanFactory bf = testContext.getApplicationContext().getAutowireCapableBeanFactory()__		String tmName = retrieveConfigurationAttributes(testContext).getTransactionManagerName()___		try {_			_			if (StringUtils.hasText(tmName) && !DEFAULT_TRANSACTION_MANAGER_NAME.equals(tmName)) {_				return bf.getBean(tmName, PlatformTransactionManager.class)__			}__			if (bf instanceof ListableBeanFactory) {_				ListableBeanFactory lbf = (ListableBeanFactory) bf___				_				Map<String, PlatformTransactionManager> txMgrs = BeanFactoryUtils.beansOfTypeIncludingAncestors(_					lbf, PlatformTransactionManager.class)__				if (txMgrs.size() == 1) {_					return txMgrs.values().iterator().next()__				}__				_				Map<String, TransactionManagementConfigurer> configurers = BeanFactoryUtils.beansOfTypeIncludingAncestors(_					lbf, TransactionManagementConfigurer.class)__				if (configurers.size() > 1) {_					throw new IllegalStateException(_						"Only one TransactionManagementConfigurer may exist in the ApplicationContext")__				}_				if (configurers.size() == 1) {_					return configurers.values().iterator().next().annotationDrivenTransactionManager()__				}_			}__			_			return bf.getBean(DEFAULT_TRANSACTION_MANAGER_NAME, PlatformTransactionManager.class)___		} catch (BeansException ex) {_			if (logger.isWarnEnabled()) {_				logger.warn("Caught exception while retrieving transaction manager for test context " + testContext, ex)__			}_			throw ex__		}_	};get,the,link,platform,transaction,manager,transaction,manager,to,use,for,the,supplied,link,test,context,test,context,param,test,context,the,test,context,for,which,the,transaction,manager,should,be,retrieved,return,the,transaction,manager,to,use,or,code,null,if,not,found,throws,beans,exception,if,an,error,occurs,while,retrieving,the,transaction,manager,see,get,transaction,manager,test,context,string;protected,final,platform,transaction,manager,get,transaction,manager,test,context,test,context,bean,factory,bf,test,context,get,application,context,get,autowire,capable,bean,factory,string,tm,name,retrieve,configuration,attributes,test,context,get,transaction,manager,name,try,if,string,utils,has,text,tm,name,equals,tm,name,return,bf,get,bean,tm,name,platform,transaction,manager,class,if,bf,instanceof,listable,bean,factory,listable,bean,factory,lbf,listable,bean,factory,bf,map,string,platform,transaction,manager,tx,mgrs,bean,factory,utils,beans,of,type,including,ancestors,lbf,platform,transaction,manager,class,if,tx,mgrs,size,1,return,tx,mgrs,values,iterator,next,map,string,transaction,management,configurer,configurers,bean,factory,utils,beans,of,type,including,ancestors,lbf,transaction,management,configurer,class,if,configurers,size,1,throw,new,illegal,state,exception,only,one,transaction,management,configurer,may,exist,in,the,application,context,if,configurers,size,1,return,configurers,values,iterator,next,annotation,driven,transaction,manager,return,bf,get,bean,platform,transaction,manager,class,catch,beans,exception,ex,if,logger,is,warn,enabled,logger,warn,caught,exception,while,retrieving,transaction,manager,for,test,context,test,context,ex,throw,ex
TransactionalTestExecutionListener -> protected final PlatformTransactionManager getTransactionManager(TestContext testContext);1367163114;Get the {@link PlatformTransactionManager transaction manager} to use_for the supplied {@link TestContext test context}._@param testContext the test context for which the transaction manager_should be retrieved_@return the transaction manager to use, or {@code null} if not found_@throws BeansException if an error occurs while retrieving the transaction manager_@see #getTransactionManager(TestContext, String);protected final PlatformTransactionManager getTransactionManager(TestContext testContext) {_		BeanFactory bf = testContext.getApplicationContext().getAutowireCapableBeanFactory()__		String tmName = retrieveConfigurationAttributes(testContext).getTransactionManagerName()___		try {_			_			if (StringUtils.hasText(tmName) && !DEFAULT_TRANSACTION_MANAGER_NAME.equals(tmName)) {_				return bf.getBean(tmName, PlatformTransactionManager.class)__			}__			if (bf instanceof ListableBeanFactory) {_				ListableBeanFactory lbf = (ListableBeanFactory) bf___				_				Map<String, PlatformTransactionManager> txMgrs = BeanFactoryUtils.beansOfTypeIncludingAncestors(_					lbf, PlatformTransactionManager.class)__				if (txMgrs.size() == 1) {_					return txMgrs.values().iterator().next()__				}__				_				Map<String, TransactionManagementConfigurer> configurers = BeanFactoryUtils.beansOfTypeIncludingAncestors(_					lbf, TransactionManagementConfigurer.class)__				if (configurers.size() > 1) {_					throw new IllegalStateException(_						"Only one TransactionManagementConfigurer may exist in the ApplicationContext")__				}_				if (configurers.size() == 1) {_					return configurers.values().iterator().next().annotationDrivenTransactionManager()__				}_			}__			_			return bf.getBean(DEFAULT_TRANSACTION_MANAGER_NAME, PlatformTransactionManager.class)___		} catch (BeansException ex) {_			if (logger.isWarnEnabled()) {_				logger.warn("Caught exception while retrieving transaction manager for test context " + testContext, ex)__			}_			throw ex__		}_	};get,the,link,platform,transaction,manager,transaction,manager,to,use,for,the,supplied,link,test,context,test,context,param,test,context,the,test,context,for,which,the,transaction,manager,should,be,retrieved,return,the,transaction,manager,to,use,or,code,null,if,not,found,throws,beans,exception,if,an,error,occurs,while,retrieving,the,transaction,manager,see,get,transaction,manager,test,context,string;protected,final,platform,transaction,manager,get,transaction,manager,test,context,test,context,bean,factory,bf,test,context,get,application,context,get,autowire,capable,bean,factory,string,tm,name,retrieve,configuration,attributes,test,context,get,transaction,manager,name,try,if,string,utils,has,text,tm,name,equals,tm,name,return,bf,get,bean,tm,name,platform,transaction,manager,class,if,bf,instanceof,listable,bean,factory,listable,bean,factory,lbf,listable,bean,factory,bf,map,string,platform,transaction,manager,tx,mgrs,bean,factory,utils,beans,of,type,including,ancestors,lbf,platform,transaction,manager,class,if,tx,mgrs,size,1,return,tx,mgrs,values,iterator,next,map,string,transaction,management,configurer,configurers,bean,factory,utils,beans,of,type,including,ancestors,lbf,transaction,management,configurer,class,if,configurers,size,1,throw,new,illegal,state,exception,only,one,transaction,management,configurer,may,exist,in,the,application,context,if,configurers,size,1,return,configurers,values,iterator,next,annotation,driven,transaction,manager,return,bf,get,bean,platform,transaction,manager,class,catch,beans,exception,ex,if,logger,is,warn,enabled,logger,warn,caught,exception,while,retrieving,transaction,manager,for,test,context,test,context,ex,throw,ex
TransactionalTestExecutionListener -> protected final PlatformTransactionManager getTransactionManager(TestContext testContext);1367873075;Get the {@link PlatformTransactionManager transaction manager} to use_for the supplied {@link TestContext test context}._@param testContext the test context for which the transaction manager_should be retrieved_@return the transaction manager to use, or {@code null} if not found_@throws BeansException if an error occurs while retrieving the transaction manager_@see #getTransactionManager(TestContext, String);protected final PlatformTransactionManager getTransactionManager(TestContext testContext) {_		BeanFactory bf = testContext.getApplicationContext().getAutowireCapableBeanFactory()__		String tmName = retrieveConfigurationAttributes(testContext).getTransactionManagerName()___		try {_			_			if (StringUtils.hasText(tmName) && !DEFAULT_TRANSACTION_MANAGER_NAME.equals(tmName)) {_				return bf.getBean(tmName, PlatformTransactionManager.class)__			}__			if (bf instanceof ListableBeanFactory) {_				ListableBeanFactory lbf = (ListableBeanFactory) bf___				_				Map<String, PlatformTransactionManager> txMgrs = BeanFactoryUtils.beansOfTypeIncludingAncestors(_					lbf, PlatformTransactionManager.class)__				if (txMgrs.size() == 1) {_					return txMgrs.values().iterator().next()__				}__				_				Map<String, TransactionManagementConfigurer> configurers = BeanFactoryUtils.beansOfTypeIncludingAncestors(_					lbf, TransactionManagementConfigurer.class)__				if (configurers.size() > 1) {_					throw new IllegalStateException(_						"Only one TransactionManagementConfigurer may exist in the ApplicationContext")__				}_				if (configurers.size() == 1) {_					return configurers.values().iterator().next().annotationDrivenTransactionManager()__				}_			}__			_			return bf.getBean(DEFAULT_TRANSACTION_MANAGER_NAME, PlatformTransactionManager.class)___		} catch (BeansException ex) {_			if (logger.isWarnEnabled()) {_				logger.warn("Caught exception while retrieving transaction manager for test context " + testContext, ex)__			}_			throw ex__		}_	};get,the,link,platform,transaction,manager,transaction,manager,to,use,for,the,supplied,link,test,context,test,context,param,test,context,the,test,context,for,which,the,transaction,manager,should,be,retrieved,return,the,transaction,manager,to,use,or,code,null,if,not,found,throws,beans,exception,if,an,error,occurs,while,retrieving,the,transaction,manager,see,get,transaction,manager,test,context,string;protected,final,platform,transaction,manager,get,transaction,manager,test,context,test,context,bean,factory,bf,test,context,get,application,context,get,autowire,capable,bean,factory,string,tm,name,retrieve,configuration,attributes,test,context,get,transaction,manager,name,try,if,string,utils,has,text,tm,name,equals,tm,name,return,bf,get,bean,tm,name,platform,transaction,manager,class,if,bf,instanceof,listable,bean,factory,listable,bean,factory,lbf,listable,bean,factory,bf,map,string,platform,transaction,manager,tx,mgrs,bean,factory,utils,beans,of,type,including,ancestors,lbf,platform,transaction,manager,class,if,tx,mgrs,size,1,return,tx,mgrs,values,iterator,next,map,string,transaction,management,configurer,configurers,bean,factory,utils,beans,of,type,including,ancestors,lbf,transaction,management,configurer,class,if,configurers,size,1,throw,new,illegal,state,exception,only,one,transaction,management,configurer,may,exist,in,the,application,context,if,configurers,size,1,return,configurers,values,iterator,next,annotation,driven,transaction,manager,return,bf,get,bean,platform,transaction,manager,class,catch,beans,exception,ex,if,logger,is,warn,enabled,logger,warn,caught,exception,while,retrieving,transaction,manager,for,test,context,test,context,ex,throw,ex
TransactionalTestExecutionListener -> protected final PlatformTransactionManager getTransactionManager(TestContext testContext);1368482696;Get the {@link PlatformTransactionManager transaction manager} to use_for the supplied {@link TestContext test context}._@param testContext the test context for which the transaction manager_should be retrieved_@return the transaction manager to use, or {@code null} if not found_@throws BeansException if an error occurs while retrieving the transaction manager_@see #getTransactionManager(TestContext, String);protected final PlatformTransactionManager getTransactionManager(TestContext testContext) {_		BeanFactory bf = testContext.getApplicationContext().getAutowireCapableBeanFactory()__		String tmName = retrieveConfigurationAttributes(testContext).getTransactionManagerName()___		try {_			_			if (StringUtils.hasText(tmName) && !DEFAULT_TRANSACTION_MANAGER_NAME.equals(tmName)) {_				return bf.getBean(tmName, PlatformTransactionManager.class)__			}__			if (bf instanceof ListableBeanFactory) {_				ListableBeanFactory lbf = (ListableBeanFactory) bf___				_				Map<String, PlatformTransactionManager> txMgrs = BeanFactoryUtils.beansOfTypeIncludingAncestors(_					lbf, PlatformTransactionManager.class)__				if (txMgrs.size() == 1) {_					return txMgrs.values().iterator().next()__				}__				_				Map<String, TransactionManagementConfigurer> configurers = BeanFactoryUtils.beansOfTypeIncludingAncestors(_					lbf, TransactionManagementConfigurer.class)__				if (configurers.size() > 1) {_					throw new IllegalStateException(_						"Only one TransactionManagementConfigurer may exist in the ApplicationContext")__				}_				if (configurers.size() == 1) {_					return configurers.values().iterator().next().annotationDrivenTransactionManager()__				}_			}__			_			return bf.getBean(DEFAULT_TRANSACTION_MANAGER_NAME, PlatformTransactionManager.class)___		} catch (BeansException ex) {_			if (logger.isWarnEnabled()) {_				logger.warn("Caught exception while retrieving transaction manager for test context " + testContext, ex)__			}_			throw ex__		}_	};get,the,link,platform,transaction,manager,transaction,manager,to,use,for,the,supplied,link,test,context,test,context,param,test,context,the,test,context,for,which,the,transaction,manager,should,be,retrieved,return,the,transaction,manager,to,use,or,code,null,if,not,found,throws,beans,exception,if,an,error,occurs,while,retrieving,the,transaction,manager,see,get,transaction,manager,test,context,string;protected,final,platform,transaction,manager,get,transaction,manager,test,context,test,context,bean,factory,bf,test,context,get,application,context,get,autowire,capable,bean,factory,string,tm,name,retrieve,configuration,attributes,test,context,get,transaction,manager,name,try,if,string,utils,has,text,tm,name,equals,tm,name,return,bf,get,bean,tm,name,platform,transaction,manager,class,if,bf,instanceof,listable,bean,factory,listable,bean,factory,lbf,listable,bean,factory,bf,map,string,platform,transaction,manager,tx,mgrs,bean,factory,utils,beans,of,type,including,ancestors,lbf,platform,transaction,manager,class,if,tx,mgrs,size,1,return,tx,mgrs,values,iterator,next,map,string,transaction,management,configurer,configurers,bean,factory,utils,beans,of,type,including,ancestors,lbf,transaction,management,configurer,class,if,configurers,size,1,throw,new,illegal,state,exception,only,one,transaction,management,configurer,may,exist,in,the,application,context,if,configurers,size,1,return,configurers,values,iterator,next,annotation,driven,transaction,manager,return,bf,get,bean,platform,transaction,manager,class,catch,beans,exception,ex,if,logger,is,warn,enabled,logger,warn,caught,exception,while,retrieving,transaction,manager,for,test,context,test,context,ex,throw,ex
TransactionalTestExecutionListener -> private List<Class<?>> getSuperClasses(Class<?> clazz);1328020251;Gets all superclasses of the supplied {@link Class class}, including the_class itself. The ordering of the returned list will begin with the_supplied class and continue up the class hierarchy._<p>Note: This code has been borrowed from_{@link org.junit.internal.runners.TestClass#getSuperClasses(Class)} and_adapted._@param clazz the class for which to retrieve the superclasses._@return all superclasses of the supplied class.;private List<Class<?>> getSuperClasses(Class<?> clazz) {_		ArrayList<Class<?>> results = new ArrayList<Class<?>>()__		Class<?> current = clazz__		while (current != null) {_			results.add(current)__			current = current.getSuperclass()__		}_		return results__	};gets,all,superclasses,of,the,supplied,link,class,class,including,the,class,itself,the,ordering,of,the,returned,list,will,begin,with,the,supplied,class,and,continue,up,the,class,hierarchy,p,note,this,code,has,been,borrowed,from,link,org,junit,internal,runners,test,class,get,super,classes,class,and,adapted,param,clazz,the,class,for,which,to,retrieve,the,superclasses,return,all,superclasses,of,the,supplied,class;private,list,class,get,super,classes,class,clazz,array,list,class,results,new,array,list,class,class,current,clazz,while,current,null,results,add,current,current,current,get,superclass,return,results
TransactionalTestExecutionListener -> private List<Class<?>> getSuperClasses(Class<?> clazz);1337516454;Gets all superclasses of the supplied {@link Class class}, including the_class itself. The ordering of the returned list will begin with the_supplied class and continue up the class hierarchy._<p>Note: This code has been borrowed from_{@link org.junit.internal.runners.TestClass#getSuperClasses(Class)} and_adapted._@param clazz the class for which to retrieve the superclasses._@return all superclasses of the supplied class.;private List<Class<?>> getSuperClasses(Class<?> clazz) {_		ArrayList<Class<?>> results = new ArrayList<Class<?>>()__		Class<?> current = clazz__		while (current != null) {_			results.add(current)__			current = current.getSuperclass()__		}_		return results__	};gets,all,superclasses,of,the,supplied,link,class,class,including,the,class,itself,the,ordering,of,the,returned,list,will,begin,with,the,supplied,class,and,continue,up,the,class,hierarchy,p,note,this,code,has,been,borrowed,from,link,org,junit,internal,runners,test,class,get,super,classes,class,and,adapted,param,clazz,the,class,for,which,to,retrieve,the,superclasses,return,all,superclasses,of,the,supplied,class;private,list,class,get,super,classes,class,clazz,array,list,class,results,new,array,list,class,class,current,clazz,while,current,null,results,add,current,current,current,get,superclass,return,results
TransactionalTestExecutionListener -> private List<Class<?>> getSuperClasses(Class<?> clazz);1338031377;Gets all superclasses of the supplied {@link Class class}, including the_class itself. The ordering of the returned list will begin with the_supplied class and continue up the class hierarchy._<p>Note: This code has been borrowed from_{@link org.junit.internal.runners.TestClass#getSuperClasses(Class)} and_adapted._@param clazz the class for which to retrieve the superclasses._@return all superclasses of the supplied class.;private List<Class<?>> getSuperClasses(Class<?> clazz) {_		ArrayList<Class<?>> results = new ArrayList<Class<?>>()__		Class<?> current = clazz__		while (current != null) {_			results.add(current)__			current = current.getSuperclass()__		}_		return results__	};gets,all,superclasses,of,the,supplied,link,class,class,including,the,class,itself,the,ordering,of,the,returned,list,will,begin,with,the,supplied,class,and,continue,up,the,class,hierarchy,p,note,this,code,has,been,borrowed,from,link,org,junit,internal,runners,test,class,get,super,classes,class,and,adapted,param,clazz,the,class,for,which,to,retrieve,the,superclasses,return,all,superclasses,of,the,supplied,class;private,list,class,get,super,classes,class,clazz,array,list,class,results,new,array,list,class,class,current,clazz,while,current,null,results,add,current,current,current,get,superclass,return,results
TransactionalTestExecutionListener -> private List<Class<?>> getSuperClasses(Class<?> clazz);1343426806;Gets all superclasses of the supplied {@link Class class}, including the_class itself. The ordering of the returned list will begin with the_supplied class and continue up the class hierarchy._<p>Note: This code has been borrowed from_{@link org.junit.internal.runners.TestClass#getSuperClasses(Class)} and_adapted._@param clazz the class for which to retrieve the superclasses._@return all superclasses of the supplied class.;private List<Class<?>> getSuperClasses(Class<?> clazz) {_		ArrayList<Class<?>> results = new ArrayList<Class<?>>()__		Class<?> current = clazz__		while (current != null) {_			results.add(current)__			current = current.getSuperclass()__		}_		return results__	};gets,all,superclasses,of,the,supplied,link,class,class,including,the,class,itself,the,ordering,of,the,returned,list,will,begin,with,the,supplied,class,and,continue,up,the,class,hierarchy,p,note,this,code,has,been,borrowed,from,link,org,junit,internal,runners,test,class,get,super,classes,class,and,adapted,param,clazz,the,class,for,which,to,retrieve,the,superclasses,return,all,superclasses,of,the,supplied,class;private,list,class,get,super,classes,class,clazz,array,list,class,results,new,array,list,class,class,current,clazz,while,current,null,results,add,current,current,current,get,superclass,return,results
TransactionalTestExecutionListener -> private List<Class<?>> getSuperClasses(Class<?> clazz);1343431472;Gets all superclasses of the supplied {@link Class class}, including the_class itself. The ordering of the returned list will begin with the_supplied class and continue up the class hierarchy._<p>Note: This code has been borrowed from_{@link org.junit.internal.runners.TestClass#getSuperClasses(Class)} and_adapted._@param clazz the class for which to retrieve the superclasses._@return all superclasses of the supplied class.;private List<Class<?>> getSuperClasses(Class<?> clazz) {_		ArrayList<Class<?>> results = new ArrayList<Class<?>>()__		Class<?> current = clazz__		while (current != null) {_			results.add(current)__			current = current.getSuperclass()__		}_		return results__	};gets,all,superclasses,of,the,supplied,link,class,class,including,the,class,itself,the,ordering,of,the,returned,list,will,begin,with,the,supplied,class,and,continue,up,the,class,hierarchy,p,note,this,code,has,been,borrowed,from,link,org,junit,internal,runners,test,class,get,super,classes,class,and,adapted,param,clazz,the,class,for,which,to,retrieve,the,superclasses,return,all,superclasses,of,the,supplied,class;private,list,class,get,super,classes,class,clazz,array,list,class,results,new,array,list,class,class,current,clazz,while,current,null,results,add,current,current,current,get,superclass,return,results
TransactionalTestExecutionListener -> private List<Class<?>> getSuperClasses(Class<?> clazz);1354571539;Gets all superclasses of the supplied {@link Class class}, including the_class itself. The ordering of the returned list will begin with the_supplied class and continue up the class hierarchy._<p>Note: This code has been borrowed from_{@link org.junit.internal.runners.TestClass#getSuperClasses(Class)} and_adapted._@param clazz the class for which to retrieve the superclasses._@return all superclasses of the supplied class.;private List<Class<?>> getSuperClasses(Class<?> clazz) {_		ArrayList<Class<?>> results = new ArrayList<Class<?>>()__		Class<?> current = clazz__		while (current != null) {_			results.add(current)__			current = current.getSuperclass()__		}_		return results__	};gets,all,superclasses,of,the,supplied,link,class,class,including,the,class,itself,the,ordering,of,the,returned,list,will,begin,with,the,supplied,class,and,continue,up,the,class,hierarchy,p,note,this,code,has,been,borrowed,from,link,org,junit,internal,runners,test,class,get,super,classes,class,and,adapted,param,clazz,the,class,for,which,to,retrieve,the,superclasses,return,all,superclasses,of,the,supplied,class;private,list,class,get,super,classes,class,clazz,array,list,class,results,new,array,list,class,class,current,clazz,while,current,null,results,add,current,current,current,get,superclass,return,results
TransactionalTestExecutionListener -> private List<Class<?>> getSuperClasses(Class<?> clazz);1355352386;Gets all superclasses of the supplied {@link Class class}, including the_class itself. The ordering of the returned list will begin with the_supplied class and continue up the class hierarchy._<p>Note: This code has been borrowed from_{@link org.junit.internal.runners.TestClass#getSuperClasses(Class)} and_adapted._@param clazz the class for which to retrieve the superclasses._@return all superclasses of the supplied class.;private List<Class<?>> getSuperClasses(Class<?> clazz) {_		ArrayList<Class<?>> results = new ArrayList<Class<?>>()__		Class<?> current = clazz__		while (current != null) {_			results.add(current)__			current = current.getSuperclass()__		}_		return results__	};gets,all,superclasses,of,the,supplied,link,class,class,including,the,class,itself,the,ordering,of,the,returned,list,will,begin,with,the,supplied,class,and,continue,up,the,class,hierarchy,p,note,this,code,has,been,borrowed,from,link,org,junit,internal,runners,test,class,get,super,classes,class,and,adapted,param,clazz,the,class,for,which,to,retrieve,the,superclasses,return,all,superclasses,of,the,supplied,class;private,list,class,get,super,classes,class,clazz,array,list,class,results,new,array,list,class,class,current,clazz,while,current,null,results,add,current,current,current,get,superclass,return,results
TransactionalTestExecutionListener -> private List<Class<?>> getSuperClasses(Class<?> clazz);1356735495;Gets all superclasses of the supplied {@link Class class}, including the_class itself. The ordering of the returned list will begin with the_supplied class and continue up the class hierarchy._<p>Note: This code has been borrowed from_{@link org.junit.internal.runners.TestClass#getSuperClasses(Class)} and_adapted._@param clazz the class for which to retrieve the superclasses._@return all superclasses of the supplied class.;private List<Class<?>> getSuperClasses(Class<?> clazz) {_		ArrayList<Class<?>> results = new ArrayList<Class<?>>()__		Class<?> current = clazz__		while (current != null) {_			results.add(current)__			current = current.getSuperclass()__		}_		return results__	};gets,all,superclasses,of,the,supplied,link,class,class,including,the,class,itself,the,ordering,of,the,returned,list,will,begin,with,the,supplied,class,and,continue,up,the,class,hierarchy,p,note,this,code,has,been,borrowed,from,link,org,junit,internal,runners,test,class,get,super,classes,class,and,adapted,param,clazz,the,class,for,which,to,retrieve,the,superclasses,return,all,superclasses,of,the,supplied,class;private,list,class,get,super,classes,class,clazz,array,list,class,results,new,array,list,class,class,current,clazz,while,current,null,results,add,current,current,current,get,superclass,return,results
TransactionalTestExecutionListener -> private List<Class<?>> getSuperClasses(Class<?> clazz);1357119239;Gets all superclasses of the supplied {@link Class class}, including the_class itself. The ordering of the returned list will begin with the_supplied class and continue up the class hierarchy._<p>Note: This code has been borrowed from_{@link org.junit.internal.runners.TestClass#getSuperClasses(Class)} and_adapted._@param clazz the class for which to retrieve the superclasses._@return all superclasses of the supplied class.;private List<Class<?>> getSuperClasses(Class<?> clazz) {_		ArrayList<Class<?>> results = new ArrayList<Class<?>>()__		Class<?> current = clazz__		while (current != null) {_			results.add(current)__			current = current.getSuperclass()__		}_		return results__	};gets,all,superclasses,of,the,supplied,link,class,class,including,the,class,itself,the,ordering,of,the,returned,list,will,begin,with,the,supplied,class,and,continue,up,the,class,hierarchy,p,note,this,code,has,been,borrowed,from,link,org,junit,internal,runners,test,class,get,super,classes,class,and,adapted,param,clazz,the,class,for,which,to,retrieve,the,superclasses,return,all,superclasses,of,the,supplied,class;private,list,class,get,super,classes,class,clazz,array,list,class,results,new,array,list,class,class,current,clazz,while,current,null,results,add,current,current,current,get,superclass,return,results
TransactionalTestExecutionListener -> private List<Class<?>> getSuperClasses(Class<?> clazz);1367163114;Gets all superclasses of the supplied {@link Class class}, including the_class itself. The ordering of the returned list will begin with the_supplied class and continue up the class hierarchy._<p>Note: This code has been borrowed from_{@link org.junit.internal.runners.TestClass#getSuperClasses(Class)} and_adapted._@param clazz the class for which to retrieve the superclasses._@return all superclasses of the supplied class.;private List<Class<?>> getSuperClasses(Class<?> clazz) {_		ArrayList<Class<?>> results = new ArrayList<Class<?>>()__		Class<?> current = clazz__		while (current != null) {_			results.add(current)__			current = current.getSuperclass()__		}_		return results__	};gets,all,superclasses,of,the,supplied,link,class,class,including,the,class,itself,the,ordering,of,the,returned,list,will,begin,with,the,supplied,class,and,continue,up,the,class,hierarchy,p,note,this,code,has,been,borrowed,from,link,org,junit,internal,runners,test,class,get,super,classes,class,and,adapted,param,clazz,the,class,for,which,to,retrieve,the,superclasses,return,all,superclasses,of,the,supplied,class;private,list,class,get,super,classes,class,clazz,array,list,class,results,new,array,list,class,class,current,clazz,while,current,null,results,add,current,current,current,get,superclass,return,results
TransactionalTestExecutionListener -> private List<Class<?>> getSuperClasses(Class<?> clazz);1367873075;Gets all superclasses of the supplied {@link Class class}, including the_class itself. The ordering of the returned list will begin with the_supplied class and continue up the class hierarchy._<p>Note: This code has been borrowed from_{@link org.junit.internal.runners.TestClass#getSuperClasses(Class)} and_adapted._@param clazz the class for which to retrieve the superclasses._@return all superclasses of the supplied class.;private List<Class<?>> getSuperClasses(Class<?> clazz) {_		ArrayList<Class<?>> results = new ArrayList<Class<?>>()__		Class<?> current = clazz__		while (current != null) {_			results.add(current)__			current = current.getSuperclass()__		}_		return results__	};gets,all,superclasses,of,the,supplied,link,class,class,including,the,class,itself,the,ordering,of,the,returned,list,will,begin,with,the,supplied,class,and,continue,up,the,class,hierarchy,p,note,this,code,has,been,borrowed,from,link,org,junit,internal,runners,test,class,get,super,classes,class,and,adapted,param,clazz,the,class,for,which,to,retrieve,the,superclasses,return,all,superclasses,of,the,supplied,class;private,list,class,get,super,classes,class,clazz,array,list,class,results,new,array,list,class,class,current,clazz,while,current,null,results,add,current,current,current,get,superclass,return,results
TransactionalTestExecutionListener -> private List<Class<?>> getSuperClasses(Class<?> clazz);1368482696;Gets all superclasses of the supplied {@link Class class}, including the_class itself. The ordering of the returned list will begin with the_supplied class and continue up the class hierarchy._<p>Note: This code has been borrowed from_{@link org.junit.internal.runners.TestClass#getSuperClasses(Class)} and_adapted._@param clazz the class for which to retrieve the superclasses._@return all superclasses of the supplied class.;private List<Class<?>> getSuperClasses(Class<?> clazz) {_		ArrayList<Class<?>> results = new ArrayList<Class<?>>()__		Class<?> current = clazz__		while (current != null) {_			results.add(current)__			current = current.getSuperclass()__		}_		return results__	};gets,all,superclasses,of,the,supplied,link,class,class,including,the,class,itself,the,ordering,of,the,returned,list,will,begin,with,the,supplied,class,and,continue,up,the,class,hierarchy,p,note,this,code,has,been,borrowed,from,link,org,junit,internal,runners,test,class,get,super,classes,class,and,adapted,param,clazz,the,class,for,which,to,retrieve,the,superclasses,return,all,superclasses,of,the,supplied,class;private,list,class,get,super,classes,class,clazz,array,list,class,results,new,array,list,class,class,current,clazz,while,current,null,results,add,current,current,current,get,superclass,return,results
TransactionalTestExecutionListener -> private List<Class<?>> getSuperClasses(Class<?> clazz);1382920864;Gets all superclasses of the supplied {@link Class class}, including the_class itself. The ordering of the returned list will begin with the_supplied class and continue up the class hierarchy, excluding {@link Object}._<p>Note: This code has been borrowed from_{@link org.junit.internal.runners.TestClass#getSuperClasses(Class)} and_adapted._@param clazz the class for which to retrieve the superclasses_@return all superclasses of the supplied class, excluding {@code Object};private List<Class<?>> getSuperClasses(Class<?> clazz) {_		List<Class<?>> results = new ArrayList<Class<?>>()__		Class<?> current = clazz__		while (current != null && !current.equals(Object.class)) {_			results.add(current)__			current = current.getSuperclass()__		}_		return results__	};gets,all,superclasses,of,the,supplied,link,class,class,including,the,class,itself,the,ordering,of,the,returned,list,will,begin,with,the,supplied,class,and,continue,up,the,class,hierarchy,excluding,link,object,p,note,this,code,has,been,borrowed,from,link,org,junit,internal,runners,test,class,get,super,classes,class,and,adapted,param,clazz,the,class,for,which,to,retrieve,the,superclasses,return,all,superclasses,of,the,supplied,class,excluding,code,object;private,list,class,get,super,classes,class,clazz,list,class,results,new,array,list,class,class,current,clazz,while,current,null,current,equals,object,class,results,add,current,current,current,get,superclass,return,results
TransactionalTestExecutionListener -> private List<Class<?>> getSuperClasses(Class<?> clazz);1385499540;Gets all superclasses of the supplied {@link Class class}, including the_class itself. The ordering of the returned list will begin with the_supplied class and continue up the class hierarchy, excluding {@link Object}._<p>Note: This code has been borrowed from_{@link org.junit.internal.runners.TestClass#getSuperClasses(Class)} and_adapted._@param clazz the class for which to retrieve the superclasses_@return all superclasses of the supplied class, excluding {@code Object};private List<Class<?>> getSuperClasses(Class<?> clazz) {_		List<Class<?>> results = new ArrayList<Class<?>>()__		Class<?> current = clazz__		while (current != null && !current.equals(Object.class)) {_			results.add(current)__			current = current.getSuperclass()__		}_		return results__	};gets,all,superclasses,of,the,supplied,link,class,class,including,the,class,itself,the,ordering,of,the,returned,list,will,begin,with,the,supplied,class,and,continue,up,the,class,hierarchy,excluding,link,object,p,note,this,code,has,been,borrowed,from,link,org,junit,internal,runners,test,class,get,super,classes,class,and,adapted,param,clazz,the,class,for,which,to,retrieve,the,superclasses,return,all,superclasses,of,the,supplied,class,excluding,code,object;private,list,class,get,super,classes,class,clazz,list,class,results,new,array,list,class,class,current,clazz,while,current,null,current,equals,object,class,results,add,current,current,current,get,superclass,return,results
TransactionalTestExecutionListener -> private List<Class<?>> getSuperClasses(Class<?> clazz);1389966876;Gets all superclasses of the supplied {@link Class class}, including the_class itself. The ordering of the returned list will begin with the_supplied class and continue up the class hierarchy, excluding {@link Object}._<p>Note: This code has been borrowed from_{@link org.junit.internal.runners.TestClass#getSuperClasses(Class)} and_adapted._@param clazz the class for which to retrieve the superclasses_@return all superclasses of the supplied class, excluding {@code Object};private List<Class<?>> getSuperClasses(Class<?> clazz) {_		List<Class<?>> results = new ArrayList<Class<?>>()__		Class<?> current = clazz__		while (current != null && !current.equals(Object.class)) {_			results.add(current)__			current = current.getSuperclass()__		}_		return results__	};gets,all,superclasses,of,the,supplied,link,class,class,including,the,class,itself,the,ordering,of,the,returned,list,will,begin,with,the,supplied,class,and,continue,up,the,class,hierarchy,excluding,link,object,p,note,this,code,has,been,borrowed,from,link,org,junit,internal,runners,test,class,get,super,classes,class,and,adapted,param,clazz,the,class,for,which,to,retrieve,the,superclasses,return,all,superclasses,of,the,supplied,class,excluding,code,object;private,list,class,get,super,classes,class,clazz,list,class,results,new,array,list,class,class,current,clazz,while,current,null,current,equals,object,class,results,add,current,current,current,get,superclass,return,results
TransactionalTestExecutionListener -> private List<Class<?>> getSuperClasses(Class<?> clazz);1401991965;Gets all superclasses of the supplied {@link Class class}, including the_class itself. The ordering of the returned list will begin with the_supplied class and continue up the class hierarchy, excluding {@link Object}._<p>Note: This code has been borrowed from_{@link org.junit.internal.runners.TestClass#getSuperClasses(Class)} and_adapted._@param clazz the class for which to retrieve the superclasses_@return all superclasses of the supplied class, excluding {@code Object};private List<Class<?>> getSuperClasses(Class<?> clazz) {_		List<Class<?>> results = new ArrayList<Class<?>>()__		Class<?> current = clazz__		while (current != null && !current.equals(Object.class)) {_			results.add(current)__			current = current.getSuperclass()__		}_		return results__	};gets,all,superclasses,of,the,supplied,link,class,class,including,the,class,itself,the,ordering,of,the,returned,list,will,begin,with,the,supplied,class,and,continue,up,the,class,hierarchy,excluding,link,object,p,note,this,code,has,been,borrowed,from,link,org,junit,internal,runners,test,class,get,super,classes,class,and,adapted,param,clazz,the,class,for,which,to,retrieve,the,superclasses,return,all,superclasses,of,the,supplied,class,excluding,code,object;private,list,class,get,super,classes,class,clazz,list,class,results,new,array,list,class,class,current,clazz,while,current,null,current,equals,object,class,results,add,current,current,current,get,superclass,return,results
TransactionalTestExecutionListener -> private List<Class<?>> getSuperClasses(Class<?> clazz);1404334604;Gets all superclasses of the supplied {@link Class class}, including the_class itself. The ordering of the returned list will begin with the_supplied class and continue up the class hierarchy, excluding {@link Object}._<p>Note: This code has been borrowed from_{@link org.junit.internal.runners.TestClass#getSuperClasses(Class)} and_adapted._@param clazz the class for which to retrieve the superclasses_@return all superclasses of the supplied class, excluding {@code Object};private List<Class<?>> getSuperClasses(Class<?> clazz) {_		List<Class<?>> results = new ArrayList<Class<?>>()__		Class<?> current = clazz__		while (current != null && !current.equals(Object.class)) {_			results.add(current)__			current = current.getSuperclass()__		}_		return results__	};gets,all,superclasses,of,the,supplied,link,class,class,including,the,class,itself,the,ordering,of,the,returned,list,will,begin,with,the,supplied,class,and,continue,up,the,class,hierarchy,excluding,link,object,p,note,this,code,has,been,borrowed,from,link,org,junit,internal,runners,test,class,get,super,classes,class,and,adapted,param,clazz,the,class,for,which,to,retrieve,the,superclasses,return,all,superclasses,of,the,supplied,class,excluding,code,object;private,list,class,get,super,classes,class,clazz,list,class,results,new,array,list,class,class,current,clazz,while,current,null,current,equals,object,class,results,add,current,current,current,get,superclass,return,results
TransactionalTestExecutionListener -> private List<Class<?>> getSuperClasses(Class<?> clazz);1405645143;Gets all superclasses of the supplied {@link Class class}, including the_class itself. The ordering of the returned list will begin with the_supplied class and continue up the class hierarchy, excluding {@link Object}._<p>Note: This code has been borrowed from_{@link org.junit.internal.runners.TestClass#getSuperClasses(Class)} and_adapted._@param clazz the class for which to retrieve the superclasses_@return all superclasses of the supplied class, excluding {@code Object};private List<Class<?>> getSuperClasses(Class<?> clazz) {_		List<Class<?>> results = new ArrayList<Class<?>>()__		Class<?> current = clazz__		while (current != null && !current.equals(Object.class)) {_			results.add(current)__			current = current.getSuperclass()__		}_		return results__	};gets,all,superclasses,of,the,supplied,link,class,class,including,the,class,itself,the,ordering,of,the,returned,list,will,begin,with,the,supplied,class,and,continue,up,the,class,hierarchy,excluding,link,object,p,note,this,code,has,been,borrowed,from,link,org,junit,internal,runners,test,class,get,super,classes,class,and,adapted,param,clazz,the,class,for,which,to,retrieve,the,superclasses,return,all,superclasses,of,the,supplied,class,excluding,code,object;private,list,class,get,super,classes,class,clazz,list,class,results,new,array,list,class,class,current,clazz,while,current,null,current,equals,object,class,results,add,current,current,current,get,superclass,return,results
TransactionalTestExecutionListener -> private List<Class<?>> getSuperClasses(Class<?> clazz);1405698612;Gets all superclasses of the supplied {@link Class class}, including the_class itself. The ordering of the returned list will begin with the_supplied class and continue up the class hierarchy, excluding {@link Object}._<p>Note: This code has been borrowed from_{@link org.junit.internal.runners.TestClass#getSuperClasses(Class)} and_adapted._@param clazz the class for which to retrieve the superclasses_@return all superclasses of the supplied class, excluding {@code Object};private List<Class<?>> getSuperClasses(Class<?> clazz) {_		List<Class<?>> results = new ArrayList<Class<?>>()__		Class<?> current = clazz__		while (current != null && !current.equals(Object.class)) {_			results.add(current)__			current = current.getSuperclass()__		}_		return results__	};gets,all,superclasses,of,the,supplied,link,class,class,including,the,class,itself,the,ordering,of,the,returned,list,will,begin,with,the,supplied,class,and,continue,up,the,class,hierarchy,excluding,link,object,p,note,this,code,has,been,borrowed,from,link,org,junit,internal,runners,test,class,get,super,classes,class,and,adapted,param,clazz,the,class,for,which,to,retrieve,the,superclasses,return,all,superclasses,of,the,supplied,class,excluding,code,object;private,list,class,get,super,classes,class,clazz,list,class,results,new,array,list,class,class,current,clazz,while,current,null,current,equals,object,class,results,add,current,current,current,get,superclass,return,results
TransactionalTestExecutionListener -> private List<Class<?>> getSuperClasses(Class<?> clazz);1405759527;Gets all superclasses of the supplied {@link Class class}, including the_class itself. The ordering of the returned list will begin with the_supplied class and continue up the class hierarchy, excluding {@link Object}._<p>Note: This code has been borrowed from_{@link org.junit.internal.runners.TestClass#getSuperClasses(Class)} and_adapted._@param clazz the class for which to retrieve the superclasses_@return all superclasses of the supplied class, excluding {@code Object};private List<Class<?>> getSuperClasses(Class<?> clazz) {_		List<Class<?>> results = new ArrayList<Class<?>>()__		Class<?> current = clazz__		while (current != null && !current.equals(Object.class)) {_			results.add(current)__			current = current.getSuperclass()__		}_		return results__	};gets,all,superclasses,of,the,supplied,link,class,class,including,the,class,itself,the,ordering,of,the,returned,list,will,begin,with,the,supplied,class,and,continue,up,the,class,hierarchy,excluding,link,object,p,note,this,code,has,been,borrowed,from,link,org,junit,internal,runners,test,class,get,super,classes,class,and,adapted,param,clazz,the,class,for,which,to,retrieve,the,superclasses,return,all,superclasses,of,the,supplied,class,excluding,code,object;private,list,class,get,super,classes,class,clazz,list,class,results,new,array,list,class,class,current,clazz,while,current,null,current,equals,object,class,results,add,current,current,current,get,superclass,return,results
TransactionalTestExecutionListener -> private List<Class<?>> getSuperClasses(Class<?> clazz);1405759966;Gets all superclasses of the supplied {@link Class class}, including the_class itself. The ordering of the returned list will begin with the_supplied class and continue up the class hierarchy, excluding {@link Object}._<p>Note: This code has been borrowed from_{@link org.junit.internal.runners.TestClass#getSuperClasses(Class)} and_adapted._@param clazz the class for which to retrieve the superclasses_@return all superclasses of the supplied class, excluding {@code Object};private List<Class<?>> getSuperClasses(Class<?> clazz) {_		List<Class<?>> results = new ArrayList<Class<?>>()__		Class<?> current = clazz__		while (current != null && !current.equals(Object.class)) {_			results.add(current)__			current = current.getSuperclass()__		}_		return results__	};gets,all,superclasses,of,the,supplied,link,class,class,including,the,class,itself,the,ordering,of,the,returned,list,will,begin,with,the,supplied,class,and,continue,up,the,class,hierarchy,excluding,link,object,p,note,this,code,has,been,borrowed,from,link,org,junit,internal,runners,test,class,get,super,classes,class,and,adapted,param,clazz,the,class,for,which,to,retrieve,the,superclasses,return,all,superclasses,of,the,supplied,class,excluding,code,object;private,list,class,get,super,classes,class,clazz,list,class,results,new,array,list,class,class,current,clazz,while,current,null,current,equals,object,class,results,add,current,current,current,get,superclass,return,results
TransactionalTestExecutionListener -> private List<Class<?>> getSuperClasses(Class<?> clazz);1406218418;Gets all superclasses of the supplied {@link Class class}, including the_class itself. The ordering of the returned list will begin with the_supplied class and continue up the class hierarchy, excluding {@link Object}._<p>Note: This code has been borrowed from_{@link org.junit.internal.runners.TestClass#getSuperClasses(Class)} and_adapted._@param clazz the class for which to retrieve the superclasses_@return all superclasses of the supplied class, excluding {@code Object};private List<Class<?>> getSuperClasses(Class<?> clazz) {_		List<Class<?>> results = new ArrayList<Class<?>>()__		Class<?> current = clazz__		while (current != null && !current.equals(Object.class)) {_			results.add(current)__			current = current.getSuperclass()__		}_		return results__	};gets,all,superclasses,of,the,supplied,link,class,class,including,the,class,itself,the,ordering,of,the,returned,list,will,begin,with,the,supplied,class,and,continue,up,the,class,hierarchy,excluding,link,object,p,note,this,code,has,been,borrowed,from,link,org,junit,internal,runners,test,class,get,super,classes,class,and,adapted,param,clazz,the,class,for,which,to,retrieve,the,superclasses,return,all,superclasses,of,the,supplied,class,excluding,code,object;private,list,class,get,super,classes,class,clazz,list,class,results,new,array,list,class,class,current,clazz,while,current,null,current,equals,object,class,results,add,current,current,current,get,superclass,return,results
TransactionalTestExecutionListener -> private List<Class<?>> getSuperClasses(Class<?> clazz);1407419079;Gets all superclasses of the supplied {@link Class class}, including the_class itself. The ordering of the returned list will begin with the_supplied class and continue up the class hierarchy, excluding {@link Object}._<p>Note: This code has been borrowed from_{@link org.junit.internal.runners.TestClass#getSuperClasses(Class)} and_adapted._@param clazz the class for which to retrieve the superclasses_@return all superclasses of the supplied class, excluding {@code Object};private List<Class<?>> getSuperClasses(Class<?> clazz) {_		List<Class<?>> results = new ArrayList<Class<?>>()__		Class<?> current = clazz__		while (current != null && !current.equals(Object.class)) {_			results.add(current)__			current = current.getSuperclass()__		}_		return results__	};gets,all,superclasses,of,the,supplied,link,class,class,including,the,class,itself,the,ordering,of,the,returned,list,will,begin,with,the,supplied,class,and,continue,up,the,class,hierarchy,excluding,link,object,p,note,this,code,has,been,borrowed,from,link,org,junit,internal,runners,test,class,get,super,classes,class,and,adapted,param,clazz,the,class,for,which,to,retrieve,the,superclasses,return,all,superclasses,of,the,supplied,class,excluding,code,object;private,list,class,get,super,classes,class,clazz,list,class,results,new,array,list,class,class,current,clazz,while,current,null,current,equals,object,class,results,add,current,current,current,get,superclass,return,results
TransactionalTestExecutionListener -> private List<Class<?>> getSuperClasses(Class<?> clazz);1408048216;Gets all superclasses of the supplied {@link Class class}, including the_class itself. The ordering of the returned list will begin with the_supplied class and continue up the class hierarchy, excluding {@link Object}._<p>Note: This code has been borrowed from_{@link org.junit.internal.runners.TestClass#getSuperClasses(Class)} and_adapted._@param clazz the class for which to retrieve the superclasses_@return all superclasses of the supplied class, excluding {@code Object};private List<Class<?>> getSuperClasses(Class<?> clazz) {_		List<Class<?>> results = new ArrayList<Class<?>>()__		Class<?> current = clazz__		while (current != null && !current.equals(Object.class)) {_			results.add(current)__			current = current.getSuperclass()__		}_		return results__	};gets,all,superclasses,of,the,supplied,link,class,class,including,the,class,itself,the,ordering,of,the,returned,list,will,begin,with,the,supplied,class,and,continue,up,the,class,hierarchy,excluding,link,object,p,note,this,code,has,been,borrowed,from,link,org,junit,internal,runners,test,class,get,super,classes,class,and,adapted,param,clazz,the,class,for,which,to,retrieve,the,superclasses,return,all,superclasses,of,the,supplied,class,excluding,code,object;private,list,class,get,super,classes,class,clazz,list,class,results,new,array,list,class,class,current,clazz,while,current,null,current,equals,object,class,results,add,current,current,current,get,superclass,return,results
TransactionalTestExecutionListener -> private List<Class<?>> getSuperClasses(Class<?> clazz);1413848647;Gets all superclasses of the supplied {@link Class class}, including the_class itself. The ordering of the returned list will begin with the_supplied class and continue up the class hierarchy, excluding {@link Object}._<p>Note: This code has been borrowed from_{@link org.junit.internal.runners.TestClass#getSuperClasses(Class)} and_adapted._@param clazz the class for which to retrieve the superclasses_@return all superclasses of the supplied class, excluding {@code Object};private List<Class<?>> getSuperClasses(Class<?> clazz) {_		List<Class<?>> results = new ArrayList<Class<?>>()__		Class<?> current = clazz__		while (current != null && !current.equals(Object.class)) {_			results.add(current)__			current = current.getSuperclass()__		}_		return results__	};gets,all,superclasses,of,the,supplied,link,class,class,including,the,class,itself,the,ordering,of,the,returned,list,will,begin,with,the,supplied,class,and,continue,up,the,class,hierarchy,excluding,link,object,p,note,this,code,has,been,borrowed,from,link,org,junit,internal,runners,test,class,get,super,classes,class,and,adapted,param,clazz,the,class,for,which,to,retrieve,the,superclasses,return,all,superclasses,of,the,supplied,class,excluding,code,object;private,list,class,get,super,classes,class,clazz,list,class,results,new,array,list,class,class,current,clazz,while,current,null,current,equals,object,class,results,add,current,current,current,get,superclass,return,results
TransactionalTestExecutionListener -> private List<Class<?>> getSuperClasses(Class<?> clazz);1431568199;Gets all superclasses of the supplied {@link Class class}, including the_class itself. The ordering of the returned list will begin with the_supplied class and continue up the class hierarchy, excluding {@link Object}._<p>Note: This code has been borrowed from_{@link org.junit.internal.runners.TestClass#getSuperClasses(Class)} and_adapted._@param clazz the class for which to retrieve the superclasses_@return all superclasses of the supplied class, excluding {@code Object};private List<Class<?>> getSuperClasses(Class<?> clazz) {_		List<Class<?>> results = new ArrayList<Class<?>>()__		Class<?> current = clazz__		while (current != null && !current.equals(Object.class)) {_			results.add(current)__			current = current.getSuperclass()__		}_		return results__	};gets,all,superclasses,of,the,supplied,link,class,class,including,the,class,itself,the,ordering,of,the,returned,list,will,begin,with,the,supplied,class,and,continue,up,the,class,hierarchy,excluding,link,object,p,note,this,code,has,been,borrowed,from,link,org,junit,internal,runners,test,class,get,super,classes,class,and,adapted,param,clazz,the,class,for,which,to,retrieve,the,superclasses,return,all,superclasses,of,the,supplied,class,excluding,code,object;private,list,class,get,super,classes,class,clazz,list,class,results,new,array,list,class,class,current,clazz,while,current,null,current,equals,object,class,results,add,current,current,current,get,superclass,return,results
TransactionalTestExecutionListener -> private List<Class<?>> getSuperClasses(Class<?> clazz);1432125256;Gets all superclasses of the supplied {@link Class class}, including the_class itself. The ordering of the returned list will begin with the_supplied class and continue up the class hierarchy, excluding {@link Object}._<p>Note: This code has been borrowed from_{@link org.junit.internal.runners.TestClass#getSuperClasses(Class)} and_adapted._@param clazz the class for which to retrieve the superclasses_@return all superclasses of the supplied class, excluding {@code Object};private List<Class<?>> getSuperClasses(Class<?> clazz) {_		List<Class<?>> results = new ArrayList<Class<?>>()__		Class<?> current = clazz__		while (current != null && Object.class != current) {_			results.add(current)__			current = current.getSuperclass()__		}_		return results__	};gets,all,superclasses,of,the,supplied,link,class,class,including,the,class,itself,the,ordering,of,the,returned,list,will,begin,with,the,supplied,class,and,continue,up,the,class,hierarchy,excluding,link,object,p,note,this,code,has,been,borrowed,from,link,org,junit,internal,runners,test,class,get,super,classes,class,and,adapted,param,clazz,the,class,for,which,to,retrieve,the,superclasses,return,all,superclasses,of,the,supplied,class,excluding,code,object;private,list,class,get,super,classes,class,clazz,list,class,results,new,array,list,class,class,current,clazz,while,current,null,object,class,current,results,add,current,current,current,get,superclass,return,results
TransactionalTestExecutionListener -> private List<Class<?>> getSuperClasses(Class<?> clazz);1432856630;Gets all superclasses of the supplied {@link Class class}, including the_class itself. The ordering of the returned list will begin with the_supplied class and continue up the class hierarchy, excluding {@link Object}._<p>Note: This code has been borrowed from_{@link org.junit.internal.runners.TestClass#getSuperClasses(Class)} and_adapted._@param clazz the class for which to retrieve the superclasses_@return all superclasses of the supplied class, excluding {@code Object};private List<Class<?>> getSuperClasses(Class<?> clazz) {_		List<Class<?>> results = new ArrayList<Class<?>>()__		Class<?> current = clazz__		while (current != null && Object.class != current) {_			results.add(current)__			current = current.getSuperclass()__		}_		return results__	};gets,all,superclasses,of,the,supplied,link,class,class,including,the,class,itself,the,ordering,of,the,returned,list,will,begin,with,the,supplied,class,and,continue,up,the,class,hierarchy,excluding,link,object,p,note,this,code,has,been,borrowed,from,link,org,junit,internal,runners,test,class,get,super,classes,class,and,adapted,param,clazz,the,class,for,which,to,retrieve,the,superclasses,return,all,superclasses,of,the,supplied,class,excluding,code,object;private,list,class,get,super,classes,class,clazz,list,class,results,new,array,list,class,class,current,clazz,while,current,null,object,class,current,results,add,current,current,current,get,superclass,return,results
TransactionalTestExecutionListener -> private List<Class<?>> getSuperClasses(Class<?> clazz);1434234880;Gets all superclasses of the supplied {@link Class class}, including the_class itself. The ordering of the returned list will begin with the_supplied class and continue up the class hierarchy, excluding {@link Object}._<p>Note: This code has been borrowed from_{@link org.junit.internal.runners.TestClass#getSuperClasses(Class)} and_adapted._@param clazz the class for which to retrieve the superclasses_@return all superclasses of the supplied class, excluding {@code Object};private List<Class<?>> getSuperClasses(Class<?> clazz) {_		List<Class<?>> results = new ArrayList<Class<?>>()__		Class<?> current = clazz__		while (current != null && Object.class != current) {_			results.add(current)__			current = current.getSuperclass()__		}_		return results__	};gets,all,superclasses,of,the,supplied,link,class,class,including,the,class,itself,the,ordering,of,the,returned,list,will,begin,with,the,supplied,class,and,continue,up,the,class,hierarchy,excluding,link,object,p,note,this,code,has,been,borrowed,from,link,org,junit,internal,runners,test,class,get,super,classes,class,and,adapted,param,clazz,the,class,for,which,to,retrieve,the,superclasses,return,all,superclasses,of,the,supplied,class,excluding,code,object;private,list,class,get,super,classes,class,clazz,list,class,results,new,array,list,class,class,current,clazz,while,current,null,object,class,current,results,add,current,current,current,get,superclass,return,results
TransactionalTestExecutionListener -> private List<Class<?>> getSuperClasses(Class<?> clazz);1434720443;Gets all superclasses of the supplied {@link Class class}, including the_class itself. The ordering of the returned list will begin with the_supplied class and continue up the class hierarchy, excluding {@link Object}._<p>Note: This code has been borrowed from_{@link org.junit.internal.runners.TestClass#getSuperClasses(Class)} and_adapted._@param clazz the class for which to retrieve the superclasses_@return all superclasses of the supplied class, excluding {@code Object};private List<Class<?>> getSuperClasses(Class<?> clazz) {_		List<Class<?>> results = new ArrayList<Class<?>>()__		Class<?> current = clazz__		while (current != null && Object.class != current) {_			results.add(current)__			current = current.getSuperclass()__		}_		return results__	};gets,all,superclasses,of,the,supplied,link,class,class,including,the,class,itself,the,ordering,of,the,returned,list,will,begin,with,the,supplied,class,and,continue,up,the,class,hierarchy,excluding,link,object,p,note,this,code,has,been,borrowed,from,link,org,junit,internal,runners,test,class,get,super,classes,class,and,adapted,param,clazz,the,class,for,which,to,retrieve,the,superclasses,return,all,superclasses,of,the,supplied,class,excluding,code,object;private,list,class,get,super,classes,class,clazz,list,class,results,new,array,list,class,class,current,clazz,while,current,null,object,class,current,results,add,current,current,current,get,superclass,return,results
TransactionalTestExecutionListener -> private List<Class<?>> getSuperClasses(Class<?> clazz);1434817656;Gets all superclasses of the supplied {@link Class class}, including the_class itself. The ordering of the returned list will begin with the_supplied class and continue up the class hierarchy, excluding {@link Object}._<p>Note: This code has been borrowed from_{@link org.junit.internal.runners.TestClass#getSuperClasses(Class)} and_adapted._@param clazz the class for which to retrieve the superclasses_@return all superclasses of the supplied class, excluding {@code Object};private List<Class<?>> getSuperClasses(Class<?> clazz) {_		List<Class<?>> results = new ArrayList<Class<?>>()__		Class<?> current = clazz__		while (current != null && Object.class != current) {_			results.add(current)__			current = current.getSuperclass()__		}_		return results__	};gets,all,superclasses,of,the,supplied,link,class,class,including,the,class,itself,the,ordering,of,the,returned,list,will,begin,with,the,supplied,class,and,continue,up,the,class,hierarchy,excluding,link,object,p,note,this,code,has,been,borrowed,from,link,org,junit,internal,runners,test,class,get,super,classes,class,and,adapted,param,clazz,the,class,for,which,to,retrieve,the,superclasses,return,all,superclasses,of,the,supplied,class,excluding,code,object;private,list,class,get,super,classes,class,clazz,list,class,results,new,array,list,class,class,current,clazz,while,current,null,object,class,current,results,add,current,current,current,get,superclass,return,results
TransactionalTestExecutionListener -> private List<Class<?>> getSuperClasses(Class<?> clazz);1437841346;Gets all superclasses of the supplied {@link Class class}, including the_class itself. The ordering of the returned list will begin with the_supplied class and continue up the class hierarchy, excluding {@link Object}._<p>Note: This code has been borrowed from_{@link org.junit.internal.runners.TestClass#getSuperClasses(Class)} and_adapted._@param clazz the class for which to retrieve the superclasses_@return all superclasses of the supplied class, excluding {@code Object};private List<Class<?>> getSuperClasses(Class<?> clazz) {_		List<Class<?>> results = new ArrayList<Class<?>>()__		Class<?> current = clazz__		while (current != null && Object.class != current) {_			results.add(current)__			current = current.getSuperclass()__		}_		return results__	};gets,all,superclasses,of,the,supplied,link,class,class,including,the,class,itself,the,ordering,of,the,returned,list,will,begin,with,the,supplied,class,and,continue,up,the,class,hierarchy,excluding,link,object,p,note,this,code,has,been,borrowed,from,link,org,junit,internal,runners,test,class,get,super,classes,class,and,adapted,param,clazz,the,class,for,which,to,retrieve,the,superclasses,return,all,superclasses,of,the,supplied,class,excluding,code,object;private,list,class,get,super,classes,class,clazz,list,class,results,new,array,list,class,class,current,clazz,while,current,null,object,class,current,results,add,current,current,current,get,superclass,return,results
TransactionalTestExecutionListener -> private List<Class<?>> getSuperClasses(Class<?> clazz);1437851372;Gets all superclasses of the supplied {@link Class class}, including the_class itself. The ordering of the returned list will begin with the_supplied class and continue up the class hierarchy, excluding {@link Object}._<p>Note: This code has been borrowed from_{@link org.junit.internal.runners.TestClass#getSuperClasses(Class)} and_adapted._@param clazz the class for which to retrieve the superclasses_@return all superclasses of the supplied class, excluding {@code Object};private List<Class<?>> getSuperClasses(Class<?> clazz) {_		List<Class<?>> results = new ArrayList<Class<?>>()__		Class<?> current = clazz__		while (current != null && Object.class != current) {_			results.add(current)__			current = current.getSuperclass()__		}_		return results__	};gets,all,superclasses,of,the,supplied,link,class,class,including,the,class,itself,the,ordering,of,the,returned,list,will,begin,with,the,supplied,class,and,continue,up,the,class,hierarchy,excluding,link,object,p,note,this,code,has,been,borrowed,from,link,org,junit,internal,runners,test,class,get,super,classes,class,and,adapted,param,clazz,the,class,for,which,to,retrieve,the,superclasses,return,all,superclasses,of,the,supplied,class,excluding,code,object;private,list,class,get,super,classes,class,clazz,list,class,results,new,array,list,class,class,current,clazz,while,current,null,object,class,current,results,add,current,current,current,get,superclass,return,results
TransactionalTestExecutionListener -> private List<Class<?>> getSuperClasses(Class<?> clazz);1437852597;Gets all superclasses of the supplied {@link Class class}, including the_class itself. The ordering of the returned list will begin with the_supplied class and continue up the class hierarchy, excluding {@link Object}._<p>Note: This code has been borrowed from_{@link org.junit.internal.runners.TestClass#getSuperClasses(Class)} and_adapted._@param clazz the class for which to retrieve the superclasses_@return all superclasses of the supplied class, excluding {@code Object};private List<Class<?>> getSuperClasses(Class<?> clazz) {_		List<Class<?>> results = new ArrayList<Class<?>>()__		Class<?> current = clazz__		while (current != null && Object.class != current) {_			results.add(current)__			current = current.getSuperclass()__		}_		return results__	};gets,all,superclasses,of,the,supplied,link,class,class,including,the,class,itself,the,ordering,of,the,returned,list,will,begin,with,the,supplied,class,and,continue,up,the,class,hierarchy,excluding,link,object,p,note,this,code,has,been,borrowed,from,link,org,junit,internal,runners,test,class,get,super,classes,class,and,adapted,param,clazz,the,class,for,which,to,retrieve,the,superclasses,return,all,superclasses,of,the,supplied,class,excluding,code,object;private,list,class,get,super,classes,class,clazz,list,class,results,new,array,list,class,class,current,clazz,while,current,null,object,class,current,results,add,current,current,current,get,superclass,return,results
TransactionalTestExecutionListener -> private List<Class<?>> getSuperClasses(Class<?> clazz);1454507787;Gets all superclasses of the supplied {@link Class class}, including the_class itself. The ordering of the returned list will begin with the_supplied class and continue up the class hierarchy, excluding {@link Object}._<p>Note: This code has been borrowed from_{@link org.junit.internal.runners.TestClass#getSuperClasses(Class)} and_adapted._@param clazz the class for which to retrieve the superclasses_@return all superclasses of the supplied class, excluding {@code Object};private List<Class<?>> getSuperClasses(Class<?> clazz) {_		List<Class<?>> results = new ArrayList<Class<?>>()__		Class<?> current = clazz__		while (current != null && Object.class != current) {_			results.add(current)__			current = current.getSuperclass()__		}_		return results__	};gets,all,superclasses,of,the,supplied,link,class,class,including,the,class,itself,the,ordering,of,the,returned,list,will,begin,with,the,supplied,class,and,continue,up,the,class,hierarchy,excluding,link,object,p,note,this,code,has,been,borrowed,from,link,org,junit,internal,runners,test,class,get,super,classes,class,and,adapted,param,clazz,the,class,for,which,to,retrieve,the,superclasses,return,all,superclasses,of,the,supplied,class,excluding,code,object;private,list,class,get,super,classes,class,clazz,list,class,results,new,array,list,class,class,current,clazz,while,current,null,object,class,current,results,add,current,current,current,get,superclass,return,results
TransactionalTestExecutionListener -> private List<Class<?>> getSuperClasses(Class<?> clazz);1456702967;Gets all superclasses of the supplied {@link Class class}, including the_class itself. The ordering of the returned list will begin with the_supplied class and continue up the class hierarchy, excluding {@link Object}._<p>Note: This code has been borrowed from_{@link org.junit.internal.runners.TestClass#getSuperClasses(Class)} and_adapted._@param clazz the class for which to retrieve the superclasses_@return all superclasses of the supplied class, excluding {@code Object};private List<Class<?>> getSuperClasses(Class<?> clazz) {_		List<Class<?>> results = new ArrayList<Class<?>>()__		Class<?> current = clazz__		while (current != null && Object.class != current) {_			results.add(current)__			current = current.getSuperclass()__		}_		return results__	};gets,all,superclasses,of,the,supplied,link,class,class,including,the,class,itself,the,ordering,of,the,returned,list,will,begin,with,the,supplied,class,and,continue,up,the,class,hierarchy,excluding,link,object,p,note,this,code,has,been,borrowed,from,link,org,junit,internal,runners,test,class,get,super,classes,class,and,adapted,param,clazz,the,class,for,which,to,retrieve,the,superclasses,return,all,superclasses,of,the,supplied,class,excluding,code,object;private,list,class,get,super,classes,class,clazz,list,class,results,new,array,list,class,class,current,clazz,while,current,null,object,class,current,results,add,current,current,current,get,superclass,return,results
TransactionalTestExecutionListener -> private List<Class<?>> getSuperClasses(Class<?> clazz);1456756222;Gets all superclasses of the supplied {@link Class class}, including the_class itself. The ordering of the returned list will begin with the_supplied class and continue up the class hierarchy, excluding {@link Object}._<p>Note: This code has been borrowed from_{@link org.junit.internal.runners.TestClass#getSuperClasses(Class)} and_adapted._@param clazz the class for which to retrieve the superclasses_@return all superclasses of the supplied class, excluding {@code Object};private List<Class<?>> getSuperClasses(Class<?> clazz) {_		List<Class<?>> results = new ArrayList<Class<?>>()__		Class<?> current = clazz__		while (current != null && Object.class != current) {_			results.add(current)__			current = current.getSuperclass()__		}_		return results__	};gets,all,superclasses,of,the,supplied,link,class,class,including,the,class,itself,the,ordering,of,the,returned,list,will,begin,with,the,supplied,class,and,continue,up,the,class,hierarchy,excluding,link,object,p,note,this,code,has,been,borrowed,from,link,org,junit,internal,runners,test,class,get,super,classes,class,and,adapted,param,clazz,the,class,for,which,to,retrieve,the,superclasses,return,all,superclasses,of,the,supplied,class,excluding,code,object;private,list,class,get,super,classes,class,clazz,list,class,results,new,array,list,class,class,current,clazz,while,current,null,object,class,current,results,add,current,current,current,get,superclass,return,results
TransactionalTestExecutionListener -> private List<Class<?>> getSuperClasses(Class<?> clazz);1456756222;Gets all superclasses of the supplied {@link Class class}, including the_class itself. The ordering of the returned list will begin with the_supplied class and continue up the class hierarchy, excluding {@link Object}._<p>Note: This code has been borrowed from_{@link org.junit.internal.runners.TestClass#getSuperClasses(Class)} and_adapted._@param clazz the class for which to retrieve the superclasses_@return all superclasses of the supplied class, excluding {@code Object};private List<Class<?>> getSuperClasses(Class<?> clazz) {_		List<Class<?>> results = new ArrayList<Class<?>>()__		Class<?> current = clazz__		while (current != null && Object.class != current) {_			results.add(current)__			current = current.getSuperclass()__		}_		return results__	};gets,all,superclasses,of,the,supplied,link,class,class,including,the,class,itself,the,ordering,of,the,returned,list,will,begin,with,the,supplied,class,and,continue,up,the,class,hierarchy,excluding,link,object,p,note,this,code,has,been,borrowed,from,link,org,junit,internal,runners,test,class,get,super,classes,class,and,adapted,param,clazz,the,class,for,which,to,retrieve,the,superclasses,return,all,superclasses,of,the,supplied,class,excluding,code,object;private,list,class,get,super,classes,class,clazz,list,class,results,new,array,list,class,class,current,clazz,while,current,null,object,class,current,results,add,current,current,current,get,superclass,return,results
TransactionalTestExecutionListener -> private List<Class<?>> getSuperClasses(Class<?> clazz);1458754760;Gets all superclasses of the supplied {@link Class class}, including the_class itself. The ordering of the returned list will begin with the_supplied class and continue up the class hierarchy, excluding {@link Object}._<p>Note: This code has been borrowed from_{@link org.junit.internal.runners.TestClass#getSuperClasses(Class)} and_adapted._@param clazz the class for which to retrieve the superclasses_@return all superclasses of the supplied class, excluding {@code Object};private List<Class<?>> getSuperClasses(Class<?> clazz) {_		List<Class<?>> results = new ArrayList<Class<?>>()__		Class<?> current = clazz__		while (current != null && Object.class != current) {_			results.add(current)__			current = current.getSuperclass()__		}_		return results__	};gets,all,superclasses,of,the,supplied,link,class,class,including,the,class,itself,the,ordering,of,the,returned,list,will,begin,with,the,supplied,class,and,continue,up,the,class,hierarchy,excluding,link,object,p,note,this,code,has,been,borrowed,from,link,org,junit,internal,runners,test,class,get,super,classes,class,and,adapted,param,clazz,the,class,for,which,to,retrieve,the,superclasses,return,all,superclasses,of,the,supplied,class,excluding,code,object;private,list,class,get,super,classes,class,clazz,list,class,results,new,array,list,class,class,current,clazz,while,current,null,object,class,current,results,add,current,current,current,get,superclass,return,results
TransactionalTestExecutionListener -> @SuppressWarnings("deprecation") 	TransactionConfigurationAttributes retrieveConfigurationAttributes(TestContext testContext);1437841346;Retrieve the {@link TransactionConfigurationAttributes} for the_supplied {@link TestContext} whose {@linkplain Class test class}_may optionally declare or inherit_{@link TransactionConfiguration @TransactionConfiguration}._<p>If {@code @TransactionConfiguration} is not present for the_supplied {@code TestContext}, a default instance of_{@code TransactionConfigurationAttributes} will be used instead._@param testContext the test context for which the configuration_attributes should be retrieved_@return the TransactionConfigurationAttributes instance for this listener,_potentially cached_@see TransactionConfigurationAttributes#TransactionConfigurationAttributes();@SuppressWarnings("deprecation")_	TransactionConfigurationAttributes retrieveConfigurationAttributes(TestContext testContext) {_		if (this.configurationAttributes == null) {_			Class<?> clazz = testContext.getTestClass()___			TransactionConfiguration txConfig = AnnotatedElementUtils.findMergedAnnotation(clazz,_				TransactionConfiguration.class)__			if (logger.isDebugEnabled()) {_				logger.debug(String.format("Retrieved @TransactionConfiguration [%s] for test class [%s].",_					txConfig, clazz.getName()))__			}__			TransactionConfigurationAttributes configAttributes = (txConfig == null ? defaultTxConfigAttributes_					: new TransactionConfigurationAttributes(txConfig.transactionManager(), txConfig.defaultRollback()))___			if (logger.isDebugEnabled()) {_				logger.debug(String.format("Using TransactionConfigurationAttributes %s for test class [%s].",_					configAttributes, clazz.getName()))__			}_			this.configurationAttributes = configAttributes__		}_		return this.configurationAttributes__	};retrieve,the,link,transaction,configuration,attributes,for,the,supplied,link,test,context,whose,linkplain,class,test,class,may,optionally,declare,or,inherit,link,transaction,configuration,transaction,configuration,p,if,code,transaction,configuration,is,not,present,for,the,supplied,code,test,context,a,default,instance,of,code,transaction,configuration,attributes,will,be,used,instead,param,test,context,the,test,context,for,which,the,configuration,attributes,should,be,retrieved,return,the,transaction,configuration,attributes,instance,for,this,listener,potentially,cached,see,transaction,configuration,attributes,transaction,configuration,attributes;suppress,warnings,deprecation,transaction,configuration,attributes,retrieve,configuration,attributes,test,context,test,context,if,this,configuration,attributes,null,class,clazz,test,context,get,test,class,transaction,configuration,tx,config,annotated,element,utils,find,merged,annotation,clazz,transaction,configuration,class,if,logger,is,debug,enabled,logger,debug,string,format,retrieved,transaction,configuration,s,for,test,class,s,tx,config,clazz,get,name,transaction,configuration,attributes,config,attributes,tx,config,null,default,tx,config,attributes,new,transaction,configuration,attributes,tx,config,transaction,manager,tx,config,default,rollback,if,logger,is,debug,enabled,logger,debug,string,format,using,transaction,configuration,attributes,s,for,test,class,s,config,attributes,clazz,get,name,this,configuration,attributes,config,attributes,return,this,configuration,attributes
TransactionalTestExecutionListener -> @SuppressWarnings("deprecation") 	TransactionConfigurationAttributes retrieveConfigurationAttributes(TestContext testContext);1437851372;Retrieve the {@link TransactionConfigurationAttributes} for the_supplied {@link TestContext} whose {@linkplain Class test class}_may optionally declare or inherit_{@link TransactionConfiguration @TransactionConfiguration}._<p>If {@code @TransactionConfiguration} is not present for the_supplied {@code TestContext}, a default instance of_{@code TransactionConfigurationAttributes} will be used instead._@param testContext the test context for which the configuration_attributes should be retrieved_@return the TransactionConfigurationAttributes instance for this listener,_potentially cached_@see TransactionConfigurationAttributes#TransactionConfigurationAttributes();@SuppressWarnings("deprecation")_	TransactionConfigurationAttributes retrieveConfigurationAttributes(TestContext testContext) {_		if (this.configurationAttributes == null) {_			Class<?> clazz = testContext.getTestClass()___			TransactionConfiguration txConfig = AnnotatedElementUtils.findMergedAnnotation(clazz,_				TransactionConfiguration.class)__			if (logger.isDebugEnabled()) {_				logger.debug(String.format("Retrieved @TransactionConfiguration [%s] for test class [%s].",_					txConfig, clazz.getName()))__			}__			TransactionConfigurationAttributes configAttributes = (txConfig == null ? defaultTxConfigAttributes_					: new TransactionConfigurationAttributes(txConfig.transactionManager(), txConfig.defaultRollback()))___			if (logger.isDebugEnabled()) {_				logger.debug(String.format("Using TransactionConfigurationAttributes %s for test class [%s].",_					configAttributes, clazz.getName()))__			}_			this.configurationAttributes = configAttributes__		}_		return this.configurationAttributes__	};retrieve,the,link,transaction,configuration,attributes,for,the,supplied,link,test,context,whose,linkplain,class,test,class,may,optionally,declare,or,inherit,link,transaction,configuration,transaction,configuration,p,if,code,transaction,configuration,is,not,present,for,the,supplied,code,test,context,a,default,instance,of,code,transaction,configuration,attributes,will,be,used,instead,param,test,context,the,test,context,for,which,the,configuration,attributes,should,be,retrieved,return,the,transaction,configuration,attributes,instance,for,this,listener,potentially,cached,see,transaction,configuration,attributes,transaction,configuration,attributes;suppress,warnings,deprecation,transaction,configuration,attributes,retrieve,configuration,attributes,test,context,test,context,if,this,configuration,attributes,null,class,clazz,test,context,get,test,class,transaction,configuration,tx,config,annotated,element,utils,find,merged,annotation,clazz,transaction,configuration,class,if,logger,is,debug,enabled,logger,debug,string,format,retrieved,transaction,configuration,s,for,test,class,s,tx,config,clazz,get,name,transaction,configuration,attributes,config,attributes,tx,config,null,default,tx,config,attributes,new,transaction,configuration,attributes,tx,config,transaction,manager,tx,config,default,rollback,if,logger,is,debug,enabled,logger,debug,string,format,using,transaction,configuration,attributes,s,for,test,class,s,config,attributes,clazz,get,name,this,configuration,attributes,config,attributes,return,this,configuration,attributes
TransactionalTestExecutionListener -> @SuppressWarnings("deprecation") 	TransactionConfigurationAttributes retrieveConfigurationAttributes(TestContext testContext);1437852597;Retrieve the {@link TransactionConfigurationAttributes} for the_supplied {@link TestContext} whose {@linkplain Class test class}_may optionally declare or inherit_{@link TransactionConfiguration @TransactionConfiguration}._<p>If {@code @TransactionConfiguration} is not present for the_supplied {@code TestContext}, a default instance of_{@code TransactionConfigurationAttributes} will be used instead._@param testContext the test context for which the configuration_attributes should be retrieved_@return the TransactionConfigurationAttributes instance for this listener,_potentially cached_@see TransactionConfigurationAttributes#TransactionConfigurationAttributes();@SuppressWarnings("deprecation")_	TransactionConfigurationAttributes retrieveConfigurationAttributes(TestContext testContext) {_		if (this.configurationAttributes == null) {_			Class<?> clazz = testContext.getTestClass()___			TransactionConfiguration txConfig = AnnotatedElementUtils.findMergedAnnotation(clazz,_				TransactionConfiguration.class)__			if (logger.isDebugEnabled()) {_				logger.debug(String.format("Retrieved @TransactionConfiguration [%s] for test class [%s].",_					txConfig, clazz.getName()))__			}__			TransactionConfigurationAttributes configAttributes = (txConfig == null ? defaultTxConfigAttributes_					: new TransactionConfigurationAttributes(txConfig.transactionManager(), txConfig.defaultRollback()))___			if (logger.isDebugEnabled()) {_				logger.debug(String.format("Using TransactionConfigurationAttributes %s for test class [%s].",_					configAttributes, clazz.getName()))__			}_			this.configurationAttributes = configAttributes__		}_		return this.configurationAttributes__	};retrieve,the,link,transaction,configuration,attributes,for,the,supplied,link,test,context,whose,linkplain,class,test,class,may,optionally,declare,or,inherit,link,transaction,configuration,transaction,configuration,p,if,code,transaction,configuration,is,not,present,for,the,supplied,code,test,context,a,default,instance,of,code,transaction,configuration,attributes,will,be,used,instead,param,test,context,the,test,context,for,which,the,configuration,attributes,should,be,retrieved,return,the,transaction,configuration,attributes,instance,for,this,listener,potentially,cached,see,transaction,configuration,attributes,transaction,configuration,attributes;suppress,warnings,deprecation,transaction,configuration,attributes,retrieve,configuration,attributes,test,context,test,context,if,this,configuration,attributes,null,class,clazz,test,context,get,test,class,transaction,configuration,tx,config,annotated,element,utils,find,merged,annotation,clazz,transaction,configuration,class,if,logger,is,debug,enabled,logger,debug,string,format,retrieved,transaction,configuration,s,for,test,class,s,tx,config,clazz,get,name,transaction,configuration,attributes,config,attributes,tx,config,null,default,tx,config,attributes,new,transaction,configuration,attributes,tx,config,transaction,manager,tx,config,default,rollback,if,logger,is,debug,enabled,logger,debug,string,format,using,transaction,configuration,attributes,s,for,test,class,s,config,attributes,clazz,get,name,this,configuration,attributes,config,attributes,return,this,configuration,attributes
TransactionalTestExecutionListener -> @SuppressWarnings("deprecation") 	TransactionConfigurationAttributes retrieveConfigurationAttributes(TestContext testContext);1454507787;Retrieve the {@link TransactionConfigurationAttributes} for the_supplied {@link TestContext} whose {@linkplain Class test class}_may optionally declare or inherit_{@link TransactionConfiguration @TransactionConfiguration}._<p>If {@code @TransactionConfiguration} is not present for the_supplied {@code TestContext}, a default instance of_{@code TransactionConfigurationAttributes} will be used instead._@param testContext the test context for which the configuration_attributes should be retrieved_@return the TransactionConfigurationAttributes instance for this listener,_potentially cached_@see TransactionConfigurationAttributes#TransactionConfigurationAttributes();@SuppressWarnings("deprecation")_	TransactionConfigurationAttributes retrieveConfigurationAttributes(TestContext testContext) {_		if (this.configurationAttributes == null) {_			Class<?> clazz = testContext.getTestClass()___			TransactionConfiguration txConfig = AnnotatedElementUtils.findMergedAnnotation(clazz,_				TransactionConfiguration.class)__			if (logger.isDebugEnabled()) {_				logger.debug(String.format("Retrieved @TransactionConfiguration [%s] for test class [%s].",_					txConfig, clazz.getName()))__			}__			TransactionConfigurationAttributes configAttributes = (txConfig == null ? defaultTxConfigAttributes_					: new TransactionConfigurationAttributes(txConfig.transactionManager(), txConfig.defaultRollback()))___			if (logger.isDebugEnabled()) {_				logger.debug(String.format("Using TransactionConfigurationAttributes %s for test class [%s].",_					configAttributes, clazz.getName()))__			}_			this.configurationAttributes = configAttributes__		}_		return this.configurationAttributes__	};retrieve,the,link,transaction,configuration,attributes,for,the,supplied,link,test,context,whose,linkplain,class,test,class,may,optionally,declare,or,inherit,link,transaction,configuration,transaction,configuration,p,if,code,transaction,configuration,is,not,present,for,the,supplied,code,test,context,a,default,instance,of,code,transaction,configuration,attributes,will,be,used,instead,param,test,context,the,test,context,for,which,the,configuration,attributes,should,be,retrieved,return,the,transaction,configuration,attributes,instance,for,this,listener,potentially,cached,see,transaction,configuration,attributes,transaction,configuration,attributes;suppress,warnings,deprecation,transaction,configuration,attributes,retrieve,configuration,attributes,test,context,test,context,if,this,configuration,attributes,null,class,clazz,test,context,get,test,class,transaction,configuration,tx,config,annotated,element,utils,find,merged,annotation,clazz,transaction,configuration,class,if,logger,is,debug,enabled,logger,debug,string,format,retrieved,transaction,configuration,s,for,test,class,s,tx,config,clazz,get,name,transaction,configuration,attributes,config,attributes,tx,config,null,default,tx,config,attributes,new,transaction,configuration,attributes,tx,config,transaction,manager,tx,config,default,rollback,if,logger,is,debug,enabled,logger,debug,string,format,using,transaction,configuration,attributes,s,for,test,class,s,config,attributes,clazz,get,name,this,configuration,attributes,config,attributes,return,this,configuration,attributes
TransactionalTestExecutionListener -> @SuppressWarnings("deprecation") 	TransactionConfigurationAttributes retrieveConfigurationAttributes(TestContext testContext);1456702967;Retrieve the {@link TransactionConfigurationAttributes} for the_supplied {@link TestContext} whose {@linkplain Class test class}_may optionally declare or inherit_{@link TransactionConfiguration @TransactionConfiguration}._<p>If {@code @TransactionConfiguration} is not present for the_supplied {@code TestContext}, a default instance of_{@code TransactionConfigurationAttributes} will be used instead._@param testContext the test context for which the configuration_attributes should be retrieved_@return the TransactionConfigurationAttributes instance for this listener,_potentially cached_@see TransactionConfigurationAttributes#TransactionConfigurationAttributes();@SuppressWarnings("deprecation")_	TransactionConfigurationAttributes retrieveConfigurationAttributes(TestContext testContext) {_		if (this.configurationAttributes == null) {_			Class<?> clazz = testContext.getTestClass()___			TransactionConfiguration txConfig = AnnotatedElementUtils.findMergedAnnotation(clazz,_				TransactionConfiguration.class)__			if (logger.isDebugEnabled()) {_				logger.debug(String.format("Retrieved @TransactionConfiguration [%s] for test class [%s].",_					txConfig, clazz.getName()))__			}__			TransactionConfigurationAttributes configAttributes = (txConfig == null ? defaultTxConfigAttributes_					: new TransactionConfigurationAttributes(txConfig.transactionManager(), txConfig.defaultRollback()))___			if (logger.isDebugEnabled()) {_				logger.debug(String.format("Using TransactionConfigurationAttributes %s for test class [%s].",_					configAttributes, clazz.getName()))__			}_			this.configurationAttributes = configAttributes__		}_		return this.configurationAttributes__	};retrieve,the,link,transaction,configuration,attributes,for,the,supplied,link,test,context,whose,linkplain,class,test,class,may,optionally,declare,or,inherit,link,transaction,configuration,transaction,configuration,p,if,code,transaction,configuration,is,not,present,for,the,supplied,code,test,context,a,default,instance,of,code,transaction,configuration,attributes,will,be,used,instead,param,test,context,the,test,context,for,which,the,configuration,attributes,should,be,retrieved,return,the,transaction,configuration,attributes,instance,for,this,listener,potentially,cached,see,transaction,configuration,attributes,transaction,configuration,attributes;suppress,warnings,deprecation,transaction,configuration,attributes,retrieve,configuration,attributes,test,context,test,context,if,this,configuration,attributes,null,class,clazz,test,context,get,test,class,transaction,configuration,tx,config,annotated,element,utils,find,merged,annotation,clazz,transaction,configuration,class,if,logger,is,debug,enabled,logger,debug,string,format,retrieved,transaction,configuration,s,for,test,class,s,tx,config,clazz,get,name,transaction,configuration,attributes,config,attributes,tx,config,null,default,tx,config,attributes,new,transaction,configuration,attributes,tx,config,transaction,manager,tx,config,default,rollback,if,logger,is,debug,enabled,logger,debug,string,format,using,transaction,configuration,attributes,s,for,test,class,s,config,attributes,clazz,get,name,this,configuration,attributes,config,attributes,return,this,configuration,attributes
TransactionalTestExecutionListener -> @SuppressWarnings("deprecation") 	TransactionConfigurationAttributes retrieveConfigurationAttributes(TestContext testContext);1456756222;Retrieve the {@link TransactionConfigurationAttributes} for the_supplied {@link TestContext} whose {@linkplain Class test class}_may optionally declare or inherit_{@link TransactionConfiguration @TransactionConfiguration}._<p>If {@code @TransactionConfiguration} is not present for the_supplied {@code TestContext}, a default instance of_{@code TransactionConfigurationAttributes} will be used instead._@param testContext the test context for which the configuration_attributes should be retrieved_@return the TransactionConfigurationAttributes instance for this listener,_potentially cached_@see TransactionConfigurationAttributes#TransactionConfigurationAttributes();@SuppressWarnings("deprecation")_	TransactionConfigurationAttributes retrieveConfigurationAttributes(TestContext testContext) {_		if (this.configurationAttributes == null) {_			Class<?> clazz = testContext.getTestClass()___			TransactionConfiguration txConfig = AnnotatedElementUtils.findMergedAnnotation(clazz,_				TransactionConfiguration.class)__			if (logger.isDebugEnabled()) {_				logger.debug(String.format("Retrieved @TransactionConfiguration [%s] for test class [%s].",_					txConfig, clazz.getName()))__			}__			TransactionConfigurationAttributes configAttributes = (txConfig == null ? defaultTxConfigAttributes_					: new TransactionConfigurationAttributes(txConfig.transactionManager(), txConfig.defaultRollback()))___			if (logger.isDebugEnabled()) {_				logger.debug(String.format("Using TransactionConfigurationAttributes %s for test class [%s].",_					configAttributes, clazz.getName()))__			}_			this.configurationAttributes = configAttributes__		}_		return this.configurationAttributes__	};retrieve,the,link,transaction,configuration,attributes,for,the,supplied,link,test,context,whose,linkplain,class,test,class,may,optionally,declare,or,inherit,link,transaction,configuration,transaction,configuration,p,if,code,transaction,configuration,is,not,present,for,the,supplied,code,test,context,a,default,instance,of,code,transaction,configuration,attributes,will,be,used,instead,param,test,context,the,test,context,for,which,the,configuration,attributes,should,be,retrieved,return,the,transaction,configuration,attributes,instance,for,this,listener,potentially,cached,see,transaction,configuration,attributes,transaction,configuration,attributes;suppress,warnings,deprecation,transaction,configuration,attributes,retrieve,configuration,attributes,test,context,test,context,if,this,configuration,attributes,null,class,clazz,test,context,get,test,class,transaction,configuration,tx,config,annotated,element,utils,find,merged,annotation,clazz,transaction,configuration,class,if,logger,is,debug,enabled,logger,debug,string,format,retrieved,transaction,configuration,s,for,test,class,s,tx,config,clazz,get,name,transaction,configuration,attributes,config,attributes,tx,config,null,default,tx,config,attributes,new,transaction,configuration,attributes,tx,config,transaction,manager,tx,config,default,rollback,if,logger,is,debug,enabled,logger,debug,string,format,using,transaction,configuration,attributes,s,for,test,class,s,config,attributes,clazz,get,name,this,configuration,attributes,config,attributes,return,this,configuration,attributes
TransactionalTestExecutionListener -> @SuppressWarnings("deprecation") 	TransactionConfigurationAttributes retrieveConfigurationAttributes(TestContext testContext);1456756222;Retrieve the {@link TransactionConfigurationAttributes} for the_supplied {@link TestContext} whose {@linkplain Class test class}_may optionally declare or inherit_{@link TransactionConfiguration @TransactionConfiguration}._<p>If {@code @TransactionConfiguration} is not present for the_supplied {@code TestContext}, a default instance of_{@code TransactionConfigurationAttributes} will be used instead._@param testContext the test context for which the configuration_attributes should be retrieved_@return the TransactionConfigurationAttributes instance for this listener,_potentially cached_@see TransactionConfigurationAttributes#TransactionConfigurationAttributes();@SuppressWarnings("deprecation")_	TransactionConfigurationAttributes retrieveConfigurationAttributes(TestContext testContext) {_		if (this.configurationAttributes == null) {_			Class<?> clazz = testContext.getTestClass()___			TransactionConfiguration txConfig = AnnotatedElementUtils.findMergedAnnotation(clazz,_				TransactionConfiguration.class)__			if (logger.isDebugEnabled()) {_				logger.debug(String.format("Retrieved @TransactionConfiguration [%s] for test class [%s].",_					txConfig, clazz.getName()))__			}__			TransactionConfigurationAttributes configAttributes = (txConfig == null ? defaultTxConfigAttributes_					: new TransactionConfigurationAttributes(txConfig.transactionManager(), txConfig.defaultRollback()))___			if (logger.isDebugEnabled()) {_				logger.debug(String.format("Using TransactionConfigurationAttributes %s for test class [%s].",_					configAttributes, clazz.getName()))__			}_			this.configurationAttributes = configAttributes__		}_		return this.configurationAttributes__	};retrieve,the,link,transaction,configuration,attributes,for,the,supplied,link,test,context,whose,linkplain,class,test,class,may,optionally,declare,or,inherit,link,transaction,configuration,transaction,configuration,p,if,code,transaction,configuration,is,not,present,for,the,supplied,code,test,context,a,default,instance,of,code,transaction,configuration,attributes,will,be,used,instead,param,test,context,the,test,context,for,which,the,configuration,attributes,should,be,retrieved,return,the,transaction,configuration,attributes,instance,for,this,listener,potentially,cached,see,transaction,configuration,attributes,transaction,configuration,attributes;suppress,warnings,deprecation,transaction,configuration,attributes,retrieve,configuration,attributes,test,context,test,context,if,this,configuration,attributes,null,class,clazz,test,context,get,test,class,transaction,configuration,tx,config,annotated,element,utils,find,merged,annotation,clazz,transaction,configuration,class,if,logger,is,debug,enabled,logger,debug,string,format,retrieved,transaction,configuration,s,for,test,class,s,tx,config,clazz,get,name,transaction,configuration,attributes,config,attributes,tx,config,null,default,tx,config,attributes,new,transaction,configuration,attributes,tx,config,transaction,manager,tx,config,default,rollback,if,logger,is,debug,enabled,logger,debug,string,format,using,transaction,configuration,attributes,s,for,test,class,s,config,attributes,clazz,get,name,this,configuration,attributes,config,attributes,return,this,configuration,attributes
TransactionalTestExecutionListener -> @SuppressWarnings("deprecation") 	TransactionConfigurationAttributes retrieveConfigurationAttributes(TestContext testContext);1458754760;Retrieve the {@link TransactionConfigurationAttributes} for the_supplied {@link TestContext} whose {@linkplain Class test class}_may optionally declare or inherit_{@link TransactionConfiguration @TransactionConfiguration}._<p>If {@code @TransactionConfiguration} is not present for the_supplied {@code TestContext}, a default instance of_{@code TransactionConfigurationAttributes} will be used instead._@param testContext the test context for which the configuration_attributes should be retrieved_@return the TransactionConfigurationAttributes instance for this listener,_potentially cached_@see TransactionConfigurationAttributes#TransactionConfigurationAttributes();@SuppressWarnings("deprecation")_	TransactionConfigurationAttributes retrieveConfigurationAttributes(TestContext testContext) {_		if (this.configurationAttributes == null) {_			Class<?> clazz = testContext.getTestClass()___			TransactionConfiguration txConfig =_					AnnotatedElementUtils.findMergedAnnotation(clazz, TransactionConfiguration.class)__			if (logger.isDebugEnabled()) {_				logger.debug(String.format("Retrieved @TransactionConfiguration [%s] for test class [%s].",_						txConfig, clazz.getName()))__			}__			TransactionConfigurationAttributes configAttributes = (txConfig == null ? defaultTxConfigAttributes :_					new TransactionConfigurationAttributes(txConfig.transactionManager(), txConfig.defaultRollback()))__			if (logger.isDebugEnabled()) {_				logger.debug(String.format("Using TransactionConfigurationAttributes %s for test class [%s].",_						configAttributes, clazz.getName()))__			}_			this.configurationAttributes = configAttributes__		}_		return this.configurationAttributes__	};retrieve,the,link,transaction,configuration,attributes,for,the,supplied,link,test,context,whose,linkplain,class,test,class,may,optionally,declare,or,inherit,link,transaction,configuration,transaction,configuration,p,if,code,transaction,configuration,is,not,present,for,the,supplied,code,test,context,a,default,instance,of,code,transaction,configuration,attributes,will,be,used,instead,param,test,context,the,test,context,for,which,the,configuration,attributes,should,be,retrieved,return,the,transaction,configuration,attributes,instance,for,this,listener,potentially,cached,see,transaction,configuration,attributes,transaction,configuration,attributes;suppress,warnings,deprecation,transaction,configuration,attributes,retrieve,configuration,attributes,test,context,test,context,if,this,configuration,attributes,null,class,clazz,test,context,get,test,class,transaction,configuration,tx,config,annotated,element,utils,find,merged,annotation,clazz,transaction,configuration,class,if,logger,is,debug,enabled,logger,debug,string,format,retrieved,transaction,configuration,s,for,test,class,s,tx,config,clazz,get,name,transaction,configuration,attributes,config,attributes,tx,config,null,default,tx,config,attributes,new,transaction,configuration,attributes,tx,config,transaction,manager,tx,config,default,rollback,if,logger,is,debug,enabled,logger,debug,string,format,using,transaction,configuration,attributes,s,for,test,class,s,config,attributes,clazz,get,name,this,configuration,attributes,config,attributes,return,this,configuration,attributes
TransactionalTestExecutionListener -> @SuppressWarnings("deprecation") 	TransactionConfigurationAttributes retrieveConfigurationAttributes(TestContext testContext);1462294651;Retrieve the {@link TransactionConfigurationAttributes} for the_supplied {@link TestContext} whose {@linkplain Class test class}_may optionally declare or inherit_{@link TransactionConfiguration @TransactionConfiguration}._<p>If {@code @TransactionConfiguration} is not present for the_supplied {@code TestContext}, a default instance of_{@code TransactionConfigurationAttributes} will be used instead._@param testContext the test context for which the configuration_attributes should be retrieved_@return the TransactionConfigurationAttributes instance for this listener,_potentially cached_@see TransactionConfigurationAttributes#TransactionConfigurationAttributes();@SuppressWarnings("deprecation")_	TransactionConfigurationAttributes retrieveConfigurationAttributes(TestContext testContext) {_		if (this.configurationAttributes == null) {_			Class<?> clazz = testContext.getTestClass()___			TransactionConfiguration txConfig =_					AnnotatedElementUtils.findMergedAnnotation(clazz, TransactionConfiguration.class)__			if (logger.isDebugEnabled()) {_				logger.debug(String.format("Retrieved @TransactionConfiguration [%s] for test class [%s].",_						txConfig, clazz.getName()))__			}__			TransactionConfigurationAttributes configAttributes = (txConfig == null ? defaultTxConfigAttributes :_					new TransactionConfigurationAttributes(txConfig.transactionManager(), txConfig.defaultRollback()))__			if (logger.isDebugEnabled()) {_				logger.debug(String.format("Using TransactionConfigurationAttributes %s for test class [%s].",_						configAttributes, clazz.getName()))__			}_			this.configurationAttributes = configAttributes__		}_		return this.configurationAttributes__	};retrieve,the,link,transaction,configuration,attributes,for,the,supplied,link,test,context,whose,linkplain,class,test,class,may,optionally,declare,or,inherit,link,transaction,configuration,transaction,configuration,p,if,code,transaction,configuration,is,not,present,for,the,supplied,code,test,context,a,default,instance,of,code,transaction,configuration,attributes,will,be,used,instead,param,test,context,the,test,context,for,which,the,configuration,attributes,should,be,retrieved,return,the,transaction,configuration,attributes,instance,for,this,listener,potentially,cached,see,transaction,configuration,attributes,transaction,configuration,attributes;suppress,warnings,deprecation,transaction,configuration,attributes,retrieve,configuration,attributes,test,context,test,context,if,this,configuration,attributes,null,class,clazz,test,context,get,test,class,transaction,configuration,tx,config,annotated,element,utils,find,merged,annotation,clazz,transaction,configuration,class,if,logger,is,debug,enabled,logger,debug,string,format,retrieved,transaction,configuration,s,for,test,class,s,tx,config,clazz,get,name,transaction,configuration,attributes,config,attributes,tx,config,null,default,tx,config,attributes,new,transaction,configuration,attributes,tx,config,transaction,manager,tx,config,default,rollback,if,logger,is,debug,enabled,logger,debug,string,format,using,transaction,configuration,attributes,s,for,test,class,s,config,attributes,clazz,get,name,this,configuration,attributes,config,attributes,return,this,configuration,attributes
TransactionalTestExecutionListener -> @SuppressWarnings("deprecation") 	TransactionConfigurationAttributes retrieveConfigurationAttributes(TestContext testContext);1462299971;Retrieve the {@link TransactionConfigurationAttributes} for the_supplied {@link TestContext} whose {@linkplain Class test class}_may optionally declare or inherit_{@link TransactionConfiguration @TransactionConfiguration}._<p>If {@code @TransactionConfiguration} is not present for the_supplied {@code TestContext}, a default instance of_{@code TransactionConfigurationAttributes} will be used instead._@param testContext the test context for which the configuration_attributes should be retrieved_@return the TransactionConfigurationAttributes instance for this listener,_potentially cached_@see TransactionConfigurationAttributes#TransactionConfigurationAttributes();@SuppressWarnings("deprecation")_	TransactionConfigurationAttributes retrieveConfigurationAttributes(TestContext testContext) {_		if (this.configurationAttributes == null) {_			Class<?> clazz = testContext.getTestClass()___			TransactionConfiguration txConfig =_					AnnotatedElementUtils.findMergedAnnotation(clazz, TransactionConfiguration.class)__			if (logger.isDebugEnabled()) {_				logger.debug(String.format("Retrieved @TransactionConfiguration [%s] for test class [%s].",_						txConfig, clazz.getName()))__			}__			TransactionConfigurationAttributes configAttributes = (txConfig == null ? defaultTxConfigAttributes :_					new TransactionConfigurationAttributes(txConfig.transactionManager(), txConfig.defaultRollback()))__			if (logger.isDebugEnabled()) {_				logger.debug(String.format("Using TransactionConfigurationAttributes %s for test class [%s].",_						configAttributes, clazz.getName()))__			}_			this.configurationAttributes = configAttributes__		}_		return this.configurationAttributes__	};retrieve,the,link,transaction,configuration,attributes,for,the,supplied,link,test,context,whose,linkplain,class,test,class,may,optionally,declare,or,inherit,link,transaction,configuration,transaction,configuration,p,if,code,transaction,configuration,is,not,present,for,the,supplied,code,test,context,a,default,instance,of,code,transaction,configuration,attributes,will,be,used,instead,param,test,context,the,test,context,for,which,the,configuration,attributes,should,be,retrieved,return,the,transaction,configuration,attributes,instance,for,this,listener,potentially,cached,see,transaction,configuration,attributes,transaction,configuration,attributes;suppress,warnings,deprecation,transaction,configuration,attributes,retrieve,configuration,attributes,test,context,test,context,if,this,configuration,attributes,null,class,clazz,test,context,get,test,class,transaction,configuration,tx,config,annotated,element,utils,find,merged,annotation,clazz,transaction,configuration,class,if,logger,is,debug,enabled,logger,debug,string,format,retrieved,transaction,configuration,s,for,test,class,s,tx,config,clazz,get,name,transaction,configuration,attributes,config,attributes,tx,config,null,default,tx,config,attributes,new,transaction,configuration,attributes,tx,config,transaction,manager,tx,config,default,rollback,if,logger,is,debug,enabled,logger,debug,string,format,using,transaction,configuration,attributes,s,for,test,class,s,config,attributes,clazz,get,name,this,configuration,attributes,config,attributes,return,this,configuration,attributes
TransactionalTestExecutionListener -> @SuppressWarnings("deprecation") 	TransactionConfigurationAttributes retrieveConfigurationAttributes(TestContext testContext);1467730834;Retrieve the {@link TransactionConfigurationAttributes} for the_supplied {@link TestContext} whose {@linkplain Class test class}_may optionally declare or inherit_{@link TransactionConfiguration @TransactionConfiguration}._<p>If {@code @TransactionConfiguration} is not present for the_supplied {@code TestContext}, a default instance of_{@code TransactionConfigurationAttributes} will be used instead._@param testContext the test context for which the configuration_attributes should be retrieved_@return the TransactionConfigurationAttributes instance for this listener,_potentially cached_@see TransactionConfigurationAttributes#TransactionConfigurationAttributes();@SuppressWarnings("deprecation")_	TransactionConfigurationAttributes retrieveConfigurationAttributes(TestContext testContext) {_		if (this.configurationAttributes == null) {_			Class<?> clazz = testContext.getTestClass()___			TransactionConfiguration txConfig =_					AnnotatedElementUtils.findMergedAnnotation(clazz, TransactionConfiguration.class)__			if (logger.isDebugEnabled()) {_				logger.debug(String.format("Retrieved @TransactionConfiguration [%s] for test class [%s].",_						txConfig, clazz.getName()))__			}__			TransactionConfigurationAttributes configAttributes = (txConfig == null ? defaultTxConfigAttributes :_					new TransactionConfigurationAttributes(txConfig.transactionManager(), txConfig.defaultRollback()))__			if (logger.isDebugEnabled()) {_				logger.debug(String.format("Using TransactionConfigurationAttributes %s for test class [%s].",_						configAttributes, clazz.getName()))__			}_			this.configurationAttributes = configAttributes__		}_		return this.configurationAttributes__	};retrieve,the,link,transaction,configuration,attributes,for,the,supplied,link,test,context,whose,linkplain,class,test,class,may,optionally,declare,or,inherit,link,transaction,configuration,transaction,configuration,p,if,code,transaction,configuration,is,not,present,for,the,supplied,code,test,context,a,default,instance,of,code,transaction,configuration,attributes,will,be,used,instead,param,test,context,the,test,context,for,which,the,configuration,attributes,should,be,retrieved,return,the,transaction,configuration,attributes,instance,for,this,listener,potentially,cached,see,transaction,configuration,attributes,transaction,configuration,attributes;suppress,warnings,deprecation,transaction,configuration,attributes,retrieve,configuration,attributes,test,context,test,context,if,this,configuration,attributes,null,class,clazz,test,context,get,test,class,transaction,configuration,tx,config,annotated,element,utils,find,merged,annotation,clazz,transaction,configuration,class,if,logger,is,debug,enabled,logger,debug,string,format,retrieved,transaction,configuration,s,for,test,class,s,tx,config,clazz,get,name,transaction,configuration,attributes,config,attributes,tx,config,null,default,tx,config,attributes,new,transaction,configuration,attributes,tx,config,transaction,manager,tx,config,default,rollback,if,logger,is,debug,enabled,logger,debug,string,format,using,transaction,configuration,attributes,s,for,test,class,s,config,attributes,clazz,get,name,this,configuration,attributes,config,attributes,return,this,configuration,attributes
TransactionalTestExecutionListener -> @SuppressWarnings("deprecation") 	TransactionConfigurationAttributes retrieveConfigurationAttributes(TestContext testContext);1467992320;Retrieve the {@link TransactionConfigurationAttributes} for the_supplied {@link TestContext} whose {@linkplain Class test class}_may optionally declare or inherit_{@link TransactionConfiguration @TransactionConfiguration}._<p>If {@code @TransactionConfiguration} is not present for the_supplied {@code TestContext}, a default instance of_{@code TransactionConfigurationAttributes} will be used instead._@param testContext the test context for which the configuration_attributes should be retrieved_@return the TransactionConfigurationAttributes instance for this listener,_potentially cached_@see TransactionConfigurationAttributes#TransactionConfigurationAttributes();@SuppressWarnings("deprecation")_	TransactionConfigurationAttributes retrieveConfigurationAttributes(TestContext testContext) {_		if (this.configurationAttributes == null) {_			Class<?> clazz = testContext.getTestClass()___			TransactionConfiguration txConfig =_					AnnotatedElementUtils.findMergedAnnotation(clazz, TransactionConfiguration.class)__			if (logger.isDebugEnabled()) {_				logger.debug(String.format("Retrieved @TransactionConfiguration [%s] for test class [%s].",_						txConfig, clazz.getName()))__			}__			TransactionConfigurationAttributes configAttributes = (txConfig == null ? defaultTxConfigAttributes :_					new TransactionConfigurationAttributes(txConfig.transactionManager(), txConfig.defaultRollback()))__			if (logger.isDebugEnabled()) {_				logger.debug(String.format("Using TransactionConfigurationAttributes %s for test class [%s].",_						configAttributes, clazz.getName()))__			}_			this.configurationAttributes = configAttributes__		}_		return this.configurationAttributes__	};retrieve,the,link,transaction,configuration,attributes,for,the,supplied,link,test,context,whose,linkplain,class,test,class,may,optionally,declare,or,inherit,link,transaction,configuration,transaction,configuration,p,if,code,transaction,configuration,is,not,present,for,the,supplied,code,test,context,a,default,instance,of,code,transaction,configuration,attributes,will,be,used,instead,param,test,context,the,test,context,for,which,the,configuration,attributes,should,be,retrieved,return,the,transaction,configuration,attributes,instance,for,this,listener,potentially,cached,see,transaction,configuration,attributes,transaction,configuration,attributes;suppress,warnings,deprecation,transaction,configuration,attributes,retrieve,configuration,attributes,test,context,test,context,if,this,configuration,attributes,null,class,clazz,test,context,get,test,class,transaction,configuration,tx,config,annotated,element,utils,find,merged,annotation,clazz,transaction,configuration,class,if,logger,is,debug,enabled,logger,debug,string,format,retrieved,transaction,configuration,s,for,test,class,s,tx,config,clazz,get,name,transaction,configuration,attributes,config,attributes,tx,config,null,default,tx,config,attributes,new,transaction,configuration,attributes,tx,config,transaction,manager,tx,config,default,rollback,if,logger,is,debug,enabled,logger,debug,string,format,using,transaction,configuration,attributes,s,for,test,class,s,config,attributes,clazz,get,name,this,configuration,attributes,config,attributes,return,this,configuration,attributes
TransactionalTestExecutionListener -> @SuppressWarnings("deprecation") 	TransactionConfigurationAttributes retrieveConfigurationAttributes(TestContext testContext);1467992442;Retrieve the {@link TransactionConfigurationAttributes} for the_supplied {@link TestContext} whose {@linkplain Class test class}_may optionally declare or inherit_{@link TransactionConfiguration @TransactionConfiguration}._<p>If {@code @TransactionConfiguration} is not present for the_supplied {@code TestContext}, a default instance of_{@code TransactionConfigurationAttributes} will be used instead._@param testContext the test context for which the configuration_attributes should be retrieved_@return the TransactionConfigurationAttributes instance for this listener,_potentially cached_@see TransactionConfigurationAttributes#TransactionConfigurationAttributes();@SuppressWarnings("deprecation")_	TransactionConfigurationAttributes retrieveConfigurationAttributes(TestContext testContext) {_		if (this.configurationAttributes == null) {_			Class<?> clazz = testContext.getTestClass()___			TransactionConfiguration txConfig =_					AnnotatedElementUtils.findMergedAnnotation(clazz, TransactionConfiguration.class)__			if (logger.isDebugEnabled()) {_				logger.debug(String.format("Retrieved @TransactionConfiguration [%s] for test class [%s].",_						txConfig, clazz.getName()))__			}__			TransactionConfigurationAttributes configAttributes = (txConfig == null ? defaultTxConfigAttributes :_					new TransactionConfigurationAttributes(txConfig.transactionManager(), txConfig.defaultRollback()))__			if (logger.isDebugEnabled()) {_				logger.debug(String.format("Using TransactionConfigurationAttributes %s for test class [%s].",_						configAttributes, clazz.getName()))__			}_			this.configurationAttributes = configAttributes__		}_		return this.configurationAttributes__	};retrieve,the,link,transaction,configuration,attributes,for,the,supplied,link,test,context,whose,linkplain,class,test,class,may,optionally,declare,or,inherit,link,transaction,configuration,transaction,configuration,p,if,code,transaction,configuration,is,not,present,for,the,supplied,code,test,context,a,default,instance,of,code,transaction,configuration,attributes,will,be,used,instead,param,test,context,the,test,context,for,which,the,configuration,attributes,should,be,retrieved,return,the,transaction,configuration,attributes,instance,for,this,listener,potentially,cached,see,transaction,configuration,attributes,transaction,configuration,attributes;suppress,warnings,deprecation,transaction,configuration,attributes,retrieve,configuration,attributes,test,context,test,context,if,this,configuration,attributes,null,class,clazz,test,context,get,test,class,transaction,configuration,tx,config,annotated,element,utils,find,merged,annotation,clazz,transaction,configuration,class,if,logger,is,debug,enabled,logger,debug,string,format,retrieved,transaction,configuration,s,for,test,class,s,tx,config,clazz,get,name,transaction,configuration,attributes,config,attributes,tx,config,null,default,tx,config,attributes,new,transaction,configuration,attributes,tx,config,transaction,manager,tx,config,default,rollback,if,logger,is,debug,enabled,logger,debug,string,format,using,transaction,configuration,attributes,s,for,test,class,s,config,attributes,clazz,get,name,this,configuration,attributes,config,attributes,return,this,configuration,attributes
TransactionalTestExecutionListener -> TransactionConfigurationAttributes retrieveConfigurationAttributes(TestContext testContext);1385499540;Retrieves the {@link TransactionConfigurationAttributes} for the_specified {@link Class class} which may optionally declare or inherit_{@link TransactionConfiguration &#064_TransactionConfiguration}. If_{@code @TransactionConfiguration} is not present for the supplied_class, the <em>default values</em> for attributes defined in_{@code @TransactionConfiguration} will be used instead._@param testContext the test context for which the configuration_attributes should be retrieved_@return the TransactionConfigurationAttributes instance for this listener,_potentially cached;TransactionConfigurationAttributes retrieveConfigurationAttributes(TestContext testContext) {_		if (this.configurationAttributes == null) {_			Class<?> clazz = testContext.getTestClass()___			AnnotationAttributes annAttrs = AnnotatedElementUtils.getAnnotationAttributes(clazz,_				TransactionConfiguration.class.getName())__			if (logger.isDebugEnabled()) {_				logger.debug(String.format("Retrieved @TransactionConfiguration attributes [%s] for test class [%s].",_					annAttrs, clazz))__			}__			String transactionManagerName__			boolean defaultRollback__			if (annAttrs != null) {_				transactionManagerName = annAttrs.getString("transactionManager")__				defaultRollback = annAttrs.getBoolean("defaultRollback")__			}_			else {_				transactionManagerName = DEFAULT_TRANSACTION_MANAGER_NAME__				defaultRollback = DEFAULT_DEFAULT_ROLLBACK__			}__			TransactionConfigurationAttributes configAttributes = new TransactionConfigurationAttributes(_				transactionManagerName, defaultRollback)__			if (logger.isDebugEnabled()) {_				logger.debug(String.format("Retrieved TransactionConfigurationAttributes %s for class [%s].",_					configAttributes, clazz))__			}_			this.configurationAttributes = configAttributes__		}_		return this.configurationAttributes__	};retrieves,the,link,transaction,configuration,attributes,for,the,specified,link,class,class,which,may,optionally,declare,or,inherit,link,transaction,configuration,064,transaction,configuration,if,code,transaction,configuration,is,not,present,for,the,supplied,class,the,em,default,values,em,for,attributes,defined,in,code,transaction,configuration,will,be,used,instead,param,test,context,the,test,context,for,which,the,configuration,attributes,should,be,retrieved,return,the,transaction,configuration,attributes,instance,for,this,listener,potentially,cached;transaction,configuration,attributes,retrieve,configuration,attributes,test,context,test,context,if,this,configuration,attributes,null,class,clazz,test,context,get,test,class,annotation,attributes,ann,attrs,annotated,element,utils,get,annotation,attributes,clazz,transaction,configuration,class,get,name,if,logger,is,debug,enabled,logger,debug,string,format,retrieved,transaction,configuration,attributes,s,for,test,class,s,ann,attrs,clazz,string,transaction,manager,name,boolean,default,rollback,if,ann,attrs,null,transaction,manager,name,ann,attrs,get,string,transaction,manager,default,rollback,ann,attrs,get,boolean,default,rollback,else,transaction,manager,name,default,rollback,transaction,configuration,attributes,config,attributes,new,transaction,configuration,attributes,transaction,manager,name,default,rollback,if,logger,is,debug,enabled,logger,debug,string,format,retrieved,transaction,configuration,attributes,s,for,class,s,config,attributes,clazz,this,configuration,attributes,config,attributes,return,this,configuration,attributes
TransactionalTestExecutionListener -> TransactionConfigurationAttributes retrieveConfigurationAttributes(TestContext testContext);1389966876;Retrieves the {@link TransactionConfigurationAttributes} for the_specified {@link Class class} which may optionally declare or inherit_{@link TransactionConfiguration &#064_TransactionConfiguration}. If_{@code @TransactionConfiguration} is not present for the supplied_class, the <em>default values</em> for attributes defined in_{@code @TransactionConfiguration} will be used instead._@param testContext the test context for which the configuration_attributes should be retrieved_@return the TransactionConfigurationAttributes instance for this listener,_potentially cached;TransactionConfigurationAttributes retrieveConfigurationAttributes(TestContext testContext) {_		if (this.configurationAttributes == null) {_			Class<?> clazz = testContext.getTestClass()___			AnnotationAttributes annAttrs = AnnotatedElementUtils.getAnnotationAttributes(clazz,_				TransactionConfiguration.class.getName())__			if (logger.isDebugEnabled()) {_				logger.debug(String.format("Retrieved @TransactionConfiguration attributes [%s] for test class [%s].",_					annAttrs, clazz))__			}__			String transactionManagerName__			boolean defaultRollback__			if (annAttrs != null) {_				transactionManagerName = annAttrs.getString("transactionManager")__				defaultRollback = annAttrs.getBoolean("defaultRollback")__			}_			else {_				transactionManagerName = DEFAULT_TRANSACTION_MANAGER_NAME__				defaultRollback = DEFAULT_DEFAULT_ROLLBACK__			}__			TransactionConfigurationAttributes configAttributes = new TransactionConfigurationAttributes(_				transactionManagerName, defaultRollback)__			if (logger.isDebugEnabled()) {_				logger.debug(String.format("Retrieved TransactionConfigurationAttributes %s for class [%s].",_					configAttributes, clazz))__			}_			this.configurationAttributes = configAttributes__		}_		return this.configurationAttributes__	};retrieves,the,link,transaction,configuration,attributes,for,the,specified,link,class,class,which,may,optionally,declare,or,inherit,link,transaction,configuration,064,transaction,configuration,if,code,transaction,configuration,is,not,present,for,the,supplied,class,the,em,default,values,em,for,attributes,defined,in,code,transaction,configuration,will,be,used,instead,param,test,context,the,test,context,for,which,the,configuration,attributes,should,be,retrieved,return,the,transaction,configuration,attributes,instance,for,this,listener,potentially,cached;transaction,configuration,attributes,retrieve,configuration,attributes,test,context,test,context,if,this,configuration,attributes,null,class,clazz,test,context,get,test,class,annotation,attributes,ann,attrs,annotated,element,utils,get,annotation,attributes,clazz,transaction,configuration,class,get,name,if,logger,is,debug,enabled,logger,debug,string,format,retrieved,transaction,configuration,attributes,s,for,test,class,s,ann,attrs,clazz,string,transaction,manager,name,boolean,default,rollback,if,ann,attrs,null,transaction,manager,name,ann,attrs,get,string,transaction,manager,default,rollback,ann,attrs,get,boolean,default,rollback,else,transaction,manager,name,default,rollback,transaction,configuration,attributes,config,attributes,new,transaction,configuration,attributes,transaction,manager,name,default,rollback,if,logger,is,debug,enabled,logger,debug,string,format,retrieved,transaction,configuration,attributes,s,for,class,s,config,attributes,clazz,this,configuration,attributes,config,attributes,return,this,configuration,attributes
TransactionalTestExecutionListener -> TransactionConfigurationAttributes retrieveConfigurationAttributes(TestContext testContext);1401991965;Retrieves the {@link TransactionConfigurationAttributes} for the_specified {@link Class class} which may optionally declare or inherit_{@link TransactionConfiguration &#064_TransactionConfiguration}. If_{@code @TransactionConfiguration} is not present for the supplied_class, the <em>default values</em> for attributes defined in_{@code @TransactionConfiguration} will be used instead._@param testContext the test context for which the configuration_attributes should be retrieved_@return the TransactionConfigurationAttributes instance for this listener,_potentially cached;TransactionConfigurationAttributes retrieveConfigurationAttributes(TestContext testContext) {_		if (this.configurationAttributes == null) {_			Class<?> clazz = testContext.getTestClass()___			AnnotationAttributes annAttrs = AnnotatedElementUtils.getAnnotationAttributes(clazz,_				TransactionConfiguration.class.getName())__			if (logger.isDebugEnabled()) {_				logger.debug(String.format("Retrieved @TransactionConfiguration attributes [%s] for test class [%s].",_					annAttrs, clazz))__			}__			String transactionManagerName__			boolean defaultRollback__			if (annAttrs != null) {_				transactionManagerName = annAttrs.getString("transactionManager")__				defaultRollback = annAttrs.getBoolean("defaultRollback")__			}_			else {_				transactionManagerName = DEFAULT_TRANSACTION_MANAGER_NAME__				defaultRollback = DEFAULT_DEFAULT_ROLLBACK__			}__			TransactionConfigurationAttributes configAttributes = new TransactionConfigurationAttributes(_				transactionManagerName, defaultRollback)__			if (logger.isDebugEnabled()) {_				logger.debug(String.format("Retrieved TransactionConfigurationAttributes %s for class [%s].",_					configAttributes, clazz))__			}_			this.configurationAttributes = configAttributes__		}_		return this.configurationAttributes__	};retrieves,the,link,transaction,configuration,attributes,for,the,specified,link,class,class,which,may,optionally,declare,or,inherit,link,transaction,configuration,064,transaction,configuration,if,code,transaction,configuration,is,not,present,for,the,supplied,class,the,em,default,values,em,for,attributes,defined,in,code,transaction,configuration,will,be,used,instead,param,test,context,the,test,context,for,which,the,configuration,attributes,should,be,retrieved,return,the,transaction,configuration,attributes,instance,for,this,listener,potentially,cached;transaction,configuration,attributes,retrieve,configuration,attributes,test,context,test,context,if,this,configuration,attributes,null,class,clazz,test,context,get,test,class,annotation,attributes,ann,attrs,annotated,element,utils,get,annotation,attributes,clazz,transaction,configuration,class,get,name,if,logger,is,debug,enabled,logger,debug,string,format,retrieved,transaction,configuration,attributes,s,for,test,class,s,ann,attrs,clazz,string,transaction,manager,name,boolean,default,rollback,if,ann,attrs,null,transaction,manager,name,ann,attrs,get,string,transaction,manager,default,rollback,ann,attrs,get,boolean,default,rollback,else,transaction,manager,name,default,rollback,transaction,configuration,attributes,config,attributes,new,transaction,configuration,attributes,transaction,manager,name,default,rollback,if,logger,is,debug,enabled,logger,debug,string,format,retrieved,transaction,configuration,attributes,s,for,class,s,config,attributes,clazz,this,configuration,attributes,config,attributes,return,this,configuration,attributes
TransactionalTestExecutionListener -> TransactionConfigurationAttributes retrieveConfigurationAttributes(TestContext testContext);1404334604;Retrieves the {@link TransactionConfigurationAttributes} for the_specified {@link Class class} which may optionally declare or inherit_{@link TransactionConfiguration @TransactionConfiguration}. If_{@code @TransactionConfiguration} is not present for the supplied_class, the <em>default values</em> for attributes defined in_{@code @TransactionConfiguration} will be used instead._@param testContext the test context for which the configuration_attributes should be retrieved_@return the TransactionConfigurationAttributes instance for this listener,_potentially cached;TransactionConfigurationAttributes retrieveConfigurationAttributes(TestContext testContext) {_		if (this.configurationAttributes == null) {_			Class<?> clazz = testContext.getTestClass()___			AnnotationAttributes annAttrs = AnnotatedElementUtils.getAnnotationAttributes(clazz,_				TransactionConfiguration.class.getName())__			if (logger.isDebugEnabled()) {_				logger.debug(String.format("Retrieved @TransactionConfiguration attributes [%s] for test class [%s].",_					annAttrs, clazz))__			}__			String transactionManagerName__			boolean defaultRollback__			if (annAttrs != null) {_				transactionManagerName = annAttrs.getString("transactionManager")__				defaultRollback = annAttrs.getBoolean("defaultRollback")__			}_			else {_				transactionManagerName = DEFAULT_TRANSACTION_MANAGER_NAME__				defaultRollback = DEFAULT_DEFAULT_ROLLBACK__			}__			TransactionConfigurationAttributes configAttributes = new TransactionConfigurationAttributes(_				transactionManagerName, defaultRollback)__			if (logger.isDebugEnabled()) {_				logger.debug(String.format("Retrieved TransactionConfigurationAttributes %s for class [%s].",_					configAttributes, clazz))__			}_			this.configurationAttributes = configAttributes__		}_		return this.configurationAttributes__	};retrieves,the,link,transaction,configuration,attributes,for,the,specified,link,class,class,which,may,optionally,declare,or,inherit,link,transaction,configuration,transaction,configuration,if,code,transaction,configuration,is,not,present,for,the,supplied,class,the,em,default,values,em,for,attributes,defined,in,code,transaction,configuration,will,be,used,instead,param,test,context,the,test,context,for,which,the,configuration,attributes,should,be,retrieved,return,the,transaction,configuration,attributes,instance,for,this,listener,potentially,cached;transaction,configuration,attributes,retrieve,configuration,attributes,test,context,test,context,if,this,configuration,attributes,null,class,clazz,test,context,get,test,class,annotation,attributes,ann,attrs,annotated,element,utils,get,annotation,attributes,clazz,transaction,configuration,class,get,name,if,logger,is,debug,enabled,logger,debug,string,format,retrieved,transaction,configuration,attributes,s,for,test,class,s,ann,attrs,clazz,string,transaction,manager,name,boolean,default,rollback,if,ann,attrs,null,transaction,manager,name,ann,attrs,get,string,transaction,manager,default,rollback,ann,attrs,get,boolean,default,rollback,else,transaction,manager,name,default,rollback,transaction,configuration,attributes,config,attributes,new,transaction,configuration,attributes,transaction,manager,name,default,rollback,if,logger,is,debug,enabled,logger,debug,string,format,retrieved,transaction,configuration,attributes,s,for,class,s,config,attributes,clazz,this,configuration,attributes,config,attributes,return,this,configuration,attributes
TransactionalTestExecutionListener -> TransactionConfigurationAttributes retrieveConfigurationAttributes(TestContext testContext);1405645143;Retrieves the {@link TransactionConfigurationAttributes} for the_specified {@link Class class} which may optionally declare or inherit_{@link TransactionConfiguration @TransactionConfiguration}. If_{@code @TransactionConfiguration} is not present for the supplied_class, the <em>default values</em> for attributes defined in_{@code @TransactionConfiguration} will be used instead._@param testContext the test context for which the configuration_attributes should be retrieved_@return the TransactionConfigurationAttributes instance for this listener,_potentially cached;TransactionConfigurationAttributes retrieveConfigurationAttributes(TestContext testContext) {_		if (this.configurationAttributes == null) {_			Class<?> clazz = testContext.getTestClass()___			AnnotationAttributes annAttrs = AnnotatedElementUtils.getAnnotationAttributes(clazz,_				TransactionConfiguration.class.getName())__			if (logger.isDebugEnabled()) {_				logger.debug(String.format("Retrieved @TransactionConfiguration attributes [%s] for test class [%s].",_					annAttrs, clazz))__			}__			String transactionManagerName__			boolean defaultRollback__			if (annAttrs != null) {_				transactionManagerName = annAttrs.getString("transactionManager")__				defaultRollback = annAttrs.getBoolean("defaultRollback")__			}_			else {_				transactionManagerName = DEFAULT_TRANSACTION_MANAGER_NAME__				defaultRollback = DEFAULT_DEFAULT_ROLLBACK__			}__			TransactionConfigurationAttributes configAttributes = new TransactionConfigurationAttributes(_				transactionManagerName, defaultRollback)__			if (logger.isDebugEnabled()) {_				logger.debug(String.format("Retrieved TransactionConfigurationAttributes %s for class [%s].",_					configAttributes, clazz))__			}_			this.configurationAttributes = configAttributes__		}_		return this.configurationAttributes__	};retrieves,the,link,transaction,configuration,attributes,for,the,specified,link,class,class,which,may,optionally,declare,or,inherit,link,transaction,configuration,transaction,configuration,if,code,transaction,configuration,is,not,present,for,the,supplied,class,the,em,default,values,em,for,attributes,defined,in,code,transaction,configuration,will,be,used,instead,param,test,context,the,test,context,for,which,the,configuration,attributes,should,be,retrieved,return,the,transaction,configuration,attributes,instance,for,this,listener,potentially,cached;transaction,configuration,attributes,retrieve,configuration,attributes,test,context,test,context,if,this,configuration,attributes,null,class,clazz,test,context,get,test,class,annotation,attributes,ann,attrs,annotated,element,utils,get,annotation,attributes,clazz,transaction,configuration,class,get,name,if,logger,is,debug,enabled,logger,debug,string,format,retrieved,transaction,configuration,attributes,s,for,test,class,s,ann,attrs,clazz,string,transaction,manager,name,boolean,default,rollback,if,ann,attrs,null,transaction,manager,name,ann,attrs,get,string,transaction,manager,default,rollback,ann,attrs,get,boolean,default,rollback,else,transaction,manager,name,default,rollback,transaction,configuration,attributes,config,attributes,new,transaction,configuration,attributes,transaction,manager,name,default,rollback,if,logger,is,debug,enabled,logger,debug,string,format,retrieved,transaction,configuration,attributes,s,for,class,s,config,attributes,clazz,this,configuration,attributes,config,attributes,return,this,configuration,attributes
TransactionalTestExecutionListener -> TransactionConfigurationAttributes retrieveConfigurationAttributes(TestContext testContext);1405698612;Retrieves the {@link TransactionConfigurationAttributes} for the_specified {@link Class class} which may optionally declare or inherit_{@link TransactionConfiguration @TransactionConfiguration}. If_{@code @TransactionConfiguration} is not present for the supplied_class, the <em>default values</em> for attributes defined in_{@code @TransactionConfiguration} will be used instead._@param testContext the test context for which the configuration_attributes should be retrieved_@return the TransactionConfigurationAttributes instance for this listener,_potentially cached;TransactionConfigurationAttributes retrieveConfigurationAttributes(TestContext testContext) {_		if (this.configurationAttributes == null) {_			Class<?> clazz = testContext.getTestClass()___			AnnotationAttributes annAttrs = AnnotatedElementUtils.getAnnotationAttributes(clazz,_				TransactionConfiguration.class.getName())__			if (logger.isDebugEnabled()) {_				logger.debug(String.format("Retrieved @TransactionConfiguration attributes [%s] for test class [%s].",_					annAttrs, clazz))__			}__			String transactionManagerName__			boolean defaultRollback__			if (annAttrs != null) {_				transactionManagerName = annAttrs.getString("transactionManager")__				defaultRollback = annAttrs.getBoolean("defaultRollback")__			}_			else {_				transactionManagerName = DEFAULT_TRANSACTION_MANAGER_NAME__				defaultRollback = DEFAULT_DEFAULT_ROLLBACK__			}__			TransactionConfigurationAttributes configAttributes = new TransactionConfigurationAttributes(_				transactionManagerName, defaultRollback)__			if (logger.isDebugEnabled()) {_				logger.debug(String.format("Retrieved TransactionConfigurationAttributes %s for class [%s].",_					configAttributes, clazz))__			}_			this.configurationAttributes = configAttributes__		}_		return this.configurationAttributes__	};retrieves,the,link,transaction,configuration,attributes,for,the,specified,link,class,class,which,may,optionally,declare,or,inherit,link,transaction,configuration,transaction,configuration,if,code,transaction,configuration,is,not,present,for,the,supplied,class,the,em,default,values,em,for,attributes,defined,in,code,transaction,configuration,will,be,used,instead,param,test,context,the,test,context,for,which,the,configuration,attributes,should,be,retrieved,return,the,transaction,configuration,attributes,instance,for,this,listener,potentially,cached;transaction,configuration,attributes,retrieve,configuration,attributes,test,context,test,context,if,this,configuration,attributes,null,class,clazz,test,context,get,test,class,annotation,attributes,ann,attrs,annotated,element,utils,get,annotation,attributes,clazz,transaction,configuration,class,get,name,if,logger,is,debug,enabled,logger,debug,string,format,retrieved,transaction,configuration,attributes,s,for,test,class,s,ann,attrs,clazz,string,transaction,manager,name,boolean,default,rollback,if,ann,attrs,null,transaction,manager,name,ann,attrs,get,string,transaction,manager,default,rollback,ann,attrs,get,boolean,default,rollback,else,transaction,manager,name,default,rollback,transaction,configuration,attributes,config,attributes,new,transaction,configuration,attributes,transaction,manager,name,default,rollback,if,logger,is,debug,enabled,logger,debug,string,format,retrieved,transaction,configuration,attributes,s,for,class,s,config,attributes,clazz,this,configuration,attributes,config,attributes,return,this,configuration,attributes
TransactionalTestExecutionListener -> TransactionConfigurationAttributes retrieveConfigurationAttributes(TestContext testContext);1405759527;Retrieves the {@link TransactionConfigurationAttributes} for the_specified {@link Class class} which may optionally declare or inherit_{@link TransactionConfiguration @TransactionConfiguration}. If_{@code @TransactionConfiguration} is not present for the supplied_class, the <em>default values</em> for attributes defined in_{@code @TransactionConfiguration} will be used instead._@param testContext the test context for which the configuration_attributes should be retrieved_@return the TransactionConfigurationAttributes instance for this listener,_potentially cached;TransactionConfigurationAttributes retrieveConfigurationAttributes(TestContext testContext) {_		if (this.configurationAttributes == null) {_			Class<?> clazz = testContext.getTestClass()___			AnnotationAttributes annAttrs = AnnotatedElementUtils.getAnnotationAttributes(clazz,_				TransactionConfiguration.class.getName())__			if (logger.isDebugEnabled()) {_				logger.debug(String.format("Retrieved @TransactionConfiguration attributes [%s] for test class [%s].",_					annAttrs, clazz))__			}__			String transactionManagerName__			boolean defaultRollback__			if (annAttrs != null) {_				transactionManagerName = annAttrs.getString("transactionManager")__				defaultRollback = annAttrs.getBoolean("defaultRollback")__			}_			else {_				transactionManagerName = DEFAULT_TRANSACTION_MANAGER_NAME__				defaultRollback = DEFAULT_DEFAULT_ROLLBACK__			}__			TransactionConfigurationAttributes configAttributes = new TransactionConfigurationAttributes(_				transactionManagerName, defaultRollback)__			if (logger.isDebugEnabled()) {_				logger.debug(String.format("Retrieved TransactionConfigurationAttributes %s for class [%s].",_					configAttributes, clazz))__			}_			this.configurationAttributes = configAttributes__		}_		return this.configurationAttributes__	};retrieves,the,link,transaction,configuration,attributes,for,the,specified,link,class,class,which,may,optionally,declare,or,inherit,link,transaction,configuration,transaction,configuration,if,code,transaction,configuration,is,not,present,for,the,supplied,class,the,em,default,values,em,for,attributes,defined,in,code,transaction,configuration,will,be,used,instead,param,test,context,the,test,context,for,which,the,configuration,attributes,should,be,retrieved,return,the,transaction,configuration,attributes,instance,for,this,listener,potentially,cached;transaction,configuration,attributes,retrieve,configuration,attributes,test,context,test,context,if,this,configuration,attributes,null,class,clazz,test,context,get,test,class,annotation,attributes,ann,attrs,annotated,element,utils,get,annotation,attributes,clazz,transaction,configuration,class,get,name,if,logger,is,debug,enabled,logger,debug,string,format,retrieved,transaction,configuration,attributes,s,for,test,class,s,ann,attrs,clazz,string,transaction,manager,name,boolean,default,rollback,if,ann,attrs,null,transaction,manager,name,ann,attrs,get,string,transaction,manager,default,rollback,ann,attrs,get,boolean,default,rollback,else,transaction,manager,name,default,rollback,transaction,configuration,attributes,config,attributes,new,transaction,configuration,attributes,transaction,manager,name,default,rollback,if,logger,is,debug,enabled,logger,debug,string,format,retrieved,transaction,configuration,attributes,s,for,class,s,config,attributes,clazz,this,configuration,attributes,config,attributes,return,this,configuration,attributes
TransactionalTestExecutionListener -> TransactionConfigurationAttributes retrieveConfigurationAttributes(TestContext testContext);1405759966;Retrieves the {@link TransactionConfigurationAttributes} for the_specified {@link Class class} which may optionally declare or inherit_{@link TransactionConfiguration @TransactionConfiguration}. If_{@code @TransactionConfiguration} is not present for the supplied_class, the <em>default values</em> for attributes defined in_{@code @TransactionConfiguration} will be used instead._@param testContext the test context for which the configuration_attributes should be retrieved_@return the TransactionConfigurationAttributes instance for this listener,_potentially cached;TransactionConfigurationAttributes retrieveConfigurationAttributes(TestContext testContext) {_		if (this.configurationAttributes == null) {_			Class<?> clazz = testContext.getTestClass()___			AnnotationAttributes annAttrs = AnnotatedElementUtils.getAnnotationAttributes(clazz,_				TransactionConfiguration.class.getName())__			if (logger.isDebugEnabled()) {_				logger.debug(String.format("Retrieved @TransactionConfiguration attributes [%s] for test class [%s].",_					annAttrs, clazz))__			}__			String transactionManagerName__			boolean defaultRollback__			if (annAttrs != null) {_				transactionManagerName = annAttrs.getString("transactionManager")__				defaultRollback = annAttrs.getBoolean("defaultRollback")__			}_			else {_				transactionManagerName = DEFAULT_TRANSACTION_MANAGER_NAME__				defaultRollback = DEFAULT_DEFAULT_ROLLBACK__			}__			TransactionConfigurationAttributes configAttributes = new TransactionConfigurationAttributes(_				transactionManagerName, defaultRollback)__			if (logger.isDebugEnabled()) {_				logger.debug(String.format("Retrieved TransactionConfigurationAttributes %s for class [%s].",_					configAttributes, clazz))__			}_			this.configurationAttributes = configAttributes__		}_		return this.configurationAttributes__	};retrieves,the,link,transaction,configuration,attributes,for,the,specified,link,class,class,which,may,optionally,declare,or,inherit,link,transaction,configuration,transaction,configuration,if,code,transaction,configuration,is,not,present,for,the,supplied,class,the,em,default,values,em,for,attributes,defined,in,code,transaction,configuration,will,be,used,instead,param,test,context,the,test,context,for,which,the,configuration,attributes,should,be,retrieved,return,the,transaction,configuration,attributes,instance,for,this,listener,potentially,cached;transaction,configuration,attributes,retrieve,configuration,attributes,test,context,test,context,if,this,configuration,attributes,null,class,clazz,test,context,get,test,class,annotation,attributes,ann,attrs,annotated,element,utils,get,annotation,attributes,clazz,transaction,configuration,class,get,name,if,logger,is,debug,enabled,logger,debug,string,format,retrieved,transaction,configuration,attributes,s,for,test,class,s,ann,attrs,clazz,string,transaction,manager,name,boolean,default,rollback,if,ann,attrs,null,transaction,manager,name,ann,attrs,get,string,transaction,manager,default,rollback,ann,attrs,get,boolean,default,rollback,else,transaction,manager,name,default,rollback,transaction,configuration,attributes,config,attributes,new,transaction,configuration,attributes,transaction,manager,name,default,rollback,if,logger,is,debug,enabled,logger,debug,string,format,retrieved,transaction,configuration,attributes,s,for,class,s,config,attributes,clazz,this,configuration,attributes,config,attributes,return,this,configuration,attributes
TransactionalTestExecutionListener -> TransactionConfigurationAttributes retrieveConfigurationAttributes(TestContext testContext);1406218418;Retrieves the {@link TransactionConfigurationAttributes} for the_specified {@link Class class} which may optionally declare or inherit_{@link TransactionConfiguration @TransactionConfiguration}. If_{@code @TransactionConfiguration} is not present for the supplied_class, the <em>default values</em> for attributes defined in_{@code @TransactionConfiguration} will be used instead._@param testContext the test context for which the configuration_attributes should be retrieved_@return the TransactionConfigurationAttributes instance for this listener,_potentially cached;TransactionConfigurationAttributes retrieveConfigurationAttributes(TestContext testContext) {_		if (this.configurationAttributes == null) {_			Class<?> clazz = testContext.getTestClass()___			AnnotationAttributes annAttrs = AnnotatedElementUtils.getAnnotationAttributes(clazz,_				TransactionConfiguration.class.getName())__			if (logger.isDebugEnabled()) {_				logger.debug(String.format("Retrieved @TransactionConfiguration attributes [%s] for test class [%s].",_					annAttrs, clazz))__			}__			String transactionManagerName__			boolean defaultRollback__			if (annAttrs != null) {_				transactionManagerName = annAttrs.getString("transactionManager")__				defaultRollback = annAttrs.getBoolean("defaultRollback")__			}_			else {_				transactionManagerName = DEFAULT_TRANSACTION_MANAGER_NAME__				defaultRollback = DEFAULT_DEFAULT_ROLLBACK__			}__			TransactionConfigurationAttributes configAttributes = new TransactionConfigurationAttributes(_				transactionManagerName, defaultRollback)__			if (logger.isDebugEnabled()) {_				logger.debug(String.format("Retrieved TransactionConfigurationAttributes %s for class [%s].",_					configAttributes, clazz))__			}_			this.configurationAttributes = configAttributes__		}_		return this.configurationAttributes__	};retrieves,the,link,transaction,configuration,attributes,for,the,specified,link,class,class,which,may,optionally,declare,or,inherit,link,transaction,configuration,transaction,configuration,if,code,transaction,configuration,is,not,present,for,the,supplied,class,the,em,default,values,em,for,attributes,defined,in,code,transaction,configuration,will,be,used,instead,param,test,context,the,test,context,for,which,the,configuration,attributes,should,be,retrieved,return,the,transaction,configuration,attributes,instance,for,this,listener,potentially,cached;transaction,configuration,attributes,retrieve,configuration,attributes,test,context,test,context,if,this,configuration,attributes,null,class,clazz,test,context,get,test,class,annotation,attributes,ann,attrs,annotated,element,utils,get,annotation,attributes,clazz,transaction,configuration,class,get,name,if,logger,is,debug,enabled,logger,debug,string,format,retrieved,transaction,configuration,attributes,s,for,test,class,s,ann,attrs,clazz,string,transaction,manager,name,boolean,default,rollback,if,ann,attrs,null,transaction,manager,name,ann,attrs,get,string,transaction,manager,default,rollback,ann,attrs,get,boolean,default,rollback,else,transaction,manager,name,default,rollback,transaction,configuration,attributes,config,attributes,new,transaction,configuration,attributes,transaction,manager,name,default,rollback,if,logger,is,debug,enabled,logger,debug,string,format,retrieved,transaction,configuration,attributes,s,for,class,s,config,attributes,clazz,this,configuration,attributes,config,attributes,return,this,configuration,attributes
TransactionalTestExecutionListener -> TransactionConfigurationAttributes retrieveConfigurationAttributes(TestContext testContext);1407419079;Retrieves the {@link TransactionConfigurationAttributes} for the_specified {@link Class class} which may optionally declare or inherit_{@link TransactionConfiguration @TransactionConfiguration}. If_{@code @TransactionConfiguration} is not present for the supplied_class, the <em>default values</em> for attributes defined in_{@code @TransactionConfiguration} will be used instead._@param testContext the test context for which the configuration_attributes should be retrieved_@return the TransactionConfigurationAttributes instance for this listener,_potentially cached;TransactionConfigurationAttributes retrieveConfigurationAttributes(TestContext testContext) {_		if (this.configurationAttributes == null) {_			Class<?> clazz = testContext.getTestClass()___			AnnotationAttributes annAttrs = AnnotatedElementUtils.getAnnotationAttributes(clazz,_				TransactionConfiguration.class.getName())__			if (logger.isDebugEnabled()) {_				logger.debug(String.format("Retrieved @TransactionConfiguration attributes [%s] for test class [%s].",_					annAttrs, clazz))__			}__			String transactionManagerName__			boolean defaultRollback__			if (annAttrs != null) {_				transactionManagerName = annAttrs.getString("transactionManager")__				defaultRollback = annAttrs.getBoolean("defaultRollback")__			}_			else {_				transactionManagerName = DEFAULT_TRANSACTION_MANAGER_NAME__				defaultRollback = DEFAULT_DEFAULT_ROLLBACK__			}__			TransactionConfigurationAttributes configAttributes = new TransactionConfigurationAttributes(_				transactionManagerName, defaultRollback)__			if (logger.isDebugEnabled()) {_				logger.debug(String.format("Retrieved TransactionConfigurationAttributes %s for class [%s].",_					configAttributes, clazz))__			}_			this.configurationAttributes = configAttributes__		}_		return this.configurationAttributes__	};retrieves,the,link,transaction,configuration,attributes,for,the,specified,link,class,class,which,may,optionally,declare,or,inherit,link,transaction,configuration,transaction,configuration,if,code,transaction,configuration,is,not,present,for,the,supplied,class,the,em,default,values,em,for,attributes,defined,in,code,transaction,configuration,will,be,used,instead,param,test,context,the,test,context,for,which,the,configuration,attributes,should,be,retrieved,return,the,transaction,configuration,attributes,instance,for,this,listener,potentially,cached;transaction,configuration,attributes,retrieve,configuration,attributes,test,context,test,context,if,this,configuration,attributes,null,class,clazz,test,context,get,test,class,annotation,attributes,ann,attrs,annotated,element,utils,get,annotation,attributes,clazz,transaction,configuration,class,get,name,if,logger,is,debug,enabled,logger,debug,string,format,retrieved,transaction,configuration,attributes,s,for,test,class,s,ann,attrs,clazz,string,transaction,manager,name,boolean,default,rollback,if,ann,attrs,null,transaction,manager,name,ann,attrs,get,string,transaction,manager,default,rollback,ann,attrs,get,boolean,default,rollback,else,transaction,manager,name,default,rollback,transaction,configuration,attributes,config,attributes,new,transaction,configuration,attributes,transaction,manager,name,default,rollback,if,logger,is,debug,enabled,logger,debug,string,format,retrieved,transaction,configuration,attributes,s,for,class,s,config,attributes,clazz,this,configuration,attributes,config,attributes,return,this,configuration,attributes
TransactionalTestExecutionListener -> TransactionConfigurationAttributes retrieveConfigurationAttributes(TestContext testContext);1408048216;Retrieves the {@link TransactionConfigurationAttributes} for the_specified {@link Class class} which may optionally declare or inherit_{@link TransactionConfiguration @TransactionConfiguration}. If_{@code @TransactionConfiguration} is not present for the supplied_class, the <em>default values</em> for attributes defined in_{@code @TransactionConfiguration} will be used instead._@param testContext the test context for which the configuration_attributes should be retrieved_@return the TransactionConfigurationAttributes instance for this listener,_potentially cached;TransactionConfigurationAttributes retrieveConfigurationAttributes(TestContext testContext) {_		if (this.configurationAttributes == null) {_			Class<?> clazz = testContext.getTestClass()___			AnnotationAttributes annAttrs = AnnotatedElementUtils.getAnnotationAttributes(clazz,_				TransactionConfiguration.class.getName())__			if (logger.isDebugEnabled()) {_				logger.debug(String.format("Retrieved @TransactionConfiguration attributes [%s] for test class [%s].",_					annAttrs, clazz))__			}__			String transactionManagerName__			boolean defaultRollback__			if (annAttrs != null) {_				transactionManagerName = annAttrs.getString("transactionManager")__				defaultRollback = annAttrs.getBoolean("defaultRollback")__			}_			else {_				transactionManagerName = DEFAULT_TRANSACTION_MANAGER_NAME__				defaultRollback = DEFAULT_DEFAULT_ROLLBACK__			}__			TransactionConfigurationAttributes configAttributes = new TransactionConfigurationAttributes(_				transactionManagerName, defaultRollback)__			if (logger.isDebugEnabled()) {_				logger.debug(String.format("Retrieved TransactionConfigurationAttributes %s for class [%s].",_					configAttributes, clazz))__			}_			this.configurationAttributes = configAttributes__		}_		return this.configurationAttributes__	};retrieves,the,link,transaction,configuration,attributes,for,the,specified,link,class,class,which,may,optionally,declare,or,inherit,link,transaction,configuration,transaction,configuration,if,code,transaction,configuration,is,not,present,for,the,supplied,class,the,em,default,values,em,for,attributes,defined,in,code,transaction,configuration,will,be,used,instead,param,test,context,the,test,context,for,which,the,configuration,attributes,should,be,retrieved,return,the,transaction,configuration,attributes,instance,for,this,listener,potentially,cached;transaction,configuration,attributes,retrieve,configuration,attributes,test,context,test,context,if,this,configuration,attributes,null,class,clazz,test,context,get,test,class,annotation,attributes,ann,attrs,annotated,element,utils,get,annotation,attributes,clazz,transaction,configuration,class,get,name,if,logger,is,debug,enabled,logger,debug,string,format,retrieved,transaction,configuration,attributes,s,for,test,class,s,ann,attrs,clazz,string,transaction,manager,name,boolean,default,rollback,if,ann,attrs,null,transaction,manager,name,ann,attrs,get,string,transaction,manager,default,rollback,ann,attrs,get,boolean,default,rollback,else,transaction,manager,name,default,rollback,transaction,configuration,attributes,config,attributes,new,transaction,configuration,attributes,transaction,manager,name,default,rollback,if,logger,is,debug,enabled,logger,debug,string,format,retrieved,transaction,configuration,attributes,s,for,class,s,config,attributes,clazz,this,configuration,attributes,config,attributes,return,this,configuration,attributes
TransactionalTestExecutionListener -> TransactionConfigurationAttributes retrieveConfigurationAttributes(TestContext testContext);1413848647;Retrieves the {@link TransactionConfigurationAttributes} for the_specified {@link Class class} which may optionally declare or inherit_{@link TransactionConfiguration @TransactionConfiguration}. If_{@code @TransactionConfiguration} is not present for the supplied_class, the <em>default values</em> for attributes defined in_{@code @TransactionConfiguration} will be used instead._@param testContext the test context for which the configuration_attributes should be retrieved_@return the TransactionConfigurationAttributes instance for this listener,_potentially cached;TransactionConfigurationAttributes retrieveConfigurationAttributes(TestContext testContext) {_		if (this.configurationAttributes == null) {_			Class<?> clazz = testContext.getTestClass()___			AnnotationAttributes annAttrs = AnnotatedElementUtils.getAnnotationAttributes(clazz,_				TransactionConfiguration.class.getName())__			if (logger.isDebugEnabled()) {_				logger.debug(String.format("Retrieved @TransactionConfiguration attributes [%s] for test class [%s].",_					annAttrs, clazz))__			}__			String transactionManagerName__			boolean defaultRollback__			if (annAttrs != null) {_				transactionManagerName = annAttrs.getString("transactionManager")__				defaultRollback = annAttrs.getBoolean("defaultRollback")__			}_			else {_				transactionManagerName = DEFAULT_TRANSACTION_MANAGER_NAME__				defaultRollback = DEFAULT_DEFAULT_ROLLBACK__			}__			TransactionConfigurationAttributes configAttributes = new TransactionConfigurationAttributes(_				transactionManagerName, defaultRollback)__			if (logger.isDebugEnabled()) {_				logger.debug(String.format("Retrieved TransactionConfigurationAttributes %s for class [%s].",_					configAttributes, clazz))__			}_			this.configurationAttributes = configAttributes__		}_		return this.configurationAttributes__	};retrieves,the,link,transaction,configuration,attributes,for,the,specified,link,class,class,which,may,optionally,declare,or,inherit,link,transaction,configuration,transaction,configuration,if,code,transaction,configuration,is,not,present,for,the,supplied,class,the,em,default,values,em,for,attributes,defined,in,code,transaction,configuration,will,be,used,instead,param,test,context,the,test,context,for,which,the,configuration,attributes,should,be,retrieved,return,the,transaction,configuration,attributes,instance,for,this,listener,potentially,cached;transaction,configuration,attributes,retrieve,configuration,attributes,test,context,test,context,if,this,configuration,attributes,null,class,clazz,test,context,get,test,class,annotation,attributes,ann,attrs,annotated,element,utils,get,annotation,attributes,clazz,transaction,configuration,class,get,name,if,logger,is,debug,enabled,logger,debug,string,format,retrieved,transaction,configuration,attributes,s,for,test,class,s,ann,attrs,clazz,string,transaction,manager,name,boolean,default,rollback,if,ann,attrs,null,transaction,manager,name,ann,attrs,get,string,transaction,manager,default,rollback,ann,attrs,get,boolean,default,rollback,else,transaction,manager,name,default,rollback,transaction,configuration,attributes,config,attributes,new,transaction,configuration,attributes,transaction,manager,name,default,rollback,if,logger,is,debug,enabled,logger,debug,string,format,retrieved,transaction,configuration,attributes,s,for,class,s,config,attributes,clazz,this,configuration,attributes,config,attributes,return,this,configuration,attributes
TransactionalTestExecutionListener -> TransactionConfigurationAttributes retrieveConfigurationAttributes(TestContext testContext);1431568199;Retrieves the {@link TransactionConfigurationAttributes} for the_specified {@link Class class} which may optionally declare or inherit_{@link TransactionConfiguration @TransactionConfiguration}. If_{@code @TransactionConfiguration} is not present for the supplied_class, the <em>default values</em> for attributes defined in_{@code @TransactionConfiguration} will be used instead._@param testContext the test context for which the configuration_attributes should be retrieved_@return the TransactionConfigurationAttributes instance for this listener,_potentially cached;TransactionConfigurationAttributes retrieveConfigurationAttributes(TestContext testContext) {_		if (this.configurationAttributes == null) {_			Class<?> clazz = testContext.getTestClass()___			AnnotationAttributes annAttrs = AnnotatedElementUtils.findAnnotationAttributes(clazz,_				TransactionConfiguration.class.getName())__			if (logger.isDebugEnabled()) {_				logger.debug(String.format("Retrieved @TransactionConfiguration attributes [%s] for test class [%s].",_					annAttrs, clazz))__			}__			String transactionManagerName__			boolean defaultRollback__			if (annAttrs != null) {_				transactionManagerName = annAttrs.getString("transactionManager")__				defaultRollback = annAttrs.getBoolean("defaultRollback")__			}_			else {_				transactionManagerName = DEFAULT_TRANSACTION_MANAGER_NAME__				defaultRollback = DEFAULT_DEFAULT_ROLLBACK__			}__			TransactionConfigurationAttributes configAttributes = new TransactionConfigurationAttributes(_				transactionManagerName, defaultRollback)__			if (logger.isDebugEnabled()) {_				logger.debug(String.format("Retrieved TransactionConfigurationAttributes %s for class [%s].",_					configAttributes, clazz))__			}_			this.configurationAttributes = configAttributes__		}_		return this.configurationAttributes__	};retrieves,the,link,transaction,configuration,attributes,for,the,specified,link,class,class,which,may,optionally,declare,or,inherit,link,transaction,configuration,transaction,configuration,if,code,transaction,configuration,is,not,present,for,the,supplied,class,the,em,default,values,em,for,attributes,defined,in,code,transaction,configuration,will,be,used,instead,param,test,context,the,test,context,for,which,the,configuration,attributes,should,be,retrieved,return,the,transaction,configuration,attributes,instance,for,this,listener,potentially,cached;transaction,configuration,attributes,retrieve,configuration,attributes,test,context,test,context,if,this,configuration,attributes,null,class,clazz,test,context,get,test,class,annotation,attributes,ann,attrs,annotated,element,utils,find,annotation,attributes,clazz,transaction,configuration,class,get,name,if,logger,is,debug,enabled,logger,debug,string,format,retrieved,transaction,configuration,attributes,s,for,test,class,s,ann,attrs,clazz,string,transaction,manager,name,boolean,default,rollback,if,ann,attrs,null,transaction,manager,name,ann,attrs,get,string,transaction,manager,default,rollback,ann,attrs,get,boolean,default,rollback,else,transaction,manager,name,default,rollback,transaction,configuration,attributes,config,attributes,new,transaction,configuration,attributes,transaction,manager,name,default,rollback,if,logger,is,debug,enabled,logger,debug,string,format,retrieved,transaction,configuration,attributes,s,for,class,s,config,attributes,clazz,this,configuration,attributes,config,attributes,return,this,configuration,attributes
TransactionalTestExecutionListener -> TransactionConfigurationAttributes retrieveConfigurationAttributes(TestContext testContext);1432125256;Retrieves the {@link TransactionConfigurationAttributes} for the_specified {@link Class class} which may optionally declare or inherit_{@link TransactionConfiguration @TransactionConfiguration}. If_{@code @TransactionConfiguration} is not present for the supplied_class, the <em>default values</em> for attributes defined in_{@code @TransactionConfiguration} will be used instead._@param testContext the test context for which the configuration_attributes should be retrieved_@return the TransactionConfigurationAttributes instance for this listener,_potentially cached;TransactionConfigurationAttributes retrieveConfigurationAttributes(TestContext testContext) {_		if (this.configurationAttributes == null) {_			Class<?> clazz = testContext.getTestClass()___			AnnotationAttributes annAttrs = AnnotatedElementUtils.findAnnotationAttributes(clazz,_				TransactionConfiguration.class.getName())__			if (logger.isDebugEnabled()) {_				logger.debug(String.format("Retrieved @TransactionConfiguration attributes [%s] for test class [%s].",_					annAttrs, clazz))__			}__			String transactionManagerName__			boolean defaultRollback__			if (annAttrs != null) {_				transactionManagerName = annAttrs.getString("transactionManager")__				defaultRollback = annAttrs.getBoolean("defaultRollback")__			}_			else {_				transactionManagerName = DEFAULT_TRANSACTION_MANAGER_NAME__				defaultRollback = DEFAULT_DEFAULT_ROLLBACK__			}__			TransactionConfigurationAttributes configAttributes = new TransactionConfigurationAttributes(_				transactionManagerName, defaultRollback)__			if (logger.isDebugEnabled()) {_				logger.debug(String.format("Retrieved TransactionConfigurationAttributes %s for class [%s].",_					configAttributes, clazz))__			}_			this.configurationAttributes = configAttributes__		}_		return this.configurationAttributes__	};retrieves,the,link,transaction,configuration,attributes,for,the,specified,link,class,class,which,may,optionally,declare,or,inherit,link,transaction,configuration,transaction,configuration,if,code,transaction,configuration,is,not,present,for,the,supplied,class,the,em,default,values,em,for,attributes,defined,in,code,transaction,configuration,will,be,used,instead,param,test,context,the,test,context,for,which,the,configuration,attributes,should,be,retrieved,return,the,transaction,configuration,attributes,instance,for,this,listener,potentially,cached;transaction,configuration,attributes,retrieve,configuration,attributes,test,context,test,context,if,this,configuration,attributes,null,class,clazz,test,context,get,test,class,annotation,attributes,ann,attrs,annotated,element,utils,find,annotation,attributes,clazz,transaction,configuration,class,get,name,if,logger,is,debug,enabled,logger,debug,string,format,retrieved,transaction,configuration,attributes,s,for,test,class,s,ann,attrs,clazz,string,transaction,manager,name,boolean,default,rollback,if,ann,attrs,null,transaction,manager,name,ann,attrs,get,string,transaction,manager,default,rollback,ann,attrs,get,boolean,default,rollback,else,transaction,manager,name,default,rollback,transaction,configuration,attributes,config,attributes,new,transaction,configuration,attributes,transaction,manager,name,default,rollback,if,logger,is,debug,enabled,logger,debug,string,format,retrieved,transaction,configuration,attributes,s,for,class,s,config,attributes,clazz,this,configuration,attributes,config,attributes,return,this,configuration,attributes
TransactionalTestExecutionListener -> TransactionConfigurationAttributes retrieveConfigurationAttributes(TestContext testContext);1432856630;Retrieves the {@link TransactionConfigurationAttributes} for the_specified {@link Class class} which may optionally declare or inherit_{@link TransactionConfiguration @TransactionConfiguration}. If_{@code @TransactionConfiguration} is not present for the supplied_class, the <em>default values</em> for attributes defined in_{@code @TransactionConfiguration} will be used instead._@param testContext the test context for which the configuration_attributes should be retrieved_@return the TransactionConfigurationAttributes instance for this listener,_potentially cached;TransactionConfigurationAttributes retrieveConfigurationAttributes(TestContext testContext) {_		if (this.configurationAttributes == null) {_			Class<?> clazz = testContext.getTestClass()___			TransactionConfiguration txConfig = AnnotatedElementUtils.findAnnotation(clazz,_				TransactionConfiguration.class)__			if (logger.isDebugEnabled()) {_				logger.debug(String.format("Retrieved @TransactionConfiguration [%s] for test class [%s].",_					txConfig, clazz))__			}__			String transactionManagerName__			boolean defaultRollback__			if (txConfig != null) {_				transactionManagerName = txConfig.transactionManager()__				defaultRollback = txConfig.defaultRollback()__			}_			else {_				transactionManagerName = DEFAULT_TRANSACTION_MANAGER_NAME__				defaultRollback = DEFAULT_DEFAULT_ROLLBACK__			}__			TransactionConfigurationAttributes configAttributes = new TransactionConfigurationAttributes(_				transactionManagerName, defaultRollback)__			if (logger.isDebugEnabled()) {_				logger.debug(String.format("Retrieved TransactionConfigurationAttributes %s for class [%s].",_					configAttributes, clazz))__			}_			this.configurationAttributes = configAttributes__		}_		return this.configurationAttributes__	};retrieves,the,link,transaction,configuration,attributes,for,the,specified,link,class,class,which,may,optionally,declare,or,inherit,link,transaction,configuration,transaction,configuration,if,code,transaction,configuration,is,not,present,for,the,supplied,class,the,em,default,values,em,for,attributes,defined,in,code,transaction,configuration,will,be,used,instead,param,test,context,the,test,context,for,which,the,configuration,attributes,should,be,retrieved,return,the,transaction,configuration,attributes,instance,for,this,listener,potentially,cached;transaction,configuration,attributes,retrieve,configuration,attributes,test,context,test,context,if,this,configuration,attributes,null,class,clazz,test,context,get,test,class,transaction,configuration,tx,config,annotated,element,utils,find,annotation,clazz,transaction,configuration,class,if,logger,is,debug,enabled,logger,debug,string,format,retrieved,transaction,configuration,s,for,test,class,s,tx,config,clazz,string,transaction,manager,name,boolean,default,rollback,if,tx,config,null,transaction,manager,name,tx,config,transaction,manager,default,rollback,tx,config,default,rollback,else,transaction,manager,name,default,rollback,transaction,configuration,attributes,config,attributes,new,transaction,configuration,attributes,transaction,manager,name,default,rollback,if,logger,is,debug,enabled,logger,debug,string,format,retrieved,transaction,configuration,attributes,s,for,class,s,config,attributes,clazz,this,configuration,attributes,config,attributes,return,this,configuration,attributes
TransactionalTestExecutionListener -> TransactionConfigurationAttributes retrieveConfigurationAttributes(TestContext testContext);1434234880;Retrieves the {@link TransactionConfigurationAttributes} for the_specified {@link Class class} which may optionally declare or inherit_{@link TransactionConfiguration @TransactionConfiguration}. If_{@code @TransactionConfiguration} is not present for the supplied_class, the <em>default values</em> for attributes defined in_{@code @TransactionConfiguration} will be used instead._@param testContext the test context for which the configuration_attributes should be retrieved_@return the TransactionConfigurationAttributes instance for this listener,_potentially cached;TransactionConfigurationAttributes retrieveConfigurationAttributes(TestContext testContext) {_		if (this.configurationAttributes == null) {_			Class<?> clazz = testContext.getTestClass()___			TransactionConfiguration txConfig = AnnotatedElementUtils.findMergedAnnotation(clazz,_				TransactionConfiguration.class)__			if (logger.isDebugEnabled()) {_				logger.debug(String.format("Retrieved @TransactionConfiguration [%s] for test class [%s].",_					txConfig, clazz))__			}__			String transactionManagerName__			boolean defaultRollback__			if (txConfig != null) {_				transactionManagerName = txConfig.transactionManager()__				defaultRollback = txConfig.defaultRollback()__			}_			else {_				transactionManagerName = DEFAULT_TRANSACTION_MANAGER_NAME__				defaultRollback = DEFAULT_DEFAULT_ROLLBACK__			}__			TransactionConfigurationAttributes configAttributes = new TransactionConfigurationAttributes(_				transactionManagerName, defaultRollback)__			if (logger.isDebugEnabled()) {_				logger.debug(String.format("Retrieved TransactionConfigurationAttributes %s for class [%s].",_					configAttributes, clazz))__			}_			this.configurationAttributes = configAttributes__		}_		return this.configurationAttributes__	};retrieves,the,link,transaction,configuration,attributes,for,the,specified,link,class,class,which,may,optionally,declare,or,inherit,link,transaction,configuration,transaction,configuration,if,code,transaction,configuration,is,not,present,for,the,supplied,class,the,em,default,values,em,for,attributes,defined,in,code,transaction,configuration,will,be,used,instead,param,test,context,the,test,context,for,which,the,configuration,attributes,should,be,retrieved,return,the,transaction,configuration,attributes,instance,for,this,listener,potentially,cached;transaction,configuration,attributes,retrieve,configuration,attributes,test,context,test,context,if,this,configuration,attributes,null,class,clazz,test,context,get,test,class,transaction,configuration,tx,config,annotated,element,utils,find,merged,annotation,clazz,transaction,configuration,class,if,logger,is,debug,enabled,logger,debug,string,format,retrieved,transaction,configuration,s,for,test,class,s,tx,config,clazz,string,transaction,manager,name,boolean,default,rollback,if,tx,config,null,transaction,manager,name,tx,config,transaction,manager,default,rollback,tx,config,default,rollback,else,transaction,manager,name,default,rollback,transaction,configuration,attributes,config,attributes,new,transaction,configuration,attributes,transaction,manager,name,default,rollback,if,logger,is,debug,enabled,logger,debug,string,format,retrieved,transaction,configuration,attributes,s,for,class,s,config,attributes,clazz,this,configuration,attributes,config,attributes,return,this,configuration,attributes
TransactionalTestExecutionListener -> TransactionConfigurationAttributes retrieveConfigurationAttributes(TestContext testContext);1434720443;Retrieves the {@link TransactionConfigurationAttributes} for the_specified {@link Class class} which may optionally declare or inherit_{@link TransactionConfiguration @TransactionConfiguration}. If_{@code @TransactionConfiguration} is not present for the supplied_class, the <em>default values</em> for attributes defined in_{@code @TransactionConfiguration} will be used instead._@param testContext the test context for which the configuration_attributes should be retrieved_@return the TransactionConfigurationAttributes instance for this listener,_potentially cached;TransactionConfigurationAttributes retrieveConfigurationAttributes(TestContext testContext) {_		if (this.configurationAttributes == null) {_			Class<?> clazz = testContext.getTestClass()___			TransactionConfiguration txConfig = AnnotatedElementUtils.findMergedAnnotation(clazz,_				TransactionConfiguration.class)__			if (logger.isDebugEnabled()) {_				logger.debug(String.format("Retrieved @TransactionConfiguration [%s] for test class [%s].",_					txConfig, clazz))__			}__			if (txConfig == null) {_				txConfig = defaultTransactionConfiguration__			}__			TransactionConfigurationAttributes configAttributes = new TransactionConfigurationAttributes(_				txConfig.transactionManager(), txConfig.defaultRollback())__			if (logger.isDebugEnabled()) {_				logger.debug(String.format("Using TransactionConfigurationAttributes %s for class [%s].",_					configAttributes, clazz))__			}_			this.configurationAttributes = configAttributes__		}_		return this.configurationAttributes__	};retrieves,the,link,transaction,configuration,attributes,for,the,specified,link,class,class,which,may,optionally,declare,or,inherit,link,transaction,configuration,transaction,configuration,if,code,transaction,configuration,is,not,present,for,the,supplied,class,the,em,default,values,em,for,attributes,defined,in,code,transaction,configuration,will,be,used,instead,param,test,context,the,test,context,for,which,the,configuration,attributes,should,be,retrieved,return,the,transaction,configuration,attributes,instance,for,this,listener,potentially,cached;transaction,configuration,attributes,retrieve,configuration,attributes,test,context,test,context,if,this,configuration,attributes,null,class,clazz,test,context,get,test,class,transaction,configuration,tx,config,annotated,element,utils,find,merged,annotation,clazz,transaction,configuration,class,if,logger,is,debug,enabled,logger,debug,string,format,retrieved,transaction,configuration,s,for,test,class,s,tx,config,clazz,if,tx,config,null,tx,config,default,transaction,configuration,transaction,configuration,attributes,config,attributes,new,transaction,configuration,attributes,tx,config,transaction,manager,tx,config,default,rollback,if,logger,is,debug,enabled,logger,debug,string,format,using,transaction,configuration,attributes,s,for,class,s,config,attributes,clazz,this,configuration,attributes,config,attributes,return,this,configuration,attributes
TransactionalTestExecutionListener -> TransactionConfigurationAttributes retrieveConfigurationAttributes(TestContext testContext);1434817656;Retrieves the {@link TransactionConfigurationAttributes} for the_specified {@link Class class} which may optionally declare or inherit_{@link TransactionConfiguration @TransactionConfiguration}. If_{@code @TransactionConfiguration} is not present for the supplied_class, the <em>default values</em> for attributes defined in_{@code @TransactionConfiguration} will be used instead._@param testContext the test context for which the configuration_attributes should be retrieved_@return the TransactionConfigurationAttributes instance for this listener,_potentially cached;TransactionConfigurationAttributes retrieveConfigurationAttributes(TestContext testContext) {_		if (this.configurationAttributes == null) {_			Class<?> clazz = testContext.getTestClass()___			TransactionConfiguration txConfig = AnnotatedElementUtils.findMergedAnnotation(clazz,_				TransactionConfiguration.class)__			if (logger.isDebugEnabled()) {_				logger.debug(String.format("Retrieved @TransactionConfiguration [%s] for test class [%s].",_					txConfig, clazz))__			}__			if (txConfig == null) {_				txConfig = defaultTransactionConfiguration__			}__			TransactionConfigurationAttributes configAttributes = new TransactionConfigurationAttributes(_				txConfig.transactionManager(), txConfig.defaultRollback())__			if (logger.isDebugEnabled()) {_				logger.debug(String.format("Using TransactionConfigurationAttributes %s for class [%s].",_					configAttributes, clazz))__			}_			this.configurationAttributes = configAttributes__		}_		return this.configurationAttributes__	};retrieves,the,link,transaction,configuration,attributes,for,the,specified,link,class,class,which,may,optionally,declare,or,inherit,link,transaction,configuration,transaction,configuration,if,code,transaction,configuration,is,not,present,for,the,supplied,class,the,em,default,values,em,for,attributes,defined,in,code,transaction,configuration,will,be,used,instead,param,test,context,the,test,context,for,which,the,configuration,attributes,should,be,retrieved,return,the,transaction,configuration,attributes,instance,for,this,listener,potentially,cached;transaction,configuration,attributes,retrieve,configuration,attributes,test,context,test,context,if,this,configuration,attributes,null,class,clazz,test,context,get,test,class,transaction,configuration,tx,config,annotated,element,utils,find,merged,annotation,clazz,transaction,configuration,class,if,logger,is,debug,enabled,logger,debug,string,format,retrieved,transaction,configuration,s,for,test,class,s,tx,config,clazz,if,tx,config,null,tx,config,default,transaction,configuration,transaction,configuration,attributes,config,attributes,new,transaction,configuration,attributes,tx,config,transaction,manager,tx,config,default,rollback,if,logger,is,debug,enabled,logger,debug,string,format,using,transaction,configuration,attributes,s,for,class,s,config,attributes,clazz,this,configuration,attributes,config,attributes,return,this,configuration,attributes
TransactionalTestExecutionListener -> @Nullable 	protected PlatformTransactionManager getTransactionManager(TestContext testContext);1496955179;Get the {@linkplain PlatformTransactionManager transaction manager}_to use for the supplied {@linkplain TestContext test context}._<p>The default implementation simply delegates to_{@link TestContextTransactionUtils#retrieveTransactionManager}._@param testContext the test context for which the transaction manager_should be retrieved_@return the transaction manager to use, or {@code null} if not found_@throws BeansException if an error occurs while retrieving an explicitly_named transaction manager_@throws IllegalStateException if more than one TransactionManagementConfigurer_exists in the ApplicationContext_@see #getTransactionManager(TestContext, String);@Nullable_	protected PlatformTransactionManager getTransactionManager(TestContext testContext) {_		return TestContextTransactionUtils.retrieveTransactionManager(testContext, null)__	};get,the,linkplain,platform,transaction,manager,transaction,manager,to,use,for,the,supplied,linkplain,test,context,test,context,p,the,default,implementation,simply,delegates,to,link,test,context,transaction,utils,retrieve,transaction,manager,param,test,context,the,test,context,for,which,the,transaction,manager,should,be,retrieved,return,the,transaction,manager,to,use,or,code,null,if,not,found,throws,beans,exception,if,an,error,occurs,while,retrieving,an,explicitly,named,transaction,manager,throws,illegal,state,exception,if,more,than,one,transaction,management,configurer,exists,in,the,application,context,see,get,transaction,manager,test,context,string;nullable,protected,platform,transaction,manager,get,transaction,manager,test,context,test,context,return,test,context,transaction,utils,retrieve,transaction,manager,test,context,null
TransactionalTestExecutionListener -> @Nullable 	protected PlatformTransactionManager getTransactionManager(TestContext testContext);1498780456;Get the {@linkplain PlatformTransactionManager transaction manager}_to use for the supplied {@linkplain TestContext test context}._<p>The default implementation simply delegates to_{@link TestContextTransactionUtils#retrieveTransactionManager}._@param testContext the test context for which the transaction manager_should be retrieved_@return the transaction manager to use, or {@code null} if not found_@throws BeansException if an error occurs while retrieving an explicitly_named transaction manager_@throws IllegalStateException if more than one TransactionManagementConfigurer_exists in the ApplicationContext_@see #getTransactionManager(TestContext, String);@Nullable_	protected PlatformTransactionManager getTransactionManager(TestContext testContext) {_		return TestContextTransactionUtils.retrieveTransactionManager(testContext, null)__	};get,the,linkplain,platform,transaction,manager,transaction,manager,to,use,for,the,supplied,linkplain,test,context,test,context,p,the,default,implementation,simply,delegates,to,link,test,context,transaction,utils,retrieve,transaction,manager,param,test,context,the,test,context,for,which,the,transaction,manager,should,be,retrieved,return,the,transaction,manager,to,use,or,code,null,if,not,found,throws,beans,exception,if,an,error,occurs,while,retrieving,an,explicitly,named,transaction,manager,throws,illegal,state,exception,if,more,than,one,transaction,management,configurer,exists,in,the,application,context,see,get,transaction,manager,test,context,string;nullable,protected,platform,transaction,manager,get,transaction,manager,test,context,test,context,return,test,context,transaction,utils,retrieve,transaction,manager,test,context,null
TransactionalTestExecutionListener -> @Nullable 	protected PlatformTransactionManager getTransactionManager(TestContext testContext);1520251235;Get the {@linkplain PlatformTransactionManager transaction manager}_to use for the supplied {@linkplain TestContext test context}._<p>The default implementation simply delegates to_{@link TestContextTransactionUtils#retrieveTransactionManager}._@param testContext the test context for which the transaction manager_should be retrieved_@return the transaction manager to use, or {@code null} if not found_@throws BeansException if an error occurs while retrieving an explicitly_named transaction manager_@throws IllegalStateException if more than one TransactionManagementConfigurer_exists in the ApplicationContext_@see #getTransactionManager(TestContext, String);@Nullable_	protected PlatformTransactionManager getTransactionManager(TestContext testContext) {_		return TestContextTransactionUtils.retrieveTransactionManager(testContext, null)__	};get,the,linkplain,platform,transaction,manager,transaction,manager,to,use,for,the,supplied,linkplain,test,context,test,context,p,the,default,implementation,simply,delegates,to,link,test,context,transaction,utils,retrieve,transaction,manager,param,test,context,the,test,context,for,which,the,transaction,manager,should,be,retrieved,return,the,transaction,manager,to,use,or,code,null,if,not,found,throws,beans,exception,if,an,error,occurs,while,retrieving,an,explicitly,named,transaction,manager,throws,illegal,state,exception,if,more,than,one,transaction,management,configurer,exists,in,the,application,context,see,get,transaction,manager,test,context,string;nullable,protected,platform,transaction,manager,get,transaction,manager,test,context,test,context,return,test,context,transaction,utils,retrieve,transaction,manager,test,context,null
TransactionalTestExecutionListener -> @Override 	public void afterTestMethod(TestContext testContext) throws Exception;1328020251;If a transaction is currently active for the test method of the supplied_{@link TestContext test context}, this method will end the transaction_and run {@link AfterTransaction &#064_AfterTransaction methods}._<p>{@link AfterTransaction &#064_AfterTransaction methods} are guaranteed to be_invoked even if an error occurs while ending the transaction.;@Override_	public void afterTestMethod(TestContext testContext) throws Exception {_		Method testMethod = testContext.getTestMethod()__		Assert.notNull(testMethod, "The test method of the supplied TestContext must not be null")___		_		TransactionContext txContext = this.transactionContextCache.remove(testMethod)__		if (txContext != null && !txContext.transactionStatus.isCompleted()) {_			try {_				endTransaction(testContext, txContext)__			}_			finally {_				runAfterTransactionMethods(testContext)__			}_		}_	};if,a,transaction,is,currently,active,for,the,test,method,of,the,supplied,link,test,context,test,context,this,method,will,end,the,transaction,and,run,link,after,transaction,064,after,transaction,methods,p,link,after,transaction,064,after,transaction,methods,are,guaranteed,to,be,invoked,even,if,an,error,occurs,while,ending,the,transaction;override,public,void,after,test,method,test,context,test,context,throws,exception,method,test,method,test,context,get,test,method,assert,not,null,test,method,the,test,method,of,the,supplied,test,context,must,not,be,null,transaction,context,tx,context,this,transaction,context,cache,remove,test,method,if,tx,context,null,tx,context,transaction,status,is,completed,try,end,transaction,test,context,tx,context,finally,run,after,transaction,methods,test,context
TransactionalTestExecutionListener -> @Override 	public void afterTestMethod(TestContext testContext) throws Exception;1337516454;If a transaction is currently active for the test method of the supplied_{@link TestContext test context}, this method will end the transaction_and run {@link AfterTransaction &#064_AfterTransaction methods}._<p>{@link AfterTransaction &#064_AfterTransaction methods} are guaranteed to be_invoked even if an error occurs while ending the transaction.;@Override_	public void afterTestMethod(TestContext testContext) throws Exception {_		Method testMethod = testContext.getTestMethod()__		Assert.notNull(testMethod, "The test method of the supplied TestContext must not be null")___		_		TransactionContext txContext = this.transactionContextCache.remove(testMethod)__		if (txContext != null && !txContext.transactionStatus.isCompleted()) {_			try {_				endTransaction(testContext, txContext)__			}_			finally {_				runAfterTransactionMethods(testContext)__			}_		}_	};if,a,transaction,is,currently,active,for,the,test,method,of,the,supplied,link,test,context,test,context,this,method,will,end,the,transaction,and,run,link,after,transaction,064,after,transaction,methods,p,link,after,transaction,064,after,transaction,methods,are,guaranteed,to,be,invoked,even,if,an,error,occurs,while,ending,the,transaction;override,public,void,after,test,method,test,context,test,context,throws,exception,method,test,method,test,context,get,test,method,assert,not,null,test,method,the,test,method,of,the,supplied,test,context,must,not,be,null,transaction,context,tx,context,this,transaction,context,cache,remove,test,method,if,tx,context,null,tx,context,transaction,status,is,completed,try,end,transaction,test,context,tx,context,finally,run,after,transaction,methods,test,context
TransactionalTestExecutionListener -> @Override 	public void afterTestMethod(TestContext testContext) throws Exception;1338031377;If a transaction is currently active for the test method of the supplied_{@link TestContext test context}, this method will end the transaction_and run {@link AfterTransaction &#064_AfterTransaction methods}._<p>{@link AfterTransaction &#064_AfterTransaction methods} are guaranteed to be_invoked even if an error occurs while ending the transaction.;@Override_	public void afterTestMethod(TestContext testContext) throws Exception {_		Method testMethod = testContext.getTestMethod()__		Assert.notNull(testMethod, "The test method of the supplied TestContext must not be null")___		_		TransactionContext txContext = this.transactionContextCache.remove(testMethod)__		if (txContext != null && !txContext.transactionStatus.isCompleted()) {_			try {_				endTransaction(testContext, txContext)__			}_			finally {_				runAfterTransactionMethods(testContext)__			}_		}_	};if,a,transaction,is,currently,active,for,the,test,method,of,the,supplied,link,test,context,test,context,this,method,will,end,the,transaction,and,run,link,after,transaction,064,after,transaction,methods,p,link,after,transaction,064,after,transaction,methods,are,guaranteed,to,be,invoked,even,if,an,error,occurs,while,ending,the,transaction;override,public,void,after,test,method,test,context,test,context,throws,exception,method,test,method,test,context,get,test,method,assert,not,null,test,method,the,test,method,of,the,supplied,test,context,must,not,be,null,transaction,context,tx,context,this,transaction,context,cache,remove,test,method,if,tx,context,null,tx,context,transaction,status,is,completed,try,end,transaction,test,context,tx,context,finally,run,after,transaction,methods,test,context
TransactionalTestExecutionListener -> @Override 	public void afterTestMethod(TestContext testContext) throws Exception;1343426806;If a transaction is currently active for the test method of the supplied_{@link TestContext test context}, this method will end the transaction_and run {@link AfterTransaction &#064_AfterTransaction methods}._<p>{@code AfterTransaction &#064_AfterTransaction methods} are guaranteed to be_invoked even if an error occurs while ending the transaction.;@Override_	public void afterTestMethod(TestContext testContext) throws Exception {_		Method testMethod = testContext.getTestMethod()__		Assert.notNull(testMethod, "The test method of the supplied TestContext must not be null")___		_		TransactionContext txContext = this.transactionContextCache.remove(testMethod)__		if (txContext != null && !txContext.transactionStatus.isCompleted()) {_			try {_				endTransaction(testContext, txContext)__			}_			finally {_				runAfterTransactionMethods(testContext)__			}_		}_	};if,a,transaction,is,currently,active,for,the,test,method,of,the,supplied,link,test,context,test,context,this,method,will,end,the,transaction,and,run,link,after,transaction,064,after,transaction,methods,p,code,after,transaction,064,after,transaction,methods,are,guaranteed,to,be,invoked,even,if,an,error,occurs,while,ending,the,transaction;override,public,void,after,test,method,test,context,test,context,throws,exception,method,test,method,test,context,get,test,method,assert,not,null,test,method,the,test,method,of,the,supplied,test,context,must,not,be,null,transaction,context,tx,context,this,transaction,context,cache,remove,test,method,if,tx,context,null,tx,context,transaction,status,is,completed,try,end,transaction,test,context,tx,context,finally,run,after,transaction,methods,test,context
TransactionalTestExecutionListener -> @Override 	public void afterTestMethod(TestContext testContext) throws Exception;1343431472;If a transaction is currently active for the test method of the supplied_{@link TestContext test context}, this method will end the transaction_and run {@link AfterTransaction &#064_AfterTransaction methods}._<p>{@code AfterTransaction &#064_AfterTransaction methods} are guaranteed to be_invoked even if an error occurs while ending the transaction.;@Override_	public void afterTestMethod(TestContext testContext) throws Exception {_		Method testMethod = testContext.getTestMethod()__		Assert.notNull(testMethod, "The test method of the supplied TestContext must not be null")___		_		TransactionContext txContext = this.transactionContextCache.remove(testMethod)__		if (txContext != null && !txContext.transactionStatus.isCompleted()) {_			try {_				endTransaction(testContext, txContext)__			}_			finally {_				runAfterTransactionMethods(testContext)__			}_		}_	};if,a,transaction,is,currently,active,for,the,test,method,of,the,supplied,link,test,context,test,context,this,method,will,end,the,transaction,and,run,link,after,transaction,064,after,transaction,methods,p,code,after,transaction,064,after,transaction,methods,are,guaranteed,to,be,invoked,even,if,an,error,occurs,while,ending,the,transaction;override,public,void,after,test,method,test,context,test,context,throws,exception,method,test,method,test,context,get,test,method,assert,not,null,test,method,the,test,method,of,the,supplied,test,context,must,not,be,null,transaction,context,tx,context,this,transaction,context,cache,remove,test,method,if,tx,context,null,tx,context,transaction,status,is,completed,try,end,transaction,test,context,tx,context,finally,run,after,transaction,methods,test,context
TransactionalTestExecutionListener -> @Override 	public void afterTestMethod(TestContext testContext) throws Exception;1354571539;If a transaction is currently active for the test method of the supplied_{@link TestContext test context}, this method will end the transaction_and run {@link AfterTransaction &#064_AfterTransaction methods}._<p>{@code @AfterTransaction} methods are guaranteed to be_invoked even if an error occurs while ending the transaction.;@Override_	public void afterTestMethod(TestContext testContext) throws Exception {_		Method testMethod = testContext.getTestMethod()__		Assert.notNull(testMethod, "The test method of the supplied TestContext must not be null")___		_		TransactionContext txContext = this.transactionContextCache.remove(testMethod)__		if (txContext != null && !txContext.transactionStatus.isCompleted()) {_			try {_				endTransaction(testContext, txContext)__			}_			finally {_				runAfterTransactionMethods(testContext)__			}_		}_	};if,a,transaction,is,currently,active,for,the,test,method,of,the,supplied,link,test,context,test,context,this,method,will,end,the,transaction,and,run,link,after,transaction,064,after,transaction,methods,p,code,after,transaction,methods,are,guaranteed,to,be,invoked,even,if,an,error,occurs,while,ending,the,transaction;override,public,void,after,test,method,test,context,test,context,throws,exception,method,test,method,test,context,get,test,method,assert,not,null,test,method,the,test,method,of,the,supplied,test,context,must,not,be,null,transaction,context,tx,context,this,transaction,context,cache,remove,test,method,if,tx,context,null,tx,context,transaction,status,is,completed,try,end,transaction,test,context,tx,context,finally,run,after,transaction,methods,test,context
TransactionalTestExecutionListener -> @Override 	public void afterTestMethod(TestContext testContext) throws Exception;1355352386;If a transaction is currently active for the test method of the supplied_{@link TestContext test context}, this method will end the transaction_and run {@link AfterTransaction &#064_AfterTransaction methods}._<p>{@code @AfterTransaction} methods are guaranteed to be_invoked even if an error occurs while ending the transaction.;@Override_	public void afterTestMethod(TestContext testContext) throws Exception {_		Method testMethod = testContext.getTestMethod()__		Assert.notNull(testMethod, "The test method of the supplied TestContext must not be null")___		_		TransactionContext txContext = this.transactionContextCache.remove(testMethod)__		if (txContext != null && !txContext.transactionStatus.isCompleted()) {_			try {_				endTransaction(testContext, txContext)__			}_			finally {_				runAfterTransactionMethods(testContext)__			}_		}_	};if,a,transaction,is,currently,active,for,the,test,method,of,the,supplied,link,test,context,test,context,this,method,will,end,the,transaction,and,run,link,after,transaction,064,after,transaction,methods,p,code,after,transaction,methods,are,guaranteed,to,be,invoked,even,if,an,error,occurs,while,ending,the,transaction;override,public,void,after,test,method,test,context,test,context,throws,exception,method,test,method,test,context,get,test,method,assert,not,null,test,method,the,test,method,of,the,supplied,test,context,must,not,be,null,transaction,context,tx,context,this,transaction,context,cache,remove,test,method,if,tx,context,null,tx,context,transaction,status,is,completed,try,end,transaction,test,context,tx,context,finally,run,after,transaction,methods,test,context
TransactionalTestExecutionListener -> @Override 	public void afterTestMethod(TestContext testContext) throws Exception;1356735495;If a transaction is currently active for the test method of the supplied_{@link TestContext test context}, this method will end the transaction_and run {@link AfterTransaction &#064_AfterTransaction methods}._<p>{@code @AfterTransaction} methods are guaranteed to be_invoked even if an error occurs while ending the transaction.;@Override_	public void afterTestMethod(TestContext testContext) throws Exception {_		Method testMethod = testContext.getTestMethod()__		Assert.notNull(testMethod, "The test method of the supplied TestContext must not be null")___		_		TransactionContext txContext = this.transactionContextCache.remove(testMethod)__		if (txContext != null && !txContext.transactionStatus.isCompleted()) {_			try {_				endTransaction(testContext, txContext)__			}_			finally {_				runAfterTransactionMethods(testContext)__			}_		}_	};if,a,transaction,is,currently,active,for,the,test,method,of,the,supplied,link,test,context,test,context,this,method,will,end,the,transaction,and,run,link,after,transaction,064,after,transaction,methods,p,code,after,transaction,methods,are,guaranteed,to,be,invoked,even,if,an,error,occurs,while,ending,the,transaction;override,public,void,after,test,method,test,context,test,context,throws,exception,method,test,method,test,context,get,test,method,assert,not,null,test,method,the,test,method,of,the,supplied,test,context,must,not,be,null,transaction,context,tx,context,this,transaction,context,cache,remove,test,method,if,tx,context,null,tx,context,transaction,status,is,completed,try,end,transaction,test,context,tx,context,finally,run,after,transaction,methods,test,context
TransactionalTestExecutionListener -> @Override 	public void afterTestMethod(TestContext testContext) throws Exception;1357119239;If a transaction is currently active for the test method of the supplied_{@link TestContext test context}, this method will end the transaction_and run {@link AfterTransaction &#064_AfterTransaction methods}._<p>{@code @AfterTransaction} methods are guaranteed to be_invoked even if an error occurs while ending the transaction.;@Override_	public void afterTestMethod(TestContext testContext) throws Exception {_		Method testMethod = testContext.getTestMethod()__		Assert.notNull(testMethod, "The test method of the supplied TestContext must not be null")___		_		TransactionContext txContext = this.transactionContextCache.remove(testMethod)__		if (txContext != null && !txContext.transactionStatus.isCompleted()) {_			try {_				endTransaction(testContext, txContext)__			}_			finally {_				runAfterTransactionMethods(testContext)__			}_		}_	};if,a,transaction,is,currently,active,for,the,test,method,of,the,supplied,link,test,context,test,context,this,method,will,end,the,transaction,and,run,link,after,transaction,064,after,transaction,methods,p,code,after,transaction,methods,are,guaranteed,to,be,invoked,even,if,an,error,occurs,while,ending,the,transaction;override,public,void,after,test,method,test,context,test,context,throws,exception,method,test,method,test,context,get,test,method,assert,not,null,test,method,the,test,method,of,the,supplied,test,context,must,not,be,null,transaction,context,tx,context,this,transaction,context,cache,remove,test,method,if,tx,context,null,tx,context,transaction,status,is,completed,try,end,transaction,test,context,tx,context,finally,run,after,transaction,methods,test,context
TransactionalTestExecutionListener -> @Override 	public void afterTestMethod(TestContext testContext) throws Exception;1367163114;If a transaction is currently active for the test method of the supplied_{@link TestContext test context}, this method will end the transaction_and run {@link AfterTransaction &#064_AfterTransaction methods}._<p>{@code @AfterTransaction} methods are guaranteed to be_invoked even if an error occurs while ending the transaction.;@Override_	public void afterTestMethod(TestContext testContext) throws Exception {_		Method testMethod = testContext.getTestMethod()__		Assert.notNull(testMethod, "The test method of the supplied TestContext must not be null")___		_		TransactionContext txContext = this.transactionContextCache.remove(testMethod)__		if (txContext != null && !txContext.transactionStatus.isCompleted()) {_			try {_				endTransaction(testContext, txContext)__			}_			finally {_				runAfterTransactionMethods(testContext)__			}_		}_	};if,a,transaction,is,currently,active,for,the,test,method,of,the,supplied,link,test,context,test,context,this,method,will,end,the,transaction,and,run,link,after,transaction,064,after,transaction,methods,p,code,after,transaction,methods,are,guaranteed,to,be,invoked,even,if,an,error,occurs,while,ending,the,transaction;override,public,void,after,test,method,test,context,test,context,throws,exception,method,test,method,test,context,get,test,method,assert,not,null,test,method,the,test,method,of,the,supplied,test,context,must,not,be,null,transaction,context,tx,context,this,transaction,context,cache,remove,test,method,if,tx,context,null,tx,context,transaction,status,is,completed,try,end,transaction,test,context,tx,context,finally,run,after,transaction,methods,test,context
TransactionalTestExecutionListener -> @Override 	public void afterTestMethod(TestContext testContext) throws Exception;1367873075;If a transaction is currently active for the test method of the supplied_{@link TestContext test context}, this method will end the transaction_and run {@link AfterTransaction &#064_AfterTransaction methods}._<p>{@code @AfterTransaction} methods are guaranteed to be_invoked even if an error occurs while ending the transaction.;@Override_	public void afterTestMethod(TestContext testContext) throws Exception {_		Method testMethod = testContext.getTestMethod()__		Assert.notNull(testMethod, "The test method of the supplied TestContext must not be null")___		_		TransactionContext txContext = this.transactionContextCache.remove(testMethod)__		if (txContext != null && !txContext.transactionStatus.isCompleted()) {_			try {_				endTransaction(testContext, txContext)__			}_			finally {_				runAfterTransactionMethods(testContext)__			}_		}_	};if,a,transaction,is,currently,active,for,the,test,method,of,the,supplied,link,test,context,test,context,this,method,will,end,the,transaction,and,run,link,after,transaction,064,after,transaction,methods,p,code,after,transaction,methods,are,guaranteed,to,be,invoked,even,if,an,error,occurs,while,ending,the,transaction;override,public,void,after,test,method,test,context,test,context,throws,exception,method,test,method,test,context,get,test,method,assert,not,null,test,method,the,test,method,of,the,supplied,test,context,must,not,be,null,transaction,context,tx,context,this,transaction,context,cache,remove,test,method,if,tx,context,null,tx,context,transaction,status,is,completed,try,end,transaction,test,context,tx,context,finally,run,after,transaction,methods,test,context
TransactionalTestExecutionListener -> @Override 	public void afterTestMethod(TestContext testContext) throws Exception;1368482696;If a transaction is currently active for the test method of the supplied_{@link TestContext test context}, this method will end the transaction_and run {@link AfterTransaction &#064_AfterTransaction methods}._<p>{@code @AfterTransaction} methods are guaranteed to be_invoked even if an error occurs while ending the transaction.;@Override_	public void afterTestMethod(TestContext testContext) throws Exception {_		Method testMethod = testContext.getTestMethod()__		Assert.notNull(testMethod, "The test method of the supplied TestContext must not be null")___		_		TransactionContext txContext = this.transactionContextCache.remove(testMethod)__		if (txContext != null && !txContext.transactionStatus.isCompleted()) {_			try {_				endTransaction(testContext, txContext)__			}_			finally {_				runAfterTransactionMethods(testContext)__			}_		}_	};if,a,transaction,is,currently,active,for,the,test,method,of,the,supplied,link,test,context,test,context,this,method,will,end,the,transaction,and,run,link,after,transaction,064,after,transaction,methods,p,code,after,transaction,methods,are,guaranteed,to,be,invoked,even,if,an,error,occurs,while,ending,the,transaction;override,public,void,after,test,method,test,context,test,context,throws,exception,method,test,method,test,context,get,test,method,assert,not,null,test,method,the,test,method,of,the,supplied,test,context,must,not,be,null,transaction,context,tx,context,this,transaction,context,cache,remove,test,method,if,tx,context,null,tx,context,transaction,status,is,completed,try,end,transaction,test,context,tx,context,finally,run,after,transaction,methods,test,context
TransactionalTestExecutionListener -> @Override 	public void afterTestMethod(TestContext testContext) throws Exception;1382920864;If a transaction is currently active for the test method of the supplied_{@link TestContext test context}, this method will end the transaction_and run {@link AfterTransaction &#064_AfterTransaction methods}._<p>{@code @AfterTransaction} methods are guaranteed to be_invoked even if an error occurs while ending the transaction.;@Override_	public void afterTestMethod(TestContext testContext) throws Exception {_		Method testMethod = testContext.getTestMethod()__		Assert.notNull(testMethod, "The test method of the supplied TestContext must not be null")___		_		TransactionContext txContext = this.transactionContextCache.remove(testMethod)__		if (txContext != null && !txContext.transactionStatus.isCompleted()) {_			try {_				endTransaction(testContext, txContext)__			}_			finally {_				runAfterTransactionMethods(testContext)__			}_		}_	};if,a,transaction,is,currently,active,for,the,test,method,of,the,supplied,link,test,context,test,context,this,method,will,end,the,transaction,and,run,link,after,transaction,064,after,transaction,methods,p,code,after,transaction,methods,are,guaranteed,to,be,invoked,even,if,an,error,occurs,while,ending,the,transaction;override,public,void,after,test,method,test,context,test,context,throws,exception,method,test,method,test,context,get,test,method,assert,not,null,test,method,the,test,method,of,the,supplied,test,context,must,not,be,null,transaction,context,tx,context,this,transaction,context,cache,remove,test,method,if,tx,context,null,tx,context,transaction,status,is,completed,try,end,transaction,test,context,tx,context,finally,run,after,transaction,methods,test,context
TransactionalTestExecutionListener -> @Override 	public void afterTestMethod(TestContext testContext) throws Exception;1385499540;If a transaction is currently active for the test method of the supplied_{@link TestContext test context}, this method will end the transaction_and run {@link AfterTransaction &#064_AfterTransaction methods}._<p>{@code @AfterTransaction} methods are guaranteed to be_invoked even if an error occurs while ending the transaction.;@Override_	public void afterTestMethod(TestContext testContext) throws Exception {_		Method testMethod = testContext.getTestMethod()__		Assert.notNull(testMethod, "The test method of the supplied TestContext must not be null")___		_		TransactionContext txContext = this.transactionContextCache.remove(testMethod)__		if (txContext != null && !txContext.transactionStatus.isCompleted()) {_			try {_				endTransaction(testContext, txContext)__			}_			finally {_				runAfterTransactionMethods(testContext)__			}_		}_	};if,a,transaction,is,currently,active,for,the,test,method,of,the,supplied,link,test,context,test,context,this,method,will,end,the,transaction,and,run,link,after,transaction,064,after,transaction,methods,p,code,after,transaction,methods,are,guaranteed,to,be,invoked,even,if,an,error,occurs,while,ending,the,transaction;override,public,void,after,test,method,test,context,test,context,throws,exception,method,test,method,test,context,get,test,method,assert,not,null,test,method,the,test,method,of,the,supplied,test,context,must,not,be,null,transaction,context,tx,context,this,transaction,context,cache,remove,test,method,if,tx,context,null,tx,context,transaction,status,is,completed,try,end,transaction,test,context,tx,context,finally,run,after,transaction,methods,test,context
TransactionalTestExecutionListener -> @Override 	public void afterTestMethod(TestContext testContext) throws Exception;1389966876;If a transaction is currently active for the test method of the supplied_{@link TestContext test context}, this method will end the transaction_and run {@link AfterTransaction &#064_AfterTransaction methods}._<p>{@code @AfterTransaction} methods are guaranteed to be_invoked even if an error occurs while ending the transaction.;@Override_	public void afterTestMethod(TestContext testContext) throws Exception {_		Method testMethod = testContext.getTestMethod()__		Assert.notNull(testMethod, "The test method of the supplied TestContext must not be null")___		_		TransactionContext txContext = this.transactionContextCache.remove(testMethod)__		if (txContext != null && !txContext.transactionStatus.isCompleted()) {_			try {_				endTransaction(testContext, txContext)__			}_			finally {_				runAfterTransactionMethods(testContext)__			}_		}_	};if,a,transaction,is,currently,active,for,the,test,method,of,the,supplied,link,test,context,test,context,this,method,will,end,the,transaction,and,run,link,after,transaction,064,after,transaction,methods,p,code,after,transaction,methods,are,guaranteed,to,be,invoked,even,if,an,error,occurs,while,ending,the,transaction;override,public,void,after,test,method,test,context,test,context,throws,exception,method,test,method,test,context,get,test,method,assert,not,null,test,method,the,test,method,of,the,supplied,test,context,must,not,be,null,transaction,context,tx,context,this,transaction,context,cache,remove,test,method,if,tx,context,null,tx,context,transaction,status,is,completed,try,end,transaction,test,context,tx,context,finally,run,after,transaction,methods,test,context
TransactionalTestExecutionListener -> @Override 	public void afterTestMethod(TestContext testContext) throws Exception;1401991965;If a transaction is currently active for the test method of the supplied_{@link TestContext test context}, this method will end the transaction_and run {@link AfterTransaction &#064_AfterTransaction methods}._<p>{@code @AfterTransaction} methods are guaranteed to be_invoked even if an error occurs while ending the transaction.;@Override_	public void afterTestMethod(TestContext testContext) throws Exception {_		Method testMethod = testContext.getTestMethod()__		Assert.notNull(testMethod, "The test method of the supplied TestContext must not be null")___		_		TransactionContext txContext = this.transactionContextCache.remove(testMethod)__		if (txContext != null && !txContext.transactionStatus.isCompleted()) {_			try {_				endTransaction(testContext, txContext)__			}_			finally {_				runAfterTransactionMethods(testContext)__			}_		}_	};if,a,transaction,is,currently,active,for,the,test,method,of,the,supplied,link,test,context,test,context,this,method,will,end,the,transaction,and,run,link,after,transaction,064,after,transaction,methods,p,code,after,transaction,methods,are,guaranteed,to,be,invoked,even,if,an,error,occurs,while,ending,the,transaction;override,public,void,after,test,method,test,context,test,context,throws,exception,method,test,method,test,context,get,test,method,assert,not,null,test,method,the,test,method,of,the,supplied,test,context,must,not,be,null,transaction,context,tx,context,this,transaction,context,cache,remove,test,method,if,tx,context,null,tx,context,transaction,status,is,completed,try,end,transaction,test,context,tx,context,finally,run,after,transaction,methods,test,context
TransactionalTestExecutionListener -> @Override 	public void afterTestMethod(TestContext testContext) throws Exception;1404334604;If a transaction is currently active for the supplied_{@linkplain TestContext test context}, this method will end the transaction_and run {@link AfterTransaction @AfterTransaction} methods._<p>{@code @AfterTransaction} methods are guaranteed to be invoked even if_an error occurs while ending the transaction.;@Override_	public void afterTestMethod(TestContext testContext) throws Exception {_		Method testMethod = testContext.getTestMethod()__		Assert.notNull(testMethod, "The test method of the supplied TestContext must not be null")___		TransactionContext txContext = TransactionContextHolder.removeCurrentTransactionContext()__		_		if (txContext != null) {_			TransactionStatus transactionStatus = txContext.getTransactionStatus()__			try {_				_				if ((transactionStatus != null) && !transactionStatus.isCompleted()) {_					txContext.endTransaction()__				}_			}_			finally {_				runAfterTransactionMethods(testContext)__			}_		}_	};if,a,transaction,is,currently,active,for,the,supplied,linkplain,test,context,test,context,this,method,will,end,the,transaction,and,run,link,after,transaction,after,transaction,methods,p,code,after,transaction,methods,are,guaranteed,to,be,invoked,even,if,an,error,occurs,while,ending,the,transaction;override,public,void,after,test,method,test,context,test,context,throws,exception,method,test,method,test,context,get,test,method,assert,not,null,test,method,the,test,method,of,the,supplied,test,context,must,not,be,null,transaction,context,tx,context,transaction,context,holder,remove,current,transaction,context,if,tx,context,null,transaction,status,transaction,status,tx,context,get,transaction,status,try,if,transaction,status,null,transaction,status,is,completed,tx,context,end,transaction,finally,run,after,transaction,methods,test,context
TransactionalTestExecutionListener -> @Override 	public void afterTestMethod(TestContext testContext) throws Exception;1405645143;If a transaction is currently active for the supplied_{@linkplain TestContext test context}, this method will end the transaction_and run {@link AfterTransaction @AfterTransaction} methods._<p>{@code @AfterTransaction} methods are guaranteed to be invoked even if_an error occurs while ending the transaction.;@Override_	public void afterTestMethod(TestContext testContext) throws Exception {_		Method testMethod = testContext.getTestMethod()__		Assert.notNull(testMethod, "The test method of the supplied TestContext must not be null")___		TransactionContext txContext = TransactionContextHolder.removeCurrentTransactionContext()__		_		if (txContext != null) {_			TransactionStatus transactionStatus = txContext.getTransactionStatus()__			try {_				_				if ((transactionStatus != null) && !transactionStatus.isCompleted()) {_					txContext.endTransaction()__				}_			}_			finally {_				runAfterTransactionMethods(testContext)__			}_		}_	};if,a,transaction,is,currently,active,for,the,supplied,linkplain,test,context,test,context,this,method,will,end,the,transaction,and,run,link,after,transaction,after,transaction,methods,p,code,after,transaction,methods,are,guaranteed,to,be,invoked,even,if,an,error,occurs,while,ending,the,transaction;override,public,void,after,test,method,test,context,test,context,throws,exception,method,test,method,test,context,get,test,method,assert,not,null,test,method,the,test,method,of,the,supplied,test,context,must,not,be,null,transaction,context,tx,context,transaction,context,holder,remove,current,transaction,context,if,tx,context,null,transaction,status,transaction,status,tx,context,get,transaction,status,try,if,transaction,status,null,transaction,status,is,completed,tx,context,end,transaction,finally,run,after,transaction,methods,test,context
TransactionalTestExecutionListener -> @Override 	public void afterTestMethod(TestContext testContext) throws Exception;1405698612;If a transaction is currently active for the supplied_{@linkplain TestContext test context}, this method will end the transaction_and run {@link AfterTransaction @AfterTransaction} methods._<p>{@code @AfterTransaction} methods are guaranteed to be invoked even if_an error occurs while ending the transaction.;@Override_	public void afterTestMethod(TestContext testContext) throws Exception {_		Method testMethod = testContext.getTestMethod()__		Assert.notNull(testMethod, "The test method of the supplied TestContext must not be null")___		TransactionContext txContext = TransactionContextHolder.removeCurrentTransactionContext()__		_		if (txContext != null) {_			TransactionStatus transactionStatus = txContext.getTransactionStatus()__			try {_				_				if ((transactionStatus != null) && !transactionStatus.isCompleted()) {_					txContext.endTransaction()__				}_			}_			finally {_				runAfterTransactionMethods(testContext)__			}_		}_	};if,a,transaction,is,currently,active,for,the,supplied,linkplain,test,context,test,context,this,method,will,end,the,transaction,and,run,link,after,transaction,after,transaction,methods,p,code,after,transaction,methods,are,guaranteed,to,be,invoked,even,if,an,error,occurs,while,ending,the,transaction;override,public,void,after,test,method,test,context,test,context,throws,exception,method,test,method,test,context,get,test,method,assert,not,null,test,method,the,test,method,of,the,supplied,test,context,must,not,be,null,transaction,context,tx,context,transaction,context,holder,remove,current,transaction,context,if,tx,context,null,transaction,status,transaction,status,tx,context,get,transaction,status,try,if,transaction,status,null,transaction,status,is,completed,tx,context,end,transaction,finally,run,after,transaction,methods,test,context
TransactionalTestExecutionListener -> @Override 	public void afterTestMethod(TestContext testContext) throws Exception;1405759527;If a transaction is currently active for the supplied_{@linkplain TestContext test context}, this method will end the transaction_and run {@link AfterTransaction @AfterTransaction} methods._<p>{@code @AfterTransaction} methods are guaranteed to be invoked even if_an error occurs while ending the transaction.;@Override_	public void afterTestMethod(TestContext testContext) throws Exception {_		Method testMethod = testContext.getTestMethod()__		Assert.notNull(testMethod, "The test method of the supplied TestContext must not be null")___		TransactionContext txContext = TransactionContextHolder.removeCurrentTransactionContext()__		_		if (txContext != null) {_			TransactionStatus transactionStatus = txContext.getTransactionStatus()__			try {_				_				if ((transactionStatus != null) && !transactionStatus.isCompleted()) {_					txContext.endTransaction()__				}_			}_			finally {_				runAfterTransactionMethods(testContext)__			}_		}_	};if,a,transaction,is,currently,active,for,the,supplied,linkplain,test,context,test,context,this,method,will,end,the,transaction,and,run,link,after,transaction,after,transaction,methods,p,code,after,transaction,methods,are,guaranteed,to,be,invoked,even,if,an,error,occurs,while,ending,the,transaction;override,public,void,after,test,method,test,context,test,context,throws,exception,method,test,method,test,context,get,test,method,assert,not,null,test,method,the,test,method,of,the,supplied,test,context,must,not,be,null,transaction,context,tx,context,transaction,context,holder,remove,current,transaction,context,if,tx,context,null,transaction,status,transaction,status,tx,context,get,transaction,status,try,if,transaction,status,null,transaction,status,is,completed,tx,context,end,transaction,finally,run,after,transaction,methods,test,context
TransactionalTestExecutionListener -> @Override 	public void afterTestMethod(TestContext testContext) throws Exception;1405759966;If a transaction is currently active for the supplied_{@linkplain TestContext test context}, this method will end the transaction_and run {@link AfterTransaction @AfterTransaction} methods._<p>{@code @AfterTransaction} methods are guaranteed to be invoked even if_an error occurs while ending the transaction.;@Override_	public void afterTestMethod(TestContext testContext) throws Exception {_		Method testMethod = testContext.getTestMethod()__		Assert.notNull(testMethod, "The test method of the supplied TestContext must not be null")___		TransactionContext txContext = TransactionContextHolder.removeCurrentTransactionContext()__		_		if (txContext != null) {_			TransactionStatus transactionStatus = txContext.getTransactionStatus()__			try {_				_				if ((transactionStatus != null) && !transactionStatus.isCompleted()) {_					txContext.endTransaction()__				}_			}_			finally {_				runAfterTransactionMethods(testContext)__			}_		}_	};if,a,transaction,is,currently,active,for,the,supplied,linkplain,test,context,test,context,this,method,will,end,the,transaction,and,run,link,after,transaction,after,transaction,methods,p,code,after,transaction,methods,are,guaranteed,to,be,invoked,even,if,an,error,occurs,while,ending,the,transaction;override,public,void,after,test,method,test,context,test,context,throws,exception,method,test,method,test,context,get,test,method,assert,not,null,test,method,the,test,method,of,the,supplied,test,context,must,not,be,null,transaction,context,tx,context,transaction,context,holder,remove,current,transaction,context,if,tx,context,null,transaction,status,transaction,status,tx,context,get,transaction,status,try,if,transaction,status,null,transaction,status,is,completed,tx,context,end,transaction,finally,run,after,transaction,methods,test,context
TransactionalTestExecutionListener -> @Override 	public void afterTestMethod(TestContext testContext) throws Exception;1406218418;If a transaction is currently active for the supplied_{@linkplain TestContext test context}, this method will end the transaction_and run {@link AfterTransaction @AfterTransaction} methods._<p>{@code @AfterTransaction} methods are guaranteed to be invoked even if_an error occurs while ending the transaction.;@Override_	public void afterTestMethod(TestContext testContext) throws Exception {_		Method testMethod = testContext.getTestMethod()__		Assert.notNull(testMethod, "The test method of the supplied TestContext must not be null")___		TransactionContext txContext = TransactionContextHolder.removeCurrentTransactionContext()__		_		if (txContext != null) {_			TransactionStatus transactionStatus = txContext.getTransactionStatus()__			try {_				_				if ((transactionStatus != null) && !transactionStatus.isCompleted()) {_					txContext.endTransaction()__				}_			}_			finally {_				runAfterTransactionMethods(testContext)__			}_		}_	};if,a,transaction,is,currently,active,for,the,supplied,linkplain,test,context,test,context,this,method,will,end,the,transaction,and,run,link,after,transaction,after,transaction,methods,p,code,after,transaction,methods,are,guaranteed,to,be,invoked,even,if,an,error,occurs,while,ending,the,transaction;override,public,void,after,test,method,test,context,test,context,throws,exception,method,test,method,test,context,get,test,method,assert,not,null,test,method,the,test,method,of,the,supplied,test,context,must,not,be,null,transaction,context,tx,context,transaction,context,holder,remove,current,transaction,context,if,tx,context,null,transaction,status,transaction,status,tx,context,get,transaction,status,try,if,transaction,status,null,transaction,status,is,completed,tx,context,end,transaction,finally,run,after,transaction,methods,test,context
TransactionalTestExecutionListener -> @Override 	public void afterTestMethod(TestContext testContext) throws Exception;1407419079;If a transaction is currently active for the supplied_{@linkplain TestContext test context}, this method will end the transaction_and run {@link AfterTransaction @AfterTransaction} methods._<p>{@code @AfterTransaction} methods are guaranteed to be invoked even if_an error occurs while ending the transaction.;@Override_	public void afterTestMethod(TestContext testContext) throws Exception {_		Method testMethod = testContext.getTestMethod()__		Assert.notNull(testMethod, "The test method of the supplied TestContext must not be null")___		TransactionContext txContext = TransactionContextHolder.removeCurrentTransactionContext()__		_		if (txContext != null) {_			TransactionStatus transactionStatus = txContext.getTransactionStatus()__			try {_				_				if ((transactionStatus != null) && !transactionStatus.isCompleted()) {_					txContext.endTransaction()__				}_			}_			finally {_				runAfterTransactionMethods(testContext)__			}_		}_	};if,a,transaction,is,currently,active,for,the,supplied,linkplain,test,context,test,context,this,method,will,end,the,transaction,and,run,link,after,transaction,after,transaction,methods,p,code,after,transaction,methods,are,guaranteed,to,be,invoked,even,if,an,error,occurs,while,ending,the,transaction;override,public,void,after,test,method,test,context,test,context,throws,exception,method,test,method,test,context,get,test,method,assert,not,null,test,method,the,test,method,of,the,supplied,test,context,must,not,be,null,transaction,context,tx,context,transaction,context,holder,remove,current,transaction,context,if,tx,context,null,transaction,status,transaction,status,tx,context,get,transaction,status,try,if,transaction,status,null,transaction,status,is,completed,tx,context,end,transaction,finally,run,after,transaction,methods,test,context
TransactionalTestExecutionListener -> @Override 	public void afterTestMethod(TestContext testContext) throws Exception;1408048216;If a transaction is currently active for the supplied_{@linkplain TestContext test context}, this method will end the transaction_and run {@link AfterTransaction @AfterTransaction} methods._<p>{@code @AfterTransaction} methods are guaranteed to be invoked even if_an error occurs while ending the transaction.;@Override_	public void afterTestMethod(TestContext testContext) throws Exception {_		Method testMethod = testContext.getTestMethod()__		Assert.notNull(testMethod, "The test method of the supplied TestContext must not be null")___		TransactionContext txContext = TransactionContextHolder.removeCurrentTransactionContext()__		_		if (txContext != null) {_			TransactionStatus transactionStatus = txContext.getTransactionStatus()__			try {_				_				if ((transactionStatus != null) && !transactionStatus.isCompleted()) {_					txContext.endTransaction()__				}_			}_			finally {_				runAfterTransactionMethods(testContext)__			}_		}_	};if,a,transaction,is,currently,active,for,the,supplied,linkplain,test,context,test,context,this,method,will,end,the,transaction,and,run,link,after,transaction,after,transaction,methods,p,code,after,transaction,methods,are,guaranteed,to,be,invoked,even,if,an,error,occurs,while,ending,the,transaction;override,public,void,after,test,method,test,context,test,context,throws,exception,method,test,method,test,context,get,test,method,assert,not,null,test,method,the,test,method,of,the,supplied,test,context,must,not,be,null,transaction,context,tx,context,transaction,context,holder,remove,current,transaction,context,if,tx,context,null,transaction,status,transaction,status,tx,context,get,transaction,status,try,if,transaction,status,null,transaction,status,is,completed,tx,context,end,transaction,finally,run,after,transaction,methods,test,context
TransactionalTestExecutionListener -> @Override 	public void afterTestMethod(TestContext testContext) throws Exception;1413848647;If a transaction is currently active for the supplied_{@linkplain TestContext test context}, this method will end the transaction_and run {@link AfterTransaction @AfterTransaction} methods._<p>{@code @AfterTransaction} methods are guaranteed to be invoked even if_an error occurs while ending the transaction.;@Override_	public void afterTestMethod(TestContext testContext) throws Exception {_		Method testMethod = testContext.getTestMethod()__		Assert.notNull(testMethod, "The test method of the supplied TestContext must not be null")___		TransactionContext txContext = TransactionContextHolder.removeCurrentTransactionContext()__		_		if (txContext != null) {_			TransactionStatus transactionStatus = txContext.getTransactionStatus()__			try {_				_				if ((transactionStatus != null) && !transactionStatus.isCompleted()) {_					txContext.endTransaction()__				}_			}_			finally {_				runAfterTransactionMethods(testContext)__			}_		}_	};if,a,transaction,is,currently,active,for,the,supplied,linkplain,test,context,test,context,this,method,will,end,the,transaction,and,run,link,after,transaction,after,transaction,methods,p,code,after,transaction,methods,are,guaranteed,to,be,invoked,even,if,an,error,occurs,while,ending,the,transaction;override,public,void,after,test,method,test,context,test,context,throws,exception,method,test,method,test,context,get,test,method,assert,not,null,test,method,the,test,method,of,the,supplied,test,context,must,not,be,null,transaction,context,tx,context,transaction,context,holder,remove,current,transaction,context,if,tx,context,null,transaction,status,transaction,status,tx,context,get,transaction,status,try,if,transaction,status,null,transaction,status,is,completed,tx,context,end,transaction,finally,run,after,transaction,methods,test,context
TransactionalTestExecutionListener -> @Override 	public void afterTestMethod(TestContext testContext) throws Exception;1431568199;If a transaction is currently active for the supplied_{@linkplain TestContext test context}, this method will end the transaction_and run {@link AfterTransaction @AfterTransaction} methods._<p>{@code @AfterTransaction} methods are guaranteed to be invoked even if_an error occurs while ending the transaction.;@Override_	public void afterTestMethod(TestContext testContext) throws Exception {_		Method testMethod = testContext.getTestMethod()__		Assert.notNull(testMethod, "The test method of the supplied TestContext must not be null")___		TransactionContext txContext = TransactionContextHolder.removeCurrentTransactionContext()__		_		if (txContext != null) {_			TransactionStatus transactionStatus = txContext.getTransactionStatus()__			try {_				_				if ((transactionStatus != null) && !transactionStatus.isCompleted()) {_					txContext.endTransaction()__				}_			}_			finally {_				runAfterTransactionMethods(testContext)__			}_		}_	};if,a,transaction,is,currently,active,for,the,supplied,linkplain,test,context,test,context,this,method,will,end,the,transaction,and,run,link,after,transaction,after,transaction,methods,p,code,after,transaction,methods,are,guaranteed,to,be,invoked,even,if,an,error,occurs,while,ending,the,transaction;override,public,void,after,test,method,test,context,test,context,throws,exception,method,test,method,test,context,get,test,method,assert,not,null,test,method,the,test,method,of,the,supplied,test,context,must,not,be,null,transaction,context,tx,context,transaction,context,holder,remove,current,transaction,context,if,tx,context,null,transaction,status,transaction,status,tx,context,get,transaction,status,try,if,transaction,status,null,transaction,status,is,completed,tx,context,end,transaction,finally,run,after,transaction,methods,test,context
TransactionalTestExecutionListener -> @Override 	public void afterTestMethod(TestContext testContext) throws Exception;1432125256;If a transaction is currently active for the supplied_{@linkplain TestContext test context}, this method will end the transaction_and run {@link AfterTransaction @AfterTransaction} methods._<p>{@code @AfterTransaction} methods are guaranteed to be invoked even if_an error occurs while ending the transaction.;@Override_	public void afterTestMethod(TestContext testContext) throws Exception {_		Method testMethod = testContext.getTestMethod()__		Assert.notNull(testMethod, "The test method of the supplied TestContext must not be null")___		TransactionContext txContext = TransactionContextHolder.removeCurrentTransactionContext()__		_		if (txContext != null) {_			TransactionStatus transactionStatus = txContext.getTransactionStatus()__			try {_				_				if ((transactionStatus != null) && !transactionStatus.isCompleted()) {_					txContext.endTransaction()__				}_			}_			finally {_				runAfterTransactionMethods(testContext)__			}_		}_	};if,a,transaction,is,currently,active,for,the,supplied,linkplain,test,context,test,context,this,method,will,end,the,transaction,and,run,link,after,transaction,after,transaction,methods,p,code,after,transaction,methods,are,guaranteed,to,be,invoked,even,if,an,error,occurs,while,ending,the,transaction;override,public,void,after,test,method,test,context,test,context,throws,exception,method,test,method,test,context,get,test,method,assert,not,null,test,method,the,test,method,of,the,supplied,test,context,must,not,be,null,transaction,context,tx,context,transaction,context,holder,remove,current,transaction,context,if,tx,context,null,transaction,status,transaction,status,tx,context,get,transaction,status,try,if,transaction,status,null,transaction,status,is,completed,tx,context,end,transaction,finally,run,after,transaction,methods,test,context
TransactionalTestExecutionListener -> @Override 	public void afterTestMethod(TestContext testContext) throws Exception;1432856630;If a transaction is currently active for the supplied_{@linkplain TestContext test context}, this method will end the transaction_and run {@link AfterTransaction @AfterTransaction} methods._<p>{@code @AfterTransaction} methods are guaranteed to be invoked even if_an error occurs while ending the transaction.;@Override_	public void afterTestMethod(TestContext testContext) throws Exception {_		Method testMethod = testContext.getTestMethod()__		Assert.notNull(testMethod, "The test method of the supplied TestContext must not be null")___		TransactionContext txContext = TransactionContextHolder.removeCurrentTransactionContext()__		_		if (txContext != null) {_			TransactionStatus transactionStatus = txContext.getTransactionStatus()__			try {_				_				if ((transactionStatus != null) && !transactionStatus.isCompleted()) {_					txContext.endTransaction()__				}_			}_			finally {_				runAfterTransactionMethods(testContext)__			}_		}_	};if,a,transaction,is,currently,active,for,the,supplied,linkplain,test,context,test,context,this,method,will,end,the,transaction,and,run,link,after,transaction,after,transaction,methods,p,code,after,transaction,methods,are,guaranteed,to,be,invoked,even,if,an,error,occurs,while,ending,the,transaction;override,public,void,after,test,method,test,context,test,context,throws,exception,method,test,method,test,context,get,test,method,assert,not,null,test,method,the,test,method,of,the,supplied,test,context,must,not,be,null,transaction,context,tx,context,transaction,context,holder,remove,current,transaction,context,if,tx,context,null,transaction,status,transaction,status,tx,context,get,transaction,status,try,if,transaction,status,null,transaction,status,is,completed,tx,context,end,transaction,finally,run,after,transaction,methods,test,context
TransactionalTestExecutionListener -> @Override 	public void afterTestMethod(TestContext testContext) throws Exception;1434234880;If a transaction is currently active for the supplied_{@linkplain TestContext test context}, this method will end the transaction_and run {@link AfterTransaction @AfterTransaction} methods._<p>{@code @AfterTransaction} methods are guaranteed to be invoked even if_an error occurs while ending the transaction.;@Override_	public void afterTestMethod(TestContext testContext) throws Exception {_		Method testMethod = testContext.getTestMethod()__		Assert.notNull(testMethod, "The test method of the supplied TestContext must not be null")___		TransactionContext txContext = TransactionContextHolder.removeCurrentTransactionContext()__		_		if (txContext != null) {_			TransactionStatus transactionStatus = txContext.getTransactionStatus()__			try {_				_				if ((transactionStatus != null) && !transactionStatus.isCompleted()) {_					txContext.endTransaction()__				}_			}_			finally {_				runAfterTransactionMethods(testContext)__			}_		}_	};if,a,transaction,is,currently,active,for,the,supplied,linkplain,test,context,test,context,this,method,will,end,the,transaction,and,run,link,after,transaction,after,transaction,methods,p,code,after,transaction,methods,are,guaranteed,to,be,invoked,even,if,an,error,occurs,while,ending,the,transaction;override,public,void,after,test,method,test,context,test,context,throws,exception,method,test,method,test,context,get,test,method,assert,not,null,test,method,the,test,method,of,the,supplied,test,context,must,not,be,null,transaction,context,tx,context,transaction,context,holder,remove,current,transaction,context,if,tx,context,null,transaction,status,transaction,status,tx,context,get,transaction,status,try,if,transaction,status,null,transaction,status,is,completed,tx,context,end,transaction,finally,run,after,transaction,methods,test,context
TransactionalTestExecutionListener -> @Override 	public void afterTestMethod(TestContext testContext) throws Exception;1434720443;If a transaction is currently active for the supplied_{@linkplain TestContext test context}, this method will end the transaction_and run {@link AfterTransaction @AfterTransaction} methods._<p>{@code @AfterTransaction} methods are guaranteed to be invoked even if_an error occurs while ending the transaction.;@Override_	public void afterTestMethod(TestContext testContext) throws Exception {_		Method testMethod = testContext.getTestMethod()__		Assert.notNull(testMethod, "The test method of the supplied TestContext must not be null")___		TransactionContext txContext = TransactionContextHolder.removeCurrentTransactionContext()__		_		if (txContext != null) {_			TransactionStatus transactionStatus = txContext.getTransactionStatus()__			try {_				_				if ((transactionStatus != null) && !transactionStatus.isCompleted()) {_					txContext.endTransaction()__				}_			}_			finally {_				runAfterTransactionMethods(testContext)__			}_		}_	};if,a,transaction,is,currently,active,for,the,supplied,linkplain,test,context,test,context,this,method,will,end,the,transaction,and,run,link,after,transaction,after,transaction,methods,p,code,after,transaction,methods,are,guaranteed,to,be,invoked,even,if,an,error,occurs,while,ending,the,transaction;override,public,void,after,test,method,test,context,test,context,throws,exception,method,test,method,test,context,get,test,method,assert,not,null,test,method,the,test,method,of,the,supplied,test,context,must,not,be,null,transaction,context,tx,context,transaction,context,holder,remove,current,transaction,context,if,tx,context,null,transaction,status,transaction,status,tx,context,get,transaction,status,try,if,transaction,status,null,transaction,status,is,completed,tx,context,end,transaction,finally,run,after,transaction,methods,test,context
TransactionalTestExecutionListener -> @Override 	public void afterTestMethod(TestContext testContext) throws Exception;1434817656;If a transaction is currently active for the supplied_{@linkplain TestContext test context}, this method will end the transaction_and run {@link AfterTransaction @AfterTransaction} methods._<p>{@code @AfterTransaction} methods are guaranteed to be invoked even if_an error occurs while ending the transaction.;@Override_	public void afterTestMethod(TestContext testContext) throws Exception {_		Method testMethod = testContext.getTestMethod()__		Assert.notNull(testMethod, "The test method of the supplied TestContext must not be null")___		TransactionContext txContext = TransactionContextHolder.removeCurrentTransactionContext()__		_		if (txContext != null) {_			TransactionStatus transactionStatus = txContext.getTransactionStatus()__			try {_				_				if ((transactionStatus != null) && !transactionStatus.isCompleted()) {_					txContext.endTransaction()__				}_			}_			finally {_				runAfterTransactionMethods(testContext)__			}_		}_	};if,a,transaction,is,currently,active,for,the,supplied,linkplain,test,context,test,context,this,method,will,end,the,transaction,and,run,link,after,transaction,after,transaction,methods,p,code,after,transaction,methods,are,guaranteed,to,be,invoked,even,if,an,error,occurs,while,ending,the,transaction;override,public,void,after,test,method,test,context,test,context,throws,exception,method,test,method,test,context,get,test,method,assert,not,null,test,method,the,test,method,of,the,supplied,test,context,must,not,be,null,transaction,context,tx,context,transaction,context,holder,remove,current,transaction,context,if,tx,context,null,transaction,status,transaction,status,tx,context,get,transaction,status,try,if,transaction,status,null,transaction,status,is,completed,tx,context,end,transaction,finally,run,after,transaction,methods,test,context
TransactionalTestExecutionListener -> @Override 	public void afterTestMethod(TestContext testContext) throws Exception;1437841346;If a transaction is currently active for the supplied_{@linkplain TestContext test context}, this method will end the transaction_and run {@link AfterTransaction @AfterTransaction} methods._<p>{@code @AfterTransaction} methods are guaranteed to be invoked even if_an error occurs while ending the transaction.;@Override_	public void afterTestMethod(TestContext testContext) throws Exception {_		Method testMethod = testContext.getTestMethod()__		Assert.notNull(testMethod, "The test method of the supplied TestContext must not be null")___		TransactionContext txContext = TransactionContextHolder.removeCurrentTransactionContext()__		_		if (txContext != null) {_			TransactionStatus transactionStatus = txContext.getTransactionStatus()__			try {_				_				if ((transactionStatus != null) && !transactionStatus.isCompleted()) {_					txContext.endTransaction()__				}_			}_			finally {_				runAfterTransactionMethods(testContext)__			}_		}_	};if,a,transaction,is,currently,active,for,the,supplied,linkplain,test,context,test,context,this,method,will,end,the,transaction,and,run,link,after,transaction,after,transaction,methods,p,code,after,transaction,methods,are,guaranteed,to,be,invoked,even,if,an,error,occurs,while,ending,the,transaction;override,public,void,after,test,method,test,context,test,context,throws,exception,method,test,method,test,context,get,test,method,assert,not,null,test,method,the,test,method,of,the,supplied,test,context,must,not,be,null,transaction,context,tx,context,transaction,context,holder,remove,current,transaction,context,if,tx,context,null,transaction,status,transaction,status,tx,context,get,transaction,status,try,if,transaction,status,null,transaction,status,is,completed,tx,context,end,transaction,finally,run,after,transaction,methods,test,context
TransactionalTestExecutionListener -> @Override 	public void afterTestMethod(TestContext testContext) throws Exception;1437851372;If a transaction is currently active for the supplied_{@linkplain TestContext test context}, this method will end the transaction_and run {@link AfterTransaction @AfterTransaction} methods._<p>{@code @AfterTransaction} methods are guaranteed to be invoked even if_an error occurs while ending the transaction.;@Override_	public void afterTestMethod(TestContext testContext) throws Exception {_		Method testMethod = testContext.getTestMethod()__		Assert.notNull(testMethod, "The test method of the supplied TestContext must not be null")___		TransactionContext txContext = TransactionContextHolder.removeCurrentTransactionContext()__		_		if (txContext != null) {_			TransactionStatus transactionStatus = txContext.getTransactionStatus()__			try {_				_				if ((transactionStatus != null) && !transactionStatus.isCompleted()) {_					txContext.endTransaction()__				}_			}_			finally {_				runAfterTransactionMethods(testContext)__			}_		}_	};if,a,transaction,is,currently,active,for,the,supplied,linkplain,test,context,test,context,this,method,will,end,the,transaction,and,run,link,after,transaction,after,transaction,methods,p,code,after,transaction,methods,are,guaranteed,to,be,invoked,even,if,an,error,occurs,while,ending,the,transaction;override,public,void,after,test,method,test,context,test,context,throws,exception,method,test,method,test,context,get,test,method,assert,not,null,test,method,the,test,method,of,the,supplied,test,context,must,not,be,null,transaction,context,tx,context,transaction,context,holder,remove,current,transaction,context,if,tx,context,null,transaction,status,transaction,status,tx,context,get,transaction,status,try,if,transaction,status,null,transaction,status,is,completed,tx,context,end,transaction,finally,run,after,transaction,methods,test,context
TransactionalTestExecutionListener -> @Override 	public void afterTestMethod(TestContext testContext) throws Exception;1437852597;If a transaction is currently active for the supplied_{@linkplain TestContext test context}, this method will end the transaction_and run {@link AfterTransaction @AfterTransaction} methods._<p>{@code @AfterTransaction} methods are guaranteed to be invoked even if_an error occurs while ending the transaction.;@Override_	public void afterTestMethod(TestContext testContext) throws Exception {_		Method testMethod = testContext.getTestMethod()__		Assert.notNull(testMethod, "The test method of the supplied TestContext must not be null")___		TransactionContext txContext = TransactionContextHolder.removeCurrentTransactionContext()__		_		if (txContext != null) {_			TransactionStatus transactionStatus = txContext.getTransactionStatus()__			try {_				_				if ((transactionStatus != null) && !transactionStatus.isCompleted()) {_					txContext.endTransaction()__				}_			}_			finally {_				runAfterTransactionMethods(testContext)__			}_		}_	};if,a,transaction,is,currently,active,for,the,supplied,linkplain,test,context,test,context,this,method,will,end,the,transaction,and,run,link,after,transaction,after,transaction,methods,p,code,after,transaction,methods,are,guaranteed,to,be,invoked,even,if,an,error,occurs,while,ending,the,transaction;override,public,void,after,test,method,test,context,test,context,throws,exception,method,test,method,test,context,get,test,method,assert,not,null,test,method,the,test,method,of,the,supplied,test,context,must,not,be,null,transaction,context,tx,context,transaction,context,holder,remove,current,transaction,context,if,tx,context,null,transaction,status,transaction,status,tx,context,get,transaction,status,try,if,transaction,status,null,transaction,status,is,completed,tx,context,end,transaction,finally,run,after,transaction,methods,test,context
TransactionalTestExecutionListener -> @Override 	public void afterTestMethod(TestContext testContext) throws Exception;1454507787;If a transaction is currently active for the supplied_{@linkplain TestContext test context}, this method will end the transaction_and run {@link AfterTransaction @AfterTransaction} methods._<p>{@code @AfterTransaction} methods are guaranteed to be invoked even if_an error occurs while ending the transaction.;@Override_	public void afterTestMethod(TestContext testContext) throws Exception {_		Method testMethod = testContext.getTestMethod()__		Assert.notNull(testMethod, "The test method of the supplied TestContext must not be null")___		TransactionContext txContext = TransactionContextHolder.removeCurrentTransactionContext()__		_		if (txContext != null) {_			TransactionStatus transactionStatus = txContext.getTransactionStatus()__			try {_				_				if ((transactionStatus != null) && !transactionStatus.isCompleted()) {_					txContext.endTransaction()__				}_			}_			finally {_				runAfterTransactionMethods(testContext)__			}_		}_	};if,a,transaction,is,currently,active,for,the,supplied,linkplain,test,context,test,context,this,method,will,end,the,transaction,and,run,link,after,transaction,after,transaction,methods,p,code,after,transaction,methods,are,guaranteed,to,be,invoked,even,if,an,error,occurs,while,ending,the,transaction;override,public,void,after,test,method,test,context,test,context,throws,exception,method,test,method,test,context,get,test,method,assert,not,null,test,method,the,test,method,of,the,supplied,test,context,must,not,be,null,transaction,context,tx,context,transaction,context,holder,remove,current,transaction,context,if,tx,context,null,transaction,status,transaction,status,tx,context,get,transaction,status,try,if,transaction,status,null,transaction,status,is,completed,tx,context,end,transaction,finally,run,after,transaction,methods,test,context
TransactionalTestExecutionListener -> @Override 	public void afterTestMethod(TestContext testContext) throws Exception;1456702967;If a transaction is currently active for the supplied_{@linkplain TestContext test context}, this method will end the transaction_and run {@link AfterTransaction @AfterTransaction} methods._<p>{@code @AfterTransaction} methods are guaranteed to be invoked even if_an error occurs while ending the transaction.;@Override_	public void afterTestMethod(TestContext testContext) throws Exception {_		Method testMethod = testContext.getTestMethod()__		Assert.notNull(testMethod, "The test method of the supplied TestContext must not be null")___		TransactionContext txContext = TransactionContextHolder.removeCurrentTransactionContext()__		_		if (txContext != null) {_			TransactionStatus transactionStatus = txContext.getTransactionStatus()__			try {_				_				if ((transactionStatus != null) && !transactionStatus.isCompleted()) {_					txContext.endTransaction()__				}_			}_			finally {_				runAfterTransactionMethods(testContext)__			}_		}_	};if,a,transaction,is,currently,active,for,the,supplied,linkplain,test,context,test,context,this,method,will,end,the,transaction,and,run,link,after,transaction,after,transaction,methods,p,code,after,transaction,methods,are,guaranteed,to,be,invoked,even,if,an,error,occurs,while,ending,the,transaction;override,public,void,after,test,method,test,context,test,context,throws,exception,method,test,method,test,context,get,test,method,assert,not,null,test,method,the,test,method,of,the,supplied,test,context,must,not,be,null,transaction,context,tx,context,transaction,context,holder,remove,current,transaction,context,if,tx,context,null,transaction,status,transaction,status,tx,context,get,transaction,status,try,if,transaction,status,null,transaction,status,is,completed,tx,context,end,transaction,finally,run,after,transaction,methods,test,context
TransactionalTestExecutionListener -> @Override 	public void afterTestMethod(TestContext testContext) throws Exception;1456756222;If a transaction is currently active for the supplied_{@linkplain TestContext test context}, this method will end the transaction_and run {@link AfterTransaction @AfterTransaction} methods._<p>{@code @AfterTransaction} methods are guaranteed to be invoked even if_an error occurs while ending the transaction.;@Override_	public void afterTestMethod(TestContext testContext) throws Exception {_		Method testMethod = testContext.getTestMethod()__		Assert.notNull(testMethod, "The test method of the supplied TestContext must not be null")___		TransactionContext txContext = TransactionContextHolder.removeCurrentTransactionContext()__		_		if (txContext != null) {_			TransactionStatus transactionStatus = txContext.getTransactionStatus()__			try {_				_				if ((transactionStatus != null) && !transactionStatus.isCompleted()) {_					txContext.endTransaction()__				}_			}_			finally {_				runAfterTransactionMethods(testContext)__			}_		}_	};if,a,transaction,is,currently,active,for,the,supplied,linkplain,test,context,test,context,this,method,will,end,the,transaction,and,run,link,after,transaction,after,transaction,methods,p,code,after,transaction,methods,are,guaranteed,to,be,invoked,even,if,an,error,occurs,while,ending,the,transaction;override,public,void,after,test,method,test,context,test,context,throws,exception,method,test,method,test,context,get,test,method,assert,not,null,test,method,the,test,method,of,the,supplied,test,context,must,not,be,null,transaction,context,tx,context,transaction,context,holder,remove,current,transaction,context,if,tx,context,null,transaction,status,transaction,status,tx,context,get,transaction,status,try,if,transaction,status,null,transaction,status,is,completed,tx,context,end,transaction,finally,run,after,transaction,methods,test,context
TransactionalTestExecutionListener -> @Override 	public void afterTestMethod(TestContext testContext) throws Exception;1456756222;If a transaction is currently active for the supplied_{@linkplain TestContext test context}, this method will end the transaction_and run {@link AfterTransaction @AfterTransaction} methods._<p>{@code @AfterTransaction} methods are guaranteed to be invoked even if_an error occurs while ending the transaction.;@Override_	public void afterTestMethod(TestContext testContext) throws Exception {_		Method testMethod = testContext.getTestMethod()__		Assert.notNull(testMethod, "The test method of the supplied TestContext must not be null")___		TransactionContext txContext = TransactionContextHolder.removeCurrentTransactionContext()__		_		if (txContext != null) {_			TransactionStatus transactionStatus = txContext.getTransactionStatus()__			try {_				_				if ((transactionStatus != null) && !transactionStatus.isCompleted()) {_					txContext.endTransaction()__				}_			}_			finally {_				runAfterTransactionMethods(testContext)__			}_		}_	};if,a,transaction,is,currently,active,for,the,supplied,linkplain,test,context,test,context,this,method,will,end,the,transaction,and,run,link,after,transaction,after,transaction,methods,p,code,after,transaction,methods,are,guaranteed,to,be,invoked,even,if,an,error,occurs,while,ending,the,transaction;override,public,void,after,test,method,test,context,test,context,throws,exception,method,test,method,test,context,get,test,method,assert,not,null,test,method,the,test,method,of,the,supplied,test,context,must,not,be,null,transaction,context,tx,context,transaction,context,holder,remove,current,transaction,context,if,tx,context,null,transaction,status,transaction,status,tx,context,get,transaction,status,try,if,transaction,status,null,transaction,status,is,completed,tx,context,end,transaction,finally,run,after,transaction,methods,test,context
TransactionalTestExecutionListener -> @Override 	public void afterTestMethod(TestContext testContext) throws Exception;1458754760;If a transaction is currently active for the supplied_{@linkplain TestContext test context}, this method will end the transaction_and run {@link AfterTransaction @AfterTransaction} methods._<p>{@code @AfterTransaction} methods are guaranteed to be invoked even if_an error occurs while ending the transaction.;@Override_	public void afterTestMethod(TestContext testContext) throws Exception {_		Method testMethod = testContext.getTestMethod()__		Assert.notNull(testMethod, "The test method of the supplied TestContext must not be null")___		TransactionContext txContext = TransactionContextHolder.removeCurrentTransactionContext()__		_		if (txContext != null) {_			TransactionStatus transactionStatus = txContext.getTransactionStatus()__			try {_				_				if ((transactionStatus != null) && !transactionStatus.isCompleted()) {_					txContext.endTransaction()__				}_			}_			finally {_				runAfterTransactionMethods(testContext)__			}_		}_	};if,a,transaction,is,currently,active,for,the,supplied,linkplain,test,context,test,context,this,method,will,end,the,transaction,and,run,link,after,transaction,after,transaction,methods,p,code,after,transaction,methods,are,guaranteed,to,be,invoked,even,if,an,error,occurs,while,ending,the,transaction;override,public,void,after,test,method,test,context,test,context,throws,exception,method,test,method,test,context,get,test,method,assert,not,null,test,method,the,test,method,of,the,supplied,test,context,must,not,be,null,transaction,context,tx,context,transaction,context,holder,remove,current,transaction,context,if,tx,context,null,transaction,status,transaction,status,tx,context,get,transaction,status,try,if,transaction,status,null,transaction,status,is,completed,tx,context,end,transaction,finally,run,after,transaction,methods,test,context
TransactionalTestExecutionListener -> @Override 	public void afterTestMethod(TestContext testContext) throws Exception;1462294651;If a transaction is currently active for the supplied_{@linkplain TestContext test context}, this method will end the transaction_and run {@link AfterTransaction @AfterTransaction} methods._<p>{@code @AfterTransaction} methods are guaranteed to be invoked even if_an error occurs while ending the transaction.;@Override_	public void afterTestMethod(TestContext testContext) throws Exception {_		Method testMethod = testContext.getTestMethod()__		Assert.notNull(testMethod, "The test method of the supplied TestContext must not be null")___		TransactionContext txContext = TransactionContextHolder.removeCurrentTransactionContext()__		_		if (txContext != null) {_			TransactionStatus transactionStatus = txContext.getTransactionStatus()__			try {_				_				if ((transactionStatus != null) && !transactionStatus.isCompleted()) {_					txContext.endTransaction()__				}_			}_			finally {_				runAfterTransactionMethods(testContext)__			}_		}_	};if,a,transaction,is,currently,active,for,the,supplied,linkplain,test,context,test,context,this,method,will,end,the,transaction,and,run,link,after,transaction,after,transaction,methods,p,code,after,transaction,methods,are,guaranteed,to,be,invoked,even,if,an,error,occurs,while,ending,the,transaction;override,public,void,after,test,method,test,context,test,context,throws,exception,method,test,method,test,context,get,test,method,assert,not,null,test,method,the,test,method,of,the,supplied,test,context,must,not,be,null,transaction,context,tx,context,transaction,context,holder,remove,current,transaction,context,if,tx,context,null,transaction,status,transaction,status,tx,context,get,transaction,status,try,if,transaction,status,null,transaction,status,is,completed,tx,context,end,transaction,finally,run,after,transaction,methods,test,context
TransactionalTestExecutionListener -> @Override 	public void afterTestMethod(TestContext testContext) throws Exception;1462299971;If a transaction is currently active for the supplied_{@linkplain TestContext test context}, this method will end the transaction_and run {@link AfterTransaction @AfterTransaction} methods._<p>{@code @AfterTransaction} methods are guaranteed to be invoked even if_an error occurs while ending the transaction.;@Override_	public void afterTestMethod(TestContext testContext) throws Exception {_		Method testMethod = testContext.getTestMethod()__		Assert.notNull(testMethod, "The test method of the supplied TestContext must not be null")___		TransactionContext txContext = TransactionContextHolder.removeCurrentTransactionContext()__		_		if (txContext != null) {_			TransactionStatus transactionStatus = txContext.getTransactionStatus()__			try {_				_				if ((transactionStatus != null) && !transactionStatus.isCompleted()) {_					txContext.endTransaction()__				}_			}_			finally {_				runAfterTransactionMethods(testContext)__			}_		}_	};if,a,transaction,is,currently,active,for,the,supplied,linkplain,test,context,test,context,this,method,will,end,the,transaction,and,run,link,after,transaction,after,transaction,methods,p,code,after,transaction,methods,are,guaranteed,to,be,invoked,even,if,an,error,occurs,while,ending,the,transaction;override,public,void,after,test,method,test,context,test,context,throws,exception,method,test,method,test,context,get,test,method,assert,not,null,test,method,the,test,method,of,the,supplied,test,context,must,not,be,null,transaction,context,tx,context,transaction,context,holder,remove,current,transaction,context,if,tx,context,null,transaction,status,transaction,status,tx,context,get,transaction,status,try,if,transaction,status,null,transaction,status,is,completed,tx,context,end,transaction,finally,run,after,transaction,methods,test,context
TransactionalTestExecutionListener -> @Override 	public void afterTestMethod(TestContext testContext) throws Exception;1467730834;If a transaction is currently active for the supplied_{@linkplain TestContext test context}, this method will end the transaction_and run {@link AfterTransaction @AfterTransaction} methods._<p>{@code @AfterTransaction} methods are guaranteed to be invoked even if_an error occurs while ending the transaction.;@Override_	public void afterTestMethod(TestContext testContext) throws Exception {_		Method testMethod = testContext.getTestMethod()__		Assert.notNull(testMethod, "The test method of the supplied TestContext must not be null")___		TransactionContext txContext = TransactionContextHolder.removeCurrentTransactionContext()__		_		if (txContext != null) {_			TransactionStatus transactionStatus = txContext.getTransactionStatus()__			try {_				_				if ((transactionStatus != null) && !transactionStatus.isCompleted()) {_					txContext.endTransaction()__				}_			}_			finally {_				runAfterTransactionMethods(testContext)__			}_		}_	};if,a,transaction,is,currently,active,for,the,supplied,linkplain,test,context,test,context,this,method,will,end,the,transaction,and,run,link,after,transaction,after,transaction,methods,p,code,after,transaction,methods,are,guaranteed,to,be,invoked,even,if,an,error,occurs,while,ending,the,transaction;override,public,void,after,test,method,test,context,test,context,throws,exception,method,test,method,test,context,get,test,method,assert,not,null,test,method,the,test,method,of,the,supplied,test,context,must,not,be,null,transaction,context,tx,context,transaction,context,holder,remove,current,transaction,context,if,tx,context,null,transaction,status,transaction,status,tx,context,get,transaction,status,try,if,transaction,status,null,transaction,status,is,completed,tx,context,end,transaction,finally,run,after,transaction,methods,test,context
TransactionalTestExecutionListener -> @Override 	public void afterTestMethod(TestContext testContext) throws Exception;1467992320;If a transaction is currently active for the supplied_{@linkplain TestContext test context}, this method will end the transaction_and run {@link AfterTransaction @AfterTransaction} methods._<p>{@code @AfterTransaction} methods are guaranteed to be invoked even if_an error occurs while ending the transaction.;@Override_	public void afterTestMethod(TestContext testContext) throws Exception {_		Method testMethod = testContext.getTestMethod()__		Assert.notNull(testMethod, "The test method of the supplied TestContext must not be null")___		TransactionContext txContext = TransactionContextHolder.removeCurrentTransactionContext()__		_		if (txContext != null) {_			TransactionStatus transactionStatus = txContext.getTransactionStatus()__			try {_				_				if ((transactionStatus != null) && !transactionStatus.isCompleted()) {_					txContext.endTransaction()__				}_			}_			finally {_				runAfterTransactionMethods(testContext)__			}_		}_	};if,a,transaction,is,currently,active,for,the,supplied,linkplain,test,context,test,context,this,method,will,end,the,transaction,and,run,link,after,transaction,after,transaction,methods,p,code,after,transaction,methods,are,guaranteed,to,be,invoked,even,if,an,error,occurs,while,ending,the,transaction;override,public,void,after,test,method,test,context,test,context,throws,exception,method,test,method,test,context,get,test,method,assert,not,null,test,method,the,test,method,of,the,supplied,test,context,must,not,be,null,transaction,context,tx,context,transaction,context,holder,remove,current,transaction,context,if,tx,context,null,transaction,status,transaction,status,tx,context,get,transaction,status,try,if,transaction,status,null,transaction,status,is,completed,tx,context,end,transaction,finally,run,after,transaction,methods,test,context
TransactionalTestExecutionListener -> @Override 	public void afterTestMethod(TestContext testContext) throws Exception;1467992442;If a transaction is currently active for the supplied_{@linkplain TestContext test context}, this method will end the transaction_and run {@link AfterTransaction @AfterTransaction} methods._<p>{@code @AfterTransaction} methods are guaranteed to be invoked even if_an error occurs while ending the transaction.;@Override_	public void afterTestMethod(TestContext testContext) throws Exception {_		Method testMethod = testContext.getTestMethod()__		Assert.notNull(testMethod, "The test method of the supplied TestContext must not be null")___		TransactionContext txContext = TransactionContextHolder.removeCurrentTransactionContext()__		_		if (txContext != null) {_			TransactionStatus transactionStatus = txContext.getTransactionStatus()__			try {_				_				if ((transactionStatus != null) && !transactionStatus.isCompleted()) {_					txContext.endTransaction()__				}_			}_			finally {_				runAfterTransactionMethods(testContext)__			}_		}_	};if,a,transaction,is,currently,active,for,the,supplied,linkplain,test,context,test,context,this,method,will,end,the,transaction,and,run,link,after,transaction,after,transaction,methods,p,code,after,transaction,methods,are,guaranteed,to,be,invoked,even,if,an,error,occurs,while,ending,the,transaction;override,public,void,after,test,method,test,context,test,context,throws,exception,method,test,method,test,context,get,test,method,assert,not,null,test,method,the,test,method,of,the,supplied,test,context,must,not,be,null,transaction,context,tx,context,transaction,context,holder,remove,current,transaction,context,if,tx,context,null,transaction,status,transaction,status,tx,context,get,transaction,status,try,if,transaction,status,null,transaction,status,is,completed,tx,context,end,transaction,finally,run,after,transaction,methods,test,context
TransactionalTestExecutionListener -> @Override 	public void afterTestMethod(TestContext testContext) throws Exception;1467994604;If a transaction is currently active for the supplied_{@linkplain TestContext test context}, this method will end the transaction_and run {@link AfterTransaction @AfterTransaction} methods._<p>{@code @AfterTransaction} methods are guaranteed to be invoked even if_an error occurs while ending the transaction.;@Override_	public void afterTestMethod(TestContext testContext) throws Exception {_		Method testMethod = testContext.getTestMethod()__		Assert.notNull(testMethod, "The test method of the supplied TestContext must not be null")___		TransactionContext txContext = TransactionContextHolder.removeCurrentTransactionContext()__		_		if (txContext != null) {_			TransactionStatus transactionStatus = txContext.getTransactionStatus()__			try {_				_				if ((transactionStatus != null) && !transactionStatus.isCompleted()) {_					txContext.endTransaction()__				}_			}_			finally {_				runAfterTransactionMethods(testContext)__			}_		}_	};if,a,transaction,is,currently,active,for,the,supplied,linkplain,test,context,test,context,this,method,will,end,the,transaction,and,run,link,after,transaction,after,transaction,methods,p,code,after,transaction,methods,are,guaranteed,to,be,invoked,even,if,an,error,occurs,while,ending,the,transaction;override,public,void,after,test,method,test,context,test,context,throws,exception,method,test,method,test,context,get,test,method,assert,not,null,test,method,the,test,method,of,the,supplied,test,context,must,not,be,null,transaction,context,tx,context,transaction,context,holder,remove,current,transaction,context,if,tx,context,null,transaction,status,transaction,status,tx,context,get,transaction,status,try,if,transaction,status,null,transaction,status,is,completed,tx,context,end,transaction,finally,run,after,transaction,methods,test,context
TransactionalTestExecutionListener -> @Override 	public void afterTestMethod(TestContext testContext) throws Exception;1468334463;If a transaction is currently active for the supplied_{@linkplain TestContext test context}, this method will end the transaction_and run {@link AfterTransaction @AfterTransaction} methods._<p>{@code @AfterTransaction} methods are guaranteed to be invoked even if_an error occurs while ending the transaction.;@Override_	public void afterTestMethod(TestContext testContext) throws Exception {_		Method testMethod = testContext.getTestMethod()__		Assert.notNull(testMethod, "The test method of the supplied TestContext must not be null")___		TransactionContext txContext = TransactionContextHolder.removeCurrentTransactionContext()__		_		if (txContext != null) {_			TransactionStatus transactionStatus = txContext.getTransactionStatus()__			try {_				_				if ((transactionStatus != null) && !transactionStatus.isCompleted()) {_					txContext.endTransaction()__				}_			}_			finally {_				runAfterTransactionMethods(testContext)__			}_		}_	};if,a,transaction,is,currently,active,for,the,supplied,linkplain,test,context,test,context,this,method,will,end,the,transaction,and,run,link,after,transaction,after,transaction,methods,p,code,after,transaction,methods,are,guaranteed,to,be,invoked,even,if,an,error,occurs,while,ending,the,transaction;override,public,void,after,test,method,test,context,test,context,throws,exception,method,test,method,test,context,get,test,method,assert,not,null,test,method,the,test,method,of,the,supplied,test,context,must,not,be,null,transaction,context,tx,context,transaction,context,holder,remove,current,transaction,context,if,tx,context,null,transaction,status,transaction,status,tx,context,get,transaction,status,try,if,transaction,status,null,transaction,status,is,completed,tx,context,end,transaction,finally,run,after,transaction,methods,test,context
TransactionalTestExecutionListener -> @Override 	public void afterTestMethod(TestContext testContext) throws Exception;1496955179;If a transaction is currently active for the supplied_{@linkplain TestContext test context}, this method will end the transaction_and run {@link AfterTransaction @AfterTransaction} methods._<p>{@code @AfterTransaction} methods are guaranteed to be invoked even if_an error occurs while ending the transaction.;@Override_	public void afterTestMethod(TestContext testContext) throws Exception {_		Method testMethod = testContext.getTestMethod()__		Assert.notNull(testMethod, "The test method of the supplied TestContext must not be null")___		TransactionContext txContext = TransactionContextHolder.removeCurrentTransactionContext()__		_		if (txContext != null) {_			TransactionStatus transactionStatus = txContext.getTransactionStatus()__			try {_				_				if (transactionStatus != null && !transactionStatus.isCompleted()) {_					txContext.endTransaction()__				}_			}_			finally {_				runAfterTransactionMethods(testContext)__			}_		}_	};if,a,transaction,is,currently,active,for,the,supplied,linkplain,test,context,test,context,this,method,will,end,the,transaction,and,run,link,after,transaction,after,transaction,methods,p,code,after,transaction,methods,are,guaranteed,to,be,invoked,even,if,an,error,occurs,while,ending,the,transaction;override,public,void,after,test,method,test,context,test,context,throws,exception,method,test,method,test,context,get,test,method,assert,not,null,test,method,the,test,method,of,the,supplied,test,context,must,not,be,null,transaction,context,tx,context,transaction,context,holder,remove,current,transaction,context,if,tx,context,null,transaction,status,transaction,status,tx,context,get,transaction,status,try,if,transaction,status,null,transaction,status,is,completed,tx,context,end,transaction,finally,run,after,transaction,methods,test,context
TransactionalTestExecutionListener -> @Override 	public void afterTestMethod(TestContext testContext) throws Exception;1498780456;If a transaction is currently active for the supplied_{@linkplain TestContext test context}, this method will end the transaction_and run {@link AfterTransaction @AfterTransaction} methods._<p>{@code @AfterTransaction} methods are guaranteed to be invoked even if_an error occurs while ending the transaction.;@Override_	public void afterTestMethod(TestContext testContext) throws Exception {_		Method testMethod = testContext.getTestMethod()__		Assert.notNull(testMethod, "The test method of the supplied TestContext must not be null")___		TransactionContext txContext = TransactionContextHolder.removeCurrentTransactionContext()__		_		if (txContext != null) {_			TransactionStatus transactionStatus = txContext.getTransactionStatus()__			try {_				_				if (transactionStatus != null && !transactionStatus.isCompleted()) {_					txContext.endTransaction()__				}_			}_			finally {_				runAfterTransactionMethods(testContext)__			}_		}_	};if,a,transaction,is,currently,active,for,the,supplied,linkplain,test,context,test,context,this,method,will,end,the,transaction,and,run,link,after,transaction,after,transaction,methods,p,code,after,transaction,methods,are,guaranteed,to,be,invoked,even,if,an,error,occurs,while,ending,the,transaction;override,public,void,after,test,method,test,context,test,context,throws,exception,method,test,method,test,context,get,test,method,assert,not,null,test,method,the,test,method,of,the,supplied,test,context,must,not,be,null,transaction,context,tx,context,transaction,context,holder,remove,current,transaction,context,if,tx,context,null,transaction,status,transaction,status,tx,context,get,transaction,status,try,if,transaction,status,null,transaction,status,is,completed,tx,context,end,transaction,finally,run,after,transaction,methods,test,context
TransactionalTestExecutionListener -> @Override 	public void afterTestMethod(TestContext testContext) throws Exception;1520251235;If a transaction is currently active for the supplied_{@linkplain TestContext test context}, this method will end the transaction_and run {@link AfterTransaction @AfterTransaction} methods._<p>{@code @AfterTransaction} methods are guaranteed to be invoked even if_an error occurs while ending the transaction.;@Override_	public void afterTestMethod(TestContext testContext) throws Exception {_		Method testMethod = testContext.getTestMethod()__		Assert.notNull(testMethod, "The test method of the supplied TestContext must not be null")___		TransactionContext txContext = TransactionContextHolder.removeCurrentTransactionContext()__		_		if (txContext != null) {_			TransactionStatus transactionStatus = txContext.getTransactionStatus()__			try {_				_				if (transactionStatus != null && !transactionStatus.isCompleted()) {_					txContext.endTransaction()__				}_			}_			finally {_				runAfterTransactionMethods(testContext)__			}_		}_	};if,a,transaction,is,currently,active,for,the,supplied,linkplain,test,context,test,context,this,method,will,end,the,transaction,and,run,link,after,transaction,after,transaction,methods,p,code,after,transaction,methods,are,guaranteed,to,be,invoked,even,if,an,error,occurs,while,ending,the,transaction;override,public,void,after,test,method,test,context,test,context,throws,exception,method,test,method,test,context,get,test,method,assert,not,null,test,method,the,test,method,of,the,supplied,test,context,must,not,be,null,transaction,context,tx,context,transaction,context,holder,remove,current,transaction,context,if,tx,context,null,transaction,status,transaction,status,tx,context,get,transaction,status,try,if,transaction,status,null,transaction,status,is,completed,tx,context,end,transaction,finally,run,after,transaction,methods,test,context
