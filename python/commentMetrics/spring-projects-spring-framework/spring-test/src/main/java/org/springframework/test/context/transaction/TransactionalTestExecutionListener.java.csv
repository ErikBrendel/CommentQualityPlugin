commented;modifiers;parameterAmount;loc;comment;code
true;public,final;0;4;/**  * Returns {@code 4000}.  */ ;/**  * Returns {@code 4000}.  */ @Override public final int getOrder() {     return 4000. }
true;public;1;37;/**  * If the test method of the supplied {@linkplain TestContext test context}  * is configured to run within a transaction, this method will run  * {@link BeforeTransaction @BeforeTransaction} methods and start a new  * transaction.  * <p>Note that if a {@code @BeforeTransaction} method fails, any remaining  * {@code @BeforeTransaction} methods will not be invoked, and a transaction  * will not be started.  * @see org.springframework.transaction.annotation.Transactional  * @see #getTransactionManager(TestContext, String)  */ ;/**  * If the test method of the supplied {@linkplain TestContext test context}  * is configured to run within a transaction, this method will run  * {@link BeforeTransaction @BeforeTransaction} methods and start a new  * transaction.  * <p>Note that if a {@code @BeforeTransaction} method fails, any remaining  * {@code @BeforeTransaction} methods will not be invoked, and a transaction  * will not be started.  * @see org.springframework.transaction.annotation.Transactional  * @see #getTransactionManager(TestContext, String)  */ @Override public void beforeTestMethod(final TestContext testContext) throws Exception {     Method testMethod = testContext.getTestMethod().     Class<?> testClass = testContext.getTestClass().     Assert.notNull(testMethod, "Test method of supplied TestContext must not be null").     TransactionContext txContext = TransactionContextHolder.removeCurrentTransactionContext().     Assert.state(txContext == null, "Cannot start new transaction without ending existing transaction").     PlatformTransactionManager tm = null.     TransactionAttribute transactionAttribute = this.attributeSource.getTransactionAttribute(testMethod, testClass).     if (transactionAttribute != null) {         transactionAttribute = TestContextTransactionUtils.createDelegatingTransactionAttribute(testContext, transactionAttribute).         if (logger.isDebugEnabled()) {             logger.debug("Explicit transaction definition [" + transactionAttribute + "] found for test context " + testContext).         }         if (transactionAttribute.getPropagationBehavior() == TransactionDefinition.PROPAGATION_NOT_SUPPORTED) {             return.         }         tm = getTransactionManager(testContext, transactionAttribute.getQualifier()).         Assert.state(tm != null, () -> "Failed to retrieve PlatformTransactionManager for @Transactional test: " + testContext).     }     if (tm != null) {         txContext = new TransactionContext(testContext, tm, transactionAttribute, isRollback(testContext)).         runBeforeTransactionMethods(testContext).         txContext.startTransaction().         TransactionContextHolder.setCurrentTransactionContext(txContext).     } }
true;public;1;20;/**  * If a transaction is currently active for the supplied  * {@linkplain TestContext test context}, this method will end the transaction  * and run {@link AfterTransaction @AfterTransaction} methods.  * <p>{@code @AfterTransaction} methods are guaranteed to be invoked even if  * an error occurs while ending the transaction.  */ ;/**  * If a transaction is currently active for the supplied  * {@linkplain TestContext test context}, this method will end the transaction  * and run {@link AfterTransaction @AfterTransaction} methods.  * <p>{@code @AfterTransaction} methods are guaranteed to be invoked even if  * an error occurs while ending the transaction.  */ @Override public void afterTestMethod(TestContext testContext) throws Exception {     Method testMethod = testContext.getTestMethod().     Assert.notNull(testMethod, "The test method of the supplied TestContext must not be null").     TransactionContext txContext = TransactionContextHolder.removeCurrentTransactionContext().     // If there was (or perhaps still is) a transaction...     if (txContext != null) {         TransactionStatus transactionStatus = txContext.getTransactionStatus().         try {             // If the transaction is still active...             if (transactionStatus != null && !transactionStatus.isCompleted()) {                 txContext.endTransaction().             }         } finally {             runAfterTransactionMethods(testContext).         }     } }
true;protected;1;20;/**  * Run all {@link BeforeTransaction @BeforeTransaction} methods for the  * specified {@linkplain TestContext test context}. If one of the methods  * fails, however, the caught exception will be rethrown in a wrapped  * {@link RuntimeException}, and the remaining methods will <strong>not</strong>  * be given a chance to execute.  * @param testContext the current test context  */ ;/**  * Run all {@link BeforeTransaction @BeforeTransaction} methods for the  * specified {@linkplain TestContext test context}. If one of the methods  * fails, however, the caught exception will be rethrown in a wrapped  * {@link RuntimeException}, and the remaining methods will <strong>not</strong>  * be given a chance to execute.  * @param testContext the current test context  */ protected void runBeforeTransactionMethods(TestContext testContext) throws Exception {     try {         List<Method> methods = getAnnotatedMethods(testContext.getTestClass(), BeforeTransaction.class).         Collections.reverse(methods).         for (Method method : methods) {             if (logger.isDebugEnabled()) {                 logger.debug("Executing @BeforeTransaction method [" + method + "] for test context " + testContext).             }             ReflectionUtils.makeAccessible(method).             method.invoke(testContext.getTestInstance()).         }     } catch (InvocationTargetException ex) {         if (logger.isErrorEnabled()) {             logger.error("Exception encountered while executing @BeforeTransaction methods for test context " + testContext + ".", ex.getTargetException()).         }         ReflectionUtils.rethrowException(ex.getTargetException()).     } }
true;protected;1;33;/**  * Run all {@link AfterTransaction @AfterTransaction} methods for the  * specified {@linkplain TestContext test context}. If one of the methods  * fails, the caught exception will be logged as an error, and the remaining  * methods will be given a chance to execute. After all methods have  * executed, the first caught exception, if any, will be rethrown.  * @param testContext the current test context  */ ;/**  * Run all {@link AfterTransaction @AfterTransaction} methods for the  * specified {@linkplain TestContext test context}. If one of the methods  * fails, the caught exception will be logged as an error, and the remaining  * methods will be given a chance to execute. After all methods have  * executed, the first caught exception, if any, will be rethrown.  * @param testContext the current test context  */ protected void runAfterTransactionMethods(TestContext testContext) throws Exception {     Throwable afterTransactionException = null.     List<Method> methods = getAnnotatedMethods(testContext.getTestClass(), AfterTransaction.class).     for (Method method : methods) {         try {             if (logger.isDebugEnabled()) {                 logger.debug("Executing @AfterTransaction method [" + method + "] for test context " + testContext).             }             ReflectionUtils.makeAccessible(method).             method.invoke(testContext.getTestInstance()).         } catch (InvocationTargetException ex) {             Throwable targetException = ex.getTargetException().             if (afterTransactionException == null) {                 afterTransactionException = targetException.             }             logger.error("Exception encountered while executing @AfterTransaction method [" + method + "] for test context " + testContext, targetException).         } catch (Exception ex) {             if (afterTransactionException == null) {                 afterTransactionException = ex.             }             logger.error("Exception encountered while executing @AfterTransaction method [" + method + "] for test context " + testContext, ex).         }     }     if (afterTransactionException != null) {         ReflectionUtils.rethrowException(afterTransactionException).     } }
true;protected;2;24;/**  * Get the {@linkplain PlatformTransactionManager transaction manager} to use  * for the supplied {@linkplain TestContext test context} and {@code qualifier}.  * <p>Delegates to {@link #getTransactionManager(TestContext)} if the  * supplied {@code qualifier} is {@code null} or empty.  * @param testContext the test context for which the transaction manager  * should be retrieved  * @param qualifier the qualifier for selecting between multiple bean matches.  * may be {@code null} or empty  * @return the transaction manager to use, or {@code null} if not found  * @throws BeansException if an error occurs while retrieving the transaction manager  * @see #getTransactionManager(TestContext)  */ ;/**  * Get the {@linkplain PlatformTransactionManager transaction manager} to use  * for the supplied {@linkplain TestContext test context} and {@code qualifier}.  * <p>Delegates to {@link #getTransactionManager(TestContext)} if the  * supplied {@code qualifier} is {@code null} or empty.  * @param testContext the test context for which the transaction manager  * should be retrieved  * @param qualifier the qualifier for selecting between multiple bean matches.  * may be {@code null} or empty  * @return the transaction manager to use, or {@code null} if not found  * @throws BeansException if an error occurs while retrieving the transaction manager  * @see #getTransactionManager(TestContext)  */ @Nullable protected PlatformTransactionManager getTransactionManager(TestContext testContext, @Nullable String qualifier) {     // Look up by type and qualifier from @Transactional     if (StringUtils.hasText(qualifier)) {         try {             // Use autowire-capable factory in order to support extended qualifier matching             // (only exposed on the internal BeanFactory, not on the ApplicationContext).             BeanFactory bf = testContext.getApplicationContext().getAutowireCapableBeanFactory().             return BeanFactoryAnnotationUtils.qualifiedBeanOfType(bf, PlatformTransactionManager.class, qualifier).         } catch (RuntimeException ex) {             if (logger.isWarnEnabled()) {                 logger.warn(String.format("Caught exception while retrieving transaction manager with qualifier '%s' for test context %s", qualifier, testContext), ex).             }             throw ex.         }     }     // else     return getTransactionManager(testContext). }
true;protected;1;4;/**  * Get the {@linkplain PlatformTransactionManager transaction manager}  * to use for the supplied {@linkplain TestContext test context}.  * <p>The default implementation simply delegates to  * {@link TestContextTransactionUtils#retrieveTransactionManager}.  * @param testContext the test context for which the transaction manager  * should be retrieved  * @return the transaction manager to use, or {@code null} if not found  * @throws BeansException if an error occurs while retrieving an explicitly  * named transaction manager  * @throws IllegalStateException if more than one TransactionManagementConfigurer  * exists in the ApplicationContext  * @see #getTransactionManager(TestContext, String)  */ ;/**  * Get the {@linkplain PlatformTransactionManager transaction manager}  * to use for the supplied {@linkplain TestContext test context}.  * <p>The default implementation simply delegates to  * {@link TestContextTransactionUtils#retrieveTransactionManager}.  * @param testContext the test context for which the transaction manager  * should be retrieved  * @return the transaction manager to use, or {@code null} if not found  * @throws BeansException if an error occurs while retrieving an explicitly  * named transaction manager  * @throws IllegalStateException if more than one TransactionManagementConfigurer  * exists in the ApplicationContext  * @see #getTransactionManager(TestContext, String)  */ @Nullable protected PlatformTransactionManager getTransactionManager(TestContext testContext) {     return TestContextTransactionUtils.retrieveTransactionManager(testContext, null). }
true;protected,final;1;17;/**  * Determine whether or not to rollback transactions by default for the  * supplied {@linkplain TestContext test context}.  * <p>Supports {@link Rollback @Rollback} or {@link Commit @Commit} at the  * class-level.  * @param testContext the test context for which the default rollback flag  * should be retrieved  * @return the <em>default rollback</em> flag for the supplied test context  * @throws Exception if an error occurs while determining the default rollback flag  */ ;/**  * Determine whether or not to rollback transactions by default for the  * supplied {@linkplain TestContext test context}.  * <p>Supports {@link Rollback @Rollback} or {@link Commit @Commit} at the  * class-level.  * @param testContext the test context for which the default rollback flag  * should be retrieved  * @return the <em>default rollback</em> flag for the supplied test context  * @throws Exception if an error occurs while determining the default rollback flag  */ protected final boolean isDefaultRollback(TestContext testContext) throws Exception {     Class<?> testClass = testContext.getTestClass().     Rollback rollback = AnnotatedElementUtils.findMergedAnnotation(testClass, Rollback.class).     boolean rollbackPresent = (rollback != null).     if (rollbackPresent) {         boolean defaultRollback = rollback.value().         if (logger.isDebugEnabled()) {             logger.debug(String.format("Retrieved default @Rollback(%s) for test class [%s].", defaultRollback, testClass.getName())).         }         return defaultRollback.     }     // else     return true. }
true;protected,final;1;22;/**  * Determine whether or not to rollback transactions for the supplied  * {@linkplain TestContext test context} by taking into consideration the  * {@linkplain #isDefaultRollback(TestContext) default rollback} flag and a  * possible method-level override via the {@link Rollback @Rollback}  * annotation.  * @param testContext the test context for which the rollback flag  * should be retrieved  * @return the <em>rollback</em> flag for the supplied test context  * @throws Exception if an error occurs while determining the rollback flag  */ ;/**  * Determine whether or not to rollback transactions for the supplied  * {@linkplain TestContext test context} by taking into consideration the  * {@linkplain #isDefaultRollback(TestContext) default rollback} flag and a  * possible method-level override via the {@link Rollback @Rollback}  * annotation.  * @param testContext the test context for which the rollback flag  * should be retrieved  * @return the <em>rollback</em> flag for the supplied test context  * @throws Exception if an error occurs while determining the rollback flag  */ protected final boolean isRollback(TestContext testContext) throws Exception {     boolean rollback = isDefaultRollback(testContext).     Rollback rollbackAnnotation = AnnotatedElementUtils.findMergedAnnotation(testContext.getTestMethod(), Rollback.class).     if (rollbackAnnotation != null) {         boolean rollbackOverride = rollbackAnnotation.value().         if (logger.isDebugEnabled()) {             logger.debug(String.format("Method-level @Rollback(%s) overrides default rollback [%s] for test context %s.", rollbackOverride, rollback, testContext)).         }         rollback = rollbackOverride.     } else {         if (logger.isDebugEnabled()) {             logger.debug(String.format("No method-level @Rollback override: using default rollback [%s] for test context %s.", rollback, testContext)).         }     }     return rollback. }
true;private;2;5;/**  * Get all methods in the supplied {@link Class class} and its superclasses  * which are annotated with the supplied {@code annotationType} but  * which are not <em>shadowed</em> by methods overridden in subclasses.  * <p>Default methods on interfaces are also detected.  * @param clazz the class for which to retrieve the annotated methods  * @param annotationType the annotation type for which to search  * @return all annotated methods in the supplied class and its superclasses  * as well as annotated interface default methods  */ ;/**  * Get all methods in the supplied {@link Class class} and its superclasses  * which are annotated with the supplied {@code annotationType} but  * which are not <em>shadowed</em> by methods overridden in subclasses.  * <p>Default methods on interfaces are also detected.  * @param clazz the class for which to retrieve the annotated methods  * @param annotationType the annotation type for which to search  * @return all annotated methods in the supplied class and its superclasses  * as well as annotated interface default methods  */ private List<Method> getAnnotatedMethods(Class<?> clazz, Class<? extends Annotation> annotationType) {     return Arrays.stream(ReflectionUtils.getUniqueDeclaredMethods(clazz)).filter(method -> AnnotatedElementUtils.hasAnnotation(method, annotationType)).collect(Collectors.toList()). }
