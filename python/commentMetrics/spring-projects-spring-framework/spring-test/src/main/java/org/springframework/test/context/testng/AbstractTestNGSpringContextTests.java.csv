commented;modifiers;parameterAmount;loc;comment;code
true;public,final;1;4;/**  * Set the {@link ApplicationContext} to be used by this test instance,  * provided via {@link ApplicationContextAware} semantics.  * @param applicationContext the ApplicationContext that this test runs in  */ ;/**  * Set the {@link ApplicationContext} to be used by this test instance,  * provided via {@link ApplicationContextAware} semantics.  * @param applicationContext the ApplicationContext that this test runs in  */ @Override public final void setApplicationContext(ApplicationContext applicationContext) {     this.applicationContext = applicationContext. }
true;protected;0;4;/**  * Delegates to the configured {@link TestContextManager} to call  * {@linkplain TestContextManager#beforeTestClass() 'before test class'} callbacks.  * @throws Exception if a registered TestExecutionListener throws an exception  */ ;/**  * Delegates to the configured {@link TestContextManager} to call  * {@linkplain TestContextManager#beforeTestClass() 'before test class'} callbacks.  * @throws Exception if a registered TestExecutionListener throws an exception  */ @BeforeClass(alwaysRun = true) protected void springTestContextBeforeTestClass() throws Exception {     this.testContextManager.beforeTestClass(). }
true;protected;0;4;/**  * Delegates to the configured {@link TestContextManager} to  * {@linkplain TestContextManager#prepareTestInstance(Object) prepare} this test  * instance prior to execution of any individual tests, for example for  * injecting dependencies, etc.  * @throws Exception if a registered TestExecutionListener throws an exception  */ ;/**  * Delegates to the configured {@link TestContextManager} to  * {@linkplain TestContextManager#prepareTestInstance(Object) prepare} this test  * instance prior to execution of any individual tests, for example for  * injecting dependencies, etc.  * @throws Exception if a registered TestExecutionListener throws an exception  */ @BeforeClass(alwaysRun = true, dependsOnMethods = "springTestContextBeforeTestClass") protected void springTestContextPrepareTestInstance() throws Exception {     this.testContextManager.prepareTestInstance(this). }
true;protected;1;4;/**  * Delegates to the configured {@link TestContextManager} to  * {@linkplain TestContextManager#beforeTestMethod(Object,Method) pre-process}  * the test method before the actual test is executed.  * @param testMethod the test method which is about to be executed  * @throws Exception allows all exceptions to propagate  */ ;/**  * Delegates to the configured {@link TestContextManager} to  * {@linkplain TestContextManager#beforeTestMethod(Object,Method) pre-process}  * the test method before the actual test is executed.  * @param testMethod the test method which is about to be executed  * @throws Exception allows all exceptions to propagate  */ @BeforeMethod(alwaysRun = true) protected void springTestContextBeforeTestMethod(Method testMethod) throws Exception {     this.testContextManager.beforeTestMethod(this, testMethod). }
true;public;2;31;/**  * Delegates to the {@linkplain IHookCallBack#runTestMethod(ITestResult) test  * method} in the supplied {@code callback} to execute the actual test  * and then tracks the exception thrown during test execution, if any.  * @see org.testng.IHookable#run(IHookCallBack, ITestResult)  */ ;/**  * Delegates to the {@linkplain IHookCallBack#runTestMethod(ITestResult) test  * method} in the supplied {@code callback} to execute the actual test  * and then tracks the exception thrown during test execution, if any.  * @see org.testng.IHookable#run(IHookCallBack, ITestResult)  */ @Override public void run(IHookCallBack callBack, ITestResult testResult) {     Method testMethod = testResult.getMethod().getConstructorOrMethod().getMethod().     boolean beforeCallbacksExecuted = false.     try {         this.testContextManager.beforeTestExecution(this, testMethod).         beforeCallbacksExecuted = true.     } catch (Throwable ex) {         this.testException = ex.     }     if (beforeCallbacksExecuted) {         callBack.runTestMethod(testResult).         this.testException = getTestResultException(testResult).     }     try {         this.testContextManager.afterTestExecution(this, testMethod, this.testException).     } catch (Throwable ex) {         if (this.testException == null) {             this.testException = ex.         }     }     if (this.testException != null) {         throwAsUncheckedException(this.testException).     } }
true;protected;1;9;/**  * Delegates to the configured {@link TestContextManager} to  * {@linkplain TestContextManager#afterTestMethod(Object, Method, Throwable)  * post-process} the test method after the actual test has executed.  *  * @param testMethod the test method which has just been executed on the  * test instance  * @throws Exception allows all exceptions to propagate  */ ;/**  * Delegates to the configured {@link TestContextManager} to  * {@linkplain TestContextManager#afterTestMethod(Object, Method, Throwable)  * post-process} the test method after the actual test has executed.  *  * @param testMethod the test method which has just been executed on the  * test instance  * @throws Exception allows all exceptions to propagate  */ @AfterMethod(alwaysRun = true) protected void springTestContextAfterTestMethod(Method testMethod) throws Exception {     try {         this.testContextManager.afterTestMethod(this, testMethod, this.testException).     } finally {         this.testException = null.     } }
true;protected;0;4;/**  * Delegates to the configured {@link TestContextManager} to call  * {@linkplain TestContextManager#afterTestClass() 'after test class'} callbacks.  * @throws Exception if a registered TestExecutionListener throws an exception  */ ;/**  * Delegates to the configured {@link TestContextManager} to call  * {@linkplain TestContextManager#afterTestClass() 'after test class'} callbacks.  * @throws Exception if a registered TestExecutionListener throws an exception  */ @AfterClass(alwaysRun = true) protected void springTestContextAfterTestClass() throws Exception {     this.testContextManager.afterTestClass(). }
false;private;1;7;;private Throwable getTestResultException(ITestResult testResult) {     Throwable testResultException = testResult.getThrowable().     if (testResultException instanceof InvocationTargetException) {         testResultException = ((InvocationTargetException) testResultException).getCause().     }     return testResultException. }
false;private;1;5;;private RuntimeException throwAsUncheckedException(Throwable t) {     throwAs(t).     // Appeasing the compiler: the following line will never be executed.     throw new IllegalStateException(t). }
false;private;1;4;;@SuppressWarnings("unchecked") private <T extends Throwable> void throwAs(Throwable t) throws T {     throw (T) t. }
