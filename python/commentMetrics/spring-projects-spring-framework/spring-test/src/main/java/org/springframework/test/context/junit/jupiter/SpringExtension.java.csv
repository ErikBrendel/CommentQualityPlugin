commented;modifiers;parameterAmount;loc;comment;code
true;public;1;4;/**  * Delegates to {@link TestContextManager#beforeTestClass}.  */ ;/**  * Delegates to {@link TestContextManager#beforeTestClass}.  */ @Override public void beforeAll(ExtensionContext context) throws Exception {     getTestContextManager(context).beforeTestClass(). }
true;public;1;9;/**  * Delegates to {@link TestContextManager#afterTestClass}.  */ ;/**  * Delegates to {@link TestContextManager#afterTestClass}.  */ @Override public void afterAll(ExtensionContext context) throws Exception {     try {         getTestContextManager(context).afterTestClass().     } finally {         getStore(context).remove(context.getRequiredTestClass()).     } }
true;public;2;4;/**  * Delegates to {@link TestContextManager#prepareTestInstance}.  */ ;/**  * Delegates to {@link TestContextManager#prepareTestInstance}.  */ @Override public void postProcessTestInstance(Object testInstance, ExtensionContext context) throws Exception {     getTestContextManager(context).prepareTestInstance(testInstance). }
true;public;1;6;/**  * Delegates to {@link TestContextManager#beforeTestMethod}.  */ ;/**  * Delegates to {@link TestContextManager#beforeTestMethod}.  */ @Override public void beforeEach(ExtensionContext context) throws Exception {     Object testInstance = context.getRequiredTestInstance().     Method testMethod = context.getRequiredTestMethod().     getTestContextManager(context).beforeTestMethod(testInstance, testMethod). }
true;public;1;6;/**  * Delegates to {@link TestContextManager#beforeTestExecution}.  */ ;/**  * Delegates to {@link TestContextManager#beforeTestExecution}.  */ @Override public void beforeTestExecution(ExtensionContext context) throws Exception {     Object testInstance = context.getRequiredTestInstance().     Method testMethod = context.getRequiredTestMethod().     getTestContextManager(context).beforeTestExecution(testInstance, testMethod). }
true;public;1;7;/**  * Delegates to {@link TestContextManager#afterTestExecution}.  */ ;/**  * Delegates to {@link TestContextManager#afterTestExecution}.  */ @Override public void afterTestExecution(ExtensionContext context) throws Exception {     Object testInstance = context.getRequiredTestInstance().     Method testMethod = context.getRequiredTestMethod().     Throwable testException = context.getExecutionException().orElse(null).     getTestContextManager(context).afterTestExecution(testInstance, testMethod, testException). }
true;public;1;7;/**  * Delegates to {@link TestContextManager#afterTestMethod}.  */ ;/**  * Delegates to {@link TestContextManager#afterTestMethod}.  */ @Override public void afterEach(ExtensionContext context) throws Exception {     Object testInstance = context.getRequiredTestInstance().     Method testMethod = context.getRequiredTestMethod().     Throwable testException = context.getExecutionException().orElse(null).     getTestContextManager(context).afterTestMethod(testInstance, testMethod, testException). }
true;public;2;10;/**  * Determine if the value for the {@link Parameter} in the supplied {@link ParameterContext}  * should be autowired from the test's {@link ApplicationContext}.  * <p>Returns {@code true} if the parameter is declared in a {@link Constructor}  * that is annotated with {@link Autowired @Autowired} or if the parameter is  * of type {@link ApplicationContext} (or a sub-type thereof) and otherwise delegates  * to {@link AutowireUtils#isAutowirable}.  * <p><strong>WARNING</strong>: If the parameter is declared in a {@code Constructor}  * that is annotated with {@code @Autowired}, Spring will assume the responsibility  * for resolving all parameters in the constructor. Consequently, no other registered  * {@link ParameterResolver} will be able to resolve parameters.  * @see #resolveParameter  * @see AutowireUtils#isAutowirable  */ ;/**  * Determine if the value for the {@link Parameter} in the supplied {@link ParameterContext}  * should be autowired from the test's {@link ApplicationContext}.  * <p>Returns {@code true} if the parameter is declared in a {@link Constructor}  * that is annotated with {@link Autowired @Autowired} or if the parameter is  * of type {@link ApplicationContext} (or a sub-type thereof) and otherwise delegates  * to {@link AutowireUtils#isAutowirable}.  * <p><strong>WARNING</strong>: If the parameter is declared in a {@code Constructor}  * that is annotated with {@code @Autowired}, Spring will assume the responsibility  * for resolving all parameters in the constructor. Consequently, no other registered  * {@link ParameterResolver} will be able to resolve parameters.  * @see #resolveParameter  * @see AutowireUtils#isAutowirable  */ @Override public boolean supportsParameter(ParameterContext parameterContext, ExtensionContext extensionContext) {     Parameter parameter = parameterContext.getParameter().     int index = parameterContext.getIndex().     Executable executable = parameter.getDeclaringExecutable().     return (executable instanceof Constructor && AnnotatedElementUtils.hasAnnotation(executable, Autowired.class)) || ApplicationContext.class.isAssignableFrom(parameter.getType()) || AutowireUtils.isAutowirable(parameter, index). }
true;public;2;10;/**  * Resolve a value for the {@link Parameter} in the supplied {@link ParameterContext} by  * retrieving the corresponding dependency from the test's {@link ApplicationContext}.  * <p>Delegates to {@link AutowireUtils#resolveDependency}.  * @see #supportsParameter  * @see AutowireUtils#resolveDependency  */ ;/**  * Resolve a value for the {@link Parameter} in the supplied {@link ParameterContext} by  * retrieving the corresponding dependency from the test's {@link ApplicationContext}.  * <p>Delegates to {@link AutowireUtils#resolveDependency}.  * @see #supportsParameter  * @see AutowireUtils#resolveDependency  */ @Override @Nullable public Object resolveParameter(ParameterContext parameterContext, ExtensionContext extensionContext) {     Parameter parameter = parameterContext.getParameter().     int index = parameterContext.getIndex().     Class<?> testClass = extensionContext.getRequiredTestClass().     ApplicationContext applicationContext = getApplicationContext(extensionContext).     return AutowireUtils.resolveDependency(parameter, index, testClass, applicationContext.getAutowireCapableBeanFactory()). }
true;public,static;1;3;/**  * Get the {@link ApplicationContext} associated with the supplied {@code ExtensionContext}.  * @param context the current {@code ExtensionContext} (never {@code null})  * @return the application context  * @throws IllegalStateException if an error occurs while retrieving the application context  * @see org.springframework.test.context.TestContext#getApplicationContext()  */ ;/**  * Get the {@link ApplicationContext} associated with the supplied {@code ExtensionContext}.  * @param context the current {@code ExtensionContext} (never {@code null})  * @return the application context  * @throws IllegalStateException if an error occurs while retrieving the application context  * @see org.springframework.test.context.TestContext#getApplicationContext()  */ public static ApplicationContext getApplicationContext(ExtensionContext context) {     return getTestContextManager(context).getTestContext().getApplicationContext(). }
true;private,static;1;6;/**  * Get the {@link TestContextManager} associated with the supplied {@code ExtensionContext}.  * @return the {@code TestContextManager} (never {@code null})  */ ;/**  * Get the {@link TestContextManager} associated with the supplied {@code ExtensionContext}.  * @return the {@code TestContextManager} (never {@code null})  */ private static TestContextManager getTestContextManager(ExtensionContext context) {     Assert.notNull(context, "ExtensionContext must not be null").     Class<?> testClass = context.getRequiredTestClass().     Store store = getStore(context).     return store.getOrComputeIfAbsent(testClass, TestContextManager::new, TestContextManager.class). }
false;private,static;1;3;;private static Store getStore(ExtensionContext context) {     return context.getRoot().getStore(NAMESPACE). }
