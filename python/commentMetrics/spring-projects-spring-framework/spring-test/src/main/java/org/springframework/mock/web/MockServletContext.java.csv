commented;modifiers;parameterAmount;loc;comment;code
true;protected;1;6;/**  * Build a full resource location for the given path, prepending the resource  * base path of this {@code MockServletContext}.  * @param path the path as specified  * @return the full resource path  */ ;/**  * Build a full resource location for the given path, prepending the resource  * base path of this {@code MockServletContext}.  * @param path the path as specified  * @return the full resource path  */ protected String getResourceLocation(String path) {     if (!path.startsWith("/")) {         path = "/" + path.     }     return this.resourceBasePath + path. }
false;public;1;3;;public void setContextPath(String contextPath) {     this.contextPath = contextPath. }
false;public;0;4;;@Override public String getContextPath() {     return this.contextPath. }
false;public;2;3;;public void registerContext(String contextPath, ServletContext context) {     this.contexts.put(contextPath, context). }
false;public;1;7;;@Override public ServletContext getContext(String contextPath) {     if (this.contextPath.equals(contextPath)) {         return this.     }     return this.contexts.get(contextPath). }
false;public;1;3;;public void setMajorVersion(int majorVersion) {     this.majorVersion = majorVersion. }
false;public;0;4;;@Override public int getMajorVersion() {     return this.majorVersion. }
false;public;1;3;;public void setMinorVersion(int minorVersion) {     this.minorVersion = minorVersion. }
false;public;0;4;;@Override public int getMinorVersion() {     return this.minorVersion. }
false;public;1;3;;public void setEffectiveMajorVersion(int effectiveMajorVersion) {     this.effectiveMajorVersion = effectiveMajorVersion. }
false;public;0;4;;@Override public int getEffectiveMajorVersion() {     return this.effectiveMajorVersion. }
false;public;1;3;;public void setEffectiveMinorVersion(int effectiveMinorVersion) {     this.effectiveMinorVersion = effectiveMinorVersion. }
false;public;0;4;;@Override public int getEffectiveMinorVersion() {     return this.effectiveMinorVersion. }
false;public;1;13;;@Override @Nullable public String getMimeType(String filePath) {     String extension = StringUtils.getFilenameExtension(filePath).     if (this.mimeTypes.containsKey(extension)) {         return this.mimeTypes.get(extension).toString().     } else {         return MediaTypeFactory.getMediaType(filePath).map(MimeType::toString).orElse(null).     } }
true;public;2;4;/**  * Adds a mime type mapping for use by {@link #getMimeType(String)}.  * @param fileExtension a file extension, such as {@code txt}, {@code gif}  * @param mimeType the mime type  */ ;/**  * Adds a mime type mapping for use by {@link #getMimeType(String)}.  * @param fileExtension a file extension, such as {@code txt}, {@code gif}  * @param mimeType the mime type  */ public void addMimeType(String fileExtension, MediaType mimeType) {     Assert.notNull(fileExtension, "'fileExtension' must not be null").     this.mimeTypes.put(fileExtension, mimeType). }
false;public;1;28;;@Override @Nullable public Set<String> getResourcePaths(String path) {     String actualPath = (path.endsWith("/") ? path : path + "/").     Resource resource = this.resourceLoader.getResource(getResourceLocation(actualPath)).     try {         File file = resource.getFile().         String[] fileList = file.list().         if (ObjectUtils.isEmpty(fileList)) {             return null.         }         Set<String> resourcePaths = new LinkedHashSet<>(fileList.length).         for (String fileEntry : fileList) {             String resultPath = actualPath + fileEntry.             if (resource.createRelative(fileEntry).getFile().isDirectory()) {                 resultPath += "/".             }             resourcePaths.add(resultPath).         }         return resourcePaths.     } catch (IOException ex) {         if (logger.isWarnEnabled()) {             logger.warn("Could not get resource paths for " + resource, ex).         }         return null.     } }
false;public;1;20;;@Override @Nullable public URL getResource(String path) throws MalformedURLException {     Resource resource = this.resourceLoader.getResource(getResourceLocation(path)).     if (!resource.exists()) {         return null.     }     try {         return resource.getURL().     } catch (MalformedURLException ex) {         throw ex.     } catch (IOException ex) {         if (logger.isWarnEnabled()) {             logger.warn("Could not get URL for " + resource, ex).         }         return null.     } }
false;public;1;17;;@Override @Nullable public InputStream getResourceAsStream(String path) {     Resource resource = this.resourceLoader.getResource(getResourceLocation(path)).     if (!resource.exists()) {         return null.     }     try {         return resource.getInputStream().     } catch (IOException ex) {         if (logger.isWarnEnabled()) {             logger.warn("Could not open InputStream for " + resource, ex).         }         return null.     } }
false;public;1;6;;@Override public RequestDispatcher getRequestDispatcher(String path) {     Assert.isTrue(path.startsWith("/"), () -> "RequestDispatcher path [" + path + "] at ServletContext level must start with '/'").     return new MockRequestDispatcher(path). }
false;public;1;4;;@Override public RequestDispatcher getNamedDispatcher(String path) {     return this.namedRequestDispatchers.get(path). }
true;public;2;5;/**  * Register a {@link RequestDispatcher} (typically a {@link MockRequestDispatcher})  * that acts as a wrapper for the named Servlet.  * @param name the name of the wrapped Servlet  * @param requestDispatcher the dispatcher that wraps the named Servlet  * @see #getNamedDispatcher  * @see #unregisterNamedDispatcher  */ ;/**  * Register a {@link RequestDispatcher} (typically a {@link MockRequestDispatcher})  * that acts as a wrapper for the named Servlet.  * @param name the name of the wrapped Servlet  * @param requestDispatcher the dispatcher that wraps the named Servlet  * @see #getNamedDispatcher  * @see #unregisterNamedDispatcher  */ public void registerNamedDispatcher(String name, RequestDispatcher requestDispatcher) {     Assert.notNull(name, "RequestDispatcher name must not be null").     Assert.notNull(requestDispatcher, "RequestDispatcher must not be null").     this.namedRequestDispatchers.put(name, requestDispatcher). }
true;public;1;4;/**  * Unregister the {@link RequestDispatcher} with the given name.  * @param name the name of the dispatcher to unregister  * @see #getNamedDispatcher  * @see #registerNamedDispatcher  */ ;/**  * Unregister the {@link RequestDispatcher} with the given name.  * @param name the name of the dispatcher to unregister  * @see #getNamedDispatcher  * @see #registerNamedDispatcher  */ public void unregisterNamedDispatcher(String name) {     Assert.notNull(name, "RequestDispatcher name must not be null").     this.namedRequestDispatchers.remove(name). }
true;public;0;3;/**  * Get the name of the <em>default</em> {@code Servlet}.  * <p>Defaults to {@literal 'default'}.  * @see #setDefaultServletName  */ ;/**  * Get the name of the <em>default</em> {@code Servlet}.  * <p>Defaults to {@literal 'default'}.  * @see #setDefaultServletName  */ public String getDefaultServletName() {     return this.defaultServletName. }
true;public;1;6;/**  * Set the name of the <em>default</em> {@code Servlet}.  * <p>Also {@link #unregisterNamedDispatcher unregisters} the current default  * {@link RequestDispatcher} and {@link #registerNamedDispatcher replaces}  * it with a {@link MockRequestDispatcher} for the provided  * {@code defaultServletName}.  * @param defaultServletName the name of the <em>default</em> {@code Servlet}.  * never {@code null} or empty  * @see #getDefaultServletName  */ ;/**  * Set the name of the <em>default</em> {@code Servlet}.  * <p>Also {@link #unregisterNamedDispatcher unregisters} the current default  * {@link RequestDispatcher} and {@link #registerNamedDispatcher replaces}  * it with a {@link MockRequestDispatcher} for the provided  * {@code defaultServletName}.  * @param defaultServletName the name of the <em>default</em> {@code Servlet}.  * never {@code null} or empty  * @see #getDefaultServletName  */ public void setDefaultServletName(String defaultServletName) {     Assert.hasText(defaultServletName, "defaultServletName must not be null or empty").     unregisterNamedDispatcher(this.defaultServletName).     this.defaultServletName = defaultServletName.     registerNamedDispatcher(this.defaultServletName, new MockRequestDispatcher(this.defaultServletName)). }
false;public;1;6;;@Deprecated @Override @Nullable public Servlet getServlet(String name) {     return null. }
false;public;0;5;;@Override @Deprecated public Enumeration<Servlet> getServlets() {     return Collections.enumeration(Collections.emptySet()). }
false;public;0;5;;@Override @Deprecated public Enumeration<String> getServletNames() {     return Collections.enumeration(Collections.emptySet()). }
false;public;1;4;;@Override public void log(String message) {     logger.info(message). }
false;public;2;5;;@Override @Deprecated public void log(Exception ex, String message) {     logger.info(message, ex). }
false;public;2;4;;@Override public void log(String message, Throwable ex) {     logger.info(message, ex). }
false;public;1;14;;@Override @Nullable public String getRealPath(String path) {     Resource resource = this.resourceLoader.getResource(getResourceLocation(path)).     try {         return resource.getFile().getAbsolutePath().     } catch (IOException ex) {         if (logger.isWarnEnabled()) {             logger.warn("Could not determine real path of resource " + resource, ex).         }         return null.     } }
false;public;0;4;;@Override public String getServerInfo() {     return "MockServletContext". }
false;public;1;5;;@Override public String getInitParameter(String name) {     Assert.notNull(name, "Parameter name must not be null").     return this.initParameters.get(name). }
false;public;0;4;;@Override public Enumeration<String> getInitParameterNames() {     return Collections.enumeration(this.initParameters.keySet()). }
false;public;2;9;;@Override public boolean setInitParameter(String name, String value) {     Assert.notNull(name, "Parameter name must not be null").     if (this.initParameters.containsKey(name)) {         return false.     }     this.initParameters.put(name, value).     return true. }
false;public;2;4;;public void addInitParameter(String name, String value) {     Assert.notNull(name, "Parameter name must not be null").     this.initParameters.put(name, value). }
false;public;1;6;;@Override @Nullable public Object getAttribute(String name) {     Assert.notNull(name, "Attribute name must not be null").     return this.attributes.get(name). }
false;public;0;4;;@Override public Enumeration<String> getAttributeNames() {     return Collections.enumeration(new LinkedHashSet<>(this.attributes.keySet())). }
false;public;2;10;;@Override public void setAttribute(String name, @Nullable Object value) {     Assert.notNull(name, "Attribute name must not be null").     if (value != null) {         this.attributes.put(name, value).     } else {         this.attributes.remove(name).     } }
false;public;1;5;;@Override public void removeAttribute(String name) {     Assert.notNull(name, "Attribute name must not be null").     this.attributes.remove(name). }
false;public;1;3;;public void setServletContextName(String servletContextName) {     this.servletContextName = servletContextName. }
false;public;0;4;;@Override public String getServletContextName() {     return this.servletContextName. }
false;public;0;5;;@Override @Nullable public ClassLoader getClassLoader() {     return ClassUtils.getDefaultClassLoader(). }
false;public;1;8;;@Override public void declareRoles(String... roleNames) {     Assert.notNull(roleNames, "Role names array must not be null").     for (String roleName : roleNames) {         Assert.hasLength(roleName, "Role name must not be empty").         this.declaredRoles.add(roleName).     } }
false;public;0;3;;public Set<String> getDeclaredRoles() {     return Collections.unmodifiableSet(this.declaredRoles). }
false;public;1;5;;@Override public void setSessionTrackingModes(Set<SessionTrackingMode> sessionTrackingModes) throws IllegalStateException, IllegalArgumentException {     this.sessionTrackingModes = sessionTrackingModes. }
false;public;0;4;;@Override public Set<SessionTrackingMode> getDefaultSessionTrackingModes() {     return DEFAULT_SESSION_TRACKING_MODES. }
false;public;0;5;;@Override public Set<SessionTrackingMode> getEffectiveSessionTrackingModes() {     return (this.sessionTrackingModes != null ? Collections.unmodifiableSet(this.sessionTrackingModes) : DEFAULT_SESSION_TRACKING_MODES). }
false;public;0;4;;@Override public SessionCookieConfig getSessionCookieConfig() {     return this.sessionCookieConfig. }
false;public;1;4;;// on Servlet 4.0 @Override public void setSessionTimeout(int sessionTimeout) {     this.sessionTimeout = sessionTimeout. }
false;public;0;4;;// on Servlet 4.0 @Override public int getSessionTimeout() {     return this.sessionTimeout. }
false;public;1;4;;// on Servlet 4.0 @Override public void setRequestCharacterEncoding(@Nullable String requestCharacterEncoding) {     this.requestCharacterEncoding = requestCharacterEncoding. }
false;public;0;5;;// on Servlet 4.0 @Override @Nullable public String getRequestCharacterEncoding() {     return this.requestCharacterEncoding. }
false;public;1;4;;// on Servlet 4.0 @Override public void setResponseCharacterEncoding(@Nullable String responseCharacterEncoding) {     this.responseCharacterEncoding = responseCharacterEncoding. }
false;public;0;5;;// on Servlet 4.0 @Override @Nullable public String getResponseCharacterEncoding() {     return this.responseCharacterEncoding. }
false;public;0;4;;// --------------------------------------------------------------------- // Unsupported Servlet 3.0 registration methods // --------------------------------------------------------------------- @Override public JspConfigDescriptor getJspConfigDescriptor() {     throw new UnsupportedOperationException(). }
false;public;2;4;;// on Servlet 4.0 @Override public ServletRegistration.Dynamic addJspFile(String servletName, String jspFile) {     throw new UnsupportedOperationException(). }
false;public;2;4;;@Override public ServletRegistration.Dynamic addServlet(String servletName, String className) {     throw new UnsupportedOperationException(). }
false;public;2;4;;@Override public ServletRegistration.Dynamic addServlet(String servletName, Servlet servlet) {     throw new UnsupportedOperationException(). }
false;public;2;4;;@Override public ServletRegistration.Dynamic addServlet(String servletName, Class<? extends Servlet> servletClass) {     throw new UnsupportedOperationException(). }
false;public;1;4;;@Override public <T extends Servlet> T createServlet(Class<T> c) throws ServletException {     throw new UnsupportedOperationException(). }
true;public;1;5;/**  * This method always returns {@code null}.  * @see javax.servlet.ServletContext#getServletRegistration(java.lang.String)  */ ;/**  * This method always returns {@code null}.  * @see javax.servlet.ServletContext#getServletRegistration(java.lang.String)  */ @Override @Nullable public ServletRegistration getServletRegistration(String servletName) {     return null. }
true;public;0;4;/**  * This method always returns an {@linkplain Collections#emptyMap empty map}.  * @see javax.servlet.ServletContext#getServletRegistrations()  */ ;/**  * This method always returns an {@linkplain Collections#emptyMap empty map}.  * @see javax.servlet.ServletContext#getServletRegistrations()  */ @Override public Map<String, ? extends ServletRegistration> getServletRegistrations() {     return Collections.emptyMap(). }
false;public;2;4;;@Override public FilterRegistration.Dynamic addFilter(String filterName, String className) {     throw new UnsupportedOperationException(). }
false;public;2;4;;@Override public FilterRegistration.Dynamic addFilter(String filterName, Filter filter) {     throw new UnsupportedOperationException(). }
false;public;2;4;;@Override public FilterRegistration.Dynamic addFilter(String filterName, Class<? extends Filter> filterClass) {     throw new UnsupportedOperationException(). }
false;public;1;4;;@Override public <T extends Filter> T createFilter(Class<T> c) throws ServletException {     throw new UnsupportedOperationException(). }
true;public;1;5;/**  * This method always returns {@code null}.  * @see javax.servlet.ServletContext#getFilterRegistration(java.lang.String)  */ ;/**  * This method always returns {@code null}.  * @see javax.servlet.ServletContext#getFilterRegistration(java.lang.String)  */ @Override @Nullable public FilterRegistration getFilterRegistration(String filterName) {     return null. }
true;public;0;4;/**  * This method always returns an {@linkplain Collections#emptyMap empty map}.  * @see javax.servlet.ServletContext#getFilterRegistrations()  */ ;/**  * This method always returns an {@linkplain Collections#emptyMap empty map}.  * @see javax.servlet.ServletContext#getFilterRegistrations()  */ @Override public Map<String, ? extends FilterRegistration> getFilterRegistrations() {     return Collections.emptyMap(). }
false;public;1;4;;@Override public void addListener(Class<? extends EventListener> listenerClass) {     throw new UnsupportedOperationException(). }
false;public;1;4;;@Override public void addListener(String className) {     throw new UnsupportedOperationException(). }
false;public;1;4;;@Override public <T extends EventListener> void addListener(T t) {     throw new UnsupportedOperationException(). }
false;public;1;4;;@Override public <T extends EventListener> T createListener(Class<T> c) throws ServletException {     throw new UnsupportedOperationException(). }
false;public;0;4;;@Override public String getVirtualServerName() {     throw new UnsupportedOperationException(). }
