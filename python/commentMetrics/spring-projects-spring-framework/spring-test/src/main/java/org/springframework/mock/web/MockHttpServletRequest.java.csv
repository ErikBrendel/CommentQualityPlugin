commented;modifiers;parameterAmount;loc;comment;code
true;public;0;4;/**  * Return the ServletContext that this request is associated with. (Not  * available in the standard HttpServletRequest interface for some reason.)  */ ;// --------------------------------------------------------------------- // Lifecycle methods // --------------------------------------------------------------------- /**  * Return the ServletContext that this request is associated with. (Not  * available in the standard HttpServletRequest interface for some reason.)  */ @Override public ServletContext getServletContext() {     return this.servletContext. }
true;public;0;3;/**  * Return whether this request is still active (that is, not completed yet).  */ ;/**  * Return whether this request is still active (that is, not completed yet).  */ public boolean isActive() {     return this.active. }
true;public;0;3;/**  * Mark this request as completed, keeping its state.  */ ;/**  * Mark this request as completed, keeping its state.  */ public void close() {     this.active = false. }
true;public;0;4;/**  * Invalidate this request, clearing its state.  */ ;/**  * Invalidate this request, clearing its state.  */ public void invalidate() {     close().     clearAttributes(). }
true;protected;0;3;/**  * Check whether this request is still active (that is, not completed yet),  * throwing an IllegalStateException if not active anymore.  */ ;/**  * Check whether this request is still active (that is, not completed yet),  * throwing an IllegalStateException if not active anymore.  */ protected void checkActive() throws IllegalStateException {     Assert.state(this.active, "Request is not active anymore"). }
false;public;1;5;;// --------------------------------------------------------------------- // ServletRequest interface // --------------------------------------------------------------------- @Override public Object getAttribute(String name) {     checkActive().     return this.attributes.get(name). }
false;public;0;5;;@Override public Enumeration<String> getAttributeNames() {     checkActive().     return Collections.enumeration(new LinkedHashSet<>(this.attributes.keySet())). }
false;public;0;5;;@Override @Nullable public String getCharacterEncoding() {     return this.characterEncoding. }
false;public;1;5;;@Override public void setCharacterEncoding(@Nullable String characterEncoding) {     this.characterEncoding = characterEncoding.     updateContentTypeHeader(). }
false;private;0;10;;private void updateContentTypeHeader() {     if (StringUtils.hasLength(this.contentType)) {         StringBuilder sb = new StringBuilder(this.contentType).         if (!this.contentType.toLowerCase().contains(CHARSET_PREFIX) && StringUtils.hasLength(this.characterEncoding)) {             sb.append(".").append(CHARSET_PREFIX).append(this.characterEncoding).         }         doAddHeaderValue(HttpHeaders.CONTENT_TYPE, sb.toString(), true).     } }
true;public;1;5;/**  * Set the content of the request body as a byte array.  * <p>If the supplied byte array represents text such as XML or JSON, the  * {@link #setCharacterEncoding character encoding} should typically be  * set as well.  * @see #setCharacterEncoding(String)  * @see #getContentAsByteArray()  * @see #getContentAsString()  */ ;/**  * Set the content of the request body as a byte array.  * <p>If the supplied byte array represents text such as XML or JSON, the  * {@link #setCharacterEncoding character encoding} should typically be  * set as well.  * @see #setCharacterEncoding(String)  * @see #getContentAsByteArray()  * @see #getContentAsString()  */ public void setContent(@Nullable byte[] content) {     this.content = content.     this.inputStream = null.     this.reader = null. }
true;public;0;4;/**  * Get the content of the request body as a byte array.  * @return the content as a byte array (potentially {@code null})  * @since 5.0  * @see #setContent(byte[])  * @see #getContentAsString()  */ ;/**  * Get the content of the request body as a byte array.  * @return the content as a byte array (potentially {@code null})  * @since 5.0  * @see #setContent(byte[])  * @see #getContentAsString()  */ @Nullable public byte[] getContentAsByteArray() {     return this.content. }
true;public;0;11;/**  * Get the content of the request body as a {@code String}, using the configured  * {@linkplain #getCharacterEncoding character encoding}.  * @return the content as a {@code String}, potentially {@code null}  * @throws IllegalStateException if the character encoding has not been set  * @throws UnsupportedEncodingException if the character encoding is not supported  * @since 5.0  * @see #setContent(byte[])  * @see #setCharacterEncoding(String)  * @see #getContentAsByteArray()  */ ;/**  * Get the content of the request body as a {@code String}, using the configured  * {@linkplain #getCharacterEncoding character encoding}.  * @return the content as a {@code String}, potentially {@code null}  * @throws IllegalStateException if the character encoding has not been set  * @throws UnsupportedEncodingException if the character encoding is not supported  * @since 5.0  * @see #setContent(byte[])  * @see #setCharacterEncoding(String)  * @see #getContentAsByteArray()  */ @Nullable public String getContentAsString() throws IllegalStateException, UnsupportedEncodingException {     Assert.state(this.characterEncoding != null, "Cannot get content as a String for a null character encoding. " + "Consider setting the characterEncoding in the request.").     if (this.content == null) {         return null.     }     return new String(this.content, this.characterEncoding). }
false;public;0;4;;@Override public int getContentLength() {     return (this.content != null ? this.content.length : -1). }
false;public;0;4;;@Override public long getContentLengthLong() {     return getContentLength(). }
false;public;1;19;;public void setContentType(@Nullable String contentType) {     this.contentType = contentType.     if (contentType != null) {         try {             MediaType mediaType = MediaType.parseMediaType(contentType).             if (mediaType.getCharset() != null) {                 this.characterEncoding = mediaType.getCharset().name().             }         } catch (IllegalArgumentException ex) {             // Try to get charset value anyway             int charsetIndex = contentType.toLowerCase().indexOf(CHARSET_PREFIX).             if (charsetIndex != -1) {                 this.characterEncoding = contentType.substring(charsetIndex + CHARSET_PREFIX.length()).             }         }         updateContentTypeHeader().     } }
false;public;0;5;;@Override @Nullable public String getContentType() {     return this.contentType. }
false;public;0;15;;@Override public ServletInputStream getInputStream() {     if (this.inputStream != null) {         return this.inputStream.     } else if (this.reader != null) {         throw new IllegalStateException("Cannot call getInputStream() after getReader() has already been called for the current request").     }     this.inputStream = (this.content != null ? new DelegatingServletInputStream(new ByteArrayInputStream(this.content)) : EMPTY_SERVLET_INPUT_STREAM).     return this.inputStream. }
true;public;2;3;/**  * Set a single value for the specified HTTP parameter.  * <p>If there are already one or more values registered for the given  * parameter name, they will be replaced.  */ ;/**  * Set a single value for the specified HTTP parameter.  * <p>If there are already one or more values registered for the given  * parameter name, they will be replaced.  */ public void setParameter(String name, String value) {     setParameter(name, new String[] { value }). }
true;public;2;4;/**  * Set an array of values for the specified HTTP parameter.  * <p>If there are already one or more values registered for the given  * parameter name, they will be replaced.  */ ;/**  * Set an array of values for the specified HTTP parameter.  * <p>If there are already one or more values registered for the given  * parameter name, they will be replaced.  */ public void setParameter(String name, String... values) {     Assert.notNull(name, "Parameter name must not be null").     this.parameters.put(name, values). }
true;public;1;15;/**  * Set all provided parameters <strong>replacing</strong> any existing  * values for the provided parameter names. To add without replacing  * existing values, use {@link #addParameters(java.util.Map)}.  */ ;/**  * Set all provided parameters <strong>replacing</strong> any existing  * values for the provided parameter names. To add without replacing  * existing values, use {@link #addParameters(java.util.Map)}.  */ public void setParameters(Map<String, ?> params) {     Assert.notNull(params, "Parameter map must not be null").     params.forEach((key, value) -> {         if (value instanceof String) {             setParameter(key, (String) value).         } else if (value instanceof String[]) {             setParameter(key, (String[]) value).         } else {             throw new IllegalArgumentException("Parameter map value must be single value " + " or array of type [" + String.class.getName() + "]").         }     }). }
true;public;2;3;/**  * Add a single value for the specified HTTP parameter.  * <p>If there are already one or more values registered for the given  * parameter name, the given value will be added to the end of the list.  */ ;/**  * Add a single value for the specified HTTP parameter.  * <p>If there are already one or more values registered for the given  * parameter name, the given value will be added to the end of the list.  */ public void addParameter(String name, @Nullable String value) {     addParameter(name, new String[] { value }). }
true;public;2;13;/**  * Add an array of values for the specified HTTP parameter.  * <p>If there are already one or more values registered for the given  * parameter name, the given values will be added to the end of the list.  */ ;/**  * Add an array of values for the specified HTTP parameter.  * <p>If there are already one or more values registered for the given  * parameter name, the given values will be added to the end of the list.  */ public void addParameter(String name, String... values) {     Assert.notNull(name, "Parameter name must not be null").     String[] oldArr = this.parameters.get(name).     if (oldArr != null) {         String[] newArr = new String[oldArr.length + values.length].         System.arraycopy(oldArr, 0, newArr, 0, oldArr.length).         System.arraycopy(values, 0, newArr, oldArr.length, values.length).         this.parameters.put(name, newArr).     } else {         this.parameters.put(name, values).     } }
true;public;1;15;/**  * Add all provided parameters <strong>without</strong> replacing any  * existing values. To replace existing values, use  * {@link #setParameters(java.util.Map)}.  */ ;/**  * Add all provided parameters <strong>without</strong> replacing any  * existing values. To replace existing values, use  * {@link #setParameters(java.util.Map)}.  */ public void addParameters(Map<String, ?> params) {     Assert.notNull(params, "Parameter map must not be null").     params.forEach((key, value) -> {         if (value instanceof String) {             addParameter(key, (String) value).         } else if (value instanceof String[]) {             addParameter(key, (String[]) value).         } else {             throw new IllegalArgumentException("Parameter map value must be single value " + " or array of type [" + String.class.getName() + "]").         }     }). }
true;public;1;4;/**  * Remove already registered values for the specified HTTP parameter, if any.  */ ;/**  * Remove already registered values for the specified HTTP parameter, if any.  */ public void removeParameter(String name) {     Assert.notNull(name, "Parameter name must not be null").     this.parameters.remove(name). }
true;public;0;3;/**  * Remove all existing parameters.  */ ;/**  * Remove all existing parameters.  */ public void removeAllParameters() {     this.parameters.clear(). }
false;public;1;7;;@Override @Nullable public String getParameter(String name) {     Assert.notNull(name, "Parameter name must not be null").     String[] arr = this.parameters.get(name).     return (arr != null && arr.length > 0 ? arr[0] : null). }
false;public;0;4;;@Override public Enumeration<String> getParameterNames() {     return Collections.enumeration(this.parameters.keySet()). }
false;public;1;5;;@Override public String[] getParameterValues(String name) {     Assert.notNull(name, "Parameter name must not be null").     return this.parameters.get(name). }
false;public;0;4;;@Override public Map<String, String[]> getParameterMap() {     return Collections.unmodifiableMap(this.parameters). }
false;public;1;3;;public void setProtocol(String protocol) {     this.protocol = protocol. }
false;public;0;4;;@Override public String getProtocol() {     return this.protocol. }
false;public;1;3;;public void setScheme(String scheme) {     this.scheme = scheme. }
false;public;0;4;;@Override public String getScheme() {     return this.scheme. }
false;public;1;3;;public void setServerName(String serverName) {     this.serverName = serverName. }
false;public;0;17;;@Override public String getServerName() {     String host = getHeader(HttpHeaders.HOST).     if (host != null) {         host = host.trim().         if (host.startsWith("[")) {             host = host.substring(1, host.indexOf(']')).         } else if (host.contains(":")) {             host = host.substring(0, host.indexOf(':')).         }         return host.     }     // else     return this.serverName. }
false;public;1;3;;public void setServerPort(int serverPort) {     this.serverPort = serverPort. }
false;public;0;20;;@Override public int getServerPort() {     String host = getHeader(HttpHeaders.HOST).     if (host != null) {         host = host.trim().         int idx.         if (host.startsWith("[")) {             idx = host.indexOf(':', host.indexOf(']')).         } else {             idx = host.indexOf(':').         }         if (idx != -1) {             return Integer.parseInt(host.substring(idx + 1)).         }     }     // else     return this.serverPort. }
false;public;0;22;;@Override public BufferedReader getReader() throws UnsupportedEncodingException {     if (this.reader != null) {         return this.reader.     } else if (this.inputStream != null) {         throw new IllegalStateException("Cannot call getReader() after getInputStream() has already been called for the current request").     }     if (this.content != null) {         InputStream sourceStream = new ByteArrayInputStream(this.content).         Reader sourceReader = (this.characterEncoding != null) ? new InputStreamReader(sourceStream, this.characterEncoding) : new InputStreamReader(sourceStream).         this.reader = new BufferedReader(sourceReader).     } else {         this.reader = EMPTY_BUFFERED_READER.     }     return this.reader. }
false;public;1;3;;public void setRemoteAddr(String remoteAddr) {     this.remoteAddr = remoteAddr. }
false;public;0;4;;@Override public String getRemoteAddr() {     return this.remoteAddr. }
false;public;1;3;;public void setRemoteHost(String remoteHost) {     this.remoteHost = remoteHost. }
false;public;0;4;;@Override public String getRemoteHost() {     return this.remoteHost. }
false;public;2;11;;@Override public void setAttribute(String name, @Nullable Object value) {     checkActive().     Assert.notNull(name, "Attribute name must not be null").     if (value != null) {         this.attributes.put(name, value).     } else {         this.attributes.remove(name).     } }
false;public;1;6;;@Override public void removeAttribute(String name) {     checkActive().     Assert.notNull(name, "Attribute name must not be null").     this.attributes.remove(name). }
true;public;0;3;/**  * Clear all of this request's attributes.  */ ;/**  * Clear all of this request's attributes.  */ public void clearAttributes() {     this.attributes.clear(). }
true;public;1;5;/**  * Add a new preferred locale, before any existing locales.  * @see #setPreferredLocales  */ ;/**  * Add a new preferred locale, before any existing locales.  * @see #setPreferredLocales  */ public void addPreferredLocale(Locale locale) {     Assert.notNull(locale, "Locale must not be null").     this.locales.add(0, locale).     updateAcceptLanguageHeader(). }
true;public;1;6;/**  * Set the list of preferred locales, in descending order, effectively replacing  * any existing locales.  * @since 3.2  * @see #addPreferredLocale  */ ;/**  * Set the list of preferred locales, in descending order, effectively replacing  * any existing locales.  * @since 3.2  * @see #addPreferredLocale  */ public void setPreferredLocales(List<Locale> locales) {     Assert.notEmpty(locales, "Locale list must not be empty").     this.locales.clear().     this.locales.addAll(locales).     updateAcceptLanguageHeader(). }
false;private;0;5;;private void updateAcceptLanguageHeader() {     HttpHeaders headers = new HttpHeaders().     headers.setAcceptLanguageAsLocales(this.locales).     doAddHeaderValue(HttpHeaders.ACCEPT_LANGUAGE, headers.getFirst(HttpHeaders.ACCEPT_LANGUAGE), true). }
true;public;0;4;/**  * Return the first preferred {@linkplain Locale locale} configured  * in this mock request.  * <p>If no locales have been explicitly configured, the default,  * preferred {@link Locale} for the <em>server</em> mocked by this  * request is {@link Locale#ENGLISH}.  * <p>In contrast to the Servlet specification, this mock implementation  * does <strong>not</strong> take into consideration any locales  * specified via the {@code Accept-Language} header.  * @see javax.servlet.ServletRequest#getLocale()  * @see #addPreferredLocale(Locale)  * @see #setPreferredLocales(List)  */ ;/**  * Return the first preferred {@linkplain Locale locale} configured  * in this mock request.  * <p>If no locales have been explicitly configured, the default,  * preferred {@link Locale} for the <em>server</em> mocked by this  * request is {@link Locale#ENGLISH}.  * <p>In contrast to the Servlet specification, this mock implementation  * does <strong>not</strong> take into consideration any locales  * specified via the {@code Accept-Language} header.  * @see javax.servlet.ServletRequest#getLocale()  * @see #addPreferredLocale(Locale)  * @see #setPreferredLocales(List)  */ @Override public Locale getLocale() {     return this.locales.get(0). }
true;public;0;4;/**  * Return an {@linkplain Enumeration enumeration} of the preferred  * {@linkplain Locale locales} configured in this mock request.  * <p>If no locales have been explicitly configured, the default,  * preferred {@link Locale} for the <em>server</em> mocked by this  * request is {@link Locale#ENGLISH}.  * <p>In contrast to the Servlet specification, this mock implementation  * does <strong>not</strong> take into consideration any locales  * specified via the {@code Accept-Language} header.  * @see javax.servlet.ServletRequest#getLocales()  * @see #addPreferredLocale(Locale)  * @see #setPreferredLocales(List)  */ ;/**  * Return an {@linkplain Enumeration enumeration} of the preferred  * {@linkplain Locale locales} configured in this mock request.  * <p>If no locales have been explicitly configured, the default,  * preferred {@link Locale} for the <em>server</em> mocked by this  * request is {@link Locale#ENGLISH}.  * <p>In contrast to the Servlet specification, this mock implementation  * does <strong>not</strong> take into consideration any locales  * specified via the {@code Accept-Language} header.  * @see javax.servlet.ServletRequest#getLocales()  * @see #addPreferredLocale(Locale)  * @see #setPreferredLocales(List)  */ @Override public Enumeration<Locale> getLocales() {     return Collections.enumeration(this.locales). }
true;public;1;3;/**  * Set the boolean {@code secure} flag indicating whether the mock request  * was made using a secure channel, such as HTTPS.  * @see #isSecure()  * @see #getScheme()  * @see #setScheme(String)  */ ;/**  * Set the boolean {@code secure} flag indicating whether the mock request  * was made using a secure channel, such as HTTPS.  * @see #isSecure()  * @see #getScheme()  * @see #setScheme(String)  */ public void setSecure(boolean secure) {     this.secure = secure. }
true;public;0;4;/**  * Return {@code true} if the {@link #setSecure secure} flag has been set  * to {@code true} or if the {@link #getScheme scheme} is {@code https}.  * @see javax.servlet.ServletRequest#isSecure()  */ ;/**  * Return {@code true} if the {@link #setSecure secure} flag has been set  * to {@code true} or if the {@link #getScheme scheme} is {@code https}.  * @see javax.servlet.ServletRequest#isSecure()  */ @Override public boolean isSecure() {     return (this.secure || HTTPS.equalsIgnoreCase(this.scheme)). }
false;public;1;4;;@Override public RequestDispatcher getRequestDispatcher(String path) {     return new MockRequestDispatcher(path). }
false;public;1;5;;@Override @Deprecated public String getRealPath(String path) {     return this.servletContext.getRealPath(path). }
false;public;1;3;;public void setRemotePort(int remotePort) {     this.remotePort = remotePort. }
false;public;0;4;;@Override public int getRemotePort() {     return this.remotePort. }
false;public;1;3;;public void setLocalName(String localName) {     this.localName = localName. }
false;public;0;4;;@Override public String getLocalName() {     return this.localName. }
false;public;1;3;;public void setLocalAddr(String localAddr) {     this.localAddr = localAddr. }
false;public;0;4;;@Override public String getLocalAddr() {     return this.localAddr. }
false;public;1;3;;public void setLocalPort(int localPort) {     this.localPort = localPort. }
false;public;0;4;;@Override public int getLocalPort() {     return this.localPort. }
false;public;0;4;;@Override public AsyncContext startAsync() {     return startAsync(this, null). }
false;public;2;7;;@Override public AsyncContext startAsync(ServletRequest request, @Nullable ServletResponse response) {     Assert.state(this.asyncSupported, "Async not supported").     this.asyncStarted = true.     this.asyncContext = new MockAsyncContext(request, response).     return this.asyncContext. }
false;public;1;3;;public void setAsyncStarted(boolean asyncStarted) {     this.asyncStarted = asyncStarted. }
false;public;0;4;;@Override public boolean isAsyncStarted() {     return this.asyncStarted. }
false;public;1;3;;public void setAsyncSupported(boolean asyncSupported) {     this.asyncSupported = asyncSupported. }
false;public;0;4;;@Override public boolean isAsyncSupported() {     return this.asyncSupported. }
false;public;1;3;;public void setAsyncContext(@Nullable MockAsyncContext asyncContext) {     this.asyncContext = asyncContext. }
false;public;0;5;;@Override @Nullable public AsyncContext getAsyncContext() {     return this.asyncContext. }
false;public;1;3;;public void setDispatcherType(DispatcherType dispatcherType) {     this.dispatcherType = dispatcherType. }
false;public;0;4;;@Override public DispatcherType getDispatcherType() {     return this.dispatcherType. }
false;public;1;3;;// --------------------------------------------------------------------- // HttpServletRequest interface // --------------------------------------------------------------------- public void setAuthType(@Nullable String authType) {     this.authType = authType. }
false;public;0;5;;@Override @Nullable public String getAuthType() {     return this.authType. }
false;public;1;9;;public void setCookies(@Nullable Cookie... cookies) {     this.cookies = (ObjectUtils.isEmpty(cookies) ? null : cookies).     this.headers.remove(HttpHeaders.COOKIE).     if (this.cookies != null) {         Arrays.stream(this.cookies).map(c -> c.getName() + '=' + (c.getValue() == null ? "" : c.getValue())).forEach(value -> doAddHeaderValue(HttpHeaders.COOKIE, value, false)).     } }
false;public;0;5;;@Override @Nullable public Cookie[] getCookies() {     return this.cookies. }
true;public;2;23;/**  * Add an HTTP header entry for the given name.  * <p>While this method can take any {@code Object} as a parameter,  * it is recommended to use the following types:  * <ul>  * <li>String or any Object to be converted using {@code toString()}. see {@link #getHeader}.</li>  * <li>String, Number, or Date for date headers. see {@link #getDateHeader}.</li>  * <li>String or Number for integer headers. see {@link #getIntHeader}.</li>  * <li>{@code String[]} or {@code Collection<String>} for multiple values. see {@link #getHeaders}.</li>  * </ul>  * @see #getHeaderNames  * @see #getHeaders  * @see #getHeader  * @see #getDateHeader  */ ;/**  * Add an HTTP header entry for the given name.  * <p>While this method can take any {@code Object} as a parameter,  * it is recommended to use the following types:  * <ul>  * <li>String or any Object to be converted using {@code toString()}. see {@link #getHeader}.</li>  * <li>String, Number, or Date for date headers. see {@link #getDateHeader}.</li>  * <li>String or Number for integer headers. see {@link #getIntHeader}.</li>  * <li>{@code String[]} or {@code Collection<String>} for multiple values. see {@link #getHeaders}.</li>  * </ul>  * @see #getHeaderNames  * @see #getHeaders  * @see #getHeader  * @see #getDateHeader  */ public void addHeader(String name, Object value) {     if (HttpHeaders.CONTENT_TYPE.equalsIgnoreCase(name) && !this.headers.containsKey(HttpHeaders.CONTENT_TYPE)) {         setContentType(value.toString()).     } else if (HttpHeaders.ACCEPT_LANGUAGE.equalsIgnoreCase(name) && !this.headers.containsKey(HttpHeaders.ACCEPT_LANGUAGE)) {         try {             HttpHeaders headers = new HttpHeaders().             headers.add(HttpHeaders.ACCEPT_LANGUAGE, value.toString()).             List<Locale> locales = headers.getAcceptLanguageAsLocales().             this.locales.clear().             this.locales.addAll(locales).         } catch (IllegalArgumentException ex) {         // Invalid Accept-Language format -> just store plain header         }         doAddHeaderValue(name, value, true).     } else {         doAddHeaderValue(name, value, false).     } }
false;private;3;17;;private void doAddHeaderValue(String name, @Nullable Object value, boolean replace) {     HeaderValueHolder header = HeaderValueHolder.getByName(this.headers, name).     Assert.notNull(value, "Header value must not be null").     if (header == null || replace) {         header = new HeaderValueHolder().         this.headers.put(name, header).     }     if (value instanceof Collection) {         header.addValues((Collection<?>) value).     } else if (value.getClass().isArray()) {         header.addValueArray(value).     } else {         header.addValue(value).     } }
true;public;1;4;/**  * Remove already registered entries for the specified HTTP header, if any.  * @since 4.3.20  */ ;/**  * Remove already registered entries for the specified HTTP header, if any.  * @since 4.3.20  */ public void removeHeader(String name) {     Assert.notNull(name, "Header name must not be null").     this.headers.remove(name). }
true;public;1;21;/**  * Return the long timestamp for the date header with the given {@code name}.  * <p>If the internal value representation is a String, this method will try  * to parse it as a date using the supported date formats:  * <ul>  * <li>"EEE, dd MMM yyyy HH:mm:ss zzz"</li>  * <li>"EEE, dd-MMM-yy HH:mm:ss zzz"</li>  * <li>"EEE MMM dd HH:mm:ss yyyy"</li>  * </ul>  * @param name the header name  * @see <a href="https://tools.ietf.org/html/rfc7231#section-7.1.1.1">Section 7.1.1.1 of RFC 7231</a>  */ ;/**  * Return the long timestamp for the date header with the given {@code name}.  * <p>If the internal value representation is a String, this method will try  * to parse it as a date using the supported date formats:  * <ul>  * <li>"EEE, dd MMM yyyy HH:mm:ss zzz"</li>  * <li>"EEE, dd-MMM-yy HH:mm:ss zzz"</li>  * <li>"EEE MMM dd HH:mm:ss yyyy"</li>  * </ul>  * @param name the header name  * @see <a href="https://tools.ietf.org/html/rfc7231#section-7.1.1.1">Section 7.1.1.1 of RFC 7231</a>  */ @Override public long getDateHeader(String name) {     HeaderValueHolder header = HeaderValueHolder.getByName(this.headers, name).     Object value = (header != null ? header.getValue() : null).     if (value instanceof Date) {         return ((Date) value).getTime().     } else if (value instanceof Number) {         return ((Number) value).longValue().     } else if (value instanceof String) {         return parseDateHeader(name, (String) value).     } else if (value != null) {         throw new IllegalArgumentException("Value for header '" + name + "' is not a Date, Number, or String: " + value).     } else {         return -1L.     } }
false;private;2;13;;private long parseDateHeader(String name, String value) {     for (String dateFormat : DATE_FORMATS) {         SimpleDateFormat simpleDateFormat = new SimpleDateFormat(dateFormat, Locale.US).         simpleDateFormat.setTimeZone(GMT).         try {             return simpleDateFormat.parse(value).getTime().         } catch (ParseException ex) {         // ignore         }     }     throw new IllegalArgumentException("Cannot parse date value '" + value + "' for '" + name + "' header"). }
false;public;1;6;;@Override @Nullable public String getHeader(String name) {     HeaderValueHolder header = HeaderValueHolder.getByName(this.headers, name).     return (header != null ? header.getStringValue() : null). }
false;public;1;5;;@Override public Enumeration<String> getHeaders(String name) {     HeaderValueHolder header = HeaderValueHolder.getByName(this.headers, name).     return Collections.enumeration(header != null ? header.getStringValues() : new LinkedList<>()). }
false;public;0;4;;@Override public Enumeration<String> getHeaderNames() {     return Collections.enumeration(this.headers.keySet()). }
false;public;1;17;;@Override public int getIntHeader(String name) {     HeaderValueHolder header = HeaderValueHolder.getByName(this.headers, name).     Object value = (header != null ? header.getValue() : null).     if (value instanceof Number) {         return ((Number) value).intValue().     } else if (value instanceof String) {         return Integer.parseInt((String) value).     } else if (value != null) {         throw new NumberFormatException("Value for header '" + name + "' is not a Number: " + value).     } else {         return -1.     } }
false;public;1;3;;public void setMethod(@Nullable String method) {     this.method = method. }
false;public;0;5;;@Override @Nullable public String getMethod() {     return this.method. }
false;public;1;3;;public void setPathInfo(@Nullable String pathInfo) {     this.pathInfo = pathInfo. }
false;public;0;5;;@Override @Nullable public String getPathInfo() {     return this.pathInfo. }
false;public;0;5;;@Override @Nullable public String getPathTranslated() {     return (this.pathInfo != null ? getRealPath(this.pathInfo) : null). }
false;public;1;3;;public void setContextPath(String contextPath) {     this.contextPath = contextPath. }
false;public;0;4;;@Override public String getContextPath() {     return this.contextPath. }
false;public;1;3;;public void setQueryString(@Nullable String queryString) {     this.queryString = queryString. }
false;public;0;5;;@Override @Nullable public String getQueryString() {     return this.queryString. }
false;public;1;3;;public void setRemoteUser(@Nullable String remoteUser) {     this.remoteUser = remoteUser. }
false;public;0;5;;@Override @Nullable public String getRemoteUser() {     return this.remoteUser. }
false;public;1;3;;public void addUserRole(String role) {     this.userRoles.add(role). }
false;public;1;5;;@Override public boolean isUserInRole(String role) {     return (this.userRoles.contains(role) || (this.servletContext instanceof MockServletContext && ((MockServletContext) this.servletContext).getDeclaredRoles().contains(role))). }
false;public;1;3;;public void setUserPrincipal(@Nullable Principal userPrincipal) {     this.userPrincipal = userPrincipal. }
false;public;0;5;;@Override @Nullable public Principal getUserPrincipal() {     return this.userPrincipal. }
false;public;1;3;;public void setRequestedSessionId(@Nullable String requestedSessionId) {     this.requestedSessionId = requestedSessionId. }
false;public;0;5;;@Override @Nullable public String getRequestedSessionId() {     return this.requestedSessionId. }
false;public;1;3;;public void setRequestURI(@Nullable String requestURI) {     this.requestURI = requestURI. }
false;public;0;5;;@Override @Nullable public String getRequestURI() {     return this.requestURI. }
false;public;0;17;;@Override public StringBuffer getRequestURL() {     String scheme = getScheme().     String server = getServerName().     int port = getServerPort().     String uri = getRequestURI().     StringBuffer url = new StringBuffer(scheme).append("://").append(server).     if (port > 0 && ((HTTP.equalsIgnoreCase(scheme) && port != 80) || (HTTPS.equalsIgnoreCase(scheme) && port != 443))) {         url.append(':').append(port).     }     if (StringUtils.hasText(uri)) {         url.append(uri).     }     return url. }
false;public;1;3;;public void setServletPath(String servletPath) {     this.servletPath = servletPath. }
false;public;0;4;;@Override public String getServletPath() {     return this.servletPath. }
false;public;1;7;;public void setSession(HttpSession session) {     this.session = session.     if (session instanceof MockHttpSession) {         MockHttpSession mockSession = ((MockHttpSession) session).         mockSession.access().     } }
false;public;1;14;;@Override @Nullable public HttpSession getSession(boolean create) {     checkActive().     // Reset session if invalidated.     if (this.session instanceof MockHttpSession && ((MockHttpSession) this.session).isInvalid()) {         this.session = null.     }     // Create new session if necessary.     if (this.session == null && create) {         this.session = new MockHttpSession(this.servletContext).     }     return this.session. }
false;public;0;5;;@Override @Nullable public HttpSession getSession() {     return getSession(true). }
true;public;0;7;/**  * The implementation of this (Servlet 3.1+) method calls  * {@link MockHttpSession#changeSessionId()} if the session is a mock session.  * Otherwise it simply returns the current session id.  * @since 4.0.3  */ ;/**  * The implementation of this (Servlet 3.1+) method calls  * {@link MockHttpSession#changeSessionId()} if the session is a mock session.  * Otherwise it simply returns the current session id.  * @since 4.0.3  */ public String changeSessionId() {     Assert.isTrue(this.session != null, "The request does not have a session").     if (this.session instanceof MockHttpSession) {         return ((MockHttpSession) this.session).changeSessionId().     }     return this.session.getId(). }
false;public;1;3;;public void setRequestedSessionIdValid(boolean requestedSessionIdValid) {     this.requestedSessionIdValid = requestedSessionIdValid. }
false;public;0;4;;@Override public boolean isRequestedSessionIdValid() {     return this.requestedSessionIdValid. }
false;public;1;3;;public void setRequestedSessionIdFromCookie(boolean requestedSessionIdFromCookie) {     this.requestedSessionIdFromCookie = requestedSessionIdFromCookie. }
false;public;0;4;;@Override public boolean isRequestedSessionIdFromCookie() {     return this.requestedSessionIdFromCookie. }
false;public;1;3;;public void setRequestedSessionIdFromURL(boolean requestedSessionIdFromURL) {     this.requestedSessionIdFromURL = requestedSessionIdFromURL. }
false;public;0;4;;@Override public boolean isRequestedSessionIdFromURL() {     return this.requestedSessionIdFromURL. }
false;public;0;5;;@Override @Deprecated public boolean isRequestedSessionIdFromUrl() {     return isRequestedSessionIdFromURL(). }
false;public;1;4;;@Override public boolean authenticate(HttpServletResponse response) throws IOException, ServletException {     throw new UnsupportedOperationException(). }
false;public;2;4;;@Override public void login(String username, String password) throws ServletException {     throw new UnsupportedOperationException(). }
false;public;0;6;;@Override public void logout() throws ServletException {     this.userPrincipal = null.     this.remoteUser = null.     this.authType = null. }
false;public;1;3;;public void addPart(Part part) {     this.parts.add(part.getName(), part). }
false;public;1;5;;@Override @Nullable public Part getPart(String name) throws IOException, ServletException {     return this.parts.getFirst(name). }
false;public;0;8;;@Override public Collection<Part> getParts() throws IOException, ServletException {     List<Part> result = new LinkedList<>().     for (List<Part> list : this.parts.values()) {         result.addAll(list).     }     return result. }
false;public;1;4;;@Override public <T extends HttpUpgradeHandler> T upgrade(Class<T> handlerClass) throws IOException, ServletException {     throw new UnsupportedOperationException(). }
