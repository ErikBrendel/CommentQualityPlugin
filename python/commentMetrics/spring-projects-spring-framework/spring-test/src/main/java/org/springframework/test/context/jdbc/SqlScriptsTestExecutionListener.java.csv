commented;modifiers;parameterAmount;loc;comment;code
true;public,final;0;4;/**  * Returns {@code 5000}.  */ ;/**  * Returns {@code 5000}.  */ @Override public final int getOrder() {     return 5000. }
true;public;1;4;/**  * Execute SQL scripts configured via {@link Sql @Sql} for the supplied  * {@link TestContext} <em>before</em> the current test method.  */ ;/**  * Execute SQL scripts configured via {@link Sql @Sql} for the supplied  * {@link TestContext} <em>before</em> the current test method.  */ @Override public void beforeTestMethod(TestContext testContext) throws Exception {     executeSqlScripts(testContext, ExecutionPhase.BEFORE_TEST_METHOD). }
true;public;1;4;/**  * Execute SQL scripts configured via {@link Sql @Sql} for the supplied  * {@link TestContext} <em>after</em> the current test method.  */ ;/**  * Execute SQL scripts configured via {@link Sql @Sql} for the supplied  * {@link TestContext} <em>after</em> the current test method.  */ @Override public void afterTestMethod(TestContext testContext) throws Exception {     executeSqlScripts(testContext, ExecutionPhase.AFTER_TEST_METHOD). }
true;private;2;17;/**  * Execute SQL scripts configured via {@link Sql @Sql} for the supplied  * {@link TestContext} and {@link ExecutionPhase}.  */ ;/**  * Execute SQL scripts configured via {@link Sql @Sql} for the supplied  * {@link TestContext} and {@link ExecutionPhase}.  */ private void executeSqlScripts(TestContext testContext, ExecutionPhase executionPhase) throws Exception {     boolean classLevel = false.     Set<Sql> sqlAnnotations = AnnotatedElementUtils.getMergedRepeatableAnnotations(testContext.getTestMethod(), Sql.class, SqlGroup.class).     if (sqlAnnotations.isEmpty()) {         sqlAnnotations = AnnotatedElementUtils.getMergedRepeatableAnnotations(testContext.getTestClass(), Sql.class, SqlGroup.class).         if (!sqlAnnotations.isEmpty()) {             classLevel = true.         }     }     for (Sql sql : sqlAnnotations) {         executeSqlScripts(sql, executionPhase, testContext, classLevel).     } }
true;private;4;78;/**  * Execute the SQL scripts configured via the supplied {@link Sql @Sql}  * annotation for the given {@link ExecutionPhase} and {@link TestContext}.  * <p>Special care must be taken in order to properly support the configured  * {@link SqlConfig#transactionMode}.  * @param sql the {@code @Sql} annotation to parse  * @param executionPhase the current execution phase  * @param testContext the current {@code TestContext}  * @param classLevel {@code true} if {@link Sql @Sql} was declared at the class level  */ ;/**  * Execute the SQL scripts configured via the supplied {@link Sql @Sql}  * annotation for the given {@link ExecutionPhase} and {@link TestContext}.  * <p>Special care must be taken in order to properly support the configured  * {@link SqlConfig#transactionMode}.  * @param sql the {@code @Sql} annotation to parse  * @param executionPhase the current execution phase  * @param testContext the current {@code TestContext}  * @param classLevel {@code true} if {@link Sql @Sql} was declared at the class level  */ private void executeSqlScripts(Sql sql, ExecutionPhase executionPhase, TestContext testContext, boolean classLevel) throws Exception {     if (executionPhase != sql.executionPhase()) {         return.     }     MergedSqlConfig mergedSqlConfig = new MergedSqlConfig(sql.config(), testContext.getTestClass()).     if (logger.isDebugEnabled()) {         logger.debug(String.format("Processing %s for execution phase [%s] and test context %s.", mergedSqlConfig, executionPhase, testContext)).     }     final ResourceDatabasePopulator populator = new ResourceDatabasePopulator().     populator.setSqlScriptEncoding(mergedSqlConfig.getEncoding()).     populator.setSeparator(mergedSqlConfig.getSeparator()).     populator.setCommentPrefix(mergedSqlConfig.getCommentPrefix()).     populator.setBlockCommentStartDelimiter(mergedSqlConfig.getBlockCommentStartDelimiter()).     populator.setBlockCommentEndDelimiter(mergedSqlConfig.getBlockCommentEndDelimiter()).     populator.setContinueOnError(mergedSqlConfig.getErrorMode() == ErrorMode.CONTINUE_ON_ERROR).     populator.setIgnoreFailedDrops(mergedSqlConfig.getErrorMode() == ErrorMode.IGNORE_FAILED_DROPS).     String[] scripts = getScripts(sql, testContext, classLevel).     scripts = TestContextResourceUtils.convertToClasspathResourcePaths(testContext.getTestClass(), scripts).     List<Resource> scriptResources = TestContextResourceUtils.convertToResourceList(testContext.getApplicationContext(), scripts).     for (String stmt : sql.statements()) {         if (StringUtils.hasText(stmt)) {             stmt = stmt.trim().             scriptResources.add(new ByteArrayResource(stmt.getBytes(), "from inlined SQL statement: " + stmt)).         }     }     populator.setScripts(scriptResources.toArray(new Resource[0])).     if (logger.isDebugEnabled()) {         logger.debug("Executing SQL scripts: " + ObjectUtils.nullSafeToString(scriptResources)).     }     String dsName = mergedSqlConfig.getDataSource().     String tmName = mergedSqlConfig.getTransactionManager().     DataSource dataSource = TestContextTransactionUtils.retrieveDataSource(testContext, dsName).     PlatformTransactionManager txMgr = TestContextTransactionUtils.retrieveTransactionManager(testContext, tmName).     boolean newTxRequired = (mergedSqlConfig.getTransactionMode() == TransactionMode.ISOLATED).     if (txMgr == null) {         Assert.state(!newTxRequired, () -> String.format("Failed to execute SQL scripts for test context %s: " + "cannot execute SQL scripts using Transaction Mode " + "[%s] without a PlatformTransactionManager.", testContext, TransactionMode.ISOLATED)).         Assert.state(dataSource != null, () -> String.format("Failed to execute SQL scripts for test context %s: " + "supply at least a DataSource or PlatformTransactionManager.", testContext)).         // Execute scripts directly against the DataSource         populator.execute(dataSource).     } else {         DataSource dataSourceFromTxMgr = getDataSourceFromTransactionManager(txMgr).         // Ensure user configured an appropriate DataSource/TransactionManager pair.         if (dataSource != null && dataSourceFromTxMgr != null && !dataSource.equals(dataSourceFromTxMgr)) {             throw new IllegalStateException(String.format("Failed to execute SQL scripts for test context %s: " + "the configured DataSource [%s] (named '%s') is not the one associated with " + "transaction manager [%s] (named '%s').", testContext, dataSource.getClass().getName(), dsName, txMgr.getClass().getName(), tmName)).         }         if (dataSource == null) {             dataSource = dataSourceFromTxMgr.             Assert.state(dataSource != null, () -> String.format("Failed to execute SQL scripts for " + "test context %s: could not obtain DataSource from transaction manager [%s] (named '%s').", testContext, txMgr.getClass().getName(), tmName)).         }         final DataSource finalDataSource = dataSource.         int propagation = (newTxRequired ? TransactionDefinition.PROPAGATION_REQUIRES_NEW : TransactionDefinition.PROPAGATION_REQUIRED).         TransactionAttribute txAttr = TestContextTransactionUtils.createDelegatingTransactionAttribute(testContext, new DefaultTransactionAttribute(propagation)).         new TransactionTemplate(txMgr, txAttr).execute(status -> {             populator.execute(finalDataSource).             return null.         }).     } }
false;private;1;14;;@Nullable private DataSource getDataSourceFromTransactionManager(PlatformTransactionManager transactionManager) {     try {         Method getDataSourceMethod = transactionManager.getClass().getMethod("getDataSource").         Object obj = ReflectionUtils.invokeMethod(getDataSourceMethod, transactionManager).         if (obj instanceof DataSource) {             return (DataSource) obj.         }     } catch (Exception ex) {     // ignore     }     return null. }
false;private;3;7;;private String[] getScripts(Sql sql, TestContext testContext, boolean classLevel) {     String[] scripts = sql.scripts().     if (ObjectUtils.isEmpty(scripts) && ObjectUtils.isEmpty(sql.statements())) {         scripts = new String[] { detectDefaultScript(testContext, classLevel) }.     }     return scripts. }
true;private;2;30;/**  * Detect a default SQL script by implementing the algorithm defined in  * {@link Sql#scripts}.  */ ;/**  * Detect a default SQL script by implementing the algorithm defined in  * {@link Sql#scripts}.  */ private String detectDefaultScript(TestContext testContext, boolean classLevel) {     Class<?> clazz = testContext.getTestClass().     Method method = testContext.getTestMethod().     String elementType = (classLevel ? "class" : "method").     String elementName = (classLevel ? clazz.getName() : method.toString()).     String resourcePath = ClassUtils.convertClassNameToResourcePath(clazz.getName()).     if (!classLevel) {         resourcePath += "." + method.getName().     }     resourcePath += ".sql".     String prefixedResourcePath = ResourceUtils.CLASSPATH_URL_PREFIX + resourcePath.     ClassPathResource classPathResource = new ClassPathResource(resourcePath).     if (classPathResource.exists()) {         if (logger.isInfoEnabled()) {             logger.info(String.format("Detected default SQL script \"%s\" for test %s [%s]", prefixedResourcePath, elementType, elementName)).         }         return prefixedResourcePath.     } else {         String msg = String.format("Could not detect default SQL script for test %s [%s]: " + "%s does not exist. Either declare statements or scripts via @Sql or make the " + "default SQL script available.", elementType, elementName, classPathResource).         logger.error(msg).         throw new IllegalStateException(msg).     } }
