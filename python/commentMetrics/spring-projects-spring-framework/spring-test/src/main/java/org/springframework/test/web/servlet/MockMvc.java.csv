commented;modifiers;parameterAmount;loc;comment;code
true;;1;3;/**  * A default request builder merged into every performed request.  * @see org.springframework.test.web.servlet.setup.DefaultMockMvcBuilder#defaultRequest(RequestBuilder)  */ ;/**  * A default request builder merged into every performed request.  * @see org.springframework.test.web.servlet.setup.DefaultMockMvcBuilder#defaultRequest(RequestBuilder)  */ void setDefaultRequest(@Nullable RequestBuilder requestBuilder) {     this.defaultRequestBuilder = requestBuilder. }
true;;1;4;/**  * Expectations to assert after every performed request.  * @see org.springframework.test.web.servlet.setup.DefaultMockMvcBuilder#alwaysExpect(ResultMatcher)  */ ;/**  * Expectations to assert after every performed request.  * @see org.springframework.test.web.servlet.setup.DefaultMockMvcBuilder#alwaysExpect(ResultMatcher)  */ void setGlobalResultMatchers(List<ResultMatcher> resultMatchers) {     Assert.notNull(resultMatchers, "ResultMatcher List is required").     this.defaultResultMatchers = resultMatchers. }
true;;1;4;/**  * General actions to apply after every performed request.  * @see org.springframework.test.web.servlet.setup.DefaultMockMvcBuilder#alwaysDo(ResultHandler)  */ ;/**  * General actions to apply after every performed request.  * @see org.springframework.test.web.servlet.setup.DefaultMockMvcBuilder#alwaysDo(ResultHandler)  */ void setGlobalResultHandlers(List<ResultHandler> resultHandlers) {     Assert.notNull(resultHandlers, "ResultHandler List is required").     this.defaultResultHandlers = resultHandlers. }
true;public;0;3;/**  * Return the underlying {@link DispatcherServlet} instance that this  * {@code MockMvc} was initialized with.  * <p>This is intended for use in custom request processing scenario where a  * request handling component happens to delegate to the {@code DispatcherServlet}  * at runtime and therefore needs to be injected with it.  * <p>For most processing scenarios, simply use {@link MockMvc#perform},  * or if you need to configure the {@code DispatcherServlet}, provide a  * {@link DispatcherServletCustomizer} to the {@code MockMvcBuilder}.  * @since 5.1  */ ;/**  * Return the underlying {@link DispatcherServlet} instance that this  * {@code MockMvc} was initialized with.  * <p>This is intended for use in custom request processing scenario where a  * request handling component happens to delegate to the {@code DispatcherServlet}  * at runtime and therefore needs to be injected with it.  * <p>For most processing scenarios, simply use {@link MockMvc#perform},  * or if you need to configure the {@code DispatcherServlet}, provide a  * {@link DispatcherServletCustomizer} to the {@code MockMvcBuilder}.  * @since 5.1  */ public DispatcherServlet getDispatcherServlet() {     return this.servlet. }
false;public;1;5;;@Override public ResultActions andExpect(ResultMatcher matcher) throws Exception {     matcher.match(mvcResult).     return this. }
false;public;1;5;;@Override public ResultActions andDo(ResultHandler handler) throws Exception {     handler.handle(mvcResult).     return this. }
false;public;0;4;;@Override public MvcResult andReturn() {     return mvcResult. }
true;public;1;57;/**  * Perform a request and return a type that allows chaining further  * actions, such as asserting expectations, on the result.  * @param requestBuilder used to prepare the request to execute.  * see static factory methods in  * {@link org.springframework.test.web.servlet.request.MockMvcRequestBuilders}  * @return an instance of {@link ResultActions} (never {@code null})  * @see org.springframework.test.web.servlet.request.MockMvcRequestBuilders  * @see org.springframework.test.web.servlet.result.MockMvcResultMatchers  */ ;/**  * Perform a request and return a type that allows chaining further  * actions, such as asserting expectations, on the result.  * @param requestBuilder used to prepare the request to execute.  * see static factory methods in  * {@link org.springframework.test.web.servlet.request.MockMvcRequestBuilders}  * @return an instance of {@link ResultActions} (never {@code null})  * @see org.springframework.test.web.servlet.request.MockMvcRequestBuilders  * @see org.springframework.test.web.servlet.result.MockMvcResultMatchers  */ public ResultActions perform(RequestBuilder requestBuilder) throws Exception {     if (this.defaultRequestBuilder != null && requestBuilder instanceof Mergeable) {         requestBuilder = (RequestBuilder) ((Mergeable) requestBuilder).merge(this.defaultRequestBuilder).     }     MockHttpServletRequest request = requestBuilder.buildRequest(this.servletContext).     AsyncContext asyncContext = request.getAsyncContext().     MockHttpServletResponse mockResponse.     HttpServletResponse servletResponse.     if (asyncContext != null) {         servletResponse = (HttpServletResponse) asyncContext.getResponse().         mockResponse = unwrapResponseIfNecessary(servletResponse).     } else {         mockResponse = new MockHttpServletResponse().         servletResponse = mockResponse.     }     if (requestBuilder instanceof SmartRequestBuilder) {         request = ((SmartRequestBuilder) requestBuilder).postProcessRequest(request).     }     final MvcResult mvcResult = new DefaultMvcResult(request, mockResponse).     request.setAttribute(MVC_RESULT_ATTRIBUTE, mvcResult).     RequestAttributes previousAttributes = RequestContextHolder.getRequestAttributes().     RequestContextHolder.setRequestAttributes(new ServletRequestAttributes(request, servletResponse)).     MockFilterChain filterChain = new MockFilterChain(this.servlet, this.filters).     filterChain.doFilter(request, servletResponse).     if (DispatcherType.ASYNC.equals(request.getDispatcherType()) && asyncContext != null && !request.isAsyncStarted()) {         asyncContext.complete().     }     applyDefaultResultActions(mvcResult).     RequestContextHolder.setRequestAttributes(previousAttributes).     return new ResultActions() {          @Override         public ResultActions andExpect(ResultMatcher matcher) throws Exception {             matcher.match(mvcResult).             return this.         }          @Override         public ResultActions andDo(ResultHandler handler) throws Exception {             handler.handle(mvcResult).             return this.         }          @Override         public MvcResult andReturn() {             return mvcResult.         }     }. }
false;private;1;7;;private MockHttpServletResponse unwrapResponseIfNecessary(ServletResponse servletResponse) {     while (servletResponse instanceof HttpServletResponseWrapper) {         servletResponse = ((HttpServletResponseWrapper) servletResponse).getResponse().     }     Assert.isInstanceOf(MockHttpServletResponse.class, servletResponse).     return (MockHttpServletResponse) servletResponse. }
false;private;1;8;;private void applyDefaultResultActions(MvcResult mvcResult) throws Exception {     for (ResultMatcher matcher : this.defaultResultMatchers) {         matcher.match(mvcResult).     }     for (ResultHandler handler : this.defaultResultHandlers) {         handler.handle(mvcResult).     } }
