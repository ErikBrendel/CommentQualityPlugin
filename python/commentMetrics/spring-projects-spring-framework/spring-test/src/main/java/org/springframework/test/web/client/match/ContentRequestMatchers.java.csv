commented;modifiers;parameterAmount;loc;comment;code
true;public;1;3;/**  * Assert the request content type as a String.  */ ;/**  * Assert the request content type as a String.  */ public RequestMatcher contentType(String expectedContentType) {     return contentType(MediaType.parseMediaType(expectedContentType)). }
true;public;1;7;/**  * Assert the request content type as a {@link MediaType}.  */ ;/**  * Assert the request content type as a {@link MediaType}.  */ public RequestMatcher contentType(final MediaType expectedContentType) {     return request -> {         MediaType actualContentType = request.getHeaders().getContentType().         assertTrue("Content type not set", actualContentType != null).         assertEquals("Content type", expectedContentType, actualContentType).     }. }
true;public;1;3;/**  * Assert the request content type is compatible with the given  * content type as defined by {@link MediaType#isCompatibleWith(MediaType)}.  */ ;/**  * Assert the request content type is compatible with the given  * content type as defined by {@link MediaType#isCompatibleWith(MediaType)}.  */ public RequestMatcher contentTypeCompatibleWith(String contentType) {     return contentTypeCompatibleWith(MediaType.parseMediaType(contentType)). }
true;public;1;10;/**  * Assert the request content type is compatible with the given  * content type as defined by {@link MediaType#isCompatibleWith(MediaType)}.  */ ;/**  * Assert the request content type is compatible with the given  * content type as defined by {@link MediaType#isCompatibleWith(MediaType)}.  */ public RequestMatcher contentTypeCompatibleWith(final MediaType contentType) {     return request -> {         MediaType actualContentType = request.getHeaders().getContentType().         assertTrue("Content type not set", actualContentType != null).         if (actualContentType != null) {             assertTrue("Content type [" + actualContentType + "] is not compatible with [" + contentType + "]", actualContentType.isCompatibleWith(contentType)).         }     }. }
true;public;1;6;/**  * Get the body of the request as a UTF-8 string and apply the given {@link Matcher}.  */ ;/**  * Get the body of the request as a UTF-8 string and apply the given {@link Matcher}.  */ public RequestMatcher string(final Matcher<? super String> matcher) {     return request -> {         MockClientHttpRequest mockRequest = (MockClientHttpRequest) request.         assertThat("Request content", mockRequest.getBodyAsString(), matcher).     }. }
true;public;1;6;/**  * Get the body of the request as a UTF-8 string and compare it to the given String.  */ ;/**  * Get the body of the request as a UTF-8 string and compare it to the given String.  */ public RequestMatcher string(final String expectedContent) {     return request -> {         MockClientHttpRequest mockRequest = (MockClientHttpRequest) request.         assertEquals("Request content", expectedContent, mockRequest.getBodyAsString()).     }. }
true;public;1;6;/**  * Compare the body of the request to the given byte array.  */ ;/**  * Compare the body of the request to the given byte array.  */ public RequestMatcher bytes(final byte[] expectedContent) {     return request -> {         MockClientHttpRequest mockRequest = (MockClientHttpRequest) request.         assertEquals("Request content", expectedContent, mockRequest.getBodyAsBytes()).     }. }
false;public;0;5;;@Override public InputStream getBody() throws IOException {     MockClientHttpRequest mockRequest = (MockClientHttpRequest) request.     return new ByteArrayInputStream(mockRequest.getBodyAsBytes()). }
false;public;0;4;;@Override public HttpHeaders getHeaders() {     return request.getHeaders(). }
true;public;1;17;/**  * Parse the body as form data and compare to the given {@code MultiValueMap}.  * @since 4.3  */ ;/**  * Parse the body as form data and compare to the given {@code MultiValueMap}.  * @since 4.3  */ public RequestMatcher formData(final MultiValueMap<String, String> expectedContent) {     return request -> {         HttpInputMessage inputMessage = new HttpInputMessage() {              @Override             public InputStream getBody() throws IOException {                 MockClientHttpRequest mockRequest = (MockClientHttpRequest) request.                 return new ByteArrayInputStream(mockRequest.getBodyAsBytes()).             }              @Override             public HttpHeaders getHeaders() {                 return request.getHeaders().             }         }.         FormHttpMessageConverter converter = new FormHttpMessageConverter().         assertEquals("Request content", expectedContent, converter.read(null, inputMessage)).     }. }
false;protected;1;4;;@Override protected void matchInternal(MockClientHttpRequest request) throws Exception {     xmlHelper.assertXmlEqual(expectedXmlContent, request.getBodyAsString()). }
true;public;1;8;/**  * Parse the request body and the given String as XML and assert that the  * two are "similar" - i.e. they contain the same elements and attributes  * regardless of order.  * <p>Use of this matcher assumes the  * <a href="http://xmlunit.sourceforge.net/">XMLUnit</a> library is available.  * @param expectedXmlContent the expected XML content  */ ;/**  * Parse the request body and the given String as XML and assert that the  * two are "similar" - i.e. they contain the same elements and attributes  * regardless of order.  * <p>Use of this matcher assumes the  * <a href="http://xmlunit.sourceforge.net/">XMLUnit</a> library is available.  * @param expectedXmlContent the expected XML content  */ public RequestMatcher xml(final String expectedXmlContent) {     return new AbstractXmlRequestMatcher() {          @Override         protected void matchInternal(MockClientHttpRequest request) throws Exception {             xmlHelper.assertXmlEqual(expectedXmlContent, request.getBodyAsString()).         }     }. }
false;protected;1;4;;@Override protected void matchInternal(MockClientHttpRequest request) throws Exception {     xmlHelper.assertNode(request.getBodyAsString(), matcher). }
true;public;1;8;/**  * Parse the request content as {@link Node} and apply the given {@link Matcher}.  */ ;/**  * Parse the request content as {@link Node} and apply the given {@link Matcher}.  */ public RequestMatcher node(final Matcher<? super Node> matcher) {     return new AbstractXmlRequestMatcher() {          @Override         protected void matchInternal(MockClientHttpRequest request) throws Exception {             xmlHelper.assertNode(request.getBodyAsString(), matcher).         }     }. }
false;protected;1;4;;@Override protected void matchInternal(MockClientHttpRequest request) throws Exception {     xmlHelper.assertSource(request.getBodyAsString(), matcher). }
true;public;1;8;/**  * Parse the request content as {@link DOMSource} and apply the given {@link Matcher}.  * @see <a href="http://code.google.com/p/xml-matchers/">http://code.google.com/p/xml-matchers/</a>  */ ;/**  * Parse the request content as {@link DOMSource} and apply the given {@link Matcher}.  * @see <a href="http://code.google.com/p/xml-matchers/">http://code.google.com/p/xml-matchers/</a>  */ public RequestMatcher source(final Matcher<? super Source> matcher) {     return new AbstractXmlRequestMatcher() {          @Override         protected void matchInternal(MockClientHttpRequest request) throws Exception {             xmlHelper.assertSource(request.getBodyAsString(), matcher).         }     }. }
true;public;1;3;/**  * Parse the expected and actual strings as JSON and assert the two  * are "similar" - i.e. they contain the same attribute-value pairs  * regardless of formatting with a lenient checking (extensible, and non-strict array  * ordering).  * <p>Use of this matcher requires the <a  * href="http://jsonassert.skyscreamer.org/">JSONassert</a> library.  * @param expectedJsonContent the expected JSON content  * @since 5.0.5  */ ;/**  * Parse the expected and actual strings as JSON and assert the two  * are "similar" - i.e. they contain the same attribute-value pairs  * regardless of formatting with a lenient checking (extensible, and non-strict array  * ordering).  * <p>Use of this matcher requires the <a  * href="http://jsonassert.skyscreamer.org/">JSONassert</a> library.  * @param expectedJsonContent the expected JSON content  * @since 5.0.5  */ public RequestMatcher json(final String expectedJsonContent) {     return json(expectedJsonContent, false). }
true;public;2;11;/**  * Parse the request body and the given string as JSON and assert the two  * are "similar" - i.e. they contain the same attribute-value pairs  * regardless of formatting.  * <p>Can compare in two modes, depending on {@code strict} parameter value:  * <ul>  * <li>{@code true}: strict checking. Not extensible, and strict array ordering.</li>  * <li>{@code false}: lenient checking. Extensible, and non-strict array ordering.</li>  * </ul>  * <p>Use of this matcher requires the <a  * href="http://jsonassert.skyscreamer.org/">JSONassert</a> library.  * @param expectedJsonContent the expected JSON content  * @param strict enables strict checking  * @since 5.0.5  */ ;/**  * Parse the request body and the given string as JSON and assert the two  * are "similar" - i.e. they contain the same attribute-value pairs  * regardless of formatting.  * <p>Can compare in two modes, depending on {@code strict} parameter value:  * <ul>  * <li>{@code true}: strict checking. Not extensible, and strict array ordering.</li>  * <li>{@code false}: lenient checking. Extensible, and non-strict array ordering.</li>  * </ul>  * <p>Use of this matcher requires the <a  * href="http://jsonassert.skyscreamer.org/">JSONassert</a> library.  * @param expectedJsonContent the expected JSON content  * @param strict enables strict checking  * @since 5.0.5  */ public RequestMatcher json(final String expectedJsonContent, final boolean strict) {     return request -> {         try {             MockClientHttpRequest mockRequest = (MockClientHttpRequest) request.             this.jsonHelper.assertJsonEqual(expectedJsonContent, mockRequest.getBodyAsString(), strict).         } catch (Exception ex) {             throw new AssertionError("Failed to parse expected or actual JSON request content", ex).         }     }. }
false;public,final;1;10;;@Override public final void match(ClientHttpRequest request) throws IOException, AssertionError {     try {         MockClientHttpRequest mockRequest = (MockClientHttpRequest) request.         matchInternal(mockRequest).     } catch (Exception ex) {         throw new AssertionError("Failed to parse expected or actual XML request content", ex).     } }
false;protected,abstract;1;1;;protected abstract void matchInternal(MockClientHttpRequest request) throws Exception.
