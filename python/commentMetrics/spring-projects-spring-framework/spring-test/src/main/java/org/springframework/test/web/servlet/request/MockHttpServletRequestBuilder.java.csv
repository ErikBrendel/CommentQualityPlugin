commented;modifiers;parameterAmount;loc;comment;code
true;public;1;8;/**  * Specify the portion of the requestURI that represents the context path.  * The context path, if specified, must match to the start of the request URI.  * <p>In most cases, tests can be written by omitting the context path from  * the requestURI. This is because most applications don't actually depend  * on the name under which they're deployed. If specified here, the context  * path must start with a "/" and must not end with a "/".  * @see javax.servlet.http.HttpServletRequest#getContextPath()  */ ;/**  * Specify the portion of the requestURI that represents the context path.  * The context path, if specified, must match to the start of the request URI.  * <p>In most cases, tests can be written by omitting the context path from  * the requestURI. This is because most applications don't actually depend  * on the name under which they're deployed. If specified here, the context  * path must start with a "/" and must not end with a "/".  * @see javax.servlet.http.HttpServletRequest#getContextPath()  */ public MockHttpServletRequestBuilder contextPath(String contextPath) {     if (StringUtils.hasText(contextPath)) {         Assert.isTrue(contextPath.startsWith("/"), "Context path must start with a '/'").         Assert.isTrue(!contextPath.endsWith("/"), "Context path must not end with a '/'").     }     this.contextPath = contextPath.     return this. }
true;public;1;8;/**  * Specify the portion of the requestURI that represents the path to which  * the Servlet is mapped. This is typically a portion of the requestURI  * after the context path.  * <p>In most cases, tests can be written by omitting the servlet path from  * the requestURI. This is because most applications don't actually depend  * on the prefix to which a servlet is mapped. For example if a Servlet is  * mapped to {@code "/main/*"}, tests can be written with the requestURI  * {@code "/accounts/1"} as opposed to {@code "/main/accounts/1"}.  * If specified here, the servletPath must start with a "/" and must not  * end with a "/".  * @see javax.servlet.http.HttpServletRequest#getServletPath()  */ ;/**  * Specify the portion of the requestURI that represents the path to which  * the Servlet is mapped. This is typically a portion of the requestURI  * after the context path.  * <p>In most cases, tests can be written by omitting the servlet path from  * the requestURI. This is because most applications don't actually depend  * on the prefix to which a servlet is mapped. For example if a Servlet is  * mapped to {@code "/main/*"}, tests can be written with the requestURI  * {@code "/accounts/1"} as opposed to {@code "/main/accounts/1"}.  * If specified here, the servletPath must start with a "/" and must not  * end with a "/".  * @see javax.servlet.http.HttpServletRequest#getServletPath()  */ public MockHttpServletRequestBuilder servletPath(String servletPath) {     if (StringUtils.hasText(servletPath)) {         Assert.isTrue(servletPath.startsWith("/"), "Servlet path must start with a '/'").         Assert.isTrue(!servletPath.endsWith("/"), "Servlet path must not end with a '/'").     }     this.servletPath = servletPath.     return this. }
true;public;1;7;/**  * Specify the portion of the requestURI that represents the pathInfo.  * <p>If left unspecified (recommended), the pathInfo will be automatically derived  * by removing the contextPath and the servletPath from the requestURI and using any  * remaining part. If specified here, the pathInfo must start with a "/".  * <p>If specified, the pathInfo will be used as-is.  * @see javax.servlet.http.HttpServletRequest#getPathInfo()  */ ;/**  * Specify the portion of the requestURI that represents the pathInfo.  * <p>If left unspecified (recommended), the pathInfo will be automatically derived  * by removing the contextPath and the servletPath from the requestURI and using any  * remaining part. If specified here, the pathInfo must start with a "/".  * <p>If specified, the pathInfo will be used as-is.  * @see javax.servlet.http.HttpServletRequest#getPathInfo()  */ public MockHttpServletRequestBuilder pathInfo(@Nullable String pathInfo) {     if (StringUtils.hasText(pathInfo)) {         Assert.isTrue(pathInfo.startsWith("/"), "Path info must start with a '/'").     }     this.pathInfo = pathInfo.     return this. }
true;public;1;4;/**  * Set the secure property of the {@link ServletRequest} indicating use of a  * secure channel, such as HTTPS.  * @param secure whether the request is using a secure channel  */ ;/**  * Set the secure property of the {@link ServletRequest} indicating use of a  * secure channel, such as HTTPS.  * @param secure whether the request is using a secure channel  */ public MockHttpServletRequestBuilder secure(boolean secure) {     this.secure = secure.     return this. }
true;public;1;4;/**  * Set the character encoding of the request.  * @param encoding the character encoding  */ ;/**  * Set the character encoding of the request.  * @param encoding the character encoding  */ public MockHttpServletRequestBuilder characterEncoding(String encoding) {     this.characterEncoding = encoding.     return this. }
true;public;1;4;/**  * Set the request body.  * @param content the body content  */ ;/**  * Set the request body.  * @param content the body content  */ public MockHttpServletRequestBuilder content(byte[] content) {     this.content = content.     return this. }
true;public;1;4;/**  * Set the request body as a UTF-8 String.  * @param content the body content  */ ;/**  * Set the request body as a UTF-8 String.  * @param content the body content  */ public MockHttpServletRequestBuilder content(String content) {     this.content = content.getBytes(StandardCharsets.UTF_8).     return this. }
true;public;1;5;/**  * Set the 'Content-Type' header of the request.  * @param contentType the content type  */ ;/**  * Set the 'Content-Type' header of the request.  * @param contentType the content type  */ public MockHttpServletRequestBuilder contentType(MediaType contentType) {     Assert.notNull(contentType, "'contentType' must not be null").     this.contentType = contentType.toString().     return this. }
true;public;1;4;/**  * Set the 'Content-Type' header of the request.  * @param contentType the content type  * @since 4.1.2  */ ;/**  * Set the 'Content-Type' header of the request.  * @param contentType the content type  * @since 4.1.2  */ public MockHttpServletRequestBuilder contentType(String contentType) {     this.contentType = MediaType.parseMediaType(contentType).toString().     return this. }
true;public;1;5;/**  * Set the 'Accept' header to the given media type(s).  * @param mediaTypes one or more media types  */ ;/**  * Set the 'Accept' header to the given media type(s).  * @param mediaTypes one or more media types  */ public MockHttpServletRequestBuilder accept(MediaType... mediaTypes) {     Assert.notEmpty(mediaTypes, "'mediaTypes' must not be empty").     this.headers.set("Accept", MediaType.toString(Arrays.asList(mediaTypes))).     return this. }
true;public;1;9;/**  * Set the 'Accept' header to the given media type(s).  * @param mediaTypes one or more media types  */ ;/**  * Set the 'Accept' header to the given media type(s).  * @param mediaTypes one or more media types  */ public MockHttpServletRequestBuilder accept(String... mediaTypes) {     Assert.notEmpty(mediaTypes, "'mediaTypes' must not be empty").     List<MediaType> result = new ArrayList<>(mediaTypes.length).     for (String mediaType : mediaTypes) {         result.add(MediaType.parseMediaType(mediaType)).     }     this.headers.set("Accept", MediaType.toString(result)).     return this. }
true;public;2;4;/**  * Add a header to the request. Values are always added.  * @param name the header name  * @param values one or more header values  */ ;/**  * Add a header to the request. Values are always added.  * @param name the header name  * @param values one or more header values  */ public MockHttpServletRequestBuilder header(String name, Object... values) {     addToMultiValueMap(this.headers, name, values).     return this. }
true;public;1;4;/**  * Add all headers to the request. Values are always added.  * @param httpHeaders the headers and values to add  */ ;/**  * Add all headers to the request. Values are always added.  * @param httpHeaders the headers and values to add  */ public MockHttpServletRequestBuilder headers(HttpHeaders httpHeaders) {     httpHeaders.forEach(this.headers::addAll).     return this. }
true;public;2;4;/**  * Add a request parameter to the {@link MockHttpServletRequest}.  * <p>If called more than once, new values get added to existing ones.  * @param name the parameter name  * @param values one or more values  */ ;/**  * Add a request parameter to the {@link MockHttpServletRequest}.  * <p>If called more than once, new values get added to existing ones.  * @param name the parameter name  * @param values one or more values  */ public MockHttpServletRequestBuilder param(String name, String... values) {     addToMultiValueMap(this.parameters, name, values).     return this. }
true;public;1;8;/**  * Add a map of request parameters to the {@link MockHttpServletRequest},  * for example when testing a form submission.  * <p>If called more than once, new values get added to existing ones.  * @param params the parameters to add  * @since 4.2.4  */ ;/**  * Add a map of request parameters to the {@link MockHttpServletRequest},  * for example when testing a form submission.  * <p>If called more than once, new values get added to existing ones.  * @param params the parameters to add  * @since 4.2.4  */ public MockHttpServletRequestBuilder params(MultiValueMap<String, String> params) {     params.forEach((name, values) -> {         for (String value : values) {             this.parameters.add(name, value).         }     }).     return this. }
true;public;1;5;/**  * Add the given cookies to the request. Cookies are always added.  * @param cookies the cookies to add  */ ;/**  * Add the given cookies to the request. Cookies are always added.  * @param cookies the cookies to add  */ public MockHttpServletRequestBuilder cookie(Cookie... cookies) {     Assert.notEmpty(cookies, "'cookies' must not be empty").     this.cookies.addAll(Arrays.asList(cookies)).     return this. }
true;public;1;5;/**  * Add the specified locales as preferred request locales.  * @param locales the locales to add  * @since 4.3.6  * @see #locale(Locale)  */ ;/**  * Add the specified locales as preferred request locales.  * @param locales the locales to add  * @since 4.3.6  * @see #locale(Locale)  */ public MockHttpServletRequestBuilder locale(Locale... locales) {     Assert.notEmpty(locales, "'locales' must not be empty").     this.locales.addAll(Arrays.asList(locales)).     return this. }
true;public;1;7;/**  * Set the locale of the request, overriding any previous locales.  * @param locale the locale, or {@code null} to reset it  * @see #locale(Locale...)  */ ;/**  * Set the locale of the request, overriding any previous locales.  * @param locale the locale, or {@code null} to reset it  * @see #locale(Locale...)  */ public MockHttpServletRequestBuilder locale(@Nullable Locale locale) {     this.locales.clear().     if (locale != null) {         this.locales.add(locale).     }     return this. }
true;public;2;4;/**  * Set a request attribute.  * @param name the attribute name  * @param value the attribute value  */ ;/**  * Set a request attribute.  * @param name the attribute name  * @param value the attribute value  */ public MockHttpServletRequestBuilder requestAttr(String name, Object value) {     addToMap(this.requestAttributes, name, value).     return this. }
true;public;2;4;/**  * Set a session attribute.  * @param name the session attribute name  * @param value the session attribute value  */ ;/**  * Set a session attribute.  * @param name the session attribute name  * @param value the session attribute value  */ public MockHttpServletRequestBuilder sessionAttr(String name, Object value) {     addToMap(this.sessionAttributes, name, value).     return this. }
true;public;1;5;/**  * Set session attributes.  * @param sessionAttributes the session attributes  */ ;/**  * Set session attributes.  * @param sessionAttributes the session attributes  */ public MockHttpServletRequestBuilder sessionAttrs(Map<String, Object> sessionAttributes) {     Assert.notEmpty(sessionAttributes, "'sessionAttributes' must not be empty").     sessionAttributes.forEach(this::sessionAttr).     return this. }
true;public;2;4;/**  * Set an "input" flash attribute.  * @param name the flash attribute name  * @param value the flash attribute value  */ ;/**  * Set an "input" flash attribute.  * @param name the flash attribute name  * @param value the flash attribute value  */ public MockHttpServletRequestBuilder flashAttr(String name, Object value) {     addToMap(this.flashAttributes, name, value).     return this. }
true;public;1;5;/**  * Set flash attributes.  * @param flashAttributes the flash attributes  */ ;/**  * Set flash attributes.  * @param flashAttributes the flash attributes  */ public MockHttpServletRequestBuilder flashAttrs(Map<String, Object> flashAttributes) {     Assert.notEmpty(flashAttributes, "'flashAttributes' must not be empty").     flashAttributes.forEach(this::flashAttr).     return this. }
true;public;1;5;/**  * Set the HTTP session to use, possibly re-used across requests.  * <p>Individual attributes provided via {@link #sessionAttr(String, Object)}  * override the content of the session provided here.  * @param session the HTTP session  */ ;/**  * Set the HTTP session to use, possibly re-used across requests.  * <p>Individual attributes provided via {@link #sessionAttr(String, Object)}  * override the content of the session provided here.  * @param session the HTTP session  */ public MockHttpServletRequestBuilder session(MockHttpSession session) {     Assert.notNull(session, "'session' must not be null").     this.session = session.     return this. }
true;public;1;5;/**  * Set the principal of the request.  * @param principal the principal  */ ;/**  * Set the principal of the request.  * @param principal the principal  */ public MockHttpServletRequestBuilder principal(Principal principal) {     Assert.notNull(principal, "'principal' must not be null").     this.principal = principal.     return this. }
true;public;1;6;/**  * An extension point for further initialization of {@link MockHttpServletRequest}  * in ways not built directly into the {@code MockHttpServletRequestBuilder}.  * Implementation of this interface can have builder-style methods themselves  * and be made accessible through static factory methods.  * @param postProcessor a post-processor to add  */ ;/**  * An extension point for further initialization of {@link MockHttpServletRequest}  * in ways not built directly into the {@code MockHttpServletRequestBuilder}.  * Implementation of this interface can have builder-style methods themselves  * and be made accessible through static factory methods.  * @param postProcessor a post-processor to add  */ @Override public MockHttpServletRequestBuilder with(RequestPostProcessor postProcessor) {     Assert.notNull(postProcessor, "postProcessor is required").     this.postProcessors.add(postProcessor).     return this. }
true;public;0;4;/**  * {@inheritDoc}  * @return always returns {@code true}.  */ ;/**  * {@inheritDoc}  * @return always returns {@code true}.  */ @Override public boolean isMergeEnabled() {     return true. }
true;public;1;81;/**  * Merges the properties of the "parent" RequestBuilder accepting values  * only if not already set in "this" instance.  * @param parent the parent {@code RequestBuilder} to inherit properties from  * @return the result of the merge  */ ;/**  * Merges the properties of the "parent" RequestBuilder accepting values  * only if not already set in "this" instance.  * @param parent the parent {@code RequestBuilder} to inherit properties from  * @return the result of the merge  */ @Override public Object merge(@Nullable Object parent) {     if (parent == null) {         return this.     }     if (!(parent instanceof MockHttpServletRequestBuilder)) {         throw new IllegalArgumentException("Cannot merge with [" + parent.getClass().getName() + "]").     }     MockHttpServletRequestBuilder parentBuilder = (MockHttpServletRequestBuilder) parent.     if (!StringUtils.hasText(this.contextPath)) {         this.contextPath = parentBuilder.contextPath.     }     if (!StringUtils.hasText(this.servletPath)) {         this.servletPath = parentBuilder.servletPath.     }     if ("".equals(this.pathInfo)) {         this.pathInfo = parentBuilder.pathInfo.     }     if (this.secure == null) {         this.secure = parentBuilder.secure.     }     if (this.principal == null) {         this.principal = parentBuilder.principal.     }     if (this.session == null) {         this.session = parentBuilder.session.     }     if (this.characterEncoding == null) {         this.characterEncoding = parentBuilder.characterEncoding.     }     if (this.content == null) {         this.content = parentBuilder.content.     }     if (this.contentType == null) {         this.contentType = parentBuilder.contentType.     }     for (String headerName : parentBuilder.headers.keySet()) {         if (!this.headers.containsKey(headerName)) {             this.headers.put(headerName, parentBuilder.headers.get(headerName)).         }     }     for (String paramName : parentBuilder.parameters.keySet()) {         if (!this.parameters.containsKey(paramName)) {             this.parameters.put(paramName, parentBuilder.parameters.get(paramName)).         }     }     for (Cookie cookie : parentBuilder.cookies) {         if (!containsCookie(cookie)) {             this.cookies.add(cookie).         }     }     for (Locale locale : parentBuilder.locales) {         if (!this.locales.contains(locale)) {             this.locales.add(locale).         }     }     for (String attributeName : parentBuilder.requestAttributes.keySet()) {         if (!this.requestAttributes.containsKey(attributeName)) {             this.requestAttributes.put(attributeName, parentBuilder.requestAttributes.get(attributeName)).         }     }     for (String attributeName : parentBuilder.sessionAttributes.keySet()) {         if (!this.sessionAttributes.containsKey(attributeName)) {             this.sessionAttributes.put(attributeName, parentBuilder.sessionAttributes.get(attributeName)).         }     }     for (String attributeName : parentBuilder.flashAttributes.keySet()) {         if (!this.flashAttributes.containsKey(attributeName)) {             this.flashAttributes.put(attributeName, parentBuilder.flashAttributes.get(attributeName)).         }     }     this.postProcessors.addAll(0, parentBuilder.postProcessors).     return this. }
false;private;1;8;;private boolean containsCookie(Cookie cookie) {     for (Cookie cookieToCheck : this.cookies) {         if (ObjectUtils.nullSafeEquals(cookieToCheck.getName(), cookie.getName())) {             return true.         }     }     return false. }
true;public,final;1;84;/**  * Build a {@link MockHttpServletRequest}.  */ ;/**  * Build a {@link MockHttpServletRequest}.  */ @Override public final MockHttpServletRequest buildRequest(ServletContext servletContext) {     MockHttpServletRequest request = createServletRequest(servletContext).     request.setAsyncSupported(true).     request.setMethod(this.method).     String requestUri = this.url.getRawPath().     request.setRequestURI(requestUri).     if (this.url.getScheme() != null) {         request.setScheme(this.url.getScheme()).     }     if (this.url.getHost() != null) {         request.setServerName(this.url.getHost()).     }     if (this.url.getPort() != -1) {         request.setServerPort(this.url.getPort()).     }     updatePathRequestProperties(request, requestUri).     if (this.secure != null) {         request.setSecure(this.secure).     }     if (this.principal != null) {         request.setUserPrincipal(this.principal).     }     if (this.session != null) {         request.setSession(this.session).     }     request.setCharacterEncoding(this.characterEncoding).     request.setContent(this.content).     request.setContentType(this.contentType).     this.headers.forEach((name, values) -> {         for (Object value : values) {             request.addHeader(name, value).         }     }).     if (this.url.getRawQuery() != null) {         request.setQueryString(this.url.getRawQuery()).     }     addRequestParams(request, UriComponentsBuilder.fromUri(this.url).build().getQueryParams()).     this.parameters.forEach((name, values) -> {         for (String value : values) {             request.addParameter(name, value).         }     }).     if (this.content != null && this.content.length > 0) {         String requestContentType = request.getContentType().         if (requestContentType != null) {             MediaType mediaType = MediaType.parseMediaType(requestContentType).             if (MediaType.APPLICATION_FORM_URLENCODED.includes(mediaType)) {                 addRequestParams(request, parseFormData(mediaType)).             }         }     }     if (!ObjectUtils.isEmpty(this.cookies)) {         request.setCookies(this.cookies.toArray(new Cookie[0])).     }     if (!ObjectUtils.isEmpty(this.locales)) {         request.setPreferredLocales(this.locales).     }     this.requestAttributes.forEach(request::setAttribute).     this.sessionAttributes.forEach((name, attribute) -> {         HttpSession session = request.getSession().         Assert.state(session != null, "No HttpSession").         session.setAttribute(name, attribute).     }).     FlashMap flashMap = new FlashMap().     flashMap.putAll(this.flashAttributes).     FlashMapManager flashMapManager = getFlashMapManager(request).     flashMapManager.saveOutputFlashMap(flashMap, request, new MockHttpServletResponse()).     return request. }
true;protected;1;3;/**  * Create a new {@link MockHttpServletRequest} based on the supplied  * {@code ServletContext}.  * <p>Can be overridden in subclasses.  */ ;/**  * Create a new {@link MockHttpServletRequest} based on the supplied  * {@code ServletContext}.  * <p>Can be overridden in subclasses.  */ protected MockHttpServletRequest createServletRequest(ServletContext servletContext) {     return new MockHttpServletRequest(servletContext). }
true;private;2;19;/**  * Update the contextPath, servletPath, and pathInfo of the request.  */ ;/**  * Update the contextPath, servletPath, and pathInfo of the request.  */ private void updatePathRequestProperties(MockHttpServletRequest request, String requestUri) {     if (!requestUri.startsWith(this.contextPath)) {         throw new IllegalArgumentException("Request URI [" + requestUri + "] does not start with context path [" + this.contextPath + "]").     }     request.setContextPath(this.contextPath).     request.setServletPath(this.servletPath).     if ("".equals(this.pathInfo)) {         if (!requestUri.startsWith(this.contextPath + this.servletPath)) {             throw new IllegalArgumentException("Invalid servlet path [" + this.servletPath + "] for request URI [" + requestUri + "]").         }         String extraPath = requestUri.substring(this.contextPath.length() + this.servletPath.length()).         this.pathInfo = (StringUtils.hasText(extraPath) ? urlPathHelper.decodeRequestString(request, extraPath) : null).     }     request.setPathInfo(this.pathInfo). }
false;private;2;6;;private void addRequestParams(MockHttpServletRequest request, MultiValueMap<String, String> map) {     map.forEach((key, values) -> values.forEach(value -> {         value = (value != null ? UriUtils.decode(value, StandardCharsets.UTF_8) : null).         request.addParameter(UriUtils.decode(key, StandardCharsets.UTF_8), value).     })). }
false;public;0;4;;@Override public InputStream getBody() {     return (content != null ? new ByteArrayInputStream(content) : StreamUtils.emptyInput()). }
false;public;0;6;;@Override public HttpHeaders getHeaders() {     HttpHeaders headers = new HttpHeaders().     headers.setContentType(mediaType).     return headers. }
false;private;1;21;;private MultiValueMap<String, String> parseFormData(final MediaType mediaType) {     HttpInputMessage message = new HttpInputMessage() {          @Override         public InputStream getBody() {             return (content != null ? new ByteArrayInputStream(content) : StreamUtils.emptyInput()).         }          @Override         public HttpHeaders getHeaders() {             HttpHeaders headers = new HttpHeaders().             headers.setContentType(mediaType).             return headers.         }     }.     try {         return new FormHttpMessageConverter().read(null, message).     } catch (IOException ex) {         throw new IllegalStateException("Failed to parse form data in request body", ex).     } }
false;private;1;12;;private FlashMapManager getFlashMapManager(MockHttpServletRequest request) {     FlashMapManager flashMapManager = null.     try {         ServletContext servletContext = request.getServletContext().         WebApplicationContext wac = WebApplicationContextUtils.getRequiredWebApplicationContext(servletContext).         flashMapManager = wac.getBean(DispatcherServlet.FLASH_MAP_MANAGER_BEAN_NAME, FlashMapManager.class).     } catch (IllegalStateException | NoSuchBeanDefinitionException ex) {     // ignore     }     return (flashMapManager != null ? flashMapManager : new SessionFlashMapManager()). }
false;public;1;7;;@Override public MockHttpServletRequest postProcessRequest(MockHttpServletRequest request) {     for (RequestPostProcessor postProcessor : this.postProcessors) {         request = postProcessor.postProcessRequest(request).     }     return request. }
false;private,static;3;5;;private static void addToMap(Map<String, Object> map, String name, Object value) {     Assert.hasLength(name, "'name' must not be empty").     Assert.notNull(value, "'value' must not be null").     map.put(name, value). }
false;private,static;3;7;;private static <T> void addToMultiValueMap(MultiValueMap<String, T> map, String name, T[] values) {     Assert.hasLength(name, "'name' must not be empty").     Assert.notEmpty(values, "'values' must not be empty").     for (T value : values) {         map.add(name, value).     } }
