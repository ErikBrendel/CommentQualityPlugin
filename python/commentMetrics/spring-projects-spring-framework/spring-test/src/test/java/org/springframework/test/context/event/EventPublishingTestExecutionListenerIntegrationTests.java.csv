commented;modifiers;parameterAmount;loc;comment;code
false;public;0;6;;@Before public void resetMock() {     // The mocked listener is a bean in the ApplicationContext that is stored     // in a static cache by the Spring TestContext Framework.     reset(listener). }
false;public;0;5;;@Test public void beforeTestClassAnnotation() throws Exception {     testContextManager.beforeTestClass().     verify(listener, only()).beforeTestClass(testContext). }
false;public;0;5;;@Test public void prepareTestInstanceAnnotation() throws Exception {     testContextManager.prepareTestInstance(testInstance).     verify(listener, only()).prepareTestInstance(testContext). }
false;public;0;5;;@Test public void beforeTestMethodAnnotation() throws Exception {     testContextManager.beforeTestMethod(testInstance, testMethod).     verify(listener, only()).beforeTestMethod(testContext). }
false;public;0;6;;@Test public void beforeTestMethodAnnotationWithFailingCondition() throws Exception {     Method standardTest = ReflectionUtils.findMethod(ExampleTestCase.class, "standardTest").     testContextManager.beforeTestMethod(testInstance, standardTest).     verify(listener, never()).beforeTestMethod(testContext). }
false;public;0;14;;@Test public void beforeTestMethodAnnotationWithFailingEventListener() throws Exception {     Method method = ReflectionUtils.findMethod(ExampleTestCase.class, "testWithFailingEventListener").     exception.expect(RuntimeException.class).     exception.expectMessage("Boom!").     try {         testContextManager.beforeTestMethod(testInstance, method).     } finally {         verify(listener, only()).beforeTestMethod(testContext).     } }
false;public;0;15;;@Test public void beforeTestMethodAnnotationWithFailingAsyncEventListener() throws Exception {     TrackingAsyncUncaughtExceptionHandler.asyncException = null.     String methodName = "testWithFailingAsyncEventListener".     Method method = ReflectionUtils.findMethod(ExampleTestCase.class, methodName).     testContextManager.beforeTestMethod(testInstance, method).     assertThat(countDownLatch.await(2, TimeUnit.SECONDS), equalTo(true)).     verify(listener, only()).beforeTestMethod(testContext).     assertThat(TrackingAsyncUncaughtExceptionHandler.asyncException.getMessage(), startsWith("Asynchronous exception for test method [" + methodName + "] in thread [" + THREAD_NAME_PREFIX)). }
false;public;0;5;;@Test public void beforeTestExecutionAnnotation() throws Exception {     testContextManager.beforeTestExecution(testInstance, testMethod).     verify(listener, only()).beforeTestExecution(testContext). }
false;public;0;5;;@Test public void afterTestExecutionAnnotation() throws Exception {     testContextManager.afterTestExecution(testInstance, testMethod, null).     verify(listener, only()).afterTestExecution(testContext). }
false;public;0;5;;@Test public void afterTestMethodAnnotation() throws Exception {     testContextManager.afterTestMethod(testInstance, testMethod, null).     verify(listener, only()).afterTestMethod(testContext). }
false;public;0;5;;@Test public void afterTestClassAnnotation() throws Exception {     testContextManager.afterTestClass().     verify(listener, only()).afterTestClass(testContext). }
false;public;0;5;;@Traceable @Test public void traceableTest() { /* no-op */ }
false;public;0;4;;@Test public void standardTest() { /* no-op */ }
false;public;0;4;;@Test public void testWithFailingEventListener() { /* no-op */ }
false;public;0;4;;@Test public void testWithFailingAsyncEventListener() { /* no-op */ }
false;public;0;7;;@Override public Executor getAsyncExecutor() {     ThreadPoolTaskExecutor executor = new ThreadPoolTaskExecutor().     executor.setThreadNamePrefix(THREAD_NAME_PREFIX).     executor.initialize().     return executor. }
false;public;0;4;;@Override public AsyncUncaughtExceptionHandler getAsyncUncaughtExceptionHandler() {     return new TrackingAsyncUncaughtExceptionHandler(). }
false;public;0;4;;@Bean public TestExecutionListener listener() {     return mock(TestExecutionListener.class). }
false;;0;4;;@Bean EventCaptureBean eventCaptureBean() {     return new EventCaptureBean(listener()). }
false;public;3;5;;@Override public void handleUncaughtException(Throwable exception, Method method, Object... params) {     asyncException = exception.     countDownLatch.countDown(). }
false;public;1;4;;@BeforeTestClass("#root.event.source.testClass.name matches '.+TestCase'") public void beforeTestClass(BeforeTestClassEvent e) throws Exception {     this.listener.beforeTestClass(e.getSource()). }
false;public;1;4;;@PrepareTestInstance("#a0.testContext.testClass.name matches '.+TestCase'") public void prepareTestInstance(PrepareTestInstanceEvent e) throws Exception {     this.listener.prepareTestInstance(e.getSource()). }
false;public;1;4;;@BeforeTestMethod("#p0.testContext.testMethod.isAnnotationPresent(T(org.springframework.test.context.event.EventPublishingTestExecutionListenerIntegrationTests.Traceable))") public void beforeTestMethod(BeforeTestMethodEvent e) throws Exception {     this.listener.beforeTestMethod(e.getSource()). }
false;public;1;5;;@BeforeTestMethod("event.testContext.testMethod.name == 'testWithFailingEventListener'") public void beforeTestMethodWithFailure(BeforeTestMethodEvent event) throws Exception {     this.listener.beforeTestMethod(event.getSource()).     throw new RuntimeException("Boom!"). }
false;public;1;7;;@BeforeTestMethod("event.testContext.testMethod.name == 'testWithFailingAsyncEventListener'") @Async public void beforeTestMethodWithAsyncFailure(BeforeTestMethodEvent event) throws Exception {     this.listener.beforeTestMethod(event.getSource()).     throw new RuntimeException(String.format("Asynchronous exception for test method [%s] in thread [%s]", event.getTestContext().getTestMethod().getName(), Thread.currentThread().getName())). }
false;public;1;4;;@BeforeTestExecution public void beforeTestExecution(BeforeTestExecutionEvent e) throws Exception {     this.listener.beforeTestExecution(e.getSource()). }
false;public;1;4;;@AfterTestExecution public void afterTestExecution(AfterTestExecutionEvent e) throws Exception {     this.listener.afterTestExecution(e.getSource()). }
false;public;1;4;;@AfterTestMethod("event.testContext.testMethod.isAnnotationPresent(T(org.springframework.test.context.event.EventPublishingTestExecutionListenerIntegrationTests.Traceable))") public void afterTestMethod(AfterTestMethodEvent e) throws Exception {     this.listener.afterTestMethod(e.getSource()). }
false;public;1;4;;@AfterTestClass("#afterTestClassEvent.testContext.testClass.name matches '.+TestCase'") public void afterTestClass(AfterTestClassEvent afterTestClassEvent) throws Exception {     this.listener.afterTestClass(afterTestClassEvent.getSource()). }
