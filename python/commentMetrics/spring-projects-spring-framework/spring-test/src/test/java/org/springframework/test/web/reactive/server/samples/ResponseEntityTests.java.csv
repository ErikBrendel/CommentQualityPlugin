commented;modifiers;parameterAmount;loc;comment;code
false;public;0;8;;@Test public void entity() {     this.client.get().uri("/John").exchange().expectStatus().isOk().expectHeader().contentType(MediaType.APPLICATION_JSON_UTF8).expectBody(Person.class).isEqualTo(new Person("John")). }
false;public;0;8;;@Test public void entityMatcher() {     this.client.get().uri("/John").exchange().expectStatus().isOk().expectHeader().contentType(MediaType.APPLICATION_JSON_UTF8).expectBody(Person.class).value(Person::getName, startsWith("Joh")). }
false;public;0;9;;@Test public void entityWithConsumer() {     this.client.get().uri("/John").exchange().expectStatus().isOk().expectHeader().contentType(MediaType.APPLICATION_JSON_UTF8).expectBody(Person.class).consumeWith(result -> assertEquals(new Person("John"), result.getResponseBody())). }
false;public;0;12;;@Test public void entityList() {     List<Person> expected = Arrays.asList(new Person("Jane"), new Person("Jason"), new Person("John")).     this.client.get().exchange().expectStatus().isOk().expectHeader().contentType(MediaType.APPLICATION_JSON_UTF8).expectBodyList(Person.class).isEqualTo(expected). }
false;public;0;11;;@Test public void entityListWithConsumer() {     this.client.get().exchange().expectStatus().isOk().expectHeader().contentType(MediaType.APPLICATION_JSON_UTF8).expectBodyList(Person.class).value(people -> {         MatcherAssert.assertThat(people, hasItem(new Person("Jason"))).     }). }
false;public;0;13;;@Test public void entityMap() {     Map<String, Person> map = new LinkedHashMap<>().     map.put("Jane", new Person("Jane")).     map.put("Jason", new Person("Jason")).     map.put("John", new Person("John")).     this.client.get().uri("?map=true").exchange().expectStatus().isOk().expectBody(new ParameterizedTypeReference<Map<String, Person>>() {     }).isEqualTo(map). }
false;public;0;17;;@Test public void entityStream() {     FluxExchangeResult<Person> result = this.client.get().accept(TEXT_EVENT_STREAM).exchange().expectStatus().isOk().expectHeader().contentTypeCompatibleWith(TEXT_EVENT_STREAM).returnResult(Person.class).     StepVerifier.create(result.getResponseBody()).expectNext(new Person("N0"), new Person("N1"), new Person("N2")).expectNextCount(4).consumeNextWith(person -> assertThat(person.getName(), endsWith("7"))).thenCancel().verify(). }
false;public;0;9;;@Test public void postEntity() {     this.client.post().syncBody(new Person("John")).exchange().expectStatus().isCreated().expectHeader().valueEquals("location", "/persons/John").expectBody().isEmpty(). }
false;;1;4;;@GetMapping("/{name}") Person getPerson(@PathVariable String name) {     return new Person(name). }
false;;0;4;;@GetMapping Flux<Person> getPersons() {     return Flux.just(new Person("Jane"), new Person("Jason"), new Person("John")). }
false;;0;8;;@GetMapping(params = "map") Map<String, Person> getPersonsAsMap() {     Map<String, Person> map = new LinkedHashMap<>().     map.put("Jane", new Person("Jane")).     map.put("Jason", new Person("Jason")).     map.put("John", new Person("John")).     return map. }
false;;0;5;;@GetMapping(produces = "text/event-stream") Flux<Person> getPersonStream() {     return Flux.interval(ofMillis(100)).take(50).onBackpressureBuffer(50).map(index -> new Person("N" + index)). }
false;;1;4;;@PostMapping ResponseEntity<String> savePerson(@RequestBody Person person) {     return ResponseEntity.created(URI.create("/persons/" + person.getName())).build(). }
