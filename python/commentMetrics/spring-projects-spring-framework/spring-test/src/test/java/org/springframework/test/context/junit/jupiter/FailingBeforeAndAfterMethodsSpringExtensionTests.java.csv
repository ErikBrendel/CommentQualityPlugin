commented;modifiers;parameterAmount;loc;comment;code
false;private,static;0;14;;private static Stream<Class<?>> testClasses() {     // @formatter:off     return Stream.of(AlwaysFailingBeforeTestClassTestCase.class, AlwaysFailingAfterTestClassTestCase.class, AlwaysFailingPrepareTestInstanceTestCase.class, AlwaysFailingBeforeTestMethodTestCase.class, AlwaysFailingBeforeTestExecutionTestCase.class, AlwaysFailingAfterTestExecutionTestCase.class, AlwaysFailingAfterTestMethodTestCase.class, FailingBeforeTransactionTestCase.class, FailingAfterTransactionTestCase.class). // @formatter:on }
false;;0;4;;@TestFactory Stream<DynamicTest> generateTests() throws Exception {     return testClasses().map(clazz -> dynamicTest(clazz.getSimpleName(), () -> runTestAndAssertCounters(clazz))). }
false;private;1;36;;private void runTestAndAssertCounters(Class<?> testClass) {     Launcher launcher = LauncherFactory.create().     ExceptionTrackingListener listener = new ExceptionTrackingListener().     launcher.registerTestExecutionListeners(listener).     launcher.execute(request().selectors(selectClass(testClass)).build()).     TestExecutionSummary summary = listener.getSummary().     String name = testClass.getSimpleName().     int expectedStartedCount = getExpectedStartedCount(testClass).     int expectedSucceededCount = getExpectedSucceededCount(testClass).     int expectedFailedCount = getExpectedFailedCount(testClass).     // @formatter:off     assertAll(() -> assertEquals(1, summary.getTestsFoundCount(), () -> name + ": tests found"), () -> assertEquals(0, summary.getTestsSkippedCount(), () -> name + ": tests skipped"), () -> assertEquals(0, summary.getTestsAbortedCount(), () -> name + ": tests aborted"), () -> assertEquals(expectedStartedCount, summary.getTestsStartedCount(), () -> name + ": tests started"), () -> assertEquals(expectedSucceededCount, summary.getTestsSucceededCount(), () -> name + ": tests succeeded"), () -> assertEquals(expectedFailedCount, summary.getTestsFailedCount(), () -> name + ": tests failed")).     // something else like an error in the @Configuration class, etc.     if (expectedFailedCount > 0) {         assertEquals(1, listener.exceptions.size(), "exceptions expected").         Throwable exception = listener.exceptions.get(0).         if (!(exception instanceof AssertionFailedError)) {             throw new AssertionFailedError(exception.getClass().getName() + " is not an instance of " + AssertionFailedError.class.getName(), exception).         }     } }
false;private;1;3;;private int getExpectedStartedCount(Class<?> testClass) {     return (testClass == AlwaysFailingBeforeTestClassTestCase.class ? 0 : 1). }
false;private;1;3;;private int getExpectedSucceededCount(Class<?> testClass) {     return (testClass == AlwaysFailingAfterTestClassTestCase.class ? 1 : 0). }
false;private;1;7;;private int getExpectedFailedCount(Class<?> testClass) {     if (testClass == AlwaysFailingBeforeTestClassTestCase.class || testClass == AlwaysFailingAfterTestClassTestCase.class) {         return 0.     }     return 1. }
false;public;1;4;;@Override public void beforeTestClass(TestContext testContext) {     fail("always failing beforeTestClass()"). }
false;public;1;4;;@Override public void afterTestClass(TestContext testContext) {     fail("always failing afterTestClass()"). }
false;public;1;4;;@Override public void prepareTestInstance(TestContext testContext) throws Exception {     fail("always failing prepareTestInstance()"). }
false;public;1;4;;@Override public void beforeTestMethod(TestContext testContext) {     fail("always failing beforeTestMethod()"). }
false;public;1;4;;@Override public void beforeTestExecution(TestContext testContext) {     fail("always failing beforeTestExecution()"). }
false;public;1;4;;@Override public void afterTestMethod(TestContext testContext) {     fail("always failing afterTestMethod()"). }
false;public;1;4;;@Override public void afterTestExecution(TestContext testContext) {     fail("always failing afterTestExecution()"). }
false;;0;3;;@Test void testNothing() { }
false;;0;3;;@Test void testNothing() { }
false;;0;4;;@BeforeTransaction void beforeTransaction() {     fail("always failing beforeTransaction()"). }
false;;0;3;;@Test void testNothing() { }
false;;0;4;;@AfterTransaction void afterTransaction() {     fail("always failing afterTransaction()"). }
false;;0;4;;@Bean PlatformTransactionManager transactionManager() {     return new DataSourceTransactionManager(dataSource()). }
false;;0;4;;@Bean DataSource dataSource() {     return new EmbeddedDatabaseBuilder().generateUniqueName(true).build(). }
false;public;2;5;;@Override public void executionFinished(TestIdentifier testIdentifier, TestExecutionResult testExecutionResult) {     super.executionFinished(testIdentifier, testExecutionResult).     testExecutionResult.getThrowable().ifPresent(exceptions::add). }
