commented;modifiers;parameterAmount;loc;comment;code
false;public;0;8;;@Bean public Employee employee() {     Employee employee = new Employee().     employee.setName("John Smith").     employee.setAge(42).     employee.setCompany("Acme Widgets, Inc.").     return employee. }
false;public;0;4;;@Bean public PlatformTransactionManager transactionManager() {     return new DataSourceTransactionManager(dataSource()). }
true;public;0;8;/**  *  Since this method does not reside in a true {@code @Configuration class},  *  it acts as a factory method when invoked directly (e.g., from  *  {@link #transactionManager()}) and as a singleton bean when retrieved  *  through the application context (e.g., when injected into the test  *  instance). The result is that this method will be called twice:  *  *  <ol>  *  <li>once <em>indirectly</em> by the {@link TransactionalTestExecutionListener}  *  when it retrieves the {@link PlatformTransactionManager} from the  *  application context</li>  *  <li>and again when the {@link DataSource} is injected into the test  *  instance in {@link AbstractTransactionalAnnotatedConfigClassTests#setDataSource(DataSource)}.</li>  * </ol>  *  *  Consequently, the {@link JdbcTemplate} used by this test instance and  *  the {@link PlatformTransactionManager} used by the Spring TestContext  *  Framework will operate on two different {@code DataSource} instances,  *  which is almost certainly not the desired or intended behavior.  */ ;/**  *  Since this method does not reside in a true {@code @Configuration class},  *  it acts as a factory method when invoked directly (e.g., from  *  {@link #transactionManager()}) and as a singleton bean when retrieved  *  through the application context (e.g., when injected into the test  *  instance). The result is that this method will be called twice:  *  *  <ol>  *  <li>once <em>indirectly</em> by the {@link TransactionalTestExecutionListener}  *  when it retrieves the {@link PlatformTransactionManager} from the  *  application context</li>  *  <li>and again when the {@link DataSource} is injected into the test  *  instance in {@link AbstractTransactionalAnnotatedConfigClassTests#setDataSource(DataSource)}.</li>  * </ol>  *  *  Consequently, the {@link JdbcTemplate} used by this test instance and  *  the {@link PlatformTransactionManager} used by the Spring TestContext  *  Framework will operate on two different {@code DataSource} instances,  *  which is almost certainly not the desired or intended behavior.  */ @Bean public DataSource dataSource() {     return //      new EmbeddedDatabaseBuilder().addScript(//      "classpath:/org/springframework/test/jdbc/schema.sql").setName(//      getClass().getName()).build(). }
false;public;0;5;;@Before public void compareDataSources() throws Exception {     // NOTE: the two DataSource instances are NOT the same!     assertNotSame(dataSourceFromTxManager, dataSourceViaInjection). }
true;public;0;16;/**  * Overrides {@code afterTransaction()} in order to assert a different result.  *  * <p>See in-line comments for details.  *  * @see AbstractTransactionalAnnotatedConfigClassTests#afterTransaction()  * @see AbstractTransactionalAnnotatedConfigClassTests#modifyTestDataWithinTransaction()  */ ;/**  * Overrides {@code afterTransaction()} in order to assert a different result.  *  * <p>See in-line comments for details.  *  * @see AbstractTransactionalAnnotatedConfigClassTests#afterTransaction()  * @see AbstractTransactionalAnnotatedConfigClassTests#modifyTestDataWithinTransaction()  */ @AfterTransaction @Override public void afterTransaction() {     assertEquals("Deleting yoda", 1, deletePerson(YODA)).     // NOTE: We would actually expect that there are now ZERO entries in the     // person table, since the transaction is rolled back by the framework.     // however, since our JdbcTemplate and the transaction manager used by     // the Spring TestContext Framework use two different DataSource     // instances, our insert statements were executed in transactions that     // are not controlled by the test framework. Consequently, there was no     // rollback for the two insert statements in     // modifyTestDataWithinTransaction().     //      assertNumRowsInPersonTable(2, "after a transactional test method"). }
