commented;modifiers;parameterAmount;loc;comment;code
true;;0;1;/**  * Start building an HTTP GET request.  * @return a spec for specifying the target URL  */ ;/**  * Start building an HTTP GET request.  * @return a spec for specifying the target URL  */ RequestHeadersUriSpec<?> get().
true;;0;1;/**  * Start building an HTTP HEAD request.  * @return a spec for specifying the target URL  */ ;/**  * Start building an HTTP HEAD request.  * @return a spec for specifying the target URL  */ RequestHeadersUriSpec<?> head().
true;;0;1;/**  * Start building an HTTP POST request.  * @return a spec for specifying the target URL  */ ;/**  * Start building an HTTP POST request.  * @return a spec for specifying the target URL  */ RequestBodyUriSpec post().
true;;0;1;/**  * Start building an HTTP PUT request.  * @return a spec for specifying the target URL  */ ;/**  * Start building an HTTP PUT request.  * @return a spec for specifying the target URL  */ RequestBodyUriSpec put().
true;;0;1;/**  * Start building an HTTP PATCH request.  * @return a spec for specifying the target URL  */ ;/**  * Start building an HTTP PATCH request.  * @return a spec for specifying the target URL  */ RequestBodyUriSpec patch().
true;;0;1;/**  * Start building an HTTP DELETE request.  * @return a spec for specifying the target URL  */ ;/**  * Start building an HTTP DELETE request.  * @return a spec for specifying the target URL  */ RequestHeadersUriSpec<?> delete().
true;;0;1;/**  * Start building an HTTP OPTIONS request.  * @return a spec for specifying the target URL  */ ;/**  * Start building an HTTP OPTIONS request.  * @return a spec for specifying the target URL  */ RequestHeadersUriSpec<?> options().
true;;1;1;/**  * Start building a request for the given {@code HttpMethod}.  * @return a spec for specifying the target URL  */ ;/**  * Start building a request for the given {@code HttpMethod}.  * @return a spec for specifying the target URL  */ RequestBodyUriSpec method(HttpMethod method).
true;;0;1;/**  * Return a builder to create a new {@code WebClient} whose settings are  * replicated from the current {@code WebClient}.  */ ;/**  * Return a builder to create a new {@code WebClient} whose settings are  * replicated from the current {@code WebClient}.  */ Builder mutate().
true;static;0;3;/**  * Create a new {@code WebClient} with Reactor Netty by default.  * @see #create(String)  * @see #builder()  */ ;// Static, factory methods /**  * Create a new {@code WebClient} with Reactor Netty by default.  * @see #create(String)  * @see #builder()  */ static WebClient create() {     return new DefaultWebClientBuilder().build(). }
true;static;1;3;/**  * Variant of {@link #create()} that accepts a default base URL. For more  * details see {@link Builder#baseUrl(String) Builder.baseUrl(String)}.  * @param baseUrl the base URI for all requests  * @see #builder()  */ ;/**  * Variant of {@link #create()} that accepts a default base URL. For more  * details see {@link Builder#baseUrl(String) Builder.baseUrl(String)}.  * @param baseUrl the base URI for all requests  * @see #builder()  */ static WebClient create(String baseUrl) {     return new DefaultWebClientBuilder().baseUrl(baseUrl).build(). }
true;static;0;3;/**  * Obtain a {@code WebClient} builder.  */ ;/**  * Obtain a {@code WebClient} builder.  */ static WebClient.Builder builder() {     return new DefaultWebClientBuilder(). }
true;;1;1;/**  * Configure a base URL for requests performed through the client.  *  * <p>For example given base URL "http://abc.com/v1":  * <p><pre class="code">  * Mono&#060.Account&#062. result = client.get().uri("/accounts/{id}", 43)  *         .retrieve()  *         .bodyToMono(Account.class).  *  * // Result: http://abc.com/v1/accounts/43  *  * Flux&#060.Account&#062. result = client.get()  *         .uri(builder -> builder.path("/accounts").queryParam("q", "12").build())  *         .retrieve()  *         .bodyToFlux(Account.class).  *  * // Result: http://abc.com/v1/accounts?q=12  * </pre>  *  * <p>The base URL can be overridden with an absolute URI:  * <pre class="code">  * Mono&#060.Account&#062. result = client.get().uri("http://xyz.com/path")  *         .retrieve()  *         .bodyToMono(Account.class).  *  * // Result: http://xyz.com/path  * </pre>  *  * <p>Or partially overridden with a {@code UriBuilder}:  * <pre class="code">  * Flux&#060.Account&#062. result = client.get()  *         .uri(builder -> builder.replacePath("/v2/accounts").queryParam("q", "12").build())  *         .retrieve()  *         .bodyToFlux(Account.class).  *  * // Result: http://abc.com/v2/accounts?q=12  * </pre>  *  * @see #defaultUriVariables(Map)  * @see #uriBuilderFactory(UriBuilderFactory)  */ ;/**  * Configure a base URL for requests performed through the client.  *  * <p>For example given base URL "http://abc.com/v1":  * <p><pre class="code">  * Mono&#060.Account&#062. result = client.get().uri("/accounts/{id}", 43)  *         .retrieve()  *         .bodyToMono(Account.class).  *  * // Result: http://abc.com/v1/accounts/43  *  * Flux&#060.Account&#062. result = client.get()  *         .uri(builder -> builder.path("/accounts").queryParam("q", "12").build())  *         .retrieve()  *         .bodyToFlux(Account.class).  *  * // Result: http://abc.com/v1/accounts?q=12  * </pre>  *  * <p>The base URL can be overridden with an absolute URI:  * <pre class="code">  * Mono&#060.Account&#062. result = client.get().uri("http://xyz.com/path")  *         .retrieve()  *         .bodyToMono(Account.class).  *  * // Result: http://xyz.com/path  * </pre>  *  * <p>Or partially overridden with a {@code UriBuilder}:  * <pre class="code">  * Flux&#060.Account&#062. result = client.get()  *         .uri(builder -> builder.replacePath("/v2/accounts").queryParam("q", "12").build())  *         .retrieve()  *         .bodyToFlux(Account.class).  *  * // Result: http://abc.com/v2/accounts?q=12  * </pre>  *  * @see #defaultUriVariables(Map)  * @see #uriBuilderFactory(UriBuilderFactory)  */ Builder baseUrl(String baseUrl).
true;;1;1;/**  * Configure default URI variable values that will be used when expanding  * URI templates using a {@link Map}.  * @param defaultUriVariables the default values to use  * @see #baseUrl(String)  * @see #uriBuilderFactory(UriBuilderFactory)  */ ;/**  * Configure default URI variable values that will be used when expanding  * URI templates using a {@link Map}.  * @param defaultUriVariables the default values to use  * @see #baseUrl(String)  * @see #uriBuilderFactory(UriBuilderFactory)  */ Builder defaultUriVariables(Map<String, ?> defaultUriVariables).
true;;1;1;/**  * Provide a pre-configured {@link UriBuilderFactory} instance. This is  * an alternative to and effectively overrides the following:  * <ul>  * <li>{@link #baseUrl(String)}  * <li>{@link #defaultUriVariables(Map)}.  * </ul>  * @param uriBuilderFactory the URI builder factory to use  * @see #baseUrl(String)  * @see #defaultUriVariables(Map)  */ ;/**  * Provide a pre-configured {@link UriBuilderFactory} instance. This is  * an alternative to and effectively overrides the following:  * <ul>  * <li>{@link #baseUrl(String)}  * <li>{@link #defaultUriVariables(Map)}.  * </ul>  * @param uriBuilderFactory the URI builder factory to use  * @see #baseUrl(String)  * @see #defaultUriVariables(Map)  */ Builder uriBuilderFactory(UriBuilderFactory uriBuilderFactory).
true;;2;1;/**  * Global option to specify a header to be added to every request,  * if the request does not already contain such a header.  * @param header the header name  * @param values the header values  */ ;/**  * Global option to specify a header to be added to every request,  * if the request does not already contain such a header.  * @param header the header name  * @param values the header values  */ Builder defaultHeader(String header, String... values).
true;;1;1;/**  * Provides access to every {@link #defaultHeader(String, String...)}  * declared so far with the possibility to add, replace, or remove.  * @param headersConsumer the consumer  */ ;/**  * Provides access to every {@link #defaultHeader(String, String...)}  * declared so far with the possibility to add, replace, or remove.  * @param headersConsumer the consumer  */ Builder defaultHeaders(Consumer<HttpHeaders> headersConsumer).
true;;2;1;/**  * Global option to specify a cookie to be added to every request,  * if the request does not already contain such a cookie.  * @param cookie the cookie name  * @param values the cookie values  */ ;/**  * Global option to specify a cookie to be added to every request,  * if the request does not already contain such a cookie.  * @param cookie the cookie name  * @param values the cookie values  */ Builder defaultCookie(String cookie, String... values).
true;;1;1;/**  * Provides access to every {@link #defaultCookie(String, String...)}  * declared so far with the possibility to add, replace, or remove.  * @param cookiesConsumer a function that consumes the cookies map  */ ;/**  * Provides access to every {@link #defaultCookie(String, String...)}  * declared so far with the possibility to add, replace, or remove.  * @param cookiesConsumer a function that consumes the cookies map  */ Builder defaultCookies(Consumer<MultiValueMap<String, String>> cookiesConsumer).
true;;1;1;/**  * Provide a consumer to modify every request being built just before the  * call to {@link RequestHeadersSpec#exchange() exchange()}.  * @param defaultRequest the consumer to use for modifying requests  * @since 5.1  */ ;/**  * Provide a consumer to modify every request being built just before the  * call to {@link RequestHeadersSpec#exchange() exchange()}.  * @param defaultRequest the consumer to use for modifying requests  * @since 5.1  */ Builder defaultRequest(Consumer<RequestHeadersSpec<?>> defaultRequest).
true;;1;1;/**  * Add the given filter to the filter chain.  * @param filter the filter to be added to the chain  */ ;/**  * Add the given filter to the filter chain.  * @param filter the filter to be added to the chain  */ Builder filter(ExchangeFilterFunction filter).
true;;1;1;/**  * Manipulate the filters with the given consumer. The list provided to  * the consumer is "live", so that the consumer can be used to remove  * filters, change ordering, etc.  * @param filtersConsumer a function that consumes the filter list  * @return this builder  */ ;/**  * Manipulate the filters with the given consumer. The list provided to  * the consumer is "live", so that the consumer can be used to remove  * filters, change ordering, etc.  * @param filtersConsumer a function that consumes the filter list  * @return this builder  */ Builder filters(Consumer<List<ExchangeFilterFunction>> filtersConsumer).
true;;1;1;/**  * Configure the {@link ClientHttpConnector} to use. This is useful for  * plugging in and/or customizing options of the underlying HTTP client  * library (e.g. SSL).  * <p>By default this is set to  * {@link org.springframework.http.client.reactive.ReactorClientHttpConnector  * ReactorClientHttpConnector}.  * @param connector the connector to use  */ ;/**  * Configure the {@link ClientHttpConnector} to use. This is useful for  * plugging in and/or customizing options of the underlying HTTP client  * library (e.g. SSL).  * <p>By default this is set to  * {@link org.springframework.http.client.reactive.ReactorClientHttpConnector  * ReactorClientHttpConnector}.  * @param connector the connector to use  */ Builder clientConnector(ClientHttpConnector connector).
true;;1;1;/**  * Configure the {@link ExchangeStrategies} to use.  * <p>By default this is obtained from {@link ExchangeStrategies#withDefaults()}.  * @param strategies the strategies to use  */ ;/**  * Configure the {@link ExchangeStrategies} to use.  * <p>By default this is obtained from {@link ExchangeStrategies#withDefaults()}.  * @param strategies the strategies to use  */ Builder exchangeStrategies(ExchangeStrategies strategies).
true;;1;1;/**  * Provide an {@link ExchangeFunction} pre-configured with  * {@link ClientHttpConnector} and {@link ExchangeStrategies}.  * <p>This is an alternative to, and effectively overrides  * {@link #clientConnector}, and {@link #exchangeStrategies}.  * @param exchangeFunction the exchange function to use  */ ;/**  * Provide an {@link ExchangeFunction} pre-configured with  * {@link ClientHttpConnector} and {@link ExchangeStrategies}.  * <p>This is an alternative to, and effectively overrides  * {@link #clientConnector}, and {@link #exchangeStrategies}.  * @param exchangeFunction the exchange function to use  */ Builder exchangeFunction(ExchangeFunction exchangeFunction).
true;;0;1;/**  * Clone this {@code WebClient.Builder}.  */ ;/**  * Clone this {@code WebClient.Builder}.  */ Builder clone().
true;;1;1;/**  * Apply the given {@code Consumer} to this builder instance.  * <p>This can be useful for applying pre-packaged customizations.  * @param builderConsumer the consumer to apply  */ ;/**  * Apply the given {@code Consumer} to this builder instance.  * <p>This can be useful for applying pre-packaged customizations.  * @param builderConsumer the consumer to apply  */ Builder apply(Consumer<Builder> builderConsumer).
true;;0;1;/**  * Builder the {@link WebClient} instance.  */ ;/**  * Builder the {@link WebClient} instance.  */ WebClient build().
true;;1;1;/**  * Specify the URI using an absolute, fully constructed {@link URI}.  */ ;/**  * Specify the URI using an absolute, fully constructed {@link URI}.  */ S uri(URI uri).
true;;2;1;/**  * Specify the URI for the request using a URI template and URI variables.  * If a {@link UriBuilderFactory} was configured for the client (e.g.  * with a base URI) it will be used to expand the URI template.  */ ;/**  * Specify the URI for the request using a URI template and URI variables.  * If a {@link UriBuilderFactory} was configured for the client (e.g.  * with a base URI) it will be used to expand the URI template.  */ S uri(String uri, Object... uriVariables).
true;;2;1;/**  * Specify the URI for the request using a URI template and URI variables.  * If a {@link UriBuilderFactory} was configured for the client (e.g.  * with a base URI) it will be used to expand the URI template.  */ ;/**  * Specify the URI for the request using a URI template and URI variables.  * If a {@link UriBuilderFactory} was configured for the client (e.g.  * with a base URI) it will be used to expand the URI template.  */ S uri(String uri, Map<String, ?> uriVariables).
true;;1;1;/**  * Build the URI for the request using the {@link UriBuilderFactory}  * configured for this client.  */ ;/**  * Build the URI for the request using the {@link UriBuilderFactory}  * configured for this client.  */ S uri(Function<UriBuilder, URI> uriFunction).
true;;1;1;/**  * Set the list of acceptable {@linkplain MediaType media types}, as  * specified by the {@code Accept} header.  * @param acceptableMediaTypes the acceptable media types  * @return this builder  */ ;/**  * Set the list of acceptable {@linkplain MediaType media types}, as  * specified by the {@code Accept} header.  * @param acceptableMediaTypes the acceptable media types  * @return this builder  */ S accept(MediaType... acceptableMediaTypes).
true;;1;1;/**  * Set the list of acceptable {@linkplain Charset charsets}, as specified  * by the {@code Accept-Charset} header.  * @param acceptableCharsets the acceptable charsets  * @return this builder  */ ;/**  * Set the list of acceptable {@linkplain Charset charsets}, as specified  * by the {@code Accept-Charset} header.  * @param acceptableCharsets the acceptable charsets  * @return this builder  */ S acceptCharset(Charset... acceptableCharsets).
true;;2;1;/**  * Add a cookie with the given name and value.  * @param name the cookie name  * @param value the cookie value  * @return this builder  */ ;/**  * Add a cookie with the given name and value.  * @param name the cookie name  * @param value the cookie value  * @return this builder  */ S cookie(String name, String value).
true;;1;1;/**  * Provides access to every cookie declared so far with the possibility  * to add, replace, or remove values.  * @param cookiesConsumer the consumer to provide access to  * @return this builder  */ ;/**  * Provides access to every cookie declared so far with the possibility  * to add, replace, or remove values.  * @param cookiesConsumer the consumer to provide access to  * @return this builder  */ S cookies(Consumer<MultiValueMap<String, String>> cookiesConsumer).
true;;1;1;/**  * Set the value of the {@code If-Modified-Since} header.  * <p>The date should be specified as the number of milliseconds since  * January 1, 1970 GMT.  * @param ifModifiedSince the new value of the header  * @return this builder  */ ;/**  * Set the value of the {@code If-Modified-Since} header.  * <p>The date should be specified as the number of milliseconds since  * January 1, 1970 GMT.  * @param ifModifiedSince the new value of the header  * @return this builder  */ S ifModifiedSince(ZonedDateTime ifModifiedSince).
true;;1;1;/**  * Set the values of the {@code If-None-Match} header.  * @param ifNoneMatches the new value of the header  * @return this builder  */ ;/**  * Set the values of the {@code If-None-Match} header.  * @param ifNoneMatches the new value of the header  * @return this builder  */ S ifNoneMatch(String... ifNoneMatches).
true;;2;1;/**  * Add the given, single header value under the given name.  * @param headerName  the header name  * @param headerValues the header value(s)  * @return this builder  */ ;/**  * Add the given, single header value under the given name.  * @param headerName  the header name  * @param headerValues the header value(s)  * @return this builder  */ S header(String headerName, String... headerValues).
true;;1;1;/**  * Provides access to every header declared so far with the possibility  * to add, replace, or remove values.  * @param headersConsumer the consumer to provide access to  * @return this builder  */ ;/**  * Provides access to every header declared so far with the possibility  * to add, replace, or remove values.  * @param headersConsumer the consumer to provide access to  * @return this builder  */ S headers(Consumer<HttpHeaders> headersConsumer).
true;;2;1;/**  * Set the attribute with the given name to the given value.  * @param name the name of the attribute to add  * @param value the value of the attribute to add  * @return this builder  */ ;/**  * Set the attribute with the given name to the given value.  * @param name the name of the attribute to add  * @param value the value of the attribute to add  * @return this builder  */ S attribute(String name, Object value).
true;;1;1;/**  * Provides access to every attribute declared so far with the  * possibility to add, replace, or remove values.  * @param attributesConsumer the consumer to provide access to  * @return this builder  */ ;/**  * Provides access to every attribute declared so far with the  * possibility to add, replace, or remove values.  * @param attributesConsumer the consumer to provide access to  * @return this builder  */ S attributes(Consumer<Map<String, Object>> attributesConsumer).
true;;0;1;/**  * Perform the HTTP request and retrieve the response body:  * <p><pre>  * Mono&lt.Person&gt. bodyMono = client.get()  *     .uri("/persons/1")  *     .accept(MediaType.APPLICATION_JSON)  *     .retrieve()  *     .bodyToMono(Person.class).  * </pre>  * <p>This method is a shortcut to using {@link #exchange()} and  * decoding the response body through {@link ClientResponse}.  * @return {@code ResponseSpec} to specify how to decode the body  * @see #exchange()  */ ;/**  * Perform the HTTP request and retrieve the response body:  * <p><pre>  * Mono&lt.Person&gt. bodyMono = client.get()  *     .uri("/persons/1")  *     .accept(MediaType.APPLICATION_JSON)  *     .retrieve()  *     .bodyToMono(Person.class).  * </pre>  * <p>This method is a shortcut to using {@link #exchange()} and  * decoding the response body through {@link ClientResponse}.  * @return {@code ResponseSpec} to specify how to decode the body  * @see #exchange()  */ ResponseSpec retrieve().
true;;0;1;/**  * Perform the HTTP request and return a {@link ClientResponse} with the  * response status and headers. You can then use methods of the response  * to consume the body:  * <p><pre>  * Mono&lt.Person&gt. mono = client.get()  *     .uri("/persons/1")  *     .accept(MediaType.APPLICATION_JSON)  *     .exchange()  *     .flatMap(response -&gt. response.bodyToMono(Person.class)).  *  * Flux&lt.Person&gt. flux = client.get()  *     .uri("/persons")  *     .accept(MediaType.APPLICATION_STREAM_JSON)  *     .exchange()  *     .flatMapMany(response -&gt. response.bodyToFlux(Person.class)).  * </pre>  * <p><strong>NOTE:</strong> You must always use one of the body or  * entity methods of the response to ensure resources are released.  * See {@link ClientResponse} for more details.  * @return a {@code Mono} for the response  * @see #retrieve()  */ ;/**  * Perform the HTTP request and return a {@link ClientResponse} with the  * response status and headers. You can then use methods of the response  * to consume the body:  * <p><pre>  * Mono&lt.Person&gt. mono = client.get()  *     .uri("/persons/1")  *     .accept(MediaType.APPLICATION_JSON)  *     .exchange()  *     .flatMap(response -&gt. response.bodyToMono(Person.class)).  *  * Flux&lt.Person&gt. flux = client.get()  *     .uri("/persons")  *     .accept(MediaType.APPLICATION_STREAM_JSON)  *     .exchange()  *     .flatMapMany(response -&gt. response.bodyToFlux(Person.class)).  * </pre>  * <p><strong>NOTE:</strong> You must always use one of the body or  * entity methods of the response to ensure resources are released.  * See {@link ClientResponse} for more details.  * @return a {@code Mono} for the response  * @see #retrieve()  */ Mono<ClientResponse> exchange().
true;;1;1;/**  * Set the length of the body in bytes, as specified by the  * {@code Content-Length} header.  * @param contentLength the content length  * @return this builder  * @see HttpHeaders#setContentLength(long)  */ ;/**  * Set the length of the body in bytes, as specified by the  * {@code Content-Length} header.  * @param contentLength the content length  * @return this builder  * @see HttpHeaders#setContentLength(long)  */ RequestBodySpec contentLength(long contentLength).
true;;1;1;/**  * Set the {@linkplain MediaType media type} of the body, as specified  * by the {@code Content-Type} header.  * @param contentType the content type  * @return this builder  * @see HttpHeaders#setContentType(MediaType)  */ ;/**  * Set the {@linkplain MediaType media type} of the body, as specified  * by the {@code Content-Type} header.  * @param contentType the content type  * @return this builder  * @see HttpHeaders#setContentType(MediaType)  */ RequestBodySpec contentType(MediaType contentType).
true;;1;1;/**  * Set the body of the request using the given body inserter.  * {@link BodyInserters} provides access to built-in implementations of  * {@link BodyInserter}.  * @param inserter the body inserter to use for the request body  * @return this builder  * @see org.springframework.web.reactive.function.BodyInserters  */ ;/**  * Set the body of the request using the given body inserter.  * {@link BodyInserters} provides access to built-in implementations of  * {@link BodyInserter}.  * @param inserter the body inserter to use for the request body  * @return this builder  * @see org.springframework.web.reactive.function.BodyInserters  */ RequestHeadersSpec<?> body(BodyInserter<?, ? super ClientHttpRequest> inserter).
true;;2;1;/**  * A shortcut for {@link #body(BodyInserter)} with a  * {@linkplain BodyInserters#fromPublisher Publisher inserter}.  * For example:  * <p><pre>  * Mono<Person> personMono = ... .  *  * Mono<Void> result = client.post()  *     .uri("/persons/{id}", id)  *     .contentType(MediaType.APPLICATION_JSON)  *     .body(personMono, Person.class)  *     .retrieve()  *     .bodyToMono(Void.class).  * </pre>  * @param publisher the {@code Publisher} to write to the request  * @param elementClass the class of elements contained in the publisher  * @param <T> the type of the elements contained in the publisher  * @param <P> the type of the {@code Publisher}  * @return this builder  */ ;/**  * A shortcut for {@link #body(BodyInserter)} with a  * {@linkplain BodyInserters#fromPublisher Publisher inserter}.  * For example:  * <p><pre>  * Mono<Person> personMono = ... .  *  * Mono<Void> result = client.post()  *     .uri("/persons/{id}", id)  *     .contentType(MediaType.APPLICATION_JSON)  *     .body(personMono, Person.class)  *     .retrieve()  *     .bodyToMono(Void.class).  * </pre>  * @param publisher the {@code Publisher} to write to the request  * @param elementClass the class of elements contained in the publisher  * @param <T> the type of the elements contained in the publisher  * @param <P> the type of the {@code Publisher}  * @return this builder  */ <T, P extends Publisher<T>> RequestHeadersSpec<?> body(P publisher, Class<T> elementClass).
true;;2;2;/**  * A variant of {@link #body(Publisher, Class)} that allows providing  * element type information that includes generics via a  * {@link ParameterizedTypeReference}.  * @param publisher the {@code Publisher} to write to the request  * @param typeReference the type reference of elements contained in the publisher  * @param <T> the type of the elements contained in the publisher  * @param <P> the type of the {@code Publisher}  * @return this builder  */ ;/**  * A variant of {@link #body(Publisher, Class)} that allows providing  * element type information that includes generics via a  * {@link ParameterizedTypeReference}.  * @param publisher the {@code Publisher} to write to the request  * @param typeReference the type reference of elements contained in the publisher  * @param <T> the type of the elements contained in the publisher  * @param <P> the type of the {@code Publisher}  * @return this builder  */ <T, P extends Publisher<T>> RequestHeadersSpec<?> body(P publisher, ParameterizedTypeReference<T> typeReference).
true;;1;1;/**  * A shortcut for {@link #body(BodyInserter)} with an  * {@linkplain BodyInserters#fromObject Object inserter}.  * For example:  * <p><pre class="code">  * Person person = ... .  *  * Mono&lt.Void&gt. result = client.post()  *     .uri("/persons/{id}", id)  *     .contentType(MediaType.APPLICATION_JSON)  *     .syncBody(person)  *     .retrieve()  *     .bodyToMono(Void.class).  * </pre>  * <p>For multipart requests, provide a  * {@link org.springframework.util.MultiValueMap MultiValueMap}. The  * values in the {@code MultiValueMap} can be any Object representing  * the body of the part, or an  * {@link org.springframework.http.HttpEntity HttpEntity} representing  * a part with body and headers. The {@code MultiValueMap} can be built  * with {@link org.springframework.http.client.MultipartBodyBuilder  * MultipartBodyBuilder}.  * @param body the {@code Object} to write to the request  * @return this builder  */ ;/**  * A shortcut for {@link #body(BodyInserter)} with an  * {@linkplain BodyInserters#fromObject Object inserter}.  * For example:  * <p><pre class="code">  * Person person = ... .  *  * Mono&lt.Void&gt. result = client.post()  *     .uri("/persons/{id}", id)  *     .contentType(MediaType.APPLICATION_JSON)  *     .syncBody(person)  *     .retrieve()  *     .bodyToMono(Void.class).  * </pre>  * <p>For multipart requests, provide a  * {@link org.springframework.util.MultiValueMap MultiValueMap}. The  * values in the {@code MultiValueMap} can be any Object representing  * the body of the part, or an  * {@link org.springframework.http.HttpEntity HttpEntity} representing  * a part with body and headers. The {@code MultiValueMap} can be built  * with {@link org.springframework.http.client.MultipartBodyBuilder  * MultipartBodyBuilder}.  * @param body the {@code Object} to write to the request  * @return this builder  */ RequestHeadersSpec<?> syncBody(Object body).
true;;2;2;/**  * Register a custom error function that gets invoked when the given {@link HttpStatus}  * predicate applies. The exception returned from the function will be returned from  * {@link #bodyToMono(Class)} and {@link #bodyToFlux(Class)}.  * <p>By default, an error handler is register that throws a  * {@link WebClientResponseException} when the response status code is 4xx or 5xx.  * @param statusPredicate a predicate that indicates whether {@code exceptionFunction}  * applies  * <p><strong>NOTE:</strong> if the response is expected to have content,  * the exceptionFunction should consume it. If not, the content will be  * automatically drained to ensure resources are released.  * @param exceptionFunction the function that returns the exception  * @return this builder  */ ;/**  * Register a custom error function that gets invoked when the given {@link HttpStatus}  * predicate applies. The exception returned from the function will be returned from  * {@link #bodyToMono(Class)} and {@link #bodyToFlux(Class)}.  * <p>By default, an error handler is register that throws a  * {@link WebClientResponseException} when the response status code is 4xx or 5xx.  * @param statusPredicate a predicate that indicates whether {@code exceptionFunction}  * applies  * <p><strong>NOTE:</strong> if the response is expected to have content,  * the exceptionFunction should consume it. If not, the content will be  * automatically drained to ensure resources are released.  * @param exceptionFunction the function that returns the exception  * @return this builder  */ ResponseSpec onStatus(Predicate<HttpStatus> statusPredicate, Function<ClientResponse, Mono<? extends Throwable>> exceptionFunction).
true;;1;1;/**  * Extract the body to a {@code Mono}. By default, if the response has status code 4xx or  * 5xx, the {@code Mono} will contain a {@link WebClientException}. This can be overridden  * with {@link #onStatus(Predicate, Function)}.  * @param bodyType the expected response body type  * @param <T> response body type  * @return a mono containing the body, or a {@link WebClientResponseException} if the  * status code is 4xx or 5xx  */ ;/**  * Extract the body to a {@code Mono}. By default, if the response has status code 4xx or  * 5xx, the {@code Mono} will contain a {@link WebClientException}. This can be overridden  * with {@link #onStatus(Predicate, Function)}.  * @param bodyType the expected response body type  * @param <T> response body type  * @return a mono containing the body, or a {@link WebClientResponseException} if the  * status code is 4xx or 5xx  */ <T> Mono<T> bodyToMono(Class<T> bodyType).
true;;1;1;/**  * Extract the body to a {@code Mono}. By default, if the response has status code 4xx or  * 5xx, the {@code Mono} will contain a {@link WebClientException}. This can be overridden  * with {@link #onStatus(Predicate, Function)}.  * @param typeReference a type reference describing the expected response body type  * @param <T> response body type  * @return a mono containing the body, or a {@link WebClientResponseException} if the  * status code is 4xx or 5xx  */ ;/**  * Extract the body to a {@code Mono}. By default, if the response has status code 4xx or  * 5xx, the {@code Mono} will contain a {@link WebClientException}. This can be overridden  * with {@link #onStatus(Predicate, Function)}.  * @param typeReference a type reference describing the expected response body type  * @param <T> response body type  * @return a mono containing the body, or a {@link WebClientResponseException} if the  * status code is 4xx or 5xx  */ <T> Mono<T> bodyToMono(ParameterizedTypeReference<T> typeReference).
true;;1;1;/**  * Extract the body to a {@code Flux}. By default, if the response has status code 4xx or  * 5xx, the {@code Flux} will contain a {@link WebClientException}. This can be overridden  * with {@link #onStatus(Predicate, Function)}.  * @param elementType the type of element in the response  * @param <T> the type of elements in the response  * @return a flux containing the body, or a {@link WebClientResponseException} if the  * status code is 4xx or 5xx  */ ;/**  * Extract the body to a {@code Flux}. By default, if the response has status code 4xx or  * 5xx, the {@code Flux} will contain a {@link WebClientException}. This can be overridden  * with {@link #onStatus(Predicate, Function)}.  * @param elementType the type of element in the response  * @param <T> the type of elements in the response  * @return a flux containing the body, or a {@link WebClientResponseException} if the  * status code is 4xx or 5xx  */ <T> Flux<T> bodyToFlux(Class<T> elementType).
true;;1;1;/**  * Extract the body to a {@code Flux}. By default, if the response has status code 4xx or  * 5xx, the {@code Flux} will contain a {@link WebClientException}. This can be overridden  * with {@link #onStatus(Predicate, Function)}.  * @param typeReference a type reference describing the expected response body type  * @param <T> the type of elements in the response  * @return a flux containing the body, or a {@link WebClientResponseException} if the  * status code is 4xx or 5xx  */ ;/**  * Extract the body to a {@code Flux}. By default, if the response has status code 4xx or  * 5xx, the {@code Flux} will contain a {@link WebClientException}. This can be overridden  * with {@link #onStatus(Predicate, Function)}.  * @param typeReference a type reference describing the expected response body type  * @param <T> the type of elements in the response  * @return a flux containing the body, or a {@link WebClientResponseException} if the  * status code is 4xx or 5xx  */ <T> Flux<T> bodyToFlux(ParameterizedTypeReference<T> typeReference).
