commented;modifiers;parameterAmount;loc;comment;code
true;public;1;6;/**  * Configure path prefixes to apply to controller methods.  * <p>Prefixes are used to enrich the mappings of every {@code @RequestMapping}  * method whose controller type is matched by a corresponding  * {@code Predicate} in the map. The prefix for the first matching predicate  * is used, assuming the input map has predictable order.  * <p>Consider using {@link org.springframework.web.method.HandlerTypePredicate  * HandlerTypePredicate} to group controllers.  * @param prefixes a map with path prefixes as key  * @since 5.1  * @see org.springframework.web.method.HandlerTypePredicate  */ ;/**  * Configure path prefixes to apply to controller methods.  * <p>Prefixes are used to enrich the mappings of every {@code @RequestMapping}  * method whose controller type is matched by a corresponding  * {@code Predicate} in the map. The prefix for the first matching predicate  * is used, assuming the input map has predictable order.  * <p>Consider using {@link org.springframework.web.method.HandlerTypePredicate  * HandlerTypePredicate} to group controllers.  * @param prefixes a map with path prefixes as key  * @since 5.1  * @see org.springframework.web.method.HandlerTypePredicate  */ public void setPathPrefixes(Map<String, Predicate<Class<?>>> prefixes) {     this.pathPrefixes.clear().     prefixes.entrySet().stream().filter(entry -> StringUtils.hasText(entry.getKey())).forEach(entry -> this.pathPrefixes.put(entry.getKey(), entry.getValue())). }
true;public;0;3;/**  * The configured path prefixes as a read-only, possibly empty map.  * @since 5.1  */ ;/**  * The configured path prefixes as a read-only, possibly empty map.  * @since 5.1  */ public Map<String, Predicate<Class<?>>> getPathPrefixes() {     return Collections.unmodifiableMap(this.pathPrefixes). }
true;public;1;4;/**  * Set the {@link RequestedContentTypeResolver} to use to determine requested  * media types. If not set, the default constructor is used.  */ ;/**  * Set the {@link RequestedContentTypeResolver} to use to determine requested  * media types. If not set, the default constructor is used.  */ public void setContentTypeResolver(RequestedContentTypeResolver contentTypeResolver) {     Assert.notNull(contentTypeResolver, "'contentTypeResolver' must not be null").     this.contentTypeResolver = contentTypeResolver. }
true;public;0;3;/**  * Return the configured {@link RequestedContentTypeResolver}.  */ ;/**  * Return the configured {@link RequestedContentTypeResolver}.  */ public RequestedContentTypeResolver getContentTypeResolver() {     return this.contentTypeResolver. }
false;public;1;4;;@Override public void setEmbeddedValueResolver(StringValueResolver resolver) {     this.embeddedValueResolver = resolver. }
false;public;0;8;;@Override public void afterPropertiesSet() {     this.config = new RequestMappingInfo.BuilderConfiguration().     this.config.setPatternParser(getPathPatternParser()).     this.config.setContentTypeResolver(getContentTypeResolver()).     super.afterPropertiesSet(). }
true;protected;1;5;/**  * {@inheritDoc}  * Expects a handler to have a type-level @{@link Controller} annotation.  */ ;/**  * {@inheritDoc}  * Expects a handler to have a type-level @{@link Controller} annotation.  */ @Override protected boolean isHandler(Class<?> beanType) {     return (AnnotatedElementUtils.hasAnnotation(beanType, Controller.class) || AnnotatedElementUtils.hasAnnotation(beanType, RequestMapping.class)). }
true;protected;2;21;/**  * Uses method and type-level @{@link RequestMapping} annotations to create  * the RequestMappingInfo.  * @return the created RequestMappingInfo, or {@code null} if the method  * does not have a {@code @RequestMapping} annotation.  * @see #getCustomMethodCondition(Method)  * @see #getCustomTypeCondition(Class)  */ ;/**  * Uses method and type-level @{@link RequestMapping} annotations to create  * the RequestMappingInfo.  * @return the created RequestMappingInfo, or {@code null} if the method  * does not have a {@code @RequestMapping} annotation.  * @see #getCustomMethodCondition(Method)  * @see #getCustomTypeCondition(Class)  */ @Override protected RequestMappingInfo getMappingForMethod(Method method, Class<?> handlerType) {     RequestMappingInfo info = createRequestMappingInfo(method).     if (info != null) {         RequestMappingInfo typeInfo = createRequestMappingInfo(handlerType).         if (typeInfo != null) {             info = typeInfo.combine(info).         }         for (Map.Entry<String, Predicate<Class<?>>> entry : this.pathPrefixes.entrySet()) {             if (entry.getValue().test(handlerType)) {                 String prefix = entry.getKey().                 if (this.embeddedValueResolver != null) {                     prefix = this.embeddedValueResolver.resolveStringValue(prefix).                 }                 info = RequestMappingInfo.paths(prefix).build().combine(info).                 break.             }         }     }     return info. }
true;private;1;7;/**  * Delegates to {@link #createRequestMappingInfo(RequestMapping, RequestCondition)},  * supplying the appropriate custom {@link RequestCondition} depending on whether  * the supplied {@code annotatedElement} is a class or method.  * @see #getCustomTypeCondition(Class)  * @see #getCustomMethodCondition(Method)  */ ;/**  * Delegates to {@link #createRequestMappingInfo(RequestMapping, RequestCondition)},  * supplying the appropriate custom {@link RequestCondition} depending on whether  * the supplied {@code annotatedElement} is a class or method.  * @see #getCustomTypeCondition(Class)  * @see #getCustomMethodCondition(Method)  */ @Nullable private RequestMappingInfo createRequestMappingInfo(AnnotatedElement element) {     RequestMapping requestMapping = AnnotatedElementUtils.findMergedAnnotation(element, RequestMapping.class).     RequestCondition<?> condition = (element instanceof Class ? getCustomTypeCondition((Class<?>) element) : getCustomMethodCondition((Method) element)).     return (requestMapping != null ? createRequestMappingInfo(requestMapping, condition) : null). }
true;protected;1;5;/**  * Provide a custom type-level request condition.  * The custom {@link RequestCondition} can be of any type so long as the  * same condition type is returned from all calls to this method in order  * to ensure custom request conditions can be combined and compared.  * <p>Consider extending  * {@link org.springframework.web.reactive.result.condition.AbstractRequestCondition  * AbstractRequestCondition} for custom condition types and using  * {@link org.springframework.web.reactive.result.condition.CompositeRequestCondition  * CompositeRequestCondition} to provide multiple custom conditions.  * @param handlerType the handler type for which to create the condition  * @return the condition, or {@code null}  */ ;/**  * Provide a custom type-level request condition.  * The custom {@link RequestCondition} can be of any type so long as the  * same condition type is returned from all calls to this method in order  * to ensure custom request conditions can be combined and compared.  * <p>Consider extending  * {@link org.springframework.web.reactive.result.condition.AbstractRequestCondition  * AbstractRequestCondition} for custom condition types and using  * {@link org.springframework.web.reactive.result.condition.CompositeRequestCondition  * CompositeRequestCondition} to provide multiple custom conditions.  * @param handlerType the handler type for which to create the condition  * @return the condition, or {@code null}  */ @SuppressWarnings("UnusedParameters") @Nullable protected RequestCondition<?> getCustomTypeCondition(Class<?> handlerType) {     return null. }
true;protected;1;5;/**  * Provide a custom method-level request condition.  * The custom {@link RequestCondition} can be of any type so long as the  * same condition type is returned from all calls to this method in order  * to ensure custom request conditions can be combined and compared.  * <p>Consider extending  * {@link org.springframework.web.reactive.result.condition.AbstractRequestCondition  * AbstractRequestCondition} for custom condition types and using  * {@link org.springframework.web.reactive.result.condition.CompositeRequestCondition  * CompositeRequestCondition} to provide multiple custom conditions.  * @param method the handler method for which to create the condition  * @return the condition, or {@code null}  */ ;/**  * Provide a custom method-level request condition.  * The custom {@link RequestCondition} can be of any type so long as the  * same condition type is returned from all calls to this method in order  * to ensure custom request conditions can be combined and compared.  * <p>Consider extending  * {@link org.springframework.web.reactive.result.condition.AbstractRequestCondition  * AbstractRequestCondition} for custom condition types and using  * {@link org.springframework.web.reactive.result.condition.CompositeRequestCondition  * CompositeRequestCondition} to provide multiple custom conditions.  * @param method the handler method for which to create the condition  * @return the condition, or {@code null}  */ @SuppressWarnings("UnusedParameters") @Nullable protected RequestCondition<?> getCustomMethodCondition(Method method) {     return null. }
true;protected;2;16;/**  * Create a {@link RequestMappingInfo} from the supplied  * {@link RequestMapping @RequestMapping} annotation, which is either  * a directly declared annotation, a meta-annotation, or the synthesized  * result of merging annotation attributes within an annotation hierarchy.  */ ;/**  * Create a {@link RequestMappingInfo} from the supplied  * {@link RequestMapping @RequestMapping} annotation, which is either  * a directly declared annotation, a meta-annotation, or the synthesized  * result of merging annotation attributes within an annotation hierarchy.  */ protected RequestMappingInfo createRequestMappingInfo(RequestMapping requestMapping, @Nullable RequestCondition<?> customCondition) {     RequestMappingInfo.Builder builder = RequestMappingInfo.paths(resolveEmbeddedValuesInPatterns(requestMapping.path())).methods(requestMapping.method()).params(requestMapping.params()).headers(requestMapping.headers()).consumes(requestMapping.consumes()).produces(requestMapping.produces()).mappingName(requestMapping.name()).     if (customCondition != null) {         builder.customCondition(customCondition).     }     return builder.options(this.config).build(). }
true;protected;1;12;/**  * Resolve placeholder values in the given array of patterns.  * @return a new array with updated patterns  */ ;/**  * Resolve placeholder values in the given array of patterns.  * @return a new array with updated patterns  */ protected String[] resolveEmbeddedValuesInPatterns(String[] patterns) {     if (this.embeddedValueResolver == null) {         return patterns.     } else {         String[] resolvedPatterns = new String[patterns.length].         for (int i = 0. i < patterns.length. i++) {             resolvedPatterns[i] = this.embeddedValueResolver.resolveStringValue(patterns[i]).         }         return resolvedPatterns.     } }
false;protected;3;22;;@Override protected CorsConfiguration initCorsConfiguration(Object handler, Method method, RequestMappingInfo mappingInfo) {     HandlerMethod handlerMethod = createHandlerMethod(handler, method).     Class<?> beanType = handlerMethod.getBeanType().     CrossOrigin typeAnnotation = AnnotatedElementUtils.findMergedAnnotation(beanType, CrossOrigin.class).     CrossOrigin methodAnnotation = AnnotatedElementUtils.findMergedAnnotation(method, CrossOrigin.class).     if (typeAnnotation == null && methodAnnotation == null) {         return null.     }     CorsConfiguration config = new CorsConfiguration().     updateCorsConfig(config, typeAnnotation).     updateCorsConfig(config, methodAnnotation).     if (CollectionUtils.isEmpty(config.getAllowedMethods())) {         for (RequestMethod allowedMethod : mappingInfo.getMethodsCondition().getMethods()) {             config.addAllowedMethod(allowedMethod.name()).         }     }     return config.applyPermitDefaultValues(). }
false;private;2;33;;private void updateCorsConfig(CorsConfiguration config, @Nullable CrossOrigin annotation) {     if (annotation == null) {         return.     }     for (String origin : annotation.origins()) {         config.addAllowedOrigin(resolveCorsAnnotationValue(origin)).     }     for (RequestMethod method : annotation.methods()) {         config.addAllowedMethod(method.name()).     }     for (String header : annotation.allowedHeaders()) {         config.addAllowedHeader(resolveCorsAnnotationValue(header)).     }     for (String header : annotation.exposedHeaders()) {         config.addExposedHeader(resolveCorsAnnotationValue(header)).     }     String allowCredentials = resolveCorsAnnotationValue(annotation.allowCredentials()).     if ("true".equalsIgnoreCase(allowCredentials)) {         config.setAllowCredentials(true).     } else if ("false".equalsIgnoreCase(allowCredentials)) {         config.setAllowCredentials(false).     } else if (!allowCredentials.isEmpty()) {         throw new IllegalStateException("@CrossOrigin's allowCredentials value must be \"true\", \"false\", " + "or an empty string (\"\"): current value is [" + allowCredentials + "]").     }     if (annotation.maxAge() >= 0 && config.getMaxAge() == null) {         config.setMaxAge(annotation.maxAge()).     } }
false;private;1;9;;private String resolveCorsAnnotationValue(String value) {     if (this.embeddedValueResolver != null) {         String resolved = this.embeddedValueResolver.resolveStringValue(value).         return (resolved != null ? resolved : "").     } else {         return value.     } }
