commented;modifiers;parameterAmount;loc;comment;code
false;public;1;10;;@Override public boolean supportsParameter(MethodParameter parameter) {     if (parameter.hasParameterAnnotation(ModelAttribute.class)) {         return true.     } else if (this.useDefaultResolution) {         return checkParameterType(parameter, type -> !BeanUtils.isSimpleProperty(type)).     }     return false. }
false;public;3;47;;@Override public Mono<Object> resolveArgument(MethodParameter parameter, BindingContext context, ServerWebExchange exchange) {     ResolvableType type = ResolvableType.forMethodParameter(parameter).     Class<?> resolvedType = type.resolve().     ReactiveAdapter adapter = (resolvedType != null ? getAdapterRegistry().getAdapter(resolvedType) : null).     ResolvableType valueType = (adapter != null ? type.getGeneric() : type).     Assert.state(adapter == null || !adapter.isMultiValue(), () -> getClass().getSimpleName() + " does not support multi-value reactive type wrapper: " + parameter.getGenericParameterType()).     String name = ModelInitializer.getNameForParameter(parameter).     Mono<?> valueMono = prepareAttributeMono(name, valueType, context, exchange).     Map<String, Object> model = context.getModel().asMap().     MonoProcessor<BindingResult> bindingResultMono = MonoProcessor.create().     model.put(BindingResult.MODEL_KEY_PREFIX + name, bindingResultMono).     return valueMono.flatMap(value -> {         WebExchangeDataBinder binder = context.createDataBinder(exchange, value, name).         return binder.bind(exchange).doOnError(bindingResultMono::onError).doOnSuccess(aVoid -> {             validateIfApplicable(binder, parameter).             BindingResult errors = binder.getBindingResult().             model.put(BindingResult.MODEL_KEY_PREFIX + name, errors).             model.put(name, value).             bindingResultMono.onNext(errors).         }).then(Mono.fromCallable(() -> {             BindingResult errors = binder.getBindingResult().             if (adapter != null) {                 return adapter.fromPublisher(errors.hasErrors() ? Mono.error(new WebExchangeBindException(parameter, errors)) : valueMono).             } else {                 if (errors.hasErrors() && !hasErrorsArgument(parameter)) {                     throw new WebExchangeBindException(parameter, errors).                 }                 return value.             }         })).     }). }
false;private;4;22;;private Mono<?> prepareAttributeMono(String attributeName, ResolvableType attributeType, BindingContext context, ServerWebExchange exchange) {     Object attribute = context.getModel().asMap().get(attributeName).     if (attribute == null) {         attribute = findAndRemoveReactiveAttribute(context.getModel(), attributeName).     }     if (attribute == null) {         return createAttribute(attributeName, attributeType.toClass(), context, exchange).     }     ReactiveAdapter adapterFrom = getAdapterRegistry().getAdapter(null, attribute).     if (adapterFrom != null) {         Assert.isTrue(!adapterFrom.isMultiValue(), "Data binding only supports single-value async types").         return Mono.from(adapterFrom.toPublisher(attribute)).     } else {         return Mono.justOrEmpty(attribute).     } }
false;private;2;22;;@Nullable private Object findAndRemoveReactiveAttribute(Model model, String attributeName) {     return model.asMap().entrySet().stream().filter(entry -> {         if (!entry.getKey().startsWith(attributeName)) {             return false.         }         ReactiveAdapter adapter = getAdapterRegistry().getAdapter(null, entry.getValue()).         if (adapter == null) {             return false.         }         String name = attributeName + ClassUtils.getShortName(adapter.getReactiveType()).         return entry.getKey().equals(name).     }).findFirst().map(entry -> {         // Remove since we will be re-inserting the resolved attribute value         model.asMap().remove(entry.getKey()).         return entry.getValue().     }).orElse(null). }
false;private;4;20;;private Mono<?> createAttribute(String attributeName, Class<?> clazz, BindingContext context, ServerWebExchange exchange) {     Constructor<?> ctor = BeanUtils.findPrimaryConstructor(clazz).     if (ctor == null) {         Constructor<?>[] ctors = clazz.getConstructors().         if (ctors.length == 1) {             ctor = ctors[0].         } else {             try {                 ctor = clazz.getDeclaredConstructor().             } catch (NoSuchMethodException ex) {                 throw new IllegalStateException("No primary or default constructor found for " + clazz, ex).             }         }     }     return constructAttribute(ctor, attributeName, context, exchange). }
false;private;4;46;;private Mono<?> constructAttribute(Constructor<?> ctor, String attributeName, BindingContext context, ServerWebExchange exchange) {     if (ctor.getParameterCount() == 0) {         // A single default constructor -> clearly a standard JavaBeans arrangement.         return Mono.just(BeanUtils.instantiateClass(ctor)).     }     // A single data class constructor -> resolve constructor arguments from request parameters.     return WebExchangeDataBinder.extractValuesToBind(exchange).map(bindValues -> {         ConstructorProperties cp = ctor.getAnnotation(ConstructorProperties.class).         String[] paramNames = (cp != null ? cp.value() : parameterNameDiscoverer.getParameterNames(ctor)).         Assert.state(paramNames != null, () -> "Cannot resolve parameter names for constructor " + ctor).         Class<?>[] paramTypes = ctor.getParameterTypes().         Assert.state(paramNames.length == paramTypes.length, () -> "Invalid number of parameter names: " + paramNames.length + " for constructor " + ctor).         Object[] args = new Object[paramTypes.length].         WebDataBinder binder = context.createDataBinder(exchange, null, attributeName).         String fieldDefaultPrefix = binder.getFieldDefaultPrefix().         String fieldMarkerPrefix = binder.getFieldMarkerPrefix().         for (int i = 0. i < paramNames.length. i++) {             String paramName = paramNames[i].             Class<?> paramType = paramTypes[i].             Object value = bindValues.get(paramName).             if (value == null) {                 if (fieldDefaultPrefix != null) {                     value = bindValues.get(fieldDefaultPrefix + paramName).                 }                 if (value == null && fieldMarkerPrefix != null) {                     if (bindValues.get(fieldMarkerPrefix + paramName) != null) {                         value = binder.getEmptyValue(paramType).                     }                 }             }             value = (value instanceof List ? ((List<?>) value).toArray() : value).             MethodParameter methodParam = new MethodParameter(ctor, i).             if (value == null && methodParam.isOptional()) {                 args[i] = (methodParam.getParameterType() == Optional.class ? Optional.empty() : null).             } else {                 args[i] = binder.convertIfNecessary(value, paramTypes[i], methodParam).             }         }         return BeanUtils.instantiateClass(ctor, args).     }). }
false;private;1;5;;private boolean hasErrorsArgument(MethodParameter parameter) {     int i = parameter.getParameterIndex().     Class<?>[] paramTypes = parameter.getExecutable().getParameterTypes().     return (paramTypes.length > i + 1 && Errors.class.isAssignableFrom(paramTypes[i + 1])). }
false;private;2;15;;private void validateIfApplicable(WebExchangeDataBinder binder, MethodParameter parameter) {     for (Annotation ann : parameter.getParameterAnnotations()) {         Validated validatedAnn = AnnotationUtils.getAnnotation(ann, Validated.class).         if (validatedAnn != null || ann.annotationType().getSimpleName().startsWith("Valid")) {             Object hints = (validatedAnn != null ? validatedAnn.value() : AnnotationUtils.getValue(ann)).             if (hints != null) {                 Object[] validationHints = (hints instanceof Object[] ? (Object[]) hints : new Object[] { hints }).                 binder.validate(validationHints).             } else {                 binder.validate().             }         }     } }
