commented;modifiers;parameterAmount;loc;comment;code
false;public;3;26;;@SuppressWarnings("deprecation") @Override public Mono<Resource> transform(ServerWebExchange exchange, Resource inputResource, ResourceTransformerChain transformerChain) {     return transformerChain.transform(exchange, inputResource).flatMap(outputResource -> {         String filename = outputResource.getFilename().         if (!"css".equals(StringUtils.getFilenameExtension(filename)) || inputResource instanceof EncodedResourceResolver.EncodedResource || inputResource instanceof GzipResourceResolver.GzippedResource) {             return Mono.just(outputResource).         }         DataBufferFactory bufferFactory = exchange.getResponse().bufferFactory().         Flux<DataBuffer> flux = DataBufferUtils.read(outputResource, bufferFactory, StreamUtils.BUFFER_SIZE).         return DataBufferUtils.join(flux).flatMap(dataBuffer -> {             CharBuffer charBuffer = DEFAULT_CHARSET.decode(dataBuffer.asByteBuffer()).             DataBufferUtils.release(dataBuffer).             String cssContent = charBuffer.toString().             return transformContent(cssContent, outputResource, transformerChain, exchange).         }).     }). }
false;private;4;28;;private Mono<? extends Resource> transformContent(String cssContent, Resource resource, ResourceTransformerChain chain, ServerWebExchange exchange) {     List<ContentChunkInfo> contentChunkInfos = parseContent(cssContent).     if (contentChunkInfos.isEmpty()) {         return Mono.just(resource).     }     return Flux.fromIterable(contentChunkInfos).concatMap(contentChunkInfo -> {         String contentChunk = contentChunkInfo.getContent(cssContent).         if (contentChunkInfo.isLink() && !hasScheme(contentChunk)) {             String link = toAbsolutePath(contentChunk, exchange).             return resolveUrlPath(link, exchange, resource, chain).defaultIfEmpty(contentChunk).         } else {             return Mono.just(contentChunk).         }     }).reduce(new StringWriter(), (writer, chunk) -> {         writer.write(chunk).         return writer.     }).map(writer -> {         byte[] newContent = writer.toString().getBytes(DEFAULT_CHARSET).         return new TransformedResource(resource, newContent).     }). }
false;private;1;18;;private List<ContentChunkInfo> parseContent(String cssContent) {     SortedSet<ContentChunkInfo> links = new TreeSet<>().     this.linkParsers.forEach(parser -> parser.parse(cssContent, links)).     if (links.isEmpty()) {         return Collections.emptyList().     }     int index = 0.     List<ContentChunkInfo> result = new ArrayList<>().     for (ContentChunkInfo link : links) {         result.add(new ContentChunkInfo(index, link.getStart(), false)).         result.add(link).         index = link.getEnd().     }     if (index < cssContent.length()) {         result.add(new ContentChunkInfo(index, cssContent.length(), false)).     }     return result. }
false;private;1;4;;private boolean hasScheme(String link) {     int schemeIndex = link.indexOf(':').     return (schemeIndex > 0 && !link.substring(0, schemeIndex).contains("/")) || link.indexOf("//") == 0. }
false;;2;1;;void parse(String cssContent, SortedSet<ContentChunkInfo> result).
true;protected,abstract;0;1;/**  * Return the keyword to use to search for links, e.g. "@import", "url("  */ ;/**  * Return the keyword to use to search for links, e.g. "@import", "url("  */ protected abstract String getKeyword().
false;public;2;24;;@Override public void parse(String content, SortedSet<ContentChunkInfo> result) {     int position = 0.     while (true) {         position = content.indexOf(getKeyword(), position).         if (position == -1) {             return.         }         position += getKeyword().length().         while (Character.isWhitespace(content.charAt(position))) {             position++.         }         if (content.charAt(position) == '\'') {             position = extractLink(position, '\'', content, result).         } else if (content.charAt(position) == '"') {             position = extractLink(position, '"', content, result).         } else {             position = extractUnquotedLink(position, content, result).         }     } }
false;protected;4;6;;protected int extractLink(int index, char endChar, String content, Set<ContentChunkInfo> result) {     int start = index + 1.     int end = content.indexOf(endChar, start).     result.add(new ContentChunkInfo(start, end, true)).     return end + 1. }
true;protected,abstract;3;2;/**  * Invoked after a keyword match, after whitespaces removed, and when  * the next char is neither a single nor double quote.  */ ;/**  * Invoked after a keyword match, after whitespaces removed, and when  * the next char is neither a single nor double quote.  */ protected abstract int extractUnquotedLink(int position, String content, Set<ContentChunkInfo> linksToAdd).
false;protected;0;4;;@Override protected String getKeyword() {     return "@import". }
false;protected;3;10;;@Override protected int extractUnquotedLink(int position, String content, Set<ContentChunkInfo> result) {     if (content.substring(position, position + 4).equals("url(")) {     // Ignore, UrlFunctionContentParser will take care     } else if (logger.isTraceEnabled()) {         logger.trace("Unexpected syntax for @import link at index " + position).     }     return position. }
false;protected;0;4;;@Override protected String getKeyword() {     return "url(". }
false;protected;3;5;;@Override protected int extractUnquotedLink(int position, String content, Set<ContentChunkInfo> result) {     // A url() function without unquoted     return extractLink(position - 1, ')', content, result). }
false;public;0;3;;public int getStart() {     return this.start. }
false;public;0;3;;public int getEnd() {     return this.end. }
false;public;0;3;;public boolean isLink() {     return this.isLink. }
false;public;1;3;;public String getContent(String fullContent) {     return fullContent.substring(this.start, this.end). }
false;public;1;4;;@Override public int compareTo(ContentChunkInfo other) {     return Integer.compare(this.start, other.start). }
false;public;1;11;;@Override public boolean equals(Object other) {     if (this == other) {         return true.     }     if (!(other instanceof ContentChunkInfo)) {         return false.     }     ContentChunkInfo otherCci = (ContentChunkInfo) other.     return (this.start == otherCci.start && this.end == otherCci.end). }
false;public;0;4;;@Override public int hashCode() {     return this.start * 31 + this.end. }
