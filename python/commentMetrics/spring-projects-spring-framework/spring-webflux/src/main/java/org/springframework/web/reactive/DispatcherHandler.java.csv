commented;modifiers;parameterAmount;loc;comment;code
true;public,final;0;4;/**  * Return all {@link HandlerMapping} beans detected by type in the  * {@link #setApplicationContext injected context} and also  * {@link AnnotationAwareOrderComparator#sort(List) sorted}.  * <p><strong>Note:</strong> This method may return {@code null} if invoked  * prior to {@link #setApplicationContext(ApplicationContext)}.  * @return immutable list with the configured mappings or {@code null}  */ ;/**  * Return all {@link HandlerMapping} beans detected by type in the  * {@link #setApplicationContext injected context} and also  * {@link AnnotationAwareOrderComparator#sort(List) sorted}.  * <p><strong>Note:</strong> This method may return {@code null} if invoked  * prior to {@link #setApplicationContext(ApplicationContext)}.  * @return immutable list with the configured mappings or {@code null}  */ @Nullable public final List<HandlerMapping> getHandlerMappings() {     return this.handlerMappings. }
false;public;1;4;;@Override public void setApplicationContext(ApplicationContext applicationContext) {     initStrategies(applicationContext). }
false;protected;1;20;;protected void initStrategies(ApplicationContext context) {     Map<String, HandlerMapping> mappingBeans = BeanFactoryUtils.beansOfTypeIncludingAncestors(context, HandlerMapping.class, true, false).     ArrayList<HandlerMapping> mappings = new ArrayList<>(mappingBeans.values()).     AnnotationAwareOrderComparator.sort(mappings).     this.handlerMappings = Collections.unmodifiableList(mappings).     Map<String, HandlerAdapter> adapterBeans = BeanFactoryUtils.beansOfTypeIncludingAncestors(context, HandlerAdapter.class, true, false).     this.handlerAdapters = new ArrayList<>(adapterBeans.values()).     AnnotationAwareOrderComparator.sort(this.handlerAdapters).     Map<String, HandlerResultHandler> beans = BeanFactoryUtils.beansOfTypeIncludingAncestors(context, HandlerResultHandler.class, true, false).     this.resultHandlers = new ArrayList<>(beans.values()).     AnnotationAwareOrderComparator.sort(this.resultHandlers). }
false;public;1;12;;@Override public Mono<Void> handle(ServerWebExchange exchange) {     if (this.handlerMappings == null) {         return createNotFoundError().     }     return Flux.fromIterable(this.handlerMappings).concatMap(mapping -> mapping.getHandler(exchange)).next().switchIfEmpty(createNotFoundError()).flatMap(handler -> invokeHandler(exchange, handler)).flatMap(result -> handleResult(exchange, result)). }
false;private;0;6;;private <R> Mono<R> createNotFoundError() {     return Mono.defer(() -> {         Exception ex = new ResponseStatusException(HttpStatus.NOT_FOUND, "No matching handler").         return Mono.error(ex).     }). }
false;private;2;10;;private Mono<HandlerResult> invokeHandler(ServerWebExchange exchange, Object handler) {     if (this.handlerAdapters != null) {         for (HandlerAdapter handlerAdapter : this.handlerAdapters) {             if (handlerAdapter.supports(handler)) {                 return handlerAdapter.handle(exchange, handler).             }         }     }     return Mono.error(new IllegalStateException("No HandlerAdapter: " + handler)). }
false;private;2;5;;private Mono<Void> handleResult(ServerWebExchange exchange, HandlerResult result) {     return getResultHandler(result).handleResult(exchange, result).onErrorResume(ex -> result.applyExceptionHandler(ex).flatMap(exceptionResult -> getResultHandler(exceptionResult).handleResult(exchange, exceptionResult))). }
false;private;1;10;;private HandlerResultHandler getResultHandler(HandlerResult handlerResult) {     if (this.resultHandlers != null) {         for (HandlerResultHandler resultHandler : this.resultHandlers) {             if (resultHandler.supports(handlerResult)) {                 return resultHandler.             }         }     }     throw new IllegalStateException("No HandlerResultHandler for " + handlerResult.getReturnValue()). }
