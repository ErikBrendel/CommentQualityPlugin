commented;modifiers;parameterAmount;loc;comment;code
true;private,static;1;8;/**  * Extract the error codes from the ObjectError list.  */ ;/**  * Extract the error codes from the ObjectError list.  */ private static String[] initErrorCodes(List<? extends ObjectError> objectErrors) {     String[] errorCodes = new String[objectErrors.size()].     for (int i = 0. i < objectErrors.size(). i++) {         ObjectError error = objectErrors.get(i).         errorCodes[i] = error.getCode().     }     return errorCodes. }
true;public;0;3;/**  * Return the bean and property path for which values and errors  * will be resolved (e.g. "customer.address.street").  */ ;/**  * Return the bean and property path for which values and errors  * will be resolved (e.g. "customer.address.street").  */ public String getPath() {     return this.path. }
true;public;0;4;/**  * Return a bind expression that can be used in HTML forms as input name  * for the respective field, or {@code null} if not field-specific.  * <p>Returns a bind path appropriate for resubmission, e.g. "address.street".  * Note that the complete bind path as required by the bind tag is  * "customer.address.street", if bound to a "customer" bean.  */ ;/**  * Return a bind expression that can be used in HTML forms as input name  * for the respective field, or {@code null} if not field-specific.  * <p>Returns a bind path appropriate for resubmission, e.g. "address.street".  * Note that the complete bind path as required by the bind tag is  * "customer.address.street", if bound to a "customer" bean.  */ @Nullable public String getExpression() {     return this.expression. }
true;public;0;4;/**  * Return the current value of the field, i.e. either the property value  * or a rejected update, or {@code null} if not field-specific.  * <p>This value will be an HTML-escaped String if the original value  * already was a String.  */ ;/**  * Return the current value of the field, i.e. either the property value  * or a rejected update, or {@code null} if not field-specific.  * <p>This value will be an HTML-escaped String if the original value  * already was a String.  */ @Nullable public Object getValue() {     return this.value. }
true;public;0;4;/**  * Get the '{@code Class}' type of the field. Favor this instead of  * '{@code getValue().getClass()}' since '{@code getValue()}' may  * return '{@code null}'.  */ ;/**  * Get the '{@code Class}' type of the field. Favor this instead of  * '{@code getValue().getClass()}' since '{@code getValue()}' may  * return '{@code null}'.  */ @Nullable public Class<?> getValueType() {     return this.valueType. }
true;public;0;4;/**  * Return the actual value of the field, i.e. the raw property value,  * or {@code null} if not available.  */ ;/**  * Return the actual value of the field, i.e. the raw property value,  * or {@code null} if not available.  */ @Nullable public Object getActualValue() {     return this.actualValue. }
true;public;0;10;/**  * Return a suitable display value for the field, i.e. the stringified  * value if not null, and an empty string in case of a null value.  * <p>This value will be an HTML-escaped String if the original value  * was non-null: the {@code toString} result of the original value  * will get HTML-escaped.  */ ;/**  * Return a suitable display value for the field, i.e. the stringified  * value if not null, and an empty string in case of a null value.  * <p>This value will be an HTML-escaped String if the original value  * was non-null: the {@code toString} result of the original value  * will get HTML-escaped.  */ public String getDisplayValue() {     if (this.value instanceof String) {         return (String) this.value.     }     if (this.value != null) {         return (this.htmlEscape ? HtmlUtils.htmlEscape(this.value.toString()) : this.value.toString()).     }     return "". }
true;public;0;3;/**  * Return if this status represents a field or object error.  */ ;/**  * Return if this status represents a field or object error.  */ public boolean isError() {     return (this.errorCodes.length > 0). }
true;public;0;3;/**  * Return the error codes for the field or object, if any.  * Returns an empty array instead of null if none.  */ ;/**  * Return the error codes for the field or object, if any.  * Returns an empty array instead of null if none.  */ public String[] getErrorCodes() {     return this.errorCodes. }
true;public;0;3;/**  * Return the first error codes for the field or object, if any.  */ ;/**  * Return the first error codes for the field or object, if any.  */ public String getErrorCode() {     return (!ObjectUtils.isEmpty(this.errorCodes) ? this.errorCodes[0] : ""). }
true;public;0;3;/**  * Return the resolved error messages for the field or object,  * if any. Returns an empty array instead of null if none.  */ ;/**  * Return the resolved error messages for the field or object,  * if any. Returns an empty array instead of null if none.  */ public String[] getErrorMessages() {     return initErrorMessages(). }
true;public;0;4;/**  * Return the first error message for the field or object, if any.  */ ;/**  * Return the first error message for the field or object, if any.  */ public String getErrorMessage() {     String[] errorMessages = initErrorMessages().     return (errorMessages.length > 0 ? errorMessages[0] : ""). }
true;public;1;3;/**  * Return an error message string, concatenating all messages  * separated by the given delimiter.  * @param delimiter separator string, e.g. ", " or "<br>"  * @return the error message string  */ ;/**  * Return an error message string, concatenating all messages  * separated by the given delimiter.  * @param delimiter separator string, e.g. ", " or "<br>"  * @return the error message string  */ public String getErrorMessagesAsString(String delimiter) {     return StringUtils.arrayToDelimitedString(initErrorMessages(), delimiter). }
true;private;0;15;/**  * Extract the error messages from the ObjectError list.  */ ;/**  * Extract the error messages from the ObjectError list.  */ private String[] initErrorMessages() throws NoSuchMessageException {     if (this.errorMessages == null) {         if (this.objectErrors != null) {             this.errorMessages = new String[this.objectErrors.size()].             for (int i = 0. i < this.objectErrors.size(). i++) {                 ObjectError error = this.objectErrors.get(i).                 this.errorMessages[i] = this.requestContext.getMessage(error, this.htmlEscape).             }         } else {             this.errorMessages = new String[0].         }     }     return this.errorMessages. }
true;public;0;4;/**  * Return the Errors instance (typically a BindingResult) that this  * bind status is currently associated with.  * @return the current Errors instance, or {@code null} if none  * @see org.springframework.validation.BindingResult  */ ;/**  * Return the Errors instance (typically a BindingResult) that this  * bind status is currently associated with.  * @return the current Errors instance, or {@code null} if none  * @see org.springframework.validation.BindingResult  */ @Nullable public Errors getErrors() {     return this.errors. }
true;public;0;4;/**  * Return the PropertyEditor for the property that this bind status  * is currently bound to.  * @return the current PropertyEditor, or {@code null} if none  */ ;/**  * Return the PropertyEditor for the property that this bind status  * is currently bound to.  * @return the current PropertyEditor, or {@code null} if none  */ @Nullable public PropertyEditor getEditor() {     return this.editor. }
true;public;1;5;/**  * Find a PropertyEditor for the given value class, associated with  * the property that this bound status is currently bound to.  * @param valueClass the value class that an editor is needed for  * @return the associated PropertyEditor, or {@code null} if none  */ ;/**  * Find a PropertyEditor for the given value class, associated with  * the property that this bound status is currently bound to.  * @param valueClass the value class that an editor is needed for  * @return the associated PropertyEditor, or {@code null} if none  */ @Nullable public PropertyEditor findEditor(Class<?> valueClass) {     return (this.bindingResult != null ? this.bindingResult.findEditor(this.expression, valueClass) : null). }
false;public;0;10;;@Override public String toString() {     StringBuilder sb = new StringBuilder("BindStatus: ").     sb.append("expression=[").append(this.expression).append("]. ").     sb.append("value=[").append(this.value).append("]").     if (!ObjectUtils.isEmpty(this.errorCodes)) {         sb.append(". errorCodes=").append(Arrays.asList(this.errorCodes)).     }     return sb.toString(). }
