commented;modifiers;parameterAmount;loc;comment;code
true;public,static;0;3;/**  * Return a {@code RequestPredicate} that always matches.  * @return a predicate that always matches  */ ;/**  * Return a {@code RequestPredicate} that always matches.  * @return a predicate that always matches  */ public static RequestPredicate all() {     return request -> true. }
true;public,static;1;3;/**  * Return a {@code RequestPredicate} that matches if the request's  * HTTP method is equal to the given method.  * @param httpMethod the HTTP method to match against  * @return a predicate that tests against the given HTTP method  */ ;/**  * Return a {@code RequestPredicate} that matches if the request's  * HTTP method is equal to the given method.  * @param httpMethod the HTTP method to match against  * @return a predicate that tests against the given HTTP method  */ public static RequestPredicate method(HttpMethod httpMethod) {     return new HttpMethodPredicate(httpMethod). }
true;public,static;1;3;/**  * Return a {@code RequestPredicate} that matches if the request's  * HTTP method is equal to one the of the given methods.  * @param httpMethods the HTTP methods to match against  * @return a predicate that tests against the given HTTP methods  * @since 5.1  */ ;/**  * Return a {@code RequestPredicate} that matches if the request's  * HTTP method is equal to one the of the given methods.  * @param httpMethods the HTTP methods to match against  * @return a predicate that tests against the given HTTP methods  * @since 5.1  */ public static RequestPredicate methods(HttpMethod... httpMethods) {     return new HttpMethodPredicate(httpMethods). }
true;public,static;1;4;/**  * Return a {@code RequestPredicate} that tests the request path  * against the given path pattern.  * @param pattern the pattern to match to  * @return a predicate that tests against the given path pattern  */ ;/**  * Return a {@code RequestPredicate} that tests the request path  * against the given path pattern.  * @param pattern the pattern to match to  * @return a predicate that tests against the given path pattern  */ public static RequestPredicate path(String pattern) {     Assert.notNull(pattern, "'pattern' must not be null").     return pathPredicates(DEFAULT_PATTERN_PARSER).apply(pattern). }
true;public,static;1;4;/**  * Return a function that creates new path-matching {@code RequestPredicates}  * from pattern Strings using the given {@link PathPatternParser}.  * <p>This method can be used to specify a non-default, customized  * {@code PathPatternParser} when resolving path patterns.  * @param patternParser the parser used to parse patterns given to the returned function  * @return a function that resolves a pattern String into a path-matching  * {@code RequestPredicates} instance  */ ;/**  * Return a function that creates new path-matching {@code RequestPredicates}  * from pattern Strings using the given {@link PathPatternParser}.  * <p>This method can be used to specify a non-default, customized  * {@code PathPatternParser} when resolving path patterns.  * @param patternParser the parser used to parse patterns given to the returned function  * @return a function that resolves a pattern String into a path-matching  * {@code RequestPredicates} instance  */ public static Function<String, RequestPredicate> pathPredicates(PathPatternParser patternParser) {     Assert.notNull(patternParser, "PathPatternParser must not be null").     return pattern -> new PathPatternPredicate(patternParser.parse(pattern)). }
true;public,static;1;3;/**  * Return a {@code RequestPredicate} that tests the request's headers  * against the given headers predicate.  * @param headersPredicate a predicate that tests against the request headers  * @return a predicate that tests against the given header predicate  */ ;/**  * Return a {@code RequestPredicate} that tests the request's headers  * against the given headers predicate.  * @param headersPredicate a predicate that tests against the request headers  * @return a predicate that tests against the given header predicate  */ public static RequestPredicate headers(Predicate<ServerRequest.Headers> headersPredicate) {     return new HeadersPredicate(headersPredicate). }
true;public,static;1;4;/**  * Return a {@code RequestPredicate} that tests if the request's  * {@linkplain ServerRequest.Headers#contentType() content type} is  * {@linkplain MediaType#includes(MediaType) included} by any of the given media types.  * @param mediaTypes the media types to match the request's content type against  * @return a predicate that tests the request's content type against the given media types  */ ;/**  * Return a {@code RequestPredicate} that tests if the request's  * {@linkplain ServerRequest.Headers#contentType() content type} is  * {@linkplain MediaType#includes(MediaType) included} by any of the given media types.  * @param mediaTypes the media types to match the request's content type against  * @return a predicate that tests the request's content type against the given media types  */ public static RequestPredicate contentType(MediaType... mediaTypes) {     Assert.notEmpty(mediaTypes, "'mediaTypes' must not be empty").     return new ContentTypePredicate(mediaTypes). }
true;public,static;1;4;/**  * Return a {@code RequestPredicate} that tests if the request's  * {@linkplain ServerRequest.Headers#accept() accept} header is  * {@linkplain MediaType#isCompatibleWith(MediaType) compatible} with any of the given media types.  * @param mediaTypes the media types to match the request's accept header against  * @return a predicate that tests the request's accept header against the given media types  */ ;/**  * Return a {@code RequestPredicate} that tests if the request's  * {@linkplain ServerRequest.Headers#accept() accept} header is  * {@linkplain MediaType#isCompatibleWith(MediaType) compatible} with any of the given media types.  * @param mediaTypes the media types to match the request's accept header against  * @return a predicate that tests the request's accept header against the given media types  */ public static RequestPredicate accept(MediaType... mediaTypes) {     Assert.notEmpty(mediaTypes, "'mediaTypes' must not be empty").     return new AcceptPredicate(mediaTypes). }
true;public,static;1;3;/**  * Return a {@code RequestPredicate} that matches if request's HTTP method is {@code GET}  * and the given {@code pattern} matches against the request path.  * @param pattern the path pattern to match against  * @return a predicate that matches if the request method is GET and if the given pattern  * matches against the request path  */ ;/**  * Return a {@code RequestPredicate} that matches if request's HTTP method is {@code GET}  * and the given {@code pattern} matches against the request path.  * @param pattern the path pattern to match against  * @return a predicate that matches if the request method is GET and if the given pattern  * matches against the request path  */ public static RequestPredicate GET(String pattern) {     return method(HttpMethod.GET).and(path(pattern)). }
true;public,static;1;3;/**  * Return a {@code RequestPredicate} that matches if request's HTTP method is {@code HEAD}  * and the given {@code pattern} matches against the request path.  * @param pattern the path pattern to match against  * @return a predicate that matches if the request method is HEAD and if the given pattern  * matches against the request path  */ ;/**  * Return a {@code RequestPredicate} that matches if request's HTTP method is {@code HEAD}  * and the given {@code pattern} matches against the request path.  * @param pattern the path pattern to match against  * @return a predicate that matches if the request method is HEAD and if the given pattern  * matches against the request path  */ public static RequestPredicate HEAD(String pattern) {     return method(HttpMethod.HEAD).and(path(pattern)). }
true;public,static;1;3;/**  * Return a {@code RequestPredicate} that matches if request's HTTP method is {@code POST}  * and the given {@code pattern} matches against the request path.  * @param pattern the path pattern to match against  * @return a predicate that matches if the request method is POST and if the given pattern  * matches against the request path  */ ;/**  * Return a {@code RequestPredicate} that matches if request's HTTP method is {@code POST}  * and the given {@code pattern} matches against the request path.  * @param pattern the path pattern to match against  * @return a predicate that matches if the request method is POST and if the given pattern  * matches against the request path  */ public static RequestPredicate POST(String pattern) {     return method(HttpMethod.POST).and(path(pattern)). }
true;public,static;1;3;/**  * Return a {@code RequestPredicate} that matches if request's HTTP method is {@code PUT}  * and the given {@code pattern} matches against the request path.  * @param pattern the path pattern to match against  * @return a predicate that matches if the request method is PUT and if the given pattern  * matches against the request path  */ ;/**  * Return a {@code RequestPredicate} that matches if request's HTTP method is {@code PUT}  * and the given {@code pattern} matches against the request path.  * @param pattern the path pattern to match against  * @return a predicate that matches if the request method is PUT and if the given pattern  * matches against the request path  */ public static RequestPredicate PUT(String pattern) {     return method(HttpMethod.PUT).and(path(pattern)). }
true;public,static;1;3;/**  * Return a {@code RequestPredicate} that matches if request's HTTP method is {@code PATCH}  * and the given {@code pattern} matches against the request path.  * @param pattern the path pattern to match against  * @return a predicate that matches if the request method is PATCH and if the given pattern  * matches against the request path  */ ;/**  * Return a {@code RequestPredicate} that matches if request's HTTP method is {@code PATCH}  * and the given {@code pattern} matches against the request path.  * @param pattern the path pattern to match against  * @return a predicate that matches if the request method is PATCH and if the given pattern  * matches against the request path  */ public static RequestPredicate PATCH(String pattern) {     return method(HttpMethod.PATCH).and(path(pattern)). }
true;public,static;1;3;/**  * Return a {@code RequestPredicate} that matches if request's HTTP method is {@code DELETE}  * and the given {@code pattern} matches against the request path.  * @param pattern the path pattern to match against  * @return a predicate that matches if the request method is DELETE and if the given pattern  * matches against the request path  */ ;/**  * Return a {@code RequestPredicate} that matches if request's HTTP method is {@code DELETE}  * and the given {@code pattern} matches against the request path.  * @param pattern the path pattern to match against  * @return a predicate that matches if the request method is DELETE and if the given pattern  * matches against the request path  */ public static RequestPredicate DELETE(String pattern) {     return method(HttpMethod.DELETE).and(path(pattern)). }
true;public,static;1;3;/**  * Return a {@code RequestPredicate} that matches if request's HTTP method is {@code OPTIONS}  * and the given {@code pattern} matches against the request path.  * @param pattern the path pattern to match against  * @return a predicate that matches if the request method is OPTIONS and if the given pattern  * matches against the request path  */ ;/**  * Return a {@code RequestPredicate} that matches if request's HTTP method is {@code OPTIONS}  * and the given {@code pattern} matches against the request path.  * @param pattern the path pattern to match against  * @return a predicate that matches if the request method is OPTIONS and if the given pattern  * matches against the request path  */ public static RequestPredicate OPTIONS(String pattern) {     return method(HttpMethod.OPTIONS).and(path(pattern)). }
true;public,static;1;4;/**  * Return a {@code RequestPredicate} that matches if the request's path has the given extension.  * @param extension the path extension to match against, ignoring case  * @return a predicate that matches if the request's path has the given file extension  */ ;/**  * Return a {@code RequestPredicate} that matches if the request's path has the given extension.  * @param extension the path extension to match against, ignoring case  * @return a predicate that matches if the request's path has the given file extension  */ public static RequestPredicate pathExtension(String extension) {     Assert.notNull(extension, "'extension' must not be null").     return new PathExtensionPredicate(extension). }
true;public,static;1;3;/**  * Return a {@code RequestPredicate} that matches if the request's path matches the given  * predicate.  * @param extensionPredicate the predicate to test against the request path extension  * @return a predicate that matches if the given predicate matches against the request's path  * file extension  */ ;/**  * Return a {@code RequestPredicate} that matches if the request's path matches the given  * predicate.  * @param extensionPredicate the predicate to test against the request path extension  * @return a predicate that matches if the given predicate matches against the request's path  * file extension  */ public static RequestPredicate pathExtension(Predicate<String> extensionPredicate) {     return new PathExtensionPredicate(extensionPredicate). }
true;public,static;2;3;/**  * Return a {@code RequestPredicate} that matches if the request's query parameter of the given name  * has the given value.  * @param name the name of the query parameter to test against  * @param value the value of the query parameter to test against  * @return a predicate that matches if the query parameter has the given value  * @since 5.0.7  * @see ServerRequest#queryParam(String)  */ ;/**  * Return a {@code RequestPredicate} that matches if the request's query parameter of the given name  * has the given value.  * @param name the name of the query parameter to test against  * @param value the value of the query parameter to test against  * @return a predicate that matches if the query parameter has the given value  * @since 5.0.7  * @see ServerRequest#queryParam(String)  */ public static RequestPredicate queryParam(String name, String value) {     return new QueryParamPredicate(name, value). }
true;public,static;2;3;/**  * Return a {@code RequestPredicate} that tests the request's query parameter of the given name  * against the given predicate.  * @param name the name of the query parameter to test against  * @param predicate predicate to test against the query parameter value  * @return a predicate that matches the given predicate against the query parameter of the given name  * @see ServerRequest#queryParam(String)  */ ;/**  * Return a {@code RequestPredicate} that tests the request's query parameter of the given name  * against the given predicate.  * @param name the name of the query parameter to test against  * @param predicate predicate to test against the query parameter value  * @return a predicate that matches the given predicate against the query parameter of the given name  * @see ServerRequest#queryParam(String)  */ public static RequestPredicate queryParam(String name, Predicate<String> predicate) {     return new QueryParamPredicate(name, predicate). }
false;private,static;4;6;;private static void traceMatch(String prefix, Object desired, @Nullable Object actual, boolean match) {     if (logger.isTraceEnabled()) {         logger.trace(String.format("%s \"%s\" %s against value \"%s\"", prefix, desired, match ? "matches" : "does not match", actual)).     } }
false;private,static;2;4;;private static void restoreAttributes(ServerRequest request, Map<String, Object> attributes) {     request.attributes().clear().     request.attributes().putAll(attributes). }
false;private,static;2;12;;private static Map<String, String> mergePathVariables(Map<String, String> oldVariables, Map<String, String> newVariables) {     if (!newVariables.isEmpty()) {         Map<String, String> mergedVariables = new LinkedHashMap<>(oldVariables).         mergedVariables.putAll(newVariables).         return mergedVariables.     } else {         return oldVariables.     } }
false;private,static;2;9;;private static PathPattern mergePatterns(@Nullable PathPattern oldPattern, PathPattern newPattern) {     if (oldPattern != null) {         return oldPattern.combine(newPattern).     } else {         return newPattern.     } }
true;;1;1;/**  * Receive notification of an HTTP method predicate.  * @param methods the HTTP methods that make up the predicate  * @see RequestPredicates#method(HttpMethod)  */ ;/**  * Receive notification of an HTTP method predicate.  * @param methods the HTTP methods that make up the predicate  * @see RequestPredicates#method(HttpMethod)  */ void method(Set<HttpMethod> methods).
true;;1;1;/**  * Receive notification of an path predicate.  * @param pattern the path pattern that makes up the predicate  * @see RequestPredicates#path(String)  */ ;/**  * Receive notification of an path predicate.  * @param pattern the path pattern that makes up the predicate  * @see RequestPredicates#path(String)  */ void path(String pattern).
true;;1;1;/**  * Receive notification of an path extension predicate.  * @param extension the path extension that makes up the predicate  * @see RequestPredicates#pathExtension(String)  */ ;/**  * Receive notification of an path extension predicate.  * @param extension the path extension that makes up the predicate  * @see RequestPredicates#pathExtension(String)  */ void pathExtension(String extension).
true;;2;1;/**  * Receive notification of a HTTP header predicate.  * @param name the name of the HTTP header to check  * @param value the desired value of the HTTP header  * @see RequestPredicates#headers(Predicate)  * @see RequestPredicates#contentType(MediaType...)  * @see RequestPredicates#accept(MediaType...)  */ ;/**  * Receive notification of a HTTP header predicate.  * @param name the name of the HTTP header to check  * @param value the desired value of the HTTP header  * @see RequestPredicates#headers(Predicate)  * @see RequestPredicates#contentType(MediaType...)  * @see RequestPredicates#accept(MediaType...)  */ void header(String name, String value).
true;;2;1;/**  * Receive notification of a query parameter predicate.  * @param name the name of the query parameter  * @param value the desired value of the parameter  * @see RequestPredicates#queryParam(String, String)  */ ;/**  * Receive notification of a query parameter predicate.  * @param name the name of the query parameter  * @param value the desired value of the parameter  * @see RequestPredicates#queryParam(String, String)  */ void queryParam(String name, String value).
true;;0;1;/**  * Receive first notification of a logical AND predicate.  * The first subsequent notification will contain the left-hand side of the AND-predicate.  * followed by {@link #and()}, followed by the right-hand side, followed by {@link #endAnd()}.  * @see RequestPredicate#and(RequestPredicate)  */ ;/**  * Receive first notification of a logical AND predicate.  * The first subsequent notification will contain the left-hand side of the AND-predicate.  * followed by {@link #and()}, followed by the right-hand side, followed by {@link #endAnd()}.  * @see RequestPredicate#and(RequestPredicate)  */ void startAnd().
true;;0;1;/**  * Receive "middle" notification of a logical AND predicate.  * The following notification contains the right-hand side, followed by {@link #endAnd()}.  * @see RequestPredicate#and(RequestPredicate)  */ ;/**  * Receive "middle" notification of a logical AND predicate.  * The following notification contains the right-hand side, followed by {@link #endAnd()}.  * @see RequestPredicate#and(RequestPredicate)  */ void and().
true;;0;1;/**  * Receive last notification of a logical AND predicate.  * @see RequestPredicate#and(RequestPredicate)  */ ;/**  * Receive last notification of a logical AND predicate.  * @see RequestPredicate#and(RequestPredicate)  */ void endAnd().
true;;0;1;/**  * Receive first notification of a logical OR predicate.  * The first subsequent notification will contain the left-hand side of the OR-predicate.  * the second notification contains the right-hand side, followed by {@link #endOr()}.  * @see RequestPredicate#or(RequestPredicate)  */ ;/**  * Receive first notification of a logical OR predicate.  * The first subsequent notification will contain the left-hand side of the OR-predicate.  * the second notification contains the right-hand side, followed by {@link #endOr()}.  * @see RequestPredicate#or(RequestPredicate)  */ void startOr().
true;;0;1;/**  * Receive "middle" notification of a logical OR predicate.  * The following notification contains the right-hand side, followed by {@link #endOr()}.  * @see RequestPredicate#or(RequestPredicate)  */ ;/**  * Receive "middle" notification of a logical OR predicate.  * The following notification contains the right-hand side, followed by {@link #endOr()}.  * @see RequestPredicate#or(RequestPredicate)  */ void or().
true;;0;1;/**  * Receive last notification of a logical OR predicate.  * @see RequestPredicate#or(RequestPredicate)  */ ;/**  * Receive last notification of a logical OR predicate.  * @see RequestPredicate#or(RequestPredicate)  */ void endOr().
true;;0;1;/**  * Receive first notification of a negated predicate.  * The first subsequent notification will contain the negated predicated, followed  * by {@link #endNegate()}.  * @see RequestPredicate#negate()  */ ;/**  * Receive first notification of a negated predicate.  * The first subsequent notification will contain the negated predicated, followed  * by {@link #endNegate()}.  * @see RequestPredicate#negate()  */ void startNegate().
true;;0;1;/**  * Receive last notification of a negated predicate.  * @see RequestPredicate#negate()  */ ;/**  * Receive last notification of a negated predicate.  * @see RequestPredicate#negate()  */ void endNegate().
true;;1;1;/**  * Receive first notification of an unknown predicate.  */ ;/**  * Receive first notification of an unknown predicate.  */ void unknown(RequestPredicate predicate).
false;public;1;6;;@Override public boolean test(ServerRequest request) {     boolean match = this.httpMethods.contains(request.method()).     traceMatch("Method", this.httpMethods, request.method(), match).     return match. }
false;public;1;4;;@Override public void accept(Visitor visitor) {     visitor.method(Collections.unmodifiableSet(this.httpMethods)). }
false;public;0;9;;@Override public String toString() {     if (this.httpMethods.size() == 1) {         return this.httpMethods.iterator().next().toString().     } else {         return this.httpMethods.toString().     } }
false;public;1;13;;@Override public boolean test(ServerRequest request) {     PathContainer pathContainer = request.pathContainer().     PathPattern.PathMatchInfo info = this.pattern.matchAndExtract(pathContainer).     traceMatch("Pattern", this.pattern.getPatternString(), request.path(), info != null).     if (info != null) {         mergeAttributes(request, info.getUriVariables(), this.pattern).         return true.     } else {         return false.     } }
false;private,static;3;11;;private static void mergeAttributes(ServerRequest request, Map<String, String> variables, PathPattern pattern) {     Map<String, String> pathVariables = mergePathVariables(request.pathVariables(), variables).     request.attributes().put(RouterFunctions.URI_TEMPLATE_VARIABLES_ATTRIBUTE, Collections.unmodifiableMap(pathVariables)).     pattern = mergePatterns((PathPattern) request.attributes().get(RouterFunctions.MATCHING_PATTERN_ATTRIBUTE), pattern).     request.attributes().put(RouterFunctions.MATCHING_PATTERN_ATTRIBUTE, pattern). }
false;public;1;5;;@Override public Optional<ServerRequest> nest(ServerRequest request) {     return Optional.ofNullable(this.pattern.matchStartOfPath(request.pathContainer())).map(info -> new SubPathServerRequestWrapper(request, info, this.pattern)). }
false;public;1;4;;@Override public void accept(Visitor visitor) {     visitor.path(this.pattern.getPatternString()). }
false;public;0;4;;@Override public String toString() {     return this.pattern.getPatternString(). }
false;public;1;4;;@Override public boolean test(ServerRequest request) {     return this.headersPredicate.test(request.headers()). }
false;public;0;4;;@Override public String toString() {     return this.headersPredicate.toString(). }
false;public;1;7;;@Override public void accept(Visitor visitor) {     visitor.header(HttpHeaders.CONTENT_TYPE, (this.mediaTypes.size() == 1) ? this.mediaTypes.iterator().next().toString() : this.mediaTypes.toString()). }
false;public;0;7;;@Override public String toString() {     return String.format("Content-Type: %s", (this.mediaTypes.size() == 1) ? this.mediaTypes.iterator().next().toString() : this.mediaTypes.toString()). }
false;private,static;1;11;;@NonNull private static List<MediaType> acceptedMediaTypes(ServerRequest.Headers headers) {     List<MediaType> acceptedMediaTypes = headers.accept().     if (acceptedMediaTypes.isEmpty()) {         acceptedMediaTypes = Collections.singletonList(MediaType.ALL).     } else {         MediaType.sortBySpecificityAndQuality(acceptedMediaTypes).     }     return acceptedMediaTypes. }
false;public;1;7;;@Override public void accept(Visitor visitor) {     visitor.header(HttpHeaders.ACCEPT, (this.mediaTypes.size() == 1) ? this.mediaTypes.iterator().next().toString() : this.mediaTypes.toString()). }
false;public;0;7;;@Override public String toString() {     return String.format("Accept: %s", (this.mediaTypes.size() == 1) ? this.mediaTypes.iterator().next().toString() : this.mediaTypes.toString()). }
false;public;1;5;;@Override public boolean test(ServerRequest request) {     String pathExtension = UriUtils.extractFileExtension(request.path()).     return this.extensionPredicate.test(pathExtension). }
false;public;1;7;;@Override public void accept(Visitor visitor) {     visitor.pathExtension((this.extension != null) ? this.extension : this.extensionPredicate.toString()). }
false;public;0;7;;@Override public String toString() {     return String.format("*.%s", (this.extension != null) ? this.extension : this.extensionPredicate). }
false;public;1;5;;@Override public boolean test(ServerRequest request) {     Optional<String> s = request.queryParam(this.name).     return s.filter(this.valuePredicate).isPresent(). }
false;public;1;7;;@Override public void accept(Visitor visitor) {     visitor.queryParam(this.name, (this.value != null) ? this.value : this.valuePredicate.toString()). }
false;public;0;7;;@Override public String toString() {     return String.format("?%s %s", this.name, (this.value != null) ? this.value : this.valuePredicate). }
false;public;1;10;;@Override public boolean test(ServerRequest request) {     Map<String, Object> oldAttributes = new HashMap<>(request.attributes()).     if (this.left.test(request) && this.right.test(request)) {         return true.     }     restoreAttributes(request, oldAttributes).     return false. }
false;public;1;4;;@Override public Optional<ServerRequest> nest(ServerRequest request) {     return this.left.nest(request).flatMap(this.right::nest). }
false;public;1;8;;@Override public void accept(Visitor visitor) {     visitor.startAnd().     this.left.accept(visitor).     visitor.and().     this.right.accept(visitor).     visitor.endAnd(). }
false;public;0;4;;@Override public String toString() {     return String.format("(%s && %s)", this.left, this.right). }
false;public;1;9;;@Override public boolean test(ServerRequest request) {     Map<String, Object> oldAttributes = new HashMap<>(request.attributes()).     boolean result = !this.delegate.test(request).     if (!result) {         restoreAttributes(request, oldAttributes).     }     return result. }
false;public;1;6;;@Override public void accept(Visitor visitor) {     visitor.startNegate().     this.delegate.accept(visitor).     visitor.endNegate(). }
false;public;0;4;;@Override public String toString() {     return "!" + this.delegate.toString(). }
false;public;1;16;;@Override public boolean test(ServerRequest request) {     Map<String, Object> oldAttributes = new HashMap<>(request.attributes()).     if (this.left.test(request)) {         return true.     } else {         restoreAttributes(request, oldAttributes).         if (this.right.test(request)) {             return true.         }     }     restoreAttributes(request, oldAttributes).     return false. }
false;public;1;10;;@Override public Optional<ServerRequest> nest(ServerRequest request) {     Optional<ServerRequest> leftResult = this.left.nest(request).     if (leftResult.isPresent()) {         return leftResult.     } else {         return this.right.nest(request).     } }
false;public;1;8;;@Override public void accept(Visitor visitor) {     visitor.startOr().     this.left.accept(visitor).     visitor.or().     this.right.accept(visitor).     visitor.endOr(). }
false;public;0;4;;@Override public String toString() {     return String.format("(%s || %s)", this.left, this.right). }
false;private,static;3;13;;private static Map<String, Object> mergeAttributes(ServerRequest request, Map<String, String> pathVariables, PathPattern pattern) {     Map<String, Object> result = new ConcurrentHashMap<>(request.attributes()).     result.put(RouterFunctions.URI_TEMPLATE_VARIABLES_ATTRIBUTE, mergePathVariables(request.pathVariables(), pathVariables)).     pattern = mergePatterns((PathPattern) request.attributes().get(RouterFunctions.MATCHING_PATTERN_ATTRIBUTE), pattern).     result.put(RouterFunctions.MATCHING_PATTERN_ATTRIBUTE, pattern).     return result. }
false;public;0;4;;@Override public HttpMethod method() {     return this.request.method(). }
false;public;0;4;;@Override public String methodName() {     return this.request.methodName(). }
false;public;0;4;;@Override public URI uri() {     return this.request.uri(). }
false;public;0;4;;@Override public UriBuilder uriBuilder() {     return this.request.uriBuilder(). }
false;public;0;4;;@Override public String path() {     return this.pathContainer.value(). }
false;public;0;4;;@Override public PathContainer pathContainer() {     return this.pathContainer. }
false;public;0;4;;@Override public Headers headers() {     return this.request.headers(). }
false;public;0;4;;@Override public MultiValueMap<String, HttpCookie> cookies() {     return this.request.cookies(). }
false;public;0;4;;@Override public Optional<InetSocketAddress> remoteAddress() {     return this.request.remoteAddress(). }
false;public;0;4;;@Override public List<HttpMessageReader<?>> messageReaders() {     return this.request.messageReaders(). }
false;public;1;4;;@Override public <T> T body(BodyExtractor<T, ? super ServerHttpRequest> extractor) {     return this.request.body(extractor). }
false;public;2;4;;@Override public <T> T body(BodyExtractor<T, ? super ServerHttpRequest> extractor, Map<String, Object> hints) {     return this.request.body(extractor, hints). }
false;public;1;4;;@Override public <T> Mono<T> bodyToMono(Class<? extends T> elementClass) {     return this.request.bodyToMono(elementClass). }
false;public;1;4;;@Override public <T> Mono<T> bodyToMono(ParameterizedTypeReference<T> typeReference) {     return this.request.bodyToMono(typeReference). }
false;public;1;4;;@Override public <T> Flux<T> bodyToFlux(Class<? extends T> elementClass) {     return this.request.bodyToFlux(elementClass). }
false;public;1;4;;@Override public <T> Flux<T> bodyToFlux(ParameterizedTypeReference<T> typeReference) {     return this.request.bodyToFlux(typeReference). }
false;public;0;4;;@Override public Map<String, Object> attributes() {     return this.attributes. }
false;public;1;4;;@Override public Optional<String> queryParam(String name) {     return this.request.queryParam(name). }
false;public;0;4;;@Override public MultiValueMap<String, String> queryParams() {     return this.request.queryParams(). }
false;public;0;7;;@Override @SuppressWarnings("unchecked") public Map<String, String> pathVariables() {     return (Map<String, String>) this.attributes.getOrDefault(RouterFunctions.URI_TEMPLATE_VARIABLES_ATTRIBUTE, Collections.emptyMap()). }
false;public;0;4;;@Override public Mono<WebSession> session() {     return this.request.session(). }
false;public;0;4;;@Override public Mono<? extends Principal> principal() {     return this.request.principal(). }
false;public;0;4;;@Override public Mono<MultiValueMap<String, String>> formData() {     return this.request.formData(). }
false;public;0;4;;@Override public Mono<MultiValueMap<String, Part>> multipartData() {     return this.request.multipartData(). }
false;public;0;4;;@Override public ServerWebExchange exchange() {     return this.request.exchange(). }
false;public;0;4;;@Override public String toString() {     return method() + " " + path(). }
false;private,static;1;6;;private static String prefixWithSlash(String path) {     if (!path.startsWith("/")) {         path = "/" + path.     }     return path. }
false;private,static;1;7;;private static List<Element> prependWithSeparator(List<Element> elements) {     List<Element> result = new ArrayList<>(elements).     if (result.isEmpty() || !(result.get(0) instanceof Separator)) {         result.add(0, SEPARATOR).     }     return Collections.unmodifiableList(result). }
false;public;0;4;;@Override public String value() {     return this.value. }
false;public;0;4;;@Override public List<Element> elements() {     return this.elements. }
