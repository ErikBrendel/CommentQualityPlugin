commented;modifiers;parameterAmount;loc;comment;code
true;public;1;3;/**  * Whether to interpret a given redirect URLs that starts with a slash ("/")  * as relative to the current context path ({@code true}, the default) or to  * the web server root ({@code false}).  */ ;/**  * Whether to interpret a given redirect URLs that starts with a slash ("/")  * as relative to the current context path ({@code true}, the default) or to  * the web server root ({@code false}).  */ public void setContextRelative(boolean contextRelative) {     this.contextRelative = contextRelative. }
true;public;0;3;/**  * Whether to interpret URLs as relative to the current context path.  */ ;/**  * Whether to interpret URLs as relative to the current context path.  */ public boolean isContextRelative() {     return this.contextRelative. }
true;public;1;4;/**  * Set an alternate redirect status code such as  * {@link HttpStatus#TEMPORARY_REDIRECT} or  * {@link HttpStatus#PERMANENT_REDIRECT}.  */ ;/**  * Set an alternate redirect status code such as  * {@link HttpStatus#TEMPORARY_REDIRECT} or  * {@link HttpStatus#PERMANENT_REDIRECT}.  */ public void setStatusCode(HttpStatus statusCode) {     Assert.isTrue(statusCode.is3xxRedirection(), "Not a redirect status code").     this.statusCode = statusCode. }
true;public;0;3;/**  * Get the redirect status code to use.  */ ;/**  * Get the redirect status code to use.  */ public HttpStatus getStatusCode() {     return this.statusCode. }
true;public;1;3;/**  * Whether to append the query string of the current URL to the redirect URL  * ({@code true}) or not ({@code false}, the default).  */ ;/**  * Whether to append the query string of the current URL to the redirect URL  * ({@code true}) or not ({@code false}, the default).  */ public void setPropagateQuery(boolean propagateQuery) {     this.propagateQuery = propagateQuery. }
true;public;0;3;/**  * Whether the query string of the current URL is appended to the redirect URL.  */ ;/**  * Whether the query string of the current URL is appended to the redirect URL.  */ public boolean isPropagateQuery() {     return this.propagateQuery. }
true;public;1;3;/**  * Configure one or more hosts associated with the application.  * All other hosts will be considered external hosts.  * <p>In effect this provides a way turn off encoding for URLs that  * have a host and that host is not listed as a known host.  * <p>If not set (the default) all redirect URLs are encoded.  * @param hosts one or more application hosts  */ ;/**  * Configure one or more hosts associated with the application.  * All other hosts will be considered external hosts.  * <p>In effect this provides a way turn off encoding for URLs that  * have a host and that host is not listed as a known host.  * <p>If not set (the default) all redirect URLs are encoded.  * @param hosts one or more application hosts  */ public void setHosts(@Nullable String... hosts) {     this.hosts = hosts. }
true;public;0;4;/**  * Return the configured application hosts.  */ ;/**  * Return the configured application hosts.  */ @Nullable public String[] getHosts() {     return this.hosts. }
false;public;0;4;;@Override public void afterPropertiesSet() throws Exception {     super.afterPropertiesSet(). }
false;public;0;4;;@Override public boolean isRedirectView() {     return true. }
false;public;1;4;;@Override public boolean checkResourceExists(Locale locale) throws Exception {     return true. }
true;protected;3;7;/**  * Convert model to request parameters and redirect to the given URL.  */ ;/**  * Convert model to request parameters and redirect to the given URL.  */ @Override protected Mono<Void> renderInternal(Map<String, Object> model, @Nullable MediaType contentType, ServerWebExchange exchange) {     String targetUrl = createTargetUrl(model, exchange).     return sendRedirect(targetUrl, exchange). }
true;protected,final;2;26;/**  * Create the target URL and, if necessary, pre-pend the contextPath, expand  * URI template variables, append the current request query, and apply the  * configured {@link #getRequestDataValueProcessor()  * RequestDataValueProcessor}.  */ ;/**  * Create the target URL and, if necessary, pre-pend the contextPath, expand  * URI template variables, append the current request query, and apply the  * configured {@link #getRequestDataValueProcessor()  * RequestDataValueProcessor}.  */ protected final String createTargetUrl(Map<String, Object> model, ServerWebExchange exchange) {     String url = getUrl().     Assert.state(url != null, "'url' not set").     ServerHttpRequest request = exchange.getRequest().     StringBuilder targetUrl = new StringBuilder().     if (isContextRelative() && url.startsWith("/")) {         targetUrl.append(request.getPath().contextPath().value()).     }     targetUrl.append(url).     if (StringUtils.hasText(targetUrl)) {         Map<String, String> uriVars = getCurrentUriVariables(exchange).         targetUrl = expandTargetUrlTemplate(targetUrl.toString(), model, uriVars).     }     if (isPropagateQuery()) {         targetUrl = appendCurrentRequestQuery(targetUrl.toString(), request).     }     String result = targetUrl.toString().     RequestDataValueProcessor processor = getRequestDataValueProcessor().     return (processor != null ? processor.processUrl(exchange, result) : result). }
false;private;1;5;;@SuppressWarnings("unchecked") private Map<String, String> getCurrentUriVariables(ServerWebExchange exchange) {     String name = HandlerMapping.URI_TEMPLATE_VARIABLES_ATTRIBUTE.     return exchange.getAttributeOrDefault(name, Collections.<String, String>emptyMap()). }
true;protected;3;22;/**  * Expand URI template variables in the target URL with either model  * attribute values or as a fallback with URI variable values from the  * current request. Values are encoded.  */ ;/**  * Expand URI template variables in the target URL with either model  * attribute values or as a fallback with URI variable values from the  * current request. Values are encoded.  */ protected StringBuilder expandTargetUrlTemplate(String targetUrl, Map<String, Object> model, Map<String, String> uriVariables) {     Matcher matcher = URI_TEMPLATE_VARIABLE_PATTERN.matcher(targetUrl).     boolean found = matcher.find().     if (!found) {         return new StringBuilder(targetUrl).     }     StringBuilder result = new StringBuilder().     int endLastMatch = 0.     while (found) {         String name = matcher.group(1).         Object value = (model.containsKey(name) ? model.get(name) : uriVariables.get(name)).         Assert.notNull(value, () -> "No value for URI variable '" + name + "'").         result.append(targetUrl.substring(endLastMatch, matcher.start())).         result.append(encodeUriVariable(value.toString())).         endLastMatch = matcher.end().         found = matcher.find().     }     result.append(targetUrl.substring(endLastMatch, targetUrl.length())).     return result. }
false;private;1;4;;private String encodeUriVariable(String text) {     // Strict encoding of all reserved URI characters     return UriUtils.encode(text, StandardCharsets.UTF_8). }
true;protected;2;19;/**  * Append the query of the current request to the target redirect URL.  */ ;/**  * Append the query of the current request to the target redirect URL.  */ protected StringBuilder appendCurrentRequestQuery(String targetUrl, ServerHttpRequest request) {     String query = request.getURI().getRawQuery().     if (!StringUtils.hasText(query)) {         return new StringBuilder(targetUrl).     }     int index = targetUrl.indexOf('#').     String fragment = (index > -1 ? targetUrl.substring(index) : null).     StringBuilder result = new StringBuilder().     result.append(index != -1 ? targetUrl.substring(0, index) : targetUrl).     result.append(targetUrl.indexOf('?') < 0 ? '?' : '&').append(query).     if (fragment != null) {         result.append(fragment).     }     return result. }
true;protected;2;7;/**  * Send a redirect back to the HTTP client.  * @param targetUrl the target URL to redirect to  * @param exchange current exchange  */ ;/**  * Send a redirect back to the HTTP client.  * @param targetUrl the target URL to redirect to  * @param exchange current exchange  */ protected Mono<Void> sendRedirect(String targetUrl, ServerWebExchange exchange) {     String transformedUrl = (isRemoteHost(targetUrl) ? targetUrl : exchange.transformUrl(targetUrl)).     ServerHttpResponse response = exchange.getResponse().     response.getHeaders().setLocation(URI.create(transformedUrl)).     response.setStatusCode(getStatusCode()).     return Mono.empty(). }
true;protected;1;15;/**  * Whether the given targetUrl has a host that is a "foreign" system in which  * case {@link javax.servlet.http.HttpServletResponse#encodeRedirectURL} will not be applied.  * This method returns {@code true} if the {@link #setHosts(String[])}  * property is configured and the target URL has a host that does not match.  * @param targetUrl the target redirect URL  * @return {@code true} the target URL has a remote host, {@code false} if it  * the URL does not have a host or the "host" property is not configured.  */ ;/**  * Whether the given targetUrl has a host that is a "foreign" system in which  * case {@link javax.servlet.http.HttpServletResponse#encodeRedirectURL} will not be applied.  * This method returns {@code true} if the {@link #setHosts(String[])}  * property is configured and the target URL has a host that does not match.  * @param targetUrl the target redirect URL  * @return {@code true} the target URL has a remote host, {@code false} if it  * the URL does not have a host or the "host" property is not configured.  */ protected boolean isRemoteHost(String targetUrl) {     if (ObjectUtils.isEmpty(this.hosts)) {         return false.     }     String targetHost = UriComponentsBuilder.fromUriString(targetUrl).build().getHost().     if (StringUtils.isEmpty(targetHost)) {         return false.     }     for (String host : this.hosts) {         if (targetHost.equals(host)) {             return false.         }     }     return true. }
