commented;modifiers;parameterAmount;loc;comment;code
true;public;0;3;/**  * Return the configured {@link XnioWorker}.  */ ;/**  * Return the configured {@link XnioWorker}.  */ public XnioWorker getXnioWorker() {     return this.worker. }
true;public;1;4;/**  * Set the {@link io.undertow.connector.ByteBufferPool ByteBufferPool} to pass to  * {@link io.undertow.websockets.client.WebSocketClient#connectionBuilder}.  * <p>By default an indirect {@link io.undertow.server.DefaultByteBufferPool}  * with a buffer size of 8192 is used.  * @since 5.0.8  * @see #DEFAULT_POOL_BUFFER_SIZE  */ ;/**  * Set the {@link io.undertow.connector.ByteBufferPool ByteBufferPool} to pass to  * {@link io.undertow.websockets.client.WebSocketClient#connectionBuilder}.  * <p>By default an indirect {@link io.undertow.server.DefaultByteBufferPool}  * with a buffer size of 8192 is used.  * @since 5.0.8  * @see #DEFAULT_POOL_BUFFER_SIZE  */ public void setByteBufferPool(ByteBufferPool byteBufferPool) {     Assert.notNull(byteBufferPool, "ByteBufferPool must not be null").     this.byteBufferPool = byteBufferPool. }
true;public;0;3;/**  * Return the {@link io.undertow.connector.ByteBufferPool} currently used  * for newly created WebSocket sessions by this client.  * @return the byte buffer pool  * @since 5.0.8  */ ;/**  * Return the {@link io.undertow.connector.ByteBufferPool} currently used  * for newly created WebSocket sessions by this client.  * @return the byte buffer pool  * @since 5.0.8  */ public ByteBufferPool getByteBufferPool() {     return this.byteBufferPool. }
true;public;0;3;/**  * Return the configured <code>Consumer&lt.ConnectionBuilder&gt.</code>.  */ ;/**  * Return the configured <code>Consumer&lt.ConnectionBuilder&gt.</code>.  */ public Consumer<ConnectionBuilder> getConnectionBuilderConsumer() {     return this.builderConsumer. }
false;public;2;4;;@Override public Mono<Void> execute(URI url, WebSocketHandler handler) {     return execute(url, new HttpHeaders(), handler). }
false;public;3;4;;@Override public Mono<Void> execute(URI url, HttpHeaders headers, WebSocketHandler handler) {     return executeInternal(url, headers, handler). }
false;public;2;4;;@Override public void handleDone(WebSocketChannel channel, Object attachment) {     handleChannel(url, handler, completion, negotiation, channel). }
false;public;2;4;;@Override public void handleFailed(IOException ex, Object attachment) {     completion.onError(new IllegalStateException("Failed to connect to " + url, ex)). }
false;private;3;25;;private Mono<Void> executeInternal(URI url, HttpHeaders headers, WebSocketHandler handler) {     MonoProcessor<Void> completion = MonoProcessor.create().     return Mono.fromCallable(() -> {         if (logger.isDebugEnabled()) {             logger.debug("Connecting to " + url).         }         List<String> protocols = handler.getSubProtocols().         ConnectionBuilder builder = createConnectionBuilder(url).         DefaultNegotiation negotiation = new DefaultNegotiation(protocols, headers, builder).         builder.setClientNegotiation(negotiation).         return builder.connect().addNotifier(new IoFuture.HandlingNotifier<WebSocketChannel, Object>() {              @Override             public void handleDone(WebSocketChannel channel, Object attachment) {                 handleChannel(url, handler, completion, negotiation, channel).             }              @Override             public void handleFailed(IOException ex, Object attachment) {                 completion.onError(new IllegalStateException("Failed to connect to " + url, ex)).             }         }, null).     }).then(completion). }
true;protected;1;6;/**  * Create a {@link ConnectionBuilder} for the given URI.  * <p>The default implementation creates a builder with the configured  * {@link #getXnioWorker() XnioWorker} and {@link #getByteBufferPool() ByteBufferPool} and  * then passes it to the {@link #getConnectionBuilderConsumer() consumer}  * provided at construction time.  */ ;/**  * Create a {@link ConnectionBuilder} for the given URI.  * <p>The default implementation creates a builder with the configured  * {@link #getXnioWorker() XnioWorker} and {@link #getByteBufferPool() ByteBufferPool} and  * then passes it to the {@link #getConnectionBuilderConsumer() consumer}  * provided at construction time.  */ protected ConnectionBuilder createConnectionBuilder(URI url) {     ConnectionBuilder builder = io.undertow.websockets.client.WebSocketClient.connectionBuilder(getXnioWorker(), getByteBufferPool(), url).     this.builderConsumer.accept(builder).     return builder. }
false;private;5;12;;private void handleChannel(URI url, WebSocketHandler handler, MonoProcessor<Void> completion, DefaultNegotiation negotiation, WebSocketChannel channel) {     HandshakeInfo info = createHandshakeInfo(url, negotiation).     UndertowWebSocketSession session = new UndertowWebSocketSession(channel, info, this.bufferFactory, completion).     UndertowWebSocketHandlerAdapter adapter = new UndertowWebSocketHandlerAdapter(session).     channel.getReceiveSetter().set(adapter).     channel.resumeReceives().     handler.handle(session).subscribe(session). }
false;private;2;5;;private HandshakeInfo createHandshakeInfo(URI url, DefaultNegotiation negotiation) {     HttpHeaders responseHeaders = negotiation.getResponseHeaders().     String protocol = responseHeaders.getFirst("Sec-WebSocket-Protocol").     return new HandshakeInfo(url, responseHeaders, Mono.empty(), protocol). }
false;public;0;3;;public HttpHeaders getResponseHeaders() {     return this.responseHeaders. }
false;public;1;7;;@Override public void beforeRequest(Map<String, List<String>> headers) {     this.requestHeaders.forEach(headers::put).     if (this.delegate != null) {         this.delegate.beforeRequest(headers).     } }
false;public;1;7;;@Override public void afterRequest(Map<String, List<String>> headers) {     headers.forEach(this.responseHeaders::put).     if (this.delegate != null) {         this.delegate.afterRequest(headers).     } }
