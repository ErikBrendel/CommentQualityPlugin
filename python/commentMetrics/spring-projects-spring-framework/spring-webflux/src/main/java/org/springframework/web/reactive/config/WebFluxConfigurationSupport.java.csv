commented;modifiers;parameterAmount;loc;comment;code
false;public;1;9;;@Override public void setApplicationContext(@Nullable ApplicationContext applicationContext) {     this.applicationContext = applicationContext.     if (applicationContext != null) {         Assert.state(!applicationContext.containsBean("mvcContentNegotiationManager"), "The Java/XML config for Spring MVC and Spring WebFlux cannot both be enabled, " + "e.g. via @EnableWebMvc and @EnableWebFlux, in the same application.").     } }
false;public,final;0;4;;@Nullable public final ApplicationContext getApplicationContext() {     return this.applicationContext. }
false;public;0;4;;@Bean public DispatcherHandler webHandler() {     return new DispatcherHandler(). }
false;public;0;5;;@Bean @Order(0) public WebExceptionHandler responseStatusExceptionHandler() {     return new WebFluxResponseStatusExceptionHandler(). }
false;public;0;23;;@Bean public RequestMappingHandlerMapping requestMappingHandlerMapping() {     RequestMappingHandlerMapping mapping = createRequestMappingHandlerMapping().     mapping.setOrder(0).     mapping.setContentTypeResolver(webFluxContentTypeResolver()).     mapping.setCorsConfigurations(getCorsConfigurations()).     PathMatchConfigurer configurer = getPathMatchConfigurer().     Boolean useTrailingSlashMatch = configurer.isUseTrailingSlashMatch().     if (useTrailingSlashMatch != null) {         mapping.setUseTrailingSlashMatch(useTrailingSlashMatch).     }     Boolean useCaseSensitiveMatch = configurer.isUseCaseSensitiveMatch().     if (useCaseSensitiveMatch != null) {         mapping.setUseCaseSensitiveMatch(useCaseSensitiveMatch).     }     Map<String, Predicate<Class<?>>> pathPrefixes = configurer.getPathPrefixes().     if (pathPrefixes != null) {         mapping.setPathPrefixes(pathPrefixes).     }     return mapping. }
true;protected;0;3;/**  * Override to plug a sub-class of {@link RequestMappingHandlerMapping}.  */ ;/**  * Override to plug a sub-class of {@link RequestMappingHandlerMapping}.  */ protected RequestMappingHandlerMapping createRequestMappingHandlerMapping() {     return new RequestMappingHandlerMapping(). }
false;public;0;6;;@Bean public RequestedContentTypeResolver webFluxContentTypeResolver() {     RequestedContentTypeResolverBuilder builder = new RequestedContentTypeResolverBuilder().     configureContentTypeResolver(builder).     return builder.build(). }
true;protected;1;2;/**  * Override to configure how the requested content type is resolved.  */ ;/**  * Override to configure how the requested content type is resolved.  */ protected void configureContentTypeResolver(RequestedContentTypeResolverBuilder builder) { }
true;protected,final;0;8;/**  * Callback for building the global CORS configuration. This method is final.  * Use {@link #addCorsMappings(CorsRegistry)} to customize the CORS conifg.  */ ;/**  * Callback for building the global CORS configuration. This method is final.  * Use {@link #addCorsMappings(CorsRegistry)} to customize the CORS conifg.  */ protected final Map<String, CorsConfiguration> getCorsConfigurations() {     if (this.corsConfigurations == null) {         CorsRegistry registry = new CorsRegistry().         addCorsMappings(registry).         this.corsConfigurations = registry.getCorsConfigurations().     }     return this.corsConfigurations. }
true;protected;1;2;/**  * Override this method to configure cross origin requests processing.  * @see CorsRegistry  */ ;/**  * Override this method to configure cross origin requests processing.  * @see CorsRegistry  */ protected void addCorsMappings(CorsRegistry registry) { }
true;protected,final;0;7;/**  * Callback for building the {@link PathMatchConfigurer}. This method is  * final, use {@link #configurePathMatching} to customize path matching.  */ ;/**  * Callback for building the {@link PathMatchConfigurer}. This method is  * final, use {@link #configurePathMatching} to customize path matching.  */ protected final PathMatchConfigurer getPathMatchConfigurer() {     if (this.pathMatchConfigurer == null) {         this.pathMatchConfigurer = new PathMatchConfigurer().         configurePathMatching(this.pathMatchConfigurer).     }     return this.pathMatchConfigurer. }
true;public;1;2;/**  * Override to configure path matching options.  */ ;/**  * Override to configure path matching options.  */ public void configurePathMatching(PathMatchConfigurer configurer) { }
false;public;0;9;;@Bean public RouterFunctionMapping routerFunctionMapping() {     RouterFunctionMapping mapping = createRouterFunctionMapping().     // go before RequestMappingHandlerMapping     mapping.setOrder(-1).     mapping.setMessageReaders(serverCodecConfigurer().getReaders()).     mapping.setCorsConfigurations(getCorsConfigurations()).     return mapping. }
true;protected;0;3;/**  * Override to plug a sub-class of {@link RouterFunctionMapping}.  */ ;/**  * Override to plug a sub-class of {@link RouterFunctionMapping}.  */ protected RouterFunctionMapping createRouterFunctionMapping() {     return new RouterFunctionMapping(). }
true;public;0;27;/**  * Return a handler mapping ordered at Integer.MAX_VALUE-1 with mapped  * resource handlers. To configure resource handling, override  * {@link #addResourceHandlers}.  */ ;/**  * Return a handler mapping ordered at Integer.MAX_VALUE-1 with mapped  * resource handlers. To configure resource handling, override  * {@link #addResourceHandlers}.  */ @Bean public HandlerMapping resourceHandlerMapping() {     ResourceLoader resourceLoader = this.applicationContext.     if (resourceLoader == null) {         resourceLoader = new DefaultResourceLoader().     }     ResourceHandlerRegistry registry = new ResourceHandlerRegistry(resourceLoader).     registry.setResourceUrlProvider(resourceUrlProvider()).     addResourceHandlers(registry).     AbstractHandlerMapping handlerMapping = registry.getHandlerMapping().     if (handlerMapping != null) {         PathMatchConfigurer configurer = getPathMatchConfigurer().         Boolean useTrailingSlashMatch = configurer.isUseTrailingSlashMatch().         Boolean useCaseSensitiveMatch = configurer.isUseCaseSensitiveMatch().         if (useTrailingSlashMatch != null) {             handlerMapping.setUseTrailingSlashMatch(useTrailingSlashMatch).         }         if (useCaseSensitiveMatch != null) {             handlerMapping.setUseCaseSensitiveMatch(useCaseSensitiveMatch).         }     } else {         handlerMapping = new EmptyHandlerMapping().     }     return handlerMapping. }
false;public;0;4;;@Bean public ResourceUrlProvider resourceUrlProvider() {     return new ResourceUrlProvider(). }
true;protected;1;2;/**  * Override this method to add resource handlers for serving static resources.  * @see ResourceHandlerRegistry  */ ;/**  * Override this method to add resource handlers for serving static resources.  * @see ResourceHandlerRegistry  */ protected void addResourceHandlers(ResourceHandlerRegistry registry) { }
false;public;0;13;;@Bean public RequestMappingHandlerAdapter requestMappingHandlerAdapter() {     RequestMappingHandlerAdapter adapter = createRequestMappingHandlerAdapter().     adapter.setMessageReaders(serverCodecConfigurer().getReaders()).     adapter.setWebBindingInitializer(getConfigurableWebBindingInitializer()).     adapter.setReactiveAdapterRegistry(webFluxAdapterRegistry()).     ArgumentResolverConfigurer configurer = new ArgumentResolverConfigurer().     configureArgumentResolvers(configurer).     adapter.setArgumentResolverConfigurer(configurer).     return adapter. }
true;protected;0;3;/**  * Override to plug a sub-class of {@link RequestMappingHandlerAdapter}.  */ ;/**  * Override to plug a sub-class of {@link RequestMappingHandlerAdapter}.  */ protected RequestMappingHandlerAdapter createRequestMappingHandlerAdapter() {     return new RequestMappingHandlerAdapter(). }
true;protected;1;2;/**  * Configure resolvers for custom controller method arguments.  */ ;/**  * Configure resolvers for custom controller method arguments.  */ protected void configureArgumentResolvers(ArgumentResolverConfigurer configurer) { }
true;public;0;6;/**  * Return the configurer for HTTP message readers and writers.  * <p>Use {@link #configureHttpMessageCodecs(ServerCodecConfigurer)} to  * configure the readers and writers.  */ ;/**  * Return the configurer for HTTP message readers and writers.  * <p>Use {@link #configureHttpMessageCodecs(ServerCodecConfigurer)} to  * configure the readers and writers.  */ @Bean public ServerCodecConfigurer serverCodecConfigurer() {     ServerCodecConfigurer serverCodecConfigurer = ServerCodecConfigurer.create().     configureHttpMessageCodecs(serverCodecConfigurer).     return serverCodecConfigurer. }
true;protected;0;3;/**  * Override to plug a sub-class of {@link LocaleContextResolver}.  */ ;/**  * Override to plug a sub-class of {@link LocaleContextResolver}.  */ protected LocaleContextResolver createLocaleContextResolver() {     return new AcceptHeaderLocaleContextResolver(). }
false;public;0;4;;@Bean public LocaleContextResolver localeContextResolver() {     return createLocaleContextResolver(). }
true;protected;1;2;/**  * Override to configure the HTTP message readers and writers to use.  */ ;/**  * Override to configure the HTTP message readers and writers to use.  */ protected void configureHttpMessageCodecs(ServerCodecConfigurer configurer) { }
true;protected;0;10;/**  * Return the {@link ConfigurableWebBindingInitializer} to use for  * initializing all {@link WebDataBinder} instances.  */ ;/**  * Return the {@link ConfigurableWebBindingInitializer} to use for  * initializing all {@link WebDataBinder} instances.  */ protected ConfigurableWebBindingInitializer getConfigurableWebBindingInitializer() {     ConfigurableWebBindingInitializer initializer = new ConfigurableWebBindingInitializer().     initializer.setConversionService(webFluxConversionService()).     initializer.setValidator(webFluxValidator()).     MessageCodesResolver messageCodesResolver = getMessageCodesResolver().     if (messageCodesResolver != null) {         initializer.setMessageCodesResolver(messageCodesResolver).     }     return initializer. }
true;public;0;6;/**  * Return a {@link FormattingConversionService} for use with annotated controllers.  * <p>See {@link #addFormatters} as an alternative to overriding this method.  */ ;/**  * Return a {@link FormattingConversionService} for use with annotated controllers.  * <p>See {@link #addFormatters} as an alternative to overriding this method.  */ @Bean public FormattingConversionService webFluxConversionService() {     FormattingConversionService service = new DefaultFormattingConversionService().     addFormatters(service).     return service. }
true;protected;1;2;/**  * Override this method to add custom {@link Converter} and/or {@link Formatter}  * delegates to the common {@link FormattingConversionService}.  * @see #webFluxConversionService()  */ ;/**  * Override this method to add custom {@link Converter} and/or {@link Formatter}  * delegates to the common {@link FormattingConversionService}.  * @see #webFluxConversionService()  */ protected void addFormatters(FormatterRegistry registry) { }
true;public;0;4;/**  * Return a {@link ReactiveAdapterRegistry} to adapting reactive types.  */ ;/**  * Return a {@link ReactiveAdapterRegistry} to adapting reactive types.  */ @Bean public ReactiveAdapterRegistry webFluxAdapterRegistry() {     return new ReactiveAdapterRegistry(). }
true;public;0;21;/**  * Return a global {@link Validator} instance for example for validating  * {@code @RequestBody} method arguments.  * <p>Delegates to {@link #getValidator()} first. If that returns {@code null}  * checks the classpath for the presence of a JSR-303 implementations  * before creating a {@code OptionalValidatorFactoryBean}. If a JSR-303  * implementation is not available, a "no-op" {@link Validator} is returned.  */ ;/**  * Return a global {@link Validator} instance for example for validating  * {@code @RequestBody} method arguments.  * <p>Delegates to {@link #getValidator()} first. If that returns {@code null}  * checks the classpath for the presence of a JSR-303 implementations  * before creating a {@code OptionalValidatorFactoryBean}. If a JSR-303  * implementation is not available, a "no-op" {@link Validator} is returned.  */ @Bean public Validator webFluxValidator() {     Validator validator = getValidator().     if (validator == null) {         if (ClassUtils.isPresent("javax.validation.Validator", getClass().getClassLoader())) {             Class<?> clazz.             try {                 String name = "org.springframework.validation.beanvalidation.OptionalValidatorFactoryBean".                 clazz = ClassUtils.forName(name, getClass().getClassLoader()).             } catch (ClassNotFoundException | LinkageError ex) {                 throw new BeanInitializationException("Failed to resolve default validator class", ex).             }             validator = (Validator) BeanUtils.instantiateClass(clazz).         } else {             validator = new NoOpValidator().         }     }     return validator. }
true;protected;0;4;/**  * Override this method to provide a custom {@link Validator}.  */ ;/**  * Override this method to provide a custom {@link Validator}.  */ @Nullable protected Validator getValidator() {     return null. }
true;protected;0;4;/**  * Override this method to provide a custom {@link MessageCodesResolver}.  */ ;/**  * Override this method to provide a custom {@link MessageCodesResolver}.  */ @Nullable protected MessageCodesResolver getMessageCodesResolver() {     return null. }
false;public;0;4;;@Bean public HandlerFunctionAdapter handlerFunctionAdapter() {     return new HandlerFunctionAdapter(). }
false;public;0;4;;@Bean public SimpleHandlerAdapter simpleHandlerAdapter() {     return new SimpleHandlerAdapter(). }
false;public;0;5;;@Bean public ResponseEntityResultHandler responseEntityResultHandler() {     return new ResponseEntityResultHandler(serverCodecConfigurer().getWriters(), webFluxContentTypeResolver(), webFluxAdapterRegistry()). }
false;public;0;5;;@Bean public ResponseBodyResultHandler responseBodyResultHandler() {     return new ResponseBodyResultHandler(serverCodecConfigurer().getWriters(), webFluxContentTypeResolver(), webFluxAdapterRegistry()). }
false;public;0;10;;@Bean public ViewResolutionResultHandler viewResolutionResultHandler() {     ViewResolverRegistry registry = getViewResolverRegistry().     List<ViewResolver> resolvers = registry.getViewResolvers().     ViewResolutionResultHandler handler = new ViewResolutionResultHandler(resolvers, webFluxContentTypeResolver(), webFluxAdapterRegistry()).     handler.setDefaultViews(registry.getDefaultViews()).     handler.setOrder(registry.getOrder()).     return handler. }
false;public;0;8;;@Bean public ServerResponseResultHandler serverResponseResultHandler() {     List<ViewResolver> resolvers = getViewResolverRegistry().getViewResolvers().     ServerResponseResultHandler handler = new ServerResponseResultHandler().     handler.setMessageWriters(serverCodecConfigurer().getWriters()).     handler.setViewResolvers(resolvers).     return handler. }
true;protected,final;0;7;/**  * Callback for building the {@link ViewResolverRegistry}. This method is final,  * use {@link #configureViewResolvers} to customize view resolvers.  */ ;/**  * Callback for building the {@link ViewResolverRegistry}. This method is final,  * use {@link #configureViewResolvers} to customize view resolvers.  */ protected final ViewResolverRegistry getViewResolverRegistry() {     if (this.viewResolverRegistry == null) {         this.viewResolverRegistry = new ViewResolverRegistry(this.applicationContext).         configureViewResolvers(this.viewResolverRegistry).     }     return this.viewResolverRegistry. }
true;protected;1;2;/**  * Configure view resolution for supporting template engines.  * @see ViewResolverRegistry  */ ;/**  * Configure view resolution for supporting template engines.  * @see ViewResolverRegistry  */ protected void configureViewResolvers(ViewResolverRegistry registry) { }
false;public;1;4;;@Override public Mono<Object> getHandlerInternal(ServerWebExchange exchange) {     return Mono.empty(). }
false;public;1;4;;@Override public boolean supports(Class<?> clazz) {     return false. }
false;public;2;3;;@Override public void validate(@Nullable Object target, Errors errors) { }
