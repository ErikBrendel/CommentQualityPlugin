commented;modifiers;parameterAmount;loc;comment;code
true;public,static;1;3;/**  * Extractor to decode the input content into {@code Mono<T>}.  * @param elementClass the class of the element type to decode to  * @param <T> the element type to decode to  * @return {@code BodyExtractor} for {@code Mono<T>}  */ ;/**  * Extractor to decode the input content into {@code Mono<T>}.  * @param elementClass the class of the element type to decode to  * @param <T> the element type to decode to  * @return {@code BodyExtractor} for {@code Mono<T>}  */ public static <T> BodyExtractor<Mono<T>, ReactiveHttpInputMessage> toMono(Class<? extends T> elementClass) {     return toMono(ResolvableType.forClass(elementClass)). }
true;public,static;1;3;/**  * Variant of {@link #toMono(Class)} for type information with generics.  * @param typeRef the type reference for the type to decode to  * @param <T> the element type to decode to  * @return {@code BodyExtractor} for {@code Mono<T>}  */ ;/**  * Variant of {@link #toMono(Class)} for type information with generics.  * @param typeRef the type reference for the type to decode to  * @param <T> the element type to decode to  * @return {@code BodyExtractor} for {@code Mono<T>}  */ public static <T> BodyExtractor<Mono<T>, ReactiveHttpInputMessage> toMono(ParameterizedTypeReference<T> typeRef) {     return toMono(ResolvableType.forType(typeRef.getType())). }
false;private,static;1;7;;private static <T> BodyExtractor<Mono<T>, ReactiveHttpInputMessage> toMono(ResolvableType elementType) {     return (inputMessage, context) -> readWithMessageReaders(inputMessage, context, elementType, (HttpMessageReader<T> reader) -> readToMono(inputMessage, context, elementType, reader), ex -> Mono.from(unsupportedErrorHandler(inputMessage, ex)), skipBodyAsMono(inputMessage)). }
true;public,static;1;3;/**  * Extractor to decode the input content into {@code Flux<T>}.  * @param elementClass the class of the element type to decode to  * @param <T> the element type to decode to  * @return {@code BodyExtractor} for {@code Flux<T>}  */ ;/**  * Extractor to decode the input content into {@code Flux<T>}.  * @param elementClass the class of the element type to decode to  * @param <T> the element type to decode to  * @return {@code BodyExtractor} for {@code Flux<T>}  */ public static <T> BodyExtractor<Flux<T>, ReactiveHttpInputMessage> toFlux(Class<? extends T> elementClass) {     return toFlux(ResolvableType.forClass(elementClass)). }
true;public,static;1;3;/**  * Variant of {@link #toFlux(Class)} for type information with generics.  * @param typeRef the type reference for the type to decode to  * @param <T> the element type to decode to  * @return {@code BodyExtractor} for {@code Flux<T>}  */ ;/**  * Variant of {@link #toFlux(Class)} for type information with generics.  * @param typeRef the type reference for the type to decode to  * @param <T> the element type to decode to  * @return {@code BodyExtractor} for {@code Flux<T>}  */ public static <T> BodyExtractor<Flux<T>, ReactiveHttpInputMessage> toFlux(ParameterizedTypeReference<T> typeRef) {     return toFlux(ResolvableType.forType(typeRef.getType())). }
false;private,static;1;8;;@SuppressWarnings("unchecked") private static <T> BodyExtractor<Flux<T>, ReactiveHttpInputMessage> toFlux(ResolvableType elementType) {     return (inputMessage, context) -> readWithMessageReaders(inputMessage, context, elementType, (HttpMessageReader<T> reader) -> readToFlux(inputMessage, context, elementType, reader), ex -> unsupportedErrorHandler(inputMessage, ex), skipBodyAsFlux(inputMessage)). }
true;public,static;0;8;/**  * Extractor to read form data into {@code MultiValueMap<String, String>}.  * <p>As of 5.1 this method can also be used on the client side to read form  * data from a server response (e.g. OAuth).  * @return {@code BodyExtractor} for form data  */ ;// Extractors for specific content .. /**  * Extractor to read form data into {@code MultiValueMap<String, String>}.  * <p>As of 5.1 this method can also be used on the client side to read form  * data from a server response (e.g. OAuth).  * @return {@code BodyExtractor} for form data  */ public static BodyExtractor<Mono<MultiValueMap<String, String>>, ReactiveHttpInputMessage> toFormData() {     return (message, context) -> {         ResolvableType elementType = FORM_DATA_TYPE.         MediaType mediaType = MediaType.APPLICATION_FORM_URLENCODED.         HttpMessageReader<MultiValueMap<String, String>> reader = findReader(elementType, mediaType, context).         return readToMono(message, context, elementType, reader).     }. }
true;public,static;0;8;// Parameterized for server-side use ;/**  * Extractor to read multipart data into a {@code MultiValueMap<String, Part>}.  * @return {@code BodyExtractor} for multipart data  */ // Parameterized for server-side use public static BodyExtractor<Mono<MultiValueMap<String, Part>>, ServerHttpRequest> toMultipartData() {     return (serverRequest, context) -> {         ResolvableType elementType = MULTIPART_DATA_TYPE.         MediaType mediaType = MediaType.MULTIPART_FORM_DATA.         HttpMessageReader<MultiValueMap<String, Part>> reader = findReader(elementType, mediaType, context).         return readToMono(serverRequest, context, elementType, reader).     }. }
true;public,static;0;8;// Parameterized for server-side use ;/**  * Extractor to read multipart data into {@code Flux<Part>}.  * @return {@code BodyExtractor} for multipart request parts  */ // Parameterized for server-side use public static BodyExtractor<Flux<Part>, ServerHttpRequest> toParts() {     return (serverRequest, context) -> {         ResolvableType elementType = PART_TYPE.         MediaType mediaType = MediaType.MULTIPART_FORM_DATA.         HttpMessageReader<Part> reader = findReader(elementType, mediaType, context).         return readToFlux(serverRequest, context, elementType, reader).     }. }
true;public,static;0;3;/**  * Extractor that returns the raw {@link DataBuffer DataBuffers}.  * <p><strong>Note:</strong> the data buffers should be  * {@link org.springframework.core.io.buffer.DataBufferUtils#release(DataBuffer)  * released} after being used.  * @return {@code BodyExtractor} for data buffers  */ ;/**  * Extractor that returns the raw {@link DataBuffer DataBuffers}.  * <p><strong>Note:</strong> the data buffers should be  * {@link org.springframework.core.io.buffer.DataBufferUtils#release(DataBuffer)  * released} after being used.  * @return {@code BodyExtractor} for data buffers  */ public static BodyExtractor<Flux<DataBuffer>, ReactiveHttpInputMessage> toDataBuffers() {     return (inputMessage, context) -> inputMessage.getBody(). }
false;private,static;6;25;;// Private support methods private static <T, S extends Publisher<T>> S readWithMessageReaders(ReactiveHttpInputMessage message, BodyExtractor.Context context, ResolvableType elementType, Function<HttpMessageReader<T>, S> readerFunction, Function<UnsupportedMediaTypeException, S> errorFunction, Supplier<S> emptySupplier) {     if (VOID_TYPE.equals(elementType)) {         return emptySupplier.get().     }     MediaType contentType = Optional.ofNullable(message.getHeaders().getContentType()).orElse(MediaType.APPLICATION_OCTET_STREAM).     return context.messageReaders().stream().filter(reader -> reader.canRead(elementType, contentType)).findFirst().map(BodyExtractors::<T>cast).map(readerFunction).orElseGet(() -> {         List<MediaType> mediaTypes = context.messageReaders().stream().flatMap(reader -> reader.getReadableMediaTypes().stream()).collect(Collectors.toList()).         return errorFunction.apply(new UnsupportedMediaTypeException(contentType, mediaTypes, elementType)).     }). }
false;private,static;4;7;;private static <T> Mono<T> readToMono(ReactiveHttpInputMessage message, BodyExtractor.Context context, ResolvableType type, HttpMessageReader<T> reader) {     return context.serverResponse().map(response -> reader.readMono(type, type, (ServerHttpRequest) message, response, context.hints())).orElseGet(() -> reader.readMono(type, message, context.hints())). }
false;private,static;4;7;;private static <T> Flux<T> readToFlux(ReactiveHttpInputMessage message, BodyExtractor.Context context, ResolvableType type, HttpMessageReader<T> reader) {     return context.serverResponse().map(response -> reader.read(type, type, (ServerHttpRequest) message, response, context.hints())).orElseGet(() -> reader.read(type, message, context.hints())). }
false;private,static;2;17;;private static <T> Flux<T> unsupportedErrorHandler(ReactiveHttpInputMessage message, UnsupportedMediaTypeException ex) {     Flux<T> result.     if (message.getHeaders().getContentType() == null) {         // Maybe it's okay there is no content type, if there is no content..         result = message.getBody().map(buffer -> {             DataBufferUtils.release(buffer).             throw ex.         }).     } else {         result = message instanceof ClientHttpResponse ? consumeAndCancel(message).thenMany(Flux.error(ex)) : Flux.error(ex).     }     return result. }
false;private,static;3;10;;private static <T> HttpMessageReader<T> findReader(ResolvableType elementType, MediaType mediaType, BodyExtractor.Context context) {     return context.messageReaders().stream().filter(messageReader -> messageReader.canRead(elementType, mediaType)).findFirst().map(BodyExtractors::<T>cast).orElseThrow(() -> new IllegalStateException("No HttpMessageReader for \"" + mediaType + "\" and \"" + elementType + "\"")). }
false;private,static;1;4;;@SuppressWarnings("unchecked") private static <T> HttpMessageReader<T> cast(HttpMessageReader<?> reader) {     return (HttpMessageReader<T>) reader. }
false;private,static;1;4;;private static <T> Supplier<Flux<T>> skipBodyAsFlux(ReactiveHttpInputMessage message) {     return message instanceof ClientHttpResponse ? () -> consumeAndCancel(message).thenMany(Mono.empty()) : Flux::empty. }
false;private,static;1;5;;@SuppressWarnings("unchecked") private static <T> Supplier<Mono<T>> skipBodyAsMono(ReactiveHttpInputMessage message) {     return message instanceof ClientHttpResponse ? () -> consumeAndCancel(message).then(Mono.empty()) : Mono::empty. }
false;private,static;1;9;;private static Mono<Void> consumeAndCancel(ReactiveHttpInputMessage message) {     return message.getBody().map(buffer -> {         DataBufferUtils.release(buffer).         throw new ReadCancellationException().     }).onErrorResume(ReadCancellationException.class, ex -> Mono.empty()).then(). }
