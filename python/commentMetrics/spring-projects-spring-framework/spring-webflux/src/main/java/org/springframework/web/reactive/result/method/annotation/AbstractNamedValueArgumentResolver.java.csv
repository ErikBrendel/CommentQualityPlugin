commented;modifiers;parameterAmount;loc;comment;code
false;public;3;27;;@Override public Mono<Object> resolveArgument(MethodParameter parameter, BindingContext bindingContext, ServerWebExchange exchange) {     NamedValueInfo namedValueInfo = getNamedValueInfo(parameter).     MethodParameter nestedParameter = parameter.nestedIfOptional().     Object resolvedName = resolveStringValue(namedValueInfo.name).     if (resolvedName == null) {         return Mono.error(new IllegalArgumentException("Specified name must not resolve to null: [" + namedValueInfo.name + "]")).     }     Model model = bindingContext.getModel().     return resolveName(resolvedName.toString(), nestedParameter, exchange).flatMap(arg -> {         if ("".equals(arg) && namedValueInfo.defaultValue != null) {             arg = resolveStringValue(namedValueInfo.defaultValue).         }         arg = applyConversion(arg, namedValueInfo, parameter, bindingContext, exchange).         handleResolvedValue(arg, namedValueInfo.name, parameter, model, exchange).         return Mono.justOrEmpty(arg).     }).switchIfEmpty(getDefaultValue(namedValueInfo, parameter, bindingContext, model, exchange)). }
true;private;1;9;/**  * Obtain the named value for the given method parameter.  */ ;/**  * Obtain the named value for the given method parameter.  */ private NamedValueInfo getNamedValueInfo(MethodParameter parameter) {     NamedValueInfo namedValueInfo = this.namedValueInfoCache.get(parameter).     if (namedValueInfo == null) {         namedValueInfo = createNamedValueInfo(parameter).         namedValueInfo = updateNamedValueInfo(parameter, namedValueInfo).         this.namedValueInfoCache.put(parameter, namedValueInfo).     }     return namedValueInfo. }
true;protected,abstract;1;1;/**  * Create the {@link NamedValueInfo} object for the given method parameter.  * Implementations typically retrieve the method annotation by means of  * {@link MethodParameter#getParameterAnnotation(Class)}.  * @param parameter the method parameter  * @return the named value information  */ ;/**  * Create the {@link NamedValueInfo} object for the given method parameter.  * Implementations typically retrieve the method annotation by means of  * {@link MethodParameter#getParameterAnnotation(Class)}.  * @param parameter the method parameter  * @return the named value information  */ protected abstract NamedValueInfo createNamedValueInfo(MethodParameter parameter).
true;private;2;13;/**  * Create a new NamedValueInfo based on the given NamedValueInfo with  * sanitized values.  */ ;/**  * Create a new NamedValueInfo based on the given NamedValueInfo with  * sanitized values.  */ private NamedValueInfo updateNamedValueInfo(MethodParameter parameter, NamedValueInfo info) {     String name = info.name.     if (info.name.isEmpty()) {         name = parameter.getParameterName().         if (name == null) {             String type = parameter.getNestedParameterType().getName().             throw new IllegalArgumentException("Name for argument type [" + type + "] not " + "available, and parameter name information not found in class file either.").         }     }     String defaultValue = (ValueConstants.DEFAULT_NONE.equals(info.defaultValue) ? null : info.defaultValue).     return new NamedValueInfo(name, info.required, defaultValue). }
true;private;1;12;/**  * Resolve the given annotation-specified value,  * potentially containing placeholders and expressions.  */ ;/**  * Resolve the given annotation-specified value,  * potentially containing placeholders and expressions.  */ @Nullable private Object resolveStringValue(String value) {     if (this.configurableBeanFactory == null || this.expressionContext == null) {         return value.     }     String placeholdersResolved = this.configurableBeanFactory.resolveEmbeddedValue(value).     BeanExpressionResolver exprResolver = this.configurableBeanFactory.getBeanExpressionResolver().     if (exprResolver == null) {         return value.     }     return exprResolver.evaluate(placeholdersResolved, this.expressionContext). }
true;protected,abstract;3;1;/**  * Resolve the given parameter type and value name into an argument value.  * @param name the name of the value being resolved  * @param parameter the method parameter to resolve to an argument value  * (pre-nested in case of a {@link java.util.Optional} declaration)  * @param exchange the current exchange  * @return the resolved argument (may be empty {@link Mono})  */ ;/**  * Resolve the given parameter type and value name into an argument value.  * @param name the name of the value being resolved  * @param parameter the method parameter to resolve to an argument value  * (pre-nested in case of a {@link java.util.Optional} declaration)  * @param exchange the current exchange  * @return the resolved argument (may be empty {@link Mono})  */ protected abstract Mono<Object> resolveName(String name, MethodParameter parameter, ServerWebExchange exchange).
true;private;5;16;/**  * Apply type conversion if necessary.  */ ;/**  * Apply type conversion if necessary.  */ @Nullable private Object applyConversion(@Nullable Object value, NamedValueInfo namedValueInfo, MethodParameter parameter, BindingContext bindingContext, ServerWebExchange exchange) {     WebDataBinder binder = bindingContext.createDataBinder(exchange, namedValueInfo.name).     try {         value = binder.convertIfNecessary(value, parameter.getParameterType(), parameter).     } catch (ConversionNotSupportedException ex) {         throw new ServerErrorException("Conversion not supported.", parameter, ex).     } catch (TypeMismatchException ex) {         throw new ServerWebInputException("Type mismatch.", parameter, ex).     }     return value. }
true;private;5;17;/**  * Resolve the default value, if any.  */ ;/**  * Resolve the default value, if any.  */ private Mono<Object> getDefaultValue(NamedValueInfo namedValueInfo, MethodParameter parameter, BindingContext bindingContext, Model model, ServerWebExchange exchange) {     return Mono.fromSupplier(() -> {         Object value = null.         if (namedValueInfo.defaultValue != null) {             value = resolveStringValue(namedValueInfo.defaultValue).         } else if (namedValueInfo.required && !parameter.isOptional()) {             handleMissingValue(namedValueInfo.name, parameter, exchange).         }         value = handleNullValue(namedValueInfo.name, value, parameter.getNestedParameterType()).         value = applyConversion(value, namedValueInfo, parameter, bindingContext, exchange).         handleResolvedValue(value, namedValueInfo.name, parameter, model, exchange).         return value.     }). }
true;protected;3;4;/**  * Invoked when a named value is required, but  * {@link #resolveName(String, MethodParameter, ServerWebExchange)} returned  * {@code null} and there is no default value. Subclasses typically throw an  * exception in this case.  * @param name the name for the value  * @param parameter the method parameter  * @param exchange the current exchange  */ ;/**  * Invoked when a named value is required, but  * {@link #resolveName(String, MethodParameter, ServerWebExchange)} returned  * {@code null} and there is no default value. Subclasses typically throw an  * exception in this case.  * @param name the name for the value  * @param parameter the method parameter  * @param exchange the current exchange  */ @SuppressWarnings("UnusedParameters") protected void handleMissingValue(String name, MethodParameter parameter, ServerWebExchange exchange) {     handleMissingValue(name, parameter). }
true;protected;2;5;/**  * Invoked when a named value is required, but  * {@link #resolveName(String, MethodParameter, ServerWebExchange)} returned  * {@code null} and there is no default value. Subclasses typically throw an  * exception in this case.  * @param name the name for the value  * @param parameter the method parameter  */ ;/**  * Invoked when a named value is required, but  * {@link #resolveName(String, MethodParameter, ServerWebExchange)} returned  * {@code null} and there is no default value. Subclasses typically throw an  * exception in this case.  * @param name the name for the value  * @param parameter the method parameter  */ protected void handleMissingValue(String name, MethodParameter parameter) {     String typeName = parameter.getNestedParameterType().getSimpleName().     throw new ServerWebInputException("Missing argument '" + name + "' for method " + "parameter of type " + typeName, parameter). }
true;private;3;15;/**  * A {@code null} results in a {@code false} value for {@code boolean}s or  * an exception for other primitives.  */ ;/**  * A {@code null} results in a {@code false} value for {@code boolean}s or  * an exception for other primitives.  */ @Nullable private Object handleNullValue(String name, @Nullable Object value, Class<?> paramType) {     if (value == null) {         if (Boolean.TYPE.equals(paramType)) {             return Boolean.FALSE.         } else if (paramType.isPrimitive()) {             throw new IllegalStateException("Optional " + paramType.getSimpleName() + " parameter '" + name + "' is present but cannot be translated into a" + " null value due to being declared as a primitive type. " + "Consider declaring it as object wrapper for the corresponding primitive type.").         }     }     return value. }
true;protected;5;4;/**  * Invoked after a value is resolved.  * @param arg the resolved argument value  * @param name the argument name  * @param parameter the argument parameter type  * @param model the model  * @param exchange the current exchange  */ ;/**  * Invoked after a value is resolved.  * @param arg the resolved argument value  * @param name the argument name  * @param parameter the argument parameter type  * @param model the model  * @param exchange the current exchange  */ @SuppressWarnings("UnusedParameters") protected void handleResolvedValue(@Nullable Object arg, String name, MethodParameter parameter, Model model, ServerWebExchange exchange) { }
