commented;modifiers;parameterAmount;loc;comment;code
true;public;0;3;/**  * Return the configured {@link ReactiveAdapterRegistry}.  */ ;/**  * Return the configured {@link ReactiveAdapterRegistry}.  */ public ReactiveAdapterRegistry getAdapterRegistry() {     return this.adapterRegistry. }
true;public;0;3;/**  * Return the configured {@link RequestedContentTypeResolver}.  */ ;/**  * Return the configured {@link RequestedContentTypeResolver}.  */ public RequestedContentTypeResolver getContentTypeResolver() {     return this.contentTypeResolver. }
true;public;1;3;/**  * Set the order for this result handler relative to others.  * <p>By default set to {@link Ordered#LOWEST_PRECEDENCE}, however see  * Javadoc of sub-classes which may change this default.  * @param order the order  */ ;/**  * Set the order for this result handler relative to others.  * <p>By default set to {@link Ordered#LOWEST_PRECEDENCE}, however see  * Javadoc of sub-classes which may change this default.  * @param order the order  */ public void setOrder(int order) {     this.order = order. }
false;public;0;4;;@Override public int getOrder() {     return this.order. }
true;protected;1;4;/**  * Get a {@code ReactiveAdapter} for the top-level return value type.  * @return the matching adapter, or {@code null} if none  */ ;/**  * Get a {@code ReactiveAdapter} for the top-level return value type.  * @return the matching adapter, or {@code null} if none  */ @Nullable protected ReactiveAdapter getAdapter(HandlerResult result) {     return getAdapterRegistry().getAdapter(result.getReturnType().resolve(), result.getReturnValue()). }
true;protected;2;52;/**  * Select the best media type for the current request through a content negotiation algorithm.  * @param exchange the current request  * @param producibleTypesSupplier the media types that can be produced for the current request  * @return the selected media type, or {@code null} if none  */ ;/**  * Select the best media type for the current request through a content negotiation algorithm.  * @param exchange the current request  * @param producibleTypesSupplier the media types that can be produced for the current request  * @return the selected media type, or {@code null} if none  */ @Nullable protected MediaType selectMediaType(ServerWebExchange exchange, Supplier<List<MediaType>> producibleTypesSupplier) {     MediaType contentType = exchange.getResponse().getHeaders().getContentType().     if (contentType != null && contentType.isConcrete()) {         if (logger.isDebugEnabled()) {             logger.debug(exchange.getLogPrefix() + "Found 'Content-Type:" + contentType + "' in response").         }         return contentType.     }     List<MediaType> acceptableTypes = getAcceptableTypes(exchange).     List<MediaType> producibleTypes = getProducibleTypes(exchange, producibleTypesSupplier).     Set<MediaType> compatibleMediaTypes = new LinkedHashSet<>().     for (MediaType acceptable : acceptableTypes) {         for (MediaType producible : producibleTypes) {             if (acceptable.isCompatibleWith(producible)) {                 compatibleMediaTypes.add(selectMoreSpecificMediaType(acceptable, producible)).             }         }     }     List<MediaType> result = new ArrayList<>(compatibleMediaTypes).     MediaType.sortBySpecificityAndQuality(result).     MediaType selected = null.     for (MediaType mediaType : result) {         if (mediaType.isConcrete()) {             selected = mediaType.             break.         } else if (mediaType.isPresentIn(ALL_APPLICATION_MEDIA_TYPES)) {             selected = MediaType.APPLICATION_OCTET_STREAM.             break.         }     }     if (selected != null) {         if (logger.isDebugEnabled()) {             logger.debug("Using '" + selected + "' given " + acceptableTypes + " and supported " + producibleTypes).         }     } else if (logger.isDebugEnabled()) {         logger.debug(exchange.getLogPrefix() + "No match for " + acceptableTypes + ", supported: " + producibleTypes).     }     return selected. }
false;private;1;3;;private List<MediaType> getAcceptableTypes(ServerWebExchange exchange) {     return getContentTypeResolver().resolveMediaTypes(exchange). }
false;private;2;7;;@SuppressWarnings("unchecked") private List<MediaType> getProducibleTypes(ServerWebExchange exchange, Supplier<List<MediaType>> producibleTypesSupplier) {     Set<MediaType> mediaTypes = exchange.getAttribute(HandlerMapping.PRODUCIBLE_MEDIA_TYPES_ATTRIBUTE).     return (mediaTypes != null ? new ArrayList<>(mediaTypes) : producibleTypesSupplier.get()). }
false;private;2;5;;private MediaType selectMoreSpecificMediaType(MediaType acceptable, MediaType producible) {     producible = producible.copyQualityValue(acceptable).     Comparator<MediaType> comparator = MediaType.SPECIFICITY_COMPARATOR.     return (comparator.compare(acceptable, producible) <= 0 ? acceptable : producible). }
