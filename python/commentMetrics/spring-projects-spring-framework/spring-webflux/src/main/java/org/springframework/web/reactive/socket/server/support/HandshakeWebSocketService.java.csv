commented;modifiers;parameterAmount;loc;comment;code
false;private,static;0;29;;private static RequestUpgradeStrategy initUpgradeStrategy() {     String className.     if (tomcatPresent) {         className = "TomcatRequestUpgradeStrategy".     } else if (jettyPresent) {         className = "JettyRequestUpgradeStrategy".     } else if (undertowPresent) {         className = "UndertowRequestUpgradeStrategy".     } else if (reactorNettyPresent) {         // As late as possible (Reactor Netty commonly used for WebClient)         className = "ReactorNettyRequestUpgradeStrategy".     } else {         throw new IllegalStateException("No suitable default RequestUpgradeStrategy found").     }     try {         className = "org.springframework.web.reactive.socket.server.upgrade." + className.         Class<?> clazz = ClassUtils.forName(className, HandshakeWebSocketService.class.getClassLoader()).         return (RequestUpgradeStrategy) ReflectionUtils.accessibleConstructor(clazz).newInstance().     } catch (Throwable ex) {         throw new IllegalStateException("Failed to instantiate RequestUpgradeStrategy: " + className, ex).     } }
true;public;0;3;/**  * Return the {@link RequestUpgradeStrategy} for WebSocket requests.  */ ;/**  * Return the {@link RequestUpgradeStrategy} for WebSocket requests.  */ public RequestUpgradeStrategy getUpgradeStrategy() {     return this.upgradeStrategy. }
true;public;1;3;/**  * Configure a predicate to use to extract  * {@link org.springframework.web.server.WebSession WebSession} attributes  * and use them to initialize the WebSocket session with.  * <p>By default this is not set in which case no attributes are passed.  * @param predicate the predicate  * @since 5.1  */ ;/**  * Configure a predicate to use to extract  * {@link org.springframework.web.server.WebSession WebSession} attributes  * and use them to initialize the WebSocket session with.  * <p>By default this is not set in which case no attributes are passed.  * @param predicate the predicate  * @since 5.1  */ public void setSessionAttributePredicate(@Nullable Predicate<String> predicate) {     this.sessionAttributePredicate = predicate. }
true;public;0;4;/**  * Return the configured predicate for initialization WebSocket session  * attributes from {@code WebSession} attributes.  * @since 5.1  */ ;/**  * Return the configured predicate for initialization WebSocket session  * attributes from {@code WebSession} attributes.  * @since 5.1  */ @Nullable public Predicate<String> getSessionAttributePredicate() {     return this.sessionAttributePredicate. }
false;public;0;7;;@Override public void start() {     if (!isRunning()) {         this.running = true.         doStart().     } }
false;protected;0;5;;protected void doStart() {     if (getUpgradeStrategy() instanceof Lifecycle) {         ((Lifecycle) getUpgradeStrategy()).start().     } }
false;public;0;7;;@Override public void stop() {     if (isRunning()) {         this.running = false.         doStop().     } }
false;protected;0;5;;protected void doStop() {     if (getUpgradeStrategy() instanceof Lifecycle) {         ((Lifecycle) getUpgradeStrategy()).stop().     } }
false;public;0;4;;@Override public boolean isRunning() {     return this.running. }
false;public;2;32;;@Override public Mono<Void> handleRequest(ServerWebExchange exchange, WebSocketHandler handler) {     ServerHttpRequest request = exchange.getRequest().     HttpMethod method = request.getMethod().     HttpHeaders headers = request.getHeaders().     if (HttpMethod.GET != method) {         return Mono.error(new MethodNotAllowedException(request.getMethodValue(), Collections.singleton(HttpMethod.GET))).     }     if (!"WebSocket".equalsIgnoreCase(headers.getUpgrade())) {         return handleBadRequest(exchange, "Invalid 'Upgrade' header: " + headers).     }     List<String> connectionValue = headers.getConnection().     if (!connectionValue.contains("Upgrade") && !connectionValue.contains("upgrade")) {         return handleBadRequest(exchange, "Invalid 'Connection' header: " + headers).     }     String key = headers.getFirst(SEC_WEBSOCKET_KEY).     if (key == null) {         return handleBadRequest(exchange, "Missing \"Sec-WebSocket-Key\" header").     }     String protocol = selectProtocol(headers, handler).     return initAttributes(exchange).flatMap(attributes -> this.upgradeStrategy.upgrade(exchange, handler, protocol, () -> createHandshakeInfo(exchange, request, protocol, attributes))). }
false;private;2;6;;private Mono<Void> handleBadRequest(ServerWebExchange exchange, String reason) {     if (logger.isDebugEnabled()) {         logger.debug(exchange.getLogPrefix() + reason).     }     return Mono.error(new ServerWebInputException(reason)). }
false;private;2;13;;@Nullable private String selectProtocol(HttpHeaders headers, WebSocketHandler handler) {     String protocolHeader = headers.getFirst(SEC_WEBSOCKET_PROTOCOL).     if (protocolHeader != null) {         List<String> supportedProtocols = handler.getSubProtocols().         for (String protocol : StringUtils.commaDelimitedListToStringArray(protocolHeader)) {             if (supportedProtocols.contains(protocol)) {                 return protocol.             }         }     }     return null. }
false;private;1;9;;private Mono<Map<String, Object>> initAttributes(ServerWebExchange exchange) {     if (this.sessionAttributePredicate == null) {         return EMPTY_ATTRIBUTES.     }     return exchange.getSession().map(session -> session.getAttributes().entrySet().stream().filter(entry -> this.sessionAttributePredicate.test(entry.getKey())).collect(Collectors.toMap(Map.Entry::getKey, Map.Entry::getValue))). }
false;private;4;13;;private HandshakeInfo createHandshakeInfo(ServerWebExchange exchange, ServerHttpRequest request, @Nullable String protocol, Map<String, Object> attributes) {     URI uri = request.getURI().     // Copy request headers, as they might be pooled and recycled by     // the server implementation once the handshake HTTP exchange is done.     HttpHeaders headers = new HttpHeaders().     headers.addAll(request.getHeaders()).     Mono<Principal> principal = exchange.getPrincipal().     String logPrefix = exchange.getLogPrefix().     InetSocketAddress remoteAddress = request.getRemoteAddress().     return new HandshakeInfo(uri, headers, principal, protocol, remoteAddress, attributes, logPrefix). }
