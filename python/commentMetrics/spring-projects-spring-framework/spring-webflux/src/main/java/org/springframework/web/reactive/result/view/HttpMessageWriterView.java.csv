commented;modifiers;parameterAmount;loc;comment;code
true;public;0;3;/**  * Return the configured message writer.  */ ;/**  * Return the configured message writer.  */ public HttpMessageWriter<?> getMessageWriter() {     return this.writer. }
true;public;0;4;/**  * {@inheritDoc}  * <p>The implementation of this method for {@link HttpMessageWriterView}  * delegates to {@link HttpMessageWriter#getWritableMediaTypes()}.  */ ;/**  * {@inheritDoc}  * <p>The implementation of this method for {@link HttpMessageWriterView}  * delegates to {@link HttpMessageWriter#getWritableMediaTypes()}.  */ @Override public List<MediaType> getSupportedMediaTypes() {     return this.writer.getWritableMediaTypes(). }
true;public;1;6;/**  * Set the attributes in the model that should be rendered by this view.  * When set, all other model attributes will be ignored. The matching  * attributes are further narrowed with {@link HttpMessageWriter#canWrite}.  * The matching attributes are processed as follows:  * <ul>  * <li>0: nothing is written to the response body.  * <li>1: the matching attribute is passed to the writer.  * <li>2..N: if the writer supports {@link Map}, write all matches.  * otherwise raise an {@link IllegalStateException}.  * </ul>  */ ;/**  * Set the attributes in the model that should be rendered by this view.  * When set, all other model attributes will be ignored. The matching  * attributes are further narrowed with {@link HttpMessageWriter#canWrite}.  * The matching attributes are processed as follows:  * <ul>  * <li>0: nothing is written to the response body.  * <li>1: the matching attribute is passed to the writer.  * <li>2..N: if the writer supports {@link Map}, write all matches.  * otherwise raise an {@link IllegalStateException}.  * </ul>  */ public void setModelKeys(@Nullable Set<String> modelKeys) {     this.modelKeys.clear().     if (modelKeys != null) {         this.modelKeys.addAll(modelKeys).     } }
true;public,final;0;3;/**  * Return the configured model keys.  */ ;/**  * Return the configured model keys.  */ public final Set<String> getModelKeys() {     return this.modelKeys. }
false;public;3;8;;@Override @SuppressWarnings("unchecked") public Mono<Void> render(@Nullable Map<String, ?> model, @Nullable MediaType contentType, ServerWebExchange exchange) {     Object value = getObjectToRender(model).     return (value != null ? write(value, contentType, exchange) : exchange.getResponse().setComplete()). }
false;private;1;24;;@Nullable private Object getObjectToRender(@Nullable Map<String, ?> model) {     if (model == null) {         return null.     }     Map<String, ?> result = model.entrySet().stream().filter(this::isMatch).collect(Collectors.toMap(Map.Entry::getKey, Map.Entry::getValue)).     if (result.isEmpty()) {         return null.     } else if (result.size() == 1) {         return result.values().iterator().next().     } else if (this.canWriteMap) {         return result.     } else {         throw new IllegalStateException("Multiple matches found: " + result + " but " + "Map rendering is not supported by " + getMessageWriter().getClass().getName()).     } }
false;private;1;10;;private boolean isMatch(Map.Entry<String, ?> entry) {     if (entry.getValue() == null) {         return false.     }     if (!getModelKeys().isEmpty() && !getModelKeys().contains(entry.getKey())) {         return false.     }     ResolvableType type = ResolvableType.forInstance(entry.getValue()).     return getMessageWriter().canWrite(type, null). }
false;private;3;8;;@SuppressWarnings("unchecked") private <T> Mono<Void> write(T value, @Nullable MediaType contentType, ServerWebExchange exchange) {     Publisher<T> input = Mono.justOrEmpty(value).     ResolvableType elementType = ResolvableType.forClass(value.getClass()).     return ((HttpMessageWriter<T>) this.writer).write(input, elementType, contentType, exchange.getResponse(), Hints.from(Hints.LOG_PREFIX_HINT, exchange.getLogPrefix())). }
