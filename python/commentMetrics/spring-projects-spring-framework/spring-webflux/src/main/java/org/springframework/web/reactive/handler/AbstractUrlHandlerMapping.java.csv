commented;modifiers;parameterAmount;loc;comment;code
true;public;1;3;/**  * Set whether to lazily initialize handlers. Only applicable to  * singleton handlers, as prototypes are always lazily initialized.  * Default is "false", as eager initialization allows for more efficiency  * through referencing the controller objects directly.  * <p>If you want to allow your controllers to be lazily initialized,  * make them "lazy-init" and set this flag to true. Just making them  * "lazy-init" will not work, as they are initialized through the  * references from the handler mapping in this case.  */ ;/**  * Set whether to lazily initialize handlers. Only applicable to  * singleton handlers, as prototypes are always lazily initialized.  * Default is "false", as eager initialization allows for more efficiency  * through referencing the controller objects directly.  * <p>If you want to allow your controllers to be lazily initialized,  * make them "lazy-init" and set this flag to true. Just making them  * "lazy-init" will not work, as they are initialized through the  * references from the handler mapping in this case.  */ public void setLazyInitHandlers(boolean lazyInitHandlers) {     this.lazyInitHandlers = lazyInitHandlers. }
true;public,final;0;3;/**  * Return a read-only view of registered path patterns and handlers which may  * may be an actual handler instance or the bean name of lazily initialized  * handler.  */ ;/**  * Return a read-only view of registered path patterns and handlers which may  * may be an actual handler instance or the bean name of lazily initialized  * handler.  */ public final Map<PathPattern, Object> getHandlerMap() {     return Collections.unmodifiableMap(this.handlerMap). }
false;public;1;12;;@Override public Mono<Object> getHandlerInternal(ServerWebExchange exchange) {     PathContainer lookupPath = exchange.getRequest().getPath().pathWithinApplication().     Object handler.     try {         handler = lookupHandler(lookupPath, exchange).     } catch (Exception ex) {         return Mono.error(ex).     }     return Mono.justOrEmpty(handler). }
true;protected;2;22;/**  * Look up a handler instance for the given URL lookup path.  * <p>Supports direct matches, e.g. a registered "/test" matches "/test",  * and various path pattern matches, e.g. a registered "/t*" matches  * both "/test" and "/team". For details, see the PathPattern class.  * @param lookupPath the URL the handler is mapped to  * @param exchange the current exchange  * @return the associated handler instance, or {@code null} if not found  * @see org.springframework.web.util.pattern.PathPattern  */ ;/**  * Look up a handler instance for the given URL lookup path.  * <p>Supports direct matches, e.g. a registered "/test" matches "/test",  * and various path pattern matches, e.g. a registered "/t*" matches  * both "/test" and "/team". For details, see the PathPattern class.  * @param lookupPath the URL the handler is mapped to  * @param exchange the current exchange  * @return the associated handler instance, or {@code null} if not found  * @see org.springframework.web.util.pattern.PathPattern  */ @Nullable protected Object lookupHandler(PathContainer lookupPath, ServerWebExchange exchange) throws Exception {     List<PathPattern> matches = this.handlerMap.keySet().stream().filter(key -> key.matches(lookupPath)).collect(Collectors.toList()).     if (matches.isEmpty()) {         return null.     }     if (matches.size() > 1) {         matches.sort(PathPattern.SPECIFICITY_COMPARATOR).         if (logger.isTraceEnabled()) {             logger.debug(exchange.getLogPrefix() + "Matching patterns " + matches).         }     }     PathPattern pattern = matches.get(0).     PathContainer pathWithinMapping = pattern.extractPathWithinPattern(lookupPath).     return handleMatch(this.handlerMap.get(pattern), pattern, pathWithinMapping, exchange). }
false;private;4;17;;private Object handleMatch(Object handler, PathPattern bestMatch, PathContainer pathWithinMapping, ServerWebExchange exchange) {     // Bean name or resolved handler?     if (handler instanceof String) {         String handlerName = (String) handler.         handler = obtainApplicationContext().getBean(handlerName).     }     validateHandler(handler, exchange).     exchange.getAttributes().put(BEST_MATCHING_HANDLER_ATTRIBUTE, handler).     exchange.getAttributes().put(BEST_MATCHING_PATTERN_ATTRIBUTE, bestMatch).     exchange.getAttributes().put(PATH_WITHIN_HANDLER_MAPPING_ATTRIBUTE, pathWithinMapping).     return handler. }
true;protected;2;3;/**  * Validate the given handler against the current request.  * <p>The default implementation is empty. Can be overridden in subclasses,  * for example to enforce specific preconditions expressed in URL mappings.  * @param handler the handler object to validate  * @param exchange current exchange  */ ;/**  * Validate the given handler against the current request.  * <p>The default implementation is empty. Can be overridden in subclasses,  * for example to enforce specific preconditions expressed in URL mappings.  * @param handler the handler object to validate  * @param exchange current exchange  */ @SuppressWarnings("UnusedParameters") protected void validateHandler(Object handler, ServerWebExchange exchange) { }
true;protected;2;6;/**  * Register the specified handler for the given URL paths.  * @param urlPaths the URLs that the bean should be mapped to  * @param beanName the name of the handler bean  * @throws BeansException if the handler couldn't be registered  * @throws IllegalStateException if there is a conflicting handler registered  */ ;/**  * Register the specified handler for the given URL paths.  * @param urlPaths the URLs that the bean should be mapped to  * @param beanName the name of the handler bean  * @throws BeansException if the handler couldn't be registered  * @throws IllegalStateException if there is a conflicting handler registered  */ protected void registerHandler(String[] urlPaths, String beanName) throws BeansException, IllegalStateException {     Assert.notNull(urlPaths, "URL path array must not be null").     for (String urlPath : urlPaths) {         registerHandler(urlPath, beanName).     } }
true;protected;2;31;/**  * Register the specified handler for the given URL path.  * @param urlPath the URL the bean should be mapped to  * @param handler the handler instance or handler bean name String  * (a bean name will automatically be resolved into the corresponding handler bean)  * @throws BeansException if the handler couldn't be registered  * @throws IllegalStateException if there is a conflicting handler registered  */ ;/**  * Register the specified handler for the given URL path.  * @param urlPath the URL the bean should be mapped to  * @param handler the handler instance or handler bean name String  * (a bean name will automatically be resolved into the corresponding handler bean)  * @throws BeansException if the handler couldn't be registered  * @throws IllegalStateException if there is a conflicting handler registered  */ protected void registerHandler(String urlPath, Object handler) throws BeansException, IllegalStateException {     Assert.notNull(urlPath, "URL path must not be null").     Assert.notNull(handler, "Handler object must not be null").     Object resolvedHandler = handler.     // Parse path pattern     urlPath = prependLeadingSlash(urlPath).     PathPattern pattern = getPathPatternParser().parse(urlPath).     if (this.handlerMap.containsKey(pattern)) {         Object existingHandler = this.handlerMap.get(pattern).         if (existingHandler != null && existingHandler != resolvedHandler) {             throw new IllegalStateException("Cannot map " + getHandlerDescription(handler) + " to [" + urlPath + "]: " + "there is already " + getHandlerDescription(existingHandler) + " mapped.").         }     }     // Eagerly resolve handler if referencing singleton via name.     if (!this.lazyInitHandlers && handler instanceof String) {         String handlerName = (String) handler.         if (obtainApplicationContext().isSingleton(handlerName)) {             resolvedHandler = obtainApplicationContext().getBean(handlerName).         }     }     // Register resolved handler     this.handlerMap.put(pattern, resolvedHandler).     if (logger.isTraceEnabled()) {         logger.trace("Mapped [" + urlPath + "] onto " + getHandlerDescription(handler)).     } }
false;private;1;3;;private String getHandlerDescription(Object handler) {     return (handler instanceof String ? "'" + handler + "'" : handler.toString()). }
false;private,static;1;8;;private static String prependLeadingSlash(String pattern) {     if (StringUtils.hasLength(pattern) && !pattern.startsWith("/")) {         return "/" + pattern.     } else {         return pattern.     } }
