# id;timestamp;commentText;codeText;commentWords;codeWords
AbstractUrlHandlerMapping -> @Nullable 	protected Object lookupHandler(LookupPath lookupPath, ServerWebExchange exchange) throws Exception;1496334664;Look up a handler instance for the given URL lookup path.__<p>Supports direct matches, e.g. a registered "/test" matches "/test",_and various path pattern matches, e.g. a registered "/t*" matches_both "/test" and "/team". For details, see the PathPattern class.__@param lookupPath URL the handler is mapped to_@param exchange the current exchange_@return the associated handler instance, or {@code null} if not found_@see org.springframework.web.util.pattern.ParsingPathMatcher;@Nullable_	protected Object lookupHandler(LookupPath lookupPath, ServerWebExchange exchange) throws Exception {_		_		String urlPath = lookupPath.getPath()__		Object handler = this.handlerMap.get(urlPath)__		if (handler != null) {_			return handleMatch(handler, urlPath, urlPath, exchange)__		}__		_		List<String> matches = new ArrayList<>()__		for (String pattern : this.handlerMap.keySet()) {_			if (getPathMatcher().match(pattern, urlPath)) {_				matches.add(pattern)__			}_			else if (useTrailingSlashMatch()) {_				if (!pattern.endsWith("/") && getPathMatcher().match(pattern + "/", urlPath)) {_					matches.add(pattern +"/")__				}_			}_		}__		String bestMatch = null__		Comparator<String> comparator = getPathMatcher().getPatternComparator(urlPath)__		if (!matches.isEmpty()) {_			Collections.sort(matches, comparator)__			if (logger.isDebugEnabled()) {_				logger.debug("Matching patterns for request [" + lookupPath + "] are " + matches)__			}_			bestMatch = matches.get(0)__		}_		if (bestMatch != null) {_			handler = this.handlerMap.get(bestMatch)__			if (handler == null) {_				if (bestMatch.endsWith("/")) {_					handler = this.handlerMap.get(bestMatch.substring(0, bestMatch.length() - 1))__				}_				if (handler == null) {_					throw new IllegalStateException(_							"Could not find handler for best pattern match [" + bestMatch + "]")__				}_			}_			String pathWithinMapping = getPathMatcher().extractPathWithinPattern(bestMatch, urlPath)__			return handleMatch(handler, bestMatch, pathWithinMapping, exchange)__		}__		_		return null__	};look,up,a,handler,instance,for,the,given,url,lookup,path,p,supports,direct,matches,e,g,a,registered,test,matches,test,and,various,path,pattern,matches,e,g,a,registered,t,matches,both,test,and,team,for,details,see,the,path,pattern,class,param,lookup,path,url,the,handler,is,mapped,to,param,exchange,the,current,exchange,return,the,associated,handler,instance,or,code,null,if,not,found,see,org,springframework,web,util,pattern,parsing,path,matcher;nullable,protected,object,lookup,handler,lookup,path,lookup,path,server,web,exchange,exchange,throws,exception,string,url,path,lookup,path,get,path,object,handler,this,handler,map,get,url,path,if,handler,null,return,handle,match,handler,url,path,url,path,exchange,list,string,matches,new,array,list,for,string,pattern,this,handler,map,key,set,if,get,path,matcher,match,pattern,url,path,matches,add,pattern,else,if,use,trailing,slash,match,if,pattern,ends,with,get,path,matcher,match,pattern,url,path,matches,add,pattern,string,best,match,null,comparator,string,comparator,get,path,matcher,get,pattern,comparator,url,path,if,matches,is,empty,collections,sort,matches,comparator,if,logger,is,debug,enabled,logger,debug,matching,patterns,for,request,lookup,path,are,matches,best,match,matches,get,0,if,best,match,null,handler,this,handler,map,get,best,match,if,handler,null,if,best,match,ends,with,handler,this,handler,map,get,best,match,substring,0,best,match,length,1,if,handler,null,throw,new,illegal,state,exception,could,not,find,handler,for,best,pattern,match,best,match,string,path,within,mapping,get,path,matcher,extract,path,within,pattern,best,match,url,path,return,handle,match,handler,best,match,path,within,mapping,exchange,return,null
AbstractUrlHandlerMapping -> @Nullable 	protected Object lookupHandler(LookupPath lookupPath, ServerWebExchange exchange) throws Exception;1496430942;Look up a handler instance for the given URL lookup path.__<p>Supports direct matches, e.g. a registered "/test" matches "/test",_and various path pattern matches, e.g. a registered "/t*" matches_both "/test" and "/team". For details, see the PathPattern class.__@param lookupPath URL the handler is mapped to_@param exchange the current exchange_@return the associated handler instance, or {@code null} if not found_@see org.springframework.web.util.pattern.ParsingPathMatcher;@Nullable_	protected Object lookupHandler(LookupPath lookupPath, ServerWebExchange exchange) throws Exception {_		_		String urlPath = lookupPath.getPath()__		Object handler = this.handlerMap.get(urlPath)__		if (handler != null) {_			return handleMatch(handler, urlPath, urlPath, exchange)__		}__		_		List<String> matches = new ArrayList<>()__		for (String pattern : this.handlerMap.keySet()) {_			if (getPathMatcher().match(pattern, urlPath)) {_				matches.add(pattern)__			}_			else if (useTrailingSlashMatch()) {_				if (!pattern.endsWith("/") && getPathMatcher().match(pattern + "/", urlPath)) {_					matches.add(pattern +"/")__				}_			}_		}__		String bestMatch = null__		Comparator<String> comparator = getPathMatcher().getPatternComparator(urlPath)__		if (!matches.isEmpty()) {_			Collections.sort(matches, comparator)__			if (logger.isDebugEnabled()) {_				logger.debug("Matching patterns for request [" + lookupPath + "] are " + matches)__			}_			bestMatch = matches.get(0)__		}_		if (bestMatch != null) {_			handler = this.handlerMap.get(bestMatch)__			if (handler == null) {_				if (bestMatch.endsWith("/")) {_					handler = this.handlerMap.get(bestMatch.substring(0, bestMatch.length() - 1))__				}_				if (handler == null) {_					throw new IllegalStateException(_							"Could not find handler for best pattern match [" + bestMatch + "]")__				}_			}_			String pathWithinMapping = getPathMatcher().extractPathWithinPattern(bestMatch, urlPath)__			return handleMatch(handler, bestMatch, pathWithinMapping, exchange)__		}__		_		return null__	};look,up,a,handler,instance,for,the,given,url,lookup,path,p,supports,direct,matches,e,g,a,registered,test,matches,test,and,various,path,pattern,matches,e,g,a,registered,t,matches,both,test,and,team,for,details,see,the,path,pattern,class,param,lookup,path,url,the,handler,is,mapped,to,param,exchange,the,current,exchange,return,the,associated,handler,instance,or,code,null,if,not,found,see,org,springframework,web,util,pattern,parsing,path,matcher;nullable,protected,object,lookup,handler,lookup,path,lookup,path,server,web,exchange,exchange,throws,exception,string,url,path,lookup,path,get,path,object,handler,this,handler,map,get,url,path,if,handler,null,return,handle,match,handler,url,path,url,path,exchange,list,string,matches,new,array,list,for,string,pattern,this,handler,map,key,set,if,get,path,matcher,match,pattern,url,path,matches,add,pattern,else,if,use,trailing,slash,match,if,pattern,ends,with,get,path,matcher,match,pattern,url,path,matches,add,pattern,string,best,match,null,comparator,string,comparator,get,path,matcher,get,pattern,comparator,url,path,if,matches,is,empty,collections,sort,matches,comparator,if,logger,is,debug,enabled,logger,debug,matching,patterns,for,request,lookup,path,are,matches,best,match,matches,get,0,if,best,match,null,handler,this,handler,map,get,best,match,if,handler,null,if,best,match,ends,with,handler,this,handler,map,get,best,match,substring,0,best,match,length,1,if,handler,null,throw,new,illegal,state,exception,could,not,find,handler,for,best,pattern,match,best,match,string,path,within,mapping,get,path,matcher,extract,path,within,pattern,best,match,url,path,return,handle,match,handler,best,match,path,within,mapping,exchange,return,null
AbstractUrlHandlerMapping -> @Nullable 	protected Object lookupHandler(LookupPath lookupPath, ServerWebExchange exchange) throws Exception;1496837955;Look up a handler instance for the given URL lookup path.__<p>Supports direct matches, e.g. a registered "/test" matches "/test",_and various path pattern matches, e.g. a registered "/t*" matches_both "/test" and "/team". For details, see the PathPattern class.__@param lookupPath URL the handler is mapped to_@param exchange the current exchange_@return the associated handler instance, or {@code null} if not found_@see org.springframework.web.util.pattern.ParsingPathMatcher;@Nullable_	protected Object lookupHandler(LookupPath lookupPath, ServerWebExchange exchange) throws Exception {_		_		String urlPath = lookupPath.getPath()__		Object handler = this.handlerMap.get(urlPath)__		if (handler != null) {_			return handleMatch(handler, urlPath, urlPath, exchange)__		}__		_		List<String> matches = new ArrayList<>()__		for (String pattern : this.handlerMap.keySet()) {_			if (getPathMatcher().match(pattern, urlPath)) {_				matches.add(pattern)__			}_			else if (useTrailingSlashMatch()) {_				if (!pattern.endsWith("/") && getPathMatcher().match(pattern + "/", urlPath)) {_					matches.add(pattern +"/")__				}_			}_		}__		String bestMatch = null__		Comparator<String> comparator = getPathMatcher().getPatternComparator(urlPath)__		if (!matches.isEmpty()) {_			Collections.sort(matches, comparator)__			if (logger.isDebugEnabled()) {_				logger.debug("Matching patterns for request [" + lookupPath + "] are " + matches)__			}_			bestMatch = matches.get(0)__		}_		if (bestMatch != null) {_			handler = this.handlerMap.get(bestMatch)__			if (handler == null) {_				if (bestMatch.endsWith("/")) {_					handler = this.handlerMap.get(bestMatch.substring(0, bestMatch.length() - 1))__				}_				if (handler == null) {_					throw new IllegalStateException(_							"Could not find handler for best pattern match [" + bestMatch + "]")__				}_			}_			String pathWithinMapping = getPathMatcher().extractPathWithinPattern(bestMatch, urlPath)__			return handleMatch(handler, bestMatch, pathWithinMapping, exchange)__		}__		_		return null__	};look,up,a,handler,instance,for,the,given,url,lookup,path,p,supports,direct,matches,e,g,a,registered,test,matches,test,and,various,path,pattern,matches,e,g,a,registered,t,matches,both,test,and,team,for,details,see,the,path,pattern,class,param,lookup,path,url,the,handler,is,mapped,to,param,exchange,the,current,exchange,return,the,associated,handler,instance,or,code,null,if,not,found,see,org,springframework,web,util,pattern,parsing,path,matcher;nullable,protected,object,lookup,handler,lookup,path,lookup,path,server,web,exchange,exchange,throws,exception,string,url,path,lookup,path,get,path,object,handler,this,handler,map,get,url,path,if,handler,null,return,handle,match,handler,url,path,url,path,exchange,list,string,matches,new,array,list,for,string,pattern,this,handler,map,key,set,if,get,path,matcher,match,pattern,url,path,matches,add,pattern,else,if,use,trailing,slash,match,if,pattern,ends,with,get,path,matcher,match,pattern,url,path,matches,add,pattern,string,best,match,null,comparator,string,comparator,get,path,matcher,get,pattern,comparator,url,path,if,matches,is,empty,collections,sort,matches,comparator,if,logger,is,debug,enabled,logger,debug,matching,patterns,for,request,lookup,path,are,matches,best,match,matches,get,0,if,best,match,null,handler,this,handler,map,get,best,match,if,handler,null,if,best,match,ends,with,handler,this,handler,map,get,best,match,substring,0,best,match,length,1,if,handler,null,throw,new,illegal,state,exception,could,not,find,handler,for,best,pattern,match,best,match,string,path,within,mapping,get,path,matcher,extract,path,within,pattern,best,match,url,path,return,handle,match,handler,best,match,path,within,mapping,exchange,return,null
AbstractUrlHandlerMapping -> @Nullable 	protected Object lookupHandler(PathContainer lookupPath, ServerWebExchange exchange) throws Exception;1498953917;Look up a handler instance for the given URL lookup path._<p>Supports direct matches, e.g. a registered "/test" matches "/test",_and various path pattern matches, e.g. a registered "/t*" matches_both "/test" and "/team". For details, see the PathPattern class._@param lookupPath URL the handler is mapped to_@param exchange the current exchange_@return the associated handler instance, or {@code null} if not found_@see org.springframework.web.util.pattern.PathPattern;@Nullable_	protected Object lookupHandler(PathContainer lookupPath, ServerWebExchange exchange) throws Exception {_		if (this.patternRegistry != null) {_			PathMatchResult<Object> bestMatch = this.patternRegistry.findFirstMatch(lookupPath)__			if (bestMatch != null) {_				if (logger.isDebugEnabled()) {_					logger.debug("Matching patterns for request [" + lookupPath + "] are " + bestMatch)__				}_				PathContainer pathWithinMapping = bestMatch.getPattern().extractPathWithinPattern(lookupPath)__				Object handler = bestMatch.getHandler()__				return handleMatch(handler, bestMatch.getPattern(), pathWithinMapping, exchange)__			}_		}__		_		return null__	};look,up,a,handler,instance,for,the,given,url,lookup,path,p,supports,direct,matches,e,g,a,registered,test,matches,test,and,various,path,pattern,matches,e,g,a,registered,t,matches,both,test,and,team,for,details,see,the,path,pattern,class,param,lookup,path,url,the,handler,is,mapped,to,param,exchange,the,current,exchange,return,the,associated,handler,instance,or,code,null,if,not,found,see,org,springframework,web,util,pattern,path,pattern;nullable,protected,object,lookup,handler,path,container,lookup,path,server,web,exchange,exchange,throws,exception,if,this,pattern,registry,null,path,match,result,object,best,match,this,pattern,registry,find,first,match,lookup,path,if,best,match,null,if,logger,is,debug,enabled,logger,debug,matching,patterns,for,request,lookup,path,are,best,match,path,container,path,within,mapping,best,match,get,pattern,extract,path,within,pattern,lookup,path,object,handler,best,match,get,handler,return,handle,match,handler,best,match,get,pattern,path,within,mapping,exchange,return,null
AbstractUrlHandlerMapping -> @Nullable 	protected Object lookupHandler(PathContainer lookupPath, ServerWebExchange exchange) throws Exception;1520529117;Look up a handler instance for the given URL lookup path._<p>Supports direct matches, e.g. a registered "/test" matches "/test",_and various path pattern matches, e.g. a registered "/t*" matches_both "/test" and "/team". For details, see the PathPattern class._@param lookupPath URL the handler is mapped to_@param exchange the current exchange_@return the associated handler instance, or {@code null} if not found_@see org.springframework.web.util.pattern.PathPattern;@Nullable_	protected Object lookupHandler(PathContainer lookupPath, ServerWebExchange exchange) throws Exception {_		return this.handlerMap.entrySet().stream()_				.filter(entry -> entry.getKey().matches(lookupPath))_				.sorted((entry1, entry2) ->_						PathPattern.SPECIFICITY_COMPARATOR.compare(entry1.getKey(), entry2.getKey()))_				.findFirst()_				.map(entry -> {_					PathPattern pattern = entry.getKey()__					if (logger.isDebugEnabled()) {_						logger.debug("Matching pattern for request [" + lookupPath + "] is " + pattern)__					}_					PathContainer pathWithinMapping = pattern.extractPathWithinPattern(lookupPath)__					return handleMatch(entry.getValue(), pattern, pathWithinMapping, exchange)__				})_				.orElse(null)__	};look,up,a,handler,instance,for,the,given,url,lookup,path,p,supports,direct,matches,e,g,a,registered,test,matches,test,and,various,path,pattern,matches,e,g,a,registered,t,matches,both,test,and,team,for,details,see,the,path,pattern,class,param,lookup,path,url,the,handler,is,mapped,to,param,exchange,the,current,exchange,return,the,associated,handler,instance,or,code,null,if,not,found,see,org,springframework,web,util,pattern,path,pattern;nullable,protected,object,lookup,handler,path,container,lookup,path,server,web,exchange,exchange,throws,exception,return,this,handler,map,entry,set,stream,filter,entry,entry,get,key,matches,lookup,path,sorted,entry1,entry2,path,pattern,compare,entry1,get,key,entry2,get,key,find,first,map,entry,path,pattern,pattern,entry,get,key,if,logger,is,debug,enabled,logger,debug,matching,pattern,for,request,lookup,path,is,pattern,path,container,path,within,mapping,pattern,extract,path,within,pattern,lookup,path,return,handle,match,entry,get,value,pattern,path,within,mapping,exchange,or,else,null
AbstractUrlHandlerMapping -> @Nullable 	protected Object lookupHandler(PathContainer lookupPath, ServerWebExchange exchange) throws Exception;1529721864;Look up a handler instance for the given URL lookup path._<p>Supports direct matches, e.g. a registered "/test" matches "/test",_and various path pattern matches, e.g. a registered "/t*" matches_both "/test" and "/team". For details, see the PathPattern class._@param lookupPath URL the handler is mapped to_@param exchange the current exchange_@return the associated handler instance, or {@code null} if not found_@see org.springframework.web.util.pattern.PathPattern;@Nullable_	protected Object lookupHandler(PathContainer lookupPath, ServerWebExchange exchange) throws Exception {__		List<PathPattern> matches = this.handlerMap.keySet().stream()_				.filter(key -> key.matches(lookupPath))_				.collect(Collectors.toList())___		if (matches.isEmpty()) {_			return null__		}__		if (matches.size() > 1) {_			matches.sort(PathPattern.SPECIFICITY_COMPARATOR)__			if (logger.isTraceEnabled()) {_				logger.debug("Matching patterns " + matches)__			}_		}__		PathPattern pattern = matches.get(0)__		PathContainer pathWithinMapping = pattern.extractPathWithinPattern(lookupPath)__		return handleMatch(this.handlerMap.get(pattern), pattern, pathWithinMapping, exchange)__	};look,up,a,handler,instance,for,the,given,url,lookup,path,p,supports,direct,matches,e,g,a,registered,test,matches,test,and,various,path,pattern,matches,e,g,a,registered,t,matches,both,test,and,team,for,details,see,the,path,pattern,class,param,lookup,path,url,the,handler,is,mapped,to,param,exchange,the,current,exchange,return,the,associated,handler,instance,or,code,null,if,not,found,see,org,springframework,web,util,pattern,path,pattern;nullable,protected,object,lookup,handler,path,container,lookup,path,server,web,exchange,exchange,throws,exception,list,path,pattern,matches,this,handler,map,key,set,stream,filter,key,key,matches,lookup,path,collect,collectors,to,list,if,matches,is,empty,return,null,if,matches,size,1,matches,sort,path,pattern,if,logger,is,trace,enabled,logger,debug,matching,patterns,matches,path,pattern,pattern,matches,get,0,path,container,path,within,mapping,pattern,extract,path,within,pattern,lookup,path,return,handle,match,this,handler,map,get,pattern,pattern,path,within,mapping,exchange
AbstractUrlHandlerMapping -> @Nullable 	protected Object lookupHandler(PathContainer lookupPath, ServerWebExchange exchange) throws Exception;1530174524;Look up a handler instance for the given URL lookup path._<p>Supports direct matches, e.g. a registered "/test" matches "/test",_and various path pattern matches, e.g. a registered "/t*" matches_both "/test" and "/team". For details, see the PathPattern class._@param lookupPath the URL the handler is mapped to_@param exchange the current exchange_@return the associated handler instance, or {@code null} if not found_@see org.springframework.web.util.pattern.PathPattern;@Nullable_	protected Object lookupHandler(PathContainer lookupPath, ServerWebExchange exchange) throws Exception {__		List<PathPattern> matches = this.handlerMap.keySet().stream()_				.filter(key -> key.matches(lookupPath))_				.collect(Collectors.toList())___		if (matches.isEmpty()) {_			return null__		}__		if (matches.size() > 1) {_			matches.sort(PathPattern.SPECIFICITY_COMPARATOR)__			if (logger.isTraceEnabled()) {_				logger.debug("Matching patterns " + matches)__			}_		}__		PathPattern pattern = matches.get(0)__		PathContainer pathWithinMapping = pattern.extractPathWithinPattern(lookupPath)__		return handleMatch(this.handlerMap.get(pattern), pattern, pathWithinMapping, exchange)__	};look,up,a,handler,instance,for,the,given,url,lookup,path,p,supports,direct,matches,e,g,a,registered,test,matches,test,and,various,path,pattern,matches,e,g,a,registered,t,matches,both,test,and,team,for,details,see,the,path,pattern,class,param,lookup,path,the,url,the,handler,is,mapped,to,param,exchange,the,current,exchange,return,the,associated,handler,instance,or,code,null,if,not,found,see,org,springframework,web,util,pattern,path,pattern;nullable,protected,object,lookup,handler,path,container,lookup,path,server,web,exchange,exchange,throws,exception,list,path,pattern,matches,this,handler,map,key,set,stream,filter,key,key,matches,lookup,path,collect,collectors,to,list,if,matches,is,empty,return,null,if,matches,size,1,matches,sort,path,pattern,if,logger,is,trace,enabled,logger,debug,matching,patterns,matches,path,pattern,pattern,matches,get,0,path,container,path,within,mapping,pattern,extract,path,within,pattern,lookup,path,return,handle,match,this,handler,map,get,pattern,pattern,path,within,mapping,exchange
AbstractUrlHandlerMapping -> @Nullable 	protected Object lookupHandler(PathContainer lookupPath, ServerWebExchange exchange) throws Exception;1530793633;Look up a handler instance for the given URL lookup path._<p>Supports direct matches, e.g. a registered "/test" matches "/test",_and various path pattern matches, e.g. a registered "/t*" matches_both "/test" and "/team". For details, see the PathPattern class._@param lookupPath the URL the handler is mapped to_@param exchange the current exchange_@return the associated handler instance, or {@code null} if not found_@see org.springframework.web.util.pattern.PathPattern;@Nullable_	protected Object lookupHandler(PathContainer lookupPath, ServerWebExchange exchange) throws Exception {__		List<PathPattern> matches = this.handlerMap.keySet().stream()_				.filter(key -> key.matches(lookupPath))_				.collect(Collectors.toList())___		if (matches.isEmpty()) {_			return null__		}__		if (matches.size() > 1) {_			matches.sort(PathPattern.SPECIFICITY_COMPARATOR)__			if (logger.isTraceEnabled()) {_				logger.debug(exchange.getLogPrefix() + "Matching patterns " + matches)__			}_		}__		PathPattern pattern = matches.get(0)__		PathContainer pathWithinMapping = pattern.extractPathWithinPattern(lookupPath)__		return handleMatch(this.handlerMap.get(pattern), pattern, pathWithinMapping, exchange)__	};look,up,a,handler,instance,for,the,given,url,lookup,path,p,supports,direct,matches,e,g,a,registered,test,matches,test,and,various,path,pattern,matches,e,g,a,registered,t,matches,both,test,and,team,for,details,see,the,path,pattern,class,param,lookup,path,the,url,the,handler,is,mapped,to,param,exchange,the,current,exchange,return,the,associated,handler,instance,or,code,null,if,not,found,see,org,springframework,web,util,pattern,path,pattern;nullable,protected,object,lookup,handler,path,container,lookup,path,server,web,exchange,exchange,throws,exception,list,path,pattern,matches,this,handler,map,key,set,stream,filter,key,key,matches,lookup,path,collect,collectors,to,list,if,matches,is,empty,return,null,if,matches,size,1,matches,sort,path,pattern,if,logger,is,trace,enabled,logger,debug,exchange,get,log,prefix,matching,patterns,matches,path,pattern,pattern,matches,get,0,path,container,path,within,mapping,pattern,extract,path,within,pattern,lookup,path,return,handle,match,this,handler,map,get,pattern,pattern,path,within,mapping,exchange
AbstractUrlHandlerMapping -> @Nullable 	protected Object lookupHandler(PathContainer lookupPath, ServerWebExchange exchange) 			throws Exception;1499679438;Look up a handler instance for the given URL lookup path._<p>Supports direct matches, e.g. a registered "/test" matches "/test",_and various path pattern matches, e.g. a registered "/t*" matches_both "/test" and "/team". For details, see the PathPattern class._@param lookupPath URL the handler is mapped to_@param exchange the current exchange_@return the associated handler instance, or {@code null} if not found_@see org.springframework.web.util.pattern.PathPattern;@Nullable_	protected Object lookupHandler(PathContainer lookupPath, ServerWebExchange exchange)_			throws Exception {__		return this.handlerMap.entrySet().stream()_				.filter(entry -> entry.getKey().matches(lookupPath))_				.sorted(Comparator.comparing(Map.Entry::getKey))_				.findFirst()_				.map(entry -> {_					PathPattern pattern = entry.getKey()__					if (logger.isDebugEnabled()) {_						logger.debug("Matching pattern for request [" + lookupPath + "] is " + pattern)__					}_					PathContainer pathWithinMapping = pattern.extractPathWithinPattern(lookupPath)__					return handleMatch(entry.getValue(), pattern, pathWithinMapping, exchange)__				})_				.orElse(null)__	};look,up,a,handler,instance,for,the,given,url,lookup,path,p,supports,direct,matches,e,g,a,registered,test,matches,test,and,various,path,pattern,matches,e,g,a,registered,t,matches,both,test,and,team,for,details,see,the,path,pattern,class,param,lookup,path,url,the,handler,is,mapped,to,param,exchange,the,current,exchange,return,the,associated,handler,instance,or,code,null,if,not,found,see,org,springframework,web,util,pattern,path,pattern;nullable,protected,object,lookup,handler,path,container,lookup,path,server,web,exchange,exchange,throws,exception,return,this,handler,map,entry,set,stream,filter,entry,entry,get,key,matches,lookup,path,sorted,comparator,comparing,map,entry,get,key,find,first,map,entry,path,pattern,pattern,entry,get,key,if,logger,is,debug,enabled,logger,debug,matching,pattern,for,request,lookup,path,is,pattern,path,container,path,within,mapping,pattern,extract,path,within,pattern,lookup,path,return,handle,match,entry,get,value,pattern,path,within,mapping,exchange,or,else,null
AbstractUrlHandlerMapping -> @Nullable 	protected Object lookupHandler(PathContainer lookupPath, ServerWebExchange exchange) 			throws Exception;1501237594;Look up a handler instance for the given URL lookup path._<p>Supports direct matches, e.g. a registered "/test" matches "/test",_and various path pattern matches, e.g. a registered "/t*" matches_both "/test" and "/team". For details, see the PathPattern class._@param lookupPath URL the handler is mapped to_@param exchange the current exchange_@return the associated handler instance, or {@code null} if not found_@see org.springframework.web.util.pattern.PathPattern;@Nullable_	protected Object lookupHandler(PathContainer lookupPath, ServerWebExchange exchange)_			throws Exception {__		return this.handlerMap.entrySet().stream()_				.filter(entry -> entry.getKey().matches(lookupPath))_				.sorted(Comparator.comparing(Map.Entry::getKey))_				.findFirst()_				.map(entry -> {_					PathPattern pattern = entry.getKey()__					if (logger.isDebugEnabled()) {_						logger.debug("Matching pattern for request [" + lookupPath + "] is " + pattern)__					}_					PathContainer pathWithinMapping = pattern.extractPathWithinPattern(lookupPath)__					return handleMatch(entry.getValue(), pattern, pathWithinMapping, exchange)__				})_				.orElse(null)__	};look,up,a,handler,instance,for,the,given,url,lookup,path,p,supports,direct,matches,e,g,a,registered,test,matches,test,and,various,path,pattern,matches,e,g,a,registered,t,matches,both,test,and,team,for,details,see,the,path,pattern,class,param,lookup,path,url,the,handler,is,mapped,to,param,exchange,the,current,exchange,return,the,associated,handler,instance,or,code,null,if,not,found,see,org,springframework,web,util,pattern,path,pattern;nullable,protected,object,lookup,handler,path,container,lookup,path,server,web,exchange,exchange,throws,exception,return,this,handler,map,entry,set,stream,filter,entry,entry,get,key,matches,lookup,path,sorted,comparator,comparing,map,entry,get,key,find,first,map,entry,path,pattern,pattern,entry,get,key,if,logger,is,debug,enabled,logger,debug,matching,pattern,for,request,lookup,path,is,pattern,path,container,path,within,mapping,pattern,extract,path,within,pattern,lookup,path,return,handle,match,entry,get,value,pattern,path,within,mapping,exchange,or,else,null
AbstractUrlHandlerMapping -> @Nullable 	protected Object lookupHandler(PathContainer lookupPath, ServerWebExchange exchange) 			throws Exception;1501690296;Look up a handler instance for the given URL lookup path._<p>Supports direct matches, e.g. a registered "/test" matches "/test",_and various path pattern matches, e.g. a registered "/t*" matches_both "/test" and "/team". For details, see the PathPattern class._@param lookupPath URL the handler is mapped to_@param exchange the current exchange_@return the associated handler instance, or {@code null} if not found_@see org.springframework.web.util.pattern.PathPattern;@Nullable_	protected Object lookupHandler(PathContainer lookupPath, ServerWebExchange exchange)_			throws Exception {__		return this.handlerMap.entrySet().stream()_				.filter(entry -> entry.getKey().matches(lookupPath))_				.sorted((entry1, entry2) ->_						PathPattern.SPECIFICITY_COMPARATOR.compare(entry1.getKey(), entry2.getKey()))_				.findFirst()_				.map(entry -> {_					PathPattern pattern = entry.getKey()__					if (logger.isDebugEnabled()) {_						logger.debug("Matching pattern for request [" + lookupPath + "] is " + pattern)__					}_					PathContainer pathWithinMapping = pattern.extractPathWithinPattern(lookupPath)__					return handleMatch(entry.getValue(), pattern, pathWithinMapping, exchange)__				})_				.orElse(null)__	};look,up,a,handler,instance,for,the,given,url,lookup,path,p,supports,direct,matches,e,g,a,registered,test,matches,test,and,various,path,pattern,matches,e,g,a,registered,t,matches,both,test,and,team,for,details,see,the,path,pattern,class,param,lookup,path,url,the,handler,is,mapped,to,param,exchange,the,current,exchange,return,the,associated,handler,instance,or,code,null,if,not,found,see,org,springframework,web,util,pattern,path,pattern;nullable,protected,object,lookup,handler,path,container,lookup,path,server,web,exchange,exchange,throws,exception,return,this,handler,map,entry,set,stream,filter,entry,entry,get,key,matches,lookup,path,sorted,entry1,entry2,path,pattern,compare,entry1,get,key,entry2,get,key,find,first,map,entry,path,pattern,pattern,entry,get,key,if,logger,is,debug,enabled,logger,debug,matching,pattern,for,request,lookup,path,is,pattern,path,container,path,within,mapping,pattern,extract,path,within,pattern,lookup,path,return,handle,match,entry,get,value,pattern,path,within,mapping,exchange,or,else,null
AbstractUrlHandlerMapping -> @Nullable 	protected Object lookupHandler(PathContainer lookupPath, ServerWebExchange exchange) 			throws Exception;1520075565;Look up a handler instance for the given URL lookup path._<p>Supports direct matches, e.g. a registered "/test" matches "/test",_and various path pattern matches, e.g. a registered "/t*" matches_both "/test" and "/team". For details, see the PathPattern class._@param lookupPath URL the handler is mapped to_@param exchange the current exchange_@return the associated handler instance, or {@code null} if not found_@see org.springframework.web.util.pattern.PathPattern;@Nullable_	protected Object lookupHandler(PathContainer lookupPath, ServerWebExchange exchange)_			throws Exception {__		return this.handlerMap.entrySet().stream()_				.filter(entry -> entry.getKey().matches(lookupPath))_				.sorted((entry1, entry2) ->_						PathPattern.SPECIFICITY_COMPARATOR.compare(entry1.getKey(), entry2.getKey()))_				.findFirst()_				.map(entry -> {_					PathPattern pattern = entry.getKey()__					if (logger.isDebugEnabled()) {_						logger.debug("Matching pattern for request [" + lookupPath + "] is " + pattern)__					}_					PathContainer pathWithinMapping = pattern.extractPathWithinPattern(lookupPath)__					return handleMatch(entry.getValue(), pattern, pathWithinMapping, exchange)__				})_				.orElse(null)__	};look,up,a,handler,instance,for,the,given,url,lookup,path,p,supports,direct,matches,e,g,a,registered,test,matches,test,and,various,path,pattern,matches,e,g,a,registered,t,matches,both,test,and,team,for,details,see,the,path,pattern,class,param,lookup,path,url,the,handler,is,mapped,to,param,exchange,the,current,exchange,return,the,associated,handler,instance,or,code,null,if,not,found,see,org,springframework,web,util,pattern,path,pattern;nullable,protected,object,lookup,handler,path,container,lookup,path,server,web,exchange,exchange,throws,exception,return,this,handler,map,entry,set,stream,filter,entry,entry,get,key,matches,lookup,path,sorted,entry1,entry2,path,pattern,compare,entry1,get,key,entry2,get,key,find,first,map,entry,path,pattern,pattern,entry,get,key,if,logger,is,debug,enabled,logger,debug,matching,pattern,for,request,lookup,path,is,pattern,path,container,path,within,mapping,pattern,extract,path,within,pattern,lookup,path,return,handle,match,entry,get,value,pattern,path,within,mapping,exchange,or,else,null
AbstractUrlHandlerMapping -> protected Object lookupHandler(String urlPath, ServerWebExchange exchange) throws Exception;1485986572;Look up a handler instance for the given URL path.__<p>Supports direct matches, e.g. a registered "/test" matches "/test",_and various Ant-style pattern matches, e.g. a registered "/t*" matches_both "/test" and "/team". For details, see the AntPathMatcher class.__<p>Looks for the most exact pattern, where most exact is defined as_the longest path pattern.__@param urlPath URL the bean is mapped to_@param exchange the current exchange_@return the associated handler instance, or {@code null} if not found_@see org.springframework.util.AntPathMatcher;protected Object lookupHandler(String urlPath, ServerWebExchange exchange) throws Exception {_		_		Object handler = this.handlerMap.get(urlPath)__		if (handler != null) {_			return handleMatch(handler, urlPath, urlPath, exchange)__		}__		_		List<String> matches = new ArrayList<>()__		for (String pattern : this.handlerMap.keySet()) {_			if (getPathMatcher().match(pattern, urlPath)) {_				matches.add(pattern)__			}_			else if (useTrailingSlashMatch()) {_				if (!pattern.endsWith("/") && getPathMatcher().match(pattern + "/", urlPath)) {_					matches.add(pattern +"/")__				}_			}_		}__		String bestMatch = null__		Comparator<String> comparator = getPathMatcher().getPatternComparator(urlPath)__		if (!matches.isEmpty()) {_			Collections.sort(matches, comparator)__			if (logger.isDebugEnabled()) {_				logger.debug("Matching patterns for request [" + urlPath + "] are " + matches)__			}_			bestMatch = matches.get(0)__		}_		if (bestMatch != null) {_			handler = this.handlerMap.get(bestMatch)__			if (handler == null) {_				if (bestMatch.endsWith("/")) {_					handler = this.handlerMap.get(bestMatch.substring(0, bestMatch.length() - 1))__				}_				if (handler == null) {_					throw new IllegalStateException(_							"Could not find handler for best pattern match [" + bestMatch + "]")__				}_			}_			String pathWithinMapping = getPathMatcher().extractPathWithinPattern(bestMatch, urlPath)__			return handleMatch(handler, bestMatch, pathWithinMapping, exchange)__		}__		_		return null__	};look,up,a,handler,instance,for,the,given,url,path,p,supports,direct,matches,e,g,a,registered,test,matches,test,and,various,ant,style,pattern,matches,e,g,a,registered,t,matches,both,test,and,team,for,details,see,the,ant,path,matcher,class,p,looks,for,the,most,exact,pattern,where,most,exact,is,defined,as,the,longest,path,pattern,param,url,path,url,the,bean,is,mapped,to,param,exchange,the,current,exchange,return,the,associated,handler,instance,or,code,null,if,not,found,see,org,springframework,util,ant,path,matcher;protected,object,lookup,handler,string,url,path,server,web,exchange,exchange,throws,exception,object,handler,this,handler,map,get,url,path,if,handler,null,return,handle,match,handler,url,path,url,path,exchange,list,string,matches,new,array,list,for,string,pattern,this,handler,map,key,set,if,get,path,matcher,match,pattern,url,path,matches,add,pattern,else,if,use,trailing,slash,match,if,pattern,ends,with,get,path,matcher,match,pattern,url,path,matches,add,pattern,string,best,match,null,comparator,string,comparator,get,path,matcher,get,pattern,comparator,url,path,if,matches,is,empty,collections,sort,matches,comparator,if,logger,is,debug,enabled,logger,debug,matching,patterns,for,request,url,path,are,matches,best,match,matches,get,0,if,best,match,null,handler,this,handler,map,get,best,match,if,handler,null,if,best,match,ends,with,handler,this,handler,map,get,best,match,substring,0,best,match,length,1,if,handler,null,throw,new,illegal,state,exception,could,not,find,handler,for,best,pattern,match,best,match,string,path,within,mapping,get,path,matcher,extract,path,within,pattern,best,match,url,path,return,handle,match,handler,best,match,path,within,mapping,exchange,return,null
AbstractUrlHandlerMapping -> protected Object lookupHandler(String urlPath, ServerWebExchange exchange) throws Exception;1486635693;Look up a handler instance for the given URL path.__<p>Supports direct matches, e.g. a registered "/test" matches "/test",_and various Ant-style pattern matches, e.g. a registered "/t*" matches_both "/test" and "/team". For details, see the PathPattern class.__<p>Looks for the most exact pattern, where most exact is defined as_the longest path pattern.__@param urlPath URL the bean is mapped to_@param exchange the current exchange_@return the associated handler instance, or {@code null} if not found_@see org.springframework.util.AntPathMatcher;protected Object lookupHandler(String urlPath, ServerWebExchange exchange) throws Exception {_		SortedSet<PathPattern> matches = this.patternRegistry.findMatches(urlPath)__		if (!matches.isEmpty()) {_			if (logger.isDebugEnabled()) {_				logger.debug("Matching patterns for request [" + urlPath + "] are " + matches)__			}_			PathPattern bestMatch = matches.first()__			String pathWithinMapping = bestMatch.extractPathWithinPattern(urlPath)__			return handleMatch(this.handlerMap.get(bestMatch), bestMatch, pathWithinMapping, exchange)__		}__		_		return null__	};look,up,a,handler,instance,for,the,given,url,path,p,supports,direct,matches,e,g,a,registered,test,matches,test,and,various,ant,style,pattern,matches,e,g,a,registered,t,matches,both,test,and,team,for,details,see,the,path,pattern,class,p,looks,for,the,most,exact,pattern,where,most,exact,is,defined,as,the,longest,path,pattern,param,url,path,url,the,bean,is,mapped,to,param,exchange,the,current,exchange,return,the,associated,handler,instance,or,code,null,if,not,found,see,org,springframework,util,ant,path,matcher;protected,object,lookup,handler,string,url,path,server,web,exchange,exchange,throws,exception,sorted,set,path,pattern,matches,this,pattern,registry,find,matches,url,path,if,matches,is,empty,if,logger,is,debug,enabled,logger,debug,matching,patterns,for,request,url,path,are,matches,path,pattern,best,match,matches,first,string,path,within,mapping,best,match,extract,path,within,pattern,url,path,return,handle,match,this,handler,map,get,best,match,best,match,path,within,mapping,exchange,return,null
AbstractUrlHandlerMapping -> protected Object lookupHandler(String urlPath, ServerWebExchange exchange) throws Exception;1486747801;Look up a handler instance for the given URL path.__<p>Supports direct matches, e.g. a registered "/test" matches "/test",_and various Ant-style pattern matches, e.g. a registered "/t*" matches_both "/test" and "/team". For details, see the AntPathMatcher class.__<p>Looks for the most exact pattern, where most exact is defined as_the longest path pattern.__@param urlPath URL the bean is mapped to_@param exchange the current exchange_@return the associated handler instance, or {@code null} if not found_@see org.springframework.util.AntPathMatcher;protected Object lookupHandler(String urlPath, ServerWebExchange exchange) throws Exception {_		_		Object handler = this.handlerMap.get(urlPath)__		if (handler != null) {_			return handleMatch(handler, urlPath, urlPath, exchange)__		}__		_		List<String> matches = new ArrayList<>()__		for (String pattern : this.handlerMap.keySet()) {_			if (getPathMatcher().match(pattern, urlPath)) {_				matches.add(pattern)__			}_			else if (useTrailingSlashMatch()) {_				if (!pattern.endsWith("/") && getPathMatcher().match(pattern + "/", urlPath)) {_					matches.add(pattern +"/")__				}_			}_		}__		String bestMatch = null__		Comparator<String> comparator = getPathMatcher().getPatternComparator(urlPath)__		if (!matches.isEmpty()) {_			Collections.sort(matches, comparator)__			if (logger.isDebugEnabled()) {_				logger.debug("Matching patterns for request [" + urlPath + "] are " + matches)__			}_			bestMatch = matches.get(0)__		}_		if (bestMatch != null) {_			handler = this.handlerMap.get(bestMatch)__			if (handler == null) {_				if (bestMatch.endsWith("/")) {_					handler = this.handlerMap.get(bestMatch.substring(0, bestMatch.length() - 1))__				}_				if (handler == null) {_					throw new IllegalStateException(_							"Could not find handler for best pattern match [" + bestMatch + "]")__				}_			}_			String pathWithinMapping = getPathMatcher().extractPathWithinPattern(bestMatch, urlPath)__			return handleMatch(handler, bestMatch, pathWithinMapping, exchange)__		}__		_		return null__	};look,up,a,handler,instance,for,the,given,url,path,p,supports,direct,matches,e,g,a,registered,test,matches,test,and,various,ant,style,pattern,matches,e,g,a,registered,t,matches,both,test,and,team,for,details,see,the,ant,path,matcher,class,p,looks,for,the,most,exact,pattern,where,most,exact,is,defined,as,the,longest,path,pattern,param,url,path,url,the,bean,is,mapped,to,param,exchange,the,current,exchange,return,the,associated,handler,instance,or,code,null,if,not,found,see,org,springframework,util,ant,path,matcher;protected,object,lookup,handler,string,url,path,server,web,exchange,exchange,throws,exception,object,handler,this,handler,map,get,url,path,if,handler,null,return,handle,match,handler,url,path,url,path,exchange,list,string,matches,new,array,list,for,string,pattern,this,handler,map,key,set,if,get,path,matcher,match,pattern,url,path,matches,add,pattern,else,if,use,trailing,slash,match,if,pattern,ends,with,get,path,matcher,match,pattern,url,path,matches,add,pattern,string,best,match,null,comparator,string,comparator,get,path,matcher,get,pattern,comparator,url,path,if,matches,is,empty,collections,sort,matches,comparator,if,logger,is,debug,enabled,logger,debug,matching,patterns,for,request,url,path,are,matches,best,match,matches,get,0,if,best,match,null,handler,this,handler,map,get,best,match,if,handler,null,if,best,match,ends,with,handler,this,handler,map,get,best,match,substring,0,best,match,length,1,if,handler,null,throw,new,illegal,state,exception,could,not,find,handler,for,best,pattern,match,best,match,string,path,within,mapping,get,path,matcher,extract,path,within,pattern,best,match,url,path,return,handle,match,handler,best,match,path,within,mapping,exchange,return,null
AbstractUrlHandlerMapping -> protected Object lookupHandler(String urlPath, ServerWebExchange exchange) throws Exception;1486747828;Look up a handler instance for the given URL path.__<p>Supports direct matches, e.g. a registered "/test" matches "/test",_and various Ant-style pattern matches, e.g. a registered "/t*" matches_both "/test" and "/team". For details, see the AntPathMatcher class.__<p>Looks for the most exact pattern, where most exact is defined as_the longest path pattern.__@param urlPath URL the bean is mapped to_@param exchange the current exchange_@return the associated handler instance, or {@code null} if not found_@see org.springframework.web.util.ParsingPathMatcher;protected Object lookupHandler(String urlPath, ServerWebExchange exchange) throws Exception {_		_		Object handler = this.handlerMap.get(urlPath)__		if (handler != null) {_			return handleMatch(handler, urlPath, urlPath, exchange)__		}__		_		List<String> matches = new ArrayList<>()__		for (String pattern : this.handlerMap.keySet()) {_			if (getPathMatcher().match(pattern, urlPath)) {_				matches.add(pattern)__			}_			else if (useTrailingSlashMatch()) {_				if (!pattern.endsWith("/") && getPathMatcher().match(pattern + "/", urlPath)) {_					matches.add(pattern +"/")__				}_			}_		}__		String bestMatch = null__		Comparator<String> comparator = getPathMatcher().getPatternComparator(urlPath)__		if (!matches.isEmpty()) {_			Collections.sort(matches, comparator)__			if (logger.isDebugEnabled()) {_				logger.debug("Matching patterns for request [" + urlPath + "] are " + matches)__			}_			bestMatch = matches.get(0)__		}_		if (bestMatch != null) {_			handler = this.handlerMap.get(bestMatch)__			if (handler == null) {_				if (bestMatch.endsWith("/")) {_					handler = this.handlerMap.get(bestMatch.substring(0, bestMatch.length() - 1))__				}_				if (handler == null) {_					throw new IllegalStateException(_							"Could not find handler for best pattern match [" + bestMatch + "]")__				}_			}_			String pathWithinMapping = getPathMatcher().extractPathWithinPattern(bestMatch, urlPath)__			return handleMatch(handler, bestMatch, pathWithinMapping, exchange)__		}__		_		return null__	};look,up,a,handler,instance,for,the,given,url,path,p,supports,direct,matches,e,g,a,registered,test,matches,test,and,various,ant,style,pattern,matches,e,g,a,registered,t,matches,both,test,and,team,for,details,see,the,ant,path,matcher,class,p,looks,for,the,most,exact,pattern,where,most,exact,is,defined,as,the,longest,path,pattern,param,url,path,url,the,bean,is,mapped,to,param,exchange,the,current,exchange,return,the,associated,handler,instance,or,code,null,if,not,found,see,org,springframework,web,util,parsing,path,matcher;protected,object,lookup,handler,string,url,path,server,web,exchange,exchange,throws,exception,object,handler,this,handler,map,get,url,path,if,handler,null,return,handle,match,handler,url,path,url,path,exchange,list,string,matches,new,array,list,for,string,pattern,this,handler,map,key,set,if,get,path,matcher,match,pattern,url,path,matches,add,pattern,else,if,use,trailing,slash,match,if,pattern,ends,with,get,path,matcher,match,pattern,url,path,matches,add,pattern,string,best,match,null,comparator,string,comparator,get,path,matcher,get,pattern,comparator,url,path,if,matches,is,empty,collections,sort,matches,comparator,if,logger,is,debug,enabled,logger,debug,matching,patterns,for,request,url,path,are,matches,best,match,matches,get,0,if,best,match,null,handler,this,handler,map,get,best,match,if,handler,null,if,best,match,ends,with,handler,this,handler,map,get,best,match,substring,0,best,match,length,1,if,handler,null,throw,new,illegal,state,exception,could,not,find,handler,for,best,pattern,match,best,match,string,path,within,mapping,get,path,matcher,extract,path,within,pattern,best,match,url,path,return,handle,match,handler,best,match,path,within,mapping,exchange,return,null
AbstractUrlHandlerMapping -> protected Object lookupHandler(String urlPath, ServerWebExchange exchange) throws Exception;1495035625;Look up a handler instance for the given URL path._<p>Supports direct matches, e.g. a registered "/test" matches "/test",_and various Ant-style pattern matches, e.g. a registered "/t*" matches_both "/test" and "/team". For details, see the AntPathMatcher class._<p>Looks for the most exact pattern, where most exact is defined as_the longest path pattern._@param urlPath URL the bean is mapped to_@param exchange the current exchange_@return the associated handler instance, or {@code null} if not found_@see org.springframework.web.util.pattern.ParsingPathMatcher;protected Object lookupHandler(String urlPath, ServerWebExchange exchange) throws Exception {_		_		Object handler = this.handlerMap.get(urlPath)__		if (handler != null) {_			return handleMatch(handler, urlPath, urlPath, exchange)__		}__		_		List<String> matches = new ArrayList<>()__		for (String pattern : this.handlerMap.keySet()) {_			if (getPathMatcher().match(pattern, urlPath)) {_				matches.add(pattern)__			}_			else if (useTrailingSlashMatch()) {_				if (!pattern.endsWith("/") && getPathMatcher().match(pattern + "/", urlPath)) {_					matches.add(pattern +"/")__				}_			}_		}__		String bestMatch = null__		Comparator<String> comparator = getPathMatcher().getPatternComparator(urlPath)__		if (!matches.isEmpty()) {_			Collections.sort(matches, comparator)__			if (logger.isDebugEnabled()) {_				logger.debug("Matching patterns for request [" + urlPath + "] are " + matches)__			}_			bestMatch = matches.get(0)__		}_		if (bestMatch != null) {_			handler = this.handlerMap.get(bestMatch)__			if (handler == null) {_				if (bestMatch.endsWith("/")) {_					handler = this.handlerMap.get(bestMatch.substring(0, bestMatch.length() - 1))__				}_				if (handler == null) {_					throw new IllegalStateException(_							"Could not find handler for best pattern match [" + bestMatch + "]")__				}_			}_			String pathWithinMapping = getPathMatcher().extractPathWithinPattern(bestMatch, urlPath)__			return handleMatch(handler, bestMatch, pathWithinMapping, exchange)__		}__		_		return null__	};look,up,a,handler,instance,for,the,given,url,path,p,supports,direct,matches,e,g,a,registered,test,matches,test,and,various,ant,style,pattern,matches,e,g,a,registered,t,matches,both,test,and,team,for,details,see,the,ant,path,matcher,class,p,looks,for,the,most,exact,pattern,where,most,exact,is,defined,as,the,longest,path,pattern,param,url,path,url,the,bean,is,mapped,to,param,exchange,the,current,exchange,return,the,associated,handler,instance,or,code,null,if,not,found,see,org,springframework,web,util,pattern,parsing,path,matcher;protected,object,lookup,handler,string,url,path,server,web,exchange,exchange,throws,exception,object,handler,this,handler,map,get,url,path,if,handler,null,return,handle,match,handler,url,path,url,path,exchange,list,string,matches,new,array,list,for,string,pattern,this,handler,map,key,set,if,get,path,matcher,match,pattern,url,path,matches,add,pattern,else,if,use,trailing,slash,match,if,pattern,ends,with,get,path,matcher,match,pattern,url,path,matches,add,pattern,string,best,match,null,comparator,string,comparator,get,path,matcher,get,pattern,comparator,url,path,if,matches,is,empty,collections,sort,matches,comparator,if,logger,is,debug,enabled,logger,debug,matching,patterns,for,request,url,path,are,matches,best,match,matches,get,0,if,best,match,null,handler,this,handler,map,get,best,match,if,handler,null,if,best,match,ends,with,handler,this,handler,map,get,best,match,substring,0,best,match,length,1,if,handler,null,throw,new,illegal,state,exception,could,not,find,handler,for,best,pattern,match,best,match,string,path,within,mapping,get,path,matcher,extract,path,within,pattern,best,match,url,path,return,handle,match,handler,best,match,path,within,mapping,exchange,return,null
AbstractUrlHandlerMapping -> protected void registerHandler(String[] urlPaths, String beanName) throws BeansException, IllegalStateException;1485986572;Register the specified handler for the given URL paths._@param urlPaths the URLs that the bean should be mapped to_@param beanName the name of the handler bean_@throws BeansException if the handler couldn't be registered_@throws IllegalStateException if there is a conflicting handler registered;protected void registerHandler(String[] urlPaths, String beanName) throws BeansException, IllegalStateException {_		Assert.notNull(urlPaths, "URL path array must not be null")__		for (String urlPath : urlPaths) {_			registerHandler(urlPath, beanName)__		}_	};register,the,specified,handler,for,the,given,url,paths,param,url,paths,the,urls,that,the,bean,should,be,mapped,to,param,bean,name,the,name,of,the,handler,bean,throws,beans,exception,if,the,handler,couldn,t,be,registered,throws,illegal,state,exception,if,there,is,a,conflicting,handler,registered;protected,void,register,handler,string,url,paths,string,bean,name,throws,beans,exception,illegal,state,exception,assert,not,null,url,paths,url,path,array,must,not,be,null,for,string,url,path,url,paths,register,handler,url,path,bean,name
AbstractUrlHandlerMapping -> protected void registerHandler(String[] urlPaths, String beanName) throws BeansException, IllegalStateException;1486635693;Register the specified handler for the given URL paths._@param urlPaths the URLs that the bean should be mapped to_@param beanName the name of the handler bean_@throws BeansException if the handler couldn't be registered_@throws IllegalStateException if there is a conflicting handler registered;protected void registerHandler(String[] urlPaths, String beanName) throws BeansException, IllegalStateException {_		Assert.notNull(urlPaths, "URL path array must not be null")__		for (String urlPath : urlPaths) {_			registerHandler(urlPath, beanName)__		}_	};register,the,specified,handler,for,the,given,url,paths,param,url,paths,the,urls,that,the,bean,should,be,mapped,to,param,bean,name,the,name,of,the,handler,bean,throws,beans,exception,if,the,handler,couldn,t,be,registered,throws,illegal,state,exception,if,there,is,a,conflicting,handler,registered;protected,void,register,handler,string,url,paths,string,bean,name,throws,beans,exception,illegal,state,exception,assert,not,null,url,paths,url,path,array,must,not,be,null,for,string,url,path,url,paths,register,handler,url,path,bean,name
AbstractUrlHandlerMapping -> protected void registerHandler(String[] urlPaths, String beanName) throws BeansException, IllegalStateException;1486747801;Register the specified handler for the given URL paths._@param urlPaths the URLs that the bean should be mapped to_@param beanName the name of the handler bean_@throws BeansException if the handler couldn't be registered_@throws IllegalStateException if there is a conflicting handler registered;protected void registerHandler(String[] urlPaths, String beanName) throws BeansException, IllegalStateException {_		Assert.notNull(urlPaths, "URL path array must not be null")__		for (String urlPath : urlPaths) {_			registerHandler(urlPath, beanName)__		}_	};register,the,specified,handler,for,the,given,url,paths,param,url,paths,the,urls,that,the,bean,should,be,mapped,to,param,bean,name,the,name,of,the,handler,bean,throws,beans,exception,if,the,handler,couldn,t,be,registered,throws,illegal,state,exception,if,there,is,a,conflicting,handler,registered;protected,void,register,handler,string,url,paths,string,bean,name,throws,beans,exception,illegal,state,exception,assert,not,null,url,paths,url,path,array,must,not,be,null,for,string,url,path,url,paths,register,handler,url,path,bean,name
AbstractUrlHandlerMapping -> protected void registerHandler(String[] urlPaths, String beanName) throws BeansException, IllegalStateException;1486747828;Register the specified handler for the given URL paths._@param urlPaths the URLs that the bean should be mapped to_@param beanName the name of the handler bean_@throws BeansException if the handler couldn't be registered_@throws IllegalStateException if there is a conflicting handler registered;protected void registerHandler(String[] urlPaths, String beanName) throws BeansException, IllegalStateException {_		Assert.notNull(urlPaths, "URL path array must not be null")__		for (String urlPath : urlPaths) {_			registerHandler(urlPath, beanName)__		}_	};register,the,specified,handler,for,the,given,url,paths,param,url,paths,the,urls,that,the,bean,should,be,mapped,to,param,bean,name,the,name,of,the,handler,bean,throws,beans,exception,if,the,handler,couldn,t,be,registered,throws,illegal,state,exception,if,there,is,a,conflicting,handler,registered;protected,void,register,handler,string,url,paths,string,bean,name,throws,beans,exception,illegal,state,exception,assert,not,null,url,paths,url,path,array,must,not,be,null,for,string,url,path,url,paths,register,handler,url,path,bean,name
AbstractUrlHandlerMapping -> protected void registerHandler(String[] urlPaths, String beanName) throws BeansException, IllegalStateException;1495035625;Register the specified handler for the given URL paths._@param urlPaths the URLs that the bean should be mapped to_@param beanName the name of the handler bean_@throws BeansException if the handler couldn't be registered_@throws IllegalStateException if there is a conflicting handler registered;protected void registerHandler(String[] urlPaths, String beanName) throws BeansException, IllegalStateException {_		Assert.notNull(urlPaths, "URL path array must not be null")__		for (String urlPath : urlPaths) {_			registerHandler(urlPath, beanName)__		}_	};register,the,specified,handler,for,the,given,url,paths,param,url,paths,the,urls,that,the,bean,should,be,mapped,to,param,bean,name,the,name,of,the,handler,bean,throws,beans,exception,if,the,handler,couldn,t,be,registered,throws,illegal,state,exception,if,there,is,a,conflicting,handler,registered;protected,void,register,handler,string,url,paths,string,bean,name,throws,beans,exception,illegal,state,exception,assert,not,null,url,paths,url,path,array,must,not,be,null,for,string,url,path,url,paths,register,handler,url,path,bean,name
AbstractUrlHandlerMapping -> protected void registerHandler(String[] urlPaths, String beanName) throws BeansException, IllegalStateException;1495868221;Register the specified handler for the given URL paths._@param urlPaths the URLs that the bean should be mapped to_@param beanName the name of the handler bean_@throws BeansException if the handler couldn't be registered_@throws IllegalStateException if there is a conflicting handler registered;protected void registerHandler(String[] urlPaths, String beanName) throws BeansException, IllegalStateException {_		Assert.notNull(urlPaths, "URL path array must not be null")__		for (String urlPath : urlPaths) {_			registerHandler(urlPath, beanName)__		}_	};register,the,specified,handler,for,the,given,url,paths,param,url,paths,the,urls,that,the,bean,should,be,mapped,to,param,bean,name,the,name,of,the,handler,bean,throws,beans,exception,if,the,handler,couldn,t,be,registered,throws,illegal,state,exception,if,there,is,a,conflicting,handler,registered;protected,void,register,handler,string,url,paths,string,bean,name,throws,beans,exception,illegal,state,exception,assert,not,null,url,paths,url,path,array,must,not,be,null,for,string,url,path,url,paths,register,handler,url,path,bean,name
AbstractUrlHandlerMapping -> protected void registerHandler(String[] urlPaths, String beanName) throws BeansException, IllegalStateException;1496334664;Register the specified handler for the given URL paths._@param urlPaths the URLs that the bean should be mapped to_@param beanName the name of the handler bean_@throws BeansException if the handler couldn't be registered_@throws IllegalStateException if there is a conflicting handler registered;protected void registerHandler(String[] urlPaths, String beanName) throws BeansException, IllegalStateException {_		Assert.notNull(urlPaths, "URL path array must not be null")__		for (String urlPath : urlPaths) {_			registerHandler(urlPath, beanName)__		}_	};register,the,specified,handler,for,the,given,url,paths,param,url,paths,the,urls,that,the,bean,should,be,mapped,to,param,bean,name,the,name,of,the,handler,bean,throws,beans,exception,if,the,handler,couldn,t,be,registered,throws,illegal,state,exception,if,there,is,a,conflicting,handler,registered;protected,void,register,handler,string,url,paths,string,bean,name,throws,beans,exception,illegal,state,exception,assert,not,null,url,paths,url,path,array,must,not,be,null,for,string,url,path,url,paths,register,handler,url,path,bean,name
AbstractUrlHandlerMapping -> protected void registerHandler(String[] urlPaths, String beanName) throws BeansException, IllegalStateException;1496430942;Register the specified handler for the given URL paths._@param urlPaths the URLs that the bean should be mapped to_@param beanName the name of the handler bean_@throws BeansException if the handler couldn't be registered_@throws IllegalStateException if there is a conflicting handler registered;protected void registerHandler(String[] urlPaths, String beanName) throws BeansException, IllegalStateException {_		Assert.notNull(urlPaths, "URL path array must not be null")__		for (String urlPath : urlPaths) {_			registerHandler(urlPath, beanName)__		}_	};register,the,specified,handler,for,the,given,url,paths,param,url,paths,the,urls,that,the,bean,should,be,mapped,to,param,bean,name,the,name,of,the,handler,bean,throws,beans,exception,if,the,handler,couldn,t,be,registered,throws,illegal,state,exception,if,there,is,a,conflicting,handler,registered;protected,void,register,handler,string,url,paths,string,bean,name,throws,beans,exception,illegal,state,exception,assert,not,null,url,paths,url,path,array,must,not,be,null,for,string,url,path,url,paths,register,handler,url,path,bean,name
AbstractUrlHandlerMapping -> protected void registerHandler(String[] urlPaths, String beanName) throws BeansException, IllegalStateException;1496837955;Register the specified handler for the given URL paths._@param urlPaths the URLs that the bean should be mapped to_@param beanName the name of the handler bean_@throws BeansException if the handler couldn't be registered_@throws IllegalStateException if there is a conflicting handler registered;protected void registerHandler(String[] urlPaths, String beanName) throws BeansException, IllegalStateException {_		Assert.notNull(urlPaths, "URL path array must not be null")__		for (String urlPath : urlPaths) {_			registerHandler(urlPath, beanName)__		}_	};register,the,specified,handler,for,the,given,url,paths,param,url,paths,the,urls,that,the,bean,should,be,mapped,to,param,bean,name,the,name,of,the,handler,bean,throws,beans,exception,if,the,handler,couldn,t,be,registered,throws,illegal,state,exception,if,there,is,a,conflicting,handler,registered;protected,void,register,handler,string,url,paths,string,bean,name,throws,beans,exception,illegal,state,exception,assert,not,null,url,paths,url,path,array,must,not,be,null,for,string,url,path,url,paths,register,handler,url,path,bean,name
AbstractUrlHandlerMapping -> protected void registerHandler(String[] urlPaths, String beanName) throws BeansException, IllegalStateException;1497039338;Register the specified handler for the given URL paths._@param urlPaths the URLs that the bean should be mapped to_@param beanName the name of the handler bean_@throws BeansException if the handler couldn't be registered_@throws IllegalStateException if there is a conflicting handler registered;protected void registerHandler(String[] urlPaths, String beanName) throws BeansException, IllegalStateException {_		Assert.notNull(urlPaths, "URL path array must not be null")__		for (String urlPath : urlPaths) {_			registerHandler(urlPath, beanName)__		}_	};register,the,specified,handler,for,the,given,url,paths,param,url,paths,the,urls,that,the,bean,should,be,mapped,to,param,bean,name,the,name,of,the,handler,bean,throws,beans,exception,if,the,handler,couldn,t,be,registered,throws,illegal,state,exception,if,there,is,a,conflicting,handler,registered;protected,void,register,handler,string,url,paths,string,bean,name,throws,beans,exception,illegal,state,exception,assert,not,null,url,paths,url,path,array,must,not,be,null,for,string,url,path,url,paths,register,handler,url,path,bean,name
AbstractUrlHandlerMapping -> protected void registerHandler(String[] urlPaths, String beanName) throws BeansException, IllegalStateException;1497232764;Register the specified handler for the given URL paths._@param urlPaths the URLs that the bean should be mapped to_@param beanName the name of the handler bean_@throws BeansException if the handler couldn't be registered_@throws IllegalStateException if there is a conflicting handler registered;protected void registerHandler(String[] urlPaths, String beanName) throws BeansException, IllegalStateException {_		Assert.notNull(urlPaths, "URL path array must not be null")__		for (String urlPath : urlPaths) {_			registerHandler(urlPath, beanName)__		}_	};register,the,specified,handler,for,the,given,url,paths,param,url,paths,the,urls,that,the,bean,should,be,mapped,to,param,bean,name,the,name,of,the,handler,bean,throws,beans,exception,if,the,handler,couldn,t,be,registered,throws,illegal,state,exception,if,there,is,a,conflicting,handler,registered;protected,void,register,handler,string,url,paths,string,bean,name,throws,beans,exception,illegal,state,exception,assert,not,null,url,paths,url,path,array,must,not,be,null,for,string,url,path,url,paths,register,handler,url,path,bean,name
AbstractUrlHandlerMapping -> protected void registerHandler(String[] urlPaths, String beanName) throws BeansException, IllegalStateException;1497286385;Register the specified handler for the given URL paths._@param urlPaths the URLs that the bean should be mapped to_@param beanName the name of the handler bean_@throws BeansException if the handler couldn't be registered_@throws IllegalStateException if there is a conflicting handler registered;protected void registerHandler(String[] urlPaths, String beanName) throws BeansException, IllegalStateException {_		Assert.notNull(urlPaths, "URL path array must not be null")__		for (String urlPath : urlPaths) {_			registerHandler(urlPath, beanName)__		}_	};register,the,specified,handler,for,the,given,url,paths,param,url,paths,the,urls,that,the,bean,should,be,mapped,to,param,bean,name,the,name,of,the,handler,bean,throws,beans,exception,if,the,handler,couldn,t,be,registered,throws,illegal,state,exception,if,there,is,a,conflicting,handler,registered;protected,void,register,handler,string,url,paths,string,bean,name,throws,beans,exception,illegal,state,exception,assert,not,null,url,paths,url,path,array,must,not,be,null,for,string,url,path,url,paths,register,handler,url,path,bean,name
AbstractUrlHandlerMapping -> protected void registerHandler(String[] urlPaths, String beanName) throws BeansException, IllegalStateException;1498756719;Register the specified handler for the given URL paths._@param urlPaths the URLs that the bean should be mapped to_@param beanName the name of the handler bean_@throws BeansException if the handler couldn't be registered_@throws IllegalStateException if there is a conflicting handler registered;protected void registerHandler(String[] urlPaths, String beanName) throws BeansException, IllegalStateException {_		Assert.notNull(urlPaths, "URL path array must not be null")__		for (String urlPath : urlPaths) {_			registerHandler(urlPath, beanName)__		}_	};register,the,specified,handler,for,the,given,url,paths,param,url,paths,the,urls,that,the,bean,should,be,mapped,to,param,bean,name,the,name,of,the,handler,bean,throws,beans,exception,if,the,handler,couldn,t,be,registered,throws,illegal,state,exception,if,there,is,a,conflicting,handler,registered;protected,void,register,handler,string,url,paths,string,bean,name,throws,beans,exception,illegal,state,exception,assert,not,null,url,paths,url,path,array,must,not,be,null,for,string,url,path,url,paths,register,handler,url,path,bean,name
AbstractUrlHandlerMapping -> protected void registerHandler(String[] urlPaths, String beanName) throws BeansException, IllegalStateException;1498780456;Register the specified handler for the given URL paths._@param urlPaths the URLs that the bean should be mapped to_@param beanName the name of the handler bean_@throws BeansException if the handler couldn't be registered_@throws IllegalStateException if there is a conflicting handler registered;protected void registerHandler(String[] urlPaths, String beanName) throws BeansException, IllegalStateException {_		Assert.notNull(urlPaths, "URL path array must not be null")__		for (String urlPath : urlPaths) {_			registerHandler(urlPath, beanName)__		}_	};register,the,specified,handler,for,the,given,url,paths,param,url,paths,the,urls,that,the,bean,should,be,mapped,to,param,bean,name,the,name,of,the,handler,bean,throws,beans,exception,if,the,handler,couldn,t,be,registered,throws,illegal,state,exception,if,there,is,a,conflicting,handler,registered;protected,void,register,handler,string,url,paths,string,bean,name,throws,beans,exception,illegal,state,exception,assert,not,null,url,paths,url,path,array,must,not,be,null,for,string,url,path,url,paths,register,handler,url,path,bean,name
AbstractUrlHandlerMapping -> protected void registerHandler(String[] urlPaths, String beanName) throws BeansException, IllegalStateException;1498944474;Register the specified handler for the given URL paths._@param urlPaths the URLs that the bean should be mapped to_@param beanName the name of the handler bean_@throws BeansException if the handler couldn't be registered_@throws IllegalStateException if there is a conflicting handler registered;protected void registerHandler(String[] urlPaths, String beanName) throws BeansException, IllegalStateException {_		Assert.notNull(urlPaths, "URL path array must not be null")__		for (String urlPath : urlPaths) {_			registerHandler(urlPath, beanName)__		}_	};register,the,specified,handler,for,the,given,url,paths,param,url,paths,the,urls,that,the,bean,should,be,mapped,to,param,bean,name,the,name,of,the,handler,bean,throws,beans,exception,if,the,handler,couldn,t,be,registered,throws,illegal,state,exception,if,there,is,a,conflicting,handler,registered;protected,void,register,handler,string,url,paths,string,bean,name,throws,beans,exception,illegal,state,exception,assert,not,null,url,paths,url,path,array,must,not,be,null,for,string,url,path,url,paths,register,handler,url,path,bean,name
AbstractUrlHandlerMapping -> protected void registerHandler(String[] urlPaths, String beanName) throws BeansException, IllegalStateException;1498953917;Register the specified handler for the given URL paths._@param urlPaths the URLs that the bean should be mapped to_@param beanName the name of the handler bean_@throws BeansException if the handler couldn't be registered_@throws IllegalStateException if there is a conflicting handler registered;protected void registerHandler(String[] urlPaths, String beanName) throws BeansException, IllegalStateException {_		Assert.notNull(urlPaths, "URL path array must not be null")__		for (String urlPath : urlPaths) {_			registerHandler(urlPath, beanName)__		}_	};register,the,specified,handler,for,the,given,url,paths,param,url,paths,the,urls,that,the,bean,should,be,mapped,to,param,bean,name,the,name,of,the,handler,bean,throws,beans,exception,if,the,handler,couldn,t,be,registered,throws,illegal,state,exception,if,there,is,a,conflicting,handler,registered;protected,void,register,handler,string,url,paths,string,bean,name,throws,beans,exception,illegal,state,exception,assert,not,null,url,paths,url,path,array,must,not,be,null,for,string,url,path,url,paths,register,handler,url,path,bean,name
AbstractUrlHandlerMapping -> protected void registerHandler(String[] urlPaths, String beanName) throws BeansException, IllegalStateException;1520529117;Register the specified handler for the given URL paths._@param urlPaths the URLs that the bean should be mapped to_@param beanName the name of the handler bean_@throws BeansException if the handler couldn't be registered_@throws IllegalStateException if there is a conflicting handler registered;protected void registerHandler(String[] urlPaths, String beanName) throws BeansException, IllegalStateException {_		Assert.notNull(urlPaths, "URL path array must not be null")__		for (String urlPath : urlPaths) {_			registerHandler(urlPath, beanName)__		}_	};register,the,specified,handler,for,the,given,url,paths,param,url,paths,the,urls,that,the,bean,should,be,mapped,to,param,bean,name,the,name,of,the,handler,bean,throws,beans,exception,if,the,handler,couldn,t,be,registered,throws,illegal,state,exception,if,there,is,a,conflicting,handler,registered;protected,void,register,handler,string,url,paths,string,bean,name,throws,beans,exception,illegal,state,exception,assert,not,null,url,paths,url,path,array,must,not,be,null,for,string,url,path,url,paths,register,handler,url,path,bean,name
AbstractUrlHandlerMapping -> protected void registerHandler(String[] urlPaths, String beanName) throws BeansException, IllegalStateException;1529721864;Register the specified handler for the given URL paths._@param urlPaths the URLs that the bean should be mapped to_@param beanName the name of the handler bean_@throws BeansException if the handler couldn't be registered_@throws IllegalStateException if there is a conflicting handler registered;protected void registerHandler(String[] urlPaths, String beanName) throws BeansException, IllegalStateException {_		Assert.notNull(urlPaths, "URL path array must not be null")__		for (String urlPath : urlPaths) {_			registerHandler(urlPath, beanName)__		}_	};register,the,specified,handler,for,the,given,url,paths,param,url,paths,the,urls,that,the,bean,should,be,mapped,to,param,bean,name,the,name,of,the,handler,bean,throws,beans,exception,if,the,handler,couldn,t,be,registered,throws,illegal,state,exception,if,there,is,a,conflicting,handler,registered;protected,void,register,handler,string,url,paths,string,bean,name,throws,beans,exception,illegal,state,exception,assert,not,null,url,paths,url,path,array,must,not,be,null,for,string,url,path,url,paths,register,handler,url,path,bean,name
AbstractUrlHandlerMapping -> protected void registerHandler(String[] urlPaths, String beanName) throws BeansException, IllegalStateException;1530174524;Register the specified handler for the given URL paths._@param urlPaths the URLs that the bean should be mapped to_@param beanName the name of the handler bean_@throws BeansException if the handler couldn't be registered_@throws IllegalStateException if there is a conflicting handler registered;protected void registerHandler(String[] urlPaths, String beanName) throws BeansException, IllegalStateException {_		Assert.notNull(urlPaths, "URL path array must not be null")__		for (String urlPath : urlPaths) {_			registerHandler(urlPath, beanName)__		}_	};register,the,specified,handler,for,the,given,url,paths,param,url,paths,the,urls,that,the,bean,should,be,mapped,to,param,bean,name,the,name,of,the,handler,bean,throws,beans,exception,if,the,handler,couldn,t,be,registered,throws,illegal,state,exception,if,there,is,a,conflicting,handler,registered;protected,void,register,handler,string,url,paths,string,bean,name,throws,beans,exception,illegal,state,exception,assert,not,null,url,paths,url,path,array,must,not,be,null,for,string,url,path,url,paths,register,handler,url,path,bean,name
AbstractUrlHandlerMapping -> protected void registerHandler(String[] urlPaths, String beanName) throws BeansException, IllegalStateException;1530793633;Register the specified handler for the given URL paths._@param urlPaths the URLs that the bean should be mapped to_@param beanName the name of the handler bean_@throws BeansException if the handler couldn't be registered_@throws IllegalStateException if there is a conflicting handler registered;protected void registerHandler(String[] urlPaths, String beanName) throws BeansException, IllegalStateException {_		Assert.notNull(urlPaths, "URL path array must not be null")__		for (String urlPath : urlPaths) {_			registerHandler(urlPath, beanName)__		}_	};register,the,specified,handler,for,the,given,url,paths,param,url,paths,the,urls,that,the,bean,should,be,mapped,to,param,bean,name,the,name,of,the,handler,bean,throws,beans,exception,if,the,handler,couldn,t,be,registered,throws,illegal,state,exception,if,there,is,a,conflicting,handler,registered;protected,void,register,handler,string,url,paths,string,bean,name,throws,beans,exception,illegal,state,exception,assert,not,null,url,paths,url,path,array,must,not,be,null,for,string,url,path,url,paths,register,handler,url,path,bean,name
AbstractUrlHandlerMapping -> public void setUseTrailingSlashMatch(boolean useTrailingSlashMatch);1485986572;Whether to match to URLs irrespective of the presence of a trailing slash._If enabled a URL pattern such as "/users" also matches to "/users/"._<p>The default value is {@code false}.;public void setUseTrailingSlashMatch(boolean useTrailingSlashMatch) {_		this.useTrailingSlashMatch = useTrailingSlashMatch__	};whether,to,match,to,urls,irrespective,of,the,presence,of,a,trailing,slash,if,enabled,a,url,pattern,such,as,users,also,matches,to,users,p,the,default,value,is,code,false;public,void,set,use,trailing,slash,match,boolean,use,trailing,slash,match,this,use,trailing,slash,match,use,trailing,slash,match
AbstractUrlHandlerMapping -> public void setUseTrailingSlashMatch(boolean useTrailingSlashMatch);1486635693;Whether to match to URLs irrespective of the presence of a trailing slash._If enabled a URL pattern such as "/users" also matches to "/users/"._<p>The default value is {@code false}.;public void setUseTrailingSlashMatch(boolean useTrailingSlashMatch) {_		this.patternRegistry.setUseTrailingSlashMatch(useTrailingSlashMatch)__	};whether,to,match,to,urls,irrespective,of,the,presence,of,a,trailing,slash,if,enabled,a,url,pattern,such,as,users,also,matches,to,users,p,the,default,value,is,code,false;public,void,set,use,trailing,slash,match,boolean,use,trailing,slash,match,this,pattern,registry,set,use,trailing,slash,match,use,trailing,slash,match
AbstractUrlHandlerMapping -> public void setUseTrailingSlashMatch(boolean useTrailingSlashMatch);1486747801;Whether to match to URLs irrespective of the presence of a trailing slash._If enabled a URL pattern such as "/users" also matches to "/users/"._<p>The default value is {@code false}.;public void setUseTrailingSlashMatch(boolean useTrailingSlashMatch) {_		this.useTrailingSlashMatch = useTrailingSlashMatch__	};whether,to,match,to,urls,irrespective,of,the,presence,of,a,trailing,slash,if,enabled,a,url,pattern,such,as,users,also,matches,to,users,p,the,default,value,is,code,false;public,void,set,use,trailing,slash,match,boolean,use,trailing,slash,match,this,use,trailing,slash,match,use,trailing,slash,match
AbstractUrlHandlerMapping -> public void setUseTrailingSlashMatch(boolean useTrailingSlashMatch);1486747828;Whether to match to URLs irrespective of the presence of a trailing slash._If enabled a URL pattern such as "/users" also matches to "/users/"._<p>The default value is {@code false}.;public void setUseTrailingSlashMatch(boolean useTrailingSlashMatch) {_		this.useTrailingSlashMatch = useTrailingSlashMatch__	};whether,to,match,to,urls,irrespective,of,the,presence,of,a,trailing,slash,if,enabled,a,url,pattern,such,as,users,also,matches,to,users,p,the,default,value,is,code,false;public,void,set,use,trailing,slash,match,boolean,use,trailing,slash,match,this,use,trailing,slash,match,use,trailing,slash,match
AbstractUrlHandlerMapping -> public void setUseTrailingSlashMatch(boolean useTrailingSlashMatch);1495035625;Whether to match to URLs irrespective of the presence of a trailing slash._If enabled a URL pattern such as "/users" also matches to "/users/"._<p>The default value is {@code false}.;public void setUseTrailingSlashMatch(boolean useTrailingSlashMatch) {_		this.useTrailingSlashMatch = useTrailingSlashMatch__	};whether,to,match,to,urls,irrespective,of,the,presence,of,a,trailing,slash,if,enabled,a,url,pattern,such,as,users,also,matches,to,users,p,the,default,value,is,code,false;public,void,set,use,trailing,slash,match,boolean,use,trailing,slash,match,this,use,trailing,slash,match,use,trailing,slash,match
AbstractUrlHandlerMapping -> public void setUseTrailingSlashMatch(boolean useTrailingSlashMatch);1495868221;Whether to match to URLs irrespective of the presence of a trailing slash._If enabled a URL pattern such as "/users" also matches to "/users/"._<p>The default value is {@code false}.;public void setUseTrailingSlashMatch(boolean useTrailingSlashMatch) {_		this.useTrailingSlashMatch = useTrailingSlashMatch__	};whether,to,match,to,urls,irrespective,of,the,presence,of,a,trailing,slash,if,enabled,a,url,pattern,such,as,users,also,matches,to,users,p,the,default,value,is,code,false;public,void,set,use,trailing,slash,match,boolean,use,trailing,slash,match,this,use,trailing,slash,match,use,trailing,slash,match
AbstractUrlHandlerMapping -> public void setUseTrailingSlashMatch(boolean useTrailingSlashMatch);1496334664;Whether to match to URLs irrespective of the presence of a trailing slash._If enabled a URL pattern such as "/users" also matches to "/users/"._<p>The default value is {@code false}.;public void setUseTrailingSlashMatch(boolean useTrailingSlashMatch) {_		this.useTrailingSlashMatch = useTrailingSlashMatch__	};whether,to,match,to,urls,irrespective,of,the,presence,of,a,trailing,slash,if,enabled,a,url,pattern,such,as,users,also,matches,to,users,p,the,default,value,is,code,false;public,void,set,use,trailing,slash,match,boolean,use,trailing,slash,match,this,use,trailing,slash,match,use,trailing,slash,match
AbstractUrlHandlerMapping -> public void setUseTrailingSlashMatch(boolean useTrailingSlashMatch);1496430942;Whether to match to URLs irrespective of the presence of a trailing slash._If enabled a URL pattern such as "/users" also matches to "/users/"._<p>The default value is {@code false}.;public void setUseTrailingSlashMatch(boolean useTrailingSlashMatch) {_		this.useTrailingSlashMatch = useTrailingSlashMatch__	};whether,to,match,to,urls,irrespective,of,the,presence,of,a,trailing,slash,if,enabled,a,url,pattern,such,as,users,also,matches,to,users,p,the,default,value,is,code,false;public,void,set,use,trailing,slash,match,boolean,use,trailing,slash,match,this,use,trailing,slash,match,use,trailing,slash,match
AbstractUrlHandlerMapping -> public void setUseTrailingSlashMatch(boolean useTrailingSlashMatch);1496837955;Whether to match to URLs irrespective of the presence of a trailing slash._If enabled a URL pattern such as "/users" also matches to "/users/"._<p>The default value is {@code false}.;public void setUseTrailingSlashMatch(boolean useTrailingSlashMatch) {_		this.useTrailingSlashMatch = useTrailingSlashMatch__	};whether,to,match,to,urls,irrespective,of,the,presence,of,a,trailing,slash,if,enabled,a,url,pattern,such,as,users,also,matches,to,users,p,the,default,value,is,code,false;public,void,set,use,trailing,slash,match,boolean,use,trailing,slash,match,this,use,trailing,slash,match,use,trailing,slash,match
AbstractUrlHandlerMapping -> public void setUseTrailingSlashMatch(boolean useTrailingSlashMatch);1497039338;Whether to match to URLs irrespective of the presence of a trailing slash._If enabled a URL pattern such as "/users" also matches to "/users/"._<p>The default value is {@code false}.;public void setUseTrailingSlashMatch(boolean useTrailingSlashMatch) {_		this.useTrailingSlashMatch = useTrailingSlashMatch__	};whether,to,match,to,urls,irrespective,of,the,presence,of,a,trailing,slash,if,enabled,a,url,pattern,such,as,users,also,matches,to,users,p,the,default,value,is,code,false;public,void,set,use,trailing,slash,match,boolean,use,trailing,slash,match,this,use,trailing,slash,match,use,trailing,slash,match
AbstractUrlHandlerMapping -> public void setUseTrailingSlashMatch(boolean useTrailingSlashMatch);1497232764;Whether to match to URLs irrespective of the presence of a trailing slash._If enabled a URL pattern such as "/users" also matches to "/users/"._<p>The default value is {@code false}.;public void setUseTrailingSlashMatch(boolean useTrailingSlashMatch) {_		this.useTrailingSlashMatch = useTrailingSlashMatch__	};whether,to,match,to,urls,irrespective,of,the,presence,of,a,trailing,slash,if,enabled,a,url,pattern,such,as,users,also,matches,to,users,p,the,default,value,is,code,false;public,void,set,use,trailing,slash,match,boolean,use,trailing,slash,match,this,use,trailing,slash,match,use,trailing,slash,match
AbstractUrlHandlerMapping -> public final Map<String, Object> getHandlerMap();1485986572;Return the registered handlers as an unmodifiable Map, with the registered path_as key and the handler object (or handler bean name in case of a lazy-init handler)_as value.;public final Map<String, Object> getHandlerMap() {_		return Collections.unmodifiableMap(this.handlerMap)__	};return,the,registered,handlers,as,an,unmodifiable,map,with,the,registered,path,as,key,and,the,handler,object,or,handler,bean,name,in,case,of,a,lazy,init,handler,as,value;public,final,map,string,object,get,handler,map,return,collections,unmodifiable,map,this,handler,map
AbstractUrlHandlerMapping -> public final Map<String, Object> getHandlerMap();1486747801;Return the registered handlers as an unmodifiable Map, with the registered path_as key and the handler object (or handler bean name in case of a lazy-init handler)_as value.;public final Map<String, Object> getHandlerMap() {_		return Collections.unmodifiableMap(this.handlerMap)__	};return,the,registered,handlers,as,an,unmodifiable,map,with,the,registered,path,as,key,and,the,handler,object,or,handler,bean,name,in,case,of,a,lazy,init,handler,as,value;public,final,map,string,object,get,handler,map,return,collections,unmodifiable,map,this,handler,map
AbstractUrlHandlerMapping -> public final Map<String, Object> getHandlerMap();1486747828;Return the registered handlers as an unmodifiable Map, with the registered path_as key and the handler object (or handler bean name in case of a lazy-init handler)_as value.;public final Map<String, Object> getHandlerMap() {_		return Collections.unmodifiableMap(this.handlerMap)__	};return,the,registered,handlers,as,an,unmodifiable,map,with,the,registered,path,as,key,and,the,handler,object,or,handler,bean,name,in,case,of,a,lazy,init,handler,as,value;public,final,map,string,object,get,handler,map,return,collections,unmodifiable,map,this,handler,map
AbstractUrlHandlerMapping -> public final Map<String, Object> getHandlerMap();1495035625;Return the registered handlers as an unmodifiable Map, with the registered path_as key and the handler object (or handler bean name in case of a lazy-init handler)_as value.;public final Map<String, Object> getHandlerMap() {_		return Collections.unmodifiableMap(this.handlerMap)__	};return,the,registered,handlers,as,an,unmodifiable,map,with,the,registered,path,as,key,and,the,handler,object,or,handler,bean,name,in,case,of,a,lazy,init,handler,as,value;public,final,map,string,object,get,handler,map,return,collections,unmodifiable,map,this,handler,map
AbstractUrlHandlerMapping -> public final Map<String, Object> getHandlerMap();1495868221;Return the registered handlers as an unmodifiable Map, with the registered path_as key and the handler object (or handler bean name in case of a lazy-init handler)_as value.;public final Map<String, Object> getHandlerMap() {_		return Collections.unmodifiableMap(this.handlerMap)__	};return,the,registered,handlers,as,an,unmodifiable,map,with,the,registered,path,as,key,and,the,handler,object,or,handler,bean,name,in,case,of,a,lazy,init,handler,as,value;public,final,map,string,object,get,handler,map,return,collections,unmodifiable,map,this,handler,map
AbstractUrlHandlerMapping -> public final Map<String, Object> getHandlerMap();1496334664;Return the registered handlers as an unmodifiable Map, with the registered path_as key and the handler object (or handler bean name in case of a lazy-init handler)_as value.;public final Map<String, Object> getHandlerMap() {_		return Collections.unmodifiableMap(this.handlerMap)__	};return,the,registered,handlers,as,an,unmodifiable,map,with,the,registered,path,as,key,and,the,handler,object,or,handler,bean,name,in,case,of,a,lazy,init,handler,as,value;public,final,map,string,object,get,handler,map,return,collections,unmodifiable,map,this,handler,map
AbstractUrlHandlerMapping -> public final Map<String, Object> getHandlerMap();1496430942;Return the registered handlers as an unmodifiable Map, with the registered path_as key and the handler object (or handler bean name in case of a lazy-init handler)_as value.;public final Map<String, Object> getHandlerMap() {_		return Collections.unmodifiableMap(this.handlerMap)__	};return,the,registered,handlers,as,an,unmodifiable,map,with,the,registered,path,as,key,and,the,handler,object,or,handler,bean,name,in,case,of,a,lazy,init,handler,as,value;public,final,map,string,object,get,handler,map,return,collections,unmodifiable,map,this,handler,map
AbstractUrlHandlerMapping -> public final Map<String, Object> getHandlerMap();1496837955;Return the registered handlers as an unmodifiable Map, with the registered path_as key and the handler object (or handler bean name in case of a lazy-init handler)_as value.;public final Map<String, Object> getHandlerMap() {_		return Collections.unmodifiableMap(this.handlerMap)__	};return,the,registered,handlers,as,an,unmodifiable,map,with,the,registered,path,as,key,and,the,handler,object,or,handler,bean,name,in,case,of,a,lazy,init,handler,as,value;public,final,map,string,object,get,handler,map,return,collections,unmodifiable,map,this,handler,map
AbstractUrlHandlerMapping -> public final Map<String, Object> getHandlerMap();1497039338;Return the registered handlers as an unmodifiable Map, with the registered path_as key and the handler object (or handler bean name in case of a lazy-init handler)_as value.;public final Map<String, Object> getHandlerMap() {_		return Collections.unmodifiableMap(this.handlerMap)__	};return,the,registered,handlers,as,an,unmodifiable,map,with,the,registered,path,as,key,and,the,handler,object,or,handler,bean,name,in,case,of,a,lazy,init,handler,as,value;public,final,map,string,object,get,handler,map,return,collections,unmodifiable,map,this,handler,map
AbstractUrlHandlerMapping -> public final Map<String, Object> getHandlerMap();1497232764;Return the registered handlers as an unmodifiable Map, with the registered path_as key and the handler object (or handler bean name in case of a lazy-init handler)_as value.;public final Map<String, Object> getHandlerMap() {_		return Collections.unmodifiableMap(this.handlerMap)__	};return,the,registered,handlers,as,an,unmodifiable,map,with,the,registered,path,as,key,and,the,handler,object,or,handler,bean,name,in,case,of,a,lazy,init,handler,as,value;public,final,map,string,object,get,handler,map,return,collections,unmodifiable,map,this,handler,map
AbstractUrlHandlerMapping -> protected void registerHandler(String urlPath, Object handler) throws BeansException, IllegalStateException;1485986572;Register the specified handler for the given URL path._@param urlPath the URL the bean should be mapped to_@param handler the handler instance or handler bean name String_(a bean name will automatically be resolved into the corresponding handler bean)_@throws BeansException if the handler couldn't be registered_@throws IllegalStateException if there is a conflicting handler registered;protected void registerHandler(String urlPath, Object handler) throws BeansException, IllegalStateException {_		Assert.notNull(urlPath, "URL path must not be null")__		Assert.notNull(handler, "Handler object must not be null")__		Object resolvedHandler = handler___		_		if (!this.lazyInitHandlers && handler instanceof String) {_			String handlerName = (String) handler__			if (getApplicationContext().isSingleton(handlerName)) {_				resolvedHandler = getApplicationContext().getBean(handlerName)__			}_		}__		Object mappedHandler = this.handlerMap.get(urlPath)__		if (mappedHandler != null) {_			if (mappedHandler != resolvedHandler) {_				throw new IllegalStateException(_						"Cannot map " + getHandlerDescription(handler) + " to URL path [" + urlPath +_						"]: There is already " + getHandlerDescription(mappedHandler) + " mapped.")__			}_		}_		else {_			this.handlerMap.put(urlPath, resolvedHandler)__			if (logger.isInfoEnabled()) {_				logger.info("Mapped URL path [" + urlPath + "] onto " + getHandlerDescription(handler))__			}_		}_	};register,the,specified,handler,for,the,given,url,path,param,url,path,the,url,the,bean,should,be,mapped,to,param,handler,the,handler,instance,or,handler,bean,name,string,a,bean,name,will,automatically,be,resolved,into,the,corresponding,handler,bean,throws,beans,exception,if,the,handler,couldn,t,be,registered,throws,illegal,state,exception,if,there,is,a,conflicting,handler,registered;protected,void,register,handler,string,url,path,object,handler,throws,beans,exception,illegal,state,exception,assert,not,null,url,path,url,path,must,not,be,null,assert,not,null,handler,handler,object,must,not,be,null,object,resolved,handler,handler,if,this,lazy,init,handlers,handler,instanceof,string,string,handler,name,string,handler,if,get,application,context,is,singleton,handler,name,resolved,handler,get,application,context,get,bean,handler,name,object,mapped,handler,this,handler,map,get,url,path,if,mapped,handler,null,if,mapped,handler,resolved,handler,throw,new,illegal,state,exception,cannot,map,get,handler,description,handler,to,url,path,url,path,there,is,already,get,handler,description,mapped,handler,mapped,else,this,handler,map,put,url,path,resolved,handler,if,logger,is,info,enabled,logger,info,mapped,url,path,url,path,onto,get,handler,description,handler
AbstractUrlHandlerMapping -> protected void registerHandler(String urlPath, Object handler) throws BeansException, IllegalStateException;1486635693;Register the specified handler for the given URL path._@param urlPath the URL the bean should be mapped to_@param handler the handler instance or handler bean name String_(a bean name will automatically be resolved into the corresponding handler bean)_@throws BeansException if the handler couldn't be registered_@throws IllegalStateException if there is a conflicting handler registered;protected void registerHandler(String urlPath, Object handler) throws BeansException, IllegalStateException {_		Assert.notNull(urlPath, "URL path must not be null")__		Assert.notNull(handler, "Handler object must not be null")__		Object resolvedHandler = handler___		_		if (!this.lazyInitHandlers && handler instanceof String) {_			String handlerName = (String) handler__			if (getApplicationContext().isSingleton(handlerName)) {_				resolvedHandler = getApplicationContext().getBean(handlerName)__			}_		}_		for (PathPattern newPattern : this.patternRegistry.register(urlPath)) {_			Object mappedHandler = this.handlerMap.get(newPattern)__			if (mappedHandler != null) {_				if (mappedHandler != resolvedHandler) {_					throw new IllegalStateException(_							"Cannot map " + getHandlerDescription(handler) + " to URL path [" + urlPath +_									"]: There is already " + getHandlerDescription(mappedHandler) + " mapped.")__				}_			}_			else {_				this.handlerMap.put(newPattern, resolvedHandler)___			}_		}_		if (logger.isInfoEnabled()) {_			logger.info("Mapped URL path [" + urlPath + "] onto " + getHandlerDescription(handler))__		}_	};register,the,specified,handler,for,the,given,url,path,param,url,path,the,url,the,bean,should,be,mapped,to,param,handler,the,handler,instance,or,handler,bean,name,string,a,bean,name,will,automatically,be,resolved,into,the,corresponding,handler,bean,throws,beans,exception,if,the,handler,couldn,t,be,registered,throws,illegal,state,exception,if,there,is,a,conflicting,handler,registered;protected,void,register,handler,string,url,path,object,handler,throws,beans,exception,illegal,state,exception,assert,not,null,url,path,url,path,must,not,be,null,assert,not,null,handler,handler,object,must,not,be,null,object,resolved,handler,handler,if,this,lazy,init,handlers,handler,instanceof,string,string,handler,name,string,handler,if,get,application,context,is,singleton,handler,name,resolved,handler,get,application,context,get,bean,handler,name,for,path,pattern,new,pattern,this,pattern,registry,register,url,path,object,mapped,handler,this,handler,map,get,new,pattern,if,mapped,handler,null,if,mapped,handler,resolved,handler,throw,new,illegal,state,exception,cannot,map,get,handler,description,handler,to,url,path,url,path,there,is,already,get,handler,description,mapped,handler,mapped,else,this,handler,map,put,new,pattern,resolved,handler,if,logger,is,info,enabled,logger,info,mapped,url,path,url,path,onto,get,handler,description,handler
AbstractUrlHandlerMapping -> protected void registerHandler(String urlPath, Object handler) throws BeansException, IllegalStateException;1486747801;Register the specified handler for the given URL path._@param urlPath the URL the bean should be mapped to_@param handler the handler instance or handler bean name String_(a bean name will automatically be resolved into the corresponding handler bean)_@throws BeansException if the handler couldn't be registered_@throws IllegalStateException if there is a conflicting handler registered;protected void registerHandler(String urlPath, Object handler) throws BeansException, IllegalStateException {_		Assert.notNull(urlPath, "URL path must not be null")__		Assert.notNull(handler, "Handler object must not be null")__		Object resolvedHandler = handler___		_		if (!this.lazyInitHandlers && handler instanceof String) {_			String handlerName = (String) handler__			if (getApplicationContext().isSingleton(handlerName)) {_				resolvedHandler = getApplicationContext().getBean(handlerName)__			}_		}__		Object mappedHandler = this.handlerMap.get(urlPath)__		if (mappedHandler != null) {_			if (mappedHandler != resolvedHandler) {_				throw new IllegalStateException(_						"Cannot map " + getHandlerDescription(handler) + " to URL path [" + urlPath +_						"]: There is already " + getHandlerDescription(mappedHandler) + " mapped.")__			}_		}_		else {_			this.handlerMap.put(urlPath, resolvedHandler)__			if (logger.isInfoEnabled()) {_				logger.info("Mapped URL path [" + urlPath + "] onto " + getHandlerDescription(handler))__			}_		}_	};register,the,specified,handler,for,the,given,url,path,param,url,path,the,url,the,bean,should,be,mapped,to,param,handler,the,handler,instance,or,handler,bean,name,string,a,bean,name,will,automatically,be,resolved,into,the,corresponding,handler,bean,throws,beans,exception,if,the,handler,couldn,t,be,registered,throws,illegal,state,exception,if,there,is,a,conflicting,handler,registered;protected,void,register,handler,string,url,path,object,handler,throws,beans,exception,illegal,state,exception,assert,not,null,url,path,url,path,must,not,be,null,assert,not,null,handler,handler,object,must,not,be,null,object,resolved,handler,handler,if,this,lazy,init,handlers,handler,instanceof,string,string,handler,name,string,handler,if,get,application,context,is,singleton,handler,name,resolved,handler,get,application,context,get,bean,handler,name,object,mapped,handler,this,handler,map,get,url,path,if,mapped,handler,null,if,mapped,handler,resolved,handler,throw,new,illegal,state,exception,cannot,map,get,handler,description,handler,to,url,path,url,path,there,is,already,get,handler,description,mapped,handler,mapped,else,this,handler,map,put,url,path,resolved,handler,if,logger,is,info,enabled,logger,info,mapped,url,path,url,path,onto,get,handler,description,handler
AbstractUrlHandlerMapping -> protected void registerHandler(String urlPath, Object handler) throws BeansException, IllegalStateException;1486747828;Register the specified handler for the given URL path._@param urlPath the URL the bean should be mapped to_@param handler the handler instance or handler bean name String_(a bean name will automatically be resolved into the corresponding handler bean)_@throws BeansException if the handler couldn't be registered_@throws IllegalStateException if there is a conflicting handler registered;protected void registerHandler(String urlPath, Object handler) throws BeansException, IllegalStateException {_		Assert.notNull(urlPath, "URL path must not be null")__		Assert.notNull(handler, "Handler object must not be null")__		Object resolvedHandler = handler___		_		if (!this.lazyInitHandlers && handler instanceof String) {_			String handlerName = (String) handler__			if (getApplicationContext().isSingleton(handlerName)) {_				resolvedHandler = getApplicationContext().getBean(handlerName)__			}_		}__		Object mappedHandler = this.handlerMap.get(urlPath)__		if (mappedHandler != null) {_			if (mappedHandler != resolvedHandler) {_				throw new IllegalStateException(_						"Cannot map " + getHandlerDescription(handler) + " to URL path [" + urlPath +_						"]: There is already " + getHandlerDescription(mappedHandler) + " mapped.")__			}_		}_		else {_			this.handlerMap.put(urlPath, resolvedHandler)__			if (logger.isInfoEnabled()) {_				logger.info("Mapped URL path [" + urlPath + "] onto " + getHandlerDescription(handler))__			}_		}_	};register,the,specified,handler,for,the,given,url,path,param,url,path,the,url,the,bean,should,be,mapped,to,param,handler,the,handler,instance,or,handler,bean,name,string,a,bean,name,will,automatically,be,resolved,into,the,corresponding,handler,bean,throws,beans,exception,if,the,handler,couldn,t,be,registered,throws,illegal,state,exception,if,there,is,a,conflicting,handler,registered;protected,void,register,handler,string,url,path,object,handler,throws,beans,exception,illegal,state,exception,assert,not,null,url,path,url,path,must,not,be,null,assert,not,null,handler,handler,object,must,not,be,null,object,resolved,handler,handler,if,this,lazy,init,handlers,handler,instanceof,string,string,handler,name,string,handler,if,get,application,context,is,singleton,handler,name,resolved,handler,get,application,context,get,bean,handler,name,object,mapped,handler,this,handler,map,get,url,path,if,mapped,handler,null,if,mapped,handler,resolved,handler,throw,new,illegal,state,exception,cannot,map,get,handler,description,handler,to,url,path,url,path,there,is,already,get,handler,description,mapped,handler,mapped,else,this,handler,map,put,url,path,resolved,handler,if,logger,is,info,enabled,logger,info,mapped,url,path,url,path,onto,get,handler,description,handler
AbstractUrlHandlerMapping -> protected void registerHandler(String urlPath, Object handler) throws BeansException, IllegalStateException;1495035625;Register the specified handler for the given URL path._@param urlPath the URL the bean should be mapped to_@param handler the handler instance or handler bean name String_(a bean name will automatically be resolved into the corresponding handler bean)_@throws BeansException if the handler couldn't be registered_@throws IllegalStateException if there is a conflicting handler registered;protected void registerHandler(String urlPath, Object handler) throws BeansException, IllegalStateException {_		Assert.notNull(urlPath, "URL path must not be null")__		Assert.notNull(handler, "Handler object must not be null")__		Object resolvedHandler = handler___		_		if (!this.lazyInitHandlers && handler instanceof String) {_			String handlerName = (String) handler__			if (getApplicationContext().isSingleton(handlerName)) {_				resolvedHandler = getApplicationContext().getBean(handlerName)__			}_		}__		Object mappedHandler = this.handlerMap.get(urlPath)__		if (mappedHandler != null) {_			if (mappedHandler != resolvedHandler) {_				throw new IllegalStateException(_						"Cannot map " + getHandlerDescription(handler) + " to URL path [" + urlPath +_						"]: There is already " + getHandlerDescription(mappedHandler) + " mapped.")__			}_		}_		else {_			this.handlerMap.put(urlPath, resolvedHandler)__			if (logger.isInfoEnabled()) {_				logger.info("Mapped URL path [" + urlPath + "] onto " + getHandlerDescription(handler))__			}_		}_	};register,the,specified,handler,for,the,given,url,path,param,url,path,the,url,the,bean,should,be,mapped,to,param,handler,the,handler,instance,or,handler,bean,name,string,a,bean,name,will,automatically,be,resolved,into,the,corresponding,handler,bean,throws,beans,exception,if,the,handler,couldn,t,be,registered,throws,illegal,state,exception,if,there,is,a,conflicting,handler,registered;protected,void,register,handler,string,url,path,object,handler,throws,beans,exception,illegal,state,exception,assert,not,null,url,path,url,path,must,not,be,null,assert,not,null,handler,handler,object,must,not,be,null,object,resolved,handler,handler,if,this,lazy,init,handlers,handler,instanceof,string,string,handler,name,string,handler,if,get,application,context,is,singleton,handler,name,resolved,handler,get,application,context,get,bean,handler,name,object,mapped,handler,this,handler,map,get,url,path,if,mapped,handler,null,if,mapped,handler,resolved,handler,throw,new,illegal,state,exception,cannot,map,get,handler,description,handler,to,url,path,url,path,there,is,already,get,handler,description,mapped,handler,mapped,else,this,handler,map,put,url,path,resolved,handler,if,logger,is,info,enabled,logger,info,mapped,url,path,url,path,onto,get,handler,description,handler
AbstractUrlHandlerMapping -> protected void registerHandler(String urlPath, Object handler) throws BeansException, IllegalStateException;1495868221;Register the specified handler for the given URL path._@param urlPath the URL the bean should be mapped to_@param handler the handler instance or handler bean name String_(a bean name will automatically be resolved into the corresponding handler bean)_@throws BeansException if the handler couldn't be registered_@throws IllegalStateException if there is a conflicting handler registered;protected void registerHandler(String urlPath, Object handler) throws BeansException, IllegalStateException {_		Assert.notNull(urlPath, "URL path must not be null")__		Assert.notNull(handler, "Handler object must not be null")__		Object resolvedHandler = handler___		_		if (!this.lazyInitHandlers && handler instanceof String) {_			String handlerName = (String) handler__			if (getApplicationContext().isSingleton(handlerName)) {_				resolvedHandler = getApplicationContext().getBean(handlerName)__			}_		}__		Object mappedHandler = this.handlerMap.get(urlPath)__		if (mappedHandler != null) {_			if (mappedHandler != resolvedHandler) {_				throw new IllegalStateException(_						"Cannot map " + getHandlerDescription(handler) + " to URL path [" + urlPath +_						"]: There is already " + getHandlerDescription(mappedHandler) + " mapped.")__			}_		}_		else {_			this.handlerMap.put(urlPath, resolvedHandler)__			if (logger.isInfoEnabled()) {_				logger.info("Mapped URL path [" + urlPath + "] onto " + getHandlerDescription(handler))__			}_		}_	};register,the,specified,handler,for,the,given,url,path,param,url,path,the,url,the,bean,should,be,mapped,to,param,handler,the,handler,instance,or,handler,bean,name,string,a,bean,name,will,automatically,be,resolved,into,the,corresponding,handler,bean,throws,beans,exception,if,the,handler,couldn,t,be,registered,throws,illegal,state,exception,if,there,is,a,conflicting,handler,registered;protected,void,register,handler,string,url,path,object,handler,throws,beans,exception,illegal,state,exception,assert,not,null,url,path,url,path,must,not,be,null,assert,not,null,handler,handler,object,must,not,be,null,object,resolved,handler,handler,if,this,lazy,init,handlers,handler,instanceof,string,string,handler,name,string,handler,if,get,application,context,is,singleton,handler,name,resolved,handler,get,application,context,get,bean,handler,name,object,mapped,handler,this,handler,map,get,url,path,if,mapped,handler,null,if,mapped,handler,resolved,handler,throw,new,illegal,state,exception,cannot,map,get,handler,description,handler,to,url,path,url,path,there,is,already,get,handler,description,mapped,handler,mapped,else,this,handler,map,put,url,path,resolved,handler,if,logger,is,info,enabled,logger,info,mapped,url,path,url,path,onto,get,handler,description,handler
AbstractUrlHandlerMapping -> protected void registerHandler(String urlPath, Object handler) throws BeansException, IllegalStateException;1496334664;Register the specified handler for the given URL path._@param urlPath the URL the bean should be mapped to_@param handler the handler instance or handler bean name String_(a bean name will automatically be resolved into the corresponding handler bean)_@throws BeansException if the handler couldn't be registered_@throws IllegalStateException if there is a conflicting handler registered;protected void registerHandler(String urlPath, Object handler) throws BeansException, IllegalStateException {_		Assert.notNull(urlPath, "URL path must not be null")__		Assert.notNull(handler, "Handler object must not be null")__		Object resolvedHandler = handler___		_		if (!this.lazyInitHandlers && handler instanceof String) {_			String handlerName = (String) handler__			if (getApplicationContext().isSingleton(handlerName)) {_				resolvedHandler = getApplicationContext().getBean(handlerName)__			}_		}__		Object mappedHandler = this.handlerMap.get(urlPath)__		if (mappedHandler != null) {_			if (mappedHandler != resolvedHandler) {_				throw new IllegalStateException(_						"Cannot map " + getHandlerDescription(handler) + " to URL path [" + urlPath +_						"]: There is already " + getHandlerDescription(mappedHandler) + " mapped.")__			}_		}_		else {_			this.handlerMap.put(urlPath, resolvedHandler)__			if (logger.isInfoEnabled()) {_				logger.info("Mapped URL path [" + urlPath + "] onto " + getHandlerDescription(handler))__			}_		}_	};register,the,specified,handler,for,the,given,url,path,param,url,path,the,url,the,bean,should,be,mapped,to,param,handler,the,handler,instance,or,handler,bean,name,string,a,bean,name,will,automatically,be,resolved,into,the,corresponding,handler,bean,throws,beans,exception,if,the,handler,couldn,t,be,registered,throws,illegal,state,exception,if,there,is,a,conflicting,handler,registered;protected,void,register,handler,string,url,path,object,handler,throws,beans,exception,illegal,state,exception,assert,not,null,url,path,url,path,must,not,be,null,assert,not,null,handler,handler,object,must,not,be,null,object,resolved,handler,handler,if,this,lazy,init,handlers,handler,instanceof,string,string,handler,name,string,handler,if,get,application,context,is,singleton,handler,name,resolved,handler,get,application,context,get,bean,handler,name,object,mapped,handler,this,handler,map,get,url,path,if,mapped,handler,null,if,mapped,handler,resolved,handler,throw,new,illegal,state,exception,cannot,map,get,handler,description,handler,to,url,path,url,path,there,is,already,get,handler,description,mapped,handler,mapped,else,this,handler,map,put,url,path,resolved,handler,if,logger,is,info,enabled,logger,info,mapped,url,path,url,path,onto,get,handler,description,handler
AbstractUrlHandlerMapping -> protected void registerHandler(String urlPath, Object handler) throws BeansException, IllegalStateException;1496430942;Register the specified handler for the given URL path._@param urlPath the URL the bean should be mapped to_@param handler the handler instance or handler bean name String_(a bean name will automatically be resolved into the corresponding handler bean)_@throws BeansException if the handler couldn't be registered_@throws IllegalStateException if there is a conflicting handler registered;protected void registerHandler(String urlPath, Object handler) throws BeansException, IllegalStateException {_		Assert.notNull(urlPath, "URL path must not be null")__		Assert.notNull(handler, "Handler object must not be null")__		Object resolvedHandler = handler___		_		if (!this.lazyInitHandlers && handler instanceof String) {_			String handlerName = (String) handler__			if (getApplicationContext().isSingleton(handlerName)) {_				resolvedHandler = getApplicationContext().getBean(handlerName)__			}_		}__		Object mappedHandler = this.handlerMap.get(urlPath)__		if (mappedHandler != null) {_			if (mappedHandler != resolvedHandler) {_				throw new IllegalStateException(_						"Cannot map " + getHandlerDescription(handler) + " to URL path [" + urlPath +_						"]: There is already " + getHandlerDescription(mappedHandler) + " mapped.")__			}_		}_		else {_			this.handlerMap.put(urlPath, resolvedHandler)__			if (logger.isInfoEnabled()) {_				logger.info("Mapped URL path [" + urlPath + "] onto " + getHandlerDescription(handler))__			}_		}_	};register,the,specified,handler,for,the,given,url,path,param,url,path,the,url,the,bean,should,be,mapped,to,param,handler,the,handler,instance,or,handler,bean,name,string,a,bean,name,will,automatically,be,resolved,into,the,corresponding,handler,bean,throws,beans,exception,if,the,handler,couldn,t,be,registered,throws,illegal,state,exception,if,there,is,a,conflicting,handler,registered;protected,void,register,handler,string,url,path,object,handler,throws,beans,exception,illegal,state,exception,assert,not,null,url,path,url,path,must,not,be,null,assert,not,null,handler,handler,object,must,not,be,null,object,resolved,handler,handler,if,this,lazy,init,handlers,handler,instanceof,string,string,handler,name,string,handler,if,get,application,context,is,singleton,handler,name,resolved,handler,get,application,context,get,bean,handler,name,object,mapped,handler,this,handler,map,get,url,path,if,mapped,handler,null,if,mapped,handler,resolved,handler,throw,new,illegal,state,exception,cannot,map,get,handler,description,handler,to,url,path,url,path,there,is,already,get,handler,description,mapped,handler,mapped,else,this,handler,map,put,url,path,resolved,handler,if,logger,is,info,enabled,logger,info,mapped,url,path,url,path,onto,get,handler,description,handler
AbstractUrlHandlerMapping -> protected void registerHandler(String urlPath, Object handler) throws BeansException, IllegalStateException;1496837955;Register the specified handler for the given URL path._@param urlPath the URL the bean should be mapped to_@param handler the handler instance or handler bean name String_(a bean name will automatically be resolved into the corresponding handler bean)_@throws BeansException if the handler couldn't be registered_@throws IllegalStateException if there is a conflicting handler registered;protected void registerHandler(String urlPath, Object handler) throws BeansException, IllegalStateException {_		Assert.notNull(urlPath, "URL path must not be null")__		Assert.notNull(handler, "Handler object must not be null")__		Object resolvedHandler = handler___		_		if (!this.lazyInitHandlers && handler instanceof String) {_			String handlerName = (String) handler__			if (obtainApplicationContext().isSingleton(handlerName)) {_				resolvedHandler = obtainApplicationContext().getBean(handlerName)__			}_		}__		Object mappedHandler = this.handlerMap.get(urlPath)__		if (mappedHandler != null) {_			if (mappedHandler != resolvedHandler) {_				throw new IllegalStateException(_						"Cannot map " + getHandlerDescription(handler) + " to URL path [" + urlPath +_						"]: There is already " + getHandlerDescription(mappedHandler) + " mapped.")__			}_		}_		else {_			this.handlerMap.put(urlPath, resolvedHandler)__			if (logger.isInfoEnabled()) {_				logger.info("Mapped URL path [" + urlPath + "] onto " + getHandlerDescription(handler))__			}_		}_	};register,the,specified,handler,for,the,given,url,path,param,url,path,the,url,the,bean,should,be,mapped,to,param,handler,the,handler,instance,or,handler,bean,name,string,a,bean,name,will,automatically,be,resolved,into,the,corresponding,handler,bean,throws,beans,exception,if,the,handler,couldn,t,be,registered,throws,illegal,state,exception,if,there,is,a,conflicting,handler,registered;protected,void,register,handler,string,url,path,object,handler,throws,beans,exception,illegal,state,exception,assert,not,null,url,path,url,path,must,not,be,null,assert,not,null,handler,handler,object,must,not,be,null,object,resolved,handler,handler,if,this,lazy,init,handlers,handler,instanceof,string,string,handler,name,string,handler,if,obtain,application,context,is,singleton,handler,name,resolved,handler,obtain,application,context,get,bean,handler,name,object,mapped,handler,this,handler,map,get,url,path,if,mapped,handler,null,if,mapped,handler,resolved,handler,throw,new,illegal,state,exception,cannot,map,get,handler,description,handler,to,url,path,url,path,there,is,already,get,handler,description,mapped,handler,mapped,else,this,handler,map,put,url,path,resolved,handler,if,logger,is,info,enabled,logger,info,mapped,url,path,url,path,onto,get,handler,description,handler
AbstractUrlHandlerMapping -> protected void registerHandler(String urlPath, Object handler) throws BeansException, IllegalStateException;1497039338;Register the specified handler for the given URL path._@param urlPath the URL the bean should be mapped to_@param handler the handler instance or handler bean name String_(a bean name will automatically be resolved into the corresponding handler bean)_@throws BeansException if the handler couldn't be registered_@throws IllegalStateException if there is a conflicting handler registered;protected void registerHandler(String urlPath, Object handler) throws BeansException, IllegalStateException {_		Assert.notNull(urlPath, "URL path must not be null")__		Assert.notNull(handler, "Handler object must not be null")__		Object resolvedHandler = handler___		_		if (!this.lazyInitHandlers && handler instanceof String) {_			String handlerName = (String) handler__			if (obtainApplicationContext().isSingleton(handlerName)) {_				resolvedHandler = obtainApplicationContext().getBean(handlerName)__			}_		}__		Object mappedHandler = this.handlerMap.get(urlPath)__		if (mappedHandler != null) {_			if (mappedHandler != resolvedHandler) {_				throw new IllegalStateException(_						"Cannot map " + getHandlerDescription(handler) + " to URL path [" + urlPath +_						"]: There is already " + getHandlerDescription(mappedHandler) + " mapped.")__			}_		}_		else {_			this.handlerMap.put(urlPath, resolvedHandler)__			if (logger.isInfoEnabled()) {_				logger.info("Mapped URL path [" + urlPath + "] onto " + getHandlerDescription(handler))__			}_		}_	};register,the,specified,handler,for,the,given,url,path,param,url,path,the,url,the,bean,should,be,mapped,to,param,handler,the,handler,instance,or,handler,bean,name,string,a,bean,name,will,automatically,be,resolved,into,the,corresponding,handler,bean,throws,beans,exception,if,the,handler,couldn,t,be,registered,throws,illegal,state,exception,if,there,is,a,conflicting,handler,registered;protected,void,register,handler,string,url,path,object,handler,throws,beans,exception,illegal,state,exception,assert,not,null,url,path,url,path,must,not,be,null,assert,not,null,handler,handler,object,must,not,be,null,object,resolved,handler,handler,if,this,lazy,init,handlers,handler,instanceof,string,string,handler,name,string,handler,if,obtain,application,context,is,singleton,handler,name,resolved,handler,obtain,application,context,get,bean,handler,name,object,mapped,handler,this,handler,map,get,url,path,if,mapped,handler,null,if,mapped,handler,resolved,handler,throw,new,illegal,state,exception,cannot,map,get,handler,description,handler,to,url,path,url,path,there,is,already,get,handler,description,mapped,handler,mapped,else,this,handler,map,put,url,path,resolved,handler,if,logger,is,info,enabled,logger,info,mapped,url,path,url,path,onto,get,handler,description,handler
AbstractUrlHandlerMapping -> protected void registerHandler(String urlPath, Object handler) throws BeansException, IllegalStateException;1497232764;Register the specified handler for the given URL path._@param urlPath the URL the bean should be mapped to_@param handler the handler instance or handler bean name String_(a bean name will automatically be resolved into the corresponding handler bean)_@throws BeansException if the handler couldn't be registered_@throws IllegalStateException if there is a conflicting handler registered;protected void registerHandler(String urlPath, Object handler) throws BeansException, IllegalStateException {_		Assert.notNull(urlPath, "URL path must not be null")__		Assert.notNull(handler, "Handler object must not be null")__		Object resolvedHandler = handler___		_		if (!this.lazyInitHandlers && handler instanceof String) {_			String handlerName = (String) handler__			if (obtainApplicationContext().isSingleton(handlerName)) {_				resolvedHandler = obtainApplicationContext().getBean(handlerName)__			}_		}__		Object mappedHandler = this.handlerMap.get(urlPath)__		if (mappedHandler != null) {_			if (mappedHandler != resolvedHandler) {_				throw new IllegalStateException(_						"Cannot map " + getHandlerDescription(handler) + " to URL path [" + urlPath +_						"]: There is already " + getHandlerDescription(mappedHandler) + " mapped.")__			}_		}_		else {_			this.handlerMap.put(urlPath, resolvedHandler)__			if (logger.isInfoEnabled()) {_				logger.info("Mapped URL path [" + urlPath + "] onto " + getHandlerDescription(handler))__			}_		}_	};register,the,specified,handler,for,the,given,url,path,param,url,path,the,url,the,bean,should,be,mapped,to,param,handler,the,handler,instance,or,handler,bean,name,string,a,bean,name,will,automatically,be,resolved,into,the,corresponding,handler,bean,throws,beans,exception,if,the,handler,couldn,t,be,registered,throws,illegal,state,exception,if,there,is,a,conflicting,handler,registered;protected,void,register,handler,string,url,path,object,handler,throws,beans,exception,illegal,state,exception,assert,not,null,url,path,url,path,must,not,be,null,assert,not,null,handler,handler,object,must,not,be,null,object,resolved,handler,handler,if,this,lazy,init,handlers,handler,instanceof,string,string,handler,name,string,handler,if,obtain,application,context,is,singleton,handler,name,resolved,handler,obtain,application,context,get,bean,handler,name,object,mapped,handler,this,handler,map,get,url,path,if,mapped,handler,null,if,mapped,handler,resolved,handler,throw,new,illegal,state,exception,cannot,map,get,handler,description,handler,to,url,path,url,path,there,is,already,get,handler,description,mapped,handler,mapped,else,this,handler,map,put,url,path,resolved,handler,if,logger,is,info,enabled,logger,info,mapped,url,path,url,path,onto,get,handler,description,handler
AbstractUrlHandlerMapping -> protected void registerHandler(String urlPath, Object handler) throws BeansException, IllegalStateException;1497286385;Register the specified handler for the given URL path._@param urlPath the URL the bean should be mapped to_@param handler the handler instance or handler bean name String_(a bean name will automatically be resolved into the corresponding handler bean)_@throws BeansException if the handler couldn't be registered_@throws IllegalStateException if there is a conflicting handler registered;protected void registerHandler(String urlPath, Object handler) throws BeansException, IllegalStateException {_		Assert.notNull(urlPath, "URL path must not be null")__		Assert.notNull(handler, "Handler object must not be null")__		Object resolvedHandler = handler____		_		if (!this.lazyInitHandlers && handler instanceof String) {_			String handlerName = (String) handler__			if (obtainApplicationContext().isSingleton(handlerName)) {_				resolvedHandler = obtainApplicationContext().getBean(handlerName)__			}_		}_		if (this.patternRegistry == null) {_			this.patternRegistry = new PathPatternRegistry<>(getPathPatternParser())__		}__		Map<PathPattern, Object> patternsMap = this.patternRegistry.getPatternsMap()__		if (patternsMap.containsKey(urlPath)) {_			Object mappedHandler = patternsMap.get(urlPath)__			if (mappedHandler != null) {_				if (mappedHandler != resolvedHandler) {_					throw new IllegalStateException(_							"Cannot map " + getHandlerDescription(handler) + " to URL path [" + urlPath +_									"]: There is already " + getHandlerDescription(mappedHandler) + " mapped.")__				}_			}_		}_		else {_			this.patternRegistry.register(urlPath, resolvedHandler)__		}__		if (logger.isInfoEnabled()) {_			logger.info("Mapped URL path [" + urlPath + "] onto " + getHandlerDescription(handler))__		}_	};register,the,specified,handler,for,the,given,url,path,param,url,path,the,url,the,bean,should,be,mapped,to,param,handler,the,handler,instance,or,handler,bean,name,string,a,bean,name,will,automatically,be,resolved,into,the,corresponding,handler,bean,throws,beans,exception,if,the,handler,couldn,t,be,registered,throws,illegal,state,exception,if,there,is,a,conflicting,handler,registered;protected,void,register,handler,string,url,path,object,handler,throws,beans,exception,illegal,state,exception,assert,not,null,url,path,url,path,must,not,be,null,assert,not,null,handler,handler,object,must,not,be,null,object,resolved,handler,handler,if,this,lazy,init,handlers,handler,instanceof,string,string,handler,name,string,handler,if,obtain,application,context,is,singleton,handler,name,resolved,handler,obtain,application,context,get,bean,handler,name,if,this,pattern,registry,null,this,pattern,registry,new,path,pattern,registry,get,path,pattern,parser,map,path,pattern,object,patterns,map,this,pattern,registry,get,patterns,map,if,patterns,map,contains,key,url,path,object,mapped,handler,patterns,map,get,url,path,if,mapped,handler,null,if,mapped,handler,resolved,handler,throw,new,illegal,state,exception,cannot,map,get,handler,description,handler,to,url,path,url,path,there,is,already,get,handler,description,mapped,handler,mapped,else,this,pattern,registry,register,url,path,resolved,handler,if,logger,is,info,enabled,logger,info,mapped,url,path,url,path,onto,get,handler,description,handler
AbstractUrlHandlerMapping -> protected void registerHandler(String urlPath, Object handler) throws BeansException, IllegalStateException;1498756719;Register the specified handler for the given URL path._@param urlPath the URL the bean should be mapped to_@param handler the handler instance or handler bean name String_(a bean name will automatically be resolved into the corresponding handler bean)_@throws BeansException if the handler couldn't be registered_@throws IllegalStateException if there is a conflicting handler registered;protected void registerHandler(String urlPath, Object handler) throws BeansException, IllegalStateException {_		Assert.notNull(urlPath, "URL path must not be null")__		Assert.notNull(handler, "Handler object must not be null")__		Object resolvedHandler = handler____		_		if (!this.lazyInitHandlers && handler instanceof String) {_			String handlerName = (String) handler__			if (obtainApplicationContext().isSingleton(handlerName)) {_				resolvedHandler = obtainApplicationContext().getBean(handlerName)__			}_		}_		if (this.patternRegistry == null) {_			this.patternRegistry = new PathPatternRegistry<>(getPathPatternParser())__		}__		Map<PathPattern, Object> patternsMap = this.patternRegistry.getPatternsMap()__		if (patternsMap.containsKey(urlPath)) {_			Object mappedHandler = patternsMap.get(urlPath)__			if (mappedHandler != null) {_				if (mappedHandler != resolvedHandler) {_					throw new IllegalStateException(_							"Cannot map " + getHandlerDescription(handler) + " to URL path [" + urlPath +_									"]: There is already " + getHandlerDescription(mappedHandler) + " mapped.")__				}_			}_		}_		else {_			this.patternRegistry.register(urlPath, resolvedHandler)__		}__		if (logger.isInfoEnabled()) {_			logger.info("Mapped URL path [" + urlPath + "] onto " + getHandlerDescription(handler))__		}_	};register,the,specified,handler,for,the,given,url,path,param,url,path,the,url,the,bean,should,be,mapped,to,param,handler,the,handler,instance,or,handler,bean,name,string,a,bean,name,will,automatically,be,resolved,into,the,corresponding,handler,bean,throws,beans,exception,if,the,handler,couldn,t,be,registered,throws,illegal,state,exception,if,there,is,a,conflicting,handler,registered;protected,void,register,handler,string,url,path,object,handler,throws,beans,exception,illegal,state,exception,assert,not,null,url,path,url,path,must,not,be,null,assert,not,null,handler,handler,object,must,not,be,null,object,resolved,handler,handler,if,this,lazy,init,handlers,handler,instanceof,string,string,handler,name,string,handler,if,obtain,application,context,is,singleton,handler,name,resolved,handler,obtain,application,context,get,bean,handler,name,if,this,pattern,registry,null,this,pattern,registry,new,path,pattern,registry,get,path,pattern,parser,map,path,pattern,object,patterns,map,this,pattern,registry,get,patterns,map,if,patterns,map,contains,key,url,path,object,mapped,handler,patterns,map,get,url,path,if,mapped,handler,null,if,mapped,handler,resolved,handler,throw,new,illegal,state,exception,cannot,map,get,handler,description,handler,to,url,path,url,path,there,is,already,get,handler,description,mapped,handler,mapped,else,this,pattern,registry,register,url,path,resolved,handler,if,logger,is,info,enabled,logger,info,mapped,url,path,url,path,onto,get,handler,description,handler
AbstractUrlHandlerMapping -> protected void registerHandler(String urlPath, Object handler) throws BeansException, IllegalStateException;1498780456;Register the specified handler for the given URL path._@param urlPath the URL the bean should be mapped to_@param handler the handler instance or handler bean name String_(a bean name will automatically be resolved into the corresponding handler bean)_@throws BeansException if the handler couldn't be registered_@throws IllegalStateException if there is a conflicting handler registered;protected void registerHandler(String urlPath, Object handler) throws BeansException, IllegalStateException {_		Assert.notNull(urlPath, "URL path must not be null")__		Assert.notNull(handler, "Handler object must not be null")__		Object resolvedHandler = handler____		_		if (!this.lazyInitHandlers && handler instanceof String) {_			String handlerName = (String) handler__			if (obtainApplicationContext().isSingleton(handlerName)) {_				resolvedHandler = obtainApplicationContext().getBean(handlerName)__			}_		}_		if (this.patternRegistry == null) {_			this.patternRegistry = new PathPatternRegistry<>(getPathPatternParser())__		}__		Map<PathPattern, Object> patternsMap = this.patternRegistry.getPatternsMap()__		if (patternsMap.containsKey(urlPath)) {_			Object mappedHandler = patternsMap.get(urlPath)__			if (mappedHandler != null) {_				if (mappedHandler != resolvedHandler) {_					throw new IllegalStateException(_							"Cannot map " + getHandlerDescription(handler) + " to URL path [" + urlPath +_									"]: There is already " + getHandlerDescription(mappedHandler) + " mapped.")__				}_			}_		}_		else {_			this.patternRegistry.register(urlPath, resolvedHandler)__		}__		if (logger.isInfoEnabled()) {_			logger.info("Mapped URL path [" + urlPath + "] onto " + getHandlerDescription(handler))__		}_	};register,the,specified,handler,for,the,given,url,path,param,url,path,the,url,the,bean,should,be,mapped,to,param,handler,the,handler,instance,or,handler,bean,name,string,a,bean,name,will,automatically,be,resolved,into,the,corresponding,handler,bean,throws,beans,exception,if,the,handler,couldn,t,be,registered,throws,illegal,state,exception,if,there,is,a,conflicting,handler,registered;protected,void,register,handler,string,url,path,object,handler,throws,beans,exception,illegal,state,exception,assert,not,null,url,path,url,path,must,not,be,null,assert,not,null,handler,handler,object,must,not,be,null,object,resolved,handler,handler,if,this,lazy,init,handlers,handler,instanceof,string,string,handler,name,string,handler,if,obtain,application,context,is,singleton,handler,name,resolved,handler,obtain,application,context,get,bean,handler,name,if,this,pattern,registry,null,this,pattern,registry,new,path,pattern,registry,get,path,pattern,parser,map,path,pattern,object,patterns,map,this,pattern,registry,get,patterns,map,if,patterns,map,contains,key,url,path,object,mapped,handler,patterns,map,get,url,path,if,mapped,handler,null,if,mapped,handler,resolved,handler,throw,new,illegal,state,exception,cannot,map,get,handler,description,handler,to,url,path,url,path,there,is,already,get,handler,description,mapped,handler,mapped,else,this,pattern,registry,register,url,path,resolved,handler,if,logger,is,info,enabled,logger,info,mapped,url,path,url,path,onto,get,handler,description,handler
AbstractUrlHandlerMapping -> protected void registerHandler(String urlPath, Object handler) throws BeansException, IllegalStateException;1498944474;Register the specified handler for the given URL path._@param urlPath the URL the bean should be mapped to_@param handler the handler instance or handler bean name String_(a bean name will automatically be resolved into the corresponding handler bean)_@throws BeansException if the handler couldn't be registered_@throws IllegalStateException if there is a conflicting handler registered;protected void registerHandler(String urlPath, Object handler) throws BeansException, IllegalStateException {_		Assert.notNull(urlPath, "URL path must not be null")__		Assert.notNull(handler, "Handler object must not be null")__		Object resolvedHandler = handler____		_		if (!this.lazyInitHandlers && handler instanceof String) {_			String handlerName = (String) handler__			if (obtainApplicationContext().isSingleton(handlerName)) {_				resolvedHandler = obtainApplicationContext().getBean(handlerName)__			}_		}_		if (this.patternRegistry == null) {_			this.patternRegistry = new PathPatternRegistry<>(getPathPatternParser())__		}__		Map<PathPattern, Object> patternsMap = this.patternRegistry.getPatternsMap()__		if (patternsMap.containsKey(urlPath)) {_			Object mappedHandler = patternsMap.get(urlPath)__			if (mappedHandler != null) {_				if (mappedHandler != resolvedHandler) {_					throw new IllegalStateException(_							"Cannot map " + getHandlerDescription(handler) + " to URL path [" + urlPath +_									"]: There is already " + getHandlerDescription(mappedHandler) + " mapped.")__				}_			}_		}_		else {_			this.patternRegistry.register(urlPath, resolvedHandler)__		}__		if (logger.isInfoEnabled()) {_			logger.info("Mapped URL path [" + urlPath + "] onto " + getHandlerDescription(handler))__		}_	};register,the,specified,handler,for,the,given,url,path,param,url,path,the,url,the,bean,should,be,mapped,to,param,handler,the,handler,instance,or,handler,bean,name,string,a,bean,name,will,automatically,be,resolved,into,the,corresponding,handler,bean,throws,beans,exception,if,the,handler,couldn,t,be,registered,throws,illegal,state,exception,if,there,is,a,conflicting,handler,registered;protected,void,register,handler,string,url,path,object,handler,throws,beans,exception,illegal,state,exception,assert,not,null,url,path,url,path,must,not,be,null,assert,not,null,handler,handler,object,must,not,be,null,object,resolved,handler,handler,if,this,lazy,init,handlers,handler,instanceof,string,string,handler,name,string,handler,if,obtain,application,context,is,singleton,handler,name,resolved,handler,obtain,application,context,get,bean,handler,name,if,this,pattern,registry,null,this,pattern,registry,new,path,pattern,registry,get,path,pattern,parser,map,path,pattern,object,patterns,map,this,pattern,registry,get,patterns,map,if,patterns,map,contains,key,url,path,object,mapped,handler,patterns,map,get,url,path,if,mapped,handler,null,if,mapped,handler,resolved,handler,throw,new,illegal,state,exception,cannot,map,get,handler,description,handler,to,url,path,url,path,there,is,already,get,handler,description,mapped,handler,mapped,else,this,pattern,registry,register,url,path,resolved,handler,if,logger,is,info,enabled,logger,info,mapped,url,path,url,path,onto,get,handler,description,handler
AbstractUrlHandlerMapping -> protected void registerHandler(String urlPath, Object handler) throws BeansException, IllegalStateException;1498953917;Register the specified handler for the given URL path._@param urlPath the URL the bean should be mapped to_@param handler the handler instance or handler bean name String_(a bean name will automatically be resolved into the corresponding handler bean)_@throws BeansException if the handler couldn't be registered_@throws IllegalStateException if there is a conflicting handler registered;protected void registerHandler(String urlPath, Object handler) throws BeansException, IllegalStateException {_		Assert.notNull(urlPath, "URL path must not be null")__		Assert.notNull(handler, "Handler object must not be null")__		Object resolvedHandler = handler____		_		if (!this.lazyInitHandlers && handler instanceof String) {_			String handlerName = (String) handler__			if (obtainApplicationContext().isSingleton(handlerName)) {_				resolvedHandler = obtainApplicationContext().getBean(handlerName)__			}_		}_		if (this.patternRegistry == null) {_			this.patternRegistry = new PathPatternRegistry<>(getPathPatternParser())__		}__		Map<PathPattern, Object> patternsMap = this.patternRegistry.getPatternsMap()__		if (patternsMap.containsKey(urlPath)) {_			Object mappedHandler = patternsMap.get(urlPath)__			if (mappedHandler != null) {_				if (mappedHandler != resolvedHandler) {_					throw new IllegalStateException(_							"Cannot map " + getHandlerDescription(handler) + " to URL path [" + urlPath +_									"]: There is already " + getHandlerDescription(mappedHandler) + " mapped.")__				}_			}_		}_		else {_			this.patternRegistry.register(urlPath, resolvedHandler)__		}__		if (logger.isInfoEnabled()) {_			logger.info("Mapped URL path [" + urlPath + "] onto " + getHandlerDescription(handler))__		}_	};register,the,specified,handler,for,the,given,url,path,param,url,path,the,url,the,bean,should,be,mapped,to,param,handler,the,handler,instance,or,handler,bean,name,string,a,bean,name,will,automatically,be,resolved,into,the,corresponding,handler,bean,throws,beans,exception,if,the,handler,couldn,t,be,registered,throws,illegal,state,exception,if,there,is,a,conflicting,handler,registered;protected,void,register,handler,string,url,path,object,handler,throws,beans,exception,illegal,state,exception,assert,not,null,url,path,url,path,must,not,be,null,assert,not,null,handler,handler,object,must,not,be,null,object,resolved,handler,handler,if,this,lazy,init,handlers,handler,instanceof,string,string,handler,name,string,handler,if,obtain,application,context,is,singleton,handler,name,resolved,handler,obtain,application,context,get,bean,handler,name,if,this,pattern,registry,null,this,pattern,registry,new,path,pattern,registry,get,path,pattern,parser,map,path,pattern,object,patterns,map,this,pattern,registry,get,patterns,map,if,patterns,map,contains,key,url,path,object,mapped,handler,patterns,map,get,url,path,if,mapped,handler,null,if,mapped,handler,resolved,handler,throw,new,illegal,state,exception,cannot,map,get,handler,description,handler,to,url,path,url,path,there,is,already,get,handler,description,mapped,handler,mapped,else,this,pattern,registry,register,url,path,resolved,handler,if,logger,is,info,enabled,logger,info,mapped,url,path,url,path,onto,get,handler,description,handler
AbstractUrlHandlerMapping -> protected void registerHandler(String urlPath, Object handler) throws BeansException, IllegalStateException;1520529117;Register the specified handler for the given URL path._@param urlPath the URL the bean should be mapped to_@param handler the handler instance or handler bean name String_(a bean name will automatically be resolved into the corresponding handler bean)_@throws BeansException if the handler couldn't be registered_@throws IllegalStateException if there is a conflicting handler registered;protected void registerHandler(String urlPath, Object handler) throws BeansException, IllegalStateException {_		Assert.notNull(urlPath, "URL path must not be null")__		Assert.notNull(handler, "Handler object must not be null")__		Object resolvedHandler = handler___		_		urlPath = prependLeadingSlash(urlPath)__		PathPattern pattern = getPathPatternParser().parse(urlPath)__		if (this.handlerMap.containsKey(pattern)) {_			Object existingHandler = this.handlerMap.get(pattern)__			if (existingHandler != null && existingHandler != resolvedHandler) {_				throw new IllegalStateException(_						"Cannot map " + getHandlerDescription(handler) + " to [" + urlPath + "]: " +_						"there is already " + getHandlerDescription(existingHandler) + " mapped.")__			}_		}__		_		if (!this.lazyInitHandlers && handler instanceof String) {_			String handlerName = (String) handler__			if (obtainApplicationContext().isSingleton(handlerName)) {_				resolvedHandler = obtainApplicationContext().getBean(handlerName)__			}_		}__		_		this.handlerMap.put(pattern, resolvedHandler)__		if (logger.isInfoEnabled()) {_			logger.info("Mapped URL path [" + urlPath + "] onto " + getHandlerDescription(handler))__		}_	};register,the,specified,handler,for,the,given,url,path,param,url,path,the,url,the,bean,should,be,mapped,to,param,handler,the,handler,instance,or,handler,bean,name,string,a,bean,name,will,automatically,be,resolved,into,the,corresponding,handler,bean,throws,beans,exception,if,the,handler,couldn,t,be,registered,throws,illegal,state,exception,if,there,is,a,conflicting,handler,registered;protected,void,register,handler,string,url,path,object,handler,throws,beans,exception,illegal,state,exception,assert,not,null,url,path,url,path,must,not,be,null,assert,not,null,handler,handler,object,must,not,be,null,object,resolved,handler,handler,url,path,prepend,leading,slash,url,path,path,pattern,pattern,get,path,pattern,parser,parse,url,path,if,this,handler,map,contains,key,pattern,object,existing,handler,this,handler,map,get,pattern,if,existing,handler,null,existing,handler,resolved,handler,throw,new,illegal,state,exception,cannot,map,get,handler,description,handler,to,url,path,there,is,already,get,handler,description,existing,handler,mapped,if,this,lazy,init,handlers,handler,instanceof,string,string,handler,name,string,handler,if,obtain,application,context,is,singleton,handler,name,resolved,handler,obtain,application,context,get,bean,handler,name,this,handler,map,put,pattern,resolved,handler,if,logger,is,info,enabled,logger,info,mapped,url,path,url,path,onto,get,handler,description,handler
AbstractUrlHandlerMapping -> protected void registerHandler(String urlPath, Object handler) throws BeansException, IllegalStateException;1529721864;Register the specified handler for the given URL path._@param urlPath the URL the bean should be mapped to_@param handler the handler instance or handler bean name String_(a bean name will automatically be resolved into the corresponding handler bean)_@throws BeansException if the handler couldn't be registered_@throws IllegalStateException if there is a conflicting handler registered;protected void registerHandler(String urlPath, Object handler) throws BeansException, IllegalStateException {_		Assert.notNull(urlPath, "URL path must not be null")__		Assert.notNull(handler, "Handler object must not be null")__		Object resolvedHandler = handler___		_		urlPath = prependLeadingSlash(urlPath)__		PathPattern pattern = getPathPatternParser().parse(urlPath)__		if (this.handlerMap.containsKey(pattern)) {_			Object existingHandler = this.handlerMap.get(pattern)__			if (existingHandler != null && existingHandler != resolvedHandler) {_				throw new IllegalStateException(_						"Cannot map " + getHandlerDescription(handler) + " to [" + urlPath + "]: " +_						"there is already " + getHandlerDescription(existingHandler) + " mapped.")__			}_		}__		_		if (!this.lazyInitHandlers && handler instanceof String) {_			String handlerName = (String) handler__			if (obtainApplicationContext().isSingleton(handlerName)) {_				resolvedHandler = obtainApplicationContext().getBean(handlerName)__			}_		}__		_		this.handlerMap.put(pattern, resolvedHandler)__		if (logger.isTraceEnabled()) {_			logger.trace("Mapped [" + urlPath + "] onto " + getHandlerDescription(handler))__		}_	};register,the,specified,handler,for,the,given,url,path,param,url,path,the,url,the,bean,should,be,mapped,to,param,handler,the,handler,instance,or,handler,bean,name,string,a,bean,name,will,automatically,be,resolved,into,the,corresponding,handler,bean,throws,beans,exception,if,the,handler,couldn,t,be,registered,throws,illegal,state,exception,if,there,is,a,conflicting,handler,registered;protected,void,register,handler,string,url,path,object,handler,throws,beans,exception,illegal,state,exception,assert,not,null,url,path,url,path,must,not,be,null,assert,not,null,handler,handler,object,must,not,be,null,object,resolved,handler,handler,url,path,prepend,leading,slash,url,path,path,pattern,pattern,get,path,pattern,parser,parse,url,path,if,this,handler,map,contains,key,pattern,object,existing,handler,this,handler,map,get,pattern,if,existing,handler,null,existing,handler,resolved,handler,throw,new,illegal,state,exception,cannot,map,get,handler,description,handler,to,url,path,there,is,already,get,handler,description,existing,handler,mapped,if,this,lazy,init,handlers,handler,instanceof,string,string,handler,name,string,handler,if,obtain,application,context,is,singleton,handler,name,resolved,handler,obtain,application,context,get,bean,handler,name,this,handler,map,put,pattern,resolved,handler,if,logger,is,trace,enabled,logger,trace,mapped,url,path,onto,get,handler,description,handler
AbstractUrlHandlerMapping -> protected void registerHandler(String urlPath, Object handler) throws BeansException, IllegalStateException;1530174524;Register the specified handler for the given URL path._@param urlPath the URL the bean should be mapped to_@param handler the handler instance or handler bean name String_(a bean name will automatically be resolved into the corresponding handler bean)_@throws BeansException if the handler couldn't be registered_@throws IllegalStateException if there is a conflicting handler registered;protected void registerHandler(String urlPath, Object handler) throws BeansException, IllegalStateException {_		Assert.notNull(urlPath, "URL path must not be null")__		Assert.notNull(handler, "Handler object must not be null")__		Object resolvedHandler = handler___		_		urlPath = prependLeadingSlash(urlPath)__		PathPattern pattern = getPathPatternParser().parse(urlPath)__		if (this.handlerMap.containsKey(pattern)) {_			Object existingHandler = this.handlerMap.get(pattern)__			if (existingHandler != null && existingHandler != resolvedHandler) {_				throw new IllegalStateException(_						"Cannot map " + getHandlerDescription(handler) + " to [" + urlPath + "]: " +_						"there is already " + getHandlerDescription(existingHandler) + " mapped.")__			}_		}__		_		if (!this.lazyInitHandlers && handler instanceof String) {_			String handlerName = (String) handler__			if (obtainApplicationContext().isSingleton(handlerName)) {_				resolvedHandler = obtainApplicationContext().getBean(handlerName)__			}_		}__		_		this.handlerMap.put(pattern, resolvedHandler)__		if (logger.isTraceEnabled()) {_			logger.trace("Mapped [" + urlPath + "] onto " + getHandlerDescription(handler))__		}_	};register,the,specified,handler,for,the,given,url,path,param,url,path,the,url,the,bean,should,be,mapped,to,param,handler,the,handler,instance,or,handler,bean,name,string,a,bean,name,will,automatically,be,resolved,into,the,corresponding,handler,bean,throws,beans,exception,if,the,handler,couldn,t,be,registered,throws,illegal,state,exception,if,there,is,a,conflicting,handler,registered;protected,void,register,handler,string,url,path,object,handler,throws,beans,exception,illegal,state,exception,assert,not,null,url,path,url,path,must,not,be,null,assert,not,null,handler,handler,object,must,not,be,null,object,resolved,handler,handler,url,path,prepend,leading,slash,url,path,path,pattern,pattern,get,path,pattern,parser,parse,url,path,if,this,handler,map,contains,key,pattern,object,existing,handler,this,handler,map,get,pattern,if,existing,handler,null,existing,handler,resolved,handler,throw,new,illegal,state,exception,cannot,map,get,handler,description,handler,to,url,path,there,is,already,get,handler,description,existing,handler,mapped,if,this,lazy,init,handlers,handler,instanceof,string,string,handler,name,string,handler,if,obtain,application,context,is,singleton,handler,name,resolved,handler,obtain,application,context,get,bean,handler,name,this,handler,map,put,pattern,resolved,handler,if,logger,is,trace,enabled,logger,trace,mapped,url,path,onto,get,handler,description,handler
AbstractUrlHandlerMapping -> protected void registerHandler(String urlPath, Object handler) throws BeansException, IllegalStateException;1530793633;Register the specified handler for the given URL path._@param urlPath the URL the bean should be mapped to_@param handler the handler instance or handler bean name String_(a bean name will automatically be resolved into the corresponding handler bean)_@throws BeansException if the handler couldn't be registered_@throws IllegalStateException if there is a conflicting handler registered;protected void registerHandler(String urlPath, Object handler) throws BeansException, IllegalStateException {_		Assert.notNull(urlPath, "URL path must not be null")__		Assert.notNull(handler, "Handler object must not be null")__		Object resolvedHandler = handler___		_		urlPath = prependLeadingSlash(urlPath)__		PathPattern pattern = getPathPatternParser().parse(urlPath)__		if (this.handlerMap.containsKey(pattern)) {_			Object existingHandler = this.handlerMap.get(pattern)__			if (existingHandler != null && existingHandler != resolvedHandler) {_				throw new IllegalStateException(_						"Cannot map " + getHandlerDescription(handler) + " to [" + urlPath + "]: " +_						"there is already " + getHandlerDescription(existingHandler) + " mapped.")__			}_		}__		_		if (!this.lazyInitHandlers && handler instanceof String) {_			String handlerName = (String) handler__			if (obtainApplicationContext().isSingleton(handlerName)) {_				resolvedHandler = obtainApplicationContext().getBean(handlerName)__			}_		}__		_		this.handlerMap.put(pattern, resolvedHandler)__		if (logger.isTraceEnabled()) {_			logger.trace("Mapped [" + urlPath + "] onto " + getHandlerDescription(handler))__		}_	};register,the,specified,handler,for,the,given,url,path,param,url,path,the,url,the,bean,should,be,mapped,to,param,handler,the,handler,instance,or,handler,bean,name,string,a,bean,name,will,automatically,be,resolved,into,the,corresponding,handler,bean,throws,beans,exception,if,the,handler,couldn,t,be,registered,throws,illegal,state,exception,if,there,is,a,conflicting,handler,registered;protected,void,register,handler,string,url,path,object,handler,throws,beans,exception,illegal,state,exception,assert,not,null,url,path,url,path,must,not,be,null,assert,not,null,handler,handler,object,must,not,be,null,object,resolved,handler,handler,url,path,prepend,leading,slash,url,path,path,pattern,pattern,get,path,pattern,parser,parse,url,path,if,this,handler,map,contains,key,pattern,object,existing,handler,this,handler,map,get,pattern,if,existing,handler,null,existing,handler,resolved,handler,throw,new,illegal,state,exception,cannot,map,get,handler,description,handler,to,url,path,there,is,already,get,handler,description,existing,handler,mapped,if,this,lazy,init,handlers,handler,instanceof,string,string,handler,name,string,handler,if,obtain,application,context,is,singleton,handler,name,resolved,handler,obtain,application,context,get,bean,handler,name,this,handler,map,put,pattern,resolved,handler,if,logger,is,trace,enabled,logger,trace,mapped,url,path,onto,get,handler,description,handler
AbstractUrlHandlerMapping -> protected void registerHandler(String[] urlPaths, String beanName) 			throws BeansException, IllegalStateException;1499679438;Register the specified handler for the given URL paths._@param urlPaths the URLs that the bean should be mapped to_@param beanName the name of the handler bean_@throws BeansException if the handler couldn't be registered_@throws IllegalStateException if there is a conflicting handler registered;protected void registerHandler(String[] urlPaths, String beanName)_			throws BeansException, IllegalStateException {__		Assert.notNull(urlPaths, "URL path array must not be null")__		for (String urlPath : urlPaths) {_			registerHandler(urlPath, beanName)__		}_	};register,the,specified,handler,for,the,given,url,paths,param,url,paths,the,urls,that,the,bean,should,be,mapped,to,param,bean,name,the,name,of,the,handler,bean,throws,beans,exception,if,the,handler,couldn,t,be,registered,throws,illegal,state,exception,if,there,is,a,conflicting,handler,registered;protected,void,register,handler,string,url,paths,string,bean,name,throws,beans,exception,illegal,state,exception,assert,not,null,url,paths,url,path,array,must,not,be,null,for,string,url,path,url,paths,register,handler,url,path,bean,name
AbstractUrlHandlerMapping -> protected void registerHandler(String[] urlPaths, String beanName) 			throws BeansException, IllegalStateException;1501237594;Register the specified handler for the given URL paths._@param urlPaths the URLs that the bean should be mapped to_@param beanName the name of the handler bean_@throws BeansException if the handler couldn't be registered_@throws IllegalStateException if there is a conflicting handler registered;protected void registerHandler(String[] urlPaths, String beanName)_			throws BeansException, IllegalStateException {__		Assert.notNull(urlPaths, "URL path array must not be null")__		for (String urlPath : urlPaths) {_			registerHandler(urlPath, beanName)__		}_	};register,the,specified,handler,for,the,given,url,paths,param,url,paths,the,urls,that,the,bean,should,be,mapped,to,param,bean,name,the,name,of,the,handler,bean,throws,beans,exception,if,the,handler,couldn,t,be,registered,throws,illegal,state,exception,if,there,is,a,conflicting,handler,registered;protected,void,register,handler,string,url,paths,string,bean,name,throws,beans,exception,illegal,state,exception,assert,not,null,url,paths,url,path,array,must,not,be,null,for,string,url,path,url,paths,register,handler,url,path,bean,name
AbstractUrlHandlerMapping -> protected void registerHandler(String[] urlPaths, String beanName) 			throws BeansException, IllegalStateException;1501690296;Register the specified handler for the given URL paths._@param urlPaths the URLs that the bean should be mapped to_@param beanName the name of the handler bean_@throws BeansException if the handler couldn't be registered_@throws IllegalStateException if there is a conflicting handler registered;protected void registerHandler(String[] urlPaths, String beanName)_			throws BeansException, IllegalStateException {__		Assert.notNull(urlPaths, "URL path array must not be null")__		for (String urlPath : urlPaths) {_			registerHandler(urlPath, beanName)__		}_	};register,the,specified,handler,for,the,given,url,paths,param,url,paths,the,urls,that,the,bean,should,be,mapped,to,param,bean,name,the,name,of,the,handler,bean,throws,beans,exception,if,the,handler,couldn,t,be,registered,throws,illegal,state,exception,if,there,is,a,conflicting,handler,registered;protected,void,register,handler,string,url,paths,string,bean,name,throws,beans,exception,illegal,state,exception,assert,not,null,url,paths,url,path,array,must,not,be,null,for,string,url,path,url,paths,register,handler,url,path,bean,name
AbstractUrlHandlerMapping -> protected void registerHandler(String[] urlPaths, String beanName) 			throws BeansException, IllegalStateException;1520075565;Register the specified handler for the given URL paths._@param urlPaths the URLs that the bean should be mapped to_@param beanName the name of the handler bean_@throws BeansException if the handler couldn't be registered_@throws IllegalStateException if there is a conflicting handler registered;protected void registerHandler(String[] urlPaths, String beanName)_			throws BeansException, IllegalStateException {__		Assert.notNull(urlPaths, "URL path array must not be null")__		for (String urlPath : urlPaths) {_			registerHandler(urlPath, beanName)__		}_	};register,the,specified,handler,for,the,given,url,paths,param,url,paths,the,urls,that,the,bean,should,be,mapped,to,param,bean,name,the,name,of,the,handler,bean,throws,beans,exception,if,the,handler,couldn,t,be,registered,throws,illegal,state,exception,if,there,is,a,conflicting,handler,registered;protected,void,register,handler,string,url,paths,string,bean,name,throws,beans,exception,illegal,state,exception,assert,not,null,url,paths,url,path,array,must,not,be,null,for,string,url,path,url,paths,register,handler,url,path,bean,name
AbstractUrlHandlerMapping -> public void setLazyInitHandlers(boolean lazyInitHandlers);1485986572;Set whether to lazily initialize handlers. Only applicable to_singleton handlers, as prototypes are always lazily initialized._Default is "false", as eager initialization allows for more efficiency_through referencing the controller objects directly._<p>If you want to allow your controllers to be lazily initialized,_make them "lazy-init" and set this flag to true. Just making them_"lazy-init" will not work, as they are initialized through the_references from the handler mapping in this case.;public void setLazyInitHandlers(boolean lazyInitHandlers) {_		this.lazyInitHandlers = lazyInitHandlers__	};set,whether,to,lazily,initialize,handlers,only,applicable,to,singleton,handlers,as,prototypes,are,always,lazily,initialized,default,is,false,as,eager,initialization,allows,for,more,efficiency,through,referencing,the,controller,objects,directly,p,if,you,want,to,allow,your,controllers,to,be,lazily,initialized,make,them,lazy,init,and,set,this,flag,to,true,just,making,them,lazy,init,will,not,work,as,they,are,initialized,through,the,references,from,the,handler,mapping,in,this,case;public,void,set,lazy,init,handlers,boolean,lazy,init,handlers,this,lazy,init,handlers,lazy,init,handlers
AbstractUrlHandlerMapping -> public void setLazyInitHandlers(boolean lazyInitHandlers);1486635693;Set whether to lazily initialize handlers. Only applicable to_singleton handlers, as prototypes are always lazily initialized._Default is "false", as eager initialization allows for more efficiency_through referencing the controller objects directly._<p>If you want to allow your controllers to be lazily initialized,_make them "lazy-init" and set this flag to true. Just making them_"lazy-init" will not work, as they are initialized through the_references from the handler mapping in this case.;public void setLazyInitHandlers(boolean lazyInitHandlers) {_		this.lazyInitHandlers = lazyInitHandlers__	};set,whether,to,lazily,initialize,handlers,only,applicable,to,singleton,handlers,as,prototypes,are,always,lazily,initialized,default,is,false,as,eager,initialization,allows,for,more,efficiency,through,referencing,the,controller,objects,directly,p,if,you,want,to,allow,your,controllers,to,be,lazily,initialized,make,them,lazy,init,and,set,this,flag,to,true,just,making,them,lazy,init,will,not,work,as,they,are,initialized,through,the,references,from,the,handler,mapping,in,this,case;public,void,set,lazy,init,handlers,boolean,lazy,init,handlers,this,lazy,init,handlers,lazy,init,handlers
AbstractUrlHandlerMapping -> public void setLazyInitHandlers(boolean lazyInitHandlers);1486747801;Set whether to lazily initialize handlers. Only applicable to_singleton handlers, as prototypes are always lazily initialized._Default is "false", as eager initialization allows for more efficiency_through referencing the controller objects directly._<p>If you want to allow your controllers to be lazily initialized,_make them "lazy-init" and set this flag to true. Just making them_"lazy-init" will not work, as they are initialized through the_references from the handler mapping in this case.;public void setLazyInitHandlers(boolean lazyInitHandlers) {_		this.lazyInitHandlers = lazyInitHandlers__	};set,whether,to,lazily,initialize,handlers,only,applicable,to,singleton,handlers,as,prototypes,are,always,lazily,initialized,default,is,false,as,eager,initialization,allows,for,more,efficiency,through,referencing,the,controller,objects,directly,p,if,you,want,to,allow,your,controllers,to,be,lazily,initialized,make,them,lazy,init,and,set,this,flag,to,true,just,making,them,lazy,init,will,not,work,as,they,are,initialized,through,the,references,from,the,handler,mapping,in,this,case;public,void,set,lazy,init,handlers,boolean,lazy,init,handlers,this,lazy,init,handlers,lazy,init,handlers
AbstractUrlHandlerMapping -> public void setLazyInitHandlers(boolean lazyInitHandlers);1486747828;Set whether to lazily initialize handlers. Only applicable to_singleton handlers, as prototypes are always lazily initialized._Default is "false", as eager initialization allows for more efficiency_through referencing the controller objects directly._<p>If you want to allow your controllers to be lazily initialized,_make them "lazy-init" and set this flag to true. Just making them_"lazy-init" will not work, as they are initialized through the_references from the handler mapping in this case.;public void setLazyInitHandlers(boolean lazyInitHandlers) {_		this.lazyInitHandlers = lazyInitHandlers__	};set,whether,to,lazily,initialize,handlers,only,applicable,to,singleton,handlers,as,prototypes,are,always,lazily,initialized,default,is,false,as,eager,initialization,allows,for,more,efficiency,through,referencing,the,controller,objects,directly,p,if,you,want,to,allow,your,controllers,to,be,lazily,initialized,make,them,lazy,init,and,set,this,flag,to,true,just,making,them,lazy,init,will,not,work,as,they,are,initialized,through,the,references,from,the,handler,mapping,in,this,case;public,void,set,lazy,init,handlers,boolean,lazy,init,handlers,this,lazy,init,handlers,lazy,init,handlers
AbstractUrlHandlerMapping -> public void setLazyInitHandlers(boolean lazyInitHandlers);1495035625;Set whether to lazily initialize handlers. Only applicable to_singleton handlers, as prototypes are always lazily initialized._Default is "false", as eager initialization allows for more efficiency_through referencing the controller objects directly._<p>If you want to allow your controllers to be lazily initialized,_make them "lazy-init" and set this flag to true. Just making them_"lazy-init" will not work, as they are initialized through the_references from the handler mapping in this case.;public void setLazyInitHandlers(boolean lazyInitHandlers) {_		this.lazyInitHandlers = lazyInitHandlers__	};set,whether,to,lazily,initialize,handlers,only,applicable,to,singleton,handlers,as,prototypes,are,always,lazily,initialized,default,is,false,as,eager,initialization,allows,for,more,efficiency,through,referencing,the,controller,objects,directly,p,if,you,want,to,allow,your,controllers,to,be,lazily,initialized,make,them,lazy,init,and,set,this,flag,to,true,just,making,them,lazy,init,will,not,work,as,they,are,initialized,through,the,references,from,the,handler,mapping,in,this,case;public,void,set,lazy,init,handlers,boolean,lazy,init,handlers,this,lazy,init,handlers,lazy,init,handlers
AbstractUrlHandlerMapping -> public void setLazyInitHandlers(boolean lazyInitHandlers);1495868221;Set whether to lazily initialize handlers. Only applicable to_singleton handlers, as prototypes are always lazily initialized._Default is "false", as eager initialization allows for more efficiency_through referencing the controller objects directly._<p>If you want to allow your controllers to be lazily initialized,_make them "lazy-init" and set this flag to true. Just making them_"lazy-init" will not work, as they are initialized through the_references from the handler mapping in this case.;public void setLazyInitHandlers(boolean lazyInitHandlers) {_		this.lazyInitHandlers = lazyInitHandlers__	};set,whether,to,lazily,initialize,handlers,only,applicable,to,singleton,handlers,as,prototypes,are,always,lazily,initialized,default,is,false,as,eager,initialization,allows,for,more,efficiency,through,referencing,the,controller,objects,directly,p,if,you,want,to,allow,your,controllers,to,be,lazily,initialized,make,them,lazy,init,and,set,this,flag,to,true,just,making,them,lazy,init,will,not,work,as,they,are,initialized,through,the,references,from,the,handler,mapping,in,this,case;public,void,set,lazy,init,handlers,boolean,lazy,init,handlers,this,lazy,init,handlers,lazy,init,handlers
AbstractUrlHandlerMapping -> public void setLazyInitHandlers(boolean lazyInitHandlers);1496334664;Set whether to lazily initialize handlers. Only applicable to_singleton handlers, as prototypes are always lazily initialized._Default is "false", as eager initialization allows for more efficiency_through referencing the controller objects directly._<p>If you want to allow your controllers to be lazily initialized,_make them "lazy-init" and set this flag to true. Just making them_"lazy-init" will not work, as they are initialized through the_references from the handler mapping in this case.;public void setLazyInitHandlers(boolean lazyInitHandlers) {_		this.lazyInitHandlers = lazyInitHandlers__	};set,whether,to,lazily,initialize,handlers,only,applicable,to,singleton,handlers,as,prototypes,are,always,lazily,initialized,default,is,false,as,eager,initialization,allows,for,more,efficiency,through,referencing,the,controller,objects,directly,p,if,you,want,to,allow,your,controllers,to,be,lazily,initialized,make,them,lazy,init,and,set,this,flag,to,true,just,making,them,lazy,init,will,not,work,as,they,are,initialized,through,the,references,from,the,handler,mapping,in,this,case;public,void,set,lazy,init,handlers,boolean,lazy,init,handlers,this,lazy,init,handlers,lazy,init,handlers
AbstractUrlHandlerMapping -> public void setLazyInitHandlers(boolean lazyInitHandlers);1496430942;Set whether to lazily initialize handlers. Only applicable to_singleton handlers, as prototypes are always lazily initialized._Default is "false", as eager initialization allows for more efficiency_through referencing the controller objects directly._<p>If you want to allow your controllers to be lazily initialized,_make them "lazy-init" and set this flag to true. Just making them_"lazy-init" will not work, as they are initialized through the_references from the handler mapping in this case.;public void setLazyInitHandlers(boolean lazyInitHandlers) {_		this.lazyInitHandlers = lazyInitHandlers__	};set,whether,to,lazily,initialize,handlers,only,applicable,to,singleton,handlers,as,prototypes,are,always,lazily,initialized,default,is,false,as,eager,initialization,allows,for,more,efficiency,through,referencing,the,controller,objects,directly,p,if,you,want,to,allow,your,controllers,to,be,lazily,initialized,make,them,lazy,init,and,set,this,flag,to,true,just,making,them,lazy,init,will,not,work,as,they,are,initialized,through,the,references,from,the,handler,mapping,in,this,case;public,void,set,lazy,init,handlers,boolean,lazy,init,handlers,this,lazy,init,handlers,lazy,init,handlers
AbstractUrlHandlerMapping -> public void setLazyInitHandlers(boolean lazyInitHandlers);1496837955;Set whether to lazily initialize handlers. Only applicable to_singleton handlers, as prototypes are always lazily initialized._Default is "false", as eager initialization allows for more efficiency_through referencing the controller objects directly._<p>If you want to allow your controllers to be lazily initialized,_make them "lazy-init" and set this flag to true. Just making them_"lazy-init" will not work, as they are initialized through the_references from the handler mapping in this case.;public void setLazyInitHandlers(boolean lazyInitHandlers) {_		this.lazyInitHandlers = lazyInitHandlers__	};set,whether,to,lazily,initialize,handlers,only,applicable,to,singleton,handlers,as,prototypes,are,always,lazily,initialized,default,is,false,as,eager,initialization,allows,for,more,efficiency,through,referencing,the,controller,objects,directly,p,if,you,want,to,allow,your,controllers,to,be,lazily,initialized,make,them,lazy,init,and,set,this,flag,to,true,just,making,them,lazy,init,will,not,work,as,they,are,initialized,through,the,references,from,the,handler,mapping,in,this,case;public,void,set,lazy,init,handlers,boolean,lazy,init,handlers,this,lazy,init,handlers,lazy,init,handlers
AbstractUrlHandlerMapping -> public void setLazyInitHandlers(boolean lazyInitHandlers);1497039338;Set whether to lazily initialize handlers. Only applicable to_singleton handlers, as prototypes are always lazily initialized._Default is "false", as eager initialization allows for more efficiency_through referencing the controller objects directly._<p>If you want to allow your controllers to be lazily initialized,_make them "lazy-init" and set this flag to true. Just making them_"lazy-init" will not work, as they are initialized through the_references from the handler mapping in this case.;public void setLazyInitHandlers(boolean lazyInitHandlers) {_		this.lazyInitHandlers = lazyInitHandlers__	};set,whether,to,lazily,initialize,handlers,only,applicable,to,singleton,handlers,as,prototypes,are,always,lazily,initialized,default,is,false,as,eager,initialization,allows,for,more,efficiency,through,referencing,the,controller,objects,directly,p,if,you,want,to,allow,your,controllers,to,be,lazily,initialized,make,them,lazy,init,and,set,this,flag,to,true,just,making,them,lazy,init,will,not,work,as,they,are,initialized,through,the,references,from,the,handler,mapping,in,this,case;public,void,set,lazy,init,handlers,boolean,lazy,init,handlers,this,lazy,init,handlers,lazy,init,handlers
AbstractUrlHandlerMapping -> public void setLazyInitHandlers(boolean lazyInitHandlers);1497232764;Set whether to lazily initialize handlers. Only applicable to_singleton handlers, as prototypes are always lazily initialized._Default is "false", as eager initialization allows for more efficiency_through referencing the controller objects directly._<p>If you want to allow your controllers to be lazily initialized,_make them "lazy-init" and set this flag to true. Just making them_"lazy-init" will not work, as they are initialized through the_references from the handler mapping in this case.;public void setLazyInitHandlers(boolean lazyInitHandlers) {_		this.lazyInitHandlers = lazyInitHandlers__	};set,whether,to,lazily,initialize,handlers,only,applicable,to,singleton,handlers,as,prototypes,are,always,lazily,initialized,default,is,false,as,eager,initialization,allows,for,more,efficiency,through,referencing,the,controller,objects,directly,p,if,you,want,to,allow,your,controllers,to,be,lazily,initialized,make,them,lazy,init,and,set,this,flag,to,true,just,making,them,lazy,init,will,not,work,as,they,are,initialized,through,the,references,from,the,handler,mapping,in,this,case;public,void,set,lazy,init,handlers,boolean,lazy,init,handlers,this,lazy,init,handlers,lazy,init,handlers
AbstractUrlHandlerMapping -> public void setLazyInitHandlers(boolean lazyInitHandlers);1497286385;Set whether to lazily initialize handlers. Only applicable to_singleton handlers, as prototypes are always lazily initialized._Default is "false", as eager initialization allows for more efficiency_through referencing the controller objects directly._<p>If you want to allow your controllers to be lazily initialized,_make them "lazy-init" and set this flag to true. Just making them_"lazy-init" will not work, as they are initialized through the_references from the handler mapping in this case.;public void setLazyInitHandlers(boolean lazyInitHandlers) {_		this.lazyInitHandlers = lazyInitHandlers__	};set,whether,to,lazily,initialize,handlers,only,applicable,to,singleton,handlers,as,prototypes,are,always,lazily,initialized,default,is,false,as,eager,initialization,allows,for,more,efficiency,through,referencing,the,controller,objects,directly,p,if,you,want,to,allow,your,controllers,to,be,lazily,initialized,make,them,lazy,init,and,set,this,flag,to,true,just,making,them,lazy,init,will,not,work,as,they,are,initialized,through,the,references,from,the,handler,mapping,in,this,case;public,void,set,lazy,init,handlers,boolean,lazy,init,handlers,this,lazy,init,handlers,lazy,init,handlers
AbstractUrlHandlerMapping -> public void setLazyInitHandlers(boolean lazyInitHandlers);1498756719;Set whether to lazily initialize handlers. Only applicable to_singleton handlers, as prototypes are always lazily initialized._Default is "false", as eager initialization allows for more efficiency_through referencing the controller objects directly._<p>If you want to allow your controllers to be lazily initialized,_make them "lazy-init" and set this flag to true. Just making them_"lazy-init" will not work, as they are initialized through the_references from the handler mapping in this case.;public void setLazyInitHandlers(boolean lazyInitHandlers) {_		this.lazyInitHandlers = lazyInitHandlers__	};set,whether,to,lazily,initialize,handlers,only,applicable,to,singleton,handlers,as,prototypes,are,always,lazily,initialized,default,is,false,as,eager,initialization,allows,for,more,efficiency,through,referencing,the,controller,objects,directly,p,if,you,want,to,allow,your,controllers,to,be,lazily,initialized,make,them,lazy,init,and,set,this,flag,to,true,just,making,them,lazy,init,will,not,work,as,they,are,initialized,through,the,references,from,the,handler,mapping,in,this,case;public,void,set,lazy,init,handlers,boolean,lazy,init,handlers,this,lazy,init,handlers,lazy,init,handlers
AbstractUrlHandlerMapping -> public void setLazyInitHandlers(boolean lazyInitHandlers);1498780456;Set whether to lazily initialize handlers. Only applicable to_singleton handlers, as prototypes are always lazily initialized._Default is "false", as eager initialization allows for more efficiency_through referencing the controller objects directly._<p>If you want to allow your controllers to be lazily initialized,_make them "lazy-init" and set this flag to true. Just making them_"lazy-init" will not work, as they are initialized through the_references from the handler mapping in this case.;public void setLazyInitHandlers(boolean lazyInitHandlers) {_		this.lazyInitHandlers = lazyInitHandlers__	};set,whether,to,lazily,initialize,handlers,only,applicable,to,singleton,handlers,as,prototypes,are,always,lazily,initialized,default,is,false,as,eager,initialization,allows,for,more,efficiency,through,referencing,the,controller,objects,directly,p,if,you,want,to,allow,your,controllers,to,be,lazily,initialized,make,them,lazy,init,and,set,this,flag,to,true,just,making,them,lazy,init,will,not,work,as,they,are,initialized,through,the,references,from,the,handler,mapping,in,this,case;public,void,set,lazy,init,handlers,boolean,lazy,init,handlers,this,lazy,init,handlers,lazy,init,handlers
AbstractUrlHandlerMapping -> public void setLazyInitHandlers(boolean lazyInitHandlers);1498944474;Set whether to lazily initialize handlers. Only applicable to_singleton handlers, as prototypes are always lazily initialized._Default is "false", as eager initialization allows for more efficiency_through referencing the controller objects directly._<p>If you want to allow your controllers to be lazily initialized,_make them "lazy-init" and set this flag to true. Just making them_"lazy-init" will not work, as they are initialized through the_references from the handler mapping in this case.;public void setLazyInitHandlers(boolean lazyInitHandlers) {_		this.lazyInitHandlers = lazyInitHandlers__	};set,whether,to,lazily,initialize,handlers,only,applicable,to,singleton,handlers,as,prototypes,are,always,lazily,initialized,default,is,false,as,eager,initialization,allows,for,more,efficiency,through,referencing,the,controller,objects,directly,p,if,you,want,to,allow,your,controllers,to,be,lazily,initialized,make,them,lazy,init,and,set,this,flag,to,true,just,making,them,lazy,init,will,not,work,as,they,are,initialized,through,the,references,from,the,handler,mapping,in,this,case;public,void,set,lazy,init,handlers,boolean,lazy,init,handlers,this,lazy,init,handlers,lazy,init,handlers
AbstractUrlHandlerMapping -> public void setLazyInitHandlers(boolean lazyInitHandlers);1498953917;Set whether to lazily initialize handlers. Only applicable to_singleton handlers, as prototypes are always lazily initialized._Default is "false", as eager initialization allows for more efficiency_through referencing the controller objects directly._<p>If you want to allow your controllers to be lazily initialized,_make them "lazy-init" and set this flag to true. Just making them_"lazy-init" will not work, as they are initialized through the_references from the handler mapping in this case.;public void setLazyInitHandlers(boolean lazyInitHandlers) {_		this.lazyInitHandlers = lazyInitHandlers__	};set,whether,to,lazily,initialize,handlers,only,applicable,to,singleton,handlers,as,prototypes,are,always,lazily,initialized,default,is,false,as,eager,initialization,allows,for,more,efficiency,through,referencing,the,controller,objects,directly,p,if,you,want,to,allow,your,controllers,to,be,lazily,initialized,make,them,lazy,init,and,set,this,flag,to,true,just,making,them,lazy,init,will,not,work,as,they,are,initialized,through,the,references,from,the,handler,mapping,in,this,case;public,void,set,lazy,init,handlers,boolean,lazy,init,handlers,this,lazy,init,handlers,lazy,init,handlers
AbstractUrlHandlerMapping -> public void setLazyInitHandlers(boolean lazyInitHandlers);1499679438;Set whether to lazily initialize handlers. Only applicable to_singleton handlers, as prototypes are always lazily initialized._Default is "false", as eager initialization allows for more efficiency_through referencing the controller objects directly._<p>If you want to allow your controllers to be lazily initialized,_make them "lazy-init" and set this flag to true. Just making them_"lazy-init" will not work, as they are initialized through the_references from the handler mapping in this case.;public void setLazyInitHandlers(boolean lazyInitHandlers) {_		this.lazyInitHandlers = lazyInitHandlers__	};set,whether,to,lazily,initialize,handlers,only,applicable,to,singleton,handlers,as,prototypes,are,always,lazily,initialized,default,is,false,as,eager,initialization,allows,for,more,efficiency,through,referencing,the,controller,objects,directly,p,if,you,want,to,allow,your,controllers,to,be,lazily,initialized,make,them,lazy,init,and,set,this,flag,to,true,just,making,them,lazy,init,will,not,work,as,they,are,initialized,through,the,references,from,the,handler,mapping,in,this,case;public,void,set,lazy,init,handlers,boolean,lazy,init,handlers,this,lazy,init,handlers,lazy,init,handlers
AbstractUrlHandlerMapping -> public void setLazyInitHandlers(boolean lazyInitHandlers);1501237594;Set whether to lazily initialize handlers. Only applicable to_singleton handlers, as prototypes are always lazily initialized._Default is "false", as eager initialization allows for more efficiency_through referencing the controller objects directly._<p>If you want to allow your controllers to be lazily initialized,_make them "lazy-init" and set this flag to true. Just making them_"lazy-init" will not work, as they are initialized through the_references from the handler mapping in this case.;public void setLazyInitHandlers(boolean lazyInitHandlers) {_		this.lazyInitHandlers = lazyInitHandlers__	};set,whether,to,lazily,initialize,handlers,only,applicable,to,singleton,handlers,as,prototypes,are,always,lazily,initialized,default,is,false,as,eager,initialization,allows,for,more,efficiency,through,referencing,the,controller,objects,directly,p,if,you,want,to,allow,your,controllers,to,be,lazily,initialized,make,them,lazy,init,and,set,this,flag,to,true,just,making,them,lazy,init,will,not,work,as,they,are,initialized,through,the,references,from,the,handler,mapping,in,this,case;public,void,set,lazy,init,handlers,boolean,lazy,init,handlers,this,lazy,init,handlers,lazy,init,handlers
AbstractUrlHandlerMapping -> public void setLazyInitHandlers(boolean lazyInitHandlers);1501690296;Set whether to lazily initialize handlers. Only applicable to_singleton handlers, as prototypes are always lazily initialized._Default is "false", as eager initialization allows for more efficiency_through referencing the controller objects directly._<p>If you want to allow your controllers to be lazily initialized,_make them "lazy-init" and set this flag to true. Just making them_"lazy-init" will not work, as they are initialized through the_references from the handler mapping in this case.;public void setLazyInitHandlers(boolean lazyInitHandlers) {_		this.lazyInitHandlers = lazyInitHandlers__	};set,whether,to,lazily,initialize,handlers,only,applicable,to,singleton,handlers,as,prototypes,are,always,lazily,initialized,default,is,false,as,eager,initialization,allows,for,more,efficiency,through,referencing,the,controller,objects,directly,p,if,you,want,to,allow,your,controllers,to,be,lazily,initialized,make,them,lazy,init,and,set,this,flag,to,true,just,making,them,lazy,init,will,not,work,as,they,are,initialized,through,the,references,from,the,handler,mapping,in,this,case;public,void,set,lazy,init,handlers,boolean,lazy,init,handlers,this,lazy,init,handlers,lazy,init,handlers
AbstractUrlHandlerMapping -> public void setLazyInitHandlers(boolean lazyInitHandlers);1520075565;Set whether to lazily initialize handlers. Only applicable to_singleton handlers, as prototypes are always lazily initialized._Default is "false", as eager initialization allows for more efficiency_through referencing the controller objects directly._<p>If you want to allow your controllers to be lazily initialized,_make them "lazy-init" and set this flag to true. Just making them_"lazy-init" will not work, as they are initialized through the_references from the handler mapping in this case.;public void setLazyInitHandlers(boolean lazyInitHandlers) {_		this.lazyInitHandlers = lazyInitHandlers__	};set,whether,to,lazily,initialize,handlers,only,applicable,to,singleton,handlers,as,prototypes,are,always,lazily,initialized,default,is,false,as,eager,initialization,allows,for,more,efficiency,through,referencing,the,controller,objects,directly,p,if,you,want,to,allow,your,controllers,to,be,lazily,initialized,make,them,lazy,init,and,set,this,flag,to,true,just,making,them,lazy,init,will,not,work,as,they,are,initialized,through,the,references,from,the,handler,mapping,in,this,case;public,void,set,lazy,init,handlers,boolean,lazy,init,handlers,this,lazy,init,handlers,lazy,init,handlers
AbstractUrlHandlerMapping -> public void setLazyInitHandlers(boolean lazyInitHandlers);1520529117;Set whether to lazily initialize handlers. Only applicable to_singleton handlers, as prototypes are always lazily initialized._Default is "false", as eager initialization allows for more efficiency_through referencing the controller objects directly._<p>If you want to allow your controllers to be lazily initialized,_make them "lazy-init" and set this flag to true. Just making them_"lazy-init" will not work, as they are initialized through the_references from the handler mapping in this case.;public void setLazyInitHandlers(boolean lazyInitHandlers) {_		this.lazyInitHandlers = lazyInitHandlers__	};set,whether,to,lazily,initialize,handlers,only,applicable,to,singleton,handlers,as,prototypes,are,always,lazily,initialized,default,is,false,as,eager,initialization,allows,for,more,efficiency,through,referencing,the,controller,objects,directly,p,if,you,want,to,allow,your,controllers,to,be,lazily,initialized,make,them,lazy,init,and,set,this,flag,to,true,just,making,them,lazy,init,will,not,work,as,they,are,initialized,through,the,references,from,the,handler,mapping,in,this,case;public,void,set,lazy,init,handlers,boolean,lazy,init,handlers,this,lazy,init,handlers,lazy,init,handlers
AbstractUrlHandlerMapping -> public void setLazyInitHandlers(boolean lazyInitHandlers);1529721864;Set whether to lazily initialize handlers. Only applicable to_singleton handlers, as prototypes are always lazily initialized._Default is "false", as eager initialization allows for more efficiency_through referencing the controller objects directly._<p>If you want to allow your controllers to be lazily initialized,_make them "lazy-init" and set this flag to true. Just making them_"lazy-init" will not work, as they are initialized through the_references from the handler mapping in this case.;public void setLazyInitHandlers(boolean lazyInitHandlers) {_		this.lazyInitHandlers = lazyInitHandlers__	};set,whether,to,lazily,initialize,handlers,only,applicable,to,singleton,handlers,as,prototypes,are,always,lazily,initialized,default,is,false,as,eager,initialization,allows,for,more,efficiency,through,referencing,the,controller,objects,directly,p,if,you,want,to,allow,your,controllers,to,be,lazily,initialized,make,them,lazy,init,and,set,this,flag,to,true,just,making,them,lazy,init,will,not,work,as,they,are,initialized,through,the,references,from,the,handler,mapping,in,this,case;public,void,set,lazy,init,handlers,boolean,lazy,init,handlers,this,lazy,init,handlers,lazy,init,handlers
AbstractUrlHandlerMapping -> public void setLazyInitHandlers(boolean lazyInitHandlers);1530174524;Set whether to lazily initialize handlers. Only applicable to_singleton handlers, as prototypes are always lazily initialized._Default is "false", as eager initialization allows for more efficiency_through referencing the controller objects directly._<p>If you want to allow your controllers to be lazily initialized,_make them "lazy-init" and set this flag to true. Just making them_"lazy-init" will not work, as they are initialized through the_references from the handler mapping in this case.;public void setLazyInitHandlers(boolean lazyInitHandlers) {_		this.lazyInitHandlers = lazyInitHandlers__	};set,whether,to,lazily,initialize,handlers,only,applicable,to,singleton,handlers,as,prototypes,are,always,lazily,initialized,default,is,false,as,eager,initialization,allows,for,more,efficiency,through,referencing,the,controller,objects,directly,p,if,you,want,to,allow,your,controllers,to,be,lazily,initialized,make,them,lazy,init,and,set,this,flag,to,true,just,making,them,lazy,init,will,not,work,as,they,are,initialized,through,the,references,from,the,handler,mapping,in,this,case;public,void,set,lazy,init,handlers,boolean,lazy,init,handlers,this,lazy,init,handlers,lazy,init,handlers
AbstractUrlHandlerMapping -> public void setLazyInitHandlers(boolean lazyInitHandlers);1530793633;Set whether to lazily initialize handlers. Only applicable to_singleton handlers, as prototypes are always lazily initialized._Default is "false", as eager initialization allows for more efficiency_through referencing the controller objects directly._<p>If you want to allow your controllers to be lazily initialized,_make them "lazy-init" and set this flag to true. Just making them_"lazy-init" will not work, as they are initialized through the_references from the handler mapping in this case.;public void setLazyInitHandlers(boolean lazyInitHandlers) {_		this.lazyInitHandlers = lazyInitHandlers__	};set,whether,to,lazily,initialize,handlers,only,applicable,to,singleton,handlers,as,prototypes,are,always,lazily,initialized,default,is,false,as,eager,initialization,allows,for,more,efficiency,through,referencing,the,controller,objects,directly,p,if,you,want,to,allow,your,controllers,to,be,lazily,initialized,make,them,lazy,init,and,set,this,flag,to,true,just,making,them,lazy,init,will,not,work,as,they,are,initialized,through,the,references,from,the,handler,mapping,in,this,case;public,void,set,lazy,init,handlers,boolean,lazy,init,handlers,this,lazy,init,handlers,lazy,init,handlers
AbstractUrlHandlerMapping -> @SuppressWarnings("UnusedParameters") 	protected void validateHandler(Object handler, ServerWebExchange exchange);1499679438;Validate the given handler against the current request._<p>The default implementation is empty. Can be overridden in subclasses,_for example to enforce specific preconditions expressed in URL mappings._@param handler the handler object to validate_@param exchange current exchange;@SuppressWarnings("UnusedParameters")_	protected void validateHandler(Object handler, ServerWebExchange exchange) {_	};validate,the,given,handler,against,the,current,request,p,the,default,implementation,is,empty,can,be,overridden,in,subclasses,for,example,to,enforce,specific,preconditions,expressed,in,url,mappings,param,handler,the,handler,object,to,validate,param,exchange,current,exchange;suppress,warnings,unused,parameters,protected,void,validate,handler,object,handler,server,web,exchange,exchange
AbstractUrlHandlerMapping -> @SuppressWarnings("UnusedParameters") 	protected void validateHandler(Object handler, ServerWebExchange exchange);1501237594;Validate the given handler against the current request._<p>The default implementation is empty. Can be overridden in subclasses,_for example to enforce specific preconditions expressed in URL mappings._@param handler the handler object to validate_@param exchange current exchange;@SuppressWarnings("UnusedParameters")_	protected void validateHandler(Object handler, ServerWebExchange exchange) {_	};validate,the,given,handler,against,the,current,request,p,the,default,implementation,is,empty,can,be,overridden,in,subclasses,for,example,to,enforce,specific,preconditions,expressed,in,url,mappings,param,handler,the,handler,object,to,validate,param,exchange,current,exchange;suppress,warnings,unused,parameters,protected,void,validate,handler,object,handler,server,web,exchange,exchange
AbstractUrlHandlerMapping -> @SuppressWarnings("UnusedParameters") 	protected void validateHandler(Object handler, ServerWebExchange exchange);1501690296;Validate the given handler against the current request._<p>The default implementation is empty. Can be overridden in subclasses,_for example to enforce specific preconditions expressed in URL mappings._@param handler the handler object to validate_@param exchange current exchange;@SuppressWarnings("UnusedParameters")_	protected void validateHandler(Object handler, ServerWebExchange exchange) {_	};validate,the,given,handler,against,the,current,request,p,the,default,implementation,is,empty,can,be,overridden,in,subclasses,for,example,to,enforce,specific,preconditions,expressed,in,url,mappings,param,handler,the,handler,object,to,validate,param,exchange,current,exchange;suppress,warnings,unused,parameters,protected,void,validate,handler,object,handler,server,web,exchange,exchange
AbstractUrlHandlerMapping -> @SuppressWarnings("UnusedParameters") 	protected void validateHandler(Object handler, ServerWebExchange exchange);1520075565;Validate the given handler against the current request._<p>The default implementation is empty. Can be overridden in subclasses,_for example to enforce specific preconditions expressed in URL mappings._@param handler the handler object to validate_@param exchange current exchange;@SuppressWarnings("UnusedParameters")_	protected void validateHandler(Object handler, ServerWebExchange exchange) {_	};validate,the,given,handler,against,the,current,request,p,the,default,implementation,is,empty,can,be,overridden,in,subclasses,for,example,to,enforce,specific,preconditions,expressed,in,url,mappings,param,handler,the,handler,object,to,validate,param,exchange,current,exchange;suppress,warnings,unused,parameters,protected,void,validate,handler,object,handler,server,web,exchange,exchange
AbstractUrlHandlerMapping -> @SuppressWarnings("UnusedParameters") 	protected void validateHandler(Object handler, ServerWebExchange exchange);1520529117;Validate the given handler against the current request._<p>The default implementation is empty. Can be overridden in subclasses,_for example to enforce specific preconditions expressed in URL mappings._@param handler the handler object to validate_@param exchange current exchange;@SuppressWarnings("UnusedParameters")_	protected void validateHandler(Object handler, ServerWebExchange exchange) {_	};validate,the,given,handler,against,the,current,request,p,the,default,implementation,is,empty,can,be,overridden,in,subclasses,for,example,to,enforce,specific,preconditions,expressed,in,url,mappings,param,handler,the,handler,object,to,validate,param,exchange,current,exchange;suppress,warnings,unused,parameters,protected,void,validate,handler,object,handler,server,web,exchange,exchange
AbstractUrlHandlerMapping -> @SuppressWarnings("UnusedParameters") 	protected void validateHandler(Object handler, ServerWebExchange exchange);1529721864;Validate the given handler against the current request._<p>The default implementation is empty. Can be overridden in subclasses,_for example to enforce specific preconditions expressed in URL mappings._@param handler the handler object to validate_@param exchange current exchange;@SuppressWarnings("UnusedParameters")_	protected void validateHandler(Object handler, ServerWebExchange exchange) {_	};validate,the,given,handler,against,the,current,request,p,the,default,implementation,is,empty,can,be,overridden,in,subclasses,for,example,to,enforce,specific,preconditions,expressed,in,url,mappings,param,handler,the,handler,object,to,validate,param,exchange,current,exchange;suppress,warnings,unused,parameters,protected,void,validate,handler,object,handler,server,web,exchange,exchange
AbstractUrlHandlerMapping -> @SuppressWarnings("UnusedParameters") 	protected void validateHandler(Object handler, ServerWebExchange exchange);1530174524;Validate the given handler against the current request._<p>The default implementation is empty. Can be overridden in subclasses,_for example to enforce specific preconditions expressed in URL mappings._@param handler the handler object to validate_@param exchange current exchange;@SuppressWarnings("UnusedParameters")_	protected void validateHandler(Object handler, ServerWebExchange exchange) {_	};validate,the,given,handler,against,the,current,request,p,the,default,implementation,is,empty,can,be,overridden,in,subclasses,for,example,to,enforce,specific,preconditions,expressed,in,url,mappings,param,handler,the,handler,object,to,validate,param,exchange,current,exchange;suppress,warnings,unused,parameters,protected,void,validate,handler,object,handler,server,web,exchange,exchange
AbstractUrlHandlerMapping -> @SuppressWarnings("UnusedParameters") 	protected void validateHandler(Object handler, ServerWebExchange exchange);1530793633;Validate the given handler against the current request._<p>The default implementation is empty. Can be overridden in subclasses,_for example to enforce specific preconditions expressed in URL mappings._@param handler the handler object to validate_@param exchange current exchange;@SuppressWarnings("UnusedParameters")_	protected void validateHandler(Object handler, ServerWebExchange exchange) {_	};validate,the,given,handler,against,the,current,request,p,the,default,implementation,is,empty,can,be,overridden,in,subclasses,for,example,to,enforce,specific,preconditions,expressed,in,url,mappings,param,handler,the,handler,object,to,validate,param,exchange,current,exchange;suppress,warnings,unused,parameters,protected,void,validate,handler,object,handler,server,web,exchange,exchange
AbstractUrlHandlerMapping -> public final Map<PathPattern, Object> getHandlerMap();1486635693;Return the registered handlers as an unmodifiable Map, with the registered path_as key and the handler object (or handler bean name in case of a lazy-init handler)_as value.;public final Map<PathPattern, Object> getHandlerMap() {_		return Collections.unmodifiableMap(this.handlerMap)__	};return,the,registered,handlers,as,an,unmodifiable,map,with,the,registered,path,as,key,and,the,handler,object,or,handler,bean,name,in,case,of,a,lazy,init,handler,as,value;public,final,map,path,pattern,object,get,handler,map,return,collections,unmodifiable,map,this,handler,map
AbstractUrlHandlerMapping -> public final Map<PathPattern, Object> getHandlerMap();1497286385;Return the registered handlers as an unmodifiable Map, with the registered path_pattern as key and the handler object (or handler bean name in case of a lazy-init handler)_as value.;public final Map<PathPattern, Object> getHandlerMap() {_		return this.patternRegistry.getPatternsMap()__	};return,the,registered,handlers,as,an,unmodifiable,map,with,the,registered,path,pattern,as,key,and,the,handler,object,or,handler,bean,name,in,case,of,a,lazy,init,handler,as,value;public,final,map,path,pattern,object,get,handler,map,return,this,pattern,registry,get,patterns,map
AbstractUrlHandlerMapping -> public final Map<PathPattern, Object> getHandlerMap();1498756719;Return the registered handlers as an unmodifiable Map, with the registered path_pattern as key and the handler object (or handler bean name in case of a lazy-init handler)_as value.;public final Map<PathPattern, Object> getHandlerMap() {_		return this.patternRegistry.getPatternsMap()__	};return,the,registered,handlers,as,an,unmodifiable,map,with,the,registered,path,pattern,as,key,and,the,handler,object,or,handler,bean,name,in,case,of,a,lazy,init,handler,as,value;public,final,map,path,pattern,object,get,handler,map,return,this,pattern,registry,get,patterns,map
AbstractUrlHandlerMapping -> public final Map<PathPattern, Object> getHandlerMap();1498780456;Return the registered handlers as an unmodifiable Map, with the registered path_pattern as key and the handler object (or handler bean name in case of a lazy-init handler)_as value.;public final Map<PathPattern, Object> getHandlerMap() {_		return (this.patternRegistry != null ? this.patternRegistry.getPatternsMap() : Collections.emptyMap())__	};return,the,registered,handlers,as,an,unmodifiable,map,with,the,registered,path,pattern,as,key,and,the,handler,object,or,handler,bean,name,in,case,of,a,lazy,init,handler,as,value;public,final,map,path,pattern,object,get,handler,map,return,this,pattern,registry,null,this,pattern,registry,get,patterns,map,collections,empty,map
AbstractUrlHandlerMapping -> public final Map<PathPattern, Object> getHandlerMap();1498944474;Return the registered handlers as an unmodifiable Map, with the registered path_pattern as key and the handler object (or handler bean name in case of a lazy-init handler)_as value.;public final Map<PathPattern, Object> getHandlerMap() {_		return (this.patternRegistry != null ? this.patternRegistry.getPatternsMap() : Collections.emptyMap())__	};return,the,registered,handlers,as,an,unmodifiable,map,with,the,registered,path,pattern,as,key,and,the,handler,object,or,handler,bean,name,in,case,of,a,lazy,init,handler,as,value;public,final,map,path,pattern,object,get,handler,map,return,this,pattern,registry,null,this,pattern,registry,get,patterns,map,collections,empty,map
AbstractUrlHandlerMapping -> public final Map<PathPattern, Object> getHandlerMap();1498953917;Return the registered handlers as an unmodifiable Map, with the registered path_pattern as key and the handler object (or handler bean name in case of a lazy-init handler)_as value.;public final Map<PathPattern, Object> getHandlerMap() {_		return (this.patternRegistry != null ? this.patternRegistry.getPatternsMap() : Collections.emptyMap())__	};return,the,registered,handlers,as,an,unmodifiable,map,with,the,registered,path,pattern,as,key,and,the,handler,object,or,handler,bean,name,in,case,of,a,lazy,init,handler,as,value;public,final,map,path,pattern,object,get,handler,map,return,this,pattern,registry,null,this,pattern,registry,get,patterns,map,collections,empty,map
AbstractUrlHandlerMapping -> public final Map<PathPattern, Object> getHandlerMap();1499679438;Return a read-only view of registered path patterns and handlers which may_may be an actual handler instance or the bean name of lazily initialized_handler.;public final Map<PathPattern, Object> getHandlerMap() {_		return Collections.unmodifiableMap(this.handlerMap)__	};return,a,read,only,view,of,registered,path,patterns,and,handlers,which,may,may,be,an,actual,handler,instance,or,the,bean,name,of,lazily,initialized,handler;public,final,map,path,pattern,object,get,handler,map,return,collections,unmodifiable,map,this,handler,map
AbstractUrlHandlerMapping -> public final Map<PathPattern, Object> getHandlerMap();1501237594;Return a read-only view of registered path patterns and handlers which may_may be an actual handler instance or the bean name of lazily initialized_handler.;public final Map<PathPattern, Object> getHandlerMap() {_		return Collections.unmodifiableMap(this.handlerMap)__	};return,a,read,only,view,of,registered,path,patterns,and,handlers,which,may,may,be,an,actual,handler,instance,or,the,bean,name,of,lazily,initialized,handler;public,final,map,path,pattern,object,get,handler,map,return,collections,unmodifiable,map,this,handler,map
AbstractUrlHandlerMapping -> public final Map<PathPattern, Object> getHandlerMap();1501690296;Return a read-only view of registered path patterns and handlers which may_may be an actual handler instance or the bean name of lazily initialized_handler.;public final Map<PathPattern, Object> getHandlerMap() {_		return Collections.unmodifiableMap(this.handlerMap)__	};return,a,read,only,view,of,registered,path,patterns,and,handlers,which,may,may,be,an,actual,handler,instance,or,the,bean,name,of,lazily,initialized,handler;public,final,map,path,pattern,object,get,handler,map,return,collections,unmodifiable,map,this,handler,map
AbstractUrlHandlerMapping -> public final Map<PathPattern, Object> getHandlerMap();1520075565;Return a read-only view of registered path patterns and handlers which may_may be an actual handler instance or the bean name of lazily initialized_handler.;public final Map<PathPattern, Object> getHandlerMap() {_		return Collections.unmodifiableMap(this.handlerMap)__	};return,a,read,only,view,of,registered,path,patterns,and,handlers,which,may,may,be,an,actual,handler,instance,or,the,bean,name,of,lazily,initialized,handler;public,final,map,path,pattern,object,get,handler,map,return,collections,unmodifiable,map,this,handler,map
AbstractUrlHandlerMapping -> public final Map<PathPattern, Object> getHandlerMap();1520529117;Return a read-only view of registered path patterns and handlers which may_may be an actual handler instance or the bean name of lazily initialized_handler.;public final Map<PathPattern, Object> getHandlerMap() {_		return Collections.unmodifiableMap(this.handlerMap)__	};return,a,read,only,view,of,registered,path,patterns,and,handlers,which,may,may,be,an,actual,handler,instance,or,the,bean,name,of,lazily,initialized,handler;public,final,map,path,pattern,object,get,handler,map,return,collections,unmodifiable,map,this,handler,map
AbstractUrlHandlerMapping -> public final Map<PathPattern, Object> getHandlerMap();1529721864;Return a read-only view of registered path patterns and handlers which may_may be an actual handler instance or the bean name of lazily initialized_handler.;public final Map<PathPattern, Object> getHandlerMap() {_		return Collections.unmodifiableMap(this.handlerMap)__	};return,a,read,only,view,of,registered,path,patterns,and,handlers,which,may,may,be,an,actual,handler,instance,or,the,bean,name,of,lazily,initialized,handler;public,final,map,path,pattern,object,get,handler,map,return,collections,unmodifiable,map,this,handler,map
AbstractUrlHandlerMapping -> public final Map<PathPattern, Object> getHandlerMap();1530174524;Return a read-only view of registered path patterns and handlers which may_may be an actual handler instance or the bean name of lazily initialized_handler.;public final Map<PathPattern, Object> getHandlerMap() {_		return Collections.unmodifiableMap(this.handlerMap)__	};return,a,read,only,view,of,registered,path,patterns,and,handlers,which,may,may,be,an,actual,handler,instance,or,the,bean,name,of,lazily,initialized,handler;public,final,map,path,pattern,object,get,handler,map,return,collections,unmodifiable,map,this,handler,map
AbstractUrlHandlerMapping -> public final Map<PathPattern, Object> getHandlerMap();1530793633;Return a read-only view of registered path patterns and handlers which may_may be an actual handler instance or the bean name of lazily initialized_handler.;public final Map<PathPattern, Object> getHandlerMap() {_		return Collections.unmodifiableMap(this.handlerMap)__	};return,a,read,only,view,of,registered,path,patterns,and,handlers,which,may,may,be,an,actual,handler,instance,or,the,bean,name,of,lazily,initialized,handler;public,final,map,path,pattern,object,get,handler,map,return,collections,unmodifiable,map,this,handler,map
AbstractUrlHandlerMapping -> public boolean useTrailingSlashMatch();1485986572;Whether to match to URLs irrespective of the presence of a trailing slash.;public boolean useTrailingSlashMatch() {_		return this.useTrailingSlashMatch__	};whether,to,match,to,urls,irrespective,of,the,presence,of,a,trailing,slash;public,boolean,use,trailing,slash,match,return,this,use,trailing,slash,match
AbstractUrlHandlerMapping -> public boolean useTrailingSlashMatch();1486635693;Whether to match to URLs irrespective of the presence of a trailing slash.;public boolean useTrailingSlashMatch() {_		return this.patternRegistry.useTrailingSlashMatch()__	};whether,to,match,to,urls,irrespective,of,the,presence,of,a,trailing,slash;public,boolean,use,trailing,slash,match,return,this,pattern,registry,use,trailing,slash,match
AbstractUrlHandlerMapping -> public boolean useTrailingSlashMatch();1486747801;Whether to match to URLs irrespective of the presence of a trailing slash.;public boolean useTrailingSlashMatch() {_		return this.useTrailingSlashMatch__	};whether,to,match,to,urls,irrespective,of,the,presence,of,a,trailing,slash;public,boolean,use,trailing,slash,match,return,this,use,trailing,slash,match
AbstractUrlHandlerMapping -> public boolean useTrailingSlashMatch();1486747828;Whether to match to URLs irrespective of the presence of a trailing slash.;public boolean useTrailingSlashMatch() {_		return this.useTrailingSlashMatch__	};whether,to,match,to,urls,irrespective,of,the,presence,of,a,trailing,slash;public,boolean,use,trailing,slash,match,return,this,use,trailing,slash,match
AbstractUrlHandlerMapping -> public boolean useTrailingSlashMatch();1495035625;Whether to match to URLs irrespective of the presence of a trailing slash.;public boolean useTrailingSlashMatch() {_		return this.useTrailingSlashMatch__	};whether,to,match,to,urls,irrespective,of,the,presence,of,a,trailing,slash;public,boolean,use,trailing,slash,match,return,this,use,trailing,slash,match
AbstractUrlHandlerMapping -> public boolean useTrailingSlashMatch();1495868221;Whether to match to URLs irrespective of the presence of a trailing slash.;public boolean useTrailingSlashMatch() {_		return this.useTrailingSlashMatch__	};whether,to,match,to,urls,irrespective,of,the,presence,of,a,trailing,slash;public,boolean,use,trailing,slash,match,return,this,use,trailing,slash,match
AbstractUrlHandlerMapping -> public boolean useTrailingSlashMatch();1496334664;Whether to match to URLs irrespective of the presence of a trailing slash.;public boolean useTrailingSlashMatch() {_		return this.useTrailingSlashMatch__	};whether,to,match,to,urls,irrespective,of,the,presence,of,a,trailing,slash;public,boolean,use,trailing,slash,match,return,this,use,trailing,slash,match
AbstractUrlHandlerMapping -> public boolean useTrailingSlashMatch();1496430942;Whether to match to URLs irrespective of the presence of a trailing slash.;public boolean useTrailingSlashMatch() {_		return this.useTrailingSlashMatch__	};whether,to,match,to,urls,irrespective,of,the,presence,of,a,trailing,slash;public,boolean,use,trailing,slash,match,return,this,use,trailing,slash,match
AbstractUrlHandlerMapping -> public boolean useTrailingSlashMatch();1496837955;Whether to match to URLs irrespective of the presence of a trailing slash.;public boolean useTrailingSlashMatch() {_		return this.useTrailingSlashMatch__	};whether,to,match,to,urls,irrespective,of,the,presence,of,a,trailing,slash;public,boolean,use,trailing,slash,match,return,this,use,trailing,slash,match
AbstractUrlHandlerMapping -> public boolean useTrailingSlashMatch();1497039338;Whether to match to URLs irrespective of the presence of a trailing slash.;public boolean useTrailingSlashMatch() {_		return this.useTrailingSlashMatch__	};whether,to,match,to,urls,irrespective,of,the,presence,of,a,trailing,slash;public,boolean,use,trailing,slash,match,return,this,use,trailing,slash,match
AbstractUrlHandlerMapping -> public boolean useTrailingSlashMatch();1497232764;Whether to match to URLs irrespective of the presence of a trailing slash.;public boolean useTrailingSlashMatch() {_		return this.useTrailingSlashMatch__	};whether,to,match,to,urls,irrespective,of,the,presence,of,a,trailing,slash;public,boolean,use,trailing,slash,match,return,this,use,trailing,slash,match
AbstractUrlHandlerMapping -> @Nullable 	protected Object lookupHandler(String lookupPath, ServerWebExchange exchange) throws Exception;1497039338;Look up a handler instance for the given URL lookup path.__<p>Supports direct matches, e.g. a registered "/test" matches "/test",_and various path pattern matches, e.g. a registered "/t*" matches_both "/test" and "/team". For details, see the PathPattern class.__@param lookupPath URL the handler is mapped to_@param exchange the current exchange_@return the associated handler instance, or {@code null} if not found_@see org.springframework.web.util.pattern.ParsingPathMatcher;@Nullable_	protected Object lookupHandler(String lookupPath, ServerWebExchange exchange) throws Exception {_		_		Object handler = this.handlerMap.get(lookupPath)__		if (handler != null) {_			return handleMatch(handler, lookupPath, lookupPath, exchange)__		}__		_		List<String> matches = new ArrayList<>()__		for (String pattern : this.handlerMap.keySet()) {_			if (getPathMatcher().match(pattern, lookupPath)) {_				matches.add(pattern)__			}_			else if (useTrailingSlashMatch()) {_				if (!pattern.endsWith("/") && getPathMatcher().match(pattern + "/", lookupPath)) {_					matches.add(pattern +"/")__				}_			}_		}__		String bestMatch = null__		Comparator<String> comparator = getPathMatcher().getPatternComparator(lookupPath)__		if (!matches.isEmpty()) {_			Collections.sort(matches, comparator)__			if (logger.isDebugEnabled()) {_				logger.debug("Matching patterns for request [" + lookupPath + "] are " + matches)__			}_			bestMatch = matches.get(0)__		}_		if (bestMatch != null) {_			handler = this.handlerMap.get(bestMatch)__			if (handler == null) {_				if (bestMatch.endsWith("/")) {_					handler = this.handlerMap.get(bestMatch.substring(0, bestMatch.length() - 1))__				}_				if (handler == null) {_					throw new IllegalStateException(_							"Could not find handler for best pattern match [" + bestMatch + "]")__				}_			}_			String pathWithinMapping = getPathMatcher().extractPathWithinPattern(bestMatch, lookupPath)__			return handleMatch(handler, bestMatch, pathWithinMapping, exchange)__		}__		_		return null__	};look,up,a,handler,instance,for,the,given,url,lookup,path,p,supports,direct,matches,e,g,a,registered,test,matches,test,and,various,path,pattern,matches,e,g,a,registered,t,matches,both,test,and,team,for,details,see,the,path,pattern,class,param,lookup,path,url,the,handler,is,mapped,to,param,exchange,the,current,exchange,return,the,associated,handler,instance,or,code,null,if,not,found,see,org,springframework,web,util,pattern,parsing,path,matcher;nullable,protected,object,lookup,handler,string,lookup,path,server,web,exchange,exchange,throws,exception,object,handler,this,handler,map,get,lookup,path,if,handler,null,return,handle,match,handler,lookup,path,lookup,path,exchange,list,string,matches,new,array,list,for,string,pattern,this,handler,map,key,set,if,get,path,matcher,match,pattern,lookup,path,matches,add,pattern,else,if,use,trailing,slash,match,if,pattern,ends,with,get,path,matcher,match,pattern,lookup,path,matches,add,pattern,string,best,match,null,comparator,string,comparator,get,path,matcher,get,pattern,comparator,lookup,path,if,matches,is,empty,collections,sort,matches,comparator,if,logger,is,debug,enabled,logger,debug,matching,patterns,for,request,lookup,path,are,matches,best,match,matches,get,0,if,best,match,null,handler,this,handler,map,get,best,match,if,handler,null,if,best,match,ends,with,handler,this,handler,map,get,best,match,substring,0,best,match,length,1,if,handler,null,throw,new,illegal,state,exception,could,not,find,handler,for,best,pattern,match,best,match,string,path,within,mapping,get,path,matcher,extract,path,within,pattern,best,match,lookup,path,return,handle,match,handler,best,match,path,within,mapping,exchange,return,null
AbstractUrlHandlerMapping -> @Nullable 	protected Object lookupHandler(String lookupPath, ServerWebExchange exchange) throws Exception;1497232764;Look up a handler instance for the given URL lookup path.__<p>Supports direct matches, e.g. a registered "/test" matches "/test",_and various path pattern matches, e.g. a registered "/t*" matches_both "/test" and "/team". For details, see the PathPattern class.__@param lookupPath URL the handler is mapped to_@param exchange the current exchange_@return the associated handler instance, or {@code null} if not found_@see org.springframework.web.util.pattern.ParsingPathMatcher;@Nullable_	protected Object lookupHandler(String lookupPath, ServerWebExchange exchange) throws Exception {_		_		Object handler = this.handlerMap.get(lookupPath)__		if (handler != null) {_			return handleMatch(handler, lookupPath, lookupPath, exchange)__		}__		_		List<String> matches = new ArrayList<>()__		for (String pattern : this.handlerMap.keySet()) {_			if (getPathMatcher().match(pattern, lookupPath)) {_				matches.add(pattern)__			}_			else if (useTrailingSlashMatch()) {_				if (!pattern.endsWith("/") && getPathMatcher().match(pattern + "/", lookupPath)) {_					matches.add(pattern +"/")__				}_			}_		}__		String bestMatch = null__		Comparator<String> comparator = getPathMatcher().getPatternComparator(lookupPath)__		if (!matches.isEmpty()) {_			Collections.sort(matches, comparator)__			if (logger.isDebugEnabled()) {_				logger.debug("Matching patterns for request [" + lookupPath + "] are " + matches)__			}_			bestMatch = matches.get(0)__		}_		if (bestMatch != null) {_			handler = this.handlerMap.get(bestMatch)__			if (handler == null) {_				if (bestMatch.endsWith("/")) {_					handler = this.handlerMap.get(bestMatch.substring(0, bestMatch.length() - 1))__				}_				if (handler == null) {_					throw new IllegalStateException(_							"Could not find handler for best pattern match [" + bestMatch + "]")__				}_			}_			String pathWithinMapping = getPathMatcher().extractPathWithinPattern(bestMatch, lookupPath)__			return handleMatch(handler, bestMatch, pathWithinMapping, exchange)__		}__		_		return null__	};look,up,a,handler,instance,for,the,given,url,lookup,path,p,supports,direct,matches,e,g,a,registered,test,matches,test,and,various,path,pattern,matches,e,g,a,registered,t,matches,both,test,and,team,for,details,see,the,path,pattern,class,param,lookup,path,url,the,handler,is,mapped,to,param,exchange,the,current,exchange,return,the,associated,handler,instance,or,code,null,if,not,found,see,org,springframework,web,util,pattern,parsing,path,matcher;nullable,protected,object,lookup,handler,string,lookup,path,server,web,exchange,exchange,throws,exception,object,handler,this,handler,map,get,lookup,path,if,handler,null,return,handle,match,handler,lookup,path,lookup,path,exchange,list,string,matches,new,array,list,for,string,pattern,this,handler,map,key,set,if,get,path,matcher,match,pattern,lookup,path,matches,add,pattern,else,if,use,trailing,slash,match,if,pattern,ends,with,get,path,matcher,match,pattern,lookup,path,matches,add,pattern,string,best,match,null,comparator,string,comparator,get,path,matcher,get,pattern,comparator,lookup,path,if,matches,is,empty,collections,sort,matches,comparator,if,logger,is,debug,enabled,logger,debug,matching,patterns,for,request,lookup,path,are,matches,best,match,matches,get,0,if,best,match,null,handler,this,handler,map,get,best,match,if,handler,null,if,best,match,ends,with,handler,this,handler,map,get,best,match,substring,0,best,match,length,1,if,handler,null,throw,new,illegal,state,exception,could,not,find,handler,for,best,pattern,match,best,match,string,path,within,mapping,get,path,matcher,extract,path,within,pattern,best,match,lookup,path,return,handle,match,handler,best,match,path,within,mapping,exchange,return,null
AbstractUrlHandlerMapping -> @Nullable 	protected Object lookupHandler(String lookupPath, ServerWebExchange exchange) throws Exception;1497286385;Look up a handler instance for the given URL lookup path.__<p>Supports direct matches, e.g. a registered "/test" matches "/test",_and various path pattern matches, e.g. a registered "/t*" matches_both "/test" and "/team". For details, see the PathPattern class.__@param lookupPath URL the handler is mapped to_@param exchange the current exchange_@return the associated handler instance, or {@code null} if not found_@see org.springframework.web.util.pattern.PathPattern;@Nullable_	protected Object lookupHandler(String lookupPath, ServerWebExchange exchange) throws Exception {_		Optional<PathMatchResult<Object>> matches = this.patternRegistry.findFirstMatch(lookupPath)__		if (matches.isPresent()) {_			if (logger.isDebugEnabled()) {_				logger.debug("Matching patterns for request [" + lookupPath + "] are " + matches)__			}_			PathMatchResult<Object> bestMatch = matches.get()__			String pathWithinMapping = bestMatch.getPattern().extractPathWithinPattern(lookupPath)__			Object handler = bestMatch.getHandler()__			if (handler == null) {_				throw new IllegalStateException(_						"Could not find handler for best pattern match [" + bestMatch + "]")__			}_			return handleMatch(handler, bestMatch.getPattern(), pathWithinMapping, exchange)__		}__		_		return null__	};look,up,a,handler,instance,for,the,given,url,lookup,path,p,supports,direct,matches,e,g,a,registered,test,matches,test,and,various,path,pattern,matches,e,g,a,registered,t,matches,both,test,and,team,for,details,see,the,path,pattern,class,param,lookup,path,url,the,handler,is,mapped,to,param,exchange,the,current,exchange,return,the,associated,handler,instance,or,code,null,if,not,found,see,org,springframework,web,util,pattern,path,pattern;nullable,protected,object,lookup,handler,string,lookup,path,server,web,exchange,exchange,throws,exception,optional,path,match,result,object,matches,this,pattern,registry,find,first,match,lookup,path,if,matches,is,present,if,logger,is,debug,enabled,logger,debug,matching,patterns,for,request,lookup,path,are,matches,path,match,result,object,best,match,matches,get,string,path,within,mapping,best,match,get,pattern,extract,path,within,pattern,lookup,path,object,handler,best,match,get,handler,if,handler,null,throw,new,illegal,state,exception,could,not,find,handler,for,best,pattern,match,best,match,return,handle,match,handler,best,match,get,pattern,path,within,mapping,exchange,return,null
AbstractUrlHandlerMapping -> @Nullable 	protected Object lookupHandler(String lookupPath, ServerWebExchange exchange) throws Exception;1498756719;Look up a handler instance for the given URL lookup path.__<p>Supports direct matches, e.g. a registered "/test" matches "/test",_and various path pattern matches, e.g. a registered "/t*" matches_both "/test" and "/team". For details, see the PathPattern class.__@param lookupPath URL the handler is mapped to_@param exchange the current exchange_@return the associated handler instance, or {@code null} if not found_@see org.springframework.web.util.pattern.PathPattern;@Nullable_	protected Object lookupHandler(String lookupPath, ServerWebExchange exchange) throws Exception {_		Optional<PathMatchResult<Object>> matches = this.patternRegistry.findFirstMatch(lookupPath)__		if (matches.isPresent()) {_			if (logger.isDebugEnabled()) {_				logger.debug("Matching patterns for request [" + lookupPath + "] are " + matches)__			}_			PathMatchResult<Object> bestMatch = matches.get()__			String pathWithinMapping = bestMatch.getPattern().extractPathWithinPattern(lookupPath)__			Object handler = bestMatch.getHandler()__			if (handler == null) {_				throw new IllegalStateException(_						"Could not find handler for best pattern match [" + bestMatch + "]")__			}_			return handleMatch(handler, bestMatch.getPattern(), pathWithinMapping, exchange)__		}__		_		return null__	};look,up,a,handler,instance,for,the,given,url,lookup,path,p,supports,direct,matches,e,g,a,registered,test,matches,test,and,various,path,pattern,matches,e,g,a,registered,t,matches,both,test,and,team,for,details,see,the,path,pattern,class,param,lookup,path,url,the,handler,is,mapped,to,param,exchange,the,current,exchange,return,the,associated,handler,instance,or,code,null,if,not,found,see,org,springframework,web,util,pattern,path,pattern;nullable,protected,object,lookup,handler,string,lookup,path,server,web,exchange,exchange,throws,exception,optional,path,match,result,object,matches,this,pattern,registry,find,first,match,lookup,path,if,matches,is,present,if,logger,is,debug,enabled,logger,debug,matching,patterns,for,request,lookup,path,are,matches,path,match,result,object,best,match,matches,get,string,path,within,mapping,best,match,get,pattern,extract,path,within,pattern,lookup,path,object,handler,best,match,get,handler,if,handler,null,throw,new,illegal,state,exception,could,not,find,handler,for,best,pattern,match,best,match,return,handle,match,handler,best,match,get,pattern,path,within,mapping,exchange,return,null
AbstractUrlHandlerMapping -> @Nullable 	protected Object lookupHandler(String lookupPath, ServerWebExchange exchange) throws Exception;1498780456;Look up a handler instance for the given URL lookup path._<p>Supports direct matches, e.g. a registered "/test" matches "/test",_and various path pattern matches, e.g. a registered "/t*" matches_both "/test" and "/team". For details, see the PathPattern class._@param lookupPath URL the handler is mapped to_@param exchange the current exchange_@return the associated handler instance, or {@code null} if not found_@see org.springframework.web.util.pattern.PathPattern;@Nullable_	protected Object lookupHandler(String lookupPath, ServerWebExchange exchange) throws Exception {_		if (this.patternRegistry != null) {_			Optional<PathMatchResult<Object>> matches = this.patternRegistry.findFirstMatch(lookupPath)__			if (matches.isPresent()) {_				if (logger.isDebugEnabled()) {_					logger.debug("Matching patterns for request [" + lookupPath + "] are " + matches)__				}_				PathMatchResult<Object> bestMatch = matches.get()__				String pathWithinMapping = bestMatch.getPattern().extractPathWithinPattern(lookupPath)__				Object handler = bestMatch.getHandler()__				return handleMatch(handler, bestMatch.getPattern(), pathWithinMapping, exchange)__			}_		}__		_		return null__	};look,up,a,handler,instance,for,the,given,url,lookup,path,p,supports,direct,matches,e,g,a,registered,test,matches,test,and,various,path,pattern,matches,e,g,a,registered,t,matches,both,test,and,team,for,details,see,the,path,pattern,class,param,lookup,path,url,the,handler,is,mapped,to,param,exchange,the,current,exchange,return,the,associated,handler,instance,or,code,null,if,not,found,see,org,springframework,web,util,pattern,path,pattern;nullable,protected,object,lookup,handler,string,lookup,path,server,web,exchange,exchange,throws,exception,if,this,pattern,registry,null,optional,path,match,result,object,matches,this,pattern,registry,find,first,match,lookup,path,if,matches,is,present,if,logger,is,debug,enabled,logger,debug,matching,patterns,for,request,lookup,path,are,matches,path,match,result,object,best,match,matches,get,string,path,within,mapping,best,match,get,pattern,extract,path,within,pattern,lookup,path,object,handler,best,match,get,handler,return,handle,match,handler,best,match,get,pattern,path,within,mapping,exchange,return,null
AbstractUrlHandlerMapping -> @Nullable 	protected Object lookupHandler(String lookupPath, ServerWebExchange exchange) throws Exception;1498944474;Look up a handler instance for the given URL lookup path._<p>Supports direct matches, e.g. a registered "/test" matches "/test",_and various path pattern matches, e.g. a registered "/t*" matches_both "/test" and "/team". For details, see the PathPattern class._@param lookupPath URL the handler is mapped to_@param exchange the current exchange_@return the associated handler instance, or {@code null} if not found_@see org.springframework.web.util.pattern.PathPattern;@Nullable_	protected Object lookupHandler(String lookupPath, ServerWebExchange exchange) throws Exception {_		if (this.patternRegistry != null) {_			PathMatchResult<Object> bestMatch = this.patternRegistry.findFirstMatch(lookupPath)__			if (bestMatch != null) {_				if (logger.isDebugEnabled()) {_					logger.debug("Matching patterns for request [" + lookupPath + "] are " + bestMatch)__				}_				String pathWithinMapping = bestMatch.getPattern().extractPathWithinPattern(lookupPath)__				Object handler = bestMatch.getHandler()__				return handleMatch(handler, bestMatch.getPattern(), pathWithinMapping, exchange)__			}_		}__		_		return null__	};look,up,a,handler,instance,for,the,given,url,lookup,path,p,supports,direct,matches,e,g,a,registered,test,matches,test,and,various,path,pattern,matches,e,g,a,registered,t,matches,both,test,and,team,for,details,see,the,path,pattern,class,param,lookup,path,url,the,handler,is,mapped,to,param,exchange,the,current,exchange,return,the,associated,handler,instance,or,code,null,if,not,found,see,org,springframework,web,util,pattern,path,pattern;nullable,protected,object,lookup,handler,string,lookup,path,server,web,exchange,exchange,throws,exception,if,this,pattern,registry,null,path,match,result,object,best,match,this,pattern,registry,find,first,match,lookup,path,if,best,match,null,if,logger,is,debug,enabled,logger,debug,matching,patterns,for,request,lookup,path,are,best,match,string,path,within,mapping,best,match,get,pattern,extract,path,within,pattern,lookup,path,object,handler,best,match,get,handler,return,handle,match,handler,best,match,get,pattern,path,within,mapping,exchange,return,null
AbstractUrlHandlerMapping -> protected void registerHandler(String urlPath, Object handler) 			throws BeansException, IllegalStateException;1499679438;Register the specified handler for the given URL path._@param urlPath the URL the bean should be mapped to_@param handler the handler instance or handler bean name String_(a bean name will automatically be resolved into the corresponding handler bean)_@throws BeansException if the handler couldn't be registered_@throws IllegalStateException if there is a conflicting handler registered;protected void registerHandler(String urlPath, Object handler)_			throws BeansException, IllegalStateException {__		Assert.notNull(urlPath, "URL path must not be null")__		Assert.notNull(handler, "Handler object must not be null")__		Object resolvedHandler = handler___		_		urlPath = prependLeadingSlash(urlPath)__		PathPattern pattern = getPathPatternParser().parse(urlPath)__		if (this.handlerMap.containsKey(pattern)) {_			Object existingHandler = this.handlerMap.get(pattern)__			if (existingHandler != null) {_				if (existingHandler != resolvedHandler) {_					throw new IllegalStateException(_							"Cannot map " + getHandlerDescription(handler) + " to [" + urlPath + "]: " +_							"there is already " + getHandlerDescription(existingHandler) + " mapped.")__				}_			}_		}__		_		if (!this.lazyInitHandlers && handler instanceof String) {_			String handlerName = (String) handler__			if (obtainApplicationContext().isSingleton(handlerName)) {_				resolvedHandler = obtainApplicationContext().getBean(handlerName)__			}_		}__		_		this.handlerMap.put(pattern, resolvedHandler)__		if (logger.isInfoEnabled()) {_			logger.info("Mapped URL path [" + urlPath + "] onto " + getHandlerDescription(handler))__		}_	};register,the,specified,handler,for,the,given,url,path,param,url,path,the,url,the,bean,should,be,mapped,to,param,handler,the,handler,instance,or,handler,bean,name,string,a,bean,name,will,automatically,be,resolved,into,the,corresponding,handler,bean,throws,beans,exception,if,the,handler,couldn,t,be,registered,throws,illegal,state,exception,if,there,is,a,conflicting,handler,registered;protected,void,register,handler,string,url,path,object,handler,throws,beans,exception,illegal,state,exception,assert,not,null,url,path,url,path,must,not,be,null,assert,not,null,handler,handler,object,must,not,be,null,object,resolved,handler,handler,url,path,prepend,leading,slash,url,path,path,pattern,pattern,get,path,pattern,parser,parse,url,path,if,this,handler,map,contains,key,pattern,object,existing,handler,this,handler,map,get,pattern,if,existing,handler,null,if,existing,handler,resolved,handler,throw,new,illegal,state,exception,cannot,map,get,handler,description,handler,to,url,path,there,is,already,get,handler,description,existing,handler,mapped,if,this,lazy,init,handlers,handler,instanceof,string,string,handler,name,string,handler,if,obtain,application,context,is,singleton,handler,name,resolved,handler,obtain,application,context,get,bean,handler,name,this,handler,map,put,pattern,resolved,handler,if,logger,is,info,enabled,logger,info,mapped,url,path,url,path,onto,get,handler,description,handler
AbstractUrlHandlerMapping -> protected void registerHandler(String urlPath, Object handler) 			throws BeansException, IllegalStateException;1501237594;Register the specified handler for the given URL path._@param urlPath the URL the bean should be mapped to_@param handler the handler instance or handler bean name String_(a bean name will automatically be resolved into the corresponding handler bean)_@throws BeansException if the handler couldn't be registered_@throws IllegalStateException if there is a conflicting handler registered;protected void registerHandler(String urlPath, Object handler)_			throws BeansException, IllegalStateException {__		Assert.notNull(urlPath, "URL path must not be null")__		Assert.notNull(handler, "Handler object must not be null")__		Object resolvedHandler = handler___		_		urlPath = prependLeadingSlash(urlPath)__		PathPattern pattern = getPathPatternParser().parse(urlPath)__		if (this.handlerMap.containsKey(pattern)) {_			Object existingHandler = this.handlerMap.get(pattern)__			if (existingHandler != null) {_				if (existingHandler != resolvedHandler) {_					throw new IllegalStateException(_							"Cannot map " + getHandlerDescription(handler) + " to [" + urlPath + "]: " +_							"there is already " + getHandlerDescription(existingHandler) + " mapped.")__				}_			}_		}__		_		if (!this.lazyInitHandlers && handler instanceof String) {_			String handlerName = (String) handler__			if (obtainApplicationContext().isSingleton(handlerName)) {_				resolvedHandler = obtainApplicationContext().getBean(handlerName)__			}_		}__		_		this.handlerMap.put(pattern, resolvedHandler)__		if (logger.isInfoEnabled()) {_			logger.info("Mapped URL path [" + urlPath + "] onto " + getHandlerDescription(handler))__		}_	};register,the,specified,handler,for,the,given,url,path,param,url,path,the,url,the,bean,should,be,mapped,to,param,handler,the,handler,instance,or,handler,bean,name,string,a,bean,name,will,automatically,be,resolved,into,the,corresponding,handler,bean,throws,beans,exception,if,the,handler,couldn,t,be,registered,throws,illegal,state,exception,if,there,is,a,conflicting,handler,registered;protected,void,register,handler,string,url,path,object,handler,throws,beans,exception,illegal,state,exception,assert,not,null,url,path,url,path,must,not,be,null,assert,not,null,handler,handler,object,must,not,be,null,object,resolved,handler,handler,url,path,prepend,leading,slash,url,path,path,pattern,pattern,get,path,pattern,parser,parse,url,path,if,this,handler,map,contains,key,pattern,object,existing,handler,this,handler,map,get,pattern,if,existing,handler,null,if,existing,handler,resolved,handler,throw,new,illegal,state,exception,cannot,map,get,handler,description,handler,to,url,path,there,is,already,get,handler,description,existing,handler,mapped,if,this,lazy,init,handlers,handler,instanceof,string,string,handler,name,string,handler,if,obtain,application,context,is,singleton,handler,name,resolved,handler,obtain,application,context,get,bean,handler,name,this,handler,map,put,pattern,resolved,handler,if,logger,is,info,enabled,logger,info,mapped,url,path,url,path,onto,get,handler,description,handler
AbstractUrlHandlerMapping -> protected void registerHandler(String urlPath, Object handler) 			throws BeansException, IllegalStateException;1501690296;Register the specified handler for the given URL path._@param urlPath the URL the bean should be mapped to_@param handler the handler instance or handler bean name String_(a bean name will automatically be resolved into the corresponding handler bean)_@throws BeansException if the handler couldn't be registered_@throws IllegalStateException if there is a conflicting handler registered;protected void registerHandler(String urlPath, Object handler)_			throws BeansException, IllegalStateException {__		Assert.notNull(urlPath, "URL path must not be null")__		Assert.notNull(handler, "Handler object must not be null")__		Object resolvedHandler = handler___		_		urlPath = prependLeadingSlash(urlPath)__		PathPattern pattern = getPathPatternParser().parse(urlPath)__		if (this.handlerMap.containsKey(pattern)) {_			Object existingHandler = this.handlerMap.get(pattern)__			if (existingHandler != null) {_				if (existingHandler != resolvedHandler) {_					throw new IllegalStateException(_							"Cannot map " + getHandlerDescription(handler) + " to [" + urlPath + "]: " +_							"there is already " + getHandlerDescription(existingHandler) + " mapped.")__				}_			}_		}__		_		if (!this.lazyInitHandlers && handler instanceof String) {_			String handlerName = (String) handler__			if (obtainApplicationContext().isSingleton(handlerName)) {_				resolvedHandler = obtainApplicationContext().getBean(handlerName)__			}_		}__		_		this.handlerMap.put(pattern, resolvedHandler)__		if (logger.isInfoEnabled()) {_			logger.info("Mapped URL path [" + urlPath + "] onto " + getHandlerDescription(handler))__		}_	};register,the,specified,handler,for,the,given,url,path,param,url,path,the,url,the,bean,should,be,mapped,to,param,handler,the,handler,instance,or,handler,bean,name,string,a,bean,name,will,automatically,be,resolved,into,the,corresponding,handler,bean,throws,beans,exception,if,the,handler,couldn,t,be,registered,throws,illegal,state,exception,if,there,is,a,conflicting,handler,registered;protected,void,register,handler,string,url,path,object,handler,throws,beans,exception,illegal,state,exception,assert,not,null,url,path,url,path,must,not,be,null,assert,not,null,handler,handler,object,must,not,be,null,object,resolved,handler,handler,url,path,prepend,leading,slash,url,path,path,pattern,pattern,get,path,pattern,parser,parse,url,path,if,this,handler,map,contains,key,pattern,object,existing,handler,this,handler,map,get,pattern,if,existing,handler,null,if,existing,handler,resolved,handler,throw,new,illegal,state,exception,cannot,map,get,handler,description,handler,to,url,path,there,is,already,get,handler,description,existing,handler,mapped,if,this,lazy,init,handlers,handler,instanceof,string,string,handler,name,string,handler,if,obtain,application,context,is,singleton,handler,name,resolved,handler,obtain,application,context,get,bean,handler,name,this,handler,map,put,pattern,resolved,handler,if,logger,is,info,enabled,logger,info,mapped,url,path,url,path,onto,get,handler,description,handler
AbstractUrlHandlerMapping -> protected void registerHandler(String urlPath, Object handler) 			throws BeansException, IllegalStateException;1520075565;Register the specified handler for the given URL path._@param urlPath the URL the bean should be mapped to_@param handler the handler instance or handler bean name String_(a bean name will automatically be resolved into the corresponding handler bean)_@throws BeansException if the handler couldn't be registered_@throws IllegalStateException if there is a conflicting handler registered;protected void registerHandler(String urlPath, Object handler)_			throws BeansException, IllegalStateException {__		Assert.notNull(urlPath, "URL path must not be null")__		Assert.notNull(handler, "Handler object must not be null")__		Object resolvedHandler = handler___		_		urlPath = prependLeadingSlash(urlPath)__		PathPattern pattern = getPathPatternParser().parse(urlPath)__		if (this.handlerMap.containsKey(pattern)) {_			Object existingHandler = this.handlerMap.get(pattern)__			if (existingHandler != null) {_				if (existingHandler != resolvedHandler) {_					throw new IllegalStateException(_							"Cannot map " + getHandlerDescription(handler) + " to [" + urlPath + "]: " +_							"there is already " + getHandlerDescription(existingHandler) + " mapped.")__				}_			}_		}__		_		if (!this.lazyInitHandlers && handler instanceof String) {_			String handlerName = (String) handler__			if (obtainApplicationContext().isSingleton(handlerName)) {_				resolvedHandler = obtainApplicationContext().getBean(handlerName)__			}_		}__		_		this.handlerMap.put(pattern, resolvedHandler)__		if (logger.isInfoEnabled()) {_			logger.info("Mapped URL path [" + urlPath + "] onto " + getHandlerDescription(handler))__		}_	};register,the,specified,handler,for,the,given,url,path,param,url,path,the,url,the,bean,should,be,mapped,to,param,handler,the,handler,instance,or,handler,bean,name,string,a,bean,name,will,automatically,be,resolved,into,the,corresponding,handler,bean,throws,beans,exception,if,the,handler,couldn,t,be,registered,throws,illegal,state,exception,if,there,is,a,conflicting,handler,registered;protected,void,register,handler,string,url,path,object,handler,throws,beans,exception,illegal,state,exception,assert,not,null,url,path,url,path,must,not,be,null,assert,not,null,handler,handler,object,must,not,be,null,object,resolved,handler,handler,url,path,prepend,leading,slash,url,path,path,pattern,pattern,get,path,pattern,parser,parse,url,path,if,this,handler,map,contains,key,pattern,object,existing,handler,this,handler,map,get,pattern,if,existing,handler,null,if,existing,handler,resolved,handler,throw,new,illegal,state,exception,cannot,map,get,handler,description,handler,to,url,path,there,is,already,get,handler,description,existing,handler,mapped,if,this,lazy,init,handlers,handler,instanceof,string,string,handler,name,string,handler,if,obtain,application,context,is,singleton,handler,name,resolved,handler,obtain,application,context,get,bean,handler,name,this,handler,map,put,pattern,resolved,handler,if,logger,is,info,enabled,logger,info,mapped,url,path,url,path,onto,get,handler,description,handler
AbstractUrlHandlerMapping -> @SuppressWarnings("UnusedParameters") 	protected void validateHandler(Object handler, ServerWebExchange exchange) throws Exception;1485986572;Validate the given handler against the current request._<p>The default implementation is empty. Can be overridden in subclasses,_for example to enforce specific preconditions expressed in URL mappings._@param handler the handler object to validate_@param exchange current exchange_@throws Exception if validation failed;@SuppressWarnings("UnusedParameters")_	protected void validateHandler(Object handler, ServerWebExchange exchange) throws Exception {_	};validate,the,given,handler,against,the,current,request,p,the,default,implementation,is,empty,can,be,overridden,in,subclasses,for,example,to,enforce,specific,preconditions,expressed,in,url,mappings,param,handler,the,handler,object,to,validate,param,exchange,current,exchange,throws,exception,if,validation,failed;suppress,warnings,unused,parameters,protected,void,validate,handler,object,handler,server,web,exchange,exchange,throws,exception
AbstractUrlHandlerMapping -> @SuppressWarnings("UnusedParameters") 	protected void validateHandler(Object handler, ServerWebExchange exchange) throws Exception;1486635693;Validate the given handler against the current request._<p>The default implementation is empty. Can be overridden in subclasses,_for example to enforce specific preconditions expressed in URL mappings._@param handler the handler object to validate_@param exchange current exchange_@throws Exception if validation failed;@SuppressWarnings("UnusedParameters")_	protected void validateHandler(Object handler, ServerWebExchange exchange) throws Exception {_	};validate,the,given,handler,against,the,current,request,p,the,default,implementation,is,empty,can,be,overridden,in,subclasses,for,example,to,enforce,specific,preconditions,expressed,in,url,mappings,param,handler,the,handler,object,to,validate,param,exchange,current,exchange,throws,exception,if,validation,failed;suppress,warnings,unused,parameters,protected,void,validate,handler,object,handler,server,web,exchange,exchange,throws,exception
AbstractUrlHandlerMapping -> @SuppressWarnings("UnusedParameters") 	protected void validateHandler(Object handler, ServerWebExchange exchange) throws Exception;1486747801;Validate the given handler against the current request._<p>The default implementation is empty. Can be overridden in subclasses,_for example to enforce specific preconditions expressed in URL mappings._@param handler the handler object to validate_@param exchange current exchange_@throws Exception if validation failed;@SuppressWarnings("UnusedParameters")_	protected void validateHandler(Object handler, ServerWebExchange exchange) throws Exception {_	};validate,the,given,handler,against,the,current,request,p,the,default,implementation,is,empty,can,be,overridden,in,subclasses,for,example,to,enforce,specific,preconditions,expressed,in,url,mappings,param,handler,the,handler,object,to,validate,param,exchange,current,exchange,throws,exception,if,validation,failed;suppress,warnings,unused,parameters,protected,void,validate,handler,object,handler,server,web,exchange,exchange,throws,exception
AbstractUrlHandlerMapping -> @SuppressWarnings("UnusedParameters") 	protected void validateHandler(Object handler, ServerWebExchange exchange) throws Exception;1486747828;Validate the given handler against the current request._<p>The default implementation is empty. Can be overridden in subclasses,_for example to enforce specific preconditions expressed in URL mappings._@param handler the handler object to validate_@param exchange current exchange_@throws Exception if validation failed;@SuppressWarnings("UnusedParameters")_	protected void validateHandler(Object handler, ServerWebExchange exchange) throws Exception {_	};validate,the,given,handler,against,the,current,request,p,the,default,implementation,is,empty,can,be,overridden,in,subclasses,for,example,to,enforce,specific,preconditions,expressed,in,url,mappings,param,handler,the,handler,object,to,validate,param,exchange,current,exchange,throws,exception,if,validation,failed;suppress,warnings,unused,parameters,protected,void,validate,handler,object,handler,server,web,exchange,exchange,throws,exception
AbstractUrlHandlerMapping -> @SuppressWarnings("UnusedParameters") 	protected void validateHandler(Object handler, ServerWebExchange exchange) throws Exception;1495035625;Validate the given handler against the current request._<p>The default implementation is empty. Can be overridden in subclasses,_for example to enforce specific preconditions expressed in URL mappings._@param handler the handler object to validate_@param exchange current exchange_@throws Exception if validation failed;@SuppressWarnings("UnusedParameters")_	protected void validateHandler(Object handler, ServerWebExchange exchange) throws Exception {_	};validate,the,given,handler,against,the,current,request,p,the,default,implementation,is,empty,can,be,overridden,in,subclasses,for,example,to,enforce,specific,preconditions,expressed,in,url,mappings,param,handler,the,handler,object,to,validate,param,exchange,current,exchange,throws,exception,if,validation,failed;suppress,warnings,unused,parameters,protected,void,validate,handler,object,handler,server,web,exchange,exchange,throws,exception
AbstractUrlHandlerMapping -> @SuppressWarnings("UnusedParameters") 	protected void validateHandler(Object handler, ServerWebExchange exchange) throws Exception;1495868221;Validate the given handler against the current request._<p>The default implementation is empty. Can be overridden in subclasses,_for example to enforce specific preconditions expressed in URL mappings._@param handler the handler object to validate_@param exchange current exchange_@throws Exception if validation failed;@SuppressWarnings("UnusedParameters")_	protected void validateHandler(Object handler, ServerWebExchange exchange) throws Exception {_	};validate,the,given,handler,against,the,current,request,p,the,default,implementation,is,empty,can,be,overridden,in,subclasses,for,example,to,enforce,specific,preconditions,expressed,in,url,mappings,param,handler,the,handler,object,to,validate,param,exchange,current,exchange,throws,exception,if,validation,failed;suppress,warnings,unused,parameters,protected,void,validate,handler,object,handler,server,web,exchange,exchange,throws,exception
AbstractUrlHandlerMapping -> @SuppressWarnings("UnusedParameters") 	protected void validateHandler(Object handler, ServerWebExchange exchange) throws Exception;1496334664;Validate the given handler against the current request._<p>The default implementation is empty. Can be overridden in subclasses,_for example to enforce specific preconditions expressed in URL mappings._@param handler the handler object to validate_@param exchange current exchange_@throws Exception if validation failed;@SuppressWarnings("UnusedParameters")_	protected void validateHandler(Object handler, ServerWebExchange exchange) throws Exception {_	};validate,the,given,handler,against,the,current,request,p,the,default,implementation,is,empty,can,be,overridden,in,subclasses,for,example,to,enforce,specific,preconditions,expressed,in,url,mappings,param,handler,the,handler,object,to,validate,param,exchange,current,exchange,throws,exception,if,validation,failed;suppress,warnings,unused,parameters,protected,void,validate,handler,object,handler,server,web,exchange,exchange,throws,exception
AbstractUrlHandlerMapping -> @SuppressWarnings("UnusedParameters") 	protected void validateHandler(Object handler, ServerWebExchange exchange) throws Exception;1496430942;Validate the given handler against the current request._<p>The default implementation is empty. Can be overridden in subclasses,_for example to enforce specific preconditions expressed in URL mappings._@param handler the handler object to validate_@param exchange current exchange_@throws Exception if validation failed;@SuppressWarnings("UnusedParameters")_	protected void validateHandler(Object handler, ServerWebExchange exchange) throws Exception {_	};validate,the,given,handler,against,the,current,request,p,the,default,implementation,is,empty,can,be,overridden,in,subclasses,for,example,to,enforce,specific,preconditions,expressed,in,url,mappings,param,handler,the,handler,object,to,validate,param,exchange,current,exchange,throws,exception,if,validation,failed;suppress,warnings,unused,parameters,protected,void,validate,handler,object,handler,server,web,exchange,exchange,throws,exception
AbstractUrlHandlerMapping -> @SuppressWarnings("UnusedParameters") 	protected void validateHandler(Object handler, ServerWebExchange exchange) throws Exception;1496837955;Validate the given handler against the current request._<p>The default implementation is empty. Can be overridden in subclasses,_for example to enforce specific preconditions expressed in URL mappings._@param handler the handler object to validate_@param exchange current exchange_@throws Exception if validation failed;@SuppressWarnings("UnusedParameters")_	protected void validateHandler(Object handler, ServerWebExchange exchange) throws Exception {_	};validate,the,given,handler,against,the,current,request,p,the,default,implementation,is,empty,can,be,overridden,in,subclasses,for,example,to,enforce,specific,preconditions,expressed,in,url,mappings,param,handler,the,handler,object,to,validate,param,exchange,current,exchange,throws,exception,if,validation,failed;suppress,warnings,unused,parameters,protected,void,validate,handler,object,handler,server,web,exchange,exchange,throws,exception
AbstractUrlHandlerMapping -> @SuppressWarnings("UnusedParameters") 	protected void validateHandler(Object handler, ServerWebExchange exchange) throws Exception;1497039338;Validate the given handler against the current request._<p>The default implementation is empty. Can be overridden in subclasses,_for example to enforce specific preconditions expressed in URL mappings._@param handler the handler object to validate_@param exchange current exchange_@throws Exception if validation failed;@SuppressWarnings("UnusedParameters")_	protected void validateHandler(Object handler, ServerWebExchange exchange) throws Exception {_	};validate,the,given,handler,against,the,current,request,p,the,default,implementation,is,empty,can,be,overridden,in,subclasses,for,example,to,enforce,specific,preconditions,expressed,in,url,mappings,param,handler,the,handler,object,to,validate,param,exchange,current,exchange,throws,exception,if,validation,failed;suppress,warnings,unused,parameters,protected,void,validate,handler,object,handler,server,web,exchange,exchange,throws,exception
AbstractUrlHandlerMapping -> @SuppressWarnings("UnusedParameters") 	protected void validateHandler(Object handler, ServerWebExchange exchange) throws Exception;1497232764;Validate the given handler against the current request._<p>The default implementation is empty. Can be overridden in subclasses,_for example to enforce specific preconditions expressed in URL mappings._@param handler the handler object to validate_@param exchange current exchange_@throws Exception if validation failed;@SuppressWarnings("UnusedParameters")_	protected void validateHandler(Object handler, ServerWebExchange exchange) throws Exception {_	};validate,the,given,handler,against,the,current,request,p,the,default,implementation,is,empty,can,be,overridden,in,subclasses,for,example,to,enforce,specific,preconditions,expressed,in,url,mappings,param,handler,the,handler,object,to,validate,param,exchange,current,exchange,throws,exception,if,validation,failed;suppress,warnings,unused,parameters,protected,void,validate,handler,object,handler,server,web,exchange,exchange,throws,exception
AbstractUrlHandlerMapping -> @SuppressWarnings("UnusedParameters") 	protected void validateHandler(Object handler, ServerWebExchange exchange) throws Exception;1497286385;Validate the given handler against the current request._<p>The default implementation is empty. Can be overridden in subclasses,_for example to enforce specific preconditions expressed in URL mappings._@param handler the handler object to validate_@param exchange current exchange_@throws Exception if validation failed;@SuppressWarnings("UnusedParameters")_	protected void validateHandler(Object handler, ServerWebExchange exchange) throws Exception {_	};validate,the,given,handler,against,the,current,request,p,the,default,implementation,is,empty,can,be,overridden,in,subclasses,for,example,to,enforce,specific,preconditions,expressed,in,url,mappings,param,handler,the,handler,object,to,validate,param,exchange,current,exchange,throws,exception,if,validation,failed;suppress,warnings,unused,parameters,protected,void,validate,handler,object,handler,server,web,exchange,exchange,throws,exception
AbstractUrlHandlerMapping -> @SuppressWarnings("UnusedParameters") 	protected void validateHandler(Object handler, ServerWebExchange exchange) throws Exception;1498756719;Validate the given handler against the current request._<p>The default implementation is empty. Can be overridden in subclasses,_for example to enforce specific preconditions expressed in URL mappings._@param handler the handler object to validate_@param exchange current exchange_@throws Exception if validation failed;@SuppressWarnings("UnusedParameters")_	protected void validateHandler(Object handler, ServerWebExchange exchange) throws Exception {_	};validate,the,given,handler,against,the,current,request,p,the,default,implementation,is,empty,can,be,overridden,in,subclasses,for,example,to,enforce,specific,preconditions,expressed,in,url,mappings,param,handler,the,handler,object,to,validate,param,exchange,current,exchange,throws,exception,if,validation,failed;suppress,warnings,unused,parameters,protected,void,validate,handler,object,handler,server,web,exchange,exchange,throws,exception
AbstractUrlHandlerMapping -> @SuppressWarnings("UnusedParameters") 	protected void validateHandler(Object handler, ServerWebExchange exchange) throws Exception;1498780456;Validate the given handler against the current request._<p>The default implementation is empty. Can be overridden in subclasses,_for example to enforce specific preconditions expressed in URL mappings._@param handler the handler object to validate_@param exchange current exchange_@throws Exception if validation failed;@SuppressWarnings("UnusedParameters")_	protected void validateHandler(Object handler, ServerWebExchange exchange) throws Exception {_	};validate,the,given,handler,against,the,current,request,p,the,default,implementation,is,empty,can,be,overridden,in,subclasses,for,example,to,enforce,specific,preconditions,expressed,in,url,mappings,param,handler,the,handler,object,to,validate,param,exchange,current,exchange,throws,exception,if,validation,failed;suppress,warnings,unused,parameters,protected,void,validate,handler,object,handler,server,web,exchange,exchange,throws,exception
AbstractUrlHandlerMapping -> @SuppressWarnings("UnusedParameters") 	protected void validateHandler(Object handler, ServerWebExchange exchange) throws Exception;1498944474;Validate the given handler against the current request._<p>The default implementation is empty. Can be overridden in subclasses,_for example to enforce specific preconditions expressed in URL mappings._@param handler the handler object to validate_@param exchange current exchange_@throws Exception if validation failed;@SuppressWarnings("UnusedParameters")_	protected void validateHandler(Object handler, ServerWebExchange exchange) throws Exception {_	};validate,the,given,handler,against,the,current,request,p,the,default,implementation,is,empty,can,be,overridden,in,subclasses,for,example,to,enforce,specific,preconditions,expressed,in,url,mappings,param,handler,the,handler,object,to,validate,param,exchange,current,exchange,throws,exception,if,validation,failed;suppress,warnings,unused,parameters,protected,void,validate,handler,object,handler,server,web,exchange,exchange,throws,exception
AbstractUrlHandlerMapping -> @SuppressWarnings("UnusedParameters") 	protected void validateHandler(Object handler, ServerWebExchange exchange) throws Exception;1498953917;Validate the given handler against the current request._<p>The default implementation is empty. Can be overridden in subclasses,_for example to enforce specific preconditions expressed in URL mappings._@param handler the handler object to validate_@param exchange current exchange_@throws Exception if validation failed;@SuppressWarnings("UnusedParameters")_	protected void validateHandler(Object handler, ServerWebExchange exchange) throws Exception {_	};validate,the,given,handler,against,the,current,request,p,the,default,implementation,is,empty,can,be,overridden,in,subclasses,for,example,to,enforce,specific,preconditions,expressed,in,url,mappings,param,handler,the,handler,object,to,validate,param,exchange,current,exchange,throws,exception,if,validation,failed;suppress,warnings,unused,parameters,protected,void,validate,handler,object,handler,server,web,exchange,exchange,throws,exception
