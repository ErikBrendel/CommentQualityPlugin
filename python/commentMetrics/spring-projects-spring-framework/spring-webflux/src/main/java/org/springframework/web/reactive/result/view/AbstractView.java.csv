commented;modifiers;parameterAmount;loc;comment;code
true;public;1;5;/**  * Set the supported media types for this view.  * Default is "text/html.charset=UTF-8".  */ ;/**  * Set the supported media types for this view.  * Default is "text/html.charset=UTF-8".  */ public void setSupportedMediaTypes(List<MediaType> supportedMediaTypes) {     Assert.notEmpty(supportedMediaTypes, "MediaType List must not be empty").     this.mediaTypes.clear().     this.mediaTypes.addAll(supportedMediaTypes). }
true;public;0;4;/**  * Return the configured media types supported by this view.  */ ;/**  * Return the configured media types supported by this view.  */ @Override public List<MediaType> getSupportedMediaTypes() {     return this.mediaTypes. }
true;public;1;4;/**  * Set the default charset for this view, used when the  * {@linkplain #setSupportedMediaTypes(List) content type} does not contain one.  * Default is {@linkplain StandardCharsets#UTF_8 UTF 8}.  */ ;/**  * Set the default charset for this view, used when the  * {@linkplain #setSupportedMediaTypes(List) content type} does not contain one.  * Default is {@linkplain StandardCharsets#UTF_8 UTF 8}.  */ public void setDefaultCharset(Charset defaultCharset) {     Assert.notNull(defaultCharset, "'defaultCharset' must not be null").     this.defaultCharset = defaultCharset. }
true;public;0;3;/**  * Return the default charset, used when the  * {@linkplain #setSupportedMediaTypes(List) content type} does not contain one.  */ ;/**  * Return the default charset, used when the  * {@linkplain #setSupportedMediaTypes(List) content type} does not contain one.  */ public Charset getDefaultCharset() {     return this.defaultCharset. }
true;public;1;3;/**  * Set the name of the RequestContext attribute for this view.  * Default is none.  */ ;/**  * Set the name of the RequestContext attribute for this view.  * Default is none.  */ public void setRequestContextAttribute(@Nullable String requestContextAttribute) {     this.requestContextAttribute = requestContextAttribute. }
true;public;0;4;/**  * Return the name of the RequestContext attribute, if any.  */ ;/**  * Return the name of the RequestContext attribute, if any.  */ @Nullable public String getRequestContextAttribute() {     return this.requestContextAttribute. }
true;public;1;4;/**  * Set the view's name. Helpful for traceability.  * <p>Framework code must call this when constructing views.  */ ;/**  * Set the view's name. Helpful for traceability.  * <p>Framework code must call this when constructing views.  */ @Override public void setBeanName(@Nullable String beanName) {     this.beanName = beanName. }
true;public;0;4;/**  * Return the view's name. Should never be {@code null}, if the view was  * correctly configured.  */ ;/**  * Return the view's name. Should never be {@code null}, if the view was  * correctly configured.  */ @Nullable public String getBeanName() {     return this.beanName. }
false;public;1;4;;@Override public void setApplicationContext(@Nullable ApplicationContext applicationContext) {     this.applicationContext = applicationContext. }
false;public;0;4;;@Nullable public ApplicationContext getApplicationContext() {     return this.applicationContext. }
true;protected,final;0;5;/**  * Obtain the ApplicationContext for actual use.  * @return the ApplicationContext (never {@code null})  * @throws IllegalStateException in case of no ApplicationContext set  */ ;/**  * Obtain the ApplicationContext for actual use.  * @return the ApplicationContext (never {@code null})  * @throws IllegalStateException in case of no ApplicationContext set  */ protected final ApplicationContext obtainApplicationContext() {     ApplicationContext applicationContext = getApplicationContext().     Assert.state(applicationContext != null, "No ApplicationContext").     return applicationContext. }
true;public;3;21;/**  * Prepare the model to render.  * @param model a Map with name Strings as keys and corresponding model  * objects as values (Map can also be {@code null} in case of empty model)  * @param contentType the content type selected to render with which should  * match one of the {@link #getSupportedMediaTypes() supported media types}.  * @param exchange the current exchange  * @return {@code Mono} to represent when and if rendering succeeds  */ ;/**  * Prepare the model to render.  * @param model a Map with name Strings as keys and corresponding model  * objects as values (Map can also be {@code null} in case of empty model)  * @param contentType the content type selected to render with which should  * match one of the {@link #getSupportedMediaTypes() supported media types}.  * @param exchange the current exchange  * @return {@code Mono} to represent when and if rendering succeeds  */ @Override public Mono<Void> render(@Nullable Map<String, ?> model, @Nullable MediaType contentType, ServerWebExchange exchange) {     if (logger.isDebugEnabled()) {         logger.debug(exchange.getLogPrefix() + "View " + formatViewName() + ", model " + (model != null ? model : Collections.emptyMap())).     }     if (contentType != null) {         exchange.getResponse().getHeaders().setContentType(contentType).     }     return getModelAttributes(model, exchange).flatMap(mergedModel -> {         // Expose RequestContext?         if (this.requestContextAttribute != null) {             mergedModel.put(this.requestContextAttribute, createRequestContext(exchange, mergedModel)).         }         return renderInternal(mergedModel, contentType, exchange).     }). }
true;protected;2;12;/**  * Prepare the model to use for rendering.  * <p>The default implementation creates a combined output Map that includes  * model as well as static attributes with the former taking precedence.  */ ;/**  * Prepare the model to use for rendering.  * <p>The default implementation creates a combined output Map that includes  * model as well as static attributes with the former taking precedence.  */ protected Mono<Map<String, Object>> getModelAttributes(@Nullable Map<String, ?> model, ServerWebExchange exchange) {     int size = (model != null ? model.size() : 0).     Map<String, Object> attributes = new LinkedHashMap<>(size).     if (model != null) {         attributes.putAll(model).     }     return resolveAsyncAttributes(attributes).then(Mono.just(attributes)). }
true;protected;1;41;/**  * By default, resolve async attributes supported by the  * {@link ReactiveAdapterRegistry} to their blocking counterparts.  * <p>View implementations capable of taking advantage of reactive types  * can override this method if needed.  * @return {@code Mono} for the completion of async attributes resolution  */ ;/**  * By default, resolve async attributes supported by the  * {@link ReactiveAdapterRegistry} to their blocking counterparts.  * <p>View implementations capable of taking advantage of reactive types  * can override this method if needed.  * @return {@code Mono} for the completion of async attributes resolution  */ protected Mono<Void> resolveAsyncAttributes(Map<String, Object> model) {     List<String> names = new ArrayList<>().     List<Mono<?>> valueMonos = new ArrayList<>().     for (Map.Entry<String, ?> entry : model.entrySet()) {         Object value = entry.getValue().         if (value == null) {             continue.         }         ReactiveAdapter adapter = this.reactiveAdapterRegistry.getAdapter(null, value).         if (adapter != null) {             names.add(entry.getKey()).             if (adapter.isMultiValue()) {                 Flux<Object> fluxValue = Flux.from(adapter.toPublisher(value)).                 valueMonos.add(fluxValue.collectList().defaultIfEmpty(Collections.emptyList())).             } else {                 Mono<Object> monoValue = Mono.from(adapter.toPublisher(value)).                 valueMonos.add(monoValue.defaultIfEmpty(NO_VALUE)).             }         }     }     if (names.isEmpty()) {         return Mono.empty().     }     return Mono.zip(valueMonos, values -> {         for (int i = 0. i < values.length. i++) {             if (values[i] != NO_VALUE) {                 model.put(names.get(i), values[i]).             } else {                 model.remove(names.get(i)).             }         }         return NO_VALUE.     }).then(). }
true;protected;2;3;/**  * Create a RequestContext to expose under the specified attribute name.  * <p>The default implementation creates a standard RequestContext instance  * for the given request and model. Can be overridden in subclasses for  * custom instances.  * @param exchange current exchange  * @param model combined output Map (never {@code null}),  * with dynamic values taking precedence over static attributes  * @return the RequestContext instance  * @see #setRequestContextAttribute  */ ;/**  * Create a RequestContext to expose under the specified attribute name.  * <p>The default implementation creates a standard RequestContext instance  * for the given request and model. Can be overridden in subclasses for  * custom instances.  * @param exchange current exchange  * @param model combined output Map (never {@code null}),  * with dynamic values taking precedence over static attributes  * @return the RequestContext instance  * @see #setRequestContextAttribute  */ protected RequestContext createRequestContext(ServerWebExchange exchange, Map<String, Object> model) {     return new RequestContext(exchange, model, obtainApplicationContext(), getRequestDataValueProcessor()). }
true;protected;0;8;/**  * Return the {@link RequestDataValueProcessor} to use.  * <p>The default implementation looks in the {@link #getApplicationContext()  * Spring configuration} for a {@code RequestDataValueProcessor} bean with  * the name {@link #REQUEST_DATA_VALUE_PROCESSOR_BEAN_NAME}.  * @return the RequestDataValueProcessor, or null if there is none at the  * application context.  */ ;/**  * Return the {@link RequestDataValueProcessor} to use.  * <p>The default implementation looks in the {@link #getApplicationContext()  * Spring configuration} for a {@code RequestDataValueProcessor} bean with  * the name {@link #REQUEST_DATA_VALUE_PROCESSOR_BEAN_NAME}.  * @return the RequestDataValueProcessor, or null if there is none at the  * application context.  */ @Nullable protected RequestDataValueProcessor getRequestDataValueProcessor() {     ApplicationContext context = getApplicationContext().     if (context != null && context.containsBean(REQUEST_DATA_VALUE_PROCESSOR_BEAN_NAME)) {         return context.getBean(REQUEST_DATA_VALUE_PROCESSOR_BEAN_NAME, RequestDataValueProcessor.class).     }     return null. }
true;protected,abstract;3;2;/**  *  Subclasses must implement this method to actually render the view.  *  @param renderAttributes combined output Map (never {@code null}),  *  with dynamic values taking precedence over static attributes  *  @param contentType the content type selected to render with which should  *  match one of the {@link #getSupportedMediaTypes() supported media types}.  * @param exchange current exchange  @return {@code Mono} to represent when  *  and if rendering succeeds  */ ;/**  *  Subclasses must implement this method to actually render the view.  *  @param renderAttributes combined output Map (never {@code null}),  *  with dynamic values taking precedence over static attributes  *  @param contentType the content type selected to render with which should  *  match one of the {@link #getSupportedMediaTypes() supported media types}.  * @param exchange current exchange  @return {@code Mono} to represent when  *  and if rendering succeeds  */ protected abstract Mono<Void> renderInternal(Map<String, Object> renderAttributes, @Nullable MediaType contentType, ServerWebExchange exchange).
false;public;0;4;;@Override public String toString() {     return getClass().getName() + ": " + formatViewName(). }
false;protected;0;4;;protected String formatViewName() {     return (getBeanName() != null ? "name '" + getBeanName() + "'" : "[" + getClass().getSimpleName() + "]"). }
