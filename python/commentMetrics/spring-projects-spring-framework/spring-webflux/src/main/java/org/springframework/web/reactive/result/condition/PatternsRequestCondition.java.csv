commented;modifiers;parameterAmount;loc;comment;code
false;public;0;3;;public Set<PathPattern> getPatterns() {     return this.patterns. }
false;protected;0;4;;@Override protected Collection<PathPattern> getContent() {     return this.patterns. }
false;protected;0;4;;@Override protected String getToStringInfix() {     return " || ". }
true;public;1;18;/**  * Returns a new instance with URL patterns from the current instance ("this") and  * the "other" instance as follows:  * <ul>  * <li>If there are patterns in both instances, combine the patterns in "this" with  * the patterns in "other" using {@link PathPattern#combine(PathPattern)}.  * <li>If only one instance has patterns, use them.  * <li>If neither instance has patterns, use an empty String (i.e. "").  * </ul>  */ ;/**  * Returns a new instance with URL patterns from the current instance ("this") and  * the "other" instance as follows:  * <ul>  * <li>If there are patterns in both instances, combine the patterns in "this" with  * the patterns in "other" using {@link PathPattern#combine(PathPattern)}.  * <li>If only one instance has patterns, use them.  * <li>If neither instance has patterns, use an empty String (i.e. "").  * </ul>  */ @Override public PatternsRequestCondition combine(PatternsRequestCondition other) {     List<PathPattern> combined = new ArrayList<>().     if (!this.patterns.isEmpty() && !other.patterns.isEmpty()) {         for (PathPattern pattern1 : this.patterns) {             for (PathPattern pattern2 : other.patterns) {                 combined.add(pattern1.combine(pattern2)).             }         }     } else if (!this.patterns.isEmpty()) {         combined.addAll(this.patterns).     } else if (!other.patterns.isEmpty()) {         combined.addAll(other.patterns).     }     return new PatternsRequestCondition(combined). }
true;public;1;9;/**  * Checks if any of the patterns match the given request and returns an instance  * that is guaranteed to contain matching patterns, sorted.  * @param exchange the current exchange  * @return the same instance if the condition contains no patterns.  * or a new condition with sorted matching patterns.  * or {@code null} if no patterns match.  */ ;/**  * Checks if any of the patterns match the given request and returns an instance  * that is guaranteed to contain matching patterns, sorted.  * @param exchange the current exchange  * @return the same instance if the condition contains no patterns.  * or a new condition with sorted matching patterns.  * or {@code null} if no patterns match.  */ @Override @Nullable public PatternsRequestCondition getMatchingCondition(ServerWebExchange exchange) {     if (this.patterns.isEmpty()) {         return this.     }     SortedSet<PathPattern> matches = getMatchingPatterns(exchange).     return (!matches.isEmpty() ? new PatternsRequestCondition(matches) : null). }
true;private;1;6;/**  * Find the patterns matching the given lookup path. Invoking this method should  * yield results equivalent to those of calling  * {@link #getMatchingCondition(ServerWebExchange)}.  * This method is provided as an alternative to be used if no request is available  * (e.g. introspection, tooling, etc).  * @param exchange the current exchange  * @return a sorted set of matching patterns sorted with the closest match first  */ ;/**  * Find the patterns matching the given lookup path. Invoking this method should  * yield results equivalent to those of calling  * {@link #getMatchingCondition(ServerWebExchange)}.  * This method is provided as an alternative to be used if no request is available  * (e.g. introspection, tooling, etc).  * @param exchange the current exchange  * @return a sorted set of matching patterns sorted with the closest match first  */ private SortedSet<PathPattern> getMatchingPatterns(ServerWebExchange exchange) {     PathContainer lookupPath = exchange.getRequest().getPath().pathWithinApplication().     return this.patterns.stream().filter(pattern -> pattern.matches(lookupPath)).collect(Collectors.toCollection(TreeSet::new)). }
true;public;2;20;/**  * Compare the two conditions based on the URL patterns they contain.  * Patterns are compared one at a time, from top to bottom. If all compared  * patterns match equally, but one instance has more patterns, it is  * considered a closer match.  * <p>It is assumed that both instances have been obtained via  * {@link #getMatchingCondition(ServerWebExchange)} to ensure they  * contain only patterns that match the request and are sorted with  * the best matches on top.  */ ;/**  * Compare the two conditions based on the URL patterns they contain.  * Patterns are compared one at a time, from top to bottom. If all compared  * patterns match equally, but one instance has more patterns, it is  * considered a closer match.  * <p>It is assumed that both instances have been obtained via  * {@link #getMatchingCondition(ServerWebExchange)} to ensure they  * contain only patterns that match the request and are sorted with  * the best matches on top.  */ @Override public int compareTo(PatternsRequestCondition other, ServerWebExchange exchange) {     Iterator<PathPattern> iterator = this.patterns.iterator().     Iterator<PathPattern> iteratorOther = other.getPatterns().iterator().     while (iterator.hasNext() && iteratorOther.hasNext()) {         int result = PathPattern.SPECIFICITY_COMPARATOR.compare(iterator.next(), iteratorOther.next()).         if (result != 0) {             return result.         }     }     if (iterator.hasNext()) {         return -1.     } else if (iteratorOther.hasNext()) {         return 1.     } else {         return 0.     } }
