# id;timestamp;commentText;codeText;commentWords;codeWords
PatternsRequestCondition -> public PatternsRequestCondition(String[] patterns, HttpRequestPathHelper pathHelper, 			PathMatcher pathMatcher, boolean useSuffixPatternMatch, boolean useTrailingSlashMatch, 			Set<String> extensions);1485986572;Creates a new instance with the given URL patterns._Each pattern that is not empty and does not start with "/" is pre-pended with "/"._@param patterns the URL patterns to use_ if 0, the condition will match to every request._@param pathHelper to determine the lookup path for a request_@param pathMatcher for pattern path matching_@param useSuffixPatternMatch whether to enable matching by suffix (".*")_@param useTrailingSlashMatch whether to match irrespective of a trailing slash_@param extensions file extensions to consider for path matching;public PatternsRequestCondition(String[] patterns, HttpRequestPathHelper pathHelper,_			PathMatcher pathMatcher, boolean useSuffixPatternMatch, boolean useTrailingSlashMatch,_			Set<String> extensions) {__		this(asList(patterns), pathHelper, pathMatcher, useSuffixPatternMatch, useTrailingSlashMatch, extensions)__	};creates,a,new,instance,with,the,given,url,patterns,each,pattern,that,is,not,empty,and,does,not,start,with,is,pre,pended,with,param,patterns,the,url,patterns,to,use,if,0,the,condition,will,match,to,every,request,param,path,helper,to,determine,the,lookup,path,for,a,request,param,path,matcher,for,pattern,path,matching,param,use,suffix,pattern,match,whether,to,enable,matching,by,suffix,param,use,trailing,slash,match,whether,to,match,irrespective,of,a,trailing,slash,param,extensions,file,extensions,to,consider,for,path,matching;public,patterns,request,condition,string,patterns,http,request,path,helper,path,helper,path,matcher,path,matcher,boolean,use,suffix,pattern,match,boolean,use,trailing,slash,match,set,string,extensions,this,as,list,patterns,path,helper,path,matcher,use,suffix,pattern,match,use,trailing,slash,match,extensions
PatternsRequestCondition -> public PatternsRequestCondition(String[] patterns, HttpRequestPathHelper pathHelper, 			PathMatcher pathMatcher, boolean useSuffixPatternMatch, boolean useTrailingSlashMatch, 			Set<String> extensions);1486634978;Creates a new instance with the given URL patterns._Each pattern that is not empty and does not start with "/" is pre-pended with "/"._@param patterns the URL patterns to use_ if 0, the condition will match to every request._@param pathHelper to determine the lookup path for a request_@param pathMatcher for pattern path matching_@param useSuffixPatternMatch whether to enable matching by suffix (".*")_@param useTrailingSlashMatch whether to match irrespective of a trailing slash_@param extensions file extensions to consider for path matching;public PatternsRequestCondition(String[] patterns, HttpRequestPathHelper pathHelper,_			PathMatcher pathMatcher, boolean useSuffixPatternMatch, boolean useTrailingSlashMatch,_			Set<String> extensions) {__		this(asList(patterns), pathHelper, pathMatcher, useSuffixPatternMatch, useTrailingSlashMatch, extensions)__	};creates,a,new,instance,with,the,given,url,patterns,each,pattern,that,is,not,empty,and,does,not,start,with,is,pre,pended,with,param,patterns,the,url,patterns,to,use,if,0,the,condition,will,match,to,every,request,param,path,helper,to,determine,the,lookup,path,for,a,request,param,path,matcher,for,pattern,path,matching,param,use,suffix,pattern,match,whether,to,enable,matching,by,suffix,param,use,trailing,slash,match,whether,to,match,irrespective,of,a,trailing,slash,param,extensions,file,extensions,to,consider,for,path,matching;public,patterns,request,condition,string,patterns,http,request,path,helper,path,helper,path,matcher,path,matcher,boolean,use,suffix,pattern,match,boolean,use,trailing,slash,match,set,string,extensions,this,as,list,patterns,path,helper,path,matcher,use,suffix,pattern,match,use,trailing,slash,match,extensions
PatternsRequestCondition -> public PatternsRequestCondition(String[] patterns, HttpRequestPathHelper pathHelper, 			PathMatcher pathMatcher, boolean useSuffixPatternMatch, boolean useTrailingSlashMatch, 			Set<String> extensions);1486747801;Creates a new instance with the given URL patterns._Each pattern that is not empty and does not start with "/" is pre-pended with "/"._@param patterns the URL patterns to use_ if 0, the condition will match to every request._@param pathHelper to determine the lookup path for a request_@param pathMatcher for pattern path matching_@param useSuffixPatternMatch whether to enable matching by suffix (".*")_@param useTrailingSlashMatch whether to match irrespective of a trailing slash_@param extensions file extensions to consider for path matching;public PatternsRequestCondition(String[] patterns, HttpRequestPathHelper pathHelper,_			PathMatcher pathMatcher, boolean useSuffixPatternMatch, boolean useTrailingSlashMatch,_			Set<String> extensions) {__		this(asList(patterns), pathHelper, pathMatcher, useSuffixPatternMatch, useTrailingSlashMatch, extensions)__	};creates,a,new,instance,with,the,given,url,patterns,each,pattern,that,is,not,empty,and,does,not,start,with,is,pre,pended,with,param,patterns,the,url,patterns,to,use,if,0,the,condition,will,match,to,every,request,param,path,helper,to,determine,the,lookup,path,for,a,request,param,path,matcher,for,pattern,path,matching,param,use,suffix,pattern,match,whether,to,enable,matching,by,suffix,param,use,trailing,slash,match,whether,to,match,irrespective,of,a,trailing,slash,param,extensions,file,extensions,to,consider,for,path,matching;public,patterns,request,condition,string,patterns,http,request,path,helper,path,helper,path,matcher,path,matcher,boolean,use,suffix,pattern,match,boolean,use,trailing,slash,match,set,string,extensions,this,as,list,patterns,path,helper,path,matcher,use,suffix,pattern,match,use,trailing,slash,match,extensions
PatternsRequestCondition -> public PatternsRequestCondition(String[] patterns, HttpRequestPathHelper pathHelper, 			PathMatcher pathMatcher, boolean useSuffixPatternMatch, boolean useTrailingSlashMatch, 			Set<String> extensions);1495035625;Creates a new instance with the given URL patterns._Each pattern that is not empty and does not start with "/" is pre-pended with "/"._@param patterns the URL patterns to use_ if 0, the condition will match to every request._@param pathHelper to determine the lookup path for a request_@param pathMatcher for pattern path matching_@param useSuffixPatternMatch whether to enable matching by suffix (".*")_@param useTrailingSlashMatch whether to match irrespective of a trailing slash_@param extensions file extensions to consider for path matching;public PatternsRequestCondition(String[] patterns, HttpRequestPathHelper pathHelper,_			PathMatcher pathMatcher, boolean useSuffixPatternMatch, boolean useTrailingSlashMatch,_			Set<String> extensions) {__		this(asList(patterns), pathHelper, pathMatcher, useSuffixPatternMatch, useTrailingSlashMatch, extensions)__	};creates,a,new,instance,with,the,given,url,patterns,each,pattern,that,is,not,empty,and,does,not,start,with,is,pre,pended,with,param,patterns,the,url,patterns,to,use,if,0,the,condition,will,match,to,every,request,param,path,helper,to,determine,the,lookup,path,for,a,request,param,path,matcher,for,pattern,path,matching,param,use,suffix,pattern,match,whether,to,enable,matching,by,suffix,param,use,trailing,slash,match,whether,to,match,irrespective,of,a,trailing,slash,param,extensions,file,extensions,to,consider,for,path,matching;public,patterns,request,condition,string,patterns,http,request,path,helper,path,helper,path,matcher,path,matcher,boolean,use,suffix,pattern,match,boolean,use,trailing,slash,match,set,string,extensions,this,as,list,patterns,path,helper,path,matcher,use,suffix,pattern,match,use,trailing,slash,match,extensions
PatternsRequestCondition -> private PatternsRequestCondition(Collection<String> patterns, PathMatcher pathMatcher, 			boolean useSuffixPatternMatch, boolean useTrailingSlashMatch, 			Set<String> fileExtensions);1496334664;Private constructor accepting a collection of patterns.;private PatternsRequestCondition(Collection<String> patterns, PathMatcher pathMatcher,_			boolean useSuffixPatternMatch, boolean useTrailingSlashMatch,_			Set<String> fileExtensions) {__		this.patterns = Collections.unmodifiableSet(prependLeadingSlash(patterns))__		this.pathMatcher = (pathMatcher != null ? pathMatcher : new ParsingPathMatcher())__		this.useSuffixPatternMatch = useSuffixPatternMatch__		this.useTrailingSlashMatch = useTrailingSlashMatch__		if (fileExtensions != null) {_			for (String fileExtension : fileExtensions) {_				if (fileExtension.charAt(0) != '.') {_					fileExtension = "." + fileExtension__				}_				this.fileExtensions.add(fileExtension)__			}_		}_	};private,constructor,accepting,a,collection,of,patterns;private,patterns,request,condition,collection,string,patterns,path,matcher,path,matcher,boolean,use,suffix,pattern,match,boolean,use,trailing,slash,match,set,string,file,extensions,this,patterns,collections,unmodifiable,set,prepend,leading,slash,patterns,this,path,matcher,path,matcher,null,path,matcher,new,parsing,path,matcher,this,use,suffix,pattern,match,use,suffix,pattern,match,this,use,trailing,slash,match,use,trailing,slash,match,if,file,extensions,null,for,string,file,extension,file,extensions,if,file,extension,char,at,0,file,extension,file,extension,this,file,extensions,add,file,extension
PatternsRequestCondition -> private PatternsRequestCondition(Collection<String> patterns, PathMatcher pathMatcher, 			boolean useSuffixPatternMatch, boolean useTrailingSlashMatch, 			Set<String> fileExtensions);1496429194;Private constructor accepting a collection of patterns.;private PatternsRequestCondition(Collection<String> patterns, PathMatcher pathMatcher,_			boolean useSuffixPatternMatch, boolean useTrailingSlashMatch,_			Set<String> fileExtensions) {__		this.patterns = Collections.unmodifiableSet(prependLeadingSlash(patterns))__		this.pathMatcher = (pathMatcher != null ? pathMatcher : new ParsingPathMatcher())__		this.useSuffixPatternMatch = useSuffixPatternMatch__		this.useTrailingSlashMatch = useTrailingSlashMatch__		if (fileExtensions != null) {_			for (String fileExtension : fileExtensions) {_				if (fileExtension.charAt(0) != '.') {_					fileExtension = "." + fileExtension__				}_				this.fileExtensions.add(fileExtension)__			}_		}_	};private,constructor,accepting,a,collection,of,patterns;private,patterns,request,condition,collection,string,patterns,path,matcher,path,matcher,boolean,use,suffix,pattern,match,boolean,use,trailing,slash,match,set,string,file,extensions,this,patterns,collections,unmodifiable,set,prepend,leading,slash,patterns,this,path,matcher,path,matcher,null,path,matcher,new,parsing,path,matcher,this,use,suffix,pattern,match,use,suffix,pattern,match,this,use,trailing,slash,match,use,trailing,slash,match,if,file,extensions,null,for,string,file,extension,file,extensions,if,file,extension,char,at,0,file,extension,file,extension,this,file,extensions,add,file,extension
PatternsRequestCondition -> private PatternsRequestCondition(Collection<String> patterns, PathMatcher pathMatcher, 			boolean useSuffixPatternMatch, boolean useTrailingSlashMatch, 			Set<String> fileExtensions);1496430942;Private constructor accepting a collection of patterns.;private PatternsRequestCondition(Collection<String> patterns, PathMatcher pathMatcher,_			boolean useSuffixPatternMatch, boolean useTrailingSlashMatch,_			Set<String> fileExtensions) {__		this.patterns = Collections.unmodifiableSet(prependLeadingSlash(patterns))__		this.pathMatcher = (pathMatcher != null ? pathMatcher : new ParsingPathMatcher())__		this.useSuffixPatternMatch = useSuffixPatternMatch__		this.useTrailingSlashMatch = useTrailingSlashMatch__		if (fileExtensions != null) {_			for (String fileExtension : fileExtensions) {_				if (fileExtension.charAt(0) != '.') {_					fileExtension = "." + fileExtension__				}_				this.fileExtensions.add(fileExtension)__			}_		}_	};private,constructor,accepting,a,collection,of,patterns;private,patterns,request,condition,collection,string,patterns,path,matcher,path,matcher,boolean,use,suffix,pattern,match,boolean,use,trailing,slash,match,set,string,file,extensions,this,patterns,collections,unmodifiable,set,prepend,leading,slash,patterns,this,path,matcher,path,matcher,null,path,matcher,new,parsing,path,matcher,this,use,suffix,pattern,match,use,suffix,pattern,match,this,use,trailing,slash,match,use,trailing,slash,match,if,file,extensions,null,for,string,file,extension,file,extensions,if,file,extension,char,at,0,file,extension,file,extension,this,file,extensions,add,file,extension
PatternsRequestCondition -> private PatternsRequestCondition(Collection<String> patterns, PathMatcher pathMatcher, 			boolean useSuffixPatternMatch, boolean useTrailingSlashMatch, 			Set<String> fileExtensions);1497039338;Private constructor accepting a collection of patterns.;private PatternsRequestCondition(Collection<String> patterns, PathMatcher pathMatcher,_			boolean useSuffixPatternMatch, boolean useTrailingSlashMatch,_			Set<String> fileExtensions) {__		this.patterns = Collections.unmodifiableSet(prependLeadingSlash(patterns))__		this.pathMatcher = (pathMatcher != null ? pathMatcher : new ParsingPathMatcher())__		this.useSuffixPatternMatch = useSuffixPatternMatch__		this.useTrailingSlashMatch = useTrailingSlashMatch__		if (fileExtensions != null) {_			for (String fileExtension : fileExtensions) {_				if (fileExtension.charAt(0) != '.') {_					fileExtension = "." + fileExtension__				}_				this.fileExtensions.add(fileExtension)__			}_		}_	};private,constructor,accepting,a,collection,of,patterns;private,patterns,request,condition,collection,string,patterns,path,matcher,path,matcher,boolean,use,suffix,pattern,match,boolean,use,trailing,slash,match,set,string,file,extensions,this,patterns,collections,unmodifiable,set,prepend,leading,slash,patterns,this,path,matcher,path,matcher,null,path,matcher,new,parsing,path,matcher,this,use,suffix,pattern,match,use,suffix,pattern,match,this,use,trailing,slash,match,use,trailing,slash,match,if,file,extensions,null,for,string,file,extension,file,extensions,if,file,extension,char,at,0,file,extension,file,extension,this,file,extensions,add,file,extension
PatternsRequestCondition -> private PatternsRequestCondition(Collection<String> patterns, PathMatcher pathMatcher, 			boolean useSuffixPatternMatch, boolean useTrailingSlashMatch, 			Set<String> fileExtensions);1497232764;Private constructor accepting a collection of patterns.;private PatternsRequestCondition(Collection<String> patterns, PathMatcher pathMatcher,_			boolean useSuffixPatternMatch, boolean useTrailingSlashMatch,_			Set<String> fileExtensions) {__		this.patterns = Collections.unmodifiableSet(prependLeadingSlash(patterns))__		this.pathMatcher = (pathMatcher != null ? pathMatcher : new ParsingPathMatcher())__		this.useSuffixPatternMatch = useSuffixPatternMatch__		this.useTrailingSlashMatch = useTrailingSlashMatch__		if (fileExtensions != null) {_			for (String fileExtension : fileExtensions) {_				if (fileExtension.charAt(0) != '.') {_					fileExtension = "." + fileExtension__				}_				this.fileExtensions.add(fileExtension)__			}_		}_	};private,constructor,accepting,a,collection,of,patterns;private,patterns,request,condition,collection,string,patterns,path,matcher,path,matcher,boolean,use,suffix,pattern,match,boolean,use,trailing,slash,match,set,string,file,extensions,this,patterns,collections,unmodifiable,set,prepend,leading,slash,patterns,this,path,matcher,path,matcher,null,path,matcher,new,parsing,path,matcher,this,use,suffix,pattern,match,use,suffix,pattern,match,this,use,trailing,slash,match,use,trailing,slash,match,if,file,extensions,null,for,string,file,extension,file,extensions,if,file,extension,char,at,0,file,extension,file,extension,this,file,extensions,add,file,extension
PatternsRequestCondition -> public List<String> getMatchingPatterns(String lookupPath);1485986572;Find the patterns matching the given lookup path. Invoking this method should_yield results equivalent to those of calling_{@link #getMatchingCondition(ServerWebExchange)}._This method is provided as an alternative to be used if no request is available_(e.g. introspection, tooling, etc)._@param lookupPath the lookup path to match to existing patterns_@return a collection of matching patterns sorted with the closest match at the top;public List<String> getMatchingPatterns(String lookupPath) {_		List<String> matches = new ArrayList<>()__		for (String pattern : this.patterns) {_			String match = getMatchingPattern(pattern, lookupPath)__			if (match != null) {_				matches.add(match)__			}_		}_		Collections.sort(matches, this.pathMatcher.getPatternComparator(lookupPath))__		return matches__	};find,the,patterns,matching,the,given,lookup,path,invoking,this,method,should,yield,results,equivalent,to,those,of,calling,link,get,matching,condition,server,web,exchange,this,method,is,provided,as,an,alternative,to,be,used,if,no,request,is,available,e,g,introspection,tooling,etc,param,lookup,path,the,lookup,path,to,match,to,existing,patterns,return,a,collection,of,matching,patterns,sorted,with,the,closest,match,at,the,top;public,list,string,get,matching,patterns,string,lookup,path,list,string,matches,new,array,list,for,string,pattern,this,patterns,string,match,get,matching,pattern,pattern,lookup,path,if,match,null,matches,add,match,collections,sort,matches,this,path,matcher,get,pattern,comparator,lookup,path,return,matches
PatternsRequestCondition -> public List<String> getMatchingPatterns(String lookupPath);1486634978;Find the patterns matching the given lookup path. Invoking this method should_yield results equivalent to those of calling_{@link #getMatchingCondition(ServerWebExchange)}._This method is provided as an alternative to be used if no request is available_(e.g. introspection, tooling, etc)._@param lookupPath the lookup path to match to existing patterns_@return a collection of matching patterns sorted with the closest match at the top;public List<String> getMatchingPatterns(String lookupPath) {_		List<String> matches = new ArrayList<>()__		for (String pattern : this.patterns) {_			String match = getMatchingPattern(pattern, lookupPath)__			if (match != null) {_				matches.add(match)__			}_		}_		Collections.sort(matches, this.pathMatcher.getPatternComparator(lookupPath))__		return matches__	};find,the,patterns,matching,the,given,lookup,path,invoking,this,method,should,yield,results,equivalent,to,those,of,calling,link,get,matching,condition,server,web,exchange,this,method,is,provided,as,an,alternative,to,be,used,if,no,request,is,available,e,g,introspection,tooling,etc,param,lookup,path,the,lookup,path,to,match,to,existing,patterns,return,a,collection,of,matching,patterns,sorted,with,the,closest,match,at,the,top;public,list,string,get,matching,patterns,string,lookup,path,list,string,matches,new,array,list,for,string,pattern,this,patterns,string,match,get,matching,pattern,pattern,lookup,path,if,match,null,matches,add,match,collections,sort,matches,this,path,matcher,get,pattern,comparator,lookup,path,return,matches
PatternsRequestCondition -> public List<String> getMatchingPatterns(String lookupPath);1486747801;Find the patterns matching the given lookup path. Invoking this method should_yield results equivalent to those of calling_{@link #getMatchingCondition(ServerWebExchange)}._This method is provided as an alternative to be used if no request is available_(e.g. introspection, tooling, etc)._@param lookupPath the lookup path to match to existing patterns_@return a collection of matching patterns sorted with the closest match at the top;public List<String> getMatchingPatterns(String lookupPath) {_		List<String> matches = new ArrayList<>()__		for (String pattern : this.patterns) {_			String match = getMatchingPattern(pattern, lookupPath)__			if (match != null) {_				matches.add(match)__			}_		}_		Collections.sort(matches, this.pathMatcher.getPatternComparator(lookupPath))__		return matches__	};find,the,patterns,matching,the,given,lookup,path,invoking,this,method,should,yield,results,equivalent,to,those,of,calling,link,get,matching,condition,server,web,exchange,this,method,is,provided,as,an,alternative,to,be,used,if,no,request,is,available,e,g,introspection,tooling,etc,param,lookup,path,the,lookup,path,to,match,to,existing,patterns,return,a,collection,of,matching,patterns,sorted,with,the,closest,match,at,the,top;public,list,string,get,matching,patterns,string,lookup,path,list,string,matches,new,array,list,for,string,pattern,this,patterns,string,match,get,matching,pattern,pattern,lookup,path,if,match,null,matches,add,match,collections,sort,matches,this,path,matcher,get,pattern,comparator,lookup,path,return,matches
PatternsRequestCondition -> public List<String> getMatchingPatterns(String lookupPath);1495035625;Find the patterns matching the given lookup path. Invoking this method should_yield results equivalent to those of calling_{@link #getMatchingCondition(ServerWebExchange)}._This method is provided as an alternative to be used if no request is available_(e.g. introspection, tooling, etc)._@param lookupPath the lookup path to match to existing patterns_@return a collection of matching patterns sorted with the closest match at the top;public List<String> getMatchingPatterns(String lookupPath) {_		List<String> matches = new ArrayList<>()__		for (String pattern : this.patterns) {_			String match = getMatchingPattern(pattern, lookupPath)__			if (match != null) {_				matches.add(match)__			}_		}_		Collections.sort(matches, this.pathMatcher.getPatternComparator(lookupPath))__		return matches__	};find,the,patterns,matching,the,given,lookup,path,invoking,this,method,should,yield,results,equivalent,to,those,of,calling,link,get,matching,condition,server,web,exchange,this,method,is,provided,as,an,alternative,to,be,used,if,no,request,is,available,e,g,introspection,tooling,etc,param,lookup,path,the,lookup,path,to,match,to,existing,patterns,return,a,collection,of,matching,patterns,sorted,with,the,closest,match,at,the,top;public,list,string,get,matching,patterns,string,lookup,path,list,string,matches,new,array,list,for,string,pattern,this,patterns,string,match,get,matching,pattern,pattern,lookup,path,if,match,null,matches,add,match,collections,sort,matches,this,path,matcher,get,pattern,comparator,lookup,path,return,matches
PatternsRequestCondition -> public List<String> getMatchingPatterns(String lookupPath);1497039338;Find the patterns matching the given lookup path. Invoking this method should_yield results equivalent to those of calling_{@link #getMatchingCondition(ServerWebExchange)}._This method is provided as an alternative to be used if no request is available_(e.g. introspection, tooling, etc)._@param lookupPath the lookup path to match to existing patterns_@return a collection of matching patterns sorted with the closest match at the top;public List<String> getMatchingPatterns(String lookupPath) {_		List<String> matches = new ArrayList<>()__		for (String pattern : this.patterns) {_			String match = getMatchingPattern(pattern, lookupPath)__			if (match != null) {_				matches.add(match)__			}_		}_		Collections.sort(matches, this.pathMatcher.getPatternComparator(lookupPath))__		return matches__	};find,the,patterns,matching,the,given,lookup,path,invoking,this,method,should,yield,results,equivalent,to,those,of,calling,link,get,matching,condition,server,web,exchange,this,method,is,provided,as,an,alternative,to,be,used,if,no,request,is,available,e,g,introspection,tooling,etc,param,lookup,path,the,lookup,path,to,match,to,existing,patterns,return,a,collection,of,matching,patterns,sorted,with,the,closest,match,at,the,top;public,list,string,get,matching,patterns,string,lookup,path,list,string,matches,new,array,list,for,string,pattern,this,patterns,string,match,get,matching,pattern,pattern,lookup,path,if,match,null,matches,add,match,collections,sort,matches,this,path,matcher,get,pattern,comparator,lookup,path,return,matches
PatternsRequestCondition -> public List<String> getMatchingPatterns(String lookupPath);1497232764;Find the patterns matching the given lookup path. Invoking this method should_yield results equivalent to those of calling_{@link #getMatchingCondition(ServerWebExchange)}._This method is provided as an alternative to be used if no request is available_(e.g. introspection, tooling, etc)._@param lookupPath the lookup path to match to existing patterns_@return a collection of matching patterns sorted with the closest match at the top;public List<String> getMatchingPatterns(String lookupPath) {_		List<String> matches = new ArrayList<>()__		for (String pattern : this.patterns) {_			String match = getMatchingPattern(pattern, lookupPath)__			if (match != null) {_				matches.add(match)__			}_		}_		Collections.sort(matches, this.pathMatcher.getPatternComparator(lookupPath))__		return matches__	};find,the,patterns,matching,the,given,lookup,path,invoking,this,method,should,yield,results,equivalent,to,those,of,calling,link,get,matching,condition,server,web,exchange,this,method,is,provided,as,an,alternative,to,be,used,if,no,request,is,available,e,g,introspection,tooling,etc,param,lookup,path,the,lookup,path,to,match,to,existing,patterns,return,a,collection,of,matching,patterns,sorted,with,the,closest,match,at,the,top;public,list,string,get,matching,patterns,string,lookup,path,list,string,matches,new,array,list,for,string,pattern,this,patterns,string,match,get,matching,pattern,pattern,lookup,path,if,match,null,matches,add,match,collections,sort,matches,this,path,matcher,get,pattern,comparator,lookup,path,return,matches
PatternsRequestCondition -> @Override 	public PatternsRequestCondition getMatchingCondition(ServerWebExchange exchange);1485986572;Checks if any of the patterns match the given request and returns an instance_that is guaranteed to contain matching patterns, sorted via_{@link PathMatcher#getPatternComparator(String)}._<p>A matching pattern is obtained by making checks in the following order:_<ul>_<li>Direct match_<li>Pattern match with ".*" appended if the pattern doesn't already contain a "."_<li>Pattern match_<li>Pattern match with "/" appended if the pattern doesn't already end in "/"_</ul>_@param exchange the current exchange_@return the same instance if the condition contains no patterns__or a new condition with sorted matching patterns__or {@code null} if no patterns match.;@Override_	public PatternsRequestCondition getMatchingCondition(ServerWebExchange exchange) {_		if (this.patterns.isEmpty()) {_			return this__		}__		String lookupPath = this.pathHelper.getLookupPathForRequest(exchange)__		List<String> matches = getMatchingPatterns(lookupPath)___		return matches.isEmpty() ? null :_			new PatternsRequestCondition(matches, this.pathHelper, this.pathMatcher, this.useSuffixPatternMatch,_					this.useTrailingSlashMatch, this.fileExtensions)__	};checks,if,any,of,the,patterns,match,the,given,request,and,returns,an,instance,that,is,guaranteed,to,contain,matching,patterns,sorted,via,link,path,matcher,get,pattern,comparator,string,p,a,matching,pattern,is,obtained,by,making,checks,in,the,following,order,ul,li,direct,match,li,pattern,match,with,appended,if,the,pattern,doesn,t,already,contain,a,li,pattern,match,li,pattern,match,with,appended,if,the,pattern,doesn,t,already,end,in,ul,param,exchange,the,current,exchange,return,the,same,instance,if,the,condition,contains,no,patterns,or,a,new,condition,with,sorted,matching,patterns,or,code,null,if,no,patterns,match;override,public,patterns,request,condition,get,matching,condition,server,web,exchange,exchange,if,this,patterns,is,empty,return,this,string,lookup,path,this,path,helper,get,lookup,path,for,request,exchange,list,string,matches,get,matching,patterns,lookup,path,return,matches,is,empty,null,new,patterns,request,condition,matches,this,path,helper,this,path,matcher,this,use,suffix,pattern,match,this,use,trailing,slash,match,this,file,extensions
PatternsRequestCondition -> @Override 	public PatternsRequestCondition getMatchingCondition(ServerWebExchange exchange);1486634978;Checks if any of the patterns match the given request and returns an instance_that is guaranteed to contain matching patterns, sorted via_{@link PathMatcher#getPatternComparator(String)}._<p>A matching pattern is obtained by making checks in the following order:_<ul>_<li>Direct match_<li>Pattern match with ".*" appended if the pattern doesn't already contain a "."_<li>Pattern match_<li>Pattern match with "/" appended if the pattern doesn't already end in "/"_</ul>_@param exchange the current exchange_@return the same instance if the condition contains no patterns__or a new condition with sorted matching patterns__or {@code null} if no patterns match.;@Override_	public PatternsRequestCondition getMatchingCondition(ServerWebExchange exchange) {_		if (this.patterns.isEmpty()) {_			return this__		}__		String lookupPath = this.pathHelper.getLookupPathForRequest(exchange)__		List<String> matches = getMatchingPatterns(lookupPath)___		return matches.isEmpty() ? null :_			new PatternsRequestCondition(matches, this.pathHelper, this.pathMatcher, this.useSuffixPatternMatch,_					this.useTrailingSlashMatch, this.fileExtensions)__	};checks,if,any,of,the,patterns,match,the,given,request,and,returns,an,instance,that,is,guaranteed,to,contain,matching,patterns,sorted,via,link,path,matcher,get,pattern,comparator,string,p,a,matching,pattern,is,obtained,by,making,checks,in,the,following,order,ul,li,direct,match,li,pattern,match,with,appended,if,the,pattern,doesn,t,already,contain,a,li,pattern,match,li,pattern,match,with,appended,if,the,pattern,doesn,t,already,end,in,ul,param,exchange,the,current,exchange,return,the,same,instance,if,the,condition,contains,no,patterns,or,a,new,condition,with,sorted,matching,patterns,or,code,null,if,no,patterns,match;override,public,patterns,request,condition,get,matching,condition,server,web,exchange,exchange,if,this,patterns,is,empty,return,this,string,lookup,path,this,path,helper,get,lookup,path,for,request,exchange,list,string,matches,get,matching,patterns,lookup,path,return,matches,is,empty,null,new,patterns,request,condition,matches,this,path,helper,this,path,matcher,this,use,suffix,pattern,match,this,use,trailing,slash,match,this,file,extensions
PatternsRequestCondition -> @Override 	public PatternsRequestCondition getMatchingCondition(ServerWebExchange exchange);1486635693;Checks if any of the patterns match the given request and returns an instance_that is guaranteed to contain matching patterns, sorted via_{@link PathMatcher#getPatternComparator(String)}._<p>A matching pattern is obtained by making checks in the following order:_<ul>_<li>Direct match_<li>Pattern match with ".*" appended if the pattern doesn't already contain a "."_<li>Pattern match_<li>Pattern match with "/" appended if the pattern doesn't already end in "/"_</ul>_@param exchange the current exchange_@return the same instance if the condition contains no patterns__or a new condition with sorted matching patterns__or {@code null} if no patterns match.;@Override_	public PatternsRequestCondition getMatchingCondition(ServerWebExchange exchange) {_		if (this.patternRegistry.getPatterns().isEmpty()) {_			return this__		}__		String lookupPath = this.pathHelper.getLookupPathForRequest(exchange)__		SortedSet<PathPattern> matches = getMatchingPatterns(lookupPath)___		if(!matches.isEmpty()) {_			PathPatternRegistry registry = new PathPatternRegistry()__			registry.addAll(matches)__			return new PatternsRequestCondition(registry, this.pathHelper)__		}_		return null__	};checks,if,any,of,the,patterns,match,the,given,request,and,returns,an,instance,that,is,guaranteed,to,contain,matching,patterns,sorted,via,link,path,matcher,get,pattern,comparator,string,p,a,matching,pattern,is,obtained,by,making,checks,in,the,following,order,ul,li,direct,match,li,pattern,match,with,appended,if,the,pattern,doesn,t,already,contain,a,li,pattern,match,li,pattern,match,with,appended,if,the,pattern,doesn,t,already,end,in,ul,param,exchange,the,current,exchange,return,the,same,instance,if,the,condition,contains,no,patterns,or,a,new,condition,with,sorted,matching,patterns,or,code,null,if,no,patterns,match;override,public,patterns,request,condition,get,matching,condition,server,web,exchange,exchange,if,this,pattern,registry,get,patterns,is,empty,return,this,string,lookup,path,this,path,helper,get,lookup,path,for,request,exchange,sorted,set,path,pattern,matches,get,matching,patterns,lookup,path,if,matches,is,empty,path,pattern,registry,registry,new,path,pattern,registry,registry,add,all,matches,return,new,patterns,request,condition,registry,this,path,helper,return,null
PatternsRequestCondition -> @Override 	public PatternsRequestCondition getMatchingCondition(ServerWebExchange exchange);1486652296;Checks if any of the patterns match the given request and returns an instance_that is guaranteed to contain matching patterns, sorted via_{@link PathMatcher#getPatternComparator(String)}._<p>A matching pattern is obtained by making checks in the following order:_<ul>_<li>Direct match_<li>Pattern match with ".*" appended if the pattern doesn't already contain a "."_<li>Pattern match_<li>Pattern match with "/" appended if the pattern doesn't already end in "/"_</ul>_@param exchange the current exchange_@return the same instance if the condition contains no patterns__or a new condition with sorted matching patterns__or {@code null} if no patterns match.;@Override_	public PatternsRequestCondition getMatchingCondition(ServerWebExchange exchange) {_		if (this.patternRegistry.getPatterns().isEmpty()) {_			return this__		}__		String lookupPath = this.pathHelper.getLookupPathForRequest(exchange)__		SortedSet<PathPattern> matches = getMatchingPatterns(lookupPath)___		if(!matches.isEmpty()) {_			PathPatternRegistry registry = new PathPatternRegistry()__			registry.addAll(matches)__			return new PatternsRequestCondition(registry, this.pathHelper)__		}_		return null__	};checks,if,any,of,the,patterns,match,the,given,request,and,returns,an,instance,that,is,guaranteed,to,contain,matching,patterns,sorted,via,link,path,matcher,get,pattern,comparator,string,p,a,matching,pattern,is,obtained,by,making,checks,in,the,following,order,ul,li,direct,match,li,pattern,match,with,appended,if,the,pattern,doesn,t,already,contain,a,li,pattern,match,li,pattern,match,with,appended,if,the,pattern,doesn,t,already,end,in,ul,param,exchange,the,current,exchange,return,the,same,instance,if,the,condition,contains,no,patterns,or,a,new,condition,with,sorted,matching,patterns,or,code,null,if,no,patterns,match;override,public,patterns,request,condition,get,matching,condition,server,web,exchange,exchange,if,this,pattern,registry,get,patterns,is,empty,return,this,string,lookup,path,this,path,helper,get,lookup,path,for,request,exchange,sorted,set,path,pattern,matches,get,matching,patterns,lookup,path,if,matches,is,empty,path,pattern,registry,registry,new,path,pattern,registry,registry,add,all,matches,return,new,patterns,request,condition,registry,this,path,helper,return,null
PatternsRequestCondition -> @Override 	public PatternsRequestCondition getMatchingCondition(ServerWebExchange exchange);1486674586;Checks if any of the patterns match the given request and returns an instance_that is guaranteed to contain matching patterns, sorted via_{@link PathMatcher#getPatternComparator(String)}._<p>A matching pattern is obtained by making checks in the following order:_<ul>_<li>Direct match_<li>Pattern match with ".*" appended if the pattern doesn't already contain a "."_<li>Pattern match_<li>Pattern match with "/" appended if the pattern doesn't already end in "/"_</ul>_@param exchange the current exchange_@return the same instance if the condition contains no patterns__or a new condition with sorted matching patterns__or {@code null} if no patterns match.;@Override_	public PatternsRequestCondition getMatchingCondition(ServerWebExchange exchange) {_		if (this.patternRegistry.getPatterns().isEmpty()) {_			return this__		}__		String lookupPath = this.pathHelper.getLookupPathForRequest(exchange)__		SortedSet<PathPattern> matches = getMatchingPatterns(lookupPath)___		if(!matches.isEmpty()) {_			PathPatternRegistry registry = new PathPatternRegistry(matches)__			return new PatternsRequestCondition(registry, this.pathHelper)__		}_		return null__	};checks,if,any,of,the,patterns,match,the,given,request,and,returns,an,instance,that,is,guaranteed,to,contain,matching,patterns,sorted,via,link,path,matcher,get,pattern,comparator,string,p,a,matching,pattern,is,obtained,by,making,checks,in,the,following,order,ul,li,direct,match,li,pattern,match,with,appended,if,the,pattern,doesn,t,already,contain,a,li,pattern,match,li,pattern,match,with,appended,if,the,pattern,doesn,t,already,end,in,ul,param,exchange,the,current,exchange,return,the,same,instance,if,the,condition,contains,no,patterns,or,a,new,condition,with,sorted,matching,patterns,or,code,null,if,no,patterns,match;override,public,patterns,request,condition,get,matching,condition,server,web,exchange,exchange,if,this,pattern,registry,get,patterns,is,empty,return,this,string,lookup,path,this,path,helper,get,lookup,path,for,request,exchange,sorted,set,path,pattern,matches,get,matching,patterns,lookup,path,if,matches,is,empty,path,pattern,registry,registry,new,path,pattern,registry,matches,return,new,patterns,request,condition,registry,this,path,helper,return,null
PatternsRequestCondition -> @Override 	public PatternsRequestCondition getMatchingCondition(ServerWebExchange exchange);1486747801;Checks if any of the patterns match the given request and returns an instance_that is guaranteed to contain matching patterns, sorted via_{@link PathMatcher#getPatternComparator(String)}._<p>A matching pattern is obtained by making checks in the following order:_<ul>_<li>Direct match_<li>Pattern match with ".*" appended if the pattern doesn't already contain a "."_<li>Pattern match_<li>Pattern match with "/" appended if the pattern doesn't already end in "/"_</ul>_@param exchange the current exchange_@return the same instance if the condition contains no patterns__or a new condition with sorted matching patterns__or {@code null} if no patterns match.;@Override_	public PatternsRequestCondition getMatchingCondition(ServerWebExchange exchange) {_		if (this.patterns.isEmpty()) {_			return this__		}__		String lookupPath = this.pathHelper.getLookupPathForRequest(exchange)__		List<String> matches = getMatchingPatterns(lookupPath)___		return matches.isEmpty() ? null :_			new PatternsRequestCondition(matches, this.pathHelper, this.pathMatcher, this.useSuffixPatternMatch,_					this.useTrailingSlashMatch, this.fileExtensions)__	};checks,if,any,of,the,patterns,match,the,given,request,and,returns,an,instance,that,is,guaranteed,to,contain,matching,patterns,sorted,via,link,path,matcher,get,pattern,comparator,string,p,a,matching,pattern,is,obtained,by,making,checks,in,the,following,order,ul,li,direct,match,li,pattern,match,with,appended,if,the,pattern,doesn,t,already,contain,a,li,pattern,match,li,pattern,match,with,appended,if,the,pattern,doesn,t,already,end,in,ul,param,exchange,the,current,exchange,return,the,same,instance,if,the,condition,contains,no,patterns,or,a,new,condition,with,sorted,matching,patterns,or,code,null,if,no,patterns,match;override,public,patterns,request,condition,get,matching,condition,server,web,exchange,exchange,if,this,patterns,is,empty,return,this,string,lookup,path,this,path,helper,get,lookup,path,for,request,exchange,list,string,matches,get,matching,patterns,lookup,path,return,matches,is,empty,null,new,patterns,request,condition,matches,this,path,helper,this,path,matcher,this,use,suffix,pattern,match,this,use,trailing,slash,match,this,file,extensions
PatternsRequestCondition -> @Override 	public PatternsRequestCondition getMatchingCondition(ServerWebExchange exchange);1495035625;Checks if any of the patterns match the given request and returns an instance_that is guaranteed to contain matching patterns, sorted via_{@link PathMatcher#getPatternComparator(String)}._<p>A matching pattern is obtained by making checks in the following order:_<ul>_<li>Direct match_<li>Pattern match with ".*" appended if the pattern doesn't already contain a "."_<li>Pattern match_<li>Pattern match with "/" appended if the pattern doesn't already end in "/"_</ul>_@param exchange the current exchange_@return the same instance if the condition contains no patterns__or a new condition with sorted matching patterns__or {@code null} if no patterns match.;@Override_	public PatternsRequestCondition getMatchingCondition(ServerWebExchange exchange) {_		if (this.patterns.isEmpty()) {_			return this__		}__		String lookupPath = this.pathHelper.getLookupPathForRequest(exchange)__		List<String> matches = getMatchingPatterns(lookupPath)___		return matches.isEmpty() ? null :_			new PatternsRequestCondition(matches, this.pathHelper, this.pathMatcher, this.useSuffixPatternMatch,_					this.useTrailingSlashMatch, this.fileExtensions)__	};checks,if,any,of,the,patterns,match,the,given,request,and,returns,an,instance,that,is,guaranteed,to,contain,matching,patterns,sorted,via,link,path,matcher,get,pattern,comparator,string,p,a,matching,pattern,is,obtained,by,making,checks,in,the,following,order,ul,li,direct,match,li,pattern,match,with,appended,if,the,pattern,doesn,t,already,contain,a,li,pattern,match,li,pattern,match,with,appended,if,the,pattern,doesn,t,already,end,in,ul,param,exchange,the,current,exchange,return,the,same,instance,if,the,condition,contains,no,patterns,or,a,new,condition,with,sorted,matching,patterns,or,code,null,if,no,patterns,match;override,public,patterns,request,condition,get,matching,condition,server,web,exchange,exchange,if,this,patterns,is,empty,return,this,string,lookup,path,this,path,helper,get,lookup,path,for,request,exchange,list,string,matches,get,matching,patterns,lookup,path,return,matches,is,empty,null,new,patterns,request,condition,matches,this,path,helper,this,path,matcher,this,use,suffix,pattern,match,this,use,trailing,slash,match,this,file,extensions
PatternsRequestCondition -> @Override 	public PatternsRequestCondition getMatchingCondition(ServerWebExchange exchange);1496334664;Checks if any of the patterns match the given request and returns an instance_that is guaranteed to contain matching patterns, sorted via_{@link PathMatcher#getPatternComparator(String)}._<p>A matching pattern is obtained by making checks in the following order:_<ul>_<li>Direct match_<li>Pattern match with ".*" appended if the pattern doesn't already contain a "."_<li>Pattern match_<li>Pattern match with "/" appended if the pattern doesn't already end in "/"_</ul>_@param exchange the current exchange_@return the same instance if the condition contains no patterns__or a new condition with sorted matching patterns__or {@code null} if no patterns match.;@Override_	public PatternsRequestCondition getMatchingCondition(ServerWebExchange exchange) {_		if (this.patterns.isEmpty()) {_			return this__		}__		LookupPath lookupPath = exchange_				.<LookupPath>getAttribute(LookupPath.LOOKUP_PATH_ATTRIBUTE).get()__		List<String> matches = getMatchingPatterns(lookupPath)___		return matches.isEmpty() ? null :_				new PatternsRequestCondition(matches, this.pathMatcher, this.useSuffixPatternMatch,_						this.useTrailingSlashMatch, this.fileExtensions)__	};checks,if,any,of,the,patterns,match,the,given,request,and,returns,an,instance,that,is,guaranteed,to,contain,matching,patterns,sorted,via,link,path,matcher,get,pattern,comparator,string,p,a,matching,pattern,is,obtained,by,making,checks,in,the,following,order,ul,li,direct,match,li,pattern,match,with,appended,if,the,pattern,doesn,t,already,contain,a,li,pattern,match,li,pattern,match,with,appended,if,the,pattern,doesn,t,already,end,in,ul,param,exchange,the,current,exchange,return,the,same,instance,if,the,condition,contains,no,patterns,or,a,new,condition,with,sorted,matching,patterns,or,code,null,if,no,patterns,match;override,public,patterns,request,condition,get,matching,condition,server,web,exchange,exchange,if,this,patterns,is,empty,return,this,lookup,path,lookup,path,exchange,lookup,path,get,attribute,lookup,path,get,list,string,matches,get,matching,patterns,lookup,path,return,matches,is,empty,null,new,patterns,request,condition,matches,this,path,matcher,this,use,suffix,pattern,match,this,use,trailing,slash,match,this,file,extensions
PatternsRequestCondition -> @Override 	public PatternsRequestCondition getMatchingCondition(ServerWebExchange exchange);1496429194;Checks if any of the patterns match the given request and returns an instance_that is guaranteed to contain matching patterns, sorted via_{@link PathMatcher#getPatternComparator(String)}._<p>A matching pattern is obtained by making checks in the following order:_<ul>_<li>Direct match_<li>Pattern match with ".*" appended if the pattern doesn't already contain a "."_<li>Pattern match_<li>Pattern match with "/" appended if the pattern doesn't already end in "/"_</ul>_@param exchange the current exchange_@return the same instance if the condition contains no patterns__or a new condition with sorted matching patterns__or {@code null} if no patterns match.;@Override_	public PatternsRequestCondition getMatchingCondition(ServerWebExchange exchange) {_		if (this.patterns.isEmpty()) {_			return this__		}__		LookupPath lookupPath = getLookupPath(exchange)__		List<String> matches = getMatchingPatterns(lookupPath)___		return matches.isEmpty() ? null :_				new PatternsRequestCondition(matches, this.pathMatcher, this.useSuffixPatternMatch,_						this.useTrailingSlashMatch, this.fileExtensions)__	};checks,if,any,of,the,patterns,match,the,given,request,and,returns,an,instance,that,is,guaranteed,to,contain,matching,patterns,sorted,via,link,path,matcher,get,pattern,comparator,string,p,a,matching,pattern,is,obtained,by,making,checks,in,the,following,order,ul,li,direct,match,li,pattern,match,with,appended,if,the,pattern,doesn,t,already,contain,a,li,pattern,match,li,pattern,match,with,appended,if,the,pattern,doesn,t,already,end,in,ul,param,exchange,the,current,exchange,return,the,same,instance,if,the,condition,contains,no,patterns,or,a,new,condition,with,sorted,matching,patterns,or,code,null,if,no,patterns,match;override,public,patterns,request,condition,get,matching,condition,server,web,exchange,exchange,if,this,patterns,is,empty,return,this,lookup,path,lookup,path,get,lookup,path,exchange,list,string,matches,get,matching,patterns,lookup,path,return,matches,is,empty,null,new,patterns,request,condition,matches,this,path,matcher,this,use,suffix,pattern,match,this,use,trailing,slash,match,this,file,extensions
PatternsRequestCondition -> @Override 	public PatternsRequestCondition getMatchingCondition(ServerWebExchange exchange);1496430942;Checks if any of the patterns match the given request and returns an instance_that is guaranteed to contain matching patterns, sorted via_{@link PathMatcher#getPatternComparator(String)}._<p>A matching pattern is obtained by making checks in the following order:_<ul>_<li>Direct match_<li>Pattern match with ".*" appended if the pattern doesn't already contain a "."_<li>Pattern match_<li>Pattern match with "/" appended if the pattern doesn't already end in "/"_</ul>_@param exchange the current exchange_@return the same instance if the condition contains no patterns__or a new condition with sorted matching patterns__or {@code null} if no patterns match.;@Override_	public PatternsRequestCondition getMatchingCondition(ServerWebExchange exchange) {_		if (this.patterns.isEmpty()) {_			return this__		}__		LookupPath lookupPath = LookupPath.getCurrent(exchange)__		List<String> matches = getMatchingPatterns(lookupPath)___		return matches.isEmpty() ? null :_				new PatternsRequestCondition(matches, this.pathMatcher, this.useSuffixPatternMatch,_						this.useTrailingSlashMatch, this.fileExtensions)__	};checks,if,any,of,the,patterns,match,the,given,request,and,returns,an,instance,that,is,guaranteed,to,contain,matching,patterns,sorted,via,link,path,matcher,get,pattern,comparator,string,p,a,matching,pattern,is,obtained,by,making,checks,in,the,following,order,ul,li,direct,match,li,pattern,match,with,appended,if,the,pattern,doesn,t,already,contain,a,li,pattern,match,li,pattern,match,with,appended,if,the,pattern,doesn,t,already,end,in,ul,param,exchange,the,current,exchange,return,the,same,instance,if,the,condition,contains,no,patterns,or,a,new,condition,with,sorted,matching,patterns,or,code,null,if,no,patterns,match;override,public,patterns,request,condition,get,matching,condition,server,web,exchange,exchange,if,this,patterns,is,empty,return,this,lookup,path,lookup,path,lookup,path,get,current,exchange,list,string,matches,get,matching,patterns,lookup,path,return,matches,is,empty,null,new,patterns,request,condition,matches,this,path,matcher,this,use,suffix,pattern,match,this,use,trailing,slash,match,this,file,extensions
PatternsRequestCondition -> @Override 	public PatternsRequestCondition getMatchingCondition(ServerWebExchange exchange);1497039338;Checks if any of the patterns match the given request and returns an instance_that is guaranteed to contain matching patterns, sorted via_{@link PathMatcher#getPatternComparator(String)}._<p>A matching pattern is obtained by making checks in the following order:_<ul>_<li>Direct match_<li>Pattern match with ".*" appended if the pattern doesn't already contain a "."_<li>Pattern match_<li>Pattern match with "/" appended if the pattern doesn't already end in "/"_</ul>_@param exchange the current exchange_@return the same instance if the condition contains no patterns__or a new condition with sorted matching patterns__or {@code null} if no patterns match.;@Override_	public PatternsRequestCondition getMatchingCondition(ServerWebExchange exchange) {_		if (this.patterns.isEmpty()) {_			return this__		}__		String lookupPath = exchange.getRequest().getPathWithinApplication()__		List<String> matches = getMatchingPatterns(lookupPath)___		return matches.isEmpty() ? null :_				new PatternsRequestCondition(matches, this.pathMatcher, this.useSuffixPatternMatch,_						this.useTrailingSlashMatch, this.fileExtensions)__	};checks,if,any,of,the,patterns,match,the,given,request,and,returns,an,instance,that,is,guaranteed,to,contain,matching,patterns,sorted,via,link,path,matcher,get,pattern,comparator,string,p,a,matching,pattern,is,obtained,by,making,checks,in,the,following,order,ul,li,direct,match,li,pattern,match,with,appended,if,the,pattern,doesn,t,already,contain,a,li,pattern,match,li,pattern,match,with,appended,if,the,pattern,doesn,t,already,end,in,ul,param,exchange,the,current,exchange,return,the,same,instance,if,the,condition,contains,no,patterns,or,a,new,condition,with,sorted,matching,patterns,or,code,null,if,no,patterns,match;override,public,patterns,request,condition,get,matching,condition,server,web,exchange,exchange,if,this,patterns,is,empty,return,this,string,lookup,path,exchange,get,request,get,path,within,application,list,string,matches,get,matching,patterns,lookup,path,return,matches,is,empty,null,new,patterns,request,condition,matches,this,path,matcher,this,use,suffix,pattern,match,this,use,trailing,slash,match,this,file,extensions
PatternsRequestCondition -> @Override 	public PatternsRequestCondition getMatchingCondition(ServerWebExchange exchange);1497232764;Checks if any of the patterns match the given request and returns an instance_that is guaranteed to contain matching patterns, sorted via_{@link PathMatcher#getPatternComparator(String)}._<p>A matching pattern is obtained by making checks in the following order:_<ul>_<li>Direct match_<li>Pattern match with ".*" appended if the pattern doesn't already contain a "."_<li>Pattern match_<li>Pattern match with "/" appended if the pattern doesn't already end in "/"_</ul>_@param exchange the current exchange_@return the same instance if the condition contains no patterns__or a new condition with sorted matching patterns__or {@code null} if no patterns match.;@Override_	public PatternsRequestCondition getMatchingCondition(ServerWebExchange exchange) {_		if (this.patterns.isEmpty()) {_			return this__		}__		String lookupPath = exchange.getRequest().getPath().pathWithinApplication().value()__		List<String> matches = getMatchingPatterns(lookupPath)___		return matches.isEmpty() ? null :_				new PatternsRequestCondition(matches, this.pathMatcher, this.useSuffixPatternMatch,_						this.useTrailingSlashMatch, this.fileExtensions)__	};checks,if,any,of,the,patterns,match,the,given,request,and,returns,an,instance,that,is,guaranteed,to,contain,matching,patterns,sorted,via,link,path,matcher,get,pattern,comparator,string,p,a,matching,pattern,is,obtained,by,making,checks,in,the,following,order,ul,li,direct,match,li,pattern,match,with,appended,if,the,pattern,doesn,t,already,contain,a,li,pattern,match,li,pattern,match,with,appended,if,the,pattern,doesn,t,already,end,in,ul,param,exchange,the,current,exchange,return,the,same,instance,if,the,condition,contains,no,patterns,or,a,new,condition,with,sorted,matching,patterns,or,code,null,if,no,patterns,match;override,public,patterns,request,condition,get,matching,condition,server,web,exchange,exchange,if,this,patterns,is,empty,return,this,string,lookup,path,exchange,get,request,get,path,path,within,application,value,list,string,matches,get,matching,patterns,lookup,path,return,matches,is,empty,null,new,patterns,request,condition,matches,this,path,matcher,this,use,suffix,pattern,match,this,use,trailing,slash,match,this,file,extensions
PatternsRequestCondition -> @Override 	public PatternsRequestCondition combine(PatternsRequestCondition other);1485986572;Returns a new instance with URL patterns from the current instance ("this") and_the "other" instance as follows:_<ul>_<li>If there are patterns in both instances, combine the patterns in "this" with_the patterns in "other" using {@link PathMatcher#combine(String, String)}._<li>If only one instance has patterns, use them._<li>If neither instance has patterns, use an empty String (i.e. "")._</ul>;@Override_	public PatternsRequestCondition combine(PatternsRequestCondition other) {_		Set<String> result = new LinkedHashSet<>()__		if (!this.patterns.isEmpty() && !other.patterns.isEmpty()) {_			for (String pattern1 : this.patterns) {_				for (String pattern2 : other.patterns) {_					result.add(this.pathMatcher.combine(pattern1, pattern2))__				}_			}_		}_		else if (!this.patterns.isEmpty()) {_			result.addAll(this.patterns)__		}_		else if (!other.patterns.isEmpty()) {_			result.addAll(other.patterns)__		}_		else {_			result.add("")__		}_		return new PatternsRequestCondition(result, this.pathHelper, this.pathMatcher, this.useSuffixPatternMatch,_				this.useTrailingSlashMatch, this.fileExtensions)__	};returns,a,new,instance,with,url,patterns,from,the,current,instance,this,and,the,other,instance,as,follows,ul,li,if,there,are,patterns,in,both,instances,combine,the,patterns,in,this,with,the,patterns,in,other,using,link,path,matcher,combine,string,string,li,if,only,one,instance,has,patterns,use,them,li,if,neither,instance,has,patterns,use,an,empty,string,i,e,ul;override,public,patterns,request,condition,combine,patterns,request,condition,other,set,string,result,new,linked,hash,set,if,this,patterns,is,empty,other,patterns,is,empty,for,string,pattern1,this,patterns,for,string,pattern2,other,patterns,result,add,this,path,matcher,combine,pattern1,pattern2,else,if,this,patterns,is,empty,result,add,all,this,patterns,else,if,other,patterns,is,empty,result,add,all,other,patterns,else,result,add,return,new,patterns,request,condition,result,this,path,helper,this,path,matcher,this,use,suffix,pattern,match,this,use,trailing,slash,match,this,file,extensions
PatternsRequestCondition -> @Override 	public PatternsRequestCondition combine(PatternsRequestCondition other);1486634978;Returns a new instance with URL patterns from the current instance ("this") and_the "other" instance as follows:_<ul>_<li>If there are patterns in both instances, combine the patterns in "this" with_the patterns in "other" using {@link PathMatcher#combine(String, String)}._<li>If only one instance has patterns, use them._<li>If neither instance has patterns, use an empty String (i.e. "")._</ul>;@Override_	public PatternsRequestCondition combine(PatternsRequestCondition other) {_		Set<String> result = new LinkedHashSet<>()__		if (!this.patterns.isEmpty() && !other.patterns.isEmpty()) {_			for (String pattern1 : this.patterns) {_				for (String pattern2 : other.patterns) {_					result.add(this.pathMatcher.combine(pattern1, pattern2))__				}_			}_		}_		else if (!this.patterns.isEmpty()) {_			result.addAll(this.patterns)__		}_		else if (!other.patterns.isEmpty()) {_			result.addAll(other.patterns)__		}_		else {_			result.add("")__		}_		return new PatternsRequestCondition(result, this.pathHelper, this.pathMatcher, this.useSuffixPatternMatch,_				this.useTrailingSlashMatch, this.fileExtensions)__	};returns,a,new,instance,with,url,patterns,from,the,current,instance,this,and,the,other,instance,as,follows,ul,li,if,there,are,patterns,in,both,instances,combine,the,patterns,in,this,with,the,patterns,in,other,using,link,path,matcher,combine,string,string,li,if,only,one,instance,has,patterns,use,them,li,if,neither,instance,has,patterns,use,an,empty,string,i,e,ul;override,public,patterns,request,condition,combine,patterns,request,condition,other,set,string,result,new,linked,hash,set,if,this,patterns,is,empty,other,patterns,is,empty,for,string,pattern1,this,patterns,for,string,pattern2,other,patterns,result,add,this,path,matcher,combine,pattern1,pattern2,else,if,this,patterns,is,empty,result,add,all,this,patterns,else,if,other,patterns,is,empty,result,add,all,other,patterns,else,result,add,return,new,patterns,request,condition,result,this,path,helper,this,path,matcher,this,use,suffix,pattern,match,this,use,trailing,slash,match,this,file,extensions
PatternsRequestCondition -> @Override 	public PatternsRequestCondition combine(PatternsRequestCondition other);1486635693;Returns a new instance with URL patterns from the current instance ("this") and_the "other" instance as follows:_<ul>_<li>If there are patterns in both instances, combine the patterns in "this" with_the patterns in "other" using {@link PathMatcher#combine(String, String)}._<li>If only one instance has patterns, use them._<li>If neither instance has patterns, use an empty String (i.e. "")._</ul>;@Override_	public PatternsRequestCondition combine(PatternsRequestCondition other) {_		return new PatternsRequestCondition(this.patternRegistry.combine(other.patternRegistry), this.pathHelper)__	};returns,a,new,instance,with,url,patterns,from,the,current,instance,this,and,the,other,instance,as,follows,ul,li,if,there,are,patterns,in,both,instances,combine,the,patterns,in,this,with,the,patterns,in,other,using,link,path,matcher,combine,string,string,li,if,only,one,instance,has,patterns,use,them,li,if,neither,instance,has,patterns,use,an,empty,string,i,e,ul;override,public,patterns,request,condition,combine,patterns,request,condition,other,return,new,patterns,request,condition,this,pattern,registry,combine,other,pattern,registry,this,path,helper
PatternsRequestCondition -> @Override 	public PatternsRequestCondition combine(PatternsRequestCondition other);1486652296;Returns a new instance with URL patterns from the current instance ("this") and_the "other" instance as follows:_<ul>_<li>If there are patterns in both instances, combine the patterns in "this" with_the patterns in "other" using {@link PathMatcher#combine(String, String)}._<li>If only one instance has patterns, use them._<li>If neither instance has patterns, use an empty String (i.e. "")._</ul>;@Override_	public PatternsRequestCondition combine(PatternsRequestCondition other) {_		return new PatternsRequestCondition(this.patternRegistry.combine(other.patternRegistry), this.pathHelper)__	};returns,a,new,instance,with,url,patterns,from,the,current,instance,this,and,the,other,instance,as,follows,ul,li,if,there,are,patterns,in,both,instances,combine,the,patterns,in,this,with,the,patterns,in,other,using,link,path,matcher,combine,string,string,li,if,only,one,instance,has,patterns,use,them,li,if,neither,instance,has,patterns,use,an,empty,string,i,e,ul;override,public,patterns,request,condition,combine,patterns,request,condition,other,return,new,patterns,request,condition,this,pattern,registry,combine,other,pattern,registry,this,path,helper
PatternsRequestCondition -> @Override 	public PatternsRequestCondition combine(PatternsRequestCondition other);1486674586;Returns a new instance with URL patterns from the current instance ("this") and_the "other" instance as follows:_<ul>_<li>If there are patterns in both instances, combine the patterns in "this" with_the patterns in "other" using {@link PathMatcher#combine(String, String)}._<li>If only one instance has patterns, use them._<li>If neither instance has patterns, use an empty String (i.e. "")._</ul>;@Override_	public PatternsRequestCondition combine(PatternsRequestCondition other) {_		return new PatternsRequestCondition(this.patternRegistry.combine(other.patternRegistry), this.pathHelper)__	};returns,a,new,instance,with,url,patterns,from,the,current,instance,this,and,the,other,instance,as,follows,ul,li,if,there,are,patterns,in,both,instances,combine,the,patterns,in,this,with,the,patterns,in,other,using,link,path,matcher,combine,string,string,li,if,only,one,instance,has,patterns,use,them,li,if,neither,instance,has,patterns,use,an,empty,string,i,e,ul;override,public,patterns,request,condition,combine,patterns,request,condition,other,return,new,patterns,request,condition,this,pattern,registry,combine,other,pattern,registry,this,path,helper
PatternsRequestCondition -> @Override 	public PatternsRequestCondition combine(PatternsRequestCondition other);1486747801;Returns a new instance with URL patterns from the current instance ("this") and_the "other" instance as follows:_<ul>_<li>If there are patterns in both instances, combine the patterns in "this" with_the patterns in "other" using {@link PathMatcher#combine(String, String)}._<li>If only one instance has patterns, use them._<li>If neither instance has patterns, use an empty String (i.e. "")._</ul>;@Override_	public PatternsRequestCondition combine(PatternsRequestCondition other) {_		Set<String> result = new LinkedHashSet<>()__		if (!this.patterns.isEmpty() && !other.patterns.isEmpty()) {_			for (String pattern1 : this.patterns) {_				for (String pattern2 : other.patterns) {_					result.add(this.pathMatcher.combine(pattern1, pattern2))__				}_			}_		}_		else if (!this.patterns.isEmpty()) {_			result.addAll(this.patterns)__		}_		else if (!other.patterns.isEmpty()) {_			result.addAll(other.patterns)__		}_		else {_			result.add("")__		}_		return new PatternsRequestCondition(result, this.pathHelper, this.pathMatcher, this.useSuffixPatternMatch,_				this.useTrailingSlashMatch, this.fileExtensions)__	};returns,a,new,instance,with,url,patterns,from,the,current,instance,this,and,the,other,instance,as,follows,ul,li,if,there,are,patterns,in,both,instances,combine,the,patterns,in,this,with,the,patterns,in,other,using,link,path,matcher,combine,string,string,li,if,only,one,instance,has,patterns,use,them,li,if,neither,instance,has,patterns,use,an,empty,string,i,e,ul;override,public,patterns,request,condition,combine,patterns,request,condition,other,set,string,result,new,linked,hash,set,if,this,patterns,is,empty,other,patterns,is,empty,for,string,pattern1,this,patterns,for,string,pattern2,other,patterns,result,add,this,path,matcher,combine,pattern1,pattern2,else,if,this,patterns,is,empty,result,add,all,this,patterns,else,if,other,patterns,is,empty,result,add,all,other,patterns,else,result,add,return,new,patterns,request,condition,result,this,path,helper,this,path,matcher,this,use,suffix,pattern,match,this,use,trailing,slash,match,this,file,extensions
PatternsRequestCondition -> @Override 	public PatternsRequestCondition combine(PatternsRequestCondition other);1495035625;Returns a new instance with URL patterns from the current instance ("this") and_the "other" instance as follows:_<ul>_<li>If there are patterns in both instances, combine the patterns in "this" with_the patterns in "other" using {@link PathMatcher#combine(String, String)}._<li>If only one instance has patterns, use them._<li>If neither instance has patterns, use an empty String (i.e. "")._</ul>;@Override_	public PatternsRequestCondition combine(PatternsRequestCondition other) {_		Set<String> result = new LinkedHashSet<>()__		if (!this.patterns.isEmpty() && !other.patterns.isEmpty()) {_			for (String pattern1 : this.patterns) {_				for (String pattern2 : other.patterns) {_					result.add(this.pathMatcher.combine(pattern1, pattern2))__				}_			}_		}_		else if (!this.patterns.isEmpty()) {_			result.addAll(this.patterns)__		}_		else if (!other.patterns.isEmpty()) {_			result.addAll(other.patterns)__		}_		else {_			result.add("")__		}_		return new PatternsRequestCondition(result, this.pathHelper, this.pathMatcher, this.useSuffixPatternMatch,_				this.useTrailingSlashMatch, this.fileExtensions)__	};returns,a,new,instance,with,url,patterns,from,the,current,instance,this,and,the,other,instance,as,follows,ul,li,if,there,are,patterns,in,both,instances,combine,the,patterns,in,this,with,the,patterns,in,other,using,link,path,matcher,combine,string,string,li,if,only,one,instance,has,patterns,use,them,li,if,neither,instance,has,patterns,use,an,empty,string,i,e,ul;override,public,patterns,request,condition,combine,patterns,request,condition,other,set,string,result,new,linked,hash,set,if,this,patterns,is,empty,other,patterns,is,empty,for,string,pattern1,this,patterns,for,string,pattern2,other,patterns,result,add,this,path,matcher,combine,pattern1,pattern2,else,if,this,patterns,is,empty,result,add,all,this,patterns,else,if,other,patterns,is,empty,result,add,all,other,patterns,else,result,add,return,new,patterns,request,condition,result,this,path,helper,this,path,matcher,this,use,suffix,pattern,match,this,use,trailing,slash,match,this,file,extensions
PatternsRequestCondition -> @Override 	public PatternsRequestCondition combine(PatternsRequestCondition other);1496334664;Returns a new instance with URL patterns from the current instance ("this") and_the "other" instance as follows:_<ul>_<li>If there are patterns in both instances, combine the patterns in "this" with_the patterns in "other" using {@link PathMatcher#combine(String, String)}._<li>If only one instance has patterns, use them._<li>If neither instance has patterns, use an empty String (i.e. "")._</ul>;@Override_	public PatternsRequestCondition combine(PatternsRequestCondition other) {_		Set<String> result = new LinkedHashSet<>()__		if (!this.patterns.isEmpty() && !other.patterns.isEmpty()) {_			for (String pattern1 : this.patterns) {_				for (String pattern2 : other.patterns) {_					result.add(this.pathMatcher.combine(pattern1, pattern2))__				}_			}_		}_		else if (!this.patterns.isEmpty()) {_			result.addAll(this.patterns)__		}_		else if (!other.patterns.isEmpty()) {_			result.addAll(other.patterns)__		}_		else {_			result.add("")__		}_		return new PatternsRequestCondition(result, this.pathMatcher, this.useSuffixPatternMatch,_				this.useTrailingSlashMatch, this.fileExtensions)__	};returns,a,new,instance,with,url,patterns,from,the,current,instance,this,and,the,other,instance,as,follows,ul,li,if,there,are,patterns,in,both,instances,combine,the,patterns,in,this,with,the,patterns,in,other,using,link,path,matcher,combine,string,string,li,if,only,one,instance,has,patterns,use,them,li,if,neither,instance,has,patterns,use,an,empty,string,i,e,ul;override,public,patterns,request,condition,combine,patterns,request,condition,other,set,string,result,new,linked,hash,set,if,this,patterns,is,empty,other,patterns,is,empty,for,string,pattern1,this,patterns,for,string,pattern2,other,patterns,result,add,this,path,matcher,combine,pattern1,pattern2,else,if,this,patterns,is,empty,result,add,all,this,patterns,else,if,other,patterns,is,empty,result,add,all,other,patterns,else,result,add,return,new,patterns,request,condition,result,this,path,matcher,this,use,suffix,pattern,match,this,use,trailing,slash,match,this,file,extensions
PatternsRequestCondition -> @Override 	public PatternsRequestCondition combine(PatternsRequestCondition other);1496429194;Returns a new instance with URL patterns from the current instance ("this") and_the "other" instance as follows:_<ul>_<li>If there are patterns in both instances, combine the patterns in "this" with_the patterns in "other" using {@link PathMatcher#combine(String, String)}._<li>If only one instance has patterns, use them._<li>If neither instance has patterns, use an empty String (i.e. "")._</ul>;@Override_	public PatternsRequestCondition combine(PatternsRequestCondition other) {_		Set<String> result = new LinkedHashSet<>()__		if (!this.patterns.isEmpty() && !other.patterns.isEmpty()) {_			for (String pattern1 : this.patterns) {_				for (String pattern2 : other.patterns) {_					result.add(this.pathMatcher.combine(pattern1, pattern2))__				}_			}_		}_		else if (!this.patterns.isEmpty()) {_			result.addAll(this.patterns)__		}_		else if (!other.patterns.isEmpty()) {_			result.addAll(other.patterns)__		}_		else {_			result.add("")__		}_		return new PatternsRequestCondition(result, this.pathMatcher, this.useSuffixPatternMatch,_				this.useTrailingSlashMatch, this.fileExtensions)__	};returns,a,new,instance,with,url,patterns,from,the,current,instance,this,and,the,other,instance,as,follows,ul,li,if,there,are,patterns,in,both,instances,combine,the,patterns,in,this,with,the,patterns,in,other,using,link,path,matcher,combine,string,string,li,if,only,one,instance,has,patterns,use,them,li,if,neither,instance,has,patterns,use,an,empty,string,i,e,ul;override,public,patterns,request,condition,combine,patterns,request,condition,other,set,string,result,new,linked,hash,set,if,this,patterns,is,empty,other,patterns,is,empty,for,string,pattern1,this,patterns,for,string,pattern2,other,patterns,result,add,this,path,matcher,combine,pattern1,pattern2,else,if,this,patterns,is,empty,result,add,all,this,patterns,else,if,other,patterns,is,empty,result,add,all,other,patterns,else,result,add,return,new,patterns,request,condition,result,this,path,matcher,this,use,suffix,pattern,match,this,use,trailing,slash,match,this,file,extensions
PatternsRequestCondition -> @Override 	public PatternsRequestCondition combine(PatternsRequestCondition other);1496430942;Returns a new instance with URL patterns from the current instance ("this") and_the "other" instance as follows:_<ul>_<li>If there are patterns in both instances, combine the patterns in "this" with_the patterns in "other" using {@link PathMatcher#combine(String, String)}._<li>If only one instance has patterns, use them._<li>If neither instance has patterns, use an empty String (i.e. "")._</ul>;@Override_	public PatternsRequestCondition combine(PatternsRequestCondition other) {_		Set<String> result = new LinkedHashSet<>()__		if (!this.patterns.isEmpty() && !other.patterns.isEmpty()) {_			for (String pattern1 : this.patterns) {_				for (String pattern2 : other.patterns) {_					result.add(this.pathMatcher.combine(pattern1, pattern2))__				}_			}_		}_		else if (!this.patterns.isEmpty()) {_			result.addAll(this.patterns)__		}_		else if (!other.patterns.isEmpty()) {_			result.addAll(other.patterns)__		}_		else {_			result.add("")__		}_		return new PatternsRequestCondition(result, this.pathMatcher, this.useSuffixPatternMatch,_				this.useTrailingSlashMatch, this.fileExtensions)__	};returns,a,new,instance,with,url,patterns,from,the,current,instance,this,and,the,other,instance,as,follows,ul,li,if,there,are,patterns,in,both,instances,combine,the,patterns,in,this,with,the,patterns,in,other,using,link,path,matcher,combine,string,string,li,if,only,one,instance,has,patterns,use,them,li,if,neither,instance,has,patterns,use,an,empty,string,i,e,ul;override,public,patterns,request,condition,combine,patterns,request,condition,other,set,string,result,new,linked,hash,set,if,this,patterns,is,empty,other,patterns,is,empty,for,string,pattern1,this,patterns,for,string,pattern2,other,patterns,result,add,this,path,matcher,combine,pattern1,pattern2,else,if,this,patterns,is,empty,result,add,all,this,patterns,else,if,other,patterns,is,empty,result,add,all,other,patterns,else,result,add,return,new,patterns,request,condition,result,this,path,matcher,this,use,suffix,pattern,match,this,use,trailing,slash,match,this,file,extensions
PatternsRequestCondition -> @Override 	public PatternsRequestCondition combine(PatternsRequestCondition other);1497039338;Returns a new instance with URL patterns from the current instance ("this") and_the "other" instance as follows:_<ul>_<li>If there are patterns in both instances, combine the patterns in "this" with_the patterns in "other" using {@link PathMatcher#combine(String, String)}._<li>If only one instance has patterns, use them._<li>If neither instance has patterns, use an empty String (i.e. "")._</ul>;@Override_	public PatternsRequestCondition combine(PatternsRequestCondition other) {_		Set<String> result = new LinkedHashSet<>()__		if (!this.patterns.isEmpty() && !other.patterns.isEmpty()) {_			for (String pattern1 : this.patterns) {_				for (String pattern2 : other.patterns) {_					result.add(this.pathMatcher.combine(pattern1, pattern2))__				}_			}_		}_		else if (!this.patterns.isEmpty()) {_			result.addAll(this.patterns)__		}_		else if (!other.patterns.isEmpty()) {_			result.addAll(other.patterns)__		}_		else {_			result.add("")__		}_		return new PatternsRequestCondition(result, this.pathMatcher, this.useSuffixPatternMatch,_				this.useTrailingSlashMatch, this.fileExtensions)__	};returns,a,new,instance,with,url,patterns,from,the,current,instance,this,and,the,other,instance,as,follows,ul,li,if,there,are,patterns,in,both,instances,combine,the,patterns,in,this,with,the,patterns,in,other,using,link,path,matcher,combine,string,string,li,if,only,one,instance,has,patterns,use,them,li,if,neither,instance,has,patterns,use,an,empty,string,i,e,ul;override,public,patterns,request,condition,combine,patterns,request,condition,other,set,string,result,new,linked,hash,set,if,this,patterns,is,empty,other,patterns,is,empty,for,string,pattern1,this,patterns,for,string,pattern2,other,patterns,result,add,this,path,matcher,combine,pattern1,pattern2,else,if,this,patterns,is,empty,result,add,all,this,patterns,else,if,other,patterns,is,empty,result,add,all,other,patterns,else,result,add,return,new,patterns,request,condition,result,this,path,matcher,this,use,suffix,pattern,match,this,use,trailing,slash,match,this,file,extensions
PatternsRequestCondition -> @Override 	public PatternsRequestCondition combine(PatternsRequestCondition other);1497232764;Returns a new instance with URL patterns from the current instance ("this") and_the "other" instance as follows:_<ul>_<li>If there are patterns in both instances, combine the patterns in "this" with_the patterns in "other" using {@link PathMatcher#combine(String, String)}._<li>If only one instance has patterns, use them._<li>If neither instance has patterns, use an empty String (i.e. "")._</ul>;@Override_	public PatternsRequestCondition combine(PatternsRequestCondition other) {_		Set<String> result = new LinkedHashSet<>()__		if (!this.patterns.isEmpty() && !other.patterns.isEmpty()) {_			for (String pattern1 : this.patterns) {_				for (String pattern2 : other.patterns) {_					result.add(this.pathMatcher.combine(pattern1, pattern2))__				}_			}_		}_		else if (!this.patterns.isEmpty()) {_			result.addAll(this.patterns)__		}_		else if (!other.patterns.isEmpty()) {_			result.addAll(other.patterns)__		}_		else {_			result.add("")__		}_		return new PatternsRequestCondition(result, this.pathMatcher, this.useSuffixPatternMatch,_				this.useTrailingSlashMatch, this.fileExtensions)__	};returns,a,new,instance,with,url,patterns,from,the,current,instance,this,and,the,other,instance,as,follows,ul,li,if,there,are,patterns,in,both,instances,combine,the,patterns,in,this,with,the,patterns,in,other,using,link,path,matcher,combine,string,string,li,if,only,one,instance,has,patterns,use,them,li,if,neither,instance,has,patterns,use,an,empty,string,i,e,ul;override,public,patterns,request,condition,combine,patterns,request,condition,other,set,string,result,new,linked,hash,set,if,this,patterns,is,empty,other,patterns,is,empty,for,string,pattern1,this,patterns,for,string,pattern2,other,patterns,result,add,this,path,matcher,combine,pattern1,pattern2,else,if,this,patterns,is,empty,result,add,all,this,patterns,else,if,other,patterns,is,empty,result,add,all,other,patterns,else,result,add,return,new,patterns,request,condition,result,this,path,matcher,this,use,suffix,pattern,match,this,use,trailing,slash,match,this,file,extensions
PatternsRequestCondition -> @Override 	public PatternsRequestCondition combine(PatternsRequestCondition other);1497286385;Returns a new instance with URL patterns from the current instance ("this") and_the "other" instance as follows:_<ul>_<li>If there are patterns in both instances, combine the patterns in "this" with_the patterns in "other" using {@link PathPattern#combine(String)}._<li>If only one instance has patterns, use them._<li>If neither instance has patterns, use an empty String (i.e. "")._</ul>;@Override_	public PatternsRequestCondition combine(PatternsRequestCondition other) {_		List<PathPattern> combined = new ArrayList<>()__		if (!this.patterns.isEmpty() && !other.patterns.isEmpty()) {_			for (PathPattern pattern1 : this.patterns) {_				for (PathPattern pattern2 : other.patterns) {_					String combinedPattern = pattern1.combine(pattern2.getPatternString())__					combined.add(this.parser.parse(combinedPattern))__				}_			}_		}_		else if (!this.patterns.isEmpty()) {_			combined.addAll(this.patterns)__		}_		else if (!other.patterns.isEmpty()) {_			combined.addAll(other.patterns)__		}_		else {_			combined.add(this.parser.parse(""))__		}__		return new PatternsRequestCondition(combined, this.parser)__	};returns,a,new,instance,with,url,patterns,from,the,current,instance,this,and,the,other,instance,as,follows,ul,li,if,there,are,patterns,in,both,instances,combine,the,patterns,in,this,with,the,patterns,in,other,using,link,path,pattern,combine,string,li,if,only,one,instance,has,patterns,use,them,li,if,neither,instance,has,patterns,use,an,empty,string,i,e,ul;override,public,patterns,request,condition,combine,patterns,request,condition,other,list,path,pattern,combined,new,array,list,if,this,patterns,is,empty,other,patterns,is,empty,for,path,pattern,pattern1,this,patterns,for,path,pattern,pattern2,other,patterns,string,combined,pattern,pattern1,combine,pattern2,get,pattern,string,combined,add,this,parser,parse,combined,pattern,else,if,this,patterns,is,empty,combined,add,all,this,patterns,else,if,other,patterns,is,empty,combined,add,all,other,patterns,else,combined,add,this,parser,parse,return,new,patterns,request,condition,combined,this,parser
PatternsRequestCondition -> @Override 	public PatternsRequestCondition combine(PatternsRequestCondition other);1498861175;Returns a new instance with URL patterns from the current instance ("this") and_the "other" instance as follows:_<ul>_<li>If there are patterns in both instances, combine the patterns in "this" with_the patterns in "other" using {@link PathPattern#combine(PathPattern)}._<li>If only one instance has patterns, use them._<li>If neither instance has patterns, use an empty String (i.e. "")._</ul>;@Override_	public PatternsRequestCondition combine(PatternsRequestCondition other) {_		List<PathPattern> combined = new ArrayList<>()__		if (!this.patterns.isEmpty() && !other.patterns.isEmpty()) {_			for (PathPattern pattern1 : this.patterns) {_				for (PathPattern pattern2 : other.patterns) {_					combined.add(pattern1.combine(pattern2))__				}_			}_		}_		else if (!this.patterns.isEmpty()) {_			combined.addAll(this.patterns)__		}_		else if (!other.patterns.isEmpty()) {_			combined.addAll(other.patterns)__		}_		else {_			combined.add(this.parser.parse(""))__		}__		return new PatternsRequestCondition(combined, this.parser)__	};returns,a,new,instance,with,url,patterns,from,the,current,instance,this,and,the,other,instance,as,follows,ul,li,if,there,are,patterns,in,both,instances,combine,the,patterns,in,this,with,the,patterns,in,other,using,link,path,pattern,combine,path,pattern,li,if,only,one,instance,has,patterns,use,them,li,if,neither,instance,has,patterns,use,an,empty,string,i,e,ul;override,public,patterns,request,condition,combine,patterns,request,condition,other,list,path,pattern,combined,new,array,list,if,this,patterns,is,empty,other,patterns,is,empty,for,path,pattern,pattern1,this,patterns,for,path,pattern,pattern2,other,patterns,combined,add,pattern1,combine,pattern2,else,if,this,patterns,is,empty,combined,add,all,this,patterns,else,if,other,patterns,is,empty,combined,add,all,other,patterns,else,combined,add,this,parser,parse,return,new,patterns,request,condition,combined,this,parser
PatternsRequestCondition -> @Override 	public PatternsRequestCondition combine(PatternsRequestCondition other);1498861175;Returns a new instance with URL patterns from the current instance ("this") and_the "other" instance as follows:_<ul>_<li>If there are patterns in both instances, combine the patterns in "this" with_the patterns in "other" using {@link PathPattern#combine(PathPattern)}._<li>If only one instance has patterns, use them._<li>If neither instance has patterns, use an empty String (i.e. "")._</ul>;@Override_	public PatternsRequestCondition combine(PatternsRequestCondition other) {_		List<PathPattern> combined = new ArrayList<>()__		if (!this.patterns.isEmpty() && !other.patterns.isEmpty()) {_			for (PathPattern pattern1 : this.patterns) {_				for (PathPattern pattern2 : other.patterns) {_					combined.add(pattern1.combine(pattern2))__				}_			}_		}_		else if (!this.patterns.isEmpty()) {_			combined.addAll(this.patterns)__		}_		else if (!other.patterns.isEmpty()) {_			combined.addAll(other.patterns)__		}_		else {_			combined.add(this.parser.parse(""))__		}_		return new PatternsRequestCondition(combined, this.parser)__	};returns,a,new,instance,with,url,patterns,from,the,current,instance,this,and,the,other,instance,as,follows,ul,li,if,there,are,patterns,in,both,instances,combine,the,patterns,in,this,with,the,patterns,in,other,using,link,path,pattern,combine,path,pattern,li,if,only,one,instance,has,patterns,use,them,li,if,neither,instance,has,patterns,use,an,empty,string,i,e,ul;override,public,patterns,request,condition,combine,patterns,request,condition,other,list,path,pattern,combined,new,array,list,if,this,patterns,is,empty,other,patterns,is,empty,for,path,pattern,pattern1,this,patterns,for,path,pattern,pattern2,other,patterns,combined,add,pattern1,combine,pattern2,else,if,this,patterns,is,empty,combined,add,all,this,patterns,else,if,other,patterns,is,empty,combined,add,all,other,patterns,else,combined,add,this,parser,parse,return,new,patterns,request,condition,combined,this,parser
PatternsRequestCondition -> @Override 	public PatternsRequestCondition combine(PatternsRequestCondition other);1498944474;Returns a new instance with URL patterns from the current instance ("this") and_the "other" instance as follows:_<ul>_<li>If there are patterns in both instances, combine the patterns in "this" with_the patterns in "other" using {@link PathPattern#combine(PathPattern)}._<li>If only one instance has patterns, use them._<li>If neither instance has patterns, use an empty String (i.e. "")._</ul>;@Override_	public PatternsRequestCondition combine(PatternsRequestCondition other) {_		List<PathPattern> combined = new ArrayList<>()__		if (!this.patterns.isEmpty() && !other.patterns.isEmpty()) {_			for (PathPattern pattern1 : this.patterns) {_				for (PathPattern pattern2 : other.patterns) {_					combined.add(pattern1.combine(pattern2))__				}_			}_		}_		else if (!this.patterns.isEmpty()) {_			combined.addAll(this.patterns)__		}_		else if (!other.patterns.isEmpty()) {_			combined.addAll(other.patterns)__		}_		else {_			combined.add(this.parser.parse(""))__		}_		return new PatternsRequestCondition(combined, this.parser)__	};returns,a,new,instance,with,url,patterns,from,the,current,instance,this,and,the,other,instance,as,follows,ul,li,if,there,are,patterns,in,both,instances,combine,the,patterns,in,this,with,the,patterns,in,other,using,link,path,pattern,combine,path,pattern,li,if,only,one,instance,has,patterns,use,them,li,if,neither,instance,has,patterns,use,an,empty,string,i,e,ul;override,public,patterns,request,condition,combine,patterns,request,condition,other,list,path,pattern,combined,new,array,list,if,this,patterns,is,empty,other,patterns,is,empty,for,path,pattern,pattern1,this,patterns,for,path,pattern,pattern2,other,patterns,combined,add,pattern1,combine,pattern2,else,if,this,patterns,is,empty,combined,add,all,this,patterns,else,if,other,patterns,is,empty,combined,add,all,other,patterns,else,combined,add,this,parser,parse,return,new,patterns,request,condition,combined,this,parser
PatternsRequestCondition -> @Override 	public PatternsRequestCondition combine(PatternsRequestCondition other);1500370830;Returns a new instance with URL patterns from the current instance ("this") and_the "other" instance as follows:_<ul>_<li>If there are patterns in both instances, combine the patterns in "this" with_the patterns in "other" using {@link PathPattern#combine(PathPattern)}._<li>If only one instance has patterns, use them._<li>If neither instance has patterns, use an empty String (i.e. "")._</ul>;@Override_	public PatternsRequestCondition combine(PatternsRequestCondition other) {_		List<PathPattern> combined = new ArrayList<>()__		if (!this.patterns.isEmpty() && !other.patterns.isEmpty()) {_			for (PathPattern pattern1 : this.patterns) {_				for (PathPattern pattern2 : other.patterns) {_					combined.add(pattern1.combine(pattern2))__				}_			}_		}_		else if (!this.patterns.isEmpty()) {_			combined.addAll(this.patterns)__		}_		else if (!other.patterns.isEmpty()) {_			combined.addAll(other.patterns)__		}_		return new PatternsRequestCondition(combined)__	};returns,a,new,instance,with,url,patterns,from,the,current,instance,this,and,the,other,instance,as,follows,ul,li,if,there,are,patterns,in,both,instances,combine,the,patterns,in,this,with,the,patterns,in,other,using,link,path,pattern,combine,path,pattern,li,if,only,one,instance,has,patterns,use,them,li,if,neither,instance,has,patterns,use,an,empty,string,i,e,ul;override,public,patterns,request,condition,combine,patterns,request,condition,other,list,path,pattern,combined,new,array,list,if,this,patterns,is,empty,other,patterns,is,empty,for,path,pattern,pattern1,this,patterns,for,path,pattern,pattern2,other,patterns,combined,add,pattern1,combine,pattern2,else,if,this,patterns,is,empty,combined,add,all,this,patterns,else,if,other,patterns,is,empty,combined,add,all,other,patterns,return,new,patterns,request,condition,combined
PatternsRequestCondition -> @Override 	public PatternsRequestCondition combine(PatternsRequestCondition other);1501237594;Returns a new instance with URL patterns from the current instance ("this") and_the "other" instance as follows:_<ul>_<li>If there are patterns in both instances, combine the patterns in "this" with_the patterns in "other" using {@link PathPattern#combine(PathPattern)}._<li>If only one instance has patterns, use them._<li>If neither instance has patterns, use an empty String (i.e. "")._</ul>;@Override_	public PatternsRequestCondition combine(PatternsRequestCondition other) {_		List<PathPattern> combined = new ArrayList<>()__		if (!this.patterns.isEmpty() && !other.patterns.isEmpty()) {_			for (PathPattern pattern1 : this.patterns) {_				for (PathPattern pattern2 : other.patterns) {_					combined.add(pattern1.combine(pattern2))__				}_			}_		}_		else if (!this.patterns.isEmpty()) {_			combined.addAll(this.patterns)__		}_		else if (!other.patterns.isEmpty()) {_			combined.addAll(other.patterns)__		}_		return new PatternsRequestCondition(combined)__	};returns,a,new,instance,with,url,patterns,from,the,current,instance,this,and,the,other,instance,as,follows,ul,li,if,there,are,patterns,in,both,instances,combine,the,patterns,in,this,with,the,patterns,in,other,using,link,path,pattern,combine,path,pattern,li,if,only,one,instance,has,patterns,use,them,li,if,neither,instance,has,patterns,use,an,empty,string,i,e,ul;override,public,patterns,request,condition,combine,patterns,request,condition,other,list,path,pattern,combined,new,array,list,if,this,patterns,is,empty,other,patterns,is,empty,for,path,pattern,pattern1,this,patterns,for,path,pattern,pattern2,other,patterns,combined,add,pattern1,combine,pattern2,else,if,this,patterns,is,empty,combined,add,all,this,patterns,else,if,other,patterns,is,empty,combined,add,all,other,patterns,return,new,patterns,request,condition,combined
PatternsRequestCondition -> @Override 	public PatternsRequestCondition combine(PatternsRequestCondition other);1501690296;Returns a new instance with URL patterns from the current instance ("this") and_the "other" instance as follows:_<ul>_<li>If there are patterns in both instances, combine the patterns in "this" with_the patterns in "other" using {@link PathPattern#combine(PathPattern)}._<li>If only one instance has patterns, use them._<li>If neither instance has patterns, use an empty String (i.e. "")._</ul>;@Override_	public PatternsRequestCondition combine(PatternsRequestCondition other) {_		List<PathPattern> combined = new ArrayList<>()__		if (!this.patterns.isEmpty() && !other.patterns.isEmpty()) {_			for (PathPattern pattern1 : this.patterns) {_				for (PathPattern pattern2 : other.patterns) {_					combined.add(pattern1.combine(pattern2))__				}_			}_		}_		else if (!this.patterns.isEmpty()) {_			combined.addAll(this.patterns)__		}_		else if (!other.patterns.isEmpty()) {_			combined.addAll(other.patterns)__		}_		return new PatternsRequestCondition(combined)__	};returns,a,new,instance,with,url,patterns,from,the,current,instance,this,and,the,other,instance,as,follows,ul,li,if,there,are,patterns,in,both,instances,combine,the,patterns,in,this,with,the,patterns,in,other,using,link,path,pattern,combine,path,pattern,li,if,only,one,instance,has,patterns,use,them,li,if,neither,instance,has,patterns,use,an,empty,string,i,e,ul;override,public,patterns,request,condition,combine,patterns,request,condition,other,list,path,pattern,combined,new,array,list,if,this,patterns,is,empty,other,patterns,is,empty,for,path,pattern,pattern1,this,patterns,for,path,pattern,pattern2,other,patterns,combined,add,pattern1,combine,pattern2,else,if,this,patterns,is,empty,combined,add,all,this,patterns,else,if,other,patterns,is,empty,combined,add,all,other,patterns,return,new,patterns,request,condition,combined
PatternsRequestCondition -> @Override 	public PatternsRequestCondition combine(PatternsRequestCondition other);1530174524;Returns a new instance with URL patterns from the current instance ("this") and_the "other" instance as follows:_<ul>_<li>If there are patterns in both instances, combine the patterns in "this" with_the patterns in "other" using {@link PathPattern#combine(PathPattern)}._<li>If only one instance has patterns, use them._<li>If neither instance has patterns, use an empty String (i.e. "")._</ul>;@Override_	public PatternsRequestCondition combine(PatternsRequestCondition other) {_		List<PathPattern> combined = new ArrayList<>()__		if (!this.patterns.isEmpty() && !other.patterns.isEmpty()) {_			for (PathPattern pattern1 : this.patterns) {_				for (PathPattern pattern2 : other.patterns) {_					combined.add(pattern1.combine(pattern2))__				}_			}_		}_		else if (!this.patterns.isEmpty()) {_			combined.addAll(this.patterns)__		}_		else if (!other.patterns.isEmpty()) {_			combined.addAll(other.patterns)__		}_		return new PatternsRequestCondition(combined)__	};returns,a,new,instance,with,url,patterns,from,the,current,instance,this,and,the,other,instance,as,follows,ul,li,if,there,are,patterns,in,both,instances,combine,the,patterns,in,this,with,the,patterns,in,other,using,link,path,pattern,combine,path,pattern,li,if,only,one,instance,has,patterns,use,them,li,if,neither,instance,has,patterns,use,an,empty,string,i,e,ul;override,public,patterns,request,condition,combine,patterns,request,condition,other,list,path,pattern,combined,new,array,list,if,this,patterns,is,empty,other,patterns,is,empty,for,path,pattern,pattern1,this,patterns,for,path,pattern,pattern2,other,patterns,combined,add,pattern1,combine,pattern2,else,if,this,patterns,is,empty,combined,add,all,this,patterns,else,if,other,patterns,is,empty,combined,add,all,other,patterns,return,new,patterns,request,condition,combined
PatternsRequestCondition -> @Override 	public PatternsRequestCondition combine(PatternsRequestCondition other);1530190293;Returns a new instance with URL patterns from the current instance ("this") and_the "other" instance as follows:_<ul>_<li>If there are patterns in both instances, combine the patterns in "this" with_the patterns in "other" using {@link PathPattern#combine(PathPattern)}._<li>If only one instance has patterns, use them._<li>If neither instance has patterns, use an empty String (i.e. "")._</ul>;@Override_	public PatternsRequestCondition combine(PatternsRequestCondition other) {_		List<PathPattern> combined = new ArrayList<>()__		if (!this.patterns.isEmpty() && !other.patterns.isEmpty()) {_			for (PathPattern pattern1 : this.patterns) {_				for (PathPattern pattern2 : other.patterns) {_					combined.add(pattern1.combine(pattern2))__				}_			}_		}_		else if (!this.patterns.isEmpty()) {_			combined.addAll(this.patterns)__		}_		else if (!other.patterns.isEmpty()) {_			combined.addAll(other.patterns)__		}_		return new PatternsRequestCondition(combined)__	};returns,a,new,instance,with,url,patterns,from,the,current,instance,this,and,the,other,instance,as,follows,ul,li,if,there,are,patterns,in,both,instances,combine,the,patterns,in,this,with,the,patterns,in,other,using,link,path,pattern,combine,path,pattern,li,if,only,one,instance,has,patterns,use,them,li,if,neither,instance,has,patterns,use,an,empty,string,i,e,ul;override,public,patterns,request,condition,combine,patterns,request,condition,other,list,path,pattern,combined,new,array,list,if,this,patterns,is,empty,other,patterns,is,empty,for,path,pattern,pattern1,this,patterns,for,path,pattern,pattern2,other,patterns,combined,add,pattern1,combine,pattern2,else,if,this,patterns,is,empty,combined,add,all,this,patterns,else,if,other,patterns,is,empty,combined,add,all,other,patterns,return,new,patterns,request,condition,combined
PatternsRequestCondition -> public PatternsRequestCondition(String[] patterns, PathMatcher pathMatcher, 			boolean useSuffixPatternMatch, boolean useTrailingSlashMatch, 			Set<String> extensions);1496334664;Creates a new instance with the given URL patterns._Each pattern that is not empty and does not start with "/" is pre-pended with "/"._@param patterns the URL patterns to use_ if 0, the condition will match to every request._@param pathMatcher for pattern path matching_@param useSuffixPatternMatch whether to enable matching by suffix (".*")_@param useTrailingSlashMatch whether to match irrespective of a trailing slash_@param extensions file extensions to consider for path matching;public PatternsRequestCondition(String[] patterns, PathMatcher pathMatcher,_			boolean useSuffixPatternMatch, boolean useTrailingSlashMatch,_			Set<String> extensions) {__		this(asList(patterns), pathMatcher, useSuffixPatternMatch, useTrailingSlashMatch, extensions)__	};creates,a,new,instance,with,the,given,url,patterns,each,pattern,that,is,not,empty,and,does,not,start,with,is,pre,pended,with,param,patterns,the,url,patterns,to,use,if,0,the,condition,will,match,to,every,request,param,path,matcher,for,pattern,path,matching,param,use,suffix,pattern,match,whether,to,enable,matching,by,suffix,param,use,trailing,slash,match,whether,to,match,irrespective,of,a,trailing,slash,param,extensions,file,extensions,to,consider,for,path,matching;public,patterns,request,condition,string,patterns,path,matcher,path,matcher,boolean,use,suffix,pattern,match,boolean,use,trailing,slash,match,set,string,extensions,this,as,list,patterns,path,matcher,use,suffix,pattern,match,use,trailing,slash,match,extensions
PatternsRequestCondition -> public PatternsRequestCondition(String[] patterns, PathMatcher pathMatcher, 			boolean useSuffixPatternMatch, boolean useTrailingSlashMatch, 			Set<String> extensions);1496429194;Creates a new instance with the given URL patterns._Each pattern that is not empty and does not start with "/" is pre-pended with "/"._@param patterns the URL patterns to use_ if 0, the condition will match to every request._@param pathMatcher for pattern path matching_@param useSuffixPatternMatch whether to enable matching by suffix (".*")_@param useTrailingSlashMatch whether to match irrespective of a trailing slash_@param extensions file extensions to consider for path matching;public PatternsRequestCondition(String[] patterns, PathMatcher pathMatcher,_			boolean useSuffixPatternMatch, boolean useTrailingSlashMatch,_			Set<String> extensions) {__		this(asList(patterns), pathMatcher, useSuffixPatternMatch, useTrailingSlashMatch, extensions)__	};creates,a,new,instance,with,the,given,url,patterns,each,pattern,that,is,not,empty,and,does,not,start,with,is,pre,pended,with,param,patterns,the,url,patterns,to,use,if,0,the,condition,will,match,to,every,request,param,path,matcher,for,pattern,path,matching,param,use,suffix,pattern,match,whether,to,enable,matching,by,suffix,param,use,trailing,slash,match,whether,to,match,irrespective,of,a,trailing,slash,param,extensions,file,extensions,to,consider,for,path,matching;public,patterns,request,condition,string,patterns,path,matcher,path,matcher,boolean,use,suffix,pattern,match,boolean,use,trailing,slash,match,set,string,extensions,this,as,list,patterns,path,matcher,use,suffix,pattern,match,use,trailing,slash,match,extensions
PatternsRequestCondition -> public PatternsRequestCondition(String[] patterns, PathMatcher pathMatcher, 			boolean useSuffixPatternMatch, boolean useTrailingSlashMatch, 			Set<String> extensions);1496430942;Creates a new instance with the given URL patterns._Each pattern that is not empty and does not start with "/" is pre-pended with "/"._@param patterns the URL patterns to use_ if 0, the condition will match to every request._@param pathMatcher for pattern path matching_@param useSuffixPatternMatch whether to enable matching by suffix (".*")_@param useTrailingSlashMatch whether to match irrespective of a trailing slash_@param extensions file extensions to consider for path matching;public PatternsRequestCondition(String[] patterns, PathMatcher pathMatcher,_			boolean useSuffixPatternMatch, boolean useTrailingSlashMatch,_			Set<String> extensions) {__		this(asList(patterns), pathMatcher, useSuffixPatternMatch, useTrailingSlashMatch, extensions)__	};creates,a,new,instance,with,the,given,url,patterns,each,pattern,that,is,not,empty,and,does,not,start,with,is,pre,pended,with,param,patterns,the,url,patterns,to,use,if,0,the,condition,will,match,to,every,request,param,path,matcher,for,pattern,path,matching,param,use,suffix,pattern,match,whether,to,enable,matching,by,suffix,param,use,trailing,slash,match,whether,to,match,irrespective,of,a,trailing,slash,param,extensions,file,extensions,to,consider,for,path,matching;public,patterns,request,condition,string,patterns,path,matcher,path,matcher,boolean,use,suffix,pattern,match,boolean,use,trailing,slash,match,set,string,extensions,this,as,list,patterns,path,matcher,use,suffix,pattern,match,use,trailing,slash,match,extensions
PatternsRequestCondition -> public PatternsRequestCondition(String[] patterns, PathMatcher pathMatcher, 			boolean useSuffixPatternMatch, boolean useTrailingSlashMatch, 			Set<String> extensions);1497039338;Creates a new instance with the given URL patterns._Each pattern that is not empty and does not start with "/" is pre-pended with "/"._@param patterns the URL patterns to use_ if 0, the condition will match to every request._@param pathMatcher for pattern path matching_@param useSuffixPatternMatch whether to enable matching by suffix (".*")_@param useTrailingSlashMatch whether to match irrespective of a trailing slash_@param extensions file extensions to consider for path matching;public PatternsRequestCondition(String[] patterns, PathMatcher pathMatcher,_			boolean useSuffixPatternMatch, boolean useTrailingSlashMatch,_			Set<String> extensions) {__		this(asList(patterns), pathMatcher, useSuffixPatternMatch, useTrailingSlashMatch, extensions)__	};creates,a,new,instance,with,the,given,url,patterns,each,pattern,that,is,not,empty,and,does,not,start,with,is,pre,pended,with,param,patterns,the,url,patterns,to,use,if,0,the,condition,will,match,to,every,request,param,path,matcher,for,pattern,path,matching,param,use,suffix,pattern,match,whether,to,enable,matching,by,suffix,param,use,trailing,slash,match,whether,to,match,irrespective,of,a,trailing,slash,param,extensions,file,extensions,to,consider,for,path,matching;public,patterns,request,condition,string,patterns,path,matcher,path,matcher,boolean,use,suffix,pattern,match,boolean,use,trailing,slash,match,set,string,extensions,this,as,list,patterns,path,matcher,use,suffix,pattern,match,use,trailing,slash,match,extensions
PatternsRequestCondition -> public PatternsRequestCondition(String[] patterns, PathMatcher pathMatcher, 			boolean useSuffixPatternMatch, boolean useTrailingSlashMatch, 			Set<String> extensions);1497232764;Creates a new instance with the given URL patterns._Each pattern that is not empty and does not start with "/" is pre-pended with "/"._@param patterns the URL patterns to use_ if 0, the condition will match to every request._@param pathMatcher for pattern path matching_@param useSuffixPatternMatch whether to enable matching by suffix (".*")_@param useTrailingSlashMatch whether to match irrespective of a trailing slash_@param extensions file extensions to consider for path matching;public PatternsRequestCondition(String[] patterns, PathMatcher pathMatcher,_			boolean useSuffixPatternMatch, boolean useTrailingSlashMatch,_			Set<String> extensions) {__		this(asList(patterns), pathMatcher, useSuffixPatternMatch, useTrailingSlashMatch, extensions)__	};creates,a,new,instance,with,the,given,url,patterns,each,pattern,that,is,not,empty,and,does,not,start,with,is,pre,pended,with,param,patterns,the,url,patterns,to,use,if,0,the,condition,will,match,to,every,request,param,path,matcher,for,pattern,path,matching,param,use,suffix,pattern,match,whether,to,enable,matching,by,suffix,param,use,trailing,slash,match,whether,to,match,irrespective,of,a,trailing,slash,param,extensions,file,extensions,to,consider,for,path,matching;public,patterns,request,condition,string,patterns,path,matcher,path,matcher,boolean,use,suffix,pattern,match,boolean,use,trailing,slash,match,set,string,extensions,this,as,list,patterns,path,matcher,use,suffix,pattern,match,use,trailing,slash,match,extensions
PatternsRequestCondition -> public List<String> getMatchingPatterns(LookupPath lookupPath);1496334664;Find the patterns matching the given lookup path. Invoking this method should_yield results equivalent to those of calling_{@link #getMatchingCondition(ServerWebExchange)}._This method is provided as an alternative to be used if no request is available_(e.g. introspection, tooling, etc)._@param lookupPath the lookup path to match to existing patterns_@return a collection of matching patterns sorted with the closest match at the top;public List<String> getMatchingPatterns(LookupPath lookupPath) {_		List<String> matches = new ArrayList<>()__		for (String pattern : this.patterns) {_			String match = getMatchingPattern(pattern, lookupPath)__			if (match != null) {_				matches.add(match)__			}_		}_		Collections.sort(matches, this.pathMatcher.getPatternComparator(lookupPath.getPath()))__		return matches__	};find,the,patterns,matching,the,given,lookup,path,invoking,this,method,should,yield,results,equivalent,to,those,of,calling,link,get,matching,condition,server,web,exchange,this,method,is,provided,as,an,alternative,to,be,used,if,no,request,is,available,e,g,introspection,tooling,etc,param,lookup,path,the,lookup,path,to,match,to,existing,patterns,return,a,collection,of,matching,patterns,sorted,with,the,closest,match,at,the,top;public,list,string,get,matching,patterns,lookup,path,lookup,path,list,string,matches,new,array,list,for,string,pattern,this,patterns,string,match,get,matching,pattern,pattern,lookup,path,if,match,null,matches,add,match,collections,sort,matches,this,path,matcher,get,pattern,comparator,lookup,path,get,path,return,matches
PatternsRequestCondition -> public List<String> getMatchingPatterns(LookupPath lookupPath);1496429194;Find the patterns matching the given lookup path. Invoking this method should_yield results equivalent to those of calling_{@link #getMatchingCondition(ServerWebExchange)}._This method is provided as an alternative to be used if no request is available_(e.g. introspection, tooling, etc)._@param lookupPath the lookup path to match to existing patterns_@return a collection of matching patterns sorted with the closest match at the top;public List<String> getMatchingPatterns(LookupPath lookupPath) {_		List<String> matches = new ArrayList<>()__		for (String pattern : this.patterns) {_			String match = getMatchingPattern(pattern, lookupPath)__			if (match != null) {_				matches.add(match)__			}_		}_		Collections.sort(matches, this.pathMatcher.getPatternComparator(lookupPath.getPath()))__		return matches__	};find,the,patterns,matching,the,given,lookup,path,invoking,this,method,should,yield,results,equivalent,to,those,of,calling,link,get,matching,condition,server,web,exchange,this,method,is,provided,as,an,alternative,to,be,used,if,no,request,is,available,e,g,introspection,tooling,etc,param,lookup,path,the,lookup,path,to,match,to,existing,patterns,return,a,collection,of,matching,patterns,sorted,with,the,closest,match,at,the,top;public,list,string,get,matching,patterns,lookup,path,lookup,path,list,string,matches,new,array,list,for,string,pattern,this,patterns,string,match,get,matching,pattern,pattern,lookup,path,if,match,null,matches,add,match,collections,sort,matches,this,path,matcher,get,pattern,comparator,lookup,path,get,path,return,matches
PatternsRequestCondition -> public List<String> getMatchingPatterns(LookupPath lookupPath);1496430942;Find the patterns matching the given lookup path. Invoking this method should_yield results equivalent to those of calling_{@link #getMatchingCondition(ServerWebExchange)}._This method is provided as an alternative to be used if no request is available_(e.g. introspection, tooling, etc)._@param lookupPath the lookup path to match to existing patterns_@return a collection of matching patterns sorted with the closest match at the top;public List<String> getMatchingPatterns(LookupPath lookupPath) {_		List<String> matches = new ArrayList<>()__		for (String pattern : this.patterns) {_			String match = getMatchingPattern(pattern, lookupPath)__			if (match != null) {_				matches.add(match)__			}_		}_		Collections.sort(matches, this.pathMatcher.getPatternComparator(lookupPath.getPath()))__		return matches__	};find,the,patterns,matching,the,given,lookup,path,invoking,this,method,should,yield,results,equivalent,to,those,of,calling,link,get,matching,condition,server,web,exchange,this,method,is,provided,as,an,alternative,to,be,used,if,no,request,is,available,e,g,introspection,tooling,etc,param,lookup,path,the,lookup,path,to,match,to,existing,patterns,return,a,collection,of,matching,patterns,sorted,with,the,closest,match,at,the,top;public,list,string,get,matching,patterns,lookup,path,lookup,path,list,string,matches,new,array,list,for,string,pattern,this,patterns,string,match,get,matching,pattern,pattern,lookup,path,if,match,null,matches,add,match,collections,sort,matches,this,path,matcher,get,pattern,comparator,lookup,path,get,path,return,matches
PatternsRequestCondition -> @Override 	public int compareTo(PatternsRequestCondition other, ServerWebExchange exchange);1485986572;Compare the two conditions based on the URL patterns they contain._Patterns are compared one at a time, from top to bottom via_{@link PathMatcher#getPatternComparator(String)}. If all compared_patterns match equally, but one instance has more patterns, it is_considered a closer match._<p>It is assumed that both instances have been obtained via_{@link #getMatchingCondition(ServerWebExchange)} to ensure they_contain only patterns that match the request and are sorted with_the best matches on top.;@Override_	public int compareTo(PatternsRequestCondition other, ServerWebExchange exchange) {_		String lookupPath = this.pathHelper.getLookupPathForRequest(exchange)__		Comparator<String> patternComparator = this.pathMatcher.getPatternComparator(lookupPath)__		Iterator<String> iterator = this.patterns.iterator()__		Iterator<String> iteratorOther = other.patterns.iterator()__		while (iterator.hasNext() && iteratorOther.hasNext()) {_			int result = patternComparator.compare(iterator.next(), iteratorOther.next())__			if (result != 0) {_				return result__			}_		}_		if (iterator.hasNext()) {_			return -1__		}_		else if (iteratorOther.hasNext()) {_			return 1__		}_		else {_			return 0__		}_	};compare,the,two,conditions,based,on,the,url,patterns,they,contain,patterns,are,compared,one,at,a,time,from,top,to,bottom,via,link,path,matcher,get,pattern,comparator,string,if,all,compared,patterns,match,equally,but,one,instance,has,more,patterns,it,is,considered,a,closer,match,p,it,is,assumed,that,both,instances,have,been,obtained,via,link,get,matching,condition,server,web,exchange,to,ensure,they,contain,only,patterns,that,match,the,request,and,are,sorted,with,the,best,matches,on,top;override,public,int,compare,to,patterns,request,condition,other,server,web,exchange,exchange,string,lookup,path,this,path,helper,get,lookup,path,for,request,exchange,comparator,string,pattern,comparator,this,path,matcher,get,pattern,comparator,lookup,path,iterator,string,iterator,this,patterns,iterator,iterator,string,iterator,other,other,patterns,iterator,while,iterator,has,next,iterator,other,has,next,int,result,pattern,comparator,compare,iterator,next,iterator,other,next,if,result,0,return,result,if,iterator,has,next,return,1,else,if,iterator,other,has,next,return,1,else,return,0
PatternsRequestCondition -> @Override 	public int compareTo(PatternsRequestCondition other, ServerWebExchange exchange);1486634978;Compare the two conditions based on the URL patterns they contain._Patterns are compared one at a time, from top to bottom via_{@link PathMatcher#getPatternComparator(String)}. If all compared_patterns match equally, but one instance has more patterns, it is_considered a closer match._<p>It is assumed that both instances have been obtained via_{@link #getMatchingCondition(ServerWebExchange)} to ensure they_contain only patterns that match the request and are sorted with_the best matches on top.;@Override_	public int compareTo(PatternsRequestCondition other, ServerWebExchange exchange) {_		String lookupPath = this.pathHelper.getLookupPathForRequest(exchange)__		Comparator<String> patternComparator = this.pathMatcher.getPatternComparator(lookupPath)__		Iterator<String> iterator = this.patterns.iterator()__		Iterator<String> iteratorOther = other.patterns.iterator()__		while (iterator.hasNext() && iteratorOther.hasNext()) {_			int result = patternComparator.compare(iterator.next(), iteratorOther.next())__			if (result != 0) {_				return result__			}_		}_		if (iterator.hasNext()) {_			return -1__		}_		else if (iteratorOther.hasNext()) {_			return 1__		}_		else {_			return 0__		}_	};compare,the,two,conditions,based,on,the,url,patterns,they,contain,patterns,are,compared,one,at,a,time,from,top,to,bottom,via,link,path,matcher,get,pattern,comparator,string,if,all,compared,patterns,match,equally,but,one,instance,has,more,patterns,it,is,considered,a,closer,match,p,it,is,assumed,that,both,instances,have,been,obtained,via,link,get,matching,condition,server,web,exchange,to,ensure,they,contain,only,patterns,that,match,the,request,and,are,sorted,with,the,best,matches,on,top;override,public,int,compare,to,patterns,request,condition,other,server,web,exchange,exchange,string,lookup,path,this,path,helper,get,lookup,path,for,request,exchange,comparator,string,pattern,comparator,this,path,matcher,get,pattern,comparator,lookup,path,iterator,string,iterator,this,patterns,iterator,iterator,string,iterator,other,other,patterns,iterator,while,iterator,has,next,iterator,other,has,next,int,result,pattern,comparator,compare,iterator,next,iterator,other,next,if,result,0,return,result,if,iterator,has,next,return,1,else,if,iterator,other,has,next,return,1,else,return,0
PatternsRequestCondition -> @Override 	public int compareTo(PatternsRequestCondition other, ServerWebExchange exchange);1486635693;Compare the two conditions based on the URL patterns they contain._Patterns are compared one at a time, from top to bottom via_{@link PathPatternRegistry#getComparator(String)}. If all compared_patterns match equally, but one instance has more patterns, it is_considered a closer match._<p>It is assumed that both instances have been obtained via_{@link #getMatchingCondition(ServerWebExchange)} to ensure they_contain only patterns that match the request and are sorted with_the best matches on top.;@Override_	public int compareTo(PatternsRequestCondition other, ServerWebExchange exchange) {_		String lookupPath = this.pathHelper.getLookupPathForRequest(exchange)__		Comparator<PathPatternRegistry> comparator = this.patternRegistry.getComparator(lookupPath)__		return comparator.compare(this.patternRegistry, other.patternRegistry)__	};compare,the,two,conditions,based,on,the,url,patterns,they,contain,patterns,are,compared,one,at,a,time,from,top,to,bottom,via,link,path,pattern,registry,get,comparator,string,if,all,compared,patterns,match,equally,but,one,instance,has,more,patterns,it,is,considered,a,closer,match,p,it,is,assumed,that,both,instances,have,been,obtained,via,link,get,matching,condition,server,web,exchange,to,ensure,they,contain,only,patterns,that,match,the,request,and,are,sorted,with,the,best,matches,on,top;override,public,int,compare,to,patterns,request,condition,other,server,web,exchange,exchange,string,lookup,path,this,path,helper,get,lookup,path,for,request,exchange,comparator,path,pattern,registry,comparator,this,pattern,registry,get,comparator,lookup,path,return,comparator,compare,this,pattern,registry,other,pattern,registry
PatternsRequestCondition -> @Override 	public int compareTo(PatternsRequestCondition other, ServerWebExchange exchange);1486652296;Compare the two conditions based on the URL patterns they contain._Patterns are compared one at a time, from top to bottom via_{@link PathPatternRegistry#getComparator(String)}. If all compared_patterns match equally, but one instance has more patterns, it is_considered a closer match._<p>It is assumed that both instances have been obtained via_{@link #getMatchingCondition(ServerWebExchange)} to ensure they_contain only patterns that match the request and are sorted with_the best matches on top.;@Override_	public int compareTo(PatternsRequestCondition other, ServerWebExchange exchange) {_		String lookupPath = this.pathHelper.getLookupPathForRequest(exchange)__		Comparator<PathPatternRegistry> comparator = this.patternRegistry.getComparator(lookupPath)__		return comparator.compare(this.patternRegistry, other.patternRegistry)__	};compare,the,two,conditions,based,on,the,url,patterns,they,contain,patterns,are,compared,one,at,a,time,from,top,to,bottom,via,link,path,pattern,registry,get,comparator,string,if,all,compared,patterns,match,equally,but,one,instance,has,more,patterns,it,is,considered,a,closer,match,p,it,is,assumed,that,both,instances,have,been,obtained,via,link,get,matching,condition,server,web,exchange,to,ensure,they,contain,only,patterns,that,match,the,request,and,are,sorted,with,the,best,matches,on,top;override,public,int,compare,to,patterns,request,condition,other,server,web,exchange,exchange,string,lookup,path,this,path,helper,get,lookup,path,for,request,exchange,comparator,path,pattern,registry,comparator,this,pattern,registry,get,comparator,lookup,path,return,comparator,compare,this,pattern,registry,other,pattern,registry
PatternsRequestCondition -> @Override 	public int compareTo(PatternsRequestCondition other, ServerWebExchange exchange);1486674586;Compare the two conditions based on the URL patterns they contain._Patterns are compared one at a time, from top to bottom via_{@link PathPatternRegistry#getComparator(String)}. If all compared_patterns match equally, but one instance has more patterns, it is_considered a closer match._<p>It is assumed that both instances have been obtained via_{@link #getMatchingCondition(ServerWebExchange)} to ensure they_contain only patterns that match the request and are sorted with_the best matches on top.;@Override_	public int compareTo(PatternsRequestCondition other, ServerWebExchange exchange) {_		String lookupPath = this.pathHelper.getLookupPathForRequest(exchange)__		Comparator<PathPatternRegistry> comparator = this.patternRegistry.getComparator(lookupPath)__		return comparator.compare(this.patternRegistry, other.patternRegistry)__	};compare,the,two,conditions,based,on,the,url,patterns,they,contain,patterns,are,compared,one,at,a,time,from,top,to,bottom,via,link,path,pattern,registry,get,comparator,string,if,all,compared,patterns,match,equally,but,one,instance,has,more,patterns,it,is,considered,a,closer,match,p,it,is,assumed,that,both,instances,have,been,obtained,via,link,get,matching,condition,server,web,exchange,to,ensure,they,contain,only,patterns,that,match,the,request,and,are,sorted,with,the,best,matches,on,top;override,public,int,compare,to,patterns,request,condition,other,server,web,exchange,exchange,string,lookup,path,this,path,helper,get,lookup,path,for,request,exchange,comparator,path,pattern,registry,comparator,this,pattern,registry,get,comparator,lookup,path,return,comparator,compare,this,pattern,registry,other,pattern,registry
PatternsRequestCondition -> @Override 	public int compareTo(PatternsRequestCondition other, ServerWebExchange exchange);1486747801;Compare the two conditions based on the URL patterns they contain._Patterns are compared one at a time, from top to bottom via_{@link PathMatcher#getPatternComparator(String)}. If all compared_patterns match equally, but one instance has more patterns, it is_considered a closer match._<p>It is assumed that both instances have been obtained via_{@link #getMatchingCondition(ServerWebExchange)} to ensure they_contain only patterns that match the request and are sorted with_the best matches on top.;@Override_	public int compareTo(PatternsRequestCondition other, ServerWebExchange exchange) {_		String lookupPath = this.pathHelper.getLookupPathForRequest(exchange)__		Comparator<String> patternComparator = this.pathMatcher.getPatternComparator(lookupPath)__		Iterator<String> iterator = this.patterns.iterator()__		Iterator<String> iteratorOther = other.patterns.iterator()__		while (iterator.hasNext() && iteratorOther.hasNext()) {_			int result = patternComparator.compare(iterator.next(), iteratorOther.next())__			if (result != 0) {_				return result__			}_		}_		if (iterator.hasNext()) {_			return -1__		}_		else if (iteratorOther.hasNext()) {_			return 1__		}_		else {_			return 0__		}_	};compare,the,two,conditions,based,on,the,url,patterns,they,contain,patterns,are,compared,one,at,a,time,from,top,to,bottom,via,link,path,matcher,get,pattern,comparator,string,if,all,compared,patterns,match,equally,but,one,instance,has,more,patterns,it,is,considered,a,closer,match,p,it,is,assumed,that,both,instances,have,been,obtained,via,link,get,matching,condition,server,web,exchange,to,ensure,they,contain,only,patterns,that,match,the,request,and,are,sorted,with,the,best,matches,on,top;override,public,int,compare,to,patterns,request,condition,other,server,web,exchange,exchange,string,lookup,path,this,path,helper,get,lookup,path,for,request,exchange,comparator,string,pattern,comparator,this,path,matcher,get,pattern,comparator,lookup,path,iterator,string,iterator,this,patterns,iterator,iterator,string,iterator,other,other,patterns,iterator,while,iterator,has,next,iterator,other,has,next,int,result,pattern,comparator,compare,iterator,next,iterator,other,next,if,result,0,return,result,if,iterator,has,next,return,1,else,if,iterator,other,has,next,return,1,else,return,0
PatternsRequestCondition -> @Override 	public int compareTo(PatternsRequestCondition other, ServerWebExchange exchange);1495035625;Compare the two conditions based on the URL patterns they contain._Patterns are compared one at a time, from top to bottom via_{@link PathMatcher#getPatternComparator(String)}. If all compared_patterns match equally, but one instance has more patterns, it is_considered a closer match._<p>It is assumed that both instances have been obtained via_{@link #getMatchingCondition(ServerWebExchange)} to ensure they_contain only patterns that match the request and are sorted with_the best matches on top.;@Override_	public int compareTo(PatternsRequestCondition other, ServerWebExchange exchange) {_		String lookupPath = this.pathHelper.getLookupPathForRequest(exchange)__		Comparator<String> patternComparator = this.pathMatcher.getPatternComparator(lookupPath)__		Iterator<String> iterator = this.patterns.iterator()__		Iterator<String> iteratorOther = other.patterns.iterator()__		while (iterator.hasNext() && iteratorOther.hasNext()) {_			int result = patternComparator.compare(iterator.next(), iteratorOther.next())__			if (result != 0) {_				return result__			}_		}_		if (iterator.hasNext()) {_			return -1__		}_		else if (iteratorOther.hasNext()) {_			return 1__		}_		else {_			return 0__		}_	};compare,the,two,conditions,based,on,the,url,patterns,they,contain,patterns,are,compared,one,at,a,time,from,top,to,bottom,via,link,path,matcher,get,pattern,comparator,string,if,all,compared,patterns,match,equally,but,one,instance,has,more,patterns,it,is,considered,a,closer,match,p,it,is,assumed,that,both,instances,have,been,obtained,via,link,get,matching,condition,server,web,exchange,to,ensure,they,contain,only,patterns,that,match,the,request,and,are,sorted,with,the,best,matches,on,top;override,public,int,compare,to,patterns,request,condition,other,server,web,exchange,exchange,string,lookup,path,this,path,helper,get,lookup,path,for,request,exchange,comparator,string,pattern,comparator,this,path,matcher,get,pattern,comparator,lookup,path,iterator,string,iterator,this,patterns,iterator,iterator,string,iterator,other,other,patterns,iterator,while,iterator,has,next,iterator,other,has,next,int,result,pattern,comparator,compare,iterator,next,iterator,other,next,if,result,0,return,result,if,iterator,has,next,return,1,else,if,iterator,other,has,next,return,1,else,return,0
PatternsRequestCondition -> @Override 	public int compareTo(PatternsRequestCondition other, ServerWebExchange exchange);1496334664;Compare the two conditions based on the URL patterns they contain._Patterns are compared one at a time, from top to bottom via_{@link PathMatcher#getPatternComparator(String)}. If all compared_patterns match equally, but one instance has more patterns, it is_considered a closer match._<p>It is assumed that both instances have been obtained via_{@link #getMatchingCondition(ServerWebExchange)} to ensure they_contain only patterns that match the request and are sorted with_the best matches on top.;@Override_	public int compareTo(PatternsRequestCondition other, ServerWebExchange exchange) {_		LookupPath lookupPath = exchange_				.<LookupPath>getAttribute(LookupPath.LOOKUP_PATH_ATTRIBUTE).get()__		Comparator<String> patternComparator = this.pathMatcher.getPatternComparator(lookupPath.getPath())__		Iterator<String> iterator = this.patterns.iterator()__		Iterator<String> iteratorOther = other.patterns.iterator()__		while (iterator.hasNext() && iteratorOther.hasNext()) {_			int result = patternComparator.compare(iterator.next(), iteratorOther.next())__			if (result != 0) {_				return result__			}_		}_		if (iterator.hasNext()) {_			return -1__		}_		else if (iteratorOther.hasNext()) {_			return 1__		}_		else {_			return 0__		}_	};compare,the,two,conditions,based,on,the,url,patterns,they,contain,patterns,are,compared,one,at,a,time,from,top,to,bottom,via,link,path,matcher,get,pattern,comparator,string,if,all,compared,patterns,match,equally,but,one,instance,has,more,patterns,it,is,considered,a,closer,match,p,it,is,assumed,that,both,instances,have,been,obtained,via,link,get,matching,condition,server,web,exchange,to,ensure,they,contain,only,patterns,that,match,the,request,and,are,sorted,with,the,best,matches,on,top;override,public,int,compare,to,patterns,request,condition,other,server,web,exchange,exchange,lookup,path,lookup,path,exchange,lookup,path,get,attribute,lookup,path,get,comparator,string,pattern,comparator,this,path,matcher,get,pattern,comparator,lookup,path,get,path,iterator,string,iterator,this,patterns,iterator,iterator,string,iterator,other,other,patterns,iterator,while,iterator,has,next,iterator,other,has,next,int,result,pattern,comparator,compare,iterator,next,iterator,other,next,if,result,0,return,result,if,iterator,has,next,return,1,else,if,iterator,other,has,next,return,1,else,return,0
PatternsRequestCondition -> @Override 	public int compareTo(PatternsRequestCondition other, ServerWebExchange exchange);1496429194;Compare the two conditions based on the URL patterns they contain._Patterns are compared one at a time, from top to bottom via_{@link PathMatcher#getPatternComparator(String)}. If all compared_patterns match equally, but one instance has more patterns, it is_considered a closer match._<p>It is assumed that both instances have been obtained via_{@link #getMatchingCondition(ServerWebExchange)} to ensure they_contain only patterns that match the request and are sorted with_the best matches on top.;@Override_	public int compareTo(PatternsRequestCondition other, ServerWebExchange exchange) {_		LookupPath lookupPath = getLookupPath(exchange)__		Comparator<String> patternComparator = this.pathMatcher.getPatternComparator(lookupPath.getPath())__		Iterator<String> iterator = this.patterns.iterator()__		Iterator<String> iteratorOther = other.patterns.iterator()__		while (iterator.hasNext() && iteratorOther.hasNext()) {_			int result = patternComparator.compare(iterator.next(), iteratorOther.next())__			if (result != 0) {_				return result__			}_		}_		if (iterator.hasNext()) {_			return -1__		}_		else if (iteratorOther.hasNext()) {_			return 1__		}_		else {_			return 0__		}_	};compare,the,two,conditions,based,on,the,url,patterns,they,contain,patterns,are,compared,one,at,a,time,from,top,to,bottom,via,link,path,matcher,get,pattern,comparator,string,if,all,compared,patterns,match,equally,but,one,instance,has,more,patterns,it,is,considered,a,closer,match,p,it,is,assumed,that,both,instances,have,been,obtained,via,link,get,matching,condition,server,web,exchange,to,ensure,they,contain,only,patterns,that,match,the,request,and,are,sorted,with,the,best,matches,on,top;override,public,int,compare,to,patterns,request,condition,other,server,web,exchange,exchange,lookup,path,lookup,path,get,lookup,path,exchange,comparator,string,pattern,comparator,this,path,matcher,get,pattern,comparator,lookup,path,get,path,iterator,string,iterator,this,patterns,iterator,iterator,string,iterator,other,other,patterns,iterator,while,iterator,has,next,iterator,other,has,next,int,result,pattern,comparator,compare,iterator,next,iterator,other,next,if,result,0,return,result,if,iterator,has,next,return,1,else,if,iterator,other,has,next,return,1,else,return,0
PatternsRequestCondition -> @Override 	public int compareTo(PatternsRequestCondition other, ServerWebExchange exchange);1496430942;Compare the two conditions based on the URL patterns they contain._Patterns are compared one at a time, from top to bottom via_{@link PathMatcher#getPatternComparator(String)}. If all compared_patterns match equally, but one instance has more patterns, it is_considered a closer match._<p>It is assumed that both instances have been obtained via_{@link #getMatchingCondition(ServerWebExchange)} to ensure they_contain only patterns that match the request and are sorted with_the best matches on top.;@Override_	public int compareTo(PatternsRequestCondition other, ServerWebExchange exchange) {_		String path = LookupPath.getCurrent(exchange).getPath()__		Comparator<String> patternComparator = this.pathMatcher.getPatternComparator(path)__		Iterator<String> iterator = this.patterns.iterator()__		Iterator<String> iteratorOther = other.patterns.iterator()__		while (iterator.hasNext() && iteratorOther.hasNext()) {_			int result = patternComparator.compare(iterator.next(), iteratorOther.next())__			if (result != 0) {_				return result__			}_		}_		if (iterator.hasNext()) {_			return -1__		}_		else if (iteratorOther.hasNext()) {_			return 1__		}_		else {_			return 0__		}_	};compare,the,two,conditions,based,on,the,url,patterns,they,contain,patterns,are,compared,one,at,a,time,from,top,to,bottom,via,link,path,matcher,get,pattern,comparator,string,if,all,compared,patterns,match,equally,but,one,instance,has,more,patterns,it,is,considered,a,closer,match,p,it,is,assumed,that,both,instances,have,been,obtained,via,link,get,matching,condition,server,web,exchange,to,ensure,they,contain,only,patterns,that,match,the,request,and,are,sorted,with,the,best,matches,on,top;override,public,int,compare,to,patterns,request,condition,other,server,web,exchange,exchange,string,path,lookup,path,get,current,exchange,get,path,comparator,string,pattern,comparator,this,path,matcher,get,pattern,comparator,path,iterator,string,iterator,this,patterns,iterator,iterator,string,iterator,other,other,patterns,iterator,while,iterator,has,next,iterator,other,has,next,int,result,pattern,comparator,compare,iterator,next,iterator,other,next,if,result,0,return,result,if,iterator,has,next,return,1,else,if,iterator,other,has,next,return,1,else,return,0
PatternsRequestCondition -> @Override 	public int compareTo(PatternsRequestCondition other, ServerWebExchange exchange);1497039338;Compare the two conditions based on the URL patterns they contain._Patterns are compared one at a time, from top to bottom via_{@link PathMatcher#getPatternComparator(String)}. If all compared_patterns match equally, but one instance has more patterns, it is_considered a closer match._<p>It is assumed that both instances have been obtained via_{@link #getMatchingCondition(ServerWebExchange)} to ensure they_contain only patterns that match the request and are sorted with_the best matches on top.;@Override_	public int compareTo(PatternsRequestCondition other, ServerWebExchange exchange) {_		String lookupPath = exchange.getRequest().getPathWithinApplication()__		Comparator<String> patternComparator = this.pathMatcher.getPatternComparator(lookupPath)__		Iterator<String> iterator = this.patterns.iterator()__		Iterator<String> iteratorOther = other.patterns.iterator()__		while (iterator.hasNext() && iteratorOther.hasNext()) {_			int result = patternComparator.compare(iterator.next(), iteratorOther.next())__			if (result != 0) {_				return result__			}_		}_		if (iterator.hasNext()) {_			return -1__		}_		else if (iteratorOther.hasNext()) {_			return 1__		}_		else {_			return 0__		}_	};compare,the,two,conditions,based,on,the,url,patterns,they,contain,patterns,are,compared,one,at,a,time,from,top,to,bottom,via,link,path,matcher,get,pattern,comparator,string,if,all,compared,patterns,match,equally,but,one,instance,has,more,patterns,it,is,considered,a,closer,match,p,it,is,assumed,that,both,instances,have,been,obtained,via,link,get,matching,condition,server,web,exchange,to,ensure,they,contain,only,patterns,that,match,the,request,and,are,sorted,with,the,best,matches,on,top;override,public,int,compare,to,patterns,request,condition,other,server,web,exchange,exchange,string,lookup,path,exchange,get,request,get,path,within,application,comparator,string,pattern,comparator,this,path,matcher,get,pattern,comparator,lookup,path,iterator,string,iterator,this,patterns,iterator,iterator,string,iterator,other,other,patterns,iterator,while,iterator,has,next,iterator,other,has,next,int,result,pattern,comparator,compare,iterator,next,iterator,other,next,if,result,0,return,result,if,iterator,has,next,return,1,else,if,iterator,other,has,next,return,1,else,return,0
PatternsRequestCondition -> @Override 	public int compareTo(PatternsRequestCondition other, ServerWebExchange exchange);1497232764;Compare the two conditions based on the URL patterns they contain._Patterns are compared one at a time, from top to bottom via_{@link PathMatcher#getPatternComparator(String)}. If all compared_patterns match equally, but one instance has more patterns, it is_considered a closer match._<p>It is assumed that both instances have been obtained via_{@link #getMatchingCondition(ServerWebExchange)} to ensure they_contain only patterns that match the request and are sorted with_the best matches on top.;@Override_	public int compareTo(PatternsRequestCondition other, ServerWebExchange exchange) {_		String lookupPath = exchange.getRequest().getPath().pathWithinApplication().value()__		Comparator<String> patternComparator = this.pathMatcher.getPatternComparator(lookupPath)__		Iterator<String> iterator = this.patterns.iterator()__		Iterator<String> iteratorOther = other.patterns.iterator()__		while (iterator.hasNext() && iteratorOther.hasNext()) {_			int result = patternComparator.compare(iterator.next(), iteratorOther.next())__			if (result != 0) {_				return result__			}_		}_		if (iterator.hasNext()) {_			return -1__		}_		else if (iteratorOther.hasNext()) {_			return 1__		}_		else {_			return 0__		}_	};compare,the,two,conditions,based,on,the,url,patterns,they,contain,patterns,are,compared,one,at,a,time,from,top,to,bottom,via,link,path,matcher,get,pattern,comparator,string,if,all,compared,patterns,match,equally,but,one,instance,has,more,patterns,it,is,considered,a,closer,match,p,it,is,assumed,that,both,instances,have,been,obtained,via,link,get,matching,condition,server,web,exchange,to,ensure,they,contain,only,patterns,that,match,the,request,and,are,sorted,with,the,best,matches,on,top;override,public,int,compare,to,patterns,request,condition,other,server,web,exchange,exchange,string,lookup,path,exchange,get,request,get,path,path,within,application,value,comparator,string,pattern,comparator,this,path,matcher,get,pattern,comparator,lookup,path,iterator,string,iterator,this,patterns,iterator,iterator,string,iterator,other,other,patterns,iterator,while,iterator,has,next,iterator,other,has,next,int,result,pattern,comparator,compare,iterator,next,iterator,other,next,if,result,0,return,result,if,iterator,has,next,return,1,else,if,iterator,other,has,next,return,1,else,return,0
PatternsRequestCondition -> @Override 	public int compareTo(PatternsRequestCondition other, ServerWebExchange exchange);1497286385;Compare the two conditions based on the URL patterns they contain._Patterns are compared one at a time, from top to bottom via_{@link PathPatternComparator}. If all compared_patterns match equally, but one instance has more patterns, it is_considered a closer match._<p>It is assumed that both instances have been obtained via_{@link #getMatchingCondition(ServerWebExchange)} to ensure they_contain only patterns that match the request and are sorted with_the best matches on top.;@Override_	public int compareTo(PatternsRequestCondition other, ServerWebExchange exchange) {_		String lookupPath = exchange.getRequest().getPath().pathWithinApplication().value()__		PathPatternComparator comparator = new PathPatternComparator(lookupPath)__		Iterator<PathPattern> iterator = this.patterns.stream()_				.sorted(comparator).collect(Collectors.toList()).iterator()__		Iterator<PathPattern> iteratorOther = other.getPatterns().stream()_				.sorted(comparator).collect(Collectors.toList()).iterator()__		while (iterator.hasNext() && iteratorOther.hasNext()) {_			int result = comparator.compare(iterator.next(), iteratorOther.next())__			if (result != 0) {_				return result__			}_		}_		if (iterator.hasNext()) {_			return -1__		}_		else if (iteratorOther.hasNext()) {_			return 1__		}_		else {_			return 0__		}_	};compare,the,two,conditions,based,on,the,url,patterns,they,contain,patterns,are,compared,one,at,a,time,from,top,to,bottom,via,link,path,pattern,comparator,if,all,compared,patterns,match,equally,but,one,instance,has,more,patterns,it,is,considered,a,closer,match,p,it,is,assumed,that,both,instances,have,been,obtained,via,link,get,matching,condition,server,web,exchange,to,ensure,they,contain,only,patterns,that,match,the,request,and,are,sorted,with,the,best,matches,on,top;override,public,int,compare,to,patterns,request,condition,other,server,web,exchange,exchange,string,lookup,path,exchange,get,request,get,path,path,within,application,value,path,pattern,comparator,comparator,new,path,pattern,comparator,lookup,path,iterator,path,pattern,iterator,this,patterns,stream,sorted,comparator,collect,collectors,to,list,iterator,iterator,path,pattern,iterator,other,other,get,patterns,stream,sorted,comparator,collect,collectors,to,list,iterator,while,iterator,has,next,iterator,other,has,next,int,result,comparator,compare,iterator,next,iterator,other,next,if,result,0,return,result,if,iterator,has,next,return,1,else,if,iterator,other,has,next,return,1,else,return,0
PatternsRequestCondition -> @Override 	public int compareTo(PatternsRequestCondition other, ServerWebExchange exchange);1498861175;Compare the two conditions based on the URL patterns they contain._Patterns are compared one at a time, from top to bottom via_{@link PathPatternComparator}. If all compared_patterns match equally, but one instance has more patterns, it is_considered a closer match._<p>It is assumed that both instances have been obtained via_{@link #getMatchingCondition(ServerWebExchange)} to ensure they_contain only patterns that match the request and are sorted with_the best matches on top.;@Override_	public int compareTo(PatternsRequestCondition other, ServerWebExchange exchange) {_		String lookupPath = exchange.getRequest().getPath().pathWithinApplication().value()__		PathPatternComparator comparator = new PathPatternComparator(lookupPath)__		Iterator<PathPattern> iterator = this.patterns.stream()_				.sorted(comparator).collect(Collectors.toList()).iterator()__		Iterator<PathPattern> iteratorOther = other.getPatterns().stream()_				.sorted(comparator).collect(Collectors.toList()).iterator()__		while (iterator.hasNext() && iteratorOther.hasNext()) {_			int result = comparator.compare(iterator.next(), iteratorOther.next())__			if (result != 0) {_				return result__			}_		}_		if (iterator.hasNext()) {_			return -1__		}_		else if (iteratorOther.hasNext()) {_			return 1__		}_		else {_			return 0__		}_	};compare,the,two,conditions,based,on,the,url,patterns,they,contain,patterns,are,compared,one,at,a,time,from,top,to,bottom,via,link,path,pattern,comparator,if,all,compared,patterns,match,equally,but,one,instance,has,more,patterns,it,is,considered,a,closer,match,p,it,is,assumed,that,both,instances,have,been,obtained,via,link,get,matching,condition,server,web,exchange,to,ensure,they,contain,only,patterns,that,match,the,request,and,are,sorted,with,the,best,matches,on,top;override,public,int,compare,to,patterns,request,condition,other,server,web,exchange,exchange,string,lookup,path,exchange,get,request,get,path,path,within,application,value,path,pattern,comparator,comparator,new,path,pattern,comparator,lookup,path,iterator,path,pattern,iterator,this,patterns,stream,sorted,comparator,collect,collectors,to,list,iterator,iterator,path,pattern,iterator,other,other,get,patterns,stream,sorted,comparator,collect,collectors,to,list,iterator,while,iterator,has,next,iterator,other,has,next,int,result,comparator,compare,iterator,next,iterator,other,next,if,result,0,return,result,if,iterator,has,next,return,1,else,if,iterator,other,has,next,return,1,else,return,0
PatternsRequestCondition -> @Override 	public int compareTo(PatternsRequestCondition other, ServerWebExchange exchange);1498861175;Compare the two conditions based on the URL patterns they contain._Patterns are compared one at a time, from top to bottom. If all compared_patterns match equally, but one instance has more patterns, it is_considered a closer match._<p>It is assumed that both instances have been obtained via_{@link #getMatchingCondition(ServerWebExchange)} to ensure they_contain only patterns that match the request and are sorted with_the best matches on top.;@Override_	public int compareTo(PatternsRequestCondition other, ServerWebExchange exchange) {_		Iterator<PathPattern> iterator = this.patterns.iterator()__		Iterator<PathPattern> iteratorOther = other.getPatterns().iterator()__		while (iterator.hasNext() && iteratorOther.hasNext()) {_			int result = iterator.next().compareTo(iteratorOther.next())__			if (result != 0) {_				return result__			}_		}_		if (iterator.hasNext()) {_			return -1__		}_		else if (iteratorOther.hasNext()) {_			return 1__		}_		else {_			return 0__		}_	};compare,the,two,conditions,based,on,the,url,patterns,they,contain,patterns,are,compared,one,at,a,time,from,top,to,bottom,if,all,compared,patterns,match,equally,but,one,instance,has,more,patterns,it,is,considered,a,closer,match,p,it,is,assumed,that,both,instances,have,been,obtained,via,link,get,matching,condition,server,web,exchange,to,ensure,they,contain,only,patterns,that,match,the,request,and,are,sorted,with,the,best,matches,on,top;override,public,int,compare,to,patterns,request,condition,other,server,web,exchange,exchange,iterator,path,pattern,iterator,this,patterns,iterator,iterator,path,pattern,iterator,other,other,get,patterns,iterator,while,iterator,has,next,iterator,other,has,next,int,result,iterator,next,compare,to,iterator,other,next,if,result,0,return,result,if,iterator,has,next,return,1,else,if,iterator,other,has,next,return,1,else,return,0
PatternsRequestCondition -> @Override 	public int compareTo(PatternsRequestCondition other, ServerWebExchange exchange);1498944474;Compare the two conditions based on the URL patterns they contain._Patterns are compared one at a time, from top to bottom. If all compared_patterns match equally, but one instance has more patterns, it is_considered a closer match._<p>It is assumed that both instances have been obtained via_{@link #getMatchingCondition(ServerWebExchange)} to ensure they_contain only patterns that match the request and are sorted with_the best matches on top.;@Override_	public int compareTo(PatternsRequestCondition other, ServerWebExchange exchange) {_		Iterator<PathPattern> iterator = this.patterns.iterator()__		Iterator<PathPattern> iteratorOther = other.getPatterns().iterator()__		while (iterator.hasNext() && iteratorOther.hasNext()) {_			int result = iterator.next().compareTo(iteratorOther.next())__			if (result != 0) {_				return result__			}_		}_		if (iterator.hasNext()) {_			return -1__		}_		else if (iteratorOther.hasNext()) {_			return 1__		}_		else {_			return 0__		}_	};compare,the,two,conditions,based,on,the,url,patterns,they,contain,patterns,are,compared,one,at,a,time,from,top,to,bottom,if,all,compared,patterns,match,equally,but,one,instance,has,more,patterns,it,is,considered,a,closer,match,p,it,is,assumed,that,both,instances,have,been,obtained,via,link,get,matching,condition,server,web,exchange,to,ensure,they,contain,only,patterns,that,match,the,request,and,are,sorted,with,the,best,matches,on,top;override,public,int,compare,to,patterns,request,condition,other,server,web,exchange,exchange,iterator,path,pattern,iterator,this,patterns,iterator,iterator,path,pattern,iterator,other,other,get,patterns,iterator,while,iterator,has,next,iterator,other,has,next,int,result,iterator,next,compare,to,iterator,other,next,if,result,0,return,result,if,iterator,has,next,return,1,else,if,iterator,other,has,next,return,1,else,return,0
PatternsRequestCondition -> @Override 	public int compareTo(PatternsRequestCondition other, ServerWebExchange exchange);1500370830;Compare the two conditions based on the URL patterns they contain._Patterns are compared one at a time, from top to bottom. If all compared_patterns match equally, but one instance has more patterns, it is_considered a closer match._<p>It is assumed that both instances have been obtained via_{@link #getMatchingCondition(ServerWebExchange)} to ensure they_contain only patterns that match the request and are sorted with_the best matches on top.;@Override_	public int compareTo(PatternsRequestCondition other, ServerWebExchange exchange) {_		Iterator<PathPattern> iterator = this.patterns.iterator()__		Iterator<PathPattern> iteratorOther = other.getPatterns().iterator()__		while (iterator.hasNext() && iteratorOther.hasNext()) {_			int result = iterator.next().compareTo(iteratorOther.next())__			if (result != 0) {_				return result__			}_		}_		if (iterator.hasNext()) {_			return -1__		}_		else if (iteratorOther.hasNext()) {_			return 1__		}_		else {_			return 0__		}_	};compare,the,two,conditions,based,on,the,url,patterns,they,contain,patterns,are,compared,one,at,a,time,from,top,to,bottom,if,all,compared,patterns,match,equally,but,one,instance,has,more,patterns,it,is,considered,a,closer,match,p,it,is,assumed,that,both,instances,have,been,obtained,via,link,get,matching,condition,server,web,exchange,to,ensure,they,contain,only,patterns,that,match,the,request,and,are,sorted,with,the,best,matches,on,top;override,public,int,compare,to,patterns,request,condition,other,server,web,exchange,exchange,iterator,path,pattern,iterator,this,patterns,iterator,iterator,path,pattern,iterator,other,other,get,patterns,iterator,while,iterator,has,next,iterator,other,has,next,int,result,iterator,next,compare,to,iterator,other,next,if,result,0,return,result,if,iterator,has,next,return,1,else,if,iterator,other,has,next,return,1,else,return,0
PatternsRequestCondition -> @Override 	public int compareTo(PatternsRequestCondition other, ServerWebExchange exchange);1501237594;Compare the two conditions based on the URL patterns they contain._Patterns are compared one at a time, from top to bottom. If all compared_patterns match equally, but one instance has more patterns, it is_considered a closer match._<p>It is assumed that both instances have been obtained via_{@link #getMatchingCondition(ServerWebExchange)} to ensure they_contain only patterns that match the request and are sorted with_the best matches on top.;@Override_	public int compareTo(PatternsRequestCondition other, ServerWebExchange exchange) {_		Iterator<PathPattern> iterator = this.patterns.iterator()__		Iterator<PathPattern> iteratorOther = other.getPatterns().iterator()__		while (iterator.hasNext() && iteratorOther.hasNext()) {_			int result = iterator.next().compareTo(iteratorOther.next())__			if (result != 0) {_				return result__			}_		}_		if (iterator.hasNext()) {_			return -1__		}_		else if (iteratorOther.hasNext()) {_			return 1__		}_		else {_			return 0__		}_	};compare,the,two,conditions,based,on,the,url,patterns,they,contain,patterns,are,compared,one,at,a,time,from,top,to,bottom,if,all,compared,patterns,match,equally,but,one,instance,has,more,patterns,it,is,considered,a,closer,match,p,it,is,assumed,that,both,instances,have,been,obtained,via,link,get,matching,condition,server,web,exchange,to,ensure,they,contain,only,patterns,that,match,the,request,and,are,sorted,with,the,best,matches,on,top;override,public,int,compare,to,patterns,request,condition,other,server,web,exchange,exchange,iterator,path,pattern,iterator,this,patterns,iterator,iterator,path,pattern,iterator,other,other,get,patterns,iterator,while,iterator,has,next,iterator,other,has,next,int,result,iterator,next,compare,to,iterator,other,next,if,result,0,return,result,if,iterator,has,next,return,1,else,if,iterator,other,has,next,return,1,else,return,0
PatternsRequestCondition -> @Override 	public int compareTo(PatternsRequestCondition other, ServerWebExchange exchange);1501690296;Compare the two conditions based on the URL patterns they contain._Patterns are compared one at a time, from top to bottom. If all compared_patterns match equally, but one instance has more patterns, it is_considered a closer match._<p>It is assumed that both instances have been obtained via_{@link #getMatchingCondition(ServerWebExchange)} to ensure they_contain only patterns that match the request and are sorted with_the best matches on top.;@Override_	public int compareTo(PatternsRequestCondition other, ServerWebExchange exchange) {_		Iterator<PathPattern> iterator = this.patterns.iterator()__		Iterator<PathPattern> iteratorOther = other.getPatterns().iterator()__		while (iterator.hasNext() && iteratorOther.hasNext()) {_			int result = PathPattern.SPECIFICITY_COMPARATOR.compare(iterator.next(), iteratorOther.next())__			if (result != 0) {_				return result__			}_		}_		if (iterator.hasNext()) {_			return -1__		}_		else if (iteratorOther.hasNext()) {_			return 1__		}_		else {_			return 0__		}_	};compare,the,two,conditions,based,on,the,url,patterns,they,contain,patterns,are,compared,one,at,a,time,from,top,to,bottom,if,all,compared,patterns,match,equally,but,one,instance,has,more,patterns,it,is,considered,a,closer,match,p,it,is,assumed,that,both,instances,have,been,obtained,via,link,get,matching,condition,server,web,exchange,to,ensure,they,contain,only,patterns,that,match,the,request,and,are,sorted,with,the,best,matches,on,top;override,public,int,compare,to,patterns,request,condition,other,server,web,exchange,exchange,iterator,path,pattern,iterator,this,patterns,iterator,iterator,path,pattern,iterator,other,other,get,patterns,iterator,while,iterator,has,next,iterator,other,has,next,int,result,path,pattern,compare,iterator,next,iterator,other,next,if,result,0,return,result,if,iterator,has,next,return,1,else,if,iterator,other,has,next,return,1,else,return,0
PatternsRequestCondition -> @Override 	public int compareTo(PatternsRequestCondition other, ServerWebExchange exchange);1530174524;Compare the two conditions based on the URL patterns they contain._Patterns are compared one at a time, from top to bottom. If all compared_patterns match equally, but one instance has more patterns, it is_considered a closer match._<p>It is assumed that both instances have been obtained via_{@link #getMatchingCondition(ServerWebExchange)} to ensure they_contain only patterns that match the request and are sorted with_the best matches on top.;@Override_	public int compareTo(PatternsRequestCondition other, ServerWebExchange exchange) {_		Iterator<PathPattern> iterator = this.patterns.iterator()__		Iterator<PathPattern> iteratorOther = other.getPatterns().iterator()__		while (iterator.hasNext() && iteratorOther.hasNext()) {_			int result = PathPattern.SPECIFICITY_COMPARATOR.compare(iterator.next(), iteratorOther.next())__			if (result != 0) {_				return result__			}_		}_		if (iterator.hasNext()) {_			return -1__		}_		else if (iteratorOther.hasNext()) {_			return 1__		}_		else {_			return 0__		}_	};compare,the,two,conditions,based,on,the,url,patterns,they,contain,patterns,are,compared,one,at,a,time,from,top,to,bottom,if,all,compared,patterns,match,equally,but,one,instance,has,more,patterns,it,is,considered,a,closer,match,p,it,is,assumed,that,both,instances,have,been,obtained,via,link,get,matching,condition,server,web,exchange,to,ensure,they,contain,only,patterns,that,match,the,request,and,are,sorted,with,the,best,matches,on,top;override,public,int,compare,to,patterns,request,condition,other,server,web,exchange,exchange,iterator,path,pattern,iterator,this,patterns,iterator,iterator,path,pattern,iterator,other,other,get,patterns,iterator,while,iterator,has,next,iterator,other,has,next,int,result,path,pattern,compare,iterator,next,iterator,other,next,if,result,0,return,result,if,iterator,has,next,return,1,else,if,iterator,other,has,next,return,1,else,return,0
PatternsRequestCondition -> @Override 	public int compareTo(PatternsRequestCondition other, ServerWebExchange exchange);1530190293;Compare the two conditions based on the URL patterns they contain._Patterns are compared one at a time, from top to bottom. If all compared_patterns match equally, but one instance has more patterns, it is_considered a closer match._<p>It is assumed that both instances have been obtained via_{@link #getMatchingCondition(ServerWebExchange)} to ensure they_contain only patterns that match the request and are sorted with_the best matches on top.;@Override_	public int compareTo(PatternsRequestCondition other, ServerWebExchange exchange) {_		Iterator<PathPattern> iterator = this.patterns.iterator()__		Iterator<PathPattern> iteratorOther = other.getPatterns().iterator()__		while (iterator.hasNext() && iteratorOther.hasNext()) {_			int result = PathPattern.SPECIFICITY_COMPARATOR.compare(iterator.next(), iteratorOther.next())__			if (result != 0) {_				return result__			}_		}_		if (iterator.hasNext()) {_			return -1__		}_		else if (iteratorOther.hasNext()) {_			return 1__		}_		else {_			return 0__		}_	};compare,the,two,conditions,based,on,the,url,patterns,they,contain,patterns,are,compared,one,at,a,time,from,top,to,bottom,if,all,compared,patterns,match,equally,but,one,instance,has,more,patterns,it,is,considered,a,closer,match,p,it,is,assumed,that,both,instances,have,been,obtained,via,link,get,matching,condition,server,web,exchange,to,ensure,they,contain,only,patterns,that,match,the,request,and,are,sorted,with,the,best,matches,on,top;override,public,int,compare,to,patterns,request,condition,other,server,web,exchange,exchange,iterator,path,pattern,iterator,this,patterns,iterator,iterator,path,pattern,iterator,other,other,get,patterns,iterator,while,iterator,has,next,iterator,other,has,next,int,result,path,pattern,compare,iterator,next,iterator,other,next,if,result,0,return,result,if,iterator,has,next,return,1,else,if,iterator,other,has,next,return,1,else,return,0
PatternsRequestCondition -> private PatternsRequestCondition(Collection<String> patterns, PathPatternParser patternParser);1497286385;Private constructor accepting a collection of raw patterns.;private PatternsRequestCondition(Collection<String> patterns, PathPatternParser patternParser) {_		this.parser = patternParser != null ? patternParser : new PathPatternParser()__		this.patterns = new ArrayList<>()__		patterns.forEach(pattern -> {_			if (StringUtils.hasText(pattern) && !pattern.startsWith("/")) {_				pattern = "/" + pattern__			}_			this.patterns.add(this.parser.parse(pattern))__		})__	};private,constructor,accepting,a,collection,of,raw,patterns;private,patterns,request,condition,collection,string,patterns,path,pattern,parser,pattern,parser,this,parser,pattern,parser,null,pattern,parser,new,path,pattern,parser,this,patterns,new,array,list,patterns,for,each,pattern,if,string,utils,has,text,pattern,pattern,starts,with,pattern,pattern,this,patterns,add,this,parser,parse,pattern
PatternsRequestCondition -> private PatternsRequestCondition(Collection<String> patterns, PathPatternParser patternParser);1498861175;Private constructor accepting a collection of raw patterns.;private PatternsRequestCondition(Collection<String> patterns, PathPatternParser patternParser) {_		this.parser = patternParser != null ? patternParser : new PathPatternParser()__		this.patterns = new ArrayList<>()__		patterns.forEach(pattern -> {_			if (StringUtils.hasText(pattern) && !pattern.startsWith("/")) {_				pattern = "/" + pattern__			}_			this.patterns.add(this.parser.parse(pattern))__		})__	};private,constructor,accepting,a,collection,of,raw,patterns;private,patterns,request,condition,collection,string,patterns,path,pattern,parser,pattern,parser,this,parser,pattern,parser,null,pattern,parser,new,path,pattern,parser,this,patterns,new,array,list,patterns,for,each,pattern,if,string,utils,has,text,pattern,pattern,starts,with,pattern,pattern,this,patterns,add,this,parser,parse,pattern
PatternsRequestCondition -> @Override 	@Nullable 	public PatternsRequestCondition getMatchingCondition(ServerWebExchange exchange);1497286385;Checks if any of the patterns match the given request and returns an instance_that is guaranteed to contain matching patterns, sorted with a_{@link PathPatternComparator}._@param exchange the current exchange_@return the same instance if the condition contains no patterns__or a new condition with sorted matching patterns__or {@code null} if no patterns match.;@Override_	@Nullable_	public PatternsRequestCondition getMatchingCondition(ServerWebExchange exchange) {_		if (this.patterns.isEmpty()) {_			return this__		}__		String lookupPath = exchange.getRequest().getPath().pathWithinApplication().value()__		SortedSet<PathPattern> matches = getMatchingPatterns(lookupPath)__		return matches.isEmpty() ? null : new PatternsRequestCondition(new ArrayList<>(matches), this.parser)__	};checks,if,any,of,the,patterns,match,the,given,request,and,returns,an,instance,that,is,guaranteed,to,contain,matching,patterns,sorted,with,a,link,path,pattern,comparator,param,exchange,the,current,exchange,return,the,same,instance,if,the,condition,contains,no,patterns,or,a,new,condition,with,sorted,matching,patterns,or,code,null,if,no,patterns,match;override,nullable,public,patterns,request,condition,get,matching,condition,server,web,exchange,exchange,if,this,patterns,is,empty,return,this,string,lookup,path,exchange,get,request,get,path,path,within,application,value,sorted,set,path,pattern,matches,get,matching,patterns,lookup,path,return,matches,is,empty,null,new,patterns,request,condition,new,array,list,matches,this,parser
PatternsRequestCondition -> @Override 	@Nullable 	public PatternsRequestCondition getMatchingCondition(ServerWebExchange exchange);1498861175;Checks if any of the patterns match the given request and returns an instance_that is guaranteed to contain matching patterns, sorted with a_{@link PathPatternComparator}._@param exchange the current exchange_@return the same instance if the condition contains no patterns__or a new condition with sorted matching patterns__or {@code null} if no patterns match.;@Override_	@Nullable_	public PatternsRequestCondition getMatchingCondition(ServerWebExchange exchange) {_		if (this.patterns.isEmpty()) {_			return this__		}__		String lookupPath = exchange.getRequest().getPath().pathWithinApplication().value()__		SortedSet<PathPattern> matches = getMatchingPatterns(lookupPath)__		return matches.isEmpty() ? null : new PatternsRequestCondition(_				new ArrayList<PathPattern>(matches), this.parser)__	};checks,if,any,of,the,patterns,match,the,given,request,and,returns,an,instance,that,is,guaranteed,to,contain,matching,patterns,sorted,with,a,link,path,pattern,comparator,param,exchange,the,current,exchange,return,the,same,instance,if,the,condition,contains,no,patterns,or,a,new,condition,with,sorted,matching,patterns,or,code,null,if,no,patterns,match;override,nullable,public,patterns,request,condition,get,matching,condition,server,web,exchange,exchange,if,this,patterns,is,empty,return,this,string,lookup,path,exchange,get,request,get,path,path,within,application,value,sorted,set,path,pattern,matches,get,matching,patterns,lookup,path,return,matches,is,empty,null,new,patterns,request,condition,new,array,list,path,pattern,matches,this,parser
PatternsRequestCondition -> @Override 	@Nullable 	public PatternsRequestCondition getMatchingCondition(ServerWebExchange exchange);1498861175;Checks if any of the patterns match the given request and returns an instance_that is guaranteed to contain matching patterns, sorted._@param exchange the current exchange_@return the same instance if the condition contains no patterns__or a new condition with sorted matching patterns__or {@code null} if no patterns match.;@Override_	@Nullable_	public PatternsRequestCondition getMatchingCondition(ServerWebExchange exchange) {_		if (this.patterns.isEmpty()) {_			return this__		}_		SortedSet<PathPattern> matches = getMatchingPatterns(exchange)__		return matches.isEmpty() ? null :_				new PatternsRequestCondition(new ArrayList<PathPattern>(matches), this.parser)__	};checks,if,any,of,the,patterns,match,the,given,request,and,returns,an,instance,that,is,guaranteed,to,contain,matching,patterns,sorted,param,exchange,the,current,exchange,return,the,same,instance,if,the,condition,contains,no,patterns,or,a,new,condition,with,sorted,matching,patterns,or,code,null,if,no,patterns,match;override,nullable,public,patterns,request,condition,get,matching,condition,server,web,exchange,exchange,if,this,patterns,is,empty,return,this,sorted,set,path,pattern,matches,get,matching,patterns,exchange,return,matches,is,empty,null,new,patterns,request,condition,new,array,list,path,pattern,matches,this,parser
PatternsRequestCondition -> @Override 	@Nullable 	public PatternsRequestCondition getMatchingCondition(ServerWebExchange exchange);1498944474;Checks if any of the patterns match the given request and returns an instance_that is guaranteed to contain matching patterns, sorted._@param exchange the current exchange_@return the same instance if the condition contains no patterns__or a new condition with sorted matching patterns__or {@code null} if no patterns match.;@Override_	@Nullable_	public PatternsRequestCondition getMatchingCondition(ServerWebExchange exchange) {_		if (this.patterns.isEmpty()) {_			return this__		}_		SortedSet<PathPattern> matches = getMatchingPatterns(exchange)__		return matches.isEmpty() ? null :_				new PatternsRequestCondition(new ArrayList<PathPattern>(matches), this.parser)__	};checks,if,any,of,the,patterns,match,the,given,request,and,returns,an,instance,that,is,guaranteed,to,contain,matching,patterns,sorted,param,exchange,the,current,exchange,return,the,same,instance,if,the,condition,contains,no,patterns,or,a,new,condition,with,sorted,matching,patterns,or,code,null,if,no,patterns,match;override,nullable,public,patterns,request,condition,get,matching,condition,server,web,exchange,exchange,if,this,patterns,is,empty,return,this,sorted,set,path,pattern,matches,get,matching,patterns,exchange,return,matches,is,empty,null,new,patterns,request,condition,new,array,list,path,pattern,matches,this,parser
PatternsRequestCondition -> @Override 	@Nullable 	public PatternsRequestCondition getMatchingCondition(ServerWebExchange exchange);1500370830;Checks if any of the patterns match the given request and returns an instance_that is guaranteed to contain matching patterns, sorted._@param exchange the current exchange_@return the same instance if the condition contains no patterns__or a new condition with sorted matching patterns__or {@code null} if no patterns match.;@Override_	@Nullable_	public PatternsRequestCondition getMatchingCondition(ServerWebExchange exchange) {_		if (this.patterns.isEmpty()) {_			return this__		}_		SortedSet<PathPattern> matches = getMatchingPatterns(exchange)__		return matches.isEmpty() ? null :_				new PatternsRequestCondition(matches)__	};checks,if,any,of,the,patterns,match,the,given,request,and,returns,an,instance,that,is,guaranteed,to,contain,matching,patterns,sorted,param,exchange,the,current,exchange,return,the,same,instance,if,the,condition,contains,no,patterns,or,a,new,condition,with,sorted,matching,patterns,or,code,null,if,no,patterns,match;override,nullable,public,patterns,request,condition,get,matching,condition,server,web,exchange,exchange,if,this,patterns,is,empty,return,this,sorted,set,path,pattern,matches,get,matching,patterns,exchange,return,matches,is,empty,null,new,patterns,request,condition,matches
PatternsRequestCondition -> @Override 	@Nullable 	public PatternsRequestCondition getMatchingCondition(ServerWebExchange exchange);1501237594;Checks if any of the patterns match the given request and returns an instance_that is guaranteed to contain matching patterns, sorted._@param exchange the current exchange_@return the same instance if the condition contains no patterns__or a new condition with sorted matching patterns__or {@code null} if no patterns match.;@Override_	@Nullable_	public PatternsRequestCondition getMatchingCondition(ServerWebExchange exchange) {_		if (this.patterns.isEmpty()) {_			return this__		}_		SortedSet<PathPattern> matches = getMatchingPatterns(exchange)__		return matches.isEmpty() ? null :_				new PatternsRequestCondition(matches)__	};checks,if,any,of,the,patterns,match,the,given,request,and,returns,an,instance,that,is,guaranteed,to,contain,matching,patterns,sorted,param,exchange,the,current,exchange,return,the,same,instance,if,the,condition,contains,no,patterns,or,a,new,condition,with,sorted,matching,patterns,or,code,null,if,no,patterns,match;override,nullable,public,patterns,request,condition,get,matching,condition,server,web,exchange,exchange,if,this,patterns,is,empty,return,this,sorted,set,path,pattern,matches,get,matching,patterns,exchange,return,matches,is,empty,null,new,patterns,request,condition,matches
PatternsRequestCondition -> @Override 	@Nullable 	public PatternsRequestCondition getMatchingCondition(ServerWebExchange exchange);1501690296;Checks if any of the patterns match the given request and returns an instance_that is guaranteed to contain matching patterns, sorted._@param exchange the current exchange_@return the same instance if the condition contains no patterns__or a new condition with sorted matching patterns__or {@code null} if no patterns match.;@Override_	@Nullable_	public PatternsRequestCondition getMatchingCondition(ServerWebExchange exchange) {_		if (this.patterns.isEmpty()) {_			return this__		}_		SortedSet<PathPattern> matches = getMatchingPatterns(exchange)__		return matches.isEmpty() ? null :_				new PatternsRequestCondition(matches)__	};checks,if,any,of,the,patterns,match,the,given,request,and,returns,an,instance,that,is,guaranteed,to,contain,matching,patterns,sorted,param,exchange,the,current,exchange,return,the,same,instance,if,the,condition,contains,no,patterns,or,a,new,condition,with,sorted,matching,patterns,or,code,null,if,no,patterns,match;override,nullable,public,patterns,request,condition,get,matching,condition,server,web,exchange,exchange,if,this,patterns,is,empty,return,this,sorted,set,path,pattern,matches,get,matching,patterns,exchange,return,matches,is,empty,null,new,patterns,request,condition,matches
PatternsRequestCondition -> @Override 	@Nullable 	public PatternsRequestCondition getMatchingCondition(ServerWebExchange exchange);1530174524;Checks if any of the patterns match the given request and returns an instance_that is guaranteed to contain matching patterns, sorted._@param exchange the current exchange_@return the same instance if the condition contains no patterns__or a new condition with sorted matching patterns__or {@code null} if no patterns match.;@Override_	@Nullable_	public PatternsRequestCondition getMatchingCondition(ServerWebExchange exchange) {_		if (this.patterns.isEmpty()) {_			return this__		}_		SortedSet<PathPattern> matches = getMatchingPatterns(exchange)__		return matches.isEmpty() ? null :_				new PatternsRequestCondition(matches)__	};checks,if,any,of,the,patterns,match,the,given,request,and,returns,an,instance,that,is,guaranteed,to,contain,matching,patterns,sorted,param,exchange,the,current,exchange,return,the,same,instance,if,the,condition,contains,no,patterns,or,a,new,condition,with,sorted,matching,patterns,or,code,null,if,no,patterns,match;override,nullable,public,patterns,request,condition,get,matching,condition,server,web,exchange,exchange,if,this,patterns,is,empty,return,this,sorted,set,path,pattern,matches,get,matching,patterns,exchange,return,matches,is,empty,null,new,patterns,request,condition,matches
PatternsRequestCondition -> @Override 	@Nullable 	public PatternsRequestCondition getMatchingCondition(ServerWebExchange exchange);1530190293;Checks if any of the patterns match the given request and returns an instance_that is guaranteed to contain matching patterns, sorted._@param exchange the current exchange_@return the same instance if the condition contains no patterns__or a new condition with sorted matching patterns__or {@code null} if no patterns match.;@Override_	@Nullable_	public PatternsRequestCondition getMatchingCondition(ServerWebExchange exchange) {_		if (this.patterns.isEmpty()) {_			return this__		}_		SortedSet<PathPattern> matches = getMatchingPatterns(exchange)__		return (!matches.isEmpty() ? new PatternsRequestCondition(matches) : null)__	};checks,if,any,of,the,patterns,match,the,given,request,and,returns,an,instance,that,is,guaranteed,to,contain,matching,patterns,sorted,param,exchange,the,current,exchange,return,the,same,instance,if,the,condition,contains,no,patterns,or,a,new,condition,with,sorted,matching,patterns,or,code,null,if,no,patterns,match;override,nullable,public,patterns,request,condition,get,matching,condition,server,web,exchange,exchange,if,this,patterns,is,empty,return,this,sorted,set,path,pattern,matches,get,matching,patterns,exchange,return,matches,is,empty,new,patterns,request,condition,matches,null
PatternsRequestCondition -> public PatternsRequestCondition(PathPattern... patterns);1500370830;Creates a new instance with the given URL patterns._@param patterns 0 or more URL patterns_ if 0 the condition will match to every request.;public PatternsRequestCondition(PathPattern... patterns) {_		this(Arrays.asList(patterns))__	};creates,a,new,instance,with,the,given,url,patterns,param,patterns,0,or,more,url,patterns,if,0,the,condition,will,match,to,every,request;public,patterns,request,condition,path,pattern,patterns,this,arrays,as,list,patterns
PatternsRequestCondition -> public PatternsRequestCondition(PathPattern... patterns);1501237594;Creates a new instance with the given URL patterns._@param patterns 0 or more URL patterns_ if 0 the condition will match to every request.;public PatternsRequestCondition(PathPattern... patterns) {_		this(Arrays.asList(patterns))__	};creates,a,new,instance,with,the,given,url,patterns,param,patterns,0,or,more,url,patterns,if,0,the,condition,will,match,to,every,request;public,patterns,request,condition,path,pattern,patterns,this,arrays,as,list,patterns
PatternsRequestCondition -> public PatternsRequestCondition(PathPattern... patterns);1501690296;Creates a new instance with the given URL patterns._@param patterns 0 or more URL patterns_ if 0 the condition will match to every request.;public PatternsRequestCondition(PathPattern... patterns) {_		this(Arrays.asList(patterns))__	};creates,a,new,instance,with,the,given,url,patterns,param,patterns,0,or,more,url,patterns,if,0,the,condition,will,match,to,every,request;public,patterns,request,condition,path,pattern,patterns,this,arrays,as,list,patterns
PatternsRequestCondition -> public PatternsRequestCondition(PathPattern... patterns);1530174524;Creates a new instance with the given URL patterns._@param patterns 0 or more URL patterns_ if 0 the condition will match to every request.;public PatternsRequestCondition(PathPattern... patterns) {_		this(Arrays.asList(patterns))__	};creates,a,new,instance,with,the,given,url,patterns,param,patterns,0,or,more,url,patterns,if,0,the,condition,will,match,to,every,request;public,patterns,request,condition,path,pattern,patterns,this,arrays,as,list,patterns
PatternsRequestCondition -> public PatternsRequestCondition(PathPattern... patterns);1530190293;Creates a new instance with the given URL patterns._@param patterns 0 or more URL patterns_ if 0 the condition will match to every request.;public PatternsRequestCondition(PathPattern... patterns) {_		this(Arrays.asList(patterns))__	};creates,a,new,instance,with,the,given,url,patterns,param,patterns,0,or,more,url,patterns,if,0,the,condition,will,match,to,every,request;public,patterns,request,condition,path,pattern,patterns,this,arrays,as,list,patterns
PatternsRequestCondition -> public PatternsRequestCondition(String[] patterns, HttpRequestPathHelper pathHelper, 			PathPatternRegistry pathPatternRegistry);1486652296;Creates a new instance with the given URL patterns._Each pattern that is not empty and does not start with "/" is pre-pended with "/"._@param patterns the URL patterns to use_ if 0, the condition will match to every request._@param pathHelper to determine the lookup path for a request_@param pathPatternRegistry the pattern registry in which we'll register the given paths;public PatternsRequestCondition(String[] patterns, HttpRequestPathHelper pathHelper,_			PathPatternRegistry pathPatternRegistry) {_		this(createPatternSet(patterns, pathPatternRegistry),_				(pathHelper != null ? pathHelper : new HttpRequestPathHelper()))__	};creates,a,new,instance,with,the,given,url,patterns,each,pattern,that,is,not,empty,and,does,not,start,with,is,pre,pended,with,param,patterns,the,url,patterns,to,use,if,0,the,condition,will,match,to,every,request,param,path,helper,to,determine,the,lookup,path,for,a,request,param,path,pattern,registry,the,pattern,registry,in,which,we,ll,register,the,given,paths;public,patterns,request,condition,string,patterns,http,request,path,helper,path,helper,path,pattern,registry,path,pattern,registry,this,create,pattern,set,patterns,path,pattern,registry,path,helper,null,path,helper,new,http,request,path,helper
PatternsRequestCondition -> public PatternsRequestCondition(String[] patterns, HttpRequestPathHelper pathHelper, 			PathPatternRegistry pathPatternRegistry);1486674586;Creates a new instance with the given URL patterns._Each pattern that is not empty and does not start with "/" is pre-pended with "/"._@param patterns the URL patterns to use_ if 0, the condition will match to every request._@param pathHelper to determine the lookup path for a request_@param pathPatternRegistry the pattern registry in which we'll register the given paths;public PatternsRequestCondition(String[] patterns, HttpRequestPathHelper pathHelper,_			PathPatternRegistry pathPatternRegistry) {_		this(createPatternSet(patterns, pathPatternRegistry),_				(pathHelper != null ? pathHelper : new HttpRequestPathHelper()))__	};creates,a,new,instance,with,the,given,url,patterns,each,pattern,that,is,not,empty,and,does,not,start,with,is,pre,pended,with,param,patterns,the,url,patterns,to,use,if,0,the,condition,will,match,to,every,request,param,path,helper,to,determine,the,lookup,path,for,a,request,param,path,pattern,registry,the,pattern,registry,in,which,we,ll,register,the,given,paths;public,patterns,request,condition,string,patterns,http,request,path,helper,path,helper,path,pattern,registry,path,pattern,registry,this,create,pattern,set,patterns,path,pattern,registry,path,helper,null,path,helper,new,http,request,path,helper
PatternsRequestCondition -> public PatternsRequestCondition(String[] patterns, PathPatternParser patternParser);1497286385;Creates a new instance with the given URL patterns._Each pattern that is not empty and does not start with "/" is pre-pended with "/"._@param patterns the URL patterns to use_ if 0, the condition will match to every request._@param patternParser for parsing string patterns;public PatternsRequestCondition(String[] patterns, PathPatternParser patternParser) {__		this(asList(patterns), patternParser)__	};creates,a,new,instance,with,the,given,url,patterns,each,pattern,that,is,not,empty,and,does,not,start,with,is,pre,pended,with,param,patterns,the,url,patterns,to,use,if,0,the,condition,will,match,to,every,request,param,pattern,parser,for,parsing,string,patterns;public,patterns,request,condition,string,patterns,path,pattern,parser,pattern,parser,this,as,list,patterns,pattern,parser
PatternsRequestCondition -> public PatternsRequestCondition(String[] patterns, PathPatternParser patternParser);1498861175;Creates a new instance with the given URL patterns._Each pattern that is not empty and does not start with "/" is pre-pended with "/"._@param patterns the URL patterns to use_ if 0, the condition will match to every request._@param patternParser for parsing string patterns;public PatternsRequestCondition(String[] patterns, PathPatternParser patternParser) {__		this(asList(patterns), patternParser)__	};creates,a,new,instance,with,the,given,url,patterns,each,pattern,that,is,not,empty,and,does,not,start,with,is,pre,pended,with,param,patterns,the,url,patterns,to,use,if,0,the,condition,will,match,to,every,request,param,pattern,parser,for,parsing,string,patterns;public,patterns,request,condition,string,patterns,path,pattern,parser,pattern,parser,this,as,list,patterns,pattern,parser
PatternsRequestCondition -> public PatternsRequestCondition(String[] patterns, PathPatternParser patternParser);1498861175;Creates a new instance with the given URL patterns._Each pattern that is not empty and does not start with "/" is pre-pended with "/"._@param patterns the URL patterns to use_ if 0, the condition will match to every request._@param patternParser for parsing string patterns;public PatternsRequestCondition(String[] patterns, PathPatternParser patternParser) {_		this(Arrays.asList(patterns), patternParser)__	};creates,a,new,instance,with,the,given,url,patterns,each,pattern,that,is,not,empty,and,does,not,start,with,is,pre,pended,with,param,patterns,the,url,patterns,to,use,if,0,the,condition,will,match,to,every,request,param,pattern,parser,for,parsing,string,patterns;public,patterns,request,condition,string,patterns,path,pattern,parser,pattern,parser,this,arrays,as,list,patterns,pattern,parser
PatternsRequestCondition -> public PatternsRequestCondition(String[] patterns, PathPatternParser patternParser);1498944474;Creates a new instance with the given URL patterns._Each pattern that is not empty and does not start with "/" is pre-pended with "/"._@param patterns the URL patterns to use_ if 0, the condition will match to every request._@param patternParser for parsing string patterns;public PatternsRequestCondition(String[] patterns, PathPatternParser patternParser) {_		this(Arrays.asList(patterns), patternParser)__	};creates,a,new,instance,with,the,given,url,patterns,each,pattern,that,is,not,empty,and,does,not,start,with,is,pre,pended,with,param,patterns,the,url,patterns,to,use,if,0,the,condition,will,match,to,every,request,param,pattern,parser,for,parsing,string,patterns;public,patterns,request,condition,string,patterns,path,pattern,parser,pattern,parser,this,arrays,as,list,patterns,pattern,parser
PatternsRequestCondition -> private PatternsRequestCondition(Collection<String> patterns, PathPatternParser parser);1498861175;Private constructor accepting a collection of raw patterns.;private PatternsRequestCondition(Collection<String> patterns, PathPatternParser parser) {_		this.parser = (parser != null ? parser : new PathPatternParser())__		this.patterns = toSortedSet(patterns.stream().map(pattern -> parse(pattern, this.parser)))__	};private,constructor,accepting,a,collection,of,raw,patterns;private,patterns,request,condition,collection,string,patterns,path,pattern,parser,parser,this,parser,parser,null,parser,new,path,pattern,parser,this,patterns,to,sorted,set,patterns,stream,map,pattern,parse,pattern,this,parser
PatternsRequestCondition -> private PatternsRequestCondition(Collection<String> patterns, PathPatternParser parser);1498944474;Private constructor accepting a collection of raw patterns.;private PatternsRequestCondition(Collection<String> patterns, PathPatternParser parser) {_		this.parser = (parser != null ? parser : new PathPatternParser())__		this.patterns = toSortedSet(patterns.stream().map(pattern -> parse(pattern, this.parser)))__	};private,constructor,accepting,a,collection,of,raw,patterns;private,patterns,request,condition,collection,string,patterns,path,pattern,parser,parser,this,parser,parser,null,parser,new,path,pattern,parser,this,patterns,to,sorted,set,patterns,stream,map,pattern,parse,pattern,this,parser
PatternsRequestCondition -> public PatternsRequestCondition(List<PathPattern> patterns);1500370830;Creates a new instance with the given {@code Stream} of URL patterns.;public PatternsRequestCondition(List<PathPattern> patterns) {_		this(toSortedSet(patterns))__	};creates,a,new,instance,with,the,given,code,stream,of,url,patterns;public,patterns,request,condition,list,path,pattern,patterns,this,to,sorted,set,patterns
PatternsRequestCondition -> public PatternsRequestCondition(List<PathPattern> patterns);1501237594;Creates a new instance with the given {@code Stream} of URL patterns.;public PatternsRequestCondition(List<PathPattern> patterns) {_		this(toSortedSet(patterns))__	};creates,a,new,instance,with,the,given,code,stream,of,url,patterns;public,patterns,request,condition,list,path,pattern,patterns,this,to,sorted,set,patterns
PatternsRequestCondition -> public PatternsRequestCondition(List<PathPattern> patterns);1501690296;Creates a new instance with the given {@code Stream} of URL patterns.;public PatternsRequestCondition(List<PathPattern> patterns) {_		this(toSortedSet(patterns))__	};creates,a,new,instance,with,the,given,code,stream,of,url,patterns;public,patterns,request,condition,list,path,pattern,patterns,this,to,sorted,set,patterns
PatternsRequestCondition -> public PatternsRequestCondition(List<PathPattern> patterns);1530174524;Creates a new instance with the given {@code Stream} of URL patterns.;public PatternsRequestCondition(List<PathPattern> patterns) {_		this(toSortedSet(patterns))__	};creates,a,new,instance,with,the,given,code,stream,of,url,patterns;public,patterns,request,condition,list,path,pattern,patterns,this,to,sorted,set,patterns
PatternsRequestCondition -> public PatternsRequestCondition(List<PathPattern> patterns);1530190293;Creates a new instance with the given {@code Stream} of URL patterns.;public PatternsRequestCondition(List<PathPattern> patterns) {_		this(new TreeSet<>(patterns))__	};creates,a,new,instance,with,the,given,code,stream,of,url,patterns;public,patterns,request,condition,list,path,pattern,patterns,this,new,tree,set,patterns
PatternsRequestCondition -> private PatternsRequestCondition(Collection<String> patterns, HttpRequestPathHelper pathHelper, 			PathMatcher pathMatcher, boolean useSuffixPatternMatch, boolean useTrailingSlashMatch, 			Set<String> fileExtensions);1485986572;Private constructor accepting a collection of patterns.;private PatternsRequestCondition(Collection<String> patterns, HttpRequestPathHelper pathHelper,_			PathMatcher pathMatcher, boolean useSuffixPatternMatch, boolean useTrailingSlashMatch,_			Set<String> fileExtensions) {__		this.patterns = Collections.unmodifiableSet(prependLeadingSlash(patterns))__		this.pathHelper = (pathHelper != null ? pathHelper : new HttpRequestPathHelper())__		this.pathMatcher = (pathMatcher != null ? pathMatcher : new AntPathMatcher())__		this.useSuffixPatternMatch = useSuffixPatternMatch__		this.useTrailingSlashMatch = useTrailingSlashMatch__		if (fileExtensions != null) {_			for (String fileExtension : fileExtensions) {_				if (fileExtension.charAt(0) != '.') {_					fileExtension = "." + fileExtension__				}_				this.fileExtensions.add(fileExtension)__			}_		}_	};private,constructor,accepting,a,collection,of,patterns;private,patterns,request,condition,collection,string,patterns,http,request,path,helper,path,helper,path,matcher,path,matcher,boolean,use,suffix,pattern,match,boolean,use,trailing,slash,match,set,string,file,extensions,this,patterns,collections,unmodifiable,set,prepend,leading,slash,patterns,this,path,helper,path,helper,null,path,helper,new,http,request,path,helper,this,path,matcher,path,matcher,null,path,matcher,new,ant,path,matcher,this,use,suffix,pattern,match,use,suffix,pattern,match,this,use,trailing,slash,match,use,trailing,slash,match,if,file,extensions,null,for,string,file,extension,file,extensions,if,file,extension,char,at,0,file,extension,file,extension,this,file,extensions,add,file,extension
PatternsRequestCondition -> private PatternsRequestCondition(Collection<String> patterns, HttpRequestPathHelper pathHelper, 			PathMatcher pathMatcher, boolean useSuffixPatternMatch, boolean useTrailingSlashMatch, 			Set<String> fileExtensions);1486634978;Private constructor accepting a collection of patterns.;private PatternsRequestCondition(Collection<String> patterns, HttpRequestPathHelper pathHelper,_			PathMatcher pathMatcher, boolean useSuffixPatternMatch, boolean useTrailingSlashMatch,_			Set<String> fileExtensions) {__		this.patterns = Collections.unmodifiableSet(prependLeadingSlash(patterns))__		this.pathHelper = (pathHelper != null ? pathHelper : new HttpRequestPathHelper())__		this.pathMatcher = (pathMatcher != null ? pathMatcher : new ParsingPathMatcher())__		this.useSuffixPatternMatch = useSuffixPatternMatch__		this.useTrailingSlashMatch = useTrailingSlashMatch__		if (fileExtensions != null) {_			for (String fileExtension : fileExtensions) {_				if (fileExtension.charAt(0) != '.') {_					fileExtension = "." + fileExtension__				}_				this.fileExtensions.add(fileExtension)__			}_		}_	};private,constructor,accepting,a,collection,of,patterns;private,patterns,request,condition,collection,string,patterns,http,request,path,helper,path,helper,path,matcher,path,matcher,boolean,use,suffix,pattern,match,boolean,use,trailing,slash,match,set,string,file,extensions,this,patterns,collections,unmodifiable,set,prepend,leading,slash,patterns,this,path,helper,path,helper,null,path,helper,new,http,request,path,helper,this,path,matcher,path,matcher,null,path,matcher,new,parsing,path,matcher,this,use,suffix,pattern,match,use,suffix,pattern,match,this,use,trailing,slash,match,use,trailing,slash,match,if,file,extensions,null,for,string,file,extension,file,extensions,if,file,extension,char,at,0,file,extension,file,extension,this,file,extensions,add,file,extension
PatternsRequestCondition -> private PatternsRequestCondition(Collection<String> patterns, HttpRequestPathHelper pathHelper, 			PathMatcher pathMatcher, boolean useSuffixPatternMatch, boolean useTrailingSlashMatch, 			Set<String> fileExtensions);1486747801;Private constructor accepting a collection of patterns.;private PatternsRequestCondition(Collection<String> patterns, HttpRequestPathHelper pathHelper,_			PathMatcher pathMatcher, boolean useSuffixPatternMatch, boolean useTrailingSlashMatch,_			Set<String> fileExtensions) {__		this.patterns = Collections.unmodifiableSet(prependLeadingSlash(patterns))__		this.pathHelper = (pathHelper != null ? pathHelper : new HttpRequestPathHelper())__		this.pathMatcher = (pathMatcher != null ? pathMatcher : new ParsingPathMatcher())__		this.useSuffixPatternMatch = useSuffixPatternMatch__		this.useTrailingSlashMatch = useTrailingSlashMatch__		if (fileExtensions != null) {_			for (String fileExtension : fileExtensions) {_				if (fileExtension.charAt(0) != '.') {_					fileExtension = "." + fileExtension__				}_				this.fileExtensions.add(fileExtension)__			}_		}_	};private,constructor,accepting,a,collection,of,patterns;private,patterns,request,condition,collection,string,patterns,http,request,path,helper,path,helper,path,matcher,path,matcher,boolean,use,suffix,pattern,match,boolean,use,trailing,slash,match,set,string,file,extensions,this,patterns,collections,unmodifiable,set,prepend,leading,slash,patterns,this,path,helper,path,helper,null,path,helper,new,http,request,path,helper,this,path,matcher,path,matcher,null,path,matcher,new,parsing,path,matcher,this,use,suffix,pattern,match,use,suffix,pattern,match,this,use,trailing,slash,match,use,trailing,slash,match,if,file,extensions,null,for,string,file,extension,file,extensions,if,file,extension,char,at,0,file,extension,file,extension,this,file,extensions,add,file,extension
PatternsRequestCondition -> private PatternsRequestCondition(Collection<String> patterns, HttpRequestPathHelper pathHelper, 			PathMatcher pathMatcher, boolean useSuffixPatternMatch, boolean useTrailingSlashMatch, 			Set<String> fileExtensions);1495035625;Private constructor accepting a collection of patterns.;private PatternsRequestCondition(Collection<String> patterns, HttpRequestPathHelper pathHelper,_			PathMatcher pathMatcher, boolean useSuffixPatternMatch, boolean useTrailingSlashMatch,_			Set<String> fileExtensions) {__		this.patterns = Collections.unmodifiableSet(prependLeadingSlash(patterns))__		this.pathHelper = (pathHelper != null ? pathHelper : new HttpRequestPathHelper())__		this.pathMatcher = (pathMatcher != null ? pathMatcher : new ParsingPathMatcher())__		this.useSuffixPatternMatch = useSuffixPatternMatch__		this.useTrailingSlashMatch = useTrailingSlashMatch__		if (fileExtensions != null) {_			for (String fileExtension : fileExtensions) {_				if (fileExtension.charAt(0) != '.') {_					fileExtension = "." + fileExtension__				}_				this.fileExtensions.add(fileExtension)__			}_		}_	};private,constructor,accepting,a,collection,of,patterns;private,patterns,request,condition,collection,string,patterns,http,request,path,helper,path,helper,path,matcher,path,matcher,boolean,use,suffix,pattern,match,boolean,use,trailing,slash,match,set,string,file,extensions,this,patterns,collections,unmodifiable,set,prepend,leading,slash,patterns,this,path,helper,path,helper,null,path,helper,new,http,request,path,helper,this,path,matcher,path,matcher,null,path,matcher,new,parsing,path,matcher,this,use,suffix,pattern,match,use,suffix,pattern,match,this,use,trailing,slash,match,use,trailing,slash,match,if,file,extensions,null,for,string,file,extension,file,extensions,if,file,extension,char,at,0,file,extension,file,extension,this,file,extensions,add,file,extension
PatternsRequestCondition -> private PatternsRequestCondition(List<PathPattern> patterns, PathPatternParser patternParser);1497286385;Private constructor accepting a list of path patterns.;private PatternsRequestCondition(List<PathPattern> patterns, PathPatternParser patternParser) {_		this.patterns = patterns__		this.parser = patternParser__	};private,constructor,accepting,a,list,of,path,patterns;private,patterns,request,condition,list,path,pattern,patterns,path,pattern,parser,pattern,parser,this,patterns,patterns,this,parser,pattern,parser
PatternsRequestCondition -> private PatternsRequestCondition(List<PathPattern> patterns, PathPatternParser patternParser);1498861175;Private constructor accepting a list of path patterns.;private PatternsRequestCondition(List<PathPattern> patterns, PathPatternParser patternParser) {_		this.patterns = patterns__		this.parser = patternParser__	};private,constructor,accepting,a,list,of,path,patterns;private,patterns,request,condition,list,path,pattern,patterns,path,pattern,parser,pattern,parser,this,patterns,patterns,this,parser,pattern,parser
PatternsRequestCondition -> private PatternsRequestCondition(List<PathPattern> patterns, PathPatternParser patternParser);1498861175;Private constructor accepting a list of path patterns.;private PatternsRequestCondition(List<PathPattern> patterns, PathPatternParser patternParser) {_		this.patterns = toSortedSet(patterns.stream())__		this.parser = patternParser__	};private,constructor,accepting,a,list,of,path,patterns;private,patterns,request,condition,list,path,pattern,patterns,path,pattern,parser,pattern,parser,this,patterns,to,sorted,set,patterns,stream,this,parser,pattern,parser
PatternsRequestCondition -> private PatternsRequestCondition(List<PathPattern> patterns, PathPatternParser patternParser);1498944474;Private constructor accepting a list of path patterns.;private PatternsRequestCondition(List<PathPattern> patterns, PathPatternParser patternParser) {_		this.patterns = toSortedSet(patterns.stream())__		this.parser = patternParser__	};private,constructor,accepting,a,list,of,path,patterns;private,patterns,request,condition,list,path,pattern,patterns,path,pattern,parser,pattern,parser,this,patterns,to,sorted,set,patterns,stream,this,parser,pattern,parser
PatternsRequestCondition -> private SortedSet<PathPattern> getMatchingPatterns(ServerWebExchange exchange);1498861175;Find the patterns matching the given lookup path. Invoking this method should_yield results equivalent to those of calling_{@link #getMatchingCondition(ServerWebExchange)}._This method is provided as an alternative to be used if no request is available_(e.g. introspection, tooling, etc)._@param exchange the current exchange_@return a sorted set of matching patterns sorted with the closest match first;private SortedSet<PathPattern> getMatchingPatterns(ServerWebExchange exchange) {_		PathContainer lookupPath = exchange.getRequest().getPath().pathWithinApplication()__		return patterns.stream()_				.filter(pattern -> pattern.matches(lookupPath))_				.collect(Collectors.toCollection(TreeSet::new))__	};find,the,patterns,matching,the,given,lookup,path,invoking,this,method,should,yield,results,equivalent,to,those,of,calling,link,get,matching,condition,server,web,exchange,this,method,is,provided,as,an,alternative,to,be,used,if,no,request,is,available,e,g,introspection,tooling,etc,param,exchange,the,current,exchange,return,a,sorted,set,of,matching,patterns,sorted,with,the,closest,match,first;private,sorted,set,path,pattern,get,matching,patterns,server,web,exchange,exchange,path,container,lookup,path,exchange,get,request,get,path,path,within,application,return,patterns,stream,filter,pattern,pattern,matches,lookup,path,collect,collectors,to,collection,tree,set,new
PatternsRequestCondition -> private SortedSet<PathPattern> getMatchingPatterns(ServerWebExchange exchange);1498944474;Find the patterns matching the given lookup path. Invoking this method should_yield results equivalent to those of calling_{@link #getMatchingCondition(ServerWebExchange)}._This method is provided as an alternative to be used if no request is available_(e.g. introspection, tooling, etc)._@param exchange the current exchange_@return a sorted set of matching patterns sorted with the closest match first;private SortedSet<PathPattern> getMatchingPatterns(ServerWebExchange exchange) {_		PathContainer lookupPath = exchange.getRequest().getPath().pathWithinApplication()__		return patterns.stream()_				.filter(pattern -> pattern.matches(lookupPath))_				.collect(Collectors.toCollection(TreeSet::new))__	};find,the,patterns,matching,the,given,lookup,path,invoking,this,method,should,yield,results,equivalent,to,those,of,calling,link,get,matching,condition,server,web,exchange,this,method,is,provided,as,an,alternative,to,be,used,if,no,request,is,available,e,g,introspection,tooling,etc,param,exchange,the,current,exchange,return,a,sorted,set,of,matching,patterns,sorted,with,the,closest,match,first;private,sorted,set,path,pattern,get,matching,patterns,server,web,exchange,exchange,path,container,lookup,path,exchange,get,request,get,path,path,within,application,return,patterns,stream,filter,pattern,pattern,matches,lookup,path,collect,collectors,to,collection,tree,set,new
PatternsRequestCondition -> private SortedSet<PathPattern> getMatchingPatterns(ServerWebExchange exchange);1500370830;Find the patterns matching the given lookup path. Invoking this method should_yield results equivalent to those of calling_{@link #getMatchingCondition(ServerWebExchange)}._This method is provided as an alternative to be used if no request is available_(e.g. introspection, tooling, etc)._@param exchange the current exchange_@return a sorted set of matching patterns sorted with the closest match first;private SortedSet<PathPattern> getMatchingPatterns(ServerWebExchange exchange) {_		PathContainer lookupPath = exchange.getRequest().getPath().pathWithinApplication()__		return patterns.stream()_				.filter(pattern -> pattern.matches(lookupPath))_				.collect(Collectors.toCollection(TreeSet::new))__	};find,the,patterns,matching,the,given,lookup,path,invoking,this,method,should,yield,results,equivalent,to,those,of,calling,link,get,matching,condition,server,web,exchange,this,method,is,provided,as,an,alternative,to,be,used,if,no,request,is,available,e,g,introspection,tooling,etc,param,exchange,the,current,exchange,return,a,sorted,set,of,matching,patterns,sorted,with,the,closest,match,first;private,sorted,set,path,pattern,get,matching,patterns,server,web,exchange,exchange,path,container,lookup,path,exchange,get,request,get,path,path,within,application,return,patterns,stream,filter,pattern,pattern,matches,lookup,path,collect,collectors,to,collection,tree,set,new
PatternsRequestCondition -> private SortedSet<PathPattern> getMatchingPatterns(ServerWebExchange exchange);1501237594;Find the patterns matching the given lookup path. Invoking this method should_yield results equivalent to those of calling_{@link #getMatchingCondition(ServerWebExchange)}._This method is provided as an alternative to be used if no request is available_(e.g. introspection, tooling, etc)._@param exchange the current exchange_@return a sorted set of matching patterns sorted with the closest match first;private SortedSet<PathPattern> getMatchingPatterns(ServerWebExchange exchange) {_		PathContainer lookupPath = exchange.getRequest().getPath().pathWithinApplication()__		return patterns.stream()_				.filter(pattern -> pattern.matches(lookupPath))_				.collect(Collectors.toCollection(TreeSet::new))__	};find,the,patterns,matching,the,given,lookup,path,invoking,this,method,should,yield,results,equivalent,to,those,of,calling,link,get,matching,condition,server,web,exchange,this,method,is,provided,as,an,alternative,to,be,used,if,no,request,is,available,e,g,introspection,tooling,etc,param,exchange,the,current,exchange,return,a,sorted,set,of,matching,patterns,sorted,with,the,closest,match,first;private,sorted,set,path,pattern,get,matching,patterns,server,web,exchange,exchange,path,container,lookup,path,exchange,get,request,get,path,path,within,application,return,patterns,stream,filter,pattern,pattern,matches,lookup,path,collect,collectors,to,collection,tree,set,new
PatternsRequestCondition -> private SortedSet<PathPattern> getMatchingPatterns(ServerWebExchange exchange);1501690296;Find the patterns matching the given lookup path. Invoking this method should_yield results equivalent to those of calling_{@link #getMatchingCondition(ServerWebExchange)}._This method is provided as an alternative to be used if no request is available_(e.g. introspection, tooling, etc)._@param exchange the current exchange_@return a sorted set of matching patterns sorted with the closest match first;private SortedSet<PathPattern> getMatchingPatterns(ServerWebExchange exchange) {_		PathContainer lookupPath = exchange.getRequest().getPath().pathWithinApplication()__		return patterns.stream()_				.filter(pattern -> pattern.matches(lookupPath))_				.collect(Collectors.toCollection(TreeSet::new))__	};find,the,patterns,matching,the,given,lookup,path,invoking,this,method,should,yield,results,equivalent,to,those,of,calling,link,get,matching,condition,server,web,exchange,this,method,is,provided,as,an,alternative,to,be,used,if,no,request,is,available,e,g,introspection,tooling,etc,param,exchange,the,current,exchange,return,a,sorted,set,of,matching,patterns,sorted,with,the,closest,match,first;private,sorted,set,path,pattern,get,matching,patterns,server,web,exchange,exchange,path,container,lookup,path,exchange,get,request,get,path,path,within,application,return,patterns,stream,filter,pattern,pattern,matches,lookup,path,collect,collectors,to,collection,tree,set,new
PatternsRequestCondition -> private SortedSet<PathPattern> getMatchingPatterns(ServerWebExchange exchange);1530174524;Find the patterns matching the given lookup path. Invoking this method should_yield results equivalent to those of calling_{@link #getMatchingCondition(ServerWebExchange)}._This method is provided as an alternative to be used if no request is available_(e.g. introspection, tooling, etc)._@param exchange the current exchange_@return a sorted set of matching patterns sorted with the closest match first;private SortedSet<PathPattern> getMatchingPatterns(ServerWebExchange exchange) {_		PathContainer lookupPath = exchange.getRequest().getPath().pathWithinApplication()__		return this.patterns.stream()_				.filter(pattern -> pattern.matches(lookupPath))_				.collect(Collectors.toCollection(TreeSet::new))__	};find,the,patterns,matching,the,given,lookup,path,invoking,this,method,should,yield,results,equivalent,to,those,of,calling,link,get,matching,condition,server,web,exchange,this,method,is,provided,as,an,alternative,to,be,used,if,no,request,is,available,e,g,introspection,tooling,etc,param,exchange,the,current,exchange,return,a,sorted,set,of,matching,patterns,sorted,with,the,closest,match,first;private,sorted,set,path,pattern,get,matching,patterns,server,web,exchange,exchange,path,container,lookup,path,exchange,get,request,get,path,path,within,application,return,this,patterns,stream,filter,pattern,pattern,matches,lookup,path,collect,collectors,to,collection,tree,set,new
PatternsRequestCondition -> private SortedSet<PathPattern> getMatchingPatterns(ServerWebExchange exchange);1530190293;Find the patterns matching the given lookup path. Invoking this method should_yield results equivalent to those of calling_{@link #getMatchingCondition(ServerWebExchange)}._This method is provided as an alternative to be used if no request is available_(e.g. introspection, tooling, etc)._@param exchange the current exchange_@return a sorted set of matching patterns sorted with the closest match first;private SortedSet<PathPattern> getMatchingPatterns(ServerWebExchange exchange) {_		PathContainer lookupPath = exchange.getRequest().getPath().pathWithinApplication()__		return this.patterns.stream()_				.filter(pattern -> pattern.matches(lookupPath))_				.collect(Collectors.toCollection(TreeSet::new))__	};find,the,patterns,matching,the,given,lookup,path,invoking,this,method,should,yield,results,equivalent,to,those,of,calling,link,get,matching,condition,server,web,exchange,this,method,is,provided,as,an,alternative,to,be,used,if,no,request,is,available,e,g,introspection,tooling,etc,param,exchange,the,current,exchange,return,a,sorted,set,of,matching,patterns,sorted,with,the,closest,match,first;private,sorted,set,path,pattern,get,matching,patterns,server,web,exchange,exchange,path,container,lookup,path,exchange,get,request,get,path,path,within,application,return,this,patterns,stream,filter,pattern,pattern,matches,lookup,path,collect,collectors,to,collection,tree,set,new
PatternsRequestCondition -> public PatternsRequestCondition(String... patterns);1485986572;Creates a new instance with the given URL patterns._Each pattern that is not empty and does not start with "/" is prepended with "/"._@param patterns 0 or more URL patterns_ if 0 the condition will match to every request.;public PatternsRequestCondition(String... patterns) {_		this(asList(patterns), null, null, true, true, null)__	};creates,a,new,instance,with,the,given,url,patterns,each,pattern,that,is,not,empty,and,does,not,start,with,is,prepended,with,param,patterns,0,or,more,url,patterns,if,0,the,condition,will,match,to,every,request;public,patterns,request,condition,string,patterns,this,as,list,patterns,null,null,true,true,null
PatternsRequestCondition -> public PatternsRequestCondition(String... patterns);1486634978;Creates a new instance with the given URL patterns._Each pattern that is not empty and does not start with "/" is prepended with "/"._@param patterns 0 or more URL patterns_ if 0 the condition will match to every request.;public PatternsRequestCondition(String... patterns) {_		this(asList(patterns), null, null, true, true, null)__	};creates,a,new,instance,with,the,given,url,patterns,each,pattern,that,is,not,empty,and,does,not,start,with,is,prepended,with,param,patterns,0,or,more,url,patterns,if,0,the,condition,will,match,to,every,request;public,patterns,request,condition,string,patterns,this,as,list,patterns,null,null,true,true,null
PatternsRequestCondition -> public PatternsRequestCondition(String... patterns);1486635693;Creates a new instance with the given URL patterns._Each pattern that is not empty and does not start with "/" is prepended with "/"._@param patterns 0 or more URL patterns_ if 0 the condition will match to every request.;public PatternsRequestCondition(String... patterns) {_		this(patterns, null, false, false, null)__	};creates,a,new,instance,with,the,given,url,patterns,each,pattern,that,is,not,empty,and,does,not,start,with,is,prepended,with,param,patterns,0,or,more,url,patterns,if,0,the,condition,will,match,to,every,request;public,patterns,request,condition,string,patterns,this,patterns,null,false,false,null
PatternsRequestCondition -> public PatternsRequestCondition(String... patterns);1486652296;Creates a new instance with the given URL patterns._Each pattern that is not empty and does not start with "/" is prepended with "/"._@param patterns 0 or more URL patterns_ if 0 the condition will match to every request.;public PatternsRequestCondition(String... patterns) {_		this(patterns, null, null)__	};creates,a,new,instance,with,the,given,url,patterns,each,pattern,that,is,not,empty,and,does,not,start,with,is,prepended,with,param,patterns,0,or,more,url,patterns,if,0,the,condition,will,match,to,every,request;public,patterns,request,condition,string,patterns,this,patterns,null,null
PatternsRequestCondition -> public PatternsRequestCondition(String... patterns);1486674586;Creates a new instance with the given URL patterns._Each pattern that is not empty and does not start with "/" is prepended with "/"._@param patterns 0 or more URL patterns_ if 0 the condition will match to every request.;public PatternsRequestCondition(String... patterns) {_		this(patterns, null, null)__	};creates,a,new,instance,with,the,given,url,patterns,each,pattern,that,is,not,empty,and,does,not,start,with,is,prepended,with,param,patterns,0,or,more,url,patterns,if,0,the,condition,will,match,to,every,request;public,patterns,request,condition,string,patterns,this,patterns,null,null
PatternsRequestCondition -> public PatternsRequestCondition(String... patterns);1486747801;Creates a new instance with the given URL patterns._Each pattern that is not empty and does not start with "/" is prepended with "/"._@param patterns 0 or more URL patterns_ if 0 the condition will match to every request.;public PatternsRequestCondition(String... patterns) {_		this(asList(patterns), null, null, true, true, null)__	};creates,a,new,instance,with,the,given,url,patterns,each,pattern,that,is,not,empty,and,does,not,start,with,is,prepended,with,param,patterns,0,or,more,url,patterns,if,0,the,condition,will,match,to,every,request;public,patterns,request,condition,string,patterns,this,as,list,patterns,null,null,true,true,null
PatternsRequestCondition -> public PatternsRequestCondition(String... patterns);1495035625;Creates a new instance with the given URL patterns._Each pattern that is not empty and does not start with "/" is prepended with "/"._@param patterns 0 or more URL patterns_ if 0 the condition will match to every request.;public PatternsRequestCondition(String... patterns) {_		this(asList(patterns), null, null, true, true, null)__	};creates,a,new,instance,with,the,given,url,patterns,each,pattern,that,is,not,empty,and,does,not,start,with,is,prepended,with,param,patterns,0,or,more,url,patterns,if,0,the,condition,will,match,to,every,request;public,patterns,request,condition,string,patterns,this,as,list,patterns,null,null,true,true,null
PatternsRequestCondition -> public PatternsRequestCondition(String... patterns);1496334664;Creates a new instance with the given URL patterns._Each pattern that is not empty and does not start with "/" is prepended with "/"._@param patterns 0 or more URL patterns_ if 0 the condition will match to every request.;public PatternsRequestCondition(String... patterns) {_		this(asList(patterns), null, true, true, null)__	};creates,a,new,instance,with,the,given,url,patterns,each,pattern,that,is,not,empty,and,does,not,start,with,is,prepended,with,param,patterns,0,or,more,url,patterns,if,0,the,condition,will,match,to,every,request;public,patterns,request,condition,string,patterns,this,as,list,patterns,null,true,true,null
PatternsRequestCondition -> public PatternsRequestCondition(String... patterns);1496429194;Creates a new instance with the given URL patterns._Each pattern that is not empty and does not start with "/" is prepended with "/"._@param patterns 0 or more URL patterns_ if 0 the condition will match to every request.;public PatternsRequestCondition(String... patterns) {_		this(asList(patterns), null, true, true, null)__	};creates,a,new,instance,with,the,given,url,patterns,each,pattern,that,is,not,empty,and,does,not,start,with,is,prepended,with,param,patterns,0,or,more,url,patterns,if,0,the,condition,will,match,to,every,request;public,patterns,request,condition,string,patterns,this,as,list,patterns,null,true,true,null
PatternsRequestCondition -> public PatternsRequestCondition(String... patterns);1496430942;Creates a new instance with the given URL patterns._Each pattern that is not empty and does not start with "/" is prepended with "/"._@param patterns 0 or more URL patterns_ if 0 the condition will match to every request.;public PatternsRequestCondition(String... patterns) {_		this(asList(patterns), null, true, true, null)__	};creates,a,new,instance,with,the,given,url,patterns,each,pattern,that,is,not,empty,and,does,not,start,with,is,prepended,with,param,patterns,0,or,more,url,patterns,if,0,the,condition,will,match,to,every,request;public,patterns,request,condition,string,patterns,this,as,list,patterns,null,true,true,null
PatternsRequestCondition -> public PatternsRequestCondition(String... patterns);1497039338;Creates a new instance with the given URL patterns._Each pattern that is not empty and does not start with "/" is prepended with "/"._@param patterns 0 or more URL patterns_ if 0 the condition will match to every request.;public PatternsRequestCondition(String... patterns) {_		this(asList(patterns), null, true, true, null)__	};creates,a,new,instance,with,the,given,url,patterns,each,pattern,that,is,not,empty,and,does,not,start,with,is,prepended,with,param,patterns,0,or,more,url,patterns,if,0,the,condition,will,match,to,every,request;public,patterns,request,condition,string,patterns,this,as,list,patterns,null,true,true,null
PatternsRequestCondition -> public PatternsRequestCondition(String... patterns);1497232764;Creates a new instance with the given URL patterns._Each pattern that is not empty and does not start with "/" is prepended with "/"._@param patterns 0 or more URL patterns_ if 0 the condition will match to every request.;public PatternsRequestCondition(String... patterns) {_		this(asList(patterns), null, true, true, null)__	};creates,a,new,instance,with,the,given,url,patterns,each,pattern,that,is,not,empty,and,does,not,start,with,is,prepended,with,param,patterns,0,or,more,url,patterns,if,0,the,condition,will,match,to,every,request;public,patterns,request,condition,string,patterns,this,as,list,patterns,null,true,true,null
PatternsRequestCondition -> public PatternsRequestCondition(String... patterns);1497286385;Creates a new instance with the given URL patterns._Each pattern is prepended with "/" if not already._@param patterns 0 or more URL patterns_ if 0 the condition will match to every request.;public PatternsRequestCondition(String... patterns) {_		this(asList(patterns), null)__	};creates,a,new,instance,with,the,given,url,patterns,each,pattern,is,prepended,with,if,not,already,param,patterns,0,or,more,url,patterns,if,0,the,condition,will,match,to,every,request;public,patterns,request,condition,string,patterns,this,as,list,patterns,null
PatternsRequestCondition -> public PatternsRequestCondition(String... patterns);1498861175;Creates a new instance with the given URL patterns._Each pattern is prepended with "/" if not already._@param patterns 0 or more URL patterns_ if 0 the condition will match to every request.;public PatternsRequestCondition(String... patterns) {_		this(asList(patterns), null)__	};creates,a,new,instance,with,the,given,url,patterns,each,pattern,is,prepended,with,if,not,already,param,patterns,0,or,more,url,patterns,if,0,the,condition,will,match,to,every,request;public,patterns,request,condition,string,patterns,this,as,list,patterns,null
PatternsRequestCondition -> public PatternsRequestCondition(String... patterns);1498861175;Creates a new instance with the given URL patterns._Each pattern is prepended with "/" if not already._@param patterns 0 or more URL patterns_ if 0 the condition will match to every request.;public PatternsRequestCondition(String... patterns) {_		this(patterns, null)__	};creates,a,new,instance,with,the,given,url,patterns,each,pattern,is,prepended,with,if,not,already,param,patterns,0,or,more,url,patterns,if,0,the,condition,will,match,to,every,request;public,patterns,request,condition,string,patterns,this,patterns,null
PatternsRequestCondition -> public PatternsRequestCondition(String... patterns);1498944474;Creates a new instance with the given URL patterns._Each pattern is prepended with "/" if not already._@param patterns 0 or more URL patterns_ if 0 the condition will match to every request.;public PatternsRequestCondition(String... patterns) {_		this(patterns, null)__	};creates,a,new,instance,with,the,given,url,patterns,each,pattern,is,prepended,with,if,not,already,param,patterns,0,or,more,url,patterns,if,0,the,condition,will,match,to,every,request;public,patterns,request,condition,string,patterns,this,patterns,null
PatternsRequestCondition -> public SortedSet<PathPattern> getMatchingPatterns(String lookupPath);1486635693;Find the patterns matching the given lookup path. Invoking this method should_yield results equivalent to those of calling_{@link #getMatchingCondition(ServerWebExchange)}._This method is provided as an alternative to be used if no request is available_(e.g. introspection, tooling, etc)._@param lookupPath the lookup path to match to existing patterns_@return a sorted set of matching patterns sorted with the closest match first;public SortedSet<PathPattern> getMatchingPatterns(String lookupPath) {_		return this.patternRegistry.findMatches(lookupPath)__	};find,the,patterns,matching,the,given,lookup,path,invoking,this,method,should,yield,results,equivalent,to,those,of,calling,link,get,matching,condition,server,web,exchange,this,method,is,provided,as,an,alternative,to,be,used,if,no,request,is,available,e,g,introspection,tooling,etc,param,lookup,path,the,lookup,path,to,match,to,existing,patterns,return,a,sorted,set,of,matching,patterns,sorted,with,the,closest,match,first;public,sorted,set,path,pattern,get,matching,patterns,string,lookup,path,return,this,pattern,registry,find,matches,lookup,path
PatternsRequestCondition -> public SortedSet<PathPattern> getMatchingPatterns(String lookupPath);1486652296;Find the patterns matching the given lookup path. Invoking this method should_yield results equivalent to those of calling_{@link #getMatchingCondition(ServerWebExchange)}._This method is provided as an alternative to be used if no request is available_(e.g. introspection, tooling, etc)._@param lookupPath the lookup path to match to existing patterns_@return a sorted set of matching patterns sorted with the closest match first;public SortedSet<PathPattern> getMatchingPatterns(String lookupPath) {_		return this.patternRegistry.findMatches(lookupPath)__	};find,the,patterns,matching,the,given,lookup,path,invoking,this,method,should,yield,results,equivalent,to,those,of,calling,link,get,matching,condition,server,web,exchange,this,method,is,provided,as,an,alternative,to,be,used,if,no,request,is,available,e,g,introspection,tooling,etc,param,lookup,path,the,lookup,path,to,match,to,existing,patterns,return,a,sorted,set,of,matching,patterns,sorted,with,the,closest,match,first;public,sorted,set,path,pattern,get,matching,patterns,string,lookup,path,return,this,pattern,registry,find,matches,lookup,path
PatternsRequestCondition -> public SortedSet<PathPattern> getMatchingPatterns(String lookupPath);1486674586;Find the patterns matching the given lookup path. Invoking this method should_yield results equivalent to those of calling_{@link #getMatchingCondition(ServerWebExchange)}._This method is provided as an alternative to be used if no request is available_(e.g. introspection, tooling, etc)._@param lookupPath the lookup path to match to existing patterns_@return a sorted set of matching patterns sorted with the closest match first;public SortedSet<PathPattern> getMatchingPatterns(String lookupPath) {_		return this.patternRegistry.findMatches(lookupPath)__	};find,the,patterns,matching,the,given,lookup,path,invoking,this,method,should,yield,results,equivalent,to,those,of,calling,link,get,matching,condition,server,web,exchange,this,method,is,provided,as,an,alternative,to,be,used,if,no,request,is,available,e,g,introspection,tooling,etc,param,lookup,path,the,lookup,path,to,match,to,existing,patterns,return,a,sorted,set,of,matching,patterns,sorted,with,the,closest,match,first;public,sorted,set,path,pattern,get,matching,patterns,string,lookup,path,return,this,pattern,registry,find,matches,lookup,path
PatternsRequestCondition -> public SortedSet<PathPattern> getMatchingPatterns(String lookupPath);1497286385;Find the patterns matching the given lookup path. Invoking this method should_yield results equivalent to those of calling_{@link #getMatchingCondition(ServerWebExchange)}._This method is provided as an alternative to be used if no request is available_(e.g. introspection, tooling, etc)._@param lookupPath the lookup path to match to existing patterns_@return a sorted set of matching patterns sorted with the closest match first;public SortedSet<PathPattern> getMatchingPatterns(String lookupPath) {_		return patterns.stream()_				.filter(pattern -> pattern.matches(lookupPath))_				.collect(Collectors.toCollection(() ->_						new TreeSet<>(new PathPatternComparator(lookupPath))))__	};find,the,patterns,matching,the,given,lookup,path,invoking,this,method,should,yield,results,equivalent,to,those,of,calling,link,get,matching,condition,server,web,exchange,this,method,is,provided,as,an,alternative,to,be,used,if,no,request,is,available,e,g,introspection,tooling,etc,param,lookup,path,the,lookup,path,to,match,to,existing,patterns,return,a,sorted,set,of,matching,patterns,sorted,with,the,closest,match,first;public,sorted,set,path,pattern,get,matching,patterns,string,lookup,path,return,patterns,stream,filter,pattern,pattern,matches,lookup,path,collect,collectors,to,collection,new,tree,set,new,path,pattern,comparator,lookup,path
PatternsRequestCondition -> public SortedSet<PathPattern> getMatchingPatterns(String lookupPath);1498861175;Find the patterns matching the given lookup path. Invoking this method should_yield results equivalent to those of calling_{@link #getMatchingCondition(ServerWebExchange)}._This method is provided as an alternative to be used if no request is available_(e.g. introspection, tooling, etc)._@param lookupPath the lookup path to match to existing patterns_@return a sorted set of matching patterns sorted with the closest match first;public SortedSet<PathPattern> getMatchingPatterns(String lookupPath) {_		return patterns.stream()_				.filter(pattern -> pattern.matches(lookupPath))_				.collect(Collectors.toCollection(() ->_						new TreeSet<>(new PathPatternComparator(lookupPath))))__	};find,the,patterns,matching,the,given,lookup,path,invoking,this,method,should,yield,results,equivalent,to,those,of,calling,link,get,matching,condition,server,web,exchange,this,method,is,provided,as,an,alternative,to,be,used,if,no,request,is,available,e,g,introspection,tooling,etc,param,lookup,path,the,lookup,path,to,match,to,existing,patterns,return,a,sorted,set,of,matching,patterns,sorted,with,the,closest,match,first;public,sorted,set,path,pattern,get,matching,patterns,string,lookup,path,return,patterns,stream,filter,pattern,pattern,matches,lookup,path,collect,collectors,to,collection,new,tree,set,new,path,pattern,comparator,lookup,path
