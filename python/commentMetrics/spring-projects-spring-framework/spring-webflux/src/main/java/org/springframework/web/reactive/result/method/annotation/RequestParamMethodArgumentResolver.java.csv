commented;modifiers;parameterAmount;loc;comment;code
false;public;1;11;;@Override public boolean supportsParameter(MethodParameter param) {     if (checkAnnotatedParamNoReactiveWrapper(param, RequestParam.class, this::singleParam)) {         return true.     } else if (this.useDefaultResolution) {         return checkParameterTypeNoReactiveWrapper(param, BeanUtils::isSimpleProperty) || BeanUtils.isSimpleProperty(param.nestedIfOptional().getNestedParameterType()).     }     return false. }
false;private;2;3;;private boolean singleParam(RequestParam requestParam, Class<?> type) {     return !Map.class.isAssignableFrom(type) || StringUtils.hasText(requestParam.name()). }
false;protected;1;5;;@Override protected NamedValueInfo createNamedValueInfo(MethodParameter parameter) {     RequestParam ann = parameter.getParameterAnnotation(RequestParam.class).     return (ann != null ? new RequestParamNamedValueInfo(ann) : new RequestParamNamedValueInfo()). }
false;protected;3;9;;@Override protected Object resolveNamedValue(String name, MethodParameter parameter, ServerWebExchange exchange) {     List<String> paramValues = exchange.getRequest().getQueryParams().get(name).     Object result = null.     if (paramValues != null) {         result = (paramValues.size() == 1 ? paramValues.get(0) : paramValues).     }     return result. }
false;protected;3;6;;@Override protected void handleMissingValue(String name, MethodParameter parameter, ServerWebExchange exchange) {     String type = parameter.getNestedParameterType().getSimpleName().     String reason = "Required " + type + " parameter '" + name + "' is not present".     throw new ServerWebInputException(reason, parameter). }
