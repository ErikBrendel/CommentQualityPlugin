commented;modifiers;parameterAmount;loc;comment;code
true;public,static;1;3;/**  * Create an {@code ExchangeFunction} with the given {@code ClientHttpConnector}.  * This is the same as calling  * {@link #create(ClientHttpConnector, ExchangeStrategies)} and passing  * {@link ExchangeStrategies#withDefaults()}.  * @param connector the connector to use for connecting to servers  * @return the created {@code ExchangeFunction}  */ ;/**  * Create an {@code ExchangeFunction} with the given {@code ClientHttpConnector}.  * This is the same as calling  * {@link #create(ClientHttpConnector, ExchangeStrategies)} and passing  * {@link ExchangeStrategies#withDefaults()}.  * @param connector the connector to use for connecting to servers  * @return the created {@code ExchangeFunction}  */ public static ExchangeFunction create(ClientHttpConnector connector) {     return create(connector, ExchangeStrategies.withDefaults()). }
true;public,static;2;3;/**  * Create an {@code ExchangeFunction} with the given  * {@code ClientHttpConnector} and {@code ExchangeStrategies}.  * @param connector the connector to use for connecting to servers  * @param strategies the {@code ExchangeStrategies} to use  * @return the created {@code ExchangeFunction}  */ ;/**  * Create an {@code ExchangeFunction} with the given  * {@code ClientHttpConnector} and {@code ExchangeStrategies}.  * @param connector the connector to use for connecting to servers  * @param strategies the {@code ExchangeStrategies} to use  * @return the created {@code ExchangeFunction}  */ public static ExchangeFunction create(ClientHttpConnector connector, ExchangeStrategies strategies) {     return new DefaultExchangeFunction(connector, strategies). }
false;public;1;16;;@Override public Mono<ClientResponse> exchange(ClientRequest clientRequest) {     Assert.notNull(clientRequest, "ClientRequest must not be null").     HttpMethod httpMethod = clientRequest.method().     URI url = clientRequest.url().     String logPrefix = clientRequest.logPrefix().     return this.connector.connect(httpMethod, url, httpRequest -> clientRequest.writeTo(httpRequest, this.strategies)).doOnRequest(n -> logRequest(clientRequest)).doOnCancel(() -> logger.debug(logPrefix + "Cancel signal (to close connection)")).map(httpResponse -> {         logResponse(httpResponse, logPrefix).         return new DefaultClientResponse(httpResponse, this.strategies, logPrefix).     }). }
false;private;1;6;;private void logRequest(ClientRequest request) {     LogFormatUtils.traceDebug(logger, traceOn -> request.logPrefix() + "HTTP " + request.method() + " " + request.url() + (traceOn ? ", headers=" + formatHeaders(request.headers()) : "")). }
false;private;2;8;;private void logResponse(ClientHttpResponse response, String logPrefix) {     LogFormatUtils.traceDebug(logger, traceOn -> {         int code = response.getRawStatusCode().         HttpStatus status = HttpStatus.resolve(code).         return logPrefix + "Response " + (status != null ? status : code) + (traceOn ? ", headers=" + formatHeaders(response.getHeaders()) : "").     }). }
false;private;1;3;;private String formatHeaders(HttpHeaders headers) {     return this.enableLoggingRequestDetails ? headers.toString() : headers.isEmpty() ? "{}" : "{masked}". }
