commented;modifiers;parameterAmount;loc;comment;code
true;public;1;3;/**  * See {@link ScriptTemplateConfigurer#setEngine(ScriptEngine)} documentation.  */ ;/**  * See {@link ScriptTemplateConfigurer#setEngine(ScriptEngine)} documentation.  */ public void setEngine(ScriptEngine engine) {     this.engine = engine. }
true;public;1;3;/**  * See {@link ScriptTemplateConfigurer#setEngineName(String)} documentation.  */ ;/**  * See {@link ScriptTemplateConfigurer#setEngineName(String)} documentation.  */ public void setEngineName(String engineName) {     this.engineName = engineName. }
true;public;1;3;/**  * See {@link ScriptTemplateConfigurer#setSharedEngine(Boolean)} documentation.  */ ;/**  * See {@link ScriptTemplateConfigurer#setSharedEngine(Boolean)} documentation.  */ public void setSharedEngine(Boolean sharedEngine) {     this.sharedEngine = sharedEngine. }
true;public;1;3;/**  * See {@link ScriptTemplateConfigurer#setScripts(String...)} documentation.  */ ;/**  * See {@link ScriptTemplateConfigurer#setScripts(String...)} documentation.  */ public void setScripts(String... scripts) {     this.scripts = scripts. }
true;public;1;3;/**  * See {@link ScriptTemplateConfigurer#setRenderObject(String)} documentation.  */ ;/**  * See {@link ScriptTemplateConfigurer#setRenderObject(String)} documentation.  */ public void setRenderObject(String renderObject) {     this.renderObject = renderObject. }
true;public;1;3;/**  * See {@link ScriptTemplateConfigurer#setRenderFunction(String)} documentation.  */ ;/**  * See {@link ScriptTemplateConfigurer#setRenderFunction(String)} documentation.  */ public void setRenderFunction(String functionName) {     this.renderFunction = functionName. }
true;public;1;12;/**  * See {@link ScriptTemplateConfigurer#setResourceLoaderPath(String)} documentation.  */ ;/**  * See {@link ScriptTemplateConfigurer#setResourceLoaderPath(String)} documentation.  */ public void setResourceLoaderPath(String resourceLoaderPath) {     String[] paths = StringUtils.commaDelimitedListToStringArray(resourceLoaderPath).     this.resourceLoaderPaths = new String[paths.length + 1].     this.resourceLoaderPaths[0] = "".     for (int i = 0. i < paths.length. i++) {         String path = paths[i].         if (!path.endsWith("/") && !path.endsWith(":")) {             path = path + "/".         }         this.resourceLoaderPaths[i + 1] = path.     } }
false;public;1;53;;@Override public void setApplicationContext(@Nullable ApplicationContext context) {     super.setApplicationContext(context).     ScriptTemplateConfig viewConfig = autodetectViewConfig().     if (this.engine == null && viewConfig.getEngine() != null) {         setEngine(viewConfig.getEngine()).     }     if (this.engineName == null && viewConfig.getEngineName() != null) {         this.engineName = viewConfig.getEngineName().     }     if (this.scripts == null && viewConfig.getScripts() != null) {         this.scripts = viewConfig.getScripts().     }     if (this.renderObject == null && viewConfig.getRenderObject() != null) {         this.renderObject = viewConfig.getRenderObject().     }     if (this.renderFunction == null && viewConfig.getRenderFunction() != null) {         this.renderFunction = viewConfig.getRenderFunction().     }     if (viewConfig.getCharset() != null) {         setDefaultCharset(viewConfig.getCharset()).     }     if (this.resourceLoaderPaths == null) {         String resourceLoaderPath = viewConfig.getResourceLoaderPath().         setResourceLoaderPath(resourceLoaderPath != null ? resourceLoaderPath : DEFAULT_RESOURCE_LOADER_PATH).     }     if (this.sharedEngine == null && viewConfig.isSharedEngine() != null) {         this.sharedEngine = viewConfig.isSharedEngine().     }     Assert.isTrue(!(this.engine != null && this.engineName != null), "You should define either 'engine' or 'engineName', not both.").     Assert.isTrue(!(this.engine == null && this.engineName == null), "No script engine found, please specify either 'engine' or 'engineName'.").     if (Boolean.FALSE.equals(this.sharedEngine)) {         Assert.isTrue(this.engineName != null, "When 'sharedEngine' is set to false, you should specify the " + "script engine using the 'engineName' property, not the 'engine' one.").     } else if (this.engine != null) {         loadScripts(this.engine).     } else {         setEngine(createEngineFromName(this.engineName)).     }     if (this.renderFunction != null && this.engine != null) {         Assert.isInstanceOf(Invocable.class, this.engine, "ScriptEngine must implement Invocable when 'renderFunction' is specified").     } }
false;protected;0;10;;protected ScriptEngine getEngine() {     if (Boolean.FALSE.equals(this.sharedEngine)) {         Assert.state(this.engineName != null, "No engine name specified").         return createEngineFromName(this.engineName).     } else {         Assert.state(this.engine != null, "No shared engine available").         return this.engine.     } }
false;protected;1;11;;protected ScriptEngine createEngineFromName(String engineName) {     ScriptEngineManager scriptEngineManager = this.scriptEngineManager.     if (scriptEngineManager == null) {         scriptEngineManager = new ScriptEngineManager(obtainApplicationContext().getClassLoader()).         this.scriptEngineManager = scriptEngineManager.     }     ScriptEngine engine = StandardScriptUtils.retrieveEngineByName(scriptEngineManager, engineName).     loadScripts(engine).     return engine. }
false;protected;1;16;;protected void loadScripts(ScriptEngine engine) {     if (!ObjectUtils.isEmpty(this.scripts)) {         for (String script : this.scripts) {             Resource resource = getResource(script).             if (resource == null) {                 throw new IllegalStateException("Script resource [" + script + "] not found").             }             try {                 engine.eval(new InputStreamReader(resource.getInputStream())).             } catch (Throwable ex) {                 throw new IllegalStateException("Failed to evaluate script [" + script + "]", ex).             }         }     } }
false;protected;1;12;;@Nullable protected Resource getResource(String location) {     if (this.resourceLoaderPaths != null) {         for (String path : this.resourceLoaderPaths) {             Resource resource = obtainApplicationContext().getResource(path + location).             if (resource.exists()) {                 return resource.             }         }     }     return null. }
false;protected;0;11;;protected ScriptTemplateConfig autodetectViewConfig() throws BeansException {     try {         return BeanFactoryUtils.beanOfTypeIncludingAncestors(obtainApplicationContext(), ScriptTemplateConfig.class, true, false).     } catch (NoSuchBeanDefinitionException ex) {         throw new ApplicationContextException("Expected a single ScriptTemplateConfig bean in the current " + "web application context or the parent root context: ScriptTemplateConfigurer is " + "the usual implementation. This bean may have any name.", ex).     } }
false;public;1;6;;@Override public boolean checkResourceExists(Locale locale) throws Exception {     String url = getUrl().     Assert.state(url != null, "'url' not set").     return (getResource(url) != null). }
false;protected;3;52;;@Override protected Mono<Void> renderInternal(Map<String, Object> model, @Nullable MediaType contentType, ServerWebExchange exchange) {     return Mono.defer(() -> {         ServerHttpResponse response = exchange.getResponse().         try {             ScriptEngine engine = getEngine().             String url = getUrl().             Assert.state(url != null, "'url' not set").             String template = getTemplate(url).             Function<String, String> templateLoader = path -> {                 try {                     return getTemplate(path).                 } catch (IOException ex) {                     throw new IllegalStateException(ex).                 }             }.             Locale locale = LocaleContextHolder.getLocale(exchange.getLocaleContext()).             RenderingContext context = new RenderingContext(obtainApplicationContext(), locale, templateLoader, url).             Object html.             if (this.renderFunction == null) {                 SimpleBindings bindings = new SimpleBindings().                 bindings.putAll(model).                 model.put("renderingContext", context).                 html = engine.eval(template, bindings).             } else if (this.renderObject != null) {                 Object thiz = engine.eval(this.renderObject).                 html = ((Invocable) engine).invokeMethod(thiz, this.renderFunction, template, model, context).             } else {                 html = ((Invocable) engine).invokeFunction(this.renderFunction, template, model, context).             }             byte[] bytes = String.valueOf(html).getBytes(StandardCharsets.UTF_8).             DataBuffer buffer = response.bufferFactory().allocateBuffer(bytes.length).write(bytes).             return response.writeWith(Mono.just(buffer)).         } catch (ScriptException ex) {             throw new IllegalStateException("Failed to render script template", new StandardScriptEvalException(ex)).         } catch (Exception ex) {             throw new IllegalStateException("Failed to render script template", ex).         }     }). }
false;protected;1;8;;protected String getTemplate(String path) throws IOException {     Resource resource = getResource(path).     if (resource == null) {         throw new IllegalStateException("Template resource [" + path + "] not found").     }     InputStreamReader reader = new InputStreamReader(resource.getInputStream(), getDefaultCharset()).     return FileCopyUtils.copyToString(reader). }
