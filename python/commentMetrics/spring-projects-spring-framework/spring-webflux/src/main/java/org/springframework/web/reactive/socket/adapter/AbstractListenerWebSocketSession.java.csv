commented;modifiers;parameterAmount;loc;comment;code
false;protected;0;5;;protected WebSocketSendProcessor getSendProcessor() {     WebSocketSendProcessor sendProcessor = this.sendProcessor.     Assert.state(sendProcessor != null, "No WebSocketSendProcessor available").     return sendProcessor. }
false;public;0;5;;@Override public Flux<WebSocketMessage> receive() {     return (canSuspendReceiving() ? Flux.from(this.receivePublisher) : Flux.from(this.receivePublisher).onBackpressureBuffer(RECEIVE_BUFFER_SIZE)). }
false;public;1;14;;@Override public Mono<Void> send(Publisher<WebSocketMessage> messages) {     if (this.sendCalled.compareAndSet(false, true)) {         WebSocketSendProcessor sendProcessor = new WebSocketSendProcessor().         this.sendProcessor = sendProcessor.         return Mono.from(subscriber -> {             messages.subscribe(sendProcessor).             sendProcessor.subscribe(subscriber).         }).     } else {         return Mono.error(new IllegalStateException("send() has already been called")).     } }
true;protected,abstract;0;1;/**  * Whether the underlying WebSocket API has flow control and can suspend and  * resume the receiving of messages.  * <p><strong>Note:</strong> Sub-classes are encouraged to start out in  * suspended mode, if possible, and wait until demand is received.  */ ;/**  * Whether the underlying WebSocket API has flow control and can suspend and  * resume the receiving of messages.  * <p><strong>Note:</strong> Sub-classes are encouraged to start out in  * suspended mode, if possible, and wait until demand is received.  */ protected abstract boolean canSuspendReceiving().
true;protected,abstract;0;1;/**  * Suspend receiving until received message(s) are processed and more demand  * is generated by the downstream Subscriber.  * <p><strong>Note:</strong> if the underlying WebSocket API does not provide  * flow control for receiving messages, this method should be a no-op  * and {@link #canSuspendReceiving()} should return {@code false}.  */ ;/**  * Suspend receiving until received message(s) are processed and more demand  * is generated by the downstream Subscriber.  * <p><strong>Note:</strong> if the underlying WebSocket API does not provide  * flow control for receiving messages, this method should be a no-op  * and {@link #canSuspendReceiving()} should return {@code false}.  */ protected abstract void suspendReceiving().
true;protected,abstract;0;1;/**  * Resume receiving new message(s) after demand is generated by the  * downstream Subscriber.  * <p><strong>Note:</strong> if the underlying WebSocket API does not provide  * flow control for receiving messages, this method should be a no-op  * and {@link #canSuspendReceiving()} should return {@code false}.  */ ;/**  * Resume receiving new message(s) after demand is generated by the  * downstream Subscriber.  * <p><strong>Note:</strong> if the underlying WebSocket API does not provide  * flow control for receiving messages, this method should be a no-op  * and {@link #canSuspendReceiving()} should return {@code false}.  */ protected abstract void resumeReceiving().
true;protected,abstract;1;1;/**  * Send the given WebSocket message.  * <p><strong>Note:</strong> Sub-classes are responsible for releasing the  * payload data buffer, once fully written, if pooled buffers apply to the  * underlying container.  */ ;/**  * Send the given WebSocket message.  * <p><strong>Note:</strong> Sub-classes are responsible for releasing the  * payload data buffer, once fully written, if pooled buffers apply to the  * underlying container.  */ protected abstract boolean sendMessage(WebSocketMessage message) throws IOException.
true;;2;3;/**  * Handle a message callback from the WebSocketHandler adapter.  */ ;// WebSocketHandler adapter delegate methods /**  * Handle a message callback from the WebSocketHandler adapter.  */ void handleMessage(Type type, WebSocketMessage message) {     this.receivePublisher.handleMessage(message). }
true;;1;8;/**  * Handle an error callback from the WebSocketHandler adapter.  */ ;/**  * Handle an error callback from the WebSocketHandler adapter.  */ void handleError(Throwable ex) {     this.receivePublisher.onError(ex).     WebSocketSendProcessor sendProcessor = this.sendProcessor.     if (sendProcessor != null) {         sendProcessor.cancel().         sendProcessor.onError(ex).     } }
true;;1;8;/**  * Handle a close callback from the WebSocketHandler adapter.  */ ;/**  * Handle a close callback from the WebSocketHandler adapter.  */ void handleClose(CloseStatus reason) {     this.receivePublisher.onAllDataRead().     WebSocketSendProcessor sendProcessor = this.sendProcessor.     if (sendProcessor != null) {         sendProcessor.cancel().         sendProcessor.onComplete().     } }
false;public;1;4;;// Subscriber<Void> implementation @Override public void onSubscribe(Subscription subscription) {     subscription.request(Long.MAX_VALUE). }
false;public;1;4;;@Override public void onNext(Void aVoid) { // no op }
false;public;1;8;;@Override public void onError(Throwable ex) {     if (this.completionMono != null) {         this.completionMono.onError(ex).     }     int code = CloseStatus.SERVER_ERROR.getCode().     close(new CloseStatus(code, ex.getMessage())). }
false;public;0;7;;@Override public void onComplete() {     if (this.completionMono != null) {         this.completionMono.onComplete().     }     close(). }
false;protected;0;11;;@Override protected void checkOnDataAvailable() {     resumeReceiving().     int size = this.pendingMessages.size().     if (rsReadLogger.isTraceEnabled()) {         rsReadLogger.trace(getLogPrefix() + "checkOnDataAvailable (" + size + " pending)").     }     if (size > 0) {         onDataAvailable().     } }
false;protected;0;4;;@Override protected void readingPaused() {     suspendReceiving(). }
false;protected;0;5;;@Override @Nullable protected WebSocketMessage read() throws IOException {     return (WebSocketMessage) this.pendingMessages.poll(). }
false;;1;14;;void handleMessage(WebSocketMessage message) {     if (logger.isTraceEnabled()) {         logger.trace(getLogPrefix() + "Received " + message).     } else if (rsReadLogger.isTraceEnabled()) {         rsReadLogger.trace(getLogPrefix() + "Received " + message).     }     if (!this.pendingMessages.offer(message)) {         discardData().         throw new IllegalStateException("Too many messages. Please ensure WebSocketSession.receive() is subscribed to.").     }     onDataAvailable(). }
false;protected;0;10;;@Override protected void discardData() {     while (true) {         WebSocketMessage message = (WebSocketMessage) this.pendingMessages.poll().         if (message == null) {             return.         }         message.release().     } }
false;protected;1;11;;@Override protected boolean write(WebSocketMessage message) throws IOException {     if (logger.isTraceEnabled()) {         logger.trace(getLogPrefix() + "Sending " + message).     } else if (rsWriteLogger.isTraceEnabled()) {         rsWriteLogger.trace(getLogPrefix() + "Sending " + message).     }     // In case of IOException, onError handling should call discardData(WebSocketMessage)..     return sendMessage(message). }
false;protected;1;4;;@Override protected boolean isDataEmpty(WebSocketMessage message) {     return (message.getPayload().readableByteCount() == 0). }
false;protected;0;4;;@Override protected boolean isWritePossible() {     return (this.isReady). }
true;public;1;6;/**  * Sub-classes can invoke this before sending a message (false) and  * after receiving the async send callback (true) effective translating  * async completion callback into simple flow control.  */ ;/**  * Sub-classes can invoke this before sending a message (false) and  * after receiving the async send callback (true) effective translating  * async completion callback into simple flow control.  */ public void setReadyToSend(boolean ready) {     if (ready && rsWriteLogger.isTraceEnabled()) {         rsWriteLogger.trace(getLogPrefix() + "Ready to send").     }     this.isReady = ready. }
false;protected;1;4;;@Override protected void discardData(WebSocketMessage message) {     message.release(). }
