commented;modifiers;parameterAmount;loc;comment;code
true;public;1;3;/**  * Configure the argument resolvers to use to use for resolving method  * argument values against a {@code ServerWebExchange}.  */ ;/**  * Configure the argument resolvers to use to use for resolving method  * argument values against a {@code ServerWebExchange}.  */ public void setArgumentResolvers(List<HandlerMethodArgumentResolver> resolvers) {     this.resolvers.addResolvers(resolvers). }
true;public;0;3;/**  * Return the configured argument resolvers.  */ ;/**  * Return the configured argument resolvers.  */ public List<HandlerMethodArgumentResolver> getResolvers() {     return this.resolvers.getResolvers(). }
true;public;1;3;/**  * Set the ParameterNameDiscoverer for resolving parameter names when needed  * (e.g. default request attribute name).  * <p>Default is a {@link DefaultParameterNameDiscoverer}.  */ ;/**  * Set the ParameterNameDiscoverer for resolving parameter names when needed  * (e.g. default request attribute name).  * <p>Default is a {@link DefaultParameterNameDiscoverer}.  */ public void setParameterNameDiscoverer(ParameterNameDiscoverer nameDiscoverer) {     this.parameterNameDiscoverer = nameDiscoverer. }
true;public;0;3;/**  * Return the configured parameter name discoverer.  */ ;/**  * Return the configured parameter name discoverer.  */ public ParameterNameDiscoverer getParameterNameDiscoverer() {     return this.parameterNameDiscoverer. }
true;public;1;3;/**  * Configure a reactive registry. This is needed for cases where the response  * is fully handled within the controller in combination with an async void  * return value.  * <p>By default this is an instance of {@link ReactiveAdapterRegistry} with  * default settings.  * @param registry the registry to use  */ ;/**  * Configure a reactive registry. This is needed for cases where the response  * is fully handled within the controller in combination with an async void  * return value.  * <p>By default this is an instance of {@link ReactiveAdapterRegistry} with  * default settings.  * @param registry the registry to use  */ public void setReactiveAdapterRegistry(ReactiveAdapterRegistry registry) {     this.reactiveAdapterRegistry = registry. }
true;public;3;38;/**  * Invoke the method for the given exchange.  * @param exchange the current exchange  * @param bindingContext the binding context to use  * @param providedArgs optional list of argument values to match by type  * @return a Mono with a {@link HandlerResult}.  */ ;/**  * Invoke the method for the given exchange.  * @param exchange the current exchange  * @param bindingContext the binding context to use  * @param providedArgs optional list of argument values to match by type  * @return a Mono with a {@link HandlerResult}.  */ public Mono<HandlerResult> invoke(ServerWebExchange exchange, BindingContext bindingContext, Object... providedArgs) {     return getMethodArgumentValues(exchange, bindingContext, providedArgs).flatMap(args -> {         Object value.         try {             ReflectionUtils.makeAccessible(getBridgedMethod()).             value = getBridgedMethod().invoke(getBean(), args).         } catch (IllegalArgumentException ex) {             assertTargetBean(getBridgedMethod(), getBean(), args).             String text = (ex.getMessage() != null ? ex.getMessage() : "Illegal argument").             return Mono.error(new IllegalStateException(formatInvokeError(text, args), ex)).         } catch (InvocationTargetException ex) {             return Mono.error(ex.getTargetException()).         } catch (Throwable ex) {             // Unlikely to ever get here, but it must be handled...             return Mono.error(new IllegalStateException(formatInvokeError("Invocation failure", args), ex)).         }         HttpStatus status = getResponseStatus().         if (status != null) {             exchange.getResponse().setStatusCode(status).         }         MethodParameter returnType = getReturnType().         ReactiveAdapter adapter = this.reactiveAdapterRegistry.getAdapter(returnType.getParameterType()).         boolean asyncVoid = isAsyncVoidReturnType(returnType, adapter).         if ((value == null || asyncVoid) && isResponseHandled(args, exchange)) {             return (asyncVoid ? Mono.from(adapter.toPublisher(value)) : Mono.empty()).         }         HandlerResult result = new HandlerResult(this, value, returnType, bindingContext).         return Mono.just(result).     }). }
false;private;3;32;;private Mono<Object[]> getMethodArgumentValues(ServerWebExchange exchange, BindingContext bindingContext, Object... providedArgs) {     if (ObjectUtils.isEmpty(getMethodParameters())) {         return EMPTY_ARGS.     }     MethodParameter[] parameters = getMethodParameters().     List<Mono<Object>> argMonos = new ArrayList<>(parameters.length).     for (MethodParameter parameter : parameters) {         parameter.initParameterNameDiscovery(this.parameterNameDiscoverer).         Object providedArg = findProvidedArgument(parameter, providedArgs).         if (providedArg != null) {             argMonos.add(Mono.just(providedArg)).             continue.         }         if (!this.resolvers.supportsParameter(parameter)) {             return Mono.error(new IllegalStateException(formatArgumentError(parameter, "No suitable resolver"))).         }         try {             argMonos.add(this.resolvers.resolveArgument(parameter, bindingContext, exchange).defaultIfEmpty(NO_ARG_VALUE).doOnError(cause -> logArgumentErrorIfNecessary(exchange, parameter, cause))).         } catch (Exception ex) {             logArgumentErrorIfNecessary(exchange, parameter, ex).             argMonos.add(Mono.error(ex)).         }     }     return Mono.zip(argMonos, values -> Stream.of(values).map(o -> o != NO_ARG_VALUE ? o : null).toArray()). }
false;private;3;11;;private void logArgumentErrorIfNecessary(ServerWebExchange exchange, MethodParameter parameter, Throwable cause) {     // Leave stack trace for later, if error is not handled..     String message = cause.getMessage().     if (!message.contains(parameter.getExecutable().toGenericString())) {         if (logger.isDebugEnabled()) {             logger.debug(exchange.getLogPrefix() + formatArgumentError(parameter, message)).         }     } }
false;private,static;2;15;;private static boolean isAsyncVoidReturnType(MethodParameter returnType, @Nullable ReactiveAdapter adapter) {     if (adapter != null && adapter.supportsEmpty()) {         if (adapter.isNoValue()) {             return true.         }         Type parameterType = returnType.getGenericParameterType().         if (parameterType instanceof ParameterizedType) {             ParameterizedType type = (ParameterizedType) parameterType.             if (type.getActualTypeArguments().length == 1) {                 return Void.class.equals(type.getActualTypeArguments()[0]).             }         }     }     return false. }
false;private;2;11;;private boolean isResponseHandled(Object[] args, ServerWebExchange exchange) {     if (getResponseStatus() != null || exchange.isNotModified()) {         return true.     }     for (Object arg : args) {         if (arg instanceof ServerHttpResponse || arg instanceof ServerWebExchange) {             return true.         }     }     return false. }
