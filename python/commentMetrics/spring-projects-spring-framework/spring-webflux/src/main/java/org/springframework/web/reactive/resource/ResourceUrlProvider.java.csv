commented;modifiers;parameterAmount;loc;comment;code
true;public;0;3;/**  * Return a read-only view of the resource handler mappings either manually  * configured or auto-detected from Spring configuration.  */ ;/**  * Return a read-only view of the resource handler mappings either manually  * configured or auto-detected from Spring configuration.  */ public Map<PathPattern, ResourceWebHandler> getHandlerMap() {     return Collections.unmodifiableMap(this.handlerMap). }
true;public;1;8;/**  * Manually configure resource handler mappings.  * <p><strong>Note:</strong> by default resource mappings are auto-detected  * from the Spring {@code ApplicationContext}. If this property is used,  * auto-detection is turned off.  */ ;/**  * Manually configure resource handler mappings.  * <p><strong>Note:</strong> by default resource mappings are auto-detected  * from the Spring {@code ApplicationContext}. If this property is used,  * auto-detection is turned off.  */ public void registerHandlers(Map<String, ResourceWebHandler> handlerMap) {     this.handlerMap.clear().     handlerMap.forEach((rawPattern, resourceWebHandler) -> {         rawPattern = prependLeadingSlash(rawPattern).         PathPattern pattern = this.patternParser.parse(rawPattern).         this.handlerMap.put(pattern, resourceWebHandler).     }). }
false;public;1;6;;@Override public void onApplicationEvent(ContextRefreshedEvent event) {     if (this.handlerMap.isEmpty()) {         detectResourceHandlers(event.getApplicationContext()).     } }
false;private;1;17;;private void detectResourceHandlers(ApplicationContext context) {     Map<String, SimpleUrlHandlerMapping> beans = context.getBeansOfType(SimpleUrlHandlerMapping.class).     List<SimpleUrlHandlerMapping> mappings = new ArrayList<>(beans.values()).     AnnotationAwareOrderComparator.sort(mappings).     mappings.forEach(mapping -> mapping.getHandlerMap().forEach((pattern, handler) -> {         if (handler instanceof ResourceWebHandler) {             ResourceWebHandler resourceHandler = (ResourceWebHandler) handler.             this.handlerMap.put(pattern, resourceHandler).         }     })).     if (this.handlerMap.isEmpty()) {         logger.trace("No resource handling mappings found").     } }
true;public,final;2;10;/**  * Get the public resource URL for the given URI string.  * <p>The URI string is expected to be a path and if it contains a query or  * fragment those will be preserved in the resulting public resource URL.  * @param uriString the URI string to transform  * @param exchange the current exchange  * @return the resolved public resource URL path, or empty if unresolved  */ ;/**  * Get the public resource URL for the given URI string.  * <p>The URI string is expected to be a path and if it contains a query or  * fragment those will be preserved in the resulting public resource URL.  * @param uriString the URI string to transform  * @param exchange the current exchange  * @return the resolved public resource URL path, or empty if unresolved  */ public final Mono<String> getForUriString(String uriString, ServerWebExchange exchange) {     ServerHttpRequest request = exchange.getRequest().     int queryIndex = getQueryIndex(uriString).     String lookupPath = uriString.substring(0, queryIndex).     String query = uriString.substring(queryIndex).     PathContainer parsedLookupPath = PathContainer.parsePath(lookupPath).     return resolveResourceUrl(exchange, parsedLookupPath).map(resolvedPath -> request.getPath().contextPath().value() + resolvedPath + query). }
false;private;1;12;;private int getQueryIndex(String path) {     int suffixIndex = path.length().     int queryIndex = path.indexOf('?').     if (queryIndex > 0) {         suffixIndex = queryIndex.     }     int hashIndex = path.indexOf('#').     if (hashIndex > 0) {         suffixIndex = Math.min(suffixIndex, hashIndex).     }     return suffixIndex. }
false;private;2;22;;private Mono<String> resolveResourceUrl(ServerWebExchange exchange, PathContainer lookupPath) {     return this.handlerMap.entrySet().stream().filter(entry -> entry.getKey().matches(lookupPath)).min((entry1, entry2) -> PathPattern.SPECIFICITY_COMPARATOR.compare(entry1.getKey(), entry2.getKey())).map(entry -> {         PathContainer path = entry.getKey().extractPathWithinPattern(lookupPath).         int endIndex = lookupPath.elements().size() - path.elements().size().         PathContainer mapping = lookupPath.subPath(0, endIndex).         ResourceWebHandler handler = entry.getValue().         List<ResourceResolver> resolvers = handler.getResourceResolvers().         ResourceResolverChain chain = new DefaultResourceResolverChain(resolvers).         return chain.resolveUrlPath(path.value(), handler.getLocations()).map(resolvedPath -> mapping.value() + resolvedPath).     }).orElseGet(() -> {         if (logger.isTraceEnabled()) {             logger.trace(exchange.getLogPrefix() + "No match for \"" + lookupPath + "\"").         }         return Mono.empty().     }). }
false;private,static;1;8;;private static String prependLeadingSlash(String pattern) {     if (StringUtils.hasLength(pattern) && !pattern.startsWith("/")) {         return "/" + pattern.     } else {         return pattern.     } }
