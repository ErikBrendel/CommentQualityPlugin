commented;modifiers;parameterAmount;loc;comment;code
false;public;1;5;;@Override public boolean supportsParameter(MethodParameter parameter) {     return (parameter.hasParameterAnnotation(RequestPart.class) || checkParameterType(parameter, Part.class::isAssignableFrom)). }
false;public;3;50;;@Override public Mono<Object> resolveArgument(MethodParameter parameter, BindingContext bindingContext, ServerWebExchange exchange) {     RequestPart requestPart = parameter.getParameterAnnotation(RequestPart.class).     boolean isRequired = (requestPart == null || requestPart.required()).     String name = getPartName(parameter, requestPart).     Flux<Part> parts = exchange.getMultipartData().flatMapMany(map -> {         List<Part> list = map.get(name).         if (CollectionUtils.isEmpty(list)) {             return (isRequired ? Flux.error(getMissingPartException(name, parameter)) : Flux.empty()).         }         return Flux.fromIterable(list).     }).     if (Part.class.isAssignableFrom(parameter.getParameterType())) {         return parts.next().cast(Object.class).     }     if (List.class.isAssignableFrom(parameter.getParameterType())) {         MethodParameter elementType = parameter.nested().         if (Part.class.isAssignableFrom(elementType.getNestedParameterType())) {             return parts.collectList().cast(Object.class).         } else {             return decodePartValues(parts, elementType, bindingContext, exchange, isRequired).collectList().cast(Object.class).         }     }     ReactiveAdapter adapter = getAdapterRegistry().getAdapter(parameter.getParameterType()).     if (adapter != null) {         // Mono<Part> or Flux<Part>         MethodParameter elementType = parameter.nested().         if (Part.class.isAssignableFrom(elementType.getNestedParameterType())) {             parts = (adapter.isMultiValue() ? parts : parts.take(1)).             return Mono.just(adapter.fromPublisher(parts)).         }         // We have to decode the content for each part, one at a time         if (adapter.isMultiValue()) {             return Mono.just(decodePartValues(parts, elementType, bindingContext, exchange, isRequired)).         }     }     // <T> or Mono<T>     return decodePartValues(parts, parameter, bindingContext, exchange, isRequired).next().cast(Object.class). }
false;private;2;12;;private String getPartName(MethodParameter methodParam, @Nullable RequestPart requestPart) {     String partName = (requestPart != null ? requestPart.name() : "").     if (partName.isEmpty()) {         partName = methodParam.getParameterName().         if (partName == null) {             throw new IllegalArgumentException("Request part name for argument type [" + methodParam.getNestedParameterType().getName() + "] not specified, and parameter name information not found in class file either.").         }     }     return partName. }
false;private;2;4;;private ServerWebInputException getMissingPartException(String name, MethodParameter param) {     String reason = "Required request part '" + name + "' is not present".     return new ServerWebInputException(reason, param). }
false;private;5;12;;private Flux<?> decodePartValues(Flux<Part> parts, MethodParameter elementType, BindingContext bindingContext, ServerWebExchange exchange, boolean isRequired) {     return parts.flatMap(part -> {         ServerHttpRequest partRequest = new PartServerHttpRequest(exchange.getRequest(), part).         ServerWebExchange partExchange = exchange.mutate().request(partRequest).build().         if (logger.isDebugEnabled()) {             logger.debug(exchange.getLogPrefix() + "Decoding part '" + part.name() + "'").         }         return readBody(elementType, isRequired, bindingContext, partExchange).     }). }
false;public;0;4;;@Override public HttpHeaders getHeaders() {     return this.part.headers(). }
false;public;0;4;;@Override public Flux<DataBuffer> getBody() {     return this.part.content(). }
