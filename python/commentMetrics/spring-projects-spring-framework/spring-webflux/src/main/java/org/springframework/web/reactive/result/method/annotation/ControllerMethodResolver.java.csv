commented;modifiers;parameterAmount;loc;comment;code
false;private;3;9;;private List<SyncHandlerMethodArgumentResolver> initBinderResolvers(ArgumentResolverConfigurer customResolvers, ReactiveAdapterRegistry reactiveRegistry, ConfigurableApplicationContext context) {     return initResolvers(customResolvers, reactiveRegistry, context, false, Collections.emptyList()).stream().filter(resolver -> resolver instanceof SyncHandlerMethodArgumentResolver).map(resolver -> (SyncHandlerMethodArgumentResolver) resolver).collect(Collectors.toList()). }
false;private,static;3;6;;private static List<HandlerMethodArgumentResolver> modelMethodResolvers(ArgumentResolverConfigurer customResolvers, ReactiveAdapterRegistry reactiveRegistry, ConfigurableApplicationContext context) {     return initResolvers(customResolvers, reactiveRegistry, context, true, Collections.emptyList()). }
false;private,static;4;6;;private static List<HandlerMethodArgumentResolver> requestMappingResolvers(ArgumentResolverConfigurer customResolvers, ReactiveAdapterRegistry reactiveRegistry, ConfigurableApplicationContext context, List<HttpMessageReader<?>> readers) {     return initResolvers(customResolvers, reactiveRegistry, context, true, readers). }
false;private,static;3;6;;private static List<HandlerMethodArgumentResolver> exceptionHandlerResolvers(ArgumentResolverConfigurer customResolvers, ReactiveAdapterRegistry reactiveRegistry, ConfigurableApplicationContext context) {     return initResolvers(customResolvers, reactiveRegistry, context, false, Collections.emptyList()). }
false;private,static;5;55;;private static List<HandlerMethodArgumentResolver> initResolvers(ArgumentResolverConfigurer customResolvers, ReactiveAdapterRegistry reactiveRegistry, ConfigurableApplicationContext context, boolean supportDataBinding, List<HttpMessageReader<?>> readers) {     ConfigurableListableBeanFactory beanFactory = context.getBeanFactory().     boolean requestMappingMethod = !readers.isEmpty() && supportDataBinding.     // Annotation-based...     List<HandlerMethodArgumentResolver> result = new ArrayList<>().     result.add(new RequestParamMethodArgumentResolver(beanFactory, reactiveRegistry, false)).     result.add(new RequestParamMapMethodArgumentResolver(reactiveRegistry)).     result.add(new PathVariableMethodArgumentResolver(beanFactory, reactiveRegistry)).     result.add(new PathVariableMapMethodArgumentResolver(reactiveRegistry)).     result.add(new MatrixVariableMethodArgumentResolver(beanFactory, reactiveRegistry)).     result.add(new MatrixVariableMapMethodArgumentResolver(reactiveRegistry)).     if (!readers.isEmpty()) {         result.add(new RequestBodyArgumentResolver(readers, reactiveRegistry)).         result.add(new RequestPartMethodArgumentResolver(readers, reactiveRegistry)).     }     if (supportDataBinding) {         result.add(new ModelAttributeMethodArgumentResolver(reactiveRegistry, false)).     }     result.add(new RequestHeaderMethodArgumentResolver(beanFactory, reactiveRegistry)).     result.add(new RequestHeaderMapMethodArgumentResolver(reactiveRegistry)).     result.add(new CookieValueMethodArgumentResolver(beanFactory, reactiveRegistry)).     result.add(new ExpressionValueMethodArgumentResolver(beanFactory, reactiveRegistry)).     result.add(new SessionAttributeMethodArgumentResolver(beanFactory, reactiveRegistry)).     result.add(new RequestAttributeMethodArgumentResolver(beanFactory, reactiveRegistry)).     // Type-based...     if (!readers.isEmpty()) {         result.add(new HttpEntityArgumentResolver(readers, reactiveRegistry)).     }     result.add(new ModelArgumentResolver(reactiveRegistry)).     if (supportDataBinding) {         result.add(new ErrorsMethodArgumentResolver(reactiveRegistry)).     }     result.add(new ServerWebExchangeArgumentResolver(reactiveRegistry)).     result.add(new PrincipalArgumentResolver(reactiveRegistry)).     if (requestMappingMethod) {         result.add(new SessionStatusMethodArgumentResolver()).     }     result.add(new WebSessionArgumentResolver(reactiveRegistry)).     // Custom...     result.addAll(customResolvers.getCustomResolvers()).     // Catch-all...     result.add(new RequestParamMethodArgumentResolver(beanFactory, reactiveRegistry, true)).     if (supportDataBinding) {         result.add(new ModelAttributeMethodArgumentResolver(reactiveRegistry, true)).     }     return result. }
false;private;1;35;;private void initControllerAdviceCaches(ApplicationContext applicationContext) {     List<ControllerAdviceBean> beans = ControllerAdviceBean.findAnnotatedBeans(applicationContext).     AnnotationAwareOrderComparator.sort(beans).     for (ControllerAdviceBean bean : beans) {         Class<?> beanType = bean.getBeanType().         if (beanType != null) {             Set<Method> attrMethods = MethodIntrospector.selectMethods(beanType, MODEL_ATTRIBUTE_METHODS).             if (!attrMethods.isEmpty()) {                 this.modelAttributeAdviceCache.put(bean, attrMethods).             }             Set<Method> binderMethods = MethodIntrospector.selectMethods(beanType, INIT_BINDER_METHODS).             if (!binderMethods.isEmpty()) {                 this.initBinderAdviceCache.put(bean, binderMethods).             }             ExceptionHandlerMethodResolver resolver = new ExceptionHandlerMethodResolver(beanType).             if (resolver.hasExceptionMappings()) {                 this.exceptionHandlerAdviceCache.put(bean, resolver).             }         }     }     if (logger.isDebugEnabled()) {         int modelSize = this.modelAttributeAdviceCache.size().         int binderSize = this.initBinderAdviceCache.size().         int handlerSize = this.exceptionHandlerAdviceCache.size().         if (modelSize == 0 && binderSize == 0 && handlerSize == 0) {             logger.debug("ControllerAdvice beans: none").         } else {             logger.debug("ControllerAdvice beans: " + modelSize + " @ModelAttribute, " + binderSize + " @InitBinder, " + handlerSize + " @ExceptionHandler").         }     } }
true;public;1;6;/**  * Return an {@link InvocableHandlerMethod} for the given  * {@code @RequestMapping} method initialized with argument resolvers.  */ ;/**  * Return an {@link InvocableHandlerMethod} for the given  * {@code @RequestMapping} method initialized with argument resolvers.  */ public InvocableHandlerMethod getRequestMappingMethod(HandlerMethod handlerMethod) {     InvocableHandlerMethod invocable = new InvocableHandlerMethod(handlerMethod).     invocable.setArgumentResolvers(this.requestMappingResolvers).     invocable.setReactiveAdapterRegistry(this.reactiveAdapterRegistry).     return invocable. }
true;public;1;22;/**  * Find {@code @InitBinder} methods in {@code @ControllerAdvice} components  * or in the controller of the given {@code @RequestMapping} method.  */ ;/**  * Find {@code @InitBinder} methods in {@code @ControllerAdvice} components  * or in the controller of the given {@code @RequestMapping} method.  */ public List<SyncInvocableHandlerMethod> getInitBinderMethods(HandlerMethod handlerMethod) {     List<SyncInvocableHandlerMethod> result = new ArrayList<>().     Class<?> handlerType = handlerMethod.getBeanType().     // Global methods first     this.initBinderAdviceCache.forEach((adviceBean, methods) -> {         if (adviceBean.isApplicableToBeanType(handlerType)) {             Object bean = adviceBean.resolveBean().             methods.forEach(method -> result.add(getInitBinderMethod(bean, method))).         }     }).     this.initBinderMethodCache.computeIfAbsent(handlerType, clazz -> MethodIntrospector.selectMethods(handlerType, INIT_BINDER_METHODS)).forEach(method -> {         Object bean = handlerMethod.getBean().         result.add(getInitBinderMethod(bean, method)).     }).     return result. }
false;private;2;5;;private SyncInvocableHandlerMethod getInitBinderMethod(Object bean, Method method) {     SyncInvocableHandlerMethod invocable = new SyncInvocableHandlerMethod(bean, method).     invocable.setArgumentResolvers(this.initBinderResolvers).     return invocable. }
true;public;1;22;/**  * Find {@code @ModelAttribute} methods in {@code @ControllerAdvice}  * components or in the controller of the given {@code @RequestMapping} method.  */ ;/**  * Find {@code @ModelAttribute} methods in {@code @ControllerAdvice}  * components or in the controller of the given {@code @RequestMapping} method.  */ public List<InvocableHandlerMethod> getModelAttributeMethods(HandlerMethod handlerMethod) {     List<InvocableHandlerMethod> result = new ArrayList<>().     Class<?> handlerType = handlerMethod.getBeanType().     // Global methods first     this.modelAttributeAdviceCache.forEach((adviceBean, methods) -> {         if (adviceBean.isApplicableToBeanType(handlerType)) {             Object bean = adviceBean.resolveBean().             methods.forEach(method -> result.add(createAttributeMethod(bean, method))).         }     }).     this.modelAttributeMethodCache.computeIfAbsent(handlerType, clazz -> MethodIntrospector.selectMethods(handlerType, MODEL_ATTRIBUTE_METHODS)).forEach(method -> {         Object bean = handlerMethod.getBean().         result.add(createAttributeMethod(bean, method)).     }).     return result. }
false;private;2;5;;private InvocableHandlerMethod createAttributeMethod(Object bean, Method method) {     InvocableHandlerMethod invocable = new InvocableHandlerMethod(bean, method).     invocable.setArgumentResolvers(this.modelAttributeResolvers).     return invocable. }
true;public;2;32;/**  * Find an {@code @ExceptionHandler} method in {@code @ControllerAdvice}  * components or in the controller of the given {@code @RequestMapping} method.  */ ;/**  * Find an {@code @ExceptionHandler} method in {@code @ControllerAdvice}  * components or in the controller of the given {@code @RequestMapping} method.  */ @Nullable public InvocableHandlerMethod getExceptionHandlerMethod(Throwable ex, HandlerMethod handlerMethod) {     Class<?> handlerType = handlerMethod.getBeanType().     // Controller-local first...     Object targetBean = handlerMethod.getBean().     Method targetMethod = this.exceptionHandlerCache.computeIfAbsent(handlerType, ExceptionHandlerMethodResolver::new).resolveMethodByThrowable(ex).     if (targetMethod == null) {         // Global exception handlers...         for (ControllerAdviceBean advice : this.exceptionHandlerAdviceCache.keySet()) {             if (advice.isApplicableToBeanType(handlerType)) {                 targetBean = advice.resolveBean().                 targetMethod = this.exceptionHandlerAdviceCache.get(advice).resolveMethodByThrowable(ex).                 if (targetMethod != null) {                     break.                 }             }         }     }     if (targetMethod == null) {         return null.     }     InvocableHandlerMethod invocable = new InvocableHandlerMethod(targetBean, targetMethod).     invocable.setArgumentResolvers(this.exceptionHandlerResolvers).     return invocable. }
true;public;1;14;/**  * Return the handler for the type-level {@code @SessionAttributes} annotation  * based on the given controller method.  */ ;/**  * Return the handler for the type-level {@code @SessionAttributes} annotation  * based on the given controller method.  */ public SessionAttributesHandler getSessionAttributesHandler(HandlerMethod handlerMethod) {     Class<?> handlerType = handlerMethod.getBeanType().     SessionAttributesHandler result = this.sessionAttributesHandlerCache.get(handlerType).     if (result == null) {         synchronized (this.sessionAttributesHandlerCache) {             result = this.sessionAttributesHandlerCache.get(handlerType).             if (result == null) {                 result = new SessionAttributesHandler(handlerType).                 this.sessionAttributesHandlerCache.put(handlerType, result).             }         }     }     return result. }
