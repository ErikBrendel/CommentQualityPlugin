commented;modifiers;parameterAmount;loc;comment;code
true;public;0;3;/**  * Return a read-only list of view resolvers.  */ ;/**  * Return a read-only list of view resolvers.  */ public List<ViewResolver> getViewResolvers() {     return Collections.unmodifiableList(this.viewResolvers). }
true;public;1;6;/**  * Set the default views to consider always when resolving view names and  * trying to satisfy the best matching content type.  */ ;/**  * Set the default views to consider always when resolving view names and  * trying to satisfy the best matching content type.  */ public void setDefaultViews(@Nullable List<View> defaultViews) {     this.defaultViews.clear().     if (defaultViews != null) {         this.defaultViews.addAll(defaultViews).     } }
true;public;0;3;/**  * Return the configured default {@code View}'s.  */ ;/**  * Return the configured default {@code View}'s.  */ public List<View> getDefaultViews() {     return this.defaultViews. }
false;public;1;20;;@Override public boolean supports(HandlerResult result) {     if (hasModelAnnotation(result.getReturnTypeSource())) {         return true.     }     Class<?> type = result.getReturnType().toClass().     ReactiveAdapter adapter = getAdapter(result).     if (adapter != null) {         if (adapter.isNoValue()) {             return true.         }         type = result.getReturnType().getGeneric().toClass().     }     return (CharSequence.class.isAssignableFrom(type) || Rendering.class.isAssignableFrom(type) || Model.class.isAssignableFrom(type) || Map.class.isAssignableFrom(type) || void.class.equals(type) || View.class.isAssignableFrom(type) || !BeanUtils.isSimpleProperty(type)). }
false;private;1;3;;private boolean hasModelAnnotation(MethodParameter parameter) {     return parameter.hasMethodAnnotation(ModelAttribute.class). }
false;public;2;81;;@Override @SuppressWarnings("unchecked") public Mono<Void> handleResult(ServerWebExchange exchange, HandlerResult result) {     Mono<Object> valueMono.     ResolvableType valueType.     ReactiveAdapter adapter = getAdapter(result).     if (adapter != null) {         if (adapter.isMultiValue()) {             throw new IllegalArgumentException("Multi-value reactive types not supported in view resolution: " + result.getReturnType()).         }         valueMono = (result.getReturnValue() != null ? Mono.from(adapter.toPublisher(result.getReturnValue())) : Mono.empty()).         valueType = (adapter.isNoValue() ? ResolvableType.forClass(Void.class) : result.getReturnType().getGeneric()).     } else {         valueMono = Mono.justOrEmpty(result.getReturnValue()).         valueType = result.getReturnType().     }     return valueMono.switchIfEmpty(exchange.isNotModified() ? Mono.empty() : NO_VALUE_MONO).flatMap(returnValue -> {         Mono<List<View>> viewsMono.         Model model = result.getModel().         MethodParameter parameter = result.getReturnTypeSource().         Locale locale = LocaleContextHolder.getLocale(exchange.getLocaleContext()).         Class<?> clazz = valueType.toClass().         if (clazz == Object.class) {             clazz = returnValue.getClass().         }         if (returnValue == NO_VALUE || clazz == void.class || clazz == Void.class) {             viewsMono = resolveViews(getDefaultViewName(exchange), locale).         } else if (CharSequence.class.isAssignableFrom(clazz) && !hasModelAnnotation(parameter)) {             viewsMono = resolveViews(returnValue.toString(), locale).         } else if (Rendering.class.isAssignableFrom(clazz)) {             Rendering render = (Rendering) returnValue.             HttpStatus status = render.status().             if (status != null) {                 exchange.getResponse().setStatusCode(status).             }             exchange.getResponse().getHeaders().putAll(render.headers()).             model.addAllAttributes(render.modelAttributes()).             Object view = render.view().             if (view == null) {                 view = getDefaultViewName(exchange).             }             viewsMono = (view instanceof String ? resolveViews((String) view, locale) : Mono.just(Collections.singletonList((View) view))).         } else if (Model.class.isAssignableFrom(clazz)) {             model.addAllAttributes(((Model) returnValue).asMap()).             viewsMono = resolveViews(getDefaultViewName(exchange), locale).         } else if (Map.class.isAssignableFrom(clazz) && !hasModelAnnotation(parameter)) {             model.addAllAttributes((Map<String, ?>) returnValue).             viewsMono = resolveViews(getDefaultViewName(exchange), locale).         } else if (View.class.isAssignableFrom(clazz)) {             viewsMono = Mono.just(Collections.singletonList((View) returnValue)).         } else {             String name = getNameForReturnValue(parameter).             model.addAttribute(name, returnValue).             viewsMono = resolveViews(getDefaultViewName(exchange), locale).         }         updateBindingContext(result.getBindingContext(), exchange).         return viewsMono.flatMap(views -> render(views, model.asMap(), exchange)).     }). }
true;private;1;10;/**  * Select a default view name when a controller did not specify it.  * Use the request path the leading and trailing slash stripped.  */ ;/**  * Select a default view name when a controller did not specify it.  * Use the request path the leading and trailing slash stripped.  */ private String getDefaultViewName(ServerWebExchange exchange) {     String path = exchange.getRequest().getPath().pathWithinApplication().value().     if (path.startsWith("/")) {         path = path.substring(1).     }     if (path.endsWith("/")) {         path = path.substring(0, path.length() - 1).     }     return StringUtils.stripFilenameExtension(path). }
false;private;2;13;;private Mono<List<View>> resolveViews(String viewName, Locale locale) {     return Flux.fromIterable(getViewResolvers()).concatMap(resolver -> resolver.resolveViewName(viewName, locale)).collectList().map(views -> {         if (views.isEmpty()) {             throw new IllegalStateException("Could not resolve view with name '" + viewName + "'.").         }         views.addAll(getDefaultViews()).         return views.     }). }
false;private;1;6;;private String getNameForReturnValue(MethodParameter returnType) {     return Optional.ofNullable(returnType.getMethodAnnotation(ModelAttribute.class)).filter(ann -> StringUtils.hasText(ann.value())).map(ModelAttribute::value).orElseGet(() -> Conventions.getVariableNameForParameter(returnType)). }
false;private;2;10;;private void updateBindingContext(BindingContext context, ServerWebExchange exchange) {     Map<String, Object> model = context.getModel().asMap().     model.keySet().stream().filter(name -> isBindingCandidate(name, model.get(name))).filter(name -> !model.containsKey(BindingResult.MODEL_KEY_PREFIX + name)).forEach(name -> {         WebExchangeDataBinder binder = context.createDataBinder(exchange, model.get(name), name).         model.put(BindingResult.MODEL_KEY_PREFIX + name, binder.getBindingResult()).     }). }
false;private;2;5;;private boolean isBindingCandidate(String name, @Nullable Object value) {     return (!name.startsWith(BindingResult.MODEL_KEY_PREFIX) && value != null && !value.getClass().isArray() && !(value instanceof Collection) && !(value instanceof Map) && !BeanUtils.isSimpleValueType(value.getClass())). }
false;private;3;22;;private Mono<? extends Void> render(List<View> views, Map<String, Object> model, ServerWebExchange exchange) {     for (View view : views) {         if (view.isRedirectView()) {             return view.render(model, null, exchange).         }     }     List<MediaType> mediaTypes = getMediaTypes(views).     MediaType bestMediaType = selectMediaType(exchange, () -> mediaTypes).     if (bestMediaType != null) {         for (View view : views) {             for (MediaType mediaType : view.getSupportedMediaTypes()) {                 if (mediaType.isCompatibleWith(bestMediaType)) {                     return view.render(model, mediaType, exchange).                 }             }         }     }     throw new NotAcceptableStatusException(mediaTypes). }
false;private;1;5;;private List<MediaType> getMediaTypes(List<View> views) {     return views.stream().flatMap(view -> view.getSupportedMediaTypes().stream()).collect(Collectors.toList()). }
