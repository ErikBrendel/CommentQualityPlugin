commented;modifiers;parameterAmount;loc;comment;code
true;public;1;4;/**  * Configure HTTP message readers to de-serialize the request body with.  * <p>By default this is set to {@link ServerCodecConfigurer}'s readers with defaults.  */ ;/**  * Configure HTTP message readers to de-serialize the request body with.  * <p>By default this is set to {@link ServerCodecConfigurer}'s readers with defaults.  */ public void setMessageReaders(List<HttpMessageReader<?>> messageReaders) {     Assert.notNull(messageReaders, "'messageReaders' must not be null").     this.messageReaders = messageReaders. }
true;public;0;3;/**  * Return the configurer for HTTP message readers.  */ ;/**  * Return the configurer for HTTP message readers.  */ public List<HttpMessageReader<?>> getMessageReaders() {     return this.messageReaders. }
true;public;1;3;/**  * Provide a WebBindingInitializer with "global" initialization to apply  * to every DataBinder instance.  */ ;/**  * Provide a WebBindingInitializer with "global" initialization to apply  * to every DataBinder instance.  */ public void setWebBindingInitializer(@Nullable WebBindingInitializer webBindingInitializer) {     this.webBindingInitializer = webBindingInitializer. }
true;public;0;4;/**  * Return the configured WebBindingInitializer, or {@code null} if none.  */ ;/**  * Return the configured WebBindingInitializer, or {@code null} if none.  */ @Nullable public WebBindingInitializer getWebBindingInitializer() {     return this.webBindingInitializer. }
true;public;1;3;/**  * Configure resolvers for controller method arguments.  */ ;/**  * Configure resolvers for controller method arguments.  */ public void setArgumentResolverConfigurer(@Nullable ArgumentResolverConfigurer configurer) {     this.argumentResolverConfigurer = configurer. }
true;public;0;4;/**  * Return the configured resolvers for controller method arguments.  */ ;/**  * Return the configured resolvers for controller method arguments.  */ @Nullable public ArgumentResolverConfigurer getArgumentResolverConfigurer() {     return this.argumentResolverConfigurer. }
true;public;1;3;/**  * Configure the registry for adapting various reactive types.  * <p>By default this is an instance of {@link ReactiveAdapterRegistry} with  * default settings.  */ ;/**  * Configure the registry for adapting various reactive types.  * <p>By default this is an instance of {@link ReactiveAdapterRegistry} with  * default settings.  */ public void setReactiveAdapterRegistry(@Nullable ReactiveAdapterRegistry registry) {     this.reactiveAdapterRegistry = registry. }
true;public;0;4;/**  * Return the configured registry for adapting reactive types.  */ ;/**  * Return the configured registry for adapting reactive types.  */ @Nullable public ReactiveAdapterRegistry getReactiveAdapterRegistry() {     return this.reactiveAdapterRegistry. }
true;public;1;6;/**  * A {@link ConfigurableApplicationContext} is expected for resolving  * expressions in method argument default values as well as for  * detecting {@code @ControllerAdvice} beans.  */ ;/**  * A {@link ConfigurableApplicationContext} is expected for resolving  * expressions in method argument default values as well as for  * detecting {@code @ControllerAdvice} beans.  */ @Override public void setApplicationContext(ApplicationContext applicationContext) {     if (applicationContext instanceof ConfigurableApplicationContext) {         this.applicationContext = (ConfigurableApplicationContext) applicationContext.     } }
false;public;0;20;;@Override public void afterPropertiesSet() throws Exception {     Assert.notNull(this.applicationContext, "ApplicationContext is required").     if (CollectionUtils.isEmpty(this.messageReaders)) {         ServerCodecConfigurer codecConfigurer = ServerCodecConfigurer.create().         this.messageReaders = codecConfigurer.getReaders().     }     if (this.argumentResolverConfigurer == null) {         this.argumentResolverConfigurer = new ArgumentResolverConfigurer().     }     if (this.reactiveAdapterRegistry == null) {         this.reactiveAdapterRegistry = ReactiveAdapterRegistry.getSharedInstance().     }     this.methodResolver = new ControllerMethodResolver(this.argumentResolverConfigurer, this.reactiveAdapterRegistry, this.applicationContext, this.messageReaders).     this.modelInitializer = new ModelInitializer(this.methodResolver, this.reactiveAdapterRegistry). }
false;public;1;4;;@Override public boolean supports(Object handler) {     return handler instanceof HandlerMethod. }
false;public;2;20;;@Override public Mono<HandlerResult> handle(ServerWebExchange exchange, Object handler) {     HandlerMethod handlerMethod = (HandlerMethod) handler.     Assert.state(this.methodResolver != null && this.modelInitializer != null, "Not initialized").     InitBinderBindingContext bindingContext = new InitBinderBindingContext(getWebBindingInitializer(), this.methodResolver.getInitBinderMethods(handlerMethod)).     InvocableHandlerMethod invocableMethod = this.methodResolver.getRequestMappingMethod(handlerMethod).     Function<Throwable, Mono<HandlerResult>> exceptionHandler = ex -> handleException(ex, handlerMethod, bindingContext, exchange).     return this.modelInitializer.initModel(handlerMethod, bindingContext, exchange).then(Mono.defer(() -> invocableMethod.invoke(exchange, bindingContext))).doOnNext(result -> result.setExceptionHandler(exceptionHandler)).doOnNext(result -> bindingContext.saveModel()).onErrorResume(exceptionHandler). }
false;private;4;34;;private Mono<HandlerResult> handleException(Throwable exception, HandlerMethod handlerMethod, BindingContext bindingContext, ServerWebExchange exchange) {     Assert.state(this.methodResolver != null, "Not initialized").     // Success and error responses may use different content types     exchange.getAttributes().remove(HandlerMapping.PRODUCIBLE_MEDIA_TYPES_ATTRIBUTE).     if (!exchange.getResponse().isCommitted()) {         exchange.getResponse().getHeaders().remove(HttpHeaders.CONTENT_TYPE).     }     InvocableHandlerMethod invocable = this.methodResolver.getExceptionHandlerMethod(exception, handlerMethod).     if (invocable != null) {         try {             if (logger.isDebugEnabled()) {                 logger.debug(exchange.getLogPrefix() + "Using @ExceptionHandler " + invocable).             }             bindingContext.getModel().asMap().clear().             Throwable cause = exception.getCause().             if (cause != null) {                 return invocable.invoke(exchange, bindingContext, exception, cause, handlerMethod).             } else {                 return invocable.invoke(exchange, bindingContext, exception, handlerMethod).             }         } catch (Throwable invocationEx) {             if (logger.isWarnEnabled()) {                 logger.warn(exchange.getLogPrefix() + "Failure in @ExceptionHandler " + invocable, invocationEx).             }         }     }     return Mono.error(exception). }
