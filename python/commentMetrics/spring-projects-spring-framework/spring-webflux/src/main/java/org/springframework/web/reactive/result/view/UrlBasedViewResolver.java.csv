commented;modifiers;parameterAmount;loc;comment;code
true;public;1;8;/**  * Set the view class to instantiate through {@link #createView(String)}.  * @param viewClass a class that is assignable to the required view class  * which by default is AbstractUrlBasedView  */ ;/**  * Set the view class to instantiate through {@link #createView(String)}.  * @param viewClass a class that is assignable to the required view class  * which by default is AbstractUrlBasedView  */ public void setViewClass(@Nullable Class<?> viewClass) {     if (viewClass != null && !requiredViewClass().isAssignableFrom(viewClass)) {         String name = viewClass.getName().         throw new IllegalArgumentException("Given view class [" + name + "] " + "is not of type [" + requiredViewClass().getName() + "]").     }     this.viewClass = viewClass. }
true;protected;0;4;/**  * Return the view class to be used to create views.  */ ;/**  * Return the view class to be used to create views.  */ @Nullable protected Class<?> getViewClass() {     return this.viewClass. }
true;protected;0;3;/**  * Return the required type of view for this resolver.  * This implementation returns {@link AbstractUrlBasedView}.  * @see AbstractUrlBasedView  */ ;/**  * Return the required type of view for this resolver.  * This implementation returns {@link AbstractUrlBasedView}.  * @see AbstractUrlBasedView  */ protected Class<?> requiredViewClass() {     return AbstractUrlBasedView.class. }
true;public;1;3;/**  * Set the prefix that gets prepended to view names when building a URL.  */ ;/**  * Set the prefix that gets prepended to view names when building a URL.  */ public void setPrefix(@Nullable String prefix) {     this.prefix = (prefix != null ? prefix : ""). }
true;protected;0;3;/**  * Return the prefix that gets prepended to view names when building a URL.  */ ;/**  * Return the prefix that gets prepended to view names when building a URL.  */ protected String getPrefix() {     return this.prefix. }
true;public;1;3;/**  * Set the suffix that gets appended to view names when building a URL.  */ ;/**  * Set the suffix that gets appended to view names when building a URL.  */ public void setSuffix(@Nullable String suffix) {     this.suffix = (suffix != null ? suffix : ""). }
true;protected;0;3;/**  * Return the suffix that gets appended to view names when building a URL.  */ ;/**  * Return the suffix that gets appended to view names when building a URL.  */ protected String getSuffix() {     return this.suffix. }
true;public;1;3;/**  * Set the view names (or name patterns) that can be handled by this  * {@link ViewResolver}. View names can contain simple wildcards such that  * 'my*', '*Report' and '*Repo*' will all match the view name 'myReport'.  * @see #canHandle  */ ;/**  * Set the view names (or name patterns) that can be handled by this  * {@link ViewResolver}. View names can contain simple wildcards such that  * 'my*', '*Report' and '*Repo*' will all match the view name 'myReport'.  * @see #canHandle  */ public void setViewNames(@Nullable String... viewNames) {     this.viewNames = viewNames. }
true;protected;0;4;/**  * Return the view names (or name patterns) that can be handled by this  * {@link ViewResolver}.  */ ;/**  * Return the view names (or name patterns) that can be handled by this  * {@link ViewResolver}.  */ @Nullable protected String[] getViewNames() {     return this.viewNames. }
true;public;1;3;/**  * URL based {@link RedirectView} provider which can be used to provide, for example,  * redirect views with a custom default status code.  */ ;/**  * URL based {@link RedirectView} provider which can be used to provide, for example,  * redirect views with a custom default status code.  */ public void setRedirectViewProvider(Function<String, RedirectView> redirectViewProvider) {     this.redirectViewProvider = redirectViewProvider. }
true;public;1;3;/**  * Set the name of the {@link RequestContext} attribute for all views.  * @param requestContextAttribute name of the RequestContext attribute  * @see AbstractView#setRequestContextAttribute  */ ;/**  * Set the name of the {@link RequestContext} attribute for all views.  * @param requestContextAttribute name of the RequestContext attribute  * @see AbstractView#setRequestContextAttribute  */ public void setRequestContextAttribute(@Nullable String requestContextAttribute) {     this.requestContextAttribute = requestContextAttribute. }
true;protected;0;4;/**  * Return the name of the @link RequestContext} attribute for all views, if any.  */ ;/**  * Return the name of the @link RequestContext} attribute for all views, if any.  */ @Nullable protected String getRequestContextAttribute() {     return this.requestContextAttribute. }
true;public;1;4;/**  * Accept the containing {@code ApplicationContext}, if any.  * <p>To be used for the initialization of newly created {@link View} instances,  * applying lifecycle callbacks and providing access to the containing environment.  * @see #setViewClass  * @see #createView  * @see #applyLifecycleMethods  */ ;/**  * Accept the containing {@code ApplicationContext}, if any.  * <p>To be used for the initialization of newly created {@link View} instances,  * applying lifecycle callbacks and providing access to the containing environment.  * @see #setViewClass  * @see #createView  * @see #applyLifecycleMethods  */ @Override public void setApplicationContext(@Nullable ApplicationContext applicationContext) {     this.applicationContext = applicationContext. }
true;public;0;4;/**  * Return the containing {@code ApplicationContext}, if any.  * @see #setApplicationContext  */ ;/**  * Return the containing {@code ApplicationContext}, if any.  * @see #setApplicationContext  */ @Nullable public ApplicationContext getApplicationContext() {     return this.applicationContext. }
false;public;0;6;;@Override public void afterPropertiesSet() throws Exception {     if (getViewClass() == null) {         throw new IllegalArgumentException("Property 'viewClass' is required").     } }
false;public;2;23;;@Override public Mono<View> resolveViewName(String viewName, Locale locale) {     if (!canHandle(viewName, locale)) {         return Mono.empty().     }     AbstractUrlBasedView urlBasedView.     if (viewName.startsWith(REDIRECT_URL_PREFIX)) {         String redirectUrl = viewName.substring(REDIRECT_URL_PREFIX.length()).         urlBasedView = this.redirectViewProvider.apply(redirectUrl).     } else {         urlBasedView = createView(viewName).     }     View view = applyLifecycleMethods(viewName, urlBasedView).     try {         return (urlBasedView.checkResourceExists(locale) ? Mono.just(view) : Mono.empty()).     } catch (Exception ex) {         return Mono.error(ex).     } }
true;protected;2;4;/**  * Indicates whether or not this {@link ViewResolver} can handle the supplied  * view name. If not, an empty result is returned. The default implementation  * checks against the configured {@link #setViewNames view names}.  * @param viewName the name of the view to retrieve  * @param locale the Locale to retrieve the view for  * @return whether this resolver applies to the specified view  * @see org.springframework.util.PatternMatchUtils#simpleMatch(String, String)  */ ;/**  * Indicates whether or not this {@link ViewResolver} can handle the supplied  * view name. If not, an empty result is returned. The default implementation  * checks against the configured {@link #setViewNames view names}.  * @param viewName the name of the view to retrieve  * @param locale the Locale to retrieve the view for  * @return whether this resolver applies to the specified view  * @see org.springframework.util.PatternMatchUtils#simpleMatch(String, String)  */ protected boolean canHandle(String viewName, Locale locale) {     String[] viewNames = getViewNames().     return (viewNames == null || PatternMatchUtils.simpleMatch(viewNames, viewName)). }
true;protected;1;12;/**  * Creates a new View instance of the specified view class and configures it.  * Does <i>not</i> perform any lookup for pre-defined View instances.  * <p>Spring lifecycle methods as defined by the bean container do not have to  * be called here: They will be automatically applied afterwards, provided  * that an {@link #setApplicationContext ApplicationContext} is available.  * @param viewName the name of the view to build  * @return the View instance  * @see #getViewClass()  * @see #applyLifecycleMethods  */ ;/**  * Creates a new View instance of the specified view class and configures it.  * Does <i>not</i> perform any lookup for pre-defined View instances.  * <p>Spring lifecycle methods as defined by the bean container do not have to  * be called here: They will be automatically applied afterwards, provided  * that an {@link #setApplicationContext ApplicationContext} is available.  * @param viewName the name of the view to build  * @return the View instance  * @see #getViewClass()  * @see #applyLifecycleMethods  */ protected AbstractUrlBasedView createView(String viewName) {     Class<?> viewClass = getViewClass().     Assert.state(viewClass != null, "No view class").     AbstractUrlBasedView view = (AbstractUrlBasedView) BeanUtils.instantiateClass(viewClass).     view.setSupportedMediaTypes(getSupportedMediaTypes()).     view.setRequestContextAttribute(getRequestContextAttribute()).     view.setDefaultCharset(getDefaultCharset()).     view.setUrl(getPrefix() + viewName + getSuffix()).     return view. }
true;protected;2;10;/**  * Apply the containing {@link ApplicationContext}'s lifecycle methods  * to the given {@link View} instance, if such a context is available.  * @param viewName the name of the view  * @param view the freshly created View instance, pre-configured with  * {@link AbstractUrlBasedView}'s properties  * @return the {@link View} instance to use (either the original one  * or a decorated variant)  * @see #getApplicationContext()  * @see ApplicationContext#getAutowireCapableBeanFactory()  * @see org.springframework.beans.factory.config.AutowireCapableBeanFactory#initializeBean  */ ;/**  * Apply the containing {@link ApplicationContext}'s lifecycle methods  * to the given {@link View} instance, if such a context is available.  * @param viewName the name of the view  * @param view the freshly created View instance, pre-configured with  * {@link AbstractUrlBasedView}'s properties  * @return the {@link View} instance to use (either the original one  * or a decorated variant)  * @see #getApplicationContext()  * @see ApplicationContext#getAutowireCapableBeanFactory()  * @see org.springframework.beans.factory.config.AutowireCapableBeanFactory#initializeBean  */ protected View applyLifecycleMethods(String viewName, AbstractUrlBasedView view) {     ApplicationContext context = getApplicationContext().     if (context != null) {         Object initialized = context.getAutowireCapableBeanFactory().initializeBean(view, viewName).         if (initialized instanceof View) {             return (View) initialized.         }     }     return view. }
