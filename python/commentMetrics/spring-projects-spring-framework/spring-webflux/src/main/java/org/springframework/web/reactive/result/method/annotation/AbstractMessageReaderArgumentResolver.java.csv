commented;modifiers;parameterAmount;loc;comment;code
true;public;0;3;/**  * Return the configured message converters.  */ ;/**  * Return the configured message converters.  */ public List<HttpMessageReader<?>> getMessageReaders() {     return this.messageReaders. }
true;protected;4;5;/**  * Read the body from a method argument with {@link HttpMessageReader}.  * @param bodyParameter the {@link MethodParameter} to read  * @param isBodyRequired true if the body is required  * @param bindingContext the binding context to use  * @param exchange the current exchange  * @return the body  * @see #readBody(MethodParameter, MethodParameter, boolean, BindingContext, ServerWebExchange)  */ ;/**  * Read the body from a method argument with {@link HttpMessageReader}.  * @param bodyParameter the {@link MethodParameter} to read  * @param isBodyRequired true if the body is required  * @param bindingContext the binding context to use  * @param exchange the current exchange  * @return the body  * @see #readBody(MethodParameter, MethodParameter, boolean, BindingContext, ServerWebExchange)  */ protected Mono<Object> readBody(MethodParameter bodyParameter, boolean isBodyRequired, BindingContext bindingContext, ServerWebExchange exchange) {     return this.readBody(bodyParameter, null, isBodyRequired, bindingContext, exchange). }
true;protected;5;76;/**  * Read the body from a method argument with {@link HttpMessageReader}.  * @param bodyParam represents the element type for the body  * @param actualParam the actual method argument type. possibly different  * from {@code bodyParam}, e.g. for an {@code HttpEntity} argument  * @param isBodyRequired true if the body is required  * @param bindingContext the binding context to use  * @param exchange the current exchange  * @return a Mono with the value to use for the method argument  * @since 5.0.2  */ ;/**  * Read the body from a method argument with {@link HttpMessageReader}.  * @param bodyParam represents the element type for the body  * @param actualParam the actual method argument type. possibly different  * from {@code bodyParam}, e.g. for an {@code HttpEntity} argument  * @param isBodyRequired true if the body is required  * @param bindingContext the binding context to use  * @param exchange the current exchange  * @return a Mono with the value to use for the method argument  * @since 5.0.2  */ protected Mono<Object> readBody(MethodParameter bodyParam, @Nullable MethodParameter actualParam, boolean isBodyRequired, BindingContext bindingContext, ServerWebExchange exchange) {     ResolvableType bodyType = ResolvableType.forMethodParameter(bodyParam).     ResolvableType actualType = (actualParam != null ? ResolvableType.forMethodParameter(actualParam) : bodyType).     Class<?> resolvedType = bodyType.resolve().     ReactiveAdapter adapter = (resolvedType != null ? getAdapterRegistry().getAdapter(resolvedType) : null).     ResolvableType elementType = (adapter != null ? bodyType.getGeneric() : bodyType).     isBodyRequired = isBodyRequired || (adapter != null && !adapter.supportsEmpty()).     ServerHttpRequest request = exchange.getRequest().     ServerHttpResponse response = exchange.getResponse().     MediaType contentType = request.getHeaders().getContentType().     MediaType mediaType = (contentType != null ? contentType : MediaType.APPLICATION_OCTET_STREAM).     Object[] hints = extractValidationHints(bodyParam).     if (logger.isDebugEnabled()) {         logger.debug(exchange.getLogPrefix() + (contentType != null ? "Content-Type:" + contentType : "No Content-Type, using " + MediaType.APPLICATION_OCTET_STREAM)).     }     for (HttpMessageReader<?> reader : getMessageReaders()) {         if (reader.canRead(elementType, mediaType)) {             Map<String, Object> readHints = Hints.from(Hints.LOG_PREFIX_HINT, exchange.getLogPrefix()).             if (adapter != null && adapter.isMultiValue()) {                 if (logger.isDebugEnabled()) {                     logger.debug(exchange.getLogPrefix() + "0..N [" + elementType + "]").                 }                 Flux<?> flux = reader.read(actualType, elementType, request, response, readHints).                 flux = flux.onErrorResume(ex -> Flux.error(handleReadError(bodyParam, ex))).                 if (isBodyRequired) {                     flux = flux.switchIfEmpty(Flux.error(() -> handleMissingBody(bodyParam))).                 }                 if (hints != null) {                     flux = flux.doOnNext(target -> validate(target, hints, bodyParam, bindingContext, exchange)).                 }                 return Mono.just(adapter.fromPublisher(flux)).             } else {                 // Single-value (with or without reactive type wrapper)                 if (logger.isDebugEnabled()) {                     logger.debug(exchange.getLogPrefix() + "0..1 [" + elementType + "]").                 }                 Mono<?> mono = reader.readMono(actualType, elementType, request, response, readHints).                 mono = mono.onErrorResume(ex -> Mono.error(handleReadError(bodyParam, ex))).                 if (isBodyRequired) {                     mono = mono.switchIfEmpty(Mono.error(() -> handleMissingBody(bodyParam))).                 }                 if (hints != null) {                     mono = mono.doOnNext(target -> validate(target, hints, bodyParam, bindingContext, exchange)).                 }                 return (adapter != null ? Mono.just(adapter.fromPublisher(mono)) : Mono.from(mono)).             }         }     }     // No compatible reader but body may be empty..     HttpMethod method = request.getMethod().     if (contentType == null && method != null && SUPPORTED_METHODS.contains(method)) {         Flux<DataBuffer> body = request.getBody().doOnNext(o -> {             // Body not empty, back to 415..             throw new UnsupportedMediaTypeStatusException(mediaType, this.supportedMediaTypes, elementType).         }).         if (isBodyRequired) {             body = body.switchIfEmpty(Mono.error(() -> handleMissingBody(bodyParam))).         }         return (adapter != null ? Mono.just(adapter.fromPublisher(body)) : Mono.from(body)).     }     return Mono.error(new UnsupportedMediaTypeStatusException(mediaType, this.supportedMediaTypes, elementType)). }
false;private;2;4;;private Throwable handleReadError(MethodParameter parameter, Throwable ex) {     return (ex instanceof DecodingException ? new ServerWebInputException("Failed to read HTTP message", parameter, ex) : ex). }
false;private;1;4;;private ServerWebInputException handleMissingBody(MethodParameter parameter) {     String paramInfo = parameter.getExecutable().toGenericString().     return new ServerWebInputException("Request body is missing: " + paramInfo, parameter). }
true;private;1;12;/**  * Check if the given MethodParameter requires validation and if so return  * a (possibly empty) Object[] with validation hints. A return value of  * {@code null} indicates that validation is not required.  */ ;/**  * Check if the given MethodParameter requires validation and if so return  * a (possibly empty) Object[] with validation hints. A return value of  * {@code null} indicates that validation is not required.  */ @Nullable private Object[] extractValidationHints(MethodParameter parameter) {     Annotation[] annotations = parameter.getParameterAnnotations().     for (Annotation ann : annotations) {         Validated validatedAnn = AnnotationUtils.getAnnotation(ann, Validated.class).         if (validatedAnn != null || ann.annotationType().getSimpleName().startsWith("Valid")) {             Object hints = (validatedAnn != null ? validatedAnn.value() : AnnotationUtils.getValue(ann)).             return (hints instanceof Object[] ? (Object[]) hints : new Object[] { hints }).         }     }     return null. }
false;private;5;10;;private void validate(Object target, Object[] validationHints, MethodParameter param, BindingContext binding, ServerWebExchange exchange) {     String name = Conventions.getVariableNameForParameter(param).     WebExchangeDataBinder binder = binding.createDataBinder(exchange, target, name).     binder.validate(validationHints).     if (binder.getBindingResult().hasErrors()) {         throw new WebExchangeBindException(param, binder.getBindingResult()).     } }
