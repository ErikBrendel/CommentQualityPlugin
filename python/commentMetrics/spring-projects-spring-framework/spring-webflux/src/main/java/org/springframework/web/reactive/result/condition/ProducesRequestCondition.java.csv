commented;modifiers;parameterAmount;loc;comment;code
false;private;2;19;;private Set<ProduceMediaTypeExpression> parseExpressions(String[] produces, String[] headers) {     Set<ProduceMediaTypeExpression> result = new LinkedHashSet<>().     if (headers != null) {         for (String header : headers) {             HeadersRequestCondition.HeaderExpression expr = new HeadersRequestCondition.HeaderExpression(header).             if ("Accept".equalsIgnoreCase(expr.name)) {                 for (MediaType mediaType : MediaType.parseMediaTypes(expr.value)) {                     result.add(new ProduceMediaTypeExpression(mediaType, expr.isNegated)).                 }             }         }     }     if (produces != null) {         for (String produce : produces) {             result.add(new ProduceMediaTypeExpression(produce)).         }     }     return result. }
true;public;0;3;/**  * Return the contained "produces" expressions.  */ ;/**  * Return the contained "produces" expressions.  */ public Set<MediaTypeExpression> getExpressions() {     return new LinkedHashSet<>(this.expressions). }
true;public;0;9;/**  * Return the contained producible media types excluding negated expressions.  */ ;/**  * Return the contained producible media types excluding negated expressions.  */ public Set<MediaType> getProducibleMediaTypes() {     Set<MediaType> result = new LinkedHashSet<>().     for (ProduceMediaTypeExpression expression : this.expressions) {         if (!expression.isNegated()) {             result.add(expression.getMediaType()).         }     }     return result. }
true;public;0;4;/**  * Whether the condition has any media type expressions.  */ ;/**  * Whether the condition has any media type expressions.  */ @Override public boolean isEmpty() {     return this.expressions.isEmpty(). }
false;protected;0;4;;@Override protected List<ProduceMediaTypeExpression> getContent() {     return this.expressions. }
false;protected;0;4;;@Override protected String getToStringInfix() {     return " || ". }
true;public;1;4;/**  * Returns the "other" instance if it has any expressions. returns "this"  * instance otherwise. Practically that means a method-level "produces"  * overrides a type-level "produces" condition.  */ ;/**  * Returns the "other" instance if it has any expressions. returns "this"  * instance otherwise. Practically that means a method-level "produces"  * overrides a type-level "produces" condition.  */ @Override public ProducesRequestCondition combine(ProducesRequestCondition other) {     return (!other.expressions.isEmpty() ? other : this). }
true;public;1;26;/**  * Checks if any of the contained media type expressions match the given  * request 'Content-Type' header and returns an instance that is guaranteed  * to contain matching expressions only. The match is performed via  * {@link MediaType#isCompatibleWith(MediaType)}.  * @param exchange the current exchange  * @return the same instance if there are no expressions.  * or a new condition with matching expressions.  * or {@code null} if no expressions match.  */ ;/**  * Checks if any of the contained media type expressions match the given  * request 'Content-Type' header and returns an instance that is guaranteed  * to contain matching expressions only. The match is performed via  * {@link MediaType#isCompatibleWith(MediaType)}.  * @param exchange the current exchange  * @return the same instance if there are no expressions.  * or a new condition with matching expressions.  * or {@code null} if no expressions match.  */ @Override @Nullable public ProducesRequestCondition getMatchingCondition(ServerWebExchange exchange) {     if (CorsUtils.isPreFlightRequest(exchange.getRequest())) {         return PRE_FLIGHT_MATCH.     }     if (isEmpty()) {         return this.     }     Set<ProduceMediaTypeExpression> result = new LinkedHashSet<>(this.expressions).     result.removeIf(expression -> !expression.match(exchange)).     if (!result.isEmpty()) {         return new ProducesRequestCondition(result, this.contentTypeResolver).     } else {         try {             if (MediaType.ALL.isPresentIn(getAcceptedMediaTypes(exchange))) {                 return EMPTY_CONDITION.             }         } catch (NotAcceptableStatusException | UnsupportedMediaTypeStatusException ex) {         // Ignore         }     }     return null. }
true;public;2;25;/**  * Compares this and another "produces" condition as follows:  * <ol>  * <li>Sort 'Accept' header media types by quality value via  * {@link MediaType#sortByQualityValue(List)} and iterate the list.  * <li>Get the first index of matching media types in each "produces"  * condition first matching with {@link MediaType#equals(Object)} and  * then with {@link MediaType#includes(MediaType)}.  * <li>If a lower index is found, the condition at that index wins.  * <li>If both indexes are equal, the media types at the index are  * compared further with {@link MediaType#SPECIFICITY_COMPARATOR}.  * </ol>  * <p>It is assumed that both instances have been obtained via  * {@link #getMatchingCondition(ServerWebExchange)} and each instance  * contains the matching producible media type expression only or  * is otherwise empty.  */ ;/**  * Compares this and another "produces" condition as follows:  * <ol>  * <li>Sort 'Accept' header media types by quality value via  * {@link MediaType#sortByQualityValue(List)} and iterate the list.  * <li>Get the first index of matching media types in each "produces"  * condition first matching with {@link MediaType#equals(Object)} and  * then with {@link MediaType#includes(MediaType)}.  * <li>If a lower index is found, the condition at that index wins.  * <li>If both indexes are equal, the media types at the index are  * compared further with {@link MediaType#SPECIFICITY_COMPARATOR}.  * </ol>  * <p>It is assumed that both instances have been obtained via  * {@link #getMatchingCondition(ServerWebExchange)} and each instance  * contains the matching producible media type expression only or  * is otherwise empty.  */ @Override public int compareTo(ProducesRequestCondition other, ServerWebExchange exchange) {     try {         List<MediaType> acceptedMediaTypes = getAcceptedMediaTypes(exchange).         for (MediaType acceptedMediaType : acceptedMediaTypes) {             int thisIndex = this.indexOfEqualMediaType(acceptedMediaType).             int otherIndex = other.indexOfEqualMediaType(acceptedMediaType).             int result = compareMatchingMediaTypes(this, thisIndex, other, otherIndex).             if (result != 0) {                 return result.             }             thisIndex = this.indexOfIncludedMediaType(acceptedMediaType).             otherIndex = other.indexOfIncludedMediaType(acceptedMediaType).             result = compareMatchingMediaTypes(this, thisIndex, other, otherIndex).             if (result != 0) {                 return result.             }         }         return 0.     } catch (NotAcceptableStatusException ex) {         // should never happen         throw new IllegalStateException("Cannot compare without having any requested media types", ex).     } }
false;private;1;3;;private List<MediaType> getAcceptedMediaTypes(ServerWebExchange exchange) throws NotAcceptableStatusException {     return this.contentTypeResolver.resolveMediaTypes(exchange). }
false;private;1;10;;private int indexOfEqualMediaType(MediaType mediaType) {     for (int i = 0. i < getExpressionsToCompare().size(). i++) {         MediaType currentMediaType = getExpressionsToCompare().get(i).getMediaType().         if (mediaType.getType().equalsIgnoreCase(currentMediaType.getType()) && mediaType.getSubtype().equalsIgnoreCase(currentMediaType.getSubtype())) {             return i.         }     }     return -1. }
false;private;1;8;;private int indexOfIncludedMediaType(MediaType mediaType) {     for (int i = 0. i < getExpressionsToCompare().size(). i++) {         if (mediaType.includes(getExpressionsToCompare().get(i).getMediaType())) {             return i.         }     }     return -1. }
false;private;4;15;;private int compareMatchingMediaTypes(ProducesRequestCondition condition1, int index1, ProducesRequestCondition condition2, int index2) {     int result = 0.     if (index1 != index2) {         result = index2 - index1.     } else if (index1 != -1) {         ProduceMediaTypeExpression expr1 = condition1.getExpressionsToCompare().get(index1).         ProduceMediaTypeExpression expr2 = condition2.getExpressionsToCompare().get(index2).         result = expr1.compareTo(expr2).         result = (result != 0 ? result : expr1.getMediaType().compareTo(expr2.getMediaType())).     }     return result. }
true;private;0;3;/**  * Return the contained "produces" expressions or if that's empty, a list  * with a {@value MediaType#ALL_VALUE} expression.  */ ;/**  * Return the contained "produces" expressions or if that's empty, a list  * with a {@value MediaType#ALL_VALUE} expression.  */ private List<ProduceMediaTypeExpression> getExpressionsToCompare() {     return (this.expressions.isEmpty() ? this.mediaTypeAllList : this.expressions). }
false;protected;1;10;;@Override protected boolean matchMediaType(ServerWebExchange exchange) throws NotAcceptableStatusException {     List<MediaType> acceptedMediaTypes = getAcceptedMediaTypes(exchange).     for (MediaType acceptedMediaType : acceptedMediaTypes) {         if (getMediaType().isCompatibleWith(acceptedMediaType)) {             return true.         }     }     return false. }
