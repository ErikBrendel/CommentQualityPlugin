commented;modifiers;parameterAmount;loc;comment;code
false;public;3;22;;@Override public Mono<Resource> transform(ServerWebExchange exchange, Resource inputResource, ResourceTransformerChain chain) {     return chain.transform(exchange, inputResource).flatMap(outputResource -> {         String name = outputResource.getFilename().         if (!this.fileExtension.equals(StringUtils.getFilenameExtension(name))) {             return Mono.just(outputResource).         }         DataBufferFactory bufferFactory = exchange.getResponse().bufferFactory().         Flux<DataBuffer> flux = DataBufferUtils.read(outputResource, bufferFactory, StreamUtils.BUFFER_SIZE).         return DataBufferUtils.join(flux).flatMap(dataBuffer -> {             CharBuffer charBuffer = DEFAULT_CHARSET.decode(dataBuffer.asByteBuffer()).             DataBufferUtils.release(dataBuffer).             String content = charBuffer.toString().             return transform(content, outputResource, chain, exchange).         }).     }). }
false;private;4;22;;private Mono<? extends Resource> transform(String content, Resource resource, ResourceTransformerChain chain, ServerWebExchange exchange) {     if (!content.startsWith(MANIFEST_HEADER)) {         if (logger.isTraceEnabled()) {             logger.trace(exchange.getLogPrefix() + "Skipping " + resource + ": Manifest does not start with 'CACHE MANIFEST'").         }         return Mono.just(resource).     }     return Flux.generate(new LineInfoGenerator(content)).concatMap(info -> processLine(info, exchange, resource, chain)).reduce(new ByteArrayOutputStream(), (out, line) -> {         writeToByteArrayOutputStream(out, line + "\n").         return out.     }).map(out -> {         String hash = DigestUtils.md5DigestAsHex(out.toByteArray()).         writeToByteArrayOutputStream(out, "\n" + "# Hash: " + hash).         return new TransformedResource(resource, out.toByteArray()).     }). }
false;private,static;2;9;;private static void writeToByteArrayOutputStream(ByteArrayOutputStream out, String toWrite) {     try {         byte[] bytes = toWrite.getBytes(DEFAULT_CHARSET).         out.write(bytes).     } catch (IOException ex) {         throw Exceptions.propagate(ex).     } }
false;private;4;10;;private Mono<String> processLine(LineInfo info, ServerWebExchange exchange, Resource resource, ResourceTransformerChain chain) {     if (!info.isLink()) {         return Mono.just(info.getLine()).     }     String link = toAbsolutePath(info.getLine(), exchange).     return resolveUrlPath(link, exchange, resource, chain). }
false;public;1;12;;@Override public void accept(SynchronousSink<LineInfo> sink) {     if (this.scanner.hasNext()) {         String line = this.scanner.nextLine().         LineInfo current = new LineInfo(line, this.previous).         sink.next(current).         this.previous = current.     } else {         sink.complete().     } }
false;private,static;2;10;;private static boolean initCacheSectionFlag(String line, @Nullable LineInfo previousLine) {     if (MANIFEST_SECTION_HEADERS.contains(line.trim())) {         return line.trim().equals(CACHE_HEADER).     } else if (previousLine != null) {         return previousLine.isCacheSection().     }     throw new IllegalStateException("Manifest does not start with " + MANIFEST_HEADER + ": " + line). }
false;private,static;2;4;;private static boolean iniLinkFlag(String line, boolean isCacheSection) {     return (isCacheSection && StringUtils.hasText(line) && !line.startsWith("#") && !line.startsWith("//") && !hasScheme(line)). }
false;private,static;1;4;;private static boolean hasScheme(String line) {     int index = line.indexOf(':').     return (line.startsWith("//") || (index > 0 && !line.substring(0, index).contains("/"))). }
false;public;0;3;;public String getLine() {     return this.line. }
false;public;0;3;;public boolean isCacheSection() {     return this.cacheSection. }
false;public;0;3;;public boolean isLink() {     return this.link. }
