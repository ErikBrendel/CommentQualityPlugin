commented;modifiers;parameterAmount;loc;comment;code
false;private,static;2;19;;private static Set<ConsumeMediaTypeExpression> parseExpressions(String[] consumes, String[] headers) {     Set<ConsumeMediaTypeExpression> result = new LinkedHashSet<>().     if (headers != null) {         for (String header : headers) {             HeadersRequestCondition.HeaderExpression expr = new HeadersRequestCondition.HeaderExpression(header).             if ("Content-Type".equalsIgnoreCase(expr.name)) {                 for (MediaType mediaType : MediaType.parseMediaTypes(expr.value)) {                     result.add(new ConsumeMediaTypeExpression(mediaType, expr.isNegated)).                 }             }         }     }     if (consumes != null) {         for (String consume : consumes) {             result.add(new ConsumeMediaTypeExpression(consume)).         }     }     return result. }
true;public;0;3;/**  * Return the contained MediaType expressions.  */ ;/**  * Return the contained MediaType expressions.  */ public Set<MediaTypeExpression> getExpressions() {     return new LinkedHashSet<>(this.expressions). }
true;public;0;9;/**  * Returns the media types for this condition excluding negated expressions.  */ ;/**  * Returns the media types for this condition excluding negated expressions.  */ public Set<MediaType> getConsumableMediaTypes() {     Set<MediaType> result = new LinkedHashSet<>().     for (ConsumeMediaTypeExpression expression : this.expressions) {         if (!expression.isNegated()) {             result.add(expression.getMediaType()).         }     }     return result. }
true;public;0;3;/**  * Whether the condition has any media type expressions.  */ ;/**  * Whether the condition has any media type expressions.  */ public boolean isEmpty() {     return this.expressions.isEmpty(). }
false;protected;0;4;;@Override protected Collection<ConsumeMediaTypeExpression> getContent() {     return this.expressions. }
false;protected;0;4;;@Override protected String getToStringInfix() {     return " || ". }
true;public;1;4;/**  * Returns the "other" instance if it has any expressions. returns "this"  * instance otherwise. Practically that means a method-level "consumes"  * overrides a type-level "consumes" condition.  */ ;/**  * Returns the "other" instance if it has any expressions. returns "this"  * instance otherwise. Practically that means a method-level "consumes"  * overrides a type-level "consumes" condition.  */ @Override public ConsumesRequestCondition combine(ConsumesRequestCondition other) {     return (!other.expressions.isEmpty() ? other : this). }
true;public;1;12;/**  * Checks if any of the contained media type expressions match the given  * request 'Content-Type' header and returns an instance that is guaranteed  * to contain matching expressions only. The match is performed via  * {@link MediaType#includes(MediaType)}.  * @param exchange the current exchange  * @return the same instance if the condition contains no expressions.  * or a new condition with matching expressions only.  * or {@code null} if no expressions match.  */ ;/**  * Checks if any of the contained media type expressions match the given  * request 'Content-Type' header and returns an instance that is guaranteed  * to contain matching expressions only. The match is performed via  * {@link MediaType#includes(MediaType)}.  * @param exchange the current exchange  * @return the same instance if the condition contains no expressions.  * or a new condition with matching expressions only.  * or {@code null} if no expressions match.  */ @Override public ConsumesRequestCondition getMatchingCondition(ServerWebExchange exchange) {     if (CorsUtils.isPreFlightRequest(exchange.getRequest())) {         return PRE_FLIGHT_MATCH.     }     if (isEmpty()) {         return this.     }     Set<ConsumeMediaTypeExpression> result = new LinkedHashSet<>(this.expressions).     result.removeIf(expression -> !expression.match(exchange)).     return (!result.isEmpty() ? new ConsumesRequestCondition(result) : null). }
true;public;2;15;/**  * Returns:  * <ul>  * <li>0 if the two conditions have the same number of expressions  * <li>Less than 0 if "this" has more or more specific media type expressions  * <li>Greater than 0 if "other" has more or more specific media type expressions  * </ul>  * <p>It is assumed that both instances have been obtained via  * {@link #getMatchingCondition(ServerWebExchange)} and each instance contains  * the matching consumable media type expression only or is otherwise empty.  */ ;/**  * Returns:  * <ul>  * <li>0 if the two conditions have the same number of expressions  * <li>Less than 0 if "this" has more or more specific media type expressions  * <li>Greater than 0 if "other" has more or more specific media type expressions  * </ul>  * <p>It is assumed that both instances have been obtained via  * {@link #getMatchingCondition(ServerWebExchange)} and each instance contains  * the matching consumable media type expression only or is otherwise empty.  */ @Override public int compareTo(ConsumesRequestCondition other, ServerWebExchange exchange) {     if (this.expressions.isEmpty() && other.expressions.isEmpty()) {         return 0.     } else if (this.expressions.isEmpty()) {         return 1.     } else if (other.expressions.isEmpty()) {         return -1.     } else {         return this.expressions.get(0).compareTo(other.expressions.get(0)).     } }
false;protected;1;13;;@Override protected boolean matchMediaType(ServerWebExchange exchange) throws UnsupportedMediaTypeStatusException {     try {         MediaType contentType = exchange.getRequest().getHeaders().getContentType().         contentType = (contentType != null ? contentType : MediaType.APPLICATION_OCTET_STREAM).         return getMediaType().includes(contentType).     } catch (InvalidMediaTypeException ex) {         throw new UnsupportedMediaTypeStatusException("Can't parse Content-Type [" + exchange.getRequest().getHeaders().getFirst("Content-Type") + "]: " + ex.getMessage()).     } }
