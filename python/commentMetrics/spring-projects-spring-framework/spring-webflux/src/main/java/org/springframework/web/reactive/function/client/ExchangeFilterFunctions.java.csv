commented;modifiers;parameterAmount;loc;comment;code
true;public,static;1;8;/**  * Consume up to the specified number of bytes from the response body and  * cancel if any more data arrives.  * <p>Internally delegates to {@link DataBufferUtils#takeUntilByteCount}.  * @param maxByteCount the limit as number of bytes  * @return the filter to limit the response size with  * @since 5.1  */ ;/**  * Consume up to the specified number of bytes from the response body and  * cancel if any more data arrives.  * <p>Internally delegates to {@link DataBufferUtils#takeUntilByteCount}.  * @param maxByteCount the limit as number of bytes  * @return the filter to limit the response size with  * @since 5.1  */ public static ExchangeFilterFunction limitResponseSize(long maxByteCount) {     return (request, next) -> next.exchange(request).map(response -> {         Flux<DataBuffer> body = response.body(BodyExtractors.toDataBuffers()).         body = DataBufferUtils.takeUntilByteCount(body, maxByteCount).         return ClientResponse.from(response).body(body).build().     }). }
true;public,static;2;10;/**  * Return a filter that generates an error signal when the given  * {@link HttpStatus} predicate matches.  * @param statusPredicate the predicate to check the HTTP status with  * @param exceptionFunction the function that to create the exception  * @return the filter to generate an error signal  */ ;/**  * Return a filter that generates an error signal when the given  * {@link HttpStatus} predicate matches.  * @param statusPredicate the predicate to check the HTTP status with  * @param exceptionFunction the function that to create the exception  * @return the filter to generate an error signal  */ public static ExchangeFilterFunction statusError(Predicate<HttpStatus> statusPredicate, Function<ClientResponse, ? extends Throwable> exceptionFunction) {     Assert.notNull(statusPredicate, "Predicate must not be null").     Assert.notNull(exceptionFunction, "Function must not be null").     return ExchangeFilterFunction.ofResponseProcessor(response -> (statusPredicate.test(response.statusCode()) ? Mono.error(exceptionFunction.apply(response)) : Mono.just(response))). }
true;public,static;2;6;/**  * Return a filter that applies HTTP Basic Authentication to the request  * headers via {@link HttpHeaders#setBasicAuth(String, String)}.  * @param user the user  * @param password the password  * @return the filter to add authentication headers with  * @see HttpHeaders#setBasicAuth(String, String)  * @see HttpHeaders#setBasicAuth(String, String, Charset)  */ ;/**  * Return a filter that applies HTTP Basic Authentication to the request  * headers via {@link HttpHeaders#setBasicAuth(String, String)}.  * @param user the user  * @param password the password  * @return the filter to add authentication headers with  * @see HttpHeaders#setBasicAuth(String, String)  * @see HttpHeaders#setBasicAuth(String, String, Charset)  */ public static ExchangeFilterFunction basicAuthentication(String user, String password) {     return (request, next) -> next.exchange(ClientRequest.from(request).headers(headers -> headers.setBasicAuth(user, password)).build()). }
true;public,static;0;15;/**  * Variant of {@link #basicAuthentication(String, String)} that looks up  * the {@link Credentials Credentials} in a  * {@link #BASIC_AUTHENTICATION_CREDENTIALS_ATTRIBUTE request attribute}.  * @return the filter to use  * @see Credentials  * @deprecated as of Spring 5.1 in favor of using  * {@link HttpHeaders#setBasicAuth(String, String)} while building the request.  */ ;/**  * Variant of {@link #basicAuthentication(String, String)} that looks up  * the {@link Credentials Credentials} in a  * {@link #BASIC_AUTHENTICATION_CREDENTIALS_ATTRIBUTE request attribute}.  * @return the filter to use  * @see Credentials  * @deprecated as of Spring 5.1 in favor of using  * {@link HttpHeaders#setBasicAuth(String, String)} while building the request.  */ @Deprecated public static ExchangeFilterFunction basicAuthentication() {     return (request, next) -> {         Object attr = request.attributes().get(BASIC_AUTHENTICATION_CREDENTIALS_ATTRIBUTE).         if (attr instanceof Credentials) {             Credentials cred = (Credentials) attr.             return next.exchange(ClientRequest.from(request).headers(headers -> headers.setBasicAuth(cred.username, cred.password)).build()).         } else {             return next.exchange(request).         }     }. }
true;public,static;2;4;/**  * Return a {@literal Consumer} that stores the given user and password  * as a request attribute of type {@code Credentials} that is in turn  * used by {@link ExchangeFilterFunctions#basicAuthentication()}.  * @param user the user  * @param password the password  * @return a consumer that can be passed into  * {@linkplain ClientRequest.Builder#attributes(java.util.function.Consumer)}  * @see ClientRequest.Builder#attributes(java.util.function.Consumer)  * @see #BASIC_AUTHENTICATION_CREDENTIALS_ATTRIBUTE  */ ;/**  * Return a {@literal Consumer} that stores the given user and password  * as a request attribute of type {@code Credentials} that is in turn  * used by {@link ExchangeFilterFunctions#basicAuthentication()}.  * @param user the user  * @param password the password  * @return a consumer that can be passed into  * {@linkplain ClientRequest.Builder#attributes(java.util.function.Consumer)}  * @see ClientRequest.Builder#attributes(java.util.function.Consumer)  * @see #BASIC_AUTHENTICATION_CREDENTIALS_ATTRIBUTE  */ public static Consumer<Map<String, Object>> basicAuthenticationCredentials(String user, String password) {     Credentials credentials = new Credentials(user, password).     return (map -> map.put(BASIC_AUTHENTICATION_CREDENTIALS_ATTRIBUTE, credentials)). }
false;public;1;11;;@Override public boolean equals(Object other) {     if (this == other) {         return true.     }     if (!(other instanceof Credentials)) {         return false.     }     Credentials otherCred = (Credentials) other.     return (this.username.equals(otherCred.username) && this.password.equals(otherCred.password)). }
false;public;0;4;;@Override public int hashCode() {     return 31 * this.username.hashCode() + this.password.hashCode(). }
