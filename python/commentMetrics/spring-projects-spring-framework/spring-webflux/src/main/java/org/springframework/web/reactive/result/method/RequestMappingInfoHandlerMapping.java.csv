commented;modifiers;parameterAmount;loc;comment;code
true;protected;2;4;/**  * Check if the given RequestMappingInfo matches the current request and  * return a (potentially new) instance with conditions that match the  * current request -- for example with a subset of URL patterns.  * @return an info in case of a match. or {@code null} otherwise.  */ ;/**  * Check if the given RequestMappingInfo matches the current request and  * return a (potentially new) instance with conditions that match the  * current request -- for example with a subset of URL patterns.  * @return an info in case of a match. or {@code null} otherwise.  */ @Override protected RequestMappingInfo getMatchingMapping(RequestMappingInfo info, ServerWebExchange exchange) {     return info.getMatchingCondition(exchange). }
true;protected;1;4;/**  * Provide a Comparator to sort RequestMappingInfos matched to a request.  */ ;/**  * Provide a Comparator to sort RequestMappingInfos matched to a request.  */ @Override protected Comparator<RequestMappingInfo> getMappingComparator(final ServerWebExchange exchange) {     return (info1, info2) -> info1.compareTo(info2, exchange). }
true;protected;3;37;/**  * Expose URI template variables, matrix variables, and producible media types in the request.  * @see HandlerMapping#URI_TEMPLATE_VARIABLES_ATTRIBUTE  * @see HandlerMapping#MATRIX_VARIABLES_ATTRIBUTE  * @see HandlerMapping#PRODUCIBLE_MEDIA_TYPES_ATTRIBUTE  */ ;/**  * Expose URI template variables, matrix variables, and producible media types in the request.  * @see HandlerMapping#URI_TEMPLATE_VARIABLES_ATTRIBUTE  * @see HandlerMapping#MATRIX_VARIABLES_ATTRIBUTE  * @see HandlerMapping#PRODUCIBLE_MEDIA_TYPES_ATTRIBUTE  */ @Override protected void handleMatch(RequestMappingInfo info, HandlerMethod handlerMethod, ServerWebExchange exchange) {     super.handleMatch(info, handlerMethod, exchange).     PathContainer lookupPath = exchange.getRequest().getPath().pathWithinApplication().     PathPattern bestPattern.     Map<String, String> uriVariables.     Map<String, MultiValueMap<String, String>> matrixVariables.     Set<PathPattern> patterns = info.getPatternsCondition().getPatterns().     if (patterns.isEmpty()) {         bestPattern = getPathPatternParser().parse(lookupPath.value()).         uriVariables = Collections.emptyMap().         matrixVariables = Collections.emptyMap().     } else {         bestPattern = patterns.iterator().next().         PathPattern.PathMatchInfo result = bestPattern.matchAndExtract(lookupPath).         Assert.notNull(result, () -> "Expected bestPattern: " + bestPattern + " to match lookupPath " + lookupPath).         uriVariables = result.getUriVariables().         matrixVariables = result.getMatrixVariables().     }     exchange.getAttributes().put(BEST_MATCHING_HANDLER_ATTRIBUTE, handlerMethod).     exchange.getAttributes().put(BEST_MATCHING_PATTERN_ATTRIBUTE, bestPattern).     exchange.getAttributes().put(URI_TEMPLATE_VARIABLES_ATTRIBUTE, uriVariables).     exchange.getAttributes().put(MATRIX_VARIABLES_ATTRIBUTE, matrixVariables).     if (!info.getProducesCondition().getProducibleMediaTypes().isEmpty()) {         Set<MediaType> mediaTypes = info.getProducesCondition().getProducibleMediaTypes().         exchange.getAttributes().put(PRODUCIBLE_MEDIA_TYPES_ATTRIBUTE, mediaTypes).     } }
true;protected;2;47;/**  * Iterate all RequestMappingInfos once again, look if any match by URL at  * least and raise exceptions accordingly.  * @throws MethodNotAllowedException for matches by URL but not by HTTP method  * @throws UnsupportedMediaTypeStatusException if there are matches by URL  * and HTTP method but not by consumable media types  * @throws NotAcceptableStatusException if there are matches by URL and HTTP  * method but not by producible media types  * @throws ServerWebInputException if there are matches by URL and HTTP  * method but not by query parameter conditions  */ ;/**  * Iterate all RequestMappingInfos once again, look if any match by URL at  * least and raise exceptions accordingly.  * @throws MethodNotAllowedException for matches by URL but not by HTTP method  * @throws UnsupportedMediaTypeStatusException if there are matches by URL  * and HTTP method but not by consumable media types  * @throws NotAcceptableStatusException if there are matches by URL and HTTP  * method but not by producible media types  * @throws ServerWebInputException if there are matches by URL and HTTP  * method but not by query parameter conditions  */ @Override protected HandlerMethod handleNoMatch(Set<RequestMappingInfo> infos, ServerWebExchange exchange) throws Exception {     PartialMatchHelper helper = new PartialMatchHelper(infos, exchange).     if (helper.isEmpty()) {         return null.     }     ServerHttpRequest request = exchange.getRequest().     if (helper.hasMethodsMismatch()) {         String httpMethod = request.getMethodValue().         Set<HttpMethod> methods = helper.getAllowedMethods().         if (HttpMethod.OPTIONS.matches(httpMethod)) {             HttpOptionsHandler handler = new HttpOptionsHandler(methods).             return new HandlerMethod(handler, HTTP_OPTIONS_HANDLE_METHOD).         }         throw new MethodNotAllowedException(httpMethod, methods).     }     if (helper.hasConsumesMismatch()) {         Set<MediaType> mediaTypes = helper.getConsumableMediaTypes().         MediaType contentType.         try {             contentType = request.getHeaders().getContentType().         } catch (InvalidMediaTypeException ex) {             throw new UnsupportedMediaTypeStatusException(ex.getMessage()).         }         throw new UnsupportedMediaTypeStatusException(contentType, new ArrayList<>(mediaTypes)).     }     if (helper.hasProducesMismatch()) {         Set<MediaType> mediaTypes = helper.getProducibleMediaTypes().         throw new NotAcceptableStatusException(new ArrayList<>(mediaTypes)).     }     if (helper.hasParamsMismatch()) {         throw new ServerWebInputException("Unsatisfied query parameter conditions: " + helper.getParamConditions() + ", actual parameters: " + request.getQueryParams()).     }     return null. }
true;public;0;3;/**  * Whether there any partial matches.  */ ;/**  * Whether there any partial matches.  */ public boolean isEmpty() {     return this.partialMatches.isEmpty(). }
true;public;0;4;/**  * Any partial matches for "methods"?  */ ;/**  * Any partial matches for "methods"?  */ public boolean hasMethodsMismatch() {     return this.partialMatches.stream().noneMatch(PartialMatch::hasMethodsMatch). }
true;public;0;4;/**  * Any partial matches for "methods" and "consumes"?  */ ;/**  * Any partial matches for "methods" and "consumes"?  */ public boolean hasConsumesMismatch() {     return this.partialMatches.stream().noneMatch(PartialMatch::hasConsumesMatch). }
true;public;0;4;/**  * Any partial matches for "methods", "consumes", and "produces"?  */ ;/**  * Any partial matches for "methods", "consumes", and "produces"?  */ public boolean hasProducesMismatch() {     return this.partialMatches.stream().noneMatch(PartialMatch::hasProducesMatch). }
true;public;0;4;/**  * Any partial matches for "methods", "consumes", "produces", and "params"?  */ ;/**  * Any partial matches for "methods", "consumes", "produces", and "params"?  */ public boolean hasParamsMismatch() {     return this.partialMatches.stream().noneMatch(PartialMatch::hasParamsMatch). }
true;public;0;6;/**  * Return declared HTTP methods.  */ ;/**  * Return declared HTTP methods.  */ public Set<HttpMethod> getAllowedMethods() {     return this.partialMatches.stream().flatMap(m -> m.getInfo().getMethodsCondition().getMethods().stream()).map(requestMethod -> HttpMethod.resolve(requestMethod.name())).collect(Collectors.toSet()). }
true;public;0;5;/**  * Return declared "consumable" types but only among those that also  * match the "methods" condition.  */ ;/**  * Return declared "consumable" types but only among those that also  * match the "methods" condition.  */ public Set<MediaType> getConsumableMediaTypes() {     return this.partialMatches.stream().filter(PartialMatch::hasMethodsMatch).flatMap(m -> m.getInfo().getConsumesCondition().getConsumableMediaTypes().stream()).collect(Collectors.toCollection(LinkedHashSet::new)). }
true;public;0;5;/**  * Return declared "producible" types but only among those that also  * match the "methods" and "consumes" conditions.  */ ;/**  * Return declared "producible" types but only among those that also  * match the "methods" and "consumes" conditions.  */ public Set<MediaType> getProducibleMediaTypes() {     return this.partialMatches.stream().filter(PartialMatch::hasConsumesMatch).flatMap(m -> m.getInfo().getProducesCondition().getProducibleMediaTypes().stream()).collect(Collectors.toCollection(LinkedHashSet::new)). }
true;public;0;5;/**  * Return declared "params" conditions but only among those that also  * match the "methods", "consumes", and "params" conditions.  */ ;/**  * Return declared "params" conditions but only among those that also  * match the "methods", "consumes", and "params" conditions.  */ public List<Set<NameValueExpression<String>>> getParamConditions() {     return this.partialMatches.stream().filter(PartialMatch::hasProducesMatch).map(match -> match.getInfo().getParamsCondition().getExpressions()).collect(Collectors.toList()). }
false;public;0;3;;public RequestMappingInfo getInfo() {     return this.info. }
false;public;0;3;;public boolean hasMethodsMatch() {     return this.methodsMatch. }
false;public;0;3;;public boolean hasConsumesMatch() {     return hasMethodsMatch() && this.consumesMatch. }
false;public;0;3;;public boolean hasProducesMatch() {     return hasConsumesMatch() && this.producesMatch. }
false;public;0;3;;public boolean hasParamsMatch() {     return hasProducesMatch() && this.paramsMatch. }
false;public;0;4;;@Override public String toString() {     return this.info.toString(). }
false;private,static;1;15;;private static Set<HttpMethod> initAllowedHttpMethods(Set<HttpMethod> declaredMethods) {     if (declaredMethods.isEmpty()) {         return EnumSet.allOf(HttpMethod.class).stream().filter(method -> method != HttpMethod.TRACE).collect(Collectors.toSet()).     } else {         Set<HttpMethod> result = new LinkedHashSet<>(declaredMethods).         if (result.contains(HttpMethod.GET)) {             result.add(HttpMethod.HEAD).         }         result.add(HttpMethod.OPTIONS).         return result.     } }
false;public;0;4;;@SuppressWarnings("unused") public HttpHeaders handle() {     return this.headers. }
