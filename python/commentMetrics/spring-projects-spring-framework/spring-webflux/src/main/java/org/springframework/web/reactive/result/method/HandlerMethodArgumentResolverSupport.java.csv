commented;modifiers;parameterAmount;loc;comment;code
true;public;0;3;/**  * Return the configured {@link ReactiveAdapterRegistry}.  */ ;/**  * Return the configured {@link ReactiveAdapterRegistry}.  */ public ReactiveAdapterRegistry getAdapterRegistry() {     return this.adapterRegistry. }
true;protected;2;9;/**  * Evaluate the {@code Predicate} on the method parameter type or on  * the generic type within a reactive type wrapper.  */ ;/**  * Evaluate the {@code Predicate} on the method parameter type or on  * the generic type within a reactive type wrapper.  */ protected boolean checkParameterType(MethodParameter parameter, Predicate<Class<?>> predicate) {     Class<?> type = parameter.getParameterType().     ReactiveAdapter adapter = getAdapterRegistry().getAdapter(type).     if (adapter != null) {         assertHasValues(adapter, parameter).         type = parameter.nested().getNestedParameterType().     }     return predicate.test(type). }
false;private;2;6;;private void assertHasValues(ReactiveAdapter adapter, MethodParameter param) {     if (adapter.isNoValue()) {         throw new IllegalArgumentException("No value reactive types not supported: " + param.getGenericParameterType()).     } }
true;protected;2;15;/**  * Evaluate the {@code Predicate} on the method parameter type but raise an  * {@code IllegalStateException} if the same matches the generic type  * within a reactive type wrapper.  */ ;/**  * Evaluate the {@code Predicate} on the method parameter type but raise an  * {@code IllegalStateException} if the same matches the generic type  * within a reactive type wrapper.  */ protected boolean checkParameterTypeNoReactiveWrapper(MethodParameter parameter, Predicate<Class<?>> predicate) {     Class<?> type = parameter.getParameterType().     ReactiveAdapter adapter = getAdapterRegistry().getAdapter(type).     if (adapter != null) {         assertHasValues(adapter, parameter).         type = parameter.nested().getNestedParameterType().     }     if (predicate.test(type)) {         if (adapter == null) {             return true.         }         throw buildReactiveWrapperException(parameter).     }     return false. }
false;private;1;4;;private IllegalStateException buildReactiveWrapperException(MethodParameter parameter) {     return new IllegalStateException(getClass().getSimpleName() + " doesn't support reactive type wrapper: " + parameter.getGenericParameterType()). }
true;protected;3;27;/**  * Evaluate the {@code Predicate} on the method parameter type if it has the  * given annotation, nesting within {@link java.util.Optional} if necessary,  * but raise an {@code IllegalStateException} if the same matches the generic  * type within a reactive type wrapper.  */ ;/**  * Evaluate the {@code Predicate} on the method parameter type if it has the  * given annotation, nesting within {@link java.util.Optional} if necessary,  * but raise an {@code IllegalStateException} if the same matches the generic  * type within a reactive type wrapper.  */ protected <A extends Annotation> boolean checkAnnotatedParamNoReactiveWrapper(MethodParameter parameter, Class<A> annotationType, BiPredicate<A, Class<?>> typePredicate) {     A annotation = parameter.getParameterAnnotation(annotationType).     if (annotation == null) {         return false.     }     parameter = parameter.nestedIfOptional().     Class<?> type = parameter.getNestedParameterType().     ReactiveAdapter adapter = getAdapterRegistry().getAdapter(type).     if (adapter != null) {         assertHasValues(adapter, parameter).         parameter = parameter.nested().         type = parameter.getNestedParameterType().     }     if (typePredicate.test(annotation, type)) {         if (adapter == null) {             return true.         }         throw buildReactiveWrapperException(parameter).     }     return false. }
