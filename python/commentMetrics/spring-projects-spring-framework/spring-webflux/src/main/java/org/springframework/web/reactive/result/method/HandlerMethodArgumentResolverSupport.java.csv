# id;timestamp;commentText;codeText;commentWords;codeWords
HandlerMethodArgumentResolverSupport -> protected <A extends Annotation> boolean checkAnnotatedParamNoReactiveWrapper( 			MethodParameter parameter, Class<A> annotationType, BiPredicate<A, Class<?>> typePredicate);1490354145;Evaluate the {@code Predicate} on the method parameter type if it has the_given annotation, nesting within {@link java.util.Optional} if necessary,_but raise an {@code IllegalStateException} if the same matches the generic_type within a reactive type wrapper.;protected <A extends Annotation> boolean checkAnnotatedParamNoReactiveWrapper(_			MethodParameter parameter, Class<A> annotationType, BiPredicate<A, Class<?>> typePredicate) {__		A annotation = parameter.getParameterAnnotation(annotationType)__		if (annotation == null) {_			return false__		}__		parameter = parameter.nestedIfOptional()__		Class<?> type = parameter.getNestedParameterType()___		ReactiveAdapter adapter = getAdapterRegistry().getAdapter(type)__		if (adapter != null) {_			assertHasValues(adapter, parameter)__			parameter = parameter.nested()__			type = parameter.getNestedParameterType()__		}__		if (typePredicate.test(annotation, type)) {_			if (adapter == null) {_				return true__			}_			throw buildReactiveWrapperException(parameter)__		}__		return false__	};evaluate,the,code,predicate,on,the,method,parameter,type,if,it,has,the,given,annotation,nesting,within,link,java,util,optional,if,necessary,but,raise,an,code,illegal,state,exception,if,the,same,matches,the,generic,type,within,a,reactive,type,wrapper;protected,a,extends,annotation,boolean,check,annotated,param,no,reactive,wrapper,method,parameter,parameter,class,a,annotation,type,bi,predicate,a,class,type,predicate,a,annotation,parameter,get,parameter,annotation,annotation,type,if,annotation,null,return,false,parameter,parameter,nested,if,optional,class,type,parameter,get,nested,parameter,type,reactive,adapter,adapter,get,adapter,registry,get,adapter,type,if,adapter,null,assert,has,values,adapter,parameter,parameter,parameter,nested,type,parameter,get,nested,parameter,type,if,type,predicate,test,annotation,type,if,adapter,null,return,true,throw,build,reactive,wrapper,exception,parameter,return,false
HandlerMethodArgumentResolverSupport -> protected <A extends Annotation> boolean checkAnnotatedParamNoReactiveWrapper( 			MethodParameter parameter, Class<A> annotationType, BiPredicate<A, Class<?>> typePredicate);1491113276;Evaluate the {@code Predicate} on the method parameter type if it has the_given annotation, nesting within {@link java.util.Optional} if necessary,_but raise an {@code IllegalStateException} if the same matches the generic_type within a reactive type wrapper.;protected <A extends Annotation> boolean checkAnnotatedParamNoReactiveWrapper(_			MethodParameter parameter, Class<A> annotationType, BiPredicate<A, Class<?>> typePredicate) {__		A annotation = parameter.getParameterAnnotation(annotationType)__		if (annotation == null) {_			return false__		}__		parameter = parameter.nestedIfOptional()__		Class<?> type = parameter.getNestedParameterType()___		ReactiveAdapter adapter = getAdapterRegistry().getAdapter(type)__		if (adapter != null) {_			assertHasValues(adapter, parameter)__			parameter = parameter.nested()__			type = parameter.getNestedParameterType()__		}__		if (typePredicate.test(annotation, type)) {_			if (adapter == null) {_				return true__			}_			throw buildReactiveWrapperException(parameter)__		}__		return false__	};evaluate,the,code,predicate,on,the,method,parameter,type,if,it,has,the,given,annotation,nesting,within,link,java,util,optional,if,necessary,but,raise,an,code,illegal,state,exception,if,the,same,matches,the,generic,type,within,a,reactive,type,wrapper;protected,a,extends,annotation,boolean,check,annotated,param,no,reactive,wrapper,method,parameter,parameter,class,a,annotation,type,bi,predicate,a,class,type,predicate,a,annotation,parameter,get,parameter,annotation,annotation,type,if,annotation,null,return,false,parameter,parameter,nested,if,optional,class,type,parameter,get,nested,parameter,type,reactive,adapter,adapter,get,adapter,registry,get,adapter,type,if,adapter,null,assert,has,values,adapter,parameter,parameter,parameter,nested,type,parameter,get,nested,parameter,type,if,type,predicate,test,annotation,type,if,adapter,null,return,true,throw,build,reactive,wrapper,exception,parameter,return,false
HandlerMethodArgumentResolverSupport -> protected <A extends Annotation> boolean checkAnnotatedParamNoReactiveWrapper( 			MethodParameter parameter, Class<A> annotationType, BiPredicate<A, Class<?>> typePredicate);1529721864;Evaluate the {@code Predicate} on the method parameter type if it has the_given annotation, nesting within {@link java.util.Optional} if necessary,_but raise an {@code IllegalStateException} if the same matches the generic_type within a reactive type wrapper.;protected <A extends Annotation> boolean checkAnnotatedParamNoReactiveWrapper(_			MethodParameter parameter, Class<A> annotationType, BiPredicate<A, Class<?>> typePredicate) {__		A annotation = parameter.getParameterAnnotation(annotationType)__		if (annotation == null) {_			return false__		}__		parameter = parameter.nestedIfOptional()__		Class<?> type = parameter.getNestedParameterType()___		ReactiveAdapter adapter = getAdapterRegistry().getAdapter(type)__		if (adapter != null) {_			assertHasValues(adapter, parameter)__			parameter = parameter.nested()__			type = parameter.getNestedParameterType()__		}__		if (typePredicate.test(annotation, type)) {_			if (adapter == null) {_				return true__			}_			throw buildReactiveWrapperException(parameter)__		}__		return false__	};evaluate,the,code,predicate,on,the,method,parameter,type,if,it,has,the,given,annotation,nesting,within,link,java,util,optional,if,necessary,but,raise,an,code,illegal,state,exception,if,the,same,matches,the,generic,type,within,a,reactive,type,wrapper;protected,a,extends,annotation,boolean,check,annotated,param,no,reactive,wrapper,method,parameter,parameter,class,a,annotation,type,bi,predicate,a,class,type,predicate,a,annotation,parameter,get,parameter,annotation,annotation,type,if,annotation,null,return,false,parameter,parameter,nested,if,optional,class,type,parameter,get,nested,parameter,type,reactive,adapter,adapter,get,adapter,registry,get,adapter,type,if,adapter,null,assert,has,values,adapter,parameter,parameter,parameter,nested,type,parameter,get,nested,parameter,type,if,type,predicate,test,annotation,type,if,adapter,null,return,true,throw,build,reactive,wrapper,exception,parameter,return,false
HandlerMethodArgumentResolverSupport -> public ReactiveAdapterRegistry getAdapterRegistry();1489535791;Return the configured {@link ReactiveAdapterRegistry}.;public ReactiveAdapterRegistry getAdapterRegistry() {_		return this.adapterRegistry__	};return,the,configured,link,reactive,adapter,registry;public,reactive,adapter,registry,get,adapter,registry,return,this,adapter,registry
HandlerMethodArgumentResolverSupport -> public ReactiveAdapterRegistry getAdapterRegistry();1490354145;Return the configured {@link ReactiveAdapterRegistry}.;public ReactiveAdapterRegistry getAdapterRegistry() {_		return this.adapterRegistry__	};return,the,configured,link,reactive,adapter,registry;public,reactive,adapter,registry,get,adapter,registry,return,this,adapter,registry
HandlerMethodArgumentResolverSupport -> public ReactiveAdapterRegistry getAdapterRegistry();1491113276;Return the configured {@link ReactiveAdapterRegistry}.;public ReactiveAdapterRegistry getAdapterRegistry() {_		return this.adapterRegistry__	};return,the,configured,link,reactive,adapter,registry;public,reactive,adapter,registry,get,adapter,registry,return,this,adapter,registry
HandlerMethodArgumentResolverSupport -> public ReactiveAdapterRegistry getAdapterRegistry();1529721864;Return the configured {@link ReactiveAdapterRegistry}.;public ReactiveAdapterRegistry getAdapterRegistry() {_		return this.adapterRegistry__	};return,the,configured,link,reactive,adapter,registry;public,reactive,adapter,registry,get,adapter,registry,return,this,adapter,registry
HandlerMethodArgumentResolverSupport -> protected boolean checkParameterType(MethodParameter parameter, Predicate<Class<?>> predicate);1490354145;Evaluate the {@code Predicate} on the the method parameter type or on_the generic type within a reactive type wrapper.;protected boolean checkParameterType(MethodParameter parameter, Predicate<Class<?>> predicate) {_		Class<?> type = parameter.getParameterType()__		ReactiveAdapter adapter = getAdapterRegistry().getAdapter(type)__		if (adapter != null) {_			assertHasValues(adapter, parameter)__			type = parameter.nested().getNestedParameterType()__		}_		return predicate.test(type)__	};evaluate,the,code,predicate,on,the,the,method,parameter,type,or,on,the,generic,type,within,a,reactive,type,wrapper;protected,boolean,check,parameter,type,method,parameter,parameter,predicate,class,predicate,class,type,parameter,get,parameter,type,reactive,adapter,adapter,get,adapter,registry,get,adapter,type,if,adapter,null,assert,has,values,adapter,parameter,type,parameter,nested,get,nested,parameter,type,return,predicate,test,type
HandlerMethodArgumentResolverSupport -> protected boolean checkParameterType(MethodParameter parameter, Predicate<Class<?>> predicate);1491113276;Evaluate the {@code Predicate} on the method parameter type or on_the generic type within a reactive type wrapper.;protected boolean checkParameterType(MethodParameter parameter, Predicate<Class<?>> predicate) {_		Class<?> type = parameter.getParameterType()__		ReactiveAdapter adapter = getAdapterRegistry().getAdapter(type)__		if (adapter != null) {_			assertHasValues(adapter, parameter)__			type = parameter.nested().getNestedParameterType()__		}_		return predicate.test(type)__	};evaluate,the,code,predicate,on,the,method,parameter,type,or,on,the,generic,type,within,a,reactive,type,wrapper;protected,boolean,check,parameter,type,method,parameter,parameter,predicate,class,predicate,class,type,parameter,get,parameter,type,reactive,adapter,adapter,get,adapter,registry,get,adapter,type,if,adapter,null,assert,has,values,adapter,parameter,type,parameter,nested,get,nested,parameter,type,return,predicate,test,type
HandlerMethodArgumentResolverSupport -> protected boolean checkParameterType(MethodParameter parameter, Predicate<Class<?>> predicate);1529721864;Evaluate the {@code Predicate} on the method parameter type or on_the generic type within a reactive type wrapper.;protected boolean checkParameterType(MethodParameter parameter, Predicate<Class<?>> predicate) {_		Class<?> type = parameter.getParameterType()__		ReactiveAdapter adapter = getAdapterRegistry().getAdapter(type)__		if (adapter != null) {_			assertHasValues(adapter, parameter)__			type = parameter.nested().getNestedParameterType()__		}_		return predicate.test(type)__	};evaluate,the,code,predicate,on,the,method,parameter,type,or,on,the,generic,type,within,a,reactive,type,wrapper;protected,boolean,check,parameter,type,method,parameter,parameter,predicate,class,predicate,class,type,parameter,get,parameter,type,reactive,adapter,adapter,get,adapter,registry,get,adapter,type,if,adapter,null,assert,has,values,adapter,parameter,type,parameter,nested,get,nested,parameter,type,return,predicate,test,type
HandlerMethodArgumentResolverSupport -> protected boolean checkParameterTypeNoReactiveWrapper(MethodParameter parameter, Predicate<Class<?>> predicate);1490354145;Evaluate the {@code Predicate} on the method parameter type but raise an_{@code IllegalStateException} if the same matches the generic type_within a reactive type wrapper.;protected boolean checkParameterTypeNoReactiveWrapper(MethodParameter parameter, Predicate<Class<?>> predicate) {_		Class<?> type = parameter.getParameterType()__		ReactiveAdapter adapter = getAdapterRegistry().getAdapter(type)__		if (adapter != null) {_			assertHasValues(adapter, parameter)__			type = parameter.nested().getNestedParameterType()__		}_		if (predicate.test(type)) {_			if (adapter == null) {_				return true__			}_			throw buildReactiveWrapperException(parameter)__		}_		return false__	};evaluate,the,code,predicate,on,the,method,parameter,type,but,raise,an,code,illegal,state,exception,if,the,same,matches,the,generic,type,within,a,reactive,type,wrapper;protected,boolean,check,parameter,type,no,reactive,wrapper,method,parameter,parameter,predicate,class,predicate,class,type,parameter,get,parameter,type,reactive,adapter,adapter,get,adapter,registry,get,adapter,type,if,adapter,null,assert,has,values,adapter,parameter,type,parameter,nested,get,nested,parameter,type,if,predicate,test,type,if,adapter,null,return,true,throw,build,reactive,wrapper,exception,parameter,return,false
HandlerMethodArgumentResolverSupport -> protected boolean checkParameterTypeNoReactiveWrapper(MethodParameter parameter, Predicate<Class<?>> predicate);1491113276;Evaluate the {@code Predicate} on the method parameter type but raise an_{@code IllegalStateException} if the same matches the generic type_within a reactive type wrapper.;protected boolean checkParameterTypeNoReactiveWrapper(MethodParameter parameter, Predicate<Class<?>> predicate) {_		Class<?> type = parameter.getParameterType()__		ReactiveAdapter adapter = getAdapterRegistry().getAdapter(type)__		if (adapter != null) {_			assertHasValues(adapter, parameter)__			type = parameter.nested().getNestedParameterType()__		}_		if (predicate.test(type)) {_			if (adapter == null) {_				return true__			}_			throw buildReactiveWrapperException(parameter)__		}_		return false__	};evaluate,the,code,predicate,on,the,method,parameter,type,but,raise,an,code,illegal,state,exception,if,the,same,matches,the,generic,type,within,a,reactive,type,wrapper;protected,boolean,check,parameter,type,no,reactive,wrapper,method,parameter,parameter,predicate,class,predicate,class,type,parameter,get,parameter,type,reactive,adapter,adapter,get,adapter,registry,get,adapter,type,if,adapter,null,assert,has,values,adapter,parameter,type,parameter,nested,get,nested,parameter,type,if,predicate,test,type,if,adapter,null,return,true,throw,build,reactive,wrapper,exception,parameter,return,false
HandlerMethodArgumentResolverSupport -> protected boolean checkParameterTypeNoReactiveWrapper(MethodParameter parameter, Predicate<Class<?>> predicate);1529721864;Evaluate the {@code Predicate} on the method parameter type but raise an_{@code IllegalStateException} if the same matches the generic type_within a reactive type wrapper.;protected boolean checkParameterTypeNoReactiveWrapper(MethodParameter parameter, Predicate<Class<?>> predicate) {_		Class<?> type = parameter.getParameterType()__		ReactiveAdapter adapter = getAdapterRegistry().getAdapter(type)__		if (adapter != null) {_			assertHasValues(adapter, parameter)__			type = parameter.nested().getNestedParameterType()__		}_		if (predicate.test(type)) {_			if (adapter == null) {_				return true__			}_			throw buildReactiveWrapperException(parameter)__		}_		return false__	};evaluate,the,code,predicate,on,the,method,parameter,type,but,raise,an,code,illegal,state,exception,if,the,same,matches,the,generic,type,within,a,reactive,type,wrapper;protected,boolean,check,parameter,type,no,reactive,wrapper,method,parameter,parameter,predicate,class,predicate,class,type,parameter,get,parameter,type,reactive,adapter,adapter,get,adapter,registry,get,adapter,type,if,adapter,null,assert,has,values,adapter,parameter,type,parameter,nested,get,nested,parameter,type,if,predicate,test,type,if,adapter,null,return,true,throw,build,reactive,wrapper,exception,parameter,return,false
