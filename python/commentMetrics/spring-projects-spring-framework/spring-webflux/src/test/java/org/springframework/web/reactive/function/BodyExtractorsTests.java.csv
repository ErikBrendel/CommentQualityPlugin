commented;modifiers;parameterAmount;loc;comment;code
false;public;0;4;;@Override public List<HttpMessageReader<?>> messageReaders() {     return messageReaders. }
false;public;0;4;;@Override public Optional<ServerHttpResponse> serverResponse() {     return serverResponse. }
false;public;0;4;;@Override public Map<String, Object> hints() {     return hints. }
false;public;0;32;;@Before public void createContext() {     final List<HttpMessageReader<?>> messageReaders = new ArrayList<>().     messageReaders.add(new DecoderHttpMessageReader<>(new ByteBufferDecoder())).     messageReaders.add(new DecoderHttpMessageReader<>(StringDecoder.allMimeTypes())).     messageReaders.add(new DecoderHttpMessageReader<>(new Jaxb2XmlDecoder())).     messageReaders.add(new DecoderHttpMessageReader<>(new Jackson2JsonDecoder())).     messageReaders.add(new FormHttpMessageReader()).     SynchronossPartHttpMessageReader partReader = new SynchronossPartHttpMessageReader().     messageReaders.add(partReader).     messageReaders.add(new MultipartHttpMessageReader(partReader)).     messageReaders.add(new FormHttpMessageReader()).     this.context = new BodyExtractor.Context() {          @Override         public List<HttpMessageReader<?>> messageReaders() {             return messageReaders.         }          @Override         public Optional<ServerHttpResponse> serverResponse() {             return serverResponse.         }          @Override         public Map<String, Object> hints() {             return hints.         }     }.     this.hints = new HashMap<String, Object>(). }
false;public;0;17;;@Test public void toMono() {     BodyExtractor<Mono<String>, ReactiveHttpInputMessage> extractor = BodyExtractors.toMono(String.class).     DefaultDataBufferFactory factory = new DefaultDataBufferFactory().     DefaultDataBuffer dataBuffer = factory.wrap(ByteBuffer.wrap("foo".getBytes(StandardCharsets.UTF_8))).     Flux<DataBuffer> body = Flux.just(dataBuffer).     MockServerHttpRequest request = MockServerHttpRequest.post("/").body(body).     Mono<String> result = extractor.extract(request, this.context).     StepVerifier.create(result).expectNext("foo").expectComplete().verify(). }
false;public;0;21;;@Test public void toMonoParameterizedTypeReference() {     BodyExtractor<Mono<Map<String, String>>, ReactiveHttpInputMessage> extractor = BodyExtractors.toMono(new ParameterizedTypeReference<Map<String, String>>() {     }).     DefaultDataBufferFactory factory = new DefaultDataBufferFactory().     DefaultDataBuffer dataBuffer = factory.wrap(ByteBuffer.wrap("{\"username\":\"foo\",\"password\":\"bar\"}".getBytes(StandardCharsets.UTF_8))).     Flux<DataBuffer> body = Flux.just(dataBuffer).     MockServerHttpRequest request = MockServerHttpRequest.post("/").contentType(MediaType.APPLICATION_JSON).body(body).     Mono<Map<String, String>> result = extractor.extract(request, this.context).     Map<String, String> expected = new LinkedHashMap<>().     expected.put("username", "foo").     expected.put("password", "bar").     StepVerifier.create(result).expectNext(expected).expectComplete().verify(). }
false;public;0;24;;@Test public void toMonoWithHints() {     BodyExtractor<Mono<User>, ReactiveHttpInputMessage> extractor = BodyExtractors.toMono(User.class).     this.hints.put(JSON_VIEW_HINT, SafeToDeserialize.class).     DefaultDataBufferFactory factory = new DefaultDataBufferFactory().     DefaultDataBuffer dataBuffer = factory.wrap(ByteBuffer.wrap("{\"username\":\"foo\",\"password\":\"bar\"}".getBytes(StandardCharsets.UTF_8))).     Flux<DataBuffer> body = Flux.just(dataBuffer).     MockServerHttpRequest request = MockServerHttpRequest.post("/").contentType(MediaType.APPLICATION_JSON).body(body).     Mono<User> result = extractor.extract(request, this.context).     StepVerifier.create(result).consumeNextWith(user -> {         assertEquals("foo", user.getUsername()).         assertNull(user.getPassword()).     }).expectComplete().verify(). }
false;public;0;10;;// SPR-15758 @Test public void toMonoWithEmptyBodyAndNoContentType() {     BodyExtractor<Mono<Map<String, String>>, ReactiveHttpInputMessage> extractor = BodyExtractors.toMono(new ParameterizedTypeReference<Map<String, String>>() {     }).     MockServerHttpRequest request = MockServerHttpRequest.post("/").body(Flux.empty()).     Mono<Map<String, String>> result = extractor.extract(request, this.context).     StepVerifier.create(result).expectComplete().verify(). }
false;public;0;20;;@Test public void toMonoVoidAsClientShouldConsumeAndCancel() {     DefaultDataBufferFactory factory = new DefaultDataBufferFactory().     DefaultDataBuffer dataBuffer = factory.wrap(ByteBuffer.wrap("foo".getBytes(StandardCharsets.UTF_8))).     TestPublisher<DataBuffer> body = TestPublisher.create().     BodyExtractor<Mono<Void>, ReactiveHttpInputMessage> extractor = BodyExtractors.toMono(Void.class).     MockClientHttpResponse response = new MockClientHttpResponse(HttpStatus.OK).     response.setBody(body.flux()).     StepVerifier.create(extractor.extract(response, this.context)).then(() -> {         body.assertWasSubscribed().         body.emit(dataBuffer).     }).verifyComplete().     body.assertCancelled(). }
false;public;0;15;;@Test public void toMonoVoidAsClientWithEmptyBody() {     TestPublisher<DataBuffer> body = TestPublisher.create().     BodyExtractor<Mono<Void>, ReactiveHttpInputMessage> extractor = BodyExtractors.toMono(Void.class).     MockClientHttpResponse response = new MockClientHttpResponse(HttpStatus.OK).     response.setBody(body.flux()).     StepVerifier.create(extractor.extract(response, this.context)).then(() -> {         body.assertWasSubscribed().         body.complete().     }).verifyComplete(). }
false;public;0;17;;@Test public void toFlux() {     BodyExtractor<Flux<String>, ReactiveHttpInputMessage> extractor = BodyExtractors.toFlux(String.class).     DefaultDataBufferFactory factory = new DefaultDataBufferFactory().     DefaultDataBuffer dataBuffer = factory.wrap(ByteBuffer.wrap("foo".getBytes(StandardCharsets.UTF_8))).     Flux<DataBuffer> body = Flux.just(dataBuffer).     MockServerHttpRequest request = MockServerHttpRequest.post("/").body(body).     Flux<String> result = extractor.extract(request, this.context).     StepVerifier.create(result).expectNext("foo").expectComplete().verify(). }
false;public;0;28;;@Test public void toFluxWithHints() {     BodyExtractor<Flux<User>, ReactiveHttpInputMessage> extractor = BodyExtractors.toFlux(User.class).     this.hints.put(JSON_VIEW_HINT, SafeToDeserialize.class).     DefaultDataBufferFactory factory = new DefaultDataBufferFactory().     String text = "[{\"username\":\"foo\",\"password\":\"bar\"},{\"username\":\"bar\",\"password\":\"baz\"}]".     DefaultDataBuffer dataBuffer = factory.wrap(ByteBuffer.wrap(text.getBytes(StandardCharsets.UTF_8))).     Flux<DataBuffer> body = Flux.just(dataBuffer).     MockServerHttpRequest request = MockServerHttpRequest.post("/").contentType(MediaType.APPLICATION_JSON).body(body).     Flux<User> result = extractor.extract(request, this.context).     StepVerifier.create(result).consumeNextWith(user -> {         assertEquals("foo", user.getUsername()).         assertNull(user.getPassword()).     }).consumeNextWith(user -> {         assertEquals("bar", user.getUsername()).         assertNull(user.getPassword()).     }).expectComplete().verify(). }
false;public;0;4;;@Override public List<HttpMessageReader<?>> messageReaders() {     return Collections.emptyList(). }
false;public;0;4;;@Override public Optional<ServerHttpResponse> serverResponse() {     return Optional.empty(). }
false;public;0;4;;@Override public Map<String, Object> hints() {     return Collections.emptyMap(). }
false;public;0;35;;@Test public void toFluxUnacceptable() {     BodyExtractor<Flux<String>, ReactiveHttpInputMessage> extractor = BodyExtractors.toFlux(String.class).     DefaultDataBufferFactory factory = new DefaultDataBufferFactory().     DefaultDataBuffer dataBuffer = factory.wrap(ByteBuffer.wrap("foo".getBytes(StandardCharsets.UTF_8))).     Flux<DataBuffer> body = Flux.just(dataBuffer).     MockServerHttpRequest request = MockServerHttpRequest.post("/").contentType(MediaType.APPLICATION_JSON).body(body).     BodyExtractor.Context emptyContext = new BodyExtractor.Context() {          @Override         public List<HttpMessageReader<?>> messageReaders() {             return Collections.emptyList().         }          @Override         public Optional<ServerHttpResponse> serverResponse() {             return Optional.empty().         }          @Override         public Map<String, Object> hints() {             return Collections.emptyMap().         }     }.     Flux<String> result = extractor.extract(request, emptyContext).     StepVerifier.create(result).expectError(UnsupportedMediaTypeException.class).verify(). }
false;public;0;26;;@Test public void toFormData() {     DefaultDataBufferFactory factory = new DefaultDataBufferFactory().     String text = "name+1=value+1&name+2=value+2%2B1&name+2=value+2%2B2&name+3".     DefaultDataBuffer dataBuffer = factory.wrap(ByteBuffer.wrap(text.getBytes(StandardCharsets.UTF_8))).     Flux<DataBuffer> body = Flux.just(dataBuffer).     MockServerHttpRequest request = MockServerHttpRequest.post("/").contentType(MediaType.APPLICATION_FORM_URLENCODED).body(body).     Mono<MultiValueMap<String, String>> result = BodyExtractors.toFormData().extract(request, this.context).     StepVerifier.create(result).consumeNextWith(form -> {         assertEquals("Invalid result", 3, form.size()).         assertEquals("Invalid result", "value 1", form.getFirst("name 1")).         List<String> values = form.get("name 2").         assertEquals("Invalid result", 2, values.size()).         assertEquals("Invalid result", "value 2+1", values.get(0)).         assertEquals("Invalid result", "value 2+2", values.get(1)).         assertNull("Invalid result", form.getFirst("name 3")).     }).expectComplete().verify(). }
false;public;0;57;;@Test public void toParts() {     BodyExtractor<Flux<Part>, ServerHttpRequest> extractor = BodyExtractors.toParts().     String bodyContents = "-----------------------------9051914041544843365972754266\r\n" + "Content-Disposition: form-data. name=\"text\"\r\n" + "\r\n" + "text default\r\n" + "-----------------------------9051914041544843365972754266\r\n" + "Content-Disposition: form-data. name=\"file1\". filename=\"a.txt\"\r\n" + "Content-Type: text/plain\r\n" + "\r\n" + "Content of a.txt.\r\n" + "\r\n" + "-----------------------------9051914041544843365972754266\r\n" + "Content-Disposition: form-data. name=\"file2\". filename=\"a.html\"\r\n" + "Content-Type: text/html\r\n" + "\r\n" + "<!DOCTYPE html><title>Content of a.html.</title>\r\n" + "\r\n" + "-----------------------------9051914041544843365972754266--\r\n".     DefaultDataBufferFactory factory = new DefaultDataBufferFactory().     DefaultDataBuffer dataBuffer = factory.wrap(ByteBuffer.wrap(bodyContents.getBytes(StandardCharsets.UTF_8))).     Flux<DataBuffer> body = Flux.just(dataBuffer).     MockServerHttpRequest request = MockServerHttpRequest.post("/").header("Content-Type", "multipart/form-data. boundary=---------------------------9051914041544843365972754266").body(body).     Flux<Part> result = extractor.extract(request, this.context).     StepVerifier.create(result).consumeNextWith(part -> {         assertEquals("text", part.name()).         assertTrue(part instanceof FormFieldPart).         FormFieldPart formFieldPart = (FormFieldPart) part.         assertEquals("text default", formFieldPart.value()).     }).consumeNextWith(part -> {         assertEquals("file1", part.name()).         assertTrue(part instanceof FilePart).         FilePart filePart = (FilePart) part.         assertEquals("a.txt", filePart.filename()).         assertEquals(MediaType.TEXT_PLAIN, filePart.headers().getContentType()).     }).consumeNextWith(part -> {         assertEquals("file2", part.name()).         assertTrue(part instanceof FilePart).         FilePart filePart = (FilePart) part.         assertEquals("a.html", filePart.filename()).         assertEquals(MediaType.TEXT_HTML, filePart.headers().getContentType()).     }).expectComplete().verify(). }
false;public;0;17;;@Test public void toDataBuffers() {     BodyExtractor<Flux<DataBuffer>, ReactiveHttpInputMessage> extractor = BodyExtractors.toDataBuffers().     DefaultDataBufferFactory factory = new DefaultDataBufferFactory().     DefaultDataBuffer dataBuffer = factory.wrap(ByteBuffer.wrap("foo".getBytes(StandardCharsets.UTF_8))).     Flux<DataBuffer> body = Flux.just(dataBuffer).     MockServerHttpRequest request = MockServerHttpRequest.post("/").body(body).     Flux<DataBuffer> result = extractor.extract(request, this.context).     StepVerifier.create(result).expectNext(dataBuffer).expectComplete().verify(). }
false;public;0;27;;// SPR-17054 @Test public void unsupportedMediaTypeShouldConsumeAndCancel() {     NettyDataBufferFactory factory = new NettyDataBufferFactory(new PooledByteBufAllocator(true)).     NettyDataBuffer buffer = factory.wrap(ByteBuffer.wrap("spring".getBytes(StandardCharsets.UTF_8))).     TestPublisher<DataBuffer> body = TestPublisher.create().     MockClientHttpResponse response = new MockClientHttpResponse(HttpStatus.OK).     response.getHeaders().setContentType(MediaType.APPLICATION_PDF).     response.setBody(body.flux()).     BodyExtractor<Mono<User>, ReactiveHttpInputMessage> extractor = BodyExtractors.toMono(User.class).     StepVerifier.create(extractor.extract(response, this.context)).then(() -> {         body.assertWasSubscribed().         body.emit(buffer).     }).expectErrorSatisfies(throwable -> {         assertTrue(throwable instanceof UnsupportedMediaTypeException).         try {             buffer.release().             Assert.fail("releasing the buffer should have failed").         } catch (IllegalReferenceCountException exc) {         }         body.assertCancelled().     }).verify(). }
false;public;0;3;;public String getUsername() {     return username. }
false;public;1;3;;public void setUsername(String username) {     this.username = username. }
false;public;0;3;;public String getPassword() {     return password. }
false;public;1;3;;public void setPassword(String password) {     this.password = password. }
