commented;modifiers;parameterAmount;loc;comment;code
false;public;0;29;;@Test public void supports() {     testSupports(on(Handler.class).annotPresent(ModelAttribute.class).resolveReturnType(String.class)).     testSupports(on(Handler.class).annotNotPresent(ModelAttribute.class).resolveReturnType(String.class)).     testSupports(on(Handler.class).resolveReturnType(Mono.class, String.class)).     testSupports(on(Handler.class).resolveReturnType(Rendering.class)).     testSupports(on(Handler.class).resolveReturnType(Mono.class, Rendering.class)).     testSupports(on(Handler.class).resolveReturnType(View.class)).     testSupports(on(Handler.class).resolveReturnType(Mono.class, View.class)).     testSupports(on(Handler.class).resolveReturnType(void.class)).     testSupports(on(Handler.class).resolveReturnType(Mono.class, Void.class)).     testSupports(on(Handler.class).resolveReturnType(Completable.class)).     testSupports(on(Handler.class).resolveReturnType(Model.class)).     testSupports(on(Handler.class).annotPresent(ModelAttribute.class).resolveReturnType(Map.class)).     testSupports(on(Handler.class).annotNotPresent(ModelAttribute.class).resolveReturnType(Map.class)).     testSupports(on(Handler.class).resolveReturnType(TestBean.class)).     testSupports(on(Handler.class).annotPresent(ModelAttribute.class).resolveReturnType(Long.class)).     testDoesNotSupport(on(Handler.class).annotNotPresent(ModelAttribute.class).resolveReturnType(Long.class)).     // SPR-15464     testSupports(on(Handler.class).resolveReturnType(Mono.class)). }
false;private;1;3;;private void testSupports(MethodParameter returnType) {     testSupports(returnType, true). }
false;private;1;3;;private void testDoesNotSupport(MethodParameter returnType) {     testSupports(returnType, false). }
false;private;2;5;;private void testSupports(MethodParameter returnType, boolean supports) {     ViewResolutionResultHandler resultHandler = resultHandler(mock(ViewResolver.class)).     HandlerResult handlerResult = new HandlerResult(new Object(), null, returnType, this.bindingContext).     assertEquals(supports, resultHandler.supports(handlerResult)). }
false;public;0;10;;@Test public void viewResolverOrder() {     TestViewResolver resolver1 = new TestViewResolver("account").     TestViewResolver resolver2 = new TestViewResolver("profile").     resolver1.setOrder(2).     resolver2.setOrder(1).     List<ViewResolver> resolvers = resultHandler(resolver1, resolver2).getViewResolvers().     assertEquals(Arrays.asList(resolver2, resolver1), resolvers). }
false;public;0;63;;@Test public void handleReturnValueTypes() {     Object returnValue.     MethodParameter returnType.     ViewResolver resolver = new TestViewResolver("account").     returnType = on(Handler.class).resolveReturnType(View.class).     returnValue = new TestView("account").     testHandle("/path", returnType, returnValue, "account: {id=123}").     returnType = on(Handler.class).resolveReturnType(Mono.class, View.class).     returnValue = Mono.just(new TestView("account")).     testHandle("/path", returnType, returnValue, "account: {id=123}").     returnType = on(Handler.class).annotNotPresent(ModelAttribute.class).resolveReturnType(String.class).     returnValue = "account".     testHandle("/path", returnType, returnValue, "account: {id=123}", resolver).     returnType = on(Handler.class).annotPresent(ModelAttribute.class).resolveReturnType(String.class).     returnValue = "123".     testHandle("/account", returnType, returnValue, "account: {id=123, myString=123}", resolver).     returnType = on(Handler.class).resolveReturnType(Mono.class, String.class).     returnValue = Mono.just("account").     testHandle("/path", returnType, returnValue, "account: {id=123}", resolver).     returnType = on(Handler.class).resolveReturnType(Model.class).     returnValue = new ConcurrentModel().addAttribute("name", "Joe").addAttribute("ignore", null).     testHandle("/account", returnType, returnValue, "account: {id=123, name=Joe}", resolver).     // Work around  caching issue...     ResolvableType.clearCache().     returnType = on(Handler.class).annotNotPresent(ModelAttribute.class).resolveReturnType(Map.class).     returnValue = Collections.singletonMap("name", "Joe").     testHandle("/account", returnType, returnValue, "account: {id=123, name=Joe}", resolver).     // Work around  caching issue...     ResolvableType.clearCache().     returnType = on(Handler.class).annotPresent(ModelAttribute.class).resolveReturnType(Map.class).     returnValue = Collections.singletonMap("name", "Joe").     testHandle("/account", returnType, returnValue, "account: {id=123, myMap={name=Joe}}", resolver).     returnType = on(Handler.class).resolveReturnType(TestBean.class).     returnValue = new TestBean("Joe").     String responseBody = "account: {id=123, " + "org.springframework.validation.BindingResult.testBean=" + "org.springframework.validation.BeanPropertyBindingResult: 0 errors, " + "testBean=TestBean[name=Joe]}".     testHandle("/account", returnType, returnValue, responseBody, resolver).     returnType = on(Handler.class).annotPresent(ModelAttribute.class).resolveReturnType(Long.class).     testHandle("/account", returnType, 99L, "account: {id=123, myLong=99}", resolver).     returnType = on(Handler.class).resolveReturnType(Rendering.class).     HttpStatus status = HttpStatus.UNPROCESSABLE_ENTITY.     returnValue = Rendering.view("account").modelAttribute("a", "a1").status(status).header("h", "h1").build().     String expected = "account: {a=a1, id=123}".     ServerWebExchange exchange = testHandle("/path", returnType, returnValue, expected, resolver).     assertEquals(status, exchange.getResponse().getStatusCode()).     assertEquals("h1", exchange.getResponse().getHeaders().getFirst("h")). }
false;public;0;7;;@Test public void handleWithMultipleResolvers() {     testHandle("/account", on(Handler.class).annotNotPresent(ModelAttribute.class).resolveReturnType(String.class), "profile", "profile: {id=123}", new TestViewResolver("account"), new TestViewResolver("profile")). }
false;public;0;7;;@Test public void defaultViewName() {     testDefaultViewName(null, on(Handler.class).annotPresent(ModelAttribute.class).resolveReturnType(String.class)).     testDefaultViewName(Mono.empty(), on(Handler.class).resolveReturnType(Mono.class, String.class)).     testDefaultViewName(Mono.empty(), on(Handler.class).resolveReturnType(Mono.class, Void.class)).     testDefaultViewName(Completable.complete(), on(Handler.class).resolveReturnType(Completable.class)). }
false;private;2;17;;private void testDefaultViewName(Object returnValue, MethodParameter returnType) {     this.bindingContext.getModel().addAttribute("id", "123").     HandlerResult result = new HandlerResult(new Object(), returnValue, returnType, this.bindingContext).     ViewResolutionResultHandler handler = resultHandler(new TestViewResolver("account")).     MockServerWebExchange exchange = MockServerWebExchange.from(get("/account")).     handler.handleResult(exchange, result).block(Duration.ofMillis(5000)).     assertResponseBody(exchange, "account: {id=123}").     exchange = MockServerWebExchange.from(get("/account/")).     handler.handleResult(exchange, result).block(Duration.ofMillis(5000)).     assertResponseBody(exchange, "account: {id=123}").     exchange = MockServerWebExchange.from(get("/account.123")).     handler.handleResult(exchange, result).block(Duration.ofMillis(5000)).     assertResponseBody(exchange, "account: {id=123}"). }
false;public;0;14;;@Test public void unresolvedViewName() {     String returnValue = "account".     MethodParameter returnType = on(Handler.class).annotPresent(ModelAttribute.class).resolveReturnType(String.class).     HandlerResult result = new HandlerResult(new Object(), returnValue, returnType, this.bindingContext).     MockServerWebExchange exchange = MockServerWebExchange.from(get("/path")).     Mono<Void> mono = resultHandler().handleResult(exchange, result).     StepVerifier.create(mono).expectNextCount(0).expectErrorMessage("Could not resolve view with name 'path'.").verify(). }
false;public;0;21;;@Test public void contentNegotiation() {     TestBean value = new TestBean("Joe").     MethodParameter returnType = on(Handler.class).resolveReturnType(TestBean.class).     HandlerResult handlerResult = new HandlerResult(new Object(), value, returnType, this.bindingContext).     MockServerWebExchange exchange = MockServerWebExchange.from(get("/account").accept(APPLICATION_JSON)).     TestView defaultView = new TestView("jsonView", APPLICATION_JSON).     resultHandler(Collections.singletonList(defaultView), new TestViewResolver("account")).handleResult(exchange, handlerResult).block(Duration.ofSeconds(5)).     assertEquals(APPLICATION_JSON, exchange.getResponse().getHeaders().getContentType()).     assertResponseBody(exchange, "jsonView: {" + "org.springframework.validation.BindingResult.testBean=" + "org.springframework.validation.BeanPropertyBindingResult: 0 errors, " + "testBean=TestBean[name=Joe]" + "}"). }
false;public;0;15;;@Test public void contentNegotiationWith406() {     TestBean value = new TestBean("Joe").     MethodParameter returnType = on(Handler.class).resolveReturnType(TestBean.class).     HandlerResult handlerResult = new HandlerResult(new Object(), value, returnType, this.bindingContext).     MockServerWebExchange exchange = MockServerWebExchange.from(get("/account").accept(APPLICATION_JSON)).     ViewResolutionResultHandler resultHandler = resultHandler(new TestViewResolver("account")).     Mono<Void> mono = resultHandler.handleResult(exchange, handlerResult).     StepVerifier.create(mono).expectNextCount(0).expectError(NotAcceptableStatusException.class).verify(). }
false;public;0;17;;// SPR-15291 @Test public void contentNegotiationWithRedirect() {     HandlerResult handlerResult = new HandlerResult(new Object(), "redirect:/", on(Handler.class).annotNotPresent(ModelAttribute.class).resolveReturnType(String.class), this.bindingContext).     UrlBasedViewResolver viewResolver = new UrlBasedViewResolver().     viewResolver.setApplicationContext(new StaticApplicationContext()).     ViewResolutionResultHandler resultHandler = resultHandler(viewResolver).     MockServerWebExchange exchange = MockServerWebExchange.from(get("/account").accept(APPLICATION_JSON)).     resultHandler.handleResult(exchange, handlerResult).block(Duration.ZERO).     MockServerHttpResponse response = exchange.getResponse().     assertEquals(303, response.getStatusCode().value()).     assertEquals("/", response.getHeaders().getLocation().toString()). }
false;private;1;3;;private ViewResolutionResultHandler resultHandler(ViewResolver... resolvers) {     return resultHandler(Collections.emptyList(), resolvers). }
false;private;2;7;;private ViewResolutionResultHandler resultHandler(List<View> defaultViews, ViewResolver... resolvers) {     List<ViewResolver> resolverList = Arrays.asList(resolvers).     RequestedContentTypeResolver contentTypeResolver = new HeaderContentTypeResolver().     ViewResolutionResultHandler handler = new ViewResolutionResultHandler(resolverList, contentTypeResolver).     handler.setDefaultViews(defaultViews).     return handler. }
false;private;5;12;;private ServerWebExchange testHandle(String path, MethodParameter returnType, Object returnValue, String responseBody, ViewResolver... resolvers) {     Model model = this.bindingContext.getModel().     model.asMap().clear().     model.addAttribute("id", "123").     HandlerResult result = new HandlerResult(new Object(), returnValue, returnType, this.bindingContext).     MockServerWebExchange exchange = MockServerWebExchange.from(get(path)).     resultHandler(resolvers).handleResult(exchange, result).block(Duration.ofSeconds(5)).     assertResponseBody(exchange, responseBody).     return exchange. }
false;private;2;6;;private void assertResponseBody(MockServerWebExchange exchange, String responseBody) {     StepVerifier.create(exchange.getResponse().getBody()).consumeNextWith(buf -> assertEquals(responseBody, DataBufferTestUtils.dumpString(buf, UTF_8))).expectComplete().verify(). }
false;;1;3;;void setOrder(int order) {     this.order = order. }
false;public;0;4;;@Override public int getOrder() {     return this.order. }
false;public;2;5;;@Override public Mono<View> resolveViewName(String viewName, Locale locale) {     View view = this.views.get(viewName).     return Mono.justOrEmpty(view). }
false;public;0;4;;@SuppressWarnings("unused") public String getName() {     return this.name. }
false;public;0;4;;@Override public List<MediaType> getSupportedMediaTypes() {     return this.mediaTypes. }
false;public;3;12;;@Override public Mono<Void> render(@Nullable Map<String, ?> model, @Nullable MediaType mediaType, ServerWebExchange exchange) {     ServerHttpResponse response = exchange.getResponse().     if (mediaType != null) {         response.getHeaders().setContentType(mediaType).     }     model = new TreeMap<>(model).     String value = this.name + ": " + model.toString().     ByteBuffer byteBuffer = ByteBuffer.wrap(value.getBytes(UTF_8)).     DataBuffer dataBuffer = new DefaultDataBufferFactory().wrap(byteBuffer).     return response.writeWith(Flux.just(dataBuffer)). }
false;public;0;4;;@SuppressWarnings("unused") public String getName() {     return this.name. }
false;public;0;4;;@Override public String toString() {     return "TestBean[name=" + this.name + "]". }
false;;0;1;;String string() {     return null. }
false;;0;1;;Mono<String> monoString() {     return null. }
false;;0;1;;@ModelAttribute("myString") String stringWithAnnotation() {     return null. }
false;;0;1;;Rendering rendering() {     return null. }
false;;0;1;;Mono<Rendering> monoRendering() {     return null. }
false;;0;1;;View view() {     return null. }
false;;0;1;;Mono<View> monoView() {     return null. }
false;;0;1;;void voidMethod() { }
false;;0;1;;Mono<Void> monoVoid() {     return null. }
false;;0;1;;Completable completable() {     return null. }
false;;0;1;;Model model() {     return null. }
false;;0;1;;Map<?, ?> map() {     return null. }
false;;0;1;;@ModelAttribute("myMap") Map<?, ?> mapWithAnnotation() {     return null. }
false;;0;1;;TestBean testBean() {     return null. }
false;;0;1;;Long longValue() {     return null. }
false;;0;1;;@ModelAttribute("myLong") Long longModelAttribute() {     return null. }
false;;0;1;;Mono<?> monoWildcard() {     return null. }
