commented;modifiers;parameterAmount;loc;comment;code
false;public;3;8;;@Override public ListenableFuture<WebSocketSession> doHandshake(WebSocketHandler webSocketHandler, String uriTemplate, Object... uriVars) {     Assert.notNull(uriTemplate, "'uriTemplate' must not be null").     URI uri = UriComponentsBuilder.fromUriString(uriTemplate).buildAndExpand(uriVars).encode().toUri().     return doHandshake(webSocketHandler, null, uri). }
false;public,final;3;28;;@Override public final ListenableFuture<WebSocketSession> doHandshake(WebSocketHandler webSocketHandler, @Nullable WebSocketHttpHeaders headers, URI uri) {     Assert.notNull(webSocketHandler, "WebSocketHandler must not be null").     assertUri(uri).     if (logger.isDebugEnabled()) {         logger.debug("Connecting to " + uri).     }     HttpHeaders headersToUse = new HttpHeaders().     if (headers != null) {         headers.forEach((header, values) -> {             if (values != null && !specialHeaders.contains(header.toLowerCase())) {                 headersToUse.put(header, values).             }         }).     }     List<String> subProtocols = (headers != null ? headers.getSecWebSocketProtocol() : Collections.emptyList()).     List<WebSocketExtension> extensions = (headers != null ? headers.getSecWebSocketExtensions() : Collections.emptyList()).     return doHandshakeInternal(webSocketHandler, headersToUse, uri, subProtocols, extensions, Collections.emptyMap()). }
false;protected;1;7;;protected void assertUri(URI uri) {     Assert.notNull(uri, "URI must not be null").     String scheme = uri.getScheme().     if (!"ws".equals(scheme) && !"wss".equals(scheme)) {         throw new IllegalArgumentException("Invalid scheme: " + scheme).     } }
true;protected,abstract;6;3;/**  * Perform the actual handshake to establish a connection to the server.  * @param webSocketHandler the client-side handler for WebSocket messages  * @param headers the HTTP headers to use for the handshake, with unwanted (forbidden)  * headers filtered out (never {@code null})  * @param uri the target URI for the handshake (never {@code null})  * @param subProtocols requested sub-protocols, or an empty list  * @param extensions requested WebSocket extensions, or an empty list  * @param attributes attributes to associate with the WebSocketSession, i.e. via  * {@link WebSocketSession#getAttributes()}. currently always an empty map.  * @return the established WebSocket session wrapped in a ListenableFuture.  */ ;/**  * Perform the actual handshake to establish a connection to the server.  * @param webSocketHandler the client-side handler for WebSocket messages  * @param headers the HTTP headers to use for the handshake, with unwanted (forbidden)  * headers filtered out (never {@code null})  * @param uri the target URI for the handshake (never {@code null})  * @param subProtocols requested sub-protocols, or an empty list  * @param extensions requested WebSocket extensions, or an empty list  * @param attributes attributes to associate with the WebSocketSession, i.e. via  * {@link WebSocketSession#getAttributes()}. currently always an empty map.  * @return the established WebSocket session wrapped in a ListenableFuture.  */ protected abstract ListenableFuture<WebSocketSession> doHandshakeInternal(WebSocketHandler webSocketHandler, HttpHeaders headers, URI uri, List<String> subProtocols, List<WebSocketExtension> extensions, Map<String, Object> attributes).
