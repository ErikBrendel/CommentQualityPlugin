commented;modifiers;parameterAmount;loc;comment;code
false;public;0;5;;@Override public List<TransportType> getTransportTypes() {     return (isXhrStreamingDisabled() ? Collections.singletonList(TransportType.XHR) : Arrays.asList(TransportType.XHR_STREAMING, TransportType.XHR)). }
true;public;1;3;/**  * An {@code XhrTransport} can support both the "xhr_streaming" and "xhr"  * SockJS server transports. From a client perspective there is no  * implementation difference.  * <p>Typically an {@code XhrTransport} is used as "XHR streaming" first and  * then, if that fails, as "XHR". In some cases however it may be helpful to  * suppress XHR streaming so that only XHR is attempted.  * <p>By default this property is set to {@code false} which means both  * "XHR streaming" and "XHR" apply.  */ ;/**  * An {@code XhrTransport} can support both the "xhr_streaming" and "xhr"  * SockJS server transports. From a client perspective there is no  * implementation difference.  * <p>Typically an {@code XhrTransport} is used as "XHR streaming" first and  * then, if that fails, as "XHR". In some cases however it may be helpful to  * suppress XHR streaming so that only XHR is attempted.  * <p>By default this property is set to {@code false} which means both  * "XHR streaming" and "XHR" apply.  */ public void setXhrStreamingDisabled(boolean disabled) {     this.xhrStreamingDisabled = disabled. }
true;public;0;3;/**  * Whether XHR streaming is disabled or not.  */ ;/**  * Whether XHR streaming is disabled or not.  */ public boolean isXhrStreamingDisabled() {     return this.xhrStreamingDisabled. }
false;public;2;18;;// Transport methods @Override public ListenableFuture<WebSocketSession> connect(TransportRequest request, WebSocketHandler handler) {     SettableListenableFuture<WebSocketSession> connectFuture = new SettableListenableFuture<>().     XhrClientSockJsSession session = new XhrClientSockJsSession(request, handler, this, connectFuture).     request.addTimeoutTask(session.getTimeoutTask()).     URI receiveUrl = request.getTransportUrl().     if (logger.isDebugEnabled()) {         logger.debug("Starting XHR " + (isXhrStreamingDisabled() ? "Polling" : "Streaming") + "session url=" + receiveUrl).     }     HttpHeaders handshakeHeaders = new HttpHeaders().     handshakeHeaders.putAll(request.getHandshakeHeaders()).     connectInternal(request, handler, receiveUrl, handshakeHeaders, session, connectFuture).     return connectFuture. }
false;protected,abstract;6;3;;protected abstract void connectInternal(TransportRequest request, WebSocketHandler handler, URI receiveUrl, HttpHeaders handshakeHeaders, XhrClientSockJsSession session, SettableListenableFuture<WebSocketSession> connectFuture).
false;public;2;22;;// InfoReceiver methods @Override public String executeInfoRequest(URI infoUrl, @Nullable HttpHeaders headers) {     if (logger.isDebugEnabled()) {         logger.debug("Executing SockJS Info request, url=" + infoUrl).     }     HttpHeaders infoRequestHeaders = new HttpHeaders().     if (headers != null) {         infoRequestHeaders.putAll(headers).     }     ResponseEntity<String> response = executeInfoRequestInternal(infoUrl, infoRequestHeaders).     if (response.getStatusCode() != HttpStatus.OK) {         if (logger.isErrorEnabled()) {             logger.error("SockJS Info request (url=" + infoUrl + ") failed: " + response).         }         throw new HttpServerErrorException(response.getStatusCode()).     }     if (logger.isTraceEnabled()) {         logger.trace("SockJS Info request (url=" + infoUrl + ") response: " + response).     }     String result = response.getBody().     return (result != null ? result : ""). }
false;protected,abstract;2;1;;protected abstract ResponseEntity<String> executeInfoRequestInternal(URI infoUrl, HttpHeaders headers).
false;public;3;16;;// XhrTransport methods @Override public void executeSendRequest(URI url, HttpHeaders headers, TextMessage message) {     if (logger.isTraceEnabled()) {         logger.trace("Starting XHR send, url=" + url).     }     ResponseEntity<String> response = executeSendRequestInternal(url, headers, message).     if (response.getStatusCode() != HttpStatus.NO_CONTENT) {         if (logger.isErrorEnabled()) {             logger.error("XHR send request (url=" + url + ") failed: " + response).         }         throw new HttpServerErrorException(response.getStatusCode()).     }     if (logger.isTraceEnabled()) {         logger.trace("XHR send request (url=" + url + ") response: " + response).     } }
false;protected,abstract;3;2;;protected abstract ResponseEntity<String> executeSendRequestInternal(URI url, HttpHeaders headers, TextMessage message).
