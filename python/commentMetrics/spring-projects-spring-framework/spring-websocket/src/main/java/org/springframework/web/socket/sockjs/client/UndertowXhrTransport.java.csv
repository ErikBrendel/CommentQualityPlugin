commented;modifiers;parameterAmount;loc;comment;code
true;public;0;3;/**  * Return Undertow's native HTTP client.  */ ;/**  * Return Undertow's native HTTP client.  */ public UndertowClient getHttpClient() {     return this.httpClient. }
true;public;0;3;/**  * Return the {@link org.xnio.XnioWorker} backing the I/O operations  * for Undertow's HTTP client.  * @see org.xnio.Xnio  */ ;/**  * Return the {@link org.xnio.XnioWorker} backing the I/O operations  * for Undertow's HTTP client.  * @see org.xnio.Xnio  */ public XnioWorker getWorker() {     return this.worker. }
false;protected;6;7;;@Override protected void connectInternal(TransportRequest request, WebSocketHandler handler, URI receiveUrl, HttpHeaders handshakeHeaders, XhrClientSockJsSession session, SettableListenableFuture<WebSocketSession> connectFuture) {     executeReceiveRequest(request, receiveUrl, handshakeHeaders, session, connectFuture). }
false;public;1;10;;@Override public void completed(ClientConnection connection) {     ClientRequest request = new ClientRequest().setMethod(Methods.POST).setPath(url.getPath()).     HttpString headerName = HttpString.tryFromString(HttpHeaders.HOST).     request.getRequestHeaders().add(headerName, url.getHost()).     addHttpHeaders(request, headers).     HttpHeaders httpHeaders = transportRequest.getHttpRequestHeaders().     connection.sendRequest(request, createReceiveCallback(transportRequest, url, httpHeaders, session, connectFuture)). }
false;public;1;4;;@Override public void failed(IOException ex) {     throw new SockJsTransportFailureException("Failed to execute request to " + url, ex). }
false;private;5;28;;private void executeReceiveRequest(final TransportRequest transportRequest, final URI url, final HttpHeaders headers, final XhrClientSockJsSession session, final SettableListenableFuture<WebSocketSession> connectFuture) {     if (logger.isTraceEnabled()) {         logger.trace("Starting XHR receive request for " + url).     }     ClientCallback<ClientConnection> clientCallback = new ClientCallback<ClientConnection>() {          @Override         public void completed(ClientConnection connection) {             ClientRequest request = new ClientRequest().setMethod(Methods.POST).setPath(url.getPath()).             HttpString headerName = HttpString.tryFromString(HttpHeaders.HOST).             request.getRequestHeaders().add(headerName, url.getHost()).             addHttpHeaders(request, headers).             HttpHeaders httpHeaders = transportRequest.getHttpRequestHeaders().             connection.sendRequest(request, createReceiveCallback(transportRequest, url, httpHeaders, session, connectFuture)).         }          @Override         public void failed(IOException ex) {             throw new SockJsTransportFailureException("Failed to execute request to " + url, ex).         }     }.     this.httpClient.connect(clientCallback, url, this.worker, this.bufferPool, this.optionMap). }
false;private,static;2;8;;private static void addHttpHeaders(ClientRequest request, HttpHeaders headers) {     HeaderMap headerMap = request.getRequestHeaders().     headers.forEach((key, values) -> {         for (String value : values) {             headerMap.add(HttpString.tryFromString(key), value).         }     }). }
false;public;1;30;;@Override public void completed(ClientExchange result) {     ClientResponse response = result.getResponse().     if (response.getResponseCode() != 200) {         HttpStatus status = HttpStatus.valueOf(response.getResponseCode()).         IoUtils.safeClose(result.getConnection()).         onFailure(new HttpServerErrorException(status, "Unexpected XHR receive status")).     } else {         SockJsResponseListener listener = new SockJsResponseListener(transportRequest, result.getConnection(), url, headers, sockJsSession, connectFuture).         listener.setup(result.getResponseChannel()).     }     if (logger.isTraceEnabled()) {         logger.trace("XHR receive headers: " + toHttpHeaders(response.getResponseHeaders())).     }     try {         StreamSinkChannel channel = result.getRequestChannel().         channel.shutdownWrites().         if (!channel.flush()) {             channel.getWriteSetter().set(ChannelListeners.<StreamSinkChannel>flushingChannelListener(null, null)).             channel.resumeWrites().         }     } catch (IOException exc) {         IoUtils.safeClose(result.getConnection()).         onFailure(exc).     } }
false;public;1;5;;@Override public void failed(IOException exc) {     IoUtils.safeClose(exchange.getConnection()).     onFailure(exc). }
false;public;1;41;;@Override public void completed(final ClientExchange exchange) {     exchange.setResponseListener(new ClientCallback<ClientExchange>() {          @Override         public void completed(ClientExchange result) {             ClientResponse response = result.getResponse().             if (response.getResponseCode() != 200) {                 HttpStatus status = HttpStatus.valueOf(response.getResponseCode()).                 IoUtils.safeClose(result.getConnection()).                 onFailure(new HttpServerErrorException(status, "Unexpected XHR receive status")).             } else {                 SockJsResponseListener listener = new SockJsResponseListener(transportRequest, result.getConnection(), url, headers, sockJsSession, connectFuture).                 listener.setup(result.getResponseChannel()).             }             if (logger.isTraceEnabled()) {                 logger.trace("XHR receive headers: " + toHttpHeaders(response.getResponseHeaders())).             }             try {                 StreamSinkChannel channel = result.getRequestChannel().                 channel.shutdownWrites().                 if (!channel.flush()) {                     channel.getWriteSetter().set(ChannelListeners.<StreamSinkChannel>flushingChannelListener(null, null)).                     channel.resumeWrites().                 }             } catch (IOException exc) {                 IoUtils.safeClose(result.getConnection()).                 onFailure(exc).             }         }          @Override         public void failed(IOException exc) {             IoUtils.safeClose(exchange.getConnection()).             onFailure(exc).         }     }). }
false;public;1;4;;@Override public void failed(IOException exc) {     onFailure(exc). }
false;private;1;12;;private void onFailure(Throwable failure) {     if (connectFuture.setException(failure)) {         return.     }     if (sockJsSession.isDisconnected()) {         sockJsSession.afterTransportClosed(null).     } else {         sockJsSession.handleTransportError(failure).         sockJsSession.afterTransportClosed(new CloseStatus(1006, failure.getMessage())).     } }
false;private;5;66;;private ClientCallback<ClientExchange> createReceiveCallback(final TransportRequest transportRequest, final URI url, final HttpHeaders headers, final XhrClientSockJsSession sockJsSession, final SettableListenableFuture<WebSocketSession> connectFuture) {     return new ClientCallback<ClientExchange>() {          @Override         public void completed(final ClientExchange exchange) {             exchange.setResponseListener(new ClientCallback<ClientExchange>() {                  @Override                 public void completed(ClientExchange result) {                     ClientResponse response = result.getResponse().                     if (response.getResponseCode() != 200) {                         HttpStatus status = HttpStatus.valueOf(response.getResponseCode()).                         IoUtils.safeClose(result.getConnection()).                         onFailure(new HttpServerErrorException(status, "Unexpected XHR receive status")).                     } else {                         SockJsResponseListener listener = new SockJsResponseListener(transportRequest, result.getConnection(), url, headers, sockJsSession, connectFuture).                         listener.setup(result.getResponseChannel()).                     }                     if (logger.isTraceEnabled()) {                         logger.trace("XHR receive headers: " + toHttpHeaders(response.getResponseHeaders())).                     }                     try {                         StreamSinkChannel channel = result.getRequestChannel().                         channel.shutdownWrites().                         if (!channel.flush()) {                             channel.getWriteSetter().set(ChannelListeners.<StreamSinkChannel>flushingChannelListener(null, null)).                             channel.resumeWrites().                         }                     } catch (IOException exc) {                         IoUtils.safeClose(result.getConnection()).                         onFailure(exc).                     }                 }                  @Override                 public void failed(IOException exc) {                     IoUtils.safeClose(exchange.getConnection()).                     onFailure(exc).                 }             }).         }          @Override         public void failed(IOException exc) {             onFailure(exc).         }          private void onFailure(Throwable failure) {             if (connectFuture.setException(failure)) {                 return.             }             if (sockJsSession.isDisconnected()) {                 sockJsSession.afterTransportClosed(null).             } else {                 sockJsSession.handleTransportError(failure).                 sockJsSession.afterTransportClosed(new CloseStatus(1006, failure.getMessage())).             }         }     }. }
false;private,static;1;9;;private static HttpHeaders toHttpHeaders(HeaderMap headerMap) {     HttpHeaders httpHeaders = new HttpHeaders().     for (HttpString name : headerMap.getHeaderNames()) {         for (String value : headerMap.get(name)) {             httpHeaders.add(name.toString(), value).         }     }     return httpHeaders. }
false;protected;2;4;;@Override protected ResponseEntity<String> executeInfoRequestInternal(URI infoUrl, HttpHeaders headers) {     return executeRequest(infoUrl, Methods.GET, headers, null). }
false;protected;3;4;;@Override protected ResponseEntity<String> executeSendRequestInternal(URI url, HttpHeaders headers, TextMessage message) {     return executeRequest(url, Methods.POST, headers, message.getPayload()). }
false;protected;4;40;;protected ResponseEntity<String> executeRequest(URI url, HttpString method, HttpHeaders headers, @Nullable String body) {     CountDownLatch latch = new CountDownLatch(1).     List<ClientResponse> responses = new CopyOnWriteArrayList<>().     try {         ClientConnection connection = this.httpClient.connect(url, this.worker, this.bufferPool, this.optionMap).get().         try {             ClientRequest request = new ClientRequest().setMethod(method).setPath(url.getPath()).             request.getRequestHeaders().add(HttpString.tryFromString(HttpHeaders.HOST), url.getHost()).             if (StringUtils.hasLength(body)) {                 HttpString headerName = HttpString.tryFromString(HttpHeaders.CONTENT_LENGTH).                 request.getRequestHeaders().add(headerName, body.length()).             }             addHttpHeaders(request, headers).             connection.sendRequest(request, createRequestCallback(body, responses, latch)).             latch.await().             ClientResponse response = responses.iterator().next().             HttpStatus status = HttpStatus.valueOf(response.getResponseCode()).             HttpHeaders responseHeaders = toHttpHeaders(response.getResponseHeaders()).             String responseBody = response.getAttachment(RESPONSE_BODY).             return (responseBody != null ? new ResponseEntity<>(responseBody, responseHeaders, status) : new ResponseEntity<>(responseHeaders, status)).         } finally {             IoUtils.safeClose(connection).         }     } catch (IOException ex) {         throw new SockJsTransportFailureException("Failed to execute request to " + url, ex).     } catch (InterruptedException ex) {         Thread.currentThread().interrupt().         throw new SockJsTransportFailureException("Interrupted while processing request to " + url, ex).     } }
false;protected;1;5;;@Override protected void stringDone(String string) {     result.getResponse().putAttachment(RESPONSE_BODY, string).     latch.countDown(). }
false;protected;1;4;;@Override protected void error(IOException ex) {     onFailure(latch, ex). }
false;public;1;15;;@Override public void completed(final ClientExchange result) {     responses.add(result.getResponse()).     new StringReadChannelListener(result.getConnection().getBufferPool()) {          @Override         protected void stringDone(String string) {             result.getResponse().putAttachment(RESPONSE_BODY, string).             latch.countDown().         }          @Override         protected void error(IOException ex) {             onFailure(latch, ex).         }     }.setup(result.getResponseChannel()). }
false;public;1;4;;@Override public void failed(IOException ex) {     onFailure(latch, ex). }
false;public;1;38;;@Override public void completed(ClientExchange result) {     result.setResponseListener(new ClientCallback<ClientExchange>() {          @Override         public void completed(final ClientExchange result) {             responses.add(result.getResponse()).             new StringReadChannelListener(result.getConnection().getBufferPool()) {                  @Override                 protected void stringDone(String string) {                     result.getResponse().putAttachment(RESPONSE_BODY, string).                     latch.countDown().                 }                  @Override                 protected void error(IOException ex) {                     onFailure(latch, ex).                 }             }.setup(result.getResponseChannel()).         }          @Override         public void failed(IOException ex) {             onFailure(latch, ex).         }     }).     try {         if (body != null) {             result.getRequestChannel().write(ByteBuffer.wrap(body.getBytes())).         }         result.getRequestChannel().shutdownWrites().         if (!result.getRequestChannel().flush()) {             result.getRequestChannel().getWriteSetter().set(ChannelListeners.<StreamSinkChannel>flushingChannelListener(null, null)).             result.getRequestChannel().resumeWrites().         }     } catch (IOException ex) {         onFailure(latch, ex).     } }
false;public;1;4;;@Override public void failed(IOException ex) {     onFailure(latch, ex). }
false;private;2;4;;private void onFailure(CountDownLatch latch, IOException ex) {     latch.countDown().     throw new SockJsTransportFailureException("Failed to execute request", ex). }
false;private;3;54;;private ClientCallback<ClientExchange> createRequestCallback(@Nullable final String body, final List<ClientResponse> responses, final CountDownLatch latch) {     return new ClientCallback<ClientExchange>() {          @Override         public void completed(ClientExchange result) {             result.setResponseListener(new ClientCallback<ClientExchange>() {                  @Override                 public void completed(final ClientExchange result) {                     responses.add(result.getResponse()).                     new StringReadChannelListener(result.getConnection().getBufferPool()) {                          @Override                         protected void stringDone(String string) {                             result.getResponse().putAttachment(RESPONSE_BODY, string).                             latch.countDown().                         }                          @Override                         protected void error(IOException ex) {                             onFailure(latch, ex).                         }                     }.setup(result.getResponseChannel()).                 }                  @Override                 public void failed(IOException ex) {                     onFailure(latch, ex).                 }             }).             try {                 if (body != null) {                     result.getRequestChannel().write(ByteBuffer.wrap(body.getBytes())).                 }                 result.getRequestChannel().shutdownWrites().                 if (!result.getRequestChannel().flush()) {                     result.getRequestChannel().getWriteSetter().set(ChannelListeners.<StreamSinkChannel>flushingChannelListener(null, null)).                     result.getRequestChannel().resumeWrites().                 }             } catch (IOException ex) {                 onFailure(latch, ex).             }         }          @Override         public void failed(IOException ex) {             onFailure(latch, ex).         }          private void onFailure(CountDownLatch latch, IOException ex) {             latch.countDown().             throw new SockJsTransportFailureException("Failed to execute request", ex).         }     }. }
false;public;1;5;;public void setup(StreamSourceChannel channel) {     channel.suspendReads().     channel.getReadSetter().set(this).     channel.resumeReads(). }
false;public;1;45;;@Override public void handleEvent(StreamSourceChannel channel) {     if (this.session.isDisconnected()) {         if (logger.isDebugEnabled()) {             logger.debug("SockJS sockJsSession closed, closing response.").         }         IoUtils.safeClose(this.connection).         throw new SockJsException("Session closed.", this.session.getId(), null).     }     PooledByteBuffer pooled = bufferPool.allocate().     try {         int r.         do {             ByteBuffer buffer = pooled.getBuffer().             buffer.clear().             r = channel.read(buffer).             buffer.flip().             if (r == 0) {                 return.             } else if (r == -1) {                 onSuccess().             } else {                 while (buffer.hasRemaining()) {                     int b = buffer.get().                     if (b == '\n') {                         handleFrame().                     } else {                         this.outputStream.write(b).                     }                 }             }         } while (r > 0).     } catch (IOException exc) {         onFailure(exc).     } finally {         pooled.close().     } }
false;private;0;11;;private void handleFrame() {     byte[] bytes = this.outputStream.toByteArray().     this.outputStream.reset().     String content = new String(bytes, SockJsFrame.CHARSET).     if (logger.isTraceEnabled()) {         logger.trace("XHR content received: " + content).     }     if (!PRELUDE.equals(content)) {         this.session.handleFrame(new String(bytes, SockJsFrame.CHARSET)).     } }
false;public;0;10;;public void onSuccess() {     if (this.outputStream.size() > 0) {         handleFrame().     }     if (logger.isTraceEnabled()) {         logger.trace("XHR receive request completed.").     }     IoUtils.safeClose(this.connection).     executeReceiveRequest(this.request, this.url, this.headers, this.session, this.connectFuture). }
false;public;1;13;;public void onFailure(Throwable failure) {     IoUtils.safeClose(this.connection).     if (this.connectFuture.setException(failure)) {         return.     }     if (this.session.isDisconnected()) {         this.session.afterTransportClosed(null).     } else {         this.session.handleTransportError(failure).         this.session.afterTransportClosed(new CloseStatus(1006, failure.getMessage())).     } }
