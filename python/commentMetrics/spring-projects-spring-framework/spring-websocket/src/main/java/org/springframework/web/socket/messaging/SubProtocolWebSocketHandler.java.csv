commented;modifiers;parameterAmount;loc;comment;code
true;public;1;7;/**  * Configure one or more handlers to use depending on the sub-protocol requested by  * the client in the WebSocket handshake request.  * @param protocolHandlers the sub-protocol handlers to use  */ ;/**  * Configure one or more handlers to use depending on the sub-protocol requested by  * the client in the WebSocket handshake request.  * @param protocolHandlers the sub-protocol handlers to use  */ public void setProtocolHandlers(List<SubProtocolHandler> protocolHandlers) {     this.protocolHandlerLookup.clear().     this.protocolHandlers.clear().     for (SubProtocolHandler handler : protocolHandlers) {         addProtocolHandler(handler).     } }
false;public;0;3;;public List<SubProtocolHandler> getProtocolHandlers() {     return new ArrayList<>(this.protocolHandlers). }
true;public;1;17;/**  * Register a sub-protocol handler.  */ ;/**  * Register a sub-protocol handler.  */ public void addProtocolHandler(SubProtocolHandler handler) {     List<String> protocols = handler.getSupportedProtocols().     if (CollectionUtils.isEmpty(protocols)) {         if (logger.isErrorEnabled()) {             logger.error("No sub-protocols for " + handler).         }         return.     }     for (String protocol : protocols) {         SubProtocolHandler replaced = this.protocolHandlerLookup.put(protocol, handler).         if (replaced != null && replaced != handler) {             throw new IllegalStateException("Cannot map " + handler + " to protocol '" + protocol + "': already mapped to " + replaced + ".").         }     }     this.protocolHandlers.add(handler). }
true;public;0;3;/**  * Return the sub-protocols keyed by protocol name.  */ ;/**  * Return the sub-protocols keyed by protocol name.  */ public Map<String, SubProtocolHandler> getProtocolHandlerMap() {     return this.protocolHandlerLookup. }
true;public;1;6;/**  * Set the {@link SubProtocolHandler} to use when the client did not request a  * sub-protocol.  * @param defaultProtocolHandler the default handler  */ ;/**  * Set the {@link SubProtocolHandler} to use when the client did not request a  * sub-protocol.  * @param defaultProtocolHandler the default handler  */ public void setDefaultProtocolHandler(@Nullable SubProtocolHandler defaultProtocolHandler) {     this.defaultProtocolHandler = defaultProtocolHandler.     if (this.protocolHandlerLookup.isEmpty()) {         setProtocolHandlers(Collections.singletonList(defaultProtocolHandler)).     } }
true;public;0;4;/**  * Return the default sub-protocol handler to use.  */ ;/**  * Return the default sub-protocol handler to use.  */ @Nullable public SubProtocolHandler getDefaultProtocolHandler() {     return this.defaultProtocolHandler. }
true;public;0;3;/**  * Return all supported protocols.  */ ;/**  * Return all supported protocols.  */ public List<String> getSubProtocols() {     return new ArrayList<>(this.protocolHandlerLookup.keySet()). }
true;public;1;3;/**  * Specify the send-time limit (milliseconds).  * @see ConcurrentWebSocketSessionDecorator  */ ;/**  * Specify the send-time limit (milliseconds).  * @see ConcurrentWebSocketSessionDecorator  */ public void setSendTimeLimit(int sendTimeLimit) {     this.sendTimeLimit = sendTimeLimit. }
true;public;0;3;/**  * Return the send-time limit (milliseconds).  */ ;/**  * Return the send-time limit (milliseconds).  */ public int getSendTimeLimit() {     return this.sendTimeLimit. }
true;public;1;3;/**  * Specify the buffer-size limit (number of bytes).  * @see ConcurrentWebSocketSessionDecorator  */ ;/**  * Specify the buffer-size limit (number of bytes).  * @see ConcurrentWebSocketSessionDecorator  */ public void setSendBufferSizeLimit(int sendBufferSizeLimit) {     this.sendBufferSizeLimit = sendBufferSizeLimit. }
true;public;0;3;/**  * Return the buffer-size limit (number of bytes).  */ ;/**  * Return the buffer-size limit (number of bytes).  */ public int getSendBufferSizeLimit() {     return this.sendBufferSizeLimit. }
true;public;1;3;/**  * Set the maximum time allowed in milliseconds after the WebSocket connection  * is established and before the first sub-protocol message is received.  * <p>This handler is for WebSocket connections that use a sub-protocol.  * Therefore, we expect the client to send at least one sub-protocol message  * in the beginning, or else we assume the connection isn't doing well, e.g.  * proxy issue, slow network, and can be closed.  * <p>By default this is set to {@code 60,000} (1 minute).  * @param timeToFirstMessage the maximum time allowed in milliseconds  * @since 5.1  * @see #checkSessions()  */ ;/**  * Set the maximum time allowed in milliseconds after the WebSocket connection  * is established and before the first sub-protocol message is received.  * <p>This handler is for WebSocket connections that use a sub-protocol.  * Therefore, we expect the client to send at least one sub-protocol message  * in the beginning, or else we assume the connection isn't doing well, e.g.  * proxy issue, slow network, and can be closed.  * <p>By default this is set to {@code 60,000} (1 minute).  * @param timeToFirstMessage the maximum time allowed in milliseconds  * @since 5.1  * @see #checkSessions()  */ public void setTimeToFirstMessage(int timeToFirstMessage) {     this.timeToFirstMessage = timeToFirstMessage. }
true;public;0;3;/**  * Return the maximum time allowed after the WebSocket connection is  * established and before the first sub-protocol message.  * @since 5.1  */ ;/**  * Return the maximum time allowed after the WebSocket connection is  * established and before the first sub-protocol message.  * @since 5.1  */ public int getTimeToFirstMessage() {     return this.timeToFirstMessage. }
true;public;0;3;/**  * Return a String describing internal state and counters.  */ ;/**  * Return a String describing internal state and counters.  */ public String getStatsInfo() {     return this.stats.toString(). }
false;public,final;0;9;;@Override public final void start() {     Assert.isTrue(this.defaultProtocolHandler != null || !this.protocolHandlers.isEmpty(), "No handlers").     synchronized (this.lifecycleMonitor) {         this.clientOutboundChannel.subscribe(this).         this.running = true.     } }
false;public,final;0;19;;@Override public final void stop() {     synchronized (this.lifecycleMonitor) {         this.running = false.         this.clientOutboundChannel.unsubscribe(this).     }     // Proactively notify all active WebSocket sessions     for (WebSocketSessionHolder holder : this.sessions.values()) {         try {             holder.getSession().close(CloseStatus.GOING_AWAY).         } catch (Throwable ex) {             if (logger.isWarnEnabled()) {                 logger.warn("Failed to close '" + holder.getSession() + "': " + ex).             }         }     } }
false;public,final;1;7;;@Override public final void stop(Runnable callback) {     synchronized (this.lifecycleMonitor) {         stop().         callback.run().     } }
false;public,final;0;4;;@Override public final boolean isRunning() {     return this.running. }
false;public;1;12;;@Override public void afterConnectionEstablished(WebSocketSession session) throws Exception {     // WebSocketHandlerDecorator could close the session     if (!session.isOpen()) {         return.     }     this.stats.incrementSessionCount(session).     session = decorateSession(session).     this.sessions.put(session.getId(), new WebSocketSessionHolder(session)).     findProtocolHandler(session).afterSessionStarted(session, this.clientInboundChannel). }
true;public;2;13;/**  * Handle an inbound message from a WebSocket client.  */ ;/**  * Handle an inbound message from a WebSocket client.  */ @Override public void handleMessage(WebSocketSession session, WebSocketMessage<?> message) throws Exception {     WebSocketSessionHolder holder = this.sessions.get(session.getId()).     if (holder != null) {         session = holder.getSession().     }     SubProtocolHandler protocolHandler = findProtocolHandler(session).     protocolHandler.handleMessageFromClient(session, message, this.clientInboundChannel).     if (holder != null) {         holder.setHasHandledMessages().     }     checkSessions(). }
true;public;1;43;/**  * Handle an outbound Spring Message to a WebSocket client.  */ ;/**  * Handle an outbound Spring Message to a WebSocket client.  */ @Override public void handleMessage(Message<?> message) throws MessagingException {     String sessionId = resolveSessionId(message).     if (sessionId == null) {         if (logger.isErrorEnabled()) {             logger.error("Could not find session id in " + message).         }         return.     }     WebSocketSessionHolder holder = this.sessions.get(sessionId).     if (holder == null) {         if (logger.isDebugEnabled()) {             // The broker may not have removed the session yet             logger.debug("No session for " + message).         }         return.     }     WebSocketSession session = holder.getSession().     try {         findProtocolHandler(session).handleMessageToClient(session, message).     } catch (SessionLimitExceededException ex) {         try {             if (logger.isDebugEnabled()) {                 logger.debug("Terminating '" + session + "'", ex).             }             this.stats.incrementLimitExceededCount().             // clear first, session may be unresponsive             clearSession(session, ex.getStatus()).             session.close(ex.getStatus()).         } catch (Exception secondException) {             logger.debug("Failure while closing session " + sessionId + ".", secondException).         }     } catch (Exception ex) {         // Could be part of normal workflow (e.g. browser tab closed)         if (logger.isDebugEnabled()) {             logger.debug("Failed to send message to client in " + session + ": " + message, ex).         }     } }
false;public;2;4;;@Override public void handleTransportError(WebSocketSession session, Throwable exception) throws Exception {     this.stats.incrementTransportError(). }
false;public;2;4;;@Override public void afterConnectionClosed(WebSocketSession session, CloseStatus closeStatus) throws Exception {     clearSession(session, closeStatus). }
false;public;0;4;;@Override public boolean supportsPartialMessages() {     return false. }
true;protected;1;3;/**  * Decorate the given {@link WebSocketSession}, if desired.  * <p>The default implementation builds a {@link ConcurrentWebSocketSessionDecorator}  * with the configured {@link #getSendTimeLimit() send-time limit} and  * {@link #getSendBufferSizeLimit() buffer-size limit}.  * @param session the original {@code WebSocketSession}  * @return the decorated {@code WebSocketSession}, or potentially the given session as-is  * @since 4.3.13  */ ;/**  * Decorate the given {@link WebSocketSession}, if desired.  * <p>The default implementation builds a {@link ConcurrentWebSocketSessionDecorator}  * with the configured {@link #getSendTimeLimit() send-time limit} and  * {@link #getSendBufferSizeLimit() buffer-size limit}.  * @param session the original {@code WebSocketSession}  * @return the decorated {@code WebSocketSession}, or potentially the given session as-is  * @since 4.3.13  */ protected WebSocketSession decorateSession(WebSocketSession session) {     return new ConcurrentWebSocketSessionDecorator(session, getSendTimeLimit(), getSendBufferSizeLimit()). }
true;protected,final;1;33;/**  * Find a {@link SubProtocolHandler} for the given session.  * @param session the {@code WebSocketSession} to find a handler for  */ ;/**  * Find a {@link SubProtocolHandler} for the given session.  * @param session the {@code WebSocketSession} to find a handler for  */ protected final SubProtocolHandler findProtocolHandler(WebSocketSession session) {     String protocol = null.     try {         protocol = session.getAcceptedProtocol().     } catch (Exception ex) {         // Shouldn't happen         logger.error("Failed to obtain session.getAcceptedProtocol(): " + "will use the default protocol handler (if configured).", ex).     }     SubProtocolHandler handler.     if (!StringUtils.isEmpty(protocol)) {         handler = this.protocolHandlerLookup.get(protocol).         if (handler == null) {             throw new IllegalStateException("No handler for '" + protocol + "' among " + this.protocolHandlerLookup).         }     } else {         if (this.defaultProtocolHandler != null) {             handler = this.defaultProtocolHandler.         } else if (this.protocolHandlers.size() == 1) {             handler = this.protocolHandlers.iterator().next().         } else {             throw new IllegalStateException("Multiple protocol handlers configured and " + "no protocol was negotiated. Consider configuring a default SubProtocolHandler.").         }     }     return handler. }
false;private;1;16;;@Nullable private String resolveSessionId(Message<?> message) {     for (SubProtocolHandler handler : this.protocolHandlerLookup.values()) {         String sessionId = handler.resolveSessionId(message).         if (sessionId != null) {             return sessionId.         }     }     if (this.defaultProtocolHandler != null) {         String sessionId = this.defaultProtocolHandler.resolveSessionId(message).         if (sessionId != null) {             return sessionId.         }     }     return null. }
true;private;0;38;/**  * When a session is connected through a higher-level protocol it has a chance  * to use heartbeat management to shut down sessions that are too slow to send  * or receive messages. However, after a WebSocketSession is established and  * before the higher level protocol is fully connected there is a possibility for  * sessions to hang. This method checks and closes any sessions that have been  * connected for more than 60 seconds without having received a single message.  */ ;/**  * When a session is connected through a higher-level protocol it has a chance  * to use heartbeat management to shut down sessions that are too slow to send  * or receive messages. However, after a WebSocketSession is established and  * before the higher level protocol is fully connected there is a possibility for  * sessions to hang. This method checks and closes any sessions that have been  * connected for more than 60 seconds without having received a single message.  */ private void checkSessions() {     long currentTime = System.currentTimeMillis().     if (!isRunning() || (currentTime - this.lastSessionCheckTime < getTimeToFirstMessage())) {         return.     }     if (this.sessionCheckLock.tryLock()) {         try {             for (WebSocketSessionHolder holder : this.sessions.values()) {                 if (holder.hasHandledMessages()) {                     continue.                 }                 long timeSinceCreated = currentTime - holder.getCreateTime().                 if (timeSinceCreated < getTimeToFirstMessage()) {                     continue.                 }                 WebSocketSession session = holder.getSession().                 if (logger.isInfoEnabled()) {                     logger.info("No messages received after " + timeSinceCreated + " ms. " + "Closing " + holder.getSession() + ".").                 }                 try {                     this.stats.incrementNoMessagesReceivedCount().                     session.close(CloseStatus.SESSION_NOT_RELIABLE).                 } catch (Throwable ex) {                     if (logger.isWarnEnabled()) {                         logger.warn("Failed to close unreliable " + session, ex).                     }                 }             }         } finally {             this.lastSessionCheckTime = currentTime.             this.sessionCheckLock.unlock().         }     } }
false;private;2;9;;private void clearSession(WebSocketSession session, CloseStatus closeStatus) throws Exception {     if (logger.isDebugEnabled()) {         logger.debug("Clearing session " + session.getId()).     }     if (this.sessions.remove(session.getId()) != null) {         this.stats.decrementSessionCount(session).     }     findProtocolHandler(session).afterSessionEnded(session, closeStatus, this.clientInboundChannel). }
false;public;0;4;;@Override public String toString() {     return "SubProtocolWebSocketHandler" + this.protocolHandlers. }
false;public;0;3;;public WebSocketSession getSession() {     return this.session. }
false;public;0;3;;public long getCreateTime() {     return this.createTime. }
false;public;0;3;;public void setHasHandledMessages() {     this.hasHandledMessages = true. }
false;public;0;3;;public boolean hasHandledMessages() {     return this.hasHandledMessages. }
false;public;0;5;;@Override public String toString() {     return "WebSocketSessionHolder[session=" + this.session + ", createTime=" + this.createTime + ", hasHandledMessages=" + this.hasHandledMessages + "]". }
false;public;1;4;;public void incrementSessionCount(WebSocketSession session) {     getCountFor(session).incrementAndGet().     this.total.incrementAndGet(). }
false;public;1;3;;public void decrementSessionCount(WebSocketSession session) {     getCountFor(session).decrementAndGet(). }
false;public;0;3;;public void incrementLimitExceededCount() {     this.limitExceeded.incrementAndGet(). }
false;public;0;3;;public void incrementNoMessagesReceivedCount() {     this.noMessagesReceived.incrementAndGet(). }
false;public;0;3;;public void incrementTransportError() {     this.transportError.incrementAndGet(). }
false;private;1;11;;private AtomicInteger getCountFor(WebSocketSession session) {     if (session instanceof PollingSockJsSession) {         return this.httpPolling.     } else if (session instanceof StreamingSockJsSession) {         return this.httpStreaming.     } else {         return this.webSocket.     } }
false;public;0;11;;public String toString() {     return SubProtocolWebSocketHandler.this.sessions.size() + " current WS(" + this.webSocket.get() + ")-HttpStream(" + this.httpStreaming.get() + ")-HttpPoll(" + this.httpPolling.get() + "), " + this.total.get() + " total, " + (this.limitExceeded.get() + this.noMessagesReceived.get()) + " closed abnormally (" + this.noMessagesReceived.get() + " connect failure, " + this.limitExceeded.get() + " send limit, " + this.transportError.get() + " transport error)". }
