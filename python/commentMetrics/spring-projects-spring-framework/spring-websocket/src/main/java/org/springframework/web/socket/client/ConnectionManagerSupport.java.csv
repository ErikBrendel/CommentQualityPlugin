commented;modifiers;parameterAmount;loc;comment;code
false;protected;0;3;;protected URI getUri() {     return this.uri. }
true;public;1;3;/**  * Set whether to auto-connect to the remote endpoint after this connection manager  * has been initialized and the Spring context has been refreshed.  * <p>Default is "false".  */ ;/**  * Set whether to auto-connect to the remote endpoint after this connection manager  * has been initialized and the Spring context has been refreshed.  * <p>Default is "false".  */ public void setAutoStartup(boolean autoStartup) {     this.autoStartup = autoStartup. }
true;public;0;4;/**  * Return the value for the 'autoStartup' property. If "true", this endpoint  * connection manager will connect to the remote endpoint upon a  * ContextRefreshedEvent.  */ ;/**  * Return the value for the 'autoStartup' property. If "true", this endpoint  * connection manager will connect to the remote endpoint upon a  * ContextRefreshedEvent.  */ @Override public boolean isAutoStartup() {     return this.autoStartup. }
true;public;1;3;/**  * Specify the phase in which a connection should be established to the remote  * endpoint and subsequently closed. The startup order proceeds from lowest to  * highest, and the shutdown order is the reverse of that. By default this value is  * Integer.MAX_VALUE meaning that this endpoint connection factory connects as late as  * possible and is closed as soon as possible.  */ ;/**  * Specify the phase in which a connection should be established to the remote  * endpoint and subsequently closed. The startup order proceeds from lowest to  * highest, and the shutdown order is the reverse of that. By default this value is  * Integer.MAX_VALUE meaning that this endpoint connection factory connects as late as  * possible and is closed as soon as possible.  */ public void setPhase(int phase) {     this.phase = phase. }
true;public;0;4;/**  * Return the phase in which this endpoint connection factory will be auto-connected  * and stopped.  */ ;/**  * Return the phase in which this endpoint connection factory will be auto-connected  * and stopped.  */ @Override public int getPhase() {     return this.phase. }
true;public,final;0;8;/**  * Start the WebSocket connection. If already connected, the method has no impact.  */ ;/**  * Start the WebSocket connection. If already connected, the method has no impact.  */ @Override public final void start() {     synchronized (this.lifecycleMonitor) {         if (!isRunning()) {             startInternal().         }     } }
false;protected;0;9;;protected void startInternal() {     synchronized (this.lifecycleMonitor) {         if (logger.isInfoEnabled()) {             logger.info("Starting " + getClass().getSimpleName()).         }         this.running = true.         openConnection().     } }
false;public,final;0;19;;@Override public final void stop() {     synchronized (this.lifecycleMonitor) {         if (isRunning()) {             if (logger.isInfoEnabled()) {                 logger.info("Stopping " + getClass().getSimpleName()).             }             try {                 stopInternal().             } catch (Throwable ex) {                 logger.error("Failed to stop WebSocket connection", ex).             } finally {                 this.running = false.             }         }     } }
false;public,final;1;7;;@Override public final void stop(Runnable callback) {     synchronized (this.lifecycleMonitor) {         stop().         callback.run().     } }
false;protected;0;5;;protected void stopInternal() throws Exception {     if (isConnected()) {         closeConnection().     } }
true;public;0;4;/**  * Return whether this ConnectionManager has been started.  */ ;/**  * Return whether this ConnectionManager has been started.  */ @Override public boolean isRunning() {     return this.running. }
false;protected,abstract;0;1;;protected abstract void openConnection().
false;protected,abstract;0;1;;protected abstract void closeConnection() throws Exception.
false;protected,abstract;0;1;;protected abstract boolean isConnected().
