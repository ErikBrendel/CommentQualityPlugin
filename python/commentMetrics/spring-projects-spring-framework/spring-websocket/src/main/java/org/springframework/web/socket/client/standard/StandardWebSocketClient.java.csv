commented;modifiers;parameterAmount;loc;comment;code
true;public;1;5;/**  * The standard Java WebSocket API allows passing "user properties" to the  * server via {@link ClientEndpointConfig#getUserProperties() userProperties}.  * Use this property to configure one or more properties to be passed on  * every handshake.  */ ;/**  * The standard Java WebSocket API allows passing "user properties" to the  * server via {@link ClientEndpointConfig#getUserProperties() userProperties}.  * Use this property to configure one or more properties to be passed on  * every handshake.  */ public void setUserProperties(@Nullable Map<String, Object> userProperties) {     if (userProperties != null) {         this.userProperties.putAll(userProperties).     } }
true;public;0;3;/**  * The configured user properties.  */ ;/**  * The configured user properties.  */ public Map<String, Object> getUserProperties() {     return this.userProperties. }
true;public;1;3;/**  * Set an {@link AsyncListenableTaskExecutor} to use when opening connections.  * If this property is set to {@code null}, calls to any of the  * {@code doHandshake} methods will block until the connection is established.  * <p>By default, an instance of {@code SimpleAsyncTaskExecutor} is used.  */ ;/**  * Set an {@link AsyncListenableTaskExecutor} to use when opening connections.  * If this property is set to {@code null}, calls to any of the  * {@code doHandshake} methods will block until the connection is established.  * <p>By default, an instance of {@code SimpleAsyncTaskExecutor} is used.  */ public void setTaskExecutor(@Nullable AsyncListenableTaskExecutor taskExecutor) {     this.taskExecutor = taskExecutor. }
true;public;0;4;/**  * Return the configured {@link TaskExecutor}.  */ ;/**  * Return the configured {@link TaskExecutor}.  */ @Nullable public AsyncListenableTaskExecutor getTaskExecutor() {     return this.taskExecutor. }
false;protected;6;35;;@Override protected ListenableFuture<WebSocketSession> doHandshakeInternal(WebSocketHandler webSocketHandler, HttpHeaders headers, final URI uri, List<String> protocols, List<WebSocketExtension> extensions, Map<String, Object> attributes) {     int port = getPort(uri).     InetSocketAddress localAddress = new InetSocketAddress(getLocalHost(), port).     InetSocketAddress remoteAddress = new InetSocketAddress(uri.getHost(), port).     final StandardWebSocketSession session = new StandardWebSocketSession(headers, attributes, localAddress, remoteAddress).     final ClientEndpointConfig endpointConfig = ClientEndpointConfig.Builder.create().configurator(new StandardWebSocketClientConfigurator(headers)).preferredSubprotocols(protocols).extensions(adaptExtensions(extensions)).build().     endpointConfig.getUserProperties().putAll(getUserProperties()).     final Endpoint endpoint = new StandardWebSocketHandlerAdapter(webSocketHandler, session).     Callable<WebSocketSession> connectTask = () -> {         this.webSocketContainer.connectToServer(endpoint, endpointConfig, uri).         return session.     }.     if (this.taskExecutor != null) {         return this.taskExecutor.submitListenable(connectTask).     } else {         ListenableFutureTask<WebSocketSession> task = new ListenableFutureTask<>(connectTask).         task.run().         return task.     } }
false;private,static;1;7;;private static List<Extension> adaptExtensions(List<WebSocketExtension> extensions) {     List<Extension> result = new ArrayList<>().     for (WebSocketExtension extension : extensions) {         result.add(new WebSocketToStandardExtensionAdapter(extension)).     }     return result. }
false;private;0;8;;private InetAddress getLocalHost() {     try {         return InetAddress.getLocalHost().     } catch (UnknownHostException ex) {         return InetAddress.getLoopbackAddress().     } }
false;private;1;7;;private int getPort(URI uri) {     if (uri.getPort() == -1) {         String scheme = uri.getScheme().toLowerCase(Locale.ENGLISH).         return ("wss".equals(scheme) ? 443 : 80).     }     return uri.getPort(). }
false;public;1;7;;@Override public void beforeRequest(Map<String, List<String>> requestHeaders) {     requestHeaders.putAll(this.headers).     if (logger.isTraceEnabled()) {         logger.trace("Handshake request headers: " + requestHeaders).     } }
false;public;1;6;;@Override public void afterResponse(HandshakeResponse response) {     if (logger.isTraceEnabled()) {         logger.trace("Handshake response headers: " + response.getHeaders()).     } }
