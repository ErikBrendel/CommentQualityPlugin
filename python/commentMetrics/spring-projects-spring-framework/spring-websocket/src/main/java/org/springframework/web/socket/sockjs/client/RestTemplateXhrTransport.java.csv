commented;modifiers;parameterAmount;loc;comment;code
true;public;0;3;/**  * Return the configured {@code RestTemplate}.  */ ;/**  * Return the configured {@code RestTemplate}.  */ public RestOperations getRestTemplate() {     return this.restTemplate. }
true;public;1;4;/**  * Configure the {@code TaskExecutor} to use to execute XHR receive requests.  * <p>By default {@link org.springframework.core.task.SimpleAsyncTaskExecutor  * SimpleAsyncTaskExecutor} is configured which creates a new thread every  * time the transports connects.  */ ;/**  * Configure the {@code TaskExecutor} to use to execute XHR receive requests.  * <p>By default {@link org.springframework.core.task.SimpleAsyncTaskExecutor  * SimpleAsyncTaskExecutor} is configured which creates a new thread every  * time the transports connects.  */ public void setTaskExecutor(TaskExecutor taskExecutor) {     Assert.notNull(taskExecutor, "TaskExecutor must not be null").     this.taskExecutor = taskExecutor. }
true;public;0;3;/**  * Return the configured {@code TaskExecutor}.  */ ;/**  * Return the configured {@code TaskExecutor}.  */ public TaskExecutor getTaskExecutor() {     return this.taskExecutor. }
false;protected;6;35;;@Override protected void connectInternal(final TransportRequest transportRequest, final WebSocketHandler handler, final URI receiveUrl, final HttpHeaders handshakeHeaders, final XhrClientSockJsSession session, final SettableListenableFuture<WebSocketSession> connectFuture) {     getTaskExecutor().execute(() -> {         HttpHeaders httpHeaders = transportRequest.getHttpRequestHeaders().         XhrRequestCallback requestCallback = new XhrRequestCallback(handshakeHeaders).         XhrRequestCallback requestCallbackAfterHandshake = new XhrRequestCallback(httpHeaders).         XhrReceiveExtractor responseExtractor = new XhrReceiveExtractor(session).         while (true) {             if (session.isDisconnected()) {                 session.afterTransportClosed(null).                 break.             }             try {                 if (logger.isTraceEnabled()) {                     logger.trace("Starting XHR receive request, url=" + receiveUrl).                 }                 getRestTemplate().execute(receiveUrl, HttpMethod.POST, requestCallback, responseExtractor).                 requestCallback = requestCallbackAfterHandshake.             } catch (Throwable ex) {                 if (!connectFuture.isDone()) {                     connectFuture.setException(ex).                 } else {                     session.handleTransportError(ex).                     session.afterTransportClosed(new CloseStatus(1006, ex.getMessage())).                 }                 break.             }         }     }). }
false;protected;2;5;;@Override protected ResponseEntity<String> executeInfoRequestInternal(URI infoUrl, HttpHeaders headers) {     RequestCallback requestCallback = new XhrRequestCallback(headers).     return nonNull(this.restTemplate.execute(infoUrl, HttpMethod.GET, requestCallback, textResponseExtractor)). }
false;public;3;5;;@Override public ResponseEntity<String> executeSendRequestInternal(URI url, HttpHeaders headers, TextMessage message) {     RequestCallback requestCallback = new XhrRequestCallback(headers, message.getPayload()).     return nonNull(this.restTemplate.execute(url, HttpMethod.POST, requestCallback, textResponseExtractor)). }
false;private,static;1;4;;private static <T> T nonNull(@Nullable T result) {     Assert.state(result != null, "No result").     return result. }
false;public;1;7;;@Override public void doWithRequest(ClientHttpRequest request) throws IOException {     request.getHeaders().putAll(this.headers).     if (this.body != null) {         StreamUtils.copy(this.body, SockJsFrame.CHARSET, request.getBody()).     } }
false;public;1;45;;@Override public Object extractData(ClientHttpResponse response) throws IOException {     HttpStatus httpStatus = HttpStatus.resolve(response.getRawStatusCode()).     if (httpStatus == null) {         throw new UnknownHttpStatusCodeException(response.getRawStatusCode(), response.getStatusText(), response.getHeaders(), null, null).     }     if (httpStatus != HttpStatus.OK) {         throw new HttpServerErrorException(httpStatus, response.getStatusText(), response.getHeaders(), null, null).     }     if (logger.isTraceEnabled()) {         logger.trace("XHR receive headers: " + response.getHeaders()).     }     InputStream is = response.getBody().     ByteArrayOutputStream os = new ByteArrayOutputStream().     while (true) {         if (this.sockJsSession.isDisconnected()) {             if (logger.isDebugEnabled()) {                 logger.debug("SockJS sockJsSession closed, closing response.").             }             response.close().             break.         }         int b = is.read().         if (b == -1) {             if (os.size() > 0) {                 handleFrame(os).             }             if (logger.isTraceEnabled()) {                 logger.trace("XHR receive completed").             }             break.         }         if (b == '\n') {             handleFrame(os).         } else {             os.write(b).         }     }     return null. }
false;private;1;11;;private void handleFrame(ByteArrayOutputStream os) {     byte[] bytes = os.toByteArray().     os.reset().     String content = new String(bytes, SockJsFrame.CHARSET).     if (logger.isTraceEnabled()) {         logger.trace("XHR receive content: " + content).     }     if (!PRELUDE.equals(content)) {         this.sockJsSession.handleFrame(new String(bytes, SockJsFrame.CHARSET)).     } }
