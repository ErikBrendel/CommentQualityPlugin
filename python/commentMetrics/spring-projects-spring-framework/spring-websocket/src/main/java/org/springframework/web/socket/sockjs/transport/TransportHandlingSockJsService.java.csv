commented;modifiers;parameterAmount;loc;comment;code
true;public;0;3;/**  * Return the registered handlers per transport type.  */ ;/**  * Return the registered handlers per transport type.  */ public Map<TransportType, TransportHandler> getTransportHandlers() {     return Collections.unmodifiableMap(this.handlers). }
true;public;1;3;/**  * The codec to use for encoding and decoding SockJS messages.  */ ;/**  * The codec to use for encoding and decoding SockJS messages.  */ public void setMessageCodec(SockJsMessageCodec messageCodec) {     this.messageCodec = messageCodec. }
false;public;0;5;;public SockJsMessageCodec getMessageCodec() {     Assert.state(this.messageCodec != null, "A SockJsMessageCodec is required but not available: " + "Add Jackson to the classpath, or configure a custom SockJsMessageCodec.").     return this.messageCodec. }
true;public;1;6;/**  * Configure one or more WebSocket handshake request interceptors.  */ ;/**  * Configure one or more WebSocket handshake request interceptors.  */ public void setHandshakeInterceptors(@Nullable List<HandshakeInterceptor> interceptors) {     this.interceptors.clear().     if (interceptors != null) {         this.interceptors.addAll(interceptors).     } }
true;public;0;3;/**  * Return the configured WebSocket handshake request interceptors.  */ ;/**  * Return the configured WebSocket handshake request interceptors.  */ public List<HandshakeInterceptor> getHandshakeInterceptors() {     return this.interceptors. }
false;public;0;11;;@Override public void start() {     if (!isRunning()) {         this.running = true.         for (TransportHandler handler : this.handlers.values()) {             if (handler instanceof Lifecycle) {                 ((Lifecycle) handler).start().             }         }     } }
false;public;0;11;;@Override public void stop() {     if (isRunning()) {         this.running = false.         for (TransportHandler handler : this.handlers.values()) {             if (handler instanceof Lifecycle) {                 ((Lifecycle) handler).stop().             }         }     } }
false;public;0;4;;@Override public boolean isRunning() {     return this.running. }
false;protected;3;35;;@Override protected void handleRawWebSocketRequest(ServerHttpRequest request, ServerHttpResponse response, WebSocketHandler handler) throws IOException {     TransportHandler transportHandler = this.handlers.get(TransportType.WEBSOCKET).     if (!(transportHandler instanceof HandshakeHandler)) {         logger.error("No handler configured for raw WebSocket messages").         response.setStatusCode(HttpStatus.NOT_FOUND).         return.     }     HandshakeInterceptorChain chain = new HandshakeInterceptorChain(this.interceptors, handler).     HandshakeFailureException failure = null.     try {         Map<String, Object> attributes = new HashMap<>().         if (!chain.applyBeforeHandshake(request, response, attributes)) {             return.         }         ((HandshakeHandler) transportHandler).doHandshake(request, response, handler, attributes).         chain.applyAfterHandshake(request, response, null).     } catch (HandshakeFailureException ex) {         failure = ex.     } catch (Throwable ex) {         failure = new HandshakeFailureException("Uncaught failure for request " + request.getURI(), ex).     } finally {         if (failure != null) {             chain.applyAfterHandshake(request, response, failure).             throw failure.         }     } }
false;protected;5;100;;@Override protected void handleTransportRequest(ServerHttpRequest request, ServerHttpResponse response, WebSocketHandler handler, String sessionId, String transport) throws SockJsException {     TransportType transportType = TransportType.fromValue(transport).     if (transportType == null) {         if (logger.isWarnEnabled()) {             logger.warn("Unknown transport type for " + request.getURI()).         }         response.setStatusCode(HttpStatus.NOT_FOUND).         return.     }     TransportHandler transportHandler = this.handlers.get(transportType).     if (transportHandler == null) {         if (logger.isWarnEnabled()) {             logger.warn("No TransportHandler for " + request.getURI()).         }         response.setStatusCode(HttpStatus.NOT_FOUND).         return.     }     SockJsException failure = null.     HandshakeInterceptorChain chain = new HandshakeInterceptorChain(this.interceptors, handler).     try {         HttpMethod supportedMethod = transportType.getHttpMethod().         if (supportedMethod != request.getMethod()) {             if (request.getMethod() == HttpMethod.OPTIONS && transportType.supportsCors()) {                 if (checkOrigin(request, response, HttpMethod.OPTIONS, supportedMethod)) {                     response.setStatusCode(HttpStatus.NO_CONTENT).                     addCacheHeaders(response).                 }             } else if (transportType.supportsCors()) {                 sendMethodNotAllowed(response, supportedMethod, HttpMethod.OPTIONS).             } else {                 sendMethodNotAllowed(response, supportedMethod).             }             return.         }         SockJsSession session = this.sessions.get(sessionId).         if (session == null) {             if (transportHandler instanceof SockJsSessionFactory) {                 Map<String, Object> attributes = new HashMap<>().                 if (!chain.applyBeforeHandshake(request, response, attributes)) {                     return.                 }                 SockJsSessionFactory sessionFactory = (SockJsSessionFactory) transportHandler.                 session = createSockJsSession(sessionId, sessionFactory, handler, attributes).             } else {                 response.setStatusCode(HttpStatus.NOT_FOUND).                 if (logger.isDebugEnabled()) {                     logger.debug("Session not found, sessionId=" + sessionId + ". The session may have been closed " + "(e.g. missed heart-beat) while a message was coming in.").                 }                 return.             }         } else {             Principal principal = session.getPrincipal().             if (principal != null && !principal.equals(request.getPrincipal())) {                 logger.debug("The user for the session does not match the user for the request.").                 response.setStatusCode(HttpStatus.NOT_FOUND).                 return.             }             if (!transportHandler.checkSessionType(session)) {                 logger.debug("Session type does not match the transport type for the request.").                 response.setStatusCode(HttpStatus.NOT_FOUND).                 return.             }         }         if (transportType.sendsNoCacheInstruction()) {             addNoCacheHeaders(response).         }         if (transportType.supportsCors() && !checkOrigin(request, response)) {             return.         }         transportHandler.handleRequest(request, response, handler, session).         chain.applyAfterHandshake(request, response, null).     } catch (SockJsException ex) {         failure = ex.     } catch (Throwable ex) {         failure = new SockJsException("Uncaught failure for request " + request.getURI(), sessionId, ex).     } finally {         if (failure != null) {             chain.applyAfterHandshake(request, response, failure).             throw failure.         }     } }
false;protected;3;18;;@Override protected boolean validateRequest(String serverId, String sessionId, String transport) {     if (!super.validateRequest(serverId, sessionId, transport)) {         return false.     }     if (!this.allowedOrigins.contains("*")) {         TransportType transportType = TransportType.fromValue(transport).         if (transportType == null || !transportType.supportsOrigin()) {             if (logger.isWarnEnabled()) {                 logger.warn("Origin check enabled but transport '" + transport + "' does not support it.").             }             return false.         }     }     return true. }
false;private;4;14;;private SockJsSession createSockJsSession(String sessionId, SockJsSessionFactory sessionFactory, WebSocketHandler handler, Map<String, Object> attributes) {     SockJsSession session = this.sessions.get(sessionId).     if (session != null) {         return session.     }     if (this.sessionCleanupTask == null) {         scheduleSessionTask().     }     session = sessionFactory.createSession(sessionId, handler, attributes).     this.sessions.put(sessionId, session).     return session. }
false;private;0;26;;private void scheduleSessionTask() {     synchronized (this.sessions) {         if (this.sessionCleanupTask != null) {             return.         }         this.sessionCleanupTask = getTaskScheduler().scheduleAtFixedRate(() -> {             List<String> removedIds = new ArrayList<>().             for (SockJsSession session : this.sessions.values()) {                 try {                     if (session.getTimeSinceLastActive() > getDisconnectDelay()) {                         this.sessions.remove(session.getId()).                         removedIds.add(session.getId()).                         session.close().                     }                 } catch (Throwable ex) {                     // Could be part of normal workflow (e.g. browser tab closed)                     logger.debug("Failed to close " + session, ex).                 }             }             if (logger.isDebugEnabled() && !removedIds.isEmpty()) {                 logger.debug("Closed " + removedIds.size() + " sessions: " + removedIds).             }         }, getDisconnectDelay()).     } }
