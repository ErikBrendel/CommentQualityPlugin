commented;modifiers;parameterAmount;loc;comment;code
true;;0;1;/**  * Return a unique session identifier.  */ ;/**  * Return a unique session identifier.  */ String getId().
true;;0;2;/**  * Return the URI used to open the WebSocket connection.  */ ;/**  * Return the URI used to open the WebSocket connection.  */ @Nullable URI getUri().
true;;0;1;/**  * Return the headers used in the handshake request (never {@code null}).  */ ;/**  * Return the headers used in the handshake request (never {@code null}).  */ HttpHeaders getHandshakeHeaders().
true;;0;1;/**  * Return the map with attributes associated with the WebSocket session.  * <p>On the server side the map can be populated initially through a  * {@link org.springframework.web.socket.server.HandshakeInterceptor  * HandshakeInterceptor}. On the client side the map can be populated via  * {@link org.springframework.web.socket.client.WebSocketClient  * WebSocketClient} handshake methods.  * @return a Map with the session attributes (never {@code null})  */ ;/**  * Return the map with attributes associated with the WebSocket session.  * <p>On the server side the map can be populated initially through a  * {@link org.springframework.web.socket.server.HandshakeInterceptor  * HandshakeInterceptor}. On the client side the map can be populated via  * {@link org.springframework.web.socket.client.WebSocketClient  * WebSocketClient} handshake methods.  * @return a Map with the session attributes (never {@code null})  */ Map<String, Object> getAttributes().
true;;0;2;/**  * Return a {@link java.security.Principal} instance containing the name  * of the authenticated user.  * <p>If the user has not been authenticated, the method returns <code>null</code>.  */ ;/**  * Return a {@link java.security.Principal} instance containing the name  * of the authenticated user.  * <p>If the user has not been authenticated, the method returns <code>null</code>.  */ @Nullable Principal getPrincipal().
true;;0;2;/**  * Return the address on which the request was received.  */ ;/**  * Return the address on which the request was received.  */ @Nullable InetSocketAddress getLocalAddress().
true;;0;2;/**  * Return the address of the remote client.  */ ;/**  * Return the address of the remote client.  */ @Nullable InetSocketAddress getRemoteAddress().
true;;0;2;/**  * Return the negotiated sub-protocol.  * @return the protocol identifier, or {@code null} if no protocol  * was specified or negotiated successfully  */ ;/**  * Return the negotiated sub-protocol.  * @return the protocol identifier, or {@code null} if no protocol  * was specified or negotiated successfully  */ @Nullable String getAcceptedProtocol().
true;;1;1;/**  * Configure the maximum size for an incoming text message.  */ ;/**  * Configure the maximum size for an incoming text message.  */ void setTextMessageSizeLimit(int messageSizeLimit).
true;;0;1;/**  * Get the configured maximum size for an incoming text message.  */ ;/**  * Get the configured maximum size for an incoming text message.  */ int getTextMessageSizeLimit().
true;;1;1;/**  * Configure the maximum size for an incoming binary message.  */ ;/**  * Configure the maximum size for an incoming binary message.  */ void setBinaryMessageSizeLimit(int messageSizeLimit).
true;;0;1;/**  * Get the configured maximum size for an incoming binary message.  */ ;/**  * Get the configured maximum size for an incoming binary message.  */ int getBinaryMessageSizeLimit().
true;;0;1;/**  * Determine the negotiated extensions.  * @return the list of extensions, or an empty list if no extension  * was specified or negotiated successfully  */ ;/**  * Determine the negotiated extensions.  * @return the list of extensions, or an empty list if no extension  * was specified or negotiated successfully  */ List<WebSocketExtension> getExtensions().
true;;1;1;/**  * Send a WebSocket message: either {@link TextMessage} or {@link BinaryMessage}.  *  * <p><strong>Note:</strong> The underlying standard WebSocket session (JSR-356) does  * not allow concurrent sending. Therefore sending must be synchronized. To ensure  * that, one option is to wrap the {@code WebSocketSession} with the  * {@link org.springframework.web.socket.handler.ConcurrentWebSocketSessionDecorator  * ConcurrentWebSocketSessionDecorator}.  * @see org.springframework.web.socket.handler.ConcurrentWebSocketSessionDecorator  */ ;/**  * Send a WebSocket message: either {@link TextMessage} or {@link BinaryMessage}.  *  * <p><strong>Note:</strong> The underlying standard WebSocket session (JSR-356) does  * not allow concurrent sending. Therefore sending must be synchronized. To ensure  * that, one option is to wrap the {@code WebSocketSession} with the  * {@link org.springframework.web.socket.handler.ConcurrentWebSocketSessionDecorator  * ConcurrentWebSocketSessionDecorator}.  * @see org.springframework.web.socket.handler.ConcurrentWebSocketSessionDecorator  */ void sendMessage(WebSocketMessage<?> message) throws IOException.
true;;0;1;/**  * Return whether the connection is still open.  */ ;/**  * Return whether the connection is still open.  */ boolean isOpen().
true;;0;2;/**  * Close the WebSocket connection with status 1000, i.e. equivalent to:  * <pre class="code">  * session.close(CloseStatus.NORMAL).  * </pre>  */ ;/**  * Close the WebSocket connection with status 1000, i.e. equivalent to:  * <pre class="code">  * session.close(CloseStatus.NORMAL).  * </pre>  */ @Override void close() throws IOException.
true;;1;1;/**  * Close the WebSocket connection with the given close status.  */ ;/**  * Close the WebSocket connection with the given close status.  */ void close(CloseStatus status) throws IOException.
