# id;timestamp;commentText;codeText;commentWords;codeWords
DefaultHandshakeHandler -> protected String selectProtocol(List<String> requestedProtocols, WebSocketHandler webSocketHandler);1386019952;Perform the sub-protocol negotiation based on requested and supported sub-protocols._For the list of supported sub-protocols, this method first checks if the target_WebSocketHandler is a {@link SubProtocolCapable} and then also checks if any_sub-protocols have been explicitly configured with_{@link #setSupportedProtocols(String...)}._@param requestedProtocols the requested sub-protocols_@param webSocketHandler the WebSocketHandler that will be used_@return the selected protocols or {@code null}_@see #determineHandlerSupportedProtocols(org.springframework.web.socket.WebSocketHandler);protected String selectProtocol(List<String> requestedProtocols, WebSocketHandler webSocketHandler) {_		if (requestedProtocols != null) {_			List<String> handlerProtocols = determineHandlerSupportedProtocols(webSocketHandler)__			if (logger.isDebugEnabled()) {_				logger.debug("Requested sub-protocol(s): " + requestedProtocols +_						", WebSocketHandler supported sub-protocol(s): " + handlerProtocols +_						", configured sub-protocol(s): " + this.supportedProtocols)__			}_			for (String protocol : requestedProtocols) {_				if (handlerProtocols.contains(protocol.toLowerCase())) {_					return protocol__				}_				if (this.supportedProtocols.contains(protocol.toLowerCase())) {_					return protocol__				}_			}_		}_		return null__	};perform,the,sub,protocol,negotiation,based,on,requested,and,supported,sub,protocols,for,the,list,of,supported,sub,protocols,this,method,first,checks,if,the,target,web,socket,handler,is,a,link,sub,protocol,capable,and,then,also,checks,if,any,sub,protocols,have,been,explicitly,configured,with,link,set,supported,protocols,string,param,requested,protocols,the,requested,sub,protocols,param,web,socket,handler,the,web,socket,handler,that,will,be,used,return,the,selected,protocols,or,code,null,see,determine,handler,supported,protocols,org,springframework,web,socket,web,socket,handler;protected,string,select,protocol,list,string,requested,protocols,web,socket,handler,web,socket,handler,if,requested,protocols,null,list,string,handler,protocols,determine,handler,supported,protocols,web,socket,handler,if,logger,is,debug,enabled,logger,debug,requested,sub,protocol,s,requested,protocols,web,socket,handler,supported,sub,protocol,s,handler,protocols,configured,sub,protocol,s,this,supported,protocols,for,string,protocol,requested,protocols,if,handler,protocols,contains,protocol,to,lower,case,return,protocol,if,this,supported,protocols,contains,protocol,to,lower,case,return,protocol,return,null
DefaultHandshakeHandler -> protected String selectProtocol(List<String> requestedProtocols, WebSocketHandler webSocketHandler);1386021191;Perform the sub-protocol negotiation based on requested and supported sub-protocols._For the list of supported sub-protocols, this method first checks if the target_WebSocketHandler is a {@link SubProtocolCapable} and then also checks if any_sub-protocols have been explicitly configured with_{@link #setSupportedProtocols(String...)}._@param requestedProtocols the requested sub-protocols_@param webSocketHandler the WebSocketHandler that will be used_@return the selected protocols or {@code null}_@see #determineHandlerSupportedProtocols(org.springframework.web.socket.WebSocketHandler);protected String selectProtocol(List<String> requestedProtocols, WebSocketHandler webSocketHandler) {_		if (requestedProtocols != null) {_			List<String> handlerProtocols = determineHandlerSupportedProtocols(webSocketHandler)__			if (logger.isDebugEnabled()) {_				logger.debug("Requested sub-protocol(s): " + requestedProtocols +_						", WebSocketHandler supported sub-protocol(s): " + handlerProtocols +_						", configured sub-protocol(s): " + this.supportedProtocols)__			}_			for (String protocol : requestedProtocols) {_				if (handlerProtocols.contains(protocol.toLowerCase())) {_					return protocol__				}_				if (this.supportedProtocols.contains(protocol.toLowerCase())) {_					return protocol__				}_			}_		}_		return null__	};perform,the,sub,protocol,negotiation,based,on,requested,and,supported,sub,protocols,for,the,list,of,supported,sub,protocols,this,method,first,checks,if,the,target,web,socket,handler,is,a,link,sub,protocol,capable,and,then,also,checks,if,any,sub,protocols,have,been,explicitly,configured,with,link,set,supported,protocols,string,param,requested,protocols,the,requested,sub,protocols,param,web,socket,handler,the,web,socket,handler,that,will,be,used,return,the,selected,protocols,or,code,null,see,determine,handler,supported,protocols,org,springframework,web,socket,web,socket,handler;protected,string,select,protocol,list,string,requested,protocols,web,socket,handler,web,socket,handler,if,requested,protocols,null,list,string,handler,protocols,determine,handler,supported,protocols,web,socket,handler,if,logger,is,debug,enabled,logger,debug,requested,sub,protocol,s,requested,protocols,web,socket,handler,supported,sub,protocol,s,handler,protocols,configured,sub,protocol,s,this,supported,protocols,for,string,protocol,requested,protocols,if,handler,protocols,contains,protocol,to,lower,case,return,protocol,if,this,supported,protocols,contains,protocol,to,lower,case,return,protocol,return,null
DefaultHandshakeHandler -> protected String selectProtocol(List<String> requestedProtocols, WebSocketHandler webSocketHandler);1386087504;Perform the sub-protocol negotiation based on requested and supported sub-protocols._For the list of supported sub-protocols, this method first checks if the target_WebSocketHandler is a {@link SubProtocolCapable} and then also checks if any_sub-protocols have been explicitly configured with_{@link #setSupportedProtocols(String...)}._@param requestedProtocols the requested sub-protocols_@param webSocketHandler the WebSocketHandler that will be used_@return the selected protocols or {@code null}_@see #determineHandlerSupportedProtocols(org.springframework.web.socket.WebSocketHandler);protected String selectProtocol(List<String> requestedProtocols, WebSocketHandler webSocketHandler) {_		if (requestedProtocols != null) {_			List<String> handlerProtocols = determineHandlerSupportedProtocols(webSocketHandler)__			if (logger.isDebugEnabled()) {_				logger.debug("Requested sub-protocol(s): " + requestedProtocols +_						", WebSocketHandler supported sub-protocol(s): " + handlerProtocols +_						", configured sub-protocol(s): " + this.supportedProtocols)__			}_			for (String protocol : requestedProtocols) {_				if (handlerProtocols.contains(protocol.toLowerCase())) {_					return protocol__				}_				if (this.supportedProtocols.contains(protocol.toLowerCase())) {_					return protocol__				}_			}_		}_		return null__	};perform,the,sub,protocol,negotiation,based,on,requested,and,supported,sub,protocols,for,the,list,of,supported,sub,protocols,this,method,first,checks,if,the,target,web,socket,handler,is,a,link,sub,protocol,capable,and,then,also,checks,if,any,sub,protocols,have,been,explicitly,configured,with,link,set,supported,protocols,string,param,requested,protocols,the,requested,sub,protocols,param,web,socket,handler,the,web,socket,handler,that,will,be,used,return,the,selected,protocols,or,code,null,see,determine,handler,supported,protocols,org,springframework,web,socket,web,socket,handler;protected,string,select,protocol,list,string,requested,protocols,web,socket,handler,web,socket,handler,if,requested,protocols,null,list,string,handler,protocols,determine,handler,supported,protocols,web,socket,handler,if,logger,is,debug,enabled,logger,debug,requested,sub,protocol,s,requested,protocols,web,socket,handler,supported,sub,protocol,s,handler,protocols,configured,sub,protocol,s,this,supported,protocols,for,string,protocol,requested,protocols,if,handler,protocols,contains,protocol,to,lower,case,return,protocol,if,this,supported,protocols,contains,protocol,to,lower,case,return,protocol,return,null
DefaultHandshakeHandler -> protected String selectProtocol(List<String> requestedProtocols, WebSocketHandler webSocketHandler);1386197885;Perform the sub-protocol negotiation based on requested and supported sub-protocols._For the list of supported sub-protocols, this method first checks if the target_WebSocketHandler is a {@link SubProtocolCapable} and then also checks if any_sub-protocols have been explicitly configured with_{@link #setSupportedProtocols(String...)}._@param requestedProtocols the requested sub-protocols_@param webSocketHandler the WebSocketHandler that will be used_@return the selected protocols or {@code null}_@see #determineHandlerSupportedProtocols(org.springframework.web.socket.WebSocketHandler);protected String selectProtocol(List<String> requestedProtocols, WebSocketHandler webSocketHandler) {_		if (requestedProtocols != null) {_			List<String> handlerProtocols = determineHandlerSupportedProtocols(webSocketHandler)__			if (logger.isDebugEnabled()) {_				logger.debug("Requested sub-protocol(s): " + requestedProtocols +_						", WebSocketHandler supported sub-protocol(s): " + handlerProtocols +_						", configured sub-protocol(s): " + this.supportedProtocols)__			}_			for (String protocol : requestedProtocols) {_				if (handlerProtocols.contains(protocol.toLowerCase())) {_					return protocol__				}_				if (this.supportedProtocols.contains(protocol.toLowerCase())) {_					return protocol__				}_			}_		}_		return null__	};perform,the,sub,protocol,negotiation,based,on,requested,and,supported,sub,protocols,for,the,list,of,supported,sub,protocols,this,method,first,checks,if,the,target,web,socket,handler,is,a,link,sub,protocol,capable,and,then,also,checks,if,any,sub,protocols,have,been,explicitly,configured,with,link,set,supported,protocols,string,param,requested,protocols,the,requested,sub,protocols,param,web,socket,handler,the,web,socket,handler,that,will,be,used,return,the,selected,protocols,or,code,null,see,determine,handler,supported,protocols,org,springframework,web,socket,web,socket,handler;protected,string,select,protocol,list,string,requested,protocols,web,socket,handler,web,socket,handler,if,requested,protocols,null,list,string,handler,protocols,determine,handler,supported,protocols,web,socket,handler,if,logger,is,debug,enabled,logger,debug,requested,sub,protocol,s,requested,protocols,web,socket,handler,supported,sub,protocol,s,handler,protocols,configured,sub,protocol,s,this,supported,protocols,for,string,protocol,requested,protocols,if,handler,protocols,contains,protocol,to,lower,case,return,protocol,if,this,supported,protocols,contains,protocol,to,lower,case,return,protocol,return,null
DefaultHandshakeHandler -> protected String selectProtocol(List<String> requestedProtocols, WebSocketHandler webSocketHandler);1389649177;Perform the sub-protocol negotiation based on requested and supported sub-protocols._For the list of supported sub-protocols, this method first checks if the target_WebSocketHandler is a {@link SubProtocolCapable} and then also checks if any_sub-protocols have been explicitly configured with_{@link #setSupportedProtocols(String...)}._@param requestedProtocols the requested sub-protocols_@param webSocketHandler the WebSocketHandler that will be used_@return the selected protocols or {@code null}_@see #determineHandlerSupportedProtocols(org.springframework.web.socket.WebSocketHandler);protected String selectProtocol(List<String> requestedProtocols, WebSocketHandler webSocketHandler) {_		if (requestedProtocols != null) {_			List<String> handlerProtocols = determineHandlerSupportedProtocols(webSocketHandler)__			if (logger.isDebugEnabled()) {_				logger.debug("Requested sub-protocol(s): " + requestedProtocols +_						", WebSocketHandler supported sub-protocol(s): " + handlerProtocols +_						", configured sub-protocol(s): " + this.supportedProtocols)__			}_			for (String protocol : requestedProtocols) {_				if (handlerProtocols.contains(protocol.toLowerCase())) {_					return protocol__				}_				if (this.supportedProtocols.contains(protocol.toLowerCase())) {_					return protocol__				}_			}_		}_		return null__	};perform,the,sub,protocol,negotiation,based,on,requested,and,supported,sub,protocols,for,the,list,of,supported,sub,protocols,this,method,first,checks,if,the,target,web,socket,handler,is,a,link,sub,protocol,capable,and,then,also,checks,if,any,sub,protocols,have,been,explicitly,configured,with,link,set,supported,protocols,string,param,requested,protocols,the,requested,sub,protocols,param,web,socket,handler,the,web,socket,handler,that,will,be,used,return,the,selected,protocols,or,code,null,see,determine,handler,supported,protocols,org,springframework,web,socket,web,socket,handler;protected,string,select,protocol,list,string,requested,protocols,web,socket,handler,web,socket,handler,if,requested,protocols,null,list,string,handler,protocols,determine,handler,supported,protocols,web,socket,handler,if,logger,is,debug,enabled,logger,debug,requested,sub,protocol,s,requested,protocols,web,socket,handler,supported,sub,protocol,s,handler,protocols,configured,sub,protocol,s,this,supported,protocols,for,string,protocol,requested,protocols,if,handler,protocols,contains,protocol,to,lower,case,return,protocol,if,this,supported,protocols,contains,protocol,to,lower,case,return,protocol,return,null
DefaultHandshakeHandler -> protected String selectProtocol(List<String> requestedProtocols, WebSocketHandler webSocketHandler);1389735918;Perform the sub-protocol negotiation based on requested and supported sub-protocols._For the list of supported sub-protocols, this method first checks if the target_WebSocketHandler is a {@link SubProtocolCapable} and then also checks if any_sub-protocols have been explicitly configured with_{@link #setSupportedProtocols(String...)}._@param requestedProtocols the requested sub-protocols_@param webSocketHandler the WebSocketHandler that will be used_@return the selected protocols or {@code null}_@see #determineHandlerSupportedProtocols(org.springframework.web.socket.WebSocketHandler);protected String selectProtocol(List<String> requestedProtocols, WebSocketHandler webSocketHandler) {_		if (requestedProtocols != null) {_			List<String> handlerProtocols = determineHandlerSupportedProtocols(webSocketHandler)__			if (logger.isDebugEnabled()) {_				logger.debug("Requested sub-protocol(s): " + requestedProtocols +_						", WebSocketHandler supported sub-protocol(s): " + handlerProtocols +_						", configured sub-protocol(s): " + this.supportedProtocols)__			}_			for (String protocol : requestedProtocols) {_				if (handlerProtocols.contains(protocol.toLowerCase())) {_					return protocol__				}_				if (this.supportedProtocols.contains(protocol.toLowerCase())) {_					return protocol__				}_			}_		}_		return null__	};perform,the,sub,protocol,negotiation,based,on,requested,and,supported,sub,protocols,for,the,list,of,supported,sub,protocols,this,method,first,checks,if,the,target,web,socket,handler,is,a,link,sub,protocol,capable,and,then,also,checks,if,any,sub,protocols,have,been,explicitly,configured,with,link,set,supported,protocols,string,param,requested,protocols,the,requested,sub,protocols,param,web,socket,handler,the,web,socket,handler,that,will,be,used,return,the,selected,protocols,or,code,null,see,determine,handler,supported,protocols,org,springframework,web,socket,web,socket,handler;protected,string,select,protocol,list,string,requested,protocols,web,socket,handler,web,socket,handler,if,requested,protocols,null,list,string,handler,protocols,determine,handler,supported,protocols,web,socket,handler,if,logger,is,debug,enabled,logger,debug,requested,sub,protocol,s,requested,protocols,web,socket,handler,supported,sub,protocol,s,handler,protocols,configured,sub,protocol,s,this,supported,protocols,for,string,protocol,requested,protocols,if,handler,protocols,contains,protocol,to,lower,case,return,protocol,if,this,supported,protocols,contains,protocol,to,lower,case,return,protocol,return,null
DefaultHandshakeHandler -> protected String selectProtocol(List<String> requestedProtocols, WebSocketHandler webSocketHandler);1395555177;Perform the sub-protocol negotiation based on requested and supported sub-protocols._For the list of supported sub-protocols, this method first checks if the target_WebSocketHandler is a {@link SubProtocolCapable} and then also checks if any_sub-protocols have been explicitly configured with_{@link #setSupportedProtocols(String...)}._@param requestedProtocols the requested sub-protocols_@param webSocketHandler the WebSocketHandler that will be used_@return the selected protocols or {@code null}_@see #determineHandlerSupportedProtocols(org.springframework.web.socket.WebSocketHandler);protected String selectProtocol(List<String> requestedProtocols, WebSocketHandler webSocketHandler) {_		if (requestedProtocols != null) {_			List<String> handlerProtocols = determineHandlerSupportedProtocols(webSocketHandler)__			if (logger.isDebugEnabled()) {_				logger.debug("Requested sub-protocol(s): " + requestedProtocols +_						", WebSocketHandler supported sub-protocol(s): " + handlerProtocols +_						", configured sub-protocol(s): " + this.supportedProtocols)__			}_			for (String protocol : requestedProtocols) {_				if (handlerProtocols.contains(protocol.toLowerCase())) {_					return protocol__				}_				if (this.supportedProtocols.contains(protocol.toLowerCase())) {_					return protocol__				}_			}_		}_		return null__	};perform,the,sub,protocol,negotiation,based,on,requested,and,supported,sub,protocols,for,the,list,of,supported,sub,protocols,this,method,first,checks,if,the,target,web,socket,handler,is,a,link,sub,protocol,capable,and,then,also,checks,if,any,sub,protocols,have,been,explicitly,configured,with,link,set,supported,protocols,string,param,requested,protocols,the,requested,sub,protocols,param,web,socket,handler,the,web,socket,handler,that,will,be,used,return,the,selected,protocols,or,code,null,see,determine,handler,supported,protocols,org,springframework,web,socket,web,socket,handler;protected,string,select,protocol,list,string,requested,protocols,web,socket,handler,web,socket,handler,if,requested,protocols,null,list,string,handler,protocols,determine,handler,supported,protocols,web,socket,handler,if,logger,is,debug,enabled,logger,debug,requested,sub,protocol,s,requested,protocols,web,socket,handler,supported,sub,protocol,s,handler,protocols,configured,sub,protocol,s,this,supported,protocols,for,string,protocol,requested,protocols,if,handler,protocols,contains,protocol,to,lower,case,return,protocol,if,this,supported,protocols,contains,protocol,to,lower,case,return,protocol,return,null
DefaultHandshakeHandler -> protected String selectProtocol(List<String> requestedProtocols, WebSocketHandler webSocketHandler);1404880799;Perform the sub-protocol negotiation based on requested and supported sub-protocols._For the list of supported sub-protocols, this method first checks if the target_WebSocketHandler is a {@link SubProtocolCapable} and then also checks if any_sub-protocols have been explicitly configured with_{@link #setSupportedProtocols(String...)}._@param requestedProtocols the requested sub-protocols_@param webSocketHandler the WebSocketHandler that will be used_@return the selected protocols or {@code null}_@see #determineHandlerSupportedProtocols(org.springframework.web.socket.WebSocketHandler);protected String selectProtocol(List<String> requestedProtocols, WebSocketHandler webSocketHandler) {_		if (requestedProtocols != null) {_			List<String> handlerProtocols = determineHandlerSupportedProtocols(webSocketHandler)__			for (String protocol : requestedProtocols) {_				if (handlerProtocols.contains(protocol.toLowerCase())) {_					return protocol__				}_				if (this.supportedProtocols.contains(protocol.toLowerCase())) {_					return protocol__				}_			}_		}_		return null__	};perform,the,sub,protocol,negotiation,based,on,requested,and,supported,sub,protocols,for,the,list,of,supported,sub,protocols,this,method,first,checks,if,the,target,web,socket,handler,is,a,link,sub,protocol,capable,and,then,also,checks,if,any,sub,protocols,have,been,explicitly,configured,with,link,set,supported,protocols,string,param,requested,protocols,the,requested,sub,protocols,param,web,socket,handler,the,web,socket,handler,that,will,be,used,return,the,selected,protocols,or,code,null,see,determine,handler,supported,protocols,org,springframework,web,socket,web,socket,handler;protected,string,select,protocol,list,string,requested,protocols,web,socket,handler,web,socket,handler,if,requested,protocols,null,list,string,handler,protocols,determine,handler,supported,protocols,web,socket,handler,for,string,protocol,requested,protocols,if,handler,protocols,contains,protocol,to,lower,case,return,protocol,if,this,supported,protocols,contains,protocol,to,lower,case,return,protocol,return,null
DefaultHandshakeHandler -> protected String selectProtocol(List<String> requestedProtocols, WebSocketHandler webSocketHandler);1406210302;Perform the sub-protocol negotiation based on requested and supported sub-protocols._For the list of supported sub-protocols, this method first checks if the target_WebSocketHandler is a {@link SubProtocolCapable} and then also checks if any_sub-protocols have been explicitly configured with_{@link #setSupportedProtocols(String...)}._@param requestedProtocols the requested sub-protocols_@param webSocketHandler the WebSocketHandler that will be used_@return the selected protocols or {@code null}_@see #determineHandlerSupportedProtocols(org.springframework.web.socket.WebSocketHandler);protected String selectProtocol(List<String> requestedProtocols, WebSocketHandler webSocketHandler) {_		if (requestedProtocols != null) {_			List<String> handlerProtocols = determineHandlerSupportedProtocols(webSocketHandler)__			for (String protocol : requestedProtocols) {_				if (handlerProtocols.contains(protocol.toLowerCase())) {_					return protocol__				}_				if (this.supportedProtocols.contains(protocol.toLowerCase())) {_					return protocol__				}_			}_		}_		return null__	};perform,the,sub,protocol,negotiation,based,on,requested,and,supported,sub,protocols,for,the,list,of,supported,sub,protocols,this,method,first,checks,if,the,target,web,socket,handler,is,a,link,sub,protocol,capable,and,then,also,checks,if,any,sub,protocols,have,been,explicitly,configured,with,link,set,supported,protocols,string,param,requested,protocols,the,requested,sub,protocols,param,web,socket,handler,the,web,socket,handler,that,will,be,used,return,the,selected,protocols,or,code,null,see,determine,handler,supported,protocols,org,springframework,web,socket,web,socket,handler;protected,string,select,protocol,list,string,requested,protocols,web,socket,handler,web,socket,handler,if,requested,protocols,null,list,string,handler,protocols,determine,handler,supported,protocols,web,socket,handler,for,string,protocol,requested,protocols,if,handler,protocols,contains,protocol,to,lower,case,return,protocol,if,this,supported,protocols,contains,protocol,to,lower,case,return,protocol,return,null
DefaultHandshakeHandler -> protected String selectProtocol(List<String> requestedProtocols, WebSocketHandler webSocketHandler);1406322960;Perform the sub-protocol negotiation based on requested and supported sub-protocols._For the list of supported sub-protocols, this method first checks if the target_WebSocketHandler is a {@link SubProtocolCapable} and then also checks if any_sub-protocols have been explicitly configured with_{@link #setSupportedProtocols(String...)}._@param requestedProtocols the requested sub-protocols_@param webSocketHandler the WebSocketHandler that will be used_@return the selected protocols or {@code null}_@see #determineHandlerSupportedProtocols(org.springframework.web.socket.WebSocketHandler);protected String selectProtocol(List<String> requestedProtocols, WebSocketHandler webSocketHandler) {_		if (requestedProtocols != null) {_			List<String> handlerProtocols = determineHandlerSupportedProtocols(webSocketHandler)__			for (String protocol : requestedProtocols) {_				if (handlerProtocols.contains(protocol.toLowerCase())) {_					return protocol__				}_				if (this.supportedProtocols.contains(protocol.toLowerCase())) {_					return protocol__				}_			}_		}_		return null__	};perform,the,sub,protocol,negotiation,based,on,requested,and,supported,sub,protocols,for,the,list,of,supported,sub,protocols,this,method,first,checks,if,the,target,web,socket,handler,is,a,link,sub,protocol,capable,and,then,also,checks,if,any,sub,protocols,have,been,explicitly,configured,with,link,set,supported,protocols,string,param,requested,protocols,the,requested,sub,protocols,param,web,socket,handler,the,web,socket,handler,that,will,be,used,return,the,selected,protocols,or,code,null,see,determine,handler,supported,protocols,org,springframework,web,socket,web,socket,handler;protected,string,select,protocol,list,string,requested,protocols,web,socket,handler,web,socket,handler,if,requested,protocols,null,list,string,handler,protocols,determine,handler,supported,protocols,web,socket,handler,for,string,protocol,requested,protocols,if,handler,protocols,contains,protocol,to,lower,case,return,protocol,if,this,supported,protocols,contains,protocol,to,lower,case,return,protocol,return,null
DefaultHandshakeHandler -> protected String selectProtocol(List<String> requestedProtocols, WebSocketHandler webSocketHandler);1413840766;Perform the sub-protocol negotiation based on requested and supported sub-protocols._For the list of supported sub-protocols, this method first checks if the target_WebSocketHandler is a {@link SubProtocolCapable} and then also checks if any_sub-protocols have been explicitly configured with_{@link #setSupportedProtocols(String...)}._@param requestedProtocols the requested sub-protocols_@param webSocketHandler the WebSocketHandler that will be used_@return the selected protocols or {@code null}_@see #determineHandlerSupportedProtocols(org.springframework.web.socket.WebSocketHandler);protected String selectProtocol(List<String> requestedProtocols, WebSocketHandler webSocketHandler) {_		if (requestedProtocols != null) {_			List<String> handlerProtocols = determineHandlerSupportedProtocols(webSocketHandler)__			for (String protocol : requestedProtocols) {_				if (handlerProtocols.contains(protocol.toLowerCase())) {_					return protocol__				}_				if (this.supportedProtocols.contains(protocol.toLowerCase())) {_					return protocol__				}_			}_		}_		return null__	};perform,the,sub,protocol,negotiation,based,on,requested,and,supported,sub,protocols,for,the,list,of,supported,sub,protocols,this,method,first,checks,if,the,target,web,socket,handler,is,a,link,sub,protocol,capable,and,then,also,checks,if,any,sub,protocols,have,been,explicitly,configured,with,link,set,supported,protocols,string,param,requested,protocols,the,requested,sub,protocols,param,web,socket,handler,the,web,socket,handler,that,will,be,used,return,the,selected,protocols,or,code,null,see,determine,handler,supported,protocols,org,springframework,web,socket,web,socket,handler;protected,string,select,protocol,list,string,requested,protocols,web,socket,handler,web,socket,handler,if,requested,protocols,null,list,string,handler,protocols,determine,handler,supported,protocols,web,socket,handler,for,string,protocol,requested,protocols,if,handler,protocols,contains,protocol,to,lower,case,return,protocol,if,this,supported,protocols,contains,protocol,to,lower,case,return,protocol,return,null
DefaultHandshakeHandler -> protected String selectProtocol(List<String> requestedProtocols, WebSocketHandler webSocketHandler);1414354684;Perform the sub-protocol negotiation based on requested and supported sub-protocols._For the list of supported sub-protocols, this method first checks if the target_WebSocketHandler is a {@link SubProtocolCapable} and then also checks if any_sub-protocols have been explicitly configured with_{@link #setSupportedProtocols(String...)}._@param requestedProtocols the requested sub-protocols_@param webSocketHandler the WebSocketHandler that will be used_@return the selected protocols or {@code null}_@see #determineHandlerSupportedProtocols(org.springframework.web.socket.WebSocketHandler);protected String selectProtocol(List<String> requestedProtocols, WebSocketHandler webSocketHandler) {_		if (requestedProtocols != null) {_			List<String> handlerProtocols = determineHandlerSupportedProtocols(webSocketHandler)__			for (String protocol : requestedProtocols) {_				if (handlerProtocols.contains(protocol.toLowerCase())) {_					return protocol__				}_				if (this.supportedProtocols.contains(protocol.toLowerCase())) {_					return protocol__				}_			}_		}_		return null__	};perform,the,sub,protocol,negotiation,based,on,requested,and,supported,sub,protocols,for,the,list,of,supported,sub,protocols,this,method,first,checks,if,the,target,web,socket,handler,is,a,link,sub,protocol,capable,and,then,also,checks,if,any,sub,protocols,have,been,explicitly,configured,with,link,set,supported,protocols,string,param,requested,protocols,the,requested,sub,protocols,param,web,socket,handler,the,web,socket,handler,that,will,be,used,return,the,selected,protocols,or,code,null,see,determine,handler,supported,protocols,org,springframework,web,socket,web,socket,handler;protected,string,select,protocol,list,string,requested,protocols,web,socket,handler,web,socket,handler,if,requested,protocols,null,list,string,handler,protocols,determine,handler,supported,protocols,web,socket,handler,for,string,protocol,requested,protocols,if,handler,protocols,contains,protocol,to,lower,case,return,protocol,if,this,supported,protocols,contains,protocol,to,lower,case,return,protocol,return,null
DefaultHandshakeHandler -> protected String selectProtocol(List<String> requestedProtocols, WebSocketHandler webSocketHandler);1415669910;Perform the sub-protocol negotiation based on requested and supported sub-protocols._For the list of supported sub-protocols, this method first checks if the target_WebSocketHandler is a {@link SubProtocolCapable} and then also checks if any_sub-protocols have been explicitly configured with_{@link #setSupportedProtocols(String...)}._@param requestedProtocols the requested sub-protocols_@param webSocketHandler the WebSocketHandler that will be used_@return the selected protocols or {@code null}_@see #determineHandlerSupportedProtocols(org.springframework.web.socket.WebSocketHandler);protected String selectProtocol(List<String> requestedProtocols, WebSocketHandler webSocketHandler) {_		if (requestedProtocols != null) {_			List<String> handlerProtocols = determineHandlerSupportedProtocols(webSocketHandler)__			for (String protocol : requestedProtocols) {_				if (handlerProtocols.contains(protocol.toLowerCase())) {_					return protocol__				}_				if (this.supportedProtocols.contains(protocol.toLowerCase())) {_					return protocol__				}_			}_		}_		return null__	};perform,the,sub,protocol,negotiation,based,on,requested,and,supported,sub,protocols,for,the,list,of,supported,sub,protocols,this,method,first,checks,if,the,target,web,socket,handler,is,a,link,sub,protocol,capable,and,then,also,checks,if,any,sub,protocols,have,been,explicitly,configured,with,link,set,supported,protocols,string,param,requested,protocols,the,requested,sub,protocols,param,web,socket,handler,the,web,socket,handler,that,will,be,used,return,the,selected,protocols,or,code,null,see,determine,handler,supported,protocols,org,springframework,web,socket,web,socket,handler;protected,string,select,protocol,list,string,requested,protocols,web,socket,handler,web,socket,handler,if,requested,protocols,null,list,string,handler,protocols,determine,handler,supported,protocols,web,socket,handler,for,string,protocol,requested,protocols,if,handler,protocols,contains,protocol,to,lower,case,return,protocol,if,this,supported,protocols,contains,protocol,to,lower,case,return,protocol,return,null
DefaultHandshakeHandler -> protected String selectProtocol(List<String> requestedProtocols, WebSocketHandler webSocketHandler);1435026644;Perform the sub-protocol negotiation based on requested and supported sub-protocols._For the list of supported sub-protocols, this method first checks if the target_WebSocketHandler is a {@link SubProtocolCapable} and then also checks if any_sub-protocols have been explicitly configured with_{@link #setSupportedProtocols(String...)}._@param requestedProtocols the requested sub-protocols_@param webSocketHandler the WebSocketHandler that will be used_@return the selected protocols or {@code null}_@see #determineHandlerSupportedProtocols(org.springframework.web.socket.WebSocketHandler);protected String selectProtocol(List<String> requestedProtocols, WebSocketHandler webSocketHandler) {_		if (requestedProtocols != null) {_			List<String> handlerProtocols = determineHandlerSupportedProtocols(webSocketHandler)__			for (String protocol : requestedProtocols) {_				if (handlerProtocols.contains(protocol.toLowerCase())) {_					return protocol__				}_				if (this.supportedProtocols.contains(protocol.toLowerCase())) {_					return protocol__				}_			}_		}_		return null__	};perform,the,sub,protocol,negotiation,based,on,requested,and,supported,sub,protocols,for,the,list,of,supported,sub,protocols,this,method,first,checks,if,the,target,web,socket,handler,is,a,link,sub,protocol,capable,and,then,also,checks,if,any,sub,protocols,have,been,explicitly,configured,with,link,set,supported,protocols,string,param,requested,protocols,the,requested,sub,protocols,param,web,socket,handler,the,web,socket,handler,that,will,be,used,return,the,selected,protocols,or,code,null,see,determine,handler,supported,protocols,org,springframework,web,socket,web,socket,handler;protected,string,select,protocol,list,string,requested,protocols,web,socket,handler,web,socket,handler,if,requested,protocols,null,list,string,handler,protocols,determine,handler,supported,protocols,web,socket,handler,for,string,protocol,requested,protocols,if,handler,protocols,contains,protocol,to,lower,case,return,protocol,if,this,supported,protocols,contains,protocol,to,lower,case,return,protocol,return,null
DefaultHandshakeHandler -> public void setSupportedProtocols(String... protocols);1386019952;Use this property to configure the list of supported sub-protocols._The first configured sub-protocol that matches a client-requested sub-protocol_is accepted. If there are no matches the response will not contain a_{@literal Sec-WebSocket-Protocol} header._<p>Note that if the WebSocketHandler passed in at runtime is an instance of_{@link SubProtocolCapable} then there is not need to explicitly configure_this property. That is certainly the case with the built-in STOMP over_WebSocket support. Therefore this property should be configured explicitly_only if the WebSocketHandler does not implement {@code SubProtocolCapable}.;public void setSupportedProtocols(String... protocols) {_		this.supportedProtocols.clear()__		for (String protocol : protocols) {_			this.supportedProtocols.add(protocol.toLowerCase())__		}_	};use,this,property,to,configure,the,list,of,supported,sub,protocols,the,first,configured,sub,protocol,that,matches,a,client,requested,sub,protocol,is,accepted,if,there,are,no,matches,the,response,will,not,contain,a,literal,sec,web,socket,protocol,header,p,note,that,if,the,web,socket,handler,passed,in,at,runtime,is,an,instance,of,link,sub,protocol,capable,then,there,is,not,need,to,explicitly,configure,this,property,that,is,certainly,the,case,with,the,built,in,stomp,over,web,socket,support,therefore,this,property,should,be,configured,explicitly,only,if,the,web,socket,handler,does,not,implement,code,sub,protocol,capable;public,void,set,supported,protocols,string,protocols,this,supported,protocols,clear,for,string,protocol,protocols,this,supported,protocols,add,protocol,to,lower,case
DefaultHandshakeHandler -> public void setSupportedProtocols(String... protocols);1386021191;Use this property to configure the list of supported sub-protocols._The first configured sub-protocol that matches a client-requested sub-protocol_is accepted. If there are no matches the response will not contain a_{@literal Sec-WebSocket-Protocol} header._<p>Note that if the WebSocketHandler passed in at runtime is an instance of_{@link SubProtocolCapable} then there is not need to explicitly configure_this property. That is certainly the case with the built-in STOMP over_WebSocket support. Therefore this property should be configured explicitly_only if the WebSocketHandler does not implement {@code SubProtocolCapable}.;public void setSupportedProtocols(String... protocols) {_		this.supportedProtocols.clear()__		for (String protocol : protocols) {_			this.supportedProtocols.add(protocol.toLowerCase())__		}_	};use,this,property,to,configure,the,list,of,supported,sub,protocols,the,first,configured,sub,protocol,that,matches,a,client,requested,sub,protocol,is,accepted,if,there,are,no,matches,the,response,will,not,contain,a,literal,sec,web,socket,protocol,header,p,note,that,if,the,web,socket,handler,passed,in,at,runtime,is,an,instance,of,link,sub,protocol,capable,then,there,is,not,need,to,explicitly,configure,this,property,that,is,certainly,the,case,with,the,built,in,stomp,over,web,socket,support,therefore,this,property,should,be,configured,explicitly,only,if,the,web,socket,handler,does,not,implement,code,sub,protocol,capable;public,void,set,supported,protocols,string,protocols,this,supported,protocols,clear,for,string,protocol,protocols,this,supported,protocols,add,protocol,to,lower,case
DefaultHandshakeHandler -> public void setSupportedProtocols(String... protocols);1386087504;Use this property to configure the list of supported sub-protocols._The first configured sub-protocol that matches a client-requested sub-protocol_is accepted. If there are no matches the response will not contain a_{@literal Sec-WebSocket-Protocol} header._<p>Note that if the WebSocketHandler passed in at runtime is an instance of_{@link SubProtocolCapable} then there is not need to explicitly configure_this property. That is certainly the case with the built-in STOMP over_WebSocket support. Therefore this property should be configured explicitly_only if the WebSocketHandler does not implement {@code SubProtocolCapable}.;public void setSupportedProtocols(String... protocols) {_		this.supportedProtocols.clear()__		for (String protocol : protocols) {_			this.supportedProtocols.add(protocol.toLowerCase())__		}_	};use,this,property,to,configure,the,list,of,supported,sub,protocols,the,first,configured,sub,protocol,that,matches,a,client,requested,sub,protocol,is,accepted,if,there,are,no,matches,the,response,will,not,contain,a,literal,sec,web,socket,protocol,header,p,note,that,if,the,web,socket,handler,passed,in,at,runtime,is,an,instance,of,link,sub,protocol,capable,then,there,is,not,need,to,explicitly,configure,this,property,that,is,certainly,the,case,with,the,built,in,stomp,over,web,socket,support,therefore,this,property,should,be,configured,explicitly,only,if,the,web,socket,handler,does,not,implement,code,sub,protocol,capable;public,void,set,supported,protocols,string,protocols,this,supported,protocols,clear,for,string,protocol,protocols,this,supported,protocols,add,protocol,to,lower,case
DefaultHandshakeHandler -> public void setSupportedProtocols(String... protocols);1386197885;Use this property to configure the list of supported sub-protocols._The first configured sub-protocol that matches a client-requested sub-protocol_is accepted. If there are no matches the response will not contain a_{@literal Sec-WebSocket-Protocol} header._<p>Note that if the WebSocketHandler passed in at runtime is an instance of_{@link SubProtocolCapable} then there is not need to explicitly configure_this property. That is certainly the case with the built-in STOMP over_WebSocket support. Therefore this property should be configured explicitly_only if the WebSocketHandler does not implement {@code SubProtocolCapable}.;public void setSupportedProtocols(String... protocols) {_		this.supportedProtocols.clear()__		for (String protocol : protocols) {_			this.supportedProtocols.add(protocol.toLowerCase())__		}_	};use,this,property,to,configure,the,list,of,supported,sub,protocols,the,first,configured,sub,protocol,that,matches,a,client,requested,sub,protocol,is,accepted,if,there,are,no,matches,the,response,will,not,contain,a,literal,sec,web,socket,protocol,header,p,note,that,if,the,web,socket,handler,passed,in,at,runtime,is,an,instance,of,link,sub,protocol,capable,then,there,is,not,need,to,explicitly,configure,this,property,that,is,certainly,the,case,with,the,built,in,stomp,over,web,socket,support,therefore,this,property,should,be,configured,explicitly,only,if,the,web,socket,handler,does,not,implement,code,sub,protocol,capable;public,void,set,supported,protocols,string,protocols,this,supported,protocols,clear,for,string,protocol,protocols,this,supported,protocols,add,protocol,to,lower,case
DefaultHandshakeHandler -> public void setSupportedProtocols(String... protocols);1389649177;Use this property to configure the list of supported sub-protocols._The first configured sub-protocol that matches a client-requested sub-protocol_is accepted. If there are no matches the response will not contain a_{@literal Sec-WebSocket-Protocol} header._<p>Note that if the WebSocketHandler passed in at runtime is an instance of_{@link SubProtocolCapable} then there is not need to explicitly configure_this property. That is certainly the case with the built-in STOMP over_WebSocket support. Therefore this property should be configured explicitly_only if the WebSocketHandler does not implement {@code SubProtocolCapable}.;public void setSupportedProtocols(String... protocols) {_		this.supportedProtocols.clear()__		for (String protocol : protocols) {_			this.supportedProtocols.add(protocol.toLowerCase())__		}_	};use,this,property,to,configure,the,list,of,supported,sub,protocols,the,first,configured,sub,protocol,that,matches,a,client,requested,sub,protocol,is,accepted,if,there,are,no,matches,the,response,will,not,contain,a,literal,sec,web,socket,protocol,header,p,note,that,if,the,web,socket,handler,passed,in,at,runtime,is,an,instance,of,link,sub,protocol,capable,then,there,is,not,need,to,explicitly,configure,this,property,that,is,certainly,the,case,with,the,built,in,stomp,over,web,socket,support,therefore,this,property,should,be,configured,explicitly,only,if,the,web,socket,handler,does,not,implement,code,sub,protocol,capable;public,void,set,supported,protocols,string,protocols,this,supported,protocols,clear,for,string,protocol,protocols,this,supported,protocols,add,protocol,to,lower,case
DefaultHandshakeHandler -> public void setSupportedProtocols(String... protocols);1389735918;Use this property to configure the list of supported sub-protocols._The first configured sub-protocol that matches a client-requested sub-protocol_is accepted. If there are no matches the response will not contain a_{@literal Sec-WebSocket-Protocol} header._<p>Note that if the WebSocketHandler passed in at runtime is an instance of_{@link SubProtocolCapable} then there is not need to explicitly configure_this property. That is certainly the case with the built-in STOMP over_WebSocket support. Therefore this property should be configured explicitly_only if the WebSocketHandler does not implement {@code SubProtocolCapable}.;public void setSupportedProtocols(String... protocols) {_		this.supportedProtocols.clear()__		for (String protocol : protocols) {_			this.supportedProtocols.add(protocol.toLowerCase())__		}_	};use,this,property,to,configure,the,list,of,supported,sub,protocols,the,first,configured,sub,protocol,that,matches,a,client,requested,sub,protocol,is,accepted,if,there,are,no,matches,the,response,will,not,contain,a,literal,sec,web,socket,protocol,header,p,note,that,if,the,web,socket,handler,passed,in,at,runtime,is,an,instance,of,link,sub,protocol,capable,then,there,is,not,need,to,explicitly,configure,this,property,that,is,certainly,the,case,with,the,built,in,stomp,over,web,socket,support,therefore,this,property,should,be,configured,explicitly,only,if,the,web,socket,handler,does,not,implement,code,sub,protocol,capable;public,void,set,supported,protocols,string,protocols,this,supported,protocols,clear,for,string,protocol,protocols,this,supported,protocols,add,protocol,to,lower,case
DefaultHandshakeHandler -> public void setSupportedProtocols(String... protocols);1395555177;Use this property to configure the list of supported sub-protocols._The first configured sub-protocol that matches a client-requested sub-protocol_is accepted. If there are no matches the response will not contain a_{@literal Sec-WebSocket-Protocol} header._<p>Note that if the WebSocketHandler passed in at runtime is an instance of_{@link SubProtocolCapable} then there is not need to explicitly configure_this property. That is certainly the case with the built-in STOMP over_WebSocket support. Therefore this property should be configured explicitly_only if the WebSocketHandler does not implement {@code SubProtocolCapable}.;public void setSupportedProtocols(String... protocols) {_		this.supportedProtocols.clear()__		for (String protocol : protocols) {_			this.supportedProtocols.add(protocol.toLowerCase())__		}_	};use,this,property,to,configure,the,list,of,supported,sub,protocols,the,first,configured,sub,protocol,that,matches,a,client,requested,sub,protocol,is,accepted,if,there,are,no,matches,the,response,will,not,contain,a,literal,sec,web,socket,protocol,header,p,note,that,if,the,web,socket,handler,passed,in,at,runtime,is,an,instance,of,link,sub,protocol,capable,then,there,is,not,need,to,explicitly,configure,this,property,that,is,certainly,the,case,with,the,built,in,stomp,over,web,socket,support,therefore,this,property,should,be,configured,explicitly,only,if,the,web,socket,handler,does,not,implement,code,sub,protocol,capable;public,void,set,supported,protocols,string,protocols,this,supported,protocols,clear,for,string,protocol,protocols,this,supported,protocols,add,protocol,to,lower,case
DefaultHandshakeHandler -> public void setSupportedProtocols(String... protocols);1404880799;Use this property to configure the list of supported sub-protocols._The first configured sub-protocol that matches a client-requested sub-protocol_is accepted. If there are no matches the response will not contain a_{@literal Sec-WebSocket-Protocol} header._<p>Note that if the WebSocketHandler passed in at runtime is an instance of_{@link SubProtocolCapable} then there is not need to explicitly configure_this property. That is certainly the case with the built-in STOMP over_WebSocket support. Therefore this property should be configured explicitly_only if the WebSocketHandler does not implement {@code SubProtocolCapable}.;public void setSupportedProtocols(String... protocols) {_		this.supportedProtocols.clear()__		for (String protocol : protocols) {_			this.supportedProtocols.add(protocol.toLowerCase())__		}_	};use,this,property,to,configure,the,list,of,supported,sub,protocols,the,first,configured,sub,protocol,that,matches,a,client,requested,sub,protocol,is,accepted,if,there,are,no,matches,the,response,will,not,contain,a,literal,sec,web,socket,protocol,header,p,note,that,if,the,web,socket,handler,passed,in,at,runtime,is,an,instance,of,link,sub,protocol,capable,then,there,is,not,need,to,explicitly,configure,this,property,that,is,certainly,the,case,with,the,built,in,stomp,over,web,socket,support,therefore,this,property,should,be,configured,explicitly,only,if,the,web,socket,handler,does,not,implement,code,sub,protocol,capable;public,void,set,supported,protocols,string,protocols,this,supported,protocols,clear,for,string,protocol,protocols,this,supported,protocols,add,protocol,to,lower,case
DefaultHandshakeHandler -> public void setSupportedProtocols(String... protocols);1406210302;Use this property to configure the list of supported sub-protocols._The first configured sub-protocol that matches a client-requested sub-protocol_is accepted. If there are no matches the response will not contain a_{@literal Sec-WebSocket-Protocol} header._<p>Note that if the WebSocketHandler passed in at runtime is an instance of_{@link SubProtocolCapable} then there is not need to explicitly configure_this property. That is certainly the case with the built-in STOMP over_WebSocket support. Therefore this property should be configured explicitly_only if the WebSocketHandler does not implement {@code SubProtocolCapable}.;public void setSupportedProtocols(String... protocols) {_		this.supportedProtocols.clear()__		for (String protocol : protocols) {_			this.supportedProtocols.add(protocol.toLowerCase())__		}_	};use,this,property,to,configure,the,list,of,supported,sub,protocols,the,first,configured,sub,protocol,that,matches,a,client,requested,sub,protocol,is,accepted,if,there,are,no,matches,the,response,will,not,contain,a,literal,sec,web,socket,protocol,header,p,note,that,if,the,web,socket,handler,passed,in,at,runtime,is,an,instance,of,link,sub,protocol,capable,then,there,is,not,need,to,explicitly,configure,this,property,that,is,certainly,the,case,with,the,built,in,stomp,over,web,socket,support,therefore,this,property,should,be,configured,explicitly,only,if,the,web,socket,handler,does,not,implement,code,sub,protocol,capable;public,void,set,supported,protocols,string,protocols,this,supported,protocols,clear,for,string,protocol,protocols,this,supported,protocols,add,protocol,to,lower,case
DefaultHandshakeHandler -> public void setSupportedProtocols(String... protocols);1406322960;Use this property to configure the list of supported sub-protocols._The first configured sub-protocol that matches a client-requested sub-protocol_is accepted. If there are no matches the response will not contain a_{@literal Sec-WebSocket-Protocol} header._<p>Note that if the WebSocketHandler passed in at runtime is an instance of_{@link SubProtocolCapable} then there is not need to explicitly configure_this property. That is certainly the case with the built-in STOMP over_WebSocket support. Therefore this property should be configured explicitly_only if the WebSocketHandler does not implement {@code SubProtocolCapable}.;public void setSupportedProtocols(String... protocols) {_		this.supportedProtocols.clear()__		for (String protocol : protocols) {_			this.supportedProtocols.add(protocol.toLowerCase())__		}_	};use,this,property,to,configure,the,list,of,supported,sub,protocols,the,first,configured,sub,protocol,that,matches,a,client,requested,sub,protocol,is,accepted,if,there,are,no,matches,the,response,will,not,contain,a,literal,sec,web,socket,protocol,header,p,note,that,if,the,web,socket,handler,passed,in,at,runtime,is,an,instance,of,link,sub,protocol,capable,then,there,is,not,need,to,explicitly,configure,this,property,that,is,certainly,the,case,with,the,built,in,stomp,over,web,socket,support,therefore,this,property,should,be,configured,explicitly,only,if,the,web,socket,handler,does,not,implement,code,sub,protocol,capable;public,void,set,supported,protocols,string,protocols,this,supported,protocols,clear,for,string,protocol,protocols,this,supported,protocols,add,protocol,to,lower,case
DefaultHandshakeHandler -> public void setSupportedProtocols(String... protocols);1413840766;Use this property to configure the list of supported sub-protocols._The first configured sub-protocol that matches a client-requested sub-protocol_is accepted. If there are no matches the response will not contain a_{@literal Sec-WebSocket-Protocol} header._<p>Note that if the WebSocketHandler passed in at runtime is an instance of_{@link SubProtocolCapable} then there is not need to explicitly configure_this property. That is certainly the case with the built-in STOMP over_WebSocket support. Therefore this property should be configured explicitly_only if the WebSocketHandler does not implement {@code SubProtocolCapable}.;public void setSupportedProtocols(String... protocols) {_		this.supportedProtocols.clear()__		for (String protocol : protocols) {_			this.supportedProtocols.add(protocol.toLowerCase())__		}_	};use,this,property,to,configure,the,list,of,supported,sub,protocols,the,first,configured,sub,protocol,that,matches,a,client,requested,sub,protocol,is,accepted,if,there,are,no,matches,the,response,will,not,contain,a,literal,sec,web,socket,protocol,header,p,note,that,if,the,web,socket,handler,passed,in,at,runtime,is,an,instance,of,link,sub,protocol,capable,then,there,is,not,need,to,explicitly,configure,this,property,that,is,certainly,the,case,with,the,built,in,stomp,over,web,socket,support,therefore,this,property,should,be,configured,explicitly,only,if,the,web,socket,handler,does,not,implement,code,sub,protocol,capable;public,void,set,supported,protocols,string,protocols,this,supported,protocols,clear,for,string,protocol,protocols,this,supported,protocols,add,protocol,to,lower,case
DefaultHandshakeHandler -> public void setSupportedProtocols(String... protocols);1414354684;Use this property to configure the list of supported sub-protocols._The first configured sub-protocol that matches a client-requested sub-protocol_is accepted. If there are no matches the response will not contain a_{@literal Sec-WebSocket-Protocol} header._<p>Note that if the WebSocketHandler passed in at runtime is an instance of_{@link SubProtocolCapable} then there is not need to explicitly configure_this property. That is certainly the case with the built-in STOMP over_WebSocket support. Therefore this property should be configured explicitly_only if the WebSocketHandler does not implement {@code SubProtocolCapable}.;public void setSupportedProtocols(String... protocols) {_		this.supportedProtocols.clear()__		for (String protocol : protocols) {_			this.supportedProtocols.add(protocol.toLowerCase())__		}_	};use,this,property,to,configure,the,list,of,supported,sub,protocols,the,first,configured,sub,protocol,that,matches,a,client,requested,sub,protocol,is,accepted,if,there,are,no,matches,the,response,will,not,contain,a,literal,sec,web,socket,protocol,header,p,note,that,if,the,web,socket,handler,passed,in,at,runtime,is,an,instance,of,link,sub,protocol,capable,then,there,is,not,need,to,explicitly,configure,this,property,that,is,certainly,the,case,with,the,built,in,stomp,over,web,socket,support,therefore,this,property,should,be,configured,explicitly,only,if,the,web,socket,handler,does,not,implement,code,sub,protocol,capable;public,void,set,supported,protocols,string,protocols,this,supported,protocols,clear,for,string,protocol,protocols,this,supported,protocols,add,protocol,to,lower,case
DefaultHandshakeHandler -> public void setSupportedProtocols(String... protocols);1415669910;Use this property to configure the list of supported sub-protocols._The first configured sub-protocol that matches a client-requested sub-protocol_is accepted. If there are no matches the response will not contain a_{@literal Sec-WebSocket-Protocol} header._<p>Note that if the WebSocketHandler passed in at runtime is an instance of_{@link SubProtocolCapable} then there is not need to explicitly configure_this property. That is certainly the case with the built-in STOMP over_WebSocket support. Therefore this property should be configured explicitly_only if the WebSocketHandler does not implement {@code SubProtocolCapable}.;public void setSupportedProtocols(String... protocols) {_		this.supportedProtocols.clear()__		for (String protocol : protocols) {_			this.supportedProtocols.add(protocol.toLowerCase())__		}_	};use,this,property,to,configure,the,list,of,supported,sub,protocols,the,first,configured,sub,protocol,that,matches,a,client,requested,sub,protocol,is,accepted,if,there,are,no,matches,the,response,will,not,contain,a,literal,sec,web,socket,protocol,header,p,note,that,if,the,web,socket,handler,passed,in,at,runtime,is,an,instance,of,link,sub,protocol,capable,then,there,is,not,need,to,explicitly,configure,this,property,that,is,certainly,the,case,with,the,built,in,stomp,over,web,socket,support,therefore,this,property,should,be,configured,explicitly,only,if,the,web,socket,handler,does,not,implement,code,sub,protocol,capable;public,void,set,supported,protocols,string,protocols,this,supported,protocols,clear,for,string,protocol,protocols,this,supported,protocols,add,protocol,to,lower,case
DefaultHandshakeHandler -> public void setSupportedProtocols(String... protocols);1435026644;Use this property to configure the list of supported sub-protocols._The first configured sub-protocol that matches a client-requested sub-protocol_is accepted. If there are no matches the response will not contain a_{@literal Sec-WebSocket-Protocol} header._<p>Note that if the WebSocketHandler passed in at runtime is an instance of_{@link SubProtocolCapable} then there is not need to explicitly configure_this property. That is certainly the case with the built-in STOMP over_WebSocket support. Therefore this property should be configured explicitly_only if the WebSocketHandler does not implement {@code SubProtocolCapable}.;public void setSupportedProtocols(String... protocols) {_		this.supportedProtocols.clear()__		for (String protocol : protocols) {_			this.supportedProtocols.add(protocol.toLowerCase())__		}_	};use,this,property,to,configure,the,list,of,supported,sub,protocols,the,first,configured,sub,protocol,that,matches,a,client,requested,sub,protocol,is,accepted,if,there,are,no,matches,the,response,will,not,contain,a,literal,sec,web,socket,protocol,header,p,note,that,if,the,web,socket,handler,passed,in,at,runtime,is,an,instance,of,link,sub,protocol,capable,then,there,is,not,need,to,explicitly,configure,this,property,that,is,certainly,the,case,with,the,built,in,stomp,over,web,socket,support,therefore,this,property,should,be,configured,explicitly,only,if,the,web,socket,handler,does,not,implement,code,sub,protocol,capable;public,void,set,supported,protocols,string,protocols,this,supported,protocols,clear,for,string,protocol,protocols,this,supported,protocols,add,protocol,to,lower,case
DefaultHandshakeHandler -> public DefaultHandshakeHandler(RequestUpgradeStrategy requestUpgradeStrategy);1386197885;A constructor that accepts a runtime-specific {@link RequestUpgradeStrategy}._@param requestUpgradeStrategy the upgrade strategy to use;public DefaultHandshakeHandler(RequestUpgradeStrategy requestUpgradeStrategy) {_		Assert.notNull(requestUpgradeStrategy, "RequestUpgradeStrategy must not be null")__		this.requestUpgradeStrategy = requestUpgradeStrategy__	};a,constructor,that,accepts,a,runtime,specific,link,request,upgrade,strategy,param,request,upgrade,strategy,the,upgrade,strategy,to,use;public,default,handshake,handler,request,upgrade,strategy,request,upgrade,strategy,assert,not,null,request,upgrade,strategy,request,upgrade,strategy,must,not,be,null,this,request,upgrade,strategy,request,upgrade,strategy
DefaultHandshakeHandler -> public DefaultHandshakeHandler(RequestUpgradeStrategy requestUpgradeStrategy);1389649177;A constructor that accepts a runtime-specific {@link RequestUpgradeStrategy}._@param requestUpgradeStrategy the upgrade strategy to use;public DefaultHandshakeHandler(RequestUpgradeStrategy requestUpgradeStrategy) {_		Assert.notNull(requestUpgradeStrategy, "RequestUpgradeStrategy must not be null")__		this.requestUpgradeStrategy = requestUpgradeStrategy__	};a,constructor,that,accepts,a,runtime,specific,link,request,upgrade,strategy,param,request,upgrade,strategy,the,upgrade,strategy,to,use;public,default,handshake,handler,request,upgrade,strategy,request,upgrade,strategy,assert,not,null,request,upgrade,strategy,request,upgrade,strategy,must,not,be,null,this,request,upgrade,strategy,request,upgrade,strategy
DefaultHandshakeHandler -> public DefaultHandshakeHandler(RequestUpgradeStrategy requestUpgradeStrategy);1389735918;A constructor that accepts a runtime-specific {@link RequestUpgradeStrategy}._@param requestUpgradeStrategy the upgrade strategy to use;public DefaultHandshakeHandler(RequestUpgradeStrategy requestUpgradeStrategy) {_		Assert.notNull(requestUpgradeStrategy, "RequestUpgradeStrategy must not be null")__		this.requestUpgradeStrategy = requestUpgradeStrategy__	};a,constructor,that,accepts,a,runtime,specific,link,request,upgrade,strategy,param,request,upgrade,strategy,the,upgrade,strategy,to,use;public,default,handshake,handler,request,upgrade,strategy,request,upgrade,strategy,assert,not,null,request,upgrade,strategy,request,upgrade,strategy,must,not,be,null,this,request,upgrade,strategy,request,upgrade,strategy
DefaultHandshakeHandler -> public DefaultHandshakeHandler(RequestUpgradeStrategy requestUpgradeStrategy);1395555177;A constructor that accepts a runtime-specific {@link RequestUpgradeStrategy}._@param requestUpgradeStrategy the upgrade strategy to use;public DefaultHandshakeHandler(RequestUpgradeStrategy requestUpgradeStrategy) {_		Assert.notNull(requestUpgradeStrategy, "RequestUpgradeStrategy must not be null")__		this.requestUpgradeStrategy = requestUpgradeStrategy__	};a,constructor,that,accepts,a,runtime,specific,link,request,upgrade,strategy,param,request,upgrade,strategy,the,upgrade,strategy,to,use;public,default,handshake,handler,request,upgrade,strategy,request,upgrade,strategy,assert,not,null,request,upgrade,strategy,request,upgrade,strategy,must,not,be,null,this,request,upgrade,strategy,request,upgrade,strategy
DefaultHandshakeHandler -> public DefaultHandshakeHandler(RequestUpgradeStrategy requestUpgradeStrategy);1404880799;A constructor that accepts a runtime-specific {@link RequestUpgradeStrategy}._@param requestUpgradeStrategy the upgrade strategy to use;public DefaultHandshakeHandler(RequestUpgradeStrategy requestUpgradeStrategy) {_		Assert.notNull(requestUpgradeStrategy, "RequestUpgradeStrategy must not be null")__		this.requestUpgradeStrategy = requestUpgradeStrategy__	};a,constructor,that,accepts,a,runtime,specific,link,request,upgrade,strategy,param,request,upgrade,strategy,the,upgrade,strategy,to,use;public,default,handshake,handler,request,upgrade,strategy,request,upgrade,strategy,assert,not,null,request,upgrade,strategy,request,upgrade,strategy,must,not,be,null,this,request,upgrade,strategy,request,upgrade,strategy
DefaultHandshakeHandler -> public DefaultHandshakeHandler(RequestUpgradeStrategy requestUpgradeStrategy);1406210302;A constructor that accepts a runtime-specific {@link RequestUpgradeStrategy}._@param requestUpgradeStrategy the upgrade strategy to use;public DefaultHandshakeHandler(RequestUpgradeStrategy requestUpgradeStrategy) {_		Assert.notNull(requestUpgradeStrategy, "RequestUpgradeStrategy must not be null")__		this.requestUpgradeStrategy = requestUpgradeStrategy__	};a,constructor,that,accepts,a,runtime,specific,link,request,upgrade,strategy,param,request,upgrade,strategy,the,upgrade,strategy,to,use;public,default,handshake,handler,request,upgrade,strategy,request,upgrade,strategy,assert,not,null,request,upgrade,strategy,request,upgrade,strategy,must,not,be,null,this,request,upgrade,strategy,request,upgrade,strategy
DefaultHandshakeHandler -> public DefaultHandshakeHandler(RequestUpgradeStrategy requestUpgradeStrategy);1406322960;A constructor that accepts a runtime-specific {@link RequestUpgradeStrategy}._@param requestUpgradeStrategy the upgrade strategy to use;public DefaultHandshakeHandler(RequestUpgradeStrategy requestUpgradeStrategy) {_		Assert.notNull(requestUpgradeStrategy, "RequestUpgradeStrategy must not be null")__		this.requestUpgradeStrategy = requestUpgradeStrategy__	};a,constructor,that,accepts,a,runtime,specific,link,request,upgrade,strategy,param,request,upgrade,strategy,the,upgrade,strategy,to,use;public,default,handshake,handler,request,upgrade,strategy,request,upgrade,strategy,assert,not,null,request,upgrade,strategy,request,upgrade,strategy,must,not,be,null,this,request,upgrade,strategy,request,upgrade,strategy
DefaultHandshakeHandler -> public DefaultHandshakeHandler(RequestUpgradeStrategy requestUpgradeStrategy);1413840766;A constructor that accepts a runtime-specific {@link RequestUpgradeStrategy}._@param requestUpgradeStrategy the upgrade strategy to use;public DefaultHandshakeHandler(RequestUpgradeStrategy requestUpgradeStrategy) {_		Assert.notNull(requestUpgradeStrategy, "RequestUpgradeStrategy must not be null")__		this.requestUpgradeStrategy = requestUpgradeStrategy__	};a,constructor,that,accepts,a,runtime,specific,link,request,upgrade,strategy,param,request,upgrade,strategy,the,upgrade,strategy,to,use;public,default,handshake,handler,request,upgrade,strategy,request,upgrade,strategy,assert,not,null,request,upgrade,strategy,request,upgrade,strategy,must,not,be,null,this,request,upgrade,strategy,request,upgrade,strategy
DefaultHandshakeHandler -> public DefaultHandshakeHandler(RequestUpgradeStrategy requestUpgradeStrategy);1414354684;A constructor that accepts a runtime-specific {@link RequestUpgradeStrategy}._@param requestUpgradeStrategy the upgrade strategy to use;public DefaultHandshakeHandler(RequestUpgradeStrategy requestUpgradeStrategy) {_		Assert.notNull(requestUpgradeStrategy, "RequestUpgradeStrategy must not be null")__		this.requestUpgradeStrategy = requestUpgradeStrategy__	};a,constructor,that,accepts,a,runtime,specific,link,request,upgrade,strategy,param,request,upgrade,strategy,the,upgrade,strategy,to,use;public,default,handshake,handler,request,upgrade,strategy,request,upgrade,strategy,assert,not,null,request,upgrade,strategy,request,upgrade,strategy,must,not,be,null,this,request,upgrade,strategy,request,upgrade,strategy
DefaultHandshakeHandler -> public DefaultHandshakeHandler(RequestUpgradeStrategy requestUpgradeStrategy);1415669910;A constructor that accepts a runtime-specific {@link RequestUpgradeStrategy}._@param requestUpgradeStrategy the upgrade strategy to use;public DefaultHandshakeHandler(RequestUpgradeStrategy requestUpgradeStrategy) {_		Assert.notNull(requestUpgradeStrategy, "RequestUpgradeStrategy must not be null")__		this.requestUpgradeStrategy = requestUpgradeStrategy__	};a,constructor,that,accepts,a,runtime,specific,link,request,upgrade,strategy,param,request,upgrade,strategy,the,upgrade,strategy,to,use;public,default,handshake,handler,request,upgrade,strategy,request,upgrade,strategy,assert,not,null,request,upgrade,strategy,request,upgrade,strategy,must,not,be,null,this,request,upgrade,strategy,request,upgrade,strategy
DefaultHandshakeHandler -> public DefaultHandshakeHandler(RequestUpgradeStrategy requestUpgradeStrategy);1435026644;A constructor that accepts a runtime-specific {@link RequestUpgradeStrategy}._@param requestUpgradeStrategy the upgrade strategy to use;public DefaultHandshakeHandler(RequestUpgradeStrategy requestUpgradeStrategy) {_		Assert.notNull(requestUpgradeStrategy, "RequestUpgradeStrategy must not be null")__		this.requestUpgradeStrategy = requestUpgradeStrategy__	};a,constructor,that,accepts,a,runtime,specific,link,request,upgrade,strategy,param,request,upgrade,strategy,the,upgrade,strategy,to,use;public,default,handshake,handler,request,upgrade,strategy,request,upgrade,strategy,assert,not,null,request,upgrade,strategy,request,upgrade,strategy,must,not,be,null,this,request,upgrade,strategy,request,upgrade,strategy
DefaultHandshakeHandler -> protected boolean isValidOrigin(ServerHttpRequest request);1414354684;Return whether the request {@code Origin} header value is valid or not._By default, all origins as considered as valid. Consider using an_{@link OriginHandshakeInterceptor} for filtering origins if needed.;protected boolean isValidOrigin(ServerHttpRequest request) {_		return true__	};return,whether,the,request,code,origin,header,value,is,valid,or,not,by,default,all,origins,as,considered,as,valid,consider,using,an,link,origin,handshake,interceptor,for,filtering,origins,if,needed;protected,boolean,is,valid,origin,server,http,request,request,return,true
DefaultHandshakeHandler -> protected boolean isValidOrigin(ServerHttpRequest request);1415669910;Return whether the request {@code Origin} header value is valid or not._By default, all origins as considered as valid. Consider using an_{@link OriginHandshakeInterceptor} for filtering origins if needed.;protected boolean isValidOrigin(ServerHttpRequest request) {_		return true__	};return,whether,the,request,code,origin,header,value,is,valid,or,not,by,default,all,origins,as,considered,as,valid,consider,using,an,link,origin,handshake,interceptor,for,filtering,origins,if,needed;protected,boolean,is,valid,origin,server,http,request,request,return,true
DefaultHandshakeHandler -> protected boolean isValidOrigin(ServerHttpRequest request);1435026644;Return whether the request {@code Origin} header value is valid or not._By default, all origins as considered as valid. Consider using an_{@link OriginHandshakeInterceptor} for filtering origins if needed.;protected boolean isValidOrigin(ServerHttpRequest request) {_		return true__	};return,whether,the,request,code,origin,header,value,is,valid,or,not,by,default,all,origins,as,considered,as,valid,consider,using,an,link,origin,handshake,interceptor,for,filtering,origins,if,needed;protected,boolean,is,valid,origin,server,http,request,request,return,true
DefaultHandshakeHandler -> public DefaultHandshakeHandler();1386019952;Default constructor that auto-detects and instantiates a_{@link RequestUpgradeStrategy} suitable for the runtime container._@throws IllegalStateException if no {@link RequestUpgradeStrategy} can be found.;public DefaultHandshakeHandler() {_		this(initRequestUpgradeStrategy())__	};default,constructor,that,auto,detects,and,instantiates,a,link,request,upgrade,strategy,suitable,for,the,runtime,container,throws,illegal,state,exception,if,no,link,request,upgrade,strategy,can,be,found;public,default,handshake,handler,this,init,request,upgrade,strategy
DefaultHandshakeHandler -> public DefaultHandshakeHandler();1386021191;Default constructor that auto-detects and instantiates a_{@link RequestUpgradeStrategy} suitable for the runtime container._@throws IllegalStateException if no {@link RequestUpgradeStrategy} can be found.;public DefaultHandshakeHandler() {_		this(initRequestUpgradeStrategy())__	};default,constructor,that,auto,detects,and,instantiates,a,link,request,upgrade,strategy,suitable,for,the,runtime,container,throws,illegal,state,exception,if,no,link,request,upgrade,strategy,can,be,found;public,default,handshake,handler,this,init,request,upgrade,strategy
DefaultHandshakeHandler -> public DefaultHandshakeHandler();1386087504;Default constructor that auto-detects and instantiates a_{@link RequestUpgradeStrategy} suitable for the runtime container._@throws IllegalStateException if no {@link RequestUpgradeStrategy} can be found.;public DefaultHandshakeHandler() {_		this(initRequestUpgradeStrategy())__	};default,constructor,that,auto,detects,and,instantiates,a,link,request,upgrade,strategy,suitable,for,the,runtime,container,throws,illegal,state,exception,if,no,link,request,upgrade,strategy,can,be,found;public,default,handshake,handler,this,init,request,upgrade,strategy
DefaultHandshakeHandler -> public DefaultHandshakeHandler();1386197885;Default constructor that autodetects and instantiates a_{@link RequestUpgradeStrategy} suitable for the runtime container._@throws IllegalStateException if no {@link RequestUpgradeStrategy} can be found.;public DefaultHandshakeHandler() {_		this(initRequestUpgradeStrategy())__	};default,constructor,that,autodetects,and,instantiates,a,link,request,upgrade,strategy,suitable,for,the,runtime,container,throws,illegal,state,exception,if,no,link,request,upgrade,strategy,can,be,found;public,default,handshake,handler,this,init,request,upgrade,strategy
DefaultHandshakeHandler -> public DefaultHandshakeHandler();1389649177;Default constructor that autodetects and instantiates a_{@link RequestUpgradeStrategy} suitable for the runtime container._@throws IllegalStateException if no {@link RequestUpgradeStrategy} can be found.;public DefaultHandshakeHandler() {_		this(initRequestUpgradeStrategy())__	};default,constructor,that,autodetects,and,instantiates,a,link,request,upgrade,strategy,suitable,for,the,runtime,container,throws,illegal,state,exception,if,no,link,request,upgrade,strategy,can,be,found;public,default,handshake,handler,this,init,request,upgrade,strategy
DefaultHandshakeHandler -> public DefaultHandshakeHandler();1389735918;Default constructor that autodetects and instantiates a_{@link RequestUpgradeStrategy} suitable for the runtime container._@throws IllegalStateException if no {@link RequestUpgradeStrategy} can be found.;public DefaultHandshakeHandler() {_		this(initRequestUpgradeStrategy())__	};default,constructor,that,autodetects,and,instantiates,a,link,request,upgrade,strategy,suitable,for,the,runtime,container,throws,illegal,state,exception,if,no,link,request,upgrade,strategy,can,be,found;public,default,handshake,handler,this,init,request,upgrade,strategy
DefaultHandshakeHandler -> public DefaultHandshakeHandler();1395555177;Default constructor that autodetects and instantiates a_{@link RequestUpgradeStrategy} suitable for the runtime container._@throws IllegalStateException if no {@link RequestUpgradeStrategy} can be found.;public DefaultHandshakeHandler() {_		this(initRequestUpgradeStrategy())__	};default,constructor,that,autodetects,and,instantiates,a,link,request,upgrade,strategy,suitable,for,the,runtime,container,throws,illegal,state,exception,if,no,link,request,upgrade,strategy,can,be,found;public,default,handshake,handler,this,init,request,upgrade,strategy
DefaultHandshakeHandler -> public DefaultHandshakeHandler();1404880799;Default constructor that autodetects and instantiates a_{@link RequestUpgradeStrategy} suitable for the runtime container._@throws IllegalStateException if no {@link RequestUpgradeStrategy} can be found.;public DefaultHandshakeHandler() {_		this(initRequestUpgradeStrategy())__	};default,constructor,that,autodetects,and,instantiates,a,link,request,upgrade,strategy,suitable,for,the,runtime,container,throws,illegal,state,exception,if,no,link,request,upgrade,strategy,can,be,found;public,default,handshake,handler,this,init,request,upgrade,strategy
DefaultHandshakeHandler -> public DefaultHandshakeHandler();1406210302;Default constructor that autodetects and instantiates a_{@link RequestUpgradeStrategy} suitable for the runtime container._@throws IllegalStateException if no {@link RequestUpgradeStrategy} can be found.;public DefaultHandshakeHandler() {_		this(initRequestUpgradeStrategy())__	};default,constructor,that,autodetects,and,instantiates,a,link,request,upgrade,strategy,suitable,for,the,runtime,container,throws,illegal,state,exception,if,no,link,request,upgrade,strategy,can,be,found;public,default,handshake,handler,this,init,request,upgrade,strategy
DefaultHandshakeHandler -> public DefaultHandshakeHandler();1406322960;Default constructor that autodetects and instantiates a_{@link RequestUpgradeStrategy} suitable for the runtime container._@throws IllegalStateException if no {@link RequestUpgradeStrategy} can be found.;public DefaultHandshakeHandler() {_		this(initRequestUpgradeStrategy())__	};default,constructor,that,autodetects,and,instantiates,a,link,request,upgrade,strategy,suitable,for,the,runtime,container,throws,illegal,state,exception,if,no,link,request,upgrade,strategy,can,be,found;public,default,handshake,handler,this,init,request,upgrade,strategy
DefaultHandshakeHandler -> public DefaultHandshakeHandler();1413840766;Default constructor that autodetects and instantiates a_{@link RequestUpgradeStrategy} suitable for the runtime container._@throws IllegalStateException if no {@link RequestUpgradeStrategy} can be found.;public DefaultHandshakeHandler() {_		this(initRequestUpgradeStrategy())__	};default,constructor,that,autodetects,and,instantiates,a,link,request,upgrade,strategy,suitable,for,the,runtime,container,throws,illegal,state,exception,if,no,link,request,upgrade,strategy,can,be,found;public,default,handshake,handler,this,init,request,upgrade,strategy
DefaultHandshakeHandler -> public DefaultHandshakeHandler();1414354684;Default constructor that autodetects and instantiates a_{@link RequestUpgradeStrategy} suitable for the runtime container._@throws IllegalStateException if no {@link RequestUpgradeStrategy} can be found.;public DefaultHandshakeHandler() {_		this(initRequestUpgradeStrategy())__	};default,constructor,that,autodetects,and,instantiates,a,link,request,upgrade,strategy,suitable,for,the,runtime,container,throws,illegal,state,exception,if,no,link,request,upgrade,strategy,can,be,found;public,default,handshake,handler,this,init,request,upgrade,strategy
DefaultHandshakeHandler -> public DefaultHandshakeHandler();1415669910;Default constructor that autodetects and instantiates a_{@link RequestUpgradeStrategy} suitable for the runtime container._@throws IllegalStateException if no {@link RequestUpgradeStrategy} can be found.;public DefaultHandshakeHandler() {_		this(initRequestUpgradeStrategy())__	};default,constructor,that,autodetects,and,instantiates,a,link,request,upgrade,strategy,suitable,for,the,runtime,container,throws,illegal,state,exception,if,no,link,request,upgrade,strategy,can,be,found;public,default,handshake,handler,this,init,request,upgrade,strategy
DefaultHandshakeHandler -> public DefaultHandshakeHandler();1435026644;Default constructor that autodetects and instantiates a_{@link RequestUpgradeStrategy} suitable for the runtime container._@throws IllegalStateException if no {@link RequestUpgradeStrategy} can be found.;public DefaultHandshakeHandler() {_		this(initRequestUpgradeStrategy())__	};default,constructor,that,autodetects,and,instantiates,a,link,request,upgrade,strategy,suitable,for,the,runtime,container,throws,illegal,state,exception,if,no,link,request,upgrade,strategy,can,be,found;public,default,handshake,handler,this,init,request,upgrade,strategy
DefaultHandshakeHandler -> protected List<WebSocketExtension> filterRequestedExtensions(ServerHttpRequest request, 			List<WebSocketExtension> requested, List<WebSocketExtension> supported);1386019952;Filter the list of requested WebSocket extensions._<p>By default all request extensions are returned. The WebSocket server will further_compare the requested extensions against the list of supported extensions and_return only the ones that are both requested and supported._@param request the current request_@param requested the list of extensions requested by the client_@param supported the list of extensions supported by the server_@return the selected extensions or an empty list;protected List<WebSocketExtension> filterRequestedExtensions(ServerHttpRequest request,_			List<WebSocketExtension> requested, List<WebSocketExtension> supported) {__		if (requested != null) {_			if (logger.isDebugEnabled()) {_				logger.debug("Requested extension(s): " + requested + ", supported extension(s): " + supported)__			}_		}_		return requested__	};filter,the,list,of,requested,web,socket,extensions,p,by,default,all,request,extensions,are,returned,the,web,socket,server,will,further,compare,the,requested,extensions,against,the,list,of,supported,extensions,and,return,only,the,ones,that,are,both,requested,and,supported,param,request,the,current,request,param,requested,the,list,of,extensions,requested,by,the,client,param,supported,the,list,of,extensions,supported,by,the,server,return,the,selected,extensions,or,an,empty,list;protected,list,web,socket,extension,filter,requested,extensions,server,http,request,request,list,web,socket,extension,requested,list,web,socket,extension,supported,if,requested,null,if,logger,is,debug,enabled,logger,debug,requested,extension,s,requested,supported,extension,s,supported,return,requested
DefaultHandshakeHandler -> protected List<WebSocketExtension> filterRequestedExtensions(ServerHttpRequest request, 			List<WebSocketExtension> requested, List<WebSocketExtension> supported);1386021191;Filter the list of requested WebSocket extensions._<p>By default all request extensions are returned. The WebSocket server will further_compare the requested extensions against the list of supported extensions and_return only the ones that are both requested and supported._@param request the current request_@param requested the list of extensions requested by the client_@param supported the list of extensions supported by the server_@return the selected extensions or an empty list;protected List<WebSocketExtension> filterRequestedExtensions(ServerHttpRequest request,_			List<WebSocketExtension> requested, List<WebSocketExtension> supported) {__		if (requested != null) {_			if (logger.isDebugEnabled()) {_				logger.debug("Requested extension(s): " + requested + ", supported extension(s): " + supported)__			}_		}_		return requested__	};filter,the,list,of,requested,web,socket,extensions,p,by,default,all,request,extensions,are,returned,the,web,socket,server,will,further,compare,the,requested,extensions,against,the,list,of,supported,extensions,and,return,only,the,ones,that,are,both,requested,and,supported,param,request,the,current,request,param,requested,the,list,of,extensions,requested,by,the,client,param,supported,the,list,of,extensions,supported,by,the,server,return,the,selected,extensions,or,an,empty,list;protected,list,web,socket,extension,filter,requested,extensions,server,http,request,request,list,web,socket,extension,requested,list,web,socket,extension,supported,if,requested,null,if,logger,is,debug,enabled,logger,debug,requested,extension,s,requested,supported,extension,s,supported,return,requested
DefaultHandshakeHandler -> protected List<WebSocketExtension> filterRequestedExtensions(ServerHttpRequest request, 			List<WebSocketExtension> requested, List<WebSocketExtension> supported);1386087504;Filter the list of requested WebSocket extensions._<p>By default all request extensions are returned. The WebSocket server will further_compare the requested extensions against the list of supported extensions and_return only the ones that are both requested and supported._@param request the current request_@param requested the list of extensions requested by the client_@param supported the list of extensions supported by the server_@return the selected extensions or an empty list;protected List<WebSocketExtension> filterRequestedExtensions(ServerHttpRequest request,_			List<WebSocketExtension> requested, List<WebSocketExtension> supported) {__		if (requested != null) {_			if (logger.isDebugEnabled()) {_				logger.debug("Requested extension(s): " + requested + ", supported extension(s): " + supported)__			}_		}_		return requested__	};filter,the,list,of,requested,web,socket,extensions,p,by,default,all,request,extensions,are,returned,the,web,socket,server,will,further,compare,the,requested,extensions,against,the,list,of,supported,extensions,and,return,only,the,ones,that,are,both,requested,and,supported,param,request,the,current,request,param,requested,the,list,of,extensions,requested,by,the,client,param,supported,the,list,of,extensions,supported,by,the,server,return,the,selected,extensions,or,an,empty,list;protected,list,web,socket,extension,filter,requested,extensions,server,http,request,request,list,web,socket,extension,requested,list,web,socket,extension,supported,if,requested,null,if,logger,is,debug,enabled,logger,debug,requested,extension,s,requested,supported,extension,s,supported,return,requested
DefaultHandshakeHandler -> protected List<WebSocketExtension> filterRequestedExtensions(ServerHttpRequest request, 			List<WebSocketExtension> requested, List<WebSocketExtension> supported);1386197885;Filter the list of requested WebSocket extensions._<p>By default all request extensions are returned. The WebSocket server will further_compare the requested extensions against the list of supported extensions and_return only the ones that are both requested and supported._@param request the current request_@param requested the list of extensions requested by the client_@param supported the list of extensions supported by the server_@return the selected extensions or an empty list;protected List<WebSocketExtension> filterRequestedExtensions(ServerHttpRequest request,_			List<WebSocketExtension> requested, List<WebSocketExtension> supported) {__		if (requested != null) {_			if (logger.isDebugEnabled()) {_				logger.debug("Requested extension(s): " + requested + ", supported extension(s): " + supported)__			}_		}_		return requested__	};filter,the,list,of,requested,web,socket,extensions,p,by,default,all,request,extensions,are,returned,the,web,socket,server,will,further,compare,the,requested,extensions,against,the,list,of,supported,extensions,and,return,only,the,ones,that,are,both,requested,and,supported,param,request,the,current,request,param,requested,the,list,of,extensions,requested,by,the,client,param,supported,the,list,of,extensions,supported,by,the,server,return,the,selected,extensions,or,an,empty,list;protected,list,web,socket,extension,filter,requested,extensions,server,http,request,request,list,web,socket,extension,requested,list,web,socket,extension,supported,if,requested,null,if,logger,is,debug,enabled,logger,debug,requested,extension,s,requested,supported,extension,s,supported,return,requested
DefaultHandshakeHandler -> protected List<WebSocketExtension> filterRequestedExtensions(ServerHttpRequest request, 			List<WebSocketExtension> requested, List<WebSocketExtension> supported);1389649177;Filter the list of requested WebSocket extensions._<p>By default all request extensions are returned. The WebSocket server will further_compare the requested extensions against the list of supported extensions and_return only the ones that are both requested and supported._@param request the current request_@param requested the list of extensions requested by the client_@param supported the list of extensions supported by the server_@return the selected extensions or an empty list;protected List<WebSocketExtension> filterRequestedExtensions(ServerHttpRequest request,_			List<WebSocketExtension> requested, List<WebSocketExtension> supported) {__		if (requested != null) {_			if (logger.isDebugEnabled()) {_				logger.debug("Requested extension(s): " + requested + ", supported extension(s): " + supported)__			}_		}_		return requested__	};filter,the,list,of,requested,web,socket,extensions,p,by,default,all,request,extensions,are,returned,the,web,socket,server,will,further,compare,the,requested,extensions,against,the,list,of,supported,extensions,and,return,only,the,ones,that,are,both,requested,and,supported,param,request,the,current,request,param,requested,the,list,of,extensions,requested,by,the,client,param,supported,the,list,of,extensions,supported,by,the,server,return,the,selected,extensions,or,an,empty,list;protected,list,web,socket,extension,filter,requested,extensions,server,http,request,request,list,web,socket,extension,requested,list,web,socket,extension,supported,if,requested,null,if,logger,is,debug,enabled,logger,debug,requested,extension,s,requested,supported,extension,s,supported,return,requested
DefaultHandshakeHandler -> protected List<WebSocketExtension> filterRequestedExtensions(ServerHttpRequest request, 			List<WebSocketExtension> requested, List<WebSocketExtension> supported);1389735918;Filter the list of requested WebSocket extensions._<p>By default all request extensions are returned. The WebSocket server will further_compare the requested extensions against the list of supported extensions and_return only the ones that are both requested and supported._@param request the current request_@param requested the list of extensions requested by the client_@param supported the list of extensions supported by the server_@return the selected extensions or an empty list;protected List<WebSocketExtension> filterRequestedExtensions(ServerHttpRequest request,_			List<WebSocketExtension> requested, List<WebSocketExtension> supported) {__		if (requested != null) {_			if (logger.isDebugEnabled()) {_				logger.debug("Requested extension(s): " + requested + ", supported extension(s): " + supported)__			}_		}_		return requested__	};filter,the,list,of,requested,web,socket,extensions,p,by,default,all,request,extensions,are,returned,the,web,socket,server,will,further,compare,the,requested,extensions,against,the,list,of,supported,extensions,and,return,only,the,ones,that,are,both,requested,and,supported,param,request,the,current,request,param,requested,the,list,of,extensions,requested,by,the,client,param,supported,the,list,of,extensions,supported,by,the,server,return,the,selected,extensions,or,an,empty,list;protected,list,web,socket,extension,filter,requested,extensions,server,http,request,request,list,web,socket,extension,requested,list,web,socket,extension,supported,if,requested,null,if,logger,is,debug,enabled,logger,debug,requested,extension,s,requested,supported,extension,s,supported,return,requested
DefaultHandshakeHandler -> protected List<WebSocketExtension> filterRequestedExtensions(ServerHttpRequest request, 			List<WebSocketExtension> requested, List<WebSocketExtension> supported);1395555177;Filter the list of requested WebSocket extensions._<p>By default all request extensions are returned. The WebSocket server will further_compare the requested extensions against the list of supported extensions and_return only the ones that are both requested and supported._@param request the current request_@param requested the list of extensions requested by the client_@param supported the list of extensions supported by the server_@return the selected extensions or an empty list;protected List<WebSocketExtension> filterRequestedExtensions(ServerHttpRequest request,_			List<WebSocketExtension> requested, List<WebSocketExtension> supported) {__		if (requested != null) {_			if (logger.isDebugEnabled()) {_				logger.debug("Requested extension(s): " + requested + ", supported extension(s): " + supported)__			}_		}_		return requested__	};filter,the,list,of,requested,web,socket,extensions,p,by,default,all,request,extensions,are,returned,the,web,socket,server,will,further,compare,the,requested,extensions,against,the,list,of,supported,extensions,and,return,only,the,ones,that,are,both,requested,and,supported,param,request,the,current,request,param,requested,the,list,of,extensions,requested,by,the,client,param,supported,the,list,of,extensions,supported,by,the,server,return,the,selected,extensions,or,an,empty,list;protected,list,web,socket,extension,filter,requested,extensions,server,http,request,request,list,web,socket,extension,requested,list,web,socket,extension,supported,if,requested,null,if,logger,is,debug,enabled,logger,debug,requested,extension,s,requested,supported,extension,s,supported,return,requested
DefaultHandshakeHandler -> protected List<WebSocketExtension> filterRequestedExtensions(ServerHttpRequest request, 			List<WebSocketExtension> requested, List<WebSocketExtension> supported);1404880799;Filter the list of requested WebSocket extensions._<p>By default all request extensions are returned. The WebSocket server will further_compare the requested extensions against the list of supported extensions and_return only the ones that are both requested and supported._@param request the current request_@param requested the list of extensions requested by the client_@param supported the list of extensions supported by the server_@return the selected extensions or an empty list;protected List<WebSocketExtension> filterRequestedExtensions(ServerHttpRequest request,_			List<WebSocketExtension> requested, List<WebSocketExtension> supported) {__		return requested__	};filter,the,list,of,requested,web,socket,extensions,p,by,default,all,request,extensions,are,returned,the,web,socket,server,will,further,compare,the,requested,extensions,against,the,list,of,supported,extensions,and,return,only,the,ones,that,are,both,requested,and,supported,param,request,the,current,request,param,requested,the,list,of,extensions,requested,by,the,client,param,supported,the,list,of,extensions,supported,by,the,server,return,the,selected,extensions,or,an,empty,list;protected,list,web,socket,extension,filter,requested,extensions,server,http,request,request,list,web,socket,extension,requested,list,web,socket,extension,supported,return,requested
DefaultHandshakeHandler -> protected final List<String> determineHandlerSupportedProtocols(WebSocketHandler handler);1386019952;Determine the sub-protocols supported by the given WebSocketHandler by checking_whether it is an instance of {@link SubProtocolCapable}._@param handler the handler to check_@return a list of supported protocols or an empty list;protected final List<String> determineHandlerSupportedProtocols(WebSocketHandler handler) {_		List<String> subProtocols = null__		if (handler instanceof SubProtocolCapable) {_			subProtocols = ((SubProtocolCapable) handler).getSubProtocols()__		}_		else if (handler instanceof WebSocketHandlerDecorator) {_			WebSocketHandler lastHandler = ((WebSocketHandlerDecorator) handler).getLastHandler()__			if (lastHandler instanceof SubProtocolCapable) {_				subProtocols = ((SubProtocolCapable) lastHandler).getSubProtocols()___			}_		}_		return (subProtocols != null) ? subProtocols : Collections.<String>emptyList()__	};determine,the,sub,protocols,supported,by,the,given,web,socket,handler,by,checking,whether,it,is,an,instance,of,link,sub,protocol,capable,param,handler,the,handler,to,check,return,a,list,of,supported,protocols,or,an,empty,list;protected,final,list,string,determine,handler,supported,protocols,web,socket,handler,handler,list,string,sub,protocols,null,if,handler,instanceof,sub,protocol,capable,sub,protocols,sub,protocol,capable,handler,get,sub,protocols,else,if,handler,instanceof,web,socket,handler,decorator,web,socket,handler,last,handler,web,socket,handler,decorator,handler,get,last,handler,if,last,handler,instanceof,sub,protocol,capable,sub,protocols,sub,protocol,capable,last,handler,get,sub,protocols,return,sub,protocols,null,sub,protocols,collections,string,empty,list
DefaultHandshakeHandler -> protected final List<String> determineHandlerSupportedProtocols(WebSocketHandler handler);1386021191;Determine the sub-protocols supported by the given WebSocketHandler by checking_whether it is an instance of {@link SubProtocolCapable}._@param handler the handler to check_@return a list of supported protocols or an empty list;protected final List<String> determineHandlerSupportedProtocols(WebSocketHandler handler) {_		List<String> subProtocols = null__		if (handler instanceof SubProtocolCapable) {_			subProtocols = ((SubProtocolCapable) handler).getSubProtocols()__		}_		else if (handler instanceof WebSocketHandlerDecorator) {_			WebSocketHandler lastHandler = ((WebSocketHandlerDecorator) handler).getLastHandler()__			if (lastHandler instanceof SubProtocolCapable) {_				subProtocols = ((SubProtocolCapable) lastHandler).getSubProtocols()___			}_		}_		return (subProtocols != null) ? subProtocols : Collections.<String>emptyList()__	};determine,the,sub,protocols,supported,by,the,given,web,socket,handler,by,checking,whether,it,is,an,instance,of,link,sub,protocol,capable,param,handler,the,handler,to,check,return,a,list,of,supported,protocols,or,an,empty,list;protected,final,list,string,determine,handler,supported,protocols,web,socket,handler,handler,list,string,sub,protocols,null,if,handler,instanceof,sub,protocol,capable,sub,protocols,sub,protocol,capable,handler,get,sub,protocols,else,if,handler,instanceof,web,socket,handler,decorator,web,socket,handler,last,handler,web,socket,handler,decorator,handler,get,last,handler,if,last,handler,instanceof,sub,protocol,capable,sub,protocols,sub,protocol,capable,last,handler,get,sub,protocols,return,sub,protocols,null,sub,protocols,collections,string,empty,list
DefaultHandshakeHandler -> protected final List<String> determineHandlerSupportedProtocols(WebSocketHandler handler);1386087504;Determine the sub-protocols supported by the given WebSocketHandler by checking_whether it is an instance of {@link SubProtocolCapable}._@param handler the handler to check_@return a list of supported protocols or an empty list;protected final List<String> determineHandlerSupportedProtocols(WebSocketHandler handler) {_		List<String> subProtocols = null__		if (handler instanceof SubProtocolCapable) {_			subProtocols = ((SubProtocolCapable) handler).getSubProtocols()__		}_		else if (handler instanceof WebSocketHandlerDecorator) {_			WebSocketHandler lastHandler = ((WebSocketHandlerDecorator) handler).getLastHandler()__			if (lastHandler instanceof SubProtocolCapable) {_				subProtocols = ((SubProtocolCapable) lastHandler).getSubProtocols()___			}_		}_		return (subProtocols != null) ? subProtocols : Collections.<String>emptyList()__	};determine,the,sub,protocols,supported,by,the,given,web,socket,handler,by,checking,whether,it,is,an,instance,of,link,sub,protocol,capable,param,handler,the,handler,to,check,return,a,list,of,supported,protocols,or,an,empty,list;protected,final,list,string,determine,handler,supported,protocols,web,socket,handler,handler,list,string,sub,protocols,null,if,handler,instanceof,sub,protocol,capable,sub,protocols,sub,protocol,capable,handler,get,sub,protocols,else,if,handler,instanceof,web,socket,handler,decorator,web,socket,handler,last,handler,web,socket,handler,decorator,handler,get,last,handler,if,last,handler,instanceof,sub,protocol,capable,sub,protocols,sub,protocol,capable,last,handler,get,sub,protocols,return,sub,protocols,null,sub,protocols,collections,string,empty,list
DefaultHandshakeHandler -> protected final List<String> determineHandlerSupportedProtocols(WebSocketHandler handler);1386197885;Determine the sub-protocols supported by the given WebSocketHandler by checking_whether it is an instance of {@link SubProtocolCapable}._@param handler the handler to check_@return a list of supported protocols or an empty list;protected final List<String> determineHandlerSupportedProtocols(WebSocketHandler handler) {_		List<String> subProtocols = null__		if (handler instanceof SubProtocolCapable) {_			subProtocols = ((SubProtocolCapable) handler).getSubProtocols()__		}_		else if (handler instanceof WebSocketHandlerDecorator) {_			WebSocketHandler lastHandler = ((WebSocketHandlerDecorator) handler).getLastHandler()__			if (lastHandler instanceof SubProtocolCapable) {_				subProtocols = ((SubProtocolCapable) lastHandler).getSubProtocols()___			}_		}_		return (subProtocols != null) ? subProtocols : Collections.<String>emptyList()__	};determine,the,sub,protocols,supported,by,the,given,web,socket,handler,by,checking,whether,it,is,an,instance,of,link,sub,protocol,capable,param,handler,the,handler,to,check,return,a,list,of,supported,protocols,or,an,empty,list;protected,final,list,string,determine,handler,supported,protocols,web,socket,handler,handler,list,string,sub,protocols,null,if,handler,instanceof,sub,protocol,capable,sub,protocols,sub,protocol,capable,handler,get,sub,protocols,else,if,handler,instanceof,web,socket,handler,decorator,web,socket,handler,last,handler,web,socket,handler,decorator,handler,get,last,handler,if,last,handler,instanceof,sub,protocol,capable,sub,protocols,sub,protocol,capable,last,handler,get,sub,protocols,return,sub,protocols,null,sub,protocols,collections,string,empty,list
DefaultHandshakeHandler -> protected final List<String> determineHandlerSupportedProtocols(WebSocketHandler handler);1389649177;Determine the sub-protocols supported by the given WebSocketHandler by checking_whether it is an instance of {@link SubProtocolCapable}._@param handler the handler to check_@return a list of supported protocols or an empty list;protected final List<String> determineHandlerSupportedProtocols(WebSocketHandler handler) {_		List<String> subProtocols = null__		if (handler instanceof SubProtocolCapable) {_			subProtocols = ((SubProtocolCapable) handler).getSubProtocols()__		}_		else if (handler instanceof WebSocketHandlerDecorator) {_			WebSocketHandler lastHandler = ((WebSocketHandlerDecorator) handler).getLastHandler()__			if (lastHandler instanceof SubProtocolCapable) {_				subProtocols = ((SubProtocolCapable) lastHandler).getSubProtocols()___			}_		}_		return (subProtocols != null) ? subProtocols : Collections.<String>emptyList()__	};determine,the,sub,protocols,supported,by,the,given,web,socket,handler,by,checking,whether,it,is,an,instance,of,link,sub,protocol,capable,param,handler,the,handler,to,check,return,a,list,of,supported,protocols,or,an,empty,list;protected,final,list,string,determine,handler,supported,protocols,web,socket,handler,handler,list,string,sub,protocols,null,if,handler,instanceof,sub,protocol,capable,sub,protocols,sub,protocol,capable,handler,get,sub,protocols,else,if,handler,instanceof,web,socket,handler,decorator,web,socket,handler,last,handler,web,socket,handler,decorator,handler,get,last,handler,if,last,handler,instanceof,sub,protocol,capable,sub,protocols,sub,protocol,capable,last,handler,get,sub,protocols,return,sub,protocols,null,sub,protocols,collections,string,empty,list
DefaultHandshakeHandler -> protected final List<String> determineHandlerSupportedProtocols(WebSocketHandler handler);1389735918;Determine the sub-protocols supported by the given WebSocketHandler by checking_whether it is an instance of {@link SubProtocolCapable}._@param handler the handler to check_@return a list of supported protocols or an empty list;protected final List<String> determineHandlerSupportedProtocols(WebSocketHandler handler) {_		List<String> subProtocols = null__		if (handler instanceof SubProtocolCapable) {_			subProtocols = ((SubProtocolCapable) handler).getSubProtocols()__		}_		else if (handler instanceof WebSocketHandlerDecorator) {_			WebSocketHandler lastHandler = ((WebSocketHandlerDecorator) handler).getLastHandler()__			if (lastHandler instanceof SubProtocolCapable) {_				subProtocols = ((SubProtocolCapable) lastHandler).getSubProtocols()___			}_		}_		return (subProtocols != null) ? subProtocols : Collections.<String>emptyList()__	};determine,the,sub,protocols,supported,by,the,given,web,socket,handler,by,checking,whether,it,is,an,instance,of,link,sub,protocol,capable,param,handler,the,handler,to,check,return,a,list,of,supported,protocols,or,an,empty,list;protected,final,list,string,determine,handler,supported,protocols,web,socket,handler,handler,list,string,sub,protocols,null,if,handler,instanceof,sub,protocol,capable,sub,protocols,sub,protocol,capable,handler,get,sub,protocols,else,if,handler,instanceof,web,socket,handler,decorator,web,socket,handler,last,handler,web,socket,handler,decorator,handler,get,last,handler,if,last,handler,instanceof,sub,protocol,capable,sub,protocols,sub,protocol,capable,last,handler,get,sub,protocols,return,sub,protocols,null,sub,protocols,collections,string,empty,list
DefaultHandshakeHandler -> protected final List<String> determineHandlerSupportedProtocols(WebSocketHandler handler);1395555177;Determine the sub-protocols supported by the given WebSocketHandler by checking_whether it is an instance of {@link SubProtocolCapable}._@param handler the handler to check_@return a list of supported protocols or an empty list;protected final List<String> determineHandlerSupportedProtocols(WebSocketHandler handler) {_		handler = WebSocketHandlerDecorator.unwrap(handler)__		List<String> subProtocols = null__		if (handler instanceof SubProtocolCapable) {_			subProtocols = ((SubProtocolCapable) handler).getSubProtocols()__		}_		return (subProtocols != null) ? subProtocols : Collections.<String>emptyList()__	};determine,the,sub,protocols,supported,by,the,given,web,socket,handler,by,checking,whether,it,is,an,instance,of,link,sub,protocol,capable,param,handler,the,handler,to,check,return,a,list,of,supported,protocols,or,an,empty,list;protected,final,list,string,determine,handler,supported,protocols,web,socket,handler,handler,handler,web,socket,handler,decorator,unwrap,handler,list,string,sub,protocols,null,if,handler,instanceof,sub,protocol,capable,sub,protocols,sub,protocol,capable,handler,get,sub,protocols,return,sub,protocols,null,sub,protocols,collections,string,empty,list
DefaultHandshakeHandler -> protected final List<String> determineHandlerSupportedProtocols(WebSocketHandler handler);1404880799;Determine the sub-protocols supported by the given WebSocketHandler by checking_whether it is an instance of {@link SubProtocolCapable}._@param handler the handler to check_@return a list of supported protocols or an empty list;protected final List<String> determineHandlerSupportedProtocols(WebSocketHandler handler) {_		handler = WebSocketHandlerDecorator.unwrap(handler)__		List<String> subProtocols = null__		if (handler instanceof SubProtocolCapable) {_			subProtocols = ((SubProtocolCapable) handler).getSubProtocols()__		}_		return (subProtocols != null) ? subProtocols : Collections.<String>emptyList()__	};determine,the,sub,protocols,supported,by,the,given,web,socket,handler,by,checking,whether,it,is,an,instance,of,link,sub,protocol,capable,param,handler,the,handler,to,check,return,a,list,of,supported,protocols,or,an,empty,list;protected,final,list,string,determine,handler,supported,protocols,web,socket,handler,handler,handler,web,socket,handler,decorator,unwrap,handler,list,string,sub,protocols,null,if,handler,instanceof,sub,protocol,capable,sub,protocols,sub,protocol,capable,handler,get,sub,protocols,return,sub,protocols,null,sub,protocols,collections,string,empty,list
DefaultHandshakeHandler -> protected final List<String> determineHandlerSupportedProtocols(WebSocketHandler handler);1406210302;Determine the sub-protocols supported by the given WebSocketHandler by checking_whether it is an instance of {@link SubProtocolCapable}._@param handler the handler to check_@return a list of supported protocols or an empty list;protected final List<String> determineHandlerSupportedProtocols(WebSocketHandler handler) {_		handler = WebSocketHandlerDecorator.unwrap(handler)__		List<String> subProtocols = null__		if (handler instanceof SubProtocolCapable) {_			subProtocols = ((SubProtocolCapable) handler).getSubProtocols()__		}_		return (subProtocols != null) ? subProtocols : Collections.<String>emptyList()__	};determine,the,sub,protocols,supported,by,the,given,web,socket,handler,by,checking,whether,it,is,an,instance,of,link,sub,protocol,capable,param,handler,the,handler,to,check,return,a,list,of,supported,protocols,or,an,empty,list;protected,final,list,string,determine,handler,supported,protocols,web,socket,handler,handler,handler,web,socket,handler,decorator,unwrap,handler,list,string,sub,protocols,null,if,handler,instanceof,sub,protocol,capable,sub,protocols,sub,protocol,capable,handler,get,sub,protocols,return,sub,protocols,null,sub,protocols,collections,string,empty,list
DefaultHandshakeHandler -> protected final List<String> determineHandlerSupportedProtocols(WebSocketHandler handler);1406322960;Determine the sub-protocols supported by the given WebSocketHandler by checking_whether it is an instance of {@link SubProtocolCapable}._@param handler the handler to check_@return a list of supported protocols or an empty list;protected final List<String> determineHandlerSupportedProtocols(WebSocketHandler handler) {_		handler = WebSocketHandlerDecorator.unwrap(handler)__		List<String> subProtocols = null__		if (handler instanceof SubProtocolCapable) {_			subProtocols = ((SubProtocolCapable) handler).getSubProtocols()__		}_		return (subProtocols != null) ? subProtocols : Collections.<String>emptyList()__	};determine,the,sub,protocols,supported,by,the,given,web,socket,handler,by,checking,whether,it,is,an,instance,of,link,sub,protocol,capable,param,handler,the,handler,to,check,return,a,list,of,supported,protocols,or,an,empty,list;protected,final,list,string,determine,handler,supported,protocols,web,socket,handler,handler,handler,web,socket,handler,decorator,unwrap,handler,list,string,sub,protocols,null,if,handler,instanceof,sub,protocol,capable,sub,protocols,sub,protocol,capable,handler,get,sub,protocols,return,sub,protocols,null,sub,protocols,collections,string,empty,list
DefaultHandshakeHandler -> protected final List<String> determineHandlerSupportedProtocols(WebSocketHandler handler);1413840766;Determine the sub-protocols supported by the given WebSocketHandler by_checking whether it is an instance of {@link SubProtocolCapable}._@param handler the handler to check_@return a list of supported protocols, or an empty list if none available;protected final List<String> determineHandlerSupportedProtocols(WebSocketHandler handler) {_		WebSocketHandler handlerToCheck = WebSocketHandlerDecorator.unwrap(handler)__		List<String> subProtocols = null__		if (handlerToCheck instanceof SubProtocolCapable) {_			subProtocols = ((SubProtocolCapable) handlerToCheck).getSubProtocols()__		}_		return (subProtocols != null ? subProtocols : Collections.<String>emptyList())__	};determine,the,sub,protocols,supported,by,the,given,web,socket,handler,by,checking,whether,it,is,an,instance,of,link,sub,protocol,capable,param,handler,the,handler,to,check,return,a,list,of,supported,protocols,or,an,empty,list,if,none,available;protected,final,list,string,determine,handler,supported,protocols,web,socket,handler,handler,web,socket,handler,handler,to,check,web,socket,handler,decorator,unwrap,handler,list,string,sub,protocols,null,if,handler,to,check,instanceof,sub,protocol,capable,sub,protocols,sub,protocol,capable,handler,to,check,get,sub,protocols,return,sub,protocols,null,sub,protocols,collections,string,empty,list
DefaultHandshakeHandler -> protected final List<String> determineHandlerSupportedProtocols(WebSocketHandler handler);1414354684;Determine the sub-protocols supported by the given WebSocketHandler by_checking whether it is an instance of {@link SubProtocolCapable}._@param handler the handler to check_@return a list of supported protocols, or an empty list if none available;protected final List<String> determineHandlerSupportedProtocols(WebSocketHandler handler) {_		WebSocketHandler handlerToCheck = WebSocketHandlerDecorator.unwrap(handler)__		List<String> subProtocols = null__		if (handlerToCheck instanceof SubProtocolCapable) {_			subProtocols = ((SubProtocolCapable) handlerToCheck).getSubProtocols()__		}_		return (subProtocols != null ? subProtocols : Collections.<String>emptyList())__	};determine,the,sub,protocols,supported,by,the,given,web,socket,handler,by,checking,whether,it,is,an,instance,of,link,sub,protocol,capable,param,handler,the,handler,to,check,return,a,list,of,supported,protocols,or,an,empty,list,if,none,available;protected,final,list,string,determine,handler,supported,protocols,web,socket,handler,handler,web,socket,handler,handler,to,check,web,socket,handler,decorator,unwrap,handler,list,string,sub,protocols,null,if,handler,to,check,instanceof,sub,protocol,capable,sub,protocols,sub,protocol,capable,handler,to,check,get,sub,protocols,return,sub,protocols,null,sub,protocols,collections,string,empty,list
DefaultHandshakeHandler -> protected final List<String> determineHandlerSupportedProtocols(WebSocketHandler handler);1415669910;Determine the sub-protocols supported by the given WebSocketHandler by_checking whether it is an instance of {@link SubProtocolCapable}._@param handler the handler to check_@return a list of supported protocols, or an empty list if none available;protected final List<String> determineHandlerSupportedProtocols(WebSocketHandler handler) {_		WebSocketHandler handlerToCheck = WebSocketHandlerDecorator.unwrap(handler)__		List<String> subProtocols = null__		if (handlerToCheck instanceof SubProtocolCapable) {_			subProtocols = ((SubProtocolCapable) handlerToCheck).getSubProtocols()__		}_		return (subProtocols != null ? subProtocols : Collections.<String>emptyList())__	};determine,the,sub,protocols,supported,by,the,given,web,socket,handler,by,checking,whether,it,is,an,instance,of,link,sub,protocol,capable,param,handler,the,handler,to,check,return,a,list,of,supported,protocols,or,an,empty,list,if,none,available;protected,final,list,string,determine,handler,supported,protocols,web,socket,handler,handler,web,socket,handler,handler,to,check,web,socket,handler,decorator,unwrap,handler,list,string,sub,protocols,null,if,handler,to,check,instanceof,sub,protocol,capable,sub,protocols,sub,protocol,capable,handler,to,check,get,sub,protocols,return,sub,protocols,null,sub,protocols,collections,string,empty,list
DefaultHandshakeHandler -> protected final List<String> determineHandlerSupportedProtocols(WebSocketHandler handler);1435026644;Determine the sub-protocols supported by the given WebSocketHandler by_checking whether it is an instance of {@link SubProtocolCapable}._@param handler the handler to check_@return a list of supported protocols, or an empty list if none available;protected final List<String> determineHandlerSupportedProtocols(WebSocketHandler handler) {_		WebSocketHandler handlerToCheck = WebSocketHandlerDecorator.unwrap(handler)__		List<String> subProtocols = null__		if (handlerToCheck instanceof SubProtocolCapable) {_			subProtocols = ((SubProtocolCapable) handlerToCheck).getSubProtocols()__		}_		return (subProtocols != null ? subProtocols : Collections.<String>emptyList())__	};determine,the,sub,protocols,supported,by,the,given,web,socket,handler,by,checking,whether,it,is,an,instance,of,link,sub,protocol,capable,param,handler,the,handler,to,check,return,a,list,of,supported,protocols,or,an,empty,list,if,none,available;protected,final,list,string,determine,handler,supported,protocols,web,socket,handler,handler,web,socket,handler,handler,to,check,web,socket,handler,decorator,unwrap,handler,list,string,sub,protocols,null,if,handler,to,check,instanceof,sub,protocol,capable,sub,protocols,sub,protocol,capable,handler,to,check,get,sub,protocols,return,sub,protocols,null,sub,protocols,collections,string,empty,list
DefaultHandshakeHandler -> protected List<WebSocketExtension> filterRequestedExtensions(ServerHttpRequest request, 			List<WebSocketExtension> requestedExtensions, List<WebSocketExtension> supportedExtensions);1406210302;Filter the list of requested WebSocket extensions._<p>As of 4.1 the default implementation of this method filters the list to_leave only extensions that are both requested and supported._@param request the current request_@param requestedExtensions the list of extensions requested by the client_@param supportedExtensions the list of extensions supported by the server_@return the selected extensions or an empty list;protected List<WebSocketExtension> filterRequestedExtensions(ServerHttpRequest request,_			List<WebSocketExtension> requestedExtensions, List<WebSocketExtension> supportedExtensions) {__		List<WebSocketExtension> result = new ArrayList<WebSocketExtension>(requestedExtensions.size())__		for (WebSocketExtension extension : requestedExtensions) {_			if (supportedExtensions.contains(extension)) {_				result.add(extension)__			}_		}_		return result__	};filter,the,list,of,requested,web,socket,extensions,p,as,of,4,1,the,default,implementation,of,this,method,filters,the,list,to,leave,only,extensions,that,are,both,requested,and,supported,param,request,the,current,request,param,requested,extensions,the,list,of,extensions,requested,by,the,client,param,supported,extensions,the,list,of,extensions,supported,by,the,server,return,the,selected,extensions,or,an,empty,list;protected,list,web,socket,extension,filter,requested,extensions,server,http,request,request,list,web,socket,extension,requested,extensions,list,web,socket,extension,supported,extensions,list,web,socket,extension,result,new,array,list,web,socket,extension,requested,extensions,size,for,web,socket,extension,extension,requested,extensions,if,supported,extensions,contains,extension,result,add,extension,return,result
DefaultHandshakeHandler -> protected List<WebSocketExtension> filterRequestedExtensions(ServerHttpRequest request, 			List<WebSocketExtension> requestedExtensions, List<WebSocketExtension> supportedExtensions);1406322960;Filter the list of requested WebSocket extensions._<p>As of 4.1 the default implementation of this method filters the list to_leave only extensions that are both requested and supported._@param request the current request_@param requestedExtensions the list of extensions requested by the client_@param supportedExtensions the list of extensions supported by the server_@return the selected extensions or an empty list;protected List<WebSocketExtension> filterRequestedExtensions(ServerHttpRequest request,_			List<WebSocketExtension> requestedExtensions, List<WebSocketExtension> supportedExtensions) {__		List<WebSocketExtension> result = new ArrayList<WebSocketExtension>(requestedExtensions.size())__		for (WebSocketExtension extension : requestedExtensions) {_			if (supportedExtensions.contains(extension)) {_				result.add(extension)__			}_		}_		return result__	};filter,the,list,of,requested,web,socket,extensions,p,as,of,4,1,the,default,implementation,of,this,method,filters,the,list,to,leave,only,extensions,that,are,both,requested,and,supported,param,request,the,current,request,param,requested,extensions,the,list,of,extensions,requested,by,the,client,param,supported,extensions,the,list,of,extensions,supported,by,the,server,return,the,selected,extensions,or,an,empty,list;protected,list,web,socket,extension,filter,requested,extensions,server,http,request,request,list,web,socket,extension,requested,extensions,list,web,socket,extension,supported,extensions,list,web,socket,extension,result,new,array,list,web,socket,extension,requested,extensions,size,for,web,socket,extension,extension,requested,extensions,if,supported,extensions,contains,extension,result,add,extension,return,result
DefaultHandshakeHandler -> protected List<WebSocketExtension> filterRequestedExtensions(ServerHttpRequest request, 			List<WebSocketExtension> requestedExtensions, List<WebSocketExtension> supportedExtensions);1413840766;Filter the list of requested WebSocket extensions._<p>As of 4.1 the default implementation of this method filters the list to_leave only extensions that are both requested and supported._@param request the current request_@param requestedExtensions the list of extensions requested by the client_@param supportedExtensions the list of extensions supported by the server_@return the selected extensions or an empty list;protected List<WebSocketExtension> filterRequestedExtensions(ServerHttpRequest request,_			List<WebSocketExtension> requestedExtensions, List<WebSocketExtension> supportedExtensions) {__		List<WebSocketExtension> result = new ArrayList<WebSocketExtension>(requestedExtensions.size())__		for (WebSocketExtension extension : requestedExtensions) {_			if (supportedExtensions.contains(extension)) {_				result.add(extension)__			}_		}_		return result__	};filter,the,list,of,requested,web,socket,extensions,p,as,of,4,1,the,default,implementation,of,this,method,filters,the,list,to,leave,only,extensions,that,are,both,requested,and,supported,param,request,the,current,request,param,requested,extensions,the,list,of,extensions,requested,by,the,client,param,supported,extensions,the,list,of,extensions,supported,by,the,server,return,the,selected,extensions,or,an,empty,list;protected,list,web,socket,extension,filter,requested,extensions,server,http,request,request,list,web,socket,extension,requested,extensions,list,web,socket,extension,supported,extensions,list,web,socket,extension,result,new,array,list,web,socket,extension,requested,extensions,size,for,web,socket,extension,extension,requested,extensions,if,supported,extensions,contains,extension,result,add,extension,return,result
DefaultHandshakeHandler -> protected List<WebSocketExtension> filterRequestedExtensions(ServerHttpRequest request, 			List<WebSocketExtension> requestedExtensions, List<WebSocketExtension> supportedExtensions);1414354684;Filter the list of requested WebSocket extensions._<p>As of 4.1 the default implementation of this method filters the list to_leave only extensions that are both requested and supported._@param request the current request_@param requestedExtensions the list of extensions requested by the client_@param supportedExtensions the list of extensions supported by the server_@return the selected extensions or an empty list;protected List<WebSocketExtension> filterRequestedExtensions(ServerHttpRequest request,_			List<WebSocketExtension> requestedExtensions, List<WebSocketExtension> supportedExtensions) {__		List<WebSocketExtension> result = new ArrayList<WebSocketExtension>(requestedExtensions.size())__		for (WebSocketExtension extension : requestedExtensions) {_			if (supportedExtensions.contains(extension)) {_				result.add(extension)__			}_		}_		return result__	};filter,the,list,of,requested,web,socket,extensions,p,as,of,4,1,the,default,implementation,of,this,method,filters,the,list,to,leave,only,extensions,that,are,both,requested,and,supported,param,request,the,current,request,param,requested,extensions,the,list,of,extensions,requested,by,the,client,param,supported,extensions,the,list,of,extensions,supported,by,the,server,return,the,selected,extensions,or,an,empty,list;protected,list,web,socket,extension,filter,requested,extensions,server,http,request,request,list,web,socket,extension,requested,extensions,list,web,socket,extension,supported,extensions,list,web,socket,extension,result,new,array,list,web,socket,extension,requested,extensions,size,for,web,socket,extension,extension,requested,extensions,if,supported,extensions,contains,extension,result,add,extension,return,result
DefaultHandshakeHandler -> protected List<WebSocketExtension> filterRequestedExtensions(ServerHttpRequest request, 			List<WebSocketExtension> requestedExtensions, List<WebSocketExtension> supportedExtensions);1415669910;Filter the list of requested WebSocket extensions._<p>As of 4.1 the default implementation of this method filters the list to_leave only extensions that are both requested and supported._@param request the current request_@param requestedExtensions the list of extensions requested by the client_@param supportedExtensions the list of extensions supported by the server_@return the selected extensions or an empty list;protected List<WebSocketExtension> filterRequestedExtensions(ServerHttpRequest request,_			List<WebSocketExtension> requestedExtensions, List<WebSocketExtension> supportedExtensions) {__		List<WebSocketExtension> result = new ArrayList<WebSocketExtension>(requestedExtensions.size())__		for (WebSocketExtension extension : requestedExtensions) {_			if (supportedExtensions.contains(extension)) {_				result.add(extension)__			}_		}_		return result__	};filter,the,list,of,requested,web,socket,extensions,p,as,of,4,1,the,default,implementation,of,this,method,filters,the,list,to,leave,only,extensions,that,are,both,requested,and,supported,param,request,the,current,request,param,requested,extensions,the,list,of,extensions,requested,by,the,client,param,supported,extensions,the,list,of,extensions,supported,by,the,server,return,the,selected,extensions,or,an,empty,list;protected,list,web,socket,extension,filter,requested,extensions,server,http,request,request,list,web,socket,extension,requested,extensions,list,web,socket,extension,supported,extensions,list,web,socket,extension,result,new,array,list,web,socket,extension,requested,extensions,size,for,web,socket,extension,extension,requested,extensions,if,supported,extensions,contains,extension,result,add,extension,return,result
DefaultHandshakeHandler -> protected List<WebSocketExtension> filterRequestedExtensions(ServerHttpRequest request, 			List<WebSocketExtension> requestedExtensions, List<WebSocketExtension> supportedExtensions);1435026644;Filter the list of requested WebSocket extensions._<p>As of 4.1 the default implementation of this method filters the list to_leave only extensions that are both requested and supported._@param request the current request_@param requestedExtensions the list of extensions requested by the client_@param supportedExtensions the list of extensions supported by the server_@return the selected extensions or an empty list;protected List<WebSocketExtension> filterRequestedExtensions(ServerHttpRequest request,_			List<WebSocketExtension> requestedExtensions, List<WebSocketExtension> supportedExtensions) {__		List<WebSocketExtension> result = new ArrayList<WebSocketExtension>(requestedExtensions.size())__		for (WebSocketExtension extension : requestedExtensions) {_			if (supportedExtensions.contains(extension)) {_				result.add(extension)__			}_		}_		return result__	};filter,the,list,of,requested,web,socket,extensions,p,as,of,4,1,the,default,implementation,of,this,method,filters,the,list,to,leave,only,extensions,that,are,both,requested,and,supported,param,request,the,current,request,param,requested,extensions,the,list,of,extensions,requested,by,the,client,param,supported,extensions,the,list,of,extensions,supported,by,the,server,return,the,selected,extensions,or,an,empty,list;protected,list,web,socket,extension,filter,requested,extensions,server,http,request,request,list,web,socket,extension,requested,extensions,list,web,socket,extension,supported,extensions,list,web,socket,extension,result,new,array,list,web,socket,extension,requested,extensions,size,for,web,socket,extension,extension,requested,extensions,if,supported,extensions,contains,extension,result,add,extension,return,result
DefaultHandshakeHandler -> public String[] getSupportedProtocols();1386019952;Return the list of supported sub-protocols.;public String[] getSupportedProtocols() {_		return this.supportedProtocols.toArray(new String[this.supportedProtocols.size()])__	};return,the,list,of,supported,sub,protocols;public,string,get,supported,protocols,return,this,supported,protocols,to,array,new,string,this,supported,protocols,size
DefaultHandshakeHandler -> public String[] getSupportedProtocols();1386021191;Return the list of supported sub-protocols.;public String[] getSupportedProtocols() {_		return this.supportedProtocols.toArray(new String[this.supportedProtocols.size()])__	};return,the,list,of,supported,sub,protocols;public,string,get,supported,protocols,return,this,supported,protocols,to,array,new,string,this,supported,protocols,size
DefaultHandshakeHandler -> public String[] getSupportedProtocols();1386087504;Return the list of supported sub-protocols.;public String[] getSupportedProtocols() {_		return this.supportedProtocols.toArray(new String[this.supportedProtocols.size()])__	};return,the,list,of,supported,sub,protocols;public,string,get,supported,protocols,return,this,supported,protocols,to,array,new,string,this,supported,protocols,size
DefaultHandshakeHandler -> public String[] getSupportedProtocols();1386197885;Return the list of supported sub-protocols.;public String[] getSupportedProtocols() {_		return this.supportedProtocols.toArray(new String[this.supportedProtocols.size()])__	};return,the,list,of,supported,sub,protocols;public,string,get,supported,protocols,return,this,supported,protocols,to,array,new,string,this,supported,protocols,size
DefaultHandshakeHandler -> public String[] getSupportedProtocols();1389649177;Return the list of supported sub-protocols.;public String[] getSupportedProtocols() {_		return this.supportedProtocols.toArray(new String[this.supportedProtocols.size()])__	};return,the,list,of,supported,sub,protocols;public,string,get,supported,protocols,return,this,supported,protocols,to,array,new,string,this,supported,protocols,size
DefaultHandshakeHandler -> public String[] getSupportedProtocols();1389735918;Return the list of supported sub-protocols.;public String[] getSupportedProtocols() {_		return this.supportedProtocols.toArray(new String[this.supportedProtocols.size()])__	};return,the,list,of,supported,sub,protocols;public,string,get,supported,protocols,return,this,supported,protocols,to,array,new,string,this,supported,protocols,size
DefaultHandshakeHandler -> public String[] getSupportedProtocols();1395555177;Return the list of supported sub-protocols.;public String[] getSupportedProtocols() {_		return this.supportedProtocols.toArray(new String[this.supportedProtocols.size()])__	};return,the,list,of,supported,sub,protocols;public,string,get,supported,protocols,return,this,supported,protocols,to,array,new,string,this,supported,protocols,size
DefaultHandshakeHandler -> public String[] getSupportedProtocols();1404880799;Return the list of supported sub-protocols.;public String[] getSupportedProtocols() {_		return this.supportedProtocols.toArray(new String[this.supportedProtocols.size()])__	};return,the,list,of,supported,sub,protocols;public,string,get,supported,protocols,return,this,supported,protocols,to,array,new,string,this,supported,protocols,size
DefaultHandshakeHandler -> public String[] getSupportedProtocols();1406210302;Return the list of supported sub-protocols.;public String[] getSupportedProtocols() {_		return this.supportedProtocols.toArray(new String[this.supportedProtocols.size()])__	};return,the,list,of,supported,sub,protocols;public,string,get,supported,protocols,return,this,supported,protocols,to,array,new,string,this,supported,protocols,size
DefaultHandshakeHandler -> public String[] getSupportedProtocols();1406322960;Return the list of supported sub-protocols.;public String[] getSupportedProtocols() {_		return this.supportedProtocols.toArray(new String[this.supportedProtocols.size()])__	};return,the,list,of,supported,sub,protocols;public,string,get,supported,protocols,return,this,supported,protocols,to,array,new,string,this,supported,protocols,size
DefaultHandshakeHandler -> public String[] getSupportedProtocols();1413840766;Return the list of supported sub-protocols.;public String[] getSupportedProtocols() {_		return this.supportedProtocols.toArray(new String[this.supportedProtocols.size()])__	};return,the,list,of,supported,sub,protocols;public,string,get,supported,protocols,return,this,supported,protocols,to,array,new,string,this,supported,protocols,size
DefaultHandshakeHandler -> public String[] getSupportedProtocols();1414354684;Return the list of supported sub-protocols.;public String[] getSupportedProtocols() {_		return this.supportedProtocols.toArray(new String[this.supportedProtocols.size()])__	};return,the,list,of,supported,sub,protocols;public,string,get,supported,protocols,return,this,supported,protocols,to,array,new,string,this,supported,protocols,size
DefaultHandshakeHandler -> public String[] getSupportedProtocols();1415669910;Return the list of supported sub-protocols.;public String[] getSupportedProtocols() {_		return this.supportedProtocols.toArray(new String[this.supportedProtocols.size()])__	};return,the,list,of,supported,sub,protocols;public,string,get,supported,protocols,return,this,supported,protocols,to,array,new,string,this,supported,protocols,size
DefaultHandshakeHandler -> public String[] getSupportedProtocols();1435026644;Return the list of supported sub-protocols.;public String[] getSupportedProtocols() {_		return this.supportedProtocols.toArray(new String[this.supportedProtocols.size()])__	};return,the,list,of,supported,sub,protocols;public,string,get,supported,protocols,return,this,supported,protocols,to,array,new,string,this,supported,protocols,size
DefaultHandshakeHandler -> protected Principal determineUser(ServerHttpRequest request, WebSocketHandler wsHandler, 			Map<String, Object> attributes);1389649177;A method that can be used to associate a user with the WebSocket session_in the process of being established. The default implementation calls_{@link org.springframework.http.server.ServerHttpRequest#getPrincipal()}_<p>_Sub-classes can provide custom logic for associating a user with a session,_for example for assigning a name to anonymous users (i.e. not fully_authenticated).__@param request the handshake request_@param wsHandler the WebSocket handler that will handle messages_@param attributes handshake attributes to pass to the WebSocket session__@return the user for the WebSocket session or {@code null};protected Principal determineUser(ServerHttpRequest request, WebSocketHandler wsHandler,_			Map<String, Object> attributes) {__		return request.getPrincipal()__	};a,method,that,can,be,used,to,associate,a,user,with,the,web,socket,session,in,the,process,of,being,established,the,default,implementation,calls,link,org,springframework,http,server,server,http,request,get,principal,p,sub,classes,can,provide,custom,logic,for,associating,a,user,with,a,session,for,example,for,assigning,a,name,to,anonymous,users,i,e,not,fully,authenticated,param,request,the,handshake,request,param,ws,handler,the,web,socket,handler,that,will,handle,messages,param,attributes,handshake,attributes,to,pass,to,the,web,socket,session,return,the,user,for,the,web,socket,session,or,code,null;protected,principal,determine,user,server,http,request,request,web,socket,handler,ws,handler,map,string,object,attributes,return,request,get,principal
DefaultHandshakeHandler -> protected Principal determineUser(ServerHttpRequest request, WebSocketHandler wsHandler, 			Map<String, Object> attributes);1389735918;A method that can be used to associate a user with the WebSocket session_in the process of being established. The default implementation calls_{@link org.springframework.http.server.ServerHttpRequest#getPrincipal()}_<p>_Sub-classes can provide custom logic for associating a user with a session,_for example for assigning a name to anonymous users (i.e. not fully_authenticated).__@param request the handshake request_@param wsHandler the WebSocket handler that will handle messages_@param attributes handshake attributes to pass to the WebSocket session__@return the user for the WebSocket session or {@code null};protected Principal determineUser(ServerHttpRequest request, WebSocketHandler wsHandler,_			Map<String, Object> attributes) {__		return request.getPrincipal()__	};a,method,that,can,be,used,to,associate,a,user,with,the,web,socket,session,in,the,process,of,being,established,the,default,implementation,calls,link,org,springframework,http,server,server,http,request,get,principal,p,sub,classes,can,provide,custom,logic,for,associating,a,user,with,a,session,for,example,for,assigning,a,name,to,anonymous,users,i,e,not,fully,authenticated,param,request,the,handshake,request,param,ws,handler,the,web,socket,handler,that,will,handle,messages,param,attributes,handshake,attributes,to,pass,to,the,web,socket,session,return,the,user,for,the,web,socket,session,or,code,null;protected,principal,determine,user,server,http,request,request,web,socket,handler,ws,handler,map,string,object,attributes,return,request,get,principal
DefaultHandshakeHandler -> protected Principal determineUser(ServerHttpRequest request, WebSocketHandler wsHandler, 			Map<String, Object> attributes);1395555177;A method that can be used to associate a user with the WebSocket session_in the process of being established. The default implementation calls_{@link org.springframework.http.server.ServerHttpRequest#getPrincipal()}_<p>_Sub-classes can provide custom logic for associating a user with a session,_for example for assigning a name to anonymous users (i.e. not fully_authenticated).__@param request the handshake request_@param wsHandler the WebSocket handler that will handle messages_@param attributes handshake attributes to pass to the WebSocket session__@return the user for the WebSocket session or {@code null};protected Principal determineUser(ServerHttpRequest request, WebSocketHandler wsHandler,_			Map<String, Object> attributes) {__		return request.getPrincipal()__	};a,method,that,can,be,used,to,associate,a,user,with,the,web,socket,session,in,the,process,of,being,established,the,default,implementation,calls,link,org,springframework,http,server,server,http,request,get,principal,p,sub,classes,can,provide,custom,logic,for,associating,a,user,with,a,session,for,example,for,assigning,a,name,to,anonymous,users,i,e,not,fully,authenticated,param,request,the,handshake,request,param,ws,handler,the,web,socket,handler,that,will,handle,messages,param,attributes,handshake,attributes,to,pass,to,the,web,socket,session,return,the,user,for,the,web,socket,session,or,code,null;protected,principal,determine,user,server,http,request,request,web,socket,handler,ws,handler,map,string,object,attributes,return,request,get,principal
DefaultHandshakeHandler -> protected Principal determineUser(ServerHttpRequest request, WebSocketHandler wsHandler, 			Map<String, Object> attributes);1404880799;A method that can be used to associate a user with the WebSocket session_in the process of being established. The default implementation calls_{@link org.springframework.http.server.ServerHttpRequest#getPrincipal()}_<p>_Sub-classes can provide custom logic for associating a user with a session,_for example for assigning a name to anonymous users (i.e. not fully_authenticated).__@param request the handshake request_@param wsHandler the WebSocket handler that will handle messages_@param attributes handshake attributes to pass to the WebSocket session__@return the user for the WebSocket session or {@code null};protected Principal determineUser(ServerHttpRequest request, WebSocketHandler wsHandler,_			Map<String, Object> attributes) {__		return request.getPrincipal()__	};a,method,that,can,be,used,to,associate,a,user,with,the,web,socket,session,in,the,process,of,being,established,the,default,implementation,calls,link,org,springframework,http,server,server,http,request,get,principal,p,sub,classes,can,provide,custom,logic,for,associating,a,user,with,a,session,for,example,for,assigning,a,name,to,anonymous,users,i,e,not,fully,authenticated,param,request,the,handshake,request,param,ws,handler,the,web,socket,handler,that,will,handle,messages,param,attributes,handshake,attributes,to,pass,to,the,web,socket,session,return,the,user,for,the,web,socket,session,or,code,null;protected,principal,determine,user,server,http,request,request,web,socket,handler,ws,handler,map,string,object,attributes,return,request,get,principal
DefaultHandshakeHandler -> protected Principal determineUser(ServerHttpRequest request, WebSocketHandler wsHandler, 			Map<String, Object> attributes);1406210302;A method that can be used to associate a user with the WebSocket session_in the process of being established. The default implementation calls_{@link org.springframework.http.server.ServerHttpRequest#getPrincipal()}_<p>_Sub-classes can provide custom logic for associating a user with a session,_for example for assigning a name to anonymous users (i.e. not fully_authenticated).__@param request the handshake request_@param wsHandler the WebSocket handler that will handle messages_@param attributes handshake attributes to pass to the WebSocket session__@return the user for the WebSocket session or {@code null};protected Principal determineUser(ServerHttpRequest request, WebSocketHandler wsHandler,_			Map<String, Object> attributes) {__		return request.getPrincipal()__	};a,method,that,can,be,used,to,associate,a,user,with,the,web,socket,session,in,the,process,of,being,established,the,default,implementation,calls,link,org,springframework,http,server,server,http,request,get,principal,p,sub,classes,can,provide,custom,logic,for,associating,a,user,with,a,session,for,example,for,assigning,a,name,to,anonymous,users,i,e,not,fully,authenticated,param,request,the,handshake,request,param,ws,handler,the,web,socket,handler,that,will,handle,messages,param,attributes,handshake,attributes,to,pass,to,the,web,socket,session,return,the,user,for,the,web,socket,session,or,code,null;protected,principal,determine,user,server,http,request,request,web,socket,handler,ws,handler,map,string,object,attributes,return,request,get,principal
DefaultHandshakeHandler -> protected Principal determineUser(ServerHttpRequest request, WebSocketHandler wsHandler, 			Map<String, Object> attributes);1406322960;A method that can be used to associate a user with the WebSocket session_in the process of being established. The default implementation calls_{@link org.springframework.http.server.ServerHttpRequest#getPrincipal()}_<p>_Sub-classes can provide custom logic for associating a user with a session,_for example for assigning a name to anonymous users (i.e. not fully_authenticated).__@param request the handshake request_@param wsHandler the WebSocket handler that will handle messages_@param attributes handshake attributes to pass to the WebSocket session__@return the user for the WebSocket session or {@code null};protected Principal determineUser(ServerHttpRequest request, WebSocketHandler wsHandler,_			Map<String, Object> attributes) {__		return request.getPrincipal()__	};a,method,that,can,be,used,to,associate,a,user,with,the,web,socket,session,in,the,process,of,being,established,the,default,implementation,calls,link,org,springframework,http,server,server,http,request,get,principal,p,sub,classes,can,provide,custom,logic,for,associating,a,user,with,a,session,for,example,for,assigning,a,name,to,anonymous,users,i,e,not,fully,authenticated,param,request,the,handshake,request,param,ws,handler,the,web,socket,handler,that,will,handle,messages,param,attributes,handshake,attributes,to,pass,to,the,web,socket,session,return,the,user,for,the,web,socket,session,or,code,null;protected,principal,determine,user,server,http,request,request,web,socket,handler,ws,handler,map,string,object,attributes,return,request,get,principal
DefaultHandshakeHandler -> protected Principal determineUser(ServerHttpRequest request, WebSocketHandler wsHandler, 			Map<String, Object> attributes);1413840766;A method that can be used to associate a user with the WebSocket session_in the process of being established. The default implementation calls_{@link org.springframework.http.server.ServerHttpRequest#getPrincipal()}_<p>Subclasses can provide custom logic for associating a user with a session,_for example for assigning a name to anonymous users (i.e. not fully_authenticated)._@param request the handshake request_@param wsHandler the WebSocket handler that will handle messages_@param attributes handshake attributes to pass to the WebSocket session_@return the user for the WebSocket session, or {@code null} if not available;protected Principal determineUser(ServerHttpRequest request, WebSocketHandler wsHandler,_			Map<String, Object> attributes) {__		return request.getPrincipal()__	};a,method,that,can,be,used,to,associate,a,user,with,the,web,socket,session,in,the,process,of,being,established,the,default,implementation,calls,link,org,springframework,http,server,server,http,request,get,principal,p,subclasses,can,provide,custom,logic,for,associating,a,user,with,a,session,for,example,for,assigning,a,name,to,anonymous,users,i,e,not,fully,authenticated,param,request,the,handshake,request,param,ws,handler,the,web,socket,handler,that,will,handle,messages,param,attributes,handshake,attributes,to,pass,to,the,web,socket,session,return,the,user,for,the,web,socket,session,or,code,null,if,not,available;protected,principal,determine,user,server,http,request,request,web,socket,handler,ws,handler,map,string,object,attributes,return,request,get,principal
DefaultHandshakeHandler -> protected Principal determineUser(ServerHttpRequest request, WebSocketHandler wsHandler, 			Map<String, Object> attributes);1414354684;A method that can be used to associate a user with the WebSocket session_in the process of being established. The default implementation calls_{@link org.springframework.http.server.ServerHttpRequest#getPrincipal()}_<p>Subclasses can provide custom logic for associating a user with a session,_for example for assigning a name to anonymous users (i.e. not fully_authenticated)._@param request the handshake request_@param wsHandler the WebSocket handler that will handle messages_@param attributes handshake attributes to pass to the WebSocket session_@return the user for the WebSocket session, or {@code null} if not available;protected Principal determineUser(ServerHttpRequest request, WebSocketHandler wsHandler,_			Map<String, Object> attributes) {__		return request.getPrincipal()__	};a,method,that,can,be,used,to,associate,a,user,with,the,web,socket,session,in,the,process,of,being,established,the,default,implementation,calls,link,org,springframework,http,server,server,http,request,get,principal,p,subclasses,can,provide,custom,logic,for,associating,a,user,with,a,session,for,example,for,assigning,a,name,to,anonymous,users,i,e,not,fully,authenticated,param,request,the,handshake,request,param,ws,handler,the,web,socket,handler,that,will,handle,messages,param,attributes,handshake,attributes,to,pass,to,the,web,socket,session,return,the,user,for,the,web,socket,session,or,code,null,if,not,available;protected,principal,determine,user,server,http,request,request,web,socket,handler,ws,handler,map,string,object,attributes,return,request,get,principal
DefaultHandshakeHandler -> protected Principal determineUser(ServerHttpRequest request, WebSocketHandler wsHandler, 			Map<String, Object> attributes);1415669910;A method that can be used to associate a user with the WebSocket session_in the process of being established. The default implementation calls_{@link org.springframework.http.server.ServerHttpRequest#getPrincipal()}_<p>Subclasses can provide custom logic for associating a user with a session,_for example for assigning a name to anonymous users (i.e. not fully_authenticated)._@param request the handshake request_@param wsHandler the WebSocket handler that will handle messages_@param attributes handshake attributes to pass to the WebSocket session_@return the user for the WebSocket session, or {@code null} if not available;protected Principal determineUser(ServerHttpRequest request, WebSocketHandler wsHandler,_			Map<String, Object> attributes) {__		return request.getPrincipal()__	};a,method,that,can,be,used,to,associate,a,user,with,the,web,socket,session,in,the,process,of,being,established,the,default,implementation,calls,link,org,springframework,http,server,server,http,request,get,principal,p,subclasses,can,provide,custom,logic,for,associating,a,user,with,a,session,for,example,for,assigning,a,name,to,anonymous,users,i,e,not,fully,authenticated,param,request,the,handshake,request,param,ws,handler,the,web,socket,handler,that,will,handle,messages,param,attributes,handshake,attributes,to,pass,to,the,web,socket,session,return,the,user,for,the,web,socket,session,or,code,null,if,not,available;protected,principal,determine,user,server,http,request,request,web,socket,handler,ws,handler,map,string,object,attributes,return,request,get,principal
DefaultHandshakeHandler -> protected Principal determineUser(ServerHttpRequest request, WebSocketHandler wsHandler, 			Map<String, Object> attributes);1435026644;A method that can be used to associate a user with the WebSocket session_in the process of being established. The default implementation calls_{@link org.springframework.http.server.ServerHttpRequest#getPrincipal()}_<p>Subclasses can provide custom logic for associating a user with a session,_for example for assigning a name to anonymous users (i.e. not fully_authenticated)._@param request the handshake request_@param wsHandler the WebSocket handler that will handle messages_@param attributes handshake attributes to pass to the WebSocket session_@return the user for the WebSocket session, or {@code null} if not available;protected Principal determineUser(ServerHttpRequest request, WebSocketHandler wsHandler,_			Map<String, Object> attributes) {__		return request.getPrincipal()__	};a,method,that,can,be,used,to,associate,a,user,with,the,web,socket,session,in,the,process,of,being,established,the,default,implementation,calls,link,org,springframework,http,server,server,http,request,get,principal,p,subclasses,can,provide,custom,logic,for,associating,a,user,with,a,session,for,example,for,assigning,a,name,to,anonymous,users,i,e,not,fully,authenticated,param,request,the,handshake,request,param,ws,handler,the,web,socket,handler,that,will,handle,messages,param,attributes,handshake,attributes,to,pass,to,the,web,socket,session,return,the,user,for,the,web,socket,session,or,code,null,if,not,available;protected,principal,determine,user,server,http,request,request,web,socket,handler,ws,handler,map,string,object,attributes,return,request,get,principal
DefaultHandshakeHandler -> public DefaultHandshakeHandler(RequestUpgradeStrategy upgradeStrategy);1386019952;A constructor that accepts a runtime specific {@link RequestUpgradeStrategy}._@param upgradeStrategy the upgrade strategy;public DefaultHandshakeHandler(RequestUpgradeStrategy upgradeStrategy) {_		this.requestUpgradeStrategy = upgradeStrategy__	};a,constructor,that,accepts,a,runtime,specific,link,request,upgrade,strategy,param,upgrade,strategy,the,upgrade,strategy;public,default,handshake,handler,request,upgrade,strategy,upgrade,strategy,this,request,upgrade,strategy,upgrade,strategy
DefaultHandshakeHandler -> public DefaultHandshakeHandler(RequestUpgradeStrategy upgradeStrategy);1386021191;A constructor that accepts a runtime specific {@link RequestUpgradeStrategy}._@param upgradeStrategy the upgrade strategy;public DefaultHandshakeHandler(RequestUpgradeStrategy upgradeStrategy) {_		this.requestUpgradeStrategy = upgradeStrategy__	};a,constructor,that,accepts,a,runtime,specific,link,request,upgrade,strategy,param,upgrade,strategy,the,upgrade,strategy;public,default,handshake,handler,request,upgrade,strategy,upgrade,strategy,this,request,upgrade,strategy,upgrade,strategy
DefaultHandshakeHandler -> public DefaultHandshakeHandler(RequestUpgradeStrategy upgradeStrategy);1386087504;A constructor that accepts a runtime specific {@link RequestUpgradeStrategy}._@param upgradeStrategy the upgrade strategy;public DefaultHandshakeHandler(RequestUpgradeStrategy upgradeStrategy) {_		this.requestUpgradeStrategy = upgradeStrategy__	};a,constructor,that,accepts,a,runtime,specific,link,request,upgrade,strategy,param,upgrade,strategy,the,upgrade,strategy;public,default,handshake,handler,request,upgrade,strategy,upgrade,strategy,this,request,upgrade,strategy,upgrade,strategy
