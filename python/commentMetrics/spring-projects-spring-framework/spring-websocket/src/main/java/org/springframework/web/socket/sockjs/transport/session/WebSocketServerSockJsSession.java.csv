commented;modifiers;parameterAmount;loc;comment;code
false;public;0;6;;@Override @Nullable public URI getUri() {     Assert.state(this.webSocketSession != null, "WebSocketSession not yet initialized").     return this.webSocketSession.getUri(). }
false;public;0;5;;@Override public HttpHeaders getHandshakeHeaders() {     Assert.state(this.webSocketSession != null, "WebSocketSession not yet initialized").     return this.webSocketSession.getHandshakeHeaders(). }
false;public;0;5;;@Override public Principal getPrincipal() {     Assert.state(this.webSocketSession != null, "WebSocketSession not yet initialized").     return this.webSocketSession.getPrincipal(). }
false;public;0;5;;@Override public InetSocketAddress getLocalAddress() {     Assert.state(this.webSocketSession != null, "WebSocketSession not yet initialized").     return this.webSocketSession.getLocalAddress(). }
false;public;0;5;;@Override public InetSocketAddress getRemoteAddress() {     Assert.state(this.webSocketSession != null, "WebSocketSession not yet initialized").     return this.webSocketSession.getRemoteAddress(). }
false;public;0;5;;@Override public String getAcceptedProtocol() {     Assert.state(this.webSocketSession != null, "WebSocketSession not yet initialized").     return this.webSocketSession.getAcceptedProtocol(). }
false;public;1;5;;@Override public void setTextMessageSizeLimit(int messageSizeLimit) {     Assert.state(this.webSocketSession != null, "WebSocketSession not yet initialized").     this.webSocketSession.setTextMessageSizeLimit(messageSizeLimit). }
false;public;0;5;;@Override public int getTextMessageSizeLimit() {     Assert.state(this.webSocketSession != null, "WebSocketSession not yet initialized").     return this.webSocketSession.getTextMessageSizeLimit(). }
false;public;1;5;;@Override public void setBinaryMessageSizeLimit(int messageSizeLimit) {     Assert.state(this.webSocketSession != null, "WebSocketSession not yet initialized").     this.webSocketSession.setBinaryMessageSizeLimit(messageSizeLimit). }
false;public;0;5;;@Override public int getBinaryMessageSizeLimit() {     Assert.state(this.webSocketSession != null, "WebSocketSession not yet initialized").     return this.webSocketSession.getBinaryMessageSizeLimit(). }
false;public;0;5;;@Override public List<WebSocketExtension> getExtensions() {     Assert.state(this.webSocketSession != null, "WebSocketSession not yet initialized").     return this.webSocketSession.getExtensions(). }
false;public;0;6;;@Override public Object getNativeSession() {     Assert.state(this.webSocketSession != null, "WebSocketSession not yet initialized").     return (this.webSocketSession instanceof NativeWebSocketSession ? ((NativeWebSocketSession) this.webSocketSession).getNativeSession() : this.webSocketSession). }
false;public;1;6;;@Override @Nullable public <T> T getNativeSession(@Nullable Class<T> requiredType) {     return (this.webSocketSession instanceof NativeWebSocketSession ? ((NativeWebSocketSession) this.webSocketSession).getNativeSession(requiredType) : null). }
false;public;1;20;;public void initializeDelegateSession(WebSocketSession session) {     synchronized (this.initSessionLock) {         this.webSocketSession = session.         try {             // Let "our" handler know before sending the open frame to the remote handler             delegateConnectionEstablished().             this.webSocketSession.sendMessage(new TextMessage(SockJsFrame.openFrame().getContent())).             // Flush any messages cached in the mean time             while (!this.initSessionCache.isEmpty()) {                 writeFrame(SockJsFrame.messageFrame(getMessageCodec(), this.initSessionCache.poll())).             }             scheduleHeartbeat().             this.openFrameSent = true.         } catch (Throwable ex) {             tryCloseWithSockJsTransportError(ex, CloseStatus.SERVER_ERROR).         }     } }
false;public;0;4;;@Override public boolean isActive() {     return (this.webSocketSession != null && this.webSocketSession.isOpen() && !this.disconnected). }
false;public;2;18;;public void handleMessage(TextMessage message, WebSocketSession wsSession) throws Exception {     String payload = message.getPayload().     if (StringUtils.isEmpty(payload)) {         return.     }     String[] messages.     try {         messages = getSockJsServiceConfig().getMessageCodec().decode(payload).     } catch (Throwable ex) {         logger.error("Broken data received. Terminating WebSocket connection abruptly", ex).         tryCloseWithSockJsTransportError(ex, CloseStatus.BAD_DATA).         return.     }     if (messages != null) {         delegateMessages(messages).     } }
false;public;1;17;;@Override public void sendMessageInternal(String message) throws SockJsTransportFailureException {     // If in the session initialization thread, then cache, otherwise wait.     if (!this.openFrameSent) {         synchronized (this.initSessionLock) {             if (!this.openFrameSent) {                 this.initSessionCache.add(message).                 return.             }         }     }     cancelHeartbeat().     writeFrame(SockJsFrame.messageFrame(getMessageCodec(), message)).     scheduleHeartbeat(). }
false;protected;1;9;;@Override protected void writeFrameInternal(SockJsFrame frame) throws IOException {     Assert.state(this.webSocketSession != null, "WebSocketSession not yet initialized").     if (logger.isTraceEnabled()) {         logger.trace("Writing " + frame).     }     TextMessage message = new TextMessage(frame.getContent()).     this.webSocketSession.sendMessage(message). }
false;protected;1;13;;@Override protected void disconnect(CloseStatus status) throws IOException {     if (isActive()) {         synchronized (this.disconnectLock) {             if (isActive()) {                 this.disconnected = true.                 if (this.webSocketSession != null) {                     this.webSocketSession.close(status).                 }             }         }     } }
