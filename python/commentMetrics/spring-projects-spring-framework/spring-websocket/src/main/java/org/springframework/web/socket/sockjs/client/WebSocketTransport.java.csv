commented;modifiers;parameterAmount;loc;comment;code
true;public;0;3;/**  * Return the configured {@code WebSocketClient}.  */ ;/**  * Return the configured {@code WebSocketClient}.  */ public WebSocketClient getWebSocketClient() {     return this.webSocketClient. }
false;public;0;4;;@Override public List<TransportType> getTransportTypes() {     return Collections.singletonList(TransportType.WEBSOCKET). }
false;public;1;4;;@Override public void onSuccess(@Nullable WebSocketSession webSocketSession) { // WebSocket session ready, SockJS Session not yet }
false;public;1;4;;@Override public void onFailure(Throwable ex) {     future.setException(ex). }
false;public;2;25;;@Override public ListenableFuture<WebSocketSession> connect(TransportRequest request, WebSocketHandler handler) {     final SettableListenableFuture<WebSocketSession> future = new SettableListenableFuture<>().     WebSocketClientSockJsSession session = new WebSocketClientSockJsSession(request, handler, future).     handler = new ClientSockJsWebSocketHandler(session).     request.addTimeoutTask(session.getTimeoutTask()).     URI url = request.getTransportUrl().     WebSocketHttpHeaders headers = new WebSocketHttpHeaders(request.getHandshakeHeaders()).     if (logger.isDebugEnabled()) {         logger.debug("Starting WebSocket session on " + url).     }     this.webSocketClient.doHandshake(handler, headers, url).addCallback(new ListenableFutureCallback<WebSocketSession>() {          @Override         public void onSuccess(@Nullable WebSocketSession webSocketSession) {         // WebSocket session ready, SockJS Session not yet         }          @Override         public void onFailure(Throwable ex) {             future.setException(ex).         }     }).     return future. }
false;public;0;11;;@Override public void start() {     if (!isRunning()) {         if (this.webSocketClient instanceof Lifecycle) {             ((Lifecycle) this.webSocketClient).start().         } else {             this.running = true.         }     } }
false;public;0;11;;@Override public void stop() {     if (isRunning()) {         if (this.webSocketClient instanceof Lifecycle) {             ((Lifecycle) this.webSocketClient).stop().         } else {             this.running = false.         }     } }
false;public;0;9;;@Override public boolean isRunning() {     if (this.webSocketClient instanceof Lifecycle) {         return ((Lifecycle) this.webSocketClient).isRunning().     } else {         return this.running.     } }
false;public;0;4;;@Override public String toString() {     return "WebSocketTransport[client=" + this.webSocketClient + "]". }
false;public;1;5;;@Override public void afterConnectionEstablished(WebSocketSession webSocketSession) throws Exception {     Assert.state(this.connected.compareAndSet(false, true), "Already connected").     this.sockJsSession.initializeDelegateSession(webSocketSession). }
false;public;2;4;;@Override public void handleTextMessage(WebSocketSession webSocketSession, TextMessage message) throws Exception {     this.sockJsSession.handleFrame(message.getPayload()). }
false;public;2;4;;@Override public void handleTransportError(WebSocketSession webSocketSession, Throwable ex) throws Exception {     this.sockJsSession.handleTransportError(ex). }
false;public;2;4;;@Override public void afterConnectionClosed(WebSocketSession webSocketSession, CloseStatus status) throws Exception {     this.sockJsSession.afterTransportClosed(status). }
