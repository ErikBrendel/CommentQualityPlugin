commented;modifiers;parameterAmount;loc;comment;code
false;private,static;1;8;;private static InfoReceiver initInfoReceiver(List<Transport> transports) {     for (Transport transport : transports) {         if (transport instanceof InfoReceiver) {             return ((InfoReceiver) transport).         }     }     return new RestTemplateXhrTransport(). }
true;public;1;3;/**  * The names of HTTP headers that should be copied from the handshake headers  * of each call to {@link SockJsClient#doHandshake(WebSocketHandler, WebSocketHttpHeaders, URI)}  * and also used with other HTTP requests issued as part of that SockJS  * connection, e.g. the initial info request, XHR send or receive requests.  * <p>By default if this property is not set, all handshake headers are also  * used for other HTTP requests. Set it if you want only a subset of handshake  * headers (e.g. auth headers) to be used for other HTTP requests.  * @param httpHeaderNames the HTTP header names  */ ;/**  * The names of HTTP headers that should be copied from the handshake headers  * of each call to {@link SockJsClient#doHandshake(WebSocketHandler, WebSocketHttpHeaders, URI)}  * and also used with other HTTP requests issued as part of that SockJS  * connection, e.g. the initial info request, XHR send or receive requests.  * <p>By default if this property is not set, all handshake headers are also  * used for other HTTP requests. Set it if you want only a subset of handshake  * headers (e.g. auth headers) to be used for other HTTP requests.  * @param httpHeaderNames the HTTP header names  */ public void setHttpHeaderNames(@Nullable String... httpHeaderNames) {     this.httpHeaderNames = httpHeaderNames. }
true;public;0;4;/**  * The configured HTTP header names to be copied from the handshake  * headers and also included in other HTTP requests.  */ ;/**  * The configured HTTP header names to be copied from the handshake  * headers and also included in other HTTP requests.  */ @Nullable public String[] getHttpHeaderNames() {     return this.httpHeaderNames. }
true;public;1;4;/**  * Configure the {@code InfoReceiver} to use to perform the SockJS "Info"  * request before the SockJS session starts.  * <p>If the list of transports provided to the constructor contained an  * {@link XhrTransport} or an implementation of {@link InfoReceiver} that  * instance would have been used to initialize this property, or otherwise  * it defaults to {@link RestTemplateXhrTransport}.  * @param infoReceiver the transport to use for the SockJS "Info" request  */ ;/**  * Configure the {@code InfoReceiver} to use to perform the SockJS "Info"  * request before the SockJS session starts.  * <p>If the list of transports provided to the constructor contained an  * {@link XhrTransport} or an implementation of {@link InfoReceiver} that  * instance would have been used to initialize this property, or otherwise  * it defaults to {@link RestTemplateXhrTransport}.  * @param infoReceiver the transport to use for the SockJS "Info" request  */ public void setInfoReceiver(InfoReceiver infoReceiver) {     Assert.notNull(infoReceiver, "InfoReceiver is required").     this.infoReceiver = infoReceiver. }
true;public;0;3;/**  * Return the configured {@code InfoReceiver} (never {@code null}).  */ ;/**  * Return the configured {@code InfoReceiver} (never {@code null}).  */ public InfoReceiver getInfoReceiver() {     return this.infoReceiver. }
true;public;1;4;/**  * Set the SockJsMessageCodec to use.  * <p>By default {@link org.springframework.web.socket.sockjs.frame.Jackson2SockJsMessageCodec  * Jackson2SockJsMessageCodec} is used if Jackson is on the classpath.  */ ;/**  * Set the SockJsMessageCodec to use.  * <p>By default {@link org.springframework.web.socket.sockjs.frame.Jackson2SockJsMessageCodec  * Jackson2SockJsMessageCodec} is used if Jackson is on the classpath.  */ public void setMessageCodec(SockJsMessageCodec messageCodec) {     Assert.notNull(messageCodec, "SockJsMessageCodec is required").     this.messageCodec = messageCodec. }
true;public;0;4;/**  * Return the SockJsMessageCodec to use.  */ ;/**  * Return the SockJsMessageCodec to use.  */ public SockJsMessageCodec getMessageCodec() {     Assert.state(this.messageCodec != null, "No SockJsMessageCodec set").     return this.messageCodec. }
true;public;1;3;/**  * Configure a {@code TaskScheduler} for scheduling a connect timeout task  * where the timeout value is calculated based on the duration of the initial  * SockJS "Info" request. The connect timeout task ensures a more timely  * fallback but is otherwise entirely optional.  * <p>By default this is not configured in which case a fallback may take longer.  * @param connectTimeoutScheduler the task scheduler to use  */ ;/**  * Configure a {@code TaskScheduler} for scheduling a connect timeout task  * where the timeout value is calculated based on the duration of the initial  * SockJS "Info" request. The connect timeout task ensures a more timely  * fallback but is otherwise entirely optional.  * <p>By default this is not configured in which case a fallback may take longer.  * @param connectTimeoutScheduler the task scheduler to use  */ public void setConnectTimeoutScheduler(TaskScheduler connectTimeoutScheduler) {     this.connectTimeoutScheduler = connectTimeoutScheduler. }
false;public;0;14;;@Override public void start() {     if (!isRunning()) {         this.running = true.         for (Transport transport : this.transports) {             if (transport instanceof Lifecycle) {                 Lifecycle lifecycle = (Lifecycle) transport.                 if (!lifecycle.isRunning()) {                     lifecycle.start().                 }             }         }     } }
false;public;0;14;;@Override public void stop() {     if (isRunning()) {         this.running = false.         for (Transport transport : this.transports) {             if (transport instanceof Lifecycle) {                 Lifecycle lifecycle = (Lifecycle) transport.                 if (lifecycle.isRunning()) {                     lifecycle.stop().                 }             }         }     } }
false;public;0;4;;@Override public boolean isRunning() {     return this.running. }
false;public;3;8;;@Override public ListenableFuture<WebSocketSession> doHandshake(WebSocketHandler handler, String uriTemplate, Object... uriVars) {     Assert.notNull(uriTemplate, "uriTemplate must not be null").     URI uri = UriComponentsBuilder.fromUriString(uriTemplate).buildAndExpand(uriVars).encode().toUri().     return doHandshake(handler, null, uri). }
false;public,final;3;26;;@Override public final ListenableFuture<WebSocketSession> doHandshake(WebSocketHandler handler, @Nullable WebSocketHttpHeaders headers, URI url) {     Assert.notNull(handler, "WebSocketHandler is required").     Assert.notNull(url, "URL is required").     String scheme = url.getScheme().     if (!supportedProtocols.contains(scheme)) {         throw new IllegalArgumentException("Invalid scheme: '" + scheme + "'").     }     SettableListenableFuture<WebSocketSession> connectFuture = new SettableListenableFuture<>().     try {         SockJsUrlInfo sockJsUrlInfo = new SockJsUrlInfo(url).         ServerInfo serverInfo = getServerInfo(sockJsUrlInfo, getHttpRequestHeaders(headers)).         createRequest(sockJsUrlInfo, headers, serverInfo).connect(handler, connectFuture).     } catch (Throwable exception) {         if (logger.isErrorEnabled()) {             logger.error("Initial SockJS \"Info\" request to server failed, url=" + url, exception).         }         connectFuture.setException(exception).     }     return connectFuture. }
false;private;1;16;;@Nullable private HttpHeaders getHttpRequestHeaders(@Nullable HttpHeaders webSocketHttpHeaders) {     if (getHttpHeaderNames() == null || webSocketHttpHeaders == null) {         return webSocketHttpHeaders.     } else {         HttpHeaders httpHeaders = new HttpHeaders().         for (String name : getHttpHeaderNames()) {             List<String> values = webSocketHttpHeaders.get(name).             if (values != null) {                 httpHeaders.put(name, values).             }         }         return httpHeaders.     } }
false;private;2;12;;private ServerInfo getServerInfo(SockJsUrlInfo sockJsUrlInfo, @Nullable HttpHeaders headers) {     URI infoUrl = sockJsUrlInfo.getInfoUrl().     ServerInfo info = this.serverInfoCache.get(infoUrl).     if (info == null) {         long start = System.currentTimeMillis().         String response = this.infoReceiver.executeInfoRequest(infoUrl, headers).         long infoRequestTime = System.currentTimeMillis() - start.         info = new ServerInfo(response, infoRequestTime).         this.serverInfoCache.put(infoUrl, info).     }     return info. }
false;private;3;30;;private DefaultTransportRequest createRequest(SockJsUrlInfo urlInfo, @Nullable HttpHeaders headers, ServerInfo serverInfo) {     List<DefaultTransportRequest> requests = new ArrayList<>(this.transports.size()).     for (Transport transport : this.transports) {         for (TransportType type : transport.getTransportTypes()) {             if (serverInfo.isWebSocketEnabled() || !TransportType.WEBSOCKET.equals(type)) {                 requests.add(new DefaultTransportRequest(urlInfo, headers, getHttpRequestHeaders(headers), transport, type, getMessageCodec())).             }         }     }     if (CollectionUtils.isEmpty(requests)) {         throw new IllegalStateException("No transports: " + urlInfo + ", webSocketEnabled=" + serverInfo.isWebSocketEnabled()).     }     for (int i = 0. i < requests.size() - 1. i++) {         DefaultTransportRequest request = requests.get(i).         Principal user = getUser().         if (user != null) {             request.setUser(user).         }         if (this.connectTimeoutScheduler != null) {             request.setTimeoutValue(serverInfo.getRetransmissionTimeout()).             request.setTimeoutScheduler(this.connectTimeoutScheduler).         }         request.setFallbackRequest(requests.get(i + 1)).     }     return requests.get(0). }
true;protected;0;4;/**  * Return the user to associate with the SockJS session and make available via  * {@link org.springframework.web.socket.WebSocketSession#getPrincipal()}.  * <p>By default this method returns {@code null}.  * @return the user to associate with the session (possibly {@code null})  */ ;/**  * Return the user to associate with the SockJS session and make available via  * {@link org.springframework.web.socket.WebSocketSession#getPrincipal()}.  * <p>By default this method returns {@code null}.  * @return the user to associate with the session (possibly {@code null})  */ @Nullable protected Principal getUser() {     return null. }
true;public;0;3;/**  * By default the result of a SockJS "Info" request, including whether the  * server has WebSocket disabled and how long the request took (used for  * calculating transport timeout time) is cached. This method can be used to  * clear that cache hence causing it to re-populate.  */ ;/**  * By default the result of a SockJS "Info" request, including whether the  * server has WebSocket disabled and how long the request took (used for  * calculating transport timeout time) is cached. This method can be used to  * clear that cache hence causing it to re-populate.  */ public void clearServerInfoCache() {     this.serverInfoCache.clear(). }
false;public;0;3;;public boolean isWebSocketEnabled() {     return this.webSocketEnabled. }
false;public;0;3;;public long getRetransmissionTimeout() {     return (this.responseTime > 100 ? 4 * this.responseTime : this.responseTime + 300). }
