commented;modifiers;parameterAmount;loc;comment;code
false;public;0;6;;@Override public URI getUri() {     URI uri = this.uri.     Assert.state(uri != null, "No initial request yet").     return uri. }
false;public;0;6;;@Override public HttpHeaders getHandshakeHeaders() {     HttpHeaders headers = this.handshakeHeaders.     Assert.state(headers != null, "No initial request yet").     return headers. }
false;public;0;5;;@Override @Nullable public Principal getPrincipal() {     return this.principal. }
false;public;0;5;;@Override @Nullable public InetSocketAddress getLocalAddress() {     return this.localAddress. }
false;public;0;5;;@Override @Nullable public InetSocketAddress getRemoteAddress() {     return this.remoteAddress. }
true;public;1;3;/**  * Unlike WebSocket where sub-protocol negotiation is part of the initial  * handshake, in HTTP transports the same negotiation must be emulated and  * the selected protocol set through this setter.  * @param protocol the sub-protocol to set  */ ;/**  * Unlike WebSocket where sub-protocol negotiation is part of the initial  * handshake, in HTTP transports the same negotiation must be emulated and  * the selected protocol set through this setter.  * @param protocol the sub-protocol to set  */ public void setAcceptedProtocol(@Nullable String protocol) {     this.acceptedProtocol = protocol. }
true;public;0;4;/**  * Return the selected sub-protocol to use.  */ ;/**  * Return the selected sub-protocol to use.  */ @Nullable public String getAcceptedProtocol() {     return this.acceptedProtocol. }
true;protected;0;3;/**  * Return the SockJS buffer for messages stored transparently between polling  * requests. If the polling request takes longer than 5 seconds, the session  * is closed.  * @see org.springframework.web.socket.sockjs.transport.TransportHandlingSockJsService  */ ;/**  * Return the SockJS buffer for messages stored transparently between polling  * requests. If the polling request takes longer than 5 seconds, the session  * is closed.  * @see org.springframework.web.socket.sockjs.transport.TransportHandlingSockJsService  */ protected Queue<String> getMessageCache() {     return this.messageCache. }
false;public;0;5;;@Override public boolean isActive() {     ServerHttpAsyncRequestControl control = this.asyncRequestControl.     return (control != null && !control.isCompleted()). }
false;public;1;4;;@Override public void setTextMessageSizeLimit(int messageSizeLimit) { // ignore }
false;public;0;4;;@Override public int getTextMessageSizeLimit() {     return -1. }
false;public;1;4;;@Override public void setBinaryMessageSizeLimit(int messageSizeLimit) { // ignore }
false;public;0;4;;@Override public int getBinaryMessageSizeLimit() {     return -1. }
false;public;0;4;;@Override public List<WebSocketExtension> getExtensions() {     return Collections.emptyList(). }
true;public;3;39;/**  * Handle the first request for receiving messages on a SockJS HTTP transport  * based session.  * <p>Long polling-based transports (e.g. "xhr", "jsonp") complete the request  * after writing the open frame. Streaming-based transports ("xhr_streaming",  * "eventsource", and "htmlfile") leave the response open longer for further  * streaming of message frames but will also close it eventually after some  * amount of data has been sent.  * @param request the current request  * @param response the current response  * @param frameFormat the transport-specific SocksJS frame format to use  */ ;/**  * Handle the first request for receiving messages on a SockJS HTTP transport  * based session.  * <p>Long polling-based transports (e.g. "xhr", "jsonp") complete the request  * after writing the open frame. Streaming-based transports ("xhr_streaming",  * "eventsource", and "htmlfile") leave the response open longer for further  * streaming of message frames but will also close it eventually after some  * amount of data has been sent.  * @param request the current request  * @param response the current response  * @param frameFormat the transport-specific SocksJS frame format to use  */ public void handleInitialRequest(ServerHttpRequest request, ServerHttpResponse response, SockJsFrameFormat frameFormat) throws SockJsException {     this.uri = request.getURI().     this.handshakeHeaders = request.getHeaders().     this.principal = request.getPrincipal().     try {         this.localAddress = request.getLocalAddress().     } catch (Exception ex) {     // Ignore     }     try {         this.remoteAddress = request.getRemoteAddress().     } catch (Exception ex) {     // Ignore     }     synchronized (this.responseLock) {         try {             this.response = response.             this.frameFormat = frameFormat.             ServerHttpAsyncRequestControl control = request.getAsyncRequestControl(response).             this.asyncRequestControl = control.             control.start(-1).             disableShallowEtagHeaderFilter(request).             // Let "our" handler know before sending the open frame to the remote handler             delegateConnectionEstablished().             handleRequestInternal(request, response, true).             // Request might have been reset (e.g. polling sessions do after writing)             this.readyToSend = isActive().         } catch (Throwable ex) {             tryCloseWithSockJsTransportError(ex, CloseStatus.SERVER_ERROR).             throw new SockJsTransportFailureException("Failed to open session", getId(), ex).         }     } }
true;public;3;24;/**  * Handle all requests, except the first one, to receive messages on a SockJS  * HTTP transport based session.  * <p>Long polling-based transports (e.g. "xhr", "jsonp") complete the request  * after writing any buffered message frames (or the next one). Streaming-based  * transports ("xhr_streaming", "eventsource", and "htmlfile") leave the  * response open longer for further streaming of message frames but will also  * close it eventually after some amount of data has been sent.  * @param request the current request  * @param response the current response  * @param frameFormat the transport-specific SocksJS frame format to use  */ ;/**  * Handle all requests, except the first one, to receive messages on a SockJS  * HTTP transport based session.  * <p>Long polling-based transports (e.g. "xhr", "jsonp") complete the request  * after writing any buffered message frames (or the next one). Streaming-based  * transports ("xhr_streaming", "eventsource", and "htmlfile") leave the  * response open longer for further streaming of message frames but will also  * close it eventually after some amount of data has been sent.  * @param request the current request  * @param response the current response  * @param frameFormat the transport-specific SocksJS frame format to use  */ public void handleSuccessiveRequest(ServerHttpRequest request, ServerHttpResponse response, SockJsFrameFormat frameFormat) throws SockJsException {     synchronized (this.responseLock) {         try {             if (isClosed()) {                 response.getBody().write(SockJsFrame.closeFrameGoAway().getContentBytes()).                 return.             }             this.response = response.             this.frameFormat = frameFormat.             ServerHttpAsyncRequestControl control = request.getAsyncRequestControl(response).             this.asyncRequestControl = control.             control.start(-1).             disableShallowEtagHeaderFilter(request).             handleRequestInternal(request, response, false).             this.readyToSend = isActive().         } catch (Throwable ex) {             tryCloseWithSockJsTransportError(ex, CloseStatus.SERVER_ERROR).             throw new SockJsTransportFailureException("Failed to handle SockJS receive request", getId(), ex).         }     } }
false;private;1;6;;private void disableShallowEtagHeaderFilter(ServerHttpRequest request) {     if (request instanceof ServletServerHttpRequest) {         ServletRequest servletRequest = ((ServletServerHttpRequest) request).getServletRequest().         ShallowEtagHeaderFilter.disableContentCaching(servletRequest).     } }
true;protected,abstract;3;2;/**  * Invoked when a SockJS transport request is received.  * @param request the current request  * @param response the current response  * @param initialRequest whether it is the first request for the session  */ ;/**  * Invoked when a SockJS transport request is received.  * @param request the current request  * @param response the current response  * @param initialRequest whether it is the first request for the session  */ protected abstract void handleRequestInternal(ServerHttpRequest request, ServerHttpResponse response, boolean initialRequest) throws IOException.
false;protected,final;1;21;;@Override protected final void sendMessageInternal(String message) throws SockJsTransportFailureException {     synchronized (this.responseLock) {         this.messageCache.add(message).         if (logger.isTraceEnabled()) {             logger.trace(this.messageCache.size() + " message(s) to flush in session " + getId()).         }         if (isActive() && this.readyToSend) {             if (logger.isTraceEnabled()) {                 logger.trace("Session is active, ready to flush.").             }             cancelHeartbeat().             flushCache().         } else {             if (logger.isTraceEnabled()) {                 logger.trace("Session is not active, not ready to flush.").             }         }     } }
true;protected,abstract;0;1;/**  * Called when the connection is active and ready to write to the response.  * Subclasses should only call this method from a method where the  * "responseLock" is acquired.  */ ;/**  * Called when the connection is active and ready to write to the response.  * Subclasses should only call this method from a method where the  * "responseLock" is acquired.  */ protected abstract void flushCache() throws SockJsTransportFailureException.
false;protected;1;4;;@Override protected void disconnect(CloseStatus status) {     resetRequest(). }
false;protected;0;18;;protected void resetRequest() {     synchronized (this.responseLock) {         ServerHttpAsyncRequestControl control = this.asyncRequestControl.         this.asyncRequestControl = null.         this.readyToSend = false.         this.response = null.         updateLastActiveTime().         if (control != null && !control.isCompleted() && control.isStarted()) {             try {                 control.complete().             } catch (Throwable ex) {                 // Could be part of normal workflow (e.g. browser tab closed)                 logger.debug("Failed to complete request: " + ex.getMessage()).             }         }     } }
false;protected;1;15;;@Override protected void writeFrameInternal(SockJsFrame frame) throws IOException {     if (isActive()) {         SockJsFrameFormat frameFormat = this.frameFormat.         ServerHttpResponse response = this.response.         if (frameFormat != null && response != null) {             String formattedFrame = frameFormat.format(frame).             if (logger.isTraceEnabled()) {                 logger.trace("Writing to HTTP response: " + formattedFrame).             }             response.getBody().write(formattedFrame.getBytes(SockJsFrame.CHARSET)).             response.flush().         }     } }
