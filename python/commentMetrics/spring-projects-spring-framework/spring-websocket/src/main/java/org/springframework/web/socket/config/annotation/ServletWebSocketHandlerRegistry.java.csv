commented;modifiers;parameterAmount;loc;comment;code
false;public;2;7;;@Override public WebSocketHandlerRegistration addHandler(WebSocketHandler handler, String... paths) {     ServletWebSocketHandlerRegistration registration = new ServletWebSocketHandlerRegistration().     registration.addHandler(handler, paths).     this.registrations.add(registration).     return registration. }
true;public;1;3;/**  * Set the order for the resulting {@link SimpleUrlHandlerMapping} relative to  * other handler mappings configured in Spring MVC.  * <p>The default value is 1.  */ ;/**  * Set the order for the resulting {@link SimpleUrlHandlerMapping} relative to  * other handler mappings configured in Spring MVC.  * <p>The default value is 1.  */ public void setOrder(int order) {     this.order = order. }
false;public;0;3;;public int getOrder() {     return this.order. }
true;public;1;3;/**  * Set the UrlPathHelper to configure on the {@code SimpleUrlHandlerMapping}  * used to map handshake requests.  */ ;/**  * Set the UrlPathHelper to configure on the {@code SimpleUrlHandlerMapping}  * used to map handshake requests.  */ public void setUrlPathHelper(@Nullable UrlPathHelper urlPathHelper) {     this.urlPathHelper = urlPathHelper. }
false;public;0;4;;@Nullable public UrlPathHelper getUrlPathHelper() {     return this.urlPathHelper. }
true;protected;0;5;/**  * Whether there are any endpoint SockJS registrations without a TaskScheduler.  * This method should be invoked just before {@link #getHandlerMapping()} to  * allow for registrations to be made first.  */ ;/**  * Whether there are any endpoint SockJS registrations without a TaskScheduler.  * This method should be invoked just before {@link #getHandlerMapping()} to  * allow for registrations to be made first.  */ protected boolean requiresTaskScheduler() {     return this.registrations.stream().anyMatch(r -> r.getSockJsServiceRegistration() != null && r.getSockJsServiceRegistration().getTaskScheduler() == null). }
true;protected;1;7;/**  * Provide the TaskScheduler to use for SockJS endpoints for which a task  * scheduler has not been explicitly registered. This method must be called  * prior to {@link #getHandlerMapping()}.  */ ;/**  * Provide the TaskScheduler to use for SockJS endpoints for which a task  * scheduler has not been explicitly registered. This method must be called  * prior to {@link #getHandlerMapping()}.  */ protected void setTaskScheduler(TaskScheduler scheduler) {     this.registrations.stream().map(ServletWebSocketHandlerRegistration::getSockJsServiceRegistration).filter(Objects::nonNull).filter(r -> r.getTaskScheduler() == null).forEach(registration -> registration.setTaskScheduler(scheduler)). }
false;public;0;18;;public AbstractHandlerMapping getHandlerMapping() {     Map<String, Object> urlMap = new LinkedHashMap<>().     for (ServletWebSocketHandlerRegistration registration : this.registrations) {         MultiValueMap<HttpRequestHandler, String> mappings = registration.getMappings().         mappings.forEach((httpHandler, patterns) -> {             for (String pattern : patterns) {                 urlMap.put(pattern, httpHandler).             }         }).     }     WebSocketHandlerMapping hm = new WebSocketHandlerMapping().     hm.setUrlMap(urlMap).     hm.setOrder(this.order).     if (this.urlPathHelper != null) {         hm.setUrlPathHelper(this.urlPathHelper).     }     return hm. }
