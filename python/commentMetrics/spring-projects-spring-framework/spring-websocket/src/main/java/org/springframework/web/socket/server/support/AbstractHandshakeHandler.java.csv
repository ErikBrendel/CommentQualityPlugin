# id;timestamp;commentText;codeText;commentWords;codeWords
AbstractHandshakeHandler -> public String[] getSupportedProtocols();1435026644;Return the list of supported sub-protocols.;public String[] getSupportedProtocols() {_		return this.supportedProtocols.toArray(new String[this.supportedProtocols.size()])__	};return,the,list,of,supported,sub,protocols;public,string,get,supported,protocols,return,this,supported,protocols,to,array,new,string,this,supported,protocols,size
AbstractHandshakeHandler -> public String[] getSupportedProtocols();1439394598;Return the list of supported sub-protocols.;public String[] getSupportedProtocols() {_		return this.supportedProtocols.toArray(new String[this.supportedProtocols.size()])__	};return,the,list,of,supported,sub,protocols;public,string,get,supported,protocols,return,this,supported,protocols,to,array,new,string,this,supported,protocols,size
AbstractHandshakeHandler -> public String[] getSupportedProtocols();1440705898;Return the list of supported sub-protocols.;public String[] getSupportedProtocols() {_		return this.supportedProtocols.toArray(new String[this.supportedProtocols.size()])__	};return,the,list,of,supported,sub,protocols;public,string,get,supported,protocols,return,this,supported,protocols,to,array,new,string,this,supported,protocols,size
AbstractHandshakeHandler -> public String[] getSupportedProtocols();1444736364;Return the list of supported sub-protocols.;public String[] getSupportedProtocols() {_		return this.supportedProtocols.toArray(new String[this.supportedProtocols.size()])__	};return,the,list,of,supported,sub,protocols;public,string,get,supported,protocols,return,this,supported,protocols,to,array,new,string,this,supported,protocols,size
AbstractHandshakeHandler -> public String[] getSupportedProtocols();1449660404;Return the list of supported sub-protocols.;public String[] getSupportedProtocols() {_		return this.supportedProtocols.toArray(new String[this.supportedProtocols.size()])__	};return,the,list,of,supported,sub,protocols;public,string,get,supported,protocols,return,this,supported,protocols,to,array,new,string,this,supported,protocols,size
AbstractHandshakeHandler -> public String[] getSupportedProtocols();1467730834;Return the list of supported sub-protocols.;public String[] getSupportedProtocols() {_		return this.supportedProtocols.toArray(new String[this.supportedProtocols.size()])__	};return,the,list,of,supported,sub,protocols;public,string,get,supported,protocols,return,this,supported,protocols,to,array,new,string,this,supported,protocols,size
AbstractHandshakeHandler -> public String[] getSupportedProtocols();1468948866;Return the list of supported sub-protocols.;public String[] getSupportedProtocols() {_		return this.supportedProtocols.toArray(new String[this.supportedProtocols.size()])__	};return,the,list,of,supported,sub,protocols;public,string,get,supported,protocols,return,this,supported,protocols,to,array,new,string,this,supported,protocols,size
AbstractHandshakeHandler -> public String[] getSupportedProtocols();1468964586;Return the list of supported sub-protocols.;public String[] getSupportedProtocols() {_		return this.supportedProtocols.toArray(new String[this.supportedProtocols.size()])__	};return,the,list,of,supported,sub,protocols;public,string,get,supported,protocols,return,this,supported,protocols,to,array,new,string,this,supported,protocols,size
AbstractHandshakeHandler -> public String[] getSupportedProtocols();1474905889;Return the list of supported sub-protocols.;public String[] getSupportedProtocols() {_		return this.supportedProtocols.toArray(new String[this.supportedProtocols.size()])__	};return,the,list,of,supported,sub,protocols;public,string,get,supported,protocols,return,this,supported,protocols,to,array,new,string,this,supported,protocols,size
AbstractHandshakeHandler -> public String[] getSupportedProtocols();1495868221;Return the list of supported sub-protocols.;public String[] getSupportedProtocols() {_		return this.supportedProtocols.toArray(new String[this.supportedProtocols.size()])__	};return,the,list,of,supported,sub,protocols;public,string,get,supported,protocols,return,this,supported,protocols,to,array,new,string,this,supported,protocols,size
AbstractHandshakeHandler -> public String[] getSupportedProtocols();1496837955;Return the list of supported sub-protocols.;public String[] getSupportedProtocols() {_		return this.supportedProtocols.toArray(new String[this.supportedProtocols.size()])__	};return,the,list,of,supported,sub,protocols;public,string,get,supported,protocols,return,this,supported,protocols,to,array,new,string,this,supported,protocols,size
AbstractHandshakeHandler -> public String[] getSupportedProtocols();1518810557;Return the list of supported sub-protocols.;public String[] getSupportedProtocols() {_		return StringUtils.toStringArray(this.supportedProtocols)__	};return,the,list,of,supported,sub,protocols;public,string,get,supported,protocols,return,string,utils,to,string,array,this,supported,protocols
AbstractHandshakeHandler -> public String[] getSupportedProtocols();1521123475;Return the list of supported sub-protocols.;public String[] getSupportedProtocols() {_		return StringUtils.toStringArray(this.supportedProtocols)__	};return,the,list,of,supported,sub,protocols;public,string,get,supported,protocols,return,string,utils,to,string,array,this,supported,protocols
AbstractHandshakeHandler -> public String[] getSupportedProtocols();1532509782;Return the list of supported sub-protocols.;public String[] getSupportedProtocols() {_		return StringUtils.toStringArray(this.supportedProtocols)__	};return,the,list,of,supported,sub,protocols;public,string,get,supported,protocols,return,string,utils,to,string,array,this,supported,protocols
AbstractHandshakeHandler -> protected String selectProtocol(List<String> requestedProtocols, WebSocketHandler webSocketHandler);1435026644;Perform the sub-protocol negotiation based on requested and supported sub-protocols._For the list of supported sub-protocols, this method first checks if the target_WebSocketHandler is a {@link SubProtocolCapable} and then also checks if any_sub-protocols have been explicitly configured with_{@link #setSupportedProtocols(String...)}._@param requestedProtocols the requested sub-protocols_@param webSocketHandler the WebSocketHandler that will be used_@return the selected protocols or {@code null}_@see #determineHandlerSupportedProtocols(WebSocketHandler);protected String selectProtocol(List<String> requestedProtocols, WebSocketHandler webSocketHandler) {_		if (requestedProtocols != null) {_			List<String> handlerProtocols = determineHandlerSupportedProtocols(webSocketHandler)__			for (String protocol : requestedProtocols) {_				if (handlerProtocols.contains(protocol.toLowerCase())) {_					return protocol__				}_				if (this.supportedProtocols.contains(protocol.toLowerCase())) {_					return protocol__				}_			}_		}_		return null__	};perform,the,sub,protocol,negotiation,based,on,requested,and,supported,sub,protocols,for,the,list,of,supported,sub,protocols,this,method,first,checks,if,the,target,web,socket,handler,is,a,link,sub,protocol,capable,and,then,also,checks,if,any,sub,protocols,have,been,explicitly,configured,with,link,set,supported,protocols,string,param,requested,protocols,the,requested,sub,protocols,param,web,socket,handler,the,web,socket,handler,that,will,be,used,return,the,selected,protocols,or,code,null,see,determine,handler,supported,protocols,web,socket,handler;protected,string,select,protocol,list,string,requested,protocols,web,socket,handler,web,socket,handler,if,requested,protocols,null,list,string,handler,protocols,determine,handler,supported,protocols,web,socket,handler,for,string,protocol,requested,protocols,if,handler,protocols,contains,protocol,to,lower,case,return,protocol,if,this,supported,protocols,contains,protocol,to,lower,case,return,protocol,return,null
AbstractHandshakeHandler -> protected String selectProtocol(List<String> requestedProtocols, WebSocketHandler webSocketHandler);1439394598;Perform the sub-protocol negotiation based on requested and supported sub-protocols._For the list of supported sub-protocols, this method first checks if the target_WebSocketHandler is a {@link SubProtocolCapable} and then also checks if any_sub-protocols have been explicitly configured with_{@link #setSupportedProtocols(String...)}._@param requestedProtocols the requested sub-protocols_@param webSocketHandler the WebSocketHandler that will be used_@return the selected protocols or {@code null}_@see #determineHandlerSupportedProtocols(WebSocketHandler);protected String selectProtocol(List<String> requestedProtocols, WebSocketHandler webSocketHandler) {_		if (requestedProtocols != null) {_			List<String> handlerProtocols = determineHandlerSupportedProtocols(webSocketHandler)__			for (String protocol : requestedProtocols) {_				if (handlerProtocols.contains(protocol.toLowerCase())) {_					return protocol__				}_				if (this.supportedProtocols.contains(protocol.toLowerCase())) {_					return protocol__				}_			}_		}_		return null__	};perform,the,sub,protocol,negotiation,based,on,requested,and,supported,sub,protocols,for,the,list,of,supported,sub,protocols,this,method,first,checks,if,the,target,web,socket,handler,is,a,link,sub,protocol,capable,and,then,also,checks,if,any,sub,protocols,have,been,explicitly,configured,with,link,set,supported,protocols,string,param,requested,protocols,the,requested,sub,protocols,param,web,socket,handler,the,web,socket,handler,that,will,be,used,return,the,selected,protocols,or,code,null,see,determine,handler,supported,protocols,web,socket,handler;protected,string,select,protocol,list,string,requested,protocols,web,socket,handler,web,socket,handler,if,requested,protocols,null,list,string,handler,protocols,determine,handler,supported,protocols,web,socket,handler,for,string,protocol,requested,protocols,if,handler,protocols,contains,protocol,to,lower,case,return,protocol,if,this,supported,protocols,contains,protocol,to,lower,case,return,protocol,return,null
AbstractHandshakeHandler -> protected String selectProtocol(List<String> requestedProtocols, WebSocketHandler webSocketHandler);1440705898;Perform the sub-protocol negotiation based on requested and supported sub-protocols._For the list of supported sub-protocols, this method first checks if the target_WebSocketHandler is a {@link SubProtocolCapable} and then also checks if any_sub-protocols have been explicitly configured with_{@link #setSupportedProtocols(String...)}._@param requestedProtocols the requested sub-protocols_@param webSocketHandler the WebSocketHandler that will be used_@return the selected protocols or {@code null}_@see #determineHandlerSupportedProtocols(WebSocketHandler);protected String selectProtocol(List<String> requestedProtocols, WebSocketHandler webSocketHandler) {_		if (requestedProtocols != null) {_			List<String> handlerProtocols = determineHandlerSupportedProtocols(webSocketHandler)__			for (String protocol : requestedProtocols) {_				if (handlerProtocols.contains(protocol.toLowerCase())) {_					return protocol__				}_				if (this.supportedProtocols.contains(protocol.toLowerCase())) {_					return protocol__				}_			}_		}_		return null__	};perform,the,sub,protocol,negotiation,based,on,requested,and,supported,sub,protocols,for,the,list,of,supported,sub,protocols,this,method,first,checks,if,the,target,web,socket,handler,is,a,link,sub,protocol,capable,and,then,also,checks,if,any,sub,protocols,have,been,explicitly,configured,with,link,set,supported,protocols,string,param,requested,protocols,the,requested,sub,protocols,param,web,socket,handler,the,web,socket,handler,that,will,be,used,return,the,selected,protocols,or,code,null,see,determine,handler,supported,protocols,web,socket,handler;protected,string,select,protocol,list,string,requested,protocols,web,socket,handler,web,socket,handler,if,requested,protocols,null,list,string,handler,protocols,determine,handler,supported,protocols,web,socket,handler,for,string,protocol,requested,protocols,if,handler,protocols,contains,protocol,to,lower,case,return,protocol,if,this,supported,protocols,contains,protocol,to,lower,case,return,protocol,return,null
AbstractHandshakeHandler -> protected String selectProtocol(List<String> requestedProtocols, WebSocketHandler webSocketHandler);1444736364;Perform the sub-protocol negotiation based on requested and supported sub-protocols._For the list of supported sub-protocols, this method first checks if the target_WebSocketHandler is a {@link SubProtocolCapable} and then also checks if any_sub-protocols have been explicitly configured with_{@link #setSupportedProtocols(String...)}._@param requestedProtocols the requested sub-protocols_@param webSocketHandler the WebSocketHandler that will be used_@return the selected protocols or {@code null}_@see #determineHandlerSupportedProtocols(WebSocketHandler);protected String selectProtocol(List<String> requestedProtocols, WebSocketHandler webSocketHandler) {_		if (requestedProtocols != null) {_			List<String> handlerProtocols = determineHandlerSupportedProtocols(webSocketHandler)__			for (String protocol : requestedProtocols) {_				if (handlerProtocols.contains(protocol.toLowerCase())) {_					return protocol__				}_				if (this.supportedProtocols.contains(protocol.toLowerCase())) {_					return protocol__				}_			}_		}_		return null__	};perform,the,sub,protocol,negotiation,based,on,requested,and,supported,sub,protocols,for,the,list,of,supported,sub,protocols,this,method,first,checks,if,the,target,web,socket,handler,is,a,link,sub,protocol,capable,and,then,also,checks,if,any,sub,protocols,have,been,explicitly,configured,with,link,set,supported,protocols,string,param,requested,protocols,the,requested,sub,protocols,param,web,socket,handler,the,web,socket,handler,that,will,be,used,return,the,selected,protocols,or,code,null,see,determine,handler,supported,protocols,web,socket,handler;protected,string,select,protocol,list,string,requested,protocols,web,socket,handler,web,socket,handler,if,requested,protocols,null,list,string,handler,protocols,determine,handler,supported,protocols,web,socket,handler,for,string,protocol,requested,protocols,if,handler,protocols,contains,protocol,to,lower,case,return,protocol,if,this,supported,protocols,contains,protocol,to,lower,case,return,protocol,return,null
AbstractHandshakeHandler -> protected String selectProtocol(List<String> requestedProtocols, WebSocketHandler webSocketHandler);1449660404;Perform the sub-protocol negotiation based on requested and supported sub-protocols._For the list of supported sub-protocols, this method first checks if the target_WebSocketHandler is a {@link SubProtocolCapable} and then also checks if any_sub-protocols have been explicitly configured with_{@link #setSupportedProtocols(String...)}._@param requestedProtocols the requested sub-protocols_@param webSocketHandler the WebSocketHandler that will be used_@return the selected protocols or {@code null}_@see #determineHandlerSupportedProtocols(WebSocketHandler);protected String selectProtocol(List<String> requestedProtocols, WebSocketHandler webSocketHandler) {_		if (requestedProtocols != null) {_			List<String> handlerProtocols = determineHandlerSupportedProtocols(webSocketHandler)__			for (String protocol : requestedProtocols) {_				if (handlerProtocols.contains(protocol.toLowerCase())) {_					return protocol__				}_				if (this.supportedProtocols.contains(protocol.toLowerCase())) {_					return protocol__				}_			}_		}_		return null__	};perform,the,sub,protocol,negotiation,based,on,requested,and,supported,sub,protocols,for,the,list,of,supported,sub,protocols,this,method,first,checks,if,the,target,web,socket,handler,is,a,link,sub,protocol,capable,and,then,also,checks,if,any,sub,protocols,have,been,explicitly,configured,with,link,set,supported,protocols,string,param,requested,protocols,the,requested,sub,protocols,param,web,socket,handler,the,web,socket,handler,that,will,be,used,return,the,selected,protocols,or,code,null,see,determine,handler,supported,protocols,web,socket,handler;protected,string,select,protocol,list,string,requested,protocols,web,socket,handler,web,socket,handler,if,requested,protocols,null,list,string,handler,protocols,determine,handler,supported,protocols,web,socket,handler,for,string,protocol,requested,protocols,if,handler,protocols,contains,protocol,to,lower,case,return,protocol,if,this,supported,protocols,contains,protocol,to,lower,case,return,protocol,return,null
AbstractHandshakeHandler -> protected String selectProtocol(List<String> requestedProtocols, WebSocketHandler webSocketHandler);1467730834;Perform the sub-protocol negotiation based on requested and supported sub-protocols._For the list of supported sub-protocols, this method first checks if the target_WebSocketHandler is a {@link SubProtocolCapable} and then also checks if any_sub-protocols have been explicitly configured with_{@link #setSupportedProtocols(String...)}._@param requestedProtocols the requested sub-protocols_@param webSocketHandler the WebSocketHandler that will be used_@return the selected protocols or {@code null}_@see #determineHandlerSupportedProtocols(WebSocketHandler);protected String selectProtocol(List<String> requestedProtocols, WebSocketHandler webSocketHandler) {_		if (requestedProtocols != null) {_			List<String> handlerProtocols = determineHandlerSupportedProtocols(webSocketHandler)__			for (String protocol : requestedProtocols) {_				if (handlerProtocols.contains(protocol.toLowerCase())) {_					return protocol__				}_				if (this.supportedProtocols.contains(protocol.toLowerCase())) {_					return protocol__				}_			}_		}_		return null__	};perform,the,sub,protocol,negotiation,based,on,requested,and,supported,sub,protocols,for,the,list,of,supported,sub,protocols,this,method,first,checks,if,the,target,web,socket,handler,is,a,link,sub,protocol,capable,and,then,also,checks,if,any,sub,protocols,have,been,explicitly,configured,with,link,set,supported,protocols,string,param,requested,protocols,the,requested,sub,protocols,param,web,socket,handler,the,web,socket,handler,that,will,be,used,return,the,selected,protocols,or,code,null,see,determine,handler,supported,protocols,web,socket,handler;protected,string,select,protocol,list,string,requested,protocols,web,socket,handler,web,socket,handler,if,requested,protocols,null,list,string,handler,protocols,determine,handler,supported,protocols,web,socket,handler,for,string,protocol,requested,protocols,if,handler,protocols,contains,protocol,to,lower,case,return,protocol,if,this,supported,protocols,contains,protocol,to,lower,case,return,protocol,return,null
AbstractHandshakeHandler -> protected String selectProtocol(List<String> requestedProtocols, WebSocketHandler webSocketHandler);1468948866;Perform the sub-protocol negotiation based on requested and supported sub-protocols._For the list of supported sub-protocols, this method first checks if the target_WebSocketHandler is a {@link SubProtocolCapable} and then also checks if any_sub-protocols have been explicitly configured with_{@link #setSupportedProtocols(String...)}._@param requestedProtocols the requested sub-protocols_@param webSocketHandler the WebSocketHandler that will be used_@return the selected protocols or {@code null}_@see #determineHandlerSupportedProtocols(WebSocketHandler);protected String selectProtocol(List<String> requestedProtocols, WebSocketHandler webSocketHandler) {_		if (requestedProtocols != null) {_			List<String> handlerProtocols = determineHandlerSupportedProtocols(webSocketHandler)__			for (String protocol : requestedProtocols) {_				if (handlerProtocols.contains(protocol.toLowerCase())) {_					return protocol__				}_				if (this.supportedProtocols.contains(protocol.toLowerCase())) {_					return protocol__				}_			}_		}_		return null__	};perform,the,sub,protocol,negotiation,based,on,requested,and,supported,sub,protocols,for,the,list,of,supported,sub,protocols,this,method,first,checks,if,the,target,web,socket,handler,is,a,link,sub,protocol,capable,and,then,also,checks,if,any,sub,protocols,have,been,explicitly,configured,with,link,set,supported,protocols,string,param,requested,protocols,the,requested,sub,protocols,param,web,socket,handler,the,web,socket,handler,that,will,be,used,return,the,selected,protocols,or,code,null,see,determine,handler,supported,protocols,web,socket,handler;protected,string,select,protocol,list,string,requested,protocols,web,socket,handler,web,socket,handler,if,requested,protocols,null,list,string,handler,protocols,determine,handler,supported,protocols,web,socket,handler,for,string,protocol,requested,protocols,if,handler,protocols,contains,protocol,to,lower,case,return,protocol,if,this,supported,protocols,contains,protocol,to,lower,case,return,protocol,return,null
AbstractHandshakeHandler -> protected String selectProtocol(List<String> requestedProtocols, WebSocketHandler webSocketHandler);1468964586;Perform the sub-protocol negotiation based on requested and supported sub-protocols._For the list of supported sub-protocols, this method first checks if the target_WebSocketHandler is a {@link SubProtocolCapable} and then also checks if any_sub-protocols have been explicitly configured with_{@link #setSupportedProtocols(String...)}._@param requestedProtocols the requested sub-protocols_@param webSocketHandler the WebSocketHandler that will be used_@return the selected protocols or {@code null}_@see #determineHandlerSupportedProtocols(WebSocketHandler);protected String selectProtocol(List<String> requestedProtocols, WebSocketHandler webSocketHandler) {_		if (requestedProtocols != null) {_			List<String> handlerProtocols = determineHandlerSupportedProtocols(webSocketHandler)__			for (String protocol : requestedProtocols) {_				if (handlerProtocols.contains(protocol.toLowerCase())) {_					return protocol__				}_				if (this.supportedProtocols.contains(protocol.toLowerCase())) {_					return protocol__				}_			}_		}_		return null__	};perform,the,sub,protocol,negotiation,based,on,requested,and,supported,sub,protocols,for,the,list,of,supported,sub,protocols,this,method,first,checks,if,the,target,web,socket,handler,is,a,link,sub,protocol,capable,and,then,also,checks,if,any,sub,protocols,have,been,explicitly,configured,with,link,set,supported,protocols,string,param,requested,protocols,the,requested,sub,protocols,param,web,socket,handler,the,web,socket,handler,that,will,be,used,return,the,selected,protocols,or,code,null,see,determine,handler,supported,protocols,web,socket,handler;protected,string,select,protocol,list,string,requested,protocols,web,socket,handler,web,socket,handler,if,requested,protocols,null,list,string,handler,protocols,determine,handler,supported,protocols,web,socket,handler,for,string,protocol,requested,protocols,if,handler,protocols,contains,protocol,to,lower,case,return,protocol,if,this,supported,protocols,contains,protocol,to,lower,case,return,protocol,return,null
AbstractHandshakeHandler -> protected String selectProtocol(List<String> requestedProtocols, WebSocketHandler webSocketHandler);1474905889;Perform the sub-protocol negotiation based on requested and supported sub-protocols._For the list of supported sub-protocols, this method first checks if the target_WebSocketHandler is a {@link SubProtocolCapable} and then also checks if any_sub-protocols have been explicitly configured with_{@link #setSupportedProtocols(String...)}._@param requestedProtocols the requested sub-protocols_@param webSocketHandler the WebSocketHandler that will be used_@return the selected protocols or {@code null}_@see #determineHandlerSupportedProtocols(WebSocketHandler);protected String selectProtocol(List<String> requestedProtocols, WebSocketHandler webSocketHandler) {_		if (requestedProtocols != null) {_			List<String> handlerProtocols = determineHandlerSupportedProtocols(webSocketHandler)__			for (String protocol : requestedProtocols) {_				if (handlerProtocols.contains(protocol.toLowerCase())) {_					return protocol__				}_				if (this.supportedProtocols.contains(protocol.toLowerCase())) {_					return protocol__				}_			}_		}_		return null__	};perform,the,sub,protocol,negotiation,based,on,requested,and,supported,sub,protocols,for,the,list,of,supported,sub,protocols,this,method,first,checks,if,the,target,web,socket,handler,is,a,link,sub,protocol,capable,and,then,also,checks,if,any,sub,protocols,have,been,explicitly,configured,with,link,set,supported,protocols,string,param,requested,protocols,the,requested,sub,protocols,param,web,socket,handler,the,web,socket,handler,that,will,be,used,return,the,selected,protocols,or,code,null,see,determine,handler,supported,protocols,web,socket,handler;protected,string,select,protocol,list,string,requested,protocols,web,socket,handler,web,socket,handler,if,requested,protocols,null,list,string,handler,protocols,determine,handler,supported,protocols,web,socket,handler,for,string,protocol,requested,protocols,if,handler,protocols,contains,protocol,to,lower,case,return,protocol,if,this,supported,protocols,contains,protocol,to,lower,case,return,protocol,return,null
AbstractHandshakeHandler -> @Nullable 	protected String selectProtocol(List<String> requestedProtocols, WebSocketHandler webSocketHandler);1495868221;Perform the sub-protocol negotiation based on requested and supported sub-protocols._For the list of supported sub-protocols, this method first checks if the target_WebSocketHandler is a {@link SubProtocolCapable} and then also checks if any_sub-protocols have been explicitly configured with_{@link #setSupportedProtocols(String...)}._@param requestedProtocols the requested sub-protocols_@param webSocketHandler the WebSocketHandler that will be used_@return the selected protocols or {@code null}_@see #determineHandlerSupportedProtocols(WebSocketHandler);@Nullable_	protected String selectProtocol(List<String> requestedProtocols, WebSocketHandler webSocketHandler) {_		if (requestedProtocols != null) {_			List<String> handlerProtocols = determineHandlerSupportedProtocols(webSocketHandler)__			for (String protocol : requestedProtocols) {_				if (handlerProtocols.contains(protocol.toLowerCase())) {_					return protocol__				}_				if (this.supportedProtocols.contains(protocol.toLowerCase())) {_					return protocol__				}_			}_		}_		return null__	};perform,the,sub,protocol,negotiation,based,on,requested,and,supported,sub,protocols,for,the,list,of,supported,sub,protocols,this,method,first,checks,if,the,target,web,socket,handler,is,a,link,sub,protocol,capable,and,then,also,checks,if,any,sub,protocols,have,been,explicitly,configured,with,link,set,supported,protocols,string,param,requested,protocols,the,requested,sub,protocols,param,web,socket,handler,the,web,socket,handler,that,will,be,used,return,the,selected,protocols,or,code,null,see,determine,handler,supported,protocols,web,socket,handler;nullable,protected,string,select,protocol,list,string,requested,protocols,web,socket,handler,web,socket,handler,if,requested,protocols,null,list,string,handler,protocols,determine,handler,supported,protocols,web,socket,handler,for,string,protocol,requested,protocols,if,handler,protocols,contains,protocol,to,lower,case,return,protocol,if,this,supported,protocols,contains,protocol,to,lower,case,return,protocol,return,null
AbstractHandshakeHandler -> @Nullable 	protected String selectProtocol(List<String> requestedProtocols, WebSocketHandler webSocketHandler);1496837955;Perform the sub-protocol negotiation based on requested and supported sub-protocols._For the list of supported sub-protocols, this method first checks if the target_WebSocketHandler is a {@link SubProtocolCapable} and then also checks if any_sub-protocols have been explicitly configured with_{@link #setSupportedProtocols(String...)}._@param requestedProtocols the requested sub-protocols_@param webSocketHandler the WebSocketHandler that will be used_@return the selected protocols or {@code null}_@see #determineHandlerSupportedProtocols(WebSocketHandler);@Nullable_	protected String selectProtocol(List<String> requestedProtocols, WebSocketHandler webSocketHandler) {_		List<String> handlerProtocols = determineHandlerSupportedProtocols(webSocketHandler)__		for (String protocol : requestedProtocols) {_			if (handlerProtocols.contains(protocol.toLowerCase())) {_				return protocol__			}_			if (this.supportedProtocols.contains(protocol.toLowerCase())) {_				return protocol__			}_		}_		return null__	};perform,the,sub,protocol,negotiation,based,on,requested,and,supported,sub,protocols,for,the,list,of,supported,sub,protocols,this,method,first,checks,if,the,target,web,socket,handler,is,a,link,sub,protocol,capable,and,then,also,checks,if,any,sub,protocols,have,been,explicitly,configured,with,link,set,supported,protocols,string,param,requested,protocols,the,requested,sub,protocols,param,web,socket,handler,the,web,socket,handler,that,will,be,used,return,the,selected,protocols,or,code,null,see,determine,handler,supported,protocols,web,socket,handler;nullable,protected,string,select,protocol,list,string,requested,protocols,web,socket,handler,web,socket,handler,list,string,handler,protocols,determine,handler,supported,protocols,web,socket,handler,for,string,protocol,requested,protocols,if,handler,protocols,contains,protocol,to,lower,case,return,protocol,if,this,supported,protocols,contains,protocol,to,lower,case,return,protocol,return,null
AbstractHandshakeHandler -> @Nullable 	protected String selectProtocol(List<String> requestedProtocols, WebSocketHandler webSocketHandler);1518810557;Perform the sub-protocol negotiation based on requested and supported sub-protocols._For the list of supported sub-protocols, this method first checks if the target_WebSocketHandler is a {@link SubProtocolCapable} and then also checks if any_sub-protocols have been explicitly configured with_{@link #setSupportedProtocols(String...)}._@param requestedProtocols the requested sub-protocols_@param webSocketHandler the WebSocketHandler that will be used_@return the selected protocols or {@code null}_@see #determineHandlerSupportedProtocols(WebSocketHandler);@Nullable_	protected String selectProtocol(List<String> requestedProtocols, WebSocketHandler webSocketHandler) {_		List<String> handlerProtocols = determineHandlerSupportedProtocols(webSocketHandler)__		for (String protocol : requestedProtocols) {_			if (handlerProtocols.contains(protocol.toLowerCase())) {_				return protocol__			}_			if (this.supportedProtocols.contains(protocol.toLowerCase())) {_				return protocol__			}_		}_		return null__	};perform,the,sub,protocol,negotiation,based,on,requested,and,supported,sub,protocols,for,the,list,of,supported,sub,protocols,this,method,first,checks,if,the,target,web,socket,handler,is,a,link,sub,protocol,capable,and,then,also,checks,if,any,sub,protocols,have,been,explicitly,configured,with,link,set,supported,protocols,string,param,requested,protocols,the,requested,sub,protocols,param,web,socket,handler,the,web,socket,handler,that,will,be,used,return,the,selected,protocols,or,code,null,see,determine,handler,supported,protocols,web,socket,handler;nullable,protected,string,select,protocol,list,string,requested,protocols,web,socket,handler,web,socket,handler,list,string,handler,protocols,determine,handler,supported,protocols,web,socket,handler,for,string,protocol,requested,protocols,if,handler,protocols,contains,protocol,to,lower,case,return,protocol,if,this,supported,protocols,contains,protocol,to,lower,case,return,protocol,return,null
AbstractHandshakeHandler -> @Nullable 	protected String selectProtocol(List<String> requestedProtocols, WebSocketHandler webSocketHandler);1521123475;Perform the sub-protocol negotiation based on requested and supported sub-protocols._For the list of supported sub-protocols, this method first checks if the target_WebSocketHandler is a {@link SubProtocolCapable} and then also checks if any_sub-protocols have been explicitly configured with_{@link #setSupportedProtocols(String...)}._@param requestedProtocols the requested sub-protocols_@param webSocketHandler the WebSocketHandler that will be used_@return the selected protocols or {@code null}_@see #determineHandlerSupportedProtocols(WebSocketHandler);@Nullable_	protected String selectProtocol(List<String> requestedProtocols, WebSocketHandler webSocketHandler) {_		List<String> handlerProtocols = determineHandlerSupportedProtocols(webSocketHandler)__		for (String protocol : requestedProtocols) {_			if (handlerProtocols.contains(protocol.toLowerCase())) {_				return protocol__			}_			if (this.supportedProtocols.contains(protocol.toLowerCase())) {_				return protocol__			}_		}_		return null__	};perform,the,sub,protocol,negotiation,based,on,requested,and,supported,sub,protocols,for,the,list,of,supported,sub,protocols,this,method,first,checks,if,the,target,web,socket,handler,is,a,link,sub,protocol,capable,and,then,also,checks,if,any,sub,protocols,have,been,explicitly,configured,with,link,set,supported,protocols,string,param,requested,protocols,the,requested,sub,protocols,param,web,socket,handler,the,web,socket,handler,that,will,be,used,return,the,selected,protocols,or,code,null,see,determine,handler,supported,protocols,web,socket,handler;nullable,protected,string,select,protocol,list,string,requested,protocols,web,socket,handler,web,socket,handler,list,string,handler,protocols,determine,handler,supported,protocols,web,socket,handler,for,string,protocol,requested,protocols,if,handler,protocols,contains,protocol,to,lower,case,return,protocol,if,this,supported,protocols,contains,protocol,to,lower,case,return,protocol,return,null
AbstractHandshakeHandler -> @Nullable 	protected String selectProtocol(List<String> requestedProtocols, WebSocketHandler webSocketHandler);1532509782;Perform the sub-protocol negotiation based on requested and supported sub-protocols._For the list of supported sub-protocols, this method first checks if the target_WebSocketHandler is a {@link SubProtocolCapable} and then also checks if any_sub-protocols have been explicitly configured with_{@link #setSupportedProtocols(String...)}._@param requestedProtocols the requested sub-protocols_@param webSocketHandler the WebSocketHandler that will be used_@return the selected protocols or {@code null}_@see #determineHandlerSupportedProtocols(WebSocketHandler);@Nullable_	protected String selectProtocol(List<String> requestedProtocols, WebSocketHandler webSocketHandler) {_		List<String> handlerProtocols = determineHandlerSupportedProtocols(webSocketHandler)__		for (String protocol : requestedProtocols) {_			if (handlerProtocols.contains(protocol.toLowerCase())) {_				return protocol__			}_			if (this.supportedProtocols.contains(protocol.toLowerCase())) {_				return protocol__			}_		}_		return null__	};perform,the,sub,protocol,negotiation,based,on,requested,and,supported,sub,protocols,for,the,list,of,supported,sub,protocols,this,method,first,checks,if,the,target,web,socket,handler,is,a,link,sub,protocol,capable,and,then,also,checks,if,any,sub,protocols,have,been,explicitly,configured,with,link,set,supported,protocols,string,param,requested,protocols,the,requested,sub,protocols,param,web,socket,handler,the,web,socket,handler,that,will,be,used,return,the,selected,protocols,or,code,null,see,determine,handler,supported,protocols,web,socket,handler;nullable,protected,string,select,protocol,list,string,requested,protocols,web,socket,handler,web,socket,handler,list,string,handler,protocols,determine,handler,supported,protocols,web,socket,handler,for,string,protocol,requested,protocols,if,handler,protocols,contains,protocol,to,lower,case,return,protocol,if,this,supported,protocols,contains,protocol,to,lower,case,return,protocol,return,null
AbstractHandshakeHandler -> protected final List<String> determineHandlerSupportedProtocols(WebSocketHandler handler);1435026644;Determine the sub-protocols supported by the given WebSocketHandler by_checking whether it is an instance of {@link SubProtocolCapable}._@param handler the handler to check_@return a list of supported protocols, or an empty list if none available;protected final List<String> determineHandlerSupportedProtocols(WebSocketHandler handler) {_		WebSocketHandler handlerToCheck = WebSocketHandlerDecorator.unwrap(handler)__		List<String> subProtocols = null__		if (handlerToCheck instanceof SubProtocolCapable) {_			subProtocols = ((SubProtocolCapable) handlerToCheck).getSubProtocols()__		}_		return (subProtocols != null ? subProtocols : Collections.<String>emptyList())__	};determine,the,sub,protocols,supported,by,the,given,web,socket,handler,by,checking,whether,it,is,an,instance,of,link,sub,protocol,capable,param,handler,the,handler,to,check,return,a,list,of,supported,protocols,or,an,empty,list,if,none,available;protected,final,list,string,determine,handler,supported,protocols,web,socket,handler,handler,web,socket,handler,handler,to,check,web,socket,handler,decorator,unwrap,handler,list,string,sub,protocols,null,if,handler,to,check,instanceof,sub,protocol,capable,sub,protocols,sub,protocol,capable,handler,to,check,get,sub,protocols,return,sub,protocols,null,sub,protocols,collections,string,empty,list
AbstractHandshakeHandler -> protected final List<String> determineHandlerSupportedProtocols(WebSocketHandler handler);1439394598;Determine the sub-protocols supported by the given WebSocketHandler by_checking whether it is an instance of {@link SubProtocolCapable}._@param handler the handler to check_@return a list of supported protocols, or an empty list if none available;protected final List<String> determineHandlerSupportedProtocols(WebSocketHandler handler) {_		WebSocketHandler handlerToCheck = WebSocketHandlerDecorator.unwrap(handler)__		List<String> subProtocols = null__		if (handlerToCheck instanceof SubProtocolCapable) {_			subProtocols = ((SubProtocolCapable) handlerToCheck).getSubProtocols()__		}_		return (subProtocols != null ? subProtocols : Collections.<String>emptyList())__	};determine,the,sub,protocols,supported,by,the,given,web,socket,handler,by,checking,whether,it,is,an,instance,of,link,sub,protocol,capable,param,handler,the,handler,to,check,return,a,list,of,supported,protocols,or,an,empty,list,if,none,available;protected,final,list,string,determine,handler,supported,protocols,web,socket,handler,handler,web,socket,handler,handler,to,check,web,socket,handler,decorator,unwrap,handler,list,string,sub,protocols,null,if,handler,to,check,instanceof,sub,protocol,capable,sub,protocols,sub,protocol,capable,handler,to,check,get,sub,protocols,return,sub,protocols,null,sub,protocols,collections,string,empty,list
AbstractHandshakeHandler -> protected final List<String> determineHandlerSupportedProtocols(WebSocketHandler handler);1440705898;Determine the sub-protocols supported by the given WebSocketHandler by_checking whether it is an instance of {@link SubProtocolCapable}._@param handler the handler to check_@return a list of supported protocols, or an empty list if none available;protected final List<String> determineHandlerSupportedProtocols(WebSocketHandler handler) {_		WebSocketHandler handlerToCheck = WebSocketHandlerDecorator.unwrap(handler)__		List<String> subProtocols = null__		if (handlerToCheck instanceof SubProtocolCapable) {_			subProtocols = ((SubProtocolCapable) handlerToCheck).getSubProtocols()__		}_		return (subProtocols != null ? subProtocols : Collections.<String>emptyList())__	};determine,the,sub,protocols,supported,by,the,given,web,socket,handler,by,checking,whether,it,is,an,instance,of,link,sub,protocol,capable,param,handler,the,handler,to,check,return,a,list,of,supported,protocols,or,an,empty,list,if,none,available;protected,final,list,string,determine,handler,supported,protocols,web,socket,handler,handler,web,socket,handler,handler,to,check,web,socket,handler,decorator,unwrap,handler,list,string,sub,protocols,null,if,handler,to,check,instanceof,sub,protocol,capable,sub,protocols,sub,protocol,capable,handler,to,check,get,sub,protocols,return,sub,protocols,null,sub,protocols,collections,string,empty,list
AbstractHandshakeHandler -> protected final List<String> determineHandlerSupportedProtocols(WebSocketHandler handler);1444736364;Determine the sub-protocols supported by the given WebSocketHandler by_checking whether it is an instance of {@link SubProtocolCapable}._@param handler the handler to check_@return a list of supported protocols, or an empty list if none available;protected final List<String> determineHandlerSupportedProtocols(WebSocketHandler handler) {_		WebSocketHandler handlerToCheck = WebSocketHandlerDecorator.unwrap(handler)__		List<String> subProtocols = null__		if (handlerToCheck instanceof SubProtocolCapable) {_			subProtocols = ((SubProtocolCapable) handlerToCheck).getSubProtocols()__		}_		return (subProtocols != null ? subProtocols : Collections.<String>emptyList())__	};determine,the,sub,protocols,supported,by,the,given,web,socket,handler,by,checking,whether,it,is,an,instance,of,link,sub,protocol,capable,param,handler,the,handler,to,check,return,a,list,of,supported,protocols,or,an,empty,list,if,none,available;protected,final,list,string,determine,handler,supported,protocols,web,socket,handler,handler,web,socket,handler,handler,to,check,web,socket,handler,decorator,unwrap,handler,list,string,sub,protocols,null,if,handler,to,check,instanceof,sub,protocol,capable,sub,protocols,sub,protocol,capable,handler,to,check,get,sub,protocols,return,sub,protocols,null,sub,protocols,collections,string,empty,list
AbstractHandshakeHandler -> protected final List<String> determineHandlerSupportedProtocols(WebSocketHandler handler);1449660404;Determine the sub-protocols supported by the given WebSocketHandler by_checking whether it is an instance of {@link SubProtocolCapable}._@param handler the handler to check_@return a list of supported protocols, or an empty list if none available;protected final List<String> determineHandlerSupportedProtocols(WebSocketHandler handler) {_		WebSocketHandler handlerToCheck = WebSocketHandlerDecorator.unwrap(handler)__		List<String> subProtocols = null__		if (handlerToCheck instanceof SubProtocolCapable) {_			subProtocols = ((SubProtocolCapable) handlerToCheck).getSubProtocols()__		}_		return (subProtocols != null ? subProtocols : Collections.<String>emptyList())__	};determine,the,sub,protocols,supported,by,the,given,web,socket,handler,by,checking,whether,it,is,an,instance,of,link,sub,protocol,capable,param,handler,the,handler,to,check,return,a,list,of,supported,protocols,or,an,empty,list,if,none,available;protected,final,list,string,determine,handler,supported,protocols,web,socket,handler,handler,web,socket,handler,handler,to,check,web,socket,handler,decorator,unwrap,handler,list,string,sub,protocols,null,if,handler,to,check,instanceof,sub,protocol,capable,sub,protocols,sub,protocol,capable,handler,to,check,get,sub,protocols,return,sub,protocols,null,sub,protocols,collections,string,empty,list
AbstractHandshakeHandler -> protected final List<String> determineHandlerSupportedProtocols(WebSocketHandler handler);1467730834;Determine the sub-protocols supported by the given WebSocketHandler by_checking whether it is an instance of {@link SubProtocolCapable}._@param handler the handler to check_@return a list of supported protocols, or an empty list if none available;protected final List<String> determineHandlerSupportedProtocols(WebSocketHandler handler) {_		WebSocketHandler handlerToCheck = WebSocketHandlerDecorator.unwrap(handler)__		List<String> subProtocols = null__		if (handlerToCheck instanceof SubProtocolCapable) {_			subProtocols = ((SubProtocolCapable) handlerToCheck).getSubProtocols()__		}_		return (subProtocols != null ? subProtocols : Collections.<String>emptyList())__	};determine,the,sub,protocols,supported,by,the,given,web,socket,handler,by,checking,whether,it,is,an,instance,of,link,sub,protocol,capable,param,handler,the,handler,to,check,return,a,list,of,supported,protocols,or,an,empty,list,if,none,available;protected,final,list,string,determine,handler,supported,protocols,web,socket,handler,handler,web,socket,handler,handler,to,check,web,socket,handler,decorator,unwrap,handler,list,string,sub,protocols,null,if,handler,to,check,instanceof,sub,protocol,capable,sub,protocols,sub,protocol,capable,handler,to,check,get,sub,protocols,return,sub,protocols,null,sub,protocols,collections,string,empty,list
AbstractHandshakeHandler -> protected final List<String> determineHandlerSupportedProtocols(WebSocketHandler handler);1468948866;Determine the sub-protocols supported by the given WebSocketHandler by_checking whether it is an instance of {@link SubProtocolCapable}._@param handler the handler to check_@return a list of supported protocols, or an empty list if none available;protected final List<String> determineHandlerSupportedProtocols(WebSocketHandler handler) {_		WebSocketHandler handlerToCheck = WebSocketHandlerDecorator.unwrap(handler)__		List<String> subProtocols = null__		if (handlerToCheck instanceof SubProtocolCapable) {_			subProtocols = ((SubProtocolCapable) handlerToCheck).getSubProtocols()__		}_		return (subProtocols != null ? subProtocols : Collections.<String>emptyList())__	};determine,the,sub,protocols,supported,by,the,given,web,socket,handler,by,checking,whether,it,is,an,instance,of,link,sub,protocol,capable,param,handler,the,handler,to,check,return,a,list,of,supported,protocols,or,an,empty,list,if,none,available;protected,final,list,string,determine,handler,supported,protocols,web,socket,handler,handler,web,socket,handler,handler,to,check,web,socket,handler,decorator,unwrap,handler,list,string,sub,protocols,null,if,handler,to,check,instanceof,sub,protocol,capable,sub,protocols,sub,protocol,capable,handler,to,check,get,sub,protocols,return,sub,protocols,null,sub,protocols,collections,string,empty,list
AbstractHandshakeHandler -> protected final List<String> determineHandlerSupportedProtocols(WebSocketHandler handler);1468964586;Determine the sub-protocols supported by the given WebSocketHandler by_checking whether it is an instance of {@link SubProtocolCapable}._@param handler the handler to check_@return a list of supported protocols, or an empty list if none available;protected final List<String> determineHandlerSupportedProtocols(WebSocketHandler handler) {_		WebSocketHandler handlerToCheck = WebSocketHandlerDecorator.unwrap(handler)__		List<String> subProtocols = null__		if (handlerToCheck instanceof SubProtocolCapable) {_			subProtocols = ((SubProtocolCapable) handlerToCheck).getSubProtocols()__		}_		return (subProtocols != null ? subProtocols : Collections.<String>emptyList())__	};determine,the,sub,protocols,supported,by,the,given,web,socket,handler,by,checking,whether,it,is,an,instance,of,link,sub,protocol,capable,param,handler,the,handler,to,check,return,a,list,of,supported,protocols,or,an,empty,list,if,none,available;protected,final,list,string,determine,handler,supported,protocols,web,socket,handler,handler,web,socket,handler,handler,to,check,web,socket,handler,decorator,unwrap,handler,list,string,sub,protocols,null,if,handler,to,check,instanceof,sub,protocol,capable,sub,protocols,sub,protocol,capable,handler,to,check,get,sub,protocols,return,sub,protocols,null,sub,protocols,collections,string,empty,list
AbstractHandshakeHandler -> protected final List<String> determineHandlerSupportedProtocols(WebSocketHandler handler);1474905889;Determine the sub-protocols supported by the given WebSocketHandler by_checking whether it is an instance of {@link SubProtocolCapable}._@param handler the handler to check_@return a list of supported protocols, or an empty list if none available;protected final List<String> determineHandlerSupportedProtocols(WebSocketHandler handler) {_		WebSocketHandler handlerToCheck = WebSocketHandlerDecorator.unwrap(handler)__		List<String> subProtocols = null__		if (handlerToCheck instanceof SubProtocolCapable) {_			subProtocols = ((SubProtocolCapable) handlerToCheck).getSubProtocols()__		}_		return (subProtocols != null ? subProtocols : Collections.emptyList())__	};determine,the,sub,protocols,supported,by,the,given,web,socket,handler,by,checking,whether,it,is,an,instance,of,link,sub,protocol,capable,param,handler,the,handler,to,check,return,a,list,of,supported,protocols,or,an,empty,list,if,none,available;protected,final,list,string,determine,handler,supported,protocols,web,socket,handler,handler,web,socket,handler,handler,to,check,web,socket,handler,decorator,unwrap,handler,list,string,sub,protocols,null,if,handler,to,check,instanceof,sub,protocol,capable,sub,protocols,sub,protocol,capable,handler,to,check,get,sub,protocols,return,sub,protocols,null,sub,protocols,collections,empty,list
AbstractHandshakeHandler -> protected final List<String> determineHandlerSupportedProtocols(WebSocketHandler handler);1495868221;Determine the sub-protocols supported by the given WebSocketHandler by_checking whether it is an instance of {@link SubProtocolCapable}._@param handler the handler to check_@return a list of supported protocols, or an empty list if none available;protected final List<String> determineHandlerSupportedProtocols(WebSocketHandler handler) {_		WebSocketHandler handlerToCheck = WebSocketHandlerDecorator.unwrap(handler)__		List<String> subProtocols = null__		if (handlerToCheck instanceof SubProtocolCapable) {_			subProtocols = ((SubProtocolCapable) handlerToCheck).getSubProtocols()__		}_		return (subProtocols != null ? subProtocols : Collections.emptyList())__	};determine,the,sub,protocols,supported,by,the,given,web,socket,handler,by,checking,whether,it,is,an,instance,of,link,sub,protocol,capable,param,handler,the,handler,to,check,return,a,list,of,supported,protocols,or,an,empty,list,if,none,available;protected,final,list,string,determine,handler,supported,protocols,web,socket,handler,handler,web,socket,handler,handler,to,check,web,socket,handler,decorator,unwrap,handler,list,string,sub,protocols,null,if,handler,to,check,instanceof,sub,protocol,capable,sub,protocols,sub,protocol,capable,handler,to,check,get,sub,protocols,return,sub,protocols,null,sub,protocols,collections,empty,list
AbstractHandshakeHandler -> protected final List<String> determineHandlerSupportedProtocols(WebSocketHandler handler);1496837955;Determine the sub-protocols supported by the given WebSocketHandler by_checking whether it is an instance of {@link SubProtocolCapable}._@param handler the handler to check_@return a list of supported protocols, or an empty list if none available;protected final List<String> determineHandlerSupportedProtocols(WebSocketHandler handler) {_		WebSocketHandler handlerToCheck = WebSocketHandlerDecorator.unwrap(handler)__		List<String> subProtocols = null__		if (handlerToCheck instanceof SubProtocolCapable) {_			subProtocols = ((SubProtocolCapable) handlerToCheck).getSubProtocols()__		}_		return (subProtocols != null ? subProtocols : Collections.emptyList())__	};determine,the,sub,protocols,supported,by,the,given,web,socket,handler,by,checking,whether,it,is,an,instance,of,link,sub,protocol,capable,param,handler,the,handler,to,check,return,a,list,of,supported,protocols,or,an,empty,list,if,none,available;protected,final,list,string,determine,handler,supported,protocols,web,socket,handler,handler,web,socket,handler,handler,to,check,web,socket,handler,decorator,unwrap,handler,list,string,sub,protocols,null,if,handler,to,check,instanceof,sub,protocol,capable,sub,protocols,sub,protocol,capable,handler,to,check,get,sub,protocols,return,sub,protocols,null,sub,protocols,collections,empty,list
AbstractHandshakeHandler -> protected final List<String> determineHandlerSupportedProtocols(WebSocketHandler handler);1518810557;Determine the sub-protocols supported by the given WebSocketHandler by_checking whether it is an instance of {@link SubProtocolCapable}._@param handler the handler to check_@return a list of supported protocols, or an empty list if none available;protected final List<String> determineHandlerSupportedProtocols(WebSocketHandler handler) {_		WebSocketHandler handlerToCheck = WebSocketHandlerDecorator.unwrap(handler)__		List<String> subProtocols = null__		if (handlerToCheck instanceof SubProtocolCapable) {_			subProtocols = ((SubProtocolCapable) handlerToCheck).getSubProtocols()__		}_		return (subProtocols != null ? subProtocols : Collections.emptyList())__	};determine,the,sub,protocols,supported,by,the,given,web,socket,handler,by,checking,whether,it,is,an,instance,of,link,sub,protocol,capable,param,handler,the,handler,to,check,return,a,list,of,supported,protocols,or,an,empty,list,if,none,available;protected,final,list,string,determine,handler,supported,protocols,web,socket,handler,handler,web,socket,handler,handler,to,check,web,socket,handler,decorator,unwrap,handler,list,string,sub,protocols,null,if,handler,to,check,instanceof,sub,protocol,capable,sub,protocols,sub,protocol,capable,handler,to,check,get,sub,protocols,return,sub,protocols,null,sub,protocols,collections,empty,list
AbstractHandshakeHandler -> protected final List<String> determineHandlerSupportedProtocols(WebSocketHandler handler);1521123475;Determine the sub-protocols supported by the given WebSocketHandler by_checking whether it is an instance of {@link SubProtocolCapable}._@param handler the handler to check_@return a list of supported protocols, or an empty list if none available;protected final List<String> determineHandlerSupportedProtocols(WebSocketHandler handler) {_		WebSocketHandler handlerToCheck = WebSocketHandlerDecorator.unwrap(handler)__		List<String> subProtocols = null__		if (handlerToCheck instanceof SubProtocolCapable) {_			subProtocols = ((SubProtocolCapable) handlerToCheck).getSubProtocols()__		}_		return (subProtocols != null ? subProtocols : Collections.emptyList())__	};determine,the,sub,protocols,supported,by,the,given,web,socket,handler,by,checking,whether,it,is,an,instance,of,link,sub,protocol,capable,param,handler,the,handler,to,check,return,a,list,of,supported,protocols,or,an,empty,list,if,none,available;protected,final,list,string,determine,handler,supported,protocols,web,socket,handler,handler,web,socket,handler,handler,to,check,web,socket,handler,decorator,unwrap,handler,list,string,sub,protocols,null,if,handler,to,check,instanceof,sub,protocol,capable,sub,protocols,sub,protocol,capable,handler,to,check,get,sub,protocols,return,sub,protocols,null,sub,protocols,collections,empty,list
AbstractHandshakeHandler -> protected final List<String> determineHandlerSupportedProtocols(WebSocketHandler handler);1532509782;Determine the sub-protocols supported by the given WebSocketHandler by_checking whether it is an instance of {@link SubProtocolCapable}._@param handler the handler to check_@return a list of supported protocols, or an empty list if none available;protected final List<String> determineHandlerSupportedProtocols(WebSocketHandler handler) {_		WebSocketHandler handlerToCheck = WebSocketHandlerDecorator.unwrap(handler)__		List<String> subProtocols = null__		if (handlerToCheck instanceof SubProtocolCapable) {_			subProtocols = ((SubProtocolCapable) handlerToCheck).getSubProtocols()__		}_		return (subProtocols != null ? subProtocols : Collections.emptyList())__	};determine,the,sub,protocols,supported,by,the,given,web,socket,handler,by,checking,whether,it,is,an,instance,of,link,sub,protocol,capable,param,handler,the,handler,to,check,return,a,list,of,supported,protocols,or,an,empty,list,if,none,available;protected,final,list,string,determine,handler,supported,protocols,web,socket,handler,handler,web,socket,handler,handler,to,check,web,socket,handler,decorator,unwrap,handler,list,string,sub,protocols,null,if,handler,to,check,instanceof,sub,protocol,capable,sub,protocols,sub,protocol,capable,handler,to,check,get,sub,protocols,return,sub,protocols,null,sub,protocols,collections,empty,list
AbstractHandshakeHandler -> @Nullable 	protected Principal determineUser(ServerHttpRequest request, WebSocketHandler wsHandler, 			Map<String, Object> attributes);1495868221;A method that can be used to associate a user with the WebSocket session_in the process of being established. The default implementation calls_{@link ServerHttpRequest#getPrincipal()}_<p>Subclasses can provide custom logic for associating a user with a session,_for example for assigning a name to anonymous users (i.e. not fully authenticated)._@param request the handshake request_@param wsHandler the WebSocket handler that will handle messages_@param attributes handshake attributes to pass to the WebSocket session_@return the user for the WebSocket session, or {@code null} if not available;@Nullable_	protected Principal determineUser(ServerHttpRequest request, WebSocketHandler wsHandler,_			Map<String, Object> attributes) {__		return request.getPrincipal()__	};a,method,that,can,be,used,to,associate,a,user,with,the,web,socket,session,in,the,process,of,being,established,the,default,implementation,calls,link,server,http,request,get,principal,p,subclasses,can,provide,custom,logic,for,associating,a,user,with,a,session,for,example,for,assigning,a,name,to,anonymous,users,i,e,not,fully,authenticated,param,request,the,handshake,request,param,ws,handler,the,web,socket,handler,that,will,handle,messages,param,attributes,handshake,attributes,to,pass,to,the,web,socket,session,return,the,user,for,the,web,socket,session,or,code,null,if,not,available;nullable,protected,principal,determine,user,server,http,request,request,web,socket,handler,ws,handler,map,string,object,attributes,return,request,get,principal
AbstractHandshakeHandler -> @Nullable 	protected Principal determineUser(ServerHttpRequest request, WebSocketHandler wsHandler, 			Map<String, Object> attributes);1496837955;A method that can be used to associate a user with the WebSocket session_in the process of being established. The default implementation calls_{@link ServerHttpRequest#getPrincipal()}_<p>Subclasses can provide custom logic for associating a user with a session,_for example for assigning a name to anonymous users (i.e. not fully authenticated)._@param request the handshake request_@param wsHandler the WebSocket handler that will handle messages_@param attributes handshake attributes to pass to the WebSocket session_@return the user for the WebSocket session, or {@code null} if not available;@Nullable_	protected Principal determineUser(ServerHttpRequest request, WebSocketHandler wsHandler,_			Map<String, Object> attributes) {__		return request.getPrincipal()__	};a,method,that,can,be,used,to,associate,a,user,with,the,web,socket,session,in,the,process,of,being,established,the,default,implementation,calls,link,server,http,request,get,principal,p,subclasses,can,provide,custom,logic,for,associating,a,user,with,a,session,for,example,for,assigning,a,name,to,anonymous,users,i,e,not,fully,authenticated,param,request,the,handshake,request,param,ws,handler,the,web,socket,handler,that,will,handle,messages,param,attributes,handshake,attributes,to,pass,to,the,web,socket,session,return,the,user,for,the,web,socket,session,or,code,null,if,not,available;nullable,protected,principal,determine,user,server,http,request,request,web,socket,handler,ws,handler,map,string,object,attributes,return,request,get,principal
AbstractHandshakeHandler -> @Nullable 	protected Principal determineUser( 			ServerHttpRequest request, WebSocketHandler wsHandler, Map<String, Object> attributes);1518810557;A method that can be used to associate a user with the WebSocket session_in the process of being established. The default implementation calls_{@link ServerHttpRequest#getPrincipal()}_<p>Subclasses can provide custom logic for associating a user with a session,_for example for assigning a name to anonymous users (i.e. not fully authenticated)._@param request the handshake request_@param wsHandler the WebSocket handler that will handle messages_@param attributes handshake attributes to pass to the WebSocket session_@return the user for the WebSocket session, or {@code null} if not available;@Nullable_	protected Principal determineUser(_			ServerHttpRequest request, WebSocketHandler wsHandler, Map<String, Object> attributes) {__		return request.getPrincipal()__	};a,method,that,can,be,used,to,associate,a,user,with,the,web,socket,session,in,the,process,of,being,established,the,default,implementation,calls,link,server,http,request,get,principal,p,subclasses,can,provide,custom,logic,for,associating,a,user,with,a,session,for,example,for,assigning,a,name,to,anonymous,users,i,e,not,fully,authenticated,param,request,the,handshake,request,param,ws,handler,the,web,socket,handler,that,will,handle,messages,param,attributes,handshake,attributes,to,pass,to,the,web,socket,session,return,the,user,for,the,web,socket,session,or,code,null,if,not,available;nullable,protected,principal,determine,user,server,http,request,request,web,socket,handler,ws,handler,map,string,object,attributes,return,request,get,principal
AbstractHandshakeHandler -> @Nullable 	protected Principal determineUser( 			ServerHttpRequest request, WebSocketHandler wsHandler, Map<String, Object> attributes);1521123475;A method that can be used to associate a user with the WebSocket session_in the process of being established. The default implementation calls_{@link ServerHttpRequest#getPrincipal()}_<p>Subclasses can provide custom logic for associating a user with a session,_for example for assigning a name to anonymous users (i.e. not fully authenticated)._@param request the handshake request_@param wsHandler the WebSocket handler that will handle messages_@param attributes handshake attributes to pass to the WebSocket session_@return the user for the WebSocket session, or {@code null} if not available;@Nullable_	protected Principal determineUser(_			ServerHttpRequest request, WebSocketHandler wsHandler, Map<String, Object> attributes) {__		return request.getPrincipal()__	};a,method,that,can,be,used,to,associate,a,user,with,the,web,socket,session,in,the,process,of,being,established,the,default,implementation,calls,link,server,http,request,get,principal,p,subclasses,can,provide,custom,logic,for,associating,a,user,with,a,session,for,example,for,assigning,a,name,to,anonymous,users,i,e,not,fully,authenticated,param,request,the,handshake,request,param,ws,handler,the,web,socket,handler,that,will,handle,messages,param,attributes,handshake,attributes,to,pass,to,the,web,socket,session,return,the,user,for,the,web,socket,session,or,code,null,if,not,available;nullable,protected,principal,determine,user,server,http,request,request,web,socket,handler,ws,handler,map,string,object,attributes,return,request,get,principal
AbstractHandshakeHandler -> @Nullable 	protected Principal determineUser( 			ServerHttpRequest request, WebSocketHandler wsHandler, Map<String, Object> attributes);1532509782;A method that can be used to associate a user with the WebSocket session_in the process of being established. The default implementation calls_{@link ServerHttpRequest#getPrincipal()}_<p>Subclasses can provide custom logic for associating a user with a session,_for example for assigning a name to anonymous users (i.e. not fully authenticated)._@param request the handshake request_@param wsHandler the WebSocket handler that will handle messages_@param attributes handshake attributes to pass to the WebSocket session_@return the user for the WebSocket session, or {@code null} if not available;@Nullable_	protected Principal determineUser(_			ServerHttpRequest request, WebSocketHandler wsHandler, Map<String, Object> attributes) {__		return request.getPrincipal()__	};a,method,that,can,be,used,to,associate,a,user,with,the,web,socket,session,in,the,process,of,being,established,the,default,implementation,calls,link,server,http,request,get,principal,p,subclasses,can,provide,custom,logic,for,associating,a,user,with,a,session,for,example,for,assigning,a,name,to,anonymous,users,i,e,not,fully,authenticated,param,request,the,handshake,request,param,ws,handler,the,web,socket,handler,that,will,handle,messages,param,attributes,handshake,attributes,to,pass,to,the,web,socket,session,return,the,user,for,the,web,socket,session,or,code,null,if,not,available;nullable,protected,principal,determine,user,server,http,request,request,web,socket,handler,ws,handler,map,string,object,attributes,return,request,get,principal
AbstractHandshakeHandler -> protected AbstractHandshakeHandler();1435026644;Default constructor that auto-detects and instantiates a_{@link RequestUpgradeStrategy} suitable for the runtime container._@throws IllegalStateException if no {@link RequestUpgradeStrategy} can be found.;protected AbstractHandshakeHandler() {_		this(initRequestUpgradeStrategy())__	};default,constructor,that,auto,detects,and,instantiates,a,link,request,upgrade,strategy,suitable,for,the,runtime,container,throws,illegal,state,exception,if,no,link,request,upgrade,strategy,can,be,found;protected,abstract,handshake,handler,this,init,request,upgrade,strategy
AbstractHandshakeHandler -> protected AbstractHandshakeHandler();1439394598;Default constructor that auto-detects and instantiates a_{@link RequestUpgradeStrategy} suitable for the runtime container._@throws IllegalStateException if no {@link RequestUpgradeStrategy} can be found.;protected AbstractHandshakeHandler() {_		this(initRequestUpgradeStrategy())__	};default,constructor,that,auto,detects,and,instantiates,a,link,request,upgrade,strategy,suitable,for,the,runtime,container,throws,illegal,state,exception,if,no,link,request,upgrade,strategy,can,be,found;protected,abstract,handshake,handler,this,init,request,upgrade,strategy
AbstractHandshakeHandler -> protected AbstractHandshakeHandler();1440705898;Default constructor that auto-detects and instantiates a_{@link RequestUpgradeStrategy} suitable for the runtime container._@throws IllegalStateException if no {@link RequestUpgradeStrategy} can be found.;protected AbstractHandshakeHandler() {_		this(initRequestUpgradeStrategy())__	};default,constructor,that,auto,detects,and,instantiates,a,link,request,upgrade,strategy,suitable,for,the,runtime,container,throws,illegal,state,exception,if,no,link,request,upgrade,strategy,can,be,found;protected,abstract,handshake,handler,this,init,request,upgrade,strategy
AbstractHandshakeHandler -> protected AbstractHandshakeHandler();1444736364;Default constructor that auto-detects and instantiates a_{@link RequestUpgradeStrategy} suitable for the runtime container._@throws IllegalStateException if no {@link RequestUpgradeStrategy} can be found.;protected AbstractHandshakeHandler() {_		this(initRequestUpgradeStrategy())__	};default,constructor,that,auto,detects,and,instantiates,a,link,request,upgrade,strategy,suitable,for,the,runtime,container,throws,illegal,state,exception,if,no,link,request,upgrade,strategy,can,be,found;protected,abstract,handshake,handler,this,init,request,upgrade,strategy
AbstractHandshakeHandler -> protected AbstractHandshakeHandler();1449660404;Default constructor that auto-detects and instantiates a_{@link RequestUpgradeStrategy} suitable for the runtime container._@throws IllegalStateException if no {@link RequestUpgradeStrategy} can be found.;protected AbstractHandshakeHandler() {_		this(initRequestUpgradeStrategy())__	};default,constructor,that,auto,detects,and,instantiates,a,link,request,upgrade,strategy,suitable,for,the,runtime,container,throws,illegal,state,exception,if,no,link,request,upgrade,strategy,can,be,found;protected,abstract,handshake,handler,this,init,request,upgrade,strategy
AbstractHandshakeHandler -> protected AbstractHandshakeHandler();1467730834;Default constructor that auto-detects and instantiates a_{@link RequestUpgradeStrategy} suitable for the runtime container._@throws IllegalStateException if no {@link RequestUpgradeStrategy} can be found.;protected AbstractHandshakeHandler() {_		this(initRequestUpgradeStrategy())__	};default,constructor,that,auto,detects,and,instantiates,a,link,request,upgrade,strategy,suitable,for,the,runtime,container,throws,illegal,state,exception,if,no,link,request,upgrade,strategy,can,be,found;protected,abstract,handshake,handler,this,init,request,upgrade,strategy
AbstractHandshakeHandler -> protected AbstractHandshakeHandler();1468948866;Default constructor that auto-detects and instantiates a_{@link RequestUpgradeStrategy} suitable for the runtime container._@throws IllegalStateException if no {@link RequestUpgradeStrategy} can be found.;protected AbstractHandshakeHandler() {_		this(initRequestUpgradeStrategy())__	};default,constructor,that,auto,detects,and,instantiates,a,link,request,upgrade,strategy,suitable,for,the,runtime,container,throws,illegal,state,exception,if,no,link,request,upgrade,strategy,can,be,found;protected,abstract,handshake,handler,this,init,request,upgrade,strategy
AbstractHandshakeHandler -> protected AbstractHandshakeHandler();1468964586;Default constructor that auto-detects and instantiates a_{@link RequestUpgradeStrategy} suitable for the runtime container._@throws IllegalStateException if no {@link RequestUpgradeStrategy} can be found.;protected AbstractHandshakeHandler() {_		this(initRequestUpgradeStrategy())__	};default,constructor,that,auto,detects,and,instantiates,a,link,request,upgrade,strategy,suitable,for,the,runtime,container,throws,illegal,state,exception,if,no,link,request,upgrade,strategy,can,be,found;protected,abstract,handshake,handler,this,init,request,upgrade,strategy
AbstractHandshakeHandler -> protected AbstractHandshakeHandler();1474905889;Default constructor that auto-detects and instantiates a_{@link RequestUpgradeStrategy} suitable for the runtime container._@throws IllegalStateException if no {@link RequestUpgradeStrategy} can be found.;protected AbstractHandshakeHandler() {_		this(initRequestUpgradeStrategy())__	};default,constructor,that,auto,detects,and,instantiates,a,link,request,upgrade,strategy,suitable,for,the,runtime,container,throws,illegal,state,exception,if,no,link,request,upgrade,strategy,can,be,found;protected,abstract,handshake,handler,this,init,request,upgrade,strategy
AbstractHandshakeHandler -> protected AbstractHandshakeHandler();1495868221;Default constructor that auto-detects and instantiates a_{@link RequestUpgradeStrategy} suitable for the runtime container._@throws IllegalStateException if no {@link RequestUpgradeStrategy} can be found.;protected AbstractHandshakeHandler() {_		this(initRequestUpgradeStrategy())__	};default,constructor,that,auto,detects,and,instantiates,a,link,request,upgrade,strategy,suitable,for,the,runtime,container,throws,illegal,state,exception,if,no,link,request,upgrade,strategy,can,be,found;protected,abstract,handshake,handler,this,init,request,upgrade,strategy
AbstractHandshakeHandler -> protected AbstractHandshakeHandler();1496837955;Default constructor that auto-detects and instantiates a_{@link RequestUpgradeStrategy} suitable for the runtime container._@throws IllegalStateException if no {@link RequestUpgradeStrategy} can be found.;protected AbstractHandshakeHandler() {_		this(initRequestUpgradeStrategy())__	};default,constructor,that,auto,detects,and,instantiates,a,link,request,upgrade,strategy,suitable,for,the,runtime,container,throws,illegal,state,exception,if,no,link,request,upgrade,strategy,can,be,found;protected,abstract,handshake,handler,this,init,request,upgrade,strategy
AbstractHandshakeHandler -> protected AbstractHandshakeHandler();1518810557;Default constructor that auto-detects and instantiates a_{@link RequestUpgradeStrategy} suitable for the runtime container._@throws IllegalStateException if no {@link RequestUpgradeStrategy} can be found.;protected AbstractHandshakeHandler() {_		this(initRequestUpgradeStrategy())__	};default,constructor,that,auto,detects,and,instantiates,a,link,request,upgrade,strategy,suitable,for,the,runtime,container,throws,illegal,state,exception,if,no,link,request,upgrade,strategy,can,be,found;protected,abstract,handshake,handler,this,init,request,upgrade,strategy
AbstractHandshakeHandler -> protected AbstractHandshakeHandler();1521123475;Default constructor that auto-detects and instantiates a_{@link RequestUpgradeStrategy} suitable for the runtime container._@throws IllegalStateException if no {@link RequestUpgradeStrategy} can be found.;protected AbstractHandshakeHandler() {_		this(initRequestUpgradeStrategy())__	};default,constructor,that,auto,detects,and,instantiates,a,link,request,upgrade,strategy,suitable,for,the,runtime,container,throws,illegal,state,exception,if,no,link,request,upgrade,strategy,can,be,found;protected,abstract,handshake,handler,this,init,request,upgrade,strategy
AbstractHandshakeHandler -> protected AbstractHandshakeHandler();1532509782;Default constructor that auto-detects and instantiates a_{@link RequestUpgradeStrategy} suitable for the runtime container._@throws IllegalStateException if no {@link RequestUpgradeStrategy} can be found.;protected AbstractHandshakeHandler() {_		this(initRequestUpgradeStrategy())__	};default,constructor,that,auto,detects,and,instantiates,a,link,request,upgrade,strategy,suitable,for,the,runtime,container,throws,illegal,state,exception,if,no,link,request,upgrade,strategy,can,be,found;protected,abstract,handshake,handler,this,init,request,upgrade,strategy
AbstractHandshakeHandler -> protected AbstractHandshakeHandler(RequestUpgradeStrategy requestUpgradeStrategy);1435026644;A constructor that accepts a runtime-specific {@link RequestUpgradeStrategy}._@param requestUpgradeStrategy the upgrade strategy to use;protected AbstractHandshakeHandler(RequestUpgradeStrategy requestUpgradeStrategy) {_		Assert.notNull(requestUpgradeStrategy, "RequestUpgradeStrategy must not be null")__		this.requestUpgradeStrategy = requestUpgradeStrategy__	};a,constructor,that,accepts,a,runtime,specific,link,request,upgrade,strategy,param,request,upgrade,strategy,the,upgrade,strategy,to,use;protected,abstract,handshake,handler,request,upgrade,strategy,request,upgrade,strategy,assert,not,null,request,upgrade,strategy,request,upgrade,strategy,must,not,be,null,this,request,upgrade,strategy,request,upgrade,strategy
AbstractHandshakeHandler -> protected AbstractHandshakeHandler(RequestUpgradeStrategy requestUpgradeStrategy);1439394598;A constructor that accepts a runtime-specific {@link RequestUpgradeStrategy}._@param requestUpgradeStrategy the upgrade strategy to use;protected AbstractHandshakeHandler(RequestUpgradeStrategy requestUpgradeStrategy) {_		Assert.notNull(requestUpgradeStrategy, "RequestUpgradeStrategy must not be null")__		this.requestUpgradeStrategy = requestUpgradeStrategy__	};a,constructor,that,accepts,a,runtime,specific,link,request,upgrade,strategy,param,request,upgrade,strategy,the,upgrade,strategy,to,use;protected,abstract,handshake,handler,request,upgrade,strategy,request,upgrade,strategy,assert,not,null,request,upgrade,strategy,request,upgrade,strategy,must,not,be,null,this,request,upgrade,strategy,request,upgrade,strategy
AbstractHandshakeHandler -> protected AbstractHandshakeHandler(RequestUpgradeStrategy requestUpgradeStrategy);1440705898;A constructor that accepts a runtime-specific {@link RequestUpgradeStrategy}._@param requestUpgradeStrategy the upgrade strategy to use;protected AbstractHandshakeHandler(RequestUpgradeStrategy requestUpgradeStrategy) {_		Assert.notNull(requestUpgradeStrategy, "RequestUpgradeStrategy must not be null")__		this.requestUpgradeStrategy = requestUpgradeStrategy__	};a,constructor,that,accepts,a,runtime,specific,link,request,upgrade,strategy,param,request,upgrade,strategy,the,upgrade,strategy,to,use;protected,abstract,handshake,handler,request,upgrade,strategy,request,upgrade,strategy,assert,not,null,request,upgrade,strategy,request,upgrade,strategy,must,not,be,null,this,request,upgrade,strategy,request,upgrade,strategy
AbstractHandshakeHandler -> protected AbstractHandshakeHandler(RequestUpgradeStrategy requestUpgradeStrategy);1444736364;A constructor that accepts a runtime-specific {@link RequestUpgradeStrategy}._@param requestUpgradeStrategy the upgrade strategy to use;protected AbstractHandshakeHandler(RequestUpgradeStrategy requestUpgradeStrategy) {_		Assert.notNull(requestUpgradeStrategy, "RequestUpgradeStrategy must not be null")__		this.requestUpgradeStrategy = requestUpgradeStrategy__	};a,constructor,that,accepts,a,runtime,specific,link,request,upgrade,strategy,param,request,upgrade,strategy,the,upgrade,strategy,to,use;protected,abstract,handshake,handler,request,upgrade,strategy,request,upgrade,strategy,assert,not,null,request,upgrade,strategy,request,upgrade,strategy,must,not,be,null,this,request,upgrade,strategy,request,upgrade,strategy
AbstractHandshakeHandler -> protected AbstractHandshakeHandler(RequestUpgradeStrategy requestUpgradeStrategy);1449660404;A constructor that accepts a runtime-specific {@link RequestUpgradeStrategy}._@param requestUpgradeStrategy the upgrade strategy to use;protected AbstractHandshakeHandler(RequestUpgradeStrategy requestUpgradeStrategy) {_		Assert.notNull(requestUpgradeStrategy, "RequestUpgradeStrategy must not be null")__		this.requestUpgradeStrategy = requestUpgradeStrategy__	};a,constructor,that,accepts,a,runtime,specific,link,request,upgrade,strategy,param,request,upgrade,strategy,the,upgrade,strategy,to,use;protected,abstract,handshake,handler,request,upgrade,strategy,request,upgrade,strategy,assert,not,null,request,upgrade,strategy,request,upgrade,strategy,must,not,be,null,this,request,upgrade,strategy,request,upgrade,strategy
AbstractHandshakeHandler -> protected AbstractHandshakeHandler(RequestUpgradeStrategy requestUpgradeStrategy);1467730834;A constructor that accepts a runtime-specific {@link RequestUpgradeStrategy}._@param requestUpgradeStrategy the upgrade strategy to use;protected AbstractHandshakeHandler(RequestUpgradeStrategy requestUpgradeStrategy) {_		Assert.notNull(requestUpgradeStrategy, "RequestUpgradeStrategy must not be null")__		this.requestUpgradeStrategy = requestUpgradeStrategy__	};a,constructor,that,accepts,a,runtime,specific,link,request,upgrade,strategy,param,request,upgrade,strategy,the,upgrade,strategy,to,use;protected,abstract,handshake,handler,request,upgrade,strategy,request,upgrade,strategy,assert,not,null,request,upgrade,strategy,request,upgrade,strategy,must,not,be,null,this,request,upgrade,strategy,request,upgrade,strategy
AbstractHandshakeHandler -> protected AbstractHandshakeHandler(RequestUpgradeStrategy requestUpgradeStrategy);1468948866;A constructor that accepts a runtime-specific {@link RequestUpgradeStrategy}._@param requestUpgradeStrategy the upgrade strategy to use;protected AbstractHandshakeHandler(RequestUpgradeStrategy requestUpgradeStrategy) {_		Assert.notNull(requestUpgradeStrategy, "RequestUpgradeStrategy must not be null")__		this.requestUpgradeStrategy = requestUpgradeStrategy__	};a,constructor,that,accepts,a,runtime,specific,link,request,upgrade,strategy,param,request,upgrade,strategy,the,upgrade,strategy,to,use;protected,abstract,handshake,handler,request,upgrade,strategy,request,upgrade,strategy,assert,not,null,request,upgrade,strategy,request,upgrade,strategy,must,not,be,null,this,request,upgrade,strategy,request,upgrade,strategy
AbstractHandshakeHandler -> protected AbstractHandshakeHandler(RequestUpgradeStrategy requestUpgradeStrategy);1468964586;A constructor that accepts a runtime-specific {@link RequestUpgradeStrategy}._@param requestUpgradeStrategy the upgrade strategy to use;protected AbstractHandshakeHandler(RequestUpgradeStrategy requestUpgradeStrategy) {_		Assert.notNull(requestUpgradeStrategy, "RequestUpgradeStrategy must not be null")__		this.requestUpgradeStrategy = requestUpgradeStrategy__	};a,constructor,that,accepts,a,runtime,specific,link,request,upgrade,strategy,param,request,upgrade,strategy,the,upgrade,strategy,to,use;protected,abstract,handshake,handler,request,upgrade,strategy,request,upgrade,strategy,assert,not,null,request,upgrade,strategy,request,upgrade,strategy,must,not,be,null,this,request,upgrade,strategy,request,upgrade,strategy
AbstractHandshakeHandler -> protected AbstractHandshakeHandler(RequestUpgradeStrategy requestUpgradeStrategy);1474905889;A constructor that accepts a runtime-specific {@link RequestUpgradeStrategy}._@param requestUpgradeStrategy the upgrade strategy to use;protected AbstractHandshakeHandler(RequestUpgradeStrategy requestUpgradeStrategy) {_		Assert.notNull(requestUpgradeStrategy, "RequestUpgradeStrategy must not be null")__		this.requestUpgradeStrategy = requestUpgradeStrategy__	};a,constructor,that,accepts,a,runtime,specific,link,request,upgrade,strategy,param,request,upgrade,strategy,the,upgrade,strategy,to,use;protected,abstract,handshake,handler,request,upgrade,strategy,request,upgrade,strategy,assert,not,null,request,upgrade,strategy,request,upgrade,strategy,must,not,be,null,this,request,upgrade,strategy,request,upgrade,strategy
AbstractHandshakeHandler -> protected AbstractHandshakeHandler(RequestUpgradeStrategy requestUpgradeStrategy);1495868221;A constructor that accepts a runtime-specific {@link RequestUpgradeStrategy}._@param requestUpgradeStrategy the upgrade strategy to use;protected AbstractHandshakeHandler(RequestUpgradeStrategy requestUpgradeStrategy) {_		Assert.notNull(requestUpgradeStrategy, "RequestUpgradeStrategy must not be null")__		this.requestUpgradeStrategy = requestUpgradeStrategy__	};a,constructor,that,accepts,a,runtime,specific,link,request,upgrade,strategy,param,request,upgrade,strategy,the,upgrade,strategy,to,use;protected,abstract,handshake,handler,request,upgrade,strategy,request,upgrade,strategy,assert,not,null,request,upgrade,strategy,request,upgrade,strategy,must,not,be,null,this,request,upgrade,strategy,request,upgrade,strategy
AbstractHandshakeHandler -> protected AbstractHandshakeHandler(RequestUpgradeStrategy requestUpgradeStrategy);1496837955;A constructor that accepts a runtime-specific {@link RequestUpgradeStrategy}._@param requestUpgradeStrategy the upgrade strategy to use;protected AbstractHandshakeHandler(RequestUpgradeStrategy requestUpgradeStrategy) {_		Assert.notNull(requestUpgradeStrategy, "RequestUpgradeStrategy must not be null")__		this.requestUpgradeStrategy = requestUpgradeStrategy__	};a,constructor,that,accepts,a,runtime,specific,link,request,upgrade,strategy,param,request,upgrade,strategy,the,upgrade,strategy,to,use;protected,abstract,handshake,handler,request,upgrade,strategy,request,upgrade,strategy,assert,not,null,request,upgrade,strategy,request,upgrade,strategy,must,not,be,null,this,request,upgrade,strategy,request,upgrade,strategy
AbstractHandshakeHandler -> protected AbstractHandshakeHandler(RequestUpgradeStrategy requestUpgradeStrategy);1518810557;A constructor that accepts a runtime-specific {@link RequestUpgradeStrategy}._@param requestUpgradeStrategy the upgrade strategy to use;protected AbstractHandshakeHandler(RequestUpgradeStrategy requestUpgradeStrategy) {_		Assert.notNull(requestUpgradeStrategy, "RequestUpgradeStrategy must not be null")__		this.requestUpgradeStrategy = requestUpgradeStrategy__	};a,constructor,that,accepts,a,runtime,specific,link,request,upgrade,strategy,param,request,upgrade,strategy,the,upgrade,strategy,to,use;protected,abstract,handshake,handler,request,upgrade,strategy,request,upgrade,strategy,assert,not,null,request,upgrade,strategy,request,upgrade,strategy,must,not,be,null,this,request,upgrade,strategy,request,upgrade,strategy
AbstractHandshakeHandler -> protected AbstractHandshakeHandler(RequestUpgradeStrategy requestUpgradeStrategy);1521123475;A constructor that accepts a runtime-specific {@link RequestUpgradeStrategy}._@param requestUpgradeStrategy the upgrade strategy to use;protected AbstractHandshakeHandler(RequestUpgradeStrategy requestUpgradeStrategy) {_		Assert.notNull(requestUpgradeStrategy, "RequestUpgradeStrategy must not be null")__		this.requestUpgradeStrategy = requestUpgradeStrategy__	};a,constructor,that,accepts,a,runtime,specific,link,request,upgrade,strategy,param,request,upgrade,strategy,the,upgrade,strategy,to,use;protected,abstract,handshake,handler,request,upgrade,strategy,request,upgrade,strategy,assert,not,null,request,upgrade,strategy,request,upgrade,strategy,must,not,be,null,this,request,upgrade,strategy,request,upgrade,strategy
AbstractHandshakeHandler -> protected AbstractHandshakeHandler(RequestUpgradeStrategy requestUpgradeStrategy);1532509782;A constructor that accepts a runtime-specific {@link RequestUpgradeStrategy}._@param requestUpgradeStrategy the upgrade strategy to use;protected AbstractHandshakeHandler(RequestUpgradeStrategy requestUpgradeStrategy) {_		Assert.notNull(requestUpgradeStrategy, "RequestUpgradeStrategy must not be null")__		this.requestUpgradeStrategy = requestUpgradeStrategy__	};a,constructor,that,accepts,a,runtime,specific,link,request,upgrade,strategy,param,request,upgrade,strategy,the,upgrade,strategy,to,use;protected,abstract,handshake,handler,request,upgrade,strategy,request,upgrade,strategy,assert,not,null,request,upgrade,strategy,request,upgrade,strategy,must,not,be,null,this,request,upgrade,strategy,request,upgrade,strategy
AbstractHandshakeHandler -> protected List<WebSocketExtension> filterRequestedExtensions(ServerHttpRequest request, 			List<WebSocketExtension> requestedExtensions, List<WebSocketExtension> supportedExtensions);1435026644;Filter the list of requested WebSocket extensions._<p>As of 4.1 the default implementation of this method filters the list to_leave only extensions that are both requested and supported._@param request the current request_@param requestedExtensions the list of extensions requested by the client_@param supportedExtensions the list of extensions supported by the server_@return the selected extensions or an empty list;protected List<WebSocketExtension> filterRequestedExtensions(ServerHttpRequest request,_			List<WebSocketExtension> requestedExtensions, List<WebSocketExtension> supportedExtensions) {__		List<WebSocketExtension> result = new ArrayList<WebSocketExtension>(requestedExtensions.size())__		for (WebSocketExtension extension : requestedExtensions) {_			if (supportedExtensions.contains(extension)) {_				result.add(extension)__			}_		}_		return result__	};filter,the,list,of,requested,web,socket,extensions,p,as,of,4,1,the,default,implementation,of,this,method,filters,the,list,to,leave,only,extensions,that,are,both,requested,and,supported,param,request,the,current,request,param,requested,extensions,the,list,of,extensions,requested,by,the,client,param,supported,extensions,the,list,of,extensions,supported,by,the,server,return,the,selected,extensions,or,an,empty,list;protected,list,web,socket,extension,filter,requested,extensions,server,http,request,request,list,web,socket,extension,requested,extensions,list,web,socket,extension,supported,extensions,list,web,socket,extension,result,new,array,list,web,socket,extension,requested,extensions,size,for,web,socket,extension,extension,requested,extensions,if,supported,extensions,contains,extension,result,add,extension,return,result
AbstractHandshakeHandler -> protected List<WebSocketExtension> filterRequestedExtensions(ServerHttpRequest request, 			List<WebSocketExtension> requestedExtensions, List<WebSocketExtension> supportedExtensions);1439394598;Filter the list of requested WebSocket extensions._<p>As of 4.1 the default implementation of this method filters the list to_leave only extensions that are both requested and supported._@param request the current request_@param requestedExtensions the list of extensions requested by the client_@param supportedExtensions the list of extensions supported by the server_@return the selected extensions or an empty list;protected List<WebSocketExtension> filterRequestedExtensions(ServerHttpRequest request,_			List<WebSocketExtension> requestedExtensions, List<WebSocketExtension> supportedExtensions) {__		List<WebSocketExtension> result = new ArrayList<WebSocketExtension>(requestedExtensions.size())__		for (WebSocketExtension extension : requestedExtensions) {_			if (supportedExtensions.contains(extension)) {_				result.add(extension)__			}_		}_		return result__	};filter,the,list,of,requested,web,socket,extensions,p,as,of,4,1,the,default,implementation,of,this,method,filters,the,list,to,leave,only,extensions,that,are,both,requested,and,supported,param,request,the,current,request,param,requested,extensions,the,list,of,extensions,requested,by,the,client,param,supported,extensions,the,list,of,extensions,supported,by,the,server,return,the,selected,extensions,or,an,empty,list;protected,list,web,socket,extension,filter,requested,extensions,server,http,request,request,list,web,socket,extension,requested,extensions,list,web,socket,extension,supported,extensions,list,web,socket,extension,result,new,array,list,web,socket,extension,requested,extensions,size,for,web,socket,extension,extension,requested,extensions,if,supported,extensions,contains,extension,result,add,extension,return,result
AbstractHandshakeHandler -> protected List<WebSocketExtension> filterRequestedExtensions(ServerHttpRequest request, 			List<WebSocketExtension> requestedExtensions, List<WebSocketExtension> supportedExtensions);1440705898;Filter the list of requested WebSocket extensions._<p>As of 4.1, the default implementation of this method filters the list to_leave only extensions that are both requested and supported._@param request the current request_@param requestedExtensions the list of extensions requested by the client_@param supportedExtensions the list of extensions supported by the server_@return the selected extensions or an empty list;protected List<WebSocketExtension> filterRequestedExtensions(ServerHttpRequest request,_			List<WebSocketExtension> requestedExtensions, List<WebSocketExtension> supportedExtensions) {__		List<WebSocketExtension> result = new ArrayList<WebSocketExtension>(requestedExtensions.size())__		for (WebSocketExtension extension : requestedExtensions) {_			if (supportedExtensions.contains(extension)) {_				result.add(extension)__			}_		}_		return result__	};filter,the,list,of,requested,web,socket,extensions,p,as,of,4,1,the,default,implementation,of,this,method,filters,the,list,to,leave,only,extensions,that,are,both,requested,and,supported,param,request,the,current,request,param,requested,extensions,the,list,of,extensions,requested,by,the,client,param,supported,extensions,the,list,of,extensions,supported,by,the,server,return,the,selected,extensions,or,an,empty,list;protected,list,web,socket,extension,filter,requested,extensions,server,http,request,request,list,web,socket,extension,requested,extensions,list,web,socket,extension,supported,extensions,list,web,socket,extension,result,new,array,list,web,socket,extension,requested,extensions,size,for,web,socket,extension,extension,requested,extensions,if,supported,extensions,contains,extension,result,add,extension,return,result
AbstractHandshakeHandler -> protected List<WebSocketExtension> filterRequestedExtensions(ServerHttpRequest request, 			List<WebSocketExtension> requestedExtensions, List<WebSocketExtension> supportedExtensions);1444736364;Filter the list of requested WebSocket extensions._<p>As of 4.1, the default implementation of this method filters the list to_leave only extensions that are both requested and supported._@param request the current request_@param requestedExtensions the list of extensions requested by the client_@param supportedExtensions the list of extensions supported by the server_@return the selected extensions or an empty list;protected List<WebSocketExtension> filterRequestedExtensions(ServerHttpRequest request,_			List<WebSocketExtension> requestedExtensions, List<WebSocketExtension> supportedExtensions) {__		List<WebSocketExtension> result = new ArrayList<WebSocketExtension>(requestedExtensions.size())__		for (WebSocketExtension extension : requestedExtensions) {_			if (supportedExtensions.contains(extension)) {_				result.add(extension)__			}_		}_		return result__	};filter,the,list,of,requested,web,socket,extensions,p,as,of,4,1,the,default,implementation,of,this,method,filters,the,list,to,leave,only,extensions,that,are,both,requested,and,supported,param,request,the,current,request,param,requested,extensions,the,list,of,extensions,requested,by,the,client,param,supported,extensions,the,list,of,extensions,supported,by,the,server,return,the,selected,extensions,or,an,empty,list;protected,list,web,socket,extension,filter,requested,extensions,server,http,request,request,list,web,socket,extension,requested,extensions,list,web,socket,extension,supported,extensions,list,web,socket,extension,result,new,array,list,web,socket,extension,requested,extensions,size,for,web,socket,extension,extension,requested,extensions,if,supported,extensions,contains,extension,result,add,extension,return,result
AbstractHandshakeHandler -> protected List<WebSocketExtension> filterRequestedExtensions(ServerHttpRequest request, 			List<WebSocketExtension> requestedExtensions, List<WebSocketExtension> supportedExtensions);1449660404;Filter the list of requested WebSocket extensions._<p>As of 4.1, the default implementation of this method filters the list to_leave only extensions that are both requested and supported._@param request the current request_@param requestedExtensions the list of extensions requested by the client_@param supportedExtensions the list of extensions supported by the server_@return the selected extensions or an empty list;protected List<WebSocketExtension> filterRequestedExtensions(ServerHttpRequest request,_			List<WebSocketExtension> requestedExtensions, List<WebSocketExtension> supportedExtensions) {__		List<WebSocketExtension> result = new ArrayList<WebSocketExtension>(requestedExtensions.size())__		for (WebSocketExtension extension : requestedExtensions) {_			if (supportedExtensions.contains(extension)) {_				result.add(extension)__			}_		}_		return result__	};filter,the,list,of,requested,web,socket,extensions,p,as,of,4,1,the,default,implementation,of,this,method,filters,the,list,to,leave,only,extensions,that,are,both,requested,and,supported,param,request,the,current,request,param,requested,extensions,the,list,of,extensions,requested,by,the,client,param,supported,extensions,the,list,of,extensions,supported,by,the,server,return,the,selected,extensions,or,an,empty,list;protected,list,web,socket,extension,filter,requested,extensions,server,http,request,request,list,web,socket,extension,requested,extensions,list,web,socket,extension,supported,extensions,list,web,socket,extension,result,new,array,list,web,socket,extension,requested,extensions,size,for,web,socket,extension,extension,requested,extensions,if,supported,extensions,contains,extension,result,add,extension,return,result
AbstractHandshakeHandler -> protected List<WebSocketExtension> filterRequestedExtensions(ServerHttpRequest request, 			List<WebSocketExtension> requestedExtensions, List<WebSocketExtension> supportedExtensions);1467730834;Filter the list of requested WebSocket extensions._<p>As of 4.1, the default implementation of this method filters the list to_leave only extensions that are both requested and supported._@param request the current request_@param requestedExtensions the list of extensions requested by the client_@param supportedExtensions the list of extensions supported by the server_@return the selected extensions or an empty list;protected List<WebSocketExtension> filterRequestedExtensions(ServerHttpRequest request,_			List<WebSocketExtension> requestedExtensions, List<WebSocketExtension> supportedExtensions) {__		List<WebSocketExtension> result = new ArrayList<>(requestedExtensions.size())__		for (WebSocketExtension extension : requestedExtensions) {_			if (supportedExtensions.contains(extension)) {_				result.add(extension)__			}_		}_		return result__	};filter,the,list,of,requested,web,socket,extensions,p,as,of,4,1,the,default,implementation,of,this,method,filters,the,list,to,leave,only,extensions,that,are,both,requested,and,supported,param,request,the,current,request,param,requested,extensions,the,list,of,extensions,requested,by,the,client,param,supported,extensions,the,list,of,extensions,supported,by,the,server,return,the,selected,extensions,or,an,empty,list;protected,list,web,socket,extension,filter,requested,extensions,server,http,request,request,list,web,socket,extension,requested,extensions,list,web,socket,extension,supported,extensions,list,web,socket,extension,result,new,array,list,requested,extensions,size,for,web,socket,extension,extension,requested,extensions,if,supported,extensions,contains,extension,result,add,extension,return,result
AbstractHandshakeHandler -> protected List<WebSocketExtension> filterRequestedExtensions(ServerHttpRequest request, 			List<WebSocketExtension> requestedExtensions, List<WebSocketExtension> supportedExtensions);1468948866;Filter the list of requested WebSocket extensions._<p>As of 4.1, the default implementation of this method filters the list to_leave only extensions that are both requested and supported._@param request the current request_@param requestedExtensions the list of extensions requested by the client_@param supportedExtensions the list of extensions supported by the server_@return the selected extensions or an empty list;protected List<WebSocketExtension> filterRequestedExtensions(ServerHttpRequest request,_			List<WebSocketExtension> requestedExtensions, List<WebSocketExtension> supportedExtensions) {__		List<WebSocketExtension> result = new ArrayList<>(requestedExtensions.size())__		for (WebSocketExtension extension : requestedExtensions) {_			if (supportedExtensions.contains(extension)) {_				result.add(extension)__			}_		}_		return result__	};filter,the,list,of,requested,web,socket,extensions,p,as,of,4,1,the,default,implementation,of,this,method,filters,the,list,to,leave,only,extensions,that,are,both,requested,and,supported,param,request,the,current,request,param,requested,extensions,the,list,of,extensions,requested,by,the,client,param,supported,extensions,the,list,of,extensions,supported,by,the,server,return,the,selected,extensions,or,an,empty,list;protected,list,web,socket,extension,filter,requested,extensions,server,http,request,request,list,web,socket,extension,requested,extensions,list,web,socket,extension,supported,extensions,list,web,socket,extension,result,new,array,list,requested,extensions,size,for,web,socket,extension,extension,requested,extensions,if,supported,extensions,contains,extension,result,add,extension,return,result
AbstractHandshakeHandler -> protected List<WebSocketExtension> filterRequestedExtensions(ServerHttpRequest request, 			List<WebSocketExtension> requestedExtensions, List<WebSocketExtension> supportedExtensions);1468964586;Filter the list of requested WebSocket extensions._<p>As of 4.1, the default implementation of this method filters the list to_leave only extensions that are both requested and supported._@param request the current request_@param requestedExtensions the list of extensions requested by the client_@param supportedExtensions the list of extensions supported by the server_@return the selected extensions or an empty list;protected List<WebSocketExtension> filterRequestedExtensions(ServerHttpRequest request,_			List<WebSocketExtension> requestedExtensions, List<WebSocketExtension> supportedExtensions) {__		List<WebSocketExtension> result = new ArrayList<>(requestedExtensions.size())__		for (WebSocketExtension extension : requestedExtensions) {_			if (supportedExtensions.contains(extension)) {_				result.add(extension)__			}_		}_		return result__	};filter,the,list,of,requested,web,socket,extensions,p,as,of,4,1,the,default,implementation,of,this,method,filters,the,list,to,leave,only,extensions,that,are,both,requested,and,supported,param,request,the,current,request,param,requested,extensions,the,list,of,extensions,requested,by,the,client,param,supported,extensions,the,list,of,extensions,supported,by,the,server,return,the,selected,extensions,or,an,empty,list;protected,list,web,socket,extension,filter,requested,extensions,server,http,request,request,list,web,socket,extension,requested,extensions,list,web,socket,extension,supported,extensions,list,web,socket,extension,result,new,array,list,requested,extensions,size,for,web,socket,extension,extension,requested,extensions,if,supported,extensions,contains,extension,result,add,extension,return,result
AbstractHandshakeHandler -> protected List<WebSocketExtension> filterRequestedExtensions(ServerHttpRequest request, 			List<WebSocketExtension> requestedExtensions, List<WebSocketExtension> supportedExtensions);1474905889;Filter the list of requested WebSocket extensions._<p>As of 4.1, the default implementation of this method filters the list to_leave only extensions that are both requested and supported._@param request the current request_@param requestedExtensions the list of extensions requested by the client_@param supportedExtensions the list of extensions supported by the server_@return the selected extensions or an empty list;protected List<WebSocketExtension> filterRequestedExtensions(ServerHttpRequest request,_			List<WebSocketExtension> requestedExtensions, List<WebSocketExtension> supportedExtensions) {__		List<WebSocketExtension> result = new ArrayList<>(requestedExtensions.size())__		for (WebSocketExtension extension : requestedExtensions) {_			if (supportedExtensions.contains(extension)) {_				result.add(extension)__			}_		}_		return result__	};filter,the,list,of,requested,web,socket,extensions,p,as,of,4,1,the,default,implementation,of,this,method,filters,the,list,to,leave,only,extensions,that,are,both,requested,and,supported,param,request,the,current,request,param,requested,extensions,the,list,of,extensions,requested,by,the,client,param,supported,extensions,the,list,of,extensions,supported,by,the,server,return,the,selected,extensions,or,an,empty,list;protected,list,web,socket,extension,filter,requested,extensions,server,http,request,request,list,web,socket,extension,requested,extensions,list,web,socket,extension,supported,extensions,list,web,socket,extension,result,new,array,list,requested,extensions,size,for,web,socket,extension,extension,requested,extensions,if,supported,extensions,contains,extension,result,add,extension,return,result
AbstractHandshakeHandler -> protected List<WebSocketExtension> filterRequestedExtensions(ServerHttpRequest request, 			List<WebSocketExtension> requestedExtensions, List<WebSocketExtension> supportedExtensions);1495868221;Filter the list of requested WebSocket extensions._<p>As of 4.1, the default implementation of this method filters the list to_leave only extensions that are both requested and supported._@param request the current request_@param requestedExtensions the list of extensions requested by the client_@param supportedExtensions the list of extensions supported by the server_@return the selected extensions or an empty list;protected List<WebSocketExtension> filterRequestedExtensions(ServerHttpRequest request,_			List<WebSocketExtension> requestedExtensions, List<WebSocketExtension> supportedExtensions) {__		List<WebSocketExtension> result = new ArrayList<>(requestedExtensions.size())__		for (WebSocketExtension extension : requestedExtensions) {_			if (supportedExtensions.contains(extension)) {_				result.add(extension)__			}_		}_		return result__	};filter,the,list,of,requested,web,socket,extensions,p,as,of,4,1,the,default,implementation,of,this,method,filters,the,list,to,leave,only,extensions,that,are,both,requested,and,supported,param,request,the,current,request,param,requested,extensions,the,list,of,extensions,requested,by,the,client,param,supported,extensions,the,list,of,extensions,supported,by,the,server,return,the,selected,extensions,or,an,empty,list;protected,list,web,socket,extension,filter,requested,extensions,server,http,request,request,list,web,socket,extension,requested,extensions,list,web,socket,extension,supported,extensions,list,web,socket,extension,result,new,array,list,requested,extensions,size,for,web,socket,extension,extension,requested,extensions,if,supported,extensions,contains,extension,result,add,extension,return,result
AbstractHandshakeHandler -> protected List<WebSocketExtension> filterRequestedExtensions(ServerHttpRequest request, 			List<WebSocketExtension> requestedExtensions, List<WebSocketExtension> supportedExtensions);1496837955;Filter the list of requested WebSocket extensions._<p>As of 4.1, the default implementation of this method filters the list to_leave only extensions that are both requested and supported._@param request the current request_@param requestedExtensions the list of extensions requested by the client_@param supportedExtensions the list of extensions supported by the server_@return the selected extensions or an empty list;protected List<WebSocketExtension> filterRequestedExtensions(ServerHttpRequest request,_			List<WebSocketExtension> requestedExtensions, List<WebSocketExtension> supportedExtensions) {__		List<WebSocketExtension> result = new ArrayList<>(requestedExtensions.size())__		for (WebSocketExtension extension : requestedExtensions) {_			if (supportedExtensions.contains(extension)) {_				result.add(extension)__			}_		}_		return result__	};filter,the,list,of,requested,web,socket,extensions,p,as,of,4,1,the,default,implementation,of,this,method,filters,the,list,to,leave,only,extensions,that,are,both,requested,and,supported,param,request,the,current,request,param,requested,extensions,the,list,of,extensions,requested,by,the,client,param,supported,extensions,the,list,of,extensions,supported,by,the,server,return,the,selected,extensions,or,an,empty,list;protected,list,web,socket,extension,filter,requested,extensions,server,http,request,request,list,web,socket,extension,requested,extensions,list,web,socket,extension,supported,extensions,list,web,socket,extension,result,new,array,list,requested,extensions,size,for,web,socket,extension,extension,requested,extensions,if,supported,extensions,contains,extension,result,add,extension,return,result
AbstractHandshakeHandler -> protected List<WebSocketExtension> filterRequestedExtensions(ServerHttpRequest request, 			List<WebSocketExtension> requestedExtensions, List<WebSocketExtension> supportedExtensions);1518810557;Filter the list of requested WebSocket extensions._<p>As of 4.1, the default implementation of this method filters the list to_leave only extensions that are both requested and supported._@param request the current request_@param requestedExtensions the list of extensions requested by the client_@param supportedExtensions the list of extensions supported by the server_@return the selected extensions or an empty list;protected List<WebSocketExtension> filterRequestedExtensions(ServerHttpRequest request,_			List<WebSocketExtension> requestedExtensions, List<WebSocketExtension> supportedExtensions) {__		List<WebSocketExtension> result = new ArrayList<>(requestedExtensions.size())__		for (WebSocketExtension extension : requestedExtensions) {_			if (supportedExtensions.contains(extension)) {_				result.add(extension)__			}_		}_		return result__	};filter,the,list,of,requested,web,socket,extensions,p,as,of,4,1,the,default,implementation,of,this,method,filters,the,list,to,leave,only,extensions,that,are,both,requested,and,supported,param,request,the,current,request,param,requested,extensions,the,list,of,extensions,requested,by,the,client,param,supported,extensions,the,list,of,extensions,supported,by,the,server,return,the,selected,extensions,or,an,empty,list;protected,list,web,socket,extension,filter,requested,extensions,server,http,request,request,list,web,socket,extension,requested,extensions,list,web,socket,extension,supported,extensions,list,web,socket,extension,result,new,array,list,requested,extensions,size,for,web,socket,extension,extension,requested,extensions,if,supported,extensions,contains,extension,result,add,extension,return,result
AbstractHandshakeHandler -> protected List<WebSocketExtension> filterRequestedExtensions(ServerHttpRequest request, 			List<WebSocketExtension> requestedExtensions, List<WebSocketExtension> supportedExtensions);1521123475;Filter the list of requested WebSocket extensions._<p>As of 4.1, the default implementation of this method filters the list to_leave only extensions that are both requested and supported._@param request the current request_@param requestedExtensions the list of extensions requested by the client_@param supportedExtensions the list of extensions supported by the server_@return the selected extensions or an empty list;protected List<WebSocketExtension> filterRequestedExtensions(ServerHttpRequest request,_			List<WebSocketExtension> requestedExtensions, List<WebSocketExtension> supportedExtensions) {__		List<WebSocketExtension> result = new ArrayList<>(requestedExtensions.size())__		for (WebSocketExtension extension : requestedExtensions) {_			if (supportedExtensions.contains(extension)) {_				result.add(extension)__			}_		}_		return result__	};filter,the,list,of,requested,web,socket,extensions,p,as,of,4,1,the,default,implementation,of,this,method,filters,the,list,to,leave,only,extensions,that,are,both,requested,and,supported,param,request,the,current,request,param,requested,extensions,the,list,of,extensions,requested,by,the,client,param,supported,extensions,the,list,of,extensions,supported,by,the,server,return,the,selected,extensions,or,an,empty,list;protected,list,web,socket,extension,filter,requested,extensions,server,http,request,request,list,web,socket,extension,requested,extensions,list,web,socket,extension,supported,extensions,list,web,socket,extension,result,new,array,list,requested,extensions,size,for,web,socket,extension,extension,requested,extensions,if,supported,extensions,contains,extension,result,add,extension,return,result
AbstractHandshakeHandler -> protected List<WebSocketExtension> filterRequestedExtensions(ServerHttpRequest request, 			List<WebSocketExtension> requestedExtensions, List<WebSocketExtension> supportedExtensions);1532509782;Filter the list of requested WebSocket extensions._<p>As of 4.1, the default implementation of this method filters the list to_leave only extensions that are both requested and supported._@param request the current request_@param requestedExtensions the list of extensions requested by the client_@param supportedExtensions the list of extensions supported by the server_@return the selected extensions or an empty list;protected List<WebSocketExtension> filterRequestedExtensions(ServerHttpRequest request,_			List<WebSocketExtension> requestedExtensions, List<WebSocketExtension> supportedExtensions) {__		List<WebSocketExtension> result = new ArrayList<>(requestedExtensions.size())__		for (WebSocketExtension extension : requestedExtensions) {_			if (supportedExtensions.contains(extension)) {_				result.add(extension)__			}_		}_		return result__	};filter,the,list,of,requested,web,socket,extensions,p,as,of,4,1,the,default,implementation,of,this,method,filters,the,list,to,leave,only,extensions,that,are,both,requested,and,supported,param,request,the,current,request,param,requested,extensions,the,list,of,extensions,requested,by,the,client,param,supported,extensions,the,list,of,extensions,supported,by,the,server,return,the,selected,extensions,or,an,empty,list;protected,list,web,socket,extension,filter,requested,extensions,server,http,request,request,list,web,socket,extension,requested,extensions,list,web,socket,extension,supported,extensions,list,web,socket,extension,result,new,array,list,requested,extensions,size,for,web,socket,extension,extension,requested,extensions,if,supported,extensions,contains,extension,result,add,extension,return,result
AbstractHandshakeHandler -> public void setSupportedProtocols(String... protocols);1435026644;Use this property to configure the list of supported sub-protocols._The first configured sub-protocol that matches a client-requested sub-protocol_is accepted. If there are no matches the response will not contain a_{@literal Sec-WebSocket-Protocol} header._<p>Note that if the WebSocketHandler passed in at runtime is an instance of_{@link SubProtocolCapable} then there is not need to explicitly configure_this property. That is certainly the case with the built-in STOMP over_WebSocket support. Therefore this property should be configured explicitly_only if the WebSocketHandler does not implement {@code SubProtocolCapable}.;public void setSupportedProtocols(String... protocols) {_		this.supportedProtocols.clear()__		for (String protocol : protocols) {_			this.supportedProtocols.add(protocol.toLowerCase())__		}_	};use,this,property,to,configure,the,list,of,supported,sub,protocols,the,first,configured,sub,protocol,that,matches,a,client,requested,sub,protocol,is,accepted,if,there,are,no,matches,the,response,will,not,contain,a,literal,sec,web,socket,protocol,header,p,note,that,if,the,web,socket,handler,passed,in,at,runtime,is,an,instance,of,link,sub,protocol,capable,then,there,is,not,need,to,explicitly,configure,this,property,that,is,certainly,the,case,with,the,built,in,stomp,over,web,socket,support,therefore,this,property,should,be,configured,explicitly,only,if,the,web,socket,handler,does,not,implement,code,sub,protocol,capable;public,void,set,supported,protocols,string,protocols,this,supported,protocols,clear,for,string,protocol,protocols,this,supported,protocols,add,protocol,to,lower,case
AbstractHandshakeHandler -> public void setSupportedProtocols(String... protocols);1439394598;Use this property to configure the list of supported sub-protocols._The first configured sub-protocol that matches a client-requested sub-protocol_is accepted. If there are no matches the response will not contain a_{@literal Sec-WebSocket-Protocol} header._<p>Note that if the WebSocketHandler passed in at runtime is an instance of_{@link SubProtocolCapable} then there is not need to explicitly configure_this property. That is certainly the case with the built-in STOMP over_WebSocket support. Therefore this property should be configured explicitly_only if the WebSocketHandler does not implement {@code SubProtocolCapable}.;public void setSupportedProtocols(String... protocols) {_		this.supportedProtocols.clear()__		for (String protocol : protocols) {_			this.supportedProtocols.add(protocol.toLowerCase())__		}_	};use,this,property,to,configure,the,list,of,supported,sub,protocols,the,first,configured,sub,protocol,that,matches,a,client,requested,sub,protocol,is,accepted,if,there,are,no,matches,the,response,will,not,contain,a,literal,sec,web,socket,protocol,header,p,note,that,if,the,web,socket,handler,passed,in,at,runtime,is,an,instance,of,link,sub,protocol,capable,then,there,is,not,need,to,explicitly,configure,this,property,that,is,certainly,the,case,with,the,built,in,stomp,over,web,socket,support,therefore,this,property,should,be,configured,explicitly,only,if,the,web,socket,handler,does,not,implement,code,sub,protocol,capable;public,void,set,supported,protocols,string,protocols,this,supported,protocols,clear,for,string,protocol,protocols,this,supported,protocols,add,protocol,to,lower,case
AbstractHandshakeHandler -> public void setSupportedProtocols(String... protocols);1440705898;Use this property to configure the list of supported sub-protocols._The first configured sub-protocol that matches a client-requested sub-protocol_is accepted. If there are no matches the response will not contain a_{@literal Sec-WebSocket-Protocol} header._<p>Note that if the WebSocketHandler passed in at runtime is an instance of_{@link SubProtocolCapable} then there is not need to explicitly configure_this property. That is certainly the case with the built-in STOMP over_WebSocket support. Therefore this property should be configured explicitly_only if the WebSocketHandler does not implement {@code SubProtocolCapable}.;public void setSupportedProtocols(String... protocols) {_		this.supportedProtocols.clear()__		for (String protocol : protocols) {_			this.supportedProtocols.add(protocol.toLowerCase())__		}_	};use,this,property,to,configure,the,list,of,supported,sub,protocols,the,first,configured,sub,protocol,that,matches,a,client,requested,sub,protocol,is,accepted,if,there,are,no,matches,the,response,will,not,contain,a,literal,sec,web,socket,protocol,header,p,note,that,if,the,web,socket,handler,passed,in,at,runtime,is,an,instance,of,link,sub,protocol,capable,then,there,is,not,need,to,explicitly,configure,this,property,that,is,certainly,the,case,with,the,built,in,stomp,over,web,socket,support,therefore,this,property,should,be,configured,explicitly,only,if,the,web,socket,handler,does,not,implement,code,sub,protocol,capable;public,void,set,supported,protocols,string,protocols,this,supported,protocols,clear,for,string,protocol,protocols,this,supported,protocols,add,protocol,to,lower,case
AbstractHandshakeHandler -> public void setSupportedProtocols(String... protocols);1444736364;Use this property to configure the list of supported sub-protocols._The first configured sub-protocol that matches a client-requested sub-protocol_is accepted. If there are no matches the response will not contain a_{@literal Sec-WebSocket-Protocol} header._<p>Note that if the WebSocketHandler passed in at runtime is an instance of_{@link SubProtocolCapable} then there is not need to explicitly configure_this property. That is certainly the case with the built-in STOMP over_WebSocket support. Therefore this property should be configured explicitly_only if the WebSocketHandler does not implement {@code SubProtocolCapable}.;public void setSupportedProtocols(String... protocols) {_		this.supportedProtocols.clear()__		for (String protocol : protocols) {_			this.supportedProtocols.add(protocol.toLowerCase())__		}_	};use,this,property,to,configure,the,list,of,supported,sub,protocols,the,first,configured,sub,protocol,that,matches,a,client,requested,sub,protocol,is,accepted,if,there,are,no,matches,the,response,will,not,contain,a,literal,sec,web,socket,protocol,header,p,note,that,if,the,web,socket,handler,passed,in,at,runtime,is,an,instance,of,link,sub,protocol,capable,then,there,is,not,need,to,explicitly,configure,this,property,that,is,certainly,the,case,with,the,built,in,stomp,over,web,socket,support,therefore,this,property,should,be,configured,explicitly,only,if,the,web,socket,handler,does,not,implement,code,sub,protocol,capable;public,void,set,supported,protocols,string,protocols,this,supported,protocols,clear,for,string,protocol,protocols,this,supported,protocols,add,protocol,to,lower,case
AbstractHandshakeHandler -> public void setSupportedProtocols(String... protocols);1449660404;Use this property to configure the list of supported sub-protocols._The first configured sub-protocol that matches a client-requested sub-protocol_is accepted. If there are no matches the response will not contain a_{@literal Sec-WebSocket-Protocol} header._<p>Note that if the WebSocketHandler passed in at runtime is an instance of_{@link SubProtocolCapable} then there is not need to explicitly configure_this property. That is certainly the case with the built-in STOMP over_WebSocket support. Therefore this property should be configured explicitly_only if the WebSocketHandler does not implement {@code SubProtocolCapable}.;public void setSupportedProtocols(String... protocols) {_		this.supportedProtocols.clear()__		for (String protocol : protocols) {_			this.supportedProtocols.add(protocol.toLowerCase())__		}_	};use,this,property,to,configure,the,list,of,supported,sub,protocols,the,first,configured,sub,protocol,that,matches,a,client,requested,sub,protocol,is,accepted,if,there,are,no,matches,the,response,will,not,contain,a,literal,sec,web,socket,protocol,header,p,note,that,if,the,web,socket,handler,passed,in,at,runtime,is,an,instance,of,link,sub,protocol,capable,then,there,is,not,need,to,explicitly,configure,this,property,that,is,certainly,the,case,with,the,built,in,stomp,over,web,socket,support,therefore,this,property,should,be,configured,explicitly,only,if,the,web,socket,handler,does,not,implement,code,sub,protocol,capable;public,void,set,supported,protocols,string,protocols,this,supported,protocols,clear,for,string,protocol,protocols,this,supported,protocols,add,protocol,to,lower,case
AbstractHandshakeHandler -> public void setSupportedProtocols(String... protocols);1467730834;Use this property to configure the list of supported sub-protocols._The first configured sub-protocol that matches a client-requested sub-protocol_is accepted. If there are no matches the response will not contain a_{@literal Sec-WebSocket-Protocol} header._<p>Note that if the WebSocketHandler passed in at runtime is an instance of_{@link SubProtocolCapable} then there is not need to explicitly configure_this property. That is certainly the case with the built-in STOMP over_WebSocket support. Therefore this property should be configured explicitly_only if the WebSocketHandler does not implement {@code SubProtocolCapable}.;public void setSupportedProtocols(String... protocols) {_		this.supportedProtocols.clear()__		for (String protocol : protocols) {_			this.supportedProtocols.add(protocol.toLowerCase())__		}_	};use,this,property,to,configure,the,list,of,supported,sub,protocols,the,first,configured,sub,protocol,that,matches,a,client,requested,sub,protocol,is,accepted,if,there,are,no,matches,the,response,will,not,contain,a,literal,sec,web,socket,protocol,header,p,note,that,if,the,web,socket,handler,passed,in,at,runtime,is,an,instance,of,link,sub,protocol,capable,then,there,is,not,need,to,explicitly,configure,this,property,that,is,certainly,the,case,with,the,built,in,stomp,over,web,socket,support,therefore,this,property,should,be,configured,explicitly,only,if,the,web,socket,handler,does,not,implement,code,sub,protocol,capable;public,void,set,supported,protocols,string,protocols,this,supported,protocols,clear,for,string,protocol,protocols,this,supported,protocols,add,protocol,to,lower,case
AbstractHandshakeHandler -> public void setSupportedProtocols(String... protocols);1468948866;Use this property to configure the list of supported sub-protocols._The first configured sub-protocol that matches a client-requested sub-protocol_is accepted. If there are no matches the response will not contain a_{@literal Sec-WebSocket-Protocol} header._<p>Note that if the WebSocketHandler passed in at runtime is an instance of_{@link SubProtocolCapable} then there is not need to explicitly configure_this property. That is certainly the case with the built-in STOMP over_WebSocket support. Therefore this property should be configured explicitly_only if the WebSocketHandler does not implement {@code SubProtocolCapable}.;public void setSupportedProtocols(String... protocols) {_		this.supportedProtocols.clear()__		for (String protocol : protocols) {_			this.supportedProtocols.add(protocol.toLowerCase())__		}_	};use,this,property,to,configure,the,list,of,supported,sub,protocols,the,first,configured,sub,protocol,that,matches,a,client,requested,sub,protocol,is,accepted,if,there,are,no,matches,the,response,will,not,contain,a,literal,sec,web,socket,protocol,header,p,note,that,if,the,web,socket,handler,passed,in,at,runtime,is,an,instance,of,link,sub,protocol,capable,then,there,is,not,need,to,explicitly,configure,this,property,that,is,certainly,the,case,with,the,built,in,stomp,over,web,socket,support,therefore,this,property,should,be,configured,explicitly,only,if,the,web,socket,handler,does,not,implement,code,sub,protocol,capable;public,void,set,supported,protocols,string,protocols,this,supported,protocols,clear,for,string,protocol,protocols,this,supported,protocols,add,protocol,to,lower,case
AbstractHandshakeHandler -> public void setSupportedProtocols(String... protocols);1468964586;Use this property to configure the list of supported sub-protocols._The first configured sub-protocol that matches a client-requested sub-protocol_is accepted. If there are no matches the response will not contain a_{@literal Sec-WebSocket-Protocol} header._<p>Note that if the WebSocketHandler passed in at runtime is an instance of_{@link SubProtocolCapable} then there is not need to explicitly configure_this property. That is certainly the case with the built-in STOMP over_WebSocket support. Therefore this property should be configured explicitly_only if the WebSocketHandler does not implement {@code SubProtocolCapable}.;public void setSupportedProtocols(String... protocols) {_		this.supportedProtocols.clear()__		for (String protocol : protocols) {_			this.supportedProtocols.add(protocol.toLowerCase())__		}_	};use,this,property,to,configure,the,list,of,supported,sub,protocols,the,first,configured,sub,protocol,that,matches,a,client,requested,sub,protocol,is,accepted,if,there,are,no,matches,the,response,will,not,contain,a,literal,sec,web,socket,protocol,header,p,note,that,if,the,web,socket,handler,passed,in,at,runtime,is,an,instance,of,link,sub,protocol,capable,then,there,is,not,need,to,explicitly,configure,this,property,that,is,certainly,the,case,with,the,built,in,stomp,over,web,socket,support,therefore,this,property,should,be,configured,explicitly,only,if,the,web,socket,handler,does,not,implement,code,sub,protocol,capable;public,void,set,supported,protocols,string,protocols,this,supported,protocols,clear,for,string,protocol,protocols,this,supported,protocols,add,protocol,to,lower,case
AbstractHandshakeHandler -> public void setSupportedProtocols(String... protocols);1474905889;Use this property to configure the list of supported sub-protocols._The first configured sub-protocol that matches a client-requested sub-protocol_is accepted. If there are no matches the response will not contain a_{@literal Sec-WebSocket-Protocol} header._<p>Note that if the WebSocketHandler passed in at runtime is an instance of_{@link SubProtocolCapable} then there is not need to explicitly configure_this property. That is certainly the case with the built-in STOMP over_WebSocket support. Therefore this property should be configured explicitly_only if the WebSocketHandler does not implement {@code SubProtocolCapable}.;public void setSupportedProtocols(String... protocols) {_		this.supportedProtocols.clear()__		for (String protocol : protocols) {_			this.supportedProtocols.add(protocol.toLowerCase())__		}_	};use,this,property,to,configure,the,list,of,supported,sub,protocols,the,first,configured,sub,protocol,that,matches,a,client,requested,sub,protocol,is,accepted,if,there,are,no,matches,the,response,will,not,contain,a,literal,sec,web,socket,protocol,header,p,note,that,if,the,web,socket,handler,passed,in,at,runtime,is,an,instance,of,link,sub,protocol,capable,then,there,is,not,need,to,explicitly,configure,this,property,that,is,certainly,the,case,with,the,built,in,stomp,over,web,socket,support,therefore,this,property,should,be,configured,explicitly,only,if,the,web,socket,handler,does,not,implement,code,sub,protocol,capable;public,void,set,supported,protocols,string,protocols,this,supported,protocols,clear,for,string,protocol,protocols,this,supported,protocols,add,protocol,to,lower,case
AbstractHandshakeHandler -> public void setSupportedProtocols(String... protocols);1495868221;Use this property to configure the list of supported sub-protocols._The first configured sub-protocol that matches a client-requested sub-protocol_is accepted. If there are no matches the response will not contain a_{@literal Sec-WebSocket-Protocol} header._<p>Note that if the WebSocketHandler passed in at runtime is an instance of_{@link SubProtocolCapable} then there is not need to explicitly configure_this property. That is certainly the case with the built-in STOMP over_WebSocket support. Therefore this property should be configured explicitly_only if the WebSocketHandler does not implement {@code SubProtocolCapable}.;public void setSupportedProtocols(String... protocols) {_		this.supportedProtocols.clear()__		for (String protocol : protocols) {_			this.supportedProtocols.add(protocol.toLowerCase())__		}_	};use,this,property,to,configure,the,list,of,supported,sub,protocols,the,first,configured,sub,protocol,that,matches,a,client,requested,sub,protocol,is,accepted,if,there,are,no,matches,the,response,will,not,contain,a,literal,sec,web,socket,protocol,header,p,note,that,if,the,web,socket,handler,passed,in,at,runtime,is,an,instance,of,link,sub,protocol,capable,then,there,is,not,need,to,explicitly,configure,this,property,that,is,certainly,the,case,with,the,built,in,stomp,over,web,socket,support,therefore,this,property,should,be,configured,explicitly,only,if,the,web,socket,handler,does,not,implement,code,sub,protocol,capable;public,void,set,supported,protocols,string,protocols,this,supported,protocols,clear,for,string,protocol,protocols,this,supported,protocols,add,protocol,to,lower,case
AbstractHandshakeHandler -> public void setSupportedProtocols(String... protocols);1496837955;Use this property to configure the list of supported sub-protocols._The first configured sub-protocol that matches a client-requested sub-protocol_is accepted. If there are no matches the response will not contain a_{@literal Sec-WebSocket-Protocol} header._<p>Note that if the WebSocketHandler passed in at runtime is an instance of_{@link SubProtocolCapable} then there is not need to explicitly configure_this property. That is certainly the case with the built-in STOMP over_WebSocket support. Therefore this property should be configured explicitly_only if the WebSocketHandler does not implement {@code SubProtocolCapable}.;public void setSupportedProtocols(String... protocols) {_		this.supportedProtocols.clear()__		for (String protocol : protocols) {_			this.supportedProtocols.add(protocol.toLowerCase())__		}_	};use,this,property,to,configure,the,list,of,supported,sub,protocols,the,first,configured,sub,protocol,that,matches,a,client,requested,sub,protocol,is,accepted,if,there,are,no,matches,the,response,will,not,contain,a,literal,sec,web,socket,protocol,header,p,note,that,if,the,web,socket,handler,passed,in,at,runtime,is,an,instance,of,link,sub,protocol,capable,then,there,is,not,need,to,explicitly,configure,this,property,that,is,certainly,the,case,with,the,built,in,stomp,over,web,socket,support,therefore,this,property,should,be,configured,explicitly,only,if,the,web,socket,handler,does,not,implement,code,sub,protocol,capable;public,void,set,supported,protocols,string,protocols,this,supported,protocols,clear,for,string,protocol,protocols,this,supported,protocols,add,protocol,to,lower,case
AbstractHandshakeHandler -> public void setSupportedProtocols(String... protocols);1518810557;Use this property to configure the list of supported sub-protocols._The first configured sub-protocol that matches a client-requested sub-protocol_is accepted. If there are no matches the response will not contain a_{@literal Sec-WebSocket-Protocol} header._<p>Note that if the WebSocketHandler passed in at runtime is an instance of_{@link SubProtocolCapable} then there is not need to explicitly configure_this property. That is certainly the case with the built-in STOMP over_WebSocket support. Therefore this property should be configured explicitly_only if the WebSocketHandler does not implement {@code SubProtocolCapable}.;public void setSupportedProtocols(String... protocols) {_		this.supportedProtocols.clear()__		for (String protocol : protocols) {_			this.supportedProtocols.add(protocol.toLowerCase())__		}_	};use,this,property,to,configure,the,list,of,supported,sub,protocols,the,first,configured,sub,protocol,that,matches,a,client,requested,sub,protocol,is,accepted,if,there,are,no,matches,the,response,will,not,contain,a,literal,sec,web,socket,protocol,header,p,note,that,if,the,web,socket,handler,passed,in,at,runtime,is,an,instance,of,link,sub,protocol,capable,then,there,is,not,need,to,explicitly,configure,this,property,that,is,certainly,the,case,with,the,built,in,stomp,over,web,socket,support,therefore,this,property,should,be,configured,explicitly,only,if,the,web,socket,handler,does,not,implement,code,sub,protocol,capable;public,void,set,supported,protocols,string,protocols,this,supported,protocols,clear,for,string,protocol,protocols,this,supported,protocols,add,protocol,to,lower,case
AbstractHandshakeHandler -> public void setSupportedProtocols(String... protocols);1521123475;Use this property to configure the list of supported sub-protocols._The first configured sub-protocol that matches a client-requested sub-protocol_is accepted. If there are no matches the response will not contain a_{@literal Sec-WebSocket-Protocol} header._<p>Note that if the WebSocketHandler passed in at runtime is an instance of_{@link SubProtocolCapable} then there is not need to explicitly configure_this property. That is certainly the case with the built-in STOMP over_WebSocket support. Therefore this property should be configured explicitly_only if the WebSocketHandler does not implement {@code SubProtocolCapable}.;public void setSupportedProtocols(String... protocols) {_		this.supportedProtocols.clear()__		for (String protocol : protocols) {_			this.supportedProtocols.add(protocol.toLowerCase())__		}_	};use,this,property,to,configure,the,list,of,supported,sub,protocols,the,first,configured,sub,protocol,that,matches,a,client,requested,sub,protocol,is,accepted,if,there,are,no,matches,the,response,will,not,contain,a,literal,sec,web,socket,protocol,header,p,note,that,if,the,web,socket,handler,passed,in,at,runtime,is,an,instance,of,link,sub,protocol,capable,then,there,is,not,need,to,explicitly,configure,this,property,that,is,certainly,the,case,with,the,built,in,stomp,over,web,socket,support,therefore,this,property,should,be,configured,explicitly,only,if,the,web,socket,handler,does,not,implement,code,sub,protocol,capable;public,void,set,supported,protocols,string,protocols,this,supported,protocols,clear,for,string,protocol,protocols,this,supported,protocols,add,protocol,to,lower,case
AbstractHandshakeHandler -> public void setSupportedProtocols(String... protocols);1532509782;Use this property to configure the list of supported sub-protocols._The first configured sub-protocol that matches a client-requested sub-protocol_is accepted. If there are no matches the response will not contain a_{@literal Sec-WebSocket-Protocol} header._<p>Note that if the WebSocketHandler passed in at runtime is an instance of_{@link SubProtocolCapable} then there is not need to explicitly configure_this property. That is certainly the case with the built-in STOMP over_WebSocket support. Therefore this property should be configured explicitly_only if the WebSocketHandler does not implement {@code SubProtocolCapable}.;public void setSupportedProtocols(String... protocols) {_		this.supportedProtocols.clear()__		for (String protocol : protocols) {_			this.supportedProtocols.add(protocol.toLowerCase())__		}_	};use,this,property,to,configure,the,list,of,supported,sub,protocols,the,first,configured,sub,protocol,that,matches,a,client,requested,sub,protocol,is,accepted,if,there,are,no,matches,the,response,will,not,contain,a,literal,sec,web,socket,protocol,header,p,note,that,if,the,web,socket,handler,passed,in,at,runtime,is,an,instance,of,link,sub,protocol,capable,then,there,is,not,need,to,explicitly,configure,this,property,that,is,certainly,the,case,with,the,built,in,stomp,over,web,socket,support,therefore,this,property,should,be,configured,explicitly,only,if,the,web,socket,handler,does,not,implement,code,sub,protocol,capable;public,void,set,supported,protocols,string,protocols,this,supported,protocols,clear,for,string,protocol,protocols,this,supported,protocols,add,protocol,to,lower,case
AbstractHandshakeHandler -> protected boolean isValidOrigin(ServerHttpRequest request);1435026644;Return whether the request {@code Origin} header value is valid or not._By default, all origins as considered as valid. Consider using an_{@link OriginHandshakeInterceptor} for filtering origins if needed.;protected boolean isValidOrigin(ServerHttpRequest request) {_		return true__	};return,whether,the,request,code,origin,header,value,is,valid,or,not,by,default,all,origins,as,considered,as,valid,consider,using,an,link,origin,handshake,interceptor,for,filtering,origins,if,needed;protected,boolean,is,valid,origin,server,http,request,request,return,true
AbstractHandshakeHandler -> protected boolean isValidOrigin(ServerHttpRequest request);1439394598;Return whether the request {@code Origin} header value is valid or not._By default, all origins as considered as valid. Consider using an_{@link OriginHandshakeInterceptor} for filtering origins if needed.;protected boolean isValidOrigin(ServerHttpRequest request) {_		return true__	};return,whether,the,request,code,origin,header,value,is,valid,or,not,by,default,all,origins,as,considered,as,valid,consider,using,an,link,origin,handshake,interceptor,for,filtering,origins,if,needed;protected,boolean,is,valid,origin,server,http,request,request,return,true
AbstractHandshakeHandler -> protected boolean isValidOrigin(ServerHttpRequest request);1440705898;Return whether the request {@code Origin} header value is valid or not._By default, all origins as considered as valid. Consider using an_{@link OriginHandshakeInterceptor} for filtering origins if needed.;protected boolean isValidOrigin(ServerHttpRequest request) {_		return true__	};return,whether,the,request,code,origin,header,value,is,valid,or,not,by,default,all,origins,as,considered,as,valid,consider,using,an,link,origin,handshake,interceptor,for,filtering,origins,if,needed;protected,boolean,is,valid,origin,server,http,request,request,return,true
AbstractHandshakeHandler -> protected boolean isValidOrigin(ServerHttpRequest request);1444736364;Return whether the request {@code Origin} header value is valid or not._By default, all origins as considered as valid. Consider using an_{@link OriginHandshakeInterceptor} for filtering origins if needed.;protected boolean isValidOrigin(ServerHttpRequest request) {_		return true__	};return,whether,the,request,code,origin,header,value,is,valid,or,not,by,default,all,origins,as,considered,as,valid,consider,using,an,link,origin,handshake,interceptor,for,filtering,origins,if,needed;protected,boolean,is,valid,origin,server,http,request,request,return,true
AbstractHandshakeHandler -> protected boolean isValidOrigin(ServerHttpRequest request);1449660404;Return whether the request {@code Origin} header value is valid or not._By default, all origins as considered as valid. Consider using an_{@link OriginHandshakeInterceptor} for filtering origins if needed.;protected boolean isValidOrigin(ServerHttpRequest request) {_		return true__	};return,whether,the,request,code,origin,header,value,is,valid,or,not,by,default,all,origins,as,considered,as,valid,consider,using,an,link,origin,handshake,interceptor,for,filtering,origins,if,needed;protected,boolean,is,valid,origin,server,http,request,request,return,true
AbstractHandshakeHandler -> protected boolean isValidOrigin(ServerHttpRequest request);1467730834;Return whether the request {@code Origin} header value is valid or not._By default, all origins as considered as valid. Consider using an_{@link OriginHandshakeInterceptor} for filtering origins if needed.;protected boolean isValidOrigin(ServerHttpRequest request) {_		return true__	};return,whether,the,request,code,origin,header,value,is,valid,or,not,by,default,all,origins,as,considered,as,valid,consider,using,an,link,origin,handshake,interceptor,for,filtering,origins,if,needed;protected,boolean,is,valid,origin,server,http,request,request,return,true
AbstractHandshakeHandler -> protected boolean isValidOrigin(ServerHttpRequest request);1468948866;Return whether the request {@code Origin} header value is valid or not._By default, all origins as considered as valid. Consider using an_{@link OriginHandshakeInterceptor} for filtering origins if needed.;protected boolean isValidOrigin(ServerHttpRequest request) {_		return true__	};return,whether,the,request,code,origin,header,value,is,valid,or,not,by,default,all,origins,as,considered,as,valid,consider,using,an,link,origin,handshake,interceptor,for,filtering,origins,if,needed;protected,boolean,is,valid,origin,server,http,request,request,return,true
AbstractHandshakeHandler -> protected boolean isValidOrigin(ServerHttpRequest request);1468964586;Return whether the request {@code Origin} header value is valid or not._By default, all origins as considered as valid. Consider using an_{@link OriginHandshakeInterceptor} for filtering origins if needed.;protected boolean isValidOrigin(ServerHttpRequest request) {_		return true__	};return,whether,the,request,code,origin,header,value,is,valid,or,not,by,default,all,origins,as,considered,as,valid,consider,using,an,link,origin,handshake,interceptor,for,filtering,origins,if,needed;protected,boolean,is,valid,origin,server,http,request,request,return,true
AbstractHandshakeHandler -> protected boolean isValidOrigin(ServerHttpRequest request);1474905889;Return whether the request {@code Origin} header value is valid or not._By default, all origins as considered as valid. Consider using an_{@link OriginHandshakeInterceptor} for filtering origins if needed.;protected boolean isValidOrigin(ServerHttpRequest request) {_		return true__	};return,whether,the,request,code,origin,header,value,is,valid,or,not,by,default,all,origins,as,considered,as,valid,consider,using,an,link,origin,handshake,interceptor,for,filtering,origins,if,needed;protected,boolean,is,valid,origin,server,http,request,request,return,true
AbstractHandshakeHandler -> protected boolean isValidOrigin(ServerHttpRequest request);1495868221;Return whether the request {@code Origin} header value is valid or not._By default, all origins as considered as valid. Consider using an_{@link OriginHandshakeInterceptor} for filtering origins if needed.;protected boolean isValidOrigin(ServerHttpRequest request) {_		return true__	};return,whether,the,request,code,origin,header,value,is,valid,or,not,by,default,all,origins,as,considered,as,valid,consider,using,an,link,origin,handshake,interceptor,for,filtering,origins,if,needed;protected,boolean,is,valid,origin,server,http,request,request,return,true
AbstractHandshakeHandler -> protected boolean isValidOrigin(ServerHttpRequest request);1496837955;Return whether the request {@code Origin} header value is valid or not._By default, all origins as considered as valid. Consider using an_{@link OriginHandshakeInterceptor} for filtering origins if needed.;protected boolean isValidOrigin(ServerHttpRequest request) {_		return true__	};return,whether,the,request,code,origin,header,value,is,valid,or,not,by,default,all,origins,as,considered,as,valid,consider,using,an,link,origin,handshake,interceptor,for,filtering,origins,if,needed;protected,boolean,is,valid,origin,server,http,request,request,return,true
AbstractHandshakeHandler -> protected boolean isValidOrigin(ServerHttpRequest request);1518810557;Return whether the request {@code Origin} header value is valid or not._By default, all origins as considered as valid. Consider using an_{@link OriginHandshakeInterceptor} for filtering origins if needed.;protected boolean isValidOrigin(ServerHttpRequest request) {_		return true__	};return,whether,the,request,code,origin,header,value,is,valid,or,not,by,default,all,origins,as,considered,as,valid,consider,using,an,link,origin,handshake,interceptor,for,filtering,origins,if,needed;protected,boolean,is,valid,origin,server,http,request,request,return,true
AbstractHandshakeHandler -> protected boolean isValidOrigin(ServerHttpRequest request);1521123475;Return whether the request {@code Origin} header value is valid or not._By default, all origins as considered as valid. Consider using an_{@link OriginHandshakeInterceptor} for filtering origins if needed.;protected boolean isValidOrigin(ServerHttpRequest request) {_		return true__	};return,whether,the,request,code,origin,header,value,is,valid,or,not,by,default,all,origins,as,considered,as,valid,consider,using,an,link,origin,handshake,interceptor,for,filtering,origins,if,needed;protected,boolean,is,valid,origin,server,http,request,request,return,true
AbstractHandshakeHandler -> protected boolean isValidOrigin(ServerHttpRequest request);1532509782;Return whether the request {@code Origin} header value is valid or not._By default, all origins as considered as valid. Consider using an_{@link OriginHandshakeInterceptor} for filtering origins if needed.;protected boolean isValidOrigin(ServerHttpRequest request) {_		return true__	};return,whether,the,request,code,origin,header,value,is,valid,or,not,by,default,all,origins,as,considered,as,valid,consider,using,an,link,origin,handshake,interceptor,for,filtering,origins,if,needed;protected,boolean,is,valid,origin,server,http,request,request,return,true
AbstractHandshakeHandler -> public RequestUpgradeStrategy getRequestUpgradeStrategy();1435026644;Return the {@link RequestUpgradeStrategy} for WebSocket requests.;public RequestUpgradeStrategy getRequestUpgradeStrategy() {_		return this.requestUpgradeStrategy__	};return,the,link,request,upgrade,strategy,for,web,socket,requests;public,request,upgrade,strategy,get,request,upgrade,strategy,return,this,request,upgrade,strategy
AbstractHandshakeHandler -> public RequestUpgradeStrategy getRequestUpgradeStrategy();1439394598;Return the {@link RequestUpgradeStrategy} for WebSocket requests.;public RequestUpgradeStrategy getRequestUpgradeStrategy() {_		return this.requestUpgradeStrategy__	};return,the,link,request,upgrade,strategy,for,web,socket,requests;public,request,upgrade,strategy,get,request,upgrade,strategy,return,this,request,upgrade,strategy
AbstractHandshakeHandler -> public RequestUpgradeStrategy getRequestUpgradeStrategy();1440705898;Return the {@link RequestUpgradeStrategy} for WebSocket requests.;public RequestUpgradeStrategy getRequestUpgradeStrategy() {_		return this.requestUpgradeStrategy__	};return,the,link,request,upgrade,strategy,for,web,socket,requests;public,request,upgrade,strategy,get,request,upgrade,strategy,return,this,request,upgrade,strategy
AbstractHandshakeHandler -> public RequestUpgradeStrategy getRequestUpgradeStrategy();1444736364;Return the {@link RequestUpgradeStrategy} for WebSocket requests.;public RequestUpgradeStrategy getRequestUpgradeStrategy() {_		return this.requestUpgradeStrategy__	};return,the,link,request,upgrade,strategy,for,web,socket,requests;public,request,upgrade,strategy,get,request,upgrade,strategy,return,this,request,upgrade,strategy
AbstractHandshakeHandler -> public RequestUpgradeStrategy getRequestUpgradeStrategy();1449660404;Return the {@link RequestUpgradeStrategy} for WebSocket requests.;public RequestUpgradeStrategy getRequestUpgradeStrategy() {_		return this.requestUpgradeStrategy__	};return,the,link,request,upgrade,strategy,for,web,socket,requests;public,request,upgrade,strategy,get,request,upgrade,strategy,return,this,request,upgrade,strategy
AbstractHandshakeHandler -> public RequestUpgradeStrategy getRequestUpgradeStrategy();1467730834;Return the {@link RequestUpgradeStrategy} for WebSocket requests.;public RequestUpgradeStrategy getRequestUpgradeStrategy() {_		return this.requestUpgradeStrategy__	};return,the,link,request,upgrade,strategy,for,web,socket,requests;public,request,upgrade,strategy,get,request,upgrade,strategy,return,this,request,upgrade,strategy
AbstractHandshakeHandler -> public RequestUpgradeStrategy getRequestUpgradeStrategy();1468948866;Return the {@link RequestUpgradeStrategy} for WebSocket requests.;public RequestUpgradeStrategy getRequestUpgradeStrategy() {_		return this.requestUpgradeStrategy__	};return,the,link,request,upgrade,strategy,for,web,socket,requests;public,request,upgrade,strategy,get,request,upgrade,strategy,return,this,request,upgrade,strategy
AbstractHandshakeHandler -> public RequestUpgradeStrategy getRequestUpgradeStrategy();1468964586;Return the {@link RequestUpgradeStrategy} for WebSocket requests.;public RequestUpgradeStrategy getRequestUpgradeStrategy() {_		return this.requestUpgradeStrategy__	};return,the,link,request,upgrade,strategy,for,web,socket,requests;public,request,upgrade,strategy,get,request,upgrade,strategy,return,this,request,upgrade,strategy
AbstractHandshakeHandler -> public RequestUpgradeStrategy getRequestUpgradeStrategy();1474905889;Return the {@link RequestUpgradeStrategy} for WebSocket requests.;public RequestUpgradeStrategy getRequestUpgradeStrategy() {_		return this.requestUpgradeStrategy__	};return,the,link,request,upgrade,strategy,for,web,socket,requests;public,request,upgrade,strategy,get,request,upgrade,strategy,return,this,request,upgrade,strategy
AbstractHandshakeHandler -> public RequestUpgradeStrategy getRequestUpgradeStrategy();1495868221;Return the {@link RequestUpgradeStrategy} for WebSocket requests.;public RequestUpgradeStrategy getRequestUpgradeStrategy() {_		return this.requestUpgradeStrategy__	};return,the,link,request,upgrade,strategy,for,web,socket,requests;public,request,upgrade,strategy,get,request,upgrade,strategy,return,this,request,upgrade,strategy
AbstractHandshakeHandler -> public RequestUpgradeStrategy getRequestUpgradeStrategy();1496837955;Return the {@link RequestUpgradeStrategy} for WebSocket requests.;public RequestUpgradeStrategy getRequestUpgradeStrategy() {_		return this.requestUpgradeStrategy__	};return,the,link,request,upgrade,strategy,for,web,socket,requests;public,request,upgrade,strategy,get,request,upgrade,strategy,return,this,request,upgrade,strategy
AbstractHandshakeHandler -> public RequestUpgradeStrategy getRequestUpgradeStrategy();1518810557;Return the {@link RequestUpgradeStrategy} for WebSocket requests.;public RequestUpgradeStrategy getRequestUpgradeStrategy() {_		return this.requestUpgradeStrategy__	};return,the,link,request,upgrade,strategy,for,web,socket,requests;public,request,upgrade,strategy,get,request,upgrade,strategy,return,this,request,upgrade,strategy
AbstractHandshakeHandler -> public RequestUpgradeStrategy getRequestUpgradeStrategy();1521123475;Return the {@link RequestUpgradeStrategy} for WebSocket requests.;public RequestUpgradeStrategy getRequestUpgradeStrategy() {_		return this.requestUpgradeStrategy__	};return,the,link,request,upgrade,strategy,for,web,socket,requests;public,request,upgrade,strategy,get,request,upgrade,strategy,return,this,request,upgrade,strategy
AbstractHandshakeHandler -> public RequestUpgradeStrategy getRequestUpgradeStrategy();1532509782;Return the {@link RequestUpgradeStrategy} for WebSocket requests.;public RequestUpgradeStrategy getRequestUpgradeStrategy() {_		return this.requestUpgradeStrategy__	};return,the,link,request,upgrade,strategy,for,web,socket,requests;public,request,upgrade,strategy,get,request,upgrade,strategy,return,this,request,upgrade,strategy
AbstractHandshakeHandler -> protected Principal determineUser(ServerHttpRequest request, WebSocketHandler wsHandler, 			Map<String, Object> attributes);1435026644;A method that can be used to associate a user with the WebSocket session_in the process of being established. The default implementation calls_{@link ServerHttpRequest#getPrincipal()}_<p>Subclasses can provide custom logic for associating a user with a session,_for example for assigning a name to anonymous users (i.e. not fully_authenticated)._@param request the handshake request_@param wsHandler the WebSocket handler that will handle messages_@param attributes handshake attributes to pass to the WebSocket session_@return the user for the WebSocket session, or {@code null} if not available;protected Principal determineUser(ServerHttpRequest request, WebSocketHandler wsHandler,_			Map<String, Object> attributes) {__		return request.getPrincipal()__	};a,method,that,can,be,used,to,associate,a,user,with,the,web,socket,session,in,the,process,of,being,established,the,default,implementation,calls,link,server,http,request,get,principal,p,subclasses,can,provide,custom,logic,for,associating,a,user,with,a,session,for,example,for,assigning,a,name,to,anonymous,users,i,e,not,fully,authenticated,param,request,the,handshake,request,param,ws,handler,the,web,socket,handler,that,will,handle,messages,param,attributes,handshake,attributes,to,pass,to,the,web,socket,session,return,the,user,for,the,web,socket,session,or,code,null,if,not,available;protected,principal,determine,user,server,http,request,request,web,socket,handler,ws,handler,map,string,object,attributes,return,request,get,principal
AbstractHandshakeHandler -> protected Principal determineUser(ServerHttpRequest request, WebSocketHandler wsHandler, 			Map<String, Object> attributes);1439394598;A method that can be used to associate a user with the WebSocket session_in the process of being established. The default implementation calls_{@link ServerHttpRequest#getPrincipal()}_<p>Subclasses can provide custom logic for associating a user with a session,_for example for assigning a name to anonymous users (i.e. not fully_authenticated)._@param request the handshake request_@param wsHandler the WebSocket handler that will handle messages_@param attributes handshake attributes to pass to the WebSocket session_@return the user for the WebSocket session, or {@code null} if not available;protected Principal determineUser(ServerHttpRequest request, WebSocketHandler wsHandler,_			Map<String, Object> attributes) {__		return request.getPrincipal()__	};a,method,that,can,be,used,to,associate,a,user,with,the,web,socket,session,in,the,process,of,being,established,the,default,implementation,calls,link,server,http,request,get,principal,p,subclasses,can,provide,custom,logic,for,associating,a,user,with,a,session,for,example,for,assigning,a,name,to,anonymous,users,i,e,not,fully,authenticated,param,request,the,handshake,request,param,ws,handler,the,web,socket,handler,that,will,handle,messages,param,attributes,handshake,attributes,to,pass,to,the,web,socket,session,return,the,user,for,the,web,socket,session,or,code,null,if,not,available;protected,principal,determine,user,server,http,request,request,web,socket,handler,ws,handler,map,string,object,attributes,return,request,get,principal
AbstractHandshakeHandler -> protected Principal determineUser(ServerHttpRequest request, WebSocketHandler wsHandler, 			Map<String, Object> attributes);1440705898;A method that can be used to associate a user with the WebSocket session_in the process of being established. The default implementation calls_{@link ServerHttpRequest#getPrincipal()}_<p>Subclasses can provide custom logic for associating a user with a session,_for example for assigning a name to anonymous users (i.e. not fully_authenticated)._@param request the handshake request_@param wsHandler the WebSocket handler that will handle messages_@param attributes handshake attributes to pass to the WebSocket session_@return the user for the WebSocket session, or {@code null} if not available;protected Principal determineUser(ServerHttpRequest request, WebSocketHandler wsHandler,_			Map<String, Object> attributes) {__		return request.getPrincipal()__	};a,method,that,can,be,used,to,associate,a,user,with,the,web,socket,session,in,the,process,of,being,established,the,default,implementation,calls,link,server,http,request,get,principal,p,subclasses,can,provide,custom,logic,for,associating,a,user,with,a,session,for,example,for,assigning,a,name,to,anonymous,users,i,e,not,fully,authenticated,param,request,the,handshake,request,param,ws,handler,the,web,socket,handler,that,will,handle,messages,param,attributes,handshake,attributes,to,pass,to,the,web,socket,session,return,the,user,for,the,web,socket,session,or,code,null,if,not,available;protected,principal,determine,user,server,http,request,request,web,socket,handler,ws,handler,map,string,object,attributes,return,request,get,principal
AbstractHandshakeHandler -> protected Principal determineUser(ServerHttpRequest request, WebSocketHandler wsHandler, 			Map<String, Object> attributes);1444736364;A method that can be used to associate a user with the WebSocket session_in the process of being established. The default implementation calls_{@link ServerHttpRequest#getPrincipal()}_<p>Subclasses can provide custom logic for associating a user with a session,_for example for assigning a name to anonymous users (i.e. not fully authenticated)._@param request the handshake request_@param wsHandler the WebSocket handler that will handle messages_@param attributes handshake attributes to pass to the WebSocket session_@return the user for the WebSocket session, or {@code null} if not available;protected Principal determineUser(ServerHttpRequest request, WebSocketHandler wsHandler,_			Map<String, Object> attributes) {__		return request.getPrincipal()__	};a,method,that,can,be,used,to,associate,a,user,with,the,web,socket,session,in,the,process,of,being,established,the,default,implementation,calls,link,server,http,request,get,principal,p,subclasses,can,provide,custom,logic,for,associating,a,user,with,a,session,for,example,for,assigning,a,name,to,anonymous,users,i,e,not,fully,authenticated,param,request,the,handshake,request,param,ws,handler,the,web,socket,handler,that,will,handle,messages,param,attributes,handshake,attributes,to,pass,to,the,web,socket,session,return,the,user,for,the,web,socket,session,or,code,null,if,not,available;protected,principal,determine,user,server,http,request,request,web,socket,handler,ws,handler,map,string,object,attributes,return,request,get,principal
AbstractHandshakeHandler -> protected Principal determineUser(ServerHttpRequest request, WebSocketHandler wsHandler, 			Map<String, Object> attributes);1449660404;A method that can be used to associate a user with the WebSocket session_in the process of being established. The default implementation calls_{@link ServerHttpRequest#getPrincipal()}_<p>Subclasses can provide custom logic for associating a user with a session,_for example for assigning a name to anonymous users (i.e. not fully authenticated)._@param request the handshake request_@param wsHandler the WebSocket handler that will handle messages_@param attributes handshake attributes to pass to the WebSocket session_@return the user for the WebSocket session, or {@code null} if not available;protected Principal determineUser(ServerHttpRequest request, WebSocketHandler wsHandler,_			Map<String, Object> attributes) {__		return request.getPrincipal()__	};a,method,that,can,be,used,to,associate,a,user,with,the,web,socket,session,in,the,process,of,being,established,the,default,implementation,calls,link,server,http,request,get,principal,p,subclasses,can,provide,custom,logic,for,associating,a,user,with,a,session,for,example,for,assigning,a,name,to,anonymous,users,i,e,not,fully,authenticated,param,request,the,handshake,request,param,ws,handler,the,web,socket,handler,that,will,handle,messages,param,attributes,handshake,attributes,to,pass,to,the,web,socket,session,return,the,user,for,the,web,socket,session,or,code,null,if,not,available;protected,principal,determine,user,server,http,request,request,web,socket,handler,ws,handler,map,string,object,attributes,return,request,get,principal
AbstractHandshakeHandler -> protected Principal determineUser(ServerHttpRequest request, WebSocketHandler wsHandler, 			Map<String, Object> attributes);1467730834;A method that can be used to associate a user with the WebSocket session_in the process of being established. The default implementation calls_{@link ServerHttpRequest#getPrincipal()}_<p>Subclasses can provide custom logic for associating a user with a session,_for example for assigning a name to anonymous users (i.e. not fully authenticated)._@param request the handshake request_@param wsHandler the WebSocket handler that will handle messages_@param attributes handshake attributes to pass to the WebSocket session_@return the user for the WebSocket session, or {@code null} if not available;protected Principal determineUser(ServerHttpRequest request, WebSocketHandler wsHandler,_			Map<String, Object> attributes) {__		return request.getPrincipal()__	};a,method,that,can,be,used,to,associate,a,user,with,the,web,socket,session,in,the,process,of,being,established,the,default,implementation,calls,link,server,http,request,get,principal,p,subclasses,can,provide,custom,logic,for,associating,a,user,with,a,session,for,example,for,assigning,a,name,to,anonymous,users,i,e,not,fully,authenticated,param,request,the,handshake,request,param,ws,handler,the,web,socket,handler,that,will,handle,messages,param,attributes,handshake,attributes,to,pass,to,the,web,socket,session,return,the,user,for,the,web,socket,session,or,code,null,if,not,available;protected,principal,determine,user,server,http,request,request,web,socket,handler,ws,handler,map,string,object,attributes,return,request,get,principal
AbstractHandshakeHandler -> protected Principal determineUser(ServerHttpRequest request, WebSocketHandler wsHandler, 			Map<String, Object> attributes);1468948866;A method that can be used to associate a user with the WebSocket session_in the process of being established. The default implementation calls_{@link ServerHttpRequest#getPrincipal()}_<p>Subclasses can provide custom logic for associating a user with a session,_for example for assigning a name to anonymous users (i.e. not fully authenticated)._@param request the handshake request_@param wsHandler the WebSocket handler that will handle messages_@param attributes handshake attributes to pass to the WebSocket session_@return the user for the WebSocket session, or {@code null} if not available;protected Principal determineUser(ServerHttpRequest request, WebSocketHandler wsHandler,_			Map<String, Object> attributes) {__		return request.getPrincipal()__	};a,method,that,can,be,used,to,associate,a,user,with,the,web,socket,session,in,the,process,of,being,established,the,default,implementation,calls,link,server,http,request,get,principal,p,subclasses,can,provide,custom,logic,for,associating,a,user,with,a,session,for,example,for,assigning,a,name,to,anonymous,users,i,e,not,fully,authenticated,param,request,the,handshake,request,param,ws,handler,the,web,socket,handler,that,will,handle,messages,param,attributes,handshake,attributes,to,pass,to,the,web,socket,session,return,the,user,for,the,web,socket,session,or,code,null,if,not,available;protected,principal,determine,user,server,http,request,request,web,socket,handler,ws,handler,map,string,object,attributes,return,request,get,principal
AbstractHandshakeHandler -> protected Principal determineUser(ServerHttpRequest request, WebSocketHandler wsHandler, 			Map<String, Object> attributes);1468964586;A method that can be used to associate a user with the WebSocket session_in the process of being established. The default implementation calls_{@link ServerHttpRequest#getPrincipal()}_<p>Subclasses can provide custom logic for associating a user with a session,_for example for assigning a name to anonymous users (i.e. not fully authenticated)._@param request the handshake request_@param wsHandler the WebSocket handler that will handle messages_@param attributes handshake attributes to pass to the WebSocket session_@return the user for the WebSocket session, or {@code null} if not available;protected Principal determineUser(ServerHttpRequest request, WebSocketHandler wsHandler,_			Map<String, Object> attributes) {__		return request.getPrincipal()__	};a,method,that,can,be,used,to,associate,a,user,with,the,web,socket,session,in,the,process,of,being,established,the,default,implementation,calls,link,server,http,request,get,principal,p,subclasses,can,provide,custom,logic,for,associating,a,user,with,a,session,for,example,for,assigning,a,name,to,anonymous,users,i,e,not,fully,authenticated,param,request,the,handshake,request,param,ws,handler,the,web,socket,handler,that,will,handle,messages,param,attributes,handshake,attributes,to,pass,to,the,web,socket,session,return,the,user,for,the,web,socket,session,or,code,null,if,not,available;protected,principal,determine,user,server,http,request,request,web,socket,handler,ws,handler,map,string,object,attributes,return,request,get,principal
AbstractHandshakeHandler -> protected Principal determineUser(ServerHttpRequest request, WebSocketHandler wsHandler, 			Map<String, Object> attributes);1474905889;A method that can be used to associate a user with the WebSocket session_in the process of being established. The default implementation calls_{@link ServerHttpRequest#getPrincipal()}_<p>Subclasses can provide custom logic for associating a user with a session,_for example for assigning a name to anonymous users (i.e. not fully authenticated)._@param request the handshake request_@param wsHandler the WebSocket handler that will handle messages_@param attributes handshake attributes to pass to the WebSocket session_@return the user for the WebSocket session, or {@code null} if not available;protected Principal determineUser(ServerHttpRequest request, WebSocketHandler wsHandler,_			Map<String, Object> attributes) {__		return request.getPrincipal()__	};a,method,that,can,be,used,to,associate,a,user,with,the,web,socket,session,in,the,process,of,being,established,the,default,implementation,calls,link,server,http,request,get,principal,p,subclasses,can,provide,custom,logic,for,associating,a,user,with,a,session,for,example,for,assigning,a,name,to,anonymous,users,i,e,not,fully,authenticated,param,request,the,handshake,request,param,ws,handler,the,web,socket,handler,that,will,handle,messages,param,attributes,handshake,attributes,to,pass,to,the,web,socket,session,return,the,user,for,the,web,socket,session,or,code,null,if,not,available;protected,principal,determine,user,server,http,request,request,web,socket,handler,ws,handler,map,string,object,attributes,return,request,get,principal
