commented;modifiers;parameterAmount;loc;comment;code
true;public;1;3;/**  * Set an {@link AsyncListenableTaskExecutor} to use when opening connections.  * If this property is set to {@code null}, calls to any of the  * {@code doHandshake} methods will block until the connection is established.  * <p>By default an instance of {@code SimpleAsyncTaskExecutor} is used.  */ ;/**  * Set an {@link AsyncListenableTaskExecutor} to use when opening connections.  * If this property is set to {@code null}, calls to any of the  * {@code doHandshake} methods will block until the connection is established.  * <p>By default an instance of {@code SimpleAsyncTaskExecutor} is used.  */ public void setTaskExecutor(@Nullable AsyncListenableTaskExecutor taskExecutor) {     this.taskExecutor = taskExecutor. }
true;public;0;4;/**  * Return the configured {@link TaskExecutor}.  */ ;/**  * Return the configured {@link TaskExecutor}.  */ @Nullable public AsyncListenableTaskExecutor getTaskExecutor() {     return this.taskExecutor. }
false;public;0;9;;@Override public void start() {     try {         this.client.start().     } catch (Exception ex) {         throw new IllegalStateException("Failed to start Jetty WebSocketClient", ex).     } }
false;public;0;9;;@Override public void stop() {     try {         this.client.stop().     } catch (Exception ex) {         logger.error("Failed to stop Jetty WebSocketClient", ex).     } }
false;public;0;4;;@Override public boolean isRunning() {     return this.client.isStarted(). }
false;public;3;7;;@Override public ListenableFuture<WebSocketSession> doHandshake(WebSocketHandler webSocketHandler, String uriTemplate, Object... uriVars) {     UriComponents uriComponents = UriComponentsBuilder.fromUriString(uriTemplate).buildAndExpand(uriVars).encode().     return doHandshake(webSocketHandler, null, uriComponents.toUri()). }
false;public;6;33;;@Override public ListenableFuture<WebSocketSession> doHandshakeInternal(WebSocketHandler wsHandler, HttpHeaders headers, final URI uri, List<String> protocols, List<WebSocketExtension> extensions, Map<String, Object> attributes) {     final ClientUpgradeRequest request = new ClientUpgradeRequest().     request.setSubProtocols(protocols).     for (WebSocketExtension e : extensions) {         request.addExtensions(new WebSocketToJettyExtensionConfigAdapter(e)).     }     headers.forEach(request::setHeader).     Principal user = getUser().     final JettyWebSocketSession wsSession = new JettyWebSocketSession(attributes, user).     final JettyWebSocketHandlerAdapter listener = new JettyWebSocketHandlerAdapter(wsHandler, wsSession).     Callable<WebSocketSession> connectTask = () -> {         Future<Session> future = this.client.connect(listener, uri, request).         future.get().         return wsSession.     }.     if (this.taskExecutor != null) {         return this.taskExecutor.submitListenable(connectTask).     } else {         ListenableFutureTask<WebSocketSession> task = new ListenableFutureTask<>(connectTask).         task.run().         return task.     } }
true;protected;0;4;/**  * Return the user to make available through {@link WebSocketSession#getPrincipal()}.  * By default this method returns {@code null}  */ ;/**  * Return the user to make available through {@link WebSocketSession#getPrincipal()}.  * By default this method returns {@code null}  */ @Nullable protected Principal getUser() {     return null. }
