commented;modifiers;parameterAmount;loc;comment;code
false;public;0;4;;@Override public String getId() {     return this.id. }
false;protected;0;3;;protected SockJsMessageCodec getMessageCodec() {     return this.config.getMessageCodec(). }
false;public;0;3;;public SockJsServiceConfig getSockJsServiceConfig() {     return this.config. }
false;public;0;4;;@Override public Map<String, Object> getAttributes() {     return this.attributes. }
false;public,final;1;5;;// Message sending public final void sendMessage(WebSocketMessage<?> message) throws IOException {     Assert.state(!isClosed(), "Cannot send a message when session is closed").     Assert.isInstanceOf(TextMessage.class, message, "SockJS supports text messages only").     sendMessageInternal(((TextMessage) message).getPayload()). }
false;protected,abstract;1;1;;protected abstract void sendMessageInternal(String message) throws IOException.
false;public;0;3;;// Lifecycle related methods public boolean isNew() {     return State.NEW.equals(this.state). }
false;public;0;4;;@Override public boolean isOpen() {     return State.OPEN.equals(this.state). }
false;public;0;3;;public boolean isClosed() {     return State.CLOSED.equals(this.state). }
true;public,final;0;4;/**  * Performs cleanup and notify the {@link WebSocketHandler}.  */ ;/**  * Performs cleanup and notify the {@link WebSocketHandler}.  */ @Override public final void close() throws IOException {     close(new CloseStatus(3000, "Go away!")). }
true;public,final;1;30;/**  * Performs cleanup and notify the {@link WebSocketHandler}.  */ ;/**  * Performs cleanup and notify the {@link WebSocketHandler}.  */ @Override public final void close(CloseStatus status) throws IOException {     if (isOpen()) {         if (logger.isDebugEnabled()) {             logger.debug("Closing SockJS session " + getId() + " with " + status).         }         this.state = State.CLOSED.         try {             if (isActive() && !CloseStatus.SESSION_NOT_RELIABLE.equals(status)) {                 try {                     writeFrameInternal(SockJsFrame.closeFrame(status.getCode(), status.getReason())).                 } catch (Throwable ex) {                     logger.debug("Failure while sending SockJS close frame", ex).                 }             }             updateLastActiveTime().             cancelHeartbeat().             disconnect(status).         } finally {             try {                 this.handler.afterConnectionClosed(this, status).             } catch (Throwable ex) {                 logger.debug("Error from WebSocketHandler.afterConnectionClosed in " + this, ex).             }         }     } }
false;public;0;9;;@Override public long getTimeSinceLastActive() {     if (isNew()) {         return (System.currentTimeMillis() - this.timeCreated).     } else {         return (isActive() ? 0 : System.currentTimeMillis() - this.timeLastActive).     } }
true;protected;0;3;/**  * Should be invoked whenever the session becomes inactive.  */ ;/**  * Should be invoked whenever the session becomes inactive.  */ protected void updateLastActiveTime() {     this.timeLastActive = System.currentTimeMillis(). }
false;public;0;5;;@Override public void disableHeartbeat() {     this.heartbeatDisabled = true.     cancelHeartbeat(). }
false;protected;0;8;;protected void sendHeartbeat() throws SockJsTransportFailureException {     synchronized (this.responseLock) {         if (isActive() && !this.heartbeatDisabled) {             writeFrame(SockJsFrame.heartbeatFrame()).             scheduleHeartbeat().         }     } }
false;protected;0;17;;protected void scheduleHeartbeat() {     if (this.heartbeatDisabled) {         return.     }     synchronized (this.responseLock) {         cancelHeartbeat().         if (!isActive()) {             return.         }         Date time = new Date(System.currentTimeMillis() + this.config.getHeartbeatTime()).         this.heartbeatTask = new HeartbeatTask().         this.heartbeatFuture = this.config.getTaskScheduler().schedule(this.heartbeatTask, time).         if (logger.isTraceEnabled()) {             logger.trace("Scheduled heartbeat in session " + getId()).         }     } }
false;protected;0;15;;protected void cancelHeartbeat() {     synchronized (this.responseLock) {         if (this.heartbeatFuture != null) {             if (logger.isTraceEnabled()) {                 logger.trace("Cancelling heartbeat in session " + getId()).             }             this.heartbeatFuture.cancel(false).             this.heartbeatFuture = null.         }         if (this.heartbeatTask != null) {             this.heartbeatTask.cancel().             this.heartbeatTask = null.         }     } }
true;public,abstract;0;1;/**  * Polling and Streaming sessions periodically close the current HTTP request and  * wait for the next request to come through. During this "downtime" the session is  * still open but inactive and unable to send messages and therefore has to buffer  * them temporarily. A WebSocket session by contrast is stateful and remain active  * until closed.  */ ;/**  * Polling and Streaming sessions periodically close the current HTTP request and  * wait for the next request to come through. During this "downtime" the session is  * still open but inactive and unable to send messages and therefore has to buffer  * them temporarily. A WebSocket session by contrast is stateful and remain active  * until closed.  */ public abstract boolean isActive().
true;protected,abstract;1;1;/**  * Actually close the underlying WebSocket session or in the case of HTTP  * transports complete the underlying request.  */ ;/**  * Actually close the underlying WebSocket session or in the case of HTTP  * transports complete the underlying request.  */ protected abstract void disconnect(CloseStatus status) throws IOException.
true;protected;1;25;/**  * For internal use within a TransportHandler and the (TransportHandler-specific)  * session class.  */ ;// Frame writing /**  * For internal use within a TransportHandler and the (TransportHandler-specific)  * session class.  */ protected void writeFrame(SockJsFrame frame) throws SockJsTransportFailureException {     if (logger.isTraceEnabled()) {         logger.trace("Preparing to write " + frame).     }     try {         writeFrameInternal(frame).     } catch (Throwable ex) {         logWriteFrameFailure(ex).         try {             // Force disconnect (so we won't try to send close frame)             disconnect(CloseStatus.SERVER_ERROR).         } catch (Throwable disconnectFailure) {         // Ignore         }         try {             close(CloseStatus.SERVER_ERROR).         } catch (Throwable closeFailure) {         // Nothing of consequence, already forced disconnect         }         throw new SockJsTransportFailureException("Failed to write " + frame, getId(), ex).     } }
false;protected,abstract;1;1;;protected abstract void writeFrameInternal(SockJsFrame frame) throws IOException.
false;private;1;15;;private void logWriteFrameFailure(Throwable ex) {     if (indicatesDisconnectedClient(ex)) {         if (disconnectedClientLogger.isTraceEnabled()) {             disconnectedClientLogger.trace("Looks like the client has gone away", ex).         } else if (disconnectedClientLogger.isDebugEnabled()) {             disconnectedClientLogger.debug("Looks like the client has gone away: " + ex + " (For a full stack trace, set the log category '" + DISCONNECTED_CLIENT_LOG_CATEGORY + "' to TRACE level.)").         }     } else {         logger.debug("Terminating connection after failure to send message to client", ex).     } }
false;private;1;6;;private boolean indicatesDisconnectedClient(Throwable ex) {     String message = NestedExceptionUtils.getMostSpecificCause(ex).getMessage().     message = (message != null ? message.toLowerCase() : "").     String className = ex.getClass().getSimpleName().     return (message.contains("broken pipe") || DISCONNECTED_CLIENT_EXCEPTIONS.contains(className)). }
false;public;0;4;;// Delegation methods public void delegateConnectionEstablished() throws Exception {     this.state = State.OPEN.     this.handler.afterConnectionEstablished(this). }
false;public;1;17;;public void delegateMessages(String... messages) throws SockJsMessageDeliveryException {     List<String> undelivered = new ArrayList<>(Arrays.asList(messages)).     for (String message : messages) {         try {             if (isClosed()) {                 throw new SockJsMessageDeliveryException(this.id, undelivered, "Session closed").             } else {                 this.handler.handleMessage(this, new TextMessage(message)).                 undelivered.remove(0).             }         } catch (Throwable ex) {             throw new SockJsMessageDeliveryException(this.id, undelivered, ex).         }     } }
true;public,final;1;17;/**  * Invoked when the underlying connection is closed.  */ ;/**  * Invoked when the underlying connection is closed.  */ public final void delegateConnectionClosed(CloseStatus status) throws Exception {     if (!isClosed()) {         try {             updateLastActiveTime().             // Avoid cancelHeartbeat() and responseLock within server "close" callback             ScheduledFuture<?> future = this.heartbeatFuture.             if (future != null) {                 this.heartbeatFuture = null.                 future.cancel(false).             }         } finally {             this.state = State.CLOSED.             this.handler.afterConnectionClosed(this, status).         }     } }
true;public;2;18;/**  * Close due to error arising from SockJS transport handling.  */ ;/**  * Close due to error arising from SockJS transport handling.  */ public void tryCloseWithSockJsTransportError(Throwable error, CloseStatus closeStatus) {     if (logger.isDebugEnabled()) {         logger.debug("Closing due to transport error for " + this).     }     try {         delegateError(error).     } catch (Throwable delegateException) {         // Ignore         logger.debug("Exception from error handling delegate", delegateException).     }     try {         close(closeStatus).     } catch (Throwable closeException) {         logger.debug("Failure while closing " + this, closeException).     } }
false;public;1;3;;public void delegateError(Throwable ex) throws Exception {     this.handler.handleTransportError(this, ex). }
false;public;0;4;;// Self description @Override public String toString() {     return getClass().getSimpleName() + "[id=" + getId() + "]". }
false;public;0;16;;@Override public void run() {     synchronized (responseLock) {         if (!this.expired && !isClosed()) {             try {                 sendHeartbeat().             } catch (Throwable ex) {             // Ignore: already handled in writeFrame...             } finally {                 this.expired = true.             }         }     } }
false;;0;3;;void cancel() {     this.expired = true. }
