commented;modifiers;parameterAmount;loc;comment;code
false;public;0;4;;@Override public String getId() {     return this.request.getSockJsUrlInfo().getSessionId(). }
false;public;0;4;;@Override public URI getUri() {     return this.request.getSockJsUrlInfo().getSockJsUrl(). }
false;public;0;4;;@Override public HttpHeaders getHandshakeHeaders() {     return this.request.getHandshakeHeaders(). }
false;public;0;4;;@Override public Map<String, Object> getAttributes() {     return this.attributes. }
false;public;0;4;;@Override public Principal getPrincipal() {     return this.request.getUser(). }
false;public;0;3;;public SockJsMessageCodec getMessageCodec() {     return this.request.getMessageCodec(). }
false;public;0;3;;public WebSocketHandler getWebSocketHandler() {     return this.webSocketHandler. }
false;public;0;11;;@Override public void run() {     try {         closeInternal(new CloseStatus(2007, "Transport timed out")).     } catch (Throwable ex) {         if (logger.isWarnEnabled()) {             logger.warn("Failed to close " + this + " after transport timeout", ex).         }     } }
true;;0;15;/**  * Return a timeout cleanup task to invoke if the SockJS sessions is not  * fully established within the retransmission timeout period calculated in  * {@code SockJsRequest} based on the duration of the initial SockJS "Info"  * request.  */ ;/**  * Return a timeout cleanup task to invoke if the SockJS sessions is not  * fully established within the retransmission timeout period calculated in  * {@code SockJsRequest} based on the duration of the initial SockJS "Info"  * request.  */ Runnable getTimeoutTask() {     return new Runnable() {          @Override         public void run() {             try {                 closeInternal(new CloseStatus(2007, "Transport timed out")).             } catch (Throwable ex) {                 if (logger.isWarnEnabled()) {                     logger.warn("Failed to close " + this + " after transport timeout", ex).                 }             }         }     }. }
false;public;0;4;;@Override public boolean isOpen() {     return (this.state == State.OPEN). }
false;public;0;3;;public boolean isDisconnected() {     return (this.state == State.CLOSING || this.state == State.CLOSED). }
false;public,final;1;19;;@Override public final void sendMessage(WebSocketMessage<?> message) throws IOException {     if (!(message instanceof TextMessage)) {         throw new IllegalArgumentException(this + " supports text messages only.").     }     if (this.state != State.OPEN) {         throw new IllegalStateException(this + " is not open: current state " + this.state).     }     String payload = ((TextMessage) message).getPayload().     payload = getMessageCodec().encode(payload).     // the client-side doesn't need message framing (letter "a")     payload = payload.substring(1).     TextMessage messageToSend = new TextMessage(payload).     if (logger.isTraceEnabled()) {         logger.trace("Sending message " + messageToSend + " in " + this).     }     sendInternal(messageToSend). }
false;protected,abstract;1;1;;protected abstract void sendInternal(TextMessage textMessage) throws IOException.
false;public,final;0;4;;@Override public final void close() throws IOException {     close(CloseStatus.NORMAL). }
false;public,final;1;10;;@Override public final void close(CloseStatus status) throws IOException {     if (!isUserSetStatus(status)) {         throw new IllegalArgumentException("Invalid close status: " + status).     }     if (logger.isDebugEnabled()) {         logger.debug("Closing session with " + status + " in " + this).     }     closeInternal(status). }
false;private;1;4;;private boolean isUserSetStatus(@Nullable CloseStatus status) {     return (status != null && (status.getCode() == 1000 || (status.getCode() >= 3000 && status.getCode() <= 4999))). }
false;private;1;10;;private void silentClose(CloseStatus status) {     try {         closeInternal(status).     } catch (Throwable ex) {         if (logger.isWarnEnabled()) {             logger.warn("Failed to close " + this, ex).         }     } }
false;protected;1;16;;protected void closeInternal(CloseStatus status) throws IOException {     if (this.state == null) {         logger.warn("Ignoring close since connect() was never invoked").         return.     }     if (isDisconnected()) {         if (logger.isDebugEnabled()) {             logger.debug("Ignoring close (already closing or closed): current state " + this.state).         }         return.     }     this.state = State.CLOSING.     this.closeStatus = status.     disconnect(status). }
false;protected,abstract;1;1;;protected abstract void disconnect(CloseStatus status) throws IOException.
false;public;1;18;;public void handleFrame(String payload) {     SockJsFrame frame = new SockJsFrame(payload).     switch(frame.getType()) {         case OPEN:             handleOpenFrame().             break.         case HEARTBEAT:             if (logger.isTraceEnabled()) {                 logger.trace("Received heartbeat in " + this).             }             break.         case MESSAGE:             handleMessageFrame(frame).             break.         case CLOSE:             handleCloseFrame(frame).     } }
false;private;0;24;;private void handleOpenFrame() {     if (logger.isDebugEnabled()) {         logger.debug("Processing SockJS open frame in " + this).     }     if (this.state == State.NEW) {         this.state = State.OPEN.         try {             this.webSocketHandler.afterConnectionEstablished(this).             this.connectFuture.set(this).         } catch (Throwable ex) {             if (logger.isErrorEnabled()) {                 logger.error("WebSocketHandler.afterConnectionEstablished threw exception in " + this, ex).             }         }     } else {         if (logger.isDebugEnabled()) {             logger.debug("Open frame received in " + getId() + " but we're not connecting (current state " + this.state + "). The server might have been restarted and lost track of the session.").         }         silentClose(new CloseStatus(1006, "Server lost session")).     } }
false;private;1;40;;private void handleMessageFrame(SockJsFrame frame) {     if (!isOpen()) {         if (logger.isErrorEnabled()) {             logger.error("Ignoring received message due to state " + this.state + " in " + this).         }         return.     }     String[] messages = null.     String frameData = frame.getFrameData().     if (frameData != null) {         try {             messages = getMessageCodec().decode(frameData).         } catch (IOException ex) {             if (logger.isErrorEnabled()) {                 logger.error("Failed to decode data for SockJS \"message\" frame: " + frame + " in " + this, ex).             }             silentClose(CloseStatus.BAD_DATA).             return.         }     }     if (messages == null) {         return.     }     if (logger.isTraceEnabled()) {         logger.trace("Processing SockJS message frame " + frame.getContent() + " in " + this).     }     for (String message : messages) {         if (isOpen()) {             try {                 this.webSocketHandler.handleMessage(this, new TextMessage(message)).             } catch (Throwable ex) {                 logger.error("WebSocketHandler.handleMessage threw an exception on " + frame + " in " + this, ex).             }         }     } }
false;private;1;21;;private void handleCloseFrame(SockJsFrame frame) {     CloseStatus closeStatus = CloseStatus.NO_STATUS_CODE.     try {         String frameData = frame.getFrameData().         if (frameData != null) {             String[] data = getMessageCodec().decode(frameData).             if (data != null && data.length == 2) {                 closeStatus = new CloseStatus(Integer.valueOf(data[0]), data[1]).             }             if (logger.isDebugEnabled()) {                 logger.debug("Processing SockJS close frame with " + closeStatus + " in " + this).             }         }     } catch (IOException ex) {         if (logger.isErrorEnabled()) {             logger.error("Failed to decode data for " + frame + " in " + this, ex).         }     }     silentClose(closeStatus). }
false;public;1;11;;public void handleTransportError(Throwable error) {     try {         if (logger.isErrorEnabled()) {             logger.error("Transport error in " + this, error).         }         this.webSocketHandler.handleTransportError(this, error).     } catch (Throwable ex) {         logger.error("WebSocketHandler.handleTransportError threw an exception", ex).     } }
false;public;1;19;;public void afterTransportClosed(@Nullable CloseStatus closeStatus) {     CloseStatus cs = this.closeStatus.     if (cs == null) {         cs = closeStatus.         this.closeStatus = closeStatus.     }     Assert.state(cs != null, "CloseStatus not available").     if (logger.isDebugEnabled()) {         logger.debug("Transport closed with " + cs + " in " + this).     }     this.state = State.CLOSED.     try {         this.webSocketHandler.afterConnectionClosed(this, cs).     } catch (Throwable ex) {         logger.error("WebSocketHandler.afterConnectionClosed threw an exception", ex).     } }
false;public;0;4;;@Override public String toString() {     return getClass().getSimpleName() + "[id='" + getId() + ", url=" + getUri() + "]". }
