commented;modifiers;parameterAmount;loc;comment;code
true;public;0;3;/**  * Return the configured send-time limit (milliseconds).  * @since 4.3.13  */ ;/**  * Return the configured send-time limit (milliseconds).  * @since 4.3.13  */ public int getSendTimeLimit() {     return this.sendTimeLimit. }
true;public;0;3;/**  * Return the configured buffer-size limit (number of bytes).  * @since 4.3.13  */ ;/**  * Return the configured buffer-size limit (number of bytes).  * @since 4.3.13  */ public int getBufferSizeLimit() {     return this.bufferSizeLimit. }
true;public;0;3;/**  * Return the current buffer size (number of bytes).  */ ;/**  * Return the current buffer size (number of bytes).  */ public int getBufferSize() {     return this.bufferSize.get(). }
true;public;0;4;/**  * Return the time (milliseconds) since the current send started,  * or 0 if no send is currently in progress.  */ ;/**  * Return the time (milliseconds) since the current send started,  * or 0 if no send is currently in progress.  */ public long getTimeSinceSendStarted() {     long start = this.sendStartTime.     return (start > 0 ? (System.currentTimeMillis() - start) : 0). }
false;public;1;22;;@Override public void sendMessage(WebSocketMessage<?> message) throws IOException {     if (shouldNotSend()) {         return.     }     this.buffer.add(message).     this.bufferSize.addAndGet(message.getPayloadLength()).     do {         if (!tryFlushMessageBuffer()) {             if (logger.isTraceEnabled()) {                 logger.trace(String.format("Another send already in progress: " + "session id '%s':, \"in-progress\" send time %d (ms), buffer size %d bytes", getId(), getTimeSinceSendStarted(), getBufferSize())).             }             checkSessionLimits().             break.         }     } while (!this.buffer.isEmpty() && !shouldNotSend()). }
false;private;0;3;;private boolean shouldNotSend() {     return (this.limitExceeded || this.closeInProgress). }
false;private;0;22;;private boolean tryFlushMessageBuffer() throws IOException {     if (this.flushLock.tryLock()) {         try {             while (true) {                 WebSocketMessage<?> message = this.buffer.poll().                 if (message == null || shouldNotSend()) {                     break.                 }                 this.bufferSize.addAndGet(-message.getPayloadLength()).                 this.sendStartTime = System.currentTimeMillis().                 getDelegate().sendMessage(message).                 this.sendStartTime = 0.             }         } finally {             this.sendStartTime = 0.             this.flushLock.unlock().         }         return true.     }     return false. }
false;private;0;40;;private void checkSessionLimits() {     if (!shouldNotSend() && this.closeLock.tryLock()) {         try {             if (getTimeSinceSendStarted() > getSendTimeLimit()) {                 String format = "Send time %d (ms) for session '%s' exceeded the allowed limit %d".                 String reason = String.format(format, getTimeSinceSendStarted(), getId(), getSendTimeLimit()).                 limitExceeded(reason).             } else if (getBufferSize() > getBufferSizeLimit()) {                 switch(this.overflowStrategy) {                     case TERMINATE:                         String format = "Buffer size %d bytes for session '%s' exceeds the allowed limit %d".                         String reason = String.format(format, getBufferSize(), getId(), getBufferSizeLimit()).                         limitExceeded(reason).                         break.                     case DROP:                         int i = 0.                         while (getBufferSize() > getBufferSizeLimit()) {                             WebSocketMessage<?> message = this.buffer.poll().                             if (message == null) {                                 break.                             }                             this.bufferSize.addAndGet(-message.getPayloadLength()).                             i++.                         }                         if (logger.isDebugEnabled()) {                             logger.debug("Dropped " + i + " messages, buffer size: " + getBufferSize()).                         }                         break.                     default:                         // Should never happen..                         throw new IllegalStateException("Unexpected OverflowStrategy: " + this.overflowStrategy).                 }             }         } finally {             this.closeLock.unlock().         }     } }
false;private;1;4;;private void limitExceeded(String reason) {     this.limitExceeded = true.     throw new SessionLimitExceededException(reason, CloseStatus.SESSION_NOT_RELIABLE). }
false;public;1;28;;@Override public void close(CloseStatus status) throws IOException {     this.closeLock.lock().     try {         if (this.closeInProgress) {             return.         }         if (!CloseStatus.SESSION_NOT_RELIABLE.equals(status)) {             try {                 checkSessionLimits().             } catch (SessionLimitExceededException ex) {             // Ignore             }             if (this.limitExceeded) {                 if (logger.isDebugEnabled()) {                     logger.debug("Changing close status " + status + " to SESSION_NOT_RELIABLE.").                 }                 status = CloseStatus.SESSION_NOT_RELIABLE.             }         }         this.closeInProgress = true.         super.close(status).     } finally {         this.closeLock.unlock().     } }
false;public;0;4;;@Override public String toString() {     return getDelegate().toString(). }
