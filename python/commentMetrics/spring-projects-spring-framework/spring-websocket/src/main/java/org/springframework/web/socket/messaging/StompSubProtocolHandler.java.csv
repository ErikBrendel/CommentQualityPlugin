# id;timestamp;commentText;codeText;commentWords;codeWords
StompSubProtocolHandler -> public void setErrorHandler(StompSubProtocolErrorHandler errorHandler);1431728285;Configure a handler for error messages sent to clients which allows_customizing the error messages or preventing them from being sent._<p>By default this isn't configured in which case an ERROR frame is sent_with a message header reflecting the error._@param errorHandler the error handler;public void setErrorHandler(StompSubProtocolErrorHandler errorHandler) {_		this.errorHandler = errorHandler__	};configure,a,handler,for,error,messages,sent,to,clients,which,allows,customizing,the,error,messages,or,preventing,them,from,being,sent,p,by,default,this,isn,t,configured,in,which,case,an,error,frame,is,sent,with,a,message,header,reflecting,the,error,param,error,handler,the,error,handler;public,void,set,error,handler,stomp,sub,protocol,error,handler,error,handler,this,error,handler,error,handler
StompSubProtocolHandler -> public void setErrorHandler(StompSubProtocolErrorHandler errorHandler);1432316649;Configure a handler for error messages sent to clients which allows_customizing the error messages or preventing them from being sent._<p>By default this isn't configured in which case an ERROR frame is sent_with a message header reflecting the error._@param errorHandler the error handler;public void setErrorHandler(StompSubProtocolErrorHandler errorHandler) {_		this.errorHandler = errorHandler__	};configure,a,handler,for,error,messages,sent,to,clients,which,allows,customizing,the,error,messages,or,preventing,them,from,being,sent,p,by,default,this,isn,t,configured,in,which,case,an,error,frame,is,sent,with,a,message,header,reflecting,the,error,param,error,handler,the,error,handler;public,void,set,error,handler,stomp,sub,protocol,error,handler,error,handler,this,error,handler,error,handler
StompSubProtocolHandler -> public void setErrorHandler(StompSubProtocolErrorHandler errorHandler);1432331447;Configure a handler for error messages sent to clients which allows_customizing the error messages or preventing them from being sent._<p>By default this isn't configured in which case an ERROR frame is sent_with a message header reflecting the error._@param errorHandler the error handler;public void setErrorHandler(StompSubProtocolErrorHandler errorHandler) {_		this.errorHandler = errorHandler__	};configure,a,handler,for,error,messages,sent,to,clients,which,allows,customizing,the,error,messages,or,preventing,them,from,being,sent,p,by,default,this,isn,t,configured,in,which,case,an,error,frame,is,sent,with,a,message,header,reflecting,the,error,param,error,handler,the,error,handler;public,void,set,error,handler,stomp,sub,protocol,error,handler,error,handler,this,error,handler,error,handler
StompSubProtocolHandler -> public void setErrorHandler(StompSubProtocolErrorHandler errorHandler);1440168414;Configure a handler for error messages sent to clients which allows_customizing the error messages or preventing them from being sent._<p>By default this isn't configured in which case an ERROR frame is sent_with a message header reflecting the error._@param errorHandler the error handler;public void setErrorHandler(StompSubProtocolErrorHandler errorHandler) {_		this.errorHandler = errorHandler__	};configure,a,handler,for,error,messages,sent,to,clients,which,allows,customizing,the,error,messages,or,preventing,them,from,being,sent,p,by,default,this,isn,t,configured,in,which,case,an,error,frame,is,sent,with,a,message,header,reflecting,the,error,param,error,handler,the,error,handler;public,void,set,error,handler,stomp,sub,protocol,error,handler,error,handler,this,error,handler,error,handler
StompSubProtocolHandler -> public void setErrorHandler(StompSubProtocolErrorHandler errorHandler);1440249342;Configure a handler for error messages sent to clients which allows_customizing the error messages or preventing them from being sent._<p>By default this isn't configured in which case an ERROR frame is sent_with a message header reflecting the error._@param errorHandler the error handler;public void setErrorHandler(StompSubProtocolErrorHandler errorHandler) {_		this.errorHandler = errorHandler__	};configure,a,handler,for,error,messages,sent,to,clients,which,allows,customizing,the,error,messages,or,preventing,them,from,being,sent,p,by,default,this,isn,t,configured,in,which,case,an,error,frame,is,sent,with,a,message,header,reflecting,the,error,param,error,handler,the,error,handler;public,void,set,error,handler,stomp,sub,protocol,error,handler,error,handler,this,error,handler,error,handler
StompSubProtocolHandler -> public void setErrorHandler(StompSubProtocolErrorHandler errorHandler);1467726769;Configure a handler for error messages sent to clients which allows_customizing the error messages or preventing them from being sent._<p>By default this isn't configured in which case an ERROR frame is sent_with a message header reflecting the error._@param errorHandler the error handler;public void setErrorHandler(StompSubProtocolErrorHandler errorHandler) {_		this.errorHandler = errorHandler__	};configure,a,handler,for,error,messages,sent,to,clients,which,allows,customizing,the,error,messages,or,preventing,them,from,being,sent,p,by,default,this,isn,t,configured,in,which,case,an,error,frame,is,sent,with,a,message,header,reflecting,the,error,param,error,handler,the,error,handler;public,void,set,error,handler,stomp,sub,protocol,error,handler,error,handler,this,error,handler,error,handler
StompSubProtocolHandler -> public void setErrorHandler(StompSubProtocolErrorHandler errorHandler);1467730834;Configure a handler for error messages sent to clients which allows_customizing the error messages or preventing them from being sent._<p>By default this isn't configured in which case an ERROR frame is sent_with a message header reflecting the error._@param errorHandler the error handler;public void setErrorHandler(StompSubProtocolErrorHandler errorHandler) {_		this.errorHandler = errorHandler__	};configure,a,handler,for,error,messages,sent,to,clients,which,allows,customizing,the,error,messages,or,preventing,them,from,being,sent,p,by,default,this,isn,t,configured,in,which,case,an,error,frame,is,sent,with,a,message,header,reflecting,the,error,param,error,handler,the,error,handler;public,void,set,error,handler,stomp,sub,protocol,error,handler,error,handler,this,error,handler,error,handler
StompSubProtocolHandler -> public void setErrorHandler(StompSubProtocolErrorHandler errorHandler);1472062321;Configure a handler for error messages sent to clients which allows_customizing the error messages or preventing them from being sent._<p>By default this isn't configured in which case an ERROR frame is sent_with a message header reflecting the error._@param errorHandler the error handler;public void setErrorHandler(StompSubProtocolErrorHandler errorHandler) {_		this.errorHandler = errorHandler__	};configure,a,handler,for,error,messages,sent,to,clients,which,allows,customizing,the,error,messages,or,preventing,them,from,being,sent,p,by,default,this,isn,t,configured,in,which,case,an,error,frame,is,sent,with,a,message,header,reflecting,the,error,param,error,handler,the,error,handler;public,void,set,error,handler,stomp,sub,protocol,error,handler,error,handler,this,error,handler,error,handler
StompSubProtocolHandler -> public void setErrorHandler(StompSubProtocolErrorHandler errorHandler);1472509879;Configure a handler for error messages sent to clients which allows_customizing the error messages or preventing them from being sent._<p>By default this isn't configured in which case an ERROR frame is sent_with a message header reflecting the error._@param errorHandler the error handler;public void setErrorHandler(StompSubProtocolErrorHandler errorHandler) {_		this.errorHandler = errorHandler__	};configure,a,handler,for,error,messages,sent,to,clients,which,allows,customizing,the,error,messages,or,preventing,them,from,being,sent,p,by,default,this,isn,t,configured,in,which,case,an,error,frame,is,sent,with,a,message,header,reflecting,the,error,param,error,handler,the,error,handler;public,void,set,error,handler,stomp,sub,protocol,error,handler,error,handler,this,error,handler,error,handler
StompSubProtocolHandler -> public void setErrorHandler(StompSubProtocolErrorHandler errorHandler);1476284885;Configure a handler for error messages sent to clients which allows_customizing the error messages or preventing them from being sent._<p>By default this isn't configured in which case an ERROR frame is sent_with a message header reflecting the error._@param errorHandler the error handler;public void setErrorHandler(StompSubProtocolErrorHandler errorHandler) {_		this.errorHandler = errorHandler__	};configure,a,handler,for,error,messages,sent,to,clients,which,allows,customizing,the,error,messages,or,preventing,them,from,being,sent,p,by,default,this,isn,t,configured,in,which,case,an,error,frame,is,sent,with,a,message,header,reflecting,the,error,param,error,handler,the,error,handler;public,void,set,error,handler,stomp,sub,protocol,error,handler,error,handler,this,error,handler,error,handler
StompSubProtocolHandler -> public void setErrorHandler(StompSubProtocolErrorHandler errorHandler);1481213680;Configure a handler for error messages sent to clients which allows_customizing the error messages or preventing them from being sent._<p>By default this isn't configured in which case an ERROR frame is sent_with a message header reflecting the error._@param errorHandler the error handler;public void setErrorHandler(StompSubProtocolErrorHandler errorHandler) {_		this.errorHandler = errorHandler__	};configure,a,handler,for,error,messages,sent,to,clients,which,allows,customizing,the,error,messages,or,preventing,them,from,being,sent,p,by,default,this,isn,t,configured,in,which,case,an,error,frame,is,sent,with,a,message,header,reflecting,the,error,param,error,handler,the,error,handler;public,void,set,error,handler,stomp,sub,protocol,error,handler,error,handler,this,error,handler,error,handler
StompSubProtocolHandler -> public void setErrorHandler(StompSubProtocolErrorHandler errorHandler);1481669991;Configure a handler for error messages sent to clients which allows_customizing the error messages or preventing them from being sent._<p>By default this isn't configured in which case an ERROR frame is sent_with a message header reflecting the error._@param errorHandler the error handler;public void setErrorHandler(StompSubProtocolErrorHandler errorHandler) {_		this.errorHandler = errorHandler__	};configure,a,handler,for,error,messages,sent,to,clients,which,allows,customizing,the,error,messages,or,preventing,them,from,being,sent,p,by,default,this,isn,t,configured,in,which,case,an,error,frame,is,sent,with,a,message,header,reflecting,the,error,param,error,handler,the,error,handler;public,void,set,error,handler,stomp,sub,protocol,error,handler,error,handler,this,error,handler,error,handler
StompSubProtocolHandler -> public void setErrorHandler(StompSubProtocolErrorHandler errorHandler);1482265068;Configure a handler for error messages sent to clients which allows_customizing the error messages or preventing them from being sent._<p>By default this isn't configured in which case an ERROR frame is sent_with a message header reflecting the error._@param errorHandler the error handler;public void setErrorHandler(StompSubProtocolErrorHandler errorHandler) {_		this.errorHandler = errorHandler__	};configure,a,handler,for,error,messages,sent,to,clients,which,allows,customizing,the,error,messages,or,preventing,them,from,being,sent,p,by,default,this,isn,t,configured,in,which,case,an,error,frame,is,sent,with,a,message,header,reflecting,the,error,param,error,handler,the,error,handler;public,void,set,error,handler,stomp,sub,protocol,error,handler,error,handler,this,error,handler,error,handler
StompSubProtocolHandler -> public void setErrorHandler(StompSubProtocolErrorHandler errorHandler);1495868221;Configure a handler for error messages sent to clients which allows_customizing the error messages or preventing them from being sent._<p>By default this isn't configured in which case an ERROR frame is sent_with a message header reflecting the error._@param errorHandler the error handler;public void setErrorHandler(StompSubProtocolErrorHandler errorHandler) {_		this.errorHandler = errorHandler__	};configure,a,handler,for,error,messages,sent,to,clients,which,allows,customizing,the,error,messages,or,preventing,them,from,being,sent,p,by,default,this,isn,t,configured,in,which,case,an,error,frame,is,sent,with,a,message,header,reflecting,the,error,param,error,handler,the,error,handler;public,void,set,error,handler,stomp,sub,protocol,error,handler,error,handler,this,error,handler,error,handler
StompSubProtocolHandler -> public void setErrorHandler(StompSubProtocolErrorHandler errorHandler);1496837955;Configure a handler for error messages sent to clients which allows_customizing the error messages or preventing them from being sent._<p>By default this isn't configured in which case an ERROR frame is sent_with a message header reflecting the error._@param errorHandler the error handler;public void setErrorHandler(StompSubProtocolErrorHandler errorHandler) {_		this.errorHandler = errorHandler__	};configure,a,handler,for,error,messages,sent,to,clients,which,allows,customizing,the,error,messages,or,preventing,them,from,being,sent,p,by,default,this,isn,t,configured,in,which,case,an,error,frame,is,sent,with,a,message,header,reflecting,the,error,param,error,handler,the,error,handler;public,void,set,error,handler,stomp,sub,protocol,error,handler,error,handler,this,error,handler,error,handler
StompSubProtocolHandler -> public void setErrorHandler(StompSubProtocolErrorHandler errorHandler);1497251962;Configure a handler for error messages sent to clients which allows_customizing the error messages or preventing them from being sent._<p>By default this isn't configured in which case an ERROR frame is sent_with a message header reflecting the error._@param errorHandler the error handler;public void setErrorHandler(StompSubProtocolErrorHandler errorHandler) {_		this.errorHandler = errorHandler__	};configure,a,handler,for,error,messages,sent,to,clients,which,allows,customizing,the,error,messages,or,preventing,them,from,being,sent,p,by,default,this,isn,t,configured,in,which,case,an,error,frame,is,sent,with,a,message,header,reflecting,the,error,param,error,handler,the,error,handler;public,void,set,error,handler,stomp,sub,protocol,error,handler,error,handler,this,error,handler,error,handler
StompSubProtocolHandler -> public void setErrorHandler(StompSubProtocolErrorHandler errorHandler);1498780456;Configure a handler for error messages sent to clients which allows_customizing the error messages or preventing them from being sent._<p>By default this isn't configured in which case an ERROR frame is sent_with a message header reflecting the error._@param errorHandler the error handler;public void setErrorHandler(StompSubProtocolErrorHandler errorHandler) {_		this.errorHandler = errorHandler__	};configure,a,handler,for,error,messages,sent,to,clients,which,allows,customizing,the,error,messages,or,preventing,them,from,being,sent,p,by,default,this,isn,t,configured,in,which,case,an,error,frame,is,sent,with,a,message,header,reflecting,the,error,param,error,handler,the,error,handler;public,void,set,error,handler,stomp,sub,protocol,error,handler,error,handler,this,error,handler,error,handler
StompSubProtocolHandler -> public void setErrorHandler(StompSubProtocolErrorHandler errorHandler);1500448076;Configure a handler for error messages sent to clients which allows_customizing the error messages or preventing them from being sent._<p>By default this isn't configured in which case an ERROR frame is sent_with a message header reflecting the error._@param errorHandler the error handler;public void setErrorHandler(StompSubProtocolErrorHandler errorHandler) {_		this.errorHandler = errorHandler__	};configure,a,handler,for,error,messages,sent,to,clients,which,allows,customizing,the,error,messages,or,preventing,them,from,being,sent,p,by,default,this,isn,t,configured,in,which,case,an,error,frame,is,sent,with,a,message,header,reflecting,the,error,param,error,handler,the,error,handler;public,void,set,error,handler,stomp,sub,protocol,error,handler,error,handler,this,error,handler,error,handler
StompSubProtocolHandler -> public void setErrorHandler(StompSubProtocolErrorHandler errorHandler);1501147952;Configure a handler for error messages sent to clients which allows_customizing the error messages or preventing them from being sent._<p>By default this isn't configured in which case an ERROR frame is sent_with a message header reflecting the error._@param errorHandler the error handler;public void setErrorHandler(StompSubProtocolErrorHandler errorHandler) {_		this.errorHandler = errorHandler__	};configure,a,handler,for,error,messages,sent,to,clients,which,allows,customizing,the,error,messages,or,preventing,them,from,being,sent,p,by,default,this,isn,t,configured,in,which,case,an,error,frame,is,sent,with,a,message,header,reflecting,the,error,param,error,handler,the,error,handler;public,void,set,error,handler,stomp,sub,protocol,error,handler,error,handler,this,error,handler,error,handler
StompSubProtocolHandler -> public void setErrorHandler(StompSubProtocolErrorHandler errorHandler);1502974979;Configure a handler for error messages sent to clients which allows_customizing the error messages or preventing them from being sent._<p>By default this isn't configured in which case an ERROR frame is sent_with a message header reflecting the error._@param errorHandler the error handler;public void setErrorHandler(StompSubProtocolErrorHandler errorHandler) {_		this.errorHandler = errorHandler__	};configure,a,handler,for,error,messages,sent,to,clients,which,allows,customizing,the,error,messages,or,preventing,them,from,being,sent,p,by,default,this,isn,t,configured,in,which,case,an,error,frame,is,sent,with,a,message,header,reflecting,the,error,param,error,handler,the,error,handler;public,void,set,error,handler,stomp,sub,protocol,error,handler,error,handler,this,error,handler,error,handler
StompSubProtocolHandler -> public void setErrorHandler(StompSubProtocolErrorHandler errorHandler);1509997270;Configure a handler for error messages sent to clients which allows_customizing the error messages or preventing them from being sent._<p>By default this isn't configured in which case an ERROR frame is sent_with a message header reflecting the error._@param errorHandler the error handler;public void setErrorHandler(StompSubProtocolErrorHandler errorHandler) {_		this.errorHandler = errorHandler__	};configure,a,handler,for,error,messages,sent,to,clients,which,allows,customizing,the,error,messages,or,preventing,them,from,being,sent,p,by,default,this,isn,t,configured,in,which,case,an,error,frame,is,sent,with,a,message,header,reflecting,the,error,param,error,handler,the,error,handler;public,void,set,error,handler,stomp,sub,protocol,error,handler,error,handler,this,error,handler,error,handler
StompSubProtocolHandler -> public void setErrorHandler(StompSubProtocolErrorHandler errorHandler);1530174524;Configure a handler for error messages sent to clients which allows_customizing the error messages or preventing them from being sent._<p>By default this isn't configured in which case an ERROR frame is sent_with a message header reflecting the error._@param errorHandler the error handler;public void setErrorHandler(StompSubProtocolErrorHandler errorHandler) {_		this.errorHandler = errorHandler__	};configure,a,handler,for,error,messages,sent,to,clients,which,allows,customizing,the,error,messages,or,preventing,them,from,being,sent,p,by,default,this,isn,t,configured,in,which,case,an,error,frame,is,sent,with,a,message,header,reflecting,the,error,param,error,handler,the,error,handler;public,void,set,error,handler,stomp,sub,protocol,error,handler,error,handler,this,error,handler,error,handler
StompSubProtocolHandler -> public void setErrorHandler(StompSubProtocolErrorHandler errorHandler);1536886762;Configure a handler for error messages sent to clients which allows_customizing the error messages or preventing them from being sent._<p>By default this isn't configured in which case an ERROR frame is sent_with a message header reflecting the error._@param errorHandler the error handler;public void setErrorHandler(StompSubProtocolErrorHandler errorHandler) {_		this.errorHandler = errorHandler__	};configure,a,handler,for,error,messages,sent,to,clients,which,allows,customizing,the,error,messages,or,preventing,them,from,being,sent,p,by,default,this,isn,t,configured,in,which,case,an,error,frame,is,sent,with,a,message,header,reflecting,the,error,param,error,handler,the,error,handler;public,void,set,error,handler,stomp,sub,protocol,error,handler,error,handler,this,error,handler,error,handler
StompSubProtocolHandler -> public void setErrorHandler(StompSubProtocolErrorHandler errorHandler);1542899558;Configure a handler for error messages sent to clients which allows_customizing the error messages or preventing them from being sent._<p>By default this isn't configured in which case an ERROR frame is sent_with a message header reflecting the error._@param errorHandler the error handler;public void setErrorHandler(StompSubProtocolErrorHandler errorHandler) {_		this.errorHandler = errorHandler__	};configure,a,handler,for,error,messages,sent,to,clients,which,allows,customizing,the,error,messages,or,preventing,them,from,being,sent,p,by,default,this,isn,t,configured,in,which,case,an,error,frame,is,sent,with,a,message,header,reflecting,the,error,param,error,handler,the,error,handler;public,void,set,error,handler,stomp,sub,protocol,error,handler,error,handler,this,error,handler,error,handler
StompSubProtocolHandler -> @Deprecated 	protected void sendErrorMessage(WebSocketSession session, Throwable error);1431728285;Invoked when no_{@link #setErrorHandler(StompSubProtocolErrorHandler) errorHandler} is_configured to send an ERROR frame to the client._@deprecated as of 4.2 this method is deprecated in favor of_{@link #setErrorHandler(StompSubProtocolErrorHandler) configuring} a_{@code StompSubProtocolErrorHandler}.;@Deprecated_	protected void sendErrorMessage(WebSocketSession session, Throwable error) {_		StompHeaderAccessor headerAccessor = StompHeaderAccessor.create(StompCommand.ERROR)__		headerAccessor.setMessage(error.getMessage())__		byte[] bytes = this.stompEncoder.encode(headerAccessor.getMessageHeaders(), EMPTY_PAYLOAD)__		try {_			session.sendMessage(new TextMessage(bytes))__		}_		catch (Throwable ex) {_			_			logger.debug("Failed to send STOMP ERROR to client.", ex)__		}_	};invoked,when,no,link,set,error,handler,stomp,sub,protocol,error,handler,error,handler,is,configured,to,send,an,error,frame,to,the,client,deprecated,as,of,4,2,this,method,is,deprecated,in,favor,of,link,set,error,handler,stomp,sub,protocol,error,handler,configuring,a,code,stomp,sub,protocol,error,handler;deprecated,protected,void,send,error,message,web,socket,session,session,throwable,error,stomp,header,accessor,header,accessor,stomp,header,accessor,create,stomp,command,error,header,accessor,set,message,error,get,message,byte,bytes,this,stomp,encoder,encode,header,accessor,get,message,headers,try,session,send,message,new,text,message,bytes,catch,throwable,ex,logger,debug,failed,to,send,stomp,error,to,client,ex
StompSubProtocolHandler -> @Deprecated 	protected void sendErrorMessage(WebSocketSession session, Throwable error);1432316649;Invoked when no_{@link #setErrorHandler(StompSubProtocolErrorHandler) errorHandler} is_configured to send an ERROR frame to the client._@deprecated as of 4.2 this method is deprecated in favor of_{@link #setErrorHandler(StompSubProtocolErrorHandler) configuring} a_{@code StompSubProtocolErrorHandler}.;@Deprecated_	protected void sendErrorMessage(WebSocketSession session, Throwable error) {_		StompHeaderAccessor headerAccessor = StompHeaderAccessor.create(StompCommand.ERROR)__		headerAccessor.setMessage(error.getMessage())__		byte[] bytes = this.stompEncoder.encode(headerAccessor.getMessageHeaders(), EMPTY_PAYLOAD)__		try {_			session.sendMessage(new TextMessage(bytes))__		}_		catch (Throwable ex) {_			_			logger.debug("Failed to send STOMP ERROR to client.", ex)__		}_	};invoked,when,no,link,set,error,handler,stomp,sub,protocol,error,handler,error,handler,is,configured,to,send,an,error,frame,to,the,client,deprecated,as,of,4,2,this,method,is,deprecated,in,favor,of,link,set,error,handler,stomp,sub,protocol,error,handler,configuring,a,code,stomp,sub,protocol,error,handler;deprecated,protected,void,send,error,message,web,socket,session,session,throwable,error,stomp,header,accessor,header,accessor,stomp,header,accessor,create,stomp,command,error,header,accessor,set,message,error,get,message,byte,bytes,this,stomp,encoder,encode,header,accessor,get,message,headers,try,session,send,message,new,text,message,bytes,catch,throwable,ex,logger,debug,failed,to,send,stomp,error,to,client,ex
StompSubProtocolHandler -> @Deprecated 	protected void sendErrorMessage(WebSocketSession session, Throwable error);1432331447;Invoked when no_{@link #setErrorHandler(StompSubProtocolErrorHandler) errorHandler}_is configured to send an ERROR frame to the client._@deprecated as of Spring 4.2, in favor of_{@link #setErrorHandler(StompSubProtocolErrorHandler) configuring}_a {@code StompSubProtocolErrorHandler};@Deprecated_	protected void sendErrorMessage(WebSocketSession session, Throwable error) {_		StompHeaderAccessor headerAccessor = StompHeaderAccessor.create(StompCommand.ERROR)__		headerAccessor.setMessage(error.getMessage())___		byte[] bytes = this.stompEncoder.encode(headerAccessor.getMessageHeaders(), EMPTY_PAYLOAD)__		try {_			session.sendMessage(new TextMessage(bytes))__		}_		catch (Throwable ex) {_			_			logger.debug("Failed to send STOMP ERROR to client", ex)__		}_	};invoked,when,no,link,set,error,handler,stomp,sub,protocol,error,handler,error,handler,is,configured,to,send,an,error,frame,to,the,client,deprecated,as,of,spring,4,2,in,favor,of,link,set,error,handler,stomp,sub,protocol,error,handler,configuring,a,code,stomp,sub,protocol,error,handler;deprecated,protected,void,send,error,message,web,socket,session,session,throwable,error,stomp,header,accessor,header,accessor,stomp,header,accessor,create,stomp,command,error,header,accessor,set,message,error,get,message,byte,bytes,this,stomp,encoder,encode,header,accessor,get,message,headers,try,session,send,message,new,text,message,bytes,catch,throwable,ex,logger,debug,failed,to,send,stomp,error,to,client,ex
StompSubProtocolHandler -> @Deprecated 	protected void sendErrorMessage(WebSocketSession session, Throwable error);1440168414;Invoked when no_{@link #setErrorHandler(StompSubProtocolErrorHandler) errorHandler}_is configured to send an ERROR frame to the client._@deprecated as of Spring 4.2, in favor of_{@link #setErrorHandler(StompSubProtocolErrorHandler) configuring}_a {@code StompSubProtocolErrorHandler};@Deprecated_	protected void sendErrorMessage(WebSocketSession session, Throwable error) {_		StompHeaderAccessor headerAccessor = StompHeaderAccessor.create(StompCommand.ERROR)__		headerAccessor.setMessage(error.getMessage())___		byte[] bytes = this.stompEncoder.encode(headerAccessor.getMessageHeaders(), EMPTY_PAYLOAD)__		try {_			session.sendMessage(new TextMessage(bytes))__		}_		catch (Throwable ex) {_			_			logger.debug("Failed to send STOMP ERROR to client", ex)__		}_	};invoked,when,no,link,set,error,handler,stomp,sub,protocol,error,handler,error,handler,is,configured,to,send,an,error,frame,to,the,client,deprecated,as,of,spring,4,2,in,favor,of,link,set,error,handler,stomp,sub,protocol,error,handler,configuring,a,code,stomp,sub,protocol,error,handler;deprecated,protected,void,send,error,message,web,socket,session,session,throwable,error,stomp,header,accessor,header,accessor,stomp,header,accessor,create,stomp,command,error,header,accessor,set,message,error,get,message,byte,bytes,this,stomp,encoder,encode,header,accessor,get,message,headers,try,session,send,message,new,text,message,bytes,catch,throwable,ex,logger,debug,failed,to,send,stomp,error,to,client,ex
StompSubProtocolHandler -> @Deprecated 	protected void sendErrorMessage(WebSocketSession session, Throwable error);1440249342;Invoked when no_{@link #setErrorHandler(StompSubProtocolErrorHandler) errorHandler}_is configured to send an ERROR frame to the client._@deprecated as of Spring 4.2, in favor of_{@link #setErrorHandler(StompSubProtocolErrorHandler) configuring}_a {@code StompSubProtocolErrorHandler};@Deprecated_	protected void sendErrorMessage(WebSocketSession session, Throwable error) {_		StompHeaderAccessor headerAccessor = StompHeaderAccessor.create(StompCommand.ERROR)__		headerAccessor.setMessage(error.getMessage())___		byte[] bytes = this.stompEncoder.encode(headerAccessor.getMessageHeaders(), EMPTY_PAYLOAD)__		try {_			session.sendMessage(new TextMessage(bytes))__		}_		catch (Throwable ex) {_			_			logger.debug("Failed to send STOMP ERROR to client", ex)__		}_	};invoked,when,no,link,set,error,handler,stomp,sub,protocol,error,handler,error,handler,is,configured,to,send,an,error,frame,to,the,client,deprecated,as,of,spring,4,2,in,favor,of,link,set,error,handler,stomp,sub,protocol,error,handler,configuring,a,code,stomp,sub,protocol,error,handler;deprecated,protected,void,send,error,message,web,socket,session,session,throwable,error,stomp,header,accessor,header,accessor,stomp,header,accessor,create,stomp,command,error,header,accessor,set,message,error,get,message,byte,bytes,this,stomp,encoder,encode,header,accessor,get,message,headers,try,session,send,message,new,text,message,bytes,catch,throwable,ex,logger,debug,failed,to,send,stomp,error,to,client,ex
StompSubProtocolHandler -> public void setHeaderInitializer(@Nullable MessageHeaderInitializer headerInitializer);1500448076;Configure a {@link MessageHeaderInitializer} to apply to the headers of all_messages created from decoded STOMP frames and other messages sent to the_client inbound channel._<p>By default this property is not set.;public void setHeaderInitializer(@Nullable MessageHeaderInitializer headerInitializer) {_		this.headerInitializer = headerInitializer__		this.stompDecoder.setHeaderInitializer(headerInitializer)__	};configure,a,link,message,header,initializer,to,apply,to,the,headers,of,all,messages,created,from,decoded,stomp,frames,and,other,messages,sent,to,the,client,inbound,channel,p,by,default,this,property,is,not,set;public,void,set,header,initializer,nullable,message,header,initializer,header,initializer,this,header,initializer,header,initializer,this,stomp,decoder,set,header,initializer,header,initializer
StompSubProtocolHandler -> public void setHeaderInitializer(@Nullable MessageHeaderInitializer headerInitializer);1501147952;Configure a {@link MessageHeaderInitializer} to apply to the headers of all_messages created from decoded STOMP frames and other messages sent to the_client inbound channel._<p>By default this property is not set.;public void setHeaderInitializer(@Nullable MessageHeaderInitializer headerInitializer) {_		this.headerInitializer = headerInitializer__		this.stompDecoder.setHeaderInitializer(headerInitializer)__	};configure,a,link,message,header,initializer,to,apply,to,the,headers,of,all,messages,created,from,decoded,stomp,frames,and,other,messages,sent,to,the,client,inbound,channel,p,by,default,this,property,is,not,set;public,void,set,header,initializer,nullable,message,header,initializer,header,initializer,this,header,initializer,header,initializer,this,stomp,decoder,set,header,initializer,header,initializer
StompSubProtocolHandler -> public void setHeaderInitializer(@Nullable MessageHeaderInitializer headerInitializer);1502974979;Configure a {@link MessageHeaderInitializer} to apply to the headers of all_messages created from decoded STOMP frames and other messages sent to the_client inbound channel._<p>By default this property is not set.;public void setHeaderInitializer(@Nullable MessageHeaderInitializer headerInitializer) {_		this.headerInitializer = headerInitializer__		this.stompDecoder.setHeaderInitializer(headerInitializer)__	};configure,a,link,message,header,initializer,to,apply,to,the,headers,of,all,messages,created,from,decoded,stomp,frames,and,other,messages,sent,to,the,client,inbound,channel,p,by,default,this,property,is,not,set;public,void,set,header,initializer,nullable,message,header,initializer,header,initializer,this,header,initializer,header,initializer,this,stomp,decoder,set,header,initializer,header,initializer
StompSubProtocolHandler -> public void setHeaderInitializer(@Nullable MessageHeaderInitializer headerInitializer);1509997270;Configure a {@link MessageHeaderInitializer} to apply to the headers of all_messages created from decoded STOMP frames and other messages sent to the_client inbound channel._<p>By default this property is not set.;public void setHeaderInitializer(@Nullable MessageHeaderInitializer headerInitializer) {_		this.headerInitializer = headerInitializer__		this.stompDecoder.setHeaderInitializer(headerInitializer)__	};configure,a,link,message,header,initializer,to,apply,to,the,headers,of,all,messages,created,from,decoded,stomp,frames,and,other,messages,sent,to,the,client,inbound,channel,p,by,default,this,property,is,not,set;public,void,set,header,initializer,nullable,message,header,initializer,header,initializer,this,header,initializer,header,initializer,this,stomp,decoder,set,header,initializer,header,initializer
StompSubProtocolHandler -> public void setHeaderInitializer(@Nullable MessageHeaderInitializer headerInitializer);1530174524;Configure a {@link MessageHeaderInitializer} to apply to the headers of all_messages created from decoded STOMP frames and other messages sent to the_client inbound channel._<p>By default this property is not set.;public void setHeaderInitializer(@Nullable MessageHeaderInitializer headerInitializer) {_		this.headerInitializer = headerInitializer__		this.stompDecoder.setHeaderInitializer(headerInitializer)__	};configure,a,link,message,header,initializer,to,apply,to,the,headers,of,all,messages,created,from,decoded,stomp,frames,and,other,messages,sent,to,the,client,inbound,channel,p,by,default,this,property,is,not,set;public,void,set,header,initializer,nullable,message,header,initializer,header,initializer,this,header,initializer,header,initializer,this,stomp,decoder,set,header,initializer,header,initializer
StompSubProtocolHandler -> public void setHeaderInitializer(@Nullable MessageHeaderInitializer headerInitializer);1536886762;Configure a {@link MessageHeaderInitializer} to apply to the headers of all_messages created from decoded STOMP frames and other messages sent to the_client inbound channel._<p>By default this property is not set.;public void setHeaderInitializer(@Nullable MessageHeaderInitializer headerInitializer) {_		this.headerInitializer = headerInitializer__		this.stompDecoder.setHeaderInitializer(headerInitializer)__	};configure,a,link,message,header,initializer,to,apply,to,the,headers,of,all,messages,created,from,decoded,stomp,frames,and,other,messages,sent,to,the,client,inbound,channel,p,by,default,this,property,is,not,set;public,void,set,header,initializer,nullable,message,header,initializer,header,initializer,this,header,initializer,header,initializer,this,stomp,decoder,set,header,initializer,header,initializer
StompSubProtocolHandler -> public void setHeaderInitializer(@Nullable MessageHeaderInitializer headerInitializer);1542899558;Configure a {@link MessageHeaderInitializer} to apply to the headers of all_messages created from decoded STOMP frames and other messages sent to the_client inbound channel._<p>By default this property is not set.;public void setHeaderInitializer(@Nullable MessageHeaderInitializer headerInitializer) {_		this.headerInitializer = headerInitializer__		this.stompDecoder.setHeaderInitializer(headerInitializer)__	};configure,a,link,message,header,initializer,to,apply,to,the,headers,of,all,messages,created,from,decoded,stomp,frames,and,other,messages,sent,to,the,client,inbound,channel,p,by,default,this,property,is,not,set;public,void,set,header,initializer,nullable,message,header,initializer,header,initializer,this,header,initializer,header,initializer,this,stomp,decoder,set,header,initializer,header,initializer
StompSubProtocolHandler -> @Deprecated 	public void setUserSessionRegistry(org.springframework.messaging.simp.user.UserSessionRegistry registry);1432316649;Provide a registry with which to register active user session ids._@see org.springframework.messaging.simp.user.UserDestinationMessageHandler_@deprecated as of 4.2 in favor of {@link DefaultSimpUserRegistry} which relies_on the ApplicationContext events published by this class and is created via_{@link org.springframework.web.socket.config.annotation.WebSocketMessageBrokerConfigurationSupport#createLocalUserRegistry_WebSocketMessageBrokerConfigurationSupport.createLocalUserRegistry};@Deprecated_	public void setUserSessionRegistry(org.springframework.messaging.simp.user.UserSessionRegistry registry) {_		this.userSessionRegistry = registry__	};provide,a,registry,with,which,to,register,active,user,session,ids,see,org,springframework,messaging,simp,user,user,destination,message,handler,deprecated,as,of,4,2,in,favor,of,link,default,simp,user,registry,which,relies,on,the,application,context,events,published,by,this,class,and,is,created,via,link,org,springframework,web,socket,config,annotation,web,socket,message,broker,configuration,support,create,local,user,registry,web,socket,message,broker,configuration,support,create,local,user,registry;deprecated,public,void,set,user,session,registry,org,springframework,messaging,simp,user,user,session,registry,registry,this,user,session,registry,registry
StompSubProtocolHandler -> @Deprecated 	public void setUserSessionRegistry(org.springframework.messaging.simp.user.UserSessionRegistry registry);1432331447;Provide a registry with which to register active user session ids._@see org.springframework.messaging.simp.user.UserDestinationMessageHandler_@deprecated as of 4.2 in favor of {@link DefaultSimpUserRegistry} which relies_on the ApplicationContext events published by this class and is created via_{@link org.springframework.web.socket.config.annotation.WebSocketMessageBrokerConfigurationSupport#createLocalUserRegistry_WebSocketMessageBrokerConfigurationSupport.createLocalUserRegistry};@Deprecated_	public void setUserSessionRegistry(org.springframework.messaging.simp.user.UserSessionRegistry registry) {_		this.userSessionRegistry = registry__	};provide,a,registry,with,which,to,register,active,user,session,ids,see,org,springframework,messaging,simp,user,user,destination,message,handler,deprecated,as,of,4,2,in,favor,of,link,default,simp,user,registry,which,relies,on,the,application,context,events,published,by,this,class,and,is,created,via,link,org,springframework,web,socket,config,annotation,web,socket,message,broker,configuration,support,create,local,user,registry,web,socket,message,broker,configuration,support,create,local,user,registry;deprecated,public,void,set,user,session,registry,org,springframework,messaging,simp,user,user,session,registry,registry,this,user,session,registry,registry
StompSubProtocolHandler -> @Deprecated 	public void setUserSessionRegistry(org.springframework.messaging.simp.user.UserSessionRegistry registry);1440168414;Provide a registry with which to register active user session ids._@see org.springframework.messaging.simp.user.UserDestinationMessageHandler_@deprecated as of 4.2 in favor of {@link DefaultSimpUserRegistry} which relies_on the ApplicationContext events published by this class and is created via_{@link org.springframework.web.socket.config.annotation.WebSocketMessageBrokerConfigurationSupport#createLocalUserRegistry_WebSocketMessageBrokerConfigurationSupport.createLocalUserRegistry};@Deprecated_	public void setUserSessionRegistry(org.springframework.messaging.simp.user.UserSessionRegistry registry) {_		this.userSessionRegistry = registry__	};provide,a,registry,with,which,to,register,active,user,session,ids,see,org,springframework,messaging,simp,user,user,destination,message,handler,deprecated,as,of,4,2,in,favor,of,link,default,simp,user,registry,which,relies,on,the,application,context,events,published,by,this,class,and,is,created,via,link,org,springframework,web,socket,config,annotation,web,socket,message,broker,configuration,support,create,local,user,registry,web,socket,message,broker,configuration,support,create,local,user,registry;deprecated,public,void,set,user,session,registry,org,springframework,messaging,simp,user,user,session,registry,registry,this,user,session,registry,registry
StompSubProtocolHandler -> @Deprecated 	public void setUserSessionRegistry(org.springframework.messaging.simp.user.UserSessionRegistry registry);1440249342;Provide a registry with which to register active user session ids._@see org.springframework.messaging.simp.user.UserDestinationMessageHandler_@deprecated as of 4.2 in favor of {@link DefaultSimpUserRegistry} which relies_on the ApplicationContext events published by this class and is created via_{@link org.springframework.web.socket.config.annotation.WebSocketMessageBrokerConfigurationSupport#createLocalUserRegistry_WebSocketMessageBrokerConfigurationSupport.createLocalUserRegistry};@Deprecated_	public void setUserSessionRegistry(org.springframework.messaging.simp.user.UserSessionRegistry registry) {_		this.userSessionRegistry = registry__	};provide,a,registry,with,which,to,register,active,user,session,ids,see,org,springframework,messaging,simp,user,user,destination,message,handler,deprecated,as,of,4,2,in,favor,of,link,default,simp,user,registry,which,relies,on,the,application,context,events,published,by,this,class,and,is,created,via,link,org,springframework,web,socket,config,annotation,web,socket,message,broker,configuration,support,create,local,user,registry,web,socket,message,broker,configuration,support,create,local,user,registry;deprecated,public,void,set,user,session,registry,org,springframework,messaging,simp,user,user,session,registry,registry,this,user,session,registry,registry
StompSubProtocolHandler -> public void setHeaderInitializer(MessageHeaderInitializer headerInitializer);1397523793;Configure a {@link MessageHeaderInitializer} to apply to the headers of all_messages created from decoded STOMP frames and other messages sent to the_client inbound channel.__<p>By default this property is not set.;public void setHeaderInitializer(MessageHeaderInitializer headerInitializer) {_		this.headerInitializer = headerInitializer__		this.stompDecoder.setHeaderInitializer(headerInitializer)__	};configure,a,link,message,header,initializer,to,apply,to,the,headers,of,all,messages,created,from,decoded,stomp,frames,and,other,messages,sent,to,the,client,inbound,channel,p,by,default,this,property,is,not,set;public,void,set,header,initializer,message,header,initializer,header,initializer,this,header,initializer,header,initializer,this,stomp,decoder,set,header,initializer,header,initializer
StompSubProtocolHandler -> public void setHeaderInitializer(MessageHeaderInitializer headerInitializer);1398443164;Configure a {@link MessageHeaderInitializer} to apply to the headers of all_messages created from decoded STOMP frames and other messages sent to the_client inbound channel.__<p>By default this property is not set.;public void setHeaderInitializer(MessageHeaderInitializer headerInitializer) {_		this.headerInitializer = headerInitializer__		this.stompDecoder.setHeaderInitializer(headerInitializer)__	};configure,a,link,message,header,initializer,to,apply,to,the,headers,of,all,messages,created,from,decoded,stomp,frames,and,other,messages,sent,to,the,client,inbound,channel,p,by,default,this,property,is,not,set;public,void,set,header,initializer,message,header,initializer,header,initializer,this,header,initializer,header,initializer,this,stomp,decoder,set,header,initializer,header,initializer
StompSubProtocolHandler -> public void setHeaderInitializer(MessageHeaderInitializer headerInitializer);1399601217;Configure a {@link MessageHeaderInitializer} to apply to the headers of all_messages created from decoded STOMP frames and other messages sent to the_client inbound channel.__<p>By default this property is not set.;public void setHeaderInitializer(MessageHeaderInitializer headerInitializer) {_		this.headerInitializer = headerInitializer__		this.stompDecoder.setHeaderInitializer(headerInitializer)__	};configure,a,link,message,header,initializer,to,apply,to,the,headers,of,all,messages,created,from,decoded,stomp,frames,and,other,messages,sent,to,the,client,inbound,channel,p,by,default,this,property,is,not,set;public,void,set,header,initializer,message,header,initializer,header,initializer,this,header,initializer,header,initializer,this,stomp,decoder,set,header,initializer,header,initializer
StompSubProtocolHandler -> public void setHeaderInitializer(MessageHeaderInitializer headerInitializer);1399825877;Configure a {@link MessageHeaderInitializer} to apply to the headers of all_messages created from decoded STOMP frames and other messages sent to the_client inbound channel.__<p>By default this property is not set.;public void setHeaderInitializer(MessageHeaderInitializer headerInitializer) {_		this.headerInitializer = headerInitializer__		this.stompDecoder.setHeaderInitializer(headerInitializer)__	};configure,a,link,message,header,initializer,to,apply,to,the,headers,of,all,messages,created,from,decoded,stomp,frames,and,other,messages,sent,to,the,client,inbound,channel,p,by,default,this,property,is,not,set;public,void,set,header,initializer,message,header,initializer,header,initializer,this,header,initializer,header,initializer,this,stomp,decoder,set,header,initializer,header,initializer
StompSubProtocolHandler -> public void setHeaderInitializer(MessageHeaderInitializer headerInitializer);1403719829;Configure a {@link MessageHeaderInitializer} to apply to the headers of all_messages created from decoded STOMP frames and other messages sent to the_client inbound channel.__<p>By default this property is not set.;public void setHeaderInitializer(MessageHeaderInitializer headerInitializer) {_		this.headerInitializer = headerInitializer__		this.stompDecoder.setHeaderInitializer(headerInitializer)__	};configure,a,link,message,header,initializer,to,apply,to,the,headers,of,all,messages,created,from,decoded,stomp,frames,and,other,messages,sent,to,the,client,inbound,channel,p,by,default,this,property,is,not,set;public,void,set,header,initializer,message,header,initializer,header,initializer,this,header,initializer,header,initializer,this,stomp,decoder,set,header,initializer,header,initializer
StompSubProtocolHandler -> public void setHeaderInitializer(MessageHeaderInitializer headerInitializer);1403856366;Configure a {@link MessageHeaderInitializer} to apply to the headers of all_messages created from decoded STOMP frames and other messages sent to the_client inbound channel.__<p>By default this property is not set.;public void setHeaderInitializer(MessageHeaderInitializer headerInitializer) {_		this.headerInitializer = headerInitializer__		this.stompDecoder.setHeaderInitializer(headerInitializer)__	};configure,a,link,message,header,initializer,to,apply,to,the,headers,of,all,messages,created,from,decoded,stomp,frames,and,other,messages,sent,to,the,client,inbound,channel,p,by,default,this,property,is,not,set;public,void,set,header,initializer,message,header,initializer,header,initializer,this,header,initializer,header,initializer,this,stomp,decoder,set,header,initializer,header,initializer
StompSubProtocolHandler -> public void setHeaderInitializer(MessageHeaderInitializer headerInitializer);1403968062;Configure a {@link MessageHeaderInitializer} to apply to the headers of all_messages created from decoded STOMP frames and other messages sent to the_client inbound channel.__<p>By default this property is not set.;public void setHeaderInitializer(MessageHeaderInitializer headerInitializer) {_		this.headerInitializer = headerInitializer__		this.stompDecoder.setHeaderInitializer(headerInitializer)__	};configure,a,link,message,header,initializer,to,apply,to,the,headers,of,all,messages,created,from,decoded,stomp,frames,and,other,messages,sent,to,the,client,inbound,channel,p,by,default,this,property,is,not,set;public,void,set,header,initializer,message,header,initializer,header,initializer,this,header,initializer,header,initializer,this,stomp,decoder,set,header,initializer,header,initializer
StompSubProtocolHandler -> public void setHeaderInitializer(MessageHeaderInitializer headerInitializer);1404880787;Configure a {@link MessageHeaderInitializer} to apply to the headers of all_messages created from decoded STOMP frames and other messages sent to the_client inbound channel.__<p>By default this property is not set.;public void setHeaderInitializer(MessageHeaderInitializer headerInitializer) {_		this.headerInitializer = headerInitializer__		this.stompDecoder.setHeaderInitializer(headerInitializer)__	};configure,a,link,message,header,initializer,to,apply,to,the,headers,of,all,messages,created,from,decoded,stomp,frames,and,other,messages,sent,to,the,client,inbound,channel,p,by,default,this,property,is,not,set;public,void,set,header,initializer,message,header,initializer,header,initializer,this,header,initializer,header,initializer,this,stomp,decoder,set,header,initializer,header,initializer
StompSubProtocolHandler -> public void setHeaderInitializer(MessageHeaderInitializer headerInitializer);1404880799;Configure a {@link MessageHeaderInitializer} to apply to the headers of all_messages created from decoded STOMP frames and other messages sent to the_client inbound channel.__<p>By default this property is not set.;public void setHeaderInitializer(MessageHeaderInitializer headerInitializer) {_		this.headerInitializer = headerInitializer__		this.stompDecoder.setHeaderInitializer(headerInitializer)__	};configure,a,link,message,header,initializer,to,apply,to,the,headers,of,all,messages,created,from,decoded,stomp,frames,and,other,messages,sent,to,the,client,inbound,channel,p,by,default,this,property,is,not,set;public,void,set,header,initializer,message,header,initializer,header,initializer,this,header,initializer,header,initializer,this,stomp,decoder,set,header,initializer,header,initializer
StompSubProtocolHandler -> public void setHeaderInitializer(MessageHeaderInitializer headerInitializer);1411067168;Configure a {@link MessageHeaderInitializer} to apply to the headers of all_messages created from decoded STOMP frames and other messages sent to the_client inbound channel.__<p>By default this property is not set.;public void setHeaderInitializer(MessageHeaderInitializer headerInitializer) {_		this.headerInitializer = headerInitializer__		this.stompDecoder.setHeaderInitializer(headerInitializer)__	};configure,a,link,message,header,initializer,to,apply,to,the,headers,of,all,messages,created,from,decoded,stomp,frames,and,other,messages,sent,to,the,client,inbound,channel,p,by,default,this,property,is,not,set;public,void,set,header,initializer,message,header,initializer,header,initializer,this,header,initializer,header,initializer,this,stomp,decoder,set,header,initializer,header,initializer
StompSubProtocolHandler -> public void setHeaderInitializer(MessageHeaderInitializer headerInitializer);1411068071;Configure a {@link MessageHeaderInitializer} to apply to the headers of all_messages created from decoded STOMP frames and other messages sent to the_client inbound channel.__<p>By default this property is not set.;public void setHeaderInitializer(MessageHeaderInitializer headerInitializer) {_		this.headerInitializer = headerInitializer__		this.stompDecoder.setHeaderInitializer(headerInitializer)__	};configure,a,link,message,header,initializer,to,apply,to,the,headers,of,all,messages,created,from,decoded,stomp,frames,and,other,messages,sent,to,the,client,inbound,channel,p,by,default,this,property,is,not,set;public,void,set,header,initializer,message,header,initializer,header,initializer,this,header,initializer,header,initializer,this,stomp,decoder,set,header,initializer,header,initializer
StompSubProtocolHandler -> public void setHeaderInitializer(MessageHeaderInitializer headerInitializer);1411148800;Configure a {@link MessageHeaderInitializer} to apply to the headers of all_messages created from decoded STOMP frames and other messages sent to the_client inbound channel.__<p>By default this property is not set.;public void setHeaderInitializer(MessageHeaderInitializer headerInitializer) {_		this.headerInitializer = headerInitializer__		this.stompDecoder.setHeaderInitializer(headerInitializer)__	};configure,a,link,message,header,initializer,to,apply,to,the,headers,of,all,messages,created,from,decoded,stomp,frames,and,other,messages,sent,to,the,client,inbound,channel,p,by,default,this,property,is,not,set;public,void,set,header,initializer,message,header,initializer,header,initializer,this,header,initializer,header,initializer,this,stomp,decoder,set,header,initializer,header,initializer
StompSubProtocolHandler -> public void setHeaderInitializer(MessageHeaderInitializer headerInitializer);1411567635;Configure a {@link MessageHeaderInitializer} to apply to the headers of all_messages created from decoded STOMP frames and other messages sent to the_client inbound channel.__<p>By default this property is not set.;public void setHeaderInitializer(MessageHeaderInitializer headerInitializer) {_		this.headerInitializer = headerInitializer__		this.stompDecoder.setHeaderInitializer(headerInitializer)__	};configure,a,link,message,header,initializer,to,apply,to,the,headers,of,all,messages,created,from,decoded,stomp,frames,and,other,messages,sent,to,the,client,inbound,channel,p,by,default,this,property,is,not,set;public,void,set,header,initializer,message,header,initializer,header,initializer,this,header,initializer,header,initializer,this,stomp,decoder,set,header,initializer,header,initializer
StompSubProtocolHandler -> public void setHeaderInitializer(MessageHeaderInitializer headerInitializer);1412965899;Configure a {@link MessageHeaderInitializer} to apply to the headers of all_messages created from decoded STOMP frames and other messages sent to the_client inbound channel.__<p>By default this property is not set.;public void setHeaderInitializer(MessageHeaderInitializer headerInitializer) {_		this.headerInitializer = headerInitializer__		this.stompDecoder.setHeaderInitializer(headerInitializer)__	};configure,a,link,message,header,initializer,to,apply,to,the,headers,of,all,messages,created,from,decoded,stomp,frames,and,other,messages,sent,to,the,client,inbound,channel,p,by,default,this,property,is,not,set;public,void,set,header,initializer,message,header,initializer,header,initializer,this,header,initializer,header,initializer,this,stomp,decoder,set,header,initializer,header,initializer
StompSubProtocolHandler -> public void setHeaderInitializer(MessageHeaderInitializer headerInitializer);1413848647;Configure a {@link MessageHeaderInitializer} to apply to the headers of all_messages created from decoded STOMP frames and other messages sent to the_client inbound channel.__<p>By default this property is not set.;public void setHeaderInitializer(MessageHeaderInitializer headerInitializer) {_		this.headerInitializer = headerInitializer__		this.stompDecoder.setHeaderInitializer(headerInitializer)__	};configure,a,link,message,header,initializer,to,apply,to,the,headers,of,all,messages,created,from,decoded,stomp,frames,and,other,messages,sent,to,the,client,inbound,channel,p,by,default,this,property,is,not,set;public,void,set,header,initializer,message,header,initializer,header,initializer,this,header,initializer,header,initializer,this,stomp,decoder,set,header,initializer,header,initializer
StompSubProtocolHandler -> public void setHeaderInitializer(MessageHeaderInitializer headerInitializer);1414092351;Configure a {@link MessageHeaderInitializer} to apply to the headers of all_messages created from decoded STOMP frames and other messages sent to the_client inbound channel.__<p>By default this property is not set.;public void setHeaderInitializer(MessageHeaderInitializer headerInitializer) {_		this.headerInitializer = headerInitializer__		this.stompDecoder.setHeaderInitializer(headerInitializer)__	};configure,a,link,message,header,initializer,to,apply,to,the,headers,of,all,messages,created,from,decoded,stomp,frames,and,other,messages,sent,to,the,client,inbound,channel,p,by,default,this,property,is,not,set;public,void,set,header,initializer,message,header,initializer,header,initializer,this,header,initializer,header,initializer,this,stomp,decoder,set,header,initializer,header,initializer
StompSubProtocolHandler -> public void setHeaderInitializer(MessageHeaderInitializer headerInitializer);1414158498;Configure a {@link MessageHeaderInitializer} to apply to the headers of all_messages created from decoded STOMP frames and other messages sent to the_client inbound channel.__<p>By default this property is not set.;public void setHeaderInitializer(MessageHeaderInitializer headerInitializer) {_		this.headerInitializer = headerInitializer__		this.stompDecoder.setHeaderInitializer(headerInitializer)__	};configure,a,link,message,header,initializer,to,apply,to,the,headers,of,all,messages,created,from,decoded,stomp,frames,and,other,messages,sent,to,the,client,inbound,channel,p,by,default,this,property,is,not,set;public,void,set,header,initializer,message,header,initializer,header,initializer,this,header,initializer,header,initializer,this,stomp,decoder,set,header,initializer,header,initializer
StompSubProtocolHandler -> public void setHeaderInitializer(MessageHeaderInitializer headerInitializer);1419362683;Configure a {@link MessageHeaderInitializer} to apply to the headers of all_messages created from decoded STOMP frames and other messages sent to the_client inbound channel.__<p>By default this property is not set.;public void setHeaderInitializer(MessageHeaderInitializer headerInitializer) {_		this.headerInitializer = headerInitializer__		this.stompDecoder.setHeaderInitializer(headerInitializer)__	};configure,a,link,message,header,initializer,to,apply,to,the,headers,of,all,messages,created,from,decoded,stomp,frames,and,other,messages,sent,to,the,client,inbound,channel,p,by,default,this,property,is,not,set;public,void,set,header,initializer,message,header,initializer,header,initializer,this,header,initializer,header,initializer,this,stomp,decoder,set,header,initializer,header,initializer
StompSubProtocolHandler -> public void setHeaderInitializer(MessageHeaderInitializer headerInitializer);1419883989;Configure a {@link MessageHeaderInitializer} to apply to the headers of all_messages created from decoded STOMP frames and other messages sent to the_client inbound channel.__<p>By default this property is not set.;public void setHeaderInitializer(MessageHeaderInitializer headerInitializer) {_		this.headerInitializer = headerInitializer__		this.stompDecoder.setHeaderInitializer(headerInitializer)__	};configure,a,link,message,header,initializer,to,apply,to,the,headers,of,all,messages,created,from,decoded,stomp,frames,and,other,messages,sent,to,the,client,inbound,channel,p,by,default,this,property,is,not,set;public,void,set,header,initializer,message,header,initializer,header,initializer,this,header,initializer,header,initializer,this,stomp,decoder,set,header,initializer,header,initializer
StompSubProtocolHandler -> public void setHeaderInitializer(MessageHeaderInitializer headerInitializer);1424278379;Configure a {@link MessageHeaderInitializer} to apply to the headers of all_messages created from decoded STOMP frames and other messages sent to the_client inbound channel.__<p>By default this property is not set.;public void setHeaderInitializer(MessageHeaderInitializer headerInitializer) {_		this.headerInitializer = headerInitializer__		this.stompDecoder.setHeaderInitializer(headerInitializer)__	};configure,a,link,message,header,initializer,to,apply,to,the,headers,of,all,messages,created,from,decoded,stomp,frames,and,other,messages,sent,to,the,client,inbound,channel,p,by,default,this,property,is,not,set;public,void,set,header,initializer,message,header,initializer,header,initializer,this,header,initializer,header,initializer,this,stomp,decoder,set,header,initializer,header,initializer
StompSubProtocolHandler -> public void setHeaderInitializer(MessageHeaderInitializer headerInitializer);1428353843;Configure a {@link MessageHeaderInitializer} to apply to the headers of all_messages created from decoded STOMP frames and other messages sent to the_client inbound channel.__<p>By default this property is not set.;public void setHeaderInitializer(MessageHeaderInitializer headerInitializer) {_		this.headerInitializer = headerInitializer__		this.stompDecoder.setHeaderInitializer(headerInitializer)__	};configure,a,link,message,header,initializer,to,apply,to,the,headers,of,all,messages,created,from,decoded,stomp,frames,and,other,messages,sent,to,the,client,inbound,channel,p,by,default,this,property,is,not,set;public,void,set,header,initializer,message,header,initializer,header,initializer,this,header,initializer,header,initializer,this,stomp,decoder,set,header,initializer,header,initializer
StompSubProtocolHandler -> public void setHeaderInitializer(MessageHeaderInitializer headerInitializer);1430834982;Configure a {@link MessageHeaderInitializer} to apply to the headers of all_messages created from decoded STOMP frames and other messages sent to the_client inbound channel.__<p>By default this property is not set.;public void setHeaderInitializer(MessageHeaderInitializer headerInitializer) {_		this.headerInitializer = headerInitializer__		this.stompDecoder.setHeaderInitializer(headerInitializer)__	};configure,a,link,message,header,initializer,to,apply,to,the,headers,of,all,messages,created,from,decoded,stomp,frames,and,other,messages,sent,to,the,client,inbound,channel,p,by,default,this,property,is,not,set;public,void,set,header,initializer,message,header,initializer,header,initializer,this,header,initializer,header,initializer,this,stomp,decoder,set,header,initializer,header,initializer
StompSubProtocolHandler -> public void setHeaderInitializer(MessageHeaderInitializer headerInitializer);1431458952;Configure a {@link MessageHeaderInitializer} to apply to the headers of all_messages created from decoded STOMP frames and other messages sent to the_client inbound channel.__<p>By default this property is not set.;public void setHeaderInitializer(MessageHeaderInitializer headerInitializer) {_		this.headerInitializer = headerInitializer__		this.stompDecoder.setHeaderInitializer(headerInitializer)__	};configure,a,link,message,header,initializer,to,apply,to,the,headers,of,all,messages,created,from,decoded,stomp,frames,and,other,messages,sent,to,the,client,inbound,channel,p,by,default,this,property,is,not,set;public,void,set,header,initializer,message,header,initializer,header,initializer,this,header,initializer,header,initializer,this,stomp,decoder,set,header,initializer,header,initializer
StompSubProtocolHandler -> public void setHeaderInitializer(MessageHeaderInitializer headerInitializer);1431728285;Configure a {@link MessageHeaderInitializer} to apply to the headers of all_messages created from decoded STOMP frames and other messages sent to the_client inbound channel.__<p>By default this property is not set.;public void setHeaderInitializer(MessageHeaderInitializer headerInitializer) {_		this.headerInitializer = headerInitializer__		this.stompDecoder.setHeaderInitializer(headerInitializer)__	};configure,a,link,message,header,initializer,to,apply,to,the,headers,of,all,messages,created,from,decoded,stomp,frames,and,other,messages,sent,to,the,client,inbound,channel,p,by,default,this,property,is,not,set;public,void,set,header,initializer,message,header,initializer,header,initializer,this,header,initializer,header,initializer,this,stomp,decoder,set,header,initializer,header,initializer
StompSubProtocolHandler -> public void setHeaderInitializer(MessageHeaderInitializer headerInitializer);1432316649;Configure a {@link MessageHeaderInitializer} to apply to the headers of all_messages created from decoded STOMP frames and other messages sent to the_client inbound channel.__<p>By default this property is not set.;public void setHeaderInitializer(MessageHeaderInitializer headerInitializer) {_		this.headerInitializer = headerInitializer__		this.stompDecoder.setHeaderInitializer(headerInitializer)__	};configure,a,link,message,header,initializer,to,apply,to,the,headers,of,all,messages,created,from,decoded,stomp,frames,and,other,messages,sent,to,the,client,inbound,channel,p,by,default,this,property,is,not,set;public,void,set,header,initializer,message,header,initializer,header,initializer,this,header,initializer,header,initializer,this,stomp,decoder,set,header,initializer,header,initializer
StompSubProtocolHandler -> public void setHeaderInitializer(MessageHeaderInitializer headerInitializer);1432331447;Configure a {@link MessageHeaderInitializer} to apply to the headers of all_messages created from decoded STOMP frames and other messages sent to the_client inbound channel._<p>By default this property is not set.;public void setHeaderInitializer(MessageHeaderInitializer headerInitializer) {_		this.headerInitializer = headerInitializer__		this.stompDecoder.setHeaderInitializer(headerInitializer)__	};configure,a,link,message,header,initializer,to,apply,to,the,headers,of,all,messages,created,from,decoded,stomp,frames,and,other,messages,sent,to,the,client,inbound,channel,p,by,default,this,property,is,not,set;public,void,set,header,initializer,message,header,initializer,header,initializer,this,header,initializer,header,initializer,this,stomp,decoder,set,header,initializer,header,initializer
StompSubProtocolHandler -> public void setHeaderInitializer(MessageHeaderInitializer headerInitializer);1440168414;Configure a {@link MessageHeaderInitializer} to apply to the headers of all_messages created from decoded STOMP frames and other messages sent to the_client inbound channel._<p>By default this property is not set.;public void setHeaderInitializer(MessageHeaderInitializer headerInitializer) {_		this.headerInitializer = headerInitializer__		this.stompDecoder.setHeaderInitializer(headerInitializer)__	};configure,a,link,message,header,initializer,to,apply,to,the,headers,of,all,messages,created,from,decoded,stomp,frames,and,other,messages,sent,to,the,client,inbound,channel,p,by,default,this,property,is,not,set;public,void,set,header,initializer,message,header,initializer,header,initializer,this,header,initializer,header,initializer,this,stomp,decoder,set,header,initializer,header,initializer
StompSubProtocolHandler -> public void setHeaderInitializer(MessageHeaderInitializer headerInitializer);1440249342;Configure a {@link MessageHeaderInitializer} to apply to the headers of all_messages created from decoded STOMP frames and other messages sent to the_client inbound channel._<p>By default this property is not set.;public void setHeaderInitializer(MessageHeaderInitializer headerInitializer) {_		this.headerInitializer = headerInitializer__		this.stompDecoder.setHeaderInitializer(headerInitializer)__	};configure,a,link,message,header,initializer,to,apply,to,the,headers,of,all,messages,created,from,decoded,stomp,frames,and,other,messages,sent,to,the,client,inbound,channel,p,by,default,this,property,is,not,set;public,void,set,header,initializer,message,header,initializer,header,initializer,this,header,initializer,header,initializer,this,stomp,decoder,set,header,initializer,header,initializer
StompSubProtocolHandler -> public void setHeaderInitializer(MessageHeaderInitializer headerInitializer);1467726769;Configure a {@link MessageHeaderInitializer} to apply to the headers of all_messages created from decoded STOMP frames and other messages sent to the_client inbound channel._<p>By default this property is not set.;public void setHeaderInitializer(MessageHeaderInitializer headerInitializer) {_		this.headerInitializer = headerInitializer__		this.stompDecoder.setHeaderInitializer(headerInitializer)__	};configure,a,link,message,header,initializer,to,apply,to,the,headers,of,all,messages,created,from,decoded,stomp,frames,and,other,messages,sent,to,the,client,inbound,channel,p,by,default,this,property,is,not,set;public,void,set,header,initializer,message,header,initializer,header,initializer,this,header,initializer,header,initializer,this,stomp,decoder,set,header,initializer,header,initializer
StompSubProtocolHandler -> public void setHeaderInitializer(MessageHeaderInitializer headerInitializer);1467730834;Configure a {@link MessageHeaderInitializer} to apply to the headers of all_messages created from decoded STOMP frames and other messages sent to the_client inbound channel._<p>By default this property is not set.;public void setHeaderInitializer(MessageHeaderInitializer headerInitializer) {_		this.headerInitializer = headerInitializer__		this.stompDecoder.setHeaderInitializer(headerInitializer)__	};configure,a,link,message,header,initializer,to,apply,to,the,headers,of,all,messages,created,from,decoded,stomp,frames,and,other,messages,sent,to,the,client,inbound,channel,p,by,default,this,property,is,not,set;public,void,set,header,initializer,message,header,initializer,header,initializer,this,header,initializer,header,initializer,this,stomp,decoder,set,header,initializer,header,initializer
StompSubProtocolHandler -> public void setHeaderInitializer(MessageHeaderInitializer headerInitializer);1472062321;Configure a {@link MessageHeaderInitializer} to apply to the headers of all_messages created from decoded STOMP frames and other messages sent to the_client inbound channel._<p>By default this property is not set.;public void setHeaderInitializer(MessageHeaderInitializer headerInitializer) {_		this.headerInitializer = headerInitializer__		this.stompDecoder.setHeaderInitializer(headerInitializer)__	};configure,a,link,message,header,initializer,to,apply,to,the,headers,of,all,messages,created,from,decoded,stomp,frames,and,other,messages,sent,to,the,client,inbound,channel,p,by,default,this,property,is,not,set;public,void,set,header,initializer,message,header,initializer,header,initializer,this,header,initializer,header,initializer,this,stomp,decoder,set,header,initializer,header,initializer
StompSubProtocolHandler -> public void setHeaderInitializer(MessageHeaderInitializer headerInitializer);1472509879;Configure a {@link MessageHeaderInitializer} to apply to the headers of all_messages created from decoded STOMP frames and other messages sent to the_client inbound channel._<p>By default this property is not set.;public void setHeaderInitializer(MessageHeaderInitializer headerInitializer) {_		this.headerInitializer = headerInitializer__		this.stompDecoder.setHeaderInitializer(headerInitializer)__	};configure,a,link,message,header,initializer,to,apply,to,the,headers,of,all,messages,created,from,decoded,stomp,frames,and,other,messages,sent,to,the,client,inbound,channel,p,by,default,this,property,is,not,set;public,void,set,header,initializer,message,header,initializer,header,initializer,this,header,initializer,header,initializer,this,stomp,decoder,set,header,initializer,header,initializer
StompSubProtocolHandler -> public void setHeaderInitializer(MessageHeaderInitializer headerInitializer);1476284885;Configure a {@link MessageHeaderInitializer} to apply to the headers of all_messages created from decoded STOMP frames and other messages sent to the_client inbound channel._<p>By default this property is not set.;public void setHeaderInitializer(MessageHeaderInitializer headerInitializer) {_		this.headerInitializer = headerInitializer__		this.stompDecoder.setHeaderInitializer(headerInitializer)__	};configure,a,link,message,header,initializer,to,apply,to,the,headers,of,all,messages,created,from,decoded,stomp,frames,and,other,messages,sent,to,the,client,inbound,channel,p,by,default,this,property,is,not,set;public,void,set,header,initializer,message,header,initializer,header,initializer,this,header,initializer,header,initializer,this,stomp,decoder,set,header,initializer,header,initializer
StompSubProtocolHandler -> public void setHeaderInitializer(MessageHeaderInitializer headerInitializer);1481213680;Configure a {@link MessageHeaderInitializer} to apply to the headers of all_messages created from decoded STOMP frames and other messages sent to the_client inbound channel._<p>By default this property is not set.;public void setHeaderInitializer(MessageHeaderInitializer headerInitializer) {_		this.headerInitializer = headerInitializer__		this.stompDecoder.setHeaderInitializer(headerInitializer)__	};configure,a,link,message,header,initializer,to,apply,to,the,headers,of,all,messages,created,from,decoded,stomp,frames,and,other,messages,sent,to,the,client,inbound,channel,p,by,default,this,property,is,not,set;public,void,set,header,initializer,message,header,initializer,header,initializer,this,header,initializer,header,initializer,this,stomp,decoder,set,header,initializer,header,initializer
StompSubProtocolHandler -> public void setHeaderInitializer(MessageHeaderInitializer headerInitializer);1481669991;Configure a {@link MessageHeaderInitializer} to apply to the headers of all_messages created from decoded STOMP frames and other messages sent to the_client inbound channel._<p>By default this property is not set.;public void setHeaderInitializer(MessageHeaderInitializer headerInitializer) {_		this.headerInitializer = headerInitializer__		this.stompDecoder.setHeaderInitializer(headerInitializer)__	};configure,a,link,message,header,initializer,to,apply,to,the,headers,of,all,messages,created,from,decoded,stomp,frames,and,other,messages,sent,to,the,client,inbound,channel,p,by,default,this,property,is,not,set;public,void,set,header,initializer,message,header,initializer,header,initializer,this,header,initializer,header,initializer,this,stomp,decoder,set,header,initializer,header,initializer
StompSubProtocolHandler -> public void setHeaderInitializer(MessageHeaderInitializer headerInitializer);1482265068;Configure a {@link MessageHeaderInitializer} to apply to the headers of all_messages created from decoded STOMP frames and other messages sent to the_client inbound channel._<p>By default this property is not set.;public void setHeaderInitializer(MessageHeaderInitializer headerInitializer) {_		this.headerInitializer = headerInitializer__		this.stompDecoder.setHeaderInitializer(headerInitializer)__	};configure,a,link,message,header,initializer,to,apply,to,the,headers,of,all,messages,created,from,decoded,stomp,frames,and,other,messages,sent,to,the,client,inbound,channel,p,by,default,this,property,is,not,set;public,void,set,header,initializer,message,header,initializer,header,initializer,this,header,initializer,header,initializer,this,stomp,decoder,set,header,initializer,header,initializer
StompSubProtocolHandler -> public void setHeaderInitializer(MessageHeaderInitializer headerInitializer);1495868221;Configure a {@link MessageHeaderInitializer} to apply to the headers of all_messages created from decoded STOMP frames and other messages sent to the_client inbound channel._<p>By default this property is not set.;public void setHeaderInitializer(MessageHeaderInitializer headerInitializer) {_		this.headerInitializer = headerInitializer__		this.stompDecoder.setHeaderInitializer(headerInitializer)__	};configure,a,link,message,header,initializer,to,apply,to,the,headers,of,all,messages,created,from,decoded,stomp,frames,and,other,messages,sent,to,the,client,inbound,channel,p,by,default,this,property,is,not,set;public,void,set,header,initializer,message,header,initializer,header,initializer,this,header,initializer,header,initializer,this,stomp,decoder,set,header,initializer,header,initializer
StompSubProtocolHandler -> public void setHeaderInitializer(MessageHeaderInitializer headerInitializer);1496837955;Configure a {@link MessageHeaderInitializer} to apply to the headers of all_messages created from decoded STOMP frames and other messages sent to the_client inbound channel._<p>By default this property is not set.;public void setHeaderInitializer(MessageHeaderInitializer headerInitializer) {_		this.headerInitializer = headerInitializer__		this.stompDecoder.setHeaderInitializer(headerInitializer)__	};configure,a,link,message,header,initializer,to,apply,to,the,headers,of,all,messages,created,from,decoded,stomp,frames,and,other,messages,sent,to,the,client,inbound,channel,p,by,default,this,property,is,not,set;public,void,set,header,initializer,message,header,initializer,header,initializer,this,header,initializer,header,initializer,this,stomp,decoder,set,header,initializer,header,initializer
StompSubProtocolHandler -> public void setHeaderInitializer(MessageHeaderInitializer headerInitializer);1497251962;Configure a {@link MessageHeaderInitializer} to apply to the headers of all_messages created from decoded STOMP frames and other messages sent to the_client inbound channel._<p>By default this property is not set.;public void setHeaderInitializer(MessageHeaderInitializer headerInitializer) {_		this.headerInitializer = headerInitializer__		this.stompDecoder.setHeaderInitializer(headerInitializer)__	};configure,a,link,message,header,initializer,to,apply,to,the,headers,of,all,messages,created,from,decoded,stomp,frames,and,other,messages,sent,to,the,client,inbound,channel,p,by,default,this,property,is,not,set;public,void,set,header,initializer,message,header,initializer,header,initializer,this,header,initializer,header,initializer,this,stomp,decoder,set,header,initializer,header,initializer
StompSubProtocolHandler -> public void setHeaderInitializer(MessageHeaderInitializer headerInitializer);1498780456;Configure a {@link MessageHeaderInitializer} to apply to the headers of all_messages created from decoded STOMP frames and other messages sent to the_client inbound channel._<p>By default this property is not set.;public void setHeaderInitializer(MessageHeaderInitializer headerInitializer) {_		this.headerInitializer = headerInitializer__		this.stompDecoder.setHeaderInitializer(headerInitializer)__	};configure,a,link,message,header,initializer,to,apply,to,the,headers,of,all,messages,created,from,decoded,stomp,frames,and,other,messages,sent,to,the,client,inbound,channel,p,by,default,this,property,is,not,set;public,void,set,header,initializer,message,header,initializer,header,initializer,this,header,initializer,header,initializer,this,stomp,decoder,set,header,initializer,header,initializer
StompSubProtocolHandler -> public int getMessageSizeLimit();1395703238;Get the configured message buffer size limit in bytes.__@since 4.0.3;public int getMessageSizeLimit() {_		return this.messageSizeLimit__	};get,the,configured,message,buffer,size,limit,in,bytes,since,4,0,3;public,int,get,message,size,limit,return,this,message,size,limit
StompSubProtocolHandler -> public int getMessageSizeLimit();1395707441;Get the configured message buffer size limit in bytes.__@since 4.0.3;public int getMessageSizeLimit() {_		return this.messageSizeLimit__	};get,the,configured,message,buffer,size,limit,in,bytes,since,4,0,3;public,int,get,message,size,limit,return,this,message,size,limit
StompSubProtocolHandler -> public int getMessageSizeLimit();1395721625;Get the configured message buffer size limit in bytes.__@since 4.0.3;public int getMessageSizeLimit() {_		return this.messageSizeLimit__	};get,the,configured,message,buffer,size,limit,in,bytes,since,4,0,3;public,int,get,message,size,limit,return,this,message,size,limit
StompSubProtocolHandler -> public int getMessageSizeLimit();1395752742;Get the configured message buffer size limit in bytes.__@since 4.0.3;public int getMessageSizeLimit() {_		return this.messageSizeLimit__	};get,the,configured,message,buffer,size,limit,in,bytes,since,4,0,3;public,int,get,message,size,limit,return,this,message,size,limit
StompSubProtocolHandler -> public int getMessageSizeLimit();1395755949;Get the configured message buffer size limit in bytes.__@since 4.0.3;public int getMessageSizeLimit() {_		return this.messageSizeLimit__	};get,the,configured,message,buffer,size,limit,in,bytes,since,4,0,3;public,int,get,message,size,limit,return,this,message,size,limit
StompSubProtocolHandler -> public int getMessageSizeLimit();1395847954;Get the configured message buffer size limit in bytes.__@since 4.0.3;public int getMessageSizeLimit() {_		return this.messageSizeLimit__	};get,the,configured,message,buffer,size,limit,in,bytes,since,4,0,3;public,int,get,message,size,limit,return,this,message,size,limit
StompSubProtocolHandler -> public int getMessageSizeLimit();1396578670;Get the configured message buffer size limit in bytes.__@since 4.0.3;public int getMessageSizeLimit() {_		return this.messageSizeLimit__	};get,the,configured,message,buffer,size,limit,in,bytes,since,4,0,3;public,int,get,message,size,limit,return,this,message,size,limit
StompSubProtocolHandler -> public int getMessageSizeLimit();1396636309;Get the configured message buffer size limit in bytes.__@since 4.0.3;public int getMessageSizeLimit() {_		return this.messageSizeLimit__	};get,the,configured,message,buffer,size,limit,in,bytes,since,4,0,3;public,int,get,message,size,limit,return,this,message,size,limit
StompSubProtocolHandler -> public int getMessageSizeLimit();1397429525;Get the configured message buffer size limit in bytes.__@since 4.0.3;public int getMessageSizeLimit() {_		return this.messageSizeLimit__	};get,the,configured,message,buffer,size,limit,in,bytes,since,4,0,3;public,int,get,message,size,limit,return,this,message,size,limit
StompSubProtocolHandler -> public int getMessageSizeLimit();1397439322;Get the configured message buffer size limit in bytes.__@since 4.0.3;public int getMessageSizeLimit() {_		return this.messageSizeLimit__	};get,the,configured,message,buffer,size,limit,in,bytes,since,4,0,3;public,int,get,message,size,limit,return,this,message,size,limit
StompSubProtocolHandler -> public int getMessageSizeLimit();1397523793;Get the configured message buffer size limit in bytes.__@since 4.0.3;public int getMessageSizeLimit() {_		return this.messageSizeLimit__	};get,the,configured,message,buffer,size,limit,in,bytes,since,4,0,3;public,int,get,message,size,limit,return,this,message,size,limit
StompSubProtocolHandler -> public int getMessageSizeLimit();1398443164;Get the configured message buffer size limit in bytes.__@since 4.0.3;public int getMessageSizeLimit() {_		return this.messageSizeLimit__	};get,the,configured,message,buffer,size,limit,in,bytes,since,4,0,3;public,int,get,message,size,limit,return,this,message,size,limit
StompSubProtocolHandler -> public int getMessageSizeLimit();1399601217;Get the configured message buffer size limit in bytes.__@since 4.0.3;public int getMessageSizeLimit() {_		return this.messageSizeLimit__	};get,the,configured,message,buffer,size,limit,in,bytes,since,4,0,3;public,int,get,message,size,limit,return,this,message,size,limit
StompSubProtocolHandler -> public int getMessageSizeLimit();1399825877;Get the configured message buffer size limit in bytes.__@since 4.0.3;public int getMessageSizeLimit() {_		return this.messageSizeLimit__	};get,the,configured,message,buffer,size,limit,in,bytes,since,4,0,3;public,int,get,message,size,limit,return,this,message,size,limit
StompSubProtocolHandler -> public int getMessageSizeLimit();1403719829;Get the configured message buffer size limit in bytes.__@since 4.0.3;public int getMessageSizeLimit() {_		return this.messageSizeLimit__	};get,the,configured,message,buffer,size,limit,in,bytes,since,4,0,3;public,int,get,message,size,limit,return,this,message,size,limit
StompSubProtocolHandler -> public int getMessageSizeLimit();1403856366;Get the configured message buffer size limit in bytes.__@since 4.0.3;public int getMessageSizeLimit() {_		return this.messageSizeLimit__	};get,the,configured,message,buffer,size,limit,in,bytes,since,4,0,3;public,int,get,message,size,limit,return,this,message,size,limit
StompSubProtocolHandler -> public int getMessageSizeLimit();1403968062;Get the configured message buffer size limit in bytes.__@since 4.0.3;public int getMessageSizeLimit() {_		return this.messageSizeLimit__	};get,the,configured,message,buffer,size,limit,in,bytes,since,4,0,3;public,int,get,message,size,limit,return,this,message,size,limit
StompSubProtocolHandler -> public int getMessageSizeLimit();1404880787;Get the configured message buffer size limit in bytes.__@since 4.0.3;public int getMessageSizeLimit() {_		return this.messageSizeLimit__	};get,the,configured,message,buffer,size,limit,in,bytes,since,4,0,3;public,int,get,message,size,limit,return,this,message,size,limit
StompSubProtocolHandler -> public int getMessageSizeLimit();1404880799;Get the configured message buffer size limit in bytes.__@since 4.0.3;public int getMessageSizeLimit() {_		return this.messageSizeLimit__	};get,the,configured,message,buffer,size,limit,in,bytes,since,4,0,3;public,int,get,message,size,limit,return,this,message,size,limit
StompSubProtocolHandler -> public int getMessageSizeLimit();1411067168;Get the configured message buffer size limit in bytes.__@since 4.0.3;public int getMessageSizeLimit() {_		return this.messageSizeLimit__	};get,the,configured,message,buffer,size,limit,in,bytes,since,4,0,3;public,int,get,message,size,limit,return,this,message,size,limit
StompSubProtocolHandler -> public int getMessageSizeLimit();1411068071;Get the configured message buffer size limit in bytes.__@since 4.0.3;public int getMessageSizeLimit() {_		return this.messageSizeLimit__	};get,the,configured,message,buffer,size,limit,in,bytes,since,4,0,3;public,int,get,message,size,limit,return,this,message,size,limit
StompSubProtocolHandler -> public int getMessageSizeLimit();1411148800;Get the configured message buffer size limit in bytes.__@since 4.0.3;public int getMessageSizeLimit() {_		return this.messageSizeLimit__	};get,the,configured,message,buffer,size,limit,in,bytes,since,4,0,3;public,int,get,message,size,limit,return,this,message,size,limit
StompSubProtocolHandler -> public int getMessageSizeLimit();1411567635;Get the configured message buffer size limit in bytes.__@since 4.0.3;public int getMessageSizeLimit() {_		return this.messageSizeLimit__	};get,the,configured,message,buffer,size,limit,in,bytes,since,4,0,3;public,int,get,message,size,limit,return,this,message,size,limit
StompSubProtocolHandler -> public int getMessageSizeLimit();1412965899;Get the configured message buffer size limit in bytes.__@since 4.0.3;public int getMessageSizeLimit() {_		return this.messageSizeLimit__	};get,the,configured,message,buffer,size,limit,in,bytes,since,4,0,3;public,int,get,message,size,limit,return,this,message,size,limit
StompSubProtocolHandler -> public int getMessageSizeLimit();1413848647;Get the configured message buffer size limit in bytes.__@since 4.0.3;public int getMessageSizeLimit() {_		return this.messageSizeLimit__	};get,the,configured,message,buffer,size,limit,in,bytes,since,4,0,3;public,int,get,message,size,limit,return,this,message,size,limit
StompSubProtocolHandler -> public int getMessageSizeLimit();1414092351;Get the configured message buffer size limit in bytes.__@since 4.0.3;public int getMessageSizeLimit() {_		return this.messageSizeLimit__	};get,the,configured,message,buffer,size,limit,in,bytes,since,4,0,3;public,int,get,message,size,limit,return,this,message,size,limit
StompSubProtocolHandler -> public int getMessageSizeLimit();1414158498;Get the configured message buffer size limit in bytes.__@since 4.0.3;public int getMessageSizeLimit() {_		return this.messageSizeLimit__	};get,the,configured,message,buffer,size,limit,in,bytes,since,4,0,3;public,int,get,message,size,limit,return,this,message,size,limit
StompSubProtocolHandler -> public int getMessageSizeLimit();1419362683;Get the configured message buffer size limit in bytes.__@since 4.0.3;public int getMessageSizeLimit() {_		return this.messageSizeLimit__	};get,the,configured,message,buffer,size,limit,in,bytes,since,4,0,3;public,int,get,message,size,limit,return,this,message,size,limit
StompSubProtocolHandler -> public int getMessageSizeLimit();1419883989;Get the configured message buffer size limit in bytes.__@since 4.0.3;public int getMessageSizeLimit() {_		return this.messageSizeLimit__	};get,the,configured,message,buffer,size,limit,in,bytes,since,4,0,3;public,int,get,message,size,limit,return,this,message,size,limit
StompSubProtocolHandler -> public int getMessageSizeLimit();1424278379;Get the configured message buffer size limit in bytes.__@since 4.0.3;public int getMessageSizeLimit() {_		return this.messageSizeLimit__	};get,the,configured,message,buffer,size,limit,in,bytes,since,4,0,3;public,int,get,message,size,limit,return,this,message,size,limit
StompSubProtocolHandler -> public int getMessageSizeLimit();1428353843;Get the configured message buffer size limit in bytes.__@since 4.0.3;public int getMessageSizeLimit() {_		return this.messageSizeLimit__	};get,the,configured,message,buffer,size,limit,in,bytes,since,4,0,3;public,int,get,message,size,limit,return,this,message,size,limit
StompSubProtocolHandler -> public int getMessageSizeLimit();1430834982;Get the configured message buffer size limit in bytes.__@since 4.0.3;public int getMessageSizeLimit() {_		return this.messageSizeLimit__	};get,the,configured,message,buffer,size,limit,in,bytes,since,4,0,3;public,int,get,message,size,limit,return,this,message,size,limit
StompSubProtocolHandler -> public int getMessageSizeLimit();1431458952;Get the configured message buffer size limit in bytes.__@since 4.0.3;public int getMessageSizeLimit() {_		return this.messageSizeLimit__	};get,the,configured,message,buffer,size,limit,in,bytes,since,4,0,3;public,int,get,message,size,limit,return,this,message,size,limit
StompSubProtocolHandler -> public int getMessageSizeLimit();1431728285;Get the configured message buffer size limit in bytes.__@since 4.0.3;public int getMessageSizeLimit() {_		return this.messageSizeLimit__	};get,the,configured,message,buffer,size,limit,in,bytes,since,4,0,3;public,int,get,message,size,limit,return,this,message,size,limit
StompSubProtocolHandler -> public int getMessageSizeLimit();1432316649;Get the configured message buffer size limit in bytes.__@since 4.0.3;public int getMessageSizeLimit() {_		return this.messageSizeLimit__	};get,the,configured,message,buffer,size,limit,in,bytes,since,4,0,3;public,int,get,message,size,limit,return,this,message,size,limit
StompSubProtocolHandler -> public int getMessageSizeLimit();1432331447;Get the configured message buffer size limit in bytes._@since 4.0.3;public int getMessageSizeLimit() {_		return this.messageSizeLimit__	};get,the,configured,message,buffer,size,limit,in,bytes,since,4,0,3;public,int,get,message,size,limit,return,this,message,size,limit
StompSubProtocolHandler -> public int getMessageSizeLimit();1440168414;Get the configured message buffer size limit in bytes._@since 4.0.3;public int getMessageSizeLimit() {_		return this.messageSizeLimit__	};get,the,configured,message,buffer,size,limit,in,bytes,since,4,0,3;public,int,get,message,size,limit,return,this,message,size,limit
StompSubProtocolHandler -> public int getMessageSizeLimit();1440249342;Get the configured message buffer size limit in bytes._@since 4.0.3;public int getMessageSizeLimit() {_		return this.messageSizeLimit__	};get,the,configured,message,buffer,size,limit,in,bytes,since,4,0,3;public,int,get,message,size,limit,return,this,message,size,limit
StompSubProtocolHandler -> public int getMessageSizeLimit();1467726769;Get the configured message buffer size limit in bytes._@since 4.0.3;public int getMessageSizeLimit() {_		return this.messageSizeLimit__	};get,the,configured,message,buffer,size,limit,in,bytes,since,4,0,3;public,int,get,message,size,limit,return,this,message,size,limit
StompSubProtocolHandler -> public int getMessageSizeLimit();1467730834;Get the configured message buffer size limit in bytes._@since 4.0.3;public int getMessageSizeLimit() {_		return this.messageSizeLimit__	};get,the,configured,message,buffer,size,limit,in,bytes,since,4,0,3;public,int,get,message,size,limit,return,this,message,size,limit
StompSubProtocolHandler -> public int getMessageSizeLimit();1472062321;Get the configured message buffer size limit in bytes._@since 4.0.3;public int getMessageSizeLimit() {_		return this.messageSizeLimit__	};get,the,configured,message,buffer,size,limit,in,bytes,since,4,0,3;public,int,get,message,size,limit,return,this,message,size,limit
StompSubProtocolHandler -> public int getMessageSizeLimit();1472509879;Get the configured message buffer size limit in bytes._@since 4.0.3;public int getMessageSizeLimit() {_		return this.messageSizeLimit__	};get,the,configured,message,buffer,size,limit,in,bytes,since,4,0,3;public,int,get,message,size,limit,return,this,message,size,limit
StompSubProtocolHandler -> public int getMessageSizeLimit();1476284885;Get the configured message buffer size limit in bytes._@since 4.0.3;public int getMessageSizeLimit() {_		return this.messageSizeLimit__	};get,the,configured,message,buffer,size,limit,in,bytes,since,4,0,3;public,int,get,message,size,limit,return,this,message,size,limit
StompSubProtocolHandler -> public int getMessageSizeLimit();1481213680;Get the configured message buffer size limit in bytes._@since 4.0.3;public int getMessageSizeLimit() {_		return this.messageSizeLimit__	};get,the,configured,message,buffer,size,limit,in,bytes,since,4,0,3;public,int,get,message,size,limit,return,this,message,size,limit
StompSubProtocolHandler -> public int getMessageSizeLimit();1481669991;Get the configured message buffer size limit in bytes._@since 4.0.3;public int getMessageSizeLimit() {_		return this.messageSizeLimit__	};get,the,configured,message,buffer,size,limit,in,bytes,since,4,0,3;public,int,get,message,size,limit,return,this,message,size,limit
StompSubProtocolHandler -> public int getMessageSizeLimit();1482265068;Get the configured message buffer size limit in bytes._@since 4.0.3;public int getMessageSizeLimit() {_		return this.messageSizeLimit__	};get,the,configured,message,buffer,size,limit,in,bytes,since,4,0,3;public,int,get,message,size,limit,return,this,message,size,limit
StompSubProtocolHandler -> public int getMessageSizeLimit();1495868221;Get the configured message buffer size limit in bytes._@since 4.0.3;public int getMessageSizeLimit() {_		return this.messageSizeLimit__	};get,the,configured,message,buffer,size,limit,in,bytes,since,4,0,3;public,int,get,message,size,limit,return,this,message,size,limit
StompSubProtocolHandler -> public int getMessageSizeLimit();1496837955;Get the configured message buffer size limit in bytes._@since 4.0.3;public int getMessageSizeLimit() {_		return this.messageSizeLimit__	};get,the,configured,message,buffer,size,limit,in,bytes,since,4,0,3;public,int,get,message,size,limit,return,this,message,size,limit
StompSubProtocolHandler -> public int getMessageSizeLimit();1497251962;Get the configured message buffer size limit in bytes._@since 4.0.3;public int getMessageSizeLimit() {_		return this.messageSizeLimit__	};get,the,configured,message,buffer,size,limit,in,bytes,since,4,0,3;public,int,get,message,size,limit,return,this,message,size,limit
StompSubProtocolHandler -> public int getMessageSizeLimit();1498780456;Get the configured message buffer size limit in bytes._@since 4.0.3;public int getMessageSizeLimit() {_		return this.messageSizeLimit__	};get,the,configured,message,buffer,size,limit,in,bytes,since,4,0,3;public,int,get,message,size,limit,return,this,message,size,limit
StompSubProtocolHandler -> public int getMessageSizeLimit();1500448076;Get the configured message buffer size limit in bytes._@since 4.0.3;public int getMessageSizeLimit() {_		return this.messageSizeLimit__	};get,the,configured,message,buffer,size,limit,in,bytes,since,4,0,3;public,int,get,message,size,limit,return,this,message,size,limit
StompSubProtocolHandler -> public int getMessageSizeLimit();1501147952;Get the configured message buffer size limit in bytes._@since 4.0.3;public int getMessageSizeLimit() {_		return this.messageSizeLimit__	};get,the,configured,message,buffer,size,limit,in,bytes,since,4,0,3;public,int,get,message,size,limit,return,this,message,size,limit
StompSubProtocolHandler -> public int getMessageSizeLimit();1502974979;Get the configured message buffer size limit in bytes._@since 4.0.3;public int getMessageSizeLimit() {_		return this.messageSizeLimit__	};get,the,configured,message,buffer,size,limit,in,bytes,since,4,0,3;public,int,get,message,size,limit,return,this,message,size,limit
StompSubProtocolHandler -> public int getMessageSizeLimit();1509997270;Get the configured message buffer size limit in bytes._@since 4.0.3;public int getMessageSizeLimit() {_		return this.messageSizeLimit__	};get,the,configured,message,buffer,size,limit,in,bytes,since,4,0,3;public,int,get,message,size,limit,return,this,message,size,limit
StompSubProtocolHandler -> public int getMessageSizeLimit();1530174524;Get the configured message buffer size limit in bytes._@since 4.0.3;public int getMessageSizeLimit() {_		return this.messageSizeLimit__	};get,the,configured,message,buffer,size,limit,in,bytes,since,4,0,3;public,int,get,message,size,limit,return,this,message,size,limit
StompSubProtocolHandler -> public int getMessageSizeLimit();1536886762;Get the configured message buffer size limit in bytes._@since 4.0.3;public int getMessageSizeLimit() {_		return this.messageSizeLimit__	};get,the,configured,message,buffer,size,limit,in,bytes,since,4,0,3;public,int,get,message,size,limit,return,this,message,size,limit
StompSubProtocolHandler -> public int getMessageSizeLimit();1542899558;Get the configured message buffer size limit in bytes._@since 4.0.3;public int getMessageSizeLimit() {_		return this.messageSizeLimit__	};get,the,configured,message,buffer,size,limit,in,bytes,since,4,0,3;public,int,get,message,size,limit,return,this,message,size,limit
StompSubProtocolHandler -> public void setEncoder(StompEncoder encoder);1481213680;Configure a {@link StompEncoder} for encoding STOMP frames_@param encoder the encoder_@since 4.3.5;public void setEncoder(StompEncoder encoder) {_		this.stompEncoder = encoder__	};configure,a,link,stomp,encoder,for,encoding,stomp,frames,param,encoder,the,encoder,since,4,3,5;public,void,set,encoder,stomp,encoder,encoder,this,stomp,encoder,encoder
StompSubProtocolHandler -> public void setEncoder(StompEncoder encoder);1481669991;Configure a {@link StompEncoder} for encoding STOMP frames_@param encoder the encoder_@since 4.3.5;public void setEncoder(StompEncoder encoder) {_		this.stompEncoder = encoder__	};configure,a,link,stomp,encoder,for,encoding,stomp,frames,param,encoder,the,encoder,since,4,3,5;public,void,set,encoder,stomp,encoder,encoder,this,stomp,encoder,encoder
StompSubProtocolHandler -> public void setEncoder(StompEncoder encoder);1482265068;Configure a {@link StompEncoder} for encoding STOMP frames_@since 4.3.5;public void setEncoder(StompEncoder encoder) {_		this.stompEncoder = encoder__	};configure,a,link,stomp,encoder,for,encoding,stomp,frames,since,4,3,5;public,void,set,encoder,stomp,encoder,encoder,this,stomp,encoder,encoder
StompSubProtocolHandler -> public void setEncoder(StompEncoder encoder);1495868221;Configure a {@link StompEncoder} for encoding STOMP frames_@since 4.3.5;public void setEncoder(StompEncoder encoder) {_		this.stompEncoder = encoder__	};configure,a,link,stomp,encoder,for,encoding,stomp,frames,since,4,3,5;public,void,set,encoder,stomp,encoder,encoder,this,stomp,encoder,encoder
StompSubProtocolHandler -> public void setEncoder(StompEncoder encoder);1496837955;Configure a {@link StompEncoder} for encoding STOMP frames_@since 4.3.5;public void setEncoder(StompEncoder encoder) {_		this.stompEncoder = encoder__	};configure,a,link,stomp,encoder,for,encoding,stomp,frames,since,4,3,5;public,void,set,encoder,stomp,encoder,encoder,this,stomp,encoder,encoder
StompSubProtocolHandler -> public void setEncoder(StompEncoder encoder);1497251962;Configure a {@link StompEncoder} for encoding STOMP frames_@since 4.3.5;public void setEncoder(StompEncoder encoder) {_		this.stompEncoder = encoder__	};configure,a,link,stomp,encoder,for,encoding,stomp,frames,since,4,3,5;public,void,set,encoder,stomp,encoder,encoder,this,stomp,encoder,encoder
StompSubProtocolHandler -> public void setEncoder(StompEncoder encoder);1498780456;Configure a {@link StompEncoder} for encoding STOMP frames_@since 4.3.5;public void setEncoder(StompEncoder encoder) {_		this.stompEncoder = encoder__	};configure,a,link,stomp,encoder,for,encoding,stomp,frames,since,4,3,5;public,void,set,encoder,stomp,encoder,encoder,this,stomp,encoder,encoder
StompSubProtocolHandler -> public void setEncoder(StompEncoder encoder);1500448076;Configure a {@link StompEncoder} for encoding STOMP frames_@since 4.3.5;public void setEncoder(StompEncoder encoder) {_		this.stompEncoder = encoder__	};configure,a,link,stomp,encoder,for,encoding,stomp,frames,since,4,3,5;public,void,set,encoder,stomp,encoder,encoder,this,stomp,encoder,encoder
StompSubProtocolHandler -> public void setEncoder(StompEncoder encoder);1501147952;Configure a {@link StompEncoder} for encoding STOMP frames_@since 4.3.5;public void setEncoder(StompEncoder encoder) {_		this.stompEncoder = encoder__	};configure,a,link,stomp,encoder,for,encoding,stomp,frames,since,4,3,5;public,void,set,encoder,stomp,encoder,encoder,this,stomp,encoder,encoder
StompSubProtocolHandler -> public void setEncoder(StompEncoder encoder);1502974979;Configure a {@link StompEncoder} for encoding STOMP frames_@since 4.3.5;public void setEncoder(StompEncoder encoder) {_		this.stompEncoder = encoder__	};configure,a,link,stomp,encoder,for,encoding,stomp,frames,since,4,3,5;public,void,set,encoder,stomp,encoder,encoder,this,stomp,encoder,encoder
StompSubProtocolHandler -> public void setEncoder(StompEncoder encoder);1509997270;Configure a {@link StompEncoder} for encoding STOMP frames_@since 4.3.5;public void setEncoder(StompEncoder encoder) {_		this.stompEncoder = encoder__	};configure,a,link,stomp,encoder,for,encoding,stomp,frames,since,4,3,5;public,void,set,encoder,stomp,encoder,encoder,this,stomp,encoder,encoder
StompSubProtocolHandler -> public void setEncoder(StompEncoder encoder);1530174524;Configure a {@link StompEncoder} for encoding STOMP frames._@since 4.3.5;public void setEncoder(StompEncoder encoder) {_		this.stompEncoder = encoder__	};configure,a,link,stomp,encoder,for,encoding,stomp,frames,since,4,3,5;public,void,set,encoder,stomp,encoder,encoder,this,stomp,encoder,encoder
StompSubProtocolHandler -> public void setEncoder(StompEncoder encoder);1536886762;Configure a {@link StompEncoder} for encoding STOMP frames._@since 4.3.5;public void setEncoder(StompEncoder encoder) {_		this.stompEncoder = encoder__	};configure,a,link,stomp,encoder,for,encoding,stomp,frames,since,4,3,5;public,void,set,encoder,stomp,encoder,encoder,this,stomp,encoder,encoder
StompSubProtocolHandler -> public void setEncoder(StompEncoder encoder);1542899558;Configure a {@link StompEncoder} for encoding STOMP frames._@since 4.3.5;public void setEncoder(StompEncoder encoder) {_		this.stompEncoder = encoder__	};configure,a,link,stomp,encoder,for,encoding,stomp,frames,since,4,3,5;public,void,set,encoder,stomp,encoder,encoder,this,stomp,encoder,encoder
StompSubProtocolHandler -> public int getMessageBufferSizeLimit();1395703237;TODO_@return;public int getMessageBufferSizeLimit() {_		return this.messageBufferSizeLimit__	};todo,return;public,int,get,message,buffer,size,limit,return,this,message,buffer,size,limit
StompSubProtocolHandler -> public int getMessageBufferSizeLimit();1395703237;Get the message buffer size limit in bytes._@since 4.0.3;public int getMessageBufferSizeLimit() {_		return this.messageBufferSizeLimit__	};get,the,message,buffer,size,limit,in,bytes,since,4,0,3;public,int,get,message,buffer,size,limit,return,this,message,buffer,size,limit
StompSubProtocolHandler -> public int getMessageBufferSizeLimit();1395703237;Get the configured message buffer size limit in bytes.__@since 4.0.3;public int getMessageBufferSizeLimit() {_		return this.messageBufferSizeLimit__	};get,the,configured,message,buffer,size,limit,in,bytes,since,4,0,3;public,int,get,message,buffer,size,limit,return,this,message,buffer,size,limit
StompSubProtocolHandler -> public void setDecoder(StompDecoder decoder);1481213680;Configure a {@link StompDecoder} for decoding STOMP frames_@param decoder the decoder_@since 4.3.5;public void setDecoder(StompDecoder decoder) {_		this.stompDecoder = decoder__	};configure,a,link,stomp,decoder,for,decoding,stomp,frames,param,decoder,the,decoder,since,4,3,5;public,void,set,decoder,stomp,decoder,decoder,this,stomp,decoder,decoder
StompSubProtocolHandler -> public void setDecoder(StompDecoder decoder);1481669991;Configure a {@link StompDecoder} for decoding STOMP frames_@param decoder the decoder_@since 4.3.5;public void setDecoder(StompDecoder decoder) {_		this.stompDecoder = decoder__	};configure,a,link,stomp,decoder,for,decoding,stomp,frames,param,decoder,the,decoder,since,4,3,5;public,void,set,decoder,stomp,decoder,decoder,this,stomp,decoder,decoder
StompSubProtocolHandler -> public void setDecoder(StompDecoder decoder);1482265068;Configure a {@link StompDecoder} for decoding STOMP frames_@since 4.3.5;public void setDecoder(StompDecoder decoder) {_		this.stompDecoder = decoder__	};configure,a,link,stomp,decoder,for,decoding,stomp,frames,since,4,3,5;public,void,set,decoder,stomp,decoder,decoder,this,stomp,decoder,decoder
StompSubProtocolHandler -> public void setDecoder(StompDecoder decoder);1495868221;Configure a {@link StompDecoder} for decoding STOMP frames_@since 4.3.5;public void setDecoder(StompDecoder decoder) {_		this.stompDecoder = decoder__	};configure,a,link,stomp,decoder,for,decoding,stomp,frames,since,4,3,5;public,void,set,decoder,stomp,decoder,decoder,this,stomp,decoder,decoder
StompSubProtocolHandler -> public void setDecoder(StompDecoder decoder);1496837955;Configure a {@link StompDecoder} for decoding STOMP frames_@since 4.3.5;public void setDecoder(StompDecoder decoder) {_		this.stompDecoder = decoder__	};configure,a,link,stomp,decoder,for,decoding,stomp,frames,since,4,3,5;public,void,set,decoder,stomp,decoder,decoder,this,stomp,decoder,decoder
StompSubProtocolHandler -> public void setDecoder(StompDecoder decoder);1497251962;Configure a {@link StompDecoder} for decoding STOMP frames_@since 4.3.5;public void setDecoder(StompDecoder decoder) {_		this.stompDecoder = decoder__	};configure,a,link,stomp,decoder,for,decoding,stomp,frames,since,4,3,5;public,void,set,decoder,stomp,decoder,decoder,this,stomp,decoder,decoder
StompSubProtocolHandler -> public void setDecoder(StompDecoder decoder);1498780456;Configure a {@link StompDecoder} for decoding STOMP frames_@since 4.3.5;public void setDecoder(StompDecoder decoder) {_		this.stompDecoder = decoder__	};configure,a,link,stomp,decoder,for,decoding,stomp,frames,since,4,3,5;public,void,set,decoder,stomp,decoder,decoder,this,stomp,decoder,decoder
StompSubProtocolHandler -> public void setDecoder(StompDecoder decoder);1500448076;Configure a {@link StompDecoder} for decoding STOMP frames_@since 4.3.5;public void setDecoder(StompDecoder decoder) {_		this.stompDecoder = decoder__	};configure,a,link,stomp,decoder,for,decoding,stomp,frames,since,4,3,5;public,void,set,decoder,stomp,decoder,decoder,this,stomp,decoder,decoder
StompSubProtocolHandler -> public void setDecoder(StompDecoder decoder);1501147952;Configure a {@link StompDecoder} for decoding STOMP frames_@since 4.3.5;public void setDecoder(StompDecoder decoder) {_		this.stompDecoder = decoder__	};configure,a,link,stomp,decoder,for,decoding,stomp,frames,since,4,3,5;public,void,set,decoder,stomp,decoder,decoder,this,stomp,decoder,decoder
StompSubProtocolHandler -> public void setDecoder(StompDecoder decoder);1502974979;Configure a {@link StompDecoder} for decoding STOMP frames_@since 4.3.5;public void setDecoder(StompDecoder decoder) {_		this.stompDecoder = decoder__	};configure,a,link,stomp,decoder,for,decoding,stomp,frames,since,4,3,5;public,void,set,decoder,stomp,decoder,decoder,this,stomp,decoder,decoder
StompSubProtocolHandler -> public void setDecoder(StompDecoder decoder);1509997270;Configure a {@link StompDecoder} for decoding STOMP frames_@since 4.3.5;public void setDecoder(StompDecoder decoder) {_		this.stompDecoder = decoder__	};configure,a,link,stomp,decoder,for,decoding,stomp,frames,since,4,3,5;public,void,set,decoder,stomp,decoder,decoder,this,stomp,decoder,decoder
StompSubProtocolHandler -> public void setDecoder(StompDecoder decoder);1530174524;Configure a {@link StompDecoder} for decoding STOMP frames._@since 4.3.5;public void setDecoder(StompDecoder decoder) {_		this.stompDecoder = decoder__	};configure,a,link,stomp,decoder,for,decoding,stomp,frames,since,4,3,5;public,void,set,decoder,stomp,decoder,decoder,this,stomp,decoder,decoder
StompSubProtocolHandler -> public void setDecoder(StompDecoder decoder);1536886762;Configure a {@link StompDecoder} for decoding STOMP frames._@since 4.3.5;public void setDecoder(StompDecoder decoder) {_		this.stompDecoder = decoder__	};configure,a,link,stomp,decoder,for,decoding,stomp,frames,since,4,3,5;public,void,set,decoder,stomp,decoder,decoder,this,stomp,decoder,decoder
StompSubProtocolHandler -> public void setDecoder(StompDecoder decoder);1542899558;Configure a {@link StompDecoder} for decoding STOMP frames._@since 4.3.5;public void setDecoder(StompDecoder decoder) {_		this.stompDecoder = decoder__	};configure,a,link,stomp,decoder,for,decoding,stomp,frames,since,4,3,5;public,void,set,decoder,stomp,decoder,decoder,this,stomp,decoder,decoder
StompSubProtocolHandler -> public void setMessageSizeLimit(int messageSizeLimit);1395703238;Configure the maximum size allowed for an incoming STOMP message._Since a STOMP message can be received in multiple WebSocket messages,_buffering may be required and therefore it is necessary to know the maximum_allowed message size.__<p>By default this property is set to 64K.__@since 4.0.3;public void setMessageSizeLimit(int messageSizeLimit) {_		this.messageSizeLimit = messageSizeLimit__	};configure,the,maximum,size,allowed,for,an,incoming,stomp,message,since,a,stomp,message,can,be,received,in,multiple,web,socket,messages,buffering,may,be,required,and,therefore,it,is,necessary,to,know,the,maximum,allowed,message,size,p,by,default,this,property,is,set,to,64k,since,4,0,3;public,void,set,message,size,limit,int,message,size,limit,this,message,size,limit,message,size,limit
StompSubProtocolHandler -> public void setMessageSizeLimit(int messageSizeLimit);1395707441;Configure the maximum size allowed for an incoming STOMP message._Since a STOMP message can be received in multiple WebSocket messages,_buffering may be required and therefore it is necessary to know the maximum_allowed message size.__<p>By default this property is set to 64K.__@since 4.0.3;public void setMessageSizeLimit(int messageSizeLimit) {_		this.messageSizeLimit = messageSizeLimit__	};configure,the,maximum,size,allowed,for,an,incoming,stomp,message,since,a,stomp,message,can,be,received,in,multiple,web,socket,messages,buffering,may,be,required,and,therefore,it,is,necessary,to,know,the,maximum,allowed,message,size,p,by,default,this,property,is,set,to,64k,since,4,0,3;public,void,set,message,size,limit,int,message,size,limit,this,message,size,limit,message,size,limit
StompSubProtocolHandler -> public void setMessageSizeLimit(int messageSizeLimit);1395721625;Configure the maximum size allowed for an incoming STOMP message._Since a STOMP message can be received in multiple WebSocket messages,_buffering may be required and therefore it is necessary to know the maximum_allowed message size.__<p>By default this property is set to 64K.__@since 4.0.3;public void setMessageSizeLimit(int messageSizeLimit) {_		this.messageSizeLimit = messageSizeLimit__	};configure,the,maximum,size,allowed,for,an,incoming,stomp,message,since,a,stomp,message,can,be,received,in,multiple,web,socket,messages,buffering,may,be,required,and,therefore,it,is,necessary,to,know,the,maximum,allowed,message,size,p,by,default,this,property,is,set,to,64k,since,4,0,3;public,void,set,message,size,limit,int,message,size,limit,this,message,size,limit,message,size,limit
StompSubProtocolHandler -> public void setMessageSizeLimit(int messageSizeLimit);1395752742;Configure the maximum size allowed for an incoming STOMP message._Since a STOMP message can be received in multiple WebSocket messages,_buffering may be required and therefore it is necessary to know the maximum_allowed message size.__<p>By default this property is set to 64K.__@since 4.0.3;public void setMessageSizeLimit(int messageSizeLimit) {_		this.messageSizeLimit = messageSizeLimit__	};configure,the,maximum,size,allowed,for,an,incoming,stomp,message,since,a,stomp,message,can,be,received,in,multiple,web,socket,messages,buffering,may,be,required,and,therefore,it,is,necessary,to,know,the,maximum,allowed,message,size,p,by,default,this,property,is,set,to,64k,since,4,0,3;public,void,set,message,size,limit,int,message,size,limit,this,message,size,limit,message,size,limit
StompSubProtocolHandler -> public void setMessageSizeLimit(int messageSizeLimit);1395755949;Configure the maximum size allowed for an incoming STOMP message._Since a STOMP message can be received in multiple WebSocket messages,_buffering may be required and therefore it is necessary to know the maximum_allowed message size.__<p>By default this property is set to 64K.__@since 4.0.3;public void setMessageSizeLimit(int messageSizeLimit) {_		this.messageSizeLimit = messageSizeLimit__	};configure,the,maximum,size,allowed,for,an,incoming,stomp,message,since,a,stomp,message,can,be,received,in,multiple,web,socket,messages,buffering,may,be,required,and,therefore,it,is,necessary,to,know,the,maximum,allowed,message,size,p,by,default,this,property,is,set,to,64k,since,4,0,3;public,void,set,message,size,limit,int,message,size,limit,this,message,size,limit,message,size,limit
StompSubProtocolHandler -> public void setMessageSizeLimit(int messageSizeLimit);1395847954;Configure the maximum size allowed for an incoming STOMP message._Since a STOMP message can be received in multiple WebSocket messages,_buffering may be required and therefore it is necessary to know the maximum_allowed message size.__<p>By default this property is set to 64K.__@since 4.0.3;public void setMessageSizeLimit(int messageSizeLimit) {_		this.messageSizeLimit = messageSizeLimit__	};configure,the,maximum,size,allowed,for,an,incoming,stomp,message,since,a,stomp,message,can,be,received,in,multiple,web,socket,messages,buffering,may,be,required,and,therefore,it,is,necessary,to,know,the,maximum,allowed,message,size,p,by,default,this,property,is,set,to,64k,since,4,0,3;public,void,set,message,size,limit,int,message,size,limit,this,message,size,limit,message,size,limit
StompSubProtocolHandler -> public void setMessageSizeLimit(int messageSizeLimit);1396578670;Configure the maximum size allowed for an incoming STOMP message._Since a STOMP message can be received in multiple WebSocket messages,_buffering may be required and therefore it is necessary to know the maximum_allowed message size.__<p>By default this property is set to 64K.__@since 4.0.3;public void setMessageSizeLimit(int messageSizeLimit) {_		this.messageSizeLimit = messageSizeLimit__	};configure,the,maximum,size,allowed,for,an,incoming,stomp,message,since,a,stomp,message,can,be,received,in,multiple,web,socket,messages,buffering,may,be,required,and,therefore,it,is,necessary,to,know,the,maximum,allowed,message,size,p,by,default,this,property,is,set,to,64k,since,4,0,3;public,void,set,message,size,limit,int,message,size,limit,this,message,size,limit,message,size,limit
StompSubProtocolHandler -> public void setMessageSizeLimit(int messageSizeLimit);1396636309;Configure the maximum size allowed for an incoming STOMP message._Since a STOMP message can be received in multiple WebSocket messages,_buffering may be required and therefore it is necessary to know the maximum_allowed message size.__<p>By default this property is set to 64K.__@since 4.0.3;public void setMessageSizeLimit(int messageSizeLimit) {_		this.messageSizeLimit = messageSizeLimit__	};configure,the,maximum,size,allowed,for,an,incoming,stomp,message,since,a,stomp,message,can,be,received,in,multiple,web,socket,messages,buffering,may,be,required,and,therefore,it,is,necessary,to,know,the,maximum,allowed,message,size,p,by,default,this,property,is,set,to,64k,since,4,0,3;public,void,set,message,size,limit,int,message,size,limit,this,message,size,limit,message,size,limit
StompSubProtocolHandler -> public void setMessageSizeLimit(int messageSizeLimit);1397429525;Configure the maximum size allowed for an incoming STOMP message._Since a STOMP message can be received in multiple WebSocket messages,_buffering may be required and therefore it is necessary to know the maximum_allowed message size.__<p>By default this property is set to 64K.__@since 4.0.3;public void setMessageSizeLimit(int messageSizeLimit) {_		this.messageSizeLimit = messageSizeLimit__	};configure,the,maximum,size,allowed,for,an,incoming,stomp,message,since,a,stomp,message,can,be,received,in,multiple,web,socket,messages,buffering,may,be,required,and,therefore,it,is,necessary,to,know,the,maximum,allowed,message,size,p,by,default,this,property,is,set,to,64k,since,4,0,3;public,void,set,message,size,limit,int,message,size,limit,this,message,size,limit,message,size,limit
StompSubProtocolHandler -> public void setMessageSizeLimit(int messageSizeLimit);1397439322;Configure the maximum size allowed for an incoming STOMP message._Since a STOMP message can be received in multiple WebSocket messages,_buffering may be required and therefore it is necessary to know the maximum_allowed message size.__<p>By default this property is set to 64K.__@since 4.0.3;public void setMessageSizeLimit(int messageSizeLimit) {_		this.messageSizeLimit = messageSizeLimit__	};configure,the,maximum,size,allowed,for,an,incoming,stomp,message,since,a,stomp,message,can,be,received,in,multiple,web,socket,messages,buffering,may,be,required,and,therefore,it,is,necessary,to,know,the,maximum,allowed,message,size,p,by,default,this,property,is,set,to,64k,since,4,0,3;public,void,set,message,size,limit,int,message,size,limit,this,message,size,limit,message,size,limit
StompSubProtocolHandler -> public void setMessageSizeLimit(int messageSizeLimit);1397523793;Configure the maximum size allowed for an incoming STOMP message._Since a STOMP message can be received in multiple WebSocket messages,_buffering may be required and therefore it is necessary to know the maximum_allowed message size.__<p>By default this property is set to 64K.__@since 4.0.3;public void setMessageSizeLimit(int messageSizeLimit) {_		this.messageSizeLimit = messageSizeLimit__	};configure,the,maximum,size,allowed,for,an,incoming,stomp,message,since,a,stomp,message,can,be,received,in,multiple,web,socket,messages,buffering,may,be,required,and,therefore,it,is,necessary,to,know,the,maximum,allowed,message,size,p,by,default,this,property,is,set,to,64k,since,4,0,3;public,void,set,message,size,limit,int,message,size,limit,this,message,size,limit,message,size,limit
StompSubProtocolHandler -> public void setMessageSizeLimit(int messageSizeLimit);1398443164;Configure the maximum size allowed for an incoming STOMP message._Since a STOMP message can be received in multiple WebSocket messages,_buffering may be required and therefore it is necessary to know the maximum_allowed message size.__<p>By default this property is set to 64K.__@since 4.0.3;public void setMessageSizeLimit(int messageSizeLimit) {_		this.messageSizeLimit = messageSizeLimit__	};configure,the,maximum,size,allowed,for,an,incoming,stomp,message,since,a,stomp,message,can,be,received,in,multiple,web,socket,messages,buffering,may,be,required,and,therefore,it,is,necessary,to,know,the,maximum,allowed,message,size,p,by,default,this,property,is,set,to,64k,since,4,0,3;public,void,set,message,size,limit,int,message,size,limit,this,message,size,limit,message,size,limit
StompSubProtocolHandler -> public void setMessageSizeLimit(int messageSizeLimit);1399601217;Configure the maximum size allowed for an incoming STOMP message._Since a STOMP message can be received in multiple WebSocket messages,_buffering may be required and therefore it is necessary to know the maximum_allowed message size.__<p>By default this property is set to 64K.__@since 4.0.3;public void setMessageSizeLimit(int messageSizeLimit) {_		this.messageSizeLimit = messageSizeLimit__	};configure,the,maximum,size,allowed,for,an,incoming,stomp,message,since,a,stomp,message,can,be,received,in,multiple,web,socket,messages,buffering,may,be,required,and,therefore,it,is,necessary,to,know,the,maximum,allowed,message,size,p,by,default,this,property,is,set,to,64k,since,4,0,3;public,void,set,message,size,limit,int,message,size,limit,this,message,size,limit,message,size,limit
StompSubProtocolHandler -> public void setMessageSizeLimit(int messageSizeLimit);1399825877;Configure the maximum size allowed for an incoming STOMP message._Since a STOMP message can be received in multiple WebSocket messages,_buffering may be required and therefore it is necessary to know the maximum_allowed message size.__<p>By default this property is set to 64K.__@since 4.0.3;public void setMessageSizeLimit(int messageSizeLimit) {_		this.messageSizeLimit = messageSizeLimit__	};configure,the,maximum,size,allowed,for,an,incoming,stomp,message,since,a,stomp,message,can,be,received,in,multiple,web,socket,messages,buffering,may,be,required,and,therefore,it,is,necessary,to,know,the,maximum,allowed,message,size,p,by,default,this,property,is,set,to,64k,since,4,0,3;public,void,set,message,size,limit,int,message,size,limit,this,message,size,limit,message,size,limit
StompSubProtocolHandler -> public void setMessageSizeLimit(int messageSizeLimit);1403719829;Configure the maximum size allowed for an incoming STOMP message._Since a STOMP message can be received in multiple WebSocket messages,_buffering may be required and therefore it is necessary to know the maximum_allowed message size.__<p>By default this property is set to 64K.__@since 4.0.3;public void setMessageSizeLimit(int messageSizeLimit) {_		this.messageSizeLimit = messageSizeLimit__	};configure,the,maximum,size,allowed,for,an,incoming,stomp,message,since,a,stomp,message,can,be,received,in,multiple,web,socket,messages,buffering,may,be,required,and,therefore,it,is,necessary,to,know,the,maximum,allowed,message,size,p,by,default,this,property,is,set,to,64k,since,4,0,3;public,void,set,message,size,limit,int,message,size,limit,this,message,size,limit,message,size,limit
StompSubProtocolHandler -> public void setMessageSizeLimit(int messageSizeLimit);1403856366;Configure the maximum size allowed for an incoming STOMP message._Since a STOMP message can be received in multiple WebSocket messages,_buffering may be required and therefore it is necessary to know the maximum_allowed message size.__<p>By default this property is set to 64K.__@since 4.0.3;public void setMessageSizeLimit(int messageSizeLimit) {_		this.messageSizeLimit = messageSizeLimit__	};configure,the,maximum,size,allowed,for,an,incoming,stomp,message,since,a,stomp,message,can,be,received,in,multiple,web,socket,messages,buffering,may,be,required,and,therefore,it,is,necessary,to,know,the,maximum,allowed,message,size,p,by,default,this,property,is,set,to,64k,since,4,0,3;public,void,set,message,size,limit,int,message,size,limit,this,message,size,limit,message,size,limit
StompSubProtocolHandler -> public void setMessageSizeLimit(int messageSizeLimit);1403968062;Configure the maximum size allowed for an incoming STOMP message._Since a STOMP message can be received in multiple WebSocket messages,_buffering may be required and therefore it is necessary to know the maximum_allowed message size.__<p>By default this property is set to 64K.__@since 4.0.3;public void setMessageSizeLimit(int messageSizeLimit) {_		this.messageSizeLimit = messageSizeLimit__	};configure,the,maximum,size,allowed,for,an,incoming,stomp,message,since,a,stomp,message,can,be,received,in,multiple,web,socket,messages,buffering,may,be,required,and,therefore,it,is,necessary,to,know,the,maximum,allowed,message,size,p,by,default,this,property,is,set,to,64k,since,4,0,3;public,void,set,message,size,limit,int,message,size,limit,this,message,size,limit,message,size,limit
StompSubProtocolHandler -> public void setMessageSizeLimit(int messageSizeLimit);1404880787;Configure the maximum size allowed for an incoming STOMP message._Since a STOMP message can be received in multiple WebSocket messages,_buffering may be required and therefore it is necessary to know the maximum_allowed message size.__<p>By default this property is set to 64K.__@since 4.0.3;public void setMessageSizeLimit(int messageSizeLimit) {_		this.messageSizeLimit = messageSizeLimit__	};configure,the,maximum,size,allowed,for,an,incoming,stomp,message,since,a,stomp,message,can,be,received,in,multiple,web,socket,messages,buffering,may,be,required,and,therefore,it,is,necessary,to,know,the,maximum,allowed,message,size,p,by,default,this,property,is,set,to,64k,since,4,0,3;public,void,set,message,size,limit,int,message,size,limit,this,message,size,limit,message,size,limit
StompSubProtocolHandler -> public void setMessageSizeLimit(int messageSizeLimit);1404880799;Configure the maximum size allowed for an incoming STOMP message._Since a STOMP message can be received in multiple WebSocket messages,_buffering may be required and therefore it is necessary to know the maximum_allowed message size.__<p>By default this property is set to 64K.__@since 4.0.3;public void setMessageSizeLimit(int messageSizeLimit) {_		this.messageSizeLimit = messageSizeLimit__	};configure,the,maximum,size,allowed,for,an,incoming,stomp,message,since,a,stomp,message,can,be,received,in,multiple,web,socket,messages,buffering,may,be,required,and,therefore,it,is,necessary,to,know,the,maximum,allowed,message,size,p,by,default,this,property,is,set,to,64k,since,4,0,3;public,void,set,message,size,limit,int,message,size,limit,this,message,size,limit,message,size,limit
StompSubProtocolHandler -> public void setMessageSizeLimit(int messageSizeLimit);1411067168;Configure the maximum size allowed for an incoming STOMP message._Since a STOMP message can be received in multiple WebSocket messages,_buffering may be required and therefore it is necessary to know the maximum_allowed message size.__<p>By default this property is set to 64K.__@since 4.0.3;public void setMessageSizeLimit(int messageSizeLimit) {_		this.messageSizeLimit = messageSizeLimit__	};configure,the,maximum,size,allowed,for,an,incoming,stomp,message,since,a,stomp,message,can,be,received,in,multiple,web,socket,messages,buffering,may,be,required,and,therefore,it,is,necessary,to,know,the,maximum,allowed,message,size,p,by,default,this,property,is,set,to,64k,since,4,0,3;public,void,set,message,size,limit,int,message,size,limit,this,message,size,limit,message,size,limit
StompSubProtocolHandler -> public void setMessageSizeLimit(int messageSizeLimit);1411068071;Configure the maximum size allowed for an incoming STOMP message._Since a STOMP message can be received in multiple WebSocket messages,_buffering may be required and therefore it is necessary to know the maximum_allowed message size.__<p>By default this property is set to 64K.__@since 4.0.3;public void setMessageSizeLimit(int messageSizeLimit) {_		this.messageSizeLimit = messageSizeLimit__	};configure,the,maximum,size,allowed,for,an,incoming,stomp,message,since,a,stomp,message,can,be,received,in,multiple,web,socket,messages,buffering,may,be,required,and,therefore,it,is,necessary,to,know,the,maximum,allowed,message,size,p,by,default,this,property,is,set,to,64k,since,4,0,3;public,void,set,message,size,limit,int,message,size,limit,this,message,size,limit,message,size,limit
StompSubProtocolHandler -> public void setMessageSizeLimit(int messageSizeLimit);1411148800;Configure the maximum size allowed for an incoming STOMP message._Since a STOMP message can be received in multiple WebSocket messages,_buffering may be required and therefore it is necessary to know the maximum_allowed message size.__<p>By default this property is set to 64K.__@since 4.0.3;public void setMessageSizeLimit(int messageSizeLimit) {_		this.messageSizeLimit = messageSizeLimit__	};configure,the,maximum,size,allowed,for,an,incoming,stomp,message,since,a,stomp,message,can,be,received,in,multiple,web,socket,messages,buffering,may,be,required,and,therefore,it,is,necessary,to,know,the,maximum,allowed,message,size,p,by,default,this,property,is,set,to,64k,since,4,0,3;public,void,set,message,size,limit,int,message,size,limit,this,message,size,limit,message,size,limit
StompSubProtocolHandler -> public void setMessageSizeLimit(int messageSizeLimit);1411567635;Configure the maximum size allowed for an incoming STOMP message._Since a STOMP message can be received in multiple WebSocket messages,_buffering may be required and therefore it is necessary to know the maximum_allowed message size.__<p>By default this property is set to 64K.__@since 4.0.3;public void setMessageSizeLimit(int messageSizeLimit) {_		this.messageSizeLimit = messageSizeLimit__	};configure,the,maximum,size,allowed,for,an,incoming,stomp,message,since,a,stomp,message,can,be,received,in,multiple,web,socket,messages,buffering,may,be,required,and,therefore,it,is,necessary,to,know,the,maximum,allowed,message,size,p,by,default,this,property,is,set,to,64k,since,4,0,3;public,void,set,message,size,limit,int,message,size,limit,this,message,size,limit,message,size,limit
StompSubProtocolHandler -> public void setMessageSizeLimit(int messageSizeLimit);1412965899;Configure the maximum size allowed for an incoming STOMP message._Since a STOMP message can be received in multiple WebSocket messages,_buffering may be required and therefore it is necessary to know the maximum_allowed message size.__<p>By default this property is set to 64K.__@since 4.0.3;public void setMessageSizeLimit(int messageSizeLimit) {_		this.messageSizeLimit = messageSizeLimit__	};configure,the,maximum,size,allowed,for,an,incoming,stomp,message,since,a,stomp,message,can,be,received,in,multiple,web,socket,messages,buffering,may,be,required,and,therefore,it,is,necessary,to,know,the,maximum,allowed,message,size,p,by,default,this,property,is,set,to,64k,since,4,0,3;public,void,set,message,size,limit,int,message,size,limit,this,message,size,limit,message,size,limit
StompSubProtocolHandler -> public void setMessageSizeLimit(int messageSizeLimit);1413848647;Configure the maximum size allowed for an incoming STOMP message._Since a STOMP message can be received in multiple WebSocket messages,_buffering may be required and therefore it is necessary to know the maximum_allowed message size.__<p>By default this property is set to 64K.__@since 4.0.3;public void setMessageSizeLimit(int messageSizeLimit) {_		this.messageSizeLimit = messageSizeLimit__	};configure,the,maximum,size,allowed,for,an,incoming,stomp,message,since,a,stomp,message,can,be,received,in,multiple,web,socket,messages,buffering,may,be,required,and,therefore,it,is,necessary,to,know,the,maximum,allowed,message,size,p,by,default,this,property,is,set,to,64k,since,4,0,3;public,void,set,message,size,limit,int,message,size,limit,this,message,size,limit,message,size,limit
StompSubProtocolHandler -> public void setMessageSizeLimit(int messageSizeLimit);1414092351;Configure the maximum size allowed for an incoming STOMP message._Since a STOMP message can be received in multiple WebSocket messages,_buffering may be required and therefore it is necessary to know the maximum_allowed message size.__<p>By default this property is set to 64K.__@since 4.0.3;public void setMessageSizeLimit(int messageSizeLimit) {_		this.messageSizeLimit = messageSizeLimit__	};configure,the,maximum,size,allowed,for,an,incoming,stomp,message,since,a,stomp,message,can,be,received,in,multiple,web,socket,messages,buffering,may,be,required,and,therefore,it,is,necessary,to,know,the,maximum,allowed,message,size,p,by,default,this,property,is,set,to,64k,since,4,0,3;public,void,set,message,size,limit,int,message,size,limit,this,message,size,limit,message,size,limit
StompSubProtocolHandler -> public void setMessageSizeLimit(int messageSizeLimit);1414158498;Configure the maximum size allowed for an incoming STOMP message._Since a STOMP message can be received in multiple WebSocket messages,_buffering may be required and therefore it is necessary to know the maximum_allowed message size.__<p>By default this property is set to 64K.__@since 4.0.3;public void setMessageSizeLimit(int messageSizeLimit) {_		this.messageSizeLimit = messageSizeLimit__	};configure,the,maximum,size,allowed,for,an,incoming,stomp,message,since,a,stomp,message,can,be,received,in,multiple,web,socket,messages,buffering,may,be,required,and,therefore,it,is,necessary,to,know,the,maximum,allowed,message,size,p,by,default,this,property,is,set,to,64k,since,4,0,3;public,void,set,message,size,limit,int,message,size,limit,this,message,size,limit,message,size,limit
StompSubProtocolHandler -> public void setMessageSizeLimit(int messageSizeLimit);1419362683;Configure the maximum size allowed for an incoming STOMP message._Since a STOMP message can be received in multiple WebSocket messages,_buffering may be required and therefore it is necessary to know the maximum_allowed message size.__<p>By default this property is set to 64K.__@since 4.0.3;public void setMessageSizeLimit(int messageSizeLimit) {_		this.messageSizeLimit = messageSizeLimit__	};configure,the,maximum,size,allowed,for,an,incoming,stomp,message,since,a,stomp,message,can,be,received,in,multiple,web,socket,messages,buffering,may,be,required,and,therefore,it,is,necessary,to,know,the,maximum,allowed,message,size,p,by,default,this,property,is,set,to,64k,since,4,0,3;public,void,set,message,size,limit,int,message,size,limit,this,message,size,limit,message,size,limit
StompSubProtocolHandler -> public void setMessageSizeLimit(int messageSizeLimit);1419883989;Configure the maximum size allowed for an incoming STOMP message._Since a STOMP message can be received in multiple WebSocket messages,_buffering may be required and therefore it is necessary to know the maximum_allowed message size.__<p>By default this property is set to 64K.__@since 4.0.3;public void setMessageSizeLimit(int messageSizeLimit) {_		this.messageSizeLimit = messageSizeLimit__	};configure,the,maximum,size,allowed,for,an,incoming,stomp,message,since,a,stomp,message,can,be,received,in,multiple,web,socket,messages,buffering,may,be,required,and,therefore,it,is,necessary,to,know,the,maximum,allowed,message,size,p,by,default,this,property,is,set,to,64k,since,4,0,3;public,void,set,message,size,limit,int,message,size,limit,this,message,size,limit,message,size,limit
StompSubProtocolHandler -> public void setMessageSizeLimit(int messageSizeLimit);1424278379;Configure the maximum size allowed for an incoming STOMP message._Since a STOMP message can be received in multiple WebSocket messages,_buffering may be required and therefore it is necessary to know the maximum_allowed message size.__<p>By default this property is set to 64K.__@since 4.0.3;public void setMessageSizeLimit(int messageSizeLimit) {_		this.messageSizeLimit = messageSizeLimit__	};configure,the,maximum,size,allowed,for,an,incoming,stomp,message,since,a,stomp,message,can,be,received,in,multiple,web,socket,messages,buffering,may,be,required,and,therefore,it,is,necessary,to,know,the,maximum,allowed,message,size,p,by,default,this,property,is,set,to,64k,since,4,0,3;public,void,set,message,size,limit,int,message,size,limit,this,message,size,limit,message,size,limit
StompSubProtocolHandler -> public void setMessageSizeLimit(int messageSizeLimit);1428353843;Configure the maximum size allowed for an incoming STOMP message._Since a STOMP message can be received in multiple WebSocket messages,_buffering may be required and therefore it is necessary to know the maximum_allowed message size.__<p>By default this property is set to 64K.__@since 4.0.3;public void setMessageSizeLimit(int messageSizeLimit) {_		this.messageSizeLimit = messageSizeLimit__	};configure,the,maximum,size,allowed,for,an,incoming,stomp,message,since,a,stomp,message,can,be,received,in,multiple,web,socket,messages,buffering,may,be,required,and,therefore,it,is,necessary,to,know,the,maximum,allowed,message,size,p,by,default,this,property,is,set,to,64k,since,4,0,3;public,void,set,message,size,limit,int,message,size,limit,this,message,size,limit,message,size,limit
StompSubProtocolHandler -> public void setMessageSizeLimit(int messageSizeLimit);1430834982;Configure the maximum size allowed for an incoming STOMP message._Since a STOMP message can be received in multiple WebSocket messages,_buffering may be required and therefore it is necessary to know the maximum_allowed message size.__<p>By default this property is set to 64K.__@since 4.0.3;public void setMessageSizeLimit(int messageSizeLimit) {_		this.messageSizeLimit = messageSizeLimit__	};configure,the,maximum,size,allowed,for,an,incoming,stomp,message,since,a,stomp,message,can,be,received,in,multiple,web,socket,messages,buffering,may,be,required,and,therefore,it,is,necessary,to,know,the,maximum,allowed,message,size,p,by,default,this,property,is,set,to,64k,since,4,0,3;public,void,set,message,size,limit,int,message,size,limit,this,message,size,limit,message,size,limit
StompSubProtocolHandler -> public void setMessageSizeLimit(int messageSizeLimit);1431458952;Configure the maximum size allowed for an incoming STOMP message._Since a STOMP message can be received in multiple WebSocket messages,_buffering may be required and therefore it is necessary to know the maximum_allowed message size.__<p>By default this property is set to 64K.__@since 4.0.3;public void setMessageSizeLimit(int messageSizeLimit) {_		this.messageSizeLimit = messageSizeLimit__	};configure,the,maximum,size,allowed,for,an,incoming,stomp,message,since,a,stomp,message,can,be,received,in,multiple,web,socket,messages,buffering,may,be,required,and,therefore,it,is,necessary,to,know,the,maximum,allowed,message,size,p,by,default,this,property,is,set,to,64k,since,4,0,3;public,void,set,message,size,limit,int,message,size,limit,this,message,size,limit,message,size,limit
StompSubProtocolHandler -> public void setMessageSizeLimit(int messageSizeLimit);1431728285;Configure the maximum size allowed for an incoming STOMP message._Since a STOMP message can be received in multiple WebSocket messages,_buffering may be required and therefore it is necessary to know the maximum_allowed message size.__<p>By default this property is set to 64K.__@since 4.0.3;public void setMessageSizeLimit(int messageSizeLimit) {_		this.messageSizeLimit = messageSizeLimit__	};configure,the,maximum,size,allowed,for,an,incoming,stomp,message,since,a,stomp,message,can,be,received,in,multiple,web,socket,messages,buffering,may,be,required,and,therefore,it,is,necessary,to,know,the,maximum,allowed,message,size,p,by,default,this,property,is,set,to,64k,since,4,0,3;public,void,set,message,size,limit,int,message,size,limit,this,message,size,limit,message,size,limit
StompSubProtocolHandler -> public void setMessageSizeLimit(int messageSizeLimit);1432316649;Configure the maximum size allowed for an incoming STOMP message._Since a STOMP message can be received in multiple WebSocket messages,_buffering may be required and therefore it is necessary to know the maximum_allowed message size.__<p>By default this property is set to 64K.__@since 4.0.3;public void setMessageSizeLimit(int messageSizeLimit) {_		this.messageSizeLimit = messageSizeLimit__	};configure,the,maximum,size,allowed,for,an,incoming,stomp,message,since,a,stomp,message,can,be,received,in,multiple,web,socket,messages,buffering,may,be,required,and,therefore,it,is,necessary,to,know,the,maximum,allowed,message,size,p,by,default,this,property,is,set,to,64k,since,4,0,3;public,void,set,message,size,limit,int,message,size,limit,this,message,size,limit,message,size,limit
StompSubProtocolHandler -> public void setMessageSizeLimit(int messageSizeLimit);1432331447;Configure the maximum size allowed for an incoming STOMP message._Since a STOMP message can be received in multiple WebSocket messages,_buffering may be required and therefore it is necessary to know the maximum_allowed message size._<p>By default this property is set to 64K._@since 4.0.3;public void setMessageSizeLimit(int messageSizeLimit) {_		this.messageSizeLimit = messageSizeLimit__	};configure,the,maximum,size,allowed,for,an,incoming,stomp,message,since,a,stomp,message,can,be,received,in,multiple,web,socket,messages,buffering,may,be,required,and,therefore,it,is,necessary,to,know,the,maximum,allowed,message,size,p,by,default,this,property,is,set,to,64k,since,4,0,3;public,void,set,message,size,limit,int,message,size,limit,this,message,size,limit,message,size,limit
StompSubProtocolHandler -> public void setMessageSizeLimit(int messageSizeLimit);1440168414;Configure the maximum size allowed for an incoming STOMP message._Since a STOMP message can be received in multiple WebSocket messages,_buffering may be required and therefore it is necessary to know the maximum_allowed message size._<p>By default this property is set to 64K._@since 4.0.3;public void setMessageSizeLimit(int messageSizeLimit) {_		this.messageSizeLimit = messageSizeLimit__	};configure,the,maximum,size,allowed,for,an,incoming,stomp,message,since,a,stomp,message,can,be,received,in,multiple,web,socket,messages,buffering,may,be,required,and,therefore,it,is,necessary,to,know,the,maximum,allowed,message,size,p,by,default,this,property,is,set,to,64k,since,4,0,3;public,void,set,message,size,limit,int,message,size,limit,this,message,size,limit,message,size,limit
StompSubProtocolHandler -> public void setMessageSizeLimit(int messageSizeLimit);1440249342;Configure the maximum size allowed for an incoming STOMP message._Since a STOMP message can be received in multiple WebSocket messages,_buffering may be required and therefore it is necessary to know the maximum_allowed message size._<p>By default this property is set to 64K._@since 4.0.3;public void setMessageSizeLimit(int messageSizeLimit) {_		this.messageSizeLimit = messageSizeLimit__	};configure,the,maximum,size,allowed,for,an,incoming,stomp,message,since,a,stomp,message,can,be,received,in,multiple,web,socket,messages,buffering,may,be,required,and,therefore,it,is,necessary,to,know,the,maximum,allowed,message,size,p,by,default,this,property,is,set,to,64k,since,4,0,3;public,void,set,message,size,limit,int,message,size,limit,this,message,size,limit,message,size,limit
StompSubProtocolHandler -> public void setMessageSizeLimit(int messageSizeLimit);1467726769;Configure the maximum size allowed for an incoming STOMP message._Since a STOMP message can be received in multiple WebSocket messages,_buffering may be required and therefore it is necessary to know the maximum_allowed message size._<p>By default this property is set to 64K._@since 4.0.3;public void setMessageSizeLimit(int messageSizeLimit) {_		this.messageSizeLimit = messageSizeLimit__	};configure,the,maximum,size,allowed,for,an,incoming,stomp,message,since,a,stomp,message,can,be,received,in,multiple,web,socket,messages,buffering,may,be,required,and,therefore,it,is,necessary,to,know,the,maximum,allowed,message,size,p,by,default,this,property,is,set,to,64k,since,4,0,3;public,void,set,message,size,limit,int,message,size,limit,this,message,size,limit,message,size,limit
StompSubProtocolHandler -> public void setMessageSizeLimit(int messageSizeLimit);1467730834;Configure the maximum size allowed for an incoming STOMP message._Since a STOMP message can be received in multiple WebSocket messages,_buffering may be required and therefore it is necessary to know the maximum_allowed message size._<p>By default this property is set to 64K._@since 4.0.3;public void setMessageSizeLimit(int messageSizeLimit) {_		this.messageSizeLimit = messageSizeLimit__	};configure,the,maximum,size,allowed,for,an,incoming,stomp,message,since,a,stomp,message,can,be,received,in,multiple,web,socket,messages,buffering,may,be,required,and,therefore,it,is,necessary,to,know,the,maximum,allowed,message,size,p,by,default,this,property,is,set,to,64k,since,4,0,3;public,void,set,message,size,limit,int,message,size,limit,this,message,size,limit,message,size,limit
StompSubProtocolHandler -> public void setMessageSizeLimit(int messageSizeLimit);1472062321;Configure the maximum size allowed for an incoming STOMP message._Since a STOMP message can be received in multiple WebSocket messages,_buffering may be required and therefore it is necessary to know the maximum_allowed message size._<p>By default this property is set to 64K._@since 4.0.3;public void setMessageSizeLimit(int messageSizeLimit) {_		this.messageSizeLimit = messageSizeLimit__	};configure,the,maximum,size,allowed,for,an,incoming,stomp,message,since,a,stomp,message,can,be,received,in,multiple,web,socket,messages,buffering,may,be,required,and,therefore,it,is,necessary,to,know,the,maximum,allowed,message,size,p,by,default,this,property,is,set,to,64k,since,4,0,3;public,void,set,message,size,limit,int,message,size,limit,this,message,size,limit,message,size,limit
StompSubProtocolHandler -> public void setMessageSizeLimit(int messageSizeLimit);1472509879;Configure the maximum size allowed for an incoming STOMP message._Since a STOMP message can be received in multiple WebSocket messages,_buffering may be required and therefore it is necessary to know the maximum_allowed message size._<p>By default this property is set to 64K._@since 4.0.3;public void setMessageSizeLimit(int messageSizeLimit) {_		this.messageSizeLimit = messageSizeLimit__	};configure,the,maximum,size,allowed,for,an,incoming,stomp,message,since,a,stomp,message,can,be,received,in,multiple,web,socket,messages,buffering,may,be,required,and,therefore,it,is,necessary,to,know,the,maximum,allowed,message,size,p,by,default,this,property,is,set,to,64k,since,4,0,3;public,void,set,message,size,limit,int,message,size,limit,this,message,size,limit,message,size,limit
StompSubProtocolHandler -> public void setMessageSizeLimit(int messageSizeLimit);1476284885;Configure the maximum size allowed for an incoming STOMP message._Since a STOMP message can be received in multiple WebSocket messages,_buffering may be required and therefore it is necessary to know the maximum_allowed message size._<p>By default this property is set to 64K._@since 4.0.3;public void setMessageSizeLimit(int messageSizeLimit) {_		this.messageSizeLimit = messageSizeLimit__	};configure,the,maximum,size,allowed,for,an,incoming,stomp,message,since,a,stomp,message,can,be,received,in,multiple,web,socket,messages,buffering,may,be,required,and,therefore,it,is,necessary,to,know,the,maximum,allowed,message,size,p,by,default,this,property,is,set,to,64k,since,4,0,3;public,void,set,message,size,limit,int,message,size,limit,this,message,size,limit,message,size,limit
StompSubProtocolHandler -> public void setMessageSizeLimit(int messageSizeLimit);1481213680;Configure the maximum size allowed for an incoming STOMP message._Since a STOMP message can be received in multiple WebSocket messages,_buffering may be required and therefore it is necessary to know the maximum_allowed message size._<p>By default this property is set to 64K._@since 4.0.3;public void setMessageSizeLimit(int messageSizeLimit) {_		this.messageSizeLimit = messageSizeLimit__	};configure,the,maximum,size,allowed,for,an,incoming,stomp,message,since,a,stomp,message,can,be,received,in,multiple,web,socket,messages,buffering,may,be,required,and,therefore,it,is,necessary,to,know,the,maximum,allowed,message,size,p,by,default,this,property,is,set,to,64k,since,4,0,3;public,void,set,message,size,limit,int,message,size,limit,this,message,size,limit,message,size,limit
StompSubProtocolHandler -> public void setMessageSizeLimit(int messageSizeLimit);1481669991;Configure the maximum size allowed for an incoming STOMP message._Since a STOMP message can be received in multiple WebSocket messages,_buffering may be required and therefore it is necessary to know the maximum_allowed message size._<p>By default this property is set to 64K._@since 4.0.3;public void setMessageSizeLimit(int messageSizeLimit) {_		this.messageSizeLimit = messageSizeLimit__	};configure,the,maximum,size,allowed,for,an,incoming,stomp,message,since,a,stomp,message,can,be,received,in,multiple,web,socket,messages,buffering,may,be,required,and,therefore,it,is,necessary,to,know,the,maximum,allowed,message,size,p,by,default,this,property,is,set,to,64k,since,4,0,3;public,void,set,message,size,limit,int,message,size,limit,this,message,size,limit,message,size,limit
StompSubProtocolHandler -> public void setMessageSizeLimit(int messageSizeLimit);1482265068;Configure the maximum size allowed for an incoming STOMP message._Since a STOMP message can be received in multiple WebSocket messages,_buffering may be required and therefore it is necessary to know the maximum_allowed message size._<p>By default this property is set to 64K._@since 4.0.3;public void setMessageSizeLimit(int messageSizeLimit) {_		this.messageSizeLimit = messageSizeLimit__	};configure,the,maximum,size,allowed,for,an,incoming,stomp,message,since,a,stomp,message,can,be,received,in,multiple,web,socket,messages,buffering,may,be,required,and,therefore,it,is,necessary,to,know,the,maximum,allowed,message,size,p,by,default,this,property,is,set,to,64k,since,4,0,3;public,void,set,message,size,limit,int,message,size,limit,this,message,size,limit,message,size,limit
StompSubProtocolHandler -> public void setMessageSizeLimit(int messageSizeLimit);1495868221;Configure the maximum size allowed for an incoming STOMP message._Since a STOMP message can be received in multiple WebSocket messages,_buffering may be required and therefore it is necessary to know the maximum_allowed message size._<p>By default this property is set to 64K._@since 4.0.3;public void setMessageSizeLimit(int messageSizeLimit) {_		this.messageSizeLimit = messageSizeLimit__	};configure,the,maximum,size,allowed,for,an,incoming,stomp,message,since,a,stomp,message,can,be,received,in,multiple,web,socket,messages,buffering,may,be,required,and,therefore,it,is,necessary,to,know,the,maximum,allowed,message,size,p,by,default,this,property,is,set,to,64k,since,4,0,3;public,void,set,message,size,limit,int,message,size,limit,this,message,size,limit,message,size,limit
StompSubProtocolHandler -> public void setMessageSizeLimit(int messageSizeLimit);1496837955;Configure the maximum size allowed for an incoming STOMP message._Since a STOMP message can be received in multiple WebSocket messages,_buffering may be required and therefore it is necessary to know the maximum_allowed message size._<p>By default this property is set to 64K._@since 4.0.3;public void setMessageSizeLimit(int messageSizeLimit) {_		this.messageSizeLimit = messageSizeLimit__	};configure,the,maximum,size,allowed,for,an,incoming,stomp,message,since,a,stomp,message,can,be,received,in,multiple,web,socket,messages,buffering,may,be,required,and,therefore,it,is,necessary,to,know,the,maximum,allowed,message,size,p,by,default,this,property,is,set,to,64k,since,4,0,3;public,void,set,message,size,limit,int,message,size,limit,this,message,size,limit,message,size,limit
StompSubProtocolHandler -> public void setMessageSizeLimit(int messageSizeLimit);1497251962;Configure the maximum size allowed for an incoming STOMP message._Since a STOMP message can be received in multiple WebSocket messages,_buffering may be required and therefore it is necessary to know the maximum_allowed message size._<p>By default this property is set to 64K._@since 4.0.3;public void setMessageSizeLimit(int messageSizeLimit) {_		this.messageSizeLimit = messageSizeLimit__	};configure,the,maximum,size,allowed,for,an,incoming,stomp,message,since,a,stomp,message,can,be,received,in,multiple,web,socket,messages,buffering,may,be,required,and,therefore,it,is,necessary,to,know,the,maximum,allowed,message,size,p,by,default,this,property,is,set,to,64k,since,4,0,3;public,void,set,message,size,limit,int,message,size,limit,this,message,size,limit,message,size,limit
StompSubProtocolHandler -> public void setMessageSizeLimit(int messageSizeLimit);1498780456;Configure the maximum size allowed for an incoming STOMP message._Since a STOMP message can be received in multiple WebSocket messages,_buffering may be required and therefore it is necessary to know the maximum_allowed message size._<p>By default this property is set to 64K._@since 4.0.3;public void setMessageSizeLimit(int messageSizeLimit) {_		this.messageSizeLimit = messageSizeLimit__	};configure,the,maximum,size,allowed,for,an,incoming,stomp,message,since,a,stomp,message,can,be,received,in,multiple,web,socket,messages,buffering,may,be,required,and,therefore,it,is,necessary,to,know,the,maximum,allowed,message,size,p,by,default,this,property,is,set,to,64k,since,4,0,3;public,void,set,message,size,limit,int,message,size,limit,this,message,size,limit,message,size,limit
StompSubProtocolHandler -> public void setMessageSizeLimit(int messageSizeLimit);1500448076;Configure the maximum size allowed for an incoming STOMP message._Since a STOMP message can be received in multiple WebSocket messages,_buffering may be required and therefore it is necessary to know the maximum_allowed message size._<p>By default this property is set to 64K._@since 4.0.3;public void setMessageSizeLimit(int messageSizeLimit) {_		this.messageSizeLimit = messageSizeLimit__	};configure,the,maximum,size,allowed,for,an,incoming,stomp,message,since,a,stomp,message,can,be,received,in,multiple,web,socket,messages,buffering,may,be,required,and,therefore,it,is,necessary,to,know,the,maximum,allowed,message,size,p,by,default,this,property,is,set,to,64k,since,4,0,3;public,void,set,message,size,limit,int,message,size,limit,this,message,size,limit,message,size,limit
StompSubProtocolHandler -> public void setMessageSizeLimit(int messageSizeLimit);1501147952;Configure the maximum size allowed for an incoming STOMP message._Since a STOMP message can be received in multiple WebSocket messages,_buffering may be required and therefore it is necessary to know the maximum_allowed message size._<p>By default this property is set to 64K._@since 4.0.3;public void setMessageSizeLimit(int messageSizeLimit) {_		this.messageSizeLimit = messageSizeLimit__	};configure,the,maximum,size,allowed,for,an,incoming,stomp,message,since,a,stomp,message,can,be,received,in,multiple,web,socket,messages,buffering,may,be,required,and,therefore,it,is,necessary,to,know,the,maximum,allowed,message,size,p,by,default,this,property,is,set,to,64k,since,4,0,3;public,void,set,message,size,limit,int,message,size,limit,this,message,size,limit,message,size,limit
StompSubProtocolHandler -> public void setMessageSizeLimit(int messageSizeLimit);1502974979;Configure the maximum size allowed for an incoming STOMP message._Since a STOMP message can be received in multiple WebSocket messages,_buffering may be required and therefore it is necessary to know the maximum_allowed message size._<p>By default this property is set to 64K._@since 4.0.3;public void setMessageSizeLimit(int messageSizeLimit) {_		this.messageSizeLimit = messageSizeLimit__	};configure,the,maximum,size,allowed,for,an,incoming,stomp,message,since,a,stomp,message,can,be,received,in,multiple,web,socket,messages,buffering,may,be,required,and,therefore,it,is,necessary,to,know,the,maximum,allowed,message,size,p,by,default,this,property,is,set,to,64k,since,4,0,3;public,void,set,message,size,limit,int,message,size,limit,this,message,size,limit,message,size,limit
StompSubProtocolHandler -> public void setMessageSizeLimit(int messageSizeLimit);1509997270;Configure the maximum size allowed for an incoming STOMP message._Since a STOMP message can be received in multiple WebSocket messages,_buffering may be required and therefore it is necessary to know the maximum_allowed message size._<p>By default this property is set to 64K._@since 4.0.3;public void setMessageSizeLimit(int messageSizeLimit) {_		this.messageSizeLimit = messageSizeLimit__	};configure,the,maximum,size,allowed,for,an,incoming,stomp,message,since,a,stomp,message,can,be,received,in,multiple,web,socket,messages,buffering,may,be,required,and,therefore,it,is,necessary,to,know,the,maximum,allowed,message,size,p,by,default,this,property,is,set,to,64k,since,4,0,3;public,void,set,message,size,limit,int,message,size,limit,this,message,size,limit,message,size,limit
StompSubProtocolHandler -> public void setMessageSizeLimit(int messageSizeLimit);1530174524;Configure the maximum size allowed for an incoming STOMP message._Since a STOMP message can be received in multiple WebSocket messages,_buffering may be required and therefore it is necessary to know the maximum_allowed message size._<p>By default this property is set to 64K._@since 4.0.3;public void setMessageSizeLimit(int messageSizeLimit) {_		this.messageSizeLimit = messageSizeLimit__	};configure,the,maximum,size,allowed,for,an,incoming,stomp,message,since,a,stomp,message,can,be,received,in,multiple,web,socket,messages,buffering,may,be,required,and,therefore,it,is,necessary,to,know,the,maximum,allowed,message,size,p,by,default,this,property,is,set,to,64k,since,4,0,3;public,void,set,message,size,limit,int,message,size,limit,this,message,size,limit,message,size,limit
StompSubProtocolHandler -> public void setMessageSizeLimit(int messageSizeLimit);1536886762;Configure the maximum size allowed for an incoming STOMP message._Since a STOMP message can be received in multiple WebSocket messages,_buffering may be required and therefore it is necessary to know the maximum_allowed message size._<p>By default this property is set to 64K._@since 4.0.3;public void setMessageSizeLimit(int messageSizeLimit) {_		this.messageSizeLimit = messageSizeLimit__	};configure,the,maximum,size,allowed,for,an,incoming,stomp,message,since,a,stomp,message,can,be,received,in,multiple,web,socket,messages,buffering,may,be,required,and,therefore,it,is,necessary,to,know,the,maximum,allowed,message,size,p,by,default,this,property,is,set,to,64k,since,4,0,3;public,void,set,message,size,limit,int,message,size,limit,this,message,size,limit,message,size,limit
StompSubProtocolHandler -> public void setMessageSizeLimit(int messageSizeLimit);1542899558;Configure the maximum size allowed for an incoming STOMP message._Since a STOMP message can be received in multiple WebSocket messages,_buffering may be required and therefore it is necessary to know the maximum_allowed message size._<p>By default this property is set to 64K._@since 4.0.3;public void setMessageSizeLimit(int messageSizeLimit) {_		this.messageSizeLimit = messageSizeLimit__	};configure,the,maximum,size,allowed,for,an,incoming,stomp,message,since,a,stomp,message,can,be,received,in,multiple,web,socket,messages,buffering,may,be,required,and,therefore,it,is,necessary,to,know,the,maximum,allowed,message,size,p,by,default,this,property,is,set,to,64k,since,4,0,3;public,void,set,message,size,limit,int,message,size,limit,this,message,size,limit,message,size,limit
StompSubProtocolHandler -> @Deprecated 	public org.springframework.messaging.simp.user.UserSessionRegistry getUserSessionRegistry();1432316649;@deprecated as of 4.2;@Deprecated_	public org.springframework.messaging.simp.user.UserSessionRegistry getUserSessionRegistry() {_		return this.userSessionRegistry__	};deprecated,as,of,4,2;deprecated,public,org,springframework,messaging,simp,user,user,session,registry,get,user,session,registry,return,this,user,session,registry
StompSubProtocolHandler -> @Deprecated 	public org.springframework.messaging.simp.user.UserSessionRegistry getUserSessionRegistry();1432331447;@deprecated as of 4.2;@Deprecated_	public org.springframework.messaging.simp.user.UserSessionRegistry getUserSessionRegistry() {_		return this.userSessionRegistry__	};deprecated,as,of,4,2;deprecated,public,org,springframework,messaging,simp,user,user,session,registry,get,user,session,registry,return,this,user,session,registry
StompSubProtocolHandler -> @Deprecated 	public org.springframework.messaging.simp.user.UserSessionRegistry getUserSessionRegistry();1440168414;@deprecated as of 4.2;@Deprecated_	public org.springframework.messaging.simp.user.UserSessionRegistry getUserSessionRegistry() {_		return this.userSessionRegistry__	};deprecated,as,of,4,2;deprecated,public,org,springframework,messaging,simp,user,user,session,registry,get,user,session,registry,return,this,user,session,registry
StompSubProtocolHandler -> @Deprecated 	public org.springframework.messaging.simp.user.UserSessionRegistry getUserSessionRegistry();1440249342;@deprecated as of 4.2;@Deprecated_	public org.springframework.messaging.simp.user.UserSessionRegistry getUserSessionRegistry() {_		return this.userSessionRegistry__	};deprecated,as,of,4,2;deprecated,public,org,springframework,messaging,simp,user,user,session,registry,get,user,session,registry,return,this,user,session,registry
StompSubProtocolHandler -> public StompSubProtocolErrorHandler getErrorHandler();1431728285;Return the configured error handler.;public StompSubProtocolErrorHandler getErrorHandler() {_		return this.errorHandler__	};return,the,configured,error,handler;public,stomp,sub,protocol,error,handler,get,error,handler,return,this,error,handler
StompSubProtocolHandler -> public StompSubProtocolErrorHandler getErrorHandler();1432316649;Return the configured error handler.;public StompSubProtocolErrorHandler getErrorHandler() {_		return this.errorHandler__	};return,the,configured,error,handler;public,stomp,sub,protocol,error,handler,get,error,handler,return,this,error,handler
StompSubProtocolHandler -> public StompSubProtocolErrorHandler getErrorHandler();1432331447;Return the configured error handler.;public StompSubProtocolErrorHandler getErrorHandler() {_		return this.errorHandler__	};return,the,configured,error,handler;public,stomp,sub,protocol,error,handler,get,error,handler,return,this,error,handler
StompSubProtocolHandler -> public StompSubProtocolErrorHandler getErrorHandler();1440168414;Return the configured error handler.;public StompSubProtocolErrorHandler getErrorHandler() {_		return this.errorHandler__	};return,the,configured,error,handler;public,stomp,sub,protocol,error,handler,get,error,handler,return,this,error,handler
StompSubProtocolHandler -> public StompSubProtocolErrorHandler getErrorHandler();1440249342;Return the configured error handler.;public StompSubProtocolErrorHandler getErrorHandler() {_		return this.errorHandler__	};return,the,configured,error,handler;public,stomp,sub,protocol,error,handler,get,error,handler,return,this,error,handler
StompSubProtocolHandler -> public StompSubProtocolErrorHandler getErrorHandler();1467726769;Return the configured error handler.;public StompSubProtocolErrorHandler getErrorHandler() {_		return this.errorHandler__	};return,the,configured,error,handler;public,stomp,sub,protocol,error,handler,get,error,handler,return,this,error,handler
StompSubProtocolHandler -> public StompSubProtocolErrorHandler getErrorHandler();1467730834;Return the configured error handler.;public StompSubProtocolErrorHandler getErrorHandler() {_		return this.errorHandler__	};return,the,configured,error,handler;public,stomp,sub,protocol,error,handler,get,error,handler,return,this,error,handler
StompSubProtocolHandler -> public StompSubProtocolErrorHandler getErrorHandler();1472062321;Return the configured error handler.;public StompSubProtocolErrorHandler getErrorHandler() {_		return this.errorHandler__	};return,the,configured,error,handler;public,stomp,sub,protocol,error,handler,get,error,handler,return,this,error,handler
StompSubProtocolHandler -> public StompSubProtocolErrorHandler getErrorHandler();1472509879;Return the configured error handler.;public StompSubProtocolErrorHandler getErrorHandler() {_		return this.errorHandler__	};return,the,configured,error,handler;public,stomp,sub,protocol,error,handler,get,error,handler,return,this,error,handler
StompSubProtocolHandler -> public StompSubProtocolErrorHandler getErrorHandler();1476284885;Return the configured error handler.;public StompSubProtocolErrorHandler getErrorHandler() {_		return this.errorHandler__	};return,the,configured,error,handler;public,stomp,sub,protocol,error,handler,get,error,handler,return,this,error,handler
StompSubProtocolHandler -> public StompSubProtocolErrorHandler getErrorHandler();1481213680;Return the configured error handler.;public StompSubProtocolErrorHandler getErrorHandler() {_		return this.errorHandler__	};return,the,configured,error,handler;public,stomp,sub,protocol,error,handler,get,error,handler,return,this,error,handler
StompSubProtocolHandler -> public StompSubProtocolErrorHandler getErrorHandler();1481669991;Return the configured error handler.;public StompSubProtocolErrorHandler getErrorHandler() {_		return this.errorHandler__	};return,the,configured,error,handler;public,stomp,sub,protocol,error,handler,get,error,handler,return,this,error,handler
StompSubProtocolHandler -> public StompSubProtocolErrorHandler getErrorHandler();1482265068;Return the configured error handler.;public StompSubProtocolErrorHandler getErrorHandler() {_		return this.errorHandler__	};return,the,configured,error,handler;public,stomp,sub,protocol,error,handler,get,error,handler,return,this,error,handler
StompSubProtocolHandler -> public StompSubProtocolErrorHandler getErrorHandler();1495868221;Return the configured error handler.;public StompSubProtocolErrorHandler getErrorHandler() {_		return this.errorHandler__	};return,the,configured,error,handler;public,stomp,sub,protocol,error,handler,get,error,handler,return,this,error,handler
StompSubProtocolHandler -> private void sendErrorMessage(WebSocketSession session, Throwable error);1467726769;Invoked when no_{@link #setErrorHandler(StompSubProtocolErrorHandler) errorHandler}_is configured to send an ERROR frame to the client.;private void sendErrorMessage(WebSocketSession session, Throwable error) {_		StompHeaderAccessor headerAccessor = StompHeaderAccessor.create(StompCommand.ERROR)__		headerAccessor.setMessage(error.getMessage())___		byte[] bytes = this.stompEncoder.encode(headerAccessor.getMessageHeaders(), EMPTY_PAYLOAD)__		try {_			session.sendMessage(new TextMessage(bytes))__		}_		catch (Throwable ex) {_			_			logger.debug("Failed to send STOMP ERROR to client", ex)__		}_	};invoked,when,no,link,set,error,handler,stomp,sub,protocol,error,handler,error,handler,is,configured,to,send,an,error,frame,to,the,client;private,void,send,error,message,web,socket,session,session,throwable,error,stomp,header,accessor,header,accessor,stomp,header,accessor,create,stomp,command,error,header,accessor,set,message,error,get,message,byte,bytes,this,stomp,encoder,encode,header,accessor,get,message,headers,try,session,send,message,new,text,message,bytes,catch,throwable,ex,logger,debug,failed,to,send,stomp,error,to,client,ex
StompSubProtocolHandler -> private void sendErrorMessage(WebSocketSession session, Throwable error);1467730834;Invoked when no_{@link #setErrorHandler(StompSubProtocolErrorHandler) errorHandler}_is configured to send an ERROR frame to the client.;private void sendErrorMessage(WebSocketSession session, Throwable error) {_		StompHeaderAccessor headerAccessor = StompHeaderAccessor.create(StompCommand.ERROR)__		headerAccessor.setMessage(error.getMessage())___		byte[] bytes = this.stompEncoder.encode(headerAccessor.getMessageHeaders(), EMPTY_PAYLOAD)__		try {_			session.sendMessage(new TextMessage(bytes))__		}_		catch (Throwable ex) {_			_			logger.debug("Failed to send STOMP ERROR to client", ex)__		}_	};invoked,when,no,link,set,error,handler,stomp,sub,protocol,error,handler,error,handler,is,configured,to,send,an,error,frame,to,the,client;private,void,send,error,message,web,socket,session,session,throwable,error,stomp,header,accessor,header,accessor,stomp,header,accessor,create,stomp,command,error,header,accessor,set,message,error,get,message,byte,bytes,this,stomp,encoder,encode,header,accessor,get,message,headers,try,session,send,message,new,text,message,bytes,catch,throwable,ex,logger,debug,failed,to,send,stomp,error,to,client,ex
StompSubProtocolHandler -> private void sendErrorMessage(WebSocketSession session, Throwable error);1472062321;Invoked when no_{@link #setErrorHandler(StompSubProtocolErrorHandler) errorHandler}_is configured to send an ERROR frame to the client.;private void sendErrorMessage(WebSocketSession session, Throwable error) {_		StompHeaderAccessor headerAccessor = StompHeaderAccessor.create(StompCommand.ERROR)__		headerAccessor.setMessage(error.getMessage())___		byte[] bytes = this.stompEncoder.encode(headerAccessor.getMessageHeaders(), EMPTY_PAYLOAD)__		try {_			session.sendMessage(new TextMessage(bytes))__		}_		catch (Throwable ex) {_			_			logger.debug("Failed to send STOMP ERROR to client", ex)__		}_	};invoked,when,no,link,set,error,handler,stomp,sub,protocol,error,handler,error,handler,is,configured,to,send,an,error,frame,to,the,client;private,void,send,error,message,web,socket,session,session,throwable,error,stomp,header,accessor,header,accessor,stomp,header,accessor,create,stomp,command,error,header,accessor,set,message,error,get,message,byte,bytes,this,stomp,encoder,encode,header,accessor,get,message,headers,try,session,send,message,new,text,message,bytes,catch,throwable,ex,logger,debug,failed,to,send,stomp,error,to,client,ex
StompSubProtocolHandler -> private void sendErrorMessage(WebSocketSession session, Throwable error);1472509879;Invoked when no_{@link #setErrorHandler(StompSubProtocolErrorHandler) errorHandler}_is configured to send an ERROR frame to the client.;private void sendErrorMessage(WebSocketSession session, Throwable error) {_		StompHeaderAccessor headerAccessor = StompHeaderAccessor.create(StompCommand.ERROR)__		headerAccessor.setMessage(error.getMessage())___		byte[] bytes = this.stompEncoder.encode(headerAccessor.getMessageHeaders(), EMPTY_PAYLOAD)__		try {_			session.sendMessage(new TextMessage(bytes))__		}_		catch (Throwable ex) {_			_			logger.debug("Failed to send STOMP ERROR to client", ex)__		}_	};invoked,when,no,link,set,error,handler,stomp,sub,protocol,error,handler,error,handler,is,configured,to,send,an,error,frame,to,the,client;private,void,send,error,message,web,socket,session,session,throwable,error,stomp,header,accessor,header,accessor,stomp,header,accessor,create,stomp,command,error,header,accessor,set,message,error,get,message,byte,bytes,this,stomp,encoder,encode,header,accessor,get,message,headers,try,session,send,message,new,text,message,bytes,catch,throwable,ex,logger,debug,failed,to,send,stomp,error,to,client,ex
StompSubProtocolHandler -> private void sendErrorMessage(WebSocketSession session, Throwable error);1476284885;Invoked when no_{@link #setErrorHandler(StompSubProtocolErrorHandler) errorHandler}_is configured to send an ERROR frame to the client.;private void sendErrorMessage(WebSocketSession session, Throwable error) {_		StompHeaderAccessor headerAccessor = StompHeaderAccessor.create(StompCommand.ERROR)__		headerAccessor.setMessage(error.getMessage())___		byte[] bytes = this.stompEncoder.encode(headerAccessor.getMessageHeaders(), EMPTY_PAYLOAD)__		try {_			session.sendMessage(new TextMessage(bytes))__		}_		catch (Throwable ex) {_			_			logger.debug("Failed to send STOMP ERROR to client", ex)__		}_	};invoked,when,no,link,set,error,handler,stomp,sub,protocol,error,handler,error,handler,is,configured,to,send,an,error,frame,to,the,client;private,void,send,error,message,web,socket,session,session,throwable,error,stomp,header,accessor,header,accessor,stomp,header,accessor,create,stomp,command,error,header,accessor,set,message,error,get,message,byte,bytes,this,stomp,encoder,encode,header,accessor,get,message,headers,try,session,send,message,new,text,message,bytes,catch,throwable,ex,logger,debug,failed,to,send,stomp,error,to,client,ex
StompSubProtocolHandler -> private void sendErrorMessage(WebSocketSession session, Throwable error);1481213680;Invoked when no_{@link #setErrorHandler(StompSubProtocolErrorHandler) errorHandler}_is configured to send an ERROR frame to the client.;private void sendErrorMessage(WebSocketSession session, Throwable error) {_		StompHeaderAccessor headerAccessor = StompHeaderAccessor.create(StompCommand.ERROR)__		headerAccessor.setMessage(error.getMessage())___		byte[] bytes = this.stompEncoder.encode(headerAccessor.getMessageHeaders(), EMPTY_PAYLOAD)__		try {_			session.sendMessage(new TextMessage(bytes))__		}_		catch (Throwable ex) {_			_			logger.debug("Failed to send STOMP ERROR to client", ex)__		}_	};invoked,when,no,link,set,error,handler,stomp,sub,protocol,error,handler,error,handler,is,configured,to,send,an,error,frame,to,the,client;private,void,send,error,message,web,socket,session,session,throwable,error,stomp,header,accessor,header,accessor,stomp,header,accessor,create,stomp,command,error,header,accessor,set,message,error,get,message,byte,bytes,this,stomp,encoder,encode,header,accessor,get,message,headers,try,session,send,message,new,text,message,bytes,catch,throwable,ex,logger,debug,failed,to,send,stomp,error,to,client,ex
StompSubProtocolHandler -> private void sendErrorMessage(WebSocketSession session, Throwable error);1481669991;Invoked when no_{@link #setErrorHandler(StompSubProtocolErrorHandler) errorHandler}_is configured to send an ERROR frame to the client.;private void sendErrorMessage(WebSocketSession session, Throwable error) {_		StompHeaderAccessor headerAccessor = StompHeaderAccessor.create(StompCommand.ERROR)__		headerAccessor.setMessage(error.getMessage())___		byte[] bytes = this.stompEncoder.encode(headerAccessor.getMessageHeaders(), EMPTY_PAYLOAD)__		try {_			session.sendMessage(new TextMessage(bytes))__		}_		catch (Throwable ex) {_			_			logger.debug("Failed to send STOMP ERROR to client", ex)__		}_	};invoked,when,no,link,set,error,handler,stomp,sub,protocol,error,handler,error,handler,is,configured,to,send,an,error,frame,to,the,client;private,void,send,error,message,web,socket,session,session,throwable,error,stomp,header,accessor,header,accessor,stomp,header,accessor,create,stomp,command,error,header,accessor,set,message,error,get,message,byte,bytes,this,stomp,encoder,encode,header,accessor,get,message,headers,try,session,send,message,new,text,message,bytes,catch,throwable,ex,logger,debug,failed,to,send,stomp,error,to,client,ex
StompSubProtocolHandler -> private void sendErrorMessage(WebSocketSession session, Throwable error);1482265068;Invoked when no_{@link #setErrorHandler(StompSubProtocolErrorHandler) errorHandler}_is configured to send an ERROR frame to the client.;private void sendErrorMessage(WebSocketSession session, Throwable error) {_		StompHeaderAccessor headerAccessor = StompHeaderAccessor.create(StompCommand.ERROR)__		headerAccessor.setMessage(error.getMessage())___		byte[] bytes = this.stompEncoder.encode(headerAccessor.getMessageHeaders(), EMPTY_PAYLOAD)__		try {_			session.sendMessage(new TextMessage(bytes))__		}_		catch (Throwable ex) {_			_			logger.debug("Failed to send STOMP ERROR to client", ex)__		}_	};invoked,when,no,link,set,error,handler,stomp,sub,protocol,error,handler,error,handler,is,configured,to,send,an,error,frame,to,the,client;private,void,send,error,message,web,socket,session,session,throwable,error,stomp,header,accessor,header,accessor,stomp,header,accessor,create,stomp,command,error,header,accessor,set,message,error,get,message,byte,bytes,this,stomp,encoder,encode,header,accessor,get,message,headers,try,session,send,message,new,text,message,bytes,catch,throwable,ex,logger,debug,failed,to,send,stomp,error,to,client,ex
StompSubProtocolHandler -> private void sendErrorMessage(WebSocketSession session, Throwable error);1495868221;Invoked when no_{@link #setErrorHandler(StompSubProtocolErrorHandler) errorHandler}_is configured to send an ERROR frame to the client.;private void sendErrorMessage(WebSocketSession session, Throwable error) {_		StompHeaderAccessor headerAccessor = StompHeaderAccessor.create(StompCommand.ERROR)__		headerAccessor.setMessage(error.getMessage())___		byte[] bytes = this.stompEncoder.encode(headerAccessor.getMessageHeaders(), EMPTY_PAYLOAD)__		try {_			session.sendMessage(new TextMessage(bytes))__		}_		catch (Throwable ex) {_			_			logger.debug("Failed to send STOMP ERROR to client", ex)__		}_	};invoked,when,no,link,set,error,handler,stomp,sub,protocol,error,handler,error,handler,is,configured,to,send,an,error,frame,to,the,client;private,void,send,error,message,web,socket,session,session,throwable,error,stomp,header,accessor,header,accessor,stomp,header,accessor,create,stomp,command,error,header,accessor,set,message,error,get,message,byte,bytes,this,stomp,encoder,encode,header,accessor,get,message,headers,try,session,send,message,new,text,message,bytes,catch,throwable,ex,logger,debug,failed,to,send,stomp,error,to,client,ex
StompSubProtocolHandler -> private void sendErrorMessage(WebSocketSession session, Throwable error);1496837955;Invoked when no_{@link #setErrorHandler(StompSubProtocolErrorHandler) errorHandler}_is configured to send an ERROR frame to the client.;private void sendErrorMessage(WebSocketSession session, Throwable error) {_		StompHeaderAccessor headerAccessor = StompHeaderAccessor.create(StompCommand.ERROR)__		headerAccessor.setMessage(error.getMessage())___		byte[] bytes = this.stompEncoder.encode(headerAccessor.getMessageHeaders(), EMPTY_PAYLOAD)__		try {_			session.sendMessage(new TextMessage(bytes))__		}_		catch (Throwable ex) {_			_			logger.debug("Failed to send STOMP ERROR to client", ex)__		}_	};invoked,when,no,link,set,error,handler,stomp,sub,protocol,error,handler,error,handler,is,configured,to,send,an,error,frame,to,the,client;private,void,send,error,message,web,socket,session,session,throwable,error,stomp,header,accessor,header,accessor,stomp,header,accessor,create,stomp,command,error,header,accessor,set,message,error,get,message,byte,bytes,this,stomp,encoder,encode,header,accessor,get,message,headers,try,session,send,message,new,text,message,bytes,catch,throwable,ex,logger,debug,failed,to,send,stomp,error,to,client,ex
StompSubProtocolHandler -> private void sendErrorMessage(WebSocketSession session, Throwable error);1497251962;Invoked when no_{@link #setErrorHandler(StompSubProtocolErrorHandler) errorHandler}_is configured to send an ERROR frame to the client.;private void sendErrorMessage(WebSocketSession session, Throwable error) {_		StompHeaderAccessor headerAccessor = StompHeaderAccessor.create(StompCommand.ERROR)__		headerAccessor.setMessage(error.getMessage())___		byte[] bytes = this.stompEncoder.encode(headerAccessor.getMessageHeaders(), EMPTY_PAYLOAD)__		try {_			session.sendMessage(new TextMessage(bytes))__		}_		catch (Throwable ex) {_			_			logger.debug("Failed to send STOMP ERROR to client", ex)__		}_	};invoked,when,no,link,set,error,handler,stomp,sub,protocol,error,handler,error,handler,is,configured,to,send,an,error,frame,to,the,client;private,void,send,error,message,web,socket,session,session,throwable,error,stomp,header,accessor,header,accessor,stomp,header,accessor,create,stomp,command,error,header,accessor,set,message,error,get,message,byte,bytes,this,stomp,encoder,encode,header,accessor,get,message,headers,try,session,send,message,new,text,message,bytes,catch,throwable,ex,logger,debug,failed,to,send,stomp,error,to,client,ex
StompSubProtocolHandler -> private void sendErrorMessage(WebSocketSession session, Throwable error);1498780456;Invoked when no_{@link #setErrorHandler(StompSubProtocolErrorHandler) errorHandler}_is configured to send an ERROR frame to the client.;private void sendErrorMessage(WebSocketSession session, Throwable error) {_		StompHeaderAccessor headerAccessor = StompHeaderAccessor.create(StompCommand.ERROR)__		headerAccessor.setMessage(error.getMessage())___		byte[] bytes = this.stompEncoder.encode(headerAccessor.getMessageHeaders(), EMPTY_PAYLOAD)__		try {_			session.sendMessage(new TextMessage(bytes))__		}_		catch (Throwable ex) {_			_			logger.debug("Failed to send STOMP ERROR to client", ex)__		}_	};invoked,when,no,link,set,error,handler,stomp,sub,protocol,error,handler,error,handler,is,configured,to,send,an,error,frame,to,the,client;private,void,send,error,message,web,socket,session,session,throwable,error,stomp,header,accessor,header,accessor,stomp,header,accessor,create,stomp,command,error,header,accessor,set,message,error,get,message,byte,bytes,this,stomp,encoder,encode,header,accessor,get,message,headers,try,session,send,message,new,text,message,bytes,catch,throwable,ex,logger,debug,failed,to,send,stomp,error,to,client,ex
StompSubProtocolHandler -> private void sendErrorMessage(WebSocketSession session, Throwable error);1500448076;Invoked when no_{@link #setErrorHandler(StompSubProtocolErrorHandler) errorHandler}_is configured to send an ERROR frame to the client.;private void sendErrorMessage(WebSocketSession session, Throwable error) {_		StompHeaderAccessor headerAccessor = StompHeaderAccessor.create(StompCommand.ERROR)__		headerAccessor.setMessage(error.getMessage())___		byte[] bytes = this.stompEncoder.encode(headerAccessor.getMessageHeaders(), EMPTY_PAYLOAD)__		try {_			session.sendMessage(new TextMessage(bytes))__		}_		catch (Throwable ex) {_			_			logger.debug("Failed to send STOMP ERROR to client", ex)__		}_	};invoked,when,no,link,set,error,handler,stomp,sub,protocol,error,handler,error,handler,is,configured,to,send,an,error,frame,to,the,client;private,void,send,error,message,web,socket,session,session,throwable,error,stomp,header,accessor,header,accessor,stomp,header,accessor,create,stomp,command,error,header,accessor,set,message,error,get,message,byte,bytes,this,stomp,encoder,encode,header,accessor,get,message,headers,try,session,send,message,new,text,message,bytes,catch,throwable,ex,logger,debug,failed,to,send,stomp,error,to,client,ex
StompSubProtocolHandler -> private void sendErrorMessage(WebSocketSession session, Throwable error);1501147952;Invoked when no_{@link #setErrorHandler(StompSubProtocolErrorHandler) errorHandler}_is configured to send an ERROR frame to the client.;private void sendErrorMessage(WebSocketSession session, Throwable error) {_		StompHeaderAccessor headerAccessor = StompHeaderAccessor.create(StompCommand.ERROR)__		headerAccessor.setMessage(error.getMessage())___		byte[] bytes = this.stompEncoder.encode(headerAccessor.getMessageHeaders(), EMPTY_PAYLOAD)__		try {_			session.sendMessage(new TextMessage(bytes))__		}_		catch (Throwable ex) {_			_			logger.debug("Failed to send STOMP ERROR to client", ex)__		}_	};invoked,when,no,link,set,error,handler,stomp,sub,protocol,error,handler,error,handler,is,configured,to,send,an,error,frame,to,the,client;private,void,send,error,message,web,socket,session,session,throwable,error,stomp,header,accessor,header,accessor,stomp,header,accessor,create,stomp,command,error,header,accessor,set,message,error,get,message,byte,bytes,this,stomp,encoder,encode,header,accessor,get,message,headers,try,session,send,message,new,text,message,bytes,catch,throwable,ex,logger,debug,failed,to,send,stomp,error,to,client,ex
StompSubProtocolHandler -> private void sendErrorMessage(WebSocketSession session, Throwable error);1502974979;Invoked when no_{@link #setErrorHandler(StompSubProtocolErrorHandler) errorHandler}_is configured to send an ERROR frame to the client.;private void sendErrorMessage(WebSocketSession session, Throwable error) {_		StompHeaderAccessor headerAccessor = StompHeaderAccessor.create(StompCommand.ERROR)__		headerAccessor.setMessage(error.getMessage())___		byte[] bytes = this.stompEncoder.encode(headerAccessor.getMessageHeaders(), EMPTY_PAYLOAD)__		try {_			session.sendMessage(new TextMessage(bytes))__		}_		catch (Throwable ex) {_			_			logger.debug("Failed to send STOMP ERROR to client", ex)__		}_	};invoked,when,no,link,set,error,handler,stomp,sub,protocol,error,handler,error,handler,is,configured,to,send,an,error,frame,to,the,client;private,void,send,error,message,web,socket,session,session,throwable,error,stomp,header,accessor,header,accessor,stomp,header,accessor,create,stomp,command,error,header,accessor,set,message,error,get,message,byte,bytes,this,stomp,encoder,encode,header,accessor,get,message,headers,try,session,send,message,new,text,message,bytes,catch,throwable,ex,logger,debug,failed,to,send,stomp,error,to,client,ex
StompSubProtocolHandler -> private void sendErrorMessage(WebSocketSession session, Throwable error);1509997270;Invoked when no_{@link #setErrorHandler(StompSubProtocolErrorHandler) errorHandler}_is configured to send an ERROR frame to the client.;private void sendErrorMessage(WebSocketSession session, Throwable error) {_		StompHeaderAccessor headerAccessor = StompHeaderAccessor.create(StompCommand.ERROR)__		headerAccessor.setMessage(error.getMessage())___		byte[] bytes = this.stompEncoder.encode(headerAccessor.getMessageHeaders(), EMPTY_PAYLOAD)__		try {_			session.sendMessage(new TextMessage(bytes))__		}_		catch (Throwable ex) {_			_			logger.debug("Failed to send STOMP ERROR to client", ex)__		}_	};invoked,when,no,link,set,error,handler,stomp,sub,protocol,error,handler,error,handler,is,configured,to,send,an,error,frame,to,the,client;private,void,send,error,message,web,socket,session,session,throwable,error,stomp,header,accessor,header,accessor,stomp,header,accessor,create,stomp,command,error,header,accessor,set,message,error,get,message,byte,bytes,this,stomp,encoder,encode,header,accessor,get,message,headers,try,session,send,message,new,text,message,bytes,catch,throwable,ex,logger,debug,failed,to,send,stomp,error,to,client,ex
StompSubProtocolHandler -> private void sendErrorMessage(WebSocketSession session, Throwable error);1530174524;Invoked when no_{@link #setErrorHandler(StompSubProtocolErrorHandler) errorHandler}_is configured to send an ERROR frame to the client.;private void sendErrorMessage(WebSocketSession session, Throwable error) {_		StompHeaderAccessor headerAccessor = StompHeaderAccessor.create(StompCommand.ERROR)__		headerAccessor.setMessage(error.getMessage())___		byte[] bytes = this.stompEncoder.encode(headerAccessor.getMessageHeaders(), EMPTY_PAYLOAD)__		try {_			session.sendMessage(new TextMessage(bytes))__		}_		catch (Throwable ex) {_			_			logger.debug("Failed to send STOMP ERROR to client", ex)__		}_	};invoked,when,no,link,set,error,handler,stomp,sub,protocol,error,handler,error,handler,is,configured,to,send,an,error,frame,to,the,client;private,void,send,error,message,web,socket,session,session,throwable,error,stomp,header,accessor,header,accessor,stomp,header,accessor,create,stomp,command,error,header,accessor,set,message,error,get,message,byte,bytes,this,stomp,encoder,encode,header,accessor,get,message,headers,try,session,send,message,new,text,message,bytes,catch,throwable,ex,logger,debug,failed,to,send,stomp,error,to,client,ex
StompSubProtocolHandler -> private void sendErrorMessage(WebSocketSession session, Throwable error);1536886762;Invoked when no_{@link #setErrorHandler(StompSubProtocolErrorHandler) errorHandler}_is configured to send an ERROR frame to the client.;private void sendErrorMessage(WebSocketSession session, Throwable error) {_		StompHeaderAccessor headerAccessor = StompHeaderAccessor.create(StompCommand.ERROR)__		headerAccessor.setMessage(error.getMessage())___		byte[] bytes = this.stompEncoder.encode(headerAccessor.getMessageHeaders(), EMPTY_PAYLOAD)__		try {_			session.sendMessage(new TextMessage(bytes))__		}_		catch (Throwable ex) {_			_			logger.debug("Failed to send STOMP ERROR to client", ex)__		}_	};invoked,when,no,link,set,error,handler,stomp,sub,protocol,error,handler,error,handler,is,configured,to,send,an,error,frame,to,the,client;private,void,send,error,message,web,socket,session,session,throwable,error,stomp,header,accessor,header,accessor,stomp,header,accessor,create,stomp,command,error,header,accessor,set,message,error,get,message,byte,bytes,this,stomp,encoder,encode,header,accessor,get,message,headers,try,session,send,message,new,text,message,bytes,catch,throwable,ex,logger,debug,failed,to,send,stomp,error,to,client,ex
StompSubProtocolHandler -> private void sendErrorMessage(WebSocketSession session, Throwable error);1542899558;Invoked when no_{@link #setErrorHandler(StompSubProtocolErrorHandler) errorHandler}_is configured to send an ERROR frame to the client.;private void sendErrorMessage(WebSocketSession session, Throwable error) {_		StompHeaderAccessor headerAccessor = StompHeaderAccessor.create(StompCommand.ERROR)__		headerAccessor.setMessage(error.getMessage())___		byte[] bytes = this.stompEncoder.encode(headerAccessor.getMessageHeaders(), EMPTY_PAYLOAD)__		try {_			session.sendMessage(new TextMessage(bytes))__		}_		catch (Throwable ex) {_			_			logger.debug("Failed to send STOMP ERROR to client", ex)__		}_	};invoked,when,no,link,set,error,handler,stomp,sub,protocol,error,handler,error,handler,is,configured,to,send,an,error,frame,to,the,client;private,void,send,error,message,web,socket,session,session,throwable,error,stomp,header,accessor,header,accessor,stomp,header,accessor,create,stomp,command,error,header,accessor,set,message,error,get,message,byte,bytes,this,stomp,encoder,encode,header,accessor,get,message,headers,try,session,send,message,new,text,message,bytes,catch,throwable,ex,logger,debug,failed,to,send,stomp,error,to,client,ex
StompSubProtocolHandler -> @Nullable 	public MessageHeaderInitializer getHeaderInitializer();1496837955;Return the configured header initializer.;@Nullable_	public MessageHeaderInitializer getHeaderInitializer() {_		return this.headerInitializer__	};return,the,configured,header,initializer;nullable,public,message,header,initializer,get,header,initializer,return,this,header,initializer
StompSubProtocolHandler -> @Nullable 	public MessageHeaderInitializer getHeaderInitializer();1497251962;Return the configured header initializer.;@Nullable_	public MessageHeaderInitializer getHeaderInitializer() {_		return this.headerInitializer__	};return,the,configured,header,initializer;nullable,public,message,header,initializer,get,header,initializer,return,this,header,initializer
StompSubProtocolHandler -> @Nullable 	public MessageHeaderInitializer getHeaderInitializer();1498780456;Return the configured header initializer.;@Nullable_	public MessageHeaderInitializer getHeaderInitializer() {_		return this.headerInitializer__	};return,the,configured,header,initializer;nullable,public,message,header,initializer,get,header,initializer,return,this,header,initializer
StompSubProtocolHandler -> @Nullable 	public MessageHeaderInitializer getHeaderInitializer();1500448076;Return the configured header initializer.;@Nullable_	public MessageHeaderInitializer getHeaderInitializer() {_		return this.headerInitializer__	};return,the,configured,header,initializer;nullable,public,message,header,initializer,get,header,initializer,return,this,header,initializer
StompSubProtocolHandler -> @Nullable 	public MessageHeaderInitializer getHeaderInitializer();1501147952;Return the configured header initializer.;@Nullable_	public MessageHeaderInitializer getHeaderInitializer() {_		return this.headerInitializer__	};return,the,configured,header,initializer;nullable,public,message,header,initializer,get,header,initializer,return,this,header,initializer
StompSubProtocolHandler -> @Nullable 	public MessageHeaderInitializer getHeaderInitializer();1502974979;Return the configured header initializer.;@Nullable_	public MessageHeaderInitializer getHeaderInitializer() {_		return this.headerInitializer__	};return,the,configured,header,initializer;nullable,public,message,header,initializer,get,header,initializer,return,this,header,initializer
StompSubProtocolHandler -> @Nullable 	public MessageHeaderInitializer getHeaderInitializer();1509997270;Return the configured header initializer.;@Nullable_	public MessageHeaderInitializer getHeaderInitializer() {_		return this.headerInitializer__	};return,the,configured,header,initializer;nullable,public,message,header,initializer,get,header,initializer,return,this,header,initializer
StompSubProtocolHandler -> @Nullable 	public MessageHeaderInitializer getHeaderInitializer();1530174524;Return the configured header initializer.;@Nullable_	public MessageHeaderInitializer getHeaderInitializer() {_		return this.headerInitializer__	};return,the,configured,header,initializer;nullable,public,message,header,initializer,get,header,initializer,return,this,header,initializer
StompSubProtocolHandler -> @Nullable 	public MessageHeaderInitializer getHeaderInitializer();1536886762;Return the configured header initializer.;@Nullable_	public MessageHeaderInitializer getHeaderInitializer() {_		return this.headerInitializer__	};return,the,configured,header,initializer;nullable,public,message,header,initializer,get,header,initializer,return,this,header,initializer
StompSubProtocolHandler -> @Nullable 	public MessageHeaderInitializer getHeaderInitializer();1542899558;Return the configured header initializer.;@Nullable_	public MessageHeaderInitializer getHeaderInitializer() {_		return this.headerInitializer__	};return,the,configured,header,initializer;nullable,public,message,header,initializer,get,header,initializer,return,this,header,initializer
StompSubProtocolHandler -> @Override 	@SuppressWarnings("unchecked") 	public void handleMessageToClient(WebSocketSession session, Message<?> message);1440249342;Handle STOMP messages going back out to WebSocket clients.;@Override_	@SuppressWarnings("unchecked")_	public void handleMessageToClient(WebSocketSession session, Message<?> message) {_		if (!(message.getPayload() instanceof byte[])) {_			logger.error("Expected byte[] payload. Ignoring " + message + ".")__			return__		}__		StompHeaderAccessor stompAccessor = getStompHeaderAccessor(message)__		StompCommand command = stompAccessor.getCommand()___		if (StompCommand.MESSAGE.equals(command)) {_			if (stompAccessor.getSubscriptionId() == null) {_				logger.warn("No STOMP \"subscription\" header in " + message)__			}_			String origDestination = stompAccessor.getFirstNativeHeader(SimpMessageHeaderAccessor.ORIGINAL_DESTINATION)__			if (origDestination != null) {_				stompAccessor = toMutableAccessor(stompAccessor, message)__				stompAccessor.removeNativeHeader(SimpMessageHeaderAccessor.ORIGINAL_DESTINATION)__				stompAccessor.setDestination(origDestination)__			}_		}_		else if (StompCommand.CONNECTED.equals(command)) {_			this.stats.incrementConnectedCount()__			stompAccessor = afterStompSessionConnected(message, stompAccessor, session)__			if (this.eventPublisher != null && StompCommand.CONNECTED.equals(command)) {_				try {_					SimpAttributes simpAttributes = new SimpAttributes(session.getId(), session.getAttributes())__					SimpAttributesContextHolder.setAttributes(simpAttributes)__					Principal user = session.getPrincipal()__					publishEvent(new SessionConnectedEvent(this, (Message<byte[]>) message, user))__				}_				finally {_					SimpAttributesContextHolder.resetAttributes()__				}_			}_		}__		byte[] payload = (byte[]) message.getPayload()___		if (StompCommand.ERROR.equals(command) && getErrorHandler() != null) {_			Message<byte[]> errorMessage = getErrorHandler().handleErrorMessageToClient((Message<byte[]>) message)__			stompAccessor = MessageHeaderAccessor.getAccessor(errorMessage, StompHeaderAccessor.class)__			Assert.notNull(stompAccessor, "Expected STOMP headers")__			payload = errorMessage.getPayload()__		}__		sendToClient(session, stompAccessor, payload)__	};handle,stomp,messages,going,back,out,to,web,socket,clients;override,suppress,warnings,unchecked,public,void,handle,message,to,client,web,socket,session,session,message,message,if,message,get,payload,instanceof,byte,logger,error,expected,byte,payload,ignoring,message,return,stomp,header,accessor,stomp,accessor,get,stomp,header,accessor,message,stomp,command,command,stomp,accessor,get,command,if,stomp,command,message,equals,command,if,stomp,accessor,get,subscription,id,null,logger,warn,no,stomp,subscription,header,in,message,string,orig,destination,stomp,accessor,get,first,native,header,simp,message,header,accessor,if,orig,destination,null,stomp,accessor,to,mutable,accessor,stomp,accessor,message,stomp,accessor,remove,native,header,simp,message,header,accessor,stomp,accessor,set,destination,orig,destination,else,if,stomp,command,connected,equals,command,this,stats,increment,connected,count,stomp,accessor,after,stomp,session,connected,message,stomp,accessor,session,if,this,event,publisher,null,stomp,command,connected,equals,command,try,simp,attributes,simp,attributes,new,simp,attributes,session,get,id,session,get,attributes,simp,attributes,context,holder,set,attributes,simp,attributes,principal,user,session,get,principal,publish,event,new,session,connected,event,this,message,byte,message,user,finally,simp,attributes,context,holder,reset,attributes,byte,payload,byte,message,get,payload,if,stomp,command,error,equals,command,get,error,handler,null,message,byte,error,message,get,error,handler,handle,error,message,to,client,message,byte,message,stomp,accessor,message,header,accessor,get,accessor,error,message,stomp,header,accessor,class,assert,not,null,stomp,accessor,expected,stomp,headers,payload,error,message,get,payload,send,to,client,session,stomp,accessor,payload
StompSubProtocolHandler -> @Override 	@SuppressWarnings("unchecked") 	public void handleMessageToClient(WebSocketSession session, Message<?> message);1467726769;Handle STOMP messages going back out to WebSocket clients.;@Override_	@SuppressWarnings("unchecked")_	public void handleMessageToClient(WebSocketSession session, Message<?> message) {_		if (!(message.getPayload() instanceof byte[])) {_			logger.error("Expected byte[] payload. Ignoring " + message + ".")__			return__		}__		StompHeaderAccessor stompAccessor = getStompHeaderAccessor(message)__		StompCommand command = stompAccessor.getCommand()___		if (StompCommand.MESSAGE.equals(command)) {_			if (stompAccessor.getSubscriptionId() == null) {_				logger.warn("No STOMP \"subscription\" header in " + message)__			}_			String origDestination = stompAccessor.getFirstNativeHeader(SimpMessageHeaderAccessor.ORIGINAL_DESTINATION)__			if (origDestination != null) {_				stompAccessor = toMutableAccessor(stompAccessor, message)__				stompAccessor.removeNativeHeader(SimpMessageHeaderAccessor.ORIGINAL_DESTINATION)__				stompAccessor.setDestination(origDestination)__			}_		}_		else if (StompCommand.CONNECTED.equals(command)) {_			this.stats.incrementConnectedCount()__			stompAccessor = afterStompSessionConnected(message, stompAccessor, session)__			if (this.eventPublisher != null && StompCommand.CONNECTED.equals(command)) {_				try {_					SimpAttributes simpAttributes = new SimpAttributes(session.getId(), session.getAttributes())__					SimpAttributesContextHolder.setAttributes(simpAttributes)__					Principal user = session.getPrincipal()__					publishEvent(new SessionConnectedEvent(this, (Message<byte[]>) message, user))__				}_				finally {_					SimpAttributesContextHolder.resetAttributes()__				}_			}_		}__		byte[] payload = (byte[]) message.getPayload()___		if (StompCommand.ERROR.equals(command) && getErrorHandler() != null) {_			Message<byte[]> errorMessage = getErrorHandler().handleErrorMessageToClient((Message<byte[]>) message)__			stompAccessor = MessageHeaderAccessor.getAccessor(errorMessage, StompHeaderAccessor.class)__			Assert.notNull(stompAccessor, "Expected STOMP headers")__			payload = errorMessage.getPayload()__		}__		sendToClient(session, stompAccessor, payload)__	};handle,stomp,messages,going,back,out,to,web,socket,clients;override,suppress,warnings,unchecked,public,void,handle,message,to,client,web,socket,session,session,message,message,if,message,get,payload,instanceof,byte,logger,error,expected,byte,payload,ignoring,message,return,stomp,header,accessor,stomp,accessor,get,stomp,header,accessor,message,stomp,command,command,stomp,accessor,get,command,if,stomp,command,message,equals,command,if,stomp,accessor,get,subscription,id,null,logger,warn,no,stomp,subscription,header,in,message,string,orig,destination,stomp,accessor,get,first,native,header,simp,message,header,accessor,if,orig,destination,null,stomp,accessor,to,mutable,accessor,stomp,accessor,message,stomp,accessor,remove,native,header,simp,message,header,accessor,stomp,accessor,set,destination,orig,destination,else,if,stomp,command,connected,equals,command,this,stats,increment,connected,count,stomp,accessor,after,stomp,session,connected,message,stomp,accessor,session,if,this,event,publisher,null,stomp,command,connected,equals,command,try,simp,attributes,simp,attributes,new,simp,attributes,session,get,id,session,get,attributes,simp,attributes,context,holder,set,attributes,simp,attributes,principal,user,session,get,principal,publish,event,new,session,connected,event,this,message,byte,message,user,finally,simp,attributes,context,holder,reset,attributes,byte,payload,byte,message,get,payload,if,stomp,command,error,equals,command,get,error,handler,null,message,byte,error,message,get,error,handler,handle,error,message,to,client,message,byte,message,stomp,accessor,message,header,accessor,get,accessor,error,message,stomp,header,accessor,class,assert,not,null,stomp,accessor,expected,stomp,headers,payload,error,message,get,payload,send,to,client,session,stomp,accessor,payload
StompSubProtocolHandler -> @Override 	@SuppressWarnings("unchecked") 	public void handleMessageToClient(WebSocketSession session, Message<?> message);1467730834;Handle STOMP messages going back out to WebSocket clients.;@Override_	@SuppressWarnings("unchecked")_	public void handleMessageToClient(WebSocketSession session, Message<?> message) {_		if (!(message.getPayload() instanceof byte[])) {_			logger.error("Expected byte[] payload. Ignoring " + message + ".")__			return__		}__		StompHeaderAccessor stompAccessor = getStompHeaderAccessor(message)__		StompCommand command = stompAccessor.getCommand()___		if (StompCommand.MESSAGE.equals(command)) {_			if (stompAccessor.getSubscriptionId() == null) {_				logger.warn("No STOMP \"subscription\" header in " + message)__			}_			String origDestination = stompAccessor.getFirstNativeHeader(SimpMessageHeaderAccessor.ORIGINAL_DESTINATION)__			if (origDestination != null) {_				stompAccessor = toMutableAccessor(stompAccessor, message)__				stompAccessor.removeNativeHeader(SimpMessageHeaderAccessor.ORIGINAL_DESTINATION)__				stompAccessor.setDestination(origDestination)__			}_		}_		else if (StompCommand.CONNECTED.equals(command)) {_			this.stats.incrementConnectedCount()__			stompAccessor = afterStompSessionConnected(message, stompAccessor, session)__			if (this.eventPublisher != null && StompCommand.CONNECTED.equals(command)) {_				try {_					SimpAttributes simpAttributes = new SimpAttributes(session.getId(), session.getAttributes())__					SimpAttributesContextHolder.setAttributes(simpAttributes)__					Principal user = session.getPrincipal()__					publishEvent(new SessionConnectedEvent(this, (Message<byte[]>) message, user))__				}_				finally {_					SimpAttributesContextHolder.resetAttributes()__				}_			}_		}__		byte[] payload = (byte[]) message.getPayload()___		if (StompCommand.ERROR.equals(command) && getErrorHandler() != null) {_			Message<byte[]> errorMessage = getErrorHandler().handleErrorMessageToClient((Message<byte[]>) message)__			stompAccessor = MessageHeaderAccessor.getAccessor(errorMessage, StompHeaderAccessor.class)__			Assert.notNull(stompAccessor, "Expected STOMP headers")__			payload = errorMessage.getPayload()__		}__		sendToClient(session, stompAccessor, payload)__	};handle,stomp,messages,going,back,out,to,web,socket,clients;override,suppress,warnings,unchecked,public,void,handle,message,to,client,web,socket,session,session,message,message,if,message,get,payload,instanceof,byte,logger,error,expected,byte,payload,ignoring,message,return,stomp,header,accessor,stomp,accessor,get,stomp,header,accessor,message,stomp,command,command,stomp,accessor,get,command,if,stomp,command,message,equals,command,if,stomp,accessor,get,subscription,id,null,logger,warn,no,stomp,subscription,header,in,message,string,orig,destination,stomp,accessor,get,first,native,header,simp,message,header,accessor,if,orig,destination,null,stomp,accessor,to,mutable,accessor,stomp,accessor,message,stomp,accessor,remove,native,header,simp,message,header,accessor,stomp,accessor,set,destination,orig,destination,else,if,stomp,command,connected,equals,command,this,stats,increment,connected,count,stomp,accessor,after,stomp,session,connected,message,stomp,accessor,session,if,this,event,publisher,null,stomp,command,connected,equals,command,try,simp,attributes,simp,attributes,new,simp,attributes,session,get,id,session,get,attributes,simp,attributes,context,holder,set,attributes,simp,attributes,principal,user,session,get,principal,publish,event,new,session,connected,event,this,message,byte,message,user,finally,simp,attributes,context,holder,reset,attributes,byte,payload,byte,message,get,payload,if,stomp,command,error,equals,command,get,error,handler,null,message,byte,error,message,get,error,handler,handle,error,message,to,client,message,byte,message,stomp,accessor,message,header,accessor,get,accessor,error,message,stomp,header,accessor,class,assert,not,null,stomp,accessor,expected,stomp,headers,payload,error,message,get,payload,send,to,client,session,stomp,accessor,payload
StompSubProtocolHandler -> @Override 	@SuppressWarnings("unchecked") 	public void handleMessageToClient(WebSocketSession session, Message<?> message);1472062321;Handle STOMP messages going back out to WebSocket clients.;@Override_	@SuppressWarnings("unchecked")_	public void handleMessageToClient(WebSocketSession session, Message<?> message) {_		if (!(message.getPayload() instanceof byte[])) {_			if (logger.isErrorEnabled()) {_				logger.error("Expected byte[] payload. Ignoring " + message + ".")__			}_			return__		}__		StompHeaderAccessor accessor = getStompHeaderAccessor(message)__		StompCommand command = accessor.getCommand()___		if (StompCommand.MESSAGE.equals(command)) {_			if (accessor.getSubscriptionId() == null && logger.isWarnEnabled()) {_				logger.warn("No STOMP \"subscription\" header in " + message)__			}_			String origDestination = accessor.getFirstNativeHeader(SimpMessageHeaderAccessor.ORIGINAL_DESTINATION)__			if (origDestination != null) {_				accessor = toMutableAccessor(accessor, message)__				accessor.removeNativeHeader(SimpMessageHeaderAccessor.ORIGINAL_DESTINATION)__				accessor.setDestination(origDestination)__			}_		}_		else if (StompCommand.CONNECTED.equals(command)) {_			this.stats.incrementConnectedCount()__			accessor = afterStompSessionConnected(message, accessor, session)__			if (this.eventPublisher != null && StompCommand.CONNECTED.equals(command)) {_				try {_					SimpAttributes simpAttributes = new SimpAttributes(session.getId(), session.getAttributes())__					SimpAttributesContextHolder.setAttributes(simpAttributes)__					Principal user = session.getPrincipal()__					publishEvent(new SessionConnectedEvent(this, (Message<byte[]>) message, user))__				}_				finally {_					SimpAttributesContextHolder.resetAttributes()__				}_			}_		}__		byte[] payload = (byte[]) message.getPayload()__		if (StompCommand.ERROR.equals(command) && getErrorHandler() != null) {_			Message<byte[]> errorMessage = getErrorHandler().handleErrorMessageToClient((Message<byte[]>) message)__			accessor = MessageHeaderAccessor.getAccessor(errorMessage, StompHeaderAccessor.class)__			Assert.state(accessor != null, "Expected STOMP headers")__			payload = errorMessage.getPayload()__		}_		sendToClient(session, accessor, payload)__	};handle,stomp,messages,going,back,out,to,web,socket,clients;override,suppress,warnings,unchecked,public,void,handle,message,to,client,web,socket,session,session,message,message,if,message,get,payload,instanceof,byte,if,logger,is,error,enabled,logger,error,expected,byte,payload,ignoring,message,return,stomp,header,accessor,accessor,get,stomp,header,accessor,message,stomp,command,command,accessor,get,command,if,stomp,command,message,equals,command,if,accessor,get,subscription,id,null,logger,is,warn,enabled,logger,warn,no,stomp,subscription,header,in,message,string,orig,destination,accessor,get,first,native,header,simp,message,header,accessor,if,orig,destination,null,accessor,to,mutable,accessor,accessor,message,accessor,remove,native,header,simp,message,header,accessor,accessor,set,destination,orig,destination,else,if,stomp,command,connected,equals,command,this,stats,increment,connected,count,accessor,after,stomp,session,connected,message,accessor,session,if,this,event,publisher,null,stomp,command,connected,equals,command,try,simp,attributes,simp,attributes,new,simp,attributes,session,get,id,session,get,attributes,simp,attributes,context,holder,set,attributes,simp,attributes,principal,user,session,get,principal,publish,event,new,session,connected,event,this,message,byte,message,user,finally,simp,attributes,context,holder,reset,attributes,byte,payload,byte,message,get,payload,if,stomp,command,error,equals,command,get,error,handler,null,message,byte,error,message,get,error,handler,handle,error,message,to,client,message,byte,message,accessor,message,header,accessor,get,accessor,error,message,stomp,header,accessor,class,assert,state,accessor,null,expected,stomp,headers,payload,error,message,get,payload,send,to,client,session,accessor,payload
StompSubProtocolHandler -> @Override 	@SuppressWarnings("unchecked") 	public void handleMessageToClient(WebSocketSession session, Message<?> message);1472509879;Handle STOMP messages going back out to WebSocket clients.;@Override_	@SuppressWarnings("unchecked")_	public void handleMessageToClient(WebSocketSession session, Message<?> message) {_		if (!(message.getPayload() instanceof byte[])) {_			if (logger.isErrorEnabled()) {_				logger.error("Expected byte[] payload. Ignoring " + message + ".")__			}_			return__		}__		StompHeaderAccessor accessor = getStompHeaderAccessor(message)__		StompCommand command = accessor.getCommand()___		if (StompCommand.MESSAGE.equals(command)) {_			if (accessor.getSubscriptionId() == null && logger.isWarnEnabled()) {_				logger.warn("No STOMP \"subscription\" header in " + message)__			}_			String origDestination = accessor.getFirstNativeHeader(SimpMessageHeaderAccessor.ORIGINAL_DESTINATION)__			if (origDestination != null) {_				accessor = toMutableAccessor(accessor, message)__				accessor.removeNativeHeader(SimpMessageHeaderAccessor.ORIGINAL_DESTINATION)__				accessor.setDestination(origDestination)__			}_		}_		else if (StompCommand.CONNECTED.equals(command)) {_			this.stats.incrementConnectedCount()__			accessor = afterStompSessionConnected(message, accessor, session)__			if (this.eventPublisher != null && StompCommand.CONNECTED.equals(command)) {_				try {_					SimpAttributes simpAttributes = new SimpAttributes(session.getId(), session.getAttributes())__					SimpAttributesContextHolder.setAttributes(simpAttributes)__					Principal user = session.getPrincipal()__					publishEvent(new SessionConnectedEvent(this, (Message<byte[]>) message, user))__				}_				finally {_					SimpAttributesContextHolder.resetAttributes()__				}_			}_		}__		byte[] payload = (byte[]) message.getPayload()__		if (StompCommand.ERROR.equals(command) && getErrorHandler() != null) {_			Message<byte[]> errorMessage = getErrorHandler().handleErrorMessageToClient((Message<byte[]>) message)__			accessor = MessageHeaderAccessor.getAccessor(errorMessage, StompHeaderAccessor.class)__			Assert.state(accessor != null, "Expected STOMP headers")__			payload = errorMessage.getPayload()__		}_		sendToClient(session, accessor, payload)__	};handle,stomp,messages,going,back,out,to,web,socket,clients;override,suppress,warnings,unchecked,public,void,handle,message,to,client,web,socket,session,session,message,message,if,message,get,payload,instanceof,byte,if,logger,is,error,enabled,logger,error,expected,byte,payload,ignoring,message,return,stomp,header,accessor,accessor,get,stomp,header,accessor,message,stomp,command,command,accessor,get,command,if,stomp,command,message,equals,command,if,accessor,get,subscription,id,null,logger,is,warn,enabled,logger,warn,no,stomp,subscription,header,in,message,string,orig,destination,accessor,get,first,native,header,simp,message,header,accessor,if,orig,destination,null,accessor,to,mutable,accessor,accessor,message,accessor,remove,native,header,simp,message,header,accessor,accessor,set,destination,orig,destination,else,if,stomp,command,connected,equals,command,this,stats,increment,connected,count,accessor,after,stomp,session,connected,message,accessor,session,if,this,event,publisher,null,stomp,command,connected,equals,command,try,simp,attributes,simp,attributes,new,simp,attributes,session,get,id,session,get,attributes,simp,attributes,context,holder,set,attributes,simp,attributes,principal,user,session,get,principal,publish,event,new,session,connected,event,this,message,byte,message,user,finally,simp,attributes,context,holder,reset,attributes,byte,payload,byte,message,get,payload,if,stomp,command,error,equals,command,get,error,handler,null,message,byte,error,message,get,error,handler,handle,error,message,to,client,message,byte,message,accessor,message,header,accessor,get,accessor,error,message,stomp,header,accessor,class,assert,state,accessor,null,expected,stomp,headers,payload,error,message,get,payload,send,to,client,session,accessor,payload
StompSubProtocolHandler -> @Override 	@SuppressWarnings("unchecked") 	public void handleMessageToClient(WebSocketSession session, Message<?> message);1476284885;Handle STOMP messages going back out to WebSocket clients.;@Override_	@SuppressWarnings("unchecked")_	public void handleMessageToClient(WebSocketSession session, Message<?> message) {_		if (!(message.getPayload() instanceof byte[])) {_			if (logger.isErrorEnabled()) {_				logger.error("Expected byte[] payload. Ignoring " + message + ".")__			}_			return__		}__		StompHeaderAccessor accessor = getStompHeaderAccessor(message)__		StompCommand command = accessor.getCommand()___		if (StompCommand.MESSAGE.equals(command)) {_			if (accessor.getSubscriptionId() == null && logger.isWarnEnabled()) {_				logger.warn("No STOMP \"subscription\" header in " + message)__			}_			String origDestination = accessor.getFirstNativeHeader(SimpMessageHeaderAccessor.ORIGINAL_DESTINATION)__			if (origDestination != null) {_				accessor = toMutableAccessor(accessor, message)__				accessor.removeNativeHeader(SimpMessageHeaderAccessor.ORIGINAL_DESTINATION)__				accessor.setDestination(origDestination)__			}_		}_		else if (StompCommand.CONNECTED.equals(command)) {_			this.stats.incrementConnectedCount()__			accessor = afterStompSessionConnected(message, accessor, session)__			if (this.eventPublisher != null && StompCommand.CONNECTED.equals(command)) {_				try {_					SimpAttributes simpAttributes = new SimpAttributes(session.getId(), session.getAttributes())__					SimpAttributesContextHolder.setAttributes(simpAttributes)__					Principal user = session.getPrincipal()__					publishEvent(new SessionConnectedEvent(this, (Message<byte[]>) message, user))__				}_				finally {_					SimpAttributesContextHolder.resetAttributes()__				}_			}_		}__		byte[] payload = (byte[]) message.getPayload()__		if (StompCommand.ERROR.equals(command) && getErrorHandler() != null) {_			Message<byte[]> errorMessage = getErrorHandler().handleErrorMessageToClient((Message<byte[]>) message)__			accessor = MessageHeaderAccessor.getAccessor(errorMessage, StompHeaderAccessor.class)__			Assert.state(accessor != null, "Expected STOMP headers")__			payload = errorMessage.getPayload()__		}_		sendToClient(session, accessor, payload)__	};handle,stomp,messages,going,back,out,to,web,socket,clients;override,suppress,warnings,unchecked,public,void,handle,message,to,client,web,socket,session,session,message,message,if,message,get,payload,instanceof,byte,if,logger,is,error,enabled,logger,error,expected,byte,payload,ignoring,message,return,stomp,header,accessor,accessor,get,stomp,header,accessor,message,stomp,command,command,accessor,get,command,if,stomp,command,message,equals,command,if,accessor,get,subscription,id,null,logger,is,warn,enabled,logger,warn,no,stomp,subscription,header,in,message,string,orig,destination,accessor,get,first,native,header,simp,message,header,accessor,if,orig,destination,null,accessor,to,mutable,accessor,accessor,message,accessor,remove,native,header,simp,message,header,accessor,accessor,set,destination,orig,destination,else,if,stomp,command,connected,equals,command,this,stats,increment,connected,count,accessor,after,stomp,session,connected,message,accessor,session,if,this,event,publisher,null,stomp,command,connected,equals,command,try,simp,attributes,simp,attributes,new,simp,attributes,session,get,id,session,get,attributes,simp,attributes,context,holder,set,attributes,simp,attributes,principal,user,session,get,principal,publish,event,new,session,connected,event,this,message,byte,message,user,finally,simp,attributes,context,holder,reset,attributes,byte,payload,byte,message,get,payload,if,stomp,command,error,equals,command,get,error,handler,null,message,byte,error,message,get,error,handler,handle,error,message,to,client,message,byte,message,accessor,message,header,accessor,get,accessor,error,message,stomp,header,accessor,class,assert,state,accessor,null,expected,stomp,headers,payload,error,message,get,payload,send,to,client,session,accessor,payload
StompSubProtocolHandler -> @Override 	@SuppressWarnings("unchecked") 	public void handleMessageToClient(WebSocketSession session, Message<?> message);1481213680;Handle STOMP messages going back out to WebSocket clients.;@Override_	@SuppressWarnings("unchecked")_	public void handleMessageToClient(WebSocketSession session, Message<?> message) {_		if (!(message.getPayload() instanceof byte[])) {_			if (logger.isErrorEnabled()) {_				logger.error("Expected byte[] payload. Ignoring " + message + ".")__			}_			return__		}__		StompHeaderAccessor accessor = getStompHeaderAccessor(message)__		StompCommand command = accessor.getCommand()___		if (StompCommand.MESSAGE.equals(command)) {_			if (accessor.getSubscriptionId() == null && logger.isWarnEnabled()) {_				logger.warn("No STOMP \"subscription\" header in " + message)__			}_			String origDestination = accessor.getFirstNativeHeader(SimpMessageHeaderAccessor.ORIGINAL_DESTINATION)__			if (origDestination != null) {_				accessor = toMutableAccessor(accessor, message)__				accessor.removeNativeHeader(SimpMessageHeaderAccessor.ORIGINAL_DESTINATION)__				accessor.setDestination(origDestination)__			}_		}_		else if (StompCommand.CONNECTED.equals(command)) {_			this.stats.incrementConnectedCount()__			accessor = afterStompSessionConnected(message, accessor, session)__			if (this.eventPublisher != null && StompCommand.CONNECTED.equals(command)) {_				try {_					SimpAttributes simpAttributes = new SimpAttributes(session.getId(), session.getAttributes())__					SimpAttributesContextHolder.setAttributes(simpAttributes)__					Principal user = session.getPrincipal()__					publishEvent(new SessionConnectedEvent(this, (Message<byte[]>) message, user))__				}_				finally {_					SimpAttributesContextHolder.resetAttributes()__				}_			}_		}__		byte[] payload = (byte[]) message.getPayload()__		if (StompCommand.ERROR.equals(command) && getErrorHandler() != null) {_			Message<byte[]> errorMessage = getErrorHandler().handleErrorMessageToClient((Message<byte[]>) message)__			accessor = MessageHeaderAccessor.getAccessor(errorMessage, StompHeaderAccessor.class)__			Assert.state(accessor != null, "Expected STOMP headers")__			payload = errorMessage.getPayload()__		}_		sendToClient(session, accessor, payload)__	};handle,stomp,messages,going,back,out,to,web,socket,clients;override,suppress,warnings,unchecked,public,void,handle,message,to,client,web,socket,session,session,message,message,if,message,get,payload,instanceof,byte,if,logger,is,error,enabled,logger,error,expected,byte,payload,ignoring,message,return,stomp,header,accessor,accessor,get,stomp,header,accessor,message,stomp,command,command,accessor,get,command,if,stomp,command,message,equals,command,if,accessor,get,subscription,id,null,logger,is,warn,enabled,logger,warn,no,stomp,subscription,header,in,message,string,orig,destination,accessor,get,first,native,header,simp,message,header,accessor,if,orig,destination,null,accessor,to,mutable,accessor,accessor,message,accessor,remove,native,header,simp,message,header,accessor,accessor,set,destination,orig,destination,else,if,stomp,command,connected,equals,command,this,stats,increment,connected,count,accessor,after,stomp,session,connected,message,accessor,session,if,this,event,publisher,null,stomp,command,connected,equals,command,try,simp,attributes,simp,attributes,new,simp,attributes,session,get,id,session,get,attributes,simp,attributes,context,holder,set,attributes,simp,attributes,principal,user,session,get,principal,publish,event,new,session,connected,event,this,message,byte,message,user,finally,simp,attributes,context,holder,reset,attributes,byte,payload,byte,message,get,payload,if,stomp,command,error,equals,command,get,error,handler,null,message,byte,error,message,get,error,handler,handle,error,message,to,client,message,byte,message,accessor,message,header,accessor,get,accessor,error,message,stomp,header,accessor,class,assert,state,accessor,null,expected,stomp,headers,payload,error,message,get,payload,send,to,client,session,accessor,payload
StompSubProtocolHandler -> @Override 	@SuppressWarnings("unchecked") 	public void handleMessageToClient(WebSocketSession session, Message<?> message);1481669991;Handle STOMP messages going back out to WebSocket clients.;@Override_	@SuppressWarnings("unchecked")_	public void handleMessageToClient(WebSocketSession session, Message<?> message) {_		if (!(message.getPayload() instanceof byte[])) {_			if (logger.isErrorEnabled()) {_				logger.error("Expected byte[] payload. Ignoring " + message + ".")__			}_			return__		}__		StompHeaderAccessor accessor = getStompHeaderAccessor(message)__		StompCommand command = accessor.getCommand()___		if (StompCommand.MESSAGE.equals(command)) {_			if (accessor.getSubscriptionId() == null && logger.isWarnEnabled()) {_				logger.warn("No STOMP \"subscription\" header in " + message)__			}_			String origDestination = accessor.getFirstNativeHeader(SimpMessageHeaderAccessor.ORIGINAL_DESTINATION)__			if (origDestination != null) {_				accessor = toMutableAccessor(accessor, message)__				accessor.removeNativeHeader(SimpMessageHeaderAccessor.ORIGINAL_DESTINATION)__				accessor.setDestination(origDestination)__			}_		}_		else if (StompCommand.CONNECTED.equals(command)) {_			this.stats.incrementConnectedCount()__			accessor = afterStompSessionConnected(message, accessor, session)__			if (this.eventPublisher != null && StompCommand.CONNECTED.equals(command)) {_				try {_					SimpAttributes simpAttributes = new SimpAttributes(session.getId(), session.getAttributes())__					SimpAttributesContextHolder.setAttributes(simpAttributes)__					Principal user = getUser(session)__					publishEvent(new SessionConnectedEvent(this, (Message<byte[]>) message, user))__				}_				finally {_					SimpAttributesContextHolder.resetAttributes()__				}_			}_		}__		byte[] payload = (byte[]) message.getPayload()__		if (StompCommand.ERROR.equals(command) && getErrorHandler() != null) {_			Message<byte[]> errorMessage = getErrorHandler().handleErrorMessageToClient((Message<byte[]>) message)__			accessor = MessageHeaderAccessor.getAccessor(errorMessage, StompHeaderAccessor.class)__			Assert.state(accessor != null, "Expected STOMP headers")__			payload = errorMessage.getPayload()__		}_		sendToClient(session, accessor, payload)__	};handle,stomp,messages,going,back,out,to,web,socket,clients;override,suppress,warnings,unchecked,public,void,handle,message,to,client,web,socket,session,session,message,message,if,message,get,payload,instanceof,byte,if,logger,is,error,enabled,logger,error,expected,byte,payload,ignoring,message,return,stomp,header,accessor,accessor,get,stomp,header,accessor,message,stomp,command,command,accessor,get,command,if,stomp,command,message,equals,command,if,accessor,get,subscription,id,null,logger,is,warn,enabled,logger,warn,no,stomp,subscription,header,in,message,string,orig,destination,accessor,get,first,native,header,simp,message,header,accessor,if,orig,destination,null,accessor,to,mutable,accessor,accessor,message,accessor,remove,native,header,simp,message,header,accessor,accessor,set,destination,orig,destination,else,if,stomp,command,connected,equals,command,this,stats,increment,connected,count,accessor,after,stomp,session,connected,message,accessor,session,if,this,event,publisher,null,stomp,command,connected,equals,command,try,simp,attributes,simp,attributes,new,simp,attributes,session,get,id,session,get,attributes,simp,attributes,context,holder,set,attributes,simp,attributes,principal,user,get,user,session,publish,event,new,session,connected,event,this,message,byte,message,user,finally,simp,attributes,context,holder,reset,attributes,byte,payload,byte,message,get,payload,if,stomp,command,error,equals,command,get,error,handler,null,message,byte,error,message,get,error,handler,handle,error,message,to,client,message,byte,message,accessor,message,header,accessor,get,accessor,error,message,stomp,header,accessor,class,assert,state,accessor,null,expected,stomp,headers,payload,error,message,get,payload,send,to,client,session,accessor,payload
StompSubProtocolHandler -> @Override 	@SuppressWarnings("unchecked") 	public void handleMessageToClient(WebSocketSession session, Message<?> message);1482265068;Handle STOMP messages going back out to WebSocket clients.;@Override_	@SuppressWarnings("unchecked")_	public void handleMessageToClient(WebSocketSession session, Message<?> message) {_		if (!(message.getPayload() instanceof byte[])) {_			if (logger.isErrorEnabled()) {_				logger.error("Expected byte[] payload. Ignoring " + message + ".")__			}_			return__		}__		StompHeaderAccessor accessor = getStompHeaderAccessor(message)__		StompCommand command = accessor.getCommand()___		if (StompCommand.MESSAGE.equals(command)) {_			if (accessor.getSubscriptionId() == null && logger.isWarnEnabled()) {_				logger.warn("No STOMP \"subscription\" header in " + message)__			}_			String origDestination = accessor.getFirstNativeHeader(SimpMessageHeaderAccessor.ORIGINAL_DESTINATION)__			if (origDestination != null) {_				accessor = toMutableAccessor(accessor, message)__				accessor.removeNativeHeader(SimpMessageHeaderAccessor.ORIGINAL_DESTINATION)__				accessor.setDestination(origDestination)__			}_		}_		else if (StompCommand.CONNECTED.equals(command)) {_			this.stats.incrementConnectedCount()__			accessor = afterStompSessionConnected(message, accessor, session)__			if (this.eventPublisher != null && StompCommand.CONNECTED.equals(command)) {_				try {_					SimpAttributes simpAttributes = new SimpAttributes(session.getId(), session.getAttributes())__					SimpAttributesContextHolder.setAttributes(simpAttributes)__					Principal user = getUser(session)__					publishEvent(new SessionConnectedEvent(this, (Message<byte[]>) message, user))__				}_				finally {_					SimpAttributesContextHolder.resetAttributes()__				}_			}_		}__		byte[] payload = (byte[]) message.getPayload()__		if (StompCommand.ERROR.equals(command) && getErrorHandler() != null) {_			Message<byte[]> errorMessage = getErrorHandler().handleErrorMessageToClient((Message<byte[]>) message)__			accessor = MessageHeaderAccessor.getAccessor(errorMessage, StompHeaderAccessor.class)__			Assert.state(accessor != null, "Expected STOMP headers")__			payload = errorMessage.getPayload()__		}_		sendToClient(session, accessor, payload)__	};handle,stomp,messages,going,back,out,to,web,socket,clients;override,suppress,warnings,unchecked,public,void,handle,message,to,client,web,socket,session,session,message,message,if,message,get,payload,instanceof,byte,if,logger,is,error,enabled,logger,error,expected,byte,payload,ignoring,message,return,stomp,header,accessor,accessor,get,stomp,header,accessor,message,stomp,command,command,accessor,get,command,if,stomp,command,message,equals,command,if,accessor,get,subscription,id,null,logger,is,warn,enabled,logger,warn,no,stomp,subscription,header,in,message,string,orig,destination,accessor,get,first,native,header,simp,message,header,accessor,if,orig,destination,null,accessor,to,mutable,accessor,accessor,message,accessor,remove,native,header,simp,message,header,accessor,accessor,set,destination,orig,destination,else,if,stomp,command,connected,equals,command,this,stats,increment,connected,count,accessor,after,stomp,session,connected,message,accessor,session,if,this,event,publisher,null,stomp,command,connected,equals,command,try,simp,attributes,simp,attributes,new,simp,attributes,session,get,id,session,get,attributes,simp,attributes,context,holder,set,attributes,simp,attributes,principal,user,get,user,session,publish,event,new,session,connected,event,this,message,byte,message,user,finally,simp,attributes,context,holder,reset,attributes,byte,payload,byte,message,get,payload,if,stomp,command,error,equals,command,get,error,handler,null,message,byte,error,message,get,error,handler,handle,error,message,to,client,message,byte,message,accessor,message,header,accessor,get,accessor,error,message,stomp,header,accessor,class,assert,state,accessor,null,expected,stomp,headers,payload,error,message,get,payload,send,to,client,session,accessor,payload
StompSubProtocolHandler -> @Override 	@SuppressWarnings("unchecked") 	public void handleMessageToClient(WebSocketSession session, Message<?> message);1495868221;Handle STOMP messages going back out to WebSocket clients.;@Override_	@SuppressWarnings("unchecked")_	public void handleMessageToClient(WebSocketSession session, Message<?> message) {_		if (!(message.getPayload() instanceof byte[])) {_			if (logger.isErrorEnabled()) {_				logger.error("Expected byte[] payload. Ignoring " + message + ".")__			}_			return__		}__		StompHeaderAccessor accessor = getStompHeaderAccessor(message)__		StompCommand command = accessor.getCommand()___		if (StompCommand.MESSAGE.equals(command)) {_			if (accessor.getSubscriptionId() == null && logger.isWarnEnabled()) {_				logger.warn("No STOMP \"subscription\" header in " + message)__			}_			String origDestination = accessor.getFirstNativeHeader(SimpMessageHeaderAccessor.ORIGINAL_DESTINATION)__			if (origDestination != null) {_				accessor = toMutableAccessor(accessor, message)__				accessor.removeNativeHeader(SimpMessageHeaderAccessor.ORIGINAL_DESTINATION)__				accessor.setDestination(origDestination)__			}_		}_		else if (StompCommand.CONNECTED.equals(command)) {_			this.stats.incrementConnectedCount()__			accessor = afterStompSessionConnected(message, accessor, session)__			if (this.eventPublisher != null && StompCommand.CONNECTED.equals(command)) {_				try {_					SimpAttributes simpAttributes = new SimpAttributes(session.getId(), session.getAttributes())__					SimpAttributesContextHolder.setAttributes(simpAttributes)__					Principal user = getUser(session)__					publishEvent(new SessionConnectedEvent(this, (Message<byte[]>) message, user))__				}_				finally {_					SimpAttributesContextHolder.resetAttributes()__				}_			}_		}__		byte[] payload = (byte[]) message.getPayload()__		if (StompCommand.ERROR.equals(command) && getErrorHandler() != null) {_			Message<byte[]> errorMessage = getErrorHandler().handleErrorMessageToClient((Message<byte[]>) message)__			accessor = MessageHeaderAccessor.getAccessor(errorMessage, StompHeaderAccessor.class)__			Assert.state(accessor != null, "Expected STOMP headers")__			payload = errorMessage.getPayload()__		}_		sendToClient(session, accessor, payload)__	};handle,stomp,messages,going,back,out,to,web,socket,clients;override,suppress,warnings,unchecked,public,void,handle,message,to,client,web,socket,session,session,message,message,if,message,get,payload,instanceof,byte,if,logger,is,error,enabled,logger,error,expected,byte,payload,ignoring,message,return,stomp,header,accessor,accessor,get,stomp,header,accessor,message,stomp,command,command,accessor,get,command,if,stomp,command,message,equals,command,if,accessor,get,subscription,id,null,logger,is,warn,enabled,logger,warn,no,stomp,subscription,header,in,message,string,orig,destination,accessor,get,first,native,header,simp,message,header,accessor,if,orig,destination,null,accessor,to,mutable,accessor,accessor,message,accessor,remove,native,header,simp,message,header,accessor,accessor,set,destination,orig,destination,else,if,stomp,command,connected,equals,command,this,stats,increment,connected,count,accessor,after,stomp,session,connected,message,accessor,session,if,this,event,publisher,null,stomp,command,connected,equals,command,try,simp,attributes,simp,attributes,new,simp,attributes,session,get,id,session,get,attributes,simp,attributes,context,holder,set,attributes,simp,attributes,principal,user,get,user,session,publish,event,new,session,connected,event,this,message,byte,message,user,finally,simp,attributes,context,holder,reset,attributes,byte,payload,byte,message,get,payload,if,stomp,command,error,equals,command,get,error,handler,null,message,byte,error,message,get,error,handler,handle,error,message,to,client,message,byte,message,accessor,message,header,accessor,get,accessor,error,message,stomp,header,accessor,class,assert,state,accessor,null,expected,stomp,headers,payload,error,message,get,payload,send,to,client,session,accessor,payload
StompSubProtocolHandler -> @Override 	@SuppressWarnings("unchecked") 	public void handleMessageToClient(WebSocketSession session, Message<?> message);1496837955;Handle STOMP messages going back out to WebSocket clients.;@Override_	@SuppressWarnings("unchecked")_	public void handleMessageToClient(WebSocketSession session, Message<?> message) {_		if (!(message.getPayload() instanceof byte[])) {_			if (logger.isErrorEnabled()) {_				logger.error("Expected byte[] payload. Ignoring " + message + ".")__			}_			return__		}__		StompHeaderAccessor accessor = getStompHeaderAccessor(message)__		StompCommand command = accessor.getCommand()___		if (StompCommand.MESSAGE.equals(command)) {_			if (accessor.getSubscriptionId() == null && logger.isWarnEnabled()) {_				logger.warn("No STOMP \"subscription\" header in " + message)__			}_			String origDestination = accessor.getFirstNativeHeader(SimpMessageHeaderAccessor.ORIGINAL_DESTINATION)__			if (origDestination != null) {_				accessor = toMutableAccessor(accessor, message)__				accessor.removeNativeHeader(SimpMessageHeaderAccessor.ORIGINAL_DESTINATION)__				accessor.setDestination(origDestination)__			}_		}_		else if (StompCommand.CONNECTED.equals(command)) {_			this.stats.incrementConnectedCount()__			accessor = afterStompSessionConnected(message, accessor, session)__			if (this.eventPublisher != null && StompCommand.CONNECTED.equals(command)) {_				try {_					SimpAttributes simpAttributes = new SimpAttributes(session.getId(), session.getAttributes())__					SimpAttributesContextHolder.setAttributes(simpAttributes)__					Principal user = getUser(session)__					publishEvent(new SessionConnectedEvent(this, (Message<byte[]>) message, user))__				}_				finally {_					SimpAttributesContextHolder.resetAttributes()__				}_			}_		}__		byte[] payload = (byte[]) message.getPayload()__		if (StompCommand.ERROR.equals(command) && getErrorHandler() != null) {_			Message<byte[]> errorMessage = getErrorHandler().handleErrorMessageToClient((Message<byte[]>) message)__			if (errorMessage != null) {_				accessor = MessageHeaderAccessor.getAccessor(errorMessage, StompHeaderAccessor.class)__				Assert.state(accessor != null, "No StompHeaderAccessor")__				payload = errorMessage.getPayload()__			}_		}_		sendToClient(session, accessor, payload)__	};handle,stomp,messages,going,back,out,to,web,socket,clients;override,suppress,warnings,unchecked,public,void,handle,message,to,client,web,socket,session,session,message,message,if,message,get,payload,instanceof,byte,if,logger,is,error,enabled,logger,error,expected,byte,payload,ignoring,message,return,stomp,header,accessor,accessor,get,stomp,header,accessor,message,stomp,command,command,accessor,get,command,if,stomp,command,message,equals,command,if,accessor,get,subscription,id,null,logger,is,warn,enabled,logger,warn,no,stomp,subscription,header,in,message,string,orig,destination,accessor,get,first,native,header,simp,message,header,accessor,if,orig,destination,null,accessor,to,mutable,accessor,accessor,message,accessor,remove,native,header,simp,message,header,accessor,accessor,set,destination,orig,destination,else,if,stomp,command,connected,equals,command,this,stats,increment,connected,count,accessor,after,stomp,session,connected,message,accessor,session,if,this,event,publisher,null,stomp,command,connected,equals,command,try,simp,attributes,simp,attributes,new,simp,attributes,session,get,id,session,get,attributes,simp,attributes,context,holder,set,attributes,simp,attributes,principal,user,get,user,session,publish,event,new,session,connected,event,this,message,byte,message,user,finally,simp,attributes,context,holder,reset,attributes,byte,payload,byte,message,get,payload,if,stomp,command,error,equals,command,get,error,handler,null,message,byte,error,message,get,error,handler,handle,error,message,to,client,message,byte,message,if,error,message,null,accessor,message,header,accessor,get,accessor,error,message,stomp,header,accessor,class,assert,state,accessor,null,no,stomp,header,accessor,payload,error,message,get,payload,send,to,client,session,accessor,payload
StompSubProtocolHandler -> @Override 	@SuppressWarnings("unchecked") 	public void handleMessageToClient(WebSocketSession session, Message<?> message);1497251962;Handle STOMP messages going back out to WebSocket clients.;@Override_	@SuppressWarnings("unchecked")_	public void handleMessageToClient(WebSocketSession session, Message<?> message) {_		if (!(message.getPayload() instanceof byte[])) {_			if (logger.isErrorEnabled()) {_				logger.error("Expected byte[] payload. Ignoring " + message + ".")__			}_			return__		}__		StompHeaderAccessor accessor = getStompHeaderAccessor(message)__		StompCommand command = accessor.getCommand()___		if (StompCommand.MESSAGE.equals(command)) {_			if (accessor.getSubscriptionId() == null && logger.isWarnEnabled()) {_				logger.warn("No STOMP \"subscription\" header in " + message)__			}_			String origDestination = accessor.getFirstNativeHeader(SimpMessageHeaderAccessor.ORIGINAL_DESTINATION)__			if (origDestination != null) {_				accessor = toMutableAccessor(accessor, message)__				accessor.removeNativeHeader(SimpMessageHeaderAccessor.ORIGINAL_DESTINATION)__				accessor.setDestination(origDestination)__			}_		}_		else if (StompCommand.CONNECTED.equals(command)) {_			this.stats.incrementConnectedCount()__			accessor = afterStompSessionConnected(message, accessor, session)__			if (this.eventPublisher != null && StompCommand.CONNECTED.equals(command)) {_				try {_					SimpAttributes simpAttributes = new SimpAttributes(session.getId(), session.getAttributes())__					SimpAttributesContextHolder.setAttributes(simpAttributes)__					Principal user = getUser(session)__					publishEvent(new SessionConnectedEvent(this, (Message<byte[]>) message, user))__				}_				finally {_					SimpAttributesContextHolder.resetAttributes()__				}_			}_		}__		byte[] payload = (byte[]) message.getPayload()__		if (StompCommand.ERROR.equals(command) && getErrorHandler() != null) {_			Message<byte[]> errorMessage = getErrorHandler().handleErrorMessageToClient((Message<byte[]>) message)__			if (errorMessage != null) {_				accessor = MessageHeaderAccessor.getAccessor(errorMessage, StompHeaderAccessor.class)__				Assert.state(accessor != null, "No StompHeaderAccessor")__				payload = errorMessage.getPayload()__			}_		}_		sendToClient(session, accessor, payload)__	};handle,stomp,messages,going,back,out,to,web,socket,clients;override,suppress,warnings,unchecked,public,void,handle,message,to,client,web,socket,session,session,message,message,if,message,get,payload,instanceof,byte,if,logger,is,error,enabled,logger,error,expected,byte,payload,ignoring,message,return,stomp,header,accessor,accessor,get,stomp,header,accessor,message,stomp,command,command,accessor,get,command,if,stomp,command,message,equals,command,if,accessor,get,subscription,id,null,logger,is,warn,enabled,logger,warn,no,stomp,subscription,header,in,message,string,orig,destination,accessor,get,first,native,header,simp,message,header,accessor,if,orig,destination,null,accessor,to,mutable,accessor,accessor,message,accessor,remove,native,header,simp,message,header,accessor,accessor,set,destination,orig,destination,else,if,stomp,command,connected,equals,command,this,stats,increment,connected,count,accessor,after,stomp,session,connected,message,accessor,session,if,this,event,publisher,null,stomp,command,connected,equals,command,try,simp,attributes,simp,attributes,new,simp,attributes,session,get,id,session,get,attributes,simp,attributes,context,holder,set,attributes,simp,attributes,principal,user,get,user,session,publish,event,new,session,connected,event,this,message,byte,message,user,finally,simp,attributes,context,holder,reset,attributes,byte,payload,byte,message,get,payload,if,stomp,command,error,equals,command,get,error,handler,null,message,byte,error,message,get,error,handler,handle,error,message,to,client,message,byte,message,if,error,message,null,accessor,message,header,accessor,get,accessor,error,message,stomp,header,accessor,class,assert,state,accessor,null,no,stomp,header,accessor,payload,error,message,get,payload,send,to,client,session,accessor,payload
StompSubProtocolHandler -> @Override 	@SuppressWarnings("unchecked") 	public void handleMessageToClient(WebSocketSession session, Message<?> message);1498780456;Handle STOMP messages going back out to WebSocket clients.;@Override_	@SuppressWarnings("unchecked")_	public void handleMessageToClient(WebSocketSession session, Message<?> message) {_		if (!(message.getPayload() instanceof byte[])) {_			if (logger.isErrorEnabled()) {_				logger.error("Expected byte[] payload. Ignoring " + message + ".")__			}_			return__		}__		StompHeaderAccessor accessor = getStompHeaderAccessor(message)__		StompCommand command = accessor.getCommand()___		if (StompCommand.MESSAGE.equals(command)) {_			if (accessor.getSubscriptionId() == null && logger.isWarnEnabled()) {_				logger.warn("No STOMP \"subscription\" header in " + message)__			}_			String origDestination = accessor.getFirstNativeHeader(SimpMessageHeaderAccessor.ORIGINAL_DESTINATION)__			if (origDestination != null) {_				accessor = toMutableAccessor(accessor, message)__				accessor.removeNativeHeader(SimpMessageHeaderAccessor.ORIGINAL_DESTINATION)__				accessor.setDestination(origDestination)__			}_		}_		else if (StompCommand.CONNECTED.equals(command)) {_			this.stats.incrementConnectedCount()__			accessor = afterStompSessionConnected(message, accessor, session)__			if (this.eventPublisher != null && StompCommand.CONNECTED.equals(command)) {_				try {_					SimpAttributes simpAttributes = new SimpAttributes(session.getId(), session.getAttributes())__					SimpAttributesContextHolder.setAttributes(simpAttributes)__					Principal user = getUser(session)__					publishEvent(this.eventPublisher, new SessionConnectedEvent(this, (Message<byte[]>) message, user))__				}_				finally {_					SimpAttributesContextHolder.resetAttributes()__				}_			}_		}__		byte[] payload = (byte[]) message.getPayload()__		if (StompCommand.ERROR.equals(command) && getErrorHandler() != null) {_			Message<byte[]> errorMessage = getErrorHandler().handleErrorMessageToClient((Message<byte[]>) message)__			if (errorMessage != null) {_				accessor = MessageHeaderAccessor.getAccessor(errorMessage, StompHeaderAccessor.class)__				Assert.state(accessor != null, "No StompHeaderAccessor")__				payload = errorMessage.getPayload()__			}_		}_		sendToClient(session, accessor, payload)__	};handle,stomp,messages,going,back,out,to,web,socket,clients;override,suppress,warnings,unchecked,public,void,handle,message,to,client,web,socket,session,session,message,message,if,message,get,payload,instanceof,byte,if,logger,is,error,enabled,logger,error,expected,byte,payload,ignoring,message,return,stomp,header,accessor,accessor,get,stomp,header,accessor,message,stomp,command,command,accessor,get,command,if,stomp,command,message,equals,command,if,accessor,get,subscription,id,null,logger,is,warn,enabled,logger,warn,no,stomp,subscription,header,in,message,string,orig,destination,accessor,get,first,native,header,simp,message,header,accessor,if,orig,destination,null,accessor,to,mutable,accessor,accessor,message,accessor,remove,native,header,simp,message,header,accessor,accessor,set,destination,orig,destination,else,if,stomp,command,connected,equals,command,this,stats,increment,connected,count,accessor,after,stomp,session,connected,message,accessor,session,if,this,event,publisher,null,stomp,command,connected,equals,command,try,simp,attributes,simp,attributes,new,simp,attributes,session,get,id,session,get,attributes,simp,attributes,context,holder,set,attributes,simp,attributes,principal,user,get,user,session,publish,event,this,event,publisher,new,session,connected,event,this,message,byte,message,user,finally,simp,attributes,context,holder,reset,attributes,byte,payload,byte,message,get,payload,if,stomp,command,error,equals,command,get,error,handler,null,message,byte,error,message,get,error,handler,handle,error,message,to,client,message,byte,message,if,error,message,null,accessor,message,header,accessor,get,accessor,error,message,stomp,header,accessor,class,assert,state,accessor,null,no,stomp,header,accessor,payload,error,message,get,payload,send,to,client,session,accessor,payload
StompSubProtocolHandler -> @Override 	@SuppressWarnings("unchecked") 	public void handleMessageToClient(WebSocketSession session, Message<?> message);1500448076;Handle STOMP messages going back out to WebSocket clients.;@Override_	@SuppressWarnings("unchecked")_	public void handleMessageToClient(WebSocketSession session, Message<?> message) {_		if (!(message.getPayload() instanceof byte[])) {_			if (logger.isErrorEnabled()) {_				logger.error("Expected byte[] payload. Ignoring " + message + ".")__			}_			return__		}__		StompHeaderAccessor accessor = getStompHeaderAccessor(message)__		StompCommand command = accessor.getCommand()___		if (StompCommand.MESSAGE.equals(command)) {_			if (accessor.getSubscriptionId() == null && logger.isWarnEnabled()) {_				logger.warn("No STOMP \"subscription\" header in " + message)__			}_			String origDestination = accessor.getFirstNativeHeader(SimpMessageHeaderAccessor.ORIGINAL_DESTINATION)__			if (origDestination != null) {_				accessor = toMutableAccessor(accessor, message)__				accessor.removeNativeHeader(SimpMessageHeaderAccessor.ORIGINAL_DESTINATION)__				accessor.setDestination(origDestination)__			}_		}_		else if (StompCommand.CONNECTED.equals(command)) {_			this.stats.incrementConnectedCount()__			accessor = afterStompSessionConnected(message, accessor, session)__			if (this.eventPublisher != null && StompCommand.CONNECTED.equals(command)) {_				try {_					SimpAttributes simpAttributes = new SimpAttributes(session.getId(), session.getAttributes())__					SimpAttributesContextHolder.setAttributes(simpAttributes)__					Principal user = getUser(session)__					publishEvent(this.eventPublisher, new SessionConnectedEvent(this, (Message<byte[]>) message, user))__				}_				finally {_					SimpAttributesContextHolder.resetAttributes()__				}_			}_		}__		byte[] payload = (byte[]) message.getPayload()__		if (StompCommand.ERROR.equals(command) && getErrorHandler() != null) {_			Message<byte[]> errorMessage = getErrorHandler().handleErrorMessageToClient((Message<byte[]>) message)__			if (errorMessage != null) {_				accessor = MessageHeaderAccessor.getAccessor(errorMessage, StompHeaderAccessor.class)__				Assert.state(accessor != null, "No StompHeaderAccessor")__				payload = errorMessage.getPayload()__			}_		}_		sendToClient(session, accessor, payload)__	};handle,stomp,messages,going,back,out,to,web,socket,clients;override,suppress,warnings,unchecked,public,void,handle,message,to,client,web,socket,session,session,message,message,if,message,get,payload,instanceof,byte,if,logger,is,error,enabled,logger,error,expected,byte,payload,ignoring,message,return,stomp,header,accessor,accessor,get,stomp,header,accessor,message,stomp,command,command,accessor,get,command,if,stomp,command,message,equals,command,if,accessor,get,subscription,id,null,logger,is,warn,enabled,logger,warn,no,stomp,subscription,header,in,message,string,orig,destination,accessor,get,first,native,header,simp,message,header,accessor,if,orig,destination,null,accessor,to,mutable,accessor,accessor,message,accessor,remove,native,header,simp,message,header,accessor,accessor,set,destination,orig,destination,else,if,stomp,command,connected,equals,command,this,stats,increment,connected,count,accessor,after,stomp,session,connected,message,accessor,session,if,this,event,publisher,null,stomp,command,connected,equals,command,try,simp,attributes,simp,attributes,new,simp,attributes,session,get,id,session,get,attributes,simp,attributes,context,holder,set,attributes,simp,attributes,principal,user,get,user,session,publish,event,this,event,publisher,new,session,connected,event,this,message,byte,message,user,finally,simp,attributes,context,holder,reset,attributes,byte,payload,byte,message,get,payload,if,stomp,command,error,equals,command,get,error,handler,null,message,byte,error,message,get,error,handler,handle,error,message,to,client,message,byte,message,if,error,message,null,accessor,message,header,accessor,get,accessor,error,message,stomp,header,accessor,class,assert,state,accessor,null,no,stomp,header,accessor,payload,error,message,get,payload,send,to,client,session,accessor,payload
StompSubProtocolHandler -> @Override 	@SuppressWarnings("unchecked") 	public void handleMessageToClient(WebSocketSession session, Message<?> message);1501147952;Handle STOMP messages going back out to WebSocket clients.;@Override_	@SuppressWarnings("unchecked")_	public void handleMessageToClient(WebSocketSession session, Message<?> message) {_		if (!(message.getPayload() instanceof byte[])) {_			if (logger.isErrorEnabled()) {_				logger.error("Expected byte[] payload. Ignoring " + message + ".")__			}_			return__		}__		StompHeaderAccessor accessor = getStompHeaderAccessor(message)__		StompCommand command = accessor.getCommand()___		if (StompCommand.MESSAGE.equals(command)) {_			if (accessor.getSubscriptionId() == null && logger.isWarnEnabled()) {_				logger.warn("No STOMP \"subscription\" header in " + message)__			}_			String origDestination = accessor.getFirstNativeHeader(SimpMessageHeaderAccessor.ORIGINAL_DESTINATION)__			if (origDestination != null) {_				accessor = toMutableAccessor(accessor, message)__				accessor.removeNativeHeader(SimpMessageHeaderAccessor.ORIGINAL_DESTINATION)__				accessor.setDestination(origDestination)__			}_		}_		else if (StompCommand.CONNECTED.equals(command)) {_			this.stats.incrementConnectedCount()__			accessor = afterStompSessionConnected(message, accessor, session)__			if (this.eventPublisher != null && StompCommand.CONNECTED.equals(command)) {_				try {_					SimpAttributes simpAttributes = new SimpAttributes(session.getId(), session.getAttributes())__					SimpAttributesContextHolder.setAttributes(simpAttributes)__					Principal user = getUser(session)__					publishEvent(this.eventPublisher, new SessionConnectedEvent(this, (Message<byte[]>) message, user))__				}_				finally {_					SimpAttributesContextHolder.resetAttributes()__				}_			}_		}__		byte[] payload = (byte[]) message.getPayload()__		if (StompCommand.ERROR.equals(command) && getErrorHandler() != null) {_			Message<byte[]> errorMessage = getErrorHandler().handleErrorMessageToClient((Message<byte[]>) message)__			if (errorMessage != null) {_				accessor = MessageHeaderAccessor.getAccessor(errorMessage, StompHeaderAccessor.class)__				Assert.state(accessor != null, "No StompHeaderAccessor")__				payload = errorMessage.getPayload()__			}_		}_		sendToClient(session, accessor, payload)__	};handle,stomp,messages,going,back,out,to,web,socket,clients;override,suppress,warnings,unchecked,public,void,handle,message,to,client,web,socket,session,session,message,message,if,message,get,payload,instanceof,byte,if,logger,is,error,enabled,logger,error,expected,byte,payload,ignoring,message,return,stomp,header,accessor,accessor,get,stomp,header,accessor,message,stomp,command,command,accessor,get,command,if,stomp,command,message,equals,command,if,accessor,get,subscription,id,null,logger,is,warn,enabled,logger,warn,no,stomp,subscription,header,in,message,string,orig,destination,accessor,get,first,native,header,simp,message,header,accessor,if,orig,destination,null,accessor,to,mutable,accessor,accessor,message,accessor,remove,native,header,simp,message,header,accessor,accessor,set,destination,orig,destination,else,if,stomp,command,connected,equals,command,this,stats,increment,connected,count,accessor,after,stomp,session,connected,message,accessor,session,if,this,event,publisher,null,stomp,command,connected,equals,command,try,simp,attributes,simp,attributes,new,simp,attributes,session,get,id,session,get,attributes,simp,attributes,context,holder,set,attributes,simp,attributes,principal,user,get,user,session,publish,event,this,event,publisher,new,session,connected,event,this,message,byte,message,user,finally,simp,attributes,context,holder,reset,attributes,byte,payload,byte,message,get,payload,if,stomp,command,error,equals,command,get,error,handler,null,message,byte,error,message,get,error,handler,handle,error,message,to,client,message,byte,message,if,error,message,null,accessor,message,header,accessor,get,accessor,error,message,stomp,header,accessor,class,assert,state,accessor,null,no,stomp,header,accessor,payload,error,message,get,payload,send,to,client,session,accessor,payload
StompSubProtocolHandler -> @Override 	@SuppressWarnings("unchecked") 	public void handleMessageToClient(WebSocketSession session, Message<?> message);1502974979;Handle STOMP messages going back out to WebSocket clients.;@Override_	@SuppressWarnings("unchecked")_	public void handleMessageToClient(WebSocketSession session, Message<?> message) {_		if (!(message.getPayload() instanceof byte[])) {_			if (logger.isErrorEnabled()) {_				logger.error("Expected byte[] payload. Ignoring " + message + ".")__			}_			return__		}__		StompHeaderAccessor accessor = getStompHeaderAccessor(message)__		StompCommand command = accessor.getCommand()___		if (StompCommand.MESSAGE.equals(command)) {_			if (accessor.getSubscriptionId() == null && logger.isWarnEnabled()) {_				logger.warn("No STOMP \"subscription\" header in " + message)__			}_			String origDestination = accessor.getFirstNativeHeader(SimpMessageHeaderAccessor.ORIGINAL_DESTINATION)__			if (origDestination != null) {_				accessor = toMutableAccessor(accessor, message)__				accessor.removeNativeHeader(SimpMessageHeaderAccessor.ORIGINAL_DESTINATION)__				accessor.setDestination(origDestination)__			}_		}_		else if (StompCommand.CONNECTED.equals(command)) {_			this.stats.incrementConnectedCount()__			accessor = afterStompSessionConnected(message, accessor, session)__			if (this.eventPublisher != null && StompCommand.CONNECTED.equals(command)) {_				try {_					SimpAttributes simpAttributes = new SimpAttributes(session.getId(), session.getAttributes())__					SimpAttributesContextHolder.setAttributes(simpAttributes)__					Principal user = getUser(session)__					publishEvent(this.eventPublisher, new SessionConnectedEvent(this, (Message<byte[]>) message, user))__				}_				finally {_					SimpAttributesContextHolder.resetAttributes()__				}_			}_		}__		byte[] payload = (byte[]) message.getPayload()__		if (StompCommand.ERROR.equals(command) && getErrorHandler() != null) {_			Message<byte[]> errorMessage = getErrorHandler().handleErrorMessageToClient((Message<byte[]>) message)__			if (errorMessage != null) {_				accessor = MessageHeaderAccessor.getAccessor(errorMessage, StompHeaderAccessor.class)__				Assert.state(accessor != null, "No StompHeaderAccessor")__				payload = errorMessage.getPayload()__			}_		}_		sendToClient(session, accessor, payload)__	};handle,stomp,messages,going,back,out,to,web,socket,clients;override,suppress,warnings,unchecked,public,void,handle,message,to,client,web,socket,session,session,message,message,if,message,get,payload,instanceof,byte,if,logger,is,error,enabled,logger,error,expected,byte,payload,ignoring,message,return,stomp,header,accessor,accessor,get,stomp,header,accessor,message,stomp,command,command,accessor,get,command,if,stomp,command,message,equals,command,if,accessor,get,subscription,id,null,logger,is,warn,enabled,logger,warn,no,stomp,subscription,header,in,message,string,orig,destination,accessor,get,first,native,header,simp,message,header,accessor,if,orig,destination,null,accessor,to,mutable,accessor,accessor,message,accessor,remove,native,header,simp,message,header,accessor,accessor,set,destination,orig,destination,else,if,stomp,command,connected,equals,command,this,stats,increment,connected,count,accessor,after,stomp,session,connected,message,accessor,session,if,this,event,publisher,null,stomp,command,connected,equals,command,try,simp,attributes,simp,attributes,new,simp,attributes,session,get,id,session,get,attributes,simp,attributes,context,holder,set,attributes,simp,attributes,principal,user,get,user,session,publish,event,this,event,publisher,new,session,connected,event,this,message,byte,message,user,finally,simp,attributes,context,holder,reset,attributes,byte,payload,byte,message,get,payload,if,stomp,command,error,equals,command,get,error,handler,null,message,byte,error,message,get,error,handler,handle,error,message,to,client,message,byte,message,if,error,message,null,accessor,message,header,accessor,get,accessor,error,message,stomp,header,accessor,class,assert,state,accessor,null,no,stomp,header,accessor,payload,error,message,get,payload,send,to,client,session,accessor,payload
StompSubProtocolHandler -> @Override 	@SuppressWarnings("unchecked") 	public void handleMessageToClient(WebSocketSession session, Message<?> message);1509997270;Handle STOMP messages going back out to WebSocket clients.;@Override_	@SuppressWarnings("unchecked")_	public void handleMessageToClient(WebSocketSession session, Message<?> message) {_		if (!(message.getPayload() instanceof byte[])) {_			if (logger.isErrorEnabled()) {_				logger.error("Expected byte[] payload. Ignoring " + message + ".")__			}_			return__		}__		StompHeaderAccessor accessor = getStompHeaderAccessor(message)__		StompCommand command = accessor.getCommand()___		if (StompCommand.MESSAGE.equals(command)) {_			if (accessor.getSubscriptionId() == null && logger.isWarnEnabled()) {_				logger.warn("No STOMP \"subscription\" header in " + message)__			}_			String origDestination = accessor.getFirstNativeHeader(SimpMessageHeaderAccessor.ORIGINAL_DESTINATION)__			if (origDestination != null) {_				accessor = toMutableAccessor(accessor, message)__				accessor.removeNativeHeader(SimpMessageHeaderAccessor.ORIGINAL_DESTINATION)__				accessor.setDestination(origDestination)__			}_		}_		else if (StompCommand.CONNECTED.equals(command)) {_			this.stats.incrementConnectedCount()__			accessor = afterStompSessionConnected(message, accessor, session)__			if (this.eventPublisher != null && StompCommand.CONNECTED.equals(command)) {_				try {_					SimpAttributes simpAttributes = new SimpAttributes(session.getId(), session.getAttributes())__					SimpAttributesContextHolder.setAttributes(simpAttributes)__					Principal user = getUser(session)__					publishEvent(this.eventPublisher, new SessionConnectedEvent(this, (Message<byte[]>) message, user))__				}_				finally {_					SimpAttributesContextHolder.resetAttributes()__				}_			}_		}__		byte[] payload = (byte[]) message.getPayload()__		if (StompCommand.ERROR.equals(command) && getErrorHandler() != null) {_			Message<byte[]> errorMessage = getErrorHandler().handleErrorMessageToClient((Message<byte[]>) message)__			if (errorMessage != null) {_				accessor = MessageHeaderAccessor.getAccessor(errorMessage, StompHeaderAccessor.class)__				Assert.state(accessor != null, "No StompHeaderAccessor")__				payload = errorMessage.getPayload()__			}_		}_		sendToClient(session, accessor, payload)__	};handle,stomp,messages,going,back,out,to,web,socket,clients;override,suppress,warnings,unchecked,public,void,handle,message,to,client,web,socket,session,session,message,message,if,message,get,payload,instanceof,byte,if,logger,is,error,enabled,logger,error,expected,byte,payload,ignoring,message,return,stomp,header,accessor,accessor,get,stomp,header,accessor,message,stomp,command,command,accessor,get,command,if,stomp,command,message,equals,command,if,accessor,get,subscription,id,null,logger,is,warn,enabled,logger,warn,no,stomp,subscription,header,in,message,string,orig,destination,accessor,get,first,native,header,simp,message,header,accessor,if,orig,destination,null,accessor,to,mutable,accessor,accessor,message,accessor,remove,native,header,simp,message,header,accessor,accessor,set,destination,orig,destination,else,if,stomp,command,connected,equals,command,this,stats,increment,connected,count,accessor,after,stomp,session,connected,message,accessor,session,if,this,event,publisher,null,stomp,command,connected,equals,command,try,simp,attributes,simp,attributes,new,simp,attributes,session,get,id,session,get,attributes,simp,attributes,context,holder,set,attributes,simp,attributes,principal,user,get,user,session,publish,event,this,event,publisher,new,session,connected,event,this,message,byte,message,user,finally,simp,attributes,context,holder,reset,attributes,byte,payload,byte,message,get,payload,if,stomp,command,error,equals,command,get,error,handler,null,message,byte,error,message,get,error,handler,handle,error,message,to,client,message,byte,message,if,error,message,null,accessor,message,header,accessor,get,accessor,error,message,stomp,header,accessor,class,assert,state,accessor,null,no,stomp,header,accessor,payload,error,message,get,payload,send,to,client,session,accessor,payload
StompSubProtocolHandler -> @Override 	@SuppressWarnings("unchecked") 	public void handleMessageToClient(WebSocketSession session, Message<?> message);1530174524;Handle STOMP messages going back out to WebSocket clients.;@Override_	@SuppressWarnings("unchecked")_	public void handleMessageToClient(WebSocketSession session, Message<?> message) {_		if (!(message.getPayload() instanceof byte[])) {_			if (logger.isErrorEnabled()) {_				logger.error("Expected byte[] payload. Ignoring " + message + ".")__			}_			return__		}__		StompHeaderAccessor accessor = getStompHeaderAccessor(message)__		StompCommand command = accessor.getCommand()___		if (StompCommand.MESSAGE.equals(command)) {_			if (accessor.getSubscriptionId() == null && logger.isWarnEnabled()) {_				logger.warn("No STOMP \"subscription\" header in " + message)__			}_			String origDestination = accessor.getFirstNativeHeader(SimpMessageHeaderAccessor.ORIGINAL_DESTINATION)__			if (origDestination != null) {_				accessor = toMutableAccessor(accessor, message)__				accessor.removeNativeHeader(SimpMessageHeaderAccessor.ORIGINAL_DESTINATION)__				accessor.setDestination(origDestination)__			}_		}_		else if (StompCommand.CONNECTED.equals(command)) {_			this.stats.incrementConnectedCount()__			accessor = afterStompSessionConnected(message, accessor, session)__			if (this.eventPublisher != null && StompCommand.CONNECTED.equals(command)) {_				try {_					SimpAttributes simpAttributes = new SimpAttributes(session.getId(), session.getAttributes())__					SimpAttributesContextHolder.setAttributes(simpAttributes)__					Principal user = getUser(session)__					publishEvent(this.eventPublisher, new SessionConnectedEvent(this, (Message<byte[]>) message, user))__				}_				finally {_					SimpAttributesContextHolder.resetAttributes()__				}_			}_		}__		byte[] payload = (byte[]) message.getPayload()__		if (StompCommand.ERROR.equals(command) && getErrorHandler() != null) {_			Message<byte[]> errorMessage = getErrorHandler().handleErrorMessageToClient((Message<byte[]>) message)__			if (errorMessage != null) {_				accessor = MessageHeaderAccessor.getAccessor(errorMessage, StompHeaderAccessor.class)__				Assert.state(accessor != null, "No StompHeaderAccessor")__				payload = errorMessage.getPayload()__			}_		}_		sendToClient(session, accessor, payload)__	};handle,stomp,messages,going,back,out,to,web,socket,clients;override,suppress,warnings,unchecked,public,void,handle,message,to,client,web,socket,session,session,message,message,if,message,get,payload,instanceof,byte,if,logger,is,error,enabled,logger,error,expected,byte,payload,ignoring,message,return,stomp,header,accessor,accessor,get,stomp,header,accessor,message,stomp,command,command,accessor,get,command,if,stomp,command,message,equals,command,if,accessor,get,subscription,id,null,logger,is,warn,enabled,logger,warn,no,stomp,subscription,header,in,message,string,orig,destination,accessor,get,first,native,header,simp,message,header,accessor,if,orig,destination,null,accessor,to,mutable,accessor,accessor,message,accessor,remove,native,header,simp,message,header,accessor,accessor,set,destination,orig,destination,else,if,stomp,command,connected,equals,command,this,stats,increment,connected,count,accessor,after,stomp,session,connected,message,accessor,session,if,this,event,publisher,null,stomp,command,connected,equals,command,try,simp,attributes,simp,attributes,new,simp,attributes,session,get,id,session,get,attributes,simp,attributes,context,holder,set,attributes,simp,attributes,principal,user,get,user,session,publish,event,this,event,publisher,new,session,connected,event,this,message,byte,message,user,finally,simp,attributes,context,holder,reset,attributes,byte,payload,byte,message,get,payload,if,stomp,command,error,equals,command,get,error,handler,null,message,byte,error,message,get,error,handler,handle,error,message,to,client,message,byte,message,if,error,message,null,accessor,message,header,accessor,get,accessor,error,message,stomp,header,accessor,class,assert,state,accessor,null,no,stomp,header,accessor,payload,error,message,get,payload,send,to,client,session,accessor,payload
StompSubProtocolHandler -> @Override 	@SuppressWarnings("unchecked") 	public void handleMessageToClient(WebSocketSession session, Message<?> message);1536886762;Handle STOMP messages going back out to WebSocket clients.;@Override_	@SuppressWarnings("unchecked")_	public void handleMessageToClient(WebSocketSession session, Message<?> message) {_		if (!(message.getPayload() instanceof byte[])) {_			if (logger.isErrorEnabled()) {_				logger.error("Expected byte[] payload. Ignoring " + message + ".")__			}_			return__		}__		StompHeaderAccessor accessor = getStompHeaderAccessor(message)__		StompCommand command = accessor.getCommand()___		if (StompCommand.MESSAGE.equals(command)) {_			if (accessor.getSubscriptionId() == null && logger.isWarnEnabled()) {_				logger.warn("No STOMP \"subscription\" header in " + message)__			}_			String origDestination = accessor.getFirstNativeHeader(SimpMessageHeaderAccessor.ORIGINAL_DESTINATION)__			if (origDestination != null) {_				accessor = toMutableAccessor(accessor, message)__				accessor.removeNativeHeader(SimpMessageHeaderAccessor.ORIGINAL_DESTINATION)__				accessor.setDestination(origDestination)__			}_		}_		else if (StompCommand.CONNECTED.equals(command)) {_			this.stats.incrementConnectedCount()__			accessor = afterStompSessionConnected(message, accessor, session)__			if (this.eventPublisher != null && StompCommand.CONNECTED.equals(command)) {_				try {_					SimpAttributes simpAttributes = new SimpAttributes(session.getId(), session.getAttributes())__					SimpAttributesContextHolder.setAttributes(simpAttributes)__					Principal user = getUser(session)__					publishEvent(this.eventPublisher, new SessionConnectedEvent(this, (Message<byte[]>) message, user))__				}_				finally {_					SimpAttributesContextHolder.resetAttributes()__				}_			}_		}__		byte[] payload = (byte[]) message.getPayload()__		if (StompCommand.ERROR.equals(command) && getErrorHandler() != null) {_			Message<byte[]> errorMessage = getErrorHandler().handleErrorMessageToClient((Message<byte[]>) message)__			if (errorMessage != null) {_				accessor = MessageHeaderAccessor.getAccessor(errorMessage, StompHeaderAccessor.class)__				Assert.state(accessor != null, "No StompHeaderAccessor")__				payload = errorMessage.getPayload()__			}_		}_		sendToClient(session, accessor, payload)__	};handle,stomp,messages,going,back,out,to,web,socket,clients;override,suppress,warnings,unchecked,public,void,handle,message,to,client,web,socket,session,session,message,message,if,message,get,payload,instanceof,byte,if,logger,is,error,enabled,logger,error,expected,byte,payload,ignoring,message,return,stomp,header,accessor,accessor,get,stomp,header,accessor,message,stomp,command,command,accessor,get,command,if,stomp,command,message,equals,command,if,accessor,get,subscription,id,null,logger,is,warn,enabled,logger,warn,no,stomp,subscription,header,in,message,string,orig,destination,accessor,get,first,native,header,simp,message,header,accessor,if,orig,destination,null,accessor,to,mutable,accessor,accessor,message,accessor,remove,native,header,simp,message,header,accessor,accessor,set,destination,orig,destination,else,if,stomp,command,connected,equals,command,this,stats,increment,connected,count,accessor,after,stomp,session,connected,message,accessor,session,if,this,event,publisher,null,stomp,command,connected,equals,command,try,simp,attributes,simp,attributes,new,simp,attributes,session,get,id,session,get,attributes,simp,attributes,context,holder,set,attributes,simp,attributes,principal,user,get,user,session,publish,event,this,event,publisher,new,session,connected,event,this,message,byte,message,user,finally,simp,attributes,context,holder,reset,attributes,byte,payload,byte,message,get,payload,if,stomp,command,error,equals,command,get,error,handler,null,message,byte,error,message,get,error,handler,handle,error,message,to,client,message,byte,message,if,error,message,null,accessor,message,header,accessor,get,accessor,error,message,stomp,header,accessor,class,assert,state,accessor,null,no,stomp,header,accessor,payload,error,message,get,payload,send,to,client,session,accessor,payload
StompSubProtocolHandler -> @Override 	@SuppressWarnings("unchecked") 	public void handleMessageToClient(WebSocketSession session, Message<?> message);1542899558;Handle STOMP messages going back out to WebSocket clients.;@Override_	@SuppressWarnings("unchecked")_	public void handleMessageToClient(WebSocketSession session, Message<?> message) {_		if (!(message.getPayload() instanceof byte[])) {_			if (logger.isErrorEnabled()) {_				logger.error("Expected byte[] payload. Ignoring " + message + ".")__			}_			return__		}__		StompHeaderAccessor accessor = getStompHeaderAccessor(message)__		StompCommand command = accessor.getCommand()___		if (StompCommand.MESSAGE.equals(command)) {_			if (accessor.getSubscriptionId() == null && logger.isWarnEnabled()) {_				logger.warn("No STOMP \"subscription\" header in " + message)__			}_			String origDestination = accessor.getFirstNativeHeader(SimpMessageHeaderAccessor.ORIGINAL_DESTINATION)__			if (origDestination != null) {_				accessor = toMutableAccessor(accessor, message)__				accessor.removeNativeHeader(SimpMessageHeaderAccessor.ORIGINAL_DESTINATION)__				accessor.setDestination(origDestination)__			}_		}_		else if (StompCommand.CONNECTED.equals(command)) {_			this.stats.incrementConnectedCount()__			accessor = afterStompSessionConnected(message, accessor, session)__			if (this.eventPublisher != null) {_				try {_					SimpAttributes simpAttributes = new SimpAttributes(session.getId(), session.getAttributes())__					SimpAttributesContextHolder.setAttributes(simpAttributes)__					Principal user = getUser(session)__					publishEvent(this.eventPublisher, new SessionConnectedEvent(this, (Message<byte[]>) message, user))__				}_				finally {_					SimpAttributesContextHolder.resetAttributes()__				}_			}_		}__		byte[] payload = (byte[]) message.getPayload()__		if (StompCommand.ERROR.equals(command) && getErrorHandler() != null) {_			Message<byte[]> errorMessage = getErrorHandler().handleErrorMessageToClient((Message<byte[]>) message)__			if (errorMessage != null) {_				accessor = MessageHeaderAccessor.getAccessor(errorMessage, StompHeaderAccessor.class)__				Assert.state(accessor != null, "No StompHeaderAccessor")__				payload = errorMessage.getPayload()__			}_		}_		sendToClient(session, accessor, payload)__	};handle,stomp,messages,going,back,out,to,web,socket,clients;override,suppress,warnings,unchecked,public,void,handle,message,to,client,web,socket,session,session,message,message,if,message,get,payload,instanceof,byte,if,logger,is,error,enabled,logger,error,expected,byte,payload,ignoring,message,return,stomp,header,accessor,accessor,get,stomp,header,accessor,message,stomp,command,command,accessor,get,command,if,stomp,command,message,equals,command,if,accessor,get,subscription,id,null,logger,is,warn,enabled,logger,warn,no,stomp,subscription,header,in,message,string,orig,destination,accessor,get,first,native,header,simp,message,header,accessor,if,orig,destination,null,accessor,to,mutable,accessor,accessor,message,accessor,remove,native,header,simp,message,header,accessor,accessor,set,destination,orig,destination,else,if,stomp,command,connected,equals,command,this,stats,increment,connected,count,accessor,after,stomp,session,connected,message,accessor,session,if,this,event,publisher,null,try,simp,attributes,simp,attributes,new,simp,attributes,session,get,id,session,get,attributes,simp,attributes,context,holder,set,attributes,simp,attributes,principal,user,get,user,session,publish,event,this,event,publisher,new,session,connected,event,this,message,byte,message,user,finally,simp,attributes,context,holder,reset,attributes,byte,payload,byte,message,get,payload,if,stomp,command,error,equals,command,get,error,handler,null,message,byte,error,message,get,error,handler,handle,error,message,to,client,message,byte,message,if,error,message,null,accessor,message,header,accessor,get,accessor,error,message,stomp,header,accessor,class,assert,state,accessor,null,no,stomp,header,accessor,payload,error,message,get,payload,send,to,client,session,accessor,payload
StompSubProtocolHandler -> public MessageHeaderInitializer getHeaderInitializer();1397523793;@return the configured header initializer.;public MessageHeaderInitializer getHeaderInitializer() {_		return this.headerInitializer__	};return,the,configured,header,initializer;public,message,header,initializer,get,header,initializer,return,this,header,initializer
StompSubProtocolHandler -> public MessageHeaderInitializer getHeaderInitializer();1398443164;@return the configured header initializer.;public MessageHeaderInitializer getHeaderInitializer() {_		return this.headerInitializer__	};return,the,configured,header,initializer;public,message,header,initializer,get,header,initializer,return,this,header,initializer
StompSubProtocolHandler -> public MessageHeaderInitializer getHeaderInitializer();1399601217;@return the configured header initializer.;public MessageHeaderInitializer getHeaderInitializer() {_		return this.headerInitializer__	};return,the,configured,header,initializer;public,message,header,initializer,get,header,initializer,return,this,header,initializer
StompSubProtocolHandler -> public MessageHeaderInitializer getHeaderInitializer();1399825877;@return the configured header initializer.;public MessageHeaderInitializer getHeaderInitializer() {_		return this.headerInitializer__	};return,the,configured,header,initializer;public,message,header,initializer,get,header,initializer,return,this,header,initializer
StompSubProtocolHandler -> public MessageHeaderInitializer getHeaderInitializer();1403719829;@return the configured header initializer.;public MessageHeaderInitializer getHeaderInitializer() {_		return this.headerInitializer__	};return,the,configured,header,initializer;public,message,header,initializer,get,header,initializer,return,this,header,initializer
StompSubProtocolHandler -> public MessageHeaderInitializer getHeaderInitializer();1403856366;@return the configured header initializer.;public MessageHeaderInitializer getHeaderInitializer() {_		return this.headerInitializer__	};return,the,configured,header,initializer;public,message,header,initializer,get,header,initializer,return,this,header,initializer
StompSubProtocolHandler -> public MessageHeaderInitializer getHeaderInitializer();1403968062;@return the configured header initializer.;public MessageHeaderInitializer getHeaderInitializer() {_		return this.headerInitializer__	};return,the,configured,header,initializer;public,message,header,initializer,get,header,initializer,return,this,header,initializer
StompSubProtocolHandler -> public MessageHeaderInitializer getHeaderInitializer();1404880787;@return the configured header initializer.;public MessageHeaderInitializer getHeaderInitializer() {_		return this.headerInitializer__	};return,the,configured,header,initializer;public,message,header,initializer,get,header,initializer,return,this,header,initializer
StompSubProtocolHandler -> public MessageHeaderInitializer getHeaderInitializer();1404880799;@return the configured header initializer.;public MessageHeaderInitializer getHeaderInitializer() {_		return this.headerInitializer__	};return,the,configured,header,initializer;public,message,header,initializer,get,header,initializer,return,this,header,initializer
StompSubProtocolHandler -> public MessageHeaderInitializer getHeaderInitializer();1411067168;@return the configured header initializer.;public MessageHeaderInitializer getHeaderInitializer() {_		return this.headerInitializer__	};return,the,configured,header,initializer;public,message,header,initializer,get,header,initializer,return,this,header,initializer
StompSubProtocolHandler -> public MessageHeaderInitializer getHeaderInitializer();1411068071;@return the configured header initializer.;public MessageHeaderInitializer getHeaderInitializer() {_		return this.headerInitializer__	};return,the,configured,header,initializer;public,message,header,initializer,get,header,initializer,return,this,header,initializer
StompSubProtocolHandler -> public MessageHeaderInitializer getHeaderInitializer();1411148800;@return the configured header initializer.;public MessageHeaderInitializer getHeaderInitializer() {_		return this.headerInitializer__	};return,the,configured,header,initializer;public,message,header,initializer,get,header,initializer,return,this,header,initializer
StompSubProtocolHandler -> public MessageHeaderInitializer getHeaderInitializer();1411567635;@return the configured header initializer.;public MessageHeaderInitializer getHeaderInitializer() {_		return this.headerInitializer__	};return,the,configured,header,initializer;public,message,header,initializer,get,header,initializer,return,this,header,initializer
StompSubProtocolHandler -> public MessageHeaderInitializer getHeaderInitializer();1412965899;@return the configured header initializer.;public MessageHeaderInitializer getHeaderInitializer() {_		return this.headerInitializer__	};return,the,configured,header,initializer;public,message,header,initializer,get,header,initializer,return,this,header,initializer
StompSubProtocolHandler -> public MessageHeaderInitializer getHeaderInitializer();1413848647;@return the configured header initializer.;public MessageHeaderInitializer getHeaderInitializer() {_		return this.headerInitializer__	};return,the,configured,header,initializer;public,message,header,initializer,get,header,initializer,return,this,header,initializer
StompSubProtocolHandler -> public MessageHeaderInitializer getHeaderInitializer();1414092351;@return the configured header initializer.;public MessageHeaderInitializer getHeaderInitializer() {_		return this.headerInitializer__	};return,the,configured,header,initializer;public,message,header,initializer,get,header,initializer,return,this,header,initializer
StompSubProtocolHandler -> public MessageHeaderInitializer getHeaderInitializer();1414158498;@return the configured header initializer.;public MessageHeaderInitializer getHeaderInitializer() {_		return this.headerInitializer__	};return,the,configured,header,initializer;public,message,header,initializer,get,header,initializer,return,this,header,initializer
StompSubProtocolHandler -> public MessageHeaderInitializer getHeaderInitializer();1419362683;@return the configured header initializer.;public MessageHeaderInitializer getHeaderInitializer() {_		return this.headerInitializer__	};return,the,configured,header,initializer;public,message,header,initializer,get,header,initializer,return,this,header,initializer
StompSubProtocolHandler -> public MessageHeaderInitializer getHeaderInitializer();1419883989;@return the configured header initializer.;public MessageHeaderInitializer getHeaderInitializer() {_		return this.headerInitializer__	};return,the,configured,header,initializer;public,message,header,initializer,get,header,initializer,return,this,header,initializer
StompSubProtocolHandler -> public MessageHeaderInitializer getHeaderInitializer();1424278379;@return the configured header initializer.;public MessageHeaderInitializer getHeaderInitializer() {_		return this.headerInitializer__	};return,the,configured,header,initializer;public,message,header,initializer,get,header,initializer,return,this,header,initializer
StompSubProtocolHandler -> public MessageHeaderInitializer getHeaderInitializer();1428353843;@return the configured header initializer.;public MessageHeaderInitializer getHeaderInitializer() {_		return this.headerInitializer__	};return,the,configured,header,initializer;public,message,header,initializer,get,header,initializer,return,this,header,initializer
StompSubProtocolHandler -> public MessageHeaderInitializer getHeaderInitializer();1430834982;@return the configured header initializer.;public MessageHeaderInitializer getHeaderInitializer() {_		return this.headerInitializer__	};return,the,configured,header,initializer;public,message,header,initializer,get,header,initializer,return,this,header,initializer
StompSubProtocolHandler -> public MessageHeaderInitializer getHeaderInitializer();1431458952;@return the configured header initializer.;public MessageHeaderInitializer getHeaderInitializer() {_		return this.headerInitializer__	};return,the,configured,header,initializer;public,message,header,initializer,get,header,initializer,return,this,header,initializer
StompSubProtocolHandler -> public MessageHeaderInitializer getHeaderInitializer();1431728285;@return the configured header initializer.;public MessageHeaderInitializer getHeaderInitializer() {_		return this.headerInitializer__	};return,the,configured,header,initializer;public,message,header,initializer,get,header,initializer,return,this,header,initializer
StompSubProtocolHandler -> public MessageHeaderInitializer getHeaderInitializer();1432316649;@return the configured header initializer.;public MessageHeaderInitializer getHeaderInitializer() {_		return this.headerInitializer__	};return,the,configured,header,initializer;public,message,header,initializer,get,header,initializer,return,this,header,initializer
StompSubProtocolHandler -> public MessageHeaderInitializer getHeaderInitializer();1432331447;Return the configured header initializer.;public MessageHeaderInitializer getHeaderInitializer() {_		return this.headerInitializer__	};return,the,configured,header,initializer;public,message,header,initializer,get,header,initializer,return,this,header,initializer
StompSubProtocolHandler -> public MessageHeaderInitializer getHeaderInitializer();1440168414;Return the configured header initializer.;public MessageHeaderInitializer getHeaderInitializer() {_		return this.headerInitializer__	};return,the,configured,header,initializer;public,message,header,initializer,get,header,initializer,return,this,header,initializer
StompSubProtocolHandler -> public MessageHeaderInitializer getHeaderInitializer();1440249342;Return the configured header initializer.;public MessageHeaderInitializer getHeaderInitializer() {_		return this.headerInitializer__	};return,the,configured,header,initializer;public,message,header,initializer,get,header,initializer,return,this,header,initializer
StompSubProtocolHandler -> public MessageHeaderInitializer getHeaderInitializer();1467726769;Return the configured header initializer.;public MessageHeaderInitializer getHeaderInitializer() {_		return this.headerInitializer__	};return,the,configured,header,initializer;public,message,header,initializer,get,header,initializer,return,this,header,initializer
StompSubProtocolHandler -> public MessageHeaderInitializer getHeaderInitializer();1467730834;Return the configured header initializer.;public MessageHeaderInitializer getHeaderInitializer() {_		return this.headerInitializer__	};return,the,configured,header,initializer;public,message,header,initializer,get,header,initializer,return,this,header,initializer
StompSubProtocolHandler -> public MessageHeaderInitializer getHeaderInitializer();1472062321;Return the configured header initializer.;public MessageHeaderInitializer getHeaderInitializer() {_		return this.headerInitializer__	};return,the,configured,header,initializer;public,message,header,initializer,get,header,initializer,return,this,header,initializer
StompSubProtocolHandler -> public MessageHeaderInitializer getHeaderInitializer();1472509879;Return the configured header initializer.;public MessageHeaderInitializer getHeaderInitializer() {_		return this.headerInitializer__	};return,the,configured,header,initializer;public,message,header,initializer,get,header,initializer,return,this,header,initializer
StompSubProtocolHandler -> public MessageHeaderInitializer getHeaderInitializer();1476284885;Return the configured header initializer.;public MessageHeaderInitializer getHeaderInitializer() {_		return this.headerInitializer__	};return,the,configured,header,initializer;public,message,header,initializer,get,header,initializer,return,this,header,initializer
StompSubProtocolHandler -> public MessageHeaderInitializer getHeaderInitializer();1481213680;Return the configured header initializer.;public MessageHeaderInitializer getHeaderInitializer() {_		return this.headerInitializer__	};return,the,configured,header,initializer;public,message,header,initializer,get,header,initializer,return,this,header,initializer
StompSubProtocolHandler -> public MessageHeaderInitializer getHeaderInitializer();1481669991;Return the configured header initializer.;public MessageHeaderInitializer getHeaderInitializer() {_		return this.headerInitializer__	};return,the,configured,header,initializer;public,message,header,initializer,get,header,initializer,return,this,header,initializer
StompSubProtocolHandler -> public MessageHeaderInitializer getHeaderInitializer();1482265068;Return the configured header initializer.;public MessageHeaderInitializer getHeaderInitializer() {_		return this.headerInitializer__	};return,the,configured,header,initializer;public,message,header,initializer,get,header,initializer,return,this,header,initializer
StompSubProtocolHandler -> public MessageHeaderInitializer getHeaderInitializer();1495868221;Return the configured header initializer.;public MessageHeaderInitializer getHeaderInitializer() {_		return this.headerInitializer__	};return,the,configured,header,initializer;public,message,header,initializer,get,header,initializer,return,this,header,initializer
StompSubProtocolHandler -> @SuppressWarnings("unchecked") 	@Override 	public void handleMessageToClient(WebSocketSession session, Message<?> message);1385258957;Handle STOMP messages going back out to WebSocket clients.;@SuppressWarnings("unchecked")_	@Override_	public void handleMessageToClient(WebSocketSession session, Message<?> message) {__		StompHeaderAccessor headers = StompHeaderAccessor.wrap(message)___		if (headers.getMessageType() == SimpMessageType.CONNECT_ACK) {_			StompHeaderAccessor connectedHeaders = StompHeaderAccessor.create(StompCommand.CONNECTED)__			connectedHeaders.setVersion(getVersion(headers))__			connectedHeaders.setHeartbeat(0, 0)_ _			headers = connectedHeaders__		}_		else if (SimpMessageType.MESSAGE.equals(headers.getMessageType())) {_			headers.updateStompCommandAsServerMessage()__		}__		if (headers.getCommand() == StompCommand.CONNECTED) {_			afterStompSessionConnected(headers, session)__		}__		if (StompCommand.MESSAGE.equals(headers.getCommand()) && (headers.getSubscriptionId() == null)) {_			logger.error("Ignoring message, no subscriptionId header: " + message)__			return__		}__		if (!(message.getPayload() instanceof byte[])) {_			logger.error("Ignoring message, expected byte[] content: " + message)__			return__		}__		try {_			message = MessageBuilder.withPayload(message.getPayload()).setHeaders(headers).build()__			byte[] bytes = this.stompEncoder.encode((Message<byte[]>) message)__			session.sendMessage(new TextMessage(new String(bytes, Charset.forName("UTF-8"))))__		}_		catch (Throwable t) {_			sendErrorMessage(session, t)__		}_		finally {_			if (StompCommand.ERROR.equals(headers.getCommand())) {_				try {_					session.close(CloseStatus.PROTOCOL_ERROR)__				}_				catch (IOException e) {_					_				}_			}_		}_	};handle,stomp,messages,going,back,out,to,web,socket,clients;suppress,warnings,unchecked,override,public,void,handle,message,to,client,web,socket,session,session,message,message,stomp,header,accessor,headers,stomp,header,accessor,wrap,message,if,headers,get,message,type,simp,message,type,stomp,header,accessor,connected,headers,stomp,header,accessor,create,stomp,command,connected,connected,headers,set,version,get,version,headers,connected,headers,set,heartbeat,0,0,headers,connected,headers,else,if,simp,message,type,message,equals,headers,get,message,type,headers,update,stomp,command,as,server,message,if,headers,get,command,stomp,command,connected,after,stomp,session,connected,headers,session,if,stomp,command,message,equals,headers,get,command,headers,get,subscription,id,null,logger,error,ignoring,message,no,subscription,id,header,message,return,if,message,get,payload,instanceof,byte,logger,error,ignoring,message,expected,byte,content,message,return,try,message,message,builder,with,payload,message,get,payload,set,headers,headers,build,byte,bytes,this,stomp,encoder,encode,message,byte,message,session,send,message,new,text,message,new,string,bytes,charset,for,name,utf,8,catch,throwable,t,send,error,message,session,t,finally,if,stomp,command,error,equals,headers,get,command,try,session,close,close,status,catch,ioexception,e
StompSubProtocolHandler -> @SuppressWarnings("unchecked") 	@Override 	public void handleMessageToClient(WebSocketSession session, Message<?> message);1385412762;Handle STOMP messages going back out to WebSocket clients.;@SuppressWarnings("unchecked")_	@Override_	public void handleMessageToClient(WebSocketSession session, Message<?> message) {__		StompHeaderAccessor headers = StompHeaderAccessor.wrap(message)___		if (headers.getMessageType() == SimpMessageType.CONNECT_ACK) {_			StompHeaderAccessor connectedHeaders = StompHeaderAccessor.create(StompCommand.CONNECTED)__			connectedHeaders.setVersion(getVersion(headers))__			connectedHeaders.setHeartbeat(0, 0)_ _			headers = connectedHeaders__		}_		else if (SimpMessageType.MESSAGE.equals(headers.getMessageType())) {_			headers.updateStompCommandAsServerMessage()__		}__		if (headers.getCommand() == StompCommand.CONNECTED) {_			afterStompSessionConnected(headers, session)__		}__		if (StompCommand.MESSAGE.equals(headers.getCommand()) && (headers.getSubscriptionId() == null)) {_			logger.error("Ignoring message, no subscriptionId header: " + message)__			return__		}__		if (!(message.getPayload() instanceof byte[])) {_			logger.error("Ignoring message, expected byte[] content: " + message)__			return__		}__		try {_			message = MessageBuilder.withPayload(message.getPayload()).setHeaders(headers).build()__			byte[] bytes = this.stompEncoder.encode((Message<byte[]>) message)__			session.sendMessage(new TextMessage(new String(bytes, Charset.forName("UTF-8"))))__		}_		catch (Throwable t) {_			sendErrorMessage(session, t)__		}_		finally {_			if (StompCommand.ERROR.equals(headers.getCommand())) {_				try {_					session.close(CloseStatus.PROTOCOL_ERROR)__				}_				catch (IOException e) {_					_				}_			}_		}_	};handle,stomp,messages,going,back,out,to,web,socket,clients;suppress,warnings,unchecked,override,public,void,handle,message,to,client,web,socket,session,session,message,message,stomp,header,accessor,headers,stomp,header,accessor,wrap,message,if,headers,get,message,type,simp,message,type,stomp,header,accessor,connected,headers,stomp,header,accessor,create,stomp,command,connected,connected,headers,set,version,get,version,headers,connected,headers,set,heartbeat,0,0,headers,connected,headers,else,if,simp,message,type,message,equals,headers,get,message,type,headers,update,stomp,command,as,server,message,if,headers,get,command,stomp,command,connected,after,stomp,session,connected,headers,session,if,stomp,command,message,equals,headers,get,command,headers,get,subscription,id,null,logger,error,ignoring,message,no,subscription,id,header,message,return,if,message,get,payload,instanceof,byte,logger,error,ignoring,message,expected,byte,content,message,return,try,message,message,builder,with,payload,message,get,payload,set,headers,headers,build,byte,bytes,this,stomp,encoder,encode,message,byte,message,session,send,message,new,text,message,new,string,bytes,charset,for,name,utf,8,catch,throwable,t,send,error,message,session,t,finally,if,stomp,command,error,equals,headers,get,command,try,session,close,close,status,catch,ioexception,e
StompSubProtocolHandler -> @SuppressWarnings("unchecked") 	@Override 	public void handleMessageToClient(WebSocketSession session, Message<?> message);1385501137;Handle STOMP messages going back out to WebSocket clients.;@SuppressWarnings("unchecked")_	@Override_	public void handleMessageToClient(WebSocketSession session, Message<?> message) {__		StompHeaderAccessor headers = StompHeaderAccessor.wrap(message)___		if (headers.getMessageType() == SimpMessageType.CONNECT_ACK) {_			StompHeaderAccessor connectedHeaders = StompHeaderAccessor.create(StompCommand.CONNECTED)__			connectedHeaders.setVersion(getVersion(headers))__			connectedHeaders.setHeartbeat(0, 0)_ _			headers = connectedHeaders__		}_		else if (SimpMessageType.MESSAGE.equals(headers.getMessageType())) {_			headers.updateStompCommandAsServerMessage()__		}__		if (headers.getCommand() == StompCommand.CONNECTED) {_			afterStompSessionConnected(headers, session)__		}__		if (StompCommand.MESSAGE.equals(headers.getCommand()) && (headers.getSubscriptionId() == null)) {_			logger.error("Ignoring message, no subscriptionId header: " + message)__			return__		}__		if (!(message.getPayload() instanceof byte[])) {_			logger.error("Ignoring message, expected byte[] content: " + message)__			return__		}__		try {_			message = MessageBuilder.withPayload(message.getPayload()).setHeaders(headers).build()__			byte[] bytes = this.stompEncoder.encode((Message<byte[]>) message)__			session.sendMessage(new TextMessage(new String(bytes, Charset.forName("UTF-8"))))__		}_		catch (Throwable t) {_			sendErrorMessage(session, t)__		}_		finally {_			if (StompCommand.ERROR.equals(headers.getCommand())) {_				try {_					session.close(CloseStatus.PROTOCOL_ERROR)__				}_				catch (IOException e) {_					_				}_			}_		}_	};handle,stomp,messages,going,back,out,to,web,socket,clients;suppress,warnings,unchecked,override,public,void,handle,message,to,client,web,socket,session,session,message,message,stomp,header,accessor,headers,stomp,header,accessor,wrap,message,if,headers,get,message,type,simp,message,type,stomp,header,accessor,connected,headers,stomp,header,accessor,create,stomp,command,connected,connected,headers,set,version,get,version,headers,connected,headers,set,heartbeat,0,0,headers,connected,headers,else,if,simp,message,type,message,equals,headers,get,message,type,headers,update,stomp,command,as,server,message,if,headers,get,command,stomp,command,connected,after,stomp,session,connected,headers,session,if,stomp,command,message,equals,headers,get,command,headers,get,subscription,id,null,logger,error,ignoring,message,no,subscription,id,header,message,return,if,message,get,payload,instanceof,byte,logger,error,ignoring,message,expected,byte,content,message,return,try,message,message,builder,with,payload,message,get,payload,set,headers,headers,build,byte,bytes,this,stomp,encoder,encode,message,byte,message,session,send,message,new,text,message,new,string,bytes,charset,for,name,utf,8,catch,throwable,t,send,error,message,session,t,finally,if,stomp,command,error,equals,headers,get,command,try,session,close,close,status,catch,ioexception,e
StompSubProtocolHandler -> @SuppressWarnings("unchecked") 	@Override 	public void handleMessageToClient(WebSocketSession session, Message<?> message);1385502674;Handle STOMP messages going back out to WebSocket clients.;@SuppressWarnings("unchecked")_	@Override_	public void handleMessageToClient(WebSocketSession session, Message<?> message) {__		StompHeaderAccessor headers = StompHeaderAccessor.wrap(message)___		if (headers.getMessageType() == SimpMessageType.CONNECT_ACK) {_			StompHeaderAccessor connectedHeaders = StompHeaderAccessor.create(StompCommand.CONNECTED)__			connectedHeaders.setVersion(getVersion(headers))__			connectedHeaders.setHeartbeat(0, 0)_ _			headers = connectedHeaders__		}_		else if (SimpMessageType.MESSAGE.equals(headers.getMessageType())) {_			headers.updateStompCommandAsServerMessage()__		}__		if (headers.getCommand() == StompCommand.CONNECTED) {_			afterStompSessionConnected(headers, session)__		}__		if (StompCommand.MESSAGE.equals(headers.getCommand()) && (headers.getSubscriptionId() == null)) {_			logger.error("Ignoring message, no subscriptionId header: " + message)__			return__		}__		if (!(message.getPayload() instanceof byte[])) {_			logger.error("Ignoring message, expected byte[] content: " + message)__			return__		}__		try {_			message = MessageBuilder.withPayload(message.getPayload()).setHeaders(headers).build()__			byte[] bytes = this.stompEncoder.encode((Message<byte[]>) message)___			synchronized(session) {_				session.sendMessage(new TextMessage(new String(bytes, Charset.forName("UTF-8"))))__			}__		}_		catch (Throwable t) {_			sendErrorMessage(session, t)__		}_		finally {_			if (StompCommand.ERROR.equals(headers.getCommand())) {_				try {_					session.close(CloseStatus.PROTOCOL_ERROR)__				}_				catch (IOException e) {_					_				}_			}_		}_	};handle,stomp,messages,going,back,out,to,web,socket,clients;suppress,warnings,unchecked,override,public,void,handle,message,to,client,web,socket,session,session,message,message,stomp,header,accessor,headers,stomp,header,accessor,wrap,message,if,headers,get,message,type,simp,message,type,stomp,header,accessor,connected,headers,stomp,header,accessor,create,stomp,command,connected,connected,headers,set,version,get,version,headers,connected,headers,set,heartbeat,0,0,headers,connected,headers,else,if,simp,message,type,message,equals,headers,get,message,type,headers,update,stomp,command,as,server,message,if,headers,get,command,stomp,command,connected,after,stomp,session,connected,headers,session,if,stomp,command,message,equals,headers,get,command,headers,get,subscription,id,null,logger,error,ignoring,message,no,subscription,id,header,message,return,if,message,get,payload,instanceof,byte,logger,error,ignoring,message,expected,byte,content,message,return,try,message,message,builder,with,payload,message,get,payload,set,headers,headers,build,byte,bytes,this,stomp,encoder,encode,message,byte,message,synchronized,session,session,send,message,new,text,message,new,string,bytes,charset,for,name,utf,8,catch,throwable,t,send,error,message,session,t,finally,if,stomp,command,error,equals,headers,get,command,try,session,close,close,status,catch,ioexception,e
StompSubProtocolHandler -> @SuppressWarnings("unchecked") 	@Override 	public void handleMessageToClient(WebSocketSession session, Message<?> message);1386367529;Handle STOMP messages going back out to WebSocket clients.;@SuppressWarnings("unchecked")_	@Override_	public void handleMessageToClient(WebSocketSession session, Message<?> message) {__		StompHeaderAccessor headers = StompHeaderAccessor.wrap(message)___		if (headers.getMessageType() == SimpMessageType.CONNECT_ACK) {_			StompHeaderAccessor connectedHeaders = StompHeaderAccessor.create(StompCommand.CONNECTED)__			connectedHeaders.setVersion(getVersion(headers))__			connectedHeaders.setHeartbeat(0, 0)_ _			headers = connectedHeaders__		}_		else if (SimpMessageType.MESSAGE.equals(headers.getMessageType())) {_			headers.updateStompCommandAsServerMessage()__		}__		if (headers.getCommand() == StompCommand.CONNECTED) {_			afterStompSessionConnected(headers, session)__		}__		if (StompCommand.MESSAGE.equals(headers.getCommand()) && (headers.getSubscriptionId() == null)) {_			logger.error("Ignoring message, no subscriptionId header: " + message)__			return__		}__		if (!(message.getPayload() instanceof byte[])) {_			logger.error("Ignoring message, expected byte[] content: " + message)__			return__		}__		try {_			message = MessageBuilder.withPayload(message.getPayload()).setHeaders(headers).build()__			byte[] bytes = this.stompEncoder.encode((Message<byte[]>) message)___			synchronized(session) {_				session.sendMessage(new TextMessage(new String(bytes, Charset.forName("UTF-8"))))__			}__		}_		catch (Throwable t) {_			sendErrorMessage(session, t)__		}_		finally {_			if (StompCommand.ERROR.equals(headers.getCommand())) {_				try {_					session.close(CloseStatus.PROTOCOL_ERROR)__				}_				catch (IOException e) {_					_				}_			}_		}_	};handle,stomp,messages,going,back,out,to,web,socket,clients;suppress,warnings,unchecked,override,public,void,handle,message,to,client,web,socket,session,session,message,message,stomp,header,accessor,headers,stomp,header,accessor,wrap,message,if,headers,get,message,type,simp,message,type,stomp,header,accessor,connected,headers,stomp,header,accessor,create,stomp,command,connected,connected,headers,set,version,get,version,headers,connected,headers,set,heartbeat,0,0,headers,connected,headers,else,if,simp,message,type,message,equals,headers,get,message,type,headers,update,stomp,command,as,server,message,if,headers,get,command,stomp,command,connected,after,stomp,session,connected,headers,session,if,stomp,command,message,equals,headers,get,command,headers,get,subscription,id,null,logger,error,ignoring,message,no,subscription,id,header,message,return,if,message,get,payload,instanceof,byte,logger,error,ignoring,message,expected,byte,content,message,return,try,message,message,builder,with,payload,message,get,payload,set,headers,headers,build,byte,bytes,this,stomp,encoder,encode,message,byte,message,synchronized,session,session,send,message,new,text,message,new,string,bytes,charset,for,name,utf,8,catch,throwable,t,send,error,message,session,t,finally,if,stomp,command,error,equals,headers,get,command,try,session,close,close,status,catch,ioexception,e
StompSubProtocolHandler -> @SuppressWarnings("unchecked") 	@Override 	public void handleMessageToClient(WebSocketSession session, Message<?> message);1386462352;Handle STOMP messages going back out to WebSocket clients.;@SuppressWarnings("unchecked")_	@Override_	public void handleMessageToClient(WebSocketSession session, Message<?> message) {__		StompHeaderAccessor headers = StompHeaderAccessor.wrap(message)___		if (headers.getMessageType() == SimpMessageType.CONNECT_ACK) {_			StompHeaderAccessor connectedHeaders = StompHeaderAccessor.create(StompCommand.CONNECTED)__			connectedHeaders.setVersion(getVersion(headers))__			connectedHeaders.setHeartbeat(0, 0)_ _			headers = connectedHeaders__		}_		else if (SimpMessageType.MESSAGE.equals(headers.getMessageType())) {_			headers.updateStompCommandAsServerMessage()__		}__		if (headers.getCommand() == StompCommand.CONNECTED) {_			afterStompSessionConnected(headers, session)__		}__		if (StompCommand.MESSAGE.equals(headers.getCommand()) && (headers.getSubscriptionId() == null)) {_			logger.error("Ignoring message, no subscriptionId header: " + message)__			return__		}__		if (!(message.getPayload() instanceof byte[])) {_			logger.error("Ignoring message, expected byte[] content: " + message)__			return__		}__		try {_			message = MessageBuilder.withPayload(message.getPayload()).setHeaders(headers).build()__			byte[] bytes = this.stompEncoder.encode((Message<byte[]>) message)___			synchronized(session) {_				session.sendMessage(new TextMessage(new String(bytes, UTF8_CHARSET)))__			}__		}_		catch (Throwable ex) {_			sendErrorMessage(session, ex)__		}_		finally {_			if (StompCommand.ERROR.equals(headers.getCommand())) {_				try {_					session.close(CloseStatus.PROTOCOL_ERROR)__				}_				catch (IOException ex) {_					_				}_			}_		}_	};handle,stomp,messages,going,back,out,to,web,socket,clients;suppress,warnings,unchecked,override,public,void,handle,message,to,client,web,socket,session,session,message,message,stomp,header,accessor,headers,stomp,header,accessor,wrap,message,if,headers,get,message,type,simp,message,type,stomp,header,accessor,connected,headers,stomp,header,accessor,create,stomp,command,connected,connected,headers,set,version,get,version,headers,connected,headers,set,heartbeat,0,0,headers,connected,headers,else,if,simp,message,type,message,equals,headers,get,message,type,headers,update,stomp,command,as,server,message,if,headers,get,command,stomp,command,connected,after,stomp,session,connected,headers,session,if,stomp,command,message,equals,headers,get,command,headers,get,subscription,id,null,logger,error,ignoring,message,no,subscription,id,header,message,return,if,message,get,payload,instanceof,byte,logger,error,ignoring,message,expected,byte,content,message,return,try,message,message,builder,with,payload,message,get,payload,set,headers,headers,build,byte,bytes,this,stomp,encoder,encode,message,byte,message,synchronized,session,session,send,message,new,text,message,new,string,bytes,catch,throwable,ex,send,error,message,session,ex,finally,if,stomp,command,error,equals,headers,get,command,try,session,close,close,status,catch,ioexception,ex
StompSubProtocolHandler -> @SuppressWarnings("unchecked") 	@Override 	public void handleMessageToClient(WebSocketSession session, Message<?> message);1388683679;Handle STOMP messages going back out to WebSocket clients.;@SuppressWarnings("unchecked")_	@Override_	public void handleMessageToClient(WebSocketSession session, Message<?> message) {__		StompHeaderAccessor headers = StompHeaderAccessor.wrap(message)___		if (headers.getMessageType() == SimpMessageType.CONNECT_ACK) {_			StompHeaderAccessor connectedHeaders = StompHeaderAccessor.create(StompCommand.CONNECTED)__			connectedHeaders.setVersion(getVersion(headers))__			connectedHeaders.setHeartbeat(0, 0)_ _			headers = connectedHeaders__		}_		else if (SimpMessageType.MESSAGE.equals(headers.getMessageType())) {_			headers.updateStompCommandAsServerMessage()__		}__		if (headers.getCommand() == StompCommand.CONNECTED) {_			afterStompSessionConnected(headers, session)__		}__		if (StompCommand.MESSAGE.equals(headers.getCommand()) && (headers.getSubscriptionId() == null)) {_			logger.error("Ignoring message, no subscriptionId header: " + message)__			return__		}__		if (!(message.getPayload() instanceof byte[])) {_			logger.error("Ignoring message, expected byte[] content: " + message)__			return__		}__		try {_			message = MessageBuilder.withPayload(message.getPayload()).setHeaders(headers).build()__			byte[] bytes = this.stompEncoder.encode((Message<byte[]>) message)___			synchronized(session) {_				session.sendMessage(new TextMessage(new String(bytes, UTF8_CHARSET)))__			}__		}_		catch (Throwable ex) {_			sendErrorMessage(session, ex)__		}_		finally {_			if (StompCommand.ERROR.equals(headers.getCommand())) {_				try {_					session.close(CloseStatus.PROTOCOL_ERROR)__				}_				catch (IOException ex) {_					_				}_			}_		}_	};handle,stomp,messages,going,back,out,to,web,socket,clients;suppress,warnings,unchecked,override,public,void,handle,message,to,client,web,socket,session,session,message,message,stomp,header,accessor,headers,stomp,header,accessor,wrap,message,if,headers,get,message,type,simp,message,type,stomp,header,accessor,connected,headers,stomp,header,accessor,create,stomp,command,connected,connected,headers,set,version,get,version,headers,connected,headers,set,heartbeat,0,0,headers,connected,headers,else,if,simp,message,type,message,equals,headers,get,message,type,headers,update,stomp,command,as,server,message,if,headers,get,command,stomp,command,connected,after,stomp,session,connected,headers,session,if,stomp,command,message,equals,headers,get,command,headers,get,subscription,id,null,logger,error,ignoring,message,no,subscription,id,header,message,return,if,message,get,payload,instanceof,byte,logger,error,ignoring,message,expected,byte,content,message,return,try,message,message,builder,with,payload,message,get,payload,set,headers,headers,build,byte,bytes,this,stomp,encoder,encode,message,byte,message,synchronized,session,session,send,message,new,text,message,new,string,bytes,catch,throwable,ex,send,error,message,session,ex,finally,if,stomp,command,error,equals,headers,get,command,try,session,close,close,status,catch,ioexception,ex
StompSubProtocolHandler -> @SuppressWarnings("unchecked") 	@Override 	public void handleMessageToClient(WebSocketSession session, Message<?> message);1390324325;Handle STOMP messages going back out to WebSocket clients.;@SuppressWarnings("unchecked")_	@Override_	public void handleMessageToClient(WebSocketSession session, Message<?> message) {__		StompHeaderAccessor headers = StompHeaderAccessor.wrap(message)___		if (headers.getMessageType() == SimpMessageType.CONNECT_ACK) {_			StompHeaderAccessor connectedHeaders = StompHeaderAccessor.create(StompCommand.CONNECTED)__			connectedHeaders.setVersion(getVersion(headers))__			connectedHeaders.setHeartbeat(0, 0)_ _			headers = connectedHeaders__		}_		else if (SimpMessageType.MESSAGE.equals(headers.getMessageType())) {_			headers.updateStompCommandAsServerMessage()__		}__		if (headers.getCommand() == StompCommand.CONNECTED) {_			afterStompSessionConnected(headers, session)__		}__		if (StompCommand.MESSAGE.equals(headers.getCommand()) && (headers.getSubscriptionId() == null)) {_			logger.error("Ignoring message, no subscriptionId header: " + message)__			return__		}__		if (!(message.getPayload() instanceof byte[])) {_			logger.error("Ignoring message, expected byte[] content: " + message)__			return__		}__		try {_			message = MessageBuilder.withPayload(message.getPayload()).setHeaders(headers).build()__			byte[] bytes = this.stompEncoder.encode((Message<byte[]>) message)___			synchronized(session) {_				session.sendMessage(new TextMessage(new String(bytes, UTF8_CHARSET)))__			}__		}_		catch (Throwable ex) {_			sendErrorMessage(session, ex)__		}_		finally {_			if (StompCommand.ERROR.equals(headers.getCommand())) {_				try {_					session.close(CloseStatus.PROTOCOL_ERROR)__				}_				catch (IOException ex) {_					_				}_			}_		}_	};handle,stomp,messages,going,back,out,to,web,socket,clients;suppress,warnings,unchecked,override,public,void,handle,message,to,client,web,socket,session,session,message,message,stomp,header,accessor,headers,stomp,header,accessor,wrap,message,if,headers,get,message,type,simp,message,type,stomp,header,accessor,connected,headers,stomp,header,accessor,create,stomp,command,connected,connected,headers,set,version,get,version,headers,connected,headers,set,heartbeat,0,0,headers,connected,headers,else,if,simp,message,type,message,equals,headers,get,message,type,headers,update,stomp,command,as,server,message,if,headers,get,command,stomp,command,connected,after,stomp,session,connected,headers,session,if,stomp,command,message,equals,headers,get,command,headers,get,subscription,id,null,logger,error,ignoring,message,no,subscription,id,header,message,return,if,message,get,payload,instanceof,byte,logger,error,ignoring,message,expected,byte,content,message,return,try,message,message,builder,with,payload,message,get,payload,set,headers,headers,build,byte,bytes,this,stomp,encoder,encode,message,byte,message,synchronized,session,session,send,message,new,text,message,new,string,bytes,catch,throwable,ex,send,error,message,session,ex,finally,if,stomp,command,error,equals,headers,get,command,try,session,close,close,status,catch,ioexception,ex
StompSubProtocolHandler -> @SuppressWarnings("unchecked") 	@Override 	public void handleMessageToClient(WebSocketSession session, Message<?> message);1390325555;Handle STOMP messages going back out to WebSocket clients.;@SuppressWarnings("unchecked")_	@Override_	public void handleMessageToClient(WebSocketSession session, Message<?> message) {__		StompHeaderAccessor headers = StompHeaderAccessor.wrap(message)___		if (headers.getMessageType() == SimpMessageType.CONNECT_ACK) {_			StompHeaderAccessor connectedHeaders = StompHeaderAccessor.create(StompCommand.CONNECTED)__			connectedHeaders.setVersion(getVersion(headers))__			connectedHeaders.setHeartbeat(0, 0)_ _			headers = connectedHeaders__		}_		else if (SimpMessageType.MESSAGE.equals(headers.getMessageType())) {_			headers.updateStompCommandAsServerMessage()__		}__		if (headers.getCommand() == StompCommand.CONNECTED) {_			afterStompSessionConnected(headers, session)__		}__		if (StompCommand.MESSAGE.equals(headers.getCommand()) && (headers.getSubscriptionId() == null)) {_			logger.error("Ignoring message, no subscriptionId header: " + message)__			return__		}__		if (!(message.getPayload() instanceof byte[])) {_			logger.error("Ignoring message, expected byte[] content: " + message)__			return__		}__		try {_			message = MessageBuilder.withPayload(message.getPayload()).setHeaders(headers).build()__			byte[] bytes = this.stompEncoder.encode((Message<byte[]>) message)___			synchronized(session) {_				session.sendMessage(new TextMessage(new String(bytes, UTF8_CHARSET)))__			}__		}_		catch (Throwable ex) {_			sendErrorMessage(session, ex)__		}_		finally {_			if (StompCommand.ERROR.equals(headers.getCommand())) {_				try {_					session.close(CloseStatus.PROTOCOL_ERROR)__				}_				catch (IOException ex) {_					_				}_			}_		}_	};handle,stomp,messages,going,back,out,to,web,socket,clients;suppress,warnings,unchecked,override,public,void,handle,message,to,client,web,socket,session,session,message,message,stomp,header,accessor,headers,stomp,header,accessor,wrap,message,if,headers,get,message,type,simp,message,type,stomp,header,accessor,connected,headers,stomp,header,accessor,create,stomp,command,connected,connected,headers,set,version,get,version,headers,connected,headers,set,heartbeat,0,0,headers,connected,headers,else,if,simp,message,type,message,equals,headers,get,message,type,headers,update,stomp,command,as,server,message,if,headers,get,command,stomp,command,connected,after,stomp,session,connected,headers,session,if,stomp,command,message,equals,headers,get,command,headers,get,subscription,id,null,logger,error,ignoring,message,no,subscription,id,header,message,return,if,message,get,payload,instanceof,byte,logger,error,ignoring,message,expected,byte,content,message,return,try,message,message,builder,with,payload,message,get,payload,set,headers,headers,build,byte,bytes,this,stomp,encoder,encode,message,byte,message,synchronized,session,session,send,message,new,text,message,new,string,bytes,catch,throwable,ex,send,error,message,session,ex,finally,if,stomp,command,error,equals,headers,get,command,try,session,close,close,status,catch,ioexception,ex
StompSubProtocolHandler -> @SuppressWarnings("unchecked") 	@Override 	public void handleMessageToClient(WebSocketSession session, Message<?> message);1392327536;Handle STOMP messages going back out to WebSocket clients.;@SuppressWarnings("unchecked")_	@Override_	public void handleMessageToClient(WebSocketSession session, Message<?> message) {__		StompHeaderAccessor headers = StompHeaderAccessor.wrap(message)___		if (headers.getMessageType() == SimpMessageType.CONNECT_ACK) {_			StompHeaderAccessor connectedHeaders = StompHeaderAccessor.create(StompCommand.CONNECTED)__			connectedHeaders.setVersion(getVersion(headers))__			connectedHeaders.setHeartbeat(0, 0)_ _			headers = connectedHeaders__		}_		else if (SimpMessageType.MESSAGE.equals(headers.getMessageType())) {_			headers.updateStompCommandAsServerMessage()__		}__		if (headers.getCommand() == StompCommand.CONNECTED) {_			afterStompSessionConnected(headers, session)__		}__		if (StompCommand.MESSAGE.equals(headers.getCommand())) {_			if (headers.getSubscriptionId() == null) {_				logger.error("Ignoring message, no subscriptionId header: " + message)__				return__			}_			String header = UserDestinationMessageHandler.SUBSCRIBE_DESTINATION__			if (message.getHeaders().containsKey(header)) {_				headers.setDestination((String) message.getHeaders().get(header))__			}_		}__		if (!(message.getPayload() instanceof byte[])) {_			logger.error("Ignoring message, expected byte[] content: " + message)__			return__		}__		try {_			message = MessageBuilder.withPayload(message.getPayload()).setHeaders(headers).build()__			byte[] bytes = this.stompEncoder.encode((Message<byte[]>) message)___			synchronized(session) {_				session.sendMessage(new TextMessage(new String(bytes, UTF8_CHARSET)))__			}__		}_		catch (Throwable ex) {_			sendErrorMessage(session, ex)__		}_		finally {_			if (StompCommand.ERROR.equals(headers.getCommand())) {_				try {_					session.close(CloseStatus.PROTOCOL_ERROR)__				}_				catch (IOException ex) {_					_				}_			}_		}_	};handle,stomp,messages,going,back,out,to,web,socket,clients;suppress,warnings,unchecked,override,public,void,handle,message,to,client,web,socket,session,session,message,message,stomp,header,accessor,headers,stomp,header,accessor,wrap,message,if,headers,get,message,type,simp,message,type,stomp,header,accessor,connected,headers,stomp,header,accessor,create,stomp,command,connected,connected,headers,set,version,get,version,headers,connected,headers,set,heartbeat,0,0,headers,connected,headers,else,if,simp,message,type,message,equals,headers,get,message,type,headers,update,stomp,command,as,server,message,if,headers,get,command,stomp,command,connected,after,stomp,session,connected,headers,session,if,stomp,command,message,equals,headers,get,command,if,headers,get,subscription,id,null,logger,error,ignoring,message,no,subscription,id,header,message,return,string,header,user,destination,message,handler,if,message,get,headers,contains,key,header,headers,set,destination,string,message,get,headers,get,header,if,message,get,payload,instanceof,byte,logger,error,ignoring,message,expected,byte,content,message,return,try,message,message,builder,with,payload,message,get,payload,set,headers,headers,build,byte,bytes,this,stomp,encoder,encode,message,byte,message,synchronized,session,session,send,message,new,text,message,new,string,bytes,catch,throwable,ex,send,error,message,session,ex,finally,if,stomp,command,error,equals,headers,get,command,try,session,close,close,status,catch,ioexception,ex
StompSubProtocolHandler -> @SuppressWarnings("unchecked") 	@Override 	public void handleMessageToClient(WebSocketSession session, Message<?> message);1395251140;Handle STOMP messages going back out to WebSocket clients.;@SuppressWarnings("unchecked")_	@Override_	public void handleMessageToClient(WebSocketSession session, Message<?> message) {__		StompHeaderAccessor headers = StompHeaderAccessor.wrap(message)___		if (headers.getMessageType() == SimpMessageType.CONNECT_ACK) {_			StompHeaderAccessor connectedHeaders = StompHeaderAccessor.create(StompCommand.CONNECTED)__			connectedHeaders.setVersion(getVersion(headers))__			connectedHeaders.setHeartbeat(0, 0)_ _			headers = connectedHeaders__		}_		else if (SimpMessageType.MESSAGE.equals(headers.getMessageType())) {_			headers.updateStompCommandAsServerMessage()__		}__		if (headers.getCommand() == StompCommand.CONNECTED) {_			afterStompSessionConnected(headers, session)__		}__		if (StompCommand.MESSAGE.equals(headers.getCommand())) {_			if (headers.getSubscriptionId() == null) {_				logger.error("Ignoring message, no subscriptionId header: " + message)__				return__			}_			String header = UserDestinationMessageHandler.SUBSCRIBE_DESTINATION__			if (message.getHeaders().containsKey(header)) {_				headers.setDestination((String) message.getHeaders().get(header))__			}_		}__		if (!(message.getPayload() instanceof byte[])) {_			logger.error("Ignoring message, expected byte[] content: " + message)__			return__		}__		try {_			message = MessageBuilder.withPayload(message.getPayload()).setHeaders(headers).build()__			byte[] bytes = this.stompEncoder.encode((Message<byte[]>) message)___			synchronized(session) {_				session.sendMessage(new TextMessage(new String(bytes, UTF8_CHARSET)))__			}__		}_		catch (Throwable ex) {_			sendErrorMessage(session, ex)__		}_		finally {_			if (StompCommand.ERROR.equals(headers.getCommand())) {_				try {_					session.close(CloseStatus.PROTOCOL_ERROR)__				}_				catch (IOException ex) {_					_				}_			}_		}_	};handle,stomp,messages,going,back,out,to,web,socket,clients;suppress,warnings,unchecked,override,public,void,handle,message,to,client,web,socket,session,session,message,message,stomp,header,accessor,headers,stomp,header,accessor,wrap,message,if,headers,get,message,type,simp,message,type,stomp,header,accessor,connected,headers,stomp,header,accessor,create,stomp,command,connected,connected,headers,set,version,get,version,headers,connected,headers,set,heartbeat,0,0,headers,connected,headers,else,if,simp,message,type,message,equals,headers,get,message,type,headers,update,stomp,command,as,server,message,if,headers,get,command,stomp,command,connected,after,stomp,session,connected,headers,session,if,stomp,command,message,equals,headers,get,command,if,headers,get,subscription,id,null,logger,error,ignoring,message,no,subscription,id,header,message,return,string,header,user,destination,message,handler,if,message,get,headers,contains,key,header,headers,set,destination,string,message,get,headers,get,header,if,message,get,payload,instanceof,byte,logger,error,ignoring,message,expected,byte,content,message,return,try,message,message,builder,with,payload,message,get,payload,set,headers,headers,build,byte,bytes,this,stomp,encoder,encode,message,byte,message,synchronized,session,session,send,message,new,text,message,new,string,bytes,catch,throwable,ex,send,error,message,session,ex,finally,if,stomp,command,error,equals,headers,get,command,try,session,close,close,status,catch,ioexception,ex
StompSubProtocolHandler -> @SuppressWarnings("unchecked") 	@Override 	public void handleMessageToClient(WebSocketSession session, Message<?> message);1395364758;Handle STOMP messages going back out to WebSocket clients.;@SuppressWarnings("unchecked")_	@Override_	public void handleMessageToClient(WebSocketSession session, Message<?> message) {__		StompHeaderAccessor headers = StompHeaderAccessor.wrap(message)___		if (headers.getMessageType() == SimpMessageType.CONNECT_ACK) {_			StompHeaderAccessor connectedHeaders = StompHeaderAccessor.create(StompCommand.CONNECTED)__			connectedHeaders.setVersion(getVersion(headers))__			connectedHeaders.setHeartbeat(0, 0)_ _			headers = connectedHeaders__		}_		else if (SimpMessageType.MESSAGE.equals(headers.getMessageType())) {_			headers.updateStompCommandAsServerMessage()__		}__		if (headers.getCommand() == StompCommand.CONNECTED) {_			afterStompSessionConnected(headers, session)__		}__		if (StompCommand.MESSAGE.equals(headers.getCommand())) {_			if (headers.getSubscriptionId() == null) {_				logger.error("Ignoring message, no subscriptionId header: " + message)__				return__			}_			String header = UserDestinationMessageHandler.SUBSCRIBE_DESTINATION__			if (message.getHeaders().containsKey(header)) {_				headers.setDestination((String) message.getHeaders().get(header))__			}_		}__		if (!(message.getPayload() instanceof byte[])) {_			logger.error("Ignoring message, expected byte[] content: " + message)__			return__		}__		try {_			message = MessageBuilder.withPayload(message.getPayload()).setHeaders(headers).build()__			byte[] bytes = this.stompEncoder.encode((Message<byte[]>) message)___			synchronized(session) {_				session.sendMessage(new TextMessage(bytes))__			}__		}_		catch (Throwable ex) {_			sendErrorMessage(session, ex)__		}_		finally {_			if (StompCommand.ERROR.equals(headers.getCommand())) {_				try {_					session.close(CloseStatus.PROTOCOL_ERROR)__				}_				catch (IOException ex) {_					_				}_			}_		}_	};handle,stomp,messages,going,back,out,to,web,socket,clients;suppress,warnings,unchecked,override,public,void,handle,message,to,client,web,socket,session,session,message,message,stomp,header,accessor,headers,stomp,header,accessor,wrap,message,if,headers,get,message,type,simp,message,type,stomp,header,accessor,connected,headers,stomp,header,accessor,create,stomp,command,connected,connected,headers,set,version,get,version,headers,connected,headers,set,heartbeat,0,0,headers,connected,headers,else,if,simp,message,type,message,equals,headers,get,message,type,headers,update,stomp,command,as,server,message,if,headers,get,command,stomp,command,connected,after,stomp,session,connected,headers,session,if,stomp,command,message,equals,headers,get,command,if,headers,get,subscription,id,null,logger,error,ignoring,message,no,subscription,id,header,message,return,string,header,user,destination,message,handler,if,message,get,headers,contains,key,header,headers,set,destination,string,message,get,headers,get,header,if,message,get,payload,instanceof,byte,logger,error,ignoring,message,expected,byte,content,message,return,try,message,message,builder,with,payload,message,get,payload,set,headers,headers,build,byte,bytes,this,stomp,encoder,encode,message,byte,message,synchronized,session,session,send,message,new,text,message,bytes,catch,throwable,ex,send,error,message,session,ex,finally,if,stomp,command,error,equals,headers,get,command,try,session,close,close,status,catch,ioexception,ex
StompSubProtocolHandler -> @SuppressWarnings("unchecked") 	@Override 	public void handleMessageToClient(WebSocketSession session, Message<?> message);1395416543;Handle STOMP messages going back out to WebSocket clients.;@SuppressWarnings("unchecked")_	@Override_	public void handleMessageToClient(WebSocketSession session, Message<?> message) {__		StompHeaderAccessor headers = StompHeaderAccessor.wrap(message)___		if (headers.getMessageType() == SimpMessageType.CONNECT_ACK) {_			StompHeaderAccessor connectedHeaders = StompHeaderAccessor.create(StompCommand.CONNECTED)__			connectedHeaders.setVersion(getVersion(headers))__			connectedHeaders.setHeartbeat(0, 0)_ _			headers = connectedHeaders__		}_		else if (SimpMessageType.MESSAGE.equals(headers.getMessageType())) {_			headers.updateStompCommandAsServerMessage()__		}__		if (headers.getCommand() == StompCommand.CONNECTED) {_			afterStompSessionConnected(headers, session)__		}__		if (StompCommand.MESSAGE.equals(headers.getCommand())) {_			if (headers.getSubscriptionId() == null) {_				logger.error("Ignoring message, no subscriptionId header: " + message)__				return__			}_			String header = UserDestinationMessageHandler.SUBSCRIBE_DESTINATION__			if (message.getHeaders().containsKey(header)) {_				headers.setDestination((String) message.getHeaders().get(header))__			}_		}__		if (!(message.getPayload() instanceof byte[])) {_			logger.error("Ignoring message, expected byte[] content: " + message)__			return__		}__		try {_			message = MessageBuilder.withPayload(message.getPayload()).setHeaders(headers).build()__			byte[] bytes = this.stompEncoder.encode((Message<byte[]>) message)__			TextMessage textMessage = new TextMessage(bytes)___			session.sendMessage(textMessage)__		}_		catch (Throwable ex) {_			sendErrorMessage(session, ex)__		}_		finally {_			if (StompCommand.ERROR.equals(headers.getCommand())) {_				try {_					session.close(CloseStatus.PROTOCOL_ERROR)__				}_				catch (IOException ex) {_					_				}_			}_		}_	};handle,stomp,messages,going,back,out,to,web,socket,clients;suppress,warnings,unchecked,override,public,void,handle,message,to,client,web,socket,session,session,message,message,stomp,header,accessor,headers,stomp,header,accessor,wrap,message,if,headers,get,message,type,simp,message,type,stomp,header,accessor,connected,headers,stomp,header,accessor,create,stomp,command,connected,connected,headers,set,version,get,version,headers,connected,headers,set,heartbeat,0,0,headers,connected,headers,else,if,simp,message,type,message,equals,headers,get,message,type,headers,update,stomp,command,as,server,message,if,headers,get,command,stomp,command,connected,after,stomp,session,connected,headers,session,if,stomp,command,message,equals,headers,get,command,if,headers,get,subscription,id,null,logger,error,ignoring,message,no,subscription,id,header,message,return,string,header,user,destination,message,handler,if,message,get,headers,contains,key,header,headers,set,destination,string,message,get,headers,get,header,if,message,get,payload,instanceof,byte,logger,error,ignoring,message,expected,byte,content,message,return,try,message,message,builder,with,payload,message,get,payload,set,headers,headers,build,byte,bytes,this,stomp,encoder,encode,message,byte,message,text,message,text,message,new,text,message,bytes,session,send,message,text,message,catch,throwable,ex,send,error,message,session,ex,finally,if,stomp,command,error,equals,headers,get,command,try,session,close,close,status,catch,ioexception,ex
StompSubProtocolHandler -> @SuppressWarnings("unchecked") 	@Override 	public void handleMessageToClient(WebSocketSession session, Message<?> message);1395543579;Handle STOMP messages going back out to WebSocket clients.;@SuppressWarnings("unchecked")_	@Override_	public void handleMessageToClient(WebSocketSession session, Message<?> message) {__		StompHeaderAccessor headers = StompHeaderAccessor.wrap(message)___		if (headers.getMessageType() == SimpMessageType.CONNECT_ACK) {_			StompHeaderAccessor connectedHeaders = StompHeaderAccessor.create(StompCommand.CONNECTED)__			connectedHeaders.setVersion(getVersion(headers))__			connectedHeaders.setHeartbeat(0, 0)_ _			headers = connectedHeaders__		}_		else if (SimpMessageType.MESSAGE.equals(headers.getMessageType())) {_			headers.updateStompCommandAsServerMessage()__		}__		if (headers.getCommand() == StompCommand.CONNECTED) {_			afterStompSessionConnected(headers, session)__		}__		if (StompCommand.MESSAGE.equals(headers.getCommand())) {_			if (headers.getSubscriptionId() == null) {_				logger.error("Ignoring message, no subscriptionId header: " + message)__				return__			}_			String header = UserDestinationMessageHandler.SUBSCRIBE_DESTINATION__			if (message.getHeaders().containsKey(header)) {_				headers.setDestination((String) message.getHeaders().get(header))__			}_		}__		if (!(message.getPayload() instanceof byte[])) {_			logger.error("Ignoring message, expected byte[] content: " + message)__			return__		}__		try {_			message = MessageBuilder.withPayload(message.getPayload()).setHeaders(headers).build()__			byte[] bytes = this.stompEncoder.encode((Message<byte[]>) message)__			TextMessage textMessage = new TextMessage(bytes)___			session.sendMessage(textMessage)__		}_		catch (SessionLimitExceededException ex) {_			_			throw ex__		}_		catch (Throwable ex) {_			sendErrorMessage(session, ex)__		}_		finally {_			if (StompCommand.ERROR.equals(headers.getCommand())) {_				try {_					session.close(CloseStatus.PROTOCOL_ERROR)__				}_				catch (IOException ex) {_					_				}_			}_		}_	};handle,stomp,messages,going,back,out,to,web,socket,clients;suppress,warnings,unchecked,override,public,void,handle,message,to,client,web,socket,session,session,message,message,stomp,header,accessor,headers,stomp,header,accessor,wrap,message,if,headers,get,message,type,simp,message,type,stomp,header,accessor,connected,headers,stomp,header,accessor,create,stomp,command,connected,connected,headers,set,version,get,version,headers,connected,headers,set,heartbeat,0,0,headers,connected,headers,else,if,simp,message,type,message,equals,headers,get,message,type,headers,update,stomp,command,as,server,message,if,headers,get,command,stomp,command,connected,after,stomp,session,connected,headers,session,if,stomp,command,message,equals,headers,get,command,if,headers,get,subscription,id,null,logger,error,ignoring,message,no,subscription,id,header,message,return,string,header,user,destination,message,handler,if,message,get,headers,contains,key,header,headers,set,destination,string,message,get,headers,get,header,if,message,get,payload,instanceof,byte,logger,error,ignoring,message,expected,byte,content,message,return,try,message,message,builder,with,payload,message,get,payload,set,headers,headers,build,byte,bytes,this,stomp,encoder,encode,message,byte,message,text,message,text,message,new,text,message,bytes,session,send,message,text,message,catch,session,limit,exceeded,exception,ex,throw,ex,catch,throwable,ex,send,error,message,session,ex,finally,if,stomp,command,error,equals,headers,get,command,try,session,close,close,status,catch,ioexception,ex
StompSubProtocolHandler -> @SuppressWarnings("unchecked") 	@Override 	public void handleMessageToClient(WebSocketSession session, Message<?> message);1395555177;Handle STOMP messages going back out to WebSocket clients.;@SuppressWarnings("unchecked")_	@Override_	public void handleMessageToClient(WebSocketSession session, Message<?> message) {__		StompHeaderAccessor headers = StompHeaderAccessor.wrap(message)___		if (headers.getMessageType() == SimpMessageType.CONNECT_ACK) {_			StompHeaderAccessor connectedHeaders = StompHeaderAccessor.create(StompCommand.CONNECTED)__			connectedHeaders.setVersion(getVersion(headers))__			connectedHeaders.setHeartbeat(0, 0)_ _			headers = connectedHeaders__		}_		else if (SimpMessageType.MESSAGE.equals(headers.getMessageType())) {_			headers.updateStompCommandAsServerMessage()__		}__		if (headers.getCommand() == StompCommand.CONNECTED) {_			afterStompSessionConnected(headers, session)__		}__		if (StompCommand.MESSAGE.equals(headers.getCommand())) {_			if (headers.getSubscriptionId() == null) {_				logger.error("Ignoring message, no subscriptionId header: " + message)__				return__			}_			String header = UserDestinationMessageHandler.SUBSCRIBE_DESTINATION__			if (message.getHeaders().containsKey(header)) {_				headers.setDestination((String) message.getHeaders().get(header))__			}_		}__		if (!(message.getPayload() instanceof byte[])) {_			logger.error("Ignoring message, expected byte[] content: " + message)__			return__		}__		try {_			message = MessageBuilder.withPayload(message.getPayload()).setHeaders(headers).build()__			byte[] bytes = this.stompEncoder.encode((Message<byte[]>) message)__			TextMessage textMessage = new TextMessage(bytes)___			session.sendMessage(textMessage)__		}_		catch (SessionLimitExceededException ex) {_			_			throw ex__		}_		catch (Throwable ex) {_			sendErrorMessage(session, ex)__		}_		finally {_			if (StompCommand.ERROR.equals(headers.getCommand())) {_				try {_					session.close(CloseStatus.PROTOCOL_ERROR)__				}_				catch (IOException ex) {_					_				}_			}_		}_	};handle,stomp,messages,going,back,out,to,web,socket,clients;suppress,warnings,unchecked,override,public,void,handle,message,to,client,web,socket,session,session,message,message,stomp,header,accessor,headers,stomp,header,accessor,wrap,message,if,headers,get,message,type,simp,message,type,stomp,header,accessor,connected,headers,stomp,header,accessor,create,stomp,command,connected,connected,headers,set,version,get,version,headers,connected,headers,set,heartbeat,0,0,headers,connected,headers,else,if,simp,message,type,message,equals,headers,get,message,type,headers,update,stomp,command,as,server,message,if,headers,get,command,stomp,command,connected,after,stomp,session,connected,headers,session,if,stomp,command,message,equals,headers,get,command,if,headers,get,subscription,id,null,logger,error,ignoring,message,no,subscription,id,header,message,return,string,header,user,destination,message,handler,if,message,get,headers,contains,key,header,headers,set,destination,string,message,get,headers,get,header,if,message,get,payload,instanceof,byte,logger,error,ignoring,message,expected,byte,content,message,return,try,message,message,builder,with,payload,message,get,payload,set,headers,headers,build,byte,bytes,this,stomp,encoder,encode,message,byte,message,text,message,text,message,new,text,message,bytes,session,send,message,text,message,catch,session,limit,exceeded,exception,ex,throw,ex,catch,throwable,ex,send,error,message,session,ex,finally,if,stomp,command,error,equals,headers,get,command,try,session,close,close,status,catch,ioexception,ex
StompSubProtocolHandler -> @SuppressWarnings("unchecked") 	@Override 	public void handleMessageToClient(WebSocketSession session, Message<?> message);1395703237;Handle STOMP messages going back out to WebSocket clients.;@SuppressWarnings("unchecked")_	@Override_	public void handleMessageToClient(WebSocketSession session, Message<?> message) {__		StompHeaderAccessor headers = StompHeaderAccessor.wrap(message)___		if (headers.getMessageType() == SimpMessageType.CONNECT_ACK) {_			StompHeaderAccessor connectedHeaders = StompHeaderAccessor.create(StompCommand.CONNECTED)__			connectedHeaders.setVersion(getVersion(headers))__			connectedHeaders.setHeartbeat(0, 0)_ _			headers = connectedHeaders__		}_		else if (SimpMessageType.MESSAGE.equals(headers.getMessageType())) {_			headers.updateStompCommandAsServerMessage()__		}__		if (headers.getCommand() == StompCommand.CONNECTED) {_			afterStompSessionConnected(headers, session)__		}__		if (StompCommand.MESSAGE.equals(headers.getCommand())) {_			if (headers.getSubscriptionId() == null) {_				logger.error("Ignoring message, no subscriptionId header: " + message)__				return__			}_			String header = UserDestinationMessageHandler.SUBSCRIBE_DESTINATION__			if (message.getHeaders().containsKey(header)) {_				headers.setDestination((String) message.getHeaders().get(header))__			}_		}__		if (!(message.getPayload() instanceof byte[])) {_			logger.error("Ignoring message, expected byte[] content: " + message)__			return__		}__		try {_			message = MessageBuilder.withPayload(message.getPayload()).setHeaders(headers).build()__			byte[] bytes = this.stompEncoder.encode((Message<byte[]>) message)__			TextMessage textMessage = new TextMessage(bytes)___			session.sendMessage(textMessage)__		}_		catch (SessionLimitExceededException ex) {_			_			throw ex__		}_		catch (Throwable ex) {_			sendErrorMessage(session, ex)__		}_		finally {_			if (StompCommand.ERROR.equals(headers.getCommand())) {_				try {_					session.close(CloseStatus.PROTOCOL_ERROR)__				}_				catch (IOException ex) {_					_				}_			}_		}_	};handle,stomp,messages,going,back,out,to,web,socket,clients;suppress,warnings,unchecked,override,public,void,handle,message,to,client,web,socket,session,session,message,message,stomp,header,accessor,headers,stomp,header,accessor,wrap,message,if,headers,get,message,type,simp,message,type,stomp,header,accessor,connected,headers,stomp,header,accessor,create,stomp,command,connected,connected,headers,set,version,get,version,headers,connected,headers,set,heartbeat,0,0,headers,connected,headers,else,if,simp,message,type,message,equals,headers,get,message,type,headers,update,stomp,command,as,server,message,if,headers,get,command,stomp,command,connected,after,stomp,session,connected,headers,session,if,stomp,command,message,equals,headers,get,command,if,headers,get,subscription,id,null,logger,error,ignoring,message,no,subscription,id,header,message,return,string,header,user,destination,message,handler,if,message,get,headers,contains,key,header,headers,set,destination,string,message,get,headers,get,header,if,message,get,payload,instanceof,byte,logger,error,ignoring,message,expected,byte,content,message,return,try,message,message,builder,with,payload,message,get,payload,set,headers,headers,build,byte,bytes,this,stomp,encoder,encode,message,byte,message,text,message,text,message,new,text,message,bytes,session,send,message,text,message,catch,session,limit,exceeded,exception,ex,throw,ex,catch,throwable,ex,send,error,message,session,ex,finally,if,stomp,command,error,equals,headers,get,command,try,session,close,close,status,catch,ioexception,ex
StompSubProtocolHandler -> @SuppressWarnings("unchecked") 	@Override 	public void handleMessageToClient(WebSocketSession session, Message<?> message);1395703237;Handle STOMP messages going back out to WebSocket clients.;@SuppressWarnings("unchecked")_	@Override_	public void handleMessageToClient(WebSocketSession session, Message<?> message) {__		StompHeaderAccessor headers = StompHeaderAccessor.wrap(message)___		if (headers.getMessageType() == SimpMessageType.CONNECT_ACK) {_			StompHeaderAccessor connectedHeaders = StompHeaderAccessor.create(StompCommand.CONNECTED)__			connectedHeaders.setVersion(getVersion(headers))__			connectedHeaders.setHeartbeat(0, 0)_ _			headers = connectedHeaders__		}_		else if (SimpMessageType.MESSAGE.equals(headers.getMessageType())) {_			headers.updateStompCommandAsServerMessage()__		}__		if (headers.getCommand() == StompCommand.CONNECTED) {_			afterStompSessionConnected(headers, session)__		}__		if (StompCommand.MESSAGE.equals(headers.getCommand())) {_			if (headers.getSubscriptionId() == null) {_				logger.error("Ignoring message, no subscriptionId header: " + message)__				return__			}_			String header = UserDestinationMessageHandler.SUBSCRIBE_DESTINATION__			if (message.getHeaders().containsKey(header)) {_				headers.setDestination((String) message.getHeaders().get(header))__			}_		}__		if (!(message.getPayload() instanceof byte[])) {_			logger.error("Ignoring message, expected byte[] content: " + message)__			return__		}__		try {_			message = MessageBuilder.withPayload(message.getPayload()).setHeaders(headers).build()__			byte[] bytes = this.stompEncoder.encode((Message<byte[]>) message)__			TextMessage textMessage = new TextMessage(bytes)___			session.sendMessage(textMessage)__		}_		catch (SessionLimitExceededException ex) {_			_			throw ex__		}_		catch (Throwable ex) {_			sendErrorMessage(session, ex)__		}_		finally {_			if (StompCommand.ERROR.equals(headers.getCommand())) {_				try {_					session.close(CloseStatus.PROTOCOL_ERROR)__				}_				catch (IOException ex) {_					_				}_			}_		}_	};handle,stomp,messages,going,back,out,to,web,socket,clients;suppress,warnings,unchecked,override,public,void,handle,message,to,client,web,socket,session,session,message,message,stomp,header,accessor,headers,stomp,header,accessor,wrap,message,if,headers,get,message,type,simp,message,type,stomp,header,accessor,connected,headers,stomp,header,accessor,create,stomp,command,connected,connected,headers,set,version,get,version,headers,connected,headers,set,heartbeat,0,0,headers,connected,headers,else,if,simp,message,type,message,equals,headers,get,message,type,headers,update,stomp,command,as,server,message,if,headers,get,command,stomp,command,connected,after,stomp,session,connected,headers,session,if,stomp,command,message,equals,headers,get,command,if,headers,get,subscription,id,null,logger,error,ignoring,message,no,subscription,id,header,message,return,string,header,user,destination,message,handler,if,message,get,headers,contains,key,header,headers,set,destination,string,message,get,headers,get,header,if,message,get,payload,instanceof,byte,logger,error,ignoring,message,expected,byte,content,message,return,try,message,message,builder,with,payload,message,get,payload,set,headers,headers,build,byte,bytes,this,stomp,encoder,encode,message,byte,message,text,message,text,message,new,text,message,bytes,session,send,message,text,message,catch,session,limit,exceeded,exception,ex,throw,ex,catch,throwable,ex,send,error,message,session,ex,finally,if,stomp,command,error,equals,headers,get,command,try,session,close,close,status,catch,ioexception,ex
StompSubProtocolHandler -> @SuppressWarnings("unchecked") 	@Override 	public void handleMessageToClient(WebSocketSession session, Message<?> message);1395703237;Handle STOMP messages going back out to WebSocket clients.;@SuppressWarnings("unchecked")_	@Override_	public void handleMessageToClient(WebSocketSession session, Message<?> message) {__		StompHeaderAccessor headers = StompHeaderAccessor.wrap(message)___		if (headers.getMessageType() == SimpMessageType.CONNECT_ACK) {_			StompHeaderAccessor connectedHeaders = StompHeaderAccessor.create(StompCommand.CONNECTED)__			connectedHeaders.setVersion(getVersion(headers))__			connectedHeaders.setHeartbeat(0, 0)_ _			headers = connectedHeaders__		}_		else if (SimpMessageType.MESSAGE.equals(headers.getMessageType())) {_			headers.updateStompCommandAsServerMessage()__		}__		if (headers.getCommand() == StompCommand.CONNECTED) {_			afterStompSessionConnected(headers, session)__		}__		if (StompCommand.MESSAGE.equals(headers.getCommand())) {_			if (headers.getSubscriptionId() == null) {_				logger.error("Ignoring message, no subscriptionId header: " + message)__				return__			}_			String header = UserDestinationMessageHandler.SUBSCRIBE_DESTINATION__			if (message.getHeaders().containsKey(header)) {_				headers.setDestination((String) message.getHeaders().get(header))__			}_		}__		if (!(message.getPayload() instanceof byte[])) {_			logger.error("Ignoring message, expected byte[] content: " + message)__			return__		}__		try {_			message = MessageBuilder.withPayload(message.getPayload()).setHeaders(headers).build()__			byte[] bytes = this.stompEncoder.encode((Message<byte[]>) message)__			TextMessage textMessage = new TextMessage(bytes)___			session.sendMessage(textMessage)__		}_		catch (SessionLimitExceededException ex) {_			_			throw ex__		}_		catch (Throwable ex) {_			sendErrorMessage(session, ex)__		}_		finally {_			if (StompCommand.ERROR.equals(headers.getCommand())) {_				try {_					session.close(CloseStatus.PROTOCOL_ERROR)__				}_				catch (IOException ex) {_					_				}_			}_		}_	};handle,stomp,messages,going,back,out,to,web,socket,clients;suppress,warnings,unchecked,override,public,void,handle,message,to,client,web,socket,session,session,message,message,stomp,header,accessor,headers,stomp,header,accessor,wrap,message,if,headers,get,message,type,simp,message,type,stomp,header,accessor,connected,headers,stomp,header,accessor,create,stomp,command,connected,connected,headers,set,version,get,version,headers,connected,headers,set,heartbeat,0,0,headers,connected,headers,else,if,simp,message,type,message,equals,headers,get,message,type,headers,update,stomp,command,as,server,message,if,headers,get,command,stomp,command,connected,after,stomp,session,connected,headers,session,if,stomp,command,message,equals,headers,get,command,if,headers,get,subscription,id,null,logger,error,ignoring,message,no,subscription,id,header,message,return,string,header,user,destination,message,handler,if,message,get,headers,contains,key,header,headers,set,destination,string,message,get,headers,get,header,if,message,get,payload,instanceof,byte,logger,error,ignoring,message,expected,byte,content,message,return,try,message,message,builder,with,payload,message,get,payload,set,headers,headers,build,byte,bytes,this,stomp,encoder,encode,message,byte,message,text,message,text,message,new,text,message,bytes,session,send,message,text,message,catch,session,limit,exceeded,exception,ex,throw,ex,catch,throwable,ex,send,error,message,session,ex,finally,if,stomp,command,error,equals,headers,get,command,try,session,close,close,status,catch,ioexception,ex
StompSubProtocolHandler -> @SuppressWarnings("unchecked") 	@Override 	public void handleMessageToClient(WebSocketSession session, Message<?> message);1395703238;Handle STOMP messages going back out to WebSocket clients.;@SuppressWarnings("unchecked")_	@Override_	public void handleMessageToClient(WebSocketSession session, Message<?> message) {__		StompHeaderAccessor headers = StompHeaderAccessor.wrap(message)___		if (headers.getMessageType() == SimpMessageType.CONNECT_ACK) {_			StompHeaderAccessor connectedHeaders = StompHeaderAccessor.create(StompCommand.CONNECTED)__			connectedHeaders.setVersion(getVersion(headers))__			connectedHeaders.setHeartbeat(0, 0)_ _			headers = connectedHeaders__		}_		else if (SimpMessageType.MESSAGE.equals(headers.getMessageType())) {_			headers.updateStompCommandAsServerMessage()__		}__		if (headers.getCommand() == StompCommand.CONNECTED) {_			afterStompSessionConnected(headers, session)__		}__		if (StompCommand.MESSAGE.equals(headers.getCommand())) {_			if (headers.getSubscriptionId() == null) {_				logger.error("Ignoring message, no subscriptionId header: " + message)__				return__			}_			String header = UserDestinationMessageHandler.SUBSCRIBE_DESTINATION__			if (message.getHeaders().containsKey(header)) {_				headers.setDestination((String) message.getHeaders().get(header))__			}_		}__		if (!(message.getPayload() instanceof byte[])) {_			logger.error("Ignoring message, expected byte[] content: " + message)__			return__		}__		try {_			message = MessageBuilder.withPayload(message.getPayload()).setHeaders(headers).build()__			byte[] bytes = this.stompEncoder.encode((Message<byte[]>) message)__			TextMessage textMessage = new TextMessage(bytes)___			session.sendMessage(textMessage)__		}_		catch (SessionLimitExceededException ex) {_			_			throw ex__		}_		catch (Throwable ex) {_			sendErrorMessage(session, ex)__		}_		finally {_			if (StompCommand.ERROR.equals(headers.getCommand())) {_				try {_					session.close(CloseStatus.PROTOCOL_ERROR)__				}_				catch (IOException ex) {_					_				}_			}_		}_	};handle,stomp,messages,going,back,out,to,web,socket,clients;suppress,warnings,unchecked,override,public,void,handle,message,to,client,web,socket,session,session,message,message,stomp,header,accessor,headers,stomp,header,accessor,wrap,message,if,headers,get,message,type,simp,message,type,stomp,header,accessor,connected,headers,stomp,header,accessor,create,stomp,command,connected,connected,headers,set,version,get,version,headers,connected,headers,set,heartbeat,0,0,headers,connected,headers,else,if,simp,message,type,message,equals,headers,get,message,type,headers,update,stomp,command,as,server,message,if,headers,get,command,stomp,command,connected,after,stomp,session,connected,headers,session,if,stomp,command,message,equals,headers,get,command,if,headers,get,subscription,id,null,logger,error,ignoring,message,no,subscription,id,header,message,return,string,header,user,destination,message,handler,if,message,get,headers,contains,key,header,headers,set,destination,string,message,get,headers,get,header,if,message,get,payload,instanceof,byte,logger,error,ignoring,message,expected,byte,content,message,return,try,message,message,builder,with,payload,message,get,payload,set,headers,headers,build,byte,bytes,this,stomp,encoder,encode,message,byte,message,text,message,text,message,new,text,message,bytes,session,send,message,text,message,catch,session,limit,exceeded,exception,ex,throw,ex,catch,throwable,ex,send,error,message,session,ex,finally,if,stomp,command,error,equals,headers,get,command,try,session,close,close,status,catch,ioexception,ex
StompSubProtocolHandler -> @SuppressWarnings("unchecked") 	@Override 	public void handleMessageToClient(WebSocketSession session, Message<?> message);1395707441;Handle STOMP messages going back out to WebSocket clients.;@SuppressWarnings("unchecked")_	@Override_	public void handleMessageToClient(WebSocketSession session, Message<?> message) {__		StompHeaderAccessor headers = StompHeaderAccessor.wrap(message)___		if (headers.getMessageType() == SimpMessageType.CONNECT_ACK) {_			StompHeaderAccessor connectedHeaders = StompHeaderAccessor.create(StompCommand.CONNECTED)__			connectedHeaders.setVersion(getVersion(headers))__			connectedHeaders.setHeartbeat(0, 0)_ _			headers = connectedHeaders__		}_		else if (SimpMessageType.MESSAGE.equals(headers.getMessageType())) {_			headers.updateStompCommandAsServerMessage()__		}__		if (headers.getCommand() == StompCommand.CONNECTED) {_			afterStompSessionConnected(headers, session)__		}__		if (StompCommand.MESSAGE.equals(headers.getCommand())) {_			if (headers.getSubscriptionId() == null) {_				logger.error("Ignoring message, no subscriptionId header: " + message)__				return__			}_			String header = UserDestinationMessageHandler.SUBSCRIBE_DESTINATION__			if (message.getHeaders().containsKey(header)) {_				headers.setDestination((String) message.getHeaders().get(header))__			}_		}__		if (!(message.getPayload() instanceof byte[])) {_			logger.error("Ignoring message, expected byte[] content: " + message)__			return__		}__		try {_			message = MessageBuilder.withPayload(message.getPayload()).setHeaders(headers).build()___			if (headers.getCommand() == StompCommand.CONNECTED && this.eventPublisher != null) {_				this.eventPublisher.publishEvent(new SessionConnectedEvent(this, (Message<byte[]>) message))__			}__			byte[] bytes = this.stompEncoder.encode((Message<byte[]>) message)__			TextMessage textMessage = new TextMessage(bytes)___			session.sendMessage(textMessage)__		}_		catch (SessionLimitExceededException ex) {_			_			throw ex__		}_		catch (Throwable ex) {_			sendErrorMessage(session, ex)__		}_		finally {_			if (StompCommand.ERROR.equals(headers.getCommand())) {_				try {_					session.close(CloseStatus.PROTOCOL_ERROR)__				}_				catch (IOException ex) {_					_				}_			}_		}_	};handle,stomp,messages,going,back,out,to,web,socket,clients;suppress,warnings,unchecked,override,public,void,handle,message,to,client,web,socket,session,session,message,message,stomp,header,accessor,headers,stomp,header,accessor,wrap,message,if,headers,get,message,type,simp,message,type,stomp,header,accessor,connected,headers,stomp,header,accessor,create,stomp,command,connected,connected,headers,set,version,get,version,headers,connected,headers,set,heartbeat,0,0,headers,connected,headers,else,if,simp,message,type,message,equals,headers,get,message,type,headers,update,stomp,command,as,server,message,if,headers,get,command,stomp,command,connected,after,stomp,session,connected,headers,session,if,stomp,command,message,equals,headers,get,command,if,headers,get,subscription,id,null,logger,error,ignoring,message,no,subscription,id,header,message,return,string,header,user,destination,message,handler,if,message,get,headers,contains,key,header,headers,set,destination,string,message,get,headers,get,header,if,message,get,payload,instanceof,byte,logger,error,ignoring,message,expected,byte,content,message,return,try,message,message,builder,with,payload,message,get,payload,set,headers,headers,build,if,headers,get,command,stomp,command,connected,this,event,publisher,null,this,event,publisher,publish,event,new,session,connected,event,this,message,byte,message,byte,bytes,this,stomp,encoder,encode,message,byte,message,text,message,text,message,new,text,message,bytes,session,send,message,text,message,catch,session,limit,exceeded,exception,ex,throw,ex,catch,throwable,ex,send,error,message,session,ex,finally,if,stomp,command,error,equals,headers,get,command,try,session,close,close,status,catch,ioexception,ex
StompSubProtocolHandler -> @SuppressWarnings("unchecked") 	@Override 	public void handleMessageToClient(WebSocketSession session, Message<?> message);1395721625;Handle STOMP messages going back out to WebSocket clients.;@SuppressWarnings("unchecked")_	@Override_	public void handleMessageToClient(WebSocketSession session, Message<?> message) {__		StompHeaderAccessor headers = StompHeaderAccessor.wrap(message)___		if (headers.getMessageType() == SimpMessageType.CONNECT_ACK) {_			StompHeaderAccessor connectedHeaders = StompHeaderAccessor.create(StompCommand.CONNECTED)__			connectedHeaders.setVersion(getVersion(headers))__			connectedHeaders.setHeartbeat(0, 0)_ _			headers = connectedHeaders__		}_		else if (SimpMessageType.MESSAGE.equals(headers.getMessageType())) {_			headers.updateStompCommandAsServerMessage()__		}__		if (headers.getCommand() == StompCommand.CONNECTED) {_			afterStompSessionConnected(headers, session)__		}__		if (StompCommand.MESSAGE.equals(headers.getCommand())) {_			if (headers.getSubscriptionId() == null) {_				logger.error("Ignoring message, no subscriptionId header: " + message)__				return__			}_			String header = UserDestinationMessageHandler.SUBSCRIBE_DESTINATION__			if (message.getHeaders().containsKey(header)) {_				headers.setDestination((String) message.getHeaders().get(header))__			}_		}__		if (!(message.getPayload() instanceof byte[])) {_			logger.error("Ignoring message, expected byte[] content: " + message)__			return__		}__		try {_			message = MessageBuilder.withPayload(message.getPayload()).setHeaders(headers).build()___			if (headers.getCommand() == StompCommand.CONNECTED && this.eventPublisher != null) {_				this.eventPublisher.publishEvent(new SessionConnectedEvent(this, (Message<byte[]>) message))__			}__			byte[] bytes = this.stompEncoder.encode((Message<byte[]>) message)__			TextMessage textMessage = new TextMessage(bytes)___			session.sendMessage(textMessage)__		}_		catch (SessionLimitExceededException ex) {_			_			throw ex__		}_		catch (Throwable ex) {_			sendErrorMessage(session, ex)__		}_		finally {_			if (StompCommand.ERROR.equals(headers.getCommand())) {_				try {_					session.close(CloseStatus.PROTOCOL_ERROR)__				}_				catch (IOException ex) {_					_				}_			}_		}_	};handle,stomp,messages,going,back,out,to,web,socket,clients;suppress,warnings,unchecked,override,public,void,handle,message,to,client,web,socket,session,session,message,message,stomp,header,accessor,headers,stomp,header,accessor,wrap,message,if,headers,get,message,type,simp,message,type,stomp,header,accessor,connected,headers,stomp,header,accessor,create,stomp,command,connected,connected,headers,set,version,get,version,headers,connected,headers,set,heartbeat,0,0,headers,connected,headers,else,if,simp,message,type,message,equals,headers,get,message,type,headers,update,stomp,command,as,server,message,if,headers,get,command,stomp,command,connected,after,stomp,session,connected,headers,session,if,stomp,command,message,equals,headers,get,command,if,headers,get,subscription,id,null,logger,error,ignoring,message,no,subscription,id,header,message,return,string,header,user,destination,message,handler,if,message,get,headers,contains,key,header,headers,set,destination,string,message,get,headers,get,header,if,message,get,payload,instanceof,byte,logger,error,ignoring,message,expected,byte,content,message,return,try,message,message,builder,with,payload,message,get,payload,set,headers,headers,build,if,headers,get,command,stomp,command,connected,this,event,publisher,null,this,event,publisher,publish,event,new,session,connected,event,this,message,byte,message,byte,bytes,this,stomp,encoder,encode,message,byte,message,text,message,text,message,new,text,message,bytes,session,send,message,text,message,catch,session,limit,exceeded,exception,ex,throw,ex,catch,throwable,ex,send,error,message,session,ex,finally,if,stomp,command,error,equals,headers,get,command,try,session,close,close,status,catch,ioexception,ex
StompSubProtocolHandler -> @SuppressWarnings("unchecked") 	@Override 	public void handleMessageToClient(WebSocketSession session, Message<?> message);1395752742;Handle STOMP messages going back out to WebSocket clients.;@SuppressWarnings("unchecked")_	@Override_	public void handleMessageToClient(WebSocketSession session, Message<?> message) {__		StompHeaderAccessor headers = StompHeaderAccessor.wrap(message)___		if (headers.getMessageType() == SimpMessageType.CONNECT_ACK) {_			StompHeaderAccessor connectedHeaders = StompHeaderAccessor.create(StompCommand.CONNECTED)__			connectedHeaders.setVersion(getVersion(headers))__			connectedHeaders.setHeartbeat(0, 0)_ _			headers = connectedHeaders__		}_		else if (SimpMessageType.MESSAGE.equals(headers.getMessageType())) {_			headers.updateStompCommandAsServerMessage()__		}__		if (headers.getCommand() == StompCommand.CONNECTED) {_			afterStompSessionConnected(headers, session)__		}__		if (StompCommand.MESSAGE.equals(headers.getCommand())) {_			if (headers.getSubscriptionId() == null) {_				logger.error("Ignoring message, no subscriptionId header: " + message)__				return__			}_			String header = UserDestinationMessageHandler.SUBSCRIBE_DESTINATION__			if (message.getHeaders().containsKey(header)) {_				headers.setDestination((String) message.getHeaders().get(header))__			}_		}__		if (!(message.getPayload() instanceof byte[])) {_			logger.error("Ignoring message, expected byte[] content: " + message)__			return__		}__		try {_			message = MessageBuilder.withPayload(message.getPayload()).setHeaders(headers).build()___			if (this.eventPublisher != null && StompCommand.CONNECTED.equals(headers.getMessageType())) {_				publishEvent(new SessionConnectedEvent(this, (Message<byte[]>) message))__			}__			byte[] bytes = this.stompEncoder.encode((Message<byte[]>) message)__			TextMessage textMessage = new TextMessage(bytes)___			session.sendMessage(textMessage)__		}_		catch (SessionLimitExceededException ex) {_			_			throw ex__		}_		catch (Throwable ex) {_			sendErrorMessage(session, ex)__		}_		finally {_			if (StompCommand.ERROR.equals(headers.getCommand())) {_				try {_					session.close(CloseStatus.PROTOCOL_ERROR)__				}_				catch (IOException ex) {_					_				}_			}_		}_	};handle,stomp,messages,going,back,out,to,web,socket,clients;suppress,warnings,unchecked,override,public,void,handle,message,to,client,web,socket,session,session,message,message,stomp,header,accessor,headers,stomp,header,accessor,wrap,message,if,headers,get,message,type,simp,message,type,stomp,header,accessor,connected,headers,stomp,header,accessor,create,stomp,command,connected,connected,headers,set,version,get,version,headers,connected,headers,set,heartbeat,0,0,headers,connected,headers,else,if,simp,message,type,message,equals,headers,get,message,type,headers,update,stomp,command,as,server,message,if,headers,get,command,stomp,command,connected,after,stomp,session,connected,headers,session,if,stomp,command,message,equals,headers,get,command,if,headers,get,subscription,id,null,logger,error,ignoring,message,no,subscription,id,header,message,return,string,header,user,destination,message,handler,if,message,get,headers,contains,key,header,headers,set,destination,string,message,get,headers,get,header,if,message,get,payload,instanceof,byte,logger,error,ignoring,message,expected,byte,content,message,return,try,message,message,builder,with,payload,message,get,payload,set,headers,headers,build,if,this,event,publisher,null,stomp,command,connected,equals,headers,get,message,type,publish,event,new,session,connected,event,this,message,byte,message,byte,bytes,this,stomp,encoder,encode,message,byte,message,text,message,text,message,new,text,message,bytes,session,send,message,text,message,catch,session,limit,exceeded,exception,ex,throw,ex,catch,throwable,ex,send,error,message,session,ex,finally,if,stomp,command,error,equals,headers,get,command,try,session,close,close,status,catch,ioexception,ex
StompSubProtocolHandler -> @SuppressWarnings("unchecked") 	@Override 	public void handleMessageToClient(WebSocketSession session, Message<?> message);1395755949;Handle STOMP messages going back out to WebSocket clients.;@SuppressWarnings("unchecked")_	@Override_	public void handleMessageToClient(WebSocketSession session, Message<?> message) {__		StompHeaderAccessor headers = StompHeaderAccessor.wrap(message)___		if (headers.getMessageType() == SimpMessageType.CONNECT_ACK) {_			StompHeaderAccessor connectedHeaders = StompHeaderAccessor.create(StompCommand.CONNECTED)__			connectedHeaders.setVersion(getVersion(headers))__			connectedHeaders.setHeartbeat(0, 0)_ _			headers = connectedHeaders__		}_		else if (SimpMessageType.MESSAGE.equals(headers.getMessageType())) {_			headers.updateStompCommandAsServerMessage()__		}__		if (headers.getCommand() == StompCommand.CONNECTED) {_			afterStompSessionConnected(headers, session)__		}__		if (StompCommand.MESSAGE.equals(headers.getCommand())) {_			if (headers.getSubscriptionId() == null) {_				logger.error("Ignoring message, no subscriptionId header: " + message)__				return__			}_			String header = UserDestinationMessageHandler.SUBSCRIBE_DESTINATION__			if (message.getHeaders().containsKey(header)) {_				headers.setDestination((String) message.getHeaders().get(header))__			}_		}__		if (!(message.getPayload() instanceof byte[])) {_			logger.error("Ignoring message, expected byte[] content: " + message)__			return__		}__		try {_			message = MessageBuilder.withPayload(message.getPayload()).setHeaders(headers).build()___			if (this.eventPublisher != null && StompCommand.CONNECTED.equals(headers.getCommand())) {_				publishEvent(new SessionConnectedEvent(this, (Message<byte[]>) message))__			}__			byte[] bytes = this.stompEncoder.encode((Message<byte[]>) message)__			TextMessage textMessage = new TextMessage(bytes)___			session.sendMessage(textMessage)__		}_		catch (SessionLimitExceededException ex) {_			_			throw ex__		}_		catch (Throwable ex) {_			sendErrorMessage(session, ex)__		}_		finally {_			if (StompCommand.ERROR.equals(headers.getCommand())) {_				try {_					session.close(CloseStatus.PROTOCOL_ERROR)__				}_				catch (IOException ex) {_					_				}_			}_		}_	};handle,stomp,messages,going,back,out,to,web,socket,clients;suppress,warnings,unchecked,override,public,void,handle,message,to,client,web,socket,session,session,message,message,stomp,header,accessor,headers,stomp,header,accessor,wrap,message,if,headers,get,message,type,simp,message,type,stomp,header,accessor,connected,headers,stomp,header,accessor,create,stomp,command,connected,connected,headers,set,version,get,version,headers,connected,headers,set,heartbeat,0,0,headers,connected,headers,else,if,simp,message,type,message,equals,headers,get,message,type,headers,update,stomp,command,as,server,message,if,headers,get,command,stomp,command,connected,after,stomp,session,connected,headers,session,if,stomp,command,message,equals,headers,get,command,if,headers,get,subscription,id,null,logger,error,ignoring,message,no,subscription,id,header,message,return,string,header,user,destination,message,handler,if,message,get,headers,contains,key,header,headers,set,destination,string,message,get,headers,get,header,if,message,get,payload,instanceof,byte,logger,error,ignoring,message,expected,byte,content,message,return,try,message,message,builder,with,payload,message,get,payload,set,headers,headers,build,if,this,event,publisher,null,stomp,command,connected,equals,headers,get,command,publish,event,new,session,connected,event,this,message,byte,message,byte,bytes,this,stomp,encoder,encode,message,byte,message,text,message,text,message,new,text,message,bytes,session,send,message,text,message,catch,session,limit,exceeded,exception,ex,throw,ex,catch,throwable,ex,send,error,message,session,ex,finally,if,stomp,command,error,equals,headers,get,command,try,session,close,close,status,catch,ioexception,ex
StompSubProtocolHandler -> @SuppressWarnings("unchecked") 	@Override 	public void handleMessageToClient(WebSocketSession session, Message<?> message);1395847954;Handle STOMP messages going back out to WebSocket clients.;@SuppressWarnings("unchecked")_	@Override_	public void handleMessageToClient(WebSocketSession session, Message<?> message) {__		StompHeaderAccessor headers = StompHeaderAccessor.wrap(message)___		if (headers.getMessageType() == SimpMessageType.CONNECT_ACK) {_			StompHeaderAccessor connectedHeaders = StompHeaderAccessor.create(StompCommand.CONNECTED)__			connectedHeaders.setVersion(getVersion(headers))__			connectedHeaders.setHeartbeat(0, 0)_ _			headers = connectedHeaders__		}_		else if (SimpMessageType.MESSAGE.equals(headers.getMessageType())) {_			headers.updateStompCommandAsServerMessage()__		}__		if (headers.getCommand() == StompCommand.CONNECTED) {_			afterStompSessionConnected(headers, session)__		}__		if (StompCommand.MESSAGE.equals(headers.getCommand())) {_			if (headers.getSubscriptionId() == null) {_				logger.error("Ignoring message, no subscriptionId header: " + message)__				return__			}_			String header = UserDestinationMessageHandler.SUBSCRIBE_DESTINATION__			if (message.getHeaders().containsKey(header)) {_				headers.setDestination((String) message.getHeaders().get(header))__			}_		}__		if (!(message.getPayload() instanceof byte[])) {_			logger.error("Ignoring message, expected byte[] content: " + message)__			return__		}__		try {_			message = MessageBuilder.withPayload(message.getPayload()).setHeaders(headers).build()___			if (this.eventPublisher != null && StompCommand.CONNECTED.equals(headers.getCommand())) {_				publishEvent(new SessionConnectedEvent(this, (Message<byte[]>) message))__			}__			byte[] bytes = this.stompEncoder.encode((Message<byte[]>) message)__			TextMessage textMessage = new TextMessage(bytes)___			session.sendMessage(textMessage)__		}_		catch (SessionLimitExceededException ex) {_			_			throw ex__		}_		catch (Throwable ex) {_			sendErrorMessage(session, ex)__		}_		finally {_			if (StompCommand.ERROR.equals(headers.getCommand())) {_				try {_					session.close(CloseStatus.PROTOCOL_ERROR)__				}_				catch (IOException ex) {_					_				}_			}_		}_	};handle,stomp,messages,going,back,out,to,web,socket,clients;suppress,warnings,unchecked,override,public,void,handle,message,to,client,web,socket,session,session,message,message,stomp,header,accessor,headers,stomp,header,accessor,wrap,message,if,headers,get,message,type,simp,message,type,stomp,header,accessor,connected,headers,stomp,header,accessor,create,stomp,command,connected,connected,headers,set,version,get,version,headers,connected,headers,set,heartbeat,0,0,headers,connected,headers,else,if,simp,message,type,message,equals,headers,get,message,type,headers,update,stomp,command,as,server,message,if,headers,get,command,stomp,command,connected,after,stomp,session,connected,headers,session,if,stomp,command,message,equals,headers,get,command,if,headers,get,subscription,id,null,logger,error,ignoring,message,no,subscription,id,header,message,return,string,header,user,destination,message,handler,if,message,get,headers,contains,key,header,headers,set,destination,string,message,get,headers,get,header,if,message,get,payload,instanceof,byte,logger,error,ignoring,message,expected,byte,content,message,return,try,message,message,builder,with,payload,message,get,payload,set,headers,headers,build,if,this,event,publisher,null,stomp,command,connected,equals,headers,get,command,publish,event,new,session,connected,event,this,message,byte,message,byte,bytes,this,stomp,encoder,encode,message,byte,message,text,message,text,message,new,text,message,bytes,session,send,message,text,message,catch,session,limit,exceeded,exception,ex,throw,ex,catch,throwable,ex,send,error,message,session,ex,finally,if,stomp,command,error,equals,headers,get,command,try,session,close,close,status,catch,ioexception,ex
StompSubProtocolHandler -> @SuppressWarnings("unchecked") 	@Override 	public void handleMessageToClient(WebSocketSession session, Message<?> message);1396578670;Handle STOMP messages going back out to WebSocket clients.;@SuppressWarnings("unchecked")_	@Override_	public void handleMessageToClient(WebSocketSession session, Message<?> message) {__		StompHeaderAccessor headers = StompHeaderAccessor.wrap(message)___		if (headers.getMessageType() == SimpMessageType.CONNECT_ACK) {_			StompHeaderAccessor connectedHeaders = StompHeaderAccessor.create(StompCommand.CONNECTED)__			connectedHeaders.setVersion(getVersion(headers))__			connectedHeaders.setHeartbeat(0, 0)_ _			headers = connectedHeaders__		}_		else if (SimpMessageType.MESSAGE.equals(headers.getMessageType())) {_			headers.updateStompCommandAsServerMessage()__		}__		if (headers.getCommand() == StompCommand.CONNECTED) {_			afterStompSessionConnected(headers, session)__		}__		if (StompCommand.MESSAGE.equals(headers.getCommand())) {_			if (headers.getSubscriptionId() == null) {_				logger.error("Ignoring message, no subscriptionId header: " + message)__				return__			}_			String header = UserDestinationMessageHandler.SUBSCRIBE_DESTINATION__			if (message.getHeaders().containsKey(header)) {_				headers.setDestination((String) message.getHeaders().get(header))__			}_		}__		if (!(message.getPayload() instanceof byte[])) {_			logger.error("Ignoring message, expected byte[] content: " + message)__			return__		}__		try {_			message = MessageBuilder.withPayload(message.getPayload()).setHeaders(headers).build()___			if (this.eventPublisher != null && StompCommand.CONNECTED.equals(headers.getCommand())) {_				publishEvent(new SessionConnectedEvent(this, (Message<byte[]>) message))__			}__			byte[] bytes = this.stompEncoder.encode((Message<byte[]>) message)__			TextMessage textMessage = new TextMessage(bytes)___			session.sendMessage(textMessage)__		}_		catch (SessionLimitExceededException ex) {_			_			throw ex__		}_		catch (Throwable ex) {_			sendErrorMessage(session, ex)__		}_		finally {_			if (StompCommand.ERROR.equals(headers.getCommand())) {_				try {_					session.close(CloseStatus.PROTOCOL_ERROR)__				}_				catch (IOException ex) {_					_				}_			}_		}_	};handle,stomp,messages,going,back,out,to,web,socket,clients;suppress,warnings,unchecked,override,public,void,handle,message,to,client,web,socket,session,session,message,message,stomp,header,accessor,headers,stomp,header,accessor,wrap,message,if,headers,get,message,type,simp,message,type,stomp,header,accessor,connected,headers,stomp,header,accessor,create,stomp,command,connected,connected,headers,set,version,get,version,headers,connected,headers,set,heartbeat,0,0,headers,connected,headers,else,if,simp,message,type,message,equals,headers,get,message,type,headers,update,stomp,command,as,server,message,if,headers,get,command,stomp,command,connected,after,stomp,session,connected,headers,session,if,stomp,command,message,equals,headers,get,command,if,headers,get,subscription,id,null,logger,error,ignoring,message,no,subscription,id,header,message,return,string,header,user,destination,message,handler,if,message,get,headers,contains,key,header,headers,set,destination,string,message,get,headers,get,header,if,message,get,payload,instanceof,byte,logger,error,ignoring,message,expected,byte,content,message,return,try,message,message,builder,with,payload,message,get,payload,set,headers,headers,build,if,this,event,publisher,null,stomp,command,connected,equals,headers,get,command,publish,event,new,session,connected,event,this,message,byte,message,byte,bytes,this,stomp,encoder,encode,message,byte,message,text,message,text,message,new,text,message,bytes,session,send,message,text,message,catch,session,limit,exceeded,exception,ex,throw,ex,catch,throwable,ex,send,error,message,session,ex,finally,if,stomp,command,error,equals,headers,get,command,try,session,close,close,status,catch,ioexception,ex
StompSubProtocolHandler -> @SuppressWarnings("unchecked") 	@Override 	public void handleMessageToClient(WebSocketSession session, Message<?> message);1396636309;Handle STOMP messages going back out to WebSocket clients.;@SuppressWarnings("unchecked")_	@Override_	public void handleMessageToClient(WebSocketSession session, Message<?> message) {__		StompHeaderAccessor headers = StompHeaderAccessor.wrap(message)___		if (headers.getMessageType() == SimpMessageType.CONNECT_ACK) {_			StompHeaderAccessor connectedHeaders = StompHeaderAccessor.create(StompCommand.CONNECTED)__			connectedHeaders.setVersion(getVersion(headers))__			connectedHeaders.setHeartbeat(0, 0)_ _			headers = connectedHeaders__		}_		else if (SimpMessageType.MESSAGE.equals(headers.getMessageType())) {_			headers.updateStompCommandAsServerMessage()__		}__		if (headers.getCommand() == StompCommand.CONNECTED) {_			afterStompSessionConnected(headers, session)__		}__		if (StompCommand.MESSAGE.equals(headers.getCommand())) {_			if (headers.getSubscriptionId() == null) {_				logger.error("Ignoring message, no subscriptionId header: " + message)__				return__			}_			String header = SimpMessageHeaderAccessor.ORIGINAL_DESTINATION__			if (message.getHeaders().containsKey(header)) {_				headers.setDestination((String) message.getHeaders().get(header))__			}_		}__		if (!(message.getPayload() instanceof byte[])) {_			logger.error("Ignoring message, expected byte[] content: " + message)__			return__		}__		try {_			message = MessageBuilder.withPayload(message.getPayload()).setHeaders(headers).build()___			if (this.eventPublisher != null && StompCommand.CONNECTED.equals(headers.getCommand())) {_				publishEvent(new SessionConnectedEvent(this, (Message<byte[]>) message))__			}__			byte[] bytes = this.stompEncoder.encode((Message<byte[]>) message)__			TextMessage textMessage = new TextMessage(bytes)___			session.sendMessage(textMessage)__		}_		catch (SessionLimitExceededException ex) {_			_			throw ex__		}_		catch (Throwable ex) {_			sendErrorMessage(session, ex)__		}_		finally {_			if (StompCommand.ERROR.equals(headers.getCommand())) {_				try {_					session.close(CloseStatus.PROTOCOL_ERROR)__				}_				catch (IOException ex) {_					_				}_			}_		}_	};handle,stomp,messages,going,back,out,to,web,socket,clients;suppress,warnings,unchecked,override,public,void,handle,message,to,client,web,socket,session,session,message,message,stomp,header,accessor,headers,stomp,header,accessor,wrap,message,if,headers,get,message,type,simp,message,type,stomp,header,accessor,connected,headers,stomp,header,accessor,create,stomp,command,connected,connected,headers,set,version,get,version,headers,connected,headers,set,heartbeat,0,0,headers,connected,headers,else,if,simp,message,type,message,equals,headers,get,message,type,headers,update,stomp,command,as,server,message,if,headers,get,command,stomp,command,connected,after,stomp,session,connected,headers,session,if,stomp,command,message,equals,headers,get,command,if,headers,get,subscription,id,null,logger,error,ignoring,message,no,subscription,id,header,message,return,string,header,simp,message,header,accessor,if,message,get,headers,contains,key,header,headers,set,destination,string,message,get,headers,get,header,if,message,get,payload,instanceof,byte,logger,error,ignoring,message,expected,byte,content,message,return,try,message,message,builder,with,payload,message,get,payload,set,headers,headers,build,if,this,event,publisher,null,stomp,command,connected,equals,headers,get,command,publish,event,new,session,connected,event,this,message,byte,message,byte,bytes,this,stomp,encoder,encode,message,byte,message,text,message,text,message,new,text,message,bytes,session,send,message,text,message,catch,session,limit,exceeded,exception,ex,throw,ex,catch,throwable,ex,send,error,message,session,ex,finally,if,stomp,command,error,equals,headers,get,command,try,session,close,close,status,catch,ioexception,ex
StompSubProtocolHandler -> @SuppressWarnings("unchecked") 	@Override 	public void handleMessageToClient(WebSocketSession session, Message<?> message);1397429525;Handle STOMP messages going back out to WebSocket clients.;@SuppressWarnings("unchecked")_	@Override_	public void handleMessageToClient(WebSocketSession session, Message<?> message) {__		if (!(message.getPayload() instanceof byte[])) {_			logger.error("Ignoring message, expected byte[] content: " + message)__			return__		}__		MessageHeaderAccessor accessor = MessageHeaderAccessor.getAccessor(message, MessageHeaderAccessor.class)__		if (accessor == null) {_			logger.error("No header accessor: " + message)__			return__		}__		StompHeaderAccessor stompAccessor__		if (accessor instanceof StompHeaderAccessor) {_			stompAccessor = (StompHeaderAccessor) accessor__		}_		else if (accessor instanceof SimpMessageHeaderAccessor) {_			stompAccessor = StompHeaderAccessor.wrap(message)__			if (SimpMessageType.CONNECT_ACK.equals(stompAccessor.getMessageType())) {_				StompHeaderAccessor connectedHeaders = StompHeaderAccessor.create(StompCommand.CONNECTED)__				connectedHeaders.setVersion(getVersion(stompAccessor))__				connectedHeaders.setHeartbeat(0, 0)_ _				stompAccessor = connectedHeaders__			}_			else if (stompAccessor.getCommand() == null || StompCommand.SEND.equals(stompAccessor.getCommand())) {_				stompAccessor.updateStompCommandAsServerMessage()__			}_		}_		else {_			_			logger.error("Unexpected header accessor type: " + accessor)__			return__		}__		StompCommand command = stompAccessor.getCommand()__		if (StompCommand.MESSAGE.equals(command)) {_			if (stompAccessor.getSubscriptionId() == null) {_				logger.error("Ignoring message, no subscriptionId header: " + message)__				return__			}_			String header = SimpMessageHeaderAccessor.ORIGINAL_DESTINATION__			if (message.getHeaders().containsKey(header)) {_				stompAccessor = toMutableAccessor(stompAccessor, message)__				stompAccessor.setDestination((String) message.getHeaders().get(header))__			}_		}_		else if (StompCommand.CONNECTED.equals(command)) {_			stompAccessor = afterStompSessionConnected(message, stompAccessor, session)__			if (this.eventPublisher != null && StompCommand.CONNECTED.equals(command)) {_				publishEvent(new SessionConnectedEvent(this, (Message<byte[]>) message))__			}_		}__		try {_			byte[] bytes = this.stompEncoder.encode(stompAccessor.getMessageHeaders(), (byte[]) message.getPayload())__			TextMessage textMessage = new TextMessage(bytes)___			session.sendMessage(textMessage)__		}_		catch (SessionLimitExceededException ex) {_			_			throw ex__		}_		catch (Throwable ex) {_			sendErrorMessage(session, ex)__		}_		finally {_			if (StompCommand.ERROR.equals(command)) {_				try {_					session.close(CloseStatus.PROTOCOL_ERROR)__				}_				catch (IOException ex) {_					_				}_			}_		}_	};handle,stomp,messages,going,back,out,to,web,socket,clients;suppress,warnings,unchecked,override,public,void,handle,message,to,client,web,socket,session,session,message,message,if,message,get,payload,instanceof,byte,logger,error,ignoring,message,expected,byte,content,message,return,message,header,accessor,accessor,message,header,accessor,get,accessor,message,message,header,accessor,class,if,accessor,null,logger,error,no,header,accessor,message,return,stomp,header,accessor,stomp,accessor,if,accessor,instanceof,stomp,header,accessor,stomp,accessor,stomp,header,accessor,accessor,else,if,accessor,instanceof,simp,message,header,accessor,stomp,accessor,stomp,header,accessor,wrap,message,if,simp,message,type,equals,stomp,accessor,get,message,type,stomp,header,accessor,connected,headers,stomp,header,accessor,create,stomp,command,connected,connected,headers,set,version,get,version,stomp,accessor,connected,headers,set,heartbeat,0,0,stomp,accessor,connected,headers,else,if,stomp,accessor,get,command,null,stomp,command,send,equals,stomp,accessor,get,command,stomp,accessor,update,stomp,command,as,server,message,else,logger,error,unexpected,header,accessor,type,accessor,return,stomp,command,command,stomp,accessor,get,command,if,stomp,command,message,equals,command,if,stomp,accessor,get,subscription,id,null,logger,error,ignoring,message,no,subscription,id,header,message,return,string,header,simp,message,header,accessor,if,message,get,headers,contains,key,header,stomp,accessor,to,mutable,accessor,stomp,accessor,message,stomp,accessor,set,destination,string,message,get,headers,get,header,else,if,stomp,command,connected,equals,command,stomp,accessor,after,stomp,session,connected,message,stomp,accessor,session,if,this,event,publisher,null,stomp,command,connected,equals,command,publish,event,new,session,connected,event,this,message,byte,message,try,byte,bytes,this,stomp,encoder,encode,stomp,accessor,get,message,headers,byte,message,get,payload,text,message,text,message,new,text,message,bytes,session,send,message,text,message,catch,session,limit,exceeded,exception,ex,throw,ex,catch,throwable,ex,send,error,message,session,ex,finally,if,stomp,command,error,equals,command,try,session,close,close,status,catch,ioexception,ex
StompSubProtocolHandler -> @SuppressWarnings("unchecked") 	@Override 	public void handleMessageToClient(WebSocketSession session, Message<?> message);1397439322;Handle STOMP messages going back out to WebSocket clients.;@SuppressWarnings("unchecked")_	@Override_	public void handleMessageToClient(WebSocketSession session, Message<?> message) {__		if (!(message.getPayload() instanceof byte[])) {_			logger.error("Ignoring message, expected byte[] content: " + message)__			return__		}__		MessageHeaderAccessor accessor = MessageHeaderAccessor.getAccessor(message, MessageHeaderAccessor.class)__		if (accessor == null) {_			logger.error("No header accessor: " + message)__			return__		}__		StompHeaderAccessor stompAccessor__		if (accessor instanceof StompHeaderAccessor) {_			stompAccessor = (StompHeaderAccessor) accessor__		}_		else if (accessor instanceof SimpMessageHeaderAccessor) {_			stompAccessor = StompHeaderAccessor.wrap(message)__			if (SimpMessageType.CONNECT_ACK.equals(stompAccessor.getMessageType())) {_				StompHeaderAccessor connectedHeaders = StompHeaderAccessor.create(StompCommand.CONNECTED)__				connectedHeaders.setVersion(getVersion(stompAccessor))__				connectedHeaders.setHeartbeat(0, 0)_ _				stompAccessor = connectedHeaders__			}_			else if (stompAccessor.getCommand() == null || StompCommand.SEND.equals(stompAccessor.getCommand())) {_				stompAccessor.updateStompCommandAsServerMessage()__			}_		}_		else {_			_			logger.error("Unexpected header accessor type: " + accessor)__			return__		}__		StompCommand command = stompAccessor.getCommand()__		if (StompCommand.MESSAGE.equals(command)) {_			if (stompAccessor.getSubscriptionId() == null) {_				logger.error("Ignoring message, no subscriptionId header: " + message)__				return__			}_			String header = SimpMessageHeaderAccessor.ORIGINAL_DESTINATION__			if (message.getHeaders().containsKey(header)) {_				stompAccessor = toMutableAccessor(stompAccessor, message)__				stompAccessor.setDestination((String) message.getHeaders().get(header))__			}_		}_		else if (StompCommand.CONNECTED.equals(command)) {_			stompAccessor = afterStompSessionConnected(message, stompAccessor, session)__			if (this.eventPublisher != null && StompCommand.CONNECTED.equals(command)) {_				publishEvent(new SessionConnectedEvent(this, (Message<byte[]>) message))__			}_		}__		try {_			byte[] bytes = this.stompEncoder.encode(stompAccessor.getMessageHeaders(), (byte[]) message.getPayload())__			TextMessage textMessage = new TextMessage(bytes)___			session.sendMessage(textMessage)__		}_		catch (SessionLimitExceededException ex) {_			_			throw ex__		}_		catch (Throwable ex) {_			sendErrorMessage(session, ex)__		}_		finally {_			if (StompCommand.ERROR.equals(command)) {_				try {_					session.close(CloseStatus.PROTOCOL_ERROR)__				}_				catch (IOException ex) {_					_				}_			}_		}_	};handle,stomp,messages,going,back,out,to,web,socket,clients;suppress,warnings,unchecked,override,public,void,handle,message,to,client,web,socket,session,session,message,message,if,message,get,payload,instanceof,byte,logger,error,ignoring,message,expected,byte,content,message,return,message,header,accessor,accessor,message,header,accessor,get,accessor,message,message,header,accessor,class,if,accessor,null,logger,error,no,header,accessor,message,return,stomp,header,accessor,stomp,accessor,if,accessor,instanceof,stomp,header,accessor,stomp,accessor,stomp,header,accessor,accessor,else,if,accessor,instanceof,simp,message,header,accessor,stomp,accessor,stomp,header,accessor,wrap,message,if,simp,message,type,equals,stomp,accessor,get,message,type,stomp,header,accessor,connected,headers,stomp,header,accessor,create,stomp,command,connected,connected,headers,set,version,get,version,stomp,accessor,connected,headers,set,heartbeat,0,0,stomp,accessor,connected,headers,else,if,stomp,accessor,get,command,null,stomp,command,send,equals,stomp,accessor,get,command,stomp,accessor,update,stomp,command,as,server,message,else,logger,error,unexpected,header,accessor,type,accessor,return,stomp,command,command,stomp,accessor,get,command,if,stomp,command,message,equals,command,if,stomp,accessor,get,subscription,id,null,logger,error,ignoring,message,no,subscription,id,header,message,return,string,header,simp,message,header,accessor,if,message,get,headers,contains,key,header,stomp,accessor,to,mutable,accessor,stomp,accessor,message,stomp,accessor,set,destination,string,message,get,headers,get,header,else,if,stomp,command,connected,equals,command,stomp,accessor,after,stomp,session,connected,message,stomp,accessor,session,if,this,event,publisher,null,stomp,command,connected,equals,command,publish,event,new,session,connected,event,this,message,byte,message,try,byte,bytes,this,stomp,encoder,encode,stomp,accessor,get,message,headers,byte,message,get,payload,text,message,text,message,new,text,message,bytes,session,send,message,text,message,catch,session,limit,exceeded,exception,ex,throw,ex,catch,throwable,ex,send,error,message,session,ex,finally,if,stomp,command,error,equals,command,try,session,close,close,status,catch,ioexception,ex
StompSubProtocolHandler -> @SuppressWarnings("unchecked") 	@Override 	public void handleMessageToClient(WebSocketSession session, Message<?> message);1397523793;Handle STOMP messages going back out to WebSocket clients.;@SuppressWarnings("unchecked")_	@Override_	public void handleMessageToClient(WebSocketSession session, Message<?> message) {__		if (!(message.getPayload() instanceof byte[])) {_			logger.error("Ignoring message, expected byte[] content: " + message)__			return__		}__		MessageHeaderAccessor accessor = MessageHeaderAccessor.getAccessor(message, MessageHeaderAccessor.class)__		if (accessor == null) {_			logger.error("No header accessor: " + message)__			return__		}__		StompHeaderAccessor stompAccessor__		if (accessor instanceof StompHeaderAccessor) {_			stompAccessor = (StompHeaderAccessor) accessor__		}_		else if (accessor instanceof SimpMessageHeaderAccessor) {_			stompAccessor = StompHeaderAccessor.wrap(message)__			if (SimpMessageType.CONNECT_ACK.equals(stompAccessor.getMessageType())) {_				StompHeaderAccessor connectedHeaders = StompHeaderAccessor.create(StompCommand.CONNECTED)__				connectedHeaders.setVersion(getVersion(stompAccessor))__				connectedHeaders.setHeartbeat(0, 0)_ _				stompAccessor = connectedHeaders__			}_			else if (stompAccessor.getCommand() == null || StompCommand.SEND.equals(stompAccessor.getCommand())) {_				stompAccessor.updateStompCommandAsServerMessage()__			}_		}_		else {_			_			logger.error("Unexpected header accessor type: " + accessor)__			return__		}__		StompCommand command = stompAccessor.getCommand()__		if (StompCommand.MESSAGE.equals(command)) {_			if (stompAccessor.getSubscriptionId() == null) {_				logger.error("Ignoring message, no subscriptionId header: " + message)__				return__			}_			String header = SimpMessageHeaderAccessor.ORIGINAL_DESTINATION__			if (message.getHeaders().containsKey(header)) {_				stompAccessor = toMutableAccessor(stompAccessor, message)__				stompAccessor.setDestination((String) message.getHeaders().get(header))__			}_		}_		else if (StompCommand.CONNECTED.equals(command)) {_			stompAccessor = afterStompSessionConnected(message, stompAccessor, session)__			if (this.eventPublisher != null && StompCommand.CONNECTED.equals(command)) {_				publishEvent(new SessionConnectedEvent(this, (Message<byte[]>) message))__			}_		}__		try {_			byte[] bytes = this.stompEncoder.encode(stompAccessor.getMessageHeaders(), (byte[]) message.getPayload())__			TextMessage textMessage = new TextMessage(bytes)___			session.sendMessage(textMessage)__		}_		catch (SessionLimitExceededException ex) {_			_			throw ex__		}_		catch (Throwable ex) {_			sendErrorMessage(session, ex)__		}_		finally {_			if (StompCommand.ERROR.equals(command)) {_				try {_					session.close(CloseStatus.PROTOCOL_ERROR)__				}_				catch (IOException ex) {_					_				}_			}_		}_	};handle,stomp,messages,going,back,out,to,web,socket,clients;suppress,warnings,unchecked,override,public,void,handle,message,to,client,web,socket,session,session,message,message,if,message,get,payload,instanceof,byte,logger,error,ignoring,message,expected,byte,content,message,return,message,header,accessor,accessor,message,header,accessor,get,accessor,message,message,header,accessor,class,if,accessor,null,logger,error,no,header,accessor,message,return,stomp,header,accessor,stomp,accessor,if,accessor,instanceof,stomp,header,accessor,stomp,accessor,stomp,header,accessor,accessor,else,if,accessor,instanceof,simp,message,header,accessor,stomp,accessor,stomp,header,accessor,wrap,message,if,simp,message,type,equals,stomp,accessor,get,message,type,stomp,header,accessor,connected,headers,stomp,header,accessor,create,stomp,command,connected,connected,headers,set,version,get,version,stomp,accessor,connected,headers,set,heartbeat,0,0,stomp,accessor,connected,headers,else,if,stomp,accessor,get,command,null,stomp,command,send,equals,stomp,accessor,get,command,stomp,accessor,update,stomp,command,as,server,message,else,logger,error,unexpected,header,accessor,type,accessor,return,stomp,command,command,stomp,accessor,get,command,if,stomp,command,message,equals,command,if,stomp,accessor,get,subscription,id,null,logger,error,ignoring,message,no,subscription,id,header,message,return,string,header,simp,message,header,accessor,if,message,get,headers,contains,key,header,stomp,accessor,to,mutable,accessor,stomp,accessor,message,stomp,accessor,set,destination,string,message,get,headers,get,header,else,if,stomp,command,connected,equals,command,stomp,accessor,after,stomp,session,connected,message,stomp,accessor,session,if,this,event,publisher,null,stomp,command,connected,equals,command,publish,event,new,session,connected,event,this,message,byte,message,try,byte,bytes,this,stomp,encoder,encode,stomp,accessor,get,message,headers,byte,message,get,payload,text,message,text,message,new,text,message,bytes,session,send,message,text,message,catch,session,limit,exceeded,exception,ex,throw,ex,catch,throwable,ex,send,error,message,session,ex,finally,if,stomp,command,error,equals,command,try,session,close,close,status,catch,ioexception,ex
StompSubProtocolHandler -> @SuppressWarnings("unchecked") 	@Override 	public void handleMessageToClient(WebSocketSession session, Message<?> message);1398443164;Handle STOMP messages going back out to WebSocket clients.;@SuppressWarnings("unchecked")_	@Override_	public void handleMessageToClient(WebSocketSession session, Message<?> message) {__		if (!(message.getPayload() instanceof byte[])) {_			logger.error("Ignoring message, expected byte[] content: " + message)__			return__		}__		MessageHeaderAccessor accessor = MessageHeaderAccessor.getAccessor(message, MessageHeaderAccessor.class)__		if (accessor == null) {_			logger.error("No header accessor: " + message)__			return__		}__		StompHeaderAccessor stompAccessor__		if (accessor instanceof StompHeaderAccessor) {_			stompAccessor = (StompHeaderAccessor) accessor__		}_		else if (accessor instanceof SimpMessageHeaderAccessor) {_			stompAccessor = StompHeaderAccessor.wrap(message)__			if (SimpMessageType.CONNECT_ACK.equals(stompAccessor.getMessageType())) {_				StompHeaderAccessor connectedHeaders = StompHeaderAccessor.create(StompCommand.CONNECTED)__				connectedHeaders.setVersion(getVersion(stompAccessor))__				connectedHeaders.setHeartbeat(0, 0)_ _				stompAccessor = connectedHeaders__			}_			else if (stompAccessor.getCommand() == null || StompCommand.SEND.equals(stompAccessor.getCommand())) {_				stompAccessor.updateStompCommandAsServerMessage()__			}_		}_		else {_			_			logger.error("Unexpected header accessor type: " + accessor)__			return__		}__		StompCommand command = stompAccessor.getCommand()__		if (StompCommand.MESSAGE.equals(command)) {_			if (stompAccessor.getSubscriptionId() == null) {_				logger.error("Ignoring message, no subscriptionId header: " + message)__				return__			}_			String origDestination = stompAccessor.getFirstNativeHeader(SimpMessageHeaderAccessor.ORIGINAL_DESTINATION)__			if (origDestination != null) {_				stompAccessor = toMutableAccessor(stompAccessor, message)__				stompAccessor.setDestination(origDestination)__			}_		}_		else if (StompCommand.CONNECTED.equals(command)) {_			stompAccessor = afterStompSessionConnected(message, stompAccessor, session)__			if (this.eventPublisher != null && StompCommand.CONNECTED.equals(command)) {_				publishEvent(new SessionConnectedEvent(this, (Message<byte[]>) message))__			}_		}__		try {_			byte[] bytes = this.stompEncoder.encode(stompAccessor.getMessageHeaders(), (byte[]) message.getPayload())__			TextMessage textMessage = new TextMessage(bytes)___			session.sendMessage(textMessage)__		}_		catch (SessionLimitExceededException ex) {_			_			throw ex__		}_		catch (Throwable ex) {_			sendErrorMessage(session, ex)__		}_		finally {_			if (StompCommand.ERROR.equals(command)) {_				try {_					session.close(CloseStatus.PROTOCOL_ERROR)__				}_				catch (IOException ex) {_					_				}_			}_		}_	};handle,stomp,messages,going,back,out,to,web,socket,clients;suppress,warnings,unchecked,override,public,void,handle,message,to,client,web,socket,session,session,message,message,if,message,get,payload,instanceof,byte,logger,error,ignoring,message,expected,byte,content,message,return,message,header,accessor,accessor,message,header,accessor,get,accessor,message,message,header,accessor,class,if,accessor,null,logger,error,no,header,accessor,message,return,stomp,header,accessor,stomp,accessor,if,accessor,instanceof,stomp,header,accessor,stomp,accessor,stomp,header,accessor,accessor,else,if,accessor,instanceof,simp,message,header,accessor,stomp,accessor,stomp,header,accessor,wrap,message,if,simp,message,type,equals,stomp,accessor,get,message,type,stomp,header,accessor,connected,headers,stomp,header,accessor,create,stomp,command,connected,connected,headers,set,version,get,version,stomp,accessor,connected,headers,set,heartbeat,0,0,stomp,accessor,connected,headers,else,if,stomp,accessor,get,command,null,stomp,command,send,equals,stomp,accessor,get,command,stomp,accessor,update,stomp,command,as,server,message,else,logger,error,unexpected,header,accessor,type,accessor,return,stomp,command,command,stomp,accessor,get,command,if,stomp,command,message,equals,command,if,stomp,accessor,get,subscription,id,null,logger,error,ignoring,message,no,subscription,id,header,message,return,string,orig,destination,stomp,accessor,get,first,native,header,simp,message,header,accessor,if,orig,destination,null,stomp,accessor,to,mutable,accessor,stomp,accessor,message,stomp,accessor,set,destination,orig,destination,else,if,stomp,command,connected,equals,command,stomp,accessor,after,stomp,session,connected,message,stomp,accessor,session,if,this,event,publisher,null,stomp,command,connected,equals,command,publish,event,new,session,connected,event,this,message,byte,message,try,byte,bytes,this,stomp,encoder,encode,stomp,accessor,get,message,headers,byte,message,get,payload,text,message,text,message,new,text,message,bytes,session,send,message,text,message,catch,session,limit,exceeded,exception,ex,throw,ex,catch,throwable,ex,send,error,message,session,ex,finally,if,stomp,command,error,equals,command,try,session,close,close,status,catch,ioexception,ex
StompSubProtocolHandler -> @SuppressWarnings("unchecked") 	@Override 	public void handleMessageToClient(WebSocketSession session, Message<?> message);1399601217;Handle STOMP messages going back out to WebSocket clients.;@SuppressWarnings("unchecked")_	@Override_	public void handleMessageToClient(WebSocketSession session, Message<?> message) {__		if (!(message.getPayload() instanceof byte[])) {_			logger.error("Ignoring message, expected byte[] content: " + message)__			return__		}__		MessageHeaderAccessor accessor = MessageHeaderAccessor.getAccessor(message, MessageHeaderAccessor.class)__		if (accessor == null) {_			logger.error("No header accessor: " + message)__			return__		}__		StompHeaderAccessor stompAccessor__		if (accessor instanceof StompHeaderAccessor) {_			stompAccessor = (StompHeaderAccessor) accessor__		}_		else if (accessor instanceof SimpMessageHeaderAccessor) {_			stompAccessor = StompHeaderAccessor.wrap(message)__			if (SimpMessageType.CONNECT_ACK.equals(stompAccessor.getMessageType())) {_				StompHeaderAccessor connectedHeaders = StompHeaderAccessor.create(StompCommand.CONNECTED)__				connectedHeaders.setVersion(getVersion(stompAccessor))__				connectedHeaders.setHeartbeat(0, 0)_ _				stompAccessor = connectedHeaders__			}_			else if (stompAccessor.getCommand() == null || StompCommand.SEND.equals(stompAccessor.getCommand())) {_				stompAccessor.updateStompCommandAsServerMessage()__			}_		}_		else {_			_			logger.error("Unexpected header accessor type: " + accessor)__			return__		}__		StompCommand command = stompAccessor.getCommand()__		if (StompCommand.MESSAGE.equals(command)) {_			if (stompAccessor.getSubscriptionId() == null) {_				logger.error("Ignoring message, no subscriptionId header: " + message)__				return__			}_			String origDestination = stompAccessor.getFirstNativeHeader(SimpMessageHeaderAccessor.ORIGINAL_DESTINATION)__			if (origDestination != null) {_				stompAccessor = toMutableAccessor(stompAccessor, message)__				stompAccessor.removeNativeHeader(SimpMessageHeaderAccessor.ORIGINAL_DESTINATION)__				stompAccessor.setDestination(origDestination)__			}_		}_		else if (StompCommand.CONNECTED.equals(command)) {_			stompAccessor = afterStompSessionConnected(message, stompAccessor, session)__			if (this.eventPublisher != null && StompCommand.CONNECTED.equals(command)) {_				publishEvent(new SessionConnectedEvent(this, (Message<byte[]>) message))__			}_		}__		try {_			byte[] bytes = this.stompEncoder.encode(stompAccessor.getMessageHeaders(), (byte[]) message.getPayload())__			TextMessage textMessage = new TextMessage(bytes)___			session.sendMessage(textMessage)__		}_		catch (SessionLimitExceededException ex) {_			_			throw ex__		}_		catch (Throwable ex) {_			sendErrorMessage(session, ex)__		}_		finally {_			if (StompCommand.ERROR.equals(command)) {_				try {_					session.close(CloseStatus.PROTOCOL_ERROR)__				}_				catch (IOException ex) {_					_				}_			}_		}_	};handle,stomp,messages,going,back,out,to,web,socket,clients;suppress,warnings,unchecked,override,public,void,handle,message,to,client,web,socket,session,session,message,message,if,message,get,payload,instanceof,byte,logger,error,ignoring,message,expected,byte,content,message,return,message,header,accessor,accessor,message,header,accessor,get,accessor,message,message,header,accessor,class,if,accessor,null,logger,error,no,header,accessor,message,return,stomp,header,accessor,stomp,accessor,if,accessor,instanceof,stomp,header,accessor,stomp,accessor,stomp,header,accessor,accessor,else,if,accessor,instanceof,simp,message,header,accessor,stomp,accessor,stomp,header,accessor,wrap,message,if,simp,message,type,equals,stomp,accessor,get,message,type,stomp,header,accessor,connected,headers,stomp,header,accessor,create,stomp,command,connected,connected,headers,set,version,get,version,stomp,accessor,connected,headers,set,heartbeat,0,0,stomp,accessor,connected,headers,else,if,stomp,accessor,get,command,null,stomp,command,send,equals,stomp,accessor,get,command,stomp,accessor,update,stomp,command,as,server,message,else,logger,error,unexpected,header,accessor,type,accessor,return,stomp,command,command,stomp,accessor,get,command,if,stomp,command,message,equals,command,if,stomp,accessor,get,subscription,id,null,logger,error,ignoring,message,no,subscription,id,header,message,return,string,orig,destination,stomp,accessor,get,first,native,header,simp,message,header,accessor,if,orig,destination,null,stomp,accessor,to,mutable,accessor,stomp,accessor,message,stomp,accessor,remove,native,header,simp,message,header,accessor,stomp,accessor,set,destination,orig,destination,else,if,stomp,command,connected,equals,command,stomp,accessor,after,stomp,session,connected,message,stomp,accessor,session,if,this,event,publisher,null,stomp,command,connected,equals,command,publish,event,new,session,connected,event,this,message,byte,message,try,byte,bytes,this,stomp,encoder,encode,stomp,accessor,get,message,headers,byte,message,get,payload,text,message,text,message,new,text,message,bytes,session,send,message,text,message,catch,session,limit,exceeded,exception,ex,throw,ex,catch,throwable,ex,send,error,message,session,ex,finally,if,stomp,command,error,equals,command,try,session,close,close,status,catch,ioexception,ex
StompSubProtocolHandler -> @SuppressWarnings("unchecked") 	@Override 	public void handleMessageToClient(WebSocketSession session, Message<?> message);1399825877;Handle STOMP messages going back out to WebSocket clients.;@SuppressWarnings("unchecked")_	@Override_	public void handleMessageToClient(WebSocketSession session, Message<?> message) {__		if (!(message.getPayload() instanceof byte[])) {_			logger.error("Ignoring message, expected byte[] content: " + message)__			return__		}__		MessageHeaderAccessor accessor = MessageHeaderAccessor.getAccessor(message, MessageHeaderAccessor.class)__		if (accessor == null) {_			logger.error("No header accessor: " + message)__			return__		}__		StompHeaderAccessor stompAccessor__		if (accessor instanceof StompHeaderAccessor) {_			stompAccessor = (StompHeaderAccessor) accessor__		}_		else if (accessor instanceof SimpMessageHeaderAccessor) {_			stompAccessor = StompHeaderAccessor.wrap(message)__			if (SimpMessageType.CONNECT_ACK.equals(stompAccessor.getMessageType())) {_				StompHeaderAccessor connectedHeaders = StompHeaderAccessor.create(StompCommand.CONNECTED)__				connectedHeaders.setVersion(getVersion(stompAccessor))__				connectedHeaders.setHeartbeat(0, 0)_ _				stompAccessor = connectedHeaders__			}_			else if (stompAccessor.getCommand() == null || StompCommand.SEND.equals(stompAccessor.getCommand())) {_				stompAccessor.updateStompCommandAsServerMessage()__			}_		}_		else {_			_			logger.error("Unexpected header accessor type: " + accessor)__			return__		}__		StompCommand command = stompAccessor.getCommand()__		if (StompCommand.MESSAGE.equals(command)) {_			if (stompAccessor.getSubscriptionId() == null) {_				logger.error("Ignoring message, no subscriptionId header: " + message)__				return__			}_			String origDestination = stompAccessor.getFirstNativeHeader(SimpMessageHeaderAccessor.ORIGINAL_DESTINATION)__			if (origDestination != null) {_				stompAccessor = toMutableAccessor(stompAccessor, message)__				stompAccessor.removeNativeHeader(SimpMessageHeaderAccessor.ORIGINAL_DESTINATION)__				stompAccessor.setDestination(origDestination)__			}_		}_		else if (StompCommand.CONNECTED.equals(command)) {_			stompAccessor = afterStompSessionConnected(message, stompAccessor, session)__			if (this.eventPublisher != null && StompCommand.CONNECTED.equals(command)) {_				publishEvent(new SessionConnectedEvent(this, (Message<byte[]>) message))__			}_		}__		try {_			byte[] bytes = this.stompEncoder.encode(stompAccessor.getMessageHeaders(), (byte[]) message.getPayload())__			TextMessage textMessage = new TextMessage(bytes)___			session.sendMessage(textMessage)__		}_		catch (SessionLimitExceededException ex) {_			_			throw ex__		}_		catch (Throwable ex) {_			sendErrorMessage(session, ex)__		}_		finally {_			if (StompCommand.ERROR.equals(command)) {_				try {_					session.close(CloseStatus.PROTOCOL_ERROR)__				}_				catch (IOException ex) {_					_				}_			}_		}_	};handle,stomp,messages,going,back,out,to,web,socket,clients;suppress,warnings,unchecked,override,public,void,handle,message,to,client,web,socket,session,session,message,message,if,message,get,payload,instanceof,byte,logger,error,ignoring,message,expected,byte,content,message,return,message,header,accessor,accessor,message,header,accessor,get,accessor,message,message,header,accessor,class,if,accessor,null,logger,error,no,header,accessor,message,return,stomp,header,accessor,stomp,accessor,if,accessor,instanceof,stomp,header,accessor,stomp,accessor,stomp,header,accessor,accessor,else,if,accessor,instanceof,simp,message,header,accessor,stomp,accessor,stomp,header,accessor,wrap,message,if,simp,message,type,equals,stomp,accessor,get,message,type,stomp,header,accessor,connected,headers,stomp,header,accessor,create,stomp,command,connected,connected,headers,set,version,get,version,stomp,accessor,connected,headers,set,heartbeat,0,0,stomp,accessor,connected,headers,else,if,stomp,accessor,get,command,null,stomp,command,send,equals,stomp,accessor,get,command,stomp,accessor,update,stomp,command,as,server,message,else,logger,error,unexpected,header,accessor,type,accessor,return,stomp,command,command,stomp,accessor,get,command,if,stomp,command,message,equals,command,if,stomp,accessor,get,subscription,id,null,logger,error,ignoring,message,no,subscription,id,header,message,return,string,orig,destination,stomp,accessor,get,first,native,header,simp,message,header,accessor,if,orig,destination,null,stomp,accessor,to,mutable,accessor,stomp,accessor,message,stomp,accessor,remove,native,header,simp,message,header,accessor,stomp,accessor,set,destination,orig,destination,else,if,stomp,command,connected,equals,command,stomp,accessor,after,stomp,session,connected,message,stomp,accessor,session,if,this,event,publisher,null,stomp,command,connected,equals,command,publish,event,new,session,connected,event,this,message,byte,message,try,byte,bytes,this,stomp,encoder,encode,stomp,accessor,get,message,headers,byte,message,get,payload,text,message,text,message,new,text,message,bytes,session,send,message,text,message,catch,session,limit,exceeded,exception,ex,throw,ex,catch,throwable,ex,send,error,message,session,ex,finally,if,stomp,command,error,equals,command,try,session,close,close,status,catch,ioexception,ex
StompSubProtocolHandler -> @SuppressWarnings("unchecked") 	@Override 	public void handleMessageToClient(WebSocketSession session, Message<?> message);1403719829;Handle STOMP messages going back out to WebSocket clients.;@SuppressWarnings("unchecked")_	@Override_	public void handleMessageToClient(WebSocketSession session, Message<?> message) {__		if (!(message.getPayload() instanceof byte[])) {_			logger.error("Ignoring message, expected byte[] content: " + message)__			return__		}__		MessageHeaderAccessor accessor = MessageHeaderAccessor.getAccessor(message, MessageHeaderAccessor.class)__		if (accessor == null) {_			logger.error("No header accessor: " + message)__			return__		}__		StompHeaderAccessor stompAccessor__		if (accessor instanceof StompHeaderAccessor) {_			stompAccessor = (StompHeaderAccessor) accessor__		}_		else if (accessor instanceof SimpMessageHeaderAccessor) {_			stompAccessor = StompHeaderAccessor.wrap(message)__			if (SimpMessageType.CONNECT_ACK.equals(stompAccessor.getMessageType())) {_				StompHeaderAccessor connectedHeaders = StompHeaderAccessor.create(StompCommand.CONNECTED)__				connectedHeaders.setVersion(getVersion(stompAccessor))__				connectedHeaders.setHeartbeat(0, 0)_ _				stompAccessor = connectedHeaders__			}_			else if (stompAccessor.getCommand() == null || StompCommand.SEND.equals(stompAccessor.getCommand())) {_				stompAccessor.updateStompCommandAsServerMessage()__			}_		}_		else {_			_			logger.error("Unexpected header accessor type: " + accessor)__			return__		}__		StompCommand command = stompAccessor.getCommand()__		if (StompCommand.MESSAGE.equals(command)) {_			if (stompAccessor.getSubscriptionId() == null) {_				logger.error("Ignoring message, no subscriptionId header: " + message)__				return__			}_			String origDestination = stompAccessor.getFirstNativeHeader(SimpMessageHeaderAccessor.ORIGINAL_DESTINATION)__			if (origDestination != null) {_				stompAccessor = toMutableAccessor(stompAccessor, message)__				stompAccessor.removeNativeHeader(SimpMessageHeaderAccessor.ORIGINAL_DESTINATION)__				stompAccessor.setDestination(origDestination)__			}_		}_		else if (StompCommand.CONNECTED.equals(command)) {_			stompAccessor = afterStompSessionConnected(message, stompAccessor, session)__			if (this.eventPublisher != null && StompCommand.CONNECTED.equals(command)) {_				publishEvent(new SessionConnectedEvent(this, (Message<byte[]>) message))__			}_		}__		try {_			byte[] bytes = this.stompEncoder.encode(stompAccessor.getMessageHeaders(), (byte[]) message.getPayload())__			TextMessage textMessage = new TextMessage(bytes)___			session.sendMessage(textMessage)__		}_		catch (SessionLimitExceededException ex) {_			_			throw ex__		}_		catch (Throwable ex) {_			logger.error("Failed to send WebSocket message to client, sessionId=" + session.getId(), ex)__			command = StompCommand.ERROR__		}_		finally {_			if (StompCommand.ERROR.equals(command)) {_				try {_					session.close(CloseStatus.PROTOCOL_ERROR)__				}_				catch (IOException ex) {_					_				}_			}_		}_	};handle,stomp,messages,going,back,out,to,web,socket,clients;suppress,warnings,unchecked,override,public,void,handle,message,to,client,web,socket,session,session,message,message,if,message,get,payload,instanceof,byte,logger,error,ignoring,message,expected,byte,content,message,return,message,header,accessor,accessor,message,header,accessor,get,accessor,message,message,header,accessor,class,if,accessor,null,logger,error,no,header,accessor,message,return,stomp,header,accessor,stomp,accessor,if,accessor,instanceof,stomp,header,accessor,stomp,accessor,stomp,header,accessor,accessor,else,if,accessor,instanceof,simp,message,header,accessor,stomp,accessor,stomp,header,accessor,wrap,message,if,simp,message,type,equals,stomp,accessor,get,message,type,stomp,header,accessor,connected,headers,stomp,header,accessor,create,stomp,command,connected,connected,headers,set,version,get,version,stomp,accessor,connected,headers,set,heartbeat,0,0,stomp,accessor,connected,headers,else,if,stomp,accessor,get,command,null,stomp,command,send,equals,stomp,accessor,get,command,stomp,accessor,update,stomp,command,as,server,message,else,logger,error,unexpected,header,accessor,type,accessor,return,stomp,command,command,stomp,accessor,get,command,if,stomp,command,message,equals,command,if,stomp,accessor,get,subscription,id,null,logger,error,ignoring,message,no,subscription,id,header,message,return,string,orig,destination,stomp,accessor,get,first,native,header,simp,message,header,accessor,if,orig,destination,null,stomp,accessor,to,mutable,accessor,stomp,accessor,message,stomp,accessor,remove,native,header,simp,message,header,accessor,stomp,accessor,set,destination,orig,destination,else,if,stomp,command,connected,equals,command,stomp,accessor,after,stomp,session,connected,message,stomp,accessor,session,if,this,event,publisher,null,stomp,command,connected,equals,command,publish,event,new,session,connected,event,this,message,byte,message,try,byte,bytes,this,stomp,encoder,encode,stomp,accessor,get,message,headers,byte,message,get,payload,text,message,text,message,new,text,message,bytes,session,send,message,text,message,catch,session,limit,exceeded,exception,ex,throw,ex,catch,throwable,ex,logger,error,failed,to,send,web,socket,message,to,client,session,id,session,get,id,ex,command,stomp,command,error,finally,if,stomp,command,error,equals,command,try,session,close,close,status,catch,ioexception,ex
StompSubProtocolHandler -> @SuppressWarnings("unchecked") 	@Override 	public void handleMessageToClient(WebSocketSession session, Message<?> message);1403856366;Handle STOMP messages going back out to WebSocket clients.;@SuppressWarnings("unchecked")_	@Override_	public void handleMessageToClient(WebSocketSession session, Message<?> message) {_		if (!(message.getPayload() instanceof byte[])) {_			logger.error("Expected byte[] payload. Ignoring " + message + ".")__			return__		}_		StompHeaderAccessor stompAccessor = getStompHeaderAccessor(message)__		StompCommand command = stompAccessor.getCommand()__		if (StompCommand.MESSAGE.equals(command)) {_			if (stompAccessor.getSubscriptionId() == null) {_				if (logger.isWarnEnabled()) {_					logger.warn("No STOMP \"subscription\" header in " + message)__				}_			}_			String origDestination = stompAccessor.getFirstNativeHeader(SimpMessageHeaderAccessor.ORIGINAL_DESTINATION)__			if (origDestination != null) {_				stompAccessor = toMutableAccessor(stompAccessor, message)__				stompAccessor.removeNativeHeader(SimpMessageHeaderAccessor.ORIGINAL_DESTINATION)__				stompAccessor.setDestination(origDestination)__			}_		}_		else if (StompCommand.CONNECTED.equals(command)) {_			stompAccessor = afterStompSessionConnected(message, stompAccessor, session)__			if (this.eventPublisher != null && StompCommand.CONNECTED.equals(command)) {_				publishEvent(new SessionConnectedEvent(this, (Message<byte[]>) message))__			}_		}_		try {_			byte[] bytes = this.stompEncoder.encode(stompAccessor.getMessageHeaders(), (byte[]) message.getPayload())__			session.sendMessage(new TextMessage(bytes))__		}_		catch (SessionLimitExceededException ex) {_			_			throw ex__		}_		catch (Throwable ex) {_			logger.error("Failed to send WebSocket message to client in session " + session.getId() + ".", ex)__			command = StompCommand.ERROR__		}_		finally {_			if (StompCommand.ERROR.equals(command)) {_				try {_					session.close(CloseStatus.PROTOCOL_ERROR)__				}_				catch (IOException ex) {_					_				}_			}_		}_	};handle,stomp,messages,going,back,out,to,web,socket,clients;suppress,warnings,unchecked,override,public,void,handle,message,to,client,web,socket,session,session,message,message,if,message,get,payload,instanceof,byte,logger,error,expected,byte,payload,ignoring,message,return,stomp,header,accessor,stomp,accessor,get,stomp,header,accessor,message,stomp,command,command,stomp,accessor,get,command,if,stomp,command,message,equals,command,if,stomp,accessor,get,subscription,id,null,if,logger,is,warn,enabled,logger,warn,no,stomp,subscription,header,in,message,string,orig,destination,stomp,accessor,get,first,native,header,simp,message,header,accessor,if,orig,destination,null,stomp,accessor,to,mutable,accessor,stomp,accessor,message,stomp,accessor,remove,native,header,simp,message,header,accessor,stomp,accessor,set,destination,orig,destination,else,if,stomp,command,connected,equals,command,stomp,accessor,after,stomp,session,connected,message,stomp,accessor,session,if,this,event,publisher,null,stomp,command,connected,equals,command,publish,event,new,session,connected,event,this,message,byte,message,try,byte,bytes,this,stomp,encoder,encode,stomp,accessor,get,message,headers,byte,message,get,payload,session,send,message,new,text,message,bytes,catch,session,limit,exceeded,exception,ex,throw,ex,catch,throwable,ex,logger,error,failed,to,send,web,socket,message,to,client,in,session,session,get,id,ex,command,stomp,command,error,finally,if,stomp,command,error,equals,command,try,session,close,close,status,catch,ioexception,ex
StompSubProtocolHandler -> @SuppressWarnings("unchecked") 	@Override 	public void handleMessageToClient(WebSocketSession session, Message<?> message);1403968062;Handle STOMP messages going back out to WebSocket clients.;@SuppressWarnings("unchecked")_	@Override_	public void handleMessageToClient(WebSocketSession session, Message<?> message) {_		if (!(message.getPayload() instanceof byte[])) {_			logger.error("Expected byte[] payload. Ignoring " + message + ".")__			return__		}_		StompHeaderAccessor stompAccessor = getStompHeaderAccessor(message)__		StompCommand command = stompAccessor.getCommand()__		if (StompCommand.MESSAGE.equals(command)) {_			if (stompAccessor.getSubscriptionId() == null) {_				if (logger.isWarnEnabled()) {_					logger.warn("No STOMP \"subscription\" header in " + message)__				}_			}_			String origDestination = stompAccessor.getFirstNativeHeader(SimpMessageHeaderAccessor.ORIGINAL_DESTINATION)__			if (origDestination != null) {_				stompAccessor = toMutableAccessor(stompAccessor, message)__				stompAccessor.removeNativeHeader(SimpMessageHeaderAccessor.ORIGINAL_DESTINATION)__				stompAccessor.setDestination(origDestination)__			}_		}_		else if (StompCommand.CONNECTED.equals(command)) {_			stompAccessor = afterStompSessionConnected(message, stompAccessor, session)__			if (this.eventPublisher != null && StompCommand.CONNECTED.equals(command)) {_				publishEvent(new SessionConnectedEvent(this, (Message<byte[]>) message))__			}_		}_		try {_			byte[] bytes = this.stompEncoder.encode(stompAccessor.getMessageHeaders(), (byte[]) message.getPayload())__			session.sendMessage(new TextMessage(bytes))__		}_		catch (SessionLimitExceededException ex) {_			_			throw ex__		}_		catch (Throwable ex) {_			logger.error("Failed to send WebSocket message to client in session " + session.getId() + ".", ex)__			command = StompCommand.ERROR__		}_		finally {_			if (StompCommand.ERROR.equals(command)) {_				try {_					session.close(CloseStatus.PROTOCOL_ERROR)__				}_				catch (IOException ex) {_					_				}_			}_		}_	};handle,stomp,messages,going,back,out,to,web,socket,clients;suppress,warnings,unchecked,override,public,void,handle,message,to,client,web,socket,session,session,message,message,if,message,get,payload,instanceof,byte,logger,error,expected,byte,payload,ignoring,message,return,stomp,header,accessor,stomp,accessor,get,stomp,header,accessor,message,stomp,command,command,stomp,accessor,get,command,if,stomp,command,message,equals,command,if,stomp,accessor,get,subscription,id,null,if,logger,is,warn,enabled,logger,warn,no,stomp,subscription,header,in,message,string,orig,destination,stomp,accessor,get,first,native,header,simp,message,header,accessor,if,orig,destination,null,stomp,accessor,to,mutable,accessor,stomp,accessor,message,stomp,accessor,remove,native,header,simp,message,header,accessor,stomp,accessor,set,destination,orig,destination,else,if,stomp,command,connected,equals,command,stomp,accessor,after,stomp,session,connected,message,stomp,accessor,session,if,this,event,publisher,null,stomp,command,connected,equals,command,publish,event,new,session,connected,event,this,message,byte,message,try,byte,bytes,this,stomp,encoder,encode,stomp,accessor,get,message,headers,byte,message,get,payload,session,send,message,new,text,message,bytes,catch,session,limit,exceeded,exception,ex,throw,ex,catch,throwable,ex,logger,error,failed,to,send,web,socket,message,to,client,in,session,session,get,id,ex,command,stomp,command,error,finally,if,stomp,command,error,equals,command,try,session,close,close,status,catch,ioexception,ex
StompSubProtocolHandler -> @SuppressWarnings("unchecked") 	@Override 	public void handleMessageToClient(WebSocketSession session, Message<?> message);1404880787;Handle STOMP messages going back out to WebSocket clients.;@SuppressWarnings("unchecked")_	@Override_	public void handleMessageToClient(WebSocketSession session, Message<?> message) {_		if (!(message.getPayload() instanceof byte[])) {_			logger.error("Expected byte[] payload. Ignoring " + message + ".")__			return__		}_		StompHeaderAccessor stompAccessor = getStompHeaderAccessor(message)__		StompCommand command = stompAccessor.getCommand()__		if (StompCommand.MESSAGE.equals(command)) {_			if (stompAccessor.getSubscriptionId() == null) {_				if (logger.isWarnEnabled()) {_					logger.warn("No STOMP \"subscription\" header in " + message)__				}_			}_			String origDestination = stompAccessor.getFirstNativeHeader(SimpMessageHeaderAccessor.ORIGINAL_DESTINATION)__			if (origDestination != null) {_				stompAccessor = toMutableAccessor(stompAccessor, message)__				stompAccessor.removeNativeHeader(SimpMessageHeaderAccessor.ORIGINAL_DESTINATION)__				stompAccessor.setDestination(origDestination)__			}_		}_		else if (StompCommand.CONNECTED.equals(command)) {_			this.stats.incrementConnectedCount()__			stompAccessor = afterStompSessionConnected(message, stompAccessor, session)__			if (this.eventPublisher != null && StompCommand.CONNECTED.equals(command)) {_				publishEvent(new SessionConnectedEvent(this, (Message<byte[]>) message))__			}_		}_		try {_			byte[] bytes = this.stompEncoder.encode(stompAccessor.getMessageHeaders(), (byte[]) message.getPayload())__			session.sendMessage(new TextMessage(bytes))__		}_		catch (SessionLimitExceededException ex) {_			_			throw ex__		}_		catch (Throwable ex) {_			logger.error("Failed to send WebSocket message to client in session " + session.getId() + ".", ex)__			command = StompCommand.ERROR__		}_		finally {_			if (StompCommand.ERROR.equals(command)) {_				try {_					session.close(CloseStatus.PROTOCOL_ERROR)__				}_				catch (IOException ex) {_					_				}_			}_		}_	};handle,stomp,messages,going,back,out,to,web,socket,clients;suppress,warnings,unchecked,override,public,void,handle,message,to,client,web,socket,session,session,message,message,if,message,get,payload,instanceof,byte,logger,error,expected,byte,payload,ignoring,message,return,stomp,header,accessor,stomp,accessor,get,stomp,header,accessor,message,stomp,command,command,stomp,accessor,get,command,if,stomp,command,message,equals,command,if,stomp,accessor,get,subscription,id,null,if,logger,is,warn,enabled,logger,warn,no,stomp,subscription,header,in,message,string,orig,destination,stomp,accessor,get,first,native,header,simp,message,header,accessor,if,orig,destination,null,stomp,accessor,to,mutable,accessor,stomp,accessor,message,stomp,accessor,remove,native,header,simp,message,header,accessor,stomp,accessor,set,destination,orig,destination,else,if,stomp,command,connected,equals,command,this,stats,increment,connected,count,stomp,accessor,after,stomp,session,connected,message,stomp,accessor,session,if,this,event,publisher,null,stomp,command,connected,equals,command,publish,event,new,session,connected,event,this,message,byte,message,try,byte,bytes,this,stomp,encoder,encode,stomp,accessor,get,message,headers,byte,message,get,payload,session,send,message,new,text,message,bytes,catch,session,limit,exceeded,exception,ex,throw,ex,catch,throwable,ex,logger,error,failed,to,send,web,socket,message,to,client,in,session,session,get,id,ex,command,stomp,command,error,finally,if,stomp,command,error,equals,command,try,session,close,close,status,catch,ioexception,ex
StompSubProtocolHandler -> @SuppressWarnings("unchecked") 	@Override 	public void handleMessageToClient(WebSocketSession session, Message<?> message);1404880799;Handle STOMP messages going back out to WebSocket clients.;@SuppressWarnings("unchecked")_	@Override_	public void handleMessageToClient(WebSocketSession session, Message<?> message) {_		if (!(message.getPayload() instanceof byte[])) {_			logger.error("Expected byte[] payload. Ignoring " + message + ".")__			return__		}_		StompHeaderAccessor stompAccessor = getStompHeaderAccessor(message)__		StompCommand command = stompAccessor.getCommand()__		if (StompCommand.MESSAGE.equals(command)) {_			if (stompAccessor.getSubscriptionId() == null) {_				logger.warn("No STOMP \"subscription\" header in " + message)__			}_			String origDestination = stompAccessor.getFirstNativeHeader(SimpMessageHeaderAccessor.ORIGINAL_DESTINATION)__			if (origDestination != null) {_				stompAccessor = toMutableAccessor(stompAccessor, message)__				stompAccessor.removeNativeHeader(SimpMessageHeaderAccessor.ORIGINAL_DESTINATION)__				stompAccessor.setDestination(origDestination)__			}_		}_		else if (StompCommand.CONNECTED.equals(command)) {_			this.stats.incrementConnectedCount()__			stompAccessor = afterStompSessionConnected(message, stompAccessor, session)__			if (this.eventPublisher != null && StompCommand.CONNECTED.equals(command)) {_				publishEvent(new SessionConnectedEvent(this, (Message<byte[]>) message))__			}_		}_		try {_			byte[] bytes = this.stompEncoder.encode(stompAccessor.getMessageHeaders(), (byte[]) message.getPayload())__			session.sendMessage(new TextMessage(bytes))__		}_		catch (SessionLimitExceededException ex) {_			_			throw ex__		}_		catch (Throwable ex) {_			logger.error("Failed to send WebSocket message to client in session " + session.getId() + ".", ex)__			command = StompCommand.ERROR__		}_		finally {_			if (StompCommand.ERROR.equals(command)) {_				try {_					session.close(CloseStatus.PROTOCOL_ERROR)__				}_				catch (IOException ex) {_					_				}_			}_		}_	};handle,stomp,messages,going,back,out,to,web,socket,clients;suppress,warnings,unchecked,override,public,void,handle,message,to,client,web,socket,session,session,message,message,if,message,get,payload,instanceof,byte,logger,error,expected,byte,payload,ignoring,message,return,stomp,header,accessor,stomp,accessor,get,stomp,header,accessor,message,stomp,command,command,stomp,accessor,get,command,if,stomp,command,message,equals,command,if,stomp,accessor,get,subscription,id,null,logger,warn,no,stomp,subscription,header,in,message,string,orig,destination,stomp,accessor,get,first,native,header,simp,message,header,accessor,if,orig,destination,null,stomp,accessor,to,mutable,accessor,stomp,accessor,message,stomp,accessor,remove,native,header,simp,message,header,accessor,stomp,accessor,set,destination,orig,destination,else,if,stomp,command,connected,equals,command,this,stats,increment,connected,count,stomp,accessor,after,stomp,session,connected,message,stomp,accessor,session,if,this,event,publisher,null,stomp,command,connected,equals,command,publish,event,new,session,connected,event,this,message,byte,message,try,byte,bytes,this,stomp,encoder,encode,stomp,accessor,get,message,headers,byte,message,get,payload,session,send,message,new,text,message,bytes,catch,session,limit,exceeded,exception,ex,throw,ex,catch,throwable,ex,logger,error,failed,to,send,web,socket,message,to,client,in,session,session,get,id,ex,command,stomp,command,error,finally,if,stomp,command,error,equals,command,try,session,close,close,status,catch,ioexception,ex
StompSubProtocolHandler -> @SuppressWarnings("unchecked") 	@Override 	public void handleMessageToClient(WebSocketSession session, Message<?> message);1411067168;Handle STOMP messages going back out to WebSocket clients.;@SuppressWarnings("unchecked")_	@Override_	public void handleMessageToClient(WebSocketSession session, Message<?> message) {_		if (!(message.getPayload() instanceof byte[])) {_			logger.error("Expected byte[] payload. Ignoring " + message + ".")__			return__		}_		StompHeaderAccessor stompAccessor = getStompHeaderAccessor(message)__		StompCommand command = stompAccessor.getCommand()__		if (StompCommand.MESSAGE.equals(command)) {_			if (stompAccessor.getSubscriptionId() == null) {_				logger.warn("No STOMP \"subscription\" header in " + message)__			}_			String origDestination = stompAccessor.getFirstNativeHeader(SimpMessageHeaderAccessor.ORIGINAL_DESTINATION)__			if (origDestination != null) {_				stompAccessor = toMutableAccessor(stompAccessor, message)__				stompAccessor.removeNativeHeader(SimpMessageHeaderAccessor.ORIGINAL_DESTINATION)__				stompAccessor.setDestination(origDestination)__			}_		}_		else if (StompCommand.CONNECTED.equals(command)) {_			this.stats.incrementConnectedCount()__			stompAccessor = afterStompSessionConnected(message, stompAccessor, session)__			if (this.eventPublisher != null && StompCommand.CONNECTED.equals(command)) {_				publishEvent(new SessionConnectedEvent(this, (Message<byte[]>) message))__			}_		}_		try {_			byte[] bytes = this.stompEncoder.encode(stompAccessor.getMessageHeaders(), (byte[]) message.getPayload())__			session.sendMessage(new TextMessage(bytes))__		}_		catch (SessionLimitExceededException ex) {_			_			throw ex__		}_		catch (Throwable ex) {_			logger.error("Failed to send WebSocket message to client in session " + session.getId() + ".", ex)__			command = StompCommand.ERROR__		}_		finally {_			if (StompCommand.ERROR.equals(command)) {_				try {_					session.close(CloseStatus.PROTOCOL_ERROR)__				}_				catch (IOException ex) {_					_				}_			}_		}_	};handle,stomp,messages,going,back,out,to,web,socket,clients;suppress,warnings,unchecked,override,public,void,handle,message,to,client,web,socket,session,session,message,message,if,message,get,payload,instanceof,byte,logger,error,expected,byte,payload,ignoring,message,return,stomp,header,accessor,stomp,accessor,get,stomp,header,accessor,message,stomp,command,command,stomp,accessor,get,command,if,stomp,command,message,equals,command,if,stomp,accessor,get,subscription,id,null,logger,warn,no,stomp,subscription,header,in,message,string,orig,destination,stomp,accessor,get,first,native,header,simp,message,header,accessor,if,orig,destination,null,stomp,accessor,to,mutable,accessor,stomp,accessor,message,stomp,accessor,remove,native,header,simp,message,header,accessor,stomp,accessor,set,destination,orig,destination,else,if,stomp,command,connected,equals,command,this,stats,increment,connected,count,stomp,accessor,after,stomp,session,connected,message,stomp,accessor,session,if,this,event,publisher,null,stomp,command,connected,equals,command,publish,event,new,session,connected,event,this,message,byte,message,try,byte,bytes,this,stomp,encoder,encode,stomp,accessor,get,message,headers,byte,message,get,payload,session,send,message,new,text,message,bytes,catch,session,limit,exceeded,exception,ex,throw,ex,catch,throwable,ex,logger,error,failed,to,send,web,socket,message,to,client,in,session,session,get,id,ex,command,stomp,command,error,finally,if,stomp,command,error,equals,command,try,session,close,close,status,catch,ioexception,ex
StompSubProtocolHandler -> @SuppressWarnings("unchecked") 	@Override 	public void handleMessageToClient(WebSocketSession session, Message<?> message);1411068071;Handle STOMP messages going back out to WebSocket clients.;@SuppressWarnings("unchecked")_	@Override_	public void handleMessageToClient(WebSocketSession session, Message<?> message) {_		if (!(message.getPayload() instanceof byte[])) {_			logger.error("Expected byte[] payload. Ignoring " + message + ".")__			return__		}_		StompHeaderAccessor stompAccessor = getStompHeaderAccessor(message)__		StompCommand command = stompAccessor.getCommand()__		if (StompCommand.MESSAGE.equals(command)) {_			if (stompAccessor.getSubscriptionId() == null) {_				logger.warn("No STOMP \"subscription\" header in " + message)__			}_			String origDestination = stompAccessor.getFirstNativeHeader(SimpMessageHeaderAccessor.ORIGINAL_DESTINATION)__			if (origDestination != null) {_				stompAccessor = toMutableAccessor(stompAccessor, message)__				stompAccessor.removeNativeHeader(SimpMessageHeaderAccessor.ORIGINAL_DESTINATION)__				stompAccessor.setDestination(origDestination)__			}_		}_		else if (StompCommand.CONNECTED.equals(command)) {_			this.stats.incrementConnectedCount()__			stompAccessor = afterStompSessionConnected(message, stompAccessor, session)__			if (this.eventPublisher != null && StompCommand.CONNECTED.equals(command)) {_				publishEvent(new SessionConnectedEvent(this, (Message<byte[]>) message))__			}_		}_		try {_			byte[] bytes = this.stompEncoder.encode(stompAccessor.getMessageHeaders(), (byte[]) message.getPayload())__			session.sendMessage(new TextMessage(bytes))__		}_		catch (SessionLimitExceededException ex) {_			_			throw ex__		}_		catch (Throwable ex) {_			logger.error("Failed to send WebSocket message to client in session " + session.getId() + ".", ex)__			command = StompCommand.ERROR__		}_		finally {_			if (StompCommand.ERROR.equals(command)) {_				try {_					session.close(CloseStatus.PROTOCOL_ERROR)__				}_				catch (IOException ex) {_					_				}_			}_		}_	};handle,stomp,messages,going,back,out,to,web,socket,clients;suppress,warnings,unchecked,override,public,void,handle,message,to,client,web,socket,session,session,message,message,if,message,get,payload,instanceof,byte,logger,error,expected,byte,payload,ignoring,message,return,stomp,header,accessor,stomp,accessor,get,stomp,header,accessor,message,stomp,command,command,stomp,accessor,get,command,if,stomp,command,message,equals,command,if,stomp,accessor,get,subscription,id,null,logger,warn,no,stomp,subscription,header,in,message,string,orig,destination,stomp,accessor,get,first,native,header,simp,message,header,accessor,if,orig,destination,null,stomp,accessor,to,mutable,accessor,stomp,accessor,message,stomp,accessor,remove,native,header,simp,message,header,accessor,stomp,accessor,set,destination,orig,destination,else,if,stomp,command,connected,equals,command,this,stats,increment,connected,count,stomp,accessor,after,stomp,session,connected,message,stomp,accessor,session,if,this,event,publisher,null,stomp,command,connected,equals,command,publish,event,new,session,connected,event,this,message,byte,message,try,byte,bytes,this,stomp,encoder,encode,stomp,accessor,get,message,headers,byte,message,get,payload,session,send,message,new,text,message,bytes,catch,session,limit,exceeded,exception,ex,throw,ex,catch,throwable,ex,logger,error,failed,to,send,web,socket,message,to,client,in,session,session,get,id,ex,command,stomp,command,error,finally,if,stomp,command,error,equals,command,try,session,close,close,status,catch,ioexception,ex
StompSubProtocolHandler -> @SuppressWarnings("unchecked") 	@Override 	public void handleMessageToClient(WebSocketSession session, Message<?> message);1411148800;Handle STOMP messages going back out to WebSocket clients.;@SuppressWarnings("unchecked")_	@Override_	public void handleMessageToClient(WebSocketSession session, Message<?> message) {_		if (!(message.getPayload() instanceof byte[])) {_			logger.error("Expected byte[] payload. Ignoring " + message + ".")__			return__		}_		StompHeaderAccessor stompAccessor = getStompHeaderAccessor(message)__		StompCommand command = stompAccessor.getCommand()__		if (StompCommand.MESSAGE.equals(command)) {_			if (stompAccessor.getSubscriptionId() == null) {_				logger.warn("No STOMP \"subscription\" header in " + message)__			}_			String origDestination = stompAccessor.getFirstNativeHeader(SimpMessageHeaderAccessor.ORIGINAL_DESTINATION)__			if (origDestination != null) {_				stompAccessor = toMutableAccessor(stompAccessor, message)__				stompAccessor.removeNativeHeader(SimpMessageHeaderAccessor.ORIGINAL_DESTINATION)__				stompAccessor.setDestination(origDestination)__			}_		}_		else if (StompCommand.CONNECTED.equals(command)) {_			this.stats.incrementConnectedCount()__			stompAccessor = afterStompSessionConnected(message, stompAccessor, session)__			if (this.eventPublisher != null && StompCommand.CONNECTED.equals(command)) {_				try {_					SimpAttributes simpAttributes = new SimpAttributes(session.getId(), session.getAttributes())__					SimpAttributesContextHolder.setAttributes(simpAttributes)__					publishEvent(new SessionConnectedEvent(this, (Message<byte[]>) message))__				}_				finally {_					SimpAttributesContextHolder.resetAttributes()__				}_			}_		}_		try {_			byte[] bytes = this.stompEncoder.encode(stompAccessor.getMessageHeaders(), (byte[]) message.getPayload())__			session.sendMessage(new TextMessage(bytes))__		}_		catch (SessionLimitExceededException ex) {_			_			throw ex__		}_		catch (Throwable ex) {_			logger.error("Failed to send WebSocket message to client in session " + session.getId() + ".", ex)__			command = StompCommand.ERROR__		}_		finally {_			if (StompCommand.ERROR.equals(command)) {_				try {_					session.close(CloseStatus.PROTOCOL_ERROR)__				}_				catch (IOException ex) {_					_				}_			}_		}_	};handle,stomp,messages,going,back,out,to,web,socket,clients;suppress,warnings,unchecked,override,public,void,handle,message,to,client,web,socket,session,session,message,message,if,message,get,payload,instanceof,byte,logger,error,expected,byte,payload,ignoring,message,return,stomp,header,accessor,stomp,accessor,get,stomp,header,accessor,message,stomp,command,command,stomp,accessor,get,command,if,stomp,command,message,equals,command,if,stomp,accessor,get,subscription,id,null,logger,warn,no,stomp,subscription,header,in,message,string,orig,destination,stomp,accessor,get,first,native,header,simp,message,header,accessor,if,orig,destination,null,stomp,accessor,to,mutable,accessor,stomp,accessor,message,stomp,accessor,remove,native,header,simp,message,header,accessor,stomp,accessor,set,destination,orig,destination,else,if,stomp,command,connected,equals,command,this,stats,increment,connected,count,stomp,accessor,after,stomp,session,connected,message,stomp,accessor,session,if,this,event,publisher,null,stomp,command,connected,equals,command,try,simp,attributes,simp,attributes,new,simp,attributes,session,get,id,session,get,attributes,simp,attributes,context,holder,set,attributes,simp,attributes,publish,event,new,session,connected,event,this,message,byte,message,finally,simp,attributes,context,holder,reset,attributes,try,byte,bytes,this,stomp,encoder,encode,stomp,accessor,get,message,headers,byte,message,get,payload,session,send,message,new,text,message,bytes,catch,session,limit,exceeded,exception,ex,throw,ex,catch,throwable,ex,logger,error,failed,to,send,web,socket,message,to,client,in,session,session,get,id,ex,command,stomp,command,error,finally,if,stomp,command,error,equals,command,try,session,close,close,status,catch,ioexception,ex
StompSubProtocolHandler -> @SuppressWarnings("unchecked") 	@Override 	public void handleMessageToClient(WebSocketSession session, Message<?> message);1411567635;Handle STOMP messages going back out to WebSocket clients.;@SuppressWarnings("unchecked")_	@Override_	public void handleMessageToClient(WebSocketSession session, Message<?> message) {_		if (!(message.getPayload() instanceof byte[])) {_			logger.error("Expected byte[] payload. Ignoring " + message + ".")__			return__		}_		StompHeaderAccessor stompAccessor = getStompHeaderAccessor(message)__		StompCommand command = stompAccessor.getCommand()__		if (StompCommand.MESSAGE.equals(command)) {_			if (stompAccessor.getSubscriptionId() == null) {_				logger.warn("No STOMP \"subscription\" header in " + message)__			}_			String origDestination = stompAccessor.getFirstNativeHeader(SimpMessageHeaderAccessor.ORIGINAL_DESTINATION)__			if (origDestination != null) {_				stompAccessor = toMutableAccessor(stompAccessor, message)__				stompAccessor.removeNativeHeader(SimpMessageHeaderAccessor.ORIGINAL_DESTINATION)__				stompAccessor.setDestination(origDestination)__			}_		}_		else if (StompCommand.CONNECTED.equals(command)) {_			this.stats.incrementConnectedCount()__			stompAccessor = afterStompSessionConnected(message, stompAccessor, session)__			if (this.eventPublisher != null && StompCommand.CONNECTED.equals(command)) {_				try {_					SimpAttributes simpAttributes = new SimpAttributes(session.getId(), session.getAttributes())__					SimpAttributesContextHolder.setAttributes(simpAttributes)__					publishEvent(new SessionConnectedEvent(this, (Message<byte[]>) message))__				}_				finally {_					SimpAttributesContextHolder.resetAttributes()__				}_			}_		}_		try {_			byte[] bytes = this.stompEncoder.encode(stompAccessor.getMessageHeaders(), (byte[]) message.getPayload())__			session.sendMessage(new TextMessage(bytes))__		}_		catch (SessionLimitExceededException ex) {_			_			throw ex__		}_		catch (Throwable ex) {_			_			logger.debug("Failed to send WebSocket message to client in session " + session.getId() + ".", ex)__			command = StompCommand.ERROR__		}_		finally {_			if (StompCommand.ERROR.equals(command)) {_				try {_					session.close(CloseStatus.PROTOCOL_ERROR)__				}_				catch (IOException ex) {_					_				}_			}_		}_	};handle,stomp,messages,going,back,out,to,web,socket,clients;suppress,warnings,unchecked,override,public,void,handle,message,to,client,web,socket,session,session,message,message,if,message,get,payload,instanceof,byte,logger,error,expected,byte,payload,ignoring,message,return,stomp,header,accessor,stomp,accessor,get,stomp,header,accessor,message,stomp,command,command,stomp,accessor,get,command,if,stomp,command,message,equals,command,if,stomp,accessor,get,subscription,id,null,logger,warn,no,stomp,subscription,header,in,message,string,orig,destination,stomp,accessor,get,first,native,header,simp,message,header,accessor,if,orig,destination,null,stomp,accessor,to,mutable,accessor,stomp,accessor,message,stomp,accessor,remove,native,header,simp,message,header,accessor,stomp,accessor,set,destination,orig,destination,else,if,stomp,command,connected,equals,command,this,stats,increment,connected,count,stomp,accessor,after,stomp,session,connected,message,stomp,accessor,session,if,this,event,publisher,null,stomp,command,connected,equals,command,try,simp,attributes,simp,attributes,new,simp,attributes,session,get,id,session,get,attributes,simp,attributes,context,holder,set,attributes,simp,attributes,publish,event,new,session,connected,event,this,message,byte,message,finally,simp,attributes,context,holder,reset,attributes,try,byte,bytes,this,stomp,encoder,encode,stomp,accessor,get,message,headers,byte,message,get,payload,session,send,message,new,text,message,bytes,catch,session,limit,exceeded,exception,ex,throw,ex,catch,throwable,ex,logger,debug,failed,to,send,web,socket,message,to,client,in,session,session,get,id,ex,command,stomp,command,error,finally,if,stomp,command,error,equals,command,try,session,close,close,status,catch,ioexception,ex
StompSubProtocolHandler -> @SuppressWarnings("unchecked") 	@Override 	public void handleMessageToClient(WebSocketSession session, Message<?> message);1412965899;Handle STOMP messages going back out to WebSocket clients.;@SuppressWarnings("unchecked")_	@Override_	public void handleMessageToClient(WebSocketSession session, Message<?> message) {_		if (!(message.getPayload() instanceof byte[])) {_			logger.error("Expected byte[] payload. Ignoring " + message + ".")__			return__		}_		StompHeaderAccessor stompAccessor = getStompHeaderAccessor(message)__		StompCommand command = stompAccessor.getCommand()__		if (StompCommand.MESSAGE.equals(command)) {_			if (stompAccessor.getSubscriptionId() == null) {_				logger.warn("No STOMP \"subscription\" header in " + message)__			}_			String origDestination = stompAccessor.getFirstNativeHeader(SimpMessageHeaderAccessor.ORIGINAL_DESTINATION)__			if (origDestination != null) {_				stompAccessor = toMutableAccessor(stompAccessor, message)__				stompAccessor.removeNativeHeader(SimpMessageHeaderAccessor.ORIGINAL_DESTINATION)__				stompAccessor.setDestination(origDestination)__			}_		}_		else if (StompCommand.CONNECTED.equals(command)) {_			this.stats.incrementConnectedCount()__			stompAccessor = afterStompSessionConnected(message, stompAccessor, session)__			if (this.eventPublisher != null && StompCommand.CONNECTED.equals(command)) {_				try {_					SimpAttributes simpAttributes = new SimpAttributes(session.getId(), session.getAttributes())__					SimpAttributesContextHolder.setAttributes(simpAttributes)__					publishEvent(new SessionConnectedEvent(this, (Message<byte[]>) message))__				}_				finally {_					SimpAttributesContextHolder.resetAttributes()__				}_			}_		}_		try {_			byte[] bytes = this.stompEncoder.encode(stompAccessor.getMessageHeaders(), (byte[]) message.getPayload())__			session.sendMessage(new TextMessage(bytes))__		}_		catch (SessionLimitExceededException ex) {_			_			throw ex__		}_		catch (Throwable ex) {_			_			logger.debug("Failed to send WebSocket message to client in session " + session.getId() + ".", ex)__			command = StompCommand.ERROR__		}_		finally {_			if (StompCommand.ERROR.equals(command)) {_				try {_					session.close(CloseStatus.PROTOCOL_ERROR)__				}_				catch (IOException ex) {_					_				}_			}_		}_	};handle,stomp,messages,going,back,out,to,web,socket,clients;suppress,warnings,unchecked,override,public,void,handle,message,to,client,web,socket,session,session,message,message,if,message,get,payload,instanceof,byte,logger,error,expected,byte,payload,ignoring,message,return,stomp,header,accessor,stomp,accessor,get,stomp,header,accessor,message,stomp,command,command,stomp,accessor,get,command,if,stomp,command,message,equals,command,if,stomp,accessor,get,subscription,id,null,logger,warn,no,stomp,subscription,header,in,message,string,orig,destination,stomp,accessor,get,first,native,header,simp,message,header,accessor,if,orig,destination,null,stomp,accessor,to,mutable,accessor,stomp,accessor,message,stomp,accessor,remove,native,header,simp,message,header,accessor,stomp,accessor,set,destination,orig,destination,else,if,stomp,command,connected,equals,command,this,stats,increment,connected,count,stomp,accessor,after,stomp,session,connected,message,stomp,accessor,session,if,this,event,publisher,null,stomp,command,connected,equals,command,try,simp,attributes,simp,attributes,new,simp,attributes,session,get,id,session,get,attributes,simp,attributes,context,holder,set,attributes,simp,attributes,publish,event,new,session,connected,event,this,message,byte,message,finally,simp,attributes,context,holder,reset,attributes,try,byte,bytes,this,stomp,encoder,encode,stomp,accessor,get,message,headers,byte,message,get,payload,session,send,message,new,text,message,bytes,catch,session,limit,exceeded,exception,ex,throw,ex,catch,throwable,ex,logger,debug,failed,to,send,web,socket,message,to,client,in,session,session,get,id,ex,command,stomp,command,error,finally,if,stomp,command,error,equals,command,try,session,close,close,status,catch,ioexception,ex
StompSubProtocolHandler -> @SuppressWarnings("unchecked") 	@Override 	public void handleMessageToClient(WebSocketSession session, Message<?> message);1413848647;Handle STOMP messages going back out to WebSocket clients.;@SuppressWarnings("unchecked")_	@Override_	public void handleMessageToClient(WebSocketSession session, Message<?> message) {_		if (!(message.getPayload() instanceof byte[])) {_			logger.error("Expected byte[] payload. Ignoring " + message + ".")__			return__		}_		StompHeaderAccessor stompAccessor = getStompHeaderAccessor(message)__		StompCommand command = stompAccessor.getCommand()__		if (StompCommand.MESSAGE.equals(command)) {_			if (stompAccessor.getSubscriptionId() == null) {_				logger.warn("No STOMP \"subscription\" header in " + message)__			}_			String origDestination = stompAccessor.getFirstNativeHeader(SimpMessageHeaderAccessor.ORIGINAL_DESTINATION)__			if (origDestination != null) {_				stompAccessor = toMutableAccessor(stompAccessor, message)__				stompAccessor.removeNativeHeader(SimpMessageHeaderAccessor.ORIGINAL_DESTINATION)__				stompAccessor.setDestination(origDestination)__			}_		}_		else if (StompCommand.CONNECTED.equals(command)) {_			this.stats.incrementConnectedCount()__			stompAccessor = afterStompSessionConnected(message, stompAccessor, session)__			if (this.eventPublisher != null && StompCommand.CONNECTED.equals(command)) {_				try {_					SimpAttributes simpAttributes = new SimpAttributes(session.getId(), session.getAttributes())__					SimpAttributesContextHolder.setAttributes(simpAttributes)__					publishEvent(new SessionConnectedEvent(this, (Message<byte[]>) message))__				}_				finally {_					SimpAttributesContextHolder.resetAttributes()__				}_			}_		}_		try {_			byte[] bytes = this.stompEncoder.encode(stompAccessor.getMessageHeaders(), (byte[]) message.getPayload())__			session.sendMessage(new TextMessage(bytes))__		}_		catch (SessionLimitExceededException ex) {_			_			throw ex__		}_		catch (Throwable ex) {_			_			logger.debug("Failed to send WebSocket message to client in session " + session.getId() + ".", ex)__			command = StompCommand.ERROR__		}_		finally {_			if (StompCommand.ERROR.equals(command)) {_				try {_					session.close(CloseStatus.PROTOCOL_ERROR)__				}_				catch (IOException ex) {_					_				}_			}_		}_	};handle,stomp,messages,going,back,out,to,web,socket,clients;suppress,warnings,unchecked,override,public,void,handle,message,to,client,web,socket,session,session,message,message,if,message,get,payload,instanceof,byte,logger,error,expected,byte,payload,ignoring,message,return,stomp,header,accessor,stomp,accessor,get,stomp,header,accessor,message,stomp,command,command,stomp,accessor,get,command,if,stomp,command,message,equals,command,if,stomp,accessor,get,subscription,id,null,logger,warn,no,stomp,subscription,header,in,message,string,orig,destination,stomp,accessor,get,first,native,header,simp,message,header,accessor,if,orig,destination,null,stomp,accessor,to,mutable,accessor,stomp,accessor,message,stomp,accessor,remove,native,header,simp,message,header,accessor,stomp,accessor,set,destination,orig,destination,else,if,stomp,command,connected,equals,command,this,stats,increment,connected,count,stomp,accessor,after,stomp,session,connected,message,stomp,accessor,session,if,this,event,publisher,null,stomp,command,connected,equals,command,try,simp,attributes,simp,attributes,new,simp,attributes,session,get,id,session,get,attributes,simp,attributes,context,holder,set,attributes,simp,attributes,publish,event,new,session,connected,event,this,message,byte,message,finally,simp,attributes,context,holder,reset,attributes,try,byte,bytes,this,stomp,encoder,encode,stomp,accessor,get,message,headers,byte,message,get,payload,session,send,message,new,text,message,bytes,catch,session,limit,exceeded,exception,ex,throw,ex,catch,throwable,ex,logger,debug,failed,to,send,web,socket,message,to,client,in,session,session,get,id,ex,command,stomp,command,error,finally,if,stomp,command,error,equals,command,try,session,close,close,status,catch,ioexception,ex
StompSubProtocolHandler -> @SuppressWarnings("unchecked") 	@Override 	public void handleMessageToClient(WebSocketSession session, Message<?> message);1414092351;Handle STOMP messages going back out to WebSocket clients.;@SuppressWarnings("unchecked")_	@Override_	public void handleMessageToClient(WebSocketSession session, Message<?> message) {_		if (!(message.getPayload() instanceof byte[])) {_			logger.error("Expected byte[] payload. Ignoring " + message + ".")__			return__		}_		StompHeaderAccessor stompAccessor = getStompHeaderAccessor(message)__		StompCommand command = stompAccessor.getCommand()__		if (StompCommand.MESSAGE.equals(command)) {_			if (stompAccessor.getSubscriptionId() == null) {_				logger.warn("No STOMP \"subscription\" header in " + message)__			}_			String origDestination = stompAccessor.getFirstNativeHeader(SimpMessageHeaderAccessor.ORIGINAL_DESTINATION)__			if (origDestination != null) {_				stompAccessor = toMutableAccessor(stompAccessor, message)__				stompAccessor.removeNativeHeader(SimpMessageHeaderAccessor.ORIGINAL_DESTINATION)__				stompAccessor.setDestination(origDestination)__			}_		}_		else if (StompCommand.CONNECTED.equals(command)) {_			this.stats.incrementConnectedCount()__			stompAccessor = afterStompSessionConnected(message, stompAccessor, session)__			if (this.eventPublisher != null && StompCommand.CONNECTED.equals(command)) {_				try {_					SimpAttributes simpAttributes = new SimpAttributes(session.getId(), session.getAttributes())__					SimpAttributesContextHolder.setAttributes(simpAttributes)__					publishEvent(new SessionConnectedEvent(this, (Message<byte[]>) message))__				}_				finally {_					SimpAttributesContextHolder.resetAttributes()__				}_			}_		}_		try {_			byte[] bytes = this.stompEncoder.encode(stompAccessor.getMessageHeaders(), (byte[]) message.getPayload())__			session.sendMessage(new TextMessage(bytes))__		}_		catch (SessionLimitExceededException ex) {_			_			throw ex__		}_		catch (Throwable ex) {_			_			logger.debug("Failed to send WebSocket message to client in session " + session.getId() + ".", ex)__			command = StompCommand.ERROR__		}_		finally {_			if (StompCommand.ERROR.equals(command)) {_				try {_					session.close(CloseStatus.PROTOCOL_ERROR)__				}_				catch (IOException ex) {_					_				}_			}_		}_	};handle,stomp,messages,going,back,out,to,web,socket,clients;suppress,warnings,unchecked,override,public,void,handle,message,to,client,web,socket,session,session,message,message,if,message,get,payload,instanceof,byte,logger,error,expected,byte,payload,ignoring,message,return,stomp,header,accessor,stomp,accessor,get,stomp,header,accessor,message,stomp,command,command,stomp,accessor,get,command,if,stomp,command,message,equals,command,if,stomp,accessor,get,subscription,id,null,logger,warn,no,stomp,subscription,header,in,message,string,orig,destination,stomp,accessor,get,first,native,header,simp,message,header,accessor,if,orig,destination,null,stomp,accessor,to,mutable,accessor,stomp,accessor,message,stomp,accessor,remove,native,header,simp,message,header,accessor,stomp,accessor,set,destination,orig,destination,else,if,stomp,command,connected,equals,command,this,stats,increment,connected,count,stomp,accessor,after,stomp,session,connected,message,stomp,accessor,session,if,this,event,publisher,null,stomp,command,connected,equals,command,try,simp,attributes,simp,attributes,new,simp,attributes,session,get,id,session,get,attributes,simp,attributes,context,holder,set,attributes,simp,attributes,publish,event,new,session,connected,event,this,message,byte,message,finally,simp,attributes,context,holder,reset,attributes,try,byte,bytes,this,stomp,encoder,encode,stomp,accessor,get,message,headers,byte,message,get,payload,session,send,message,new,text,message,bytes,catch,session,limit,exceeded,exception,ex,throw,ex,catch,throwable,ex,logger,debug,failed,to,send,web,socket,message,to,client,in,session,session,get,id,ex,command,stomp,command,error,finally,if,stomp,command,error,equals,command,try,session,close,close,status,catch,ioexception,ex
StompSubProtocolHandler -> @SuppressWarnings("unchecked") 	@Override 	public void handleMessageToClient(WebSocketSession session, Message<?> message);1414158498;Handle STOMP messages going back out to WebSocket clients.;@SuppressWarnings("unchecked")_	@Override_	public void handleMessageToClient(WebSocketSession session, Message<?> message) {_		if (!(message.getPayload() instanceof byte[])) {_			logger.error("Expected byte[] payload. Ignoring " + message + ".")__			return__		}_		StompHeaderAccessor stompAccessor = getStompHeaderAccessor(message)__		StompCommand command = stompAccessor.getCommand()__		if (StompCommand.MESSAGE.equals(command)) {_			if (stompAccessor.getSubscriptionId() == null) {_				logger.warn("No STOMP \"subscription\" header in " + message)__			}_			String origDestination = stompAccessor.getFirstNativeHeader(SimpMessageHeaderAccessor.ORIGINAL_DESTINATION)__			if (origDestination != null) {_				stompAccessor = toMutableAccessor(stompAccessor, message)__				stompAccessor.removeNativeHeader(SimpMessageHeaderAccessor.ORIGINAL_DESTINATION)__				stompAccessor.setDestination(origDestination)__			}_		}_		else if (StompCommand.CONNECTED.equals(command)) {_			this.stats.incrementConnectedCount()__			stompAccessor = afterStompSessionConnected(message, stompAccessor, session)__			if (this.eventPublisher != null && StompCommand.CONNECTED.equals(command)) {_				try {_					SimpAttributes simpAttributes = new SimpAttributes(session.getId(), session.getAttributes())__					SimpAttributesContextHolder.setAttributes(simpAttributes)__					publishEvent(new SessionConnectedEvent(this, (Message<byte[]>) message))__				}_				finally {_					SimpAttributesContextHolder.resetAttributes()__				}_			}_		}_		try {_			byte[] bytes = this.stompEncoder.encode(stompAccessor.getMessageHeaders(), (byte[]) message.getPayload())__			session.sendMessage(new TextMessage(bytes))__		}_		catch (SessionLimitExceededException ex) {_			_			throw ex__		}_		catch (Throwable ex) {_			_			logger.debug("Failed to send WebSocket message to client in session " + session.getId() + ".", ex)__			command = StompCommand.ERROR__		}_		finally {_			if (StompCommand.ERROR.equals(command)) {_				try {_					session.close(CloseStatus.PROTOCOL_ERROR)__				}_				catch (IOException ex) {_					_				}_			}_		}_	};handle,stomp,messages,going,back,out,to,web,socket,clients;suppress,warnings,unchecked,override,public,void,handle,message,to,client,web,socket,session,session,message,message,if,message,get,payload,instanceof,byte,logger,error,expected,byte,payload,ignoring,message,return,stomp,header,accessor,stomp,accessor,get,stomp,header,accessor,message,stomp,command,command,stomp,accessor,get,command,if,stomp,command,message,equals,command,if,stomp,accessor,get,subscription,id,null,logger,warn,no,stomp,subscription,header,in,message,string,orig,destination,stomp,accessor,get,first,native,header,simp,message,header,accessor,if,orig,destination,null,stomp,accessor,to,mutable,accessor,stomp,accessor,message,stomp,accessor,remove,native,header,simp,message,header,accessor,stomp,accessor,set,destination,orig,destination,else,if,stomp,command,connected,equals,command,this,stats,increment,connected,count,stomp,accessor,after,stomp,session,connected,message,stomp,accessor,session,if,this,event,publisher,null,stomp,command,connected,equals,command,try,simp,attributes,simp,attributes,new,simp,attributes,session,get,id,session,get,attributes,simp,attributes,context,holder,set,attributes,simp,attributes,publish,event,new,session,connected,event,this,message,byte,message,finally,simp,attributes,context,holder,reset,attributes,try,byte,bytes,this,stomp,encoder,encode,stomp,accessor,get,message,headers,byte,message,get,payload,session,send,message,new,text,message,bytes,catch,session,limit,exceeded,exception,ex,throw,ex,catch,throwable,ex,logger,debug,failed,to,send,web,socket,message,to,client,in,session,session,get,id,ex,command,stomp,command,error,finally,if,stomp,command,error,equals,command,try,session,close,close,status,catch,ioexception,ex
StompSubProtocolHandler -> @SuppressWarnings("unchecked") 	@Override 	public void handleMessageToClient(WebSocketSession session, Message<?> message);1419362683;Handle STOMP messages going back out to WebSocket clients.;@SuppressWarnings("unchecked")_	@Override_	public void handleMessageToClient(WebSocketSession session, Message<?> message) {_		if (!(message.getPayload() instanceof byte[])) {_			logger.error("Expected byte[] payload. Ignoring " + message + ".")__			return__		}_		StompHeaderAccessor stompAccessor = getStompHeaderAccessor(message)__		StompCommand command = stompAccessor.getCommand()__		if (StompCommand.MESSAGE.equals(command)) {_			if (stompAccessor.getSubscriptionId() == null) {_				logger.warn("No STOMP \"subscription\" header in " + message)__			}_			String origDestination = stompAccessor.getFirstNativeHeader(SimpMessageHeaderAccessor.ORIGINAL_DESTINATION)__			if (origDestination != null) {_				stompAccessor = toMutableAccessor(stompAccessor, message)__				stompAccessor.removeNativeHeader(SimpMessageHeaderAccessor.ORIGINAL_DESTINATION)__				stompAccessor.setDestination(origDestination)__			}_		}_		else if (StompCommand.CONNECTED.equals(command)) {_			this.stats.incrementConnectedCount()__			stompAccessor = afterStompSessionConnected(message, stompAccessor, session)__			if (this.eventPublisher != null && StompCommand.CONNECTED.equals(command)) {_				try {_					SimpAttributes simpAttributes = new SimpAttributes(session.getId(), session.getAttributes())__					SimpAttributesContextHolder.setAttributes(simpAttributes)__					publishEvent(new SessionConnectedEvent(this, (Message<byte[]>) message))__				}_				finally {_					SimpAttributesContextHolder.resetAttributes()__				}_			}_		}_		try {_			byte[] bytes = this.stompEncoder.encode(stompAccessor.getMessageHeaders(), (byte[]) message.getPayload())__			if (MimeTypeUtils.APPLICATION_OCTET_STREAM.isCompatibleWith(stompAccessor.getContentType())) {_				session.sendMessage(new BinaryMessage(bytes))__			}_			else {_				session.sendMessage(new TextMessage(bytes))__			}_		}_		catch (SessionLimitExceededException ex) {_			_			throw ex__		}_		catch (Throwable ex) {_			_			logger.debug("Failed to send WebSocket message to client in session " + session.getId() + ".", ex)__			command = StompCommand.ERROR__		}_		finally {_			if (StompCommand.ERROR.equals(command)) {_				try {_					session.close(CloseStatus.PROTOCOL_ERROR)__				}_				catch (IOException ex) {_					_				}_			}_		}_	};handle,stomp,messages,going,back,out,to,web,socket,clients;suppress,warnings,unchecked,override,public,void,handle,message,to,client,web,socket,session,session,message,message,if,message,get,payload,instanceof,byte,logger,error,expected,byte,payload,ignoring,message,return,stomp,header,accessor,stomp,accessor,get,stomp,header,accessor,message,stomp,command,command,stomp,accessor,get,command,if,stomp,command,message,equals,command,if,stomp,accessor,get,subscription,id,null,logger,warn,no,stomp,subscription,header,in,message,string,orig,destination,stomp,accessor,get,first,native,header,simp,message,header,accessor,if,orig,destination,null,stomp,accessor,to,mutable,accessor,stomp,accessor,message,stomp,accessor,remove,native,header,simp,message,header,accessor,stomp,accessor,set,destination,orig,destination,else,if,stomp,command,connected,equals,command,this,stats,increment,connected,count,stomp,accessor,after,stomp,session,connected,message,stomp,accessor,session,if,this,event,publisher,null,stomp,command,connected,equals,command,try,simp,attributes,simp,attributes,new,simp,attributes,session,get,id,session,get,attributes,simp,attributes,context,holder,set,attributes,simp,attributes,publish,event,new,session,connected,event,this,message,byte,message,finally,simp,attributes,context,holder,reset,attributes,try,byte,bytes,this,stomp,encoder,encode,stomp,accessor,get,message,headers,byte,message,get,payload,if,mime,type,utils,is,compatible,with,stomp,accessor,get,content,type,session,send,message,new,binary,message,bytes,else,session,send,message,new,text,message,bytes,catch,session,limit,exceeded,exception,ex,throw,ex,catch,throwable,ex,logger,debug,failed,to,send,web,socket,message,to,client,in,session,session,get,id,ex,command,stomp,command,error,finally,if,stomp,command,error,equals,command,try,session,close,close,status,catch,ioexception,ex
StompSubProtocolHandler -> @SuppressWarnings("unchecked") 	@Override 	public void handleMessageToClient(WebSocketSession session, Message<?> message);1419883989;Handle STOMP messages going back out to WebSocket clients.;@SuppressWarnings("unchecked")_	@Override_	public void handleMessageToClient(WebSocketSession session, Message<?> message) {_		if (!(message.getPayload() instanceof byte[])) {_			logger.error("Expected byte[] payload. Ignoring " + message + ".")__			return__		}_		StompHeaderAccessor stompAccessor = getStompHeaderAccessor(message)__		StompCommand command = stompAccessor.getCommand()__		if (StompCommand.MESSAGE.equals(command)) {_			if (stompAccessor.getSubscriptionId() == null) {_				logger.warn("No STOMP \"subscription\" header in " + message)__			}_			String origDestination = stompAccessor.getFirstNativeHeader(SimpMessageHeaderAccessor.ORIGINAL_DESTINATION)__			if (origDestination != null) {_				stompAccessor = toMutableAccessor(stompAccessor, message)__				stompAccessor.removeNativeHeader(SimpMessageHeaderAccessor.ORIGINAL_DESTINATION)__				stompAccessor.setDestination(origDestination)__			}_		}_		else if (StompCommand.CONNECTED.equals(command)) {_			this.stats.incrementConnectedCount()__			stompAccessor = afterStompSessionConnected(message, stompAccessor, session)__			if (this.eventPublisher != null && StompCommand.CONNECTED.equals(command)) {_				try {_					SimpAttributes simpAttributes = new SimpAttributes(session.getId(), session.getAttributes())__					SimpAttributesContextHolder.setAttributes(simpAttributes)__					publishEvent(new SessionConnectedEvent(this, (Message<byte[]>) message))__				}_				finally {_					SimpAttributesContextHolder.resetAttributes()__				}_			}_		}_		try {_			byte[] payload = (byte[]) message.getPayload()__			byte[] bytes = this.stompEncoder.encode(stompAccessor.getMessageHeaders(), payload)___			boolean useBinary = (payload.length > 0 && !(session instanceof SockJsSession) &&_					MimeTypeUtils.APPLICATION_OCTET_STREAM.isCompatibleWith(stompAccessor.getContentType()))___			if (useBinary) {_				session.sendMessage(new BinaryMessage(bytes))__			}_			else {_				session.sendMessage(new TextMessage(bytes))__			}_		}_		catch (SessionLimitExceededException ex) {_			_			throw ex__		}_		catch (Throwable ex) {_			_			logger.debug("Failed to send WebSocket message to client in session " + session.getId() + ".", ex)__			command = StompCommand.ERROR__		}_		finally {_			if (StompCommand.ERROR.equals(command)) {_				try {_					session.close(CloseStatus.PROTOCOL_ERROR)__				}_				catch (IOException ex) {_					_				}_			}_		}_	};handle,stomp,messages,going,back,out,to,web,socket,clients;suppress,warnings,unchecked,override,public,void,handle,message,to,client,web,socket,session,session,message,message,if,message,get,payload,instanceof,byte,logger,error,expected,byte,payload,ignoring,message,return,stomp,header,accessor,stomp,accessor,get,stomp,header,accessor,message,stomp,command,command,stomp,accessor,get,command,if,stomp,command,message,equals,command,if,stomp,accessor,get,subscription,id,null,logger,warn,no,stomp,subscription,header,in,message,string,orig,destination,stomp,accessor,get,first,native,header,simp,message,header,accessor,if,orig,destination,null,stomp,accessor,to,mutable,accessor,stomp,accessor,message,stomp,accessor,remove,native,header,simp,message,header,accessor,stomp,accessor,set,destination,orig,destination,else,if,stomp,command,connected,equals,command,this,stats,increment,connected,count,stomp,accessor,after,stomp,session,connected,message,stomp,accessor,session,if,this,event,publisher,null,stomp,command,connected,equals,command,try,simp,attributes,simp,attributes,new,simp,attributes,session,get,id,session,get,attributes,simp,attributes,context,holder,set,attributes,simp,attributes,publish,event,new,session,connected,event,this,message,byte,message,finally,simp,attributes,context,holder,reset,attributes,try,byte,payload,byte,message,get,payload,byte,bytes,this,stomp,encoder,encode,stomp,accessor,get,message,headers,payload,boolean,use,binary,payload,length,0,session,instanceof,sock,js,session,mime,type,utils,is,compatible,with,stomp,accessor,get,content,type,if,use,binary,session,send,message,new,binary,message,bytes,else,session,send,message,new,text,message,bytes,catch,session,limit,exceeded,exception,ex,throw,ex,catch,throwable,ex,logger,debug,failed,to,send,web,socket,message,to,client,in,session,session,get,id,ex,command,stomp,command,error,finally,if,stomp,command,error,equals,command,try,session,close,close,status,catch,ioexception,ex
StompSubProtocolHandler -> @SuppressWarnings("unchecked") 	@Override 	public void handleMessageToClient(WebSocketSession session, Message<?> message);1424278379;Handle STOMP messages going back out to WebSocket clients.;@SuppressWarnings("unchecked")_	@Override_	public void handleMessageToClient(WebSocketSession session, Message<?> message) {_		if (!(message.getPayload() instanceof byte[])) {_			logger.error("Expected byte[] payload. Ignoring " + message + ".")__			return__		}_		StompHeaderAccessor stompAccessor = getStompHeaderAccessor(message)__		StompCommand command = stompAccessor.getCommand()__		if (StompCommand.MESSAGE.equals(command)) {_			if (stompAccessor.getSubscriptionId() == null) {_				logger.warn("No STOMP \"subscription\" header in " + message)__			}_			String origDestination = stompAccessor.getFirstNativeHeader(SimpMessageHeaderAccessor.ORIGINAL_DESTINATION)__			if (origDestination != null) {_				stompAccessor = toMutableAccessor(stompAccessor, message)__				stompAccessor.removeNativeHeader(SimpMessageHeaderAccessor.ORIGINAL_DESTINATION)__				stompAccessor.setDestination(origDestination)__			}_		}_		else if (StompCommand.CONNECTED.equals(command)) {_			this.stats.incrementConnectedCount()__			stompAccessor = afterStompSessionConnected(message, stompAccessor, session)__			if (this.eventPublisher != null && StompCommand.CONNECTED.equals(command)) {_				try {_					SimpAttributes simpAttributes = new SimpAttributes(session.getId(), session.getAttributes())__					SimpAttributesContextHolder.setAttributes(simpAttributes)__					publishEvent(new SessionConnectedEvent(this, (Message<byte[]>) message))__				}_				finally {_					SimpAttributesContextHolder.resetAttributes()__				}_			}_		}_		try {_			byte[] payload = (byte[]) message.getPayload()__			byte[] bytes = this.stompEncoder.encode(stompAccessor.getMessageHeaders(), payload)___			boolean useBinary = (payload.length > 0 && !(session instanceof SockJsSession) &&_					MimeTypeUtils.APPLICATION_OCTET_STREAM.isCompatibleWith(stompAccessor.getContentType()))___			if (useBinary) {_				session.sendMessage(new BinaryMessage(bytes))__			}_			else {_				session.sendMessage(new TextMessage(bytes))__			}_		}_		catch (SessionLimitExceededException ex) {_			_			throw ex__		}_		catch (Throwable ex) {_			_			logger.debug("Failed to send WebSocket message to client in session " + session.getId() + ".", ex)__			command = StompCommand.ERROR__		}_		finally {_			if (StompCommand.ERROR.equals(command)) {_				try {_					session.close(CloseStatus.PROTOCOL_ERROR)__				}_				catch (IOException ex) {_					_				}_			}_		}_	};handle,stomp,messages,going,back,out,to,web,socket,clients;suppress,warnings,unchecked,override,public,void,handle,message,to,client,web,socket,session,session,message,message,if,message,get,payload,instanceof,byte,logger,error,expected,byte,payload,ignoring,message,return,stomp,header,accessor,stomp,accessor,get,stomp,header,accessor,message,stomp,command,command,stomp,accessor,get,command,if,stomp,command,message,equals,command,if,stomp,accessor,get,subscription,id,null,logger,warn,no,stomp,subscription,header,in,message,string,orig,destination,stomp,accessor,get,first,native,header,simp,message,header,accessor,if,orig,destination,null,stomp,accessor,to,mutable,accessor,stomp,accessor,message,stomp,accessor,remove,native,header,simp,message,header,accessor,stomp,accessor,set,destination,orig,destination,else,if,stomp,command,connected,equals,command,this,stats,increment,connected,count,stomp,accessor,after,stomp,session,connected,message,stomp,accessor,session,if,this,event,publisher,null,stomp,command,connected,equals,command,try,simp,attributes,simp,attributes,new,simp,attributes,session,get,id,session,get,attributes,simp,attributes,context,holder,set,attributes,simp,attributes,publish,event,new,session,connected,event,this,message,byte,message,finally,simp,attributes,context,holder,reset,attributes,try,byte,payload,byte,message,get,payload,byte,bytes,this,stomp,encoder,encode,stomp,accessor,get,message,headers,payload,boolean,use,binary,payload,length,0,session,instanceof,sock,js,session,mime,type,utils,is,compatible,with,stomp,accessor,get,content,type,if,use,binary,session,send,message,new,binary,message,bytes,else,session,send,message,new,text,message,bytes,catch,session,limit,exceeded,exception,ex,throw,ex,catch,throwable,ex,logger,debug,failed,to,send,web,socket,message,to,client,in,session,session,get,id,ex,command,stomp,command,error,finally,if,stomp,command,error,equals,command,try,session,close,close,status,catch,ioexception,ex
StompSubProtocolHandler -> @SuppressWarnings("unchecked") 	@Override 	public void handleMessageToClient(WebSocketSession session, Message<?> message);1428353843;Handle STOMP messages going back out to WebSocket clients.;@SuppressWarnings("unchecked")_	@Override_	public void handleMessageToClient(WebSocketSession session, Message<?> message) {_		if (!(message.getPayload() instanceof byte[])) {_			logger.error("Expected byte[] payload. Ignoring " + message + ".")__			return__		}_		StompHeaderAccessor stompAccessor = getStompHeaderAccessor(message)__		StompCommand command = stompAccessor.getCommand()__		if (StompCommand.MESSAGE.equals(command)) {_			if (stompAccessor.getSubscriptionId() == null) {_				logger.warn("No STOMP \"subscription\" header in " + message)__			}_			String origDestination = stompAccessor.getFirstNativeHeader(SimpMessageHeaderAccessor.ORIGINAL_DESTINATION)__			if (origDestination != null) {_				stompAccessor = toMutableAccessor(stompAccessor, message)__				stompAccessor.removeNativeHeader(SimpMessageHeaderAccessor.ORIGINAL_DESTINATION)__				stompAccessor.setDestination(origDestination)__			}_		}_		else if (StompCommand.CONNECTED.equals(command)) {_			this.stats.incrementConnectedCount()__			stompAccessor = afterStompSessionConnected(message, stompAccessor, session)__			if (this.eventPublisher != null && StompCommand.CONNECTED.equals(command)) {_				try {_					SimpAttributes simpAttributes = new SimpAttributes(session.getId(), session.getAttributes())__					SimpAttributesContextHolder.setAttributes(simpAttributes)__					publishEvent(new SessionConnectedEvent(this, (Message<byte[]>) message))__				}_				finally {_					SimpAttributesContextHolder.resetAttributes()__				}_			}_		}_		try {_			byte[] payload = (byte[]) message.getPayload()__			byte[] bytes = this.stompEncoder.encode(stompAccessor.getMessageHeaders(), payload)___			boolean useBinary = (payload.length > 0 && !(session instanceof SockJsSession) &&_					MimeTypeUtils.APPLICATION_OCTET_STREAM.isCompatibleWith(stompAccessor.getContentType()))___			if (useBinary) {_				session.sendMessage(new BinaryMessage(bytes))__			}_			else {_				session.sendMessage(new TextMessage(bytes))__			}_		}_		catch (SessionLimitExceededException ex) {_			_			throw ex__		}_		catch (Throwable ex) {_			_			logger.debug("Failed to send WebSocket message to client in session " + session.getId() + ".", ex)__			command = StompCommand.ERROR__		}_		finally {_			if (StompCommand.ERROR.equals(command)) {_				try {_					session.close(CloseStatus.PROTOCOL_ERROR)__				}_				catch (IOException ex) {_					_				}_			}_		}_	};handle,stomp,messages,going,back,out,to,web,socket,clients;suppress,warnings,unchecked,override,public,void,handle,message,to,client,web,socket,session,session,message,message,if,message,get,payload,instanceof,byte,logger,error,expected,byte,payload,ignoring,message,return,stomp,header,accessor,stomp,accessor,get,stomp,header,accessor,message,stomp,command,command,stomp,accessor,get,command,if,stomp,command,message,equals,command,if,stomp,accessor,get,subscription,id,null,logger,warn,no,stomp,subscription,header,in,message,string,orig,destination,stomp,accessor,get,first,native,header,simp,message,header,accessor,if,orig,destination,null,stomp,accessor,to,mutable,accessor,stomp,accessor,message,stomp,accessor,remove,native,header,simp,message,header,accessor,stomp,accessor,set,destination,orig,destination,else,if,stomp,command,connected,equals,command,this,stats,increment,connected,count,stomp,accessor,after,stomp,session,connected,message,stomp,accessor,session,if,this,event,publisher,null,stomp,command,connected,equals,command,try,simp,attributes,simp,attributes,new,simp,attributes,session,get,id,session,get,attributes,simp,attributes,context,holder,set,attributes,simp,attributes,publish,event,new,session,connected,event,this,message,byte,message,finally,simp,attributes,context,holder,reset,attributes,try,byte,payload,byte,message,get,payload,byte,bytes,this,stomp,encoder,encode,stomp,accessor,get,message,headers,payload,boolean,use,binary,payload,length,0,session,instanceof,sock,js,session,mime,type,utils,is,compatible,with,stomp,accessor,get,content,type,if,use,binary,session,send,message,new,binary,message,bytes,else,session,send,message,new,text,message,bytes,catch,session,limit,exceeded,exception,ex,throw,ex,catch,throwable,ex,logger,debug,failed,to,send,web,socket,message,to,client,in,session,session,get,id,ex,command,stomp,command,error,finally,if,stomp,command,error,equals,command,try,session,close,close,status,catch,ioexception,ex
StompSubProtocolHandler -> @SuppressWarnings("unchecked") 	@Override 	public void handleMessageToClient(WebSocketSession session, Message<?> message);1430834982;Handle STOMP messages going back out to WebSocket clients.;@SuppressWarnings("unchecked")_	@Override_	public void handleMessageToClient(WebSocketSession session, Message<?> message) {_		if (!(message.getPayload() instanceof byte[])) {_			logger.error("Expected byte[] payload. Ignoring " + message + ".")__			return__		}_		StompHeaderAccessor stompAccessor = getStompHeaderAccessor(message)__		StompCommand command = stompAccessor.getCommand()__		if (StompCommand.MESSAGE.equals(command)) {_			if (stompAccessor.getSubscriptionId() == null) {_				logger.warn("No STOMP \"subscription\" header in " + message)__			}_			String origDestination = stompAccessor.getFirstNativeHeader(SimpMessageHeaderAccessor.ORIGINAL_DESTINATION)__			if (origDestination != null) {_				stompAccessor = toMutableAccessor(stompAccessor, message)__				stompAccessor.removeNativeHeader(SimpMessageHeaderAccessor.ORIGINAL_DESTINATION)__				stompAccessor.setDestination(origDestination)__			}_		}_		else if (StompCommand.CONNECTED.equals(command)) {_			this.stats.incrementConnectedCount()__			stompAccessor = afterStompSessionConnected(message, stompAccessor, session)__			if (this.eventPublisher != null && StompCommand.CONNECTED.equals(command)) {_				try {_					SimpAttributes simpAttributes = new SimpAttributes(session.getId(), session.getAttributes())__					SimpAttributesContextHolder.setAttributes(simpAttributes)__					publishEvent(new SessionConnectedEvent(this, (Message<byte[]>) message))__				}_				finally {_					SimpAttributesContextHolder.resetAttributes()__				}_			}_		}_		try {_			byte[] payload = (byte[]) message.getPayload()__			byte[] bytes = this.stompEncoder.encode(stompAccessor.getMessageHeaders(), payload)___			boolean useBinary = (payload.length > 0 && !(session instanceof SockJsSession) &&_					MimeTypeUtils.APPLICATION_OCTET_STREAM.isCompatibleWith(stompAccessor.getContentType()))___			if (useBinary) {_				session.sendMessage(new BinaryMessage(bytes))__			}_			else {_				session.sendMessage(new TextMessage(bytes))__			}_		}_		catch (SessionLimitExceededException ex) {_			_			throw ex__		}_		catch (Throwable ex) {_			_			logger.debug("Failed to send WebSocket message to client in session " + session.getId() + ".", ex)__			command = StompCommand.ERROR__		}_		finally {_			if (StompCommand.ERROR.equals(command)) {_				try {_					session.close(CloseStatus.PROTOCOL_ERROR)__				}_				catch (IOException ex) {_					_				}_			}_		}_	};handle,stomp,messages,going,back,out,to,web,socket,clients;suppress,warnings,unchecked,override,public,void,handle,message,to,client,web,socket,session,session,message,message,if,message,get,payload,instanceof,byte,logger,error,expected,byte,payload,ignoring,message,return,stomp,header,accessor,stomp,accessor,get,stomp,header,accessor,message,stomp,command,command,stomp,accessor,get,command,if,stomp,command,message,equals,command,if,stomp,accessor,get,subscription,id,null,logger,warn,no,stomp,subscription,header,in,message,string,orig,destination,stomp,accessor,get,first,native,header,simp,message,header,accessor,if,orig,destination,null,stomp,accessor,to,mutable,accessor,stomp,accessor,message,stomp,accessor,remove,native,header,simp,message,header,accessor,stomp,accessor,set,destination,orig,destination,else,if,stomp,command,connected,equals,command,this,stats,increment,connected,count,stomp,accessor,after,stomp,session,connected,message,stomp,accessor,session,if,this,event,publisher,null,stomp,command,connected,equals,command,try,simp,attributes,simp,attributes,new,simp,attributes,session,get,id,session,get,attributes,simp,attributes,context,holder,set,attributes,simp,attributes,publish,event,new,session,connected,event,this,message,byte,message,finally,simp,attributes,context,holder,reset,attributes,try,byte,payload,byte,message,get,payload,byte,bytes,this,stomp,encoder,encode,stomp,accessor,get,message,headers,payload,boolean,use,binary,payload,length,0,session,instanceof,sock,js,session,mime,type,utils,is,compatible,with,stomp,accessor,get,content,type,if,use,binary,session,send,message,new,binary,message,bytes,else,session,send,message,new,text,message,bytes,catch,session,limit,exceeded,exception,ex,throw,ex,catch,throwable,ex,logger,debug,failed,to,send,web,socket,message,to,client,in,session,session,get,id,ex,command,stomp,command,error,finally,if,stomp,command,error,equals,command,try,session,close,close,status,catch,ioexception,ex
StompSubProtocolHandler -> @SuppressWarnings("unchecked") 	@Override 	public void handleMessageToClient(WebSocketSession session, Message<?> message);1431458952;Handle STOMP messages going back out to WebSocket clients.;@SuppressWarnings("unchecked")_	@Override_	public void handleMessageToClient(WebSocketSession session, Message<?> message) {_		if (!(message.getPayload() instanceof byte[])) {_			logger.error("Expected byte[] payload. Ignoring " + message + ".")__			return__		}_		StompHeaderAccessor stompAccessor = getStompHeaderAccessor(message)__		StompCommand command = stompAccessor.getCommand()__		if (StompCommand.MESSAGE.equals(command)) {_			if (stompAccessor.getSubscriptionId() == null) {_				logger.warn("No STOMP \"subscription\" header in " + message)__			}_			String origDestination = stompAccessor.getFirstNativeHeader(SimpMessageHeaderAccessor.ORIGINAL_DESTINATION)__			if (origDestination != null) {_				stompAccessor = toMutableAccessor(stompAccessor, message)__				stompAccessor.removeNativeHeader(SimpMessageHeaderAccessor.ORIGINAL_DESTINATION)__				stompAccessor.setDestination(origDestination)__			}_		}_		else if (StompCommand.CONNECTED.equals(command)) {_			this.stats.incrementConnectedCount()__			stompAccessor = afterStompSessionConnected(message, stompAccessor, session)__			if (this.eventPublisher != null && StompCommand.CONNECTED.equals(command)) {_				try {_					SimpAttributes simpAttributes = new SimpAttributes(session.getId(), session.getAttributes())__					SimpAttributesContextHolder.setAttributes(simpAttributes)__					Principal user = session.getPrincipal()__					publishEvent(new SessionConnectedEvent(this, (Message<byte[]>) message, user))__				}_				finally {_					SimpAttributesContextHolder.resetAttributes()__				}_			}_		}_		try {_			byte[] payload = (byte[]) message.getPayload()__			byte[] bytes = this.stompEncoder.encode(stompAccessor.getMessageHeaders(), payload)___			boolean useBinary = (payload.length > 0 && !(session instanceof SockJsSession) &&_					MimeTypeUtils.APPLICATION_OCTET_STREAM.isCompatibleWith(stompAccessor.getContentType()))___			if (useBinary) {_				session.sendMessage(new BinaryMessage(bytes))__			}_			else {_				session.sendMessage(new TextMessage(bytes))__			}_		}_		catch (SessionLimitExceededException ex) {_			_			throw ex__		}_		catch (Throwable ex) {_			_			logger.debug("Failed to send WebSocket message to client in session " + session.getId() + ".", ex)__			command = StompCommand.ERROR__		}_		finally {_			if (StompCommand.ERROR.equals(command)) {_				try {_					session.close(CloseStatus.PROTOCOL_ERROR)__				}_				catch (IOException ex) {_					_				}_			}_		}_	};handle,stomp,messages,going,back,out,to,web,socket,clients;suppress,warnings,unchecked,override,public,void,handle,message,to,client,web,socket,session,session,message,message,if,message,get,payload,instanceof,byte,logger,error,expected,byte,payload,ignoring,message,return,stomp,header,accessor,stomp,accessor,get,stomp,header,accessor,message,stomp,command,command,stomp,accessor,get,command,if,stomp,command,message,equals,command,if,stomp,accessor,get,subscription,id,null,logger,warn,no,stomp,subscription,header,in,message,string,orig,destination,stomp,accessor,get,first,native,header,simp,message,header,accessor,if,orig,destination,null,stomp,accessor,to,mutable,accessor,stomp,accessor,message,stomp,accessor,remove,native,header,simp,message,header,accessor,stomp,accessor,set,destination,orig,destination,else,if,stomp,command,connected,equals,command,this,stats,increment,connected,count,stomp,accessor,after,stomp,session,connected,message,stomp,accessor,session,if,this,event,publisher,null,stomp,command,connected,equals,command,try,simp,attributes,simp,attributes,new,simp,attributes,session,get,id,session,get,attributes,simp,attributes,context,holder,set,attributes,simp,attributes,principal,user,session,get,principal,publish,event,new,session,connected,event,this,message,byte,message,user,finally,simp,attributes,context,holder,reset,attributes,try,byte,payload,byte,message,get,payload,byte,bytes,this,stomp,encoder,encode,stomp,accessor,get,message,headers,payload,boolean,use,binary,payload,length,0,session,instanceof,sock,js,session,mime,type,utils,is,compatible,with,stomp,accessor,get,content,type,if,use,binary,session,send,message,new,binary,message,bytes,else,session,send,message,new,text,message,bytes,catch,session,limit,exceeded,exception,ex,throw,ex,catch,throwable,ex,logger,debug,failed,to,send,web,socket,message,to,client,in,session,session,get,id,ex,command,stomp,command,error,finally,if,stomp,command,error,equals,command,try,session,close,close,status,catch,ioexception,ex
StompSubProtocolHandler -> @SuppressWarnings("unchecked") 	@Override 	public void handleMessageToClient(WebSocketSession session, Message<?> message);1431728285;Handle STOMP messages going back out to WebSocket clients.;@SuppressWarnings("unchecked")_	@Override_	public void handleMessageToClient(WebSocketSession session, Message<?> message) {_		if (!(message.getPayload() instanceof byte[])) {_			logger.error("Expected byte[] payload. Ignoring " + message + ".")__			return__		}_		StompHeaderAccessor stompAccessor = getStompHeaderAccessor(message)__		StompCommand command = stompAccessor.getCommand()__		if (StompCommand.MESSAGE.equals(command)) {_			if (stompAccessor.getSubscriptionId() == null) {_				logger.warn("No STOMP \"subscription\" header in " + message)__			}_			String origDestination = stompAccessor.getFirstNativeHeader(SimpMessageHeaderAccessor.ORIGINAL_DESTINATION)__			if (origDestination != null) {_				stompAccessor = toMutableAccessor(stompAccessor, message)__				stompAccessor.removeNativeHeader(SimpMessageHeaderAccessor.ORIGINAL_DESTINATION)__				stompAccessor.setDestination(origDestination)__			}_		}_		else if (StompCommand.CONNECTED.equals(command)) {_			this.stats.incrementConnectedCount()__			stompAccessor = afterStompSessionConnected(message, stompAccessor, session)__			if (this.eventPublisher != null && StompCommand.CONNECTED.equals(command)) {_				try {_					SimpAttributes simpAttributes = new SimpAttributes(session.getId(), session.getAttributes())__					SimpAttributesContextHolder.setAttributes(simpAttributes)__					Principal user = session.getPrincipal()__					publishEvent(new SessionConnectedEvent(this, (Message<byte[]>) message, user))__				}_				finally {_					SimpAttributesContextHolder.resetAttributes()__				}_			}_		}__		byte[] payload = (byte[]) message.getPayload()___		if (StompCommand.ERROR.equals(command) && getErrorHandler() != null) {_			Message<byte[]> errorMessage = getErrorHandler().handleErrorMessageToClient((Message<byte[]>) message)__			stompAccessor = MessageHeaderAccessor.getAccessor(errorMessage, StompHeaderAccessor.class)__			Assert.notNull(stompAccessor, "Expected STOMP headers.")__			payload = errorMessage.getPayload()__		}__		sendToClient(session, stompAccessor, payload)__	};handle,stomp,messages,going,back,out,to,web,socket,clients;suppress,warnings,unchecked,override,public,void,handle,message,to,client,web,socket,session,session,message,message,if,message,get,payload,instanceof,byte,logger,error,expected,byte,payload,ignoring,message,return,stomp,header,accessor,stomp,accessor,get,stomp,header,accessor,message,stomp,command,command,stomp,accessor,get,command,if,stomp,command,message,equals,command,if,stomp,accessor,get,subscription,id,null,logger,warn,no,stomp,subscription,header,in,message,string,orig,destination,stomp,accessor,get,first,native,header,simp,message,header,accessor,if,orig,destination,null,stomp,accessor,to,mutable,accessor,stomp,accessor,message,stomp,accessor,remove,native,header,simp,message,header,accessor,stomp,accessor,set,destination,orig,destination,else,if,stomp,command,connected,equals,command,this,stats,increment,connected,count,stomp,accessor,after,stomp,session,connected,message,stomp,accessor,session,if,this,event,publisher,null,stomp,command,connected,equals,command,try,simp,attributes,simp,attributes,new,simp,attributes,session,get,id,session,get,attributes,simp,attributes,context,holder,set,attributes,simp,attributes,principal,user,session,get,principal,publish,event,new,session,connected,event,this,message,byte,message,user,finally,simp,attributes,context,holder,reset,attributes,byte,payload,byte,message,get,payload,if,stomp,command,error,equals,command,get,error,handler,null,message,byte,error,message,get,error,handler,handle,error,message,to,client,message,byte,message,stomp,accessor,message,header,accessor,get,accessor,error,message,stomp,header,accessor,class,assert,not,null,stomp,accessor,expected,stomp,headers,payload,error,message,get,payload,send,to,client,session,stomp,accessor,payload
StompSubProtocolHandler -> @SuppressWarnings("unchecked") 	@Override 	public void handleMessageToClient(WebSocketSession session, Message<?> message);1432316649;Handle STOMP messages going back out to WebSocket clients.;@SuppressWarnings("unchecked")_	@Override_	public void handleMessageToClient(WebSocketSession session, Message<?> message) {_		if (!(message.getPayload() instanceof byte[])) {_			logger.error("Expected byte[] payload. Ignoring " + message + ".")__			return__		}_		StompHeaderAccessor stompAccessor = getStompHeaderAccessor(message)__		StompCommand command = stompAccessor.getCommand()__		if (StompCommand.MESSAGE.equals(command)) {_			if (stompAccessor.getSubscriptionId() == null) {_				logger.warn("No STOMP \"subscription\" header in " + message)__			}_			String origDestination = stompAccessor.getFirstNativeHeader(SimpMessageHeaderAccessor.ORIGINAL_DESTINATION)__			if (origDestination != null) {_				stompAccessor = toMutableAccessor(stompAccessor, message)__				stompAccessor.removeNativeHeader(SimpMessageHeaderAccessor.ORIGINAL_DESTINATION)__				stompAccessor.setDestination(origDestination)__			}_		}_		else if (StompCommand.CONNECTED.equals(command)) {_			this.stats.incrementConnectedCount()__			stompAccessor = afterStompSessionConnected(message, stompAccessor, session)__			if (this.eventPublisher != null && StompCommand.CONNECTED.equals(command)) {_				try {_					SimpAttributes simpAttributes = new SimpAttributes(session.getId(), session.getAttributes())__					SimpAttributesContextHolder.setAttributes(simpAttributes)__					Principal user = session.getPrincipal()__					publishEvent(new SessionConnectedEvent(this, (Message<byte[]>) message, user))__				}_				finally {_					SimpAttributesContextHolder.resetAttributes()__				}_			}_		}__		byte[] payload = (byte[]) message.getPayload()___		if (StompCommand.ERROR.equals(command) && getErrorHandler() != null) {_			Message<byte[]> errorMessage = getErrorHandler().handleErrorMessageToClient((Message<byte[]>) message)__			stompAccessor = MessageHeaderAccessor.getAccessor(errorMessage, StompHeaderAccessor.class)__			Assert.notNull(stompAccessor, "Expected STOMP headers.")__			payload = errorMessage.getPayload()__		}__		sendToClient(session, stompAccessor, payload)__	};handle,stomp,messages,going,back,out,to,web,socket,clients;suppress,warnings,unchecked,override,public,void,handle,message,to,client,web,socket,session,session,message,message,if,message,get,payload,instanceof,byte,logger,error,expected,byte,payload,ignoring,message,return,stomp,header,accessor,stomp,accessor,get,stomp,header,accessor,message,stomp,command,command,stomp,accessor,get,command,if,stomp,command,message,equals,command,if,stomp,accessor,get,subscription,id,null,logger,warn,no,stomp,subscription,header,in,message,string,orig,destination,stomp,accessor,get,first,native,header,simp,message,header,accessor,if,orig,destination,null,stomp,accessor,to,mutable,accessor,stomp,accessor,message,stomp,accessor,remove,native,header,simp,message,header,accessor,stomp,accessor,set,destination,orig,destination,else,if,stomp,command,connected,equals,command,this,stats,increment,connected,count,stomp,accessor,after,stomp,session,connected,message,stomp,accessor,session,if,this,event,publisher,null,stomp,command,connected,equals,command,try,simp,attributes,simp,attributes,new,simp,attributes,session,get,id,session,get,attributes,simp,attributes,context,holder,set,attributes,simp,attributes,principal,user,session,get,principal,publish,event,new,session,connected,event,this,message,byte,message,user,finally,simp,attributes,context,holder,reset,attributes,byte,payload,byte,message,get,payload,if,stomp,command,error,equals,command,get,error,handler,null,message,byte,error,message,get,error,handler,handle,error,message,to,client,message,byte,message,stomp,accessor,message,header,accessor,get,accessor,error,message,stomp,header,accessor,class,assert,not,null,stomp,accessor,expected,stomp,headers,payload,error,message,get,payload,send,to,client,session,stomp,accessor,payload
StompSubProtocolHandler -> @SuppressWarnings("unchecked") 	@Override 	public void handleMessageToClient(WebSocketSession session, Message<?> message);1432331447;Handle STOMP messages going back out to WebSocket clients.;@SuppressWarnings("unchecked")_	@Override_	public void handleMessageToClient(WebSocketSession session, Message<?> message) {_		if (!(message.getPayload() instanceof byte[])) {_			logger.error("Expected byte[] payload. Ignoring " + message + ".")__			return__		}__		StompHeaderAccessor stompAccessor = getStompHeaderAccessor(message)__		StompCommand command = stompAccessor.getCommand()___		if (StompCommand.MESSAGE.equals(command)) {_			if (stompAccessor.getSubscriptionId() == null) {_				logger.warn("No STOMP \"subscription\" header in " + message)__			}_			String origDestination = stompAccessor.getFirstNativeHeader(SimpMessageHeaderAccessor.ORIGINAL_DESTINATION)__			if (origDestination != null) {_				stompAccessor = toMutableAccessor(stompAccessor, message)__				stompAccessor.removeNativeHeader(SimpMessageHeaderAccessor.ORIGINAL_DESTINATION)__				stompAccessor.setDestination(origDestination)__			}_		}_		else if (StompCommand.CONNECTED.equals(command)) {_			this.stats.incrementConnectedCount()__			stompAccessor = afterStompSessionConnected(message, stompAccessor, session)__			if (this.eventPublisher != null && StompCommand.CONNECTED.equals(command)) {_				try {_					SimpAttributes simpAttributes = new SimpAttributes(session.getId(), session.getAttributes())__					SimpAttributesContextHolder.setAttributes(simpAttributes)__					Principal user = session.getPrincipal()__					publishEvent(new SessionConnectedEvent(this, (Message<byte[]>) message, user))__				}_				finally {_					SimpAttributesContextHolder.resetAttributes()__				}_			}_		}__		byte[] payload = (byte[]) message.getPayload()___		if (StompCommand.ERROR.equals(command) && getErrorHandler() != null) {_			Message<byte[]> errorMessage = getErrorHandler().handleErrorMessageToClient((Message<byte[]>) message)__			stompAccessor = MessageHeaderAccessor.getAccessor(errorMessage, StompHeaderAccessor.class)__			Assert.notNull(stompAccessor, "Expected STOMP headers")__			payload = errorMessage.getPayload()__		}__		sendToClient(session, stompAccessor, payload)__	};handle,stomp,messages,going,back,out,to,web,socket,clients;suppress,warnings,unchecked,override,public,void,handle,message,to,client,web,socket,session,session,message,message,if,message,get,payload,instanceof,byte,logger,error,expected,byte,payload,ignoring,message,return,stomp,header,accessor,stomp,accessor,get,stomp,header,accessor,message,stomp,command,command,stomp,accessor,get,command,if,stomp,command,message,equals,command,if,stomp,accessor,get,subscription,id,null,logger,warn,no,stomp,subscription,header,in,message,string,orig,destination,stomp,accessor,get,first,native,header,simp,message,header,accessor,if,orig,destination,null,stomp,accessor,to,mutable,accessor,stomp,accessor,message,stomp,accessor,remove,native,header,simp,message,header,accessor,stomp,accessor,set,destination,orig,destination,else,if,stomp,command,connected,equals,command,this,stats,increment,connected,count,stomp,accessor,after,stomp,session,connected,message,stomp,accessor,session,if,this,event,publisher,null,stomp,command,connected,equals,command,try,simp,attributes,simp,attributes,new,simp,attributes,session,get,id,session,get,attributes,simp,attributes,context,holder,set,attributes,simp,attributes,principal,user,session,get,principal,publish,event,new,session,connected,event,this,message,byte,message,user,finally,simp,attributes,context,holder,reset,attributes,byte,payload,byte,message,get,payload,if,stomp,command,error,equals,command,get,error,handler,null,message,byte,error,message,get,error,handler,handle,error,message,to,client,message,byte,message,stomp,accessor,message,header,accessor,get,accessor,error,message,stomp,header,accessor,class,assert,not,null,stomp,accessor,expected,stomp,headers,payload,error,message,get,payload,send,to,client,session,stomp,accessor,payload
StompSubProtocolHandler -> @SuppressWarnings("unchecked") 	@Override 	public void handleMessageToClient(WebSocketSession session, Message<?> message);1440168414;Handle STOMP messages going back out to WebSocket clients.;@SuppressWarnings("unchecked")_	@Override_	public void handleMessageToClient(WebSocketSession session, Message<?> message) {_		if (!(message.getPayload() instanceof byte[])) {_			logger.error("Expected byte[] payload. Ignoring " + message + ".")__			return__		}__		StompHeaderAccessor stompAccessor = getStompHeaderAccessor(message)__		StompCommand command = stompAccessor.getCommand()___		if (StompCommand.MESSAGE.equals(command)) {_			if (stompAccessor.getSubscriptionId() == null) {_				logger.warn("No STOMP \"subscription\" header in " + message)__			}_			String origDestination = stompAccessor.getFirstNativeHeader(SimpMessageHeaderAccessor.ORIGINAL_DESTINATION)__			if (origDestination != null) {_				stompAccessor = toMutableAccessor(stompAccessor, message)__				stompAccessor.removeNativeHeader(SimpMessageHeaderAccessor.ORIGINAL_DESTINATION)__				stompAccessor.setDestination(origDestination)__			}_		}_		else if (StompCommand.CONNECTED.equals(command)) {_			this.stats.incrementConnectedCount()__			stompAccessor = afterStompSessionConnected(message, stompAccessor, session)__			if (this.eventPublisher != null && StompCommand.CONNECTED.equals(command)) {_				try {_					SimpAttributes simpAttributes = new SimpAttributes(session.getId(), session.getAttributes())__					SimpAttributesContextHolder.setAttributes(simpAttributes)__					Principal user = session.getPrincipal()__					publishEvent(new SessionConnectedEvent(this, (Message<byte[]>) message, user))__				}_				finally {_					SimpAttributesContextHolder.resetAttributes()__				}_			}_		}__		byte[] payload = (byte[]) message.getPayload()___		if (StompCommand.ERROR.equals(command) && getErrorHandler() != null) {_			Message<byte[]> errorMessage = getErrorHandler().handleErrorMessageToClient((Message<byte[]>) message)__			stompAccessor = MessageHeaderAccessor.getAccessor(errorMessage, StompHeaderAccessor.class)__			Assert.notNull(stompAccessor, "Expected STOMP headers")__			payload = errorMessage.getPayload()__		}__		sendToClient(session, stompAccessor, payload)__	};handle,stomp,messages,going,back,out,to,web,socket,clients;suppress,warnings,unchecked,override,public,void,handle,message,to,client,web,socket,session,session,message,message,if,message,get,payload,instanceof,byte,logger,error,expected,byte,payload,ignoring,message,return,stomp,header,accessor,stomp,accessor,get,stomp,header,accessor,message,stomp,command,command,stomp,accessor,get,command,if,stomp,command,message,equals,command,if,stomp,accessor,get,subscription,id,null,logger,warn,no,stomp,subscription,header,in,message,string,orig,destination,stomp,accessor,get,first,native,header,simp,message,header,accessor,if,orig,destination,null,stomp,accessor,to,mutable,accessor,stomp,accessor,message,stomp,accessor,remove,native,header,simp,message,header,accessor,stomp,accessor,set,destination,orig,destination,else,if,stomp,command,connected,equals,command,this,stats,increment,connected,count,stomp,accessor,after,stomp,session,connected,message,stomp,accessor,session,if,this,event,publisher,null,stomp,command,connected,equals,command,try,simp,attributes,simp,attributes,new,simp,attributes,session,get,id,session,get,attributes,simp,attributes,context,holder,set,attributes,simp,attributes,principal,user,session,get,principal,publish,event,new,session,connected,event,this,message,byte,message,user,finally,simp,attributes,context,holder,reset,attributes,byte,payload,byte,message,get,payload,if,stomp,command,error,equals,command,get,error,handler,null,message,byte,error,message,get,error,handler,handle,error,message,to,client,message,byte,message,stomp,accessor,message,header,accessor,get,accessor,error,message,stomp,header,accessor,class,assert,not,null,stomp,accessor,expected,stomp,headers,payload,error,message,get,payload,send,to,client,session,stomp,accessor,payload
StompSubProtocolHandler -> private StompHeaderAccessor convertConnectAcktoStompConnected(StompHeaderAccessor connectAckHeaders);1403856366;The simple broker produces {@code SimpMessageType.CONNECT_ACK} that's not STOMP_specific and needs to be turned into a STOMP CONNECTED frame.;private StompHeaderAccessor convertConnectAcktoStompConnected(StompHeaderAccessor connectAckHeaders) {_		String name = StompHeaderAccessor.CONNECT_MESSAGE_HEADER__		Message<?> message = (Message<?>) connectAckHeaders.getHeader(name)__		Assert.notNull(message, "Original STOMP CONNECT not found in " + connectAckHeaders)__		StompHeaderAccessor connectHeaders = MessageHeaderAccessor.getAccessor(message, StompHeaderAccessor.class)__		String version__		Set<String> acceptVersions = connectHeaders.getAcceptVersion()__		if (acceptVersions.contains("1.2")) {_			version = "1.2"__		}_		else if (acceptVersions.contains("1.1")) {_			version = "1.1"__		}_		else if (acceptVersions.isEmpty()) {_			version = null__		}_		else {_			throw new IllegalArgumentException("Unsupported STOMP version '" + acceptVersions + "'")__		}_		StompHeaderAccessor connectedHeaders = StompHeaderAccessor.create(StompCommand.CONNECTED)__		connectedHeaders.setVersion(version)__		connectedHeaders.setHeartbeat(0, 0)_ _		return connectedHeaders__	};the,simple,broker,produces,code,simp,message,type,that,s,not,stomp,specific,and,needs,to,be,turned,into,a,stomp,connected,frame;private,stomp,header,accessor,convert,connect,ackto,stomp,connected,stomp,header,accessor,connect,ack,headers,string,name,stomp,header,accessor,message,message,message,connect,ack,headers,get,header,name,assert,not,null,message,original,stomp,connect,not,found,in,connect,ack,headers,stomp,header,accessor,connect,headers,message,header,accessor,get,accessor,message,stomp,header,accessor,class,string,version,set,string,accept,versions,connect,headers,get,accept,version,if,accept,versions,contains,1,2,version,1,2,else,if,accept,versions,contains,1,1,version,1,1,else,if,accept,versions,is,empty,version,null,else,throw,new,illegal,argument,exception,unsupported,stomp,version,accept,versions,stomp,header,accessor,connected,headers,stomp,header,accessor,create,stomp,command,connected,connected,headers,set,version,version,connected,headers,set,heartbeat,0,0,return,connected,headers
StompSubProtocolHandler -> private StompHeaderAccessor convertConnectAcktoStompConnected(StompHeaderAccessor connectAckHeaders);1403968062;The simple broker produces {@code SimpMessageType.CONNECT_ACK} that's not STOMP_specific and needs to be turned into a STOMP CONNECTED frame.;private StompHeaderAccessor convertConnectAcktoStompConnected(StompHeaderAccessor connectAckHeaders) {_		String name = StompHeaderAccessor.CONNECT_MESSAGE_HEADER__		Message<?> message = (Message<?>) connectAckHeaders.getHeader(name)__		Assert.notNull(message, "Original STOMP CONNECT not found in " + connectAckHeaders)__		StompHeaderAccessor connectHeaders = MessageHeaderAccessor.getAccessor(message, StompHeaderAccessor.class)__		String version__		Set<String> acceptVersions = connectHeaders.getAcceptVersion()__		if (acceptVersions.contains("1.2")) {_			version = "1.2"__		}_		else if (acceptVersions.contains("1.1")) {_			version = "1.1"__		}_		else if (acceptVersions.isEmpty()) {_			version = null__		}_		else {_			throw new IllegalArgumentException("Unsupported STOMP version '" + acceptVersions + "'")__		}_		StompHeaderAccessor connectedHeaders = StompHeaderAccessor.create(StompCommand.CONNECTED)__		connectedHeaders.setVersion(version)__		connectedHeaders.setHeartbeat(0, 0)_ _		return connectedHeaders__	};the,simple,broker,produces,code,simp,message,type,that,s,not,stomp,specific,and,needs,to,be,turned,into,a,stomp,connected,frame;private,stomp,header,accessor,convert,connect,ackto,stomp,connected,stomp,header,accessor,connect,ack,headers,string,name,stomp,header,accessor,message,message,message,connect,ack,headers,get,header,name,assert,not,null,message,original,stomp,connect,not,found,in,connect,ack,headers,stomp,header,accessor,connect,headers,message,header,accessor,get,accessor,message,stomp,header,accessor,class,string,version,set,string,accept,versions,connect,headers,get,accept,version,if,accept,versions,contains,1,2,version,1,2,else,if,accept,versions,contains,1,1,version,1,1,else,if,accept,versions,is,empty,version,null,else,throw,new,illegal,argument,exception,unsupported,stomp,version,accept,versions,stomp,header,accessor,connected,headers,stomp,header,accessor,create,stomp,command,connected,connected,headers,set,version,version,connected,headers,set,heartbeat,0,0,return,connected,headers
StompSubProtocolHandler -> private StompHeaderAccessor convertConnectAcktoStompConnected(StompHeaderAccessor connectAckHeaders);1404880787;The simple broker produces {@code SimpMessageType.CONNECT_ACK} that's not STOMP_specific and needs to be turned into a STOMP CONNECTED frame.;private StompHeaderAccessor convertConnectAcktoStompConnected(StompHeaderAccessor connectAckHeaders) {_		String name = StompHeaderAccessor.CONNECT_MESSAGE_HEADER__		Message<?> message = (Message<?>) connectAckHeaders.getHeader(name)__		Assert.notNull(message, "Original STOMP CONNECT not found in " + connectAckHeaders)__		StompHeaderAccessor connectHeaders = MessageHeaderAccessor.getAccessor(message, StompHeaderAccessor.class)__		String version__		Set<String> acceptVersions = connectHeaders.getAcceptVersion()__		if (acceptVersions.contains("1.2")) {_			version = "1.2"__		}_		else if (acceptVersions.contains("1.1")) {_			version = "1.1"__		}_		else if (acceptVersions.isEmpty()) {_			version = null__		}_		else {_			throw new IllegalArgumentException("Unsupported STOMP version '" + acceptVersions + "'")__		}_		StompHeaderAccessor connectedHeaders = StompHeaderAccessor.create(StompCommand.CONNECTED)__		connectedHeaders.setVersion(version)__		connectedHeaders.setHeartbeat(0, 0)_ _		return connectedHeaders__	};the,simple,broker,produces,code,simp,message,type,that,s,not,stomp,specific,and,needs,to,be,turned,into,a,stomp,connected,frame;private,stomp,header,accessor,convert,connect,ackto,stomp,connected,stomp,header,accessor,connect,ack,headers,string,name,stomp,header,accessor,message,message,message,connect,ack,headers,get,header,name,assert,not,null,message,original,stomp,connect,not,found,in,connect,ack,headers,stomp,header,accessor,connect,headers,message,header,accessor,get,accessor,message,stomp,header,accessor,class,string,version,set,string,accept,versions,connect,headers,get,accept,version,if,accept,versions,contains,1,2,version,1,2,else,if,accept,versions,contains,1,1,version,1,1,else,if,accept,versions,is,empty,version,null,else,throw,new,illegal,argument,exception,unsupported,stomp,version,accept,versions,stomp,header,accessor,connected,headers,stomp,header,accessor,create,stomp,command,connected,connected,headers,set,version,version,connected,headers,set,heartbeat,0,0,return,connected,headers
StompSubProtocolHandler -> private StompHeaderAccessor convertConnectAcktoStompConnected(StompHeaderAccessor connectAckHeaders);1404880799;The simple broker produces {@code SimpMessageType.CONNECT_ACK} that's not STOMP_specific and needs to be turned into a STOMP CONNECTED frame.;private StompHeaderAccessor convertConnectAcktoStompConnected(StompHeaderAccessor connectAckHeaders) {_		String name = StompHeaderAccessor.CONNECT_MESSAGE_HEADER__		Message<?> message = (Message<?>) connectAckHeaders.getHeader(name)__		Assert.notNull(message, "Original STOMP CONNECT not found in " + connectAckHeaders)__		StompHeaderAccessor connectHeaders = MessageHeaderAccessor.getAccessor(message, StompHeaderAccessor.class)__		String version__		Set<String> acceptVersions = connectHeaders.getAcceptVersion()__		if (acceptVersions.contains("1.2")) {_			version = "1.2"__		}_		else if (acceptVersions.contains("1.1")) {_			version = "1.1"__		}_		else if (acceptVersions.isEmpty()) {_			version = null__		}_		else {_			throw new IllegalArgumentException("Unsupported STOMP version '" + acceptVersions + "'")__		}_		StompHeaderAccessor connectedHeaders = StompHeaderAccessor.create(StompCommand.CONNECTED)__		connectedHeaders.setVersion(version)__		connectedHeaders.setHeartbeat(0, 0)_ _		return connectedHeaders__	};the,simple,broker,produces,code,simp,message,type,that,s,not,stomp,specific,and,needs,to,be,turned,into,a,stomp,connected,frame;private,stomp,header,accessor,convert,connect,ackto,stomp,connected,stomp,header,accessor,connect,ack,headers,string,name,stomp,header,accessor,message,message,message,connect,ack,headers,get,header,name,assert,not,null,message,original,stomp,connect,not,found,in,connect,ack,headers,stomp,header,accessor,connect,headers,message,header,accessor,get,accessor,message,stomp,header,accessor,class,string,version,set,string,accept,versions,connect,headers,get,accept,version,if,accept,versions,contains,1,2,version,1,2,else,if,accept,versions,contains,1,1,version,1,1,else,if,accept,versions,is,empty,version,null,else,throw,new,illegal,argument,exception,unsupported,stomp,version,accept,versions,stomp,header,accessor,connected,headers,stomp,header,accessor,create,stomp,command,connected,connected,headers,set,version,version,connected,headers,set,heartbeat,0,0,return,connected,headers
StompSubProtocolHandler -> private StompHeaderAccessor convertConnectAcktoStompConnected(StompHeaderAccessor connectAckHeaders);1411067168;The simple broker produces {@code SimpMessageType.CONNECT_ACK} that's not STOMP_specific and needs to be turned into a STOMP CONNECTED frame.;private StompHeaderAccessor convertConnectAcktoStompConnected(StompHeaderAccessor connectAckHeaders) {_		String name = StompHeaderAccessor.CONNECT_MESSAGE_HEADER__		Message<?> message = (Message<?>) connectAckHeaders.getHeader(name)__		Assert.notNull(message, "Original STOMP CONNECT not found in " + connectAckHeaders)__		StompHeaderAccessor connectHeaders = MessageHeaderAccessor.getAccessor(message, StompHeaderAccessor.class)__		String version__		Set<String> acceptVersions = connectHeaders.getAcceptVersion()__		if (acceptVersions.contains("1.2")) {_			version = "1.2"__		}_		else if (acceptVersions.contains("1.1")) {_			version = "1.1"__		}_		else if (acceptVersions.isEmpty()) {_			version = null__		}_		else {_			throw new IllegalArgumentException("Unsupported STOMP version '" + acceptVersions + "'")__		}_		StompHeaderAccessor connectedHeaders = StompHeaderAccessor.create(StompCommand.CONNECTED)__		connectedHeaders.setVersion(version)__		connectedHeaders.setHeartbeat(0, 0)_ _		return connectedHeaders__	};the,simple,broker,produces,code,simp,message,type,that,s,not,stomp,specific,and,needs,to,be,turned,into,a,stomp,connected,frame;private,stomp,header,accessor,convert,connect,ackto,stomp,connected,stomp,header,accessor,connect,ack,headers,string,name,stomp,header,accessor,message,message,message,connect,ack,headers,get,header,name,assert,not,null,message,original,stomp,connect,not,found,in,connect,ack,headers,stomp,header,accessor,connect,headers,message,header,accessor,get,accessor,message,stomp,header,accessor,class,string,version,set,string,accept,versions,connect,headers,get,accept,version,if,accept,versions,contains,1,2,version,1,2,else,if,accept,versions,contains,1,1,version,1,1,else,if,accept,versions,is,empty,version,null,else,throw,new,illegal,argument,exception,unsupported,stomp,version,accept,versions,stomp,header,accessor,connected,headers,stomp,header,accessor,create,stomp,command,connected,connected,headers,set,version,version,connected,headers,set,heartbeat,0,0,return,connected,headers
StompSubProtocolHandler -> private StompHeaderAccessor convertConnectAcktoStompConnected(StompHeaderAccessor connectAckHeaders);1411068071;The simple broker produces {@code SimpMessageType.CONNECT_ACK} that's not STOMP_specific and needs to be turned into a STOMP CONNECTED frame.;private StompHeaderAccessor convertConnectAcktoStompConnected(StompHeaderAccessor connectAckHeaders) {_		String name = StompHeaderAccessor.CONNECT_MESSAGE_HEADER__		Message<?> message = (Message<?>) connectAckHeaders.getHeader(name)__		Assert.notNull(message, "Original STOMP CONNECT not found in " + connectAckHeaders)__		StompHeaderAccessor connectHeaders = MessageHeaderAccessor.getAccessor(message, StompHeaderAccessor.class)__		String version__		Set<String> acceptVersions = connectHeaders.getAcceptVersion()__		if (acceptVersions.contains("1.2")) {_			version = "1.2"__		}_		else if (acceptVersions.contains("1.1")) {_			version = "1.1"__		}_		else if (acceptVersions.isEmpty()) {_			version = null__		}_		else {_			throw new IllegalArgumentException("Unsupported STOMP version '" + acceptVersions + "'")__		}_		StompHeaderAccessor connectedHeaders = StompHeaderAccessor.create(StompCommand.CONNECTED)__		connectedHeaders.setVersion(version)__		connectedHeaders.setHeartbeat(0, 0)_ _		return connectedHeaders__	};the,simple,broker,produces,code,simp,message,type,that,s,not,stomp,specific,and,needs,to,be,turned,into,a,stomp,connected,frame;private,stomp,header,accessor,convert,connect,ackto,stomp,connected,stomp,header,accessor,connect,ack,headers,string,name,stomp,header,accessor,message,message,message,connect,ack,headers,get,header,name,assert,not,null,message,original,stomp,connect,not,found,in,connect,ack,headers,stomp,header,accessor,connect,headers,message,header,accessor,get,accessor,message,stomp,header,accessor,class,string,version,set,string,accept,versions,connect,headers,get,accept,version,if,accept,versions,contains,1,2,version,1,2,else,if,accept,versions,contains,1,1,version,1,1,else,if,accept,versions,is,empty,version,null,else,throw,new,illegal,argument,exception,unsupported,stomp,version,accept,versions,stomp,header,accessor,connected,headers,stomp,header,accessor,create,stomp,command,connected,connected,headers,set,version,version,connected,headers,set,heartbeat,0,0,return,connected,headers
StompSubProtocolHandler -> private StompHeaderAccessor convertConnectAcktoStompConnected(StompHeaderAccessor connectAckHeaders);1411148800;The simple broker produces {@code SimpMessageType.CONNECT_ACK} that's not STOMP_specific and needs to be turned into a STOMP CONNECTED frame.;private StompHeaderAccessor convertConnectAcktoStompConnected(StompHeaderAccessor connectAckHeaders) {_		String name = StompHeaderAccessor.CONNECT_MESSAGE_HEADER__		Message<?> message = (Message<?>) connectAckHeaders.getHeader(name)__		Assert.notNull(message, "Original STOMP CONNECT not found in " + connectAckHeaders)__		StompHeaderAccessor connectHeaders = MessageHeaderAccessor.getAccessor(message, StompHeaderAccessor.class)__		String version__		Set<String> acceptVersions = connectHeaders.getAcceptVersion()__		if (acceptVersions.contains("1.2")) {_			version = "1.2"__		}_		else if (acceptVersions.contains("1.1")) {_			version = "1.1"__		}_		else if (acceptVersions.isEmpty()) {_			version = null__		}_		else {_			throw new IllegalArgumentException("Unsupported STOMP version '" + acceptVersions + "'")__		}_		StompHeaderAccessor connectedHeaders = StompHeaderAccessor.create(StompCommand.CONNECTED)__		connectedHeaders.setVersion(version)__		connectedHeaders.setHeartbeat(0, 0)_ _		return connectedHeaders__	};the,simple,broker,produces,code,simp,message,type,that,s,not,stomp,specific,and,needs,to,be,turned,into,a,stomp,connected,frame;private,stomp,header,accessor,convert,connect,ackto,stomp,connected,stomp,header,accessor,connect,ack,headers,string,name,stomp,header,accessor,message,message,message,connect,ack,headers,get,header,name,assert,not,null,message,original,stomp,connect,not,found,in,connect,ack,headers,stomp,header,accessor,connect,headers,message,header,accessor,get,accessor,message,stomp,header,accessor,class,string,version,set,string,accept,versions,connect,headers,get,accept,version,if,accept,versions,contains,1,2,version,1,2,else,if,accept,versions,contains,1,1,version,1,1,else,if,accept,versions,is,empty,version,null,else,throw,new,illegal,argument,exception,unsupported,stomp,version,accept,versions,stomp,header,accessor,connected,headers,stomp,header,accessor,create,stomp,command,connected,connected,headers,set,version,version,connected,headers,set,heartbeat,0,0,return,connected,headers
StompSubProtocolHandler -> private StompHeaderAccessor convertConnectAcktoStompConnected(StompHeaderAccessor connectAckHeaders);1411567635;The simple broker produces {@code SimpMessageType.CONNECT_ACK} that's not STOMP_specific and needs to be turned into a STOMP CONNECTED frame.;private StompHeaderAccessor convertConnectAcktoStompConnected(StompHeaderAccessor connectAckHeaders) {_		String name = StompHeaderAccessor.CONNECT_MESSAGE_HEADER__		Message<?> message = (Message<?>) connectAckHeaders.getHeader(name)__		Assert.notNull(message, "Original STOMP CONNECT not found in " + connectAckHeaders)__		StompHeaderAccessor connectHeaders = MessageHeaderAccessor.getAccessor(message, StompHeaderAccessor.class)__		String version__		Set<String> acceptVersions = connectHeaders.getAcceptVersion()__		if (acceptVersions.contains("1.2")) {_			version = "1.2"__		}_		else if (acceptVersions.contains("1.1")) {_			version = "1.1"__		}_		else if (acceptVersions.isEmpty()) {_			version = null__		}_		else {_			throw new IllegalArgumentException("Unsupported STOMP version '" + acceptVersions + "'")__		}_		StompHeaderAccessor connectedHeaders = StompHeaderAccessor.create(StompCommand.CONNECTED)__		connectedHeaders.setVersion(version)__		connectedHeaders.setHeartbeat(0, 0)_ _		return connectedHeaders__	};the,simple,broker,produces,code,simp,message,type,that,s,not,stomp,specific,and,needs,to,be,turned,into,a,stomp,connected,frame;private,stomp,header,accessor,convert,connect,ackto,stomp,connected,stomp,header,accessor,connect,ack,headers,string,name,stomp,header,accessor,message,message,message,connect,ack,headers,get,header,name,assert,not,null,message,original,stomp,connect,not,found,in,connect,ack,headers,stomp,header,accessor,connect,headers,message,header,accessor,get,accessor,message,stomp,header,accessor,class,string,version,set,string,accept,versions,connect,headers,get,accept,version,if,accept,versions,contains,1,2,version,1,2,else,if,accept,versions,contains,1,1,version,1,1,else,if,accept,versions,is,empty,version,null,else,throw,new,illegal,argument,exception,unsupported,stomp,version,accept,versions,stomp,header,accessor,connected,headers,stomp,header,accessor,create,stomp,command,connected,connected,headers,set,version,version,connected,headers,set,heartbeat,0,0,return,connected,headers
StompSubProtocolHandler -> private StompHeaderAccessor convertConnectAcktoStompConnected(StompHeaderAccessor connectAckHeaders);1412965899;The simple broker produces {@code SimpMessageType.CONNECT_ACK} that's not STOMP_specific and needs to be turned into a STOMP CONNECTED frame.;private StompHeaderAccessor convertConnectAcktoStompConnected(StompHeaderAccessor connectAckHeaders) {_		String name = StompHeaderAccessor.CONNECT_MESSAGE_HEADER__		Message<?> message = (Message<?>) connectAckHeaders.getHeader(name)__		Assert.notNull(message, "Original STOMP CONNECT not found in " + connectAckHeaders)__		StompHeaderAccessor connectHeaders = MessageHeaderAccessor.getAccessor(message, StompHeaderAccessor.class)__		String version__		Set<String> acceptVersions = connectHeaders.getAcceptVersion()__		if (acceptVersions.contains("1.2")) {_			version = "1.2"__		}_		else if (acceptVersions.contains("1.1")) {_			version = "1.1"__		}_		else if (acceptVersions.isEmpty()) {_			version = null__		}_		else {_			throw new IllegalArgumentException("Unsupported STOMP version '" + acceptVersions + "'")__		}_		StompHeaderAccessor connectedHeaders = StompHeaderAccessor.create(StompCommand.CONNECTED)__		connectedHeaders.setVersion(version)__		connectedHeaders.setHeartbeat(0, 0)_ _		return connectedHeaders__	};the,simple,broker,produces,code,simp,message,type,that,s,not,stomp,specific,and,needs,to,be,turned,into,a,stomp,connected,frame;private,stomp,header,accessor,convert,connect,ackto,stomp,connected,stomp,header,accessor,connect,ack,headers,string,name,stomp,header,accessor,message,message,message,connect,ack,headers,get,header,name,assert,not,null,message,original,stomp,connect,not,found,in,connect,ack,headers,stomp,header,accessor,connect,headers,message,header,accessor,get,accessor,message,stomp,header,accessor,class,string,version,set,string,accept,versions,connect,headers,get,accept,version,if,accept,versions,contains,1,2,version,1,2,else,if,accept,versions,contains,1,1,version,1,1,else,if,accept,versions,is,empty,version,null,else,throw,new,illegal,argument,exception,unsupported,stomp,version,accept,versions,stomp,header,accessor,connected,headers,stomp,header,accessor,create,stomp,command,connected,connected,headers,set,version,version,connected,headers,set,heartbeat,0,0,return,connected,headers
StompSubProtocolHandler -> private StompHeaderAccessor convertConnectAcktoStompConnected(StompHeaderAccessor connectAckHeaders);1413848647;The simple broker produces {@code SimpMessageType.CONNECT_ACK} that's not STOMP_specific and needs to be turned into a STOMP CONNECTED frame.;private StompHeaderAccessor convertConnectAcktoStompConnected(StompHeaderAccessor connectAckHeaders) {_		String name = StompHeaderAccessor.CONNECT_MESSAGE_HEADER__		Message<?> message = (Message<?>) connectAckHeaders.getHeader(name)__		Assert.notNull(message, "Original STOMP CONNECT not found in " + connectAckHeaders)__		StompHeaderAccessor connectHeaders = MessageHeaderAccessor.getAccessor(message, StompHeaderAccessor.class)__		String version__		Set<String> acceptVersions = connectHeaders.getAcceptVersion()__		if (acceptVersions.contains("1.2")) {_			version = "1.2"__		}_		else if (acceptVersions.contains("1.1")) {_			version = "1.1"__		}_		else if (acceptVersions.isEmpty()) {_			version = null__		}_		else {_			throw new IllegalArgumentException("Unsupported STOMP version '" + acceptVersions + "'")__		}_		StompHeaderAccessor connectedHeaders = StompHeaderAccessor.create(StompCommand.CONNECTED)__		connectedHeaders.setVersion(version)__		connectedHeaders.setHeartbeat(0, 0)_ _		return connectedHeaders__	};the,simple,broker,produces,code,simp,message,type,that,s,not,stomp,specific,and,needs,to,be,turned,into,a,stomp,connected,frame;private,stomp,header,accessor,convert,connect,ackto,stomp,connected,stomp,header,accessor,connect,ack,headers,string,name,stomp,header,accessor,message,message,message,connect,ack,headers,get,header,name,assert,not,null,message,original,stomp,connect,not,found,in,connect,ack,headers,stomp,header,accessor,connect,headers,message,header,accessor,get,accessor,message,stomp,header,accessor,class,string,version,set,string,accept,versions,connect,headers,get,accept,version,if,accept,versions,contains,1,2,version,1,2,else,if,accept,versions,contains,1,1,version,1,1,else,if,accept,versions,is,empty,version,null,else,throw,new,illegal,argument,exception,unsupported,stomp,version,accept,versions,stomp,header,accessor,connected,headers,stomp,header,accessor,create,stomp,command,connected,connected,headers,set,version,version,connected,headers,set,heartbeat,0,0,return,connected,headers
StompSubProtocolHandler -> private StompHeaderAccessor convertConnectAcktoStompConnected(StompHeaderAccessor connectAckHeaders);1414092351;The simple broker produces {@code SimpMessageType.CONNECT_ACK} that's not STOMP_specific and needs to be turned into a STOMP CONNECTED frame.;private StompHeaderAccessor convertConnectAcktoStompConnected(StompHeaderAccessor connectAckHeaders) {_		String name = StompHeaderAccessor.CONNECT_MESSAGE_HEADER__		Message<?> message = (Message<?>) connectAckHeaders.getHeader(name)__		Assert.notNull(message, "Original STOMP CONNECT not found in " + connectAckHeaders)__		StompHeaderAccessor connectHeaders = MessageHeaderAccessor.getAccessor(message, StompHeaderAccessor.class)__		String version__		Set<String> acceptVersions = connectHeaders.getAcceptVersion()__		if (acceptVersions.contains("1.2")) {_			version = "1.2"__		}_		else if (acceptVersions.contains("1.1")) {_			version = "1.1"__		}_		else if (acceptVersions.isEmpty()) {_			version = null__		}_		else {_			throw new IllegalArgumentException("Unsupported STOMP version '" + acceptVersions + "'")__		}_		StompHeaderAccessor connectedHeaders = StompHeaderAccessor.create(StompCommand.CONNECTED)__		connectedHeaders.setVersion(version)__		connectedHeaders.setHeartbeat(0, 0)_ _		return connectedHeaders__	};the,simple,broker,produces,code,simp,message,type,that,s,not,stomp,specific,and,needs,to,be,turned,into,a,stomp,connected,frame;private,stomp,header,accessor,convert,connect,ackto,stomp,connected,stomp,header,accessor,connect,ack,headers,string,name,stomp,header,accessor,message,message,message,connect,ack,headers,get,header,name,assert,not,null,message,original,stomp,connect,not,found,in,connect,ack,headers,stomp,header,accessor,connect,headers,message,header,accessor,get,accessor,message,stomp,header,accessor,class,string,version,set,string,accept,versions,connect,headers,get,accept,version,if,accept,versions,contains,1,2,version,1,2,else,if,accept,versions,contains,1,1,version,1,1,else,if,accept,versions,is,empty,version,null,else,throw,new,illegal,argument,exception,unsupported,stomp,version,accept,versions,stomp,header,accessor,connected,headers,stomp,header,accessor,create,stomp,command,connected,connected,headers,set,version,version,connected,headers,set,heartbeat,0,0,return,connected,headers
StompSubProtocolHandler -> private StompHeaderAccessor convertConnectAcktoStompConnected(StompHeaderAccessor connectAckHeaders);1414158498;The simple broker produces {@code SimpMessageType.CONNECT_ACK} that's not STOMP_specific and needs to be turned into a STOMP CONNECTED frame.;private StompHeaderAccessor convertConnectAcktoStompConnected(StompHeaderAccessor connectAckHeaders) {_		String name = StompHeaderAccessor.CONNECT_MESSAGE_HEADER__		Message<?> message = (Message<?>) connectAckHeaders.getHeader(name)__		Assert.notNull(message, "Original STOMP CONNECT not found in " + connectAckHeaders)__		StompHeaderAccessor connectHeaders = MessageHeaderAccessor.getAccessor(message, StompHeaderAccessor.class)__		String version__		Set<String> acceptVersions = connectHeaders.getAcceptVersion()__		if (acceptVersions.contains("1.2")) {_			version = "1.2"__		}_		else if (acceptVersions.contains("1.1")) {_			version = "1.1"__		}_		else if (acceptVersions.isEmpty()) {_			version = null__		}_		else {_			throw new IllegalArgumentException("Unsupported STOMP version '" + acceptVersions + "'")__		}_		StompHeaderAccessor connectedHeaders = StompHeaderAccessor.create(StompCommand.CONNECTED)__		connectedHeaders.setVersion(version)__		connectedHeaders.setHeartbeat(0, 0)_ _		return connectedHeaders__	};the,simple,broker,produces,code,simp,message,type,that,s,not,stomp,specific,and,needs,to,be,turned,into,a,stomp,connected,frame;private,stomp,header,accessor,convert,connect,ackto,stomp,connected,stomp,header,accessor,connect,ack,headers,string,name,stomp,header,accessor,message,message,message,connect,ack,headers,get,header,name,assert,not,null,message,original,stomp,connect,not,found,in,connect,ack,headers,stomp,header,accessor,connect,headers,message,header,accessor,get,accessor,message,stomp,header,accessor,class,string,version,set,string,accept,versions,connect,headers,get,accept,version,if,accept,versions,contains,1,2,version,1,2,else,if,accept,versions,contains,1,1,version,1,1,else,if,accept,versions,is,empty,version,null,else,throw,new,illegal,argument,exception,unsupported,stomp,version,accept,versions,stomp,header,accessor,connected,headers,stomp,header,accessor,create,stomp,command,connected,connected,headers,set,version,version,connected,headers,set,heartbeat,0,0,return,connected,headers
StompSubProtocolHandler -> private StompHeaderAccessor convertConnectAcktoStompConnected(StompHeaderAccessor connectAckHeaders);1419362683;The simple broker produces {@code SimpMessageType.CONNECT_ACK} that's not STOMP_specific and needs to be turned into a STOMP CONNECTED frame.;private StompHeaderAccessor convertConnectAcktoStompConnected(StompHeaderAccessor connectAckHeaders) {_		String name = StompHeaderAccessor.CONNECT_MESSAGE_HEADER__		Message<?> message = (Message<?>) connectAckHeaders.getHeader(name)__		Assert.notNull(message, "Original STOMP CONNECT not found in " + connectAckHeaders)__		StompHeaderAccessor connectHeaders = MessageHeaderAccessor.getAccessor(message, StompHeaderAccessor.class)__		String version__		Set<String> acceptVersions = connectHeaders.getAcceptVersion()__		if (acceptVersions.contains("1.2")) {_			version = "1.2"__		}_		else if (acceptVersions.contains("1.1")) {_			version = "1.1"__		}_		else if (acceptVersions.isEmpty()) {_			version = null__		}_		else {_			throw new IllegalArgumentException("Unsupported STOMP version '" + acceptVersions + "'")__		}_		StompHeaderAccessor connectedHeaders = StompHeaderAccessor.create(StompCommand.CONNECTED)__		connectedHeaders.setVersion(version)__		connectedHeaders.setHeartbeat(0, 0)_ _		return connectedHeaders__	};the,simple,broker,produces,code,simp,message,type,that,s,not,stomp,specific,and,needs,to,be,turned,into,a,stomp,connected,frame;private,stomp,header,accessor,convert,connect,ackto,stomp,connected,stomp,header,accessor,connect,ack,headers,string,name,stomp,header,accessor,message,message,message,connect,ack,headers,get,header,name,assert,not,null,message,original,stomp,connect,not,found,in,connect,ack,headers,stomp,header,accessor,connect,headers,message,header,accessor,get,accessor,message,stomp,header,accessor,class,string,version,set,string,accept,versions,connect,headers,get,accept,version,if,accept,versions,contains,1,2,version,1,2,else,if,accept,versions,contains,1,1,version,1,1,else,if,accept,versions,is,empty,version,null,else,throw,new,illegal,argument,exception,unsupported,stomp,version,accept,versions,stomp,header,accessor,connected,headers,stomp,header,accessor,create,stomp,command,connected,connected,headers,set,version,version,connected,headers,set,heartbeat,0,0,return,connected,headers
StompSubProtocolHandler -> private StompHeaderAccessor convertConnectAcktoStompConnected(StompHeaderAccessor connectAckHeaders);1419883989;The simple broker produces {@code SimpMessageType.CONNECT_ACK} that's not STOMP_specific and needs to be turned into a STOMP CONNECTED frame.;private StompHeaderAccessor convertConnectAcktoStompConnected(StompHeaderAccessor connectAckHeaders) {_		String name = StompHeaderAccessor.CONNECT_MESSAGE_HEADER__		Message<?> message = (Message<?>) connectAckHeaders.getHeader(name)__		Assert.notNull(message, "Original STOMP CONNECT not found in " + connectAckHeaders)__		StompHeaderAccessor connectHeaders = MessageHeaderAccessor.getAccessor(message, StompHeaderAccessor.class)__		String version__		Set<String> acceptVersions = connectHeaders.getAcceptVersion()__		if (acceptVersions.contains("1.2")) {_			version = "1.2"__		}_		else if (acceptVersions.contains("1.1")) {_			version = "1.1"__		}_		else if (acceptVersions.isEmpty()) {_			version = null__		}_		else {_			throw new IllegalArgumentException("Unsupported STOMP version '" + acceptVersions + "'")__		}_		StompHeaderAccessor connectedHeaders = StompHeaderAccessor.create(StompCommand.CONNECTED)__		connectedHeaders.setVersion(version)__		connectedHeaders.setHeartbeat(0, 0)_ _		return connectedHeaders__	};the,simple,broker,produces,code,simp,message,type,that,s,not,stomp,specific,and,needs,to,be,turned,into,a,stomp,connected,frame;private,stomp,header,accessor,convert,connect,ackto,stomp,connected,stomp,header,accessor,connect,ack,headers,string,name,stomp,header,accessor,message,message,message,connect,ack,headers,get,header,name,assert,not,null,message,original,stomp,connect,not,found,in,connect,ack,headers,stomp,header,accessor,connect,headers,message,header,accessor,get,accessor,message,stomp,header,accessor,class,string,version,set,string,accept,versions,connect,headers,get,accept,version,if,accept,versions,contains,1,2,version,1,2,else,if,accept,versions,contains,1,1,version,1,1,else,if,accept,versions,is,empty,version,null,else,throw,new,illegal,argument,exception,unsupported,stomp,version,accept,versions,stomp,header,accessor,connected,headers,stomp,header,accessor,create,stomp,command,connected,connected,headers,set,version,version,connected,headers,set,heartbeat,0,0,return,connected,headers
StompSubProtocolHandler -> private StompHeaderAccessor convertConnectAcktoStompConnected(StompHeaderAccessor connectAckHeaders);1424278379;The simple broker produces {@code SimpMessageType.CONNECT_ACK} that's not STOMP_specific and needs to be turned into a STOMP CONNECTED frame.;private StompHeaderAccessor convertConnectAcktoStompConnected(StompHeaderAccessor connectAckHeaders) {_		String name = StompHeaderAccessor.CONNECT_MESSAGE_HEADER__		Message<?> message = (Message<?>) connectAckHeaders.getHeader(name)__		Assert.notNull(message, "Original STOMP CONNECT not found in " + connectAckHeaders)__		StompHeaderAccessor connectHeaders = MessageHeaderAccessor.getAccessor(message, StompHeaderAccessor.class)__		String version__		Set<String> acceptVersions = connectHeaders.getAcceptVersion()__		if (acceptVersions.contains("1.2")) {_			version = "1.2"__		}_		else if (acceptVersions.contains("1.1")) {_			version = "1.1"__		}_		else if (acceptVersions.isEmpty()) {_			version = null__		}_		else {_			throw new IllegalArgumentException("Unsupported STOMP version '" + acceptVersions + "'")__		}_		StompHeaderAccessor connectedHeaders = StompHeaderAccessor.create(StompCommand.CONNECTED)__		connectedHeaders.setVersion(version)__		connectedHeaders.setHeartbeat(0, 0)_ _		return connectedHeaders__	};the,simple,broker,produces,code,simp,message,type,that,s,not,stomp,specific,and,needs,to,be,turned,into,a,stomp,connected,frame;private,stomp,header,accessor,convert,connect,ackto,stomp,connected,stomp,header,accessor,connect,ack,headers,string,name,stomp,header,accessor,message,message,message,connect,ack,headers,get,header,name,assert,not,null,message,original,stomp,connect,not,found,in,connect,ack,headers,stomp,header,accessor,connect,headers,message,header,accessor,get,accessor,message,stomp,header,accessor,class,string,version,set,string,accept,versions,connect,headers,get,accept,version,if,accept,versions,contains,1,2,version,1,2,else,if,accept,versions,contains,1,1,version,1,1,else,if,accept,versions,is,empty,version,null,else,throw,new,illegal,argument,exception,unsupported,stomp,version,accept,versions,stomp,header,accessor,connected,headers,stomp,header,accessor,create,stomp,command,connected,connected,headers,set,version,version,connected,headers,set,heartbeat,0,0,return,connected,headers
StompSubProtocolHandler -> private StompHeaderAccessor convertConnectAcktoStompConnected(StompHeaderAccessor connectAckHeaders);1428353843;The simple broker produces {@code SimpMessageType.CONNECT_ACK} that's not STOMP_specific and needs to be turned into a STOMP CONNECTED frame.;private StompHeaderAccessor convertConnectAcktoStompConnected(StompHeaderAccessor connectAckHeaders) {_		String name = StompHeaderAccessor.CONNECT_MESSAGE_HEADER__		Message<?> message = (Message<?>) connectAckHeaders.getHeader(name)__		Assert.notNull(message, "Original STOMP CONNECT not found in " + connectAckHeaders)__		StompHeaderAccessor connectHeaders = MessageHeaderAccessor.getAccessor(message, StompHeaderAccessor.class)__		StompHeaderAccessor connectedHeaders = StompHeaderAccessor.create(StompCommand.CONNECTED)__		Set<String> acceptVersions = connectHeaders.getAcceptVersion()__		if (acceptVersions.contains("1.2")) {_			connectedHeaders.setVersion("1.2")__		}_		else if (acceptVersions.contains("1.1")) {_			connectedHeaders.setVersion("1.1")__		}_		else if (!acceptVersions.isEmpty()) {_			throw new IllegalArgumentException("Unsupported STOMP version '" + acceptVersions + "'")__		}_		long[] heartbeat = (long[]) connectAckHeaders.getHeader(SimpMessageHeaderAccessor.HEART_BEAT_HEADER)__		if (heartbeat != null) {_			connectedHeaders.setHeartbeat(heartbeat[0], heartbeat[1])__		}_		return connectedHeaders__	};the,simple,broker,produces,code,simp,message,type,that,s,not,stomp,specific,and,needs,to,be,turned,into,a,stomp,connected,frame;private,stomp,header,accessor,convert,connect,ackto,stomp,connected,stomp,header,accessor,connect,ack,headers,string,name,stomp,header,accessor,message,message,message,connect,ack,headers,get,header,name,assert,not,null,message,original,stomp,connect,not,found,in,connect,ack,headers,stomp,header,accessor,connect,headers,message,header,accessor,get,accessor,message,stomp,header,accessor,class,stomp,header,accessor,connected,headers,stomp,header,accessor,create,stomp,command,connected,set,string,accept,versions,connect,headers,get,accept,version,if,accept,versions,contains,1,2,connected,headers,set,version,1,2,else,if,accept,versions,contains,1,1,connected,headers,set,version,1,1,else,if,accept,versions,is,empty,throw,new,illegal,argument,exception,unsupported,stomp,version,accept,versions,long,heartbeat,long,connect,ack,headers,get,header,simp,message,header,accessor,if,heartbeat,null,connected,headers,set,heartbeat,heartbeat,0,heartbeat,1,return,connected,headers
StompSubProtocolHandler -> private StompHeaderAccessor convertConnectAcktoStompConnected(StompHeaderAccessor connectAckHeaders);1430834982;The simple broker produces {@code SimpMessageType.CONNECT_ACK} that's not STOMP_specific and needs to be turned into a STOMP CONNECTED frame.;private StompHeaderAccessor convertConnectAcktoStompConnected(StompHeaderAccessor connectAckHeaders) {_		String name = StompHeaderAccessor.CONNECT_MESSAGE_HEADER__		Message<?> message = (Message<?>) connectAckHeaders.getHeader(name)__		Assert.notNull(message, "Original STOMP CONNECT not found in " + connectAckHeaders)__		StompHeaderAccessor connectHeaders = MessageHeaderAccessor.getAccessor(message, StompHeaderAccessor.class)__		StompHeaderAccessor connectedHeaders = StompHeaderAccessor.create(StompCommand.CONNECTED)__		Set<String> acceptVersions = connectHeaders.getAcceptVersion()__		if (acceptVersions.contains("1.2")) {_			connectedHeaders.setVersion("1.2")__		}_		else if (acceptVersions.contains("1.1")) {_			connectedHeaders.setVersion("1.1")__		}_		else if (!acceptVersions.isEmpty()) {_			throw new IllegalArgumentException("Unsupported STOMP version '" + acceptVersions + "'")__		}_		long[] heartbeat = (long[]) connectAckHeaders.getHeader(SimpMessageHeaderAccessor.HEART_BEAT_HEADER)__		if (heartbeat != null) {_			connectedHeaders.setHeartbeat(heartbeat[0], heartbeat[1])__		} else {_			connectedHeaders.setHeartbeat(0, 0)__		}_		return connectedHeaders__	};the,simple,broker,produces,code,simp,message,type,that,s,not,stomp,specific,and,needs,to,be,turned,into,a,stomp,connected,frame;private,stomp,header,accessor,convert,connect,ackto,stomp,connected,stomp,header,accessor,connect,ack,headers,string,name,stomp,header,accessor,message,message,message,connect,ack,headers,get,header,name,assert,not,null,message,original,stomp,connect,not,found,in,connect,ack,headers,stomp,header,accessor,connect,headers,message,header,accessor,get,accessor,message,stomp,header,accessor,class,stomp,header,accessor,connected,headers,stomp,header,accessor,create,stomp,command,connected,set,string,accept,versions,connect,headers,get,accept,version,if,accept,versions,contains,1,2,connected,headers,set,version,1,2,else,if,accept,versions,contains,1,1,connected,headers,set,version,1,1,else,if,accept,versions,is,empty,throw,new,illegal,argument,exception,unsupported,stomp,version,accept,versions,long,heartbeat,long,connect,ack,headers,get,header,simp,message,header,accessor,if,heartbeat,null,connected,headers,set,heartbeat,heartbeat,0,heartbeat,1,else,connected,headers,set,heartbeat,0,0,return,connected,headers
StompSubProtocolHandler -> private StompHeaderAccessor convertConnectAcktoStompConnected(StompHeaderAccessor connectAckHeaders);1431458952;The simple broker produces {@code SimpMessageType.CONNECT_ACK} that's not STOMP_specific and needs to be turned into a STOMP CONNECTED frame.;private StompHeaderAccessor convertConnectAcktoStompConnected(StompHeaderAccessor connectAckHeaders) {_		String name = StompHeaderAccessor.CONNECT_MESSAGE_HEADER__		Message<?> message = (Message<?>) connectAckHeaders.getHeader(name)__		Assert.notNull(message, "Original STOMP CONNECT not found in " + connectAckHeaders)__		StompHeaderAccessor connectHeaders = MessageHeaderAccessor.getAccessor(message, StompHeaderAccessor.class)__		StompHeaderAccessor connectedHeaders = StompHeaderAccessor.create(StompCommand.CONNECTED)__		Set<String> acceptVersions = connectHeaders.getAcceptVersion()__		if (acceptVersions.contains("1.2")) {_			connectedHeaders.setVersion("1.2")__		}_		else if (acceptVersions.contains("1.1")) {_			connectedHeaders.setVersion("1.1")__		}_		else if (!acceptVersions.isEmpty()) {_			throw new IllegalArgumentException("Unsupported STOMP version '" + acceptVersions + "'")__		}_		long[] heartbeat = (long[]) connectAckHeaders.getHeader(SimpMessageHeaderAccessor.HEART_BEAT_HEADER)__		if (heartbeat != null) {_			connectedHeaders.setHeartbeat(heartbeat[0], heartbeat[1])__		} else {_			connectedHeaders.setHeartbeat(0, 0)__		}_		return connectedHeaders__	};the,simple,broker,produces,code,simp,message,type,that,s,not,stomp,specific,and,needs,to,be,turned,into,a,stomp,connected,frame;private,stomp,header,accessor,convert,connect,ackto,stomp,connected,stomp,header,accessor,connect,ack,headers,string,name,stomp,header,accessor,message,message,message,connect,ack,headers,get,header,name,assert,not,null,message,original,stomp,connect,not,found,in,connect,ack,headers,stomp,header,accessor,connect,headers,message,header,accessor,get,accessor,message,stomp,header,accessor,class,stomp,header,accessor,connected,headers,stomp,header,accessor,create,stomp,command,connected,set,string,accept,versions,connect,headers,get,accept,version,if,accept,versions,contains,1,2,connected,headers,set,version,1,2,else,if,accept,versions,contains,1,1,connected,headers,set,version,1,1,else,if,accept,versions,is,empty,throw,new,illegal,argument,exception,unsupported,stomp,version,accept,versions,long,heartbeat,long,connect,ack,headers,get,header,simp,message,header,accessor,if,heartbeat,null,connected,headers,set,heartbeat,heartbeat,0,heartbeat,1,else,connected,headers,set,heartbeat,0,0,return,connected,headers
StompSubProtocolHandler -> private StompHeaderAccessor convertConnectAcktoStompConnected(StompHeaderAccessor connectAckHeaders);1431728285;The simple broker produces {@code SimpMessageType.CONNECT_ACK} that's not STOMP_specific and needs to be turned into a STOMP CONNECTED frame.;private StompHeaderAccessor convertConnectAcktoStompConnected(StompHeaderAccessor connectAckHeaders) {_		String name = StompHeaderAccessor.CONNECT_MESSAGE_HEADER__		Message<?> message = (Message<?>) connectAckHeaders.getHeader(name)__		Assert.notNull(message, "Original STOMP CONNECT not found in " + connectAckHeaders)__		StompHeaderAccessor connectHeaders = MessageHeaderAccessor.getAccessor(message, StompHeaderAccessor.class)__		StompHeaderAccessor connectedHeaders = StompHeaderAccessor.create(StompCommand.CONNECTED)__		Set<String> acceptVersions = connectHeaders.getAcceptVersion()__		if (acceptVersions.contains("1.2")) {_			connectedHeaders.setVersion("1.2")__		}_		else if (acceptVersions.contains("1.1")) {_			connectedHeaders.setVersion("1.1")__		}_		else if (!acceptVersions.isEmpty()) {_			throw new IllegalArgumentException("Unsupported STOMP version '" + acceptVersions + "'")__		}_		long[] heartbeat = (long[]) connectAckHeaders.getHeader(SimpMessageHeaderAccessor.HEART_BEAT_HEADER)__		if (heartbeat != null) {_			connectedHeaders.setHeartbeat(heartbeat[0], heartbeat[1])__		} else {_			connectedHeaders.setHeartbeat(0, 0)__		}_		return connectedHeaders__	};the,simple,broker,produces,code,simp,message,type,that,s,not,stomp,specific,and,needs,to,be,turned,into,a,stomp,connected,frame;private,stomp,header,accessor,convert,connect,ackto,stomp,connected,stomp,header,accessor,connect,ack,headers,string,name,stomp,header,accessor,message,message,message,connect,ack,headers,get,header,name,assert,not,null,message,original,stomp,connect,not,found,in,connect,ack,headers,stomp,header,accessor,connect,headers,message,header,accessor,get,accessor,message,stomp,header,accessor,class,stomp,header,accessor,connected,headers,stomp,header,accessor,create,stomp,command,connected,set,string,accept,versions,connect,headers,get,accept,version,if,accept,versions,contains,1,2,connected,headers,set,version,1,2,else,if,accept,versions,contains,1,1,connected,headers,set,version,1,1,else,if,accept,versions,is,empty,throw,new,illegal,argument,exception,unsupported,stomp,version,accept,versions,long,heartbeat,long,connect,ack,headers,get,header,simp,message,header,accessor,if,heartbeat,null,connected,headers,set,heartbeat,heartbeat,0,heartbeat,1,else,connected,headers,set,heartbeat,0,0,return,connected,headers
StompSubProtocolHandler -> private StompHeaderAccessor convertConnectAcktoStompConnected(StompHeaderAccessor connectAckHeaders);1432316649;The simple broker produces {@code SimpMessageType.CONNECT_ACK} that's not STOMP_specific and needs to be turned into a STOMP CONNECTED frame.;private StompHeaderAccessor convertConnectAcktoStompConnected(StompHeaderAccessor connectAckHeaders) {_		String name = StompHeaderAccessor.CONNECT_MESSAGE_HEADER__		Message<?> message = (Message<?>) connectAckHeaders.getHeader(name)__		Assert.notNull(message, "Original STOMP CONNECT not found in " + connectAckHeaders)__		StompHeaderAccessor connectHeaders = MessageHeaderAccessor.getAccessor(message, StompHeaderAccessor.class)__		StompHeaderAccessor connectedHeaders = StompHeaderAccessor.create(StompCommand.CONNECTED)__		Set<String> acceptVersions = connectHeaders.getAcceptVersion()__		if (acceptVersions.contains("1.2")) {_			connectedHeaders.setVersion("1.2")__		}_		else if (acceptVersions.contains("1.1")) {_			connectedHeaders.setVersion("1.1")__		}_		else if (!acceptVersions.isEmpty()) {_			throw new IllegalArgumentException("Unsupported STOMP version '" + acceptVersions + "'")__		}_		long[] heartbeat = (long[]) connectAckHeaders.getHeader(SimpMessageHeaderAccessor.HEART_BEAT_HEADER)__		if (heartbeat != null) {_			connectedHeaders.setHeartbeat(heartbeat[0], heartbeat[1])__		} else {_			connectedHeaders.setHeartbeat(0, 0)__		}_		return connectedHeaders__	};the,simple,broker,produces,code,simp,message,type,that,s,not,stomp,specific,and,needs,to,be,turned,into,a,stomp,connected,frame;private,stomp,header,accessor,convert,connect,ackto,stomp,connected,stomp,header,accessor,connect,ack,headers,string,name,stomp,header,accessor,message,message,message,connect,ack,headers,get,header,name,assert,not,null,message,original,stomp,connect,not,found,in,connect,ack,headers,stomp,header,accessor,connect,headers,message,header,accessor,get,accessor,message,stomp,header,accessor,class,stomp,header,accessor,connected,headers,stomp,header,accessor,create,stomp,command,connected,set,string,accept,versions,connect,headers,get,accept,version,if,accept,versions,contains,1,2,connected,headers,set,version,1,2,else,if,accept,versions,contains,1,1,connected,headers,set,version,1,1,else,if,accept,versions,is,empty,throw,new,illegal,argument,exception,unsupported,stomp,version,accept,versions,long,heartbeat,long,connect,ack,headers,get,header,simp,message,header,accessor,if,heartbeat,null,connected,headers,set,heartbeat,heartbeat,0,heartbeat,1,else,connected,headers,set,heartbeat,0,0,return,connected,headers
StompSubProtocolHandler -> private StompHeaderAccessor convertConnectAcktoStompConnected(StompHeaderAccessor connectAckHeaders);1432331447;The simple broker produces {@code SimpMessageType.CONNECT_ACK} that's not STOMP_specific and needs to be turned into a STOMP CONNECTED frame.;private StompHeaderAccessor convertConnectAcktoStompConnected(StompHeaderAccessor connectAckHeaders) {_		String name = StompHeaderAccessor.CONNECT_MESSAGE_HEADER__		Message<?> message = (Message<?>) connectAckHeaders.getHeader(name)__		Assert.notNull(message, "Original STOMP CONNECT not found in " + connectAckHeaders)__		StompHeaderAccessor connectHeaders = MessageHeaderAccessor.getAccessor(message, StompHeaderAccessor.class)__		StompHeaderAccessor connectedHeaders = StompHeaderAccessor.create(StompCommand.CONNECTED)__		Set<String> acceptVersions = connectHeaders.getAcceptVersion()__		if (acceptVersions.contains("1.2")) {_			connectedHeaders.setVersion("1.2")__		}_		else if (acceptVersions.contains("1.1")) {_			connectedHeaders.setVersion("1.1")__		}_		else if (!acceptVersions.isEmpty()) {_			throw new IllegalArgumentException("Unsupported STOMP version '" + acceptVersions + "'")__		}_		long[] heartbeat = (long[]) connectAckHeaders.getHeader(SimpMessageHeaderAccessor.HEART_BEAT_HEADER)__		if (heartbeat != null) {_			connectedHeaders.setHeartbeat(heartbeat[0], heartbeat[1])__		}_		else {_			connectedHeaders.setHeartbeat(0, 0)__		}_		return connectedHeaders__	};the,simple,broker,produces,code,simp,message,type,that,s,not,stomp,specific,and,needs,to,be,turned,into,a,stomp,connected,frame;private,stomp,header,accessor,convert,connect,ackto,stomp,connected,stomp,header,accessor,connect,ack,headers,string,name,stomp,header,accessor,message,message,message,connect,ack,headers,get,header,name,assert,not,null,message,original,stomp,connect,not,found,in,connect,ack,headers,stomp,header,accessor,connect,headers,message,header,accessor,get,accessor,message,stomp,header,accessor,class,stomp,header,accessor,connected,headers,stomp,header,accessor,create,stomp,command,connected,set,string,accept,versions,connect,headers,get,accept,version,if,accept,versions,contains,1,2,connected,headers,set,version,1,2,else,if,accept,versions,contains,1,1,connected,headers,set,version,1,1,else,if,accept,versions,is,empty,throw,new,illegal,argument,exception,unsupported,stomp,version,accept,versions,long,heartbeat,long,connect,ack,headers,get,header,simp,message,header,accessor,if,heartbeat,null,connected,headers,set,heartbeat,heartbeat,0,heartbeat,1,else,connected,headers,set,heartbeat,0,0,return,connected,headers
StompSubProtocolHandler -> private StompHeaderAccessor convertConnectAcktoStompConnected(StompHeaderAccessor connectAckHeaders);1440168414;The simple broker produces {@code SimpMessageType.CONNECT_ACK} that's not STOMP_specific and needs to be turned into a STOMP CONNECTED frame.;private StompHeaderAccessor convertConnectAcktoStompConnected(StompHeaderAccessor connectAckHeaders) {_		String name = StompHeaderAccessor.CONNECT_MESSAGE_HEADER__		Message<?> message = (Message<?>) connectAckHeaders.getHeader(name)__		Assert.notNull(message, "Original STOMP CONNECT not found in " + connectAckHeaders)__		StompHeaderAccessor connectHeaders = MessageHeaderAccessor.getAccessor(message, StompHeaderAccessor.class)__		StompHeaderAccessor connectedHeaders = StompHeaderAccessor.create(StompCommand.CONNECTED)__		Set<String> acceptVersions = connectHeaders.getAcceptVersion()__		if (acceptVersions.contains("1.2")) {_			connectedHeaders.setVersion("1.2")__		}_		else if (acceptVersions.contains("1.1")) {_			connectedHeaders.setVersion("1.1")__		}_		else if (!acceptVersions.isEmpty()) {_			throw new IllegalArgumentException("Unsupported STOMP version '" + acceptVersions + "'")__		}_		long[] heartbeat = (long[]) connectAckHeaders.getHeader(SimpMessageHeaderAccessor.HEART_BEAT_HEADER)__		if (heartbeat != null) {_			connectedHeaders.setHeartbeat(heartbeat[0], heartbeat[1])__		}_		else {_			connectedHeaders.setHeartbeat(0, 0)__		}_		return connectedHeaders__	};the,simple,broker,produces,code,simp,message,type,that,s,not,stomp,specific,and,needs,to,be,turned,into,a,stomp,connected,frame;private,stomp,header,accessor,convert,connect,ackto,stomp,connected,stomp,header,accessor,connect,ack,headers,string,name,stomp,header,accessor,message,message,message,connect,ack,headers,get,header,name,assert,not,null,message,original,stomp,connect,not,found,in,connect,ack,headers,stomp,header,accessor,connect,headers,message,header,accessor,get,accessor,message,stomp,header,accessor,class,stomp,header,accessor,connected,headers,stomp,header,accessor,create,stomp,command,connected,set,string,accept,versions,connect,headers,get,accept,version,if,accept,versions,contains,1,2,connected,headers,set,version,1,2,else,if,accept,versions,contains,1,1,connected,headers,set,version,1,1,else,if,accept,versions,is,empty,throw,new,illegal,argument,exception,unsupported,stomp,version,accept,versions,long,heartbeat,long,connect,ack,headers,get,header,simp,message,header,accessor,if,heartbeat,null,connected,headers,set,heartbeat,heartbeat,0,heartbeat,1,else,connected,headers,set,heartbeat,0,0,return,connected,headers
StompSubProtocolHandler -> private StompHeaderAccessor convertConnectAcktoStompConnected(StompHeaderAccessor connectAckHeaders);1440249342;The simple broker produces {@code SimpMessageType.CONNECT_ACK} that's not STOMP_specific and needs to be turned into a STOMP CONNECTED frame.;private StompHeaderAccessor convertConnectAcktoStompConnected(StompHeaderAccessor connectAckHeaders) {_		String name = StompHeaderAccessor.CONNECT_MESSAGE_HEADER__		Message<?> message = (Message<?>) connectAckHeaders.getHeader(name)__		Assert.notNull(message, "Original STOMP CONNECT not found in " + connectAckHeaders)__		StompHeaderAccessor connectHeaders = MessageHeaderAccessor.getAccessor(message, StompHeaderAccessor.class)__		StompHeaderAccessor connectedHeaders = StompHeaderAccessor.create(StompCommand.CONNECTED)__		Set<String> acceptVersions = connectHeaders.getAcceptVersion()__		if (acceptVersions.contains("1.2")) {_			connectedHeaders.setVersion("1.2")__		}_		else if (acceptVersions.contains("1.1")) {_			connectedHeaders.setVersion("1.1")__		}_		else if (!acceptVersions.isEmpty()) {_			throw new IllegalArgumentException("Unsupported STOMP version '" + acceptVersions + "'")__		}_		long[] heartbeat = (long[]) connectAckHeaders.getHeader(SimpMessageHeaderAccessor.HEART_BEAT_HEADER)__		if (heartbeat != null) {_			connectedHeaders.setHeartbeat(heartbeat[0], heartbeat[1])__		}_		else {_			connectedHeaders.setHeartbeat(0, 0)__		}_		return connectedHeaders__	};the,simple,broker,produces,code,simp,message,type,that,s,not,stomp,specific,and,needs,to,be,turned,into,a,stomp,connected,frame;private,stomp,header,accessor,convert,connect,ackto,stomp,connected,stomp,header,accessor,connect,ack,headers,string,name,stomp,header,accessor,message,message,message,connect,ack,headers,get,header,name,assert,not,null,message,original,stomp,connect,not,found,in,connect,ack,headers,stomp,header,accessor,connect,headers,message,header,accessor,get,accessor,message,stomp,header,accessor,class,stomp,header,accessor,connected,headers,stomp,header,accessor,create,stomp,command,connected,set,string,accept,versions,connect,headers,get,accept,version,if,accept,versions,contains,1,2,connected,headers,set,version,1,2,else,if,accept,versions,contains,1,1,connected,headers,set,version,1,1,else,if,accept,versions,is,empty,throw,new,illegal,argument,exception,unsupported,stomp,version,accept,versions,long,heartbeat,long,connect,ack,headers,get,header,simp,message,header,accessor,if,heartbeat,null,connected,headers,set,heartbeat,heartbeat,0,heartbeat,1,else,connected,headers,set,heartbeat,0,0,return,connected,headers
StompSubProtocolHandler -> private StompHeaderAccessor convertConnectAcktoStompConnected(StompHeaderAccessor connectAckHeaders);1467726769;The simple broker produces {@code SimpMessageType.CONNECT_ACK} that's not STOMP_specific and needs to be turned into a STOMP CONNECTED frame.;private StompHeaderAccessor convertConnectAcktoStompConnected(StompHeaderAccessor connectAckHeaders) {_		String name = StompHeaderAccessor.CONNECT_MESSAGE_HEADER__		Message<?> message = (Message<?>) connectAckHeaders.getHeader(name)__		Assert.notNull(message, "Original STOMP CONNECT not found in " + connectAckHeaders)__		StompHeaderAccessor connectHeaders = MessageHeaderAccessor.getAccessor(message, StompHeaderAccessor.class)__		StompHeaderAccessor connectedHeaders = StompHeaderAccessor.create(StompCommand.CONNECTED)__		Set<String> acceptVersions = connectHeaders.getAcceptVersion()__		if (acceptVersions.contains("1.2")) {_			connectedHeaders.setVersion("1.2")__		}_		else if (acceptVersions.contains("1.1")) {_			connectedHeaders.setVersion("1.1")__		}_		else if (!acceptVersions.isEmpty()) {_			throw new IllegalArgumentException("Unsupported STOMP version '" + acceptVersions + "'")__		}_		long[] heartbeat = (long[]) connectAckHeaders.getHeader(SimpMessageHeaderAccessor.HEART_BEAT_HEADER)__		if (heartbeat != null) {_			connectedHeaders.setHeartbeat(heartbeat[0], heartbeat[1])__		}_		else {_			connectedHeaders.setHeartbeat(0, 0)__		}_		return connectedHeaders__	};the,simple,broker,produces,code,simp,message,type,that,s,not,stomp,specific,and,needs,to,be,turned,into,a,stomp,connected,frame;private,stomp,header,accessor,convert,connect,ackto,stomp,connected,stomp,header,accessor,connect,ack,headers,string,name,stomp,header,accessor,message,message,message,connect,ack,headers,get,header,name,assert,not,null,message,original,stomp,connect,not,found,in,connect,ack,headers,stomp,header,accessor,connect,headers,message,header,accessor,get,accessor,message,stomp,header,accessor,class,stomp,header,accessor,connected,headers,stomp,header,accessor,create,stomp,command,connected,set,string,accept,versions,connect,headers,get,accept,version,if,accept,versions,contains,1,2,connected,headers,set,version,1,2,else,if,accept,versions,contains,1,1,connected,headers,set,version,1,1,else,if,accept,versions,is,empty,throw,new,illegal,argument,exception,unsupported,stomp,version,accept,versions,long,heartbeat,long,connect,ack,headers,get,header,simp,message,header,accessor,if,heartbeat,null,connected,headers,set,heartbeat,heartbeat,0,heartbeat,1,else,connected,headers,set,heartbeat,0,0,return,connected,headers
StompSubProtocolHandler -> private StompHeaderAccessor convertConnectAcktoStompConnected(StompHeaderAccessor connectAckHeaders);1467730834;The simple broker produces {@code SimpMessageType.CONNECT_ACK} that's not STOMP_specific and needs to be turned into a STOMP CONNECTED frame.;private StompHeaderAccessor convertConnectAcktoStompConnected(StompHeaderAccessor connectAckHeaders) {_		String name = StompHeaderAccessor.CONNECT_MESSAGE_HEADER__		Message<?> message = (Message<?>) connectAckHeaders.getHeader(name)__		Assert.notNull(message, "Original STOMP CONNECT not found in " + connectAckHeaders)__		StompHeaderAccessor connectHeaders = MessageHeaderAccessor.getAccessor(message, StompHeaderAccessor.class)__		StompHeaderAccessor connectedHeaders = StompHeaderAccessor.create(StompCommand.CONNECTED)__		Set<String> acceptVersions = connectHeaders.getAcceptVersion()__		if (acceptVersions.contains("1.2")) {_			connectedHeaders.setVersion("1.2")__		}_		else if (acceptVersions.contains("1.1")) {_			connectedHeaders.setVersion("1.1")__		}_		else if (!acceptVersions.isEmpty()) {_			throw new IllegalArgumentException("Unsupported STOMP version '" + acceptVersions + "'")__		}_		long[] heartbeat = (long[]) connectAckHeaders.getHeader(SimpMessageHeaderAccessor.HEART_BEAT_HEADER)__		if (heartbeat != null) {_			connectedHeaders.setHeartbeat(heartbeat[0], heartbeat[1])__		}_		else {_			connectedHeaders.setHeartbeat(0, 0)__		}_		return connectedHeaders__	};the,simple,broker,produces,code,simp,message,type,that,s,not,stomp,specific,and,needs,to,be,turned,into,a,stomp,connected,frame;private,stomp,header,accessor,convert,connect,ackto,stomp,connected,stomp,header,accessor,connect,ack,headers,string,name,stomp,header,accessor,message,message,message,connect,ack,headers,get,header,name,assert,not,null,message,original,stomp,connect,not,found,in,connect,ack,headers,stomp,header,accessor,connect,headers,message,header,accessor,get,accessor,message,stomp,header,accessor,class,stomp,header,accessor,connected,headers,stomp,header,accessor,create,stomp,command,connected,set,string,accept,versions,connect,headers,get,accept,version,if,accept,versions,contains,1,2,connected,headers,set,version,1,2,else,if,accept,versions,contains,1,1,connected,headers,set,version,1,1,else,if,accept,versions,is,empty,throw,new,illegal,argument,exception,unsupported,stomp,version,accept,versions,long,heartbeat,long,connect,ack,headers,get,header,simp,message,header,accessor,if,heartbeat,null,connected,headers,set,heartbeat,heartbeat,0,heartbeat,1,else,connected,headers,set,heartbeat,0,0,return,connected,headers
StompSubProtocolHandler -> private StompHeaderAccessor convertConnectAcktoStompConnected(StompHeaderAccessor connectAckHeaders);1472062321;The simple broker produces {@code SimpMessageType.CONNECT_ACK} that's not STOMP_specific and needs to be turned into a STOMP CONNECTED frame.;private StompHeaderAccessor convertConnectAcktoStompConnected(StompHeaderAccessor connectAckHeaders) {_		String name = StompHeaderAccessor.CONNECT_MESSAGE_HEADER__		Message<?> message = (Message<?>) connectAckHeaders.getHeader(name)__		if (message == null) {_			throw new IllegalStateException("Original STOMP CONNECT not found in " + connectAckHeaders)__		}__		StompHeaderAccessor connectHeaders = MessageHeaderAccessor.getAccessor(message, StompHeaderAccessor.class)__		StompHeaderAccessor connectedHeaders = StompHeaderAccessor.create(StompCommand.CONNECTED)___		Set<String> acceptVersions = connectHeaders.getAcceptVersion()__		if (acceptVersions.contains("1.2")) {_			connectedHeaders.setVersion("1.2")__		}_		else if (acceptVersions.contains("1.1")) {_			connectedHeaders.setVersion("1.1")__		}_		else if (!acceptVersions.isEmpty()) {_			throw new IllegalArgumentException("Unsupported STOMP version '" + acceptVersions + "'")__		}__		long[] heartbeat = (long[]) connectAckHeaders.getHeader(SimpMessageHeaderAccessor.HEART_BEAT_HEADER)__		if (heartbeat != null) {_			connectedHeaders.setHeartbeat(heartbeat[0], heartbeat[1])__		}_		else {_			connectedHeaders.setHeartbeat(0, 0)__		}__		return connectedHeaders__	};the,simple,broker,produces,code,simp,message,type,that,s,not,stomp,specific,and,needs,to,be,turned,into,a,stomp,connected,frame;private,stomp,header,accessor,convert,connect,ackto,stomp,connected,stomp,header,accessor,connect,ack,headers,string,name,stomp,header,accessor,message,message,message,connect,ack,headers,get,header,name,if,message,null,throw,new,illegal,state,exception,original,stomp,connect,not,found,in,connect,ack,headers,stomp,header,accessor,connect,headers,message,header,accessor,get,accessor,message,stomp,header,accessor,class,stomp,header,accessor,connected,headers,stomp,header,accessor,create,stomp,command,connected,set,string,accept,versions,connect,headers,get,accept,version,if,accept,versions,contains,1,2,connected,headers,set,version,1,2,else,if,accept,versions,contains,1,1,connected,headers,set,version,1,1,else,if,accept,versions,is,empty,throw,new,illegal,argument,exception,unsupported,stomp,version,accept,versions,long,heartbeat,long,connect,ack,headers,get,header,simp,message,header,accessor,if,heartbeat,null,connected,headers,set,heartbeat,heartbeat,0,heartbeat,1,else,connected,headers,set,heartbeat,0,0,return,connected,headers
StompSubProtocolHandler -> private StompHeaderAccessor convertConnectAcktoStompConnected(StompHeaderAccessor connectAckHeaders);1472509879;The simple broker produces {@code SimpMessageType.CONNECT_ACK} that's not STOMP_specific and needs to be turned into a STOMP CONNECTED frame.;private StompHeaderAccessor convertConnectAcktoStompConnected(StompHeaderAccessor connectAckHeaders) {_		String name = StompHeaderAccessor.CONNECT_MESSAGE_HEADER__		Message<?> message = (Message<?>) connectAckHeaders.getHeader(name)__		if (message == null) {_			throw new IllegalStateException("Original STOMP CONNECT not found in " + connectAckHeaders)__		}__		StompHeaderAccessor connectHeaders = MessageHeaderAccessor.getAccessor(message, StompHeaderAccessor.class)__		StompHeaderAccessor connectedHeaders = StompHeaderAccessor.create(StompCommand.CONNECTED)___		Set<String> acceptVersions = connectHeaders.getAcceptVersion()__		if (acceptVersions.contains("1.2")) {_			connectedHeaders.setVersion("1.2")__		}_		else if (acceptVersions.contains("1.1")) {_			connectedHeaders.setVersion("1.1")__		}_		else if (!acceptVersions.isEmpty()) {_			throw new IllegalArgumentException("Unsupported STOMP version '" + acceptVersions + "'")__		}__		long[] heartbeat = (long[]) connectAckHeaders.getHeader(SimpMessageHeaderAccessor.HEART_BEAT_HEADER)__		if (heartbeat != null) {_			connectedHeaders.setHeartbeat(heartbeat[0], heartbeat[1])__		}_		else {_			connectedHeaders.setHeartbeat(0, 0)__		}__		return connectedHeaders__	};the,simple,broker,produces,code,simp,message,type,that,s,not,stomp,specific,and,needs,to,be,turned,into,a,stomp,connected,frame;private,stomp,header,accessor,convert,connect,ackto,stomp,connected,stomp,header,accessor,connect,ack,headers,string,name,stomp,header,accessor,message,message,message,connect,ack,headers,get,header,name,if,message,null,throw,new,illegal,state,exception,original,stomp,connect,not,found,in,connect,ack,headers,stomp,header,accessor,connect,headers,message,header,accessor,get,accessor,message,stomp,header,accessor,class,stomp,header,accessor,connected,headers,stomp,header,accessor,create,stomp,command,connected,set,string,accept,versions,connect,headers,get,accept,version,if,accept,versions,contains,1,2,connected,headers,set,version,1,2,else,if,accept,versions,contains,1,1,connected,headers,set,version,1,1,else,if,accept,versions,is,empty,throw,new,illegal,argument,exception,unsupported,stomp,version,accept,versions,long,heartbeat,long,connect,ack,headers,get,header,simp,message,header,accessor,if,heartbeat,null,connected,headers,set,heartbeat,heartbeat,0,heartbeat,1,else,connected,headers,set,heartbeat,0,0,return,connected,headers
StompSubProtocolHandler -> private StompHeaderAccessor convertConnectAcktoStompConnected(StompHeaderAccessor connectAckHeaders);1476284885;The simple broker produces {@code SimpMessageType.CONNECT_ACK} that's not STOMP_specific and needs to be turned into a STOMP CONNECTED frame.;private StompHeaderAccessor convertConnectAcktoStompConnected(StompHeaderAccessor connectAckHeaders) {_		String name = StompHeaderAccessor.CONNECT_MESSAGE_HEADER__		Message<?> message = (Message<?>) connectAckHeaders.getHeader(name)__		if (message == null) {_			throw new IllegalStateException("Original STOMP CONNECT not found in " + connectAckHeaders)__		}__		StompHeaderAccessor connectHeaders = MessageHeaderAccessor.getAccessor(message, StompHeaderAccessor.class)__		StompHeaderAccessor connectedHeaders = StompHeaderAccessor.create(StompCommand.CONNECTED)___		Set<String> acceptVersions = connectHeaders.getAcceptVersion()__		if (acceptVersions.contains("1.2")) {_			connectedHeaders.setVersion("1.2")__		}_		else if (acceptVersions.contains("1.1")) {_			connectedHeaders.setVersion("1.1")__		}_		else if (!acceptVersions.isEmpty()) {_			throw new IllegalArgumentException("Unsupported STOMP version '" + acceptVersions + "'")__		}__		long[] heartbeat = (long[]) connectAckHeaders.getHeader(SimpMessageHeaderAccessor.HEART_BEAT_HEADER)__		if (heartbeat != null) {_			connectedHeaders.setHeartbeat(heartbeat[0], heartbeat[1])__		}_		else {_			connectedHeaders.setHeartbeat(0, 0)__		}__		return connectedHeaders__	};the,simple,broker,produces,code,simp,message,type,that,s,not,stomp,specific,and,needs,to,be,turned,into,a,stomp,connected,frame;private,stomp,header,accessor,convert,connect,ackto,stomp,connected,stomp,header,accessor,connect,ack,headers,string,name,stomp,header,accessor,message,message,message,connect,ack,headers,get,header,name,if,message,null,throw,new,illegal,state,exception,original,stomp,connect,not,found,in,connect,ack,headers,stomp,header,accessor,connect,headers,message,header,accessor,get,accessor,message,stomp,header,accessor,class,stomp,header,accessor,connected,headers,stomp,header,accessor,create,stomp,command,connected,set,string,accept,versions,connect,headers,get,accept,version,if,accept,versions,contains,1,2,connected,headers,set,version,1,2,else,if,accept,versions,contains,1,1,connected,headers,set,version,1,1,else,if,accept,versions,is,empty,throw,new,illegal,argument,exception,unsupported,stomp,version,accept,versions,long,heartbeat,long,connect,ack,headers,get,header,simp,message,header,accessor,if,heartbeat,null,connected,headers,set,heartbeat,heartbeat,0,heartbeat,1,else,connected,headers,set,heartbeat,0,0,return,connected,headers
StompSubProtocolHandler -> private StompHeaderAccessor convertConnectAcktoStompConnected(StompHeaderAccessor connectAckHeaders);1481213680;The simple broker produces {@code SimpMessageType.CONNECT_ACK} that's not STOMP_specific and needs to be turned into a STOMP CONNECTED frame.;private StompHeaderAccessor convertConnectAcktoStompConnected(StompHeaderAccessor connectAckHeaders) {_		String name = StompHeaderAccessor.CONNECT_MESSAGE_HEADER__		Message<?> message = (Message<?>) connectAckHeaders.getHeader(name)__		if (message == null) {_			throw new IllegalStateException("Original STOMP CONNECT not found in " + connectAckHeaders)__		}__		StompHeaderAccessor connectHeaders = MessageHeaderAccessor.getAccessor(message, StompHeaderAccessor.class)__		StompHeaderAccessor connectedHeaders = StompHeaderAccessor.create(StompCommand.CONNECTED)___		Set<String> acceptVersions = connectHeaders.getAcceptVersion()__		if (acceptVersions.contains("1.2")) {_			connectedHeaders.setVersion("1.2")__		}_		else if (acceptVersions.contains("1.1")) {_			connectedHeaders.setVersion("1.1")__		}_		else if (!acceptVersions.isEmpty()) {_			throw new IllegalArgumentException("Unsupported STOMP version '" + acceptVersions + "'")__		}__		long[] heartbeat = (long[]) connectAckHeaders.getHeader(SimpMessageHeaderAccessor.HEART_BEAT_HEADER)__		if (heartbeat != null) {_			connectedHeaders.setHeartbeat(heartbeat[0], heartbeat[1])__		}_		else {_			connectedHeaders.setHeartbeat(0, 0)__		}__		return connectedHeaders__	};the,simple,broker,produces,code,simp,message,type,that,s,not,stomp,specific,and,needs,to,be,turned,into,a,stomp,connected,frame;private,stomp,header,accessor,convert,connect,ackto,stomp,connected,stomp,header,accessor,connect,ack,headers,string,name,stomp,header,accessor,message,message,message,connect,ack,headers,get,header,name,if,message,null,throw,new,illegal,state,exception,original,stomp,connect,not,found,in,connect,ack,headers,stomp,header,accessor,connect,headers,message,header,accessor,get,accessor,message,stomp,header,accessor,class,stomp,header,accessor,connected,headers,stomp,header,accessor,create,stomp,command,connected,set,string,accept,versions,connect,headers,get,accept,version,if,accept,versions,contains,1,2,connected,headers,set,version,1,2,else,if,accept,versions,contains,1,1,connected,headers,set,version,1,1,else,if,accept,versions,is,empty,throw,new,illegal,argument,exception,unsupported,stomp,version,accept,versions,long,heartbeat,long,connect,ack,headers,get,header,simp,message,header,accessor,if,heartbeat,null,connected,headers,set,heartbeat,heartbeat,0,heartbeat,1,else,connected,headers,set,heartbeat,0,0,return,connected,headers
StompSubProtocolHandler -> private StompHeaderAccessor convertConnectAcktoStompConnected(StompHeaderAccessor connectAckHeaders);1481669991;The simple broker produces {@code SimpMessageType.CONNECT_ACK} that's not STOMP_specific and needs to be turned into a STOMP CONNECTED frame.;private StompHeaderAccessor convertConnectAcktoStompConnected(StompHeaderAccessor connectAckHeaders) {_		String name = StompHeaderAccessor.CONNECT_MESSAGE_HEADER__		Message<?> message = (Message<?>) connectAckHeaders.getHeader(name)__		if (message == null) {_			throw new IllegalStateException("Original STOMP CONNECT not found in " + connectAckHeaders)__		}__		StompHeaderAccessor connectHeaders = MessageHeaderAccessor.getAccessor(message, StompHeaderAccessor.class)__		StompHeaderAccessor connectedHeaders = StompHeaderAccessor.create(StompCommand.CONNECTED)___		Set<String> acceptVersions = connectHeaders.getAcceptVersion()__		if (acceptVersions.contains("1.2")) {_			connectedHeaders.setVersion("1.2")__		}_		else if (acceptVersions.contains("1.1")) {_			connectedHeaders.setVersion("1.1")__		}_		else if (!acceptVersions.isEmpty()) {_			throw new IllegalArgumentException("Unsupported STOMP version '" + acceptVersions + "'")__		}__		long[] heartbeat = (long[]) connectAckHeaders.getHeader(SimpMessageHeaderAccessor.HEART_BEAT_HEADER)__		if (heartbeat != null) {_			connectedHeaders.setHeartbeat(heartbeat[0], heartbeat[1])__		}_		else {_			connectedHeaders.setHeartbeat(0, 0)__		}__		return connectedHeaders__	};the,simple,broker,produces,code,simp,message,type,that,s,not,stomp,specific,and,needs,to,be,turned,into,a,stomp,connected,frame;private,stomp,header,accessor,convert,connect,ackto,stomp,connected,stomp,header,accessor,connect,ack,headers,string,name,stomp,header,accessor,message,message,message,connect,ack,headers,get,header,name,if,message,null,throw,new,illegal,state,exception,original,stomp,connect,not,found,in,connect,ack,headers,stomp,header,accessor,connect,headers,message,header,accessor,get,accessor,message,stomp,header,accessor,class,stomp,header,accessor,connected,headers,stomp,header,accessor,create,stomp,command,connected,set,string,accept,versions,connect,headers,get,accept,version,if,accept,versions,contains,1,2,connected,headers,set,version,1,2,else,if,accept,versions,contains,1,1,connected,headers,set,version,1,1,else,if,accept,versions,is,empty,throw,new,illegal,argument,exception,unsupported,stomp,version,accept,versions,long,heartbeat,long,connect,ack,headers,get,header,simp,message,header,accessor,if,heartbeat,null,connected,headers,set,heartbeat,heartbeat,0,heartbeat,1,else,connected,headers,set,heartbeat,0,0,return,connected,headers
StompSubProtocolHandler -> private StompHeaderAccessor convertConnectAcktoStompConnected(StompHeaderAccessor connectAckHeaders);1482265068;The simple broker produces {@code SimpMessageType.CONNECT_ACK} that's not STOMP_specific and needs to be turned into a STOMP CONNECTED frame.;private StompHeaderAccessor convertConnectAcktoStompConnected(StompHeaderAccessor connectAckHeaders) {_		String name = StompHeaderAccessor.CONNECT_MESSAGE_HEADER__		Message<?> message = (Message<?>) connectAckHeaders.getHeader(name)__		if (message == null) {_			throw new IllegalStateException("Original STOMP CONNECT not found in " + connectAckHeaders)__		}__		StompHeaderAccessor connectHeaders = MessageHeaderAccessor.getAccessor(message, StompHeaderAccessor.class)__		StompHeaderAccessor connectedHeaders = StompHeaderAccessor.create(StompCommand.CONNECTED)___		Set<String> acceptVersions = connectHeaders.getAcceptVersion()__		if (acceptVersions.contains("1.2")) {_			connectedHeaders.setVersion("1.2")__		}_		else if (acceptVersions.contains("1.1")) {_			connectedHeaders.setVersion("1.1")__		}_		else if (!acceptVersions.isEmpty()) {_			throw new IllegalArgumentException("Unsupported STOMP version '" + acceptVersions + "'")__		}__		long[] heartbeat = (long[]) connectAckHeaders.getHeader(SimpMessageHeaderAccessor.HEART_BEAT_HEADER)__		if (heartbeat != null) {_			connectedHeaders.setHeartbeat(heartbeat[0], heartbeat[1])__		}_		else {_			connectedHeaders.setHeartbeat(0, 0)__		}__		return connectedHeaders__	};the,simple,broker,produces,code,simp,message,type,that,s,not,stomp,specific,and,needs,to,be,turned,into,a,stomp,connected,frame;private,stomp,header,accessor,convert,connect,ackto,stomp,connected,stomp,header,accessor,connect,ack,headers,string,name,stomp,header,accessor,message,message,message,connect,ack,headers,get,header,name,if,message,null,throw,new,illegal,state,exception,original,stomp,connect,not,found,in,connect,ack,headers,stomp,header,accessor,connect,headers,message,header,accessor,get,accessor,message,stomp,header,accessor,class,stomp,header,accessor,connected,headers,stomp,header,accessor,create,stomp,command,connected,set,string,accept,versions,connect,headers,get,accept,version,if,accept,versions,contains,1,2,connected,headers,set,version,1,2,else,if,accept,versions,contains,1,1,connected,headers,set,version,1,1,else,if,accept,versions,is,empty,throw,new,illegal,argument,exception,unsupported,stomp,version,accept,versions,long,heartbeat,long,connect,ack,headers,get,header,simp,message,header,accessor,if,heartbeat,null,connected,headers,set,heartbeat,heartbeat,0,heartbeat,1,else,connected,headers,set,heartbeat,0,0,return,connected,headers
StompSubProtocolHandler -> private StompHeaderAccessor convertConnectAcktoStompConnected(StompHeaderAccessor connectAckHeaders);1495868221;The simple broker produces {@code SimpMessageType.CONNECT_ACK} that's not STOMP_specific and needs to be turned into a STOMP CONNECTED frame.;private StompHeaderAccessor convertConnectAcktoStompConnected(StompHeaderAccessor connectAckHeaders) {_		String name = StompHeaderAccessor.CONNECT_MESSAGE_HEADER__		Message<?> message = (Message<?>) connectAckHeaders.getHeader(name)__		if (message == null) {_			throw new IllegalStateException("Original STOMP CONNECT not found in " + connectAckHeaders)__		}__		StompHeaderAccessor connectHeaders = MessageHeaderAccessor.getAccessor(message, StompHeaderAccessor.class)__		StompHeaderAccessor connectedHeaders = StompHeaderAccessor.create(StompCommand.CONNECTED)___		Set<String> acceptVersions = connectHeaders.getAcceptVersion()__		if (acceptVersions.contains("1.2")) {_			connectedHeaders.setVersion("1.2")__		}_		else if (acceptVersions.contains("1.1")) {_			connectedHeaders.setVersion("1.1")__		}_		else if (!acceptVersions.isEmpty()) {_			throw new IllegalArgumentException("Unsupported STOMP version '" + acceptVersions + "'")__		}__		long[] heartbeat = (long[]) connectAckHeaders.getHeader(SimpMessageHeaderAccessor.HEART_BEAT_HEADER)__		if (heartbeat != null) {_			connectedHeaders.setHeartbeat(heartbeat[0], heartbeat[1])__		}_		else {_			connectedHeaders.setHeartbeat(0, 0)__		}__		return connectedHeaders__	};the,simple,broker,produces,code,simp,message,type,that,s,not,stomp,specific,and,needs,to,be,turned,into,a,stomp,connected,frame;private,stomp,header,accessor,convert,connect,ackto,stomp,connected,stomp,header,accessor,connect,ack,headers,string,name,stomp,header,accessor,message,message,message,connect,ack,headers,get,header,name,if,message,null,throw,new,illegal,state,exception,original,stomp,connect,not,found,in,connect,ack,headers,stomp,header,accessor,connect,headers,message,header,accessor,get,accessor,message,stomp,header,accessor,class,stomp,header,accessor,connected,headers,stomp,header,accessor,create,stomp,command,connected,set,string,accept,versions,connect,headers,get,accept,version,if,accept,versions,contains,1,2,connected,headers,set,version,1,2,else,if,accept,versions,contains,1,1,connected,headers,set,version,1,1,else,if,accept,versions,is,empty,throw,new,illegal,argument,exception,unsupported,stomp,version,accept,versions,long,heartbeat,long,connect,ack,headers,get,header,simp,message,header,accessor,if,heartbeat,null,connected,headers,set,heartbeat,heartbeat,0,heartbeat,1,else,connected,headers,set,heartbeat,0,0,return,connected,headers
StompSubProtocolHandler -> private StompHeaderAccessor convertConnectAcktoStompConnected(StompHeaderAccessor connectAckHeaders);1496837955;The simple broker produces {@code SimpMessageType.CONNECT_ACK} that's not STOMP_specific and needs to be turned into a STOMP CONNECTED frame.;private StompHeaderAccessor convertConnectAcktoStompConnected(StompHeaderAccessor connectAckHeaders) {_		String name = StompHeaderAccessor.CONNECT_MESSAGE_HEADER__		Message<?> message = (Message<?>) connectAckHeaders.getHeader(name)__		if (message == null) {_			throw new IllegalStateException("Original STOMP CONNECT not found in " + connectAckHeaders)__		}__		StompHeaderAccessor connectHeaders = MessageHeaderAccessor.getAccessor(message, StompHeaderAccessor.class)__		StompHeaderAccessor connectedHeaders = StompHeaderAccessor.create(StompCommand.CONNECTED)___		if (connectHeaders != null) {_			Set<String> acceptVersions = connectHeaders.getAcceptVersion()__			if (acceptVersions.contains("1.2")) {_				connectedHeaders.setVersion("1.2")__			}_			else if (acceptVersions.contains("1.1")) {_				connectedHeaders.setVersion("1.1")__			}_			else if (!acceptVersions.isEmpty()) {_				throw new IllegalArgumentException("Unsupported STOMP version '" + acceptVersions + "'")__			}_		}__		long[] heartbeat = (long[]) connectAckHeaders.getHeader(SimpMessageHeaderAccessor.HEART_BEAT_HEADER)__		if (heartbeat != null) {_			connectedHeaders.setHeartbeat(heartbeat[0], heartbeat[1])__		}_		else {_			connectedHeaders.setHeartbeat(0, 0)__		}__		return connectedHeaders__	};the,simple,broker,produces,code,simp,message,type,that,s,not,stomp,specific,and,needs,to,be,turned,into,a,stomp,connected,frame;private,stomp,header,accessor,convert,connect,ackto,stomp,connected,stomp,header,accessor,connect,ack,headers,string,name,stomp,header,accessor,message,message,message,connect,ack,headers,get,header,name,if,message,null,throw,new,illegal,state,exception,original,stomp,connect,not,found,in,connect,ack,headers,stomp,header,accessor,connect,headers,message,header,accessor,get,accessor,message,stomp,header,accessor,class,stomp,header,accessor,connected,headers,stomp,header,accessor,create,stomp,command,connected,if,connect,headers,null,set,string,accept,versions,connect,headers,get,accept,version,if,accept,versions,contains,1,2,connected,headers,set,version,1,2,else,if,accept,versions,contains,1,1,connected,headers,set,version,1,1,else,if,accept,versions,is,empty,throw,new,illegal,argument,exception,unsupported,stomp,version,accept,versions,long,heartbeat,long,connect,ack,headers,get,header,simp,message,header,accessor,if,heartbeat,null,connected,headers,set,heartbeat,heartbeat,0,heartbeat,1,else,connected,headers,set,heartbeat,0,0,return,connected,headers
StompSubProtocolHandler -> private StompHeaderAccessor convertConnectAcktoStompConnected(StompHeaderAccessor connectAckHeaders);1497251962;The simple broker produces {@code SimpMessageType.CONNECT_ACK} that's not STOMP_specific and needs to be turned into a STOMP CONNECTED frame.;private StompHeaderAccessor convertConnectAcktoStompConnected(StompHeaderAccessor connectAckHeaders) {_		String name = StompHeaderAccessor.CONNECT_MESSAGE_HEADER__		Message<?> message = (Message<?>) connectAckHeaders.getHeader(name)__		if (message == null) {_			throw new IllegalStateException("Original STOMP CONNECT not found in " + connectAckHeaders)__		}__		StompHeaderAccessor connectHeaders = MessageHeaderAccessor.getAccessor(message, StompHeaderAccessor.class)__		StompHeaderAccessor connectedHeaders = StompHeaderAccessor.create(StompCommand.CONNECTED)___		if (connectHeaders != null) {_			Set<String> acceptVersions = connectHeaders.getAcceptVersion()__			if (acceptVersions.contains("1.2")) {_				connectedHeaders.setVersion("1.2")__			}_			else if (acceptVersions.contains("1.1")) {_				connectedHeaders.setVersion("1.1")__			}_			else if (!acceptVersions.isEmpty()) {_				throw new IllegalArgumentException("Unsupported STOMP version '" + acceptVersions + "'")__			}_		}__		long[] heartbeat = (long[]) connectAckHeaders.getHeader(SimpMessageHeaderAccessor.HEART_BEAT_HEADER)__		if (heartbeat != null) {_			connectedHeaders.setHeartbeat(heartbeat[0], heartbeat[1])__		}_		else {_			connectedHeaders.setHeartbeat(0, 0)__		}__		return connectedHeaders__	};the,simple,broker,produces,code,simp,message,type,that,s,not,stomp,specific,and,needs,to,be,turned,into,a,stomp,connected,frame;private,stomp,header,accessor,convert,connect,ackto,stomp,connected,stomp,header,accessor,connect,ack,headers,string,name,stomp,header,accessor,message,message,message,connect,ack,headers,get,header,name,if,message,null,throw,new,illegal,state,exception,original,stomp,connect,not,found,in,connect,ack,headers,stomp,header,accessor,connect,headers,message,header,accessor,get,accessor,message,stomp,header,accessor,class,stomp,header,accessor,connected,headers,stomp,header,accessor,create,stomp,command,connected,if,connect,headers,null,set,string,accept,versions,connect,headers,get,accept,version,if,accept,versions,contains,1,2,connected,headers,set,version,1,2,else,if,accept,versions,contains,1,1,connected,headers,set,version,1,1,else,if,accept,versions,is,empty,throw,new,illegal,argument,exception,unsupported,stomp,version,accept,versions,long,heartbeat,long,connect,ack,headers,get,header,simp,message,header,accessor,if,heartbeat,null,connected,headers,set,heartbeat,heartbeat,0,heartbeat,1,else,connected,headers,set,heartbeat,0,0,return,connected,headers
StompSubProtocolHandler -> private StompHeaderAccessor convertConnectAcktoStompConnected(StompHeaderAccessor connectAckHeaders);1498780456;The simple broker produces {@code SimpMessageType.CONNECT_ACK} that's not STOMP_specific and needs to be turned into a STOMP CONNECTED frame.;private StompHeaderAccessor convertConnectAcktoStompConnected(StompHeaderAccessor connectAckHeaders) {_		String name = StompHeaderAccessor.CONNECT_MESSAGE_HEADER__		Message<?> message = (Message<?>) connectAckHeaders.getHeader(name)__		if (message == null) {_			throw new IllegalStateException("Original STOMP CONNECT not found in " + connectAckHeaders)__		}__		StompHeaderAccessor connectHeaders = MessageHeaderAccessor.getAccessor(message, StompHeaderAccessor.class)__		StompHeaderAccessor connectedHeaders = StompHeaderAccessor.create(StompCommand.CONNECTED)___		if (connectHeaders != null) {_			Set<String> acceptVersions = connectHeaders.getAcceptVersion()__			if (acceptVersions.contains("1.2")) {_				connectedHeaders.setVersion("1.2")__			}_			else if (acceptVersions.contains("1.1")) {_				connectedHeaders.setVersion("1.1")__			}_			else if (!acceptVersions.isEmpty()) {_				throw new IllegalArgumentException("Unsupported STOMP version '" + acceptVersions + "'")__			}_		}__		long[] heartbeat = (long[]) connectAckHeaders.getHeader(SimpMessageHeaderAccessor.HEART_BEAT_HEADER)__		if (heartbeat != null) {_			connectedHeaders.setHeartbeat(heartbeat[0], heartbeat[1])__		}_		else {_			connectedHeaders.setHeartbeat(0, 0)__		}__		return connectedHeaders__	};the,simple,broker,produces,code,simp,message,type,that,s,not,stomp,specific,and,needs,to,be,turned,into,a,stomp,connected,frame;private,stomp,header,accessor,convert,connect,ackto,stomp,connected,stomp,header,accessor,connect,ack,headers,string,name,stomp,header,accessor,message,message,message,connect,ack,headers,get,header,name,if,message,null,throw,new,illegal,state,exception,original,stomp,connect,not,found,in,connect,ack,headers,stomp,header,accessor,connect,headers,message,header,accessor,get,accessor,message,stomp,header,accessor,class,stomp,header,accessor,connected,headers,stomp,header,accessor,create,stomp,command,connected,if,connect,headers,null,set,string,accept,versions,connect,headers,get,accept,version,if,accept,versions,contains,1,2,connected,headers,set,version,1,2,else,if,accept,versions,contains,1,1,connected,headers,set,version,1,1,else,if,accept,versions,is,empty,throw,new,illegal,argument,exception,unsupported,stomp,version,accept,versions,long,heartbeat,long,connect,ack,headers,get,header,simp,message,header,accessor,if,heartbeat,null,connected,headers,set,heartbeat,heartbeat,0,heartbeat,1,else,connected,headers,set,heartbeat,0,0,return,connected,headers
StompSubProtocolHandler -> private StompHeaderAccessor convertConnectAcktoStompConnected(StompHeaderAccessor connectAckHeaders);1500448076;The simple broker produces {@code SimpMessageType.CONNECT_ACK} that's not STOMP_specific and needs to be turned into a STOMP CONNECTED frame.;private StompHeaderAccessor convertConnectAcktoStompConnected(StompHeaderAccessor connectAckHeaders) {_		String name = StompHeaderAccessor.CONNECT_MESSAGE_HEADER__		Message<?> message = (Message<?>) connectAckHeaders.getHeader(name)__		if (message == null) {_			throw new IllegalStateException("Original STOMP CONNECT not found in " + connectAckHeaders)__		}__		StompHeaderAccessor connectHeaders = MessageHeaderAccessor.getAccessor(message, StompHeaderAccessor.class)__		StompHeaderAccessor connectedHeaders = StompHeaderAccessor.create(StompCommand.CONNECTED)___		if (connectHeaders != null) {_			Set<String> acceptVersions = connectHeaders.getAcceptVersion()__			if (acceptVersions.contains("1.2")) {_				connectedHeaders.setVersion("1.2")__			}_			else if (acceptVersions.contains("1.1")) {_				connectedHeaders.setVersion("1.1")__			}_			else if (!acceptVersions.isEmpty()) {_				throw new IllegalArgumentException("Unsupported STOMP version '" + acceptVersions + "'")__			}_		}__		long[] heartbeat = (long[]) connectAckHeaders.getHeader(SimpMessageHeaderAccessor.HEART_BEAT_HEADER)__		if (heartbeat != null) {_			connectedHeaders.setHeartbeat(heartbeat[0], heartbeat[1])__		}_		else {_			connectedHeaders.setHeartbeat(0, 0)__		}__		return connectedHeaders__	};the,simple,broker,produces,code,simp,message,type,that,s,not,stomp,specific,and,needs,to,be,turned,into,a,stomp,connected,frame;private,stomp,header,accessor,convert,connect,ackto,stomp,connected,stomp,header,accessor,connect,ack,headers,string,name,stomp,header,accessor,message,message,message,connect,ack,headers,get,header,name,if,message,null,throw,new,illegal,state,exception,original,stomp,connect,not,found,in,connect,ack,headers,stomp,header,accessor,connect,headers,message,header,accessor,get,accessor,message,stomp,header,accessor,class,stomp,header,accessor,connected,headers,stomp,header,accessor,create,stomp,command,connected,if,connect,headers,null,set,string,accept,versions,connect,headers,get,accept,version,if,accept,versions,contains,1,2,connected,headers,set,version,1,2,else,if,accept,versions,contains,1,1,connected,headers,set,version,1,1,else,if,accept,versions,is,empty,throw,new,illegal,argument,exception,unsupported,stomp,version,accept,versions,long,heartbeat,long,connect,ack,headers,get,header,simp,message,header,accessor,if,heartbeat,null,connected,headers,set,heartbeat,heartbeat,0,heartbeat,1,else,connected,headers,set,heartbeat,0,0,return,connected,headers
StompSubProtocolHandler -> private StompHeaderAccessor convertConnectAcktoStompConnected(StompHeaderAccessor connectAckHeaders);1501147952;The simple broker produces {@code SimpMessageType.CONNECT_ACK} that's not STOMP_specific and needs to be turned into a STOMP CONNECTED frame.;private StompHeaderAccessor convertConnectAcktoStompConnected(StompHeaderAccessor connectAckHeaders) {_		String name = StompHeaderAccessor.CONNECT_MESSAGE_HEADER__		Message<?> message = (Message<?>) connectAckHeaders.getHeader(name)__		if (message == null) {_			throw new IllegalStateException("Original STOMP CONNECT not found in " + connectAckHeaders)__		}__		StompHeaderAccessor connectHeaders = MessageHeaderAccessor.getAccessor(message, StompHeaderAccessor.class)__		StompHeaderAccessor connectedHeaders = StompHeaderAccessor.create(StompCommand.CONNECTED)___		if (connectHeaders != null) {_			Set<String> acceptVersions = connectHeaders.getAcceptVersion()__			if (acceptVersions.contains("1.2")) {_				connectedHeaders.setVersion("1.2")__			}_			else if (acceptVersions.contains("1.1")) {_				connectedHeaders.setVersion("1.1")__			}_			else if (!acceptVersions.isEmpty()) {_				throw new IllegalArgumentException("Unsupported STOMP version '" + acceptVersions + "'")__			}_		}__		long[] heartbeat = (long[]) connectAckHeaders.getHeader(SimpMessageHeaderAccessor.HEART_BEAT_HEADER)__		if (heartbeat != null) {_			connectedHeaders.setHeartbeat(heartbeat[0], heartbeat[1])__		}_		else {_			connectedHeaders.setHeartbeat(0, 0)__		}__		return connectedHeaders__	};the,simple,broker,produces,code,simp,message,type,that,s,not,stomp,specific,and,needs,to,be,turned,into,a,stomp,connected,frame;private,stomp,header,accessor,convert,connect,ackto,stomp,connected,stomp,header,accessor,connect,ack,headers,string,name,stomp,header,accessor,message,message,message,connect,ack,headers,get,header,name,if,message,null,throw,new,illegal,state,exception,original,stomp,connect,not,found,in,connect,ack,headers,stomp,header,accessor,connect,headers,message,header,accessor,get,accessor,message,stomp,header,accessor,class,stomp,header,accessor,connected,headers,stomp,header,accessor,create,stomp,command,connected,if,connect,headers,null,set,string,accept,versions,connect,headers,get,accept,version,if,accept,versions,contains,1,2,connected,headers,set,version,1,2,else,if,accept,versions,contains,1,1,connected,headers,set,version,1,1,else,if,accept,versions,is,empty,throw,new,illegal,argument,exception,unsupported,stomp,version,accept,versions,long,heartbeat,long,connect,ack,headers,get,header,simp,message,header,accessor,if,heartbeat,null,connected,headers,set,heartbeat,heartbeat,0,heartbeat,1,else,connected,headers,set,heartbeat,0,0,return,connected,headers
StompSubProtocolHandler -> private StompHeaderAccessor convertConnectAcktoStompConnected(StompHeaderAccessor connectAckHeaders);1502974979;The simple broker produces {@code SimpMessageType.CONNECT_ACK} that's not STOMP_specific and needs to be turned into a STOMP CONNECTED frame.;private StompHeaderAccessor convertConnectAcktoStompConnected(StompHeaderAccessor connectAckHeaders) {_		String name = StompHeaderAccessor.CONNECT_MESSAGE_HEADER__		Message<?> message = (Message<?>) connectAckHeaders.getHeader(name)__		if (message == null) {_			throw new IllegalStateException("Original STOMP CONNECT not found in " + connectAckHeaders)__		}__		StompHeaderAccessor connectHeaders = MessageHeaderAccessor.getAccessor(message, StompHeaderAccessor.class)__		StompHeaderAccessor connectedHeaders = StompHeaderAccessor.create(StompCommand.CONNECTED)___		if (connectHeaders != null) {_			Set<String> acceptVersions = connectHeaders.getAcceptVersion()__			if (acceptVersions.contains("1.2")) {_				connectedHeaders.setVersion("1.2")__			}_			else if (acceptVersions.contains("1.1")) {_				connectedHeaders.setVersion("1.1")__			}_			else if (!acceptVersions.isEmpty()) {_				throw new IllegalArgumentException("Unsupported STOMP version '" + acceptVersions + "'")__			}_		}__		long[] heartbeat = (long[]) connectAckHeaders.getHeader(SimpMessageHeaderAccessor.HEART_BEAT_HEADER)__		if (heartbeat != null) {_			connectedHeaders.setHeartbeat(heartbeat[0], heartbeat[1])__		}_		else {_			connectedHeaders.setHeartbeat(0, 0)__		}__		return connectedHeaders__	};the,simple,broker,produces,code,simp,message,type,that,s,not,stomp,specific,and,needs,to,be,turned,into,a,stomp,connected,frame;private,stomp,header,accessor,convert,connect,ackto,stomp,connected,stomp,header,accessor,connect,ack,headers,string,name,stomp,header,accessor,message,message,message,connect,ack,headers,get,header,name,if,message,null,throw,new,illegal,state,exception,original,stomp,connect,not,found,in,connect,ack,headers,stomp,header,accessor,connect,headers,message,header,accessor,get,accessor,message,stomp,header,accessor,class,stomp,header,accessor,connected,headers,stomp,header,accessor,create,stomp,command,connected,if,connect,headers,null,set,string,accept,versions,connect,headers,get,accept,version,if,accept,versions,contains,1,2,connected,headers,set,version,1,2,else,if,accept,versions,contains,1,1,connected,headers,set,version,1,1,else,if,accept,versions,is,empty,throw,new,illegal,argument,exception,unsupported,stomp,version,accept,versions,long,heartbeat,long,connect,ack,headers,get,header,simp,message,header,accessor,if,heartbeat,null,connected,headers,set,heartbeat,heartbeat,0,heartbeat,1,else,connected,headers,set,heartbeat,0,0,return,connected,headers
StompSubProtocolHandler -> private StompHeaderAccessor convertConnectAcktoStompConnected(StompHeaderAccessor connectAckHeaders);1509997270;The simple broker produces {@code SimpMessageType.CONNECT_ACK} that's not STOMP_specific and needs to be turned into a STOMP CONNECTED frame.;private StompHeaderAccessor convertConnectAcktoStompConnected(StompHeaderAccessor connectAckHeaders) {_		String name = StompHeaderAccessor.CONNECT_MESSAGE_HEADER__		Message<?> message = (Message<?>) connectAckHeaders.getHeader(name)__		if (message == null) {_			throw new IllegalStateException("Original STOMP CONNECT not found in " + connectAckHeaders)__		}__		StompHeaderAccessor connectHeaders = MessageHeaderAccessor.getAccessor(message, StompHeaderAccessor.class)__		StompHeaderAccessor connectedHeaders = StompHeaderAccessor.create(StompCommand.CONNECTED)___		if (connectHeaders != null) {_			Set<String> acceptVersions = connectHeaders.getAcceptVersion()__			if (acceptVersions.contains("1.2")) {_				connectedHeaders.setVersion("1.2")__			}_			else if (acceptVersions.contains("1.1")) {_				connectedHeaders.setVersion("1.1")__			}_			else if (!acceptVersions.isEmpty()) {_				throw new IllegalArgumentException("Unsupported STOMP version '" + acceptVersions + "'")__			}_		}__		long[] heartbeat = (long[]) connectAckHeaders.getHeader(SimpMessageHeaderAccessor.HEART_BEAT_HEADER)__		if (heartbeat != null) {_			connectedHeaders.setHeartbeat(heartbeat[0], heartbeat[1])__		}_		else {_			connectedHeaders.setHeartbeat(0, 0)__		}__		return connectedHeaders__	};the,simple,broker,produces,code,simp,message,type,that,s,not,stomp,specific,and,needs,to,be,turned,into,a,stomp,connected,frame;private,stomp,header,accessor,convert,connect,ackto,stomp,connected,stomp,header,accessor,connect,ack,headers,string,name,stomp,header,accessor,message,message,message,connect,ack,headers,get,header,name,if,message,null,throw,new,illegal,state,exception,original,stomp,connect,not,found,in,connect,ack,headers,stomp,header,accessor,connect,headers,message,header,accessor,get,accessor,message,stomp,header,accessor,class,stomp,header,accessor,connected,headers,stomp,header,accessor,create,stomp,command,connected,if,connect,headers,null,set,string,accept,versions,connect,headers,get,accept,version,if,accept,versions,contains,1,2,connected,headers,set,version,1,2,else,if,accept,versions,contains,1,1,connected,headers,set,version,1,1,else,if,accept,versions,is,empty,throw,new,illegal,argument,exception,unsupported,stomp,version,accept,versions,long,heartbeat,long,connect,ack,headers,get,header,simp,message,header,accessor,if,heartbeat,null,connected,headers,set,heartbeat,heartbeat,0,heartbeat,1,else,connected,headers,set,heartbeat,0,0,return,connected,headers
StompSubProtocolHandler -> private StompHeaderAccessor convertConnectAcktoStompConnected(StompHeaderAccessor connectAckHeaders);1530174524;The simple broker produces {@code SimpMessageType.CONNECT_ACK} that's not STOMP_specific and needs to be turned into a STOMP CONNECTED frame.;private StompHeaderAccessor convertConnectAcktoStompConnected(StompHeaderAccessor connectAckHeaders) {_		String name = StompHeaderAccessor.CONNECT_MESSAGE_HEADER__		Message<?> message = (Message<?>) connectAckHeaders.getHeader(name)__		if (message == null) {_			throw new IllegalStateException("Original STOMP CONNECT not found in " + connectAckHeaders)__		}__		StompHeaderAccessor connectHeaders = MessageHeaderAccessor.getAccessor(message, StompHeaderAccessor.class)__		StompHeaderAccessor connectedHeaders = StompHeaderAccessor.create(StompCommand.CONNECTED)___		if (connectHeaders != null) {_			Set<String> acceptVersions = connectHeaders.getAcceptVersion()__			if (acceptVersions.contains("1.2")) {_				connectedHeaders.setVersion("1.2")__			}_			else if (acceptVersions.contains("1.1")) {_				connectedHeaders.setVersion("1.1")__			}_			else if (!acceptVersions.isEmpty()) {_				throw new IllegalArgumentException("Unsupported STOMP version '" + acceptVersions + "'")__			}_		}__		long[] heartbeat = (long[]) connectAckHeaders.getHeader(SimpMessageHeaderAccessor.HEART_BEAT_HEADER)__		if (heartbeat != null) {_			connectedHeaders.setHeartbeat(heartbeat[0], heartbeat[1])__		}_		else {_			connectedHeaders.setHeartbeat(0, 0)__		}__		return connectedHeaders__	};the,simple,broker,produces,code,simp,message,type,that,s,not,stomp,specific,and,needs,to,be,turned,into,a,stomp,connected,frame;private,stomp,header,accessor,convert,connect,ackto,stomp,connected,stomp,header,accessor,connect,ack,headers,string,name,stomp,header,accessor,message,message,message,connect,ack,headers,get,header,name,if,message,null,throw,new,illegal,state,exception,original,stomp,connect,not,found,in,connect,ack,headers,stomp,header,accessor,connect,headers,message,header,accessor,get,accessor,message,stomp,header,accessor,class,stomp,header,accessor,connected,headers,stomp,header,accessor,create,stomp,command,connected,if,connect,headers,null,set,string,accept,versions,connect,headers,get,accept,version,if,accept,versions,contains,1,2,connected,headers,set,version,1,2,else,if,accept,versions,contains,1,1,connected,headers,set,version,1,1,else,if,accept,versions,is,empty,throw,new,illegal,argument,exception,unsupported,stomp,version,accept,versions,long,heartbeat,long,connect,ack,headers,get,header,simp,message,header,accessor,if,heartbeat,null,connected,headers,set,heartbeat,heartbeat,0,heartbeat,1,else,connected,headers,set,heartbeat,0,0,return,connected,headers
StompSubProtocolHandler -> private StompHeaderAccessor convertConnectAcktoStompConnected(StompHeaderAccessor connectAckHeaders);1536886762;The simple broker produces {@code SimpMessageType.CONNECT_ACK} that's not STOMP_specific and needs to be turned into a STOMP CONNECTED frame.;private StompHeaderAccessor convertConnectAcktoStompConnected(StompHeaderAccessor connectAckHeaders) {_		String name = StompHeaderAccessor.CONNECT_MESSAGE_HEADER__		Message<?> message = (Message<?>) connectAckHeaders.getHeader(name)__		if (message == null) {_			throw new IllegalStateException("Original STOMP CONNECT not found in " + connectAckHeaders)__		}__		StompHeaderAccessor connectHeaders = MessageHeaderAccessor.getAccessor(message, StompHeaderAccessor.class)__		StompHeaderAccessor connectedHeaders = StompHeaderAccessor.create(StompCommand.CONNECTED)___		if (connectHeaders != null) {_			Set<String> acceptVersions = connectHeaders.getAcceptVersion()__			connectedHeaders.setVersion(_					Arrays.stream(SUPPORTED_VERSIONS)_							.filter(acceptVersions::contains)_							.findAny()_							.orElseThrow(() -> new IllegalArgumentException(_									"Unsupported STOMP version '" + acceptVersions + "'")))__		}__		long[] heartbeat = (long[]) connectAckHeaders.getHeader(SimpMessageHeaderAccessor.HEART_BEAT_HEADER)__		if (heartbeat != null) {_			connectedHeaders.setHeartbeat(heartbeat[0], heartbeat[1])__		}_		else {_			connectedHeaders.setHeartbeat(0, 0)__		}__		return connectedHeaders__	};the,simple,broker,produces,code,simp,message,type,that,s,not,stomp,specific,and,needs,to,be,turned,into,a,stomp,connected,frame;private,stomp,header,accessor,convert,connect,ackto,stomp,connected,stomp,header,accessor,connect,ack,headers,string,name,stomp,header,accessor,message,message,message,connect,ack,headers,get,header,name,if,message,null,throw,new,illegal,state,exception,original,stomp,connect,not,found,in,connect,ack,headers,stomp,header,accessor,connect,headers,message,header,accessor,get,accessor,message,stomp,header,accessor,class,stomp,header,accessor,connected,headers,stomp,header,accessor,create,stomp,command,connected,if,connect,headers,null,set,string,accept,versions,connect,headers,get,accept,version,connected,headers,set,version,arrays,stream,filter,accept,versions,contains,find,any,or,else,throw,new,illegal,argument,exception,unsupported,stomp,version,accept,versions,long,heartbeat,long,connect,ack,headers,get,header,simp,message,header,accessor,if,heartbeat,null,connected,headers,set,heartbeat,heartbeat,0,heartbeat,1,else,connected,headers,set,heartbeat,0,0,return,connected,headers
StompSubProtocolHandler -> private StompHeaderAccessor convertConnectAcktoStompConnected(StompHeaderAccessor connectAckHeaders);1542899558;The simple broker produces {@code SimpMessageType.CONNECT_ACK} that's not STOMP_specific and needs to be turned into a STOMP CONNECTED frame.;private StompHeaderAccessor convertConnectAcktoStompConnected(StompHeaderAccessor connectAckHeaders) {_		String name = StompHeaderAccessor.CONNECT_MESSAGE_HEADER__		Message<?> message = (Message<?>) connectAckHeaders.getHeader(name)__		if (message == null) {_			throw new IllegalStateException("Original STOMP CONNECT not found in " + connectAckHeaders)__		}__		StompHeaderAccessor connectHeaders = MessageHeaderAccessor.getAccessor(message, StompHeaderAccessor.class)__		StompHeaderAccessor connectedHeaders = StompHeaderAccessor.create(StompCommand.CONNECTED)___		if (connectHeaders != null) {_			Set<String> acceptVersions = connectHeaders.getAcceptVersion()__			connectedHeaders.setVersion(_					Arrays.stream(SUPPORTED_VERSIONS)_							.filter(acceptVersions::contains)_							.findAny()_							.orElseThrow(() -> new IllegalArgumentException(_									"Unsupported STOMP version '" + acceptVersions + "'")))__		}__		long[] heartbeat = (long[]) connectAckHeaders.getHeader(SimpMessageHeaderAccessor.HEART_BEAT_HEADER)__		if (heartbeat != null) {_			connectedHeaders.setHeartbeat(heartbeat[0], heartbeat[1])__		}_		else {_			connectedHeaders.setHeartbeat(0, 0)__		}__		return connectedHeaders__	};the,simple,broker,produces,code,simp,message,type,that,s,not,stomp,specific,and,needs,to,be,turned,into,a,stomp,connected,frame;private,stomp,header,accessor,convert,connect,ackto,stomp,connected,stomp,header,accessor,connect,ack,headers,string,name,stomp,header,accessor,message,message,message,connect,ack,headers,get,header,name,if,message,null,throw,new,illegal,state,exception,original,stomp,connect,not,found,in,connect,ack,headers,stomp,header,accessor,connect,headers,message,header,accessor,get,accessor,message,stomp,header,accessor,class,stomp,header,accessor,connected,headers,stomp,header,accessor,create,stomp,command,connected,if,connect,headers,null,set,string,accept,versions,connect,headers,get,accept,version,connected,headers,set,version,arrays,stream,filter,accept,versions,contains,find,any,or,else,throw,new,illegal,argument,exception,unsupported,stomp,version,accept,versions,long,heartbeat,long,connect,ack,headers,get,header,simp,message,header,accessor,if,heartbeat,null,connected,headers,set,heartbeat,heartbeat,0,heartbeat,1,else,connected,headers,set,heartbeat,0,0,return,connected,headers
StompSubProtocolHandler -> public String getStatsInfo();1404880787;Return a String describing internal state and counters.;public String getStatsInfo() {_		return this.stats.toString()__	};return,a,string,describing,internal,state,and,counters;public,string,get,stats,info,return,this,stats,to,string
StompSubProtocolHandler -> public String getStatsInfo();1404880799;Return a String describing internal state and counters.;public String getStatsInfo() {_		return this.stats.toString()__	};return,a,string,describing,internal,state,and,counters;public,string,get,stats,info,return,this,stats,to,string
StompSubProtocolHandler -> public String getStatsInfo();1411067168;Return a String describing internal state and counters.;public String getStatsInfo() {_		return this.stats.toString()__	};return,a,string,describing,internal,state,and,counters;public,string,get,stats,info,return,this,stats,to,string
StompSubProtocolHandler -> public String getStatsInfo();1411068071;Return a String describing internal state and counters.;public String getStatsInfo() {_		return this.stats.toString()__	};return,a,string,describing,internal,state,and,counters;public,string,get,stats,info,return,this,stats,to,string
StompSubProtocolHandler -> public String getStatsInfo();1411148800;Return a String describing internal state and counters.;public String getStatsInfo() {_		return this.stats.toString()__	};return,a,string,describing,internal,state,and,counters;public,string,get,stats,info,return,this,stats,to,string
StompSubProtocolHandler -> public String getStatsInfo();1411567635;Return a String describing internal state and counters.;public String getStatsInfo() {_		return this.stats.toString()__	};return,a,string,describing,internal,state,and,counters;public,string,get,stats,info,return,this,stats,to,string
StompSubProtocolHandler -> public String getStatsInfo();1412965899;Return a String describing internal state and counters.;public String getStatsInfo() {_		return this.stats.toString()__	};return,a,string,describing,internal,state,and,counters;public,string,get,stats,info,return,this,stats,to,string
StompSubProtocolHandler -> public String getStatsInfo();1413848647;Return a String describing internal state and counters.;public String getStatsInfo() {_		return this.stats.toString()__	};return,a,string,describing,internal,state,and,counters;public,string,get,stats,info,return,this,stats,to,string
StompSubProtocolHandler -> public String getStatsInfo();1414092351;Return a String describing internal state and counters.;public String getStatsInfo() {_		return this.stats.toString()__	};return,a,string,describing,internal,state,and,counters;public,string,get,stats,info,return,this,stats,to,string
StompSubProtocolHandler -> public String getStatsInfo();1414158498;Return a String describing internal state and counters.;public String getStatsInfo() {_		return this.stats.toString()__	};return,a,string,describing,internal,state,and,counters;public,string,get,stats,info,return,this,stats,to,string
StompSubProtocolHandler -> public String getStatsInfo();1419362683;Return a String describing internal state and counters.;public String getStatsInfo() {_		return this.stats.toString()__	};return,a,string,describing,internal,state,and,counters;public,string,get,stats,info,return,this,stats,to,string
StompSubProtocolHandler -> public String getStatsInfo();1419883989;Return a String describing internal state and counters.;public String getStatsInfo() {_		return this.stats.toString()__	};return,a,string,describing,internal,state,and,counters;public,string,get,stats,info,return,this,stats,to,string
StompSubProtocolHandler -> public String getStatsInfo();1424278379;Return a String describing internal state and counters.;public String getStatsInfo() {_		return this.stats.toString()__	};return,a,string,describing,internal,state,and,counters;public,string,get,stats,info,return,this,stats,to,string
StompSubProtocolHandler -> public String getStatsInfo();1428353843;Return a String describing internal state and counters.;public String getStatsInfo() {_		return this.stats.toString()__	};return,a,string,describing,internal,state,and,counters;public,string,get,stats,info,return,this,stats,to,string
StompSubProtocolHandler -> public String getStatsInfo();1430834982;Return a String describing internal state and counters.;public String getStatsInfo() {_		return this.stats.toString()__	};return,a,string,describing,internal,state,and,counters;public,string,get,stats,info,return,this,stats,to,string
StompSubProtocolHandler -> public String getStatsInfo();1431458952;Return a String describing internal state and counters.;public String getStatsInfo() {_		return this.stats.toString()__	};return,a,string,describing,internal,state,and,counters;public,string,get,stats,info,return,this,stats,to,string
StompSubProtocolHandler -> public String getStatsInfo();1431728285;Return a String describing internal state and counters.;public String getStatsInfo() {_		return this.stats.toString()__	};return,a,string,describing,internal,state,and,counters;public,string,get,stats,info,return,this,stats,to,string
StompSubProtocolHandler -> public String getStatsInfo();1432316649;Return a String describing internal state and counters.;public String getStatsInfo() {_		return this.stats.toString()__	};return,a,string,describing,internal,state,and,counters;public,string,get,stats,info,return,this,stats,to,string
StompSubProtocolHandler -> public String getStatsInfo();1432331447;Return a String describing internal state and counters.;public String getStatsInfo() {_		return this.stats.toString()__	};return,a,string,describing,internal,state,and,counters;public,string,get,stats,info,return,this,stats,to,string
StompSubProtocolHandler -> public String getStatsInfo();1440168414;Return a String describing internal state and counters.;public String getStatsInfo() {_		return this.stats.toString()__	};return,a,string,describing,internal,state,and,counters;public,string,get,stats,info,return,this,stats,to,string
StompSubProtocolHandler -> public String getStatsInfo();1440249342;Return a String describing internal state and counters.;public String getStatsInfo() {_		return this.stats.toString()__	};return,a,string,describing,internal,state,and,counters;public,string,get,stats,info,return,this,stats,to,string
StompSubProtocolHandler -> public String getStatsInfo();1467726769;Return a String describing internal state and counters.;public String getStatsInfo() {_		return this.stats.toString()__	};return,a,string,describing,internal,state,and,counters;public,string,get,stats,info,return,this,stats,to,string
StompSubProtocolHandler -> public String getStatsInfo();1467730834;Return a String describing internal state and counters.;public String getStatsInfo() {_		return this.stats.toString()__	};return,a,string,describing,internal,state,and,counters;public,string,get,stats,info,return,this,stats,to,string
StompSubProtocolHandler -> public String getStatsInfo();1472062321;Return a String describing internal state and counters.;public String getStatsInfo() {_		return this.stats.toString()__	};return,a,string,describing,internal,state,and,counters;public,string,get,stats,info,return,this,stats,to,string
StompSubProtocolHandler -> public String getStatsInfo();1472509879;Return a String describing internal state and counters.;public String getStatsInfo() {_		return this.stats.toString()__	};return,a,string,describing,internal,state,and,counters;public,string,get,stats,info,return,this,stats,to,string
StompSubProtocolHandler -> public String getStatsInfo();1476284885;Return a String describing internal state and counters.;public String getStatsInfo() {_		return this.stats.toString()__	};return,a,string,describing,internal,state,and,counters;public,string,get,stats,info,return,this,stats,to,string
StompSubProtocolHandler -> public String getStatsInfo();1481213680;Return a String describing internal state and counters.;public String getStatsInfo() {_		return this.stats.toString()__	};return,a,string,describing,internal,state,and,counters;public,string,get,stats,info,return,this,stats,to,string
StompSubProtocolHandler -> public String getStatsInfo();1481669991;Return a String describing internal state and counters.;public String getStatsInfo() {_		return this.stats.toString()__	};return,a,string,describing,internal,state,and,counters;public,string,get,stats,info,return,this,stats,to,string
StompSubProtocolHandler -> public String getStatsInfo();1482265068;Return a String describing internal state and counters.;public String getStatsInfo() {_		return this.stats.toString()__	};return,a,string,describing,internal,state,and,counters;public,string,get,stats,info,return,this,stats,to,string
StompSubProtocolHandler -> public String getStatsInfo();1495868221;Return a String describing internal state and counters.;public String getStatsInfo() {_		return this.stats.toString()__	};return,a,string,describing,internal,state,and,counters;public,string,get,stats,info,return,this,stats,to,string
StompSubProtocolHandler -> public String getStatsInfo();1496837955;Return a String describing internal state and counters.;public String getStatsInfo() {_		return this.stats.toString()__	};return,a,string,describing,internal,state,and,counters;public,string,get,stats,info,return,this,stats,to,string
StompSubProtocolHandler -> public String getStatsInfo();1497251962;Return a String describing internal state and counters.;public String getStatsInfo() {_		return this.stats.toString()__	};return,a,string,describing,internal,state,and,counters;public,string,get,stats,info,return,this,stats,to,string
StompSubProtocolHandler -> public String getStatsInfo();1498780456;Return a String describing internal state and counters.;public String getStatsInfo() {_		return this.stats.toString()__	};return,a,string,describing,internal,state,and,counters;public,string,get,stats,info,return,this,stats,to,string
StompSubProtocolHandler -> public String getStatsInfo();1500448076;Return a String describing internal state and counters.;public String getStatsInfo() {_		return this.stats.toString()__	};return,a,string,describing,internal,state,and,counters;public,string,get,stats,info,return,this,stats,to,string
StompSubProtocolHandler -> public String getStatsInfo();1501147952;Return a String describing internal state and counters.;public String getStatsInfo() {_		return this.stats.toString()__	};return,a,string,describing,internal,state,and,counters;public,string,get,stats,info,return,this,stats,to,string
StompSubProtocolHandler -> public String getStatsInfo();1502974979;Return a String describing internal state and counters.;public String getStatsInfo() {_		return this.stats.toString()__	};return,a,string,describing,internal,state,and,counters;public,string,get,stats,info,return,this,stats,to,string
StompSubProtocolHandler -> public String getStatsInfo();1509997270;Return a String describing internal state and counters.;public String getStatsInfo() {_		return this.stats.toString()__	};return,a,string,describing,internal,state,and,counters;public,string,get,stats,info,return,this,stats,to,string
StompSubProtocolHandler -> public String getStatsInfo();1530174524;Return a String describing internal state and counters.;public String getStatsInfo() {_		return this.stats.toString()__	};return,a,string,describing,internal,state,and,counters;public,string,get,stats,info,return,this,stats,to,string
StompSubProtocolHandler -> public String getStatsInfo();1536886762;Return a String describing internal state and counters.;public String getStatsInfo() {_		return this.stats.toString()__	};return,a,string,describing,internal,state,and,counters;public,string,get,stats,info,return,this,stats,to,string
StompSubProtocolHandler -> public String getStatsInfo();1542899558;Return a String describing internal state and counters.;public String getStatsInfo() {_		return this.stats.toString()__	};return,a,string,describing,internal,state,and,counters;public,string,get,stats,info,return,this,stats,to,string
StompSubProtocolHandler -> public void setMessageBufferSizeLimit(int messageBufferSizeLimit);1395703237;TODO_@param messageBufferSizeLimit;public void setMessageBufferSizeLimit(int messageBufferSizeLimit) {_		this.messageBufferSizeLimit = messageBufferSizeLimit__	};todo,param,message,buffer,size,limit;public,void,set,message,buffer,size,limit,int,message,buffer,size,limit,this,message,buffer,size,limit,message,buffer,size,limit
StompSubProtocolHandler -> public void setMessageBufferSizeLimit(int messageBufferSizeLimit);1395703237;Set the message buffer size limit in bytes._@since 4.0.3;public void setMessageBufferSizeLimit(int messageBufferSizeLimit) {_		this.messageBufferSizeLimit = messageBufferSizeLimit__	};set,the,message,buffer,size,limit,in,bytes,since,4,0,3;public,void,set,message,buffer,size,limit,int,message,buffer,size,limit,this,message,buffer,size,limit,message,buffer,size,limit
StompSubProtocolHandler -> public void setMessageBufferSizeLimit(int messageBufferSizeLimit);1395703237;Configure the maximum size of the buffer used when a STOMP message has been_split over multiple WebSocket messages.__<p>While the STOMP spec version 1.2 (current as of 4.0.3) does not discuss_STOMP over WebSocket explicitly, a number of clients already split messages_around 16K boundaries. Therefore partial content must be buffered before a_full message can be assembled.__<p>By default this property is set to 64K.__@since 4.0.3;public void setMessageBufferSizeLimit(int messageBufferSizeLimit) {_		this.messageBufferSizeLimit = messageBufferSizeLimit__	};configure,the,maximum,size,of,the,buffer,used,when,a,stomp,message,has,been,split,over,multiple,web,socket,messages,p,while,the,stomp,spec,version,1,2,current,as,of,4,0,3,does,not,discuss,stomp,over,web,socket,explicitly,a,number,of,clients,already,split,messages,around,16k,boundaries,therefore,partial,content,must,be,buffered,before,a,full,message,can,be,assembled,p,by,default,this,property,is,set,to,64k,since,4,0,3;public,void,set,message,buffer,size,limit,int,message,buffer,size,limit,this,message,buffer,size,limit,message,buffer,size,limit
StompSubProtocolHandler -> public void setUserSessionRegistry(UserSessionRegistry registry);1385258957;Provide a registry with which to register active user session ids.__@see {@link org.springframework.messaging.simp.handler.UserDestinationMessageHandler};public void setUserSessionRegistry(UserSessionRegistry registry) {_		this.userSessionRegistry = registry__	};provide,a,registry,with,which,to,register,active,user,session,ids,see,link,org,springframework,messaging,simp,handler,user,destination,message,handler;public,void,set,user,session,registry,user,session,registry,registry,this,user,session,registry,registry
StompSubProtocolHandler -> public void setUserSessionRegistry(UserSessionRegistry registry);1385412762;Provide a registry with which to register active user session ids.__@see {@link org.springframework.messaging.simp.handler.UserDestinationMessageHandler};public void setUserSessionRegistry(UserSessionRegistry registry) {_		this.userSessionRegistry = registry__	};provide,a,registry,with,which,to,register,active,user,session,ids,see,link,org,springframework,messaging,simp,handler,user,destination,message,handler;public,void,set,user,session,registry,user,session,registry,registry,this,user,session,registry,registry
StompSubProtocolHandler -> public void setUserSessionRegistry(UserSessionRegistry registry);1385501137;Provide a registry with which to register active user session ids._@see org.springframework.messaging.simp.handler.UserDestinationMessageHandler;public void setUserSessionRegistry(UserSessionRegistry registry) {_		this.userSessionRegistry = registry__	};provide,a,registry,with,which,to,register,active,user,session,ids,see,org,springframework,messaging,simp,handler,user,destination,message,handler;public,void,set,user,session,registry,user,session,registry,registry,this,user,session,registry,registry
StompSubProtocolHandler -> public void setUserSessionRegistry(UserSessionRegistry registry);1385502674;Provide a registry with which to register active user session ids._@see org.springframework.messaging.simp.handler.UserDestinationMessageHandler;public void setUserSessionRegistry(UserSessionRegistry registry) {_		this.userSessionRegistry = registry__	};provide,a,registry,with,which,to,register,active,user,session,ids,see,org,springframework,messaging,simp,handler,user,destination,message,handler;public,void,set,user,session,registry,user,session,registry,registry,this,user,session,registry,registry
StompSubProtocolHandler -> public void setUserSessionRegistry(UserSessionRegistry registry);1386367529;Provide a registry with which to register active user session ids._@see org.springframework.messaging.simp.user.UserDestinationMessageHandler;public void setUserSessionRegistry(UserSessionRegistry registry) {_		this.userSessionRegistry = registry__	};provide,a,registry,with,which,to,register,active,user,session,ids,see,org,springframework,messaging,simp,user,user,destination,message,handler;public,void,set,user,session,registry,user,session,registry,registry,this,user,session,registry,registry
StompSubProtocolHandler -> public void setUserSessionRegistry(UserSessionRegistry registry);1386462352;Provide a registry with which to register active user session ids._@see org.springframework.messaging.simp.user.UserDestinationMessageHandler;public void setUserSessionRegistry(UserSessionRegistry registry) {_		this.userSessionRegistry = registry__	};provide,a,registry,with,which,to,register,active,user,session,ids,see,org,springframework,messaging,simp,user,user,destination,message,handler;public,void,set,user,session,registry,user,session,registry,registry,this,user,session,registry,registry
StompSubProtocolHandler -> public void setUserSessionRegistry(UserSessionRegistry registry);1388683679;Provide a registry with which to register active user session ids._@see org.springframework.messaging.simp.user.UserDestinationMessageHandler;public void setUserSessionRegistry(UserSessionRegistry registry) {_		this.userSessionRegistry = registry__	};provide,a,registry,with,which,to,register,active,user,session,ids,see,org,springframework,messaging,simp,user,user,destination,message,handler;public,void,set,user,session,registry,user,session,registry,registry,this,user,session,registry,registry
StompSubProtocolHandler -> public void setUserSessionRegistry(UserSessionRegistry registry);1390324325;Provide a registry with which to register active user session ids._@see org.springframework.messaging.simp.user.UserDestinationMessageHandler;public void setUserSessionRegistry(UserSessionRegistry registry) {_		this.userSessionRegistry = registry__	};provide,a,registry,with,which,to,register,active,user,session,ids,see,org,springframework,messaging,simp,user,user,destination,message,handler;public,void,set,user,session,registry,user,session,registry,registry,this,user,session,registry,registry
StompSubProtocolHandler -> public void setUserSessionRegistry(UserSessionRegistry registry);1390325555;Provide a registry with which to register active user session ids._@see org.springframework.messaging.simp.user.UserDestinationMessageHandler;public void setUserSessionRegistry(UserSessionRegistry registry) {_		this.userSessionRegistry = registry__	};provide,a,registry,with,which,to,register,active,user,session,ids,see,org,springframework,messaging,simp,user,user,destination,message,handler;public,void,set,user,session,registry,user,session,registry,registry,this,user,session,registry,registry
StompSubProtocolHandler -> public void setUserSessionRegistry(UserSessionRegistry registry);1392327536;Provide a registry with which to register active user session ids._@see org.springframework.messaging.simp.user.UserDestinationMessageHandler;public void setUserSessionRegistry(UserSessionRegistry registry) {_		this.userSessionRegistry = registry__	};provide,a,registry,with,which,to,register,active,user,session,ids,see,org,springframework,messaging,simp,user,user,destination,message,handler;public,void,set,user,session,registry,user,session,registry,registry,this,user,session,registry,registry
StompSubProtocolHandler -> public void setUserSessionRegistry(UserSessionRegistry registry);1395251140;Provide a registry with which to register active user session ids._@see org.springframework.messaging.simp.user.UserDestinationMessageHandler;public void setUserSessionRegistry(UserSessionRegistry registry) {_		this.userSessionRegistry = registry__	};provide,a,registry,with,which,to,register,active,user,session,ids,see,org,springframework,messaging,simp,user,user,destination,message,handler;public,void,set,user,session,registry,user,session,registry,registry,this,user,session,registry,registry
StompSubProtocolHandler -> public void setUserSessionRegistry(UserSessionRegistry registry);1395364758;Provide a registry with which to register active user session ids._@see org.springframework.messaging.simp.user.UserDestinationMessageHandler;public void setUserSessionRegistry(UserSessionRegistry registry) {_		this.userSessionRegistry = registry__	};provide,a,registry,with,which,to,register,active,user,session,ids,see,org,springframework,messaging,simp,user,user,destination,message,handler;public,void,set,user,session,registry,user,session,registry,registry,this,user,session,registry,registry
StompSubProtocolHandler -> public void setUserSessionRegistry(UserSessionRegistry registry);1395416543;Provide a registry with which to register active user session ids._@see org.springframework.messaging.simp.user.UserDestinationMessageHandler;public void setUserSessionRegistry(UserSessionRegistry registry) {_		this.userSessionRegistry = registry__	};provide,a,registry,with,which,to,register,active,user,session,ids,see,org,springframework,messaging,simp,user,user,destination,message,handler;public,void,set,user,session,registry,user,session,registry,registry,this,user,session,registry,registry
StompSubProtocolHandler -> public void setUserSessionRegistry(UserSessionRegistry registry);1395543579;Provide a registry with which to register active user session ids._@see org.springframework.messaging.simp.user.UserDestinationMessageHandler;public void setUserSessionRegistry(UserSessionRegistry registry) {_		this.userSessionRegistry = registry__	};provide,a,registry,with,which,to,register,active,user,session,ids,see,org,springframework,messaging,simp,user,user,destination,message,handler;public,void,set,user,session,registry,user,session,registry,registry,this,user,session,registry,registry
StompSubProtocolHandler -> public void setUserSessionRegistry(UserSessionRegistry registry);1395555177;Provide a registry with which to register active user session ids._@see org.springframework.messaging.simp.user.UserDestinationMessageHandler;public void setUserSessionRegistry(UserSessionRegistry registry) {_		this.userSessionRegistry = registry__	};provide,a,registry,with,which,to,register,active,user,session,ids,see,org,springframework,messaging,simp,user,user,destination,message,handler;public,void,set,user,session,registry,user,session,registry,registry,this,user,session,registry,registry
StompSubProtocolHandler -> public void setUserSessionRegistry(UserSessionRegistry registry);1395703237;Provide a registry with which to register active user session ids._@see org.springframework.messaging.simp.user.UserDestinationMessageHandler;public void setUserSessionRegistry(UserSessionRegistry registry) {_		this.userSessionRegistry = registry__	};provide,a,registry,with,which,to,register,active,user,session,ids,see,org,springframework,messaging,simp,user,user,destination,message,handler;public,void,set,user,session,registry,user,session,registry,registry,this,user,session,registry,registry
StompSubProtocolHandler -> public void setUserSessionRegistry(UserSessionRegistry registry);1395703237;Provide a registry with which to register active user session ids._@see org.springframework.messaging.simp.user.UserDestinationMessageHandler;public void setUserSessionRegistry(UserSessionRegistry registry) {_		this.userSessionRegistry = registry__	};provide,a,registry,with,which,to,register,active,user,session,ids,see,org,springframework,messaging,simp,user,user,destination,message,handler;public,void,set,user,session,registry,user,session,registry,registry,this,user,session,registry,registry
StompSubProtocolHandler -> public void setUserSessionRegistry(UserSessionRegistry registry);1395703237;Provide a registry with which to register active user session ids._@see org.springframework.messaging.simp.user.UserDestinationMessageHandler;public void setUserSessionRegistry(UserSessionRegistry registry) {_		this.userSessionRegistry = registry__	};provide,a,registry,with,which,to,register,active,user,session,ids,see,org,springframework,messaging,simp,user,user,destination,message,handler;public,void,set,user,session,registry,user,session,registry,registry,this,user,session,registry,registry
StompSubProtocolHandler -> public void setUserSessionRegistry(UserSessionRegistry registry);1395703238;Provide a registry with which to register active user session ids._@see org.springframework.messaging.simp.user.UserDestinationMessageHandler;public void setUserSessionRegistry(UserSessionRegistry registry) {_		this.userSessionRegistry = registry__	};provide,a,registry,with,which,to,register,active,user,session,ids,see,org,springframework,messaging,simp,user,user,destination,message,handler;public,void,set,user,session,registry,user,session,registry,registry,this,user,session,registry,registry
StompSubProtocolHandler -> public void setUserSessionRegistry(UserSessionRegistry registry);1395707441;Provide a registry with which to register active user session ids._@see org.springframework.messaging.simp.user.UserDestinationMessageHandler;public void setUserSessionRegistry(UserSessionRegistry registry) {_		this.userSessionRegistry = registry__	};provide,a,registry,with,which,to,register,active,user,session,ids,see,org,springframework,messaging,simp,user,user,destination,message,handler;public,void,set,user,session,registry,user,session,registry,registry,this,user,session,registry,registry
StompSubProtocolHandler -> public void setUserSessionRegistry(UserSessionRegistry registry);1395721625;Provide a registry with which to register active user session ids._@see org.springframework.messaging.simp.user.UserDestinationMessageHandler;public void setUserSessionRegistry(UserSessionRegistry registry) {_		this.userSessionRegistry = registry__	};provide,a,registry,with,which,to,register,active,user,session,ids,see,org,springframework,messaging,simp,user,user,destination,message,handler;public,void,set,user,session,registry,user,session,registry,registry,this,user,session,registry,registry
StompSubProtocolHandler -> public void setUserSessionRegistry(UserSessionRegistry registry);1395752742;Provide a registry with which to register active user session ids._@see org.springframework.messaging.simp.user.UserDestinationMessageHandler;public void setUserSessionRegistry(UserSessionRegistry registry) {_		this.userSessionRegistry = registry__	};provide,a,registry,with,which,to,register,active,user,session,ids,see,org,springframework,messaging,simp,user,user,destination,message,handler;public,void,set,user,session,registry,user,session,registry,registry,this,user,session,registry,registry
StompSubProtocolHandler -> public void setUserSessionRegistry(UserSessionRegistry registry);1395755949;Provide a registry with which to register active user session ids._@see org.springframework.messaging.simp.user.UserDestinationMessageHandler;public void setUserSessionRegistry(UserSessionRegistry registry) {_		this.userSessionRegistry = registry__	};provide,a,registry,with,which,to,register,active,user,session,ids,see,org,springframework,messaging,simp,user,user,destination,message,handler;public,void,set,user,session,registry,user,session,registry,registry,this,user,session,registry,registry
StompSubProtocolHandler -> public void setUserSessionRegistry(UserSessionRegistry registry);1395847954;Provide a registry with which to register active user session ids._@see org.springframework.messaging.simp.user.UserDestinationMessageHandler;public void setUserSessionRegistry(UserSessionRegistry registry) {_		this.userSessionRegistry = registry__	};provide,a,registry,with,which,to,register,active,user,session,ids,see,org,springframework,messaging,simp,user,user,destination,message,handler;public,void,set,user,session,registry,user,session,registry,registry,this,user,session,registry,registry
StompSubProtocolHandler -> public void setUserSessionRegistry(UserSessionRegistry registry);1396578670;Provide a registry with which to register active user session ids._@see org.springframework.messaging.simp.user.UserDestinationMessageHandler;public void setUserSessionRegistry(UserSessionRegistry registry) {_		this.userSessionRegistry = registry__	};provide,a,registry,with,which,to,register,active,user,session,ids,see,org,springframework,messaging,simp,user,user,destination,message,handler;public,void,set,user,session,registry,user,session,registry,registry,this,user,session,registry,registry
StompSubProtocolHandler -> public void setUserSessionRegistry(UserSessionRegistry registry);1396636309;Provide a registry with which to register active user session ids._@see org.springframework.messaging.simp.user.UserDestinationMessageHandler;public void setUserSessionRegistry(UserSessionRegistry registry) {_		this.userSessionRegistry = registry__	};provide,a,registry,with,which,to,register,active,user,session,ids,see,org,springframework,messaging,simp,user,user,destination,message,handler;public,void,set,user,session,registry,user,session,registry,registry,this,user,session,registry,registry
StompSubProtocolHandler -> public void setUserSessionRegistry(UserSessionRegistry registry);1397429525;Provide a registry with which to register active user session ids._@see org.springframework.messaging.simp.user.UserDestinationMessageHandler;public void setUserSessionRegistry(UserSessionRegistry registry) {_		this.userSessionRegistry = registry__	};provide,a,registry,with,which,to,register,active,user,session,ids,see,org,springframework,messaging,simp,user,user,destination,message,handler;public,void,set,user,session,registry,user,session,registry,registry,this,user,session,registry,registry
StompSubProtocolHandler -> public void setUserSessionRegistry(UserSessionRegistry registry);1397439322;Provide a registry with which to register active user session ids._@see org.springframework.messaging.simp.user.UserDestinationMessageHandler;public void setUserSessionRegistry(UserSessionRegistry registry) {_		this.userSessionRegistry = registry__	};provide,a,registry,with,which,to,register,active,user,session,ids,see,org,springframework,messaging,simp,user,user,destination,message,handler;public,void,set,user,session,registry,user,session,registry,registry,this,user,session,registry,registry
StompSubProtocolHandler -> public void setUserSessionRegistry(UserSessionRegistry registry);1397523793;Provide a registry with which to register active user session ids._@see org.springframework.messaging.simp.user.UserDestinationMessageHandler;public void setUserSessionRegistry(UserSessionRegistry registry) {_		this.userSessionRegistry = registry__	};provide,a,registry,with,which,to,register,active,user,session,ids,see,org,springframework,messaging,simp,user,user,destination,message,handler;public,void,set,user,session,registry,user,session,registry,registry,this,user,session,registry,registry
StompSubProtocolHandler -> public void setUserSessionRegistry(UserSessionRegistry registry);1398443164;Provide a registry with which to register active user session ids._@see org.springframework.messaging.simp.user.UserDestinationMessageHandler;public void setUserSessionRegistry(UserSessionRegistry registry) {_		this.userSessionRegistry = registry__	};provide,a,registry,with,which,to,register,active,user,session,ids,see,org,springframework,messaging,simp,user,user,destination,message,handler;public,void,set,user,session,registry,user,session,registry,registry,this,user,session,registry,registry
StompSubProtocolHandler -> public void setUserSessionRegistry(UserSessionRegistry registry);1399601217;Provide a registry with which to register active user session ids._@see org.springframework.messaging.simp.user.UserDestinationMessageHandler;public void setUserSessionRegistry(UserSessionRegistry registry) {_		this.userSessionRegistry = registry__	};provide,a,registry,with,which,to,register,active,user,session,ids,see,org,springframework,messaging,simp,user,user,destination,message,handler;public,void,set,user,session,registry,user,session,registry,registry,this,user,session,registry,registry
StompSubProtocolHandler -> public void setUserSessionRegistry(UserSessionRegistry registry);1399825877;Provide a registry with which to register active user session ids._@see org.springframework.messaging.simp.user.UserDestinationMessageHandler;public void setUserSessionRegistry(UserSessionRegistry registry) {_		this.userSessionRegistry = registry__	};provide,a,registry,with,which,to,register,active,user,session,ids,see,org,springframework,messaging,simp,user,user,destination,message,handler;public,void,set,user,session,registry,user,session,registry,registry,this,user,session,registry,registry
StompSubProtocolHandler -> public void setUserSessionRegistry(UserSessionRegistry registry);1403719829;Provide a registry with which to register active user session ids._@see org.springframework.messaging.simp.user.UserDestinationMessageHandler;public void setUserSessionRegistry(UserSessionRegistry registry) {_		this.userSessionRegistry = registry__	};provide,a,registry,with,which,to,register,active,user,session,ids,see,org,springframework,messaging,simp,user,user,destination,message,handler;public,void,set,user,session,registry,user,session,registry,registry,this,user,session,registry,registry
StompSubProtocolHandler -> public void setUserSessionRegistry(UserSessionRegistry registry);1403856366;Provide a registry with which to register active user session ids._@see org.springframework.messaging.simp.user.UserDestinationMessageHandler;public void setUserSessionRegistry(UserSessionRegistry registry) {_		this.userSessionRegistry = registry__	};provide,a,registry,with,which,to,register,active,user,session,ids,see,org,springframework,messaging,simp,user,user,destination,message,handler;public,void,set,user,session,registry,user,session,registry,registry,this,user,session,registry,registry
StompSubProtocolHandler -> public void setUserSessionRegistry(UserSessionRegistry registry);1403968062;Provide a registry with which to register active user session ids._@see org.springframework.messaging.simp.user.UserDestinationMessageHandler;public void setUserSessionRegistry(UserSessionRegistry registry) {_		this.userSessionRegistry = registry__	};provide,a,registry,with,which,to,register,active,user,session,ids,see,org,springframework,messaging,simp,user,user,destination,message,handler;public,void,set,user,session,registry,user,session,registry,registry,this,user,session,registry,registry
StompSubProtocolHandler -> public void setUserSessionRegistry(UserSessionRegistry registry);1404880787;Provide a registry with which to register active user session ids._@see org.springframework.messaging.simp.user.UserDestinationMessageHandler;public void setUserSessionRegistry(UserSessionRegistry registry) {_		this.userSessionRegistry = registry__	};provide,a,registry,with,which,to,register,active,user,session,ids,see,org,springframework,messaging,simp,user,user,destination,message,handler;public,void,set,user,session,registry,user,session,registry,registry,this,user,session,registry,registry
StompSubProtocolHandler -> public void setUserSessionRegistry(UserSessionRegistry registry);1404880799;Provide a registry with which to register active user session ids._@see org.springframework.messaging.simp.user.UserDestinationMessageHandler;public void setUserSessionRegistry(UserSessionRegistry registry) {_		this.userSessionRegistry = registry__	};provide,a,registry,with,which,to,register,active,user,session,ids,see,org,springframework,messaging,simp,user,user,destination,message,handler;public,void,set,user,session,registry,user,session,registry,registry,this,user,session,registry,registry
StompSubProtocolHandler -> public void setUserSessionRegistry(UserSessionRegistry registry);1411067168;Provide a registry with which to register active user session ids._@see org.springframework.messaging.simp.user.UserDestinationMessageHandler;public void setUserSessionRegistry(UserSessionRegistry registry) {_		this.userSessionRegistry = registry__	};provide,a,registry,with,which,to,register,active,user,session,ids,see,org,springframework,messaging,simp,user,user,destination,message,handler;public,void,set,user,session,registry,user,session,registry,registry,this,user,session,registry,registry
StompSubProtocolHandler -> public void setUserSessionRegistry(UserSessionRegistry registry);1411068071;Provide a registry with which to register active user session ids._@see org.springframework.messaging.simp.user.UserDestinationMessageHandler;public void setUserSessionRegistry(UserSessionRegistry registry) {_		this.userSessionRegistry = registry__	};provide,a,registry,with,which,to,register,active,user,session,ids,see,org,springframework,messaging,simp,user,user,destination,message,handler;public,void,set,user,session,registry,user,session,registry,registry,this,user,session,registry,registry
StompSubProtocolHandler -> public void setUserSessionRegistry(UserSessionRegistry registry);1411148800;Provide a registry with which to register active user session ids._@see org.springframework.messaging.simp.user.UserDestinationMessageHandler;public void setUserSessionRegistry(UserSessionRegistry registry) {_		this.userSessionRegistry = registry__	};provide,a,registry,with,which,to,register,active,user,session,ids,see,org,springframework,messaging,simp,user,user,destination,message,handler;public,void,set,user,session,registry,user,session,registry,registry,this,user,session,registry,registry
StompSubProtocolHandler -> public void setUserSessionRegistry(UserSessionRegistry registry);1411567635;Provide a registry with which to register active user session ids._@see org.springframework.messaging.simp.user.UserDestinationMessageHandler;public void setUserSessionRegistry(UserSessionRegistry registry) {_		this.userSessionRegistry = registry__	};provide,a,registry,with,which,to,register,active,user,session,ids,see,org,springframework,messaging,simp,user,user,destination,message,handler;public,void,set,user,session,registry,user,session,registry,registry,this,user,session,registry,registry
StompSubProtocolHandler -> public void setUserSessionRegistry(UserSessionRegistry registry);1412965899;Provide a registry with which to register active user session ids._@see org.springframework.messaging.simp.user.UserDestinationMessageHandler;public void setUserSessionRegistry(UserSessionRegistry registry) {_		this.userSessionRegistry = registry__	};provide,a,registry,with,which,to,register,active,user,session,ids,see,org,springframework,messaging,simp,user,user,destination,message,handler;public,void,set,user,session,registry,user,session,registry,registry,this,user,session,registry,registry
StompSubProtocolHandler -> public void setUserSessionRegistry(UserSessionRegistry registry);1413848647;Provide a registry with which to register active user session ids._@see org.springframework.messaging.simp.user.UserDestinationMessageHandler;public void setUserSessionRegistry(UserSessionRegistry registry) {_		this.userSessionRegistry = registry__	};provide,a,registry,with,which,to,register,active,user,session,ids,see,org,springframework,messaging,simp,user,user,destination,message,handler;public,void,set,user,session,registry,user,session,registry,registry,this,user,session,registry,registry
StompSubProtocolHandler -> public void setUserSessionRegistry(UserSessionRegistry registry);1414092351;Provide a registry with which to register active user session ids._@see org.springframework.messaging.simp.user.UserDestinationMessageHandler;public void setUserSessionRegistry(UserSessionRegistry registry) {_		this.userSessionRegistry = registry__	};provide,a,registry,with,which,to,register,active,user,session,ids,see,org,springframework,messaging,simp,user,user,destination,message,handler;public,void,set,user,session,registry,user,session,registry,registry,this,user,session,registry,registry
StompSubProtocolHandler -> public void setUserSessionRegistry(UserSessionRegistry registry);1414158498;Provide a registry with which to register active user session ids._@see org.springframework.messaging.simp.user.UserDestinationMessageHandler;public void setUserSessionRegistry(UserSessionRegistry registry) {_		this.userSessionRegistry = registry__	};provide,a,registry,with,which,to,register,active,user,session,ids,see,org,springframework,messaging,simp,user,user,destination,message,handler;public,void,set,user,session,registry,user,session,registry,registry,this,user,session,registry,registry
StompSubProtocolHandler -> public void setUserSessionRegistry(UserSessionRegistry registry);1419362683;Provide a registry with which to register active user session ids._@see org.springframework.messaging.simp.user.UserDestinationMessageHandler;public void setUserSessionRegistry(UserSessionRegistry registry) {_		this.userSessionRegistry = registry__	};provide,a,registry,with,which,to,register,active,user,session,ids,see,org,springframework,messaging,simp,user,user,destination,message,handler;public,void,set,user,session,registry,user,session,registry,registry,this,user,session,registry,registry
StompSubProtocolHandler -> public void setUserSessionRegistry(UserSessionRegistry registry);1419883989;Provide a registry with which to register active user session ids._@see org.springframework.messaging.simp.user.UserDestinationMessageHandler;public void setUserSessionRegistry(UserSessionRegistry registry) {_		this.userSessionRegistry = registry__	};provide,a,registry,with,which,to,register,active,user,session,ids,see,org,springframework,messaging,simp,user,user,destination,message,handler;public,void,set,user,session,registry,user,session,registry,registry,this,user,session,registry,registry
StompSubProtocolHandler -> public void setUserSessionRegistry(UserSessionRegistry registry);1424278379;Provide a registry with which to register active user session ids._@see org.springframework.messaging.simp.user.UserDestinationMessageHandler;public void setUserSessionRegistry(UserSessionRegistry registry) {_		this.userSessionRegistry = registry__	};provide,a,registry,with,which,to,register,active,user,session,ids,see,org,springframework,messaging,simp,user,user,destination,message,handler;public,void,set,user,session,registry,user,session,registry,registry,this,user,session,registry,registry
StompSubProtocolHandler -> public void setUserSessionRegistry(UserSessionRegistry registry);1428353843;Provide a registry with which to register active user session ids._@see org.springframework.messaging.simp.user.UserDestinationMessageHandler;public void setUserSessionRegistry(UserSessionRegistry registry) {_		this.userSessionRegistry = registry__	};provide,a,registry,with,which,to,register,active,user,session,ids,see,org,springframework,messaging,simp,user,user,destination,message,handler;public,void,set,user,session,registry,user,session,registry,registry,this,user,session,registry,registry
StompSubProtocolHandler -> public void setUserSessionRegistry(UserSessionRegistry registry);1430834982;Provide a registry with which to register active user session ids._@see org.springframework.messaging.simp.user.UserDestinationMessageHandler;public void setUserSessionRegistry(UserSessionRegistry registry) {_		this.userSessionRegistry = registry__	};provide,a,registry,with,which,to,register,active,user,session,ids,see,org,springframework,messaging,simp,user,user,destination,message,handler;public,void,set,user,session,registry,user,session,registry,registry,this,user,session,registry,registry
StompSubProtocolHandler -> public void handleMessageFromClient(WebSocketSession session, 			WebSocketMessage<?> webSocketMessage, MessageChannel outputChannel);1385412762;Handle incoming WebSocket messages from clients.;public void handleMessageFromClient(WebSocketSession session,_			WebSocketMessage<?> webSocketMessage, MessageChannel outputChannel) {__		Message<?> message__		try {_			Assert.isInstanceOf(TextMessage.class,  webSocketMessage)__			String payload = ((TextMessage)webSocketMessage).getPayload()__			ByteBuffer byteBuffer = ByteBuffer.wrap(payload.getBytes(Charset.forName("UTF-8")))__			message = this.stompDecoder.decode(byteBuffer)__		}_		catch (Throwable error) {_			logger.error("Failed to parse STOMP frame, WebSocket message payload: ", error)__			sendErrorMessage(session, error)__			return__		}__		try {_			StompHeaderAccessor headers = StompHeaderAccessor.wrap(message)__			if (SimpMessageType.HEARTBEAT.equals(headers.getMessageType())) {_				logger.trace("Received heartbeat from client session=" + session.getId())__			}_			else {_				logger.trace("Received message from client session=" + session.getId())__			}__			headers.setSessionId(session.getId())__			headers.setUser(session.getPrincipal())___			message = MessageBuilder.withPayload(message.getPayload()).setHeaders(headers).build()__			outputChannel.send(message)__		}_		catch (Throwable t) {_			logger.error("Terminating STOMP session due to failure to send message: ", t)__			sendErrorMessage(session, t)__		}_	};handle,incoming,web,socket,messages,from,clients;public,void,handle,message,from,client,web,socket,session,session,web,socket,message,web,socket,message,message,channel,output,channel,message,message,try,assert,is,instance,of,text,message,class,web,socket,message,string,payload,text,message,web,socket,message,get,payload,byte,buffer,byte,buffer,byte,buffer,wrap,payload,get,bytes,charset,for,name,utf,8,message,this,stomp,decoder,decode,byte,buffer,catch,throwable,error,logger,error,failed,to,parse,stomp,frame,web,socket,message,payload,error,send,error,message,session,error,return,try,stomp,header,accessor,headers,stomp,header,accessor,wrap,message,if,simp,message,type,heartbeat,equals,headers,get,message,type,logger,trace,received,heartbeat,from,client,session,session,get,id,else,logger,trace,received,message,from,client,session,session,get,id,headers,set,session,id,session,get,id,headers,set,user,session,get,principal,message,message,builder,with,payload,message,get,payload,set,headers,headers,build,output,channel,send,message,catch,throwable,t,logger,error,terminating,stomp,session,due,to,failure,to,send,message,t,send,error,message,session,t
StompSubProtocolHandler -> public void handleMessageFromClient(WebSocketSession session, 			WebSocketMessage<?> webSocketMessage, MessageChannel outputChannel);1385501137;Handle incoming WebSocket messages from clients.;public void handleMessageFromClient(WebSocketSession session,_			WebSocketMessage<?> webSocketMessage, MessageChannel outputChannel) {__		Message<?> message__		try {_			Assert.isInstanceOf(TextMessage.class,  webSocketMessage)__			String payload = ((TextMessage)webSocketMessage).getPayload()__			ByteBuffer byteBuffer = ByteBuffer.wrap(payload.getBytes(Charset.forName("UTF-8")))__			message = this.stompDecoder.decode(byteBuffer)__		}_		catch (Throwable error) {_			logger.error("Failed to parse STOMP frame, WebSocket message payload: ", error)__			sendErrorMessage(session, error)__			return__		}__		try {_			StompHeaderAccessor headers = StompHeaderAccessor.wrap(message)__			if (SimpMessageType.HEARTBEAT.equals(headers.getMessageType())) {_				logger.trace("Received heartbeat from client session=" + session.getId())__			}_			else {_				logger.trace("Received message from client session=" + session.getId())__			}__			headers.setSessionId(session.getId())__			headers.setUser(session.getPrincipal())___			message = MessageBuilder.withPayload(message.getPayload()).setHeaders(headers).build()__			outputChannel.send(message)__		}_		catch (Throwable t) {_			logger.error("Terminating STOMP session due to failure to send message: ", t)__			sendErrorMessage(session, t)__		}_	};handle,incoming,web,socket,messages,from,clients;public,void,handle,message,from,client,web,socket,session,session,web,socket,message,web,socket,message,message,channel,output,channel,message,message,try,assert,is,instance,of,text,message,class,web,socket,message,string,payload,text,message,web,socket,message,get,payload,byte,buffer,byte,buffer,byte,buffer,wrap,payload,get,bytes,charset,for,name,utf,8,message,this,stomp,decoder,decode,byte,buffer,catch,throwable,error,logger,error,failed,to,parse,stomp,frame,web,socket,message,payload,error,send,error,message,session,error,return,try,stomp,header,accessor,headers,stomp,header,accessor,wrap,message,if,simp,message,type,heartbeat,equals,headers,get,message,type,logger,trace,received,heartbeat,from,client,session,session,get,id,else,logger,trace,received,message,from,client,session,session,get,id,headers,set,session,id,session,get,id,headers,set,user,session,get,principal,message,message,builder,with,payload,message,get,payload,set,headers,headers,build,output,channel,send,message,catch,throwable,t,logger,error,terminating,stomp,session,due,to,failure,to,send,message,t,send,error,message,session,t
StompSubProtocolHandler -> public void handleMessageFromClient(WebSocketSession session, 			WebSocketMessage<?> webSocketMessage, MessageChannel outputChannel);1385502674;Handle incoming WebSocket messages from clients.;public void handleMessageFromClient(WebSocketSession session,_			WebSocketMessage<?> webSocketMessage, MessageChannel outputChannel) {__		Message<?> message__		try {_			Assert.isInstanceOf(TextMessage.class,  webSocketMessage)__			String payload = ((TextMessage)webSocketMessage).getPayload()__			ByteBuffer byteBuffer = ByteBuffer.wrap(payload.getBytes(Charset.forName("UTF-8")))__			message = this.stompDecoder.decode(byteBuffer)__		}_		catch (Throwable error) {_			logger.error("Failed to parse STOMP frame, WebSocket message payload: ", error)__			sendErrorMessage(session, error)__			return__		}__		try {_			StompHeaderAccessor headers = StompHeaderAccessor.wrap(message)__			if (SimpMessageType.HEARTBEAT.equals(headers.getMessageType())) {_				logger.trace("Received heartbeat from client session=" + session.getId())__			}_			else {_				logger.trace("Received message from client session=" + session.getId())__			}__			headers.setSessionId(session.getId())__			headers.setUser(session.getPrincipal())___			message = MessageBuilder.withPayload(message.getPayload()).setHeaders(headers).build()__			outputChannel.send(message)__		}_		catch (Throwable t) {_			logger.error("Terminating STOMP session due to failure to send message: ", t)__			sendErrorMessage(session, t)__		}_	};handle,incoming,web,socket,messages,from,clients;public,void,handle,message,from,client,web,socket,session,session,web,socket,message,web,socket,message,message,channel,output,channel,message,message,try,assert,is,instance,of,text,message,class,web,socket,message,string,payload,text,message,web,socket,message,get,payload,byte,buffer,byte,buffer,byte,buffer,wrap,payload,get,bytes,charset,for,name,utf,8,message,this,stomp,decoder,decode,byte,buffer,catch,throwable,error,logger,error,failed,to,parse,stomp,frame,web,socket,message,payload,error,send,error,message,session,error,return,try,stomp,header,accessor,headers,stomp,header,accessor,wrap,message,if,simp,message,type,heartbeat,equals,headers,get,message,type,logger,trace,received,heartbeat,from,client,session,session,get,id,else,logger,trace,received,message,from,client,session,session,get,id,headers,set,session,id,session,get,id,headers,set,user,session,get,principal,message,message,builder,with,payload,message,get,payload,set,headers,headers,build,output,channel,send,message,catch,throwable,t,logger,error,terminating,stomp,session,due,to,failure,to,send,message,t,send,error,message,session,t
StompSubProtocolHandler -> public void handleMessageFromClient(WebSocketSession session, 			WebSocketMessage<?> webSocketMessage, MessageChannel outputChannel);1386367529;Handle incoming WebSocket messages from clients.;public void handleMessageFromClient(WebSocketSession session,_			WebSocketMessage<?> webSocketMessage, MessageChannel outputChannel) {__		Message<?> message__		try {_			Assert.isInstanceOf(TextMessage.class,  webSocketMessage)__			String payload = ((TextMessage)webSocketMessage).getPayload()__			ByteBuffer byteBuffer = ByteBuffer.wrap(payload.getBytes(Charset.forName("UTF-8")))__			message = this.stompDecoder.decode(byteBuffer)__		}_		catch (Throwable error) {_			logger.error("Failed to parse STOMP frame, WebSocket message payload: ", error)__			sendErrorMessage(session, error)__			return__		}__		try {_			StompHeaderAccessor headers = StompHeaderAccessor.wrap(message)__			if (SimpMessageType.HEARTBEAT.equals(headers.getMessageType())) {_				logger.trace("Received heartbeat from client session=" + session.getId())__			}_			else {_				logger.trace("Received message from client session=" + session.getId())__			}__			headers.setSessionId(session.getId())__			headers.setUser(session.getPrincipal())___			message = MessageBuilder.withPayload(message.getPayload()).setHeaders(headers).build()__			outputChannel.send(message)__		}_		catch (Throwable t) {_			logger.error("Terminating STOMP session due to failure to send message: ", t)__			sendErrorMessage(session, t)__		}_	};handle,incoming,web,socket,messages,from,clients;public,void,handle,message,from,client,web,socket,session,session,web,socket,message,web,socket,message,message,channel,output,channel,message,message,try,assert,is,instance,of,text,message,class,web,socket,message,string,payload,text,message,web,socket,message,get,payload,byte,buffer,byte,buffer,byte,buffer,wrap,payload,get,bytes,charset,for,name,utf,8,message,this,stomp,decoder,decode,byte,buffer,catch,throwable,error,logger,error,failed,to,parse,stomp,frame,web,socket,message,payload,error,send,error,message,session,error,return,try,stomp,header,accessor,headers,stomp,header,accessor,wrap,message,if,simp,message,type,heartbeat,equals,headers,get,message,type,logger,trace,received,heartbeat,from,client,session,session,get,id,else,logger,trace,received,message,from,client,session,session,get,id,headers,set,session,id,session,get,id,headers,set,user,session,get,principal,message,message,builder,with,payload,message,get,payload,set,headers,headers,build,output,channel,send,message,catch,throwable,t,logger,error,terminating,stomp,session,due,to,failure,to,send,message,t,send,error,message,session,t
StompSubProtocolHandler -> public void handleMessageFromClient(WebSocketSession session, 			WebSocketMessage<?> webSocketMessage, MessageChannel outputChannel);1386462352;Handle incoming WebSocket messages from clients.;public void handleMessageFromClient(WebSocketSession session,_			WebSocketMessage<?> webSocketMessage, MessageChannel outputChannel) {__		Message<?> message__		try {_			Assert.isInstanceOf(TextMessage.class,  webSocketMessage)__			String payload = ((TextMessage)webSocketMessage).getPayload()__			ByteBuffer byteBuffer = ByteBuffer.wrap(payload.getBytes(UTF8_CHARSET))__			message = this.stompDecoder.decode(byteBuffer)__		}_		catch (Throwable ex) {_			logger.error("Failed to parse STOMP frame, WebSocket message payload", ex)__			sendErrorMessage(session, ex)__			return__		}__		try {_			StompHeaderAccessor headers = StompHeaderAccessor.wrap(message)__			if (logger.isTraceEnabled()) {_				if (SimpMessageType.HEARTBEAT.equals(headers.getMessageType())) {_					logger.trace("Received heartbeat from client session=" + session.getId())__				}_				else {_					logger.trace("Received message from client session=" + session.getId())__				}_			}__			headers.setSessionId(session.getId())__			headers.setUser(session.getPrincipal())___			message = MessageBuilder.withPayload(message.getPayload()).setHeaders(headers).build()__			outputChannel.send(message)__		}_		catch (Throwable ex) {_			logger.error("Terminating STOMP session due to failure to send message", ex)__			sendErrorMessage(session, ex)__		}_	};handle,incoming,web,socket,messages,from,clients;public,void,handle,message,from,client,web,socket,session,session,web,socket,message,web,socket,message,message,channel,output,channel,message,message,try,assert,is,instance,of,text,message,class,web,socket,message,string,payload,text,message,web,socket,message,get,payload,byte,buffer,byte,buffer,byte,buffer,wrap,payload,get,bytes,message,this,stomp,decoder,decode,byte,buffer,catch,throwable,ex,logger,error,failed,to,parse,stomp,frame,web,socket,message,payload,ex,send,error,message,session,ex,return,try,stomp,header,accessor,headers,stomp,header,accessor,wrap,message,if,logger,is,trace,enabled,if,simp,message,type,heartbeat,equals,headers,get,message,type,logger,trace,received,heartbeat,from,client,session,session,get,id,else,logger,trace,received,message,from,client,session,session,get,id,headers,set,session,id,session,get,id,headers,set,user,session,get,principal,message,message,builder,with,payload,message,get,payload,set,headers,headers,build,output,channel,send,message,catch,throwable,ex,logger,error,terminating,stomp,session,due,to,failure,to,send,message,ex,send,error,message,session,ex
StompSubProtocolHandler -> public void handleMessageFromClient(WebSocketSession session, 			WebSocketMessage<?> webSocketMessage, MessageChannel outputChannel);1388683679;Handle incoming WebSocket messages from clients.;public void handleMessageFromClient(WebSocketSession session,_			WebSocketMessage<?> webSocketMessage, MessageChannel outputChannel) {__		Message<?> message = null__		Throwable decodeFailure = null__		try {_			Assert.isInstanceOf(TextMessage.class,  webSocketMessage)__			String payload = ((TextMessage) webSocketMessage).getPayload()__			ByteBuffer byteBuffer = ByteBuffer.wrap(payload.getBytes(UTF8_CHARSET))___			message = this.stompDecoder.decode(byteBuffer)__			if (message == null) {_				decodeFailure = new IllegalStateException("Not a valid STOMP frame: " + payload)__			}_		}_		catch (Throwable ex) {_			decodeFailure = ex__		}__		if (decodeFailure != null) {_			logger.error("Failed to parse WebSocket message as STOMP frame", decodeFailure)__			sendErrorMessage(session, decodeFailure)__			return__		}__		try {_			StompHeaderAccessor headers = StompHeaderAccessor.wrap(message)__			if (logger.isTraceEnabled()) {_				if (SimpMessageType.HEARTBEAT.equals(headers.getMessageType())) {_					logger.trace("Received heartbeat from client session=" + session.getId())__				}_				else {_					logger.trace("Received message from client session=" + session.getId())__				}_			}__			headers.setSessionId(session.getId())__			headers.setUser(session.getPrincipal())___			message = MessageBuilder.withPayload(message.getPayload()).setHeaders(headers).build()__			outputChannel.send(message)__		}_		catch (Throwable ex) {_			logger.error("Terminating STOMP session due to failure to send message", ex)__			sendErrorMessage(session, ex)__		}_	};handle,incoming,web,socket,messages,from,clients;public,void,handle,message,from,client,web,socket,session,session,web,socket,message,web,socket,message,message,channel,output,channel,message,message,null,throwable,decode,failure,null,try,assert,is,instance,of,text,message,class,web,socket,message,string,payload,text,message,web,socket,message,get,payload,byte,buffer,byte,buffer,byte,buffer,wrap,payload,get,bytes,message,this,stomp,decoder,decode,byte,buffer,if,message,null,decode,failure,new,illegal,state,exception,not,a,valid,stomp,frame,payload,catch,throwable,ex,decode,failure,ex,if,decode,failure,null,logger,error,failed,to,parse,web,socket,message,as,stomp,frame,decode,failure,send,error,message,session,decode,failure,return,try,stomp,header,accessor,headers,stomp,header,accessor,wrap,message,if,logger,is,trace,enabled,if,simp,message,type,heartbeat,equals,headers,get,message,type,logger,trace,received,heartbeat,from,client,session,session,get,id,else,logger,trace,received,message,from,client,session,session,get,id,headers,set,session,id,session,get,id,headers,set,user,session,get,principal,message,message,builder,with,payload,message,get,payload,set,headers,headers,build,output,channel,send,message,catch,throwable,ex,logger,error,terminating,stomp,session,due,to,failure,to,send,message,ex,send,error,message,session,ex
StompSubProtocolHandler -> public void handleMessageFromClient(WebSocketSession session, 			WebSocketMessage<?> webSocketMessage, MessageChannel outputChannel);1390324325;Handle incoming WebSocket messages from clients.;public void handleMessageFromClient(WebSocketSession session,_			WebSocketMessage<?> webSocketMessage, MessageChannel outputChannel) {__		Message<?> message = null__		Throwable decodeFailure = null__		try {_			Assert.isInstanceOf(TextMessage.class,  webSocketMessage)__			String payload = ((TextMessage) webSocketMessage).getPayload()__			ByteBuffer byteBuffer = ByteBuffer.wrap(payload.getBytes(UTF8_CHARSET))___			message = this.stompDecoder.decode(byteBuffer)__			if (message == null) {_				decodeFailure = new IllegalStateException("Not a valid STOMP frame: " + payload)__			}_		}_		catch (Throwable ex) {_			decodeFailure = ex__		}__		if (decodeFailure != null) {_			logger.error("Failed to parse WebSocket message as STOMP frame", decodeFailure)__			sendErrorMessage(session, decodeFailure)__			return__		}__		try {_			StompHeaderAccessor headers = StompHeaderAccessor.wrap(message)__			if (logger.isTraceEnabled()) {_				if (SimpMessageType.HEARTBEAT.equals(headers.getMessageType())) {_					logger.trace("Received heartbeat from client session=" + session.getId())__				}_				else {_					logger.trace("Received message from client session=" + session.getId())__				}_			}__			headers.setSessionId(session.getId())__			headers.setUser(session.getPrincipal())___			message = MessageBuilder.withPayload(message.getPayload()).setHeaders(headers).build()__			outputChannel.send(message)__		}_		catch (Throwable ex) {_			logger.error("Terminating STOMP session due to failure to send message", ex)__			sendErrorMessage(session, ex)__		}_	};handle,incoming,web,socket,messages,from,clients;public,void,handle,message,from,client,web,socket,session,session,web,socket,message,web,socket,message,message,channel,output,channel,message,message,null,throwable,decode,failure,null,try,assert,is,instance,of,text,message,class,web,socket,message,string,payload,text,message,web,socket,message,get,payload,byte,buffer,byte,buffer,byte,buffer,wrap,payload,get,bytes,message,this,stomp,decoder,decode,byte,buffer,if,message,null,decode,failure,new,illegal,state,exception,not,a,valid,stomp,frame,payload,catch,throwable,ex,decode,failure,ex,if,decode,failure,null,logger,error,failed,to,parse,web,socket,message,as,stomp,frame,decode,failure,send,error,message,session,decode,failure,return,try,stomp,header,accessor,headers,stomp,header,accessor,wrap,message,if,logger,is,trace,enabled,if,simp,message,type,heartbeat,equals,headers,get,message,type,logger,trace,received,heartbeat,from,client,session,session,get,id,else,logger,trace,received,message,from,client,session,session,get,id,headers,set,session,id,session,get,id,headers,set,user,session,get,principal,message,message,builder,with,payload,message,get,payload,set,headers,headers,build,output,channel,send,message,catch,throwable,ex,logger,error,terminating,stomp,session,due,to,failure,to,send,message,ex,send,error,message,session,ex
StompSubProtocolHandler -> public void handleMessageFromClient(WebSocketSession session, 			WebSocketMessage<?> webSocketMessage, MessageChannel outputChannel);1390325555;Handle incoming WebSocket messages from clients.;public void handleMessageFromClient(WebSocketSession session,_			WebSocketMessage<?> webSocketMessage, MessageChannel outputChannel) {__		Message<?> message = null__		Throwable decodeFailure = null__		try {_			Assert.isInstanceOf(TextMessage.class,  webSocketMessage)__			String payload = ((TextMessage) webSocketMessage).getPayload()__			ByteBuffer byteBuffer = ByteBuffer.wrap(payload.getBytes(UTF8_CHARSET))___			message = this.stompDecoder.decode(byteBuffer)__			if (message == null) {_				decodeFailure = new IllegalStateException("Not a valid STOMP frame: " + payload)__			}_		}_		catch (Throwable ex) {_			decodeFailure = ex__		}__		if (decodeFailure != null) {_			logger.error("Failed to parse WebSocket message as STOMP frame", decodeFailure)__			sendErrorMessage(session, decodeFailure)__			return__		}__		try {_			StompHeaderAccessor headers = StompHeaderAccessor.wrap(message)__			if (logger.isTraceEnabled()) {_				if (SimpMessageType.HEARTBEAT.equals(headers.getMessageType())) {_					logger.trace("Received heartbeat from client session=" + session.getId())__				}_				else {_					logger.trace("Received message from client session=" + session.getId())__				}_			}__			headers.setSessionId(session.getId())__			headers.setUser(session.getPrincipal())___			message = MessageBuilder.withPayload(message.getPayload()).setHeaders(headers).build()__			outputChannel.send(message)__		}_		catch (Throwable ex) {_			logger.error("Terminating STOMP session due to failure to send message", ex)__			sendErrorMessage(session, ex)__		}_	};handle,incoming,web,socket,messages,from,clients;public,void,handle,message,from,client,web,socket,session,session,web,socket,message,web,socket,message,message,channel,output,channel,message,message,null,throwable,decode,failure,null,try,assert,is,instance,of,text,message,class,web,socket,message,string,payload,text,message,web,socket,message,get,payload,byte,buffer,byte,buffer,byte,buffer,wrap,payload,get,bytes,message,this,stomp,decoder,decode,byte,buffer,if,message,null,decode,failure,new,illegal,state,exception,not,a,valid,stomp,frame,payload,catch,throwable,ex,decode,failure,ex,if,decode,failure,null,logger,error,failed,to,parse,web,socket,message,as,stomp,frame,decode,failure,send,error,message,session,decode,failure,return,try,stomp,header,accessor,headers,stomp,header,accessor,wrap,message,if,logger,is,trace,enabled,if,simp,message,type,heartbeat,equals,headers,get,message,type,logger,trace,received,heartbeat,from,client,session,session,get,id,else,logger,trace,received,message,from,client,session,session,get,id,headers,set,session,id,session,get,id,headers,set,user,session,get,principal,message,message,builder,with,payload,message,get,payload,set,headers,headers,build,output,channel,send,message,catch,throwable,ex,logger,error,terminating,stomp,session,due,to,failure,to,send,message,ex,send,error,message,session,ex
StompSubProtocolHandler -> public void handleMessageFromClient(WebSocketSession session, 			WebSocketMessage<?> webSocketMessage, MessageChannel outputChannel);1392327536;Handle incoming WebSocket messages from clients.;public void handleMessageFromClient(WebSocketSession session,_			WebSocketMessage<?> webSocketMessage, MessageChannel outputChannel) {__		Message<?> message = null__		Throwable decodeFailure = null__		try {_			Assert.isInstanceOf(TextMessage.class,  webSocketMessage)__			String payload = ((TextMessage) webSocketMessage).getPayload()__			ByteBuffer byteBuffer = ByteBuffer.wrap(payload.getBytes(UTF8_CHARSET))___			message = this.stompDecoder.decode(byteBuffer)__			if (message == null) {_				decodeFailure = new IllegalStateException("Not a valid STOMP frame: " + payload)__			}_		}_		catch (Throwable ex) {_			decodeFailure = ex__		}__		if (decodeFailure != null) {_			logger.error("Failed to parse WebSocket message as STOMP frame", decodeFailure)__			sendErrorMessage(session, decodeFailure)__			return__		}__		try {_			StompHeaderAccessor headers = StompHeaderAccessor.wrap(message)__			if (logger.isTraceEnabled()) {_				if (SimpMessageType.HEARTBEAT.equals(headers.getMessageType())) {_					logger.trace("Received heartbeat from client session=" + session.getId())__				}_				else {_					logger.trace("Received message from client session=" + session.getId())__				}_			}__			headers.setSessionId(session.getId())__			headers.setUser(session.getPrincipal())___			message = MessageBuilder.withPayload(message.getPayload()).setHeaders(headers).build()__			outputChannel.send(message)__		}_		catch (Throwable ex) {_			logger.error("Terminating STOMP session due to failure to send message", ex)__			sendErrorMessage(session, ex)__		}_	};handle,incoming,web,socket,messages,from,clients;public,void,handle,message,from,client,web,socket,session,session,web,socket,message,web,socket,message,message,channel,output,channel,message,message,null,throwable,decode,failure,null,try,assert,is,instance,of,text,message,class,web,socket,message,string,payload,text,message,web,socket,message,get,payload,byte,buffer,byte,buffer,byte,buffer,wrap,payload,get,bytes,message,this,stomp,decoder,decode,byte,buffer,if,message,null,decode,failure,new,illegal,state,exception,not,a,valid,stomp,frame,payload,catch,throwable,ex,decode,failure,ex,if,decode,failure,null,logger,error,failed,to,parse,web,socket,message,as,stomp,frame,decode,failure,send,error,message,session,decode,failure,return,try,stomp,header,accessor,headers,stomp,header,accessor,wrap,message,if,logger,is,trace,enabled,if,simp,message,type,heartbeat,equals,headers,get,message,type,logger,trace,received,heartbeat,from,client,session,session,get,id,else,logger,trace,received,message,from,client,session,session,get,id,headers,set,session,id,session,get,id,headers,set,user,session,get,principal,message,message,builder,with,payload,message,get,payload,set,headers,headers,build,output,channel,send,message,catch,throwable,ex,logger,error,terminating,stomp,session,due,to,failure,to,send,message,ex,send,error,message,session,ex
StompSubProtocolHandler -> public void handleMessageFromClient(WebSocketSession session, 			WebSocketMessage<?> webSocketMessage, MessageChannel outputChannel);1395251140;Handle incoming WebSocket messages from clients.;public void handleMessageFromClient(WebSocketSession session,_			WebSocketMessage<?> webSocketMessage, MessageChannel outputChannel) {__		Message<?> message = null__		Throwable decodeFailure = null__		try {_			Assert.isInstanceOf(TextMessage.class,  webSocketMessage)__			String payload = ((TextMessage) webSocketMessage).getPayload()__			ByteBuffer byteBuffer = ByteBuffer.wrap(payload.getBytes(UTF8_CHARSET))___			message = this.stompDecoder.decode(byteBuffer)__			if (message == null) {_				decodeFailure = new IllegalStateException("Not a valid STOMP frame: " + payload)__			}_		}_		catch (Throwable ex) {_			decodeFailure = ex__		}__		if (decodeFailure != null) {_			logger.error("Failed to parse WebSocket message as STOMP frame", decodeFailure)__			sendErrorMessage(session, decodeFailure)__			return__		}__		try {_			StompHeaderAccessor headers = StompHeaderAccessor.wrap(message)__			if (logger.isTraceEnabled()) {_				if (SimpMessageType.HEARTBEAT.equals(headers.getMessageType())) {_					logger.trace("Received heartbeat from client session=" + session.getId())__				}_				else {_					logger.trace("Received message from client session=" + session.getId())__				}_			}__			headers.setSessionId(session.getId())__			headers.setSessionAttributes(session.getAttributes())__			headers.setUser(session.getPrincipal())___			message = MessageBuilder.withPayload(message.getPayload()).setHeaders(headers).build()__			outputChannel.send(message)__		}_		catch (Throwable ex) {_			logger.error("Terminating STOMP session due to failure to send message", ex)__			sendErrorMessage(session, ex)__		}_	};handle,incoming,web,socket,messages,from,clients;public,void,handle,message,from,client,web,socket,session,session,web,socket,message,web,socket,message,message,channel,output,channel,message,message,null,throwable,decode,failure,null,try,assert,is,instance,of,text,message,class,web,socket,message,string,payload,text,message,web,socket,message,get,payload,byte,buffer,byte,buffer,byte,buffer,wrap,payload,get,bytes,message,this,stomp,decoder,decode,byte,buffer,if,message,null,decode,failure,new,illegal,state,exception,not,a,valid,stomp,frame,payload,catch,throwable,ex,decode,failure,ex,if,decode,failure,null,logger,error,failed,to,parse,web,socket,message,as,stomp,frame,decode,failure,send,error,message,session,decode,failure,return,try,stomp,header,accessor,headers,stomp,header,accessor,wrap,message,if,logger,is,trace,enabled,if,simp,message,type,heartbeat,equals,headers,get,message,type,logger,trace,received,heartbeat,from,client,session,session,get,id,else,logger,trace,received,message,from,client,session,session,get,id,headers,set,session,id,session,get,id,headers,set,session,attributes,session,get,attributes,headers,set,user,session,get,principal,message,message,builder,with,payload,message,get,payload,set,headers,headers,build,output,channel,send,message,catch,throwable,ex,logger,error,terminating,stomp,session,due,to,failure,to,send,message,ex,send,error,message,session,ex
StompSubProtocolHandler -> public void handleMessageFromClient(WebSocketSession session, 			WebSocketMessage<?> webSocketMessage, MessageChannel outputChannel);1395364758;Handle incoming WebSocket messages from clients.;public void handleMessageFromClient(WebSocketSession session,_			WebSocketMessage<?> webSocketMessage, MessageChannel outputChannel) {__		Message<?> message = null__		Throwable decodeFailure = null__		try {_			Assert.isInstanceOf(TextMessage.class,  webSocketMessage)__			TextMessage textMessage = (TextMessage) webSocketMessage__			ByteBuffer byteBuffer = ByteBuffer.wrap(textMessage.asBytes())___			message = this.stompDecoder.decode(byteBuffer)__			if (message == null) {_				decodeFailure = new IllegalStateException("Not a valid STOMP frame: " + textMessage.getPayload())__			}_		}_		catch (Throwable ex) {_			decodeFailure = ex__		}__		if (decodeFailure != null) {_			logger.error("Failed to parse WebSocket message as STOMP frame", decodeFailure)__			sendErrorMessage(session, decodeFailure)__			return__		}__		try {_			StompHeaderAccessor headers = StompHeaderAccessor.wrap(message)__			if (logger.isTraceEnabled()) {_				if (SimpMessageType.HEARTBEAT.equals(headers.getMessageType())) {_					logger.trace("Received heartbeat from client session=" + session.getId())__				}_				else {_					logger.trace("Received message from client session=" + session.getId())__				}_			}__			headers.setSessionId(session.getId())__			headers.setSessionAttributes(session.getAttributes())__			headers.setUser(session.getPrincipal())___			message = MessageBuilder.withPayload(message.getPayload()).setHeaders(headers).build()__			outputChannel.send(message)__		}_		catch (Throwable ex) {_			logger.error("Terminating STOMP session due to failure to send message", ex)__			sendErrorMessage(session, ex)__		}_	};handle,incoming,web,socket,messages,from,clients;public,void,handle,message,from,client,web,socket,session,session,web,socket,message,web,socket,message,message,channel,output,channel,message,message,null,throwable,decode,failure,null,try,assert,is,instance,of,text,message,class,web,socket,message,text,message,text,message,text,message,web,socket,message,byte,buffer,byte,buffer,byte,buffer,wrap,text,message,as,bytes,message,this,stomp,decoder,decode,byte,buffer,if,message,null,decode,failure,new,illegal,state,exception,not,a,valid,stomp,frame,text,message,get,payload,catch,throwable,ex,decode,failure,ex,if,decode,failure,null,logger,error,failed,to,parse,web,socket,message,as,stomp,frame,decode,failure,send,error,message,session,decode,failure,return,try,stomp,header,accessor,headers,stomp,header,accessor,wrap,message,if,logger,is,trace,enabled,if,simp,message,type,heartbeat,equals,headers,get,message,type,logger,trace,received,heartbeat,from,client,session,session,get,id,else,logger,trace,received,message,from,client,session,session,get,id,headers,set,session,id,session,get,id,headers,set,session,attributes,session,get,attributes,headers,set,user,session,get,principal,message,message,builder,with,payload,message,get,payload,set,headers,headers,build,output,channel,send,message,catch,throwable,ex,logger,error,terminating,stomp,session,due,to,failure,to,send,message,ex,send,error,message,session,ex
StompSubProtocolHandler -> public void handleMessageFromClient(WebSocketSession session, 			WebSocketMessage<?> webSocketMessage, MessageChannel outputChannel);1395416543;Handle incoming WebSocket messages from clients.;public void handleMessageFromClient(WebSocketSession session,_			WebSocketMessage<?> webSocketMessage, MessageChannel outputChannel) {__		Message<?> message = null__		Throwable decodeFailure = null__		try {_			Assert.isInstanceOf(TextMessage.class,  webSocketMessage)__			TextMessage textMessage = (TextMessage) webSocketMessage__			ByteBuffer byteBuffer = ByteBuffer.wrap(textMessage.asBytes())___			message = this.stompDecoder.decode(byteBuffer)__			if (message == null) {_				decodeFailure = new IllegalStateException("Not a valid STOMP frame: " + textMessage.getPayload())__			}_		}_		catch (Throwable ex) {_			decodeFailure = ex__		}__		if (decodeFailure != null) {_			logger.error("Failed to parse WebSocket message as STOMP frame", decodeFailure)__			sendErrorMessage(session, decodeFailure)__			return__		}__		try {_			StompHeaderAccessor headers = StompHeaderAccessor.wrap(message)__			if (logger.isTraceEnabled()) {_				if (SimpMessageType.HEARTBEAT.equals(headers.getMessageType())) {_					logger.trace("Received heartbeat from client session=" + session.getId())__				}_				else {_					logger.trace("Received message from client session=" + session.getId())__				}_			}__			headers.setSessionId(session.getId())__			headers.setSessionAttributes(session.getAttributes())__			headers.setUser(session.getPrincipal())___			message = MessageBuilder.withPayload(message.getPayload()).setHeaders(headers).build()__			outputChannel.send(message)__		}_		catch (Throwable ex) {_			logger.error("Terminating STOMP session due to failure to send message", ex)__			sendErrorMessage(session, ex)__		}_	};handle,incoming,web,socket,messages,from,clients;public,void,handle,message,from,client,web,socket,session,session,web,socket,message,web,socket,message,message,channel,output,channel,message,message,null,throwable,decode,failure,null,try,assert,is,instance,of,text,message,class,web,socket,message,text,message,text,message,text,message,web,socket,message,byte,buffer,byte,buffer,byte,buffer,wrap,text,message,as,bytes,message,this,stomp,decoder,decode,byte,buffer,if,message,null,decode,failure,new,illegal,state,exception,not,a,valid,stomp,frame,text,message,get,payload,catch,throwable,ex,decode,failure,ex,if,decode,failure,null,logger,error,failed,to,parse,web,socket,message,as,stomp,frame,decode,failure,send,error,message,session,decode,failure,return,try,stomp,header,accessor,headers,stomp,header,accessor,wrap,message,if,logger,is,trace,enabled,if,simp,message,type,heartbeat,equals,headers,get,message,type,logger,trace,received,heartbeat,from,client,session,session,get,id,else,logger,trace,received,message,from,client,session,session,get,id,headers,set,session,id,session,get,id,headers,set,session,attributes,session,get,attributes,headers,set,user,session,get,principal,message,message,builder,with,payload,message,get,payload,set,headers,headers,build,output,channel,send,message,catch,throwable,ex,logger,error,terminating,stomp,session,due,to,failure,to,send,message,ex,send,error,message,session,ex
StompSubProtocolHandler -> public void handleMessageFromClient(WebSocketSession session, 			WebSocketMessage<?> webSocketMessage, MessageChannel outputChannel);1395543579;Handle incoming WebSocket messages from clients.;public void handleMessageFromClient(WebSocketSession session,_			WebSocketMessage<?> webSocketMessage, MessageChannel outputChannel) {__		Message<?> message = null__		Throwable decodeFailure = null__		try {_			Assert.isInstanceOf(TextMessage.class,  webSocketMessage)__			TextMessage textMessage = (TextMessage) webSocketMessage__			ByteBuffer byteBuffer = ByteBuffer.wrap(textMessage.asBytes())___			message = this.stompDecoder.decode(byteBuffer)__			if (message == null) {_				decodeFailure = new IllegalStateException("Not a valid STOMP frame: " + textMessage.getPayload())__			}_		}_		catch (Throwable ex) {_			decodeFailure = ex__		}__		if (decodeFailure != null) {_			logger.error("Failed to parse WebSocket message as STOMP frame", decodeFailure)__			sendErrorMessage(session, decodeFailure)__			return__		}__		try {_			StompHeaderAccessor headers = StompHeaderAccessor.wrap(message)__			if (logger.isTraceEnabled()) {_				if (SimpMessageType.HEARTBEAT.equals(headers.getMessageType())) {_					logger.trace("Received heartbeat from client session=" + session.getId())__				}_				else {_					logger.trace("Received message from client session=" + session.getId())__				}_			}__			headers.setSessionId(session.getId())__			headers.setSessionAttributes(session.getAttributes())__			headers.setUser(session.getPrincipal())___			message = MessageBuilder.withPayload(message.getPayload()).setHeaders(headers).build()__			outputChannel.send(message)__		}_		catch (Throwable ex) {_			logger.error("Terminating STOMP session due to failure to send message", ex)__			sendErrorMessage(session, ex)__		}_	};handle,incoming,web,socket,messages,from,clients;public,void,handle,message,from,client,web,socket,session,session,web,socket,message,web,socket,message,message,channel,output,channel,message,message,null,throwable,decode,failure,null,try,assert,is,instance,of,text,message,class,web,socket,message,text,message,text,message,text,message,web,socket,message,byte,buffer,byte,buffer,byte,buffer,wrap,text,message,as,bytes,message,this,stomp,decoder,decode,byte,buffer,if,message,null,decode,failure,new,illegal,state,exception,not,a,valid,stomp,frame,text,message,get,payload,catch,throwable,ex,decode,failure,ex,if,decode,failure,null,logger,error,failed,to,parse,web,socket,message,as,stomp,frame,decode,failure,send,error,message,session,decode,failure,return,try,stomp,header,accessor,headers,stomp,header,accessor,wrap,message,if,logger,is,trace,enabled,if,simp,message,type,heartbeat,equals,headers,get,message,type,logger,trace,received,heartbeat,from,client,session,session,get,id,else,logger,trace,received,message,from,client,session,session,get,id,headers,set,session,id,session,get,id,headers,set,session,attributes,session,get,attributes,headers,set,user,session,get,principal,message,message,builder,with,payload,message,get,payload,set,headers,headers,build,output,channel,send,message,catch,throwable,ex,logger,error,terminating,stomp,session,due,to,failure,to,send,message,ex,send,error,message,session,ex
StompSubProtocolHandler -> public void handleMessageFromClient(WebSocketSession session, 			WebSocketMessage<?> webSocketMessage, MessageChannel outputChannel);1395555177;Handle incoming WebSocket messages from clients.;public void handleMessageFromClient(WebSocketSession session,_			WebSocketMessage<?> webSocketMessage, MessageChannel outputChannel) {__		Message<?> message = null__		Throwable decodeFailure = null__		try {_			Assert.isInstanceOf(TextMessage.class,  webSocketMessage)__			TextMessage textMessage = (TextMessage) webSocketMessage__			ByteBuffer byteBuffer = ByteBuffer.wrap(textMessage.asBytes())___			message = this.stompDecoder.decode(byteBuffer)__			if (message == null) {_				decodeFailure = new IllegalStateException("Not a valid STOMP frame: " + textMessage.getPayload())__			}_		}_		catch (Throwable ex) {_			decodeFailure = ex__		}__		if (decodeFailure != null) {_			logger.error("Failed to parse WebSocket message as STOMP frame", decodeFailure)__			sendErrorMessage(session, decodeFailure)__			return__		}__		try {_			StompHeaderAccessor headers = StompHeaderAccessor.wrap(message)__			if (logger.isTraceEnabled()) {_				if (SimpMessageType.HEARTBEAT.equals(headers.getMessageType())) {_					logger.trace("Received heartbeat from client session=" + session.getId())__				}_				else {_					logger.trace("Received message from client session=" + session.getId())__				}_			}__			headers.setSessionId(session.getId())__			headers.setSessionAttributes(session.getAttributes())__			headers.setUser(session.getPrincipal())___			message = MessageBuilder.withPayload(message.getPayload()).setHeaders(headers).build()__			outputChannel.send(message)__		}_		catch (Throwable ex) {_			logger.error("Terminating STOMP session due to failure to send message", ex)__			sendErrorMessage(session, ex)__		}_	};handle,incoming,web,socket,messages,from,clients;public,void,handle,message,from,client,web,socket,session,session,web,socket,message,web,socket,message,message,channel,output,channel,message,message,null,throwable,decode,failure,null,try,assert,is,instance,of,text,message,class,web,socket,message,text,message,text,message,text,message,web,socket,message,byte,buffer,byte,buffer,byte,buffer,wrap,text,message,as,bytes,message,this,stomp,decoder,decode,byte,buffer,if,message,null,decode,failure,new,illegal,state,exception,not,a,valid,stomp,frame,text,message,get,payload,catch,throwable,ex,decode,failure,ex,if,decode,failure,null,logger,error,failed,to,parse,web,socket,message,as,stomp,frame,decode,failure,send,error,message,session,decode,failure,return,try,stomp,header,accessor,headers,stomp,header,accessor,wrap,message,if,logger,is,trace,enabled,if,simp,message,type,heartbeat,equals,headers,get,message,type,logger,trace,received,heartbeat,from,client,session,session,get,id,else,logger,trace,received,message,from,client,session,session,get,id,headers,set,session,id,session,get,id,headers,set,session,attributes,session,get,attributes,headers,set,user,session,get,principal,message,message,builder,with,payload,message,get,payload,set,headers,headers,build,output,channel,send,message,catch,throwable,ex,logger,error,terminating,stomp,session,due,to,failure,to,send,message,ex,send,error,message,session,ex
StompSubProtocolHandler -> public void handleMessageFromClient(WebSocketSession session, 			WebSocketMessage<?> webSocketMessage, MessageChannel outputChannel);1395703237;Handle incoming WebSocket messages from clients.;public void handleMessageFromClient(WebSocketSession session,_			WebSocketMessage<?> webSocketMessage, MessageChannel outputChannel) {__		List<Message<byte[]>> messages = null__		try {_			Assert.isInstanceOf(TextMessage.class,  webSocketMessage)__			TextMessage textMessage = (TextMessage) webSocketMessage__			ByteBuffer byteBuffer = ByteBuffer.wrap(textMessage.asBytes())___			BufferingStompDecoder decoder = this.decoders.get(session.getId())__			if (decoder == null) {_				throw new IllegalStateException("No decoder for session id '" + session.getId() + "'")__			}__			messages = decoder.decode(byteBuffer)__			if (messages.isEmpty()) {_				logger.debug("Incomplete STOMP frame content received," + "buffered=" +_						decoder.getBufferSize() + ", buffer size limit=" + decoder.getBufferSizeLimit())__				return__			}_		}_		catch (Throwable ex) {_			logger.error("Failed to parse WebSocket message to STOMP frame(s)", ex)__			sendErrorMessage(session, ex)__			return__		}__		for (Message<byte[]> message : messages) {_			try {_				StompHeaderAccessor headers = StompHeaderAccessor.wrap(message)__				if (logger.isTraceEnabled()) {_					if (SimpMessageType.HEARTBEAT.equals(headers.getMessageType())) {_						logger.trace("Received heartbeat from client session=" + session.getId())__					}_					else {_						logger.trace("Received message from client session=" + session.getId())__					}_				}__				headers.setSessionId(session.getId())__				headers.setSessionAttributes(session.getAttributes())__				headers.setUser(session.getPrincipal())___				message = MessageBuilder.withPayload(message.getPayload()).setHeaders(headers).build()__				outputChannel.send(message)__			}_			catch (Throwable ex) {_				logger.error("Terminating STOMP session due to failure to send message", ex)__				sendErrorMessage(session, ex)__			}_		}_	};handle,incoming,web,socket,messages,from,clients;public,void,handle,message,from,client,web,socket,session,session,web,socket,message,web,socket,message,message,channel,output,channel,list,message,byte,messages,null,try,assert,is,instance,of,text,message,class,web,socket,message,text,message,text,message,text,message,web,socket,message,byte,buffer,byte,buffer,byte,buffer,wrap,text,message,as,bytes,buffering,stomp,decoder,decoder,this,decoders,get,session,get,id,if,decoder,null,throw,new,illegal,state,exception,no,decoder,for,session,id,session,get,id,messages,decoder,decode,byte,buffer,if,messages,is,empty,logger,debug,incomplete,stomp,frame,content,received,buffered,decoder,get,buffer,size,buffer,size,limit,decoder,get,buffer,size,limit,return,catch,throwable,ex,logger,error,failed,to,parse,web,socket,message,to,stomp,frame,s,ex,send,error,message,session,ex,return,for,message,byte,message,messages,try,stomp,header,accessor,headers,stomp,header,accessor,wrap,message,if,logger,is,trace,enabled,if,simp,message,type,heartbeat,equals,headers,get,message,type,logger,trace,received,heartbeat,from,client,session,session,get,id,else,logger,trace,received,message,from,client,session,session,get,id,headers,set,session,id,session,get,id,headers,set,session,attributes,session,get,attributes,headers,set,user,session,get,principal,message,message,builder,with,payload,message,get,payload,set,headers,headers,build,output,channel,send,message,catch,throwable,ex,logger,error,terminating,stomp,session,due,to,failure,to,send,message,ex,send,error,message,session,ex
StompSubProtocolHandler -> public void handleMessageFromClient(WebSocketSession session, 			WebSocketMessage<?> webSocketMessage, MessageChannel outputChannel);1395703237;Handle incoming WebSocket messages from clients.;public void handleMessageFromClient(WebSocketSession session,_			WebSocketMessage<?> webSocketMessage, MessageChannel outputChannel) {__		List<Message<byte[]>> messages = null__		try {_			Assert.isInstanceOf(TextMessage.class,  webSocketMessage)__			TextMessage textMessage = (TextMessage) webSocketMessage__			ByteBuffer byteBuffer = ByteBuffer.wrap(textMessage.asBytes())___			BufferingStompDecoder decoder = this.decoders.get(session.getId())__			if (decoder == null) {_				throw new IllegalStateException("No decoder for session id '" + session.getId() + "'")__			}__			messages = decoder.decode(byteBuffer)__			if (messages.isEmpty()) {_				logger.debug("Incomplete STOMP frame content received," + "buffered=" +_						decoder.getBufferSize() + ", buffer size limit=" + decoder.getBufferSizeLimit())__				return__			}_		}_		catch (Throwable ex) {_			logger.error("Failed to parse WebSocket message to STOMP frame(s)", ex)__			sendErrorMessage(session, ex)__			return__		}__		for (Message<byte[]> message : messages) {_			try {_				StompHeaderAccessor headers = StompHeaderAccessor.wrap(message)__				if (logger.isTraceEnabled()) {_					if (SimpMessageType.HEARTBEAT.equals(headers.getMessageType())) {_						logger.trace("Received heartbeat from client session=" + session.getId())__					}_					else {_						logger.trace("Received message from client session=" + session.getId())__					}_				}__				headers.setSessionId(session.getId())__				headers.setSessionAttributes(session.getAttributes())__				headers.setUser(session.getPrincipal())___				message = MessageBuilder.withPayload(message.getPayload()).setHeaders(headers).build()__				outputChannel.send(message)__			}_			catch (Throwable ex) {_				logger.error("Terminating STOMP session due to failure to send message", ex)__				sendErrorMessage(session, ex)__			}_		}_	};handle,incoming,web,socket,messages,from,clients;public,void,handle,message,from,client,web,socket,session,session,web,socket,message,web,socket,message,message,channel,output,channel,list,message,byte,messages,null,try,assert,is,instance,of,text,message,class,web,socket,message,text,message,text,message,text,message,web,socket,message,byte,buffer,byte,buffer,byte,buffer,wrap,text,message,as,bytes,buffering,stomp,decoder,decoder,this,decoders,get,session,get,id,if,decoder,null,throw,new,illegal,state,exception,no,decoder,for,session,id,session,get,id,messages,decoder,decode,byte,buffer,if,messages,is,empty,logger,debug,incomplete,stomp,frame,content,received,buffered,decoder,get,buffer,size,buffer,size,limit,decoder,get,buffer,size,limit,return,catch,throwable,ex,logger,error,failed,to,parse,web,socket,message,to,stomp,frame,s,ex,send,error,message,session,ex,return,for,message,byte,message,messages,try,stomp,header,accessor,headers,stomp,header,accessor,wrap,message,if,logger,is,trace,enabled,if,simp,message,type,heartbeat,equals,headers,get,message,type,logger,trace,received,heartbeat,from,client,session,session,get,id,else,logger,trace,received,message,from,client,session,session,get,id,headers,set,session,id,session,get,id,headers,set,session,attributes,session,get,attributes,headers,set,user,session,get,principal,message,message,builder,with,payload,message,get,payload,set,headers,headers,build,output,channel,send,message,catch,throwable,ex,logger,error,terminating,stomp,session,due,to,failure,to,send,message,ex,send,error,message,session,ex
StompSubProtocolHandler -> public void handleMessageFromClient(WebSocketSession session, 			WebSocketMessage<?> webSocketMessage, MessageChannel outputChannel);1395703237;Handle incoming WebSocket messages from clients.;public void handleMessageFromClient(WebSocketSession session,_			WebSocketMessage<?> webSocketMessage, MessageChannel outputChannel) {__		List<Message<byte[]>> messages = null__		try {_			Assert.isInstanceOf(TextMessage.class,  webSocketMessage)__			TextMessage textMessage = (TextMessage) webSocketMessage__			ByteBuffer byteBuffer = ByteBuffer.wrap(textMessage.asBytes())___			BufferingStompDecoder decoder = this.decoders.get(session.getId())__			if (decoder == null) {_				throw new IllegalStateException("No decoder for session id '" + session.getId() + "'")__			}__			messages = decoder.decode(byteBuffer)__			if (messages.isEmpty()) {_				logger.debug("Incomplete STOMP frame content received," + "buffered=" +_						decoder.getBufferSize() + ", buffer size limit=" + decoder.getBufferSizeLimit())__				return__			}_		}_		catch (Throwable ex) {_			logger.error("Failed to parse WebSocket message to STOMP frame(s)", ex)__			sendErrorMessage(session, ex)__			return__		}__		for (Message<byte[]> message : messages) {_			try {_				StompHeaderAccessor headers = StompHeaderAccessor.wrap(message)__				if (logger.isTraceEnabled()) {_					if (SimpMessageType.HEARTBEAT.equals(headers.getMessageType())) {_						logger.trace("Received heartbeat from client session=" + session.getId())__					}_					else {_						logger.trace("Received message from client session=" + session.getId())__					}_				}__				headers.setSessionId(session.getId())__				headers.setSessionAttributes(session.getAttributes())__				headers.setUser(session.getPrincipal())___				message = MessageBuilder.withPayload(message.getPayload()).setHeaders(headers).build()__				outputChannel.send(message)__			}_			catch (Throwable ex) {_				logger.error("Terminating STOMP session due to failure to send message", ex)__				sendErrorMessage(session, ex)__			}_		}_	};handle,incoming,web,socket,messages,from,clients;public,void,handle,message,from,client,web,socket,session,session,web,socket,message,web,socket,message,message,channel,output,channel,list,message,byte,messages,null,try,assert,is,instance,of,text,message,class,web,socket,message,text,message,text,message,text,message,web,socket,message,byte,buffer,byte,buffer,byte,buffer,wrap,text,message,as,bytes,buffering,stomp,decoder,decoder,this,decoders,get,session,get,id,if,decoder,null,throw,new,illegal,state,exception,no,decoder,for,session,id,session,get,id,messages,decoder,decode,byte,buffer,if,messages,is,empty,logger,debug,incomplete,stomp,frame,content,received,buffered,decoder,get,buffer,size,buffer,size,limit,decoder,get,buffer,size,limit,return,catch,throwable,ex,logger,error,failed,to,parse,web,socket,message,to,stomp,frame,s,ex,send,error,message,session,ex,return,for,message,byte,message,messages,try,stomp,header,accessor,headers,stomp,header,accessor,wrap,message,if,logger,is,trace,enabled,if,simp,message,type,heartbeat,equals,headers,get,message,type,logger,trace,received,heartbeat,from,client,session,session,get,id,else,logger,trace,received,message,from,client,session,session,get,id,headers,set,session,id,session,get,id,headers,set,session,attributes,session,get,attributes,headers,set,user,session,get,principal,message,message,builder,with,payload,message,get,payload,set,headers,headers,build,output,channel,send,message,catch,throwable,ex,logger,error,terminating,stomp,session,due,to,failure,to,send,message,ex,send,error,message,session,ex
StompSubProtocolHandler -> public void handleMessageFromClient(WebSocketSession session, 			WebSocketMessage<?> webSocketMessage, MessageChannel outputChannel);1395703238;Handle incoming WebSocket messages from clients.;public void handleMessageFromClient(WebSocketSession session,_			WebSocketMessage<?> webSocketMessage, MessageChannel outputChannel) {__		List<Message<byte[]>> messages = null__		try {_			Assert.isInstanceOf(TextMessage.class,  webSocketMessage)__			TextMessage textMessage = (TextMessage) webSocketMessage__			ByteBuffer byteBuffer = ByteBuffer.wrap(textMessage.asBytes())___			BufferingStompDecoder decoder = this.decoders.get(session.getId())__			if (decoder == null) {_				throw new IllegalStateException("No decoder for session id '" + session.getId() + "'")__			}__			messages = decoder.decode(byteBuffer)__			if (messages.isEmpty()) {_				logger.debug("Incomplete STOMP frame content received," + "buffered=" +_						decoder.getBufferSize() + ", buffer size limit=" + decoder.getBufferSizeLimit())__				return__			}_		}_		catch (Throwable ex) {_			logger.error("Failed to parse WebSocket message to STOMP frame(s)", ex)__			sendErrorMessage(session, ex)__			return__		}__		for (Message<byte[]> message : messages) {_			try {_				StompHeaderAccessor headers = StompHeaderAccessor.wrap(message)__				if (logger.isTraceEnabled()) {_					if (SimpMessageType.HEARTBEAT.equals(headers.getMessageType())) {_						logger.trace("Received heartbeat from client session=" + session.getId())__					}_					else {_						logger.trace("Received message from client session=" + session.getId())__					}_				}__				headers.setSessionId(session.getId())__				headers.setSessionAttributes(session.getAttributes())__				headers.setUser(session.getPrincipal())___				message = MessageBuilder.withPayload(message.getPayload()).setHeaders(headers).build()__				outputChannel.send(message)__			}_			catch (Throwable ex) {_				logger.error("Terminating STOMP session due to failure to send message", ex)__				sendErrorMessage(session, ex)__			}_		}_	};handle,incoming,web,socket,messages,from,clients;public,void,handle,message,from,client,web,socket,session,session,web,socket,message,web,socket,message,message,channel,output,channel,list,message,byte,messages,null,try,assert,is,instance,of,text,message,class,web,socket,message,text,message,text,message,text,message,web,socket,message,byte,buffer,byte,buffer,byte,buffer,wrap,text,message,as,bytes,buffering,stomp,decoder,decoder,this,decoders,get,session,get,id,if,decoder,null,throw,new,illegal,state,exception,no,decoder,for,session,id,session,get,id,messages,decoder,decode,byte,buffer,if,messages,is,empty,logger,debug,incomplete,stomp,frame,content,received,buffered,decoder,get,buffer,size,buffer,size,limit,decoder,get,buffer,size,limit,return,catch,throwable,ex,logger,error,failed,to,parse,web,socket,message,to,stomp,frame,s,ex,send,error,message,session,ex,return,for,message,byte,message,messages,try,stomp,header,accessor,headers,stomp,header,accessor,wrap,message,if,logger,is,trace,enabled,if,simp,message,type,heartbeat,equals,headers,get,message,type,logger,trace,received,heartbeat,from,client,session,session,get,id,else,logger,trace,received,message,from,client,session,session,get,id,headers,set,session,id,session,get,id,headers,set,session,attributes,session,get,attributes,headers,set,user,session,get,principal,message,message,builder,with,payload,message,get,payload,set,headers,headers,build,output,channel,send,message,catch,throwable,ex,logger,error,terminating,stomp,session,due,to,failure,to,send,message,ex,send,error,message,session,ex
StompSubProtocolHandler -> public void handleMessageFromClient(WebSocketSession session, 			WebSocketMessage<?> webSocketMessage, MessageChannel outputChannel);1395707441;Handle incoming WebSocket messages from clients.;public void handleMessageFromClient(WebSocketSession session,_			WebSocketMessage<?> webSocketMessage, MessageChannel outputChannel) {__		List<Message<byte[]>> messages = null__		try {_			Assert.isInstanceOf(TextMessage.class,  webSocketMessage)__			TextMessage textMessage = (TextMessage) webSocketMessage__			ByteBuffer byteBuffer = ByteBuffer.wrap(textMessage.asBytes())___			BufferingStompDecoder decoder = this.decoders.get(session.getId())__			if (decoder == null) {_				throw new IllegalStateException("No decoder for session id '" + session.getId() + "'")__			}__			messages = decoder.decode(byteBuffer)__			if (messages.isEmpty()) {_				logger.debug("Incomplete STOMP frame content received," + "buffered=" +_						decoder.getBufferSize() + ", buffer size limit=" + decoder.getBufferSizeLimit())__				return__			}_		}_		catch (Throwable ex) {_			logger.error("Failed to parse WebSocket message to STOMP frame(s)", ex)__			sendErrorMessage(session, ex)__			return__		}__		for (Message<byte[]> message : messages) {_			try {_				StompHeaderAccessor headers = StompHeaderAccessor.wrap(message)__				if (logger.isTraceEnabled()) {_					if (SimpMessageType.HEARTBEAT.equals(headers.getMessageType())) {_						logger.trace("Received heartbeat from client session=" + session.getId())__					}_					else {_						logger.trace("Received message from client session=" + session.getId())__					}_				}__				headers.setSessionId(session.getId())__				headers.setSessionAttributes(session.getAttributes())__				headers.setUser(session.getPrincipal())___				message = MessageBuilder.withPayload(message.getPayload()).setHeaders(headers).build()___				if (SimpMessageType.CONNECT.equals(headers.getMessageType()) && this.eventPublisher != null) {_					this.eventPublisher.publishEvent(new SessionConnectEvent(this, message))__				}__				outputChannel.send(message)__			}_			catch (Throwable ex) {_				logger.error("Terminating STOMP session due to failure to send message", ex)__				sendErrorMessage(session, ex)__			}_		}_	};handle,incoming,web,socket,messages,from,clients;public,void,handle,message,from,client,web,socket,session,session,web,socket,message,web,socket,message,message,channel,output,channel,list,message,byte,messages,null,try,assert,is,instance,of,text,message,class,web,socket,message,text,message,text,message,text,message,web,socket,message,byte,buffer,byte,buffer,byte,buffer,wrap,text,message,as,bytes,buffering,stomp,decoder,decoder,this,decoders,get,session,get,id,if,decoder,null,throw,new,illegal,state,exception,no,decoder,for,session,id,session,get,id,messages,decoder,decode,byte,buffer,if,messages,is,empty,logger,debug,incomplete,stomp,frame,content,received,buffered,decoder,get,buffer,size,buffer,size,limit,decoder,get,buffer,size,limit,return,catch,throwable,ex,logger,error,failed,to,parse,web,socket,message,to,stomp,frame,s,ex,send,error,message,session,ex,return,for,message,byte,message,messages,try,stomp,header,accessor,headers,stomp,header,accessor,wrap,message,if,logger,is,trace,enabled,if,simp,message,type,heartbeat,equals,headers,get,message,type,logger,trace,received,heartbeat,from,client,session,session,get,id,else,logger,trace,received,message,from,client,session,session,get,id,headers,set,session,id,session,get,id,headers,set,session,attributes,session,get,attributes,headers,set,user,session,get,principal,message,message,builder,with,payload,message,get,payload,set,headers,headers,build,if,simp,message,type,connect,equals,headers,get,message,type,this,event,publisher,null,this,event,publisher,publish,event,new,session,connect,event,this,message,output,channel,send,message,catch,throwable,ex,logger,error,terminating,stomp,session,due,to,failure,to,send,message,ex,send,error,message,session,ex
StompSubProtocolHandler -> public void handleMessageFromClient(WebSocketSession session, 			WebSocketMessage<?> webSocketMessage, MessageChannel outputChannel);1395721625;Handle incoming WebSocket messages from clients.;public void handleMessageFromClient(WebSocketSession session,_			WebSocketMessage<?> webSocketMessage, MessageChannel outputChannel) {__		List<Message<byte[]>> messages = null__		try {_			Assert.isInstanceOf(TextMessage.class,  webSocketMessage)__			TextMessage textMessage = (TextMessage) webSocketMessage__			ByteBuffer byteBuffer = ByteBuffer.wrap(textMessage.asBytes())___			BufferingStompDecoder decoder = this.decoders.get(session.getId())__			if (decoder == null) {_				throw new IllegalStateException("No decoder for session id '" + session.getId() + "'")__			}__			messages = decoder.decode(byteBuffer)__			if (messages.isEmpty()) {_				logger.debug("Incomplete STOMP frame content received," + "buffered=" +_						decoder.getBufferSize() + ", buffer size limit=" + decoder.getBufferSizeLimit())__				return__			}_		}_		catch (Throwable ex) {_			logger.error("Failed to parse WebSocket message to STOMP frame(s)", ex)__			sendErrorMessage(session, ex)__			return__		}__		for (Message<byte[]> message : messages) {_			try {_				StompHeaderAccessor headers = StompHeaderAccessor.wrap(message)__				if (logger.isTraceEnabled()) {_					if (SimpMessageType.HEARTBEAT.equals(headers.getMessageType())) {_						logger.trace("Received heartbeat from client session=" + session.getId())__					}_					else {_						logger.trace("Received message from client session=" + session.getId())__					}_				}__				headers.setSessionId(session.getId())__				headers.setSessionAttributes(session.getAttributes())__				headers.setUser(session.getPrincipal())___				message = MessageBuilder.withPayload(message.getPayload()).setHeaders(headers).build()___				if (SimpMessageType.CONNECT.equals(headers.getMessageType()) && this.eventPublisher != null) {_					this.eventPublisher.publishEvent(new SessionConnectEvent(this, message))__				}__				outputChannel.send(message)__			}_			catch (Throwable ex) {_				logger.error("Terminating STOMP session due to failure to send message", ex)__				sendErrorMessage(session, ex)__			}_		}_	};handle,incoming,web,socket,messages,from,clients;public,void,handle,message,from,client,web,socket,session,session,web,socket,message,web,socket,message,message,channel,output,channel,list,message,byte,messages,null,try,assert,is,instance,of,text,message,class,web,socket,message,text,message,text,message,text,message,web,socket,message,byte,buffer,byte,buffer,byte,buffer,wrap,text,message,as,bytes,buffering,stomp,decoder,decoder,this,decoders,get,session,get,id,if,decoder,null,throw,new,illegal,state,exception,no,decoder,for,session,id,session,get,id,messages,decoder,decode,byte,buffer,if,messages,is,empty,logger,debug,incomplete,stomp,frame,content,received,buffered,decoder,get,buffer,size,buffer,size,limit,decoder,get,buffer,size,limit,return,catch,throwable,ex,logger,error,failed,to,parse,web,socket,message,to,stomp,frame,s,ex,send,error,message,session,ex,return,for,message,byte,message,messages,try,stomp,header,accessor,headers,stomp,header,accessor,wrap,message,if,logger,is,trace,enabled,if,simp,message,type,heartbeat,equals,headers,get,message,type,logger,trace,received,heartbeat,from,client,session,session,get,id,else,logger,trace,received,message,from,client,session,session,get,id,headers,set,session,id,session,get,id,headers,set,session,attributes,session,get,attributes,headers,set,user,session,get,principal,message,message,builder,with,payload,message,get,payload,set,headers,headers,build,if,simp,message,type,connect,equals,headers,get,message,type,this,event,publisher,null,this,event,publisher,publish,event,new,session,connect,event,this,message,output,channel,send,message,catch,throwable,ex,logger,error,terminating,stomp,session,due,to,failure,to,send,message,ex,send,error,message,session,ex
StompSubProtocolHandler -> public void handleMessageFromClient(WebSocketSession session, 			WebSocketMessage<?> webSocketMessage, MessageChannel outputChannel);1395752742;Handle incoming WebSocket messages from clients.;public void handleMessageFromClient(WebSocketSession session,_			WebSocketMessage<?> webSocketMessage, MessageChannel outputChannel) {__		List<Message<byte[]>> messages = null__		try {_			Assert.isInstanceOf(TextMessage.class,  webSocketMessage)__			TextMessage textMessage = (TextMessage) webSocketMessage__			ByteBuffer byteBuffer = ByteBuffer.wrap(textMessage.asBytes())___			BufferingStompDecoder decoder = this.decoders.get(session.getId())__			if (decoder == null) {_				throw new IllegalStateException("No decoder for session id '" + session.getId() + "'")__			}__			messages = decoder.decode(byteBuffer)__			if (messages.isEmpty()) {_				logger.debug("Incomplete STOMP frame content received," + "buffered=" +_						decoder.getBufferSize() + ", buffer size limit=" + decoder.getBufferSizeLimit())__				return__			}_		}_		catch (Throwable ex) {_			logger.error("Failed to parse WebSocket message to STOMP frame(s)", ex)__			sendErrorMessage(session, ex)__			return__		}__		for (Message<byte[]> message : messages) {_			try {_				StompHeaderAccessor headers = StompHeaderAccessor.wrap(message)__				if (logger.isTraceEnabled()) {_					if (SimpMessageType.HEARTBEAT.equals(headers.getMessageType())) {_						logger.trace("Received heartbeat from client session=" + session.getId())__					}_					else {_						logger.trace("Received message from client session=" + session.getId())__					}_				}__				headers.setSessionId(session.getId())__				headers.setSessionAttributes(session.getAttributes())__				headers.setUser(session.getPrincipal())___				message = MessageBuilder.withPayload(message.getPayload()).setHeaders(headers).build()___				if (this.eventPublisher != null && StompCommand.CONNECT.equals(headers.getMessageType())) {_					publishEvent(new SessionConnectEvent(this, message))__				}__				outputChannel.send(message)__			}_			catch (Throwable ex) {_				logger.error("Terminating STOMP session due to failure to send message", ex)__				sendErrorMessage(session, ex)__			}_		}_	};handle,incoming,web,socket,messages,from,clients;public,void,handle,message,from,client,web,socket,session,session,web,socket,message,web,socket,message,message,channel,output,channel,list,message,byte,messages,null,try,assert,is,instance,of,text,message,class,web,socket,message,text,message,text,message,text,message,web,socket,message,byte,buffer,byte,buffer,byte,buffer,wrap,text,message,as,bytes,buffering,stomp,decoder,decoder,this,decoders,get,session,get,id,if,decoder,null,throw,new,illegal,state,exception,no,decoder,for,session,id,session,get,id,messages,decoder,decode,byte,buffer,if,messages,is,empty,logger,debug,incomplete,stomp,frame,content,received,buffered,decoder,get,buffer,size,buffer,size,limit,decoder,get,buffer,size,limit,return,catch,throwable,ex,logger,error,failed,to,parse,web,socket,message,to,stomp,frame,s,ex,send,error,message,session,ex,return,for,message,byte,message,messages,try,stomp,header,accessor,headers,stomp,header,accessor,wrap,message,if,logger,is,trace,enabled,if,simp,message,type,heartbeat,equals,headers,get,message,type,logger,trace,received,heartbeat,from,client,session,session,get,id,else,logger,trace,received,message,from,client,session,session,get,id,headers,set,session,id,session,get,id,headers,set,session,attributes,session,get,attributes,headers,set,user,session,get,principal,message,message,builder,with,payload,message,get,payload,set,headers,headers,build,if,this,event,publisher,null,stomp,command,connect,equals,headers,get,message,type,publish,event,new,session,connect,event,this,message,output,channel,send,message,catch,throwable,ex,logger,error,terminating,stomp,session,due,to,failure,to,send,message,ex,send,error,message,session,ex
StompSubProtocolHandler -> public void handleMessageFromClient(WebSocketSession session, 			WebSocketMessage<?> webSocketMessage, MessageChannel outputChannel);1395755949;Handle incoming WebSocket messages from clients.;public void handleMessageFromClient(WebSocketSession session,_			WebSocketMessage<?> webSocketMessage, MessageChannel outputChannel) {__		List<Message<byte[]>> messages = null__		try {_			Assert.isInstanceOf(TextMessage.class,  webSocketMessage)__			TextMessage textMessage = (TextMessage) webSocketMessage__			ByteBuffer byteBuffer = ByteBuffer.wrap(textMessage.asBytes())___			BufferingStompDecoder decoder = this.decoders.get(session.getId())__			if (decoder == null) {_				throw new IllegalStateException("No decoder for session id '" + session.getId() + "'")__			}__			messages = decoder.decode(byteBuffer)__			if (messages.isEmpty()) {_				logger.debug("Incomplete STOMP frame content received," + "buffered=" +_						decoder.getBufferSize() + ", buffer size limit=" + decoder.getBufferSizeLimit())__				return__			}_		}_		catch (Throwable ex) {_			logger.error("Failed to parse WebSocket message to STOMP frame(s)", ex)__			sendErrorMessage(session, ex)__			return__		}__		for (Message<byte[]> message : messages) {_			try {_				StompHeaderAccessor headers = StompHeaderAccessor.wrap(message)__				if (logger.isTraceEnabled()) {_					if (SimpMessageType.HEARTBEAT.equals(headers.getMessageType())) {_						logger.trace("Received heartbeat from client session=" + session.getId())__					}_					else {_						logger.trace("Received message from client session=" + session.getId())__					}_				}__				headers.setSessionId(session.getId())__				headers.setSessionAttributes(session.getAttributes())__				headers.setUser(session.getPrincipal())___				message = MessageBuilder.withPayload(message.getPayload()).setHeaders(headers).build()___				if (this.eventPublisher != null && StompCommand.CONNECT.equals(headers.getCommand())) {_					publishEvent(new SessionConnectEvent(this, message))__				}__				outputChannel.send(message)__			}_			catch (Throwable ex) {_				logger.error("Terminating STOMP session due to failure to send message", ex)__				sendErrorMessage(session, ex)__			}_		}_	};handle,incoming,web,socket,messages,from,clients;public,void,handle,message,from,client,web,socket,session,session,web,socket,message,web,socket,message,message,channel,output,channel,list,message,byte,messages,null,try,assert,is,instance,of,text,message,class,web,socket,message,text,message,text,message,text,message,web,socket,message,byte,buffer,byte,buffer,byte,buffer,wrap,text,message,as,bytes,buffering,stomp,decoder,decoder,this,decoders,get,session,get,id,if,decoder,null,throw,new,illegal,state,exception,no,decoder,for,session,id,session,get,id,messages,decoder,decode,byte,buffer,if,messages,is,empty,logger,debug,incomplete,stomp,frame,content,received,buffered,decoder,get,buffer,size,buffer,size,limit,decoder,get,buffer,size,limit,return,catch,throwable,ex,logger,error,failed,to,parse,web,socket,message,to,stomp,frame,s,ex,send,error,message,session,ex,return,for,message,byte,message,messages,try,stomp,header,accessor,headers,stomp,header,accessor,wrap,message,if,logger,is,trace,enabled,if,simp,message,type,heartbeat,equals,headers,get,message,type,logger,trace,received,heartbeat,from,client,session,session,get,id,else,logger,trace,received,message,from,client,session,session,get,id,headers,set,session,id,session,get,id,headers,set,session,attributes,session,get,attributes,headers,set,user,session,get,principal,message,message,builder,with,payload,message,get,payload,set,headers,headers,build,if,this,event,publisher,null,stomp,command,connect,equals,headers,get,command,publish,event,new,session,connect,event,this,message,output,channel,send,message,catch,throwable,ex,logger,error,terminating,stomp,session,due,to,failure,to,send,message,ex,send,error,message,session,ex
StompSubProtocolHandler -> public void handleMessageFromClient(WebSocketSession session, 			WebSocketMessage<?> webSocketMessage, MessageChannel outputChannel);1395847954;Handle incoming WebSocket messages from clients.;public void handleMessageFromClient(WebSocketSession session,_			WebSocketMessage<?> webSocketMessage, MessageChannel outputChannel) {__		List<Message<byte[]>> messages = null__		try {_			Assert.isInstanceOf(TextMessage.class,  webSocketMessage)__			TextMessage textMessage = (TextMessage) webSocketMessage__			ByteBuffer byteBuffer = ByteBuffer.wrap(textMessage.asBytes())___			BufferingStompDecoder decoder = this.decoders.get(session.getId())__			if (decoder == null) {_				throw new IllegalStateException("No decoder for session id '" + session.getId() + "'")__			}__			messages = decoder.decode(byteBuffer)__			if (messages.isEmpty()) {_				logger.debug("Incomplete STOMP frame content received," + "buffered=" +_						decoder.getBufferSize() + ", buffer size limit=" + decoder.getBufferSizeLimit())__				return__			}_		}_		catch (Throwable ex) {_			logger.error("Failed to parse WebSocket message to STOMP frame(s)", ex)__			sendErrorMessage(session, ex)__			return__		}__		for (Message<byte[]> message : messages) {_			try {_				StompHeaderAccessor headers = StompHeaderAccessor.wrap(message)__				if (logger.isTraceEnabled()) {_					if (SimpMessageType.HEARTBEAT.equals(headers.getMessageType())) {_						logger.trace("Received heartbeat from client session=" + session.getId())__					}_					else {_						logger.trace("Received message from client session=" + session.getId())__					}_				}__				headers.setSessionId(session.getId())__				headers.setSessionAttributes(session.getAttributes())__				headers.setUser(session.getPrincipal())___				message = MessageBuilder.withPayload(message.getPayload()).setHeaders(headers).build()___				if (this.eventPublisher != null && StompCommand.CONNECT.equals(headers.getCommand())) {_					publishEvent(new SessionConnectEvent(this, message))__				}__				outputChannel.send(message)__			}_			catch (Throwable ex) {_				logger.error("Terminating STOMP session due to failure to send message", ex)__				sendErrorMessage(session, ex)__			}_		}_	};handle,incoming,web,socket,messages,from,clients;public,void,handle,message,from,client,web,socket,session,session,web,socket,message,web,socket,message,message,channel,output,channel,list,message,byte,messages,null,try,assert,is,instance,of,text,message,class,web,socket,message,text,message,text,message,text,message,web,socket,message,byte,buffer,byte,buffer,byte,buffer,wrap,text,message,as,bytes,buffering,stomp,decoder,decoder,this,decoders,get,session,get,id,if,decoder,null,throw,new,illegal,state,exception,no,decoder,for,session,id,session,get,id,messages,decoder,decode,byte,buffer,if,messages,is,empty,logger,debug,incomplete,stomp,frame,content,received,buffered,decoder,get,buffer,size,buffer,size,limit,decoder,get,buffer,size,limit,return,catch,throwable,ex,logger,error,failed,to,parse,web,socket,message,to,stomp,frame,s,ex,send,error,message,session,ex,return,for,message,byte,message,messages,try,stomp,header,accessor,headers,stomp,header,accessor,wrap,message,if,logger,is,trace,enabled,if,simp,message,type,heartbeat,equals,headers,get,message,type,logger,trace,received,heartbeat,from,client,session,session,get,id,else,logger,trace,received,message,from,client,session,session,get,id,headers,set,session,id,session,get,id,headers,set,session,attributes,session,get,attributes,headers,set,user,session,get,principal,message,message,builder,with,payload,message,get,payload,set,headers,headers,build,if,this,event,publisher,null,stomp,command,connect,equals,headers,get,command,publish,event,new,session,connect,event,this,message,output,channel,send,message,catch,throwable,ex,logger,error,terminating,stomp,session,due,to,failure,to,send,message,ex,send,error,message,session,ex
StompSubProtocolHandler -> public void handleMessageFromClient(WebSocketSession session, 			WebSocketMessage<?> webSocketMessage, MessageChannel outputChannel);1396578670;Handle incoming WebSocket messages from clients.;public void handleMessageFromClient(WebSocketSession session,_			WebSocketMessage<?> webSocketMessage, MessageChannel outputChannel) {__		List<Message<byte[]>> messages = null__		try {_			Assert.isInstanceOf(TextMessage.class,  webSocketMessage)__			TextMessage textMessage = (TextMessage) webSocketMessage__			ByteBuffer byteBuffer = ByteBuffer.wrap(textMessage.asBytes())___			BufferingStompDecoder decoder = this.decoders.get(session.getId())__			if (decoder == null) {_				throw new IllegalStateException("No decoder for session id '" + session.getId() + "'")__			}__			messages = decoder.decode(byteBuffer)__			if (messages.isEmpty()) {_				logger.debug("Incomplete STOMP frame content received," + "buffered=" +_						decoder.getBufferSize() + ", buffer size limit=" + decoder.getBufferSizeLimit())__				return__			}_		}_		catch (Throwable ex) {_			logger.error("Failed to parse WebSocket message to STOMP frame(s)", ex)__			sendErrorMessage(session, ex)__			return__		}__		for (Message<byte[]> message : messages) {_			try {_				StompHeaderAccessor headers = StompHeaderAccessor.wrap(message)__				if (logger.isTraceEnabled()) {_					if (SimpMessageType.HEARTBEAT.equals(headers.getMessageType())) {_						logger.trace("Received heartbeat from client session=" + session.getId())__					}_					else {_						logger.trace("Received message from client session=" + session.getId())__					}_				}__				headers.setSessionId(session.getId())__				headers.setSessionAttributes(session.getAttributes())__				headers.setUser(session.getPrincipal())___				message = MessageBuilder.withPayload(message.getPayload()).setHeaders(headers).build()___				if (this.eventPublisher != null && StompCommand.CONNECT.equals(headers.getCommand())) {_					publishEvent(new SessionConnectEvent(this, message))__				}__				outputChannel.send(message)__			}_			catch (Throwable ex) {_				logger.error("Terminating STOMP session due to failure to send message", ex)__				sendErrorMessage(session, ex)__			}_		}_	};handle,incoming,web,socket,messages,from,clients;public,void,handle,message,from,client,web,socket,session,session,web,socket,message,web,socket,message,message,channel,output,channel,list,message,byte,messages,null,try,assert,is,instance,of,text,message,class,web,socket,message,text,message,text,message,text,message,web,socket,message,byte,buffer,byte,buffer,byte,buffer,wrap,text,message,as,bytes,buffering,stomp,decoder,decoder,this,decoders,get,session,get,id,if,decoder,null,throw,new,illegal,state,exception,no,decoder,for,session,id,session,get,id,messages,decoder,decode,byte,buffer,if,messages,is,empty,logger,debug,incomplete,stomp,frame,content,received,buffered,decoder,get,buffer,size,buffer,size,limit,decoder,get,buffer,size,limit,return,catch,throwable,ex,logger,error,failed,to,parse,web,socket,message,to,stomp,frame,s,ex,send,error,message,session,ex,return,for,message,byte,message,messages,try,stomp,header,accessor,headers,stomp,header,accessor,wrap,message,if,logger,is,trace,enabled,if,simp,message,type,heartbeat,equals,headers,get,message,type,logger,trace,received,heartbeat,from,client,session,session,get,id,else,logger,trace,received,message,from,client,session,session,get,id,headers,set,session,id,session,get,id,headers,set,session,attributes,session,get,attributes,headers,set,user,session,get,principal,message,message,builder,with,payload,message,get,payload,set,headers,headers,build,if,this,event,publisher,null,stomp,command,connect,equals,headers,get,command,publish,event,new,session,connect,event,this,message,output,channel,send,message,catch,throwable,ex,logger,error,terminating,stomp,session,due,to,failure,to,send,message,ex,send,error,message,session,ex
StompSubProtocolHandler -> public void handleMessageFromClient(WebSocketSession session, 			WebSocketMessage<?> webSocketMessage, MessageChannel outputChannel);1396636309;Handle incoming WebSocket messages from clients.;public void handleMessageFromClient(WebSocketSession session,_			WebSocketMessage<?> webSocketMessage, MessageChannel outputChannel) {__		List<Message<byte[]>> messages = null__		try {_			Assert.isInstanceOf(TextMessage.class,  webSocketMessage)__			TextMessage textMessage = (TextMessage) webSocketMessage__			ByteBuffer byteBuffer = ByteBuffer.wrap(textMessage.asBytes())___			BufferingStompDecoder decoder = this.decoders.get(session.getId())__			if (decoder == null) {_				throw new IllegalStateException("No decoder for session id '" + session.getId() + "'")__			}__			messages = decoder.decode(byteBuffer)__			if (messages.isEmpty()) {_				logger.debug("Incomplete STOMP frame content received," + "buffered=" +_						decoder.getBufferSize() + ", buffer size limit=" + decoder.getBufferSizeLimit())__				return__			}_		}_		catch (Throwable ex) {_			logger.error("Failed to parse WebSocket message to STOMP frame(s)", ex)__			sendErrorMessage(session, ex)__			return__		}__		for (Message<byte[]> message : messages) {_			try {_				StompHeaderAccessor headers = StompHeaderAccessor.wrap(message)__				if (logger.isTraceEnabled()) {_					if (SimpMessageType.HEARTBEAT.equals(headers.getMessageType())) {_						logger.trace("Received heartbeat from client session=" + session.getId())__					}_					else {_						logger.trace("Received message from client session=" + session.getId())__					}_				}__				headers.setSessionId(session.getId())__				headers.setSessionAttributes(session.getAttributes())__				headers.setUser(session.getPrincipal())___				message = MessageBuilder.withPayload(message.getPayload()).setHeaders(headers).build()___				if (this.eventPublisher != null && StompCommand.CONNECT.equals(headers.getCommand())) {_					publishEvent(new SessionConnectEvent(this, message))__				}__				outputChannel.send(message)__			}_			catch (Throwable ex) {_				logger.error("Terminating STOMP session due to failure to send message", ex)__				sendErrorMessage(session, ex)__			}_		}_	};handle,incoming,web,socket,messages,from,clients;public,void,handle,message,from,client,web,socket,session,session,web,socket,message,web,socket,message,message,channel,output,channel,list,message,byte,messages,null,try,assert,is,instance,of,text,message,class,web,socket,message,text,message,text,message,text,message,web,socket,message,byte,buffer,byte,buffer,byte,buffer,wrap,text,message,as,bytes,buffering,stomp,decoder,decoder,this,decoders,get,session,get,id,if,decoder,null,throw,new,illegal,state,exception,no,decoder,for,session,id,session,get,id,messages,decoder,decode,byte,buffer,if,messages,is,empty,logger,debug,incomplete,stomp,frame,content,received,buffered,decoder,get,buffer,size,buffer,size,limit,decoder,get,buffer,size,limit,return,catch,throwable,ex,logger,error,failed,to,parse,web,socket,message,to,stomp,frame,s,ex,send,error,message,session,ex,return,for,message,byte,message,messages,try,stomp,header,accessor,headers,stomp,header,accessor,wrap,message,if,logger,is,trace,enabled,if,simp,message,type,heartbeat,equals,headers,get,message,type,logger,trace,received,heartbeat,from,client,session,session,get,id,else,logger,trace,received,message,from,client,session,session,get,id,headers,set,session,id,session,get,id,headers,set,session,attributes,session,get,attributes,headers,set,user,session,get,principal,message,message,builder,with,payload,message,get,payload,set,headers,headers,build,if,this,event,publisher,null,stomp,command,connect,equals,headers,get,command,publish,event,new,session,connect,event,this,message,output,channel,send,message,catch,throwable,ex,logger,error,terminating,stomp,session,due,to,failure,to,send,message,ex,send,error,message,session,ex
StompSubProtocolHandler -> public void handleMessageFromClient(WebSocketSession session, 			WebSocketMessage<?> webSocketMessage, MessageChannel outputChannel);1397429525;Handle incoming WebSocket messages from clients.;public void handleMessageFromClient(WebSocketSession session,_			WebSocketMessage<?> webSocketMessage, MessageChannel outputChannel) {__		List<Message<byte[]>> messages = null__		try {_			Assert.isInstanceOf(TextMessage.class,  webSocketMessage)__			TextMessage textMessage = (TextMessage) webSocketMessage__			ByteBuffer byteBuffer = ByteBuffer.wrap(textMessage.asBytes())___			BufferingStompDecoder decoder = this.decoders.get(session.getId())__			if (decoder == null) {_				throw new IllegalStateException("No decoder for session id '" + session.getId() + "'")__			}__			messages = decoder.decode(byteBuffer)__			if (messages.isEmpty()) {_				logger.debug("Incomplete STOMP frame content received," + "buffered=" +_						decoder.getBufferSize() + ", buffer size limit=" + decoder.getBufferSizeLimit())__				return__			}_		}_		catch (Throwable ex) {_			logger.error("Failed to parse WebSocket message to STOMP frame(s)", ex)__			sendErrorMessage(session, ex)__			return__		}__		for (Message<byte[]> message : messages) {_			try {__				StompHeaderAccessor headerAccessor =_						MessageHeaderAccessor.getAccessor(message, StompHeaderAccessor.class)___				if (logger.isTraceEnabled()) {_					if (headerAccessor.isHeartbeat()) {_						logger.trace("Received heartbeat from client session=" + session.getId())__					}_					else {_						logger.trace("Received message from client session=" + session.getId())__					}_				}__				headerAccessor.setSessionId(session.getId())__				headerAccessor.setSessionAttributes(session.getAttributes())__				headerAccessor.setUser(session.getPrincipal())__				headerAccessor.setImmutable()___				if (this.eventPublisher != null && StompCommand.CONNECT.equals(headerAccessor.getCommand())) {_					publishEvent(new SessionConnectEvent(this, message))__				}__				outputChannel.send(message)__			}_			catch (Throwable ex) {_				logger.error("Terminating STOMP session due to failure to send message", ex)__				sendErrorMessage(session, ex)__			}_		}_	};handle,incoming,web,socket,messages,from,clients;public,void,handle,message,from,client,web,socket,session,session,web,socket,message,web,socket,message,message,channel,output,channel,list,message,byte,messages,null,try,assert,is,instance,of,text,message,class,web,socket,message,text,message,text,message,text,message,web,socket,message,byte,buffer,byte,buffer,byte,buffer,wrap,text,message,as,bytes,buffering,stomp,decoder,decoder,this,decoders,get,session,get,id,if,decoder,null,throw,new,illegal,state,exception,no,decoder,for,session,id,session,get,id,messages,decoder,decode,byte,buffer,if,messages,is,empty,logger,debug,incomplete,stomp,frame,content,received,buffered,decoder,get,buffer,size,buffer,size,limit,decoder,get,buffer,size,limit,return,catch,throwable,ex,logger,error,failed,to,parse,web,socket,message,to,stomp,frame,s,ex,send,error,message,session,ex,return,for,message,byte,message,messages,try,stomp,header,accessor,header,accessor,message,header,accessor,get,accessor,message,stomp,header,accessor,class,if,logger,is,trace,enabled,if,header,accessor,is,heartbeat,logger,trace,received,heartbeat,from,client,session,session,get,id,else,logger,trace,received,message,from,client,session,session,get,id,header,accessor,set,session,id,session,get,id,header,accessor,set,session,attributes,session,get,attributes,header,accessor,set,user,session,get,principal,header,accessor,set,immutable,if,this,event,publisher,null,stomp,command,connect,equals,header,accessor,get,command,publish,event,new,session,connect,event,this,message,output,channel,send,message,catch,throwable,ex,logger,error,terminating,stomp,session,due,to,failure,to,send,message,ex,send,error,message,session,ex
StompSubProtocolHandler -> public void handleMessageFromClient(WebSocketSession session, 			WebSocketMessage<?> webSocketMessage, MessageChannel outputChannel);1397439322;Handle incoming WebSocket messages from clients.;public void handleMessageFromClient(WebSocketSession session,_			WebSocketMessage<?> webSocketMessage, MessageChannel outputChannel) {__		List<Message<byte[]>> messages__		try {_			Assert.isInstanceOf(TextMessage.class,  webSocketMessage)__			TextMessage textMessage = (TextMessage) webSocketMessage__			ByteBuffer byteBuffer = ByteBuffer.wrap(textMessage.asBytes())___			BufferingStompDecoder decoder = this.decoders.get(session.getId())__			if (decoder == null) {_				throw new IllegalStateException("No decoder for session id '" + session.getId() + "'")__			}__			messages = decoder.decode(byteBuffer)__			if (messages.isEmpty()) {_				logger.debug("Incomplete STOMP frame content received," + "buffered=" +_						decoder.getBufferSize() + ", buffer size limit=" + decoder.getBufferSizeLimit())__				return__			}_		}_		catch (Throwable ex) {_			logger.error("Failed to parse WebSocket message to STOMP frame(s)", ex)__			sendErrorMessage(session, ex)__			return__		}__		for (Message<byte[]> message : messages) {_			try {__				StompHeaderAccessor headerAccessor =_						MessageHeaderAccessor.getAccessor(message, StompHeaderAccessor.class)___				if (logger.isTraceEnabled()) {_					if (headerAccessor.isHeartbeat()) {_						logger.trace("Received heartbeat from client session=" + session.getId())__					}_					else {_						logger.trace("Received message from client session=" + session.getId())__					}_				}__				headerAccessor.setSessionId(session.getId())__				headerAccessor.setSessionAttributes(session.getAttributes())__				headerAccessor.setUser(session.getPrincipal())__				headerAccessor.setImmutable()___				if (this.eventPublisher != null && StompCommand.CONNECT.equals(headerAccessor.getCommand())) {_					publishEvent(new SessionConnectEvent(this, message))__				}__				outputChannel.send(message)__			}_			catch (Throwable ex) {_				logger.error("Terminating STOMP session due to failure to send message", ex)__				sendErrorMessage(session, ex)__			}_		}_	};handle,incoming,web,socket,messages,from,clients;public,void,handle,message,from,client,web,socket,session,session,web,socket,message,web,socket,message,message,channel,output,channel,list,message,byte,messages,try,assert,is,instance,of,text,message,class,web,socket,message,text,message,text,message,text,message,web,socket,message,byte,buffer,byte,buffer,byte,buffer,wrap,text,message,as,bytes,buffering,stomp,decoder,decoder,this,decoders,get,session,get,id,if,decoder,null,throw,new,illegal,state,exception,no,decoder,for,session,id,session,get,id,messages,decoder,decode,byte,buffer,if,messages,is,empty,logger,debug,incomplete,stomp,frame,content,received,buffered,decoder,get,buffer,size,buffer,size,limit,decoder,get,buffer,size,limit,return,catch,throwable,ex,logger,error,failed,to,parse,web,socket,message,to,stomp,frame,s,ex,send,error,message,session,ex,return,for,message,byte,message,messages,try,stomp,header,accessor,header,accessor,message,header,accessor,get,accessor,message,stomp,header,accessor,class,if,logger,is,trace,enabled,if,header,accessor,is,heartbeat,logger,trace,received,heartbeat,from,client,session,session,get,id,else,logger,trace,received,message,from,client,session,session,get,id,header,accessor,set,session,id,session,get,id,header,accessor,set,session,attributes,session,get,attributes,header,accessor,set,user,session,get,principal,header,accessor,set,immutable,if,this,event,publisher,null,stomp,command,connect,equals,header,accessor,get,command,publish,event,new,session,connect,event,this,message,output,channel,send,message,catch,throwable,ex,logger,error,terminating,stomp,session,due,to,failure,to,send,message,ex,send,error,message,session,ex
StompSubProtocolHandler -> public void handleMessageFromClient(WebSocketSession session, 			WebSocketMessage<?> webSocketMessage, MessageChannel outputChannel);1397523793;Handle incoming WebSocket messages from clients.;public void handleMessageFromClient(WebSocketSession session,_			WebSocketMessage<?> webSocketMessage, MessageChannel outputChannel) {__		List<Message<byte[]>> messages__		try {_			Assert.isInstanceOf(TextMessage.class,  webSocketMessage)__			TextMessage textMessage = (TextMessage) webSocketMessage__			ByteBuffer byteBuffer = ByteBuffer.wrap(textMessage.asBytes())___			BufferingStompDecoder decoder = this.decoders.get(session.getId())__			if (decoder == null) {_				throw new IllegalStateException("No decoder for session id '" + session.getId() + "'")__			}__			messages = decoder.decode(byteBuffer)__			if (messages.isEmpty()) {_				logger.debug("Incomplete STOMP frame content received," + "buffered=" +_						decoder.getBufferSize() + ", buffer size limit=" + decoder.getBufferSizeLimit())__				return__			}_		}_		catch (Throwable ex) {_			logger.error("Failed to parse WebSocket message to STOMP frame(s)", ex)__			sendErrorMessage(session, ex)__			return__		}__		for (Message<byte[]> message : messages) {_			try {__				StompHeaderAccessor headerAccessor =_						MessageHeaderAccessor.getAccessor(message, StompHeaderAccessor.class)___				if (logger.isTraceEnabled()) {_					if (headerAccessor.isHeartbeat()) {_						logger.trace("Received heartbeat from client session=" + session.getId())__					}_					else {_						logger.trace("Received message from client session=" + session.getId())__					}_				}__				headerAccessor.setSessionId(session.getId())__				headerAccessor.setSessionAttributes(session.getAttributes())__				headerAccessor.setUser(session.getPrincipal())__				headerAccessor.setImmutable()___				if (this.eventPublisher != null && StompCommand.CONNECT.equals(headerAccessor.getCommand())) {_					publishEvent(new SessionConnectEvent(this, message))__				}__				outputChannel.send(message)__			}_			catch (Throwable ex) {_				logger.error("Terminating STOMP session due to failure to send message", ex)__				sendErrorMessage(session, ex)__			}_		}_	};handle,incoming,web,socket,messages,from,clients;public,void,handle,message,from,client,web,socket,session,session,web,socket,message,web,socket,message,message,channel,output,channel,list,message,byte,messages,try,assert,is,instance,of,text,message,class,web,socket,message,text,message,text,message,text,message,web,socket,message,byte,buffer,byte,buffer,byte,buffer,wrap,text,message,as,bytes,buffering,stomp,decoder,decoder,this,decoders,get,session,get,id,if,decoder,null,throw,new,illegal,state,exception,no,decoder,for,session,id,session,get,id,messages,decoder,decode,byte,buffer,if,messages,is,empty,logger,debug,incomplete,stomp,frame,content,received,buffered,decoder,get,buffer,size,buffer,size,limit,decoder,get,buffer,size,limit,return,catch,throwable,ex,logger,error,failed,to,parse,web,socket,message,to,stomp,frame,s,ex,send,error,message,session,ex,return,for,message,byte,message,messages,try,stomp,header,accessor,header,accessor,message,header,accessor,get,accessor,message,stomp,header,accessor,class,if,logger,is,trace,enabled,if,header,accessor,is,heartbeat,logger,trace,received,heartbeat,from,client,session,session,get,id,else,logger,trace,received,message,from,client,session,session,get,id,header,accessor,set,session,id,session,get,id,header,accessor,set,session,attributes,session,get,attributes,header,accessor,set,user,session,get,principal,header,accessor,set,immutable,if,this,event,publisher,null,stomp,command,connect,equals,header,accessor,get,command,publish,event,new,session,connect,event,this,message,output,channel,send,message,catch,throwable,ex,logger,error,terminating,stomp,session,due,to,failure,to,send,message,ex,send,error,message,session,ex
StompSubProtocolHandler -> public void handleMessageFromClient(WebSocketSession session, 			WebSocketMessage<?> webSocketMessage, MessageChannel outputChannel);1398443164;Handle incoming WebSocket messages from clients.;public void handleMessageFromClient(WebSocketSession session,_			WebSocketMessage<?> webSocketMessage, MessageChannel outputChannel) {__		List<Message<byte[]>> messages__		try {_			Assert.isInstanceOf(TextMessage.class,  webSocketMessage)__			TextMessage textMessage = (TextMessage) webSocketMessage__			ByteBuffer byteBuffer = ByteBuffer.wrap(textMessage.asBytes())___			BufferingStompDecoder decoder = this.decoders.get(session.getId())__			if (decoder == null) {_				throw new IllegalStateException("No decoder for session id '" + session.getId() + "'")__			}__			messages = decoder.decode(byteBuffer)__			if (messages.isEmpty()) {_				logger.debug("Incomplete STOMP frame content received," + "buffered=" +_						decoder.getBufferSize() + ", buffer size limit=" + decoder.getBufferSizeLimit())__				return__			}_		}_		catch (Throwable ex) {_			logger.error("Failed to parse WebSocket message to STOMP frame(s)", ex)__			sendErrorMessage(session, ex)__			return__		}__		for (Message<byte[]> message : messages) {_			try {__				StompHeaderAccessor headerAccessor =_						MessageHeaderAccessor.getAccessor(message, StompHeaderAccessor.class)___				if (logger.isTraceEnabled()) {_					if (headerAccessor.isHeartbeat()) {_						logger.trace("Received heartbeat from client session=" + session.getId())__					}_					else {_						logger.trace("Received message from client session=" + session.getId())__					}_				}__				headerAccessor.setSessionId(session.getId())__				headerAccessor.setSessionAttributes(session.getAttributes())__				headerAccessor.setUser(session.getPrincipal())__				headerAccessor.setImmutable()___				if (this.eventPublisher != null && StompCommand.CONNECT.equals(headerAccessor.getCommand())) {_					publishEvent(new SessionConnectEvent(this, message))__				}__				outputChannel.send(message)__			}_			catch (Throwable ex) {_				logger.error("Terminating STOMP session due to failure to send message", ex)__				sendErrorMessage(session, ex)__			}_		}_	};handle,incoming,web,socket,messages,from,clients;public,void,handle,message,from,client,web,socket,session,session,web,socket,message,web,socket,message,message,channel,output,channel,list,message,byte,messages,try,assert,is,instance,of,text,message,class,web,socket,message,text,message,text,message,text,message,web,socket,message,byte,buffer,byte,buffer,byte,buffer,wrap,text,message,as,bytes,buffering,stomp,decoder,decoder,this,decoders,get,session,get,id,if,decoder,null,throw,new,illegal,state,exception,no,decoder,for,session,id,session,get,id,messages,decoder,decode,byte,buffer,if,messages,is,empty,logger,debug,incomplete,stomp,frame,content,received,buffered,decoder,get,buffer,size,buffer,size,limit,decoder,get,buffer,size,limit,return,catch,throwable,ex,logger,error,failed,to,parse,web,socket,message,to,stomp,frame,s,ex,send,error,message,session,ex,return,for,message,byte,message,messages,try,stomp,header,accessor,header,accessor,message,header,accessor,get,accessor,message,stomp,header,accessor,class,if,logger,is,trace,enabled,if,header,accessor,is,heartbeat,logger,trace,received,heartbeat,from,client,session,session,get,id,else,logger,trace,received,message,from,client,session,session,get,id,header,accessor,set,session,id,session,get,id,header,accessor,set,session,attributes,session,get,attributes,header,accessor,set,user,session,get,principal,header,accessor,set,immutable,if,this,event,publisher,null,stomp,command,connect,equals,header,accessor,get,command,publish,event,new,session,connect,event,this,message,output,channel,send,message,catch,throwable,ex,logger,error,terminating,stomp,session,due,to,failure,to,send,message,ex,send,error,message,session,ex
StompSubProtocolHandler -> public void handleMessageFromClient(WebSocketSession session, 			WebSocketMessage<?> webSocketMessage, MessageChannel outputChannel);1399601217;Handle incoming WebSocket messages from clients.;public void handleMessageFromClient(WebSocketSession session,_			WebSocketMessage<?> webSocketMessage, MessageChannel outputChannel) {__		List<Message<byte[]>> messages__		try {_			Assert.isInstanceOf(TextMessage.class,  webSocketMessage)__			TextMessage textMessage = (TextMessage) webSocketMessage__			ByteBuffer byteBuffer = ByteBuffer.wrap(textMessage.asBytes())___			BufferingStompDecoder decoder = this.decoders.get(session.getId())__			if (decoder == null) {_				throw new IllegalStateException("No decoder for session id '" + session.getId() + "'")__			}__			messages = decoder.decode(byteBuffer)__			if (messages.isEmpty()) {_				logger.debug("Incomplete STOMP frame content received," + "buffered=" +_						decoder.getBufferSize() + ", buffer size limit=" + decoder.getBufferSizeLimit())__				return__			}_		}_		catch (Throwable ex) {_			logger.error("Failed to parse WebSocket message to STOMP frame(s)", ex)__			sendErrorMessage(session, ex)__			return__		}__		for (Message<byte[]> message : messages) {_			try {__				StompHeaderAccessor headerAccessor =_						MessageHeaderAccessor.getAccessor(message, StompHeaderAccessor.class)___				if (logger.isTraceEnabled()) {_					if (headerAccessor.isHeartbeat()) {_						logger.trace("Received heartbeat from client session=" + session.getId())__					}_					else {_						logger.trace("Received message from client session=" + session.getId())__					}_				}__				headerAccessor.setSessionId(session.getId())__				headerAccessor.setSessionAttributes(session.getAttributes())__				headerAccessor.setUser(session.getPrincipal())__				headerAccessor.setImmutable()___				if (this.eventPublisher != null && StompCommand.CONNECT.equals(headerAccessor.getCommand())) {_					publishEvent(new SessionConnectEvent(this, message))__				}__				outputChannel.send(message)__			}_			catch (Throwable ex) {_				logger.error("Terminating STOMP session due to failure to send message", ex)__				sendErrorMessage(session, ex)__			}_		}_	};handle,incoming,web,socket,messages,from,clients;public,void,handle,message,from,client,web,socket,session,session,web,socket,message,web,socket,message,message,channel,output,channel,list,message,byte,messages,try,assert,is,instance,of,text,message,class,web,socket,message,text,message,text,message,text,message,web,socket,message,byte,buffer,byte,buffer,byte,buffer,wrap,text,message,as,bytes,buffering,stomp,decoder,decoder,this,decoders,get,session,get,id,if,decoder,null,throw,new,illegal,state,exception,no,decoder,for,session,id,session,get,id,messages,decoder,decode,byte,buffer,if,messages,is,empty,logger,debug,incomplete,stomp,frame,content,received,buffered,decoder,get,buffer,size,buffer,size,limit,decoder,get,buffer,size,limit,return,catch,throwable,ex,logger,error,failed,to,parse,web,socket,message,to,stomp,frame,s,ex,send,error,message,session,ex,return,for,message,byte,message,messages,try,stomp,header,accessor,header,accessor,message,header,accessor,get,accessor,message,stomp,header,accessor,class,if,logger,is,trace,enabled,if,header,accessor,is,heartbeat,logger,trace,received,heartbeat,from,client,session,session,get,id,else,logger,trace,received,message,from,client,session,session,get,id,header,accessor,set,session,id,session,get,id,header,accessor,set,session,attributes,session,get,attributes,header,accessor,set,user,session,get,principal,header,accessor,set,immutable,if,this,event,publisher,null,stomp,command,connect,equals,header,accessor,get,command,publish,event,new,session,connect,event,this,message,output,channel,send,message,catch,throwable,ex,logger,error,terminating,stomp,session,due,to,failure,to,send,message,ex,send,error,message,session,ex
StompSubProtocolHandler -> public void handleMessageFromClient(WebSocketSession session, 			WebSocketMessage<?> webSocketMessage, MessageChannel outputChannel);1399825877;Handle incoming WebSocket messages from clients.;public void handleMessageFromClient(WebSocketSession session,_			WebSocketMessage<?> webSocketMessage, MessageChannel outputChannel) {__		List<Message<byte[]>> messages__		try {_			Assert.isInstanceOf(TextMessage.class,  webSocketMessage)__			TextMessage textMessage = (TextMessage) webSocketMessage__			ByteBuffer byteBuffer = ByteBuffer.wrap(textMessage.asBytes())___			BufferingStompDecoder decoder = this.decoders.get(session.getId())__			if (decoder == null) {_				throw new IllegalStateException("No decoder for session id '" + session.getId() + "'")__			}__			messages = decoder.decode(byteBuffer)__			if (messages.isEmpty()) {_				logger.debug("Incomplete STOMP frame content received," + "buffered=" +_						decoder.getBufferSize() + ", buffer size limit=" + decoder.getBufferSizeLimit())__				return__			}_		}_		catch (Throwable ex) {_			logger.error("Failed to parse WebSocket message to STOMP frame(s)", ex)__			sendErrorMessage(session, ex)__			return__		}__		for (Message<byte[]> message : messages) {_			try {__				StompHeaderAccessor headerAccessor =_						MessageHeaderAccessor.getAccessor(message, StompHeaderAccessor.class)___				if (logger.isTraceEnabled()) {_					if (headerAccessor.isHeartbeat()) {_						logger.trace("Received heartbeat from client session=" + session.getId())__					}_					else {_						logger.trace("Received message from client session=" + session.getId())__					}_				}__				headerAccessor.setSessionId(session.getId())__				headerAccessor.setSessionAttributes(session.getAttributes())__				headerAccessor.setUser(session.getPrincipal())__				headerAccessor.setImmutable()___				if (this.eventPublisher != null && StompCommand.CONNECT.equals(headerAccessor.getCommand())) {_					publishEvent(new SessionConnectEvent(this, message))__				}__				try {_					SimpAttributesContextHolder.setAttributesFromMessage(message)__					outputChannel.send(message)__				}_				finally {_					SimpAttributesContextHolder.resetAttributes()__				}_			}_			catch (Throwable ex) {_				logger.error("Terminating STOMP session due to failure to send message", ex)__				sendErrorMessage(session, ex)__			}_		}_	};handle,incoming,web,socket,messages,from,clients;public,void,handle,message,from,client,web,socket,session,session,web,socket,message,web,socket,message,message,channel,output,channel,list,message,byte,messages,try,assert,is,instance,of,text,message,class,web,socket,message,text,message,text,message,text,message,web,socket,message,byte,buffer,byte,buffer,byte,buffer,wrap,text,message,as,bytes,buffering,stomp,decoder,decoder,this,decoders,get,session,get,id,if,decoder,null,throw,new,illegal,state,exception,no,decoder,for,session,id,session,get,id,messages,decoder,decode,byte,buffer,if,messages,is,empty,logger,debug,incomplete,stomp,frame,content,received,buffered,decoder,get,buffer,size,buffer,size,limit,decoder,get,buffer,size,limit,return,catch,throwable,ex,logger,error,failed,to,parse,web,socket,message,to,stomp,frame,s,ex,send,error,message,session,ex,return,for,message,byte,message,messages,try,stomp,header,accessor,header,accessor,message,header,accessor,get,accessor,message,stomp,header,accessor,class,if,logger,is,trace,enabled,if,header,accessor,is,heartbeat,logger,trace,received,heartbeat,from,client,session,session,get,id,else,logger,trace,received,message,from,client,session,session,get,id,header,accessor,set,session,id,session,get,id,header,accessor,set,session,attributes,session,get,attributes,header,accessor,set,user,session,get,principal,header,accessor,set,immutable,if,this,event,publisher,null,stomp,command,connect,equals,header,accessor,get,command,publish,event,new,session,connect,event,this,message,try,simp,attributes,context,holder,set,attributes,from,message,message,output,channel,send,message,finally,simp,attributes,context,holder,reset,attributes,catch,throwable,ex,logger,error,terminating,stomp,session,due,to,failure,to,send,message,ex,send,error,message,session,ex
StompSubProtocolHandler -> public void handleMessageFromClient(WebSocketSession session, 			WebSocketMessage<?> webSocketMessage, MessageChannel outputChannel);1403719829;Handle incoming WebSocket messages from clients.;public void handleMessageFromClient(WebSocketSession session,_			WebSocketMessage<?> webSocketMessage, MessageChannel outputChannel) {__		List<Message<byte[]>> messages__		try {_			Assert.isInstanceOf(TextMessage.class,  webSocketMessage)__			TextMessage textMessage = (TextMessage) webSocketMessage__			ByteBuffer byteBuffer = ByteBuffer.wrap(textMessage.asBytes())___			BufferingStompDecoder decoder = this.decoders.get(session.getId())__			if (decoder == null) {_				throw new IllegalStateException("No decoder for session id '" + session.getId() + "'")__			}__			messages = decoder.decode(byteBuffer)__			if (messages.isEmpty()) {_				logger.debug("Incomplete STOMP frame content received," + "buffered=" +_						decoder.getBufferSize() + ", buffer size limit=" + decoder.getBufferSizeLimit())__				return__			}_		}_		catch (Throwable ex) {_			logger.error("Failed to parse WebSocket message to STOMP." +_					"Sending STOMP ERROR to client, sessionId=" + session.getId(), ex)__			sendErrorMessage(session, ex)__			return__		}__		for (Message<byte[]> message : messages) {_			try {__				StompHeaderAccessor headerAccessor =_						MessageHeaderAccessor.getAccessor(message, StompHeaderAccessor.class)___				if (logger.isTraceEnabled()) {_					if (headerAccessor.isHeartbeat()) {_						logger.trace("Received heartbeat from client session=" + session.getId())__					}_					else {_						logger.trace("Received message from client session=" + session.getId())__					}_				}__				headerAccessor.setSessionId(session.getId())__				headerAccessor.setSessionAttributes(session.getAttributes())__				headerAccessor.setUser(session.getPrincipal())__				headerAccessor.setImmutable()___				if (this.eventPublisher != null && StompCommand.CONNECT.equals(headerAccessor.getCommand())) {_					publishEvent(new SessionConnectEvent(this, message))__				}__				try {_					SimpAttributesContextHolder.setAttributesFromMessage(message)__					outputChannel.send(message)__				}_				finally {_					SimpAttributesContextHolder.resetAttributes()__				}_			}_			catch (Throwable ex) {_				logger.error("Parsed STOMP message but could not send it to to message channel. " +_						"Sending STOMP ERROR to client, sessionId=" + session.getId(), ex)__				sendErrorMessage(session, ex)__			}_		}_	};handle,incoming,web,socket,messages,from,clients;public,void,handle,message,from,client,web,socket,session,session,web,socket,message,web,socket,message,message,channel,output,channel,list,message,byte,messages,try,assert,is,instance,of,text,message,class,web,socket,message,text,message,text,message,text,message,web,socket,message,byte,buffer,byte,buffer,byte,buffer,wrap,text,message,as,bytes,buffering,stomp,decoder,decoder,this,decoders,get,session,get,id,if,decoder,null,throw,new,illegal,state,exception,no,decoder,for,session,id,session,get,id,messages,decoder,decode,byte,buffer,if,messages,is,empty,logger,debug,incomplete,stomp,frame,content,received,buffered,decoder,get,buffer,size,buffer,size,limit,decoder,get,buffer,size,limit,return,catch,throwable,ex,logger,error,failed,to,parse,web,socket,message,to,stomp,sending,stomp,error,to,client,session,id,session,get,id,ex,send,error,message,session,ex,return,for,message,byte,message,messages,try,stomp,header,accessor,header,accessor,message,header,accessor,get,accessor,message,stomp,header,accessor,class,if,logger,is,trace,enabled,if,header,accessor,is,heartbeat,logger,trace,received,heartbeat,from,client,session,session,get,id,else,logger,trace,received,message,from,client,session,session,get,id,header,accessor,set,session,id,session,get,id,header,accessor,set,session,attributes,session,get,attributes,header,accessor,set,user,session,get,principal,header,accessor,set,immutable,if,this,event,publisher,null,stomp,command,connect,equals,header,accessor,get,command,publish,event,new,session,connect,event,this,message,try,simp,attributes,context,holder,set,attributes,from,message,message,output,channel,send,message,finally,simp,attributes,context,holder,reset,attributes,catch,throwable,ex,logger,error,parsed,stomp,message,but,could,not,send,it,to,to,message,channel,sending,stomp,error,to,client,session,id,session,get,id,ex,send,error,message,session,ex
StompSubProtocolHandler -> public void handleMessageFromClient(WebSocketSession session, 			WebSocketMessage<?> webSocketMessage, MessageChannel outputChannel);1403856366;Handle incoming WebSocket messages from clients.;public void handleMessageFromClient(WebSocketSession session,_			WebSocketMessage<?> webSocketMessage, MessageChannel outputChannel) {__		List<Message<byte[]>> messages__		try {_			Assert.isInstanceOf(TextMessage.class,  webSocketMessage)__			TextMessage textMessage = (TextMessage) webSocketMessage__			ByteBuffer byteBuffer = ByteBuffer.wrap(textMessage.asBytes())___			BufferingStompDecoder decoder = this.decoders.get(session.getId())__			if (decoder == null) {_				throw new IllegalStateException("No decoder for session id '" + session.getId() + "'")__			}__			messages = decoder.decode(byteBuffer)__			if (messages.isEmpty()) {_				if (logger.isTraceEnabled()) {_					logger.trace("Incomplete STOMP frame content received, bufferSize=" +_							decoder.getBufferSize() + ", bufferSizeLimit=" + decoder.getBufferSizeLimit() + ".")__				}_				return__			}_		}_		catch (Throwable ex) {_			if (logger.isErrorEnabled()) {_				logger.error("Failed to parse " + webSocketMessage +_						" in session " + session.getId() + ". Sending STOMP ERROR to client.", ex)__			}_			sendErrorMessage(session, ex)__			return__		}__		for (Message<byte[]> message : messages) {_			try {_				StompHeaderAccessor headerAccessor =_						MessageHeaderAccessor.getAccessor(message, StompHeaderAccessor.class)___				if (logger.isTraceEnabled()) {_					logger.trace(headerAccessor.isHeartbeat() ?_							"Received heartbeat from broker in session " + session.getId() + "." :_							"Received message from broker in session " + session.getId() + ": " + message + ".")__				}__				headerAccessor.setSessionId(session.getId())__				headerAccessor.setSessionAttributes(session.getAttributes())__				headerAccessor.setUser(session.getPrincipal())__				headerAccessor.setImmutable()___				if (this.eventPublisher != null && StompCommand.CONNECT.equals(headerAccessor.getCommand())) {_					publishEvent(new SessionConnectEvent(this, message))__				}__				try {_					SimpAttributesContextHolder.setAttributesFromMessage(message)__					outputChannel.send(message)__				}_				finally {_					SimpAttributesContextHolder.resetAttributes()__				}_			}_			catch (Throwable ex) {_				logger.error("Failed to send STOMP message from client to application MessageChannel" +_						" in session " + session.getId() + ". Sending STOMP ERROR to client.", ex)__				sendErrorMessage(session, ex)___			}_		}_	};handle,incoming,web,socket,messages,from,clients;public,void,handle,message,from,client,web,socket,session,session,web,socket,message,web,socket,message,message,channel,output,channel,list,message,byte,messages,try,assert,is,instance,of,text,message,class,web,socket,message,text,message,text,message,text,message,web,socket,message,byte,buffer,byte,buffer,byte,buffer,wrap,text,message,as,bytes,buffering,stomp,decoder,decoder,this,decoders,get,session,get,id,if,decoder,null,throw,new,illegal,state,exception,no,decoder,for,session,id,session,get,id,messages,decoder,decode,byte,buffer,if,messages,is,empty,if,logger,is,trace,enabled,logger,trace,incomplete,stomp,frame,content,received,buffer,size,decoder,get,buffer,size,buffer,size,limit,decoder,get,buffer,size,limit,return,catch,throwable,ex,if,logger,is,error,enabled,logger,error,failed,to,parse,web,socket,message,in,session,session,get,id,sending,stomp,error,to,client,ex,send,error,message,session,ex,return,for,message,byte,message,messages,try,stomp,header,accessor,header,accessor,message,header,accessor,get,accessor,message,stomp,header,accessor,class,if,logger,is,trace,enabled,logger,trace,header,accessor,is,heartbeat,received,heartbeat,from,broker,in,session,session,get,id,received,message,from,broker,in,session,session,get,id,message,header,accessor,set,session,id,session,get,id,header,accessor,set,session,attributes,session,get,attributes,header,accessor,set,user,session,get,principal,header,accessor,set,immutable,if,this,event,publisher,null,stomp,command,connect,equals,header,accessor,get,command,publish,event,new,session,connect,event,this,message,try,simp,attributes,context,holder,set,attributes,from,message,message,output,channel,send,message,finally,simp,attributes,context,holder,reset,attributes,catch,throwable,ex,logger,error,failed,to,send,stomp,message,from,client,to,application,message,channel,in,session,session,get,id,sending,stomp,error,to,client,ex,send,error,message,session,ex
StompSubProtocolHandler -> public void handleMessageFromClient(WebSocketSession session, 			WebSocketMessage<?> webSocketMessage, MessageChannel outputChannel);1403968062;Handle incoming WebSocket messages from clients.;public void handleMessageFromClient(WebSocketSession session,_			WebSocketMessage<?> webSocketMessage, MessageChannel outputChannel) {__		List<Message<byte[]>> messages__		try {_			Assert.isInstanceOf(TextMessage.class,  webSocketMessage)__			TextMessage textMessage = (TextMessage) webSocketMessage__			ByteBuffer byteBuffer = ByteBuffer.wrap(textMessage.asBytes())___			BufferingStompDecoder decoder = this.decoders.get(session.getId())__			if (decoder == null) {_				throw new IllegalStateException("No decoder for session id '" + session.getId() + "'")__			}__			messages = decoder.decode(byteBuffer)__			if (messages.isEmpty()) {_				if (logger.isTraceEnabled()) {_					logger.trace("Incomplete STOMP frame content received, bufferSize=" +_							decoder.getBufferSize() + ", bufferSizeLimit=" + decoder.getBufferSizeLimit() + ".")__				}_				return__			}_		}_		catch (Throwable ex) {_			if (logger.isErrorEnabled()) {_				logger.error("Failed to parse " + webSocketMessage +_						" in session " + session.getId() + ". Sending STOMP ERROR to client.", ex)__			}_			sendErrorMessage(session, ex)__			return__		}__		for (Message<byte[]> message : messages) {_			try {_				StompHeaderAccessor headerAccessor =_						MessageHeaderAccessor.getAccessor(message, StompHeaderAccessor.class)___				if (logger.isTraceEnabled()) {_					logger.trace(headerAccessor.isHeartbeat() ?_							"Received heartbeat from broker in session " + session.getId() + "." :_							"Received message from broker in session " + session.getId() + ": " + message + ".")__				}__				headerAccessor.setSessionId(session.getId())__				headerAccessor.setSessionAttributes(session.getAttributes())__				headerAccessor.setUser(session.getPrincipal())__				headerAccessor.setImmutable()___				if (this.eventPublisher != null) {_					if (StompCommand.CONNECT.equals(headerAccessor.getCommand())) {_						publishEvent(new SessionConnectEvent(this, message))__					}_					else if (StompCommand.SUBSCRIBE.equals(headerAccessor.getCommand())) {_						publishEvent(new SessionSubscribeEvent(this, message))__					}_					else if (StompCommand.UNSUBSCRIBE.equals(headerAccessor.getCommand())) {_						publishEvent(new SessionUnsubscribeEvent(this, message))__					}_				}__				try {_					SimpAttributesContextHolder.setAttributesFromMessage(message)__					outputChannel.send(message)__				}_				finally {_					SimpAttributesContextHolder.resetAttributes()__				}_			}_			catch (Throwable ex) {_				logger.error("Failed to send STOMP message from client to application MessageChannel" +_						" in session " + session.getId() + ". Sending STOMP ERROR to client.", ex)__				sendErrorMessage(session, ex)___			}_		}_	};handle,incoming,web,socket,messages,from,clients;public,void,handle,message,from,client,web,socket,session,session,web,socket,message,web,socket,message,message,channel,output,channel,list,message,byte,messages,try,assert,is,instance,of,text,message,class,web,socket,message,text,message,text,message,text,message,web,socket,message,byte,buffer,byte,buffer,byte,buffer,wrap,text,message,as,bytes,buffering,stomp,decoder,decoder,this,decoders,get,session,get,id,if,decoder,null,throw,new,illegal,state,exception,no,decoder,for,session,id,session,get,id,messages,decoder,decode,byte,buffer,if,messages,is,empty,if,logger,is,trace,enabled,logger,trace,incomplete,stomp,frame,content,received,buffer,size,decoder,get,buffer,size,buffer,size,limit,decoder,get,buffer,size,limit,return,catch,throwable,ex,if,logger,is,error,enabled,logger,error,failed,to,parse,web,socket,message,in,session,session,get,id,sending,stomp,error,to,client,ex,send,error,message,session,ex,return,for,message,byte,message,messages,try,stomp,header,accessor,header,accessor,message,header,accessor,get,accessor,message,stomp,header,accessor,class,if,logger,is,trace,enabled,logger,trace,header,accessor,is,heartbeat,received,heartbeat,from,broker,in,session,session,get,id,received,message,from,broker,in,session,session,get,id,message,header,accessor,set,session,id,session,get,id,header,accessor,set,session,attributes,session,get,attributes,header,accessor,set,user,session,get,principal,header,accessor,set,immutable,if,this,event,publisher,null,if,stomp,command,connect,equals,header,accessor,get,command,publish,event,new,session,connect,event,this,message,else,if,stomp,command,subscribe,equals,header,accessor,get,command,publish,event,new,session,subscribe,event,this,message,else,if,stomp,command,unsubscribe,equals,header,accessor,get,command,publish,event,new,session,unsubscribe,event,this,message,try,simp,attributes,context,holder,set,attributes,from,message,message,output,channel,send,message,finally,simp,attributes,context,holder,reset,attributes,catch,throwable,ex,logger,error,failed,to,send,stomp,message,from,client,to,application,message,channel,in,session,session,get,id,sending,stomp,error,to,client,ex,send,error,message,session,ex
StompSubProtocolHandler -> public void handleMessageFromClient(WebSocketSession session, 			WebSocketMessage<?> webSocketMessage, MessageChannel outputChannel);1404880787;Handle incoming WebSocket messages from clients.;public void handleMessageFromClient(WebSocketSession session,_			WebSocketMessage<?> webSocketMessage, MessageChannel outputChannel) {__		List<Message<byte[]>> messages__		try {_			Assert.isInstanceOf(TextMessage.class,  webSocketMessage)__			TextMessage textMessage = (TextMessage) webSocketMessage__			ByteBuffer byteBuffer = ByteBuffer.wrap(textMessage.asBytes())___			BufferingStompDecoder decoder = this.decoders.get(session.getId())__			if (decoder == null) {_				throw new IllegalStateException("No decoder for session id '" + session.getId() + "'")__			}__			messages = decoder.decode(byteBuffer)__			if (messages.isEmpty()) {_				if (logger.isTraceEnabled()) {_					logger.trace("Incomplete STOMP frame content received, bufferSize=" +_							decoder.getBufferSize() + ", bufferSizeLimit=" + decoder.getBufferSizeLimit() + ".")__				}_				return__			}_		}_		catch (Throwable ex) {_			if (logger.isErrorEnabled()) {_				logger.error("Failed to parse " + webSocketMessage +_						" in session " + session.getId() + ". Sending STOMP ERROR to client.", ex)__			}_			sendErrorMessage(session, ex)__			return__		}__		for (Message<byte[]> message : messages) {_			try {_				StompHeaderAccessor headerAccessor =_						MessageHeaderAccessor.getAccessor(message, StompHeaderAccessor.class)___				if (logger.isTraceEnabled()) {_					logger.trace(headerAccessor.isHeartbeat() ?_							"Received heartbeat from broker in session " + session.getId() + "." :_							"Received message from broker in session " + session.getId() + ": " + message + ".")__				}__				headerAccessor.setSessionId(session.getId())__				headerAccessor.setSessionAttributes(session.getAttributes())__				headerAccessor.setUser(session.getPrincipal())__				headerAccessor.setImmutable()___				if (this.eventPublisher != null) {_					if (StompCommand.CONNECT.equals(headerAccessor.getCommand())) {_						this.stats.incrementConnectCount()__						publishEvent(new SessionConnectEvent(this, message))__					}_					else if (StompCommand.DISCONNECT.equals(headerAccessor.getCommand())) {_						this.stats.incrementDisconnectCount()__					}_					else if (StompCommand.SUBSCRIBE.equals(headerAccessor.getCommand())) {_						publishEvent(new SessionSubscribeEvent(this, message))__					}_					else if (StompCommand.UNSUBSCRIBE.equals(headerAccessor.getCommand())) {_						publishEvent(new SessionUnsubscribeEvent(this, message))__					}_				}__				try {_					SimpAttributesContextHolder.setAttributesFromMessage(message)__					outputChannel.send(message)__				}_				finally {_					SimpAttributesContextHolder.resetAttributes()__				}_			}_			catch (Throwable ex) {_				logger.error("Failed to send STOMP message from client to application MessageChannel" +_						" in session " + session.getId() + ". Sending STOMP ERROR to client.", ex)__				sendErrorMessage(session, ex)___			}_		}_	};handle,incoming,web,socket,messages,from,clients;public,void,handle,message,from,client,web,socket,session,session,web,socket,message,web,socket,message,message,channel,output,channel,list,message,byte,messages,try,assert,is,instance,of,text,message,class,web,socket,message,text,message,text,message,text,message,web,socket,message,byte,buffer,byte,buffer,byte,buffer,wrap,text,message,as,bytes,buffering,stomp,decoder,decoder,this,decoders,get,session,get,id,if,decoder,null,throw,new,illegal,state,exception,no,decoder,for,session,id,session,get,id,messages,decoder,decode,byte,buffer,if,messages,is,empty,if,logger,is,trace,enabled,logger,trace,incomplete,stomp,frame,content,received,buffer,size,decoder,get,buffer,size,buffer,size,limit,decoder,get,buffer,size,limit,return,catch,throwable,ex,if,logger,is,error,enabled,logger,error,failed,to,parse,web,socket,message,in,session,session,get,id,sending,stomp,error,to,client,ex,send,error,message,session,ex,return,for,message,byte,message,messages,try,stomp,header,accessor,header,accessor,message,header,accessor,get,accessor,message,stomp,header,accessor,class,if,logger,is,trace,enabled,logger,trace,header,accessor,is,heartbeat,received,heartbeat,from,broker,in,session,session,get,id,received,message,from,broker,in,session,session,get,id,message,header,accessor,set,session,id,session,get,id,header,accessor,set,session,attributes,session,get,attributes,header,accessor,set,user,session,get,principal,header,accessor,set,immutable,if,this,event,publisher,null,if,stomp,command,connect,equals,header,accessor,get,command,this,stats,increment,connect,count,publish,event,new,session,connect,event,this,message,else,if,stomp,command,disconnect,equals,header,accessor,get,command,this,stats,increment,disconnect,count,else,if,stomp,command,subscribe,equals,header,accessor,get,command,publish,event,new,session,subscribe,event,this,message,else,if,stomp,command,unsubscribe,equals,header,accessor,get,command,publish,event,new,session,unsubscribe,event,this,message,try,simp,attributes,context,holder,set,attributes,from,message,message,output,channel,send,message,finally,simp,attributes,context,holder,reset,attributes,catch,throwable,ex,logger,error,failed,to,send,stomp,message,from,client,to,application,message,channel,in,session,session,get,id,sending,stomp,error,to,client,ex,send,error,message,session,ex
StompSubProtocolHandler -> public void handleMessageFromClient(WebSocketSession session, 			WebSocketMessage<?> webSocketMessage, MessageChannel outputChannel);1404880799;Handle incoming WebSocket messages from clients.;public void handleMessageFromClient(WebSocketSession session,_			WebSocketMessage<?> webSocketMessage, MessageChannel outputChannel) {__		List<Message<byte[]>> messages__		try {_			Assert.isInstanceOf(TextMessage.class,  webSocketMessage)__			TextMessage textMessage = (TextMessage) webSocketMessage__			ByteBuffer byteBuffer = ByteBuffer.wrap(textMessage.asBytes())___			BufferingStompDecoder decoder = this.decoders.get(session.getId())__			if (decoder == null) {_				throw new IllegalStateException("No decoder for session id '" + session.getId() + "'")__			}__			messages = decoder.decode(byteBuffer)__			if (messages.isEmpty()) {_				if (logger.isTraceEnabled()) {_					logger.trace("Incomplete STOMP frame content received in session " +_							session + ", bufferSize=" + decoder.getBufferSize() +_							", bufferSizeLimit=" + decoder.getBufferSizeLimit() + ".")__				}_				return__			}_		}_		catch (Throwable ex) {_			if (logger.isErrorEnabled()) {_				logger.error("Failed to parse " + webSocketMessage +_						" in session " + session.getId() + ". Sending STOMP ERROR to client.", ex)__			}_			sendErrorMessage(session, ex)__			return__		}__		for (Message<byte[]> message : messages) {_			try {_				StompHeaderAccessor headerAccessor =_						MessageHeaderAccessor.getAccessor(message, StompHeaderAccessor.class)___				if (logger.isTraceEnabled()) {_					logger.trace("From client: " + headerAccessor.getShortLogMessage(message.getPayload()))__				}__				headerAccessor.setSessionId(session.getId())__				headerAccessor.setSessionAttributes(session.getAttributes())__				headerAccessor.setUser(session.getPrincipal())__				headerAccessor.setImmutable()___				if (this.eventPublisher != null) {_					if (StompCommand.CONNECT.equals(headerAccessor.getCommand())) {_						this.stats.incrementConnectCount()__						publishEvent(new SessionConnectEvent(this, message))__					}_					else if (StompCommand.DISCONNECT.equals(headerAccessor.getCommand())) {_						this.stats.incrementDisconnectCount()__					}_					else if (StompCommand.SUBSCRIBE.equals(headerAccessor.getCommand())) {_						publishEvent(new SessionSubscribeEvent(this, message))__					}_					else if (StompCommand.UNSUBSCRIBE.equals(headerAccessor.getCommand())) {_						publishEvent(new SessionUnsubscribeEvent(this, message))__					}_				}__				try {_					SimpAttributesContextHolder.setAttributesFromMessage(message)__					outputChannel.send(message)__				}_				finally {_					SimpAttributesContextHolder.resetAttributes()__				}_			}_			catch (Throwable ex) {_				logger.error("Failed to send STOMP message from client to application MessageChannel" +_						" in session " + session.getId() + ". Sending STOMP ERROR to client.", ex)__				sendErrorMessage(session, ex)___			}_		}_	};handle,incoming,web,socket,messages,from,clients;public,void,handle,message,from,client,web,socket,session,session,web,socket,message,web,socket,message,message,channel,output,channel,list,message,byte,messages,try,assert,is,instance,of,text,message,class,web,socket,message,text,message,text,message,text,message,web,socket,message,byte,buffer,byte,buffer,byte,buffer,wrap,text,message,as,bytes,buffering,stomp,decoder,decoder,this,decoders,get,session,get,id,if,decoder,null,throw,new,illegal,state,exception,no,decoder,for,session,id,session,get,id,messages,decoder,decode,byte,buffer,if,messages,is,empty,if,logger,is,trace,enabled,logger,trace,incomplete,stomp,frame,content,received,in,session,session,buffer,size,decoder,get,buffer,size,buffer,size,limit,decoder,get,buffer,size,limit,return,catch,throwable,ex,if,logger,is,error,enabled,logger,error,failed,to,parse,web,socket,message,in,session,session,get,id,sending,stomp,error,to,client,ex,send,error,message,session,ex,return,for,message,byte,message,messages,try,stomp,header,accessor,header,accessor,message,header,accessor,get,accessor,message,stomp,header,accessor,class,if,logger,is,trace,enabled,logger,trace,from,client,header,accessor,get,short,log,message,message,get,payload,header,accessor,set,session,id,session,get,id,header,accessor,set,session,attributes,session,get,attributes,header,accessor,set,user,session,get,principal,header,accessor,set,immutable,if,this,event,publisher,null,if,stomp,command,connect,equals,header,accessor,get,command,this,stats,increment,connect,count,publish,event,new,session,connect,event,this,message,else,if,stomp,command,disconnect,equals,header,accessor,get,command,this,stats,increment,disconnect,count,else,if,stomp,command,subscribe,equals,header,accessor,get,command,publish,event,new,session,subscribe,event,this,message,else,if,stomp,command,unsubscribe,equals,header,accessor,get,command,publish,event,new,session,unsubscribe,event,this,message,try,simp,attributes,context,holder,set,attributes,from,message,message,output,channel,send,message,finally,simp,attributes,context,holder,reset,attributes,catch,throwable,ex,logger,error,failed,to,send,stomp,message,from,client,to,application,message,channel,in,session,session,get,id,sending,stomp,error,to,client,ex,send,error,message,session,ex
StompSubProtocolHandler -> public void handleMessageFromClient(WebSocketSession session, 			WebSocketMessage<?> webSocketMessage, MessageChannel outputChannel);1411067168;Handle incoming WebSocket messages from clients.;public void handleMessageFromClient(WebSocketSession session,_			WebSocketMessage<?> webSocketMessage, MessageChannel outputChannel) {__		List<Message<byte[]>> messages__		try {_			Assert.isInstanceOf(TextMessage.class,  webSocketMessage)__			TextMessage textMessage = (TextMessage) webSocketMessage__			ByteBuffer byteBuffer = ByteBuffer.wrap(textMessage.asBytes())___			BufferingStompDecoder decoder = this.decoders.get(session.getId())__			if (decoder == null) {_				throw new IllegalStateException("No decoder for session id '" + session.getId() + "'")__			}__			messages = decoder.decode(byteBuffer)__			if (messages.isEmpty()) {_				if (logger.isTraceEnabled()) {_					logger.trace("Incomplete STOMP frame content received in session " +_							session + ", bufferSize=" + decoder.getBufferSize() +_							", bufferSizeLimit=" + decoder.getBufferSizeLimit() + ".")__				}_				return__			}_		}_		catch (Throwable ex) {_			if (logger.isErrorEnabled()) {_				logger.error("Failed to parse " + webSocketMessage +_						" in session " + session.getId() + ". Sending STOMP ERROR to client.", ex)__			}_			sendErrorMessage(session, ex)__			return__		}__		for (Message<byte[]> message : messages) {_			try {_				StompHeaderAccessor headerAccessor =_						MessageHeaderAccessor.getAccessor(message, StompHeaderAccessor.class)___				if (logger.isTraceEnabled()) {_					logger.trace("From client: " + headerAccessor.getShortLogMessage(message.getPayload()))__				}__				headerAccessor.setSessionId(session.getId())__				headerAccessor.setSessionAttributes(session.getAttributes())__				headerAccessor.setUser(session.getPrincipal())__				headerAccessor.setImmutable()___				if (this.eventPublisher != null) {_					if (StompCommand.CONNECT.equals(headerAccessor.getCommand())) {_						this.stats.incrementConnectCount()__						publishEvent(new SessionConnectEvent(this, message))__					}_					else if (StompCommand.DISCONNECT.equals(headerAccessor.getCommand())) {_						this.stats.incrementDisconnectCount()__					}_					else if (StompCommand.SUBSCRIBE.equals(headerAccessor.getCommand())) {_						publishEvent(new SessionSubscribeEvent(this, message))__					}_					else if (StompCommand.UNSUBSCRIBE.equals(headerAccessor.getCommand())) {_						publishEvent(new SessionUnsubscribeEvent(this, message))__					}_				}__				try {_					SimpAttributesContextHolder.setAttributesFromMessage(message)__					outputChannel.send(message)__				}_				finally {_					SimpAttributesContextHolder.resetAttributes()__				}_			}_			catch (Throwable ex) {_				logger.error("Failed to send STOMP message from client to application MessageChannel" +_						" in session " + session.getId() + ". Sending STOMP ERROR to client.", ex)__				sendErrorMessage(session, ex)___			}_		}_	};handle,incoming,web,socket,messages,from,clients;public,void,handle,message,from,client,web,socket,session,session,web,socket,message,web,socket,message,message,channel,output,channel,list,message,byte,messages,try,assert,is,instance,of,text,message,class,web,socket,message,text,message,text,message,text,message,web,socket,message,byte,buffer,byte,buffer,byte,buffer,wrap,text,message,as,bytes,buffering,stomp,decoder,decoder,this,decoders,get,session,get,id,if,decoder,null,throw,new,illegal,state,exception,no,decoder,for,session,id,session,get,id,messages,decoder,decode,byte,buffer,if,messages,is,empty,if,logger,is,trace,enabled,logger,trace,incomplete,stomp,frame,content,received,in,session,session,buffer,size,decoder,get,buffer,size,buffer,size,limit,decoder,get,buffer,size,limit,return,catch,throwable,ex,if,logger,is,error,enabled,logger,error,failed,to,parse,web,socket,message,in,session,session,get,id,sending,stomp,error,to,client,ex,send,error,message,session,ex,return,for,message,byte,message,messages,try,stomp,header,accessor,header,accessor,message,header,accessor,get,accessor,message,stomp,header,accessor,class,if,logger,is,trace,enabled,logger,trace,from,client,header,accessor,get,short,log,message,message,get,payload,header,accessor,set,session,id,session,get,id,header,accessor,set,session,attributes,session,get,attributes,header,accessor,set,user,session,get,principal,header,accessor,set,immutable,if,this,event,publisher,null,if,stomp,command,connect,equals,header,accessor,get,command,this,stats,increment,connect,count,publish,event,new,session,connect,event,this,message,else,if,stomp,command,disconnect,equals,header,accessor,get,command,this,stats,increment,disconnect,count,else,if,stomp,command,subscribe,equals,header,accessor,get,command,publish,event,new,session,subscribe,event,this,message,else,if,stomp,command,unsubscribe,equals,header,accessor,get,command,publish,event,new,session,unsubscribe,event,this,message,try,simp,attributes,context,holder,set,attributes,from,message,message,output,channel,send,message,finally,simp,attributes,context,holder,reset,attributes,catch,throwable,ex,logger,error,failed,to,send,stomp,message,from,client,to,application,message,channel,in,session,session,get,id,sending,stomp,error,to,client,ex,send,error,message,session,ex
StompSubProtocolHandler -> public void handleMessageFromClient(WebSocketSession session, 			WebSocketMessage<?> webSocketMessage, MessageChannel outputChannel);1411068071;Handle incoming WebSocket messages from clients.;public void handleMessageFromClient(WebSocketSession session,_			WebSocketMessage<?> webSocketMessage, MessageChannel outputChannel) {__		List<Message<byte[]>> messages__		try {_			Assert.isInstanceOf(TextMessage.class,  webSocketMessage)__			TextMessage textMessage = (TextMessage) webSocketMessage__			ByteBuffer byteBuffer = ByteBuffer.wrap(textMessage.asBytes())___			BufferingStompDecoder decoder = this.decoders.get(session.getId())__			if (decoder == null) {_				throw new IllegalStateException("No decoder for session id '" + session.getId() + "'")__			}__			messages = decoder.decode(byteBuffer)__			if (messages.isEmpty()) {_				if (logger.isTraceEnabled()) {_					logger.trace("Incomplete STOMP frame content received in session " +_							session + ", bufferSize=" + decoder.getBufferSize() +_							", bufferSizeLimit=" + decoder.getBufferSizeLimit() + ".")__				}_				return__			}_		}_		catch (Throwable ex) {_			if (logger.isErrorEnabled()) {_				logger.error("Failed to parse " + webSocketMessage +_						" in session " + session.getId() + ". Sending STOMP ERROR to client.", ex)__			}_			sendErrorMessage(session, ex)__			return__		}__		for (Message<byte[]> message : messages) {_			try {_				StompHeaderAccessor headerAccessor =_						MessageHeaderAccessor.getAccessor(message, StompHeaderAccessor.class)___				if (logger.isTraceEnabled()) {_					logger.trace("From client: " + headerAccessor.getShortLogMessage(message.getPayload()))__				}__				headerAccessor.setSessionId(session.getId())__				headerAccessor.setSessionAttributes(session.getAttributes())__				headerAccessor.setUser(session.getPrincipal())__				headerAccessor.setImmutable()___				if (this.eventPublisher != null) {_					if (StompCommand.CONNECT.equals(headerAccessor.getCommand())) {_						this.stats.incrementConnectCount()__						publishEvent(new SessionConnectEvent(this, message))__					}_					else if (StompCommand.DISCONNECT.equals(headerAccessor.getCommand())) {_						this.stats.incrementDisconnectCount()__					}_					else if (StompCommand.SUBSCRIBE.equals(headerAccessor.getCommand())) {_						publishEvent(new SessionSubscribeEvent(this, message))__					}_					else if (StompCommand.UNSUBSCRIBE.equals(headerAccessor.getCommand())) {_						publishEvent(new SessionUnsubscribeEvent(this, message))__					}_				}__				try {_					SimpAttributesContextHolder.setAttributesFromMessage(message)__					outputChannel.send(message)__				}_				finally {_					SimpAttributesContextHolder.resetAttributes()__				}_			}_			catch (Throwable ex) {_				logger.error("Failed to send STOMP message from client to application MessageChannel" +_						" in session " + session.getId() + ". Sending STOMP ERROR to client.", ex)__				sendErrorMessage(session, ex)___			}_		}_	};handle,incoming,web,socket,messages,from,clients;public,void,handle,message,from,client,web,socket,session,session,web,socket,message,web,socket,message,message,channel,output,channel,list,message,byte,messages,try,assert,is,instance,of,text,message,class,web,socket,message,text,message,text,message,text,message,web,socket,message,byte,buffer,byte,buffer,byte,buffer,wrap,text,message,as,bytes,buffering,stomp,decoder,decoder,this,decoders,get,session,get,id,if,decoder,null,throw,new,illegal,state,exception,no,decoder,for,session,id,session,get,id,messages,decoder,decode,byte,buffer,if,messages,is,empty,if,logger,is,trace,enabled,logger,trace,incomplete,stomp,frame,content,received,in,session,session,buffer,size,decoder,get,buffer,size,buffer,size,limit,decoder,get,buffer,size,limit,return,catch,throwable,ex,if,logger,is,error,enabled,logger,error,failed,to,parse,web,socket,message,in,session,session,get,id,sending,stomp,error,to,client,ex,send,error,message,session,ex,return,for,message,byte,message,messages,try,stomp,header,accessor,header,accessor,message,header,accessor,get,accessor,message,stomp,header,accessor,class,if,logger,is,trace,enabled,logger,trace,from,client,header,accessor,get,short,log,message,message,get,payload,header,accessor,set,session,id,session,get,id,header,accessor,set,session,attributes,session,get,attributes,header,accessor,set,user,session,get,principal,header,accessor,set,immutable,if,this,event,publisher,null,if,stomp,command,connect,equals,header,accessor,get,command,this,stats,increment,connect,count,publish,event,new,session,connect,event,this,message,else,if,stomp,command,disconnect,equals,header,accessor,get,command,this,stats,increment,disconnect,count,else,if,stomp,command,subscribe,equals,header,accessor,get,command,publish,event,new,session,subscribe,event,this,message,else,if,stomp,command,unsubscribe,equals,header,accessor,get,command,publish,event,new,session,unsubscribe,event,this,message,try,simp,attributes,context,holder,set,attributes,from,message,message,output,channel,send,message,finally,simp,attributes,context,holder,reset,attributes,catch,throwable,ex,logger,error,failed,to,send,stomp,message,from,client,to,application,message,channel,in,session,session,get,id,sending,stomp,error,to,client,ex,send,error,message,session,ex
StompSubProtocolHandler -> public void handleMessageFromClient(WebSocketSession session, 			WebSocketMessage<?> webSocketMessage, MessageChannel outputChannel);1411148800;Handle incoming WebSocket messages from clients.;public void handleMessageFromClient(WebSocketSession session,_			WebSocketMessage<?> webSocketMessage, MessageChannel outputChannel) {__		List<Message<byte[]>> messages__		try {_			Assert.isInstanceOf(TextMessage.class,  webSocketMessage)__			TextMessage textMessage = (TextMessage) webSocketMessage__			ByteBuffer byteBuffer = ByteBuffer.wrap(textMessage.asBytes())___			BufferingStompDecoder decoder = this.decoders.get(session.getId())__			if (decoder == null) {_				throw new IllegalStateException("No decoder for session id '" + session.getId() + "'")__			}__			messages = decoder.decode(byteBuffer)__			if (messages.isEmpty()) {_				if (logger.isTraceEnabled()) {_					logger.trace("Incomplete STOMP frame content received in session " +_							session + ", bufferSize=" + decoder.getBufferSize() +_							", bufferSizeLimit=" + decoder.getBufferSizeLimit() + ".")__				}_				return__			}_		}_		catch (Throwable ex) {_			if (logger.isErrorEnabled()) {_				logger.error("Failed to parse " + webSocketMessage +_						" in session " + session.getId() + ". Sending STOMP ERROR to client.", ex)__			}_			sendErrorMessage(session, ex)__			return__		}__		for (Message<byte[]> message : messages) {_			try {_				StompHeaderAccessor headerAccessor =_						MessageHeaderAccessor.getAccessor(message, StompHeaderAccessor.class)___				if (logger.isTraceEnabled()) {_					logger.trace("From client: " + headerAccessor.getShortLogMessage(message.getPayload()))__				}__				headerAccessor.setSessionId(session.getId())__				headerAccessor.setSessionAttributes(session.getAttributes())__				headerAccessor.setUser(session.getPrincipal())__				headerAccessor.setImmutable()___				if (StompCommand.CONNECT.equals(headerAccessor.getCommand())) {_					this.stats.incrementConnectCount()__				}_				else if (StompCommand.DISCONNECT.equals(headerAccessor.getCommand())) {_					this.stats.incrementDisconnectCount()__				}__				try {_					SimpAttributesContextHolder.setAttributesFromMessage(message)__					if (this.eventPublisher != null) {_						if (StompCommand.CONNECT.equals(headerAccessor.getCommand())) {_							publishEvent(new SessionConnectEvent(this, message))__						}_						else if (StompCommand.SUBSCRIBE.equals(headerAccessor.getCommand())) {_							publishEvent(new SessionSubscribeEvent(this, message))__						}_						else if (StompCommand.UNSUBSCRIBE.equals(headerAccessor.getCommand())) {_							publishEvent(new SessionUnsubscribeEvent(this, message))__						}_					}_					outputChannel.send(message)__				}_				finally {_					SimpAttributesContextHolder.resetAttributes()__				}_			}_			catch (Throwable ex) {_				logger.error("Failed to send STOMP message from client to application MessageChannel" +_						" in session " + session.getId() + ". Sending STOMP ERROR to client.", ex)__				sendErrorMessage(session, ex)___			}_		}_	};handle,incoming,web,socket,messages,from,clients;public,void,handle,message,from,client,web,socket,session,session,web,socket,message,web,socket,message,message,channel,output,channel,list,message,byte,messages,try,assert,is,instance,of,text,message,class,web,socket,message,text,message,text,message,text,message,web,socket,message,byte,buffer,byte,buffer,byte,buffer,wrap,text,message,as,bytes,buffering,stomp,decoder,decoder,this,decoders,get,session,get,id,if,decoder,null,throw,new,illegal,state,exception,no,decoder,for,session,id,session,get,id,messages,decoder,decode,byte,buffer,if,messages,is,empty,if,logger,is,trace,enabled,logger,trace,incomplete,stomp,frame,content,received,in,session,session,buffer,size,decoder,get,buffer,size,buffer,size,limit,decoder,get,buffer,size,limit,return,catch,throwable,ex,if,logger,is,error,enabled,logger,error,failed,to,parse,web,socket,message,in,session,session,get,id,sending,stomp,error,to,client,ex,send,error,message,session,ex,return,for,message,byte,message,messages,try,stomp,header,accessor,header,accessor,message,header,accessor,get,accessor,message,stomp,header,accessor,class,if,logger,is,trace,enabled,logger,trace,from,client,header,accessor,get,short,log,message,message,get,payload,header,accessor,set,session,id,session,get,id,header,accessor,set,session,attributes,session,get,attributes,header,accessor,set,user,session,get,principal,header,accessor,set,immutable,if,stomp,command,connect,equals,header,accessor,get,command,this,stats,increment,connect,count,else,if,stomp,command,disconnect,equals,header,accessor,get,command,this,stats,increment,disconnect,count,try,simp,attributes,context,holder,set,attributes,from,message,message,if,this,event,publisher,null,if,stomp,command,connect,equals,header,accessor,get,command,publish,event,new,session,connect,event,this,message,else,if,stomp,command,subscribe,equals,header,accessor,get,command,publish,event,new,session,subscribe,event,this,message,else,if,stomp,command,unsubscribe,equals,header,accessor,get,command,publish,event,new,session,unsubscribe,event,this,message,output,channel,send,message,finally,simp,attributes,context,holder,reset,attributes,catch,throwable,ex,logger,error,failed,to,send,stomp,message,from,client,to,application,message,channel,in,session,session,get,id,sending,stomp,error,to,client,ex,send,error,message,session,ex
StompSubProtocolHandler -> public void handleMessageFromClient(WebSocketSession session, 			WebSocketMessage<?> webSocketMessage, MessageChannel outputChannel);1411567635;Handle incoming WebSocket messages from clients.;public void handleMessageFromClient(WebSocketSession session,_			WebSocketMessage<?> webSocketMessage, MessageChannel outputChannel) {__		List<Message<byte[]>> messages__		try {_			Assert.isInstanceOf(TextMessage.class,  webSocketMessage)__			TextMessage textMessage = (TextMessage) webSocketMessage__			ByteBuffer byteBuffer = ByteBuffer.wrap(textMessage.asBytes())___			BufferingStompDecoder decoder = this.decoders.get(session.getId())__			if (decoder == null) {_				throw new IllegalStateException("No decoder for session id '" + session.getId() + "'")__			}__			messages = decoder.decode(byteBuffer)__			if (messages.isEmpty()) {_				if (logger.isTraceEnabled()) {_					logger.trace("Incomplete STOMP frame content received in session " +_							session + ", bufferSize=" + decoder.getBufferSize() +_							", bufferSizeLimit=" + decoder.getBufferSizeLimit() + ".")__				}_				return__			}_		}_		catch (Throwable ex) {_			if (logger.isErrorEnabled()) {_				logger.error("Failed to parse " + webSocketMessage +_						" in session " + session.getId() + ". Sending STOMP ERROR to client.", ex)__			}_			sendErrorMessage(session, ex)__			return__		}__		for (Message<byte[]> message : messages) {_			try {_				StompHeaderAccessor headerAccessor =_						MessageHeaderAccessor.getAccessor(message, StompHeaderAccessor.class)___				if (logger.isTraceEnabled()) {_					logger.trace("From client: " + headerAccessor.getShortLogMessage(message.getPayload()))__				}__				headerAccessor.setSessionId(session.getId())__				headerAccessor.setSessionAttributes(session.getAttributes())__				headerAccessor.setUser(session.getPrincipal())__				headerAccessor.setImmutable()___				if (StompCommand.CONNECT.equals(headerAccessor.getCommand())) {_					this.stats.incrementConnectCount()__				}_				else if (StompCommand.DISCONNECT.equals(headerAccessor.getCommand())) {_					this.stats.incrementDisconnectCount()__				}__				try {_					SimpAttributesContextHolder.setAttributesFromMessage(message)__					if (this.eventPublisher != null) {_						if (StompCommand.CONNECT.equals(headerAccessor.getCommand())) {_							publishEvent(new SessionConnectEvent(this, message))__						}_						else if (StompCommand.SUBSCRIBE.equals(headerAccessor.getCommand())) {_							publishEvent(new SessionSubscribeEvent(this, message))__						}_						else if (StompCommand.UNSUBSCRIBE.equals(headerAccessor.getCommand())) {_							publishEvent(new SessionUnsubscribeEvent(this, message))__						}_					}_					outputChannel.send(message)__				}_				finally {_					SimpAttributesContextHolder.resetAttributes()__				}_			}_			catch (Throwable ex) {_				logger.error("Failed to send client message to application via MessageChannel" +_						" in session " + session.getId() + ". Sending STOMP ERROR to client.", ex)__				sendErrorMessage(session, ex)___			}_		}_	};handle,incoming,web,socket,messages,from,clients;public,void,handle,message,from,client,web,socket,session,session,web,socket,message,web,socket,message,message,channel,output,channel,list,message,byte,messages,try,assert,is,instance,of,text,message,class,web,socket,message,text,message,text,message,text,message,web,socket,message,byte,buffer,byte,buffer,byte,buffer,wrap,text,message,as,bytes,buffering,stomp,decoder,decoder,this,decoders,get,session,get,id,if,decoder,null,throw,new,illegal,state,exception,no,decoder,for,session,id,session,get,id,messages,decoder,decode,byte,buffer,if,messages,is,empty,if,logger,is,trace,enabled,logger,trace,incomplete,stomp,frame,content,received,in,session,session,buffer,size,decoder,get,buffer,size,buffer,size,limit,decoder,get,buffer,size,limit,return,catch,throwable,ex,if,logger,is,error,enabled,logger,error,failed,to,parse,web,socket,message,in,session,session,get,id,sending,stomp,error,to,client,ex,send,error,message,session,ex,return,for,message,byte,message,messages,try,stomp,header,accessor,header,accessor,message,header,accessor,get,accessor,message,stomp,header,accessor,class,if,logger,is,trace,enabled,logger,trace,from,client,header,accessor,get,short,log,message,message,get,payload,header,accessor,set,session,id,session,get,id,header,accessor,set,session,attributes,session,get,attributes,header,accessor,set,user,session,get,principal,header,accessor,set,immutable,if,stomp,command,connect,equals,header,accessor,get,command,this,stats,increment,connect,count,else,if,stomp,command,disconnect,equals,header,accessor,get,command,this,stats,increment,disconnect,count,try,simp,attributes,context,holder,set,attributes,from,message,message,if,this,event,publisher,null,if,stomp,command,connect,equals,header,accessor,get,command,publish,event,new,session,connect,event,this,message,else,if,stomp,command,subscribe,equals,header,accessor,get,command,publish,event,new,session,subscribe,event,this,message,else,if,stomp,command,unsubscribe,equals,header,accessor,get,command,publish,event,new,session,unsubscribe,event,this,message,output,channel,send,message,finally,simp,attributes,context,holder,reset,attributes,catch,throwable,ex,logger,error,failed,to,send,client,message,to,application,via,message,channel,in,session,session,get,id,sending,stomp,error,to,client,ex,send,error,message,session,ex
StompSubProtocolHandler -> public void handleMessageFromClient(WebSocketSession session, 			WebSocketMessage<?> webSocketMessage, MessageChannel outputChannel);1412965899;Handle incoming WebSocket messages from clients.;public void handleMessageFromClient(WebSocketSession session,_			WebSocketMessage<?> webSocketMessage, MessageChannel outputChannel) {__		List<Message<byte[]>> messages__		try {_			ByteBuffer byteBuffer__			if (webSocketMessage instanceof TextMessage) {_				byteBuffer = ByteBuffer.wrap(((TextMessage) webSocketMessage).asBytes())__			}_			else if (webSocketMessage instanceof BinaryMessage) {_				byteBuffer = ((BinaryMessage) webSocketMessage).getPayload()__			}_			else {_				throw new IllegalArgumentException("Unexpected WebSocket message type: " + webSocketMessage)__			}__			BufferingStompDecoder decoder = this.decoders.get(session.getId())__			if (decoder == null) {_				throw new IllegalStateException("No decoder for session id '" + session.getId() + "'")__			}__			messages = decoder.decode(byteBuffer)__			if (messages.isEmpty()) {_				if (logger.isTraceEnabled()) {_					logger.trace("Incomplete STOMP frame content received in session " +_							session + ", bufferSize=" + decoder.getBufferSize() +_							", bufferSizeLimit=" + decoder.getBufferSizeLimit() + ".")__				}_				return__			}_		}_		catch (Throwable ex) {_			if (logger.isErrorEnabled()) {_				logger.error("Failed to parse " + webSocketMessage +_						" in session " + session.getId() + ". Sending STOMP ERROR to client.", ex)__			}_			sendErrorMessage(session, ex)__			return__		}__		for (Message<byte[]> message : messages) {_			try {_				StompHeaderAccessor headerAccessor =_						MessageHeaderAccessor.getAccessor(message, StompHeaderAccessor.class)___				if (logger.isTraceEnabled()) {_					logger.trace("From client: " + headerAccessor.getShortLogMessage(message.getPayload()))__				}__				headerAccessor.setSessionId(session.getId())__				headerAccessor.setSessionAttributes(session.getAttributes())__				headerAccessor.setUser(session.getPrincipal())__				headerAccessor.setImmutable()___				if (StompCommand.CONNECT.equals(headerAccessor.getCommand())) {_					this.stats.incrementConnectCount()__				}_				else if (StompCommand.DISCONNECT.equals(headerAccessor.getCommand())) {_					this.stats.incrementDisconnectCount()__				}__				try {_					SimpAttributesContextHolder.setAttributesFromMessage(message)__					if (this.eventPublisher != null) {_						if (StompCommand.CONNECT.equals(headerAccessor.getCommand())) {_							publishEvent(new SessionConnectEvent(this, message))__						}_						else if (StompCommand.SUBSCRIBE.equals(headerAccessor.getCommand())) {_							publishEvent(new SessionSubscribeEvent(this, message))__						}_						else if (StompCommand.UNSUBSCRIBE.equals(headerAccessor.getCommand())) {_							publishEvent(new SessionUnsubscribeEvent(this, message))__						}_					}_					outputChannel.send(message)__				}_				finally {_					SimpAttributesContextHolder.resetAttributes()__				}_			}_			catch (Throwable ex) {_				logger.error("Failed to send client message to application via MessageChannel" +_						" in session " + session.getId() + ". Sending STOMP ERROR to client.", ex)__				sendErrorMessage(session, ex)___			}_		}_	};handle,incoming,web,socket,messages,from,clients;public,void,handle,message,from,client,web,socket,session,session,web,socket,message,web,socket,message,message,channel,output,channel,list,message,byte,messages,try,byte,buffer,byte,buffer,if,web,socket,message,instanceof,text,message,byte,buffer,byte,buffer,wrap,text,message,web,socket,message,as,bytes,else,if,web,socket,message,instanceof,binary,message,byte,buffer,binary,message,web,socket,message,get,payload,else,throw,new,illegal,argument,exception,unexpected,web,socket,message,type,web,socket,message,buffering,stomp,decoder,decoder,this,decoders,get,session,get,id,if,decoder,null,throw,new,illegal,state,exception,no,decoder,for,session,id,session,get,id,messages,decoder,decode,byte,buffer,if,messages,is,empty,if,logger,is,trace,enabled,logger,trace,incomplete,stomp,frame,content,received,in,session,session,buffer,size,decoder,get,buffer,size,buffer,size,limit,decoder,get,buffer,size,limit,return,catch,throwable,ex,if,logger,is,error,enabled,logger,error,failed,to,parse,web,socket,message,in,session,session,get,id,sending,stomp,error,to,client,ex,send,error,message,session,ex,return,for,message,byte,message,messages,try,stomp,header,accessor,header,accessor,message,header,accessor,get,accessor,message,stomp,header,accessor,class,if,logger,is,trace,enabled,logger,trace,from,client,header,accessor,get,short,log,message,message,get,payload,header,accessor,set,session,id,session,get,id,header,accessor,set,session,attributes,session,get,attributes,header,accessor,set,user,session,get,principal,header,accessor,set,immutable,if,stomp,command,connect,equals,header,accessor,get,command,this,stats,increment,connect,count,else,if,stomp,command,disconnect,equals,header,accessor,get,command,this,stats,increment,disconnect,count,try,simp,attributes,context,holder,set,attributes,from,message,message,if,this,event,publisher,null,if,stomp,command,connect,equals,header,accessor,get,command,publish,event,new,session,connect,event,this,message,else,if,stomp,command,subscribe,equals,header,accessor,get,command,publish,event,new,session,subscribe,event,this,message,else,if,stomp,command,unsubscribe,equals,header,accessor,get,command,publish,event,new,session,unsubscribe,event,this,message,output,channel,send,message,finally,simp,attributes,context,holder,reset,attributes,catch,throwable,ex,logger,error,failed,to,send,client,message,to,application,via,message,channel,in,session,session,get,id,sending,stomp,error,to,client,ex,send,error,message,session,ex
StompSubProtocolHandler -> public void handleMessageFromClient(WebSocketSession session, 			WebSocketMessage<?> webSocketMessage, MessageChannel outputChannel);1413848647;Handle incoming WebSocket messages from clients.;public void handleMessageFromClient(WebSocketSession session,_			WebSocketMessage<?> webSocketMessage, MessageChannel outputChannel) {__		List<Message<byte[]>> messages__		try {_			ByteBuffer byteBuffer__			if (webSocketMessage instanceof TextMessage) {_				byteBuffer = ByteBuffer.wrap(((TextMessage) webSocketMessage).asBytes())__			}_			else if (webSocketMessage instanceof BinaryMessage) {_				byteBuffer = ((BinaryMessage) webSocketMessage).getPayload()__			}_			else {_				throw new IllegalArgumentException("Unexpected WebSocket message type: " + webSocketMessage)__			}__			BufferingStompDecoder decoder = this.decoders.get(session.getId())__			if (decoder == null) {_				throw new IllegalStateException("No decoder for session id '" + session.getId() + "'")__			}__			messages = decoder.decode(byteBuffer)__			if (messages.isEmpty()) {_				if (logger.isTraceEnabled()) {_					logger.trace("Incomplete STOMP frame content received in session " +_							session + ", bufferSize=" + decoder.getBufferSize() +_							", bufferSizeLimit=" + decoder.getBufferSizeLimit() + ".")__				}_				return__			}_		}_		catch (Throwable ex) {_			if (logger.isErrorEnabled()) {_				logger.error("Failed to parse " + webSocketMessage +_						" in session " + session.getId() + ". Sending STOMP ERROR to client.", ex)__			}_			sendErrorMessage(session, ex)__			return__		}__		for (Message<byte[]> message : messages) {_			try {_				StompHeaderAccessor headerAccessor =_						MessageHeaderAccessor.getAccessor(message, StompHeaderAccessor.class)___				if (logger.isTraceEnabled()) {_					logger.trace("From client: " + headerAccessor.getShortLogMessage(message.getPayload()))__				}__				headerAccessor.setSessionId(session.getId())__				headerAccessor.setSessionAttributes(session.getAttributes())__				headerAccessor.setUser(session.getPrincipal())__				headerAccessor.setImmutable()___				if (StompCommand.CONNECT.equals(headerAccessor.getCommand())) {_					this.stats.incrementConnectCount()__				}_				else if (StompCommand.DISCONNECT.equals(headerAccessor.getCommand())) {_					this.stats.incrementDisconnectCount()__				}__				try {_					SimpAttributesContextHolder.setAttributesFromMessage(message)__					if (this.eventPublisher != null) {_						if (StompCommand.CONNECT.equals(headerAccessor.getCommand())) {_							publishEvent(new SessionConnectEvent(this, message))__						}_						else if (StompCommand.SUBSCRIBE.equals(headerAccessor.getCommand())) {_							publishEvent(new SessionSubscribeEvent(this, message))__						}_						else if (StompCommand.UNSUBSCRIBE.equals(headerAccessor.getCommand())) {_							publishEvent(new SessionUnsubscribeEvent(this, message))__						}_					}_					outputChannel.send(message)__				}_				finally {_					SimpAttributesContextHolder.resetAttributes()__				}_			}_			catch (Throwable ex) {_				logger.error("Failed to send client message to application via MessageChannel" +_						" in session " + session.getId() + ". Sending STOMP ERROR to client.", ex)__				sendErrorMessage(session, ex)___			}_		}_	};handle,incoming,web,socket,messages,from,clients;public,void,handle,message,from,client,web,socket,session,session,web,socket,message,web,socket,message,message,channel,output,channel,list,message,byte,messages,try,byte,buffer,byte,buffer,if,web,socket,message,instanceof,text,message,byte,buffer,byte,buffer,wrap,text,message,web,socket,message,as,bytes,else,if,web,socket,message,instanceof,binary,message,byte,buffer,binary,message,web,socket,message,get,payload,else,throw,new,illegal,argument,exception,unexpected,web,socket,message,type,web,socket,message,buffering,stomp,decoder,decoder,this,decoders,get,session,get,id,if,decoder,null,throw,new,illegal,state,exception,no,decoder,for,session,id,session,get,id,messages,decoder,decode,byte,buffer,if,messages,is,empty,if,logger,is,trace,enabled,logger,trace,incomplete,stomp,frame,content,received,in,session,session,buffer,size,decoder,get,buffer,size,buffer,size,limit,decoder,get,buffer,size,limit,return,catch,throwable,ex,if,logger,is,error,enabled,logger,error,failed,to,parse,web,socket,message,in,session,session,get,id,sending,stomp,error,to,client,ex,send,error,message,session,ex,return,for,message,byte,message,messages,try,stomp,header,accessor,header,accessor,message,header,accessor,get,accessor,message,stomp,header,accessor,class,if,logger,is,trace,enabled,logger,trace,from,client,header,accessor,get,short,log,message,message,get,payload,header,accessor,set,session,id,session,get,id,header,accessor,set,session,attributes,session,get,attributes,header,accessor,set,user,session,get,principal,header,accessor,set,immutable,if,stomp,command,connect,equals,header,accessor,get,command,this,stats,increment,connect,count,else,if,stomp,command,disconnect,equals,header,accessor,get,command,this,stats,increment,disconnect,count,try,simp,attributes,context,holder,set,attributes,from,message,message,if,this,event,publisher,null,if,stomp,command,connect,equals,header,accessor,get,command,publish,event,new,session,connect,event,this,message,else,if,stomp,command,subscribe,equals,header,accessor,get,command,publish,event,new,session,subscribe,event,this,message,else,if,stomp,command,unsubscribe,equals,header,accessor,get,command,publish,event,new,session,unsubscribe,event,this,message,output,channel,send,message,finally,simp,attributes,context,holder,reset,attributes,catch,throwable,ex,logger,error,failed,to,send,client,message,to,application,via,message,channel,in,session,session,get,id,sending,stomp,error,to,client,ex,send,error,message,session,ex
StompSubProtocolHandler -> public void handleMessageFromClient(WebSocketSession session, 			WebSocketMessage<?> webSocketMessage, MessageChannel outputChannel);1414092351;Handle incoming WebSocket messages from clients.;public void handleMessageFromClient(WebSocketSession session,_			WebSocketMessage<?> webSocketMessage, MessageChannel outputChannel) {__		List<Message<byte[]>> messages__		try {_			ByteBuffer byteBuffer__			if (webSocketMessage instanceof TextMessage) {_				byteBuffer = ByteBuffer.wrap(((TextMessage) webSocketMessage).asBytes())__			}_			else if (webSocketMessage instanceof BinaryMessage) {_				byteBuffer = ((BinaryMessage) webSocketMessage).getPayload()__			}_			else {_				throw new IllegalArgumentException("Unexpected WebSocket message type: " + webSocketMessage)__			}__			BufferingStompDecoder decoder = this.decoders.get(session.getId())__			if (decoder == null) {_				throw new IllegalStateException("No decoder for session id '" + session.getId() + "'")__			}__			messages = decoder.decode(byteBuffer)__			if (messages.isEmpty()) {_				if (logger.isTraceEnabled()) {_					logger.trace("Incomplete STOMP frame content received in session " +_							session + ", bufferSize=" + decoder.getBufferSize() +_							", bufferSizeLimit=" + decoder.getBufferSizeLimit() + ".")__				}_				return__			}_		}_		catch (Throwable ex) {_			if (logger.isErrorEnabled()) {_				logger.error("Failed to parse " + webSocketMessage +_						" in session " + session.getId() + ". Sending STOMP ERROR to client.", ex)__			}_			sendErrorMessage(session, ex)__			return__		}__		for (Message<byte[]> message : messages) {_			try {_				StompHeaderAccessor headerAccessor =_						MessageHeaderAccessor.getAccessor(message, StompHeaderAccessor.class)___				if (logger.isTraceEnabled()) {_					logger.trace("From client: " + headerAccessor.getShortLogMessage(message.getPayload()))__				}__				headerAccessor.setSessionId(session.getId())__				headerAccessor.setSessionAttributes(session.getAttributes())__				headerAccessor.setUser(session.getPrincipal())__				if (!detectImmutableMessageInterceptor(outputChannel)) {_					headerAccessor.setImmutable()__				}__				if (StompCommand.CONNECT.equals(headerAccessor.getCommand())) {_					this.stats.incrementConnectCount()__				}_				else if (StompCommand.DISCONNECT.equals(headerAccessor.getCommand())) {_					this.stats.incrementDisconnectCount()__				}__				try {_					SimpAttributesContextHolder.setAttributesFromMessage(message)__					if (this.eventPublisher != null) {_						if (StompCommand.CONNECT.equals(headerAccessor.getCommand())) {_							publishEvent(new SessionConnectEvent(this, message))__						}_						else if (StompCommand.SUBSCRIBE.equals(headerAccessor.getCommand())) {_							publishEvent(new SessionSubscribeEvent(this, message))__						}_						else if (StompCommand.UNSUBSCRIBE.equals(headerAccessor.getCommand())) {_							publishEvent(new SessionUnsubscribeEvent(this, message))__						}_					}_					outputChannel.send(message)__				}_				finally {_					SimpAttributesContextHolder.resetAttributes()__				}_			}_			catch (Throwable ex) {_				logger.error("Failed to send client message to application via MessageChannel" +_						" in session " + session.getId() + ". Sending STOMP ERROR to client.", ex)__				sendErrorMessage(session, ex)___			}_		}_	};handle,incoming,web,socket,messages,from,clients;public,void,handle,message,from,client,web,socket,session,session,web,socket,message,web,socket,message,message,channel,output,channel,list,message,byte,messages,try,byte,buffer,byte,buffer,if,web,socket,message,instanceof,text,message,byte,buffer,byte,buffer,wrap,text,message,web,socket,message,as,bytes,else,if,web,socket,message,instanceof,binary,message,byte,buffer,binary,message,web,socket,message,get,payload,else,throw,new,illegal,argument,exception,unexpected,web,socket,message,type,web,socket,message,buffering,stomp,decoder,decoder,this,decoders,get,session,get,id,if,decoder,null,throw,new,illegal,state,exception,no,decoder,for,session,id,session,get,id,messages,decoder,decode,byte,buffer,if,messages,is,empty,if,logger,is,trace,enabled,logger,trace,incomplete,stomp,frame,content,received,in,session,session,buffer,size,decoder,get,buffer,size,buffer,size,limit,decoder,get,buffer,size,limit,return,catch,throwable,ex,if,logger,is,error,enabled,logger,error,failed,to,parse,web,socket,message,in,session,session,get,id,sending,stomp,error,to,client,ex,send,error,message,session,ex,return,for,message,byte,message,messages,try,stomp,header,accessor,header,accessor,message,header,accessor,get,accessor,message,stomp,header,accessor,class,if,logger,is,trace,enabled,logger,trace,from,client,header,accessor,get,short,log,message,message,get,payload,header,accessor,set,session,id,session,get,id,header,accessor,set,session,attributes,session,get,attributes,header,accessor,set,user,session,get,principal,if,detect,immutable,message,interceptor,output,channel,header,accessor,set,immutable,if,stomp,command,connect,equals,header,accessor,get,command,this,stats,increment,connect,count,else,if,stomp,command,disconnect,equals,header,accessor,get,command,this,stats,increment,disconnect,count,try,simp,attributes,context,holder,set,attributes,from,message,message,if,this,event,publisher,null,if,stomp,command,connect,equals,header,accessor,get,command,publish,event,new,session,connect,event,this,message,else,if,stomp,command,subscribe,equals,header,accessor,get,command,publish,event,new,session,subscribe,event,this,message,else,if,stomp,command,unsubscribe,equals,header,accessor,get,command,publish,event,new,session,unsubscribe,event,this,message,output,channel,send,message,finally,simp,attributes,context,holder,reset,attributes,catch,throwable,ex,logger,error,failed,to,send,client,message,to,application,via,message,channel,in,session,session,get,id,sending,stomp,error,to,client,ex,send,error,message,session,ex
StompSubProtocolHandler -> public void handleMessageFromClient(WebSocketSession session, 			WebSocketMessage<?> webSocketMessage, MessageChannel outputChannel);1414158498;Handle incoming WebSocket messages from clients.;public void handleMessageFromClient(WebSocketSession session,_			WebSocketMessage<?> webSocketMessage, MessageChannel outputChannel) {__		List<Message<byte[]>> messages__		try {_			ByteBuffer byteBuffer__			if (webSocketMessage instanceof TextMessage) {_				byteBuffer = ByteBuffer.wrap(((TextMessage) webSocketMessage).asBytes())__			}_			else if (webSocketMessage instanceof BinaryMessage) {_				byteBuffer = ((BinaryMessage) webSocketMessage).getPayload()__			}_			else {_				throw new IllegalArgumentException("Unexpected WebSocket message type: " + webSocketMessage)__			}__			BufferingStompDecoder decoder = this.decoders.get(session.getId())__			if (decoder == null) {_				throw new IllegalStateException("No decoder for session id '" + session.getId() + "'")__			}__			messages = decoder.decode(byteBuffer)__			if (messages.isEmpty()) {_				if (logger.isTraceEnabled()) {_					logger.trace("Incomplete STOMP frame content received in session " +_							session + ", bufferSize=" + decoder.getBufferSize() +_							", bufferSizeLimit=" + decoder.getBufferSizeLimit() + ".")__				}_				return__			}_		}_		catch (Throwable ex) {_			if (logger.isErrorEnabled()) {_				logger.error("Failed to parse " + webSocketMessage +_						" in session " + session.getId() + ". Sending STOMP ERROR to client.", ex)__			}_			sendErrorMessage(session, ex)__			return__		}__		for (Message<byte[]> message : messages) {_			try {_				StompHeaderAccessor headerAccessor =_						MessageHeaderAccessor.getAccessor(message, StompHeaderAccessor.class)___				if (logger.isTraceEnabled()) {_					logger.trace("From client: " + headerAccessor.getShortLogMessage(message.getPayload()))__				}__				headerAccessor.setSessionId(session.getId())__				headerAccessor.setSessionAttributes(session.getAttributes())__				headerAccessor.setUser(session.getPrincipal())__				if (!detectImmutableMessageInterceptor(outputChannel)) {_					headerAccessor.setImmutable()__				}__				if (StompCommand.CONNECT.equals(headerAccessor.getCommand())) {_					this.stats.incrementConnectCount()__				}_				else if (StompCommand.DISCONNECT.equals(headerAccessor.getCommand())) {_					this.stats.incrementDisconnectCount()__				}__				try {_					SimpAttributesContextHolder.setAttributesFromMessage(message)__					if (this.eventPublisher != null) {_						if (StompCommand.CONNECT.equals(headerAccessor.getCommand())) {_							publishEvent(new SessionConnectEvent(this, message))__						}_						else if (StompCommand.SUBSCRIBE.equals(headerAccessor.getCommand())) {_							publishEvent(new SessionSubscribeEvent(this, message))__						}_						else if (StompCommand.UNSUBSCRIBE.equals(headerAccessor.getCommand())) {_							publishEvent(new SessionUnsubscribeEvent(this, message))__						}_					}_					outputChannel.send(message)__				}_				finally {_					SimpAttributesContextHolder.resetAttributes()__				}_			}_			catch (Throwable ex) {_				logger.error("Failed to send client message to application via MessageChannel" +_						" in session " + session.getId() + ". Sending STOMP ERROR to client.", ex)__				sendErrorMessage(session, ex)___			}_		}_	};handle,incoming,web,socket,messages,from,clients;public,void,handle,message,from,client,web,socket,session,session,web,socket,message,web,socket,message,message,channel,output,channel,list,message,byte,messages,try,byte,buffer,byte,buffer,if,web,socket,message,instanceof,text,message,byte,buffer,byte,buffer,wrap,text,message,web,socket,message,as,bytes,else,if,web,socket,message,instanceof,binary,message,byte,buffer,binary,message,web,socket,message,get,payload,else,throw,new,illegal,argument,exception,unexpected,web,socket,message,type,web,socket,message,buffering,stomp,decoder,decoder,this,decoders,get,session,get,id,if,decoder,null,throw,new,illegal,state,exception,no,decoder,for,session,id,session,get,id,messages,decoder,decode,byte,buffer,if,messages,is,empty,if,logger,is,trace,enabled,logger,trace,incomplete,stomp,frame,content,received,in,session,session,buffer,size,decoder,get,buffer,size,buffer,size,limit,decoder,get,buffer,size,limit,return,catch,throwable,ex,if,logger,is,error,enabled,logger,error,failed,to,parse,web,socket,message,in,session,session,get,id,sending,stomp,error,to,client,ex,send,error,message,session,ex,return,for,message,byte,message,messages,try,stomp,header,accessor,header,accessor,message,header,accessor,get,accessor,message,stomp,header,accessor,class,if,logger,is,trace,enabled,logger,trace,from,client,header,accessor,get,short,log,message,message,get,payload,header,accessor,set,session,id,session,get,id,header,accessor,set,session,attributes,session,get,attributes,header,accessor,set,user,session,get,principal,if,detect,immutable,message,interceptor,output,channel,header,accessor,set,immutable,if,stomp,command,connect,equals,header,accessor,get,command,this,stats,increment,connect,count,else,if,stomp,command,disconnect,equals,header,accessor,get,command,this,stats,increment,disconnect,count,try,simp,attributes,context,holder,set,attributes,from,message,message,if,this,event,publisher,null,if,stomp,command,connect,equals,header,accessor,get,command,publish,event,new,session,connect,event,this,message,else,if,stomp,command,subscribe,equals,header,accessor,get,command,publish,event,new,session,subscribe,event,this,message,else,if,stomp,command,unsubscribe,equals,header,accessor,get,command,publish,event,new,session,unsubscribe,event,this,message,output,channel,send,message,finally,simp,attributes,context,holder,reset,attributes,catch,throwable,ex,logger,error,failed,to,send,client,message,to,application,via,message,channel,in,session,session,get,id,sending,stomp,error,to,client,ex,send,error,message,session,ex
StompSubProtocolHandler -> public void handleMessageFromClient(WebSocketSession session, 			WebSocketMessage<?> webSocketMessage, MessageChannel outputChannel);1419362683;Handle incoming WebSocket messages from clients.;public void handleMessageFromClient(WebSocketSession session,_			WebSocketMessage<?> webSocketMessage, MessageChannel outputChannel) {__		List<Message<byte[]>> messages__		try {_			ByteBuffer byteBuffer__			if (webSocketMessage instanceof TextMessage) {_				byteBuffer = ByteBuffer.wrap(((TextMessage) webSocketMessage).asBytes())__			}_			else if (webSocketMessage instanceof BinaryMessage) {_				byteBuffer = ((BinaryMessage) webSocketMessage).getPayload()__			}_			else {_				throw new IllegalArgumentException("Unexpected WebSocket message type: " + webSocketMessage)__			}__			BufferingStompDecoder decoder = this.decoders.get(session.getId())__			if (decoder == null) {_				throw new IllegalStateException("No decoder for session id '" + session.getId() + "'")__			}__			messages = decoder.decode(byteBuffer)__			if (messages.isEmpty()) {_				if (logger.isTraceEnabled()) {_					logger.trace("Incomplete STOMP frame content received in session " +_							session + ", bufferSize=" + decoder.getBufferSize() +_							", bufferSizeLimit=" + decoder.getBufferSizeLimit() + ".")__				}_				return__			}_		}_		catch (Throwable ex) {_			if (logger.isErrorEnabled()) {_				logger.error("Failed to parse " + webSocketMessage +_						" in session " + session.getId() + ". Sending STOMP ERROR to client.", ex)__			}_			sendErrorMessage(session, ex)__			return__		}__		for (Message<byte[]> message : messages) {_			try {_				StompHeaderAccessor headerAccessor =_						MessageHeaderAccessor.getAccessor(message, StompHeaderAccessor.class)___				if (logger.isTraceEnabled()) {_					logger.trace("From client: " + headerAccessor.getShortLogMessage(message.getPayload()))__				}__				headerAccessor.setSessionId(session.getId())__				headerAccessor.setSessionAttributes(session.getAttributes())__				headerAccessor.setUser(session.getPrincipal())__				if (!detectImmutableMessageInterceptor(outputChannel)) {_					headerAccessor.setImmutable()__				}__				if (StompCommand.CONNECT.equals(headerAccessor.getCommand())) {_					this.stats.incrementConnectCount()__				}_				else if (StompCommand.DISCONNECT.equals(headerAccessor.getCommand())) {_					this.stats.incrementDisconnectCount()__				}__				try {_					SimpAttributesContextHolder.setAttributesFromMessage(message)__					if (this.eventPublisher != null) {_						if (StompCommand.CONNECT.equals(headerAccessor.getCommand())) {_							publishEvent(new SessionConnectEvent(this, message))__						}_						else if (StompCommand.SUBSCRIBE.equals(headerAccessor.getCommand())) {_							publishEvent(new SessionSubscribeEvent(this, message))__						}_						else if (StompCommand.UNSUBSCRIBE.equals(headerAccessor.getCommand())) {_							publishEvent(new SessionUnsubscribeEvent(this, message))__						}_					}_					outputChannel.send(message)__				}_				finally {_					SimpAttributesContextHolder.resetAttributes()__				}_			}_			catch (Throwable ex) {_				logger.error("Failed to send client message to application via MessageChannel" +_						" in session " + session.getId() + ". Sending STOMP ERROR to client.", ex)__				sendErrorMessage(session, ex)___			}_		}_	};handle,incoming,web,socket,messages,from,clients;public,void,handle,message,from,client,web,socket,session,session,web,socket,message,web,socket,message,message,channel,output,channel,list,message,byte,messages,try,byte,buffer,byte,buffer,if,web,socket,message,instanceof,text,message,byte,buffer,byte,buffer,wrap,text,message,web,socket,message,as,bytes,else,if,web,socket,message,instanceof,binary,message,byte,buffer,binary,message,web,socket,message,get,payload,else,throw,new,illegal,argument,exception,unexpected,web,socket,message,type,web,socket,message,buffering,stomp,decoder,decoder,this,decoders,get,session,get,id,if,decoder,null,throw,new,illegal,state,exception,no,decoder,for,session,id,session,get,id,messages,decoder,decode,byte,buffer,if,messages,is,empty,if,logger,is,trace,enabled,logger,trace,incomplete,stomp,frame,content,received,in,session,session,buffer,size,decoder,get,buffer,size,buffer,size,limit,decoder,get,buffer,size,limit,return,catch,throwable,ex,if,logger,is,error,enabled,logger,error,failed,to,parse,web,socket,message,in,session,session,get,id,sending,stomp,error,to,client,ex,send,error,message,session,ex,return,for,message,byte,message,messages,try,stomp,header,accessor,header,accessor,message,header,accessor,get,accessor,message,stomp,header,accessor,class,if,logger,is,trace,enabled,logger,trace,from,client,header,accessor,get,short,log,message,message,get,payload,header,accessor,set,session,id,session,get,id,header,accessor,set,session,attributes,session,get,attributes,header,accessor,set,user,session,get,principal,if,detect,immutable,message,interceptor,output,channel,header,accessor,set,immutable,if,stomp,command,connect,equals,header,accessor,get,command,this,stats,increment,connect,count,else,if,stomp,command,disconnect,equals,header,accessor,get,command,this,stats,increment,disconnect,count,try,simp,attributes,context,holder,set,attributes,from,message,message,if,this,event,publisher,null,if,stomp,command,connect,equals,header,accessor,get,command,publish,event,new,session,connect,event,this,message,else,if,stomp,command,subscribe,equals,header,accessor,get,command,publish,event,new,session,subscribe,event,this,message,else,if,stomp,command,unsubscribe,equals,header,accessor,get,command,publish,event,new,session,unsubscribe,event,this,message,output,channel,send,message,finally,simp,attributes,context,holder,reset,attributes,catch,throwable,ex,logger,error,failed,to,send,client,message,to,application,via,message,channel,in,session,session,get,id,sending,stomp,error,to,client,ex,send,error,message,session,ex
StompSubProtocolHandler -> public void handleMessageFromClient(WebSocketSession session, 			WebSocketMessage<?> webSocketMessage, MessageChannel outputChannel);1419883989;Handle incoming WebSocket messages from clients.;public void handleMessageFromClient(WebSocketSession session,_			WebSocketMessage<?> webSocketMessage, MessageChannel outputChannel) {__		List<Message<byte[]>> messages__		try {_			ByteBuffer byteBuffer__			if (webSocketMessage instanceof TextMessage) {_				byteBuffer = ByteBuffer.wrap(((TextMessage) webSocketMessage).asBytes())__			}_			else if (webSocketMessage instanceof BinaryMessage) {_				byteBuffer = ((BinaryMessage) webSocketMessage).getPayload()__			}_			else {_				throw new IllegalArgumentException("Unexpected WebSocket message type: " + webSocketMessage)__			}__			BufferingStompDecoder decoder = this.decoders.get(session.getId())__			if (decoder == null) {_				throw new IllegalStateException("No decoder for session id '" + session.getId() + "'")__			}__			messages = decoder.decode(byteBuffer)__			if (messages.isEmpty()) {_				if (logger.isTraceEnabled()) {_					logger.trace("Incomplete STOMP frame content received in session " +_							session + ", bufferSize=" + decoder.getBufferSize() +_							", bufferSizeLimit=" + decoder.getBufferSizeLimit() + ".")__				}_				return__			}_		}_		catch (Throwable ex) {_			if (logger.isErrorEnabled()) {_				logger.error("Failed to parse " + webSocketMessage +_						" in session " + session.getId() + ". Sending STOMP ERROR to client.", ex)__			}_			sendErrorMessage(session, ex)__			return__		}__		for (Message<byte[]> message : messages) {_			try {_				StompHeaderAccessor headerAccessor =_						MessageHeaderAccessor.getAccessor(message, StompHeaderAccessor.class)___				if (logger.isTraceEnabled()) {_					logger.trace("From client: " + headerAccessor.getShortLogMessage(message.getPayload()))__				}__				headerAccessor.setSessionId(session.getId())__				headerAccessor.setSessionAttributes(session.getAttributes())__				headerAccessor.setUser(session.getPrincipal())__				if (!detectImmutableMessageInterceptor(outputChannel)) {_					headerAccessor.setImmutable()__				}__				if (StompCommand.CONNECT.equals(headerAccessor.getCommand())) {_					this.stats.incrementConnectCount()__				}_				else if (StompCommand.DISCONNECT.equals(headerAccessor.getCommand())) {_					this.stats.incrementDisconnectCount()__				}__				try {_					SimpAttributesContextHolder.setAttributesFromMessage(message)__					if (this.eventPublisher != null) {_						if (StompCommand.CONNECT.equals(headerAccessor.getCommand())) {_							publishEvent(new SessionConnectEvent(this, message))__						}_						else if (StompCommand.SUBSCRIBE.equals(headerAccessor.getCommand())) {_							publishEvent(new SessionSubscribeEvent(this, message))__						}_						else if (StompCommand.UNSUBSCRIBE.equals(headerAccessor.getCommand())) {_							publishEvent(new SessionUnsubscribeEvent(this, message))__						}_					}_					outputChannel.send(message)__				}_				finally {_					SimpAttributesContextHolder.resetAttributes()__				}_			}_			catch (Throwable ex) {_				logger.error("Failed to send client message to application via MessageChannel" +_						" in session " + session.getId() + ". Sending STOMP ERROR to client.", ex)__				sendErrorMessage(session, ex)___			}_		}_	};handle,incoming,web,socket,messages,from,clients;public,void,handle,message,from,client,web,socket,session,session,web,socket,message,web,socket,message,message,channel,output,channel,list,message,byte,messages,try,byte,buffer,byte,buffer,if,web,socket,message,instanceof,text,message,byte,buffer,byte,buffer,wrap,text,message,web,socket,message,as,bytes,else,if,web,socket,message,instanceof,binary,message,byte,buffer,binary,message,web,socket,message,get,payload,else,throw,new,illegal,argument,exception,unexpected,web,socket,message,type,web,socket,message,buffering,stomp,decoder,decoder,this,decoders,get,session,get,id,if,decoder,null,throw,new,illegal,state,exception,no,decoder,for,session,id,session,get,id,messages,decoder,decode,byte,buffer,if,messages,is,empty,if,logger,is,trace,enabled,logger,trace,incomplete,stomp,frame,content,received,in,session,session,buffer,size,decoder,get,buffer,size,buffer,size,limit,decoder,get,buffer,size,limit,return,catch,throwable,ex,if,logger,is,error,enabled,logger,error,failed,to,parse,web,socket,message,in,session,session,get,id,sending,stomp,error,to,client,ex,send,error,message,session,ex,return,for,message,byte,message,messages,try,stomp,header,accessor,header,accessor,message,header,accessor,get,accessor,message,stomp,header,accessor,class,if,logger,is,trace,enabled,logger,trace,from,client,header,accessor,get,short,log,message,message,get,payload,header,accessor,set,session,id,session,get,id,header,accessor,set,session,attributes,session,get,attributes,header,accessor,set,user,session,get,principal,if,detect,immutable,message,interceptor,output,channel,header,accessor,set,immutable,if,stomp,command,connect,equals,header,accessor,get,command,this,stats,increment,connect,count,else,if,stomp,command,disconnect,equals,header,accessor,get,command,this,stats,increment,disconnect,count,try,simp,attributes,context,holder,set,attributes,from,message,message,if,this,event,publisher,null,if,stomp,command,connect,equals,header,accessor,get,command,publish,event,new,session,connect,event,this,message,else,if,stomp,command,subscribe,equals,header,accessor,get,command,publish,event,new,session,subscribe,event,this,message,else,if,stomp,command,unsubscribe,equals,header,accessor,get,command,publish,event,new,session,unsubscribe,event,this,message,output,channel,send,message,finally,simp,attributes,context,holder,reset,attributes,catch,throwable,ex,logger,error,failed,to,send,client,message,to,application,via,message,channel,in,session,session,get,id,sending,stomp,error,to,client,ex,send,error,message,session,ex
StompSubProtocolHandler -> public void handleMessageFromClient(WebSocketSession session, 			WebSocketMessage<?> webSocketMessage, MessageChannel outputChannel);1424278379;Handle incoming WebSocket messages from clients.;public void handleMessageFromClient(WebSocketSession session,_			WebSocketMessage<?> webSocketMessage, MessageChannel outputChannel) {__		List<Message<byte[]>> messages__		try {_			ByteBuffer byteBuffer__			if (webSocketMessage instanceof TextMessage) {_				byteBuffer = ByteBuffer.wrap(((TextMessage) webSocketMessage).asBytes())__			}_			else if (webSocketMessage instanceof BinaryMessage) {_				byteBuffer = ((BinaryMessage) webSocketMessage).getPayload()__			}_			else {_				return__			}__			BufferingStompDecoder decoder = this.decoders.get(session.getId())__			if (decoder == null) {_				throw new IllegalStateException("No decoder for session id '" + session.getId() + "'")__			}__			messages = decoder.decode(byteBuffer)__			if (messages.isEmpty()) {_				if (logger.isTraceEnabled()) {_					logger.trace("Incomplete STOMP frame content received in session " +_							session + ", bufferSize=" + decoder.getBufferSize() +_							", bufferSizeLimit=" + decoder.getBufferSizeLimit() + ".")__				}_				return__			}_		}_		catch (Throwable ex) {_			if (logger.isErrorEnabled()) {_				logger.error("Failed to parse " + webSocketMessage +_						" in session " + session.getId() + ". Sending STOMP ERROR to client.", ex)__			}_			sendErrorMessage(session, ex)__			return__		}__		for (Message<byte[]> message : messages) {_			try {_				StompHeaderAccessor headerAccessor =_						MessageHeaderAccessor.getAccessor(message, StompHeaderAccessor.class)___				if (logger.isTraceEnabled()) {_					logger.trace("From client: " + headerAccessor.getShortLogMessage(message.getPayload()))__				}__				headerAccessor.setSessionId(session.getId())__				headerAccessor.setSessionAttributes(session.getAttributes())__				headerAccessor.setUser(session.getPrincipal())__				if (!detectImmutableMessageInterceptor(outputChannel)) {_					headerAccessor.setImmutable()__				}__				if (StompCommand.CONNECT.equals(headerAccessor.getCommand())) {_					this.stats.incrementConnectCount()__				}_				else if (StompCommand.DISCONNECT.equals(headerAccessor.getCommand())) {_					this.stats.incrementDisconnectCount()__				}__				try {_					SimpAttributesContextHolder.setAttributesFromMessage(message)__					if (this.eventPublisher != null) {_						if (StompCommand.CONNECT.equals(headerAccessor.getCommand())) {_							publishEvent(new SessionConnectEvent(this, message))__						}_						else if (StompCommand.SUBSCRIBE.equals(headerAccessor.getCommand())) {_							publishEvent(new SessionSubscribeEvent(this, message))__						}_						else if (StompCommand.UNSUBSCRIBE.equals(headerAccessor.getCommand())) {_							publishEvent(new SessionUnsubscribeEvent(this, message))__						}_					}_					outputChannel.send(message)__				}_				finally {_					SimpAttributesContextHolder.resetAttributes()__				}_			}_			catch (Throwable ex) {_				logger.error("Failed to send client message to application via MessageChannel" +_						" in session " + session.getId() + ". Sending STOMP ERROR to client.", ex)__				sendErrorMessage(session, ex)___			}_		}_	};handle,incoming,web,socket,messages,from,clients;public,void,handle,message,from,client,web,socket,session,session,web,socket,message,web,socket,message,message,channel,output,channel,list,message,byte,messages,try,byte,buffer,byte,buffer,if,web,socket,message,instanceof,text,message,byte,buffer,byte,buffer,wrap,text,message,web,socket,message,as,bytes,else,if,web,socket,message,instanceof,binary,message,byte,buffer,binary,message,web,socket,message,get,payload,else,return,buffering,stomp,decoder,decoder,this,decoders,get,session,get,id,if,decoder,null,throw,new,illegal,state,exception,no,decoder,for,session,id,session,get,id,messages,decoder,decode,byte,buffer,if,messages,is,empty,if,logger,is,trace,enabled,logger,trace,incomplete,stomp,frame,content,received,in,session,session,buffer,size,decoder,get,buffer,size,buffer,size,limit,decoder,get,buffer,size,limit,return,catch,throwable,ex,if,logger,is,error,enabled,logger,error,failed,to,parse,web,socket,message,in,session,session,get,id,sending,stomp,error,to,client,ex,send,error,message,session,ex,return,for,message,byte,message,messages,try,stomp,header,accessor,header,accessor,message,header,accessor,get,accessor,message,stomp,header,accessor,class,if,logger,is,trace,enabled,logger,trace,from,client,header,accessor,get,short,log,message,message,get,payload,header,accessor,set,session,id,session,get,id,header,accessor,set,session,attributes,session,get,attributes,header,accessor,set,user,session,get,principal,if,detect,immutable,message,interceptor,output,channel,header,accessor,set,immutable,if,stomp,command,connect,equals,header,accessor,get,command,this,stats,increment,connect,count,else,if,stomp,command,disconnect,equals,header,accessor,get,command,this,stats,increment,disconnect,count,try,simp,attributes,context,holder,set,attributes,from,message,message,if,this,event,publisher,null,if,stomp,command,connect,equals,header,accessor,get,command,publish,event,new,session,connect,event,this,message,else,if,stomp,command,subscribe,equals,header,accessor,get,command,publish,event,new,session,subscribe,event,this,message,else,if,stomp,command,unsubscribe,equals,header,accessor,get,command,publish,event,new,session,unsubscribe,event,this,message,output,channel,send,message,finally,simp,attributes,context,holder,reset,attributes,catch,throwable,ex,logger,error,failed,to,send,client,message,to,application,via,message,channel,in,session,session,get,id,sending,stomp,error,to,client,ex,send,error,message,session,ex
StompSubProtocolHandler -> public void handleMessageFromClient(WebSocketSession session, 			WebSocketMessage<?> webSocketMessage, MessageChannel outputChannel);1428353843;Handle incoming WebSocket messages from clients.;public void handleMessageFromClient(WebSocketSession session,_			WebSocketMessage<?> webSocketMessage, MessageChannel outputChannel) {__		List<Message<byte[]>> messages__		try {_			ByteBuffer byteBuffer__			if (webSocketMessage instanceof TextMessage) {_				byteBuffer = ByteBuffer.wrap(((TextMessage) webSocketMessage).asBytes())__			}_			else if (webSocketMessage instanceof BinaryMessage) {_				byteBuffer = ((BinaryMessage) webSocketMessage).getPayload()__			}_			else {_				return__			}__			BufferingStompDecoder decoder = this.decoders.get(session.getId())__			if (decoder == null) {_				throw new IllegalStateException("No decoder for session id '" + session.getId() + "'")__			}__			messages = decoder.decode(byteBuffer)__			if (messages.isEmpty()) {_				if (logger.isTraceEnabled()) {_					logger.trace("Incomplete STOMP frame content received in session " +_							session + ", bufferSize=" + decoder.getBufferSize() +_							", bufferSizeLimit=" + decoder.getBufferSizeLimit() + ".")__				}_				return__			}_		}_		catch (Throwable ex) {_			if (logger.isErrorEnabled()) {_				logger.error("Failed to parse " + webSocketMessage +_						" in session " + session.getId() + ". Sending STOMP ERROR to client.", ex)__			}_			sendErrorMessage(session, ex)__			return__		}__		for (Message<byte[]> message : messages) {_			try {_				StompHeaderAccessor headerAccessor =_						MessageHeaderAccessor.getAccessor(message, StompHeaderAccessor.class)___				headerAccessor.setSessionId(session.getId())__				headerAccessor.setSessionAttributes(session.getAttributes())__				headerAccessor.setUser(session.getPrincipal())__				headerAccessor.setHeader(SimpMessageHeaderAccessor.HEART_BEAT_HEADER, headerAccessor.getHeartbeat())__				if (!detectImmutableMessageInterceptor(outputChannel)) {_					headerAccessor.setImmutable()__				}__				if (logger.isTraceEnabled()) {_					logger.trace("From client: " + headerAccessor.getShortLogMessage(message.getPayload()))__				}__				if (StompCommand.CONNECT.equals(headerAccessor.getCommand())) {_					this.stats.incrementConnectCount()__				}_				else if (StompCommand.DISCONNECT.equals(headerAccessor.getCommand())) {_					this.stats.incrementDisconnectCount()__				}__				try {_					SimpAttributesContextHolder.setAttributesFromMessage(message)__					if (this.eventPublisher != null) {_						if (StompCommand.CONNECT.equals(headerAccessor.getCommand())) {_							publishEvent(new SessionConnectEvent(this, message))__						}_						else if (StompCommand.SUBSCRIBE.equals(headerAccessor.getCommand())) {_							publishEvent(new SessionSubscribeEvent(this, message))__						}_						else if (StompCommand.UNSUBSCRIBE.equals(headerAccessor.getCommand())) {_							publishEvent(new SessionUnsubscribeEvent(this, message))__						}_					}_					outputChannel.send(message)__				}_				finally {_					SimpAttributesContextHolder.resetAttributes()__				}_			}_			catch (Throwable ex) {_				logger.error("Failed to send client message to application via MessageChannel" +_						" in session " + session.getId() + ". Sending STOMP ERROR to client.", ex)__				sendErrorMessage(session, ex)___			}_		}_	};handle,incoming,web,socket,messages,from,clients;public,void,handle,message,from,client,web,socket,session,session,web,socket,message,web,socket,message,message,channel,output,channel,list,message,byte,messages,try,byte,buffer,byte,buffer,if,web,socket,message,instanceof,text,message,byte,buffer,byte,buffer,wrap,text,message,web,socket,message,as,bytes,else,if,web,socket,message,instanceof,binary,message,byte,buffer,binary,message,web,socket,message,get,payload,else,return,buffering,stomp,decoder,decoder,this,decoders,get,session,get,id,if,decoder,null,throw,new,illegal,state,exception,no,decoder,for,session,id,session,get,id,messages,decoder,decode,byte,buffer,if,messages,is,empty,if,logger,is,trace,enabled,logger,trace,incomplete,stomp,frame,content,received,in,session,session,buffer,size,decoder,get,buffer,size,buffer,size,limit,decoder,get,buffer,size,limit,return,catch,throwable,ex,if,logger,is,error,enabled,logger,error,failed,to,parse,web,socket,message,in,session,session,get,id,sending,stomp,error,to,client,ex,send,error,message,session,ex,return,for,message,byte,message,messages,try,stomp,header,accessor,header,accessor,message,header,accessor,get,accessor,message,stomp,header,accessor,class,header,accessor,set,session,id,session,get,id,header,accessor,set,session,attributes,session,get,attributes,header,accessor,set,user,session,get,principal,header,accessor,set,header,simp,message,header,accessor,header,accessor,get,heartbeat,if,detect,immutable,message,interceptor,output,channel,header,accessor,set,immutable,if,logger,is,trace,enabled,logger,trace,from,client,header,accessor,get,short,log,message,message,get,payload,if,stomp,command,connect,equals,header,accessor,get,command,this,stats,increment,connect,count,else,if,stomp,command,disconnect,equals,header,accessor,get,command,this,stats,increment,disconnect,count,try,simp,attributes,context,holder,set,attributes,from,message,message,if,this,event,publisher,null,if,stomp,command,connect,equals,header,accessor,get,command,publish,event,new,session,connect,event,this,message,else,if,stomp,command,subscribe,equals,header,accessor,get,command,publish,event,new,session,subscribe,event,this,message,else,if,stomp,command,unsubscribe,equals,header,accessor,get,command,publish,event,new,session,unsubscribe,event,this,message,output,channel,send,message,finally,simp,attributes,context,holder,reset,attributes,catch,throwable,ex,logger,error,failed,to,send,client,message,to,application,via,message,channel,in,session,session,get,id,sending,stomp,error,to,client,ex,send,error,message,session,ex
StompSubProtocolHandler -> public void handleMessageFromClient(WebSocketSession session, 			WebSocketMessage<?> webSocketMessage, MessageChannel outputChannel);1430834982;Handle incoming WebSocket messages from clients.;public void handleMessageFromClient(WebSocketSession session,_			WebSocketMessage<?> webSocketMessage, MessageChannel outputChannel) {__		List<Message<byte[]>> messages__		try {_			ByteBuffer byteBuffer__			if (webSocketMessage instanceof TextMessage) {_				byteBuffer = ByteBuffer.wrap(((TextMessage) webSocketMessage).asBytes())__			}_			else if (webSocketMessage instanceof BinaryMessage) {_				byteBuffer = ((BinaryMessage) webSocketMessage).getPayload()__			}_			else {_				return__			}__			BufferingStompDecoder decoder = this.decoders.get(session.getId())__			if (decoder == null) {_				throw new IllegalStateException("No decoder for session id '" + session.getId() + "'")__			}__			messages = decoder.decode(byteBuffer)__			if (messages.isEmpty()) {_				if (logger.isTraceEnabled()) {_					logger.trace("Incomplete STOMP frame content received in session " +_							session + ", bufferSize=" + decoder.getBufferSize() +_							", bufferSizeLimit=" + decoder.getBufferSizeLimit() + ".")__				}_				return__			}_		}_		catch (Throwable ex) {_			if (logger.isErrorEnabled()) {_				logger.error("Failed to parse " + webSocketMessage +_						" in session " + session.getId() + ". Sending STOMP ERROR to client.", ex)__			}_			sendErrorMessage(session, ex)__			return__		}__		for (Message<byte[]> message : messages) {_			try {_				StompHeaderAccessor headerAccessor =_						MessageHeaderAccessor.getAccessor(message, StompHeaderAccessor.class)___				headerAccessor.setSessionId(session.getId())__				headerAccessor.setSessionAttributes(session.getAttributes())__				headerAccessor.setUser(session.getPrincipal())__				headerAccessor.setHeader(SimpMessageHeaderAccessor.HEART_BEAT_HEADER, headerAccessor.getHeartbeat())__				if (!detectImmutableMessageInterceptor(outputChannel)) {_					headerAccessor.setImmutable()__				}__				if (logger.isTraceEnabled()) {_					logger.trace("From client: " + headerAccessor.getShortLogMessage(message.getPayload()))__				}__				if (StompCommand.CONNECT.equals(headerAccessor.getCommand())) {_					this.stats.incrementConnectCount()__				}_				else if (StompCommand.DISCONNECT.equals(headerAccessor.getCommand())) {_					this.stats.incrementDisconnectCount()__				}__				try {_					SimpAttributesContextHolder.setAttributesFromMessage(message)__					if (this.eventPublisher != null) {_						if (StompCommand.CONNECT.equals(headerAccessor.getCommand())) {_							publishEvent(new SessionConnectEvent(this, message))__						}_						else if (StompCommand.SUBSCRIBE.equals(headerAccessor.getCommand())) {_							publishEvent(new SessionSubscribeEvent(this, message))__						}_						else if (StompCommand.UNSUBSCRIBE.equals(headerAccessor.getCommand())) {_							publishEvent(new SessionUnsubscribeEvent(this, message))__						}_					}_					outputChannel.send(message)__				}_				finally {_					SimpAttributesContextHolder.resetAttributes()__				}_			}_			catch (Throwable ex) {_				logger.error("Failed to send client message to application via MessageChannel" +_						" in session " + session.getId() + ". Sending STOMP ERROR to client.", ex)__				sendErrorMessage(session, ex)___			}_		}_	};handle,incoming,web,socket,messages,from,clients;public,void,handle,message,from,client,web,socket,session,session,web,socket,message,web,socket,message,message,channel,output,channel,list,message,byte,messages,try,byte,buffer,byte,buffer,if,web,socket,message,instanceof,text,message,byte,buffer,byte,buffer,wrap,text,message,web,socket,message,as,bytes,else,if,web,socket,message,instanceof,binary,message,byte,buffer,binary,message,web,socket,message,get,payload,else,return,buffering,stomp,decoder,decoder,this,decoders,get,session,get,id,if,decoder,null,throw,new,illegal,state,exception,no,decoder,for,session,id,session,get,id,messages,decoder,decode,byte,buffer,if,messages,is,empty,if,logger,is,trace,enabled,logger,trace,incomplete,stomp,frame,content,received,in,session,session,buffer,size,decoder,get,buffer,size,buffer,size,limit,decoder,get,buffer,size,limit,return,catch,throwable,ex,if,logger,is,error,enabled,logger,error,failed,to,parse,web,socket,message,in,session,session,get,id,sending,stomp,error,to,client,ex,send,error,message,session,ex,return,for,message,byte,message,messages,try,stomp,header,accessor,header,accessor,message,header,accessor,get,accessor,message,stomp,header,accessor,class,header,accessor,set,session,id,session,get,id,header,accessor,set,session,attributes,session,get,attributes,header,accessor,set,user,session,get,principal,header,accessor,set,header,simp,message,header,accessor,header,accessor,get,heartbeat,if,detect,immutable,message,interceptor,output,channel,header,accessor,set,immutable,if,logger,is,trace,enabled,logger,trace,from,client,header,accessor,get,short,log,message,message,get,payload,if,stomp,command,connect,equals,header,accessor,get,command,this,stats,increment,connect,count,else,if,stomp,command,disconnect,equals,header,accessor,get,command,this,stats,increment,disconnect,count,try,simp,attributes,context,holder,set,attributes,from,message,message,if,this,event,publisher,null,if,stomp,command,connect,equals,header,accessor,get,command,publish,event,new,session,connect,event,this,message,else,if,stomp,command,subscribe,equals,header,accessor,get,command,publish,event,new,session,subscribe,event,this,message,else,if,stomp,command,unsubscribe,equals,header,accessor,get,command,publish,event,new,session,unsubscribe,event,this,message,output,channel,send,message,finally,simp,attributes,context,holder,reset,attributes,catch,throwable,ex,logger,error,failed,to,send,client,message,to,application,via,message,channel,in,session,session,get,id,sending,stomp,error,to,client,ex,send,error,message,session,ex
StompSubProtocolHandler -> public void handleMessageFromClient(WebSocketSession session, 			WebSocketMessage<?> webSocketMessage, MessageChannel outputChannel);1431458952;Handle incoming WebSocket messages from clients.;public void handleMessageFromClient(WebSocketSession session,_			WebSocketMessage<?> webSocketMessage, MessageChannel outputChannel) {__		List<Message<byte[]>> messages__		try {_			ByteBuffer byteBuffer__			if (webSocketMessage instanceof TextMessage) {_				byteBuffer = ByteBuffer.wrap(((TextMessage) webSocketMessage).asBytes())__			}_			else if (webSocketMessage instanceof BinaryMessage) {_				byteBuffer = ((BinaryMessage) webSocketMessage).getPayload()__			}_			else {_				return__			}__			BufferingStompDecoder decoder = this.decoders.get(session.getId())__			if (decoder == null) {_				throw new IllegalStateException("No decoder for session id '" + session.getId() + "'")__			}__			messages = decoder.decode(byteBuffer)__			if (messages.isEmpty()) {_				if (logger.isTraceEnabled()) {_					logger.trace("Incomplete STOMP frame content received in session " +_							session + ", bufferSize=" + decoder.getBufferSize() +_							", bufferSizeLimit=" + decoder.getBufferSizeLimit() + ".")__				}_				return__			}_		}_		catch (Throwable ex) {_			if (logger.isErrorEnabled()) {_				logger.error("Failed to parse " + webSocketMessage +_						" in session " + session.getId() + ". Sending STOMP ERROR to client.", ex)__			}_			sendErrorMessage(session, ex)__			return__		}__		for (Message<byte[]> message : messages) {_			try {_				StompHeaderAccessor headerAccessor =_						MessageHeaderAccessor.getAccessor(message, StompHeaderAccessor.class)___				Principal user = session.getPrincipal()___				headerAccessor.setSessionId(session.getId())__				headerAccessor.setSessionAttributes(session.getAttributes())__				headerAccessor.setUser(user)__				headerAccessor.setHeader(SimpMessageHeaderAccessor.HEART_BEAT_HEADER, headerAccessor.getHeartbeat())__				if (!detectImmutableMessageInterceptor(outputChannel)) {_					headerAccessor.setImmutable()__				}__				if (logger.isTraceEnabled()) {_					logger.trace("From client: " + headerAccessor.getShortLogMessage(message.getPayload()))__				}__				if (StompCommand.CONNECT.equals(headerAccessor.getCommand())) {_					this.stats.incrementConnectCount()__				}_				else if (StompCommand.DISCONNECT.equals(headerAccessor.getCommand())) {_					this.stats.incrementDisconnectCount()__				}__				try {_					SimpAttributesContextHolder.setAttributesFromMessage(message)__					if (this.eventPublisher != null) {_						if (StompCommand.CONNECT.equals(headerAccessor.getCommand())) {_							publishEvent(new SessionConnectEvent(this, message, user))__						}_						else if (StompCommand.SUBSCRIBE.equals(headerAccessor.getCommand())) {_							publishEvent(new SessionSubscribeEvent(this, message, user))__						}_						else if (StompCommand.UNSUBSCRIBE.equals(headerAccessor.getCommand())) {_							publishEvent(new SessionUnsubscribeEvent(this, message, user))__						}_					}_					outputChannel.send(message)__				}_				finally {_					SimpAttributesContextHolder.resetAttributes()__				}_			}_			catch (Throwable ex) {_				logger.error("Failed to send client message to application via MessageChannel" +_						" in session " + session.getId() + ". Sending STOMP ERROR to client.", ex)__				sendErrorMessage(session, ex)___			}_		}_	};handle,incoming,web,socket,messages,from,clients;public,void,handle,message,from,client,web,socket,session,session,web,socket,message,web,socket,message,message,channel,output,channel,list,message,byte,messages,try,byte,buffer,byte,buffer,if,web,socket,message,instanceof,text,message,byte,buffer,byte,buffer,wrap,text,message,web,socket,message,as,bytes,else,if,web,socket,message,instanceof,binary,message,byte,buffer,binary,message,web,socket,message,get,payload,else,return,buffering,stomp,decoder,decoder,this,decoders,get,session,get,id,if,decoder,null,throw,new,illegal,state,exception,no,decoder,for,session,id,session,get,id,messages,decoder,decode,byte,buffer,if,messages,is,empty,if,logger,is,trace,enabled,logger,trace,incomplete,stomp,frame,content,received,in,session,session,buffer,size,decoder,get,buffer,size,buffer,size,limit,decoder,get,buffer,size,limit,return,catch,throwable,ex,if,logger,is,error,enabled,logger,error,failed,to,parse,web,socket,message,in,session,session,get,id,sending,stomp,error,to,client,ex,send,error,message,session,ex,return,for,message,byte,message,messages,try,stomp,header,accessor,header,accessor,message,header,accessor,get,accessor,message,stomp,header,accessor,class,principal,user,session,get,principal,header,accessor,set,session,id,session,get,id,header,accessor,set,session,attributes,session,get,attributes,header,accessor,set,user,user,header,accessor,set,header,simp,message,header,accessor,header,accessor,get,heartbeat,if,detect,immutable,message,interceptor,output,channel,header,accessor,set,immutable,if,logger,is,trace,enabled,logger,trace,from,client,header,accessor,get,short,log,message,message,get,payload,if,stomp,command,connect,equals,header,accessor,get,command,this,stats,increment,connect,count,else,if,stomp,command,disconnect,equals,header,accessor,get,command,this,stats,increment,disconnect,count,try,simp,attributes,context,holder,set,attributes,from,message,message,if,this,event,publisher,null,if,stomp,command,connect,equals,header,accessor,get,command,publish,event,new,session,connect,event,this,message,user,else,if,stomp,command,subscribe,equals,header,accessor,get,command,publish,event,new,session,subscribe,event,this,message,user,else,if,stomp,command,unsubscribe,equals,header,accessor,get,command,publish,event,new,session,unsubscribe,event,this,message,user,output,channel,send,message,finally,simp,attributes,context,holder,reset,attributes,catch,throwable,ex,logger,error,failed,to,send,client,message,to,application,via,message,channel,in,session,session,get,id,sending,stomp,error,to,client,ex,send,error,message,session,ex
StompSubProtocolHandler -> public void handleMessageFromClient(WebSocketSession session, 			WebSocketMessage<?> webSocketMessage, MessageChannel outputChannel);1431728285;Handle incoming WebSocket messages from clients.;public void handleMessageFromClient(WebSocketSession session,_			WebSocketMessage<?> webSocketMessage, MessageChannel outputChannel) {__		List<Message<byte[]>> messages__		try {_			ByteBuffer byteBuffer__			if (webSocketMessage instanceof TextMessage) {_				byteBuffer = ByteBuffer.wrap(((TextMessage) webSocketMessage).asBytes())__			}_			else if (webSocketMessage instanceof BinaryMessage) {_				byteBuffer = ((BinaryMessage) webSocketMessage).getPayload()__			}_			else {_				return__			}__			BufferingStompDecoder decoder = this.decoders.get(session.getId())__			if (decoder == null) {_				throw new IllegalStateException("No decoder for session id '" + session.getId() + "'")__			}__			messages = decoder.decode(byteBuffer)__			if (messages.isEmpty()) {_				if (logger.isTraceEnabled()) {_					logger.trace("Incomplete STOMP frame content received in session " +_							session + ", bufferSize=" + decoder.getBufferSize() +_							", bufferSizeLimit=" + decoder.getBufferSizeLimit() + ".")__				}_				return__			}_		}_		catch (Throwable ex) {_			if (logger.isErrorEnabled()) {_				logger.error("Failed to parse " + webSocketMessage +_						" in session " + session.getId() + ". Sending STOMP ERROR to client.", ex)__			}_			handleError(session, ex, null)__			return__		}__		for (Message<byte[]> message : messages) {_			try {_				StompHeaderAccessor headerAccessor =_						MessageHeaderAccessor.getAccessor(message, StompHeaderAccessor.class)___				Principal user = session.getPrincipal()___				headerAccessor.setSessionId(session.getId())__				headerAccessor.setSessionAttributes(session.getAttributes())__				headerAccessor.setUser(user)__				headerAccessor.setHeader(SimpMessageHeaderAccessor.HEART_BEAT_HEADER, headerAccessor.getHeartbeat())__				if (!detectImmutableMessageInterceptor(outputChannel)) {_					headerAccessor.setImmutable()__				}__				if (logger.isTraceEnabled()) {_					logger.trace("From client: " + headerAccessor.getShortLogMessage(message.getPayload()))__				}__				if (StompCommand.CONNECT.equals(headerAccessor.getCommand())) {_					this.stats.incrementConnectCount()__				}_				else if (StompCommand.DISCONNECT.equals(headerAccessor.getCommand())) {_					this.stats.incrementDisconnectCount()__				}__				try {_					SimpAttributesContextHolder.setAttributesFromMessage(message)__					if (this.eventPublisher != null) {_						if (StompCommand.CONNECT.equals(headerAccessor.getCommand())) {_							publishEvent(new SessionConnectEvent(this, message, user))__						}_						else if (StompCommand.SUBSCRIBE.equals(headerAccessor.getCommand())) {_							publishEvent(new SessionSubscribeEvent(this, message, user))__						}_						else if (StompCommand.UNSUBSCRIBE.equals(headerAccessor.getCommand())) {_							publishEvent(new SessionUnsubscribeEvent(this, message, user))__						}_					}_					outputChannel.send(message)__				}_				finally {_					SimpAttributesContextHolder.resetAttributes()__				}_			}_			catch (Throwable ex) {_				logger.error("Failed to send client message to application via MessageChannel" +_						" in session " + session.getId() + ". Sending STOMP ERROR to client.", ex)__				handleError(session, ex, message)__			}_		}_	};handle,incoming,web,socket,messages,from,clients;public,void,handle,message,from,client,web,socket,session,session,web,socket,message,web,socket,message,message,channel,output,channel,list,message,byte,messages,try,byte,buffer,byte,buffer,if,web,socket,message,instanceof,text,message,byte,buffer,byte,buffer,wrap,text,message,web,socket,message,as,bytes,else,if,web,socket,message,instanceof,binary,message,byte,buffer,binary,message,web,socket,message,get,payload,else,return,buffering,stomp,decoder,decoder,this,decoders,get,session,get,id,if,decoder,null,throw,new,illegal,state,exception,no,decoder,for,session,id,session,get,id,messages,decoder,decode,byte,buffer,if,messages,is,empty,if,logger,is,trace,enabled,logger,trace,incomplete,stomp,frame,content,received,in,session,session,buffer,size,decoder,get,buffer,size,buffer,size,limit,decoder,get,buffer,size,limit,return,catch,throwable,ex,if,logger,is,error,enabled,logger,error,failed,to,parse,web,socket,message,in,session,session,get,id,sending,stomp,error,to,client,ex,handle,error,session,ex,null,return,for,message,byte,message,messages,try,stomp,header,accessor,header,accessor,message,header,accessor,get,accessor,message,stomp,header,accessor,class,principal,user,session,get,principal,header,accessor,set,session,id,session,get,id,header,accessor,set,session,attributes,session,get,attributes,header,accessor,set,user,user,header,accessor,set,header,simp,message,header,accessor,header,accessor,get,heartbeat,if,detect,immutable,message,interceptor,output,channel,header,accessor,set,immutable,if,logger,is,trace,enabled,logger,trace,from,client,header,accessor,get,short,log,message,message,get,payload,if,stomp,command,connect,equals,header,accessor,get,command,this,stats,increment,connect,count,else,if,stomp,command,disconnect,equals,header,accessor,get,command,this,stats,increment,disconnect,count,try,simp,attributes,context,holder,set,attributes,from,message,message,if,this,event,publisher,null,if,stomp,command,connect,equals,header,accessor,get,command,publish,event,new,session,connect,event,this,message,user,else,if,stomp,command,subscribe,equals,header,accessor,get,command,publish,event,new,session,subscribe,event,this,message,user,else,if,stomp,command,unsubscribe,equals,header,accessor,get,command,publish,event,new,session,unsubscribe,event,this,message,user,output,channel,send,message,finally,simp,attributes,context,holder,reset,attributes,catch,throwable,ex,logger,error,failed,to,send,client,message,to,application,via,message,channel,in,session,session,get,id,sending,stomp,error,to,client,ex,handle,error,session,ex,message
StompSubProtocolHandler -> public void handleMessageFromClient(WebSocketSession session, 			WebSocketMessage<?> webSocketMessage, MessageChannel outputChannel);1432316649;Handle incoming WebSocket messages from clients.;public void handleMessageFromClient(WebSocketSession session,_			WebSocketMessage<?> webSocketMessage, MessageChannel outputChannel) {__		List<Message<byte[]>> messages__		try {_			ByteBuffer byteBuffer__			if (webSocketMessage instanceof TextMessage) {_				byteBuffer = ByteBuffer.wrap(((TextMessage) webSocketMessage).asBytes())__			}_			else if (webSocketMessage instanceof BinaryMessage) {_				byteBuffer = ((BinaryMessage) webSocketMessage).getPayload()__			}_			else {_				return__			}__			BufferingStompDecoder decoder = this.decoders.get(session.getId())__			if (decoder == null) {_				throw new IllegalStateException("No decoder for session id '" + session.getId() + "'")__			}__			messages = decoder.decode(byteBuffer)__			if (messages.isEmpty()) {_				if (logger.isTraceEnabled()) {_					logger.trace("Incomplete STOMP frame content received in session " +_							session + ", bufferSize=" + decoder.getBufferSize() +_							", bufferSizeLimit=" + decoder.getBufferSizeLimit() + ".")__				}_				return__			}_		}_		catch (Throwable ex) {_			if (logger.isErrorEnabled()) {_				logger.error("Failed to parse " + webSocketMessage +_						" in session " + session.getId() + ". Sending STOMP ERROR to client.", ex)__			}_			handleError(session, ex, null)__			return__		}__		for (Message<byte[]> message : messages) {_			try {_				StompHeaderAccessor headerAccessor =_						MessageHeaderAccessor.getAccessor(message, StompHeaderAccessor.class)___				Principal user = session.getPrincipal()___				headerAccessor.setSessionId(session.getId())__				headerAccessor.setSessionAttributes(session.getAttributes())__				headerAccessor.setUser(user)__				headerAccessor.setHeader(SimpMessageHeaderAccessor.HEART_BEAT_HEADER, headerAccessor.getHeartbeat())__				if (!detectImmutableMessageInterceptor(outputChannel)) {_					headerAccessor.setImmutable()__				}__				if (logger.isTraceEnabled()) {_					logger.trace("From client: " + headerAccessor.getShortLogMessage(message.getPayload()))__				}__				if (StompCommand.CONNECT.equals(headerAccessor.getCommand())) {_					this.stats.incrementConnectCount()__				}_				else if (StompCommand.DISCONNECT.equals(headerAccessor.getCommand())) {_					this.stats.incrementDisconnectCount()__				}__				try {_					SimpAttributesContextHolder.setAttributesFromMessage(message)__					if (this.eventPublisher != null) {_						if (StompCommand.CONNECT.equals(headerAccessor.getCommand())) {_							publishEvent(new SessionConnectEvent(this, message, user))__						}_						else if (StompCommand.SUBSCRIBE.equals(headerAccessor.getCommand())) {_							publishEvent(new SessionSubscribeEvent(this, message, user))__						}_						else if (StompCommand.UNSUBSCRIBE.equals(headerAccessor.getCommand())) {_							publishEvent(new SessionUnsubscribeEvent(this, message, user))__						}_					}_					outputChannel.send(message)__				}_				finally {_					SimpAttributesContextHolder.resetAttributes()__				}_			}_			catch (Throwable ex) {_				logger.error("Failed to send client message to application via MessageChannel" +_						" in session " + session.getId() + ". Sending STOMP ERROR to client.", ex)__				handleError(session, ex, message)__			}_		}_	};handle,incoming,web,socket,messages,from,clients;public,void,handle,message,from,client,web,socket,session,session,web,socket,message,web,socket,message,message,channel,output,channel,list,message,byte,messages,try,byte,buffer,byte,buffer,if,web,socket,message,instanceof,text,message,byte,buffer,byte,buffer,wrap,text,message,web,socket,message,as,bytes,else,if,web,socket,message,instanceof,binary,message,byte,buffer,binary,message,web,socket,message,get,payload,else,return,buffering,stomp,decoder,decoder,this,decoders,get,session,get,id,if,decoder,null,throw,new,illegal,state,exception,no,decoder,for,session,id,session,get,id,messages,decoder,decode,byte,buffer,if,messages,is,empty,if,logger,is,trace,enabled,logger,trace,incomplete,stomp,frame,content,received,in,session,session,buffer,size,decoder,get,buffer,size,buffer,size,limit,decoder,get,buffer,size,limit,return,catch,throwable,ex,if,logger,is,error,enabled,logger,error,failed,to,parse,web,socket,message,in,session,session,get,id,sending,stomp,error,to,client,ex,handle,error,session,ex,null,return,for,message,byte,message,messages,try,stomp,header,accessor,header,accessor,message,header,accessor,get,accessor,message,stomp,header,accessor,class,principal,user,session,get,principal,header,accessor,set,session,id,session,get,id,header,accessor,set,session,attributes,session,get,attributes,header,accessor,set,user,user,header,accessor,set,header,simp,message,header,accessor,header,accessor,get,heartbeat,if,detect,immutable,message,interceptor,output,channel,header,accessor,set,immutable,if,logger,is,trace,enabled,logger,trace,from,client,header,accessor,get,short,log,message,message,get,payload,if,stomp,command,connect,equals,header,accessor,get,command,this,stats,increment,connect,count,else,if,stomp,command,disconnect,equals,header,accessor,get,command,this,stats,increment,disconnect,count,try,simp,attributes,context,holder,set,attributes,from,message,message,if,this,event,publisher,null,if,stomp,command,connect,equals,header,accessor,get,command,publish,event,new,session,connect,event,this,message,user,else,if,stomp,command,subscribe,equals,header,accessor,get,command,publish,event,new,session,subscribe,event,this,message,user,else,if,stomp,command,unsubscribe,equals,header,accessor,get,command,publish,event,new,session,unsubscribe,event,this,message,user,output,channel,send,message,finally,simp,attributes,context,holder,reset,attributes,catch,throwable,ex,logger,error,failed,to,send,client,message,to,application,via,message,channel,in,session,session,get,id,sending,stomp,error,to,client,ex,handle,error,session,ex,message
StompSubProtocolHandler -> public void handleMessageFromClient(WebSocketSession session, 			WebSocketMessage<?> webSocketMessage, MessageChannel outputChannel);1432331447;Handle incoming WebSocket messages from clients.;public void handleMessageFromClient(WebSocketSession session,_			WebSocketMessage<?> webSocketMessage, MessageChannel outputChannel) {__		List<Message<byte[]>> messages__		try {_			ByteBuffer byteBuffer__			if (webSocketMessage instanceof TextMessage) {_				byteBuffer = ByteBuffer.wrap(((TextMessage) webSocketMessage).asBytes())__			}_			else if (webSocketMessage instanceof BinaryMessage) {_				byteBuffer = ((BinaryMessage) webSocketMessage).getPayload()__			}_			else {_				return__			}__			BufferingStompDecoder decoder = this.decoders.get(session.getId())__			if (decoder == null) {_				throw new IllegalStateException("No decoder for session id '" + session.getId() + "'")__			}__			messages = decoder.decode(byteBuffer)__			if (messages.isEmpty()) {_				if (logger.isTraceEnabled()) {_					logger.trace("Incomplete STOMP frame content received in session " +_							session + ", bufferSize=" + decoder.getBufferSize() +_							", bufferSizeLimit=" + decoder.getBufferSizeLimit() + ".")__				}_				return__			}_		}_		catch (Throwable ex) {_			if (logger.isErrorEnabled()) {_				logger.error("Failed to parse " + webSocketMessage +_						" in session " + session.getId() + ". Sending STOMP ERROR to client.", ex)__			}_			handleError(session, ex, null)__			return__		}__		for (Message<byte[]> message : messages) {_			try {_				StompHeaderAccessor headerAccessor =_						MessageHeaderAccessor.getAccessor(message, StompHeaderAccessor.class)__				Principal user = session.getPrincipal()___				headerAccessor.setSessionId(session.getId())__				headerAccessor.setSessionAttributes(session.getAttributes())__				headerAccessor.setUser(user)__				headerAccessor.setHeader(SimpMessageHeaderAccessor.HEART_BEAT_HEADER, headerAccessor.getHeartbeat())__				if (!detectImmutableMessageInterceptor(outputChannel)) {_					headerAccessor.setImmutable()__				}__				if (logger.isTraceEnabled()) {_					logger.trace("From client: " + headerAccessor.getShortLogMessage(message.getPayload()))__				}__				if (StompCommand.CONNECT.equals(headerAccessor.getCommand())) {_					this.stats.incrementConnectCount()__				}_				else if (StompCommand.DISCONNECT.equals(headerAccessor.getCommand())) {_					this.stats.incrementDisconnectCount()__				}__				try {_					SimpAttributesContextHolder.setAttributesFromMessage(message)__					if (this.eventPublisher != null) {_						if (StompCommand.CONNECT.equals(headerAccessor.getCommand())) {_							publishEvent(new SessionConnectEvent(this, message, user))__						}_						else if (StompCommand.SUBSCRIBE.equals(headerAccessor.getCommand())) {_							publishEvent(new SessionSubscribeEvent(this, message, user))__						}_						else if (StompCommand.UNSUBSCRIBE.equals(headerAccessor.getCommand())) {_							publishEvent(new SessionUnsubscribeEvent(this, message, user))__						}_					}_					outputChannel.send(message)__				}_				finally {_					SimpAttributesContextHolder.resetAttributes()__				}_			}_			catch (Throwable ex) {_				logger.error("Failed to send client message to application via MessageChannel" +_						" in session " + session.getId() + ". Sending STOMP ERROR to client.", ex)__				handleError(session, ex, message)__			}_		}_	};handle,incoming,web,socket,messages,from,clients;public,void,handle,message,from,client,web,socket,session,session,web,socket,message,web,socket,message,message,channel,output,channel,list,message,byte,messages,try,byte,buffer,byte,buffer,if,web,socket,message,instanceof,text,message,byte,buffer,byte,buffer,wrap,text,message,web,socket,message,as,bytes,else,if,web,socket,message,instanceof,binary,message,byte,buffer,binary,message,web,socket,message,get,payload,else,return,buffering,stomp,decoder,decoder,this,decoders,get,session,get,id,if,decoder,null,throw,new,illegal,state,exception,no,decoder,for,session,id,session,get,id,messages,decoder,decode,byte,buffer,if,messages,is,empty,if,logger,is,trace,enabled,logger,trace,incomplete,stomp,frame,content,received,in,session,session,buffer,size,decoder,get,buffer,size,buffer,size,limit,decoder,get,buffer,size,limit,return,catch,throwable,ex,if,logger,is,error,enabled,logger,error,failed,to,parse,web,socket,message,in,session,session,get,id,sending,stomp,error,to,client,ex,handle,error,session,ex,null,return,for,message,byte,message,messages,try,stomp,header,accessor,header,accessor,message,header,accessor,get,accessor,message,stomp,header,accessor,class,principal,user,session,get,principal,header,accessor,set,session,id,session,get,id,header,accessor,set,session,attributes,session,get,attributes,header,accessor,set,user,user,header,accessor,set,header,simp,message,header,accessor,header,accessor,get,heartbeat,if,detect,immutable,message,interceptor,output,channel,header,accessor,set,immutable,if,logger,is,trace,enabled,logger,trace,from,client,header,accessor,get,short,log,message,message,get,payload,if,stomp,command,connect,equals,header,accessor,get,command,this,stats,increment,connect,count,else,if,stomp,command,disconnect,equals,header,accessor,get,command,this,stats,increment,disconnect,count,try,simp,attributes,context,holder,set,attributes,from,message,message,if,this,event,publisher,null,if,stomp,command,connect,equals,header,accessor,get,command,publish,event,new,session,connect,event,this,message,user,else,if,stomp,command,subscribe,equals,header,accessor,get,command,publish,event,new,session,subscribe,event,this,message,user,else,if,stomp,command,unsubscribe,equals,header,accessor,get,command,publish,event,new,session,unsubscribe,event,this,message,user,output,channel,send,message,finally,simp,attributes,context,holder,reset,attributes,catch,throwable,ex,logger,error,failed,to,send,client,message,to,application,via,message,channel,in,session,session,get,id,sending,stomp,error,to,client,ex,handle,error,session,ex,message
StompSubProtocolHandler -> public void handleMessageFromClient(WebSocketSession session, 			WebSocketMessage<?> webSocketMessage, MessageChannel outputChannel);1440168414;Handle incoming WebSocket messages from clients.;public void handleMessageFromClient(WebSocketSession session,_			WebSocketMessage<?> webSocketMessage, MessageChannel outputChannel) {__		List<Message<byte[]>> messages__		try {_			ByteBuffer byteBuffer__			if (webSocketMessage instanceof TextMessage) {_				byteBuffer = ByteBuffer.wrap(((TextMessage) webSocketMessage).asBytes())__			}_			else if (webSocketMessage instanceof BinaryMessage) {_				byteBuffer = ((BinaryMessage) webSocketMessage).getPayload()__			}_			else {_				return__			}__			BufferingStompDecoder decoder = this.decoders.get(session.getId())__			if (decoder == null) {_				throw new IllegalStateException("No decoder for session id '" + session.getId() + "'")__			}__			messages = decoder.decode(byteBuffer)__			if (messages.isEmpty()) {_				if (logger.isTraceEnabled()) {_					logger.trace("Incomplete STOMP frame content received in session " +_							session + ", bufferSize=" + decoder.getBufferSize() +_							", bufferSizeLimit=" + decoder.getBufferSizeLimit() + ".")__				}_				return__			}_		}_		catch (Throwable ex) {_			if (logger.isErrorEnabled()) {_				logger.error("Failed to parse " + webSocketMessage +_						" in session " + session.getId() + ". Sending STOMP ERROR to client.", ex)__			}_			handleError(session, ex, null)__			return__		}__		for (Message<byte[]> message : messages) {_			try {_				StompHeaderAccessor headerAccessor =_						MessageHeaderAccessor.getAccessor(message, StompHeaderAccessor.class)__				Principal user = session.getPrincipal()___				headerAccessor.setSessionId(session.getId())__				headerAccessor.setSessionAttributes(session.getAttributes())__				headerAccessor.setUser(user)__				headerAccessor.setHeader(SimpMessageHeaderAccessor.HEART_BEAT_HEADER, headerAccessor.getHeartbeat())__				if (!detectImmutableMessageInterceptor(outputChannel)) {_					headerAccessor.setImmutable()__				}__				if (logger.isTraceEnabled()) {_					logger.trace("From client: " + headerAccessor.getShortLogMessage(message.getPayload()))__				}__				if (StompCommand.CONNECT.equals(headerAccessor.getCommand())) {_					this.stats.incrementConnectCount()__				}_				else if (StompCommand.DISCONNECT.equals(headerAccessor.getCommand())) {_					this.stats.incrementDisconnectCount()__				}__				try {_					SimpAttributesContextHolder.setAttributesFromMessage(message)__					boolean sent = outputChannel.send(message)___					if (sent && this.eventPublisher != null) {_						if (StompCommand.CONNECT.equals(headerAccessor.getCommand())) {_							publishEvent(new SessionConnectEvent(this, message, user))__						}_						else if (StompCommand.SUBSCRIBE.equals(headerAccessor.getCommand())) {_							publishEvent(new SessionSubscribeEvent(this, message, user))__						}_						else if (StompCommand.UNSUBSCRIBE.equals(headerAccessor.getCommand())) {_							publishEvent(new SessionUnsubscribeEvent(this, message, user))__						}_					}_				}_				finally {_					SimpAttributesContextHolder.resetAttributes()__				}_			}_			catch (Throwable ex) {_				logger.error("Failed to send client message to application via MessageChannel" +_						" in session " + session.getId() + ". Sending STOMP ERROR to client.", ex)__				handleError(session, ex, message)__			}_		}_	};handle,incoming,web,socket,messages,from,clients;public,void,handle,message,from,client,web,socket,session,session,web,socket,message,web,socket,message,message,channel,output,channel,list,message,byte,messages,try,byte,buffer,byte,buffer,if,web,socket,message,instanceof,text,message,byte,buffer,byte,buffer,wrap,text,message,web,socket,message,as,bytes,else,if,web,socket,message,instanceof,binary,message,byte,buffer,binary,message,web,socket,message,get,payload,else,return,buffering,stomp,decoder,decoder,this,decoders,get,session,get,id,if,decoder,null,throw,new,illegal,state,exception,no,decoder,for,session,id,session,get,id,messages,decoder,decode,byte,buffer,if,messages,is,empty,if,logger,is,trace,enabled,logger,trace,incomplete,stomp,frame,content,received,in,session,session,buffer,size,decoder,get,buffer,size,buffer,size,limit,decoder,get,buffer,size,limit,return,catch,throwable,ex,if,logger,is,error,enabled,logger,error,failed,to,parse,web,socket,message,in,session,session,get,id,sending,stomp,error,to,client,ex,handle,error,session,ex,null,return,for,message,byte,message,messages,try,stomp,header,accessor,header,accessor,message,header,accessor,get,accessor,message,stomp,header,accessor,class,principal,user,session,get,principal,header,accessor,set,session,id,session,get,id,header,accessor,set,session,attributes,session,get,attributes,header,accessor,set,user,user,header,accessor,set,header,simp,message,header,accessor,header,accessor,get,heartbeat,if,detect,immutable,message,interceptor,output,channel,header,accessor,set,immutable,if,logger,is,trace,enabled,logger,trace,from,client,header,accessor,get,short,log,message,message,get,payload,if,stomp,command,connect,equals,header,accessor,get,command,this,stats,increment,connect,count,else,if,stomp,command,disconnect,equals,header,accessor,get,command,this,stats,increment,disconnect,count,try,simp,attributes,context,holder,set,attributes,from,message,message,boolean,sent,output,channel,send,message,if,sent,this,event,publisher,null,if,stomp,command,connect,equals,header,accessor,get,command,publish,event,new,session,connect,event,this,message,user,else,if,stomp,command,subscribe,equals,header,accessor,get,command,publish,event,new,session,subscribe,event,this,message,user,else,if,stomp,command,unsubscribe,equals,header,accessor,get,command,publish,event,new,session,unsubscribe,event,this,message,user,finally,simp,attributes,context,holder,reset,attributes,catch,throwable,ex,logger,error,failed,to,send,client,message,to,application,via,message,channel,in,session,session,get,id,sending,stomp,error,to,client,ex,handle,error,session,ex,message
StompSubProtocolHandler -> public void handleMessageFromClient(WebSocketSession session, 			WebSocketMessage<?> webSocketMessage, MessageChannel outputChannel);1440249342;Handle incoming WebSocket messages from clients.;public void handleMessageFromClient(WebSocketSession session,_			WebSocketMessage<?> webSocketMessage, MessageChannel outputChannel) {__		List<Message<byte[]>> messages__		try {_			ByteBuffer byteBuffer__			if (webSocketMessage instanceof TextMessage) {_				byteBuffer = ByteBuffer.wrap(((TextMessage) webSocketMessage).asBytes())__			}_			else if (webSocketMessage instanceof BinaryMessage) {_				byteBuffer = ((BinaryMessage) webSocketMessage).getPayload()__			}_			else {_				return__			}__			BufferingStompDecoder decoder = this.decoders.get(session.getId())__			if (decoder == null) {_				throw new IllegalStateException("No decoder for session id '" + session.getId() + "'")__			}__			messages = decoder.decode(byteBuffer)__			if (messages.isEmpty()) {_				if (logger.isTraceEnabled()) {_					logger.trace("Incomplete STOMP frame content received in session " +_							session + ", bufferSize=" + decoder.getBufferSize() +_							", bufferSizeLimit=" + decoder.getBufferSizeLimit() + ".")__				}_				return__			}_		}_		catch (Throwable ex) {_			if (logger.isErrorEnabled()) {_				logger.error("Failed to parse " + webSocketMessage +_						" in session " + session.getId() + ". Sending STOMP ERROR to client.", ex)__			}_			handleError(session, ex, null)__			return__		}__		for (Message<byte[]> message : messages) {_			try {_				StompHeaderAccessor headerAccessor =_						MessageHeaderAccessor.getAccessor(message, StompHeaderAccessor.class)__				Principal user = session.getPrincipal()___				headerAccessor.setSessionId(session.getId())__				headerAccessor.setSessionAttributes(session.getAttributes())__				headerAccessor.setUser(user)__				headerAccessor.setHeader(SimpMessageHeaderAccessor.HEART_BEAT_HEADER, headerAccessor.getHeartbeat())__				if (!detectImmutableMessageInterceptor(outputChannel)) {_					headerAccessor.setImmutable()__				}__				if (logger.isTraceEnabled()) {_					logger.trace("From client: " + headerAccessor.getShortLogMessage(message.getPayload()))__				}__				if (StompCommand.CONNECT.equals(headerAccessor.getCommand())) {_					this.stats.incrementConnectCount()__				}_				else if (StompCommand.DISCONNECT.equals(headerAccessor.getCommand())) {_					this.stats.incrementDisconnectCount()__				}__				try {_					SimpAttributesContextHolder.setAttributesFromMessage(message)__					boolean sent = outputChannel.send(message)___					if (sent && this.eventPublisher != null) {_						if (StompCommand.CONNECT.equals(headerAccessor.getCommand())) {_							publishEvent(new SessionConnectEvent(this, message, user))__						}_						else if (StompCommand.SUBSCRIBE.equals(headerAccessor.getCommand())) {_							publishEvent(new SessionSubscribeEvent(this, message, user))__						}_						else if (StompCommand.UNSUBSCRIBE.equals(headerAccessor.getCommand())) {_							publishEvent(new SessionUnsubscribeEvent(this, message, user))__						}_					}_				}_				finally {_					SimpAttributesContextHolder.resetAttributes()__				}_			}_			catch (Throwable ex) {_				logger.error("Failed to send client message to application via MessageChannel" +_						" in session " + session.getId() + ". Sending STOMP ERROR to client.", ex)__				handleError(session, ex, message)__			}_		}_	};handle,incoming,web,socket,messages,from,clients;public,void,handle,message,from,client,web,socket,session,session,web,socket,message,web,socket,message,message,channel,output,channel,list,message,byte,messages,try,byte,buffer,byte,buffer,if,web,socket,message,instanceof,text,message,byte,buffer,byte,buffer,wrap,text,message,web,socket,message,as,bytes,else,if,web,socket,message,instanceof,binary,message,byte,buffer,binary,message,web,socket,message,get,payload,else,return,buffering,stomp,decoder,decoder,this,decoders,get,session,get,id,if,decoder,null,throw,new,illegal,state,exception,no,decoder,for,session,id,session,get,id,messages,decoder,decode,byte,buffer,if,messages,is,empty,if,logger,is,trace,enabled,logger,trace,incomplete,stomp,frame,content,received,in,session,session,buffer,size,decoder,get,buffer,size,buffer,size,limit,decoder,get,buffer,size,limit,return,catch,throwable,ex,if,logger,is,error,enabled,logger,error,failed,to,parse,web,socket,message,in,session,session,get,id,sending,stomp,error,to,client,ex,handle,error,session,ex,null,return,for,message,byte,message,messages,try,stomp,header,accessor,header,accessor,message,header,accessor,get,accessor,message,stomp,header,accessor,class,principal,user,session,get,principal,header,accessor,set,session,id,session,get,id,header,accessor,set,session,attributes,session,get,attributes,header,accessor,set,user,user,header,accessor,set,header,simp,message,header,accessor,header,accessor,get,heartbeat,if,detect,immutable,message,interceptor,output,channel,header,accessor,set,immutable,if,logger,is,trace,enabled,logger,trace,from,client,header,accessor,get,short,log,message,message,get,payload,if,stomp,command,connect,equals,header,accessor,get,command,this,stats,increment,connect,count,else,if,stomp,command,disconnect,equals,header,accessor,get,command,this,stats,increment,disconnect,count,try,simp,attributes,context,holder,set,attributes,from,message,message,boolean,sent,output,channel,send,message,if,sent,this,event,publisher,null,if,stomp,command,connect,equals,header,accessor,get,command,publish,event,new,session,connect,event,this,message,user,else,if,stomp,command,subscribe,equals,header,accessor,get,command,publish,event,new,session,subscribe,event,this,message,user,else,if,stomp,command,unsubscribe,equals,header,accessor,get,command,publish,event,new,session,unsubscribe,event,this,message,user,finally,simp,attributes,context,holder,reset,attributes,catch,throwable,ex,logger,error,failed,to,send,client,message,to,application,via,message,channel,in,session,session,get,id,sending,stomp,error,to,client,ex,handle,error,session,ex,message
StompSubProtocolHandler -> public void handleMessageFromClient(WebSocketSession session, 			WebSocketMessage<?> webSocketMessage, MessageChannel outputChannel);1467726769;Handle incoming WebSocket messages from clients.;public void handleMessageFromClient(WebSocketSession session,_			WebSocketMessage<?> webSocketMessage, MessageChannel outputChannel) {__		List<Message<byte[]>> messages__		try {_			ByteBuffer byteBuffer__			if (webSocketMessage instanceof TextMessage) {_				byteBuffer = ByteBuffer.wrap(((TextMessage) webSocketMessage).asBytes())__			}_			else if (webSocketMessage instanceof BinaryMessage) {_				byteBuffer = ((BinaryMessage) webSocketMessage).getPayload()__			}_			else {_				return__			}__			BufferingStompDecoder decoder = this.decoders.get(session.getId())__			if (decoder == null) {_				throw new IllegalStateException("No decoder for session id '" + session.getId() + "'")__			}__			messages = decoder.decode(byteBuffer)__			if (messages.isEmpty()) {_				if (logger.isTraceEnabled()) {_					logger.trace("Incomplete STOMP frame content received in session " +_							session + ", bufferSize=" + decoder.getBufferSize() +_							", bufferSizeLimit=" + decoder.getBufferSizeLimit() + ".")__				}_				return__			}_		}_		catch (Throwable ex) {_			if (logger.isErrorEnabled()) {_				logger.error("Failed to parse " + webSocketMessage +_						" in session " + session.getId() + ". Sending STOMP ERROR to client.", ex)__			}_			handleError(session, ex, null)__			return__		}__		for (Message<byte[]> message : messages) {_			try {_				StompHeaderAccessor headerAccessor =_						MessageHeaderAccessor.getAccessor(message, StompHeaderAccessor.class)__				Principal user = session.getPrincipal()___				headerAccessor.setSessionId(session.getId())__				headerAccessor.setSessionAttributes(session.getAttributes())__				headerAccessor.setUser(user)__				headerAccessor.setHeader(SimpMessageHeaderAccessor.HEART_BEAT_HEADER, headerAccessor.getHeartbeat())__				if (!detectImmutableMessageInterceptor(outputChannel)) {_					headerAccessor.setImmutable()__				}__				if (logger.isTraceEnabled()) {_					logger.trace("From client: " + headerAccessor.getShortLogMessage(message.getPayload()))__				}__				if (StompCommand.CONNECT.equals(headerAccessor.getCommand())) {_					this.stats.incrementConnectCount()__				}_				else if (StompCommand.DISCONNECT.equals(headerAccessor.getCommand())) {_					this.stats.incrementDisconnectCount()__				}__				try {_					SimpAttributesContextHolder.setAttributesFromMessage(message)__					boolean sent = outputChannel.send(message)___					if (sent && this.eventPublisher != null) {_						if (StompCommand.CONNECT.equals(headerAccessor.getCommand())) {_							publishEvent(new SessionConnectEvent(this, message, user))__						}_						else if (StompCommand.SUBSCRIBE.equals(headerAccessor.getCommand())) {_							publishEvent(new SessionSubscribeEvent(this, message, user))__						}_						else if (StompCommand.UNSUBSCRIBE.equals(headerAccessor.getCommand())) {_							publishEvent(new SessionUnsubscribeEvent(this, message, user))__						}_					}_				}_				finally {_					SimpAttributesContextHolder.resetAttributes()__				}_			}_			catch (Throwable ex) {_				logger.error("Failed to send client message to application via MessageChannel" +_						" in session " + session.getId() + ". Sending STOMP ERROR to client.", ex)__				handleError(session, ex, message)__			}_		}_	};handle,incoming,web,socket,messages,from,clients;public,void,handle,message,from,client,web,socket,session,session,web,socket,message,web,socket,message,message,channel,output,channel,list,message,byte,messages,try,byte,buffer,byte,buffer,if,web,socket,message,instanceof,text,message,byte,buffer,byte,buffer,wrap,text,message,web,socket,message,as,bytes,else,if,web,socket,message,instanceof,binary,message,byte,buffer,binary,message,web,socket,message,get,payload,else,return,buffering,stomp,decoder,decoder,this,decoders,get,session,get,id,if,decoder,null,throw,new,illegal,state,exception,no,decoder,for,session,id,session,get,id,messages,decoder,decode,byte,buffer,if,messages,is,empty,if,logger,is,trace,enabled,logger,trace,incomplete,stomp,frame,content,received,in,session,session,buffer,size,decoder,get,buffer,size,buffer,size,limit,decoder,get,buffer,size,limit,return,catch,throwable,ex,if,logger,is,error,enabled,logger,error,failed,to,parse,web,socket,message,in,session,session,get,id,sending,stomp,error,to,client,ex,handle,error,session,ex,null,return,for,message,byte,message,messages,try,stomp,header,accessor,header,accessor,message,header,accessor,get,accessor,message,stomp,header,accessor,class,principal,user,session,get,principal,header,accessor,set,session,id,session,get,id,header,accessor,set,session,attributes,session,get,attributes,header,accessor,set,user,user,header,accessor,set,header,simp,message,header,accessor,header,accessor,get,heartbeat,if,detect,immutable,message,interceptor,output,channel,header,accessor,set,immutable,if,logger,is,trace,enabled,logger,trace,from,client,header,accessor,get,short,log,message,message,get,payload,if,stomp,command,connect,equals,header,accessor,get,command,this,stats,increment,connect,count,else,if,stomp,command,disconnect,equals,header,accessor,get,command,this,stats,increment,disconnect,count,try,simp,attributes,context,holder,set,attributes,from,message,message,boolean,sent,output,channel,send,message,if,sent,this,event,publisher,null,if,stomp,command,connect,equals,header,accessor,get,command,publish,event,new,session,connect,event,this,message,user,else,if,stomp,command,subscribe,equals,header,accessor,get,command,publish,event,new,session,subscribe,event,this,message,user,else,if,stomp,command,unsubscribe,equals,header,accessor,get,command,publish,event,new,session,unsubscribe,event,this,message,user,finally,simp,attributes,context,holder,reset,attributes,catch,throwable,ex,logger,error,failed,to,send,client,message,to,application,via,message,channel,in,session,session,get,id,sending,stomp,error,to,client,ex,handle,error,session,ex,message
StompSubProtocolHandler -> public void handleMessageFromClient(WebSocketSession session, 			WebSocketMessage<?> webSocketMessage, MessageChannel outputChannel);1467730834;Handle incoming WebSocket messages from clients.;public void handleMessageFromClient(WebSocketSession session,_			WebSocketMessage<?> webSocketMessage, MessageChannel outputChannel) {__		List<Message<byte[]>> messages__		try {_			ByteBuffer byteBuffer__			if (webSocketMessage instanceof TextMessage) {_				byteBuffer = ByteBuffer.wrap(((TextMessage) webSocketMessage).asBytes())__			}_			else if (webSocketMessage instanceof BinaryMessage) {_				byteBuffer = ((BinaryMessage) webSocketMessage).getPayload()__			}_			else {_				return__			}__			BufferingStompDecoder decoder = this.decoders.get(session.getId())__			if (decoder == null) {_				throw new IllegalStateException("No decoder for session id '" + session.getId() + "'")__			}__			messages = decoder.decode(byteBuffer)__			if (messages.isEmpty()) {_				if (logger.isTraceEnabled()) {_					logger.trace("Incomplete STOMP frame content received in session " +_							session + ", bufferSize=" + decoder.getBufferSize() +_							", bufferSizeLimit=" + decoder.getBufferSizeLimit() + ".")__				}_				return__			}_		}_		catch (Throwable ex) {_			if (logger.isErrorEnabled()) {_				logger.error("Failed to parse " + webSocketMessage +_						" in session " + session.getId() + ". Sending STOMP ERROR to client.", ex)__			}_			handleError(session, ex, null)__			return__		}__		for (Message<byte[]> message : messages) {_			try {_				StompHeaderAccessor headerAccessor =_						MessageHeaderAccessor.getAccessor(message, StompHeaderAccessor.class)__				Principal user = session.getPrincipal()___				headerAccessor.setSessionId(session.getId())__				headerAccessor.setSessionAttributes(session.getAttributes())__				headerAccessor.setUser(user)__				headerAccessor.setHeader(SimpMessageHeaderAccessor.HEART_BEAT_HEADER, headerAccessor.getHeartbeat())__				if (!detectImmutableMessageInterceptor(outputChannel)) {_					headerAccessor.setImmutable()__				}__				if (logger.isTraceEnabled()) {_					logger.trace("From client: " + headerAccessor.getShortLogMessage(message.getPayload()))__				}__				if (StompCommand.CONNECT.equals(headerAccessor.getCommand())) {_					this.stats.incrementConnectCount()__				}_				else if (StompCommand.DISCONNECT.equals(headerAccessor.getCommand())) {_					this.stats.incrementDisconnectCount()__				}__				try {_					SimpAttributesContextHolder.setAttributesFromMessage(message)__					boolean sent = outputChannel.send(message)___					if (sent && this.eventPublisher != null) {_						if (StompCommand.CONNECT.equals(headerAccessor.getCommand())) {_							publishEvent(new SessionConnectEvent(this, message, user))__						}_						else if (StompCommand.SUBSCRIBE.equals(headerAccessor.getCommand())) {_							publishEvent(new SessionSubscribeEvent(this, message, user))__						}_						else if (StompCommand.UNSUBSCRIBE.equals(headerAccessor.getCommand())) {_							publishEvent(new SessionUnsubscribeEvent(this, message, user))__						}_					}_				}_				finally {_					SimpAttributesContextHolder.resetAttributes()__				}_			}_			catch (Throwable ex) {_				logger.error("Failed to send client message to application via MessageChannel" +_						" in session " + session.getId() + ". Sending STOMP ERROR to client.", ex)__				handleError(session, ex, message)__			}_		}_	};handle,incoming,web,socket,messages,from,clients;public,void,handle,message,from,client,web,socket,session,session,web,socket,message,web,socket,message,message,channel,output,channel,list,message,byte,messages,try,byte,buffer,byte,buffer,if,web,socket,message,instanceof,text,message,byte,buffer,byte,buffer,wrap,text,message,web,socket,message,as,bytes,else,if,web,socket,message,instanceof,binary,message,byte,buffer,binary,message,web,socket,message,get,payload,else,return,buffering,stomp,decoder,decoder,this,decoders,get,session,get,id,if,decoder,null,throw,new,illegal,state,exception,no,decoder,for,session,id,session,get,id,messages,decoder,decode,byte,buffer,if,messages,is,empty,if,logger,is,trace,enabled,logger,trace,incomplete,stomp,frame,content,received,in,session,session,buffer,size,decoder,get,buffer,size,buffer,size,limit,decoder,get,buffer,size,limit,return,catch,throwable,ex,if,logger,is,error,enabled,logger,error,failed,to,parse,web,socket,message,in,session,session,get,id,sending,stomp,error,to,client,ex,handle,error,session,ex,null,return,for,message,byte,message,messages,try,stomp,header,accessor,header,accessor,message,header,accessor,get,accessor,message,stomp,header,accessor,class,principal,user,session,get,principal,header,accessor,set,session,id,session,get,id,header,accessor,set,session,attributes,session,get,attributes,header,accessor,set,user,user,header,accessor,set,header,simp,message,header,accessor,header,accessor,get,heartbeat,if,detect,immutable,message,interceptor,output,channel,header,accessor,set,immutable,if,logger,is,trace,enabled,logger,trace,from,client,header,accessor,get,short,log,message,message,get,payload,if,stomp,command,connect,equals,header,accessor,get,command,this,stats,increment,connect,count,else,if,stomp,command,disconnect,equals,header,accessor,get,command,this,stats,increment,disconnect,count,try,simp,attributes,context,holder,set,attributes,from,message,message,boolean,sent,output,channel,send,message,if,sent,this,event,publisher,null,if,stomp,command,connect,equals,header,accessor,get,command,publish,event,new,session,connect,event,this,message,user,else,if,stomp,command,subscribe,equals,header,accessor,get,command,publish,event,new,session,subscribe,event,this,message,user,else,if,stomp,command,unsubscribe,equals,header,accessor,get,command,publish,event,new,session,unsubscribe,event,this,message,user,finally,simp,attributes,context,holder,reset,attributes,catch,throwable,ex,logger,error,failed,to,send,client,message,to,application,via,message,channel,in,session,session,get,id,sending,stomp,error,to,client,ex,handle,error,session,ex,message
StompSubProtocolHandler -> public void handleMessageFromClient(WebSocketSession session, 			WebSocketMessage<?> webSocketMessage, MessageChannel outputChannel);1472062321;Handle incoming WebSocket messages from clients.;public void handleMessageFromClient(WebSocketSession session,_			WebSocketMessage<?> webSocketMessage, MessageChannel outputChannel) {__		List<Message<byte[]>> messages__		try {_			ByteBuffer byteBuffer__			if (webSocketMessage instanceof TextMessage) {_				byteBuffer = ByteBuffer.wrap(((TextMessage) webSocketMessage).asBytes())__			}_			else if (webSocketMessage instanceof BinaryMessage) {_				byteBuffer = ((BinaryMessage) webSocketMessage).getPayload()__			}_			else {_				return__			}__			BufferingStompDecoder decoder = this.decoders.get(session.getId())__			if (decoder == null) {_				throw new IllegalStateException("No decoder for session id '" + session.getId() + "'")__			}__			messages = decoder.decode(byteBuffer)__			if (messages.isEmpty()) {_				if (logger.isTraceEnabled()) {_					logger.trace("Incomplete STOMP frame content received in session " +_							session + ", bufferSize=" + decoder.getBufferSize() +_							", bufferSizeLimit=" + decoder.getBufferSizeLimit() + ".")__				}_				return__			}_		}_		catch (Throwable ex) {_			if (logger.isErrorEnabled()) {_				logger.error("Failed to parse " + webSocketMessage +_						" in session " + session.getId() + ". Sending STOMP ERROR to client.", ex)__			}_			handleError(session, ex, null)__			return__		}__		for (Message<byte[]> message : messages) {_			try {_				StompHeaderAccessor headerAccessor =_						MessageHeaderAccessor.getAccessor(message, StompHeaderAccessor.class)__				Principal user = session.getPrincipal()___				headerAccessor.setSessionId(session.getId())__				headerAccessor.setSessionAttributes(session.getAttributes())__				headerAccessor.setUser(user)__				headerAccessor.setHeader(SimpMessageHeaderAccessor.HEART_BEAT_HEADER, headerAccessor.getHeartbeat())__				if (!detectImmutableMessageInterceptor(outputChannel)) {_					headerAccessor.setImmutable()__				}__				if (logger.isTraceEnabled()) {_					logger.trace("From client: " + headerAccessor.getShortLogMessage(message.getPayload()))__				}__				if (StompCommand.CONNECT.equals(headerAccessor.getCommand())) {_					this.stats.incrementConnectCount()__				}_				else if (StompCommand.DISCONNECT.equals(headerAccessor.getCommand())) {_					this.stats.incrementDisconnectCount()__				}__				try {_					SimpAttributesContextHolder.setAttributesFromMessage(message)__					boolean sent = outputChannel.send(message)___					if (sent && this.eventPublisher != null) {_						if (StompCommand.CONNECT.equals(headerAccessor.getCommand())) {_							publishEvent(new SessionConnectEvent(this, message, user))__						}_						else if (StompCommand.SUBSCRIBE.equals(headerAccessor.getCommand())) {_							publishEvent(new SessionSubscribeEvent(this, message, user))__						}_						else if (StompCommand.UNSUBSCRIBE.equals(headerAccessor.getCommand())) {_							publishEvent(new SessionUnsubscribeEvent(this, message, user))__						}_					}_				}_				finally {_					SimpAttributesContextHolder.resetAttributes()__				}_			}_			catch (Throwable ex) {_				if (logger.isErrorEnabled()) {_					logger.error("Failed to send client message to application via MessageChannel" +_							" in session " + session.getId() + ". Sending STOMP ERROR to client.", ex)__				}_				handleError(session, ex, message)__			}_		}_	};handle,incoming,web,socket,messages,from,clients;public,void,handle,message,from,client,web,socket,session,session,web,socket,message,web,socket,message,message,channel,output,channel,list,message,byte,messages,try,byte,buffer,byte,buffer,if,web,socket,message,instanceof,text,message,byte,buffer,byte,buffer,wrap,text,message,web,socket,message,as,bytes,else,if,web,socket,message,instanceof,binary,message,byte,buffer,binary,message,web,socket,message,get,payload,else,return,buffering,stomp,decoder,decoder,this,decoders,get,session,get,id,if,decoder,null,throw,new,illegal,state,exception,no,decoder,for,session,id,session,get,id,messages,decoder,decode,byte,buffer,if,messages,is,empty,if,logger,is,trace,enabled,logger,trace,incomplete,stomp,frame,content,received,in,session,session,buffer,size,decoder,get,buffer,size,buffer,size,limit,decoder,get,buffer,size,limit,return,catch,throwable,ex,if,logger,is,error,enabled,logger,error,failed,to,parse,web,socket,message,in,session,session,get,id,sending,stomp,error,to,client,ex,handle,error,session,ex,null,return,for,message,byte,message,messages,try,stomp,header,accessor,header,accessor,message,header,accessor,get,accessor,message,stomp,header,accessor,class,principal,user,session,get,principal,header,accessor,set,session,id,session,get,id,header,accessor,set,session,attributes,session,get,attributes,header,accessor,set,user,user,header,accessor,set,header,simp,message,header,accessor,header,accessor,get,heartbeat,if,detect,immutable,message,interceptor,output,channel,header,accessor,set,immutable,if,logger,is,trace,enabled,logger,trace,from,client,header,accessor,get,short,log,message,message,get,payload,if,stomp,command,connect,equals,header,accessor,get,command,this,stats,increment,connect,count,else,if,stomp,command,disconnect,equals,header,accessor,get,command,this,stats,increment,disconnect,count,try,simp,attributes,context,holder,set,attributes,from,message,message,boolean,sent,output,channel,send,message,if,sent,this,event,publisher,null,if,stomp,command,connect,equals,header,accessor,get,command,publish,event,new,session,connect,event,this,message,user,else,if,stomp,command,subscribe,equals,header,accessor,get,command,publish,event,new,session,subscribe,event,this,message,user,else,if,stomp,command,unsubscribe,equals,header,accessor,get,command,publish,event,new,session,unsubscribe,event,this,message,user,finally,simp,attributes,context,holder,reset,attributes,catch,throwable,ex,if,logger,is,error,enabled,logger,error,failed,to,send,client,message,to,application,via,message,channel,in,session,session,get,id,sending,stomp,error,to,client,ex,handle,error,session,ex,message
StompSubProtocolHandler -> public void handleMessageFromClient(WebSocketSession session, 			WebSocketMessage<?> webSocketMessage, MessageChannel outputChannel);1472509879;Handle incoming WebSocket messages from clients.;public void handleMessageFromClient(WebSocketSession session,_			WebSocketMessage<?> webSocketMessage, MessageChannel outputChannel) {__		List<Message<byte[]>> messages__		try {_			ByteBuffer byteBuffer__			if (webSocketMessage instanceof TextMessage) {_				byteBuffer = ByteBuffer.wrap(((TextMessage) webSocketMessage).asBytes())__			}_			else if (webSocketMessage instanceof BinaryMessage) {_				byteBuffer = ((BinaryMessage) webSocketMessage).getPayload()__			}_			else {_				return__			}__			BufferingStompDecoder decoder = this.decoders.get(session.getId())__			if (decoder == null) {_				throw new IllegalStateException("No decoder for session id '" + session.getId() + "'")__			}__			messages = decoder.decode(byteBuffer)__			if (messages.isEmpty()) {_				if (logger.isTraceEnabled()) {_					logger.trace("Incomplete STOMP frame content received in session " +_							session + ", bufferSize=" + decoder.getBufferSize() +_							", bufferSizeLimit=" + decoder.getBufferSizeLimit() + ".")__				}_				return__			}_		}_		catch (Throwable ex) {_			if (logger.isErrorEnabled()) {_				logger.error("Failed to parse " + webSocketMessage +_						" in session " + session.getId() + ". Sending STOMP ERROR to client.", ex)__			}_			handleError(session, ex, null)__			return__		}__		for (Message<byte[]> message : messages) {_			try {_				StompHeaderAccessor headerAccessor =_						MessageHeaderAccessor.getAccessor(message, StompHeaderAccessor.class)__				Principal user = session.getPrincipal()___				headerAccessor.setSessionId(session.getId())__				headerAccessor.setSessionAttributes(session.getAttributes())__				headerAccessor.setUser(user)__				headerAccessor.setHeader(SimpMessageHeaderAccessor.HEART_BEAT_HEADER, headerAccessor.getHeartbeat())__				if (!detectImmutableMessageInterceptor(outputChannel)) {_					headerAccessor.setImmutable()__				}__				if (logger.isTraceEnabled()) {_					logger.trace("From client: " + headerAccessor.getShortLogMessage(message.getPayload()))__				}__				if (StompCommand.CONNECT.equals(headerAccessor.getCommand())) {_					this.stats.incrementConnectCount()__				}_				else if (StompCommand.DISCONNECT.equals(headerAccessor.getCommand())) {_					this.stats.incrementDisconnectCount()__				}__				try {_					SimpAttributesContextHolder.setAttributesFromMessage(message)__					boolean sent = outputChannel.send(message)___					if (sent && this.eventPublisher != null) {_						if (StompCommand.CONNECT.equals(headerAccessor.getCommand())) {_							publishEvent(new SessionConnectEvent(this, message, user))__						}_						else if (StompCommand.SUBSCRIBE.equals(headerAccessor.getCommand())) {_							publishEvent(new SessionSubscribeEvent(this, message, user))__						}_						else if (StompCommand.UNSUBSCRIBE.equals(headerAccessor.getCommand())) {_							publishEvent(new SessionUnsubscribeEvent(this, message, user))__						}_					}_				}_				finally {_					SimpAttributesContextHolder.resetAttributes()__				}_			}_			catch (Throwable ex) {_				if (logger.isErrorEnabled()) {_					logger.error("Failed to send client message to application via MessageChannel" +_							" in session " + session.getId() + ". Sending STOMP ERROR to client.", ex)__				}_				handleError(session, ex, message)__			}_		}_	};handle,incoming,web,socket,messages,from,clients;public,void,handle,message,from,client,web,socket,session,session,web,socket,message,web,socket,message,message,channel,output,channel,list,message,byte,messages,try,byte,buffer,byte,buffer,if,web,socket,message,instanceof,text,message,byte,buffer,byte,buffer,wrap,text,message,web,socket,message,as,bytes,else,if,web,socket,message,instanceof,binary,message,byte,buffer,binary,message,web,socket,message,get,payload,else,return,buffering,stomp,decoder,decoder,this,decoders,get,session,get,id,if,decoder,null,throw,new,illegal,state,exception,no,decoder,for,session,id,session,get,id,messages,decoder,decode,byte,buffer,if,messages,is,empty,if,logger,is,trace,enabled,logger,trace,incomplete,stomp,frame,content,received,in,session,session,buffer,size,decoder,get,buffer,size,buffer,size,limit,decoder,get,buffer,size,limit,return,catch,throwable,ex,if,logger,is,error,enabled,logger,error,failed,to,parse,web,socket,message,in,session,session,get,id,sending,stomp,error,to,client,ex,handle,error,session,ex,null,return,for,message,byte,message,messages,try,stomp,header,accessor,header,accessor,message,header,accessor,get,accessor,message,stomp,header,accessor,class,principal,user,session,get,principal,header,accessor,set,session,id,session,get,id,header,accessor,set,session,attributes,session,get,attributes,header,accessor,set,user,user,header,accessor,set,header,simp,message,header,accessor,header,accessor,get,heartbeat,if,detect,immutable,message,interceptor,output,channel,header,accessor,set,immutable,if,logger,is,trace,enabled,logger,trace,from,client,header,accessor,get,short,log,message,message,get,payload,if,stomp,command,connect,equals,header,accessor,get,command,this,stats,increment,connect,count,else,if,stomp,command,disconnect,equals,header,accessor,get,command,this,stats,increment,disconnect,count,try,simp,attributes,context,holder,set,attributes,from,message,message,boolean,sent,output,channel,send,message,if,sent,this,event,publisher,null,if,stomp,command,connect,equals,header,accessor,get,command,publish,event,new,session,connect,event,this,message,user,else,if,stomp,command,subscribe,equals,header,accessor,get,command,publish,event,new,session,subscribe,event,this,message,user,else,if,stomp,command,unsubscribe,equals,header,accessor,get,command,publish,event,new,session,unsubscribe,event,this,message,user,finally,simp,attributes,context,holder,reset,attributes,catch,throwable,ex,if,logger,is,error,enabled,logger,error,failed,to,send,client,message,to,application,via,message,channel,in,session,session,get,id,sending,stomp,error,to,client,ex,handle,error,session,ex,message
StompSubProtocolHandler -> public void handleMessageFromClient(WebSocketSession session, 			WebSocketMessage<?> webSocketMessage, MessageChannel outputChannel);1476284885;Handle incoming WebSocket messages from clients.;public void handleMessageFromClient(WebSocketSession session,_			WebSocketMessage<?> webSocketMessage, MessageChannel outputChannel) {__		List<Message<byte[]>> messages__		try {_			ByteBuffer byteBuffer__			if (webSocketMessage instanceof TextMessage) {_				byteBuffer = ByteBuffer.wrap(((TextMessage) webSocketMessage).asBytes())__			}_			else if (webSocketMessage instanceof BinaryMessage) {_				byteBuffer = ((BinaryMessage) webSocketMessage).getPayload()__			}_			else {_				return__			}__			BufferingStompDecoder decoder = this.decoders.get(session.getId())__			if (decoder == null) {_				throw new IllegalStateException("No decoder for session id '" + session.getId() + "'")__			}__			messages = decoder.decode(byteBuffer)__			if (messages.isEmpty()) {_				if (logger.isTraceEnabled()) {_					logger.trace("Incomplete STOMP frame content received in session " +_							session + ", bufferSize=" + decoder.getBufferSize() +_							", bufferSizeLimit=" + decoder.getBufferSizeLimit() + ".")__				}_				return__			}_		}_		catch (Throwable ex) {_			if (logger.isErrorEnabled()) {_				logger.error("Failed to parse " + webSocketMessage +_						" in session " + session.getId() + ". Sending STOMP ERROR to client.", ex)__			}_			handleError(session, ex, null)__			return__		}__		for (Message<byte[]> message : messages) {_			try {_				StompHeaderAccessor headerAccessor =_						MessageHeaderAccessor.getAccessor(message, StompHeaderAccessor.class)__				Principal user = session.getPrincipal()___				headerAccessor.setSessionId(session.getId())__				headerAccessor.setSessionAttributes(session.getAttributes())__				headerAccessor.setUser(user)__				headerAccessor.setHeader(SimpMessageHeaderAccessor.HEART_BEAT_HEADER, headerAccessor.getHeartbeat())__				if (!detectImmutableMessageInterceptor(outputChannel)) {_					headerAccessor.setImmutable()__				}__				if (logger.isTraceEnabled()) {_					logger.trace("From client: " + headerAccessor.getShortLogMessage(message.getPayload()))__				}__				if (StompCommand.CONNECT.equals(headerAccessor.getCommand())) {_					this.stats.incrementConnectCount()__				}_				else if (StompCommand.DISCONNECT.equals(headerAccessor.getCommand())) {_					this.stats.incrementDisconnectCount()__				}__				try {_					SimpAttributesContextHolder.setAttributesFromMessage(message)__					boolean sent = outputChannel.send(message)___					if (sent && this.eventPublisher != null) {_						if (StompCommand.CONNECT.equals(headerAccessor.getCommand())) {_							publishEvent(new SessionConnectEvent(this, message, user))__						}_						else if (StompCommand.SUBSCRIBE.equals(headerAccessor.getCommand())) {_							publishEvent(new SessionSubscribeEvent(this, message, user))__						}_						else if (StompCommand.UNSUBSCRIBE.equals(headerAccessor.getCommand())) {_							publishEvent(new SessionUnsubscribeEvent(this, message, user))__						}_					}_				}_				finally {_					SimpAttributesContextHolder.resetAttributes()__				}_			}_			catch (Throwable ex) {_				if (logger.isErrorEnabled()) {_					logger.error("Failed to send client message to application via MessageChannel" +_							" in session " + session.getId() + ". Sending STOMP ERROR to client.", ex)__				}_				handleError(session, ex, message)__			}_		}_	};handle,incoming,web,socket,messages,from,clients;public,void,handle,message,from,client,web,socket,session,session,web,socket,message,web,socket,message,message,channel,output,channel,list,message,byte,messages,try,byte,buffer,byte,buffer,if,web,socket,message,instanceof,text,message,byte,buffer,byte,buffer,wrap,text,message,web,socket,message,as,bytes,else,if,web,socket,message,instanceof,binary,message,byte,buffer,binary,message,web,socket,message,get,payload,else,return,buffering,stomp,decoder,decoder,this,decoders,get,session,get,id,if,decoder,null,throw,new,illegal,state,exception,no,decoder,for,session,id,session,get,id,messages,decoder,decode,byte,buffer,if,messages,is,empty,if,logger,is,trace,enabled,logger,trace,incomplete,stomp,frame,content,received,in,session,session,buffer,size,decoder,get,buffer,size,buffer,size,limit,decoder,get,buffer,size,limit,return,catch,throwable,ex,if,logger,is,error,enabled,logger,error,failed,to,parse,web,socket,message,in,session,session,get,id,sending,stomp,error,to,client,ex,handle,error,session,ex,null,return,for,message,byte,message,messages,try,stomp,header,accessor,header,accessor,message,header,accessor,get,accessor,message,stomp,header,accessor,class,principal,user,session,get,principal,header,accessor,set,session,id,session,get,id,header,accessor,set,session,attributes,session,get,attributes,header,accessor,set,user,user,header,accessor,set,header,simp,message,header,accessor,header,accessor,get,heartbeat,if,detect,immutable,message,interceptor,output,channel,header,accessor,set,immutable,if,logger,is,trace,enabled,logger,trace,from,client,header,accessor,get,short,log,message,message,get,payload,if,stomp,command,connect,equals,header,accessor,get,command,this,stats,increment,connect,count,else,if,stomp,command,disconnect,equals,header,accessor,get,command,this,stats,increment,disconnect,count,try,simp,attributes,context,holder,set,attributes,from,message,message,boolean,sent,output,channel,send,message,if,sent,this,event,publisher,null,if,stomp,command,connect,equals,header,accessor,get,command,publish,event,new,session,connect,event,this,message,user,else,if,stomp,command,subscribe,equals,header,accessor,get,command,publish,event,new,session,subscribe,event,this,message,user,else,if,stomp,command,unsubscribe,equals,header,accessor,get,command,publish,event,new,session,unsubscribe,event,this,message,user,finally,simp,attributes,context,holder,reset,attributes,catch,throwable,ex,if,logger,is,error,enabled,logger,error,failed,to,send,client,message,to,application,via,message,channel,in,session,session,get,id,sending,stomp,error,to,client,ex,handle,error,session,ex,message
StompSubProtocolHandler -> public void handleMessageFromClient(WebSocketSession session, 			WebSocketMessage<?> webSocketMessage, MessageChannel outputChannel);1481213680;Handle incoming WebSocket messages from clients.;public void handleMessageFromClient(WebSocketSession session,_			WebSocketMessage<?> webSocketMessage, MessageChannel outputChannel) {__		List<Message<byte[]>> messages__		try {_			ByteBuffer byteBuffer__			if (webSocketMessage instanceof TextMessage) {_				byteBuffer = ByteBuffer.wrap(((TextMessage) webSocketMessage).asBytes())__			}_			else if (webSocketMessage instanceof BinaryMessage) {_				byteBuffer = ((BinaryMessage) webSocketMessage).getPayload()__			}_			else {_				return__			}__			BufferingStompDecoder decoder = this.decoders.get(session.getId())__			if (decoder == null) {_				throw new IllegalStateException("No decoder for session id '" + session.getId() + "'")__			}__			messages = decoder.decode(byteBuffer)__			if (messages.isEmpty()) {_				if (logger.isTraceEnabled()) {_					logger.trace("Incomplete STOMP frame content received in session " +_							session + ", bufferSize=" + decoder.getBufferSize() +_							", bufferSizeLimit=" + decoder.getBufferSizeLimit() + ".")__				}_				return__			}_		}_		catch (Throwable ex) {_			if (logger.isErrorEnabled()) {_				logger.error("Failed to parse " + webSocketMessage +_						" in session " + session.getId() + ". Sending STOMP ERROR to client.", ex)__			}_			handleError(session, ex, null)__			return__		}__		for (Message<byte[]> message : messages) {_			try {_				StompHeaderAccessor headerAccessor =_						MessageHeaderAccessor.getAccessor(message, StompHeaderAccessor.class)__				Principal user = session.getPrincipal()___				headerAccessor.setSessionId(session.getId())__				headerAccessor.setSessionAttributes(session.getAttributes())__				headerAccessor.setUser(user)__				headerAccessor.setHeader(SimpMessageHeaderAccessor.HEART_BEAT_HEADER, headerAccessor.getHeartbeat())__				if (!detectImmutableMessageInterceptor(outputChannel)) {_					headerAccessor.setImmutable()__				}__				if (logger.isTraceEnabled()) {_					logger.trace("From client: " + headerAccessor.getShortLogMessage(message.getPayload()))__				}__				if (StompCommand.CONNECT.equals(headerAccessor.getCommand())) {_					this.stats.incrementConnectCount()__				}_				else if (StompCommand.DISCONNECT.equals(headerAccessor.getCommand())) {_					this.stats.incrementDisconnectCount()__				}__				try {_					SimpAttributesContextHolder.setAttributesFromMessage(message)__					boolean sent = outputChannel.send(message)___					if (sent && this.eventPublisher != null) {_						if (StompCommand.CONNECT.equals(headerAccessor.getCommand())) {_							publishEvent(new SessionConnectEvent(this, message, user))__						}_						else if (StompCommand.SUBSCRIBE.equals(headerAccessor.getCommand())) {_							publishEvent(new SessionSubscribeEvent(this, message, user))__						}_						else if (StompCommand.UNSUBSCRIBE.equals(headerAccessor.getCommand())) {_							publishEvent(new SessionUnsubscribeEvent(this, message, user))__						}_					}_				}_				finally {_					SimpAttributesContextHolder.resetAttributes()__				}_			}_			catch (Throwable ex) {_				if (logger.isErrorEnabled()) {_					logger.error("Failed to send client message to application via MessageChannel" +_							" in session " + session.getId() + ". Sending STOMP ERROR to client.", ex)__				}_				handleError(session, ex, message)__			}_		}_	};handle,incoming,web,socket,messages,from,clients;public,void,handle,message,from,client,web,socket,session,session,web,socket,message,web,socket,message,message,channel,output,channel,list,message,byte,messages,try,byte,buffer,byte,buffer,if,web,socket,message,instanceof,text,message,byte,buffer,byte,buffer,wrap,text,message,web,socket,message,as,bytes,else,if,web,socket,message,instanceof,binary,message,byte,buffer,binary,message,web,socket,message,get,payload,else,return,buffering,stomp,decoder,decoder,this,decoders,get,session,get,id,if,decoder,null,throw,new,illegal,state,exception,no,decoder,for,session,id,session,get,id,messages,decoder,decode,byte,buffer,if,messages,is,empty,if,logger,is,trace,enabled,logger,trace,incomplete,stomp,frame,content,received,in,session,session,buffer,size,decoder,get,buffer,size,buffer,size,limit,decoder,get,buffer,size,limit,return,catch,throwable,ex,if,logger,is,error,enabled,logger,error,failed,to,parse,web,socket,message,in,session,session,get,id,sending,stomp,error,to,client,ex,handle,error,session,ex,null,return,for,message,byte,message,messages,try,stomp,header,accessor,header,accessor,message,header,accessor,get,accessor,message,stomp,header,accessor,class,principal,user,session,get,principal,header,accessor,set,session,id,session,get,id,header,accessor,set,session,attributes,session,get,attributes,header,accessor,set,user,user,header,accessor,set,header,simp,message,header,accessor,header,accessor,get,heartbeat,if,detect,immutable,message,interceptor,output,channel,header,accessor,set,immutable,if,logger,is,trace,enabled,logger,trace,from,client,header,accessor,get,short,log,message,message,get,payload,if,stomp,command,connect,equals,header,accessor,get,command,this,stats,increment,connect,count,else,if,stomp,command,disconnect,equals,header,accessor,get,command,this,stats,increment,disconnect,count,try,simp,attributes,context,holder,set,attributes,from,message,message,boolean,sent,output,channel,send,message,if,sent,this,event,publisher,null,if,stomp,command,connect,equals,header,accessor,get,command,publish,event,new,session,connect,event,this,message,user,else,if,stomp,command,subscribe,equals,header,accessor,get,command,publish,event,new,session,subscribe,event,this,message,user,else,if,stomp,command,unsubscribe,equals,header,accessor,get,command,publish,event,new,session,unsubscribe,event,this,message,user,finally,simp,attributes,context,holder,reset,attributes,catch,throwable,ex,if,logger,is,error,enabled,logger,error,failed,to,send,client,message,to,application,via,message,channel,in,session,session,get,id,sending,stomp,error,to,client,ex,handle,error,session,ex,message
StompSubProtocolHandler -> public void handleMessageFromClient(WebSocketSession session, 			WebSocketMessage<?> webSocketMessage, MessageChannel outputChannel);1481669991;Handle incoming WebSocket messages from clients.;public void handleMessageFromClient(WebSocketSession session,_			WebSocketMessage<?> webSocketMessage, MessageChannel outputChannel) {__		List<Message<byte[]>> messages__		try {_			ByteBuffer byteBuffer__			if (webSocketMessage instanceof TextMessage) {_				byteBuffer = ByteBuffer.wrap(((TextMessage) webSocketMessage).asBytes())__			}_			else if (webSocketMessage instanceof BinaryMessage) {_				byteBuffer = ((BinaryMessage) webSocketMessage).getPayload()__			}_			else {_				return__			}__			BufferingStompDecoder decoder = this.decoders.get(session.getId())__			if (decoder == null) {_				throw new IllegalStateException("No decoder for session id '" + session.getId() + "'")__			}__			messages = decoder.decode(byteBuffer)__			if (messages.isEmpty()) {_				if (logger.isTraceEnabled()) {_					logger.trace("Incomplete STOMP frame content received in session " +_							session + ", bufferSize=" + decoder.getBufferSize() +_							", bufferSizeLimit=" + decoder.getBufferSizeLimit() + ".")__				}_				return__			}_		}_		catch (Throwable ex) {_			if (logger.isErrorEnabled()) {_				logger.error("Failed to parse " + webSocketMessage +_						" in session " + session.getId() + ". Sending STOMP ERROR to client.", ex)__			}_			handleError(session, ex, null)__			return__		}__		for (Message<byte[]> message : messages) {_			try {_				StompHeaderAccessor headerAccessor =_						MessageHeaderAccessor.getAccessor(message, StompHeaderAccessor.class)___				headerAccessor.setSessionId(session.getId())__				headerAccessor.setSessionAttributes(session.getAttributes())__				headerAccessor.setUser(getUser(session))__				headerAccessor.setHeader(SimpMessageHeaderAccessor.HEART_BEAT_HEADER, headerAccessor.getHeartbeat())__				if (!detectImmutableMessageInterceptor(outputChannel)) {_					headerAccessor.setImmutable()__				}__				if (logger.isTraceEnabled()) {_					logger.trace("From client: " + headerAccessor.getShortLogMessage(message.getPayload()))__				}__				boolean isConnect = StompCommand.CONNECT.equals(headerAccessor.getCommand())__				if (isConnect) {_					this.stats.incrementConnectCount()__				}_				else if (StompCommand.DISCONNECT.equals(headerAccessor.getCommand())) {_					this.stats.incrementDisconnectCount()__				}__				try {_					SimpAttributesContextHolder.setAttributesFromMessage(message)__					boolean sent = outputChannel.send(message)___					if (sent) {_						if (isConnect) {_							Principal user = headerAccessor.getUser()__							if (user != null && user != session.getPrincipal()) {_								this.stompAuthentications.put(session.getId(), user)__							}_						}_						if (this.eventPublisher != null) {_							if (isConnect) {_								publishEvent(new SessionConnectEvent(this, message, getUser(session)))__							}_							else if (StompCommand.SUBSCRIBE.equals(headerAccessor.getCommand())) {_								publishEvent(new SessionSubscribeEvent(this, message, getUser(session)))__							}_							else if (StompCommand.UNSUBSCRIBE.equals(headerAccessor.getCommand())) {_								publishEvent(new SessionUnsubscribeEvent(this, message, getUser(session)))__							}_						}_					}_				}_				finally {_					SimpAttributesContextHolder.resetAttributes()__				}_			}_			catch (Throwable ex) {_				if (logger.isErrorEnabled()) {_					logger.error("Failed to send client message to application via MessageChannel" +_							" in session " + session.getId() + ". Sending STOMP ERROR to client.", ex)__				}_				handleError(session, ex, message)__			}_		}_	};handle,incoming,web,socket,messages,from,clients;public,void,handle,message,from,client,web,socket,session,session,web,socket,message,web,socket,message,message,channel,output,channel,list,message,byte,messages,try,byte,buffer,byte,buffer,if,web,socket,message,instanceof,text,message,byte,buffer,byte,buffer,wrap,text,message,web,socket,message,as,bytes,else,if,web,socket,message,instanceof,binary,message,byte,buffer,binary,message,web,socket,message,get,payload,else,return,buffering,stomp,decoder,decoder,this,decoders,get,session,get,id,if,decoder,null,throw,new,illegal,state,exception,no,decoder,for,session,id,session,get,id,messages,decoder,decode,byte,buffer,if,messages,is,empty,if,logger,is,trace,enabled,logger,trace,incomplete,stomp,frame,content,received,in,session,session,buffer,size,decoder,get,buffer,size,buffer,size,limit,decoder,get,buffer,size,limit,return,catch,throwable,ex,if,logger,is,error,enabled,logger,error,failed,to,parse,web,socket,message,in,session,session,get,id,sending,stomp,error,to,client,ex,handle,error,session,ex,null,return,for,message,byte,message,messages,try,stomp,header,accessor,header,accessor,message,header,accessor,get,accessor,message,stomp,header,accessor,class,header,accessor,set,session,id,session,get,id,header,accessor,set,session,attributes,session,get,attributes,header,accessor,set,user,get,user,session,header,accessor,set,header,simp,message,header,accessor,header,accessor,get,heartbeat,if,detect,immutable,message,interceptor,output,channel,header,accessor,set,immutable,if,logger,is,trace,enabled,logger,trace,from,client,header,accessor,get,short,log,message,message,get,payload,boolean,is,connect,stomp,command,connect,equals,header,accessor,get,command,if,is,connect,this,stats,increment,connect,count,else,if,stomp,command,disconnect,equals,header,accessor,get,command,this,stats,increment,disconnect,count,try,simp,attributes,context,holder,set,attributes,from,message,message,boolean,sent,output,channel,send,message,if,sent,if,is,connect,principal,user,header,accessor,get,user,if,user,null,user,session,get,principal,this,stomp,authentications,put,session,get,id,user,if,this,event,publisher,null,if,is,connect,publish,event,new,session,connect,event,this,message,get,user,session,else,if,stomp,command,subscribe,equals,header,accessor,get,command,publish,event,new,session,subscribe,event,this,message,get,user,session,else,if,stomp,command,unsubscribe,equals,header,accessor,get,command,publish,event,new,session,unsubscribe,event,this,message,get,user,session,finally,simp,attributes,context,holder,reset,attributes,catch,throwable,ex,if,logger,is,error,enabled,logger,error,failed,to,send,client,message,to,application,via,message,channel,in,session,session,get,id,sending,stomp,error,to,client,ex,handle,error,session,ex,message
StompSubProtocolHandler -> public void handleMessageFromClient(WebSocketSession session, 			WebSocketMessage<?> webSocketMessage, MessageChannel outputChannel);1482265068;Handle incoming WebSocket messages from clients.;public void handleMessageFromClient(WebSocketSession session,_			WebSocketMessage<?> webSocketMessage, MessageChannel outputChannel) {__		List<Message<byte[]>> messages__		try {_			ByteBuffer byteBuffer__			if (webSocketMessage instanceof TextMessage) {_				byteBuffer = ByteBuffer.wrap(((TextMessage) webSocketMessage).asBytes())__			}_			else if (webSocketMessage instanceof BinaryMessage) {_				byteBuffer = ((BinaryMessage) webSocketMessage).getPayload()__			}_			else {_				return__			}__			BufferingStompDecoder decoder = this.decoders.get(session.getId())__			if (decoder == null) {_				throw new IllegalStateException("No decoder for session id '" + session.getId() + "'")__			}__			messages = decoder.decode(byteBuffer)__			if (messages.isEmpty()) {_				if (logger.isTraceEnabled()) {_					logger.trace("Incomplete STOMP frame content received in session " +_							session + ", bufferSize=" + decoder.getBufferSize() +_							", bufferSizeLimit=" + decoder.getBufferSizeLimit() + ".")__				}_				return__			}_		}_		catch (Throwable ex) {_			if (logger.isErrorEnabled()) {_				logger.error("Failed to parse " + webSocketMessage +_						" in session " + session.getId() + ". Sending STOMP ERROR to client.", ex)__			}_			handleError(session, ex, null)__			return__		}__		for (Message<byte[]> message : messages) {_			try {_				StompHeaderAccessor headerAccessor =_						MessageHeaderAccessor.getAccessor(message, StompHeaderAccessor.class)___				headerAccessor.setSessionId(session.getId())__				headerAccessor.setSessionAttributes(session.getAttributes())__				headerAccessor.setUser(getUser(session))__				headerAccessor.setHeader(SimpMessageHeaderAccessor.HEART_BEAT_HEADER, headerAccessor.getHeartbeat())__				if (!detectImmutableMessageInterceptor(outputChannel)) {_					headerAccessor.setImmutable()__				}__				if (logger.isTraceEnabled()) {_					logger.trace("From client: " + headerAccessor.getShortLogMessage(message.getPayload()))__				}__				boolean isConnect = StompCommand.CONNECT.equals(headerAccessor.getCommand())__				if (isConnect) {_					this.stats.incrementConnectCount()__				}_				else if (StompCommand.DISCONNECT.equals(headerAccessor.getCommand())) {_					this.stats.incrementDisconnectCount()__				}__				try {_					SimpAttributesContextHolder.setAttributesFromMessage(message)__					boolean sent = outputChannel.send(message)___					if (sent) {_						if (isConnect) {_							Principal user = headerAccessor.getUser()__							if (user != null && user != session.getPrincipal()) {_								this.stompAuthentications.put(session.getId(), user)__							}_						}_						if (this.eventPublisher != null) {_							if (isConnect) {_								publishEvent(new SessionConnectEvent(this, message, getUser(session)))__							}_							else if (StompCommand.SUBSCRIBE.equals(headerAccessor.getCommand())) {_								publishEvent(new SessionSubscribeEvent(this, message, getUser(session)))__							}_							else if (StompCommand.UNSUBSCRIBE.equals(headerAccessor.getCommand())) {_								publishEvent(new SessionUnsubscribeEvent(this, message, getUser(session)))__							}_						}_					}_				}_				finally {_					SimpAttributesContextHolder.resetAttributes()__				}_			}_			catch (Throwable ex) {_				if (logger.isErrorEnabled()) {_					logger.error("Failed to send client message to application via MessageChannel" +_							" in session " + session.getId() + ". Sending STOMP ERROR to client.", ex)__				}_				handleError(session, ex, message)__			}_		}_	};handle,incoming,web,socket,messages,from,clients;public,void,handle,message,from,client,web,socket,session,session,web,socket,message,web,socket,message,message,channel,output,channel,list,message,byte,messages,try,byte,buffer,byte,buffer,if,web,socket,message,instanceof,text,message,byte,buffer,byte,buffer,wrap,text,message,web,socket,message,as,bytes,else,if,web,socket,message,instanceof,binary,message,byte,buffer,binary,message,web,socket,message,get,payload,else,return,buffering,stomp,decoder,decoder,this,decoders,get,session,get,id,if,decoder,null,throw,new,illegal,state,exception,no,decoder,for,session,id,session,get,id,messages,decoder,decode,byte,buffer,if,messages,is,empty,if,logger,is,trace,enabled,logger,trace,incomplete,stomp,frame,content,received,in,session,session,buffer,size,decoder,get,buffer,size,buffer,size,limit,decoder,get,buffer,size,limit,return,catch,throwable,ex,if,logger,is,error,enabled,logger,error,failed,to,parse,web,socket,message,in,session,session,get,id,sending,stomp,error,to,client,ex,handle,error,session,ex,null,return,for,message,byte,message,messages,try,stomp,header,accessor,header,accessor,message,header,accessor,get,accessor,message,stomp,header,accessor,class,header,accessor,set,session,id,session,get,id,header,accessor,set,session,attributes,session,get,attributes,header,accessor,set,user,get,user,session,header,accessor,set,header,simp,message,header,accessor,header,accessor,get,heartbeat,if,detect,immutable,message,interceptor,output,channel,header,accessor,set,immutable,if,logger,is,trace,enabled,logger,trace,from,client,header,accessor,get,short,log,message,message,get,payload,boolean,is,connect,stomp,command,connect,equals,header,accessor,get,command,if,is,connect,this,stats,increment,connect,count,else,if,stomp,command,disconnect,equals,header,accessor,get,command,this,stats,increment,disconnect,count,try,simp,attributes,context,holder,set,attributes,from,message,message,boolean,sent,output,channel,send,message,if,sent,if,is,connect,principal,user,header,accessor,get,user,if,user,null,user,session,get,principal,this,stomp,authentications,put,session,get,id,user,if,this,event,publisher,null,if,is,connect,publish,event,new,session,connect,event,this,message,get,user,session,else,if,stomp,command,subscribe,equals,header,accessor,get,command,publish,event,new,session,subscribe,event,this,message,get,user,session,else,if,stomp,command,unsubscribe,equals,header,accessor,get,command,publish,event,new,session,unsubscribe,event,this,message,get,user,session,finally,simp,attributes,context,holder,reset,attributes,catch,throwable,ex,if,logger,is,error,enabled,logger,error,failed,to,send,client,message,to,application,via,message,channel,in,session,session,get,id,sending,stomp,error,to,client,ex,handle,error,session,ex,message
StompSubProtocolHandler -> public void handleMessageFromClient(WebSocketSession session, 			WebSocketMessage<?> webSocketMessage, MessageChannel outputChannel);1495868221;Handle incoming WebSocket messages from clients.;public void handleMessageFromClient(WebSocketSession session,_			WebSocketMessage<?> webSocketMessage, MessageChannel outputChannel) {__		List<Message<byte[]>> messages__		try {_			ByteBuffer byteBuffer__			if (webSocketMessage instanceof TextMessage) {_				byteBuffer = ByteBuffer.wrap(((TextMessage) webSocketMessage).asBytes())__			}_			else if (webSocketMessage instanceof BinaryMessage) {_				byteBuffer = ((BinaryMessage) webSocketMessage).getPayload()__			}_			else {_				return__			}__			BufferingStompDecoder decoder = this.decoders.get(session.getId())__			if (decoder == null) {_				throw new IllegalStateException("No decoder for session id '" + session.getId() + "'")__			}__			messages = decoder.decode(byteBuffer)__			if (messages.isEmpty()) {_				if (logger.isTraceEnabled()) {_					logger.trace("Incomplete STOMP frame content received in session " +_							session + ", bufferSize=" + decoder.getBufferSize() +_							", bufferSizeLimit=" + decoder.getBufferSizeLimit() + ".")__				}_				return__			}_		}_		catch (Throwable ex) {_			if (logger.isErrorEnabled()) {_				logger.error("Failed to parse " + webSocketMessage +_						" in session " + session.getId() + ". Sending STOMP ERROR to client.", ex)__			}_			handleError(session, ex, null)__			return__		}__		for (Message<byte[]> message : messages) {_			try {_				StompHeaderAccessor headerAccessor =_						MessageHeaderAccessor.getAccessor(message, StompHeaderAccessor.class)___				headerAccessor.setSessionId(session.getId())__				headerAccessor.setSessionAttributes(session.getAttributes())__				headerAccessor.setUser(getUser(session))__				headerAccessor.setHeader(SimpMessageHeaderAccessor.HEART_BEAT_HEADER, headerAccessor.getHeartbeat())__				if (!detectImmutableMessageInterceptor(outputChannel)) {_					headerAccessor.setImmutable()__				}__				if (logger.isTraceEnabled()) {_					logger.trace("From client: " + headerAccessor.getShortLogMessage(message.getPayload()))__				}__				boolean isConnect = StompCommand.CONNECT.equals(headerAccessor.getCommand())__				if (isConnect) {_					this.stats.incrementConnectCount()__				}_				else if (StompCommand.DISCONNECT.equals(headerAccessor.getCommand())) {_					this.stats.incrementDisconnectCount()__				}__				try {_					SimpAttributesContextHolder.setAttributesFromMessage(message)__					boolean sent = outputChannel.send(message)___					if (sent) {_						if (isConnect) {_							Principal user = headerAccessor.getUser()__							if (user != null && user != session.getPrincipal()) {_								this.stompAuthentications.put(session.getId(), user)__							}_						}_						if (this.eventPublisher != null) {_							if (isConnect) {_								publishEvent(new SessionConnectEvent(this, message, getUser(session)))__							}_							else if (StompCommand.SUBSCRIBE.equals(headerAccessor.getCommand())) {_								publishEvent(new SessionSubscribeEvent(this, message, getUser(session)))__							}_							else if (StompCommand.UNSUBSCRIBE.equals(headerAccessor.getCommand())) {_								publishEvent(new SessionUnsubscribeEvent(this, message, getUser(session)))__							}_						}_					}_				}_				finally {_					SimpAttributesContextHolder.resetAttributes()__				}_			}_			catch (Throwable ex) {_				if (logger.isErrorEnabled()) {_					logger.error("Failed to send client message to application via MessageChannel" +_							" in session " + session.getId() + ". Sending STOMP ERROR to client.", ex)__				}_				handleError(session, ex, message)__			}_		}_	};handle,incoming,web,socket,messages,from,clients;public,void,handle,message,from,client,web,socket,session,session,web,socket,message,web,socket,message,message,channel,output,channel,list,message,byte,messages,try,byte,buffer,byte,buffer,if,web,socket,message,instanceof,text,message,byte,buffer,byte,buffer,wrap,text,message,web,socket,message,as,bytes,else,if,web,socket,message,instanceof,binary,message,byte,buffer,binary,message,web,socket,message,get,payload,else,return,buffering,stomp,decoder,decoder,this,decoders,get,session,get,id,if,decoder,null,throw,new,illegal,state,exception,no,decoder,for,session,id,session,get,id,messages,decoder,decode,byte,buffer,if,messages,is,empty,if,logger,is,trace,enabled,logger,trace,incomplete,stomp,frame,content,received,in,session,session,buffer,size,decoder,get,buffer,size,buffer,size,limit,decoder,get,buffer,size,limit,return,catch,throwable,ex,if,logger,is,error,enabled,logger,error,failed,to,parse,web,socket,message,in,session,session,get,id,sending,stomp,error,to,client,ex,handle,error,session,ex,null,return,for,message,byte,message,messages,try,stomp,header,accessor,header,accessor,message,header,accessor,get,accessor,message,stomp,header,accessor,class,header,accessor,set,session,id,session,get,id,header,accessor,set,session,attributes,session,get,attributes,header,accessor,set,user,get,user,session,header,accessor,set,header,simp,message,header,accessor,header,accessor,get,heartbeat,if,detect,immutable,message,interceptor,output,channel,header,accessor,set,immutable,if,logger,is,trace,enabled,logger,trace,from,client,header,accessor,get,short,log,message,message,get,payload,boolean,is,connect,stomp,command,connect,equals,header,accessor,get,command,if,is,connect,this,stats,increment,connect,count,else,if,stomp,command,disconnect,equals,header,accessor,get,command,this,stats,increment,disconnect,count,try,simp,attributes,context,holder,set,attributes,from,message,message,boolean,sent,output,channel,send,message,if,sent,if,is,connect,principal,user,header,accessor,get,user,if,user,null,user,session,get,principal,this,stomp,authentications,put,session,get,id,user,if,this,event,publisher,null,if,is,connect,publish,event,new,session,connect,event,this,message,get,user,session,else,if,stomp,command,subscribe,equals,header,accessor,get,command,publish,event,new,session,subscribe,event,this,message,get,user,session,else,if,stomp,command,unsubscribe,equals,header,accessor,get,command,publish,event,new,session,unsubscribe,event,this,message,get,user,session,finally,simp,attributes,context,holder,reset,attributes,catch,throwable,ex,if,logger,is,error,enabled,logger,error,failed,to,send,client,message,to,application,via,message,channel,in,session,session,get,id,sending,stomp,error,to,client,ex,handle,error,session,ex,message
StompSubProtocolHandler -> public void handleMessageFromClient(WebSocketSession session, 			WebSocketMessage<?> webSocketMessage, MessageChannel outputChannel);1496837955;Handle incoming WebSocket messages from clients.;public void handleMessageFromClient(WebSocketSession session,_			WebSocketMessage<?> webSocketMessage, MessageChannel outputChannel) {__		List<Message<byte[]>> messages__		try {_			ByteBuffer byteBuffer__			if (webSocketMessage instanceof TextMessage) {_				byteBuffer = ByteBuffer.wrap(((TextMessage) webSocketMessage).asBytes())__			}_			else if (webSocketMessage instanceof BinaryMessage) {_				byteBuffer = ((BinaryMessage) webSocketMessage).getPayload()__			}_			else {_				return__			}__			BufferingStompDecoder decoder = this.decoders.get(session.getId())__			if (decoder == null) {_				throw new IllegalStateException("No decoder for session id '" + session.getId() + "'")__			}__			messages = decoder.decode(byteBuffer)__			if (messages.isEmpty()) {_				if (logger.isTraceEnabled()) {_					logger.trace("Incomplete STOMP frame content received in session " +_							session + ", bufferSize=" + decoder.getBufferSize() +_							", bufferSizeLimit=" + decoder.getBufferSizeLimit() + ".")__				}_				return__			}_		}_		catch (Throwable ex) {_			if (logger.isErrorEnabled()) {_				logger.error("Failed to parse " + webSocketMessage +_						" in session " + session.getId() + ". Sending STOMP ERROR to client.", ex)__			}_			handleError(session, ex, null)__			return__		}__		for (Message<byte[]> message : messages) {_			try {_				StompHeaderAccessor headerAccessor =_						MessageHeaderAccessor.getAccessor(message, StompHeaderAccessor.class)__				Assert.state(headerAccessor != null, "No StompHeaderAccessor")___				headerAccessor.setSessionId(session.getId())__				headerAccessor.setSessionAttributes(session.getAttributes())___				Principal user = getUser(session)__				if (user != null) {_					headerAccessor.setUser(user)__				}__				headerAccessor.setHeader(SimpMessageHeaderAccessor.HEART_BEAT_HEADER, headerAccessor.getHeartbeat())__				if (!detectImmutableMessageInterceptor(outputChannel)) {_					headerAccessor.setImmutable()__				}__				if (logger.isTraceEnabled()) {_					logger.trace("From client: " + headerAccessor.getShortLogMessage(message.getPayload()))__				}__				boolean isConnect = StompCommand.CONNECT.equals(headerAccessor.getCommand())__				if (isConnect) {_					this.stats.incrementConnectCount()__				}_				else if (StompCommand.DISCONNECT.equals(headerAccessor.getCommand())) {_					this.stats.incrementDisconnectCount()__				}__				try {_					SimpAttributesContextHolder.setAttributesFromMessage(message)__					boolean sent = outputChannel.send(message)___					if (sent) {_						if (isConnect) {_							if (user != null && user != session.getPrincipal()) {_								this.stompAuthentications.put(session.getId(), user)__							}_						}_						if (this.eventPublisher != null) {_							if (isConnect) {_								publishEvent(new SessionConnectEvent(this, message, user))__							}_							else if (StompCommand.SUBSCRIBE.equals(headerAccessor.getCommand())) {_								publishEvent(new SessionSubscribeEvent(this, message, user))__							}_							else if (StompCommand.UNSUBSCRIBE.equals(headerAccessor.getCommand())) {_								publishEvent(new SessionUnsubscribeEvent(this, message, user))__							}_						}_					}_				}_				finally {_					SimpAttributesContextHolder.resetAttributes()__				}_			}_			catch (Throwable ex) {_				if (logger.isErrorEnabled()) {_					logger.error("Failed to send client message to application via MessageChannel" +_							" in session " + session.getId() + ". Sending STOMP ERROR to client.", ex)__				}_				handleError(session, ex, message)__			}_		}_	};handle,incoming,web,socket,messages,from,clients;public,void,handle,message,from,client,web,socket,session,session,web,socket,message,web,socket,message,message,channel,output,channel,list,message,byte,messages,try,byte,buffer,byte,buffer,if,web,socket,message,instanceof,text,message,byte,buffer,byte,buffer,wrap,text,message,web,socket,message,as,bytes,else,if,web,socket,message,instanceof,binary,message,byte,buffer,binary,message,web,socket,message,get,payload,else,return,buffering,stomp,decoder,decoder,this,decoders,get,session,get,id,if,decoder,null,throw,new,illegal,state,exception,no,decoder,for,session,id,session,get,id,messages,decoder,decode,byte,buffer,if,messages,is,empty,if,logger,is,trace,enabled,logger,trace,incomplete,stomp,frame,content,received,in,session,session,buffer,size,decoder,get,buffer,size,buffer,size,limit,decoder,get,buffer,size,limit,return,catch,throwable,ex,if,logger,is,error,enabled,logger,error,failed,to,parse,web,socket,message,in,session,session,get,id,sending,stomp,error,to,client,ex,handle,error,session,ex,null,return,for,message,byte,message,messages,try,stomp,header,accessor,header,accessor,message,header,accessor,get,accessor,message,stomp,header,accessor,class,assert,state,header,accessor,null,no,stomp,header,accessor,header,accessor,set,session,id,session,get,id,header,accessor,set,session,attributes,session,get,attributes,principal,user,get,user,session,if,user,null,header,accessor,set,user,user,header,accessor,set,header,simp,message,header,accessor,header,accessor,get,heartbeat,if,detect,immutable,message,interceptor,output,channel,header,accessor,set,immutable,if,logger,is,trace,enabled,logger,trace,from,client,header,accessor,get,short,log,message,message,get,payload,boolean,is,connect,stomp,command,connect,equals,header,accessor,get,command,if,is,connect,this,stats,increment,connect,count,else,if,stomp,command,disconnect,equals,header,accessor,get,command,this,stats,increment,disconnect,count,try,simp,attributes,context,holder,set,attributes,from,message,message,boolean,sent,output,channel,send,message,if,sent,if,is,connect,if,user,null,user,session,get,principal,this,stomp,authentications,put,session,get,id,user,if,this,event,publisher,null,if,is,connect,publish,event,new,session,connect,event,this,message,user,else,if,stomp,command,subscribe,equals,header,accessor,get,command,publish,event,new,session,subscribe,event,this,message,user,else,if,stomp,command,unsubscribe,equals,header,accessor,get,command,publish,event,new,session,unsubscribe,event,this,message,user,finally,simp,attributes,context,holder,reset,attributes,catch,throwable,ex,if,logger,is,error,enabled,logger,error,failed,to,send,client,message,to,application,via,message,channel,in,session,session,get,id,sending,stomp,error,to,client,ex,handle,error,session,ex,message
StompSubProtocolHandler -> public void handleMessageFromClient(WebSocketSession session, 			WebSocketMessage<?> webSocketMessage, MessageChannel outputChannel);1497251962;Handle incoming WebSocket messages from clients.;public void handleMessageFromClient(WebSocketSession session,_			WebSocketMessage<?> webSocketMessage, MessageChannel outputChannel) {__		List<Message<byte[]>> messages__		try {_			ByteBuffer byteBuffer__			if (webSocketMessage instanceof TextMessage) {_				byteBuffer = ByteBuffer.wrap(((TextMessage) webSocketMessage).asBytes())__			}_			else if (webSocketMessage instanceof BinaryMessage) {_				byteBuffer = ((BinaryMessage) webSocketMessage).getPayload()__			}_			else {_				return__			}__			BufferingStompDecoder decoder = this.decoders.get(session.getId())__			if (decoder == null) {_				throw new IllegalStateException("No decoder for session id '" + session.getId() + "'")__			}__			messages = decoder.decode(byteBuffer)__			if (messages.isEmpty()) {_				if (logger.isTraceEnabled()) {_					logger.trace("Incomplete STOMP frame content received in session " +_							session + ", bufferSize=" + decoder.getBufferSize() +_							", bufferSizeLimit=" + decoder.getBufferSizeLimit() + ".")__				}_				return__			}_		}_		catch (Throwable ex) {_			if (logger.isErrorEnabled()) {_				logger.error("Failed to parse " + webSocketMessage +_						" in session " + session.getId() + ". Sending STOMP ERROR to client.", ex)__			}_			handleError(session, ex, null)__			return__		}__		for (Message<byte[]> message : messages) {_			try {_				StompHeaderAccessor headerAccessor =_						MessageHeaderAccessor.getAccessor(message, StompHeaderAccessor.class)__				Assert.state(headerAccessor != null, "No StompHeaderAccessor")___				headerAccessor.setSessionId(session.getId())__				headerAccessor.setSessionAttributes(session.getAttributes())___				Principal user = getUser(session)__				if (user != null) {_					headerAccessor.setUser(user)__				}__				headerAccessor.setHeader(SimpMessageHeaderAccessor.HEART_BEAT_HEADER, headerAccessor.getHeartbeat())__				if (!detectImmutableMessageInterceptor(outputChannel)) {_					headerAccessor.setImmutable()__				}__				if (logger.isTraceEnabled()) {_					logger.trace("From client: " + headerAccessor.getShortLogMessage(message.getPayload()))__				}__				boolean isConnect = StompCommand.CONNECT.equals(headerAccessor.getCommand())__				if (isConnect) {_					this.stats.incrementConnectCount()__				}_				else if (StompCommand.DISCONNECT.equals(headerAccessor.getCommand())) {_					this.stats.incrementDisconnectCount()__				}__				try {_					SimpAttributesContextHolder.setAttributesFromMessage(message)__					boolean sent = outputChannel.send(message)___					if (sent) {_						if (isConnect) {_							if (user != null && user != session.getPrincipal()) {_								this.stompAuthentications.put(session.getId(), user)__							}_						}_						if (this.eventPublisher != null) {_							if (isConnect) {_								publishEvent(new SessionConnectEvent(this, message, user))__							}_							else if (StompCommand.SUBSCRIBE.equals(headerAccessor.getCommand())) {_								publishEvent(new SessionSubscribeEvent(this, message, user))__							}_							else if (StompCommand.UNSUBSCRIBE.equals(headerAccessor.getCommand())) {_								publishEvent(new SessionUnsubscribeEvent(this, message, user))__							}_						}_					}_				}_				finally {_					SimpAttributesContextHolder.resetAttributes()__				}_			}_			catch (Throwable ex) {_				if (logger.isErrorEnabled()) {_					logger.error("Failed to send client message to application via MessageChannel" +_							" in session " + session.getId() + ". Sending STOMP ERROR to client.", ex)__				}_				handleError(session, ex, message)__			}_		}_	};handle,incoming,web,socket,messages,from,clients;public,void,handle,message,from,client,web,socket,session,session,web,socket,message,web,socket,message,message,channel,output,channel,list,message,byte,messages,try,byte,buffer,byte,buffer,if,web,socket,message,instanceof,text,message,byte,buffer,byte,buffer,wrap,text,message,web,socket,message,as,bytes,else,if,web,socket,message,instanceof,binary,message,byte,buffer,binary,message,web,socket,message,get,payload,else,return,buffering,stomp,decoder,decoder,this,decoders,get,session,get,id,if,decoder,null,throw,new,illegal,state,exception,no,decoder,for,session,id,session,get,id,messages,decoder,decode,byte,buffer,if,messages,is,empty,if,logger,is,trace,enabled,logger,trace,incomplete,stomp,frame,content,received,in,session,session,buffer,size,decoder,get,buffer,size,buffer,size,limit,decoder,get,buffer,size,limit,return,catch,throwable,ex,if,logger,is,error,enabled,logger,error,failed,to,parse,web,socket,message,in,session,session,get,id,sending,stomp,error,to,client,ex,handle,error,session,ex,null,return,for,message,byte,message,messages,try,stomp,header,accessor,header,accessor,message,header,accessor,get,accessor,message,stomp,header,accessor,class,assert,state,header,accessor,null,no,stomp,header,accessor,header,accessor,set,session,id,session,get,id,header,accessor,set,session,attributes,session,get,attributes,principal,user,get,user,session,if,user,null,header,accessor,set,user,user,header,accessor,set,header,simp,message,header,accessor,header,accessor,get,heartbeat,if,detect,immutable,message,interceptor,output,channel,header,accessor,set,immutable,if,logger,is,trace,enabled,logger,trace,from,client,header,accessor,get,short,log,message,message,get,payload,boolean,is,connect,stomp,command,connect,equals,header,accessor,get,command,if,is,connect,this,stats,increment,connect,count,else,if,stomp,command,disconnect,equals,header,accessor,get,command,this,stats,increment,disconnect,count,try,simp,attributes,context,holder,set,attributes,from,message,message,boolean,sent,output,channel,send,message,if,sent,if,is,connect,if,user,null,user,session,get,principal,this,stomp,authentications,put,session,get,id,user,if,this,event,publisher,null,if,is,connect,publish,event,new,session,connect,event,this,message,user,else,if,stomp,command,subscribe,equals,header,accessor,get,command,publish,event,new,session,subscribe,event,this,message,user,else,if,stomp,command,unsubscribe,equals,header,accessor,get,command,publish,event,new,session,unsubscribe,event,this,message,user,finally,simp,attributes,context,holder,reset,attributes,catch,throwable,ex,if,logger,is,error,enabled,logger,error,failed,to,send,client,message,to,application,via,message,channel,in,session,session,get,id,sending,stomp,error,to,client,ex,handle,error,session,ex,message
StompSubProtocolHandler -> public void handleMessageFromClient(WebSocketSession session, 			WebSocketMessage<?> webSocketMessage, MessageChannel outputChannel);1498780456;Handle incoming WebSocket messages from clients.;public void handleMessageFromClient(WebSocketSession session,_			WebSocketMessage<?> webSocketMessage, MessageChannel outputChannel) {__		List<Message<byte[]>> messages__		try {_			ByteBuffer byteBuffer__			if (webSocketMessage instanceof TextMessage) {_				byteBuffer = ByteBuffer.wrap(((TextMessage) webSocketMessage).asBytes())__			}_			else if (webSocketMessage instanceof BinaryMessage) {_				byteBuffer = ((BinaryMessage) webSocketMessage).getPayload()__			}_			else {_				return__			}__			BufferingStompDecoder decoder = this.decoders.get(session.getId())__			if (decoder == null) {_				throw new IllegalStateException("No decoder for session id '" + session.getId() + "'")__			}__			messages = decoder.decode(byteBuffer)__			if (messages.isEmpty()) {_				if (logger.isTraceEnabled()) {_					logger.trace("Incomplete STOMP frame content received in session " +_							session + ", bufferSize=" + decoder.getBufferSize() +_							", bufferSizeLimit=" + decoder.getBufferSizeLimit() + ".")__				}_				return__			}_		}_		catch (Throwable ex) {_			if (logger.isErrorEnabled()) {_				logger.error("Failed to parse " + webSocketMessage +_						" in session " + session.getId() + ". Sending STOMP ERROR to client.", ex)__			}_			handleError(session, ex, null)__			return__		}__		for (Message<byte[]> message : messages) {_			try {_				StompHeaderAccessor headerAccessor =_						MessageHeaderAccessor.getAccessor(message, StompHeaderAccessor.class)__				Assert.state(headerAccessor != null, "No StompHeaderAccessor")___				headerAccessor.setSessionId(session.getId())__				headerAccessor.setSessionAttributes(session.getAttributes())___				Principal user = getUser(session)__				if (user != null) {_					headerAccessor.setUser(user)__				}__				headerAccessor.setHeader(SimpMessageHeaderAccessor.HEART_BEAT_HEADER, headerAccessor.getHeartbeat())__				if (!detectImmutableMessageInterceptor(outputChannel)) {_					headerAccessor.setImmutable()__				}__				if (logger.isTraceEnabled()) {_					logger.trace("From client: " + headerAccessor.getShortLogMessage(message.getPayload()))__				}__				boolean isConnect = StompCommand.CONNECT.equals(headerAccessor.getCommand())__				if (isConnect) {_					this.stats.incrementConnectCount()__				}_				else if (StompCommand.DISCONNECT.equals(headerAccessor.getCommand())) {_					this.stats.incrementDisconnectCount()__				}__				try {_					SimpAttributesContextHolder.setAttributesFromMessage(message)__					boolean sent = outputChannel.send(message)___					if (sent) {_						if (isConnect) {_							if (user != null && user != session.getPrincipal()) {_								this.stompAuthentications.put(session.getId(), user)__							}_						}_						if (this.eventPublisher != null) {_							if (isConnect) {_								publishEvent(this.eventPublisher, new SessionConnectEvent(this, message, user))__							}_							else if (StompCommand.SUBSCRIBE.equals(headerAccessor.getCommand())) {_								publishEvent(this.eventPublisher, new SessionSubscribeEvent(this, message, user))__							}_							else if (StompCommand.UNSUBSCRIBE.equals(headerAccessor.getCommand())) {_								publishEvent(this.eventPublisher, new SessionUnsubscribeEvent(this, message, user))__							}_						}_					}_				}_				finally {_					SimpAttributesContextHolder.resetAttributes()__				}_			}_			catch (Throwable ex) {_				if (logger.isErrorEnabled()) {_					logger.error("Failed to send client message to application via MessageChannel" +_							" in session " + session.getId() + ". Sending STOMP ERROR to client.", ex)__				}_				handleError(session, ex, message)__			}_		}_	};handle,incoming,web,socket,messages,from,clients;public,void,handle,message,from,client,web,socket,session,session,web,socket,message,web,socket,message,message,channel,output,channel,list,message,byte,messages,try,byte,buffer,byte,buffer,if,web,socket,message,instanceof,text,message,byte,buffer,byte,buffer,wrap,text,message,web,socket,message,as,bytes,else,if,web,socket,message,instanceof,binary,message,byte,buffer,binary,message,web,socket,message,get,payload,else,return,buffering,stomp,decoder,decoder,this,decoders,get,session,get,id,if,decoder,null,throw,new,illegal,state,exception,no,decoder,for,session,id,session,get,id,messages,decoder,decode,byte,buffer,if,messages,is,empty,if,logger,is,trace,enabled,logger,trace,incomplete,stomp,frame,content,received,in,session,session,buffer,size,decoder,get,buffer,size,buffer,size,limit,decoder,get,buffer,size,limit,return,catch,throwable,ex,if,logger,is,error,enabled,logger,error,failed,to,parse,web,socket,message,in,session,session,get,id,sending,stomp,error,to,client,ex,handle,error,session,ex,null,return,for,message,byte,message,messages,try,stomp,header,accessor,header,accessor,message,header,accessor,get,accessor,message,stomp,header,accessor,class,assert,state,header,accessor,null,no,stomp,header,accessor,header,accessor,set,session,id,session,get,id,header,accessor,set,session,attributes,session,get,attributes,principal,user,get,user,session,if,user,null,header,accessor,set,user,user,header,accessor,set,header,simp,message,header,accessor,header,accessor,get,heartbeat,if,detect,immutable,message,interceptor,output,channel,header,accessor,set,immutable,if,logger,is,trace,enabled,logger,trace,from,client,header,accessor,get,short,log,message,message,get,payload,boolean,is,connect,stomp,command,connect,equals,header,accessor,get,command,if,is,connect,this,stats,increment,connect,count,else,if,stomp,command,disconnect,equals,header,accessor,get,command,this,stats,increment,disconnect,count,try,simp,attributes,context,holder,set,attributes,from,message,message,boolean,sent,output,channel,send,message,if,sent,if,is,connect,if,user,null,user,session,get,principal,this,stomp,authentications,put,session,get,id,user,if,this,event,publisher,null,if,is,connect,publish,event,this,event,publisher,new,session,connect,event,this,message,user,else,if,stomp,command,subscribe,equals,header,accessor,get,command,publish,event,this,event,publisher,new,session,subscribe,event,this,message,user,else,if,stomp,command,unsubscribe,equals,header,accessor,get,command,publish,event,this,event,publisher,new,session,unsubscribe,event,this,message,user,finally,simp,attributes,context,holder,reset,attributes,catch,throwable,ex,if,logger,is,error,enabled,logger,error,failed,to,send,client,message,to,application,via,message,channel,in,session,session,get,id,sending,stomp,error,to,client,ex,handle,error,session,ex,message
StompSubProtocolHandler -> public void handleMessageFromClient(WebSocketSession session, 			WebSocketMessage<?> webSocketMessage, MessageChannel outputChannel);1500448076;Handle incoming WebSocket messages from clients.;public void handleMessageFromClient(WebSocketSession session,_			WebSocketMessage<?> webSocketMessage, MessageChannel outputChannel) {__		List<Message<byte[]>> messages__		try {_			ByteBuffer byteBuffer__			if (webSocketMessage instanceof TextMessage) {_				byteBuffer = ByteBuffer.wrap(((TextMessage) webSocketMessage).asBytes())__			}_			else if (webSocketMessage instanceof BinaryMessage) {_				byteBuffer = ((BinaryMessage) webSocketMessage).getPayload()__			}_			else {_				return__			}__			BufferingStompDecoder decoder = this.decoders.get(session.getId())__			if (decoder == null) {_				throw new IllegalStateException("No decoder for session id '" + session.getId() + "'")__			}__			messages = decoder.decode(byteBuffer)__			if (messages.isEmpty()) {_				if (logger.isTraceEnabled()) {_					logger.trace("Incomplete STOMP frame content received in session " +_							session + ", bufferSize=" + decoder.getBufferSize() +_							", bufferSizeLimit=" + decoder.getBufferSizeLimit() + ".")__				}_				return__			}_		}_		catch (Throwable ex) {_			if (logger.isErrorEnabled()) {_				logger.error("Failed to parse " + webSocketMessage +_						" in session " + session.getId() + ". Sending STOMP ERROR to client.", ex)__			}_			handleError(session, ex, null)__			return__		}__		for (Message<byte[]> message : messages) {_			try {_				StompHeaderAccessor headerAccessor =_						MessageHeaderAccessor.getAccessor(message, StompHeaderAccessor.class)__				Assert.state(headerAccessor != null, "No StompHeaderAccessor")___				headerAccessor.setSessionId(session.getId())__				headerAccessor.setSessionAttributes(session.getAttributes())___				Principal user = getUser(session)__				if (user != null) {_					headerAccessor.setUser(user)__				}__				headerAccessor.setHeader(SimpMessageHeaderAccessor.HEART_BEAT_HEADER, headerAccessor.getHeartbeat())__				if (!detectImmutableMessageInterceptor(outputChannel)) {_					headerAccessor.setImmutable()__				}__				if (logger.isTraceEnabled()) {_					logger.trace("From client: " + headerAccessor.getShortLogMessage(message.getPayload()))__				}__				boolean isConnect = StompCommand.CONNECT.equals(headerAccessor.getCommand())__				if (isConnect) {_					this.stats.incrementConnectCount()__				}_				else if (StompCommand.DISCONNECT.equals(headerAccessor.getCommand())) {_					this.stats.incrementDisconnectCount()__				}__				try {_					SimpAttributesContextHolder.setAttributesFromMessage(message)__					boolean sent = outputChannel.send(message)___					if (sent) {_						if (isConnect) {_							if (user != null && user != session.getPrincipal()) {_								this.stompAuthentications.put(session.getId(), user)__							}_						}_						if (this.eventPublisher != null) {_							if (isConnect) {_								publishEvent(this.eventPublisher, new SessionConnectEvent(this, message, user))__							}_							else if (StompCommand.SUBSCRIBE.equals(headerAccessor.getCommand())) {_								publishEvent(this.eventPublisher, new SessionSubscribeEvent(this, message, user))__							}_							else if (StompCommand.UNSUBSCRIBE.equals(headerAccessor.getCommand())) {_								publishEvent(this.eventPublisher, new SessionUnsubscribeEvent(this, message, user))__							}_						}_					}_				}_				finally {_					SimpAttributesContextHolder.resetAttributes()__				}_			}_			catch (Throwable ex) {_				if (logger.isErrorEnabled()) {_					logger.error("Failed to send client message to application via MessageChannel" +_							" in session " + session.getId() + ". Sending STOMP ERROR to client.", ex)__				}_				handleError(session, ex, message)__			}_		}_	};handle,incoming,web,socket,messages,from,clients;public,void,handle,message,from,client,web,socket,session,session,web,socket,message,web,socket,message,message,channel,output,channel,list,message,byte,messages,try,byte,buffer,byte,buffer,if,web,socket,message,instanceof,text,message,byte,buffer,byte,buffer,wrap,text,message,web,socket,message,as,bytes,else,if,web,socket,message,instanceof,binary,message,byte,buffer,binary,message,web,socket,message,get,payload,else,return,buffering,stomp,decoder,decoder,this,decoders,get,session,get,id,if,decoder,null,throw,new,illegal,state,exception,no,decoder,for,session,id,session,get,id,messages,decoder,decode,byte,buffer,if,messages,is,empty,if,logger,is,trace,enabled,logger,trace,incomplete,stomp,frame,content,received,in,session,session,buffer,size,decoder,get,buffer,size,buffer,size,limit,decoder,get,buffer,size,limit,return,catch,throwable,ex,if,logger,is,error,enabled,logger,error,failed,to,parse,web,socket,message,in,session,session,get,id,sending,stomp,error,to,client,ex,handle,error,session,ex,null,return,for,message,byte,message,messages,try,stomp,header,accessor,header,accessor,message,header,accessor,get,accessor,message,stomp,header,accessor,class,assert,state,header,accessor,null,no,stomp,header,accessor,header,accessor,set,session,id,session,get,id,header,accessor,set,session,attributes,session,get,attributes,principal,user,get,user,session,if,user,null,header,accessor,set,user,user,header,accessor,set,header,simp,message,header,accessor,header,accessor,get,heartbeat,if,detect,immutable,message,interceptor,output,channel,header,accessor,set,immutable,if,logger,is,trace,enabled,logger,trace,from,client,header,accessor,get,short,log,message,message,get,payload,boolean,is,connect,stomp,command,connect,equals,header,accessor,get,command,if,is,connect,this,stats,increment,connect,count,else,if,stomp,command,disconnect,equals,header,accessor,get,command,this,stats,increment,disconnect,count,try,simp,attributes,context,holder,set,attributes,from,message,message,boolean,sent,output,channel,send,message,if,sent,if,is,connect,if,user,null,user,session,get,principal,this,stomp,authentications,put,session,get,id,user,if,this,event,publisher,null,if,is,connect,publish,event,this,event,publisher,new,session,connect,event,this,message,user,else,if,stomp,command,subscribe,equals,header,accessor,get,command,publish,event,this,event,publisher,new,session,subscribe,event,this,message,user,else,if,stomp,command,unsubscribe,equals,header,accessor,get,command,publish,event,this,event,publisher,new,session,unsubscribe,event,this,message,user,finally,simp,attributes,context,holder,reset,attributes,catch,throwable,ex,if,logger,is,error,enabled,logger,error,failed,to,send,client,message,to,application,via,message,channel,in,session,session,get,id,sending,stomp,error,to,client,ex,handle,error,session,ex,message
StompSubProtocolHandler -> public void handleMessageFromClient(WebSocketSession session, 			WebSocketMessage<?> webSocketMessage, MessageChannel outputChannel);1501147952;Handle incoming WebSocket messages from clients.;public void handleMessageFromClient(WebSocketSession session,_			WebSocketMessage<?> webSocketMessage, MessageChannel outputChannel) {__		List<Message<byte[]>> messages__		try {_			ByteBuffer byteBuffer__			if (webSocketMessage instanceof TextMessage) {_				byteBuffer = ByteBuffer.wrap(((TextMessage) webSocketMessage).asBytes())__			}_			else if (webSocketMessage instanceof BinaryMessage) {_				byteBuffer = ((BinaryMessage) webSocketMessage).getPayload()__			}_			else {_				return__			}__			BufferingStompDecoder decoder = this.decoders.get(session.getId())__			if (decoder == null) {_				throw new IllegalStateException("No decoder for session id '" + session.getId() + "'")__			}__			messages = decoder.decode(byteBuffer)__			if (messages.isEmpty()) {_				if (logger.isTraceEnabled()) {_					logger.trace("Incomplete STOMP frame content received in session " +_							session + ", bufferSize=" + decoder.getBufferSize() +_							", bufferSizeLimit=" + decoder.getBufferSizeLimit() + ".")__				}_				return__			}_		}_		catch (Throwable ex) {_			if (logger.isErrorEnabled()) {_				logger.error("Failed to parse " + webSocketMessage +_						" in session " + session.getId() + ". Sending STOMP ERROR to client.", ex)__			}_			handleError(session, ex, null)__			return__		}__		for (Message<byte[]> message : messages) {_			try {_				StompHeaderAccessor headerAccessor =_						MessageHeaderAccessor.getAccessor(message, StompHeaderAccessor.class)__				Assert.state(headerAccessor != null, "No StompHeaderAccessor")___				headerAccessor.setSessionId(session.getId())__				headerAccessor.setSessionAttributes(session.getAttributes())__				headerAccessor.setUser(getUser(session))__				headerAccessor.setHeader(SimpMessageHeaderAccessor.HEART_BEAT_HEADER, headerAccessor.getHeartbeat())__				if (!detectImmutableMessageInterceptor(outputChannel)) {_					headerAccessor.setImmutable()__				}__				if (logger.isTraceEnabled()) {_					logger.trace("From client: " + headerAccessor.getShortLogMessage(message.getPayload()))__				}__				boolean isConnect = StompCommand.CONNECT.equals(headerAccessor.getCommand())__				if (isConnect) {_					this.stats.incrementConnectCount()__				}_				else if (StompCommand.DISCONNECT.equals(headerAccessor.getCommand())) {_					this.stats.incrementDisconnectCount()__				}__				try {_					SimpAttributesContextHolder.setAttributesFromMessage(message)__					boolean sent = outputChannel.send(message)___					if (sent) {_						if (isConnect) {_							Principal user = headerAccessor.getUser()__							if (user != null && user != session.getPrincipal()) {_								this.stompAuthentications.put(session.getId(), user)__							}_						}_						if (this.eventPublisher != null) {_							Principal user = getUser(session)__							if (isConnect) {_								publishEvent(this.eventPublisher, new SessionConnectEvent(this, message, user))__							}_							else if (StompCommand.SUBSCRIBE.equals(headerAccessor.getCommand())) {_								publishEvent(this.eventPublisher, new SessionSubscribeEvent(this, message, user))__							}_							else if (StompCommand.UNSUBSCRIBE.equals(headerAccessor.getCommand())) {_								publishEvent(this.eventPublisher, new SessionUnsubscribeEvent(this, message, user))__							}_						}_					}_				}_				finally {_					SimpAttributesContextHolder.resetAttributes()__				}_			}_			catch (Throwable ex) {_				if (logger.isErrorEnabled()) {_					logger.error("Failed to send client message to application via MessageChannel" +_							" in session " + session.getId() + ". Sending STOMP ERROR to client.", ex)__				}_				handleError(session, ex, message)__			}_		}_	};handle,incoming,web,socket,messages,from,clients;public,void,handle,message,from,client,web,socket,session,session,web,socket,message,web,socket,message,message,channel,output,channel,list,message,byte,messages,try,byte,buffer,byte,buffer,if,web,socket,message,instanceof,text,message,byte,buffer,byte,buffer,wrap,text,message,web,socket,message,as,bytes,else,if,web,socket,message,instanceof,binary,message,byte,buffer,binary,message,web,socket,message,get,payload,else,return,buffering,stomp,decoder,decoder,this,decoders,get,session,get,id,if,decoder,null,throw,new,illegal,state,exception,no,decoder,for,session,id,session,get,id,messages,decoder,decode,byte,buffer,if,messages,is,empty,if,logger,is,trace,enabled,logger,trace,incomplete,stomp,frame,content,received,in,session,session,buffer,size,decoder,get,buffer,size,buffer,size,limit,decoder,get,buffer,size,limit,return,catch,throwable,ex,if,logger,is,error,enabled,logger,error,failed,to,parse,web,socket,message,in,session,session,get,id,sending,stomp,error,to,client,ex,handle,error,session,ex,null,return,for,message,byte,message,messages,try,stomp,header,accessor,header,accessor,message,header,accessor,get,accessor,message,stomp,header,accessor,class,assert,state,header,accessor,null,no,stomp,header,accessor,header,accessor,set,session,id,session,get,id,header,accessor,set,session,attributes,session,get,attributes,header,accessor,set,user,get,user,session,header,accessor,set,header,simp,message,header,accessor,header,accessor,get,heartbeat,if,detect,immutable,message,interceptor,output,channel,header,accessor,set,immutable,if,logger,is,trace,enabled,logger,trace,from,client,header,accessor,get,short,log,message,message,get,payload,boolean,is,connect,stomp,command,connect,equals,header,accessor,get,command,if,is,connect,this,stats,increment,connect,count,else,if,stomp,command,disconnect,equals,header,accessor,get,command,this,stats,increment,disconnect,count,try,simp,attributes,context,holder,set,attributes,from,message,message,boolean,sent,output,channel,send,message,if,sent,if,is,connect,principal,user,header,accessor,get,user,if,user,null,user,session,get,principal,this,stomp,authentications,put,session,get,id,user,if,this,event,publisher,null,principal,user,get,user,session,if,is,connect,publish,event,this,event,publisher,new,session,connect,event,this,message,user,else,if,stomp,command,subscribe,equals,header,accessor,get,command,publish,event,this,event,publisher,new,session,subscribe,event,this,message,user,else,if,stomp,command,unsubscribe,equals,header,accessor,get,command,publish,event,this,event,publisher,new,session,unsubscribe,event,this,message,user,finally,simp,attributes,context,holder,reset,attributes,catch,throwable,ex,if,logger,is,error,enabled,logger,error,failed,to,send,client,message,to,application,via,message,channel,in,session,session,get,id,sending,stomp,error,to,client,ex,handle,error,session,ex,message
StompSubProtocolHandler -> public void handleMessageFromClient(WebSocketSession session, 			WebSocketMessage<?> webSocketMessage, MessageChannel outputChannel);1502974979;Handle incoming WebSocket messages from clients.;public void handleMessageFromClient(WebSocketSession session,_			WebSocketMessage<?> webSocketMessage, MessageChannel outputChannel) {__		List<Message<byte[]>> messages__		try {_			ByteBuffer byteBuffer__			if (webSocketMessage instanceof TextMessage) {_				byteBuffer = ByteBuffer.wrap(((TextMessage) webSocketMessage).asBytes())__			}_			else if (webSocketMessage instanceof BinaryMessage) {_				byteBuffer = ((BinaryMessage) webSocketMessage).getPayload()__			}_			else {_				return__			}__			BufferingStompDecoder decoder = this.decoders.get(session.getId())__			if (decoder == null) {_				throw new IllegalStateException("No decoder for session id '" + session.getId() + "'")__			}__			messages = decoder.decode(byteBuffer)__			if (messages.isEmpty()) {_				if (logger.isTraceEnabled()) {_					logger.trace("Incomplete STOMP frame content received in session " +_							session + ", bufferSize=" + decoder.getBufferSize() +_							", bufferSizeLimit=" + decoder.getBufferSizeLimit() + ".")__				}_				return__			}_		}_		catch (Throwable ex) {_			if (logger.isErrorEnabled()) {_				logger.error("Failed to parse " + webSocketMessage +_						" in session " + session.getId() + ". Sending STOMP ERROR to client.", ex)__			}_			handleError(session, ex, null)__			return__		}__		for (Message<byte[]> message : messages) {_			try {_				StompHeaderAccessor headerAccessor =_						MessageHeaderAccessor.getAccessor(message, StompHeaderAccessor.class)__				Assert.state(headerAccessor != null, "No StompHeaderAccessor")___				headerAccessor.setSessionId(session.getId())__				headerAccessor.setSessionAttributes(session.getAttributes())__				headerAccessor.setUser(getUser(session))__				headerAccessor.setHeader(SimpMessageHeaderAccessor.HEART_BEAT_HEADER, headerAccessor.getHeartbeat())__				if (!detectImmutableMessageInterceptor(outputChannel)) {_					headerAccessor.setImmutable()__				}__				if (logger.isTraceEnabled()) {_					logger.trace("From client: " + headerAccessor.getShortLogMessage(message.getPayload()))__				}__				boolean isConnect = StompCommand.CONNECT.equals(headerAccessor.getCommand())__				if (isConnect) {_					this.stats.incrementConnectCount()__				}_				else if (StompCommand.DISCONNECT.equals(headerAccessor.getCommand())) {_					this.stats.incrementDisconnectCount()__				}__				try {_					SimpAttributesContextHolder.setAttributesFromMessage(message)__					boolean sent = outputChannel.send(message)___					if (sent) {_						if (isConnect) {_							Principal user = headerAccessor.getUser()__							if (user != null && user != session.getPrincipal()) {_								this.stompAuthentications.put(session.getId(), user)__							}_						}_						if (this.eventPublisher != null) {_							Principal user = getUser(session)__							if (isConnect) {_								publishEvent(this.eventPublisher, new SessionConnectEvent(this, message, user))__							}_							else if (StompCommand.SUBSCRIBE.equals(headerAccessor.getCommand())) {_								publishEvent(this.eventPublisher, new SessionSubscribeEvent(this, message, user))__							}_							else if (StompCommand.UNSUBSCRIBE.equals(headerAccessor.getCommand())) {_								publishEvent(this.eventPublisher, new SessionUnsubscribeEvent(this, message, user))__							}_						}_					}_				}_				finally {_					SimpAttributesContextHolder.resetAttributes()__				}_			}_			catch (Throwable ex) {_				if (logger.isErrorEnabled()) {_					logger.error("Failed to send client message to application via MessageChannel" +_							" in session " + session.getId() + ". Sending STOMP ERROR to client.", ex)__				}_				handleError(session, ex, message)__			}_		}_	};handle,incoming,web,socket,messages,from,clients;public,void,handle,message,from,client,web,socket,session,session,web,socket,message,web,socket,message,message,channel,output,channel,list,message,byte,messages,try,byte,buffer,byte,buffer,if,web,socket,message,instanceof,text,message,byte,buffer,byte,buffer,wrap,text,message,web,socket,message,as,bytes,else,if,web,socket,message,instanceof,binary,message,byte,buffer,binary,message,web,socket,message,get,payload,else,return,buffering,stomp,decoder,decoder,this,decoders,get,session,get,id,if,decoder,null,throw,new,illegal,state,exception,no,decoder,for,session,id,session,get,id,messages,decoder,decode,byte,buffer,if,messages,is,empty,if,logger,is,trace,enabled,logger,trace,incomplete,stomp,frame,content,received,in,session,session,buffer,size,decoder,get,buffer,size,buffer,size,limit,decoder,get,buffer,size,limit,return,catch,throwable,ex,if,logger,is,error,enabled,logger,error,failed,to,parse,web,socket,message,in,session,session,get,id,sending,stomp,error,to,client,ex,handle,error,session,ex,null,return,for,message,byte,message,messages,try,stomp,header,accessor,header,accessor,message,header,accessor,get,accessor,message,stomp,header,accessor,class,assert,state,header,accessor,null,no,stomp,header,accessor,header,accessor,set,session,id,session,get,id,header,accessor,set,session,attributes,session,get,attributes,header,accessor,set,user,get,user,session,header,accessor,set,header,simp,message,header,accessor,header,accessor,get,heartbeat,if,detect,immutable,message,interceptor,output,channel,header,accessor,set,immutable,if,logger,is,trace,enabled,logger,trace,from,client,header,accessor,get,short,log,message,message,get,payload,boolean,is,connect,stomp,command,connect,equals,header,accessor,get,command,if,is,connect,this,stats,increment,connect,count,else,if,stomp,command,disconnect,equals,header,accessor,get,command,this,stats,increment,disconnect,count,try,simp,attributes,context,holder,set,attributes,from,message,message,boolean,sent,output,channel,send,message,if,sent,if,is,connect,principal,user,header,accessor,get,user,if,user,null,user,session,get,principal,this,stomp,authentications,put,session,get,id,user,if,this,event,publisher,null,principal,user,get,user,session,if,is,connect,publish,event,this,event,publisher,new,session,connect,event,this,message,user,else,if,stomp,command,subscribe,equals,header,accessor,get,command,publish,event,this,event,publisher,new,session,subscribe,event,this,message,user,else,if,stomp,command,unsubscribe,equals,header,accessor,get,command,publish,event,this,event,publisher,new,session,unsubscribe,event,this,message,user,finally,simp,attributes,context,holder,reset,attributes,catch,throwable,ex,if,logger,is,error,enabled,logger,error,failed,to,send,client,message,to,application,via,message,channel,in,session,session,get,id,sending,stomp,error,to,client,ex,handle,error,session,ex,message
StompSubProtocolHandler -> public void handleMessageFromClient(WebSocketSession session, 			WebSocketMessage<?> webSocketMessage, MessageChannel outputChannel);1509997270;Handle incoming WebSocket messages from clients.;public void handleMessageFromClient(WebSocketSession session,_			WebSocketMessage<?> webSocketMessage, MessageChannel outputChannel) {__		List<Message<byte[]>> messages__		try {_			ByteBuffer byteBuffer__			if (webSocketMessage instanceof TextMessage) {_				byteBuffer = ByteBuffer.wrap(((TextMessage) webSocketMessage).asBytes())__			}_			else if (webSocketMessage instanceof BinaryMessage) {_				byteBuffer = ((BinaryMessage) webSocketMessage).getPayload()__			}_			else {_				return__			}__			BufferingStompDecoder decoder = this.decoders.get(session.getId())__			if (decoder == null) {_				throw new IllegalStateException("No decoder for session id '" + session.getId() + "'")__			}__			messages = decoder.decode(byteBuffer)__			if (messages.isEmpty()) {_				if (logger.isTraceEnabled()) {_					logger.trace("Incomplete STOMP frame content received in session " +_							session + ", bufferSize=" + decoder.getBufferSize() +_							", bufferSizeLimit=" + decoder.getBufferSizeLimit() + ".")__				}_				return__			}_		}_		catch (Throwable ex) {_			if (logger.isErrorEnabled()) {_				logger.error("Failed to parse " + webSocketMessage +_						" in session " + session.getId() + ". Sending STOMP ERROR to client.", ex)__			}_			handleError(session, ex, null)__			return__		}__		for (Message<byte[]> message : messages) {_			try {_				StompHeaderAccessor headerAccessor =_						MessageHeaderAccessor.getAccessor(message, StompHeaderAccessor.class)__				Assert.state(headerAccessor != null, "No StompHeaderAccessor")___				headerAccessor.setSessionId(session.getId())__				headerAccessor.setSessionAttributes(session.getAttributes())__				headerAccessor.setUser(getUser(session))__				headerAccessor.setHeader(SimpMessageHeaderAccessor.HEART_BEAT_HEADER, headerAccessor.getHeartbeat())__				if (!detectImmutableMessageInterceptor(outputChannel)) {_					headerAccessor.setImmutable()__				}__				if (logger.isTraceEnabled()) {_					logger.trace("From client: " + headerAccessor.getShortLogMessage(message.getPayload()))__				}__				StompCommand command = headerAccessor.getCommand()__				boolean isConnect = StompCommand.CONNECT.equals(command)__				if (isConnect) {_					this.stats.incrementConnectCount()__				}_				else if (StompCommand.DISCONNECT.equals(command)) {_					this.stats.incrementDisconnectCount()__				}__				try {_					SimpAttributesContextHolder.setAttributesFromMessage(message)__					boolean sent = outputChannel.send(message)___					if (sent) {_						if (isConnect) {_							Principal user = headerAccessor.getUser()__							if (user != null && user != session.getPrincipal()) {_								this.stompAuthentications.put(session.getId(), user)__							}_						}_						if (this.eventPublisher != null) {_							Principal user = getUser(session)__							if (isConnect) {_								publishEvent(this.eventPublisher, new SessionConnectEvent(this, message, user))__							}_							else if (StompCommand.SUBSCRIBE.equals(command)) {_								publishEvent(this.eventPublisher, new SessionSubscribeEvent(this, message, user))__							}_							else if (StompCommand.UNSUBSCRIBE.equals(command)) {_								publishEvent(this.eventPublisher, new SessionUnsubscribeEvent(this, message, user))__							}_						}_					}_				}_				finally {_					SimpAttributesContextHolder.resetAttributes()__				}_			}_			catch (Throwable ex) {_				if (logger.isErrorEnabled()) {_					logger.error("Failed to send client message to application via MessageChannel" +_							" in session " + session.getId() + ". Sending STOMP ERROR to client.", ex)__				}_				handleError(session, ex, message)__			}_		}_	};handle,incoming,web,socket,messages,from,clients;public,void,handle,message,from,client,web,socket,session,session,web,socket,message,web,socket,message,message,channel,output,channel,list,message,byte,messages,try,byte,buffer,byte,buffer,if,web,socket,message,instanceof,text,message,byte,buffer,byte,buffer,wrap,text,message,web,socket,message,as,bytes,else,if,web,socket,message,instanceof,binary,message,byte,buffer,binary,message,web,socket,message,get,payload,else,return,buffering,stomp,decoder,decoder,this,decoders,get,session,get,id,if,decoder,null,throw,new,illegal,state,exception,no,decoder,for,session,id,session,get,id,messages,decoder,decode,byte,buffer,if,messages,is,empty,if,logger,is,trace,enabled,logger,trace,incomplete,stomp,frame,content,received,in,session,session,buffer,size,decoder,get,buffer,size,buffer,size,limit,decoder,get,buffer,size,limit,return,catch,throwable,ex,if,logger,is,error,enabled,logger,error,failed,to,parse,web,socket,message,in,session,session,get,id,sending,stomp,error,to,client,ex,handle,error,session,ex,null,return,for,message,byte,message,messages,try,stomp,header,accessor,header,accessor,message,header,accessor,get,accessor,message,stomp,header,accessor,class,assert,state,header,accessor,null,no,stomp,header,accessor,header,accessor,set,session,id,session,get,id,header,accessor,set,session,attributes,session,get,attributes,header,accessor,set,user,get,user,session,header,accessor,set,header,simp,message,header,accessor,header,accessor,get,heartbeat,if,detect,immutable,message,interceptor,output,channel,header,accessor,set,immutable,if,logger,is,trace,enabled,logger,trace,from,client,header,accessor,get,short,log,message,message,get,payload,stomp,command,command,header,accessor,get,command,boolean,is,connect,stomp,command,connect,equals,command,if,is,connect,this,stats,increment,connect,count,else,if,stomp,command,disconnect,equals,command,this,stats,increment,disconnect,count,try,simp,attributes,context,holder,set,attributes,from,message,message,boolean,sent,output,channel,send,message,if,sent,if,is,connect,principal,user,header,accessor,get,user,if,user,null,user,session,get,principal,this,stomp,authentications,put,session,get,id,user,if,this,event,publisher,null,principal,user,get,user,session,if,is,connect,publish,event,this,event,publisher,new,session,connect,event,this,message,user,else,if,stomp,command,subscribe,equals,command,publish,event,this,event,publisher,new,session,subscribe,event,this,message,user,else,if,stomp,command,unsubscribe,equals,command,publish,event,this,event,publisher,new,session,unsubscribe,event,this,message,user,finally,simp,attributes,context,holder,reset,attributes,catch,throwable,ex,if,logger,is,error,enabled,logger,error,failed,to,send,client,message,to,application,via,message,channel,in,session,session,get,id,sending,stomp,error,to,client,ex,handle,error,session,ex,message
StompSubProtocolHandler -> public void handleMessageFromClient(WebSocketSession session, 			WebSocketMessage<?> webSocketMessage, MessageChannel outputChannel);1530174524;Handle incoming WebSocket messages from clients.;public void handleMessageFromClient(WebSocketSession session,_			WebSocketMessage<?> webSocketMessage, MessageChannel outputChannel) {__		List<Message<byte[]>> messages__		try {_			ByteBuffer byteBuffer__			if (webSocketMessage instanceof TextMessage) {_				byteBuffer = ByteBuffer.wrap(((TextMessage) webSocketMessage).asBytes())__			}_			else if (webSocketMessage instanceof BinaryMessage) {_				byteBuffer = ((BinaryMessage) webSocketMessage).getPayload()__			}_			else {_				return__			}__			BufferingStompDecoder decoder = this.decoders.get(session.getId())__			if (decoder == null) {_				throw new IllegalStateException("No decoder for session id '" + session.getId() + "'")__			}__			messages = decoder.decode(byteBuffer)__			if (messages.isEmpty()) {_				if (logger.isTraceEnabled()) {_					logger.trace("Incomplete STOMP frame content received in session " +_							session + ", bufferSize=" + decoder.getBufferSize() +_							", bufferSizeLimit=" + decoder.getBufferSizeLimit() + ".")__				}_				return__			}_		}_		catch (Throwable ex) {_			if (logger.isErrorEnabled()) {_				logger.error("Failed to parse " + webSocketMessage +_						" in session " + session.getId() + ". Sending STOMP ERROR to client.", ex)__			}_			handleError(session, ex, null)__			return__		}__		for (Message<byte[]> message : messages) {_			try {_				StompHeaderAccessor headerAccessor =_						MessageHeaderAccessor.getAccessor(message, StompHeaderAccessor.class)__				Assert.state(headerAccessor != null, "No StompHeaderAccessor")___				headerAccessor.setSessionId(session.getId())__				headerAccessor.setSessionAttributes(session.getAttributes())__				headerAccessor.setUser(getUser(session))__				headerAccessor.setHeader(SimpMessageHeaderAccessor.HEART_BEAT_HEADER, headerAccessor.getHeartbeat())__				if (!detectImmutableMessageInterceptor(outputChannel)) {_					headerAccessor.setImmutable()__				}__				if (logger.isTraceEnabled()) {_					logger.trace("From client: " + headerAccessor.getShortLogMessage(message.getPayload()))__				}__				StompCommand command = headerAccessor.getCommand()__				boolean isConnect = StompCommand.CONNECT.equals(command)__				if (isConnect) {_					this.stats.incrementConnectCount()__				}_				else if (StompCommand.DISCONNECT.equals(command)) {_					this.stats.incrementDisconnectCount()__				}__				try {_					SimpAttributesContextHolder.setAttributesFromMessage(message)__					boolean sent = outputChannel.send(message)___					if (sent) {_						if (isConnect) {_							Principal user = headerAccessor.getUser()__							if (user != null && user != session.getPrincipal()) {_								this.stompAuthentications.put(session.getId(), user)__							}_						}_						if (this.eventPublisher != null) {_							Principal user = getUser(session)__							if (isConnect) {_								publishEvent(this.eventPublisher, new SessionConnectEvent(this, message, user))__							}_							else if (StompCommand.SUBSCRIBE.equals(command)) {_								publishEvent(this.eventPublisher, new SessionSubscribeEvent(this, message, user))__							}_							else if (StompCommand.UNSUBSCRIBE.equals(command)) {_								publishEvent(this.eventPublisher, new SessionUnsubscribeEvent(this, message, user))__							}_						}_					}_				}_				finally {_					SimpAttributesContextHolder.resetAttributes()__				}_			}_			catch (Throwable ex) {_				if (logger.isErrorEnabled()) {_					logger.error("Failed to send client message to application via MessageChannel" +_							" in session " + session.getId() + ". Sending STOMP ERROR to client.", ex)__				}_				handleError(session, ex, message)__			}_		}_	};handle,incoming,web,socket,messages,from,clients;public,void,handle,message,from,client,web,socket,session,session,web,socket,message,web,socket,message,message,channel,output,channel,list,message,byte,messages,try,byte,buffer,byte,buffer,if,web,socket,message,instanceof,text,message,byte,buffer,byte,buffer,wrap,text,message,web,socket,message,as,bytes,else,if,web,socket,message,instanceof,binary,message,byte,buffer,binary,message,web,socket,message,get,payload,else,return,buffering,stomp,decoder,decoder,this,decoders,get,session,get,id,if,decoder,null,throw,new,illegal,state,exception,no,decoder,for,session,id,session,get,id,messages,decoder,decode,byte,buffer,if,messages,is,empty,if,logger,is,trace,enabled,logger,trace,incomplete,stomp,frame,content,received,in,session,session,buffer,size,decoder,get,buffer,size,buffer,size,limit,decoder,get,buffer,size,limit,return,catch,throwable,ex,if,logger,is,error,enabled,logger,error,failed,to,parse,web,socket,message,in,session,session,get,id,sending,stomp,error,to,client,ex,handle,error,session,ex,null,return,for,message,byte,message,messages,try,stomp,header,accessor,header,accessor,message,header,accessor,get,accessor,message,stomp,header,accessor,class,assert,state,header,accessor,null,no,stomp,header,accessor,header,accessor,set,session,id,session,get,id,header,accessor,set,session,attributes,session,get,attributes,header,accessor,set,user,get,user,session,header,accessor,set,header,simp,message,header,accessor,header,accessor,get,heartbeat,if,detect,immutable,message,interceptor,output,channel,header,accessor,set,immutable,if,logger,is,trace,enabled,logger,trace,from,client,header,accessor,get,short,log,message,message,get,payload,stomp,command,command,header,accessor,get,command,boolean,is,connect,stomp,command,connect,equals,command,if,is,connect,this,stats,increment,connect,count,else,if,stomp,command,disconnect,equals,command,this,stats,increment,disconnect,count,try,simp,attributes,context,holder,set,attributes,from,message,message,boolean,sent,output,channel,send,message,if,sent,if,is,connect,principal,user,header,accessor,get,user,if,user,null,user,session,get,principal,this,stomp,authentications,put,session,get,id,user,if,this,event,publisher,null,principal,user,get,user,session,if,is,connect,publish,event,this,event,publisher,new,session,connect,event,this,message,user,else,if,stomp,command,subscribe,equals,command,publish,event,this,event,publisher,new,session,subscribe,event,this,message,user,else,if,stomp,command,unsubscribe,equals,command,publish,event,this,event,publisher,new,session,unsubscribe,event,this,message,user,finally,simp,attributes,context,holder,reset,attributes,catch,throwable,ex,if,logger,is,error,enabled,logger,error,failed,to,send,client,message,to,application,via,message,channel,in,session,session,get,id,sending,stomp,error,to,client,ex,handle,error,session,ex,message
StompSubProtocolHandler -> public void handleMessageFromClient(WebSocketSession session, 			WebSocketMessage<?> webSocketMessage, MessageChannel outputChannel);1536886762;Handle incoming WebSocket messages from clients.;public void handleMessageFromClient(WebSocketSession session,_			WebSocketMessage<?> webSocketMessage, MessageChannel outputChannel) {__		List<Message<byte[]>> messages__		try {_			ByteBuffer byteBuffer__			if (webSocketMessage instanceof TextMessage) {_				byteBuffer = ByteBuffer.wrap(((TextMessage) webSocketMessage).asBytes())__			}_			else if (webSocketMessage instanceof BinaryMessage) {_				byteBuffer = ((BinaryMessage) webSocketMessage).getPayload()__			}_			else {_				return__			}__			BufferingStompDecoder decoder = this.decoders.get(session.getId())__			if (decoder == null) {_				throw new IllegalStateException("No decoder for session id '" + session.getId() + "'")__			}__			messages = decoder.decode(byteBuffer)__			if (messages.isEmpty()) {_				if (logger.isTraceEnabled()) {_					logger.trace("Incomplete STOMP frame content received in session " +_							session + ", bufferSize=" + decoder.getBufferSize() +_							", bufferSizeLimit=" + decoder.getBufferSizeLimit() + ".")__				}_				return__			}_		}_		catch (Throwable ex) {_			if (logger.isErrorEnabled()) {_				logger.error("Failed to parse " + webSocketMessage +_						" in session " + session.getId() + ". Sending STOMP ERROR to client.", ex)__			}_			handleError(session, ex, null)__			return__		}__		for (Message<byte[]> message : messages) {_			try {_				StompHeaderAccessor headerAccessor =_						MessageHeaderAccessor.getAccessor(message, StompHeaderAccessor.class)__				Assert.state(headerAccessor != null, "No StompHeaderAccessor")___				headerAccessor.setSessionId(session.getId())__				headerAccessor.setSessionAttributes(session.getAttributes())__				headerAccessor.setUser(getUser(session))__				headerAccessor.setHeader(SimpMessageHeaderAccessor.HEART_BEAT_HEADER, headerAccessor.getHeartbeat())__				if (!detectImmutableMessageInterceptor(outputChannel)) {_					headerAccessor.setImmutable()__				}__				if (logger.isTraceEnabled()) {_					logger.trace("From client: " + headerAccessor.getShortLogMessage(message.getPayload()))__				}__				StompCommand command = headerAccessor.getCommand()__				boolean isConnect = StompCommand.CONNECT.equals(command)__				if (isConnect) {_					this.stats.incrementConnectCount()__				}_				else if (StompCommand.DISCONNECT.equals(command)) {_					this.stats.incrementDisconnectCount()__				}__				try {_					SimpAttributesContextHolder.setAttributesFromMessage(message)__					boolean sent = outputChannel.send(message)___					if (sent) {_						if (isConnect) {_							Principal user = headerAccessor.getUser()__							if (user != null && user != session.getPrincipal()) {_								this.stompAuthentications.put(session.getId(), user)__							}_						}_						if (this.eventPublisher != null) {_							Principal user = getUser(session)__							if (isConnect) {_								publishEvent(this.eventPublisher, new SessionConnectEvent(this, message, user))__							}_							else if (StompCommand.SUBSCRIBE.equals(command)) {_								publishEvent(this.eventPublisher, new SessionSubscribeEvent(this, message, user))__							}_							else if (StompCommand.UNSUBSCRIBE.equals(command)) {_								publishEvent(this.eventPublisher, new SessionUnsubscribeEvent(this, message, user))__							}_						}_					}_				}_				finally {_					SimpAttributesContextHolder.resetAttributes()__				}_			}_			catch (Throwable ex) {_				if (logger.isErrorEnabled()) {_					logger.error("Failed to send client message to application via MessageChannel" +_							" in session " + session.getId() + ". Sending STOMP ERROR to client.", ex)__				}_				handleError(session, ex, message)__			}_		}_	};handle,incoming,web,socket,messages,from,clients;public,void,handle,message,from,client,web,socket,session,session,web,socket,message,web,socket,message,message,channel,output,channel,list,message,byte,messages,try,byte,buffer,byte,buffer,if,web,socket,message,instanceof,text,message,byte,buffer,byte,buffer,wrap,text,message,web,socket,message,as,bytes,else,if,web,socket,message,instanceof,binary,message,byte,buffer,binary,message,web,socket,message,get,payload,else,return,buffering,stomp,decoder,decoder,this,decoders,get,session,get,id,if,decoder,null,throw,new,illegal,state,exception,no,decoder,for,session,id,session,get,id,messages,decoder,decode,byte,buffer,if,messages,is,empty,if,logger,is,trace,enabled,logger,trace,incomplete,stomp,frame,content,received,in,session,session,buffer,size,decoder,get,buffer,size,buffer,size,limit,decoder,get,buffer,size,limit,return,catch,throwable,ex,if,logger,is,error,enabled,logger,error,failed,to,parse,web,socket,message,in,session,session,get,id,sending,stomp,error,to,client,ex,handle,error,session,ex,null,return,for,message,byte,message,messages,try,stomp,header,accessor,header,accessor,message,header,accessor,get,accessor,message,stomp,header,accessor,class,assert,state,header,accessor,null,no,stomp,header,accessor,header,accessor,set,session,id,session,get,id,header,accessor,set,session,attributes,session,get,attributes,header,accessor,set,user,get,user,session,header,accessor,set,header,simp,message,header,accessor,header,accessor,get,heartbeat,if,detect,immutable,message,interceptor,output,channel,header,accessor,set,immutable,if,logger,is,trace,enabled,logger,trace,from,client,header,accessor,get,short,log,message,message,get,payload,stomp,command,command,header,accessor,get,command,boolean,is,connect,stomp,command,connect,equals,command,if,is,connect,this,stats,increment,connect,count,else,if,stomp,command,disconnect,equals,command,this,stats,increment,disconnect,count,try,simp,attributes,context,holder,set,attributes,from,message,message,boolean,sent,output,channel,send,message,if,sent,if,is,connect,principal,user,header,accessor,get,user,if,user,null,user,session,get,principal,this,stomp,authentications,put,session,get,id,user,if,this,event,publisher,null,principal,user,get,user,session,if,is,connect,publish,event,this,event,publisher,new,session,connect,event,this,message,user,else,if,stomp,command,subscribe,equals,command,publish,event,this,event,publisher,new,session,subscribe,event,this,message,user,else,if,stomp,command,unsubscribe,equals,command,publish,event,this,event,publisher,new,session,unsubscribe,event,this,message,user,finally,simp,attributes,context,holder,reset,attributes,catch,throwable,ex,if,logger,is,error,enabled,logger,error,failed,to,send,client,message,to,application,via,message,channel,in,session,session,get,id,sending,stomp,error,to,client,ex,handle,error,session,ex,message
StompSubProtocolHandler -> public void handleMessageFromClient(WebSocketSession session, 			WebSocketMessage<?> webSocketMessage, MessageChannel outputChannel);1542899558;Handle incoming WebSocket messages from clients.;public void handleMessageFromClient(WebSocketSession session,_			WebSocketMessage<?> webSocketMessage, MessageChannel outputChannel) {__		List<Message<byte[]>> messages__		try {_			ByteBuffer byteBuffer__			if (webSocketMessage instanceof TextMessage) {_				byteBuffer = ByteBuffer.wrap(((TextMessage) webSocketMessage).asBytes())__			}_			else if (webSocketMessage instanceof BinaryMessage) {_				byteBuffer = ((BinaryMessage) webSocketMessage).getPayload()__			}_			else {_				return__			}__			BufferingStompDecoder decoder = this.decoders.get(session.getId())__			if (decoder == null) {_				throw new IllegalStateException("No decoder for session id '" + session.getId() + "'")__			}__			messages = decoder.decode(byteBuffer)__			if (messages.isEmpty()) {_				if (logger.isTraceEnabled()) {_					logger.trace("Incomplete STOMP frame content received in session " +_							session + ", bufferSize=" + decoder.getBufferSize() +_							", bufferSizeLimit=" + decoder.getBufferSizeLimit() + ".")__				}_				return__			}_		}_		catch (Throwable ex) {_			if (logger.isErrorEnabled()) {_				logger.error("Failed to parse " + webSocketMessage +_						" in session " + session.getId() + ". Sending STOMP ERROR to client.", ex)__			}_			handleError(session, ex, null)__			return__		}__		for (Message<byte[]> message : messages) {_			try {_				StompHeaderAccessor headerAccessor =_						MessageHeaderAccessor.getAccessor(message, StompHeaderAccessor.class)__				Assert.state(headerAccessor != null, "No StompHeaderAccessor")___				headerAccessor.setSessionId(session.getId())__				headerAccessor.setSessionAttributes(session.getAttributes())__				headerAccessor.setUser(getUser(session))__				headerAccessor.setHeader(SimpMessageHeaderAccessor.HEART_BEAT_HEADER, headerAccessor.getHeartbeat())__				if (!detectImmutableMessageInterceptor(outputChannel)) {_					headerAccessor.setImmutable()__				}__				if (logger.isTraceEnabled()) {_					logger.trace("From client: " + headerAccessor.getShortLogMessage(message.getPayload()))__				}__				StompCommand command = headerAccessor.getCommand()__				boolean isConnect = StompCommand.CONNECT.equals(command)__				if (isConnect) {_					this.stats.incrementConnectCount()__				}_				else if (StompCommand.DISCONNECT.equals(command)) {_					this.stats.incrementDisconnectCount()__				}__				try {_					SimpAttributesContextHolder.setAttributesFromMessage(message)__					boolean sent = outputChannel.send(message)___					if (sent) {_						if (isConnect) {_							Principal user = headerAccessor.getUser()__							if (user != null && user != session.getPrincipal()) {_								this.stompAuthentications.put(session.getId(), user)__							}_						}_						if (this.eventPublisher != null) {_							Principal user = getUser(session)__							if (isConnect) {_								publishEvent(this.eventPublisher, new SessionConnectEvent(this, message, user))__							}_							else if (StompCommand.SUBSCRIBE.equals(command)) {_								publishEvent(this.eventPublisher, new SessionSubscribeEvent(this, message, user))__							}_							else if (StompCommand.UNSUBSCRIBE.equals(command)) {_								publishEvent(this.eventPublisher, new SessionUnsubscribeEvent(this, message, user))__							}_						}_					}_				}_				finally {_					SimpAttributesContextHolder.resetAttributes()__				}_			}_			catch (Throwable ex) {_				if (logger.isErrorEnabled()) {_					logger.error("Failed to send client message to application via MessageChannel" +_							" in session " + session.getId() + ". Sending STOMP ERROR to client.", ex)__				}_				handleError(session, ex, message)__			}_		}_	};handle,incoming,web,socket,messages,from,clients;public,void,handle,message,from,client,web,socket,session,session,web,socket,message,web,socket,message,message,channel,output,channel,list,message,byte,messages,try,byte,buffer,byte,buffer,if,web,socket,message,instanceof,text,message,byte,buffer,byte,buffer,wrap,text,message,web,socket,message,as,bytes,else,if,web,socket,message,instanceof,binary,message,byte,buffer,binary,message,web,socket,message,get,payload,else,return,buffering,stomp,decoder,decoder,this,decoders,get,session,get,id,if,decoder,null,throw,new,illegal,state,exception,no,decoder,for,session,id,session,get,id,messages,decoder,decode,byte,buffer,if,messages,is,empty,if,logger,is,trace,enabled,logger,trace,incomplete,stomp,frame,content,received,in,session,session,buffer,size,decoder,get,buffer,size,buffer,size,limit,decoder,get,buffer,size,limit,return,catch,throwable,ex,if,logger,is,error,enabled,logger,error,failed,to,parse,web,socket,message,in,session,session,get,id,sending,stomp,error,to,client,ex,handle,error,session,ex,null,return,for,message,byte,message,messages,try,stomp,header,accessor,header,accessor,message,header,accessor,get,accessor,message,stomp,header,accessor,class,assert,state,header,accessor,null,no,stomp,header,accessor,header,accessor,set,session,id,session,get,id,header,accessor,set,session,attributes,session,get,attributes,header,accessor,set,user,get,user,session,header,accessor,set,header,simp,message,header,accessor,header,accessor,get,heartbeat,if,detect,immutable,message,interceptor,output,channel,header,accessor,set,immutable,if,logger,is,trace,enabled,logger,trace,from,client,header,accessor,get,short,log,message,message,get,payload,stomp,command,command,header,accessor,get,command,boolean,is,connect,stomp,command,connect,equals,command,if,is,connect,this,stats,increment,connect,count,else,if,stomp,command,disconnect,equals,command,this,stats,increment,disconnect,count,try,simp,attributes,context,holder,set,attributes,from,message,message,boolean,sent,output,channel,send,message,if,sent,if,is,connect,principal,user,header,accessor,get,user,if,user,null,user,session,get,principal,this,stomp,authentications,put,session,get,id,user,if,this,event,publisher,null,principal,user,get,user,session,if,is,connect,publish,event,this,event,publisher,new,session,connect,event,this,message,user,else,if,stomp,command,subscribe,equals,command,publish,event,this,event,publisher,new,session,subscribe,event,this,message,user,else,if,stomp,command,unsubscribe,equals,command,publish,event,this,event,publisher,new,session,unsubscribe,event,this,message,user,finally,simp,attributes,context,holder,reset,attributes,catch,throwable,ex,if,logger,is,error,enabled,logger,error,failed,to,send,client,message,to,application,via,message,channel,in,session,session,get,id,sending,stomp,error,to,client,ex,handle,error,session,ex,message
StompSubProtocolHandler -> public UserSessionRegistry getUserSessionRegistry();1385258957;@return the configured UserSessionRegistry.;public UserSessionRegistry getUserSessionRegistry() {_		return this.userSessionRegistry__	};return,the,configured,user,session,registry;public,user,session,registry,get,user,session,registry,return,this,user,session,registry
StompSubProtocolHandler -> public UserSessionRegistry getUserSessionRegistry();1385412762;@return the configured UserSessionRegistry.;public UserSessionRegistry getUserSessionRegistry() {_		return this.userSessionRegistry__	};return,the,configured,user,session,registry;public,user,session,registry,get,user,session,registry,return,this,user,session,registry
StompSubProtocolHandler -> public UserSessionRegistry getUserSessionRegistry();1385501137;@return the configured UserSessionRegistry.;public UserSessionRegistry getUserSessionRegistry() {_		return this.userSessionRegistry__	};return,the,configured,user,session,registry;public,user,session,registry,get,user,session,registry,return,this,user,session,registry
StompSubProtocolHandler -> public UserSessionRegistry getUserSessionRegistry();1385502674;@return the configured UserSessionRegistry.;public UserSessionRegistry getUserSessionRegistry() {_		return this.userSessionRegistry__	};return,the,configured,user,session,registry;public,user,session,registry,get,user,session,registry,return,this,user,session,registry
StompSubProtocolHandler -> public UserSessionRegistry getUserSessionRegistry();1386367529;@return the configured UserSessionRegistry.;public UserSessionRegistry getUserSessionRegistry() {_		return this.userSessionRegistry__	};return,the,configured,user,session,registry;public,user,session,registry,get,user,session,registry,return,this,user,session,registry
StompSubProtocolHandler -> public UserSessionRegistry getUserSessionRegistry();1386462352;@return the configured UserSessionRegistry.;public UserSessionRegistry getUserSessionRegistry() {_		return this.userSessionRegistry__	};return,the,configured,user,session,registry;public,user,session,registry,get,user,session,registry,return,this,user,session,registry
StompSubProtocolHandler -> public UserSessionRegistry getUserSessionRegistry();1388683679;@return the configured UserSessionRegistry.;public UserSessionRegistry getUserSessionRegistry() {_		return this.userSessionRegistry__	};return,the,configured,user,session,registry;public,user,session,registry,get,user,session,registry,return,this,user,session,registry
StompSubProtocolHandler -> public UserSessionRegistry getUserSessionRegistry();1390324325;@return the configured UserSessionRegistry.;public UserSessionRegistry getUserSessionRegistry() {_		return this.userSessionRegistry__	};return,the,configured,user,session,registry;public,user,session,registry,get,user,session,registry,return,this,user,session,registry
StompSubProtocolHandler -> public UserSessionRegistry getUserSessionRegistry();1390325555;@return the configured UserSessionRegistry.;public UserSessionRegistry getUserSessionRegistry() {_		return this.userSessionRegistry__	};return,the,configured,user,session,registry;public,user,session,registry,get,user,session,registry,return,this,user,session,registry
StompSubProtocolHandler -> public UserSessionRegistry getUserSessionRegistry();1392327536;@return the configured UserSessionRegistry.;public UserSessionRegistry getUserSessionRegistry() {_		return this.userSessionRegistry__	};return,the,configured,user,session,registry;public,user,session,registry,get,user,session,registry,return,this,user,session,registry
StompSubProtocolHandler -> public UserSessionRegistry getUserSessionRegistry();1395251140;@return the configured UserSessionRegistry.;public UserSessionRegistry getUserSessionRegistry() {_		return this.userSessionRegistry__	};return,the,configured,user,session,registry;public,user,session,registry,get,user,session,registry,return,this,user,session,registry
StompSubProtocolHandler -> public UserSessionRegistry getUserSessionRegistry();1395364758;@return the configured UserSessionRegistry.;public UserSessionRegistry getUserSessionRegistry() {_		return this.userSessionRegistry__	};return,the,configured,user,session,registry;public,user,session,registry,get,user,session,registry,return,this,user,session,registry
StompSubProtocolHandler -> public UserSessionRegistry getUserSessionRegistry();1395416543;@return the configured UserSessionRegistry.;public UserSessionRegistry getUserSessionRegistry() {_		return this.userSessionRegistry__	};return,the,configured,user,session,registry;public,user,session,registry,get,user,session,registry,return,this,user,session,registry
StompSubProtocolHandler -> public UserSessionRegistry getUserSessionRegistry();1395543579;@return the configured UserSessionRegistry.;public UserSessionRegistry getUserSessionRegistry() {_		return this.userSessionRegistry__	};return,the,configured,user,session,registry;public,user,session,registry,get,user,session,registry,return,this,user,session,registry
StompSubProtocolHandler -> public UserSessionRegistry getUserSessionRegistry();1395555177;@return the configured UserSessionRegistry.;public UserSessionRegistry getUserSessionRegistry() {_		return this.userSessionRegistry__	};return,the,configured,user,session,registry;public,user,session,registry,get,user,session,registry,return,this,user,session,registry
StompSubProtocolHandler -> public UserSessionRegistry getUserSessionRegistry();1395703237;@return the configured UserSessionRegistry.;public UserSessionRegistry getUserSessionRegistry() {_		return this.userSessionRegistry__	};return,the,configured,user,session,registry;public,user,session,registry,get,user,session,registry,return,this,user,session,registry
StompSubProtocolHandler -> public UserSessionRegistry getUserSessionRegistry();1395703237;@return the configured UserSessionRegistry.;public UserSessionRegistry getUserSessionRegistry() {_		return this.userSessionRegistry__	};return,the,configured,user,session,registry;public,user,session,registry,get,user,session,registry,return,this,user,session,registry
StompSubProtocolHandler -> public UserSessionRegistry getUserSessionRegistry();1395703237;@return the configured UserSessionRegistry.;public UserSessionRegistry getUserSessionRegistry() {_		return this.userSessionRegistry__	};return,the,configured,user,session,registry;public,user,session,registry,get,user,session,registry,return,this,user,session,registry
StompSubProtocolHandler -> public UserSessionRegistry getUserSessionRegistry();1395703238;@return the configured UserSessionRegistry.;public UserSessionRegistry getUserSessionRegistry() {_		return this.userSessionRegistry__	};return,the,configured,user,session,registry;public,user,session,registry,get,user,session,registry,return,this,user,session,registry
StompSubProtocolHandler -> public UserSessionRegistry getUserSessionRegistry();1395707441;@return the configured UserSessionRegistry.;public UserSessionRegistry getUserSessionRegistry() {_		return this.userSessionRegistry__	};return,the,configured,user,session,registry;public,user,session,registry,get,user,session,registry,return,this,user,session,registry
StompSubProtocolHandler -> public UserSessionRegistry getUserSessionRegistry();1395721625;@return the configured UserSessionRegistry.;public UserSessionRegistry getUserSessionRegistry() {_		return this.userSessionRegistry__	};return,the,configured,user,session,registry;public,user,session,registry,get,user,session,registry,return,this,user,session,registry
StompSubProtocolHandler -> public UserSessionRegistry getUserSessionRegistry();1395752742;@return the configured UserSessionRegistry.;public UserSessionRegistry getUserSessionRegistry() {_		return this.userSessionRegistry__	};return,the,configured,user,session,registry;public,user,session,registry,get,user,session,registry,return,this,user,session,registry
StompSubProtocolHandler -> public UserSessionRegistry getUserSessionRegistry();1395755949;@return the configured UserSessionRegistry.;public UserSessionRegistry getUserSessionRegistry() {_		return this.userSessionRegistry__	};return,the,configured,user,session,registry;public,user,session,registry,get,user,session,registry,return,this,user,session,registry
StompSubProtocolHandler -> public UserSessionRegistry getUserSessionRegistry();1395847954;@return the configured UserSessionRegistry.;public UserSessionRegistry getUserSessionRegistry() {_		return this.userSessionRegistry__	};return,the,configured,user,session,registry;public,user,session,registry,get,user,session,registry,return,this,user,session,registry
StompSubProtocolHandler -> public UserSessionRegistry getUserSessionRegistry();1396578670;@return the configured UserSessionRegistry.;public UserSessionRegistry getUserSessionRegistry() {_		return this.userSessionRegistry__	};return,the,configured,user,session,registry;public,user,session,registry,get,user,session,registry,return,this,user,session,registry
StompSubProtocolHandler -> public UserSessionRegistry getUserSessionRegistry();1396636309;@return the configured UserSessionRegistry.;public UserSessionRegistry getUserSessionRegistry() {_		return this.userSessionRegistry__	};return,the,configured,user,session,registry;public,user,session,registry,get,user,session,registry,return,this,user,session,registry
StompSubProtocolHandler -> public UserSessionRegistry getUserSessionRegistry();1397429525;@return the configured UserSessionRegistry.;public UserSessionRegistry getUserSessionRegistry() {_		return this.userSessionRegistry__	};return,the,configured,user,session,registry;public,user,session,registry,get,user,session,registry,return,this,user,session,registry
StompSubProtocolHandler -> public UserSessionRegistry getUserSessionRegistry();1397439322;@return the configured UserSessionRegistry.;public UserSessionRegistry getUserSessionRegistry() {_		return this.userSessionRegistry__	};return,the,configured,user,session,registry;public,user,session,registry,get,user,session,registry,return,this,user,session,registry
StompSubProtocolHandler -> public UserSessionRegistry getUserSessionRegistry();1397523793;@return the configured UserSessionRegistry.;public UserSessionRegistry getUserSessionRegistry() {_		return this.userSessionRegistry__	};return,the,configured,user,session,registry;public,user,session,registry,get,user,session,registry,return,this,user,session,registry
StompSubProtocolHandler -> public UserSessionRegistry getUserSessionRegistry();1398443164;@return the configured UserSessionRegistry.;public UserSessionRegistry getUserSessionRegistry() {_		return this.userSessionRegistry__	};return,the,configured,user,session,registry;public,user,session,registry,get,user,session,registry,return,this,user,session,registry
StompSubProtocolHandler -> public UserSessionRegistry getUserSessionRegistry();1399601217;@return the configured UserSessionRegistry.;public UserSessionRegistry getUserSessionRegistry() {_		return this.userSessionRegistry__	};return,the,configured,user,session,registry;public,user,session,registry,get,user,session,registry,return,this,user,session,registry
StompSubProtocolHandler -> public UserSessionRegistry getUserSessionRegistry();1399825877;@return the configured UserSessionRegistry.;public UserSessionRegistry getUserSessionRegistry() {_		return this.userSessionRegistry__	};return,the,configured,user,session,registry;public,user,session,registry,get,user,session,registry,return,this,user,session,registry
StompSubProtocolHandler -> public UserSessionRegistry getUserSessionRegistry();1403719829;@return the configured UserSessionRegistry.;public UserSessionRegistry getUserSessionRegistry() {_		return this.userSessionRegistry__	};return,the,configured,user,session,registry;public,user,session,registry,get,user,session,registry,return,this,user,session,registry
StompSubProtocolHandler -> public UserSessionRegistry getUserSessionRegistry();1403856366;@return the configured UserSessionRegistry.;public UserSessionRegistry getUserSessionRegistry() {_		return this.userSessionRegistry__	};return,the,configured,user,session,registry;public,user,session,registry,get,user,session,registry,return,this,user,session,registry
StompSubProtocolHandler -> public UserSessionRegistry getUserSessionRegistry();1403968062;@return the configured UserSessionRegistry.;public UserSessionRegistry getUserSessionRegistry() {_		return this.userSessionRegistry__	};return,the,configured,user,session,registry;public,user,session,registry,get,user,session,registry,return,this,user,session,registry
StompSubProtocolHandler -> public UserSessionRegistry getUserSessionRegistry();1404880787;@return the configured UserSessionRegistry.;public UserSessionRegistry getUserSessionRegistry() {_		return this.userSessionRegistry__	};return,the,configured,user,session,registry;public,user,session,registry,get,user,session,registry,return,this,user,session,registry
StompSubProtocolHandler -> public UserSessionRegistry getUserSessionRegistry();1404880799;@return the configured UserSessionRegistry.;public UserSessionRegistry getUserSessionRegistry() {_		return this.userSessionRegistry__	};return,the,configured,user,session,registry;public,user,session,registry,get,user,session,registry,return,this,user,session,registry
StompSubProtocolHandler -> public UserSessionRegistry getUserSessionRegistry();1411067168;@return the configured UserSessionRegistry.;public UserSessionRegistry getUserSessionRegistry() {_		return this.userSessionRegistry__	};return,the,configured,user,session,registry;public,user,session,registry,get,user,session,registry,return,this,user,session,registry
StompSubProtocolHandler -> public UserSessionRegistry getUserSessionRegistry();1411068071;@return the configured UserSessionRegistry.;public UserSessionRegistry getUserSessionRegistry() {_		return this.userSessionRegistry__	};return,the,configured,user,session,registry;public,user,session,registry,get,user,session,registry,return,this,user,session,registry
StompSubProtocolHandler -> public UserSessionRegistry getUserSessionRegistry();1411148800;@return the configured UserSessionRegistry.;public UserSessionRegistry getUserSessionRegistry() {_		return this.userSessionRegistry__	};return,the,configured,user,session,registry;public,user,session,registry,get,user,session,registry,return,this,user,session,registry
StompSubProtocolHandler -> public UserSessionRegistry getUserSessionRegistry();1411567635;@return the configured UserSessionRegistry.;public UserSessionRegistry getUserSessionRegistry() {_		return this.userSessionRegistry__	};return,the,configured,user,session,registry;public,user,session,registry,get,user,session,registry,return,this,user,session,registry
StompSubProtocolHandler -> public UserSessionRegistry getUserSessionRegistry();1412965899;@return the configured UserSessionRegistry.;public UserSessionRegistry getUserSessionRegistry() {_		return this.userSessionRegistry__	};return,the,configured,user,session,registry;public,user,session,registry,get,user,session,registry,return,this,user,session,registry
StompSubProtocolHandler -> public UserSessionRegistry getUserSessionRegistry();1413848647;@return the configured UserSessionRegistry.;public UserSessionRegistry getUserSessionRegistry() {_		return this.userSessionRegistry__	};return,the,configured,user,session,registry;public,user,session,registry,get,user,session,registry,return,this,user,session,registry
StompSubProtocolHandler -> public UserSessionRegistry getUserSessionRegistry();1414092351;@return the configured UserSessionRegistry.;public UserSessionRegistry getUserSessionRegistry() {_		return this.userSessionRegistry__	};return,the,configured,user,session,registry;public,user,session,registry,get,user,session,registry,return,this,user,session,registry
StompSubProtocolHandler -> public UserSessionRegistry getUserSessionRegistry();1414158498;@return the configured UserSessionRegistry.;public UserSessionRegistry getUserSessionRegistry() {_		return this.userSessionRegistry__	};return,the,configured,user,session,registry;public,user,session,registry,get,user,session,registry,return,this,user,session,registry
StompSubProtocolHandler -> public UserSessionRegistry getUserSessionRegistry();1419362683;@return the configured UserSessionRegistry.;public UserSessionRegistry getUserSessionRegistry() {_		return this.userSessionRegistry__	};return,the,configured,user,session,registry;public,user,session,registry,get,user,session,registry,return,this,user,session,registry
StompSubProtocolHandler -> public UserSessionRegistry getUserSessionRegistry();1419883989;@return the configured UserSessionRegistry.;public UserSessionRegistry getUserSessionRegistry() {_		return this.userSessionRegistry__	};return,the,configured,user,session,registry;public,user,session,registry,get,user,session,registry,return,this,user,session,registry
StompSubProtocolHandler -> public UserSessionRegistry getUserSessionRegistry();1424278379;@return the configured UserSessionRegistry.;public UserSessionRegistry getUserSessionRegistry() {_		return this.userSessionRegistry__	};return,the,configured,user,session,registry;public,user,session,registry,get,user,session,registry,return,this,user,session,registry
StompSubProtocolHandler -> public UserSessionRegistry getUserSessionRegistry();1428353843;@return the configured UserSessionRegistry.;public UserSessionRegistry getUserSessionRegistry() {_		return this.userSessionRegistry__	};return,the,configured,user,session,registry;public,user,session,registry,get,user,session,registry,return,this,user,session,registry
StompSubProtocolHandler -> public UserSessionRegistry getUserSessionRegistry();1430834982;@return the configured UserSessionRegistry.;public UserSessionRegistry getUserSessionRegistry() {_		return this.userSessionRegistry__	};return,the,configured,user,session,registry;public,user,session,registry,get,user,session,registry,return,this,user,session,registry
StompSubProtocolHandler -> @Nullable 	public StompSubProtocolErrorHandler getErrorHandler();1496837955;Return the configured error handler.;@Nullable_	public StompSubProtocolErrorHandler getErrorHandler() {_		return this.errorHandler__	};return,the,configured,error,handler;nullable,public,stomp,sub,protocol,error,handler,get,error,handler,return,this,error,handler
StompSubProtocolHandler -> @Nullable 	public StompSubProtocolErrorHandler getErrorHandler();1497251962;Return the configured error handler.;@Nullable_	public StompSubProtocolErrorHandler getErrorHandler() {_		return this.errorHandler__	};return,the,configured,error,handler;nullable,public,stomp,sub,protocol,error,handler,get,error,handler,return,this,error,handler
StompSubProtocolHandler -> @Nullable 	public StompSubProtocolErrorHandler getErrorHandler();1498780456;Return the configured error handler.;@Nullable_	public StompSubProtocolErrorHandler getErrorHandler() {_		return this.errorHandler__	};return,the,configured,error,handler;nullable,public,stomp,sub,protocol,error,handler,get,error,handler,return,this,error,handler
StompSubProtocolHandler -> @Nullable 	public StompSubProtocolErrorHandler getErrorHandler();1500448076;Return the configured error handler.;@Nullable_	public StompSubProtocolErrorHandler getErrorHandler() {_		return this.errorHandler__	};return,the,configured,error,handler;nullable,public,stomp,sub,protocol,error,handler,get,error,handler,return,this,error,handler
StompSubProtocolHandler -> @Nullable 	public StompSubProtocolErrorHandler getErrorHandler();1501147952;Return the configured error handler.;@Nullable_	public StompSubProtocolErrorHandler getErrorHandler() {_		return this.errorHandler__	};return,the,configured,error,handler;nullable,public,stomp,sub,protocol,error,handler,get,error,handler,return,this,error,handler
StompSubProtocolHandler -> @Nullable 	public StompSubProtocolErrorHandler getErrorHandler();1502974979;Return the configured error handler.;@Nullable_	public StompSubProtocolErrorHandler getErrorHandler() {_		return this.errorHandler__	};return,the,configured,error,handler;nullable,public,stomp,sub,protocol,error,handler,get,error,handler,return,this,error,handler
StompSubProtocolHandler -> @Nullable 	public StompSubProtocolErrorHandler getErrorHandler();1509997270;Return the configured error handler.;@Nullable_	public StompSubProtocolErrorHandler getErrorHandler() {_		return this.errorHandler__	};return,the,configured,error,handler;nullable,public,stomp,sub,protocol,error,handler,get,error,handler,return,this,error,handler
StompSubProtocolHandler -> @Nullable 	public StompSubProtocolErrorHandler getErrorHandler();1530174524;Return the configured error handler.;@Nullable_	public StompSubProtocolErrorHandler getErrorHandler() {_		return this.errorHandler__	};return,the,configured,error,handler;nullable,public,stomp,sub,protocol,error,handler,get,error,handler,return,this,error,handler
StompSubProtocolHandler -> @Nullable 	public StompSubProtocolErrorHandler getErrorHandler();1536886762;Return the configured error handler.;@Nullable_	public StompSubProtocolErrorHandler getErrorHandler() {_		return this.errorHandler__	};return,the,configured,error,handler;nullable,public,stomp,sub,protocol,error,handler,get,error,handler,return,this,error,handler
StompSubProtocolHandler -> @Nullable 	public StompSubProtocolErrorHandler getErrorHandler();1542899558;Return the configured error handler.;@Nullable_	public StompSubProtocolErrorHandler getErrorHandler() {_		return this.errorHandler__	};return,the,configured,error,handler;nullable,public,stomp,sub,protocol,error,handler,get,error,handler,return,this,error,handler
