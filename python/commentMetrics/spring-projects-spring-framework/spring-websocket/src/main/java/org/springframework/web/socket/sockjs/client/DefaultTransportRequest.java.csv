commented;modifiers;parameterAmount;loc;comment;code
false;public;0;4;;@Override public SockJsUrlInfo getSockJsUrlInfo() {     return this.sockJsUrlInfo. }
false;public;0;4;;@Override public HttpHeaders getHandshakeHeaders() {     return this.handshakeHeaders. }
false;public;0;4;;@Override public HttpHeaders getHttpRequestHeaders() {     return this.httpRequestHeaders. }
false;public;0;4;;@Override public URI getTransportUrl() {     return this.sockJsUrlInfo.getTransportUrl(this.serverTransportType). }
false;public;1;3;;public void setUser(Principal user) {     this.user = user. }
false;public;0;5;;@Override @Nullable public Principal getUser() {     return this.user. }
false;public;0;4;;@Override public SockJsMessageCodec getMessageCodec() {     return this.codec. }
false;public;1;3;;public void setTimeoutValue(long timeoutValue) {     this.timeoutValue = timeoutValue. }
false;public;1;3;;public void setTimeoutScheduler(TaskScheduler scheduler) {     this.timeoutScheduler = scheduler. }
false;public;1;4;;@Override public void addTimeoutTask(Runnable runnable) {     this.timeoutTasks.add(runnable). }
false;public;1;3;;public void setFallbackRequest(DefaultTransportRequest fallbackRequest) {     this.fallbackRequest = fallbackRequest. }
false;public;2;8;;public void connect(WebSocketHandler handler, SettableListenableFuture<WebSocketSession> future) {     if (logger.isTraceEnabled()) {         logger.trace("Starting " + this).     }     ConnectCallback connectCallback = new ConnectCallback(handler, future).     scheduleConnectTimeoutTask(connectCallback).     this.transport.connect(this, handler).addCallback(connectCallback). }
false;private;1;12;;private void scheduleConnectTimeoutTask(ConnectCallback connectHandler) {     if (this.timeoutScheduler != null) {         if (logger.isTraceEnabled()) {             logger.trace("Scheduling connect to time out after " + this.timeoutValue + " ms.").         }         Date timeoutDate = new Date(System.currentTimeMillis() + this.timeoutValue).         this.timeoutScheduler.schedule(connectHandler, timeoutDate).     } else if (logger.isTraceEnabled()) {         logger.trace("Connect timeout task not scheduled (no TaskScheduler configured).").     } }
false;public;0;4;;@Override public String toString() {     return "TransportRequest[url=" + getTransportUrl() + "]". }
false;public;1;9;;@Override public void onSuccess(@Nullable WebSocketSession session) {     if (this.handled.compareAndSet(false, true)) {         this.future.set(session).     } else if (logger.isErrorEnabled()) {         logger.error("Connect success/failure already handled for " + DefaultTransportRequest.this).     } }
false;public;1;4;;@Override public void onFailure(Throwable ex) {     handleFailure(ex, false). }
false;public;0;4;;@Override public void run() {     handleFailure(null, true). }
false;private;2;33;;private void handleFailure(@Nullable Throwable ex, boolean isTimeoutFailure) {     if (this.handled.compareAndSet(false, true)) {         if (isTimeoutFailure) {             String message = "Connect timed out for " + DefaultTransportRequest.this.             logger.error(message).             ex = new SockJsTransportFailureException(message, getSockJsUrlInfo().getSessionId(), ex).         }         if (fallbackRequest != null) {             logger.error(DefaultTransportRequest.this + " failed. Falling back on next transport.", ex).             fallbackRequest.connect(this.handler, this.future).         } else {             logger.error("No more fallback transports after " + DefaultTransportRequest.this, ex).             if (ex != null) {                 this.future.setException(ex).             }         }         if (isTimeoutFailure) {             try {                 for (Runnable runnable : timeoutTasks) {                     runnable.run().                 }             } catch (Throwable ex2) {                 logger.error("Transport failed to run timeout tasks for " + DefaultTransportRequest.this, ex2).             }         }     } else {         logger.error("Connect success/failure events already took place for " + DefaultTransportRequest.this + ". Ignoring this additional failure event.", ex).     } }
