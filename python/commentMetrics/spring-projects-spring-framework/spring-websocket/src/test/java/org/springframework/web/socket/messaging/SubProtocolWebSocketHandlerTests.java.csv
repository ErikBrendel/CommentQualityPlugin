commented;modifiers;parameterAmount;loc;comment;code
false;public;0;10;;@Before public void setup() {     MockitoAnnotations.initMocks(this).     this.webSocketHandler = new SubProtocolWebSocketHandler(this.inClientChannel, this.outClientChannel).     given(stompHandler.getSupportedProtocols()).willReturn(Arrays.asList("v10.stomp", "v11.stomp", "v12.stomp")).     given(mqttHandler.getSupportedProtocols()).willReturn(Arrays.asList("MQTT")).     this.session = new TestWebSocketSession().     this.session.setId("1").     this.session.setOpen(true). }
false;public;0;10;;@Test public void subProtocolMatch() throws Exception {     this.webSocketHandler.setProtocolHandlers(Arrays.asList(stompHandler, mqttHandler)).     this.session.setAcceptedProtocol("v12.sToMp").     this.webSocketHandler.afterConnectionEstablished(session).     verify(this.stompHandler).afterSessionStarted(isA(ConcurrentWebSocketSessionDecorator.class), eq(this.inClientChannel)).     verify(this.mqttHandler, times(0)).afterSessionStarted(session, this.inClientChannel). }
false;public;0;9;;@Test public void subProtocolDefaultHandlerOnly() throws Exception {     this.webSocketHandler.setDefaultProtocolHandler(stompHandler).     this.session.setAcceptedProtocol("v12.sToMp").     this.webSocketHandler.afterConnectionEstablished(session).     verify(this.stompHandler).afterSessionStarted(isA(ConcurrentWebSocketSessionDecorator.class), eq(this.inClientChannel)). }
false;public;0;8;;@Test(expected = IllegalStateException.class) public void subProtocolNoMatch() throws Exception {     this.webSocketHandler.setDefaultProtocolHandler(defaultHandler).     this.webSocketHandler.setProtocolHandlers(Arrays.asList(stompHandler, mqttHandler)).     this.session.setAcceptedProtocol("wamp").     this.webSocketHandler.afterConnectionEstablished(session). }
false;public;0;10;;@Test public void nullSubProtocol() throws Exception {     this.webSocketHandler.setDefaultProtocolHandler(defaultHandler).     this.webSocketHandler.afterConnectionEstablished(session).     verify(this.defaultHandler).afterSessionStarted(isA(ConcurrentWebSocketSessionDecorator.class), eq(this.inClientChannel)).     verify(this.stompHandler, times(0)).afterSessionStarted(session, this.inClientChannel).     verify(this.mqttHandler, times(0)).afterSessionStarted(session, this.inClientChannel). }
false;public;0;11;;@Test public void emptySubProtocol() throws Exception {     this.session.setAcceptedProtocol("").     this.webSocketHandler.setDefaultProtocolHandler(this.defaultHandler).     this.webSocketHandler.afterConnectionEstablished(session).     verify(this.defaultHandler).afterSessionStarted(isA(ConcurrentWebSocketSessionDecorator.class), eq(this.inClientChannel)).     verify(this.stompHandler, times(0)).afterSessionStarted(session, this.inClientChannel).     verify(this.mqttHandler, times(0)).afterSessionStarted(session, this.inClientChannel). }
false;public;0;8;;@Test public void noSubProtocolOneHandler() throws Exception {     this.webSocketHandler.setProtocolHandlers(Arrays.asList(stompHandler)).     this.webSocketHandler.afterConnectionEstablished(session).     verify(this.stompHandler).afterSessionStarted(isA(ConcurrentWebSocketSessionDecorator.class), eq(this.inClientChannel)). }
false;public;0;5;;@Test(expected = IllegalStateException.class) public void noSubProtocolTwoHandlers() throws Exception {     this.webSocketHandler.setProtocolHandlers(Arrays.asList(stompHandler, mqttHandler)).     this.webSocketHandler.afterConnectionEstablished(session). }
false;public;0;5;;@Test(expected = IllegalStateException.class) public void noSubProtocolNoDefaultHandler() throws Exception {     this.webSocketHandler.setProtocolHandlers(Arrays.asList(stompHandler, mqttHandler)).     this.webSocketHandler.afterConnectionEstablished(session). }
false;public;0;36;;@Test @SuppressWarnings("unchecked") public void checkSession() throws Exception {     TestWebSocketSession session1 = new TestWebSocketSession("id1").     TestWebSocketSession session2 = new TestWebSocketSession("id2").     session1.setOpen(true).     session2.setOpen(true).     session1.setAcceptedProtocol("v12.stomp").     session2.setAcceptedProtocol("v12.stomp").     this.webSocketHandler.setProtocolHandlers(Arrays.asList(this.stompHandler)).     this.webSocketHandler.afterConnectionEstablished(session1).     this.webSocketHandler.afterConnectionEstablished(session2).     DirectFieldAccessor handlerAccessor = new DirectFieldAccessor(this.webSocketHandler).     Map<String, ?> map = (Map<String, ?>) handlerAccessor.getPropertyValue("sessions").     DirectFieldAccessor session1Accessor = new DirectFieldAccessor(map.get("id1")).     DirectFieldAccessor session2Accessor = new DirectFieldAccessor(map.get("id2")).     long sixtyOneSecondsAgo = System.currentTimeMillis() - 61 * 1000.     handlerAccessor.setPropertyValue("lastSessionCheckTime", sixtyOneSecondsAgo).     session1Accessor.setPropertyValue("createTime", sixtyOneSecondsAgo).     session2Accessor.setPropertyValue("createTime", sixtyOneSecondsAgo).     this.webSocketHandler.start().     this.webSocketHandler.handleMessage(session1, new TextMessage("foo")).     assertTrue(session1.isOpen()).     assertNull(session1.getCloseStatus()).     assertFalse(session2.isOpen()).     assertEquals(CloseStatus.SESSION_NOT_RELIABLE, session2.getCloseStatus()).     assertNotEquals("lastSessionCheckTime not updated", sixtyOneSecondsAgo, handlerAccessor.getPropertyValue("lastSessionCheckTime")). }
