commented;modifiers;parameterAmount;loc;comment;code
false;public;0;18;;@Before public void setUp() throws Exception {     logger.debug("Setting up before '" + this.testName.getMethodName() + "'").     this.wac = new AnnotationConfigWebApplicationContext().     this.wac.register(TestConfig.class).     this.wac.refresh().     this.server = new TomcatWebSocketTestServer().     this.server.setup().     this.server.deployConfig(this.wac).     this.server.start().     WebSocketClient webSocketClient = new StandardWebSocketClient().     this.stompClient = new WebSocketStompClient(webSocketClient).     this.stompClient.setMessageConverter(new StringMessageConverter()). }
false;public;0;21;;@After public void tearDown() throws Exception {     try {         this.server.undeployConfig().     } catch (Throwable t) {         logger.error("Failed to undeploy application config", t).     }     try {         this.server.stop().     } catch (Throwable t) {         logger.error("Failed to stop server", t).     }     try {         this.wac.close().     } catch (Throwable t) {         logger.error("Failed to close WebApplicationContext", t).     } }
false;public;0;11;;@Test public void publishSubscribe() throws Exception {     String url = "ws://127.0.0.1:" + this.server.getPort() + "/stomp".     TestHandler testHandler = new TestHandler("/topic/foo", "payload").     this.stompClient.connect(url, testHandler).     assertTrue(testHandler.awaitForMessageCount(1, 5000)).     assertThat(testHandler.getReceived(), containsInAnyOrder("payload")). }
false;protected;1;8;;@Override protected void registerStompEndpoints(StompEndpointRegistry registry) {     // Can't rely on classpath detection     RequestUpgradeStrategy upgradeStrategy = new TomcatRequestUpgradeStrategy().     registry.addEndpoint("/stomp").setHandshakeHandler(new DefaultHandshakeHandler(upgradeStrategy)).setAllowedOrigins("*"). }
false;public;1;5;;@Override public void configureMessageBroker(MessageBrokerRegistry configurer) {     configurer.setApplicationDestinationPrefixes("/app").     configurer.enableSimpleBroker("/topic", "/queue"). }
false;public;0;3;;public List<String> getReceived() {     return this.received. }
false;public;1;4;;@Override public Type getPayloadType(StompHeaders headers) {     return String.class. }
false;public;2;4;;@Override public void handleFrame(StompHeaders headers, @Nullable Object payload) {     received.add((String) payload). }
false;public;2;22;;@Override public void afterConnected(StompSession session, StompHeaders connectedHeaders) {     session.subscribe(this.topic, new StompFrameHandler() {          @Override         public Type getPayloadType(StompHeaders headers) {             return String.class.         }          @Override         public void handleFrame(StompHeaders headers, @Nullable Object payload) {             received.add((String) payload).         }     }).     try {         // Delay send since server processes concurrently         // Ideally order should be preserved or receipts supported (simple broker)         Thread.sleep(500).     } catch (InterruptedException ex) {         logger.error(ex).     }     session.send(this.topic, this.payload). }
false;public;2;13;;public boolean awaitForMessageCount(int expected, long millisToWait) throws InterruptedException {     if (logger.isDebugEnabled()) {         logger.debug("Awaiting for message count: " + expected).     }     long startTime = System.currentTimeMillis().     while (this.received.size() < expected) {         Thread.sleep(500).         if ((System.currentTimeMillis() - startTime) > millisToWait) {             return false.         }     }     return true. }
false;public;5;6;;@Override public void handleException(StompSession session, StompCommand command, StompHeaders headers, byte[] payload, Throwable ex) {     logger.error(command + " " + headers, ex). }
false;public;2;4;;@Override public void handleFrame(StompHeaders headers, @Nullable Object payload) {     logger.error("STOMP error frame " + headers + " payload=" + payload). }
false;public;2;4;;@Override public void handleTransportError(StompSession session, Throwable exception) {     logger.error(exception). }
