commented;modifiers;parameterAmount;loc;comment;code
false;public,static;0;8;;@Parameters(name = "server [{0}], client [{1}]") public static Object[][] arguments() {     return new Object[][] { { new JettyWebSocketTestServer(), new JettyWebSocketClient() }, { new TomcatWebSocketTestServer(), new StandardWebSocketClient() }, { new UndertowTestServer(), new StandardWebSocketClient() } }. }
false;protected;0;4;;@Override protected Class<?>[] getAnnotatedConfigClasses() {     return new Class<?>[] { TestMessageBrokerConfiguration.class, TestMessageBrokerConfigurer.class }. }
false;public;0;13;;@Test public void sendMessageToController() throws Exception {     TextMessage message = create(StompCommand.SEND).headers("destination:/app/simple").build().     WebSocketSession session = doHandshake(new TestClientWebSocketHandler(0, message), "/ws").get().     SimpleController controller = this.wac.getBean(SimpleController.class).     try {         assertTrue(controller.latch.await(TIMEOUT, TimeUnit.SECONDS)).     } finally {         session.close().     } }
false;public;0;18;;@Test public void sendMessageToControllerAndReceiveReplyViaTopic() throws Exception {     TextMessage m0 = create(StompCommand.CONNECT).headers("accept-version:1.1").build().     TextMessage m1 = create(StompCommand.SUBSCRIBE).headers("id:subs1", "destination:/topic/increment").build().     TextMessage m2 = create(StompCommand.SEND).headers("destination:/app/increment").body("5").build().     TestClientWebSocketHandler clientHandler = new TestClientWebSocketHandler(2, m0, m1, m2).     WebSocketSession session = doHandshake(clientHandler, "/ws").get().     try {         assertTrue(clientHandler.latch.await(TIMEOUT, TimeUnit.SECONDS)).     } finally {         session.close().     } }
false;public;0;19;;// SPR-10930 @Test public void sendMessageToBrokerAndReceiveReplyViaTopic() throws Exception {     TextMessage m0 = create(StompCommand.CONNECT).headers("accept-version:1.1").build().     TextMessage m1 = create(StompCommand.SUBSCRIBE).headers("id:subs1", "destination:/topic/foo").build().     TextMessage m2 = create(StompCommand.SEND).headers("destination:/topic/foo").body("5").build().     TestClientWebSocketHandler clientHandler = new TestClientWebSocketHandler(2, m0, m1, m2).     WebSocketSession session = doHandshake(clientHandler, "/ws").get().     try {         assertTrue(clientHandler.latch.await(TIMEOUT, TimeUnit.SECONDS)).         String payload = clientHandler.actual.get(1).getPayload().         assertTrue("Expected STOMP MESSAGE, got " + payload, payload.startsWith("MESSAGE\n")).     } finally {         session.close().     } }
false;public;0;19;;// SPR-11648 @Test public void sendSubscribeToControllerAndReceiveReply() throws Exception {     TextMessage m0 = create(StompCommand.CONNECT).headers("accept-version:1.1").build().     String destHeader = "destination:/app/number".     TextMessage m1 = create(StompCommand.SUBSCRIBE).headers("id:subs1", destHeader).build().     TestClientWebSocketHandler clientHandler = new TestClientWebSocketHandler(2, m0, m1).     WebSocketSession session = doHandshake(clientHandler, "/ws").get().     try {         assertTrue(clientHandler.latch.await(TIMEOUT, TimeUnit.SECONDS)).         String payload = clientHandler.actual.get(1).getPayload().         assertTrue("Expected STOMP destination=/app/number, got " + payload, payload.contains(destHeader)).         assertTrue("Expected STOMP Payload=42, got " + payload, payload.contains("42")).     } finally {         session.close().     } }
false;public;0;21;;@Test public void handleExceptionAndSendToUser() throws Exception {     String destHeader = "destination:/user/queue/error".     TextMessage m0 = create(StompCommand.CONNECT).headers("accept-version:1.1").build().     TextMessage m1 = create(StompCommand.SUBSCRIBE).headers("id:subs1", destHeader).build().     TextMessage m2 = create(StompCommand.SEND).headers("destination:/app/exception").build().     TestClientWebSocketHandler clientHandler = new TestClientWebSocketHandler(2, m0, m1, m2).     WebSocketSession session = doHandshake(clientHandler, "/ws").get().     try {         assertTrue(clientHandler.latch.await(TIMEOUT, TimeUnit.SECONDS)).         String payload = clientHandler.actual.get(1).getPayload().         assertTrue(payload.startsWith("MESSAGE\n")).         assertTrue(payload.contains("destination:/user/queue/error\n")).         assertTrue(payload.endsWith("Got error: Bad input\0")).     } finally {         session.close().     } }
false;public;0;22;;@Test public void webSocketScope() throws Exception {     TextMessage m0 = create(StompCommand.CONNECT).headers("accept-version:1.1").build().     TextMessage m1 = create(StompCommand.SUBSCRIBE).headers("id:subs1", "destination:/topic/scopedBeanValue").build().     TextMessage m2 = create(StompCommand.SEND).headers("destination:/app/scopedBeanValue").build().     TestClientWebSocketHandler clientHandler = new TestClientWebSocketHandler(2, m0, m1, m2).     WebSocketSession session = doHandshake(clientHandler, "/ws").get().     try {         assertTrue(clientHandler.latch.await(TIMEOUT, TimeUnit.SECONDS)).         String payload = clientHandler.actual.get(1).getPayload().         assertTrue(payload.startsWith("MESSAGE\n")).         assertTrue(payload.contains("destination:/topic/scopedBeanValue\n")).         assertTrue(payload.endsWith("55\0")).     } finally {         session.close().     } }
false;public;0;4;;@MessageMapping("/simple") public void handle() {     this.latch.countDown(). }
false;public;0;4;;@MessageMapping("/exception") public void handleWithError() {     throw new IllegalArgumentException("Bad input"). }
false;public;1;5;;@MessageExceptionHandler @SendToUser("/queue/error") public String handleException(IllegalArgumentException ex) {     return "Got error: " + ex.getMessage(). }
false;public;1;4;;@MessageMapping("/increment") public int handle(int i) {     return i + 1. }
false;public;0;4;;@SubscribeMapping("/number") public int number() {     return 42. }
false;public;0;4;;@MessageMapping("/scopedBeanValue") public String getValue() {     return this.scopedBean.getValue(). }
false;;0;1;;String getValue().
false;public;0;4;;@Override public String getValue() {     return this.value. }
false;public;1;6;;@Override public void afterConnectionEstablished(WebSocketSession session) throws Exception {     for (TextMessage message : this.messagesToSend) {         session.sendMessage(message).     } }
false;protected;2;5;;@Override protected void handleTextMessage(WebSocketSession session, TextMessage message) throws Exception {     this.actual.add(message).     this.latch.countDown(). }
false;public;1;4;;@Override public void registerStompEndpoints(StompEndpointRegistry registry) {     registry.addEndpoint("/ws").setHandshakeHandler(this.handshakeHandler). }
false;public;1;5;;@Override public void configureMessageBroker(MessageBrokerRegistry configurer) {     configurer.setApplicationDestinationPrefixes("/app").     configurer.enableSimpleBroker("/topic", "/queue"). }
false;public;0;5;;@Bean @Scope(scopeName = "websocket", proxyMode = ScopedProxyMode.INTERFACES) public ScopedBean scopedBean() {     return new ScopedBeanImpl("55"). }
false;public;0;5;;@Override @Bean public AbstractSubscribableChannel clientInboundChannel() {     // synchronous     return new ExecutorSubscribableChannel(). }
false;public;0;5;;@Override @Bean public AbstractSubscribableChannel clientOutboundChannel() {     // synchronous     return new ExecutorSubscribableChannel(). }
