commented;modifiers;parameterAmount;loc;comment;code
false;public,static;0;4;;@BeforeClass public static void performanceTestGroupAssumption() throws Exception {     Assume.group(TestGroup.PERFORMANCE). }
false;public;0;18;;@Before public void setup() throws Exception {     logger.debug("Setting up '" + this.testName.getMethodName() + "'").     this.testFilter = new TestFilter().     this.wac = new AnnotationConfigWebApplicationContext().     this.wac.register(TestConfig.class, upgradeStrategyConfigClass()).     this.server = createWebSocketTestServer().     this.server.setup().     this.server.deployConfig(this.wac, this.testFilter).     this.server.start().     this.wac.setServletContext(this.server.getServletContext()).     this.wac.refresh().     this.baseUrl = "http://localhost:" + this.server.getPort(). }
false;public;0;27;;@After public void teardown() throws Exception {     try {         this.sockJsClient.stop().     } catch (Throwable ex) {         logger.error("Failed to stop SockJsClient", ex).     }     try {         this.server.undeployConfig().     } catch (Throwable t) {         logger.error("Failed to undeploy application config", t).     }     try {         this.server.stop().     } catch (Throwable t) {         logger.error("Failed to stop server", t).     }     try {         this.wac.close().     } catch (Throwable t) {         logger.error("Failed to close WebApplicationContext", t).     } }
false;protected,abstract;0;1;;protected abstract Class<?> upgradeStrategyConfigClass().
false;protected,abstract;0;1;;protected abstract WebSocketTestServer createWebSocketTestServer().
false;protected,abstract;0;1;;protected abstract Transport createWebSocketTransport().
false;protected,abstract;0;1;;protected abstract AbstractXhrTransport createXhrTransport().
false;protected;1;4;;protected void initSockJsClient(Transport... transports) {     this.sockJsClient = new SockJsClient(Arrays.asList(transports)).     this.sockJsClient.start(). }
false;public;0;4;;@Test public void echoWebSocket() throws Exception {     testEcho(100, createWebSocketTransport(), null). }
false;public;0;4;;@Test public void echoXhrStreaming() throws Exception {     testEcho(100, createXhrTransport(), null). }
false;public;0;6;;@Test public void echoXhr() throws Exception {     AbstractXhrTransport xhrTransport = createXhrTransport().     xhrTransport.setXhrStreamingDisabled(true).     testEcho(100, xhrTransport, null). }
false;public;0;14;;// SPR-13254 @Test public void echoXhrWithHeaders() throws Exception {     AbstractXhrTransport xhrTransport = createXhrTransport().     xhrTransport.setXhrStreamingDisabled(true).     WebSocketHttpHeaders headers = new WebSocketHttpHeaders().     headers.add("auth", "123").     testEcho(10, xhrTransport, headers).     for (Map.Entry<String, HttpHeaders> entry : this.testFilter.requests.entrySet()) {         HttpHeaders httpHeaders = entry.getValue().         assertEquals("No auth header for: " + entry.getKey(), "123", httpHeaders.getFirst("auth")).     } }
false;public;0;4;;@Test public void receiveOneMessageWebSocket() throws Exception {     testReceiveOneMessage(createWebSocketTransport(), null). }
false;public;0;4;;@Test public void receiveOneMessageXhrStreaming() throws Exception {     testReceiveOneMessage(createXhrTransport(), null). }
false;public;0;6;;@Test public void receiveOneMessageXhr() throws Exception {     AbstractXhrTransport xhrTransport = createXhrTransport().     xhrTransport.setXhrStreamingDisabled(true).     testReceiveOneMessage(xhrTransport, null). }
false;public;1;3;;@Override public void onSuccess(WebSocketSession result) { }
false;public;1;4;;@Override public void onFailure(Throwable ex) {     latch.countDown(). }
false;public;0;20;;@Test public void infoRequestFailure() throws Exception {     TestClientHandler handler = new TestClientHandler().     this.testFilter.sendErrorMap.put("/info", 500).     CountDownLatch latch = new CountDownLatch(1).     initSockJsClient(createWebSocketTransport()).     this.sockJsClient.doHandshake(handler, this.baseUrl + "/echo").addCallback(new ListenableFutureCallback<WebSocketSession>() {          @Override         public void onSuccess(WebSocketSession result) {         }          @Override         public void onFailure(Throwable ex) {             latch.countDown().         }     }).     assertTrue(latch.await(5000, TimeUnit.MILLISECONDS)). }
false;public;0;12;;@Test public void fallbackAfterTransportFailure() throws Exception {     this.testFilter.sendErrorMap.put("/websocket", 200).     this.testFilter.sendErrorMap.put("/xhr_streaming", 500).     TestClientHandler handler = new TestClientHandler().     initSockJsClient(createWebSocketTransport(), createXhrTransport()).     WebSocketSession session = this.sockJsClient.doHandshake(handler, this.baseUrl + "/echo").get().     assertEquals("Fallback didn't occur", XhrClientSockJsSession.class, session.getClass()).     TextMessage message = new TextMessage("message1").     session.sendMessage(message).     handler.awaitMessage(message, 5000). }
false;public;0;14;;@Test(timeout = 5000) public void fallbackAfterConnectTimeout() throws Exception {     TestClientHandler clientHandler = new TestClientHandler().     this.testFilter.sleepDelayMap.put("/xhr_streaming", 10000L).     this.testFilter.sendErrorMap.put("/xhr_streaming", 503).     initSockJsClient(createXhrTransport()).     this.sockJsClient.setConnectTimeoutScheduler(this.wac.getBean(ThreadPoolTaskScheduler.class)).     WebSocketSession clientSession = sockJsClient.doHandshake(clientHandler, this.baseUrl + "/echo").get().     assertEquals("Fallback didn't occur", XhrClientSockJsSession.class, clientSession.getClass()).     TextMessage message = new TextMessage("message1").     clientSession.sendMessage(message).     clientHandler.awaitMessage(message, 5000).     clientSession.close(). }
false;private;3;19;;private void testEcho(int messageCount, Transport transport, WebSocketHttpHeaders headers) throws Exception {     List<TextMessage> messages = new ArrayList<>().     for (int i = 0. i < messageCount. i++) {         messages.add(new TextMessage("m" + i)).     }     TestClientHandler handler = new TestClientHandler().     initSockJsClient(transport).     URI url = new URI(this.baseUrl + "/echo").     WebSocketSession session = this.sockJsClient.doHandshake(handler, headers, url).get().     for (TextMessage message : messages) {         session.sendMessage(message).     }     handler.awaitMessageCount(messageCount, 5000).     for (TextMessage message : messages) {         assertTrue("Message not received: " + message, handler.receivedMessages.remove(message)).     }     assertEquals("Remaining messages: " + handler.receivedMessages, 0, handler.receivedMessages.size()).     session.close(). }
false;private;2;15;;private void testReceiveOneMessage(Transport transport, WebSocketHttpHeaders headers) throws Exception {     TestClientHandler clientHandler = new TestClientHandler().     initSockJsClient(transport).     this.sockJsClient.doHandshake(clientHandler, headers, new URI(this.baseUrl + "/test")).get().     TestServerHandler serverHandler = this.wac.getBean(TestServerHandler.class).     assertNotNull("afterConnectionEstablished should have been called", clientHandler.session).     serverHandler.awaitSession(5000).     TextMessage message = new TextMessage("message1").     serverHandler.session.sendMessage(message).     clientHandler.awaitMessage(message, 5000). }
false;private,static;3;15;;private static void awaitEvent(BooleanSupplier condition, long timeToWait, String description) {     long timeToSleep = 200.     for (int i = 0. i < Math.floor(timeToWait / timeToSleep). i++) {         if (condition.getAsBoolean()) {             return.         }         try {             Thread.sleep(timeToSleep).         } catch (InterruptedException e) {             throw new IllegalStateException("Interrupted while waiting for " + description, e).         }     }     throw new IllegalStateException("Timed out waiting for " + description). }
false;public;1;6;;@Override public void registerWebSocketHandlers(WebSocketHandlerRegistry registry) {     HandshakeHandler handshakeHandler = new DefaultHandshakeHandler(this.upgradeStrategy).     registry.addHandler(new EchoHandler(), "/echo").setHandshakeHandler(handshakeHandler).withSockJS().     registry.addHandler(testServerHandler(), "/test").setHandshakeHandler(handshakeHandler).withSockJS(). }
false;public;0;4;;@Bean public TestServerHandler testServerHandler() {     return new TestServerHandler(). }
false;public;1;4;;@Override public void afterConnectionEstablished(WebSocketSession session) throws Exception {     this.session = session. }
false;protected;2;4;;@Override protected void handleTextMessage(WebSocketSession session, TextMessage message) throws Exception {     this.receivedMessages.add(message). }
false;public;2;4;;@Override public void handleTransportError(WebSocketSession session, Throwable exception) throws Exception {     this.transportError = exception. }
false;public;2;4;;public void awaitMessageCount(final int count, long timeToWait) throws Exception {     awaitEvent(() -> receivedMessages.size() >= count, timeToWait, count + " number of messages. Received so far: " + this.receivedMessages). }
false;public;2;12;;public void awaitMessage(TextMessage expected, long timeToWait) throws InterruptedException {     TextMessage actual = this.receivedMessages.poll(timeToWait, TimeUnit.MILLISECONDS).     if (actual != null) {         assertEquals(expected, actual).     } else if (this.transportError != null) {         throw new AssertionError("Transport error", this.transportError).     } else {         fail("Timed out waiting for [" + expected + "]").     } }
false;protected;2;4;;@Override protected void handleTextMessage(WebSocketSession session, TextMessage message) throws Exception {     session.sendMessage(message). }
false;public;1;4;;@Override public void afterConnectionEstablished(WebSocketSession session) throws Exception {     this.session = session. }
false;public;1;4;;public WebSocketSession awaitSession(long timeToWait) throws InterruptedException {     awaitEvent(() -> this.session != null, timeToWait, " session").     return this.session. }
false;public;3;28;;@Override public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain) throws IOException, ServletException {     HttpServletRequest httpRequest = (HttpServletRequest) request.     String uri = httpRequest.getRequestURI().     HttpHeaders headers = new ServletServerHttpRequest(httpRequest).getHeaders().     this.requests.put(uri, headers).     for (String suffix : this.sleepDelayMap.keySet()) {         if ((httpRequest).getRequestURI().endsWith(suffix)) {             try {                 Thread.sleep(this.sleepDelayMap.get(suffix)).                 break.             } catch (InterruptedException e) {                 e.printStackTrace().             }         }     }     for (String suffix : this.sendErrorMap.keySet()) {         if ((httpRequest).getRequestURI().endsWith(suffix)) {             ((HttpServletResponse) response).sendError(this.sendErrorMap.get(suffix)).             return.         }     }     chain.doFilter(request, response). }
false;public;1;3;;@Override public void init(FilterConfig filterConfig) { }
false;public;0;3;;@Override public void destroy() { }
