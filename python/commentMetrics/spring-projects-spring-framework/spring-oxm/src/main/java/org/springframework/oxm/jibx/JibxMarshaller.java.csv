commented;modifiers;parameterAmount;loc;comment;code
true;public;1;3;/**  * Set the target class for this instance. Setting either this property or the  * {@link #setTargetPackage(String) targetPackage} property is required.  * <p>If this property is set, {@link #setTargetPackage(String) targetPackage} is ignored.  */ ;/**  * Set the target class for this instance. Setting either this property or the  * {@link #setTargetPackage(String) targetPackage} property is required.  * <p>If this property is set, {@link #setTargetPackage(String) targetPackage} is ignored.  */ public void setTargetClass(Class<?> targetClass) {     this.targetClass = targetClass. }
true;public;1;3;/**  * Set the target package for this instance. Setting either this property or the  * {@link #setTargetClass(Class) targetClass} property is required.  * <p>If {@link #setTargetClass(Class) targetClass} is set, this property is ignored.  */ ;/**  * Set the target package for this instance. Setting either this property or the  * {@link #setTargetClass(Class) targetClass} property is required.  * <p>If {@link #setTargetClass(Class) targetClass} is set, this property is ignored.  */ public void setTargetPackage(String targetPackage) {     this.targetPackage = targetPackage. }
true;public;1;3;/**  * Set the optional binding name for this instance.  */ ;/**  * Set the optional binding name for this instance.  */ public void setBindingName(String bindingName) {     this.bindingName = bindingName. }
true;public;1;3;/**  * Set the number of nesting indent spaces. Default is {@code -1}, i.e. no indentation.  */ ;/**  * Set the number of nesting indent spaces. Default is {@code -1}, i.e. no indentation.  */ public void setIndent(int indent) {     this.indent = indent. }
true;public;1;3;/**  * Set the document encoding using for marshalling. Default is UTF-8.  */ ;/**  * Set the document encoding using for marshalling. Default is UTF-8.  */ public void setEncoding(String encoding) {     this.encoding = encoding. }
false;protected;0;4;;@Override protected String getDefaultEncoding() {     return this.encoding. }
true;public;1;3;/**  * Set the document standalone flag for marshalling. By default, this flag is not present.  */ ;/**  * Set the document standalone flag for marshalling. By default, this flag is not present.  */ public void setStandalone(Boolean standalone) {     this.standalone = standalone. }
true;public;1;3;/**  * Set the root element name for the DTD declaration written when marshalling.  * By default, this is {@code null} (i.e. no DTD declaration is written).  * <p>If set to a value, the system ID or public ID also need to be set.  * @see #setDocTypeSystemId(String)  * @see #setDocTypePublicId(String)  */ ;/**  * Set the root element name for the DTD declaration written when marshalling.  * By default, this is {@code null} (i.e. no DTD declaration is written).  * <p>If set to a value, the system ID or public ID also need to be set.  * @see #setDocTypeSystemId(String)  * @see #setDocTypePublicId(String)  */ public void setDocTypeRootElementName(String docTypeRootElementName) {     this.docTypeRootElementName = docTypeRootElementName. }
true;public;1;3;/**  * Set the system id for the DTD declaration written when marshalling.  * By default, this is {@code null}. Only used when the root element also has been set.  * <p>Set either this property or {@code docTypePublicId}, not both.  * @see #setDocTypeRootElementName(String)  */ ;/**  * Set the system id for the DTD declaration written when marshalling.  * By default, this is {@code null}. Only used when the root element also has been set.  * <p>Set either this property or {@code docTypePublicId}, not both.  * @see #setDocTypeRootElementName(String)  */ public void setDocTypeSystemId(String docTypeSystemId) {     this.docTypeSystemId = docTypeSystemId. }
true;public;1;3;/**  * Set the public id for the DTD declaration written when marshalling.  * By default, this is {@code null}. Only used when the root element also has been set.  * <p>Set either this property or {@code docTypeSystemId}, not both.  * @see #setDocTypeRootElementName(String)  */ ;/**  * Set the public id for the DTD declaration written when marshalling.  * By default, this is {@code null}. Only used when the root element also has been set.  * <p>Set either this property or {@code docTypeSystemId}, not both.  * @see #setDocTypeRootElementName(String)  */ public void setDocTypePublicId(String docTypePublicId) {     this.docTypePublicId = docTypePublicId. }
true;public;1;3;/**  * Set the internal subset Id for the DTD declaration written when marshalling.  * By default, this is {@code null}. Only used when the root element also has been set.  * @see #setDocTypeRootElementName(String)  */ ;/**  * Set the internal subset Id for the DTD declaration written when marshalling.  * By default, this is {@code null}. Only used when the root element also has been set.  * @see #setDocTypeRootElementName(String)  */ public void setDocTypeInternalSubset(String docTypeInternalSubset) {     this.docTypeInternalSubset = docTypeInternalSubset. }
false;public;0;31;;@Override public void afterPropertiesSet() throws JiBXException {     if (this.targetClass != null) {         if (StringUtils.hasLength(this.bindingName)) {             if (logger.isDebugEnabled()) {                 logger.debug("Configured for target class [" + this.targetClass + "] using binding [" + this.bindingName + "]").             }             this.bindingFactory = BindingDirectory.getFactory(this.bindingName, this.targetClass).         } else {             if (logger.isDebugEnabled()) {                 logger.debug("Configured for target class [" + this.targetClass + "]").             }             this.bindingFactory = BindingDirectory.getFactory(this.targetClass).         }     } else if (this.targetPackage != null) {         if (!StringUtils.hasLength(this.bindingName)) {             this.bindingName = DEFAULT_BINDING_NAME.         }         if (logger.isDebugEnabled()) {             logger.debug("Configured for target package [" + this.targetPackage + "] using binding [" + this.bindingName + "]").         }         this.bindingFactory = BindingDirectory.getFactory(this.bindingName, this.targetPackage).     } else {         throw new IllegalArgumentException("Either 'targetClass' or 'targetPackage' is required").     } }
false;public;1;16;;@Override public boolean supports(Class<?> clazz) {     Assert.notNull(clazz, "Class must not be null").     if (this.targetClass != null) {         return (this.targetClass == clazz).     }     Assert.state(this.bindingFactory != null, "JibxMarshaller not initialized").     String[] mappedClasses = this.bindingFactory.getMappedClasses().     String className = clazz.getName().     for (String mappedClass : mappedClasses) {         if (className.equals(mappedClass)) {             return true.         }     }     return false. }
false;protected;2;12;;// Supported marshalling @Override protected void marshalOutputStream(Object graph, OutputStream outputStream) throws XmlMappingException, IOException {     try {         IMarshallingContext marshallingContext = createMarshallingContext().         marshallingContext.startDocument(this.encoding, this.standalone, outputStream).         marshalDocument(marshallingContext, graph).     } catch (JiBXException ex) {         throw convertJibxException(ex, true).     } }
false;protected;2;11;;@Override protected void marshalWriter(Object graph, Writer writer) throws XmlMappingException, IOException {     try {         IMarshallingContext marshallingContext = createMarshallingContext().         marshallingContext.startDocument(this.encoding, this.standalone, writer).         marshalDocument(marshallingContext, graph).     } catch (JiBXException ex) {         throw convertJibxException(ex, true).     } }
false;private;2;8;;private void marshalDocument(IMarshallingContext marshallingContext, Object graph) throws IOException, JiBXException {     if (StringUtils.hasLength(this.docTypeRootElementName)) {         IXMLWriter xmlWriter = marshallingContext.getXmlWriter().         xmlWriter.writeDocType(this.docTypeRootElementName, this.docTypeSystemId, this.docTypePublicId, this.docTypeInternalSubset).     }     marshallingContext.marshalDocument(graph). }
false;protected;2;11;;// Unsupported marshalling @Override protected void marshalDomNode(Object graph, Node node) throws XmlMappingException {     try {         // JiBX does not support DOM natively, so we write to a buffer first, and transform that to the Node         Result result = new DOMResult(node).         transformAndMarshal(graph, result).     } catch (IOException ex) {         throw new MarshallingFailureException("JiBX marshalling exception", ex).     } }
false;protected;2;5;;@Override protected void marshalXmlEventWriter(Object graph, XMLEventWriter eventWriter) {     XMLStreamWriter streamWriter = StaxUtils.createEventStreamWriter(eventWriter).     marshalXmlStreamWriter(graph, streamWriter). }
false;protected;2;12;;@Override protected void marshalXmlStreamWriter(Object graph, XMLStreamWriter streamWriter) throws XmlMappingException {     try {         MarshallingContext marshallingContext = (MarshallingContext) createMarshallingContext().         IXMLWriter xmlWriter = new StAXWriter(marshallingContext.getNamespaces(), streamWriter).         marshallingContext.setXmlWriter(xmlWriter).         marshallingContext.marshalDocument(graph).     } catch (JiBXException ex) {         throw convertJibxException(ex, false).     } }
false;protected;3;13;;@Override protected void marshalSaxHandlers(Object graph, ContentHandler contentHandler, @Nullable LexicalHandler lexicalHandler) throws XmlMappingException {     try {         // JiBX does not support SAX natively, so we write to a buffer first, and transform that to the handlers         SAXResult saxResult = new SAXResult(contentHandler).         saxResult.setLexicalHandler(lexicalHandler).         transformAndMarshal(graph, saxResult).     } catch (IOException ex) {         throw new MarshallingFailureException("JiBX marshalling exception", ex).     } }
false;private;2;14;;private void transformAndMarshal(Object graph, Result result) throws IOException {     try {         ByteArrayOutputStream os = new ByteArrayOutputStream(1024).         marshalOutputStream(graph, os).         ByteArrayInputStream is = new ByteArrayInputStream(os.toByteArray()).         Transformer transformer = this.transformerFactory.newTransformer().         transformer.transform(new StreamSource(is), result).     } catch (TransformerException ex) {         throw new MarshallingFailureException("Could not transform to [" + ClassUtils.getShortName(result.getClass()) + "]", ex).     } }
false;protected;1;10;;// Unmarshalling @Override protected Object unmarshalXmlEventReader(XMLEventReader eventReader) {     try {         XMLStreamReader streamReader = StaxUtils.createEventStreamReader(eventReader).         return unmarshalXmlStreamReader(streamReader).     } catch (XMLStreamException ex) {         return new UnmarshallingFailureException("JiBX unmarshalling exception", ex).     } }
false;protected;1;12;;@Override protected Object unmarshalXmlStreamReader(XMLStreamReader streamReader) {     try {         UnmarshallingContext unmarshallingContext = (UnmarshallingContext) createUnmarshallingContext().         IXMLReader xmlReader = new StAXReaderWrapper(streamReader, null, true).         unmarshallingContext.setDocument(xmlReader).         return unmarshallingContext.unmarshalElement().     } catch (JiBXException ex) {         throw convertJibxException(ex, false).     } }
false;protected;1;10;;@Override protected Object unmarshalInputStream(InputStream inputStream) throws XmlMappingException, IOException {     try {         IUnmarshallingContext unmarshallingContext = createUnmarshallingContext().         return unmarshallingContext.unmarshalDocument(inputStream, this.encoding).     } catch (JiBXException ex) {         throw convertJibxException(ex, false).     } }
false;protected;1;10;;@Override protected Object unmarshalReader(Reader reader) throws XmlMappingException, IOException {     try {         IUnmarshallingContext unmarshallingContext = createUnmarshallingContext().         return unmarshallingContext.unmarshalDocument(reader).     } catch (JiBXException ex) {         throw convertJibxException(ex, false).     } }
false;protected;1;9;;// Unsupported Unmarshalling @Override protected Object unmarshalDomNode(Node node) throws XmlMappingException {     try {         return transformAndUnmarshal(new DOMSource(node), null).     } catch (IOException ex) {         throw new UnmarshallingFailureException("JiBX unmarshalling exception", ex).     } }
false;protected;2;6;;@Override protected Object unmarshalSaxReader(XMLReader xmlReader, InputSource inputSource) throws XmlMappingException, IOException {     return transformAndUnmarshal(new SAXSource(xmlReader, inputSource), inputSource.getEncoding()). }
false;private;2;16;;private Object transformAndUnmarshal(Source source, @Nullable String encoding) throws IOException {     try {         Transformer transformer = this.transformerFactory.newTransformer().         if (encoding != null) {             transformer.setOutputProperty(OutputKeys.ENCODING, encoding).         }         ByteArrayOutputStream os = new ByteArrayOutputStream(1024).         transformer.transform(source, new StreamResult(os)).         ByteArrayInputStream is = new ByteArrayInputStream(os.toByteArray()).         return unmarshalInputStream(is).     } catch (TransformerException ex) {         throw new MarshallingFailureException("Could not transform from [" + ClassUtils.getShortName(source.getClass()) + "]", ex).     } }
true;protected;0;6;/**  * Create a new {@code IMarshallingContext}, configured with the correct indentation.  * @return the created marshalling context  * @throws JiBXException in case of errors  */ ;/**  * Create a new {@code IMarshallingContext}, configured with the correct indentation.  * @return the created marshalling context  * @throws JiBXException in case of errors  */ protected IMarshallingContext createMarshallingContext() throws JiBXException {     Assert.state(this.bindingFactory != null, "JibxMarshaller not initialized").     IMarshallingContext marshallingContext = this.bindingFactory.createMarshallingContext().     marshallingContext.setIndent(this.indent).     return marshallingContext. }
true;protected;0;4;/**  * Create a new {@code IUnmarshallingContext}.  * @return the created unmarshalling context  * @throws JiBXException in case of errors  */ ;/**  * Create a new {@code IUnmarshallingContext}.  * @return the created unmarshalling context  * @throws JiBXException in case of errors  */ protected IUnmarshallingContext createUnmarshallingContext() throws JiBXException {     Assert.state(this.bindingFactory != null, "JibxMarshaller not initialized").     return this.bindingFactory.createUnmarshallingContext(). }
true;public;2;13;/**  * Convert the given {@code JiBXException} to an appropriate exception from the  * {@code org.springframework.oxm} hierarchy.  * <p>A boolean flag is used to indicate whether this exception occurs during marshalling or  * unmarshalling, since JiBX itself does not make this distinction in its exception hierarchy.  * @param ex {@code JiBXException} that occurred  * @param marshalling indicates whether the exception occurs during marshalling ({@code true}),  * or unmarshalling ({@code false})  * @return the corresponding {@code XmlMappingException}  */ ;/**  * Convert the given {@code JiBXException} to an appropriate exception from the  * {@code org.springframework.oxm} hierarchy.  * <p>A boolean flag is used to indicate whether this exception occurs during marshalling or  * unmarshalling, since JiBX itself does not make this distinction in its exception hierarchy.  * @param ex {@code JiBXException} that occurred  * @param marshalling indicates whether the exception occurs during marshalling ({@code true}),  * or unmarshalling ({@code false})  * @return the corresponding {@code XmlMappingException}  */ public XmlMappingException convertJibxException(JiBXException ex, boolean marshalling) {     if (ex instanceof ValidationException) {         return new ValidationFailureException("JiBX validation exception", ex).     } else {         if (marshalling) {             return new MarshallingFailureException("JiBX marshalling exception", ex).         } else {             return new UnmarshallingFailureException("JiBX unmarshalling exception", ex).         }     } }
