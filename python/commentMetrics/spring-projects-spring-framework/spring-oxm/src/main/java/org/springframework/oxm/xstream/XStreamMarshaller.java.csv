commented;modifiers;parameterAmount;loc;comment;code
true;public;1;3;/**  * Set a custom XStream {@link ReflectionProvider} to use.  * @since 4.0  */ ;/**  * Set a custom XStream {@link ReflectionProvider} to use.  * @since 4.0  */ public void setReflectionProvider(ReflectionProvider reflectionProvider) {     this.reflectionProvider = reflectionProvider. }
true;public;1;4;/**  * Set a XStream {@link HierarchicalStreamDriver} to be used for readers and writers.  * <p>As of Spring 4.0, this stream driver will also be passed to the {@link XStream}  * constructor and therefore used by streaming-related native API methods themselves.  */ ;/**  * Set a XStream {@link HierarchicalStreamDriver} to be used for readers and writers.  * <p>As of Spring 4.0, this stream driver will also be passed to the {@link XStream}  * constructor and therefore used by streaming-related native API methods themselves.  */ public void setStreamDriver(HierarchicalStreamDriver streamDriver) {     this.streamDriver = streamDriver.     this.defaultDriver = streamDriver. }
false;private;0;6;;private HierarchicalStreamDriver getDefaultDriver() {     if (this.defaultDriver == null) {         this.defaultDriver = new XppDriver().     }     return this.defaultDriver. }
true;public;1;3;/**  * Set a custom XStream {@link Mapper} to use.  * @since 4.0  */ ;/**  * Set a custom XStream {@link Mapper} to use.  * @since 4.0  */ public void setMapper(Mapper mapper) {     this.mapper = mapper. }
true;public;1;4;/**  * Set one or more custom XStream {@link MapperWrapper} classes.  * Each of those classes needs to have a constructor with a single argument  * of type {@link Mapper} or {@link MapperWrapper}.  * @since 4.0  */ ;/**  * Set one or more custom XStream {@link MapperWrapper} classes.  * Each of those classes needs to have a constructor with a single argument  * of type {@link Mapper} or {@link MapperWrapper}.  * @since 4.0  */ @SuppressWarnings("unchecked") public void setMapperWrappers(Class<? extends MapperWrapper>... mapperWrappers) {     this.mapperWrappers = mapperWrappers. }
true;public;1;6;/**  * Set a custom XStream {@link ConverterLookup} to use.  * Also used as {@link ConverterRegistry} if the given reference implements it as well.  * @since 4.0  * @see DefaultConverterLookup  */ ;/**  * Set a custom XStream {@link ConverterLookup} to use.  * Also used as {@link ConverterRegistry} if the given reference implements it as well.  * @since 4.0  * @see DefaultConverterLookup  */ public void setConverterLookup(ConverterLookup converterLookup) {     this.converterLookup = converterLookup.     if (converterLookup instanceof ConverterRegistry) {         this.converterRegistry = (ConverterRegistry) converterLookup.     } }
true;public;1;3;/**  * Set a custom XStream {@link ConverterRegistry} to use.  * @since 4.0  * @see #setConverterLookup  * @see DefaultConverterLookup  */ ;/**  * Set a custom XStream {@link ConverterRegistry} to use.  * @since 4.0  * @see #setConverterLookup  * @see DefaultConverterLookup  */ public void setConverterRegistry(ConverterRegistry converterRegistry) {     this.converterRegistry = converterRegistry. }
true;public;1;3;/**  * Set the {@code Converters} or {@code SingleValueConverters} to be registered  * with the {@code XStream} instance.  * @see Converter  * @see SingleValueConverter  */ ;/**  * Set the {@code Converters} or {@code SingleValueConverters} to be registered  * with the {@code XStream} instance.  * @see Converter  * @see SingleValueConverter  */ public void setConverters(ConverterMatcher... converters) {     this.converters = converters. }
true;public;1;3;/**  * Set a custom XStream {@link MarshallingStrategy} to use.  * @since 4.0  */ ;/**  * Set a custom XStream {@link MarshallingStrategy} to use.  * @since 4.0  */ public void setMarshallingStrategy(MarshallingStrategy marshallingStrategy) {     this.marshallingStrategy = marshallingStrategy. }
true;public;1;3;/**  * Set the XStream mode to use.  * @see XStream#ID_REFERENCES  * @see XStream#NO_REFERENCES  */ ;/**  * Set the XStream mode to use.  * @see XStream#ID_REFERENCES  * @see XStream#NO_REFERENCES  */ public void setMode(int mode) {     this.mode = mode. }
true;public;1;3;/**  * Set the alias/type map, consisting of string aliases mapped to classes.  * <p>Keys are aliases. values are either {@code Class} instances, or String class names.  * @see XStream#alias(String, Class)  */ ;/**  * Set the alias/type map, consisting of string aliases mapped to classes.  * <p>Keys are aliases. values are either {@code Class} instances, or String class names.  * @see XStream#alias(String, Class)  */ public void setAliases(Map<String, ?> aliases) {     this.aliases = aliases. }
true;public;1;3;/**  * Set the <em>aliases by type</em> map, consisting of string aliases mapped to classes.  * <p>Any class that is assignable to this type will be aliased to the same name.  * Keys are aliases. values are either {@code Class} instances, or String class names.  * @see XStream#aliasType(String, Class)  */ ;/**  * Set the <em>aliases by type</em> map, consisting of string aliases mapped to classes.  * <p>Any class that is assignable to this type will be aliased to the same name.  * Keys are aliases. values are either {@code Class} instances, or String class names.  * @see XStream#aliasType(String, Class)  */ public void setAliasesByType(Map<String, ?> aliasesByType) {     this.aliasesByType = aliasesByType. }
true;public;1;3;/**  * Set the field alias/type map, consisting of field names.  * @see XStream#aliasField(String, Class, String)  */ ;/**  * Set the field alias/type map, consisting of field names.  * @see XStream#aliasField(String, Class, String)  */ public void setFieldAliases(Map<String, String> fieldAliases) {     this.fieldAliases = fieldAliases. }
true;public;1;3;/**  * Set types to use XML attributes for.  * @see XStream#useAttributeFor(Class)  */ ;/**  * Set types to use XML attributes for.  * @see XStream#useAttributeFor(Class)  */ public void setUseAttributeForTypes(Class<?>... useAttributeForTypes) {     this.useAttributeForTypes = useAttributeForTypes. }
true;public;1;3;/**  * Set the types to use XML attributes for. The given map can contain  * either {@code <String, Class>} pairs, in which case  * {@link XStream#useAttributeFor(String, Class)} is called.  * Alternatively, the map can contain {@code <Class, String>}  * or {@code <Class, List<String>>} pairs, which results  * in {@link XStream#useAttributeFor(Class, String)} calls.  */ ;/**  * Set the types to use XML attributes for. The given map can contain  * either {@code <String, Class>} pairs, in which case  * {@link XStream#useAttributeFor(String, Class)} is called.  * Alternatively, the map can contain {@code <Class, String>}  * or {@code <Class, List<String>>} pairs, which results  * in {@link XStream#useAttributeFor(Class, String)} calls.  */ public void setUseAttributeFor(Map<?, ?> useAttributeFor) {     this.useAttributeFor = useAttributeFor. }
true;public;1;3;/**  * Specify implicit collection fields, as a Map consisting of {@code Class} instances  * mapped to comma separated collection field names.  * @see XStream#addImplicitCollection(Class, String)  */ ;/**  * Specify implicit collection fields, as a Map consisting of {@code Class} instances  * mapped to comma separated collection field names.  * @see XStream#addImplicitCollection(Class, String)  */ public void setImplicitCollections(Map<Class<?>, String> implicitCollections) {     this.implicitCollections = implicitCollections. }
true;public;1;3;/**  * Specify omitted fields, as a Map consisting of {@code Class} instances  * mapped to comma separated field names.  * @see XStream#omitField(Class, String)  */ ;/**  * Specify omitted fields, as a Map consisting of {@code Class} instances  * mapped to comma separated field names.  * @see XStream#omitField(Class, String)  */ public void setOmittedFields(Map<Class<?>, String> omittedFields) {     this.omittedFields = omittedFields. }
true;public;1;3;/**  * Set annotated classes for which aliases will be read from class-level annotation metadata.  * @see XStream#processAnnotations(Class[])  */ ;/**  * Set annotated classes for which aliases will be read from class-level annotation metadata.  * @see XStream#processAnnotations(Class[])  */ public void setAnnotatedClasses(Class<?>... annotatedClasses) {     this.annotatedClasses = annotatedClasses. }
true;public;1;3;/**  * Activate XStream's autodetection mode.  * <p><b>Note</b>: Autodetection implies that the XStream instance is being configured while  * it is processing the XML streams, and thus introduces a potential concurrency problem.  * @see XStream#autodetectAnnotations(boolean)  */ ;/**  * Activate XStream's autodetection mode.  * <p><b>Note</b>: Autodetection implies that the XStream instance is being configured while  * it is processing the XML streams, and thus introduces a potential concurrency problem.  * @see XStream#autodetectAnnotations(boolean)  */ public void setAutodetectAnnotations(boolean autodetectAnnotations) {     this.autodetectAnnotations = autodetectAnnotations. }
true;public;1;3;/**  * Set the encoding to be used for stream access.  * @see #DEFAULT_ENCODING  */ ;/**  * Set the encoding to be used for stream access.  * @see #DEFAULT_ENCODING  */ public void setEncoding(String encoding) {     this.encoding = encoding. }
false;protected;0;4;;@Override protected String getDefaultEncoding() {     return this.encoding. }
true;public;1;3;/**  * Set a custom XStream {@link NameCoder} to use.  * The default is an {@link XmlFriendlyNameCoder}.  * @since 4.0.4  */ ;/**  * Set a custom XStream {@link NameCoder} to use.  * The default is an {@link XmlFriendlyNameCoder}.  * @since 4.0.4  */ public void setNameCoder(NameCoder nameCoder) {     this.nameCoder = nameCoder. }
true;public;1;3;/**  * Set the classes supported by this marshaller.  * <p>If this property is empty (the default), all classes are supported.  * @see #supports(Class)  */ ;/**  * Set the classes supported by this marshaller.  * <p>If this property is empty (the default), all classes are supported.  * @see #supports(Class)  */ public void setSupportedClasses(Class<?>... supportedClasses) {     this.supportedClasses = supportedClasses. }
false;public;1;4;;@Override public void setBeanClassLoader(ClassLoader classLoader) {     this.beanClassLoader = classLoader. }
false;public;0;4;;@Override public void afterPropertiesSet() {     this.xstream = buildXStream(). }
true;protected;0;6;/**  * Build the native XStream delegate to be used by this marshaller,  * delegating to {@link #constructXStream()}, {@link #configureXStream}  * and {@link #customizeXStream}.  */ ;/**  * Build the native XStream delegate to be used by this marshaller,  * delegating to {@link #constructXStream()}, {@link #configureXStream}  * and {@link #customizeXStream}.  */ protected XStream buildXStream() {     XStream xstream = constructXStream().     configureXStream(xstream).     customizeXStream(xstream).     return xstream. }
false;protected;1;27;;@Override protected MapperWrapper wrapMapper(MapperWrapper next) {     MapperWrapper mapperToWrap = next.     if (mapperWrappers != null) {         for (Class<? extends MapperWrapper> mapperWrapper : mapperWrappers) {             Constructor<? extends MapperWrapper> ctor.             try {                 ctor = mapperWrapper.getConstructor(Mapper.class).             } catch (NoSuchMethodException ex) {                 try {                     ctor = mapperWrapper.getConstructor(MapperWrapper.class).                 } catch (NoSuchMethodException ex2) {                     throw new IllegalStateException("No appropriate MapperWrapper constructor found: " + mapperWrapper).                 }             }             try {                 mapperToWrap = ctor.newInstance(mapperToWrap).             } catch (Throwable ex) {                 throw new IllegalStateException("Failed to construct MapperWrapper: " + mapperWrapper).             }         }     }     return mapperToWrap. }
true;protected;0;32;/**  * Construct an XStream instance, either using one of the  * standard constructors or creating a custom subclass.  * @return the {@code XStream} instance  */ ;/**  * Construct an XStream instance, either using one of the  * standard constructors or creating a custom subclass.  * @return the {@code XStream} instance  */ protected XStream constructXStream() {     return new XStream(this.reflectionProvider, getDefaultDriver(), new ClassLoaderReference(this.beanClassLoader), this.mapper, this.converterLookup, this.converterRegistry) {          @Override         protected MapperWrapper wrapMapper(MapperWrapper next) {             MapperWrapper mapperToWrap = next.             if (mapperWrappers != null) {                 for (Class<? extends MapperWrapper> mapperWrapper : mapperWrappers) {                     Constructor<? extends MapperWrapper> ctor.                     try {                         ctor = mapperWrapper.getConstructor(Mapper.class).                     } catch (NoSuchMethodException ex) {                         try {                             ctor = mapperWrapper.getConstructor(MapperWrapper.class).                         } catch (NoSuchMethodException ex2) {                             throw new IllegalStateException("No appropriate MapperWrapper constructor found: " + mapperWrapper).                         }                     }                     try {                         mapperToWrap = ctor.newInstance(mapperToWrap).                     } catch (Throwable ex) {                         throw new IllegalStateException("Failed to construct MapperWrapper: " + mapperWrapper).                     }                 }             }             return mapperToWrap.         }     }. }
true;protected;1;118;/**  * Configure the XStream instance with this marshaller's bean properties.  * @param xstream the {@code XStream} instance  */ ;/**  * Configure the XStream instance with this marshaller's bean properties.  * @param xstream the {@code XStream} instance  */ protected void configureXStream(XStream xstream) {     if (this.converters != null) {         for (int i = 0. i < this.converters.length. i++) {             if (this.converters[i] instanceof Converter) {                 xstream.registerConverter((Converter) this.converters[i], i).             } else if (this.converters[i] instanceof SingleValueConverter) {                 xstream.registerConverter((SingleValueConverter) this.converters[i], i).             } else {                 throw new IllegalArgumentException("Invalid ConverterMatcher [" + this.converters[i] + "]").             }         }     }     if (this.marshallingStrategy != null) {         xstream.setMarshallingStrategy(this.marshallingStrategy).     }     if (this.mode != null) {         xstream.setMode(this.mode).     }     try {         if (this.aliases != null) {             Map<String, Class<?>> classMap = toClassMap(this.aliases).             classMap.forEach(xstream::alias).         }         if (this.aliasesByType != null) {             Map<String, Class<?>> classMap = toClassMap(this.aliasesByType).             classMap.forEach(xstream::aliasType).         }         if (this.fieldAliases != null) {             for (Map.Entry<String, String> entry : this.fieldAliases.entrySet()) {                 String alias = entry.getValue().                 String field = entry.getKey().                 int idx = field.lastIndexOf('.').                 if (idx != -1) {                     String className = field.substring(0, idx).                     Class<?> clazz = ClassUtils.forName(className, this.beanClassLoader).                     String fieldName = field.substring(idx + 1).                     xstream.aliasField(alias, clazz, fieldName).                 } else {                     throw new IllegalArgumentException("Field name [" + field + "] does not contain '.'").                 }             }         }     } catch (ClassNotFoundException ex) {         throw new IllegalStateException("Failed to load specified alias class", ex).     }     if (this.useAttributeForTypes != null) {         for (Class<?> type : this.useAttributeForTypes) {             xstream.useAttributeFor(type).         }     }     if (this.useAttributeFor != null) {         for (Map.Entry<?, ?> entry : this.useAttributeFor.entrySet()) {             if (entry.getKey() instanceof String) {                 if (entry.getValue() instanceof Class) {                     xstream.useAttributeFor((String) entry.getKey(), (Class<?>) entry.getValue()).                 } else {                     throw new IllegalArgumentException("'useAttributesFor' takes Map<String, Class> when using a map key of type String").                 }             } else if (entry.getKey() instanceof Class) {                 Class<?> key = (Class<?>) entry.getKey().                 if (entry.getValue() instanceof String) {                     xstream.useAttributeFor(key, (String) entry.getValue()).                 } else if (entry.getValue() instanceof List) {                     @SuppressWarnings("unchecked")                     List<Object> listValue = (List<Object>) entry.getValue().                     for (Object element : listValue) {                         if (element instanceof String) {                             xstream.useAttributeFor(key, (String) element).                         }                     }                 } else {                     throw new IllegalArgumentException("'useAttributesFor' property takes either Map<Class, String> " + "or Map<Class, List<String>> when using a map key of type Class").                 }             } else {                 throw new IllegalArgumentException("'useAttributesFor' property takes either a map key of type String or Class").             }         }     }     if (this.implicitCollections != null) {         this.implicitCollections.forEach((key, fields) -> {             String[] collectionFields = StringUtils.commaDelimitedListToStringArray(fields).             for (String collectionField : collectionFields) {                 xstream.addImplicitCollection(key, collectionField).             }         }).     }     if (this.omittedFields != null) {         this.omittedFields.forEach((key, value) -> {             String[] fields = StringUtils.commaDelimitedListToStringArray(value).             for (String field : fields) {                 xstream.omitField(key, field).             }         }).     }     if (this.annotatedClasses != null) {         xstream.processAnnotations(this.annotatedClasses).     }     if (this.autodetectAnnotations) {         xstream.autodetectAnnotations(true).     } }
false;private;1;20;;private Map<String, Class<?>> toClassMap(Map<String, ?> map) throws ClassNotFoundException {     Map<String, Class<?>> result = new LinkedHashMap<>(map.size()).     for (Map.Entry<String, ?> entry : map.entrySet()) {         String key = entry.getKey().         Object value = entry.getValue().         Class<?> type.         if (value instanceof Class) {             type = (Class<?>) value.         } else if (value instanceof String) {             String className = (String) value.             type = ClassUtils.forName(className, this.beanClassLoader).         } else {             throw new IllegalArgumentException("Unknown value [" + value + "] - expected String or Class").         }         result.put(key, type).     }     return result. }
true;protected;1;2;/**  * Template to allow for customizing the given {@link XStream}.  * <p>The default implementation is empty.  * @param xstream the {@code XStream} instance  */ ;/**  * Template to allow for customizing the given {@link XStream}.  * <p>The default implementation is empty.  * @param xstream the {@code XStream} instance  */ protected void customizeXStream(XStream xstream) { }
true;public,final;0;6;/**  * Return the native XStream delegate used by this marshaller.  * <p><b>NOTE: This method has been marked as final as of Spring 4.0.</b>  * It can be used to access the fully configured XStream for marshalling  * but not configuration purposes anymore.  */ ;/**  * Return the native XStream delegate used by this marshaller.  * <p><b>NOTE: This method has been marked as final as of Spring 4.0.</b>  * It can be used to access the fully configured XStream for marshalling  * but not configuration purposes anymore.  */ public final XStream getXStream() {     if (this.xstream == null) {         this.xstream = buildXStream().     }     return this.xstream. }
false;public;1;14;;@Override public boolean supports(Class<?> clazz) {     if (ObjectUtils.isEmpty(this.supportedClasses)) {         return true.     } else {         for (Class<?> supportedClass : this.supportedClasses) {             if (supportedClass.isAssignableFrom(clazz)) {                 return true.             }         }         return false.     } }
false;protected;2;14;;// Marshalling @Override protected void marshalDomNode(Object graph, Node node) throws XmlMappingException {     HierarchicalStreamWriter streamWriter.     if (node instanceof Document) {         streamWriter = new DomWriter((Document) node, this.nameCoder).     } else if (node instanceof Element) {         streamWriter = new DomWriter((Element) node, node.getOwnerDocument(), this.nameCoder).     } else {         throw new IllegalArgumentException("DOMResult contains neither Document nor Element").     }     doMarshal(graph, streamWriter, null). }
false;protected;2;9;;@Override protected void marshalXmlEventWriter(Object graph, XMLEventWriter eventWriter) throws XmlMappingException {     ContentHandler contentHandler = StaxUtils.createContentHandler(eventWriter).     LexicalHandler lexicalHandler = null.     if (contentHandler instanceof LexicalHandler) {         lexicalHandler = (LexicalHandler) contentHandler.     }     marshalSaxHandlers(graph, contentHandler, lexicalHandler). }
false;protected;2;9;;@Override protected void marshalXmlStreamWriter(Object graph, XMLStreamWriter streamWriter) throws XmlMappingException {     try {         doMarshal(graph, new StaxWriter(new QNameMap(), streamWriter, this.nameCoder), null).     } catch (XMLStreamException ex) {         throw convertXStreamException(ex, true).     } }
false;protected;3;8;;@Override protected void marshalSaxHandlers(Object graph, ContentHandler contentHandler, @Nullable LexicalHandler lexicalHandler) throws XmlMappingException {     SaxWriter saxWriter = new SaxWriter(this.nameCoder).     saxWriter.setContentHandler(contentHandler).     doMarshal(graph, saxWriter, null). }
false;public;2;4;;@Override public void marshalOutputStream(Object graph, OutputStream outputStream) throws XmlMappingException, IOException {     marshalOutputStream(graph, outputStream, null). }
false;public;3;10;;public void marshalOutputStream(Object graph, OutputStream outputStream, @Nullable DataHolder dataHolder) throws XmlMappingException, IOException {     if (this.streamDriver != null) {         doMarshal(graph, this.streamDriver.createWriter(outputStream), dataHolder).     } else {         marshalWriter(graph, new OutputStreamWriter(outputStream, this.encoding), dataHolder).     } }
false;public;2;4;;@Override public void marshalWriter(Object graph, Writer writer) throws XmlMappingException, IOException {     marshalWriter(graph, writer, null). }
false;public;3;10;;public void marshalWriter(Object graph, Writer writer, @Nullable DataHolder dataHolder) throws XmlMappingException, IOException {     if (this.streamDriver != null) {         doMarshal(graph, this.streamDriver.createWriter(writer), dataHolder).     } else {         doMarshal(graph, new CompactWriter(writer), dataHolder).     } }
true;private;3;16;/**  * Marshals the given graph to the given XStream HierarchicalStreamWriter.  * Converts exceptions using {@link #convertXStreamException}.  */ ;/**  * Marshals the given graph to the given XStream HierarchicalStreamWriter.  * Converts exceptions using {@link #convertXStreamException}.  */ private void doMarshal(Object graph, HierarchicalStreamWriter streamWriter, @Nullable DataHolder dataHolder) {     try {         getXStream().marshal(graph, streamWriter, dataHolder).     } catch (Exception ex) {         throw convertXStreamException(ex, true).     } finally {         try {             streamWriter.flush().         } catch (Exception ex) {             logger.debug("Could not flush HierarchicalStreamWriter", ex).         }     } }
false;protected;1;12;;// Unmarshalling @Override protected Object unmarshalStreamSource(StreamSource streamSource) throws XmlMappingException, IOException {     if (streamSource.getInputStream() != null) {         return unmarshalInputStream(streamSource.getInputStream()).     } else if (streamSource.getReader() != null) {         return unmarshalReader(streamSource.getReader()).     } else {         throw new IllegalArgumentException("StreamSource contains neither InputStream nor Reader").     } }
false;protected;1;14;;@Override protected Object unmarshalDomNode(Node node) throws XmlMappingException {     HierarchicalStreamReader streamReader.     if (node instanceof Document) {         streamReader = new DomReader((Document) node, this.nameCoder).     } else if (node instanceof Element) {         streamReader = new DomReader((Element) node, this.nameCoder).     } else {         throw new IllegalArgumentException("DOMSource contains neither Document nor Element").     }     return doUnmarshal(streamReader, null). }
false;protected;1;10;;@Override protected Object unmarshalXmlEventReader(XMLEventReader eventReader) throws XmlMappingException {     try {         XMLStreamReader streamReader = StaxUtils.createEventStreamReader(eventReader).         return unmarshalXmlStreamReader(streamReader).     } catch (XMLStreamException ex) {         throw convertXStreamException(ex, false).     } }
false;protected;1;4;;@Override protected Object unmarshalXmlStreamReader(XMLStreamReader streamReader) throws XmlMappingException {     return doUnmarshal(new StaxReader(new QNameMap(), streamReader, this.nameCoder), null). }
false;protected;2;7;;@Override protected Object unmarshalSaxReader(XMLReader xmlReader, InputSource inputSource) throws XmlMappingException, IOException {     throw new UnsupportedOperationException("XStreamMarshaller does not support unmarshalling using SAX XMLReaders"). }
false;public;1;4;;@Override public Object unmarshalInputStream(InputStream inputStream) throws XmlMappingException, IOException {     return unmarshalInputStream(inputStream, null). }
false;public;2;8;;public Object unmarshalInputStream(InputStream inputStream, @Nullable DataHolder dataHolder) throws XmlMappingException, IOException {     if (this.streamDriver != null) {         return doUnmarshal(this.streamDriver.createReader(inputStream), dataHolder).     } else {         return unmarshalReader(new InputStreamReader(inputStream, this.encoding), dataHolder).     } }
false;public;1;4;;@Override public Object unmarshalReader(Reader reader) throws XmlMappingException, IOException {     return unmarshalReader(reader, null). }
false;public;2;3;;public Object unmarshalReader(Reader reader, @Nullable DataHolder dataHolder) throws XmlMappingException, IOException {     return doUnmarshal(getDefaultDriver().createReader(reader), dataHolder). }
true;private;2;8;/**  * Unmarshals the given graph to the given XStream HierarchicalStreamWriter.  * Converts exceptions using {@link #convertXStreamException}.  */ ;/**  * Unmarshals the given graph to the given XStream HierarchicalStreamWriter.  * Converts exceptions using {@link #convertXStreamException}.  */ private Object doUnmarshal(HierarchicalStreamReader streamReader, @Nullable DataHolder dataHolder) {     try {         return getXStream().unmarshal(streamReader, null, dataHolder).     } catch (Exception ex) {         throw convertXStreamException(ex, false).     } }
true;protected;2;15;/**  * Convert the given XStream exception to an appropriate exception from the  * {@code org.springframework.oxm} hierarchy.  * <p>A boolean flag is used to indicate whether this exception occurs during marshalling or  * unmarshalling, since XStream itself does not make this distinction in its exception hierarchy.  * @param ex the XStream exception that occurred  * @param marshalling indicates whether the exception occurs during marshalling ({@code true}),  * or unmarshalling ({@code false})  * @return the corresponding {@code XmlMappingException}  */ ;/**  * Convert the given XStream exception to an appropriate exception from the  * {@code org.springframework.oxm} hierarchy.  * <p>A boolean flag is used to indicate whether this exception occurs during marshalling or  * unmarshalling, since XStream itself does not make this distinction in its exception hierarchy.  * @param ex the XStream exception that occurred  * @param marshalling indicates whether the exception occurs during marshalling ({@code true}),  * or unmarshalling ({@code false})  * @return the corresponding {@code XmlMappingException}  */ protected XmlMappingException convertXStreamException(Exception ex, boolean marshalling) {     if (ex instanceof StreamException || ex instanceof CannotResolveClassException || ex instanceof ConversionException) {         if (marshalling) {             return new MarshallingFailureException("XStream marshalling exception", ex).         } else {             return new UnmarshallingFailureException("XStream unmarshalling exception", ex).         }     } else {         // fallback         return new UncategorizedMappingException("Unknown XStream exception", ex).     } }
