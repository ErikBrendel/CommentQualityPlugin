# id;timestamp;commentText;codeText;commentWords;codeWords
PythonSender -> public int sendBuffer(Iterator i, int group) throws IOException;1448205809;Extracts records from an iterator and writes them to the memory-mapped file. This method assumes that all values_in the iterator are of the same type. This method does NOT take care of synchronization. The caller must_guarantee that the file may be written to before calling this method.__@param i iterator containing records_@param group group to which the iterator belongs, most notably used by CoGroup-functions._@return size of the written buffer_@throws IOException;public int sendBuffer(Iterator i, int group) throws IOException {_		fileBuffer.clear()___		Object value__		ByteBuffer bb__		if (serializer[group] == null) {_			value = i.next()__			serializer[group] = getSerializer(value)__			bb = serializer[group].serialize(value)__			if (bb.remaining() > MAPPED_FILE_SIZE) {_				throw new RuntimeException("Serialized object does not fit into a single buffer.")__			}_			fileBuffer.put(bb)___		}_		if (saved[group] != null) {_			fileBuffer.put(saved[group])__			saved[group] = null__		}_		while (i.hasNext() && saved[group] == null) {_			value = i.next()__			bb = serializer[group].serialize(value)__			if (bb.remaining() > MAPPED_FILE_SIZE) {_				throw new RuntimeException("Serialized object does not fit into a single buffer.")__			}_			if (bb.remaining() <= fileBuffer.remaining()) {_				fileBuffer.put(bb)__			} else {_				saved[group] = bb__			}_		}__		int size = fileBuffer.position()__		return size__	};extracts,records,from,an,iterator,and,writes,them,to,the,memory,mapped,file,this,method,assumes,that,all,values,in,the,iterator,are,of,the,same,type,this,method,does,not,take,care,of,synchronization,the,caller,must,guarantee,that,the,file,may,be,written,to,before,calling,this,method,param,i,iterator,containing,records,param,group,group,to,which,the,iterator,belongs,most,notably,used,by,co,group,functions,return,size,of,the,written,buffer,throws,ioexception;public,int,send,buffer,iterator,i,int,group,throws,ioexception,file,buffer,clear,object,value,byte,buffer,bb,if,serializer,group,null,value,i,next,serializer,group,get,serializer,value,bb,serializer,group,serialize,value,if,bb,remaining,throw,new,runtime,exception,serialized,object,does,not,fit,into,a,single,buffer,file,buffer,put,bb,if,saved,group,null,file,buffer,put,saved,group,saved,group,null,while,i,has,next,saved,group,null,value,i,next,bb,serializer,group,serialize,value,if,bb,remaining,throw,new,runtime,exception,serialized,object,does,not,fit,into,a,single,buffer,if,bb,remaining,file,buffer,remaining,file,buffer,put,bb,else,saved,group,bb,int,size,file,buffer,position,return,size
PythonSender -> public int sendBuffer(Iterator i, int group) throws IOException;1453297853;Extracts records from an iterator and writes them to the memory-mapped file. This method assumes that all values_in the iterator are of the same type. This method does NOT take care of synchronization. The caller must_guarantee that the file may be written to before calling this method.__@param i iterator containing records_@param group group to which the iterator belongs, most notably used by CoGroup-functions._@return size of the written buffer_@throws IOException;public int sendBuffer(Iterator i, int group) throws IOException {_		fileBuffer.clear()___		Object value__		ByteBuffer bb__		if (serializer[group] == null) {_			value = i.next()__			serializer[group] = getSerializer(value)__			bb = serializer[group].serialize(value)__			if (bb.remaining() > MAPPED_FILE_SIZE) {_				throw new RuntimeException("Serialized object does not fit into a single buffer.")__			}_			fileBuffer.put(bb)___		}_		if (saved[group] != null) {_			fileBuffer.put(saved[group])__			saved[group] = null__		}_		while (i.hasNext() && saved[group] == null) {_			value = i.next()__			bb = serializer[group].serialize(value)__			if (bb.remaining() > MAPPED_FILE_SIZE) {_				throw new RuntimeException("Serialized object does not fit into a single buffer.")__			}_			if (bb.remaining() <= fileBuffer.remaining()) {_				fileBuffer.put(bb)__			} else {_				saved[group] = bb__			}_		}__		int size = fileBuffer.position()__		return size__	};extracts,records,from,an,iterator,and,writes,them,to,the,memory,mapped,file,this,method,assumes,that,all,values,in,the,iterator,are,of,the,same,type,this,method,does,not,take,care,of,synchronization,the,caller,must,guarantee,that,the,file,may,be,written,to,before,calling,this,method,param,i,iterator,containing,records,param,group,group,to,which,the,iterator,belongs,most,notably,used,by,co,group,functions,return,size,of,the,written,buffer,throws,ioexception;public,int,send,buffer,iterator,i,int,group,throws,ioexception,file,buffer,clear,object,value,byte,buffer,bb,if,serializer,group,null,value,i,next,serializer,group,get,serializer,value,bb,serializer,group,serialize,value,if,bb,remaining,throw,new,runtime,exception,serialized,object,does,not,fit,into,a,single,buffer,file,buffer,put,bb,if,saved,group,null,file,buffer,put,saved,group,saved,group,null,while,i,has,next,saved,group,null,value,i,next,bb,serializer,group,serialize,value,if,bb,remaining,throw,new,runtime,exception,serialized,object,does,not,fit,into,a,single,buffer,if,bb,remaining,file,buffer,remaining,file,buffer,put,bb,else,saved,group,bb,int,size,file,buffer,position,return,size
PythonSender -> private Serializer getSerializer(Object value);1453297853;=====Serializer===================================================================================================;private Serializer getSerializer(Object value) {_		if (value instanceof byte[]) {_			return new ArraySerializer()__		}_		if (((Tuple2) value).f0 instanceof byte[]) {_			return new ValuePairSerializer()__		}_		if (((Tuple2) value).f0 instanceof Tuple) {_			return new KeyValuePairSerializer()__		}_		throw new IllegalArgumentException("This object can't be serialized: " + value.toString())__	};serializer;private,serializer,get,serializer,object,value,if,value,instanceof,byte,return,new,array,serializer,if,tuple2,value,f0,instanceof,byte,return,new,value,pair,serializer,if,tuple2,value,f0,instanceof,tuple,return,new,key,value,pair,serializer,throw,new,illegal,argument,exception,this,object,can,t,be,serialized,value,to,string
PythonSender -> private Serializer getSerializer(Object value);1454324870;=====Serializer===================================================================================================;private Serializer getSerializer(Object value) {_		if (value instanceof byte[]) {_			return new ArraySerializer()__		}_		if (((Tuple2) value).f0 instanceof byte[]) {_			return new ValuePairSerializer()__		}_		if (((Tuple2) value).f0 instanceof Tuple) {_			return new KeyValuePairSerializer()__		}_		throw new IllegalArgumentException("This object can't be serialized: " + value.toString())__	};serializer;private,serializer,get,serializer,object,value,if,value,instanceof,byte,return,new,array,serializer,if,tuple2,value,f0,instanceof,byte,return,new,value,pair,serializer,if,tuple2,value,f0,instanceof,tuple,return,new,key,value,pair,serializer,throw,new,illegal,argument,exception,this,object,can,t,be,serialized,value,to,string
PythonSender -> public int sendRecord(Object value) throws IOException;1448205809;Writes a single record to the memory-mapped file. This method does NOT take care of synchronization. The user_must guarantee that the file may be written to before calling this method. This method essentially reserves the_whole buffer for one record. As such it imposes some performance restrictions and should only be used when_absolutely necessary.__@param value record to send_@return size of the written buffer_@throws IOException;public int sendRecord(Object value) throws IOException {_		fileBuffer.clear()__		int group = 0___		serializer[group] = getSerializer(value)__		ByteBuffer bb = serializer[group].serialize(value)__		if (bb.remaining() > MAPPED_FILE_SIZE) {_			throw new RuntimeException("Serialized object does not fit into a single buffer.")__		}_		fileBuffer.put(bb)___		int size = fileBuffer.position()___		reset()__		return size__	};writes,a,single,record,to,the,memory,mapped,file,this,method,does,not,take,care,of,synchronization,the,user,must,guarantee,that,the,file,may,be,written,to,before,calling,this,method,this,method,essentially,reserves,the,whole,buffer,for,one,record,as,such,it,imposes,some,performance,restrictions,and,should,only,be,used,when,absolutely,necessary,param,value,record,to,send,return,size,of,the,written,buffer,throws,ioexception;public,int,send,record,object,value,throws,ioexception,file,buffer,clear,int,group,0,serializer,group,get,serializer,value,byte,buffer,bb,serializer,group,serialize,value,if,bb,remaining,throw,new,runtime,exception,serialized,object,does,not,fit,into,a,single,buffer,file,buffer,put,bb,int,size,file,buffer,position,reset,return,size
PythonSender -> public int sendRecord(Object value) throws IOException;1453297853;Writes a single record to the memory-mapped file. This method does NOT take care of synchronization. The user_must guarantee that the file may be written to before calling this method. This method essentially reserves the_whole buffer for one record. As such it imposes some performance restrictions and should only be used when_absolutely necessary.__@param value record to send_@return size of the written buffer_@throws IOException;public int sendRecord(Object value) throws IOException {_		fileBuffer.clear()__		int group = 0___		serializer[group] = getSerializer(value)__		ByteBuffer bb = serializer[group].serialize(value)__		if (bb.remaining() > MAPPED_FILE_SIZE) {_			throw new RuntimeException("Serialized object does not fit into a single buffer.")__		}_		fileBuffer.put(bb)___		int size = fileBuffer.position()___		reset()__		return size__	};writes,a,single,record,to,the,memory,mapped,file,this,method,does,not,take,care,of,synchronization,the,user,must,guarantee,that,the,file,may,be,written,to,before,calling,this,method,this,method,essentially,reserves,the,whole,buffer,for,one,record,as,such,it,imposes,some,performance,restrictions,and,should,only,be,used,when,absolutely,necessary,param,value,record,to,send,return,size,of,the,written,buffer,throws,ioexception;public,int,send,record,object,value,throws,ioexception,file,buffer,clear,int,group,0,serializer,group,get,serializer,value,byte,buffer,bb,serializer,group,serialize,value,if,bb,remaining,throw,new,runtime,exception,serialized,object,does,not,fit,into,a,single,buffer,file,buffer,put,bb,int,size,file,buffer,position,reset,return,size
PythonSender -> public void open(String path) throws IOException;1448205809;=====Setup========================================================================================================;public void open(String path) throws IOException {_		setupMappedFile(path)__	};setup;public,void,open,string,path,throws,ioexception,setup,mapped,file,path
PythonSender -> public void open(String path) throws IOException;1453297853;=====Setup========================================================================================================;public void open(String path) throws IOException {_		setupMappedFile(path)__	};setup;public,void,open,string,path,throws,ioexception,setup,mapped,file,path
PythonSender -> public void open(String path) throws IOException;1454324870;=====Setup========================================================================================================;public void open(String path) throws IOException {_		setupMappedFile(path)__	};setup;public,void,open,string,path,throws,ioexception,setup,mapped,file,path
PythonSender -> public void open(String path) throws IOException;1489667061;=====Setup========================================================================================================;public void open(String path) throws IOException {_		saved = new ByteBuffer[2]__		serializer = new Serializer[2]__		setupMappedFile(path)__	};setup;public,void,open,string,path,throws,ioexception,saved,new,byte,buffer,2,serializer,new,serializer,2,setup,mapped,file,path
PythonSender -> public void open(String path) throws IOException;1489703169;=====Setup========================================================================================================;public void open(String path) throws IOException {_		setupMappedFile(path)__	};setup;public,void,open,string,path,throws,ioexception,setup,mapped,file,path
PythonSender -> protected <IN> int sendBuffer(SingleElementPushBackIterator<IN> input, Serializer<IN> serializer) throws IOException;1489703169;Extracts records from an iterator and writes them to the memory-mapped file. This method assumes that all values_in the iterator are of the same type. This method does NOT take care of synchronization. The caller must_guarantee that the file may be written to before calling this method.__@param input     iterator containing records_@param serializer serializer for the input records_@return size of the written buffer_@throws IOException;protected <IN> int sendBuffer(SingleElementPushBackIterator<IN> input, Serializer<IN> serializer) throws IOException {_		fileBuffer.clear()___		while (input.hasNext()) {_			IN value = input.next()__			ByteBuffer bb = serializer.serialize(value)__			if (bb.remaining() > MAPPED_FILE_SIZE) {_				throw new RuntimeException("Serialized object does not fit into a single buffer.")__			}_			if (bb.remaining() <= fileBuffer.remaining()) {_				fileBuffer.put(bb)__			} else {_				input.pushBack(value)__				break__			}_		}__		int size = fileBuffer.position()__		return size__	};extracts,records,from,an,iterator,and,writes,them,to,the,memory,mapped,file,this,method,assumes,that,all,values,in,the,iterator,are,of,the,same,type,this,method,does,not,take,care,of,synchronization,the,caller,must,guarantee,that,the,file,may,be,written,to,before,calling,this,method,param,input,iterator,containing,records,param,serializer,serializer,for,the,input,records,return,size,of,the,written,buffer,throws,ioexception;protected,in,int,send,buffer,single,element,push,back,iterator,in,input,serializer,in,serializer,throws,ioexception,file,buffer,clear,while,input,has,next,in,value,input,next,byte,buffer,bb,serializer,serialize,value,if,bb,remaining,throw,new,runtime,exception,serialized,object,does,not,fit,into,a,single,buffer,if,bb,remaining,file,buffer,remaining,file,buffer,put,bb,else,input,push,back,value,break,int,size,file,buffer,position,return,size
PythonSender -> protected <IN> int sendBuffer(SingleElementPushBackIterator<IN> input, Serializer<IN> serializer) throws IOException;1490954118;Extracts records from an iterator and writes them to the memory-mapped file. This method assumes that all values_in the iterator are of the same type. This method does NOT take care of synchronization. The caller must_guarantee that the file may be written to before calling this method.__@param input     iterator containing records_@param serializer serializer for the input records_@return size of the written buffer_@throws IOException;protected <IN> int sendBuffer(SingleElementPushBackIterator<IN> input, Serializer<IN> serializer) throws IOException {_		fileBuffer.clear()___		while (input.hasNext()) {_			IN value = input.next()__			ByteBuffer bb = serializer.serialize(value)__			if (bb.remaining() > mappedFileSizeBytes) {_				throw new RuntimeException("Serialized object does not fit into a single buffer.")__			}_			if (bb.remaining() <= fileBuffer.remaining()) {_				fileBuffer.put(bb)__			} else {_				input.pushBack(value)__				break__			}_		}__		int size = fileBuffer.position()__		return size__	};extracts,records,from,an,iterator,and,writes,them,to,the,memory,mapped,file,this,method,assumes,that,all,values,in,the,iterator,are,of,the,same,type,this,method,does,not,take,care,of,synchronization,the,caller,must,guarantee,that,the,file,may,be,written,to,before,calling,this,method,param,input,iterator,containing,records,param,serializer,serializer,for,the,input,records,return,size,of,the,written,buffer,throws,ioexception;protected,in,int,send,buffer,single,element,push,back,iterator,in,input,serializer,in,serializer,throws,ioexception,file,buffer,clear,while,input,has,next,in,value,input,next,byte,buffer,bb,serializer,serialize,value,if,bb,remaining,mapped,file,size,bytes,throw,new,runtime,exception,serialized,object,does,not,fit,into,a,single,buffer,if,bb,remaining,file,buffer,remaining,file,buffer,put,bb,else,input,push,back,value,break,int,size,file,buffer,position,return,size
PythonSender -> protected <IN> int sendBuffer(SingleElementPushBackIterator<IN> input, Serializer<IN> serializer) throws IOException;1493741028;Extracts records from an iterator and writes them to the memory-mapped file. This method assumes that all values_in the iterator are of the same type. This method does NOT take care of synchronization. The caller must_guarantee that the file may be written to before calling this method.__@param input     iterator containing records_@param serializer serializer for the input records_@return size of the written buffer_@throws IOException;protected <IN> int sendBuffer(SingleElementPushBackIterator<IN> input, Serializer<IN> serializer) throws IOException {_		fileBuffer.clear()___		while (input.hasNext()) {_			IN value = input.next()__			ByteBuffer bb = serializer.serialize(value)__			if (bb.remaining() > mappedFileSizeBytes) {_				throw new RuntimeException("Serialized object does not fit into a single buffer.")__			}_			if (bb.remaining() <= fileBuffer.remaining()) {_				fileBuffer.put(bb)__			} else {_				input.pushBack(value)__				break__			}_		}__		int size = fileBuffer.position()__		return size__	};extracts,records,from,an,iterator,and,writes,them,to,the,memory,mapped,file,this,method,assumes,that,all,values,in,the,iterator,are,of,the,same,type,this,method,does,not,take,care,of,synchronization,the,caller,must,guarantee,that,the,file,may,be,written,to,before,calling,this,method,param,input,iterator,containing,records,param,serializer,serializer,for,the,input,records,return,size,of,the,written,buffer,throws,ioexception;protected,in,int,send,buffer,single,element,push,back,iterator,in,input,serializer,in,serializer,throws,ioexception,file,buffer,clear,while,input,has,next,in,value,input,next,byte,buffer,bb,serializer,serialize,value,if,bb,remaining,mapped,file,size,bytes,throw,new,runtime,exception,serialized,object,does,not,fit,into,a,single,buffer,if,bb,remaining,file,buffer,remaining,file,buffer,put,bb,else,input,push,back,value,break,int,size,file,buffer,position,return,size
PythonSender -> public void reset();1448205809;Resets this object to the post-configuration state.;public void reset() {_		serializer[0] = null__		serializer[1] = null__		fileBuffer.clear()__	};resets,this,object,to,the,post,configuration,state;public,void,reset,serializer,0,null,serializer,1,null,file,buffer,clear
PythonSender -> public void reset();1453297853;Resets this object to the post-configuration state.;public void reset() {_		serializer[0] = null__		serializer[1] = null__		fileBuffer.clear()__	};resets,this,object,to,the,post,configuration,state;public,void,reset,serializer,0,null,serializer,1,null,file,buffer,clear
PythonSender -> public void reset();1454324870;Resets this object to the post-configuration state.;public void reset() {_		serializer[0] = null__		serializer[1] = null__		fileBuffer.clear()__	};resets,this,object,to,the,post,configuration,state;public,void,reset,serializer,0,null,serializer,1,null,file,buffer,clear
PythonSender -> public void reset();1489667061;Resets this object to the post-configuration state.;public void reset() {_		serializer[0] = null__		serializer[1] = null__		fileBuffer.clear()__	};resets,this,object,to,the,post,configuration,state;public,void,reset,serializer,0,null,serializer,1,null,file,buffer,clear
PythonSender -> public void open(File outputFile) throws IOException;1490954118;=====Setup========================================================================================================;public void open(File outputFile) throws IOException {_		outputFile.mkdirs()___		if (outputFile.exists()) {_			outputFile.delete()__		}_		outputFile.createNewFile()__		outputRAF = new RandomAccessFile(outputFile, "rw")___		_		outputRAF.setLength(mappedFileSizeBytes)__		outputRAF.seek(mappedFileSizeBytes - 1)__		outputRAF.writeByte(0)__		outputRAF.seek(0)__		outputChannel = outputRAF.getChannel()__		fileBuffer = outputChannel.map(FileChannel.MapMode.READ_WRITE, 0, mappedFileSizeBytes)__	};setup;public,void,open,file,output,file,throws,ioexception,output,file,mkdirs,if,output,file,exists,output,file,delete,output,file,create,new,file,output,raf,new,random,access,file,output,file,rw,output,raf,set,length,mapped,file,size,bytes,output,raf,seek,mapped,file,size,bytes,1,output,raf,write,byte,0,output,raf,seek,0,output,channel,output,raf,get,channel,file,buffer,output,channel,map,file,channel,map,mode,0,mapped,file,size,bytes
PythonSender -> public void open(File outputFile) throws IOException;1493741028;=====Setup========================================================================================================;public void open(File outputFile) throws IOException {_		outputFile.mkdirs()___		if (outputFile.exists()) {_			outputFile.delete()__		}_		outputFile.createNewFile()__		outputRAF = new RandomAccessFile(outputFile, "rw")___		outputRAF.setLength(mappedFileSizeBytes)__		outputRAF.seek(mappedFileSizeBytes - 1)__		outputRAF.writeByte(0)__		outputRAF.seek(0)__		outputChannel = outputRAF.getChannel()__		fileBuffer = outputChannel.map(FileChannel.MapMode.READ_WRITE, 0, mappedFileSizeBytes)__	};setup;public,void,open,file,output,file,throws,ioexception,output,file,mkdirs,if,output,file,exists,output,file,delete,output,file,create,new,file,output,raf,new,random,access,file,output,file,rw,output,raf,set,length,mapped,file,size,bytes,output,raf,seek,mapped,file,size,bytes,1,output,raf,write,byte,0,output,raf,seek,0,output,channel,output,raf,get,channel,file,buffer,output,channel,map,file,channel,map,mode,0,mapped,file,size,bytes
PythonSender -> @SuppressWarnings("unchecked") 	public int sendRecord(Object value) throws IOException;1454324870;Writes a single record to the memory-mapped file. This method does NOT take care of synchronization. The user_must guarantee that the file may be written to before calling this method. This method essentially reserves the_whole buffer for one record. As such it imposes some performance restrictions and should only be used when_absolutely necessary.__@param value record to send_@return size of the written buffer_@throws IOException;@SuppressWarnings("unchecked")_	public int sendRecord(Object value) throws IOException {_		fileBuffer.clear()__		int group = 0___		serializer[group] = getSerializer(value)__		ByteBuffer bb = serializer[group].serialize(value)__		if (bb.remaining() > MAPPED_FILE_SIZE) {_			throw new RuntimeException("Serialized object does not fit into a single buffer.")__		}_		fileBuffer.put(bb)___		int size = fileBuffer.position()___		reset()__		return size__	};writes,a,single,record,to,the,memory,mapped,file,this,method,does,not,take,care,of,synchronization,the,user,must,guarantee,that,the,file,may,be,written,to,before,calling,this,method,this,method,essentially,reserves,the,whole,buffer,for,one,record,as,such,it,imposes,some,performance,restrictions,and,should,only,be,used,when,absolutely,necessary,param,value,record,to,send,return,size,of,the,written,buffer,throws,ioexception;suppress,warnings,unchecked,public,int,send,record,object,value,throws,ioexception,file,buffer,clear,int,group,0,serializer,group,get,serializer,value,byte,buffer,bb,serializer,group,serialize,value,if,bb,remaining,throw,new,runtime,exception,serialized,object,does,not,fit,into,a,single,buffer,file,buffer,put,bb,int,size,file,buffer,position,reset,return,size
PythonSender -> @SuppressWarnings("unchecked") 	public int sendRecord(Object value) throws IOException;1489667061;Writes a single record to the memory-mapped file. This method does NOT take care of synchronization. The user_must guarantee that the file may be written to before calling this method. This method essentially reserves the_whole buffer for one record. As such it imposes some performance restrictions and should only be used when_absolutely necessary.__@param value record to send_@return size of the written buffer_@throws IOException;@SuppressWarnings("unchecked")_	public int sendRecord(Object value) throws IOException {_		fileBuffer.clear()__		int group = 0___		serializer[group] = getSerializer(value)__		ByteBuffer bb = serializer[group].serialize(value)__		if (bb.remaining() > MAPPED_FILE_SIZE) {_			throw new RuntimeException("Serialized object does not fit into a single buffer.")__		}_		fileBuffer.put(bb)___		int size = fileBuffer.position()___		reset()__		return size__	};writes,a,single,record,to,the,memory,mapped,file,this,method,does,not,take,care,of,synchronization,the,user,must,guarantee,that,the,file,may,be,written,to,before,calling,this,method,this,method,essentially,reserves,the,whole,buffer,for,one,record,as,such,it,imposes,some,performance,restrictions,and,should,only,be,used,when,absolutely,necessary,param,value,record,to,send,return,size,of,the,written,buffer,throws,ioexception;suppress,warnings,unchecked,public,int,send,record,object,value,throws,ioexception,file,buffer,clear,int,group,0,serializer,group,get,serializer,value,byte,buffer,bb,serializer,group,serialize,value,if,bb,remaining,throw,new,runtime,exception,serialized,object,does,not,fit,into,a,single,buffer,file,buffer,put,bb,int,size,file,buffer,position,reset,return,size
