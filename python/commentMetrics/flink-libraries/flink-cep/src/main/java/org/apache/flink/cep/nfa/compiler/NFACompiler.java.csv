# id;timestamp;commentText;codeText;commentWords;codeWords
NFACompiler -> NFAFactoryCompiler -> void compileFactory();1489866780;Compiles the given pattern into a {@link NFAFactory}. The NFA factory can be used to create_multiple NFAs.;void compileFactory() {_			_			State<T> sinkState = createEndingState()__			_			sinkState = createMiddleStates(sinkState)__			_			createStartState(sinkState)__		};compiles,the,given,pattern,into,a,link,nfafactory,the,nfa,factory,can,be,used,to,create,multiple,nfas;void,compile,factory,state,t,sink,state,create,ending,state,sink,state,create,middle,states,sink,state,create,start,state,sink,state
NFACompiler -> NFAFactoryCompiler -> void compileFactory();1490089987;Compiles the given pattern into a {@link NFAFactory}. The NFA factory can be used to create_multiple NFAs.;void compileFactory() {_			_			State<T> sinkState = createEndingState()__			_			sinkState = createMiddleStates(sinkState)__			_			createStartState(sinkState)__		};compiles,the,given,pattern,into,a,link,nfafactory,the,nfa,factory,can,be,used,to,create,multiple,nfas;void,compile,factory,state,t,sink,state,create,ending,state,sink,state,create,middle,states,sink,state,create,start,state,sink,state
NFACompiler -> NFAFactoryCompiler -> void compileFactory();1490194327;Compiles the given pattern into a {@link NFAFactory}. The NFA factory can be used to create_multiple NFAs.;void compileFactory() {_			_			State<T> sinkState = createEndingState()__			_			sinkState = createMiddleStates(sinkState)__			_			createStartState(sinkState)__		};compiles,the,given,pattern,into,a,link,nfafactory,the,nfa,factory,can,be,used,to,create,multiple,nfas;void,compile,factory,state,t,sink,state,create,ending,state,sink,state,create,middle,states,sink,state,create,start,state,sink,state
NFACompiler -> NFAFactoryCompiler -> void compileFactory();1490619911;Compiles the given pattern into a {@link NFAFactory}. The NFA factory can be used to create_multiple NFAs.;void compileFactory() {_			_			State<T> sinkState = createEndingState()__			_			sinkState = createMiddleStates(sinkState)__			_			createStartState(sinkState)__		};compiles,the,given,pattern,into,a,link,nfafactory,the,nfa,factory,can,be,used,to,create,multiple,nfas;void,compile,factory,state,t,sink,state,create,ending,state,sink,state,create,middle,states,sink,state,create,start,state,sink,state
NFACompiler -> NFAFactoryCompiler -> void compileFactory();1491320734;Compiles the given pattern into a {@link NFAFactory}. The NFA factory can be used to create_multiple NFAs.;void compileFactory() {_			_			State<T> sinkState = createEndingState()__			_			sinkState = createMiddleStates(sinkState)__			_			createStartState(sinkState)__		};compiles,the,given,pattern,into,a,link,nfafactory,the,nfa,factory,can,be,used,to,create,multiple,nfas;void,compile,factory,state,t,sink,state,create,ending,state,sink,state,create,middle,states,sink,state,create,start,state,sink,state
NFACompiler -> NFAFactoryCompiler -> void compileFactory();1491323030;Compiles the given pattern into a {@link NFAFactory}. The NFA factory can be used to create_multiple NFAs.;void compileFactory() {_			_			State<T> sinkState = createEndingState()__			_			sinkState = createMiddleStates(sinkState)__			_			createStartState(sinkState)__		};compiles,the,given,pattern,into,a,link,nfafactory,the,nfa,factory,can,be,used,to,create,multiple,nfas;void,compile,factory,state,t,sink,state,create,ending,state,sink,state,create,middle,states,sink,state,create,start,state,sink,state
NFACompiler -> NFAFactoryCompiler -> void compileFactory();1491633862;Compiles the given pattern into a {@link NFAFactory}. The NFA factory can be used to create_multiple NFAs.;void compileFactory() {_			_			State<T> sinkState = createEndingState()__			_			sinkState = createMiddleStates(sinkState)__			_			createStartState(sinkState)__		};compiles,the,given,pattern,into,a,link,nfafactory,the,nfa,factory,can,be,used,to,create,multiple,nfas;void,compile,factory,state,t,sink,state,create,ending,state,sink,state,create,middle,states,sink,state,create,start,state,sink,state
NFACompiler -> NFAFactoryCompiler -> void compileFactory();1492797583;Compiles the given pattern into a {@link NFAFactory}. The NFA factory can be used to create_multiple NFAs.;void compileFactory() {_			_			State<T> sinkState = createEndingState()__			_			sinkState = createMiddleStates(sinkState)__			_			createStartState(sinkState)__		};compiles,the,given,pattern,into,a,link,nfafactory,the,nfa,factory,can,be,used,to,create,multiple,nfas;void,compile,factory,state,t,sink,state,create,ending,state,sink,state,create,middle,states,sink,state,create,start,state,sink,state
NFACompiler -> NFAFactoryCompiler -> void compileFactory();1493200673;Compiles the given pattern into a {@link NFAFactory}. The NFA factory can be used to create_multiple NFAs.;void compileFactory() {_			_			State<T> sinkState = createEndingState()__			_			sinkState = createMiddleStates(sinkState)__			_			createStartState(sinkState)__		};compiles,the,given,pattern,into,a,link,nfafactory,the,nfa,factory,can,be,used,to,create,multiple,nfas;void,compile,factory,state,t,sink,state,create,ending,state,sink,state,create,middle,states,sink,state,create,start,state,sink,state
NFACompiler -> NFAFactoryCompiler -> void compileFactory();1493385877;Compiles the given pattern into a {@link NFAFactory}. The NFA factory can be used to create_multiple NFAs.;void compileFactory() {_			if (currentPattern.getQuantifier().getConsumingStrategy() == Quantifier.ConsumingStrategy.NOT_FOLLOW) {_				throw new MalformedPatternException("NotFollowedBy is not supported as a last part of a Pattern!")__			}__			_			State<T> sinkState = createEndingState()__			_			sinkState = createMiddleStates(sinkState)__			_			createStartState(sinkState)__		};compiles,the,given,pattern,into,a,link,nfafactory,the,nfa,factory,can,be,used,to,create,multiple,nfas;void,compile,factory,if,current,pattern,get,quantifier,get,consuming,strategy,quantifier,consuming,strategy,throw,new,malformed,pattern,exception,not,followed,by,is,not,supported,as,a,last,part,of,a,pattern,state,t,sink,state,create,ending,state,sink,state,create,middle,states,sink,state,create,start,state,sink,state
NFACompiler -> NFAFactoryCompiler -> void compileFactory();1494947249;Compiles the given pattern into a {@link NFAFactory}. The NFA factory can be used to create_multiple NFAs.;void compileFactory() {_			if (currentPattern.getQuantifier().getConsumingStrategy() == Quantifier.ConsumingStrategy.NOT_FOLLOW) {_				throw new MalformedPatternException("NotFollowedBy is not supported as a last part of a Pattern!")__			}__			_			State<T> sinkState = createEndingState()__			_			sinkState = createMiddleStates(sinkState)__			_			createStartState(sinkState)__		};compiles,the,given,pattern,into,a,link,nfafactory,the,nfa,factory,can,be,used,to,create,multiple,nfas;void,compile,factory,if,current,pattern,get,quantifier,get,consuming,strategy,quantifier,consuming,strategy,throw,new,malformed,pattern,exception,not,followed,by,is,not,supported,as,a,last,part,of,a,pattern,state,t,sink,state,create,ending,state,sink,state,create,middle,states,sink,state,create,start,state,sink,state
NFACompiler -> NFAFactoryCompiler -> void compileFactory();1495657626;Compiles the given pattern into a {@link NFAFactory}. The NFA factory can be used to create_multiple NFAs.;void compileFactory() {_			if (currentPattern.getQuantifier().getConsumingStrategy() == Quantifier.ConsumingStrategy.NOT_FOLLOW) {_				throw new MalformedPatternException("NotFollowedBy is not supported as a last part of a Pattern!")__			}__			_			State<T> sinkState = createEndingState()__			_			sinkState = createMiddleStates(sinkState)__			_			createStartState(sinkState)__		};compiles,the,given,pattern,into,a,link,nfafactory,the,nfa,factory,can,be,used,to,create,multiple,nfas;void,compile,factory,if,current,pattern,get,quantifier,get,consuming,strategy,quantifier,consuming,strategy,throw,new,malformed,pattern,exception,not,followed,by,is,not,supported,as,a,last,part,of,a,pattern,state,t,sink,state,create,ending,state,sink,state,create,middle,states,sink,state,create,start,state,sink,state
NFACompiler -> NFAFactoryCompiler -> void compileFactory();1496245714;Compiles the given pattern into a {@link NFAFactory}. The NFA factory can be used to create_multiple NFAs.;void compileFactory() {_			if (currentPattern.getQuantifier().getConsumingStrategy() == Quantifier.ConsumingStrategy.NOT_FOLLOW) {_				throw new MalformedPatternException("NotFollowedBy is not supported as a last part of a Pattern!")__			}__			_			State<T> sinkState = createEndingState()__			_			sinkState = createMiddleStates(sinkState)__			_			createStartState(sinkState)__		};compiles,the,given,pattern,into,a,link,nfafactory,the,nfa,factory,can,be,used,to,create,multiple,nfas;void,compile,factory,if,current,pattern,get,quantifier,get,consuming,strategy,quantifier,consuming,strategy,throw,new,malformed,pattern,exception,not,followed,by,is,not,supported,as,a,last,part,of,a,pattern,state,t,sink,state,create,ending,state,sink,state,create,middle,states,sink,state,create,start,state,sink,state
NFACompiler -> NFAFactoryCompiler -> void compileFactory();1497410381;Compiles the given pattern into a {@link NFAFactory}. The NFA factory can be used to create_multiple NFAs.;void compileFactory() {_			if (currentPattern.getQuantifier().getConsumingStrategy() == Quantifier.ConsumingStrategy.NOT_FOLLOW) {_				throw new MalformedPatternException("NotFollowedBy is not supported as a last part of a Pattern!")__			}__			_			State<T> sinkState = createEndingState()__			_			sinkState = createMiddleStates(sinkState)__			_			createStartState(sinkState)__		};compiles,the,given,pattern,into,a,link,nfafactory,the,nfa,factory,can,be,used,to,create,multiple,nfas;void,compile,factory,if,current,pattern,get,quantifier,get,consuming,strategy,quantifier,consuming,strategy,throw,new,malformed,pattern,exception,not,followed,by,is,not,supported,as,a,last,part,of,a,pattern,state,t,sink,state,create,ending,state,sink,state,create,middle,states,sink,state,create,start,state,sink,state
NFACompiler -> NFAFactoryCompiler -> void compileFactory();1497883202;Compiles the given pattern into a {@link NFAFactory}. The NFA factory can be used to create_multiple NFAs.;void compileFactory() {_			if (currentPattern.getQuantifier().getConsumingStrategy() == Quantifier.ConsumingStrategy.NOT_FOLLOW) {_				throw new MalformedPatternException("NotFollowedBy is not supported as a last part of a Pattern!")__			}__			_			State<T> sinkState = createEndingState()__			_			sinkState = createMiddleStates(sinkState)__			_			createStartState(sinkState)__		};compiles,the,given,pattern,into,a,link,nfafactory,the,nfa,factory,can,be,used,to,create,multiple,nfas;void,compile,factory,if,current,pattern,get,quantifier,get,consuming,strategy,quantifier,consuming,strategy,throw,new,malformed,pattern,exception,not,followed,by,is,not,supported,as,a,last,part,of,a,pattern,state,t,sink,state,create,ending,state,sink,state,create,middle,states,sink,state,create,start,state,sink,state
NFACompiler -> NFAFactoryCompiler -> void compileFactory();1498034481;Compiles the given pattern into a {@link NFAFactory}. The NFA factory can be used to create_multiple NFAs.;void compileFactory() {_			if (currentPattern.getQuantifier().getConsumingStrategy() == Quantifier.ConsumingStrategy.NOT_FOLLOW) {_				throw new MalformedPatternException("NotFollowedBy is not supported as a last part of a Pattern!")__			}__			checkPatternNameUniqueness()___			_			State<T> sinkState = createEndingState()__			_			sinkState = createMiddleStates(sinkState)__			_			createStartState(sinkState)__		};compiles,the,given,pattern,into,a,link,nfafactory,the,nfa,factory,can,be,used,to,create,multiple,nfas;void,compile,factory,if,current,pattern,get,quantifier,get,consuming,strategy,quantifier,consuming,strategy,throw,new,malformed,pattern,exception,not,followed,by,is,not,supported,as,a,last,part,of,a,pattern,check,pattern,name,uniqueness,state,t,sink,state,create,ending,state,sink,state,create,middle,states,sink,state,create,start,state,sink,state
NFACompiler -> NFAFactoryCompiler -> void compileFactory();1499760222;Compiles the given pattern into a {@link NFAFactory}. The NFA factory can be used to create_multiple NFAs.;void compileFactory() {_			if (currentPattern.getQuantifier().getConsumingStrategy() == Quantifier.ConsumingStrategy.NOT_FOLLOW) {_				throw new MalformedPatternException("NotFollowedBy is not supported as a last part of a Pattern!")__			}__			checkPatternNameUniqueness()___			_			State<T> sinkState = createEndingState()__			_			sinkState = createMiddleStates(sinkState)__			_			createStartState(sinkState)__		};compiles,the,given,pattern,into,a,link,nfafactory,the,nfa,factory,can,be,used,to,create,multiple,nfas;void,compile,factory,if,current,pattern,get,quantifier,get,consuming,strategy,quantifier,consuming,strategy,throw,new,malformed,pattern,exception,not,followed,by,is,not,supported,as,a,last,part,of,a,pattern,check,pattern,name,uniqueness,state,t,sink,state,create,ending,state,sink,state,create,middle,states,sink,state,create,start,state,sink,state
NFACompiler -> NFAFactoryCompiler -> void compileFactory();1499937690;Compiles the given pattern into a {@link NFAFactory}. The NFA factory can be used to create_multiple NFAs.;void compileFactory() {_			if (currentPattern.getQuantifier().getConsumingStrategy() == Quantifier.ConsumingStrategy.NOT_FOLLOW) {_				throw new MalformedPatternException("NotFollowedBy is not supported as a last part of a Pattern!")__			}__			checkPatternNameUniqueness()___			_			State<T> sinkState = createEndingState()__			_			sinkState = createMiddleStates(sinkState)__			_			createStartState(sinkState)__		};compiles,the,given,pattern,into,a,link,nfafactory,the,nfa,factory,can,be,used,to,create,multiple,nfas;void,compile,factory,if,current,pattern,get,quantifier,get,consuming,strategy,quantifier,consuming,strategy,throw,new,malformed,pattern,exception,not,followed,by,is,not,supported,as,a,last,part,of,a,pattern,check,pattern,name,uniqueness,state,t,sink,state,create,ending,state,sink,state,create,middle,states,sink,state,create,start,state,sink,state
NFACompiler -> NFAFactoryCompiler -> void compileFactory();1500021711;Compiles the given pattern into a {@link NFAFactory}. The NFA factory can be used to create_multiple NFAs.;void compileFactory() {_			if (currentPattern.getQuantifier().getConsumingStrategy() == Quantifier.ConsumingStrategy.NOT_FOLLOW) {_				throw new MalformedPatternException("NotFollowedBy is not supported as a last part of a Pattern!")__			}__			checkPatternNameUniqueness()___			checkPatternSkipStrategy()___			_			State<T> sinkState = createEndingState()__			_			sinkState = createMiddleStates(sinkState)__			_			createStartState(sinkState)__		};compiles,the,given,pattern,into,a,link,nfafactory,the,nfa,factory,can,be,used,to,create,multiple,nfas;void,compile,factory,if,current,pattern,get,quantifier,get,consuming,strategy,quantifier,consuming,strategy,throw,new,malformed,pattern,exception,not,followed,by,is,not,supported,as,a,last,part,of,a,pattern,check,pattern,name,uniqueness,check,pattern,skip,strategy,state,t,sink,state,create,ending,state,sink,state,create,middle,states,sink,state,create,start,state,sink,state
NFACompiler -> NFAFactoryCompiler -> void compileFactory();1501592283;Compiles the given pattern into a {@link NFAFactory}. The NFA factory can be used to create_multiple NFAs.;void compileFactory() {_			if (currentPattern.getQuantifier().getConsumingStrategy() == Quantifier.ConsumingStrategy.NOT_FOLLOW) {_				throw new MalformedPatternException("NotFollowedBy is not supported as a last part of a Pattern!")__			}__			checkPatternNameUniqueness()___			_			State<T> sinkState = createEndingState()__			_			sinkState = createMiddleStates(sinkState)__			_			createStartState(sinkState)__		};compiles,the,given,pattern,into,a,link,nfafactory,the,nfa,factory,can,be,used,to,create,multiple,nfas;void,compile,factory,if,current,pattern,get,quantifier,get,consuming,strategy,quantifier,consuming,strategy,throw,new,malformed,pattern,exception,not,followed,by,is,not,supported,as,a,last,part,of,a,pattern,check,pattern,name,uniqueness,state,t,sink,state,create,ending,state,sink,state,create,middle,states,sink,state,create,start,state,sink,state
NFACompiler -> NFAFactoryCompiler -> void compileFactory();1502422141;Compiles the given pattern into a {@link NFAFactory}. The NFA factory can be used to create_multiple NFAs.;void compileFactory() {_			if (currentPattern.getQuantifier().getConsumingStrategy() == Quantifier.ConsumingStrategy.NOT_FOLLOW) {_				throw new MalformedPatternException("NotFollowedBy is not supported as a last part of a Pattern!")__			}__			checkPatternNameUniqueness()___			_			State<T> sinkState = createEndingState()__			_			sinkState = createMiddleStates(sinkState)__			_			createStartState(sinkState)__		};compiles,the,given,pattern,into,a,link,nfafactory,the,nfa,factory,can,be,used,to,create,multiple,nfas;void,compile,factory,if,current,pattern,get,quantifier,get,consuming,strategy,quantifier,consuming,strategy,throw,new,malformed,pattern,exception,not,followed,by,is,not,supported,as,a,last,part,of,a,pattern,check,pattern,name,uniqueness,state,t,sink,state,create,ending,state,sink,state,create,middle,states,sink,state,create,start,state,sink,state
NFACompiler -> NFAFactoryCompiler -> void compileFactory();1503588494;Compiles the given pattern into a {@link NFAFactory}. The NFA factory can be used to create_multiple NFAs.;void compileFactory() {_			if (currentPattern.getQuantifier().getConsumingStrategy() == Quantifier.ConsumingStrategy.NOT_FOLLOW) {_				throw new MalformedPatternException("NotFollowedBy is not supported as a last part of a Pattern!")__			}__			checkPatternNameUniqueness()___			_			State<T> sinkState = createEndingState()__			_			sinkState = createMiddleStates(sinkState)__			_			createStartState(sinkState)__		};compiles,the,given,pattern,into,a,link,nfafactory,the,nfa,factory,can,be,used,to,create,multiple,nfas;void,compile,factory,if,current,pattern,get,quantifier,get,consuming,strategy,quantifier,consuming,strategy,throw,new,malformed,pattern,exception,not,followed,by,is,not,supported,as,a,last,part,of,a,pattern,check,pattern,name,uniqueness,state,t,sink,state,create,ending,state,sink,state,create,middle,states,sink,state,create,start,state,sink,state
NFACompiler -> NFAFactoryCompiler -> void compileFactory();1518008111;Compiles the given pattern into a {@link NFAFactory}. The NFA factory can be used to create_multiple NFAs.;void compileFactory() {_			if (currentPattern.getQuantifier().getConsumingStrategy() == Quantifier.ConsumingStrategy.NOT_FOLLOW) {_				throw new MalformedPatternException("NotFollowedBy is not supported as a last part of a Pattern!")__			}__			checkPatternNameUniqueness()___			checkPatternSkipStrategy()___			_			State<T> sinkState = createEndingState()__			_			sinkState = createMiddleStates(sinkState)__			_			createStartState(sinkState)__		};compiles,the,given,pattern,into,a,link,nfafactory,the,nfa,factory,can,be,used,to,create,multiple,nfas;void,compile,factory,if,current,pattern,get,quantifier,get,consuming,strategy,quantifier,consuming,strategy,throw,new,malformed,pattern,exception,not,followed,by,is,not,supported,as,a,last,part,of,a,pattern,check,pattern,name,uniqueness,check,pattern,skip,strategy,state,t,sink,state,create,ending,state,sink,state,create,middle,states,sink,state,create,start,state,sink,state
NFACompiler -> NFAFactoryCompiler -> void compileFactory();1527863170;Compiles the given pattern into a {@link NFAFactory}. The NFA factory can be used to create_multiple NFAs.;void compileFactory() {_			if (currentPattern.getQuantifier().getConsumingStrategy() == Quantifier.ConsumingStrategy.NOT_FOLLOW) {_				throw new MalformedPatternException("NotFollowedBy is not supported as a last part of a Pattern!")__			}__			checkPatternNameUniqueness()___			checkPatternSkipStrategy()___			_			State<T> sinkState = createEndingState()__			_			sinkState = createMiddleStates(sinkState)__			_			createStartState(sinkState)__		};compiles,the,given,pattern,into,a,link,nfafactory,the,nfa,factory,can,be,used,to,create,multiple,nfas;void,compile,factory,if,current,pattern,get,quantifier,get,consuming,strategy,quantifier,consuming,strategy,throw,new,malformed,pattern,exception,not,followed,by,is,not,supported,as,a,last,part,of,a,pattern,check,pattern,name,uniqueness,check,pattern,skip,strategy,state,t,sink,state,create,ending,state,sink,state,create,middle,states,sink,state,create,start,state,sink,state
NFACompiler -> NFAFactoryCompiler -> void compileFactory();1528989005;Compiles the given pattern into a {@link NFAFactory}. The NFA factory can be used to create_multiple NFAs.;void compileFactory() {_			if (currentPattern.getQuantifier().getConsumingStrategy() == Quantifier.ConsumingStrategy.NOT_FOLLOW) {_				throw new MalformedPatternException("NotFollowedBy is not supported as a last part of a Pattern!")__			}__			checkPatternNameUniqueness()___			checkPatternSkipStrategy()___			_			State<T> sinkState = createEndingState()__			_			sinkState = createMiddleStates(sinkState)__			_			createStartState(sinkState)__		};compiles,the,given,pattern,into,a,link,nfafactory,the,nfa,factory,can,be,used,to,create,multiple,nfas;void,compile,factory,if,current,pattern,get,quantifier,get,consuming,strategy,quantifier,consuming,strategy,throw,new,malformed,pattern,exception,not,followed,by,is,not,supported,as,a,last,part,of,a,pattern,check,pattern,name,uniqueness,check,pattern,skip,strategy,state,t,sink,state,create,ending,state,sink,state,create,middle,states,sink,state,create,start,state,sink,state
NFACompiler -> NFAFactoryCompiler -> void compileFactory();1538745898;Compiles the given pattern into a {@link NFAFactory}. The NFA factory can be used to create_multiple NFAs.;void compileFactory() {_			if (currentPattern.getQuantifier().getConsumingStrategy() == Quantifier.ConsumingStrategy.NOT_FOLLOW) {_				throw new MalformedPatternException("NotFollowedBy is not supported as a last part of a Pattern!")__			}__			checkPatternNameUniqueness()___			checkPatternSkipStrategy()___			_			State<T> sinkState = createEndingState()__			_			sinkState = createMiddleStates(sinkState)__			_			createStartState(sinkState)__		};compiles,the,given,pattern,into,a,link,nfafactory,the,nfa,factory,can,be,used,to,create,multiple,nfas;void,compile,factory,if,current,pattern,get,quantifier,get,consuming,strategy,quantifier,consuming,strategy,throw,new,malformed,pattern,exception,not,followed,by,is,not,supported,as,a,last,part,of,a,pattern,check,pattern,name,uniqueness,check,pattern,skip,strategy,state,t,sink,state,create,ending,state,sink,state,create,middle,states,sink,state,create,start,state,sink,state
NFACompiler -> NFAFactoryCompiler -> void compileFactory();1542293931;Compiles the given pattern into a {@link NFAFactory}. The NFA factory can be used to create_multiple NFAs.;void compileFactory() {_			if (currentPattern.getQuantifier().getConsumingStrategy() == Quantifier.ConsumingStrategy.NOT_FOLLOW) {_				throw new MalformedPatternException("NotFollowedBy is not supported as a last part of a Pattern!")__			}__			checkPatternNameUniqueness()___			checkPatternSkipStrategy()___			_			State<T> sinkState = createEndingState()__			_			sinkState = createMiddleStates(sinkState)__			_			createStartState(sinkState)__		};compiles,the,given,pattern,into,a,link,nfafactory,the,nfa,factory,can,be,used,to,create,multiple,nfas;void,compile,factory,if,current,pattern,get,quantifier,get,consuming,strategy,quantifier,consuming,strategy,throw,new,malformed,pattern,exception,not,followed,by,is,not,supported,as,a,last,part,of,a,pattern,check,pattern,name,uniqueness,check,pattern,skip,strategy,state,t,sink,state,create,ending,state,sink,state,create,middle,states,sink,state,create,start,state,sink,state
NFACompiler -> NFAFactoryCompiler -> private IterativeCondition<T> getIgnoreCondition(Pattern<T, ?> pattern);1490194327;@return The {@link IterativeCondition condition} for the {@code IGNORE} edge_that corresponds to the specified {@link Pattern}. If the pattern is_{@link QuantifierProperty#EAGER}, the negated user-specified condition is_returned. In other case, a condition that always evaluated to {@code true} is_returned.;private IterativeCondition<T> getIgnoreCondition(Pattern<T, ?> pattern) {_			return pattern.getQuantifier().hasProperty(QuantifierProperty.EAGER)_					? new NotCondition<>((IterativeCondition<T>) pattern.getCondition())_					: BooleanConditions.<T>trueFunction()__		};return,the,link,iterative,condition,condition,for,the,code,ignore,edge,that,corresponds,to,the,specified,link,pattern,if,the,pattern,is,link,quantifier,property,eager,the,negated,user,specified,condition,is,returned,in,other,case,a,condition,that,always,evaluated,to,code,true,is,returned;private,iterative,condition,t,get,ignore,condition,pattern,t,pattern,return,pattern,get,quantifier,has,property,quantifier,property,eager,new,not,condition,iterative,condition,t,pattern,get,condition,boolean,conditions,t,true,function
NFACompiler -> NFAFactoryCompiler -> private IterativeCondition<T> getIgnoreCondition(Pattern<T, ?> pattern);1490619911;@return The {@link IterativeCondition condition} for the {@code IGNORE} edge_that corresponds to the specified {@link Pattern}. If the pattern is_{@link QuantifierProperty#EAGER}, the negated user-specified condition is_returned. In other case, a condition that always evaluated to {@code true} is_returned.;private IterativeCondition<T> getIgnoreCondition(Pattern<T, ?> pattern) {_			return pattern.getQuantifier().hasProperty(QuantifierProperty.EAGER)_					? new NotCondition<>((IterativeCondition<T>) pattern.getCondition())_					: BooleanConditions.<T>trueFunction()__		};return,the,link,iterative,condition,condition,for,the,code,ignore,edge,that,corresponds,to,the,specified,link,pattern,if,the,pattern,is,link,quantifier,property,eager,the,negated,user,specified,condition,is,returned,in,other,case,a,condition,that,always,evaluated,to,code,true,is,returned;private,iterative,condition,t,get,ignore,condition,pattern,t,pattern,return,pattern,get,quantifier,has,property,quantifier,property,eager,new,not,condition,iterative,condition,t,pattern,get,condition,boolean,conditions,t,true,function
NFACompiler -> NFAFactoryCompiler -> private IterativeCondition<T> getIgnoreCondition(Pattern<T, ?> pattern);1491320734;@return The {@link IterativeCondition condition} for the {@code IGNORE} edge_that corresponds to the specified {@link Pattern}. If the pattern is_{@link QuantifierProperty#EAGER}, the negated user-specified condition is_returned. In other case, a condition that always evaluated to {@code true} is_returned.;private IterativeCondition<T> getIgnoreCondition(Pattern<T, ?> pattern) {_			return pattern.getQuantifier().hasProperty(QuantifierProperty.EAGER)_					? new NotCondition<>((IterativeCondition<T>) pattern.getCondition())_					: BooleanConditions.<T>trueFunction()__		};return,the,link,iterative,condition,condition,for,the,code,ignore,edge,that,corresponds,to,the,specified,link,pattern,if,the,pattern,is,link,quantifier,property,eager,the,negated,user,specified,condition,is,returned,in,other,case,a,condition,that,always,evaluated,to,code,true,is,returned;private,iterative,condition,t,get,ignore,condition,pattern,t,pattern,return,pattern,get,quantifier,has,property,quantifier,property,eager,new,not,condition,iterative,condition,t,pattern,get,condition,boolean,conditions,t,true,function
NFACompiler -> NFAFactoryCompiler -> private IterativeCondition<T> getIgnoreCondition(Pattern<T, ?> pattern);1491323030;@return The {@link IterativeCondition condition} for the {@code IGNORE} edge_that corresponds to the specified {@link Pattern}. If the pattern is_{@link QuantifierProperty#EAGER}, the negated user-specified condition is_returned. In other case, a condition that always evaluated to {@code true} is_returned.;private IterativeCondition<T> getIgnoreCondition(Pattern<T, ?> pattern) {_			return pattern.getQuantifier().hasProperty(QuantifierProperty.EAGER)_					? new NotCondition<>((IterativeCondition<T>) pattern.getCondition())_					: BooleanConditions.<T>trueFunction()__		};return,the,link,iterative,condition,condition,for,the,code,ignore,edge,that,corresponds,to,the,specified,link,pattern,if,the,pattern,is,link,quantifier,property,eager,the,negated,user,specified,condition,is,returned,in,other,case,a,condition,that,always,evaluated,to,code,true,is,returned;private,iterative,condition,t,get,ignore,condition,pattern,t,pattern,return,pattern,get,quantifier,has,property,quantifier,property,eager,new,not,condition,iterative,condition,t,pattern,get,condition,boolean,conditions,t,true,function
NFACompiler -> NFAFactoryCompiler -> private IterativeCondition<T> getIgnoreCondition(Pattern<T, ?> pattern);1491633862;@return The {@link IterativeCondition condition} for the {@code IGNORE} edge_that corresponds to the specified {@link Pattern}. If the pattern is_{@link QuantifierProperty#EAGER}, the negated user-specified condition is_returned. In other case, a condition that always evaluated to {@code true} is_returned.;private IterativeCondition<T> getIgnoreCondition(Pattern<T, ?> pattern) {_			return pattern.getQuantifier().hasProperty(QuantifierProperty.EAGER)_					? new NotCondition<>((IterativeCondition<T>) pattern.getCondition())_					: BooleanConditions.<T>trueFunction()__		};return,the,link,iterative,condition,condition,for,the,code,ignore,edge,that,corresponds,to,the,specified,link,pattern,if,the,pattern,is,link,quantifier,property,eager,the,negated,user,specified,condition,is,returned,in,other,case,a,condition,that,always,evaluated,to,code,true,is,returned;private,iterative,condition,t,get,ignore,condition,pattern,t,pattern,return,pattern,get,quantifier,has,property,quantifier,property,eager,new,not,condition,iterative,condition,t,pattern,get,condition,boolean,conditions,t,true,function
NFACompiler -> NFAFactoryCompiler -> private IterativeCondition<T> getIgnoreCondition(Pattern<T, ?> pattern);1492797583;@return The {@link IterativeCondition condition} for the {@code IGNORE} edge_that corresponds to the specified {@link Pattern}. If the pattern is_{@link QuantifierProperty#EAGER}, the negated user-specified condition is_returned. In other case, a condition that always evaluated to {@code true} is_returned.;private IterativeCondition<T> getIgnoreCondition(Pattern<T, ?> pattern) {_			return pattern.getQuantifier().hasProperty(QuantifierProperty.EAGER)_					? new NotCondition<>((IterativeCondition<T>) pattern.getCondition())_					: BooleanConditions.<T>trueFunction()__		};return,the,link,iterative,condition,condition,for,the,code,ignore,edge,that,corresponds,to,the,specified,link,pattern,if,the,pattern,is,link,quantifier,property,eager,the,negated,user,specified,condition,is,returned,in,other,case,a,condition,that,always,evaluated,to,code,true,is,returned;private,iterative,condition,t,get,ignore,condition,pattern,t,pattern,return,pattern,get,quantifier,has,property,quantifier,property,eager,new,not,condition,iterative,condition,t,pattern,get,condition,boolean,conditions,t,true,function
NFACompiler -> NFAFactoryCompiler -> private List<Tuple2<IterativeCondition<T>, String>> getCurrentNotCondition();1493385877;Retrieves list of conditions resulting in Stop state and names of the corresponding NOT patterns.__<p>A current not condition can be produced in two cases:_<ol>_<li>the previous pattern is a {@link Quantifier.ConsumingStrategy#NOT_FOLLOW}</li>_<li>exists a backward path of {@link Quantifier.QuantifierProperty#OPTIONAL} patterns to_{@link Quantifier.ConsumingStrategy#NOT_FOLLOW}</li>_</ol>__<p><b>WARNING:</b> for more info on the second case see: {@link NFAFactoryCompiler#copyWithoutTransitiveNots(State)}__@return list of not conditions with corresponding names;private List<Tuple2<IterativeCondition<T>, String>> getCurrentNotCondition() {_			List<Tuple2<IterativeCondition<T>, String>> notConditions = new ArrayList<>()___			Pattern<T, ? extends T> previousPattern = currentPattern__			while (previousPattern.getPrevious() != null && (_				previousPattern.getPrevious().getQuantifier().hasProperty(Quantifier.QuantifierProperty.OPTIONAL) ||_				previousPattern.getPrevious().getQuantifier().getConsumingStrategy() == Quantifier.ConsumingStrategy.NOT_FOLLOW)) {__				previousPattern = previousPattern.getPrevious()___				if (previousPattern.getQuantifier().getConsumingStrategy() == Quantifier.ConsumingStrategy.NOT_FOLLOW) {_					final IterativeCondition<T> notCondition = (IterativeCondition<T>) previousPattern.getCondition()__					notConditions.add(Tuple2.of(notCondition, previousPattern.getName()))__				}_			}_			return notConditions__		};retrieves,list,of,conditions,resulting,in,stop,state,and,names,of,the,corresponding,not,patterns,p,a,current,not,condition,can,be,produced,in,two,cases,ol,li,the,previous,pattern,is,a,link,quantifier,consuming,strategy,li,li,exists,a,backward,path,of,link,quantifier,quantifier,property,optional,patterns,to,link,quantifier,consuming,strategy,li,ol,p,b,warning,b,for,more,info,on,the,second,case,see,link,nfafactory,compiler,copy,without,transitive,nots,state,return,list,of,not,conditions,with,corresponding,names;private,list,tuple2,iterative,condition,t,string,get,current,not,condition,list,tuple2,iterative,condition,t,string,not,conditions,new,array,list,pattern,t,extends,t,previous,pattern,current,pattern,while,previous,pattern,get,previous,null,previous,pattern,get,previous,get,quantifier,has,property,quantifier,quantifier,property,optional,previous,pattern,get,previous,get,quantifier,get,consuming,strategy,quantifier,consuming,strategy,previous,pattern,previous,pattern,get,previous,if,previous,pattern,get,quantifier,get,consuming,strategy,quantifier,consuming,strategy,final,iterative,condition,t,not,condition,iterative,condition,t,previous,pattern,get,condition,not,conditions,add,tuple2,of,not,condition,previous,pattern,get,name,return,not,conditions
NFACompiler -> NFAFactoryCompiler -> private List<Tuple2<IterativeCondition<T>, String>> getCurrentNotCondition();1494947249;Retrieves list of conditions resulting in Stop state and names of the corresponding NOT patterns.__<p>A current not condition can be produced in two cases:_<ol>_<li>the previous pattern is a {@link Quantifier.ConsumingStrategy#NOT_FOLLOW}</li>_<li>exists a backward path of {@link Quantifier.QuantifierProperty#OPTIONAL} patterns to_{@link Quantifier.ConsumingStrategy#NOT_FOLLOW}</li>_</ol>__<p><b>WARNING:</b> for more info on the second case see: {@link NFAFactoryCompiler#copyWithoutTransitiveNots(State)}__@return list of not conditions with corresponding names;private List<Tuple2<IterativeCondition<T>, String>> getCurrentNotCondition() {_			List<Tuple2<IterativeCondition<T>, String>> notConditions = new ArrayList<>()___			Pattern<T, ? extends T> previousPattern = currentPattern__			while (previousPattern.getPrevious() != null && (_				previousPattern.getPrevious().getQuantifier().hasProperty(Quantifier.QuantifierProperty.OPTIONAL) ||_				previousPattern.getPrevious().getQuantifier().getConsumingStrategy() == Quantifier.ConsumingStrategy.NOT_FOLLOW)) {__				previousPattern = previousPattern.getPrevious()___				if (previousPattern.getQuantifier().getConsumingStrategy() == Quantifier.ConsumingStrategy.NOT_FOLLOW) {_					final IterativeCondition<T> notCondition = (IterativeCondition<T>) previousPattern.getCondition()__					notConditions.add(Tuple2.of(notCondition, previousPattern.getName()))__				}_			}_			return notConditions__		};retrieves,list,of,conditions,resulting,in,stop,state,and,names,of,the,corresponding,not,patterns,p,a,current,not,condition,can,be,produced,in,two,cases,ol,li,the,previous,pattern,is,a,link,quantifier,consuming,strategy,li,li,exists,a,backward,path,of,link,quantifier,quantifier,property,optional,patterns,to,link,quantifier,consuming,strategy,li,ol,p,b,warning,b,for,more,info,on,the,second,case,see,link,nfafactory,compiler,copy,without,transitive,nots,state,return,list,of,not,conditions,with,corresponding,names;private,list,tuple2,iterative,condition,t,string,get,current,not,condition,list,tuple2,iterative,condition,t,string,not,conditions,new,array,list,pattern,t,extends,t,previous,pattern,current,pattern,while,previous,pattern,get,previous,null,previous,pattern,get,previous,get,quantifier,has,property,quantifier,quantifier,property,optional,previous,pattern,get,previous,get,quantifier,get,consuming,strategy,quantifier,consuming,strategy,previous,pattern,previous,pattern,get,previous,if,previous,pattern,get,quantifier,get,consuming,strategy,quantifier,consuming,strategy,final,iterative,condition,t,not,condition,iterative,condition,t,previous,pattern,get,condition,not,conditions,add,tuple2,of,not,condition,previous,pattern,get,name,return,not,conditions
NFACompiler -> NFAFactoryCompiler -> private List<Tuple2<IterativeCondition<T>, String>> getCurrentNotCondition();1495657626;Retrieves list of conditions resulting in Stop state and names of the corresponding NOT patterns.__<p>A current not condition can be produced in two cases:_<ol>_<li>the previous pattern is a {@link Quantifier.ConsumingStrategy#NOT_FOLLOW}</li>_<li>exists a backward path of {@link Quantifier.QuantifierProperty#OPTIONAL} patterns to_{@link Quantifier.ConsumingStrategy#NOT_FOLLOW}</li>_</ol>__<p><b>WARNING:</b> for more info on the second case see: {@link NFAFactoryCompiler#copyWithoutTransitiveNots(State)}__@return list of not conditions with corresponding names;private List<Tuple2<IterativeCondition<T>, String>> getCurrentNotCondition() {_			List<Tuple2<IterativeCondition<T>, String>> notConditions = new ArrayList<>()___			Pattern<T, ? extends T> previousPattern = currentPattern__			while (previousPattern.getPrevious() != null && (_				previousPattern.getPrevious().getQuantifier().hasProperty(Quantifier.QuantifierProperty.OPTIONAL) ||_				previousPattern.getPrevious().getQuantifier().getConsumingStrategy() == Quantifier.ConsumingStrategy.NOT_FOLLOW)) {__				previousPattern = previousPattern.getPrevious()___				if (previousPattern.getQuantifier().getConsumingStrategy() == Quantifier.ConsumingStrategy.NOT_FOLLOW) {_					final IterativeCondition<T> notCondition = (IterativeCondition<T>) previousPattern.getCondition()__					notConditions.add(Tuple2.of(notCondition, previousPattern.getName()))__				}_			}_			return notConditions__		};retrieves,list,of,conditions,resulting,in,stop,state,and,names,of,the,corresponding,not,patterns,p,a,current,not,condition,can,be,produced,in,two,cases,ol,li,the,previous,pattern,is,a,link,quantifier,consuming,strategy,li,li,exists,a,backward,path,of,link,quantifier,quantifier,property,optional,patterns,to,link,quantifier,consuming,strategy,li,ol,p,b,warning,b,for,more,info,on,the,second,case,see,link,nfafactory,compiler,copy,without,transitive,nots,state,return,list,of,not,conditions,with,corresponding,names;private,list,tuple2,iterative,condition,t,string,get,current,not,condition,list,tuple2,iterative,condition,t,string,not,conditions,new,array,list,pattern,t,extends,t,previous,pattern,current,pattern,while,previous,pattern,get,previous,null,previous,pattern,get,previous,get,quantifier,has,property,quantifier,quantifier,property,optional,previous,pattern,get,previous,get,quantifier,get,consuming,strategy,quantifier,consuming,strategy,previous,pattern,previous,pattern,get,previous,if,previous,pattern,get,quantifier,get,consuming,strategy,quantifier,consuming,strategy,final,iterative,condition,t,not,condition,iterative,condition,t,previous,pattern,get,condition,not,conditions,add,tuple2,of,not,condition,previous,pattern,get,name,return,not,conditions
NFACompiler -> NFAFactoryCompiler -> private List<Tuple2<IterativeCondition<T>, String>> getCurrentNotCondition();1496245714;Retrieves list of conditions resulting in Stop state and names of the corresponding NOT patterns.__<p>A current not condition can be produced in two cases:_<ol>_<li>the previous pattern is a {@link Quantifier.ConsumingStrategy#NOT_FOLLOW}</li>_<li>exists a backward path of {@link Quantifier.QuantifierProperty#OPTIONAL} patterns to_{@link Quantifier.ConsumingStrategy#NOT_FOLLOW}</li>_</ol>__<p><b>WARNING:</b> for more info on the second case see: {@link NFAFactoryCompiler#copyWithoutTransitiveNots(State)}__@return list of not conditions with corresponding names;private List<Tuple2<IterativeCondition<T>, String>> getCurrentNotCondition() {_			List<Tuple2<IterativeCondition<T>, String>> notConditions = new ArrayList<>()___			Pattern<T, ? extends T> previousPattern = currentPattern__			while (previousPattern.getPrevious() != null && (_				previousPattern.getPrevious().getQuantifier().hasProperty(Quantifier.QuantifierProperty.OPTIONAL) ||_				previousPattern.getPrevious().getQuantifier().getConsumingStrategy() == Quantifier.ConsumingStrategy.NOT_FOLLOW)) {__				previousPattern = previousPattern.getPrevious()___				if (previousPattern.getQuantifier().getConsumingStrategy() == Quantifier.ConsumingStrategy.NOT_FOLLOW) {_					final IterativeCondition<T> notCondition = (IterativeCondition<T>) previousPattern.getCondition()__					notConditions.add(Tuple2.of(notCondition, previousPattern.getName()))__				}_			}_			return notConditions__		};retrieves,list,of,conditions,resulting,in,stop,state,and,names,of,the,corresponding,not,patterns,p,a,current,not,condition,can,be,produced,in,two,cases,ol,li,the,previous,pattern,is,a,link,quantifier,consuming,strategy,li,li,exists,a,backward,path,of,link,quantifier,quantifier,property,optional,patterns,to,link,quantifier,consuming,strategy,li,ol,p,b,warning,b,for,more,info,on,the,second,case,see,link,nfafactory,compiler,copy,without,transitive,nots,state,return,list,of,not,conditions,with,corresponding,names;private,list,tuple2,iterative,condition,t,string,get,current,not,condition,list,tuple2,iterative,condition,t,string,not,conditions,new,array,list,pattern,t,extends,t,previous,pattern,current,pattern,while,previous,pattern,get,previous,null,previous,pattern,get,previous,get,quantifier,has,property,quantifier,quantifier,property,optional,previous,pattern,get,previous,get,quantifier,get,consuming,strategy,quantifier,consuming,strategy,previous,pattern,previous,pattern,get,previous,if,previous,pattern,get,quantifier,get,consuming,strategy,quantifier,consuming,strategy,final,iterative,condition,t,not,condition,iterative,condition,t,previous,pattern,get,condition,not,conditions,add,tuple2,of,not,condition,previous,pattern,get,name,return,not,conditions
NFACompiler -> NFAFactoryCompiler -> private List<Tuple2<IterativeCondition<T>, String>> getCurrentNotCondition();1497410381;Retrieves list of conditions resulting in Stop state and names of the corresponding NOT patterns.__<p>A current not condition can be produced in two cases:_<ol>_<li>the previous pattern is a {@link Quantifier.ConsumingStrategy#NOT_FOLLOW}</li>_<li>exists a backward path of {@link Quantifier.QuantifierProperty#OPTIONAL} patterns to_{@link Quantifier.ConsumingStrategy#NOT_FOLLOW}</li>_</ol>__<p><b>WARNING:</b> for more info on the second case see: {@link NFAFactoryCompiler#copyWithoutTransitiveNots(State)}__@return list of not conditions with corresponding names;private List<Tuple2<IterativeCondition<T>, String>> getCurrentNotCondition() {_			List<Tuple2<IterativeCondition<T>, String>> notConditions = new ArrayList<>()___			Pattern<T, ? extends T> previousPattern = currentPattern__			while (previousPattern.getPrevious() != null && (_				previousPattern.getPrevious().getQuantifier().hasProperty(Quantifier.QuantifierProperty.OPTIONAL) ||_				previousPattern.getPrevious().getQuantifier().getConsumingStrategy() == Quantifier.ConsumingStrategy.NOT_FOLLOW)) {__				previousPattern = previousPattern.getPrevious()___				if (previousPattern.getQuantifier().getConsumingStrategy() == Quantifier.ConsumingStrategy.NOT_FOLLOW) {_					final IterativeCondition<T> notCondition = (IterativeCondition<T>) previousPattern.getCondition()__					notConditions.add(Tuple2.of(notCondition, previousPattern.getName()))__				}_			}_			return notConditions__		};retrieves,list,of,conditions,resulting,in,stop,state,and,names,of,the,corresponding,not,patterns,p,a,current,not,condition,can,be,produced,in,two,cases,ol,li,the,previous,pattern,is,a,link,quantifier,consuming,strategy,li,li,exists,a,backward,path,of,link,quantifier,quantifier,property,optional,patterns,to,link,quantifier,consuming,strategy,li,ol,p,b,warning,b,for,more,info,on,the,second,case,see,link,nfafactory,compiler,copy,without,transitive,nots,state,return,list,of,not,conditions,with,corresponding,names;private,list,tuple2,iterative,condition,t,string,get,current,not,condition,list,tuple2,iterative,condition,t,string,not,conditions,new,array,list,pattern,t,extends,t,previous,pattern,current,pattern,while,previous,pattern,get,previous,null,previous,pattern,get,previous,get,quantifier,has,property,quantifier,quantifier,property,optional,previous,pattern,get,previous,get,quantifier,get,consuming,strategy,quantifier,consuming,strategy,previous,pattern,previous,pattern,get,previous,if,previous,pattern,get,quantifier,get,consuming,strategy,quantifier,consuming,strategy,final,iterative,condition,t,not,condition,iterative,condition,t,previous,pattern,get,condition,not,conditions,add,tuple2,of,not,condition,previous,pattern,get,name,return,not,conditions
NFACompiler -> NFAFactoryCompiler -> private List<Tuple2<IterativeCondition<T>, String>> getCurrentNotCondition();1497883202;Retrieves list of conditions resulting in Stop state and names of the corresponding NOT patterns.__<p>A current not condition can be produced in two cases:_<ol>_<li>the previous pattern is a {@link Quantifier.ConsumingStrategy#NOT_FOLLOW}</li>_<li>exists a backward path of {@link Quantifier.QuantifierProperty#OPTIONAL} patterns to_{@link Quantifier.ConsumingStrategy#NOT_FOLLOW}</li>_</ol>__<p><b>WARNING:</b> for more info on the second case see: {@link NFAFactoryCompiler#copyWithoutTransitiveNots(State)}__@return list of not conditions with corresponding names;private List<Tuple2<IterativeCondition<T>, String>> getCurrentNotCondition() {_			List<Tuple2<IterativeCondition<T>, String>> notConditions = new ArrayList<>()___			Pattern<T, ? extends T> previousPattern = currentPattern__			while (previousPattern.getPrevious() != null && (_				previousPattern.getPrevious().getQuantifier().hasProperty(Quantifier.QuantifierProperty.OPTIONAL) ||_				previousPattern.getPrevious().getQuantifier().getConsumingStrategy() == Quantifier.ConsumingStrategy.NOT_FOLLOW)) {__				previousPattern = previousPattern.getPrevious()___				if (previousPattern.getQuantifier().getConsumingStrategy() == Quantifier.ConsumingStrategy.NOT_FOLLOW) {_					final IterativeCondition<T> notCondition = (IterativeCondition<T>) previousPattern.getCondition()__					notConditions.add(Tuple2.of(notCondition, previousPattern.getName()))__				}_			}_			return notConditions__		};retrieves,list,of,conditions,resulting,in,stop,state,and,names,of,the,corresponding,not,patterns,p,a,current,not,condition,can,be,produced,in,two,cases,ol,li,the,previous,pattern,is,a,link,quantifier,consuming,strategy,li,li,exists,a,backward,path,of,link,quantifier,quantifier,property,optional,patterns,to,link,quantifier,consuming,strategy,li,ol,p,b,warning,b,for,more,info,on,the,second,case,see,link,nfafactory,compiler,copy,without,transitive,nots,state,return,list,of,not,conditions,with,corresponding,names;private,list,tuple2,iterative,condition,t,string,get,current,not,condition,list,tuple2,iterative,condition,t,string,not,conditions,new,array,list,pattern,t,extends,t,previous,pattern,current,pattern,while,previous,pattern,get,previous,null,previous,pattern,get,previous,get,quantifier,has,property,quantifier,quantifier,property,optional,previous,pattern,get,previous,get,quantifier,get,consuming,strategy,quantifier,consuming,strategy,previous,pattern,previous,pattern,get,previous,if,previous,pattern,get,quantifier,get,consuming,strategy,quantifier,consuming,strategy,final,iterative,condition,t,not,condition,iterative,condition,t,previous,pattern,get,condition,not,conditions,add,tuple2,of,not,condition,previous,pattern,get,name,return,not,conditions
NFACompiler -> NFAFactoryCompiler -> private List<Tuple2<IterativeCondition<T>, String>> getCurrentNotCondition();1498034481;Retrieves list of conditions resulting in Stop state and names of the corresponding NOT patterns.__<p>A current not condition can be produced in two cases:_<ol>_<li>the previous pattern is a {@link Quantifier.ConsumingStrategy#NOT_FOLLOW}</li>_<li>exists a backward path of {@link Quantifier.QuantifierProperty#OPTIONAL} patterns to_{@link Quantifier.ConsumingStrategy#NOT_FOLLOW}</li>_</ol>__<p><b>WARNING:</b> for more info on the second case see: {@link NFAFactoryCompiler#copyWithoutTransitiveNots(State)}__@return list of not conditions with corresponding names;private List<Tuple2<IterativeCondition<T>, String>> getCurrentNotCondition() {_			List<Tuple2<IterativeCondition<T>, String>> notConditions = new ArrayList<>()___			Pattern<T, ? extends T> previousPattern = currentPattern__			while (previousPattern.getPrevious() != null && (_				previousPattern.getPrevious().getQuantifier().hasProperty(Quantifier.QuantifierProperty.OPTIONAL) ||_				previousPattern.getPrevious().getQuantifier().getConsumingStrategy() == Quantifier.ConsumingStrategy.NOT_FOLLOW)) {__				previousPattern = previousPattern.getPrevious()___				if (previousPattern.getQuantifier().getConsumingStrategy() == Quantifier.ConsumingStrategy.NOT_FOLLOW) {_					final IterativeCondition<T> notCondition = getTakeCondition(previousPattern)__					notConditions.add(Tuple2.of(notCondition, previousPattern.getName()))__				}_			}_			return notConditions__		};retrieves,list,of,conditions,resulting,in,stop,state,and,names,of,the,corresponding,not,patterns,p,a,current,not,condition,can,be,produced,in,two,cases,ol,li,the,previous,pattern,is,a,link,quantifier,consuming,strategy,li,li,exists,a,backward,path,of,link,quantifier,quantifier,property,optional,patterns,to,link,quantifier,consuming,strategy,li,ol,p,b,warning,b,for,more,info,on,the,second,case,see,link,nfafactory,compiler,copy,without,transitive,nots,state,return,list,of,not,conditions,with,corresponding,names;private,list,tuple2,iterative,condition,t,string,get,current,not,condition,list,tuple2,iterative,condition,t,string,not,conditions,new,array,list,pattern,t,extends,t,previous,pattern,current,pattern,while,previous,pattern,get,previous,null,previous,pattern,get,previous,get,quantifier,has,property,quantifier,quantifier,property,optional,previous,pattern,get,previous,get,quantifier,get,consuming,strategy,quantifier,consuming,strategy,previous,pattern,previous,pattern,get,previous,if,previous,pattern,get,quantifier,get,consuming,strategy,quantifier,consuming,strategy,final,iterative,condition,t,not,condition,get,take,condition,previous,pattern,not,conditions,add,tuple2,of,not,condition,previous,pattern,get,name,return,not,conditions
NFACompiler -> NFAFactoryCompiler -> private List<Tuple2<IterativeCondition<T>, String>> getCurrentNotCondition();1499760222;Retrieves list of conditions resulting in Stop state and names of the corresponding NOT patterns.__<p>A current not condition can be produced in two cases:_<ol>_<li>the previous pattern is a {@link Quantifier.ConsumingStrategy#NOT_FOLLOW}</li>_<li>exists a backward path of {@link Quantifier.QuantifierProperty#OPTIONAL} patterns to_{@link Quantifier.ConsumingStrategy#NOT_FOLLOW}</li>_</ol>__<p><b>WARNING:</b> for more info on the second case see: {@link NFAFactoryCompiler#copyWithoutTransitiveNots(State)}__@return list of not conditions with corresponding names;private List<Tuple2<IterativeCondition<T>, String>> getCurrentNotCondition() {_			List<Tuple2<IterativeCondition<T>, String>> notConditions = new ArrayList<>()___			Pattern<T, ? extends T> previousPattern = currentPattern__			while (previousPattern.getPrevious() != null && (_				previousPattern.getPrevious().getQuantifier().hasProperty(Quantifier.QuantifierProperty.OPTIONAL) ||_				previousPattern.getPrevious().getQuantifier().getConsumingStrategy() == Quantifier.ConsumingStrategy.NOT_FOLLOW)) {__				previousPattern = previousPattern.getPrevious()___				if (previousPattern.getQuantifier().getConsumingStrategy() == Quantifier.ConsumingStrategy.NOT_FOLLOW) {_					final IterativeCondition<T> notCondition = getTakeCondition(previousPattern)__					notConditions.add(Tuple2.of(notCondition, previousPattern.getName()))__				}_			}_			return notConditions__		};retrieves,list,of,conditions,resulting,in,stop,state,and,names,of,the,corresponding,not,patterns,p,a,current,not,condition,can,be,produced,in,two,cases,ol,li,the,previous,pattern,is,a,link,quantifier,consuming,strategy,li,li,exists,a,backward,path,of,link,quantifier,quantifier,property,optional,patterns,to,link,quantifier,consuming,strategy,li,ol,p,b,warning,b,for,more,info,on,the,second,case,see,link,nfafactory,compiler,copy,without,transitive,nots,state,return,list,of,not,conditions,with,corresponding,names;private,list,tuple2,iterative,condition,t,string,get,current,not,condition,list,tuple2,iterative,condition,t,string,not,conditions,new,array,list,pattern,t,extends,t,previous,pattern,current,pattern,while,previous,pattern,get,previous,null,previous,pattern,get,previous,get,quantifier,has,property,quantifier,quantifier,property,optional,previous,pattern,get,previous,get,quantifier,get,consuming,strategy,quantifier,consuming,strategy,previous,pattern,previous,pattern,get,previous,if,previous,pattern,get,quantifier,get,consuming,strategy,quantifier,consuming,strategy,final,iterative,condition,t,not,condition,get,take,condition,previous,pattern,not,conditions,add,tuple2,of,not,condition,previous,pattern,get,name,return,not,conditions
NFACompiler -> NFAFactoryCompiler -> private List<Tuple2<IterativeCondition<T>, String>> getCurrentNotCondition();1499937690;Retrieves list of conditions resulting in Stop state and names of the corresponding NOT patterns.__<p>A current not condition can be produced in two cases:_<ol>_<li>the previous pattern is a {@link Quantifier.ConsumingStrategy#NOT_FOLLOW}</li>_<li>exists a backward path of {@link Quantifier.QuantifierProperty#OPTIONAL} patterns to_{@link Quantifier.ConsumingStrategy#NOT_FOLLOW}</li>_</ol>__<p><b>WARNING:</b> for more info on the second case see: {@link NFAFactoryCompiler#copyWithoutTransitiveNots(State)}__@return list of not conditions with corresponding names;private List<Tuple2<IterativeCondition<T>, String>> getCurrentNotCondition() {_			List<Tuple2<IterativeCondition<T>, String>> notConditions = new ArrayList<>()___			Pattern<T, ? extends T> previousPattern = currentPattern__			while (previousPattern.getPrevious() != null && (_				previousPattern.getPrevious().getQuantifier().hasProperty(Quantifier.QuantifierProperty.OPTIONAL) ||_				previousPattern.getPrevious().getQuantifier().getConsumingStrategy() == Quantifier.ConsumingStrategy.NOT_FOLLOW)) {__				previousPattern = previousPattern.getPrevious()___				if (previousPattern.getQuantifier().getConsumingStrategy() == Quantifier.ConsumingStrategy.NOT_FOLLOW) {_					final IterativeCondition<T> notCondition = getTakeCondition(previousPattern)__					notConditions.add(Tuple2.of(notCondition, previousPattern.getName()))__				}_			}_			return notConditions__		};retrieves,list,of,conditions,resulting,in,stop,state,and,names,of,the,corresponding,not,patterns,p,a,current,not,condition,can,be,produced,in,two,cases,ol,li,the,previous,pattern,is,a,link,quantifier,consuming,strategy,li,li,exists,a,backward,path,of,link,quantifier,quantifier,property,optional,patterns,to,link,quantifier,consuming,strategy,li,ol,p,b,warning,b,for,more,info,on,the,second,case,see,link,nfafactory,compiler,copy,without,transitive,nots,state,return,list,of,not,conditions,with,corresponding,names;private,list,tuple2,iterative,condition,t,string,get,current,not,condition,list,tuple2,iterative,condition,t,string,not,conditions,new,array,list,pattern,t,extends,t,previous,pattern,current,pattern,while,previous,pattern,get,previous,null,previous,pattern,get,previous,get,quantifier,has,property,quantifier,quantifier,property,optional,previous,pattern,get,previous,get,quantifier,get,consuming,strategy,quantifier,consuming,strategy,previous,pattern,previous,pattern,get,previous,if,previous,pattern,get,quantifier,get,consuming,strategy,quantifier,consuming,strategy,final,iterative,condition,t,not,condition,get,take,condition,previous,pattern,not,conditions,add,tuple2,of,not,condition,previous,pattern,get,name,return,not,conditions
NFACompiler -> NFAFactoryCompiler -> private List<Tuple2<IterativeCondition<T>, String>> getCurrentNotCondition();1500021711;Retrieves list of conditions resulting in Stop state and names of the corresponding NOT patterns.__<p>A current not condition can be produced in two cases:_<ol>_<li>the previous pattern is a {@link Quantifier.ConsumingStrategy#NOT_FOLLOW}</li>_<li>exists a backward path of {@link Quantifier.QuantifierProperty#OPTIONAL} patterns to_{@link Quantifier.ConsumingStrategy#NOT_FOLLOW}</li>_</ol>__<p><b>WARNING:</b> for more info on the second case see: {@link NFAFactoryCompiler#copyWithoutTransitiveNots(State)}__@return list of not conditions with corresponding names;private List<Tuple2<IterativeCondition<T>, String>> getCurrentNotCondition() {_			List<Tuple2<IterativeCondition<T>, String>> notConditions = new ArrayList<>()___			Pattern<T, ? extends T> previousPattern = currentPattern__			while (previousPattern.getPrevious() != null && (_				previousPattern.getPrevious().getQuantifier().hasProperty(Quantifier.QuantifierProperty.OPTIONAL) ||_				previousPattern.getPrevious().getQuantifier().getConsumingStrategy() == Quantifier.ConsumingStrategy.NOT_FOLLOW)) {__				previousPattern = previousPattern.getPrevious()___				if (previousPattern.getQuantifier().getConsumingStrategy() == Quantifier.ConsumingStrategy.NOT_FOLLOW) {_					final IterativeCondition<T> notCondition = getTakeCondition(previousPattern)__					notConditions.add(Tuple2.of(notCondition, previousPattern.getName()))__				}_			}_			return notConditions__		};retrieves,list,of,conditions,resulting,in,stop,state,and,names,of,the,corresponding,not,patterns,p,a,current,not,condition,can,be,produced,in,two,cases,ol,li,the,previous,pattern,is,a,link,quantifier,consuming,strategy,li,li,exists,a,backward,path,of,link,quantifier,quantifier,property,optional,patterns,to,link,quantifier,consuming,strategy,li,ol,p,b,warning,b,for,more,info,on,the,second,case,see,link,nfafactory,compiler,copy,without,transitive,nots,state,return,list,of,not,conditions,with,corresponding,names;private,list,tuple2,iterative,condition,t,string,get,current,not,condition,list,tuple2,iterative,condition,t,string,not,conditions,new,array,list,pattern,t,extends,t,previous,pattern,current,pattern,while,previous,pattern,get,previous,null,previous,pattern,get,previous,get,quantifier,has,property,quantifier,quantifier,property,optional,previous,pattern,get,previous,get,quantifier,get,consuming,strategy,quantifier,consuming,strategy,previous,pattern,previous,pattern,get,previous,if,previous,pattern,get,quantifier,get,consuming,strategy,quantifier,consuming,strategy,final,iterative,condition,t,not,condition,get,take,condition,previous,pattern,not,conditions,add,tuple2,of,not,condition,previous,pattern,get,name,return,not,conditions
NFACompiler -> NFAFactoryCompiler -> private List<Tuple2<IterativeCondition<T>, String>> getCurrentNotCondition();1501592283;Retrieves list of conditions resulting in Stop state and names of the corresponding NOT patterns.__<p>A current not condition can be produced in two cases:_<ol>_<li>the previous pattern is a {@link Quantifier.ConsumingStrategy#NOT_FOLLOW}</li>_<li>exists a backward path of {@link Quantifier.QuantifierProperty#OPTIONAL} patterns to_{@link Quantifier.ConsumingStrategy#NOT_FOLLOW}</li>_</ol>__<p><b>WARNING:</b> for more info on the second case see: {@link NFAFactoryCompiler#copyWithoutTransitiveNots(State)}__@return list of not conditions with corresponding names;private List<Tuple2<IterativeCondition<T>, String>> getCurrentNotCondition() {_			List<Tuple2<IterativeCondition<T>, String>> notConditions = new ArrayList<>()___			Pattern<T, ? extends T> previousPattern = currentPattern__			while (previousPattern.getPrevious() != null && (_				previousPattern.getPrevious().getQuantifier().hasProperty(Quantifier.QuantifierProperty.OPTIONAL) ||_				previousPattern.getPrevious().getQuantifier().getConsumingStrategy() == Quantifier.ConsumingStrategy.NOT_FOLLOW)) {__				previousPattern = previousPattern.getPrevious()___				if (previousPattern.getQuantifier().getConsumingStrategy() == Quantifier.ConsumingStrategy.NOT_FOLLOW) {_					final IterativeCondition<T> notCondition = getTakeCondition(previousPattern)__					notConditions.add(Tuple2.of(notCondition, previousPattern.getName()))__				}_			}_			return notConditions__		};retrieves,list,of,conditions,resulting,in,stop,state,and,names,of,the,corresponding,not,patterns,p,a,current,not,condition,can,be,produced,in,two,cases,ol,li,the,previous,pattern,is,a,link,quantifier,consuming,strategy,li,li,exists,a,backward,path,of,link,quantifier,quantifier,property,optional,patterns,to,link,quantifier,consuming,strategy,li,ol,p,b,warning,b,for,more,info,on,the,second,case,see,link,nfafactory,compiler,copy,without,transitive,nots,state,return,list,of,not,conditions,with,corresponding,names;private,list,tuple2,iterative,condition,t,string,get,current,not,condition,list,tuple2,iterative,condition,t,string,not,conditions,new,array,list,pattern,t,extends,t,previous,pattern,current,pattern,while,previous,pattern,get,previous,null,previous,pattern,get,previous,get,quantifier,has,property,quantifier,quantifier,property,optional,previous,pattern,get,previous,get,quantifier,get,consuming,strategy,quantifier,consuming,strategy,previous,pattern,previous,pattern,get,previous,if,previous,pattern,get,quantifier,get,consuming,strategy,quantifier,consuming,strategy,final,iterative,condition,t,not,condition,get,take,condition,previous,pattern,not,conditions,add,tuple2,of,not,condition,previous,pattern,get,name,return,not,conditions
NFACompiler -> NFAFactoryCompiler -> private List<Tuple2<IterativeCondition<T>, String>> getCurrentNotCondition();1502422141;Retrieves list of conditions resulting in Stop state and names of the corresponding NOT patterns.__<p>A current not condition can be produced in two cases:_<ol>_<li>the previous pattern is a {@link Quantifier.ConsumingStrategy#NOT_FOLLOW}</li>_<li>exists a backward path of {@link Quantifier.QuantifierProperty#OPTIONAL} patterns to_{@link Quantifier.ConsumingStrategy#NOT_FOLLOW}</li>_</ol>__<p><b>WARNING:</b> for more info on the second case see: {@link NFAFactoryCompiler#copyWithoutTransitiveNots(State)}__@return list of not conditions with corresponding names;private List<Tuple2<IterativeCondition<T>, String>> getCurrentNotCondition() {_			List<Tuple2<IterativeCondition<T>, String>> notConditions = new ArrayList<>()___			Pattern<T, ? extends T> previousPattern = currentPattern__			while (previousPattern.getPrevious() != null && (_				previousPattern.getPrevious().getQuantifier().hasProperty(Quantifier.QuantifierProperty.OPTIONAL) ||_				previousPattern.getPrevious().getQuantifier().getConsumingStrategy() == Quantifier.ConsumingStrategy.NOT_FOLLOW)) {__				previousPattern = previousPattern.getPrevious()___				if (previousPattern.getQuantifier().getConsumingStrategy() == Quantifier.ConsumingStrategy.NOT_FOLLOW) {_					final IterativeCondition<T> notCondition = getTakeCondition(previousPattern)__					notConditions.add(Tuple2.of(notCondition, previousPattern.getName()))__				}_			}_			return notConditions__		};retrieves,list,of,conditions,resulting,in,stop,state,and,names,of,the,corresponding,not,patterns,p,a,current,not,condition,can,be,produced,in,two,cases,ol,li,the,previous,pattern,is,a,link,quantifier,consuming,strategy,li,li,exists,a,backward,path,of,link,quantifier,quantifier,property,optional,patterns,to,link,quantifier,consuming,strategy,li,ol,p,b,warning,b,for,more,info,on,the,second,case,see,link,nfafactory,compiler,copy,without,transitive,nots,state,return,list,of,not,conditions,with,corresponding,names;private,list,tuple2,iterative,condition,t,string,get,current,not,condition,list,tuple2,iterative,condition,t,string,not,conditions,new,array,list,pattern,t,extends,t,previous,pattern,current,pattern,while,previous,pattern,get,previous,null,previous,pattern,get,previous,get,quantifier,has,property,quantifier,quantifier,property,optional,previous,pattern,get,previous,get,quantifier,get,consuming,strategy,quantifier,consuming,strategy,previous,pattern,previous,pattern,get,previous,if,previous,pattern,get,quantifier,get,consuming,strategy,quantifier,consuming,strategy,final,iterative,condition,t,not,condition,get,take,condition,previous,pattern,not,conditions,add,tuple2,of,not,condition,previous,pattern,get,name,return,not,conditions
NFACompiler -> NFAFactoryCompiler -> private List<Tuple2<IterativeCondition<T>, String>> getCurrentNotCondition();1503588494;Retrieves list of conditions resulting in Stop state and names of the corresponding NOT patterns.__<p>A current not condition can be produced in two cases:_<ol>_<li>the previous pattern is a {@link Quantifier.ConsumingStrategy#NOT_FOLLOW}</li>_<li>exists a backward path of {@link Quantifier.QuantifierProperty#OPTIONAL} patterns to_{@link Quantifier.ConsumingStrategy#NOT_FOLLOW}</li>_</ol>__<p><b>WARNING:</b> for more info on the second case see: {@link NFAFactoryCompiler#copyWithoutTransitiveNots(State)}__@return list of not conditions with corresponding names;private List<Tuple2<IterativeCondition<T>, String>> getCurrentNotCondition() {_			List<Tuple2<IterativeCondition<T>, String>> notConditions = new ArrayList<>()___			Pattern<T, ? extends T> previousPattern = currentPattern__			while (previousPattern.getPrevious() != null && (_				previousPattern.getPrevious().getQuantifier().hasProperty(Quantifier.QuantifierProperty.OPTIONAL) ||_				previousPattern.getPrevious().getQuantifier().getConsumingStrategy() == Quantifier.ConsumingStrategy.NOT_FOLLOW)) {__				previousPattern = previousPattern.getPrevious()___				if (previousPattern.getQuantifier().getConsumingStrategy() == Quantifier.ConsumingStrategy.NOT_FOLLOW) {_					final IterativeCondition<T> notCondition = getTakeCondition(previousPattern)__					notConditions.add(Tuple2.of(notCondition, previousPattern.getName()))__				}_			}_			return notConditions__		};retrieves,list,of,conditions,resulting,in,stop,state,and,names,of,the,corresponding,not,patterns,p,a,current,not,condition,can,be,produced,in,two,cases,ol,li,the,previous,pattern,is,a,link,quantifier,consuming,strategy,li,li,exists,a,backward,path,of,link,quantifier,quantifier,property,optional,patterns,to,link,quantifier,consuming,strategy,li,ol,p,b,warning,b,for,more,info,on,the,second,case,see,link,nfafactory,compiler,copy,without,transitive,nots,state,return,list,of,not,conditions,with,corresponding,names;private,list,tuple2,iterative,condition,t,string,get,current,not,condition,list,tuple2,iterative,condition,t,string,not,conditions,new,array,list,pattern,t,extends,t,previous,pattern,current,pattern,while,previous,pattern,get,previous,null,previous,pattern,get,previous,get,quantifier,has,property,quantifier,quantifier,property,optional,previous,pattern,get,previous,get,quantifier,get,consuming,strategy,quantifier,consuming,strategy,previous,pattern,previous,pattern,get,previous,if,previous,pattern,get,quantifier,get,consuming,strategy,quantifier,consuming,strategy,final,iterative,condition,t,not,condition,get,take,condition,previous,pattern,not,conditions,add,tuple2,of,not,condition,previous,pattern,get,name,return,not,conditions
NFACompiler -> NFAFactoryCompiler -> private List<Tuple2<IterativeCondition<T>, String>> getCurrentNotCondition();1518008111;Retrieves list of conditions resulting in Stop state and names of the corresponding NOT patterns.__<p>A current not condition can be produced in two cases:_<ol>_<li>the previous pattern is a {@link Quantifier.ConsumingStrategy#NOT_FOLLOW}</li>_<li>exists a backward path of {@link Quantifier.QuantifierProperty#OPTIONAL} patterns to_{@link Quantifier.ConsumingStrategy#NOT_FOLLOW}</li>_</ol>__<p><b>WARNING:</b> for more info on the second case see: {@link NFAFactoryCompiler#copyWithoutTransitiveNots(State)}__@return list of not conditions with corresponding names;private List<Tuple2<IterativeCondition<T>, String>> getCurrentNotCondition() {_			List<Tuple2<IterativeCondition<T>, String>> notConditions = new ArrayList<>()___			Pattern<T, ? extends T> previousPattern = currentPattern__			while (previousPattern.getPrevious() != null && (_				previousPattern.getPrevious().getQuantifier().hasProperty(Quantifier.QuantifierProperty.OPTIONAL) ||_				previousPattern.getPrevious().getQuantifier().getConsumingStrategy() == Quantifier.ConsumingStrategy.NOT_FOLLOW)) {__				previousPattern = previousPattern.getPrevious()___				if (previousPattern.getQuantifier().getConsumingStrategy() == Quantifier.ConsumingStrategy.NOT_FOLLOW) {_					final IterativeCondition<T> notCondition = getTakeCondition(previousPattern)__					notConditions.add(Tuple2.of(notCondition, previousPattern.getName()))__				}_			}_			return notConditions__		};retrieves,list,of,conditions,resulting,in,stop,state,and,names,of,the,corresponding,not,patterns,p,a,current,not,condition,can,be,produced,in,two,cases,ol,li,the,previous,pattern,is,a,link,quantifier,consuming,strategy,li,li,exists,a,backward,path,of,link,quantifier,quantifier,property,optional,patterns,to,link,quantifier,consuming,strategy,li,ol,p,b,warning,b,for,more,info,on,the,second,case,see,link,nfafactory,compiler,copy,without,transitive,nots,state,return,list,of,not,conditions,with,corresponding,names;private,list,tuple2,iterative,condition,t,string,get,current,not,condition,list,tuple2,iterative,condition,t,string,not,conditions,new,array,list,pattern,t,extends,t,previous,pattern,current,pattern,while,previous,pattern,get,previous,null,previous,pattern,get,previous,get,quantifier,has,property,quantifier,quantifier,property,optional,previous,pattern,get,previous,get,quantifier,get,consuming,strategy,quantifier,consuming,strategy,previous,pattern,previous,pattern,get,previous,if,previous,pattern,get,quantifier,get,consuming,strategy,quantifier,consuming,strategy,final,iterative,condition,t,not,condition,get,take,condition,previous,pattern,not,conditions,add,tuple2,of,not,condition,previous,pattern,get,name,return,not,conditions
NFACompiler -> NFAFactoryCompiler -> private List<Tuple2<IterativeCondition<T>, String>> getCurrentNotCondition();1527863170;Retrieves list of conditions resulting in Stop state and names of the corresponding NOT patterns.__<p>A current not condition can be produced in two cases:_<ol>_<li>the previous pattern is a {@link Quantifier.ConsumingStrategy#NOT_FOLLOW}</li>_<li>exists a backward path of {@link Quantifier.QuantifierProperty#OPTIONAL} patterns to_{@link Quantifier.ConsumingStrategy#NOT_FOLLOW}</li>_</ol>__<p><b>WARNING:</b> for more info on the second case see: {@link NFAFactoryCompiler#copyWithoutTransitiveNots(State)}__@return list of not conditions with corresponding names;private List<Tuple2<IterativeCondition<T>, String>> getCurrentNotCondition() {_			List<Tuple2<IterativeCondition<T>, String>> notConditions = new ArrayList<>()___			Pattern<T, ? extends T> previousPattern = currentPattern__			while (previousPattern.getPrevious() != null && (_				previousPattern.getPrevious().getQuantifier().hasProperty(Quantifier.QuantifierProperty.OPTIONAL) ||_				previousPattern.getPrevious().getQuantifier().getConsumingStrategy() == Quantifier.ConsumingStrategy.NOT_FOLLOW)) {__				previousPattern = previousPattern.getPrevious()___				if (previousPattern.getQuantifier().getConsumingStrategy() == Quantifier.ConsumingStrategy.NOT_FOLLOW) {_					final IterativeCondition<T> notCondition = getTakeCondition(previousPattern)__					notConditions.add(Tuple2.of(notCondition, previousPattern.getName()))__				}_			}_			return notConditions__		};retrieves,list,of,conditions,resulting,in,stop,state,and,names,of,the,corresponding,not,patterns,p,a,current,not,condition,can,be,produced,in,two,cases,ol,li,the,previous,pattern,is,a,link,quantifier,consuming,strategy,li,li,exists,a,backward,path,of,link,quantifier,quantifier,property,optional,patterns,to,link,quantifier,consuming,strategy,li,ol,p,b,warning,b,for,more,info,on,the,second,case,see,link,nfafactory,compiler,copy,without,transitive,nots,state,return,list,of,not,conditions,with,corresponding,names;private,list,tuple2,iterative,condition,t,string,get,current,not,condition,list,tuple2,iterative,condition,t,string,not,conditions,new,array,list,pattern,t,extends,t,previous,pattern,current,pattern,while,previous,pattern,get,previous,null,previous,pattern,get,previous,get,quantifier,has,property,quantifier,quantifier,property,optional,previous,pattern,get,previous,get,quantifier,get,consuming,strategy,quantifier,consuming,strategy,previous,pattern,previous,pattern,get,previous,if,previous,pattern,get,quantifier,get,consuming,strategy,quantifier,consuming,strategy,final,iterative,condition,t,not,condition,get,take,condition,previous,pattern,not,conditions,add,tuple2,of,not,condition,previous,pattern,get,name,return,not,conditions
NFACompiler -> NFAFactoryCompiler -> private List<Tuple2<IterativeCondition<T>, String>> getCurrentNotCondition();1528989005;Retrieves list of conditions resulting in Stop state and names of the corresponding NOT patterns.__<p>A current not condition can be produced in two cases:_<ol>_<li>the previous pattern is a {@link Quantifier.ConsumingStrategy#NOT_FOLLOW}</li>_<li>exists a backward path of {@link Quantifier.QuantifierProperty#OPTIONAL} patterns to_{@link Quantifier.ConsumingStrategy#NOT_FOLLOW}</li>_</ol>__<p><b>WARNING:</b> for more info on the second case see: {@link NFAFactoryCompiler#copyWithoutTransitiveNots(State)}__@return list of not conditions with corresponding names;private List<Tuple2<IterativeCondition<T>, String>> getCurrentNotCondition() {_			List<Tuple2<IterativeCondition<T>, String>> notConditions = new ArrayList<>()___			Pattern<T, ? extends T> previousPattern = currentPattern__			while (previousPattern.getPrevious() != null && (_				previousPattern.getPrevious().getQuantifier().hasProperty(Quantifier.QuantifierProperty.OPTIONAL) ||_				previousPattern.getPrevious().getQuantifier().getConsumingStrategy() == Quantifier.ConsumingStrategy.NOT_FOLLOW)) {__				previousPattern = previousPattern.getPrevious()___				if (previousPattern.getQuantifier().getConsumingStrategy() == Quantifier.ConsumingStrategy.NOT_FOLLOW) {_					final IterativeCondition<T> notCondition = getTakeCondition(previousPattern)__					notConditions.add(Tuple2.of(notCondition, previousPattern.getName()))__				}_			}_			return notConditions__		};retrieves,list,of,conditions,resulting,in,stop,state,and,names,of,the,corresponding,not,patterns,p,a,current,not,condition,can,be,produced,in,two,cases,ol,li,the,previous,pattern,is,a,link,quantifier,consuming,strategy,li,li,exists,a,backward,path,of,link,quantifier,quantifier,property,optional,patterns,to,link,quantifier,consuming,strategy,li,ol,p,b,warning,b,for,more,info,on,the,second,case,see,link,nfafactory,compiler,copy,without,transitive,nots,state,return,list,of,not,conditions,with,corresponding,names;private,list,tuple2,iterative,condition,t,string,get,current,not,condition,list,tuple2,iterative,condition,t,string,not,conditions,new,array,list,pattern,t,extends,t,previous,pattern,current,pattern,while,previous,pattern,get,previous,null,previous,pattern,get,previous,get,quantifier,has,property,quantifier,quantifier,property,optional,previous,pattern,get,previous,get,quantifier,get,consuming,strategy,quantifier,consuming,strategy,previous,pattern,previous,pattern,get,previous,if,previous,pattern,get,quantifier,get,consuming,strategy,quantifier,consuming,strategy,final,iterative,condition,t,not,condition,get,take,condition,previous,pattern,not,conditions,add,tuple2,of,not,condition,previous,pattern,get,name,return,not,conditions
NFACompiler -> NFAFactoryCompiler -> private List<Tuple2<IterativeCondition<T>, String>> getCurrentNotCondition();1538745898;Retrieves list of conditions resulting in Stop state and names of the corresponding NOT patterns.__<p>A current not condition can be produced in two cases:_<ol>_<li>the previous pattern is a {@link Quantifier.ConsumingStrategy#NOT_FOLLOW}</li>_<li>exists a backward path of {@link Quantifier.QuantifierProperty#OPTIONAL} patterns to_{@link Quantifier.ConsumingStrategy#NOT_FOLLOW}</li>_</ol>__<p><b>WARNING:</b> for more info on the second case see: {@link NFAFactoryCompiler#copyWithoutTransitiveNots(State)}__@return list of not conditions with corresponding names;private List<Tuple2<IterativeCondition<T>, String>> getCurrentNotCondition() {_			List<Tuple2<IterativeCondition<T>, String>> notConditions = new ArrayList<>()___			Pattern<T, ? extends T> previousPattern = currentPattern__			while (previousPattern.getPrevious() != null && (_				previousPattern.getPrevious().getQuantifier().hasProperty(Quantifier.QuantifierProperty.OPTIONAL) ||_				previousPattern.getPrevious().getQuantifier().getConsumingStrategy() == Quantifier.ConsumingStrategy.NOT_FOLLOW)) {__				previousPattern = previousPattern.getPrevious()___				if (previousPattern.getQuantifier().getConsumingStrategy() == Quantifier.ConsumingStrategy.NOT_FOLLOW) {_					final IterativeCondition<T> notCondition = getTakeCondition(previousPattern)__					notConditions.add(Tuple2.of(notCondition, previousPattern.getName()))__				}_			}_			return notConditions__		};retrieves,list,of,conditions,resulting,in,stop,state,and,names,of,the,corresponding,not,patterns,p,a,current,not,condition,can,be,produced,in,two,cases,ol,li,the,previous,pattern,is,a,link,quantifier,consuming,strategy,li,li,exists,a,backward,path,of,link,quantifier,quantifier,property,optional,patterns,to,link,quantifier,consuming,strategy,li,ol,p,b,warning,b,for,more,info,on,the,second,case,see,link,nfafactory,compiler,copy,without,transitive,nots,state,return,list,of,not,conditions,with,corresponding,names;private,list,tuple2,iterative,condition,t,string,get,current,not,condition,list,tuple2,iterative,condition,t,string,not,conditions,new,array,list,pattern,t,extends,t,previous,pattern,current,pattern,while,previous,pattern,get,previous,null,previous,pattern,get,previous,get,quantifier,has,property,quantifier,quantifier,property,optional,previous,pattern,get,previous,get,quantifier,get,consuming,strategy,quantifier,consuming,strategy,previous,pattern,previous,pattern,get,previous,if,previous,pattern,get,quantifier,get,consuming,strategy,quantifier,consuming,strategy,final,iterative,condition,t,not,condition,get,take,condition,previous,pattern,not,conditions,add,tuple2,of,not,condition,previous,pattern,get,name,return,not,conditions
NFACompiler -> NFAFactoryCompiler -> private List<Tuple2<IterativeCondition<T>, String>> getCurrentNotCondition();1542293931;Retrieves list of conditions resulting in Stop state and names of the corresponding NOT patterns.__<p>A current not condition can be produced in two cases:_<ol>_<li>the previous pattern is a {@link Quantifier.ConsumingStrategy#NOT_FOLLOW}</li>_<li>exists a backward path of {@link Quantifier.QuantifierProperty#OPTIONAL} patterns to_{@link Quantifier.ConsumingStrategy#NOT_FOLLOW}</li>_</ol>__<p><b>WARNING:</b> for more info on the second case see: {@link NFAFactoryCompiler#copyWithoutTransitiveNots(State)}__@return list of not conditions with corresponding names;private List<Tuple2<IterativeCondition<T>, String>> getCurrentNotCondition() {_			List<Tuple2<IterativeCondition<T>, String>> notConditions = new ArrayList<>()___			Pattern<T, ? extends T> previousPattern = currentPattern__			while (previousPattern.getPrevious() != null && (_				previousPattern.getPrevious().getQuantifier().hasProperty(Quantifier.QuantifierProperty.OPTIONAL) ||_				previousPattern.getPrevious().getQuantifier().getConsumingStrategy() == Quantifier.ConsumingStrategy.NOT_FOLLOW)) {__				previousPattern = previousPattern.getPrevious()___				if (previousPattern.getQuantifier().getConsumingStrategy() == Quantifier.ConsumingStrategy.NOT_FOLLOW) {_					final IterativeCondition<T> notCondition = getTakeCondition(previousPattern)__					notConditions.add(Tuple2.of(notCondition, previousPattern.getName()))__				}_			}_			return notConditions__		};retrieves,list,of,conditions,resulting,in,stop,state,and,names,of,the,corresponding,not,patterns,p,a,current,not,condition,can,be,produced,in,two,cases,ol,li,the,previous,pattern,is,a,link,quantifier,consuming,strategy,li,li,exists,a,backward,path,of,link,quantifier,quantifier,property,optional,patterns,to,link,quantifier,consuming,strategy,li,ol,p,b,warning,b,for,more,info,on,the,second,case,see,link,nfafactory,compiler,copy,without,transitive,nots,state,return,list,of,not,conditions,with,corresponding,names;private,list,tuple2,iterative,condition,t,string,get,current,not,condition,list,tuple2,iterative,condition,t,string,not,conditions,new,array,list,pattern,t,extends,t,previous,pattern,current,pattern,while,previous,pattern,get,previous,null,previous,pattern,get,previous,get,quantifier,has,property,quantifier,quantifier,property,optional,previous,pattern,get,previous,get,quantifier,get,consuming,strategy,quantifier,consuming,strategy,previous,pattern,previous,pattern,get,previous,if,previous,pattern,get,quantifier,get,consuming,strategy,quantifier,consuming,strategy,final,iterative,condition,t,not,condition,get,take,condition,previous,pattern,not,conditions,add,tuple2,of,not,condition,previous,pattern,get,name,return,not,conditions
NFACompiler -> NFAFactoryCompiler -> private State<T> createState(String name, State.StateType stateType);1494947249;Creates a state with {@link State.StateType#Normal} and adds it to the collection of created states._Should be used instead of instantiating with new operator.__@return the created state;private State<T> createState(String name, State.StateType stateType) {_			String stateName = getUniqueInternalStateName(name)__			usedNames.add(stateName)__			State<T> state = new State<>(stateName, stateType)__			states.add(state)__			return state__		};creates,a,state,with,link,state,state,type,normal,and,adds,it,to,the,collection,of,created,states,should,be,used,instead,of,instantiating,with,new,operator,return,the,created,state;private,state,t,create,state,string,name,state,state,type,state,type,string,state,name,get,unique,internal,state,name,name,used,names,add,state,name,state,t,state,new,state,state,name,state,type,states,add,state,return,state
NFACompiler -> NFAFactoryCompiler -> private State<T> createState(String name, State.StateType stateType);1495657626;Creates a state with {@link State.StateType#Normal} and adds it to the collection of created states._Should be used instead of instantiating with new operator.__@return the created state;private State<T> createState(String name, State.StateType stateType) {_			String stateName = getUniqueInternalStateName(name)__			usedNames.add(stateName)__			State<T> state = new State<>(stateName, stateType)__			states.add(state)__			return state__		};creates,a,state,with,link,state,state,type,normal,and,adds,it,to,the,collection,of,created,states,should,be,used,instead,of,instantiating,with,new,operator,return,the,created,state;private,state,t,create,state,string,name,state,state,type,state,type,string,state,name,get,unique,internal,state,name,name,used,names,add,state,name,state,t,state,new,state,state,name,state,type,states,add,state,return,state
NFACompiler -> NFAFactoryCompiler -> private State<T> createState(String name, State.StateType stateType);1496245714;Creates a state with {@link State.StateType#Normal} and adds it to the collection of created states._Should be used instead of instantiating with new operator.__@return the created state;private State<T> createState(String name, State.StateType stateType) {_			String stateName = stateNameHandler.getUniqueInternalName(name)__			State<T> state = new State<>(stateName, stateType)__			states.add(state)__			return state__		};creates,a,state,with,link,state,state,type,normal,and,adds,it,to,the,collection,of,created,states,should,be,used,instead,of,instantiating,with,new,operator,return,the,created,state;private,state,t,create,state,string,name,state,state,type,state,type,string,state,name,state,name,handler,get,unique,internal,name,name,state,t,state,new,state,state,name,state,type,states,add,state,return,state
NFACompiler -> NFAFactoryCompiler -> private State<T> createState(String name, State.StateType stateType);1497410381;Creates a state with {@link State.StateType#Normal} and adds it to the collection of created states._Should be used instead of instantiating with new operator.__@return the created state;private State<T> createState(String name, State.StateType stateType) {_			String stateName = stateNameHandler.getUniqueInternalName(name)__			State<T> state = new State<>(stateName, stateType)__			states.add(state)__			return state__		};creates,a,state,with,link,state,state,type,normal,and,adds,it,to,the,collection,of,created,states,should,be,used,instead,of,instantiating,with,new,operator,return,the,created,state;private,state,t,create,state,string,name,state,state,type,state,type,string,state,name,state,name,handler,get,unique,internal,name,name,state,t,state,new,state,state,name,state,type,states,add,state,return,state
NFACompiler -> NFAFactoryCompiler -> private State<T> createState(String name, State.StateType stateType);1497883202;Creates a state with {@link State.StateType#Normal} and adds it to the collection of created states._Should be used instead of instantiating with new operator.__@return the created state;private State<T> createState(String name, State.StateType stateType) {_			String stateName = stateNameHandler.getUniqueInternalName(name)__			State<T> state = new State<>(stateName, stateType)__			states.add(state)__			return state__		};creates,a,state,with,link,state,state,type,normal,and,adds,it,to,the,collection,of,created,states,should,be,used,instead,of,instantiating,with,new,operator,return,the,created,state;private,state,t,create,state,string,name,state,state,type,state,type,string,state,name,state,name,handler,get,unique,internal,name,name,state,t,state,new,state,state,name,state,type,states,add,state,return,state
NFACompiler -> NFAFactoryCompiler -> private State<T> createState(String name, State.StateType stateType);1498034481;Creates a state with {@link State.StateType#Normal} and adds it to the collection of created states._Should be used instead of instantiating with new operator.__@return the created state;private State<T> createState(String name, State.StateType stateType) {_			String stateName = stateNameHandler.getUniqueInternalName(name)__			State<T> state = new State<>(stateName, stateType)__			states.add(state)__			return state__		};creates,a,state,with,link,state,state,type,normal,and,adds,it,to,the,collection,of,created,states,should,be,used,instead,of,instantiating,with,new,operator,return,the,created,state;private,state,t,create,state,string,name,state,state,type,state,type,string,state,name,state,name,handler,get,unique,internal,name,name,state,t,state,new,state,state,name,state,type,states,add,state,return,state
NFACompiler -> NFAFactoryCompiler -> private State<T> createState(String name, State.StateType stateType);1499760222;Creates a state with {@link State.StateType#Normal} and adds it to the collection of created states._Should be used instead of instantiating with new operator.__@return the created state;private State<T> createState(String name, State.StateType stateType) {_			String stateName = stateNameHandler.getUniqueInternalName(name)__			State<T> state = new State<>(stateName, stateType)__			states.add(state)__			return state__		};creates,a,state,with,link,state,state,type,normal,and,adds,it,to,the,collection,of,created,states,should,be,used,instead,of,instantiating,with,new,operator,return,the,created,state;private,state,t,create,state,string,name,state,state,type,state,type,string,state,name,state,name,handler,get,unique,internal,name,name,state,t,state,new,state,state,name,state,type,states,add,state,return,state
NFACompiler -> NFAFactoryCompiler -> private State<T> createState(String name, State.StateType stateType);1499937690;Creates a state with {@link State.StateType#Normal} and adds it to the collection of created states._Should be used instead of instantiating with new operator.__@return the created state;private State<T> createState(String name, State.StateType stateType) {_			String stateName = stateNameHandler.getUniqueInternalName(name)__			State<T> state = new State<>(stateName, stateType)__			states.add(state)__			return state__		};creates,a,state,with,link,state,state,type,normal,and,adds,it,to,the,collection,of,created,states,should,be,used,instead,of,instantiating,with,new,operator,return,the,created,state;private,state,t,create,state,string,name,state,state,type,state,type,string,state,name,state,name,handler,get,unique,internal,name,name,state,t,state,new,state,state,name,state,type,states,add,state,return,state
NFACompiler -> NFAFactoryCompiler -> private State<T> createState(String name, State.StateType stateType);1500021711;Creates a state with {@link State.StateType#Normal} and adds it to the collection of created states._Should be used instead of instantiating with new operator.__@return the created state;private State<T> createState(String name, State.StateType stateType) {_			String stateName = stateNameHandler.getUniqueInternalName(name)__			State<T> state = new State<>(stateName, stateType)__			states.add(state)__			return state__		};creates,a,state,with,link,state,state,type,normal,and,adds,it,to,the,collection,of,created,states,should,be,used,instead,of,instantiating,with,new,operator,return,the,created,state;private,state,t,create,state,string,name,state,state,type,state,type,string,state,name,state,name,handler,get,unique,internal,name,name,state,t,state,new,state,state,name,state,type,states,add,state,return,state
NFACompiler -> NFAFactoryCompiler -> private State<T> createState(String name, State.StateType stateType);1501592283;Creates a state with {@link State.StateType#Normal} and adds it to the collection of created states._Should be used instead of instantiating with new operator.__@return the created state;private State<T> createState(String name, State.StateType stateType) {_			String stateName = stateNameHandler.getUniqueInternalName(name)__			State<T> state = new State<>(stateName, stateType)__			states.add(state)__			return state__		};creates,a,state,with,link,state,state,type,normal,and,adds,it,to,the,collection,of,created,states,should,be,used,instead,of,instantiating,with,new,operator,return,the,created,state;private,state,t,create,state,string,name,state,state,type,state,type,string,state,name,state,name,handler,get,unique,internal,name,name,state,t,state,new,state,state,name,state,type,states,add,state,return,state
NFACompiler -> NFAFactoryCompiler -> private State<T> createState(String name, State.StateType stateType);1502422141;Creates a state with {@link State.StateType#Normal} and adds it to the collection of created states._Should be used instead of instantiating with new operator.__@return the created state;private State<T> createState(String name, State.StateType stateType) {_			String stateName = stateNameHandler.getUniqueInternalName(name)__			State<T> state = new State<>(stateName, stateType)__			states.add(state)__			return state__		};creates,a,state,with,link,state,state,type,normal,and,adds,it,to,the,collection,of,created,states,should,be,used,instead,of,instantiating,with,new,operator,return,the,created,state;private,state,t,create,state,string,name,state,state,type,state,type,string,state,name,state,name,handler,get,unique,internal,name,name,state,t,state,new,state,state,name,state,type,states,add,state,return,state
NFACompiler -> NFAFactoryCompiler -> private State<T> createState(String name, State.StateType stateType);1503588494;Creates a state with {@link State.StateType#Normal} and adds it to the collection of created states._Should be used instead of instantiating with new operator.__@return the created state;private State<T> createState(String name, State.StateType stateType) {_			String stateName = stateNameHandler.getUniqueInternalName(name)__			State<T> state = new State<>(stateName, stateType)__			states.add(state)__			return state__		};creates,a,state,with,link,state,state,type,normal,and,adds,it,to,the,collection,of,created,states,should,be,used,instead,of,instantiating,with,new,operator,return,the,created,state;private,state,t,create,state,string,name,state,state,type,state,type,string,state,name,state,name,handler,get,unique,internal,name,name,state,t,state,new,state,state,name,state,type,states,add,state,return,state
NFACompiler -> NFAFactoryCompiler -> private State<T> createState(String name, State.StateType stateType);1518008111;Creates a state with {@link State.StateType#Normal} and adds it to the collection of created states._Should be used instead of instantiating with new operator.__@return the created state;private State<T> createState(String name, State.StateType stateType) {_			String stateName = stateNameHandler.getUniqueInternalName(name)__			State<T> state = new State<>(stateName, stateType)__			states.add(state)__			return state__		};creates,a,state,with,link,state,state,type,normal,and,adds,it,to,the,collection,of,created,states,should,be,used,instead,of,instantiating,with,new,operator,return,the,created,state;private,state,t,create,state,string,name,state,state,type,state,type,string,state,name,state,name,handler,get,unique,internal,name,name,state,t,state,new,state,state,name,state,type,states,add,state,return,state
NFACompiler -> NFAFactoryCompiler -> private State<T> createState(String name, State.StateType stateType);1527863170;Creates a state with {@link State.StateType#Normal} and adds it to the collection of created states._Should be used instead of instantiating with new operator.__@return the created state;private State<T> createState(String name, State.StateType stateType) {_			String stateName = stateNameHandler.getUniqueInternalName(name)__			State<T> state = new State<>(stateName, stateType)__			states.add(state)__			return state__		};creates,a,state,with,link,state,state,type,normal,and,adds,it,to,the,collection,of,created,states,should,be,used,instead,of,instantiating,with,new,operator,return,the,created,state;private,state,t,create,state,string,name,state,state,type,state,type,string,state,name,state,name,handler,get,unique,internal,name,name,state,t,state,new,state,state,name,state,type,states,add,state,return,state
NFACompiler -> NFAFactoryCompiler -> private State<T> createState(String name, State.StateType stateType);1528989005;Creates a state with {@link State.StateType#Normal} and adds it to the collection of created states._Should be used instead of instantiating with new operator.__@return the created state;private State<T> createState(String name, State.StateType stateType) {_			String stateName = stateNameHandler.getUniqueInternalName(name)__			State<T> state = new State<>(stateName, stateType)__			states.add(state)__			return state__		};creates,a,state,with,link,state,state,type,normal,and,adds,it,to,the,collection,of,created,states,should,be,used,instead,of,instantiating,with,new,operator,return,the,created,state;private,state,t,create,state,string,name,state,state,type,state,type,string,state,name,state,name,handler,get,unique,internal,name,name,state,t,state,new,state,state,name,state,type,states,add,state,return,state
NFACompiler -> NFAFactoryCompiler -> private State<T> createState(String name, State.StateType stateType);1538745898;Creates a state with {@link State.StateType#Normal} and adds it to the collection of created states._Should be used instead of instantiating with new operator.__@return the created state;private State<T> createState(String name, State.StateType stateType) {_			String stateName = stateNameHandler.getUniqueInternalName(name)__			State<T> state = new State<>(stateName, stateType)__			states.add(state)__			return state__		};creates,a,state,with,link,state,state,type,normal,and,adds,it,to,the,collection,of,created,states,should,be,used,instead,of,instantiating,with,new,operator,return,the,created,state;private,state,t,create,state,string,name,state,state,type,state,type,string,state,name,state,name,handler,get,unique,internal,name,name,state,t,state,new,state,state,name,state,type,states,add,state,return,state
NFACompiler -> NFAFactoryCompiler -> private State<T> createState(String name, State.StateType stateType);1542293931;Creates a state with {@link State.StateType#Normal} and adds it to the collection of created states._Should be used instead of instantiating with new operator.__@return the created state;private State<T> createState(String name, State.StateType stateType) {_			String stateName = stateNameHandler.getUniqueInternalName(name)__			State<T> state = new State<>(stateName, stateType)__			states.add(state)__			return state__		};creates,a,state,with,link,state,state,type,normal,and,adds,it,to,the,collection,of,created,states,should,be,used,instead,of,instantiating,with,new,operator,return,the,created,state;private,state,t,create,state,string,name,state,state,type,state,type,string,state,name,state,name,handler,get,unique,internal,name,name,state,t,state,new,state,state,name,state,type,states,add,state,return,state
NFACompiler -> NFAFactoryCompiler -> private IterativeCondition<T> extendWithUntilCondition( 				IterativeCondition<T> condition, 				IterativeCondition<T> untilCondition, 				boolean isTakeCondition);1499760222;This method extends the given condition with stop(until) condition if necessary._The until condition needs to be applied only if both of the given conditions are not null.__@param condition the condition to extend_@param untilCondition the until condition to join with the given condition_@param isTakeCondition whether the {@code condition} is for {@code TAKE} edge_@return condition with AND applied or the original condition;private IterativeCondition<T> extendWithUntilCondition(_				IterativeCondition<T> condition,_				IterativeCondition<T> untilCondition,_				boolean isTakeCondition) {_			if (untilCondition != null && condition != null) {_				return new AndCondition<>(new NotCondition<>(untilCondition), condition)__			} else if (untilCondition != null && isTakeCondition) {_				return new NotCondition<>(untilCondition)__			}__			return condition__		};this,method,extends,the,given,condition,with,stop,until,condition,if,necessary,the,until,condition,needs,to,be,applied,only,if,both,of,the,given,conditions,are,not,null,param,condition,the,condition,to,extend,param,until,condition,the,until,condition,to,join,with,the,given,condition,param,is,take,condition,whether,the,code,condition,is,for,code,take,edge,return,condition,with,and,applied,or,the,original,condition;private,iterative,condition,t,extend,with,until,condition,iterative,condition,t,condition,iterative,condition,t,until,condition,boolean,is,take,condition,if,until,condition,null,condition,null,return,new,and,condition,new,not,condition,until,condition,condition,else,if,until,condition,null,is,take,condition,return,new,not,condition,until,condition,return,condition
NFACompiler -> NFAFactoryCompiler -> private IterativeCondition<T> extendWithUntilCondition( 				IterativeCondition<T> condition, 				IterativeCondition<T> untilCondition, 				boolean isTakeCondition);1499937690;This method extends the given condition with stop(until) condition if necessary._The until condition needs to be applied only if both of the given conditions are not null.__@param condition the condition to extend_@param untilCondition the until condition to join with the given condition_@param isTakeCondition whether the {@code condition} is for {@code TAKE} edge_@return condition with AND applied or the original condition;private IterativeCondition<T> extendWithUntilCondition(_				IterativeCondition<T> condition,_				IterativeCondition<T> untilCondition,_				boolean isTakeCondition) {_			if (untilCondition != null && condition != null) {_				return new AndCondition<>(new NotCondition<>(untilCondition), condition)__			} else if (untilCondition != null && isTakeCondition) {_				return new NotCondition<>(untilCondition)__			}__			return condition__		};this,method,extends,the,given,condition,with,stop,until,condition,if,necessary,the,until,condition,needs,to,be,applied,only,if,both,of,the,given,conditions,are,not,null,param,condition,the,condition,to,extend,param,until,condition,the,until,condition,to,join,with,the,given,condition,param,is,take,condition,whether,the,code,condition,is,for,code,take,edge,return,condition,with,and,applied,or,the,original,condition;private,iterative,condition,t,extend,with,until,condition,iterative,condition,t,condition,iterative,condition,t,until,condition,boolean,is,take,condition,if,until,condition,null,condition,null,return,new,and,condition,new,not,condition,until,condition,condition,else,if,until,condition,null,is,take,condition,return,new,not,condition,until,condition,return,condition
NFACompiler -> NFAFactoryCompiler -> private IterativeCondition<T> extendWithUntilCondition( 				IterativeCondition<T> condition, 				IterativeCondition<T> untilCondition, 				boolean isTakeCondition);1500021711;This method extends the given condition with stop(until) condition if necessary._The until condition needs to be applied only if both of the given conditions are not null.__@param condition the condition to extend_@param untilCondition the until condition to join with the given condition_@param isTakeCondition whether the {@code condition} is for {@code TAKE} edge_@return condition with AND applied or the original condition;private IterativeCondition<T> extendWithUntilCondition(_				IterativeCondition<T> condition,_				IterativeCondition<T> untilCondition,_				boolean isTakeCondition) {_			if (untilCondition != null && condition != null) {_				return new AndCondition<>(new NotCondition<>(untilCondition), condition)__			} else if (untilCondition != null && isTakeCondition) {_				return new NotCondition<>(untilCondition)__			}__			return condition__		};this,method,extends,the,given,condition,with,stop,until,condition,if,necessary,the,until,condition,needs,to,be,applied,only,if,both,of,the,given,conditions,are,not,null,param,condition,the,condition,to,extend,param,until,condition,the,until,condition,to,join,with,the,given,condition,param,is,take,condition,whether,the,code,condition,is,for,code,take,edge,return,condition,with,and,applied,or,the,original,condition;private,iterative,condition,t,extend,with,until,condition,iterative,condition,t,condition,iterative,condition,t,until,condition,boolean,is,take,condition,if,until,condition,null,condition,null,return,new,and,condition,new,not,condition,until,condition,condition,else,if,until,condition,null,is,take,condition,return,new,not,condition,until,condition,return,condition
NFACompiler -> NFAFactoryCompiler -> private IterativeCondition<T> extendWithUntilCondition( 				IterativeCondition<T> condition, 				IterativeCondition<T> untilCondition, 				boolean isTakeCondition);1501592283;This method extends the given condition with stop(until) condition if necessary._The until condition needs to be applied only if both of the given conditions are not null.__@param condition the condition to extend_@param untilCondition the until condition to join with the given condition_@param isTakeCondition whether the {@code condition} is for {@code TAKE} edge_@return condition with AND applied or the original condition;private IterativeCondition<T> extendWithUntilCondition(_				IterativeCondition<T> condition,_				IterativeCondition<T> untilCondition,_				boolean isTakeCondition) {_			if (untilCondition != null && condition != null) {_				return new AndCondition<>(new NotCondition<>(untilCondition), condition)__			} else if (untilCondition != null && isTakeCondition) {_				return new NotCondition<>(untilCondition)__			}__			return condition__		};this,method,extends,the,given,condition,with,stop,until,condition,if,necessary,the,until,condition,needs,to,be,applied,only,if,both,of,the,given,conditions,are,not,null,param,condition,the,condition,to,extend,param,until,condition,the,until,condition,to,join,with,the,given,condition,param,is,take,condition,whether,the,code,condition,is,for,code,take,edge,return,condition,with,and,applied,or,the,original,condition;private,iterative,condition,t,extend,with,until,condition,iterative,condition,t,condition,iterative,condition,t,until,condition,boolean,is,take,condition,if,until,condition,null,condition,null,return,new,and,condition,new,not,condition,until,condition,condition,else,if,until,condition,null,is,take,condition,return,new,not,condition,until,condition,return,condition
NFACompiler -> NFAFactoryCompiler -> private IterativeCondition<T> extendWithUntilCondition( 				IterativeCondition<T> condition, 				IterativeCondition<T> untilCondition, 				boolean isTakeCondition);1502422141;This method extends the given condition with stop(until) condition if necessary._The until condition needs to be applied only if both of the given conditions are not null.__@param condition the condition to extend_@param untilCondition the until condition to join with the given condition_@param isTakeCondition whether the {@code condition} is for {@code TAKE} edge_@return condition with AND applied or the original condition;private IterativeCondition<T> extendWithUntilCondition(_				IterativeCondition<T> condition,_				IterativeCondition<T> untilCondition,_				boolean isTakeCondition) {_			if (untilCondition != null && condition != null) {_				return new AndCondition<>(new NotCondition<>(untilCondition), condition)__			} else if (untilCondition != null && isTakeCondition) {_				return new NotCondition<>(untilCondition)__			}__			return condition__		};this,method,extends,the,given,condition,with,stop,until,condition,if,necessary,the,until,condition,needs,to,be,applied,only,if,both,of,the,given,conditions,are,not,null,param,condition,the,condition,to,extend,param,until,condition,the,until,condition,to,join,with,the,given,condition,param,is,take,condition,whether,the,code,condition,is,for,code,take,edge,return,condition,with,and,applied,or,the,original,condition;private,iterative,condition,t,extend,with,until,condition,iterative,condition,t,condition,iterative,condition,t,until,condition,boolean,is,take,condition,if,until,condition,null,condition,null,return,new,and,condition,new,not,condition,until,condition,condition,else,if,until,condition,null,is,take,condition,return,new,not,condition,until,condition,return,condition
NFACompiler -> NFAFactoryCompiler -> private IterativeCondition<T> extendWithUntilCondition( 				IterativeCondition<T> condition, 				IterativeCondition<T> untilCondition, 				boolean isTakeCondition);1503588494;This method extends the given condition with stop(until) condition if necessary._The until condition needs to be applied only if both of the given conditions are not null.__@param condition the condition to extend_@param untilCondition the until condition to join with the given condition_@param isTakeCondition whether the {@code condition} is for {@code TAKE} edge_@return condition with AND applied or the original condition;private IterativeCondition<T> extendWithUntilCondition(_				IterativeCondition<T> condition,_				IterativeCondition<T> untilCondition,_				boolean isTakeCondition) {_			if (untilCondition != null && condition != null) {_				return new AndCondition<>(new NotCondition<>(untilCondition), condition)__			} else if (untilCondition != null && isTakeCondition) {_				return new NotCondition<>(untilCondition)__			}__			return condition__		};this,method,extends,the,given,condition,with,stop,until,condition,if,necessary,the,until,condition,needs,to,be,applied,only,if,both,of,the,given,conditions,are,not,null,param,condition,the,condition,to,extend,param,until,condition,the,until,condition,to,join,with,the,given,condition,param,is,take,condition,whether,the,code,condition,is,for,code,take,edge,return,condition,with,and,applied,or,the,original,condition;private,iterative,condition,t,extend,with,until,condition,iterative,condition,t,condition,iterative,condition,t,until,condition,boolean,is,take,condition,if,until,condition,null,condition,null,return,new,and,condition,new,not,condition,until,condition,condition,else,if,until,condition,null,is,take,condition,return,new,not,condition,until,condition,return,condition
NFACompiler -> NFAFactoryCompiler -> private IterativeCondition<T> extendWithUntilCondition( 				IterativeCondition<T> condition, 				IterativeCondition<T> untilCondition, 				boolean isTakeCondition);1518008111;This method extends the given condition with stop(until) condition if necessary._The until condition needs to be applied only if both of the given conditions are not null.__@param condition the condition to extend_@param untilCondition the until condition to join with the given condition_@param isTakeCondition whether the {@code condition} is for {@code TAKE} edge_@return condition with AND applied or the original condition;private IterativeCondition<T> extendWithUntilCondition(_				IterativeCondition<T> condition,_				IterativeCondition<T> untilCondition,_				boolean isTakeCondition) {_			if (untilCondition != null && condition != null) {_				return new AndCondition<>(new NotCondition<>(untilCondition), condition)__			} else if (untilCondition != null && isTakeCondition) {_				return new NotCondition<>(untilCondition)__			}__			return condition__		};this,method,extends,the,given,condition,with,stop,until,condition,if,necessary,the,until,condition,needs,to,be,applied,only,if,both,of,the,given,conditions,are,not,null,param,condition,the,condition,to,extend,param,until,condition,the,until,condition,to,join,with,the,given,condition,param,is,take,condition,whether,the,code,condition,is,for,code,take,edge,return,condition,with,and,applied,or,the,original,condition;private,iterative,condition,t,extend,with,until,condition,iterative,condition,t,condition,iterative,condition,t,until,condition,boolean,is,take,condition,if,until,condition,null,condition,null,return,new,and,condition,new,not,condition,until,condition,condition,else,if,until,condition,null,is,take,condition,return,new,not,condition,until,condition,return,condition
NFACompiler -> NFAFactoryCompiler -> private IterativeCondition<T> extendWithUntilCondition( 				IterativeCondition<T> condition, 				IterativeCondition<T> untilCondition, 				boolean isTakeCondition);1527863170;This method extends the given condition with stop(until) condition if necessary._The until condition needs to be applied only if both of the given conditions are not null.__@param condition the condition to extend_@param untilCondition the until condition to join with the given condition_@param isTakeCondition whether the {@code condition} is for {@code TAKE} edge_@return condition with AND applied or the original condition;private IterativeCondition<T> extendWithUntilCondition(_				IterativeCondition<T> condition,_				IterativeCondition<T> untilCondition,_				boolean isTakeCondition) {_			if (untilCondition != null && condition != null) {_				return new AndCondition<>(new NotCondition<>(untilCondition), condition)__			} else if (untilCondition != null && isTakeCondition) {_				return new NotCondition<>(untilCondition)__			}__			return condition__		};this,method,extends,the,given,condition,with,stop,until,condition,if,necessary,the,until,condition,needs,to,be,applied,only,if,both,of,the,given,conditions,are,not,null,param,condition,the,condition,to,extend,param,until,condition,the,until,condition,to,join,with,the,given,condition,param,is,take,condition,whether,the,code,condition,is,for,code,take,edge,return,condition,with,and,applied,or,the,original,condition;private,iterative,condition,t,extend,with,until,condition,iterative,condition,t,condition,iterative,condition,t,until,condition,boolean,is,take,condition,if,until,condition,null,condition,null,return,new,and,condition,new,not,condition,until,condition,condition,else,if,until,condition,null,is,take,condition,return,new,not,condition,until,condition,return,condition
NFACompiler -> NFAFactoryCompiler -> private IterativeCondition<T> extendWithUntilCondition( 				IterativeCondition<T> condition, 				IterativeCondition<T> untilCondition, 				boolean isTakeCondition);1528989005;This method extends the given condition with stop(until) condition if necessary._The until condition needs to be applied only if both of the given conditions are not null.__@param condition the condition to extend_@param untilCondition the until condition to join with the given condition_@param isTakeCondition whether the {@code condition} is for {@code TAKE} edge_@return condition with AND applied or the original condition;private IterativeCondition<T> extendWithUntilCondition(_				IterativeCondition<T> condition,_				IterativeCondition<T> untilCondition,_				boolean isTakeCondition) {_			if (untilCondition != null && condition != null) {_				return new AndCondition<>(new NotCondition<>(untilCondition), condition)__			} else if (untilCondition != null && isTakeCondition) {_				return new NotCondition<>(untilCondition)__			}__			return condition__		};this,method,extends,the,given,condition,with,stop,until,condition,if,necessary,the,until,condition,needs,to,be,applied,only,if,both,of,the,given,conditions,are,not,null,param,condition,the,condition,to,extend,param,until,condition,the,until,condition,to,join,with,the,given,condition,param,is,take,condition,whether,the,code,condition,is,for,code,take,edge,return,condition,with,and,applied,or,the,original,condition;private,iterative,condition,t,extend,with,until,condition,iterative,condition,t,condition,iterative,condition,t,until,condition,boolean,is,take,condition,if,until,condition,null,condition,null,return,new,and,condition,new,not,condition,until,condition,condition,else,if,until,condition,null,is,take,condition,return,new,not,condition,until,condition,return,condition
NFACompiler -> NFAFactoryCompiler -> private IterativeCondition<T> extendWithUntilCondition( 				IterativeCondition<T> condition, 				IterativeCondition<T> untilCondition, 				boolean isTakeCondition);1538745898;This method extends the given condition with stop(until) condition if necessary._The until condition needs to be applied only if both of the given conditions are not null.__@param condition the condition to extend_@param untilCondition the until condition to join with the given condition_@param isTakeCondition whether the {@code condition} is for {@code TAKE} edge_@return condition with AND applied or the original condition;private IterativeCondition<T> extendWithUntilCondition(_				IterativeCondition<T> condition,_				IterativeCondition<T> untilCondition,_				boolean isTakeCondition) {_			if (untilCondition != null && condition != null) {_				return new AndCondition<>(new NotCondition<>(untilCondition), condition)__			} else if (untilCondition != null && isTakeCondition) {_				return new NotCondition<>(untilCondition)__			}__			return condition__		};this,method,extends,the,given,condition,with,stop,until,condition,if,necessary,the,until,condition,needs,to,be,applied,only,if,both,of,the,given,conditions,are,not,null,param,condition,the,condition,to,extend,param,until,condition,the,until,condition,to,join,with,the,given,condition,param,is,take,condition,whether,the,code,condition,is,for,code,take,edge,return,condition,with,and,applied,or,the,original,condition;private,iterative,condition,t,extend,with,until,condition,iterative,condition,t,condition,iterative,condition,t,until,condition,boolean,is,take,condition,if,until,condition,null,condition,null,return,new,and,condition,new,not,condition,until,condition,condition,else,if,until,condition,null,is,take,condition,return,new,not,condition,until,condition,return,condition
NFACompiler -> NFAFactoryCompiler -> private IterativeCondition<T> extendWithUntilCondition( 				IterativeCondition<T> condition, 				IterativeCondition<T> untilCondition, 				boolean isTakeCondition);1542293931;This method extends the given condition with stop(until) condition if necessary._The until condition needs to be applied only if both of the given conditions are not null.__@param condition the condition to extend_@param untilCondition the until condition to join with the given condition_@param isTakeCondition whether the {@code condition} is for {@code TAKE} edge_@return condition with AND applied or the original condition;private IterativeCondition<T> extendWithUntilCondition(_				IterativeCondition<T> condition,_				IterativeCondition<T> untilCondition,_				boolean isTakeCondition) {_			if (untilCondition != null && condition != null) {_				return new RichAndCondition<>(new RichNotCondition<>(untilCondition), condition)__			} else if (untilCondition != null && isTakeCondition) {_				return new RichNotCondition<>(untilCondition)__			}__			return condition__		};this,method,extends,the,given,condition,with,stop,until,condition,if,necessary,the,until,condition,needs,to,be,applied,only,if,both,of,the,given,conditions,are,not,null,param,condition,the,condition,to,extend,param,until,condition,the,until,condition,to,join,with,the,given,condition,param,is,take,condition,whether,the,code,condition,is,for,code,take,edge,return,condition,with,and,applied,or,the,original,condition;private,iterative,condition,t,extend,with,until,condition,iterative,condition,t,condition,iterative,condition,t,until,condition,boolean,is,take,condition,if,until,condition,null,condition,null,return,new,rich,and,condition,new,rich,not,condition,until,condition,condition,else,if,until,condition,null,is,take,condition,return,new,rich,not,condition,until,condition,return,condition
NFACompiler -> NFAFactoryCompiler -> private State<T> convertToTimesState(final State<T> sourceState, final State<T> sinkState, int times);1489866780;Converts the given state into a "complex" state consisting of given number of states with_same {@link FilterFunction}__@param sourceState the state to be converted_@param sinkState the state that the converted state should point to_@param times number of times the state should be copied_@return the first state of the "complex" state, next state should point to it;private State<T> convertToTimesState(final State<T> sourceState, final State<T> sinkState, int times) {_			convertToSingletonState(sourceState, sinkState)__			State<T> lastSink__			State<T> firstState = sourceState__			for (int i = 0_ i < times - 1_ i++) {_				lastSink = firstState__				firstState = new State<>(currentPattern.getName(), State.StateType.Normal)__				states.add(firstState)__				convertToSingletonState(firstState, lastSink)__			}_			return firstState__		};converts,the,given,state,into,a,complex,state,consisting,of,given,number,of,states,with,same,link,filter,function,param,source,state,the,state,to,be,converted,param,sink,state,the,state,that,the,converted,state,should,point,to,param,times,number,of,times,the,state,should,be,copied,return,the,first,state,of,the,complex,state,next,state,should,point,to,it;private,state,t,convert,to,times,state,final,state,t,source,state,final,state,t,sink,state,int,times,convert,to,singleton,state,source,state,sink,state,state,t,last,sink,state,t,first,state,source,state,for,int,i,0,i,times,1,i,last,sink,first,state,first,state,new,state,current,pattern,get,name,state,state,type,normal,states,add,first,state,convert,to,singleton,state,first,state,last,sink,return,first,state
NFACompiler -> NFAFactoryCompiler -> private State<T> convertToTimesState(final State<T> sourceState, final State<T> sinkState, int times);1490089987;Converts the given state into a "complex" state consisting of given number of states with_same {@link FilterFunction}__@param sourceState the state to be converted_@param sinkState the state that the converted state should point to_@param times number of times the state should be copied_@return the first state of the "complex" state, next state should point to it;private State<T> convertToTimesState(final State<T> sourceState, final State<T> sinkState, int times) {_			convertToSingletonState(sourceState, sinkState)__			State<T> lastSink__			State<T> firstState = sourceState__			for (int i = 0_ i < times - 1_ i++) {_				lastSink = firstState__				firstState = new State<>(currentPattern.getName(), State.StateType.Normal)__				states.add(firstState)__				convertToSingletonState(firstState, lastSink)__			}_			return firstState__		};converts,the,given,state,into,a,complex,state,consisting,of,given,number,of,states,with,same,link,filter,function,param,source,state,the,state,to,be,converted,param,sink,state,the,state,that,the,converted,state,should,point,to,param,times,number,of,times,the,state,should,be,copied,return,the,first,state,of,the,complex,state,next,state,should,point,to,it;private,state,t,convert,to,times,state,final,state,t,source,state,final,state,t,sink,state,int,times,convert,to,singleton,state,source,state,sink,state,state,t,last,sink,state,t,first,state,source,state,for,int,i,0,i,times,1,i,last,sink,first,state,first,state,new,state,current,pattern,get,name,state,state,type,normal,states,add,first,state,convert,to,singleton,state,first,state,last,sink,return,first,state
NFACompiler -> NFAFactoryCompiler -> private State<T> convertToTimesState(final State<T> sourceState, final State<T> sinkState, int times);1490194327;Converts the given state into a "complex" state consisting of given number of states with_same {@link IterativeCondition}__@param sourceState the state to be converted_@param sinkState the state that the converted state should point to_@param times number of times the state should be copied_@return the first state of the "complex" state, next state should point to it;private State<T> convertToTimesState(final State<T> sourceState, final State<T> sinkState, int times) {_			convertToSingletonState(sourceState, sinkState)__			State<T> lastSink__			State<T> firstState = sourceState__			for (int i = 0_ i < times - 1_ i++) {_				lastSink = firstState__				firstState = new State<>(currentPattern.getName(), State.StateType.Normal)__				states.add(firstState)__				convertToSingletonState(firstState, lastSink)__			}_			return firstState__		};converts,the,given,state,into,a,complex,state,consisting,of,given,number,of,states,with,same,link,iterative,condition,param,source,state,the,state,to,be,converted,param,sink,state,the,state,that,the,converted,state,should,point,to,param,times,number,of,times,the,state,should,be,copied,return,the,first,state,of,the,complex,state,next,state,should,point,to,it;private,state,t,convert,to,times,state,final,state,t,source,state,final,state,t,sink,state,int,times,convert,to,singleton,state,source,state,sink,state,state,t,last,sink,state,t,first,state,source,state,for,int,i,0,i,times,1,i,last,sink,first,state,first,state,new,state,current,pattern,get,name,state,state,type,normal,states,add,first,state,convert,to,singleton,state,first,state,last,sink,return,first,state
NFACompiler -> NFAFactoryCompiler -> private State<T> createEndingState();1489866780;Creates the dummy Final {@link State} of the NFA graph._@return dummy Final state;private State<T> createEndingState() {_			State<T> endState = new State<>(ENDING_STATE_NAME, State.StateType.Final)__			states.add(endState)__			usedNames.add(ENDING_STATE_NAME)___			windowTime = currentPattern.getWindowTime() != null ? currentPattern.getWindowTime().toMilliseconds() : 0L__			return endState__		};creates,the,dummy,final,link,state,of,the,nfa,graph,return,dummy,final,state;private,state,t,create,ending,state,state,t,end,state,new,state,state,state,type,final,states,add,end,state,used,names,add,window,time,current,pattern,get,window,time,null,current,pattern,get,window,time,to,milliseconds,0l,return,end,state
NFACompiler -> NFAFactoryCompiler -> private State<T> createEndingState();1490089987;Creates the dummy Final {@link State} of the NFA graph._@return dummy Final state;private State<T> createEndingState() {_			State<T> endState = new State<>(ENDING_STATE_NAME, State.StateType.Final)__			states.add(endState)__			usedNames.add(ENDING_STATE_NAME)___			windowTime = currentPattern.getWindowTime() != null ? currentPattern.getWindowTime().toMilliseconds() : 0L__			return endState__		};creates,the,dummy,final,link,state,of,the,nfa,graph,return,dummy,final,state;private,state,t,create,ending,state,state,t,end,state,new,state,state,state,type,final,states,add,end,state,used,names,add,window,time,current,pattern,get,window,time,null,current,pattern,get,window,time,to,milliseconds,0l,return,end,state
NFACompiler -> NFAFactoryCompiler -> private State<T> createEndingState();1490194327;Creates the dummy Final {@link State} of the NFA graph._@return dummy Final state;private State<T> createEndingState() {_			State<T> endState = new State<>(ENDING_STATE_NAME, State.StateType.Final)__			states.add(endState)__			usedNames.add(ENDING_STATE_NAME)___			windowTime = currentPattern.getWindowTime() != null ? currentPattern.getWindowTime().toMilliseconds() : 0L__			return endState__		};creates,the,dummy,final,link,state,of,the,nfa,graph,return,dummy,final,state;private,state,t,create,ending,state,state,t,end,state,new,state,state,state,type,final,states,add,end,state,used,names,add,window,time,current,pattern,get,window,time,null,current,pattern,get,window,time,to,milliseconds,0l,return,end,state
NFACompiler -> NFAFactoryCompiler -> private State<T> createEndingState();1490619911;Creates the dummy Final {@link State} of the NFA graph._@return dummy Final state;private State<T> createEndingState() {_			State<T> endState = new State<>(ENDING_STATE_NAME, State.StateType.Final)__			states.add(endState)__			usedNames.add(ENDING_STATE_NAME)___			windowTime = currentPattern.getWindowTime() != null ? currentPattern.getWindowTime().toMilliseconds() : 0L__			return endState__		};creates,the,dummy,final,link,state,of,the,nfa,graph,return,dummy,final,state;private,state,t,create,ending,state,state,t,end,state,new,state,state,state,type,final,states,add,end,state,used,names,add,window,time,current,pattern,get,window,time,null,current,pattern,get,window,time,to,milliseconds,0l,return,end,state
NFACompiler -> NFAFactoryCompiler -> private State<T> createEndingState();1491320734;Creates the dummy Final {@link State} of the NFA graph._@return dummy Final state;private State<T> createEndingState() {_			State<T> endState = new State<>(ENDING_STATE_NAME, State.StateType.Final)__			states.add(endState)__			usedNames.add(ENDING_STATE_NAME)___			windowTime = currentPattern.getWindowTime() != null ? currentPattern.getWindowTime().toMilliseconds() : 0L__			return endState__		};creates,the,dummy,final,link,state,of,the,nfa,graph,return,dummy,final,state;private,state,t,create,ending,state,state,t,end,state,new,state,state,state,type,final,states,add,end,state,used,names,add,window,time,current,pattern,get,window,time,null,current,pattern,get,window,time,to,milliseconds,0l,return,end,state
NFACompiler -> NFAFactoryCompiler -> private State<T> createEndingState();1491323030;Creates the dummy Final {@link State} of the NFA graph._@return dummy Final state;private State<T> createEndingState() {_			State<T> endState = new State<>(ENDING_STATE_NAME, State.StateType.Final)__			states.add(endState)__			usedNames.add(ENDING_STATE_NAME)___			windowTime = currentPattern.getWindowTime() != null ? currentPattern.getWindowTime().toMilliseconds() : 0L__			return endState__		};creates,the,dummy,final,link,state,of,the,nfa,graph,return,dummy,final,state;private,state,t,create,ending,state,state,t,end,state,new,state,state,state,type,final,states,add,end,state,used,names,add,window,time,current,pattern,get,window,time,null,current,pattern,get,window,time,to,milliseconds,0l,return,end,state
NFACompiler -> NFAFactoryCompiler -> private State<T> createEndingState();1491633862;Creates the dummy Final {@link State} of the NFA graph._@return dummy Final state;private State<T> createEndingState() {_			State<T> endState = new State<>(ENDING_STATE_NAME, State.StateType.Final)__			states.add(endState)__			usedNames.add(ENDING_STATE_NAME)___			windowTime = currentPattern.getWindowTime() != null ? currentPattern.getWindowTime().toMilliseconds() : 0L__			return endState__		};creates,the,dummy,final,link,state,of,the,nfa,graph,return,dummy,final,state;private,state,t,create,ending,state,state,t,end,state,new,state,state,state,type,final,states,add,end,state,used,names,add,window,time,current,pattern,get,window,time,null,current,pattern,get,window,time,to,milliseconds,0l,return,end,state
NFACompiler -> NFAFactoryCompiler -> private State<T> createEndingState();1492797583;Creates the dummy Final {@link State} of the NFA graph._@return dummy Final state;private State<T> createEndingState() {_			State<T> endState = new State<>(ENDING_STATE_NAME, State.StateType.Final)__			states.add(endState)__			usedNames.add(ENDING_STATE_NAME)___			windowTime = currentPattern.getWindowTime() != null ? currentPattern.getWindowTime().toMilliseconds() : 0L__			return endState__		};creates,the,dummy,final,link,state,of,the,nfa,graph,return,dummy,final,state;private,state,t,create,ending,state,state,t,end,state,new,state,state,state,type,final,states,add,end,state,used,names,add,window,time,current,pattern,get,window,time,null,current,pattern,get,window,time,to,milliseconds,0l,return,end,state
NFACompiler -> NFAFactoryCompiler -> private State<T> createEndingState();1493200673;Creates the dummy Final {@link State} of the NFA graph._@return dummy Final state;private State<T> createEndingState() {_			State<T> endState = new State<>(ENDING_STATE_NAME, State.StateType.Final)__			states.add(endState)__			usedNames.add(ENDING_STATE_NAME)___			windowTime = currentPattern.getWindowTime() != null ? currentPattern.getWindowTime().toMilliseconds() : 0L__			return endState__		};creates,the,dummy,final,link,state,of,the,nfa,graph,return,dummy,final,state;private,state,t,create,ending,state,state,t,end,state,new,state,state,state,type,final,states,add,end,state,used,names,add,window,time,current,pattern,get,window,time,null,current,pattern,get,window,time,to,milliseconds,0l,return,end,state
NFACompiler -> NFAFactoryCompiler -> private State<T> createEndingState();1493385877;Creates the dummy Final {@link State} of the NFA graph._@return dummy Final state;private State<T> createEndingState() {_			checkPatternNameUniqueness(ENDING_STATE_NAME)__			State<T> endState = new State<>(ENDING_STATE_NAME, State.StateType.Final)__			states.add(endState)___			windowTime = currentPattern.getWindowTime() != null ? currentPattern.getWindowTime().toMilliseconds() : 0L__			return endState__		};creates,the,dummy,final,link,state,of,the,nfa,graph,return,dummy,final,state;private,state,t,create,ending,state,check,pattern,name,uniqueness,state,t,end,state,new,state,state,state,type,final,states,add,end,state,window,time,current,pattern,get,window,time,null,current,pattern,get,window,time,to,milliseconds,0l,return,end,state
NFACompiler -> NFAFactoryCompiler -> private State<T> createEndingState();1494947249;Creates the dummy Final {@link State} of the NFA graph._@return dummy Final state;private State<T> createEndingState() {_			State<T> endState = createState(ENDING_STATE_NAME, State.StateType.Final)__			windowTime = currentPattern.getWindowTime() != null ? currentPattern.getWindowTime().toMilliseconds() : 0L__			return endState__		};creates,the,dummy,final,link,state,of,the,nfa,graph,return,dummy,final,state;private,state,t,create,ending,state,state,t,end,state,create,state,state,state,type,final,window,time,current,pattern,get,window,time,null,current,pattern,get,window,time,to,milliseconds,0l,return,end,state
NFACompiler -> NFAFactoryCompiler -> private State<T> createEndingState();1495657626;Creates the dummy Final {@link State} of the NFA graph._@return dummy Final state;private State<T> createEndingState() {_			State<T> endState = createState(ENDING_STATE_NAME, State.StateType.Final)__			windowTime = currentPattern.getWindowTime() != null ? currentPattern.getWindowTime().toMilliseconds() : 0L__			return endState__		};creates,the,dummy,final,link,state,of,the,nfa,graph,return,dummy,final,state;private,state,t,create,ending,state,state,t,end,state,create,state,state,state,type,final,window,time,current,pattern,get,window,time,null,current,pattern,get,window,time,to,milliseconds,0l,return,end,state
NFACompiler -> NFAFactoryCompiler -> private State<T> createEndingState();1496245714;Creates the dummy Final {@link State} of the NFA graph._@return dummy Final state;private State<T> createEndingState() {_			State<T> endState = createState(ENDING_STATE_NAME, State.StateType.Final)__			windowTime = currentPattern.getWindowTime() != null ? currentPattern.getWindowTime().toMilliseconds() : 0L__			return endState__		};creates,the,dummy,final,link,state,of,the,nfa,graph,return,dummy,final,state;private,state,t,create,ending,state,state,t,end,state,create,state,state,state,type,final,window,time,current,pattern,get,window,time,null,current,pattern,get,window,time,to,milliseconds,0l,return,end,state
NFACompiler -> NFAFactoryCompiler -> private State<T> createEndingState();1497410381;Creates the dummy Final {@link State} of the NFA graph._@return dummy Final state;private State<T> createEndingState() {_			State<T> endState = createState(ENDING_STATE_NAME, State.StateType.Final)__			windowTime = currentPattern.getWindowTime() != null ? currentPattern.getWindowTime().toMilliseconds() : 0L__			return endState__		};creates,the,dummy,final,link,state,of,the,nfa,graph,return,dummy,final,state;private,state,t,create,ending,state,state,t,end,state,create,state,state,state,type,final,window,time,current,pattern,get,window,time,null,current,pattern,get,window,time,to,milliseconds,0l,return,end,state
NFACompiler -> NFAFactoryCompiler -> private State<T> createEndingState();1497883202;Creates the dummy Final {@link State} of the NFA graph._@return dummy Final state;private State<T> createEndingState() {_			State<T> endState = createState(ENDING_STATE_NAME, State.StateType.Final)__			windowTime = currentPattern.getWindowTime() != null ? currentPattern.getWindowTime().toMilliseconds() : 0L__			return endState__		};creates,the,dummy,final,link,state,of,the,nfa,graph,return,dummy,final,state;private,state,t,create,ending,state,state,t,end,state,create,state,state,state,type,final,window,time,current,pattern,get,window,time,null,current,pattern,get,window,time,to,milliseconds,0l,return,end,state
NFACompiler -> NFAFactoryCompiler -> private State<T> createEndingState();1498034481;Creates the dummy Final {@link State} of the NFA graph._@return dummy Final state;private State<T> createEndingState() {_			State<T> endState = createState(ENDING_STATE_NAME, State.StateType.Final)__			windowTime = currentPattern.getWindowTime() != null ? currentPattern.getWindowTime().toMilliseconds() : 0L__			return endState__		};creates,the,dummy,final,link,state,of,the,nfa,graph,return,dummy,final,state;private,state,t,create,ending,state,state,t,end,state,create,state,state,state,type,final,window,time,current,pattern,get,window,time,null,current,pattern,get,window,time,to,milliseconds,0l,return,end,state
NFACompiler -> NFAFactoryCompiler -> private State<T> createEndingState();1499760222;Creates the dummy Final {@link State} of the NFA graph._@return dummy Final state;private State<T> createEndingState() {_			State<T> endState = createState(ENDING_STATE_NAME, State.StateType.Final)__			windowTime = currentPattern.getWindowTime() != null ? currentPattern.getWindowTime().toMilliseconds() : 0L__			return endState__		};creates,the,dummy,final,link,state,of,the,nfa,graph,return,dummy,final,state;private,state,t,create,ending,state,state,t,end,state,create,state,state,state,type,final,window,time,current,pattern,get,window,time,null,current,pattern,get,window,time,to,milliseconds,0l,return,end,state
NFACompiler -> NFAFactoryCompiler -> private State<T> createEndingState();1499937690;Creates the dummy Final {@link State} of the NFA graph._@return dummy Final state;private State<T> createEndingState() {_			State<T> endState = createState(ENDING_STATE_NAME, State.StateType.Final)__			windowTime = currentPattern.getWindowTime() != null ? currentPattern.getWindowTime().toMilliseconds() : 0L__			return endState__		};creates,the,dummy,final,link,state,of,the,nfa,graph,return,dummy,final,state;private,state,t,create,ending,state,state,t,end,state,create,state,state,state,type,final,window,time,current,pattern,get,window,time,null,current,pattern,get,window,time,to,milliseconds,0l,return,end,state
NFACompiler -> NFAFactoryCompiler -> private State<T> createEndingState();1500021711;Creates the dummy Final {@link State} of the NFA graph._@return dummy Final state;private State<T> createEndingState() {_			State<T> endState = createState(ENDING_STATE_NAME, State.StateType.Final)__			windowTime = currentPattern.getWindowTime() != null ? currentPattern.getWindowTime().toMilliseconds() : 0L__			return endState__		};creates,the,dummy,final,link,state,of,the,nfa,graph,return,dummy,final,state;private,state,t,create,ending,state,state,t,end,state,create,state,state,state,type,final,window,time,current,pattern,get,window,time,null,current,pattern,get,window,time,to,milliseconds,0l,return,end,state
NFACompiler -> NFAFactoryCompiler -> private State<T> createEndingState();1501592283;Creates the dummy Final {@link State} of the NFA graph._@return dummy Final state;private State<T> createEndingState() {_			State<T> endState = createState(ENDING_STATE_NAME, State.StateType.Final)__			windowTime = currentPattern.getWindowTime() != null ? currentPattern.getWindowTime().toMilliseconds() : 0L__			return endState__		};creates,the,dummy,final,link,state,of,the,nfa,graph,return,dummy,final,state;private,state,t,create,ending,state,state,t,end,state,create,state,state,state,type,final,window,time,current,pattern,get,window,time,null,current,pattern,get,window,time,to,milliseconds,0l,return,end,state
NFACompiler -> NFAFactoryCompiler -> private State<T> createEndingState();1502422141;Creates the dummy Final {@link State} of the NFA graph._@return dummy Final state;private State<T> createEndingState() {_			State<T> endState = createState(ENDING_STATE_NAME, State.StateType.Final)__			windowTime = currentPattern.getWindowTime() != null ? currentPattern.getWindowTime().toMilliseconds() : 0L__			return endState__		};creates,the,dummy,final,link,state,of,the,nfa,graph,return,dummy,final,state;private,state,t,create,ending,state,state,t,end,state,create,state,state,state,type,final,window,time,current,pattern,get,window,time,null,current,pattern,get,window,time,to,milliseconds,0l,return,end,state
NFACompiler -> NFAFactoryCompiler -> private State<T> createEndingState();1503588494;Creates the dummy Final {@link State} of the NFA graph._@return dummy Final state;private State<T> createEndingState() {_			State<T> endState = createState(ENDING_STATE_NAME, State.StateType.Final)__			windowTime = currentPattern.getWindowTime() != null ? currentPattern.getWindowTime().toMilliseconds() : 0L__			return endState__		};creates,the,dummy,final,link,state,of,the,nfa,graph,return,dummy,final,state;private,state,t,create,ending,state,state,t,end,state,create,state,state,state,type,final,window,time,current,pattern,get,window,time,null,current,pattern,get,window,time,to,milliseconds,0l,return,end,state
NFACompiler -> NFAFactoryCompiler -> private State<T> createEndingState();1518008111;Creates the dummy Final {@link State} of the NFA graph._@return dummy Final state;private State<T> createEndingState() {_			State<T> endState = createState(ENDING_STATE_NAME, State.StateType.Final)__			windowTime = currentPattern.getWindowTime() != null ? currentPattern.getWindowTime().toMilliseconds() : 0L__			return endState__		};creates,the,dummy,final,link,state,of,the,nfa,graph,return,dummy,final,state;private,state,t,create,ending,state,state,t,end,state,create,state,state,state,type,final,window,time,current,pattern,get,window,time,null,current,pattern,get,window,time,to,milliseconds,0l,return,end,state
NFACompiler -> NFAFactoryCompiler -> private State<T> createEndingState();1527863170;Creates the dummy Final {@link State} of the NFA graph._@return dummy Final state;private State<T> createEndingState() {_			State<T> endState = createState(ENDING_STATE_NAME, State.StateType.Final)__			windowTime = currentPattern.getWindowTime() != null ? currentPattern.getWindowTime().toMilliseconds() : 0L__			return endState__		};creates,the,dummy,final,link,state,of,the,nfa,graph,return,dummy,final,state;private,state,t,create,ending,state,state,t,end,state,create,state,state,state,type,final,window,time,current,pattern,get,window,time,null,current,pattern,get,window,time,to,milliseconds,0l,return,end,state
NFACompiler -> NFAFactoryCompiler -> private State<T> createEndingState();1528989005;Creates the dummy Final {@link State} of the NFA graph._@return dummy Final state;private State<T> createEndingState() {_			State<T> endState = createState(ENDING_STATE_NAME, State.StateType.Final)__			windowTime = currentPattern.getWindowTime() != null ? currentPattern.getWindowTime().toMilliseconds() : 0L__			return endState__		};creates,the,dummy,final,link,state,of,the,nfa,graph,return,dummy,final,state;private,state,t,create,ending,state,state,t,end,state,create,state,state,state,type,final,window,time,current,pattern,get,window,time,null,current,pattern,get,window,time,to,milliseconds,0l,return,end,state
NFACompiler -> NFAFactoryCompiler -> private State<T> createEndingState();1538745898;Creates the dummy Final {@link State} of the NFA graph._@return dummy Final state;private State<T> createEndingState() {_			State<T> endState = createState(ENDING_STATE_NAME, State.StateType.Final)__			windowTime = currentPattern.getWindowTime() != null ? currentPattern.getWindowTime().toMilliseconds() : 0L__			return endState__		};creates,the,dummy,final,link,state,of,the,nfa,graph,return,dummy,final,state;private,state,t,create,ending,state,state,t,end,state,create,state,state,state,type,final,window,time,current,pattern,get,window,time,null,current,pattern,get,window,time,to,milliseconds,0l,return,end,state
NFACompiler -> NFAFactoryCompiler -> private State<T> createEndingState();1542293931;Creates the dummy Final {@link State} of the NFA graph._@return dummy Final state;private State<T> createEndingState() {_			State<T> endState = createState(ENDING_STATE_NAME, State.StateType.Final)__			windowTime = currentPattern.getWindowTime() != null ? currentPattern.getWindowTime().toMilliseconds() : 0L__			return endState__		};creates,the,dummy,final,link,state,of,the,nfa,graph,return,dummy,final,state;private,state,t,create,ending,state,state,t,end,state,create,state,state,state,type,final,window,time,current,pattern,get,window,time,null,current,pattern,get,window,time,to,milliseconds,0l,return,end,state
NFACompiler -> NFAFactoryCompiler -> private State<T> createMiddleStates(final State<T> sinkState);1489866780;Creates all the states between Start and Final state._@param sinkState the state that last state should point to (always the Final state)_@return the next state after Start in the resulting graph;private State<T> createMiddleStates(final State<T> sinkState) {__			State<T> lastSink = sinkState__			while (currentPattern.getPrevious() != null) {_				checkPatternNameUniqueness()___				State<T> sourceState = new State<>(currentPattern.getName(), State.StateType.Normal)__				states.add(sourceState)__				usedNames.add(sourceState.getName())___				if (currentPattern.getQuantifier().hasProperty(QuantifierProperty.LOOPING)) {_					convertToLooping(sourceState, lastSink)___					if (currentPattern.getQuantifier().hasProperty(QuantifierProperty.AT_LEAST_ONE)) {_						sourceState = createFirstMandatoryStateOfLoop(sourceState, State.StateType.Normal)__						states.add(sourceState)__						usedNames.add(sourceState.getName())__					}_				} else if (currentPattern.getQuantifier() == Quantifier.TIMES) {_					sourceState = convertToTimesState(sourceState, lastSink, currentPattern.getTimes())__				} else {_					convertToSingletonState(sourceState, lastSink)__				}__				currentPattern = currentPattern.getPrevious()__				lastSink = sourceState___				final Time currentWindowTime = currentPattern.getWindowTime()__				if (currentWindowTime != null && currentWindowTime.toMilliseconds() < windowTime) {_					_					windowTime = currentWindowTime.toMilliseconds()__				}_			}__			return lastSink__		};creates,all,the,states,between,start,and,final,state,param,sink,state,the,state,that,last,state,should,point,to,always,the,final,state,return,the,next,state,after,start,in,the,resulting,graph;private,state,t,create,middle,states,final,state,t,sink,state,state,t,last,sink,sink,state,while,current,pattern,get,previous,null,check,pattern,name,uniqueness,state,t,source,state,new,state,current,pattern,get,name,state,state,type,normal,states,add,source,state,used,names,add,source,state,get,name,if,current,pattern,get,quantifier,has,property,quantifier,property,looping,convert,to,looping,source,state,last,sink,if,current,pattern,get,quantifier,has,property,quantifier,property,source,state,create,first,mandatory,state,of,loop,source,state,state,state,type,normal,states,add,source,state,used,names,add,source,state,get,name,else,if,current,pattern,get,quantifier,quantifier,times,source,state,convert,to,times,state,source,state,last,sink,current,pattern,get,times,else,convert,to,singleton,state,source,state,last,sink,current,pattern,current,pattern,get,previous,last,sink,source,state,final,time,current,window,time,current,pattern,get,window,time,if,current,window,time,null,current,window,time,to,milliseconds,window,time,window,time,current,window,time,to,milliseconds,return,last,sink
NFACompiler -> NFAFactoryCompiler -> private State<T> createMiddleStates(final State<T> sinkState);1490089987;Creates all the states between Start and Final state._@param sinkState the state that last state should point to (always the Final state)_@return the next state after Start in the resulting graph;private State<T> createMiddleStates(final State<T> sinkState) {__			State<T> lastSink = sinkState__			while (currentPattern.getPrevious() != null) {_				checkPatternNameUniqueness()___				State<T> sourceState = new State<>(currentPattern.getName(), State.StateType.Normal)__				states.add(sourceState)__				usedNames.add(sourceState.getName())___				if (currentPattern.getQuantifier().hasProperty(QuantifierProperty.LOOPING)) {_					convertToLooping(sourceState, lastSink)___					if (currentPattern.getQuantifier().hasProperty(QuantifierProperty.AT_LEAST_ONE)) {_						sourceState = createFirstMandatoryStateOfLoop(sourceState, State.StateType.Normal)__						states.add(sourceState)__						usedNames.add(sourceState.getName())__					}_				} else if (currentPattern.getQuantifier() == Quantifier.TIMES) {_					sourceState = convertToTimesState(sourceState, lastSink, currentPattern.getTimes())__				} else {_					convertToSingletonState(sourceState, lastSink)__				}__				currentPattern = currentPattern.getPrevious()__				lastSink = sourceState___				final Time currentWindowTime = currentPattern.getWindowTime()__				if (currentWindowTime != null && currentWindowTime.toMilliseconds() < windowTime) {_					_					windowTime = currentWindowTime.toMilliseconds()__				}_			}__			return lastSink__		};creates,all,the,states,between,start,and,final,state,param,sink,state,the,state,that,last,state,should,point,to,always,the,final,state,return,the,next,state,after,start,in,the,resulting,graph;private,state,t,create,middle,states,final,state,t,sink,state,state,t,last,sink,sink,state,while,current,pattern,get,previous,null,check,pattern,name,uniqueness,state,t,source,state,new,state,current,pattern,get,name,state,state,type,normal,states,add,source,state,used,names,add,source,state,get,name,if,current,pattern,get,quantifier,has,property,quantifier,property,looping,convert,to,looping,source,state,last,sink,if,current,pattern,get,quantifier,has,property,quantifier,property,source,state,create,first,mandatory,state,of,loop,source,state,state,state,type,normal,states,add,source,state,used,names,add,source,state,get,name,else,if,current,pattern,get,quantifier,quantifier,times,source,state,convert,to,times,state,source,state,last,sink,current,pattern,get,times,else,convert,to,singleton,state,source,state,last,sink,current,pattern,current,pattern,get,previous,last,sink,source,state,final,time,current,window,time,current,pattern,get,window,time,if,current,window,time,null,current,window,time,to,milliseconds,window,time,window,time,current,window,time,to,milliseconds,return,last,sink
NFACompiler -> NFAFactoryCompiler -> private State<T> createMiddleStates(final State<T> sinkState);1490194327;Creates all the states between Start and Final state._@param sinkState the state that last state should point to (always the Final state)_@return the next state after Start in the resulting graph;private State<T> createMiddleStates(final State<T> sinkState) {__			State<T> lastSink = sinkState__			while (currentPattern.getPrevious() != null) {_				checkPatternNameUniqueness()___				State<T> sourceState = new State<>(currentPattern.getName(), State.StateType.Normal)__				states.add(sourceState)__				usedNames.add(sourceState.getName())___				if (currentPattern.getQuantifier().hasProperty(QuantifierProperty.LOOPING)) {_					convertToLooping(sourceState, lastSink)___					if (currentPattern.getQuantifier().hasProperty(QuantifierProperty.AT_LEAST_ONE)) {_						sourceState = createFirstMandatoryStateOfLoop(sourceState, State.StateType.Normal)__						states.add(sourceState)__						usedNames.add(sourceState.getName())__					}_				} else if (currentPattern.getQuantifier() == Quantifier.TIMES) {_					sourceState = convertToTimesState(sourceState, lastSink, currentPattern.getTimes())__				} else {_					convertToSingletonState(sourceState, lastSink)__				}__				currentPattern = currentPattern.getPrevious()__				lastSink = sourceState___				final Time currentWindowTime = currentPattern.getWindowTime()__				if (currentWindowTime != null && currentWindowTime.toMilliseconds() < windowTime) {_					_					windowTime = currentWindowTime.toMilliseconds()__				}_			}__			return lastSink__		};creates,all,the,states,between,start,and,final,state,param,sink,state,the,state,that,last,state,should,point,to,always,the,final,state,return,the,next,state,after,start,in,the,resulting,graph;private,state,t,create,middle,states,final,state,t,sink,state,state,t,last,sink,sink,state,while,current,pattern,get,previous,null,check,pattern,name,uniqueness,state,t,source,state,new,state,current,pattern,get,name,state,state,type,normal,states,add,source,state,used,names,add,source,state,get,name,if,current,pattern,get,quantifier,has,property,quantifier,property,looping,convert,to,looping,source,state,last,sink,if,current,pattern,get,quantifier,has,property,quantifier,property,source,state,create,first,mandatory,state,of,loop,source,state,state,state,type,normal,states,add,source,state,used,names,add,source,state,get,name,else,if,current,pattern,get,quantifier,quantifier,times,source,state,convert,to,times,state,source,state,last,sink,current,pattern,get,times,else,convert,to,singleton,state,source,state,last,sink,current,pattern,current,pattern,get,previous,last,sink,source,state,final,time,current,window,time,current,pattern,get,window,time,if,current,window,time,null,current,window,time,to,milliseconds,window,time,window,time,current,window,time,to,milliseconds,return,last,sink
NFACompiler -> NFAFactoryCompiler -> private State<T> createMiddleStates(final State<T> sinkState);1490619911;Creates all the states between Start and Final state.__@param sinkState the state that last state should point to (always the Final state)_@return the next state after Start in the resulting graph;private State<T> createMiddleStates(final State<T> sinkState) {__			State<T> lastSink = sinkState__			while (currentPattern.getPrevious() != null) {_				checkPatternNameUniqueness()__				usedNames.add(currentPattern.getName())___				if (currentPattern.getQuantifier().hasProperty(QuantifierProperty.LOOPING)) {_					final State<T> looping = createLooping(lastSink)___					if (currentPattern.getQuantifier().hasProperty(QuantifierProperty.AT_LEAST_ONE)) {_						lastSink = createFirstMandatoryStateOfLoop(looping)__					} else if (currentPattern instanceof FollowedByPattern &&_								currentPattern.getQuantifier().hasProperty(QuantifierProperty.STRICT)) {_						lastSink = createWaitingStateForZeroOrMore(looping, lastSink)__					} else {_						lastSink = looping__					}_				} else if (currentPattern.getQuantifier().hasProperty(QuantifierProperty.TIMES)) {_					lastSink = createTimesState(lastSink, currentPattern.getTimes())__				} else {_					lastSink = createSingletonState(lastSink)__				}_				currentPattern = currentPattern.getPrevious()___				final Time currentWindowTime = currentPattern.getWindowTime()__				if (currentWindowTime != null && currentWindowTime.toMilliseconds() < windowTime) {_					_					windowTime = currentWindowTime.toMilliseconds()__				}_			}__			return lastSink__		};creates,all,the,states,between,start,and,final,state,param,sink,state,the,state,that,last,state,should,point,to,always,the,final,state,return,the,next,state,after,start,in,the,resulting,graph;private,state,t,create,middle,states,final,state,t,sink,state,state,t,last,sink,sink,state,while,current,pattern,get,previous,null,check,pattern,name,uniqueness,used,names,add,current,pattern,get,name,if,current,pattern,get,quantifier,has,property,quantifier,property,looping,final,state,t,looping,create,looping,last,sink,if,current,pattern,get,quantifier,has,property,quantifier,property,last,sink,create,first,mandatory,state,of,loop,looping,else,if,current,pattern,instanceof,followed,by,pattern,current,pattern,get,quantifier,has,property,quantifier,property,strict,last,sink,create,waiting,state,for,zero,or,more,looping,last,sink,else,last,sink,looping,else,if,current,pattern,get,quantifier,has,property,quantifier,property,times,last,sink,create,times,state,last,sink,current,pattern,get,times,else,last,sink,create,singleton,state,last,sink,current,pattern,current,pattern,get,previous,final,time,current,window,time,current,pattern,get,window,time,if,current,window,time,null,current,window,time,to,milliseconds,window,time,window,time,current,window,time,to,milliseconds,return,last,sink
NFACompiler -> NFAFactoryCompiler -> private State<T> createMiddleStates(final State<T> sinkState);1491320734;Creates all the states between Start and Final state.__@param sinkState the state that last state should point to (always the Final state)_@return the next state after Start in the resulting graph;private State<T> createMiddleStates(final State<T> sinkState) {__			State<T> lastSink = sinkState__			while (currentPattern.getPrevious() != null) {_				checkPatternNameUniqueness()__				usedNames.add(currentPattern.getName())___				if (currentPattern.getQuantifier().hasProperty(QuantifierProperty.LOOPING)) {_					final State<T> looping = createLooping(lastSink)___					if (!currentPattern.getQuantifier().hasProperty(QuantifierProperty.OPTIONAL)) {_						lastSink = createFirstMandatoryStateOfLoop(looping)__					} else if (currentPattern instanceof FollowedByPattern &&_								currentPattern.getQuantifier().hasProperty(QuantifierProperty.CONSECUTIVE)) {_						lastSink = createWaitingStateForZeroOrMore(looping, lastSink)__					} else {_						lastSink = looping__					}_				} else if (currentPattern.getQuantifier().hasProperty(QuantifierProperty.TIMES)) {_					lastSink = createTimesState(lastSink, currentPattern.getTimes())__				} else {_					lastSink = createSingletonState(lastSink)__				}_				currentPattern = currentPattern.getPrevious()___				final Time currentWindowTime = currentPattern.getWindowTime()__				if (currentWindowTime != null && currentWindowTime.toMilliseconds() < windowTime) {_					_					windowTime = currentWindowTime.toMilliseconds()__				}_			}__			return lastSink__		};creates,all,the,states,between,start,and,final,state,param,sink,state,the,state,that,last,state,should,point,to,always,the,final,state,return,the,next,state,after,start,in,the,resulting,graph;private,state,t,create,middle,states,final,state,t,sink,state,state,t,last,sink,sink,state,while,current,pattern,get,previous,null,check,pattern,name,uniqueness,used,names,add,current,pattern,get,name,if,current,pattern,get,quantifier,has,property,quantifier,property,looping,final,state,t,looping,create,looping,last,sink,if,current,pattern,get,quantifier,has,property,quantifier,property,optional,last,sink,create,first,mandatory,state,of,loop,looping,else,if,current,pattern,instanceof,followed,by,pattern,current,pattern,get,quantifier,has,property,quantifier,property,consecutive,last,sink,create,waiting,state,for,zero,or,more,looping,last,sink,else,last,sink,looping,else,if,current,pattern,get,quantifier,has,property,quantifier,property,times,last,sink,create,times,state,last,sink,current,pattern,get,times,else,last,sink,create,singleton,state,last,sink,current,pattern,current,pattern,get,previous,final,time,current,window,time,current,pattern,get,window,time,if,current,window,time,null,current,window,time,to,milliseconds,window,time,window,time,current,window,time,to,milliseconds,return,last,sink
NFACompiler -> NFAFactoryCompiler -> private State<T> createMiddleStates(final State<T> sinkState);1491323030;Creates all the states between Start and Final state.__@param sinkState the state that last state should point to (always the Final state)_@return the next state after Start in the resulting graph;private State<T> createMiddleStates(final State<T> sinkState) {__			State<T> lastSink = sinkState__			while (currentPattern.getPrevious() != null) {_				checkPatternNameUniqueness()__				usedNames.add(currentPattern.getName())___				if (currentPattern.getQuantifier().hasProperty(QuantifierProperty.LOOPING)) {_					final State<T> looping = createLooping(lastSink)___					if (currentPattern.getQuantifier().hasProperty(QuantifierProperty.AT_LEAST_ONE)) {_						lastSink = createFirstMandatoryStateOfLoop(looping)__					} else if (currentPattern instanceof FollowedByPattern &&_								currentPattern.getQuantifier().hasProperty(QuantifierProperty.STRICT)) {_						lastSink = createWaitingStateForZeroOrMore(looping, lastSink)__					} else {_						lastSink = looping__					}_				} else if (currentPattern.getQuantifier().hasProperty(QuantifierProperty.TIMES)) {_					lastSink = createTimesState(lastSink, currentPattern.getTimes())__				} else {_					lastSink = createSingletonState(lastSink)__				}_				currentPattern = currentPattern.getPrevious()___				final Time currentWindowTime = currentPattern.getWindowTime()__				if (currentWindowTime != null && currentWindowTime.toMilliseconds() < windowTime) {_					_					windowTime = currentWindowTime.toMilliseconds()__				}_			}__			return lastSink__		};creates,all,the,states,between,start,and,final,state,param,sink,state,the,state,that,last,state,should,point,to,always,the,final,state,return,the,next,state,after,start,in,the,resulting,graph;private,state,t,create,middle,states,final,state,t,sink,state,state,t,last,sink,sink,state,while,current,pattern,get,previous,null,check,pattern,name,uniqueness,used,names,add,current,pattern,get,name,if,current,pattern,get,quantifier,has,property,quantifier,property,looping,final,state,t,looping,create,looping,last,sink,if,current,pattern,get,quantifier,has,property,quantifier,property,last,sink,create,first,mandatory,state,of,loop,looping,else,if,current,pattern,instanceof,followed,by,pattern,current,pattern,get,quantifier,has,property,quantifier,property,strict,last,sink,create,waiting,state,for,zero,or,more,looping,last,sink,else,last,sink,looping,else,if,current,pattern,get,quantifier,has,property,quantifier,property,times,last,sink,create,times,state,last,sink,current,pattern,get,times,else,last,sink,create,singleton,state,last,sink,current,pattern,current,pattern,get,previous,final,time,current,window,time,current,pattern,get,window,time,if,current,window,time,null,current,window,time,to,milliseconds,window,time,window,time,current,window,time,to,milliseconds,return,last,sink
NFACompiler -> NFAFactoryCompiler -> private State<T> createMiddleStates(final State<T> sinkState);1491633862;Creates all the states between Start and Final state.__@param sinkState the state that last state should point to (always the Final state)_@return the next state after Start in the resulting graph;private State<T> createMiddleStates(final State<T> sinkState) {__			State<T> lastSink = sinkState__			while (currentPattern.getPrevious() != null) {_				checkPatternNameUniqueness()__				usedNames.add(currentPattern.getName())___				if (currentPattern.getQuantifier().hasProperty(QuantifierProperty.LOOPING)) {_					final State<T> looping = createLooping(lastSink)___					if (currentPattern.getQuantifier().hasProperty(QuantifierProperty.AT_LEAST_ONE)) {_						lastSink = createFirstMandatoryStateOfLoop(looping)__					} else if (currentPattern instanceof FollowedByPattern &&_								currentPattern.getQuantifier().hasProperty(QuantifierProperty.STRICT)) {_						lastSink = createWaitingStateForZeroOrMore(looping, lastSink)__					} else {_						lastSink = looping__					}_				} else if (currentPattern.getQuantifier().hasProperty(QuantifierProperty.TIMES)) {_					lastSink = createTimesState(lastSink, currentPattern.getTimes())__				} else {_					lastSink = createSingletonState(lastSink)__				}_				currentPattern = currentPattern.getPrevious()___				final Time currentWindowTime = currentPattern.getWindowTime()__				if (currentWindowTime != null && currentWindowTime.toMilliseconds() < windowTime) {_					_					windowTime = currentWindowTime.toMilliseconds()__				}_			}__			return lastSink__		};creates,all,the,states,between,start,and,final,state,param,sink,state,the,state,that,last,state,should,point,to,always,the,final,state,return,the,next,state,after,start,in,the,resulting,graph;private,state,t,create,middle,states,final,state,t,sink,state,state,t,last,sink,sink,state,while,current,pattern,get,previous,null,check,pattern,name,uniqueness,used,names,add,current,pattern,get,name,if,current,pattern,get,quantifier,has,property,quantifier,property,looping,final,state,t,looping,create,looping,last,sink,if,current,pattern,get,quantifier,has,property,quantifier,property,last,sink,create,first,mandatory,state,of,loop,looping,else,if,current,pattern,instanceof,followed,by,pattern,current,pattern,get,quantifier,has,property,quantifier,property,strict,last,sink,create,waiting,state,for,zero,or,more,looping,last,sink,else,last,sink,looping,else,if,current,pattern,get,quantifier,has,property,quantifier,property,times,last,sink,create,times,state,last,sink,current,pattern,get,times,else,last,sink,create,singleton,state,last,sink,current,pattern,current,pattern,get,previous,final,time,current,window,time,current,pattern,get,window,time,if,current,window,time,null,current,window,time,to,milliseconds,window,time,window,time,current,window,time,to,milliseconds,return,last,sink
NFACompiler -> NFAFactoryCompiler -> private State<T> createMiddleStates(final State<T> sinkState);1492797583;Creates all the states between Start and Final state.__@param sinkState the state that last state should point to (always the Final state)_@return the next state after Start in the resulting graph;private State<T> createMiddleStates(final State<T> sinkState) {__			State<T> lastSink = sinkState__			while (currentPattern.getPrevious() != null) {_				checkPatternNameUniqueness()__				usedNames.add(currentPattern.getName())___				if (currentPattern.getQuantifier().hasProperty(QuantifierProperty.LOOPING)) {_					final State<T> looping = createLooping(lastSink)___					if (!currentPattern.getQuantifier().hasProperty(QuantifierProperty.OPTIONAL)) {_						lastSink = createFirstMandatoryStateOfLoop(looping)__					} else if (currentPattern instanceof FollowedByPattern &&_								currentPattern.getQuantifier().hasProperty(QuantifierProperty.CONSECUTIVE)) {_						lastSink = createWaitingStateForZeroOrMore(looping, lastSink)__					} else {_						lastSink = looping__					}_				} else if (currentPattern.getQuantifier().hasProperty(QuantifierProperty.TIMES)) {_					lastSink = createTimesState(lastSink, currentPattern.getTimes())__				} else {_					lastSink = createSingletonState(lastSink)__				}_				currentPattern = currentPattern.getPrevious()___				final Time currentWindowTime = currentPattern.getWindowTime()__				if (currentWindowTime != null && currentWindowTime.toMilliseconds() < windowTime) {_					_					windowTime = currentWindowTime.toMilliseconds()__				}_			}__			return lastSink__		};creates,all,the,states,between,start,and,final,state,param,sink,state,the,state,that,last,state,should,point,to,always,the,final,state,return,the,next,state,after,start,in,the,resulting,graph;private,state,t,create,middle,states,final,state,t,sink,state,state,t,last,sink,sink,state,while,current,pattern,get,previous,null,check,pattern,name,uniqueness,used,names,add,current,pattern,get,name,if,current,pattern,get,quantifier,has,property,quantifier,property,looping,final,state,t,looping,create,looping,last,sink,if,current,pattern,get,quantifier,has,property,quantifier,property,optional,last,sink,create,first,mandatory,state,of,loop,looping,else,if,current,pattern,instanceof,followed,by,pattern,current,pattern,get,quantifier,has,property,quantifier,property,consecutive,last,sink,create,waiting,state,for,zero,or,more,looping,last,sink,else,last,sink,looping,else,if,current,pattern,get,quantifier,has,property,quantifier,property,times,last,sink,create,times,state,last,sink,current,pattern,get,times,else,last,sink,create,singleton,state,last,sink,current,pattern,current,pattern,get,previous,final,time,current,window,time,current,pattern,get,window,time,if,current,window,time,null,current,window,time,to,milliseconds,window,time,window,time,current,window,time,to,milliseconds,return,last,sink
NFACompiler -> NFAFactoryCompiler -> private State<T> createMiddleStates(final State<T> sinkState);1493200673;Creates all the states between Start and Final state.__@param sinkState the state that last state should point to (always the Final state)_@return the next state after Start in the resulting graph;private State<T> createMiddleStates(final State<T> sinkState) {__			State<T> lastSink = sinkState__			while (currentPattern.getPrevious() != null) {_				lastSink = convertPattern(lastSink)__				currentPattern = currentPattern.getPrevious()___				final Time currentWindowTime = currentPattern.getWindowTime()__				if (currentWindowTime != null && currentWindowTime.toMilliseconds() < windowTime) {_					_					windowTime = currentWindowTime.toMilliseconds()__				}_			}__			return lastSink__		};creates,all,the,states,between,start,and,final,state,param,sink,state,the,state,that,last,state,should,point,to,always,the,final,state,return,the,next,state,after,start,in,the,resulting,graph;private,state,t,create,middle,states,final,state,t,sink,state,state,t,last,sink,sink,state,while,current,pattern,get,previous,null,last,sink,convert,pattern,last,sink,current,pattern,current,pattern,get,previous,final,time,current,window,time,current,pattern,get,window,time,if,current,window,time,null,current,window,time,to,milliseconds,window,time,window,time,current,window,time,to,milliseconds,return,last,sink
NFACompiler -> NFAFactoryCompiler -> private State<T> createMiddleStates(final State<T> sinkState);1493385877;Creates all the states between Start and Final state.__@param sinkState the state that last state should point to (always the Final state)_@return the next state after Start in the resulting graph;private State<T> createMiddleStates(final State<T> sinkState) {_			State<T> lastSink = sinkState__			while (currentPattern.getPrevious() != null) {__				if (currentPattern.getQuantifier().getConsumingStrategy() == Quantifier.ConsumingStrategy.NOT_FOLLOW) {_					_				} else if (currentPattern.getQuantifier().getConsumingStrategy() == Quantifier.ConsumingStrategy.NOT_NEXT) {_					final State<T> notNext = createNormalState()__					final IterativeCondition<T> notCondition = (IterativeCondition<T>) currentPattern.getCondition()__					final State<T> stopState = createStopState(notCondition, currentPattern.getName())___					if (lastSink.isFinal()) {_						_						notNext.addIgnore(lastSink, new NotCondition<>(notCondition))__					} else {_						notNext.addProceed(lastSink, new NotCondition<>(notCondition))__					}_					notNext.addProceed(stopState, notCondition)__					lastSink = notNext__				} else {_					lastSink = convertPattern(lastSink)__				}__				_				followingPattern = currentPattern__				currentPattern = currentPattern.getPrevious()___				final Time currentWindowTime = currentPattern.getWindowTime()__				if (currentWindowTime != null && currentWindowTime.toMilliseconds() < windowTime) {_					_					windowTime = currentWindowTime.toMilliseconds()__				}_			}_			return lastSink__		};creates,all,the,states,between,start,and,final,state,param,sink,state,the,state,that,last,state,should,point,to,always,the,final,state,return,the,next,state,after,start,in,the,resulting,graph;private,state,t,create,middle,states,final,state,t,sink,state,state,t,last,sink,sink,state,while,current,pattern,get,previous,null,if,current,pattern,get,quantifier,get,consuming,strategy,quantifier,consuming,strategy,else,if,current,pattern,get,quantifier,get,consuming,strategy,quantifier,consuming,strategy,final,state,t,not,next,create,normal,state,final,iterative,condition,t,not,condition,iterative,condition,t,current,pattern,get,condition,final,state,t,stop,state,create,stop,state,not,condition,current,pattern,get,name,if,last,sink,is,final,not,next,add,ignore,last,sink,new,not,condition,not,condition,else,not,next,add,proceed,last,sink,new,not,condition,not,condition,not,next,add,proceed,stop,state,not,condition,last,sink,not,next,else,last,sink,convert,pattern,last,sink,following,pattern,current,pattern,current,pattern,current,pattern,get,previous,final,time,current,window,time,current,pattern,get,window,time,if,current,window,time,null,current,window,time,to,milliseconds,window,time,window,time,current,window,time,to,milliseconds,return,last,sink
NFACompiler -> NFAFactoryCompiler -> private State<T> createMiddleStates(final State<T> sinkState);1494947249;Creates all the states between Start and Final state.__@param sinkState the state that last state should point to (always the Final state)_@return the next state after Start in the resulting graph;private State<T> createMiddleStates(final State<T> sinkState) {_			State<T> lastSink = sinkState__			while (currentPattern.getPrevious() != null) {__				if (currentPattern.getQuantifier().getConsumingStrategy() == Quantifier.ConsumingStrategy.NOT_FOLLOW) {_					_				} else if (currentPattern.getQuantifier().getConsumingStrategy() == Quantifier.ConsumingStrategy.NOT_NEXT) {_					checkPatternNameUniqueness(currentPattern.getName())__					final State<T> notNext = createState(currentPattern.getName(), State.StateType.Normal)__					final IterativeCondition<T> notCondition = (IterativeCondition<T>) currentPattern.getCondition()__					final State<T> stopState = createStopState(notCondition, currentPattern.getName())___					if (lastSink.isFinal()) {_						_						notNext.addIgnore(lastSink, new NotCondition<>(notCondition))__					} else {_						notNext.addProceed(lastSink, new NotCondition<>(notCondition))__					}_					notNext.addProceed(stopState, notCondition)__					lastSink = notNext__				} else {_					checkPatternNameUniqueness(currentPattern.getName())__					lastSink = convertPattern(lastSink)__				}__				_				followingPattern = currentPattern__				currentPattern = currentPattern.getPrevious()___				final Time currentWindowTime = currentPattern.getWindowTime()__				if (currentWindowTime != null && currentWindowTime.toMilliseconds() < windowTime) {_					_					windowTime = currentWindowTime.toMilliseconds()__				}_			}_			return lastSink__		};creates,all,the,states,between,start,and,final,state,param,sink,state,the,state,that,last,state,should,point,to,always,the,final,state,return,the,next,state,after,start,in,the,resulting,graph;private,state,t,create,middle,states,final,state,t,sink,state,state,t,last,sink,sink,state,while,current,pattern,get,previous,null,if,current,pattern,get,quantifier,get,consuming,strategy,quantifier,consuming,strategy,else,if,current,pattern,get,quantifier,get,consuming,strategy,quantifier,consuming,strategy,check,pattern,name,uniqueness,current,pattern,get,name,final,state,t,not,next,create,state,current,pattern,get,name,state,state,type,normal,final,iterative,condition,t,not,condition,iterative,condition,t,current,pattern,get,condition,final,state,t,stop,state,create,stop,state,not,condition,current,pattern,get,name,if,last,sink,is,final,not,next,add,ignore,last,sink,new,not,condition,not,condition,else,not,next,add,proceed,last,sink,new,not,condition,not,condition,not,next,add,proceed,stop,state,not,condition,last,sink,not,next,else,check,pattern,name,uniqueness,current,pattern,get,name,last,sink,convert,pattern,last,sink,following,pattern,current,pattern,current,pattern,current,pattern,get,previous,final,time,current,window,time,current,pattern,get,window,time,if,current,window,time,null,current,window,time,to,milliseconds,window,time,window,time,current,window,time,to,milliseconds,return,last,sink
NFACompiler -> NFAFactoryCompiler -> private State<T> createMiddleStates(final State<T> sinkState);1495657626;Creates all the states between Start and Final state.__@param sinkState the state that last state should point to (always the Final state)_@return the next state after Start in the resulting graph;private State<T> createMiddleStates(final State<T> sinkState) {_			State<T> lastSink = sinkState__			while (currentPattern.getPrevious() != null) {__				if (currentPattern.getQuantifier().getConsumingStrategy() == Quantifier.ConsumingStrategy.NOT_FOLLOW) {_					_				} else if (currentPattern.getQuantifier().getConsumingStrategy() == Quantifier.ConsumingStrategy.NOT_NEXT) {_					checkPatternNameUniqueness(currentPattern.getName())__					final State<T> notNext = createState(currentPattern.getName(), State.StateType.Normal)__					final IterativeCondition<T> notCondition = (IterativeCondition<T>) currentPattern.getCondition()__					final State<T> stopState = createStopState(notCondition, currentPattern.getName())___					if (lastSink.isFinal()) {_						_						notNext.addIgnore(lastSink, new NotCondition<>(notCondition))__					} else {_						notNext.addProceed(lastSink, new NotCondition<>(notCondition))__					}_					notNext.addProceed(stopState, notCondition)__					lastSink = notNext__				} else {_					checkPatternNameUniqueness(currentPattern.getName())__					lastSink = convertPattern(lastSink)__				}__				_				followingPattern = currentPattern__				currentPattern = currentPattern.getPrevious()___				final Time currentWindowTime = currentPattern.getWindowTime()__				if (currentWindowTime != null && currentWindowTime.toMilliseconds() < windowTime) {_					_					windowTime = currentWindowTime.toMilliseconds()__				}_			}_			return lastSink__		};creates,all,the,states,between,start,and,final,state,param,sink,state,the,state,that,last,state,should,point,to,always,the,final,state,return,the,next,state,after,start,in,the,resulting,graph;private,state,t,create,middle,states,final,state,t,sink,state,state,t,last,sink,sink,state,while,current,pattern,get,previous,null,if,current,pattern,get,quantifier,get,consuming,strategy,quantifier,consuming,strategy,else,if,current,pattern,get,quantifier,get,consuming,strategy,quantifier,consuming,strategy,check,pattern,name,uniqueness,current,pattern,get,name,final,state,t,not,next,create,state,current,pattern,get,name,state,state,type,normal,final,iterative,condition,t,not,condition,iterative,condition,t,current,pattern,get,condition,final,state,t,stop,state,create,stop,state,not,condition,current,pattern,get,name,if,last,sink,is,final,not,next,add,ignore,last,sink,new,not,condition,not,condition,else,not,next,add,proceed,last,sink,new,not,condition,not,condition,not,next,add,proceed,stop,state,not,condition,last,sink,not,next,else,check,pattern,name,uniqueness,current,pattern,get,name,last,sink,convert,pattern,last,sink,following,pattern,current,pattern,current,pattern,current,pattern,get,previous,final,time,current,window,time,current,pattern,get,window,time,if,current,window,time,null,current,window,time,to,milliseconds,window,time,window,time,current,window,time,to,milliseconds,return,last,sink
NFACompiler -> NFAFactoryCompiler -> private State<T> createMiddleStates(final State<T> sinkState);1496245714;Creates all the states between Start and Final state.__@param sinkState the state that last state should point to (always the Final state)_@return the next state after Start in the resulting graph;private State<T> createMiddleStates(final State<T> sinkState) {_			State<T> lastSink = sinkState__			while (currentPattern.getPrevious() != null) {__				if (currentPattern.getQuantifier().getConsumingStrategy() == Quantifier.ConsumingStrategy.NOT_FOLLOW) {_					_				} else if (currentPattern.getQuantifier().getConsumingStrategy() == Quantifier.ConsumingStrategy.NOT_NEXT) {_					stateNameHandler.checkNameUniqueness(currentPattern.getName())___					final State<T> notNext = createState(currentPattern.getName(), State.StateType.Normal)__					final IterativeCondition<T> notCondition = (IterativeCondition<T>) currentPattern.getCondition()__					final State<T> stopState = createStopState(notCondition, currentPattern.getName())___					if (lastSink.isFinal()) {_						_						notNext.addIgnore(lastSink, new NotCondition<>(notCondition))__					} else {_						notNext.addProceed(lastSink, new NotCondition<>(notCondition))__					}_					notNext.addProceed(stopState, notCondition)__					lastSink = notNext__				} else {_					stateNameHandler.checkNameUniqueness(currentPattern.getName())__					lastSink = convertPattern(lastSink)__				}__				_				followingPattern = currentPattern__				currentPattern = currentPattern.getPrevious()___				final Time currentWindowTime = currentPattern.getWindowTime()__				if (currentWindowTime != null && currentWindowTime.toMilliseconds() < windowTime) {_					_					windowTime = currentWindowTime.toMilliseconds()__				}_			}_			return lastSink__		};creates,all,the,states,between,start,and,final,state,param,sink,state,the,state,that,last,state,should,point,to,always,the,final,state,return,the,next,state,after,start,in,the,resulting,graph;private,state,t,create,middle,states,final,state,t,sink,state,state,t,last,sink,sink,state,while,current,pattern,get,previous,null,if,current,pattern,get,quantifier,get,consuming,strategy,quantifier,consuming,strategy,else,if,current,pattern,get,quantifier,get,consuming,strategy,quantifier,consuming,strategy,state,name,handler,check,name,uniqueness,current,pattern,get,name,final,state,t,not,next,create,state,current,pattern,get,name,state,state,type,normal,final,iterative,condition,t,not,condition,iterative,condition,t,current,pattern,get,condition,final,state,t,stop,state,create,stop,state,not,condition,current,pattern,get,name,if,last,sink,is,final,not,next,add,ignore,last,sink,new,not,condition,not,condition,else,not,next,add,proceed,last,sink,new,not,condition,not,condition,not,next,add,proceed,stop,state,not,condition,last,sink,not,next,else,state,name,handler,check,name,uniqueness,current,pattern,get,name,last,sink,convert,pattern,last,sink,following,pattern,current,pattern,current,pattern,current,pattern,get,previous,final,time,current,window,time,current,pattern,get,window,time,if,current,window,time,null,current,window,time,to,milliseconds,window,time,window,time,current,window,time,to,milliseconds,return,last,sink
NFACompiler -> NFAFactoryCompiler -> private State<T> createMiddleStates(final State<T> sinkState);1497410381;Creates all the states between Start and Final state.__@param sinkState the state that last state should point to (always the Final state)_@return the next state after Start in the resulting graph;private State<T> createMiddleStates(final State<T> sinkState) {_			State<T> lastSink = sinkState__			while (currentPattern.getPrevious() != null) {__				if (currentPattern.getQuantifier().getConsumingStrategy() == Quantifier.ConsumingStrategy.NOT_FOLLOW) {_					_				} else if (currentPattern.getQuantifier().getConsumingStrategy() == Quantifier.ConsumingStrategy.NOT_NEXT) {_					stateNameHandler.checkNameUniqueness(currentPattern.getName())___					final State<T> notNext = createState(currentPattern.getName(), State.StateType.Normal)__					final IterativeCondition<T> notCondition = (IterativeCondition<T>) currentPattern.getCondition()__					final State<T> stopState = createStopState(notCondition, currentPattern.getName())___					if (lastSink.isFinal()) {_						_						notNext.addIgnore(lastSink, new NotCondition<>(notCondition))__					} else {_						notNext.addProceed(lastSink, new NotCondition<>(notCondition))__					}_					notNext.addProceed(stopState, notCondition)__					lastSink = notNext__				} else {_					stateNameHandler.checkNameUniqueness(currentPattern.getName())__					lastSink = convertPattern(lastSink)__				}__				_				followingPattern = currentPattern__				currentPattern = currentPattern.getPrevious()___				final Time currentWindowTime = currentPattern.getWindowTime()__				if (currentWindowTime != null && currentWindowTime.toMilliseconds() < windowTime) {_					_					windowTime = currentWindowTime.toMilliseconds()__				}_			}_			return lastSink__		};creates,all,the,states,between,start,and,final,state,param,sink,state,the,state,that,last,state,should,point,to,always,the,final,state,return,the,next,state,after,start,in,the,resulting,graph;private,state,t,create,middle,states,final,state,t,sink,state,state,t,last,sink,sink,state,while,current,pattern,get,previous,null,if,current,pattern,get,quantifier,get,consuming,strategy,quantifier,consuming,strategy,else,if,current,pattern,get,quantifier,get,consuming,strategy,quantifier,consuming,strategy,state,name,handler,check,name,uniqueness,current,pattern,get,name,final,state,t,not,next,create,state,current,pattern,get,name,state,state,type,normal,final,iterative,condition,t,not,condition,iterative,condition,t,current,pattern,get,condition,final,state,t,stop,state,create,stop,state,not,condition,current,pattern,get,name,if,last,sink,is,final,not,next,add,ignore,last,sink,new,not,condition,not,condition,else,not,next,add,proceed,last,sink,new,not,condition,not,condition,not,next,add,proceed,stop,state,not,condition,last,sink,not,next,else,state,name,handler,check,name,uniqueness,current,pattern,get,name,last,sink,convert,pattern,last,sink,following,pattern,current,pattern,current,pattern,current,pattern,get,previous,final,time,current,window,time,current,pattern,get,window,time,if,current,window,time,null,current,window,time,to,milliseconds,window,time,window,time,current,window,time,to,milliseconds,return,last,sink
NFACompiler -> NFAFactoryCompiler -> private State<T> createMiddleStates(final State<T> sinkState);1497883202;Creates all the states between Start and Final state.__@param sinkState the state that last state should point to (always the Final state)_@return the next state after Start in the resulting graph;private State<T> createMiddleStates(final State<T> sinkState) {_			State<T> lastSink = sinkState__			while (currentPattern.getPrevious() != null) {__				if (currentPattern.getQuantifier().getConsumingStrategy() == Quantifier.ConsumingStrategy.NOT_FOLLOW) {_					_				} else if (currentPattern.getQuantifier().getConsumingStrategy() == Quantifier.ConsumingStrategy.NOT_NEXT) {_					stateNameHandler.checkNameUniqueness(currentPattern.getName())___					final State<T> notNext = createState(currentPattern.getName(), State.StateType.Normal)__					final IterativeCondition<T> notCondition = (IterativeCondition<T>) currentPattern.getCondition()__					final State<T> stopState = createStopState(notCondition, currentPattern.getName())___					if (lastSink.isFinal()) {_						_						notNext.addIgnore(lastSink, new NotCondition<>(notCondition))__					} else {_						notNext.addProceed(lastSink, new NotCondition<>(notCondition))__					}_					notNext.addProceed(stopState, notCondition)__					lastSink = notNext__				} else {_					stateNameHandler.checkNameUniqueness(currentPattern.getName())__					lastSink = convertPattern(lastSink)__				}__				_				followingPattern = currentPattern__				currentPattern = currentPattern.getPrevious()___				final Time currentWindowTime = currentPattern.getWindowTime()__				if (currentWindowTime != null && currentWindowTime.toMilliseconds() < windowTime) {_					_					windowTime = currentWindowTime.toMilliseconds()__				}_			}_			return lastSink__		};creates,all,the,states,between,start,and,final,state,param,sink,state,the,state,that,last,state,should,point,to,always,the,final,state,return,the,next,state,after,start,in,the,resulting,graph;private,state,t,create,middle,states,final,state,t,sink,state,state,t,last,sink,sink,state,while,current,pattern,get,previous,null,if,current,pattern,get,quantifier,get,consuming,strategy,quantifier,consuming,strategy,else,if,current,pattern,get,quantifier,get,consuming,strategy,quantifier,consuming,strategy,state,name,handler,check,name,uniqueness,current,pattern,get,name,final,state,t,not,next,create,state,current,pattern,get,name,state,state,type,normal,final,iterative,condition,t,not,condition,iterative,condition,t,current,pattern,get,condition,final,state,t,stop,state,create,stop,state,not,condition,current,pattern,get,name,if,last,sink,is,final,not,next,add,ignore,last,sink,new,not,condition,not,condition,else,not,next,add,proceed,last,sink,new,not,condition,not,condition,not,next,add,proceed,stop,state,not,condition,last,sink,not,next,else,state,name,handler,check,name,uniqueness,current,pattern,get,name,last,sink,convert,pattern,last,sink,following,pattern,current,pattern,current,pattern,current,pattern,get,previous,final,time,current,window,time,current,pattern,get,window,time,if,current,window,time,null,current,window,time,to,milliseconds,window,time,window,time,current,window,time,to,milliseconds,return,last,sink
NFACompiler -> NFAFactoryCompiler -> private State<T> createMiddleStates(final State<T> sinkState);1498034481;Creates all the states between Start and Final state.__@param sinkState the state that last state should point to (always the Final state)_@return the next state after Start in the resulting graph;private State<T> createMiddleStates(final State<T> sinkState) {_			State<T> lastSink = sinkState__			while (currentPattern.getPrevious() != null) {__				if (currentPattern.getQuantifier().getConsumingStrategy() == Quantifier.ConsumingStrategy.NOT_FOLLOW) {_					_				} else if (currentPattern.getQuantifier().getConsumingStrategy() == Quantifier.ConsumingStrategy.NOT_NEXT) {_					final State<T> notNext = createState(currentPattern.getName(), State.StateType.Normal)__					final IterativeCondition<T> notCondition = getTakeCondition(currentPattern)__					final State<T> stopState = createStopState(notCondition, currentPattern.getName())___					if (lastSink.isFinal()) {_						_						notNext.addIgnore(lastSink, new NotCondition<>(notCondition))__					} else {_						notNext.addProceed(lastSink, new NotCondition<>(notCondition))__					}_					notNext.addProceed(stopState, notCondition)__					lastSink = notNext__				} else {_					lastSink = convertPattern(lastSink)__				}__				_				followingPattern = currentPattern__				currentPattern = currentPattern.getPrevious()___				final Time currentWindowTime = currentPattern.getWindowTime()__				if (currentWindowTime != null && currentWindowTime.toMilliseconds() < windowTime) {_					_					windowTime = currentWindowTime.toMilliseconds()__				}_			}_			return lastSink__		};creates,all,the,states,between,start,and,final,state,param,sink,state,the,state,that,last,state,should,point,to,always,the,final,state,return,the,next,state,after,start,in,the,resulting,graph;private,state,t,create,middle,states,final,state,t,sink,state,state,t,last,sink,sink,state,while,current,pattern,get,previous,null,if,current,pattern,get,quantifier,get,consuming,strategy,quantifier,consuming,strategy,else,if,current,pattern,get,quantifier,get,consuming,strategy,quantifier,consuming,strategy,final,state,t,not,next,create,state,current,pattern,get,name,state,state,type,normal,final,iterative,condition,t,not,condition,get,take,condition,current,pattern,final,state,t,stop,state,create,stop,state,not,condition,current,pattern,get,name,if,last,sink,is,final,not,next,add,ignore,last,sink,new,not,condition,not,condition,else,not,next,add,proceed,last,sink,new,not,condition,not,condition,not,next,add,proceed,stop,state,not,condition,last,sink,not,next,else,last,sink,convert,pattern,last,sink,following,pattern,current,pattern,current,pattern,current,pattern,get,previous,final,time,current,window,time,current,pattern,get,window,time,if,current,window,time,null,current,window,time,to,milliseconds,window,time,window,time,current,window,time,to,milliseconds,return,last,sink
NFACompiler -> NFAFactoryCompiler -> private State<T> createMiddleStates(final State<T> sinkState);1499760222;Creates all the states between Start and Final state.__@param sinkState the state that last state should point to (always the Final state)_@return the next state after Start in the resulting graph;private State<T> createMiddleStates(final State<T> sinkState) {_			State<T> lastSink = sinkState__			while (currentPattern.getPrevious() != null) {__				if (currentPattern.getQuantifier().getConsumingStrategy() == Quantifier.ConsumingStrategy.NOT_FOLLOW) {_					_				} else if (currentPattern.getQuantifier().getConsumingStrategy() == Quantifier.ConsumingStrategy.NOT_NEXT) {_					final State<T> notNext = createState(currentPattern.getName(), State.StateType.Normal)__					final IterativeCondition<T> notCondition = getTakeCondition(currentPattern)__					final State<T> stopState = createStopState(notCondition, currentPattern.getName())___					if (lastSink.isFinal()) {_						_						notNext.addIgnore(lastSink, new NotCondition<>(notCondition))__					} else {_						notNext.addProceed(lastSink, new NotCondition<>(notCondition))__					}_					notNext.addProceed(stopState, notCondition)__					lastSink = notNext__				} else {_					lastSink = convertPattern(lastSink)__				}__				_				followingPattern = currentPattern__				currentPattern = currentPattern.getPrevious()___				final Time currentWindowTime = currentPattern.getWindowTime()__				if (currentWindowTime != null && currentWindowTime.toMilliseconds() < windowTime) {_					_					windowTime = currentWindowTime.toMilliseconds()__				}_			}_			return lastSink__		};creates,all,the,states,between,start,and,final,state,param,sink,state,the,state,that,last,state,should,point,to,always,the,final,state,return,the,next,state,after,start,in,the,resulting,graph;private,state,t,create,middle,states,final,state,t,sink,state,state,t,last,sink,sink,state,while,current,pattern,get,previous,null,if,current,pattern,get,quantifier,get,consuming,strategy,quantifier,consuming,strategy,else,if,current,pattern,get,quantifier,get,consuming,strategy,quantifier,consuming,strategy,final,state,t,not,next,create,state,current,pattern,get,name,state,state,type,normal,final,iterative,condition,t,not,condition,get,take,condition,current,pattern,final,state,t,stop,state,create,stop,state,not,condition,current,pattern,get,name,if,last,sink,is,final,not,next,add,ignore,last,sink,new,not,condition,not,condition,else,not,next,add,proceed,last,sink,new,not,condition,not,condition,not,next,add,proceed,stop,state,not,condition,last,sink,not,next,else,last,sink,convert,pattern,last,sink,following,pattern,current,pattern,current,pattern,current,pattern,get,previous,final,time,current,window,time,current,pattern,get,window,time,if,current,window,time,null,current,window,time,to,milliseconds,window,time,window,time,current,window,time,to,milliseconds,return,last,sink
NFACompiler -> NFAFactoryCompiler -> private State<T> createMiddleStates(final State<T> sinkState);1499937690;Creates all the states between Start and Final state.__@param sinkState the state that last state should point to (always the Final state)_@return the next state after Start in the resulting graph;private State<T> createMiddleStates(final State<T> sinkState) {_			State<T> lastSink = sinkState__			while (currentPattern.getPrevious() != null) {__				if (currentPattern.getQuantifier().getConsumingStrategy() == Quantifier.ConsumingStrategy.NOT_FOLLOW) {_					_				} else if (currentPattern.getQuantifier().getConsumingStrategy() == Quantifier.ConsumingStrategy.NOT_NEXT) {_					final State<T> notNext = createState(currentPattern.getName(), State.StateType.Normal)__					final IterativeCondition<T> notCondition = getTakeCondition(currentPattern)__					final State<T> stopState = createStopState(notCondition, currentPattern.getName())___					if (lastSink.isFinal()) {_						_						notNext.addIgnore(lastSink, new NotCondition<>(notCondition))__					} else {_						notNext.addProceed(lastSink, new NotCondition<>(notCondition))__					}_					notNext.addProceed(stopState, notCondition)__					lastSink = notNext__				} else {_					lastSink = convertPattern(lastSink)__				}__				_				followingPattern = currentPattern__				currentPattern = currentPattern.getPrevious()___				final Time currentWindowTime = currentPattern.getWindowTime()__				if (currentWindowTime != null && currentWindowTime.toMilliseconds() < windowTime) {_					_					windowTime = currentWindowTime.toMilliseconds()__				}_			}_			return lastSink__		};creates,all,the,states,between,start,and,final,state,param,sink,state,the,state,that,last,state,should,point,to,always,the,final,state,return,the,next,state,after,start,in,the,resulting,graph;private,state,t,create,middle,states,final,state,t,sink,state,state,t,last,sink,sink,state,while,current,pattern,get,previous,null,if,current,pattern,get,quantifier,get,consuming,strategy,quantifier,consuming,strategy,else,if,current,pattern,get,quantifier,get,consuming,strategy,quantifier,consuming,strategy,final,state,t,not,next,create,state,current,pattern,get,name,state,state,type,normal,final,iterative,condition,t,not,condition,get,take,condition,current,pattern,final,state,t,stop,state,create,stop,state,not,condition,current,pattern,get,name,if,last,sink,is,final,not,next,add,ignore,last,sink,new,not,condition,not,condition,else,not,next,add,proceed,last,sink,new,not,condition,not,condition,not,next,add,proceed,stop,state,not,condition,last,sink,not,next,else,last,sink,convert,pattern,last,sink,following,pattern,current,pattern,current,pattern,current,pattern,get,previous,final,time,current,window,time,current,pattern,get,window,time,if,current,window,time,null,current,window,time,to,milliseconds,window,time,window,time,current,window,time,to,milliseconds,return,last,sink
NFACompiler -> NFAFactoryCompiler -> private State<T> createMiddleStates(final State<T> sinkState);1500021711;Creates all the states between Start and Final state.__@param sinkState the state that last state should point to (always the Final state)_@return the next state after Start in the resulting graph;private State<T> createMiddleStates(final State<T> sinkState) {_			State<T> lastSink = sinkState__			while (currentPattern.getPrevious() != null) {__				if (currentPattern.getQuantifier().getConsumingStrategy() == Quantifier.ConsumingStrategy.NOT_FOLLOW) {_					_				} else if (currentPattern.getQuantifier().getConsumingStrategy() == Quantifier.ConsumingStrategy.NOT_NEXT) {_					final State<T> notNext = createState(currentPattern.getName(), State.StateType.Normal)__					final IterativeCondition<T> notCondition = getTakeCondition(currentPattern)__					final State<T> stopState = createStopState(notCondition, currentPattern.getName())___					if (lastSink.isFinal()) {_						_						notNext.addIgnore(lastSink, new NotCondition<>(notCondition))__					} else {_						notNext.addProceed(lastSink, new NotCondition<>(notCondition))__					}_					notNext.addProceed(stopState, notCondition)__					lastSink = notNext__				} else {_					lastSink = convertPattern(lastSink)__				}__				_				followingPattern = currentPattern__				currentPattern = currentPattern.getPrevious()___				final Time currentWindowTime = currentPattern.getWindowTime()__				if (currentWindowTime != null && currentWindowTime.toMilliseconds() < windowTime) {_					_					windowTime = currentWindowTime.toMilliseconds()__				}_			}_			return lastSink__		};creates,all,the,states,between,start,and,final,state,param,sink,state,the,state,that,last,state,should,point,to,always,the,final,state,return,the,next,state,after,start,in,the,resulting,graph;private,state,t,create,middle,states,final,state,t,sink,state,state,t,last,sink,sink,state,while,current,pattern,get,previous,null,if,current,pattern,get,quantifier,get,consuming,strategy,quantifier,consuming,strategy,else,if,current,pattern,get,quantifier,get,consuming,strategy,quantifier,consuming,strategy,final,state,t,not,next,create,state,current,pattern,get,name,state,state,type,normal,final,iterative,condition,t,not,condition,get,take,condition,current,pattern,final,state,t,stop,state,create,stop,state,not,condition,current,pattern,get,name,if,last,sink,is,final,not,next,add,ignore,last,sink,new,not,condition,not,condition,else,not,next,add,proceed,last,sink,new,not,condition,not,condition,not,next,add,proceed,stop,state,not,condition,last,sink,not,next,else,last,sink,convert,pattern,last,sink,following,pattern,current,pattern,current,pattern,current,pattern,get,previous,final,time,current,window,time,current,pattern,get,window,time,if,current,window,time,null,current,window,time,to,milliseconds,window,time,window,time,current,window,time,to,milliseconds,return,last,sink
NFACompiler -> NFAFactoryCompiler -> private State<T> createMiddleStates(final State<T> sinkState);1501592283;Creates all the states between Start and Final state.__@param sinkState the state that last state should point to (always the Final state)_@return the next state after Start in the resulting graph;private State<T> createMiddleStates(final State<T> sinkState) {_			State<T> lastSink = sinkState__			while (currentPattern.getPrevious() != null) {__				if (currentPattern.getQuantifier().getConsumingStrategy() == Quantifier.ConsumingStrategy.NOT_FOLLOW) {_					_				} else if (currentPattern.getQuantifier().getConsumingStrategy() == Quantifier.ConsumingStrategy.NOT_NEXT) {_					final State<T> notNext = createState(currentPattern.getName(), State.StateType.Normal)__					final IterativeCondition<T> notCondition = getTakeCondition(currentPattern)__					final State<T> stopState = createStopState(notCondition, currentPattern.getName())___					if (lastSink.isFinal()) {_						_						notNext.addIgnore(lastSink, new NotCondition<>(notCondition))__					} else {_						notNext.addProceed(lastSink, new NotCondition<>(notCondition))__					}_					notNext.addProceed(stopState, notCondition)__					lastSink = notNext__				} else {_					lastSink = convertPattern(lastSink)__				}__				_				followingPattern = currentPattern__				currentPattern = currentPattern.getPrevious()___				final Time currentWindowTime = currentPattern.getWindowTime()__				if (currentWindowTime != null && currentWindowTime.toMilliseconds() < windowTime) {_					_					windowTime = currentWindowTime.toMilliseconds()__				}_			}_			return lastSink__		};creates,all,the,states,between,start,and,final,state,param,sink,state,the,state,that,last,state,should,point,to,always,the,final,state,return,the,next,state,after,start,in,the,resulting,graph;private,state,t,create,middle,states,final,state,t,sink,state,state,t,last,sink,sink,state,while,current,pattern,get,previous,null,if,current,pattern,get,quantifier,get,consuming,strategy,quantifier,consuming,strategy,else,if,current,pattern,get,quantifier,get,consuming,strategy,quantifier,consuming,strategy,final,state,t,not,next,create,state,current,pattern,get,name,state,state,type,normal,final,iterative,condition,t,not,condition,get,take,condition,current,pattern,final,state,t,stop,state,create,stop,state,not,condition,current,pattern,get,name,if,last,sink,is,final,not,next,add,ignore,last,sink,new,not,condition,not,condition,else,not,next,add,proceed,last,sink,new,not,condition,not,condition,not,next,add,proceed,stop,state,not,condition,last,sink,not,next,else,last,sink,convert,pattern,last,sink,following,pattern,current,pattern,current,pattern,current,pattern,get,previous,final,time,current,window,time,current,pattern,get,window,time,if,current,window,time,null,current,window,time,to,milliseconds,window,time,window,time,current,window,time,to,milliseconds,return,last,sink
NFACompiler -> NFAFactoryCompiler -> private State<T> createMiddleStates(final State<T> sinkState);1502422141;Creates all the states between Start and Final state.__@param sinkState the state that last state should point to (always the Final state)_@return the next state after Start in the resulting graph;private State<T> createMiddleStates(final State<T> sinkState) {_			State<T> lastSink = sinkState__			while (currentPattern.getPrevious() != null) {__				if (currentPattern.getQuantifier().getConsumingStrategy() == Quantifier.ConsumingStrategy.NOT_FOLLOW) {_					_				} else if (currentPattern.getQuantifier().getConsumingStrategy() == Quantifier.ConsumingStrategy.NOT_NEXT) {_					final State<T> notNext = createState(currentPattern.getName(), State.StateType.Normal)__					final IterativeCondition<T> notCondition = getTakeCondition(currentPattern)__					final State<T> stopState = createStopState(notCondition, currentPattern.getName())___					if (lastSink.isFinal()) {_						_						notNext.addIgnore(lastSink, new NotCondition<>(notCondition))__					} else {_						notNext.addProceed(lastSink, new NotCondition<>(notCondition))__					}_					notNext.addProceed(stopState, notCondition)__					lastSink = notNext__				} else {_					lastSink = convertPattern(lastSink)__				}__				_				followingPattern = currentPattern__				currentPattern = currentPattern.getPrevious()___				final Time currentWindowTime = currentPattern.getWindowTime()__				if (currentWindowTime != null && currentWindowTime.toMilliseconds() < windowTime) {_					_					windowTime = currentWindowTime.toMilliseconds()__				}_			}_			return lastSink__		};creates,all,the,states,between,start,and,final,state,param,sink,state,the,state,that,last,state,should,point,to,always,the,final,state,return,the,next,state,after,start,in,the,resulting,graph;private,state,t,create,middle,states,final,state,t,sink,state,state,t,last,sink,sink,state,while,current,pattern,get,previous,null,if,current,pattern,get,quantifier,get,consuming,strategy,quantifier,consuming,strategy,else,if,current,pattern,get,quantifier,get,consuming,strategy,quantifier,consuming,strategy,final,state,t,not,next,create,state,current,pattern,get,name,state,state,type,normal,final,iterative,condition,t,not,condition,get,take,condition,current,pattern,final,state,t,stop,state,create,stop,state,not,condition,current,pattern,get,name,if,last,sink,is,final,not,next,add,ignore,last,sink,new,not,condition,not,condition,else,not,next,add,proceed,last,sink,new,not,condition,not,condition,not,next,add,proceed,stop,state,not,condition,last,sink,not,next,else,last,sink,convert,pattern,last,sink,following,pattern,current,pattern,current,pattern,current,pattern,get,previous,final,time,current,window,time,current,pattern,get,window,time,if,current,window,time,null,current,window,time,to,milliseconds,window,time,window,time,current,window,time,to,milliseconds,return,last,sink
NFACompiler -> NFAFactoryCompiler -> private State<T> createMiddleStates(final State<T> sinkState);1503588494;Creates all the states between Start and Final state.__@param sinkState the state that last state should point to (always the Final state)_@return the next state after Start in the resulting graph;private State<T> createMiddleStates(final State<T> sinkState) {_			State<T> lastSink = sinkState__			while (currentPattern.getPrevious() != null) {__				if (currentPattern.getQuantifier().getConsumingStrategy() == Quantifier.ConsumingStrategy.NOT_FOLLOW) {_					_				} else if (currentPattern.getQuantifier().getConsumingStrategy() == Quantifier.ConsumingStrategy.NOT_NEXT) {_					final State<T> notNext = createState(currentPattern.getName(), State.StateType.Normal)__					final IterativeCondition<T> notCondition = getTakeCondition(currentPattern)__					final State<T> stopState = createStopState(notCondition, currentPattern.getName())___					if (lastSink.isFinal()) {_						_						notNext.addIgnore(lastSink, new NotCondition<>(notCondition))__					} else {_						notNext.addProceed(lastSink, new NotCondition<>(notCondition))__					}_					notNext.addProceed(stopState, notCondition)__					lastSink = notNext__				} else {_					lastSink = convertPattern(lastSink)__				}__				_				followingPattern = currentPattern__				currentPattern = currentPattern.getPrevious()___				final Time currentWindowTime = currentPattern.getWindowTime()__				if (currentWindowTime != null && currentWindowTime.toMilliseconds() < windowTime) {_					_					windowTime = currentWindowTime.toMilliseconds()__				}_			}_			return lastSink__		};creates,all,the,states,between,start,and,final,state,param,sink,state,the,state,that,last,state,should,point,to,always,the,final,state,return,the,next,state,after,start,in,the,resulting,graph;private,state,t,create,middle,states,final,state,t,sink,state,state,t,last,sink,sink,state,while,current,pattern,get,previous,null,if,current,pattern,get,quantifier,get,consuming,strategy,quantifier,consuming,strategy,else,if,current,pattern,get,quantifier,get,consuming,strategy,quantifier,consuming,strategy,final,state,t,not,next,create,state,current,pattern,get,name,state,state,type,normal,final,iterative,condition,t,not,condition,get,take,condition,current,pattern,final,state,t,stop,state,create,stop,state,not,condition,current,pattern,get,name,if,last,sink,is,final,not,next,add,ignore,last,sink,new,not,condition,not,condition,else,not,next,add,proceed,last,sink,new,not,condition,not,condition,not,next,add,proceed,stop,state,not,condition,last,sink,not,next,else,last,sink,convert,pattern,last,sink,following,pattern,current,pattern,current,pattern,current,pattern,get,previous,final,time,current,window,time,current,pattern,get,window,time,if,current,window,time,null,current,window,time,to,milliseconds,window,time,window,time,current,window,time,to,milliseconds,return,last,sink
NFACompiler -> NFAFactoryCompiler -> private State<T> createMiddleStates(final State<T> sinkState);1518008111;Creates all the states between Start and Final state.__@param sinkState the state that last state should point to (always the Final state)_@return the next state after Start in the resulting graph;private State<T> createMiddleStates(final State<T> sinkState) {_			State<T> lastSink = sinkState__			while (currentPattern.getPrevious() != null) {__				if (currentPattern.getQuantifier().getConsumingStrategy() == Quantifier.ConsumingStrategy.NOT_FOLLOW) {_					_				} else if (currentPattern.getQuantifier().getConsumingStrategy() == Quantifier.ConsumingStrategy.NOT_NEXT) {_					final State<T> notNext = createState(currentPattern.getName(), State.StateType.Normal)__					final IterativeCondition<T> notCondition = getTakeCondition(currentPattern)__					final State<T> stopState = createStopState(notCondition, currentPattern.getName())___					if (lastSink.isFinal()) {_						_						notNext.addIgnore(lastSink, new NotCondition<>(notCondition))__					} else {_						notNext.addProceed(lastSink, new NotCondition<>(notCondition))__					}_					notNext.addProceed(stopState, notCondition)__					lastSink = notNext__				} else {_					lastSink = convertPattern(lastSink)__				}__				_				followingPattern = currentPattern__				currentPattern = currentPattern.getPrevious()___				final Time currentWindowTime = currentPattern.getWindowTime()__				if (currentWindowTime != null && currentWindowTime.toMilliseconds() < windowTime) {_					_					windowTime = currentWindowTime.toMilliseconds()__				}_			}_			return lastSink__		};creates,all,the,states,between,start,and,final,state,param,sink,state,the,state,that,last,state,should,point,to,always,the,final,state,return,the,next,state,after,start,in,the,resulting,graph;private,state,t,create,middle,states,final,state,t,sink,state,state,t,last,sink,sink,state,while,current,pattern,get,previous,null,if,current,pattern,get,quantifier,get,consuming,strategy,quantifier,consuming,strategy,else,if,current,pattern,get,quantifier,get,consuming,strategy,quantifier,consuming,strategy,final,state,t,not,next,create,state,current,pattern,get,name,state,state,type,normal,final,iterative,condition,t,not,condition,get,take,condition,current,pattern,final,state,t,stop,state,create,stop,state,not,condition,current,pattern,get,name,if,last,sink,is,final,not,next,add,ignore,last,sink,new,not,condition,not,condition,else,not,next,add,proceed,last,sink,new,not,condition,not,condition,not,next,add,proceed,stop,state,not,condition,last,sink,not,next,else,last,sink,convert,pattern,last,sink,following,pattern,current,pattern,current,pattern,current,pattern,get,previous,final,time,current,window,time,current,pattern,get,window,time,if,current,window,time,null,current,window,time,to,milliseconds,window,time,window,time,current,window,time,to,milliseconds,return,last,sink
NFACompiler -> NFAFactoryCompiler -> private State<T> createMiddleStates(final State<T> sinkState);1527863170;Creates all the states between Start and Final state.__@param sinkState the state that last state should point to (always the Final state)_@return the next state after Start in the resulting graph;private State<T> createMiddleStates(final State<T> sinkState) {_			State<T> lastSink = sinkState__			while (currentPattern.getPrevious() != null) {__				if (currentPattern.getQuantifier().getConsumingStrategy() == Quantifier.ConsumingStrategy.NOT_FOLLOW) {_					_				} else if (currentPattern.getQuantifier().getConsumingStrategy() == Quantifier.ConsumingStrategy.NOT_NEXT) {_					final State<T> notNext = createState(currentPattern.getName(), State.StateType.Normal)__					final IterativeCondition<T> notCondition = getTakeCondition(currentPattern)__					final State<T> stopState = createStopState(notCondition, currentPattern.getName())___					if (lastSink.isFinal()) {_						_						notNext.addIgnore(lastSink, new NotCondition<>(notCondition))__					} else {_						notNext.addProceed(lastSink, new NotCondition<>(notCondition))__					}_					notNext.addProceed(stopState, notCondition)__					lastSink = notNext__				} else {_					lastSink = convertPattern(lastSink)__				}__				_				followingPattern = currentPattern__				currentPattern = currentPattern.getPrevious()___				final Time currentWindowTime = currentPattern.getWindowTime()__				if (currentWindowTime != null && currentWindowTime.toMilliseconds() < windowTime) {_					_					windowTime = currentWindowTime.toMilliseconds()__				}_			}_			return lastSink__		};creates,all,the,states,between,start,and,final,state,param,sink,state,the,state,that,last,state,should,point,to,always,the,final,state,return,the,next,state,after,start,in,the,resulting,graph;private,state,t,create,middle,states,final,state,t,sink,state,state,t,last,sink,sink,state,while,current,pattern,get,previous,null,if,current,pattern,get,quantifier,get,consuming,strategy,quantifier,consuming,strategy,else,if,current,pattern,get,quantifier,get,consuming,strategy,quantifier,consuming,strategy,final,state,t,not,next,create,state,current,pattern,get,name,state,state,type,normal,final,iterative,condition,t,not,condition,get,take,condition,current,pattern,final,state,t,stop,state,create,stop,state,not,condition,current,pattern,get,name,if,last,sink,is,final,not,next,add,ignore,last,sink,new,not,condition,not,condition,else,not,next,add,proceed,last,sink,new,not,condition,not,condition,not,next,add,proceed,stop,state,not,condition,last,sink,not,next,else,last,sink,convert,pattern,last,sink,following,pattern,current,pattern,current,pattern,current,pattern,get,previous,final,time,current,window,time,current,pattern,get,window,time,if,current,window,time,null,current,window,time,to,milliseconds,window,time,window,time,current,window,time,to,milliseconds,return,last,sink
NFACompiler -> NFAFactoryCompiler -> private State<T> createMiddleStates(final State<T> sinkState);1528989005;Creates all the states between Start and Final state.__@param sinkState the state that last state should point to (always the Final state)_@return the next state after Start in the resulting graph;private State<T> createMiddleStates(final State<T> sinkState) {_			State<T> lastSink = sinkState__			while (currentPattern.getPrevious() != null) {__				if (currentPattern.getQuantifier().getConsumingStrategy() == Quantifier.ConsumingStrategy.NOT_FOLLOW) {_					_				} else if (currentPattern.getQuantifier().getConsumingStrategy() == Quantifier.ConsumingStrategy.NOT_NEXT) {_					final State<T> notNext = createState(currentPattern.getName(), State.StateType.Normal)__					final IterativeCondition<T> notCondition = getTakeCondition(currentPattern)__					final State<T> stopState = createStopState(notCondition, currentPattern.getName())___					if (lastSink.isFinal()) {_						_						notNext.addIgnore(lastSink, new NotCondition<>(notCondition))__					} else {_						notNext.addProceed(lastSink, new NotCondition<>(notCondition))__					}_					notNext.addProceed(stopState, notCondition)__					lastSink = notNext__				} else {_					lastSink = convertPattern(lastSink)__				}__				_				followingPattern = currentPattern__				currentPattern = currentPattern.getPrevious()___				final Time currentWindowTime = currentPattern.getWindowTime()__				if (currentWindowTime != null && currentWindowTime.toMilliseconds() < windowTime) {_					_					windowTime = currentWindowTime.toMilliseconds()__				}_			}_			return lastSink__		};creates,all,the,states,between,start,and,final,state,param,sink,state,the,state,that,last,state,should,point,to,always,the,final,state,return,the,next,state,after,start,in,the,resulting,graph;private,state,t,create,middle,states,final,state,t,sink,state,state,t,last,sink,sink,state,while,current,pattern,get,previous,null,if,current,pattern,get,quantifier,get,consuming,strategy,quantifier,consuming,strategy,else,if,current,pattern,get,quantifier,get,consuming,strategy,quantifier,consuming,strategy,final,state,t,not,next,create,state,current,pattern,get,name,state,state,type,normal,final,iterative,condition,t,not,condition,get,take,condition,current,pattern,final,state,t,stop,state,create,stop,state,not,condition,current,pattern,get,name,if,last,sink,is,final,not,next,add,ignore,last,sink,new,not,condition,not,condition,else,not,next,add,proceed,last,sink,new,not,condition,not,condition,not,next,add,proceed,stop,state,not,condition,last,sink,not,next,else,last,sink,convert,pattern,last,sink,following,pattern,current,pattern,current,pattern,current,pattern,get,previous,final,time,current,window,time,current,pattern,get,window,time,if,current,window,time,null,current,window,time,to,milliseconds,window,time,window,time,current,window,time,to,milliseconds,return,last,sink
NFACompiler -> NFAFactoryCompiler -> private State<T> createMiddleStates(final State<T> sinkState);1538745898;Creates all the states between Start and Final state.__@param sinkState the state that last state should point to (always the Final state)_@return the next state after Start in the resulting graph;private State<T> createMiddleStates(final State<T> sinkState) {_			State<T> lastSink = sinkState__			while (currentPattern.getPrevious() != null) {__				if (currentPattern.getQuantifier().getConsumingStrategy() == Quantifier.ConsumingStrategy.NOT_FOLLOW) {_					_				} else if (currentPattern.getQuantifier().getConsumingStrategy() == Quantifier.ConsumingStrategy.NOT_NEXT) {_					final State<T> notNext = createState(currentPattern.getName(), State.StateType.Normal)__					final IterativeCondition<T> notCondition = getTakeCondition(currentPattern)__					final State<T> stopState = createStopState(notCondition, currentPattern.getName())___					if (lastSink.isFinal()) {_						_						notNext.addIgnore(lastSink, new NotCondition<>(notCondition))__					} else {_						notNext.addProceed(lastSink, new NotCondition<>(notCondition))__					}_					notNext.addProceed(stopState, notCondition)__					lastSink = notNext__				} else {_					lastSink = convertPattern(lastSink)__				}__				_				followingPattern = currentPattern__				currentPattern = currentPattern.getPrevious()___				final Time currentWindowTime = currentPattern.getWindowTime()__				if (currentWindowTime != null && currentWindowTime.toMilliseconds() < windowTime) {_					_					windowTime = currentWindowTime.toMilliseconds()__				}_			}_			return lastSink__		};creates,all,the,states,between,start,and,final,state,param,sink,state,the,state,that,last,state,should,point,to,always,the,final,state,return,the,next,state,after,start,in,the,resulting,graph;private,state,t,create,middle,states,final,state,t,sink,state,state,t,last,sink,sink,state,while,current,pattern,get,previous,null,if,current,pattern,get,quantifier,get,consuming,strategy,quantifier,consuming,strategy,else,if,current,pattern,get,quantifier,get,consuming,strategy,quantifier,consuming,strategy,final,state,t,not,next,create,state,current,pattern,get,name,state,state,type,normal,final,iterative,condition,t,not,condition,get,take,condition,current,pattern,final,state,t,stop,state,create,stop,state,not,condition,current,pattern,get,name,if,last,sink,is,final,not,next,add,ignore,last,sink,new,not,condition,not,condition,else,not,next,add,proceed,last,sink,new,not,condition,not,condition,not,next,add,proceed,stop,state,not,condition,last,sink,not,next,else,last,sink,convert,pattern,last,sink,following,pattern,current,pattern,current,pattern,current,pattern,get,previous,final,time,current,window,time,current,pattern,get,window,time,if,current,window,time,null,current,window,time,to,milliseconds,window,time,window,time,current,window,time,to,milliseconds,return,last,sink
NFACompiler -> NFAFactoryCompiler -> private State<T> createMiddleStates(final State<T> sinkState);1542293931;Creates all the states between Start and Final state.__@param sinkState the state that last state should point to (always the Final state)_@return the next state after Start in the resulting graph;private State<T> createMiddleStates(final State<T> sinkState) {_			State<T> lastSink = sinkState__			while (currentPattern.getPrevious() != null) {__				if (currentPattern.getQuantifier().getConsumingStrategy() == Quantifier.ConsumingStrategy.NOT_FOLLOW) {_					_				} else if (currentPattern.getQuantifier().getConsumingStrategy() == Quantifier.ConsumingStrategy.NOT_NEXT) {_					final State<T> notNext = createState(currentPattern.getName(), State.StateType.Normal)__					final IterativeCondition<T> notCondition = getTakeCondition(currentPattern)__					final State<T> stopState = createStopState(notCondition, currentPattern.getName())___					if (lastSink.isFinal()) {_						_						notNext.addIgnore(lastSink, new RichNotCondition<>(notCondition))__					} else {_						notNext.addProceed(lastSink, new RichNotCondition<>(notCondition))__					}_					notNext.addProceed(stopState, notCondition)__					lastSink = notNext__				} else {_					lastSink = convertPattern(lastSink)__				}__				_				followingPattern = currentPattern__				currentPattern = currentPattern.getPrevious()___				final Time currentWindowTime = currentPattern.getWindowTime()__				if (currentWindowTime != null && currentWindowTime.toMilliseconds() < windowTime) {_					_					windowTime = currentWindowTime.toMilliseconds()__				}_			}_			return lastSink__		};creates,all,the,states,between,start,and,final,state,param,sink,state,the,state,that,last,state,should,point,to,always,the,final,state,return,the,next,state,after,start,in,the,resulting,graph;private,state,t,create,middle,states,final,state,t,sink,state,state,t,last,sink,sink,state,while,current,pattern,get,previous,null,if,current,pattern,get,quantifier,get,consuming,strategy,quantifier,consuming,strategy,else,if,current,pattern,get,quantifier,get,consuming,strategy,quantifier,consuming,strategy,final,state,t,not,next,create,state,current,pattern,get,name,state,state,type,normal,final,iterative,condition,t,not,condition,get,take,condition,current,pattern,final,state,t,stop,state,create,stop,state,not,condition,current,pattern,get,name,if,last,sink,is,final,not,next,add,ignore,last,sink,new,rich,not,condition,not,condition,else,not,next,add,proceed,last,sink,new,rich,not,condition,not,condition,not,next,add,proceed,stop,state,not,condition,last,sink,not,next,else,last,sink,convert,pattern,last,sink,following,pattern,current,pattern,current,pattern,current,pattern,get,previous,final,time,current,window,time,current,pattern,get,window,time,if,current,window,time,null,current,window,time,to,milliseconds,window,time,window,time,current,window,time,to,milliseconds,return,last,sink
NFACompiler -> @SuppressWarnings("unchecked") 	public static <T> NFAFactory<T> compileFactory( 		final Pattern<T, ?> pattern, 		boolean timeoutHandling);1527863170;Compiles the given pattern into a {@link NFAFactory}. The NFA factory can be used to create_multiple NFAs.__@param pattern Definition of sequence pattern_@param timeoutHandling True if the NFA shall return timed out event patterns_@param <T> Type of the input events_@return Factory for NFAs corresponding to the given pattern;@SuppressWarnings("unchecked")_	public static <T> NFAFactory<T> compileFactory(_		final Pattern<T, ?> pattern,_		boolean timeoutHandling) {_		if (pattern == null) {_			_			return new NFAFactoryImpl<>(0, Collections.<State<T>>emptyList(), timeoutHandling)__		} else {_			final NFAFactoryCompiler<T> nfaFactoryCompiler = new NFAFactoryCompiler<>(pattern)__			nfaFactoryCompiler.compileFactory()__			return new NFAFactoryImpl<>(nfaFactoryCompiler.getWindowTime(), nfaFactoryCompiler.getStates(), timeoutHandling)__		}_	};compiles,the,given,pattern,into,a,link,nfafactory,the,nfa,factory,can,be,used,to,create,multiple,nfas,param,pattern,definition,of,sequence,pattern,param,timeout,handling,true,if,the,nfa,shall,return,timed,out,event,patterns,param,t,type,of,the,input,events,return,factory,for,nfas,corresponding,to,the,given,pattern;suppress,warnings,unchecked,public,static,t,nfafactory,t,compile,factory,final,pattern,t,pattern,boolean,timeout,handling,if,pattern,null,return,new,nfafactory,impl,0,collections,state,t,empty,list,timeout,handling,else,final,nfafactory,compiler,t,nfa,factory,compiler,new,nfafactory,compiler,pattern,nfa,factory,compiler,compile,factory,return,new,nfafactory,impl,nfa,factory,compiler,get,window,time,nfa,factory,compiler,get,states,timeout,handling
NFACompiler -> @SuppressWarnings("unchecked") 	public static <T> NFAFactory<T> compileFactory( 		final Pattern<T, ?> pattern, 		boolean timeoutHandling);1528989005;Compiles the given pattern into a {@link NFAFactory}. The NFA factory can be used to create_multiple NFAs.__@param pattern Definition of sequence pattern_@param timeoutHandling True if the NFA shall return timed out event patterns_@param <T> Type of the input events_@return Factory for NFAs corresponding to the given pattern;@SuppressWarnings("unchecked")_	public static <T> NFAFactory<T> compileFactory(_		final Pattern<T, ?> pattern,_		boolean timeoutHandling) {_		if (pattern == null) {_			_			return new NFAFactoryImpl<>(0, Collections.<State<T>>emptyList(), timeoutHandling)__		} else {_			final NFAFactoryCompiler<T> nfaFactoryCompiler = new NFAFactoryCompiler<>(pattern)__			nfaFactoryCompiler.compileFactory()__			return new NFAFactoryImpl<>(nfaFactoryCompiler.getWindowTime(), nfaFactoryCompiler.getStates(), timeoutHandling)__		}_	};compiles,the,given,pattern,into,a,link,nfafactory,the,nfa,factory,can,be,used,to,create,multiple,nfas,param,pattern,definition,of,sequence,pattern,param,timeout,handling,true,if,the,nfa,shall,return,timed,out,event,patterns,param,t,type,of,the,input,events,return,factory,for,nfas,corresponding,to,the,given,pattern;suppress,warnings,unchecked,public,static,t,nfafactory,t,compile,factory,final,pattern,t,pattern,boolean,timeout,handling,if,pattern,null,return,new,nfafactory,impl,0,collections,state,t,empty,list,timeout,handling,else,final,nfafactory,compiler,t,nfa,factory,compiler,new,nfafactory,compiler,pattern,nfa,factory,compiler,compile,factory,return,new,nfafactory,impl,nfa,factory,compiler,get,window,time,nfa,factory,compiler,get,states,timeout,handling
NFACompiler -> @SuppressWarnings("unchecked") 	public static <T> NFAFactory<T> compileFactory( 		final Pattern<T, ?> pattern, 		boolean timeoutHandling);1538745898;Compiles the given pattern into a {@link NFAFactory}. The NFA factory can be used to create_multiple NFAs.__@param pattern Definition of sequence pattern_@param timeoutHandling True if the NFA shall return timed out event patterns_@param <T> Type of the input events_@return Factory for NFAs corresponding to the given pattern;@SuppressWarnings("unchecked")_	public static <T> NFAFactory<T> compileFactory(_		final Pattern<T, ?> pattern,_		boolean timeoutHandling) {_		if (pattern == null) {_			_			return new NFAFactoryImpl<>(0, Collections.<State<T>>emptyList(), timeoutHandling)__		} else {_			final NFAFactoryCompiler<T> nfaFactoryCompiler = new NFAFactoryCompiler<>(pattern)__			nfaFactoryCompiler.compileFactory()__			return new NFAFactoryImpl<>(nfaFactoryCompiler.getWindowTime(), nfaFactoryCompiler.getStates(), timeoutHandling)__		}_	};compiles,the,given,pattern,into,a,link,nfafactory,the,nfa,factory,can,be,used,to,create,multiple,nfas,param,pattern,definition,of,sequence,pattern,param,timeout,handling,true,if,the,nfa,shall,return,timed,out,event,patterns,param,t,type,of,the,input,events,return,factory,for,nfas,corresponding,to,the,given,pattern;suppress,warnings,unchecked,public,static,t,nfafactory,t,compile,factory,final,pattern,t,pattern,boolean,timeout,handling,if,pattern,null,return,new,nfafactory,impl,0,collections,state,t,empty,list,timeout,handling,else,final,nfafactory,compiler,t,nfa,factory,compiler,new,nfafactory,compiler,pattern,nfa,factory,compiler,compile,factory,return,new,nfafactory,impl,nfa,factory,compiler,get,window,time,nfa,factory,compiler,get,states,timeout,handling
NFACompiler -> @SuppressWarnings("unchecked") 	public static <T> NFAFactory<T> compileFactory( 		final Pattern<T, ?> pattern, 		boolean timeoutHandling);1542293931;Compiles the given pattern into a {@link NFAFactory}. The NFA factory can be used to create_multiple NFAs.__@param pattern Definition of sequence pattern_@param timeoutHandling True if the NFA shall return timed out event patterns_@param <T> Type of the input events_@return Factory for NFAs corresponding to the given pattern;@SuppressWarnings("unchecked")_	public static <T> NFAFactory<T> compileFactory(_		final Pattern<T, ?> pattern,_		boolean timeoutHandling) {_		if (pattern == null) {_			_			return new NFAFactoryImpl<>(0, Collections.<State<T>>emptyList(), timeoutHandling)__		} else {_			final NFAFactoryCompiler<T> nfaFactoryCompiler = new NFAFactoryCompiler<>(pattern)__			nfaFactoryCompiler.compileFactory()__			return new NFAFactoryImpl<>(nfaFactoryCompiler.getWindowTime(), nfaFactoryCompiler.getStates(), timeoutHandling)__		}_	};compiles,the,given,pattern,into,a,link,nfafactory,the,nfa,factory,can,be,used,to,create,multiple,nfas,param,pattern,definition,of,sequence,pattern,param,timeout,handling,true,if,the,nfa,shall,return,timed,out,event,patterns,param,t,type,of,the,input,events,return,factory,for,nfas,corresponding,to,the,given,pattern;suppress,warnings,unchecked,public,static,t,nfafactory,t,compile,factory,final,pattern,t,pattern,boolean,timeout,handling,if,pattern,null,return,new,nfafactory,impl,0,collections,state,t,empty,list,timeout,handling,else,final,nfafactory,compiler,t,nfa,factory,compiler,new,nfafactory,compiler,pattern,nfa,factory,compiler,compile,factory,return,new,nfafactory,impl,nfa,factory,compiler,get,window,time,nfa,factory,compiler,get,states,timeout,handling
NFACompiler -> NFAFactoryCompiler -> @SuppressWarnings("unchecked") 		private State<T> createSingletonState(final State<T> sinkState, 			final State<T> proceedState, 			final IterativeCondition<T> takeCondition, 			final IterativeCondition<T> ignoreCondition, 			final boolean isOptional);1498034481;Creates a simple single state. For an OPTIONAL state it also consists_of a similar state without the PROCEED edge, so that for each PROCEED transition branches_in computation state graph  can be created only once.__@param ignoreCondition condition that should be applied to IGNORE transition_@param sinkState state that the state being converted should point to_@param proceedState state that the state being converted should proceed to_@param isOptional whether the state being converted is optional_@return the created state;@SuppressWarnings("unchecked")_		private State<T> createSingletonState(final State<T> sinkState,_			final State<T> proceedState,_			final IterativeCondition<T> takeCondition,_			final IterativeCondition<T> ignoreCondition,_			final boolean isOptional) {_			if (currentPattern instanceof GroupPattern) {_				return createGroupPatternState((GroupPattern) currentPattern, sinkState, proceedState, isOptional)__			}__			final IterativeCondition<T> trueFunction = getTrueFunction()___			final State<T> singletonState = createState(currentPattern.getName(), State.StateType.Normal)__			_			final State<T> sink = copyWithoutTransitiveNots(sinkState)__			singletonState.addTake(sink, takeCondition)___			_			_			if (isOptional && !headOfGroup(currentPattern)) {_				_				singletonState.addProceed(proceedState, trueFunction)__			}__			if (ignoreCondition != null) {_				final State<T> ignoreState__				if (isOptional) {_					ignoreState = createState(currentPattern.getName(), State.StateType.Normal)__					ignoreState.addTake(sink, takeCondition)__					ignoreState.addIgnore(ignoreCondition)__					addStopStates(ignoreState)__				} else {_					ignoreState = singletonState__				}_				singletonState.addIgnore(ignoreState, ignoreCondition)__			}_			return singletonState__		};creates,a,simple,single,state,for,an,optional,state,it,also,consists,of,a,similar,state,without,the,proceed,edge,so,that,for,each,proceed,transition,branches,in,computation,state,graph,can,be,created,only,once,param,ignore,condition,condition,that,should,be,applied,to,ignore,transition,param,sink,state,state,that,the,state,being,converted,should,point,to,param,proceed,state,state,that,the,state,being,converted,should,proceed,to,param,is,optional,whether,the,state,being,converted,is,optional,return,the,created,state;suppress,warnings,unchecked,private,state,t,create,singleton,state,final,state,t,sink,state,final,state,t,proceed,state,final,iterative,condition,t,take,condition,final,iterative,condition,t,ignore,condition,final,boolean,is,optional,if,current,pattern,instanceof,group,pattern,return,create,group,pattern,state,group,pattern,current,pattern,sink,state,proceed,state,is,optional,final,iterative,condition,t,true,function,get,true,function,final,state,t,singleton,state,create,state,current,pattern,get,name,state,state,type,normal,final,state,t,sink,copy,without,transitive,nots,sink,state,singleton,state,add,take,sink,take,condition,if,is,optional,head,of,group,current,pattern,singleton,state,add,proceed,proceed,state,true,function,if,ignore,condition,null,final,state,t,ignore,state,if,is,optional,ignore,state,create,state,current,pattern,get,name,state,state,type,normal,ignore,state,add,take,sink,take,condition,ignore,state,add,ignore,ignore,condition,add,stop,states,ignore,state,else,ignore,state,singleton,state,singleton,state,add,ignore,ignore,state,ignore,condition,return,singleton,state
NFACompiler -> NFAFactoryCompiler -> @SuppressWarnings("unchecked") 		private State<T> createSingletonState(final State<T> sinkState, 			final State<T> proceedState, 			final IterativeCondition<T> takeCondition, 			final IterativeCondition<T> ignoreCondition, 			final boolean isOptional);1499760222;Creates a simple single state. For an OPTIONAL state it also consists_of a similar state without the PROCEED edge, so that for each PROCEED transition branches_in computation state graph  can be created only once.__@param ignoreCondition condition that should be applied to IGNORE transition_@param sinkState state that the state being converted should point to_@param proceedState state that the state being converted should proceed to_@param isOptional whether the state being converted is optional_@return the created state;@SuppressWarnings("unchecked")_		private State<T> createSingletonState(final State<T> sinkState,_			final State<T> proceedState,_			final IterativeCondition<T> takeCondition,_			final IterativeCondition<T> ignoreCondition,_			final boolean isOptional) {_			if (currentPattern instanceof GroupPattern) {_				return createGroupPatternState((GroupPattern) currentPattern, sinkState, proceedState, isOptional)__			}__			final State<T> singletonState = createState(currentPattern.getName(), State.StateType.Normal)__			_			final State<T> sink = copyWithoutTransitiveNots(sinkState)__			singletonState.addTake(sink, takeCondition)___			_			final IterativeCondition<T> proceedCondition = getTrueFunction()___			_			_			if (isOptional && !headOfGroup(currentPattern)) {_				if (currentPattern.getQuantifier().hasProperty(Quantifier.QuantifierProperty.GREEDY)) {_					final IterativeCondition<T> untilCondition =_						(IterativeCondition<T>) currentPattern.getUntilCondition()__					if (untilCondition != null) {_						singletonState.addProceed(_							originalStateMap.get(proceedState.getName()),_							new AndCondition<>(proceedCondition, untilCondition))__					}_					singletonState.addProceed(proceedState,_						untilCondition != null_							? new AndCondition<>(proceedCondition, new NotCondition<>(untilCondition))_							: proceedCondition)__				} else {_					singletonState.addProceed(proceedState, proceedCondition)__				}_			}__			if (ignoreCondition != null) {_				final State<T> ignoreState__				if (isOptional) {_					ignoreState = createState(currentPattern.getName(), State.StateType.Normal)__					ignoreState.addTake(sink, takeCondition)__					ignoreState.addIgnore(ignoreCondition)__					addStopStates(ignoreState)__				} else {_					ignoreState = singletonState__				}_				singletonState.addIgnore(ignoreState, ignoreCondition)__			}_			return singletonState__		};creates,a,simple,single,state,for,an,optional,state,it,also,consists,of,a,similar,state,without,the,proceed,edge,so,that,for,each,proceed,transition,branches,in,computation,state,graph,can,be,created,only,once,param,ignore,condition,condition,that,should,be,applied,to,ignore,transition,param,sink,state,state,that,the,state,being,converted,should,point,to,param,proceed,state,state,that,the,state,being,converted,should,proceed,to,param,is,optional,whether,the,state,being,converted,is,optional,return,the,created,state;suppress,warnings,unchecked,private,state,t,create,singleton,state,final,state,t,sink,state,final,state,t,proceed,state,final,iterative,condition,t,take,condition,final,iterative,condition,t,ignore,condition,final,boolean,is,optional,if,current,pattern,instanceof,group,pattern,return,create,group,pattern,state,group,pattern,current,pattern,sink,state,proceed,state,is,optional,final,state,t,singleton,state,create,state,current,pattern,get,name,state,state,type,normal,final,state,t,sink,copy,without,transitive,nots,sink,state,singleton,state,add,take,sink,take,condition,final,iterative,condition,t,proceed,condition,get,true,function,if,is,optional,head,of,group,current,pattern,if,current,pattern,get,quantifier,has,property,quantifier,quantifier,property,greedy,final,iterative,condition,t,until,condition,iterative,condition,t,current,pattern,get,until,condition,if,until,condition,null,singleton,state,add,proceed,original,state,map,get,proceed,state,get,name,new,and,condition,proceed,condition,until,condition,singleton,state,add,proceed,proceed,state,until,condition,null,new,and,condition,proceed,condition,new,not,condition,until,condition,proceed,condition,else,singleton,state,add,proceed,proceed,state,proceed,condition,if,ignore,condition,null,final,state,t,ignore,state,if,is,optional,ignore,state,create,state,current,pattern,get,name,state,state,type,normal,ignore,state,add,take,sink,take,condition,ignore,state,add,ignore,ignore,condition,add,stop,states,ignore,state,else,ignore,state,singleton,state,singleton,state,add,ignore,ignore,state,ignore,condition,return,singleton,state
NFACompiler -> NFAFactoryCompiler -> @SuppressWarnings("unchecked") 		private State<T> createSingletonState(final State<T> sinkState, 			final State<T> proceedState, 			final IterativeCondition<T> takeCondition, 			final IterativeCondition<T> ignoreCondition, 			final boolean isOptional);1499937690;Creates a simple single state. For an OPTIONAL state it also consists_of a similar state without the PROCEED edge, so that for each PROCEED transition branches_in computation state graph  can be created only once.__@param ignoreCondition condition that should be applied to IGNORE transition_@param sinkState state that the state being converted should point to_@param proceedState state that the state being converted should proceed to_@param isOptional whether the state being converted is optional_@return the created state;@SuppressWarnings("unchecked")_		private State<T> createSingletonState(final State<T> sinkState,_			final State<T> proceedState,_			final IterativeCondition<T> takeCondition,_			final IterativeCondition<T> ignoreCondition,_			final boolean isOptional) {_			if (currentPattern instanceof GroupPattern) {_				return createGroupPatternState((GroupPattern) currentPattern, sinkState, proceedState, isOptional)__			}__			final IterativeCondition<T> trueFunction = getTrueFunction()___			final State<T> singletonState = createState(currentPattern.getName(), State.StateType.Normal)__			_			final State<T> sink = copyWithoutTransitiveNots(sinkState)__			singletonState.addTake(sink, takeCondition)___			_			_			if (isOptional && !headOfGroup(currentPattern)) {_				_				singletonState.addProceed(proceedState, trueFunction)__			}__			if (ignoreCondition != null) {_				final State<T> ignoreState__				if (isOptional) {_					ignoreState = createState(currentPattern.getName(), State.StateType.Normal)__					ignoreState.addTake(sink, takeCondition)__					ignoreState.addIgnore(ignoreCondition)__					addStopStates(ignoreState)__				} else {_					ignoreState = singletonState__				}_				singletonState.addIgnore(ignoreState, ignoreCondition)__			}_			return singletonState__		};creates,a,simple,single,state,for,an,optional,state,it,also,consists,of,a,similar,state,without,the,proceed,edge,so,that,for,each,proceed,transition,branches,in,computation,state,graph,can,be,created,only,once,param,ignore,condition,condition,that,should,be,applied,to,ignore,transition,param,sink,state,state,that,the,state,being,converted,should,point,to,param,proceed,state,state,that,the,state,being,converted,should,proceed,to,param,is,optional,whether,the,state,being,converted,is,optional,return,the,created,state;suppress,warnings,unchecked,private,state,t,create,singleton,state,final,state,t,sink,state,final,state,t,proceed,state,final,iterative,condition,t,take,condition,final,iterative,condition,t,ignore,condition,final,boolean,is,optional,if,current,pattern,instanceof,group,pattern,return,create,group,pattern,state,group,pattern,current,pattern,sink,state,proceed,state,is,optional,final,iterative,condition,t,true,function,get,true,function,final,state,t,singleton,state,create,state,current,pattern,get,name,state,state,type,normal,final,state,t,sink,copy,without,transitive,nots,sink,state,singleton,state,add,take,sink,take,condition,if,is,optional,head,of,group,current,pattern,singleton,state,add,proceed,proceed,state,true,function,if,ignore,condition,null,final,state,t,ignore,state,if,is,optional,ignore,state,create,state,current,pattern,get,name,state,state,type,normal,ignore,state,add,take,sink,take,condition,ignore,state,add,ignore,ignore,condition,add,stop,states,ignore,state,else,ignore,state,singleton,state,singleton,state,add,ignore,ignore,state,ignore,condition,return,singleton,state
NFACompiler -> NFAFactoryCompiler -> @SuppressWarnings("unchecked") 		private State<T> createSingletonState(final State<T> sinkState, 			final State<T> proceedState, 			final IterativeCondition<T> takeCondition, 			final IterativeCondition<T> ignoreCondition, 			final boolean isOptional);1500021711;Creates a simple single state. For an OPTIONAL state it also consists_of a similar state without the PROCEED edge, so that for each PROCEED transition branches_in computation state graph  can be created only once.__@param ignoreCondition condition that should be applied to IGNORE transition_@param sinkState state that the state being converted should point to_@param proceedState state that the state being converted should proceed to_@param isOptional whether the state being converted is optional_@return the created state;@SuppressWarnings("unchecked")_		private State<T> createSingletonState(final State<T> sinkState,_			final State<T> proceedState,_			final IterativeCondition<T> takeCondition,_			final IterativeCondition<T> ignoreCondition,_			final boolean isOptional) {_			if (currentPattern instanceof GroupPattern) {_				return createGroupPatternState((GroupPattern) currentPattern, sinkState, proceedState, isOptional)__			}__			final State<T> singletonState = createState(currentPattern.getName(), State.StateType.Normal)__			_			final State<T> sink = copyWithoutTransitiveNots(sinkState)__			singletonState.addTake(sink, takeCondition)___			_			final IterativeCondition<T> proceedCondition = getTrueFunction()___			_			_			if (isOptional && !headOfGroup(currentPattern)) {_				if (currentPattern.getQuantifier().hasProperty(Quantifier.QuantifierProperty.GREEDY)) {_					final IterativeCondition<T> untilCondition =_						(IterativeCondition<T>) currentPattern.getUntilCondition()__					if (untilCondition != null) {_						singletonState.addProceed(_							originalStateMap.get(proceedState.getName()),_							new AndCondition<>(proceedCondition, untilCondition))__					}_					singletonState.addProceed(proceedState,_						untilCondition != null_							? new AndCondition<>(proceedCondition, new NotCondition<>(untilCondition))_							: proceedCondition)__				} else {_					singletonState.addProceed(proceedState, proceedCondition)__				}_			}__			if (ignoreCondition != null) {_				final State<T> ignoreState__				if (isOptional) {_					ignoreState = createState(currentPattern.getName(), State.StateType.Normal)__					ignoreState.addTake(sink, takeCondition)__					ignoreState.addIgnore(ignoreCondition)__					addStopStates(ignoreState)__				} else {_					ignoreState = singletonState__				}_				singletonState.addIgnore(ignoreState, ignoreCondition)__			}_			return singletonState__		};creates,a,simple,single,state,for,an,optional,state,it,also,consists,of,a,similar,state,without,the,proceed,edge,so,that,for,each,proceed,transition,branches,in,computation,state,graph,can,be,created,only,once,param,ignore,condition,condition,that,should,be,applied,to,ignore,transition,param,sink,state,state,that,the,state,being,converted,should,point,to,param,proceed,state,state,that,the,state,being,converted,should,proceed,to,param,is,optional,whether,the,state,being,converted,is,optional,return,the,created,state;suppress,warnings,unchecked,private,state,t,create,singleton,state,final,state,t,sink,state,final,state,t,proceed,state,final,iterative,condition,t,take,condition,final,iterative,condition,t,ignore,condition,final,boolean,is,optional,if,current,pattern,instanceof,group,pattern,return,create,group,pattern,state,group,pattern,current,pattern,sink,state,proceed,state,is,optional,final,state,t,singleton,state,create,state,current,pattern,get,name,state,state,type,normal,final,state,t,sink,copy,without,transitive,nots,sink,state,singleton,state,add,take,sink,take,condition,final,iterative,condition,t,proceed,condition,get,true,function,if,is,optional,head,of,group,current,pattern,if,current,pattern,get,quantifier,has,property,quantifier,quantifier,property,greedy,final,iterative,condition,t,until,condition,iterative,condition,t,current,pattern,get,until,condition,if,until,condition,null,singleton,state,add,proceed,original,state,map,get,proceed,state,get,name,new,and,condition,proceed,condition,until,condition,singleton,state,add,proceed,proceed,state,until,condition,null,new,and,condition,proceed,condition,new,not,condition,until,condition,proceed,condition,else,singleton,state,add,proceed,proceed,state,proceed,condition,if,ignore,condition,null,final,state,t,ignore,state,if,is,optional,ignore,state,create,state,current,pattern,get,name,state,state,type,normal,ignore,state,add,take,sink,take,condition,ignore,state,add,ignore,ignore,condition,add,stop,states,ignore,state,else,ignore,state,singleton,state,singleton,state,add,ignore,ignore,state,ignore,condition,return,singleton,state
NFACompiler -> NFAFactoryCompiler -> @SuppressWarnings("unchecked") 		private State<T> createSingletonState(final State<T> sinkState, 			final State<T> proceedState, 			final IterativeCondition<T> takeCondition, 			final IterativeCondition<T> ignoreCondition, 			final boolean isOptional);1501592283;Creates a simple single state. For an OPTIONAL state it also consists_of a similar state without the PROCEED edge, so that for each PROCEED transition branches_in computation state graph  can be created only once.__@param ignoreCondition condition that should be applied to IGNORE transition_@param sinkState state that the state being converted should point to_@param proceedState state that the state being converted should proceed to_@param isOptional whether the state being converted is optional_@return the created state;@SuppressWarnings("unchecked")_		private State<T> createSingletonState(final State<T> sinkState,_			final State<T> proceedState,_			final IterativeCondition<T> takeCondition,_			final IterativeCondition<T> ignoreCondition,_			final boolean isOptional) {_			if (currentPattern instanceof GroupPattern) {_				return createGroupPatternState((GroupPattern) currentPattern, sinkState, proceedState, isOptional)__			}__			final IterativeCondition<T> trueFunction = getTrueFunction()___			final State<T> singletonState = createState(currentPattern.getName(), State.StateType.Normal)__			_			final State<T> sink = copyWithoutTransitiveNots(sinkState)__			singletonState.addTake(sink, takeCondition)___			_			_			if (isOptional && !headOfGroup(currentPattern)) {_				_				singletonState.addProceed(proceedState, trueFunction)__			}__			if (ignoreCondition != null) {_				final State<T> ignoreState__				if (isOptional) {_					ignoreState = createState(currentPattern.getName(), State.StateType.Normal)__					ignoreState.addTake(sink, takeCondition)__					ignoreState.addIgnore(ignoreCondition)__					addStopStates(ignoreState)__				} else {_					ignoreState = singletonState__				}_				singletonState.addIgnore(ignoreState, ignoreCondition)__			}_			return singletonState__		};creates,a,simple,single,state,for,an,optional,state,it,also,consists,of,a,similar,state,without,the,proceed,edge,so,that,for,each,proceed,transition,branches,in,computation,state,graph,can,be,created,only,once,param,ignore,condition,condition,that,should,be,applied,to,ignore,transition,param,sink,state,state,that,the,state,being,converted,should,point,to,param,proceed,state,state,that,the,state,being,converted,should,proceed,to,param,is,optional,whether,the,state,being,converted,is,optional,return,the,created,state;suppress,warnings,unchecked,private,state,t,create,singleton,state,final,state,t,sink,state,final,state,t,proceed,state,final,iterative,condition,t,take,condition,final,iterative,condition,t,ignore,condition,final,boolean,is,optional,if,current,pattern,instanceof,group,pattern,return,create,group,pattern,state,group,pattern,current,pattern,sink,state,proceed,state,is,optional,final,iterative,condition,t,true,function,get,true,function,final,state,t,singleton,state,create,state,current,pattern,get,name,state,state,type,normal,final,state,t,sink,copy,without,transitive,nots,sink,state,singleton,state,add,take,sink,take,condition,if,is,optional,head,of,group,current,pattern,singleton,state,add,proceed,proceed,state,true,function,if,ignore,condition,null,final,state,t,ignore,state,if,is,optional,ignore,state,create,state,current,pattern,get,name,state,state,type,normal,ignore,state,add,take,sink,take,condition,ignore,state,add,ignore,ignore,condition,add,stop,states,ignore,state,else,ignore,state,singleton,state,singleton,state,add,ignore,ignore,state,ignore,condition,return,singleton,state
NFACompiler -> NFAFactoryCompiler -> @SuppressWarnings("unchecked") 		private State<T> createSingletonState(final State<T> sinkState, 			final State<T> proceedState, 			final IterativeCondition<T> takeCondition, 			final IterativeCondition<T> ignoreCondition, 			final boolean isOptional);1502422141;Creates a simple single state. For an OPTIONAL state it also consists_of a similar state without the PROCEED edge, so that for each PROCEED transition branches_in computation state graph  can be created only once.__@param ignoreCondition condition that should be applied to IGNORE transition_@param sinkState state that the state being converted should point to_@param proceedState state that the state being converted should proceed to_@param isOptional whether the state being converted is optional_@return the created state;@SuppressWarnings("unchecked")_		private State<T> createSingletonState(final State<T> sinkState,_			final State<T> proceedState,_			final IterativeCondition<T> takeCondition,_			final IterativeCondition<T> ignoreCondition,_			final boolean isOptional) {_			if (currentPattern instanceof GroupPattern) {_				return createGroupPatternState((GroupPattern) currentPattern, sinkState, proceedState, isOptional)__			}__			final IterativeCondition<T> trueFunction = getTrueFunction()___			final State<T> singletonState = createState(currentPattern.getName(), State.StateType.Normal)__			_			final State<T> sink = copyWithoutTransitiveNots(sinkState)__			singletonState.addTake(sink, takeCondition)___			_			_			if (isOptional && !headOfGroup(currentPattern)) {_				_				singletonState.addProceed(proceedState, trueFunction)__			}__			if (ignoreCondition != null) {_				final State<T> ignoreState__				if (isOptional) {_					ignoreState = createState(currentPattern.getName(), State.StateType.Normal)__					ignoreState.addTake(sink, takeCondition)__					ignoreState.addIgnore(ignoreCondition)__					addStopStates(ignoreState)__				} else {_					ignoreState = singletonState__				}_				singletonState.addIgnore(ignoreState, ignoreCondition)__			}_			return singletonState__		};creates,a,simple,single,state,for,an,optional,state,it,also,consists,of,a,similar,state,without,the,proceed,edge,so,that,for,each,proceed,transition,branches,in,computation,state,graph,can,be,created,only,once,param,ignore,condition,condition,that,should,be,applied,to,ignore,transition,param,sink,state,state,that,the,state,being,converted,should,point,to,param,proceed,state,state,that,the,state,being,converted,should,proceed,to,param,is,optional,whether,the,state,being,converted,is,optional,return,the,created,state;suppress,warnings,unchecked,private,state,t,create,singleton,state,final,state,t,sink,state,final,state,t,proceed,state,final,iterative,condition,t,take,condition,final,iterative,condition,t,ignore,condition,final,boolean,is,optional,if,current,pattern,instanceof,group,pattern,return,create,group,pattern,state,group,pattern,current,pattern,sink,state,proceed,state,is,optional,final,iterative,condition,t,true,function,get,true,function,final,state,t,singleton,state,create,state,current,pattern,get,name,state,state,type,normal,final,state,t,sink,copy,without,transitive,nots,sink,state,singleton,state,add,take,sink,take,condition,if,is,optional,head,of,group,current,pattern,singleton,state,add,proceed,proceed,state,true,function,if,ignore,condition,null,final,state,t,ignore,state,if,is,optional,ignore,state,create,state,current,pattern,get,name,state,state,type,normal,ignore,state,add,take,sink,take,condition,ignore,state,add,ignore,ignore,condition,add,stop,states,ignore,state,else,ignore,state,singleton,state,singleton,state,add,ignore,ignore,state,ignore,condition,return,singleton,state
NFACompiler -> NFAFactoryCompiler -> @SuppressWarnings("unchecked") 		private State<T> createSingletonState(final State<T> sinkState, 			final State<T> proceedState, 			final IterativeCondition<T> takeCondition, 			final IterativeCondition<T> ignoreCondition, 			final boolean isOptional);1503588494;Creates a simple single state. For an OPTIONAL state it also consists_of a similar state without the PROCEED edge, so that for each PROCEED transition branches_in computation state graph  can be created only once.__@param ignoreCondition condition that should be applied to IGNORE transition_@param sinkState state that the state being converted should point to_@param proceedState state that the state being converted should proceed to_@param isOptional whether the state being converted is optional_@return the created state;@SuppressWarnings("unchecked")_		private State<T> createSingletonState(final State<T> sinkState,_			final State<T> proceedState,_			final IterativeCondition<T> takeCondition,_			final IterativeCondition<T> ignoreCondition,_			final boolean isOptional) {_			if (currentPattern instanceof GroupPattern) {_				return createGroupPatternState((GroupPattern) currentPattern, sinkState, proceedState, isOptional)__			}__			final State<T> singletonState = createState(currentPattern.getName(), State.StateType.Normal)__			_			final State<T> sink = copyWithoutTransitiveNots(sinkState)__			singletonState.addTake(sink, takeCondition)___			_			final IterativeCondition<T> proceedCondition = getTrueFunction()___			_			_			if (isOptional && !headOfGroup(currentPattern)) {_				if (currentPattern.getQuantifier().hasProperty(Quantifier.QuantifierProperty.GREEDY)) {_					final IterativeCondition<T> untilCondition =_						(IterativeCondition<T>) currentPattern.getUntilCondition()__					if (untilCondition != null) {_						singletonState.addProceed(_							originalStateMap.get(proceedState.getName()),_							new AndCondition<>(proceedCondition, untilCondition))__					}_					singletonState.addProceed(proceedState,_						untilCondition != null_							? new AndCondition<>(proceedCondition, new NotCondition<>(untilCondition))_							: proceedCondition)__				} else {_					singletonState.addProceed(proceedState, proceedCondition)__				}_			}__			if (ignoreCondition != null) {_				final State<T> ignoreState__				if (isOptional) {_					ignoreState = createState(currentPattern.getName(), State.StateType.Normal)__					ignoreState.addTake(sink, takeCondition)__					ignoreState.addIgnore(ignoreCondition)__					addStopStates(ignoreState)__				} else {_					ignoreState = singletonState__				}_				singletonState.addIgnore(ignoreState, ignoreCondition)__			}_			return singletonState__		};creates,a,simple,single,state,for,an,optional,state,it,also,consists,of,a,similar,state,without,the,proceed,edge,so,that,for,each,proceed,transition,branches,in,computation,state,graph,can,be,created,only,once,param,ignore,condition,condition,that,should,be,applied,to,ignore,transition,param,sink,state,state,that,the,state,being,converted,should,point,to,param,proceed,state,state,that,the,state,being,converted,should,proceed,to,param,is,optional,whether,the,state,being,converted,is,optional,return,the,created,state;suppress,warnings,unchecked,private,state,t,create,singleton,state,final,state,t,sink,state,final,state,t,proceed,state,final,iterative,condition,t,take,condition,final,iterative,condition,t,ignore,condition,final,boolean,is,optional,if,current,pattern,instanceof,group,pattern,return,create,group,pattern,state,group,pattern,current,pattern,sink,state,proceed,state,is,optional,final,state,t,singleton,state,create,state,current,pattern,get,name,state,state,type,normal,final,state,t,sink,copy,without,transitive,nots,sink,state,singleton,state,add,take,sink,take,condition,final,iterative,condition,t,proceed,condition,get,true,function,if,is,optional,head,of,group,current,pattern,if,current,pattern,get,quantifier,has,property,quantifier,quantifier,property,greedy,final,iterative,condition,t,until,condition,iterative,condition,t,current,pattern,get,until,condition,if,until,condition,null,singleton,state,add,proceed,original,state,map,get,proceed,state,get,name,new,and,condition,proceed,condition,until,condition,singleton,state,add,proceed,proceed,state,until,condition,null,new,and,condition,proceed,condition,new,not,condition,until,condition,proceed,condition,else,singleton,state,add,proceed,proceed,state,proceed,condition,if,ignore,condition,null,final,state,t,ignore,state,if,is,optional,ignore,state,create,state,current,pattern,get,name,state,state,type,normal,ignore,state,add,take,sink,take,condition,ignore,state,add,ignore,ignore,condition,add,stop,states,ignore,state,else,ignore,state,singleton,state,singleton,state,add,ignore,ignore,state,ignore,condition,return,singleton,state
NFACompiler -> NFAFactoryCompiler -> @SuppressWarnings("unchecked") 		private State<T> createSingletonState(final State<T> sinkState, 			final State<T> proceedState, 			final IterativeCondition<T> takeCondition, 			final IterativeCondition<T> ignoreCondition, 			final boolean isOptional);1518008111;Creates a simple single state. For an OPTIONAL state it also consists_of a similar state without the PROCEED edge, so that for each PROCEED transition branches_in computation state graph  can be created only once.__@param ignoreCondition condition that should be applied to IGNORE transition_@param sinkState state that the state being converted should point to_@param proceedState state that the state being converted should proceed to_@param isOptional whether the state being converted is optional_@return the created state;@SuppressWarnings("unchecked")_		private State<T> createSingletonState(final State<T> sinkState,_			final State<T> proceedState,_			final IterativeCondition<T> takeCondition,_			final IterativeCondition<T> ignoreCondition,_			final boolean isOptional) {_			if (currentPattern instanceof GroupPattern) {_				return createGroupPatternState((GroupPattern) currentPattern, sinkState, proceedState, isOptional)__			}__			final State<T> singletonState = createState(currentPattern.getName(), State.StateType.Normal)__			_			final State<T> sink = copyWithoutTransitiveNots(sinkState)__			singletonState.addTake(sink, takeCondition)___			_			final IterativeCondition<T> proceedCondition = getTrueFunction()___			_			_			if (isOptional && !headOfGroup(currentPattern)) {_				if (currentPattern.getQuantifier().hasProperty(Quantifier.QuantifierProperty.GREEDY)) {_					final IterativeCondition<T> untilCondition =_						(IterativeCondition<T>) currentPattern.getUntilCondition()__					if (untilCondition != null) {_						singletonState.addProceed(_							originalStateMap.get(proceedState.getName()),_							new AndCondition<>(proceedCondition, untilCondition))__					}_					singletonState.addProceed(proceedState,_						untilCondition != null_							? new AndCondition<>(proceedCondition, new NotCondition<>(untilCondition))_							: proceedCondition)__				} else {_					singletonState.addProceed(proceedState, proceedCondition)__				}_			}__			if (ignoreCondition != null) {_				final State<T> ignoreState__				if (isOptional) {_					ignoreState = createState(currentPattern.getName(), State.StateType.Normal)__					ignoreState.addTake(sink, takeCondition)__					ignoreState.addIgnore(ignoreCondition)__					addStopStates(ignoreState)__				} else {_					ignoreState = singletonState__				}_				singletonState.addIgnore(ignoreState, ignoreCondition)__			}_			return singletonState__		};creates,a,simple,single,state,for,an,optional,state,it,also,consists,of,a,similar,state,without,the,proceed,edge,so,that,for,each,proceed,transition,branches,in,computation,state,graph,can,be,created,only,once,param,ignore,condition,condition,that,should,be,applied,to,ignore,transition,param,sink,state,state,that,the,state,being,converted,should,point,to,param,proceed,state,state,that,the,state,being,converted,should,proceed,to,param,is,optional,whether,the,state,being,converted,is,optional,return,the,created,state;suppress,warnings,unchecked,private,state,t,create,singleton,state,final,state,t,sink,state,final,state,t,proceed,state,final,iterative,condition,t,take,condition,final,iterative,condition,t,ignore,condition,final,boolean,is,optional,if,current,pattern,instanceof,group,pattern,return,create,group,pattern,state,group,pattern,current,pattern,sink,state,proceed,state,is,optional,final,state,t,singleton,state,create,state,current,pattern,get,name,state,state,type,normal,final,state,t,sink,copy,without,transitive,nots,sink,state,singleton,state,add,take,sink,take,condition,final,iterative,condition,t,proceed,condition,get,true,function,if,is,optional,head,of,group,current,pattern,if,current,pattern,get,quantifier,has,property,quantifier,quantifier,property,greedy,final,iterative,condition,t,until,condition,iterative,condition,t,current,pattern,get,until,condition,if,until,condition,null,singleton,state,add,proceed,original,state,map,get,proceed,state,get,name,new,and,condition,proceed,condition,until,condition,singleton,state,add,proceed,proceed,state,until,condition,null,new,and,condition,proceed,condition,new,not,condition,until,condition,proceed,condition,else,singleton,state,add,proceed,proceed,state,proceed,condition,if,ignore,condition,null,final,state,t,ignore,state,if,is,optional,ignore,state,create,state,current,pattern,get,name,state,state,type,normal,ignore,state,add,take,sink,take,condition,ignore,state,add,ignore,ignore,condition,add,stop,states,ignore,state,else,ignore,state,singleton,state,singleton,state,add,ignore,ignore,state,ignore,condition,return,singleton,state
NFACompiler -> NFAFactoryCompiler -> @SuppressWarnings("unchecked") 		private State<T> createSingletonState(final State<T> sinkState, 			final State<T> proceedState, 			final IterativeCondition<T> takeCondition, 			final IterativeCondition<T> ignoreCondition, 			final boolean isOptional);1527863170;Creates a simple single state. For an OPTIONAL state it also consists_of a similar state without the PROCEED edge, so that for each PROCEED transition branches_in computation state graph  can be created only once.__@param ignoreCondition condition that should be applied to IGNORE transition_@param sinkState state that the state being converted should point to_@param proceedState state that the state being converted should proceed to_@param isOptional whether the state being converted is optional_@return the created state;@SuppressWarnings("unchecked")_		private State<T> createSingletonState(final State<T> sinkState,_			final State<T> proceedState,_			final IterativeCondition<T> takeCondition,_			final IterativeCondition<T> ignoreCondition,_			final boolean isOptional) {_			if (currentPattern instanceof GroupPattern) {_				return createGroupPatternState((GroupPattern) currentPattern, sinkState, proceedState, isOptional)__			}__			final State<T> singletonState = createState(currentPattern.getName(), State.StateType.Normal)__			_			final State<T> sink = copyWithoutTransitiveNots(sinkState)__			singletonState.addTake(sink, takeCondition)___			_			final IterativeCondition<T> proceedCondition = getTrueFunction()___			_			_			if (isOptional && !headOfGroup(currentPattern)) {_				if (currentPattern.getQuantifier().hasProperty(Quantifier.QuantifierProperty.GREEDY)) {_					final IterativeCondition<T> untilCondition =_						(IterativeCondition<T>) currentPattern.getUntilCondition()__					if (untilCondition != null) {_						singletonState.addProceed(_							originalStateMap.get(proceedState.getName()),_							new AndCondition<>(proceedCondition, untilCondition))__					}_					singletonState.addProceed(proceedState,_						untilCondition != null_							? new AndCondition<>(proceedCondition, new NotCondition<>(untilCondition))_							: proceedCondition)__				} else {_					singletonState.addProceed(proceedState, proceedCondition)__				}_			}__			if (ignoreCondition != null) {_				final State<T> ignoreState__				if (isOptional) {_					ignoreState = createState(currentPattern.getName(), State.StateType.Normal)__					ignoreState.addTake(sink, takeCondition)__					ignoreState.addIgnore(ignoreCondition)__					addStopStates(ignoreState)__				} else {_					ignoreState = singletonState__				}_				singletonState.addIgnore(ignoreState, ignoreCondition)__			}_			return singletonState__		};creates,a,simple,single,state,for,an,optional,state,it,also,consists,of,a,similar,state,without,the,proceed,edge,so,that,for,each,proceed,transition,branches,in,computation,state,graph,can,be,created,only,once,param,ignore,condition,condition,that,should,be,applied,to,ignore,transition,param,sink,state,state,that,the,state,being,converted,should,point,to,param,proceed,state,state,that,the,state,being,converted,should,proceed,to,param,is,optional,whether,the,state,being,converted,is,optional,return,the,created,state;suppress,warnings,unchecked,private,state,t,create,singleton,state,final,state,t,sink,state,final,state,t,proceed,state,final,iterative,condition,t,take,condition,final,iterative,condition,t,ignore,condition,final,boolean,is,optional,if,current,pattern,instanceof,group,pattern,return,create,group,pattern,state,group,pattern,current,pattern,sink,state,proceed,state,is,optional,final,state,t,singleton,state,create,state,current,pattern,get,name,state,state,type,normal,final,state,t,sink,copy,without,transitive,nots,sink,state,singleton,state,add,take,sink,take,condition,final,iterative,condition,t,proceed,condition,get,true,function,if,is,optional,head,of,group,current,pattern,if,current,pattern,get,quantifier,has,property,quantifier,quantifier,property,greedy,final,iterative,condition,t,until,condition,iterative,condition,t,current,pattern,get,until,condition,if,until,condition,null,singleton,state,add,proceed,original,state,map,get,proceed,state,get,name,new,and,condition,proceed,condition,until,condition,singleton,state,add,proceed,proceed,state,until,condition,null,new,and,condition,proceed,condition,new,not,condition,until,condition,proceed,condition,else,singleton,state,add,proceed,proceed,state,proceed,condition,if,ignore,condition,null,final,state,t,ignore,state,if,is,optional,ignore,state,create,state,current,pattern,get,name,state,state,type,normal,ignore,state,add,take,sink,take,condition,ignore,state,add,ignore,ignore,condition,add,stop,states,ignore,state,else,ignore,state,singleton,state,singleton,state,add,ignore,ignore,state,ignore,condition,return,singleton,state
NFACompiler -> NFAFactoryCompiler -> @SuppressWarnings("unchecked") 		private State<T> createSingletonState(final State<T> sinkState, 			final State<T> proceedState, 			final IterativeCondition<T> takeCondition, 			final IterativeCondition<T> ignoreCondition, 			final boolean isOptional);1528989005;Creates a simple single state. For an OPTIONAL state it also consists_of a similar state without the PROCEED edge, so that for each PROCEED transition branches_in computation state graph  can be created only once.__@param ignoreCondition condition that should be applied to IGNORE transition_@param sinkState state that the state being converted should point to_@param proceedState state that the state being converted should proceed to_@param isOptional whether the state being converted is optional_@return the created state;@SuppressWarnings("unchecked")_		private State<T> createSingletonState(final State<T> sinkState,_			final State<T> proceedState,_			final IterativeCondition<T> takeCondition,_			final IterativeCondition<T> ignoreCondition,_			final boolean isOptional) {_			if (currentPattern instanceof GroupPattern) {_				return createGroupPatternState((GroupPattern) currentPattern, sinkState, proceedState, isOptional)__			}__			final State<T> singletonState = createState(currentPattern.getName(), State.StateType.Normal)__			_			final State<T> sink = copyWithoutTransitiveNots(sinkState)__			singletonState.addTake(sink, takeCondition)___			_			final IterativeCondition<T> proceedCondition = getTrueFunction()___			_			_			if (isOptional && !headOfGroup(currentPattern)) {_				if (currentPattern.getQuantifier().hasProperty(Quantifier.QuantifierProperty.GREEDY)) {_					final IterativeCondition<T> untilCondition =_						(IterativeCondition<T>) currentPattern.getUntilCondition()__					if (untilCondition != null) {_						singletonState.addProceed(_							originalStateMap.get(proceedState.getName()),_							new AndCondition<>(proceedCondition, untilCondition))__					}_					singletonState.addProceed(proceedState,_						untilCondition != null_							? new AndCondition<>(proceedCondition, new NotCondition<>(untilCondition))_							: proceedCondition)__				} else {_					singletonState.addProceed(proceedState, proceedCondition)__				}_			}__			if (ignoreCondition != null) {_				final State<T> ignoreState__				if (isOptional) {_					ignoreState = createState(currentPattern.getName(), State.StateType.Normal)__					ignoreState.addTake(sink, takeCondition)__					ignoreState.addIgnore(ignoreCondition)__					addStopStates(ignoreState)__				} else {_					ignoreState = singletonState__				}_				singletonState.addIgnore(ignoreState, ignoreCondition)__			}_			return singletonState__		};creates,a,simple,single,state,for,an,optional,state,it,also,consists,of,a,similar,state,without,the,proceed,edge,so,that,for,each,proceed,transition,branches,in,computation,state,graph,can,be,created,only,once,param,ignore,condition,condition,that,should,be,applied,to,ignore,transition,param,sink,state,state,that,the,state,being,converted,should,point,to,param,proceed,state,state,that,the,state,being,converted,should,proceed,to,param,is,optional,whether,the,state,being,converted,is,optional,return,the,created,state;suppress,warnings,unchecked,private,state,t,create,singleton,state,final,state,t,sink,state,final,state,t,proceed,state,final,iterative,condition,t,take,condition,final,iterative,condition,t,ignore,condition,final,boolean,is,optional,if,current,pattern,instanceof,group,pattern,return,create,group,pattern,state,group,pattern,current,pattern,sink,state,proceed,state,is,optional,final,state,t,singleton,state,create,state,current,pattern,get,name,state,state,type,normal,final,state,t,sink,copy,without,transitive,nots,sink,state,singleton,state,add,take,sink,take,condition,final,iterative,condition,t,proceed,condition,get,true,function,if,is,optional,head,of,group,current,pattern,if,current,pattern,get,quantifier,has,property,quantifier,quantifier,property,greedy,final,iterative,condition,t,until,condition,iterative,condition,t,current,pattern,get,until,condition,if,until,condition,null,singleton,state,add,proceed,original,state,map,get,proceed,state,get,name,new,and,condition,proceed,condition,until,condition,singleton,state,add,proceed,proceed,state,until,condition,null,new,and,condition,proceed,condition,new,not,condition,until,condition,proceed,condition,else,singleton,state,add,proceed,proceed,state,proceed,condition,if,ignore,condition,null,final,state,t,ignore,state,if,is,optional,ignore,state,create,state,current,pattern,get,name,state,state,type,normal,ignore,state,add,take,sink,take,condition,ignore,state,add,ignore,ignore,condition,add,stop,states,ignore,state,else,ignore,state,singleton,state,singleton,state,add,ignore,ignore,state,ignore,condition,return,singleton,state
NFACompiler -> NFAFactoryCompiler -> @SuppressWarnings("unchecked") 		private State<T> createSingletonState(final State<T> sinkState, 			final State<T> proceedState, 			final IterativeCondition<T> takeCondition, 			final IterativeCondition<T> ignoreCondition, 			final boolean isOptional);1538745898;Creates a simple single state. For an OPTIONAL state it also consists_of a similar state without the PROCEED edge, so that for each PROCEED transition branches_in computation state graph  can be created only once.__@param ignoreCondition condition that should be applied to IGNORE transition_@param sinkState state that the state being converted should point to_@param proceedState state that the state being converted should proceed to_@param isOptional whether the state being converted is optional_@return the created state;@SuppressWarnings("unchecked")_		private State<T> createSingletonState(final State<T> sinkState,_			final State<T> proceedState,_			final IterativeCondition<T> takeCondition,_			final IterativeCondition<T> ignoreCondition,_			final boolean isOptional) {_			if (currentPattern instanceof GroupPattern) {_				return createGroupPatternState((GroupPattern) currentPattern, sinkState, proceedState, isOptional)__			}__			final State<T> singletonState = createState(currentPattern.getName(), State.StateType.Normal)__			_			final State<T> sink = copyWithoutTransitiveNots(sinkState)__			singletonState.addTake(sink, takeCondition)___			_			final IterativeCondition<T> proceedCondition = getTrueFunction()___			_			_			if (isOptional && !headOfGroup(currentPattern)) {_				if (currentPattern.getQuantifier().hasProperty(Quantifier.QuantifierProperty.GREEDY)) {_					final IterativeCondition<T> untilCondition =_						(IterativeCondition<T>) currentPattern.getUntilCondition()__					if (untilCondition != null) {_						singletonState.addProceed(_							originalStateMap.get(proceedState.getName()),_							new AndCondition<>(proceedCondition, untilCondition))__					}_					singletonState.addProceed(proceedState,_						untilCondition != null_							? new AndCondition<>(proceedCondition, new NotCondition<>(untilCondition))_							: proceedCondition)__				} else {_					singletonState.addProceed(proceedState, proceedCondition)__				}_			}__			if (ignoreCondition != null) {_				final State<T> ignoreState__				if (isOptional) {_					ignoreState = createState(currentPattern.getName(), State.StateType.Normal)__					ignoreState.addTake(sink, takeCondition)__					ignoreState.addIgnore(ignoreCondition)__					addStopStates(ignoreState)__				} else {_					ignoreState = singletonState__				}_				singletonState.addIgnore(ignoreState, ignoreCondition)__			}_			return singletonState__		};creates,a,simple,single,state,for,an,optional,state,it,also,consists,of,a,similar,state,without,the,proceed,edge,so,that,for,each,proceed,transition,branches,in,computation,state,graph,can,be,created,only,once,param,ignore,condition,condition,that,should,be,applied,to,ignore,transition,param,sink,state,state,that,the,state,being,converted,should,point,to,param,proceed,state,state,that,the,state,being,converted,should,proceed,to,param,is,optional,whether,the,state,being,converted,is,optional,return,the,created,state;suppress,warnings,unchecked,private,state,t,create,singleton,state,final,state,t,sink,state,final,state,t,proceed,state,final,iterative,condition,t,take,condition,final,iterative,condition,t,ignore,condition,final,boolean,is,optional,if,current,pattern,instanceof,group,pattern,return,create,group,pattern,state,group,pattern,current,pattern,sink,state,proceed,state,is,optional,final,state,t,singleton,state,create,state,current,pattern,get,name,state,state,type,normal,final,state,t,sink,copy,without,transitive,nots,sink,state,singleton,state,add,take,sink,take,condition,final,iterative,condition,t,proceed,condition,get,true,function,if,is,optional,head,of,group,current,pattern,if,current,pattern,get,quantifier,has,property,quantifier,quantifier,property,greedy,final,iterative,condition,t,until,condition,iterative,condition,t,current,pattern,get,until,condition,if,until,condition,null,singleton,state,add,proceed,original,state,map,get,proceed,state,get,name,new,and,condition,proceed,condition,until,condition,singleton,state,add,proceed,proceed,state,until,condition,null,new,and,condition,proceed,condition,new,not,condition,until,condition,proceed,condition,else,singleton,state,add,proceed,proceed,state,proceed,condition,if,ignore,condition,null,final,state,t,ignore,state,if,is,optional,ignore,state,create,state,current,pattern,get,name,state,state,type,normal,ignore,state,add,take,sink,take,condition,ignore,state,add,ignore,ignore,condition,add,stop,states,ignore,state,else,ignore,state,singleton,state,singleton,state,add,ignore,ignore,state,ignore,condition,return,singleton,state
NFACompiler -> NFAFactoryCompiler -> @SuppressWarnings("unchecked") 		private State<T> createSingletonState(final State<T> sinkState, 			final State<T> proceedState, 			final IterativeCondition<T> takeCondition, 			final IterativeCondition<T> ignoreCondition, 			final boolean isOptional);1542293931;Creates a simple single state. For an OPTIONAL state it also consists_of a similar state without the PROCEED edge, so that for each PROCEED transition branches_in computation state graph  can be created only once.__@param ignoreCondition condition that should be applied to IGNORE transition_@param sinkState state that the state being converted should point to_@param proceedState state that the state being converted should proceed to_@param isOptional whether the state being converted is optional_@return the created state;@SuppressWarnings("unchecked")_		private State<T> createSingletonState(final State<T> sinkState,_			final State<T> proceedState,_			final IterativeCondition<T> takeCondition,_			final IterativeCondition<T> ignoreCondition,_			final boolean isOptional) {_			if (currentPattern instanceof GroupPattern) {_				return createGroupPatternState((GroupPattern) currentPattern, sinkState, proceedState, isOptional)__			}__			final State<T> singletonState = createState(currentPattern.getName(), State.StateType.Normal)__			_			final State<T> sink = copyWithoutTransitiveNots(sinkState)__			singletonState.addTake(sink, takeCondition)___			_			final IterativeCondition<T> proceedCondition = getTrueFunction()___			_			_			if (isOptional && !headOfGroup(currentPattern)) {_				if (currentPattern.getQuantifier().hasProperty(Quantifier.QuantifierProperty.GREEDY)) {_					final IterativeCondition<T> untilCondition =_						(IterativeCondition<T>) currentPattern.getUntilCondition()__					if (untilCondition != null) {_						singletonState.addProceed(_							originalStateMap.get(proceedState.getName()),_							new RichAndCondition<>(proceedCondition, untilCondition))__					}_					singletonState.addProceed(proceedState,_						untilCondition != null_							? new RichAndCondition<>(proceedCondition, new RichNotCondition<>(untilCondition))_							: proceedCondition)__				} else {_					singletonState.addProceed(proceedState, proceedCondition)__				}_			}__			if (ignoreCondition != null) {_				final State<T> ignoreState__				if (isOptional) {_					ignoreState = createState(currentPattern.getName(), State.StateType.Normal)__					ignoreState.addTake(sink, takeCondition)__					ignoreState.addIgnore(ignoreCondition)__					addStopStates(ignoreState)__				} else {_					ignoreState = singletonState__				}_				singletonState.addIgnore(ignoreState, ignoreCondition)__			}_			return singletonState__		};creates,a,simple,single,state,for,an,optional,state,it,also,consists,of,a,similar,state,without,the,proceed,edge,so,that,for,each,proceed,transition,branches,in,computation,state,graph,can,be,created,only,once,param,ignore,condition,condition,that,should,be,applied,to,ignore,transition,param,sink,state,state,that,the,state,being,converted,should,point,to,param,proceed,state,state,that,the,state,being,converted,should,proceed,to,param,is,optional,whether,the,state,being,converted,is,optional,return,the,created,state;suppress,warnings,unchecked,private,state,t,create,singleton,state,final,state,t,sink,state,final,state,t,proceed,state,final,iterative,condition,t,take,condition,final,iterative,condition,t,ignore,condition,final,boolean,is,optional,if,current,pattern,instanceof,group,pattern,return,create,group,pattern,state,group,pattern,current,pattern,sink,state,proceed,state,is,optional,final,state,t,singleton,state,create,state,current,pattern,get,name,state,state,type,normal,final,state,t,sink,copy,without,transitive,nots,sink,state,singleton,state,add,take,sink,take,condition,final,iterative,condition,t,proceed,condition,get,true,function,if,is,optional,head,of,group,current,pattern,if,current,pattern,get,quantifier,has,property,quantifier,quantifier,property,greedy,final,iterative,condition,t,until,condition,iterative,condition,t,current,pattern,get,until,condition,if,until,condition,null,singleton,state,add,proceed,original,state,map,get,proceed,state,get,name,new,rich,and,condition,proceed,condition,until,condition,singleton,state,add,proceed,proceed,state,until,condition,null,new,rich,and,condition,proceed,condition,new,rich,not,condition,until,condition,proceed,condition,else,singleton,state,add,proceed,proceed,state,proceed,condition,if,ignore,condition,null,final,state,t,ignore,state,if,is,optional,ignore,state,create,state,current,pattern,get,name,state,state,type,normal,ignore,state,add,take,sink,take,condition,ignore,state,add,ignore,ignore,condition,add,stop,states,ignore,state,else,ignore,state,singleton,state,singleton,state,add,ignore,ignore,state,ignore,condition,return,singleton,state
NFACompiler -> NFAFactoryCompiler -> @SuppressWarnings("unchecked") 		private State<T> createSingletonState(final State<T> sinkState, boolean addIgnore);1490619911;Creates a simple single state. For an OPTIONAL state it also consists_of a similar state without the PROCEED edge, so that for each PROCEED transition branches_in computation state graph  can be created only once.__@param addIgnore if any IGNORE should be added_@param sinkState state that the state being converted should point to_@return the created state;@SuppressWarnings("unchecked")_		private State<T> createSingletonState(final State<T> sinkState, boolean addIgnore) {_			final IterativeCondition<T> currentFilterFunction = (IterativeCondition<T>) currentPattern.getCondition()__			final IterativeCondition<T> trueFunction = BooleanConditions.trueFunction()___			final State<T> singletonState = createNormalState()__			singletonState.addTake(sinkState, currentFilterFunction)___			if (currentPattern.getQuantifier() == Quantifier.OPTIONAL) {_				singletonState.addProceed(sinkState, trueFunction)__			}__			if (addIgnore) {_				final State<T> ignoreState__				if (currentPattern.getQuantifier() == Quantifier.OPTIONAL) {_					ignoreState = createNormalState()__					ignoreState.addTake(sinkState, currentFilterFunction)__				} else {_					ignoreState = singletonState__				}_				singletonState.addIgnore(ignoreState, trueFunction)__			}_			return singletonState__		};creates,a,simple,single,state,for,an,optional,state,it,also,consists,of,a,similar,state,without,the,proceed,edge,so,that,for,each,proceed,transition,branches,in,computation,state,graph,can,be,created,only,once,param,add,ignore,if,any,ignore,should,be,added,param,sink,state,state,that,the,state,being,converted,should,point,to,return,the,created,state;suppress,warnings,unchecked,private,state,t,create,singleton,state,final,state,t,sink,state,boolean,add,ignore,final,iterative,condition,t,current,filter,function,iterative,condition,t,current,pattern,get,condition,final,iterative,condition,t,true,function,boolean,conditions,true,function,final,state,t,singleton,state,create,normal,state,singleton,state,add,take,sink,state,current,filter,function,if,current,pattern,get,quantifier,quantifier,optional,singleton,state,add,proceed,sink,state,true,function,if,add,ignore,final,state,t,ignore,state,if,current,pattern,get,quantifier,quantifier,optional,ignore,state,create,normal,state,ignore,state,add,take,sink,state,current,filter,function,else,ignore,state,singleton,state,singleton,state,add,ignore,ignore,state,true,function,return,singleton,state
NFACompiler -> NFAFactoryCompiler -> @SuppressWarnings("unchecked") 		private State<T> createSingletonState(final State<T> sinkState, boolean addIgnore);1491323030;Creates a simple single state. For an OPTIONAL state it also consists_of a similar state without the PROCEED edge, so that for each PROCEED transition branches_in computation state graph  can be created only once.__@param addIgnore if any IGNORE should be added_@param sinkState state that the state being converted should point to_@return the created state;@SuppressWarnings("unchecked")_		private State<T> createSingletonState(final State<T> sinkState, boolean addIgnore) {_			final IterativeCondition<T> currentFilterFunction = (IterativeCondition<T>) currentPattern.getCondition()__			final IterativeCondition<T> trueFunction = BooleanConditions.trueFunction()___			final State<T> singletonState = createNormalState()__			singletonState.addTake(sinkState, currentFilterFunction)___			if (currentPattern.getQuantifier() == Quantifier.OPTIONAL) {_				singletonState.addProceed(sinkState, trueFunction)__			}__			if (addIgnore) {_				final State<T> ignoreState__				if (currentPattern.getQuantifier() == Quantifier.OPTIONAL) {_					ignoreState = createNormalState()__					ignoreState.addTake(sinkState, currentFilterFunction)__				} else {_					ignoreState = singletonState__				}_				singletonState.addIgnore(ignoreState, trueFunction)__			}_			return singletonState__		};creates,a,simple,single,state,for,an,optional,state,it,also,consists,of,a,similar,state,without,the,proceed,edge,so,that,for,each,proceed,transition,branches,in,computation,state,graph,can,be,created,only,once,param,add,ignore,if,any,ignore,should,be,added,param,sink,state,state,that,the,state,being,converted,should,point,to,return,the,created,state;suppress,warnings,unchecked,private,state,t,create,singleton,state,final,state,t,sink,state,boolean,add,ignore,final,iterative,condition,t,current,filter,function,iterative,condition,t,current,pattern,get,condition,final,iterative,condition,t,true,function,boolean,conditions,true,function,final,state,t,singleton,state,create,normal,state,singleton,state,add,take,sink,state,current,filter,function,if,current,pattern,get,quantifier,quantifier,optional,singleton,state,add,proceed,sink,state,true,function,if,add,ignore,final,state,t,ignore,state,if,current,pattern,get,quantifier,quantifier,optional,ignore,state,create,normal,state,ignore,state,add,take,sink,state,current,filter,function,else,ignore,state,singleton,state,singleton,state,add,ignore,ignore,state,true,function,return,singleton,state
NFACompiler -> NFAFactoryCompiler -> @SuppressWarnings("unchecked") 		private State<T> createSingletonState(final State<T> sinkState, boolean addIgnore);1491633862;Creates a simple single state. For an OPTIONAL state it also consists_of a similar state without the PROCEED edge, so that for each PROCEED transition branches_in computation state graph  can be created only once.__@param addIgnore if any IGNORE should be added_@param sinkState state that the state being converted should point to_@return the created state;@SuppressWarnings("unchecked")_		private State<T> createSingletonState(final State<T> sinkState, boolean addIgnore) {_			final IterativeCondition<T> currentFilterFunction = (IterativeCondition<T>) currentPattern.getCondition()__			final IterativeCondition<T> trueFunction = BooleanConditions.trueFunction()___			final State<T> singletonState = createNormalState()__			singletonState.addTake(sinkState, currentFilterFunction)___			if (currentPattern.getQuantifier() == Quantifier.OPTIONAL) {_				singletonState.addProceed(sinkState, trueFunction)__			}__			if (addIgnore) {_				final State<T> ignoreState__				if (currentPattern.getQuantifier() == Quantifier.OPTIONAL) {_					ignoreState = createNormalState()__					ignoreState.addTake(sinkState, currentFilterFunction)__				} else {_					ignoreState = singletonState__				}_				singletonState.addIgnore(ignoreState, trueFunction)__			}_			return singletonState__		};creates,a,simple,single,state,for,an,optional,state,it,also,consists,of,a,similar,state,without,the,proceed,edge,so,that,for,each,proceed,transition,branches,in,computation,state,graph,can,be,created,only,once,param,add,ignore,if,any,ignore,should,be,added,param,sink,state,state,that,the,state,being,converted,should,point,to,return,the,created,state;suppress,warnings,unchecked,private,state,t,create,singleton,state,final,state,t,sink,state,boolean,add,ignore,final,iterative,condition,t,current,filter,function,iterative,condition,t,current,pattern,get,condition,final,iterative,condition,t,true,function,boolean,conditions,true,function,final,state,t,singleton,state,create,normal,state,singleton,state,add,take,sink,state,current,filter,function,if,current,pattern,get,quantifier,quantifier,optional,singleton,state,add,proceed,sink,state,true,function,if,add,ignore,final,state,t,ignore,state,if,current,pattern,get,quantifier,quantifier,optional,ignore,state,create,normal,state,ignore,state,add,take,sink,state,current,filter,function,else,ignore,state,singleton,state,singleton,state,add,ignore,ignore,state,true,function,return,singleton,state
NFACompiler -> NFAFactoryCompiler -> private boolean isCurrentGroupPatternFirstOfLoop();1498034481;Checks if the current group pattern is the head of the TIMES/LOOPING quantifier or not a_TIMES/LOOPING quantifier pattern.;private boolean isCurrentGroupPatternFirstOfLoop() {_			if (firstOfLoopMap.containsKey(currentGroupPattern)) {_				return firstOfLoopMap.get(currentGroupPattern)__			} else {_				return true__			}_		};checks,if,the,current,group,pattern,is,the,head,of,the,times,looping,quantifier,or,not,a,times,looping,quantifier,pattern;private,boolean,is,current,group,pattern,first,of,loop,if,first,of,loop,map,contains,key,current,group,pattern,return,first,of,loop,map,get,current,group,pattern,else,return,true
NFACompiler -> NFAFactoryCompiler -> private boolean isCurrentGroupPatternFirstOfLoop();1499760222;Checks if the current group pattern is the head of the TIMES/LOOPING quantifier or not a_TIMES/LOOPING quantifier pattern.;private boolean isCurrentGroupPatternFirstOfLoop() {_			if (firstOfLoopMap.containsKey(currentGroupPattern)) {_				return firstOfLoopMap.get(currentGroupPattern)__			} else {_				return true__			}_		};checks,if,the,current,group,pattern,is,the,head,of,the,times,looping,quantifier,or,not,a,times,looping,quantifier,pattern;private,boolean,is,current,group,pattern,first,of,loop,if,first,of,loop,map,contains,key,current,group,pattern,return,first,of,loop,map,get,current,group,pattern,else,return,true
NFACompiler -> NFAFactoryCompiler -> private boolean isCurrentGroupPatternFirstOfLoop();1499937690;Checks if the current group pattern is the head of the TIMES/LOOPING quantifier or not a_TIMES/LOOPING quantifier pattern.;private boolean isCurrentGroupPatternFirstOfLoop() {_			if (firstOfLoopMap.containsKey(currentGroupPattern)) {_				return firstOfLoopMap.get(currentGroupPattern)__			} else {_				return true__			}_		};checks,if,the,current,group,pattern,is,the,head,of,the,times,looping,quantifier,or,not,a,times,looping,quantifier,pattern;private,boolean,is,current,group,pattern,first,of,loop,if,first,of,loop,map,contains,key,current,group,pattern,return,first,of,loop,map,get,current,group,pattern,else,return,true
NFACompiler -> NFAFactoryCompiler -> private boolean isCurrentGroupPatternFirstOfLoop();1500021711;Checks if the current group pattern is the head of the TIMES/LOOPING quantifier or not a_TIMES/LOOPING quantifier pattern.;private boolean isCurrentGroupPatternFirstOfLoop() {_			if (firstOfLoopMap.containsKey(currentGroupPattern)) {_				return firstOfLoopMap.get(currentGroupPattern)__			} else {_				return true__			}_		};checks,if,the,current,group,pattern,is,the,head,of,the,times,looping,quantifier,or,not,a,times,looping,quantifier,pattern;private,boolean,is,current,group,pattern,first,of,loop,if,first,of,loop,map,contains,key,current,group,pattern,return,first,of,loop,map,get,current,group,pattern,else,return,true
NFACompiler -> NFAFactoryCompiler -> private boolean isCurrentGroupPatternFirstOfLoop();1501592283;Checks if the current group pattern is the head of the TIMES/LOOPING quantifier or not a_TIMES/LOOPING quantifier pattern.;private boolean isCurrentGroupPatternFirstOfLoop() {_			if (firstOfLoopMap.containsKey(currentGroupPattern)) {_				return firstOfLoopMap.get(currentGroupPattern)__			} else {_				return true__			}_		};checks,if,the,current,group,pattern,is,the,head,of,the,times,looping,quantifier,or,not,a,times,looping,quantifier,pattern;private,boolean,is,current,group,pattern,first,of,loop,if,first,of,loop,map,contains,key,current,group,pattern,return,first,of,loop,map,get,current,group,pattern,else,return,true
NFACompiler -> NFAFactoryCompiler -> private boolean isCurrentGroupPatternFirstOfLoop();1502422141;Checks if the current group pattern is the head of the TIMES/LOOPING quantifier or not a_TIMES/LOOPING quantifier pattern.;private boolean isCurrentGroupPatternFirstOfLoop() {_			if (firstOfLoopMap.containsKey(currentGroupPattern)) {_				return firstOfLoopMap.get(currentGroupPattern)__			} else {_				return true__			}_		};checks,if,the,current,group,pattern,is,the,head,of,the,times,looping,quantifier,or,not,a,times,looping,quantifier,pattern;private,boolean,is,current,group,pattern,first,of,loop,if,first,of,loop,map,contains,key,current,group,pattern,return,first,of,loop,map,get,current,group,pattern,else,return,true
NFACompiler -> NFAFactoryCompiler -> private boolean isCurrentGroupPatternFirstOfLoop();1503588494;Checks if the current group pattern is the head of the TIMES/LOOPING quantifier or not a_TIMES/LOOPING quantifier pattern.;private boolean isCurrentGroupPatternFirstOfLoop() {_			if (firstOfLoopMap.containsKey(currentGroupPattern)) {_				return firstOfLoopMap.get(currentGroupPattern)__			} else {_				return true__			}_		};checks,if,the,current,group,pattern,is,the,head,of,the,times,looping,quantifier,or,not,a,times,looping,quantifier,pattern;private,boolean,is,current,group,pattern,first,of,loop,if,first,of,loop,map,contains,key,current,group,pattern,return,first,of,loop,map,get,current,group,pattern,else,return,true
NFACompiler -> NFAFactoryCompiler -> private boolean isCurrentGroupPatternFirstOfLoop();1518008111;Checks if the current group pattern is the head of the TIMES/LOOPING quantifier or not a_TIMES/LOOPING quantifier pattern.;private boolean isCurrentGroupPatternFirstOfLoop() {_			if (firstOfLoopMap.containsKey(currentGroupPattern)) {_				return firstOfLoopMap.get(currentGroupPattern)__			} else {_				return true__			}_		};checks,if,the,current,group,pattern,is,the,head,of,the,times,looping,quantifier,or,not,a,times,looping,quantifier,pattern;private,boolean,is,current,group,pattern,first,of,loop,if,first,of,loop,map,contains,key,current,group,pattern,return,first,of,loop,map,get,current,group,pattern,else,return,true
NFACompiler -> NFAFactoryCompiler -> private boolean isCurrentGroupPatternFirstOfLoop();1527863170;Checks if the current group pattern is the head of the TIMES/LOOPING quantifier or not a_TIMES/LOOPING quantifier pattern.;private boolean isCurrentGroupPatternFirstOfLoop() {_			if (firstOfLoopMap.containsKey(currentGroupPattern)) {_				return firstOfLoopMap.get(currentGroupPattern)__			} else {_				return true__			}_		};checks,if,the,current,group,pattern,is,the,head,of,the,times,looping,quantifier,or,not,a,times,looping,quantifier,pattern;private,boolean,is,current,group,pattern,first,of,loop,if,first,of,loop,map,contains,key,current,group,pattern,return,first,of,loop,map,get,current,group,pattern,else,return,true
NFACompiler -> NFAFactoryCompiler -> private boolean isCurrentGroupPatternFirstOfLoop();1528989005;Checks if the current group pattern is the head of the TIMES/LOOPING quantifier or not a_TIMES/LOOPING quantifier pattern.;private boolean isCurrentGroupPatternFirstOfLoop() {_			if (firstOfLoopMap.containsKey(currentGroupPattern)) {_				return firstOfLoopMap.get(currentGroupPattern)__			} else {_				return true__			}_		};checks,if,the,current,group,pattern,is,the,head,of,the,times,looping,quantifier,or,not,a,times,looping,quantifier,pattern;private,boolean,is,current,group,pattern,first,of,loop,if,first,of,loop,map,contains,key,current,group,pattern,return,first,of,loop,map,get,current,group,pattern,else,return,true
NFACompiler -> NFAFactoryCompiler -> private boolean isCurrentGroupPatternFirstOfLoop();1538745898;Checks if the current group pattern is the head of the TIMES/LOOPING quantifier or not a_TIMES/LOOPING quantifier pattern.;private boolean isCurrentGroupPatternFirstOfLoop() {_			if (firstOfLoopMap.containsKey(currentGroupPattern)) {_				return firstOfLoopMap.get(currentGroupPattern)__			} else {_				return true__			}_		};checks,if,the,current,group,pattern,is,the,head,of,the,times,looping,quantifier,or,not,a,times,looping,quantifier,pattern;private,boolean,is,current,group,pattern,first,of,loop,if,first,of,loop,map,contains,key,current,group,pattern,return,first,of,loop,map,get,current,group,pattern,else,return,true
NFACompiler -> NFAFactoryCompiler -> private boolean isCurrentGroupPatternFirstOfLoop();1542293931;Checks if the current group pattern is the head of the TIMES/LOOPING quantifier or not a_TIMES/LOOPING quantifier pattern.;private boolean isCurrentGroupPatternFirstOfLoop() {_			if (firstOfLoopMap.containsKey(currentGroupPattern)) {_				return firstOfLoopMap.get(currentGroupPattern)__			} else {_				return true__			}_		};checks,if,the,current,group,pattern,is,the,head,of,the,times,looping,quantifier,or,not,a,times,looping,quantifier,pattern;private,boolean,is,current,group,pattern,first,of,loop,if,first,of,loop,map,contains,key,current,group,pattern,return,first,of,loop,map,get,current,group,pattern,else,return,true
NFACompiler -> NFAFactoryCompiler -> private State<T> createWaitingStateForZeroOrMore(final State<T> loopingState, final State<T> lastSink);1490619911;Creates a pair of states that enables relaxed strictness before a zeroOrMore looping state.__@param loopingState the first state of zeroOrMore complex state_@param lastSink     the state that the looping one points to_@return the newly created state;private State<T> createWaitingStateForZeroOrMore(final State<T> loopingState, final State<T> lastSink) {_			final State<T> followByState = createNormalState()__			final State<T> followByStateWithoutProceed = createNormalState()___			final IterativeCondition<T> currentFunction = (IterativeCondition<T>)currentPattern.getCondition()__			final IterativeCondition<T> ignoreFunction = getIgnoreCondition(currentPattern)___			followByState.addProceed(lastSink, BooleanConditions.<T>trueFunction())__			followByState.addIgnore(followByStateWithoutProceed, ignoreFunction)__			followByState.addTake(loopingState, currentFunction)___			followByStateWithoutProceed.addIgnore(ignoreFunction)__			followByStateWithoutProceed.addTake(loopingState, currentFunction)___			return followByState__		};creates,a,pair,of,states,that,enables,relaxed,strictness,before,a,zero,or,more,looping,state,param,looping,state,the,first,state,of,zero,or,more,complex,state,param,last,sink,the,state,that,the,looping,one,points,to,return,the,newly,created,state;private,state,t,create,waiting,state,for,zero,or,more,final,state,t,looping,state,final,state,t,last,sink,final,state,t,follow,by,state,create,normal,state,final,state,t,follow,by,state,without,proceed,create,normal,state,final,iterative,condition,t,current,function,iterative,condition,t,current,pattern,get,condition,final,iterative,condition,t,ignore,function,get,ignore,condition,current,pattern,follow,by,state,add,proceed,last,sink,boolean,conditions,t,true,function,follow,by,state,add,ignore,follow,by,state,without,proceed,ignore,function,follow,by,state,add,take,looping,state,current,function,follow,by,state,without,proceed,add,ignore,ignore,function,follow,by,state,without,proceed,add,take,looping,state,current,function,return,follow,by,state
NFACompiler -> NFAFactoryCompiler -> private State<T> createWaitingStateForZeroOrMore(final State<T> loopingState, final State<T> lastSink);1491320734;Creates a pair of states that enables relaxed strictness before a zeroOrMore looping state.__@param loopingState the first state of zeroOrMore complex state_@param lastSink     the state that the looping one points to_@return the newly created state;private State<T> createWaitingStateForZeroOrMore(final State<T> loopingState, final State<T> lastSink) {_			final State<T> followByState = createNormalState()__			final State<T> followByStateWithoutProceed = createNormalState()___			final IterativeCondition<T> currentFunction = (IterativeCondition<T>)currentPattern.getCondition()__			final IterativeCondition<T> ignoreFunction = getIgnoreCondition(currentPattern)___			followByState.addProceed(lastSink, BooleanConditions.<T>trueFunction())__			followByState.addIgnore(followByStateWithoutProceed, ignoreFunction)__			followByState.addTake(loopingState, currentFunction)___			followByStateWithoutProceed.addIgnore(ignoreFunction)__			followByStateWithoutProceed.addTake(loopingState, currentFunction)___			return followByState__		};creates,a,pair,of,states,that,enables,relaxed,strictness,before,a,zero,or,more,looping,state,param,looping,state,the,first,state,of,zero,or,more,complex,state,param,last,sink,the,state,that,the,looping,one,points,to,return,the,newly,created,state;private,state,t,create,waiting,state,for,zero,or,more,final,state,t,looping,state,final,state,t,last,sink,final,state,t,follow,by,state,create,normal,state,final,state,t,follow,by,state,without,proceed,create,normal,state,final,iterative,condition,t,current,function,iterative,condition,t,current,pattern,get,condition,final,iterative,condition,t,ignore,function,get,ignore,condition,current,pattern,follow,by,state,add,proceed,last,sink,boolean,conditions,t,true,function,follow,by,state,add,ignore,follow,by,state,without,proceed,ignore,function,follow,by,state,add,take,looping,state,current,function,follow,by,state,without,proceed,add,ignore,ignore,function,follow,by,state,without,proceed,add,take,looping,state,current,function,return,follow,by,state
NFACompiler -> NFAFactoryCompiler -> private State<T> createWaitingStateForZeroOrMore(final State<T> loopingState, final State<T> lastSink);1491323030;Creates a pair of states that enables relaxed strictness before a zeroOrMore looping state.__@param loopingState the first state of zeroOrMore complex state_@param lastSink     the state that the looping one points to_@return the newly created state;private State<T> createWaitingStateForZeroOrMore(final State<T> loopingState, final State<T> lastSink) {_			final State<T> followByState = createNormalState()__			final State<T> followByStateWithoutProceed = createNormalState()___			final IterativeCondition<T> currentFunction = (IterativeCondition<T>)currentPattern.getCondition()__			final IterativeCondition<T> ignoreFunction = getIgnoreCondition(currentPattern)___			followByState.addProceed(lastSink, BooleanConditions.<T>trueFunction())__			followByState.addIgnore(followByStateWithoutProceed, ignoreFunction)__			followByState.addTake(loopingState, currentFunction)___			followByStateWithoutProceed.addIgnore(ignoreFunction)__			followByStateWithoutProceed.addTake(loopingState, currentFunction)___			return followByState__		};creates,a,pair,of,states,that,enables,relaxed,strictness,before,a,zero,or,more,looping,state,param,looping,state,the,first,state,of,zero,or,more,complex,state,param,last,sink,the,state,that,the,looping,one,points,to,return,the,newly,created,state;private,state,t,create,waiting,state,for,zero,or,more,final,state,t,looping,state,final,state,t,last,sink,final,state,t,follow,by,state,create,normal,state,final,state,t,follow,by,state,without,proceed,create,normal,state,final,iterative,condition,t,current,function,iterative,condition,t,current,pattern,get,condition,final,iterative,condition,t,ignore,function,get,ignore,condition,current,pattern,follow,by,state,add,proceed,last,sink,boolean,conditions,t,true,function,follow,by,state,add,ignore,follow,by,state,without,proceed,ignore,function,follow,by,state,add,take,looping,state,current,function,follow,by,state,without,proceed,add,ignore,ignore,function,follow,by,state,without,proceed,add,take,looping,state,current,function,return,follow,by,state
NFACompiler -> NFAFactoryCompiler -> private State<T> createWaitingStateForZeroOrMore(final State<T> loopingState, final State<T> lastSink);1491633862;Creates a pair of states that enables relaxed strictness before a zeroOrMore looping state.__@param loopingState the first state of zeroOrMore complex state_@param lastSink     the state that the looping one points to_@return the newly created state;private State<T> createWaitingStateForZeroOrMore(final State<T> loopingState, final State<T> lastSink) {_			final State<T> followByState = createNormalState()__			final State<T> followByStateWithoutProceed = createNormalState()___			final IterativeCondition<T> currentFunction = (IterativeCondition<T>)currentPattern.getCondition()__			final IterativeCondition<T> ignoreFunction = getIgnoreCondition(currentPattern)___			followByState.addProceed(lastSink, BooleanConditions.<T>trueFunction())__			followByState.addIgnore(followByStateWithoutProceed, ignoreFunction)__			followByState.addTake(loopingState, currentFunction)___			followByStateWithoutProceed.addIgnore(ignoreFunction)__			followByStateWithoutProceed.addTake(loopingState, currentFunction)___			return followByState__		};creates,a,pair,of,states,that,enables,relaxed,strictness,before,a,zero,or,more,looping,state,param,looping,state,the,first,state,of,zero,or,more,complex,state,param,last,sink,the,state,that,the,looping,one,points,to,return,the,newly,created,state;private,state,t,create,waiting,state,for,zero,or,more,final,state,t,looping,state,final,state,t,last,sink,final,state,t,follow,by,state,create,normal,state,final,state,t,follow,by,state,without,proceed,create,normal,state,final,iterative,condition,t,current,function,iterative,condition,t,current,pattern,get,condition,final,iterative,condition,t,ignore,function,get,ignore,condition,current,pattern,follow,by,state,add,proceed,last,sink,boolean,conditions,t,true,function,follow,by,state,add,ignore,follow,by,state,without,proceed,ignore,function,follow,by,state,add,take,looping,state,current,function,follow,by,state,without,proceed,add,ignore,ignore,function,follow,by,state,without,proceed,add,take,looping,state,current,function,return,follow,by,state
NFACompiler -> NFAFactoryCompiler -> private State<T> createWaitingStateForZeroOrMore(final State<T> loopingState, final State<T> lastSink);1492797583;Creates a pair of states that enables relaxed strictness before a zeroOrMore looping state.__@param loopingState the first state of zeroOrMore complex state_@param lastSink     the state that the looping one points to_@return the newly created state;private State<T> createWaitingStateForZeroOrMore(final State<T> loopingState, final State<T> lastSink) {_			final State<T> followByState = createNormalState()__			final State<T> followByStateWithoutProceed = createNormalState()___			final IterativeCondition<T> currentFunction = (IterativeCondition<T>)currentPattern.getCondition()__			final IterativeCondition<T> ignoreFunction = getIgnoreCondition(currentPattern)___			followByState.addProceed(lastSink, BooleanConditions.<T>trueFunction())__			followByState.addIgnore(followByStateWithoutProceed, ignoreFunction)__			followByState.addTake(loopingState, currentFunction)___			followByStateWithoutProceed.addIgnore(ignoreFunction)__			followByStateWithoutProceed.addTake(loopingState, currentFunction)___			return followByState__		};creates,a,pair,of,states,that,enables,relaxed,strictness,before,a,zero,or,more,looping,state,param,looping,state,the,first,state,of,zero,or,more,complex,state,param,last,sink,the,state,that,the,looping,one,points,to,return,the,newly,created,state;private,state,t,create,waiting,state,for,zero,or,more,final,state,t,looping,state,final,state,t,last,sink,final,state,t,follow,by,state,create,normal,state,final,state,t,follow,by,state,without,proceed,create,normal,state,final,iterative,condition,t,current,function,iterative,condition,t,current,pattern,get,condition,final,iterative,condition,t,ignore,function,get,ignore,condition,current,pattern,follow,by,state,add,proceed,last,sink,boolean,conditions,t,true,function,follow,by,state,add,ignore,follow,by,state,without,proceed,ignore,function,follow,by,state,add,take,looping,state,current,function,follow,by,state,without,proceed,add,ignore,ignore,function,follow,by,state,without,proceed,add,take,looping,state,current,function,return,follow,by,state
NFACompiler -> NFAFactoryCompiler -> private void checkPatternNameUniqueness();1498034481;Check if there are duplicate pattern names. If yes, it_throws a {@link MalformedPatternException}.;private void checkPatternNameUniqueness() {_			_			stateNameHandler.checkNameUniqueness(ENDING_STATE_NAME)__			Pattern patternToCheck = currentPattern__			while (patternToCheck != null) {_				checkPatternNameUniqueness(patternToCheck)__				patternToCheck = patternToCheck.getPrevious()__			}_			stateNameHandler.clear()__		};check,if,there,are,duplicate,pattern,names,if,yes,it,throws,a,link,malformed,pattern,exception;private,void,check,pattern,name,uniqueness,state,name,handler,check,name,uniqueness,pattern,pattern,to,check,current,pattern,while,pattern,to,check,null,check,pattern,name,uniqueness,pattern,to,check,pattern,to,check,pattern,to,check,get,previous,state,name,handler,clear
NFACompiler -> NFAFactoryCompiler -> private void checkPatternNameUniqueness();1499760222;Check if there are duplicate pattern names. If yes, it_throws a {@link MalformedPatternException}.;private void checkPatternNameUniqueness() {_			_			stateNameHandler.checkNameUniqueness(ENDING_STATE_NAME)__			Pattern patternToCheck = currentPattern__			while (patternToCheck != null) {_				checkPatternNameUniqueness(patternToCheck)__				patternToCheck = patternToCheck.getPrevious()__			}_			stateNameHandler.clear()__		};check,if,there,are,duplicate,pattern,names,if,yes,it,throws,a,link,malformed,pattern,exception;private,void,check,pattern,name,uniqueness,state,name,handler,check,name,uniqueness,pattern,pattern,to,check,current,pattern,while,pattern,to,check,null,check,pattern,name,uniqueness,pattern,to,check,pattern,to,check,pattern,to,check,get,previous,state,name,handler,clear
NFACompiler -> NFAFactoryCompiler -> private void checkPatternNameUniqueness();1499937690;Check if there are duplicate pattern names. If yes, it_throws a {@link MalformedPatternException}.;private void checkPatternNameUniqueness() {_			_			stateNameHandler.checkNameUniqueness(ENDING_STATE_NAME)__			Pattern patternToCheck = currentPattern__			while (patternToCheck != null) {_				checkPatternNameUniqueness(patternToCheck)__				patternToCheck = patternToCheck.getPrevious()__			}_			stateNameHandler.clear()__		};check,if,there,are,duplicate,pattern,names,if,yes,it,throws,a,link,malformed,pattern,exception;private,void,check,pattern,name,uniqueness,state,name,handler,check,name,uniqueness,pattern,pattern,to,check,current,pattern,while,pattern,to,check,null,check,pattern,name,uniqueness,pattern,to,check,pattern,to,check,pattern,to,check,get,previous,state,name,handler,clear
NFACompiler -> NFAFactoryCompiler -> private void checkPatternNameUniqueness();1500021711;Check if there are duplicate pattern names. If yes, it_throws a {@link MalformedPatternException}.;private void checkPatternNameUniqueness() {_			_			stateNameHandler.checkNameUniqueness(ENDING_STATE_NAME)__			Pattern patternToCheck = currentPattern__			while (patternToCheck != null) {_				checkPatternNameUniqueness(patternToCheck)__				patternToCheck = patternToCheck.getPrevious()__			}_			stateNameHandler.clear()__		};check,if,there,are,duplicate,pattern,names,if,yes,it,throws,a,link,malformed,pattern,exception;private,void,check,pattern,name,uniqueness,state,name,handler,check,name,uniqueness,pattern,pattern,to,check,current,pattern,while,pattern,to,check,null,check,pattern,name,uniqueness,pattern,to,check,pattern,to,check,pattern,to,check,get,previous,state,name,handler,clear
NFACompiler -> NFAFactoryCompiler -> private void checkPatternNameUniqueness();1501592283;Check if there are duplicate pattern names. If yes, it_throws a {@link MalformedPatternException}.;private void checkPatternNameUniqueness() {_			_			stateNameHandler.checkNameUniqueness(ENDING_STATE_NAME)__			Pattern patternToCheck = currentPattern__			while (patternToCheck != null) {_				checkPatternNameUniqueness(patternToCheck)__				patternToCheck = patternToCheck.getPrevious()__			}_			stateNameHandler.clear()__		};check,if,there,are,duplicate,pattern,names,if,yes,it,throws,a,link,malformed,pattern,exception;private,void,check,pattern,name,uniqueness,state,name,handler,check,name,uniqueness,pattern,pattern,to,check,current,pattern,while,pattern,to,check,null,check,pattern,name,uniqueness,pattern,to,check,pattern,to,check,pattern,to,check,get,previous,state,name,handler,clear
NFACompiler -> NFAFactoryCompiler -> private void checkPatternNameUniqueness();1502422141;Check if there are duplicate pattern names. If yes, it_throws a {@link MalformedPatternException}.;private void checkPatternNameUniqueness() {_			_			stateNameHandler.checkNameUniqueness(ENDING_STATE_NAME)__			Pattern patternToCheck = currentPattern__			while (patternToCheck != null) {_				checkPatternNameUniqueness(patternToCheck)__				patternToCheck = patternToCheck.getPrevious()__			}_			stateNameHandler.clear()__		};check,if,there,are,duplicate,pattern,names,if,yes,it,throws,a,link,malformed,pattern,exception;private,void,check,pattern,name,uniqueness,state,name,handler,check,name,uniqueness,pattern,pattern,to,check,current,pattern,while,pattern,to,check,null,check,pattern,name,uniqueness,pattern,to,check,pattern,to,check,pattern,to,check,get,previous,state,name,handler,clear
NFACompiler -> NFAFactoryCompiler -> private void checkPatternNameUniqueness();1503588494;Check if there are duplicate pattern names. If yes, it_throws a {@link MalformedPatternException}.;private void checkPatternNameUniqueness() {_			_			stateNameHandler.checkNameUniqueness(ENDING_STATE_NAME)__			Pattern patternToCheck = currentPattern__			while (patternToCheck != null) {_				checkPatternNameUniqueness(patternToCheck)__				patternToCheck = patternToCheck.getPrevious()__			}_			stateNameHandler.clear()__		};check,if,there,are,duplicate,pattern,names,if,yes,it,throws,a,link,malformed,pattern,exception;private,void,check,pattern,name,uniqueness,state,name,handler,check,name,uniqueness,pattern,pattern,to,check,current,pattern,while,pattern,to,check,null,check,pattern,name,uniqueness,pattern,to,check,pattern,to,check,pattern,to,check,get,previous,state,name,handler,clear
NFACompiler -> NFAFactoryCompiler -> private void checkPatternNameUniqueness();1518008111;Check if there are duplicate pattern names. If yes, it_throws a {@link MalformedPatternException}.;private void checkPatternNameUniqueness() {_			_			stateNameHandler.checkNameUniqueness(ENDING_STATE_NAME)__			Pattern patternToCheck = currentPattern__			while (patternToCheck != null) {_				checkPatternNameUniqueness(patternToCheck)__				patternToCheck = patternToCheck.getPrevious()__			}_			stateNameHandler.clear()__		};check,if,there,are,duplicate,pattern,names,if,yes,it,throws,a,link,malformed,pattern,exception;private,void,check,pattern,name,uniqueness,state,name,handler,check,name,uniqueness,pattern,pattern,to,check,current,pattern,while,pattern,to,check,null,check,pattern,name,uniqueness,pattern,to,check,pattern,to,check,pattern,to,check,get,previous,state,name,handler,clear
NFACompiler -> NFAFactoryCompiler -> private void checkPatternNameUniqueness();1527863170;Check if there are duplicate pattern names. If yes, it_throws a {@link MalformedPatternException}.;private void checkPatternNameUniqueness() {_			_			stateNameHandler.checkNameUniqueness(ENDING_STATE_NAME)__			Pattern patternToCheck = currentPattern__			while (patternToCheck != null) {_				checkPatternNameUniqueness(patternToCheck)__				patternToCheck = patternToCheck.getPrevious()__			}_			stateNameHandler.clear()__		};check,if,there,are,duplicate,pattern,names,if,yes,it,throws,a,link,malformed,pattern,exception;private,void,check,pattern,name,uniqueness,state,name,handler,check,name,uniqueness,pattern,pattern,to,check,current,pattern,while,pattern,to,check,null,check,pattern,name,uniqueness,pattern,to,check,pattern,to,check,pattern,to,check,get,previous,state,name,handler,clear
NFACompiler -> NFAFactoryCompiler -> private void checkPatternNameUniqueness();1528989005;Check if there are duplicate pattern names. If yes, it_throws a {@link MalformedPatternException}.;private void checkPatternNameUniqueness() {_			_			stateNameHandler.checkNameUniqueness(ENDING_STATE_NAME)__			Pattern patternToCheck = currentPattern__			while (patternToCheck != null) {_				checkPatternNameUniqueness(patternToCheck)__				patternToCheck = patternToCheck.getPrevious()__			}_			stateNameHandler.clear()__		};check,if,there,are,duplicate,pattern,names,if,yes,it,throws,a,link,malformed,pattern,exception;private,void,check,pattern,name,uniqueness,state,name,handler,check,name,uniqueness,pattern,pattern,to,check,current,pattern,while,pattern,to,check,null,check,pattern,name,uniqueness,pattern,to,check,pattern,to,check,pattern,to,check,get,previous,state,name,handler,clear
NFACompiler -> NFAFactoryCompiler -> private void checkPatternNameUniqueness();1538745898;Check if there are duplicate pattern names. If yes, it_throws a {@link MalformedPatternException}.;private void checkPatternNameUniqueness() {_			_			stateNameHandler.checkNameUniqueness(ENDING_STATE_NAME)__			Pattern patternToCheck = currentPattern__			while (patternToCheck != null) {_				checkPatternNameUniqueness(patternToCheck)__				patternToCheck = patternToCheck.getPrevious()__			}_			stateNameHandler.clear()__		};check,if,there,are,duplicate,pattern,names,if,yes,it,throws,a,link,malformed,pattern,exception;private,void,check,pattern,name,uniqueness,state,name,handler,check,name,uniqueness,pattern,pattern,to,check,current,pattern,while,pattern,to,check,null,check,pattern,name,uniqueness,pattern,to,check,pattern,to,check,pattern,to,check,get,previous,state,name,handler,clear
NFACompiler -> NFAFactoryCompiler -> private void checkPatternNameUniqueness();1542293931;Check if there are duplicate pattern names. If yes, it_throws a {@link MalformedPatternException}.;private void checkPatternNameUniqueness() {_			_			stateNameHandler.checkNameUniqueness(ENDING_STATE_NAME)__			Pattern patternToCheck = currentPattern__			while (patternToCheck != null) {_				checkPatternNameUniqueness(patternToCheck)__				patternToCheck = patternToCheck.getPrevious()__			}_			stateNameHandler.clear()__		};check,if,there,are,duplicate,pattern,names,if,yes,it,throws,a,link,malformed,pattern,exception;private,void,check,pattern,name,uniqueness,state,name,handler,check,name,uniqueness,pattern,pattern,to,check,current,pattern,while,pattern,to,check,null,check,pattern,name,uniqueness,pattern,to,check,pattern,to,check,pattern,to,check,get,previous,state,name,handler,clear
NFACompiler -> @SuppressWarnings("unchecked") 	public static <T> NFAFactory<T> compileFactory( 		Pattern<T, ?> pattern, 		TypeSerializer<T> inputTypeSerializer, 		boolean timeoutHandling);1464255256;Compiles the given pattern into a {@link NFAFactory}. The NFA factory can be used to create_multiple NFAs.__@param pattern Definition of sequence pattern_@param inputTypeSerializer Serializer for the input type_@param timeoutHandling True if the NFA shall return timed out event patterns_@param <T> Type of the input events_@return Factory for NFAs corresponding to the given pattern;@SuppressWarnings("unchecked")_	public static <T> NFAFactory<T> compileFactory(_		Pattern<T, ?> pattern,_		TypeSerializer<T> inputTypeSerializer,_		boolean timeoutHandling) {_		if (pattern == null) {_			_			return new NFAFactoryImpl<T>(inputTypeSerializer, 0, Collections.<State<T>>emptyList(), timeoutHandling)__		} else {_			_			Map<String, State<T>> states = new HashMap<>()__			long windowTime___			Pattern<T, ?> succeedingPattern__			State<T> succeedingState__			Pattern<T, ?> currentPattern = pattern___			_			State<T> currentState = new State<>(currentPattern.getName(), State.StateType.Final)___			states.put(currentPattern.getName(), currentState)___			windowTime = currentPattern.getWindowTime() != null ? currentPattern.getWindowTime().toMilliseconds() : 0L___			while (currentPattern.getPrevious() != null) {_				succeedingPattern = currentPattern__				succeedingState = currentState__				currentPattern = currentPattern.getPrevious()___				Time currentWindowTime = currentPattern.getWindowTime()___				if (currentWindowTime != null && currentWindowTime.toMilliseconds() < windowTime) {_					_					windowTime = currentWindowTime.toMilliseconds()__				}__				if (states.containsKey(currentPattern.getName())) {_					currentState = states.get(currentPattern.getName())__				} else {_					currentState = new State<>(currentPattern.getName(), State.StateType.Normal)__					states.put(currentState.getName(), currentState)__				}__				currentState.addStateTransition(new StateTransition<T>(_					StateTransitionAction.TAKE,_					succeedingState,_					(FilterFunction<T>) succeedingPattern.getFilterFunction()))___				if (succeedingPattern instanceof FollowedByPattern) {_					_					currentState.addStateTransition(new StateTransition<T>(_						StateTransitionAction.IGNORE,_						currentState,_						null_					))__				}_			}__			_			final State<T> beginningState___			if (states.containsKey(BEGINNING_STATE_NAME)) {_				beginningState = states.get(BEGINNING_STATE_NAME)__			} else {_				beginningState = new State<>(BEGINNING_STATE_NAME, State.StateType.Start)__				states.put(BEGINNING_STATE_NAME, beginningState)__			}__			beginningState.addStateTransition(new StateTransition<T>(_				StateTransitionAction.TAKE,_				currentState,_				(FilterFunction<T>) currentPattern.getFilterFunction()_			))___			return new NFAFactoryImpl<T>(inputTypeSerializer, windowTime, new HashSet<>(states.values()), timeoutHandling)__		}_	};compiles,the,given,pattern,into,a,link,nfafactory,the,nfa,factory,can,be,used,to,create,multiple,nfas,param,pattern,definition,of,sequence,pattern,param,input,type,serializer,serializer,for,the,input,type,param,timeout,handling,true,if,the,nfa,shall,return,timed,out,event,patterns,param,t,type,of,the,input,events,return,factory,for,nfas,corresponding,to,the,given,pattern;suppress,warnings,unchecked,public,static,t,nfafactory,t,compile,factory,pattern,t,pattern,type,serializer,t,input,type,serializer,boolean,timeout,handling,if,pattern,null,return,new,nfafactory,impl,t,input,type,serializer,0,collections,state,t,empty,list,timeout,handling,else,map,string,state,t,states,new,hash,map,long,window,time,pattern,t,succeeding,pattern,state,t,succeeding,state,pattern,t,current,pattern,pattern,state,t,current,state,new,state,current,pattern,get,name,state,state,type,final,states,put,current,pattern,get,name,current,state,window,time,current,pattern,get,window,time,null,current,pattern,get,window,time,to,milliseconds,0l,while,current,pattern,get,previous,null,succeeding,pattern,current,pattern,succeeding,state,current,state,current,pattern,current,pattern,get,previous,time,current,window,time,current,pattern,get,window,time,if,current,window,time,null,current,window,time,to,milliseconds,window,time,window,time,current,window,time,to,milliseconds,if,states,contains,key,current,pattern,get,name,current,state,states,get,current,pattern,get,name,else,current,state,new,state,current,pattern,get,name,state,state,type,normal,states,put,current,state,get,name,current,state,current,state,add,state,transition,new,state,transition,t,state,transition,action,take,succeeding,state,filter,function,t,succeeding,pattern,get,filter,function,if,succeeding,pattern,instanceof,followed,by,pattern,current,state,add,state,transition,new,state,transition,t,state,transition,action,ignore,current,state,null,final,state,t,beginning,state,if,states,contains,key,beginning,state,states,get,else,beginning,state,new,state,state,state,type,start,states,put,beginning,state,beginning,state,add,state,transition,new,state,transition,t,state,transition,action,take,current,state,filter,function,t,current,pattern,get,filter,function,return,new,nfafactory,impl,t,input,type,serializer,window,time,new,hash,set,states,values,timeout,handling
NFACompiler -> @SuppressWarnings("unchecked") 	public static <T> NFAFactory<T> compileFactory( 		Pattern<T, ?> pattern, 		TypeSerializer<T> inputTypeSerializer, 		boolean timeoutHandling);1487681471;Compiles the given pattern into a {@link NFAFactory}. The NFA factory can be used to create_multiple NFAs.__@param pattern Definition of sequence pattern_@param inputTypeSerializer Serializer for the input type_@param timeoutHandling True if the NFA shall return timed out event patterns_@param <T> Type of the input events_@return Factory for NFAs corresponding to the given pattern;@SuppressWarnings("unchecked")_	public static <T> NFAFactory<T> compileFactory(_		Pattern<T, ?> pattern,_		TypeSerializer<T> inputTypeSerializer,_		boolean timeoutHandling) {_		if (pattern == null) {_			_			return new NFAFactoryImpl<T>(inputTypeSerializer, 0, Collections.<State<T>>emptyList(), timeoutHandling)__		} else {_			_			Map<String, State<T>> states = new HashMap<>()__			long windowTime___			_			Set<String> patternNames = new HashSet<>()___			Pattern<T, ?> succeedingPattern__			State<T> succeedingState__			Pattern<T, ?> currentPattern = pattern___			_			State<T> currentState = new State<>(currentPattern.getName(), State.StateType.Final)__			patternNames.add(currentPattern.getName())___			states.put(currentPattern.getName(), currentState)___			windowTime = currentPattern.getWindowTime() != null ? currentPattern.getWindowTime().toMilliseconds() : 0L___			while (currentPattern.getPrevious() != null) {_				succeedingPattern = currentPattern__				succeedingState = currentState__				currentPattern = currentPattern.getPrevious()___				if (!patternNames.add(currentPattern.getName())) {_					throw new MalformedPatternException("Duplicate pattern name: " + currentPattern.getName() + ". " +_						"Pattern names must be unique.")__				}__				Time currentWindowTime = currentPattern.getWindowTime()___				if (currentWindowTime != null && currentWindowTime.toMilliseconds() < windowTime) {_					_					windowTime = currentWindowTime.toMilliseconds()__				}__				if (states.containsKey(currentPattern.getName())) {_					currentState = states.get(currentPattern.getName())__				} else {_					currentState = new State<>(currentPattern.getName(), State.StateType.Normal)__					states.put(currentState.getName(), currentState)__				}__				currentState.addStateTransition(new StateTransition<T>(_					StateTransitionAction.TAKE,_					succeedingState,_					(FilterFunction<T>) succeedingPattern.getFilterFunction()))___				if (succeedingPattern instanceof FollowedByPattern) {_					_					currentState.addStateTransition(new StateTransition<T>(_						StateTransitionAction.IGNORE,_						currentState,_						null_					))__				}_			}__			_			final State<T> beginningState___			if (states.containsKey(BEGINNING_STATE_NAME)) {_				beginningState = states.get(BEGINNING_STATE_NAME)__			} else {_				beginningState = new State<>(BEGINNING_STATE_NAME, State.StateType.Start)__				states.put(BEGINNING_STATE_NAME, beginningState)__			}__			beginningState.addStateTransition(new StateTransition<T>(_				StateTransitionAction.TAKE,_				currentState,_				(FilterFunction<T>) currentPattern.getFilterFunction()_			))___			return new NFAFactoryImpl<T>(inputTypeSerializer, windowTime, new HashSet<>(states.values()), timeoutHandling)__		}_	};compiles,the,given,pattern,into,a,link,nfafactory,the,nfa,factory,can,be,used,to,create,multiple,nfas,param,pattern,definition,of,sequence,pattern,param,input,type,serializer,serializer,for,the,input,type,param,timeout,handling,true,if,the,nfa,shall,return,timed,out,event,patterns,param,t,type,of,the,input,events,return,factory,for,nfas,corresponding,to,the,given,pattern;suppress,warnings,unchecked,public,static,t,nfafactory,t,compile,factory,pattern,t,pattern,type,serializer,t,input,type,serializer,boolean,timeout,handling,if,pattern,null,return,new,nfafactory,impl,t,input,type,serializer,0,collections,state,t,empty,list,timeout,handling,else,map,string,state,t,states,new,hash,map,long,window,time,set,string,pattern,names,new,hash,set,pattern,t,succeeding,pattern,state,t,succeeding,state,pattern,t,current,pattern,pattern,state,t,current,state,new,state,current,pattern,get,name,state,state,type,final,pattern,names,add,current,pattern,get,name,states,put,current,pattern,get,name,current,state,window,time,current,pattern,get,window,time,null,current,pattern,get,window,time,to,milliseconds,0l,while,current,pattern,get,previous,null,succeeding,pattern,current,pattern,succeeding,state,current,state,current,pattern,current,pattern,get,previous,if,pattern,names,add,current,pattern,get,name,throw,new,malformed,pattern,exception,duplicate,pattern,name,current,pattern,get,name,pattern,names,must,be,unique,time,current,window,time,current,pattern,get,window,time,if,current,window,time,null,current,window,time,to,milliseconds,window,time,window,time,current,window,time,to,milliseconds,if,states,contains,key,current,pattern,get,name,current,state,states,get,current,pattern,get,name,else,current,state,new,state,current,pattern,get,name,state,state,type,normal,states,put,current,state,get,name,current,state,current,state,add,state,transition,new,state,transition,t,state,transition,action,take,succeeding,state,filter,function,t,succeeding,pattern,get,filter,function,if,succeeding,pattern,instanceof,followed,by,pattern,current,state,add,state,transition,new,state,transition,t,state,transition,action,ignore,current,state,null,final,state,t,beginning,state,if,states,contains,key,beginning,state,states,get,else,beginning,state,new,state,state,state,type,start,states,put,beginning,state,beginning,state,add,state,transition,new,state,transition,t,state,transition,action,take,current,state,filter,function,t,current,pattern,get,filter,function,return,new,nfafactory,impl,t,input,type,serializer,window,time,new,hash,set,states,values,timeout,handling
NFACompiler -> NFAFactoryCompiler -> @SuppressWarnings("unchecked") 		private State<T> createSingletonState(final State<T> sinkState, final IterativeCondition<T> ignoreCondition, final boolean isOptional);1493200673;Creates a simple single state. For an OPTIONAL state it also consists_of a similar state without the PROCEED edge, so that for each PROCEED transition branches_in computation state graph  can be created only once.__@param ignoreCondition condition that should be applied to IGNORE transition_@param sinkState state that the state being converted should point to_@return the created state;@SuppressWarnings("unchecked")_		private State<T> createSingletonState(final State<T> sinkState, final IterativeCondition<T> ignoreCondition, final boolean isOptional) {_			final IterativeCondition<T> currentFilterFunction = (IterativeCondition<T>) currentPattern.getCondition()__			final IterativeCondition<T> trueFunction = BooleanConditions.trueFunction()___			final State<T> singletonState = createNormalState()__			singletonState.addTake(sinkState, currentFilterFunction)___			if (isOptional) {_				singletonState.addProceed(sinkState, trueFunction)__			}__			if (ignoreCondition != null) {_				final State<T> ignoreState__				if (isOptional) {_					ignoreState = createNormalState()__					ignoreState.addTake(sinkState, currentFilterFunction)__				} else {_					ignoreState = singletonState__				}_				singletonState.addIgnore(ignoreState, ignoreCondition)__			}_			return singletonState__		};creates,a,simple,single,state,for,an,optional,state,it,also,consists,of,a,similar,state,without,the,proceed,edge,so,that,for,each,proceed,transition,branches,in,computation,state,graph,can,be,created,only,once,param,ignore,condition,condition,that,should,be,applied,to,ignore,transition,param,sink,state,state,that,the,state,being,converted,should,point,to,return,the,created,state;suppress,warnings,unchecked,private,state,t,create,singleton,state,final,state,t,sink,state,final,iterative,condition,t,ignore,condition,final,boolean,is,optional,final,iterative,condition,t,current,filter,function,iterative,condition,t,current,pattern,get,condition,final,iterative,condition,t,true,function,boolean,conditions,true,function,final,state,t,singleton,state,create,normal,state,singleton,state,add,take,sink,state,current,filter,function,if,is,optional,singleton,state,add,proceed,sink,state,true,function,if,ignore,condition,null,final,state,t,ignore,state,if,is,optional,ignore,state,create,normal,state,ignore,state,add,take,sink,state,current,filter,function,else,ignore,state,singleton,state,singleton,state,add,ignore,ignore,state,ignore,condition,return,singleton,state
NFACompiler -> NFAFactoryCompiler -> @SuppressWarnings("unchecked") 		private State<T> createSingletonState(final State<T> sinkState, final IterativeCondition<T> ignoreCondition, final boolean isOptional);1493385877;Creates a simple single state. For an OPTIONAL state it also consists_of a similar state without the PROCEED edge, so that for each PROCEED transition branches_in computation state graph  can be created only once.__@param ignoreCondition condition that should be applied to IGNORE transition_@param sinkState state that the state being converted should point to_@return the created state;@SuppressWarnings("unchecked")_		private State<T> createSingletonState(final State<T> sinkState, final IterativeCondition<T> ignoreCondition, final boolean isOptional) {_			final IterativeCondition<T> currentCondition = (IterativeCondition<T>) currentPattern.getCondition()__			final IterativeCondition<T> trueFunction = BooleanConditions.trueFunction()___			final State<T> singletonState = createNormalState()__			_			final State<T> sink = copyWithoutTransitiveNots(sinkState)__			singletonState.addTake(sink, currentCondition)___			if (isOptional) {_				_				singletonState.addProceed(sinkState, trueFunction)__			}__			if (ignoreCondition != null) {_				final State<T> ignoreState__				if (isOptional) {_					ignoreState = createNormalState()__					ignoreState.addTake(sink, currentCondition)__					ignoreState.addIgnore(ignoreCondition)__					addStopStates(ignoreState)__				} else {_					ignoreState = singletonState__				}_				singletonState.addIgnore(ignoreState, ignoreCondition)__			}_			return singletonState__		};creates,a,simple,single,state,for,an,optional,state,it,also,consists,of,a,similar,state,without,the,proceed,edge,so,that,for,each,proceed,transition,branches,in,computation,state,graph,can,be,created,only,once,param,ignore,condition,condition,that,should,be,applied,to,ignore,transition,param,sink,state,state,that,the,state,being,converted,should,point,to,return,the,created,state;suppress,warnings,unchecked,private,state,t,create,singleton,state,final,state,t,sink,state,final,iterative,condition,t,ignore,condition,final,boolean,is,optional,final,iterative,condition,t,current,condition,iterative,condition,t,current,pattern,get,condition,final,iterative,condition,t,true,function,boolean,conditions,true,function,final,state,t,singleton,state,create,normal,state,final,state,t,sink,copy,without,transitive,nots,sink,state,singleton,state,add,take,sink,current,condition,if,is,optional,singleton,state,add,proceed,sink,state,true,function,if,ignore,condition,null,final,state,t,ignore,state,if,is,optional,ignore,state,create,normal,state,ignore,state,add,take,sink,current,condition,ignore,state,add,ignore,ignore,condition,add,stop,states,ignore,state,else,ignore,state,singleton,state,singleton,state,add,ignore,ignore,state,ignore,condition,return,singleton,state
NFACompiler -> NFAFactoryCompiler -> @SuppressWarnings("unchecked") 		private State<T> createSingletonState(final State<T> sinkState, final IterativeCondition<T> ignoreCondition, final boolean isOptional);1494947249;Creates a simple single state. For an OPTIONAL state it also consists_of a similar state without the PROCEED edge, so that for each PROCEED transition branches_in computation state graph  can be created only once.__@param ignoreCondition condition that should be applied to IGNORE transition_@param sinkState state that the state being converted should point to_@return the created state;@SuppressWarnings("unchecked")_		private State<T> createSingletonState(final State<T> sinkState, final IterativeCondition<T> ignoreCondition, final boolean isOptional) {_			final IterativeCondition<T> currentCondition = (IterativeCondition<T>) currentPattern.getCondition()__			final IterativeCondition<T> trueFunction = BooleanConditions.trueFunction()___			final State<T> singletonState = createState(currentPattern.getName(), State.StateType.Normal)__			_			final State<T> sink = copyWithoutTransitiveNots(sinkState)__			singletonState.addTake(sink, currentCondition)___			if (isOptional) {_				_				singletonState.addProceed(sinkState, trueFunction)__			}__			if (ignoreCondition != null) {_				final State<T> ignoreState__				if (isOptional) {_					ignoreState = createState(currentPattern.getName(), State.StateType.Normal)__					ignoreState.addTake(sink, currentCondition)__					ignoreState.addIgnore(ignoreCondition)__					addStopStates(ignoreState)__				} else {_					ignoreState = singletonState__				}_				singletonState.addIgnore(ignoreState, ignoreCondition)__			}_			return singletonState__		};creates,a,simple,single,state,for,an,optional,state,it,also,consists,of,a,similar,state,without,the,proceed,edge,so,that,for,each,proceed,transition,branches,in,computation,state,graph,can,be,created,only,once,param,ignore,condition,condition,that,should,be,applied,to,ignore,transition,param,sink,state,state,that,the,state,being,converted,should,point,to,return,the,created,state;suppress,warnings,unchecked,private,state,t,create,singleton,state,final,state,t,sink,state,final,iterative,condition,t,ignore,condition,final,boolean,is,optional,final,iterative,condition,t,current,condition,iterative,condition,t,current,pattern,get,condition,final,iterative,condition,t,true,function,boolean,conditions,true,function,final,state,t,singleton,state,create,state,current,pattern,get,name,state,state,type,normal,final,state,t,sink,copy,without,transitive,nots,sink,state,singleton,state,add,take,sink,current,condition,if,is,optional,singleton,state,add,proceed,sink,state,true,function,if,ignore,condition,null,final,state,t,ignore,state,if,is,optional,ignore,state,create,state,current,pattern,get,name,state,state,type,normal,ignore,state,add,take,sink,current,condition,ignore,state,add,ignore,ignore,condition,add,stop,states,ignore,state,else,ignore,state,singleton,state,singleton,state,add,ignore,ignore,state,ignore,condition,return,singleton,state
NFACompiler -> NFAFactoryCompiler -> @SuppressWarnings("unchecked") 		private State<T> createSingletonState(final State<T> sinkState, final IterativeCondition<T> ignoreCondition, final boolean isOptional);1495657626;Creates a simple single state. For an OPTIONAL state it also consists_of a similar state without the PROCEED edge, so that for each PROCEED transition branches_in computation state graph  can be created only once.__@param ignoreCondition condition that should be applied to IGNORE transition_@param sinkState state that the state being converted should point to_@return the created state;@SuppressWarnings("unchecked")_		private State<T> createSingletonState(final State<T> sinkState, final IterativeCondition<T> ignoreCondition, final boolean isOptional) {_			final IterativeCondition<T> currentCondition = (IterativeCondition<T>) currentPattern.getCondition()__			final IterativeCondition<T> trueFunction = BooleanConditions.trueFunction()___			final State<T> singletonState = createState(currentPattern.getName(), State.StateType.Normal)__			_			final State<T> sink = copyWithoutTransitiveNots(sinkState)__			singletonState.addTake(sink, currentCondition)___			if (isOptional) {_				_				singletonState.addProceed(sinkState, trueFunction)__			}__			if (ignoreCondition != null) {_				final State<T> ignoreState__				if (isOptional) {_					ignoreState = createState(currentPattern.getName(), State.StateType.Normal)__					ignoreState.addTake(sink, currentCondition)__					ignoreState.addIgnore(ignoreCondition)__					addStopStates(ignoreState)__				} else {_					ignoreState = singletonState__				}_				singletonState.addIgnore(ignoreState, ignoreCondition)__			}_			return singletonState__		};creates,a,simple,single,state,for,an,optional,state,it,also,consists,of,a,similar,state,without,the,proceed,edge,so,that,for,each,proceed,transition,branches,in,computation,state,graph,can,be,created,only,once,param,ignore,condition,condition,that,should,be,applied,to,ignore,transition,param,sink,state,state,that,the,state,being,converted,should,point,to,return,the,created,state;suppress,warnings,unchecked,private,state,t,create,singleton,state,final,state,t,sink,state,final,iterative,condition,t,ignore,condition,final,boolean,is,optional,final,iterative,condition,t,current,condition,iterative,condition,t,current,pattern,get,condition,final,iterative,condition,t,true,function,boolean,conditions,true,function,final,state,t,singleton,state,create,state,current,pattern,get,name,state,state,type,normal,final,state,t,sink,copy,without,transitive,nots,sink,state,singleton,state,add,take,sink,current,condition,if,is,optional,singleton,state,add,proceed,sink,state,true,function,if,ignore,condition,null,final,state,t,ignore,state,if,is,optional,ignore,state,create,state,current,pattern,get,name,state,state,type,normal,ignore,state,add,take,sink,current,condition,ignore,state,add,ignore,ignore,condition,add,stop,states,ignore,state,else,ignore,state,singleton,state,singleton,state,add,ignore,ignore,state,ignore,condition,return,singleton,state
NFACompiler -> NFAFactoryCompiler -> @SuppressWarnings("unchecked") 		private State<T> createSingletonState(final State<T> sinkState, final IterativeCondition<T> ignoreCondition, final boolean isOptional);1496245714;Creates a simple single state. For an OPTIONAL state it also consists_of a similar state without the PROCEED edge, so that for each PROCEED transition branches_in computation state graph  can be created only once.__@param ignoreCondition condition that should be applied to IGNORE transition_@param sinkState state that the state being converted should point to_@return the created state;@SuppressWarnings("unchecked")_		private State<T> createSingletonState(final State<T> sinkState, final IterativeCondition<T> ignoreCondition, final boolean isOptional) {_			final IterativeCondition<T> currentCondition = (IterativeCondition<T>) currentPattern.getCondition()__			final IterativeCondition<T> trueFunction = BooleanConditions.trueFunction()___			final State<T> singletonState = createState(currentPattern.getName(), State.StateType.Normal)__			_			final State<T> sink = copyWithoutTransitiveNots(sinkState)__			singletonState.addTake(sink, currentCondition)___			if (isOptional) {_				_				singletonState.addProceed(sinkState, trueFunction)__			}__			if (ignoreCondition != null) {_				final State<T> ignoreState__				if (isOptional) {_					ignoreState = createState(currentPattern.getName(), State.StateType.Normal)__					ignoreState.addTake(sink, currentCondition)__					ignoreState.addIgnore(ignoreCondition)__					addStopStates(ignoreState)__				} else {_					ignoreState = singletonState__				}_				singletonState.addIgnore(ignoreState, ignoreCondition)__			}_			return singletonState__		};creates,a,simple,single,state,for,an,optional,state,it,also,consists,of,a,similar,state,without,the,proceed,edge,so,that,for,each,proceed,transition,branches,in,computation,state,graph,can,be,created,only,once,param,ignore,condition,condition,that,should,be,applied,to,ignore,transition,param,sink,state,state,that,the,state,being,converted,should,point,to,return,the,created,state;suppress,warnings,unchecked,private,state,t,create,singleton,state,final,state,t,sink,state,final,iterative,condition,t,ignore,condition,final,boolean,is,optional,final,iterative,condition,t,current,condition,iterative,condition,t,current,pattern,get,condition,final,iterative,condition,t,true,function,boolean,conditions,true,function,final,state,t,singleton,state,create,state,current,pattern,get,name,state,state,type,normal,final,state,t,sink,copy,without,transitive,nots,sink,state,singleton,state,add,take,sink,current,condition,if,is,optional,singleton,state,add,proceed,sink,state,true,function,if,ignore,condition,null,final,state,t,ignore,state,if,is,optional,ignore,state,create,state,current,pattern,get,name,state,state,type,normal,ignore,state,add,take,sink,current,condition,ignore,state,add,ignore,ignore,condition,add,stop,states,ignore,state,else,ignore,state,singleton,state,singleton,state,add,ignore,ignore,state,ignore,condition,return,singleton,state
NFACompiler -> NFAFactoryCompiler -> private State<T> createLoopingGroupPatternState( 			final GroupPattern<T, ?> groupPattern, 			final State<T> sinkState);1498034481;Create the states for the group pattern as a looping one.__@param groupPattern the group pattern to create the states for_@param sinkState the state that the group pattern being converted should point to_@return the first state of the states of the group pattern;private State<T> createLoopingGroupPatternState(_			final GroupPattern<T, ?> groupPattern,_			final State<T> sinkState) {_			final IterativeCondition<T> trueFunction = getTrueFunction()___			Pattern<T, ?> oldCurrentPattern = currentPattern__			Pattern<T, ?> oldFollowingPattern = followingPattern__			GroupPattern<T, ?> oldGroupPattern = currentGroupPattern__			final State<T> dummyState = createState(currentPattern.getName(), State.StateType.Normal)__			State<T> lastSink = dummyState__			currentGroupPattern = groupPattern__			currentPattern = groupPattern.getRawPattern()__			lastSink = createMiddleStates(lastSink)__			lastSink = convertPattern(lastSink)__			lastSink.addProceed(sinkState, trueFunction)__			dummyState.addProceed(lastSink, trueFunction)__			currentPattern = oldCurrentPattern__			followingPattern = oldFollowingPattern__			currentGroupPattern = oldGroupPattern__			return lastSink__		};create,the,states,for,the,group,pattern,as,a,looping,one,param,group,pattern,the,group,pattern,to,create,the,states,for,param,sink,state,the,state,that,the,group,pattern,being,converted,should,point,to,return,the,first,state,of,the,states,of,the,group,pattern;private,state,t,create,looping,group,pattern,state,final,group,pattern,t,group,pattern,final,state,t,sink,state,final,iterative,condition,t,true,function,get,true,function,pattern,t,old,current,pattern,current,pattern,pattern,t,old,following,pattern,following,pattern,group,pattern,t,old,group,pattern,current,group,pattern,final,state,t,dummy,state,create,state,current,pattern,get,name,state,state,type,normal,state,t,last,sink,dummy,state,current,group,pattern,group,pattern,current,pattern,group,pattern,get,raw,pattern,last,sink,create,middle,states,last,sink,last,sink,convert,pattern,last,sink,last,sink,add,proceed,sink,state,true,function,dummy,state,add,proceed,last,sink,true,function,current,pattern,old,current,pattern,following,pattern,old,following,pattern,current,group,pattern,old,group,pattern,return,last,sink
NFACompiler -> NFAFactoryCompiler -> private State<T> createLoopingGroupPatternState( 			final GroupPattern<T, ?> groupPattern, 			final State<T> sinkState);1499760222;Create the states for the group pattern as a looping one.__@param groupPattern the group pattern to create the states for_@param sinkState the state that the group pattern being converted should point to_@return the first state of the states of the group pattern;private State<T> createLoopingGroupPatternState(_			final GroupPattern<T, ?> groupPattern,_			final State<T> sinkState) {_			final IterativeCondition<T> proceedCondition = getTrueFunction()___			Pattern<T, ?> oldCurrentPattern = currentPattern__			Pattern<T, ?> oldFollowingPattern = followingPattern__			GroupPattern<T, ?> oldGroupPattern = currentGroupPattern___			final State<T> dummyState = createState(currentPattern.getName(), State.StateType.Normal)__			State<T> lastSink = dummyState__			currentGroupPattern = groupPattern__			currentPattern = groupPattern.getRawPattern()__			lastSink = createMiddleStates(lastSink)__			lastSink = convertPattern(lastSink)__			lastSink.addProceed(sinkState, proceedCondition)__			dummyState.addProceed(lastSink, proceedCondition)__			currentPattern = oldCurrentPattern__			followingPattern = oldFollowingPattern__			currentGroupPattern = oldGroupPattern__			return lastSink__		};create,the,states,for,the,group,pattern,as,a,looping,one,param,group,pattern,the,group,pattern,to,create,the,states,for,param,sink,state,the,state,that,the,group,pattern,being,converted,should,point,to,return,the,first,state,of,the,states,of,the,group,pattern;private,state,t,create,looping,group,pattern,state,final,group,pattern,t,group,pattern,final,state,t,sink,state,final,iterative,condition,t,proceed,condition,get,true,function,pattern,t,old,current,pattern,current,pattern,pattern,t,old,following,pattern,following,pattern,group,pattern,t,old,group,pattern,current,group,pattern,final,state,t,dummy,state,create,state,current,pattern,get,name,state,state,type,normal,state,t,last,sink,dummy,state,current,group,pattern,group,pattern,current,pattern,group,pattern,get,raw,pattern,last,sink,create,middle,states,last,sink,last,sink,convert,pattern,last,sink,last,sink,add,proceed,sink,state,proceed,condition,dummy,state,add,proceed,last,sink,proceed,condition,current,pattern,old,current,pattern,following,pattern,old,following,pattern,current,group,pattern,old,group,pattern,return,last,sink
NFACompiler -> NFAFactoryCompiler -> private State<T> createLoopingGroupPatternState( 			final GroupPattern<T, ?> groupPattern, 			final State<T> sinkState);1499937690;Create the states for the group pattern as a looping one.__@param groupPattern the group pattern to create the states for_@param sinkState the state that the group pattern being converted should point to_@return the first state of the states of the group pattern;private State<T> createLoopingGroupPatternState(_			final GroupPattern<T, ?> groupPattern,_			final State<T> sinkState) {_			final IterativeCondition<T> trueFunction = getTrueFunction()___			Pattern<T, ?> oldCurrentPattern = currentPattern__			Pattern<T, ?> oldFollowingPattern = followingPattern__			GroupPattern<T, ?> oldGroupPattern = currentGroupPattern__			final State<T> dummyState = createState(currentPattern.getName(), State.StateType.Normal)__			State<T> lastSink = dummyState__			currentGroupPattern = groupPattern__			currentPattern = groupPattern.getRawPattern()__			lastSink = createMiddleStates(lastSink)__			lastSink = convertPattern(lastSink)__			lastSink.addProceed(sinkState, trueFunction)__			dummyState.addProceed(lastSink, trueFunction)__			currentPattern = oldCurrentPattern__			followingPattern = oldFollowingPattern__			currentGroupPattern = oldGroupPattern__			return lastSink__		};create,the,states,for,the,group,pattern,as,a,looping,one,param,group,pattern,the,group,pattern,to,create,the,states,for,param,sink,state,the,state,that,the,group,pattern,being,converted,should,point,to,return,the,first,state,of,the,states,of,the,group,pattern;private,state,t,create,looping,group,pattern,state,final,group,pattern,t,group,pattern,final,state,t,sink,state,final,iterative,condition,t,true,function,get,true,function,pattern,t,old,current,pattern,current,pattern,pattern,t,old,following,pattern,following,pattern,group,pattern,t,old,group,pattern,current,group,pattern,final,state,t,dummy,state,create,state,current,pattern,get,name,state,state,type,normal,state,t,last,sink,dummy,state,current,group,pattern,group,pattern,current,pattern,group,pattern,get,raw,pattern,last,sink,create,middle,states,last,sink,last,sink,convert,pattern,last,sink,last,sink,add,proceed,sink,state,true,function,dummy,state,add,proceed,last,sink,true,function,current,pattern,old,current,pattern,following,pattern,old,following,pattern,current,group,pattern,old,group,pattern,return,last,sink
NFACompiler -> NFAFactoryCompiler -> private State<T> createLoopingGroupPatternState( 			final GroupPattern<T, ?> groupPattern, 			final State<T> sinkState);1500021711;Create the states for the group pattern as a looping one.__@param groupPattern the group pattern to create the states for_@param sinkState the state that the group pattern being converted should point to_@return the first state of the states of the group pattern;private State<T> createLoopingGroupPatternState(_			final GroupPattern<T, ?> groupPattern,_			final State<T> sinkState) {_			final IterativeCondition<T> proceedCondition = getTrueFunction()___			Pattern<T, ?> oldCurrentPattern = currentPattern__			Pattern<T, ?> oldFollowingPattern = followingPattern__			GroupPattern<T, ?> oldGroupPattern = currentGroupPattern___			final State<T> dummyState = createState(currentPattern.getName(), State.StateType.Normal)__			State<T> lastSink = dummyState__			currentGroupPattern = groupPattern__			currentPattern = groupPattern.getRawPattern()__			lastSink = createMiddleStates(lastSink)__			lastSink = convertPattern(lastSink)__			lastSink.addProceed(sinkState, proceedCondition)__			dummyState.addProceed(lastSink, proceedCondition)__			currentPattern = oldCurrentPattern__			followingPattern = oldFollowingPattern__			currentGroupPattern = oldGroupPattern__			return lastSink__		};create,the,states,for,the,group,pattern,as,a,looping,one,param,group,pattern,the,group,pattern,to,create,the,states,for,param,sink,state,the,state,that,the,group,pattern,being,converted,should,point,to,return,the,first,state,of,the,states,of,the,group,pattern;private,state,t,create,looping,group,pattern,state,final,group,pattern,t,group,pattern,final,state,t,sink,state,final,iterative,condition,t,proceed,condition,get,true,function,pattern,t,old,current,pattern,current,pattern,pattern,t,old,following,pattern,following,pattern,group,pattern,t,old,group,pattern,current,group,pattern,final,state,t,dummy,state,create,state,current,pattern,get,name,state,state,type,normal,state,t,last,sink,dummy,state,current,group,pattern,group,pattern,current,pattern,group,pattern,get,raw,pattern,last,sink,create,middle,states,last,sink,last,sink,convert,pattern,last,sink,last,sink,add,proceed,sink,state,proceed,condition,dummy,state,add,proceed,last,sink,proceed,condition,current,pattern,old,current,pattern,following,pattern,old,following,pattern,current,group,pattern,old,group,pattern,return,last,sink
NFACompiler -> NFAFactoryCompiler -> private State<T> createLoopingGroupPatternState( 			final GroupPattern<T, ?> groupPattern, 			final State<T> sinkState);1501592283;Create the states for the group pattern as a looping one.__@param groupPattern the group pattern to create the states for_@param sinkState the state that the group pattern being converted should point to_@return the first state of the states of the group pattern;private State<T> createLoopingGroupPatternState(_			final GroupPattern<T, ?> groupPattern,_			final State<T> sinkState) {_			final IterativeCondition<T> trueFunction = getTrueFunction()___			Pattern<T, ?> oldCurrentPattern = currentPattern__			Pattern<T, ?> oldFollowingPattern = followingPattern__			GroupPattern<T, ?> oldGroupPattern = currentGroupPattern__			final State<T> dummyState = createState(currentPattern.getName(), State.StateType.Normal)__			State<T> lastSink = dummyState__			currentGroupPattern = groupPattern__			currentPattern = groupPattern.getRawPattern()__			lastSink = createMiddleStates(lastSink)__			lastSink = convertPattern(lastSink)__			lastSink.addProceed(sinkState, trueFunction)__			dummyState.addProceed(lastSink, trueFunction)__			currentPattern = oldCurrentPattern__			followingPattern = oldFollowingPattern__			currentGroupPattern = oldGroupPattern__			return lastSink__		};create,the,states,for,the,group,pattern,as,a,looping,one,param,group,pattern,the,group,pattern,to,create,the,states,for,param,sink,state,the,state,that,the,group,pattern,being,converted,should,point,to,return,the,first,state,of,the,states,of,the,group,pattern;private,state,t,create,looping,group,pattern,state,final,group,pattern,t,group,pattern,final,state,t,sink,state,final,iterative,condition,t,true,function,get,true,function,pattern,t,old,current,pattern,current,pattern,pattern,t,old,following,pattern,following,pattern,group,pattern,t,old,group,pattern,current,group,pattern,final,state,t,dummy,state,create,state,current,pattern,get,name,state,state,type,normal,state,t,last,sink,dummy,state,current,group,pattern,group,pattern,current,pattern,group,pattern,get,raw,pattern,last,sink,create,middle,states,last,sink,last,sink,convert,pattern,last,sink,last,sink,add,proceed,sink,state,true,function,dummy,state,add,proceed,last,sink,true,function,current,pattern,old,current,pattern,following,pattern,old,following,pattern,current,group,pattern,old,group,pattern,return,last,sink
NFACompiler -> NFAFactoryCompiler -> private State<T> createLoopingGroupPatternState( 			final GroupPattern<T, ?> groupPattern, 			final State<T> sinkState);1502422141;Create the states for the group pattern as a looping one.__@param groupPattern the group pattern to create the states for_@param sinkState the state that the group pattern being converted should point to_@return the first state of the states of the group pattern;private State<T> createLoopingGroupPatternState(_			final GroupPattern<T, ?> groupPattern,_			final State<T> sinkState) {_			final IterativeCondition<T> trueFunction = getTrueFunction()___			Pattern<T, ?> oldCurrentPattern = currentPattern__			Pattern<T, ?> oldFollowingPattern = followingPattern__			GroupPattern<T, ?> oldGroupPattern = currentGroupPattern__			final State<T> dummyState = createState(currentPattern.getName(), State.StateType.Normal)__			State<T> lastSink = dummyState__			currentGroupPattern = groupPattern__			currentPattern = groupPattern.getRawPattern()__			lastSink = createMiddleStates(lastSink)__			lastSink = convertPattern(lastSink)__			lastSink.addProceed(sinkState, trueFunction)__			dummyState.addProceed(lastSink, trueFunction)__			currentPattern = oldCurrentPattern__			followingPattern = oldFollowingPattern__			currentGroupPattern = oldGroupPattern__			return lastSink__		};create,the,states,for,the,group,pattern,as,a,looping,one,param,group,pattern,the,group,pattern,to,create,the,states,for,param,sink,state,the,state,that,the,group,pattern,being,converted,should,point,to,return,the,first,state,of,the,states,of,the,group,pattern;private,state,t,create,looping,group,pattern,state,final,group,pattern,t,group,pattern,final,state,t,sink,state,final,iterative,condition,t,true,function,get,true,function,pattern,t,old,current,pattern,current,pattern,pattern,t,old,following,pattern,following,pattern,group,pattern,t,old,group,pattern,current,group,pattern,final,state,t,dummy,state,create,state,current,pattern,get,name,state,state,type,normal,state,t,last,sink,dummy,state,current,group,pattern,group,pattern,current,pattern,group,pattern,get,raw,pattern,last,sink,create,middle,states,last,sink,last,sink,convert,pattern,last,sink,last,sink,add,proceed,sink,state,true,function,dummy,state,add,proceed,last,sink,true,function,current,pattern,old,current,pattern,following,pattern,old,following,pattern,current,group,pattern,old,group,pattern,return,last,sink
NFACompiler -> NFAFactoryCompiler -> private State<T> createLoopingGroupPatternState( 			final GroupPattern<T, ?> groupPattern, 			final State<T> sinkState);1503588494;Create the states for the group pattern as a looping one.__@param groupPattern the group pattern to create the states for_@param sinkState the state that the group pattern being converted should point to_@return the first state of the states of the group pattern;private State<T> createLoopingGroupPatternState(_			final GroupPattern<T, ?> groupPattern,_			final State<T> sinkState) {_			final IterativeCondition<T> proceedCondition = getTrueFunction()___			Pattern<T, ?> oldCurrentPattern = currentPattern__			Pattern<T, ?> oldFollowingPattern = followingPattern__			GroupPattern<T, ?> oldGroupPattern = currentGroupPattern___			final State<T> dummyState = createState(currentPattern.getName(), State.StateType.Normal)__			State<T> lastSink = dummyState__			currentGroupPattern = groupPattern__			currentPattern = groupPattern.getRawPattern()__			lastSink = createMiddleStates(lastSink)__			lastSink = convertPattern(lastSink)__			lastSink.addProceed(sinkState, proceedCondition)__			dummyState.addProceed(lastSink, proceedCondition)__			currentPattern = oldCurrentPattern__			followingPattern = oldFollowingPattern__			currentGroupPattern = oldGroupPattern__			return lastSink__		};create,the,states,for,the,group,pattern,as,a,looping,one,param,group,pattern,the,group,pattern,to,create,the,states,for,param,sink,state,the,state,that,the,group,pattern,being,converted,should,point,to,return,the,first,state,of,the,states,of,the,group,pattern;private,state,t,create,looping,group,pattern,state,final,group,pattern,t,group,pattern,final,state,t,sink,state,final,iterative,condition,t,proceed,condition,get,true,function,pattern,t,old,current,pattern,current,pattern,pattern,t,old,following,pattern,following,pattern,group,pattern,t,old,group,pattern,current,group,pattern,final,state,t,dummy,state,create,state,current,pattern,get,name,state,state,type,normal,state,t,last,sink,dummy,state,current,group,pattern,group,pattern,current,pattern,group,pattern,get,raw,pattern,last,sink,create,middle,states,last,sink,last,sink,convert,pattern,last,sink,last,sink,add,proceed,sink,state,proceed,condition,dummy,state,add,proceed,last,sink,proceed,condition,current,pattern,old,current,pattern,following,pattern,old,following,pattern,current,group,pattern,old,group,pattern,return,last,sink
NFACompiler -> NFAFactoryCompiler -> private State<T> createLoopingGroupPatternState( 			final GroupPattern<T, ?> groupPattern, 			final State<T> sinkState);1518008111;Create the states for the group pattern as a looping one.__@param groupPattern the group pattern to create the states for_@param sinkState the state that the group pattern being converted should point to_@return the first state of the states of the group pattern;private State<T> createLoopingGroupPatternState(_			final GroupPattern<T, ?> groupPattern,_			final State<T> sinkState) {_			final IterativeCondition<T> proceedCondition = getTrueFunction()___			Pattern<T, ?> oldCurrentPattern = currentPattern__			Pattern<T, ?> oldFollowingPattern = followingPattern__			GroupPattern<T, ?> oldGroupPattern = currentGroupPattern___			final State<T> dummyState = createState(currentPattern.getName(), State.StateType.Normal)__			State<T> lastSink = dummyState__			currentGroupPattern = groupPattern__			currentPattern = groupPattern.getRawPattern()__			lastSink = createMiddleStates(lastSink)__			lastSink = convertPattern(lastSink)__			lastSink.addProceed(sinkState, proceedCondition)__			dummyState.addProceed(lastSink, proceedCondition)__			currentPattern = oldCurrentPattern__			followingPattern = oldFollowingPattern__			currentGroupPattern = oldGroupPattern__			return lastSink__		};create,the,states,for,the,group,pattern,as,a,looping,one,param,group,pattern,the,group,pattern,to,create,the,states,for,param,sink,state,the,state,that,the,group,pattern,being,converted,should,point,to,return,the,first,state,of,the,states,of,the,group,pattern;private,state,t,create,looping,group,pattern,state,final,group,pattern,t,group,pattern,final,state,t,sink,state,final,iterative,condition,t,proceed,condition,get,true,function,pattern,t,old,current,pattern,current,pattern,pattern,t,old,following,pattern,following,pattern,group,pattern,t,old,group,pattern,current,group,pattern,final,state,t,dummy,state,create,state,current,pattern,get,name,state,state,type,normal,state,t,last,sink,dummy,state,current,group,pattern,group,pattern,current,pattern,group,pattern,get,raw,pattern,last,sink,create,middle,states,last,sink,last,sink,convert,pattern,last,sink,last,sink,add,proceed,sink,state,proceed,condition,dummy,state,add,proceed,last,sink,proceed,condition,current,pattern,old,current,pattern,following,pattern,old,following,pattern,current,group,pattern,old,group,pattern,return,last,sink
NFACompiler -> NFAFactoryCompiler -> private State<T> createLoopingGroupPatternState( 			final GroupPattern<T, ?> groupPattern, 			final State<T> sinkState);1527863170;Create the states for the group pattern as a looping one.__@param groupPattern the group pattern to create the states for_@param sinkState the state that the group pattern being converted should point to_@return the first state of the states of the group pattern;private State<T> createLoopingGroupPatternState(_			final GroupPattern<T, ?> groupPattern,_			final State<T> sinkState) {_			final IterativeCondition<T> proceedCondition = getTrueFunction()___			Pattern<T, ?> oldCurrentPattern = currentPattern__			Pattern<T, ?> oldFollowingPattern = followingPattern__			GroupPattern<T, ?> oldGroupPattern = currentGroupPattern___			final State<T> dummyState = createState(currentPattern.getName(), State.StateType.Normal)__			State<T> lastSink = dummyState__			currentGroupPattern = groupPattern__			currentPattern = groupPattern.getRawPattern()__			lastSink = createMiddleStates(lastSink)__			lastSink = convertPattern(lastSink)__			lastSink.addProceed(sinkState, proceedCondition)__			dummyState.addProceed(lastSink, proceedCondition)__			currentPattern = oldCurrentPattern__			followingPattern = oldFollowingPattern__			currentGroupPattern = oldGroupPattern__			return lastSink__		};create,the,states,for,the,group,pattern,as,a,looping,one,param,group,pattern,the,group,pattern,to,create,the,states,for,param,sink,state,the,state,that,the,group,pattern,being,converted,should,point,to,return,the,first,state,of,the,states,of,the,group,pattern;private,state,t,create,looping,group,pattern,state,final,group,pattern,t,group,pattern,final,state,t,sink,state,final,iterative,condition,t,proceed,condition,get,true,function,pattern,t,old,current,pattern,current,pattern,pattern,t,old,following,pattern,following,pattern,group,pattern,t,old,group,pattern,current,group,pattern,final,state,t,dummy,state,create,state,current,pattern,get,name,state,state,type,normal,state,t,last,sink,dummy,state,current,group,pattern,group,pattern,current,pattern,group,pattern,get,raw,pattern,last,sink,create,middle,states,last,sink,last,sink,convert,pattern,last,sink,last,sink,add,proceed,sink,state,proceed,condition,dummy,state,add,proceed,last,sink,proceed,condition,current,pattern,old,current,pattern,following,pattern,old,following,pattern,current,group,pattern,old,group,pattern,return,last,sink
NFACompiler -> NFAFactoryCompiler -> private State<T> createLoopingGroupPatternState( 			final GroupPattern<T, ?> groupPattern, 			final State<T> sinkState);1528989005;Create the states for the group pattern as a looping one.__@param groupPattern the group pattern to create the states for_@param sinkState the state that the group pattern being converted should point to_@return the first state of the states of the group pattern;private State<T> createLoopingGroupPatternState(_			final GroupPattern<T, ?> groupPattern,_			final State<T> sinkState) {_			final IterativeCondition<T> proceedCondition = getTrueFunction()___			Pattern<T, ?> oldCurrentPattern = currentPattern__			Pattern<T, ?> oldFollowingPattern = followingPattern__			GroupPattern<T, ?> oldGroupPattern = currentGroupPattern___			final State<T> dummyState = createState(currentPattern.getName(), State.StateType.Normal)__			State<T> lastSink = dummyState__			currentGroupPattern = groupPattern__			currentPattern = groupPattern.getRawPattern()__			lastSink = createMiddleStates(lastSink)__			lastSink = convertPattern(lastSink)__			lastSink.addProceed(sinkState, proceedCondition)__			dummyState.addProceed(lastSink, proceedCondition)__			currentPattern = oldCurrentPattern__			followingPattern = oldFollowingPattern__			currentGroupPattern = oldGroupPattern__			return lastSink__		};create,the,states,for,the,group,pattern,as,a,looping,one,param,group,pattern,the,group,pattern,to,create,the,states,for,param,sink,state,the,state,that,the,group,pattern,being,converted,should,point,to,return,the,first,state,of,the,states,of,the,group,pattern;private,state,t,create,looping,group,pattern,state,final,group,pattern,t,group,pattern,final,state,t,sink,state,final,iterative,condition,t,proceed,condition,get,true,function,pattern,t,old,current,pattern,current,pattern,pattern,t,old,following,pattern,following,pattern,group,pattern,t,old,group,pattern,current,group,pattern,final,state,t,dummy,state,create,state,current,pattern,get,name,state,state,type,normal,state,t,last,sink,dummy,state,current,group,pattern,group,pattern,current,pattern,group,pattern,get,raw,pattern,last,sink,create,middle,states,last,sink,last,sink,convert,pattern,last,sink,last,sink,add,proceed,sink,state,proceed,condition,dummy,state,add,proceed,last,sink,proceed,condition,current,pattern,old,current,pattern,following,pattern,old,following,pattern,current,group,pattern,old,group,pattern,return,last,sink
NFACompiler -> NFAFactoryCompiler -> private State<T> createLoopingGroupPatternState( 			final GroupPattern<T, ?> groupPattern, 			final State<T> sinkState);1538745898;Create the states for the group pattern as a looping one.__@param groupPattern the group pattern to create the states for_@param sinkState the state that the group pattern being converted should point to_@return the first state of the states of the group pattern;private State<T> createLoopingGroupPatternState(_			final GroupPattern<T, ?> groupPattern,_			final State<T> sinkState) {_			final IterativeCondition<T> proceedCondition = getTrueFunction()___			Pattern<T, ?> oldCurrentPattern = currentPattern__			Pattern<T, ?> oldFollowingPattern = followingPattern__			GroupPattern<T, ?> oldGroupPattern = currentGroupPattern___			final State<T> dummyState = createState(currentPattern.getName(), State.StateType.Normal)__			State<T> lastSink = dummyState__			currentGroupPattern = groupPattern__			currentPattern = groupPattern.getRawPattern()__			lastSink = createMiddleStates(lastSink)__			lastSink = convertPattern(lastSink)__			lastSink.addProceed(sinkState, proceedCondition)__			dummyState.addProceed(lastSink, proceedCondition)__			currentPattern = oldCurrentPattern__			followingPattern = oldFollowingPattern__			currentGroupPattern = oldGroupPattern__			return lastSink__		};create,the,states,for,the,group,pattern,as,a,looping,one,param,group,pattern,the,group,pattern,to,create,the,states,for,param,sink,state,the,state,that,the,group,pattern,being,converted,should,point,to,return,the,first,state,of,the,states,of,the,group,pattern;private,state,t,create,looping,group,pattern,state,final,group,pattern,t,group,pattern,final,state,t,sink,state,final,iterative,condition,t,proceed,condition,get,true,function,pattern,t,old,current,pattern,current,pattern,pattern,t,old,following,pattern,following,pattern,group,pattern,t,old,group,pattern,current,group,pattern,final,state,t,dummy,state,create,state,current,pattern,get,name,state,state,type,normal,state,t,last,sink,dummy,state,current,group,pattern,group,pattern,current,pattern,group,pattern,get,raw,pattern,last,sink,create,middle,states,last,sink,last,sink,convert,pattern,last,sink,last,sink,add,proceed,sink,state,proceed,condition,dummy,state,add,proceed,last,sink,proceed,condition,current,pattern,old,current,pattern,following,pattern,old,following,pattern,current,group,pattern,old,group,pattern,return,last,sink
NFACompiler -> NFAFactoryCompiler -> private State<T> createLoopingGroupPatternState( 			final GroupPattern<T, ?> groupPattern, 			final State<T> sinkState);1542293931;Create the states for the group pattern as a looping one.__@param groupPattern the group pattern to create the states for_@param sinkState the state that the group pattern being converted should point to_@return the first state of the states of the group pattern;private State<T> createLoopingGroupPatternState(_			final GroupPattern<T, ?> groupPattern,_			final State<T> sinkState) {_			final IterativeCondition<T> proceedCondition = getTrueFunction()___			Pattern<T, ?> oldCurrentPattern = currentPattern__			Pattern<T, ?> oldFollowingPattern = followingPattern__			GroupPattern<T, ?> oldGroupPattern = currentGroupPattern___			final State<T> dummyState = createState(currentPattern.getName(), State.StateType.Normal)__			State<T> lastSink = dummyState__			currentGroupPattern = groupPattern__			currentPattern = groupPattern.getRawPattern()__			lastSink = createMiddleStates(lastSink)__			lastSink = convertPattern(lastSink)__			lastSink.addProceed(sinkState, proceedCondition)__			dummyState.addProceed(lastSink, proceedCondition)__			currentPattern = oldCurrentPattern__			followingPattern = oldFollowingPattern__			currentGroupPattern = oldGroupPattern__			return lastSink__		};create,the,states,for,the,group,pattern,as,a,looping,one,param,group,pattern,the,group,pattern,to,create,the,states,for,param,sink,state,the,state,that,the,group,pattern,being,converted,should,point,to,return,the,first,state,of,the,states,of,the,group,pattern;private,state,t,create,looping,group,pattern,state,final,group,pattern,t,group,pattern,final,state,t,sink,state,final,iterative,condition,t,proceed,condition,get,true,function,pattern,t,old,current,pattern,current,pattern,pattern,t,old,following,pattern,following,pattern,group,pattern,t,old,group,pattern,current,group,pattern,final,state,t,dummy,state,create,state,current,pattern,get,name,state,state,type,normal,state,t,last,sink,dummy,state,current,group,pattern,group,pattern,current,pattern,group,pattern,get,raw,pattern,last,sink,create,middle,states,last,sink,last,sink,convert,pattern,last,sink,last,sink,add,proceed,sink,state,proceed,condition,dummy,state,add,proceed,last,sink,proceed,condition,current,pattern,old,current,pattern,following,pattern,old,following,pattern,current,group,pattern,old,group,pattern,return,last,sink
NFACompiler -> NFAFactoryCompiler -> @SuppressWarnings("unchecked") 		private State<T> createSingletonState(final State<T> sinkState, 			final State<T> proceedState, 			final IterativeCondition<T> ignoreCondition, 			final boolean isOptional);1497410381;Creates a simple single state. For an OPTIONAL state it also consists_of a similar state without the PROCEED edge, so that for each PROCEED transition branches_in computation state graph  can be created only once.__@param ignoreCondition condition that should be applied to IGNORE transition_@param sinkState state that the state being converted should point to_@param proceedState state that the state being converted should proceed to_@param isOptional whether the state being converted is optional_@return the created state;@SuppressWarnings("unchecked")_		private State<T> createSingletonState(final State<T> sinkState,_			final State<T> proceedState,_			final IterativeCondition<T> ignoreCondition,_			final boolean isOptional) {_			final IterativeCondition<T> currentCondition = (IterativeCondition<T>) currentPattern.getCondition()__			final IterativeCondition<T> trueFunction = BooleanConditions.trueFunction()___			final State<T> singletonState = createState(currentPattern.getName(), State.StateType.Normal)__			_			final State<T> sink = copyWithoutTransitiveNots(sinkState)__			singletonState.addTake(sink, currentCondition)___			if (isOptional) {_				_				singletonState.addProceed(proceedState, trueFunction)__			}__			if (ignoreCondition != null) {_				final State<T> ignoreState__				if (isOptional) {_					ignoreState = createState(currentPattern.getName(), State.StateType.Normal)__					ignoreState.addTake(sink, currentCondition)__					ignoreState.addIgnore(ignoreCondition)__					addStopStates(ignoreState)__				} else {_					ignoreState = singletonState__				}_				singletonState.addIgnore(ignoreState, ignoreCondition)__			}_			return singletonState__		};creates,a,simple,single,state,for,an,optional,state,it,also,consists,of,a,similar,state,without,the,proceed,edge,so,that,for,each,proceed,transition,branches,in,computation,state,graph,can,be,created,only,once,param,ignore,condition,condition,that,should,be,applied,to,ignore,transition,param,sink,state,state,that,the,state,being,converted,should,point,to,param,proceed,state,state,that,the,state,being,converted,should,proceed,to,param,is,optional,whether,the,state,being,converted,is,optional,return,the,created,state;suppress,warnings,unchecked,private,state,t,create,singleton,state,final,state,t,sink,state,final,state,t,proceed,state,final,iterative,condition,t,ignore,condition,final,boolean,is,optional,final,iterative,condition,t,current,condition,iterative,condition,t,current,pattern,get,condition,final,iterative,condition,t,true,function,boolean,conditions,true,function,final,state,t,singleton,state,create,state,current,pattern,get,name,state,state,type,normal,final,state,t,sink,copy,without,transitive,nots,sink,state,singleton,state,add,take,sink,current,condition,if,is,optional,singleton,state,add,proceed,proceed,state,true,function,if,ignore,condition,null,final,state,t,ignore,state,if,is,optional,ignore,state,create,state,current,pattern,get,name,state,state,type,normal,ignore,state,add,take,sink,current,condition,ignore,state,add,ignore,ignore,condition,add,stop,states,ignore,state,else,ignore,state,singleton,state,singleton,state,add,ignore,ignore,state,ignore,condition,return,singleton,state
NFACompiler -> NFAFactoryCompiler -> @SuppressWarnings("unchecked") 		private State<T> createSingletonState(final State<T> sinkState, 			final State<T> proceedState, 			final IterativeCondition<T> ignoreCondition, 			final boolean isOptional);1497883202;Creates a simple single state. For an OPTIONAL state it also consists_of a similar state without the PROCEED edge, so that for each PROCEED transition branches_in computation state graph  can be created only once.__@param ignoreCondition condition that should be applied to IGNORE transition_@param sinkState state that the state being converted should point to_@param proceedState state that the state being converted should proceed to_@param isOptional whether the state being converted is optional_@return the created state;@SuppressWarnings("unchecked")_		private State<T> createSingletonState(final State<T> sinkState,_			final State<T> proceedState,_			final IterativeCondition<T> ignoreCondition,_			final boolean isOptional) {_			final IterativeCondition<T> currentCondition = (IterativeCondition<T>) currentPattern.getCondition()__			final IterativeCondition<T> trueFunction = BooleanConditions.trueFunction()___			final State<T> singletonState = createState(currentPattern.getName(), State.StateType.Normal)__			_			final State<T> sink = copyWithoutTransitiveNots(sinkState)__			singletonState.addTake(sink, currentCondition)___			if (isOptional) {_				_				singletonState.addProceed(proceedState, trueFunction)__			}__			if (ignoreCondition != null) {_				final State<T> ignoreState__				if (isOptional) {_					ignoreState = createState(currentPattern.getName(), State.StateType.Normal)__					ignoreState.addTake(sink, currentCondition)__					ignoreState.addIgnore(ignoreCondition)__					addStopStates(ignoreState)__				} else {_					ignoreState = singletonState__				}_				singletonState.addIgnore(ignoreState, ignoreCondition)__			}_			return singletonState__		};creates,a,simple,single,state,for,an,optional,state,it,also,consists,of,a,similar,state,without,the,proceed,edge,so,that,for,each,proceed,transition,branches,in,computation,state,graph,can,be,created,only,once,param,ignore,condition,condition,that,should,be,applied,to,ignore,transition,param,sink,state,state,that,the,state,being,converted,should,point,to,param,proceed,state,state,that,the,state,being,converted,should,proceed,to,param,is,optional,whether,the,state,being,converted,is,optional,return,the,created,state;suppress,warnings,unchecked,private,state,t,create,singleton,state,final,state,t,sink,state,final,state,t,proceed,state,final,iterative,condition,t,ignore,condition,final,boolean,is,optional,final,iterative,condition,t,current,condition,iterative,condition,t,current,pattern,get,condition,final,iterative,condition,t,true,function,boolean,conditions,true,function,final,state,t,singleton,state,create,state,current,pattern,get,name,state,state,type,normal,final,state,t,sink,copy,without,transitive,nots,sink,state,singleton,state,add,take,sink,current,condition,if,is,optional,singleton,state,add,proceed,proceed,state,true,function,if,ignore,condition,null,final,state,t,ignore,state,if,is,optional,ignore,state,create,state,current,pattern,get,name,state,state,type,normal,ignore,state,add,take,sink,current,condition,ignore,state,add,ignore,ignore,condition,add,stop,states,ignore,state,else,ignore,state,singleton,state,singleton,state,add,ignore,ignore,state,ignore,condition,return,singleton,state
NFACompiler -> NFAFactoryCompiler -> private State<T> createTimesState(final State<T> sinkState, int times);1490619911;Creates a "complex" state consisting of given number of states with_same {@link IterativeCondition}__@param sinkState the state that the created state should point to_@param times     number of times the state should be copied_@return the first state of the "complex" state, next state should point to it;private State<T> createTimesState(final State<T> sinkState, int times) {_			State<T> lastSink = sinkState__			for (int i = 0_ i < times - 1_ i++) {_				lastSink = createSingletonState(_					lastSink,_					currentPattern instanceof FollowedByPattern &&_					!currentPattern.getQuantifier().hasProperty(QuantifierProperty.STRICT))__			}_			return createSingletonState(lastSink, currentPattern instanceof FollowedByPattern)__		};creates,a,complex,state,consisting,of,given,number,of,states,with,same,link,iterative,condition,param,sink,state,the,state,that,the,created,state,should,point,to,param,times,number,of,times,the,state,should,be,copied,return,the,first,state,of,the,complex,state,next,state,should,point,to,it;private,state,t,create,times,state,final,state,t,sink,state,int,times,state,t,last,sink,sink,state,for,int,i,0,i,times,1,i,last,sink,create,singleton,state,last,sink,current,pattern,instanceof,followed,by,pattern,current,pattern,get,quantifier,has,property,quantifier,property,strict,return,create,singleton,state,last,sink,current,pattern,instanceof,followed,by,pattern
NFACompiler -> NFAFactoryCompiler -> private State<T> createTimesState(final State<T> sinkState, int times);1491320734;Creates a "complex" state consisting of given number of states with_same {@link IterativeCondition}__@param sinkState the state that the created state should point to_@param times     number of times the state should be copied_@return the first state of the "complex" state, next state should point to it;private State<T> createTimesState(final State<T> sinkState, int times) {_			State<T> lastSink = sinkState__			for (int i = 0_ i < times - 1_ i++) {_				lastSink = createSingletonState(_					lastSink,_					!currentPattern.getQuantifier().hasProperty(QuantifierProperty.CONSECUTIVE),_					false)__			}__			_			if (!currentPattern.getQuantifier().hasProperty(QuantifierProperty.OPTIONAL)) {_				return createSingletonState(lastSink, currentPattern instanceof FollowedByPattern, false)__			}__			final IterativeCondition<T> currentFilterFunction = (IterativeCondition<T>) currentPattern.getCondition()__			final IterativeCondition<T> trueFunction = BooleanConditions.trueFunction()___			final State<T> singletonState = createNormalState()__			singletonState.addTake(lastSink, currentFilterFunction)__			singletonState.addProceed(sinkState, trueFunction)___			if (currentPattern instanceof FollowedByPattern) {_				State<T> ignoreState = createNormalState()__				ignoreState.addTake(lastSink, currentFilterFunction)__				ignoreState.addIgnore(BooleanConditions.<T>trueFunction())__				singletonState.addIgnore(ignoreState, trueFunction)__			}_			return singletonState__		};creates,a,complex,state,consisting,of,given,number,of,states,with,same,link,iterative,condition,param,sink,state,the,state,that,the,created,state,should,point,to,param,times,number,of,times,the,state,should,be,copied,return,the,first,state,of,the,complex,state,next,state,should,point,to,it;private,state,t,create,times,state,final,state,t,sink,state,int,times,state,t,last,sink,sink,state,for,int,i,0,i,times,1,i,last,sink,create,singleton,state,last,sink,current,pattern,get,quantifier,has,property,quantifier,property,consecutive,false,if,current,pattern,get,quantifier,has,property,quantifier,property,optional,return,create,singleton,state,last,sink,current,pattern,instanceof,followed,by,pattern,false,final,iterative,condition,t,current,filter,function,iterative,condition,t,current,pattern,get,condition,final,iterative,condition,t,true,function,boolean,conditions,true,function,final,state,t,singleton,state,create,normal,state,singleton,state,add,take,last,sink,current,filter,function,singleton,state,add,proceed,sink,state,true,function,if,current,pattern,instanceof,followed,by,pattern,state,t,ignore,state,create,normal,state,ignore,state,add,take,last,sink,current,filter,function,ignore,state,add,ignore,boolean,conditions,t,true,function,singleton,state,add,ignore,ignore,state,true,function,return,singleton,state
NFACompiler -> NFAFactoryCompiler -> private State<T> createTimesState(final State<T> sinkState, int times);1491323030;Creates a "complex" state consisting of given number of states with_same {@link IterativeCondition}__@param sinkState the state that the created state should point to_@param times     number of times the state should be copied_@return the first state of the "complex" state, next state should point to it;private State<T> createTimesState(final State<T> sinkState, int times) {_			State<T> lastSink = sinkState__			for (int i = 0_ i < times - 1_ i++) {_				lastSink = createSingletonState(_					lastSink,_					!currentPattern.getQuantifier().hasProperty(QuantifierProperty.STRICT))__			}_			return createSingletonState(lastSink, currentPattern instanceof FollowedByPattern)__		};creates,a,complex,state,consisting,of,given,number,of,states,with,same,link,iterative,condition,param,sink,state,the,state,that,the,created,state,should,point,to,param,times,number,of,times,the,state,should,be,copied,return,the,first,state,of,the,complex,state,next,state,should,point,to,it;private,state,t,create,times,state,final,state,t,sink,state,int,times,state,t,last,sink,sink,state,for,int,i,0,i,times,1,i,last,sink,create,singleton,state,last,sink,current,pattern,get,quantifier,has,property,quantifier,property,strict,return,create,singleton,state,last,sink,current,pattern,instanceof,followed,by,pattern
NFACompiler -> NFAFactoryCompiler -> private State<T> createTimesState(final State<T> sinkState, int times);1491633862;Creates a "complex" state consisting of given number of states with_same {@link IterativeCondition}__@param sinkState the state that the created state should point to_@param times     number of times the state should be copied_@return the first state of the "complex" state, next state should point to it;private State<T> createTimesState(final State<T> sinkState, int times) {_			State<T> lastSink = sinkState__			for (int i = 0_ i < times - 1_ i++) {_				lastSink = createSingletonState(_					lastSink,_					!currentPattern.getQuantifier().hasProperty(QuantifierProperty.STRICT))__			}_			return createSingletonState(lastSink, currentPattern instanceof FollowedByPattern)__		};creates,a,complex,state,consisting,of,given,number,of,states,with,same,link,iterative,condition,param,sink,state,the,state,that,the,created,state,should,point,to,param,times,number,of,times,the,state,should,be,copied,return,the,first,state,of,the,complex,state,next,state,should,point,to,it;private,state,t,create,times,state,final,state,t,sink,state,int,times,state,t,last,sink,sink,state,for,int,i,0,i,times,1,i,last,sink,create,singleton,state,last,sink,current,pattern,get,quantifier,has,property,quantifier,property,strict,return,create,singleton,state,last,sink,current,pattern,instanceof,followed,by,pattern
NFACompiler -> NFAFactoryCompiler -> private State<T> createTimesState(final State<T> sinkState, int times);1492797583;Creates a "complex" state consisting of given number of states with_same {@link IterativeCondition}__@param sinkState the state that the created state should point to_@param times     number of times the state should be copied_@return the first state of the "complex" state, next state should point to it;private State<T> createTimesState(final State<T> sinkState, int times) {_			State<T> lastSink = sinkState__			for (int i = 0_ i < times - 1_ i++) {_				lastSink = createSingletonState(_					lastSink,_					!currentPattern.getQuantifier().hasProperty(QuantifierProperty.CONSECUTIVE),_					false)__			}__			_			if (!currentPattern.getQuantifier().hasProperty(QuantifierProperty.OPTIONAL)) {_				return createSingletonState(lastSink, currentPattern instanceof FollowedByPattern, false)__			}__			final IterativeCondition<T> currentFilterFunction = (IterativeCondition<T>) currentPattern.getCondition()__			final IterativeCondition<T> trueFunction = BooleanConditions.trueFunction()___			final State<T> singletonState = createNormalState()__			singletonState.addTake(lastSink, currentFilterFunction)__			singletonState.addProceed(sinkState, trueFunction)___			if (currentPattern instanceof FollowedByPattern) {_				State<T> ignoreState = createNormalState()__				ignoreState.addTake(lastSink, currentFilterFunction)__				ignoreState.addIgnore(trueFunction)__				singletonState.addIgnore(ignoreState, trueFunction)__			}_			return singletonState__		};creates,a,complex,state,consisting,of,given,number,of,states,with,same,link,iterative,condition,param,sink,state,the,state,that,the,created,state,should,point,to,param,times,number,of,times,the,state,should,be,copied,return,the,first,state,of,the,complex,state,next,state,should,point,to,it;private,state,t,create,times,state,final,state,t,sink,state,int,times,state,t,last,sink,sink,state,for,int,i,0,i,times,1,i,last,sink,create,singleton,state,last,sink,current,pattern,get,quantifier,has,property,quantifier,property,consecutive,false,if,current,pattern,get,quantifier,has,property,quantifier,property,optional,return,create,singleton,state,last,sink,current,pattern,instanceof,followed,by,pattern,false,final,iterative,condition,t,current,filter,function,iterative,condition,t,current,pattern,get,condition,final,iterative,condition,t,true,function,boolean,conditions,true,function,final,state,t,singleton,state,create,normal,state,singleton,state,add,take,last,sink,current,filter,function,singleton,state,add,proceed,sink,state,true,function,if,current,pattern,instanceof,followed,by,pattern,state,t,ignore,state,create,normal,state,ignore,state,add,take,last,sink,current,filter,function,ignore,state,add,ignore,true,function,singleton,state,add,ignore,ignore,state,true,function,return,singleton,state
NFACompiler -> NFAFactoryCompiler -> private State<T> createTimesState(final State<T> sinkState, int times);1493200673;Creates a "complex" state consisting of given number of states with_same {@link IterativeCondition}__@param sinkState the state that the created state should point to_@param times     number of times the state should be copied_@return the first state of the "complex" state, next state should point to it;private State<T> createTimesState(final State<T> sinkState, int times) {_			State<T> lastSink = sinkState__			for (int i = 0_ i < times - 1_ i++) {_				lastSink = createSingletonState(lastSink, getInnerIgnoreCondition(currentPattern), false)__			}__			final IterativeCondition<T> currentFilterFunction = (IterativeCondition<T>) currentPattern.getCondition()__			final IterativeCondition<T> ignoreCondition = getIgnoreCondition(currentPattern)___			_			if (!currentPattern.getQuantifier().hasProperty(Quantifier.QuantifierProperty.OPTIONAL)) {_				return createSingletonState(lastSink, ignoreCondition, false)__			}__			final State<T> singletonState = createNormalState()__			singletonState.addTake(lastSink, currentFilterFunction)__			singletonState.addProceed(sinkState, BooleanConditions.<T>trueFunction())___			if (ignoreCondition != null) {_				State<T> ignoreState = createNormalState()__				ignoreState.addTake(lastSink, currentFilterFunction)__				ignoreState.addIgnore(ignoreCondition)__				singletonState.addIgnore(ignoreState, ignoreCondition)__			}_			return singletonState__		};creates,a,complex,state,consisting,of,given,number,of,states,with,same,link,iterative,condition,param,sink,state,the,state,that,the,created,state,should,point,to,param,times,number,of,times,the,state,should,be,copied,return,the,first,state,of,the,complex,state,next,state,should,point,to,it;private,state,t,create,times,state,final,state,t,sink,state,int,times,state,t,last,sink,sink,state,for,int,i,0,i,times,1,i,last,sink,create,singleton,state,last,sink,get,inner,ignore,condition,current,pattern,false,final,iterative,condition,t,current,filter,function,iterative,condition,t,current,pattern,get,condition,final,iterative,condition,t,ignore,condition,get,ignore,condition,current,pattern,if,current,pattern,get,quantifier,has,property,quantifier,quantifier,property,optional,return,create,singleton,state,last,sink,ignore,condition,false,final,state,t,singleton,state,create,normal,state,singleton,state,add,take,last,sink,current,filter,function,singleton,state,add,proceed,sink,state,boolean,conditions,t,true,function,if,ignore,condition,null,state,t,ignore,state,create,normal,state,ignore,state,add,take,last,sink,current,filter,function,ignore,state,add,ignore,ignore,condition,singleton,state,add,ignore,ignore,state,ignore,condition,return,singleton,state
NFACompiler -> NFAFactoryCompiler -> private State<T> createTimesState(final State<T> sinkState, int times);1493385877;Creates a "complex" state consisting of given number of states with_same {@link IterativeCondition}__@param sinkState the state that the created state should point to_@param times     number of times the state should be copied_@return the first state of the "complex" state, next state should point to it;private State<T> createTimesState(final State<T> sinkState, int times) {_			State<T> lastSink = copyWithoutTransitiveNots(sinkState)__			for (int i = 0_ i < times - 1_ i++) {_				lastSink = createSingletonState(lastSink, getInnerIgnoreCondition(currentPattern), false)__				addStopStateToLooping(lastSink)__			}__			final IterativeCondition<T> currentCondition = (IterativeCondition<T>) currentPattern.getCondition()__			final IterativeCondition<T> ignoreCondition = getIgnoreCondition(currentPattern)___			_			if (!currentPattern.getQuantifier().hasProperty(Quantifier.QuantifierProperty.OPTIONAL)) {_				return createSingletonState(lastSink, ignoreCondition, false)__			}__			final State<T> singletonState = createNormalState()__			singletonState.addTake(lastSink, currentCondition)__			singletonState.addProceed(sinkState, BooleanConditions.<T>trueFunction())___			if (ignoreCondition != null) {_				State<T> ignoreState = createNormalState()__				ignoreState.addTake(lastSink, currentCondition)__				ignoreState.addIgnore(ignoreCondition)__				singletonState.addIgnore(ignoreState, ignoreCondition)__				addStopStates(ignoreState)__			}_			return singletonState__		};creates,a,complex,state,consisting,of,given,number,of,states,with,same,link,iterative,condition,param,sink,state,the,state,that,the,created,state,should,point,to,param,times,number,of,times,the,state,should,be,copied,return,the,first,state,of,the,complex,state,next,state,should,point,to,it;private,state,t,create,times,state,final,state,t,sink,state,int,times,state,t,last,sink,copy,without,transitive,nots,sink,state,for,int,i,0,i,times,1,i,last,sink,create,singleton,state,last,sink,get,inner,ignore,condition,current,pattern,false,add,stop,state,to,looping,last,sink,final,iterative,condition,t,current,condition,iterative,condition,t,current,pattern,get,condition,final,iterative,condition,t,ignore,condition,get,ignore,condition,current,pattern,if,current,pattern,get,quantifier,has,property,quantifier,quantifier,property,optional,return,create,singleton,state,last,sink,ignore,condition,false,final,state,t,singleton,state,create,normal,state,singleton,state,add,take,last,sink,current,condition,singleton,state,add,proceed,sink,state,boolean,conditions,t,true,function,if,ignore,condition,null,state,t,ignore,state,create,normal,state,ignore,state,add,take,last,sink,current,condition,ignore,state,add,ignore,ignore,condition,singleton,state,add,ignore,ignore,state,ignore,condition,add,stop,states,ignore,state,return,singleton,state
NFACompiler -> NFAFactoryCompiler -> private State<T> createTimesState(final State<T> sinkState, int times);1494947249;Creates a "complex" state consisting of given number of states with_same {@link IterativeCondition}__@param sinkState the state that the created state should point to_@param times     number of times the state should be copied_@return the first state of the "complex" state, next state should point to it;private State<T> createTimesState(final State<T> sinkState, int times) {_			State<T> lastSink = copyWithoutTransitiveNots(sinkState)__			for (int i = 0_ i < times - 1_ i++) {_				lastSink = createSingletonState(lastSink, getInnerIgnoreCondition(currentPattern), false)__				addStopStateToLooping(lastSink)__			}__			final IterativeCondition<T> currentCondition = (IterativeCondition<T>) currentPattern.getCondition()__			final IterativeCondition<T> ignoreCondition = getIgnoreCondition(currentPattern)___			_			if (!currentPattern.getQuantifier().hasProperty(Quantifier.QuantifierProperty.OPTIONAL)) {_				return createSingletonState(lastSink, ignoreCondition, false)__			}__			final State<T> singletonState = createState(currentPattern.getName(), State.StateType.Normal)__			singletonState.addTake(lastSink, currentCondition)__			singletonState.addProceed(sinkState, BooleanConditions.<T>trueFunction())___			if (ignoreCondition != null) {_				State<T> ignoreState = createState(currentPattern.getName(), State.StateType.Normal)__				ignoreState.addTake(lastSink, currentCondition)__				ignoreState.addIgnore(ignoreCondition)__				singletonState.addIgnore(ignoreState, ignoreCondition)__				addStopStates(ignoreState)__			}_			return singletonState__		};creates,a,complex,state,consisting,of,given,number,of,states,with,same,link,iterative,condition,param,sink,state,the,state,that,the,created,state,should,point,to,param,times,number,of,times,the,state,should,be,copied,return,the,first,state,of,the,complex,state,next,state,should,point,to,it;private,state,t,create,times,state,final,state,t,sink,state,int,times,state,t,last,sink,copy,without,transitive,nots,sink,state,for,int,i,0,i,times,1,i,last,sink,create,singleton,state,last,sink,get,inner,ignore,condition,current,pattern,false,add,stop,state,to,looping,last,sink,final,iterative,condition,t,current,condition,iterative,condition,t,current,pattern,get,condition,final,iterative,condition,t,ignore,condition,get,ignore,condition,current,pattern,if,current,pattern,get,quantifier,has,property,quantifier,quantifier,property,optional,return,create,singleton,state,last,sink,ignore,condition,false,final,state,t,singleton,state,create,state,current,pattern,get,name,state,state,type,normal,singleton,state,add,take,last,sink,current,condition,singleton,state,add,proceed,sink,state,boolean,conditions,t,true,function,if,ignore,condition,null,state,t,ignore,state,create,state,current,pattern,get,name,state,state,type,normal,ignore,state,add,take,last,sink,current,condition,ignore,state,add,ignore,ignore,condition,singleton,state,add,ignore,ignore,state,ignore,condition,add,stop,states,ignore,state,return,singleton,state
NFACompiler -> NFAFactoryCompiler -> private State<T> createTimesState(final State<T> sinkState, int times);1495657626;Creates a "complex" state consisting of given number of states with_same {@link IterativeCondition}.__@param sinkState the state that the created state should point to_@param times     number of times the state should be copied_@return the first state of the "complex" state, next state should point to it;private State<T> createTimesState(final State<T> sinkState, int times) {_			State<T> lastSink = copyWithoutTransitiveNots(sinkState)__			for (int i = 0_ i < times - 1_ i++) {_				lastSink = createSingletonState(lastSink, getInnerIgnoreCondition(currentPattern), false)__				addStopStateToLooping(lastSink)__			}__			final IterativeCondition<T> currentCondition = (IterativeCondition<T>) currentPattern.getCondition()__			final IterativeCondition<T> ignoreCondition = getIgnoreCondition(currentPattern)___			_			if (!currentPattern.getQuantifier().hasProperty(Quantifier.QuantifierProperty.OPTIONAL)) {_				return createSingletonState(lastSink, ignoreCondition, false)__			}__			final State<T> singletonState = createState(currentPattern.getName(), State.StateType.Normal)__			singletonState.addTake(lastSink, currentCondition)__			singletonState.addProceed(sinkState, BooleanConditions.<T>trueFunction())___			if (ignoreCondition != null) {_				State<T> ignoreState = createState(currentPattern.getName(), State.StateType.Normal)__				ignoreState.addTake(lastSink, currentCondition)__				ignoreState.addIgnore(ignoreCondition)__				singletonState.addIgnore(ignoreState, ignoreCondition)__				addStopStates(ignoreState)__			}_			return singletonState__		};creates,a,complex,state,consisting,of,given,number,of,states,with,same,link,iterative,condition,param,sink,state,the,state,that,the,created,state,should,point,to,param,times,number,of,times,the,state,should,be,copied,return,the,first,state,of,the,complex,state,next,state,should,point,to,it;private,state,t,create,times,state,final,state,t,sink,state,int,times,state,t,last,sink,copy,without,transitive,nots,sink,state,for,int,i,0,i,times,1,i,last,sink,create,singleton,state,last,sink,get,inner,ignore,condition,current,pattern,false,add,stop,state,to,looping,last,sink,final,iterative,condition,t,current,condition,iterative,condition,t,current,pattern,get,condition,final,iterative,condition,t,ignore,condition,get,ignore,condition,current,pattern,if,current,pattern,get,quantifier,has,property,quantifier,quantifier,property,optional,return,create,singleton,state,last,sink,ignore,condition,false,final,state,t,singleton,state,create,state,current,pattern,get,name,state,state,type,normal,singleton,state,add,take,last,sink,current,condition,singleton,state,add,proceed,sink,state,boolean,conditions,t,true,function,if,ignore,condition,null,state,t,ignore,state,create,state,current,pattern,get,name,state,state,type,normal,ignore,state,add,take,last,sink,current,condition,ignore,state,add,ignore,ignore,condition,singleton,state,add,ignore,ignore,state,ignore,condition,add,stop,states,ignore,state,return,singleton,state
NFACompiler -> NFAFactoryCompiler -> private State<T> createTimesState(final State<T> sinkState, int times);1496245714;Creates a "complex" state consisting of given number of states with_same {@link IterativeCondition}.__@param sinkState the state that the created state should point to_@param times     number of times the state should be copied_@return the first state of the "complex" state, next state should point to it;private State<T> createTimesState(final State<T> sinkState, int times) {_			State<T> lastSink = copyWithoutTransitiveNots(sinkState)__			for (int i = 0_ i < times - 1_ i++) {_				lastSink = createSingletonState(lastSink, getInnerIgnoreCondition(currentPattern), false)__				addStopStateToLooping(lastSink)__			}__			final IterativeCondition<T> currentCondition = (IterativeCondition<T>) currentPattern.getCondition()__			final IterativeCondition<T> ignoreCondition = getIgnoreCondition(currentPattern)___			_			if (!currentPattern.getQuantifier().hasProperty(Quantifier.QuantifierProperty.OPTIONAL)) {_				return createSingletonState(lastSink, ignoreCondition, false)__			}__			final State<T> singletonState = createState(currentPattern.getName(), State.StateType.Normal)__			singletonState.addTake(lastSink, currentCondition)__			singletonState.addProceed(sinkState, BooleanConditions.<T>trueFunction())___			if (ignoreCondition != null) {_				State<T> ignoreState = createState(currentPattern.getName(), State.StateType.Normal)__				ignoreState.addTake(lastSink, currentCondition)__				ignoreState.addIgnore(ignoreCondition)__				singletonState.addIgnore(ignoreState, ignoreCondition)__				addStopStates(ignoreState)__			}_			return singletonState__		};creates,a,complex,state,consisting,of,given,number,of,states,with,same,link,iterative,condition,param,sink,state,the,state,that,the,created,state,should,point,to,param,times,number,of,times,the,state,should,be,copied,return,the,first,state,of,the,complex,state,next,state,should,point,to,it;private,state,t,create,times,state,final,state,t,sink,state,int,times,state,t,last,sink,copy,without,transitive,nots,sink,state,for,int,i,0,i,times,1,i,last,sink,create,singleton,state,last,sink,get,inner,ignore,condition,current,pattern,false,add,stop,state,to,looping,last,sink,final,iterative,condition,t,current,condition,iterative,condition,t,current,pattern,get,condition,final,iterative,condition,t,ignore,condition,get,ignore,condition,current,pattern,if,current,pattern,get,quantifier,has,property,quantifier,quantifier,property,optional,return,create,singleton,state,last,sink,ignore,condition,false,final,state,t,singleton,state,create,state,current,pattern,get,name,state,state,type,normal,singleton,state,add,take,last,sink,current,condition,singleton,state,add,proceed,sink,state,boolean,conditions,t,true,function,if,ignore,condition,null,state,t,ignore,state,create,state,current,pattern,get,name,state,state,type,normal,ignore,state,add,take,last,sink,current,condition,ignore,state,add,ignore,ignore,condition,singleton,state,add,ignore,ignore,state,ignore,condition,add,stop,states,ignore,state,return,singleton,state
NFACompiler -> NFAFactoryCompiler -> @SuppressWarnings("unchecked") 		private State<T> createInitOptionalStateOfZeroOrMore(final State<T> loopingState, final State<T> lastSink);1493385877;Creates a pair of states that enables relaxed strictness before a zeroOrMore looping state.__@param loopingState the first state of zeroOrMore complex state_@param lastSink     the state that the looping one points to_@return the newly created state;@SuppressWarnings("unchecked")_		private State<T> createInitOptionalStateOfZeroOrMore(final State<T> loopingState, final State<T> lastSink) {_			final IterativeCondition<T> currentCondition = (IterativeCondition<T>) currentPattern.getCondition()___			final State<T> firstState = createNormalState()__			firstState.addProceed(lastSink, BooleanConditions.<T>trueFunction())__			firstState.addTake(loopingState, currentCondition)___			final IterativeCondition<T> ignoreFunction = getIgnoreCondition(currentPattern)__			if (ignoreFunction != null) {_				final State<T> firstStateWithoutProceed = createNormalState()__				firstState.addIgnore(firstStateWithoutProceed, ignoreFunction)__				firstStateWithoutProceed.addIgnore(ignoreFunction)__				firstStateWithoutProceed.addTake(loopingState, currentCondition)___				addStopStates(firstStateWithoutProceed)__			}_			return firstState__		};creates,a,pair,of,states,that,enables,relaxed,strictness,before,a,zero,or,more,looping,state,param,looping,state,the,first,state,of,zero,or,more,complex,state,param,last,sink,the,state,that,the,looping,one,points,to,return,the,newly,created,state;suppress,warnings,unchecked,private,state,t,create,init,optional,state,of,zero,or,more,final,state,t,looping,state,final,state,t,last,sink,final,iterative,condition,t,current,condition,iterative,condition,t,current,pattern,get,condition,final,state,t,first,state,create,normal,state,first,state,add,proceed,last,sink,boolean,conditions,t,true,function,first,state,add,take,looping,state,current,condition,final,iterative,condition,t,ignore,function,get,ignore,condition,current,pattern,if,ignore,function,null,final,state,t,first,state,without,proceed,create,normal,state,first,state,add,ignore,first,state,without,proceed,ignore,function,first,state,without,proceed,add,ignore,ignore,function,first,state,without,proceed,add,take,looping,state,current,condition,add,stop,states,first,state,without,proceed,return,first,state
NFACompiler -> NFAFactoryCompiler -> @SuppressWarnings("unchecked") 		private State<T> createInitOptionalStateOfZeroOrMore(final State<T> loopingState, final State<T> lastSink);1494947249;Creates a pair of states that enables relaxed strictness before a zeroOrMore looping state.__@param loopingState the first state of zeroOrMore complex state_@param lastSink     the state that the looping one points to_@return the newly created state;@SuppressWarnings("unchecked")_		private State<T> createInitOptionalStateOfZeroOrMore(final State<T> loopingState, final State<T> lastSink) {_			final IterativeCondition<T> currentCondition = (IterativeCondition<T>) currentPattern.getCondition()___			final State<T> firstState = createState(currentPattern.getName(), State.StateType.Normal)__			firstState.addProceed(lastSink, BooleanConditions.<T>trueFunction())__			firstState.addTake(loopingState, currentCondition)___			final IterativeCondition<T> ignoreFunction = getIgnoreCondition(currentPattern)__			if (ignoreFunction != null) {_				final State<T> firstStateWithoutProceed = createState(currentPattern.getName(), State.StateType.Normal)__				firstState.addIgnore(firstStateWithoutProceed, ignoreFunction)__				firstStateWithoutProceed.addIgnore(ignoreFunction)__				firstStateWithoutProceed.addTake(loopingState, currentCondition)___				addStopStates(firstStateWithoutProceed)__			}_			return firstState__		};creates,a,pair,of,states,that,enables,relaxed,strictness,before,a,zero,or,more,looping,state,param,looping,state,the,first,state,of,zero,or,more,complex,state,param,last,sink,the,state,that,the,looping,one,points,to,return,the,newly,created,state;suppress,warnings,unchecked,private,state,t,create,init,optional,state,of,zero,or,more,final,state,t,looping,state,final,state,t,last,sink,final,iterative,condition,t,current,condition,iterative,condition,t,current,pattern,get,condition,final,state,t,first,state,create,state,current,pattern,get,name,state,state,type,normal,first,state,add,proceed,last,sink,boolean,conditions,t,true,function,first,state,add,take,looping,state,current,condition,final,iterative,condition,t,ignore,function,get,ignore,condition,current,pattern,if,ignore,function,null,final,state,t,first,state,without,proceed,create,state,current,pattern,get,name,state,state,type,normal,first,state,add,ignore,first,state,without,proceed,ignore,function,first,state,without,proceed,add,ignore,ignore,function,first,state,without,proceed,add,take,looping,state,current,condition,add,stop,states,first,state,without,proceed,return,first,state
NFACompiler -> NFAFactoryCompiler -> @SuppressWarnings("unchecked") 		private State<T> createInitOptionalStateOfZeroOrMore(final State<T> loopingState, final State<T> lastSink);1495657626;Creates a pair of states that enables relaxed strictness before a zeroOrMore looping state.__@param loopingState the first state of zeroOrMore complex state_@param lastSink     the state that the looping one points to_@return the newly created state;@SuppressWarnings("unchecked")_		private State<T> createInitOptionalStateOfZeroOrMore(final State<T> loopingState, final State<T> lastSink) {_			final IterativeCondition<T> currentCondition = (IterativeCondition<T>) currentPattern.getCondition()___			final State<T> firstState = createState(currentPattern.getName(), State.StateType.Normal)__			firstState.addProceed(lastSink, BooleanConditions.<T>trueFunction())__			firstState.addTake(loopingState, currentCondition)___			final IterativeCondition<T> ignoreFunction = getIgnoreCondition(currentPattern)__			if (ignoreFunction != null) {_				final State<T> firstStateWithoutProceed = createState(currentPattern.getName(), State.StateType.Normal)__				firstState.addIgnore(firstStateWithoutProceed, ignoreFunction)__				firstStateWithoutProceed.addIgnore(ignoreFunction)__				firstStateWithoutProceed.addTake(loopingState, currentCondition)___				addStopStates(firstStateWithoutProceed)__			}_			return firstState__		};creates,a,pair,of,states,that,enables,relaxed,strictness,before,a,zero,or,more,looping,state,param,looping,state,the,first,state,of,zero,or,more,complex,state,param,last,sink,the,state,that,the,looping,one,points,to,return,the,newly,created,state;suppress,warnings,unchecked,private,state,t,create,init,optional,state,of,zero,or,more,final,state,t,looping,state,final,state,t,last,sink,final,iterative,condition,t,current,condition,iterative,condition,t,current,pattern,get,condition,final,state,t,first,state,create,state,current,pattern,get,name,state,state,type,normal,first,state,add,proceed,last,sink,boolean,conditions,t,true,function,first,state,add,take,looping,state,current,condition,final,iterative,condition,t,ignore,function,get,ignore,condition,current,pattern,if,ignore,function,null,final,state,t,first,state,without,proceed,create,state,current,pattern,get,name,state,state,type,normal,first,state,add,ignore,first,state,without,proceed,ignore,function,first,state,without,proceed,add,ignore,ignore,function,first,state,without,proceed,add,take,looping,state,current,condition,add,stop,states,first,state,without,proceed,return,first,state
NFACompiler -> NFAFactoryCompiler -> @SuppressWarnings("unchecked") 		private State<T> createInitOptionalStateOfZeroOrMore(final State<T> loopingState, final State<T> lastSink);1496245714;Creates a pair of states that enables relaxed strictness before a zeroOrMore looping state.__@param loopingState the first state of zeroOrMore complex state_@param lastSink     the state that the looping one points to_@return the newly created state;@SuppressWarnings("unchecked")_		private State<T> createInitOptionalStateOfZeroOrMore(final State<T> loopingState, final State<T> lastSink) {_			final IterativeCondition<T> currentCondition = (IterativeCondition<T>) currentPattern.getCondition()___			final State<T> firstState = createState(currentPattern.getName(), State.StateType.Normal)__			firstState.addProceed(lastSink, BooleanConditions.<T>trueFunction())__			firstState.addTake(loopingState, currentCondition)___			final IterativeCondition<T> ignoreFunction = getIgnoreCondition(currentPattern)__			if (ignoreFunction != null) {_				final State<T> firstStateWithoutProceed = createState(currentPattern.getName(), State.StateType.Normal)__				firstState.addIgnore(firstStateWithoutProceed, ignoreFunction)__				firstStateWithoutProceed.addIgnore(ignoreFunction)__				firstStateWithoutProceed.addTake(loopingState, currentCondition)___				addStopStates(firstStateWithoutProceed)__			}_			return firstState__		};creates,a,pair,of,states,that,enables,relaxed,strictness,before,a,zero,or,more,looping,state,param,looping,state,the,first,state,of,zero,or,more,complex,state,param,last,sink,the,state,that,the,looping,one,points,to,return,the,newly,created,state;suppress,warnings,unchecked,private,state,t,create,init,optional,state,of,zero,or,more,final,state,t,looping,state,final,state,t,last,sink,final,iterative,condition,t,current,condition,iterative,condition,t,current,pattern,get,condition,final,state,t,first,state,create,state,current,pattern,get,name,state,state,type,normal,first,state,add,proceed,last,sink,boolean,conditions,t,true,function,first,state,add,take,looping,state,current,condition,final,iterative,condition,t,ignore,function,get,ignore,condition,current,pattern,if,ignore,function,null,final,state,t,first,state,without,proceed,create,state,current,pattern,get,name,state,state,type,normal,first,state,add,ignore,first,state,without,proceed,ignore,function,first,state,without,proceed,add,ignore,ignore,function,first,state,without,proceed,add,take,looping,state,current,condition,add,stop,states,first,state,without,proceed,return,first,state
NFACompiler -> NFAFactoryCompiler -> @SuppressWarnings("unchecked") 		private State<T> createInitOptionalStateOfZeroOrMore(final State<T> loopingState, final State<T> lastSink);1497410381;Creates a pair of states that enables relaxed strictness before a zeroOrMore looping state.__@param loopingState the first state of zeroOrMore complex state_@param lastSink     the state that the looping one points to_@return the newly created state;@SuppressWarnings("unchecked")_		private State<T> createInitOptionalStateOfZeroOrMore(final State<T> loopingState, final State<T> lastSink) {_			final IterativeCondition<T> currentCondition = (IterativeCondition<T>) currentPattern.getCondition()___			final State<T> firstState = createState(currentPattern.getName(), State.StateType.Normal)__			firstState.addProceed(lastSink, BooleanConditions.<T>trueFunction())__			firstState.addTake(loopingState, currentCondition)___			final IterativeCondition<T> ignoreFunction = getIgnoreCondition(currentPattern)__			if (ignoreFunction != null) {_				final State<T> firstStateWithoutProceed = createState(currentPattern.getName(), State.StateType.Normal)__				firstState.addIgnore(firstStateWithoutProceed, ignoreFunction)__				firstStateWithoutProceed.addIgnore(ignoreFunction)__				firstStateWithoutProceed.addTake(loopingState, currentCondition)___				addStopStates(firstStateWithoutProceed)__			}_			return firstState__		};creates,a,pair,of,states,that,enables,relaxed,strictness,before,a,zero,or,more,looping,state,param,looping,state,the,first,state,of,zero,or,more,complex,state,param,last,sink,the,state,that,the,looping,one,points,to,return,the,newly,created,state;suppress,warnings,unchecked,private,state,t,create,init,optional,state,of,zero,or,more,final,state,t,looping,state,final,state,t,last,sink,final,iterative,condition,t,current,condition,iterative,condition,t,current,pattern,get,condition,final,state,t,first,state,create,state,current,pattern,get,name,state,state,type,normal,first,state,add,proceed,last,sink,boolean,conditions,t,true,function,first,state,add,take,looping,state,current,condition,final,iterative,condition,t,ignore,function,get,ignore,condition,current,pattern,if,ignore,function,null,final,state,t,first,state,without,proceed,create,state,current,pattern,get,name,state,state,type,normal,first,state,add,ignore,first,state,without,proceed,ignore,function,first,state,without,proceed,add,ignore,ignore,function,first,state,without,proceed,add,take,looping,state,current,condition,add,stop,states,first,state,without,proceed,return,first,state
NFACompiler -> NFAFactoryCompiler -> @SuppressWarnings("unchecked") 		private State<T> createInitOptionalStateOfZeroOrMore(final State<T> loopingState, final State<T> lastSink);1497883202;Creates a pair of states that enables relaxed strictness before a zeroOrMore looping state.__@param loopingState the first state of zeroOrMore complex state_@param lastSink     the state that the looping one points to_@return the newly created state;@SuppressWarnings("unchecked")_		private State<T> createInitOptionalStateOfZeroOrMore(final State<T> loopingState, final State<T> lastSink) {_			final IterativeCondition<T> takeCondition = extendWithUntilCondition(_				(IterativeCondition<T>) currentPattern.getCondition(),_				(IterativeCondition<T>) currentPattern.getUntilCondition()_			)___			final State<T> firstState = createState(currentPattern.getName(), State.StateType.Normal)__			firstState.addProceed(lastSink, BooleanConditions.<T>trueFunction())__			firstState.addTake(loopingState, takeCondition)___			final IterativeCondition<T> ignoreFunction = getIgnoreCondition(currentPattern)__			if (ignoreFunction != null) {_				final State<T> firstStateWithoutProceed = createState(currentPattern.getName(), State.StateType.Normal)__				firstState.addIgnore(firstStateWithoutProceed, ignoreFunction)__				firstStateWithoutProceed.addIgnore(ignoreFunction)__				firstStateWithoutProceed.addTake(loopingState, takeCondition)___				addStopStates(firstStateWithoutProceed)__			}_			return firstState__		};creates,a,pair,of,states,that,enables,relaxed,strictness,before,a,zero,or,more,looping,state,param,looping,state,the,first,state,of,zero,or,more,complex,state,param,last,sink,the,state,that,the,looping,one,points,to,return,the,newly,created,state;suppress,warnings,unchecked,private,state,t,create,init,optional,state,of,zero,or,more,final,state,t,looping,state,final,state,t,last,sink,final,iterative,condition,t,take,condition,extend,with,until,condition,iterative,condition,t,current,pattern,get,condition,iterative,condition,t,current,pattern,get,until,condition,final,state,t,first,state,create,state,current,pattern,get,name,state,state,type,normal,first,state,add,proceed,last,sink,boolean,conditions,t,true,function,first,state,add,take,looping,state,take,condition,final,iterative,condition,t,ignore,function,get,ignore,condition,current,pattern,if,ignore,function,null,final,state,t,first,state,without,proceed,create,state,current,pattern,get,name,state,state,type,normal,first,state,add,ignore,first,state,without,proceed,ignore,function,first,state,without,proceed,add,ignore,ignore,function,first,state,without,proceed,add,take,looping,state,take,condition,add,stop,states,first,state,without,proceed,return,first,state
NFACompiler -> NFAFactoryCompiler -> @SuppressWarnings("unchecked") 		private State<T> createInitOptionalStateOfZeroOrMore(final State<T> loopingState, final State<T> lastSink);1498034481;Creates a pair of states that enables relaxed strictness before a zeroOrMore looping state.__@param loopingState the first state of zeroOrMore complex state_@param lastSink     the state that the looping one points to_@return the newly created state;@SuppressWarnings("unchecked")_		private State<T> createInitOptionalStateOfZeroOrMore(final State<T> loopingState, final State<T> lastSink) {_			final IterativeCondition<T> takeCondition = extendWithUntilCondition(_				getTakeCondition(currentPattern),_				(IterativeCondition<T>) currentPattern.getUntilCondition()_			)___			final IterativeCondition<T> ignoreFunction = getIgnoreCondition(currentPattern)___			return createSingletonState(loopingState, lastSink, takeCondition, ignoreFunction, true)__		};creates,a,pair,of,states,that,enables,relaxed,strictness,before,a,zero,or,more,looping,state,param,looping,state,the,first,state,of,zero,or,more,complex,state,param,last,sink,the,state,that,the,looping,one,points,to,return,the,newly,created,state;suppress,warnings,unchecked,private,state,t,create,init,optional,state,of,zero,or,more,final,state,t,looping,state,final,state,t,last,sink,final,iterative,condition,t,take,condition,extend,with,until,condition,get,take,condition,current,pattern,iterative,condition,t,current,pattern,get,until,condition,final,iterative,condition,t,ignore,function,get,ignore,condition,current,pattern,return,create,singleton,state,looping,state,last,sink,take,condition,ignore,function,true
NFACompiler -> NFAFactoryCompiler -> @SuppressWarnings("unchecked") 		private State<T> createInitOptionalStateOfZeroOrMore(final State<T> loopingState, final State<T> lastSink);1499937690;Creates a pair of states that enables relaxed strictness before a zeroOrMore looping state.__@param loopingState the first state of zeroOrMore complex state_@param lastSink     the state that the looping one points to_@return the newly created state;@SuppressWarnings("unchecked")_		private State<T> createInitOptionalStateOfZeroOrMore(final State<T> loopingState, final State<T> lastSink) {_			final IterativeCondition<T> takeCondition = extendWithUntilCondition(_				getTakeCondition(currentPattern),_				(IterativeCondition<T>) currentPattern.getUntilCondition(),_				true_			)___			final IterativeCondition<T> ignoreFunction = getIgnoreCondition(currentPattern)___			return createSingletonState(loopingState, lastSink, takeCondition, ignoreFunction, true)__		};creates,a,pair,of,states,that,enables,relaxed,strictness,before,a,zero,or,more,looping,state,param,looping,state,the,first,state,of,zero,or,more,complex,state,param,last,sink,the,state,that,the,looping,one,points,to,return,the,newly,created,state;suppress,warnings,unchecked,private,state,t,create,init,optional,state,of,zero,or,more,final,state,t,looping,state,final,state,t,last,sink,final,iterative,condition,t,take,condition,extend,with,until,condition,get,take,condition,current,pattern,iterative,condition,t,current,pattern,get,until,condition,true,final,iterative,condition,t,ignore,function,get,ignore,condition,current,pattern,return,create,singleton,state,looping,state,last,sink,take,condition,ignore,function,true
NFACompiler -> NFAFactoryCompiler -> @SuppressWarnings("unchecked") 		private State<T> createInitOptionalStateOfZeroOrMore(final State<T> loopingState, final State<T> lastSink);1501592283;Creates a pair of states that enables relaxed strictness before a zeroOrMore looping state.__@param loopingState the first state of zeroOrMore complex state_@param lastSink     the state that the looping one points to_@return the newly created state;@SuppressWarnings("unchecked")_		private State<T> createInitOptionalStateOfZeroOrMore(final State<T> loopingState, final State<T> lastSink) {_			final IterativeCondition<T> takeCondition = extendWithUntilCondition(_				getTakeCondition(currentPattern),_				(IterativeCondition<T>) currentPattern.getUntilCondition(),_				true_			)___			final IterativeCondition<T> ignoreFunction = getIgnoreCondition(currentPattern)___			return createSingletonState(loopingState, lastSink, takeCondition, ignoreFunction, true)__		};creates,a,pair,of,states,that,enables,relaxed,strictness,before,a,zero,or,more,looping,state,param,looping,state,the,first,state,of,zero,or,more,complex,state,param,last,sink,the,state,that,the,looping,one,points,to,return,the,newly,created,state;suppress,warnings,unchecked,private,state,t,create,init,optional,state,of,zero,or,more,final,state,t,looping,state,final,state,t,last,sink,final,iterative,condition,t,take,condition,extend,with,until,condition,get,take,condition,current,pattern,iterative,condition,t,current,pattern,get,until,condition,true,final,iterative,condition,t,ignore,function,get,ignore,condition,current,pattern,return,create,singleton,state,looping,state,last,sink,take,condition,ignore,function,true
NFACompiler -> NFAFactoryCompiler -> @SuppressWarnings("unchecked") 		private State<T> createStartState(State<T> sinkState);1489866780;Creates the Start {@link State} of the resulting NFA graph._@param sinkState the state that Start state should point to (alwyas first state of middle states)_@return created state;@SuppressWarnings("unchecked")_		private State<T> createStartState(State<T> sinkState) {_			checkPatternNameUniqueness()___			final State<T> beginningState__			if (currentPattern.getQuantifier().hasProperty(QuantifierProperty.LOOPING)) {_				final State<T> loopingState__				if (currentPattern.getQuantifier().hasProperty(QuantifierProperty.AT_LEAST_ONE)) {_					loopingState = new State<>(currentPattern.getName(), State.StateType.Normal)__					beginningState = createFirstMandatoryStateOfLoop(loopingState, State.StateType.Start)__					states.add(loopingState)__				} else {_					loopingState = new State<>(currentPattern.getName(), State.StateType.Start)__					beginningState = loopingState__				}_				convertToLooping(loopingState, sinkState, true)__			} else  {_				if (currentPattern.getQuantifier() == Quantifier.TIMES && currentPattern.getTimes() > 1) {_					final State<T> timesState = new State<>(currentPattern.getName(), State.StateType.Normal)__					states.add(timesState)__					sinkState = convertToTimesState(timesState, sinkState, currentPattern.getTimes() - 1)__				}__				beginningState = new State<>(currentPattern.getName(), State.StateType.Start)__				convertToSingletonState(beginningState, sinkState)__			}__			states.add(beginningState)__			usedNames.add(beginningState.getName())___			return beginningState__		};creates,the,start,link,state,of,the,resulting,nfa,graph,param,sink,state,the,state,that,start,state,should,point,to,alwyas,first,state,of,middle,states,return,created,state;suppress,warnings,unchecked,private,state,t,create,start,state,state,t,sink,state,check,pattern,name,uniqueness,final,state,t,beginning,state,if,current,pattern,get,quantifier,has,property,quantifier,property,looping,final,state,t,looping,state,if,current,pattern,get,quantifier,has,property,quantifier,property,looping,state,new,state,current,pattern,get,name,state,state,type,normal,beginning,state,create,first,mandatory,state,of,loop,looping,state,state,state,type,start,states,add,looping,state,else,looping,state,new,state,current,pattern,get,name,state,state,type,start,beginning,state,looping,state,convert,to,looping,looping,state,sink,state,true,else,if,current,pattern,get,quantifier,quantifier,times,current,pattern,get,times,1,final,state,t,times,state,new,state,current,pattern,get,name,state,state,type,normal,states,add,times,state,sink,state,convert,to,times,state,times,state,sink,state,current,pattern,get,times,1,beginning,state,new,state,current,pattern,get,name,state,state,type,start,convert,to,singleton,state,beginning,state,sink,state,states,add,beginning,state,used,names,add,beginning,state,get,name,return,beginning,state
NFACompiler -> NFAFactoryCompiler -> @SuppressWarnings("unchecked") 		private State<T> createStartState(State<T> sinkState);1490089987;Creates the Start {@link State} of the resulting NFA graph._@param sinkState the state that Start state should point to (alwyas first state of middle states)_@return created state;@SuppressWarnings("unchecked")_		private State<T> createStartState(State<T> sinkState) {_			checkPatternNameUniqueness()___			final State<T> beginningState__			if (currentPattern.getQuantifier().hasProperty(QuantifierProperty.LOOPING)) {_				final State<T> loopingState__				if (currentPattern.getQuantifier().hasProperty(QuantifierProperty.AT_LEAST_ONE)) {_					loopingState = new State<>(currentPattern.getName(), State.StateType.Normal)__					beginningState = createFirstMandatoryStateOfLoop(loopingState, State.StateType.Start)__					states.add(loopingState)__				} else {_					loopingState = new State<>(currentPattern.getName(), State.StateType.Start)__					beginningState = loopingState__				}_				convertToLooping(loopingState, sinkState, true)__			} else  {_				if (currentPattern.getQuantifier() == Quantifier.TIMES && currentPattern.getTimes() > 1) {_					final State<T> timesState = new State<>(currentPattern.getName(), State.StateType.Normal)__					states.add(timesState)__					sinkState = convertToTimesState(timesState, sinkState, currentPattern.getTimes() - 1)__				}__				beginningState = new State<>(currentPattern.getName(), State.StateType.Start)__				convertToSingletonState(beginningState, sinkState)__			}__			states.add(beginningState)__			usedNames.add(beginningState.getName())___			return beginningState__		};creates,the,start,link,state,of,the,resulting,nfa,graph,param,sink,state,the,state,that,start,state,should,point,to,alwyas,first,state,of,middle,states,return,created,state;suppress,warnings,unchecked,private,state,t,create,start,state,state,t,sink,state,check,pattern,name,uniqueness,final,state,t,beginning,state,if,current,pattern,get,quantifier,has,property,quantifier,property,looping,final,state,t,looping,state,if,current,pattern,get,quantifier,has,property,quantifier,property,looping,state,new,state,current,pattern,get,name,state,state,type,normal,beginning,state,create,first,mandatory,state,of,loop,looping,state,state,state,type,start,states,add,looping,state,else,looping,state,new,state,current,pattern,get,name,state,state,type,start,beginning,state,looping,state,convert,to,looping,looping,state,sink,state,true,else,if,current,pattern,get,quantifier,quantifier,times,current,pattern,get,times,1,final,state,t,times,state,new,state,current,pattern,get,name,state,state,type,normal,states,add,times,state,sink,state,convert,to,times,state,times,state,sink,state,current,pattern,get,times,1,beginning,state,new,state,current,pattern,get,name,state,state,type,start,convert,to,singleton,state,beginning,state,sink,state,states,add,beginning,state,used,names,add,beginning,state,get,name,return,beginning,state
NFACompiler -> NFAFactoryCompiler -> @SuppressWarnings("unchecked") 		private State<T> createStartState(State<T> sinkState);1490194327;Creates the Start {@link State} of the resulting NFA graph._@param sinkState the state that Start state should point to (alwyas first state of middle states)_@return created state;@SuppressWarnings("unchecked")_		private State<T> createStartState(State<T> sinkState) {_			checkPatternNameUniqueness()___			final State<T> beginningState__			if (currentPattern.getQuantifier().hasProperty(QuantifierProperty.LOOPING)) {_				final State<T> loopingState__				if (currentPattern.getQuantifier().hasProperty(QuantifierProperty.AT_LEAST_ONE)) {_					loopingState = new State<>(currentPattern.getName(), State.StateType.Normal)__					beginningState = createFirstMandatoryStateOfLoop(loopingState, State.StateType.Start)__					states.add(loopingState)__				} else {_					loopingState = new State<>(currentPattern.getName(), State.StateType.Start)__					beginningState = loopingState__				}_				convertToLooping(loopingState, sinkState, true)__			} else  {_				if (currentPattern.getQuantifier() == Quantifier.TIMES && currentPattern.getTimes() > 1) {_					final State<T> timesState = new State<>(currentPattern.getName(), State.StateType.Normal)__					states.add(timesState)__					sinkState = convertToTimesState(timesState, sinkState, currentPattern.getTimes() - 1)__				}__				beginningState = new State<>(currentPattern.getName(), State.StateType.Start)__				convertToSingletonState(beginningState, sinkState)__			}__			states.add(beginningState)__			usedNames.add(beginningState.getName())___			return beginningState__		};creates,the,start,link,state,of,the,resulting,nfa,graph,param,sink,state,the,state,that,start,state,should,point,to,alwyas,first,state,of,middle,states,return,created,state;suppress,warnings,unchecked,private,state,t,create,start,state,state,t,sink,state,check,pattern,name,uniqueness,final,state,t,beginning,state,if,current,pattern,get,quantifier,has,property,quantifier,property,looping,final,state,t,looping,state,if,current,pattern,get,quantifier,has,property,quantifier,property,looping,state,new,state,current,pattern,get,name,state,state,type,normal,beginning,state,create,first,mandatory,state,of,loop,looping,state,state,state,type,start,states,add,looping,state,else,looping,state,new,state,current,pattern,get,name,state,state,type,start,beginning,state,looping,state,convert,to,looping,looping,state,sink,state,true,else,if,current,pattern,get,quantifier,quantifier,times,current,pattern,get,times,1,final,state,t,times,state,new,state,current,pattern,get,name,state,state,type,normal,states,add,times,state,sink,state,convert,to,times,state,times,state,sink,state,current,pattern,get,times,1,beginning,state,new,state,current,pattern,get,name,state,state,type,start,convert,to,singleton,state,beginning,state,sink,state,states,add,beginning,state,used,names,add,beginning,state,get,name,return,beginning,state
NFACompiler -> NFAFactoryCompiler -> @SuppressWarnings("unchecked") 		private State<T> createStartState(State<T> sinkState);1490619911;Creates the Start {@link State} of the resulting NFA graph.__@param sinkState the state that Start state should point to (alwyas first state of middle states)_@return created state;@SuppressWarnings("unchecked")_		private State<T> createStartState(State<T> sinkState) {_			checkPatternNameUniqueness()__			usedNames.add(currentPattern.getName())___			final State<T> beginningState__			if (currentPattern.getQuantifier().hasProperty(QuantifierProperty.LOOPING)) {_				final State<T> loopingState = createLooping(sinkState)__				if (currentPattern.getQuantifier().hasProperty(QuantifierProperty.AT_LEAST_ONE)) {_					beginningState = createFirstMandatoryStateOfLoop(loopingState)__				} else {_					beginningState = loopingState__				}_			} else if (currentPattern.getQuantifier().hasProperty(QuantifierProperty.TIMES)) {_				beginningState = createTimesState(sinkState, currentPattern.getTimes())__			} else {_				beginningState = createSingletonState(sinkState)__			}__			beginningState.makeStart()___			return beginningState__		};creates,the,start,link,state,of,the,resulting,nfa,graph,param,sink,state,the,state,that,start,state,should,point,to,alwyas,first,state,of,middle,states,return,created,state;suppress,warnings,unchecked,private,state,t,create,start,state,state,t,sink,state,check,pattern,name,uniqueness,used,names,add,current,pattern,get,name,final,state,t,beginning,state,if,current,pattern,get,quantifier,has,property,quantifier,property,looping,final,state,t,looping,state,create,looping,sink,state,if,current,pattern,get,quantifier,has,property,quantifier,property,beginning,state,create,first,mandatory,state,of,loop,looping,state,else,beginning,state,looping,state,else,if,current,pattern,get,quantifier,has,property,quantifier,property,times,beginning,state,create,times,state,sink,state,current,pattern,get,times,else,beginning,state,create,singleton,state,sink,state,beginning,state,make,start,return,beginning,state
NFACompiler -> NFAFactoryCompiler -> @SuppressWarnings("unchecked") 		private State<T> createStartState(State<T> sinkState);1491320734;Creates the Start {@link State} of the resulting NFA graph.__@param sinkState the state that Start state should point to (always first state of middle states)_@return created state;@SuppressWarnings("unchecked")_		private State<T> createStartState(State<T> sinkState) {_			checkPatternNameUniqueness()__			usedNames.add(currentPattern.getName())___			final State<T> beginningState__			if (currentPattern.getQuantifier().hasProperty(QuantifierProperty.LOOPING)) {_				final State<T> loopingState = createLooping(sinkState)__				if (!currentPattern.getQuantifier().hasProperty(QuantifierProperty.OPTIONAL)) {_					beginningState = createFirstMandatoryStateOfLoop(loopingState)__				} else {_					beginningState = loopingState__				}_			} else if (currentPattern.getQuantifier().hasProperty(QuantifierProperty.TIMES)) {_				beginningState = createTimesState(sinkState, currentPattern.getTimes())__			} else {_				beginningState = createSingletonState(sinkState)__			}__			beginningState.makeStart()___			return beginningState__		};creates,the,start,link,state,of,the,resulting,nfa,graph,param,sink,state,the,state,that,start,state,should,point,to,always,first,state,of,middle,states,return,created,state;suppress,warnings,unchecked,private,state,t,create,start,state,state,t,sink,state,check,pattern,name,uniqueness,used,names,add,current,pattern,get,name,final,state,t,beginning,state,if,current,pattern,get,quantifier,has,property,quantifier,property,looping,final,state,t,looping,state,create,looping,sink,state,if,current,pattern,get,quantifier,has,property,quantifier,property,optional,beginning,state,create,first,mandatory,state,of,loop,looping,state,else,beginning,state,looping,state,else,if,current,pattern,get,quantifier,has,property,quantifier,property,times,beginning,state,create,times,state,sink,state,current,pattern,get,times,else,beginning,state,create,singleton,state,sink,state,beginning,state,make,start,return,beginning,state
NFACompiler -> NFAFactoryCompiler -> @SuppressWarnings("unchecked") 		private State<T> createStartState(State<T> sinkState);1491323030;Creates the Start {@link State} of the resulting NFA graph.__@param sinkState the state that Start state should point to (alwyas first state of middle states)_@return created state;@SuppressWarnings("unchecked")_		private State<T> createStartState(State<T> sinkState) {_			checkPatternNameUniqueness()__			usedNames.add(currentPattern.getName())___			final State<T> beginningState__			if (currentPattern.getQuantifier().hasProperty(QuantifierProperty.LOOPING)) {_				final State<T> loopingState = createLooping(sinkState)__				if (currentPattern.getQuantifier().hasProperty(QuantifierProperty.AT_LEAST_ONE)) {_					beginningState = createFirstMandatoryStateOfLoop(loopingState)__				} else {_					beginningState = loopingState__				}_			} else if (currentPattern.getQuantifier().hasProperty(QuantifierProperty.TIMES)) {_				beginningState = createTimesState(sinkState, currentPattern.getTimes())__			} else {_				beginningState = createSingletonState(sinkState)__			}__			beginningState.makeStart()___			return beginningState__		};creates,the,start,link,state,of,the,resulting,nfa,graph,param,sink,state,the,state,that,start,state,should,point,to,alwyas,first,state,of,middle,states,return,created,state;suppress,warnings,unchecked,private,state,t,create,start,state,state,t,sink,state,check,pattern,name,uniqueness,used,names,add,current,pattern,get,name,final,state,t,beginning,state,if,current,pattern,get,quantifier,has,property,quantifier,property,looping,final,state,t,looping,state,create,looping,sink,state,if,current,pattern,get,quantifier,has,property,quantifier,property,beginning,state,create,first,mandatory,state,of,loop,looping,state,else,beginning,state,looping,state,else,if,current,pattern,get,quantifier,has,property,quantifier,property,times,beginning,state,create,times,state,sink,state,current,pattern,get,times,else,beginning,state,create,singleton,state,sink,state,beginning,state,make,start,return,beginning,state
NFACompiler -> NFAFactoryCompiler -> @SuppressWarnings("unchecked") 		private State<T> createStartState(State<T> sinkState);1491633862;Creates the Start {@link State} of the resulting NFA graph.__@param sinkState the state that Start state should point to (always first state of middle states)_@return created state;@SuppressWarnings("unchecked")_		private State<T> createStartState(State<T> sinkState) {_			checkPatternNameUniqueness()__			usedNames.add(currentPattern.getName())___			final State<T> beginningState__			if (currentPattern.getQuantifier().hasProperty(QuantifierProperty.LOOPING)) {_				final State<T> loopingState = createLooping(sinkState)__				if (currentPattern.getQuantifier().hasProperty(QuantifierProperty.AT_LEAST_ONE)) {_					beginningState = createFirstMandatoryStateOfLoop(loopingState)__				} else {_					beginningState = loopingState__				}_			} else if (currentPattern.getQuantifier().hasProperty(QuantifierProperty.TIMES)) {_				beginningState = createTimesState(sinkState, currentPattern.getTimes())__			} else {_				beginningState = createSingletonState(sinkState)__			}__			beginningState.makeStart()___			return beginningState__		};creates,the,start,link,state,of,the,resulting,nfa,graph,param,sink,state,the,state,that,start,state,should,point,to,always,first,state,of,middle,states,return,created,state;suppress,warnings,unchecked,private,state,t,create,start,state,state,t,sink,state,check,pattern,name,uniqueness,used,names,add,current,pattern,get,name,final,state,t,beginning,state,if,current,pattern,get,quantifier,has,property,quantifier,property,looping,final,state,t,looping,state,create,looping,sink,state,if,current,pattern,get,quantifier,has,property,quantifier,property,beginning,state,create,first,mandatory,state,of,loop,looping,state,else,beginning,state,looping,state,else,if,current,pattern,get,quantifier,has,property,quantifier,property,times,beginning,state,create,times,state,sink,state,current,pattern,get,times,else,beginning,state,create,singleton,state,sink,state,beginning,state,make,start,return,beginning,state
NFACompiler -> NFAFactoryCompiler -> @SuppressWarnings("unchecked") 		private State<T> createStartState(State<T> sinkState);1492797583;Creates the Start {@link State} of the resulting NFA graph.__@param sinkState the state that Start state should point to (always first state of middle states)_@return created state;@SuppressWarnings("unchecked")_		private State<T> createStartState(State<T> sinkState) {_			checkPatternNameUniqueness()__			usedNames.add(currentPattern.getName())___			final State<T> beginningState__			if (currentPattern.getQuantifier().hasProperty(QuantifierProperty.LOOPING)) {_				final State<T> loopingState = createLooping(sinkState)__				if (!currentPattern.getQuantifier().hasProperty(QuantifierProperty.OPTIONAL)) {_					beginningState = createFirstMandatoryStateOfLoop(loopingState)__				} else {_					beginningState = loopingState__				}_			} else if (currentPattern.getQuantifier().hasProperty(QuantifierProperty.TIMES)) {_				beginningState = createTimesState(sinkState, currentPattern.getTimes())__			} else {_				beginningState = createSingletonState(sinkState)__			}__			beginningState.makeStart()___			return beginningState__		};creates,the,start,link,state,of,the,resulting,nfa,graph,param,sink,state,the,state,that,start,state,should,point,to,always,first,state,of,middle,states,return,created,state;suppress,warnings,unchecked,private,state,t,create,start,state,state,t,sink,state,check,pattern,name,uniqueness,used,names,add,current,pattern,get,name,final,state,t,beginning,state,if,current,pattern,get,quantifier,has,property,quantifier,property,looping,final,state,t,looping,state,create,looping,sink,state,if,current,pattern,get,quantifier,has,property,quantifier,property,optional,beginning,state,create,first,mandatory,state,of,loop,looping,state,else,beginning,state,looping,state,else,if,current,pattern,get,quantifier,has,property,quantifier,property,times,beginning,state,create,times,state,sink,state,current,pattern,get,times,else,beginning,state,create,singleton,state,sink,state,beginning,state,make,start,return,beginning,state
NFACompiler -> NFAFactoryCompiler -> @SuppressWarnings("unchecked") 		private State<T> createStartState(State<T> sinkState);1493200673;Creates the Start {@link State} of the resulting NFA graph.__@param sinkState the state that Start state should point to (always first state of middle states)_@return created state;@SuppressWarnings("unchecked")_		private State<T> createStartState(State<T> sinkState) {_			final State<T> beginningState = convertPattern(sinkState)__			beginningState.makeStart()___			return beginningState__		};creates,the,start,link,state,of,the,resulting,nfa,graph,param,sink,state,the,state,that,start,state,should,point,to,always,first,state,of,middle,states,return,created,state;suppress,warnings,unchecked,private,state,t,create,start,state,state,t,sink,state,final,state,t,beginning,state,convert,pattern,sink,state,beginning,state,make,start,return,beginning,state
NFACompiler -> NFAFactoryCompiler -> @SuppressWarnings("unchecked") 		private State<T> createStartState(State<T> sinkState);1493385877;Creates the Start {@link State} of the resulting NFA graph.__@param sinkState the state that Start state should point to (always first state of middle states)_@return created state;@SuppressWarnings("unchecked")_		private State<T> createStartState(State<T> sinkState) {_			final State<T> beginningState = convertPattern(sinkState)__			beginningState.makeStart()__			return beginningState__		};creates,the,start,link,state,of,the,resulting,nfa,graph,param,sink,state,the,state,that,start,state,should,point,to,always,first,state,of,middle,states,return,created,state;suppress,warnings,unchecked,private,state,t,create,start,state,state,t,sink,state,final,state,t,beginning,state,convert,pattern,sink,state,beginning,state,make,start,return,beginning,state
NFACompiler -> NFAFactoryCompiler -> @SuppressWarnings("unchecked") 		private State<T> createStartState(State<T> sinkState);1494947249;Creates the Start {@link State} of the resulting NFA graph.__@param sinkState the state that Start state should point to (always first state of middle states)_@return created state;@SuppressWarnings("unchecked")_		private State<T> createStartState(State<T> sinkState) {_			checkPatternNameUniqueness(currentPattern.getName())__			final State<T> beginningState = convertPattern(sinkState)__			beginningState.makeStart()__			return beginningState__		};creates,the,start,link,state,of,the,resulting,nfa,graph,param,sink,state,the,state,that,start,state,should,point,to,always,first,state,of,middle,states,return,created,state;suppress,warnings,unchecked,private,state,t,create,start,state,state,t,sink,state,check,pattern,name,uniqueness,current,pattern,get,name,final,state,t,beginning,state,convert,pattern,sink,state,beginning,state,make,start,return,beginning,state
NFACompiler -> NFAFactoryCompiler -> @SuppressWarnings("unchecked") 		private State<T> createStartState(State<T> sinkState);1495657626;Creates the Start {@link State} of the resulting NFA graph.__@param sinkState the state that Start state should point to (always first state of middle states)_@return created state;@SuppressWarnings("unchecked")_		private State<T> createStartState(State<T> sinkState) {_			checkPatternNameUniqueness(currentPattern.getName())__			final State<T> beginningState = convertPattern(sinkState)__			beginningState.makeStart()__			return beginningState__		};creates,the,start,link,state,of,the,resulting,nfa,graph,param,sink,state,the,state,that,start,state,should,point,to,always,first,state,of,middle,states,return,created,state;suppress,warnings,unchecked,private,state,t,create,start,state,state,t,sink,state,check,pattern,name,uniqueness,current,pattern,get,name,final,state,t,beginning,state,convert,pattern,sink,state,beginning,state,make,start,return,beginning,state
NFACompiler -> NFAFactoryCompiler -> @SuppressWarnings("unchecked") 		private State<T> createStartState(State<T> sinkState);1496245714;Creates the Start {@link State} of the resulting NFA graph.__@param sinkState the state that Start state should point to (always first state of middle states)_@return created state;@SuppressWarnings("unchecked")_		private State<T> createStartState(State<T> sinkState) {_			stateNameHandler.checkNameUniqueness(currentPattern.getName())__			final State<T> beginningState = convertPattern(sinkState)__			beginningState.makeStart()__			return beginningState__		};creates,the,start,link,state,of,the,resulting,nfa,graph,param,sink,state,the,state,that,start,state,should,point,to,always,first,state,of,middle,states,return,created,state;suppress,warnings,unchecked,private,state,t,create,start,state,state,t,sink,state,state,name,handler,check,name,uniqueness,current,pattern,get,name,final,state,t,beginning,state,convert,pattern,sink,state,beginning,state,make,start,return,beginning,state
NFACompiler -> NFAFactoryCompiler -> @SuppressWarnings("unchecked") 		private State<T> createStartState(State<T> sinkState);1497410381;Creates the Start {@link State} of the resulting NFA graph.__@param sinkState the state that Start state should point to (always first state of middle states)_@return created state;@SuppressWarnings("unchecked")_		private State<T> createStartState(State<T> sinkState) {_			stateNameHandler.checkNameUniqueness(currentPattern.getName())__			final State<T> beginningState = convertPattern(sinkState)__			beginningState.makeStart()__			return beginningState__		};creates,the,start,link,state,of,the,resulting,nfa,graph,param,sink,state,the,state,that,start,state,should,point,to,always,first,state,of,middle,states,return,created,state;suppress,warnings,unchecked,private,state,t,create,start,state,state,t,sink,state,state,name,handler,check,name,uniqueness,current,pattern,get,name,final,state,t,beginning,state,convert,pattern,sink,state,beginning,state,make,start,return,beginning,state
NFACompiler -> NFAFactoryCompiler -> @SuppressWarnings("unchecked") 		private State<T> createStartState(State<T> sinkState);1497883202;Creates the Start {@link State} of the resulting NFA graph.__@param sinkState the state that Start state should point to (always first state of middle states)_@return created state;@SuppressWarnings("unchecked")_		private State<T> createStartState(State<T> sinkState) {_			stateNameHandler.checkNameUniqueness(currentPattern.getName())__			final State<T> beginningState = convertPattern(sinkState)__			beginningState.makeStart()__			return beginningState__		};creates,the,start,link,state,of,the,resulting,nfa,graph,param,sink,state,the,state,that,start,state,should,point,to,always,first,state,of,middle,states,return,created,state;suppress,warnings,unchecked,private,state,t,create,start,state,state,t,sink,state,state,name,handler,check,name,uniqueness,current,pattern,get,name,final,state,t,beginning,state,convert,pattern,sink,state,beginning,state,make,start,return,beginning,state
NFACompiler -> NFAFactoryCompiler -> @SuppressWarnings("unchecked") 		private State<T> createStartState(State<T> sinkState);1498034481;Creates the Start {@link State} of the resulting NFA graph.__@param sinkState the state that Start state should point to (always first state of middle states)_@return created state;@SuppressWarnings("unchecked")_		private State<T> createStartState(State<T> sinkState) {_			final State<T> beginningState = convertPattern(sinkState)__			beginningState.makeStart()__			return beginningState__		};creates,the,start,link,state,of,the,resulting,nfa,graph,param,sink,state,the,state,that,start,state,should,point,to,always,first,state,of,middle,states,return,created,state;suppress,warnings,unchecked,private,state,t,create,start,state,state,t,sink,state,final,state,t,beginning,state,convert,pattern,sink,state,beginning,state,make,start,return,beginning,state
NFACompiler -> NFAFactoryCompiler -> @SuppressWarnings("unchecked") 		private State<T> createStartState(State<T> sinkState);1499760222;Creates the Start {@link State} of the resulting NFA graph.__@param sinkState the state that Start state should point to (always first state of middle states)_@return created state;@SuppressWarnings("unchecked")_		private State<T> createStartState(State<T> sinkState) {_			final State<T> beginningState = convertPattern(sinkState)__			beginningState.makeStart()__			return beginningState__		};creates,the,start,link,state,of,the,resulting,nfa,graph,param,sink,state,the,state,that,start,state,should,point,to,always,first,state,of,middle,states,return,created,state;suppress,warnings,unchecked,private,state,t,create,start,state,state,t,sink,state,final,state,t,beginning,state,convert,pattern,sink,state,beginning,state,make,start,return,beginning,state
NFACompiler -> NFAFactoryCompiler -> @SuppressWarnings("unchecked") 		private State<T> createStartState(State<T> sinkState);1499937690;Creates the Start {@link State} of the resulting NFA graph.__@param sinkState the state that Start state should point to (always first state of middle states)_@return created state;@SuppressWarnings("unchecked")_		private State<T> createStartState(State<T> sinkState) {_			final State<T> beginningState = convertPattern(sinkState)__			beginningState.makeStart()__			return beginningState__		};creates,the,start,link,state,of,the,resulting,nfa,graph,param,sink,state,the,state,that,start,state,should,point,to,always,first,state,of,middle,states,return,created,state;suppress,warnings,unchecked,private,state,t,create,start,state,state,t,sink,state,final,state,t,beginning,state,convert,pattern,sink,state,beginning,state,make,start,return,beginning,state
NFACompiler -> NFAFactoryCompiler -> @SuppressWarnings("unchecked") 		private State<T> createStartState(State<T> sinkState);1500021711;Creates the Start {@link State} of the resulting NFA graph.__@param sinkState the state that Start state should point to (always first state of middle states)_@return created state;@SuppressWarnings("unchecked")_		private State<T> createStartState(State<T> sinkState) {_			final State<T> beginningState = convertPattern(sinkState)__			beginningState.makeStart()__			return beginningState__		};creates,the,start,link,state,of,the,resulting,nfa,graph,param,sink,state,the,state,that,start,state,should,point,to,always,first,state,of,middle,states,return,created,state;suppress,warnings,unchecked,private,state,t,create,start,state,state,t,sink,state,final,state,t,beginning,state,convert,pattern,sink,state,beginning,state,make,start,return,beginning,state
NFACompiler -> NFAFactoryCompiler -> @SuppressWarnings("unchecked") 		private State<T> createStartState(State<T> sinkState);1501592283;Creates the Start {@link State} of the resulting NFA graph.__@param sinkState the state that Start state should point to (always first state of middle states)_@return created state;@SuppressWarnings("unchecked")_		private State<T> createStartState(State<T> sinkState) {_			final State<T> beginningState = convertPattern(sinkState)__			beginningState.makeStart()__			return beginningState__		};creates,the,start,link,state,of,the,resulting,nfa,graph,param,sink,state,the,state,that,start,state,should,point,to,always,first,state,of,middle,states,return,created,state;suppress,warnings,unchecked,private,state,t,create,start,state,state,t,sink,state,final,state,t,beginning,state,convert,pattern,sink,state,beginning,state,make,start,return,beginning,state
NFACompiler -> NFAFactoryCompiler -> @SuppressWarnings("unchecked") 		private State<T> createStartState(State<T> sinkState);1502422141;Creates the Start {@link State} of the resulting NFA graph.__@param sinkState the state that Start state should point to (always first state of middle states)_@return created state;@SuppressWarnings("unchecked")_		private State<T> createStartState(State<T> sinkState) {_			final State<T> beginningState = convertPattern(sinkState)__			beginningState.makeStart()__			return beginningState__		};creates,the,start,link,state,of,the,resulting,nfa,graph,param,sink,state,the,state,that,start,state,should,point,to,always,first,state,of,middle,states,return,created,state;suppress,warnings,unchecked,private,state,t,create,start,state,state,t,sink,state,final,state,t,beginning,state,convert,pattern,sink,state,beginning,state,make,start,return,beginning,state
NFACompiler -> NFAFactoryCompiler -> @SuppressWarnings("unchecked") 		private State<T> createStartState(State<T> sinkState);1503588494;Creates the Start {@link State} of the resulting NFA graph.__@param sinkState the state that Start state should point to (always first state of middle states)_@return created state;@SuppressWarnings("unchecked")_		private State<T> createStartState(State<T> sinkState) {_			final State<T> beginningState = convertPattern(sinkState)__			beginningState.makeStart()__			return beginningState__		};creates,the,start,link,state,of,the,resulting,nfa,graph,param,sink,state,the,state,that,start,state,should,point,to,always,first,state,of,middle,states,return,created,state;suppress,warnings,unchecked,private,state,t,create,start,state,state,t,sink,state,final,state,t,beginning,state,convert,pattern,sink,state,beginning,state,make,start,return,beginning,state
NFACompiler -> NFAFactoryCompiler -> @SuppressWarnings("unchecked") 		private State<T> createStartState(State<T> sinkState);1518008111;Creates the Start {@link State} of the resulting NFA graph.__@param sinkState the state that Start state should point to (always first state of middle states)_@return created state;@SuppressWarnings("unchecked")_		private State<T> createStartState(State<T> sinkState) {_			final State<T> beginningState = convertPattern(sinkState)__			beginningState.makeStart()__			return beginningState__		};creates,the,start,link,state,of,the,resulting,nfa,graph,param,sink,state,the,state,that,start,state,should,point,to,always,first,state,of,middle,states,return,created,state;suppress,warnings,unchecked,private,state,t,create,start,state,state,t,sink,state,final,state,t,beginning,state,convert,pattern,sink,state,beginning,state,make,start,return,beginning,state
NFACompiler -> NFAFactoryCompiler -> @SuppressWarnings("unchecked") 		private State<T> createStartState(State<T> sinkState);1527863170;Creates the Start {@link State} of the resulting NFA graph.__@param sinkState the state that Start state should point to (always first state of middle states)_@return created state;@SuppressWarnings("unchecked")_		private State<T> createStartState(State<T> sinkState) {_			final State<T> beginningState = convertPattern(sinkState)__			beginningState.makeStart()__			return beginningState__		};creates,the,start,link,state,of,the,resulting,nfa,graph,param,sink,state,the,state,that,start,state,should,point,to,always,first,state,of,middle,states,return,created,state;suppress,warnings,unchecked,private,state,t,create,start,state,state,t,sink,state,final,state,t,beginning,state,convert,pattern,sink,state,beginning,state,make,start,return,beginning,state
NFACompiler -> NFAFactoryCompiler -> @SuppressWarnings("unchecked") 		private State<T> createStartState(State<T> sinkState);1528989005;Creates the Start {@link State} of the resulting NFA graph.__@param sinkState the state that Start state should point to (always first state of middle states)_@return created state;@SuppressWarnings("unchecked")_		private State<T> createStartState(State<T> sinkState) {_			final State<T> beginningState = convertPattern(sinkState)__			beginningState.makeStart()__			return beginningState__		};creates,the,start,link,state,of,the,resulting,nfa,graph,param,sink,state,the,state,that,start,state,should,point,to,always,first,state,of,middle,states,return,created,state;suppress,warnings,unchecked,private,state,t,create,start,state,state,t,sink,state,final,state,t,beginning,state,convert,pattern,sink,state,beginning,state,make,start,return,beginning,state
NFACompiler -> NFAFactoryCompiler -> @SuppressWarnings("unchecked") 		private State<T> createStartState(State<T> sinkState);1538745898;Creates the Start {@link State} of the resulting NFA graph.__@param sinkState the state that Start state should point to (always first state of middle states)_@return created state;@SuppressWarnings("unchecked")_		private State<T> createStartState(State<T> sinkState) {_			final State<T> beginningState = convertPattern(sinkState)__			beginningState.makeStart()__			return beginningState__		};creates,the,start,link,state,of,the,resulting,nfa,graph,param,sink,state,the,state,that,start,state,should,point,to,always,first,state,of,middle,states,return,created,state;suppress,warnings,unchecked,private,state,t,create,start,state,state,t,sink,state,final,state,t,beginning,state,convert,pattern,sink,state,beginning,state,make,start,return,beginning,state
NFACompiler -> NFAFactoryCompiler -> @SuppressWarnings("unchecked") 		private State<T> createStartState(State<T> sinkState);1542293931;Creates the Start {@link State} of the resulting NFA graph.__@param sinkState the state that Start state should point to (always first state of middle states)_@return created state;@SuppressWarnings("unchecked")_		private State<T> createStartState(State<T> sinkState) {_			final State<T> beginningState = convertPattern(sinkState)__			beginningState.makeStart()__			return beginningState__		};creates,the,start,link,state,of,the,resulting,nfa,graph,param,sink,state,the,state,that,start,state,should,point,to,always,first,state,of,middle,states,return,created,state;suppress,warnings,unchecked,private,state,t,create,start,state,state,t,sink,state,final,state,t,beginning,state,convert,pattern,sink,state,beginning,state,make,start,return,beginning,state
NFACompiler -> NFAFactoryCompiler -> private State<T> copyWithoutTransitiveNots(final State<T> sinkState);1493385877;This method creates an alternative state that is target for TAKE transition from an optional State._Accepting an event in optional State discards all not Patterns that were present before it.__<p>E.g for a Pattern begin("a").notFollowedBy("b").followedByAny("c").optional().followedByAny("d")_a sequence like : {a c b d} is a valid match, but {a b d} is not.__<p><b>NOTICE:</b> This method creates copy only if it necessary.__@param sinkState a state to create copy without transitive nots_@return the copy of the state itself if no modifications were needed;private State<T> copyWithoutTransitiveNots(final State<T> sinkState) {_			final List<Tuple2<IterativeCondition<T>, String>> currentNotCondition = getCurrentNotCondition()___			if (currentNotCondition.isEmpty() ||_				!currentPattern.getQuantifier().hasProperty(Quantifier.QuantifierProperty.OPTIONAL)) {_				_				_				return sinkState__			}__			final State<T> copyOfSink = new State<>(sinkState.getName(), sinkState.getStateType())__			states.add(copyOfSink)___			for (StateTransition<T> tStateTransition : sinkState.getStateTransitions()) {__				if (tStateTransition.getAction() == StateTransitionAction.PROCEED) {_					State<T> targetState = tStateTransition.getTargetState()__					boolean remove = false__					if (targetState.isStop()) {_						for (Tuple2<IterativeCondition<T>, String> notCondition : currentNotCondition) {_							if (targetState.getName().equals(notCondition.f1)) {_								remove = true__							}_						}_					} else {_						targetState = copyWithoutTransitiveNots(tStateTransition.getTargetState())__					}__					if (!remove) {_						copyOfSink.addStateTransition(tStateTransition.getAction(), targetState, tStateTransition.getCondition())__					}_				} else {_					copyOfSink.addStateTransition(_							tStateTransition.getAction(),_							tStateTransition.getTargetState().equals(tStateTransition.getSourceState())_									? copyOfSink_									: tStateTransition.getTargetState(),_							tStateTransition.getCondition()_					)__				}__			}_			return copyOfSink__		};this,method,creates,an,alternative,state,that,is,target,for,take,transition,from,an,optional,state,accepting,an,event,in,optional,state,discards,all,not,patterns,that,were,present,before,it,p,e,g,for,a,pattern,begin,a,not,followed,by,b,followed,by,any,c,optional,followed,by,any,d,a,sequence,like,a,c,b,d,is,a,valid,match,but,a,b,d,is,not,p,b,notice,b,this,method,creates,copy,only,if,it,necessary,param,sink,state,a,state,to,create,copy,without,transitive,nots,return,the,copy,of,the,state,itself,if,no,modifications,were,needed;private,state,t,copy,without,transitive,nots,final,state,t,sink,state,final,list,tuple2,iterative,condition,t,string,current,not,condition,get,current,not,condition,if,current,not,condition,is,empty,current,pattern,get,quantifier,has,property,quantifier,quantifier,property,optional,return,sink,state,final,state,t,copy,of,sink,new,state,sink,state,get,name,sink,state,get,state,type,states,add,copy,of,sink,for,state,transition,t,t,state,transition,sink,state,get,state,transitions,if,t,state,transition,get,action,state,transition,action,proceed,state,t,target,state,t,state,transition,get,target,state,boolean,remove,false,if,target,state,is,stop,for,tuple2,iterative,condition,t,string,not,condition,current,not,condition,if,target,state,get,name,equals,not,condition,f1,remove,true,else,target,state,copy,without,transitive,nots,t,state,transition,get,target,state,if,remove,copy,of,sink,add,state,transition,t,state,transition,get,action,target,state,t,state,transition,get,condition,else,copy,of,sink,add,state,transition,t,state,transition,get,action,t,state,transition,get,target,state,equals,t,state,transition,get,source,state,copy,of,sink,t,state,transition,get,target,state,t,state,transition,get,condition,return,copy,of,sink
NFACompiler -> NFAFactoryCompiler -> private State<T> copyWithoutTransitiveNots(final State<T> sinkState);1494947249;This method creates an alternative state that is target for TAKE transition from an optional State._Accepting an event in optional State discards all not Patterns that were present before it.__<p>E.g for a Pattern begin("a").notFollowedBy("b").followedByAny("c").optional().followedByAny("d")_a sequence like : {a c b d} is a valid match, but {a b d} is not.__<p><b>NOTICE:</b> This method creates copy only if it necessary.__@param sinkState a state to create copy without transitive nots_@return the copy of the state itself if no modifications were needed;private State<T> copyWithoutTransitiveNots(final State<T> sinkState) {_			final List<Tuple2<IterativeCondition<T>, String>> currentNotCondition = getCurrentNotCondition()___			if (currentNotCondition.isEmpty() ||_				!currentPattern.getQuantifier().hasProperty(Quantifier.QuantifierProperty.OPTIONAL)) {_				_				_				return sinkState__			}__			final State<T> copyOfSink = createState(sinkState.getName(), sinkState.getStateType())___			for (StateTransition<T> tStateTransition : sinkState.getStateTransitions()) {__				if (tStateTransition.getAction() == StateTransitionAction.PROCEED) {_					State<T> targetState = tStateTransition.getTargetState()__					boolean remove = false__					if (targetState.isStop()) {_						for (Tuple2<IterativeCondition<T>, String> notCondition : currentNotCondition) {_							if (targetState.getName().equals(notCondition.f1)) {_								remove = true__							}_						}_					} else {_						targetState = copyWithoutTransitiveNots(tStateTransition.getTargetState())__					}__					if (!remove) {_						copyOfSink.addStateTransition(tStateTransition.getAction(), targetState, tStateTransition.getCondition())__					}_				} else {_					copyOfSink.addStateTransition(_							tStateTransition.getAction(),_							tStateTransition.getTargetState().equals(tStateTransition.getSourceState())_									? copyOfSink_									: tStateTransition.getTargetState(),_							tStateTransition.getCondition()_					)__				}__			}_			return copyOfSink__		};this,method,creates,an,alternative,state,that,is,target,for,take,transition,from,an,optional,state,accepting,an,event,in,optional,state,discards,all,not,patterns,that,were,present,before,it,p,e,g,for,a,pattern,begin,a,not,followed,by,b,followed,by,any,c,optional,followed,by,any,d,a,sequence,like,a,c,b,d,is,a,valid,match,but,a,b,d,is,not,p,b,notice,b,this,method,creates,copy,only,if,it,necessary,param,sink,state,a,state,to,create,copy,without,transitive,nots,return,the,copy,of,the,state,itself,if,no,modifications,were,needed;private,state,t,copy,without,transitive,nots,final,state,t,sink,state,final,list,tuple2,iterative,condition,t,string,current,not,condition,get,current,not,condition,if,current,not,condition,is,empty,current,pattern,get,quantifier,has,property,quantifier,quantifier,property,optional,return,sink,state,final,state,t,copy,of,sink,create,state,sink,state,get,name,sink,state,get,state,type,for,state,transition,t,t,state,transition,sink,state,get,state,transitions,if,t,state,transition,get,action,state,transition,action,proceed,state,t,target,state,t,state,transition,get,target,state,boolean,remove,false,if,target,state,is,stop,for,tuple2,iterative,condition,t,string,not,condition,current,not,condition,if,target,state,get,name,equals,not,condition,f1,remove,true,else,target,state,copy,without,transitive,nots,t,state,transition,get,target,state,if,remove,copy,of,sink,add,state,transition,t,state,transition,get,action,target,state,t,state,transition,get,condition,else,copy,of,sink,add,state,transition,t,state,transition,get,action,t,state,transition,get,target,state,equals,t,state,transition,get,source,state,copy,of,sink,t,state,transition,get,target,state,t,state,transition,get,condition,return,copy,of,sink
NFACompiler -> NFAFactoryCompiler -> private State<T> copyWithoutTransitiveNots(final State<T> sinkState);1495657626;This method creates an alternative state that is target for TAKE transition from an optional State._Accepting an event in optional State discards all not Patterns that were present before it.__<p>E.g for a Pattern begin("a").notFollowedBy("b").followedByAny("c").optional().followedByAny("d")_a sequence like : {a c b d} is a valid match, but {a b d} is not.__<p><b>NOTICE:</b> This method creates copy only if it necessary.__@param sinkState a state to create copy without transitive nots_@return the copy of the state itself if no modifications were needed;private State<T> copyWithoutTransitiveNots(final State<T> sinkState) {_			final List<Tuple2<IterativeCondition<T>, String>> currentNotCondition = getCurrentNotCondition()___			if (currentNotCondition.isEmpty() ||_				!currentPattern.getQuantifier().hasProperty(Quantifier.QuantifierProperty.OPTIONAL)) {_				_				_				return sinkState__			}__			final State<T> copyOfSink = createState(sinkState.getName(), sinkState.getStateType())___			for (StateTransition<T> tStateTransition : sinkState.getStateTransitions()) {__				if (tStateTransition.getAction() == StateTransitionAction.PROCEED) {_					State<T> targetState = tStateTransition.getTargetState()__					boolean remove = false__					if (targetState.isStop()) {_						for (Tuple2<IterativeCondition<T>, String> notCondition : currentNotCondition) {_							if (targetState.getName().equals(notCondition.f1)) {_								remove = true__							}_						}_					} else {_						targetState = copyWithoutTransitiveNots(tStateTransition.getTargetState())__					}__					if (!remove) {_						copyOfSink.addStateTransition(tStateTransition.getAction(), targetState, tStateTransition.getCondition())__					}_				} else {_					copyOfSink.addStateTransition(_							tStateTransition.getAction(),_							tStateTransition.getTargetState().equals(tStateTransition.getSourceState())_									? copyOfSink_									: tStateTransition.getTargetState(),_							tStateTransition.getCondition()_					)__				}__			}_			return copyOfSink__		};this,method,creates,an,alternative,state,that,is,target,for,take,transition,from,an,optional,state,accepting,an,event,in,optional,state,discards,all,not,patterns,that,were,present,before,it,p,e,g,for,a,pattern,begin,a,not,followed,by,b,followed,by,any,c,optional,followed,by,any,d,a,sequence,like,a,c,b,d,is,a,valid,match,but,a,b,d,is,not,p,b,notice,b,this,method,creates,copy,only,if,it,necessary,param,sink,state,a,state,to,create,copy,without,transitive,nots,return,the,copy,of,the,state,itself,if,no,modifications,were,needed;private,state,t,copy,without,transitive,nots,final,state,t,sink,state,final,list,tuple2,iterative,condition,t,string,current,not,condition,get,current,not,condition,if,current,not,condition,is,empty,current,pattern,get,quantifier,has,property,quantifier,quantifier,property,optional,return,sink,state,final,state,t,copy,of,sink,create,state,sink,state,get,name,sink,state,get,state,type,for,state,transition,t,t,state,transition,sink,state,get,state,transitions,if,t,state,transition,get,action,state,transition,action,proceed,state,t,target,state,t,state,transition,get,target,state,boolean,remove,false,if,target,state,is,stop,for,tuple2,iterative,condition,t,string,not,condition,current,not,condition,if,target,state,get,name,equals,not,condition,f1,remove,true,else,target,state,copy,without,transitive,nots,t,state,transition,get,target,state,if,remove,copy,of,sink,add,state,transition,t,state,transition,get,action,target,state,t,state,transition,get,condition,else,copy,of,sink,add,state,transition,t,state,transition,get,action,t,state,transition,get,target,state,equals,t,state,transition,get,source,state,copy,of,sink,t,state,transition,get,target,state,t,state,transition,get,condition,return,copy,of,sink
NFACompiler -> NFAFactoryCompiler -> private State<T> copyWithoutTransitiveNots(final State<T> sinkState);1496245714;This method creates an alternative state that is target for TAKE transition from an optional State._Accepting an event in optional State discards all not Patterns that were present before it.__<p>E.g for a Pattern begin("a").notFollowedBy("b").followedByAny("c").optional().followedByAny("d")_a sequence like : {a c b d} is a valid match, but {a b d} is not.__<p><b>NOTICE:</b> This method creates copy only if it necessary.__@param sinkState a state to create copy without transitive nots_@return the copy of the state itself if no modifications were needed;private State<T> copyWithoutTransitiveNots(final State<T> sinkState) {_			final List<Tuple2<IterativeCondition<T>, String>> currentNotCondition = getCurrentNotCondition()___			if (currentNotCondition.isEmpty() ||_				!currentPattern.getQuantifier().hasProperty(Quantifier.QuantifierProperty.OPTIONAL)) {_				_				_				return sinkState__			}__			final State<T> copyOfSink = createState(sinkState.getName(), sinkState.getStateType())___			for (StateTransition<T> tStateTransition : sinkState.getStateTransitions()) {__				if (tStateTransition.getAction() == StateTransitionAction.PROCEED) {_					State<T> targetState = tStateTransition.getTargetState()__					boolean remove = false__					if (targetState.isStop()) {_						for (Tuple2<IterativeCondition<T>, String> notCondition : currentNotCondition) {_							if (targetState.getName().equals(notCondition.f1)) {_								remove = true__							}_						}_					} else {_						targetState = copyWithoutTransitiveNots(tStateTransition.getTargetState())__					}__					if (!remove) {_						copyOfSink.addStateTransition(tStateTransition.getAction(), targetState, tStateTransition.getCondition())__					}_				} else {_					copyOfSink.addStateTransition(_							tStateTransition.getAction(),_							tStateTransition.getTargetState().equals(tStateTransition.getSourceState())_									? copyOfSink_									: tStateTransition.getTargetState(),_							tStateTransition.getCondition()_					)__				}__			}_			return copyOfSink__		};this,method,creates,an,alternative,state,that,is,target,for,take,transition,from,an,optional,state,accepting,an,event,in,optional,state,discards,all,not,patterns,that,were,present,before,it,p,e,g,for,a,pattern,begin,a,not,followed,by,b,followed,by,any,c,optional,followed,by,any,d,a,sequence,like,a,c,b,d,is,a,valid,match,but,a,b,d,is,not,p,b,notice,b,this,method,creates,copy,only,if,it,necessary,param,sink,state,a,state,to,create,copy,without,transitive,nots,return,the,copy,of,the,state,itself,if,no,modifications,were,needed;private,state,t,copy,without,transitive,nots,final,state,t,sink,state,final,list,tuple2,iterative,condition,t,string,current,not,condition,get,current,not,condition,if,current,not,condition,is,empty,current,pattern,get,quantifier,has,property,quantifier,quantifier,property,optional,return,sink,state,final,state,t,copy,of,sink,create,state,sink,state,get,name,sink,state,get,state,type,for,state,transition,t,t,state,transition,sink,state,get,state,transitions,if,t,state,transition,get,action,state,transition,action,proceed,state,t,target,state,t,state,transition,get,target,state,boolean,remove,false,if,target,state,is,stop,for,tuple2,iterative,condition,t,string,not,condition,current,not,condition,if,target,state,get,name,equals,not,condition,f1,remove,true,else,target,state,copy,without,transitive,nots,t,state,transition,get,target,state,if,remove,copy,of,sink,add,state,transition,t,state,transition,get,action,target,state,t,state,transition,get,condition,else,copy,of,sink,add,state,transition,t,state,transition,get,action,t,state,transition,get,target,state,equals,t,state,transition,get,source,state,copy,of,sink,t,state,transition,get,target,state,t,state,transition,get,condition,return,copy,of,sink
NFACompiler -> NFAFactoryCompiler -> private State<T> copyWithoutTransitiveNots(final State<T> sinkState);1497410381;This method creates an alternative state that is target for TAKE transition from an optional State._Accepting an event in optional State discards all not Patterns that were present before it.__<p>E.g for a Pattern begin("a").notFollowedBy("b").followedByAny("c").optional().followedByAny("d")_a sequence like : {a c b d} is a valid match, but {a b d} is not.__<p><b>NOTICE:</b> This method creates copy only if it necessary.__@param sinkState a state to create copy without transitive nots_@return the copy of the state itself if no modifications were needed;private State<T> copyWithoutTransitiveNots(final State<T> sinkState) {_			final List<Tuple2<IterativeCondition<T>, String>> currentNotCondition = getCurrentNotCondition()___			if (currentNotCondition.isEmpty() ||_				!currentPattern.getQuantifier().hasProperty(Quantifier.QuantifierProperty.OPTIONAL)) {_				_				_				return sinkState__			}__			final State<T> copyOfSink = createState(sinkState.getName(), sinkState.getStateType())___			for (StateTransition<T> tStateTransition : sinkState.getStateTransitions()) {__				if (tStateTransition.getAction() == StateTransitionAction.PROCEED) {_					State<T> targetState = tStateTransition.getTargetState()__					boolean remove = false__					if (targetState.isStop()) {_						for (Tuple2<IterativeCondition<T>, String> notCondition : currentNotCondition) {_							if (targetState.getName().equals(notCondition.f1)) {_								remove = true__							}_						}_					} else {_						targetState = copyWithoutTransitiveNots(tStateTransition.getTargetState())__					}__					if (!remove) {_						copyOfSink.addStateTransition(tStateTransition.getAction(), targetState, tStateTransition.getCondition())__					}_				} else {_					copyOfSink.addStateTransition(_							tStateTransition.getAction(),_							tStateTransition.getTargetState().equals(tStateTransition.getSourceState())_									? copyOfSink_									: tStateTransition.getTargetState(),_							tStateTransition.getCondition()_					)__				}__			}_			return copyOfSink__		};this,method,creates,an,alternative,state,that,is,target,for,take,transition,from,an,optional,state,accepting,an,event,in,optional,state,discards,all,not,patterns,that,were,present,before,it,p,e,g,for,a,pattern,begin,a,not,followed,by,b,followed,by,any,c,optional,followed,by,any,d,a,sequence,like,a,c,b,d,is,a,valid,match,but,a,b,d,is,not,p,b,notice,b,this,method,creates,copy,only,if,it,necessary,param,sink,state,a,state,to,create,copy,without,transitive,nots,return,the,copy,of,the,state,itself,if,no,modifications,were,needed;private,state,t,copy,without,transitive,nots,final,state,t,sink,state,final,list,tuple2,iterative,condition,t,string,current,not,condition,get,current,not,condition,if,current,not,condition,is,empty,current,pattern,get,quantifier,has,property,quantifier,quantifier,property,optional,return,sink,state,final,state,t,copy,of,sink,create,state,sink,state,get,name,sink,state,get,state,type,for,state,transition,t,t,state,transition,sink,state,get,state,transitions,if,t,state,transition,get,action,state,transition,action,proceed,state,t,target,state,t,state,transition,get,target,state,boolean,remove,false,if,target,state,is,stop,for,tuple2,iterative,condition,t,string,not,condition,current,not,condition,if,target,state,get,name,equals,not,condition,f1,remove,true,else,target,state,copy,without,transitive,nots,t,state,transition,get,target,state,if,remove,copy,of,sink,add,state,transition,t,state,transition,get,action,target,state,t,state,transition,get,condition,else,copy,of,sink,add,state,transition,t,state,transition,get,action,t,state,transition,get,target,state,equals,t,state,transition,get,source,state,copy,of,sink,t,state,transition,get,target,state,t,state,transition,get,condition,return,copy,of,sink
NFACompiler -> NFAFactoryCompiler -> private State<T> copyWithoutTransitiveNots(final State<T> sinkState);1497883202;This method creates an alternative state that is target for TAKE transition from an optional State._Accepting an event in optional State discards all not Patterns that were present before it.__<p>E.g for a Pattern begin("a").notFollowedBy("b").followedByAny("c").optional().followedByAny("d")_a sequence like : {a c b d} is a valid match, but {a b d} is not.__<p><b>NOTICE:</b> This method creates copy only if it necessary.__@param sinkState a state to create copy without transitive nots_@return the copy of the state itself if no modifications were needed;private State<T> copyWithoutTransitiveNots(final State<T> sinkState) {_			final List<Tuple2<IterativeCondition<T>, String>> currentNotCondition = getCurrentNotCondition()___			if (currentNotCondition.isEmpty() ||_				!currentPattern.getQuantifier().hasProperty(Quantifier.QuantifierProperty.OPTIONAL)) {_				_				_				return sinkState__			}__			final State<T> copyOfSink = createState(sinkState.getName(), sinkState.getStateType())___			for (StateTransition<T> tStateTransition : sinkState.getStateTransitions()) {__				if (tStateTransition.getAction() == StateTransitionAction.PROCEED) {_					State<T> targetState = tStateTransition.getTargetState()__					boolean remove = false__					if (targetState.isStop()) {_						for (Tuple2<IterativeCondition<T>, String> notCondition : currentNotCondition) {_							if (targetState.getName().equals(notCondition.f1)) {_								remove = true__							}_						}_					} else {_						targetState = copyWithoutTransitiveNots(tStateTransition.getTargetState())__					}__					if (!remove) {_						copyOfSink.addStateTransition(tStateTransition.getAction(), targetState, tStateTransition.getCondition())__					}_				} else {_					copyOfSink.addStateTransition(_							tStateTransition.getAction(),_							tStateTransition.getTargetState().equals(tStateTransition.getSourceState())_									? copyOfSink_									: tStateTransition.getTargetState(),_							tStateTransition.getCondition()_					)__				}__			}_			return copyOfSink__		};this,method,creates,an,alternative,state,that,is,target,for,take,transition,from,an,optional,state,accepting,an,event,in,optional,state,discards,all,not,patterns,that,were,present,before,it,p,e,g,for,a,pattern,begin,a,not,followed,by,b,followed,by,any,c,optional,followed,by,any,d,a,sequence,like,a,c,b,d,is,a,valid,match,but,a,b,d,is,not,p,b,notice,b,this,method,creates,copy,only,if,it,necessary,param,sink,state,a,state,to,create,copy,without,transitive,nots,return,the,copy,of,the,state,itself,if,no,modifications,were,needed;private,state,t,copy,without,transitive,nots,final,state,t,sink,state,final,list,tuple2,iterative,condition,t,string,current,not,condition,get,current,not,condition,if,current,not,condition,is,empty,current,pattern,get,quantifier,has,property,quantifier,quantifier,property,optional,return,sink,state,final,state,t,copy,of,sink,create,state,sink,state,get,name,sink,state,get,state,type,for,state,transition,t,t,state,transition,sink,state,get,state,transitions,if,t,state,transition,get,action,state,transition,action,proceed,state,t,target,state,t,state,transition,get,target,state,boolean,remove,false,if,target,state,is,stop,for,tuple2,iterative,condition,t,string,not,condition,current,not,condition,if,target,state,get,name,equals,not,condition,f1,remove,true,else,target,state,copy,without,transitive,nots,t,state,transition,get,target,state,if,remove,copy,of,sink,add,state,transition,t,state,transition,get,action,target,state,t,state,transition,get,condition,else,copy,of,sink,add,state,transition,t,state,transition,get,action,t,state,transition,get,target,state,equals,t,state,transition,get,source,state,copy,of,sink,t,state,transition,get,target,state,t,state,transition,get,condition,return,copy,of,sink
NFACompiler -> NFAFactoryCompiler -> private State<T> copyWithoutTransitiveNots(final State<T> sinkState);1498034481;This method creates an alternative state that is target for TAKE transition from an optional State._Accepting an event in optional State discards all not Patterns that were present before it.__<p>E.g for a Pattern begin("a").notFollowedBy("b").followedByAny("c").optional().followedByAny("d")_a sequence like : {a c b d} is a valid match, but {a b d} is not.__<p><b>NOTICE:</b> This method creates copy only if it necessary.__@param sinkState a state to create copy without transitive nots_@return the copy of the state itself if no modifications were needed;private State<T> copyWithoutTransitiveNots(final State<T> sinkState) {_			final List<Tuple2<IterativeCondition<T>, String>> currentNotCondition = getCurrentNotCondition()___			if (currentNotCondition.isEmpty() ||_				!currentPattern.getQuantifier().hasProperty(Quantifier.QuantifierProperty.OPTIONAL)) {_				_				_				return sinkState__			}__			final State<T> copyOfSink = createState(sinkState.getName(), sinkState.getStateType())___			for (StateTransition<T> tStateTransition : sinkState.getStateTransitions()) {__				if (tStateTransition.getAction() == StateTransitionAction.PROCEED) {_					State<T> targetState = tStateTransition.getTargetState()__					boolean remove = false__					if (targetState.isStop()) {_						for (Tuple2<IterativeCondition<T>, String> notCondition : currentNotCondition) {_							if (targetState.getName().equals(notCondition.f1)) {_								remove = true__							}_						}_					} else {_						targetState = copyWithoutTransitiveNots(tStateTransition.getTargetState())__					}__					if (!remove) {_						copyOfSink.addStateTransition(tStateTransition.getAction(), targetState, tStateTransition.getCondition())__					}_				} else {_					copyOfSink.addStateTransition(_							tStateTransition.getAction(),_							tStateTransition.getTargetState().equals(tStateTransition.getSourceState())_									? copyOfSink_									: tStateTransition.getTargetState(),_							tStateTransition.getCondition()_					)__				}__			}_			return copyOfSink__		};this,method,creates,an,alternative,state,that,is,target,for,take,transition,from,an,optional,state,accepting,an,event,in,optional,state,discards,all,not,patterns,that,were,present,before,it,p,e,g,for,a,pattern,begin,a,not,followed,by,b,followed,by,any,c,optional,followed,by,any,d,a,sequence,like,a,c,b,d,is,a,valid,match,but,a,b,d,is,not,p,b,notice,b,this,method,creates,copy,only,if,it,necessary,param,sink,state,a,state,to,create,copy,without,transitive,nots,return,the,copy,of,the,state,itself,if,no,modifications,were,needed;private,state,t,copy,without,transitive,nots,final,state,t,sink,state,final,list,tuple2,iterative,condition,t,string,current,not,condition,get,current,not,condition,if,current,not,condition,is,empty,current,pattern,get,quantifier,has,property,quantifier,quantifier,property,optional,return,sink,state,final,state,t,copy,of,sink,create,state,sink,state,get,name,sink,state,get,state,type,for,state,transition,t,t,state,transition,sink,state,get,state,transitions,if,t,state,transition,get,action,state,transition,action,proceed,state,t,target,state,t,state,transition,get,target,state,boolean,remove,false,if,target,state,is,stop,for,tuple2,iterative,condition,t,string,not,condition,current,not,condition,if,target,state,get,name,equals,not,condition,f1,remove,true,else,target,state,copy,without,transitive,nots,t,state,transition,get,target,state,if,remove,copy,of,sink,add,state,transition,t,state,transition,get,action,target,state,t,state,transition,get,condition,else,copy,of,sink,add,state,transition,t,state,transition,get,action,t,state,transition,get,target,state,equals,t,state,transition,get,source,state,copy,of,sink,t,state,transition,get,target,state,t,state,transition,get,condition,return,copy,of,sink
NFACompiler -> NFAFactoryCompiler -> private State<T> copyWithoutTransitiveNots(final State<T> sinkState);1499760222;This method creates an alternative state that is target for TAKE transition from an optional State._Accepting an event in optional State discards all not Patterns that were present before it.__<p>E.g for a Pattern begin("a").notFollowedBy("b").followedByAny("c").optional().followedByAny("d")_a sequence like : {a c b d} is a valid match, but {a b d} is not.__<p><b>NOTICE:</b> This method creates copy only if it necessary.__@param sinkState a state to create copy without transitive nots_@return the copy of the state itself if no modifications were needed;private State<T> copyWithoutTransitiveNots(final State<T> sinkState) {_			final List<Tuple2<IterativeCondition<T>, String>> currentNotCondition = getCurrentNotCondition()___			if (currentNotCondition.isEmpty() ||_				!currentPattern.getQuantifier().hasProperty(Quantifier.QuantifierProperty.OPTIONAL)) {_				_				_				return sinkState__			}__			final State<T> copyOfSink = createState(sinkState.getName(), sinkState.getStateType())___			for (StateTransition<T> tStateTransition : sinkState.getStateTransitions()) {__				if (tStateTransition.getAction() == StateTransitionAction.PROCEED) {_					State<T> targetState = tStateTransition.getTargetState()__					boolean remove = false__					if (targetState.isStop()) {_						for (Tuple2<IterativeCondition<T>, String> notCondition : currentNotCondition) {_							if (targetState.getName().equals(notCondition.f1)) {_								remove = true__							}_						}_					} else {_						targetState = copyWithoutTransitiveNots(tStateTransition.getTargetState())__					}__					if (!remove) {_						copyOfSink.addStateTransition(tStateTransition.getAction(), targetState, tStateTransition.getCondition())__					}_				} else {_					copyOfSink.addStateTransition(_							tStateTransition.getAction(),_							tStateTransition.getTargetState().equals(tStateTransition.getSourceState())_									? copyOfSink_									: tStateTransition.getTargetState(),_							tStateTransition.getCondition()_					)__				}__			}_			return copyOfSink__		};this,method,creates,an,alternative,state,that,is,target,for,take,transition,from,an,optional,state,accepting,an,event,in,optional,state,discards,all,not,patterns,that,were,present,before,it,p,e,g,for,a,pattern,begin,a,not,followed,by,b,followed,by,any,c,optional,followed,by,any,d,a,sequence,like,a,c,b,d,is,a,valid,match,but,a,b,d,is,not,p,b,notice,b,this,method,creates,copy,only,if,it,necessary,param,sink,state,a,state,to,create,copy,without,transitive,nots,return,the,copy,of,the,state,itself,if,no,modifications,were,needed;private,state,t,copy,without,transitive,nots,final,state,t,sink,state,final,list,tuple2,iterative,condition,t,string,current,not,condition,get,current,not,condition,if,current,not,condition,is,empty,current,pattern,get,quantifier,has,property,quantifier,quantifier,property,optional,return,sink,state,final,state,t,copy,of,sink,create,state,sink,state,get,name,sink,state,get,state,type,for,state,transition,t,t,state,transition,sink,state,get,state,transitions,if,t,state,transition,get,action,state,transition,action,proceed,state,t,target,state,t,state,transition,get,target,state,boolean,remove,false,if,target,state,is,stop,for,tuple2,iterative,condition,t,string,not,condition,current,not,condition,if,target,state,get,name,equals,not,condition,f1,remove,true,else,target,state,copy,without,transitive,nots,t,state,transition,get,target,state,if,remove,copy,of,sink,add,state,transition,t,state,transition,get,action,target,state,t,state,transition,get,condition,else,copy,of,sink,add,state,transition,t,state,transition,get,action,t,state,transition,get,target,state,equals,t,state,transition,get,source,state,copy,of,sink,t,state,transition,get,target,state,t,state,transition,get,condition,return,copy,of,sink
NFACompiler -> NFAFactoryCompiler -> private State<T> copyWithoutTransitiveNots(final State<T> sinkState);1499937690;This method creates an alternative state that is target for TAKE transition from an optional State._Accepting an event in optional State discards all not Patterns that were present before it.__<p>E.g for a Pattern begin("a").notFollowedBy("b").followedByAny("c").optional().followedByAny("d")_a sequence like : {a c b d} is a valid match, but {a b d} is not.__<p><b>NOTICE:</b> This method creates copy only if it necessary.__@param sinkState a state to create copy without transitive nots_@return the copy of the state itself if no modifications were needed;private State<T> copyWithoutTransitiveNots(final State<T> sinkState) {_			final List<Tuple2<IterativeCondition<T>, String>> currentNotCondition = getCurrentNotCondition()___			if (currentNotCondition.isEmpty() ||_				!currentPattern.getQuantifier().hasProperty(Quantifier.QuantifierProperty.OPTIONAL)) {_				_				_				return sinkState__			}__			final State<T> copyOfSink = createState(sinkState.getName(), sinkState.getStateType())___			for (StateTransition<T> tStateTransition : sinkState.getStateTransitions()) {__				if (tStateTransition.getAction() == StateTransitionAction.PROCEED) {_					State<T> targetState = tStateTransition.getTargetState()__					boolean remove = false__					if (targetState.isStop()) {_						for (Tuple2<IterativeCondition<T>, String> notCondition : currentNotCondition) {_							if (targetState.getName().equals(notCondition.f1)) {_								remove = true__							}_						}_					} else {_						targetState = copyWithoutTransitiveNots(tStateTransition.getTargetState())__					}__					if (!remove) {_						copyOfSink.addStateTransition(tStateTransition.getAction(), targetState, tStateTransition.getCondition())__					}_				} else {_					copyOfSink.addStateTransition(_							tStateTransition.getAction(),_							tStateTransition.getTargetState().equals(tStateTransition.getSourceState())_									? copyOfSink_									: tStateTransition.getTargetState(),_							tStateTransition.getCondition()_					)__				}__			}_			return copyOfSink__		};this,method,creates,an,alternative,state,that,is,target,for,take,transition,from,an,optional,state,accepting,an,event,in,optional,state,discards,all,not,patterns,that,were,present,before,it,p,e,g,for,a,pattern,begin,a,not,followed,by,b,followed,by,any,c,optional,followed,by,any,d,a,sequence,like,a,c,b,d,is,a,valid,match,but,a,b,d,is,not,p,b,notice,b,this,method,creates,copy,only,if,it,necessary,param,sink,state,a,state,to,create,copy,without,transitive,nots,return,the,copy,of,the,state,itself,if,no,modifications,were,needed;private,state,t,copy,without,transitive,nots,final,state,t,sink,state,final,list,tuple2,iterative,condition,t,string,current,not,condition,get,current,not,condition,if,current,not,condition,is,empty,current,pattern,get,quantifier,has,property,quantifier,quantifier,property,optional,return,sink,state,final,state,t,copy,of,sink,create,state,sink,state,get,name,sink,state,get,state,type,for,state,transition,t,t,state,transition,sink,state,get,state,transitions,if,t,state,transition,get,action,state,transition,action,proceed,state,t,target,state,t,state,transition,get,target,state,boolean,remove,false,if,target,state,is,stop,for,tuple2,iterative,condition,t,string,not,condition,current,not,condition,if,target,state,get,name,equals,not,condition,f1,remove,true,else,target,state,copy,without,transitive,nots,t,state,transition,get,target,state,if,remove,copy,of,sink,add,state,transition,t,state,transition,get,action,target,state,t,state,transition,get,condition,else,copy,of,sink,add,state,transition,t,state,transition,get,action,t,state,transition,get,target,state,equals,t,state,transition,get,source,state,copy,of,sink,t,state,transition,get,target,state,t,state,transition,get,condition,return,copy,of,sink
NFACompiler -> NFAFactoryCompiler -> private State<T> copyWithoutTransitiveNots(final State<T> sinkState);1500021711;This method creates an alternative state that is target for TAKE transition from an optional State._Accepting an event in optional State discards all not Patterns that were present before it.__<p>E.g for a Pattern begin("a").notFollowedBy("b").followedByAny("c").optional().followedByAny("d")_a sequence like : {a c b d} is a valid match, but {a b d} is not.__<p><b>NOTICE:</b> This method creates copy only if it necessary.__@param sinkState a state to create copy without transitive nots_@return the copy of the state itself if no modifications were needed;private State<T> copyWithoutTransitiveNots(final State<T> sinkState) {_			final List<Tuple2<IterativeCondition<T>, String>> currentNotCondition = getCurrentNotCondition()___			if (currentNotCondition.isEmpty() ||_				!currentPattern.getQuantifier().hasProperty(Quantifier.QuantifierProperty.OPTIONAL)) {_				_				_				return sinkState__			}__			final State<T> copyOfSink = createState(sinkState.getName(), sinkState.getStateType())___			for (StateTransition<T> tStateTransition : sinkState.getStateTransitions()) {__				if (tStateTransition.getAction() == StateTransitionAction.PROCEED) {_					State<T> targetState = tStateTransition.getTargetState()__					boolean remove = false__					if (targetState.isStop()) {_						for (Tuple2<IterativeCondition<T>, String> notCondition : currentNotCondition) {_							if (targetState.getName().equals(notCondition.f1)) {_								remove = true__							}_						}_					} else {_						targetState = copyWithoutTransitiveNots(tStateTransition.getTargetState())__					}__					if (!remove) {_						copyOfSink.addStateTransition(tStateTransition.getAction(), targetState, tStateTransition.getCondition())__					}_				} else {_					copyOfSink.addStateTransition(_							tStateTransition.getAction(),_							tStateTransition.getTargetState().equals(tStateTransition.getSourceState())_									? copyOfSink_									: tStateTransition.getTargetState(),_							tStateTransition.getCondition()_					)__				}__			}_			return copyOfSink__		};this,method,creates,an,alternative,state,that,is,target,for,take,transition,from,an,optional,state,accepting,an,event,in,optional,state,discards,all,not,patterns,that,were,present,before,it,p,e,g,for,a,pattern,begin,a,not,followed,by,b,followed,by,any,c,optional,followed,by,any,d,a,sequence,like,a,c,b,d,is,a,valid,match,but,a,b,d,is,not,p,b,notice,b,this,method,creates,copy,only,if,it,necessary,param,sink,state,a,state,to,create,copy,without,transitive,nots,return,the,copy,of,the,state,itself,if,no,modifications,were,needed;private,state,t,copy,without,transitive,nots,final,state,t,sink,state,final,list,tuple2,iterative,condition,t,string,current,not,condition,get,current,not,condition,if,current,not,condition,is,empty,current,pattern,get,quantifier,has,property,quantifier,quantifier,property,optional,return,sink,state,final,state,t,copy,of,sink,create,state,sink,state,get,name,sink,state,get,state,type,for,state,transition,t,t,state,transition,sink,state,get,state,transitions,if,t,state,transition,get,action,state,transition,action,proceed,state,t,target,state,t,state,transition,get,target,state,boolean,remove,false,if,target,state,is,stop,for,tuple2,iterative,condition,t,string,not,condition,current,not,condition,if,target,state,get,name,equals,not,condition,f1,remove,true,else,target,state,copy,without,transitive,nots,t,state,transition,get,target,state,if,remove,copy,of,sink,add,state,transition,t,state,transition,get,action,target,state,t,state,transition,get,condition,else,copy,of,sink,add,state,transition,t,state,transition,get,action,t,state,transition,get,target,state,equals,t,state,transition,get,source,state,copy,of,sink,t,state,transition,get,target,state,t,state,transition,get,condition,return,copy,of,sink
NFACompiler -> NFAFactoryCompiler -> private State<T> copyWithoutTransitiveNots(final State<T> sinkState);1501592283;This method creates an alternative state that is target for TAKE transition from an optional State._Accepting an event in optional State discards all not Patterns that were present before it.__<p>E.g for a Pattern begin("a").notFollowedBy("b").followedByAny("c").optional().followedByAny("d")_a sequence like : {a c b d} is a valid match, but {a b d} is not.__<p><b>NOTICE:</b> This method creates copy only if it necessary.__@param sinkState a state to create copy without transitive nots_@return the copy of the state itself if no modifications were needed;private State<T> copyWithoutTransitiveNots(final State<T> sinkState) {_			final List<Tuple2<IterativeCondition<T>, String>> currentNotCondition = getCurrentNotCondition()___			if (currentNotCondition.isEmpty() ||_				!currentPattern.getQuantifier().hasProperty(Quantifier.QuantifierProperty.OPTIONAL)) {_				_				_				return sinkState__			}__			final State<T> copyOfSink = createState(sinkState.getName(), sinkState.getStateType())___			for (StateTransition<T> tStateTransition : sinkState.getStateTransitions()) {__				if (tStateTransition.getAction() == StateTransitionAction.PROCEED) {_					State<T> targetState = tStateTransition.getTargetState()__					boolean remove = false__					if (targetState.isStop()) {_						for (Tuple2<IterativeCondition<T>, String> notCondition : currentNotCondition) {_							if (targetState.getName().equals(notCondition.f1)) {_								remove = true__							}_						}_					} else {_						targetState = copyWithoutTransitiveNots(tStateTransition.getTargetState())__					}__					if (!remove) {_						copyOfSink.addStateTransition(tStateTransition.getAction(), targetState, tStateTransition.getCondition())__					}_				} else {_					copyOfSink.addStateTransition(_							tStateTransition.getAction(),_							tStateTransition.getTargetState().equals(tStateTransition.getSourceState())_									? copyOfSink_									: tStateTransition.getTargetState(),_							tStateTransition.getCondition()_					)__				}__			}_			return copyOfSink__		};this,method,creates,an,alternative,state,that,is,target,for,take,transition,from,an,optional,state,accepting,an,event,in,optional,state,discards,all,not,patterns,that,were,present,before,it,p,e,g,for,a,pattern,begin,a,not,followed,by,b,followed,by,any,c,optional,followed,by,any,d,a,sequence,like,a,c,b,d,is,a,valid,match,but,a,b,d,is,not,p,b,notice,b,this,method,creates,copy,only,if,it,necessary,param,sink,state,a,state,to,create,copy,without,transitive,nots,return,the,copy,of,the,state,itself,if,no,modifications,were,needed;private,state,t,copy,without,transitive,nots,final,state,t,sink,state,final,list,tuple2,iterative,condition,t,string,current,not,condition,get,current,not,condition,if,current,not,condition,is,empty,current,pattern,get,quantifier,has,property,quantifier,quantifier,property,optional,return,sink,state,final,state,t,copy,of,sink,create,state,sink,state,get,name,sink,state,get,state,type,for,state,transition,t,t,state,transition,sink,state,get,state,transitions,if,t,state,transition,get,action,state,transition,action,proceed,state,t,target,state,t,state,transition,get,target,state,boolean,remove,false,if,target,state,is,stop,for,tuple2,iterative,condition,t,string,not,condition,current,not,condition,if,target,state,get,name,equals,not,condition,f1,remove,true,else,target,state,copy,without,transitive,nots,t,state,transition,get,target,state,if,remove,copy,of,sink,add,state,transition,t,state,transition,get,action,target,state,t,state,transition,get,condition,else,copy,of,sink,add,state,transition,t,state,transition,get,action,t,state,transition,get,target,state,equals,t,state,transition,get,source,state,copy,of,sink,t,state,transition,get,target,state,t,state,transition,get,condition,return,copy,of,sink
NFACompiler -> NFAFactoryCompiler -> private State<T> copyWithoutTransitiveNots(final State<T> sinkState);1502422141;This method creates an alternative state that is target for TAKE transition from an optional State._Accepting an event in optional State discards all not Patterns that were present before it.__<p>E.g for a Pattern begin("a").notFollowedBy("b").followedByAny("c").optional().followedByAny("d")_a sequence like : {a c b d} is a valid match, but {a b d} is not.__<p><b>NOTICE:</b> This method creates copy only if it necessary.__@param sinkState a state to create copy without transitive nots_@return the copy of the state itself if no modifications were needed;private State<T> copyWithoutTransitiveNots(final State<T> sinkState) {_			final List<Tuple2<IterativeCondition<T>, String>> currentNotCondition = getCurrentNotCondition()___			if (currentNotCondition.isEmpty() ||_				!currentPattern.getQuantifier().hasProperty(Quantifier.QuantifierProperty.OPTIONAL)) {_				_				_				return sinkState__			}__			final State<T> copyOfSink = createState(sinkState.getName(), sinkState.getStateType())___			for (StateTransition<T> tStateTransition : sinkState.getStateTransitions()) {__				if (tStateTransition.getAction() == StateTransitionAction.PROCEED) {_					State<T> targetState = tStateTransition.getTargetState()__					boolean remove = false__					if (targetState.isStop()) {_						for (Tuple2<IterativeCondition<T>, String> notCondition : currentNotCondition) {_							if (targetState.getName().equals(notCondition.f1)) {_								remove = true__							}_						}_					} else {_						targetState = copyWithoutTransitiveNots(tStateTransition.getTargetState())__					}__					if (!remove) {_						copyOfSink.addStateTransition(tStateTransition.getAction(), targetState, tStateTransition.getCondition())__					}_				} else {_					copyOfSink.addStateTransition(_							tStateTransition.getAction(),_							tStateTransition.getTargetState().equals(tStateTransition.getSourceState())_									? copyOfSink_									: tStateTransition.getTargetState(),_							tStateTransition.getCondition()_					)__				}__			}_			return copyOfSink__		};this,method,creates,an,alternative,state,that,is,target,for,take,transition,from,an,optional,state,accepting,an,event,in,optional,state,discards,all,not,patterns,that,were,present,before,it,p,e,g,for,a,pattern,begin,a,not,followed,by,b,followed,by,any,c,optional,followed,by,any,d,a,sequence,like,a,c,b,d,is,a,valid,match,but,a,b,d,is,not,p,b,notice,b,this,method,creates,copy,only,if,it,necessary,param,sink,state,a,state,to,create,copy,without,transitive,nots,return,the,copy,of,the,state,itself,if,no,modifications,were,needed;private,state,t,copy,without,transitive,nots,final,state,t,sink,state,final,list,tuple2,iterative,condition,t,string,current,not,condition,get,current,not,condition,if,current,not,condition,is,empty,current,pattern,get,quantifier,has,property,quantifier,quantifier,property,optional,return,sink,state,final,state,t,copy,of,sink,create,state,sink,state,get,name,sink,state,get,state,type,for,state,transition,t,t,state,transition,sink,state,get,state,transitions,if,t,state,transition,get,action,state,transition,action,proceed,state,t,target,state,t,state,transition,get,target,state,boolean,remove,false,if,target,state,is,stop,for,tuple2,iterative,condition,t,string,not,condition,current,not,condition,if,target,state,get,name,equals,not,condition,f1,remove,true,else,target,state,copy,without,transitive,nots,t,state,transition,get,target,state,if,remove,copy,of,sink,add,state,transition,t,state,transition,get,action,target,state,t,state,transition,get,condition,else,copy,of,sink,add,state,transition,t,state,transition,get,action,t,state,transition,get,target,state,equals,t,state,transition,get,source,state,copy,of,sink,t,state,transition,get,target,state,t,state,transition,get,condition,return,copy,of,sink
NFACompiler -> NFAFactoryCompiler -> private State<T> copyWithoutTransitiveNots(final State<T> sinkState);1503588494;This method creates an alternative state that is target for TAKE transition from an optional State._Accepting an event in optional State discards all not Patterns that were present before it.__<p>E.g for a Pattern begin("a").notFollowedBy("b").followedByAny("c").optional().followedByAny("d")_a sequence like : {a c b d} is a valid match, but {a b d} is not.__<p><b>NOTICE:</b> This method creates copy only if it necessary.__@param sinkState a state to create copy without transitive nots_@return the copy of the state itself if no modifications were needed;private State<T> copyWithoutTransitiveNots(final State<T> sinkState) {_			final List<Tuple2<IterativeCondition<T>, String>> currentNotCondition = getCurrentNotCondition()___			if (currentNotCondition.isEmpty() ||_				!currentPattern.getQuantifier().hasProperty(Quantifier.QuantifierProperty.OPTIONAL)) {_				_				_				return sinkState__			}__			final State<T> copyOfSink = createState(sinkState.getName(), sinkState.getStateType())___			for (StateTransition<T> tStateTransition : sinkState.getStateTransitions()) {__				if (tStateTransition.getAction() == StateTransitionAction.PROCEED) {_					State<T> targetState = tStateTransition.getTargetState()__					boolean remove = false__					if (targetState.isStop()) {_						for (Tuple2<IterativeCondition<T>, String> notCondition : currentNotCondition) {_							if (targetState.getName().equals(notCondition.f1)) {_								remove = true__							}_						}_					} else {_						targetState = copyWithoutTransitiveNots(tStateTransition.getTargetState())__					}__					if (!remove) {_						copyOfSink.addStateTransition(tStateTransition.getAction(), targetState, tStateTransition.getCondition())__					}_				} else {_					copyOfSink.addStateTransition(_							tStateTransition.getAction(),_							tStateTransition.getTargetState().equals(tStateTransition.getSourceState())_									? copyOfSink_									: tStateTransition.getTargetState(),_							tStateTransition.getCondition()_					)__				}__			}_			return copyOfSink__		};this,method,creates,an,alternative,state,that,is,target,for,take,transition,from,an,optional,state,accepting,an,event,in,optional,state,discards,all,not,patterns,that,were,present,before,it,p,e,g,for,a,pattern,begin,a,not,followed,by,b,followed,by,any,c,optional,followed,by,any,d,a,sequence,like,a,c,b,d,is,a,valid,match,but,a,b,d,is,not,p,b,notice,b,this,method,creates,copy,only,if,it,necessary,param,sink,state,a,state,to,create,copy,without,transitive,nots,return,the,copy,of,the,state,itself,if,no,modifications,were,needed;private,state,t,copy,without,transitive,nots,final,state,t,sink,state,final,list,tuple2,iterative,condition,t,string,current,not,condition,get,current,not,condition,if,current,not,condition,is,empty,current,pattern,get,quantifier,has,property,quantifier,quantifier,property,optional,return,sink,state,final,state,t,copy,of,sink,create,state,sink,state,get,name,sink,state,get,state,type,for,state,transition,t,t,state,transition,sink,state,get,state,transitions,if,t,state,transition,get,action,state,transition,action,proceed,state,t,target,state,t,state,transition,get,target,state,boolean,remove,false,if,target,state,is,stop,for,tuple2,iterative,condition,t,string,not,condition,current,not,condition,if,target,state,get,name,equals,not,condition,f1,remove,true,else,target,state,copy,without,transitive,nots,t,state,transition,get,target,state,if,remove,copy,of,sink,add,state,transition,t,state,transition,get,action,target,state,t,state,transition,get,condition,else,copy,of,sink,add,state,transition,t,state,transition,get,action,t,state,transition,get,target,state,equals,t,state,transition,get,source,state,copy,of,sink,t,state,transition,get,target,state,t,state,transition,get,condition,return,copy,of,sink
NFACompiler -> NFAFactoryCompiler -> private State<T> copyWithoutTransitiveNots(final State<T> sinkState);1518008111;This method creates an alternative state that is target for TAKE transition from an optional State._Accepting an event in optional State discards all not Patterns that were present before it.__<p>E.g for a Pattern begin("a").notFollowedBy("b").followedByAny("c").optional().followedByAny("d")_a sequence like : {a c b d} is a valid match, but {a b d} is not.__<p><b>NOTICE:</b> This method creates copy only if it necessary.__@param sinkState a state to create copy without transitive nots_@return the copy of the state itself if no modifications were needed;private State<T> copyWithoutTransitiveNots(final State<T> sinkState) {_			final List<Tuple2<IterativeCondition<T>, String>> currentNotCondition = getCurrentNotCondition()___			if (currentNotCondition.isEmpty() ||_				!currentPattern.getQuantifier().hasProperty(Quantifier.QuantifierProperty.OPTIONAL)) {_				_				_				return sinkState__			}__			final State<T> copyOfSink = createState(sinkState.getName(), sinkState.getStateType())___			for (StateTransition<T> tStateTransition : sinkState.getStateTransitions()) {__				if (tStateTransition.getAction() == StateTransitionAction.PROCEED) {_					State<T> targetState = tStateTransition.getTargetState()__					boolean remove = false__					if (targetState.isStop()) {_						for (Tuple2<IterativeCondition<T>, String> notCondition : currentNotCondition) {_							if (targetState.getName().equals(notCondition.f1)) {_								remove = true__							}_						}_					} else {_						targetState = copyWithoutTransitiveNots(tStateTransition.getTargetState())__					}__					if (!remove) {_						copyOfSink.addStateTransition(tStateTransition.getAction(), targetState, tStateTransition.getCondition())__					}_				} else {_					copyOfSink.addStateTransition(_							tStateTransition.getAction(),_							tStateTransition.getTargetState().equals(tStateTransition.getSourceState())_									? copyOfSink_									: tStateTransition.getTargetState(),_							tStateTransition.getCondition()_					)__				}__			}_			return copyOfSink__		};this,method,creates,an,alternative,state,that,is,target,for,take,transition,from,an,optional,state,accepting,an,event,in,optional,state,discards,all,not,patterns,that,were,present,before,it,p,e,g,for,a,pattern,begin,a,not,followed,by,b,followed,by,any,c,optional,followed,by,any,d,a,sequence,like,a,c,b,d,is,a,valid,match,but,a,b,d,is,not,p,b,notice,b,this,method,creates,copy,only,if,it,necessary,param,sink,state,a,state,to,create,copy,without,transitive,nots,return,the,copy,of,the,state,itself,if,no,modifications,were,needed;private,state,t,copy,without,transitive,nots,final,state,t,sink,state,final,list,tuple2,iterative,condition,t,string,current,not,condition,get,current,not,condition,if,current,not,condition,is,empty,current,pattern,get,quantifier,has,property,quantifier,quantifier,property,optional,return,sink,state,final,state,t,copy,of,sink,create,state,sink,state,get,name,sink,state,get,state,type,for,state,transition,t,t,state,transition,sink,state,get,state,transitions,if,t,state,transition,get,action,state,transition,action,proceed,state,t,target,state,t,state,transition,get,target,state,boolean,remove,false,if,target,state,is,stop,for,tuple2,iterative,condition,t,string,not,condition,current,not,condition,if,target,state,get,name,equals,not,condition,f1,remove,true,else,target,state,copy,without,transitive,nots,t,state,transition,get,target,state,if,remove,copy,of,sink,add,state,transition,t,state,transition,get,action,target,state,t,state,transition,get,condition,else,copy,of,sink,add,state,transition,t,state,transition,get,action,t,state,transition,get,target,state,equals,t,state,transition,get,source,state,copy,of,sink,t,state,transition,get,target,state,t,state,transition,get,condition,return,copy,of,sink
NFACompiler -> NFAFactoryCompiler -> private State<T> copyWithoutTransitiveNots(final State<T> sinkState);1527863170;This method creates an alternative state that is target for TAKE transition from an optional State._Accepting an event in optional State discards all not Patterns that were present before it.__<p>E.g for a Pattern begin("a").notFollowedBy("b").followedByAny("c").optional().followedByAny("d")_a sequence like : {a c b d} is a valid match, but {a b d} is not.__<p><b>NOTICE:</b> This method creates copy only if it necessary.__@param sinkState a state to create copy without transitive nots_@return the copy of the state itself if no modifications were needed;private State<T> copyWithoutTransitiveNots(final State<T> sinkState) {_			final List<Tuple2<IterativeCondition<T>, String>> currentNotCondition = getCurrentNotCondition()___			if (currentNotCondition.isEmpty() ||_				!currentPattern.getQuantifier().hasProperty(Quantifier.QuantifierProperty.OPTIONAL)) {_				_				_				return sinkState__			}__			final State<T> copyOfSink = createState(sinkState.getName(), sinkState.getStateType())___			for (StateTransition<T> tStateTransition : sinkState.getStateTransitions()) {__				if (tStateTransition.getAction() == StateTransitionAction.PROCEED) {_					State<T> targetState = tStateTransition.getTargetState()__					boolean remove = false__					if (targetState.isStop()) {_						for (Tuple2<IterativeCondition<T>, String> notCondition : currentNotCondition) {_							if (targetState.getName().equals(notCondition.f1)) {_								remove = true__							}_						}_					} else {_						targetState = copyWithoutTransitiveNots(tStateTransition.getTargetState())__					}__					if (!remove) {_						copyOfSink.addStateTransition(tStateTransition.getAction(), targetState, tStateTransition.getCondition())__					}_				} else {_					copyOfSink.addStateTransition(_							tStateTransition.getAction(),_							tStateTransition.getTargetState().equals(tStateTransition.getSourceState())_									? copyOfSink_									: tStateTransition.getTargetState(),_							tStateTransition.getCondition()_					)__				}__			}_			return copyOfSink__		};this,method,creates,an,alternative,state,that,is,target,for,take,transition,from,an,optional,state,accepting,an,event,in,optional,state,discards,all,not,patterns,that,were,present,before,it,p,e,g,for,a,pattern,begin,a,not,followed,by,b,followed,by,any,c,optional,followed,by,any,d,a,sequence,like,a,c,b,d,is,a,valid,match,but,a,b,d,is,not,p,b,notice,b,this,method,creates,copy,only,if,it,necessary,param,sink,state,a,state,to,create,copy,without,transitive,nots,return,the,copy,of,the,state,itself,if,no,modifications,were,needed;private,state,t,copy,without,transitive,nots,final,state,t,sink,state,final,list,tuple2,iterative,condition,t,string,current,not,condition,get,current,not,condition,if,current,not,condition,is,empty,current,pattern,get,quantifier,has,property,quantifier,quantifier,property,optional,return,sink,state,final,state,t,copy,of,sink,create,state,sink,state,get,name,sink,state,get,state,type,for,state,transition,t,t,state,transition,sink,state,get,state,transitions,if,t,state,transition,get,action,state,transition,action,proceed,state,t,target,state,t,state,transition,get,target,state,boolean,remove,false,if,target,state,is,stop,for,tuple2,iterative,condition,t,string,not,condition,current,not,condition,if,target,state,get,name,equals,not,condition,f1,remove,true,else,target,state,copy,without,transitive,nots,t,state,transition,get,target,state,if,remove,copy,of,sink,add,state,transition,t,state,transition,get,action,target,state,t,state,transition,get,condition,else,copy,of,sink,add,state,transition,t,state,transition,get,action,t,state,transition,get,target,state,equals,t,state,transition,get,source,state,copy,of,sink,t,state,transition,get,target,state,t,state,transition,get,condition,return,copy,of,sink
NFACompiler -> NFAFactoryCompiler -> private State<T> copyWithoutTransitiveNots(final State<T> sinkState);1528989005;This method creates an alternative state that is target for TAKE transition from an optional State._Accepting an event in optional State discards all not Patterns that were present before it.__<p>E.g for a Pattern begin("a").notFollowedBy("b").followedByAny("c").optional().followedByAny("d")_a sequence like : {a c b d} is a valid match, but {a b d} is not.__<p><b>NOTICE:</b> This method creates copy only if it necessary.__@param sinkState a state to create copy without transitive nots_@return the copy of the state itself if no modifications were needed;private State<T> copyWithoutTransitiveNots(final State<T> sinkState) {_			final List<Tuple2<IterativeCondition<T>, String>> currentNotCondition = getCurrentNotCondition()___			if (currentNotCondition.isEmpty() ||_				!currentPattern.getQuantifier().hasProperty(Quantifier.QuantifierProperty.OPTIONAL)) {_				_				_				return sinkState__			}__			final State<T> copyOfSink = createState(sinkState.getName(), sinkState.getStateType())___			for (StateTransition<T> tStateTransition : sinkState.getStateTransitions()) {__				if (tStateTransition.getAction() == StateTransitionAction.PROCEED) {_					State<T> targetState = tStateTransition.getTargetState()__					boolean remove = false__					if (targetState.isStop()) {_						for (Tuple2<IterativeCondition<T>, String> notCondition : currentNotCondition) {_							if (targetState.getName().equals(notCondition.f1)) {_								remove = true__							}_						}_					} else {_						targetState = copyWithoutTransitiveNots(tStateTransition.getTargetState())__					}__					if (!remove) {_						copyOfSink.addStateTransition(tStateTransition.getAction(), targetState, tStateTransition.getCondition())__					}_				} else {_					copyOfSink.addStateTransition(_							tStateTransition.getAction(),_							tStateTransition.getTargetState().equals(tStateTransition.getSourceState())_									? copyOfSink_									: tStateTransition.getTargetState(),_							tStateTransition.getCondition()_					)__				}__			}_			return copyOfSink__		};this,method,creates,an,alternative,state,that,is,target,for,take,transition,from,an,optional,state,accepting,an,event,in,optional,state,discards,all,not,patterns,that,were,present,before,it,p,e,g,for,a,pattern,begin,a,not,followed,by,b,followed,by,any,c,optional,followed,by,any,d,a,sequence,like,a,c,b,d,is,a,valid,match,but,a,b,d,is,not,p,b,notice,b,this,method,creates,copy,only,if,it,necessary,param,sink,state,a,state,to,create,copy,without,transitive,nots,return,the,copy,of,the,state,itself,if,no,modifications,were,needed;private,state,t,copy,without,transitive,nots,final,state,t,sink,state,final,list,tuple2,iterative,condition,t,string,current,not,condition,get,current,not,condition,if,current,not,condition,is,empty,current,pattern,get,quantifier,has,property,quantifier,quantifier,property,optional,return,sink,state,final,state,t,copy,of,sink,create,state,sink,state,get,name,sink,state,get,state,type,for,state,transition,t,t,state,transition,sink,state,get,state,transitions,if,t,state,transition,get,action,state,transition,action,proceed,state,t,target,state,t,state,transition,get,target,state,boolean,remove,false,if,target,state,is,stop,for,tuple2,iterative,condition,t,string,not,condition,current,not,condition,if,target,state,get,name,equals,not,condition,f1,remove,true,else,target,state,copy,without,transitive,nots,t,state,transition,get,target,state,if,remove,copy,of,sink,add,state,transition,t,state,transition,get,action,target,state,t,state,transition,get,condition,else,copy,of,sink,add,state,transition,t,state,transition,get,action,t,state,transition,get,target,state,equals,t,state,transition,get,source,state,copy,of,sink,t,state,transition,get,target,state,t,state,transition,get,condition,return,copy,of,sink
NFACompiler -> NFAFactoryCompiler -> private State<T> copyWithoutTransitiveNots(final State<T> sinkState);1538745898;This method creates an alternative state that is target for TAKE transition from an optional State._Accepting an event in optional State discards all not Patterns that were present before it.__<p>E.g for a Pattern begin("a").notFollowedBy("b").followedByAny("c").optional().followedByAny("d")_a sequence like : {a c b d} is a valid match, but {a b d} is not.__<p><b>NOTICE:</b> This method creates copy only if it necessary.__@param sinkState a state to create copy without transitive nots_@return the copy of the state itself if no modifications were needed;private State<T> copyWithoutTransitiveNots(final State<T> sinkState) {_			final List<Tuple2<IterativeCondition<T>, String>> currentNotCondition = getCurrentNotCondition()___			if (currentNotCondition.isEmpty() ||_				!currentPattern.getQuantifier().hasProperty(Quantifier.QuantifierProperty.OPTIONAL)) {_				_				_				return sinkState__			}__			final State<T> copyOfSink = createState(sinkState.getName(), sinkState.getStateType())___			for (StateTransition<T> tStateTransition : sinkState.getStateTransitions()) {__				if (tStateTransition.getAction() == StateTransitionAction.PROCEED) {_					State<T> targetState = tStateTransition.getTargetState()__					boolean remove = false__					if (targetState.isStop()) {_						for (Tuple2<IterativeCondition<T>, String> notCondition : currentNotCondition) {_							if (targetState.getName().equals(notCondition.f1)) {_								remove = true__							}_						}_					} else {_						targetState = copyWithoutTransitiveNots(tStateTransition.getTargetState())__					}__					if (!remove) {_						copyOfSink.addStateTransition(tStateTransition.getAction(), targetState, tStateTransition.getCondition())__					}_				} else {_					copyOfSink.addStateTransition(_							tStateTransition.getAction(),_							tStateTransition.getTargetState().equals(tStateTransition.getSourceState())_									? copyOfSink_									: tStateTransition.getTargetState(),_							tStateTransition.getCondition()_					)__				}__			}_			return copyOfSink__		};this,method,creates,an,alternative,state,that,is,target,for,take,transition,from,an,optional,state,accepting,an,event,in,optional,state,discards,all,not,patterns,that,were,present,before,it,p,e,g,for,a,pattern,begin,a,not,followed,by,b,followed,by,any,c,optional,followed,by,any,d,a,sequence,like,a,c,b,d,is,a,valid,match,but,a,b,d,is,not,p,b,notice,b,this,method,creates,copy,only,if,it,necessary,param,sink,state,a,state,to,create,copy,without,transitive,nots,return,the,copy,of,the,state,itself,if,no,modifications,were,needed;private,state,t,copy,without,transitive,nots,final,state,t,sink,state,final,list,tuple2,iterative,condition,t,string,current,not,condition,get,current,not,condition,if,current,not,condition,is,empty,current,pattern,get,quantifier,has,property,quantifier,quantifier,property,optional,return,sink,state,final,state,t,copy,of,sink,create,state,sink,state,get,name,sink,state,get,state,type,for,state,transition,t,t,state,transition,sink,state,get,state,transitions,if,t,state,transition,get,action,state,transition,action,proceed,state,t,target,state,t,state,transition,get,target,state,boolean,remove,false,if,target,state,is,stop,for,tuple2,iterative,condition,t,string,not,condition,current,not,condition,if,target,state,get,name,equals,not,condition,f1,remove,true,else,target,state,copy,without,transitive,nots,t,state,transition,get,target,state,if,remove,copy,of,sink,add,state,transition,t,state,transition,get,action,target,state,t,state,transition,get,condition,else,copy,of,sink,add,state,transition,t,state,transition,get,action,t,state,transition,get,target,state,equals,t,state,transition,get,source,state,copy,of,sink,t,state,transition,get,target,state,t,state,transition,get,condition,return,copy,of,sink
NFACompiler -> NFAFactoryCompiler -> private State<T> copyWithoutTransitiveNots(final State<T> sinkState);1542293931;This method creates an alternative state that is target for TAKE transition from an optional State._Accepting an event in optional State discards all not Patterns that were present before it.__<p>E.g for a Pattern begin("a").notFollowedBy("b").followedByAny("c").optional().followedByAny("d")_a sequence like : {a c b d} is a valid match, but {a b d} is not.__<p><b>NOTICE:</b> This method creates copy only if it necessary.__@param sinkState a state to create copy without transitive nots_@return the copy of the state itself if no modifications were needed;private State<T> copyWithoutTransitiveNots(final State<T> sinkState) {_			final List<Tuple2<IterativeCondition<T>, String>> currentNotCondition = getCurrentNotCondition()___			if (currentNotCondition.isEmpty() ||_				!currentPattern.getQuantifier().hasProperty(Quantifier.QuantifierProperty.OPTIONAL)) {_				_				_				return sinkState__			}__			final State<T> copyOfSink = createState(sinkState.getName(), sinkState.getStateType())___			for (StateTransition<T> tStateTransition : sinkState.getStateTransitions()) {__				if (tStateTransition.getAction() == StateTransitionAction.PROCEED) {_					State<T> targetState = tStateTransition.getTargetState()__					boolean remove = false__					if (targetState.isStop()) {_						for (Tuple2<IterativeCondition<T>, String> notCondition : currentNotCondition) {_							if (targetState.getName().equals(notCondition.f1)) {_								remove = true__							}_						}_					} else {_						targetState = copyWithoutTransitiveNots(tStateTransition.getTargetState())__					}__					if (!remove) {_						copyOfSink.addStateTransition(tStateTransition.getAction(), targetState, tStateTransition.getCondition())__					}_				} else {_					copyOfSink.addStateTransition(_							tStateTransition.getAction(),_							tStateTransition.getTargetState().equals(tStateTransition.getSourceState())_									? copyOfSink_									: tStateTransition.getTargetState(),_							tStateTransition.getCondition()_					)__				}__			}_			return copyOfSink__		};this,method,creates,an,alternative,state,that,is,target,for,take,transition,from,an,optional,state,accepting,an,event,in,optional,state,discards,all,not,patterns,that,were,present,before,it,p,e,g,for,a,pattern,begin,a,not,followed,by,b,followed,by,any,c,optional,followed,by,any,d,a,sequence,like,a,c,b,d,is,a,valid,match,but,a,b,d,is,not,p,b,notice,b,this,method,creates,copy,only,if,it,necessary,param,sink,state,a,state,to,create,copy,without,transitive,nots,return,the,copy,of,the,state,itself,if,no,modifications,were,needed;private,state,t,copy,without,transitive,nots,final,state,t,sink,state,final,list,tuple2,iterative,condition,t,string,current,not,condition,get,current,not,condition,if,current,not,condition,is,empty,current,pattern,get,quantifier,has,property,quantifier,quantifier,property,optional,return,sink,state,final,state,t,copy,of,sink,create,state,sink,state,get,name,sink,state,get,state,type,for,state,transition,t,t,state,transition,sink,state,get,state,transitions,if,t,state,transition,get,action,state,transition,action,proceed,state,t,target,state,t,state,transition,get,target,state,boolean,remove,false,if,target,state,is,stop,for,tuple2,iterative,condition,t,string,not,condition,current,not,condition,if,target,state,get,name,equals,not,condition,f1,remove,true,else,target,state,copy,without,transitive,nots,t,state,transition,get,target,state,if,remove,copy,of,sink,add,state,transition,t,state,transition,get,action,target,state,t,state,transition,get,condition,else,copy,of,sink,add,state,transition,t,state,transition,get,action,t,state,transition,get,target,state,equals,t,state,transition,get,source,state,copy,of,sink,t,state,transition,get,target,state,t,state,transition,get,condition,return,copy,of,sink
NFACompiler -> NFAFactoryCompiler -> private void checkPatternSkipStrategy();1500021711;Check pattern after match skip strategy.;private void checkPatternSkipStrategy() {_			if (afterMatchSkipStrategy.getStrategy() == AfterMatchSkipStrategy.SkipStrategy.SKIP_TO_FIRST ||_				afterMatchSkipStrategy.getStrategy() == AfterMatchSkipStrategy.SkipStrategy.SKIP_TO_LAST) {_				Pattern<T, ?> pattern = currentPattern__				while (pattern.getPrevious() != null && !pattern.getName().equals(afterMatchSkipStrategy.getPatternName())) {_					pattern = pattern.getPrevious()__				}__				_				if (!pattern.getName().equals(afterMatchSkipStrategy.getPatternName())) {_					throw new MalformedPatternException("The pattern name specified in AfterMatchSkipStrategy " +_						"can not be found in the given Pattern")__				}_			}_		};check,pattern,after,match,skip,strategy;private,void,check,pattern,skip,strategy,if,after,match,skip,strategy,get,strategy,after,match,skip,strategy,skip,strategy,after,match,skip,strategy,get,strategy,after,match,skip,strategy,skip,strategy,pattern,t,pattern,current,pattern,while,pattern,get,previous,null,pattern,get,name,equals,after,match,skip,strategy,get,pattern,name,pattern,pattern,get,previous,if,pattern,get,name,equals,after,match,skip,strategy,get,pattern,name,throw,new,malformed,pattern,exception,the,pattern,name,specified,in,after,match,skip,strategy,can,not,be,found,in,the,given,pattern
NFACompiler -> NFAFactoryCompiler -> private void checkPatternSkipStrategy();1518008111;Check pattern after match skip strategy.;private void checkPatternSkipStrategy() {_			if (afterMatchSkipStrategy.getStrategy() == AfterMatchSkipStrategy.SkipStrategy.SKIP_TO_FIRST ||_				afterMatchSkipStrategy.getStrategy() == AfterMatchSkipStrategy.SkipStrategy.SKIP_TO_LAST) {_				Pattern<T, ?> pattern = currentPattern__				while (pattern.getPrevious() != null && !pattern.getName().equals(afterMatchSkipStrategy.getPatternName())) {_					pattern = pattern.getPrevious()__				}__				_				if (!pattern.getName().equals(afterMatchSkipStrategy.getPatternName())) {_					throw new MalformedPatternException("The pattern name specified in AfterMatchSkipStrategy " +_						"can not be found in the given Pattern")__				}_			}_		};check,pattern,after,match,skip,strategy;private,void,check,pattern,skip,strategy,if,after,match,skip,strategy,get,strategy,after,match,skip,strategy,skip,strategy,after,match,skip,strategy,get,strategy,after,match,skip,strategy,skip,strategy,pattern,t,pattern,current,pattern,while,pattern,get,previous,null,pattern,get,name,equals,after,match,skip,strategy,get,pattern,name,pattern,pattern,get,previous,if,pattern,get,name,equals,after,match,skip,strategy,get,pattern,name,throw,new,malformed,pattern,exception,the,pattern,name,specified,in,after,match,skip,strategy,can,not,be,found,in,the,given,pattern
NFACompiler -> NFAFactoryCompiler -> private void checkPatternSkipStrategy();1527863170;Check pattern after match skip strategy.;private void checkPatternSkipStrategy() {_			if (afterMatchSkipStrategy.getStrategy() == AfterMatchSkipStrategy.SkipStrategy.SKIP_TO_FIRST ||_				afterMatchSkipStrategy.getStrategy() == AfterMatchSkipStrategy.SkipStrategy.SKIP_TO_LAST) {_				Pattern<T, ?> pattern = currentPattern__				while (pattern.getPrevious() != null && !pattern.getName().equals(afterMatchSkipStrategy.getPatternName())) {_					pattern = pattern.getPrevious()__				}__				_				if (!pattern.getName().equals(afterMatchSkipStrategy.getPatternName())) {_					throw new MalformedPatternException("The pattern name specified in AfterMatchSkipStrategy " +_						"can not be found in the given Pattern")__				}_			}_		};check,pattern,after,match,skip,strategy;private,void,check,pattern,skip,strategy,if,after,match,skip,strategy,get,strategy,after,match,skip,strategy,skip,strategy,after,match,skip,strategy,get,strategy,after,match,skip,strategy,skip,strategy,pattern,t,pattern,current,pattern,while,pattern,get,previous,null,pattern,get,name,equals,after,match,skip,strategy,get,pattern,name,pattern,pattern,get,previous,if,pattern,get,name,equals,after,match,skip,strategy,get,pattern,name,throw,new,malformed,pattern,exception,the,pattern,name,specified,in,after,match,skip,strategy,can,not,be,found,in,the,given,pattern
NFACompiler -> NFAFactoryCompiler -> private void checkPatternSkipStrategy();1528989005;Check pattern after match skip strategy.;private void checkPatternSkipStrategy() {_			if (afterMatchSkipStrategy.getPatternName().isPresent()) {_				String patternName = afterMatchSkipStrategy.getPatternName().get()__				Pattern<T, ?> pattern = currentPattern__				while (pattern.getPrevious() != null && !pattern.getName().equals(patternName)) {_					pattern = pattern.getPrevious()__				}__				_				if (!pattern.getName().equals(patternName)) {_					throw new MalformedPatternException("The pattern name specified in AfterMatchSkipStrategy " +_						"can not be found in the given Pattern")__				}_			}_		};check,pattern,after,match,skip,strategy;private,void,check,pattern,skip,strategy,if,after,match,skip,strategy,get,pattern,name,is,present,string,pattern,name,after,match,skip,strategy,get,pattern,name,get,pattern,t,pattern,current,pattern,while,pattern,get,previous,null,pattern,get,name,equals,pattern,name,pattern,pattern,get,previous,if,pattern,get,name,equals,pattern,name,throw,new,malformed,pattern,exception,the,pattern,name,specified,in,after,match,skip,strategy,can,not,be,found,in,the,given,pattern
NFACompiler -> NFAFactoryCompiler -> private void checkPatternSkipStrategy();1538745898;Check pattern after match skip strategy.;private void checkPatternSkipStrategy() {_			if (afterMatchSkipStrategy.getPatternName().isPresent()) {_				String patternName = afterMatchSkipStrategy.getPatternName().get()__				Pattern<T, ?> pattern = currentPattern__				while (pattern.getPrevious() != null && !pattern.getName().equals(patternName)) {_					pattern = pattern.getPrevious()__				}__				_				if (!pattern.getName().equals(patternName)) {_					throw new MalformedPatternException("The pattern name specified in AfterMatchSkipStrategy " +_						"can not be found in the given Pattern")__				}_			}_		};check,pattern,after,match,skip,strategy;private,void,check,pattern,skip,strategy,if,after,match,skip,strategy,get,pattern,name,is,present,string,pattern,name,after,match,skip,strategy,get,pattern,name,get,pattern,t,pattern,current,pattern,while,pattern,get,previous,null,pattern,get,name,equals,pattern,name,pattern,pattern,get,previous,if,pattern,get,name,equals,pattern,name,throw,new,malformed,pattern,exception,the,pattern,name,specified,in,after,match,skip,strategy,can,not,be,found,in,the,given,pattern
NFACompiler -> NFAFactoryCompiler -> private void checkPatternSkipStrategy();1542293931;Check pattern after match skip strategy.;private void checkPatternSkipStrategy() {_			if (afterMatchSkipStrategy.getPatternName().isPresent()) {_				String patternName = afterMatchSkipStrategy.getPatternName().get()__				Pattern<T, ?> pattern = currentPattern__				while (pattern.getPrevious() != null && !pattern.getName().equals(patternName)) {_					pattern = pattern.getPrevious()__				}__				_				if (!pattern.getName().equals(patternName)) {_					throw new MalformedPatternException("The pattern name specified in AfterMatchSkipStrategy " +_						"can not be found in the given Pattern")__				}_			}_		};check,pattern,after,match,skip,strategy;private,void,check,pattern,skip,strategy,if,after,match,skip,strategy,get,pattern,name,is,present,string,pattern,name,after,match,skip,strategy,get,pattern,name,get,pattern,t,pattern,current,pattern,while,pattern,get,previous,null,pattern,get,name,equals,pattern,name,pattern,pattern,get,previous,if,pattern,get,name,equals,pattern,name,throw,new,malformed,pattern,exception,the,pattern,name,specified,in,after,match,skip,strategy,can,not,be,found,in,the,given,pattern
NFACompiler -> NFAFactoryCompiler -> @SuppressWarnings("unchecked") 		private State<T> createFirstMandatoryStateOfLoop(final State<T> sinkState);1490619911;Patterns with quantifiers AT_LEAST_ONE_* are created as a pair of states: a singleton state and_looping state. This method creates the first of the two.__@param sinkState the state the newly created state should point to, it should be a looping state_@return the newly created state;@SuppressWarnings("unchecked")_		private State<T> createFirstMandatoryStateOfLoop(final State<T> sinkState) {__			final IterativeCondition<T> currentFilterFunction = (IterativeCondition<T>) currentPattern.getCondition()__			final State<T> firstState = createNormalState()___			firstState.addTake(sinkState, currentFilterFunction)__			if (currentPattern instanceof FollowedByPattern) {_				final IterativeCondition<T> ignoreCondition = getIgnoreCondition(currentPattern)__				firstState.addIgnore(ignoreCondition)__			}_			return firstState__		};patterns,with,quantifiers,are,created,as,a,pair,of,states,a,singleton,state,and,looping,state,this,method,creates,the,first,of,the,two,param,sink,state,the,state,the,newly,created,state,should,point,to,it,should,be,a,looping,state,return,the,newly,created,state;suppress,warnings,unchecked,private,state,t,create,first,mandatory,state,of,loop,final,state,t,sink,state,final,iterative,condition,t,current,filter,function,iterative,condition,t,current,pattern,get,condition,final,state,t,first,state,create,normal,state,first,state,add,take,sink,state,current,filter,function,if,current,pattern,instanceof,followed,by,pattern,final,iterative,condition,t,ignore,condition,get,ignore,condition,current,pattern,first,state,add,ignore,ignore,condition,return,first,state
NFACompiler -> NFAFactoryCompiler -> @SuppressWarnings("unchecked") 		private State<T> createFirstMandatoryStateOfLoop(final State<T> sinkState);1491320734;Patterns with quantifiers AT_LEAST_ONE_* are created as a pair of states: a singleton state and_looping state. This method creates the first of the two.__@param sinkState the state the newly created state should point to, it should be a looping state_@return the newly created state;@SuppressWarnings("unchecked")_		private State<T> createFirstMandatoryStateOfLoop(final State<T> sinkState) {__			final IterativeCondition<T> currentFilterFunction = (IterativeCondition<T>) currentPattern.getCondition()__			final State<T> firstState = createNormalState()___			firstState.addTake(sinkState, currentFilterFunction)__			if (currentPattern instanceof FollowedByPattern) {_				final IterativeCondition<T> ignoreCondition = getIgnoreCondition(currentPattern)__				firstState.addIgnore(ignoreCondition)__			}_			return firstState__		};patterns,with,quantifiers,are,created,as,a,pair,of,states,a,singleton,state,and,looping,state,this,method,creates,the,first,of,the,two,param,sink,state,the,state,the,newly,created,state,should,point,to,it,should,be,a,looping,state,return,the,newly,created,state;suppress,warnings,unchecked,private,state,t,create,first,mandatory,state,of,loop,final,state,t,sink,state,final,iterative,condition,t,current,filter,function,iterative,condition,t,current,pattern,get,condition,final,state,t,first,state,create,normal,state,first,state,add,take,sink,state,current,filter,function,if,current,pattern,instanceof,followed,by,pattern,final,iterative,condition,t,ignore,condition,get,ignore,condition,current,pattern,first,state,add,ignore,ignore,condition,return,first,state
NFACompiler -> NFAFactoryCompiler -> @SuppressWarnings("unchecked") 		private State<T> createFirstMandatoryStateOfLoop(final State<T> sinkState);1491323030;Patterns with quantifiers AT_LEAST_ONE_* are created as a pair of states: a singleton state and_looping state. This method creates the first of the two.__@param sinkState the state the newly created state should point to, it should be a looping state_@return the newly created state;@SuppressWarnings("unchecked")_		private State<T> createFirstMandatoryStateOfLoop(final State<T> sinkState) {__			final IterativeCondition<T> currentFilterFunction = (IterativeCondition<T>) currentPattern.getCondition()__			final State<T> firstState = createNormalState()___			firstState.addTake(sinkState, currentFilterFunction)__			if (currentPattern instanceof FollowedByPattern) {_				final IterativeCondition<T> ignoreCondition = getIgnoreCondition(currentPattern)__				firstState.addIgnore(ignoreCondition)__			}_			return firstState__		};patterns,with,quantifiers,are,created,as,a,pair,of,states,a,singleton,state,and,looping,state,this,method,creates,the,first,of,the,two,param,sink,state,the,state,the,newly,created,state,should,point,to,it,should,be,a,looping,state,return,the,newly,created,state;suppress,warnings,unchecked,private,state,t,create,first,mandatory,state,of,loop,final,state,t,sink,state,final,iterative,condition,t,current,filter,function,iterative,condition,t,current,pattern,get,condition,final,state,t,first,state,create,normal,state,first,state,add,take,sink,state,current,filter,function,if,current,pattern,instanceof,followed,by,pattern,final,iterative,condition,t,ignore,condition,get,ignore,condition,current,pattern,first,state,add,ignore,ignore,condition,return,first,state
NFACompiler -> NFAFactoryCompiler -> @SuppressWarnings("unchecked") 		private State<T> createFirstMandatoryStateOfLoop(final State<T> sinkState);1491633862;Patterns with quantifiers AT_LEAST_ONE_* are created as a pair of states: a singleton state and_looping state. This method creates the first of the two.__@param sinkState the state the newly created state should point to, it should be a looping state_@return the newly created state;@SuppressWarnings("unchecked")_		private State<T> createFirstMandatoryStateOfLoop(final State<T> sinkState) {__			final IterativeCondition<T> currentFilterFunction = (IterativeCondition<T>) currentPattern.getCondition()__			final State<T> firstState = createNormalState()___			firstState.addTake(sinkState, currentFilterFunction)__			if (currentPattern instanceof FollowedByPattern) {_				final IterativeCondition<T> ignoreCondition = getIgnoreCondition(currentPattern)__				firstState.addIgnore(ignoreCondition)__			}_			return firstState__		};patterns,with,quantifiers,are,created,as,a,pair,of,states,a,singleton,state,and,looping,state,this,method,creates,the,first,of,the,two,param,sink,state,the,state,the,newly,created,state,should,point,to,it,should,be,a,looping,state,return,the,newly,created,state;suppress,warnings,unchecked,private,state,t,create,first,mandatory,state,of,loop,final,state,t,sink,state,final,iterative,condition,t,current,filter,function,iterative,condition,t,current,pattern,get,condition,final,state,t,first,state,create,normal,state,first,state,add,take,sink,state,current,filter,function,if,current,pattern,instanceof,followed,by,pattern,final,iterative,condition,t,ignore,condition,get,ignore,condition,current,pattern,first,state,add,ignore,ignore,condition,return,first,state
NFACompiler -> NFAFactoryCompiler -> @SuppressWarnings("unchecked") 		private State<T> createFirstMandatoryStateOfLoop(final State<T> sinkState);1492797583;Patterns with quantifiers AT_LEAST_ONE_* are created as a pair of states: a singleton state and_looping state. This method creates the first of the two.__@param sinkState the state the newly created state should point to, it should be a looping state_@return the newly created state;@SuppressWarnings("unchecked")_		private State<T> createFirstMandatoryStateOfLoop(final State<T> sinkState) {__			final IterativeCondition<T> currentFilterFunction = (IterativeCondition<T>) currentPattern.getCondition()__			final State<T> firstState = createNormalState()___			firstState.addTake(sinkState, currentFilterFunction)__			if (currentPattern instanceof FollowedByPattern) {_				final IterativeCondition<T> ignoreCondition = getIgnoreCondition(currentPattern)__				firstState.addIgnore(ignoreCondition)__			}_			return firstState__		};patterns,with,quantifiers,are,created,as,a,pair,of,states,a,singleton,state,and,looping,state,this,method,creates,the,first,of,the,two,param,sink,state,the,state,the,newly,created,state,should,point,to,it,should,be,a,looping,state,return,the,newly,created,state;suppress,warnings,unchecked,private,state,t,create,first,mandatory,state,of,loop,final,state,t,sink,state,final,iterative,condition,t,current,filter,function,iterative,condition,t,current,pattern,get,condition,final,state,t,first,state,create,normal,state,first,state,add,take,sink,state,current,filter,function,if,current,pattern,instanceof,followed,by,pattern,final,iterative,condition,t,ignore,condition,get,ignore,condition,current,pattern,first,state,add,ignore,ignore,condition,return,first,state
NFACompiler -> NFAFactoryCompiler -> @SuppressWarnings("unchecked") 		private State<T> createFirstMandatoryStateOfLoop(final State<T> sinkState);1493200673;Patterns with quantifiers AT_LEAST_ONE_* are created as a pair of states: a singleton state and_looping state. This method creates the first of the two.__@param sinkState the state the newly created state should point to, it should be a looping state_@return the newly created state;@SuppressWarnings("unchecked")_		private State<T> createFirstMandatoryStateOfLoop(final State<T> sinkState) {__			final IterativeCondition<T> currentFilterFunction = (IterativeCondition<T>) currentPattern.getCondition()__			final State<T> firstState = createNormalState()___			firstState.addTake(sinkState, currentFilterFunction)__			final IterativeCondition<T> ignoreCondition = getIgnoreCondition(currentPattern)__			if (ignoreCondition != null) {_				firstState.addIgnore(ignoreCondition)__			}_			return firstState__		};patterns,with,quantifiers,are,created,as,a,pair,of,states,a,singleton,state,and,looping,state,this,method,creates,the,first,of,the,two,param,sink,state,the,state,the,newly,created,state,should,point,to,it,should,be,a,looping,state,return,the,newly,created,state;suppress,warnings,unchecked,private,state,t,create,first,mandatory,state,of,loop,final,state,t,sink,state,final,iterative,condition,t,current,filter,function,iterative,condition,t,current,pattern,get,condition,final,state,t,first,state,create,normal,state,first,state,add,take,sink,state,current,filter,function,final,iterative,condition,t,ignore,condition,get,ignore,condition,current,pattern,if,ignore,condition,null,first,state,add,ignore,ignore,condition,return,first,state
NFACompiler -> public static <T> NFA<T> compile( 		Pattern<T, ?> pattern, 		TypeSerializer<T> inputTypeSerializer, 		boolean timeoutHandling);1464255256;Compiles the given pattern into a {@link NFA}.__@param pattern Definition of sequence pattern_@param inputTypeSerializer Serializer for the input type_@param timeoutHandling True if the NFA shall return timed out event patterns_@param <T> Type of the input events_@return Non-deterministic finite automaton representing the given pattern;public static <T> NFA<T> compile(_		Pattern<T, ?> pattern,_		TypeSerializer<T> inputTypeSerializer,_		boolean timeoutHandling) {_		NFAFactory<T> factory = compileFactory(pattern, inputTypeSerializer, timeoutHandling)___		return factory.createNFA()__	};compiles,the,given,pattern,into,a,link,nfa,param,pattern,definition,of,sequence,pattern,param,input,type,serializer,serializer,for,the,input,type,param,timeout,handling,true,if,the,nfa,shall,return,timed,out,event,patterns,param,t,type,of,the,input,events,return,non,deterministic,finite,automaton,representing,the,given,pattern;public,static,t,nfa,t,compile,pattern,t,pattern,type,serializer,t,input,type,serializer,boolean,timeout,handling,nfafactory,t,factory,compile,factory,pattern,input,type,serializer,timeout,handling,return,factory,create,nfa
NFACompiler -> public static <T> NFA<T> compile( 		Pattern<T, ?> pattern, 		TypeSerializer<T> inputTypeSerializer, 		boolean timeoutHandling);1487681471;Compiles the given pattern into a {@link NFA}.__@param pattern Definition of sequence pattern_@param inputTypeSerializer Serializer for the input type_@param timeoutHandling True if the NFA shall return timed out event patterns_@param <T> Type of the input events_@return Non-deterministic finite automaton representing the given pattern;public static <T> NFA<T> compile(_		Pattern<T, ?> pattern,_		TypeSerializer<T> inputTypeSerializer,_		boolean timeoutHandling) {_		NFAFactory<T> factory = compileFactory(pattern, inputTypeSerializer, timeoutHandling)___		return factory.createNFA()__	};compiles,the,given,pattern,into,a,link,nfa,param,pattern,definition,of,sequence,pattern,param,input,type,serializer,serializer,for,the,input,type,param,timeout,handling,true,if,the,nfa,shall,return,timed,out,event,patterns,param,t,type,of,the,input,events,return,non,deterministic,finite,automaton,representing,the,given,pattern;public,static,t,nfa,t,compile,pattern,t,pattern,type,serializer,t,input,type,serializer,boolean,timeout,handling,nfafactory,t,factory,compile,factory,pattern,input,type,serializer,timeout,handling,return,factory,create,nfa
NFACompiler -> public static <T> NFA<T> compile( 		Pattern<T, ?> pattern, 		TypeSerializer<T> inputTypeSerializer, 		boolean timeoutHandling);1489866780;Compiles the given pattern into a {@link NFA}.__@param pattern Definition of sequence pattern_@param inputTypeSerializer Serializer for the input type_@param timeoutHandling True if the NFA shall return timed out event patterns_@param <T> Type of the input events_@return Non-deterministic finite automaton representing the given pattern;public static <T> NFA<T> compile(_		Pattern<T, ?> pattern,_		TypeSerializer<T> inputTypeSerializer,_		boolean timeoutHandling) {_		NFAFactory<T> factory = compileFactory(pattern, inputTypeSerializer, timeoutHandling)___		return factory.createNFA()__	};compiles,the,given,pattern,into,a,link,nfa,param,pattern,definition,of,sequence,pattern,param,input,type,serializer,serializer,for,the,input,type,param,timeout,handling,true,if,the,nfa,shall,return,timed,out,event,patterns,param,t,type,of,the,input,events,return,non,deterministic,finite,automaton,representing,the,given,pattern;public,static,t,nfa,t,compile,pattern,t,pattern,type,serializer,t,input,type,serializer,boolean,timeout,handling,nfafactory,t,factory,compile,factory,pattern,input,type,serializer,timeout,handling,return,factory,create,nfa
NFACompiler -> public static <T> NFA<T> compile( 		Pattern<T, ?> pattern, 		TypeSerializer<T> inputTypeSerializer, 		boolean timeoutHandling);1490089987;Compiles the given pattern into a {@link NFA}.__@param pattern Definition of sequence pattern_@param inputTypeSerializer Serializer for the input type_@param timeoutHandling True if the NFA shall return timed out event patterns_@param <T> Type of the input events_@return Non-deterministic finite automaton representing the given pattern;public static <T> NFA<T> compile(_		Pattern<T, ?> pattern,_		TypeSerializer<T> inputTypeSerializer,_		boolean timeoutHandling) {_		NFAFactory<T> factory = compileFactory(pattern, inputTypeSerializer, timeoutHandling)___		return factory.createNFA()__	};compiles,the,given,pattern,into,a,link,nfa,param,pattern,definition,of,sequence,pattern,param,input,type,serializer,serializer,for,the,input,type,param,timeout,handling,true,if,the,nfa,shall,return,timed,out,event,patterns,param,t,type,of,the,input,events,return,non,deterministic,finite,automaton,representing,the,given,pattern;public,static,t,nfa,t,compile,pattern,t,pattern,type,serializer,t,input,type,serializer,boolean,timeout,handling,nfafactory,t,factory,compile,factory,pattern,input,type,serializer,timeout,handling,return,factory,create,nfa
NFACompiler -> public static <T> NFA<T> compile( 		Pattern<T, ?> pattern, 		TypeSerializer<T> inputTypeSerializer, 		boolean timeoutHandling);1490194327;Compiles the given pattern into a {@link NFA}.__@param pattern Definition of sequence pattern_@param inputTypeSerializer Serializer for the input type_@param timeoutHandling True if the NFA shall return timed out event patterns_@param <T> Type of the input events_@return Non-deterministic finite automaton representing the given pattern;public static <T> NFA<T> compile(_		Pattern<T, ?> pattern,_		TypeSerializer<T> inputTypeSerializer,_		boolean timeoutHandling) {_		NFAFactory<T> factory = compileFactory(pattern, inputTypeSerializer, timeoutHandling)___		return factory.createNFA()__	};compiles,the,given,pattern,into,a,link,nfa,param,pattern,definition,of,sequence,pattern,param,input,type,serializer,serializer,for,the,input,type,param,timeout,handling,true,if,the,nfa,shall,return,timed,out,event,patterns,param,t,type,of,the,input,events,return,non,deterministic,finite,automaton,representing,the,given,pattern;public,static,t,nfa,t,compile,pattern,t,pattern,type,serializer,t,input,type,serializer,boolean,timeout,handling,nfafactory,t,factory,compile,factory,pattern,input,type,serializer,timeout,handling,return,factory,create,nfa
NFACompiler -> public static <T> NFA<T> compile( 		Pattern<T, ?> pattern, 		TypeSerializer<T> inputTypeSerializer, 		boolean timeoutHandling);1490619911;Compiles the given pattern into a {@link NFA}.__@param pattern Definition of sequence pattern_@param inputTypeSerializer Serializer for the input type_@param timeoutHandling True if the NFA shall return timed out event patterns_@param <T> Type of the input events_@return Non-deterministic finite automaton representing the given pattern;public static <T> NFA<T> compile(_		Pattern<T, ?> pattern,_		TypeSerializer<T> inputTypeSerializer,_		boolean timeoutHandling) {_		NFAFactory<T> factory = compileFactory(pattern, inputTypeSerializer, timeoutHandling)___		return factory.createNFA()__	};compiles,the,given,pattern,into,a,link,nfa,param,pattern,definition,of,sequence,pattern,param,input,type,serializer,serializer,for,the,input,type,param,timeout,handling,true,if,the,nfa,shall,return,timed,out,event,patterns,param,t,type,of,the,input,events,return,non,deterministic,finite,automaton,representing,the,given,pattern;public,static,t,nfa,t,compile,pattern,t,pattern,type,serializer,t,input,type,serializer,boolean,timeout,handling,nfafactory,t,factory,compile,factory,pattern,input,type,serializer,timeout,handling,return,factory,create,nfa
NFACompiler -> public static <T> NFA<T> compile( 		Pattern<T, ?> pattern, 		TypeSerializer<T> inputTypeSerializer, 		boolean timeoutHandling);1491320734;Compiles the given pattern into a {@link NFA}.__@param pattern Definition of sequence pattern_@param inputTypeSerializer Serializer for the input type_@param timeoutHandling True if the NFA shall return timed out event patterns_@param <T> Type of the input events_@return Non-deterministic finite automaton representing the given pattern;public static <T> NFA<T> compile(_		Pattern<T, ?> pattern,_		TypeSerializer<T> inputTypeSerializer,_		boolean timeoutHandling) {_		NFAFactory<T> factory = compileFactory(pattern, inputTypeSerializer, timeoutHandling)___		return factory.createNFA()__	};compiles,the,given,pattern,into,a,link,nfa,param,pattern,definition,of,sequence,pattern,param,input,type,serializer,serializer,for,the,input,type,param,timeout,handling,true,if,the,nfa,shall,return,timed,out,event,patterns,param,t,type,of,the,input,events,return,non,deterministic,finite,automaton,representing,the,given,pattern;public,static,t,nfa,t,compile,pattern,t,pattern,type,serializer,t,input,type,serializer,boolean,timeout,handling,nfafactory,t,factory,compile,factory,pattern,input,type,serializer,timeout,handling,return,factory,create,nfa
NFACompiler -> public static <T> NFA<T> compile( 		Pattern<T, ?> pattern, 		TypeSerializer<T> inputTypeSerializer, 		boolean timeoutHandling);1491323030;Compiles the given pattern into a {@link NFA}.__@param pattern Definition of sequence pattern_@param inputTypeSerializer Serializer for the input type_@param timeoutHandling True if the NFA shall return timed out event patterns_@param <T> Type of the input events_@return Non-deterministic finite automaton representing the given pattern;public static <T> NFA<T> compile(_		Pattern<T, ?> pattern,_		TypeSerializer<T> inputTypeSerializer,_		boolean timeoutHandling) {_		NFAFactory<T> factory = compileFactory(pattern, inputTypeSerializer, timeoutHandling)___		return factory.createNFA()__	};compiles,the,given,pattern,into,a,link,nfa,param,pattern,definition,of,sequence,pattern,param,input,type,serializer,serializer,for,the,input,type,param,timeout,handling,true,if,the,nfa,shall,return,timed,out,event,patterns,param,t,type,of,the,input,events,return,non,deterministic,finite,automaton,representing,the,given,pattern;public,static,t,nfa,t,compile,pattern,t,pattern,type,serializer,t,input,type,serializer,boolean,timeout,handling,nfafactory,t,factory,compile,factory,pattern,input,type,serializer,timeout,handling,return,factory,create,nfa
NFACompiler -> public static <T> NFA<T> compile( 		Pattern<T, ?> pattern, 		TypeSerializer<T> inputTypeSerializer, 		boolean timeoutHandling);1491633862;Compiles the given pattern into a {@link NFA}.__@param pattern Definition of sequence pattern_@param inputTypeSerializer Serializer for the input type_@param timeoutHandling True if the NFA shall return timed out event patterns_@param <T> Type of the input events_@return Non-deterministic finite automaton representing the given pattern;public static <T> NFA<T> compile(_		Pattern<T, ?> pattern,_		TypeSerializer<T> inputTypeSerializer,_		boolean timeoutHandling) {_		NFAFactory<T> factory = compileFactory(pattern, inputTypeSerializer, timeoutHandling)___		return factory.createNFA()__	};compiles,the,given,pattern,into,a,link,nfa,param,pattern,definition,of,sequence,pattern,param,input,type,serializer,serializer,for,the,input,type,param,timeout,handling,true,if,the,nfa,shall,return,timed,out,event,patterns,param,t,type,of,the,input,events,return,non,deterministic,finite,automaton,representing,the,given,pattern;public,static,t,nfa,t,compile,pattern,t,pattern,type,serializer,t,input,type,serializer,boolean,timeout,handling,nfafactory,t,factory,compile,factory,pattern,input,type,serializer,timeout,handling,return,factory,create,nfa
NFACompiler -> public static <T> NFA<T> compile( 		Pattern<T, ?> pattern, 		TypeSerializer<T> inputTypeSerializer, 		boolean timeoutHandling);1492797583;Compiles the given pattern into a {@link NFA}.__@param pattern Definition of sequence pattern_@param inputTypeSerializer Serializer for the input type_@param timeoutHandling True if the NFA shall return timed out event patterns_@param <T> Type of the input events_@return Non-deterministic finite automaton representing the given pattern;public static <T> NFA<T> compile(_		Pattern<T, ?> pattern,_		TypeSerializer<T> inputTypeSerializer,_		boolean timeoutHandling) {_		NFAFactory<T> factory = compileFactory(pattern, inputTypeSerializer, timeoutHandling)___		return factory.createNFA()__	};compiles,the,given,pattern,into,a,link,nfa,param,pattern,definition,of,sequence,pattern,param,input,type,serializer,serializer,for,the,input,type,param,timeout,handling,true,if,the,nfa,shall,return,timed,out,event,patterns,param,t,type,of,the,input,events,return,non,deterministic,finite,automaton,representing,the,given,pattern;public,static,t,nfa,t,compile,pattern,t,pattern,type,serializer,t,input,type,serializer,boolean,timeout,handling,nfafactory,t,factory,compile,factory,pattern,input,type,serializer,timeout,handling,return,factory,create,nfa
NFACompiler -> public static <T> NFA<T> compile( 		Pattern<T, ?> pattern, 		TypeSerializer<T> inputTypeSerializer, 		boolean timeoutHandling);1493200673;Compiles the given pattern into a {@link NFA}.__@param pattern Definition of sequence pattern_@param inputTypeSerializer Serializer for the input type_@param timeoutHandling True if the NFA shall return timed out event patterns_@param <T> Type of the input events_@return Non-deterministic finite automaton representing the given pattern;public static <T> NFA<T> compile(_		Pattern<T, ?> pattern,_		TypeSerializer<T> inputTypeSerializer,_		boolean timeoutHandling) {_		NFAFactory<T> factory = compileFactory(pattern, inputTypeSerializer, timeoutHandling)___		return factory.createNFA()__	};compiles,the,given,pattern,into,a,link,nfa,param,pattern,definition,of,sequence,pattern,param,input,type,serializer,serializer,for,the,input,type,param,timeout,handling,true,if,the,nfa,shall,return,timed,out,event,patterns,param,t,type,of,the,input,events,return,non,deterministic,finite,automaton,representing,the,given,pattern;public,static,t,nfa,t,compile,pattern,t,pattern,type,serializer,t,input,type,serializer,boolean,timeout,handling,nfafactory,t,factory,compile,factory,pattern,input,type,serializer,timeout,handling,return,factory,create,nfa
NFACompiler -> public static <T> NFA<T> compile( 		Pattern<T, ?> pattern, 		TypeSerializer<T> inputTypeSerializer, 		boolean timeoutHandling);1493385877;Compiles the given pattern into a {@link NFA}.__@param pattern Definition of sequence pattern_@param inputTypeSerializer Serializer for the input type_@param timeoutHandling True if the NFA shall return timed out event patterns_@param <T> Type of the input events_@return Non-deterministic finite automaton representing the given pattern;public static <T> NFA<T> compile(_		Pattern<T, ?> pattern,_		TypeSerializer<T> inputTypeSerializer,_		boolean timeoutHandling) {_		NFAFactory<T> factory = compileFactory(pattern, inputTypeSerializer, timeoutHandling)___		return factory.createNFA()__	};compiles,the,given,pattern,into,a,link,nfa,param,pattern,definition,of,sequence,pattern,param,input,type,serializer,serializer,for,the,input,type,param,timeout,handling,true,if,the,nfa,shall,return,timed,out,event,patterns,param,t,type,of,the,input,events,return,non,deterministic,finite,automaton,representing,the,given,pattern;public,static,t,nfa,t,compile,pattern,t,pattern,type,serializer,t,input,type,serializer,boolean,timeout,handling,nfafactory,t,factory,compile,factory,pattern,input,type,serializer,timeout,handling,return,factory,create,nfa
NFACompiler -> public static <T> NFA<T> compile( 		Pattern<T, ?> pattern, 		TypeSerializer<T> inputTypeSerializer, 		boolean timeoutHandling);1494947249;Compiles the given pattern into a {@link NFA}.__@param pattern Definition of sequence pattern_@param inputTypeSerializer Serializer for the input type_@param timeoutHandling True if the NFA shall return timed out event patterns_@param <T> Type of the input events_@return Non-deterministic finite automaton representing the given pattern;public static <T> NFA<T> compile(_		Pattern<T, ?> pattern,_		TypeSerializer<T> inputTypeSerializer,_		boolean timeoutHandling) {_		NFAFactory<T> factory = compileFactory(pattern, inputTypeSerializer, timeoutHandling)___		return factory.createNFA()__	};compiles,the,given,pattern,into,a,link,nfa,param,pattern,definition,of,sequence,pattern,param,input,type,serializer,serializer,for,the,input,type,param,timeout,handling,true,if,the,nfa,shall,return,timed,out,event,patterns,param,t,type,of,the,input,events,return,non,deterministic,finite,automaton,representing,the,given,pattern;public,static,t,nfa,t,compile,pattern,t,pattern,type,serializer,t,input,type,serializer,boolean,timeout,handling,nfafactory,t,factory,compile,factory,pattern,input,type,serializer,timeout,handling,return,factory,create,nfa
NFACompiler -> public static <T> NFA<T> compile( 		Pattern<T, ?> pattern, 		TypeSerializer<T> inputTypeSerializer, 		boolean timeoutHandling);1495657626;Compiles the given pattern into a {@link NFA}.__@param pattern Definition of sequence pattern_@param inputTypeSerializer Serializer for the input type_@param timeoutHandling True if the NFA shall return timed out event patterns_@param <T> Type of the input events_@return Non-deterministic finite automaton representing the given pattern;public static <T> NFA<T> compile(_		Pattern<T, ?> pattern,_		TypeSerializer<T> inputTypeSerializer,_		boolean timeoutHandling) {_		NFAFactory<T> factory = compileFactory(pattern, inputTypeSerializer, timeoutHandling)___		return factory.createNFA()__	};compiles,the,given,pattern,into,a,link,nfa,param,pattern,definition,of,sequence,pattern,param,input,type,serializer,serializer,for,the,input,type,param,timeout,handling,true,if,the,nfa,shall,return,timed,out,event,patterns,param,t,type,of,the,input,events,return,non,deterministic,finite,automaton,representing,the,given,pattern;public,static,t,nfa,t,compile,pattern,t,pattern,type,serializer,t,input,type,serializer,boolean,timeout,handling,nfafactory,t,factory,compile,factory,pattern,input,type,serializer,timeout,handling,return,factory,create,nfa
NFACompiler -> public static <T> NFA<T> compile( 		Pattern<T, ?> pattern, 		TypeSerializer<T> inputTypeSerializer, 		boolean timeoutHandling);1496245714;Compiles the given pattern into a {@link NFA}.__@param pattern Definition of sequence pattern_@param inputTypeSerializer Serializer for the input type_@param timeoutHandling True if the NFA shall return timed out event patterns_@param <T> Type of the input events_@return Non-deterministic finite automaton representing the given pattern;public static <T> NFA<T> compile(_		Pattern<T, ?> pattern,_		TypeSerializer<T> inputTypeSerializer,_		boolean timeoutHandling) {_		NFAFactory<T> factory = compileFactory(pattern, inputTypeSerializer, timeoutHandling)___		return factory.createNFA()__	};compiles,the,given,pattern,into,a,link,nfa,param,pattern,definition,of,sequence,pattern,param,input,type,serializer,serializer,for,the,input,type,param,timeout,handling,true,if,the,nfa,shall,return,timed,out,event,patterns,param,t,type,of,the,input,events,return,non,deterministic,finite,automaton,representing,the,given,pattern;public,static,t,nfa,t,compile,pattern,t,pattern,type,serializer,t,input,type,serializer,boolean,timeout,handling,nfafactory,t,factory,compile,factory,pattern,input,type,serializer,timeout,handling,return,factory,create,nfa
NFACompiler -> public static <T> NFA<T> compile( 		Pattern<T, ?> pattern, 		TypeSerializer<T> inputTypeSerializer, 		boolean timeoutHandling);1497410381;Compiles the given pattern into a {@link NFA}.__@param pattern Definition of sequence pattern_@param inputTypeSerializer Serializer for the input type_@param timeoutHandling True if the NFA shall return timed out event patterns_@param <T> Type of the input events_@return Non-deterministic finite automaton representing the given pattern;public static <T> NFA<T> compile(_		Pattern<T, ?> pattern,_		TypeSerializer<T> inputTypeSerializer,_		boolean timeoutHandling) {_		NFAFactory<T> factory = compileFactory(pattern, inputTypeSerializer, timeoutHandling)___		return factory.createNFA()__	};compiles,the,given,pattern,into,a,link,nfa,param,pattern,definition,of,sequence,pattern,param,input,type,serializer,serializer,for,the,input,type,param,timeout,handling,true,if,the,nfa,shall,return,timed,out,event,patterns,param,t,type,of,the,input,events,return,non,deterministic,finite,automaton,representing,the,given,pattern;public,static,t,nfa,t,compile,pattern,t,pattern,type,serializer,t,input,type,serializer,boolean,timeout,handling,nfafactory,t,factory,compile,factory,pattern,input,type,serializer,timeout,handling,return,factory,create,nfa
NFACompiler -> public static <T> NFA<T> compile( 		Pattern<T, ?> pattern, 		TypeSerializer<T> inputTypeSerializer, 		boolean timeoutHandling);1497883202;Compiles the given pattern into a {@link NFA}.__@param pattern Definition of sequence pattern_@param inputTypeSerializer Serializer for the input type_@param timeoutHandling True if the NFA shall return timed out event patterns_@param <T> Type of the input events_@return Non-deterministic finite automaton representing the given pattern;public static <T> NFA<T> compile(_		Pattern<T, ?> pattern,_		TypeSerializer<T> inputTypeSerializer,_		boolean timeoutHandling) {_		NFAFactory<T> factory = compileFactory(pattern, inputTypeSerializer, timeoutHandling)___		return factory.createNFA()__	};compiles,the,given,pattern,into,a,link,nfa,param,pattern,definition,of,sequence,pattern,param,input,type,serializer,serializer,for,the,input,type,param,timeout,handling,true,if,the,nfa,shall,return,timed,out,event,patterns,param,t,type,of,the,input,events,return,non,deterministic,finite,automaton,representing,the,given,pattern;public,static,t,nfa,t,compile,pattern,t,pattern,type,serializer,t,input,type,serializer,boolean,timeout,handling,nfafactory,t,factory,compile,factory,pattern,input,type,serializer,timeout,handling,return,factory,create,nfa
NFACompiler -> public static <T> NFA<T> compile( 		Pattern<T, ?> pattern, 		TypeSerializer<T> inputTypeSerializer, 		boolean timeoutHandling);1498034481;Compiles the given pattern into a {@link NFA}.__@param pattern Definition of sequence pattern_@param inputTypeSerializer Serializer for the input type_@param timeoutHandling True if the NFA shall return timed out event patterns_@param <T> Type of the input events_@return Non-deterministic finite automaton representing the given pattern;public static <T> NFA<T> compile(_		Pattern<T, ?> pattern,_		TypeSerializer<T> inputTypeSerializer,_		boolean timeoutHandling) {_		NFAFactory<T> factory = compileFactory(pattern, inputTypeSerializer, timeoutHandling)___		return factory.createNFA()__	};compiles,the,given,pattern,into,a,link,nfa,param,pattern,definition,of,sequence,pattern,param,input,type,serializer,serializer,for,the,input,type,param,timeout,handling,true,if,the,nfa,shall,return,timed,out,event,patterns,param,t,type,of,the,input,events,return,non,deterministic,finite,automaton,representing,the,given,pattern;public,static,t,nfa,t,compile,pattern,t,pattern,type,serializer,t,input,type,serializer,boolean,timeout,handling,nfafactory,t,factory,compile,factory,pattern,input,type,serializer,timeout,handling,return,factory,create,nfa
NFACompiler -> public static <T> NFA<T> compile( 		Pattern<T, ?> pattern, 		TypeSerializer<T> inputTypeSerializer, 		boolean timeoutHandling);1499760222;Compiles the given pattern into a {@link NFA}.__@param pattern Definition of sequence pattern_@param inputTypeSerializer Serializer for the input type_@param timeoutHandling True if the NFA shall return timed out event patterns_@param <T> Type of the input events_@return Non-deterministic finite automaton representing the given pattern;public static <T> NFA<T> compile(_		Pattern<T, ?> pattern,_		TypeSerializer<T> inputTypeSerializer,_		boolean timeoutHandling) {_		NFAFactory<T> factory = compileFactory(pattern, inputTypeSerializer, timeoutHandling)___		return factory.createNFA()__	};compiles,the,given,pattern,into,a,link,nfa,param,pattern,definition,of,sequence,pattern,param,input,type,serializer,serializer,for,the,input,type,param,timeout,handling,true,if,the,nfa,shall,return,timed,out,event,patterns,param,t,type,of,the,input,events,return,non,deterministic,finite,automaton,representing,the,given,pattern;public,static,t,nfa,t,compile,pattern,t,pattern,type,serializer,t,input,type,serializer,boolean,timeout,handling,nfafactory,t,factory,compile,factory,pattern,input,type,serializer,timeout,handling,return,factory,create,nfa
NFACompiler -> public static <T> NFA<T> compile( 		Pattern<T, ?> pattern, 		TypeSerializer<T> inputTypeSerializer, 		boolean timeoutHandling);1499937690;Compiles the given pattern into a {@link NFA}.__@param pattern Definition of sequence pattern_@param inputTypeSerializer Serializer for the input type_@param timeoutHandling True if the NFA shall return timed out event patterns_@param <T> Type of the input events_@return Non-deterministic finite automaton representing the given pattern;public static <T> NFA<T> compile(_		Pattern<T, ?> pattern,_		TypeSerializer<T> inputTypeSerializer,_		boolean timeoutHandling) {_		NFAFactory<T> factory = compileFactory(pattern, inputTypeSerializer, timeoutHandling)___		return factory.createNFA()__	};compiles,the,given,pattern,into,a,link,nfa,param,pattern,definition,of,sequence,pattern,param,input,type,serializer,serializer,for,the,input,type,param,timeout,handling,true,if,the,nfa,shall,return,timed,out,event,patterns,param,t,type,of,the,input,events,return,non,deterministic,finite,automaton,representing,the,given,pattern;public,static,t,nfa,t,compile,pattern,t,pattern,type,serializer,t,input,type,serializer,boolean,timeout,handling,nfafactory,t,factory,compile,factory,pattern,input,type,serializer,timeout,handling,return,factory,create,nfa
NFACompiler -> public static <T> NFA<T> compile( 		Pattern<T, ?> pattern, 		TypeSerializer<T> inputTypeSerializer, 		boolean timeoutHandling);1500021711;Compiles the given pattern into a {@link NFA}.__@param pattern Definition of sequence pattern_@param inputTypeSerializer Serializer for the input type_@param timeoutHandling True if the NFA shall return timed out event patterns_@param <T> Type of the input events_@return Non-deterministic finite automaton representing the given pattern;public static <T> NFA<T> compile(_		Pattern<T, ?> pattern,_		TypeSerializer<T> inputTypeSerializer,_		boolean timeoutHandling) {_		NFAFactory<T> factory = compileFactory(pattern, inputTypeSerializer, timeoutHandling)___		return factory.createNFA()__	};compiles,the,given,pattern,into,a,link,nfa,param,pattern,definition,of,sequence,pattern,param,input,type,serializer,serializer,for,the,input,type,param,timeout,handling,true,if,the,nfa,shall,return,timed,out,event,patterns,param,t,type,of,the,input,events,return,non,deterministic,finite,automaton,representing,the,given,pattern;public,static,t,nfa,t,compile,pattern,t,pattern,type,serializer,t,input,type,serializer,boolean,timeout,handling,nfafactory,t,factory,compile,factory,pattern,input,type,serializer,timeout,handling,return,factory,create,nfa
NFACompiler -> public static <T> NFA<T> compile( 		Pattern<T, ?> pattern, 		TypeSerializer<T> inputTypeSerializer, 		boolean timeoutHandling);1501592283;Compiles the given pattern into a {@link NFA}.__@param pattern Definition of sequence pattern_@param inputTypeSerializer Serializer for the input type_@param timeoutHandling True if the NFA shall return timed out event patterns_@param <T> Type of the input events_@return Non-deterministic finite automaton representing the given pattern;public static <T> NFA<T> compile(_		Pattern<T, ?> pattern,_		TypeSerializer<T> inputTypeSerializer,_		boolean timeoutHandling) {_		NFAFactory<T> factory = compileFactory(pattern, inputTypeSerializer, timeoutHandling)___		return factory.createNFA()__	};compiles,the,given,pattern,into,a,link,nfa,param,pattern,definition,of,sequence,pattern,param,input,type,serializer,serializer,for,the,input,type,param,timeout,handling,true,if,the,nfa,shall,return,timed,out,event,patterns,param,t,type,of,the,input,events,return,non,deterministic,finite,automaton,representing,the,given,pattern;public,static,t,nfa,t,compile,pattern,t,pattern,type,serializer,t,input,type,serializer,boolean,timeout,handling,nfafactory,t,factory,compile,factory,pattern,input,type,serializer,timeout,handling,return,factory,create,nfa
NFACompiler -> public static <T> NFA<T> compile( 		Pattern<T, ?> pattern, 		TypeSerializer<T> inputTypeSerializer, 		boolean timeoutHandling);1502422141;Compiles the given pattern into a {@link NFA}.__@param pattern Definition of sequence pattern_@param inputTypeSerializer Serializer for the input type_@param timeoutHandling True if the NFA shall return timed out event patterns_@param <T> Type of the input events_@return Non-deterministic finite automaton representing the given pattern;public static <T> NFA<T> compile(_		Pattern<T, ?> pattern,_		TypeSerializer<T> inputTypeSerializer,_		boolean timeoutHandling) {_		NFAFactory<T> factory = compileFactory(pattern, inputTypeSerializer, timeoutHandling)___		return factory.createNFA()__	};compiles,the,given,pattern,into,a,link,nfa,param,pattern,definition,of,sequence,pattern,param,input,type,serializer,serializer,for,the,input,type,param,timeout,handling,true,if,the,nfa,shall,return,timed,out,event,patterns,param,t,type,of,the,input,events,return,non,deterministic,finite,automaton,representing,the,given,pattern;public,static,t,nfa,t,compile,pattern,t,pattern,type,serializer,t,input,type,serializer,boolean,timeout,handling,nfafactory,t,factory,compile,factory,pattern,input,type,serializer,timeout,handling,return,factory,create,nfa
NFACompiler -> public static <T> NFA<T> compile( 		Pattern<T, ?> pattern, 		TypeSerializer<T> inputTypeSerializer, 		boolean timeoutHandling);1503588494;Compiles the given pattern into a {@link NFA}.__@param pattern Definition of sequence pattern_@param inputTypeSerializer Serializer for the input type_@param timeoutHandling True if the NFA shall return timed out event patterns_@param <T> Type of the input events_@return Non-deterministic finite automaton representing the given pattern;public static <T> NFA<T> compile(_		Pattern<T, ?> pattern,_		TypeSerializer<T> inputTypeSerializer,_		boolean timeoutHandling) {_		NFAFactory<T> factory = compileFactory(pattern, inputTypeSerializer, timeoutHandling)___		return factory.createNFA()__	};compiles,the,given,pattern,into,a,link,nfa,param,pattern,definition,of,sequence,pattern,param,input,type,serializer,serializer,for,the,input,type,param,timeout,handling,true,if,the,nfa,shall,return,timed,out,event,patterns,param,t,type,of,the,input,events,return,non,deterministic,finite,automaton,representing,the,given,pattern;public,static,t,nfa,t,compile,pattern,t,pattern,type,serializer,t,input,type,serializer,boolean,timeout,handling,nfafactory,t,factory,compile,factory,pattern,input,type,serializer,timeout,handling,return,factory,create,nfa
NFACompiler -> public static <T> NFA<T> compile( 		Pattern<T, ?> pattern, 		TypeSerializer<T> inputTypeSerializer, 		boolean timeoutHandling);1518008111;Compiles the given pattern into a {@link NFA}.__@param pattern Definition of sequence pattern_@param inputTypeSerializer Serializer for the input type_@param timeoutHandling True if the NFA shall return timed out event patterns_@param <T> Type of the input events_@return Non-deterministic finite automaton representing the given pattern;public static <T> NFA<T> compile(_		Pattern<T, ?> pattern,_		TypeSerializer<T> inputTypeSerializer,_		boolean timeoutHandling) {_		NFAFactory<T> factory = compileFactory(pattern, inputTypeSerializer, timeoutHandling)___		return factory.createNFA()__	};compiles,the,given,pattern,into,a,link,nfa,param,pattern,definition,of,sequence,pattern,param,input,type,serializer,serializer,for,the,input,type,param,timeout,handling,true,if,the,nfa,shall,return,timed,out,event,patterns,param,t,type,of,the,input,events,return,non,deterministic,finite,automaton,representing,the,given,pattern;public,static,t,nfa,t,compile,pattern,t,pattern,type,serializer,t,input,type,serializer,boolean,timeout,handling,nfafactory,t,factory,compile,factory,pattern,input,type,serializer,timeout,handling,return,factory,create,nfa
NFACompiler -> NFAFactoryCompiler -> private void convertToLooping(final State<T> sourceState, final State<T> sinkState);1489866780;Converts the given state into looping one. Looping state is one with TAKE edge to itself and_PROCEED edge to the sinkState. It also consists of a similar state without the PROCEED edge, so that_for each PROCEED transition branches in computation state graph  can be created only once.__@param sourceState the state to converted_@param sinkState   the state that the converted state should point to;private void convertToLooping(final State<T> sourceState, final State<T> sinkState) {_			convertToLooping(sourceState, sinkState, false)__		};converts,the,given,state,into,looping,one,looping,state,is,one,with,take,edge,to,itself,and,proceed,edge,to,the,sink,state,it,also,consists,of,a,similar,state,without,the,proceed,edge,so,that,for,each,proceed,transition,branches,in,computation,state,graph,can,be,created,only,once,param,source,state,the,state,to,converted,param,sink,state,the,state,that,the,converted,state,should,point,to;private,void,convert,to,looping,final,state,t,source,state,final,state,t,sink,state,convert,to,looping,source,state,sink,state,false
NFACompiler -> NFAFactoryCompiler -> private void convertToLooping(final State<T> sourceState, final State<T> sinkState);1490089987;Converts the given state into looping one. Looping state is one with TAKE edge to itself and_PROCEED edge to the sinkState. It also consists of a similar state without the PROCEED edge, so that_for each PROCEED transition branches in computation state graph  can be created only once.__@param sourceState the state to converted_@param sinkState   the state that the converted state should point to;private void convertToLooping(final State<T> sourceState, final State<T> sinkState) {_			convertToLooping(sourceState, sinkState, false)__		};converts,the,given,state,into,looping,one,looping,state,is,one,with,take,edge,to,itself,and,proceed,edge,to,the,sink,state,it,also,consists,of,a,similar,state,without,the,proceed,edge,so,that,for,each,proceed,transition,branches,in,computation,state,graph,can,be,created,only,once,param,source,state,the,state,to,converted,param,sink,state,the,state,that,the,converted,state,should,point,to;private,void,convert,to,looping,final,state,t,source,state,final,state,t,sink,state,convert,to,looping,source,state,sink,state,false
NFACompiler -> NFAFactoryCompiler -> private void convertToLooping(final State<T> sourceState, final State<T> sinkState);1490194327;Converts the given state into looping one. Looping state is one with TAKE edge to itself and_PROCEED edge to the sinkState. It also consists of a similar state without the PROCEED edge, so that_for each PROCEED transition branches in computation state graph  can be created only once.__@param sourceState the state to converted_@param sinkState   the state that the converted state should point to;private void convertToLooping(final State<T> sourceState, final State<T> sinkState) {_			convertToLooping(sourceState, sinkState, false)__		};converts,the,given,state,into,looping,one,looping,state,is,one,with,take,edge,to,itself,and,proceed,edge,to,the,sink,state,it,also,consists,of,a,similar,state,without,the,proceed,edge,so,that,for,each,proceed,transition,branches,in,computation,state,graph,can,be,created,only,once,param,source,state,the,state,to,converted,param,sink,state,the,state,that,the,converted,state,should,point,to;private,void,convert,to,looping,final,state,t,source,state,final,state,t,sink,state,convert,to,looping,source,state,sink,state,false
NFACompiler -> NFAFactoryCompiler -> @SuppressWarnings("unchecked") 		private State<T> createSingletonState(final State<T> sinkState, boolean addIgnore, boolean isOptional);1491320734;Creates a simple single state. For an OPTIONAL state it also consists_of a similar state without the PROCEED edge, so that for each PROCEED transition branches_in computation state graph  can be created only once.__@param addIgnore if any IGNORE should be added_@param sinkState state that the state being converted should point to_@return the created state;@SuppressWarnings("unchecked")_		private State<T> createSingletonState(final State<T> sinkState, boolean addIgnore, boolean isOptional) {_			final IterativeCondition<T> currentFilterFunction = (IterativeCondition<T>) currentPattern.getCondition()__			final IterativeCondition<T> trueFunction = BooleanConditions.trueFunction()___			final State<T> singletonState = createNormalState()__			singletonState.addTake(sinkState, currentFilterFunction)___			if (isOptional) {_				singletonState.addProceed(sinkState, trueFunction)__			}__			if (addIgnore) {_				final State<T> ignoreState__				if (isOptional) {_					ignoreState = createNormalState()__					ignoreState.addTake(sinkState, currentFilterFunction)__				} else {_					ignoreState = singletonState__				}_				singletonState.addIgnore(ignoreState, trueFunction)__			}_			return singletonState__		};creates,a,simple,single,state,for,an,optional,state,it,also,consists,of,a,similar,state,without,the,proceed,edge,so,that,for,each,proceed,transition,branches,in,computation,state,graph,can,be,created,only,once,param,add,ignore,if,any,ignore,should,be,added,param,sink,state,state,that,the,state,being,converted,should,point,to,return,the,created,state;suppress,warnings,unchecked,private,state,t,create,singleton,state,final,state,t,sink,state,boolean,add,ignore,boolean,is,optional,final,iterative,condition,t,current,filter,function,iterative,condition,t,current,pattern,get,condition,final,iterative,condition,t,true,function,boolean,conditions,true,function,final,state,t,singleton,state,create,normal,state,singleton,state,add,take,sink,state,current,filter,function,if,is,optional,singleton,state,add,proceed,sink,state,true,function,if,add,ignore,final,state,t,ignore,state,if,is,optional,ignore,state,create,normal,state,ignore,state,add,take,sink,state,current,filter,function,else,ignore,state,singleton,state,singleton,state,add,ignore,ignore,state,true,function,return,singleton,state
NFACompiler -> NFAFactoryCompiler -> @SuppressWarnings("unchecked") 		private State<T> createSingletonState(final State<T> sinkState, boolean addIgnore, boolean isOptional);1492797583;Creates a simple single state. For an OPTIONAL state it also consists_of a similar state without the PROCEED edge, so that for each PROCEED transition branches_in computation state graph  can be created only once.__@param addIgnore if any IGNORE should be added_@param sinkState state that the state being converted should point to_@return the created state;@SuppressWarnings("unchecked")_		private State<T> createSingletonState(final State<T> sinkState, boolean addIgnore, boolean isOptional) {_			final IterativeCondition<T> currentFilterFunction = (IterativeCondition<T>) currentPattern.getCondition()__			final IterativeCondition<T> trueFunction = BooleanConditions.trueFunction()___			final State<T> singletonState = createNormalState()__			singletonState.addTake(sinkState, currentFilterFunction)___			if (isOptional) {_				singletonState.addProceed(sinkState, trueFunction)__			}__			if (addIgnore) {_				final State<T> ignoreState__				if (isOptional) {_					ignoreState = createNormalState()__					ignoreState.addTake(sinkState, currentFilterFunction)__				} else {_					ignoreState = singletonState__				}_				singletonState.addIgnore(ignoreState, getIgnoreCondition(currentPattern))__			}_			return singletonState__		};creates,a,simple,single,state,for,an,optional,state,it,also,consists,of,a,similar,state,without,the,proceed,edge,so,that,for,each,proceed,transition,branches,in,computation,state,graph,can,be,created,only,once,param,add,ignore,if,any,ignore,should,be,added,param,sink,state,state,that,the,state,being,converted,should,point,to,return,the,created,state;suppress,warnings,unchecked,private,state,t,create,singleton,state,final,state,t,sink,state,boolean,add,ignore,boolean,is,optional,final,iterative,condition,t,current,filter,function,iterative,condition,t,current,pattern,get,condition,final,iterative,condition,t,true,function,boolean,conditions,true,function,final,state,t,singleton,state,create,normal,state,singleton,state,add,take,sink,state,current,filter,function,if,is,optional,singleton,state,add,proceed,sink,state,true,function,if,add,ignore,final,state,t,ignore,state,if,is,optional,ignore,state,create,normal,state,ignore,state,add,take,sink,state,current,filter,function,else,ignore,state,singleton,state,singleton,state,add,ignore,ignore,state,get,ignore,condition,current,pattern,return,singleton,state
NFACompiler -> NFAFactoryCompiler -> @SuppressWarnings("unchecked") 		private void convertToLooping(final State<T> sourceState, final State<T> sinkState, boolean isFirstState);1489866780;Converts the given state into looping one. Looping state is one with TAKE edge to itself and_PROCEED edge to the sinkState. It also consists of a similar state without the PROCEED edge, so that_for each PROCEED transition branches in computation state graph  can be created only once.__<p>If this looping state is first of a graph we should treat the {@link Pattern} as {@link FollowedByPattern}_to enable combinations.__@param sourceState  the state to converted_@param sinkState    the state that the converted state should point to_@param isFirstState if the looping state is first of a graph;@SuppressWarnings("unchecked")_		private void convertToLooping(final State<T> sourceState, final State<T> sinkState, boolean isFirstState) {__			final FilterFunction<T> filterFunction = (FilterFunction<T>) currentPattern.getFilterFunction()__			final FilterFunction<T> trueFunction = FilterFunctions.<T>trueFunction()___			sourceState.addProceed(sinkState, trueFunction)__			sourceState.addTake(filterFunction)__			if (currentPattern instanceof FollowedByPattern || isFirstState) {_				final State<T> ignoreState = new State<>(_					currentPattern.getName(),_					State.StateType.Normal)____				final FilterFunction<T> ignoreCondition__				if (currentPattern.getQuantifier().hasProperty(QuantifierProperty.EAGER)) {_					ignoreCondition = new NotFilterFunction<>(filterFunction)__				} else {_					ignoreCondition = trueFunction__				}__				sourceState.addIgnore(ignoreState, ignoreCondition)__				ignoreState.addTake(sourceState, filterFunction)__				ignoreState.addIgnore(ignoreState, ignoreCondition)__				states.add(ignoreState)__			}_		};converts,the,given,state,into,looping,one,looping,state,is,one,with,take,edge,to,itself,and,proceed,edge,to,the,sink,state,it,also,consists,of,a,similar,state,without,the,proceed,edge,so,that,for,each,proceed,transition,branches,in,computation,state,graph,can,be,created,only,once,p,if,this,looping,state,is,first,of,a,graph,we,should,treat,the,link,pattern,as,link,followed,by,pattern,to,enable,combinations,param,source,state,the,state,to,converted,param,sink,state,the,state,that,the,converted,state,should,point,to,param,is,first,state,if,the,looping,state,is,first,of,a,graph;suppress,warnings,unchecked,private,void,convert,to,looping,final,state,t,source,state,final,state,t,sink,state,boolean,is,first,state,final,filter,function,t,filter,function,filter,function,t,current,pattern,get,filter,function,final,filter,function,t,true,function,filter,functions,t,true,function,source,state,add,proceed,sink,state,true,function,source,state,add,take,filter,function,if,current,pattern,instanceof,followed,by,pattern,is,first,state,final,state,t,ignore,state,new,state,current,pattern,get,name,state,state,type,normal,final,filter,function,t,ignore,condition,if,current,pattern,get,quantifier,has,property,quantifier,property,eager,ignore,condition,new,not,filter,function,filter,function,else,ignore,condition,true,function,source,state,add,ignore,ignore,state,ignore,condition,ignore,state,add,take,source,state,filter,function,ignore,state,add,ignore,ignore,state,ignore,condition,states,add,ignore,state
NFACompiler -> NFAFactoryCompiler -> @SuppressWarnings("unchecked") 		private void convertToLooping(final State<T> sourceState, final State<T> sinkState, boolean isFirstState);1490089987;Converts the given state into looping one. Looping state is one with TAKE edge to itself and_PROCEED edge to the sinkState. It also consists of a similar state without the PROCEED edge, so that_for each PROCEED transition branches in computation state graph  can be created only once.__<p>If this looping state is first of a graph we should treat the {@link Pattern} as {@link FollowedByPattern}_to enable combinations.__@param sourceState  the state to converted_@param sinkState    the state that the converted state should point to_@param isFirstState if the looping state is first of a graph;@SuppressWarnings("unchecked")_		private void convertToLooping(final State<T> sourceState, final State<T> sinkState, boolean isFirstState) {__			final FilterFunction<T> filterFunction = (FilterFunction<T>) currentPattern.getFilterFunction()__			final FilterFunction<T> trueFunction = FilterFunctions.<T>trueFunction()___			sourceState.addProceed(sinkState, trueFunction)__			sourceState.addTake(filterFunction)__			if (currentPattern instanceof FollowedByPattern || isFirstState) {_				final State<T> ignoreState = new State<>(_					currentPattern.getName(),_					State.StateType.Normal)____				final FilterFunction<T> ignoreCondition__				if (currentPattern.getQuantifier().hasProperty(QuantifierProperty.EAGER)) {_					ignoreCondition = new NotFilterFunction<>(filterFunction)__				} else {_					ignoreCondition = trueFunction__				}__				sourceState.addIgnore(ignoreState, ignoreCondition)__				ignoreState.addTake(sourceState, filterFunction)__				ignoreState.addIgnore(ignoreState, ignoreCondition)__				states.add(ignoreState)__			}_		};converts,the,given,state,into,looping,one,looping,state,is,one,with,take,edge,to,itself,and,proceed,edge,to,the,sink,state,it,also,consists,of,a,similar,state,without,the,proceed,edge,so,that,for,each,proceed,transition,branches,in,computation,state,graph,can,be,created,only,once,p,if,this,looping,state,is,first,of,a,graph,we,should,treat,the,link,pattern,as,link,followed,by,pattern,to,enable,combinations,param,source,state,the,state,to,converted,param,sink,state,the,state,that,the,converted,state,should,point,to,param,is,first,state,if,the,looping,state,is,first,of,a,graph;suppress,warnings,unchecked,private,void,convert,to,looping,final,state,t,source,state,final,state,t,sink,state,boolean,is,first,state,final,filter,function,t,filter,function,filter,function,t,current,pattern,get,filter,function,final,filter,function,t,true,function,filter,functions,t,true,function,source,state,add,proceed,sink,state,true,function,source,state,add,take,filter,function,if,current,pattern,instanceof,followed,by,pattern,is,first,state,final,state,t,ignore,state,new,state,current,pattern,get,name,state,state,type,normal,final,filter,function,t,ignore,condition,if,current,pattern,get,quantifier,has,property,quantifier,property,eager,ignore,condition,new,not,filter,function,filter,function,else,ignore,condition,true,function,source,state,add,ignore,ignore,state,ignore,condition,ignore,state,add,take,source,state,filter,function,ignore,state,add,ignore,ignore,state,ignore,condition,states,add,ignore,state
NFACompiler -> NFAFactoryCompiler -> @SuppressWarnings("unchecked") 		private void convertToLooping(final State<T> sourceState, final State<T> sinkState, boolean isFirstState);1490194327;Converts the given state into looping one. Looping state is one with TAKE edge to itself and_PROCEED edge to the sinkState. It also consists of a similar state without the PROCEED edge, so that_for each PROCEED transition branches in computation state graph  can be created only once.__<p>If this looping state is first of a graph we should treat the {@link Pattern} as {@link FollowedByPattern}_to enable combinations.__@param sourceState  the state to converted_@param sinkState    the state that the converted state should point to_@param isFirstState if the looping state is first of a graph;@SuppressWarnings("unchecked")_		private void convertToLooping(final State<T> sourceState, final State<T> sinkState, boolean isFirstState) {__			final IterativeCondition<T> filterFunction = (IterativeCondition<T>) currentPattern.getCondition()__			final IterativeCondition<T> trueFunction = BooleanConditions.<T>trueFunction()___			sourceState.addProceed(sinkState, trueFunction)__			sourceState.addTake(filterFunction)__			if (currentPattern instanceof FollowedByPattern || isFirstState) {_				final State<T> ignoreState = new State<>(_					currentPattern.getName(),_					State.StateType.Normal)___				final IterativeCondition<T> ignoreCondition = getIgnoreCondition(currentPattern)___				sourceState.addIgnore(ignoreState, ignoreCondition)__				ignoreState.addTake(sourceState, filterFunction)__				ignoreState.addIgnore(ignoreState, ignoreCondition)__				states.add(ignoreState)__			}_		};converts,the,given,state,into,looping,one,looping,state,is,one,with,take,edge,to,itself,and,proceed,edge,to,the,sink,state,it,also,consists,of,a,similar,state,without,the,proceed,edge,so,that,for,each,proceed,transition,branches,in,computation,state,graph,can,be,created,only,once,p,if,this,looping,state,is,first,of,a,graph,we,should,treat,the,link,pattern,as,link,followed,by,pattern,to,enable,combinations,param,source,state,the,state,to,converted,param,sink,state,the,state,that,the,converted,state,should,point,to,param,is,first,state,if,the,looping,state,is,first,of,a,graph;suppress,warnings,unchecked,private,void,convert,to,looping,final,state,t,source,state,final,state,t,sink,state,boolean,is,first,state,final,iterative,condition,t,filter,function,iterative,condition,t,current,pattern,get,condition,final,iterative,condition,t,true,function,boolean,conditions,t,true,function,source,state,add,proceed,sink,state,true,function,source,state,add,take,filter,function,if,current,pattern,instanceof,followed,by,pattern,is,first,state,final,state,t,ignore,state,new,state,current,pattern,get,name,state,state,type,normal,final,iterative,condition,t,ignore,condition,get,ignore,condition,current,pattern,source,state,add,ignore,ignore,state,ignore,condition,ignore,state,add,take,source,state,filter,function,ignore,state,add,ignore,ignore,state,ignore,condition,states,add,ignore,state
NFACompiler -> NFAFactoryCompiler -> private void checkPatternNameUniqueness(final Pattern pattern);1498034481;Check if the given pattern's name is already used or not. If yes, it_throws a {@link MalformedPatternException}.__@param pattern The pattern to be checked;private void checkPatternNameUniqueness(final Pattern pattern) {_			if (pattern instanceof GroupPattern) {_				Pattern patternToCheck = ((GroupPattern) pattern).getRawPattern()__				while (patternToCheck != null) {_					checkPatternNameUniqueness(patternToCheck)__					patternToCheck = patternToCheck.getPrevious()__				}_			} else {_				stateNameHandler.checkNameUniqueness(pattern.getName())__			}_		};check,if,the,given,pattern,s,name,is,already,used,or,not,if,yes,it,throws,a,link,malformed,pattern,exception,param,pattern,the,pattern,to,be,checked;private,void,check,pattern,name,uniqueness,final,pattern,pattern,if,pattern,instanceof,group,pattern,pattern,pattern,to,check,group,pattern,pattern,get,raw,pattern,while,pattern,to,check,null,check,pattern,name,uniqueness,pattern,to,check,pattern,to,check,pattern,to,check,get,previous,else,state,name,handler,check,name,uniqueness,pattern,get,name
NFACompiler -> NFAFactoryCompiler -> private void checkPatternNameUniqueness(final Pattern pattern);1499760222;Check if the given pattern's name is already used or not. If yes, it_throws a {@link MalformedPatternException}.__@param pattern The pattern to be checked;private void checkPatternNameUniqueness(final Pattern pattern) {_			if (pattern instanceof GroupPattern) {_				Pattern patternToCheck = ((GroupPattern) pattern).getRawPattern()__				while (patternToCheck != null) {_					checkPatternNameUniqueness(patternToCheck)__					patternToCheck = patternToCheck.getPrevious()__				}_			} else {_				stateNameHandler.checkNameUniqueness(pattern.getName())__			}_		};check,if,the,given,pattern,s,name,is,already,used,or,not,if,yes,it,throws,a,link,malformed,pattern,exception,param,pattern,the,pattern,to,be,checked;private,void,check,pattern,name,uniqueness,final,pattern,pattern,if,pattern,instanceof,group,pattern,pattern,pattern,to,check,group,pattern,pattern,get,raw,pattern,while,pattern,to,check,null,check,pattern,name,uniqueness,pattern,to,check,pattern,to,check,pattern,to,check,get,previous,else,state,name,handler,check,name,uniqueness,pattern,get,name
NFACompiler -> NFAFactoryCompiler -> private void checkPatternNameUniqueness(final Pattern pattern);1499937690;Check if the given pattern's name is already used or not. If yes, it_throws a {@link MalformedPatternException}.__@param pattern The pattern to be checked;private void checkPatternNameUniqueness(final Pattern pattern) {_			if (pattern instanceof GroupPattern) {_				Pattern patternToCheck = ((GroupPattern) pattern).getRawPattern()__				while (patternToCheck != null) {_					checkPatternNameUniqueness(patternToCheck)__					patternToCheck = patternToCheck.getPrevious()__				}_			} else {_				stateNameHandler.checkNameUniqueness(pattern.getName())__			}_		};check,if,the,given,pattern,s,name,is,already,used,or,not,if,yes,it,throws,a,link,malformed,pattern,exception,param,pattern,the,pattern,to,be,checked;private,void,check,pattern,name,uniqueness,final,pattern,pattern,if,pattern,instanceof,group,pattern,pattern,pattern,to,check,group,pattern,pattern,get,raw,pattern,while,pattern,to,check,null,check,pattern,name,uniqueness,pattern,to,check,pattern,to,check,pattern,to,check,get,previous,else,state,name,handler,check,name,uniqueness,pattern,get,name
NFACompiler -> NFAFactoryCompiler -> private void checkPatternNameUniqueness(final Pattern pattern);1500021711;Check if the given pattern's name is already used or not. If yes, it_throws a {@link MalformedPatternException}.__@param pattern The pattern to be checked;private void checkPatternNameUniqueness(final Pattern pattern) {_			if (pattern instanceof GroupPattern) {_				Pattern patternToCheck = ((GroupPattern) pattern).getRawPattern()__				while (patternToCheck != null) {_					checkPatternNameUniqueness(patternToCheck)__					patternToCheck = patternToCheck.getPrevious()__				}_			} else {_				stateNameHandler.checkNameUniqueness(pattern.getName())__			}_		};check,if,the,given,pattern,s,name,is,already,used,or,not,if,yes,it,throws,a,link,malformed,pattern,exception,param,pattern,the,pattern,to,be,checked;private,void,check,pattern,name,uniqueness,final,pattern,pattern,if,pattern,instanceof,group,pattern,pattern,pattern,to,check,group,pattern,pattern,get,raw,pattern,while,pattern,to,check,null,check,pattern,name,uniqueness,pattern,to,check,pattern,to,check,pattern,to,check,get,previous,else,state,name,handler,check,name,uniqueness,pattern,get,name
NFACompiler -> NFAFactoryCompiler -> private void checkPatternNameUniqueness(final Pattern pattern);1501592283;Check if the given pattern's name is already used or not. If yes, it_throws a {@link MalformedPatternException}.__@param pattern The pattern to be checked;private void checkPatternNameUniqueness(final Pattern pattern) {_			if (pattern instanceof GroupPattern) {_				Pattern patternToCheck = ((GroupPattern) pattern).getRawPattern()__				while (patternToCheck != null) {_					checkPatternNameUniqueness(patternToCheck)__					patternToCheck = patternToCheck.getPrevious()__				}_			} else {_				stateNameHandler.checkNameUniqueness(pattern.getName())__			}_		};check,if,the,given,pattern,s,name,is,already,used,or,not,if,yes,it,throws,a,link,malformed,pattern,exception,param,pattern,the,pattern,to,be,checked;private,void,check,pattern,name,uniqueness,final,pattern,pattern,if,pattern,instanceof,group,pattern,pattern,pattern,to,check,group,pattern,pattern,get,raw,pattern,while,pattern,to,check,null,check,pattern,name,uniqueness,pattern,to,check,pattern,to,check,pattern,to,check,get,previous,else,state,name,handler,check,name,uniqueness,pattern,get,name
NFACompiler -> NFAFactoryCompiler -> private void checkPatternNameUniqueness(final Pattern pattern);1502422141;Check if the given pattern's name is already used or not. If yes, it_throws a {@link MalformedPatternException}.__@param pattern The pattern to be checked;private void checkPatternNameUniqueness(final Pattern pattern) {_			if (pattern instanceof GroupPattern) {_				Pattern patternToCheck = ((GroupPattern) pattern).getRawPattern()__				while (patternToCheck != null) {_					checkPatternNameUniqueness(patternToCheck)__					patternToCheck = patternToCheck.getPrevious()__				}_			} else {_				stateNameHandler.checkNameUniqueness(pattern.getName())__			}_		};check,if,the,given,pattern,s,name,is,already,used,or,not,if,yes,it,throws,a,link,malformed,pattern,exception,param,pattern,the,pattern,to,be,checked;private,void,check,pattern,name,uniqueness,final,pattern,pattern,if,pattern,instanceof,group,pattern,pattern,pattern,to,check,group,pattern,pattern,get,raw,pattern,while,pattern,to,check,null,check,pattern,name,uniqueness,pattern,to,check,pattern,to,check,pattern,to,check,get,previous,else,state,name,handler,check,name,uniqueness,pattern,get,name
NFACompiler -> NFAFactoryCompiler -> private void checkPatternNameUniqueness(final Pattern pattern);1503588494;Check if the given pattern's name is already used or not. If yes, it_throws a {@link MalformedPatternException}.__@param pattern The pattern to be checked;private void checkPatternNameUniqueness(final Pattern pattern) {_			if (pattern instanceof GroupPattern) {_				Pattern patternToCheck = ((GroupPattern) pattern).getRawPattern()__				while (patternToCheck != null) {_					checkPatternNameUniqueness(patternToCheck)__					patternToCheck = patternToCheck.getPrevious()__				}_			} else {_				stateNameHandler.checkNameUniqueness(pattern.getName())__			}_		};check,if,the,given,pattern,s,name,is,already,used,or,not,if,yes,it,throws,a,link,malformed,pattern,exception,param,pattern,the,pattern,to,be,checked;private,void,check,pattern,name,uniqueness,final,pattern,pattern,if,pattern,instanceof,group,pattern,pattern,pattern,to,check,group,pattern,pattern,get,raw,pattern,while,pattern,to,check,null,check,pattern,name,uniqueness,pattern,to,check,pattern,to,check,pattern,to,check,get,previous,else,state,name,handler,check,name,uniqueness,pattern,get,name
NFACompiler -> NFAFactoryCompiler -> private void checkPatternNameUniqueness(final Pattern pattern);1518008111;Check if the given pattern's name is already used or not. If yes, it_throws a {@link MalformedPatternException}.__@param pattern The pattern to be checked;private void checkPatternNameUniqueness(final Pattern pattern) {_			if (pattern instanceof GroupPattern) {_				Pattern patternToCheck = ((GroupPattern) pattern).getRawPattern()__				while (patternToCheck != null) {_					checkPatternNameUniqueness(patternToCheck)__					patternToCheck = patternToCheck.getPrevious()__				}_			} else {_				stateNameHandler.checkNameUniqueness(pattern.getName())__			}_		};check,if,the,given,pattern,s,name,is,already,used,or,not,if,yes,it,throws,a,link,malformed,pattern,exception,param,pattern,the,pattern,to,be,checked;private,void,check,pattern,name,uniqueness,final,pattern,pattern,if,pattern,instanceof,group,pattern,pattern,pattern,to,check,group,pattern,pattern,get,raw,pattern,while,pattern,to,check,null,check,pattern,name,uniqueness,pattern,to,check,pattern,to,check,pattern,to,check,get,previous,else,state,name,handler,check,name,uniqueness,pattern,get,name
NFACompiler -> NFAFactoryCompiler -> private void checkPatternNameUniqueness(final Pattern pattern);1527863170;Check if the given pattern's name is already used or not. If yes, it_throws a {@link MalformedPatternException}.__@param pattern The pattern to be checked;private void checkPatternNameUniqueness(final Pattern pattern) {_			if (pattern instanceof GroupPattern) {_				Pattern patternToCheck = ((GroupPattern) pattern).getRawPattern()__				while (patternToCheck != null) {_					checkPatternNameUniqueness(patternToCheck)__					patternToCheck = patternToCheck.getPrevious()__				}_			} else {_				stateNameHandler.checkNameUniqueness(pattern.getName())__			}_		};check,if,the,given,pattern,s,name,is,already,used,or,not,if,yes,it,throws,a,link,malformed,pattern,exception,param,pattern,the,pattern,to,be,checked;private,void,check,pattern,name,uniqueness,final,pattern,pattern,if,pattern,instanceof,group,pattern,pattern,pattern,to,check,group,pattern,pattern,get,raw,pattern,while,pattern,to,check,null,check,pattern,name,uniqueness,pattern,to,check,pattern,to,check,pattern,to,check,get,previous,else,state,name,handler,check,name,uniqueness,pattern,get,name
NFACompiler -> NFAFactoryCompiler -> private void checkPatternNameUniqueness(final Pattern pattern);1528989005;Check if the given pattern's name is already used or not. If yes, it_throws a {@link MalformedPatternException}.__@param pattern The pattern to be checked;private void checkPatternNameUniqueness(final Pattern pattern) {_			if (pattern instanceof GroupPattern) {_				Pattern patternToCheck = ((GroupPattern) pattern).getRawPattern()__				while (patternToCheck != null) {_					checkPatternNameUniqueness(patternToCheck)__					patternToCheck = patternToCheck.getPrevious()__				}_			} else {_				stateNameHandler.checkNameUniqueness(pattern.getName())__			}_		};check,if,the,given,pattern,s,name,is,already,used,or,not,if,yes,it,throws,a,link,malformed,pattern,exception,param,pattern,the,pattern,to,be,checked;private,void,check,pattern,name,uniqueness,final,pattern,pattern,if,pattern,instanceof,group,pattern,pattern,pattern,to,check,group,pattern,pattern,get,raw,pattern,while,pattern,to,check,null,check,pattern,name,uniqueness,pattern,to,check,pattern,to,check,pattern,to,check,get,previous,else,state,name,handler,check,name,uniqueness,pattern,get,name
NFACompiler -> NFAFactoryCompiler -> private void checkPatternNameUniqueness(final Pattern pattern);1538745898;Check if the given pattern's name is already used or not. If yes, it_throws a {@link MalformedPatternException}.__@param pattern The pattern to be checked;private void checkPatternNameUniqueness(final Pattern pattern) {_			if (pattern instanceof GroupPattern) {_				Pattern patternToCheck = ((GroupPattern) pattern).getRawPattern()__				while (patternToCheck != null) {_					checkPatternNameUniqueness(patternToCheck)__					patternToCheck = patternToCheck.getPrevious()__				}_			} else {_				stateNameHandler.checkNameUniqueness(pattern.getName())__			}_		};check,if,the,given,pattern,s,name,is,already,used,or,not,if,yes,it,throws,a,link,malformed,pattern,exception,param,pattern,the,pattern,to,be,checked;private,void,check,pattern,name,uniqueness,final,pattern,pattern,if,pattern,instanceof,group,pattern,pattern,pattern,to,check,group,pattern,pattern,get,raw,pattern,while,pattern,to,check,null,check,pattern,name,uniqueness,pattern,to,check,pattern,to,check,pattern,to,check,get,previous,else,state,name,handler,check,name,uniqueness,pattern,get,name
NFACompiler -> NFAFactoryCompiler -> private void checkPatternNameUniqueness(final Pattern pattern);1542293931;Check if the given pattern's name is already used or not. If yes, it_throws a {@link MalformedPatternException}.__@param pattern The pattern to be checked;private void checkPatternNameUniqueness(final Pattern pattern) {_			if (pattern instanceof GroupPattern) {_				Pattern patternToCheck = ((GroupPattern) pattern).getRawPattern()__				while (patternToCheck != null) {_					checkPatternNameUniqueness(patternToCheck)__					patternToCheck = patternToCheck.getPrevious()__				}_			} else {_				stateNameHandler.checkNameUniqueness(pattern.getName())__			}_		};check,if,the,given,pattern,s,name,is,already,used,or,not,if,yes,it,throws,a,link,malformed,pattern,exception,param,pattern,the,pattern,to,be,checked;private,void,check,pattern,name,uniqueness,final,pattern,pattern,if,pattern,instanceof,group,pattern,pattern,pattern,to,check,group,pattern,pattern,get,raw,pattern,while,pattern,to,check,null,check,pattern,name,uniqueness,pattern,to,check,pattern,to,check,pattern,to,check,get,previous,else,state,name,handler,check,name,uniqueness,pattern,get,name
NFACompiler -> NFAFactoryCompiler -> private State<T> createTimesState(final State<T> sinkState, Times times);1497410381;Creates a "complex" state consisting of given number of states with_same {@link IterativeCondition}.__@param sinkState the state that the created state should point to_@param times     number of times the state should be copied_@return the first state of the "complex" state, next state should point to it;private State<T> createTimesState(final State<T> sinkState, Times times) {_			State<T> lastSink = sinkState__			final IterativeCondition<T> innerIgnoreCondition = getInnerIgnoreCondition(currentPattern)__			for (int i = times.getFrom()_ i < times.getTo()_ i++) {_				lastSink = createSingletonState(lastSink, sinkState, innerIgnoreCondition, true)__				addStopStateToLooping(lastSink)__			}_			for (int i = 0_ i < times.getFrom() - 1_ i++) {_				lastSink = createSingletonState(lastSink, null, innerIgnoreCondition, false)__				addStopStateToLooping(lastSink)__			}_			_			return createSingletonState(_				lastSink,_				sinkState,_				getIgnoreCondition(currentPattern),_				currentPattern.getQuantifier().hasProperty(Quantifier.QuantifierProperty.OPTIONAL))__		};creates,a,complex,state,consisting,of,given,number,of,states,with,same,link,iterative,condition,param,sink,state,the,state,that,the,created,state,should,point,to,param,times,number,of,times,the,state,should,be,copied,return,the,first,state,of,the,complex,state,next,state,should,point,to,it;private,state,t,create,times,state,final,state,t,sink,state,times,times,state,t,last,sink,sink,state,final,iterative,condition,t,inner,ignore,condition,get,inner,ignore,condition,current,pattern,for,int,i,times,get,from,i,times,get,to,i,last,sink,create,singleton,state,last,sink,sink,state,inner,ignore,condition,true,add,stop,state,to,looping,last,sink,for,int,i,0,i,times,get,from,1,i,last,sink,create,singleton,state,last,sink,null,inner,ignore,condition,false,add,stop,state,to,looping,last,sink,return,create,singleton,state,last,sink,sink,state,get,ignore,condition,current,pattern,current,pattern,get,quantifier,has,property,quantifier,quantifier,property,optional
NFACompiler -> NFAFactoryCompiler -> private State<T> createTimesState(final State<T> sinkState, Times times);1497883202;Creates a "complex" state consisting of given number of states with_same {@link IterativeCondition}.__@param sinkState the state that the created state should point to_@param times     number of times the state should be copied_@return the first state of the "complex" state, next state should point to it;private State<T> createTimesState(final State<T> sinkState, Times times) {_			State<T> lastSink = sinkState__			final IterativeCondition<T> innerIgnoreCondition = getInnerIgnoreCondition(currentPattern)__			for (int i = times.getFrom()_ i < times.getTo()_ i++) {_				lastSink = createSingletonState(lastSink, sinkState, innerIgnoreCondition, true)__				addStopStateToLooping(lastSink)__			}_			for (int i = 0_ i < times.getFrom() - 1_ i++) {_				lastSink = createSingletonState(lastSink, null, innerIgnoreCondition, false)__				addStopStateToLooping(lastSink)__			}_			_			return createSingletonState(_				lastSink,_				sinkState,_				getIgnoreCondition(currentPattern),_				currentPattern.getQuantifier().hasProperty(Quantifier.QuantifierProperty.OPTIONAL))__		};creates,a,complex,state,consisting,of,given,number,of,states,with,same,link,iterative,condition,param,sink,state,the,state,that,the,created,state,should,point,to,param,times,number,of,times,the,state,should,be,copied,return,the,first,state,of,the,complex,state,next,state,should,point,to,it;private,state,t,create,times,state,final,state,t,sink,state,times,times,state,t,last,sink,sink,state,final,iterative,condition,t,inner,ignore,condition,get,inner,ignore,condition,current,pattern,for,int,i,times,get,from,i,times,get,to,i,last,sink,create,singleton,state,last,sink,sink,state,inner,ignore,condition,true,add,stop,state,to,looping,last,sink,for,int,i,0,i,times,get,from,1,i,last,sink,create,singleton,state,last,sink,null,inner,ignore,condition,false,add,stop,state,to,looping,last,sink,return,create,singleton,state,last,sink,sink,state,get,ignore,condition,current,pattern,current,pattern,get,quantifier,has,property,quantifier,quantifier,property,optional
NFACompiler -> NFAFactoryCompiler -> private State<T> createTimesState(final State<T> sinkState, Times times);1498034481;Creates a "complex" state consisting of given number of states with_same {@link IterativeCondition}.__@param sinkState the state that the created state should point to_@param times     number of times the state should be copied_@return the first state of the "complex" state, next state should point to it;private State<T> createTimesState(final State<T> sinkState, Times times) {_			State<T> lastSink = sinkState__			setCurrentGroupPatternFirstOfLoop(false)__			final IterativeCondition<T> takeCondition = getTakeCondition(currentPattern)__			final IterativeCondition<T> innerIgnoreCondition = getInnerIgnoreCondition(currentPattern)__			for (int i = times.getFrom()_ i < times.getTo()_ i++) {_				lastSink = createSingletonState(lastSink, sinkState, takeCondition, innerIgnoreCondition, true)__				addStopStateToLooping(lastSink)__			}_			for (int i = 0_ i < times.getFrom() - 1_ i++) {_				lastSink = createSingletonState(lastSink, null, takeCondition, innerIgnoreCondition, false)__				addStopStateToLooping(lastSink)__			}_			_			setCurrentGroupPatternFirstOfLoop(true)__			return createSingletonState(_				lastSink,_				sinkState,_				takeCondition,_				getIgnoreCondition(currentPattern),_				currentPattern.getQuantifier().hasProperty(Quantifier.QuantifierProperty.OPTIONAL))__		};creates,a,complex,state,consisting,of,given,number,of,states,with,same,link,iterative,condition,param,sink,state,the,state,that,the,created,state,should,point,to,param,times,number,of,times,the,state,should,be,copied,return,the,first,state,of,the,complex,state,next,state,should,point,to,it;private,state,t,create,times,state,final,state,t,sink,state,times,times,state,t,last,sink,sink,state,set,current,group,pattern,first,of,loop,false,final,iterative,condition,t,take,condition,get,take,condition,current,pattern,final,iterative,condition,t,inner,ignore,condition,get,inner,ignore,condition,current,pattern,for,int,i,times,get,from,i,times,get,to,i,last,sink,create,singleton,state,last,sink,sink,state,take,condition,inner,ignore,condition,true,add,stop,state,to,looping,last,sink,for,int,i,0,i,times,get,from,1,i,last,sink,create,singleton,state,last,sink,null,take,condition,inner,ignore,condition,false,add,stop,state,to,looping,last,sink,set,current,group,pattern,first,of,loop,true,return,create,singleton,state,last,sink,sink,state,take,condition,get,ignore,condition,current,pattern,current,pattern,get,quantifier,has,property,quantifier,quantifier,property,optional
NFACompiler -> NFAFactoryCompiler -> private State<T> createTimesState(final State<T> sinkState, Times times);1499937690;Creates a "complex" state consisting of given number of states with_same {@link IterativeCondition}.__@param sinkState the state that the created state should point to_@param times     number of times the state should be copied_@return the first state of the "complex" state, next state should point to it;private State<T> createTimesState(final State<T> sinkState, Times times) {_			State<T> lastSink = sinkState__			setCurrentGroupPatternFirstOfLoop(false)__			final IterativeCondition<T> takeCondition = getTakeCondition(currentPattern)__			final IterativeCondition<T> innerIgnoreCondition = getInnerIgnoreCondition(currentPattern)__			for (int i = times.getFrom()_ i < times.getTo()_ i++) {_				lastSink = createSingletonState(lastSink, sinkState, takeCondition, innerIgnoreCondition, true)__				addStopStateToLooping(lastSink)__			}_			for (int i = 0_ i < times.getFrom() - 1_ i++) {_				lastSink = createSingletonState(lastSink, null, takeCondition, innerIgnoreCondition, false)__				addStopStateToLooping(lastSink)__			}_			_			setCurrentGroupPatternFirstOfLoop(true)__			return createSingletonState(_				lastSink,_				sinkState,_				takeCondition,_				getIgnoreCondition(currentPattern),_				currentPattern.getQuantifier().hasProperty(Quantifier.QuantifierProperty.OPTIONAL))__		};creates,a,complex,state,consisting,of,given,number,of,states,with,same,link,iterative,condition,param,sink,state,the,state,that,the,created,state,should,point,to,param,times,number,of,times,the,state,should,be,copied,return,the,first,state,of,the,complex,state,next,state,should,point,to,it;private,state,t,create,times,state,final,state,t,sink,state,times,times,state,t,last,sink,sink,state,set,current,group,pattern,first,of,loop,false,final,iterative,condition,t,take,condition,get,take,condition,current,pattern,final,iterative,condition,t,inner,ignore,condition,get,inner,ignore,condition,current,pattern,for,int,i,times,get,from,i,times,get,to,i,last,sink,create,singleton,state,last,sink,sink,state,take,condition,inner,ignore,condition,true,add,stop,state,to,looping,last,sink,for,int,i,0,i,times,get,from,1,i,last,sink,create,singleton,state,last,sink,null,take,condition,inner,ignore,condition,false,add,stop,state,to,looping,last,sink,set,current,group,pattern,first,of,loop,true,return,create,singleton,state,last,sink,sink,state,take,condition,get,ignore,condition,current,pattern,current,pattern,get,quantifier,has,property,quantifier,quantifier,property,optional
NFACompiler -> NFAFactoryCompiler -> private State<T> createTimesState(final State<T> sinkState, Times times);1501592283;Creates a "complex" state consisting of given number of states with_same {@link IterativeCondition}.__@param sinkState the state that the created state should point to_@param times     number of times the state should be copied_@return the first state of the "complex" state, next state should point to it;private State<T> createTimesState(final State<T> sinkState, Times times) {_			State<T> lastSink = sinkState__			setCurrentGroupPatternFirstOfLoop(false)__			final IterativeCondition<T> takeCondition = getTakeCondition(currentPattern)__			final IterativeCondition<T> innerIgnoreCondition = getInnerIgnoreCondition(currentPattern)__			for (int i = times.getFrom()_ i < times.getTo()_ i++) {_				lastSink = createSingletonState(lastSink, sinkState, takeCondition, innerIgnoreCondition, true)__				addStopStateToLooping(lastSink)__			}_			for (int i = 0_ i < times.getFrom() - 1_ i++) {_				lastSink = createSingletonState(lastSink, null, takeCondition, innerIgnoreCondition, false)__				addStopStateToLooping(lastSink)__			}_			_			setCurrentGroupPatternFirstOfLoop(true)__			return createSingletonState(_				lastSink,_				sinkState,_				takeCondition,_				getIgnoreCondition(currentPattern),_				currentPattern.getQuantifier().hasProperty(Quantifier.QuantifierProperty.OPTIONAL))__		};creates,a,complex,state,consisting,of,given,number,of,states,with,same,link,iterative,condition,param,sink,state,the,state,that,the,created,state,should,point,to,param,times,number,of,times,the,state,should,be,copied,return,the,first,state,of,the,complex,state,next,state,should,point,to,it;private,state,t,create,times,state,final,state,t,sink,state,times,times,state,t,last,sink,sink,state,set,current,group,pattern,first,of,loop,false,final,iterative,condition,t,take,condition,get,take,condition,current,pattern,final,iterative,condition,t,inner,ignore,condition,get,inner,ignore,condition,current,pattern,for,int,i,times,get,from,i,times,get,to,i,last,sink,create,singleton,state,last,sink,sink,state,take,condition,inner,ignore,condition,true,add,stop,state,to,looping,last,sink,for,int,i,0,i,times,get,from,1,i,last,sink,create,singleton,state,last,sink,null,take,condition,inner,ignore,condition,false,add,stop,state,to,looping,last,sink,set,current,group,pattern,first,of,loop,true,return,create,singleton,state,last,sink,sink,state,take,condition,get,ignore,condition,current,pattern,current,pattern,get,quantifier,has,property,quantifier,quantifier,property,optional
NFACompiler -> NFAFactoryCompiler -> private IterativeCondition<T> extendWithUntilCondition( 				IterativeCondition<T> condition, 				IterativeCondition<T> untilCondition);1497883202;This method extends the given condition with stop(until) condition if necessary._The until condition needs to be applied only if both of the given conditions are not null.__@param condition the condition to extend_@param untilCondition the until condition to join with the given condition_@return condition with AND applied or the original condition;private IterativeCondition<T> extendWithUntilCondition(_				IterativeCondition<T> condition,_				IterativeCondition<T> untilCondition) {_			if (untilCondition != null && condition != null) {_				return new AndCondition<>(new NotCondition<>(untilCondition), condition)__			} else if (untilCondition != null) {_				return new NotCondition<>(untilCondition)__			}__			return condition__		};this,method,extends,the,given,condition,with,stop,until,condition,if,necessary,the,until,condition,needs,to,be,applied,only,if,both,of,the,given,conditions,are,not,null,param,condition,the,condition,to,extend,param,until,condition,the,until,condition,to,join,with,the,given,condition,return,condition,with,and,applied,or,the,original,condition;private,iterative,condition,t,extend,with,until,condition,iterative,condition,t,condition,iterative,condition,t,until,condition,if,until,condition,null,condition,null,return,new,and,condition,new,not,condition,until,condition,condition,else,if,until,condition,null,return,new,not,condition,until,condition,return,condition
NFACompiler -> NFAFactoryCompiler -> private IterativeCondition<T> extendWithUntilCondition( 				IterativeCondition<T> condition, 				IterativeCondition<T> untilCondition);1498034481;This method extends the given condition with stop(until) condition if necessary._The until condition needs to be applied only if both of the given conditions are not null.__@param condition the condition to extend_@param untilCondition the until condition to join with the given condition_@return condition with AND applied or the original condition;private IterativeCondition<T> extendWithUntilCondition(_				IterativeCondition<T> condition,_				IterativeCondition<T> untilCondition) {_			if (untilCondition != null && condition != null) {_				return new AndCondition<>(new NotCondition<>(untilCondition), condition)__			} else if (untilCondition != null) {_				return new NotCondition<>(untilCondition)__			}__			return condition__		};this,method,extends,the,given,condition,with,stop,until,condition,if,necessary,the,until,condition,needs,to,be,applied,only,if,both,of,the,given,conditions,are,not,null,param,condition,the,condition,to,extend,param,until,condition,the,until,condition,to,join,with,the,given,condition,return,condition,with,and,applied,or,the,original,condition;private,iterative,condition,t,extend,with,until,condition,iterative,condition,t,condition,iterative,condition,t,until,condition,if,until,condition,null,condition,null,return,new,and,condition,new,not,condition,until,condition,condition,else,if,until,condition,null,return,new,not,condition,until,condition,return,condition
NFACompiler -> NFAFactoryCompiler -> private boolean headOfGroup(Pattern<T, ?> pattern);1498034481;Checks if the given pattern is the head pattern of the current group pattern.__@param pattern the pattern to be checked_@return {@code true} iff the given pattern is in a group pattern and it is the head pattern of the_group pattern, {@code false} otherwise;private boolean headOfGroup(Pattern<T, ?> pattern) {_			return currentGroupPattern != null && pattern.getPrevious() == null__		};checks,if,the,given,pattern,is,the,head,pattern,of,the,current,group,pattern,param,pattern,the,pattern,to,be,checked,return,code,true,iff,the,given,pattern,is,in,a,group,pattern,and,it,is,the,head,pattern,of,the,group,pattern,code,false,otherwise;private,boolean,head,of,group,pattern,t,pattern,return,current,group,pattern,null,pattern,get,previous,null
NFACompiler -> NFAFactoryCompiler -> private boolean headOfGroup(Pattern<T, ?> pattern);1499760222;Checks if the given pattern is the head pattern of the current group pattern.__@param pattern the pattern to be checked_@return {@code true} iff the given pattern is in a group pattern and it is the head pattern of the_group pattern, {@code false} otherwise;private boolean headOfGroup(Pattern<T, ?> pattern) {_			return currentGroupPattern != null && pattern.getPrevious() == null__		};checks,if,the,given,pattern,is,the,head,pattern,of,the,current,group,pattern,param,pattern,the,pattern,to,be,checked,return,code,true,iff,the,given,pattern,is,in,a,group,pattern,and,it,is,the,head,pattern,of,the,group,pattern,code,false,otherwise;private,boolean,head,of,group,pattern,t,pattern,return,current,group,pattern,null,pattern,get,previous,null
NFACompiler -> NFAFactoryCompiler -> private boolean headOfGroup(Pattern<T, ?> pattern);1499937690;Checks if the given pattern is the head pattern of the current group pattern.__@param pattern the pattern to be checked_@return {@code true} iff the given pattern is in a group pattern and it is the head pattern of the_group pattern, {@code false} otherwise;private boolean headOfGroup(Pattern<T, ?> pattern) {_			return currentGroupPattern != null && pattern.getPrevious() == null__		};checks,if,the,given,pattern,is,the,head,pattern,of,the,current,group,pattern,param,pattern,the,pattern,to,be,checked,return,code,true,iff,the,given,pattern,is,in,a,group,pattern,and,it,is,the,head,pattern,of,the,group,pattern,code,false,otherwise;private,boolean,head,of,group,pattern,t,pattern,return,current,group,pattern,null,pattern,get,previous,null
NFACompiler -> NFAFactoryCompiler -> private boolean headOfGroup(Pattern<T, ?> pattern);1500021711;Checks if the given pattern is the head pattern of the current group pattern.__@param pattern the pattern to be checked_@return {@code true} iff the given pattern is in a group pattern and it is the head pattern of the_group pattern, {@code false} otherwise;private boolean headOfGroup(Pattern<T, ?> pattern) {_			return currentGroupPattern != null && pattern.getPrevious() == null__		};checks,if,the,given,pattern,is,the,head,pattern,of,the,current,group,pattern,param,pattern,the,pattern,to,be,checked,return,code,true,iff,the,given,pattern,is,in,a,group,pattern,and,it,is,the,head,pattern,of,the,group,pattern,code,false,otherwise;private,boolean,head,of,group,pattern,t,pattern,return,current,group,pattern,null,pattern,get,previous,null
NFACompiler -> NFAFactoryCompiler -> private boolean headOfGroup(Pattern<T, ?> pattern);1501592283;Checks if the given pattern is the head pattern of the current group pattern.__@param pattern the pattern to be checked_@return {@code true} iff the given pattern is in a group pattern and it is the head pattern of the_group pattern, {@code false} otherwise;private boolean headOfGroup(Pattern<T, ?> pattern) {_			return currentGroupPattern != null && pattern.getPrevious() == null__		};checks,if,the,given,pattern,is,the,head,pattern,of,the,current,group,pattern,param,pattern,the,pattern,to,be,checked,return,code,true,iff,the,given,pattern,is,in,a,group,pattern,and,it,is,the,head,pattern,of,the,group,pattern,code,false,otherwise;private,boolean,head,of,group,pattern,t,pattern,return,current,group,pattern,null,pattern,get,previous,null
NFACompiler -> NFAFactoryCompiler -> private boolean headOfGroup(Pattern<T, ?> pattern);1502422141;Checks if the given pattern is the head pattern of the current group pattern.__@param pattern the pattern to be checked_@return {@code true} iff the given pattern is in a group pattern and it is the head pattern of the_group pattern, {@code false} otherwise;private boolean headOfGroup(Pattern<T, ?> pattern) {_			return currentGroupPattern != null && pattern.getPrevious() == null__		};checks,if,the,given,pattern,is,the,head,pattern,of,the,current,group,pattern,param,pattern,the,pattern,to,be,checked,return,code,true,iff,the,given,pattern,is,in,a,group,pattern,and,it,is,the,head,pattern,of,the,group,pattern,code,false,otherwise;private,boolean,head,of,group,pattern,t,pattern,return,current,group,pattern,null,pattern,get,previous,null
NFACompiler -> NFAFactoryCompiler -> private boolean headOfGroup(Pattern<T, ?> pattern);1503588494;Checks if the given pattern is the head pattern of the current group pattern.__@param pattern the pattern to be checked_@return {@code true} iff the given pattern is in a group pattern and it is the head pattern of the_group pattern, {@code false} otherwise;private boolean headOfGroup(Pattern<T, ?> pattern) {_			return currentGroupPattern != null && pattern.getPrevious() == null__		};checks,if,the,given,pattern,is,the,head,pattern,of,the,current,group,pattern,param,pattern,the,pattern,to,be,checked,return,code,true,iff,the,given,pattern,is,in,a,group,pattern,and,it,is,the,head,pattern,of,the,group,pattern,code,false,otherwise;private,boolean,head,of,group,pattern,t,pattern,return,current,group,pattern,null,pattern,get,previous,null
NFACompiler -> NFAFactoryCompiler -> private boolean headOfGroup(Pattern<T, ?> pattern);1518008111;Checks if the given pattern is the head pattern of the current group pattern.__@param pattern the pattern to be checked_@return {@code true} iff the given pattern is in a group pattern and it is the head pattern of the_group pattern, {@code false} otherwise;private boolean headOfGroup(Pattern<T, ?> pattern) {_			return currentGroupPattern != null && pattern.getPrevious() == null__		};checks,if,the,given,pattern,is,the,head,pattern,of,the,current,group,pattern,param,pattern,the,pattern,to,be,checked,return,code,true,iff,the,given,pattern,is,in,a,group,pattern,and,it,is,the,head,pattern,of,the,group,pattern,code,false,otherwise;private,boolean,head,of,group,pattern,t,pattern,return,current,group,pattern,null,pattern,get,previous,null
NFACompiler -> NFAFactoryCompiler -> private boolean headOfGroup(Pattern<T, ?> pattern);1527863170;Checks if the given pattern is the head pattern of the current group pattern.__@param pattern the pattern to be checked_@return {@code true} iff the given pattern is in a group pattern and it is the head pattern of the_group pattern, {@code false} otherwise;private boolean headOfGroup(Pattern<T, ?> pattern) {_			return currentGroupPattern != null && pattern.getPrevious() == null__		};checks,if,the,given,pattern,is,the,head,pattern,of,the,current,group,pattern,param,pattern,the,pattern,to,be,checked,return,code,true,iff,the,given,pattern,is,in,a,group,pattern,and,it,is,the,head,pattern,of,the,group,pattern,code,false,otherwise;private,boolean,head,of,group,pattern,t,pattern,return,current,group,pattern,null,pattern,get,previous,null
NFACompiler -> NFAFactoryCompiler -> private boolean headOfGroup(Pattern<T, ?> pattern);1528989005;Checks if the given pattern is the head pattern of the current group pattern.__@param pattern the pattern to be checked_@return {@code true} iff the given pattern is in a group pattern and it is the head pattern of the_group pattern, {@code false} otherwise;private boolean headOfGroup(Pattern<T, ?> pattern) {_			return currentGroupPattern != null && pattern.getPrevious() == null__		};checks,if,the,given,pattern,is,the,head,pattern,of,the,current,group,pattern,param,pattern,the,pattern,to,be,checked,return,code,true,iff,the,given,pattern,is,in,a,group,pattern,and,it,is,the,head,pattern,of,the,group,pattern,code,false,otherwise;private,boolean,head,of,group,pattern,t,pattern,return,current,group,pattern,null,pattern,get,previous,null
NFACompiler -> NFAFactoryCompiler -> private boolean headOfGroup(Pattern<T, ?> pattern);1538745898;Checks if the given pattern is the head pattern of the current group pattern.__@param pattern the pattern to be checked_@return {@code true} iff the given pattern is in a group pattern and it is the head pattern of the_group pattern, {@code false} otherwise;private boolean headOfGroup(Pattern<T, ?> pattern) {_			return currentGroupPattern != null && pattern.getPrevious() == null__		};checks,if,the,given,pattern,is,the,head,pattern,of,the,current,group,pattern,param,pattern,the,pattern,to,be,checked,return,code,true,iff,the,given,pattern,is,in,a,group,pattern,and,it,is,the,head,pattern,of,the,group,pattern,code,false,otherwise;private,boolean,head,of,group,pattern,t,pattern,return,current,group,pattern,null,pattern,get,previous,null
NFACompiler -> NFAFactoryCompiler -> private boolean headOfGroup(Pattern<T, ?> pattern);1542293931;Checks if the given pattern is the head pattern of the current group pattern.__@param pattern the pattern to be checked_@return {@code true} iff the given pattern is in a group pattern and it is the head pattern of the_group pattern, {@code false} otherwise;private boolean headOfGroup(Pattern<T, ?> pattern) {_			return currentGroupPattern != null && pattern.getPrevious() == null__		};checks,if,the,given,pattern,is,the,head,pattern,of,the,current,group,pattern,param,pattern,the,pattern,to,be,checked,return,code,true,iff,the,given,pattern,is,in,a,group,pattern,and,it,is,the,head,pattern,of,the,group,pattern,code,false,otherwise;private,boolean,head,of,group,pattern,t,pattern,return,current,group,pattern,null,pattern,get,previous,null
NFACompiler -> NFAFactoryCompiler -> @SuppressWarnings("unchecked") 		private State<T> createLooping(final State<T> sinkState);1490619911;Creates the given state as a looping one. Looping state is one with TAKE edge to itself and_PROCEED edge to the sinkState. It also consists of a similar state without the PROCEED edge, so that_for each PROCEED transition branches in computation state graph  can be created only once.__@param sinkState the state that the converted state should point to_@return the first state of the created complex state;@SuppressWarnings("unchecked")_		private State<T> createLooping(final State<T> sinkState) {__			final State<T> loopingState = createNormalState()__			final IterativeCondition<T> filterFunction = (IterativeCondition<T>) currentPattern.getCondition()__			final IterativeCondition<T> trueFunction = BooleanConditions.trueFunction()___			loopingState.addProceed(sinkState, trueFunction)__			loopingState.addTake(filterFunction)__			if (!currentPattern.getQuantifier().hasProperty(QuantifierProperty.STRICT)) {_				final State<T> ignoreState = createNormalState()___				final IterativeCondition<T> ignoreCondition = getIgnoreCondition(currentPattern)___				ignoreState.addTake(loopingState, filterFunction)__				ignoreState.addIgnore(ignoreCondition)__				loopingState.addIgnore(ignoreState, ignoreCondition)__			}__			return loopingState__		};creates,the,given,state,as,a,looping,one,looping,state,is,one,with,take,edge,to,itself,and,proceed,edge,to,the,sink,state,it,also,consists,of,a,similar,state,without,the,proceed,edge,so,that,for,each,proceed,transition,branches,in,computation,state,graph,can,be,created,only,once,param,sink,state,the,state,that,the,converted,state,should,point,to,return,the,first,state,of,the,created,complex,state;suppress,warnings,unchecked,private,state,t,create,looping,final,state,t,sink,state,final,state,t,looping,state,create,normal,state,final,iterative,condition,t,filter,function,iterative,condition,t,current,pattern,get,condition,final,iterative,condition,t,true,function,boolean,conditions,true,function,looping,state,add,proceed,sink,state,true,function,looping,state,add,take,filter,function,if,current,pattern,get,quantifier,has,property,quantifier,property,strict,final,state,t,ignore,state,create,normal,state,final,iterative,condition,t,ignore,condition,get,ignore,condition,current,pattern,ignore,state,add,take,looping,state,filter,function,ignore,state,add,ignore,ignore,condition,looping,state,add,ignore,ignore,state,ignore,condition,return,looping,state
NFACompiler -> NFAFactoryCompiler -> @SuppressWarnings("unchecked") 		private State<T> createLooping(final State<T> sinkState);1491320734;Creates the given state as a looping one. Looping state is one with TAKE edge to itself and_PROCEED edge to the sinkState. It also consists of a similar state without the PROCEED edge, so that_for each PROCEED transition branches in computation state graph  can be created only once.__@param sinkState the state that the converted state should point to_@return the first state of the created complex state;@SuppressWarnings("unchecked")_		private State<T> createLooping(final State<T> sinkState) {__			final State<T> loopingState = createNormalState()__			final IterativeCondition<T> filterFunction = (IterativeCondition<T>) currentPattern.getCondition()__			final IterativeCondition<T> trueFunction = BooleanConditions.trueFunction()___			loopingState.addProceed(sinkState, trueFunction)__			loopingState.addTake(filterFunction)__			if (!currentPattern.getQuantifier().hasProperty(QuantifierProperty.CONSECUTIVE)) {_				final State<T> ignoreState = createNormalState()___				final IterativeCondition<T> ignoreCondition = getIgnoreCondition(currentPattern)___				ignoreState.addTake(loopingState, filterFunction)__				ignoreState.addIgnore(ignoreCondition)__				loopingState.addIgnore(ignoreState, ignoreCondition)__			}__			return loopingState__		};creates,the,given,state,as,a,looping,one,looping,state,is,one,with,take,edge,to,itself,and,proceed,edge,to,the,sink,state,it,also,consists,of,a,similar,state,without,the,proceed,edge,so,that,for,each,proceed,transition,branches,in,computation,state,graph,can,be,created,only,once,param,sink,state,the,state,that,the,converted,state,should,point,to,return,the,first,state,of,the,created,complex,state;suppress,warnings,unchecked,private,state,t,create,looping,final,state,t,sink,state,final,state,t,looping,state,create,normal,state,final,iterative,condition,t,filter,function,iterative,condition,t,current,pattern,get,condition,final,iterative,condition,t,true,function,boolean,conditions,true,function,looping,state,add,proceed,sink,state,true,function,looping,state,add,take,filter,function,if,current,pattern,get,quantifier,has,property,quantifier,property,consecutive,final,state,t,ignore,state,create,normal,state,final,iterative,condition,t,ignore,condition,get,ignore,condition,current,pattern,ignore,state,add,take,looping,state,filter,function,ignore,state,add,ignore,ignore,condition,looping,state,add,ignore,ignore,state,ignore,condition,return,looping,state
NFACompiler -> NFAFactoryCompiler -> @SuppressWarnings("unchecked") 		private State<T> createLooping(final State<T> sinkState);1491323030;Creates the given state as a looping one. Looping state is one with TAKE edge to itself and_PROCEED edge to the sinkState. It also consists of a similar state without the PROCEED edge, so that_for each PROCEED transition branches in computation state graph  can be created only once.__@param sinkState the state that the converted state should point to_@return the first state of the created complex state;@SuppressWarnings("unchecked")_		private State<T> createLooping(final State<T> sinkState) {__			final State<T> loopingState = createNormalState()__			final IterativeCondition<T> filterFunction = (IterativeCondition<T>) currentPattern.getCondition()__			final IterativeCondition<T> trueFunction = BooleanConditions.trueFunction()___			loopingState.addProceed(sinkState, trueFunction)__			loopingState.addTake(filterFunction)__			if (!currentPattern.getQuantifier().hasProperty(QuantifierProperty.STRICT)) {_				final State<T> ignoreState = createNormalState()___				final IterativeCondition<T> ignoreCondition = getIgnoreCondition(currentPattern)___				ignoreState.addTake(loopingState, filterFunction)__				ignoreState.addIgnore(ignoreCondition)__				loopingState.addIgnore(ignoreState, ignoreCondition)__			}__			return loopingState__		};creates,the,given,state,as,a,looping,one,looping,state,is,one,with,take,edge,to,itself,and,proceed,edge,to,the,sink,state,it,also,consists,of,a,similar,state,without,the,proceed,edge,so,that,for,each,proceed,transition,branches,in,computation,state,graph,can,be,created,only,once,param,sink,state,the,state,that,the,converted,state,should,point,to,return,the,first,state,of,the,created,complex,state;suppress,warnings,unchecked,private,state,t,create,looping,final,state,t,sink,state,final,state,t,looping,state,create,normal,state,final,iterative,condition,t,filter,function,iterative,condition,t,current,pattern,get,condition,final,iterative,condition,t,true,function,boolean,conditions,true,function,looping,state,add,proceed,sink,state,true,function,looping,state,add,take,filter,function,if,current,pattern,get,quantifier,has,property,quantifier,property,strict,final,state,t,ignore,state,create,normal,state,final,iterative,condition,t,ignore,condition,get,ignore,condition,current,pattern,ignore,state,add,take,looping,state,filter,function,ignore,state,add,ignore,ignore,condition,looping,state,add,ignore,ignore,state,ignore,condition,return,looping,state
NFACompiler -> NFAFactoryCompiler -> @SuppressWarnings("unchecked") 		private State<T> createLooping(final State<T> sinkState);1491633862;Creates the given state as a looping one. Looping state is one with TAKE edge to itself and_PROCEED edge to the sinkState. It also consists of a similar state without the PROCEED edge, so that_for each PROCEED transition branches in computation state graph  can be created only once.__@param sinkState the state that the converted state should point to_@return the first state of the created complex state;@SuppressWarnings("unchecked")_		private State<T> createLooping(final State<T> sinkState) {__			final State<T> loopingState = createNormalState()__			final IterativeCondition<T> filterFunction = (IterativeCondition<T>) currentPattern.getCondition()__			final IterativeCondition<T> trueFunction = BooleanConditions.trueFunction()___			loopingState.addProceed(sinkState, trueFunction)__			loopingState.addTake(filterFunction)__			if (!currentPattern.getQuantifier().hasProperty(QuantifierProperty.STRICT)) {_				final State<T> ignoreState = createNormalState()___				final IterativeCondition<T> ignoreCondition = getIgnoreCondition(currentPattern)___				ignoreState.addTake(loopingState, filterFunction)__				ignoreState.addIgnore(ignoreCondition)__				loopingState.addIgnore(ignoreState, ignoreCondition)__			}__			return loopingState__		};creates,the,given,state,as,a,looping,one,looping,state,is,one,with,take,edge,to,itself,and,proceed,edge,to,the,sink,state,it,also,consists,of,a,similar,state,without,the,proceed,edge,so,that,for,each,proceed,transition,branches,in,computation,state,graph,can,be,created,only,once,param,sink,state,the,state,that,the,converted,state,should,point,to,return,the,first,state,of,the,created,complex,state;suppress,warnings,unchecked,private,state,t,create,looping,final,state,t,sink,state,final,state,t,looping,state,create,normal,state,final,iterative,condition,t,filter,function,iterative,condition,t,current,pattern,get,condition,final,iterative,condition,t,true,function,boolean,conditions,true,function,looping,state,add,proceed,sink,state,true,function,looping,state,add,take,filter,function,if,current,pattern,get,quantifier,has,property,quantifier,property,strict,final,state,t,ignore,state,create,normal,state,final,iterative,condition,t,ignore,condition,get,ignore,condition,current,pattern,ignore,state,add,take,looping,state,filter,function,ignore,state,add,ignore,ignore,condition,looping,state,add,ignore,ignore,state,ignore,condition,return,looping,state
NFACompiler -> NFAFactoryCompiler -> @SuppressWarnings("unchecked") 		private State<T> createLooping(final State<T> sinkState);1492797583;Creates the given state as a looping one. Looping state is one with TAKE edge to itself and_PROCEED edge to the sinkState. It also consists of a similar state without the PROCEED edge, so that_for each PROCEED transition branches in computation state graph  can be created only once.__@param sinkState the state that the converted state should point to_@return the first state of the created complex state;@SuppressWarnings("unchecked")_		private State<T> createLooping(final State<T> sinkState) {__			final State<T> loopingState = createNormalState()__			final IterativeCondition<T> filterFunction = (IterativeCondition<T>) currentPattern.getCondition()__			final IterativeCondition<T> trueFunction = BooleanConditions.trueFunction()___			loopingState.addProceed(sinkState, trueFunction)__			loopingState.addTake(filterFunction)__			if (!currentPattern.getQuantifier().hasProperty(QuantifierProperty.CONSECUTIVE)) {_				final State<T> ignoreState = createNormalState()___				final IterativeCondition<T> ignoreCondition = getIgnoreCondition(currentPattern)___				ignoreState.addTake(loopingState, filterFunction)__				ignoreState.addIgnore(ignoreCondition)__				loopingState.addIgnore(ignoreState, ignoreCondition)__			}__			return loopingState__		};creates,the,given,state,as,a,looping,one,looping,state,is,one,with,take,edge,to,itself,and,proceed,edge,to,the,sink,state,it,also,consists,of,a,similar,state,without,the,proceed,edge,so,that,for,each,proceed,transition,branches,in,computation,state,graph,can,be,created,only,once,param,sink,state,the,state,that,the,converted,state,should,point,to,return,the,first,state,of,the,created,complex,state;suppress,warnings,unchecked,private,state,t,create,looping,final,state,t,sink,state,final,state,t,looping,state,create,normal,state,final,iterative,condition,t,filter,function,iterative,condition,t,current,pattern,get,condition,final,iterative,condition,t,true,function,boolean,conditions,true,function,looping,state,add,proceed,sink,state,true,function,looping,state,add,take,filter,function,if,current,pattern,get,quantifier,has,property,quantifier,property,consecutive,final,state,t,ignore,state,create,normal,state,final,iterative,condition,t,ignore,condition,get,ignore,condition,current,pattern,ignore,state,add,take,looping,state,filter,function,ignore,state,add,ignore,ignore,condition,looping,state,add,ignore,ignore,state,ignore,condition,return,looping,state
NFACompiler -> NFAFactoryCompiler -> @SuppressWarnings("unchecked") 		private State<T> createLooping(final State<T> sinkState);1493200673;Creates the given state as a looping one. Looping state is one with TAKE edge to itself and_PROCEED edge to the sinkState. It also consists of a similar state without the PROCEED edge, so that_for each PROCEED transition branches in computation state graph  can be created only once.__@param sinkState the state that the converted state should point to_@return the first state of the created complex state;@SuppressWarnings("unchecked")_		private State<T> createLooping(final State<T> sinkState) {_			final IterativeCondition<T> filterFunction = (IterativeCondition<T>) currentPattern.getCondition()__			final IterativeCondition<T> ignoreCondition = getInnerIgnoreCondition(currentPattern)__			final IterativeCondition<T> trueFunction = BooleanConditions.trueFunction()___			final State<T> loopingState = createNormalState()__			loopingState.addProceed(sinkState, trueFunction)__			loopingState.addTake(filterFunction)___			if (ignoreCondition != null) {_				final State<T> ignoreState = createNormalState()__				ignoreState.addTake(loopingState, filterFunction)__				ignoreState.addIgnore(ignoreCondition)__				loopingState.addIgnore(ignoreState, ignoreCondition)__			}__			return loopingState__		};creates,the,given,state,as,a,looping,one,looping,state,is,one,with,take,edge,to,itself,and,proceed,edge,to,the,sink,state,it,also,consists,of,a,similar,state,without,the,proceed,edge,so,that,for,each,proceed,transition,branches,in,computation,state,graph,can,be,created,only,once,param,sink,state,the,state,that,the,converted,state,should,point,to,return,the,first,state,of,the,created,complex,state;suppress,warnings,unchecked,private,state,t,create,looping,final,state,t,sink,state,final,iterative,condition,t,filter,function,iterative,condition,t,current,pattern,get,condition,final,iterative,condition,t,ignore,condition,get,inner,ignore,condition,current,pattern,final,iterative,condition,t,true,function,boolean,conditions,true,function,final,state,t,looping,state,create,normal,state,looping,state,add,proceed,sink,state,true,function,looping,state,add,take,filter,function,if,ignore,condition,null,final,state,t,ignore,state,create,normal,state,ignore,state,add,take,looping,state,filter,function,ignore,state,add,ignore,ignore,condition,looping,state,add,ignore,ignore,state,ignore,condition,return,looping,state
NFACompiler -> NFAFactoryCompiler -> @SuppressWarnings("unchecked") 		private State<T> createLooping(final State<T> sinkState);1493385877;Creates the given state as a looping one. Looping state is one with TAKE edge to itself and_PROCEED edge to the sinkState. It also consists of a similar state without the PROCEED edge, so that_for each PROCEED transition branches in computation state graph  can be created only once.__@param sinkState the state that the converted state should point to_@return the first state of the created complex state;@SuppressWarnings("unchecked")_		private State<T> createLooping(final State<T> sinkState) {_			final IterativeCondition<T> currentCondition = (IterativeCondition<T>) currentPattern.getCondition()__			final IterativeCondition<T> ignoreCondition = getInnerIgnoreCondition(currentPattern)__			final IterativeCondition<T> trueFunction = BooleanConditions.trueFunction()___			final State<T> loopingState = createNormalState()__			loopingState.addProceed(sinkState, trueFunction)__			loopingState.addTake(currentCondition)___			addStopStateToLooping(loopingState)___			if (ignoreCondition != null) {_				final State<T> ignoreState = createNormalState()__				ignoreState.addTake(loopingState, currentCondition)__				ignoreState.addIgnore(ignoreCondition)__				loopingState.addIgnore(ignoreState, ignoreCondition)___				addStopStateToLooping(ignoreState)__			}_			return loopingState__		};creates,the,given,state,as,a,looping,one,looping,state,is,one,with,take,edge,to,itself,and,proceed,edge,to,the,sink,state,it,also,consists,of,a,similar,state,without,the,proceed,edge,so,that,for,each,proceed,transition,branches,in,computation,state,graph,can,be,created,only,once,param,sink,state,the,state,that,the,converted,state,should,point,to,return,the,first,state,of,the,created,complex,state;suppress,warnings,unchecked,private,state,t,create,looping,final,state,t,sink,state,final,iterative,condition,t,current,condition,iterative,condition,t,current,pattern,get,condition,final,iterative,condition,t,ignore,condition,get,inner,ignore,condition,current,pattern,final,iterative,condition,t,true,function,boolean,conditions,true,function,final,state,t,looping,state,create,normal,state,looping,state,add,proceed,sink,state,true,function,looping,state,add,take,current,condition,add,stop,state,to,looping,looping,state,if,ignore,condition,null,final,state,t,ignore,state,create,normal,state,ignore,state,add,take,looping,state,current,condition,ignore,state,add,ignore,ignore,condition,looping,state,add,ignore,ignore,state,ignore,condition,add,stop,state,to,looping,ignore,state,return,looping,state
NFACompiler -> NFAFactoryCompiler -> @SuppressWarnings("unchecked") 		private State<T> createLooping(final State<T> sinkState);1494947249;Creates the given state as a looping one. Looping state is one with TAKE edge to itself and_PROCEED edge to the sinkState. It also consists of a similar state without the PROCEED edge, so that_for each PROCEED transition branches in computation state graph  can be created only once.__@param sinkState the state that the converted state should point to_@return the first state of the created complex state;@SuppressWarnings("unchecked")_		private State<T> createLooping(final State<T> sinkState) {_			final IterativeCondition<T> currentCondition = (IterativeCondition<T>) currentPattern.getCondition()__			final IterativeCondition<T> ignoreCondition = getInnerIgnoreCondition(currentPattern)__			final IterativeCondition<T> trueFunction = BooleanConditions.trueFunction()___			final State<T> loopingState = createState(currentPattern.getName(), State.StateType.Normal)__			loopingState.addProceed(sinkState, trueFunction)__			loopingState.addTake(currentCondition)___			addStopStateToLooping(loopingState)___			if (ignoreCondition != null) {_				final State<T> ignoreState = createState(currentPattern.getName(), State.StateType.Normal)__				ignoreState.addTake(loopingState, currentCondition)__				ignoreState.addIgnore(ignoreCondition)__				loopingState.addIgnore(ignoreState, ignoreCondition)___				addStopStateToLooping(ignoreState)__			}_			return loopingState__		};creates,the,given,state,as,a,looping,one,looping,state,is,one,with,take,edge,to,itself,and,proceed,edge,to,the,sink,state,it,also,consists,of,a,similar,state,without,the,proceed,edge,so,that,for,each,proceed,transition,branches,in,computation,state,graph,can,be,created,only,once,param,sink,state,the,state,that,the,converted,state,should,point,to,return,the,first,state,of,the,created,complex,state;suppress,warnings,unchecked,private,state,t,create,looping,final,state,t,sink,state,final,iterative,condition,t,current,condition,iterative,condition,t,current,pattern,get,condition,final,iterative,condition,t,ignore,condition,get,inner,ignore,condition,current,pattern,final,iterative,condition,t,true,function,boolean,conditions,true,function,final,state,t,looping,state,create,state,current,pattern,get,name,state,state,type,normal,looping,state,add,proceed,sink,state,true,function,looping,state,add,take,current,condition,add,stop,state,to,looping,looping,state,if,ignore,condition,null,final,state,t,ignore,state,create,state,current,pattern,get,name,state,state,type,normal,ignore,state,add,take,looping,state,current,condition,ignore,state,add,ignore,ignore,condition,looping,state,add,ignore,ignore,state,ignore,condition,add,stop,state,to,looping,ignore,state,return,looping,state
NFACompiler -> NFAFactoryCompiler -> @SuppressWarnings("unchecked") 		private State<T> createLooping(final State<T> sinkState);1495657626;Creates the given state as a looping one. Looping state is one with TAKE edge to itself and_PROCEED edge to the sinkState. It also consists of a similar state without the PROCEED edge, so that_for each PROCEED transition branches in computation state graph  can be created only once.__@param sinkState the state that the converted state should point to_@return the first state of the created complex state;@SuppressWarnings("unchecked")_		private State<T> createLooping(final State<T> sinkState) {_			final IterativeCondition<T> currentCondition = (IterativeCondition<T>) currentPattern.getCondition()__			final IterativeCondition<T> ignoreCondition = getInnerIgnoreCondition(currentPattern)__			final IterativeCondition<T> trueFunction = BooleanConditions.trueFunction()___			final State<T> loopingState = createState(currentPattern.getName(), State.StateType.Normal)__			loopingState.addProceed(sinkState, trueFunction)__			loopingState.addTake(currentCondition)___			addStopStateToLooping(loopingState)___			if (ignoreCondition != null) {_				final State<T> ignoreState = createState(currentPattern.getName(), State.StateType.Normal)__				ignoreState.addTake(loopingState, currentCondition)__				ignoreState.addIgnore(ignoreCondition)__				loopingState.addIgnore(ignoreState, ignoreCondition)___				addStopStateToLooping(ignoreState)__			}_			return loopingState__		};creates,the,given,state,as,a,looping,one,looping,state,is,one,with,take,edge,to,itself,and,proceed,edge,to,the,sink,state,it,also,consists,of,a,similar,state,without,the,proceed,edge,so,that,for,each,proceed,transition,branches,in,computation,state,graph,can,be,created,only,once,param,sink,state,the,state,that,the,converted,state,should,point,to,return,the,first,state,of,the,created,complex,state;suppress,warnings,unchecked,private,state,t,create,looping,final,state,t,sink,state,final,iterative,condition,t,current,condition,iterative,condition,t,current,pattern,get,condition,final,iterative,condition,t,ignore,condition,get,inner,ignore,condition,current,pattern,final,iterative,condition,t,true,function,boolean,conditions,true,function,final,state,t,looping,state,create,state,current,pattern,get,name,state,state,type,normal,looping,state,add,proceed,sink,state,true,function,looping,state,add,take,current,condition,add,stop,state,to,looping,looping,state,if,ignore,condition,null,final,state,t,ignore,state,create,state,current,pattern,get,name,state,state,type,normal,ignore,state,add,take,looping,state,current,condition,ignore,state,add,ignore,ignore,condition,looping,state,add,ignore,ignore,state,ignore,condition,add,stop,state,to,looping,ignore,state,return,looping,state
NFACompiler -> NFAFactoryCompiler -> @SuppressWarnings("unchecked") 		private State<T> createLooping(final State<T> sinkState);1496245714;Creates the given state as a looping one. Looping state is one with TAKE edge to itself and_PROCEED edge to the sinkState. It also consists of a similar state without the PROCEED edge, so that_for each PROCEED transition branches in computation state graph  can be created only once.__@param sinkState the state that the converted state should point to_@return the first state of the created complex state;@SuppressWarnings("unchecked")_		private State<T> createLooping(final State<T> sinkState) {_			final IterativeCondition<T> currentCondition = (IterativeCondition<T>) currentPattern.getCondition()__			final IterativeCondition<T> ignoreCondition = getInnerIgnoreCondition(currentPattern)__			final IterativeCondition<T> trueFunction = BooleanConditions.trueFunction()___			final State<T> loopingState = createState(currentPattern.getName(), State.StateType.Normal)__			loopingState.addProceed(sinkState, trueFunction)__			loopingState.addTake(currentCondition)___			addStopStateToLooping(loopingState)___			if (ignoreCondition != null) {_				final State<T> ignoreState = createState(currentPattern.getName(), State.StateType.Normal)__				ignoreState.addTake(loopingState, currentCondition)__				ignoreState.addIgnore(ignoreCondition)__				loopingState.addIgnore(ignoreState, ignoreCondition)___				addStopStateToLooping(ignoreState)__			}_			return loopingState__		};creates,the,given,state,as,a,looping,one,looping,state,is,one,with,take,edge,to,itself,and,proceed,edge,to,the,sink,state,it,also,consists,of,a,similar,state,without,the,proceed,edge,so,that,for,each,proceed,transition,branches,in,computation,state,graph,can,be,created,only,once,param,sink,state,the,state,that,the,converted,state,should,point,to,return,the,first,state,of,the,created,complex,state;suppress,warnings,unchecked,private,state,t,create,looping,final,state,t,sink,state,final,iterative,condition,t,current,condition,iterative,condition,t,current,pattern,get,condition,final,iterative,condition,t,ignore,condition,get,inner,ignore,condition,current,pattern,final,iterative,condition,t,true,function,boolean,conditions,true,function,final,state,t,looping,state,create,state,current,pattern,get,name,state,state,type,normal,looping,state,add,proceed,sink,state,true,function,looping,state,add,take,current,condition,add,stop,state,to,looping,looping,state,if,ignore,condition,null,final,state,t,ignore,state,create,state,current,pattern,get,name,state,state,type,normal,ignore,state,add,take,looping,state,current,condition,ignore,state,add,ignore,ignore,condition,looping,state,add,ignore,ignore,state,ignore,condition,add,stop,state,to,looping,ignore,state,return,looping,state
NFACompiler -> NFAFactoryCompiler -> @SuppressWarnings("unchecked") 		private State<T> createLooping(final State<T> sinkState);1497410381;Creates the given state as a looping one. Looping state is one with TAKE edge to itself and_PROCEED edge to the sinkState. It also consists of a similar state without the PROCEED edge, so that_for each PROCEED transition branches in computation state graph  can be created only once.__@param sinkState the state that the converted state should point to_@return the first state of the created complex state;@SuppressWarnings("unchecked")_		private State<T> createLooping(final State<T> sinkState) {_			final IterativeCondition<T> currentCondition = (IterativeCondition<T>) currentPattern.getCondition()__			final IterativeCondition<T> ignoreCondition = getInnerIgnoreCondition(currentPattern)__			final IterativeCondition<T> trueFunction = BooleanConditions.trueFunction()___			final State<T> loopingState = createState(currentPattern.getName(), State.StateType.Normal)__			loopingState.addProceed(sinkState, trueFunction)__			loopingState.addTake(currentCondition)___			addStopStateToLooping(loopingState)___			if (ignoreCondition != null) {_				final State<T> ignoreState = createState(currentPattern.getName(), State.StateType.Normal)__				ignoreState.addTake(loopingState, currentCondition)__				ignoreState.addIgnore(ignoreCondition)__				loopingState.addIgnore(ignoreState, ignoreCondition)___				addStopStateToLooping(ignoreState)__			}_			return loopingState__		};creates,the,given,state,as,a,looping,one,looping,state,is,one,with,take,edge,to,itself,and,proceed,edge,to,the,sink,state,it,also,consists,of,a,similar,state,without,the,proceed,edge,so,that,for,each,proceed,transition,branches,in,computation,state,graph,can,be,created,only,once,param,sink,state,the,state,that,the,converted,state,should,point,to,return,the,first,state,of,the,created,complex,state;suppress,warnings,unchecked,private,state,t,create,looping,final,state,t,sink,state,final,iterative,condition,t,current,condition,iterative,condition,t,current,pattern,get,condition,final,iterative,condition,t,ignore,condition,get,inner,ignore,condition,current,pattern,final,iterative,condition,t,true,function,boolean,conditions,true,function,final,state,t,looping,state,create,state,current,pattern,get,name,state,state,type,normal,looping,state,add,proceed,sink,state,true,function,looping,state,add,take,current,condition,add,stop,state,to,looping,looping,state,if,ignore,condition,null,final,state,t,ignore,state,create,state,current,pattern,get,name,state,state,type,normal,ignore,state,add,take,looping,state,current,condition,ignore,state,add,ignore,ignore,condition,looping,state,add,ignore,ignore,state,ignore,condition,add,stop,state,to,looping,ignore,state,return,looping,state
NFACompiler -> NFAFactoryCompiler -> @SuppressWarnings("unchecked") 		private State<T> createLooping(final State<T> sinkState);1497883202;Creates the given state as a looping one. Looping state is one with TAKE edge to itself and_PROCEED edge to the sinkState. It also consists of a similar state without the PROCEED edge, so that_for each PROCEED transition branches in computation state graph  can be created only once.__@param sinkState the state that the converted state should point to_@return the first state of the created complex state;@SuppressWarnings("unchecked")_		private State<T> createLooping(final State<T> sinkState) {_			final IterativeCondition<T> untilCondition = (IterativeCondition<T>) currentPattern.getUntilCondition()___			final IterativeCondition<T> ignoreCondition = extendWithUntilCondition(_				getInnerIgnoreCondition(currentPattern),_				untilCondition)__			final IterativeCondition<T> takeCondition = extendWithUntilCondition(_				(IterativeCondition<T>) currentPattern.getCondition(),_				untilCondition)___			final IterativeCondition<T> proceedCondition = BooleanConditions.trueFunction()__			final State<T> loopingState = createState(currentPattern.getName(), State.StateType.Normal)__			loopingState.addProceed(sinkState, proceedCondition)__			loopingState.addTake(takeCondition)___			addStopStateToLooping(loopingState)___			if (ignoreCondition != null) {_				final State<T> ignoreState = createState(currentPattern.getName(), State.StateType.Normal)__				ignoreState.addTake(loopingState, takeCondition)__				ignoreState.addIgnore(ignoreCondition)__				loopingState.addIgnore(ignoreState, ignoreCondition)___				addStopStateToLooping(ignoreState)__			}_			return loopingState__		};creates,the,given,state,as,a,looping,one,looping,state,is,one,with,take,edge,to,itself,and,proceed,edge,to,the,sink,state,it,also,consists,of,a,similar,state,without,the,proceed,edge,so,that,for,each,proceed,transition,branches,in,computation,state,graph,can,be,created,only,once,param,sink,state,the,state,that,the,converted,state,should,point,to,return,the,first,state,of,the,created,complex,state;suppress,warnings,unchecked,private,state,t,create,looping,final,state,t,sink,state,final,iterative,condition,t,until,condition,iterative,condition,t,current,pattern,get,until,condition,final,iterative,condition,t,ignore,condition,extend,with,until,condition,get,inner,ignore,condition,current,pattern,until,condition,final,iterative,condition,t,take,condition,extend,with,until,condition,iterative,condition,t,current,pattern,get,condition,until,condition,final,iterative,condition,t,proceed,condition,boolean,conditions,true,function,final,state,t,looping,state,create,state,current,pattern,get,name,state,state,type,normal,looping,state,add,proceed,sink,state,proceed,condition,looping,state,add,take,take,condition,add,stop,state,to,looping,looping,state,if,ignore,condition,null,final,state,t,ignore,state,create,state,current,pattern,get,name,state,state,type,normal,ignore,state,add,take,looping,state,take,condition,ignore,state,add,ignore,ignore,condition,looping,state,add,ignore,ignore,state,ignore,condition,add,stop,state,to,looping,ignore,state,return,looping,state
NFACompiler -> NFAFactoryCompiler -> @SuppressWarnings("unchecked") 		private State<T> createLooping(final State<T> sinkState);1498034481;Creates the given state as a looping one. Looping state is one with TAKE edge to itself and_PROCEED edge to the sinkState. It also consists of a similar state without the PROCEED edge, so that_for each PROCEED transition branches in computation state graph  can be created only once.__@param sinkState the state that the converted state should point to_@return the first state of the created complex state;@SuppressWarnings("unchecked")_		private State<T> createLooping(final State<T> sinkState) {_			if (currentPattern instanceof GroupPattern) {_				return createLoopingGroupPatternState((GroupPattern) currentPattern, sinkState)__			}_			final IterativeCondition<T> untilCondition = (IterativeCondition<T>) currentPattern.getUntilCondition()___			final IterativeCondition<T> ignoreCondition = extendWithUntilCondition(_				getInnerIgnoreCondition(currentPattern),_				untilCondition)__			final IterativeCondition<T> takeCondition = extendWithUntilCondition(_				getTakeCondition(currentPattern),_				untilCondition)___			final IterativeCondition<T> proceedCondition = getTrueFunction()__			final State<T> loopingState = createState(currentPattern.getName(), State.StateType.Normal)__			loopingState.addProceed(sinkState, proceedCondition)__			loopingState.addTake(takeCondition)___			addStopStateToLooping(loopingState)___			if (ignoreCondition != null) {_				final State<T> ignoreState = createState(currentPattern.getName(), State.StateType.Normal)__				ignoreState.addTake(loopingState, takeCondition)__				ignoreState.addIgnore(ignoreCondition)__				loopingState.addIgnore(ignoreState, ignoreCondition)___				addStopStateToLooping(ignoreState)__			}_			return loopingState__		};creates,the,given,state,as,a,looping,one,looping,state,is,one,with,take,edge,to,itself,and,proceed,edge,to,the,sink,state,it,also,consists,of,a,similar,state,without,the,proceed,edge,so,that,for,each,proceed,transition,branches,in,computation,state,graph,can,be,created,only,once,param,sink,state,the,state,that,the,converted,state,should,point,to,return,the,first,state,of,the,created,complex,state;suppress,warnings,unchecked,private,state,t,create,looping,final,state,t,sink,state,if,current,pattern,instanceof,group,pattern,return,create,looping,group,pattern,state,group,pattern,current,pattern,sink,state,final,iterative,condition,t,until,condition,iterative,condition,t,current,pattern,get,until,condition,final,iterative,condition,t,ignore,condition,extend,with,until,condition,get,inner,ignore,condition,current,pattern,until,condition,final,iterative,condition,t,take,condition,extend,with,until,condition,get,take,condition,current,pattern,until,condition,final,iterative,condition,t,proceed,condition,get,true,function,final,state,t,looping,state,create,state,current,pattern,get,name,state,state,type,normal,looping,state,add,proceed,sink,state,proceed,condition,looping,state,add,take,take,condition,add,stop,state,to,looping,looping,state,if,ignore,condition,null,final,state,t,ignore,state,create,state,current,pattern,get,name,state,state,type,normal,ignore,state,add,take,looping,state,take,condition,ignore,state,add,ignore,ignore,condition,looping,state,add,ignore,ignore,state,ignore,condition,add,stop,state,to,looping,ignore,state,return,looping,state
NFACompiler -> NFAFactoryCompiler -> @SuppressWarnings("unchecked") 		private State<T> createLooping(final State<T> sinkState);1499760222;Creates the given state as a looping one. Looping state is one with TAKE edge to itself and_PROCEED edge to the sinkState. It also consists of a similar state without the PROCEED edge, so that_for each PROCEED transition branches in computation state graph  can be created only once.__@param sinkState the state that the converted state should point to_@return the first state of the created complex state;@SuppressWarnings("unchecked")_		private State<T> createLooping(final State<T> sinkState) {_			if (currentPattern instanceof GroupPattern) {_				return createLoopingGroupPatternState((GroupPattern) currentPattern, sinkState)__			}_			final IterativeCondition<T> untilCondition = (IterativeCondition<T>) currentPattern.getUntilCondition()___			final IterativeCondition<T> ignoreCondition = extendWithUntilCondition(_				getInnerIgnoreCondition(currentPattern),_				untilCondition,_				false)__			final IterativeCondition<T> takeCondition = extendWithUntilCondition(_				getTakeCondition(currentPattern),_				untilCondition,_				true)___			IterativeCondition<T> proceedCondition = getTrueFunction()__			final State<T> loopingState = createState(currentPattern.getName(), State.StateType.Normal)___			if (currentPattern.getQuantifier().hasProperty(Quantifier.QuantifierProperty.GREEDY)) {_				if (untilCondition != null) {_					State<T> sinkStateCopy = copy(sinkState)__					loopingState.addProceed(sinkStateCopy, new AndCondition<>(proceedCondition, untilCondition))__					originalStateMap.put(sinkState.getName(), sinkStateCopy)__				}_				loopingState.addProceed(sinkState,_					untilCondition != null_						? new AndCondition<>(proceedCondition, new NotCondition<>(untilCondition))_						: proceedCondition)__				updateWithGreedyCondition(sinkState, getTakeCondition(currentPattern))__			} else {_				loopingState.addProceed(sinkState, proceedCondition)__			}_			loopingState.addTake(takeCondition)___			addStopStateToLooping(loopingState)___			if (ignoreCondition != null) {_				final State<T> ignoreState = createState(currentPattern.getName(), State.StateType.Normal)__				ignoreState.addTake(loopingState, takeCondition)__				ignoreState.addIgnore(ignoreCondition)__				loopingState.addIgnore(ignoreState, ignoreCondition)___				addStopStateToLooping(ignoreState)__			}_			return loopingState__		};creates,the,given,state,as,a,looping,one,looping,state,is,one,with,take,edge,to,itself,and,proceed,edge,to,the,sink,state,it,also,consists,of,a,similar,state,without,the,proceed,edge,so,that,for,each,proceed,transition,branches,in,computation,state,graph,can,be,created,only,once,param,sink,state,the,state,that,the,converted,state,should,point,to,return,the,first,state,of,the,created,complex,state;suppress,warnings,unchecked,private,state,t,create,looping,final,state,t,sink,state,if,current,pattern,instanceof,group,pattern,return,create,looping,group,pattern,state,group,pattern,current,pattern,sink,state,final,iterative,condition,t,until,condition,iterative,condition,t,current,pattern,get,until,condition,final,iterative,condition,t,ignore,condition,extend,with,until,condition,get,inner,ignore,condition,current,pattern,until,condition,false,final,iterative,condition,t,take,condition,extend,with,until,condition,get,take,condition,current,pattern,until,condition,true,iterative,condition,t,proceed,condition,get,true,function,final,state,t,looping,state,create,state,current,pattern,get,name,state,state,type,normal,if,current,pattern,get,quantifier,has,property,quantifier,quantifier,property,greedy,if,until,condition,null,state,t,sink,state,copy,copy,sink,state,looping,state,add,proceed,sink,state,copy,new,and,condition,proceed,condition,until,condition,original,state,map,put,sink,state,get,name,sink,state,copy,looping,state,add,proceed,sink,state,until,condition,null,new,and,condition,proceed,condition,new,not,condition,until,condition,proceed,condition,update,with,greedy,condition,sink,state,get,take,condition,current,pattern,else,looping,state,add,proceed,sink,state,proceed,condition,looping,state,add,take,take,condition,add,stop,state,to,looping,looping,state,if,ignore,condition,null,final,state,t,ignore,state,create,state,current,pattern,get,name,state,state,type,normal,ignore,state,add,take,looping,state,take,condition,ignore,state,add,ignore,ignore,condition,looping,state,add,ignore,ignore,state,ignore,condition,add,stop,state,to,looping,ignore,state,return,looping,state
NFACompiler -> NFAFactoryCompiler -> @SuppressWarnings("unchecked") 		private State<T> createLooping(final State<T> sinkState);1499937690;Creates the given state as a looping one. Looping state is one with TAKE edge to itself and_PROCEED edge to the sinkState. It also consists of a similar state without the PROCEED edge, so that_for each PROCEED transition branches in computation state graph  can be created only once.__@param sinkState the state that the converted state should point to_@return the first state of the created complex state;@SuppressWarnings("unchecked")_		private State<T> createLooping(final State<T> sinkState) {_			if (currentPattern instanceof GroupPattern) {_				return createLoopingGroupPatternState((GroupPattern) currentPattern, sinkState)__			}_			final IterativeCondition<T> untilCondition = (IterativeCondition<T>) currentPattern.getUntilCondition()___			final IterativeCondition<T> ignoreCondition = extendWithUntilCondition(_				getInnerIgnoreCondition(currentPattern),_				untilCondition,_				false)__			final IterativeCondition<T> takeCondition = extendWithUntilCondition(_				getTakeCondition(currentPattern),_				untilCondition,_				true)___			final IterativeCondition<T> proceedCondition = getTrueFunction()__			final State<T> loopingState = createState(currentPattern.getName(), State.StateType.Normal)__			loopingState.addProceed(sinkState, proceedCondition)__			loopingState.addTake(takeCondition)___			addStopStateToLooping(loopingState)___			if (ignoreCondition != null) {_				final State<T> ignoreState = createState(currentPattern.getName(), State.StateType.Normal)__				ignoreState.addTake(loopingState, takeCondition)__				ignoreState.addIgnore(ignoreCondition)__				loopingState.addIgnore(ignoreState, ignoreCondition)___				addStopStateToLooping(ignoreState)__			}_			return loopingState__		};creates,the,given,state,as,a,looping,one,looping,state,is,one,with,take,edge,to,itself,and,proceed,edge,to,the,sink,state,it,also,consists,of,a,similar,state,without,the,proceed,edge,so,that,for,each,proceed,transition,branches,in,computation,state,graph,can,be,created,only,once,param,sink,state,the,state,that,the,converted,state,should,point,to,return,the,first,state,of,the,created,complex,state;suppress,warnings,unchecked,private,state,t,create,looping,final,state,t,sink,state,if,current,pattern,instanceof,group,pattern,return,create,looping,group,pattern,state,group,pattern,current,pattern,sink,state,final,iterative,condition,t,until,condition,iterative,condition,t,current,pattern,get,until,condition,final,iterative,condition,t,ignore,condition,extend,with,until,condition,get,inner,ignore,condition,current,pattern,until,condition,false,final,iterative,condition,t,take,condition,extend,with,until,condition,get,take,condition,current,pattern,until,condition,true,final,iterative,condition,t,proceed,condition,get,true,function,final,state,t,looping,state,create,state,current,pattern,get,name,state,state,type,normal,looping,state,add,proceed,sink,state,proceed,condition,looping,state,add,take,take,condition,add,stop,state,to,looping,looping,state,if,ignore,condition,null,final,state,t,ignore,state,create,state,current,pattern,get,name,state,state,type,normal,ignore,state,add,take,looping,state,take,condition,ignore,state,add,ignore,ignore,condition,looping,state,add,ignore,ignore,state,ignore,condition,add,stop,state,to,looping,ignore,state,return,looping,state
NFACompiler -> NFAFactoryCompiler -> @SuppressWarnings("unchecked") 		private State<T> createLooping(final State<T> sinkState);1500021711;Creates the given state as a looping one. Looping state is one with TAKE edge to itself and_PROCEED edge to the sinkState. It also consists of a similar state without the PROCEED edge, so that_for each PROCEED transition branches in computation state graph  can be created only once.__@param sinkState the state that the converted state should point to_@return the first state of the created complex state;@SuppressWarnings("unchecked")_		private State<T> createLooping(final State<T> sinkState) {_			if (currentPattern instanceof GroupPattern) {_				return createLoopingGroupPatternState((GroupPattern) currentPattern, sinkState)__			}_			final IterativeCondition<T> untilCondition = (IterativeCondition<T>) currentPattern.getUntilCondition()___			final IterativeCondition<T> ignoreCondition = extendWithUntilCondition(_				getInnerIgnoreCondition(currentPattern),_				untilCondition,_				false)__			final IterativeCondition<T> takeCondition = extendWithUntilCondition(_				getTakeCondition(currentPattern),_				untilCondition,_				true)___			IterativeCondition<T> proceedCondition = getTrueFunction()__			final State<T> loopingState = createState(currentPattern.getName(), State.StateType.Normal)___			if (currentPattern.getQuantifier().hasProperty(Quantifier.QuantifierProperty.GREEDY)) {_				if (untilCondition != null) {_					State<T> sinkStateCopy = copy(sinkState)__					loopingState.addProceed(sinkStateCopy, new AndCondition<>(proceedCondition, untilCondition))__					originalStateMap.put(sinkState.getName(), sinkStateCopy)__				}_				loopingState.addProceed(sinkState,_					untilCondition != null_						? new AndCondition<>(proceedCondition, new NotCondition<>(untilCondition))_						: proceedCondition)__				updateWithGreedyCondition(sinkState, getTakeCondition(currentPattern))__			} else {_				loopingState.addProceed(sinkState, proceedCondition)__			}_			loopingState.addTake(takeCondition)___			addStopStateToLooping(loopingState)___			if (ignoreCondition != null) {_				final State<T> ignoreState = createState(currentPattern.getName(), State.StateType.Normal)__				ignoreState.addTake(loopingState, takeCondition)__				ignoreState.addIgnore(ignoreCondition)__				loopingState.addIgnore(ignoreState, ignoreCondition)___				addStopStateToLooping(ignoreState)__			}_			return loopingState__		};creates,the,given,state,as,a,looping,one,looping,state,is,one,with,take,edge,to,itself,and,proceed,edge,to,the,sink,state,it,also,consists,of,a,similar,state,without,the,proceed,edge,so,that,for,each,proceed,transition,branches,in,computation,state,graph,can,be,created,only,once,param,sink,state,the,state,that,the,converted,state,should,point,to,return,the,first,state,of,the,created,complex,state;suppress,warnings,unchecked,private,state,t,create,looping,final,state,t,sink,state,if,current,pattern,instanceof,group,pattern,return,create,looping,group,pattern,state,group,pattern,current,pattern,sink,state,final,iterative,condition,t,until,condition,iterative,condition,t,current,pattern,get,until,condition,final,iterative,condition,t,ignore,condition,extend,with,until,condition,get,inner,ignore,condition,current,pattern,until,condition,false,final,iterative,condition,t,take,condition,extend,with,until,condition,get,take,condition,current,pattern,until,condition,true,iterative,condition,t,proceed,condition,get,true,function,final,state,t,looping,state,create,state,current,pattern,get,name,state,state,type,normal,if,current,pattern,get,quantifier,has,property,quantifier,quantifier,property,greedy,if,until,condition,null,state,t,sink,state,copy,copy,sink,state,looping,state,add,proceed,sink,state,copy,new,and,condition,proceed,condition,until,condition,original,state,map,put,sink,state,get,name,sink,state,copy,looping,state,add,proceed,sink,state,until,condition,null,new,and,condition,proceed,condition,new,not,condition,until,condition,proceed,condition,update,with,greedy,condition,sink,state,get,take,condition,current,pattern,else,looping,state,add,proceed,sink,state,proceed,condition,looping,state,add,take,take,condition,add,stop,state,to,looping,looping,state,if,ignore,condition,null,final,state,t,ignore,state,create,state,current,pattern,get,name,state,state,type,normal,ignore,state,add,take,looping,state,take,condition,ignore,state,add,ignore,ignore,condition,looping,state,add,ignore,ignore,state,ignore,condition,add,stop,state,to,looping,ignore,state,return,looping,state
NFACompiler -> NFAFactoryCompiler -> @SuppressWarnings("unchecked") 		private State<T> createLooping(final State<T> sinkState);1501592283;Creates the given state as a looping one. Looping state is one with TAKE edge to itself and_PROCEED edge to the sinkState. It also consists of a similar state without the PROCEED edge, so that_for each PROCEED transition branches in computation state graph  can be created only once.__@param sinkState the state that the converted state should point to_@return the first state of the created complex state;@SuppressWarnings("unchecked")_		private State<T> createLooping(final State<T> sinkState) {_			if (currentPattern instanceof GroupPattern) {_				return createLoopingGroupPatternState((GroupPattern) currentPattern, sinkState)__			}_			final IterativeCondition<T> untilCondition = (IterativeCondition<T>) currentPattern.getUntilCondition()___			final IterativeCondition<T> ignoreCondition = extendWithUntilCondition(_				getInnerIgnoreCondition(currentPattern),_				untilCondition,_				false)__			final IterativeCondition<T> takeCondition = extendWithUntilCondition(_				getTakeCondition(currentPattern),_				untilCondition,_				true)___			final IterativeCondition<T> proceedCondition = getTrueFunction()__			final State<T> loopingState = createState(currentPattern.getName(), State.StateType.Normal)__			loopingState.addProceed(sinkState, proceedCondition)__			loopingState.addTake(takeCondition)___			addStopStateToLooping(loopingState)___			if (ignoreCondition != null) {_				final State<T> ignoreState = createState(currentPattern.getName(), State.StateType.Normal)__				ignoreState.addTake(loopingState, takeCondition)__				ignoreState.addIgnore(ignoreCondition)__				loopingState.addIgnore(ignoreState, ignoreCondition)___				addStopStateToLooping(ignoreState)__			}_			return loopingState__		};creates,the,given,state,as,a,looping,one,looping,state,is,one,with,take,edge,to,itself,and,proceed,edge,to,the,sink,state,it,also,consists,of,a,similar,state,without,the,proceed,edge,so,that,for,each,proceed,transition,branches,in,computation,state,graph,can,be,created,only,once,param,sink,state,the,state,that,the,converted,state,should,point,to,return,the,first,state,of,the,created,complex,state;suppress,warnings,unchecked,private,state,t,create,looping,final,state,t,sink,state,if,current,pattern,instanceof,group,pattern,return,create,looping,group,pattern,state,group,pattern,current,pattern,sink,state,final,iterative,condition,t,until,condition,iterative,condition,t,current,pattern,get,until,condition,final,iterative,condition,t,ignore,condition,extend,with,until,condition,get,inner,ignore,condition,current,pattern,until,condition,false,final,iterative,condition,t,take,condition,extend,with,until,condition,get,take,condition,current,pattern,until,condition,true,final,iterative,condition,t,proceed,condition,get,true,function,final,state,t,looping,state,create,state,current,pattern,get,name,state,state,type,normal,looping,state,add,proceed,sink,state,proceed,condition,looping,state,add,take,take,condition,add,stop,state,to,looping,looping,state,if,ignore,condition,null,final,state,t,ignore,state,create,state,current,pattern,get,name,state,state,type,normal,ignore,state,add,take,looping,state,take,condition,ignore,state,add,ignore,ignore,condition,looping,state,add,ignore,ignore,state,ignore,condition,add,stop,state,to,looping,ignore,state,return,looping,state
NFACompiler -> NFAFactoryCompiler -> @SuppressWarnings("unchecked") 		private State<T> createLooping(final State<T> sinkState);1502422141;Creates the given state as a looping one. Looping state is one with TAKE edge to itself and_PROCEED edge to the sinkState. It also consists of a similar state without the PROCEED edge, so that_for each PROCEED transition branches in computation state graph  can be created only once.__@param sinkState the state that the converted state should point to_@return the first state of the created complex state;@SuppressWarnings("unchecked")_		private State<T> createLooping(final State<T> sinkState) {_			if (currentPattern instanceof GroupPattern) {_				return createLoopingGroupPatternState((GroupPattern) currentPattern, sinkState)__			}_			final IterativeCondition<T> untilCondition = (IterativeCondition<T>) currentPattern.getUntilCondition()___			final IterativeCondition<T> ignoreCondition = extendWithUntilCondition(_				getInnerIgnoreCondition(currentPattern),_				untilCondition,_				false)__			final IterativeCondition<T> takeCondition = extendWithUntilCondition(_				getTakeCondition(currentPattern),_				untilCondition,_				true)___			final IterativeCondition<T> proceedCondition = getTrueFunction()__			final State<T> loopingState = createState(currentPattern.getName(), State.StateType.Normal)__			loopingState.addProceed(sinkState, proceedCondition)__			loopingState.addTake(takeCondition)___			addStopStateToLooping(loopingState)___			if (ignoreCondition != null) {_				final State<T> ignoreState = createState(currentPattern.getName(), State.StateType.Normal)__				ignoreState.addTake(loopingState, takeCondition)__				ignoreState.addIgnore(ignoreCondition)__				loopingState.addIgnore(ignoreState, ignoreCondition)___				addStopStateToLooping(ignoreState)__			}_			return loopingState__		};creates,the,given,state,as,a,looping,one,looping,state,is,one,with,take,edge,to,itself,and,proceed,edge,to,the,sink,state,it,also,consists,of,a,similar,state,without,the,proceed,edge,so,that,for,each,proceed,transition,branches,in,computation,state,graph,can,be,created,only,once,param,sink,state,the,state,that,the,converted,state,should,point,to,return,the,first,state,of,the,created,complex,state;suppress,warnings,unchecked,private,state,t,create,looping,final,state,t,sink,state,if,current,pattern,instanceof,group,pattern,return,create,looping,group,pattern,state,group,pattern,current,pattern,sink,state,final,iterative,condition,t,until,condition,iterative,condition,t,current,pattern,get,until,condition,final,iterative,condition,t,ignore,condition,extend,with,until,condition,get,inner,ignore,condition,current,pattern,until,condition,false,final,iterative,condition,t,take,condition,extend,with,until,condition,get,take,condition,current,pattern,until,condition,true,final,iterative,condition,t,proceed,condition,get,true,function,final,state,t,looping,state,create,state,current,pattern,get,name,state,state,type,normal,looping,state,add,proceed,sink,state,proceed,condition,looping,state,add,take,take,condition,add,stop,state,to,looping,looping,state,if,ignore,condition,null,final,state,t,ignore,state,create,state,current,pattern,get,name,state,state,type,normal,ignore,state,add,take,looping,state,take,condition,ignore,state,add,ignore,ignore,condition,looping,state,add,ignore,ignore,state,ignore,condition,add,stop,state,to,looping,ignore,state,return,looping,state
NFACompiler -> NFAFactoryCompiler -> @SuppressWarnings("unchecked") 		private State<T> createLooping(final State<T> sinkState);1503588494;Creates the given state as a looping one. Looping state is one with TAKE edge to itself and_PROCEED edge to the sinkState. It also consists of a similar state without the PROCEED edge, so that_for each PROCEED transition branches in computation state graph  can be created only once.__@param sinkState the state that the converted state should point to_@return the first state of the created complex state;@SuppressWarnings("unchecked")_		private State<T> createLooping(final State<T> sinkState) {_			if (currentPattern instanceof GroupPattern) {_				return createLoopingGroupPatternState((GroupPattern) currentPattern, sinkState)__			}_			final IterativeCondition<T> untilCondition = (IterativeCondition<T>) currentPattern.getUntilCondition()___			final IterativeCondition<T> ignoreCondition = extendWithUntilCondition(_				getInnerIgnoreCondition(currentPattern),_				untilCondition,_				false)__			final IterativeCondition<T> takeCondition = extendWithUntilCondition(_				getTakeCondition(currentPattern),_				untilCondition,_				true)___			IterativeCondition<T> proceedCondition = getTrueFunction()__			final State<T> loopingState = createState(currentPattern.getName(), State.StateType.Normal)___			if (currentPattern.getQuantifier().hasProperty(Quantifier.QuantifierProperty.GREEDY)) {_				if (untilCondition != null) {_					State<T> sinkStateCopy = copy(sinkState)__					loopingState.addProceed(sinkStateCopy, new AndCondition<>(proceedCondition, untilCondition))__					originalStateMap.put(sinkState.getName(), sinkStateCopy)__				}_				loopingState.addProceed(sinkState,_					untilCondition != null_						? new AndCondition<>(proceedCondition, new NotCondition<>(untilCondition))_						: proceedCondition)__				updateWithGreedyCondition(sinkState, getTakeCondition(currentPattern))__			} else {_				loopingState.addProceed(sinkState, proceedCondition)__			}_			loopingState.addTake(takeCondition)___			addStopStateToLooping(loopingState)___			if (ignoreCondition != null) {_				final State<T> ignoreState = createState(currentPattern.getName(), State.StateType.Normal)__				ignoreState.addTake(loopingState, takeCondition)__				ignoreState.addIgnore(ignoreCondition)__				loopingState.addIgnore(ignoreState, ignoreCondition)___				addStopStateToLooping(ignoreState)__			}_			return loopingState__		};creates,the,given,state,as,a,looping,one,looping,state,is,one,with,take,edge,to,itself,and,proceed,edge,to,the,sink,state,it,also,consists,of,a,similar,state,without,the,proceed,edge,so,that,for,each,proceed,transition,branches,in,computation,state,graph,can,be,created,only,once,param,sink,state,the,state,that,the,converted,state,should,point,to,return,the,first,state,of,the,created,complex,state;suppress,warnings,unchecked,private,state,t,create,looping,final,state,t,sink,state,if,current,pattern,instanceof,group,pattern,return,create,looping,group,pattern,state,group,pattern,current,pattern,sink,state,final,iterative,condition,t,until,condition,iterative,condition,t,current,pattern,get,until,condition,final,iterative,condition,t,ignore,condition,extend,with,until,condition,get,inner,ignore,condition,current,pattern,until,condition,false,final,iterative,condition,t,take,condition,extend,with,until,condition,get,take,condition,current,pattern,until,condition,true,iterative,condition,t,proceed,condition,get,true,function,final,state,t,looping,state,create,state,current,pattern,get,name,state,state,type,normal,if,current,pattern,get,quantifier,has,property,quantifier,quantifier,property,greedy,if,until,condition,null,state,t,sink,state,copy,copy,sink,state,looping,state,add,proceed,sink,state,copy,new,and,condition,proceed,condition,until,condition,original,state,map,put,sink,state,get,name,sink,state,copy,looping,state,add,proceed,sink,state,until,condition,null,new,and,condition,proceed,condition,new,not,condition,until,condition,proceed,condition,update,with,greedy,condition,sink,state,get,take,condition,current,pattern,else,looping,state,add,proceed,sink,state,proceed,condition,looping,state,add,take,take,condition,add,stop,state,to,looping,looping,state,if,ignore,condition,null,final,state,t,ignore,state,create,state,current,pattern,get,name,state,state,type,normal,ignore,state,add,take,looping,state,take,condition,ignore,state,add,ignore,ignore,condition,looping,state,add,ignore,ignore,state,ignore,condition,add,stop,state,to,looping,ignore,state,return,looping,state
NFACompiler -> NFAFactoryCompiler -> @SuppressWarnings("unchecked") 		private State<T> createLooping(final State<T> sinkState);1518008111;Creates the given state as a looping one. Looping state is one with TAKE edge to itself and_PROCEED edge to the sinkState. It also consists of a similar state without the PROCEED edge, so that_for each PROCEED transition branches in computation state graph  can be created only once.__@param sinkState the state that the converted state should point to_@return the first state of the created complex state;@SuppressWarnings("unchecked")_		private State<T> createLooping(final State<T> sinkState) {_			if (currentPattern instanceof GroupPattern) {_				return createLoopingGroupPatternState((GroupPattern) currentPattern, sinkState)__			}_			final IterativeCondition<T> untilCondition = (IterativeCondition<T>) currentPattern.getUntilCondition()___			final IterativeCondition<T> ignoreCondition = extendWithUntilCondition(_				getInnerIgnoreCondition(currentPattern),_				untilCondition,_				false)__			final IterativeCondition<T> takeCondition = extendWithUntilCondition(_				getTakeCondition(currentPattern),_				untilCondition,_				true)___			IterativeCondition<T> proceedCondition = getTrueFunction()__			final State<T> loopingState = createState(currentPattern.getName(), State.StateType.Normal)___			if (currentPattern.getQuantifier().hasProperty(Quantifier.QuantifierProperty.GREEDY)) {_				if (untilCondition != null) {_					State<T> sinkStateCopy = copy(sinkState)__					loopingState.addProceed(sinkStateCopy, new AndCondition<>(proceedCondition, untilCondition))__					originalStateMap.put(sinkState.getName(), sinkStateCopy)__				}_				loopingState.addProceed(sinkState,_					untilCondition != null_						? new AndCondition<>(proceedCondition, new NotCondition<>(untilCondition))_						: proceedCondition)__				updateWithGreedyCondition(sinkState, getTakeCondition(currentPattern))__			} else {_				loopingState.addProceed(sinkState, proceedCondition)__			}_			loopingState.addTake(takeCondition)___			addStopStateToLooping(loopingState)___			if (ignoreCondition != null) {_				final State<T> ignoreState = createState(currentPattern.getName(), State.StateType.Normal)__				ignoreState.addTake(loopingState, takeCondition)__				ignoreState.addIgnore(ignoreCondition)__				loopingState.addIgnore(ignoreState, ignoreCondition)___				addStopStateToLooping(ignoreState)__			}_			return loopingState__		};creates,the,given,state,as,a,looping,one,looping,state,is,one,with,take,edge,to,itself,and,proceed,edge,to,the,sink,state,it,also,consists,of,a,similar,state,without,the,proceed,edge,so,that,for,each,proceed,transition,branches,in,computation,state,graph,can,be,created,only,once,param,sink,state,the,state,that,the,converted,state,should,point,to,return,the,first,state,of,the,created,complex,state;suppress,warnings,unchecked,private,state,t,create,looping,final,state,t,sink,state,if,current,pattern,instanceof,group,pattern,return,create,looping,group,pattern,state,group,pattern,current,pattern,sink,state,final,iterative,condition,t,until,condition,iterative,condition,t,current,pattern,get,until,condition,final,iterative,condition,t,ignore,condition,extend,with,until,condition,get,inner,ignore,condition,current,pattern,until,condition,false,final,iterative,condition,t,take,condition,extend,with,until,condition,get,take,condition,current,pattern,until,condition,true,iterative,condition,t,proceed,condition,get,true,function,final,state,t,looping,state,create,state,current,pattern,get,name,state,state,type,normal,if,current,pattern,get,quantifier,has,property,quantifier,quantifier,property,greedy,if,until,condition,null,state,t,sink,state,copy,copy,sink,state,looping,state,add,proceed,sink,state,copy,new,and,condition,proceed,condition,until,condition,original,state,map,put,sink,state,get,name,sink,state,copy,looping,state,add,proceed,sink,state,until,condition,null,new,and,condition,proceed,condition,new,not,condition,until,condition,proceed,condition,update,with,greedy,condition,sink,state,get,take,condition,current,pattern,else,looping,state,add,proceed,sink,state,proceed,condition,looping,state,add,take,take,condition,add,stop,state,to,looping,looping,state,if,ignore,condition,null,final,state,t,ignore,state,create,state,current,pattern,get,name,state,state,type,normal,ignore,state,add,take,looping,state,take,condition,ignore,state,add,ignore,ignore,condition,looping,state,add,ignore,ignore,state,ignore,condition,add,stop,state,to,looping,ignore,state,return,looping,state
NFACompiler -> NFAFactoryCompiler -> @SuppressWarnings("unchecked") 		private State<T> createLooping(final State<T> sinkState);1527863170;Creates the given state as a looping one. Looping state is one with TAKE edge to itself and_PROCEED edge to the sinkState. It also consists of a similar state without the PROCEED edge, so that_for each PROCEED transition branches in computation state graph  can be created only once.__@param sinkState the state that the converted state should point to_@return the first state of the created complex state;@SuppressWarnings("unchecked")_		private State<T> createLooping(final State<T> sinkState) {_			if (currentPattern instanceof GroupPattern) {_				return createLoopingGroupPatternState((GroupPattern) currentPattern, sinkState)__			}_			final IterativeCondition<T> untilCondition = (IterativeCondition<T>) currentPattern.getUntilCondition()___			final IterativeCondition<T> ignoreCondition = extendWithUntilCondition(_				getInnerIgnoreCondition(currentPattern),_				untilCondition,_				false)__			final IterativeCondition<T> takeCondition = extendWithUntilCondition(_				getTakeCondition(currentPattern),_				untilCondition,_				true)___			IterativeCondition<T> proceedCondition = getTrueFunction()__			final State<T> loopingState = createState(currentPattern.getName(), State.StateType.Normal)___			if (currentPattern.getQuantifier().hasProperty(Quantifier.QuantifierProperty.GREEDY)) {_				if (untilCondition != null) {_					State<T> sinkStateCopy = copy(sinkState)__					loopingState.addProceed(sinkStateCopy, new AndCondition<>(proceedCondition, untilCondition))__					originalStateMap.put(sinkState.getName(), sinkStateCopy)__				}_				loopingState.addProceed(sinkState,_					untilCondition != null_						? new AndCondition<>(proceedCondition, new NotCondition<>(untilCondition))_						: proceedCondition)__				updateWithGreedyCondition(sinkState, getTakeCondition(currentPattern))__			} else {_				loopingState.addProceed(sinkState, proceedCondition)__			}_			loopingState.addTake(takeCondition)___			addStopStateToLooping(loopingState)___			if (ignoreCondition != null) {_				final State<T> ignoreState = createState(currentPattern.getName(), State.StateType.Normal)__				ignoreState.addTake(loopingState, takeCondition)__				ignoreState.addIgnore(ignoreCondition)__				loopingState.addIgnore(ignoreState, ignoreCondition)___				addStopStateToLooping(ignoreState)__			}_			return loopingState__		};creates,the,given,state,as,a,looping,one,looping,state,is,one,with,take,edge,to,itself,and,proceed,edge,to,the,sink,state,it,also,consists,of,a,similar,state,without,the,proceed,edge,so,that,for,each,proceed,transition,branches,in,computation,state,graph,can,be,created,only,once,param,sink,state,the,state,that,the,converted,state,should,point,to,return,the,first,state,of,the,created,complex,state;suppress,warnings,unchecked,private,state,t,create,looping,final,state,t,sink,state,if,current,pattern,instanceof,group,pattern,return,create,looping,group,pattern,state,group,pattern,current,pattern,sink,state,final,iterative,condition,t,until,condition,iterative,condition,t,current,pattern,get,until,condition,final,iterative,condition,t,ignore,condition,extend,with,until,condition,get,inner,ignore,condition,current,pattern,until,condition,false,final,iterative,condition,t,take,condition,extend,with,until,condition,get,take,condition,current,pattern,until,condition,true,iterative,condition,t,proceed,condition,get,true,function,final,state,t,looping,state,create,state,current,pattern,get,name,state,state,type,normal,if,current,pattern,get,quantifier,has,property,quantifier,quantifier,property,greedy,if,until,condition,null,state,t,sink,state,copy,copy,sink,state,looping,state,add,proceed,sink,state,copy,new,and,condition,proceed,condition,until,condition,original,state,map,put,sink,state,get,name,sink,state,copy,looping,state,add,proceed,sink,state,until,condition,null,new,and,condition,proceed,condition,new,not,condition,until,condition,proceed,condition,update,with,greedy,condition,sink,state,get,take,condition,current,pattern,else,looping,state,add,proceed,sink,state,proceed,condition,looping,state,add,take,take,condition,add,stop,state,to,looping,looping,state,if,ignore,condition,null,final,state,t,ignore,state,create,state,current,pattern,get,name,state,state,type,normal,ignore,state,add,take,looping,state,take,condition,ignore,state,add,ignore,ignore,condition,looping,state,add,ignore,ignore,state,ignore,condition,add,stop,state,to,looping,ignore,state,return,looping,state
NFACompiler -> NFAFactoryCompiler -> @SuppressWarnings("unchecked") 		private State<T> createLooping(final State<T> sinkState);1528989005;Creates the given state as a looping one. Looping state is one with TAKE edge to itself and_PROCEED edge to the sinkState. It also consists of a similar state without the PROCEED edge, so that_for each PROCEED transition branches in computation state graph  can be created only once.__@param sinkState the state that the converted state should point to_@return the first state of the created complex state;@SuppressWarnings("unchecked")_		private State<T> createLooping(final State<T> sinkState) {_			if (currentPattern instanceof GroupPattern) {_				return createLoopingGroupPatternState((GroupPattern) currentPattern, sinkState)__			}_			final IterativeCondition<T> untilCondition = (IterativeCondition<T>) currentPattern.getUntilCondition()___			final IterativeCondition<T> ignoreCondition = extendWithUntilCondition(_				getInnerIgnoreCondition(currentPattern),_				untilCondition,_				false)__			final IterativeCondition<T> takeCondition = extendWithUntilCondition(_				getTakeCondition(currentPattern),_				untilCondition,_				true)___			IterativeCondition<T> proceedCondition = getTrueFunction()__			final State<T> loopingState = createState(currentPattern.getName(), State.StateType.Normal)___			if (currentPattern.getQuantifier().hasProperty(Quantifier.QuantifierProperty.GREEDY)) {_				if (untilCondition != null) {_					State<T> sinkStateCopy = copy(sinkState)__					loopingState.addProceed(sinkStateCopy, new AndCondition<>(proceedCondition, untilCondition))__					originalStateMap.put(sinkState.getName(), sinkStateCopy)__				}_				loopingState.addProceed(sinkState,_					untilCondition != null_						? new AndCondition<>(proceedCondition, new NotCondition<>(untilCondition))_						: proceedCondition)__				updateWithGreedyCondition(sinkState, getTakeCondition(currentPattern))__			} else {_				loopingState.addProceed(sinkState, proceedCondition)__			}_			loopingState.addTake(takeCondition)___			addStopStateToLooping(loopingState)___			if (ignoreCondition != null) {_				final State<T> ignoreState = createState(currentPattern.getName(), State.StateType.Normal)__				ignoreState.addTake(loopingState, takeCondition)__				ignoreState.addIgnore(ignoreCondition)__				loopingState.addIgnore(ignoreState, ignoreCondition)___				addStopStateToLooping(ignoreState)__			}_			return loopingState__		};creates,the,given,state,as,a,looping,one,looping,state,is,one,with,take,edge,to,itself,and,proceed,edge,to,the,sink,state,it,also,consists,of,a,similar,state,without,the,proceed,edge,so,that,for,each,proceed,transition,branches,in,computation,state,graph,can,be,created,only,once,param,sink,state,the,state,that,the,converted,state,should,point,to,return,the,first,state,of,the,created,complex,state;suppress,warnings,unchecked,private,state,t,create,looping,final,state,t,sink,state,if,current,pattern,instanceof,group,pattern,return,create,looping,group,pattern,state,group,pattern,current,pattern,sink,state,final,iterative,condition,t,until,condition,iterative,condition,t,current,pattern,get,until,condition,final,iterative,condition,t,ignore,condition,extend,with,until,condition,get,inner,ignore,condition,current,pattern,until,condition,false,final,iterative,condition,t,take,condition,extend,with,until,condition,get,take,condition,current,pattern,until,condition,true,iterative,condition,t,proceed,condition,get,true,function,final,state,t,looping,state,create,state,current,pattern,get,name,state,state,type,normal,if,current,pattern,get,quantifier,has,property,quantifier,quantifier,property,greedy,if,until,condition,null,state,t,sink,state,copy,copy,sink,state,looping,state,add,proceed,sink,state,copy,new,and,condition,proceed,condition,until,condition,original,state,map,put,sink,state,get,name,sink,state,copy,looping,state,add,proceed,sink,state,until,condition,null,new,and,condition,proceed,condition,new,not,condition,until,condition,proceed,condition,update,with,greedy,condition,sink,state,get,take,condition,current,pattern,else,looping,state,add,proceed,sink,state,proceed,condition,looping,state,add,take,take,condition,add,stop,state,to,looping,looping,state,if,ignore,condition,null,final,state,t,ignore,state,create,state,current,pattern,get,name,state,state,type,normal,ignore,state,add,take,looping,state,take,condition,ignore,state,add,ignore,ignore,condition,looping,state,add,ignore,ignore,state,ignore,condition,add,stop,state,to,looping,ignore,state,return,looping,state
NFACompiler -> NFAFactoryCompiler -> @SuppressWarnings("unchecked") 		private State<T> createLooping(final State<T> sinkState);1538745898;Creates the given state as a looping one. Looping state is one with TAKE edge to itself and_PROCEED edge to the sinkState. It also consists of a similar state without the PROCEED edge, so that_for each PROCEED transition branches in computation state graph  can be created only once.__@param sinkState the state that the converted state should point to_@return the first state of the created complex state;@SuppressWarnings("unchecked")_		private State<T> createLooping(final State<T> sinkState) {_			if (currentPattern instanceof GroupPattern) {_				return createLoopingGroupPatternState((GroupPattern) currentPattern, sinkState)__			}_			final IterativeCondition<T> untilCondition = (IterativeCondition<T>) currentPattern.getUntilCondition()___			final IterativeCondition<T> ignoreCondition = extendWithUntilCondition(_				getInnerIgnoreCondition(currentPattern),_				untilCondition,_				false)__			final IterativeCondition<T> takeCondition = extendWithUntilCondition(_				getTakeCondition(currentPattern),_				untilCondition,_				true)___			IterativeCondition<T> proceedCondition = getTrueFunction()__			final State<T> loopingState = createState(currentPattern.getName(), State.StateType.Normal)___			if (currentPattern.getQuantifier().hasProperty(Quantifier.QuantifierProperty.GREEDY)) {_				if (untilCondition != null) {_					State<T> sinkStateCopy = copy(sinkState)__					loopingState.addProceed(sinkStateCopy, new AndCondition<>(proceedCondition, untilCondition))__					originalStateMap.put(sinkState.getName(), sinkStateCopy)__				}_				loopingState.addProceed(sinkState,_					untilCondition != null_						? new AndCondition<>(proceedCondition, new NotCondition<>(untilCondition))_						: proceedCondition)__				updateWithGreedyCondition(sinkState, getTakeCondition(currentPattern))__			} else {_				loopingState.addProceed(sinkState, proceedCondition)__			}_			loopingState.addTake(takeCondition)___			addStopStateToLooping(loopingState)___			if (ignoreCondition != null) {_				final State<T> ignoreState = createState(currentPattern.getName(), State.StateType.Normal)__				ignoreState.addTake(loopingState, takeCondition)__				ignoreState.addIgnore(ignoreCondition)__				loopingState.addIgnore(ignoreState, ignoreCondition)___				addStopStateToLooping(ignoreState)__			}_			return loopingState__		};creates,the,given,state,as,a,looping,one,looping,state,is,one,with,take,edge,to,itself,and,proceed,edge,to,the,sink,state,it,also,consists,of,a,similar,state,without,the,proceed,edge,so,that,for,each,proceed,transition,branches,in,computation,state,graph,can,be,created,only,once,param,sink,state,the,state,that,the,converted,state,should,point,to,return,the,first,state,of,the,created,complex,state;suppress,warnings,unchecked,private,state,t,create,looping,final,state,t,sink,state,if,current,pattern,instanceof,group,pattern,return,create,looping,group,pattern,state,group,pattern,current,pattern,sink,state,final,iterative,condition,t,until,condition,iterative,condition,t,current,pattern,get,until,condition,final,iterative,condition,t,ignore,condition,extend,with,until,condition,get,inner,ignore,condition,current,pattern,until,condition,false,final,iterative,condition,t,take,condition,extend,with,until,condition,get,take,condition,current,pattern,until,condition,true,iterative,condition,t,proceed,condition,get,true,function,final,state,t,looping,state,create,state,current,pattern,get,name,state,state,type,normal,if,current,pattern,get,quantifier,has,property,quantifier,quantifier,property,greedy,if,until,condition,null,state,t,sink,state,copy,copy,sink,state,looping,state,add,proceed,sink,state,copy,new,and,condition,proceed,condition,until,condition,original,state,map,put,sink,state,get,name,sink,state,copy,looping,state,add,proceed,sink,state,until,condition,null,new,and,condition,proceed,condition,new,not,condition,until,condition,proceed,condition,update,with,greedy,condition,sink,state,get,take,condition,current,pattern,else,looping,state,add,proceed,sink,state,proceed,condition,looping,state,add,take,take,condition,add,stop,state,to,looping,looping,state,if,ignore,condition,null,final,state,t,ignore,state,create,state,current,pattern,get,name,state,state,type,normal,ignore,state,add,take,looping,state,take,condition,ignore,state,add,ignore,ignore,condition,looping,state,add,ignore,ignore,state,ignore,condition,add,stop,state,to,looping,ignore,state,return,looping,state
NFACompiler -> NFAFactoryCompiler -> @SuppressWarnings("unchecked") 		private State<T> createLooping(final State<T> sinkState);1542293931;Creates the given state as a looping one. Looping state is one with TAKE edge to itself and_PROCEED edge to the sinkState. It also consists of a similar state without the PROCEED edge, so that_for each PROCEED transition branches in computation state graph  can be created only once.__@param sinkState the state that the converted state should point to_@return the first state of the created complex state;@SuppressWarnings("unchecked")_		private State<T> createLooping(final State<T> sinkState) {_			if (currentPattern instanceof GroupPattern) {_				return createLoopingGroupPatternState((GroupPattern) currentPattern, sinkState)__			}_			final IterativeCondition<T> untilCondition = (IterativeCondition<T>) currentPattern.getUntilCondition()___			final IterativeCondition<T> ignoreCondition = extendWithUntilCondition(_				getInnerIgnoreCondition(currentPattern),_				untilCondition,_				false)__			final IterativeCondition<T> takeCondition = extendWithUntilCondition(_				getTakeCondition(currentPattern),_				untilCondition,_				true)___			IterativeCondition<T> proceedCondition = getTrueFunction()__			final State<T> loopingState = createState(currentPattern.getName(), State.StateType.Normal)___			if (currentPattern.getQuantifier().hasProperty(Quantifier.QuantifierProperty.GREEDY)) {_				if (untilCondition != null) {_					State<T> sinkStateCopy = copy(sinkState)__					loopingState.addProceed(sinkStateCopy, new RichAndCondition<>(proceedCondition, untilCondition))__					originalStateMap.put(sinkState.getName(), sinkStateCopy)__				}_				loopingState.addProceed(sinkState,_					untilCondition != null_						? new RichAndCondition<>(proceedCondition, new RichNotCondition<>(untilCondition))_						: proceedCondition)__				updateWithGreedyCondition(sinkState, getTakeCondition(currentPattern))__			} else {_				loopingState.addProceed(sinkState, proceedCondition)__			}_			loopingState.addTake(takeCondition)___			addStopStateToLooping(loopingState)___			if (ignoreCondition != null) {_				final State<T> ignoreState = createState(currentPattern.getName(), State.StateType.Normal)__				ignoreState.addTake(loopingState, takeCondition)__				ignoreState.addIgnore(ignoreCondition)__				loopingState.addIgnore(ignoreState, ignoreCondition)___				addStopStateToLooping(ignoreState)__			}_			return loopingState__		};creates,the,given,state,as,a,looping,one,looping,state,is,one,with,take,edge,to,itself,and,proceed,edge,to,the,sink,state,it,also,consists,of,a,similar,state,without,the,proceed,edge,so,that,for,each,proceed,transition,branches,in,computation,state,graph,can,be,created,only,once,param,sink,state,the,state,that,the,converted,state,should,point,to,return,the,first,state,of,the,created,complex,state;suppress,warnings,unchecked,private,state,t,create,looping,final,state,t,sink,state,if,current,pattern,instanceof,group,pattern,return,create,looping,group,pattern,state,group,pattern,current,pattern,sink,state,final,iterative,condition,t,until,condition,iterative,condition,t,current,pattern,get,until,condition,final,iterative,condition,t,ignore,condition,extend,with,until,condition,get,inner,ignore,condition,current,pattern,until,condition,false,final,iterative,condition,t,take,condition,extend,with,until,condition,get,take,condition,current,pattern,until,condition,true,iterative,condition,t,proceed,condition,get,true,function,final,state,t,looping,state,create,state,current,pattern,get,name,state,state,type,normal,if,current,pattern,get,quantifier,has,property,quantifier,quantifier,property,greedy,if,until,condition,null,state,t,sink,state,copy,copy,sink,state,looping,state,add,proceed,sink,state,copy,new,rich,and,condition,proceed,condition,until,condition,original,state,map,put,sink,state,get,name,sink,state,copy,looping,state,add,proceed,sink,state,until,condition,null,new,rich,and,condition,proceed,condition,new,rich,not,condition,until,condition,proceed,condition,update,with,greedy,condition,sink,state,get,take,condition,current,pattern,else,looping,state,add,proceed,sink,state,proceed,condition,looping,state,add,take,take,condition,add,stop,state,to,looping,looping,state,if,ignore,condition,null,final,state,t,ignore,state,create,state,current,pattern,get,name,state,state,type,normal,ignore,state,add,take,looping,state,take,condition,ignore,state,add,ignore,ignore,condition,looping,state,add,ignore,ignore,state,ignore,condition,add,stop,state,to,looping,ignore,state,return,looping,state
NFACompiler -> NFAFactoryCompiler -> @SuppressWarnings("unchecked") 		private State<T> createInitMandatoryStateOfOneOrMore(final State<T> sinkState);1493385877;Patterns with quantifiers AT_LEAST_ONE_* are created as a pair of states: a singleton state and_looping state. This method creates the first of the two.__@param sinkState the state the newly created state should point to, it should be a looping state_@return the newly created state;@SuppressWarnings("unchecked")_		private State<T> createInitMandatoryStateOfOneOrMore(final State<T> sinkState) {_			final IterativeCondition<T> currentCondition = (IterativeCondition<T>) currentPattern.getCondition()___			final State<T> firstState = createNormalState()__			firstState.addTake(sinkState, currentCondition)___			final IterativeCondition<T> ignoreCondition = getIgnoreCondition(currentPattern)__			if (ignoreCondition != null) {_				firstState.addIgnore(ignoreCondition)__			}_			return firstState__		};patterns,with,quantifiers,are,created,as,a,pair,of,states,a,singleton,state,and,looping,state,this,method,creates,the,first,of,the,two,param,sink,state,the,state,the,newly,created,state,should,point,to,it,should,be,a,looping,state,return,the,newly,created,state;suppress,warnings,unchecked,private,state,t,create,init,mandatory,state,of,one,or,more,final,state,t,sink,state,final,iterative,condition,t,current,condition,iterative,condition,t,current,pattern,get,condition,final,state,t,first,state,create,normal,state,first,state,add,take,sink,state,current,condition,final,iterative,condition,t,ignore,condition,get,ignore,condition,current,pattern,if,ignore,condition,null,first,state,add,ignore,ignore,condition,return,first,state
NFACompiler -> NFAFactoryCompiler -> @SuppressWarnings("unchecked") 		private State<T> createInitMandatoryStateOfOneOrMore(final State<T> sinkState);1494947249;Patterns with quantifiers AT_LEAST_ONE_* are created as a pair of states: a singleton state and_looping state. This method creates the first of the two.__@param sinkState the state the newly created state should point to, it should be a looping state_@return the newly created state;@SuppressWarnings("unchecked")_		private State<T> createInitMandatoryStateOfOneOrMore(final State<T> sinkState) {_			final IterativeCondition<T> currentCondition = (IterativeCondition<T>) currentPattern.getCondition()___			final State<T> firstState = createState(currentPattern.getName(), State.StateType.Normal)__			firstState.addTake(sinkState, currentCondition)___			final IterativeCondition<T> ignoreCondition = getIgnoreCondition(currentPattern)__			if (ignoreCondition != null) {_				firstState.addIgnore(ignoreCondition)__			}_			return firstState__		};patterns,with,quantifiers,are,created,as,a,pair,of,states,a,singleton,state,and,looping,state,this,method,creates,the,first,of,the,two,param,sink,state,the,state,the,newly,created,state,should,point,to,it,should,be,a,looping,state,return,the,newly,created,state;suppress,warnings,unchecked,private,state,t,create,init,mandatory,state,of,one,or,more,final,state,t,sink,state,final,iterative,condition,t,current,condition,iterative,condition,t,current,pattern,get,condition,final,state,t,first,state,create,state,current,pattern,get,name,state,state,type,normal,first,state,add,take,sink,state,current,condition,final,iterative,condition,t,ignore,condition,get,ignore,condition,current,pattern,if,ignore,condition,null,first,state,add,ignore,ignore,condition,return,first,state
NFACompiler -> NFAFactoryCompiler -> @SuppressWarnings("unchecked") 		private State<T> createInitMandatoryStateOfOneOrMore(final State<T> sinkState);1495657626;Patterns with quantifiers AT_LEAST_ONE_* are created as a pair of states: a singleton state and_looping state. This method creates the first of the two.__@param sinkState the state the newly created state should point to, it should be a looping state_@return the newly created state;@SuppressWarnings("unchecked")_		private State<T> createInitMandatoryStateOfOneOrMore(final State<T> sinkState) {_			final IterativeCondition<T> currentCondition = (IterativeCondition<T>) currentPattern.getCondition()___			final State<T> firstState = createState(currentPattern.getName(), State.StateType.Normal)__			firstState.addTake(sinkState, currentCondition)___			final IterativeCondition<T> ignoreCondition = getIgnoreCondition(currentPattern)__			if (ignoreCondition != null) {_				firstState.addIgnore(ignoreCondition)__			}_			return firstState__		};patterns,with,quantifiers,are,created,as,a,pair,of,states,a,singleton,state,and,looping,state,this,method,creates,the,first,of,the,two,param,sink,state,the,state,the,newly,created,state,should,point,to,it,should,be,a,looping,state,return,the,newly,created,state;suppress,warnings,unchecked,private,state,t,create,init,mandatory,state,of,one,or,more,final,state,t,sink,state,final,iterative,condition,t,current,condition,iterative,condition,t,current,pattern,get,condition,final,state,t,first,state,create,state,current,pattern,get,name,state,state,type,normal,first,state,add,take,sink,state,current,condition,final,iterative,condition,t,ignore,condition,get,ignore,condition,current,pattern,if,ignore,condition,null,first,state,add,ignore,ignore,condition,return,first,state
NFACompiler -> NFAFactoryCompiler -> @SuppressWarnings("unchecked") 		private State<T> createInitMandatoryStateOfOneOrMore(final State<T> sinkState);1496245714;Patterns with quantifiers AT_LEAST_ONE_* are created as a pair of states: a singleton state and_looping state. This method creates the first of the two.__@param sinkState the state the newly created state should point to, it should be a looping state_@return the newly created state;@SuppressWarnings("unchecked")_		private State<T> createInitMandatoryStateOfOneOrMore(final State<T> sinkState) {_			final IterativeCondition<T> currentCondition = (IterativeCondition<T>) currentPattern.getCondition()___			final State<T> firstState = createState(currentPattern.getName(), State.StateType.Normal)__			firstState.addTake(sinkState, currentCondition)___			final IterativeCondition<T> ignoreCondition = getIgnoreCondition(currentPattern)__			if (ignoreCondition != null) {_				firstState.addIgnore(ignoreCondition)__			}_			return firstState__		};patterns,with,quantifiers,are,created,as,a,pair,of,states,a,singleton,state,and,looping,state,this,method,creates,the,first,of,the,two,param,sink,state,the,state,the,newly,created,state,should,point,to,it,should,be,a,looping,state,return,the,newly,created,state;suppress,warnings,unchecked,private,state,t,create,init,mandatory,state,of,one,or,more,final,state,t,sink,state,final,iterative,condition,t,current,condition,iterative,condition,t,current,pattern,get,condition,final,state,t,first,state,create,state,current,pattern,get,name,state,state,type,normal,first,state,add,take,sink,state,current,condition,final,iterative,condition,t,ignore,condition,get,ignore,condition,current,pattern,if,ignore,condition,null,first,state,add,ignore,ignore,condition,return,first,state
NFACompiler -> NFAFactoryCompiler -> @SuppressWarnings("unchecked") 		private State<T> createInitMandatoryStateOfOneOrMore(final State<T> sinkState);1497410381;Patterns with quantifiers AT_LEAST_ONE_* are created as a pair of states: a singleton state and_looping state. This method creates the first of the two.__@param sinkState the state the newly created state should point to, it should be a looping state_@return the newly created state;@SuppressWarnings("unchecked")_		private State<T> createInitMandatoryStateOfOneOrMore(final State<T> sinkState) {_			final IterativeCondition<T> currentCondition = (IterativeCondition<T>) currentPattern.getCondition()___			final State<T> firstState = createState(currentPattern.getName(), State.StateType.Normal)__			firstState.addTake(sinkState, currentCondition)___			final IterativeCondition<T> ignoreCondition = getIgnoreCondition(currentPattern)__			if (ignoreCondition != null) {_				firstState.addIgnore(ignoreCondition)__			}_			return firstState__		};patterns,with,quantifiers,are,created,as,a,pair,of,states,a,singleton,state,and,looping,state,this,method,creates,the,first,of,the,two,param,sink,state,the,state,the,newly,created,state,should,point,to,it,should,be,a,looping,state,return,the,newly,created,state;suppress,warnings,unchecked,private,state,t,create,init,mandatory,state,of,one,or,more,final,state,t,sink,state,final,iterative,condition,t,current,condition,iterative,condition,t,current,pattern,get,condition,final,state,t,first,state,create,state,current,pattern,get,name,state,state,type,normal,first,state,add,take,sink,state,current,condition,final,iterative,condition,t,ignore,condition,get,ignore,condition,current,pattern,if,ignore,condition,null,first,state,add,ignore,ignore,condition,return,first,state
NFACompiler -> NFAFactoryCompiler -> @SuppressWarnings("unchecked") 		private State<T> createInitMandatoryStateOfOneOrMore(final State<T> sinkState);1497883202;Patterns with quantifiers AT_LEAST_ONE_* are created as a pair of states: a singleton state and_looping state. This method creates the first of the two.__@param sinkState the state the newly created state should point to, it should be a looping state_@return the newly created state;@SuppressWarnings("unchecked")_		private State<T> createInitMandatoryStateOfOneOrMore(final State<T> sinkState) {_			final IterativeCondition<T> takeCondition = extendWithUntilCondition(_				(IterativeCondition<T>) currentPattern.getCondition(),_				(IterativeCondition<T>) currentPattern.getUntilCondition()_			)___			final State<T> firstState = createState(currentPattern.getName(), State.StateType.Normal)__			firstState.addTake(sinkState, takeCondition)___			final IterativeCondition<T> ignoreCondition = getIgnoreCondition(currentPattern)__			if (ignoreCondition != null) {_				firstState.addIgnore(ignoreCondition)__			}_			return firstState__		};patterns,with,quantifiers,are,created,as,a,pair,of,states,a,singleton,state,and,looping,state,this,method,creates,the,first,of,the,two,param,sink,state,the,state,the,newly,created,state,should,point,to,it,should,be,a,looping,state,return,the,newly,created,state;suppress,warnings,unchecked,private,state,t,create,init,mandatory,state,of,one,or,more,final,state,t,sink,state,final,iterative,condition,t,take,condition,extend,with,until,condition,iterative,condition,t,current,pattern,get,condition,iterative,condition,t,current,pattern,get,until,condition,final,state,t,first,state,create,state,current,pattern,get,name,state,state,type,normal,first,state,add,take,sink,state,take,condition,final,iterative,condition,t,ignore,condition,get,ignore,condition,current,pattern,if,ignore,condition,null,first,state,add,ignore,ignore,condition,return,first,state
NFACompiler -> NFAFactoryCompiler -> @SuppressWarnings("unchecked") 		private State<T> createInitMandatoryStateOfOneOrMore(final State<T> sinkState);1498034481;Patterns with quantifiers AT_LEAST_ONE_* are created as a pair of states: a singleton state and_looping state. This method creates the first of the two.__@param sinkState the state the newly created state should point to, it should be a looping state_@return the newly created state;@SuppressWarnings("unchecked")_		private State<T> createInitMandatoryStateOfOneOrMore(final State<T> sinkState) {_			final IterativeCondition<T> takeCondition = extendWithUntilCondition(_				getTakeCondition(currentPattern),_				(IterativeCondition<T>) currentPattern.getUntilCondition()_			)___			final IterativeCondition<T> ignoreCondition = getIgnoreCondition(currentPattern)___			return createSingletonState(sinkState, null, takeCondition, ignoreCondition, false)__		};patterns,with,quantifiers,are,created,as,a,pair,of,states,a,singleton,state,and,looping,state,this,method,creates,the,first,of,the,two,param,sink,state,the,state,the,newly,created,state,should,point,to,it,should,be,a,looping,state,return,the,newly,created,state;suppress,warnings,unchecked,private,state,t,create,init,mandatory,state,of,one,or,more,final,state,t,sink,state,final,iterative,condition,t,take,condition,extend,with,until,condition,get,take,condition,current,pattern,iterative,condition,t,current,pattern,get,until,condition,final,iterative,condition,t,ignore,condition,get,ignore,condition,current,pattern,return,create,singleton,state,sink,state,null,take,condition,ignore,condition,false
NFACompiler -> NFAFactoryCompiler -> @SuppressWarnings("unchecked") 		private State<T> createInitMandatoryStateOfOneOrMore(final State<T> sinkState);1499937690;Patterns with quantifiers AT_LEAST_ONE_* are created as a pair of states: a singleton state and_looping state. This method creates the first of the two.__@param sinkState the state the newly created state should point to, it should be a looping state_@return the newly created state;@SuppressWarnings("unchecked")_		private State<T> createInitMandatoryStateOfOneOrMore(final State<T> sinkState) {_			final IterativeCondition<T> takeCondition = extendWithUntilCondition(_				getTakeCondition(currentPattern),_				(IterativeCondition<T>) currentPattern.getUntilCondition(),_				true_			)___			final IterativeCondition<T> ignoreCondition = getIgnoreCondition(currentPattern)___			return createSingletonState(sinkState, null, takeCondition, ignoreCondition, false)__		};patterns,with,quantifiers,are,created,as,a,pair,of,states,a,singleton,state,and,looping,state,this,method,creates,the,first,of,the,two,param,sink,state,the,state,the,newly,created,state,should,point,to,it,should,be,a,looping,state,return,the,newly,created,state;suppress,warnings,unchecked,private,state,t,create,init,mandatory,state,of,one,or,more,final,state,t,sink,state,final,iterative,condition,t,take,condition,extend,with,until,condition,get,take,condition,current,pattern,iterative,condition,t,current,pattern,get,until,condition,true,final,iterative,condition,t,ignore,condition,get,ignore,condition,current,pattern,return,create,singleton,state,sink,state,null,take,condition,ignore,condition,false
NFACompiler -> NFAFactoryCompiler -> @SuppressWarnings("unchecked") 		private State<T> createInitMandatoryStateOfOneOrMore(final State<T> sinkState);1501592283;Patterns with quantifiers AT_LEAST_ONE_* are created as a pair of states: a singleton state and_looping state. This method creates the first of the two.__@param sinkState the state the newly created state should point to, it should be a looping state_@return the newly created state;@SuppressWarnings("unchecked")_		private State<T> createInitMandatoryStateOfOneOrMore(final State<T> sinkState) {_			final IterativeCondition<T> takeCondition = extendWithUntilCondition(_				getTakeCondition(currentPattern),_				(IterativeCondition<T>) currentPattern.getUntilCondition(),_				true_			)___			final IterativeCondition<T> ignoreCondition = getIgnoreCondition(currentPattern)___			return createSingletonState(sinkState, null, takeCondition, ignoreCondition, false)__		};patterns,with,quantifiers,are,created,as,a,pair,of,states,a,singleton,state,and,looping,state,this,method,creates,the,first,of,the,two,param,sink,state,the,state,the,newly,created,state,should,point,to,it,should,be,a,looping,state,return,the,newly,created,state;suppress,warnings,unchecked,private,state,t,create,init,mandatory,state,of,one,or,more,final,state,t,sink,state,final,iterative,condition,t,take,condition,extend,with,until,condition,get,take,condition,current,pattern,iterative,condition,t,current,pattern,get,until,condition,true,final,iterative,condition,t,ignore,condition,get,ignore,condition,current,pattern,return,create,singleton,state,sink,state,null,take,condition,ignore,condition,false
NFACompiler -> NFAFactoryCompiler -> @SuppressWarnings("unchecked") 		private State<T> createTimesState(final State<T> sinkState, final State<T> proceedState, Times times);1499760222;Creates a "complex" state consisting of given number of states with_same {@link IterativeCondition}.__@param sinkState the state that the created state should point to_@param proceedState state that the state being converted should proceed to_@param times     number of times the state should be copied_@return the first state of the "complex" state, next state should point to it;@SuppressWarnings("unchecked")_		private State<T> createTimesState(final State<T> sinkState, final State<T> proceedState, Times times) {_			State<T> lastSink = sinkState__			setCurrentGroupPatternFirstOfLoop(false)__			final IterativeCondition<T> untilCondition = (IterativeCondition<T>) currentPattern.getUntilCondition()__			final IterativeCondition<T> innerIgnoreCondition = extendWithUntilCondition(_				getInnerIgnoreCondition(currentPattern),_				untilCondition,_				false)__			final IterativeCondition<T> takeCondition = extendWithUntilCondition(_				getTakeCondition(currentPattern),_				untilCondition,_				true)___			if (currentPattern.getQuantifier().hasProperty(Quantifier.QuantifierProperty.GREEDY) &&_				times.getFrom() != times.getTo()) {_				if (untilCondition != null) {_					State<T> sinkStateCopy = copy(sinkState)__					originalStateMap.put(sinkState.getName(), sinkStateCopy)__				}_				updateWithGreedyCondition(sinkState, takeCondition)__			}__			for (int i = times.getFrom()_ i < times.getTo()_ i++) {_				lastSink = createSingletonState(lastSink, proceedState, takeCondition, innerIgnoreCondition, true)__				addStopStateToLooping(lastSink)__			}_			for (int i = 0_ i < times.getFrom() - 1_ i++) {_				lastSink = createSingletonState(lastSink, null, takeCondition, innerIgnoreCondition, false)__				addStopStateToLooping(lastSink)__			}_			_			setCurrentGroupPatternFirstOfLoop(true)__			return createSingletonState(_				lastSink,_				proceedState,_				takeCondition,_				getIgnoreCondition(currentPattern),_				currentPattern.getQuantifier().hasProperty(Quantifier.QuantifierProperty.OPTIONAL))__		};creates,a,complex,state,consisting,of,given,number,of,states,with,same,link,iterative,condition,param,sink,state,the,state,that,the,created,state,should,point,to,param,proceed,state,state,that,the,state,being,converted,should,proceed,to,param,times,number,of,times,the,state,should,be,copied,return,the,first,state,of,the,complex,state,next,state,should,point,to,it;suppress,warnings,unchecked,private,state,t,create,times,state,final,state,t,sink,state,final,state,t,proceed,state,times,times,state,t,last,sink,sink,state,set,current,group,pattern,first,of,loop,false,final,iterative,condition,t,until,condition,iterative,condition,t,current,pattern,get,until,condition,final,iterative,condition,t,inner,ignore,condition,extend,with,until,condition,get,inner,ignore,condition,current,pattern,until,condition,false,final,iterative,condition,t,take,condition,extend,with,until,condition,get,take,condition,current,pattern,until,condition,true,if,current,pattern,get,quantifier,has,property,quantifier,quantifier,property,greedy,times,get,from,times,get,to,if,until,condition,null,state,t,sink,state,copy,copy,sink,state,original,state,map,put,sink,state,get,name,sink,state,copy,update,with,greedy,condition,sink,state,take,condition,for,int,i,times,get,from,i,times,get,to,i,last,sink,create,singleton,state,last,sink,proceed,state,take,condition,inner,ignore,condition,true,add,stop,state,to,looping,last,sink,for,int,i,0,i,times,get,from,1,i,last,sink,create,singleton,state,last,sink,null,take,condition,inner,ignore,condition,false,add,stop,state,to,looping,last,sink,set,current,group,pattern,first,of,loop,true,return,create,singleton,state,last,sink,proceed,state,take,condition,get,ignore,condition,current,pattern,current,pattern,get,quantifier,has,property,quantifier,quantifier,property,optional
NFACompiler -> NFAFactoryCompiler -> @SuppressWarnings("unchecked") 		private State<T> createTimesState(final State<T> sinkState, final State<T> proceedState, Times times);1500021711;Creates a "complex" state consisting of given number of states with_same {@link IterativeCondition}.__@param sinkState the state that the created state should point to_@param proceedState state that the state being converted should proceed to_@param times     number of times the state should be copied_@return the first state of the "complex" state, next state should point to it;@SuppressWarnings("unchecked")_		private State<T> createTimesState(final State<T> sinkState, final State<T> proceedState, Times times) {_			State<T> lastSink = sinkState__			setCurrentGroupPatternFirstOfLoop(false)__			final IterativeCondition<T> untilCondition = (IterativeCondition<T>) currentPattern.getUntilCondition()__			final IterativeCondition<T> innerIgnoreCondition = extendWithUntilCondition(_				getInnerIgnoreCondition(currentPattern),_				untilCondition,_				false)__			final IterativeCondition<T> takeCondition = extendWithUntilCondition(_				getTakeCondition(currentPattern),_				untilCondition,_				true)___			if (currentPattern.getQuantifier().hasProperty(Quantifier.QuantifierProperty.GREEDY) &&_				times.getFrom() != times.getTo()) {_				if (untilCondition != null) {_					State<T> sinkStateCopy = copy(sinkState)__					originalStateMap.put(sinkState.getName(), sinkStateCopy)__				}_				updateWithGreedyCondition(sinkState, takeCondition)__			}__			for (int i = times.getFrom()_ i < times.getTo()_ i++) {_				lastSink = createSingletonState(lastSink, proceedState, takeCondition, innerIgnoreCondition, true)__				addStopStateToLooping(lastSink)__			}_			for (int i = 0_ i < times.getFrom() - 1_ i++) {_				lastSink = createSingletonState(lastSink, null, takeCondition, innerIgnoreCondition, false)__				addStopStateToLooping(lastSink)__			}_			_			setCurrentGroupPatternFirstOfLoop(true)__			return createSingletonState(_				lastSink,_				proceedState,_				takeCondition,_				getIgnoreCondition(currentPattern),_				currentPattern.getQuantifier().hasProperty(Quantifier.QuantifierProperty.OPTIONAL))__		};creates,a,complex,state,consisting,of,given,number,of,states,with,same,link,iterative,condition,param,sink,state,the,state,that,the,created,state,should,point,to,param,proceed,state,state,that,the,state,being,converted,should,proceed,to,param,times,number,of,times,the,state,should,be,copied,return,the,first,state,of,the,complex,state,next,state,should,point,to,it;suppress,warnings,unchecked,private,state,t,create,times,state,final,state,t,sink,state,final,state,t,proceed,state,times,times,state,t,last,sink,sink,state,set,current,group,pattern,first,of,loop,false,final,iterative,condition,t,until,condition,iterative,condition,t,current,pattern,get,until,condition,final,iterative,condition,t,inner,ignore,condition,extend,with,until,condition,get,inner,ignore,condition,current,pattern,until,condition,false,final,iterative,condition,t,take,condition,extend,with,until,condition,get,take,condition,current,pattern,until,condition,true,if,current,pattern,get,quantifier,has,property,quantifier,quantifier,property,greedy,times,get,from,times,get,to,if,until,condition,null,state,t,sink,state,copy,copy,sink,state,original,state,map,put,sink,state,get,name,sink,state,copy,update,with,greedy,condition,sink,state,take,condition,for,int,i,times,get,from,i,times,get,to,i,last,sink,create,singleton,state,last,sink,proceed,state,take,condition,inner,ignore,condition,true,add,stop,state,to,looping,last,sink,for,int,i,0,i,times,get,from,1,i,last,sink,create,singleton,state,last,sink,null,take,condition,inner,ignore,condition,false,add,stop,state,to,looping,last,sink,set,current,group,pattern,first,of,loop,true,return,create,singleton,state,last,sink,proceed,state,take,condition,get,ignore,condition,current,pattern,current,pattern,get,quantifier,has,property,quantifier,quantifier,property,optional
NFACompiler -> NFAFactoryCompiler -> @SuppressWarnings("unchecked") 		private State<T> createTimesState(final State<T> sinkState, final State<T> proceedState, Times times);1502422141;Creates a "complex" state consisting of given number of states with_same {@link IterativeCondition}.__@param sinkState the state that the created state should point to_@param proceedState state that the state being converted should proceed to_@param times     number of times the state should be copied_@return the first state of the "complex" state, next state should point to it;@SuppressWarnings("unchecked")_		private State<T> createTimesState(final State<T> sinkState, final State<T> proceedState, Times times) {_			State<T> lastSink = sinkState__			setCurrentGroupPatternFirstOfLoop(false)__			final IterativeCondition<T> untilCondition = (IterativeCondition<T>) currentPattern.getUntilCondition()__			final IterativeCondition<T> innerIgnoreCondition = extendWithUntilCondition(_				getInnerIgnoreCondition(currentPattern),_				untilCondition,_				false)__			final IterativeCondition<T> takeCondition = extendWithUntilCondition(_				getTakeCondition(currentPattern),_				untilCondition,_				true)___			for (int i = times.getFrom()_ i < times.getTo()_ i++) {_				lastSink = createSingletonState(lastSink, proceedState, takeCondition, innerIgnoreCondition, true)__				addStopStateToLooping(lastSink)__			}_			for (int i = 0_ i < times.getFrom() - 1_ i++) {_				lastSink = createSingletonState(lastSink, null, takeCondition, innerIgnoreCondition, false)__				addStopStateToLooping(lastSink)__			}_			_			setCurrentGroupPatternFirstOfLoop(true)__			return createSingletonState(_				lastSink,_				proceedState,_				takeCondition,_				getIgnoreCondition(currentPattern),_				currentPattern.getQuantifier().hasProperty(Quantifier.QuantifierProperty.OPTIONAL))__		};creates,a,complex,state,consisting,of,given,number,of,states,with,same,link,iterative,condition,param,sink,state,the,state,that,the,created,state,should,point,to,param,proceed,state,state,that,the,state,being,converted,should,proceed,to,param,times,number,of,times,the,state,should,be,copied,return,the,first,state,of,the,complex,state,next,state,should,point,to,it;suppress,warnings,unchecked,private,state,t,create,times,state,final,state,t,sink,state,final,state,t,proceed,state,times,times,state,t,last,sink,sink,state,set,current,group,pattern,first,of,loop,false,final,iterative,condition,t,until,condition,iterative,condition,t,current,pattern,get,until,condition,final,iterative,condition,t,inner,ignore,condition,extend,with,until,condition,get,inner,ignore,condition,current,pattern,until,condition,false,final,iterative,condition,t,take,condition,extend,with,until,condition,get,take,condition,current,pattern,until,condition,true,for,int,i,times,get,from,i,times,get,to,i,last,sink,create,singleton,state,last,sink,proceed,state,take,condition,inner,ignore,condition,true,add,stop,state,to,looping,last,sink,for,int,i,0,i,times,get,from,1,i,last,sink,create,singleton,state,last,sink,null,take,condition,inner,ignore,condition,false,add,stop,state,to,looping,last,sink,set,current,group,pattern,first,of,loop,true,return,create,singleton,state,last,sink,proceed,state,take,condition,get,ignore,condition,current,pattern,current,pattern,get,quantifier,has,property,quantifier,quantifier,property,optional
NFACompiler -> NFAFactoryCompiler -> @SuppressWarnings("unchecked") 		private State<T> createTimesState(final State<T> sinkState, final State<T> proceedState, Times times);1503588494;Creates a "complex" state consisting of given number of states with_same {@link IterativeCondition}.__@param sinkState the state that the created state should point to_@param proceedState state that the state being converted should proceed to_@param times     number of times the state should be copied_@return the first state of the "complex" state, next state should point to it;@SuppressWarnings("unchecked")_		private State<T> createTimesState(final State<T> sinkState, final State<T> proceedState, Times times) {_			State<T> lastSink = sinkState__			setCurrentGroupPatternFirstOfLoop(false)__			final IterativeCondition<T> untilCondition = (IterativeCondition<T>) currentPattern.getUntilCondition()__			final IterativeCondition<T> innerIgnoreCondition = extendWithUntilCondition(_				getInnerIgnoreCondition(currentPattern),_				untilCondition,_				false)__			final IterativeCondition<T> takeCondition = extendWithUntilCondition(_				getTakeCondition(currentPattern),_				untilCondition,_				true)___			if (currentPattern.getQuantifier().hasProperty(Quantifier.QuantifierProperty.GREEDY) &&_				times.getFrom() != times.getTo()) {_				if (untilCondition != null) {_					State<T> sinkStateCopy = copy(sinkState)__					originalStateMap.put(sinkState.getName(), sinkStateCopy)__				}_				updateWithGreedyCondition(sinkState, takeCondition)__			}__			for (int i = times.getFrom()_ i < times.getTo()_ i++) {_				lastSink = createSingletonState(lastSink, proceedState, takeCondition, innerIgnoreCondition, true)__				addStopStateToLooping(lastSink)__			}_			for (int i = 0_ i < times.getFrom() - 1_ i++) {_				lastSink = createSingletonState(lastSink, null, takeCondition, innerIgnoreCondition, false)__				addStopStateToLooping(lastSink)__			}_			_			setCurrentGroupPatternFirstOfLoop(true)__			return createSingletonState(_				lastSink,_				proceedState,_				takeCondition,_				getIgnoreCondition(currentPattern),_				currentPattern.getQuantifier().hasProperty(Quantifier.QuantifierProperty.OPTIONAL))__		};creates,a,complex,state,consisting,of,given,number,of,states,with,same,link,iterative,condition,param,sink,state,the,state,that,the,created,state,should,point,to,param,proceed,state,state,that,the,state,being,converted,should,proceed,to,param,times,number,of,times,the,state,should,be,copied,return,the,first,state,of,the,complex,state,next,state,should,point,to,it;suppress,warnings,unchecked,private,state,t,create,times,state,final,state,t,sink,state,final,state,t,proceed,state,times,times,state,t,last,sink,sink,state,set,current,group,pattern,first,of,loop,false,final,iterative,condition,t,until,condition,iterative,condition,t,current,pattern,get,until,condition,final,iterative,condition,t,inner,ignore,condition,extend,with,until,condition,get,inner,ignore,condition,current,pattern,until,condition,false,final,iterative,condition,t,take,condition,extend,with,until,condition,get,take,condition,current,pattern,until,condition,true,if,current,pattern,get,quantifier,has,property,quantifier,quantifier,property,greedy,times,get,from,times,get,to,if,until,condition,null,state,t,sink,state,copy,copy,sink,state,original,state,map,put,sink,state,get,name,sink,state,copy,update,with,greedy,condition,sink,state,take,condition,for,int,i,times,get,from,i,times,get,to,i,last,sink,create,singleton,state,last,sink,proceed,state,take,condition,inner,ignore,condition,true,add,stop,state,to,looping,last,sink,for,int,i,0,i,times,get,from,1,i,last,sink,create,singleton,state,last,sink,null,take,condition,inner,ignore,condition,false,add,stop,state,to,looping,last,sink,set,current,group,pattern,first,of,loop,true,return,create,singleton,state,last,sink,proceed,state,take,condition,get,ignore,condition,current,pattern,current,pattern,get,quantifier,has,property,quantifier,quantifier,property,optional
NFACompiler -> NFAFactoryCompiler -> @SuppressWarnings("unchecked") 		private State<T> createTimesState(final State<T> sinkState, final State<T> proceedState, Times times);1518008111;Creates a "complex" state consisting of given number of states with_same {@link IterativeCondition}.__@param sinkState the state that the created state should point to_@param proceedState state that the state being converted should proceed to_@param times     number of times the state should be copied_@return the first state of the "complex" state, next state should point to it;@SuppressWarnings("unchecked")_		private State<T> createTimesState(final State<T> sinkState, final State<T> proceedState, Times times) {_			State<T> lastSink = sinkState__			setCurrentGroupPatternFirstOfLoop(false)__			final IterativeCondition<T> untilCondition = (IterativeCondition<T>) currentPattern.getUntilCondition()__			final IterativeCondition<T> innerIgnoreCondition = extendWithUntilCondition(_				getInnerIgnoreCondition(currentPattern),_				untilCondition,_				false)__			final IterativeCondition<T> takeCondition = extendWithUntilCondition(_				getTakeCondition(currentPattern),_				untilCondition,_				true)___			if (currentPattern.getQuantifier().hasProperty(Quantifier.QuantifierProperty.GREEDY) &&_				times.getFrom() != times.getTo()) {_				if (untilCondition != null) {_					State<T> sinkStateCopy = copy(sinkState)__					originalStateMap.put(sinkState.getName(), sinkStateCopy)__				}_				updateWithGreedyCondition(sinkState, takeCondition)__			}__			for (int i = times.getFrom()_ i < times.getTo()_ i++) {_				lastSink = createSingletonState(lastSink, proceedState, takeCondition, innerIgnoreCondition, true)__				addStopStateToLooping(lastSink)__			}_			for (int i = 0_ i < times.getFrom() - 1_ i++) {_				lastSink = createSingletonState(lastSink, null, takeCondition, innerIgnoreCondition, false)__				addStopStateToLooping(lastSink)__			}_			_			setCurrentGroupPatternFirstOfLoop(true)__			return createSingletonState(_				lastSink,_				proceedState,_				takeCondition,_				getIgnoreCondition(currentPattern),_				currentPattern.getQuantifier().hasProperty(Quantifier.QuantifierProperty.OPTIONAL))__		};creates,a,complex,state,consisting,of,given,number,of,states,with,same,link,iterative,condition,param,sink,state,the,state,that,the,created,state,should,point,to,param,proceed,state,state,that,the,state,being,converted,should,proceed,to,param,times,number,of,times,the,state,should,be,copied,return,the,first,state,of,the,complex,state,next,state,should,point,to,it;suppress,warnings,unchecked,private,state,t,create,times,state,final,state,t,sink,state,final,state,t,proceed,state,times,times,state,t,last,sink,sink,state,set,current,group,pattern,first,of,loop,false,final,iterative,condition,t,until,condition,iterative,condition,t,current,pattern,get,until,condition,final,iterative,condition,t,inner,ignore,condition,extend,with,until,condition,get,inner,ignore,condition,current,pattern,until,condition,false,final,iterative,condition,t,take,condition,extend,with,until,condition,get,take,condition,current,pattern,until,condition,true,if,current,pattern,get,quantifier,has,property,quantifier,quantifier,property,greedy,times,get,from,times,get,to,if,until,condition,null,state,t,sink,state,copy,copy,sink,state,original,state,map,put,sink,state,get,name,sink,state,copy,update,with,greedy,condition,sink,state,take,condition,for,int,i,times,get,from,i,times,get,to,i,last,sink,create,singleton,state,last,sink,proceed,state,take,condition,inner,ignore,condition,true,add,stop,state,to,looping,last,sink,for,int,i,0,i,times,get,from,1,i,last,sink,create,singleton,state,last,sink,null,take,condition,inner,ignore,condition,false,add,stop,state,to,looping,last,sink,set,current,group,pattern,first,of,loop,true,return,create,singleton,state,last,sink,proceed,state,take,condition,get,ignore,condition,current,pattern,current,pattern,get,quantifier,has,property,quantifier,quantifier,property,optional
NFACompiler -> NFAFactoryCompiler -> @SuppressWarnings("unchecked") 		private State<T> createTimesState(final State<T> sinkState, final State<T> proceedState, Times times);1527863170;Creates a "complex" state consisting of given number of states with_same {@link IterativeCondition}.__@param sinkState the state that the created state should point to_@param proceedState state that the state being converted should proceed to_@param times     number of times the state should be copied_@return the first state of the "complex" state, next state should point to it;@SuppressWarnings("unchecked")_		private State<T> createTimesState(final State<T> sinkState, final State<T> proceedState, Times times) {_			State<T> lastSink = sinkState__			setCurrentGroupPatternFirstOfLoop(false)__			final IterativeCondition<T> untilCondition = (IterativeCondition<T>) currentPattern.getUntilCondition()__			final IterativeCondition<T> innerIgnoreCondition = extendWithUntilCondition(_				getInnerIgnoreCondition(currentPattern),_				untilCondition,_				false)__			final IterativeCondition<T> takeCondition = extendWithUntilCondition(_				getTakeCondition(currentPattern),_				untilCondition,_				true)___			if (currentPattern.getQuantifier().hasProperty(Quantifier.QuantifierProperty.GREEDY) &&_				times.getFrom() != times.getTo()) {_				if (untilCondition != null) {_					State<T> sinkStateCopy = copy(sinkState)__					originalStateMap.put(sinkState.getName(), sinkStateCopy)__				}_				updateWithGreedyCondition(sinkState, takeCondition)__			}__			for (int i = times.getFrom()_ i < times.getTo()_ i++) {_				lastSink = createSingletonState(lastSink, proceedState, takeCondition, innerIgnoreCondition, true)__				addStopStateToLooping(lastSink)__			}_			for (int i = 0_ i < times.getFrom() - 1_ i++) {_				lastSink = createSingletonState(lastSink, null, takeCondition, innerIgnoreCondition, false)__				addStopStateToLooping(lastSink)__			}_			_			setCurrentGroupPatternFirstOfLoop(true)__			return createSingletonState(_				lastSink,_				proceedState,_				takeCondition,_				getIgnoreCondition(currentPattern),_				currentPattern.getQuantifier().hasProperty(Quantifier.QuantifierProperty.OPTIONAL))__		};creates,a,complex,state,consisting,of,given,number,of,states,with,same,link,iterative,condition,param,sink,state,the,state,that,the,created,state,should,point,to,param,proceed,state,state,that,the,state,being,converted,should,proceed,to,param,times,number,of,times,the,state,should,be,copied,return,the,first,state,of,the,complex,state,next,state,should,point,to,it;suppress,warnings,unchecked,private,state,t,create,times,state,final,state,t,sink,state,final,state,t,proceed,state,times,times,state,t,last,sink,sink,state,set,current,group,pattern,first,of,loop,false,final,iterative,condition,t,until,condition,iterative,condition,t,current,pattern,get,until,condition,final,iterative,condition,t,inner,ignore,condition,extend,with,until,condition,get,inner,ignore,condition,current,pattern,until,condition,false,final,iterative,condition,t,take,condition,extend,with,until,condition,get,take,condition,current,pattern,until,condition,true,if,current,pattern,get,quantifier,has,property,quantifier,quantifier,property,greedy,times,get,from,times,get,to,if,until,condition,null,state,t,sink,state,copy,copy,sink,state,original,state,map,put,sink,state,get,name,sink,state,copy,update,with,greedy,condition,sink,state,take,condition,for,int,i,times,get,from,i,times,get,to,i,last,sink,create,singleton,state,last,sink,proceed,state,take,condition,inner,ignore,condition,true,add,stop,state,to,looping,last,sink,for,int,i,0,i,times,get,from,1,i,last,sink,create,singleton,state,last,sink,null,take,condition,inner,ignore,condition,false,add,stop,state,to,looping,last,sink,set,current,group,pattern,first,of,loop,true,return,create,singleton,state,last,sink,proceed,state,take,condition,get,ignore,condition,current,pattern,current,pattern,get,quantifier,has,property,quantifier,quantifier,property,optional
NFACompiler -> NFAFactoryCompiler -> @SuppressWarnings("unchecked") 		private State<T> createTimesState(final State<T> sinkState, final State<T> proceedState, Times times);1528989005;Creates a "complex" state consisting of given number of states with_same {@link IterativeCondition}.__@param sinkState the state that the created state should point to_@param proceedState state that the state being converted should proceed to_@param times     number of times the state should be copied_@return the first state of the "complex" state, next state should point to it;@SuppressWarnings("unchecked")_		private State<T> createTimesState(final State<T> sinkState, final State<T> proceedState, Times times) {_			State<T> lastSink = sinkState__			setCurrentGroupPatternFirstOfLoop(false)__			final IterativeCondition<T> untilCondition = (IterativeCondition<T>) currentPattern.getUntilCondition()__			final IterativeCondition<T> innerIgnoreCondition = extendWithUntilCondition(_				getInnerIgnoreCondition(currentPattern),_				untilCondition,_				false)__			final IterativeCondition<T> takeCondition = extendWithUntilCondition(_				getTakeCondition(currentPattern),_				untilCondition,_				true)___			if (currentPattern.getQuantifier().hasProperty(Quantifier.QuantifierProperty.GREEDY) &&_				times.getFrom() != times.getTo()) {_				if (untilCondition != null) {_					State<T> sinkStateCopy = copy(sinkState)__					originalStateMap.put(sinkState.getName(), sinkStateCopy)__				}_				updateWithGreedyCondition(sinkState, takeCondition)__			}__			for (int i = times.getFrom()_ i < times.getTo()_ i++) {_				lastSink = createSingletonState(lastSink, proceedState, takeCondition, innerIgnoreCondition, true)__				addStopStateToLooping(lastSink)__			}_			for (int i = 0_ i < times.getFrom() - 1_ i++) {_				lastSink = createSingletonState(lastSink, null, takeCondition, innerIgnoreCondition, false)__				addStopStateToLooping(lastSink)__			}_			_			setCurrentGroupPatternFirstOfLoop(true)__			return createSingletonState(_				lastSink,_				proceedState,_				takeCondition,_				getIgnoreCondition(currentPattern),_				currentPattern.getQuantifier().hasProperty(Quantifier.QuantifierProperty.OPTIONAL))__		};creates,a,complex,state,consisting,of,given,number,of,states,with,same,link,iterative,condition,param,sink,state,the,state,that,the,created,state,should,point,to,param,proceed,state,state,that,the,state,being,converted,should,proceed,to,param,times,number,of,times,the,state,should,be,copied,return,the,first,state,of,the,complex,state,next,state,should,point,to,it;suppress,warnings,unchecked,private,state,t,create,times,state,final,state,t,sink,state,final,state,t,proceed,state,times,times,state,t,last,sink,sink,state,set,current,group,pattern,first,of,loop,false,final,iterative,condition,t,until,condition,iterative,condition,t,current,pattern,get,until,condition,final,iterative,condition,t,inner,ignore,condition,extend,with,until,condition,get,inner,ignore,condition,current,pattern,until,condition,false,final,iterative,condition,t,take,condition,extend,with,until,condition,get,take,condition,current,pattern,until,condition,true,if,current,pattern,get,quantifier,has,property,quantifier,quantifier,property,greedy,times,get,from,times,get,to,if,until,condition,null,state,t,sink,state,copy,copy,sink,state,original,state,map,put,sink,state,get,name,sink,state,copy,update,with,greedy,condition,sink,state,take,condition,for,int,i,times,get,from,i,times,get,to,i,last,sink,create,singleton,state,last,sink,proceed,state,take,condition,inner,ignore,condition,true,add,stop,state,to,looping,last,sink,for,int,i,0,i,times,get,from,1,i,last,sink,create,singleton,state,last,sink,null,take,condition,inner,ignore,condition,false,add,stop,state,to,looping,last,sink,set,current,group,pattern,first,of,loop,true,return,create,singleton,state,last,sink,proceed,state,take,condition,get,ignore,condition,current,pattern,current,pattern,get,quantifier,has,property,quantifier,quantifier,property,optional
NFACompiler -> NFAFactoryCompiler -> @SuppressWarnings("unchecked") 		private State<T> createTimesState(final State<T> sinkState, final State<T> proceedState, Times times);1538745898;Creates a "complex" state consisting of given number of states with_same {@link IterativeCondition}.__@param sinkState the state that the created state should point to_@param proceedState state that the state being converted should proceed to_@param times     number of times the state should be copied_@return the first state of the "complex" state, next state should point to it;@SuppressWarnings("unchecked")_		private State<T> createTimesState(final State<T> sinkState, final State<T> proceedState, Times times) {_			State<T> lastSink = sinkState__			setCurrentGroupPatternFirstOfLoop(false)__			final IterativeCondition<T> untilCondition = (IterativeCondition<T>) currentPattern.getUntilCondition()__			final IterativeCondition<T> innerIgnoreCondition = extendWithUntilCondition(_				getInnerIgnoreCondition(currentPattern),_				untilCondition,_				false)__			final IterativeCondition<T> takeCondition = extendWithUntilCondition(_				getTakeCondition(currentPattern),_				untilCondition,_				true)___			if (currentPattern.getQuantifier().hasProperty(Quantifier.QuantifierProperty.GREEDY) &&_				times.getFrom() != times.getTo()) {_				if (untilCondition != null) {_					State<T> sinkStateCopy = copy(sinkState)__					originalStateMap.put(sinkState.getName(), sinkStateCopy)__				}_				updateWithGreedyCondition(sinkState, takeCondition)__			}__			for (int i = times.getFrom()_ i < times.getTo()_ i++) {_				lastSink = createSingletonState(lastSink, proceedState, takeCondition, innerIgnoreCondition, true)__				addStopStateToLooping(lastSink)__			}_			for (int i = 0_ i < times.getFrom() - 1_ i++) {_				lastSink = createSingletonState(lastSink, null, takeCondition, innerIgnoreCondition, false)__				addStopStateToLooping(lastSink)__			}_			_			setCurrentGroupPatternFirstOfLoop(true)__			return createSingletonState(_				lastSink,_				proceedState,_				takeCondition,_				getIgnoreCondition(currentPattern),_				currentPattern.getQuantifier().hasProperty(Quantifier.QuantifierProperty.OPTIONAL))__		};creates,a,complex,state,consisting,of,given,number,of,states,with,same,link,iterative,condition,param,sink,state,the,state,that,the,created,state,should,point,to,param,proceed,state,state,that,the,state,being,converted,should,proceed,to,param,times,number,of,times,the,state,should,be,copied,return,the,first,state,of,the,complex,state,next,state,should,point,to,it;suppress,warnings,unchecked,private,state,t,create,times,state,final,state,t,sink,state,final,state,t,proceed,state,times,times,state,t,last,sink,sink,state,set,current,group,pattern,first,of,loop,false,final,iterative,condition,t,until,condition,iterative,condition,t,current,pattern,get,until,condition,final,iterative,condition,t,inner,ignore,condition,extend,with,until,condition,get,inner,ignore,condition,current,pattern,until,condition,false,final,iterative,condition,t,take,condition,extend,with,until,condition,get,take,condition,current,pattern,until,condition,true,if,current,pattern,get,quantifier,has,property,quantifier,quantifier,property,greedy,times,get,from,times,get,to,if,until,condition,null,state,t,sink,state,copy,copy,sink,state,original,state,map,put,sink,state,get,name,sink,state,copy,update,with,greedy,condition,sink,state,take,condition,for,int,i,times,get,from,i,times,get,to,i,last,sink,create,singleton,state,last,sink,proceed,state,take,condition,inner,ignore,condition,true,add,stop,state,to,looping,last,sink,for,int,i,0,i,times,get,from,1,i,last,sink,create,singleton,state,last,sink,null,take,condition,inner,ignore,condition,false,add,stop,state,to,looping,last,sink,set,current,group,pattern,first,of,loop,true,return,create,singleton,state,last,sink,proceed,state,take,condition,get,ignore,condition,current,pattern,current,pattern,get,quantifier,has,property,quantifier,quantifier,property,optional
NFACompiler -> NFAFactoryCompiler -> @SuppressWarnings("unchecked") 		private State<T> createTimesState(final State<T> sinkState, final State<T> proceedState, Times times);1542293931;Creates a "complex" state consisting of given number of states with_same {@link IterativeCondition}.__@param sinkState the state that the created state should point to_@param proceedState state that the state being converted should proceed to_@param times     number of times the state should be copied_@return the first state of the "complex" state, next state should point to it;@SuppressWarnings("unchecked")_		private State<T> createTimesState(final State<T> sinkState, final State<T> proceedState, Times times) {_			State<T> lastSink = sinkState__			setCurrentGroupPatternFirstOfLoop(false)__			final IterativeCondition<T> untilCondition = (IterativeCondition<T>) currentPattern.getUntilCondition()__			final IterativeCondition<T> innerIgnoreCondition = extendWithUntilCondition(_				getInnerIgnoreCondition(currentPattern),_				untilCondition,_				false)__			final IterativeCondition<T> takeCondition = extendWithUntilCondition(_				getTakeCondition(currentPattern),_				untilCondition,_				true)___			if (currentPattern.getQuantifier().hasProperty(Quantifier.QuantifierProperty.GREEDY) &&_				times.getFrom() != times.getTo()) {_				if (untilCondition != null) {_					State<T> sinkStateCopy = copy(sinkState)__					originalStateMap.put(sinkState.getName(), sinkStateCopy)__				}_				updateWithGreedyCondition(sinkState, takeCondition)__			}__			for (int i = times.getFrom()_ i < times.getTo()_ i++) {_				lastSink = createSingletonState(lastSink, proceedState, takeCondition, innerIgnoreCondition, true)__				addStopStateToLooping(lastSink)__			}_			for (int i = 0_ i < times.getFrom() - 1_ i++) {_				lastSink = createSingletonState(lastSink, null, takeCondition, innerIgnoreCondition, false)__				addStopStateToLooping(lastSink)__			}_			_			setCurrentGroupPatternFirstOfLoop(true)__			return createSingletonState(_				lastSink,_				proceedState,_				takeCondition,_				getIgnoreCondition(currentPattern),_				currentPattern.getQuantifier().hasProperty(Quantifier.QuantifierProperty.OPTIONAL))__		};creates,a,complex,state,consisting,of,given,number,of,states,with,same,link,iterative,condition,param,sink,state,the,state,that,the,created,state,should,point,to,param,proceed,state,state,that,the,state,being,converted,should,proceed,to,param,times,number,of,times,the,state,should,be,copied,return,the,first,state,of,the,complex,state,next,state,should,point,to,it;suppress,warnings,unchecked,private,state,t,create,times,state,final,state,t,sink,state,final,state,t,proceed,state,times,times,state,t,last,sink,sink,state,set,current,group,pattern,first,of,loop,false,final,iterative,condition,t,until,condition,iterative,condition,t,current,pattern,get,until,condition,final,iterative,condition,t,inner,ignore,condition,extend,with,until,condition,get,inner,ignore,condition,current,pattern,until,condition,false,final,iterative,condition,t,take,condition,extend,with,until,condition,get,take,condition,current,pattern,until,condition,true,if,current,pattern,get,quantifier,has,property,quantifier,quantifier,property,greedy,times,get,from,times,get,to,if,until,condition,null,state,t,sink,state,copy,copy,sink,state,original,state,map,put,sink,state,get,name,sink,state,copy,update,with,greedy,condition,sink,state,take,condition,for,int,i,times,get,from,i,times,get,to,i,last,sink,create,singleton,state,last,sink,proceed,state,take,condition,inner,ignore,condition,true,add,stop,state,to,looping,last,sink,for,int,i,0,i,times,get,from,1,i,last,sink,create,singleton,state,last,sink,null,take,condition,inner,ignore,condition,false,add,stop,state,to,looping,last,sink,set,current,group,pattern,first,of,loop,true,return,create,singleton,state,last,sink,proceed,state,take,condition,get,ignore,condition,current,pattern,current,pattern,get,quantifier,has,property,quantifier,quantifier,property,optional
NFACompiler -> NFAFactoryCompiler -> private boolean isPatternOptional(Pattern<T, ?> pattern);1498034481;Checks if the given pattern is optional. If the given pattern is the head of a group pattern,_the optional status depends on the group pattern.;private boolean isPatternOptional(Pattern<T, ?> pattern) {_			if (headOfGroup(pattern)) {_				return isCurrentGroupPatternFirstOfLoop() &&_					currentGroupPattern.getQuantifier().hasProperty(Quantifier.QuantifierProperty.OPTIONAL)__			} else {_				return pattern.getQuantifier().hasProperty(Quantifier.QuantifierProperty.OPTIONAL)__			}_		};checks,if,the,given,pattern,is,optional,if,the,given,pattern,is,the,head,of,a,group,pattern,the,optional,status,depends,on,the,group,pattern;private,boolean,is,pattern,optional,pattern,t,pattern,if,head,of,group,pattern,return,is,current,group,pattern,first,of,loop,current,group,pattern,get,quantifier,has,property,quantifier,quantifier,property,optional,else,return,pattern,get,quantifier,has,property,quantifier,quantifier,property,optional
NFACompiler -> NFAFactoryCompiler -> private boolean isPatternOptional(Pattern<T, ?> pattern);1499760222;Checks if the given pattern is optional. If the given pattern is the head of a group pattern,_the optional status depends on the group pattern.;private boolean isPatternOptional(Pattern<T, ?> pattern) {_			if (headOfGroup(pattern)) {_				return isCurrentGroupPatternFirstOfLoop() &&_					currentGroupPattern.getQuantifier().hasProperty(Quantifier.QuantifierProperty.OPTIONAL)__			} else {_				return pattern.getQuantifier().hasProperty(Quantifier.QuantifierProperty.OPTIONAL)__			}_		};checks,if,the,given,pattern,is,optional,if,the,given,pattern,is,the,head,of,a,group,pattern,the,optional,status,depends,on,the,group,pattern;private,boolean,is,pattern,optional,pattern,t,pattern,if,head,of,group,pattern,return,is,current,group,pattern,first,of,loop,current,group,pattern,get,quantifier,has,property,quantifier,quantifier,property,optional,else,return,pattern,get,quantifier,has,property,quantifier,quantifier,property,optional
NFACompiler -> NFAFactoryCompiler -> private boolean isPatternOptional(Pattern<T, ?> pattern);1499937690;Checks if the given pattern is optional. If the given pattern is the head of a group pattern,_the optional status depends on the group pattern.;private boolean isPatternOptional(Pattern<T, ?> pattern) {_			if (headOfGroup(pattern)) {_				return isCurrentGroupPatternFirstOfLoop() &&_					currentGroupPattern.getQuantifier().hasProperty(Quantifier.QuantifierProperty.OPTIONAL)__			} else {_				return pattern.getQuantifier().hasProperty(Quantifier.QuantifierProperty.OPTIONAL)__			}_		};checks,if,the,given,pattern,is,optional,if,the,given,pattern,is,the,head,of,a,group,pattern,the,optional,status,depends,on,the,group,pattern;private,boolean,is,pattern,optional,pattern,t,pattern,if,head,of,group,pattern,return,is,current,group,pattern,first,of,loop,current,group,pattern,get,quantifier,has,property,quantifier,quantifier,property,optional,else,return,pattern,get,quantifier,has,property,quantifier,quantifier,property,optional
NFACompiler -> NFAFactoryCompiler -> private boolean isPatternOptional(Pattern<T, ?> pattern);1500021711;Checks if the given pattern is optional. If the given pattern is the head of a group pattern,_the optional status depends on the group pattern.;private boolean isPatternOptional(Pattern<T, ?> pattern) {_			if (headOfGroup(pattern)) {_				return isCurrentGroupPatternFirstOfLoop() &&_					currentGroupPattern.getQuantifier().hasProperty(Quantifier.QuantifierProperty.OPTIONAL)__			} else {_				return pattern.getQuantifier().hasProperty(Quantifier.QuantifierProperty.OPTIONAL)__			}_		};checks,if,the,given,pattern,is,optional,if,the,given,pattern,is,the,head,of,a,group,pattern,the,optional,status,depends,on,the,group,pattern;private,boolean,is,pattern,optional,pattern,t,pattern,if,head,of,group,pattern,return,is,current,group,pattern,first,of,loop,current,group,pattern,get,quantifier,has,property,quantifier,quantifier,property,optional,else,return,pattern,get,quantifier,has,property,quantifier,quantifier,property,optional
NFACompiler -> NFAFactoryCompiler -> private boolean isPatternOptional(Pattern<T, ?> pattern);1501592283;Checks if the given pattern is optional. If the given pattern is the head of a group pattern,_the optional status depends on the group pattern.;private boolean isPatternOptional(Pattern<T, ?> pattern) {_			if (headOfGroup(pattern)) {_				return isCurrentGroupPatternFirstOfLoop() &&_					currentGroupPattern.getQuantifier().hasProperty(Quantifier.QuantifierProperty.OPTIONAL)__			} else {_				return pattern.getQuantifier().hasProperty(Quantifier.QuantifierProperty.OPTIONAL)__			}_		};checks,if,the,given,pattern,is,optional,if,the,given,pattern,is,the,head,of,a,group,pattern,the,optional,status,depends,on,the,group,pattern;private,boolean,is,pattern,optional,pattern,t,pattern,if,head,of,group,pattern,return,is,current,group,pattern,first,of,loop,current,group,pattern,get,quantifier,has,property,quantifier,quantifier,property,optional,else,return,pattern,get,quantifier,has,property,quantifier,quantifier,property,optional
NFACompiler -> NFAFactoryCompiler -> private boolean isPatternOptional(Pattern<T, ?> pattern);1502422141;Checks if the given pattern is optional. If the given pattern is the head of a group pattern,_the optional status depends on the group pattern.;private boolean isPatternOptional(Pattern<T, ?> pattern) {_			if (headOfGroup(pattern)) {_				return isCurrentGroupPatternFirstOfLoop() &&_					currentGroupPattern.getQuantifier().hasProperty(Quantifier.QuantifierProperty.OPTIONAL)__			} else {_				return pattern.getQuantifier().hasProperty(Quantifier.QuantifierProperty.OPTIONAL)__			}_		};checks,if,the,given,pattern,is,optional,if,the,given,pattern,is,the,head,of,a,group,pattern,the,optional,status,depends,on,the,group,pattern;private,boolean,is,pattern,optional,pattern,t,pattern,if,head,of,group,pattern,return,is,current,group,pattern,first,of,loop,current,group,pattern,get,quantifier,has,property,quantifier,quantifier,property,optional,else,return,pattern,get,quantifier,has,property,quantifier,quantifier,property,optional
NFACompiler -> NFAFactoryCompiler -> private boolean isPatternOptional(Pattern<T, ?> pattern);1503588494;Checks if the given pattern is optional. If the given pattern is the head of a group pattern,_the optional status depends on the group pattern.;private boolean isPatternOptional(Pattern<T, ?> pattern) {_			if (headOfGroup(pattern)) {_				return isCurrentGroupPatternFirstOfLoop() &&_					currentGroupPattern.getQuantifier().hasProperty(Quantifier.QuantifierProperty.OPTIONAL)__			} else {_				return pattern.getQuantifier().hasProperty(Quantifier.QuantifierProperty.OPTIONAL)__			}_		};checks,if,the,given,pattern,is,optional,if,the,given,pattern,is,the,head,of,a,group,pattern,the,optional,status,depends,on,the,group,pattern;private,boolean,is,pattern,optional,pattern,t,pattern,if,head,of,group,pattern,return,is,current,group,pattern,first,of,loop,current,group,pattern,get,quantifier,has,property,quantifier,quantifier,property,optional,else,return,pattern,get,quantifier,has,property,quantifier,quantifier,property,optional
NFACompiler -> NFAFactoryCompiler -> private boolean isPatternOptional(Pattern<T, ?> pattern);1518008111;Checks if the given pattern is optional. If the given pattern is the head of a group pattern,_the optional status depends on the group pattern.;private boolean isPatternOptional(Pattern<T, ?> pattern) {_			if (headOfGroup(pattern)) {_				return isCurrentGroupPatternFirstOfLoop() &&_					currentGroupPattern.getQuantifier().hasProperty(Quantifier.QuantifierProperty.OPTIONAL)__			} else {_				return pattern.getQuantifier().hasProperty(Quantifier.QuantifierProperty.OPTIONAL)__			}_		};checks,if,the,given,pattern,is,optional,if,the,given,pattern,is,the,head,of,a,group,pattern,the,optional,status,depends,on,the,group,pattern;private,boolean,is,pattern,optional,pattern,t,pattern,if,head,of,group,pattern,return,is,current,group,pattern,first,of,loop,current,group,pattern,get,quantifier,has,property,quantifier,quantifier,property,optional,else,return,pattern,get,quantifier,has,property,quantifier,quantifier,property,optional
NFACompiler -> NFAFactoryCompiler -> private boolean isPatternOptional(Pattern<T, ?> pattern);1527863170;Checks if the given pattern is optional. If the given pattern is the head of a group pattern,_the optional status depends on the group pattern.;private boolean isPatternOptional(Pattern<T, ?> pattern) {_			if (headOfGroup(pattern)) {_				return isCurrentGroupPatternFirstOfLoop() &&_					currentGroupPattern.getQuantifier().hasProperty(Quantifier.QuantifierProperty.OPTIONAL)__			} else {_				return pattern.getQuantifier().hasProperty(Quantifier.QuantifierProperty.OPTIONAL)__			}_		};checks,if,the,given,pattern,is,optional,if,the,given,pattern,is,the,head,of,a,group,pattern,the,optional,status,depends,on,the,group,pattern;private,boolean,is,pattern,optional,pattern,t,pattern,if,head,of,group,pattern,return,is,current,group,pattern,first,of,loop,current,group,pattern,get,quantifier,has,property,quantifier,quantifier,property,optional,else,return,pattern,get,quantifier,has,property,quantifier,quantifier,property,optional
NFACompiler -> NFAFactoryCompiler -> private boolean isPatternOptional(Pattern<T, ?> pattern);1528989005;Checks if the given pattern is optional. If the given pattern is the head of a group pattern,_the optional status depends on the group pattern.;private boolean isPatternOptional(Pattern<T, ?> pattern) {_			if (headOfGroup(pattern)) {_				return isCurrentGroupPatternFirstOfLoop() &&_					currentGroupPattern.getQuantifier().hasProperty(Quantifier.QuantifierProperty.OPTIONAL)__			} else {_				return pattern.getQuantifier().hasProperty(Quantifier.QuantifierProperty.OPTIONAL)__			}_		};checks,if,the,given,pattern,is,optional,if,the,given,pattern,is,the,head,of,a,group,pattern,the,optional,status,depends,on,the,group,pattern;private,boolean,is,pattern,optional,pattern,t,pattern,if,head,of,group,pattern,return,is,current,group,pattern,first,of,loop,current,group,pattern,get,quantifier,has,property,quantifier,quantifier,property,optional,else,return,pattern,get,quantifier,has,property,quantifier,quantifier,property,optional
NFACompiler -> NFAFactoryCompiler -> private boolean isPatternOptional(Pattern<T, ?> pattern);1538745898;Checks if the given pattern is optional. If the given pattern is the head of a group pattern,_the optional status depends on the group pattern.;private boolean isPatternOptional(Pattern<T, ?> pattern) {_			if (headOfGroup(pattern)) {_				return isCurrentGroupPatternFirstOfLoop() &&_					currentGroupPattern.getQuantifier().hasProperty(Quantifier.QuantifierProperty.OPTIONAL)__			} else {_				return pattern.getQuantifier().hasProperty(Quantifier.QuantifierProperty.OPTIONAL)__			}_		};checks,if,the,given,pattern,is,optional,if,the,given,pattern,is,the,head,of,a,group,pattern,the,optional,status,depends,on,the,group,pattern;private,boolean,is,pattern,optional,pattern,t,pattern,if,head,of,group,pattern,return,is,current,group,pattern,first,of,loop,current,group,pattern,get,quantifier,has,property,quantifier,quantifier,property,optional,else,return,pattern,get,quantifier,has,property,quantifier,quantifier,property,optional
NFACompiler -> NFAFactoryCompiler -> private boolean isPatternOptional(Pattern<T, ?> pattern);1542293931;Checks if the given pattern is optional. If the given pattern is the head of a group pattern,_the optional status depends on the group pattern.;private boolean isPatternOptional(Pattern<T, ?> pattern) {_			if (headOfGroup(pattern)) {_				return isCurrentGroupPatternFirstOfLoop() &&_					currentGroupPattern.getQuantifier().hasProperty(Quantifier.QuantifierProperty.OPTIONAL)__			} else {_				return pattern.getQuantifier().hasProperty(Quantifier.QuantifierProperty.OPTIONAL)__			}_		};checks,if,the,given,pattern,is,optional,if,the,given,pattern,is,the,head,of,a,group,pattern,the,optional,status,depends,on,the,group,pattern;private,boolean,is,pattern,optional,pattern,t,pattern,if,head,of,group,pattern,return,is,current,group,pattern,first,of,loop,current,group,pattern,get,quantifier,has,property,quantifier,quantifier,property,optional,else,return,pattern,get,quantifier,has,property,quantifier,quantifier,property,optional
NFACompiler -> NFAFactoryCompiler -> @SuppressWarnings("unchecked") 		private State<T> createFirstMandatoryStateOfLoop(final State<T> sinkState, final State.StateType stateType);1489866780;Patterns with quantifiers AT_LEAST_ONE_* are converted into pair of states: a singleton state and_looping state. This method creates the first of the two.__@param sinkState the state the newly created state should point to, it should be a looping state_@param stateType the type of the created state, as the NFA graph can also start wit AT_LEAST_ONE_*_@return the newly created state;@SuppressWarnings("unchecked")_		private State<T> createFirstMandatoryStateOfLoop(final State<T> sinkState, final State.StateType stateType) {__			final FilterFunction<T> currentFilterFunction = (FilterFunction<T>) currentPattern.getFilterFunction()__			final State<T> firstState = new State<>(currentPattern.getName(), stateType)___			firstState.addTake(sinkState, currentFilterFunction)__			if (currentPattern instanceof FollowedByPattern) {_				if (currentPattern.getQuantifier().hasProperty(QuantifierProperty.EAGER)) {_					firstState.addIgnore(new NotFilterFunction<>(currentFilterFunction))__				} else {_					firstState.addIgnore(FilterFunctions.<T>trueFunction())__				}_			}_			return firstState__		};patterns,with,quantifiers,are,converted,into,pair,of,states,a,singleton,state,and,looping,state,this,method,creates,the,first,of,the,two,param,sink,state,the,state,the,newly,created,state,should,point,to,it,should,be,a,looping,state,param,state,type,the,type,of,the,created,state,as,the,nfa,graph,can,also,start,wit,return,the,newly,created,state;suppress,warnings,unchecked,private,state,t,create,first,mandatory,state,of,loop,final,state,t,sink,state,final,state,state,type,state,type,final,filter,function,t,current,filter,function,filter,function,t,current,pattern,get,filter,function,final,state,t,first,state,new,state,current,pattern,get,name,state,type,first,state,add,take,sink,state,current,filter,function,if,current,pattern,instanceof,followed,by,pattern,if,current,pattern,get,quantifier,has,property,quantifier,property,eager,first,state,add,ignore,new,not,filter,function,current,filter,function,else,first,state,add,ignore,filter,functions,t,true,function,return,first,state
NFACompiler -> NFAFactoryCompiler -> @SuppressWarnings("unchecked") 		private State<T> createFirstMandatoryStateOfLoop(final State<T> sinkState, final State.StateType stateType);1490089987;Patterns with quantifiers AT_LEAST_ONE_* are converted into pair of states: a singleton state and_looping state. This method creates the first of the two.__@param sinkState the state the newly created state should point to, it should be a looping state_@param stateType the type of the created state, as the NFA graph can also start wit AT_LEAST_ONE_*_@return the newly created state;@SuppressWarnings("unchecked")_		private State<T> createFirstMandatoryStateOfLoop(final State<T> sinkState, final State.StateType stateType) {__			final FilterFunction<T> currentFilterFunction = (FilterFunction<T>) currentPattern.getFilterFunction()__			final State<T> firstState = new State<>(currentPattern.getName(), stateType)___			firstState.addTake(sinkState, currentFilterFunction)__			if (currentPattern instanceof FollowedByPattern) {_				if (currentPattern.getQuantifier().hasProperty(QuantifierProperty.EAGER)) {_					firstState.addIgnore(new NotFilterFunction<>(currentFilterFunction))__				} else {_					firstState.addIgnore(FilterFunctions.<T>trueFunction())__				}_			}_			return firstState__		};patterns,with,quantifiers,are,converted,into,pair,of,states,a,singleton,state,and,looping,state,this,method,creates,the,first,of,the,two,param,sink,state,the,state,the,newly,created,state,should,point,to,it,should,be,a,looping,state,param,state,type,the,type,of,the,created,state,as,the,nfa,graph,can,also,start,wit,return,the,newly,created,state;suppress,warnings,unchecked,private,state,t,create,first,mandatory,state,of,loop,final,state,t,sink,state,final,state,state,type,state,type,final,filter,function,t,current,filter,function,filter,function,t,current,pattern,get,filter,function,final,state,t,first,state,new,state,current,pattern,get,name,state,type,first,state,add,take,sink,state,current,filter,function,if,current,pattern,instanceof,followed,by,pattern,if,current,pattern,get,quantifier,has,property,quantifier,property,eager,first,state,add,ignore,new,not,filter,function,current,filter,function,else,first,state,add,ignore,filter,functions,t,true,function,return,first,state
NFACompiler -> NFAFactoryCompiler -> @SuppressWarnings("unchecked") 		private State<T> createFirstMandatoryStateOfLoop(final State<T> sinkState, final State.StateType stateType);1490194327;Patterns with quantifiers AT_LEAST_ONE_* are converted into pair of states: a singleton state and_looping state. This method creates the first of the two.__@param sinkState the state the newly created state should point to, it should be a looping state_@param stateType the type of the created state, as the NFA graph can also start wit AT_LEAST_ONE_*_@return the newly created state;@SuppressWarnings("unchecked")_		private State<T> createFirstMandatoryStateOfLoop(final State<T> sinkState, final State.StateType stateType) {__			final IterativeCondition<T> currentFilterFunction = (IterativeCondition<T>) currentPattern.getCondition()__			final State<T> firstState = new State<>(currentPattern.getName(), stateType)___			firstState.addTake(sinkState, currentFilterFunction)__			if (currentPattern instanceof FollowedByPattern) {_				final IterativeCondition<T> ignoreCondition = getIgnoreCondition(currentPattern)__				firstState.addIgnore(ignoreCondition)__			}_			return firstState__		};patterns,with,quantifiers,are,converted,into,pair,of,states,a,singleton,state,and,looping,state,this,method,creates,the,first,of,the,two,param,sink,state,the,state,the,newly,created,state,should,point,to,it,should,be,a,looping,state,param,state,type,the,type,of,the,created,state,as,the,nfa,graph,can,also,start,wit,return,the,newly,created,state;suppress,warnings,unchecked,private,state,t,create,first,mandatory,state,of,loop,final,state,t,sink,state,final,state,state,type,state,type,final,iterative,condition,t,current,filter,function,iterative,condition,t,current,pattern,get,condition,final,state,t,first,state,new,state,current,pattern,get,name,state,type,first,state,add,take,sink,state,current,filter,function,if,current,pattern,instanceof,followed,by,pattern,final,iterative,condition,t,ignore,condition,get,ignore,condition,current,pattern,first,state,add,ignore,ignore,condition,return,first,state
NFACompiler -> NFAFactoryCompiler -> @SuppressWarnings("unchecked") 		private IterativeCondition<T> getInnerIgnoreCondition(Pattern<T, ?> pattern);1493200673;@return The {@link IterativeCondition condition} for the {@code IGNORE} edge_that corresponds to the specified {@link Pattern}. It is applicable only for inner states of a complex_state like looping or times.;@SuppressWarnings("unchecked")_		private IterativeCondition<T> getInnerIgnoreCondition(Pattern<T, ?> pattern) {_			switch (pattern.getQuantifier().getInnerConsumingStrategy()) {_				case STRICT:_					return null__				case SKIP_TILL_NEXT:_					return new NotCondition<>((IterativeCondition<T>) pattern.getCondition())__				case SKIP_TILL_ANY:_					return BooleanConditions.trueFunction()__			}_			return null__		};return,the,link,iterative,condition,condition,for,the,code,ignore,edge,that,corresponds,to,the,specified,link,pattern,it,is,applicable,only,for,inner,states,of,a,complex,state,like,looping,or,times;suppress,warnings,unchecked,private,iterative,condition,t,get,inner,ignore,condition,pattern,t,pattern,switch,pattern,get,quantifier,get,inner,consuming,strategy,case,strict,return,null,case,return,new,not,condition,iterative,condition,t,pattern,get,condition,case,return,boolean,conditions,true,function,return,null
NFACompiler -> NFAFactoryCompiler -> @SuppressWarnings("unchecked") 		private IterativeCondition<T> getInnerIgnoreCondition(Pattern<T, ?> pattern);1493385877;@return The {@link IterativeCondition condition} for the {@code IGNORE} edge_that corresponds to the specified {@link Pattern}. It is applicable only for inner states of a complex_state like looping or times.;@SuppressWarnings("unchecked")_		private IterativeCondition<T> getInnerIgnoreCondition(Pattern<T, ?> pattern) {_			switch (pattern.getQuantifier().getInnerConsumingStrategy()) {_				case STRICT:_					return null__				case SKIP_TILL_NEXT:_					return new NotCondition<>((IterativeCondition<T>) pattern.getCondition())__				case SKIP_TILL_ANY:_					return BooleanConditions.trueFunction()__			}_			return null__		};return,the,link,iterative,condition,condition,for,the,code,ignore,edge,that,corresponds,to,the,specified,link,pattern,it,is,applicable,only,for,inner,states,of,a,complex,state,like,looping,or,times;suppress,warnings,unchecked,private,iterative,condition,t,get,inner,ignore,condition,pattern,t,pattern,switch,pattern,get,quantifier,get,inner,consuming,strategy,case,strict,return,null,case,return,new,not,condition,iterative,condition,t,pattern,get,condition,case,return,boolean,conditions,true,function,return,null
NFACompiler -> NFAFactoryCompiler -> @SuppressWarnings("unchecked") 		private IterativeCondition<T> getInnerIgnoreCondition(Pattern<T, ?> pattern);1494947249;@return The {@link IterativeCondition condition} for the {@code IGNORE} edge_that corresponds to the specified {@link Pattern}. It is applicable only for inner states of a complex_state like looping or times.;@SuppressWarnings("unchecked")_		private IterativeCondition<T> getInnerIgnoreCondition(Pattern<T, ?> pattern) {_			switch (pattern.getQuantifier().getInnerConsumingStrategy()) {_				case STRICT:_					return null__				case SKIP_TILL_NEXT:_					return new NotCondition<>((IterativeCondition<T>) pattern.getCondition())__				case SKIP_TILL_ANY:_					return BooleanConditions.trueFunction()__			}_			return null__		};return,the,link,iterative,condition,condition,for,the,code,ignore,edge,that,corresponds,to,the,specified,link,pattern,it,is,applicable,only,for,inner,states,of,a,complex,state,like,looping,or,times;suppress,warnings,unchecked,private,iterative,condition,t,get,inner,ignore,condition,pattern,t,pattern,switch,pattern,get,quantifier,get,inner,consuming,strategy,case,strict,return,null,case,return,new,not,condition,iterative,condition,t,pattern,get,condition,case,return,boolean,conditions,true,function,return,null
NFACompiler -> NFAFactoryCompiler -> @SuppressWarnings("unchecked") 		private IterativeCondition<T> getInnerIgnoreCondition(Pattern<T, ?> pattern);1495657626;@return The {@link IterativeCondition condition} for the {@code IGNORE} edge_that corresponds to the specified {@link Pattern}. It is applicable only for inner states of a complex_state like looping or times.;@SuppressWarnings("unchecked")_		private IterativeCondition<T> getInnerIgnoreCondition(Pattern<T, ?> pattern) {_			switch (pattern.getQuantifier().getInnerConsumingStrategy()) {_				case STRICT:_					return null__				case SKIP_TILL_NEXT:_					return new NotCondition<>((IterativeCondition<T>) pattern.getCondition())__				case SKIP_TILL_ANY:_					return BooleanConditions.trueFunction()__			}_			return null__		};return,the,link,iterative,condition,condition,for,the,code,ignore,edge,that,corresponds,to,the,specified,link,pattern,it,is,applicable,only,for,inner,states,of,a,complex,state,like,looping,or,times;suppress,warnings,unchecked,private,iterative,condition,t,get,inner,ignore,condition,pattern,t,pattern,switch,pattern,get,quantifier,get,inner,consuming,strategy,case,strict,return,null,case,return,new,not,condition,iterative,condition,t,pattern,get,condition,case,return,boolean,conditions,true,function,return,null
NFACompiler -> NFAFactoryCompiler -> @SuppressWarnings("unchecked") 		private IterativeCondition<T> getInnerIgnoreCondition(Pattern<T, ?> pattern);1496245714;@return The {@link IterativeCondition condition} for the {@code IGNORE} edge_that corresponds to the specified {@link Pattern}. It is applicable only for inner states of a complex_state like looping or times.;@SuppressWarnings("unchecked")_		private IterativeCondition<T> getInnerIgnoreCondition(Pattern<T, ?> pattern) {_			switch (pattern.getQuantifier().getInnerConsumingStrategy()) {_				case STRICT:_					return null__				case SKIP_TILL_NEXT:_					return new NotCondition<>((IterativeCondition<T>) pattern.getCondition())__				case SKIP_TILL_ANY:_					return BooleanConditions.trueFunction()__			}_			return null__		};return,the,link,iterative,condition,condition,for,the,code,ignore,edge,that,corresponds,to,the,specified,link,pattern,it,is,applicable,only,for,inner,states,of,a,complex,state,like,looping,or,times;suppress,warnings,unchecked,private,iterative,condition,t,get,inner,ignore,condition,pattern,t,pattern,switch,pattern,get,quantifier,get,inner,consuming,strategy,case,strict,return,null,case,return,new,not,condition,iterative,condition,t,pattern,get,condition,case,return,boolean,conditions,true,function,return,null
NFACompiler -> NFAFactoryCompiler -> @SuppressWarnings("unchecked") 		private IterativeCondition<T> getInnerIgnoreCondition(Pattern<T, ?> pattern);1497410381;@return The {@link IterativeCondition condition} for the {@code IGNORE} edge_that corresponds to the specified {@link Pattern}. It is applicable only for inner states of a complex_state like looping or times.;@SuppressWarnings("unchecked")_		private IterativeCondition<T> getInnerIgnoreCondition(Pattern<T, ?> pattern) {_			switch (pattern.getQuantifier().getInnerConsumingStrategy()) {_				case STRICT:_					return null__				case SKIP_TILL_NEXT:_					return new NotCondition<>((IterativeCondition<T>) pattern.getCondition())__				case SKIP_TILL_ANY:_					return BooleanConditions.trueFunction()__			}_			return null__		};return,the,link,iterative,condition,condition,for,the,code,ignore,edge,that,corresponds,to,the,specified,link,pattern,it,is,applicable,only,for,inner,states,of,a,complex,state,like,looping,or,times;suppress,warnings,unchecked,private,iterative,condition,t,get,inner,ignore,condition,pattern,t,pattern,switch,pattern,get,quantifier,get,inner,consuming,strategy,case,strict,return,null,case,return,new,not,condition,iterative,condition,t,pattern,get,condition,case,return,boolean,conditions,true,function,return,null
NFACompiler -> NFAFactoryCompiler -> @SuppressWarnings("unchecked") 		private IterativeCondition<T> getInnerIgnoreCondition(Pattern<T, ?> pattern);1497883202;@return The {@link IterativeCondition condition} for the {@code IGNORE} edge_that corresponds to the specified {@link Pattern}. It is applicable only for inner states of a complex_state like looping or times.;@SuppressWarnings("unchecked")_		private IterativeCondition<T> getInnerIgnoreCondition(Pattern<T, ?> pattern) {_			switch (pattern.getQuantifier().getInnerConsumingStrategy()) {_				case STRICT:_					return null__				case SKIP_TILL_NEXT:_					return new NotCondition<>((IterativeCondition<T>) pattern.getCondition())__				case SKIP_TILL_ANY:_					return BooleanConditions.trueFunction()__			}_			return null__		};return,the,link,iterative,condition,condition,for,the,code,ignore,edge,that,corresponds,to,the,specified,link,pattern,it,is,applicable,only,for,inner,states,of,a,complex,state,like,looping,or,times;suppress,warnings,unchecked,private,iterative,condition,t,get,inner,ignore,condition,pattern,t,pattern,switch,pattern,get,quantifier,get,inner,consuming,strategy,case,strict,return,null,case,return,new,not,condition,iterative,condition,t,pattern,get,condition,case,return,boolean,conditions,true,function,return,null
NFACompiler -> NFAFactoryCompiler -> @SuppressWarnings("unchecked") 		private IterativeCondition<T> getInnerIgnoreCondition(Pattern<T, ?> pattern);1498034481;@return The {@link IterativeCondition condition} for the {@code IGNORE} edge_that corresponds to the specified {@link Pattern} and extended with stop(until) condition_if necessary. It is applicable only for inner states of a complex state like looping or times.;@SuppressWarnings("unchecked")_		private IterativeCondition<T> getInnerIgnoreCondition(Pattern<T, ?> pattern) {_			Quantifier.ConsumingStrategy consumingStrategy = pattern.getQuantifier().getInnerConsumingStrategy()__			if (headOfGroup(pattern)) {_				_				_				consumingStrategy = currentGroupPattern.getQuantifier().getInnerConsumingStrategy()__			}__			IterativeCondition<T> innerIgnoreCondition = null__			switch (consumingStrategy) {_				case STRICT:_					innerIgnoreCondition = null__					break__				case SKIP_TILL_NEXT:_					innerIgnoreCondition = new NotCondition<>((IterativeCondition<T>) pattern.getCondition())__					break__				case SKIP_TILL_ANY:_					innerIgnoreCondition = BooleanConditions.trueFunction()__					break__			}__			if (currentGroupPattern != null && currentGroupPattern.getUntilCondition() != null) {_				innerIgnoreCondition = extendWithUntilCondition(_					innerIgnoreCondition,_					(IterativeCondition<T>) currentGroupPattern.getUntilCondition())__			}_			return innerIgnoreCondition__		};return,the,link,iterative,condition,condition,for,the,code,ignore,edge,that,corresponds,to,the,specified,link,pattern,and,extended,with,stop,until,condition,if,necessary,it,is,applicable,only,for,inner,states,of,a,complex,state,like,looping,or,times;suppress,warnings,unchecked,private,iterative,condition,t,get,inner,ignore,condition,pattern,t,pattern,quantifier,consuming,strategy,consuming,strategy,pattern,get,quantifier,get,inner,consuming,strategy,if,head,of,group,pattern,consuming,strategy,current,group,pattern,get,quantifier,get,inner,consuming,strategy,iterative,condition,t,inner,ignore,condition,null,switch,consuming,strategy,case,strict,inner,ignore,condition,null,break,case,inner,ignore,condition,new,not,condition,iterative,condition,t,pattern,get,condition,break,case,inner,ignore,condition,boolean,conditions,true,function,break,if,current,group,pattern,null,current,group,pattern,get,until,condition,null,inner,ignore,condition,extend,with,until,condition,inner,ignore,condition,iterative,condition,t,current,group,pattern,get,until,condition,return,inner,ignore,condition
NFACompiler -> NFAFactoryCompiler -> @SuppressWarnings("unchecked") 		private IterativeCondition<T> getInnerIgnoreCondition(Pattern<T, ?> pattern);1499760222;@return The {@link IterativeCondition condition} for the {@code IGNORE} edge_that corresponds to the specified {@link Pattern} and extended with stop(until) condition_if necessary. It is applicable only for inner states of a complex state like looping or times.;@SuppressWarnings("unchecked")_		private IterativeCondition<T> getInnerIgnoreCondition(Pattern<T, ?> pattern) {_			Quantifier.ConsumingStrategy consumingStrategy = pattern.getQuantifier().getInnerConsumingStrategy()__			if (headOfGroup(pattern)) {_				_				_				consumingStrategy = currentGroupPattern.getQuantifier().getInnerConsumingStrategy()__			}__			IterativeCondition<T> innerIgnoreCondition = null__			switch (consumingStrategy) {_				case STRICT:_					innerIgnoreCondition = null__					break__				case SKIP_TILL_NEXT:_					innerIgnoreCondition = new NotCondition<>((IterativeCondition<T>) pattern.getCondition())__					break__				case SKIP_TILL_ANY:_					innerIgnoreCondition = BooleanConditions.trueFunction()__					break__			}__			if (currentGroupPattern != null && currentGroupPattern.getUntilCondition() != null) {_				innerIgnoreCondition = extendWithUntilCondition(_					innerIgnoreCondition,_					(IterativeCondition<T>) currentGroupPattern.getUntilCondition(),_					false)__			}_			return innerIgnoreCondition__		};return,the,link,iterative,condition,condition,for,the,code,ignore,edge,that,corresponds,to,the,specified,link,pattern,and,extended,with,stop,until,condition,if,necessary,it,is,applicable,only,for,inner,states,of,a,complex,state,like,looping,or,times;suppress,warnings,unchecked,private,iterative,condition,t,get,inner,ignore,condition,pattern,t,pattern,quantifier,consuming,strategy,consuming,strategy,pattern,get,quantifier,get,inner,consuming,strategy,if,head,of,group,pattern,consuming,strategy,current,group,pattern,get,quantifier,get,inner,consuming,strategy,iterative,condition,t,inner,ignore,condition,null,switch,consuming,strategy,case,strict,inner,ignore,condition,null,break,case,inner,ignore,condition,new,not,condition,iterative,condition,t,pattern,get,condition,break,case,inner,ignore,condition,boolean,conditions,true,function,break,if,current,group,pattern,null,current,group,pattern,get,until,condition,null,inner,ignore,condition,extend,with,until,condition,inner,ignore,condition,iterative,condition,t,current,group,pattern,get,until,condition,false,return,inner,ignore,condition
NFACompiler -> NFAFactoryCompiler -> @SuppressWarnings("unchecked") 		private IterativeCondition<T> getInnerIgnoreCondition(Pattern<T, ?> pattern);1499937690;@return The {@link IterativeCondition condition} for the {@code IGNORE} edge_that corresponds to the specified {@link Pattern} and extended with stop(until) condition_if necessary. It is applicable only for inner states of a complex state like looping or times.;@SuppressWarnings("unchecked")_		private IterativeCondition<T> getInnerIgnoreCondition(Pattern<T, ?> pattern) {_			Quantifier.ConsumingStrategy consumingStrategy = pattern.getQuantifier().getInnerConsumingStrategy()__			if (headOfGroup(pattern)) {_				_				_				consumingStrategy = currentGroupPattern.getQuantifier().getInnerConsumingStrategy()__			}__			IterativeCondition<T> innerIgnoreCondition = null__			switch (consumingStrategy) {_				case STRICT:_					innerIgnoreCondition = null__					break__				case SKIP_TILL_NEXT:_					innerIgnoreCondition = new NotCondition<>((IterativeCondition<T>) pattern.getCondition())__					break__				case SKIP_TILL_ANY:_					innerIgnoreCondition = BooleanConditions.trueFunction()__					break__			}__			if (currentGroupPattern != null && currentGroupPattern.getUntilCondition() != null) {_				innerIgnoreCondition = extendWithUntilCondition(_					innerIgnoreCondition,_					(IterativeCondition<T>) currentGroupPattern.getUntilCondition(),_					false)__			}_			return innerIgnoreCondition__		};return,the,link,iterative,condition,condition,for,the,code,ignore,edge,that,corresponds,to,the,specified,link,pattern,and,extended,with,stop,until,condition,if,necessary,it,is,applicable,only,for,inner,states,of,a,complex,state,like,looping,or,times;suppress,warnings,unchecked,private,iterative,condition,t,get,inner,ignore,condition,pattern,t,pattern,quantifier,consuming,strategy,consuming,strategy,pattern,get,quantifier,get,inner,consuming,strategy,if,head,of,group,pattern,consuming,strategy,current,group,pattern,get,quantifier,get,inner,consuming,strategy,iterative,condition,t,inner,ignore,condition,null,switch,consuming,strategy,case,strict,inner,ignore,condition,null,break,case,inner,ignore,condition,new,not,condition,iterative,condition,t,pattern,get,condition,break,case,inner,ignore,condition,boolean,conditions,true,function,break,if,current,group,pattern,null,current,group,pattern,get,until,condition,null,inner,ignore,condition,extend,with,until,condition,inner,ignore,condition,iterative,condition,t,current,group,pattern,get,until,condition,false,return,inner,ignore,condition
NFACompiler -> NFAFactoryCompiler -> @SuppressWarnings("unchecked") 		private IterativeCondition<T> getInnerIgnoreCondition(Pattern<T, ?> pattern);1500021711;@return The {@link IterativeCondition condition} for the {@code IGNORE} edge_that corresponds to the specified {@link Pattern} and extended with stop(until) condition_if necessary. It is applicable only for inner states of a complex state like looping or times.;@SuppressWarnings("unchecked")_		private IterativeCondition<T> getInnerIgnoreCondition(Pattern<T, ?> pattern) {_			Quantifier.ConsumingStrategy consumingStrategy = pattern.getQuantifier().getInnerConsumingStrategy()__			if (headOfGroup(pattern)) {_				_				_				consumingStrategy = currentGroupPattern.getQuantifier().getInnerConsumingStrategy()__			}__			IterativeCondition<T> innerIgnoreCondition = null__			switch (consumingStrategy) {_				case STRICT:_					innerIgnoreCondition = null__					break__				case SKIP_TILL_NEXT:_					innerIgnoreCondition = new NotCondition<>((IterativeCondition<T>) pattern.getCondition())__					break__				case SKIP_TILL_ANY:_					innerIgnoreCondition = BooleanConditions.trueFunction()__					break__			}__			if (currentGroupPattern != null && currentGroupPattern.getUntilCondition() != null) {_				innerIgnoreCondition = extendWithUntilCondition(_					innerIgnoreCondition,_					(IterativeCondition<T>) currentGroupPattern.getUntilCondition(),_					false)__			}_			return innerIgnoreCondition__		};return,the,link,iterative,condition,condition,for,the,code,ignore,edge,that,corresponds,to,the,specified,link,pattern,and,extended,with,stop,until,condition,if,necessary,it,is,applicable,only,for,inner,states,of,a,complex,state,like,looping,or,times;suppress,warnings,unchecked,private,iterative,condition,t,get,inner,ignore,condition,pattern,t,pattern,quantifier,consuming,strategy,consuming,strategy,pattern,get,quantifier,get,inner,consuming,strategy,if,head,of,group,pattern,consuming,strategy,current,group,pattern,get,quantifier,get,inner,consuming,strategy,iterative,condition,t,inner,ignore,condition,null,switch,consuming,strategy,case,strict,inner,ignore,condition,null,break,case,inner,ignore,condition,new,not,condition,iterative,condition,t,pattern,get,condition,break,case,inner,ignore,condition,boolean,conditions,true,function,break,if,current,group,pattern,null,current,group,pattern,get,until,condition,null,inner,ignore,condition,extend,with,until,condition,inner,ignore,condition,iterative,condition,t,current,group,pattern,get,until,condition,false,return,inner,ignore,condition
NFACompiler -> NFAFactoryCompiler -> @SuppressWarnings("unchecked") 		private IterativeCondition<T> getInnerIgnoreCondition(Pattern<T, ?> pattern);1501592283;@return The {@link IterativeCondition condition} for the {@code IGNORE} edge_that corresponds to the specified {@link Pattern} and extended with stop(until) condition_if necessary. It is applicable only for inner states of a complex state like looping or times.;@SuppressWarnings("unchecked")_		private IterativeCondition<T> getInnerIgnoreCondition(Pattern<T, ?> pattern) {_			Quantifier.ConsumingStrategy consumingStrategy = pattern.getQuantifier().getInnerConsumingStrategy()__			if (headOfGroup(pattern)) {_				_				_				consumingStrategy = currentGroupPattern.getQuantifier().getInnerConsumingStrategy()__			}__			IterativeCondition<T> innerIgnoreCondition = null__			switch (consumingStrategy) {_				case STRICT:_					innerIgnoreCondition = null__					break__				case SKIP_TILL_NEXT:_					innerIgnoreCondition = new NotCondition<>((IterativeCondition<T>) pattern.getCondition())__					break__				case SKIP_TILL_ANY:_					innerIgnoreCondition = BooleanConditions.trueFunction()__					break__			}__			if (currentGroupPattern != null && currentGroupPattern.getUntilCondition() != null) {_				innerIgnoreCondition = extendWithUntilCondition(_					innerIgnoreCondition,_					(IterativeCondition<T>) currentGroupPattern.getUntilCondition(),_					false)__			}_			return innerIgnoreCondition__		};return,the,link,iterative,condition,condition,for,the,code,ignore,edge,that,corresponds,to,the,specified,link,pattern,and,extended,with,stop,until,condition,if,necessary,it,is,applicable,only,for,inner,states,of,a,complex,state,like,looping,or,times;suppress,warnings,unchecked,private,iterative,condition,t,get,inner,ignore,condition,pattern,t,pattern,quantifier,consuming,strategy,consuming,strategy,pattern,get,quantifier,get,inner,consuming,strategy,if,head,of,group,pattern,consuming,strategy,current,group,pattern,get,quantifier,get,inner,consuming,strategy,iterative,condition,t,inner,ignore,condition,null,switch,consuming,strategy,case,strict,inner,ignore,condition,null,break,case,inner,ignore,condition,new,not,condition,iterative,condition,t,pattern,get,condition,break,case,inner,ignore,condition,boolean,conditions,true,function,break,if,current,group,pattern,null,current,group,pattern,get,until,condition,null,inner,ignore,condition,extend,with,until,condition,inner,ignore,condition,iterative,condition,t,current,group,pattern,get,until,condition,false,return,inner,ignore,condition
NFACompiler -> NFAFactoryCompiler -> @SuppressWarnings("unchecked") 		private IterativeCondition<T> getInnerIgnoreCondition(Pattern<T, ?> pattern);1502422141;@return The {@link IterativeCondition condition} for the {@code IGNORE} edge_that corresponds to the specified {@link Pattern} and extended with stop(until) condition_if necessary. It is applicable only for inner states of a complex state like looping or times.;@SuppressWarnings("unchecked")_		private IterativeCondition<T> getInnerIgnoreCondition(Pattern<T, ?> pattern) {_			Quantifier.ConsumingStrategy consumingStrategy = pattern.getQuantifier().getInnerConsumingStrategy()__			if (headOfGroup(pattern)) {_				_				_				consumingStrategy = currentGroupPattern.getQuantifier().getInnerConsumingStrategy()__			}__			IterativeCondition<T> innerIgnoreCondition = null__			switch (consumingStrategy) {_				case STRICT:_					innerIgnoreCondition = null__					break__				case SKIP_TILL_NEXT:_					innerIgnoreCondition = new NotCondition<>((IterativeCondition<T>) pattern.getCondition())__					break__				case SKIP_TILL_ANY:_					innerIgnoreCondition = BooleanConditions.trueFunction()__					break__			}__			if (currentGroupPattern != null && currentGroupPattern.getUntilCondition() != null) {_				innerIgnoreCondition = extendWithUntilCondition(_					innerIgnoreCondition,_					(IterativeCondition<T>) currentGroupPattern.getUntilCondition(),_					false)__			}_			return innerIgnoreCondition__		};return,the,link,iterative,condition,condition,for,the,code,ignore,edge,that,corresponds,to,the,specified,link,pattern,and,extended,with,stop,until,condition,if,necessary,it,is,applicable,only,for,inner,states,of,a,complex,state,like,looping,or,times;suppress,warnings,unchecked,private,iterative,condition,t,get,inner,ignore,condition,pattern,t,pattern,quantifier,consuming,strategy,consuming,strategy,pattern,get,quantifier,get,inner,consuming,strategy,if,head,of,group,pattern,consuming,strategy,current,group,pattern,get,quantifier,get,inner,consuming,strategy,iterative,condition,t,inner,ignore,condition,null,switch,consuming,strategy,case,strict,inner,ignore,condition,null,break,case,inner,ignore,condition,new,not,condition,iterative,condition,t,pattern,get,condition,break,case,inner,ignore,condition,boolean,conditions,true,function,break,if,current,group,pattern,null,current,group,pattern,get,until,condition,null,inner,ignore,condition,extend,with,until,condition,inner,ignore,condition,iterative,condition,t,current,group,pattern,get,until,condition,false,return,inner,ignore,condition
NFACompiler -> NFAFactoryCompiler -> @SuppressWarnings("unchecked") 		private IterativeCondition<T> getInnerIgnoreCondition(Pattern<T, ?> pattern);1503588494;@return The {@link IterativeCondition condition} for the {@code IGNORE} edge_that corresponds to the specified {@link Pattern} and extended with stop(until) condition_if necessary. It is applicable only for inner states of a complex state like looping or times.;@SuppressWarnings("unchecked")_		private IterativeCondition<T> getInnerIgnoreCondition(Pattern<T, ?> pattern) {_			Quantifier.ConsumingStrategy consumingStrategy = pattern.getQuantifier().getInnerConsumingStrategy()__			if (headOfGroup(pattern)) {_				_				_				consumingStrategy = currentGroupPattern.getQuantifier().getInnerConsumingStrategy()__			}__			IterativeCondition<T> innerIgnoreCondition = null__			switch (consumingStrategy) {_				case STRICT:_					innerIgnoreCondition = null__					break__				case SKIP_TILL_NEXT:_					innerIgnoreCondition = new NotCondition<>((IterativeCondition<T>) pattern.getCondition())__					break__				case SKIP_TILL_ANY:_					innerIgnoreCondition = BooleanConditions.trueFunction()__					break__			}__			if (currentGroupPattern != null && currentGroupPattern.getUntilCondition() != null) {_				innerIgnoreCondition = extendWithUntilCondition(_					innerIgnoreCondition,_					(IterativeCondition<T>) currentGroupPattern.getUntilCondition(),_					false)__			}_			return innerIgnoreCondition__		};return,the,link,iterative,condition,condition,for,the,code,ignore,edge,that,corresponds,to,the,specified,link,pattern,and,extended,with,stop,until,condition,if,necessary,it,is,applicable,only,for,inner,states,of,a,complex,state,like,looping,or,times;suppress,warnings,unchecked,private,iterative,condition,t,get,inner,ignore,condition,pattern,t,pattern,quantifier,consuming,strategy,consuming,strategy,pattern,get,quantifier,get,inner,consuming,strategy,if,head,of,group,pattern,consuming,strategy,current,group,pattern,get,quantifier,get,inner,consuming,strategy,iterative,condition,t,inner,ignore,condition,null,switch,consuming,strategy,case,strict,inner,ignore,condition,null,break,case,inner,ignore,condition,new,not,condition,iterative,condition,t,pattern,get,condition,break,case,inner,ignore,condition,boolean,conditions,true,function,break,if,current,group,pattern,null,current,group,pattern,get,until,condition,null,inner,ignore,condition,extend,with,until,condition,inner,ignore,condition,iterative,condition,t,current,group,pattern,get,until,condition,false,return,inner,ignore,condition
NFACompiler -> NFAFactoryCompiler -> @SuppressWarnings("unchecked") 		private IterativeCondition<T> getInnerIgnoreCondition(Pattern<T, ?> pattern);1518008111;@return The {@link IterativeCondition condition} for the {@code IGNORE} edge_that corresponds to the specified {@link Pattern} and extended with stop(until) condition_if necessary. It is applicable only for inner states of a complex state like looping or times.;@SuppressWarnings("unchecked")_		private IterativeCondition<T> getInnerIgnoreCondition(Pattern<T, ?> pattern) {_			Quantifier.ConsumingStrategy consumingStrategy = pattern.getQuantifier().getInnerConsumingStrategy()__			if (headOfGroup(pattern)) {_				_				_				consumingStrategy = currentGroupPattern.getQuantifier().getInnerConsumingStrategy()__			}__			IterativeCondition<T> innerIgnoreCondition = null__			switch (consumingStrategy) {_				case STRICT:_					innerIgnoreCondition = null__					break__				case SKIP_TILL_NEXT:_					innerIgnoreCondition = new NotCondition<>((IterativeCondition<T>) pattern.getCondition())__					break__				case SKIP_TILL_ANY:_					innerIgnoreCondition = BooleanConditions.trueFunction()__					break__			}__			if (currentGroupPattern != null && currentGroupPattern.getUntilCondition() != null) {_				innerIgnoreCondition = extendWithUntilCondition(_					innerIgnoreCondition,_					(IterativeCondition<T>) currentGroupPattern.getUntilCondition(),_					false)__			}_			return innerIgnoreCondition__		};return,the,link,iterative,condition,condition,for,the,code,ignore,edge,that,corresponds,to,the,specified,link,pattern,and,extended,with,stop,until,condition,if,necessary,it,is,applicable,only,for,inner,states,of,a,complex,state,like,looping,or,times;suppress,warnings,unchecked,private,iterative,condition,t,get,inner,ignore,condition,pattern,t,pattern,quantifier,consuming,strategy,consuming,strategy,pattern,get,quantifier,get,inner,consuming,strategy,if,head,of,group,pattern,consuming,strategy,current,group,pattern,get,quantifier,get,inner,consuming,strategy,iterative,condition,t,inner,ignore,condition,null,switch,consuming,strategy,case,strict,inner,ignore,condition,null,break,case,inner,ignore,condition,new,not,condition,iterative,condition,t,pattern,get,condition,break,case,inner,ignore,condition,boolean,conditions,true,function,break,if,current,group,pattern,null,current,group,pattern,get,until,condition,null,inner,ignore,condition,extend,with,until,condition,inner,ignore,condition,iterative,condition,t,current,group,pattern,get,until,condition,false,return,inner,ignore,condition
NFACompiler -> NFAFactoryCompiler -> @SuppressWarnings("unchecked") 		private IterativeCondition<T> getInnerIgnoreCondition(Pattern<T, ?> pattern);1527863170;@return The {@link IterativeCondition condition} for the {@code IGNORE} edge_that corresponds to the specified {@link Pattern} and extended with stop(until) condition_if necessary. It is applicable only for inner states of a complex state like looping or times.;@SuppressWarnings("unchecked")_		private IterativeCondition<T> getInnerIgnoreCondition(Pattern<T, ?> pattern) {_			Quantifier.ConsumingStrategy consumingStrategy = pattern.getQuantifier().getInnerConsumingStrategy()__			if (headOfGroup(pattern)) {_				_				_				consumingStrategy = currentGroupPattern.getQuantifier().getInnerConsumingStrategy()__			}__			IterativeCondition<T> innerIgnoreCondition = null__			switch (consumingStrategy) {_				case STRICT:_					innerIgnoreCondition = null__					break__				case SKIP_TILL_NEXT:_					innerIgnoreCondition = new NotCondition<>((IterativeCondition<T>) pattern.getCondition())__					break__				case SKIP_TILL_ANY:_					innerIgnoreCondition = BooleanConditions.trueFunction()__					break__			}__			if (currentGroupPattern != null && currentGroupPattern.getUntilCondition() != null) {_				innerIgnoreCondition = extendWithUntilCondition(_					innerIgnoreCondition,_					(IterativeCondition<T>) currentGroupPattern.getUntilCondition(),_					false)__			}_			return innerIgnoreCondition__		};return,the,link,iterative,condition,condition,for,the,code,ignore,edge,that,corresponds,to,the,specified,link,pattern,and,extended,with,stop,until,condition,if,necessary,it,is,applicable,only,for,inner,states,of,a,complex,state,like,looping,or,times;suppress,warnings,unchecked,private,iterative,condition,t,get,inner,ignore,condition,pattern,t,pattern,quantifier,consuming,strategy,consuming,strategy,pattern,get,quantifier,get,inner,consuming,strategy,if,head,of,group,pattern,consuming,strategy,current,group,pattern,get,quantifier,get,inner,consuming,strategy,iterative,condition,t,inner,ignore,condition,null,switch,consuming,strategy,case,strict,inner,ignore,condition,null,break,case,inner,ignore,condition,new,not,condition,iterative,condition,t,pattern,get,condition,break,case,inner,ignore,condition,boolean,conditions,true,function,break,if,current,group,pattern,null,current,group,pattern,get,until,condition,null,inner,ignore,condition,extend,with,until,condition,inner,ignore,condition,iterative,condition,t,current,group,pattern,get,until,condition,false,return,inner,ignore,condition
NFACompiler -> NFAFactoryCompiler -> @SuppressWarnings("unchecked") 		private IterativeCondition<T> getInnerIgnoreCondition(Pattern<T, ?> pattern);1528989005;@return The {@link IterativeCondition condition} for the {@code IGNORE} edge_that corresponds to the specified {@link Pattern} and extended with stop(until) condition_if necessary. It is applicable only for inner states of a complex state like looping or times.;@SuppressWarnings("unchecked")_		private IterativeCondition<T> getInnerIgnoreCondition(Pattern<T, ?> pattern) {_			Quantifier.ConsumingStrategy consumingStrategy = pattern.getQuantifier().getInnerConsumingStrategy()__			if (headOfGroup(pattern)) {_				_				_				consumingStrategy = currentGroupPattern.getQuantifier().getInnerConsumingStrategy()__			}__			IterativeCondition<T> innerIgnoreCondition = null__			switch (consumingStrategy) {_				case STRICT:_					innerIgnoreCondition = null__					break__				case SKIP_TILL_NEXT:_					innerIgnoreCondition = new NotCondition<>((IterativeCondition<T>) pattern.getCondition())__					break__				case SKIP_TILL_ANY:_					innerIgnoreCondition = BooleanConditions.trueFunction()__					break__			}__			if (currentGroupPattern != null && currentGroupPattern.getUntilCondition() != null) {_				innerIgnoreCondition = extendWithUntilCondition(_					innerIgnoreCondition,_					(IterativeCondition<T>) currentGroupPattern.getUntilCondition(),_					false)__			}_			return innerIgnoreCondition__		};return,the,link,iterative,condition,condition,for,the,code,ignore,edge,that,corresponds,to,the,specified,link,pattern,and,extended,with,stop,until,condition,if,necessary,it,is,applicable,only,for,inner,states,of,a,complex,state,like,looping,or,times;suppress,warnings,unchecked,private,iterative,condition,t,get,inner,ignore,condition,pattern,t,pattern,quantifier,consuming,strategy,consuming,strategy,pattern,get,quantifier,get,inner,consuming,strategy,if,head,of,group,pattern,consuming,strategy,current,group,pattern,get,quantifier,get,inner,consuming,strategy,iterative,condition,t,inner,ignore,condition,null,switch,consuming,strategy,case,strict,inner,ignore,condition,null,break,case,inner,ignore,condition,new,not,condition,iterative,condition,t,pattern,get,condition,break,case,inner,ignore,condition,boolean,conditions,true,function,break,if,current,group,pattern,null,current,group,pattern,get,until,condition,null,inner,ignore,condition,extend,with,until,condition,inner,ignore,condition,iterative,condition,t,current,group,pattern,get,until,condition,false,return,inner,ignore,condition
NFACompiler -> NFAFactoryCompiler -> @SuppressWarnings("unchecked") 		private IterativeCondition<T> getInnerIgnoreCondition(Pattern<T, ?> pattern);1538745898;@return The {@link IterativeCondition condition} for the {@code IGNORE} edge_that corresponds to the specified {@link Pattern} and extended with stop(until) condition_if necessary. It is applicable only for inner states of a complex state like looping or times.;@SuppressWarnings("unchecked")_		private IterativeCondition<T> getInnerIgnoreCondition(Pattern<T, ?> pattern) {_			Quantifier.ConsumingStrategy consumingStrategy = pattern.getQuantifier().getInnerConsumingStrategy()__			if (headOfGroup(pattern)) {_				_				_				consumingStrategy = currentGroupPattern.getQuantifier().getInnerConsumingStrategy()__			}__			IterativeCondition<T> innerIgnoreCondition = null__			switch (consumingStrategy) {_				case STRICT:_					innerIgnoreCondition = null__					break__				case SKIP_TILL_NEXT:_					innerIgnoreCondition = new NotCondition<>((IterativeCondition<T>) pattern.getCondition())__					break__				case SKIP_TILL_ANY:_					innerIgnoreCondition = BooleanConditions.trueFunction()__					break__			}__			if (currentGroupPattern != null && currentGroupPattern.getUntilCondition() != null) {_				innerIgnoreCondition = extendWithUntilCondition(_					innerIgnoreCondition,_					(IterativeCondition<T>) currentGroupPattern.getUntilCondition(),_					false)__			}_			return innerIgnoreCondition__		};return,the,link,iterative,condition,condition,for,the,code,ignore,edge,that,corresponds,to,the,specified,link,pattern,and,extended,with,stop,until,condition,if,necessary,it,is,applicable,only,for,inner,states,of,a,complex,state,like,looping,or,times;suppress,warnings,unchecked,private,iterative,condition,t,get,inner,ignore,condition,pattern,t,pattern,quantifier,consuming,strategy,consuming,strategy,pattern,get,quantifier,get,inner,consuming,strategy,if,head,of,group,pattern,consuming,strategy,current,group,pattern,get,quantifier,get,inner,consuming,strategy,iterative,condition,t,inner,ignore,condition,null,switch,consuming,strategy,case,strict,inner,ignore,condition,null,break,case,inner,ignore,condition,new,not,condition,iterative,condition,t,pattern,get,condition,break,case,inner,ignore,condition,boolean,conditions,true,function,break,if,current,group,pattern,null,current,group,pattern,get,until,condition,null,inner,ignore,condition,extend,with,until,condition,inner,ignore,condition,iterative,condition,t,current,group,pattern,get,until,condition,false,return,inner,ignore,condition
NFACompiler -> NFAFactoryCompiler -> @SuppressWarnings("unchecked") 		private IterativeCondition<T> getInnerIgnoreCondition(Pattern<T, ?> pattern);1542293931;@return The {@link IterativeCondition condition} for the {@code IGNORE} edge_that corresponds to the specified {@link Pattern} and extended with stop(until) condition_if necessary. It is applicable only for inner states of a complex state like looping or times.;@SuppressWarnings("unchecked")_		private IterativeCondition<T> getInnerIgnoreCondition(Pattern<T, ?> pattern) {_			Quantifier.ConsumingStrategy consumingStrategy = pattern.getQuantifier().getInnerConsumingStrategy()__			if (headOfGroup(pattern)) {_				_				_				consumingStrategy = currentGroupPattern.getQuantifier().getInnerConsumingStrategy()__			}__			IterativeCondition<T> innerIgnoreCondition = null__			switch (consumingStrategy) {_				case STRICT:_					innerIgnoreCondition = null__					break__				case SKIP_TILL_NEXT:_					innerIgnoreCondition = new RichNotCondition<>((IterativeCondition<T>) pattern.getCondition())__					break__				case SKIP_TILL_ANY:_					innerIgnoreCondition = BooleanConditions.trueFunction()__					break__			}__			if (currentGroupPattern != null && currentGroupPattern.getUntilCondition() != null) {_				innerIgnoreCondition = extendWithUntilCondition(_					innerIgnoreCondition,_					(IterativeCondition<T>) currentGroupPattern.getUntilCondition(),_					false)__			}_			return innerIgnoreCondition__		};return,the,link,iterative,condition,condition,for,the,code,ignore,edge,that,corresponds,to,the,specified,link,pattern,and,extended,with,stop,until,condition,if,necessary,it,is,applicable,only,for,inner,states,of,a,complex,state,like,looping,or,times;suppress,warnings,unchecked,private,iterative,condition,t,get,inner,ignore,condition,pattern,t,pattern,quantifier,consuming,strategy,consuming,strategy,pattern,get,quantifier,get,inner,consuming,strategy,if,head,of,group,pattern,consuming,strategy,current,group,pattern,get,quantifier,get,inner,consuming,strategy,iterative,condition,t,inner,ignore,condition,null,switch,consuming,strategy,case,strict,inner,ignore,condition,null,break,case,inner,ignore,condition,new,rich,not,condition,iterative,condition,t,pattern,get,condition,break,case,inner,ignore,condition,boolean,conditions,true,function,break,if,current,group,pattern,null,current,group,pattern,get,until,condition,null,inner,ignore,condition,extend,with,until,condition,inner,ignore,condition,iterative,condition,t,current,group,pattern,get,until,condition,false,return,inner,ignore,condition
NFACompiler -> @Internal 	public static <T> Map<String, State<T>> migrateGraph(State<T> oldStartState);1490089987;Used for migrating CEP graphs prior to 1.3. It removes the dummy start, adds the dummy end, and translates all_states to consuming ones by moving all TAKEs and IGNOREs to the next state. This method assumes each state_has at most one TAKE and one IGNORE and name of each state is unique. No PROCEED transition is allowed!__@param oldStartState dummy start state of old graph_@param <T> type of events_@return map of new states, where key is the name of a state and value is the state itself;@Internal_	public static <T> Map<String, State<T>> migrateGraph(State<T> oldStartState) {_		State<T> oldFirst = oldStartState__		State<T> oldSecond = oldStartState.getStateTransitions().iterator().next().getTargetState()___		StateTransition<T> oldFirstToSecondTake = Iterators.find(_			oldFirst.getStateTransitions().iterator(),_			new Predicate<StateTransition<T>>() {_				@Override_				public boolean apply(@Nullable StateTransition<T> input) {_					return input != null && input.getAction() == StateTransitionAction.TAKE__				}__			})___		StateTransition<T> oldFirstIgnore = Iterators.find(_			oldFirst.getStateTransitions().iterator(),_			new Predicate<StateTransition<T>>() {_				@Override_				public boolean apply(@Nullable StateTransition<T> input) {_					return input != null && input.getAction() == StateTransitionAction.IGNORE__				}__			}, null)___		StateTransition<T> oldSecondToThirdTake = Iterators.find(_			oldSecond.getStateTransitions().iterator(),_			new Predicate<StateTransition<T>>() {_				@Override_				public boolean apply(@Nullable StateTransition<T> input) {_					return input != null && input.getAction() == StateTransitionAction.TAKE__				}__			}, null)___		final Map<String, State<T>> convertedStates = new HashMap<>()__		State<T> newSecond__		State<T> newFirst = new State<>(oldSecond.getName(), State.StateType.Start)__		convertedStates.put(newFirst.getName(), newFirst)__		while (oldSecondToThirdTake != null) {__			newSecond = new State<T>(oldSecondToThirdTake.getTargetState().getName(), State.StateType.Normal)__			convertedStates.put(newSecond.getName(), newSecond)__			newFirst.addTake(newSecond, oldFirstToSecondTake.getCondition())___			if (oldFirstIgnore != null) {_				newFirst.addIgnore(oldFirstIgnore.getCondition())__			}__			oldFirst = oldSecond___			oldFirstToSecondTake = Iterators.find(_				oldFirst.getStateTransitions().iterator(),_				new Predicate<StateTransition<T>>() {_					@Override_					public boolean apply(@Nullable StateTransition<T> input) {_						return input != null && input.getAction() == StateTransitionAction.TAKE__					}__				})___			oldFirstIgnore = Iterators.find(_				oldFirst.getStateTransitions().iterator(),_				new Predicate<StateTransition<T>>() {_					@Override_					public boolean apply(@Nullable StateTransition<T> input) {_						return input != null && input.getAction() == StateTransitionAction.IGNORE__					}__				}, null)___			oldSecond = oldSecondToThirdTake.getTargetState()___			oldSecondToThirdTake = Iterators.find(_				oldSecond.getStateTransitions().iterator(),_				new Predicate<StateTransition<T>>() {_					@Override_					public boolean apply(@Nullable StateTransition<T> input) {_						return input != null && input.getAction() == StateTransitionAction.TAKE__					}__				}, null)___			newFirst = newSecond__		}__		final State<T> endingState = new State<>(ENDING_STATE_NAME, State.StateType.Final)___		newFirst.addTake(endingState, oldFirstToSecondTake.getCondition())___		if (oldFirstIgnore != null) {_			newFirst.addIgnore(oldFirstIgnore.getCondition())__		}__		convertedStates.put(endingState.getName(), endingState)___		return convertedStates__	};used,for,migrating,cep,graphs,prior,to,1,3,it,removes,the,dummy,start,adds,the,dummy,end,and,translates,all,states,to,consuming,ones,by,moving,all,takes,and,ignores,to,the,next,state,this,method,assumes,each,state,has,at,most,one,take,and,one,ignore,and,name,of,each,state,is,unique,no,proceed,transition,is,allowed,param,old,start,state,dummy,start,state,of,old,graph,param,t,type,of,events,return,map,of,new,states,where,key,is,the,name,of,a,state,and,value,is,the,state,itself;internal,public,static,t,map,string,state,t,migrate,graph,state,t,old,start,state,state,t,old,first,old,start,state,state,t,old,second,old,start,state,get,state,transitions,iterator,next,get,target,state,state,transition,t,old,first,to,second,take,iterators,find,old,first,get,state,transitions,iterator,new,predicate,state,transition,t,override,public,boolean,apply,nullable,state,transition,t,input,return,input,null,input,get,action,state,transition,action,take,state,transition,t,old,first,ignore,iterators,find,old,first,get,state,transitions,iterator,new,predicate,state,transition,t,override,public,boolean,apply,nullable,state,transition,t,input,return,input,null,input,get,action,state,transition,action,ignore,null,state,transition,t,old,second,to,third,take,iterators,find,old,second,get,state,transitions,iterator,new,predicate,state,transition,t,override,public,boolean,apply,nullable,state,transition,t,input,return,input,null,input,get,action,state,transition,action,take,null,final,map,string,state,t,converted,states,new,hash,map,state,t,new,second,state,t,new,first,new,state,old,second,get,name,state,state,type,start,converted,states,put,new,first,get,name,new,first,while,old,second,to,third,take,null,new,second,new,state,t,old,second,to,third,take,get,target,state,get,name,state,state,type,normal,converted,states,put,new,second,get,name,new,second,new,first,add,take,new,second,old,first,to,second,take,get,condition,if,old,first,ignore,null,new,first,add,ignore,old,first,ignore,get,condition,old,first,old,second,old,first,to,second,take,iterators,find,old,first,get,state,transitions,iterator,new,predicate,state,transition,t,override,public,boolean,apply,nullable,state,transition,t,input,return,input,null,input,get,action,state,transition,action,take,old,first,ignore,iterators,find,old,first,get,state,transitions,iterator,new,predicate,state,transition,t,override,public,boolean,apply,nullable,state,transition,t,input,return,input,null,input,get,action,state,transition,action,ignore,null,old,second,old,second,to,third,take,get,target,state,old,second,to,third,take,iterators,find,old,second,get,state,transitions,iterator,new,predicate,state,transition,t,override,public,boolean,apply,nullable,state,transition,t,input,return,input,null,input,get,action,state,transition,action,take,null,new,first,new,second,final,state,t,ending,state,new,state,state,state,type,final,new,first,add,take,ending,state,old,first,to,second,take,get,condition,if,old,first,ignore,null,new,first,add,ignore,old,first,ignore,get,condition,converted,states,put,ending,state,get,name,ending,state,return,converted,states
NFACompiler -> @Internal 	public static <T> Map<String, State<T>> migrateGraph(State<T> oldStartState);1490194327;Used for migrating CEP graphs prior to 1.3. It removes the dummy start, adds the dummy end, and translates all_states to consuming ones by moving all TAKEs and IGNOREs to the next state. This method assumes each state_has at most one TAKE and one IGNORE and name of each state is unique. No PROCEED transition is allowed!__@param oldStartState dummy start state of old graph_@param <T> type of events_@return map of new states, where key is the name of a state and value is the state itself;@Internal_	public static <T> Map<String, State<T>> migrateGraph(State<T> oldStartState) {_		State<T> oldFirst = oldStartState__		State<T> oldSecond = oldStartState.getStateTransitions().iterator().next().getTargetState()___		StateTransition<T> oldFirstToSecondTake = Iterators.find(_			oldFirst.getStateTransitions().iterator(),_			new Predicate<StateTransition<T>>() {_				@Override_				public boolean apply(@Nullable StateTransition<T> input) {_					return input != null && input.getAction() == StateTransitionAction.TAKE__				}__			})___		StateTransition<T> oldFirstIgnore = Iterators.find(_			oldFirst.getStateTransitions().iterator(),_			new Predicate<StateTransition<T>>() {_				@Override_				public boolean apply(@Nullable StateTransition<T> input) {_					return input != null && input.getAction() == StateTransitionAction.IGNORE__				}__			}, null)___		StateTransition<T> oldSecondToThirdTake = Iterators.find(_			oldSecond.getStateTransitions().iterator(),_			new Predicate<StateTransition<T>>() {_				@Override_				public boolean apply(@Nullable StateTransition<T> input) {_					return input != null && input.getAction() == StateTransitionAction.TAKE__				}__			}, null)___		final Map<String, State<T>> convertedStates = new HashMap<>()__		State<T> newSecond__		State<T> newFirst = new State<>(oldSecond.getName(), State.StateType.Start)__		convertedStates.put(newFirst.getName(), newFirst)__		while (oldSecondToThirdTake != null) {__			newSecond = new State<T>(oldSecondToThirdTake.getTargetState().getName(), State.StateType.Normal)__			convertedStates.put(newSecond.getName(), newSecond)__			newFirst.addTake(newSecond, oldFirstToSecondTake.getCondition())___			if (oldFirstIgnore != null) {_				newFirst.addIgnore(oldFirstIgnore.getCondition())__			}__			oldFirst = oldSecond___			oldFirstToSecondTake = Iterators.find(_				oldFirst.getStateTransitions().iterator(),_				new Predicate<StateTransition<T>>() {_					@Override_					public boolean apply(@Nullable StateTransition<T> input) {_						return input != null && input.getAction() == StateTransitionAction.TAKE__					}__				})___			oldFirstIgnore = Iterators.find(_				oldFirst.getStateTransitions().iterator(),_				new Predicate<StateTransition<T>>() {_					@Override_					public boolean apply(@Nullable StateTransition<T> input) {_						return input != null && input.getAction() == StateTransitionAction.IGNORE__					}__				}, null)___			oldSecond = oldSecondToThirdTake.getTargetState()___			oldSecondToThirdTake = Iterators.find(_				oldSecond.getStateTransitions().iterator(),_				new Predicate<StateTransition<T>>() {_					@Override_					public boolean apply(@Nullable StateTransition<T> input) {_						return input != null && input.getAction() == StateTransitionAction.TAKE__					}__				}, null)___			newFirst = newSecond__		}__		final State<T> endingState = new State<>(ENDING_STATE_NAME, State.StateType.Final)___		newFirst.addTake(endingState, oldFirstToSecondTake.getCondition())___		if (oldFirstIgnore != null) {_			newFirst.addIgnore(oldFirstIgnore.getCondition())__		}__		convertedStates.put(endingState.getName(), endingState)___		return convertedStates__	};used,for,migrating,cep,graphs,prior,to,1,3,it,removes,the,dummy,start,adds,the,dummy,end,and,translates,all,states,to,consuming,ones,by,moving,all,takes,and,ignores,to,the,next,state,this,method,assumes,each,state,has,at,most,one,take,and,one,ignore,and,name,of,each,state,is,unique,no,proceed,transition,is,allowed,param,old,start,state,dummy,start,state,of,old,graph,param,t,type,of,events,return,map,of,new,states,where,key,is,the,name,of,a,state,and,value,is,the,state,itself;internal,public,static,t,map,string,state,t,migrate,graph,state,t,old,start,state,state,t,old,first,old,start,state,state,t,old,second,old,start,state,get,state,transitions,iterator,next,get,target,state,state,transition,t,old,first,to,second,take,iterators,find,old,first,get,state,transitions,iterator,new,predicate,state,transition,t,override,public,boolean,apply,nullable,state,transition,t,input,return,input,null,input,get,action,state,transition,action,take,state,transition,t,old,first,ignore,iterators,find,old,first,get,state,transitions,iterator,new,predicate,state,transition,t,override,public,boolean,apply,nullable,state,transition,t,input,return,input,null,input,get,action,state,transition,action,ignore,null,state,transition,t,old,second,to,third,take,iterators,find,old,second,get,state,transitions,iterator,new,predicate,state,transition,t,override,public,boolean,apply,nullable,state,transition,t,input,return,input,null,input,get,action,state,transition,action,take,null,final,map,string,state,t,converted,states,new,hash,map,state,t,new,second,state,t,new,first,new,state,old,second,get,name,state,state,type,start,converted,states,put,new,first,get,name,new,first,while,old,second,to,third,take,null,new,second,new,state,t,old,second,to,third,take,get,target,state,get,name,state,state,type,normal,converted,states,put,new,second,get,name,new,second,new,first,add,take,new,second,old,first,to,second,take,get,condition,if,old,first,ignore,null,new,first,add,ignore,old,first,ignore,get,condition,old,first,old,second,old,first,to,second,take,iterators,find,old,first,get,state,transitions,iterator,new,predicate,state,transition,t,override,public,boolean,apply,nullable,state,transition,t,input,return,input,null,input,get,action,state,transition,action,take,old,first,ignore,iterators,find,old,first,get,state,transitions,iterator,new,predicate,state,transition,t,override,public,boolean,apply,nullable,state,transition,t,input,return,input,null,input,get,action,state,transition,action,ignore,null,old,second,old,second,to,third,take,get,target,state,old,second,to,third,take,iterators,find,old,second,get,state,transitions,iterator,new,predicate,state,transition,t,override,public,boolean,apply,nullable,state,transition,t,input,return,input,null,input,get,action,state,transition,action,take,null,new,first,new,second,final,state,t,ending,state,new,state,state,state,type,final,new,first,add,take,ending,state,old,first,to,second,take,get,condition,if,old,first,ignore,null,new,first,add,ignore,old,first,ignore,get,condition,converted,states,put,ending,state,get,name,ending,state,return,converted,states
NFACompiler -> @Internal 	public static <T> Map<String, State<T>> migrateGraph(State<T> oldStartState);1490619911;Used for migrating CEP graphs prior to 1.3. It removes the dummy start, adds the dummy end, and translates all_states to consuming ones by moving all TAKEs and IGNOREs to the next state. This method assumes each state_has at most one TAKE and one IGNORE and name of each state is unique. No PROCEED transition is allowed!__@param oldStartState dummy start state of old graph_@param <T>           type of events_@return map of new states, where key is the name of a state and value is the state itself;@Internal_	public static <T> Map<String, State<T>> migrateGraph(State<T> oldStartState) {_		State<T> oldFirst = oldStartState__		State<T> oldSecond = oldStartState.getStateTransitions().iterator().next().getTargetState()___		StateTransition<T> oldFirstToSecondTake = Iterators.find(_			oldFirst.getStateTransitions().iterator(),_			new Predicate<StateTransition<T>>() {_				@Override_				public boolean apply(@Nullable StateTransition<T> input) {_					return input != null && input.getAction() == StateTransitionAction.TAKE__				}__			})___		StateTransition<T> oldFirstIgnore = Iterators.find(_			oldFirst.getStateTransitions().iterator(),_			new Predicate<StateTransition<T>>() {_				@Override_				public boolean apply(@Nullable StateTransition<T> input) {_					return input != null && input.getAction() == StateTransitionAction.IGNORE__				}__			}, null)___		StateTransition<T> oldSecondToThirdTake = Iterators.find(_			oldSecond.getStateTransitions().iterator(),_			new Predicate<StateTransition<T>>() {_				@Override_				public boolean apply(@Nullable StateTransition<T> input) {_					return input != null && input.getAction() == StateTransitionAction.TAKE__				}__			}, null)___		final Map<String, State<T>> convertedStates = new HashMap<>()__		State<T> newSecond__		State<T> newFirst = new State<>(oldSecond.getName(), State.StateType.Start)__		convertedStates.put(newFirst.getName(), newFirst)__		while (oldSecondToThirdTake != null) {__			newSecond = new State<T>(oldSecondToThirdTake.getTargetState().getName(), State.StateType.Normal)__			convertedStates.put(newSecond.getName(), newSecond)__			newFirst.addTake(newSecond, oldFirstToSecondTake.getCondition())___			if (oldFirstIgnore != null) {_				newFirst.addIgnore(oldFirstIgnore.getCondition())__			}__			oldFirst = oldSecond___			oldFirstToSecondTake = Iterators.find(_				oldFirst.getStateTransitions().iterator(),_				new Predicate<StateTransition<T>>() {_					@Override_					public boolean apply(@Nullable StateTransition<T> input) {_						return input != null && input.getAction() == StateTransitionAction.TAKE__					}__				})___			oldFirstIgnore = Iterators.find(_				oldFirst.getStateTransitions().iterator(),_				new Predicate<StateTransition<T>>() {_					@Override_					public boolean apply(@Nullable StateTransition<T> input) {_						return input != null && input.getAction() == StateTransitionAction.IGNORE__					}__				}, null)___			oldSecond = oldSecondToThirdTake.getTargetState()___			oldSecondToThirdTake = Iterators.find(_				oldSecond.getStateTransitions().iterator(),_				new Predicate<StateTransition<T>>() {_					@Override_					public boolean apply(@Nullable StateTransition<T> input) {_						return input != null && input.getAction() == StateTransitionAction.TAKE__					}__				}, null)___			newFirst = newSecond__		}__		final State<T> endingState = new State<>(ENDING_STATE_NAME, State.StateType.Final)___		newFirst.addTake(endingState, oldFirstToSecondTake.getCondition())___		if (oldFirstIgnore != null) {_			newFirst.addIgnore(oldFirstIgnore.getCondition())__		}__		convertedStates.put(endingState.getName(), endingState)___		return convertedStates__	};used,for,migrating,cep,graphs,prior,to,1,3,it,removes,the,dummy,start,adds,the,dummy,end,and,translates,all,states,to,consuming,ones,by,moving,all,takes,and,ignores,to,the,next,state,this,method,assumes,each,state,has,at,most,one,take,and,one,ignore,and,name,of,each,state,is,unique,no,proceed,transition,is,allowed,param,old,start,state,dummy,start,state,of,old,graph,param,t,type,of,events,return,map,of,new,states,where,key,is,the,name,of,a,state,and,value,is,the,state,itself;internal,public,static,t,map,string,state,t,migrate,graph,state,t,old,start,state,state,t,old,first,old,start,state,state,t,old,second,old,start,state,get,state,transitions,iterator,next,get,target,state,state,transition,t,old,first,to,second,take,iterators,find,old,first,get,state,transitions,iterator,new,predicate,state,transition,t,override,public,boolean,apply,nullable,state,transition,t,input,return,input,null,input,get,action,state,transition,action,take,state,transition,t,old,first,ignore,iterators,find,old,first,get,state,transitions,iterator,new,predicate,state,transition,t,override,public,boolean,apply,nullable,state,transition,t,input,return,input,null,input,get,action,state,transition,action,ignore,null,state,transition,t,old,second,to,third,take,iterators,find,old,second,get,state,transitions,iterator,new,predicate,state,transition,t,override,public,boolean,apply,nullable,state,transition,t,input,return,input,null,input,get,action,state,transition,action,take,null,final,map,string,state,t,converted,states,new,hash,map,state,t,new,second,state,t,new,first,new,state,old,second,get,name,state,state,type,start,converted,states,put,new,first,get,name,new,first,while,old,second,to,third,take,null,new,second,new,state,t,old,second,to,third,take,get,target,state,get,name,state,state,type,normal,converted,states,put,new,second,get,name,new,second,new,first,add,take,new,second,old,first,to,second,take,get,condition,if,old,first,ignore,null,new,first,add,ignore,old,first,ignore,get,condition,old,first,old,second,old,first,to,second,take,iterators,find,old,first,get,state,transitions,iterator,new,predicate,state,transition,t,override,public,boolean,apply,nullable,state,transition,t,input,return,input,null,input,get,action,state,transition,action,take,old,first,ignore,iterators,find,old,first,get,state,transitions,iterator,new,predicate,state,transition,t,override,public,boolean,apply,nullable,state,transition,t,input,return,input,null,input,get,action,state,transition,action,ignore,null,old,second,old,second,to,third,take,get,target,state,old,second,to,third,take,iterators,find,old,second,get,state,transitions,iterator,new,predicate,state,transition,t,override,public,boolean,apply,nullable,state,transition,t,input,return,input,null,input,get,action,state,transition,action,take,null,new,first,new,second,final,state,t,ending,state,new,state,state,state,type,final,new,first,add,take,ending,state,old,first,to,second,take,get,condition,if,old,first,ignore,null,new,first,add,ignore,old,first,ignore,get,condition,converted,states,put,ending,state,get,name,ending,state,return,converted,states
NFACompiler -> @Internal 	public static <T> Map<String, State<T>> migrateGraph(State<T> oldStartState);1491320734;Used for migrating CEP graphs prior to 1.3. It removes the dummy start, adds the dummy end, and translates all_states to consuming ones by moving all TAKEs and IGNOREs to the next state. This method assumes each state_has at most one TAKE and one IGNORE and name of each state is unique. No PROCEED transition is allowed!__@param oldStartState dummy start state of old graph_@param <T>           type of events_@return map of new states, where key is the name of a state and value is the state itself;@Internal_	public static <T> Map<String, State<T>> migrateGraph(State<T> oldStartState) {_		State<T> oldFirst = oldStartState__		State<T> oldSecond = oldStartState.getStateTransitions().iterator().next().getTargetState()___		StateTransition<T> oldFirstToSecondTake = Iterators.find(_			oldFirst.getStateTransitions().iterator(),_			new Predicate<StateTransition<T>>() {_				@Override_				public boolean apply(@Nullable StateTransition<T> input) {_					return input != null && input.getAction() == StateTransitionAction.TAKE__				}__			})___		StateTransition<T> oldFirstIgnore = Iterators.find(_			oldFirst.getStateTransitions().iterator(),_			new Predicate<StateTransition<T>>() {_				@Override_				public boolean apply(@Nullable StateTransition<T> input) {_					return input != null && input.getAction() == StateTransitionAction.IGNORE__				}__			}, null)___		StateTransition<T> oldSecondToThirdTake = Iterators.find(_			oldSecond.getStateTransitions().iterator(),_			new Predicate<StateTransition<T>>() {_				@Override_				public boolean apply(@Nullable StateTransition<T> input) {_					return input != null && input.getAction() == StateTransitionAction.TAKE__				}__			}, null)___		final Map<String, State<T>> convertedStates = new HashMap<>()__		State<T> newSecond__		State<T> newFirst = new State<>(oldSecond.getName(), State.StateType.Start)__		convertedStates.put(newFirst.getName(), newFirst)__		while (oldSecondToThirdTake != null) {__			newSecond = new State<T>(oldSecondToThirdTake.getTargetState().getName(), State.StateType.Normal)__			convertedStates.put(newSecond.getName(), newSecond)__			newFirst.addTake(newSecond, oldFirstToSecondTake.getCondition())___			if (oldFirstIgnore != null) {_				newFirst.addIgnore(oldFirstIgnore.getCondition())__			}__			oldFirst = oldSecond___			oldFirstToSecondTake = Iterators.find(_				oldFirst.getStateTransitions().iterator(),_				new Predicate<StateTransition<T>>() {_					@Override_					public boolean apply(@Nullable StateTransition<T> input) {_						return input != null && input.getAction() == StateTransitionAction.TAKE__					}__				})___			oldFirstIgnore = Iterators.find(_				oldFirst.getStateTransitions().iterator(),_				new Predicate<StateTransition<T>>() {_					@Override_					public boolean apply(@Nullable StateTransition<T> input) {_						return input != null && input.getAction() == StateTransitionAction.IGNORE__					}__				}, null)___			oldSecond = oldSecondToThirdTake.getTargetState()___			oldSecondToThirdTake = Iterators.find(_				oldSecond.getStateTransitions().iterator(),_				new Predicate<StateTransition<T>>() {_					@Override_					public boolean apply(@Nullable StateTransition<T> input) {_						return input != null && input.getAction() == StateTransitionAction.TAKE__					}__				}, null)___			newFirst = newSecond__		}__		final State<T> endingState = new State<>(ENDING_STATE_NAME, State.StateType.Final)___		newFirst.addTake(endingState, oldFirstToSecondTake.getCondition())___		if (oldFirstIgnore != null) {_			newFirst.addIgnore(oldFirstIgnore.getCondition())__		}__		convertedStates.put(endingState.getName(), endingState)___		return convertedStates__	};used,for,migrating,cep,graphs,prior,to,1,3,it,removes,the,dummy,start,adds,the,dummy,end,and,translates,all,states,to,consuming,ones,by,moving,all,takes,and,ignores,to,the,next,state,this,method,assumes,each,state,has,at,most,one,take,and,one,ignore,and,name,of,each,state,is,unique,no,proceed,transition,is,allowed,param,old,start,state,dummy,start,state,of,old,graph,param,t,type,of,events,return,map,of,new,states,where,key,is,the,name,of,a,state,and,value,is,the,state,itself;internal,public,static,t,map,string,state,t,migrate,graph,state,t,old,start,state,state,t,old,first,old,start,state,state,t,old,second,old,start,state,get,state,transitions,iterator,next,get,target,state,state,transition,t,old,first,to,second,take,iterators,find,old,first,get,state,transitions,iterator,new,predicate,state,transition,t,override,public,boolean,apply,nullable,state,transition,t,input,return,input,null,input,get,action,state,transition,action,take,state,transition,t,old,first,ignore,iterators,find,old,first,get,state,transitions,iterator,new,predicate,state,transition,t,override,public,boolean,apply,nullable,state,transition,t,input,return,input,null,input,get,action,state,transition,action,ignore,null,state,transition,t,old,second,to,third,take,iterators,find,old,second,get,state,transitions,iterator,new,predicate,state,transition,t,override,public,boolean,apply,nullable,state,transition,t,input,return,input,null,input,get,action,state,transition,action,take,null,final,map,string,state,t,converted,states,new,hash,map,state,t,new,second,state,t,new,first,new,state,old,second,get,name,state,state,type,start,converted,states,put,new,first,get,name,new,first,while,old,second,to,third,take,null,new,second,new,state,t,old,second,to,third,take,get,target,state,get,name,state,state,type,normal,converted,states,put,new,second,get,name,new,second,new,first,add,take,new,second,old,first,to,second,take,get,condition,if,old,first,ignore,null,new,first,add,ignore,old,first,ignore,get,condition,old,first,old,second,old,first,to,second,take,iterators,find,old,first,get,state,transitions,iterator,new,predicate,state,transition,t,override,public,boolean,apply,nullable,state,transition,t,input,return,input,null,input,get,action,state,transition,action,take,old,first,ignore,iterators,find,old,first,get,state,transitions,iterator,new,predicate,state,transition,t,override,public,boolean,apply,nullable,state,transition,t,input,return,input,null,input,get,action,state,transition,action,ignore,null,old,second,old,second,to,third,take,get,target,state,old,second,to,third,take,iterators,find,old,second,get,state,transitions,iterator,new,predicate,state,transition,t,override,public,boolean,apply,nullable,state,transition,t,input,return,input,null,input,get,action,state,transition,action,take,null,new,first,new,second,final,state,t,ending,state,new,state,state,state,type,final,new,first,add,take,ending,state,old,first,to,second,take,get,condition,if,old,first,ignore,null,new,first,add,ignore,old,first,ignore,get,condition,converted,states,put,ending,state,get,name,ending,state,return,converted,states
NFACompiler -> @Internal 	public static <T> Map<String, State<T>> migrateGraph(State<T> oldStartState);1491323030;Used for migrating CEP graphs prior to 1.3. It removes the dummy start, adds the dummy end, and translates all_states to consuming ones by moving all TAKEs and IGNOREs to the next state. This method assumes each state_has at most one TAKE and one IGNORE and name of each state is unique. No PROCEED transition is allowed!__@param oldStartState dummy start state of old graph_@param <T>           type of events_@return map of new states, where key is the name of a state and value is the state itself;@Internal_	public static <T> Map<String, State<T>> migrateGraph(State<T> oldStartState) {_		State<T> oldFirst = oldStartState__		State<T> oldSecond = oldStartState.getStateTransitions().iterator().next().getTargetState()___		StateTransition<T> oldFirstToSecondTake = Iterators.find(_			oldFirst.getStateTransitions().iterator(),_			new Predicate<StateTransition<T>>() {_				@Override_				public boolean apply(@Nullable StateTransition<T> input) {_					return input != null && input.getAction() == StateTransitionAction.TAKE__				}__			})___		StateTransition<T> oldFirstIgnore = Iterators.find(_			oldFirst.getStateTransitions().iterator(),_			new Predicate<StateTransition<T>>() {_				@Override_				public boolean apply(@Nullable StateTransition<T> input) {_					return input != null && input.getAction() == StateTransitionAction.IGNORE__				}__			}, null)___		StateTransition<T> oldSecondToThirdTake = Iterators.find(_			oldSecond.getStateTransitions().iterator(),_			new Predicate<StateTransition<T>>() {_				@Override_				public boolean apply(@Nullable StateTransition<T> input) {_					return input != null && input.getAction() == StateTransitionAction.TAKE__				}__			}, null)___		final Map<String, State<T>> convertedStates = new HashMap<>()__		State<T> newSecond__		State<T> newFirst = new State<>(oldSecond.getName(), State.StateType.Start)__		convertedStates.put(newFirst.getName(), newFirst)__		while (oldSecondToThirdTake != null) {__			newSecond = new State<T>(oldSecondToThirdTake.getTargetState().getName(), State.StateType.Normal)__			convertedStates.put(newSecond.getName(), newSecond)__			newFirst.addTake(newSecond, oldFirstToSecondTake.getCondition())___			if (oldFirstIgnore != null) {_				newFirst.addIgnore(oldFirstIgnore.getCondition())__			}__			oldFirst = oldSecond___			oldFirstToSecondTake = Iterators.find(_				oldFirst.getStateTransitions().iterator(),_				new Predicate<StateTransition<T>>() {_					@Override_					public boolean apply(@Nullable StateTransition<T> input) {_						return input != null && input.getAction() == StateTransitionAction.TAKE__					}__				})___			oldFirstIgnore = Iterators.find(_				oldFirst.getStateTransitions().iterator(),_				new Predicate<StateTransition<T>>() {_					@Override_					public boolean apply(@Nullable StateTransition<T> input) {_						return input != null && input.getAction() == StateTransitionAction.IGNORE__					}__				}, null)___			oldSecond = oldSecondToThirdTake.getTargetState()___			oldSecondToThirdTake = Iterators.find(_				oldSecond.getStateTransitions().iterator(),_				new Predicate<StateTransition<T>>() {_					@Override_					public boolean apply(@Nullable StateTransition<T> input) {_						return input != null && input.getAction() == StateTransitionAction.TAKE__					}__				}, null)___			newFirst = newSecond__		}__		final State<T> endingState = new State<>(ENDING_STATE_NAME, State.StateType.Final)___		newFirst.addTake(endingState, oldFirstToSecondTake.getCondition())___		if (oldFirstIgnore != null) {_			newFirst.addIgnore(oldFirstIgnore.getCondition())__		}__		convertedStates.put(endingState.getName(), endingState)___		return convertedStates__	};used,for,migrating,cep,graphs,prior,to,1,3,it,removes,the,dummy,start,adds,the,dummy,end,and,translates,all,states,to,consuming,ones,by,moving,all,takes,and,ignores,to,the,next,state,this,method,assumes,each,state,has,at,most,one,take,and,one,ignore,and,name,of,each,state,is,unique,no,proceed,transition,is,allowed,param,old,start,state,dummy,start,state,of,old,graph,param,t,type,of,events,return,map,of,new,states,where,key,is,the,name,of,a,state,and,value,is,the,state,itself;internal,public,static,t,map,string,state,t,migrate,graph,state,t,old,start,state,state,t,old,first,old,start,state,state,t,old,second,old,start,state,get,state,transitions,iterator,next,get,target,state,state,transition,t,old,first,to,second,take,iterators,find,old,first,get,state,transitions,iterator,new,predicate,state,transition,t,override,public,boolean,apply,nullable,state,transition,t,input,return,input,null,input,get,action,state,transition,action,take,state,transition,t,old,first,ignore,iterators,find,old,first,get,state,transitions,iterator,new,predicate,state,transition,t,override,public,boolean,apply,nullable,state,transition,t,input,return,input,null,input,get,action,state,transition,action,ignore,null,state,transition,t,old,second,to,third,take,iterators,find,old,second,get,state,transitions,iterator,new,predicate,state,transition,t,override,public,boolean,apply,nullable,state,transition,t,input,return,input,null,input,get,action,state,transition,action,take,null,final,map,string,state,t,converted,states,new,hash,map,state,t,new,second,state,t,new,first,new,state,old,second,get,name,state,state,type,start,converted,states,put,new,first,get,name,new,first,while,old,second,to,third,take,null,new,second,new,state,t,old,second,to,third,take,get,target,state,get,name,state,state,type,normal,converted,states,put,new,second,get,name,new,second,new,first,add,take,new,second,old,first,to,second,take,get,condition,if,old,first,ignore,null,new,first,add,ignore,old,first,ignore,get,condition,old,first,old,second,old,first,to,second,take,iterators,find,old,first,get,state,transitions,iterator,new,predicate,state,transition,t,override,public,boolean,apply,nullable,state,transition,t,input,return,input,null,input,get,action,state,transition,action,take,old,first,ignore,iterators,find,old,first,get,state,transitions,iterator,new,predicate,state,transition,t,override,public,boolean,apply,nullable,state,transition,t,input,return,input,null,input,get,action,state,transition,action,ignore,null,old,second,old,second,to,third,take,get,target,state,old,second,to,third,take,iterators,find,old,second,get,state,transitions,iterator,new,predicate,state,transition,t,override,public,boolean,apply,nullable,state,transition,t,input,return,input,null,input,get,action,state,transition,action,take,null,new,first,new,second,final,state,t,ending,state,new,state,state,state,type,final,new,first,add,take,ending,state,old,first,to,second,take,get,condition,if,old,first,ignore,null,new,first,add,ignore,old,first,ignore,get,condition,converted,states,put,ending,state,get,name,ending,state,return,converted,states
NFACompiler -> @Internal 	public static <T> Map<String, State<T>> migrateGraph(State<T> oldStartState);1491633862;Used for migrating CEP graphs prior to 1.3. It removes the dummy start, adds the dummy end, and translates all_states to consuming ones by moving all TAKEs and IGNOREs to the next state. This method assumes each state_has at most one TAKE and one IGNORE and name of each state is unique. No PROCEED transition is allowed!__@param oldStartState dummy start state of old graph_@param <T>           type of events_@return map of new states, where key is the name of a state and value is the state itself;@Internal_	public static <T> Map<String, State<T>> migrateGraph(State<T> oldStartState) {_		State<T> oldFirst = oldStartState__		State<T> oldSecond = oldStartState.getStateTransitions().iterator().next().getTargetState()___		StateTransition<T> oldFirstToSecondTake = Iterators.find(_			oldFirst.getStateTransitions().iterator(),_			new Predicate<StateTransition<T>>() {_				@Override_				public boolean apply(@Nullable StateTransition<T> input) {_					return input != null && input.getAction() == StateTransitionAction.TAKE__				}__			})___		StateTransition<T> oldFirstIgnore = Iterators.find(_			oldFirst.getStateTransitions().iterator(),_			new Predicate<StateTransition<T>>() {_				@Override_				public boolean apply(@Nullable StateTransition<T> input) {_					return input != null && input.getAction() == StateTransitionAction.IGNORE__				}__			}, null)___		StateTransition<T> oldSecondToThirdTake = Iterators.find(_			oldSecond.getStateTransitions().iterator(),_			new Predicate<StateTransition<T>>() {_				@Override_				public boolean apply(@Nullable StateTransition<T> input) {_					return input != null && input.getAction() == StateTransitionAction.TAKE__				}__			}, null)___		final Map<String, State<T>> convertedStates = new HashMap<>()__		State<T> newSecond__		State<T> newFirst = new State<>(oldSecond.getName(), State.StateType.Start)__		convertedStates.put(newFirst.getName(), newFirst)__		while (oldSecondToThirdTake != null) {__			newSecond = new State<T>(oldSecondToThirdTake.getTargetState().getName(), State.StateType.Normal)__			convertedStates.put(newSecond.getName(), newSecond)__			newFirst.addTake(newSecond, oldFirstToSecondTake.getCondition())___			if (oldFirstIgnore != null) {_				newFirst.addIgnore(oldFirstIgnore.getCondition())__			}__			oldFirst = oldSecond___			oldFirstToSecondTake = Iterators.find(_				oldFirst.getStateTransitions().iterator(),_				new Predicate<StateTransition<T>>() {_					@Override_					public boolean apply(@Nullable StateTransition<T> input) {_						return input != null && input.getAction() == StateTransitionAction.TAKE__					}__				})___			oldFirstIgnore = Iterators.find(_				oldFirst.getStateTransitions().iterator(),_				new Predicate<StateTransition<T>>() {_					@Override_					public boolean apply(@Nullable StateTransition<T> input) {_						return input != null && input.getAction() == StateTransitionAction.IGNORE__					}__				}, null)___			oldSecond = oldSecondToThirdTake.getTargetState()___			oldSecondToThirdTake = Iterators.find(_				oldSecond.getStateTransitions().iterator(),_				new Predicate<StateTransition<T>>() {_					@Override_					public boolean apply(@Nullable StateTransition<T> input) {_						return input != null && input.getAction() == StateTransitionAction.TAKE__					}__				}, null)___			newFirst = newSecond__		}__		final State<T> endingState = new State<>(ENDING_STATE_NAME, State.StateType.Final)___		newFirst.addTake(endingState, oldFirstToSecondTake.getCondition())___		if (oldFirstIgnore != null) {_			newFirst.addIgnore(oldFirstIgnore.getCondition())__		}__		convertedStates.put(endingState.getName(), endingState)___		return convertedStates__	};used,for,migrating,cep,graphs,prior,to,1,3,it,removes,the,dummy,start,adds,the,dummy,end,and,translates,all,states,to,consuming,ones,by,moving,all,takes,and,ignores,to,the,next,state,this,method,assumes,each,state,has,at,most,one,take,and,one,ignore,and,name,of,each,state,is,unique,no,proceed,transition,is,allowed,param,old,start,state,dummy,start,state,of,old,graph,param,t,type,of,events,return,map,of,new,states,where,key,is,the,name,of,a,state,and,value,is,the,state,itself;internal,public,static,t,map,string,state,t,migrate,graph,state,t,old,start,state,state,t,old,first,old,start,state,state,t,old,second,old,start,state,get,state,transitions,iterator,next,get,target,state,state,transition,t,old,first,to,second,take,iterators,find,old,first,get,state,transitions,iterator,new,predicate,state,transition,t,override,public,boolean,apply,nullable,state,transition,t,input,return,input,null,input,get,action,state,transition,action,take,state,transition,t,old,first,ignore,iterators,find,old,first,get,state,transitions,iterator,new,predicate,state,transition,t,override,public,boolean,apply,nullable,state,transition,t,input,return,input,null,input,get,action,state,transition,action,ignore,null,state,transition,t,old,second,to,third,take,iterators,find,old,second,get,state,transitions,iterator,new,predicate,state,transition,t,override,public,boolean,apply,nullable,state,transition,t,input,return,input,null,input,get,action,state,transition,action,take,null,final,map,string,state,t,converted,states,new,hash,map,state,t,new,second,state,t,new,first,new,state,old,second,get,name,state,state,type,start,converted,states,put,new,first,get,name,new,first,while,old,second,to,third,take,null,new,second,new,state,t,old,second,to,third,take,get,target,state,get,name,state,state,type,normal,converted,states,put,new,second,get,name,new,second,new,first,add,take,new,second,old,first,to,second,take,get,condition,if,old,first,ignore,null,new,first,add,ignore,old,first,ignore,get,condition,old,first,old,second,old,first,to,second,take,iterators,find,old,first,get,state,transitions,iterator,new,predicate,state,transition,t,override,public,boolean,apply,nullable,state,transition,t,input,return,input,null,input,get,action,state,transition,action,take,old,first,ignore,iterators,find,old,first,get,state,transitions,iterator,new,predicate,state,transition,t,override,public,boolean,apply,nullable,state,transition,t,input,return,input,null,input,get,action,state,transition,action,ignore,null,old,second,old,second,to,third,take,get,target,state,old,second,to,third,take,iterators,find,old,second,get,state,transitions,iterator,new,predicate,state,transition,t,override,public,boolean,apply,nullable,state,transition,t,input,return,input,null,input,get,action,state,transition,action,take,null,new,first,new,second,final,state,t,ending,state,new,state,state,state,type,final,new,first,add,take,ending,state,old,first,to,second,take,get,condition,if,old,first,ignore,null,new,first,add,ignore,old,first,ignore,get,condition,converted,states,put,ending,state,get,name,ending,state,return,converted,states
NFACompiler -> @Internal 	public static <T> Map<String, State<T>> migrateGraph(State<T> oldStartState);1492797583;Used for migrating CEP graphs prior to 1.3. It removes the dummy start, adds the dummy end, and translates all_states to consuming ones by moving all TAKEs and IGNOREs to the next state. This method assumes each state_has at most one TAKE and one IGNORE and name of each state is unique. No PROCEED transition is allowed!__@param oldStartState dummy start state of old graph_@param <T>           type of events_@return map of new states, where key is the name of a state and value is the state itself;@Internal_	public static <T> Map<String, State<T>> migrateGraph(State<T> oldStartState) {_		State<T> oldFirst = oldStartState__		State<T> oldSecond = oldStartState.getStateTransitions().iterator().next().getTargetState()___		StateTransition<T> oldFirstToSecondTake = Iterators.find(_			oldFirst.getStateTransitions().iterator(),_			new Predicate<StateTransition<T>>() {_				@Override_				public boolean apply(@Nullable StateTransition<T> input) {_					return input != null && input.getAction() == StateTransitionAction.TAKE__				}__			})___		StateTransition<T> oldFirstIgnore = Iterators.find(_			oldFirst.getStateTransitions().iterator(),_			new Predicate<StateTransition<T>>() {_				@Override_				public boolean apply(@Nullable StateTransition<T> input) {_					return input != null && input.getAction() == StateTransitionAction.IGNORE__				}__			}, null)___		StateTransition<T> oldSecondToThirdTake = Iterators.find(_			oldSecond.getStateTransitions().iterator(),_			new Predicate<StateTransition<T>>() {_				@Override_				public boolean apply(@Nullable StateTransition<T> input) {_					return input != null && input.getAction() == StateTransitionAction.TAKE__				}__			}, null)___		final Map<String, State<T>> convertedStates = new HashMap<>()__		State<T> newSecond__		State<T> newFirst = new State<>(oldSecond.getName(), State.StateType.Start)__		convertedStates.put(newFirst.getName(), newFirst)__		while (oldSecondToThirdTake != null) {__			newSecond = new State<T>(oldSecondToThirdTake.getTargetState().getName(), State.StateType.Normal)__			convertedStates.put(newSecond.getName(), newSecond)__			newFirst.addTake(newSecond, oldFirstToSecondTake.getCondition())___			if (oldFirstIgnore != null) {_				newFirst.addIgnore(oldFirstIgnore.getCondition())__			}__			oldFirst = oldSecond___			oldFirstToSecondTake = Iterators.find(_				oldFirst.getStateTransitions().iterator(),_				new Predicate<StateTransition<T>>() {_					@Override_					public boolean apply(@Nullable StateTransition<T> input) {_						return input != null && input.getAction() == StateTransitionAction.TAKE__					}__				})___			oldFirstIgnore = Iterators.find(_				oldFirst.getStateTransitions().iterator(),_				new Predicate<StateTransition<T>>() {_					@Override_					public boolean apply(@Nullable StateTransition<T> input) {_						return input != null && input.getAction() == StateTransitionAction.IGNORE__					}__				}, null)___			oldSecond = oldSecondToThirdTake.getTargetState()___			oldSecondToThirdTake = Iterators.find(_				oldSecond.getStateTransitions().iterator(),_				new Predicate<StateTransition<T>>() {_					@Override_					public boolean apply(@Nullable StateTransition<T> input) {_						return input != null && input.getAction() == StateTransitionAction.TAKE__					}__				}, null)___			newFirst = newSecond__		}__		final State<T> endingState = new State<>(ENDING_STATE_NAME, State.StateType.Final)___		newFirst.addTake(endingState, oldFirstToSecondTake.getCondition())___		if (oldFirstIgnore != null) {_			newFirst.addIgnore(oldFirstIgnore.getCondition())__		}__		convertedStates.put(endingState.getName(), endingState)___		return convertedStates__	};used,for,migrating,cep,graphs,prior,to,1,3,it,removes,the,dummy,start,adds,the,dummy,end,and,translates,all,states,to,consuming,ones,by,moving,all,takes,and,ignores,to,the,next,state,this,method,assumes,each,state,has,at,most,one,take,and,one,ignore,and,name,of,each,state,is,unique,no,proceed,transition,is,allowed,param,old,start,state,dummy,start,state,of,old,graph,param,t,type,of,events,return,map,of,new,states,where,key,is,the,name,of,a,state,and,value,is,the,state,itself;internal,public,static,t,map,string,state,t,migrate,graph,state,t,old,start,state,state,t,old,first,old,start,state,state,t,old,second,old,start,state,get,state,transitions,iterator,next,get,target,state,state,transition,t,old,first,to,second,take,iterators,find,old,first,get,state,transitions,iterator,new,predicate,state,transition,t,override,public,boolean,apply,nullable,state,transition,t,input,return,input,null,input,get,action,state,transition,action,take,state,transition,t,old,first,ignore,iterators,find,old,first,get,state,transitions,iterator,new,predicate,state,transition,t,override,public,boolean,apply,nullable,state,transition,t,input,return,input,null,input,get,action,state,transition,action,ignore,null,state,transition,t,old,second,to,third,take,iterators,find,old,second,get,state,transitions,iterator,new,predicate,state,transition,t,override,public,boolean,apply,nullable,state,transition,t,input,return,input,null,input,get,action,state,transition,action,take,null,final,map,string,state,t,converted,states,new,hash,map,state,t,new,second,state,t,new,first,new,state,old,second,get,name,state,state,type,start,converted,states,put,new,first,get,name,new,first,while,old,second,to,third,take,null,new,second,new,state,t,old,second,to,third,take,get,target,state,get,name,state,state,type,normal,converted,states,put,new,second,get,name,new,second,new,first,add,take,new,second,old,first,to,second,take,get,condition,if,old,first,ignore,null,new,first,add,ignore,old,first,ignore,get,condition,old,first,old,second,old,first,to,second,take,iterators,find,old,first,get,state,transitions,iterator,new,predicate,state,transition,t,override,public,boolean,apply,nullable,state,transition,t,input,return,input,null,input,get,action,state,transition,action,take,old,first,ignore,iterators,find,old,first,get,state,transitions,iterator,new,predicate,state,transition,t,override,public,boolean,apply,nullable,state,transition,t,input,return,input,null,input,get,action,state,transition,action,ignore,null,old,second,old,second,to,third,take,get,target,state,old,second,to,third,take,iterators,find,old,second,get,state,transitions,iterator,new,predicate,state,transition,t,override,public,boolean,apply,nullable,state,transition,t,input,return,input,null,input,get,action,state,transition,action,take,null,new,first,new,second,final,state,t,ending,state,new,state,state,state,type,final,new,first,add,take,ending,state,old,first,to,second,take,get,condition,if,old,first,ignore,null,new,first,add,ignore,old,first,ignore,get,condition,converted,states,put,ending,state,get,name,ending,state,return,converted,states
NFACompiler -> @Internal 	public static <T> Map<String, State<T>> migrateGraph(State<T> oldStartState);1493200673;Used for migrating CEP graphs prior to 1.3. It removes the dummy start, adds the dummy end, and translates all_states to consuming ones by moving all TAKEs and IGNOREs to the next state. This method assumes each state_has at most one TAKE and one IGNORE and name of each state is unique. No PROCEED transition is allowed!__@param oldStartState dummy start state of old graph_@param <T>           type of events_@return map of new states, where key is the name of a state and value is the state itself;@Internal_	public static <T> Map<String, State<T>> migrateGraph(State<T> oldStartState) {_		State<T> oldFirst = oldStartState__		State<T> oldSecond = oldStartState.getStateTransitions().iterator().next().getTargetState()___		StateTransition<T> oldFirstToSecondTake = Iterators.find(_			oldFirst.getStateTransitions().iterator(),_			new Predicate<StateTransition<T>>() {_				@Override_				public boolean apply(@Nullable StateTransition<T> input) {_					return input != null && input.getAction() == StateTransitionAction.TAKE__				}__			})___		StateTransition<T> oldFirstIgnore = Iterators.find(_			oldFirst.getStateTransitions().iterator(),_			new Predicate<StateTransition<T>>() {_				@Override_				public boolean apply(@Nullable StateTransition<T> input) {_					return input != null && input.getAction() == StateTransitionAction.IGNORE__				}__			}, null)___		StateTransition<T> oldSecondToThirdTake = Iterators.find(_			oldSecond.getStateTransitions().iterator(),_			new Predicate<StateTransition<T>>() {_				@Override_				public boolean apply(@Nullable StateTransition<T> input) {_					return input != null && input.getAction() == StateTransitionAction.TAKE__				}__			}, null)___		final Map<String, State<T>> convertedStates = new HashMap<>()__		State<T> newSecond__		State<T> newFirst = new State<>(oldSecond.getName(), State.StateType.Start)__		convertedStates.put(newFirst.getName(), newFirst)__		while (oldSecondToThirdTake != null) {__			newSecond = new State<T>(oldSecondToThirdTake.getTargetState().getName(), State.StateType.Normal)__			convertedStates.put(newSecond.getName(), newSecond)__			newFirst.addTake(newSecond, oldFirstToSecondTake.getCondition())___			if (oldFirstIgnore != null) {_				newFirst.addIgnore(oldFirstIgnore.getCondition())__			}__			oldFirst = oldSecond___			oldFirstToSecondTake = Iterators.find(_				oldFirst.getStateTransitions().iterator(),_				new Predicate<StateTransition<T>>() {_					@Override_					public boolean apply(@Nullable StateTransition<T> input) {_						return input != null && input.getAction() == StateTransitionAction.TAKE__					}__				})___			oldFirstIgnore = Iterators.find(_				oldFirst.getStateTransitions().iterator(),_				new Predicate<StateTransition<T>>() {_					@Override_					public boolean apply(@Nullable StateTransition<T> input) {_						return input != null && input.getAction() == StateTransitionAction.IGNORE__					}__				}, null)___			oldSecond = oldSecondToThirdTake.getTargetState()___			oldSecondToThirdTake = Iterators.find(_				oldSecond.getStateTransitions().iterator(),_				new Predicate<StateTransition<T>>() {_					@Override_					public boolean apply(@Nullable StateTransition<T> input) {_						return input != null && input.getAction() == StateTransitionAction.TAKE__					}__				}, null)___			newFirst = newSecond__		}__		final State<T> endingState = new State<>(ENDING_STATE_NAME, State.StateType.Final)___		newFirst.addTake(endingState, oldFirstToSecondTake.getCondition())___		if (oldFirstIgnore != null) {_			newFirst.addIgnore(oldFirstIgnore.getCondition())__		}__		convertedStates.put(endingState.getName(), endingState)___		return convertedStates__	};used,for,migrating,cep,graphs,prior,to,1,3,it,removes,the,dummy,start,adds,the,dummy,end,and,translates,all,states,to,consuming,ones,by,moving,all,takes,and,ignores,to,the,next,state,this,method,assumes,each,state,has,at,most,one,take,and,one,ignore,and,name,of,each,state,is,unique,no,proceed,transition,is,allowed,param,old,start,state,dummy,start,state,of,old,graph,param,t,type,of,events,return,map,of,new,states,where,key,is,the,name,of,a,state,and,value,is,the,state,itself;internal,public,static,t,map,string,state,t,migrate,graph,state,t,old,start,state,state,t,old,first,old,start,state,state,t,old,second,old,start,state,get,state,transitions,iterator,next,get,target,state,state,transition,t,old,first,to,second,take,iterators,find,old,first,get,state,transitions,iterator,new,predicate,state,transition,t,override,public,boolean,apply,nullable,state,transition,t,input,return,input,null,input,get,action,state,transition,action,take,state,transition,t,old,first,ignore,iterators,find,old,first,get,state,transitions,iterator,new,predicate,state,transition,t,override,public,boolean,apply,nullable,state,transition,t,input,return,input,null,input,get,action,state,transition,action,ignore,null,state,transition,t,old,second,to,third,take,iterators,find,old,second,get,state,transitions,iterator,new,predicate,state,transition,t,override,public,boolean,apply,nullable,state,transition,t,input,return,input,null,input,get,action,state,transition,action,take,null,final,map,string,state,t,converted,states,new,hash,map,state,t,new,second,state,t,new,first,new,state,old,second,get,name,state,state,type,start,converted,states,put,new,first,get,name,new,first,while,old,second,to,third,take,null,new,second,new,state,t,old,second,to,third,take,get,target,state,get,name,state,state,type,normal,converted,states,put,new,second,get,name,new,second,new,first,add,take,new,second,old,first,to,second,take,get,condition,if,old,first,ignore,null,new,first,add,ignore,old,first,ignore,get,condition,old,first,old,second,old,first,to,second,take,iterators,find,old,first,get,state,transitions,iterator,new,predicate,state,transition,t,override,public,boolean,apply,nullable,state,transition,t,input,return,input,null,input,get,action,state,transition,action,take,old,first,ignore,iterators,find,old,first,get,state,transitions,iterator,new,predicate,state,transition,t,override,public,boolean,apply,nullable,state,transition,t,input,return,input,null,input,get,action,state,transition,action,ignore,null,old,second,old,second,to,third,take,get,target,state,old,second,to,third,take,iterators,find,old,second,get,state,transitions,iterator,new,predicate,state,transition,t,override,public,boolean,apply,nullable,state,transition,t,input,return,input,null,input,get,action,state,transition,action,take,null,new,first,new,second,final,state,t,ending,state,new,state,state,state,type,final,new,first,add,take,ending,state,old,first,to,second,take,get,condition,if,old,first,ignore,null,new,first,add,ignore,old,first,ignore,get,condition,converted,states,put,ending,state,get,name,ending,state,return,converted,states
NFACompiler -> @Internal 	public static <T> Map<String, State<T>> migrateGraph(State<T> oldStartState);1493385877;Used for migrating CEP graphs prior to 1.3. It removes the dummy start, adds the dummy end, and translates all_states to consuming ones by moving all TAKEs and IGNOREs to the next state. This method assumes each state_has at most one TAKE and one IGNORE and name of each state is unique. No PROCEED transition is allowed!__@param oldStartState dummy start state of old graph_@param <T>           type of events_@return map of new states, where key is the name of a state and value is the state itself;@Internal_	public static <T> Map<String, State<T>> migrateGraph(State<T> oldStartState) {_		State<T> oldFirst = oldStartState__		State<T> oldSecond = oldStartState.getStateTransitions().iterator().next().getTargetState()___		StateTransition<T> oldFirstToSecondTake = Iterators.find(_			oldFirst.getStateTransitions().iterator(),_			new Predicate<StateTransition<T>>() {_				@Override_				public boolean apply(@Nullable StateTransition<T> input) {_					return input != null && input.getAction() == StateTransitionAction.TAKE__				}__			})___		StateTransition<T> oldFirstIgnore = Iterators.find(_			oldFirst.getStateTransitions().iterator(),_			new Predicate<StateTransition<T>>() {_				@Override_				public boolean apply(@Nullable StateTransition<T> input) {_					return input != null && input.getAction() == StateTransitionAction.IGNORE__				}__			}, null)___		StateTransition<T> oldSecondToThirdTake = Iterators.find(_			oldSecond.getStateTransitions().iterator(),_			new Predicate<StateTransition<T>>() {_				@Override_				public boolean apply(@Nullable StateTransition<T> input) {_					return input != null && input.getAction() == StateTransitionAction.TAKE__				}__			}, null)___		final Map<String, State<T>> convertedStates = new HashMap<>()__		State<T> newSecond__		State<T> newFirst = new State<>(oldSecond.getName(), State.StateType.Start)__		convertedStates.put(newFirst.getName(), newFirst)__		while (oldSecondToThirdTake != null) {__			newSecond = new State<T>(oldSecondToThirdTake.getTargetState().getName(), State.StateType.Normal)__			convertedStates.put(newSecond.getName(), newSecond)__			newFirst.addTake(newSecond, oldFirstToSecondTake.getCondition())___			if (oldFirstIgnore != null) {_				newFirst.addIgnore(oldFirstIgnore.getCondition())__			}__			oldFirst = oldSecond___			oldFirstToSecondTake = Iterators.find(_				oldFirst.getStateTransitions().iterator(),_				new Predicate<StateTransition<T>>() {_					@Override_					public boolean apply(@Nullable StateTransition<T> input) {_						return input != null && input.getAction() == StateTransitionAction.TAKE__					}__				})___			oldFirstIgnore = Iterators.find(_				oldFirst.getStateTransitions().iterator(),_				new Predicate<StateTransition<T>>() {_					@Override_					public boolean apply(@Nullable StateTransition<T> input) {_						return input != null && input.getAction() == StateTransitionAction.IGNORE__					}__				}, null)___			oldSecond = oldSecondToThirdTake.getTargetState()___			oldSecondToThirdTake = Iterators.find(_				oldSecond.getStateTransitions().iterator(),_				new Predicate<StateTransition<T>>() {_					@Override_					public boolean apply(@Nullable StateTransition<T> input) {_						return input != null && input.getAction() == StateTransitionAction.TAKE__					}__				}, null)___			newFirst = newSecond__		}__		final State<T> endingState = new State<>(ENDING_STATE_NAME, State.StateType.Final)___		newFirst.addTake(endingState, oldFirstToSecondTake.getCondition())___		if (oldFirstIgnore != null) {_			newFirst.addIgnore(oldFirstIgnore.getCondition())__		}__		convertedStates.put(endingState.getName(), endingState)___		return convertedStates__	};used,for,migrating,cep,graphs,prior,to,1,3,it,removes,the,dummy,start,adds,the,dummy,end,and,translates,all,states,to,consuming,ones,by,moving,all,takes,and,ignores,to,the,next,state,this,method,assumes,each,state,has,at,most,one,take,and,one,ignore,and,name,of,each,state,is,unique,no,proceed,transition,is,allowed,param,old,start,state,dummy,start,state,of,old,graph,param,t,type,of,events,return,map,of,new,states,where,key,is,the,name,of,a,state,and,value,is,the,state,itself;internal,public,static,t,map,string,state,t,migrate,graph,state,t,old,start,state,state,t,old,first,old,start,state,state,t,old,second,old,start,state,get,state,transitions,iterator,next,get,target,state,state,transition,t,old,first,to,second,take,iterators,find,old,first,get,state,transitions,iterator,new,predicate,state,transition,t,override,public,boolean,apply,nullable,state,transition,t,input,return,input,null,input,get,action,state,transition,action,take,state,transition,t,old,first,ignore,iterators,find,old,first,get,state,transitions,iterator,new,predicate,state,transition,t,override,public,boolean,apply,nullable,state,transition,t,input,return,input,null,input,get,action,state,transition,action,ignore,null,state,transition,t,old,second,to,third,take,iterators,find,old,second,get,state,transitions,iterator,new,predicate,state,transition,t,override,public,boolean,apply,nullable,state,transition,t,input,return,input,null,input,get,action,state,transition,action,take,null,final,map,string,state,t,converted,states,new,hash,map,state,t,new,second,state,t,new,first,new,state,old,second,get,name,state,state,type,start,converted,states,put,new,first,get,name,new,first,while,old,second,to,third,take,null,new,second,new,state,t,old,second,to,third,take,get,target,state,get,name,state,state,type,normal,converted,states,put,new,second,get,name,new,second,new,first,add,take,new,second,old,first,to,second,take,get,condition,if,old,first,ignore,null,new,first,add,ignore,old,first,ignore,get,condition,old,first,old,second,old,first,to,second,take,iterators,find,old,first,get,state,transitions,iterator,new,predicate,state,transition,t,override,public,boolean,apply,nullable,state,transition,t,input,return,input,null,input,get,action,state,transition,action,take,old,first,ignore,iterators,find,old,first,get,state,transitions,iterator,new,predicate,state,transition,t,override,public,boolean,apply,nullable,state,transition,t,input,return,input,null,input,get,action,state,transition,action,ignore,null,old,second,old,second,to,third,take,get,target,state,old,second,to,third,take,iterators,find,old,second,get,state,transitions,iterator,new,predicate,state,transition,t,override,public,boolean,apply,nullable,state,transition,t,input,return,input,null,input,get,action,state,transition,action,take,null,new,first,new,second,final,state,t,ending,state,new,state,state,state,type,final,new,first,add,take,ending,state,old,first,to,second,take,get,condition,if,old,first,ignore,null,new,first,add,ignore,old,first,ignore,get,condition,converted,states,put,ending,state,get,name,ending,state,return,converted,states
NFACompiler -> @Internal 	public static <T> Map<String, State<T>> migrateGraph(State<T> oldStartState);1494947249;Used for migrating CEP graphs prior to 1.3. It removes the dummy start, adds the dummy end, and translates all_states to consuming ones by moving all TAKEs and IGNOREs to the next state. This method assumes each state_has at most one TAKE and one IGNORE and name of each state is unique. No PROCEED transition is allowed!__@param oldStartState dummy start state of old graph_@param <T>           type of events_@return map of new states, where key is the name of a state and value is the state itself;@Internal_	public static <T> Map<String, State<T>> migrateGraph(State<T> oldStartState) {_		State<T> oldFirst = oldStartState__		State<T> oldSecond = oldStartState.getStateTransitions().iterator().next().getTargetState()___		StateTransition<T> oldFirstToSecondTake = Iterators.find(_			oldFirst.getStateTransitions().iterator(),_			new Predicate<StateTransition<T>>() {_				@Override_				public boolean apply(@Nullable StateTransition<T> input) {_					return input != null && input.getAction() == StateTransitionAction.TAKE__				}__			})___		StateTransition<T> oldFirstIgnore = Iterators.find(_			oldFirst.getStateTransitions().iterator(),_			new Predicate<StateTransition<T>>() {_				@Override_				public boolean apply(@Nullable StateTransition<T> input) {_					return input != null && input.getAction() == StateTransitionAction.IGNORE__				}__			}, null)___		StateTransition<T> oldSecondToThirdTake = Iterators.find(_			oldSecond.getStateTransitions().iterator(),_			new Predicate<StateTransition<T>>() {_				@Override_				public boolean apply(@Nullable StateTransition<T> input) {_					return input != null && input.getAction() == StateTransitionAction.TAKE__				}__			}, null)___		final Map<String, State<T>> convertedStates = new HashMap<>()__		State<T> newSecond__		State<T> newFirst = new State<>(oldSecond.getName(), State.StateType.Start)__		convertedStates.put(newFirst.getName(), newFirst)__		while (oldSecondToThirdTake != null) {__			newSecond = new State<T>(oldSecondToThirdTake.getTargetState().getName(), State.StateType.Normal)__			convertedStates.put(newSecond.getName(), newSecond)__			newFirst.addTake(newSecond, oldFirstToSecondTake.getCondition())___			if (oldFirstIgnore != null) {_				newFirst.addIgnore(oldFirstIgnore.getCondition())__			}__			oldFirst = oldSecond___			oldFirstToSecondTake = Iterators.find(_				oldFirst.getStateTransitions().iterator(),_				new Predicate<StateTransition<T>>() {_					@Override_					public boolean apply(@Nullable StateTransition<T> input) {_						return input != null && input.getAction() == StateTransitionAction.TAKE__					}__				})___			oldFirstIgnore = Iterators.find(_				oldFirst.getStateTransitions().iterator(),_				new Predicate<StateTransition<T>>() {_					@Override_					public boolean apply(@Nullable StateTransition<T> input) {_						return input != null && input.getAction() == StateTransitionAction.IGNORE__					}__				}, null)___			oldSecond = oldSecondToThirdTake.getTargetState()___			oldSecondToThirdTake = Iterators.find(_				oldSecond.getStateTransitions().iterator(),_				new Predicate<StateTransition<T>>() {_					@Override_					public boolean apply(@Nullable StateTransition<T> input) {_						return input != null && input.getAction() == StateTransitionAction.TAKE__					}__				}, null)___			newFirst = newSecond__		}__		final State<T> endingState = new State<>(ENDING_STATE_NAME, State.StateType.Final)___		newFirst.addTake(endingState, oldFirstToSecondTake.getCondition())___		if (oldFirstIgnore != null) {_			newFirst.addIgnore(oldFirstIgnore.getCondition())__		}__		convertedStates.put(endingState.getName(), endingState)___		return convertedStates__	};used,for,migrating,cep,graphs,prior,to,1,3,it,removes,the,dummy,start,adds,the,dummy,end,and,translates,all,states,to,consuming,ones,by,moving,all,takes,and,ignores,to,the,next,state,this,method,assumes,each,state,has,at,most,one,take,and,one,ignore,and,name,of,each,state,is,unique,no,proceed,transition,is,allowed,param,old,start,state,dummy,start,state,of,old,graph,param,t,type,of,events,return,map,of,new,states,where,key,is,the,name,of,a,state,and,value,is,the,state,itself;internal,public,static,t,map,string,state,t,migrate,graph,state,t,old,start,state,state,t,old,first,old,start,state,state,t,old,second,old,start,state,get,state,transitions,iterator,next,get,target,state,state,transition,t,old,first,to,second,take,iterators,find,old,first,get,state,transitions,iterator,new,predicate,state,transition,t,override,public,boolean,apply,nullable,state,transition,t,input,return,input,null,input,get,action,state,transition,action,take,state,transition,t,old,first,ignore,iterators,find,old,first,get,state,transitions,iterator,new,predicate,state,transition,t,override,public,boolean,apply,nullable,state,transition,t,input,return,input,null,input,get,action,state,transition,action,ignore,null,state,transition,t,old,second,to,third,take,iterators,find,old,second,get,state,transitions,iterator,new,predicate,state,transition,t,override,public,boolean,apply,nullable,state,transition,t,input,return,input,null,input,get,action,state,transition,action,take,null,final,map,string,state,t,converted,states,new,hash,map,state,t,new,second,state,t,new,first,new,state,old,second,get,name,state,state,type,start,converted,states,put,new,first,get,name,new,first,while,old,second,to,third,take,null,new,second,new,state,t,old,second,to,third,take,get,target,state,get,name,state,state,type,normal,converted,states,put,new,second,get,name,new,second,new,first,add,take,new,second,old,first,to,second,take,get,condition,if,old,first,ignore,null,new,first,add,ignore,old,first,ignore,get,condition,old,first,old,second,old,first,to,second,take,iterators,find,old,first,get,state,transitions,iterator,new,predicate,state,transition,t,override,public,boolean,apply,nullable,state,transition,t,input,return,input,null,input,get,action,state,transition,action,take,old,first,ignore,iterators,find,old,first,get,state,transitions,iterator,new,predicate,state,transition,t,override,public,boolean,apply,nullable,state,transition,t,input,return,input,null,input,get,action,state,transition,action,ignore,null,old,second,old,second,to,third,take,get,target,state,old,second,to,third,take,iterators,find,old,second,get,state,transitions,iterator,new,predicate,state,transition,t,override,public,boolean,apply,nullable,state,transition,t,input,return,input,null,input,get,action,state,transition,action,take,null,new,first,new,second,final,state,t,ending,state,new,state,state,state,type,final,new,first,add,take,ending,state,old,first,to,second,take,get,condition,if,old,first,ignore,null,new,first,add,ignore,old,first,ignore,get,condition,converted,states,put,ending,state,get,name,ending,state,return,converted,states
NFACompiler -> @Internal 	public static <T> Map<String, State<T>> migrateGraph(State<T> oldStartState);1495657626;Used for migrating CEP graphs prior to 1.3. It removes the dummy start, adds the dummy end, and translates all_states to consuming ones by moving all TAKEs and IGNOREs to the next state. This method assumes each state_has at most one TAKE and one IGNORE and name of each state is unique. No PROCEED transition is allowed!__@param oldStartState dummy start state of old graph_@param <T>           type of events_@return map of new states, where key is the name of a state and value is the state itself;@Internal_	public static <T> Map<String, State<T>> migrateGraph(State<T> oldStartState) {_		State<T> oldFirst = oldStartState__		State<T> oldSecond = oldStartState.getStateTransitions().iterator().next().getTargetState()___		StateTransition<T> oldFirstToSecondTake = Iterators.find(_			oldFirst.getStateTransitions().iterator(),_			new Predicate<StateTransition<T>>() {_				@Override_				public boolean apply(@Nullable StateTransition<T> input) {_					return input != null && input.getAction() == StateTransitionAction.TAKE__				}__			})___		StateTransition<T> oldFirstIgnore = Iterators.find(_			oldFirst.getStateTransitions().iterator(),_			new Predicate<StateTransition<T>>() {_				@Override_				public boolean apply(@Nullable StateTransition<T> input) {_					return input != null && input.getAction() == StateTransitionAction.IGNORE__				}__			}, null)___		StateTransition<T> oldSecondToThirdTake = Iterators.find(_			oldSecond.getStateTransitions().iterator(),_			new Predicate<StateTransition<T>>() {_				@Override_				public boolean apply(@Nullable StateTransition<T> input) {_					return input != null && input.getAction() == StateTransitionAction.TAKE__				}__			}, null)___		final Map<String, State<T>> convertedStates = new HashMap<>()__		State<T> newSecond__		State<T> newFirst = new State<>(oldSecond.getName(), State.StateType.Start)__		convertedStates.put(newFirst.getName(), newFirst)__		while (oldSecondToThirdTake != null) {__			newSecond = new State<T>(oldSecondToThirdTake.getTargetState().getName(), State.StateType.Normal)__			convertedStates.put(newSecond.getName(), newSecond)__			newFirst.addTake(newSecond, oldFirstToSecondTake.getCondition())___			if (oldFirstIgnore != null) {_				newFirst.addIgnore(oldFirstIgnore.getCondition())__			}__			oldFirst = oldSecond___			oldFirstToSecondTake = Iterators.find(_				oldFirst.getStateTransitions().iterator(),_				new Predicate<StateTransition<T>>() {_					@Override_					public boolean apply(@Nullable StateTransition<T> input) {_						return input != null && input.getAction() == StateTransitionAction.TAKE__					}__				})___			oldFirstIgnore = Iterators.find(_				oldFirst.getStateTransitions().iterator(),_				new Predicate<StateTransition<T>>() {_					@Override_					public boolean apply(@Nullable StateTransition<T> input) {_						return input != null && input.getAction() == StateTransitionAction.IGNORE__					}__				}, null)___			oldSecond = oldSecondToThirdTake.getTargetState()___			oldSecondToThirdTake = Iterators.find(_				oldSecond.getStateTransitions().iterator(),_				new Predicate<StateTransition<T>>() {_					@Override_					public boolean apply(@Nullable StateTransition<T> input) {_						return input != null && input.getAction() == StateTransitionAction.TAKE__					}__				}, null)___			newFirst = newSecond__		}__		final State<T> endingState = new State<>(ENDING_STATE_NAME, State.StateType.Final)___		newFirst.addTake(endingState, oldFirstToSecondTake.getCondition())___		if (oldFirstIgnore != null) {_			newFirst.addIgnore(oldFirstIgnore.getCondition())__		}__		convertedStates.put(endingState.getName(), endingState)___		return convertedStates__	};used,for,migrating,cep,graphs,prior,to,1,3,it,removes,the,dummy,start,adds,the,dummy,end,and,translates,all,states,to,consuming,ones,by,moving,all,takes,and,ignores,to,the,next,state,this,method,assumes,each,state,has,at,most,one,take,and,one,ignore,and,name,of,each,state,is,unique,no,proceed,transition,is,allowed,param,old,start,state,dummy,start,state,of,old,graph,param,t,type,of,events,return,map,of,new,states,where,key,is,the,name,of,a,state,and,value,is,the,state,itself;internal,public,static,t,map,string,state,t,migrate,graph,state,t,old,start,state,state,t,old,first,old,start,state,state,t,old,second,old,start,state,get,state,transitions,iterator,next,get,target,state,state,transition,t,old,first,to,second,take,iterators,find,old,first,get,state,transitions,iterator,new,predicate,state,transition,t,override,public,boolean,apply,nullable,state,transition,t,input,return,input,null,input,get,action,state,transition,action,take,state,transition,t,old,first,ignore,iterators,find,old,first,get,state,transitions,iterator,new,predicate,state,transition,t,override,public,boolean,apply,nullable,state,transition,t,input,return,input,null,input,get,action,state,transition,action,ignore,null,state,transition,t,old,second,to,third,take,iterators,find,old,second,get,state,transitions,iterator,new,predicate,state,transition,t,override,public,boolean,apply,nullable,state,transition,t,input,return,input,null,input,get,action,state,transition,action,take,null,final,map,string,state,t,converted,states,new,hash,map,state,t,new,second,state,t,new,first,new,state,old,second,get,name,state,state,type,start,converted,states,put,new,first,get,name,new,first,while,old,second,to,third,take,null,new,second,new,state,t,old,second,to,third,take,get,target,state,get,name,state,state,type,normal,converted,states,put,new,second,get,name,new,second,new,first,add,take,new,second,old,first,to,second,take,get,condition,if,old,first,ignore,null,new,first,add,ignore,old,first,ignore,get,condition,old,first,old,second,old,first,to,second,take,iterators,find,old,first,get,state,transitions,iterator,new,predicate,state,transition,t,override,public,boolean,apply,nullable,state,transition,t,input,return,input,null,input,get,action,state,transition,action,take,old,first,ignore,iterators,find,old,first,get,state,transitions,iterator,new,predicate,state,transition,t,override,public,boolean,apply,nullable,state,transition,t,input,return,input,null,input,get,action,state,transition,action,ignore,null,old,second,old,second,to,third,take,get,target,state,old,second,to,third,take,iterators,find,old,second,get,state,transitions,iterator,new,predicate,state,transition,t,override,public,boolean,apply,nullable,state,transition,t,input,return,input,null,input,get,action,state,transition,action,take,null,new,first,new,second,final,state,t,ending,state,new,state,state,state,type,final,new,first,add,take,ending,state,old,first,to,second,take,get,condition,if,old,first,ignore,null,new,first,add,ignore,old,first,ignore,get,condition,converted,states,put,ending,state,get,name,ending,state,return,converted,states
NFACompiler -> @Internal 	public static <T> Map<String, State<T>> migrateGraph(State<T> oldStartState);1496245714;Used for migrating CEP graphs prior to 1.3. It removes the dummy start, adds the dummy end, and translates all_states to consuming ones by moving all TAKEs and IGNOREs to the next state. This method assumes each state_has at most one TAKE and one IGNORE and name of each state is unique. No PROCEED transition is allowed!__@param oldStartState dummy start state of old graph_@param <T>           type of events_@return map of new states, where key is the name of a state and value is the state itself;@Internal_	public static <T> Map<String, State<T>> migrateGraph(State<T> oldStartState) {_		State<T> oldFirst = oldStartState__		State<T> oldSecond = oldStartState.getStateTransitions().iterator().next().getTargetState()___		StateTransition<T> oldFirstToSecondTake = Iterators.find(_			oldFirst.getStateTransitions().iterator(),_			new Predicate<StateTransition<T>>() {_				@Override_				public boolean apply(@Nullable StateTransition<T> input) {_					return input != null && input.getAction() == StateTransitionAction.TAKE__				}__			})___		StateTransition<T> oldFirstIgnore = Iterators.find(_			oldFirst.getStateTransitions().iterator(),_			new Predicate<StateTransition<T>>() {_				@Override_				public boolean apply(@Nullable StateTransition<T> input) {_					return input != null && input.getAction() == StateTransitionAction.IGNORE__				}__			}, null)___		StateTransition<T> oldSecondToThirdTake = Iterators.find(_			oldSecond.getStateTransitions().iterator(),_			new Predicate<StateTransition<T>>() {_				@Override_				public boolean apply(@Nullable StateTransition<T> input) {_					return input != null && input.getAction() == StateTransitionAction.TAKE__				}__			}, null)___		final Map<String, State<T>> convertedStates = new HashMap<>()__		State<T> newSecond__		State<T> newFirst = new State<>(oldSecond.getName(), State.StateType.Start)__		convertedStates.put(newFirst.getName(), newFirst)__		while (oldSecondToThirdTake != null) {__			newSecond = new State<T>(oldSecondToThirdTake.getTargetState().getName(), State.StateType.Normal)__			convertedStates.put(newSecond.getName(), newSecond)__			newFirst.addTake(newSecond, oldFirstToSecondTake.getCondition())___			if (oldFirstIgnore != null) {_				newFirst.addIgnore(oldFirstIgnore.getCondition())__			}__			oldFirst = oldSecond___			oldFirstToSecondTake = Iterators.find(_				oldFirst.getStateTransitions().iterator(),_				new Predicate<StateTransition<T>>() {_					@Override_					public boolean apply(@Nullable StateTransition<T> input) {_						return input != null && input.getAction() == StateTransitionAction.TAKE__					}__				})___			oldFirstIgnore = Iterators.find(_				oldFirst.getStateTransitions().iterator(),_				new Predicate<StateTransition<T>>() {_					@Override_					public boolean apply(@Nullable StateTransition<T> input) {_						return input != null && input.getAction() == StateTransitionAction.IGNORE__					}__				}, null)___			oldSecond = oldSecondToThirdTake.getTargetState()___			oldSecondToThirdTake = Iterators.find(_				oldSecond.getStateTransitions().iterator(),_				new Predicate<StateTransition<T>>() {_					@Override_					public boolean apply(@Nullable StateTransition<T> input) {_						return input != null && input.getAction() == StateTransitionAction.TAKE__					}__				}, null)___			newFirst = newSecond__		}__		final State<T> endingState = new State<>(ENDING_STATE_NAME, State.StateType.Final)___		newFirst.addTake(endingState, oldFirstToSecondTake.getCondition())___		if (oldFirstIgnore != null) {_			newFirst.addIgnore(oldFirstIgnore.getCondition())__		}__		convertedStates.put(endingState.getName(), endingState)___		return convertedStates__	};used,for,migrating,cep,graphs,prior,to,1,3,it,removes,the,dummy,start,adds,the,dummy,end,and,translates,all,states,to,consuming,ones,by,moving,all,takes,and,ignores,to,the,next,state,this,method,assumes,each,state,has,at,most,one,take,and,one,ignore,and,name,of,each,state,is,unique,no,proceed,transition,is,allowed,param,old,start,state,dummy,start,state,of,old,graph,param,t,type,of,events,return,map,of,new,states,where,key,is,the,name,of,a,state,and,value,is,the,state,itself;internal,public,static,t,map,string,state,t,migrate,graph,state,t,old,start,state,state,t,old,first,old,start,state,state,t,old,second,old,start,state,get,state,transitions,iterator,next,get,target,state,state,transition,t,old,first,to,second,take,iterators,find,old,first,get,state,transitions,iterator,new,predicate,state,transition,t,override,public,boolean,apply,nullable,state,transition,t,input,return,input,null,input,get,action,state,transition,action,take,state,transition,t,old,first,ignore,iterators,find,old,first,get,state,transitions,iterator,new,predicate,state,transition,t,override,public,boolean,apply,nullable,state,transition,t,input,return,input,null,input,get,action,state,transition,action,ignore,null,state,transition,t,old,second,to,third,take,iterators,find,old,second,get,state,transitions,iterator,new,predicate,state,transition,t,override,public,boolean,apply,nullable,state,transition,t,input,return,input,null,input,get,action,state,transition,action,take,null,final,map,string,state,t,converted,states,new,hash,map,state,t,new,second,state,t,new,first,new,state,old,second,get,name,state,state,type,start,converted,states,put,new,first,get,name,new,first,while,old,second,to,third,take,null,new,second,new,state,t,old,second,to,third,take,get,target,state,get,name,state,state,type,normal,converted,states,put,new,second,get,name,new,second,new,first,add,take,new,second,old,first,to,second,take,get,condition,if,old,first,ignore,null,new,first,add,ignore,old,first,ignore,get,condition,old,first,old,second,old,first,to,second,take,iterators,find,old,first,get,state,transitions,iterator,new,predicate,state,transition,t,override,public,boolean,apply,nullable,state,transition,t,input,return,input,null,input,get,action,state,transition,action,take,old,first,ignore,iterators,find,old,first,get,state,transitions,iterator,new,predicate,state,transition,t,override,public,boolean,apply,nullable,state,transition,t,input,return,input,null,input,get,action,state,transition,action,ignore,null,old,second,old,second,to,third,take,get,target,state,old,second,to,third,take,iterators,find,old,second,get,state,transitions,iterator,new,predicate,state,transition,t,override,public,boolean,apply,nullable,state,transition,t,input,return,input,null,input,get,action,state,transition,action,take,null,new,first,new,second,final,state,t,ending,state,new,state,state,state,type,final,new,first,add,take,ending,state,old,first,to,second,take,get,condition,if,old,first,ignore,null,new,first,add,ignore,old,first,ignore,get,condition,converted,states,put,ending,state,get,name,ending,state,return,converted,states
NFACompiler -> @Internal 	public static <T> Map<String, State<T>> migrateGraph(State<T> oldStartState);1497410381;Used for migrating CEP graphs prior to 1.3. It removes the dummy start, adds the dummy end, and translates all_states to consuming ones by moving all TAKEs and IGNOREs to the next state. This method assumes each state_has at most one TAKE and one IGNORE and name of each state is unique. No PROCEED transition is allowed!__@param oldStartState dummy start state of old graph_@param <T>           type of events_@return map of new states, where key is the name of a state and value is the state itself;@Internal_	public static <T> Map<String, State<T>> migrateGraph(State<T> oldStartState) {_		State<T> oldFirst = oldStartState__		State<T> oldSecond = oldStartState.getStateTransitions().iterator().next().getTargetState()___		StateTransition<T> oldFirstToSecondTake = Iterators.find(_			oldFirst.getStateTransitions().iterator(),_			new Predicate<StateTransition<T>>() {_				@Override_				public boolean apply(@Nullable StateTransition<T> input) {_					return input != null && input.getAction() == StateTransitionAction.TAKE__				}__			})___		StateTransition<T> oldFirstIgnore = Iterators.find(_			oldFirst.getStateTransitions().iterator(),_			new Predicate<StateTransition<T>>() {_				@Override_				public boolean apply(@Nullable StateTransition<T> input) {_					return input != null && input.getAction() == StateTransitionAction.IGNORE__				}__			}, null)___		StateTransition<T> oldSecondToThirdTake = Iterators.find(_			oldSecond.getStateTransitions().iterator(),_			new Predicate<StateTransition<T>>() {_				@Override_				public boolean apply(@Nullable StateTransition<T> input) {_					return input != null && input.getAction() == StateTransitionAction.TAKE__				}__			}, null)___		final Map<String, State<T>> convertedStates = new HashMap<>()__		State<T> newSecond__		State<T> newFirst = new State<>(oldSecond.getName(), State.StateType.Start)__		convertedStates.put(newFirst.getName(), newFirst)__		while (oldSecondToThirdTake != null) {__			newSecond = new State<T>(oldSecondToThirdTake.getTargetState().getName(), State.StateType.Normal)__			convertedStates.put(newSecond.getName(), newSecond)__			newFirst.addTake(newSecond, oldFirstToSecondTake.getCondition())___			if (oldFirstIgnore != null) {_				newFirst.addIgnore(oldFirstIgnore.getCondition())__			}__			oldFirst = oldSecond___			oldFirstToSecondTake = Iterators.find(_				oldFirst.getStateTransitions().iterator(),_				new Predicate<StateTransition<T>>() {_					@Override_					public boolean apply(@Nullable StateTransition<T> input) {_						return input != null && input.getAction() == StateTransitionAction.TAKE__					}__				})___			oldFirstIgnore = Iterators.find(_				oldFirst.getStateTransitions().iterator(),_				new Predicate<StateTransition<T>>() {_					@Override_					public boolean apply(@Nullable StateTransition<T> input) {_						return input != null && input.getAction() == StateTransitionAction.IGNORE__					}__				}, null)___			oldSecond = oldSecondToThirdTake.getTargetState()___			oldSecondToThirdTake = Iterators.find(_				oldSecond.getStateTransitions().iterator(),_				new Predicate<StateTransition<T>>() {_					@Override_					public boolean apply(@Nullable StateTransition<T> input) {_						return input != null && input.getAction() == StateTransitionAction.TAKE__					}__				}, null)___			newFirst = newSecond__		}__		final State<T> endingState = new State<>(ENDING_STATE_NAME, State.StateType.Final)___		newFirst.addTake(endingState, oldFirstToSecondTake.getCondition())___		if (oldFirstIgnore != null) {_			newFirst.addIgnore(oldFirstIgnore.getCondition())__		}__		convertedStates.put(endingState.getName(), endingState)___		return convertedStates__	};used,for,migrating,cep,graphs,prior,to,1,3,it,removes,the,dummy,start,adds,the,dummy,end,and,translates,all,states,to,consuming,ones,by,moving,all,takes,and,ignores,to,the,next,state,this,method,assumes,each,state,has,at,most,one,take,and,one,ignore,and,name,of,each,state,is,unique,no,proceed,transition,is,allowed,param,old,start,state,dummy,start,state,of,old,graph,param,t,type,of,events,return,map,of,new,states,where,key,is,the,name,of,a,state,and,value,is,the,state,itself;internal,public,static,t,map,string,state,t,migrate,graph,state,t,old,start,state,state,t,old,first,old,start,state,state,t,old,second,old,start,state,get,state,transitions,iterator,next,get,target,state,state,transition,t,old,first,to,second,take,iterators,find,old,first,get,state,transitions,iterator,new,predicate,state,transition,t,override,public,boolean,apply,nullable,state,transition,t,input,return,input,null,input,get,action,state,transition,action,take,state,transition,t,old,first,ignore,iterators,find,old,first,get,state,transitions,iterator,new,predicate,state,transition,t,override,public,boolean,apply,nullable,state,transition,t,input,return,input,null,input,get,action,state,transition,action,ignore,null,state,transition,t,old,second,to,third,take,iterators,find,old,second,get,state,transitions,iterator,new,predicate,state,transition,t,override,public,boolean,apply,nullable,state,transition,t,input,return,input,null,input,get,action,state,transition,action,take,null,final,map,string,state,t,converted,states,new,hash,map,state,t,new,second,state,t,new,first,new,state,old,second,get,name,state,state,type,start,converted,states,put,new,first,get,name,new,first,while,old,second,to,third,take,null,new,second,new,state,t,old,second,to,third,take,get,target,state,get,name,state,state,type,normal,converted,states,put,new,second,get,name,new,second,new,first,add,take,new,second,old,first,to,second,take,get,condition,if,old,first,ignore,null,new,first,add,ignore,old,first,ignore,get,condition,old,first,old,second,old,first,to,second,take,iterators,find,old,first,get,state,transitions,iterator,new,predicate,state,transition,t,override,public,boolean,apply,nullable,state,transition,t,input,return,input,null,input,get,action,state,transition,action,take,old,first,ignore,iterators,find,old,first,get,state,transitions,iterator,new,predicate,state,transition,t,override,public,boolean,apply,nullable,state,transition,t,input,return,input,null,input,get,action,state,transition,action,ignore,null,old,second,old,second,to,third,take,get,target,state,old,second,to,third,take,iterators,find,old,second,get,state,transitions,iterator,new,predicate,state,transition,t,override,public,boolean,apply,nullable,state,transition,t,input,return,input,null,input,get,action,state,transition,action,take,null,new,first,new,second,final,state,t,ending,state,new,state,state,state,type,final,new,first,add,take,ending,state,old,first,to,second,take,get,condition,if,old,first,ignore,null,new,first,add,ignore,old,first,ignore,get,condition,converted,states,put,ending,state,get,name,ending,state,return,converted,states
NFACompiler -> @Internal 	public static <T> Map<String, State<T>> migrateGraph(State<T> oldStartState);1497883202;Used for migrating CEP graphs prior to 1.3. It removes the dummy start, adds the dummy end, and translates all_states to consuming ones by moving all TAKEs and IGNOREs to the next state. This method assumes each state_has at most one TAKE and one IGNORE and name of each state is unique. No PROCEED transition is allowed!__@param oldStartState dummy start state of old graph_@param <T>           type of events_@return map of new states, where key is the name of a state and value is the state itself;@Internal_	public static <T> Map<String, State<T>> migrateGraph(State<T> oldStartState) {_		State<T> oldFirst = oldStartState__		State<T> oldSecond = oldStartState.getStateTransitions().iterator().next().getTargetState()___		StateTransition<T> oldFirstToSecondTake = Iterators.find(_			oldFirst.getStateTransitions().iterator(),_			new Predicate<StateTransition<T>>() {_				@Override_				public boolean apply(@Nullable StateTransition<T> input) {_					return input != null && input.getAction() == StateTransitionAction.TAKE__				}__			})___		StateTransition<T> oldFirstIgnore = Iterators.find(_			oldFirst.getStateTransitions().iterator(),_			new Predicate<StateTransition<T>>() {_				@Override_				public boolean apply(@Nullable StateTransition<T> input) {_					return input != null && input.getAction() == StateTransitionAction.IGNORE__				}__			}, null)___		StateTransition<T> oldSecondToThirdTake = Iterators.find(_			oldSecond.getStateTransitions().iterator(),_			new Predicate<StateTransition<T>>() {_				@Override_				public boolean apply(@Nullable StateTransition<T> input) {_					return input != null && input.getAction() == StateTransitionAction.TAKE__				}__			}, null)___		final Map<String, State<T>> convertedStates = new HashMap<>()__		State<T> newSecond__		State<T> newFirst = new State<>(oldSecond.getName(), State.StateType.Start)__		convertedStates.put(newFirst.getName(), newFirst)__		while (oldSecondToThirdTake != null) {__			newSecond = new State<T>(oldSecondToThirdTake.getTargetState().getName(), State.StateType.Normal)__			convertedStates.put(newSecond.getName(), newSecond)__			newFirst.addTake(newSecond, oldFirstToSecondTake.getCondition())___			if (oldFirstIgnore != null) {_				newFirst.addIgnore(oldFirstIgnore.getCondition())__			}__			oldFirst = oldSecond___			oldFirstToSecondTake = Iterators.find(_				oldFirst.getStateTransitions().iterator(),_				new Predicate<StateTransition<T>>() {_					@Override_					public boolean apply(@Nullable StateTransition<T> input) {_						return input != null && input.getAction() == StateTransitionAction.TAKE__					}__				})___			oldFirstIgnore = Iterators.find(_				oldFirst.getStateTransitions().iterator(),_				new Predicate<StateTransition<T>>() {_					@Override_					public boolean apply(@Nullable StateTransition<T> input) {_						return input != null && input.getAction() == StateTransitionAction.IGNORE__					}__				}, null)___			oldSecond = oldSecondToThirdTake.getTargetState()___			oldSecondToThirdTake = Iterators.find(_				oldSecond.getStateTransitions().iterator(),_				new Predicate<StateTransition<T>>() {_					@Override_					public boolean apply(@Nullable StateTransition<T> input) {_						return input != null && input.getAction() == StateTransitionAction.TAKE__					}__				}, null)___			newFirst = newSecond__		}__		final State<T> endingState = new State<>(ENDING_STATE_NAME, State.StateType.Final)___		newFirst.addTake(endingState, oldFirstToSecondTake.getCondition())___		if (oldFirstIgnore != null) {_			newFirst.addIgnore(oldFirstIgnore.getCondition())__		}__		convertedStates.put(endingState.getName(), endingState)___		return convertedStates__	};used,for,migrating,cep,graphs,prior,to,1,3,it,removes,the,dummy,start,adds,the,dummy,end,and,translates,all,states,to,consuming,ones,by,moving,all,takes,and,ignores,to,the,next,state,this,method,assumes,each,state,has,at,most,one,take,and,one,ignore,and,name,of,each,state,is,unique,no,proceed,transition,is,allowed,param,old,start,state,dummy,start,state,of,old,graph,param,t,type,of,events,return,map,of,new,states,where,key,is,the,name,of,a,state,and,value,is,the,state,itself;internal,public,static,t,map,string,state,t,migrate,graph,state,t,old,start,state,state,t,old,first,old,start,state,state,t,old,second,old,start,state,get,state,transitions,iterator,next,get,target,state,state,transition,t,old,first,to,second,take,iterators,find,old,first,get,state,transitions,iterator,new,predicate,state,transition,t,override,public,boolean,apply,nullable,state,transition,t,input,return,input,null,input,get,action,state,transition,action,take,state,transition,t,old,first,ignore,iterators,find,old,first,get,state,transitions,iterator,new,predicate,state,transition,t,override,public,boolean,apply,nullable,state,transition,t,input,return,input,null,input,get,action,state,transition,action,ignore,null,state,transition,t,old,second,to,third,take,iterators,find,old,second,get,state,transitions,iterator,new,predicate,state,transition,t,override,public,boolean,apply,nullable,state,transition,t,input,return,input,null,input,get,action,state,transition,action,take,null,final,map,string,state,t,converted,states,new,hash,map,state,t,new,second,state,t,new,first,new,state,old,second,get,name,state,state,type,start,converted,states,put,new,first,get,name,new,first,while,old,second,to,third,take,null,new,second,new,state,t,old,second,to,third,take,get,target,state,get,name,state,state,type,normal,converted,states,put,new,second,get,name,new,second,new,first,add,take,new,second,old,first,to,second,take,get,condition,if,old,first,ignore,null,new,first,add,ignore,old,first,ignore,get,condition,old,first,old,second,old,first,to,second,take,iterators,find,old,first,get,state,transitions,iterator,new,predicate,state,transition,t,override,public,boolean,apply,nullable,state,transition,t,input,return,input,null,input,get,action,state,transition,action,take,old,first,ignore,iterators,find,old,first,get,state,transitions,iterator,new,predicate,state,transition,t,override,public,boolean,apply,nullable,state,transition,t,input,return,input,null,input,get,action,state,transition,action,ignore,null,old,second,old,second,to,third,take,get,target,state,old,second,to,third,take,iterators,find,old,second,get,state,transitions,iterator,new,predicate,state,transition,t,override,public,boolean,apply,nullable,state,transition,t,input,return,input,null,input,get,action,state,transition,action,take,null,new,first,new,second,final,state,t,ending,state,new,state,state,state,type,final,new,first,add,take,ending,state,old,first,to,second,take,get,condition,if,old,first,ignore,null,new,first,add,ignore,old,first,ignore,get,condition,converted,states,put,ending,state,get,name,ending,state,return,converted,states
NFACompiler -> @Internal 	public static <T> Map<String, State<T>> migrateGraph(State<T> oldStartState);1498034481;Used for migrating CEP graphs prior to 1.3. It removes the dummy start, adds the dummy end, and translates all_states to consuming ones by moving all TAKEs and IGNOREs to the next state. This method assumes each state_has at most one TAKE and one IGNORE and name of each state is unique. No PROCEED transition is allowed!__@param oldStartState dummy start state of old graph_@param <T>           type of events_@return map of new states, where key is the name of a state and value is the state itself;@Internal_	public static <T> Map<String, State<T>> migrateGraph(State<T> oldStartState) {_		State<T> oldFirst = oldStartState__		State<T> oldSecond = oldStartState.getStateTransitions().iterator().next().getTargetState()___		StateTransition<T> oldFirstToSecondTake = Iterators.find(_			oldFirst.getStateTransitions().iterator(),_			new Predicate<StateTransition<T>>() {_				@Override_				public boolean apply(@Nullable StateTransition<T> input) {_					return input != null && input.getAction() == StateTransitionAction.TAKE__				}__			})___		StateTransition<T> oldFirstIgnore = Iterators.find(_			oldFirst.getStateTransitions().iterator(),_			new Predicate<StateTransition<T>>() {_				@Override_				public boolean apply(@Nullable StateTransition<T> input) {_					return input != null && input.getAction() == StateTransitionAction.IGNORE__				}__			}, null)___		StateTransition<T> oldSecondToThirdTake = Iterators.find(_			oldSecond.getStateTransitions().iterator(),_			new Predicate<StateTransition<T>>() {_				@Override_				public boolean apply(@Nullable StateTransition<T> input) {_					return input != null && input.getAction() == StateTransitionAction.TAKE__				}__			}, null)___		final Map<String, State<T>> convertedStates = new HashMap<>()__		State<T> newSecond__		State<T> newFirst = new State<>(oldSecond.getName(), State.StateType.Start)__		convertedStates.put(newFirst.getName(), newFirst)__		while (oldSecondToThirdTake != null) {__			newSecond = new State<T>(oldSecondToThirdTake.getTargetState().getName(), State.StateType.Normal)__			convertedStates.put(newSecond.getName(), newSecond)__			newFirst.addTake(newSecond, oldFirstToSecondTake.getCondition())___			if (oldFirstIgnore != null) {_				newFirst.addIgnore(oldFirstIgnore.getCondition())__			}__			oldFirst = oldSecond___			oldFirstToSecondTake = Iterators.find(_				oldFirst.getStateTransitions().iterator(),_				new Predicate<StateTransition<T>>() {_					@Override_					public boolean apply(@Nullable StateTransition<T> input) {_						return input != null && input.getAction() == StateTransitionAction.TAKE__					}__				})___			oldFirstIgnore = Iterators.find(_				oldFirst.getStateTransitions().iterator(),_				new Predicate<StateTransition<T>>() {_					@Override_					public boolean apply(@Nullable StateTransition<T> input) {_						return input != null && input.getAction() == StateTransitionAction.IGNORE__					}__				}, null)___			oldSecond = oldSecondToThirdTake.getTargetState()___			oldSecondToThirdTake = Iterators.find(_				oldSecond.getStateTransitions().iterator(),_				new Predicate<StateTransition<T>>() {_					@Override_					public boolean apply(@Nullable StateTransition<T> input) {_						return input != null && input.getAction() == StateTransitionAction.TAKE__					}__				}, null)___			newFirst = newSecond__		}__		final State<T> endingState = new State<>(ENDING_STATE_NAME, State.StateType.Final)___		newFirst.addTake(endingState, oldFirstToSecondTake.getCondition())___		if (oldFirstIgnore != null) {_			newFirst.addIgnore(oldFirstIgnore.getCondition())__		}__		convertedStates.put(endingState.getName(), endingState)___		return convertedStates__	};used,for,migrating,cep,graphs,prior,to,1,3,it,removes,the,dummy,start,adds,the,dummy,end,and,translates,all,states,to,consuming,ones,by,moving,all,takes,and,ignores,to,the,next,state,this,method,assumes,each,state,has,at,most,one,take,and,one,ignore,and,name,of,each,state,is,unique,no,proceed,transition,is,allowed,param,old,start,state,dummy,start,state,of,old,graph,param,t,type,of,events,return,map,of,new,states,where,key,is,the,name,of,a,state,and,value,is,the,state,itself;internal,public,static,t,map,string,state,t,migrate,graph,state,t,old,start,state,state,t,old,first,old,start,state,state,t,old,second,old,start,state,get,state,transitions,iterator,next,get,target,state,state,transition,t,old,first,to,second,take,iterators,find,old,first,get,state,transitions,iterator,new,predicate,state,transition,t,override,public,boolean,apply,nullable,state,transition,t,input,return,input,null,input,get,action,state,transition,action,take,state,transition,t,old,first,ignore,iterators,find,old,first,get,state,transitions,iterator,new,predicate,state,transition,t,override,public,boolean,apply,nullable,state,transition,t,input,return,input,null,input,get,action,state,transition,action,ignore,null,state,transition,t,old,second,to,third,take,iterators,find,old,second,get,state,transitions,iterator,new,predicate,state,transition,t,override,public,boolean,apply,nullable,state,transition,t,input,return,input,null,input,get,action,state,transition,action,take,null,final,map,string,state,t,converted,states,new,hash,map,state,t,new,second,state,t,new,first,new,state,old,second,get,name,state,state,type,start,converted,states,put,new,first,get,name,new,first,while,old,second,to,third,take,null,new,second,new,state,t,old,second,to,third,take,get,target,state,get,name,state,state,type,normal,converted,states,put,new,second,get,name,new,second,new,first,add,take,new,second,old,first,to,second,take,get,condition,if,old,first,ignore,null,new,first,add,ignore,old,first,ignore,get,condition,old,first,old,second,old,first,to,second,take,iterators,find,old,first,get,state,transitions,iterator,new,predicate,state,transition,t,override,public,boolean,apply,nullable,state,transition,t,input,return,input,null,input,get,action,state,transition,action,take,old,first,ignore,iterators,find,old,first,get,state,transitions,iterator,new,predicate,state,transition,t,override,public,boolean,apply,nullable,state,transition,t,input,return,input,null,input,get,action,state,transition,action,ignore,null,old,second,old,second,to,third,take,get,target,state,old,second,to,third,take,iterators,find,old,second,get,state,transitions,iterator,new,predicate,state,transition,t,override,public,boolean,apply,nullable,state,transition,t,input,return,input,null,input,get,action,state,transition,action,take,null,new,first,new,second,final,state,t,ending,state,new,state,state,state,type,final,new,first,add,take,ending,state,old,first,to,second,take,get,condition,if,old,first,ignore,null,new,first,add,ignore,old,first,ignore,get,condition,converted,states,put,ending,state,get,name,ending,state,return,converted,states
NFACompiler -> @Internal 	public static <T> Map<String, State<T>> migrateGraph(State<T> oldStartState);1499760222;Used for migrating CEP graphs prior to 1.3. It removes the dummy start, adds the dummy end, and translates all_states to consuming ones by moving all TAKEs and IGNOREs to the next state. This method assumes each state_has at most one TAKE and one IGNORE and name of each state is unique. No PROCEED transition is allowed!__@param oldStartState dummy start state of old graph_@param <T>           type of events_@return map of new states, where key is the name of a state and value is the state itself;@Internal_	public static <T> Map<String, State<T>> migrateGraph(State<T> oldStartState) {_		State<T> oldFirst = oldStartState__		State<T> oldSecond = oldStartState.getStateTransitions().iterator().next().getTargetState()___		StateTransition<T> oldFirstToSecondTake = Iterators.find(_			oldFirst.getStateTransitions().iterator(),_			new Predicate<StateTransition<T>>() {_				@Override_				public boolean apply(@Nullable StateTransition<T> input) {_					return input != null && input.getAction() == StateTransitionAction.TAKE__				}__			})___		StateTransition<T> oldFirstIgnore = Iterators.find(_			oldFirst.getStateTransitions().iterator(),_			new Predicate<StateTransition<T>>() {_				@Override_				public boolean apply(@Nullable StateTransition<T> input) {_					return input != null && input.getAction() == StateTransitionAction.IGNORE__				}__			}, null)___		StateTransition<T> oldSecondToThirdTake = Iterators.find(_			oldSecond.getStateTransitions().iterator(),_			new Predicate<StateTransition<T>>() {_				@Override_				public boolean apply(@Nullable StateTransition<T> input) {_					return input != null && input.getAction() == StateTransitionAction.TAKE__				}__			}, null)___		final Map<String, State<T>> convertedStates = new HashMap<>()__		State<T> newSecond__		State<T> newFirst = new State<>(oldSecond.getName(), State.StateType.Start)__		convertedStates.put(newFirst.getName(), newFirst)__		while (oldSecondToThirdTake != null) {__			newSecond = new State<T>(oldSecondToThirdTake.getTargetState().getName(), State.StateType.Normal)__			convertedStates.put(newSecond.getName(), newSecond)__			newFirst.addTake(newSecond, oldFirstToSecondTake.getCondition())___			if (oldFirstIgnore != null) {_				newFirst.addIgnore(oldFirstIgnore.getCondition())__			}__			oldFirst = oldSecond___			oldFirstToSecondTake = Iterators.find(_				oldFirst.getStateTransitions().iterator(),_				new Predicate<StateTransition<T>>() {_					@Override_					public boolean apply(@Nullable StateTransition<T> input) {_						return input != null && input.getAction() == StateTransitionAction.TAKE__					}__				})___			oldFirstIgnore = Iterators.find(_				oldFirst.getStateTransitions().iterator(),_				new Predicate<StateTransition<T>>() {_					@Override_					public boolean apply(@Nullable StateTransition<T> input) {_						return input != null && input.getAction() == StateTransitionAction.IGNORE__					}__				}, null)___			oldSecond = oldSecondToThirdTake.getTargetState()___			oldSecondToThirdTake = Iterators.find(_				oldSecond.getStateTransitions().iterator(),_				new Predicate<StateTransition<T>>() {_					@Override_					public boolean apply(@Nullable StateTransition<T> input) {_						return input != null && input.getAction() == StateTransitionAction.TAKE__					}__				}, null)___			newFirst = newSecond__		}__		final State<T> endingState = new State<>(ENDING_STATE_NAME, State.StateType.Final)___		newFirst.addTake(endingState, oldFirstToSecondTake.getCondition())___		if (oldFirstIgnore != null) {_			newFirst.addIgnore(oldFirstIgnore.getCondition())__		}__		convertedStates.put(endingState.getName(), endingState)___		return convertedStates__	};used,for,migrating,cep,graphs,prior,to,1,3,it,removes,the,dummy,start,adds,the,dummy,end,and,translates,all,states,to,consuming,ones,by,moving,all,takes,and,ignores,to,the,next,state,this,method,assumes,each,state,has,at,most,one,take,and,one,ignore,and,name,of,each,state,is,unique,no,proceed,transition,is,allowed,param,old,start,state,dummy,start,state,of,old,graph,param,t,type,of,events,return,map,of,new,states,where,key,is,the,name,of,a,state,and,value,is,the,state,itself;internal,public,static,t,map,string,state,t,migrate,graph,state,t,old,start,state,state,t,old,first,old,start,state,state,t,old,second,old,start,state,get,state,transitions,iterator,next,get,target,state,state,transition,t,old,first,to,second,take,iterators,find,old,first,get,state,transitions,iterator,new,predicate,state,transition,t,override,public,boolean,apply,nullable,state,transition,t,input,return,input,null,input,get,action,state,transition,action,take,state,transition,t,old,first,ignore,iterators,find,old,first,get,state,transitions,iterator,new,predicate,state,transition,t,override,public,boolean,apply,nullable,state,transition,t,input,return,input,null,input,get,action,state,transition,action,ignore,null,state,transition,t,old,second,to,third,take,iterators,find,old,second,get,state,transitions,iterator,new,predicate,state,transition,t,override,public,boolean,apply,nullable,state,transition,t,input,return,input,null,input,get,action,state,transition,action,take,null,final,map,string,state,t,converted,states,new,hash,map,state,t,new,second,state,t,new,first,new,state,old,second,get,name,state,state,type,start,converted,states,put,new,first,get,name,new,first,while,old,second,to,third,take,null,new,second,new,state,t,old,second,to,third,take,get,target,state,get,name,state,state,type,normal,converted,states,put,new,second,get,name,new,second,new,first,add,take,new,second,old,first,to,second,take,get,condition,if,old,first,ignore,null,new,first,add,ignore,old,first,ignore,get,condition,old,first,old,second,old,first,to,second,take,iterators,find,old,first,get,state,transitions,iterator,new,predicate,state,transition,t,override,public,boolean,apply,nullable,state,transition,t,input,return,input,null,input,get,action,state,transition,action,take,old,first,ignore,iterators,find,old,first,get,state,transitions,iterator,new,predicate,state,transition,t,override,public,boolean,apply,nullable,state,transition,t,input,return,input,null,input,get,action,state,transition,action,ignore,null,old,second,old,second,to,third,take,get,target,state,old,second,to,third,take,iterators,find,old,second,get,state,transitions,iterator,new,predicate,state,transition,t,override,public,boolean,apply,nullable,state,transition,t,input,return,input,null,input,get,action,state,transition,action,take,null,new,first,new,second,final,state,t,ending,state,new,state,state,state,type,final,new,first,add,take,ending,state,old,first,to,second,take,get,condition,if,old,first,ignore,null,new,first,add,ignore,old,first,ignore,get,condition,converted,states,put,ending,state,get,name,ending,state,return,converted,states
NFACompiler -> @Internal 	public static <T> Map<String, State<T>> migrateGraph(State<T> oldStartState);1499937690;Used for migrating CEP graphs prior to 1.3. It removes the dummy start, adds the dummy end, and translates all_states to consuming ones by moving all TAKEs and IGNOREs to the next state. This method assumes each state_has at most one TAKE and one IGNORE and name of each state is unique. No PROCEED transition is allowed!__@param oldStartState dummy start state of old graph_@param <T>           type of events_@return map of new states, where key is the name of a state and value is the state itself;@Internal_	public static <T> Map<String, State<T>> migrateGraph(State<T> oldStartState) {_		State<T> oldFirst = oldStartState__		State<T> oldSecond = oldStartState.getStateTransitions().iterator().next().getTargetState()___		StateTransition<T> oldFirstToSecondTake = Iterators.find(_			oldFirst.getStateTransitions().iterator(),_			new Predicate<StateTransition<T>>() {_				@Override_				public boolean apply(@Nullable StateTransition<T> input) {_					return input != null && input.getAction() == StateTransitionAction.TAKE__				}__			})___		StateTransition<T> oldFirstIgnore = Iterators.find(_			oldFirst.getStateTransitions().iterator(),_			new Predicate<StateTransition<T>>() {_				@Override_				public boolean apply(@Nullable StateTransition<T> input) {_					return input != null && input.getAction() == StateTransitionAction.IGNORE__				}__			}, null)___		StateTransition<T> oldSecondToThirdTake = Iterators.find(_			oldSecond.getStateTransitions().iterator(),_			new Predicate<StateTransition<T>>() {_				@Override_				public boolean apply(@Nullable StateTransition<T> input) {_					return input != null && input.getAction() == StateTransitionAction.TAKE__				}__			}, null)___		final Map<String, State<T>> convertedStates = new HashMap<>()__		State<T> newSecond__		State<T> newFirst = new State<>(oldSecond.getName(), State.StateType.Start)__		convertedStates.put(newFirst.getName(), newFirst)__		while (oldSecondToThirdTake != null) {__			newSecond = new State<T>(oldSecondToThirdTake.getTargetState().getName(), State.StateType.Normal)__			convertedStates.put(newSecond.getName(), newSecond)__			newFirst.addTake(newSecond, oldFirstToSecondTake.getCondition())___			if (oldFirstIgnore != null) {_				newFirst.addIgnore(oldFirstIgnore.getCondition())__			}__			oldFirst = oldSecond___			oldFirstToSecondTake = Iterators.find(_				oldFirst.getStateTransitions().iterator(),_				new Predicate<StateTransition<T>>() {_					@Override_					public boolean apply(@Nullable StateTransition<T> input) {_						return input != null && input.getAction() == StateTransitionAction.TAKE__					}__				})___			oldFirstIgnore = Iterators.find(_				oldFirst.getStateTransitions().iterator(),_				new Predicate<StateTransition<T>>() {_					@Override_					public boolean apply(@Nullable StateTransition<T> input) {_						return input != null && input.getAction() == StateTransitionAction.IGNORE__					}__				}, null)___			oldSecond = oldSecondToThirdTake.getTargetState()___			oldSecondToThirdTake = Iterators.find(_				oldSecond.getStateTransitions().iterator(),_				new Predicate<StateTransition<T>>() {_					@Override_					public boolean apply(@Nullable StateTransition<T> input) {_						return input != null && input.getAction() == StateTransitionAction.TAKE__					}__				}, null)___			newFirst = newSecond__		}__		final State<T> endingState = new State<>(ENDING_STATE_NAME, State.StateType.Final)___		newFirst.addTake(endingState, oldFirstToSecondTake.getCondition())___		if (oldFirstIgnore != null) {_			newFirst.addIgnore(oldFirstIgnore.getCondition())__		}__		convertedStates.put(endingState.getName(), endingState)___		return convertedStates__	};used,for,migrating,cep,graphs,prior,to,1,3,it,removes,the,dummy,start,adds,the,dummy,end,and,translates,all,states,to,consuming,ones,by,moving,all,takes,and,ignores,to,the,next,state,this,method,assumes,each,state,has,at,most,one,take,and,one,ignore,and,name,of,each,state,is,unique,no,proceed,transition,is,allowed,param,old,start,state,dummy,start,state,of,old,graph,param,t,type,of,events,return,map,of,new,states,where,key,is,the,name,of,a,state,and,value,is,the,state,itself;internal,public,static,t,map,string,state,t,migrate,graph,state,t,old,start,state,state,t,old,first,old,start,state,state,t,old,second,old,start,state,get,state,transitions,iterator,next,get,target,state,state,transition,t,old,first,to,second,take,iterators,find,old,first,get,state,transitions,iterator,new,predicate,state,transition,t,override,public,boolean,apply,nullable,state,transition,t,input,return,input,null,input,get,action,state,transition,action,take,state,transition,t,old,first,ignore,iterators,find,old,first,get,state,transitions,iterator,new,predicate,state,transition,t,override,public,boolean,apply,nullable,state,transition,t,input,return,input,null,input,get,action,state,transition,action,ignore,null,state,transition,t,old,second,to,third,take,iterators,find,old,second,get,state,transitions,iterator,new,predicate,state,transition,t,override,public,boolean,apply,nullable,state,transition,t,input,return,input,null,input,get,action,state,transition,action,take,null,final,map,string,state,t,converted,states,new,hash,map,state,t,new,second,state,t,new,first,new,state,old,second,get,name,state,state,type,start,converted,states,put,new,first,get,name,new,first,while,old,second,to,third,take,null,new,second,new,state,t,old,second,to,third,take,get,target,state,get,name,state,state,type,normal,converted,states,put,new,second,get,name,new,second,new,first,add,take,new,second,old,first,to,second,take,get,condition,if,old,first,ignore,null,new,first,add,ignore,old,first,ignore,get,condition,old,first,old,second,old,first,to,second,take,iterators,find,old,first,get,state,transitions,iterator,new,predicate,state,transition,t,override,public,boolean,apply,nullable,state,transition,t,input,return,input,null,input,get,action,state,transition,action,take,old,first,ignore,iterators,find,old,first,get,state,transitions,iterator,new,predicate,state,transition,t,override,public,boolean,apply,nullable,state,transition,t,input,return,input,null,input,get,action,state,transition,action,ignore,null,old,second,old,second,to,third,take,get,target,state,old,second,to,third,take,iterators,find,old,second,get,state,transitions,iterator,new,predicate,state,transition,t,override,public,boolean,apply,nullable,state,transition,t,input,return,input,null,input,get,action,state,transition,action,take,null,new,first,new,second,final,state,t,ending,state,new,state,state,state,type,final,new,first,add,take,ending,state,old,first,to,second,take,get,condition,if,old,first,ignore,null,new,first,add,ignore,old,first,ignore,get,condition,converted,states,put,ending,state,get,name,ending,state,return,converted,states
NFACompiler -> @Internal 	public static <T> Map<String, State<T>> migrateGraph(State<T> oldStartState);1501592283;Used for migrating CEP graphs prior to 1.3. It removes the dummy start, adds the dummy end, and translates all_states to consuming ones by moving all TAKEs and IGNOREs to the next state. This method assumes each state_has at most one TAKE and one IGNORE and name of each state is unique. No PROCEED transition is allowed!__@param oldStartState dummy start state of old graph_@param <T>           type of events_@return map of new states, where key is the name of a state and value is the state itself;@Internal_	public static <T> Map<String, State<T>> migrateGraph(State<T> oldStartState) {_		State<T> oldFirst = oldStartState__		State<T> oldSecond = oldStartState.getStateTransitions().iterator().next().getTargetState()___		StateTransition<T> oldFirstToSecondTake = Iterators.find(_			oldFirst.getStateTransitions().iterator(),_			new Predicate<StateTransition<T>>() {_				@Override_				public boolean apply(@Nullable StateTransition<T> input) {_					return input != null && input.getAction() == StateTransitionAction.TAKE__				}__			})___		StateTransition<T> oldFirstIgnore = Iterators.find(_			oldFirst.getStateTransitions().iterator(),_			new Predicate<StateTransition<T>>() {_				@Override_				public boolean apply(@Nullable StateTransition<T> input) {_					return input != null && input.getAction() == StateTransitionAction.IGNORE__				}__			}, null)___		StateTransition<T> oldSecondToThirdTake = Iterators.find(_			oldSecond.getStateTransitions().iterator(),_			new Predicate<StateTransition<T>>() {_				@Override_				public boolean apply(@Nullable StateTransition<T> input) {_					return input != null && input.getAction() == StateTransitionAction.TAKE__				}__			}, null)___		final Map<String, State<T>> convertedStates = new HashMap<>()__		State<T> newSecond__		State<T> newFirst = new State<>(oldSecond.getName(), State.StateType.Start)__		convertedStates.put(newFirst.getName(), newFirst)__		while (oldSecondToThirdTake != null) {__			newSecond = new State<T>(oldSecondToThirdTake.getTargetState().getName(), State.StateType.Normal)__			convertedStates.put(newSecond.getName(), newSecond)__			newFirst.addTake(newSecond, oldFirstToSecondTake.getCondition())___			if (oldFirstIgnore != null) {_				newFirst.addIgnore(oldFirstIgnore.getCondition())__			}__			oldFirst = oldSecond___			oldFirstToSecondTake = Iterators.find(_				oldFirst.getStateTransitions().iterator(),_				new Predicate<StateTransition<T>>() {_					@Override_					public boolean apply(@Nullable StateTransition<T> input) {_						return input != null && input.getAction() == StateTransitionAction.TAKE__					}__				})___			oldFirstIgnore = Iterators.find(_				oldFirst.getStateTransitions().iterator(),_				new Predicate<StateTransition<T>>() {_					@Override_					public boolean apply(@Nullable StateTransition<T> input) {_						return input != null && input.getAction() == StateTransitionAction.IGNORE__					}__				}, null)___			oldSecond = oldSecondToThirdTake.getTargetState()___			oldSecondToThirdTake = Iterators.find(_				oldSecond.getStateTransitions().iterator(),_				new Predicate<StateTransition<T>>() {_					@Override_					public boolean apply(@Nullable StateTransition<T> input) {_						return input != null && input.getAction() == StateTransitionAction.TAKE__					}__				}, null)___			newFirst = newSecond__		}__		final State<T> endingState = new State<>(ENDING_STATE_NAME, State.StateType.Final)___		newFirst.addTake(endingState, oldFirstToSecondTake.getCondition())___		if (oldFirstIgnore != null) {_			newFirst.addIgnore(oldFirstIgnore.getCondition())__		}__		convertedStates.put(endingState.getName(), endingState)___		return convertedStates__	};used,for,migrating,cep,graphs,prior,to,1,3,it,removes,the,dummy,start,adds,the,dummy,end,and,translates,all,states,to,consuming,ones,by,moving,all,takes,and,ignores,to,the,next,state,this,method,assumes,each,state,has,at,most,one,take,and,one,ignore,and,name,of,each,state,is,unique,no,proceed,transition,is,allowed,param,old,start,state,dummy,start,state,of,old,graph,param,t,type,of,events,return,map,of,new,states,where,key,is,the,name,of,a,state,and,value,is,the,state,itself;internal,public,static,t,map,string,state,t,migrate,graph,state,t,old,start,state,state,t,old,first,old,start,state,state,t,old,second,old,start,state,get,state,transitions,iterator,next,get,target,state,state,transition,t,old,first,to,second,take,iterators,find,old,first,get,state,transitions,iterator,new,predicate,state,transition,t,override,public,boolean,apply,nullable,state,transition,t,input,return,input,null,input,get,action,state,transition,action,take,state,transition,t,old,first,ignore,iterators,find,old,first,get,state,transitions,iterator,new,predicate,state,transition,t,override,public,boolean,apply,nullable,state,transition,t,input,return,input,null,input,get,action,state,transition,action,ignore,null,state,transition,t,old,second,to,third,take,iterators,find,old,second,get,state,transitions,iterator,new,predicate,state,transition,t,override,public,boolean,apply,nullable,state,transition,t,input,return,input,null,input,get,action,state,transition,action,take,null,final,map,string,state,t,converted,states,new,hash,map,state,t,new,second,state,t,new,first,new,state,old,second,get,name,state,state,type,start,converted,states,put,new,first,get,name,new,first,while,old,second,to,third,take,null,new,second,new,state,t,old,second,to,third,take,get,target,state,get,name,state,state,type,normal,converted,states,put,new,second,get,name,new,second,new,first,add,take,new,second,old,first,to,second,take,get,condition,if,old,first,ignore,null,new,first,add,ignore,old,first,ignore,get,condition,old,first,old,second,old,first,to,second,take,iterators,find,old,first,get,state,transitions,iterator,new,predicate,state,transition,t,override,public,boolean,apply,nullable,state,transition,t,input,return,input,null,input,get,action,state,transition,action,take,old,first,ignore,iterators,find,old,first,get,state,transitions,iterator,new,predicate,state,transition,t,override,public,boolean,apply,nullable,state,transition,t,input,return,input,null,input,get,action,state,transition,action,ignore,null,old,second,old,second,to,third,take,get,target,state,old,second,to,third,take,iterators,find,old,second,get,state,transitions,iterator,new,predicate,state,transition,t,override,public,boolean,apply,nullable,state,transition,t,input,return,input,null,input,get,action,state,transition,action,take,null,new,first,new,second,final,state,t,ending,state,new,state,state,state,type,final,new,first,add,take,ending,state,old,first,to,second,take,get,condition,if,old,first,ignore,null,new,first,add,ignore,old,first,ignore,get,condition,converted,states,put,ending,state,get,name,ending,state,return,converted,states
NFACompiler -> @Internal 	public static <T> Map<String, State<T>> migrateGraph(State<T> oldStartState);1502422141;Used for migrating CEP graphs prior to 1.3. It removes the dummy start, adds the dummy end, and translates all_states to consuming ones by moving all TAKEs and IGNOREs to the next state. This method assumes each state_has at most one TAKE and one IGNORE and name of each state is unique. No PROCEED transition is allowed!__@param oldStartState dummy start state of old graph_@param <T>           type of events_@return map of new states, where key is the name of a state and value is the state itself;@Internal_	public static <T> Map<String, State<T>> migrateGraph(State<T> oldStartState) {_		State<T> oldFirst = oldStartState__		State<T> oldSecond = oldStartState.getStateTransitions().iterator().next().getTargetState()___		StateTransition<T> oldFirstToSecondTake = Iterators.find(_			oldFirst.getStateTransitions().iterator(),_			new Predicate<StateTransition<T>>() {_				@Override_				public boolean apply(@Nullable StateTransition<T> input) {_					return input != null && input.getAction() == StateTransitionAction.TAKE__				}__			})___		StateTransition<T> oldFirstIgnore = Iterators.find(_			oldFirst.getStateTransitions().iterator(),_			new Predicate<StateTransition<T>>() {_				@Override_				public boolean apply(@Nullable StateTransition<T> input) {_					return input != null && input.getAction() == StateTransitionAction.IGNORE__				}__			}, null)___		StateTransition<T> oldSecondToThirdTake = Iterators.find(_			oldSecond.getStateTransitions().iterator(),_			new Predicate<StateTransition<T>>() {_				@Override_				public boolean apply(@Nullable StateTransition<T> input) {_					return input != null && input.getAction() == StateTransitionAction.TAKE__				}__			}, null)___		final Map<String, State<T>> convertedStates = new HashMap<>()__		State<T> newSecond__		State<T> newFirst = new State<>(oldSecond.getName(), State.StateType.Start)__		convertedStates.put(newFirst.getName(), newFirst)__		while (oldSecondToThirdTake != null) {__			newSecond = new State<T>(oldSecondToThirdTake.getTargetState().getName(), State.StateType.Normal)__			convertedStates.put(newSecond.getName(), newSecond)__			newFirst.addTake(newSecond, oldFirstToSecondTake.getCondition())___			if (oldFirstIgnore != null) {_				newFirst.addIgnore(oldFirstIgnore.getCondition())__			}__			oldFirst = oldSecond___			oldFirstToSecondTake = Iterators.find(_				oldFirst.getStateTransitions().iterator(),_				new Predicate<StateTransition<T>>() {_					@Override_					public boolean apply(@Nullable StateTransition<T> input) {_						return input != null && input.getAction() == StateTransitionAction.TAKE__					}__				})___			oldFirstIgnore = Iterators.find(_				oldFirst.getStateTransitions().iterator(),_				new Predicate<StateTransition<T>>() {_					@Override_					public boolean apply(@Nullable StateTransition<T> input) {_						return input != null && input.getAction() == StateTransitionAction.IGNORE__					}__				}, null)___			oldSecond = oldSecondToThirdTake.getTargetState()___			oldSecondToThirdTake = Iterators.find(_				oldSecond.getStateTransitions().iterator(),_				new Predicate<StateTransition<T>>() {_					@Override_					public boolean apply(@Nullable StateTransition<T> input) {_						return input != null && input.getAction() == StateTransitionAction.TAKE__					}__				}, null)___			newFirst = newSecond__		}__		final State<T> endingState = new State<>(ENDING_STATE_NAME, State.StateType.Final)___		newFirst.addTake(endingState, oldFirstToSecondTake.getCondition())___		if (oldFirstIgnore != null) {_			newFirst.addIgnore(oldFirstIgnore.getCondition())__		}__		convertedStates.put(endingState.getName(), endingState)___		return convertedStates__	};used,for,migrating,cep,graphs,prior,to,1,3,it,removes,the,dummy,start,adds,the,dummy,end,and,translates,all,states,to,consuming,ones,by,moving,all,takes,and,ignores,to,the,next,state,this,method,assumes,each,state,has,at,most,one,take,and,one,ignore,and,name,of,each,state,is,unique,no,proceed,transition,is,allowed,param,old,start,state,dummy,start,state,of,old,graph,param,t,type,of,events,return,map,of,new,states,where,key,is,the,name,of,a,state,and,value,is,the,state,itself;internal,public,static,t,map,string,state,t,migrate,graph,state,t,old,start,state,state,t,old,first,old,start,state,state,t,old,second,old,start,state,get,state,transitions,iterator,next,get,target,state,state,transition,t,old,first,to,second,take,iterators,find,old,first,get,state,transitions,iterator,new,predicate,state,transition,t,override,public,boolean,apply,nullable,state,transition,t,input,return,input,null,input,get,action,state,transition,action,take,state,transition,t,old,first,ignore,iterators,find,old,first,get,state,transitions,iterator,new,predicate,state,transition,t,override,public,boolean,apply,nullable,state,transition,t,input,return,input,null,input,get,action,state,transition,action,ignore,null,state,transition,t,old,second,to,third,take,iterators,find,old,second,get,state,transitions,iterator,new,predicate,state,transition,t,override,public,boolean,apply,nullable,state,transition,t,input,return,input,null,input,get,action,state,transition,action,take,null,final,map,string,state,t,converted,states,new,hash,map,state,t,new,second,state,t,new,first,new,state,old,second,get,name,state,state,type,start,converted,states,put,new,first,get,name,new,first,while,old,second,to,third,take,null,new,second,new,state,t,old,second,to,third,take,get,target,state,get,name,state,state,type,normal,converted,states,put,new,second,get,name,new,second,new,first,add,take,new,second,old,first,to,second,take,get,condition,if,old,first,ignore,null,new,first,add,ignore,old,first,ignore,get,condition,old,first,old,second,old,first,to,second,take,iterators,find,old,first,get,state,transitions,iterator,new,predicate,state,transition,t,override,public,boolean,apply,nullable,state,transition,t,input,return,input,null,input,get,action,state,transition,action,take,old,first,ignore,iterators,find,old,first,get,state,transitions,iterator,new,predicate,state,transition,t,override,public,boolean,apply,nullable,state,transition,t,input,return,input,null,input,get,action,state,transition,action,ignore,null,old,second,old,second,to,third,take,get,target,state,old,second,to,third,take,iterators,find,old,second,get,state,transitions,iterator,new,predicate,state,transition,t,override,public,boolean,apply,nullable,state,transition,t,input,return,input,null,input,get,action,state,transition,action,take,null,new,first,new,second,final,state,t,ending,state,new,state,state,state,type,final,new,first,add,take,ending,state,old,first,to,second,take,get,condition,if,old,first,ignore,null,new,first,add,ignore,old,first,ignore,get,condition,converted,states,put,ending,state,get,name,ending,state,return,converted,states
NFACompiler -> NFAFactoryCompiler -> @SuppressWarnings("unchecked") 		private State<T> createSingletonState(final State<T> sinkState);1490619911;Creates a simple single state. For an OPTIONAL state it also consists_of a similar state without the PROCEED edge, so that for each PROCEED transition branches_in computation state graph  can be created only once.__@param sinkState state that the state being converted should point to_@return the created state;@SuppressWarnings("unchecked")_		private State<T> createSingletonState(final State<T> sinkState) {_			return createSingletonState(sinkState, currentPattern instanceof FollowedByPattern)__		};creates,a,simple,single,state,for,an,optional,state,it,also,consists,of,a,similar,state,without,the,proceed,edge,so,that,for,each,proceed,transition,branches,in,computation,state,graph,can,be,created,only,once,param,sink,state,state,that,the,state,being,converted,should,point,to,return,the,created,state;suppress,warnings,unchecked,private,state,t,create,singleton,state,final,state,t,sink,state,return,create,singleton,state,sink,state,current,pattern,instanceof,followed,by,pattern
NFACompiler -> NFAFactoryCompiler -> @SuppressWarnings("unchecked") 		private State<T> createSingletonState(final State<T> sinkState);1491320734;Creates a simple single state. For an OPTIONAL state it also consists_of a similar state without the PROCEED edge, so that for each PROCEED transition branches_in computation state graph  can be created only once.__@param sinkState state that the state being converted should point to_@return the created state;@SuppressWarnings("unchecked")_		private State<T> createSingletonState(final State<T> sinkState) {_			return createSingletonState(sinkState, currentPattern instanceof FollowedByPattern,_					currentPattern.getQuantifier().hasProperty(QuantifierProperty.OPTIONAL))__		};creates,a,simple,single,state,for,an,optional,state,it,also,consists,of,a,similar,state,without,the,proceed,edge,so,that,for,each,proceed,transition,branches,in,computation,state,graph,can,be,created,only,once,param,sink,state,state,that,the,state,being,converted,should,point,to,return,the,created,state;suppress,warnings,unchecked,private,state,t,create,singleton,state,final,state,t,sink,state,return,create,singleton,state,sink,state,current,pattern,instanceof,followed,by,pattern,current,pattern,get,quantifier,has,property,quantifier,property,optional
NFACompiler -> NFAFactoryCompiler -> @SuppressWarnings("unchecked") 		private State<T> createSingletonState(final State<T> sinkState);1491323030;Creates a simple single state. For an OPTIONAL state it also consists_of a similar state without the PROCEED edge, so that for each PROCEED transition branches_in computation state graph  can be created only once.__@param sinkState state that the state being converted should point to_@return the created state;@SuppressWarnings("unchecked")_		private State<T> createSingletonState(final State<T> sinkState) {_			return createSingletonState(sinkState, currentPattern instanceof FollowedByPattern)__		};creates,a,simple,single,state,for,an,optional,state,it,also,consists,of,a,similar,state,without,the,proceed,edge,so,that,for,each,proceed,transition,branches,in,computation,state,graph,can,be,created,only,once,param,sink,state,state,that,the,state,being,converted,should,point,to,return,the,created,state;suppress,warnings,unchecked,private,state,t,create,singleton,state,final,state,t,sink,state,return,create,singleton,state,sink,state,current,pattern,instanceof,followed,by,pattern
NFACompiler -> NFAFactoryCompiler -> @SuppressWarnings("unchecked") 		private State<T> createSingletonState(final State<T> sinkState);1491633862;Creates a simple single state. For an OPTIONAL state it also consists_of a similar state without the PROCEED edge, so that for each PROCEED transition branches_in computation state graph  can be created only once.__@param sinkState state that the state being converted should point to_@return the created state;@SuppressWarnings("unchecked")_		private State<T> createSingletonState(final State<T> sinkState) {_			return createSingletonState(sinkState, currentPattern instanceof FollowedByPattern)__		};creates,a,simple,single,state,for,an,optional,state,it,also,consists,of,a,similar,state,without,the,proceed,edge,so,that,for,each,proceed,transition,branches,in,computation,state,graph,can,be,created,only,once,param,sink,state,state,that,the,state,being,converted,should,point,to,return,the,created,state;suppress,warnings,unchecked,private,state,t,create,singleton,state,final,state,t,sink,state,return,create,singleton,state,sink,state,current,pattern,instanceof,followed,by,pattern
NFACompiler -> NFAFactoryCompiler -> @SuppressWarnings("unchecked") 		private State<T> createSingletonState(final State<T> sinkState);1492797583;Creates a simple single state. For an OPTIONAL state it also consists_of a similar state without the PROCEED edge, so that for each PROCEED transition branches_in computation state graph  can be created only once.__@param sinkState state that the state being converted should point to_@return the created state;@SuppressWarnings("unchecked")_		private State<T> createSingletonState(final State<T> sinkState) {_			return createSingletonState(sinkState, currentPattern instanceof FollowedByPattern,_					currentPattern.getQuantifier().hasProperty(QuantifierProperty.OPTIONAL))__		};creates,a,simple,single,state,for,an,optional,state,it,also,consists,of,a,similar,state,without,the,proceed,edge,so,that,for,each,proceed,transition,branches,in,computation,state,graph,can,be,created,only,once,param,sink,state,state,that,the,state,being,converted,should,point,to,return,the,created,state;suppress,warnings,unchecked,private,state,t,create,singleton,state,final,state,t,sink,state,return,create,singleton,state,sink,state,current,pattern,instanceof,followed,by,pattern,current,pattern,get,quantifier,has,property,quantifier,property,optional
NFACompiler -> NFAFactoryCompiler -> @SuppressWarnings("unchecked") 		private State<T> createSingletonState(final State<T> sinkState);1493200673;Creates a simple single state. For an OPTIONAL state it also consists_of a similar state without the PROCEED edge, so that for each PROCEED transition branches_in computation state graph  can be created only once.__@param sinkState state that the state being converted should point to_@return the created state;@SuppressWarnings("unchecked")_		private State<T> createSingletonState(final State<T> sinkState) {_			return createSingletonState(_				sinkState,_				getIgnoreCondition(currentPattern),_				currentPattern.getQuantifier().hasProperty(Quantifier.QuantifierProperty.OPTIONAL))__		};creates,a,simple,single,state,for,an,optional,state,it,also,consists,of,a,similar,state,without,the,proceed,edge,so,that,for,each,proceed,transition,branches,in,computation,state,graph,can,be,created,only,once,param,sink,state,state,that,the,state,being,converted,should,point,to,return,the,created,state;suppress,warnings,unchecked,private,state,t,create,singleton,state,final,state,t,sink,state,return,create,singleton,state,sink,state,get,ignore,condition,current,pattern,current,pattern,get,quantifier,has,property,quantifier,quantifier,property,optional
NFACompiler -> NFAFactoryCompiler -> @SuppressWarnings("unchecked") 		private State<T> createSingletonState(final State<T> sinkState);1493385877;Creates a simple single state. For an OPTIONAL state it also consists_of a similar state without the PROCEED edge, so that for each PROCEED transition branches_in computation state graph  can be created only once.__@param sinkState state that the state being converted should point to_@return the created state;@SuppressWarnings("unchecked")_		private State<T> createSingletonState(final State<T> sinkState) {_			return createSingletonState(_				sinkState,_				getIgnoreCondition(currentPattern),_				currentPattern.getQuantifier().hasProperty(Quantifier.QuantifierProperty.OPTIONAL))__		};creates,a,simple,single,state,for,an,optional,state,it,also,consists,of,a,similar,state,without,the,proceed,edge,so,that,for,each,proceed,transition,branches,in,computation,state,graph,can,be,created,only,once,param,sink,state,state,that,the,state,being,converted,should,point,to,return,the,created,state;suppress,warnings,unchecked,private,state,t,create,singleton,state,final,state,t,sink,state,return,create,singleton,state,sink,state,get,ignore,condition,current,pattern,current,pattern,get,quantifier,has,property,quantifier,quantifier,property,optional
NFACompiler -> NFAFactoryCompiler -> @SuppressWarnings("unchecked") 		private State<T> createSingletonState(final State<T> sinkState);1494947249;Creates a simple single state. For an OPTIONAL state it also consists_of a similar state without the PROCEED edge, so that for each PROCEED transition branches_in computation state graph  can be created only once.__@param sinkState state that the state being converted should point to_@return the created state;@SuppressWarnings("unchecked")_		private State<T> createSingletonState(final State<T> sinkState) {_			return createSingletonState(_				sinkState,_				getIgnoreCondition(currentPattern),_				currentPattern.getQuantifier().hasProperty(Quantifier.QuantifierProperty.OPTIONAL))__		};creates,a,simple,single,state,for,an,optional,state,it,also,consists,of,a,similar,state,without,the,proceed,edge,so,that,for,each,proceed,transition,branches,in,computation,state,graph,can,be,created,only,once,param,sink,state,state,that,the,state,being,converted,should,point,to,return,the,created,state;suppress,warnings,unchecked,private,state,t,create,singleton,state,final,state,t,sink,state,return,create,singleton,state,sink,state,get,ignore,condition,current,pattern,current,pattern,get,quantifier,has,property,quantifier,quantifier,property,optional
NFACompiler -> NFAFactoryCompiler -> @SuppressWarnings("unchecked") 		private State<T> createSingletonState(final State<T> sinkState);1495657626;Creates a simple single state. For an OPTIONAL state it also consists_of a similar state without the PROCEED edge, so that for each PROCEED transition branches_in computation state graph  can be created only once.__@param sinkState state that the state being converted should point to_@return the created state;@SuppressWarnings("unchecked")_		private State<T> createSingletonState(final State<T> sinkState) {_			return createSingletonState(_				sinkState,_				getIgnoreCondition(currentPattern),_				currentPattern.getQuantifier().hasProperty(Quantifier.QuantifierProperty.OPTIONAL))__		};creates,a,simple,single,state,for,an,optional,state,it,also,consists,of,a,similar,state,without,the,proceed,edge,so,that,for,each,proceed,transition,branches,in,computation,state,graph,can,be,created,only,once,param,sink,state,state,that,the,state,being,converted,should,point,to,return,the,created,state;suppress,warnings,unchecked,private,state,t,create,singleton,state,final,state,t,sink,state,return,create,singleton,state,sink,state,get,ignore,condition,current,pattern,current,pattern,get,quantifier,has,property,quantifier,quantifier,property,optional
NFACompiler -> NFAFactoryCompiler -> @SuppressWarnings("unchecked") 		private State<T> createSingletonState(final State<T> sinkState);1496245714;Creates a simple single state. For an OPTIONAL state it also consists_of a similar state without the PROCEED edge, so that for each PROCEED transition branches_in computation state graph  can be created only once.__@param sinkState state that the state being converted should point to_@return the created state;@SuppressWarnings("unchecked")_		private State<T> createSingletonState(final State<T> sinkState) {_			return createSingletonState(_				sinkState,_				getIgnoreCondition(currentPattern),_				currentPattern.getQuantifier().hasProperty(Quantifier.QuantifierProperty.OPTIONAL))__		};creates,a,simple,single,state,for,an,optional,state,it,also,consists,of,a,similar,state,without,the,proceed,edge,so,that,for,each,proceed,transition,branches,in,computation,state,graph,can,be,created,only,once,param,sink,state,state,that,the,state,being,converted,should,point,to,return,the,created,state;suppress,warnings,unchecked,private,state,t,create,singleton,state,final,state,t,sink,state,return,create,singleton,state,sink,state,get,ignore,condition,current,pattern,current,pattern,get,quantifier,has,property,quantifier,quantifier,property,optional
NFACompiler -> NFAFactoryCompiler -> @SuppressWarnings("unchecked") 		private State<T> createSingletonState(final State<T> sinkState);1497410381;Creates a simple single state. For an OPTIONAL state it also consists_of a similar state without the PROCEED edge, so that for each PROCEED transition branches_in computation state graph  can be created only once.__@param sinkState state that the state being converted should point to_@return the created state;@SuppressWarnings("unchecked")_		private State<T> createSingletonState(final State<T> sinkState) {_			return createSingletonState(_				sinkState,_				sinkState,_				getIgnoreCondition(currentPattern),_				currentPattern.getQuantifier().hasProperty(Quantifier.QuantifierProperty.OPTIONAL))__		};creates,a,simple,single,state,for,an,optional,state,it,also,consists,of,a,similar,state,without,the,proceed,edge,so,that,for,each,proceed,transition,branches,in,computation,state,graph,can,be,created,only,once,param,sink,state,state,that,the,state,being,converted,should,point,to,return,the,created,state;suppress,warnings,unchecked,private,state,t,create,singleton,state,final,state,t,sink,state,return,create,singleton,state,sink,state,sink,state,get,ignore,condition,current,pattern,current,pattern,get,quantifier,has,property,quantifier,quantifier,property,optional
NFACompiler -> NFAFactoryCompiler -> @SuppressWarnings("unchecked") 		private State<T> createSingletonState(final State<T> sinkState);1497883202;Creates a simple single state. For an OPTIONAL state it also consists_of a similar state without the PROCEED edge, so that for each PROCEED transition branches_in computation state graph  can be created only once.__@param sinkState state that the state being converted should point to_@return the created state;@SuppressWarnings("unchecked")_		private State<T> createSingletonState(final State<T> sinkState) {_			return createSingletonState(_				sinkState,_				sinkState,_				getIgnoreCondition(currentPattern),_				currentPattern.getQuantifier().hasProperty(Quantifier.QuantifierProperty.OPTIONAL))__		};creates,a,simple,single,state,for,an,optional,state,it,also,consists,of,a,similar,state,without,the,proceed,edge,so,that,for,each,proceed,transition,branches,in,computation,state,graph,can,be,created,only,once,param,sink,state,state,that,the,state,being,converted,should,point,to,return,the,created,state;suppress,warnings,unchecked,private,state,t,create,singleton,state,final,state,t,sink,state,return,create,singleton,state,sink,state,sink,state,get,ignore,condition,current,pattern,current,pattern,get,quantifier,has,property,quantifier,quantifier,property,optional
NFACompiler -> NFAFactoryCompiler -> @SuppressWarnings("unchecked") 		private State<T> createSingletonState(final State<T> sinkState);1498034481;Creates a simple single state. For an OPTIONAL state it also consists_of a similar state without the PROCEED edge, so that for each PROCEED transition branches_in computation state graph  can be created only once.__@param sinkState state that the state being converted should point to_@return the created state;@SuppressWarnings("unchecked")_		private State<T> createSingletonState(final State<T> sinkState) {_			return createSingletonState(_				sinkState,_				sinkState,_				getTakeCondition(currentPattern),_				getIgnoreCondition(currentPattern),_				isPatternOptional(currentPattern))__		};creates,a,simple,single,state,for,an,optional,state,it,also,consists,of,a,similar,state,without,the,proceed,edge,so,that,for,each,proceed,transition,branches,in,computation,state,graph,can,be,created,only,once,param,sink,state,state,that,the,state,being,converted,should,point,to,return,the,created,state;suppress,warnings,unchecked,private,state,t,create,singleton,state,final,state,t,sink,state,return,create,singleton,state,sink,state,sink,state,get,take,condition,current,pattern,get,ignore,condition,current,pattern,is,pattern,optional,current,pattern
NFACompiler -> NFAFactoryCompiler -> @SuppressWarnings("unchecked") 		private State<T> createSingletonState(final State<T> sinkState);1499760222;Creates a simple single state. For an OPTIONAL state it also consists_of a similar state without the PROCEED edge, so that for each PROCEED transition branches_in computation state graph  can be created only once.__@param sinkState state that the state being converted should point to_@return the created state;@SuppressWarnings("unchecked")_		private State<T> createSingletonState(final State<T> sinkState) {_			return createSingletonState(_				sinkState,_				sinkState,_				getTakeCondition(currentPattern),_				getIgnoreCondition(currentPattern),_				isPatternOptional(currentPattern))__		};creates,a,simple,single,state,for,an,optional,state,it,also,consists,of,a,similar,state,without,the,proceed,edge,so,that,for,each,proceed,transition,branches,in,computation,state,graph,can,be,created,only,once,param,sink,state,state,that,the,state,being,converted,should,point,to,return,the,created,state;suppress,warnings,unchecked,private,state,t,create,singleton,state,final,state,t,sink,state,return,create,singleton,state,sink,state,sink,state,get,take,condition,current,pattern,get,ignore,condition,current,pattern,is,pattern,optional,current,pattern
NFACompiler -> NFAFactoryCompiler -> @SuppressWarnings("unchecked") 		private State<T> createSingletonState(final State<T> sinkState);1499937690;Creates a simple single state. For an OPTIONAL state it also consists_of a similar state without the PROCEED edge, so that for each PROCEED transition branches_in computation state graph  can be created only once.__@param sinkState state that the state being converted should point to_@return the created state;@SuppressWarnings("unchecked")_		private State<T> createSingletonState(final State<T> sinkState) {_			return createSingletonState(_				sinkState,_				sinkState,_				getTakeCondition(currentPattern),_				getIgnoreCondition(currentPattern),_				isPatternOptional(currentPattern))__		};creates,a,simple,single,state,for,an,optional,state,it,also,consists,of,a,similar,state,without,the,proceed,edge,so,that,for,each,proceed,transition,branches,in,computation,state,graph,can,be,created,only,once,param,sink,state,state,that,the,state,being,converted,should,point,to,return,the,created,state;suppress,warnings,unchecked,private,state,t,create,singleton,state,final,state,t,sink,state,return,create,singleton,state,sink,state,sink,state,get,take,condition,current,pattern,get,ignore,condition,current,pattern,is,pattern,optional,current,pattern
NFACompiler -> NFAFactoryCompiler -> @SuppressWarnings("unchecked") 		private State<T> createSingletonState(final State<T> sinkState);1500021711;Creates a simple single state. For an OPTIONAL state it also consists_of a similar state without the PROCEED edge, so that for each PROCEED transition branches_in computation state graph  can be created only once.__@param sinkState state that the state being converted should point to_@return the created state;@SuppressWarnings("unchecked")_		private State<T> createSingletonState(final State<T> sinkState) {_			return createSingletonState(_				sinkState,_				sinkState,_				getTakeCondition(currentPattern),_				getIgnoreCondition(currentPattern),_				isPatternOptional(currentPattern))__		};creates,a,simple,single,state,for,an,optional,state,it,also,consists,of,a,similar,state,without,the,proceed,edge,so,that,for,each,proceed,transition,branches,in,computation,state,graph,can,be,created,only,once,param,sink,state,state,that,the,state,being,converted,should,point,to,return,the,created,state;suppress,warnings,unchecked,private,state,t,create,singleton,state,final,state,t,sink,state,return,create,singleton,state,sink,state,sink,state,get,take,condition,current,pattern,get,ignore,condition,current,pattern,is,pattern,optional,current,pattern
NFACompiler -> NFAFactoryCompiler -> @SuppressWarnings("unchecked") 		private State<T> createSingletonState(final State<T> sinkState);1501592283;Creates a simple single state. For an OPTIONAL state it also consists_of a similar state without the PROCEED edge, so that for each PROCEED transition branches_in computation state graph  can be created only once.__@param sinkState state that the state being converted should point to_@return the created state;@SuppressWarnings("unchecked")_		private State<T> createSingletonState(final State<T> sinkState) {_			return createSingletonState(_				sinkState,_				sinkState,_				getTakeCondition(currentPattern),_				getIgnoreCondition(currentPattern),_				isPatternOptional(currentPattern))__		};creates,a,simple,single,state,for,an,optional,state,it,also,consists,of,a,similar,state,without,the,proceed,edge,so,that,for,each,proceed,transition,branches,in,computation,state,graph,can,be,created,only,once,param,sink,state,state,that,the,state,being,converted,should,point,to,return,the,created,state;suppress,warnings,unchecked,private,state,t,create,singleton,state,final,state,t,sink,state,return,create,singleton,state,sink,state,sink,state,get,take,condition,current,pattern,get,ignore,condition,current,pattern,is,pattern,optional,current,pattern
NFACompiler -> NFAFactoryCompiler -> @SuppressWarnings("unchecked") 		private State<T> createSingletonState(final State<T> sinkState);1502422141;Creates a simple single state. For an OPTIONAL state it also consists_of a similar state without the PROCEED edge, so that for each PROCEED transition branches_in computation state graph  can be created only once.__@param sinkState state that the state being converted should point to_@return the created state;@SuppressWarnings("unchecked")_		private State<T> createSingletonState(final State<T> sinkState) {_			return createSingletonState(_				sinkState,_				sinkState,_				getTakeCondition(currentPattern),_				getIgnoreCondition(currentPattern),_				isPatternOptional(currentPattern))__		};creates,a,simple,single,state,for,an,optional,state,it,also,consists,of,a,similar,state,without,the,proceed,edge,so,that,for,each,proceed,transition,branches,in,computation,state,graph,can,be,created,only,once,param,sink,state,state,that,the,state,being,converted,should,point,to,return,the,created,state;suppress,warnings,unchecked,private,state,t,create,singleton,state,final,state,t,sink,state,return,create,singleton,state,sink,state,sink,state,get,take,condition,current,pattern,get,ignore,condition,current,pattern,is,pattern,optional,current,pattern
NFACompiler -> NFAFactoryCompiler -> @SuppressWarnings("unchecked") 		private State<T> createSingletonState(final State<T> sinkState);1503588494;Creates a simple single state. For an OPTIONAL state it also consists_of a similar state without the PROCEED edge, so that for each PROCEED transition branches_in computation state graph  can be created only once.__@param sinkState state that the state being converted should point to_@return the created state;@SuppressWarnings("unchecked")_		private State<T> createSingletonState(final State<T> sinkState) {_			return createSingletonState(_				sinkState,_				sinkState,_				getTakeCondition(currentPattern),_				getIgnoreCondition(currentPattern),_				isPatternOptional(currentPattern))__		};creates,a,simple,single,state,for,an,optional,state,it,also,consists,of,a,similar,state,without,the,proceed,edge,so,that,for,each,proceed,transition,branches,in,computation,state,graph,can,be,created,only,once,param,sink,state,state,that,the,state,being,converted,should,point,to,return,the,created,state;suppress,warnings,unchecked,private,state,t,create,singleton,state,final,state,t,sink,state,return,create,singleton,state,sink,state,sink,state,get,take,condition,current,pattern,get,ignore,condition,current,pattern,is,pattern,optional,current,pattern
NFACompiler -> NFAFactoryCompiler -> @SuppressWarnings("unchecked") 		private State<T> createSingletonState(final State<T> sinkState);1518008111;Creates a simple single state. For an OPTIONAL state it also consists_of a similar state without the PROCEED edge, so that for each PROCEED transition branches_in computation state graph  can be created only once.__@param sinkState state that the state being converted should point to_@return the created state;@SuppressWarnings("unchecked")_		private State<T> createSingletonState(final State<T> sinkState) {_			return createSingletonState(_				sinkState,_				sinkState,_				getTakeCondition(currentPattern),_				getIgnoreCondition(currentPattern),_				isPatternOptional(currentPattern))__		};creates,a,simple,single,state,for,an,optional,state,it,also,consists,of,a,similar,state,without,the,proceed,edge,so,that,for,each,proceed,transition,branches,in,computation,state,graph,can,be,created,only,once,param,sink,state,state,that,the,state,being,converted,should,point,to,return,the,created,state;suppress,warnings,unchecked,private,state,t,create,singleton,state,final,state,t,sink,state,return,create,singleton,state,sink,state,sink,state,get,take,condition,current,pattern,get,ignore,condition,current,pattern,is,pattern,optional,current,pattern
NFACompiler -> NFAFactoryCompiler -> @SuppressWarnings("unchecked") 		private State<T> createSingletonState(final State<T> sinkState);1527863170;Creates a simple single state. For an OPTIONAL state it also consists_of a similar state without the PROCEED edge, so that for each PROCEED transition branches_in computation state graph  can be created only once.__@param sinkState state that the state being converted should point to_@return the created state;@SuppressWarnings("unchecked")_		private State<T> createSingletonState(final State<T> sinkState) {_			return createSingletonState(_				sinkState,_				sinkState,_				getTakeCondition(currentPattern),_				getIgnoreCondition(currentPattern),_				isPatternOptional(currentPattern))__		};creates,a,simple,single,state,for,an,optional,state,it,also,consists,of,a,similar,state,without,the,proceed,edge,so,that,for,each,proceed,transition,branches,in,computation,state,graph,can,be,created,only,once,param,sink,state,state,that,the,state,being,converted,should,point,to,return,the,created,state;suppress,warnings,unchecked,private,state,t,create,singleton,state,final,state,t,sink,state,return,create,singleton,state,sink,state,sink,state,get,take,condition,current,pattern,get,ignore,condition,current,pattern,is,pattern,optional,current,pattern
NFACompiler -> NFAFactoryCompiler -> @SuppressWarnings("unchecked") 		private State<T> createSingletonState(final State<T> sinkState);1528989005;Creates a simple single state. For an OPTIONAL state it also consists_of a similar state without the PROCEED edge, so that for each PROCEED transition branches_in computation state graph  can be created only once.__@param sinkState state that the state being converted should point to_@return the created state;@SuppressWarnings("unchecked")_		private State<T> createSingletonState(final State<T> sinkState) {_			return createSingletonState(_				sinkState,_				sinkState,_				getTakeCondition(currentPattern),_				getIgnoreCondition(currentPattern),_				isPatternOptional(currentPattern))__		};creates,a,simple,single,state,for,an,optional,state,it,also,consists,of,a,similar,state,without,the,proceed,edge,so,that,for,each,proceed,transition,branches,in,computation,state,graph,can,be,created,only,once,param,sink,state,state,that,the,state,being,converted,should,point,to,return,the,created,state;suppress,warnings,unchecked,private,state,t,create,singleton,state,final,state,t,sink,state,return,create,singleton,state,sink,state,sink,state,get,take,condition,current,pattern,get,ignore,condition,current,pattern,is,pattern,optional,current,pattern
NFACompiler -> NFAFactoryCompiler -> @SuppressWarnings("unchecked") 		private State<T> createSingletonState(final State<T> sinkState);1538745898;Creates a simple single state. For an OPTIONAL state it also consists_of a similar state without the PROCEED edge, so that for each PROCEED transition branches_in computation state graph  can be created only once.__@param sinkState state that the state being converted should point to_@return the created state;@SuppressWarnings("unchecked")_		private State<T> createSingletonState(final State<T> sinkState) {_			return createSingletonState(_				sinkState,_				sinkState,_				getTakeCondition(currentPattern),_				getIgnoreCondition(currentPattern),_				isPatternOptional(currentPattern))__		};creates,a,simple,single,state,for,an,optional,state,it,also,consists,of,a,similar,state,without,the,proceed,edge,so,that,for,each,proceed,transition,branches,in,computation,state,graph,can,be,created,only,once,param,sink,state,state,that,the,state,being,converted,should,point,to,return,the,created,state;suppress,warnings,unchecked,private,state,t,create,singleton,state,final,state,t,sink,state,return,create,singleton,state,sink,state,sink,state,get,take,condition,current,pattern,get,ignore,condition,current,pattern,is,pattern,optional,current,pattern
NFACompiler -> NFAFactoryCompiler -> @SuppressWarnings("unchecked") 		private State<T> createSingletonState(final State<T> sinkState);1542293931;Creates a simple single state. For an OPTIONAL state it also consists_of a similar state without the PROCEED edge, so that for each PROCEED transition branches_in computation state graph  can be created only once.__@param sinkState state that the state being converted should point to_@return the created state;@SuppressWarnings("unchecked")_		private State<T> createSingletonState(final State<T> sinkState) {_			return createSingletonState(_				sinkState,_				sinkState,_				getTakeCondition(currentPattern),_				getIgnoreCondition(currentPattern),_				isPatternOptional(currentPattern))__		};creates,a,simple,single,state,for,an,optional,state,it,also,consists,of,a,similar,state,without,the,proceed,edge,so,that,for,each,proceed,transition,branches,in,computation,state,graph,can,be,created,only,once,param,sink,state,state,that,the,state,being,converted,should,point,to,return,the,created,state;suppress,warnings,unchecked,private,state,t,create,singleton,state,final,state,t,sink,state,return,create,singleton,state,sink,state,sink,state,get,take,condition,current,pattern,get,ignore,condition,current,pattern,is,pattern,optional,current,pattern
NFACompiler -> NFAFactoryCompiler -> @SuppressWarnings("unchecked") 		private void convertToSingletonState(final State<T> sourceState, final State<T> sinkState);1489866780;Converts the given state into a simple single state. For an OPTIONAL state it also consists_of a similar state without the PROCEED edge, so that for each PROCEED transition branches_in computation state graph  can be created only once.__@param sourceState the state to be converted_@param sinkState state that the state being converted should point to;@SuppressWarnings("unchecked")_		private void convertToSingletonState(final State<T> sourceState, final State<T> sinkState) {__			final FilterFunction<T> currentFilterFunction = (FilterFunction<T>) currentPattern.getFilterFunction()__			final FilterFunction<T> trueFunction = FilterFunctions.trueFunction()__			sourceState.addTake(sinkState, currentFilterFunction)___			if (currentPattern.getQuantifier() == Quantifier.OPTIONAL) {_				sourceState.addProceed(sinkState, trueFunction)__			}__			if (currentPattern instanceof FollowedByPattern) {_				final State<T> ignoreState__				if (currentPattern.getQuantifier() == Quantifier.OPTIONAL) {_					ignoreState = new State<>(currentPattern.getName(), State.StateType.Normal)__					ignoreState.addTake(sinkState, currentFilterFunction)__					states.add(ignoreState)__				} else {_					ignoreState = sourceState__				}_				sourceState.addIgnore(ignoreState, trueFunction)__			}_		};converts,the,given,state,into,a,simple,single,state,for,an,optional,state,it,also,consists,of,a,similar,state,without,the,proceed,edge,so,that,for,each,proceed,transition,branches,in,computation,state,graph,can,be,created,only,once,param,source,state,the,state,to,be,converted,param,sink,state,state,that,the,state,being,converted,should,point,to;suppress,warnings,unchecked,private,void,convert,to,singleton,state,final,state,t,source,state,final,state,t,sink,state,final,filter,function,t,current,filter,function,filter,function,t,current,pattern,get,filter,function,final,filter,function,t,true,function,filter,functions,true,function,source,state,add,take,sink,state,current,filter,function,if,current,pattern,get,quantifier,quantifier,optional,source,state,add,proceed,sink,state,true,function,if,current,pattern,instanceof,followed,by,pattern,final,state,t,ignore,state,if,current,pattern,get,quantifier,quantifier,optional,ignore,state,new,state,current,pattern,get,name,state,state,type,normal,ignore,state,add,take,sink,state,current,filter,function,states,add,ignore,state,else,ignore,state,source,state,source,state,add,ignore,ignore,state,true,function
NFACompiler -> NFAFactoryCompiler -> @SuppressWarnings("unchecked") 		private void convertToSingletonState(final State<T> sourceState, final State<T> sinkState);1490089987;Converts the given state into a simple single state. For an OPTIONAL state it also consists_of a similar state without the PROCEED edge, so that for each PROCEED transition branches_in computation state graph  can be created only once.__@param sourceState the state to be converted_@param sinkState state that the state being converted should point to;@SuppressWarnings("unchecked")_		private void convertToSingletonState(final State<T> sourceState, final State<T> sinkState) {__			final FilterFunction<T> currentFilterFunction = (FilterFunction<T>) currentPattern.getFilterFunction()__			final FilterFunction<T> trueFunction = FilterFunctions.trueFunction()__			sourceState.addTake(sinkState, currentFilterFunction)___			if (currentPattern.getQuantifier() == Quantifier.OPTIONAL) {_				sourceState.addProceed(sinkState, trueFunction)__			}__			if (currentPattern instanceof FollowedByPattern) {_				final State<T> ignoreState__				if (currentPattern.getQuantifier() == Quantifier.OPTIONAL) {_					ignoreState = new State<>(currentPattern.getName(), State.StateType.Normal)__					ignoreState.addTake(sinkState, currentFilterFunction)__					states.add(ignoreState)__				} else {_					ignoreState = sourceState__				}_				sourceState.addIgnore(ignoreState, trueFunction)__			}_		};converts,the,given,state,into,a,simple,single,state,for,an,optional,state,it,also,consists,of,a,similar,state,without,the,proceed,edge,so,that,for,each,proceed,transition,branches,in,computation,state,graph,can,be,created,only,once,param,source,state,the,state,to,be,converted,param,sink,state,state,that,the,state,being,converted,should,point,to;suppress,warnings,unchecked,private,void,convert,to,singleton,state,final,state,t,source,state,final,state,t,sink,state,final,filter,function,t,current,filter,function,filter,function,t,current,pattern,get,filter,function,final,filter,function,t,true,function,filter,functions,true,function,source,state,add,take,sink,state,current,filter,function,if,current,pattern,get,quantifier,quantifier,optional,source,state,add,proceed,sink,state,true,function,if,current,pattern,instanceof,followed,by,pattern,final,state,t,ignore,state,if,current,pattern,get,quantifier,quantifier,optional,ignore,state,new,state,current,pattern,get,name,state,state,type,normal,ignore,state,add,take,sink,state,current,filter,function,states,add,ignore,state,else,ignore,state,source,state,source,state,add,ignore,ignore,state,true,function
NFACompiler -> NFAFactoryCompiler -> @SuppressWarnings("unchecked") 		private void convertToSingletonState(final State<T> sourceState, final State<T> sinkState);1490194327;Converts the given state into a simple single state. For an OPTIONAL state it also consists_of a similar state without the PROCEED edge, so that for each PROCEED transition branches_in computation state graph  can be created only once.__@param sourceState the state to be converted_@param sinkState state that the state being converted should point to;@SuppressWarnings("unchecked")_		private void convertToSingletonState(final State<T> sourceState, final State<T> sinkState) {__			final IterativeCondition<T> currentFilterFunction = (IterativeCondition<T>) currentPattern.getCondition()__			final IterativeCondition<T> trueFunction = BooleanConditions.trueFunction()___			sourceState.addTake(sinkState, currentFilterFunction)___			if (currentPattern.getQuantifier() == Quantifier.OPTIONAL) {_				sourceState.addProceed(sinkState, trueFunction)__			}__			if (currentPattern instanceof FollowedByPattern) {_				final State<T> ignoreState__				if (currentPattern.getQuantifier() == Quantifier.OPTIONAL) {_					ignoreState = new State<>(currentPattern.getName(), State.StateType.Normal)__					ignoreState.addTake(sinkState, currentFilterFunction)__					states.add(ignoreState)__				} else {_					ignoreState = sourceState__				}_				sourceState.addIgnore(ignoreState, trueFunction)__			}_		};converts,the,given,state,into,a,simple,single,state,for,an,optional,state,it,also,consists,of,a,similar,state,without,the,proceed,edge,so,that,for,each,proceed,transition,branches,in,computation,state,graph,can,be,created,only,once,param,source,state,the,state,to,be,converted,param,sink,state,state,that,the,state,being,converted,should,point,to;suppress,warnings,unchecked,private,void,convert,to,singleton,state,final,state,t,source,state,final,state,t,sink,state,final,iterative,condition,t,current,filter,function,iterative,condition,t,current,pattern,get,condition,final,iterative,condition,t,true,function,boolean,conditions,true,function,source,state,add,take,sink,state,current,filter,function,if,current,pattern,get,quantifier,quantifier,optional,source,state,add,proceed,sink,state,true,function,if,current,pattern,instanceof,followed,by,pattern,final,state,t,ignore,state,if,current,pattern,get,quantifier,quantifier,optional,ignore,state,new,state,current,pattern,get,name,state,state,type,normal,ignore,state,add,take,sink,state,current,filter,function,states,add,ignore,state,else,ignore,state,source,state,source,state,add,ignore,ignore,state,true,function
NFACompiler -> NFAFactoryCompiler -> @SuppressWarnings("unchecked") 		private void setCurrentGroupPatternFirstOfLoop(boolean isFirstOfLoop);1498034481;Marks the current group pattern as the head of the TIMES quantifier or not.__@param isFirstOfLoop whether the current group pattern is the head of the TIMES quantifier;@SuppressWarnings("unchecked")_		private void setCurrentGroupPatternFirstOfLoop(boolean isFirstOfLoop) {_			if (currentPattern instanceof GroupPattern) {_				firstOfLoopMap.put((GroupPattern<T, ?>) currentPattern, isFirstOfLoop)__			}_		};marks,the,current,group,pattern,as,the,head,of,the,times,quantifier,or,not,param,is,first,of,loop,whether,the,current,group,pattern,is,the,head,of,the,times,quantifier;suppress,warnings,unchecked,private,void,set,current,group,pattern,first,of,loop,boolean,is,first,of,loop,if,current,pattern,instanceof,group,pattern,first,of,loop,map,put,group,pattern,t,current,pattern,is,first,of,loop
NFACompiler -> NFAFactoryCompiler -> @SuppressWarnings("unchecked") 		private void setCurrentGroupPatternFirstOfLoop(boolean isFirstOfLoop);1499760222;Marks the current group pattern as the head of the TIMES quantifier or not.__@param isFirstOfLoop whether the current group pattern is the head of the TIMES quantifier;@SuppressWarnings("unchecked")_		private void setCurrentGroupPatternFirstOfLoop(boolean isFirstOfLoop) {_			if (currentPattern instanceof GroupPattern) {_				firstOfLoopMap.put((GroupPattern<T, ?>) currentPattern, isFirstOfLoop)__			}_		};marks,the,current,group,pattern,as,the,head,of,the,times,quantifier,or,not,param,is,first,of,loop,whether,the,current,group,pattern,is,the,head,of,the,times,quantifier;suppress,warnings,unchecked,private,void,set,current,group,pattern,first,of,loop,boolean,is,first,of,loop,if,current,pattern,instanceof,group,pattern,first,of,loop,map,put,group,pattern,t,current,pattern,is,first,of,loop
NFACompiler -> NFAFactoryCompiler -> @SuppressWarnings("unchecked") 		private void setCurrentGroupPatternFirstOfLoop(boolean isFirstOfLoop);1499937690;Marks the current group pattern as the head of the TIMES quantifier or not.__@param isFirstOfLoop whether the current group pattern is the head of the TIMES quantifier;@SuppressWarnings("unchecked")_		private void setCurrentGroupPatternFirstOfLoop(boolean isFirstOfLoop) {_			if (currentPattern instanceof GroupPattern) {_				firstOfLoopMap.put((GroupPattern<T, ?>) currentPattern, isFirstOfLoop)__			}_		};marks,the,current,group,pattern,as,the,head,of,the,times,quantifier,or,not,param,is,first,of,loop,whether,the,current,group,pattern,is,the,head,of,the,times,quantifier;suppress,warnings,unchecked,private,void,set,current,group,pattern,first,of,loop,boolean,is,first,of,loop,if,current,pattern,instanceof,group,pattern,first,of,loop,map,put,group,pattern,t,current,pattern,is,first,of,loop
NFACompiler -> NFAFactoryCompiler -> @SuppressWarnings("unchecked") 		private void setCurrentGroupPatternFirstOfLoop(boolean isFirstOfLoop);1500021711;Marks the current group pattern as the head of the TIMES quantifier or not.__@param isFirstOfLoop whether the current group pattern is the head of the TIMES quantifier;@SuppressWarnings("unchecked")_		private void setCurrentGroupPatternFirstOfLoop(boolean isFirstOfLoop) {_			if (currentPattern instanceof GroupPattern) {_				firstOfLoopMap.put((GroupPattern<T, ?>) currentPattern, isFirstOfLoop)__			}_		};marks,the,current,group,pattern,as,the,head,of,the,times,quantifier,or,not,param,is,first,of,loop,whether,the,current,group,pattern,is,the,head,of,the,times,quantifier;suppress,warnings,unchecked,private,void,set,current,group,pattern,first,of,loop,boolean,is,first,of,loop,if,current,pattern,instanceof,group,pattern,first,of,loop,map,put,group,pattern,t,current,pattern,is,first,of,loop
NFACompiler -> NFAFactoryCompiler -> @SuppressWarnings("unchecked") 		private void setCurrentGroupPatternFirstOfLoop(boolean isFirstOfLoop);1501592283;Marks the current group pattern as the head of the TIMES quantifier or not.__@param isFirstOfLoop whether the current group pattern is the head of the TIMES quantifier;@SuppressWarnings("unchecked")_		private void setCurrentGroupPatternFirstOfLoop(boolean isFirstOfLoop) {_			if (currentPattern instanceof GroupPattern) {_				firstOfLoopMap.put((GroupPattern<T, ?>) currentPattern, isFirstOfLoop)__			}_		};marks,the,current,group,pattern,as,the,head,of,the,times,quantifier,or,not,param,is,first,of,loop,whether,the,current,group,pattern,is,the,head,of,the,times,quantifier;suppress,warnings,unchecked,private,void,set,current,group,pattern,first,of,loop,boolean,is,first,of,loop,if,current,pattern,instanceof,group,pattern,first,of,loop,map,put,group,pattern,t,current,pattern,is,first,of,loop
NFACompiler -> NFAFactoryCompiler -> @SuppressWarnings("unchecked") 		private void setCurrentGroupPatternFirstOfLoop(boolean isFirstOfLoop);1502422141;Marks the current group pattern as the head of the TIMES quantifier or not.__@param isFirstOfLoop whether the current group pattern is the head of the TIMES quantifier;@SuppressWarnings("unchecked")_		private void setCurrentGroupPatternFirstOfLoop(boolean isFirstOfLoop) {_			if (currentPattern instanceof GroupPattern) {_				firstOfLoopMap.put((GroupPattern<T, ?>) currentPattern, isFirstOfLoop)__			}_		};marks,the,current,group,pattern,as,the,head,of,the,times,quantifier,or,not,param,is,first,of,loop,whether,the,current,group,pattern,is,the,head,of,the,times,quantifier;suppress,warnings,unchecked,private,void,set,current,group,pattern,first,of,loop,boolean,is,first,of,loop,if,current,pattern,instanceof,group,pattern,first,of,loop,map,put,group,pattern,t,current,pattern,is,first,of,loop
NFACompiler -> NFAFactoryCompiler -> @SuppressWarnings("unchecked") 		private void setCurrentGroupPatternFirstOfLoop(boolean isFirstOfLoop);1503588494;Marks the current group pattern as the head of the TIMES quantifier or not.__@param isFirstOfLoop whether the current group pattern is the head of the TIMES quantifier;@SuppressWarnings("unchecked")_		private void setCurrentGroupPatternFirstOfLoop(boolean isFirstOfLoop) {_			if (currentPattern instanceof GroupPattern) {_				firstOfLoopMap.put((GroupPattern<T, ?>) currentPattern, isFirstOfLoop)__			}_		};marks,the,current,group,pattern,as,the,head,of,the,times,quantifier,or,not,param,is,first,of,loop,whether,the,current,group,pattern,is,the,head,of,the,times,quantifier;suppress,warnings,unchecked,private,void,set,current,group,pattern,first,of,loop,boolean,is,first,of,loop,if,current,pattern,instanceof,group,pattern,first,of,loop,map,put,group,pattern,t,current,pattern,is,first,of,loop
NFACompiler -> NFAFactoryCompiler -> @SuppressWarnings("unchecked") 		private void setCurrentGroupPatternFirstOfLoop(boolean isFirstOfLoop);1518008111;Marks the current group pattern as the head of the TIMES quantifier or not.__@param isFirstOfLoop whether the current group pattern is the head of the TIMES quantifier;@SuppressWarnings("unchecked")_		private void setCurrentGroupPatternFirstOfLoop(boolean isFirstOfLoop) {_			if (currentPattern instanceof GroupPattern) {_				firstOfLoopMap.put((GroupPattern<T, ?>) currentPattern, isFirstOfLoop)__			}_		};marks,the,current,group,pattern,as,the,head,of,the,times,quantifier,or,not,param,is,first,of,loop,whether,the,current,group,pattern,is,the,head,of,the,times,quantifier;suppress,warnings,unchecked,private,void,set,current,group,pattern,first,of,loop,boolean,is,first,of,loop,if,current,pattern,instanceof,group,pattern,first,of,loop,map,put,group,pattern,t,current,pattern,is,first,of,loop
NFACompiler -> NFAFactoryCompiler -> @SuppressWarnings("unchecked") 		private void setCurrentGroupPatternFirstOfLoop(boolean isFirstOfLoop);1527863170;Marks the current group pattern as the head of the TIMES quantifier or not.__@param isFirstOfLoop whether the current group pattern is the head of the TIMES quantifier;@SuppressWarnings("unchecked")_		private void setCurrentGroupPatternFirstOfLoop(boolean isFirstOfLoop) {_			if (currentPattern instanceof GroupPattern) {_				firstOfLoopMap.put((GroupPattern<T, ?>) currentPattern, isFirstOfLoop)__			}_		};marks,the,current,group,pattern,as,the,head,of,the,times,quantifier,or,not,param,is,first,of,loop,whether,the,current,group,pattern,is,the,head,of,the,times,quantifier;suppress,warnings,unchecked,private,void,set,current,group,pattern,first,of,loop,boolean,is,first,of,loop,if,current,pattern,instanceof,group,pattern,first,of,loop,map,put,group,pattern,t,current,pattern,is,first,of,loop
NFACompiler -> NFAFactoryCompiler -> @SuppressWarnings("unchecked") 		private void setCurrentGroupPatternFirstOfLoop(boolean isFirstOfLoop);1528989005;Marks the current group pattern as the head of the TIMES quantifier or not.__@param isFirstOfLoop whether the current group pattern is the head of the TIMES quantifier;@SuppressWarnings("unchecked")_		private void setCurrentGroupPatternFirstOfLoop(boolean isFirstOfLoop) {_			if (currentPattern instanceof GroupPattern) {_				firstOfLoopMap.put((GroupPattern<T, ?>) currentPattern, isFirstOfLoop)__			}_		};marks,the,current,group,pattern,as,the,head,of,the,times,quantifier,or,not,param,is,first,of,loop,whether,the,current,group,pattern,is,the,head,of,the,times,quantifier;suppress,warnings,unchecked,private,void,set,current,group,pattern,first,of,loop,boolean,is,first,of,loop,if,current,pattern,instanceof,group,pattern,first,of,loop,map,put,group,pattern,t,current,pattern,is,first,of,loop
NFACompiler -> NFAFactoryCompiler -> @SuppressWarnings("unchecked") 		private void setCurrentGroupPatternFirstOfLoop(boolean isFirstOfLoop);1538745898;Marks the current group pattern as the head of the TIMES quantifier or not.__@param isFirstOfLoop whether the current group pattern is the head of the TIMES quantifier;@SuppressWarnings("unchecked")_		private void setCurrentGroupPatternFirstOfLoop(boolean isFirstOfLoop) {_			if (currentPattern instanceof GroupPattern) {_				firstOfLoopMap.put((GroupPattern<T, ?>) currentPattern, isFirstOfLoop)__			}_		};marks,the,current,group,pattern,as,the,head,of,the,times,quantifier,or,not,param,is,first,of,loop,whether,the,current,group,pattern,is,the,head,of,the,times,quantifier;suppress,warnings,unchecked,private,void,set,current,group,pattern,first,of,loop,boolean,is,first,of,loop,if,current,pattern,instanceof,group,pattern,first,of,loop,map,put,group,pattern,t,current,pattern,is,first,of,loop
NFACompiler -> NFAFactoryCompiler -> @SuppressWarnings("unchecked") 		private void setCurrentGroupPatternFirstOfLoop(boolean isFirstOfLoop);1542293931;Marks the current group pattern as the head of the TIMES quantifier or not.__@param isFirstOfLoop whether the current group pattern is the head of the TIMES quantifier;@SuppressWarnings("unchecked")_		private void setCurrentGroupPatternFirstOfLoop(boolean isFirstOfLoop) {_			if (currentPattern instanceof GroupPattern) {_				firstOfLoopMap.put((GroupPattern<T, ?>) currentPattern, isFirstOfLoop)__			}_		};marks,the,current,group,pattern,as,the,head,of,the,times,quantifier,or,not,param,is,first,of,loop,whether,the,current,group,pattern,is,the,head,of,the,times,quantifier;suppress,warnings,unchecked,private,void,set,current,group,pattern,first,of,loop,boolean,is,first,of,loop,if,current,pattern,instanceof,group,pattern,first,of,loop,map,put,group,pattern,t,current,pattern,is,first,of,loop
NFACompiler -> NFAFactoryCompiler -> private State<T> createGroupPatternState( 			final GroupPattern<T, ?> groupPattern, 			final State<T> sinkState, 			final State<T> proceedState, 			final boolean isOptional);1498034481;Create all the states for the group pattern.__@param groupPattern the group pattern to create the states for_@param sinkState the state that the group pattern being converted should point to_@param proceedState the state that the group pattern being converted should proceed to_@param isOptional whether the group pattern being converted is optional_@return the first state of the states of the group pattern;private State<T> createGroupPatternState(_			final GroupPattern<T, ?> groupPattern,_			final State<T> sinkState,_			final State<T> proceedState,_			final boolean isOptional) {_			final IterativeCondition<T> trueFunction = getTrueFunction()___			Pattern<T, ?> oldCurrentPattern = currentPattern__			Pattern<T, ?> oldFollowingPattern = followingPattern__			GroupPattern<T, ?> oldGroupPattern = currentGroupPattern__			State<T> lastSink = sinkState__			currentGroupPattern = groupPattern__			currentPattern = groupPattern.getRawPattern()__			lastSink = createMiddleStates(lastSink)__			lastSink = convertPattern(lastSink)__			if (isOptional) {_				_				_				lastSink.addProceed(proceedState, trueFunction)__			}_			currentPattern = oldCurrentPattern__			followingPattern = oldFollowingPattern__			currentGroupPattern = oldGroupPattern__			return lastSink__		};create,all,the,states,for,the,group,pattern,param,group,pattern,the,group,pattern,to,create,the,states,for,param,sink,state,the,state,that,the,group,pattern,being,converted,should,point,to,param,proceed,state,the,state,that,the,group,pattern,being,converted,should,proceed,to,param,is,optional,whether,the,group,pattern,being,converted,is,optional,return,the,first,state,of,the,states,of,the,group,pattern;private,state,t,create,group,pattern,state,final,group,pattern,t,group,pattern,final,state,t,sink,state,final,state,t,proceed,state,final,boolean,is,optional,final,iterative,condition,t,true,function,get,true,function,pattern,t,old,current,pattern,current,pattern,pattern,t,old,following,pattern,following,pattern,group,pattern,t,old,group,pattern,current,group,pattern,state,t,last,sink,sink,state,current,group,pattern,group,pattern,current,pattern,group,pattern,get,raw,pattern,last,sink,create,middle,states,last,sink,last,sink,convert,pattern,last,sink,if,is,optional,last,sink,add,proceed,proceed,state,true,function,current,pattern,old,current,pattern,following,pattern,old,following,pattern,current,group,pattern,old,group,pattern,return,last,sink
NFACompiler -> NFAFactoryCompiler -> private State<T> createGroupPatternState( 			final GroupPattern<T, ?> groupPattern, 			final State<T> sinkState, 			final State<T> proceedState, 			final boolean isOptional);1499760222;Create all the states for the group pattern.__@param groupPattern the group pattern to create the states for_@param sinkState the state that the group pattern being converted should point to_@param proceedState the state that the group pattern being converted should proceed to_@param isOptional whether the group pattern being converted is optional_@return the first state of the states of the group pattern;private State<T> createGroupPatternState(_			final GroupPattern<T, ?> groupPattern,_			final State<T> sinkState,_			final State<T> proceedState,_			final boolean isOptional) {_			final IterativeCondition<T> proceedCondition = getTrueFunction()___			Pattern<T, ?> oldCurrentPattern = currentPattern__			Pattern<T, ?> oldFollowingPattern = followingPattern__			GroupPattern<T, ?> oldGroupPattern = currentGroupPattern___			State<T> lastSink = sinkState__			currentGroupPattern = groupPattern__			currentPattern = groupPattern.getRawPattern()__			lastSink = createMiddleStates(lastSink)__			lastSink = convertPattern(lastSink)__			if (isOptional) {_				_				_				lastSink.addProceed(proceedState, proceedCondition)__			}_			currentPattern = oldCurrentPattern__			followingPattern = oldFollowingPattern__			currentGroupPattern = oldGroupPattern__			return lastSink__		};create,all,the,states,for,the,group,pattern,param,group,pattern,the,group,pattern,to,create,the,states,for,param,sink,state,the,state,that,the,group,pattern,being,converted,should,point,to,param,proceed,state,the,state,that,the,group,pattern,being,converted,should,proceed,to,param,is,optional,whether,the,group,pattern,being,converted,is,optional,return,the,first,state,of,the,states,of,the,group,pattern;private,state,t,create,group,pattern,state,final,group,pattern,t,group,pattern,final,state,t,sink,state,final,state,t,proceed,state,final,boolean,is,optional,final,iterative,condition,t,proceed,condition,get,true,function,pattern,t,old,current,pattern,current,pattern,pattern,t,old,following,pattern,following,pattern,group,pattern,t,old,group,pattern,current,group,pattern,state,t,last,sink,sink,state,current,group,pattern,group,pattern,current,pattern,group,pattern,get,raw,pattern,last,sink,create,middle,states,last,sink,last,sink,convert,pattern,last,sink,if,is,optional,last,sink,add,proceed,proceed,state,proceed,condition,current,pattern,old,current,pattern,following,pattern,old,following,pattern,current,group,pattern,old,group,pattern,return,last,sink
NFACompiler -> NFAFactoryCompiler -> private State<T> createGroupPatternState( 			final GroupPattern<T, ?> groupPattern, 			final State<T> sinkState, 			final State<T> proceedState, 			final boolean isOptional);1499937690;Create all the states for the group pattern.__@param groupPattern the group pattern to create the states for_@param sinkState the state that the group pattern being converted should point to_@param proceedState the state that the group pattern being converted should proceed to_@param isOptional whether the group pattern being converted is optional_@return the first state of the states of the group pattern;private State<T> createGroupPatternState(_			final GroupPattern<T, ?> groupPattern,_			final State<T> sinkState,_			final State<T> proceedState,_			final boolean isOptional) {_			final IterativeCondition<T> trueFunction = getTrueFunction()___			Pattern<T, ?> oldCurrentPattern = currentPattern__			Pattern<T, ?> oldFollowingPattern = followingPattern__			GroupPattern<T, ?> oldGroupPattern = currentGroupPattern__			State<T> lastSink = sinkState__			currentGroupPattern = groupPattern__			currentPattern = groupPattern.getRawPattern()__			lastSink = createMiddleStates(lastSink)__			lastSink = convertPattern(lastSink)__			if (isOptional) {_				_				_				lastSink.addProceed(proceedState, trueFunction)__			}_			currentPattern = oldCurrentPattern__			followingPattern = oldFollowingPattern__			currentGroupPattern = oldGroupPattern__			return lastSink__		};create,all,the,states,for,the,group,pattern,param,group,pattern,the,group,pattern,to,create,the,states,for,param,sink,state,the,state,that,the,group,pattern,being,converted,should,point,to,param,proceed,state,the,state,that,the,group,pattern,being,converted,should,proceed,to,param,is,optional,whether,the,group,pattern,being,converted,is,optional,return,the,first,state,of,the,states,of,the,group,pattern;private,state,t,create,group,pattern,state,final,group,pattern,t,group,pattern,final,state,t,sink,state,final,state,t,proceed,state,final,boolean,is,optional,final,iterative,condition,t,true,function,get,true,function,pattern,t,old,current,pattern,current,pattern,pattern,t,old,following,pattern,following,pattern,group,pattern,t,old,group,pattern,current,group,pattern,state,t,last,sink,sink,state,current,group,pattern,group,pattern,current,pattern,group,pattern,get,raw,pattern,last,sink,create,middle,states,last,sink,last,sink,convert,pattern,last,sink,if,is,optional,last,sink,add,proceed,proceed,state,true,function,current,pattern,old,current,pattern,following,pattern,old,following,pattern,current,group,pattern,old,group,pattern,return,last,sink
NFACompiler -> NFAFactoryCompiler -> private State<T> createGroupPatternState( 			final GroupPattern<T, ?> groupPattern, 			final State<T> sinkState, 			final State<T> proceedState, 			final boolean isOptional);1500021711;Create all the states for the group pattern.__@param groupPattern the group pattern to create the states for_@param sinkState the state that the group pattern being converted should point to_@param proceedState the state that the group pattern being converted should proceed to_@param isOptional whether the group pattern being converted is optional_@return the first state of the states of the group pattern;private State<T> createGroupPatternState(_			final GroupPattern<T, ?> groupPattern,_			final State<T> sinkState,_			final State<T> proceedState,_			final boolean isOptional) {_			final IterativeCondition<T> proceedCondition = getTrueFunction()___			Pattern<T, ?> oldCurrentPattern = currentPattern__			Pattern<T, ?> oldFollowingPattern = followingPattern__			GroupPattern<T, ?> oldGroupPattern = currentGroupPattern___			State<T> lastSink = sinkState__			currentGroupPattern = groupPattern__			currentPattern = groupPattern.getRawPattern()__			lastSink = createMiddleStates(lastSink)__			lastSink = convertPattern(lastSink)__			if (isOptional) {_				_				_				lastSink.addProceed(proceedState, proceedCondition)__			}_			currentPattern = oldCurrentPattern__			followingPattern = oldFollowingPattern__			currentGroupPattern = oldGroupPattern__			return lastSink__		};create,all,the,states,for,the,group,pattern,param,group,pattern,the,group,pattern,to,create,the,states,for,param,sink,state,the,state,that,the,group,pattern,being,converted,should,point,to,param,proceed,state,the,state,that,the,group,pattern,being,converted,should,proceed,to,param,is,optional,whether,the,group,pattern,being,converted,is,optional,return,the,first,state,of,the,states,of,the,group,pattern;private,state,t,create,group,pattern,state,final,group,pattern,t,group,pattern,final,state,t,sink,state,final,state,t,proceed,state,final,boolean,is,optional,final,iterative,condition,t,proceed,condition,get,true,function,pattern,t,old,current,pattern,current,pattern,pattern,t,old,following,pattern,following,pattern,group,pattern,t,old,group,pattern,current,group,pattern,state,t,last,sink,sink,state,current,group,pattern,group,pattern,current,pattern,group,pattern,get,raw,pattern,last,sink,create,middle,states,last,sink,last,sink,convert,pattern,last,sink,if,is,optional,last,sink,add,proceed,proceed,state,proceed,condition,current,pattern,old,current,pattern,following,pattern,old,following,pattern,current,group,pattern,old,group,pattern,return,last,sink
NFACompiler -> NFAFactoryCompiler -> private State<T> createGroupPatternState( 			final GroupPattern<T, ?> groupPattern, 			final State<T> sinkState, 			final State<T> proceedState, 			final boolean isOptional);1501592283;Create all the states for the group pattern.__@param groupPattern the group pattern to create the states for_@param sinkState the state that the group pattern being converted should point to_@param proceedState the state that the group pattern being converted should proceed to_@param isOptional whether the group pattern being converted is optional_@return the first state of the states of the group pattern;private State<T> createGroupPatternState(_			final GroupPattern<T, ?> groupPattern,_			final State<T> sinkState,_			final State<T> proceedState,_			final boolean isOptional) {_			final IterativeCondition<T> trueFunction = getTrueFunction()___			Pattern<T, ?> oldCurrentPattern = currentPattern__			Pattern<T, ?> oldFollowingPattern = followingPattern__			GroupPattern<T, ?> oldGroupPattern = currentGroupPattern__			State<T> lastSink = sinkState__			currentGroupPattern = groupPattern__			currentPattern = groupPattern.getRawPattern()__			lastSink = createMiddleStates(lastSink)__			lastSink = convertPattern(lastSink)__			if (isOptional) {_				_				_				lastSink.addProceed(proceedState, trueFunction)__			}_			currentPattern = oldCurrentPattern__			followingPattern = oldFollowingPattern__			currentGroupPattern = oldGroupPattern__			return lastSink__		};create,all,the,states,for,the,group,pattern,param,group,pattern,the,group,pattern,to,create,the,states,for,param,sink,state,the,state,that,the,group,pattern,being,converted,should,point,to,param,proceed,state,the,state,that,the,group,pattern,being,converted,should,proceed,to,param,is,optional,whether,the,group,pattern,being,converted,is,optional,return,the,first,state,of,the,states,of,the,group,pattern;private,state,t,create,group,pattern,state,final,group,pattern,t,group,pattern,final,state,t,sink,state,final,state,t,proceed,state,final,boolean,is,optional,final,iterative,condition,t,true,function,get,true,function,pattern,t,old,current,pattern,current,pattern,pattern,t,old,following,pattern,following,pattern,group,pattern,t,old,group,pattern,current,group,pattern,state,t,last,sink,sink,state,current,group,pattern,group,pattern,current,pattern,group,pattern,get,raw,pattern,last,sink,create,middle,states,last,sink,last,sink,convert,pattern,last,sink,if,is,optional,last,sink,add,proceed,proceed,state,true,function,current,pattern,old,current,pattern,following,pattern,old,following,pattern,current,group,pattern,old,group,pattern,return,last,sink
NFACompiler -> NFAFactoryCompiler -> private State<T> createGroupPatternState( 			final GroupPattern<T, ?> groupPattern, 			final State<T> sinkState, 			final State<T> proceedState, 			final boolean isOptional);1502422141;Create all the states for the group pattern.__@param groupPattern the group pattern to create the states for_@param sinkState the state that the group pattern being converted should point to_@param proceedState the state that the group pattern being converted should proceed to_@param isOptional whether the group pattern being converted is optional_@return the first state of the states of the group pattern;private State<T> createGroupPatternState(_			final GroupPattern<T, ?> groupPattern,_			final State<T> sinkState,_			final State<T> proceedState,_			final boolean isOptional) {_			final IterativeCondition<T> trueFunction = getTrueFunction()___			Pattern<T, ?> oldCurrentPattern = currentPattern__			Pattern<T, ?> oldFollowingPattern = followingPattern__			GroupPattern<T, ?> oldGroupPattern = currentGroupPattern__			State<T> lastSink = sinkState__			currentGroupPattern = groupPattern__			currentPattern = groupPattern.getRawPattern()__			lastSink = createMiddleStates(lastSink)__			lastSink = convertPattern(lastSink)__			if (isOptional) {_				_				_				lastSink.addProceed(proceedState, trueFunction)__			}_			currentPattern = oldCurrentPattern__			followingPattern = oldFollowingPattern__			currentGroupPattern = oldGroupPattern__			return lastSink__		};create,all,the,states,for,the,group,pattern,param,group,pattern,the,group,pattern,to,create,the,states,for,param,sink,state,the,state,that,the,group,pattern,being,converted,should,point,to,param,proceed,state,the,state,that,the,group,pattern,being,converted,should,proceed,to,param,is,optional,whether,the,group,pattern,being,converted,is,optional,return,the,first,state,of,the,states,of,the,group,pattern;private,state,t,create,group,pattern,state,final,group,pattern,t,group,pattern,final,state,t,sink,state,final,state,t,proceed,state,final,boolean,is,optional,final,iterative,condition,t,true,function,get,true,function,pattern,t,old,current,pattern,current,pattern,pattern,t,old,following,pattern,following,pattern,group,pattern,t,old,group,pattern,current,group,pattern,state,t,last,sink,sink,state,current,group,pattern,group,pattern,current,pattern,group,pattern,get,raw,pattern,last,sink,create,middle,states,last,sink,last,sink,convert,pattern,last,sink,if,is,optional,last,sink,add,proceed,proceed,state,true,function,current,pattern,old,current,pattern,following,pattern,old,following,pattern,current,group,pattern,old,group,pattern,return,last,sink
NFACompiler -> NFAFactoryCompiler -> private State<T> createGroupPatternState( 			final GroupPattern<T, ?> groupPattern, 			final State<T> sinkState, 			final State<T> proceedState, 			final boolean isOptional);1503588494;Create all the states for the group pattern.__@param groupPattern the group pattern to create the states for_@param sinkState the state that the group pattern being converted should point to_@param proceedState the state that the group pattern being converted should proceed to_@param isOptional whether the group pattern being converted is optional_@return the first state of the states of the group pattern;private State<T> createGroupPatternState(_			final GroupPattern<T, ?> groupPattern,_			final State<T> sinkState,_			final State<T> proceedState,_			final boolean isOptional) {_			final IterativeCondition<T> proceedCondition = getTrueFunction()___			Pattern<T, ?> oldCurrentPattern = currentPattern__			Pattern<T, ?> oldFollowingPattern = followingPattern__			GroupPattern<T, ?> oldGroupPattern = currentGroupPattern___			State<T> lastSink = sinkState__			currentGroupPattern = groupPattern__			currentPattern = groupPattern.getRawPattern()__			lastSink = createMiddleStates(lastSink)__			lastSink = convertPattern(lastSink)__			if (isOptional) {_				_				_				lastSink.addProceed(proceedState, proceedCondition)__			}_			currentPattern = oldCurrentPattern__			followingPattern = oldFollowingPattern__			currentGroupPattern = oldGroupPattern__			return lastSink__		};create,all,the,states,for,the,group,pattern,param,group,pattern,the,group,pattern,to,create,the,states,for,param,sink,state,the,state,that,the,group,pattern,being,converted,should,point,to,param,proceed,state,the,state,that,the,group,pattern,being,converted,should,proceed,to,param,is,optional,whether,the,group,pattern,being,converted,is,optional,return,the,first,state,of,the,states,of,the,group,pattern;private,state,t,create,group,pattern,state,final,group,pattern,t,group,pattern,final,state,t,sink,state,final,state,t,proceed,state,final,boolean,is,optional,final,iterative,condition,t,proceed,condition,get,true,function,pattern,t,old,current,pattern,current,pattern,pattern,t,old,following,pattern,following,pattern,group,pattern,t,old,group,pattern,current,group,pattern,state,t,last,sink,sink,state,current,group,pattern,group,pattern,current,pattern,group,pattern,get,raw,pattern,last,sink,create,middle,states,last,sink,last,sink,convert,pattern,last,sink,if,is,optional,last,sink,add,proceed,proceed,state,proceed,condition,current,pattern,old,current,pattern,following,pattern,old,following,pattern,current,group,pattern,old,group,pattern,return,last,sink
NFACompiler -> NFAFactoryCompiler -> private State<T> createGroupPatternState( 			final GroupPattern<T, ?> groupPattern, 			final State<T> sinkState, 			final State<T> proceedState, 			final boolean isOptional);1518008111;Create all the states for the group pattern.__@param groupPattern the group pattern to create the states for_@param sinkState the state that the group pattern being converted should point to_@param proceedState the state that the group pattern being converted should proceed to_@param isOptional whether the group pattern being converted is optional_@return the first state of the states of the group pattern;private State<T> createGroupPatternState(_			final GroupPattern<T, ?> groupPattern,_			final State<T> sinkState,_			final State<T> proceedState,_			final boolean isOptional) {_			final IterativeCondition<T> proceedCondition = getTrueFunction()___			Pattern<T, ?> oldCurrentPattern = currentPattern__			Pattern<T, ?> oldFollowingPattern = followingPattern__			GroupPattern<T, ?> oldGroupPattern = currentGroupPattern___			State<T> lastSink = sinkState__			currentGroupPattern = groupPattern__			currentPattern = groupPattern.getRawPattern()__			lastSink = createMiddleStates(lastSink)__			lastSink = convertPattern(lastSink)__			if (isOptional) {_				_				_				lastSink.addProceed(proceedState, proceedCondition)__			}_			currentPattern = oldCurrentPattern__			followingPattern = oldFollowingPattern__			currentGroupPattern = oldGroupPattern__			return lastSink__		};create,all,the,states,for,the,group,pattern,param,group,pattern,the,group,pattern,to,create,the,states,for,param,sink,state,the,state,that,the,group,pattern,being,converted,should,point,to,param,proceed,state,the,state,that,the,group,pattern,being,converted,should,proceed,to,param,is,optional,whether,the,group,pattern,being,converted,is,optional,return,the,first,state,of,the,states,of,the,group,pattern;private,state,t,create,group,pattern,state,final,group,pattern,t,group,pattern,final,state,t,sink,state,final,state,t,proceed,state,final,boolean,is,optional,final,iterative,condition,t,proceed,condition,get,true,function,pattern,t,old,current,pattern,current,pattern,pattern,t,old,following,pattern,following,pattern,group,pattern,t,old,group,pattern,current,group,pattern,state,t,last,sink,sink,state,current,group,pattern,group,pattern,current,pattern,group,pattern,get,raw,pattern,last,sink,create,middle,states,last,sink,last,sink,convert,pattern,last,sink,if,is,optional,last,sink,add,proceed,proceed,state,proceed,condition,current,pattern,old,current,pattern,following,pattern,old,following,pattern,current,group,pattern,old,group,pattern,return,last,sink
NFACompiler -> NFAFactoryCompiler -> private State<T> createGroupPatternState( 			final GroupPattern<T, ?> groupPattern, 			final State<T> sinkState, 			final State<T> proceedState, 			final boolean isOptional);1527863170;Create all the states for the group pattern.__@param groupPattern the group pattern to create the states for_@param sinkState the state that the group pattern being converted should point to_@param proceedState the state that the group pattern being converted should proceed to_@param isOptional whether the group pattern being converted is optional_@return the first state of the states of the group pattern;private State<T> createGroupPatternState(_			final GroupPattern<T, ?> groupPattern,_			final State<T> sinkState,_			final State<T> proceedState,_			final boolean isOptional) {_			final IterativeCondition<T> proceedCondition = getTrueFunction()___			Pattern<T, ?> oldCurrentPattern = currentPattern__			Pattern<T, ?> oldFollowingPattern = followingPattern__			GroupPattern<T, ?> oldGroupPattern = currentGroupPattern___			State<T> lastSink = sinkState__			currentGroupPattern = groupPattern__			currentPattern = groupPattern.getRawPattern()__			lastSink = createMiddleStates(lastSink)__			lastSink = convertPattern(lastSink)__			if (isOptional) {_				_				_				lastSink.addProceed(proceedState, proceedCondition)__			}_			currentPattern = oldCurrentPattern__			followingPattern = oldFollowingPattern__			currentGroupPattern = oldGroupPattern__			return lastSink__		};create,all,the,states,for,the,group,pattern,param,group,pattern,the,group,pattern,to,create,the,states,for,param,sink,state,the,state,that,the,group,pattern,being,converted,should,point,to,param,proceed,state,the,state,that,the,group,pattern,being,converted,should,proceed,to,param,is,optional,whether,the,group,pattern,being,converted,is,optional,return,the,first,state,of,the,states,of,the,group,pattern;private,state,t,create,group,pattern,state,final,group,pattern,t,group,pattern,final,state,t,sink,state,final,state,t,proceed,state,final,boolean,is,optional,final,iterative,condition,t,proceed,condition,get,true,function,pattern,t,old,current,pattern,current,pattern,pattern,t,old,following,pattern,following,pattern,group,pattern,t,old,group,pattern,current,group,pattern,state,t,last,sink,sink,state,current,group,pattern,group,pattern,current,pattern,group,pattern,get,raw,pattern,last,sink,create,middle,states,last,sink,last,sink,convert,pattern,last,sink,if,is,optional,last,sink,add,proceed,proceed,state,proceed,condition,current,pattern,old,current,pattern,following,pattern,old,following,pattern,current,group,pattern,old,group,pattern,return,last,sink
NFACompiler -> NFAFactoryCompiler -> private State<T> createGroupPatternState( 			final GroupPattern<T, ?> groupPattern, 			final State<T> sinkState, 			final State<T> proceedState, 			final boolean isOptional);1528989005;Create all the states for the group pattern.__@param groupPattern the group pattern to create the states for_@param sinkState the state that the group pattern being converted should point to_@param proceedState the state that the group pattern being converted should proceed to_@param isOptional whether the group pattern being converted is optional_@return the first state of the states of the group pattern;private State<T> createGroupPatternState(_			final GroupPattern<T, ?> groupPattern,_			final State<T> sinkState,_			final State<T> proceedState,_			final boolean isOptional) {_			final IterativeCondition<T> proceedCondition = getTrueFunction()___			Pattern<T, ?> oldCurrentPattern = currentPattern__			Pattern<T, ?> oldFollowingPattern = followingPattern__			GroupPattern<T, ?> oldGroupPattern = currentGroupPattern___			State<T> lastSink = sinkState__			currentGroupPattern = groupPattern__			currentPattern = groupPattern.getRawPattern()__			lastSink = createMiddleStates(lastSink)__			lastSink = convertPattern(lastSink)__			if (isOptional) {_				_				_				lastSink.addProceed(proceedState, proceedCondition)__			}_			currentPattern = oldCurrentPattern__			followingPattern = oldFollowingPattern__			currentGroupPattern = oldGroupPattern__			return lastSink__		};create,all,the,states,for,the,group,pattern,param,group,pattern,the,group,pattern,to,create,the,states,for,param,sink,state,the,state,that,the,group,pattern,being,converted,should,point,to,param,proceed,state,the,state,that,the,group,pattern,being,converted,should,proceed,to,param,is,optional,whether,the,group,pattern,being,converted,is,optional,return,the,first,state,of,the,states,of,the,group,pattern;private,state,t,create,group,pattern,state,final,group,pattern,t,group,pattern,final,state,t,sink,state,final,state,t,proceed,state,final,boolean,is,optional,final,iterative,condition,t,proceed,condition,get,true,function,pattern,t,old,current,pattern,current,pattern,pattern,t,old,following,pattern,following,pattern,group,pattern,t,old,group,pattern,current,group,pattern,state,t,last,sink,sink,state,current,group,pattern,group,pattern,current,pattern,group,pattern,get,raw,pattern,last,sink,create,middle,states,last,sink,last,sink,convert,pattern,last,sink,if,is,optional,last,sink,add,proceed,proceed,state,proceed,condition,current,pattern,old,current,pattern,following,pattern,old,following,pattern,current,group,pattern,old,group,pattern,return,last,sink
NFACompiler -> NFAFactoryCompiler -> private State<T> createGroupPatternState( 			final GroupPattern<T, ?> groupPattern, 			final State<T> sinkState, 			final State<T> proceedState, 			final boolean isOptional);1538745898;Create all the states for the group pattern.__@param groupPattern the group pattern to create the states for_@param sinkState the state that the group pattern being converted should point to_@param proceedState the state that the group pattern being converted should proceed to_@param isOptional whether the group pattern being converted is optional_@return the first state of the states of the group pattern;private State<T> createGroupPatternState(_			final GroupPattern<T, ?> groupPattern,_			final State<T> sinkState,_			final State<T> proceedState,_			final boolean isOptional) {_			final IterativeCondition<T> proceedCondition = getTrueFunction()___			Pattern<T, ?> oldCurrentPattern = currentPattern__			Pattern<T, ?> oldFollowingPattern = followingPattern__			GroupPattern<T, ?> oldGroupPattern = currentGroupPattern___			State<T> lastSink = sinkState__			currentGroupPattern = groupPattern__			currentPattern = groupPattern.getRawPattern()__			lastSink = createMiddleStates(lastSink)__			lastSink = convertPattern(lastSink)__			if (isOptional) {_				_				_				lastSink.addProceed(proceedState, proceedCondition)__			}_			currentPattern = oldCurrentPattern__			followingPattern = oldFollowingPattern__			currentGroupPattern = oldGroupPattern__			return lastSink__		};create,all,the,states,for,the,group,pattern,param,group,pattern,the,group,pattern,to,create,the,states,for,param,sink,state,the,state,that,the,group,pattern,being,converted,should,point,to,param,proceed,state,the,state,that,the,group,pattern,being,converted,should,proceed,to,param,is,optional,whether,the,group,pattern,being,converted,is,optional,return,the,first,state,of,the,states,of,the,group,pattern;private,state,t,create,group,pattern,state,final,group,pattern,t,group,pattern,final,state,t,sink,state,final,state,t,proceed,state,final,boolean,is,optional,final,iterative,condition,t,proceed,condition,get,true,function,pattern,t,old,current,pattern,current,pattern,pattern,t,old,following,pattern,following,pattern,group,pattern,t,old,group,pattern,current,group,pattern,state,t,last,sink,sink,state,current,group,pattern,group,pattern,current,pattern,group,pattern,get,raw,pattern,last,sink,create,middle,states,last,sink,last,sink,convert,pattern,last,sink,if,is,optional,last,sink,add,proceed,proceed,state,proceed,condition,current,pattern,old,current,pattern,following,pattern,old,following,pattern,current,group,pattern,old,group,pattern,return,last,sink
NFACompiler -> NFAFactoryCompiler -> private State<T> createGroupPatternState( 			final GroupPattern<T, ?> groupPattern, 			final State<T> sinkState, 			final State<T> proceedState, 			final boolean isOptional);1542293931;Create all the states for the group pattern.__@param groupPattern the group pattern to create the states for_@param sinkState the state that the group pattern being converted should point to_@param proceedState the state that the group pattern being converted should proceed to_@param isOptional whether the group pattern being converted is optional_@return the first state of the states of the group pattern;private State<T> createGroupPatternState(_			final GroupPattern<T, ?> groupPattern,_			final State<T> sinkState,_			final State<T> proceedState,_			final boolean isOptional) {_			final IterativeCondition<T> proceedCondition = getTrueFunction()___			Pattern<T, ?> oldCurrentPattern = currentPattern__			Pattern<T, ?> oldFollowingPattern = followingPattern__			GroupPattern<T, ?> oldGroupPattern = currentGroupPattern___			State<T> lastSink = sinkState__			currentGroupPattern = groupPattern__			currentPattern = groupPattern.getRawPattern()__			lastSink = createMiddleStates(lastSink)__			lastSink = convertPattern(lastSink)__			if (isOptional) {_				_				_				lastSink.addProceed(proceedState, proceedCondition)__			}_			currentPattern = oldCurrentPattern__			followingPattern = oldFollowingPattern__			currentGroupPattern = oldGroupPattern__			return lastSink__		};create,all,the,states,for,the,group,pattern,param,group,pattern,the,group,pattern,to,create,the,states,for,param,sink,state,the,state,that,the,group,pattern,being,converted,should,point,to,param,proceed,state,the,state,that,the,group,pattern,being,converted,should,proceed,to,param,is,optional,whether,the,group,pattern,being,converted,is,optional,return,the,first,state,of,the,states,of,the,group,pattern;private,state,t,create,group,pattern,state,final,group,pattern,t,group,pattern,final,state,t,sink,state,final,state,t,proceed,state,final,boolean,is,optional,final,iterative,condition,t,proceed,condition,get,true,function,pattern,t,old,current,pattern,current,pattern,pattern,t,old,following,pattern,following,pattern,group,pattern,t,old,group,pattern,current,group,pattern,state,t,last,sink,sink,state,current,group,pattern,group,pattern,current,pattern,group,pattern,get,raw,pattern,last,sink,create,middle,states,last,sink,last,sink,convert,pattern,last,sink,if,is,optional,last,sink,add,proceed,proceed,state,proceed,condition,current,pattern,old,current,pattern,following,pattern,old,following,pattern,current,group,pattern,old,group,pattern,return,last,sink
NFACompiler -> NFAFactoryCompiler -> @SuppressWarnings("unchecked") 		private IterativeCondition<T> getIgnoreCondition(Pattern<T, ?> pattern);1493200673;@return The {@link IterativeCondition condition} for the {@code IGNORE} edge_that corresponds to the specified {@link Pattern}. For more on strategy see {@link Quantifier};@SuppressWarnings("unchecked")_		private IterativeCondition<T> getIgnoreCondition(Pattern<T, ?> pattern) {_			switch (pattern.getQuantifier().getConsumingStrategy()) {_				case STRICT:_					return null__				case SKIP_TILL_NEXT:_					return new NotCondition<>((IterativeCondition<T>) pattern.getCondition())__				case SKIP_TILL_ANY:_					return BooleanConditions.trueFunction()__			}_			return null__		};return,the,link,iterative,condition,condition,for,the,code,ignore,edge,that,corresponds,to,the,specified,link,pattern,for,more,on,strategy,see,link,quantifier;suppress,warnings,unchecked,private,iterative,condition,t,get,ignore,condition,pattern,t,pattern,switch,pattern,get,quantifier,get,consuming,strategy,case,strict,return,null,case,return,new,not,condition,iterative,condition,t,pattern,get,condition,case,return,boolean,conditions,true,function,return,null
NFACompiler -> NFAFactoryCompiler -> @SuppressWarnings("unchecked") 		private IterativeCondition<T> getIgnoreCondition(Pattern<T, ?> pattern);1493385877;@return The {@link IterativeCondition condition} for the {@code IGNORE} edge_that corresponds to the specified {@link Pattern}. For more on strategy see {@link Quantifier};@SuppressWarnings("unchecked")_		private IterativeCondition<T> getIgnoreCondition(Pattern<T, ?> pattern) {_			switch (pattern.getQuantifier().getConsumingStrategy()) {_				case STRICT:_					return null__				case SKIP_TILL_NEXT:_					return new NotCondition<>((IterativeCondition<T>) pattern.getCondition())__				case SKIP_TILL_ANY:_					return BooleanConditions.trueFunction()__			}_			return null__		};return,the,link,iterative,condition,condition,for,the,code,ignore,edge,that,corresponds,to,the,specified,link,pattern,for,more,on,strategy,see,link,quantifier;suppress,warnings,unchecked,private,iterative,condition,t,get,ignore,condition,pattern,t,pattern,switch,pattern,get,quantifier,get,consuming,strategy,case,strict,return,null,case,return,new,not,condition,iterative,condition,t,pattern,get,condition,case,return,boolean,conditions,true,function,return,null
NFACompiler -> NFAFactoryCompiler -> @SuppressWarnings("unchecked") 		private IterativeCondition<T> getIgnoreCondition(Pattern<T, ?> pattern);1494947249;@return The {@link IterativeCondition condition} for the {@code IGNORE} edge_that corresponds to the specified {@link Pattern}. For more on strategy see {@link Quantifier};@SuppressWarnings("unchecked")_		private IterativeCondition<T> getIgnoreCondition(Pattern<T, ?> pattern) {_			switch (pattern.getQuantifier().getConsumingStrategy()) {_				case STRICT:_					return null__				case SKIP_TILL_NEXT:_					return new NotCondition<>((IterativeCondition<T>) pattern.getCondition())__				case SKIP_TILL_ANY:_					return BooleanConditions.trueFunction()__			}_			return null__		};return,the,link,iterative,condition,condition,for,the,code,ignore,edge,that,corresponds,to,the,specified,link,pattern,for,more,on,strategy,see,link,quantifier;suppress,warnings,unchecked,private,iterative,condition,t,get,ignore,condition,pattern,t,pattern,switch,pattern,get,quantifier,get,consuming,strategy,case,strict,return,null,case,return,new,not,condition,iterative,condition,t,pattern,get,condition,case,return,boolean,conditions,true,function,return,null
NFACompiler -> NFAFactoryCompiler -> @SuppressWarnings("unchecked") 		private IterativeCondition<T> getIgnoreCondition(Pattern<T, ?> pattern);1495657626;@return The {@link IterativeCondition condition} for the {@code IGNORE} edge_that corresponds to the specified {@link Pattern}. For more on strategy see {@link Quantifier};@SuppressWarnings("unchecked")_		private IterativeCondition<T> getIgnoreCondition(Pattern<T, ?> pattern) {_			switch (pattern.getQuantifier().getConsumingStrategy()) {_				case STRICT:_					return null__				case SKIP_TILL_NEXT:_					return new NotCondition<>((IterativeCondition<T>) pattern.getCondition())__				case SKIP_TILL_ANY:_					return BooleanConditions.trueFunction()__			}_			return null__		};return,the,link,iterative,condition,condition,for,the,code,ignore,edge,that,corresponds,to,the,specified,link,pattern,for,more,on,strategy,see,link,quantifier;suppress,warnings,unchecked,private,iterative,condition,t,get,ignore,condition,pattern,t,pattern,switch,pattern,get,quantifier,get,consuming,strategy,case,strict,return,null,case,return,new,not,condition,iterative,condition,t,pattern,get,condition,case,return,boolean,conditions,true,function,return,null
NFACompiler -> NFAFactoryCompiler -> @SuppressWarnings("unchecked") 		private IterativeCondition<T> getIgnoreCondition(Pattern<T, ?> pattern);1496245714;@return The {@link IterativeCondition condition} for the {@code IGNORE} edge_that corresponds to the specified {@link Pattern}. For more on strategy see {@link Quantifier};@SuppressWarnings("unchecked")_		private IterativeCondition<T> getIgnoreCondition(Pattern<T, ?> pattern) {_			switch (pattern.getQuantifier().getConsumingStrategy()) {_				case STRICT:_					return null__				case SKIP_TILL_NEXT:_					return new NotCondition<>((IterativeCondition<T>) pattern.getCondition())__				case SKIP_TILL_ANY:_					return BooleanConditions.trueFunction()__			}_			return null__		};return,the,link,iterative,condition,condition,for,the,code,ignore,edge,that,corresponds,to,the,specified,link,pattern,for,more,on,strategy,see,link,quantifier;suppress,warnings,unchecked,private,iterative,condition,t,get,ignore,condition,pattern,t,pattern,switch,pattern,get,quantifier,get,consuming,strategy,case,strict,return,null,case,return,new,not,condition,iterative,condition,t,pattern,get,condition,case,return,boolean,conditions,true,function,return,null
NFACompiler -> NFAFactoryCompiler -> @SuppressWarnings("unchecked") 		private IterativeCondition<T> getIgnoreCondition(Pattern<T, ?> pattern);1497410381;@return The {@link IterativeCondition condition} for the {@code IGNORE} edge_that corresponds to the specified {@link Pattern}. For more on strategy see {@link Quantifier};@SuppressWarnings("unchecked")_		private IterativeCondition<T> getIgnoreCondition(Pattern<T, ?> pattern) {_			switch (pattern.getQuantifier().getConsumingStrategy()) {_				case STRICT:_					return null__				case SKIP_TILL_NEXT:_					return new NotCondition<>((IterativeCondition<T>) pattern.getCondition())__				case SKIP_TILL_ANY:_					return BooleanConditions.trueFunction()__			}_			return null__		};return,the,link,iterative,condition,condition,for,the,code,ignore,edge,that,corresponds,to,the,specified,link,pattern,for,more,on,strategy,see,link,quantifier;suppress,warnings,unchecked,private,iterative,condition,t,get,ignore,condition,pattern,t,pattern,switch,pattern,get,quantifier,get,consuming,strategy,case,strict,return,null,case,return,new,not,condition,iterative,condition,t,pattern,get,condition,case,return,boolean,conditions,true,function,return,null
NFACompiler -> NFAFactoryCompiler -> @SuppressWarnings("unchecked") 		private IterativeCondition<T> getIgnoreCondition(Pattern<T, ?> pattern);1497883202;@return The {@link IterativeCondition condition} for the {@code IGNORE} edge_that corresponds to the specified {@link Pattern}. For more on strategy see {@link Quantifier};@SuppressWarnings("unchecked")_		private IterativeCondition<T> getIgnoreCondition(Pattern<T, ?> pattern) {_			switch (pattern.getQuantifier().getConsumingStrategy()) {_				case STRICT:_					return null__				case SKIP_TILL_NEXT:_					return new NotCondition<>((IterativeCondition<T>) pattern.getCondition())__				case SKIP_TILL_ANY:_					return BooleanConditions.trueFunction()__			}_			return null__		};return,the,link,iterative,condition,condition,for,the,code,ignore,edge,that,corresponds,to,the,specified,link,pattern,for,more,on,strategy,see,link,quantifier;suppress,warnings,unchecked,private,iterative,condition,t,get,ignore,condition,pattern,t,pattern,switch,pattern,get,quantifier,get,consuming,strategy,case,strict,return,null,case,return,new,not,condition,iterative,condition,t,pattern,get,condition,case,return,boolean,conditions,true,function,return,null
NFACompiler -> NFAFactoryCompiler -> @SuppressWarnings("unchecked") 		private IterativeCondition<T> getIgnoreCondition(Pattern<T, ?> pattern);1498034481;@return The {@link IterativeCondition condition} for the {@code IGNORE} edge_that corresponds to the specified {@link Pattern} and extended with_stop(until) condition if necessary. For more on strategy see {@link Quantifier};@SuppressWarnings("unchecked")_		private IterativeCondition<T> getIgnoreCondition(Pattern<T, ?> pattern) {_			Quantifier.ConsumingStrategy consumingStrategy = pattern.getQuantifier().getConsumingStrategy()__			if (headOfGroup(pattern)) {_				_				_				_				if (isCurrentGroupPatternFirstOfLoop()) {_					consumingStrategy = currentGroupPattern.getQuantifier().getConsumingStrategy()__				} else {_					consumingStrategy = currentGroupPattern.getQuantifier().getInnerConsumingStrategy()__				}_			}__			IterativeCondition<T> ignoreCondition = null__			switch (consumingStrategy) {_				case STRICT:_					ignoreCondition = null__					break__				case SKIP_TILL_NEXT:_					ignoreCondition = new NotCondition<>((IterativeCondition<T>) pattern.getCondition())__					break__				case SKIP_TILL_ANY:_					ignoreCondition = BooleanConditions.trueFunction()__					break__			}__			if (currentGroupPattern != null && currentGroupPattern.getUntilCondition() != null) {_				ignoreCondition = extendWithUntilCondition(_					ignoreCondition,_					(IterativeCondition<T>) currentGroupPattern.getUntilCondition())__			}_			return ignoreCondition__		};return,the,link,iterative,condition,condition,for,the,code,ignore,edge,that,corresponds,to,the,specified,link,pattern,and,extended,with,stop,until,condition,if,necessary,for,more,on,strategy,see,link,quantifier;suppress,warnings,unchecked,private,iterative,condition,t,get,ignore,condition,pattern,t,pattern,quantifier,consuming,strategy,consuming,strategy,pattern,get,quantifier,get,consuming,strategy,if,head,of,group,pattern,if,is,current,group,pattern,first,of,loop,consuming,strategy,current,group,pattern,get,quantifier,get,consuming,strategy,else,consuming,strategy,current,group,pattern,get,quantifier,get,inner,consuming,strategy,iterative,condition,t,ignore,condition,null,switch,consuming,strategy,case,strict,ignore,condition,null,break,case,ignore,condition,new,not,condition,iterative,condition,t,pattern,get,condition,break,case,ignore,condition,boolean,conditions,true,function,break,if,current,group,pattern,null,current,group,pattern,get,until,condition,null,ignore,condition,extend,with,until,condition,ignore,condition,iterative,condition,t,current,group,pattern,get,until,condition,return,ignore,condition
NFACompiler -> NFAFactoryCompiler -> @SuppressWarnings("unchecked") 		private IterativeCondition<T> getIgnoreCondition(Pattern<T, ?> pattern);1499760222;@return The {@link IterativeCondition condition} for the {@code IGNORE} edge_that corresponds to the specified {@link Pattern} and extended with_stop(until) condition if necessary. For more on strategy see {@link Quantifier};@SuppressWarnings("unchecked")_		private IterativeCondition<T> getIgnoreCondition(Pattern<T, ?> pattern) {_			Quantifier.ConsumingStrategy consumingStrategy = pattern.getQuantifier().getConsumingStrategy()__			if (headOfGroup(pattern)) {_				_				_				_				if (isCurrentGroupPatternFirstOfLoop()) {_					consumingStrategy = currentGroupPattern.getQuantifier().getConsumingStrategy()__				} else {_					consumingStrategy = currentGroupPattern.getQuantifier().getInnerConsumingStrategy()__				}_			}__			IterativeCondition<T> ignoreCondition = null__			switch (consumingStrategy) {_				case STRICT:_					ignoreCondition = null__					break__				case SKIP_TILL_NEXT:_					ignoreCondition = new NotCondition<>((IterativeCondition<T>) pattern.getCondition())__					break__				case SKIP_TILL_ANY:_					ignoreCondition = BooleanConditions.trueFunction()__					break__			}__			if (currentGroupPattern != null && currentGroupPattern.getUntilCondition() != null) {_				ignoreCondition = extendWithUntilCondition(_					ignoreCondition,_					(IterativeCondition<T>) currentGroupPattern.getUntilCondition(),_					false)__			}_			return ignoreCondition__		};return,the,link,iterative,condition,condition,for,the,code,ignore,edge,that,corresponds,to,the,specified,link,pattern,and,extended,with,stop,until,condition,if,necessary,for,more,on,strategy,see,link,quantifier;suppress,warnings,unchecked,private,iterative,condition,t,get,ignore,condition,pattern,t,pattern,quantifier,consuming,strategy,consuming,strategy,pattern,get,quantifier,get,consuming,strategy,if,head,of,group,pattern,if,is,current,group,pattern,first,of,loop,consuming,strategy,current,group,pattern,get,quantifier,get,consuming,strategy,else,consuming,strategy,current,group,pattern,get,quantifier,get,inner,consuming,strategy,iterative,condition,t,ignore,condition,null,switch,consuming,strategy,case,strict,ignore,condition,null,break,case,ignore,condition,new,not,condition,iterative,condition,t,pattern,get,condition,break,case,ignore,condition,boolean,conditions,true,function,break,if,current,group,pattern,null,current,group,pattern,get,until,condition,null,ignore,condition,extend,with,until,condition,ignore,condition,iterative,condition,t,current,group,pattern,get,until,condition,false,return,ignore,condition
NFACompiler -> NFAFactoryCompiler -> @SuppressWarnings("unchecked") 		private IterativeCondition<T> getIgnoreCondition(Pattern<T, ?> pattern);1499937690;@return The {@link IterativeCondition condition} for the {@code IGNORE} edge_that corresponds to the specified {@link Pattern} and extended with_stop(until) condition if necessary. For more on strategy see {@link Quantifier};@SuppressWarnings("unchecked")_		private IterativeCondition<T> getIgnoreCondition(Pattern<T, ?> pattern) {_			Quantifier.ConsumingStrategy consumingStrategy = pattern.getQuantifier().getConsumingStrategy()__			if (headOfGroup(pattern)) {_				_				_				_				if (isCurrentGroupPatternFirstOfLoop()) {_					consumingStrategy = currentGroupPattern.getQuantifier().getConsumingStrategy()__				} else {_					consumingStrategy = currentGroupPattern.getQuantifier().getInnerConsumingStrategy()__				}_			}__			IterativeCondition<T> ignoreCondition = null__			switch (consumingStrategy) {_				case STRICT:_					ignoreCondition = null__					break__				case SKIP_TILL_NEXT:_					ignoreCondition = new NotCondition<>((IterativeCondition<T>) pattern.getCondition())__					break__				case SKIP_TILL_ANY:_					ignoreCondition = BooleanConditions.trueFunction()__					break__			}__			if (currentGroupPattern != null && currentGroupPattern.getUntilCondition() != null) {_				ignoreCondition = extendWithUntilCondition(_					ignoreCondition,_					(IterativeCondition<T>) currentGroupPattern.getUntilCondition(),_					false)__			}_			return ignoreCondition__		};return,the,link,iterative,condition,condition,for,the,code,ignore,edge,that,corresponds,to,the,specified,link,pattern,and,extended,with,stop,until,condition,if,necessary,for,more,on,strategy,see,link,quantifier;suppress,warnings,unchecked,private,iterative,condition,t,get,ignore,condition,pattern,t,pattern,quantifier,consuming,strategy,consuming,strategy,pattern,get,quantifier,get,consuming,strategy,if,head,of,group,pattern,if,is,current,group,pattern,first,of,loop,consuming,strategy,current,group,pattern,get,quantifier,get,consuming,strategy,else,consuming,strategy,current,group,pattern,get,quantifier,get,inner,consuming,strategy,iterative,condition,t,ignore,condition,null,switch,consuming,strategy,case,strict,ignore,condition,null,break,case,ignore,condition,new,not,condition,iterative,condition,t,pattern,get,condition,break,case,ignore,condition,boolean,conditions,true,function,break,if,current,group,pattern,null,current,group,pattern,get,until,condition,null,ignore,condition,extend,with,until,condition,ignore,condition,iterative,condition,t,current,group,pattern,get,until,condition,false,return,ignore,condition
NFACompiler -> NFAFactoryCompiler -> @SuppressWarnings("unchecked") 		private IterativeCondition<T> getIgnoreCondition(Pattern<T, ?> pattern);1500021711;@return The {@link IterativeCondition condition} for the {@code IGNORE} edge_that corresponds to the specified {@link Pattern} and extended with_stop(until) condition if necessary. For more on strategy see {@link Quantifier};@SuppressWarnings("unchecked")_		private IterativeCondition<T> getIgnoreCondition(Pattern<T, ?> pattern) {_			Quantifier.ConsumingStrategy consumingStrategy = pattern.getQuantifier().getConsumingStrategy()__			if (headOfGroup(pattern)) {_				_				_				_				if (isCurrentGroupPatternFirstOfLoop()) {_					consumingStrategy = currentGroupPattern.getQuantifier().getConsumingStrategy()__				} else {_					consumingStrategy = currentGroupPattern.getQuantifier().getInnerConsumingStrategy()__				}_			}__			IterativeCondition<T> ignoreCondition = null__			switch (consumingStrategy) {_				case STRICT:_					ignoreCondition = null__					break__				case SKIP_TILL_NEXT:_					ignoreCondition = new NotCondition<>((IterativeCondition<T>) pattern.getCondition())__					break__				case SKIP_TILL_ANY:_					ignoreCondition = BooleanConditions.trueFunction()__					break__			}__			if (currentGroupPattern != null && currentGroupPattern.getUntilCondition() != null) {_				ignoreCondition = extendWithUntilCondition(_					ignoreCondition,_					(IterativeCondition<T>) currentGroupPattern.getUntilCondition(),_					false)__			}_			return ignoreCondition__		};return,the,link,iterative,condition,condition,for,the,code,ignore,edge,that,corresponds,to,the,specified,link,pattern,and,extended,with,stop,until,condition,if,necessary,for,more,on,strategy,see,link,quantifier;suppress,warnings,unchecked,private,iterative,condition,t,get,ignore,condition,pattern,t,pattern,quantifier,consuming,strategy,consuming,strategy,pattern,get,quantifier,get,consuming,strategy,if,head,of,group,pattern,if,is,current,group,pattern,first,of,loop,consuming,strategy,current,group,pattern,get,quantifier,get,consuming,strategy,else,consuming,strategy,current,group,pattern,get,quantifier,get,inner,consuming,strategy,iterative,condition,t,ignore,condition,null,switch,consuming,strategy,case,strict,ignore,condition,null,break,case,ignore,condition,new,not,condition,iterative,condition,t,pattern,get,condition,break,case,ignore,condition,boolean,conditions,true,function,break,if,current,group,pattern,null,current,group,pattern,get,until,condition,null,ignore,condition,extend,with,until,condition,ignore,condition,iterative,condition,t,current,group,pattern,get,until,condition,false,return,ignore,condition
NFACompiler -> NFAFactoryCompiler -> @SuppressWarnings("unchecked") 		private IterativeCondition<T> getIgnoreCondition(Pattern<T, ?> pattern);1501592283;@return The {@link IterativeCondition condition} for the {@code IGNORE} edge_that corresponds to the specified {@link Pattern} and extended with_stop(until) condition if necessary. For more on strategy see {@link Quantifier};@SuppressWarnings("unchecked")_		private IterativeCondition<T> getIgnoreCondition(Pattern<T, ?> pattern) {_			Quantifier.ConsumingStrategy consumingStrategy = pattern.getQuantifier().getConsumingStrategy()__			if (headOfGroup(pattern)) {_				_				_				_				if (isCurrentGroupPatternFirstOfLoop()) {_					consumingStrategy = currentGroupPattern.getQuantifier().getConsumingStrategy()__				} else {_					consumingStrategy = currentGroupPattern.getQuantifier().getInnerConsumingStrategy()__				}_			}__			IterativeCondition<T> ignoreCondition = null__			switch (consumingStrategy) {_				case STRICT:_					ignoreCondition = null__					break__				case SKIP_TILL_NEXT:_					ignoreCondition = new NotCondition<>((IterativeCondition<T>) pattern.getCondition())__					break__				case SKIP_TILL_ANY:_					ignoreCondition = BooleanConditions.trueFunction()__					break__			}__			if (currentGroupPattern != null && currentGroupPattern.getUntilCondition() != null) {_				ignoreCondition = extendWithUntilCondition(_					ignoreCondition,_					(IterativeCondition<T>) currentGroupPattern.getUntilCondition(),_					false)__			}_			return ignoreCondition__		};return,the,link,iterative,condition,condition,for,the,code,ignore,edge,that,corresponds,to,the,specified,link,pattern,and,extended,with,stop,until,condition,if,necessary,for,more,on,strategy,see,link,quantifier;suppress,warnings,unchecked,private,iterative,condition,t,get,ignore,condition,pattern,t,pattern,quantifier,consuming,strategy,consuming,strategy,pattern,get,quantifier,get,consuming,strategy,if,head,of,group,pattern,if,is,current,group,pattern,first,of,loop,consuming,strategy,current,group,pattern,get,quantifier,get,consuming,strategy,else,consuming,strategy,current,group,pattern,get,quantifier,get,inner,consuming,strategy,iterative,condition,t,ignore,condition,null,switch,consuming,strategy,case,strict,ignore,condition,null,break,case,ignore,condition,new,not,condition,iterative,condition,t,pattern,get,condition,break,case,ignore,condition,boolean,conditions,true,function,break,if,current,group,pattern,null,current,group,pattern,get,until,condition,null,ignore,condition,extend,with,until,condition,ignore,condition,iterative,condition,t,current,group,pattern,get,until,condition,false,return,ignore,condition
NFACompiler -> NFAFactoryCompiler -> @SuppressWarnings("unchecked") 		private IterativeCondition<T> getIgnoreCondition(Pattern<T, ?> pattern);1502422141;@return The {@link IterativeCondition condition} for the {@code IGNORE} edge_that corresponds to the specified {@link Pattern} and extended with_stop(until) condition if necessary. For more on strategy see {@link Quantifier};@SuppressWarnings("unchecked")_		private IterativeCondition<T> getIgnoreCondition(Pattern<T, ?> pattern) {_			Quantifier.ConsumingStrategy consumingStrategy = pattern.getQuantifier().getConsumingStrategy()__			if (headOfGroup(pattern)) {_				_				_				_				if (isCurrentGroupPatternFirstOfLoop()) {_					consumingStrategy = currentGroupPattern.getQuantifier().getConsumingStrategy()__				} else {_					consumingStrategy = currentGroupPattern.getQuantifier().getInnerConsumingStrategy()__				}_			}__			IterativeCondition<T> ignoreCondition = null__			switch (consumingStrategy) {_				case STRICT:_					ignoreCondition = null__					break__				case SKIP_TILL_NEXT:_					ignoreCondition = new NotCondition<>((IterativeCondition<T>) pattern.getCondition())__					break__				case SKIP_TILL_ANY:_					ignoreCondition = BooleanConditions.trueFunction()__					break__			}__			if (currentGroupPattern != null && currentGroupPattern.getUntilCondition() != null) {_				ignoreCondition = extendWithUntilCondition(_					ignoreCondition,_					(IterativeCondition<T>) currentGroupPattern.getUntilCondition(),_					false)__			}_			return ignoreCondition__		};return,the,link,iterative,condition,condition,for,the,code,ignore,edge,that,corresponds,to,the,specified,link,pattern,and,extended,with,stop,until,condition,if,necessary,for,more,on,strategy,see,link,quantifier;suppress,warnings,unchecked,private,iterative,condition,t,get,ignore,condition,pattern,t,pattern,quantifier,consuming,strategy,consuming,strategy,pattern,get,quantifier,get,consuming,strategy,if,head,of,group,pattern,if,is,current,group,pattern,first,of,loop,consuming,strategy,current,group,pattern,get,quantifier,get,consuming,strategy,else,consuming,strategy,current,group,pattern,get,quantifier,get,inner,consuming,strategy,iterative,condition,t,ignore,condition,null,switch,consuming,strategy,case,strict,ignore,condition,null,break,case,ignore,condition,new,not,condition,iterative,condition,t,pattern,get,condition,break,case,ignore,condition,boolean,conditions,true,function,break,if,current,group,pattern,null,current,group,pattern,get,until,condition,null,ignore,condition,extend,with,until,condition,ignore,condition,iterative,condition,t,current,group,pattern,get,until,condition,false,return,ignore,condition
NFACompiler -> NFAFactoryCompiler -> @SuppressWarnings("unchecked") 		private IterativeCondition<T> getIgnoreCondition(Pattern<T, ?> pattern);1503588494;@return The {@link IterativeCondition condition} for the {@code IGNORE} edge_that corresponds to the specified {@link Pattern} and extended with_stop(until) condition if necessary. For more on strategy see {@link Quantifier};@SuppressWarnings("unchecked")_		private IterativeCondition<T> getIgnoreCondition(Pattern<T, ?> pattern) {_			Quantifier.ConsumingStrategy consumingStrategy = pattern.getQuantifier().getConsumingStrategy()__			if (headOfGroup(pattern)) {_				_				_				_				if (isCurrentGroupPatternFirstOfLoop()) {_					consumingStrategy = currentGroupPattern.getQuantifier().getConsumingStrategy()__				} else {_					consumingStrategy = currentGroupPattern.getQuantifier().getInnerConsumingStrategy()__				}_			}__			IterativeCondition<T> ignoreCondition = null__			switch (consumingStrategy) {_				case STRICT:_					ignoreCondition = null__					break__				case SKIP_TILL_NEXT:_					ignoreCondition = new NotCondition<>((IterativeCondition<T>) pattern.getCondition())__					break__				case SKIP_TILL_ANY:_					ignoreCondition = BooleanConditions.trueFunction()__					break__			}__			if (currentGroupPattern != null && currentGroupPattern.getUntilCondition() != null) {_				ignoreCondition = extendWithUntilCondition(_					ignoreCondition,_					(IterativeCondition<T>) currentGroupPattern.getUntilCondition(),_					false)__			}_			return ignoreCondition__		};return,the,link,iterative,condition,condition,for,the,code,ignore,edge,that,corresponds,to,the,specified,link,pattern,and,extended,with,stop,until,condition,if,necessary,for,more,on,strategy,see,link,quantifier;suppress,warnings,unchecked,private,iterative,condition,t,get,ignore,condition,pattern,t,pattern,quantifier,consuming,strategy,consuming,strategy,pattern,get,quantifier,get,consuming,strategy,if,head,of,group,pattern,if,is,current,group,pattern,first,of,loop,consuming,strategy,current,group,pattern,get,quantifier,get,consuming,strategy,else,consuming,strategy,current,group,pattern,get,quantifier,get,inner,consuming,strategy,iterative,condition,t,ignore,condition,null,switch,consuming,strategy,case,strict,ignore,condition,null,break,case,ignore,condition,new,not,condition,iterative,condition,t,pattern,get,condition,break,case,ignore,condition,boolean,conditions,true,function,break,if,current,group,pattern,null,current,group,pattern,get,until,condition,null,ignore,condition,extend,with,until,condition,ignore,condition,iterative,condition,t,current,group,pattern,get,until,condition,false,return,ignore,condition
NFACompiler -> NFAFactoryCompiler -> @SuppressWarnings("unchecked") 		private IterativeCondition<T> getIgnoreCondition(Pattern<T, ?> pattern);1518008111;@return The {@link IterativeCondition condition} for the {@code IGNORE} edge_that corresponds to the specified {@link Pattern} and extended with_stop(until) condition if necessary. For more on strategy see {@link Quantifier};@SuppressWarnings("unchecked")_		private IterativeCondition<T> getIgnoreCondition(Pattern<T, ?> pattern) {_			Quantifier.ConsumingStrategy consumingStrategy = pattern.getQuantifier().getConsumingStrategy()__			if (headOfGroup(pattern)) {_				_				_				_				if (isCurrentGroupPatternFirstOfLoop()) {_					consumingStrategy = currentGroupPattern.getQuantifier().getConsumingStrategy()__				} else {_					consumingStrategy = currentGroupPattern.getQuantifier().getInnerConsumingStrategy()__				}_			}__			IterativeCondition<T> ignoreCondition = null__			switch (consumingStrategy) {_				case STRICT:_					ignoreCondition = null__					break__				case SKIP_TILL_NEXT:_					ignoreCondition = new NotCondition<>((IterativeCondition<T>) pattern.getCondition())__					break__				case SKIP_TILL_ANY:_					ignoreCondition = BooleanConditions.trueFunction()__					break__			}__			if (currentGroupPattern != null && currentGroupPattern.getUntilCondition() != null) {_				ignoreCondition = extendWithUntilCondition(_					ignoreCondition,_					(IterativeCondition<T>) currentGroupPattern.getUntilCondition(),_					false)__			}_			return ignoreCondition__		};return,the,link,iterative,condition,condition,for,the,code,ignore,edge,that,corresponds,to,the,specified,link,pattern,and,extended,with,stop,until,condition,if,necessary,for,more,on,strategy,see,link,quantifier;suppress,warnings,unchecked,private,iterative,condition,t,get,ignore,condition,pattern,t,pattern,quantifier,consuming,strategy,consuming,strategy,pattern,get,quantifier,get,consuming,strategy,if,head,of,group,pattern,if,is,current,group,pattern,first,of,loop,consuming,strategy,current,group,pattern,get,quantifier,get,consuming,strategy,else,consuming,strategy,current,group,pattern,get,quantifier,get,inner,consuming,strategy,iterative,condition,t,ignore,condition,null,switch,consuming,strategy,case,strict,ignore,condition,null,break,case,ignore,condition,new,not,condition,iterative,condition,t,pattern,get,condition,break,case,ignore,condition,boolean,conditions,true,function,break,if,current,group,pattern,null,current,group,pattern,get,until,condition,null,ignore,condition,extend,with,until,condition,ignore,condition,iterative,condition,t,current,group,pattern,get,until,condition,false,return,ignore,condition
NFACompiler -> NFAFactoryCompiler -> @SuppressWarnings("unchecked") 		private IterativeCondition<T> getIgnoreCondition(Pattern<T, ?> pattern);1527863170;@return The {@link IterativeCondition condition} for the {@code IGNORE} edge_that corresponds to the specified {@link Pattern} and extended with_stop(until) condition if necessary. For more on strategy see {@link Quantifier};@SuppressWarnings("unchecked")_		private IterativeCondition<T> getIgnoreCondition(Pattern<T, ?> pattern) {_			Quantifier.ConsumingStrategy consumingStrategy = pattern.getQuantifier().getConsumingStrategy()__			if (headOfGroup(pattern)) {_				_				_				_				if (isCurrentGroupPatternFirstOfLoop()) {_					consumingStrategy = currentGroupPattern.getQuantifier().getConsumingStrategy()__				} else {_					consumingStrategy = currentGroupPattern.getQuantifier().getInnerConsumingStrategy()__				}_			}__			IterativeCondition<T> ignoreCondition = null__			switch (consumingStrategy) {_				case STRICT:_					ignoreCondition = null__					break__				case SKIP_TILL_NEXT:_					ignoreCondition = new NotCondition<>((IterativeCondition<T>) pattern.getCondition())__					break__				case SKIP_TILL_ANY:_					ignoreCondition = BooleanConditions.trueFunction()__					break__			}__			if (currentGroupPattern != null && currentGroupPattern.getUntilCondition() != null) {_				ignoreCondition = extendWithUntilCondition(_					ignoreCondition,_					(IterativeCondition<T>) currentGroupPattern.getUntilCondition(),_					false)__			}_			return ignoreCondition__		};return,the,link,iterative,condition,condition,for,the,code,ignore,edge,that,corresponds,to,the,specified,link,pattern,and,extended,with,stop,until,condition,if,necessary,for,more,on,strategy,see,link,quantifier;suppress,warnings,unchecked,private,iterative,condition,t,get,ignore,condition,pattern,t,pattern,quantifier,consuming,strategy,consuming,strategy,pattern,get,quantifier,get,consuming,strategy,if,head,of,group,pattern,if,is,current,group,pattern,first,of,loop,consuming,strategy,current,group,pattern,get,quantifier,get,consuming,strategy,else,consuming,strategy,current,group,pattern,get,quantifier,get,inner,consuming,strategy,iterative,condition,t,ignore,condition,null,switch,consuming,strategy,case,strict,ignore,condition,null,break,case,ignore,condition,new,not,condition,iterative,condition,t,pattern,get,condition,break,case,ignore,condition,boolean,conditions,true,function,break,if,current,group,pattern,null,current,group,pattern,get,until,condition,null,ignore,condition,extend,with,until,condition,ignore,condition,iterative,condition,t,current,group,pattern,get,until,condition,false,return,ignore,condition
NFACompiler -> NFAFactoryCompiler -> @SuppressWarnings("unchecked") 		private IterativeCondition<T> getIgnoreCondition(Pattern<T, ?> pattern);1528989005;@return The {@link IterativeCondition condition} for the {@code IGNORE} edge_that corresponds to the specified {@link Pattern} and extended with_stop(until) condition if necessary. For more on strategy see {@link Quantifier};@SuppressWarnings("unchecked")_		private IterativeCondition<T> getIgnoreCondition(Pattern<T, ?> pattern) {_			Quantifier.ConsumingStrategy consumingStrategy = pattern.getQuantifier().getConsumingStrategy()__			if (headOfGroup(pattern)) {_				_				_				_				if (isCurrentGroupPatternFirstOfLoop()) {_					consumingStrategy = currentGroupPattern.getQuantifier().getConsumingStrategy()__				} else {_					consumingStrategy = currentGroupPattern.getQuantifier().getInnerConsumingStrategy()__				}_			}__			IterativeCondition<T> ignoreCondition = null__			switch (consumingStrategy) {_				case STRICT:_					ignoreCondition = null__					break__				case SKIP_TILL_NEXT:_					ignoreCondition = new NotCondition<>((IterativeCondition<T>) pattern.getCondition())__					break__				case SKIP_TILL_ANY:_					ignoreCondition = BooleanConditions.trueFunction()__					break__			}__			if (currentGroupPattern != null && currentGroupPattern.getUntilCondition() != null) {_				ignoreCondition = extendWithUntilCondition(_					ignoreCondition,_					(IterativeCondition<T>) currentGroupPattern.getUntilCondition(),_					false)__			}_			return ignoreCondition__		};return,the,link,iterative,condition,condition,for,the,code,ignore,edge,that,corresponds,to,the,specified,link,pattern,and,extended,with,stop,until,condition,if,necessary,for,more,on,strategy,see,link,quantifier;suppress,warnings,unchecked,private,iterative,condition,t,get,ignore,condition,pattern,t,pattern,quantifier,consuming,strategy,consuming,strategy,pattern,get,quantifier,get,consuming,strategy,if,head,of,group,pattern,if,is,current,group,pattern,first,of,loop,consuming,strategy,current,group,pattern,get,quantifier,get,consuming,strategy,else,consuming,strategy,current,group,pattern,get,quantifier,get,inner,consuming,strategy,iterative,condition,t,ignore,condition,null,switch,consuming,strategy,case,strict,ignore,condition,null,break,case,ignore,condition,new,not,condition,iterative,condition,t,pattern,get,condition,break,case,ignore,condition,boolean,conditions,true,function,break,if,current,group,pattern,null,current,group,pattern,get,until,condition,null,ignore,condition,extend,with,until,condition,ignore,condition,iterative,condition,t,current,group,pattern,get,until,condition,false,return,ignore,condition
NFACompiler -> NFAFactoryCompiler -> @SuppressWarnings("unchecked") 		private IterativeCondition<T> getIgnoreCondition(Pattern<T, ?> pattern);1538745898;@return The {@link IterativeCondition condition} for the {@code IGNORE} edge_that corresponds to the specified {@link Pattern} and extended with_stop(until) condition if necessary. For more on strategy see {@link Quantifier};@SuppressWarnings("unchecked")_		private IterativeCondition<T> getIgnoreCondition(Pattern<T, ?> pattern) {_			Quantifier.ConsumingStrategy consumingStrategy = pattern.getQuantifier().getConsumingStrategy()__			if (headOfGroup(pattern)) {_				_				_				_				if (isCurrentGroupPatternFirstOfLoop()) {_					consumingStrategy = currentGroupPattern.getQuantifier().getConsumingStrategy()__				} else {_					consumingStrategy = currentGroupPattern.getQuantifier().getInnerConsumingStrategy()__				}_			}__			IterativeCondition<T> ignoreCondition = null__			switch (consumingStrategy) {_				case STRICT:_					ignoreCondition = null__					break__				case SKIP_TILL_NEXT:_					ignoreCondition = new NotCondition<>((IterativeCondition<T>) pattern.getCondition())__					break__				case SKIP_TILL_ANY:_					ignoreCondition = BooleanConditions.trueFunction()__					break__			}__			if (currentGroupPattern != null && currentGroupPattern.getUntilCondition() != null) {_				ignoreCondition = extendWithUntilCondition(_					ignoreCondition,_					(IterativeCondition<T>) currentGroupPattern.getUntilCondition(),_					false)__			}_			return ignoreCondition__		};return,the,link,iterative,condition,condition,for,the,code,ignore,edge,that,corresponds,to,the,specified,link,pattern,and,extended,with,stop,until,condition,if,necessary,for,more,on,strategy,see,link,quantifier;suppress,warnings,unchecked,private,iterative,condition,t,get,ignore,condition,pattern,t,pattern,quantifier,consuming,strategy,consuming,strategy,pattern,get,quantifier,get,consuming,strategy,if,head,of,group,pattern,if,is,current,group,pattern,first,of,loop,consuming,strategy,current,group,pattern,get,quantifier,get,consuming,strategy,else,consuming,strategy,current,group,pattern,get,quantifier,get,inner,consuming,strategy,iterative,condition,t,ignore,condition,null,switch,consuming,strategy,case,strict,ignore,condition,null,break,case,ignore,condition,new,not,condition,iterative,condition,t,pattern,get,condition,break,case,ignore,condition,boolean,conditions,true,function,break,if,current,group,pattern,null,current,group,pattern,get,until,condition,null,ignore,condition,extend,with,until,condition,ignore,condition,iterative,condition,t,current,group,pattern,get,until,condition,false,return,ignore,condition
NFACompiler -> NFAFactoryCompiler -> @SuppressWarnings("unchecked") 		private IterativeCondition<T> getIgnoreCondition(Pattern<T, ?> pattern);1542293931;@return The {@link IterativeCondition condition} for the {@code IGNORE} edge_that corresponds to the specified {@link Pattern} and extended with_stop(until) condition if necessary. For more on strategy see {@link Quantifier};@SuppressWarnings("unchecked")_		private IterativeCondition<T> getIgnoreCondition(Pattern<T, ?> pattern) {_			Quantifier.ConsumingStrategy consumingStrategy = pattern.getQuantifier().getConsumingStrategy()__			if (headOfGroup(pattern)) {_				_				_				_				if (isCurrentGroupPatternFirstOfLoop()) {_					consumingStrategy = currentGroupPattern.getQuantifier().getConsumingStrategy()__				} else {_					consumingStrategy = currentGroupPattern.getQuantifier().getInnerConsumingStrategy()__				}_			}__			IterativeCondition<T> ignoreCondition = null__			switch (consumingStrategy) {_				case STRICT:_					ignoreCondition = null__					break__				case SKIP_TILL_NEXT:_					ignoreCondition = new RichNotCondition<>((IterativeCondition<T>) pattern.getCondition())__					break__				case SKIP_TILL_ANY:_					ignoreCondition = BooleanConditions.trueFunction()__					break__			}__			if (currentGroupPattern != null && currentGroupPattern.getUntilCondition() != null) {_				ignoreCondition = extendWithUntilCondition(_					ignoreCondition,_					(IterativeCondition<T>) currentGroupPattern.getUntilCondition(),_					false)__			}_			return ignoreCondition__		};return,the,link,iterative,condition,condition,for,the,code,ignore,edge,that,corresponds,to,the,specified,link,pattern,and,extended,with,stop,until,condition,if,necessary,for,more,on,strategy,see,link,quantifier;suppress,warnings,unchecked,private,iterative,condition,t,get,ignore,condition,pattern,t,pattern,quantifier,consuming,strategy,consuming,strategy,pattern,get,quantifier,get,consuming,strategy,if,head,of,group,pattern,if,is,current,group,pattern,first,of,loop,consuming,strategy,current,group,pattern,get,quantifier,get,consuming,strategy,else,consuming,strategy,current,group,pattern,get,quantifier,get,inner,consuming,strategy,iterative,condition,t,ignore,condition,null,switch,consuming,strategy,case,strict,ignore,condition,null,break,case,ignore,condition,new,rich,not,condition,iterative,condition,t,pattern,get,condition,break,case,ignore,condition,boolean,conditions,true,function,break,if,current,group,pattern,null,current,group,pattern,get,until,condition,null,ignore,condition,extend,with,until,condition,ignore,condition,iterative,condition,t,current,group,pattern,get,until,condition,false,return,ignore,condition
NFACompiler -> NFAFactoryCompiler -> @SuppressWarnings("unchecked") 		private IterativeCondition<T> getTrueFunction();1498034481;@return An true function extended with stop(until) condition if necessary.;@SuppressWarnings("unchecked")_		private IterativeCondition<T> getTrueFunction() {_			IterativeCondition<T> trueCondition = BooleanConditions.trueFunction()__			if (currentGroupPattern != null && currentGroupPattern.getUntilCondition() != null) {_				trueCondition = extendWithUntilCondition(_					trueCondition,_					(IterativeCondition<T>) currentGroupPattern.getUntilCondition())__			}_			return trueCondition__		};return,an,true,function,extended,with,stop,until,condition,if,necessary;suppress,warnings,unchecked,private,iterative,condition,t,get,true,function,iterative,condition,t,true,condition,boolean,conditions,true,function,if,current,group,pattern,null,current,group,pattern,get,until,condition,null,true,condition,extend,with,until,condition,true,condition,iterative,condition,t,current,group,pattern,get,until,condition,return,true,condition
NFACompiler -> NFAFactoryCompiler -> @SuppressWarnings("unchecked") 		private IterativeCondition<T> getTrueFunction();1499760222;@return An true function extended with stop(until) condition if necessary.;@SuppressWarnings("unchecked")_		private IterativeCondition<T> getTrueFunction() {_			IterativeCondition<T> trueCondition = BooleanConditions.trueFunction()__			if (currentGroupPattern != null && currentGroupPattern.getUntilCondition() != null) {_				trueCondition = extendWithUntilCondition(_					trueCondition,_					(IterativeCondition<T>) currentGroupPattern.getUntilCondition(),_					true)__			}_			return trueCondition__		};return,an,true,function,extended,with,stop,until,condition,if,necessary;suppress,warnings,unchecked,private,iterative,condition,t,get,true,function,iterative,condition,t,true,condition,boolean,conditions,true,function,if,current,group,pattern,null,current,group,pattern,get,until,condition,null,true,condition,extend,with,until,condition,true,condition,iterative,condition,t,current,group,pattern,get,until,condition,true,return,true,condition
NFACompiler -> NFAFactoryCompiler -> @SuppressWarnings("unchecked") 		private IterativeCondition<T> getTrueFunction();1499937690;@return An true function extended with stop(until) condition if necessary.;@SuppressWarnings("unchecked")_		private IterativeCondition<T> getTrueFunction() {_			IterativeCondition<T> trueCondition = BooleanConditions.trueFunction()__			if (currentGroupPattern != null && currentGroupPattern.getUntilCondition() != null) {_				trueCondition = extendWithUntilCondition(_					trueCondition,_					(IterativeCondition<T>) currentGroupPattern.getUntilCondition(),_					true)__			}_			return trueCondition__		};return,an,true,function,extended,with,stop,until,condition,if,necessary;suppress,warnings,unchecked,private,iterative,condition,t,get,true,function,iterative,condition,t,true,condition,boolean,conditions,true,function,if,current,group,pattern,null,current,group,pattern,get,until,condition,null,true,condition,extend,with,until,condition,true,condition,iterative,condition,t,current,group,pattern,get,until,condition,true,return,true,condition
NFACompiler -> NFAFactoryCompiler -> @SuppressWarnings("unchecked") 		private IterativeCondition<T> getTrueFunction();1500021711;@return An true function extended with stop(until) condition if necessary.;@SuppressWarnings("unchecked")_		private IterativeCondition<T> getTrueFunction() {_			IterativeCondition<T> trueCondition = BooleanConditions.trueFunction()__			if (currentGroupPattern != null && currentGroupPattern.getUntilCondition() != null) {_				trueCondition = extendWithUntilCondition(_					trueCondition,_					(IterativeCondition<T>) currentGroupPattern.getUntilCondition(),_					true)__			}_			return trueCondition__		};return,an,true,function,extended,with,stop,until,condition,if,necessary;suppress,warnings,unchecked,private,iterative,condition,t,get,true,function,iterative,condition,t,true,condition,boolean,conditions,true,function,if,current,group,pattern,null,current,group,pattern,get,until,condition,null,true,condition,extend,with,until,condition,true,condition,iterative,condition,t,current,group,pattern,get,until,condition,true,return,true,condition
NFACompiler -> NFAFactoryCompiler -> @SuppressWarnings("unchecked") 		private IterativeCondition<T> getTrueFunction();1501592283;@return An true function extended with stop(until) condition if necessary.;@SuppressWarnings("unchecked")_		private IterativeCondition<T> getTrueFunction() {_			IterativeCondition<T> trueCondition = BooleanConditions.trueFunction()__			if (currentGroupPattern != null && currentGroupPattern.getUntilCondition() != null) {_				trueCondition = extendWithUntilCondition(_					trueCondition,_					(IterativeCondition<T>) currentGroupPattern.getUntilCondition(),_					true)__			}_			return trueCondition__		};return,an,true,function,extended,with,stop,until,condition,if,necessary;suppress,warnings,unchecked,private,iterative,condition,t,get,true,function,iterative,condition,t,true,condition,boolean,conditions,true,function,if,current,group,pattern,null,current,group,pattern,get,until,condition,null,true,condition,extend,with,until,condition,true,condition,iterative,condition,t,current,group,pattern,get,until,condition,true,return,true,condition
NFACompiler -> NFAFactoryCompiler -> @SuppressWarnings("unchecked") 		private IterativeCondition<T> getTrueFunction();1502422141;@return An true function extended with stop(until) condition if necessary.;@SuppressWarnings("unchecked")_		private IterativeCondition<T> getTrueFunction() {_			IterativeCondition<T> trueCondition = BooleanConditions.trueFunction()__			if (currentGroupPattern != null && currentGroupPattern.getUntilCondition() != null) {_				trueCondition = extendWithUntilCondition(_					trueCondition,_					(IterativeCondition<T>) currentGroupPattern.getUntilCondition(),_					true)__			}_			return trueCondition__		};return,an,true,function,extended,with,stop,until,condition,if,necessary;suppress,warnings,unchecked,private,iterative,condition,t,get,true,function,iterative,condition,t,true,condition,boolean,conditions,true,function,if,current,group,pattern,null,current,group,pattern,get,until,condition,null,true,condition,extend,with,until,condition,true,condition,iterative,condition,t,current,group,pattern,get,until,condition,true,return,true,condition
NFACompiler -> NFAFactoryCompiler -> @SuppressWarnings("unchecked") 		private IterativeCondition<T> getTrueFunction();1503588494;@return An true function extended with stop(until) condition if necessary.;@SuppressWarnings("unchecked")_		private IterativeCondition<T> getTrueFunction() {_			IterativeCondition<T> trueCondition = BooleanConditions.trueFunction()__			if (currentGroupPattern != null && currentGroupPattern.getUntilCondition() != null) {_				trueCondition = extendWithUntilCondition(_					trueCondition,_					(IterativeCondition<T>) currentGroupPattern.getUntilCondition(),_					true)__			}_			return trueCondition__		};return,an,true,function,extended,with,stop,until,condition,if,necessary;suppress,warnings,unchecked,private,iterative,condition,t,get,true,function,iterative,condition,t,true,condition,boolean,conditions,true,function,if,current,group,pattern,null,current,group,pattern,get,until,condition,null,true,condition,extend,with,until,condition,true,condition,iterative,condition,t,current,group,pattern,get,until,condition,true,return,true,condition
NFACompiler -> NFAFactoryCompiler -> @SuppressWarnings("unchecked") 		private IterativeCondition<T> getTrueFunction();1518008111;@return An true function extended with stop(until) condition if necessary.;@SuppressWarnings("unchecked")_		private IterativeCondition<T> getTrueFunction() {_			IterativeCondition<T> trueCondition = BooleanConditions.trueFunction()__			if (currentGroupPattern != null && currentGroupPattern.getUntilCondition() != null) {_				trueCondition = extendWithUntilCondition(_					trueCondition,_					(IterativeCondition<T>) currentGroupPattern.getUntilCondition(),_					true)__			}_			return trueCondition__		};return,an,true,function,extended,with,stop,until,condition,if,necessary;suppress,warnings,unchecked,private,iterative,condition,t,get,true,function,iterative,condition,t,true,condition,boolean,conditions,true,function,if,current,group,pattern,null,current,group,pattern,get,until,condition,null,true,condition,extend,with,until,condition,true,condition,iterative,condition,t,current,group,pattern,get,until,condition,true,return,true,condition
NFACompiler -> NFAFactoryCompiler -> @SuppressWarnings("unchecked") 		private IterativeCondition<T> getTrueFunction();1527863170;@return An true function extended with stop(until) condition if necessary.;@SuppressWarnings("unchecked")_		private IterativeCondition<T> getTrueFunction() {_			IterativeCondition<T> trueCondition = BooleanConditions.trueFunction()__			if (currentGroupPattern != null && currentGroupPattern.getUntilCondition() != null) {_				trueCondition = extendWithUntilCondition(_					trueCondition,_					(IterativeCondition<T>) currentGroupPattern.getUntilCondition(),_					true)__			}_			return trueCondition__		};return,an,true,function,extended,with,stop,until,condition,if,necessary;suppress,warnings,unchecked,private,iterative,condition,t,get,true,function,iterative,condition,t,true,condition,boolean,conditions,true,function,if,current,group,pattern,null,current,group,pattern,get,until,condition,null,true,condition,extend,with,until,condition,true,condition,iterative,condition,t,current,group,pattern,get,until,condition,true,return,true,condition
NFACompiler -> NFAFactoryCompiler -> @SuppressWarnings("unchecked") 		private IterativeCondition<T> getTrueFunction();1528989005;@return An true function extended with stop(until) condition if necessary.;@SuppressWarnings("unchecked")_		private IterativeCondition<T> getTrueFunction() {_			IterativeCondition<T> trueCondition = BooleanConditions.trueFunction()__			if (currentGroupPattern != null && currentGroupPattern.getUntilCondition() != null) {_				trueCondition = extendWithUntilCondition(_					trueCondition,_					(IterativeCondition<T>) currentGroupPattern.getUntilCondition(),_					true)__			}_			return trueCondition__		};return,an,true,function,extended,with,stop,until,condition,if,necessary;suppress,warnings,unchecked,private,iterative,condition,t,get,true,function,iterative,condition,t,true,condition,boolean,conditions,true,function,if,current,group,pattern,null,current,group,pattern,get,until,condition,null,true,condition,extend,with,until,condition,true,condition,iterative,condition,t,current,group,pattern,get,until,condition,true,return,true,condition
NFACompiler -> NFAFactoryCompiler -> @SuppressWarnings("unchecked") 		private IterativeCondition<T> getTrueFunction();1538745898;@return An true function extended with stop(until) condition if necessary.;@SuppressWarnings("unchecked")_		private IterativeCondition<T> getTrueFunction() {_			IterativeCondition<T> trueCondition = BooleanConditions.trueFunction()__			if (currentGroupPattern != null && currentGroupPattern.getUntilCondition() != null) {_				trueCondition = extendWithUntilCondition(_					trueCondition,_					(IterativeCondition<T>) currentGroupPattern.getUntilCondition(),_					true)__			}_			return trueCondition__		};return,an,true,function,extended,with,stop,until,condition,if,necessary;suppress,warnings,unchecked,private,iterative,condition,t,get,true,function,iterative,condition,t,true,condition,boolean,conditions,true,function,if,current,group,pattern,null,current,group,pattern,get,until,condition,null,true,condition,extend,with,until,condition,true,condition,iterative,condition,t,current,group,pattern,get,until,condition,true,return,true,condition
NFACompiler -> NFAFactoryCompiler -> @SuppressWarnings("unchecked") 		private IterativeCondition<T> getTrueFunction();1542293931;@return An true function extended with stop(until) condition if necessary.;@SuppressWarnings("unchecked")_		private IterativeCondition<T> getTrueFunction() {_			IterativeCondition<T> trueCondition = BooleanConditions.trueFunction()__			if (currentGroupPattern != null && currentGroupPattern.getUntilCondition() != null) {_				trueCondition = extendWithUntilCondition(_					trueCondition,_					(IterativeCondition<T>) currentGroupPattern.getUntilCondition(),_					true)__			}_			return trueCondition__		};return,an,true,function,extended,with,stop,until,condition,if,necessary;suppress,warnings,unchecked,private,iterative,condition,t,get,true,function,iterative,condition,t,true,condition,boolean,conditions,true,function,if,current,group,pattern,null,current,group,pattern,get,until,condition,null,true,condition,extend,with,until,condition,true,condition,iterative,condition,t,current,group,pattern,get,until,condition,true,return,true,condition
NFACompiler -> NFAFactoryCompiler -> private State<T> createNormalState();1490619911;Creates a state with {@link State.StateType#Normal} and adds it to the collection of created states._Should be used instead of instantiating with new operator.__@return the created state;private State<T> createNormalState() {_			final State<T> state = new State<>(currentPattern.getName(), State.StateType.Normal)__			states.add(state)__			return state__		};creates,a,state,with,link,state,state,type,normal,and,adds,it,to,the,collection,of,created,states,should,be,used,instead,of,instantiating,with,new,operator,return,the,created,state;private,state,t,create,normal,state,final,state,t,state,new,state,current,pattern,get,name,state,state,type,normal,states,add,state,return,state
NFACompiler -> NFAFactoryCompiler -> private State<T> createNormalState();1491320734;Creates a state with {@link State.StateType#Normal} and adds it to the collection of created states._Should be used instead of instantiating with new operator.__@return the created state;private State<T> createNormalState() {_			final State<T> state = new State<>(currentPattern.getName(), State.StateType.Normal)__			states.add(state)__			return state__		};creates,a,state,with,link,state,state,type,normal,and,adds,it,to,the,collection,of,created,states,should,be,used,instead,of,instantiating,with,new,operator,return,the,created,state;private,state,t,create,normal,state,final,state,t,state,new,state,current,pattern,get,name,state,state,type,normal,states,add,state,return,state
NFACompiler -> NFAFactoryCompiler -> private State<T> createNormalState();1491323030;Creates a state with {@link State.StateType#Normal} and adds it to the collection of created states._Should be used instead of instantiating with new operator.__@return the created state;private State<T> createNormalState() {_			final State<T> state = new State<>(currentPattern.getName(), State.StateType.Normal)__			states.add(state)__			return state__		};creates,a,state,with,link,state,state,type,normal,and,adds,it,to,the,collection,of,created,states,should,be,used,instead,of,instantiating,with,new,operator,return,the,created,state;private,state,t,create,normal,state,final,state,t,state,new,state,current,pattern,get,name,state,state,type,normal,states,add,state,return,state
NFACompiler -> NFAFactoryCompiler -> private State<T> createNormalState();1491633862;Creates a state with {@link State.StateType#Normal} and adds it to the collection of created states._Should be used instead of instantiating with new operator.__@return the created state;private State<T> createNormalState() {_			final State<T> state = new State<>(currentPattern.getName(), State.StateType.Normal)__			states.add(state)__			return state__		};creates,a,state,with,link,state,state,type,normal,and,adds,it,to,the,collection,of,created,states,should,be,used,instead,of,instantiating,with,new,operator,return,the,created,state;private,state,t,create,normal,state,final,state,t,state,new,state,current,pattern,get,name,state,state,type,normal,states,add,state,return,state
NFACompiler -> NFAFactoryCompiler -> private State<T> createNormalState();1492797583;Creates a state with {@link State.StateType#Normal} and adds it to the collection of created states._Should be used instead of instantiating with new operator.__@return the created state;private State<T> createNormalState() {_			final State<T> state = new State<>(currentPattern.getName(), State.StateType.Normal)__			states.add(state)__			return state__		};creates,a,state,with,link,state,state,type,normal,and,adds,it,to,the,collection,of,created,states,should,be,used,instead,of,instantiating,with,new,operator,return,the,created,state;private,state,t,create,normal,state,final,state,t,state,new,state,current,pattern,get,name,state,state,type,normal,states,add,state,return,state
NFACompiler -> NFAFactoryCompiler -> private State<T> createNormalState();1493200673;Creates a state with {@link State.StateType#Normal} and adds it to the collection of created states._Should be used instead of instantiating with new operator.__@return the created state;private State<T> createNormalState() {_			final State<T> state = new State<>(currentPattern.getName(), State.StateType.Normal)__			states.add(state)__			return state__		};creates,a,state,with,link,state,state,type,normal,and,adds,it,to,the,collection,of,created,states,should,be,used,instead,of,instantiating,with,new,operator,return,the,created,state;private,state,t,create,normal,state,final,state,t,state,new,state,current,pattern,get,name,state,state,type,normal,states,add,state,return,state
NFACompiler -> NFAFactoryCompiler -> private State<T> createNormalState();1493385877;Creates a state with {@link State.StateType#Normal} and adds it to the collection of created states._Should be used instead of instantiating with new operator.__@return the created state;private State<T> createNormalState() {_			final State<T> state = new State<>(currentPattern.getName(), State.StateType.Normal)__			states.add(state)__			return state__		};creates,a,state,with,link,state,state,type,normal,and,adds,it,to,the,collection,of,created,states,should,be,used,instead,of,instantiating,with,new,operator,return,the,created,state;private,state,t,create,normal,state,final,state,t,state,new,state,current,pattern,get,name,state,state,type,normal,states,add,state,return,state
NFACompiler -> NFAFactoryCompiler -> private String getUniqueInternalStateName(String baseName);1494947249;Used to give a unique name to states created_during the translation process.__@param baseName The base of the name.;private String getUniqueInternalStateName(String baseName) {_			int counter = 0__			String candidate = baseName__			while (usedNames.contains(candidate)) {_				candidate = baseName + STATE_NAME_DELIM + counter++__			}_			return candidate__		};used,to,give,a,unique,name,to,states,created,during,the,translation,process,param,base,name,the,base,of,the,name;private,string,get,unique,internal,state,name,string,base,name,int,counter,0,string,candidate,base,name,while,used,names,contains,candidate,candidate,base,name,counter,return,candidate
NFACompiler -> NFAFactoryCompiler -> private String getUniqueInternalStateName(String baseName);1495657626;Used to give a unique name to states created_during the translation process.__@param baseName The base of the name.;private String getUniqueInternalStateName(String baseName) {_			int counter = 0__			String candidate = baseName__			while (usedNames.contains(candidate)) {_				candidate = baseName + STATE_NAME_DELIM + counter++__			}_			return candidate__		};used,to,give,a,unique,name,to,states,created,during,the,translation,process,param,base,name,the,base,of,the,name;private,string,get,unique,internal,state,name,string,base,name,int,counter,0,string,candidate,base,name,while,used,names,contains,candidate,candidate,base,name,counter,return,candidate
NFACompiler -> @SuppressWarnings("unchecked") 	public static <T> NFAFactory<T> compileFactory( 		final Pattern<T, ?> pattern, 		final TypeSerializer<T> inputTypeSerializer, 		boolean timeoutHandling);1489866780;Compiles the given pattern into a {@link NFAFactory}. The NFA factory can be used to create_multiple NFAs.__@param pattern Definition of sequence pattern_@param inputTypeSerializer Serializer for the input type_@param timeoutHandling True if the NFA shall return timed out event patterns_@param <T> Type of the input events_@return Factory for NFAs corresponding to the given pattern;@SuppressWarnings("unchecked")_	public static <T> NFAFactory<T> compileFactory(_		final Pattern<T, ?> pattern,_		final TypeSerializer<T> inputTypeSerializer,_		boolean timeoutHandling) {_		if (pattern == null) {_			_			return new NFAFactoryImpl<>(inputTypeSerializer, 0, Collections.<State<T>>emptyList(), timeoutHandling)__		} else {_			final NFAFactoryCompiler<T> nfaFactoryCompiler = new NFAFactoryCompiler<>(pattern)__			nfaFactoryCompiler.compileFactory()__			return new NFAFactoryImpl<>(inputTypeSerializer, nfaFactoryCompiler.getWindowTime(), nfaFactoryCompiler.getStates(), timeoutHandling)__		}_	};compiles,the,given,pattern,into,a,link,nfafactory,the,nfa,factory,can,be,used,to,create,multiple,nfas,param,pattern,definition,of,sequence,pattern,param,input,type,serializer,serializer,for,the,input,type,param,timeout,handling,true,if,the,nfa,shall,return,timed,out,event,patterns,param,t,type,of,the,input,events,return,factory,for,nfas,corresponding,to,the,given,pattern;suppress,warnings,unchecked,public,static,t,nfafactory,t,compile,factory,final,pattern,t,pattern,final,type,serializer,t,input,type,serializer,boolean,timeout,handling,if,pattern,null,return,new,nfafactory,impl,input,type,serializer,0,collections,state,t,empty,list,timeout,handling,else,final,nfafactory,compiler,t,nfa,factory,compiler,new,nfafactory,compiler,pattern,nfa,factory,compiler,compile,factory,return,new,nfafactory,impl,input,type,serializer,nfa,factory,compiler,get,window,time,nfa,factory,compiler,get,states,timeout,handling
NFACompiler -> @SuppressWarnings("unchecked") 	public static <T> NFAFactory<T> compileFactory( 		final Pattern<T, ?> pattern, 		final TypeSerializer<T> inputTypeSerializer, 		boolean timeoutHandling);1490089987;Compiles the given pattern into a {@link NFAFactory}. The NFA factory can be used to create_multiple NFAs.__@param pattern Definition of sequence pattern_@param inputTypeSerializer Serializer for the input type_@param timeoutHandling True if the NFA shall return timed out event patterns_@param <T> Type of the input events_@return Factory for NFAs corresponding to the given pattern;@SuppressWarnings("unchecked")_	public static <T> NFAFactory<T> compileFactory(_		final Pattern<T, ?> pattern,_		final TypeSerializer<T> inputTypeSerializer,_		boolean timeoutHandling) {_		if (pattern == null) {_			_			return new NFAFactoryImpl<>(inputTypeSerializer, 0, Collections.<State<T>>emptyList(), timeoutHandling)__		} else {_			final NFAFactoryCompiler<T> nfaFactoryCompiler = new NFAFactoryCompiler<>(pattern)__			nfaFactoryCompiler.compileFactory()__			return new NFAFactoryImpl<>(inputTypeSerializer, nfaFactoryCompiler.getWindowTime(), nfaFactoryCompiler.getStates(), timeoutHandling)__		}_	};compiles,the,given,pattern,into,a,link,nfafactory,the,nfa,factory,can,be,used,to,create,multiple,nfas,param,pattern,definition,of,sequence,pattern,param,input,type,serializer,serializer,for,the,input,type,param,timeout,handling,true,if,the,nfa,shall,return,timed,out,event,patterns,param,t,type,of,the,input,events,return,factory,for,nfas,corresponding,to,the,given,pattern;suppress,warnings,unchecked,public,static,t,nfafactory,t,compile,factory,final,pattern,t,pattern,final,type,serializer,t,input,type,serializer,boolean,timeout,handling,if,pattern,null,return,new,nfafactory,impl,input,type,serializer,0,collections,state,t,empty,list,timeout,handling,else,final,nfafactory,compiler,t,nfa,factory,compiler,new,nfafactory,compiler,pattern,nfa,factory,compiler,compile,factory,return,new,nfafactory,impl,input,type,serializer,nfa,factory,compiler,get,window,time,nfa,factory,compiler,get,states,timeout,handling
NFACompiler -> @SuppressWarnings("unchecked") 	public static <T> NFAFactory<T> compileFactory( 		final Pattern<T, ?> pattern, 		final TypeSerializer<T> inputTypeSerializer, 		boolean timeoutHandling);1490194327;Compiles the given pattern into a {@link NFAFactory}. The NFA factory can be used to create_multiple NFAs.__@param pattern Definition of sequence pattern_@param inputTypeSerializer Serializer for the input type_@param timeoutHandling True if the NFA shall return timed out event patterns_@param <T> Type of the input events_@return Factory for NFAs corresponding to the given pattern;@SuppressWarnings("unchecked")_	public static <T> NFAFactory<T> compileFactory(_		final Pattern<T, ?> pattern,_		final TypeSerializer<T> inputTypeSerializer,_		boolean timeoutHandling) {_		if (pattern == null) {_			_			return new NFAFactoryImpl<>(inputTypeSerializer, 0, Collections.<State<T>>emptyList(), timeoutHandling)__		} else {_			final NFAFactoryCompiler<T> nfaFactoryCompiler = new NFAFactoryCompiler<>(pattern)__			nfaFactoryCompiler.compileFactory()__			return new NFAFactoryImpl<>(inputTypeSerializer, nfaFactoryCompiler.getWindowTime(), nfaFactoryCompiler.getStates(), timeoutHandling)__		}_	};compiles,the,given,pattern,into,a,link,nfafactory,the,nfa,factory,can,be,used,to,create,multiple,nfas,param,pattern,definition,of,sequence,pattern,param,input,type,serializer,serializer,for,the,input,type,param,timeout,handling,true,if,the,nfa,shall,return,timed,out,event,patterns,param,t,type,of,the,input,events,return,factory,for,nfas,corresponding,to,the,given,pattern;suppress,warnings,unchecked,public,static,t,nfafactory,t,compile,factory,final,pattern,t,pattern,final,type,serializer,t,input,type,serializer,boolean,timeout,handling,if,pattern,null,return,new,nfafactory,impl,input,type,serializer,0,collections,state,t,empty,list,timeout,handling,else,final,nfafactory,compiler,t,nfa,factory,compiler,new,nfafactory,compiler,pattern,nfa,factory,compiler,compile,factory,return,new,nfafactory,impl,input,type,serializer,nfa,factory,compiler,get,window,time,nfa,factory,compiler,get,states,timeout,handling
NFACompiler -> @SuppressWarnings("unchecked") 	public static <T> NFAFactory<T> compileFactory( 		final Pattern<T, ?> pattern, 		final TypeSerializer<T> inputTypeSerializer, 		boolean timeoutHandling);1490619911;Compiles the given pattern into a {@link NFAFactory}. The NFA factory can be used to create_multiple NFAs.__@param pattern Definition of sequence pattern_@param inputTypeSerializer Serializer for the input type_@param timeoutHandling True if the NFA shall return timed out event patterns_@param <T> Type of the input events_@return Factory for NFAs corresponding to the given pattern;@SuppressWarnings("unchecked")_	public static <T> NFAFactory<T> compileFactory(_		final Pattern<T, ?> pattern,_		final TypeSerializer<T> inputTypeSerializer,_		boolean timeoutHandling) {_		if (pattern == null) {_			_			return new NFAFactoryImpl<>(inputTypeSerializer, 0, Collections.<State<T>>emptyList(), timeoutHandling)__		} else {_			final NFAFactoryCompiler<T> nfaFactoryCompiler = new NFAFactoryCompiler<>(pattern)__			nfaFactoryCompiler.compileFactory()__			return new NFAFactoryImpl<>(inputTypeSerializer, nfaFactoryCompiler.getWindowTime(), nfaFactoryCompiler.getStates(), timeoutHandling)__		}_	};compiles,the,given,pattern,into,a,link,nfafactory,the,nfa,factory,can,be,used,to,create,multiple,nfas,param,pattern,definition,of,sequence,pattern,param,input,type,serializer,serializer,for,the,input,type,param,timeout,handling,true,if,the,nfa,shall,return,timed,out,event,patterns,param,t,type,of,the,input,events,return,factory,for,nfas,corresponding,to,the,given,pattern;suppress,warnings,unchecked,public,static,t,nfafactory,t,compile,factory,final,pattern,t,pattern,final,type,serializer,t,input,type,serializer,boolean,timeout,handling,if,pattern,null,return,new,nfafactory,impl,input,type,serializer,0,collections,state,t,empty,list,timeout,handling,else,final,nfafactory,compiler,t,nfa,factory,compiler,new,nfafactory,compiler,pattern,nfa,factory,compiler,compile,factory,return,new,nfafactory,impl,input,type,serializer,nfa,factory,compiler,get,window,time,nfa,factory,compiler,get,states,timeout,handling
NFACompiler -> @SuppressWarnings("unchecked") 	public static <T> NFAFactory<T> compileFactory( 		final Pattern<T, ?> pattern, 		final TypeSerializer<T> inputTypeSerializer, 		boolean timeoutHandling);1491320734;Compiles the given pattern into a {@link NFAFactory}. The NFA factory can be used to create_multiple NFAs.__@param pattern Definition of sequence pattern_@param inputTypeSerializer Serializer for the input type_@param timeoutHandling True if the NFA shall return timed out event patterns_@param <T> Type of the input events_@return Factory for NFAs corresponding to the given pattern;@SuppressWarnings("unchecked")_	public static <T> NFAFactory<T> compileFactory(_		final Pattern<T, ?> pattern,_		final TypeSerializer<T> inputTypeSerializer,_		boolean timeoutHandling) {_		if (pattern == null) {_			_			return new NFAFactoryImpl<>(inputTypeSerializer, 0, Collections.<State<T>>emptyList(), timeoutHandling)__		} else {_			final NFAFactoryCompiler<T> nfaFactoryCompiler = new NFAFactoryCompiler<>(pattern)__			nfaFactoryCompiler.compileFactory()__			return new NFAFactoryImpl<>(inputTypeSerializer, nfaFactoryCompiler.getWindowTime(), nfaFactoryCompiler.getStates(), timeoutHandling)__		}_	};compiles,the,given,pattern,into,a,link,nfafactory,the,nfa,factory,can,be,used,to,create,multiple,nfas,param,pattern,definition,of,sequence,pattern,param,input,type,serializer,serializer,for,the,input,type,param,timeout,handling,true,if,the,nfa,shall,return,timed,out,event,patterns,param,t,type,of,the,input,events,return,factory,for,nfas,corresponding,to,the,given,pattern;suppress,warnings,unchecked,public,static,t,nfafactory,t,compile,factory,final,pattern,t,pattern,final,type,serializer,t,input,type,serializer,boolean,timeout,handling,if,pattern,null,return,new,nfafactory,impl,input,type,serializer,0,collections,state,t,empty,list,timeout,handling,else,final,nfafactory,compiler,t,nfa,factory,compiler,new,nfafactory,compiler,pattern,nfa,factory,compiler,compile,factory,return,new,nfafactory,impl,input,type,serializer,nfa,factory,compiler,get,window,time,nfa,factory,compiler,get,states,timeout,handling
NFACompiler -> @SuppressWarnings("unchecked") 	public static <T> NFAFactory<T> compileFactory( 		final Pattern<T, ?> pattern, 		final TypeSerializer<T> inputTypeSerializer, 		boolean timeoutHandling);1491323030;Compiles the given pattern into a {@link NFAFactory}. The NFA factory can be used to create_multiple NFAs.__@param pattern Definition of sequence pattern_@param inputTypeSerializer Serializer for the input type_@param timeoutHandling True if the NFA shall return timed out event patterns_@param <T> Type of the input events_@return Factory for NFAs corresponding to the given pattern;@SuppressWarnings("unchecked")_	public static <T> NFAFactory<T> compileFactory(_		final Pattern<T, ?> pattern,_		final TypeSerializer<T> inputTypeSerializer,_		boolean timeoutHandling) {_		if (pattern == null) {_			_			return new NFAFactoryImpl<>(inputTypeSerializer, 0, Collections.<State<T>>emptyList(), timeoutHandling)__		} else {_			final NFAFactoryCompiler<T> nfaFactoryCompiler = new NFAFactoryCompiler<>(pattern)__			nfaFactoryCompiler.compileFactory()__			return new NFAFactoryImpl<>(inputTypeSerializer, nfaFactoryCompiler.getWindowTime(), nfaFactoryCompiler.getStates(), timeoutHandling)__		}_	};compiles,the,given,pattern,into,a,link,nfafactory,the,nfa,factory,can,be,used,to,create,multiple,nfas,param,pattern,definition,of,sequence,pattern,param,input,type,serializer,serializer,for,the,input,type,param,timeout,handling,true,if,the,nfa,shall,return,timed,out,event,patterns,param,t,type,of,the,input,events,return,factory,for,nfas,corresponding,to,the,given,pattern;suppress,warnings,unchecked,public,static,t,nfafactory,t,compile,factory,final,pattern,t,pattern,final,type,serializer,t,input,type,serializer,boolean,timeout,handling,if,pattern,null,return,new,nfafactory,impl,input,type,serializer,0,collections,state,t,empty,list,timeout,handling,else,final,nfafactory,compiler,t,nfa,factory,compiler,new,nfafactory,compiler,pattern,nfa,factory,compiler,compile,factory,return,new,nfafactory,impl,input,type,serializer,nfa,factory,compiler,get,window,time,nfa,factory,compiler,get,states,timeout,handling
NFACompiler -> @SuppressWarnings("unchecked") 	public static <T> NFAFactory<T> compileFactory( 		final Pattern<T, ?> pattern, 		final TypeSerializer<T> inputTypeSerializer, 		boolean timeoutHandling);1491633862;Compiles the given pattern into a {@link NFAFactory}. The NFA factory can be used to create_multiple NFAs.__@param pattern Definition of sequence pattern_@param inputTypeSerializer Serializer for the input type_@param timeoutHandling True if the NFA shall return timed out event patterns_@param <T> Type of the input events_@return Factory for NFAs corresponding to the given pattern;@SuppressWarnings("unchecked")_	public static <T> NFAFactory<T> compileFactory(_		final Pattern<T, ?> pattern,_		final TypeSerializer<T> inputTypeSerializer,_		boolean timeoutHandling) {_		if (pattern == null) {_			_			return new NFAFactoryImpl<>(inputTypeSerializer, 0, Collections.<State<T>>emptyList(), timeoutHandling)__		} else {_			final NFAFactoryCompiler<T> nfaFactoryCompiler = new NFAFactoryCompiler<>(pattern)__			nfaFactoryCompiler.compileFactory()__			return new NFAFactoryImpl<>(inputTypeSerializer, nfaFactoryCompiler.getWindowTime(), nfaFactoryCompiler.getStates(), timeoutHandling)__		}_	};compiles,the,given,pattern,into,a,link,nfafactory,the,nfa,factory,can,be,used,to,create,multiple,nfas,param,pattern,definition,of,sequence,pattern,param,input,type,serializer,serializer,for,the,input,type,param,timeout,handling,true,if,the,nfa,shall,return,timed,out,event,patterns,param,t,type,of,the,input,events,return,factory,for,nfas,corresponding,to,the,given,pattern;suppress,warnings,unchecked,public,static,t,nfafactory,t,compile,factory,final,pattern,t,pattern,final,type,serializer,t,input,type,serializer,boolean,timeout,handling,if,pattern,null,return,new,nfafactory,impl,input,type,serializer,0,collections,state,t,empty,list,timeout,handling,else,final,nfafactory,compiler,t,nfa,factory,compiler,new,nfafactory,compiler,pattern,nfa,factory,compiler,compile,factory,return,new,nfafactory,impl,input,type,serializer,nfa,factory,compiler,get,window,time,nfa,factory,compiler,get,states,timeout,handling
NFACompiler -> @SuppressWarnings("unchecked") 	public static <T> NFAFactory<T> compileFactory( 		final Pattern<T, ?> pattern, 		final TypeSerializer<T> inputTypeSerializer, 		boolean timeoutHandling);1492797583;Compiles the given pattern into a {@link NFAFactory}. The NFA factory can be used to create_multiple NFAs.__@param pattern Definition of sequence pattern_@param inputTypeSerializer Serializer for the input type_@param timeoutHandling True if the NFA shall return timed out event patterns_@param <T> Type of the input events_@return Factory for NFAs corresponding to the given pattern;@SuppressWarnings("unchecked")_	public static <T> NFAFactory<T> compileFactory(_		final Pattern<T, ?> pattern,_		final TypeSerializer<T> inputTypeSerializer,_		boolean timeoutHandling) {_		if (pattern == null) {_			_			return new NFAFactoryImpl<>(inputTypeSerializer, 0, Collections.<State<T>>emptyList(), timeoutHandling)__		} else {_			final NFAFactoryCompiler<T> nfaFactoryCompiler = new NFAFactoryCompiler<>(pattern)__			nfaFactoryCompiler.compileFactory()__			return new NFAFactoryImpl<>(inputTypeSerializer, nfaFactoryCompiler.getWindowTime(), nfaFactoryCompiler.getStates(), timeoutHandling)__		}_	};compiles,the,given,pattern,into,a,link,nfafactory,the,nfa,factory,can,be,used,to,create,multiple,nfas,param,pattern,definition,of,sequence,pattern,param,input,type,serializer,serializer,for,the,input,type,param,timeout,handling,true,if,the,nfa,shall,return,timed,out,event,patterns,param,t,type,of,the,input,events,return,factory,for,nfas,corresponding,to,the,given,pattern;suppress,warnings,unchecked,public,static,t,nfafactory,t,compile,factory,final,pattern,t,pattern,final,type,serializer,t,input,type,serializer,boolean,timeout,handling,if,pattern,null,return,new,nfafactory,impl,input,type,serializer,0,collections,state,t,empty,list,timeout,handling,else,final,nfafactory,compiler,t,nfa,factory,compiler,new,nfafactory,compiler,pattern,nfa,factory,compiler,compile,factory,return,new,nfafactory,impl,input,type,serializer,nfa,factory,compiler,get,window,time,nfa,factory,compiler,get,states,timeout,handling
NFACompiler -> @SuppressWarnings("unchecked") 	public static <T> NFAFactory<T> compileFactory( 		final Pattern<T, ?> pattern, 		final TypeSerializer<T> inputTypeSerializer, 		boolean timeoutHandling);1493200673;Compiles the given pattern into a {@link NFAFactory}. The NFA factory can be used to create_multiple NFAs.__@param pattern Definition of sequence pattern_@param inputTypeSerializer Serializer for the input type_@param timeoutHandling True if the NFA shall return timed out event patterns_@param <T> Type of the input events_@return Factory for NFAs corresponding to the given pattern;@SuppressWarnings("unchecked")_	public static <T> NFAFactory<T> compileFactory(_		final Pattern<T, ?> pattern,_		final TypeSerializer<T> inputTypeSerializer,_		boolean timeoutHandling) {_		if (pattern == null) {_			_			return new NFAFactoryImpl<>(inputTypeSerializer, 0, Collections.<State<T>>emptyList(), timeoutHandling)__		} else {_			final NFAFactoryCompiler<T> nfaFactoryCompiler = new NFAFactoryCompiler<>(pattern)__			nfaFactoryCompiler.compileFactory()__			return new NFAFactoryImpl<>(inputTypeSerializer, nfaFactoryCompiler.getWindowTime(), nfaFactoryCompiler.getStates(), timeoutHandling)__		}_	};compiles,the,given,pattern,into,a,link,nfafactory,the,nfa,factory,can,be,used,to,create,multiple,nfas,param,pattern,definition,of,sequence,pattern,param,input,type,serializer,serializer,for,the,input,type,param,timeout,handling,true,if,the,nfa,shall,return,timed,out,event,patterns,param,t,type,of,the,input,events,return,factory,for,nfas,corresponding,to,the,given,pattern;suppress,warnings,unchecked,public,static,t,nfafactory,t,compile,factory,final,pattern,t,pattern,final,type,serializer,t,input,type,serializer,boolean,timeout,handling,if,pattern,null,return,new,nfafactory,impl,input,type,serializer,0,collections,state,t,empty,list,timeout,handling,else,final,nfafactory,compiler,t,nfa,factory,compiler,new,nfafactory,compiler,pattern,nfa,factory,compiler,compile,factory,return,new,nfafactory,impl,input,type,serializer,nfa,factory,compiler,get,window,time,nfa,factory,compiler,get,states,timeout,handling
NFACompiler -> @SuppressWarnings("unchecked") 	public static <T> NFAFactory<T> compileFactory( 		final Pattern<T, ?> pattern, 		final TypeSerializer<T> inputTypeSerializer, 		boolean timeoutHandling);1493385877;Compiles the given pattern into a {@link NFAFactory}. The NFA factory can be used to create_multiple NFAs.__@param pattern Definition of sequence pattern_@param inputTypeSerializer Serializer for the input type_@param timeoutHandling True if the NFA shall return timed out event patterns_@param <T> Type of the input events_@return Factory for NFAs corresponding to the given pattern;@SuppressWarnings("unchecked")_	public static <T> NFAFactory<T> compileFactory(_		final Pattern<T, ?> pattern,_		final TypeSerializer<T> inputTypeSerializer,_		boolean timeoutHandling) {_		if (pattern == null) {_			_			return new NFAFactoryImpl<>(inputTypeSerializer, 0, Collections.<State<T>>emptyList(), timeoutHandling)__		} else {_			final NFAFactoryCompiler<T> nfaFactoryCompiler = new NFAFactoryCompiler<>(pattern)__			nfaFactoryCompiler.compileFactory()__			return new NFAFactoryImpl<>(inputTypeSerializer, nfaFactoryCompiler.getWindowTime(), nfaFactoryCompiler.getStates(), timeoutHandling)__		}_	};compiles,the,given,pattern,into,a,link,nfafactory,the,nfa,factory,can,be,used,to,create,multiple,nfas,param,pattern,definition,of,sequence,pattern,param,input,type,serializer,serializer,for,the,input,type,param,timeout,handling,true,if,the,nfa,shall,return,timed,out,event,patterns,param,t,type,of,the,input,events,return,factory,for,nfas,corresponding,to,the,given,pattern;suppress,warnings,unchecked,public,static,t,nfafactory,t,compile,factory,final,pattern,t,pattern,final,type,serializer,t,input,type,serializer,boolean,timeout,handling,if,pattern,null,return,new,nfafactory,impl,input,type,serializer,0,collections,state,t,empty,list,timeout,handling,else,final,nfafactory,compiler,t,nfa,factory,compiler,new,nfafactory,compiler,pattern,nfa,factory,compiler,compile,factory,return,new,nfafactory,impl,input,type,serializer,nfa,factory,compiler,get,window,time,nfa,factory,compiler,get,states,timeout,handling
NFACompiler -> @SuppressWarnings("unchecked") 	public static <T> NFAFactory<T> compileFactory( 		final Pattern<T, ?> pattern, 		final TypeSerializer<T> inputTypeSerializer, 		boolean timeoutHandling);1494947249;Compiles the given pattern into a {@link NFAFactory}. The NFA factory can be used to create_multiple NFAs.__@param pattern Definition of sequence pattern_@param inputTypeSerializer Serializer for the input type_@param timeoutHandling True if the NFA shall return timed out event patterns_@param <T> Type of the input events_@return Factory for NFAs corresponding to the given pattern;@SuppressWarnings("unchecked")_	public static <T> NFAFactory<T> compileFactory(_		final Pattern<T, ?> pattern,_		final TypeSerializer<T> inputTypeSerializer,_		boolean timeoutHandling) {_		if (pattern == null) {_			_			return new NFAFactoryImpl<>(inputTypeSerializer, 0, Collections.<State<T>>emptyList(), timeoutHandling)__		} else {_			final NFAFactoryCompiler<T> nfaFactoryCompiler = new NFAFactoryCompiler<>(pattern)__			nfaFactoryCompiler.compileFactory()__			return new NFAFactoryImpl<>(inputTypeSerializer, nfaFactoryCompiler.getWindowTime(), nfaFactoryCompiler.getStates(), timeoutHandling)__		}_	};compiles,the,given,pattern,into,a,link,nfafactory,the,nfa,factory,can,be,used,to,create,multiple,nfas,param,pattern,definition,of,sequence,pattern,param,input,type,serializer,serializer,for,the,input,type,param,timeout,handling,true,if,the,nfa,shall,return,timed,out,event,patterns,param,t,type,of,the,input,events,return,factory,for,nfas,corresponding,to,the,given,pattern;suppress,warnings,unchecked,public,static,t,nfafactory,t,compile,factory,final,pattern,t,pattern,final,type,serializer,t,input,type,serializer,boolean,timeout,handling,if,pattern,null,return,new,nfafactory,impl,input,type,serializer,0,collections,state,t,empty,list,timeout,handling,else,final,nfafactory,compiler,t,nfa,factory,compiler,new,nfafactory,compiler,pattern,nfa,factory,compiler,compile,factory,return,new,nfafactory,impl,input,type,serializer,nfa,factory,compiler,get,window,time,nfa,factory,compiler,get,states,timeout,handling
NFACompiler -> @SuppressWarnings("unchecked") 	public static <T> NFAFactory<T> compileFactory( 		final Pattern<T, ?> pattern, 		final TypeSerializer<T> inputTypeSerializer, 		boolean timeoutHandling);1495657626;Compiles the given pattern into a {@link NFAFactory}. The NFA factory can be used to create_multiple NFAs.__@param pattern Definition of sequence pattern_@param inputTypeSerializer Serializer for the input type_@param timeoutHandling True if the NFA shall return timed out event patterns_@param <T> Type of the input events_@return Factory for NFAs corresponding to the given pattern;@SuppressWarnings("unchecked")_	public static <T> NFAFactory<T> compileFactory(_		final Pattern<T, ?> pattern,_		final TypeSerializer<T> inputTypeSerializer,_		boolean timeoutHandling) {_		if (pattern == null) {_			_			return new NFAFactoryImpl<>(inputTypeSerializer, 0, Collections.<State<T>>emptyList(), timeoutHandling)__		} else {_			final NFAFactoryCompiler<T> nfaFactoryCompiler = new NFAFactoryCompiler<>(pattern)__			nfaFactoryCompiler.compileFactory()__			return new NFAFactoryImpl<>(inputTypeSerializer, nfaFactoryCompiler.getWindowTime(), nfaFactoryCompiler.getStates(), timeoutHandling)__		}_	};compiles,the,given,pattern,into,a,link,nfafactory,the,nfa,factory,can,be,used,to,create,multiple,nfas,param,pattern,definition,of,sequence,pattern,param,input,type,serializer,serializer,for,the,input,type,param,timeout,handling,true,if,the,nfa,shall,return,timed,out,event,patterns,param,t,type,of,the,input,events,return,factory,for,nfas,corresponding,to,the,given,pattern;suppress,warnings,unchecked,public,static,t,nfafactory,t,compile,factory,final,pattern,t,pattern,final,type,serializer,t,input,type,serializer,boolean,timeout,handling,if,pattern,null,return,new,nfafactory,impl,input,type,serializer,0,collections,state,t,empty,list,timeout,handling,else,final,nfafactory,compiler,t,nfa,factory,compiler,new,nfafactory,compiler,pattern,nfa,factory,compiler,compile,factory,return,new,nfafactory,impl,input,type,serializer,nfa,factory,compiler,get,window,time,nfa,factory,compiler,get,states,timeout,handling
NFACompiler -> @SuppressWarnings("unchecked") 	public static <T> NFAFactory<T> compileFactory( 		final Pattern<T, ?> pattern, 		final TypeSerializer<T> inputTypeSerializer, 		boolean timeoutHandling);1496245714;Compiles the given pattern into a {@link NFAFactory}. The NFA factory can be used to create_multiple NFAs.__@param pattern Definition of sequence pattern_@param inputTypeSerializer Serializer for the input type_@param timeoutHandling True if the NFA shall return timed out event patterns_@param <T> Type of the input events_@return Factory for NFAs corresponding to the given pattern;@SuppressWarnings("unchecked")_	public static <T> NFAFactory<T> compileFactory(_		final Pattern<T, ?> pattern,_		final TypeSerializer<T> inputTypeSerializer,_		boolean timeoutHandling) {_		if (pattern == null) {_			_			return new NFAFactoryImpl<>(inputTypeSerializer, 0, Collections.<State<T>>emptyList(), timeoutHandling)__		} else {_			final NFAFactoryCompiler<T> nfaFactoryCompiler = new NFAFactoryCompiler<>(pattern)__			nfaFactoryCompiler.compileFactory()__			return new NFAFactoryImpl<>(inputTypeSerializer, nfaFactoryCompiler.getWindowTime(), nfaFactoryCompiler.getStates(), timeoutHandling)__		}_	};compiles,the,given,pattern,into,a,link,nfafactory,the,nfa,factory,can,be,used,to,create,multiple,nfas,param,pattern,definition,of,sequence,pattern,param,input,type,serializer,serializer,for,the,input,type,param,timeout,handling,true,if,the,nfa,shall,return,timed,out,event,patterns,param,t,type,of,the,input,events,return,factory,for,nfas,corresponding,to,the,given,pattern;suppress,warnings,unchecked,public,static,t,nfafactory,t,compile,factory,final,pattern,t,pattern,final,type,serializer,t,input,type,serializer,boolean,timeout,handling,if,pattern,null,return,new,nfafactory,impl,input,type,serializer,0,collections,state,t,empty,list,timeout,handling,else,final,nfafactory,compiler,t,nfa,factory,compiler,new,nfafactory,compiler,pattern,nfa,factory,compiler,compile,factory,return,new,nfafactory,impl,input,type,serializer,nfa,factory,compiler,get,window,time,nfa,factory,compiler,get,states,timeout,handling
NFACompiler -> @SuppressWarnings("unchecked") 	public static <T> NFAFactory<T> compileFactory( 		final Pattern<T, ?> pattern, 		final TypeSerializer<T> inputTypeSerializer, 		boolean timeoutHandling);1497410381;Compiles the given pattern into a {@link NFAFactory}. The NFA factory can be used to create_multiple NFAs.__@param pattern Definition of sequence pattern_@param inputTypeSerializer Serializer for the input type_@param timeoutHandling True if the NFA shall return timed out event patterns_@param <T> Type of the input events_@return Factory for NFAs corresponding to the given pattern;@SuppressWarnings("unchecked")_	public static <T> NFAFactory<T> compileFactory(_		final Pattern<T, ?> pattern,_		final TypeSerializer<T> inputTypeSerializer,_		boolean timeoutHandling) {_		if (pattern == null) {_			_			return new NFAFactoryImpl<>(inputTypeSerializer, 0, Collections.<State<T>>emptyList(), timeoutHandling)__		} else {_			final NFAFactoryCompiler<T> nfaFactoryCompiler = new NFAFactoryCompiler<>(pattern)__			nfaFactoryCompiler.compileFactory()__			return new NFAFactoryImpl<>(inputTypeSerializer, nfaFactoryCompiler.getWindowTime(), nfaFactoryCompiler.getStates(), timeoutHandling)__		}_	};compiles,the,given,pattern,into,a,link,nfafactory,the,nfa,factory,can,be,used,to,create,multiple,nfas,param,pattern,definition,of,sequence,pattern,param,input,type,serializer,serializer,for,the,input,type,param,timeout,handling,true,if,the,nfa,shall,return,timed,out,event,patterns,param,t,type,of,the,input,events,return,factory,for,nfas,corresponding,to,the,given,pattern;suppress,warnings,unchecked,public,static,t,nfafactory,t,compile,factory,final,pattern,t,pattern,final,type,serializer,t,input,type,serializer,boolean,timeout,handling,if,pattern,null,return,new,nfafactory,impl,input,type,serializer,0,collections,state,t,empty,list,timeout,handling,else,final,nfafactory,compiler,t,nfa,factory,compiler,new,nfafactory,compiler,pattern,nfa,factory,compiler,compile,factory,return,new,nfafactory,impl,input,type,serializer,nfa,factory,compiler,get,window,time,nfa,factory,compiler,get,states,timeout,handling
NFACompiler -> @SuppressWarnings("unchecked") 	public static <T> NFAFactory<T> compileFactory( 		final Pattern<T, ?> pattern, 		final TypeSerializer<T> inputTypeSerializer, 		boolean timeoutHandling);1497883202;Compiles the given pattern into a {@link NFAFactory}. The NFA factory can be used to create_multiple NFAs.__@param pattern Definition of sequence pattern_@param inputTypeSerializer Serializer for the input type_@param timeoutHandling True if the NFA shall return timed out event patterns_@param <T> Type of the input events_@return Factory for NFAs corresponding to the given pattern;@SuppressWarnings("unchecked")_	public static <T> NFAFactory<T> compileFactory(_		final Pattern<T, ?> pattern,_		final TypeSerializer<T> inputTypeSerializer,_		boolean timeoutHandling) {_		if (pattern == null) {_			_			return new NFAFactoryImpl<>(inputTypeSerializer, 0, Collections.<State<T>>emptyList(), timeoutHandling)__		} else {_			final NFAFactoryCompiler<T> nfaFactoryCompiler = new NFAFactoryCompiler<>(pattern)__			nfaFactoryCompiler.compileFactory()__			return new NFAFactoryImpl<>(inputTypeSerializer, nfaFactoryCompiler.getWindowTime(), nfaFactoryCompiler.getStates(), timeoutHandling)__		}_	};compiles,the,given,pattern,into,a,link,nfafactory,the,nfa,factory,can,be,used,to,create,multiple,nfas,param,pattern,definition,of,sequence,pattern,param,input,type,serializer,serializer,for,the,input,type,param,timeout,handling,true,if,the,nfa,shall,return,timed,out,event,patterns,param,t,type,of,the,input,events,return,factory,for,nfas,corresponding,to,the,given,pattern;suppress,warnings,unchecked,public,static,t,nfafactory,t,compile,factory,final,pattern,t,pattern,final,type,serializer,t,input,type,serializer,boolean,timeout,handling,if,pattern,null,return,new,nfafactory,impl,input,type,serializer,0,collections,state,t,empty,list,timeout,handling,else,final,nfafactory,compiler,t,nfa,factory,compiler,new,nfafactory,compiler,pattern,nfa,factory,compiler,compile,factory,return,new,nfafactory,impl,input,type,serializer,nfa,factory,compiler,get,window,time,nfa,factory,compiler,get,states,timeout,handling
NFACompiler -> @SuppressWarnings("unchecked") 	public static <T> NFAFactory<T> compileFactory( 		final Pattern<T, ?> pattern, 		final TypeSerializer<T> inputTypeSerializer, 		boolean timeoutHandling);1498034481;Compiles the given pattern into a {@link NFAFactory}. The NFA factory can be used to create_multiple NFAs.__@param pattern Definition of sequence pattern_@param inputTypeSerializer Serializer for the input type_@param timeoutHandling True if the NFA shall return timed out event patterns_@param <T> Type of the input events_@return Factory for NFAs corresponding to the given pattern;@SuppressWarnings("unchecked")_	public static <T> NFAFactory<T> compileFactory(_		final Pattern<T, ?> pattern,_		final TypeSerializer<T> inputTypeSerializer,_		boolean timeoutHandling) {_		if (pattern == null) {_			_			return new NFAFactoryImpl<>(inputTypeSerializer, 0, Collections.<State<T>>emptyList(), timeoutHandling)__		} else {_			final NFAFactoryCompiler<T> nfaFactoryCompiler = new NFAFactoryCompiler<>(pattern)__			nfaFactoryCompiler.compileFactory()__			return new NFAFactoryImpl<>(inputTypeSerializer, nfaFactoryCompiler.getWindowTime(), nfaFactoryCompiler.getStates(), timeoutHandling)__		}_	};compiles,the,given,pattern,into,a,link,nfafactory,the,nfa,factory,can,be,used,to,create,multiple,nfas,param,pattern,definition,of,sequence,pattern,param,input,type,serializer,serializer,for,the,input,type,param,timeout,handling,true,if,the,nfa,shall,return,timed,out,event,patterns,param,t,type,of,the,input,events,return,factory,for,nfas,corresponding,to,the,given,pattern;suppress,warnings,unchecked,public,static,t,nfafactory,t,compile,factory,final,pattern,t,pattern,final,type,serializer,t,input,type,serializer,boolean,timeout,handling,if,pattern,null,return,new,nfafactory,impl,input,type,serializer,0,collections,state,t,empty,list,timeout,handling,else,final,nfafactory,compiler,t,nfa,factory,compiler,new,nfafactory,compiler,pattern,nfa,factory,compiler,compile,factory,return,new,nfafactory,impl,input,type,serializer,nfa,factory,compiler,get,window,time,nfa,factory,compiler,get,states,timeout,handling
NFACompiler -> @SuppressWarnings("unchecked") 	public static <T> NFAFactory<T> compileFactory( 		final Pattern<T, ?> pattern, 		final TypeSerializer<T> inputTypeSerializer, 		boolean timeoutHandling);1499760222;Compiles the given pattern into a {@link NFAFactory}. The NFA factory can be used to create_multiple NFAs.__@param pattern Definition of sequence pattern_@param inputTypeSerializer Serializer for the input type_@param timeoutHandling True if the NFA shall return timed out event patterns_@param <T> Type of the input events_@return Factory for NFAs corresponding to the given pattern;@SuppressWarnings("unchecked")_	public static <T> NFAFactory<T> compileFactory(_		final Pattern<T, ?> pattern,_		final TypeSerializer<T> inputTypeSerializer,_		boolean timeoutHandling) {_		if (pattern == null) {_			_			return new NFAFactoryImpl<>(inputTypeSerializer, 0, Collections.<State<T>>emptyList(), timeoutHandling)__		} else {_			final NFAFactoryCompiler<T> nfaFactoryCompiler = new NFAFactoryCompiler<>(pattern)__			nfaFactoryCompiler.compileFactory()__			return new NFAFactoryImpl<>(inputTypeSerializer, nfaFactoryCompiler.getWindowTime(), nfaFactoryCompiler.getStates(), timeoutHandling)__		}_	};compiles,the,given,pattern,into,a,link,nfafactory,the,nfa,factory,can,be,used,to,create,multiple,nfas,param,pattern,definition,of,sequence,pattern,param,input,type,serializer,serializer,for,the,input,type,param,timeout,handling,true,if,the,nfa,shall,return,timed,out,event,patterns,param,t,type,of,the,input,events,return,factory,for,nfas,corresponding,to,the,given,pattern;suppress,warnings,unchecked,public,static,t,nfafactory,t,compile,factory,final,pattern,t,pattern,final,type,serializer,t,input,type,serializer,boolean,timeout,handling,if,pattern,null,return,new,nfafactory,impl,input,type,serializer,0,collections,state,t,empty,list,timeout,handling,else,final,nfafactory,compiler,t,nfa,factory,compiler,new,nfafactory,compiler,pattern,nfa,factory,compiler,compile,factory,return,new,nfafactory,impl,input,type,serializer,nfa,factory,compiler,get,window,time,nfa,factory,compiler,get,states,timeout,handling
NFACompiler -> @SuppressWarnings("unchecked") 	public static <T> NFAFactory<T> compileFactory( 		final Pattern<T, ?> pattern, 		final TypeSerializer<T> inputTypeSerializer, 		boolean timeoutHandling);1499937690;Compiles the given pattern into a {@link NFAFactory}. The NFA factory can be used to create_multiple NFAs.__@param pattern Definition of sequence pattern_@param inputTypeSerializer Serializer for the input type_@param timeoutHandling True if the NFA shall return timed out event patterns_@param <T> Type of the input events_@return Factory for NFAs corresponding to the given pattern;@SuppressWarnings("unchecked")_	public static <T> NFAFactory<T> compileFactory(_		final Pattern<T, ?> pattern,_		final TypeSerializer<T> inputTypeSerializer,_		boolean timeoutHandling) {_		if (pattern == null) {_			_			return new NFAFactoryImpl<>(inputTypeSerializer, 0, Collections.<State<T>>emptyList(), timeoutHandling)__		} else {_			final NFAFactoryCompiler<T> nfaFactoryCompiler = new NFAFactoryCompiler<>(pattern)__			nfaFactoryCompiler.compileFactory()__			return new NFAFactoryImpl<>(inputTypeSerializer, nfaFactoryCompiler.getWindowTime(), nfaFactoryCompiler.getStates(), timeoutHandling)__		}_	};compiles,the,given,pattern,into,a,link,nfafactory,the,nfa,factory,can,be,used,to,create,multiple,nfas,param,pattern,definition,of,sequence,pattern,param,input,type,serializer,serializer,for,the,input,type,param,timeout,handling,true,if,the,nfa,shall,return,timed,out,event,patterns,param,t,type,of,the,input,events,return,factory,for,nfas,corresponding,to,the,given,pattern;suppress,warnings,unchecked,public,static,t,nfafactory,t,compile,factory,final,pattern,t,pattern,final,type,serializer,t,input,type,serializer,boolean,timeout,handling,if,pattern,null,return,new,nfafactory,impl,input,type,serializer,0,collections,state,t,empty,list,timeout,handling,else,final,nfafactory,compiler,t,nfa,factory,compiler,new,nfafactory,compiler,pattern,nfa,factory,compiler,compile,factory,return,new,nfafactory,impl,input,type,serializer,nfa,factory,compiler,get,window,time,nfa,factory,compiler,get,states,timeout,handling
NFACompiler -> @SuppressWarnings("unchecked") 	public static <T> NFAFactory<T> compileFactory( 		final Pattern<T, ?> pattern, 		final TypeSerializer<T> inputTypeSerializer, 		boolean timeoutHandling);1500021711;Compiles the given pattern into a {@link NFAFactory}. The NFA factory can be used to create_multiple NFAs.__@param pattern Definition of sequence pattern_@param inputTypeSerializer Serializer for the input type_@param timeoutHandling True if the NFA shall return timed out event patterns_@param <T> Type of the input events_@return Factory for NFAs corresponding to the given pattern;@SuppressWarnings("unchecked")_	public static <T> NFAFactory<T> compileFactory(_		final Pattern<T, ?> pattern,_		final TypeSerializer<T> inputTypeSerializer,_		boolean timeoutHandling) {_		if (pattern == null) {_			_			return new NFAFactoryImpl<>(inputTypeSerializer, 0, Collections.<State<T>>emptyList(), timeoutHandling)__		} else {_			final NFAFactoryCompiler<T> nfaFactoryCompiler = new NFAFactoryCompiler<>(pattern)__			nfaFactoryCompiler.compileFactory()__			return new NFAFactoryImpl<>(inputTypeSerializer, nfaFactoryCompiler.getWindowTime(), nfaFactoryCompiler.getStates(), timeoutHandling)__		}_	};compiles,the,given,pattern,into,a,link,nfafactory,the,nfa,factory,can,be,used,to,create,multiple,nfas,param,pattern,definition,of,sequence,pattern,param,input,type,serializer,serializer,for,the,input,type,param,timeout,handling,true,if,the,nfa,shall,return,timed,out,event,patterns,param,t,type,of,the,input,events,return,factory,for,nfas,corresponding,to,the,given,pattern;suppress,warnings,unchecked,public,static,t,nfafactory,t,compile,factory,final,pattern,t,pattern,final,type,serializer,t,input,type,serializer,boolean,timeout,handling,if,pattern,null,return,new,nfafactory,impl,input,type,serializer,0,collections,state,t,empty,list,timeout,handling,else,final,nfafactory,compiler,t,nfa,factory,compiler,new,nfafactory,compiler,pattern,nfa,factory,compiler,compile,factory,return,new,nfafactory,impl,input,type,serializer,nfa,factory,compiler,get,window,time,nfa,factory,compiler,get,states,timeout,handling
NFACompiler -> @SuppressWarnings("unchecked") 	public static <T> NFAFactory<T> compileFactory( 		final Pattern<T, ?> pattern, 		final TypeSerializer<T> inputTypeSerializer, 		boolean timeoutHandling);1501592283;Compiles the given pattern into a {@link NFAFactory}. The NFA factory can be used to create_multiple NFAs.__@param pattern Definition of sequence pattern_@param inputTypeSerializer Serializer for the input type_@param timeoutHandling True if the NFA shall return timed out event patterns_@param <T> Type of the input events_@return Factory for NFAs corresponding to the given pattern;@SuppressWarnings("unchecked")_	public static <T> NFAFactory<T> compileFactory(_		final Pattern<T, ?> pattern,_		final TypeSerializer<T> inputTypeSerializer,_		boolean timeoutHandling) {_		if (pattern == null) {_			_			return new NFAFactoryImpl<>(inputTypeSerializer, 0, Collections.<State<T>>emptyList(), timeoutHandling)__		} else {_			final NFAFactoryCompiler<T> nfaFactoryCompiler = new NFAFactoryCompiler<>(pattern)__			nfaFactoryCompiler.compileFactory()__			return new NFAFactoryImpl<>(inputTypeSerializer, nfaFactoryCompiler.getWindowTime(), nfaFactoryCompiler.getStates(), timeoutHandling)__		}_	};compiles,the,given,pattern,into,a,link,nfafactory,the,nfa,factory,can,be,used,to,create,multiple,nfas,param,pattern,definition,of,sequence,pattern,param,input,type,serializer,serializer,for,the,input,type,param,timeout,handling,true,if,the,nfa,shall,return,timed,out,event,patterns,param,t,type,of,the,input,events,return,factory,for,nfas,corresponding,to,the,given,pattern;suppress,warnings,unchecked,public,static,t,nfafactory,t,compile,factory,final,pattern,t,pattern,final,type,serializer,t,input,type,serializer,boolean,timeout,handling,if,pattern,null,return,new,nfafactory,impl,input,type,serializer,0,collections,state,t,empty,list,timeout,handling,else,final,nfafactory,compiler,t,nfa,factory,compiler,new,nfafactory,compiler,pattern,nfa,factory,compiler,compile,factory,return,new,nfafactory,impl,input,type,serializer,nfa,factory,compiler,get,window,time,nfa,factory,compiler,get,states,timeout,handling
NFACompiler -> @SuppressWarnings("unchecked") 	public static <T> NFAFactory<T> compileFactory( 		final Pattern<T, ?> pattern, 		final TypeSerializer<T> inputTypeSerializer, 		boolean timeoutHandling);1502422141;Compiles the given pattern into a {@link NFAFactory}. The NFA factory can be used to create_multiple NFAs.__@param pattern Definition of sequence pattern_@param inputTypeSerializer Serializer for the input type_@param timeoutHandling True if the NFA shall return timed out event patterns_@param <T> Type of the input events_@return Factory for NFAs corresponding to the given pattern;@SuppressWarnings("unchecked")_	public static <T> NFAFactory<T> compileFactory(_		final Pattern<T, ?> pattern,_		final TypeSerializer<T> inputTypeSerializer,_		boolean timeoutHandling) {_		if (pattern == null) {_			_			return new NFAFactoryImpl<>(inputTypeSerializer, 0, Collections.<State<T>>emptyList(), timeoutHandling)__		} else {_			final NFAFactoryCompiler<T> nfaFactoryCompiler = new NFAFactoryCompiler<>(pattern)__			nfaFactoryCompiler.compileFactory()__			return new NFAFactoryImpl<>(inputTypeSerializer, nfaFactoryCompiler.getWindowTime(), nfaFactoryCompiler.getStates(), timeoutHandling)__		}_	};compiles,the,given,pattern,into,a,link,nfafactory,the,nfa,factory,can,be,used,to,create,multiple,nfas,param,pattern,definition,of,sequence,pattern,param,input,type,serializer,serializer,for,the,input,type,param,timeout,handling,true,if,the,nfa,shall,return,timed,out,event,patterns,param,t,type,of,the,input,events,return,factory,for,nfas,corresponding,to,the,given,pattern;suppress,warnings,unchecked,public,static,t,nfafactory,t,compile,factory,final,pattern,t,pattern,final,type,serializer,t,input,type,serializer,boolean,timeout,handling,if,pattern,null,return,new,nfafactory,impl,input,type,serializer,0,collections,state,t,empty,list,timeout,handling,else,final,nfafactory,compiler,t,nfa,factory,compiler,new,nfafactory,compiler,pattern,nfa,factory,compiler,compile,factory,return,new,nfafactory,impl,input,type,serializer,nfa,factory,compiler,get,window,time,nfa,factory,compiler,get,states,timeout,handling
NFACompiler -> @SuppressWarnings("unchecked") 	public static <T> NFAFactory<T> compileFactory( 		final Pattern<T, ?> pattern, 		final TypeSerializer<T> inputTypeSerializer, 		boolean timeoutHandling);1503588494;Compiles the given pattern into a {@link NFAFactory}. The NFA factory can be used to create_multiple NFAs.__@param pattern Definition of sequence pattern_@param inputTypeSerializer Serializer for the input type_@param timeoutHandling True if the NFA shall return timed out event patterns_@param <T> Type of the input events_@return Factory for NFAs corresponding to the given pattern;@SuppressWarnings("unchecked")_	public static <T> NFAFactory<T> compileFactory(_		final Pattern<T, ?> pattern,_		final TypeSerializer<T> inputTypeSerializer,_		boolean timeoutHandling) {_		if (pattern == null) {_			_			return new NFAFactoryImpl<>(inputTypeSerializer, 0, Collections.<State<T>>emptyList(), timeoutHandling)__		} else {_			final NFAFactoryCompiler<T> nfaFactoryCompiler = new NFAFactoryCompiler<>(pattern)__			nfaFactoryCompiler.compileFactory()__			return new NFAFactoryImpl<>(inputTypeSerializer, nfaFactoryCompiler.getWindowTime(), nfaFactoryCompiler.getStates(), timeoutHandling)__		}_	};compiles,the,given,pattern,into,a,link,nfafactory,the,nfa,factory,can,be,used,to,create,multiple,nfas,param,pattern,definition,of,sequence,pattern,param,input,type,serializer,serializer,for,the,input,type,param,timeout,handling,true,if,the,nfa,shall,return,timed,out,event,patterns,param,t,type,of,the,input,events,return,factory,for,nfas,corresponding,to,the,given,pattern;suppress,warnings,unchecked,public,static,t,nfafactory,t,compile,factory,final,pattern,t,pattern,final,type,serializer,t,input,type,serializer,boolean,timeout,handling,if,pattern,null,return,new,nfafactory,impl,input,type,serializer,0,collections,state,t,empty,list,timeout,handling,else,final,nfafactory,compiler,t,nfa,factory,compiler,new,nfafactory,compiler,pattern,nfa,factory,compiler,compile,factory,return,new,nfafactory,impl,input,type,serializer,nfa,factory,compiler,get,window,time,nfa,factory,compiler,get,states,timeout,handling
NFACompiler -> @SuppressWarnings("unchecked") 	public static <T> NFAFactory<T> compileFactory( 		final Pattern<T, ?> pattern, 		final TypeSerializer<T> inputTypeSerializer, 		boolean timeoutHandling);1518008111;Compiles the given pattern into a {@link NFAFactory}. The NFA factory can be used to create_multiple NFAs.__@param pattern Definition of sequence pattern_@param inputTypeSerializer Serializer for the input type_@param timeoutHandling True if the NFA shall return timed out event patterns_@param <T> Type of the input events_@return Factory for NFAs corresponding to the given pattern;@SuppressWarnings("unchecked")_	public static <T> NFAFactory<T> compileFactory(_		final Pattern<T, ?> pattern,_		final TypeSerializer<T> inputTypeSerializer,_		boolean timeoutHandling) {_		if (pattern == null) {_			_			return new NFAFactoryImpl<>(inputTypeSerializer, 0, Collections.<State<T>>emptyList(), timeoutHandling)__		} else {_			final NFAFactoryCompiler<T> nfaFactoryCompiler = new NFAFactoryCompiler<>(pattern)__			nfaFactoryCompiler.compileFactory()__			return new NFAFactoryImpl<>(inputTypeSerializer, nfaFactoryCompiler.getWindowTime(), nfaFactoryCompiler.getStates(), timeoutHandling)__		}_	};compiles,the,given,pattern,into,a,link,nfafactory,the,nfa,factory,can,be,used,to,create,multiple,nfas,param,pattern,definition,of,sequence,pattern,param,input,type,serializer,serializer,for,the,input,type,param,timeout,handling,true,if,the,nfa,shall,return,timed,out,event,patterns,param,t,type,of,the,input,events,return,factory,for,nfas,corresponding,to,the,given,pattern;suppress,warnings,unchecked,public,static,t,nfafactory,t,compile,factory,final,pattern,t,pattern,final,type,serializer,t,input,type,serializer,boolean,timeout,handling,if,pattern,null,return,new,nfafactory,impl,input,type,serializer,0,collections,state,t,empty,list,timeout,handling,else,final,nfafactory,compiler,t,nfa,factory,compiler,new,nfafactory,compiler,pattern,nfa,factory,compiler,compile,factory,return,new,nfafactory,impl,input,type,serializer,nfa,factory,compiler,get,window,time,nfa,factory,compiler,get,states,timeout,handling
NFACompiler -> NFAFactoryCompiler -> @SuppressWarnings("unchecked") 		private IterativeCondition<T> getTakeCondition(Pattern<T, ?> pattern);1498034481;@return the {@link IterativeCondition condition} for the {@code TAKE} edge_that corresponds to the specified {@link Pattern} and extended with_stop(until) condition if necessary.;@SuppressWarnings("unchecked")_		private IterativeCondition<T> getTakeCondition(Pattern<T, ?> pattern) {_			IterativeCondition<T> takeCondition = (IterativeCondition<T>) pattern.getCondition()__			if (currentGroupPattern != null && currentGroupPattern.getUntilCondition() != null) {_				takeCondition = extendWithUntilCondition(_					takeCondition,_					(IterativeCondition<T>) currentGroupPattern.getUntilCondition())__			}_			return takeCondition__		};return,the,link,iterative,condition,condition,for,the,code,take,edge,that,corresponds,to,the,specified,link,pattern,and,extended,with,stop,until,condition,if,necessary;suppress,warnings,unchecked,private,iterative,condition,t,get,take,condition,pattern,t,pattern,iterative,condition,t,take,condition,iterative,condition,t,pattern,get,condition,if,current,group,pattern,null,current,group,pattern,get,until,condition,null,take,condition,extend,with,until,condition,take,condition,iterative,condition,t,current,group,pattern,get,until,condition,return,take,condition
NFACompiler -> NFAFactoryCompiler -> @SuppressWarnings("unchecked") 		private IterativeCondition<T> getTakeCondition(Pattern<T, ?> pattern);1499760222;@return the {@link IterativeCondition condition} for the {@code TAKE} edge_that corresponds to the specified {@link Pattern} and extended with_stop(until) condition if necessary.;@SuppressWarnings("unchecked")_		private IterativeCondition<T> getTakeCondition(Pattern<T, ?> pattern) {_			IterativeCondition<T> takeCondition = (IterativeCondition<T>) pattern.getCondition()__			if (currentGroupPattern != null && currentGroupPattern.getUntilCondition() != null) {_				takeCondition = extendWithUntilCondition(_					takeCondition,_					(IterativeCondition<T>) currentGroupPattern.getUntilCondition(),_					true)__			}_			return takeCondition__		};return,the,link,iterative,condition,condition,for,the,code,take,edge,that,corresponds,to,the,specified,link,pattern,and,extended,with,stop,until,condition,if,necessary;suppress,warnings,unchecked,private,iterative,condition,t,get,take,condition,pattern,t,pattern,iterative,condition,t,take,condition,iterative,condition,t,pattern,get,condition,if,current,group,pattern,null,current,group,pattern,get,until,condition,null,take,condition,extend,with,until,condition,take,condition,iterative,condition,t,current,group,pattern,get,until,condition,true,return,take,condition
NFACompiler -> NFAFactoryCompiler -> @SuppressWarnings("unchecked") 		private IterativeCondition<T> getTakeCondition(Pattern<T, ?> pattern);1499937690;@return the {@link IterativeCondition condition} for the {@code TAKE} edge_that corresponds to the specified {@link Pattern} and extended with_stop(until) condition if necessary.;@SuppressWarnings("unchecked")_		private IterativeCondition<T> getTakeCondition(Pattern<T, ?> pattern) {_			IterativeCondition<T> takeCondition = (IterativeCondition<T>) pattern.getCondition()__			if (currentGroupPattern != null && currentGroupPattern.getUntilCondition() != null) {_				takeCondition = extendWithUntilCondition(_					takeCondition,_					(IterativeCondition<T>) currentGroupPattern.getUntilCondition(),_					true)__			}_			return takeCondition__		};return,the,link,iterative,condition,condition,for,the,code,take,edge,that,corresponds,to,the,specified,link,pattern,and,extended,with,stop,until,condition,if,necessary;suppress,warnings,unchecked,private,iterative,condition,t,get,take,condition,pattern,t,pattern,iterative,condition,t,take,condition,iterative,condition,t,pattern,get,condition,if,current,group,pattern,null,current,group,pattern,get,until,condition,null,take,condition,extend,with,until,condition,take,condition,iterative,condition,t,current,group,pattern,get,until,condition,true,return,take,condition
NFACompiler -> NFAFactoryCompiler -> @SuppressWarnings("unchecked") 		private IterativeCondition<T> getTakeCondition(Pattern<T, ?> pattern);1500021711;@return the {@link IterativeCondition condition} for the {@code TAKE} edge_that corresponds to the specified {@link Pattern} and extended with_stop(until) condition if necessary.;@SuppressWarnings("unchecked")_		private IterativeCondition<T> getTakeCondition(Pattern<T, ?> pattern) {_			IterativeCondition<T> takeCondition = (IterativeCondition<T>) pattern.getCondition()__			if (currentGroupPattern != null && currentGroupPattern.getUntilCondition() != null) {_				takeCondition = extendWithUntilCondition(_					takeCondition,_					(IterativeCondition<T>) currentGroupPattern.getUntilCondition(),_					true)__			}_			return takeCondition__		};return,the,link,iterative,condition,condition,for,the,code,take,edge,that,corresponds,to,the,specified,link,pattern,and,extended,with,stop,until,condition,if,necessary;suppress,warnings,unchecked,private,iterative,condition,t,get,take,condition,pattern,t,pattern,iterative,condition,t,take,condition,iterative,condition,t,pattern,get,condition,if,current,group,pattern,null,current,group,pattern,get,until,condition,null,take,condition,extend,with,until,condition,take,condition,iterative,condition,t,current,group,pattern,get,until,condition,true,return,take,condition
NFACompiler -> NFAFactoryCompiler -> @SuppressWarnings("unchecked") 		private IterativeCondition<T> getTakeCondition(Pattern<T, ?> pattern);1501592283;@return the {@link IterativeCondition condition} for the {@code TAKE} edge_that corresponds to the specified {@link Pattern} and extended with_stop(until) condition if necessary.;@SuppressWarnings("unchecked")_		private IterativeCondition<T> getTakeCondition(Pattern<T, ?> pattern) {_			IterativeCondition<T> takeCondition = (IterativeCondition<T>) pattern.getCondition()__			if (currentGroupPattern != null && currentGroupPattern.getUntilCondition() != null) {_				takeCondition = extendWithUntilCondition(_					takeCondition,_					(IterativeCondition<T>) currentGroupPattern.getUntilCondition(),_					true)__			}_			return takeCondition__		};return,the,link,iterative,condition,condition,for,the,code,take,edge,that,corresponds,to,the,specified,link,pattern,and,extended,with,stop,until,condition,if,necessary;suppress,warnings,unchecked,private,iterative,condition,t,get,take,condition,pattern,t,pattern,iterative,condition,t,take,condition,iterative,condition,t,pattern,get,condition,if,current,group,pattern,null,current,group,pattern,get,until,condition,null,take,condition,extend,with,until,condition,take,condition,iterative,condition,t,current,group,pattern,get,until,condition,true,return,take,condition
NFACompiler -> NFAFactoryCompiler -> @SuppressWarnings("unchecked") 		private IterativeCondition<T> getTakeCondition(Pattern<T, ?> pattern);1502422141;@return the {@link IterativeCondition condition} for the {@code TAKE} edge_that corresponds to the specified {@link Pattern} and extended with_stop(until) condition if necessary.;@SuppressWarnings("unchecked")_		private IterativeCondition<T> getTakeCondition(Pattern<T, ?> pattern) {_			IterativeCondition<T> takeCondition = (IterativeCondition<T>) pattern.getCondition()__			if (currentGroupPattern != null && currentGroupPattern.getUntilCondition() != null) {_				takeCondition = extendWithUntilCondition(_					takeCondition,_					(IterativeCondition<T>) currentGroupPattern.getUntilCondition(),_					true)__			}_			return takeCondition__		};return,the,link,iterative,condition,condition,for,the,code,take,edge,that,corresponds,to,the,specified,link,pattern,and,extended,with,stop,until,condition,if,necessary;suppress,warnings,unchecked,private,iterative,condition,t,get,take,condition,pattern,t,pattern,iterative,condition,t,take,condition,iterative,condition,t,pattern,get,condition,if,current,group,pattern,null,current,group,pattern,get,until,condition,null,take,condition,extend,with,until,condition,take,condition,iterative,condition,t,current,group,pattern,get,until,condition,true,return,take,condition
NFACompiler -> NFAFactoryCompiler -> @SuppressWarnings("unchecked") 		private IterativeCondition<T> getTakeCondition(Pattern<T, ?> pattern);1503588494;@return the {@link IterativeCondition condition} for the {@code TAKE} edge_that corresponds to the specified {@link Pattern} and extended with_stop(until) condition if necessary.;@SuppressWarnings("unchecked")_		private IterativeCondition<T> getTakeCondition(Pattern<T, ?> pattern) {_			IterativeCondition<T> takeCondition = (IterativeCondition<T>) pattern.getCondition()__			if (currentGroupPattern != null && currentGroupPattern.getUntilCondition() != null) {_				takeCondition = extendWithUntilCondition(_					takeCondition,_					(IterativeCondition<T>) currentGroupPattern.getUntilCondition(),_					true)__			}_			return takeCondition__		};return,the,link,iterative,condition,condition,for,the,code,take,edge,that,corresponds,to,the,specified,link,pattern,and,extended,with,stop,until,condition,if,necessary;suppress,warnings,unchecked,private,iterative,condition,t,get,take,condition,pattern,t,pattern,iterative,condition,t,take,condition,iterative,condition,t,pattern,get,condition,if,current,group,pattern,null,current,group,pattern,get,until,condition,null,take,condition,extend,with,until,condition,take,condition,iterative,condition,t,current,group,pattern,get,until,condition,true,return,take,condition
NFACompiler -> NFAFactoryCompiler -> @SuppressWarnings("unchecked") 		private IterativeCondition<T> getTakeCondition(Pattern<T, ?> pattern);1518008111;@return the {@link IterativeCondition condition} for the {@code TAKE} edge_that corresponds to the specified {@link Pattern} and extended with_stop(until) condition if necessary.;@SuppressWarnings("unchecked")_		private IterativeCondition<T> getTakeCondition(Pattern<T, ?> pattern) {_			IterativeCondition<T> takeCondition = (IterativeCondition<T>) pattern.getCondition()__			if (currentGroupPattern != null && currentGroupPattern.getUntilCondition() != null) {_				takeCondition = extendWithUntilCondition(_					takeCondition,_					(IterativeCondition<T>) currentGroupPattern.getUntilCondition(),_					true)__			}_			return takeCondition__		};return,the,link,iterative,condition,condition,for,the,code,take,edge,that,corresponds,to,the,specified,link,pattern,and,extended,with,stop,until,condition,if,necessary;suppress,warnings,unchecked,private,iterative,condition,t,get,take,condition,pattern,t,pattern,iterative,condition,t,take,condition,iterative,condition,t,pattern,get,condition,if,current,group,pattern,null,current,group,pattern,get,until,condition,null,take,condition,extend,with,until,condition,take,condition,iterative,condition,t,current,group,pattern,get,until,condition,true,return,take,condition
NFACompiler -> NFAFactoryCompiler -> @SuppressWarnings("unchecked") 		private IterativeCondition<T> getTakeCondition(Pattern<T, ?> pattern);1527863170;@return the {@link IterativeCondition condition} for the {@code TAKE} edge_that corresponds to the specified {@link Pattern} and extended with_stop(until) condition if necessary.;@SuppressWarnings("unchecked")_		private IterativeCondition<T> getTakeCondition(Pattern<T, ?> pattern) {_			IterativeCondition<T> takeCondition = (IterativeCondition<T>) pattern.getCondition()__			if (currentGroupPattern != null && currentGroupPattern.getUntilCondition() != null) {_				takeCondition = extendWithUntilCondition(_					takeCondition,_					(IterativeCondition<T>) currentGroupPattern.getUntilCondition(),_					true)__			}_			return takeCondition__		};return,the,link,iterative,condition,condition,for,the,code,take,edge,that,corresponds,to,the,specified,link,pattern,and,extended,with,stop,until,condition,if,necessary;suppress,warnings,unchecked,private,iterative,condition,t,get,take,condition,pattern,t,pattern,iterative,condition,t,take,condition,iterative,condition,t,pattern,get,condition,if,current,group,pattern,null,current,group,pattern,get,until,condition,null,take,condition,extend,with,until,condition,take,condition,iterative,condition,t,current,group,pattern,get,until,condition,true,return,take,condition
NFACompiler -> NFAFactoryCompiler -> @SuppressWarnings("unchecked") 		private IterativeCondition<T> getTakeCondition(Pattern<T, ?> pattern);1528989005;@return the {@link IterativeCondition condition} for the {@code TAKE} edge_that corresponds to the specified {@link Pattern} and extended with_stop(until) condition if necessary.;@SuppressWarnings("unchecked")_		private IterativeCondition<T> getTakeCondition(Pattern<T, ?> pattern) {_			IterativeCondition<T> takeCondition = (IterativeCondition<T>) pattern.getCondition()__			if (currentGroupPattern != null && currentGroupPattern.getUntilCondition() != null) {_				takeCondition = extendWithUntilCondition(_					takeCondition,_					(IterativeCondition<T>) currentGroupPattern.getUntilCondition(),_					true)__			}_			return takeCondition__		};return,the,link,iterative,condition,condition,for,the,code,take,edge,that,corresponds,to,the,specified,link,pattern,and,extended,with,stop,until,condition,if,necessary;suppress,warnings,unchecked,private,iterative,condition,t,get,take,condition,pattern,t,pattern,iterative,condition,t,take,condition,iterative,condition,t,pattern,get,condition,if,current,group,pattern,null,current,group,pattern,get,until,condition,null,take,condition,extend,with,until,condition,take,condition,iterative,condition,t,current,group,pattern,get,until,condition,true,return,take,condition
NFACompiler -> NFAFactoryCompiler -> @SuppressWarnings("unchecked") 		private IterativeCondition<T> getTakeCondition(Pattern<T, ?> pattern);1538745898;@return the {@link IterativeCondition condition} for the {@code TAKE} edge_that corresponds to the specified {@link Pattern} and extended with_stop(until) condition if necessary.;@SuppressWarnings("unchecked")_		private IterativeCondition<T> getTakeCondition(Pattern<T, ?> pattern) {_			IterativeCondition<T> takeCondition = (IterativeCondition<T>) pattern.getCondition()__			if (currentGroupPattern != null && currentGroupPattern.getUntilCondition() != null) {_				takeCondition = extendWithUntilCondition(_					takeCondition,_					(IterativeCondition<T>) currentGroupPattern.getUntilCondition(),_					true)__			}_			return takeCondition__		};return,the,link,iterative,condition,condition,for,the,code,take,edge,that,corresponds,to,the,specified,link,pattern,and,extended,with,stop,until,condition,if,necessary;suppress,warnings,unchecked,private,iterative,condition,t,get,take,condition,pattern,t,pattern,iterative,condition,t,take,condition,iterative,condition,t,pattern,get,condition,if,current,group,pattern,null,current,group,pattern,get,until,condition,null,take,condition,extend,with,until,condition,take,condition,iterative,condition,t,current,group,pattern,get,until,condition,true,return,take,condition
NFACompiler -> NFAFactoryCompiler -> @SuppressWarnings("unchecked") 		private IterativeCondition<T> getTakeCondition(Pattern<T, ?> pattern);1542293931;@return the {@link IterativeCondition condition} for the {@code TAKE} edge_that corresponds to the specified {@link Pattern} and extended with_stop(until) condition if necessary.;@SuppressWarnings("unchecked")_		private IterativeCondition<T> getTakeCondition(Pattern<T, ?> pattern) {_			IterativeCondition<T> takeCondition = (IterativeCondition<T>) pattern.getCondition()__			if (currentGroupPattern != null && currentGroupPattern.getUntilCondition() != null) {_				takeCondition = extendWithUntilCondition(_					takeCondition,_					(IterativeCondition<T>) currentGroupPattern.getUntilCondition(),_					true)__			}_			return takeCondition__		};return,the,link,iterative,condition,condition,for,the,code,take,edge,that,corresponds,to,the,specified,link,pattern,and,extended,with,stop,until,condition,if,necessary;suppress,warnings,unchecked,private,iterative,condition,t,get,take,condition,pattern,t,pattern,iterative,condition,t,take,condition,iterative,condition,t,pattern,get,condition,if,current,group,pattern,null,current,group,pattern,get,until,condition,null,take,condition,extend,with,until,condition,take,condition,iterative,condition,t,current,group,pattern,get,until,condition,true,return,take,condition
NFACompiler -> public static boolean canProduceEmptyMatches(final Pattern<?, ?> pattern);1538745898;Verifies if the provided pattern can possibly generate empty match. Example of patterns that can possibly_generate empty matches are: A*, A?, A* B? etc.__@param pattern pattern to check_@return true if empty match could potentially match the pattern, false otherwise;public static boolean canProduceEmptyMatches(final Pattern<?, ?> pattern) {_		NFAFactoryCompiler<?> compiler = new NFAFactoryCompiler<>(checkNotNull(pattern))__		compiler.compileFactory()__		State<?> startState = compiler.getStates().stream().filter(State::isStart).findFirst().orElseThrow(_			() -> new IllegalStateException("Compiler produced no start state. It is a bug. File a jira."))___		Set<State<?>> visitedStates = new HashSet<>()__		final Stack<State<?>> statesToCheck = new Stack<>()__		statesToCheck.push(startState)__		while (!statesToCheck.isEmpty()) {_			final State<?> currentState = statesToCheck.pop()__			if (visitedStates.contains(currentState)) {_				continue__			} else {_				visitedStates.add(currentState)__			}__			for (StateTransition<?> transition : currentState.getStateTransitions()) {_				if (transition.getAction() == StateTransitionAction.PROCEED) {_					if (transition.getTargetState().isFinal()) {_						return true__					} else {_						statesToCheck.push(transition.getTargetState())__					}_				}_			}_		}__		return false__	};verifies,if,the,provided,pattern,can,possibly,generate,empty,match,example,of,patterns,that,can,possibly,generate,empty,matches,are,a,a,a,b,etc,param,pattern,pattern,to,check,return,true,if,empty,match,could,potentially,match,the,pattern,false,otherwise;public,static,boolean,can,produce,empty,matches,final,pattern,pattern,nfafactory,compiler,compiler,new,nfafactory,compiler,check,not,null,pattern,compiler,compile,factory,state,start,state,compiler,get,states,stream,filter,state,is,start,find,first,or,else,throw,new,illegal,state,exception,compiler,produced,no,start,state,it,is,a,bug,file,a,jira,set,state,visited,states,new,hash,set,final,stack,state,states,to,check,new,stack,states,to,check,push,start,state,while,states,to,check,is,empty,final,state,current,state,states,to,check,pop,if,visited,states,contains,current,state,continue,else,visited,states,add,current,state,for,state,transition,transition,current,state,get,state,transitions,if,transition,get,action,state,transition,action,proceed,if,transition,get,target,state,is,final,return,true,else,states,to,check,push,transition,get,target,state,return,false
NFACompiler -> public static boolean canProduceEmptyMatches(final Pattern<?, ?> pattern);1542293931;Verifies if the provided pattern can possibly generate empty match. Example of patterns that can possibly_generate empty matches are: A*, A?, A* B? etc.__@param pattern pattern to check_@return true if empty match could potentially match the pattern, false otherwise;public static boolean canProduceEmptyMatches(final Pattern<?, ?> pattern) {_		NFAFactoryCompiler<?> compiler = new NFAFactoryCompiler<>(checkNotNull(pattern))__		compiler.compileFactory()__		State<?> startState = compiler.getStates().stream().filter(State::isStart).findFirst().orElseThrow(_			() -> new IllegalStateException("Compiler produced no start state. It is a bug. File a jira."))___		Set<State<?>> visitedStates = new HashSet<>()__		final Stack<State<?>> statesToCheck = new Stack<>()__		statesToCheck.push(startState)__		while (!statesToCheck.isEmpty()) {_			final State<?> currentState = statesToCheck.pop()__			if (visitedStates.contains(currentState)) {_				continue__			} else {_				visitedStates.add(currentState)__			}__			for (StateTransition<?> transition : currentState.getStateTransitions()) {_				if (transition.getAction() == StateTransitionAction.PROCEED) {_					if (transition.getTargetState().isFinal()) {_						return true__					} else {_						statesToCheck.push(transition.getTargetState())__					}_				}_			}_		}__		return false__	};verifies,if,the,provided,pattern,can,possibly,generate,empty,match,example,of,patterns,that,can,possibly,generate,empty,matches,are,a,a,a,b,etc,param,pattern,pattern,to,check,return,true,if,empty,match,could,potentially,match,the,pattern,false,otherwise;public,static,boolean,can,produce,empty,matches,final,pattern,pattern,nfafactory,compiler,compiler,new,nfafactory,compiler,check,not,null,pattern,compiler,compile,factory,state,start,state,compiler,get,states,stream,filter,state,is,start,find,first,or,else,throw,new,illegal,state,exception,compiler,produced,no,start,state,it,is,a,bug,file,a,jira,set,state,visited,states,new,hash,set,final,stack,state,states,to,check,new,stack,states,to,check,push,start,state,while,states,to,check,is,empty,final,state,current,state,states,to,check,pop,if,visited,states,contains,current,state,continue,else,visited,states,add,current,state,for,state,transition,transition,current,state,get,state,transitions,if,transition,get,action,state,transition,action,proceed,if,transition,get,target,state,is,final,return,true,else,states,to,check,push,transition,get,target,state,return,false
