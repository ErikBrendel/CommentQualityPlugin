# id;timestamp;commentText;codeText;commentWords;codeWords
Pattern -> public Pattern<T, T> followedByAny(final String name);1493382517;Appends a new pattern to the existing one. The new pattern enforces non-strict_temporal contiguity. This means that a matching event of this pattern and the_preceding matching event might be interleaved with other events which are ignored.__@param name Name of the new pattern_@return A new pattern which is appended to this one;public Pattern<T, T> followedByAny(final String name) {_		return new Pattern<>(name, this, ConsumingStrategy.SKIP_TILL_ANY)__	};appends,a,new,pattern,to,the,existing,one,the,new,pattern,enforces,non,strict,temporal,contiguity,this,means,that,a,matching,event,of,this,pattern,and,the,preceding,matching,event,might,be,interleaved,with,other,events,which,are,ignored,param,name,name,of,the,new,pattern,return,a,new,pattern,which,is,appended,to,this,one;public,pattern,t,t,followed,by,any,final,string,name,return,new,pattern,name,this,consuming,strategy
Pattern -> public Pattern<T, T> followedByAny(final String name);1493906327;Appends a new pattern to the existing one. The new pattern enforces non-strict_temporal contiguity. This means that a matching event of this pattern and the_preceding matching event might be interleaved with other events which are ignored.__@param name Name of the new pattern_@return A new pattern which is appended to this one;public Pattern<T, T> followedByAny(final String name) {_		return new Pattern<>(name, this, ConsumingStrategy.SKIP_TILL_ANY)__	};appends,a,new,pattern,to,the,existing,one,the,new,pattern,enforces,non,strict,temporal,contiguity,this,means,that,a,matching,event,of,this,pattern,and,the,preceding,matching,event,might,be,interleaved,with,other,events,which,are,ignored,param,name,name,of,the,new,pattern,return,a,new,pattern,which,is,appended,to,this,one;public,pattern,t,t,followed,by,any,final,string,name,return,new,pattern,name,this,consuming,strategy
Pattern -> public Pattern<T, T> followedByAny(final String name);1493985576;Appends a new pattern to the existing one. The new pattern enforces non-strict_temporal contiguity. This means that a matching event of this pattern and the_preceding matching event might be interleaved with other events which are ignored.__@param name Name of the new pattern_@return A new pattern which is appended to this one;public Pattern<T, T> followedByAny(final String name) {_		return new Pattern<>(name, this, ConsumingStrategy.SKIP_TILL_ANY)__	};appends,a,new,pattern,to,the,existing,one,the,new,pattern,enforces,non,strict,temporal,contiguity,this,means,that,a,matching,event,of,this,pattern,and,the,preceding,matching,event,might,be,interleaved,with,other,events,which,are,ignored,param,name,name,of,the,new,pattern,return,a,new,pattern,which,is,appended,to,this,one;public,pattern,t,t,followed,by,any,final,string,name,return,new,pattern,name,this,consuming,strategy
Pattern -> public Pattern<T, T> followedByAny(final String name);1493997908;Appends a new pattern to the existing one. The new pattern enforces non-strict_temporal contiguity. This means that a matching event of this pattern and the_preceding matching event might be interleaved with other events which are ignored.__@param name Name of the new pattern_@return A new pattern which is appended to this one;public Pattern<T, T> followedByAny(final String name) {_		return new Pattern<>(name, this, ConsumingStrategy.SKIP_TILL_ANY)__	};appends,a,new,pattern,to,the,existing,one,the,new,pattern,enforces,non,strict,temporal,contiguity,this,means,that,a,matching,event,of,this,pattern,and,the,preceding,matching,event,might,be,interleaved,with,other,events,which,are,ignored,param,name,name,of,the,new,pattern,return,a,new,pattern,which,is,appended,to,this,one;public,pattern,t,t,followed,by,any,final,string,name,return,new,pattern,name,this,consuming,strategy
Pattern -> public Pattern<T, T> followedByAny(final String name);1495961498;Appends a new pattern to the existing one. The new pattern enforces non-strict_temporal contiguity. This means that a matching event of this pattern and the_preceding matching event might be interleaved with other events which are ignored.__@param name Name of the new pattern_@return A new pattern which is appended to this one;public Pattern<T, T> followedByAny(final String name) {_		return new Pattern<>(name, this, ConsumingStrategy.SKIP_TILL_ANY)__	};appends,a,new,pattern,to,the,existing,one,the,new,pattern,enforces,non,strict,temporal,contiguity,this,means,that,a,matching,event,of,this,pattern,and,the,preceding,matching,event,might,be,interleaved,with,other,events,which,are,ignored,param,name,name,of,the,new,pattern,return,a,new,pattern,which,is,appended,to,this,one;public,pattern,t,t,followed,by,any,final,string,name,return,new,pattern,name,this,consuming,strategy
Pattern -> public Pattern<T, T> followedByAny(final String name);1497940477;Appends a new pattern to the existing one. The new pattern enforces non-strict_temporal contiguity. This means that a matching event of this pattern and the_preceding matching event might be interleaved with other events which are ignored.__@param name Name of the new pattern_@return A new pattern which is appended to this one;public Pattern<T, T> followedByAny(final String name) {_		return new Pattern<>(name, this, ConsumingStrategy.SKIP_TILL_ANY)__	};appends,a,new,pattern,to,the,existing,one,the,new,pattern,enforces,non,strict,temporal,contiguity,this,means,that,a,matching,event,of,this,pattern,and,the,preceding,matching,event,might,be,interleaved,with,other,events,which,are,ignored,param,name,name,of,the,new,pattern,return,a,new,pattern,which,is,appended,to,this,one;public,pattern,t,t,followed,by,any,final,string,name,return,new,pattern,name,this,consuming,strategy
Pattern -> public Pattern<T, T> followedByAny(final String name);1498548074;Appends a new pattern to the existing one. The new pattern enforces non-strict_temporal contiguity. This means that a matching event of this pattern and the_preceding matching event might be interleaved with other events which are ignored.__@param name Name of the new pattern_@return A new pattern which is appended to this one;public Pattern<T, T> followedByAny(final String name) {_		return new Pattern<>(name, this, ConsumingStrategy.SKIP_TILL_ANY)__	};appends,a,new,pattern,to,the,existing,one,the,new,pattern,enforces,non,strict,temporal,contiguity,this,means,that,a,matching,event,of,this,pattern,and,the,preceding,matching,event,might,be,interleaved,with,other,events,which,are,ignored,param,name,name,of,the,new,pattern,return,a,new,pattern,which,is,appended,to,this,one;public,pattern,t,t,followed,by,any,final,string,name,return,new,pattern,name,this,consuming,strategy
Pattern -> public Pattern<T, T> followedByAny(final String name);1499244360;Appends a new pattern to the existing one. The new pattern enforces non-strict_temporal contiguity. This means that a matching event of this pattern and the_preceding matching event might be interleaved with other events which are ignored.__@param name Name of the new pattern_@return A new pattern which is appended to this one;public Pattern<T, T> followedByAny(final String name) {_		return new Pattern<>(name, this, ConsumingStrategy.SKIP_TILL_ANY)__	};appends,a,new,pattern,to,the,existing,one,the,new,pattern,enforces,non,strict,temporal,contiguity,this,means,that,a,matching,event,of,this,pattern,and,the,preceding,matching,event,might,be,interleaved,with,other,events,which,are,ignored,param,name,name,of,the,new,pattern,return,a,new,pattern,which,is,appended,to,this,one;public,pattern,t,t,followed,by,any,final,string,name,return,new,pattern,name,this,consuming,strategy
Pattern -> public Pattern<T, T> followedByAny(final String name);1499248439;Appends a new pattern to the existing one. The new pattern enforces non-strict_temporal contiguity. This means that a matching event of this pattern and the_preceding matching event might be interleaved with other events which are ignored.__@param name Name of the new pattern_@return A new pattern which is appended to this one;public Pattern<T, T> followedByAny(final String name) {_		return new Pattern<>(name, this, ConsumingStrategy.SKIP_TILL_ANY)__	};appends,a,new,pattern,to,the,existing,one,the,new,pattern,enforces,non,strict,temporal,contiguity,this,means,that,a,matching,event,of,this,pattern,and,the,preceding,matching,event,might,be,interleaved,with,other,events,which,are,ignored,param,name,name,of,the,new,pattern,return,a,new,pattern,which,is,appended,to,this,one;public,pattern,t,t,followed,by,any,final,string,name,return,new,pattern,name,this,consuming,strategy
Pattern -> public Pattern<T, T> followedByAny(final String name);1503420807;Appends a new pattern to the existing one. The new pattern enforces non-strict_temporal contiguity. This means that a matching event of this pattern and the_preceding matching event might be interleaved with other events which are ignored.__@param name Name of the new pattern_@return A new pattern which is appended to this one;public Pattern<T, T> followedByAny(final String name) {_		return new Pattern<>(name, this, ConsumingStrategy.SKIP_TILL_ANY)__	};appends,a,new,pattern,to,the,existing,one,the,new,pattern,enforces,non,strict,temporal,contiguity,this,means,that,a,matching,event,of,this,pattern,and,the,preceding,matching,event,might,be,interleaved,with,other,events,which,are,ignored,param,name,name,of,the,new,pattern,return,a,new,pattern,which,is,appended,to,this,one;public,pattern,t,t,followed,by,any,final,string,name,return,new,pattern,name,this,consuming,strategy
Pattern -> public Pattern<T, T> followedByAny(final String name);1503558242;Appends a new pattern to the existing one. The new pattern enforces non-strict_temporal contiguity. This means that a matching event of this pattern and the_preceding matching event might be interleaved with other events which are ignored.__@param name Name of the new pattern_@return A new pattern which is appended to this one;public Pattern<T, T> followedByAny(final String name) {_		return new Pattern<>(name, this, ConsumingStrategy.SKIP_TILL_ANY)__	};appends,a,new,pattern,to,the,existing,one,the,new,pattern,enforces,non,strict,temporal,contiguity,this,means,that,a,matching,event,of,this,pattern,and,the,preceding,matching,event,might,be,interleaved,with,other,events,which,are,ignored,param,name,name,of,the,new,pattern,return,a,new,pattern,which,is,appended,to,this,one;public,pattern,t,t,followed,by,any,final,string,name,return,new,pattern,name,this,consuming,strategy
Pattern -> public Pattern<T, T> followedByAny(final String name);1504268438;Appends a new pattern to the existing one. The new pattern enforces non-strict_temporal contiguity. This means that a matching event of this pattern and the_preceding matching event might be interleaved with other events which are ignored.__@param name Name of the new pattern_@return A new pattern which is appended to this one;public Pattern<T, T> followedByAny(final String name) {_		return new Pattern<>(name, this, ConsumingStrategy.SKIP_TILL_ANY, afterMatchSkipStrategy)__	};appends,a,new,pattern,to,the,existing,one,the,new,pattern,enforces,non,strict,temporal,contiguity,this,means,that,a,matching,event,of,this,pattern,and,the,preceding,matching,event,might,be,interleaved,with,other,events,which,are,ignored,param,name,name,of,the,new,pattern,return,a,new,pattern,which,is,appended,to,this,one;public,pattern,t,t,followed,by,any,final,string,name,return,new,pattern,name,this,consuming,strategy,after,match,skip,strategy
Pattern -> public Pattern<T, T> followedByAny(final String name);1530798894;Appends a new pattern to the existing one. The new pattern enforces non-strict_temporal contiguity. This means that a matching event of this pattern and the_preceding matching event might be interleaved with other events which are ignored.__@param name Name of the new pattern_@return A new pattern which is appended to this one;public Pattern<T, T> followedByAny(final String name) {_		return new Pattern<>(name, this, ConsumingStrategy.SKIP_TILL_ANY, afterMatchSkipStrategy)__	};appends,a,new,pattern,to,the,existing,one,the,new,pattern,enforces,non,strict,temporal,contiguity,this,means,that,a,matching,event,of,this,pattern,and,the,preceding,matching,event,might,be,interleaved,with,other,events,which,are,ignored,param,name,name,of,the,new,pattern,return,a,new,pattern,which,is,appended,to,this,one;public,pattern,t,t,followed,by,any,final,string,name,return,new,pattern,name,this,consuming,strategy,after,match,skip,strategy
Pattern -> public Pattern<T, T> followedByAny(final String name);1540208358;Appends a new pattern to the existing one. The new pattern enforces non-strict_temporal contiguity. This means that a matching event of this pattern and the_preceding matching event might be interleaved with other events which are ignored.__@param name Name of the new pattern_@return A new pattern which is appended to this one;public Pattern<T, T> followedByAny(final String name) {_		return new Pattern<>(name, this, ConsumingStrategy.SKIP_TILL_ANY, afterMatchSkipStrategy)__	};appends,a,new,pattern,to,the,existing,one,the,new,pattern,enforces,non,strict,temporal,contiguity,this,means,that,a,matching,event,of,this,pattern,and,the,preceding,matching,event,might,be,interleaved,with,other,events,which,are,ignored,param,name,name,of,the,new,pattern,return,a,new,pattern,which,is,appended,to,this,one;public,pattern,t,t,followed,by,any,final,string,name,return,new,pattern,name,this,consuming,strategy,after,match,skip,strategy
Pattern -> public Pattern<T, T> followedByAny(final String name);1543413704;Appends a new pattern to the existing one. The new pattern enforces non-strict_temporal contiguity. This means that a matching event of this pattern and the_preceding matching event might be interleaved with other events which are ignored.__@param name Name of the new pattern_@return A new pattern which is appended to this one;public Pattern<T, T> followedByAny(final String name) {_		return new Pattern<>(name, this, ConsumingStrategy.SKIP_TILL_ANY, afterMatchSkipStrategy)__	};appends,a,new,pattern,to,the,existing,one,the,new,pattern,enforces,non,strict,temporal,contiguity,this,means,that,a,matching,event,of,this,pattern,and,the,preceding,matching,event,might,be,interleaved,with,other,events,which,are,ignored,param,name,name,of,the,new,pattern,return,a,new,pattern,which,is,appended,to,this,one;public,pattern,t,t,followed,by,any,final,string,name,return,new,pattern,name,this,consuming,strategy,after,match,skip,strategy
Pattern -> public Pattern<T, F> zeroOrMore();1490262475;Specifies that this pattern can occur zero or more times(kleene star)._This means any number of events can be matched in this state.__@return The same pattern with applied Kleene star operator__@throws MalformedPatternException if quantifier already applied;public Pattern<T, F> zeroOrMore() {_		return zeroOrMore(true)__	};specifies,that,this,pattern,can,occur,zero,or,more,times,kleene,star,this,means,any,number,of,events,can,be,matched,in,this,state,return,the,same,pattern,with,applied,kleene,star,operator,throws,malformed,pattern,exception,if,quantifier,already,applied;public,pattern,t,f,zero,or,more,return,zero,or,more,true
Pattern -> public Pattern<T, F> zeroOrMore();1490638274;Specifies that this pattern can occur zero or more times(kleene star)._This means any number of events can be matched in this state.__@return The same pattern with applied Kleene star operator__@throws MalformedPatternException if quantifier already applied;public Pattern<T, F> zeroOrMore() {_		return zeroOrMore(true)__	};specifies,that,this,pattern,can,occur,zero,or,more,times,kleene,star,this,means,any,number,of,events,can,be,matched,in,this,state,return,the,same,pattern,with,applied,kleene,star,operator,throws,malformed,pattern,exception,if,quantifier,already,applied;public,pattern,t,f,zero,or,more,return,zero,or,more,true
Pattern -> public Pattern<T, F> zeroOrMore();1490862259;Specifies that this pattern can occur zero or more times(kleene star)._This means any number of events can be matched in this state.__@return The same pattern with applied Kleene star operator__@throws MalformedPatternException if quantifier already applied;public Pattern<T, F> zeroOrMore() {_		return zeroOrMore(true)__	};specifies,that,this,pattern,can,occur,zero,or,more,times,kleene,star,this,means,any,number,of,events,can,be,matched,in,this,state,return,the,same,pattern,with,applied,kleene,star,operator,throws,malformed,pattern,exception,if,quantifier,already,applied;public,pattern,t,f,zero,or,more,return,zero,or,more,true
Pattern -> public Pattern<T, F> zeroOrMore();1491647251;Specifies that this pattern can occur zero or more times(kleene star)._This means any number of events can be matched in this state.__@return The same pattern with applied Kleene star operator__@throws MalformedPatternException if quantifier already applied;public Pattern<T, F> zeroOrMore() {_		return zeroOrMore(true)__	};specifies,that,this,pattern,can,occur,zero,or,more,times,kleene,star,this,means,any,number,of,events,can,be,matched,in,this,state,return,the,same,pattern,with,applied,kleene,star,operator,throws,malformed,pattern,exception,if,quantifier,already,applied;public,pattern,t,f,zero,or,more,return,zero,or,more,true
Pattern -> public Pattern<T, F> times(int times);1490262475;Specifies exact number of times that this pattern should be matched.__@param times number of times matching event must appear_@return The same pattern with number of times applied__@throws MalformedPatternException if quantifier already applied;public Pattern<T, F> times(int times) {_		checkIfQuantifierApplied()__		Preconditions.checkArgument(times > 0, "You should give a positive number greater than 0.")__		this.quantifier = Quantifier.TIMES__		this.times = times__		return this__	};specifies,exact,number,of,times,that,this,pattern,should,be,matched,param,times,number,of,times,matching,event,must,appear,return,the,same,pattern,with,number,of,times,applied,throws,malformed,pattern,exception,if,quantifier,already,applied;public,pattern,t,f,times,int,times,check,if,quantifier,applied,preconditions,check,argument,times,0,you,should,give,a,positive,number,greater,than,0,this,quantifier,quantifier,times,this,times,times,return,this
Pattern -> public Pattern<T, F> times(int times);1490638274;Specifies exact number of times that this pattern should be matched.__@param times number of times matching event must appear_@return The same pattern with number of times applied__@throws MalformedPatternException if quantifier already applied;public Pattern<T, F> times(int times) {_		checkIfQuantifierApplied()__		Preconditions.checkArgument(times > 0, "You should give a positive number greater than 0.")__		this.quantifier = Quantifier.TIMES__		this.times = times__		return this__	};specifies,exact,number,of,times,that,this,pattern,should,be,matched,param,times,number,of,times,matching,event,must,appear,return,the,same,pattern,with,number,of,times,applied,throws,malformed,pattern,exception,if,quantifier,already,applied;public,pattern,t,f,times,int,times,check,if,quantifier,applied,preconditions,check,argument,times,0,you,should,give,a,positive,number,greater,than,0,this,quantifier,quantifier,times,this,times,times,return,this
Pattern -> public Pattern<T, F> times(int times);1490862259;Specifies exact number of times that this pattern should be matched.__@param times number of times matching event must appear_@return The same pattern with number of times applied__@throws MalformedPatternException if quantifier already applied;public Pattern<T, F> times(int times) {_		checkIfQuantifierApplied()__		Preconditions.checkArgument(times > 0, "You should give a positive number greater than 0.")__		this.quantifier = Quantifier.TIMES__		this.times = times__		return this__	};specifies,exact,number,of,times,that,this,pattern,should,be,matched,param,times,number,of,times,matching,event,must,appear,return,the,same,pattern,with,number,of,times,applied,throws,malformed,pattern,exception,if,quantifier,already,applied;public,pattern,t,f,times,int,times,check,if,quantifier,applied,preconditions,check,argument,times,0,you,should,give,a,positive,number,greater,than,0,this,quantifier,quantifier,times,this,times,times,return,this
Pattern -> public Pattern<T, F> times(int times);1491647251;Specifies exact number of times that this pattern should be matched.__@param times number of times matching event must appear_@return The same pattern with number of times applied__@throws MalformedPatternException if quantifier already applied;public Pattern<T, F> times(int times) {_		checkIfQuantifierApplied()__		Preconditions.checkArgument(times > 0, "You should give a positive number greater than 0.")__		this.quantifier = Quantifier.TIMES__		this.times = times__		return this__	};specifies,exact,number,of,times,that,this,pattern,should,be,matched,param,times,number,of,times,matching,event,must,appear,return,the,same,pattern,with,number,of,times,applied,throws,malformed,pattern,exception,if,quantifier,already,applied;public,pattern,t,f,times,int,times,check,if,quantifier,applied,preconditions,check,argument,times,0,you,should,give,a,positive,number,greater,than,0,this,quantifier,quantifier,times,this,times,times,return,this
Pattern -> public Pattern<T, F> times(int times);1493201751;Specifies exact number of times that this pattern should be matched.__@param times number of times matching event must appear_@return The same pattern with number of times applied__@throws MalformedPatternException if the quantifier is not applicable to this pattern.;public Pattern<T, F> times(int times) {_		checkIfQuantifierApplied()__		Preconditions.checkArgument(times > 0, "You should give a positive number greater than 0.")__		this.quantifier = Quantifier.TIMES()__		this.times = times__		return this__	};specifies,exact,number,of,times,that,this,pattern,should,be,matched,param,times,number,of,times,matching,event,must,appear,return,the,same,pattern,with,number,of,times,applied,throws,malformed,pattern,exception,if,the,quantifier,is,not,applicable,to,this,pattern;public,pattern,t,f,times,int,times,check,if,quantifier,applied,preconditions,check,argument,times,0,you,should,give,a,positive,number,greater,than,0,this,quantifier,quantifier,times,this,times,times,return,this
Pattern -> public Pattern<T, F> times(int times);1493201753;Specifies exact number of times that this pattern should be matched.__@param times number of times matching event must appear_@return The same pattern with number of times applied__@throws MalformedPatternException if the quantifier is not applicable to this pattern.;public Pattern<T, F> times(int times) {_		checkIfQuantifierApplied()__		Preconditions.checkArgument(times > 0, "You should give a positive number greater than 0.")__		this.quantifier = Quantifier.TIMES()__		this.times = times__		return this__	};specifies,exact,number,of,times,that,this,pattern,should,be,matched,param,times,number,of,times,matching,event,must,appear,return,the,same,pattern,with,number,of,times,applied,throws,malformed,pattern,exception,if,the,quantifier,is,not,applicable,to,this,pattern;public,pattern,t,f,times,int,times,check,if,quantifier,applied,preconditions,check,argument,times,0,you,should,give,a,positive,number,greater,than,0,this,quantifier,quantifier,times,this,times,times,return,this
Pattern -> public Pattern<T, F> times(int times);1493382517;Specifies exact number of times that this pattern should be matched.__@param times number of times matching event must appear_@return The same pattern with number of times applied__@throws MalformedPatternException if the quantifier is not applicable to this pattern.;public Pattern<T, F> times(int times) {_		checkIfQuantifierApplied()__		Preconditions.checkArgument(times > 0, "You should give a positive number greater than 0.")__		this.quantifier = Quantifier.TIMES(quantifier.getConsumingStrategy())__		this.times = times__		return this__	};specifies,exact,number,of,times,that,this,pattern,should,be,matched,param,times,number,of,times,matching,event,must,appear,return,the,same,pattern,with,number,of,times,applied,throws,malformed,pattern,exception,if,the,quantifier,is,not,applicable,to,this,pattern;public,pattern,t,f,times,int,times,check,if,quantifier,applied,preconditions,check,argument,times,0,you,should,give,a,positive,number,greater,than,0,this,quantifier,quantifier,times,quantifier,get,consuming,strategy,this,times,times,return,this
Pattern -> public Pattern<T, F> times(int times);1493906327;Specifies exact number of times that this pattern should be matched.__@param times number of times matching event must appear_@return The same pattern with number of times applied__@throws MalformedPatternException if the quantifier is not applicable to this pattern.;public Pattern<T, F> times(int times) {_		checkIfQuantifierApplied()__		Preconditions.checkArgument(times > 0, "You should give a positive number greater than 0.")__		this.quantifier = Quantifier.TIMES(quantifier.getConsumingStrategy())__		this.times = times__		return this__	};specifies,exact,number,of,times,that,this,pattern,should,be,matched,param,times,number,of,times,matching,event,must,appear,return,the,same,pattern,with,number,of,times,applied,throws,malformed,pattern,exception,if,the,quantifier,is,not,applicable,to,this,pattern;public,pattern,t,f,times,int,times,check,if,quantifier,applied,preconditions,check,argument,times,0,you,should,give,a,positive,number,greater,than,0,this,quantifier,quantifier,times,quantifier,get,consuming,strategy,this,times,times,return,this
Pattern -> public Pattern<T, F> times(int times);1493985576;Specifies exact number of times that this pattern should be matched.__@param times number of times matching event must appear_@return The same pattern with number of times applied__@throws MalformedPatternException if the quantifier is not applicable to this pattern.;public Pattern<T, F> times(int times) {_		checkIfNoNotPattern()__		checkIfQuantifierApplied()__		Preconditions.checkArgument(times > 0, "You should give a positive number greater than 0.")__		this.quantifier = Quantifier.TIMES(quantifier.getConsumingStrategy())__		this.times = times__		return this__	};specifies,exact,number,of,times,that,this,pattern,should,be,matched,param,times,number,of,times,matching,event,must,appear,return,the,same,pattern,with,number,of,times,applied,throws,malformed,pattern,exception,if,the,quantifier,is,not,applicable,to,this,pattern;public,pattern,t,f,times,int,times,check,if,no,not,pattern,check,if,quantifier,applied,preconditions,check,argument,times,0,you,should,give,a,positive,number,greater,than,0,this,quantifier,quantifier,times,quantifier,get,consuming,strategy,this,times,times,return,this
Pattern -> public Pattern<T, F> times(int times);1493997908;Specifies exact number of times that this pattern should be matched.__@param times number of times matching event must appear_@return The same pattern with number of times applied__@throws MalformedPatternException if the quantifier is not applicable to this pattern.;public Pattern<T, F> times(int times) {_		checkIfNoNotPattern()__		checkIfQuantifierApplied()__		Preconditions.checkArgument(times > 0, "You should give a positive number greater than 0.")__		this.quantifier = Quantifier.TIMES(quantifier.getConsumingStrategy())__		this.times = times__		return this__	};specifies,exact,number,of,times,that,this,pattern,should,be,matched,param,times,number,of,times,matching,event,must,appear,return,the,same,pattern,with,number,of,times,applied,throws,malformed,pattern,exception,if,the,quantifier,is,not,applicable,to,this,pattern;public,pattern,t,f,times,int,times,check,if,no,not,pattern,check,if,quantifier,applied,preconditions,check,argument,times,0,you,should,give,a,positive,number,greater,than,0,this,quantifier,quantifier,times,quantifier,get,consuming,strategy,this,times,times,return,this
Pattern -> public Pattern<T, F> times(int times);1495961498;Specifies exact number of times that this pattern should be matched.__@param times number of times matching event must appear_@return The same pattern with number of times applied__@throws MalformedPatternException if the quantifier is not applicable to this pattern.;public Pattern<T, F> times(int times) {_		checkIfNoNotPattern()__		checkIfQuantifierApplied()__		Preconditions.checkArgument(times > 0, "You should give a positive number greater than 0.")__		this.quantifier = Quantifier.times(quantifier.getConsumingStrategy())__		this.times = times__		return this__	};specifies,exact,number,of,times,that,this,pattern,should,be,matched,param,times,number,of,times,matching,event,must,appear,return,the,same,pattern,with,number,of,times,applied,throws,malformed,pattern,exception,if,the,quantifier,is,not,applicable,to,this,pattern;public,pattern,t,f,times,int,times,check,if,no,not,pattern,check,if,quantifier,applied,preconditions,check,argument,times,0,you,should,give,a,positive,number,greater,than,0,this,quantifier,quantifier,times,quantifier,get,consuming,strategy,this,times,times,return,this
Pattern -> public Pattern<T, F> times(int times);1497940477;Specifies exact number of times that this pattern should be matched.__@param times number of times matching event must appear_@return The same pattern with number of times applied__@throws MalformedPatternException if the quantifier is not applicable to this pattern.;public Pattern<T, F> times(int times) {_		checkIfNoNotPattern()__		checkIfQuantifierApplied()__		Preconditions.checkArgument(times > 0, "You should give a positive number greater than 0.")__		this.quantifier = Quantifier.times(quantifier.getConsumingStrategy())__		this.times = Times.of(times)__		return this__	};specifies,exact,number,of,times,that,this,pattern,should,be,matched,param,times,number,of,times,matching,event,must,appear,return,the,same,pattern,with,number,of,times,applied,throws,malformed,pattern,exception,if,the,quantifier,is,not,applicable,to,this,pattern;public,pattern,t,f,times,int,times,check,if,no,not,pattern,check,if,quantifier,applied,preconditions,check,argument,times,0,you,should,give,a,positive,number,greater,than,0,this,quantifier,quantifier,times,quantifier,get,consuming,strategy,this,times,times,of,times,return,this
Pattern -> public Pattern<T, F> times(int times);1498548074;Specifies exact number of times that this pattern should be matched.__@param times number of times matching event must appear_@return The same pattern with number of times applied__@throws MalformedPatternException if the quantifier is not applicable to this pattern.;public Pattern<T, F> times(int times) {_		checkIfNoNotPattern()__		checkIfQuantifierApplied()__		Preconditions.checkArgument(times > 0, "You should give a positive number greater than 0.")__		this.quantifier = Quantifier.times(quantifier.getConsumingStrategy())__		this.times = Times.of(times)__		return this__	};specifies,exact,number,of,times,that,this,pattern,should,be,matched,param,times,number,of,times,matching,event,must,appear,return,the,same,pattern,with,number,of,times,applied,throws,malformed,pattern,exception,if,the,quantifier,is,not,applicable,to,this,pattern;public,pattern,t,f,times,int,times,check,if,no,not,pattern,check,if,quantifier,applied,preconditions,check,argument,times,0,you,should,give,a,positive,number,greater,than,0,this,quantifier,quantifier,times,quantifier,get,consuming,strategy,this,times,times,of,times,return,this
Pattern -> public Pattern<T, F> times(int times);1499244360;Specifies exact number of times that this pattern should be matched.__@param times number of times matching event must appear_@return The same pattern with number of times applied__@throws MalformedPatternException if the quantifier is not applicable to this pattern.;public Pattern<T, F> times(int times) {_		checkIfNoNotPattern()__		checkIfQuantifierApplied()__		Preconditions.checkArgument(times > 0, "You should give a positive number greater than 0.")__		this.quantifier = Quantifier.times(quantifier.getConsumingStrategy())__		this.times = Times.of(times)__		return this__	};specifies,exact,number,of,times,that,this,pattern,should,be,matched,param,times,number,of,times,matching,event,must,appear,return,the,same,pattern,with,number,of,times,applied,throws,malformed,pattern,exception,if,the,quantifier,is,not,applicable,to,this,pattern;public,pattern,t,f,times,int,times,check,if,no,not,pattern,check,if,quantifier,applied,preconditions,check,argument,times,0,you,should,give,a,positive,number,greater,than,0,this,quantifier,quantifier,times,quantifier,get,consuming,strategy,this,times,times,of,times,return,this
Pattern -> public Pattern<T, F> times(int times);1499248439;Specifies exact number of times that this pattern should be matched.__@param times number of times matching event must appear_@return The same pattern with number of times applied__@throws MalformedPatternException if the quantifier is not applicable to this pattern.;public Pattern<T, F> times(int times) {_		checkIfNoNotPattern()__		checkIfQuantifierApplied()__		Preconditions.checkArgument(times > 0, "You should give a positive number greater than 0.")__		this.quantifier = Quantifier.times(quantifier.getConsumingStrategy())__		this.times = Times.of(times)__		return this__	};specifies,exact,number,of,times,that,this,pattern,should,be,matched,param,times,number,of,times,matching,event,must,appear,return,the,same,pattern,with,number,of,times,applied,throws,malformed,pattern,exception,if,the,quantifier,is,not,applicable,to,this,pattern;public,pattern,t,f,times,int,times,check,if,no,not,pattern,check,if,quantifier,applied,preconditions,check,argument,times,0,you,should,give,a,positive,number,greater,than,0,this,quantifier,quantifier,times,quantifier,get,consuming,strategy,this,times,times,of,times,return,this
Pattern -> public Pattern<T, F> times(int times);1503420807;Specifies exact number of times that this pattern should be matched.__@param times number of times matching event must appear_@return The same pattern with number of times applied__@throws MalformedPatternException if the quantifier is not applicable to this pattern.;public Pattern<T, F> times(int times) {_		checkIfNoNotPattern()__		checkIfQuantifierApplied()__		Preconditions.checkArgument(times > 0, "You should give a positive number greater than 0.")__		this.quantifier = Quantifier.times(quantifier.getConsumingStrategy())__		this.times = Times.of(times)__		return this__	};specifies,exact,number,of,times,that,this,pattern,should,be,matched,param,times,number,of,times,matching,event,must,appear,return,the,same,pattern,with,number,of,times,applied,throws,malformed,pattern,exception,if,the,quantifier,is,not,applicable,to,this,pattern;public,pattern,t,f,times,int,times,check,if,no,not,pattern,check,if,quantifier,applied,preconditions,check,argument,times,0,you,should,give,a,positive,number,greater,than,0,this,quantifier,quantifier,times,quantifier,get,consuming,strategy,this,times,times,of,times,return,this
Pattern -> public Pattern<T, F> times(int times);1503558242;Specifies exact number of times that this pattern should be matched.__@param times number of times matching event must appear_@return The same pattern with number of times applied__@throws MalformedPatternException if the quantifier is not applicable to this pattern.;public Pattern<T, F> times(int times) {_		checkIfNoNotPattern()__		checkIfQuantifierApplied()__		Preconditions.checkArgument(times > 0, "You should give a positive number greater than 0.")__		this.quantifier = Quantifier.times(quantifier.getConsumingStrategy())__		this.times = Times.of(times)__		return this__	};specifies,exact,number,of,times,that,this,pattern,should,be,matched,param,times,number,of,times,matching,event,must,appear,return,the,same,pattern,with,number,of,times,applied,throws,malformed,pattern,exception,if,the,quantifier,is,not,applicable,to,this,pattern;public,pattern,t,f,times,int,times,check,if,no,not,pattern,check,if,quantifier,applied,preconditions,check,argument,times,0,you,should,give,a,positive,number,greater,than,0,this,quantifier,quantifier,times,quantifier,get,consuming,strategy,this,times,times,of,times,return,this
Pattern -> public Pattern<T, F> times(int times);1504268438;Specifies exact number of times that this pattern should be matched.__@param times number of times matching event must appear_@return The same pattern with number of times applied__@throws MalformedPatternException if the quantifier is not applicable to this pattern.;public Pattern<T, F> times(int times) {_		checkIfNoNotPattern()__		checkIfQuantifierApplied()__		Preconditions.checkArgument(times > 0, "You should give a positive number greater than 0.")__		this.quantifier = Quantifier.times(quantifier.getConsumingStrategy())__		this.times = Times.of(times)__		return this__	};specifies,exact,number,of,times,that,this,pattern,should,be,matched,param,times,number,of,times,matching,event,must,appear,return,the,same,pattern,with,number,of,times,applied,throws,malformed,pattern,exception,if,the,quantifier,is,not,applicable,to,this,pattern;public,pattern,t,f,times,int,times,check,if,no,not,pattern,check,if,quantifier,applied,preconditions,check,argument,times,0,you,should,give,a,positive,number,greater,than,0,this,quantifier,quantifier,times,quantifier,get,consuming,strategy,this,times,times,of,times,return,this
Pattern -> public Pattern<T, F> times(int times);1530798894;Specifies exact number of times that this pattern should be matched.__@param times number of times matching event must appear_@return The same pattern with number of times applied__@throws MalformedPatternException if the quantifier is not applicable to this pattern.;public Pattern<T, F> times(int times) {_		checkIfNoNotPattern()__		checkIfQuantifierApplied()__		Preconditions.checkArgument(times > 0, "You should give a positive number greater than 0.")__		this.quantifier = Quantifier.times(quantifier.getConsumingStrategy())__		this.times = Times.of(times)__		return this__	};specifies,exact,number,of,times,that,this,pattern,should,be,matched,param,times,number,of,times,matching,event,must,appear,return,the,same,pattern,with,number,of,times,applied,throws,malformed,pattern,exception,if,the,quantifier,is,not,applicable,to,this,pattern;public,pattern,t,f,times,int,times,check,if,no,not,pattern,check,if,quantifier,applied,preconditions,check,argument,times,0,you,should,give,a,positive,number,greater,than,0,this,quantifier,quantifier,times,quantifier,get,consuming,strategy,this,times,times,of,times,return,this
Pattern -> public Pattern<T, F> times(int times);1540208358;Specifies exact number of times that this pattern should be matched.__@param times number of times matching event must appear_@return The same pattern with number of times applied__@throws MalformedPatternException if the quantifier is not applicable to this pattern.;public Pattern<T, F> times(int times) {_		checkIfNoNotPattern()__		checkIfQuantifierApplied()__		Preconditions.checkArgument(times > 0, "You should give a positive number greater than 0.")__		this.quantifier = Quantifier.times(quantifier.getConsumingStrategy())__		this.times = Times.of(times)__		return this__	};specifies,exact,number,of,times,that,this,pattern,should,be,matched,param,times,number,of,times,matching,event,must,appear,return,the,same,pattern,with,number,of,times,applied,throws,malformed,pattern,exception,if,the,quantifier,is,not,applicable,to,this,pattern;public,pattern,t,f,times,int,times,check,if,no,not,pattern,check,if,quantifier,applied,preconditions,check,argument,times,0,you,should,give,a,positive,number,greater,than,0,this,quantifier,quantifier,times,quantifier,get,consuming,strategy,this,times,times,of,times,return,this
Pattern -> public Pattern<T, F> times(int times);1543413704;Specifies exact number of times that this pattern should be matched.__@param times number of times matching event must appear_@return The same pattern with number of times applied__@throws MalformedPatternException if the quantifier is not applicable to this pattern.;public Pattern<T, F> times(int times) {_		checkIfNoNotPattern()__		checkIfQuantifierApplied()__		Preconditions.checkArgument(times > 0, "You should give a positive number greater than 0.")__		this.quantifier = Quantifier.times(quantifier.getConsumingStrategy())__		this.times = Times.of(times)__		return this__	};specifies,exact,number,of,times,that,this,pattern,should,be,matched,param,times,number,of,times,matching,event,must,appear,return,the,same,pattern,with,number,of,times,applied,throws,malformed,pattern,exception,if,the,quantifier,is,not,applicable,to,this,pattern;public,pattern,t,f,times,int,times,check,if,no,not,pattern,check,if,quantifier,applied,preconditions,check,argument,times,0,you,should,give,a,positive,number,greater,than,0,this,quantifier,quantifier,times,quantifier,get,consuming,strategy,this,times,times,of,times,return,this
Pattern -> public <S extends F> Pattern<T, S> subtype(final Class<S> subtypeClass);1454421848;Applies a subtype constraint on the current pattern operator. This means that an event has_to be of the given subtype in order to be matched.__@param subtypeClass Class of the subtype_@param <S> Type of the subtype_@return The same pattern operator with the new subtype constraint;public <S extends F> Pattern<T, S> subtype(final Class<S> subtypeClass) {_		if (filterFunction == null) {_			this.filterFunction = new SubtypeFilterFunction<F>(subtypeClass)__		} else {_			this.filterFunction = new AndFilterFunction<F>(this.filterFunction, new SubtypeFilterFunction<F>(subtypeClass))__		}__		@SuppressWarnings("unchecked")_		Pattern<T, S> result = (Pattern<T, S>) this___		return result__	};applies,a,subtype,constraint,on,the,current,pattern,operator,this,means,that,an,event,has,to,be,of,the,given,subtype,in,order,to,be,matched,param,subtype,class,class,of,the,subtype,param,s,type,of,the,subtype,return,the,same,pattern,operator,with,the,new,subtype,constraint;public,s,extends,f,pattern,t,s,subtype,final,class,s,subtype,class,if,filter,function,null,this,filter,function,new,subtype,filter,function,f,subtype,class,else,this,filter,function,new,and,filter,function,f,this,filter,function,new,subtype,filter,function,f,subtype,class,suppress,warnings,unchecked,pattern,t,s,result,pattern,t,s,this,return,result
Pattern -> public <S extends F> Pattern<T, S> subtype(final Class<S> subtypeClass);1456442894;Applies a subtype constraint on the current pattern operator. This means that an event has_to be of the given subtype in order to be matched.__@param subtypeClass Class of the subtype_@param <S> Type of the subtype_@return The same pattern operator with the new subtype constraint;public <S extends F> Pattern<T, S> subtype(final Class<S> subtypeClass) {_		if (filterFunction == null) {_			this.filterFunction = new SubtypeFilterFunction<F>(subtypeClass)__		} else {_			this.filterFunction = new AndFilterFunction<F>(this.filterFunction, new SubtypeFilterFunction<F>(subtypeClass))__		}__		@SuppressWarnings("unchecked")_		Pattern<T, S> result = (Pattern<T, S>) this___		return result__	};applies,a,subtype,constraint,on,the,current,pattern,operator,this,means,that,an,event,has,to,be,of,the,given,subtype,in,order,to,be,matched,param,subtype,class,class,of,the,subtype,param,s,type,of,the,subtype,return,the,same,pattern,operator,with,the,new,subtype,constraint;public,s,extends,f,pattern,t,s,subtype,final,class,s,subtype,class,if,filter,function,null,this,filter,function,new,subtype,filter,function,f,subtype,class,else,this,filter,function,new,and,filter,function,f,this,filter,function,new,subtype,filter,function,f,subtype,class,suppress,warnings,unchecked,pattern,t,s,result,pattern,t,s,this,return,result
Pattern -> public <S extends F> Pattern<T, S> subtype(final Class<S> subtypeClass);1461689259;Applies a subtype constraint on the current pattern operator. This means that an event has_to be of the given subtype in order to be matched.__@param subtypeClass Class of the subtype_@param <S> Type of the subtype_@return The same pattern operator with the new subtype constraint;public <S extends F> Pattern<T, S> subtype(final Class<S> subtypeClass) {_		if (filterFunction == null) {_			this.filterFunction = new SubtypeFilterFunction<F>(subtypeClass)__		} else {_			this.filterFunction = new AndFilterFunction<F>(this.filterFunction, new SubtypeFilterFunction<F>(subtypeClass))__		}__		@SuppressWarnings("unchecked")_		Pattern<T, S> result = (Pattern<T, S>) this___		return result__	};applies,a,subtype,constraint,on,the,current,pattern,operator,this,means,that,an,event,has,to,be,of,the,given,subtype,in,order,to,be,matched,param,subtype,class,class,of,the,subtype,param,s,type,of,the,subtype,return,the,same,pattern,operator,with,the,new,subtype,constraint;public,s,extends,f,pattern,t,s,subtype,final,class,s,subtype,class,if,filter,function,null,this,filter,function,new,subtype,filter,function,f,subtype,class,else,this,filter,function,new,and,filter,function,f,this,filter,function,new,subtype,filter,function,f,subtype,class,suppress,warnings,unchecked,pattern,t,s,result,pattern,t,s,this,return,result
Pattern -> public <S extends F> Pattern<T, S> subtype(final Class<S> subtypeClass);1471613162;Applies a subtype constraint on the current pattern operator. This means that an event has_to be of the given subtype in order to be matched.__@param subtypeClass Class of the subtype_@param <S> Type of the subtype_@return The same pattern operator with the new subtype constraint;public <S extends F> Pattern<T, S> subtype(final Class<S> subtypeClass) {_		if (filterFunction == null) {_			this.filterFunction = new SubtypeFilterFunction<F>(subtypeClass)__		} else {_			this.filterFunction = new AndFilterFunction<F>(this.filterFunction, new SubtypeFilterFunction<F>(subtypeClass))__		}__		@SuppressWarnings("unchecked")_		Pattern<T, S> result = (Pattern<T, S>) this___		return result__	};applies,a,subtype,constraint,on,the,current,pattern,operator,this,means,that,an,event,has,to,be,of,the,given,subtype,in,order,to,be,matched,param,subtype,class,class,of,the,subtype,param,s,type,of,the,subtype,return,the,same,pattern,operator,with,the,new,subtype,constraint;public,s,extends,f,pattern,t,s,subtype,final,class,s,subtype,class,if,filter,function,null,this,filter,function,new,subtype,filter,function,f,subtype,class,else,this,filter,function,new,and,filter,function,f,this,filter,function,new,subtype,filter,function,f,subtype,class,suppress,warnings,unchecked,pattern,t,s,result,pattern,t,s,this,return,result
Pattern -> public <S extends F> Pattern<T, S> subtype(final Class<S> subtypeClass);1471614454;Applies a subtype constraint on the current pattern operator. This means that an event has_to be of the given subtype in order to be matched.__@param subtypeClass Class of the subtype_@param <S> Type of the subtype_@return The same pattern operator with the new subtype constraint;public <S extends F> Pattern<T, S> subtype(final Class<S> subtypeClass) {_		if (filterFunction == null) {_			this.filterFunction = new SubtypeFilterFunction<F>(subtypeClass)__		} else {_			this.filterFunction = new AndFilterFunction<F>(this.filterFunction, new SubtypeFilterFunction<F>(subtypeClass))__		}__		@SuppressWarnings("unchecked")_		Pattern<T, S> result = (Pattern<T, S>) this___		return result__	};applies,a,subtype,constraint,on,the,current,pattern,operator,this,means,that,an,event,has,to,be,of,the,given,subtype,in,order,to,be,matched,param,subtype,class,class,of,the,subtype,param,s,type,of,the,subtype,return,the,same,pattern,operator,with,the,new,subtype,constraint;public,s,extends,f,pattern,t,s,subtype,final,class,s,subtype,class,if,filter,function,null,this,filter,function,new,subtype,filter,function,f,subtype,class,else,this,filter,function,new,and,filter,function,f,this,filter,function,new,subtype,filter,function,f,subtype,class,suppress,warnings,unchecked,pattern,t,s,result,pattern,t,s,this,return,result
Pattern -> public <S extends F> Pattern<T, S> subtype(final Class<S> subtypeClass);1488270949;Applies a subtype constraint on the current pattern operator. This means that an event has_to be of the given subtype in order to be matched.__@param subtypeClass Class of the subtype_@param <S> Type of the subtype_@return The same pattern operator with the new subtype constraint;public <S extends F> Pattern<T, S> subtype(final Class<S> subtypeClass) {_		if (filterFunction == null) {_			this.filterFunction = new SubtypeFilterFunction<F>(subtypeClass)__		} else {_			this.filterFunction = new AndFilterFunction<F>(this.filterFunction, new SubtypeFilterFunction<F>(subtypeClass))__		}__		@SuppressWarnings("unchecked")_		Pattern<T, S> result = (Pattern<T, S>) this___		return result__	};applies,a,subtype,constraint,on,the,current,pattern,operator,this,means,that,an,event,has,to,be,of,the,given,subtype,in,order,to,be,matched,param,subtype,class,class,of,the,subtype,param,s,type,of,the,subtype,return,the,same,pattern,operator,with,the,new,subtype,constraint;public,s,extends,f,pattern,t,s,subtype,final,class,s,subtype,class,if,filter,function,null,this,filter,function,new,subtype,filter,function,f,subtype,class,else,this,filter,function,new,and,filter,function,f,this,filter,function,new,subtype,filter,function,f,subtype,class,suppress,warnings,unchecked,pattern,t,s,result,pattern,t,s,this,return,result
Pattern -> public <S extends F> Pattern<T, S> subtype(final Class<S> subtypeClass);1490262475;Applies a subtype constraint on the current pattern operator. This means that an event has_to be of the given subtype in order to be matched.__@param subtypeClass Class of the subtype_@param <S> Type of the subtype_@return The same pattern operator with the new subtype constraint;public <S extends F> Pattern<T, S> subtype(final Class<S> subtypeClass) {_		if (filterFunction == null) {_			this.filterFunction = new SubtypeFilterFunction<F>(subtypeClass)__		} else {_			this.filterFunction = new AndFilterFunction<F>(this.filterFunction, new SubtypeFilterFunction<F>(subtypeClass))__		}__		@SuppressWarnings("unchecked")_		Pattern<T, S> result = (Pattern<T, S>) this___		return result__	};applies,a,subtype,constraint,on,the,current,pattern,operator,this,means,that,an,event,has,to,be,of,the,given,subtype,in,order,to,be,matched,param,subtype,class,class,of,the,subtype,param,s,type,of,the,subtype,return,the,same,pattern,operator,with,the,new,subtype,constraint;public,s,extends,f,pattern,t,s,subtype,final,class,s,subtype,class,if,filter,function,null,this,filter,function,new,subtype,filter,function,f,subtype,class,else,this,filter,function,new,and,filter,function,f,this,filter,function,new,subtype,filter,function,f,subtype,class,suppress,warnings,unchecked,pattern,t,s,result,pattern,t,s,this,return,result
Pattern -> public <S extends F> Pattern<T, S> subtype(final Class<S> subtypeClass);1490638274;Applies a subtype constraint on the current pattern operator. This means that an event has_to be of the given subtype in order to be matched.__@param subtypeClass Class of the subtype_@param <S> Type of the subtype_@return The same pattern operator with the new subtype constraint;public <S extends F> Pattern<T, S> subtype(final Class<S> subtypeClass) {_		if (condition == null) {_			this.condition = new SubtypeCondition<F>(subtypeClass)__		} else {_			this.condition = new AndCondition<>(this.condition,_					new SubtypeCondition<F>(subtypeClass))__		}__		@SuppressWarnings("unchecked")_		Pattern<T, S> result = (Pattern<T, S>) this___		return result__	};applies,a,subtype,constraint,on,the,current,pattern,operator,this,means,that,an,event,has,to,be,of,the,given,subtype,in,order,to,be,matched,param,subtype,class,class,of,the,subtype,param,s,type,of,the,subtype,return,the,same,pattern,operator,with,the,new,subtype,constraint;public,s,extends,f,pattern,t,s,subtype,final,class,s,subtype,class,if,condition,null,this,condition,new,subtype,condition,f,subtype,class,else,this,condition,new,and,condition,this,condition,new,subtype,condition,f,subtype,class,suppress,warnings,unchecked,pattern,t,s,result,pattern,t,s,this,return,result
Pattern -> public <S extends F> Pattern<T, S> subtype(final Class<S> subtypeClass);1490862259;Applies a subtype constraint on the current pattern operator. This means that an event has_to be of the given subtype in order to be matched.__@param subtypeClass Class of the subtype_@param <S> Type of the subtype_@return The same pattern operator with the new subtype constraint;public <S extends F> Pattern<T, S> subtype(final Class<S> subtypeClass) {_		if (condition == null) {_			this.condition = new SubtypeCondition<F>(subtypeClass)__		} else {_			this.condition = new AndCondition<>(this.condition,_					new SubtypeCondition<F>(subtypeClass))__		}__		@SuppressWarnings("unchecked")_		Pattern<T, S> result = (Pattern<T, S>) this___		return result__	};applies,a,subtype,constraint,on,the,current,pattern,operator,this,means,that,an,event,has,to,be,of,the,given,subtype,in,order,to,be,matched,param,subtype,class,class,of,the,subtype,param,s,type,of,the,subtype,return,the,same,pattern,operator,with,the,new,subtype,constraint;public,s,extends,f,pattern,t,s,subtype,final,class,s,subtype,class,if,condition,null,this,condition,new,subtype,condition,f,subtype,class,else,this,condition,new,and,condition,this,condition,new,subtype,condition,f,subtype,class,suppress,warnings,unchecked,pattern,t,s,result,pattern,t,s,this,return,result
Pattern -> public <S extends F> Pattern<T, S> subtype(final Class<S> subtypeClass);1491647251;Applies a subtype constraint on the current pattern operator. This means that an event has_to be of the given subtype in order to be matched.__@param subtypeClass Class of the subtype_@param <S> Type of the subtype_@return The same pattern operator with the new subtype constraint;public <S extends F> Pattern<T, S> subtype(final Class<S> subtypeClass) {_		if (condition == null) {_			this.condition = new SubtypeCondition<F>(subtypeClass)__		} else {_			this.condition = new AndCondition<>(this.condition,_					new SubtypeCondition<F>(subtypeClass))__		}__		@SuppressWarnings("unchecked")_		Pattern<T, S> result = (Pattern<T, S>) this___		return result__	};applies,a,subtype,constraint,on,the,current,pattern,operator,this,means,that,an,event,has,to,be,of,the,given,subtype,in,order,to,be,matched,param,subtype,class,class,of,the,subtype,param,s,type,of,the,subtype,return,the,same,pattern,operator,with,the,new,subtype,constraint;public,s,extends,f,pattern,t,s,subtype,final,class,s,subtype,class,if,condition,null,this,condition,new,subtype,condition,f,subtype,class,else,this,condition,new,and,condition,this,condition,new,subtype,condition,f,subtype,class,suppress,warnings,unchecked,pattern,t,s,result,pattern,t,s,this,return,result
Pattern -> public <S extends F> Pattern<T, S> subtype(final Class<S> subtypeClass);1493201751;Applies a subtype constraint on the current pattern. This means that an event has_to be of the given subtype in order to be matched.__@param subtypeClass Class of the subtype_@param <S> Type of the subtype_@return The same pattern with the new subtype constraint;public <S extends F> Pattern<T, S> subtype(final Class<S> subtypeClass) {_		if (condition == null) {_			this.condition = new SubtypeCondition<F>(subtypeClass)__		} else {_			this.condition = new AndCondition<>(condition, new SubtypeCondition<F>(subtypeClass))__		}__		@SuppressWarnings("unchecked")_		Pattern<T, S> result = (Pattern<T, S>) this___		return result__	};applies,a,subtype,constraint,on,the,current,pattern,this,means,that,an,event,has,to,be,of,the,given,subtype,in,order,to,be,matched,param,subtype,class,class,of,the,subtype,param,s,type,of,the,subtype,return,the,same,pattern,with,the,new,subtype,constraint;public,s,extends,f,pattern,t,s,subtype,final,class,s,subtype,class,if,condition,null,this,condition,new,subtype,condition,f,subtype,class,else,this,condition,new,and,condition,condition,new,subtype,condition,f,subtype,class,suppress,warnings,unchecked,pattern,t,s,result,pattern,t,s,this,return,result
Pattern -> public <S extends F> Pattern<T, S> subtype(final Class<S> subtypeClass);1493201753;Applies a subtype constraint on the current pattern. This means that an event has_to be of the given subtype in order to be matched.__@param subtypeClass Class of the subtype_@param <S> Type of the subtype_@return The same pattern with the new subtype constraint;public <S extends F> Pattern<T, S> subtype(final Class<S> subtypeClass) {_		if (condition == null) {_			this.condition = new SubtypeCondition<F>(subtypeClass)__		} else {_			this.condition = new AndCondition<>(condition, new SubtypeCondition<F>(subtypeClass))__		}__		@SuppressWarnings("unchecked")_		Pattern<T, S> result = (Pattern<T, S>) this___		return result__	};applies,a,subtype,constraint,on,the,current,pattern,this,means,that,an,event,has,to,be,of,the,given,subtype,in,order,to,be,matched,param,subtype,class,class,of,the,subtype,param,s,type,of,the,subtype,return,the,same,pattern,with,the,new,subtype,constraint;public,s,extends,f,pattern,t,s,subtype,final,class,s,subtype,class,if,condition,null,this,condition,new,subtype,condition,f,subtype,class,else,this,condition,new,and,condition,condition,new,subtype,condition,f,subtype,class,suppress,warnings,unchecked,pattern,t,s,result,pattern,t,s,this,return,result
Pattern -> public <S extends F> Pattern<T, S> subtype(final Class<S> subtypeClass);1493382517;Applies a subtype constraint on the current pattern. This means that an event has_to be of the given subtype in order to be matched.__@param subtypeClass Class of the subtype_@param <S> Type of the subtype_@return The same pattern with the new subtype constraint;public <S extends F> Pattern<T, S> subtype(final Class<S> subtypeClass) {_		if (condition == null) {_			this.condition = new SubtypeCondition<F>(subtypeClass)__		} else {_			this.condition = new AndCondition<>(condition, new SubtypeCondition<F>(subtypeClass))__		}__		@SuppressWarnings("unchecked")_		Pattern<T, S> result = (Pattern<T, S>) this___		return result__	};applies,a,subtype,constraint,on,the,current,pattern,this,means,that,an,event,has,to,be,of,the,given,subtype,in,order,to,be,matched,param,subtype,class,class,of,the,subtype,param,s,type,of,the,subtype,return,the,same,pattern,with,the,new,subtype,constraint;public,s,extends,f,pattern,t,s,subtype,final,class,s,subtype,class,if,condition,null,this,condition,new,subtype,condition,f,subtype,class,else,this,condition,new,and,condition,condition,new,subtype,condition,f,subtype,class,suppress,warnings,unchecked,pattern,t,s,result,pattern,t,s,this,return,result
Pattern -> public <S extends F> Pattern<T, S> subtype(final Class<S> subtypeClass);1493906327;Applies a subtype constraint on the current pattern. This means that an event has_to be of the given subtype in order to be matched.__@param subtypeClass Class of the subtype_@param <S> Type of the subtype_@return The same pattern with the new subtype constraint;public <S extends F> Pattern<T, S> subtype(final Class<S> subtypeClass) {_		Preconditions.checkNotNull(subtypeClass, "The class cannot be null.")___		if (condition == null) {_			this.condition = new SubtypeCondition<F>(subtypeClass)__		} else {_			this.condition = new AndCondition<>(condition, new SubtypeCondition<F>(subtypeClass))__		}__		@SuppressWarnings("unchecked")_		Pattern<T, S> result = (Pattern<T, S>) this___		return result__	};applies,a,subtype,constraint,on,the,current,pattern,this,means,that,an,event,has,to,be,of,the,given,subtype,in,order,to,be,matched,param,subtype,class,class,of,the,subtype,param,s,type,of,the,subtype,return,the,same,pattern,with,the,new,subtype,constraint;public,s,extends,f,pattern,t,s,subtype,final,class,s,subtype,class,preconditions,check,not,null,subtype,class,the,class,cannot,be,null,if,condition,null,this,condition,new,subtype,condition,f,subtype,class,else,this,condition,new,and,condition,condition,new,subtype,condition,f,subtype,class,suppress,warnings,unchecked,pattern,t,s,result,pattern,t,s,this,return,result
Pattern -> public <S extends F> Pattern<T, S> subtype(final Class<S> subtypeClass);1493985576;Applies a subtype constraint on the current pattern. This means that an event has_to be of the given subtype in order to be matched.__@param subtypeClass Class of the subtype_@param <S> Type of the subtype_@return The same pattern with the new subtype constraint;public <S extends F> Pattern<T, S> subtype(final Class<S> subtypeClass) {_		Preconditions.checkNotNull(subtypeClass, "The class cannot be null.")___		if (condition == null) {_			this.condition = new SubtypeCondition<F>(subtypeClass)__		} else {_			this.condition = new AndCondition<>(condition, new SubtypeCondition<F>(subtypeClass))__		}__		@SuppressWarnings("unchecked")_		Pattern<T, S> result = (Pattern<T, S>) this___		return result__	};applies,a,subtype,constraint,on,the,current,pattern,this,means,that,an,event,has,to,be,of,the,given,subtype,in,order,to,be,matched,param,subtype,class,class,of,the,subtype,param,s,type,of,the,subtype,return,the,same,pattern,with,the,new,subtype,constraint;public,s,extends,f,pattern,t,s,subtype,final,class,s,subtype,class,preconditions,check,not,null,subtype,class,the,class,cannot,be,null,if,condition,null,this,condition,new,subtype,condition,f,subtype,class,else,this,condition,new,and,condition,condition,new,subtype,condition,f,subtype,class,suppress,warnings,unchecked,pattern,t,s,result,pattern,t,s,this,return,result
Pattern -> public <S extends F> Pattern<T, S> subtype(final Class<S> subtypeClass);1493997908;Applies a subtype constraint on the current pattern. This means that an event has_to be of the given subtype in order to be matched.__@param subtypeClass Class of the subtype_@param <S> Type of the subtype_@return The same pattern with the new subtype constraint;public <S extends F> Pattern<T, S> subtype(final Class<S> subtypeClass) {_		Preconditions.checkNotNull(subtypeClass, "The class cannot be null.")___		if (condition == null) {_			this.condition = new SubtypeCondition<F>(subtypeClass)__		} else {_			this.condition = new AndCondition<>(condition, new SubtypeCondition<F>(subtypeClass))__		}__		@SuppressWarnings("unchecked")_		Pattern<T, S> result = (Pattern<T, S>) this___		return result__	};applies,a,subtype,constraint,on,the,current,pattern,this,means,that,an,event,has,to,be,of,the,given,subtype,in,order,to,be,matched,param,subtype,class,class,of,the,subtype,param,s,type,of,the,subtype,return,the,same,pattern,with,the,new,subtype,constraint;public,s,extends,f,pattern,t,s,subtype,final,class,s,subtype,class,preconditions,check,not,null,subtype,class,the,class,cannot,be,null,if,condition,null,this,condition,new,subtype,condition,f,subtype,class,else,this,condition,new,and,condition,condition,new,subtype,condition,f,subtype,class,suppress,warnings,unchecked,pattern,t,s,result,pattern,t,s,this,return,result
Pattern -> public <S extends F> Pattern<T, S> subtype(final Class<S> subtypeClass);1495961498;Applies a subtype constraint on the current pattern. This means that an event has_to be of the given subtype in order to be matched.__@param subtypeClass Class of the subtype_@param <S> Type of the subtype_@return The same pattern with the new subtype constraint;public <S extends F> Pattern<T, S> subtype(final Class<S> subtypeClass) {_		Preconditions.checkNotNull(subtypeClass, "The class cannot be null.")___		if (condition == null) {_			this.condition = new SubtypeCondition<F>(subtypeClass)__		} else {_			this.condition = new AndCondition<>(condition, new SubtypeCondition<F>(subtypeClass))__		}__		@SuppressWarnings("unchecked")_		Pattern<T, S> result = (Pattern<T, S>) this___		return result__	};applies,a,subtype,constraint,on,the,current,pattern,this,means,that,an,event,has,to,be,of,the,given,subtype,in,order,to,be,matched,param,subtype,class,class,of,the,subtype,param,s,type,of,the,subtype,return,the,same,pattern,with,the,new,subtype,constraint;public,s,extends,f,pattern,t,s,subtype,final,class,s,subtype,class,preconditions,check,not,null,subtype,class,the,class,cannot,be,null,if,condition,null,this,condition,new,subtype,condition,f,subtype,class,else,this,condition,new,and,condition,condition,new,subtype,condition,f,subtype,class,suppress,warnings,unchecked,pattern,t,s,result,pattern,t,s,this,return,result
Pattern -> public <S extends F> Pattern<T, S> subtype(final Class<S> subtypeClass);1497940477;Applies a subtype constraint on the current pattern. This means that an event has_to be of the given subtype in order to be matched.__@param subtypeClass Class of the subtype_@param <S> Type of the subtype_@return The same pattern with the new subtype constraint;public <S extends F> Pattern<T, S> subtype(final Class<S> subtypeClass) {_		Preconditions.checkNotNull(subtypeClass, "The class cannot be null.")___		if (condition == null) {_			this.condition = new SubtypeCondition<F>(subtypeClass)__		} else {_			this.condition = new AndCondition<>(condition, new SubtypeCondition<F>(subtypeClass))__		}__		@SuppressWarnings("unchecked")_		Pattern<T, S> result = (Pattern<T, S>) this___		return result__	};applies,a,subtype,constraint,on,the,current,pattern,this,means,that,an,event,has,to,be,of,the,given,subtype,in,order,to,be,matched,param,subtype,class,class,of,the,subtype,param,s,type,of,the,subtype,return,the,same,pattern,with,the,new,subtype,constraint;public,s,extends,f,pattern,t,s,subtype,final,class,s,subtype,class,preconditions,check,not,null,subtype,class,the,class,cannot,be,null,if,condition,null,this,condition,new,subtype,condition,f,subtype,class,else,this,condition,new,and,condition,condition,new,subtype,condition,f,subtype,class,suppress,warnings,unchecked,pattern,t,s,result,pattern,t,s,this,return,result
Pattern -> public <S extends F> Pattern<T, S> subtype(final Class<S> subtypeClass);1498548074;Applies a subtype constraint on the current pattern. This means that an event has_to be of the given subtype in order to be matched.__@param subtypeClass Class of the subtype_@param <S> Type of the subtype_@return The same pattern with the new subtype constraint;public <S extends F> Pattern<T, S> subtype(final Class<S> subtypeClass) {_		Preconditions.checkNotNull(subtypeClass, "The class cannot be null.")___		if (condition == null) {_			this.condition = new SubtypeCondition<F>(subtypeClass)__		} else {_			this.condition = new AndCondition<>(condition, new SubtypeCondition<F>(subtypeClass))__		}__		@SuppressWarnings("unchecked")_		Pattern<T, S> result = (Pattern<T, S>) this___		return result__	};applies,a,subtype,constraint,on,the,current,pattern,this,means,that,an,event,has,to,be,of,the,given,subtype,in,order,to,be,matched,param,subtype,class,class,of,the,subtype,param,s,type,of,the,subtype,return,the,same,pattern,with,the,new,subtype,constraint;public,s,extends,f,pattern,t,s,subtype,final,class,s,subtype,class,preconditions,check,not,null,subtype,class,the,class,cannot,be,null,if,condition,null,this,condition,new,subtype,condition,f,subtype,class,else,this,condition,new,and,condition,condition,new,subtype,condition,f,subtype,class,suppress,warnings,unchecked,pattern,t,s,result,pattern,t,s,this,return,result
Pattern -> public <S extends F> Pattern<T, S> subtype(final Class<S> subtypeClass);1499244360;Applies a subtype constraint on the current pattern. This means that an event has_to be of the given subtype in order to be matched.__@param subtypeClass Class of the subtype_@param <S> Type of the subtype_@return The same pattern with the new subtype constraint;public <S extends F> Pattern<T, S> subtype(final Class<S> subtypeClass) {_		Preconditions.checkNotNull(subtypeClass, "The class cannot be null.")___		if (condition == null) {_			this.condition = new SubtypeCondition<F>(subtypeClass)__		} else {_			this.condition = new AndCondition<>(condition, new SubtypeCondition<F>(subtypeClass))__		}__		@SuppressWarnings("unchecked")_		Pattern<T, S> result = (Pattern<T, S>) this___		return result__	};applies,a,subtype,constraint,on,the,current,pattern,this,means,that,an,event,has,to,be,of,the,given,subtype,in,order,to,be,matched,param,subtype,class,class,of,the,subtype,param,s,type,of,the,subtype,return,the,same,pattern,with,the,new,subtype,constraint;public,s,extends,f,pattern,t,s,subtype,final,class,s,subtype,class,preconditions,check,not,null,subtype,class,the,class,cannot,be,null,if,condition,null,this,condition,new,subtype,condition,f,subtype,class,else,this,condition,new,and,condition,condition,new,subtype,condition,f,subtype,class,suppress,warnings,unchecked,pattern,t,s,result,pattern,t,s,this,return,result
Pattern -> public <S extends F> Pattern<T, S> subtype(final Class<S> subtypeClass);1499248439;Applies a subtype constraint on the current pattern. This means that an event has_to be of the given subtype in order to be matched.__@param subtypeClass Class of the subtype_@param <S> Type of the subtype_@return The same pattern with the new subtype constraint;public <S extends F> Pattern<T, S> subtype(final Class<S> subtypeClass) {_		Preconditions.checkNotNull(subtypeClass, "The class cannot be null.")___		if (condition == null) {_			this.condition = new SubtypeCondition<F>(subtypeClass)__		} else {_			this.condition = new AndCondition<>(condition, new SubtypeCondition<F>(subtypeClass))__		}__		@SuppressWarnings("unchecked")_		Pattern<T, S> result = (Pattern<T, S>) this___		return result__	};applies,a,subtype,constraint,on,the,current,pattern,this,means,that,an,event,has,to,be,of,the,given,subtype,in,order,to,be,matched,param,subtype,class,class,of,the,subtype,param,s,type,of,the,subtype,return,the,same,pattern,with,the,new,subtype,constraint;public,s,extends,f,pattern,t,s,subtype,final,class,s,subtype,class,preconditions,check,not,null,subtype,class,the,class,cannot,be,null,if,condition,null,this,condition,new,subtype,condition,f,subtype,class,else,this,condition,new,and,condition,condition,new,subtype,condition,f,subtype,class,suppress,warnings,unchecked,pattern,t,s,result,pattern,t,s,this,return,result
Pattern -> public <S extends F> Pattern<T, S> subtype(final Class<S> subtypeClass);1503420807;Applies a subtype constraint on the current pattern. This means that an event has_to be of the given subtype in order to be matched.__@param subtypeClass Class of the subtype_@param <S> Type of the subtype_@return The same pattern with the new subtype constraint;public <S extends F> Pattern<T, S> subtype(final Class<S> subtypeClass) {_		Preconditions.checkNotNull(subtypeClass, "The class cannot be null.")___		if (condition == null) {_			this.condition = new SubtypeCondition<F>(subtypeClass)__		} else {_			this.condition = new AndCondition<>(condition, new SubtypeCondition<F>(subtypeClass))__		}__		@SuppressWarnings("unchecked")_		Pattern<T, S> result = (Pattern<T, S>) this___		return result__	};applies,a,subtype,constraint,on,the,current,pattern,this,means,that,an,event,has,to,be,of,the,given,subtype,in,order,to,be,matched,param,subtype,class,class,of,the,subtype,param,s,type,of,the,subtype,return,the,same,pattern,with,the,new,subtype,constraint;public,s,extends,f,pattern,t,s,subtype,final,class,s,subtype,class,preconditions,check,not,null,subtype,class,the,class,cannot,be,null,if,condition,null,this,condition,new,subtype,condition,f,subtype,class,else,this,condition,new,and,condition,condition,new,subtype,condition,f,subtype,class,suppress,warnings,unchecked,pattern,t,s,result,pattern,t,s,this,return,result
Pattern -> public <S extends F> Pattern<T, S> subtype(final Class<S> subtypeClass);1503558242;Applies a subtype constraint on the current pattern. This means that an event has_to be of the given subtype in order to be matched.__@param subtypeClass Class of the subtype_@param <S> Type of the subtype_@return The same pattern with the new subtype constraint;public <S extends F> Pattern<T, S> subtype(final Class<S> subtypeClass) {_		Preconditions.checkNotNull(subtypeClass, "The class cannot be null.")___		if (condition == null) {_			this.condition = new SubtypeCondition<F>(subtypeClass)__		} else {_			this.condition = new AndCondition<>(condition, new SubtypeCondition<F>(subtypeClass))__		}__		@SuppressWarnings("unchecked")_		Pattern<T, S> result = (Pattern<T, S>) this___		return result__	};applies,a,subtype,constraint,on,the,current,pattern,this,means,that,an,event,has,to,be,of,the,given,subtype,in,order,to,be,matched,param,subtype,class,class,of,the,subtype,param,s,type,of,the,subtype,return,the,same,pattern,with,the,new,subtype,constraint;public,s,extends,f,pattern,t,s,subtype,final,class,s,subtype,class,preconditions,check,not,null,subtype,class,the,class,cannot,be,null,if,condition,null,this,condition,new,subtype,condition,f,subtype,class,else,this,condition,new,and,condition,condition,new,subtype,condition,f,subtype,class,suppress,warnings,unchecked,pattern,t,s,result,pattern,t,s,this,return,result
Pattern -> public <S extends F> Pattern<T, S> subtype(final Class<S> subtypeClass);1504268438;Applies a subtype constraint on the current pattern. This means that an event has_to be of the given subtype in order to be matched.__@param subtypeClass Class of the subtype_@param <S> Type of the subtype_@return The same pattern with the new subtype constraint;public <S extends F> Pattern<T, S> subtype(final Class<S> subtypeClass) {_		Preconditions.checkNotNull(subtypeClass, "The class cannot be null.")___		if (condition == null) {_			this.condition = new SubtypeCondition<F>(subtypeClass)__		} else {_			this.condition = new AndCondition<>(condition, new SubtypeCondition<F>(subtypeClass))__		}__		@SuppressWarnings("unchecked")_		Pattern<T, S> result = (Pattern<T, S>) this___		return result__	};applies,a,subtype,constraint,on,the,current,pattern,this,means,that,an,event,has,to,be,of,the,given,subtype,in,order,to,be,matched,param,subtype,class,class,of,the,subtype,param,s,type,of,the,subtype,return,the,same,pattern,with,the,new,subtype,constraint;public,s,extends,f,pattern,t,s,subtype,final,class,s,subtype,class,preconditions,check,not,null,subtype,class,the,class,cannot,be,null,if,condition,null,this,condition,new,subtype,condition,f,subtype,class,else,this,condition,new,and,condition,condition,new,subtype,condition,f,subtype,class,suppress,warnings,unchecked,pattern,t,s,result,pattern,t,s,this,return,result
Pattern -> public <S extends F> Pattern<T, S> subtype(final Class<S> subtypeClass);1530798894;Applies a subtype constraint on the current pattern. This means that an event has_to be of the given subtype in order to be matched.__@param subtypeClass Class of the subtype_@param <S> Type of the subtype_@return The same pattern with the new subtype constraint;public <S extends F> Pattern<T, S> subtype(final Class<S> subtypeClass) {_		Preconditions.checkNotNull(subtypeClass, "The class cannot be null.")___		if (condition == null) {_			this.condition = new SubtypeCondition<F>(subtypeClass)__		} else {_			this.condition = new AndCondition<>(condition, new SubtypeCondition<F>(subtypeClass))__		}__		@SuppressWarnings("unchecked")_		Pattern<T, S> result = (Pattern<T, S>) this___		return result__	};applies,a,subtype,constraint,on,the,current,pattern,this,means,that,an,event,has,to,be,of,the,given,subtype,in,order,to,be,matched,param,subtype,class,class,of,the,subtype,param,s,type,of,the,subtype,return,the,same,pattern,with,the,new,subtype,constraint;public,s,extends,f,pattern,t,s,subtype,final,class,s,subtype,class,preconditions,check,not,null,subtype,class,the,class,cannot,be,null,if,condition,null,this,condition,new,subtype,condition,f,subtype,class,else,this,condition,new,and,condition,condition,new,subtype,condition,f,subtype,class,suppress,warnings,unchecked,pattern,t,s,result,pattern,t,s,this,return,result
Pattern -> public <S extends F> Pattern<T, S> subtype(final Class<S> subtypeClass);1540208358;Applies a subtype constraint on the current pattern. This means that an event has_to be of the given subtype in order to be matched.__@param subtypeClass Class of the subtype_@param <S> Type of the subtype_@return The same pattern with the new subtype constraint;public <S extends F> Pattern<T, S> subtype(final Class<S> subtypeClass) {_		Preconditions.checkNotNull(subtypeClass, "The class cannot be null.")___		if (condition == null) {_			this.condition = new SubtypeCondition<F>(subtypeClass)__		} else {_			this.condition = new AndCondition<>(condition, new SubtypeCondition<F>(subtypeClass))__		}__		@SuppressWarnings("unchecked")_		Pattern<T, S> result = (Pattern<T, S>) this___		return result__	};applies,a,subtype,constraint,on,the,current,pattern,this,means,that,an,event,has,to,be,of,the,given,subtype,in,order,to,be,matched,param,subtype,class,class,of,the,subtype,param,s,type,of,the,subtype,return,the,same,pattern,with,the,new,subtype,constraint;public,s,extends,f,pattern,t,s,subtype,final,class,s,subtype,class,preconditions,check,not,null,subtype,class,the,class,cannot,be,null,if,condition,null,this,condition,new,subtype,condition,f,subtype,class,else,this,condition,new,and,condition,condition,new,subtype,condition,f,subtype,class,suppress,warnings,unchecked,pattern,t,s,result,pattern,t,s,this,return,result
Pattern -> public <S extends F> Pattern<T, S> subtype(final Class<S> subtypeClass);1543413704;Applies a subtype constraint on the current pattern. This means that an event has_to be of the given subtype in order to be matched.__@param subtypeClass Class of the subtype_@param <S> Type of the subtype_@return The same pattern with the new subtype constraint;public <S extends F> Pattern<T, S> subtype(final Class<S> subtypeClass) {_		Preconditions.checkNotNull(subtypeClass, "The class cannot be null.")___		if (condition == null) {_			this.condition = new SubtypeCondition<F>(subtypeClass)__		} else {_			this.condition = new RichAndCondition<>(condition, new SubtypeCondition<F>(subtypeClass))__		}__		@SuppressWarnings("unchecked")_		Pattern<T, S> result = (Pattern<T, S>) this___		return result__	};applies,a,subtype,constraint,on,the,current,pattern,this,means,that,an,event,has,to,be,of,the,given,subtype,in,order,to,be,matched,param,subtype,class,class,of,the,subtype,param,s,type,of,the,subtype,return,the,same,pattern,with,the,new,subtype,constraint;public,s,extends,f,pattern,t,s,subtype,final,class,s,subtype,class,preconditions,check,not,null,subtype,class,the,class,cannot,be,null,if,condition,null,this,condition,new,subtype,condition,f,subtype,class,else,this,condition,new,rich,and,condition,condition,new,subtype,condition,f,subtype,class,suppress,warnings,unchecked,pattern,t,s,result,pattern,t,s,this,return,result
Pattern -> public Pattern<T, F> oneOrMore(final boolean eager);1490262475;Specifies that this pattern can occur one or more times(kleene star)._This means at least one and at most infinite number of events can be matched in this state.__If eagerness is enabled for a pattern A+B and sequence A1 A2 B will generate patterns:_A1 B and A1 A2 B. If disabled A1 B, A2 B and A1 A2 B.__@param eager if true the pattern always consumes earlier events_@return The same pattern with applied Kleene plus operator__@throws MalformedPatternException if quantifier already applied;public Pattern<T, F> oneOrMore(final boolean eager) {_		checkIfQuantifierApplied()__		if (eager) {_			this.quantifier = Quantifier.ONE_OR_MORE_EAGER__		} else {_			this.quantifier = Quantifier.ONE_OR_MORE_COMBINATIONS__		}_		return this__	};specifies,that,this,pattern,can,occur,one,or,more,times,kleene,star,this,means,at,least,one,and,at,most,infinite,number,of,events,can,be,matched,in,this,state,if,eagerness,is,enabled,for,a,pattern,a,b,and,sequence,a1,a2,b,will,generate,patterns,a1,b,and,a1,a2,b,if,disabled,a1,b,a2,b,and,a1,a2,b,param,eager,if,true,the,pattern,always,consumes,earlier,events,return,the,same,pattern,with,applied,kleene,plus,operator,throws,malformed,pattern,exception,if,quantifier,already,applied;public,pattern,t,f,one,or,more,final,boolean,eager,check,if,quantifier,applied,if,eager,this,quantifier,quantifier,else,this,quantifier,quantifier,return,this
Pattern -> public Pattern<T, F> oneOrMore(final boolean eager);1490638274;Specifies that this pattern can occur one or more times(kleene star)._This means at least one and at most infinite number of events can be matched in this state.__If eagerness is enabled for a pattern A+B and sequence A1 A2 B will generate patterns:_A1 B and A1 A2 B. If disabled A1 B, A2 B and A1 A2 B.__@param eager if true the pattern always consumes earlier events_@return The same pattern with applied Kleene plus operator__@throws MalformedPatternException if quantifier already applied;public Pattern<T, F> oneOrMore(final boolean eager) {_		checkIfQuantifierApplied()__		if (eager) {_			this.quantifier = Quantifier.ONE_OR_MORE_EAGER__		} else {_			this.quantifier = Quantifier.ONE_OR_MORE_COMBINATIONS__		}_		return this__	};specifies,that,this,pattern,can,occur,one,or,more,times,kleene,star,this,means,at,least,one,and,at,most,infinite,number,of,events,can,be,matched,in,this,state,if,eagerness,is,enabled,for,a,pattern,a,b,and,sequence,a1,a2,b,will,generate,patterns,a1,b,and,a1,a2,b,if,disabled,a1,b,a2,b,and,a1,a2,b,param,eager,if,true,the,pattern,always,consumes,earlier,events,return,the,same,pattern,with,applied,kleene,plus,operator,throws,malformed,pattern,exception,if,quantifier,already,applied;public,pattern,t,f,one,or,more,final,boolean,eager,check,if,quantifier,applied,if,eager,this,quantifier,quantifier,else,this,quantifier,quantifier,return,this
Pattern -> public Pattern<T, F> oneOrMore(final boolean eager);1490862259;Specifies that this pattern can occur one or more times(kleene star)._This means at least one and at most infinite number of events can be matched in this state.__If eagerness is enabled for a pattern A+B and sequence A1 A2 B will generate patterns:_A1 B and A1 A2 B. If disabled A1 B, A2 B and A1 A2 B.__@param eager if true the pattern always consumes earlier events_@return The same pattern with applied Kleene plus operator__@throws MalformedPatternException if quantifier already applied;public Pattern<T, F> oneOrMore(final boolean eager) {_		checkIfQuantifierApplied()__		if (eager) {_			this.quantifier = Quantifier.ONE_OR_MORE_EAGER__		} else {_			this.quantifier = Quantifier.ONE_OR_MORE_COMBINATIONS__		}_		return this__	};specifies,that,this,pattern,can,occur,one,or,more,times,kleene,star,this,means,at,least,one,and,at,most,infinite,number,of,events,can,be,matched,in,this,state,if,eagerness,is,enabled,for,a,pattern,a,b,and,sequence,a1,a2,b,will,generate,patterns,a1,b,and,a1,a2,b,if,disabled,a1,b,a2,b,and,a1,a2,b,param,eager,if,true,the,pattern,always,consumes,earlier,events,return,the,same,pattern,with,applied,kleene,plus,operator,throws,malformed,pattern,exception,if,quantifier,already,applied;public,pattern,t,f,one,or,more,final,boolean,eager,check,if,quantifier,applied,if,eager,this,quantifier,quantifier,else,this,quantifier,quantifier,return,this
Pattern -> public Pattern<T, F> oneOrMore(final boolean eager);1491647251;Specifies that this pattern can occur one or more times(kleene star)._This means at least one and at most infinite number of events can be matched in this state.__If eagerness is enabled for a pattern A+B and sequence A1 A2 B will generate patterns:_A1 B and A1 A2 B. If disabled A1 B, A2 B and A1 A2 B.__@param eager if true the pattern always consumes earlier events_@return The same pattern with applied Kleene plus operator__@throws MalformedPatternException if quantifier already applied;public Pattern<T, F> oneOrMore(final boolean eager) {_		checkIfQuantifierApplied()__		if (eager) {_			this.quantifier = Quantifier.ONE_OR_MORE_EAGER__		} else {_			this.quantifier = Quantifier.ONE_OR_MORE_COMBINATIONS__		}_		return this__	};specifies,that,this,pattern,can,occur,one,or,more,times,kleene,star,this,means,at,least,one,and,at,most,infinite,number,of,events,can,be,matched,in,this,state,if,eagerness,is,enabled,for,a,pattern,a,b,and,sequence,a1,a2,b,will,generate,patterns,a1,b,and,a1,a2,b,if,disabled,a1,b,a2,b,and,a1,a2,b,param,eager,if,true,the,pattern,always,consumes,earlier,events,return,the,same,pattern,with,applied,kleene,plus,operator,throws,malformed,pattern,exception,if,quantifier,already,applied;public,pattern,t,f,one,or,more,final,boolean,eager,check,if,quantifier,applied,if,eager,this,quantifier,quantifier,else,this,quantifier,quantifier,return,this
Pattern -> public GroupPattern<T, F> followedBy(Pattern<T, F> group);1499244360;Appends a new group pattern to the existing one. The new pattern enforces non-strict_temporal contiguity. This means that a matching event of this pattern and the_preceding matching event might be interleaved with other events which are ignored.__@param group the pattern to append_@return A new pattern which is appended to this one;public GroupPattern<T, F> followedBy(Pattern<T, F> group) {_		return new GroupPattern<>(this, group, ConsumingStrategy.SKIP_TILL_NEXT)__	};appends,a,new,group,pattern,to,the,existing,one,the,new,pattern,enforces,non,strict,temporal,contiguity,this,means,that,a,matching,event,of,this,pattern,and,the,preceding,matching,event,might,be,interleaved,with,other,events,which,are,ignored,param,group,the,pattern,to,append,return,a,new,pattern,which,is,appended,to,this,one;public,group,pattern,t,f,followed,by,pattern,t,f,group,return,new,group,pattern,this,group,consuming,strategy
Pattern -> public GroupPattern<T, F> followedBy(Pattern<T, F> group);1499248439;Appends a new group pattern to the existing one. The new pattern enforces non-strict_temporal contiguity. This means that a matching event of this pattern and the_preceding matching event might be interleaved with other events which are ignored.__@param group the pattern to append_@return A new pattern which is appended to this one;public GroupPattern<T, F> followedBy(Pattern<T, F> group) {_		return new GroupPattern<>(this, group, ConsumingStrategy.SKIP_TILL_NEXT)__	};appends,a,new,group,pattern,to,the,existing,one,the,new,pattern,enforces,non,strict,temporal,contiguity,this,means,that,a,matching,event,of,this,pattern,and,the,preceding,matching,event,might,be,interleaved,with,other,events,which,are,ignored,param,group,the,pattern,to,append,return,a,new,pattern,which,is,appended,to,this,one;public,group,pattern,t,f,followed,by,pattern,t,f,group,return,new,group,pattern,this,group,consuming,strategy
Pattern -> public GroupPattern<T, F> followedBy(Pattern<T, F> group);1503420807;Appends a new group pattern to the existing one. The new pattern enforces non-strict_temporal contiguity. This means that a matching event of this pattern and the_preceding matching event might be interleaved with other events which are ignored.__@param group the pattern to append_@return A new pattern which is appended to this one;public GroupPattern<T, F> followedBy(Pattern<T, F> group) {_		return new GroupPattern<>(this, group, ConsumingStrategy.SKIP_TILL_NEXT)__	};appends,a,new,group,pattern,to,the,existing,one,the,new,pattern,enforces,non,strict,temporal,contiguity,this,means,that,a,matching,event,of,this,pattern,and,the,preceding,matching,event,might,be,interleaved,with,other,events,which,are,ignored,param,group,the,pattern,to,append,return,a,new,pattern,which,is,appended,to,this,one;public,group,pattern,t,f,followed,by,pattern,t,f,group,return,new,group,pattern,this,group,consuming,strategy
Pattern -> public GroupPattern<T, F> followedBy(Pattern<T, F> group);1503558242;Appends a new group pattern to the existing one. The new pattern enforces non-strict_temporal contiguity. This means that a matching event of this pattern and the_preceding matching event might be interleaved with other events which are ignored.__@param group the pattern to append_@return A new pattern which is appended to this one;public GroupPattern<T, F> followedBy(Pattern<T, F> group) {_		return new GroupPattern<>(this, group, ConsumingStrategy.SKIP_TILL_NEXT)__	};appends,a,new,group,pattern,to,the,existing,one,the,new,pattern,enforces,non,strict,temporal,contiguity,this,means,that,a,matching,event,of,this,pattern,and,the,preceding,matching,event,might,be,interleaved,with,other,events,which,are,ignored,param,group,the,pattern,to,append,return,a,new,pattern,which,is,appended,to,this,one;public,group,pattern,t,f,followed,by,pattern,t,f,group,return,new,group,pattern,this,group,consuming,strategy
Pattern -> public GroupPattern<T, F> followedBy(Pattern<T, F> group);1504268438;Appends a new group pattern to the existing one. The new pattern enforces non-strict_temporal contiguity. This means that a matching event of this pattern and the_preceding matching event might be interleaved with other events which are ignored.__@param group the pattern to append_@return A new pattern which is appended to this one;public GroupPattern<T, F> followedBy(Pattern<T, F> group) {_		return new GroupPattern<>(this, group, ConsumingStrategy.SKIP_TILL_NEXT, afterMatchSkipStrategy)__	};appends,a,new,group,pattern,to,the,existing,one,the,new,pattern,enforces,non,strict,temporal,contiguity,this,means,that,a,matching,event,of,this,pattern,and,the,preceding,matching,event,might,be,interleaved,with,other,events,which,are,ignored,param,group,the,pattern,to,append,return,a,new,pattern,which,is,appended,to,this,one;public,group,pattern,t,f,followed,by,pattern,t,f,group,return,new,group,pattern,this,group,consuming,strategy,after,match,skip,strategy
Pattern -> public GroupPattern<T, F> followedBy(Pattern<T, F> group);1530798894;Appends a new group pattern to the existing one. The new pattern enforces non-strict_temporal contiguity. This means that a matching event of this pattern and the_preceding matching event might be interleaved with other events which are ignored.__@param group the pattern to append_@return A new pattern which is appended to this one;public GroupPattern<T, F> followedBy(Pattern<T, F> group) {_		return new GroupPattern<>(this, group, ConsumingStrategy.SKIP_TILL_NEXT, afterMatchSkipStrategy)__	};appends,a,new,group,pattern,to,the,existing,one,the,new,pattern,enforces,non,strict,temporal,contiguity,this,means,that,a,matching,event,of,this,pattern,and,the,preceding,matching,event,might,be,interleaved,with,other,events,which,are,ignored,param,group,the,pattern,to,append,return,a,new,pattern,which,is,appended,to,this,one;public,group,pattern,t,f,followed,by,pattern,t,f,group,return,new,group,pattern,this,group,consuming,strategy,after,match,skip,strategy
Pattern -> public GroupPattern<T, F> followedBy(Pattern<T, F> group);1540208358;Appends a new group pattern to the existing one. The new pattern enforces non-strict_temporal contiguity. This means that a matching event of this pattern and the_preceding matching event might be interleaved with other events which are ignored.__@param group the pattern to append_@return A new pattern which is appended to this one;public GroupPattern<T, F> followedBy(Pattern<T, F> group) {_		return new GroupPattern<>(this, group, ConsumingStrategy.SKIP_TILL_NEXT, afterMatchSkipStrategy)__	};appends,a,new,group,pattern,to,the,existing,one,the,new,pattern,enforces,non,strict,temporal,contiguity,this,means,that,a,matching,event,of,this,pattern,and,the,preceding,matching,event,might,be,interleaved,with,other,events,which,are,ignored,param,group,the,pattern,to,append,return,a,new,pattern,which,is,appended,to,this,one;public,group,pattern,t,f,followed,by,pattern,t,f,group,return,new,group,pattern,this,group,consuming,strategy,after,match,skip,strategy
Pattern -> public GroupPattern<T, F> followedBy(Pattern<T, F> group);1543413704;Appends a new group pattern to the existing one. The new pattern enforces non-strict_temporal contiguity. This means that a matching event of this pattern and the_preceding matching event might be interleaved with other events which are ignored.__@param group the pattern to append_@return A new pattern which is appended to this one;public GroupPattern<T, F> followedBy(Pattern<T, F> group) {_		return new GroupPattern<>(this, group, ConsumingStrategy.SKIP_TILL_NEXT, afterMatchSkipStrategy)__	};appends,a,new,group,pattern,to,the,existing,one,the,new,pattern,enforces,non,strict,temporal,contiguity,this,means,that,a,matching,event,of,this,pattern,and,the,preceding,matching,event,might,be,interleaved,with,other,events,which,are,ignored,param,group,the,pattern,to,append,return,a,new,pattern,which,is,appended,to,this,one;public,group,pattern,t,f,followed,by,pattern,t,f,group,return,new,group,pattern,this,group,consuming,strategy,after,match,skip,strategy
Pattern -> public GroupPattern<T, F> followedByAny(Pattern<T, F> group);1499244360;Appends a new group pattern to the existing one. The new pattern enforces non-strict_temporal contiguity. This means that a matching event of this pattern and the_preceding matching event might be interleaved with other events which are ignored.__@param group the pattern to append_@return A new pattern which is appended to this one;public GroupPattern<T, F> followedByAny(Pattern<T, F> group) {_		return new GroupPattern<>(this, group, ConsumingStrategy.SKIP_TILL_ANY)__	};appends,a,new,group,pattern,to,the,existing,one,the,new,pattern,enforces,non,strict,temporal,contiguity,this,means,that,a,matching,event,of,this,pattern,and,the,preceding,matching,event,might,be,interleaved,with,other,events,which,are,ignored,param,group,the,pattern,to,append,return,a,new,pattern,which,is,appended,to,this,one;public,group,pattern,t,f,followed,by,any,pattern,t,f,group,return,new,group,pattern,this,group,consuming,strategy
Pattern -> public GroupPattern<T, F> followedByAny(Pattern<T, F> group);1499248439;Appends a new group pattern to the existing one. The new pattern enforces non-strict_temporal contiguity. This means that a matching event of this pattern and the_preceding matching event might be interleaved with other events which are ignored.__@param group the pattern to append_@return A new pattern which is appended to this one;public GroupPattern<T, F> followedByAny(Pattern<T, F> group) {_		return new GroupPattern<>(this, group, ConsumingStrategy.SKIP_TILL_ANY)__	};appends,a,new,group,pattern,to,the,existing,one,the,new,pattern,enforces,non,strict,temporal,contiguity,this,means,that,a,matching,event,of,this,pattern,and,the,preceding,matching,event,might,be,interleaved,with,other,events,which,are,ignored,param,group,the,pattern,to,append,return,a,new,pattern,which,is,appended,to,this,one;public,group,pattern,t,f,followed,by,any,pattern,t,f,group,return,new,group,pattern,this,group,consuming,strategy
Pattern -> public GroupPattern<T, F> followedByAny(Pattern<T, F> group);1503420807;Appends a new group pattern to the existing one. The new pattern enforces non-strict_temporal contiguity. This means that a matching event of this pattern and the_preceding matching event might be interleaved with other events which are ignored.__@param group the pattern to append_@return A new pattern which is appended to this one;public GroupPattern<T, F> followedByAny(Pattern<T, F> group) {_		return new GroupPattern<>(this, group, ConsumingStrategy.SKIP_TILL_ANY)__	};appends,a,new,group,pattern,to,the,existing,one,the,new,pattern,enforces,non,strict,temporal,contiguity,this,means,that,a,matching,event,of,this,pattern,and,the,preceding,matching,event,might,be,interleaved,with,other,events,which,are,ignored,param,group,the,pattern,to,append,return,a,new,pattern,which,is,appended,to,this,one;public,group,pattern,t,f,followed,by,any,pattern,t,f,group,return,new,group,pattern,this,group,consuming,strategy
Pattern -> public GroupPattern<T, F> followedByAny(Pattern<T, F> group);1503558242;Appends a new group pattern to the existing one. The new pattern enforces non-strict_temporal contiguity. This means that a matching event of this pattern and the_preceding matching event might be interleaved with other events which are ignored.__@param group the pattern to append_@return A new pattern which is appended to this one;public GroupPattern<T, F> followedByAny(Pattern<T, F> group) {_		return new GroupPattern<>(this, group, ConsumingStrategy.SKIP_TILL_ANY)__	};appends,a,new,group,pattern,to,the,existing,one,the,new,pattern,enforces,non,strict,temporal,contiguity,this,means,that,a,matching,event,of,this,pattern,and,the,preceding,matching,event,might,be,interleaved,with,other,events,which,are,ignored,param,group,the,pattern,to,append,return,a,new,pattern,which,is,appended,to,this,one;public,group,pattern,t,f,followed,by,any,pattern,t,f,group,return,new,group,pattern,this,group,consuming,strategy
Pattern -> public GroupPattern<T, F> followedByAny(Pattern<T, F> group);1504268438;Appends a new group pattern to the existing one. The new pattern enforces non-strict_temporal contiguity. This means that a matching event of this pattern and the_preceding matching event might be interleaved with other events which are ignored.__@param group the pattern to append_@return A new pattern which is appended to this one;public GroupPattern<T, F> followedByAny(Pattern<T, F> group) {_		return new GroupPattern<>(this, group, ConsumingStrategy.SKIP_TILL_ANY, afterMatchSkipStrategy)__	};appends,a,new,group,pattern,to,the,existing,one,the,new,pattern,enforces,non,strict,temporal,contiguity,this,means,that,a,matching,event,of,this,pattern,and,the,preceding,matching,event,might,be,interleaved,with,other,events,which,are,ignored,param,group,the,pattern,to,append,return,a,new,pattern,which,is,appended,to,this,one;public,group,pattern,t,f,followed,by,any,pattern,t,f,group,return,new,group,pattern,this,group,consuming,strategy,after,match,skip,strategy
Pattern -> public GroupPattern<T, F> followedByAny(Pattern<T, F> group);1530798894;Appends a new group pattern to the existing one. The new pattern enforces non-strict_temporal contiguity. This means that a matching event of this pattern and the_preceding matching event might be interleaved with other events which are ignored.__@param group the pattern to append_@return A new pattern which is appended to this one;public GroupPattern<T, F> followedByAny(Pattern<T, F> group) {_		return new GroupPattern<>(this, group, ConsumingStrategy.SKIP_TILL_ANY, afterMatchSkipStrategy)__	};appends,a,new,group,pattern,to,the,existing,one,the,new,pattern,enforces,non,strict,temporal,contiguity,this,means,that,a,matching,event,of,this,pattern,and,the,preceding,matching,event,might,be,interleaved,with,other,events,which,are,ignored,param,group,the,pattern,to,append,return,a,new,pattern,which,is,appended,to,this,one;public,group,pattern,t,f,followed,by,any,pattern,t,f,group,return,new,group,pattern,this,group,consuming,strategy,after,match,skip,strategy
Pattern -> public GroupPattern<T, F> followedByAny(Pattern<T, F> group);1540208358;Appends a new group pattern to the existing one. The new pattern enforces non-strict_temporal contiguity. This means that a matching event of this pattern and the_preceding matching event might be interleaved with other events which are ignored.__@param group the pattern to append_@return A new pattern which is appended to this one;public GroupPattern<T, F> followedByAny(Pattern<T, F> group) {_		return new GroupPattern<>(this, group, ConsumingStrategy.SKIP_TILL_ANY, afterMatchSkipStrategy)__	};appends,a,new,group,pattern,to,the,existing,one,the,new,pattern,enforces,non,strict,temporal,contiguity,this,means,that,a,matching,event,of,this,pattern,and,the,preceding,matching,event,might,be,interleaved,with,other,events,which,are,ignored,param,group,the,pattern,to,append,return,a,new,pattern,which,is,appended,to,this,one;public,group,pattern,t,f,followed,by,any,pattern,t,f,group,return,new,group,pattern,this,group,consuming,strategy,after,match,skip,strategy
Pattern -> public GroupPattern<T, F> followedByAny(Pattern<T, F> group);1543413704;Appends a new group pattern to the existing one. The new pattern enforces non-strict_temporal contiguity. This means that a matching event of this pattern and the_preceding matching event might be interleaved with other events which are ignored.__@param group the pattern to append_@return A new pattern which is appended to this one;public GroupPattern<T, F> followedByAny(Pattern<T, F> group) {_		return new GroupPattern<>(this, group, ConsumingStrategy.SKIP_TILL_ANY, afterMatchSkipStrategy)__	};appends,a,new,group,pattern,to,the,existing,one,the,new,pattern,enforces,non,strict,temporal,contiguity,this,means,that,a,matching,event,of,this,pattern,and,the,preceding,matching,event,might,be,interleaved,with,other,events,which,are,ignored,param,group,the,pattern,to,append,return,a,new,pattern,which,is,appended,to,this,one;public,group,pattern,t,f,followed,by,any,pattern,t,f,group,return,new,group,pattern,this,group,consuming,strategy,after,match,skip,strategy
Pattern -> public FollowedByPattern<T, T> followedBy(final String name);1454421848;Appends a new pattern operator to the existing one. The new pattern operator enforces_non-strict temporal contiguity. This means that a matching event of this operator and the_preceding matching event might be interleaved with other events which are ignored.__@param name Name of the new pattern operator_@return A new pattern operator which is appended to this pattern operator;public FollowedByPattern<T, T> followedBy(final String name) {_		return new FollowedByPattern<T, T>(name, this)__	};appends,a,new,pattern,operator,to,the,existing,one,the,new,pattern,operator,enforces,non,strict,temporal,contiguity,this,means,that,a,matching,event,of,this,operator,and,the,preceding,matching,event,might,be,interleaved,with,other,events,which,are,ignored,param,name,name,of,the,new,pattern,operator,return,a,new,pattern,operator,which,is,appended,to,this,pattern,operator;public,followed,by,pattern,t,t,followed,by,final,string,name,return,new,followed,by,pattern,t,t,name,this
Pattern -> public FollowedByPattern<T, T> followedBy(final String name);1456442894;Appends a new pattern operator to the existing one. The new pattern operator enforces_non-strict temporal contiguity. This means that a matching event of this operator and the_preceding matching event might be interleaved with other events which are ignored.__@param name Name of the new pattern operator_@return A new pattern operator which is appended to this pattern operator;public FollowedByPattern<T, T> followedBy(final String name) {_		return new FollowedByPattern<T, T>(name, this)__	};appends,a,new,pattern,operator,to,the,existing,one,the,new,pattern,operator,enforces,non,strict,temporal,contiguity,this,means,that,a,matching,event,of,this,operator,and,the,preceding,matching,event,might,be,interleaved,with,other,events,which,are,ignored,param,name,name,of,the,new,pattern,operator,return,a,new,pattern,operator,which,is,appended,to,this,pattern,operator;public,followed,by,pattern,t,t,followed,by,final,string,name,return,new,followed,by,pattern,t,t,name,this
Pattern -> public FollowedByPattern<T, T> followedBy(final String name);1461689259;Appends a new pattern operator to the existing one. The new pattern operator enforces_non-strict temporal contiguity. This means that a matching event of this operator and the_preceding matching event might be interleaved with other events which are ignored.__@param name Name of the new pattern operator_@return A new pattern operator which is appended to this pattern operator;public FollowedByPattern<T, T> followedBy(final String name) {_		return new FollowedByPattern<T, T>(name, this)__	};appends,a,new,pattern,operator,to,the,existing,one,the,new,pattern,operator,enforces,non,strict,temporal,contiguity,this,means,that,a,matching,event,of,this,operator,and,the,preceding,matching,event,might,be,interleaved,with,other,events,which,are,ignored,param,name,name,of,the,new,pattern,operator,return,a,new,pattern,operator,which,is,appended,to,this,pattern,operator;public,followed,by,pattern,t,t,followed,by,final,string,name,return,new,followed,by,pattern,t,t,name,this
Pattern -> public FollowedByPattern<T, T> followedBy(final String name);1471613162;Appends a new pattern operator to the existing one. The new pattern operator enforces_non-strict temporal contiguity. This means that a matching event of this operator and the_preceding matching event might be interleaved with other events which are ignored.__@param name Name of the new pattern operator_@return A new pattern operator which is appended to this pattern operator;public FollowedByPattern<T, T> followedBy(final String name) {_		return new FollowedByPattern<T, T>(name, this)__	};appends,a,new,pattern,operator,to,the,existing,one,the,new,pattern,operator,enforces,non,strict,temporal,contiguity,this,means,that,a,matching,event,of,this,operator,and,the,preceding,matching,event,might,be,interleaved,with,other,events,which,are,ignored,param,name,name,of,the,new,pattern,operator,return,a,new,pattern,operator,which,is,appended,to,this,pattern,operator;public,followed,by,pattern,t,t,followed,by,final,string,name,return,new,followed,by,pattern,t,t,name,this
Pattern -> public FollowedByPattern<T, T> followedBy(final String name);1471614454;Appends a new pattern operator to the existing one. The new pattern operator enforces_non-strict temporal contiguity. This means that a matching event of this operator and the_preceding matching event might be interleaved with other events which are ignored.__@param name Name of the new pattern operator_@return A new pattern operator which is appended to this pattern operator;public FollowedByPattern<T, T> followedBy(final String name) {_		return new FollowedByPattern<T, T>(name, this)__	};appends,a,new,pattern,operator,to,the,existing,one,the,new,pattern,operator,enforces,non,strict,temporal,contiguity,this,means,that,a,matching,event,of,this,operator,and,the,preceding,matching,event,might,be,interleaved,with,other,events,which,are,ignored,param,name,name,of,the,new,pattern,operator,return,a,new,pattern,operator,which,is,appended,to,this,pattern,operator;public,followed,by,pattern,t,t,followed,by,final,string,name,return,new,followed,by,pattern,t,t,name,this
Pattern -> public FollowedByPattern<T, T> followedBy(final String name);1488270949;Appends a new pattern operator to the existing one. The new pattern operator enforces_non-strict temporal contiguity. This means that a matching event of this operator and the_preceding matching event might be interleaved with other events which are ignored.__@param name Name of the new pattern operator_@return A new pattern operator which is appended to this pattern operator;public FollowedByPattern<T, T> followedBy(final String name) {_		return new FollowedByPattern<T, T>(name, this)__	};appends,a,new,pattern,operator,to,the,existing,one,the,new,pattern,operator,enforces,non,strict,temporal,contiguity,this,means,that,a,matching,event,of,this,operator,and,the,preceding,matching,event,might,be,interleaved,with,other,events,which,are,ignored,param,name,name,of,the,new,pattern,operator,return,a,new,pattern,operator,which,is,appended,to,this,pattern,operator;public,followed,by,pattern,t,t,followed,by,final,string,name,return,new,followed,by,pattern,t,t,name,this
Pattern -> public FollowedByPattern<T, T> followedBy(final String name);1490262475;Appends a new pattern operator to the existing one. The new pattern operator enforces_non-strict temporal contiguity. This means that a matching event of this operator and the_preceding matching event might be interleaved with other events which are ignored.__@param name Name of the new pattern operator_@return A new pattern operator which is appended to this pattern operator;public FollowedByPattern<T, T> followedBy(final String name) {_		return new FollowedByPattern<T, T>(name, this)__	};appends,a,new,pattern,operator,to,the,existing,one,the,new,pattern,operator,enforces,non,strict,temporal,contiguity,this,means,that,a,matching,event,of,this,operator,and,the,preceding,matching,event,might,be,interleaved,with,other,events,which,are,ignored,param,name,name,of,the,new,pattern,operator,return,a,new,pattern,operator,which,is,appended,to,this,pattern,operator;public,followed,by,pattern,t,t,followed,by,final,string,name,return,new,followed,by,pattern,t,t,name,this
Pattern -> public FollowedByPattern<T, T> followedBy(final String name);1490638274;Appends a new pattern operator to the existing one. The new pattern operator enforces_non-strict temporal contiguity. This means that a matching event of this operator and the_preceding matching event might be interleaved with other events which are ignored.__@param name Name of the new pattern operator_@return A new pattern operator which is appended to this pattern operator;public FollowedByPattern<T, T> followedBy(final String name) {_		return new FollowedByPattern<T, T>(name, this)__	};appends,a,new,pattern,operator,to,the,existing,one,the,new,pattern,operator,enforces,non,strict,temporal,contiguity,this,means,that,a,matching,event,of,this,operator,and,the,preceding,matching,event,might,be,interleaved,with,other,events,which,are,ignored,param,name,name,of,the,new,pattern,operator,return,a,new,pattern,operator,which,is,appended,to,this,pattern,operator;public,followed,by,pattern,t,t,followed,by,final,string,name,return,new,followed,by,pattern,t,t,name,this
Pattern -> public FollowedByPattern<T, T> followedBy(final String name);1490862259;Appends a new pattern operator to the existing one. The new pattern operator enforces_non-strict temporal contiguity. This means that a matching event of this operator and the_preceding matching event might be interleaved with other events which are ignored.__@param name Name of the new pattern operator_@return A new pattern operator which is appended to this pattern operator;public FollowedByPattern<T, T> followedBy(final String name) {_		return new FollowedByPattern<T, T>(name, this)__	};appends,a,new,pattern,operator,to,the,existing,one,the,new,pattern,operator,enforces,non,strict,temporal,contiguity,this,means,that,a,matching,event,of,this,operator,and,the,preceding,matching,event,might,be,interleaved,with,other,events,which,are,ignored,param,name,name,of,the,new,pattern,operator,return,a,new,pattern,operator,which,is,appended,to,this,pattern,operator;public,followed,by,pattern,t,t,followed,by,final,string,name,return,new,followed,by,pattern,t,t,name,this
Pattern -> public FollowedByPattern<T, T> followedBy(final String name);1491647251;Appends a new pattern operator to the existing one. The new pattern operator enforces_non-strict temporal contiguity. This means that a matching event of this operator and the_preceding matching event might be interleaved with other events which are ignored.__@param name Name of the new pattern operator_@return A new pattern operator which is appended to this pattern operator;public FollowedByPattern<T, T> followedBy(final String name) {_		return new FollowedByPattern<T, T>(name, this)__	};appends,a,new,pattern,operator,to,the,existing,one,the,new,pattern,operator,enforces,non,strict,temporal,contiguity,this,means,that,a,matching,event,of,this,operator,and,the,preceding,matching,event,might,be,interleaved,with,other,events,which,are,ignored,param,name,name,of,the,new,pattern,operator,return,a,new,pattern,operator,which,is,appended,to,this,pattern,operator;public,followed,by,pattern,t,t,followed,by,final,string,name,return,new,followed,by,pattern,t,t,name,this
Pattern -> public FollowedByPattern<T, T> followedBy(final String name);1493201751;Appends a new pattern to the existing one. The new pattern enforces non-strict_temporal contiguity. This means that a matching event of this pattern and the_preceding matching event might be interleaved with other events which are ignored.__@param name Name of the new pattern_@return A new pattern which is appended to this one;public FollowedByPattern<T, T> followedBy(final String name) {_		return new FollowedByPattern<T, T>(name, this)__	};appends,a,new,pattern,to,the,existing,one,the,new,pattern,enforces,non,strict,temporal,contiguity,this,means,that,a,matching,event,of,this,pattern,and,the,preceding,matching,event,might,be,interleaved,with,other,events,which,are,ignored,param,name,name,of,the,new,pattern,return,a,new,pattern,which,is,appended,to,this,one;public,followed,by,pattern,t,t,followed,by,final,string,name,return,new,followed,by,pattern,t,t,name,this
Pattern -> public FollowedByPattern<T, T> followedBy(final String name);1493201753;Appends a new pattern to the existing one. The new pattern enforces non-strict_temporal contiguity. This means that a matching event of this pattern and the_preceding matching event might be interleaved with other events which are ignored.__@param name Name of the new pattern_@return A new pattern which is appended to this one;public FollowedByPattern<T, T> followedBy(final String name) {_		return new FollowedByPattern<T, T>(name, this)__	};appends,a,new,pattern,to,the,existing,one,the,new,pattern,enforces,non,strict,temporal,contiguity,this,means,that,a,matching,event,of,this,pattern,and,the,preceding,matching,event,might,be,interleaved,with,other,events,which,are,ignored,param,name,name,of,the,new,pattern,return,a,new,pattern,which,is,appended,to,this,one;public,followed,by,pattern,t,t,followed,by,final,string,name,return,new,followed,by,pattern,t,t,name,this
Pattern -> public Pattern<T, T> notFollowedBy(final String name);1493985576;Appends a new pattern to the existing one. The new pattern enforces that there is no event matching this pattern_between the preceding pattern and succeeding this one.__<p><b>NOTE:</b> There has to be other pattern after this one.__@param name Name of the new pattern_@return A new pattern which is appended to this one;public Pattern<T, T> notFollowedBy(final String name) {_		if (quantifier.hasProperty(Quantifier.QuantifierProperty.OPTIONAL)) {_			throw new MalformedPatternException(_				"Specifying a pattern with an optional path to NOT condition is not supported yet. " +_				"You can simulate such pattern with two independent patterns, one with and the other without " +_				"the optional part.")__		}__		return new Pattern<>(name, this, ConsumingStrategy.NOT_FOLLOW)__	};appends,a,new,pattern,to,the,existing,one,the,new,pattern,enforces,that,there,is,no,event,matching,this,pattern,between,the,preceding,pattern,and,succeeding,this,one,p,b,note,b,there,has,to,be,other,pattern,after,this,one,param,name,name,of,the,new,pattern,return,a,new,pattern,which,is,appended,to,this,one;public,pattern,t,t,not,followed,by,final,string,name,if,quantifier,has,property,quantifier,quantifier,property,optional,throw,new,malformed,pattern,exception,specifying,a,pattern,with,an,optional,path,to,not,condition,is,not,supported,yet,you,can,simulate,such,pattern,with,two,independent,patterns,one,with,and,the,other,without,the,optional,part,return,new,pattern,name,this,consuming,strategy
Pattern -> public Pattern<T, T> notFollowedBy(final String name);1493997908;Appends a new pattern to the existing one. The new pattern enforces that there is no event matching this pattern_between the preceding pattern and succeeding this one.__<p><b>NOTE:</b> There has to be other pattern after this one.__@param name Name of the new pattern_@return A new pattern which is appended to this one;public Pattern<T, T> notFollowedBy(final String name) {_		if (quantifier.hasProperty(Quantifier.QuantifierProperty.OPTIONAL)) {_			throw new UnsupportedOperationException(_					"Specifying a pattern with an optional path to NOT condition is not supported yet. " +_					"You can simulate such pattern with two independent patterns, one with and the other without " +_					"the optional part.")__		}_		return new Pattern<>(name, this, ConsumingStrategy.NOT_FOLLOW)__	};appends,a,new,pattern,to,the,existing,one,the,new,pattern,enforces,that,there,is,no,event,matching,this,pattern,between,the,preceding,pattern,and,succeeding,this,one,p,b,note,b,there,has,to,be,other,pattern,after,this,one,param,name,name,of,the,new,pattern,return,a,new,pattern,which,is,appended,to,this,one;public,pattern,t,t,not,followed,by,final,string,name,if,quantifier,has,property,quantifier,quantifier,property,optional,throw,new,unsupported,operation,exception,specifying,a,pattern,with,an,optional,path,to,not,condition,is,not,supported,yet,you,can,simulate,such,pattern,with,two,independent,patterns,one,with,and,the,other,without,the,optional,part,return,new,pattern,name,this,consuming,strategy
Pattern -> public Pattern<T, T> notFollowedBy(final String name);1495961498;Appends a new pattern to the existing one. The new pattern enforces that there is no event matching this pattern_between the preceding pattern and succeeding this one.__<p><b>NOTE:</b> There has to be other pattern after this one.__@param name Name of the new pattern_@return A new pattern which is appended to this one;public Pattern<T, T> notFollowedBy(final String name) {_		if (quantifier.hasProperty(Quantifier.QuantifierProperty.OPTIONAL)) {_			throw new UnsupportedOperationException(_					"Specifying a pattern with an optional path to NOT condition is not supported yet. " +_					"You can simulate such pattern with two independent patterns, one with and the other without " +_					"the optional part.")__		}_		return new Pattern<>(name, this, ConsumingStrategy.NOT_FOLLOW)__	};appends,a,new,pattern,to,the,existing,one,the,new,pattern,enforces,that,there,is,no,event,matching,this,pattern,between,the,preceding,pattern,and,succeeding,this,one,p,b,note,b,there,has,to,be,other,pattern,after,this,one,param,name,name,of,the,new,pattern,return,a,new,pattern,which,is,appended,to,this,one;public,pattern,t,t,not,followed,by,final,string,name,if,quantifier,has,property,quantifier,quantifier,property,optional,throw,new,unsupported,operation,exception,specifying,a,pattern,with,an,optional,path,to,not,condition,is,not,supported,yet,you,can,simulate,such,pattern,with,two,independent,patterns,one,with,and,the,other,without,the,optional,part,return,new,pattern,name,this,consuming,strategy
Pattern -> public Pattern<T, T> notFollowedBy(final String name);1497940477;Appends a new pattern to the existing one. The new pattern enforces that there is no event matching this pattern_between the preceding pattern and succeeding this one.__<p><b>NOTE:</b> There has to be other pattern after this one.__@param name Name of the new pattern_@return A new pattern which is appended to this one;public Pattern<T, T> notFollowedBy(final String name) {_		if (quantifier.hasProperty(Quantifier.QuantifierProperty.OPTIONAL)) {_			throw new UnsupportedOperationException(_					"Specifying a pattern with an optional path to NOT condition is not supported yet. " +_					"You can simulate such pattern with two independent patterns, one with and the other without " +_					"the optional part.")__		}_		return new Pattern<>(name, this, ConsumingStrategy.NOT_FOLLOW)__	};appends,a,new,pattern,to,the,existing,one,the,new,pattern,enforces,that,there,is,no,event,matching,this,pattern,between,the,preceding,pattern,and,succeeding,this,one,p,b,note,b,there,has,to,be,other,pattern,after,this,one,param,name,name,of,the,new,pattern,return,a,new,pattern,which,is,appended,to,this,one;public,pattern,t,t,not,followed,by,final,string,name,if,quantifier,has,property,quantifier,quantifier,property,optional,throw,new,unsupported,operation,exception,specifying,a,pattern,with,an,optional,path,to,not,condition,is,not,supported,yet,you,can,simulate,such,pattern,with,two,independent,patterns,one,with,and,the,other,without,the,optional,part,return,new,pattern,name,this,consuming,strategy
Pattern -> public Pattern<T, T> notFollowedBy(final String name);1498548074;Appends a new pattern to the existing one. The new pattern enforces that there is no event matching this pattern_between the preceding pattern and succeeding this one.__<p><b>NOTE:</b> There has to be other pattern after this one.__@param name Name of the new pattern_@return A new pattern which is appended to this one;public Pattern<T, T> notFollowedBy(final String name) {_		if (quantifier.hasProperty(Quantifier.QuantifierProperty.OPTIONAL)) {_			throw new UnsupportedOperationException(_					"Specifying a pattern with an optional path to NOT condition is not supported yet. " +_					"You can simulate such pattern with two independent patterns, one with and the other without " +_					"the optional part.")__		}_		return new Pattern<>(name, this, ConsumingStrategy.NOT_FOLLOW)__	};appends,a,new,pattern,to,the,existing,one,the,new,pattern,enforces,that,there,is,no,event,matching,this,pattern,between,the,preceding,pattern,and,succeeding,this,one,p,b,note,b,there,has,to,be,other,pattern,after,this,one,param,name,name,of,the,new,pattern,return,a,new,pattern,which,is,appended,to,this,one;public,pattern,t,t,not,followed,by,final,string,name,if,quantifier,has,property,quantifier,quantifier,property,optional,throw,new,unsupported,operation,exception,specifying,a,pattern,with,an,optional,path,to,not,condition,is,not,supported,yet,you,can,simulate,such,pattern,with,two,independent,patterns,one,with,and,the,other,without,the,optional,part,return,new,pattern,name,this,consuming,strategy
Pattern -> public Pattern<T, T> notFollowedBy(final String name);1499244360;Appends a new pattern to the existing one. The new pattern enforces that there is no event matching this pattern_between the preceding pattern and succeeding this one.__<p><b>NOTE:</b> There has to be other pattern after this one.__@param name Name of the new pattern_@return A new pattern which is appended to this one;public Pattern<T, T> notFollowedBy(final String name) {_		if (quantifier.hasProperty(Quantifier.QuantifierProperty.OPTIONAL)) {_			throw new UnsupportedOperationException(_					"Specifying a pattern with an optional path to NOT condition is not supported yet. " +_					"You can simulate such pattern with two independent patterns, one with and the other without " +_					"the optional part.")__		}_		return new Pattern<>(name, this, ConsumingStrategy.NOT_FOLLOW)__	};appends,a,new,pattern,to,the,existing,one,the,new,pattern,enforces,that,there,is,no,event,matching,this,pattern,between,the,preceding,pattern,and,succeeding,this,one,p,b,note,b,there,has,to,be,other,pattern,after,this,one,param,name,name,of,the,new,pattern,return,a,new,pattern,which,is,appended,to,this,one;public,pattern,t,t,not,followed,by,final,string,name,if,quantifier,has,property,quantifier,quantifier,property,optional,throw,new,unsupported,operation,exception,specifying,a,pattern,with,an,optional,path,to,not,condition,is,not,supported,yet,you,can,simulate,such,pattern,with,two,independent,patterns,one,with,and,the,other,without,the,optional,part,return,new,pattern,name,this,consuming,strategy
Pattern -> public Pattern<T, T> notFollowedBy(final String name);1499248439;Appends a new pattern to the existing one. The new pattern enforces that there is no event matching this pattern_between the preceding pattern and succeeding this one.__<p><b>NOTE:</b> There has to be other pattern after this one.__@param name Name of the new pattern_@return A new pattern which is appended to this one;public Pattern<T, T> notFollowedBy(final String name) {_		if (quantifier.hasProperty(Quantifier.QuantifierProperty.OPTIONAL)) {_			throw new UnsupportedOperationException(_					"Specifying a pattern with an optional path to NOT condition is not supported yet. " +_					"You can simulate such pattern with two independent patterns, one with and the other without " +_					"the optional part.")__		}_		return new Pattern<>(name, this, ConsumingStrategy.NOT_FOLLOW)__	};appends,a,new,pattern,to,the,existing,one,the,new,pattern,enforces,that,there,is,no,event,matching,this,pattern,between,the,preceding,pattern,and,succeeding,this,one,p,b,note,b,there,has,to,be,other,pattern,after,this,one,param,name,name,of,the,new,pattern,return,a,new,pattern,which,is,appended,to,this,one;public,pattern,t,t,not,followed,by,final,string,name,if,quantifier,has,property,quantifier,quantifier,property,optional,throw,new,unsupported,operation,exception,specifying,a,pattern,with,an,optional,path,to,not,condition,is,not,supported,yet,you,can,simulate,such,pattern,with,two,independent,patterns,one,with,and,the,other,without,the,optional,part,return,new,pattern,name,this,consuming,strategy
Pattern -> public Pattern<T, T> notFollowedBy(final String name);1503420807;Appends a new pattern to the existing one. The new pattern enforces that there is no event matching this pattern_between the preceding pattern and succeeding this one.__<p><b>NOTE:</b> There has to be other pattern after this one.__@param name Name of the new pattern_@return A new pattern which is appended to this one;public Pattern<T, T> notFollowedBy(final String name) {_		if (quantifier.hasProperty(Quantifier.QuantifierProperty.OPTIONAL)) {_			throw new UnsupportedOperationException(_					"Specifying a pattern with an optional path to NOT condition is not supported yet. " +_					"You can simulate such pattern with two independent patterns, one with and the other without " +_					"the optional part.")__		}_		return new Pattern<>(name, this, ConsumingStrategy.NOT_FOLLOW)__	};appends,a,new,pattern,to,the,existing,one,the,new,pattern,enforces,that,there,is,no,event,matching,this,pattern,between,the,preceding,pattern,and,succeeding,this,one,p,b,note,b,there,has,to,be,other,pattern,after,this,one,param,name,name,of,the,new,pattern,return,a,new,pattern,which,is,appended,to,this,one;public,pattern,t,t,not,followed,by,final,string,name,if,quantifier,has,property,quantifier,quantifier,property,optional,throw,new,unsupported,operation,exception,specifying,a,pattern,with,an,optional,path,to,not,condition,is,not,supported,yet,you,can,simulate,such,pattern,with,two,independent,patterns,one,with,and,the,other,without,the,optional,part,return,new,pattern,name,this,consuming,strategy
Pattern -> public Pattern<T, T> notFollowedBy(final String name);1503558242;Appends a new pattern to the existing one. The new pattern enforces that there is no event matching this pattern_between the preceding pattern and succeeding this one.__<p><b>NOTE:</b> There has to be other pattern after this one.__@param name Name of the new pattern_@return A new pattern which is appended to this one;public Pattern<T, T> notFollowedBy(final String name) {_		if (quantifier.hasProperty(Quantifier.QuantifierProperty.OPTIONAL)) {_			throw new UnsupportedOperationException(_					"Specifying a pattern with an optional path to NOT condition is not supported yet. " +_					"You can simulate such pattern with two independent patterns, one with and the other without " +_					"the optional part.")__		}_		return new Pattern<>(name, this, ConsumingStrategy.NOT_FOLLOW)__	};appends,a,new,pattern,to,the,existing,one,the,new,pattern,enforces,that,there,is,no,event,matching,this,pattern,between,the,preceding,pattern,and,succeeding,this,one,p,b,note,b,there,has,to,be,other,pattern,after,this,one,param,name,name,of,the,new,pattern,return,a,new,pattern,which,is,appended,to,this,one;public,pattern,t,t,not,followed,by,final,string,name,if,quantifier,has,property,quantifier,quantifier,property,optional,throw,new,unsupported,operation,exception,specifying,a,pattern,with,an,optional,path,to,not,condition,is,not,supported,yet,you,can,simulate,such,pattern,with,two,independent,patterns,one,with,and,the,other,without,the,optional,part,return,new,pattern,name,this,consuming,strategy
Pattern -> public Pattern<T, T> notFollowedBy(final String name);1504268438;Appends a new pattern to the existing one. The new pattern enforces that there is no event matching this pattern_between the preceding pattern and succeeding this one.__<p><b>NOTE:</b> There has to be other pattern after this one.__@param name Name of the new pattern_@return A new pattern which is appended to this one;public Pattern<T, T> notFollowedBy(final String name) {_		if (quantifier.hasProperty(Quantifier.QuantifierProperty.OPTIONAL)) {_			throw new UnsupportedOperationException(_					"Specifying a pattern with an optional path to NOT condition is not supported yet. " +_					"You can simulate such pattern with two independent patterns, one with and the other without " +_					"the optional part.")__		}_		return new Pattern<>(name, this, ConsumingStrategy.NOT_FOLLOW, afterMatchSkipStrategy)__	};appends,a,new,pattern,to,the,existing,one,the,new,pattern,enforces,that,there,is,no,event,matching,this,pattern,between,the,preceding,pattern,and,succeeding,this,one,p,b,note,b,there,has,to,be,other,pattern,after,this,one,param,name,name,of,the,new,pattern,return,a,new,pattern,which,is,appended,to,this,one;public,pattern,t,t,not,followed,by,final,string,name,if,quantifier,has,property,quantifier,quantifier,property,optional,throw,new,unsupported,operation,exception,specifying,a,pattern,with,an,optional,path,to,not,condition,is,not,supported,yet,you,can,simulate,such,pattern,with,two,independent,patterns,one,with,and,the,other,without,the,optional,part,return,new,pattern,name,this,consuming,strategy,after,match,skip,strategy
Pattern -> public Pattern<T, T> notFollowedBy(final String name);1530798894;Appends a new pattern to the existing one. The new pattern enforces that there is no event matching this pattern_between the preceding pattern and succeeding this one.__<p><b>NOTE:</b> There has to be other pattern after this one.__@param name Name of the new pattern_@return A new pattern which is appended to this one;public Pattern<T, T> notFollowedBy(final String name) {_		if (quantifier.hasProperty(Quantifier.QuantifierProperty.OPTIONAL)) {_			throw new UnsupportedOperationException(_					"Specifying a pattern with an optional path to NOT condition is not supported yet. " +_					"You can simulate such pattern with two independent patterns, one with and the other without " +_					"the optional part.")__		}_		return new Pattern<>(name, this, ConsumingStrategy.NOT_FOLLOW, afterMatchSkipStrategy)__	};appends,a,new,pattern,to,the,existing,one,the,new,pattern,enforces,that,there,is,no,event,matching,this,pattern,between,the,preceding,pattern,and,succeeding,this,one,p,b,note,b,there,has,to,be,other,pattern,after,this,one,param,name,name,of,the,new,pattern,return,a,new,pattern,which,is,appended,to,this,one;public,pattern,t,t,not,followed,by,final,string,name,if,quantifier,has,property,quantifier,quantifier,property,optional,throw,new,unsupported,operation,exception,specifying,a,pattern,with,an,optional,path,to,not,condition,is,not,supported,yet,you,can,simulate,such,pattern,with,two,independent,patterns,one,with,and,the,other,without,the,optional,part,return,new,pattern,name,this,consuming,strategy,after,match,skip,strategy
Pattern -> public Pattern<T, T> notFollowedBy(final String name);1540208358;Appends a new pattern to the existing one. The new pattern enforces that there is no event matching this pattern_between the preceding pattern and succeeding this one.__<p><b>NOTE:</b> There has to be other pattern after this one.__@param name Name of the new pattern_@return A new pattern which is appended to this one;public Pattern<T, T> notFollowedBy(final String name) {_		if (quantifier.hasProperty(Quantifier.QuantifierProperty.OPTIONAL)) {_			throw new UnsupportedOperationException(_					"Specifying a pattern with an optional path to NOT condition is not supported yet. " +_					"You can simulate such pattern with two independent patterns, one with and the other without " +_					"the optional part.")__		}_		return new Pattern<>(name, this, ConsumingStrategy.NOT_FOLLOW, afterMatchSkipStrategy)__	};appends,a,new,pattern,to,the,existing,one,the,new,pattern,enforces,that,there,is,no,event,matching,this,pattern,between,the,preceding,pattern,and,succeeding,this,one,p,b,note,b,there,has,to,be,other,pattern,after,this,one,param,name,name,of,the,new,pattern,return,a,new,pattern,which,is,appended,to,this,one;public,pattern,t,t,not,followed,by,final,string,name,if,quantifier,has,property,quantifier,quantifier,property,optional,throw,new,unsupported,operation,exception,specifying,a,pattern,with,an,optional,path,to,not,condition,is,not,supported,yet,you,can,simulate,such,pattern,with,two,independent,patterns,one,with,and,the,other,without,the,optional,part,return,new,pattern,name,this,consuming,strategy,after,match,skip,strategy
Pattern -> public Pattern<T, T> notFollowedBy(final String name);1543413704;Appends a new pattern to the existing one. The new pattern enforces that there is no event matching this pattern_between the preceding pattern and succeeding this one.__<p><b>NOTE:</b> There has to be other pattern after this one.__@param name Name of the new pattern_@return A new pattern which is appended to this one;public Pattern<T, T> notFollowedBy(final String name) {_		if (quantifier.hasProperty(Quantifier.QuantifierProperty.OPTIONAL)) {_			throw new UnsupportedOperationException(_					"Specifying a pattern with an optional path to NOT condition is not supported yet. " +_					"You can simulate such pattern with two independent patterns, one with and the other without " +_					"the optional part.")__		}_		return new Pattern<>(name, this, ConsumingStrategy.NOT_FOLLOW, afterMatchSkipStrategy)__	};appends,a,new,pattern,to,the,existing,one,the,new,pattern,enforces,that,there,is,no,event,matching,this,pattern,between,the,preceding,pattern,and,succeeding,this,one,p,b,note,b,there,has,to,be,other,pattern,after,this,one,param,name,name,of,the,new,pattern,return,a,new,pattern,which,is,appended,to,this,one;public,pattern,t,t,not,followed,by,final,string,name,if,quantifier,has,property,quantifier,quantifier,property,optional,throw,new,unsupported,operation,exception,specifying,a,pattern,with,an,optional,path,to,not,condition,is,not,supported,yet,you,can,simulate,such,pattern,with,two,independent,patterns,one,with,and,the,other,without,the,optional,part,return,new,pattern,name,this,consuming,strategy,after,match,skip,strategy
Pattern -> public Pattern<T, F> or(IterativeCondition<F> condition);1490638274;Specifies a filter condition which is OR'ed with an existing filter function.__@param condition OR filter condition_@return The same pattern operator where the new filter condition is set;public Pattern<T, F> or(IterativeCondition<F> condition) {_		ClosureCleaner.clean(condition, true)___		if (this.condition == null) {_			this.condition = condition__		} else {_			this.condition = new OrCondition<>(this.condition, condition)__		}_		return this__	};specifies,a,filter,condition,which,is,or,ed,with,an,existing,filter,function,param,condition,or,filter,condition,return,the,same,pattern,operator,where,the,new,filter,condition,is,set;public,pattern,t,f,or,iterative,condition,f,condition,closure,cleaner,clean,condition,true,if,this,condition,null,this,condition,condition,else,this,condition,new,or,condition,this,condition,condition,return,this
Pattern -> public Pattern<T, F> or(IterativeCondition<F> condition);1490862259;Specifies a filter condition which is OR'ed with an existing filter function.__@param condition OR filter condition_@return The same pattern operator where the new filter condition is set;public Pattern<T, F> or(IterativeCondition<F> condition) {_		ClosureCleaner.clean(condition, true)___		if (this.condition == null) {_			this.condition = condition__		} else {_			this.condition = new OrCondition<>(this.condition, condition)__		}_		return this__	};specifies,a,filter,condition,which,is,or,ed,with,an,existing,filter,function,param,condition,or,filter,condition,return,the,same,pattern,operator,where,the,new,filter,condition,is,set;public,pattern,t,f,or,iterative,condition,f,condition,closure,cleaner,clean,condition,true,if,this,condition,null,this,condition,condition,else,this,condition,new,or,condition,this,condition,condition,return,this
Pattern -> public Pattern<T, F> or(IterativeCondition<F> condition);1491647251;Specifies a filter condition which is OR'ed with an existing filter function.__@param condition OR filter condition_@return The same pattern operator where the new filter condition is set;public Pattern<T, F> or(IterativeCondition<F> condition) {_		ClosureCleaner.clean(condition, true)___		if (this.condition == null) {_			this.condition = condition__		} else {_			this.condition = new OrCondition<>(this.condition, condition)__		}_		return this__	};specifies,a,filter,condition,which,is,or,ed,with,an,existing,filter,function,param,condition,or,filter,condition,return,the,same,pattern,operator,where,the,new,filter,condition,is,set;public,pattern,t,f,or,iterative,condition,f,condition,closure,cleaner,clean,condition,true,if,this,condition,null,this,condition,condition,else,this,condition,new,or,condition,this,condition,condition,return,this
Pattern -> public Pattern<T, F> or(IterativeCondition<F> condition);1493201751;Adds a condition that has to be satisfied by an event_in order to be considered a match. If another condition has already been_set, the new one is going to be combined with the previous with a_logical {@code OR}. In other case, this is going to be the only_condition.__@param condition The condition as an {@link IterativeCondition}._@return The pattern with the new condition is set.;public Pattern<T, F> or(IterativeCondition<F> condition) {_		ClosureCleaner.clean(condition, true)___		if (this.condition == null) {_			this.condition = condition__		} else {_			this.condition = new OrCondition<>(this.condition, condition)__		}_		return this__	};adds,a,condition,that,has,to,be,satisfied,by,an,event,in,order,to,be,considered,a,match,if,another,condition,has,already,been,set,the,new,one,is,going,to,be,combined,with,the,previous,with,a,logical,code,or,in,other,case,this,is,going,to,be,the,only,condition,param,condition,the,condition,as,an,link,iterative,condition,return,the,pattern,with,the,new,condition,is,set;public,pattern,t,f,or,iterative,condition,f,condition,closure,cleaner,clean,condition,true,if,this,condition,null,this,condition,condition,else,this,condition,new,or,condition,this,condition,condition,return,this
Pattern -> public Pattern<T, F> or(IterativeCondition<F> condition);1493201753;Adds a condition that has to be satisfied by an event_in order to be considered a match. If another condition has already been_set, the new one is going to be combined with the previous with a_logical {@code OR}. In other case, this is going to be the only_condition.__@param condition The condition as an {@link IterativeCondition}._@return The pattern with the new condition is set.;public Pattern<T, F> or(IterativeCondition<F> condition) {_		ClosureCleaner.clean(condition, true)___		if (this.condition == null) {_			this.condition = condition__		} else {_			this.condition = new OrCondition<>(this.condition, condition)__		}_		return this__	};adds,a,condition,that,has,to,be,satisfied,by,an,event,in,order,to,be,considered,a,match,if,another,condition,has,already,been,set,the,new,one,is,going,to,be,combined,with,the,previous,with,a,logical,code,or,in,other,case,this,is,going,to,be,the,only,condition,param,condition,the,condition,as,an,link,iterative,condition,return,the,pattern,with,the,new,condition,is,set;public,pattern,t,f,or,iterative,condition,f,condition,closure,cleaner,clean,condition,true,if,this,condition,null,this,condition,condition,else,this,condition,new,or,condition,this,condition,condition,return,this
Pattern -> public Pattern<T, F> or(IterativeCondition<F> condition);1493382517;Adds a condition that has to be satisfied by an event_in order to be considered a match. If another condition has already been_set, the new one is going to be combined with the previous with a_logical {@code OR}. In other case, this is going to be the only_condition.__@param condition The condition as an {@link IterativeCondition}._@return The pattern with the new condition is set.;public Pattern<T, F> or(IterativeCondition<F> condition) {_		ClosureCleaner.clean(condition, true)___		if (this.condition == null) {_			this.condition = condition__		} else {_			this.condition = new OrCondition<>(this.condition, condition)__		}_		return this__	};adds,a,condition,that,has,to,be,satisfied,by,an,event,in,order,to,be,considered,a,match,if,another,condition,has,already,been,set,the,new,one,is,going,to,be,combined,with,the,previous,with,a,logical,code,or,in,other,case,this,is,going,to,be,the,only,condition,param,condition,the,condition,as,an,link,iterative,condition,return,the,pattern,with,the,new,condition,is,set;public,pattern,t,f,or,iterative,condition,f,condition,closure,cleaner,clean,condition,true,if,this,condition,null,this,condition,condition,else,this,condition,new,or,condition,this,condition,condition,return,this
Pattern -> public Pattern<T, F> or(IterativeCondition<F> condition);1493906327;Adds a condition that has to be satisfied by an event_in order to be considered a match. If another condition has already been_set, the new one is going to be combined with the previous with a_logical {@code OR}. In other case, this is going to be the only_condition.__@param condition The condition as an {@link IterativeCondition}._@return The pattern with the new condition is set.;public Pattern<T, F> or(IterativeCondition<F> condition) {_		Preconditions.checkNotNull(condition, "The condition cannot be null.")___		ClosureCleaner.clean(condition, true)___		if (this.condition == null) {_			this.condition = condition__		} else {_			this.condition = new OrCondition<>(this.condition, condition)__		}_		return this__	};adds,a,condition,that,has,to,be,satisfied,by,an,event,in,order,to,be,considered,a,match,if,another,condition,has,already,been,set,the,new,one,is,going,to,be,combined,with,the,previous,with,a,logical,code,or,in,other,case,this,is,going,to,be,the,only,condition,param,condition,the,condition,as,an,link,iterative,condition,return,the,pattern,with,the,new,condition,is,set;public,pattern,t,f,or,iterative,condition,f,condition,preconditions,check,not,null,condition,the,condition,cannot,be,null,closure,cleaner,clean,condition,true,if,this,condition,null,this,condition,condition,else,this,condition,new,or,condition,this,condition,condition,return,this
Pattern -> public Pattern<T, F> or(IterativeCondition<F> condition);1493985576;Adds a condition that has to be satisfied by an event_in order to be considered a match. If another condition has already been_set, the new one is going to be combined with the previous with a_logical {@code OR}. In other case, this is going to be the only_condition.__@param condition The condition as an {@link IterativeCondition}._@return The pattern with the new condition is set.;public Pattern<T, F> or(IterativeCondition<F> condition) {_		Preconditions.checkNotNull(condition, "The condition cannot be null.")___		ClosureCleaner.clean(condition, true)___		if (this.condition == null) {_			this.condition = condition__		} else {_			this.condition = new OrCondition<>(this.condition, condition)__		}_		return this__	};adds,a,condition,that,has,to,be,satisfied,by,an,event,in,order,to,be,considered,a,match,if,another,condition,has,already,been,set,the,new,one,is,going,to,be,combined,with,the,previous,with,a,logical,code,or,in,other,case,this,is,going,to,be,the,only,condition,param,condition,the,condition,as,an,link,iterative,condition,return,the,pattern,with,the,new,condition,is,set;public,pattern,t,f,or,iterative,condition,f,condition,preconditions,check,not,null,condition,the,condition,cannot,be,null,closure,cleaner,clean,condition,true,if,this,condition,null,this,condition,condition,else,this,condition,new,or,condition,this,condition,condition,return,this
Pattern -> public Pattern<T, F> or(IterativeCondition<F> condition);1493997908;Adds a condition that has to be satisfied by an event_in order to be considered a match. If another condition has already been_set, the new one is going to be combined with the previous with a_logical {@code OR}. In other case, this is going to be the only_condition.__@param condition The condition as an {@link IterativeCondition}._@return The pattern with the new condition is set.;public Pattern<T, F> or(IterativeCondition<F> condition) {_		Preconditions.checkNotNull(condition, "The condition cannot be null.")___		ClosureCleaner.clean(condition, true)___		if (this.condition == null) {_			this.condition = condition__		} else {_			this.condition = new OrCondition<>(this.condition, condition)__		}_		return this__	};adds,a,condition,that,has,to,be,satisfied,by,an,event,in,order,to,be,considered,a,match,if,another,condition,has,already,been,set,the,new,one,is,going,to,be,combined,with,the,previous,with,a,logical,code,or,in,other,case,this,is,going,to,be,the,only,condition,param,condition,the,condition,as,an,link,iterative,condition,return,the,pattern,with,the,new,condition,is,set;public,pattern,t,f,or,iterative,condition,f,condition,preconditions,check,not,null,condition,the,condition,cannot,be,null,closure,cleaner,clean,condition,true,if,this,condition,null,this,condition,condition,else,this,condition,new,or,condition,this,condition,condition,return,this
Pattern -> public Pattern<T, F> or(IterativeCondition<F> condition);1495961498;Adds a condition that has to be satisfied by an event_in order to be considered a match. If another condition has already been_set, the new one is going to be combined with the previous with a_logical {@code OR}. In other case, this is going to be the only_condition.__@param condition The condition as an {@link IterativeCondition}._@return The pattern with the new condition is set.;public Pattern<T, F> or(IterativeCondition<F> condition) {_		Preconditions.checkNotNull(condition, "The condition cannot be null.")___		ClosureCleaner.clean(condition, true)___		if (this.condition == null) {_			this.condition = condition__		} else {_			this.condition = new OrCondition<>(this.condition, condition)__		}_		return this__	};adds,a,condition,that,has,to,be,satisfied,by,an,event,in,order,to,be,considered,a,match,if,another,condition,has,already,been,set,the,new,one,is,going,to,be,combined,with,the,previous,with,a,logical,code,or,in,other,case,this,is,going,to,be,the,only,condition,param,condition,the,condition,as,an,link,iterative,condition,return,the,pattern,with,the,new,condition,is,set;public,pattern,t,f,or,iterative,condition,f,condition,preconditions,check,not,null,condition,the,condition,cannot,be,null,closure,cleaner,clean,condition,true,if,this,condition,null,this,condition,condition,else,this,condition,new,or,condition,this,condition,condition,return,this
Pattern -> public Pattern<T, F> or(IterativeCondition<F> condition);1497940477;Adds a condition that has to be satisfied by an event_in order to be considered a match. If another condition has already been_set, the new one is going to be combined with the previous with a_logical {@code OR}. In other case, this is going to be the only_condition.__@param condition The condition as an {@link IterativeCondition}._@return The pattern with the new condition is set.;public Pattern<T, F> or(IterativeCondition<F> condition) {_		Preconditions.checkNotNull(condition, "The condition cannot be null.")___		ClosureCleaner.clean(condition, true)___		if (this.condition == null) {_			this.condition = condition__		} else {_			this.condition = new OrCondition<>(this.condition, condition)__		}_		return this__	};adds,a,condition,that,has,to,be,satisfied,by,an,event,in,order,to,be,considered,a,match,if,another,condition,has,already,been,set,the,new,one,is,going,to,be,combined,with,the,previous,with,a,logical,code,or,in,other,case,this,is,going,to,be,the,only,condition,param,condition,the,condition,as,an,link,iterative,condition,return,the,pattern,with,the,new,condition,is,set;public,pattern,t,f,or,iterative,condition,f,condition,preconditions,check,not,null,condition,the,condition,cannot,be,null,closure,cleaner,clean,condition,true,if,this,condition,null,this,condition,condition,else,this,condition,new,or,condition,this,condition,condition,return,this
Pattern -> public Pattern<T, F> or(IterativeCondition<F> condition);1498548074;Adds a condition that has to be satisfied by an event_in order to be considered a match. If another condition has already been_set, the new one is going to be combined with the previous with a_logical {@code OR}. In other case, this is going to be the only_condition.__@param condition The condition as an {@link IterativeCondition}._@return The pattern with the new condition is set.;public Pattern<T, F> or(IterativeCondition<F> condition) {_		Preconditions.checkNotNull(condition, "The condition cannot be null.")___		ClosureCleaner.clean(condition, true)___		if (this.condition == null) {_			this.condition = condition__		} else {_			this.condition = new OrCondition<>(this.condition, condition)__		}_		return this__	};adds,a,condition,that,has,to,be,satisfied,by,an,event,in,order,to,be,considered,a,match,if,another,condition,has,already,been,set,the,new,one,is,going,to,be,combined,with,the,previous,with,a,logical,code,or,in,other,case,this,is,going,to,be,the,only,condition,param,condition,the,condition,as,an,link,iterative,condition,return,the,pattern,with,the,new,condition,is,set;public,pattern,t,f,or,iterative,condition,f,condition,preconditions,check,not,null,condition,the,condition,cannot,be,null,closure,cleaner,clean,condition,true,if,this,condition,null,this,condition,condition,else,this,condition,new,or,condition,this,condition,condition,return,this
Pattern -> public Pattern<T, F> or(IterativeCondition<F> condition);1499244360;Adds a condition that has to be satisfied by an event_in order to be considered a match. If another condition has already been_set, the new one is going to be combined with the previous with a_logical {@code OR}. In other case, this is going to be the only_condition.__@param condition The condition as an {@link IterativeCondition}._@return The pattern with the new condition is set.;public Pattern<T, F> or(IterativeCondition<F> condition) {_		Preconditions.checkNotNull(condition, "The condition cannot be null.")___		ClosureCleaner.clean(condition, true)___		if (this.condition == null) {_			this.condition = condition__		} else {_			this.condition = new OrCondition<>(this.condition, condition)__		}_		return this__	};adds,a,condition,that,has,to,be,satisfied,by,an,event,in,order,to,be,considered,a,match,if,another,condition,has,already,been,set,the,new,one,is,going,to,be,combined,with,the,previous,with,a,logical,code,or,in,other,case,this,is,going,to,be,the,only,condition,param,condition,the,condition,as,an,link,iterative,condition,return,the,pattern,with,the,new,condition,is,set;public,pattern,t,f,or,iterative,condition,f,condition,preconditions,check,not,null,condition,the,condition,cannot,be,null,closure,cleaner,clean,condition,true,if,this,condition,null,this,condition,condition,else,this,condition,new,or,condition,this,condition,condition,return,this
Pattern -> public Pattern<T, F> or(IterativeCondition<F> condition);1499248439;Adds a condition that has to be satisfied by an event_in order to be considered a match. If another condition has already been_set, the new one is going to be combined with the previous with a_logical {@code OR}. In other case, this is going to be the only_condition.__@param condition The condition as an {@link IterativeCondition}._@return The pattern with the new condition is set.;public Pattern<T, F> or(IterativeCondition<F> condition) {_		Preconditions.checkNotNull(condition, "The condition cannot be null.")___		ClosureCleaner.clean(condition, true)___		if (this.condition == null) {_			this.condition = condition__		} else {_			this.condition = new OrCondition<>(this.condition, condition)__		}_		return this__	};adds,a,condition,that,has,to,be,satisfied,by,an,event,in,order,to,be,considered,a,match,if,another,condition,has,already,been,set,the,new,one,is,going,to,be,combined,with,the,previous,with,a,logical,code,or,in,other,case,this,is,going,to,be,the,only,condition,param,condition,the,condition,as,an,link,iterative,condition,return,the,pattern,with,the,new,condition,is,set;public,pattern,t,f,or,iterative,condition,f,condition,preconditions,check,not,null,condition,the,condition,cannot,be,null,closure,cleaner,clean,condition,true,if,this,condition,null,this,condition,condition,else,this,condition,new,or,condition,this,condition,condition,return,this
Pattern -> public Pattern<T, F> or(IterativeCondition<F> condition);1503420807;Adds a condition that has to be satisfied by an event_in order to be considered a match. If another condition has already been_set, the new one is going to be combined with the previous with a_logical {@code OR}. In other case, this is going to be the only_condition.__@param condition The condition as an {@link IterativeCondition}._@return The pattern with the new condition is set.;public Pattern<T, F> or(IterativeCondition<F> condition) {_		Preconditions.checkNotNull(condition, "The condition cannot be null.")___		ClosureCleaner.clean(condition, true)___		if (this.condition == null) {_			this.condition = condition__		} else {_			this.condition = new OrCondition<>(this.condition, condition)__		}_		return this__	};adds,a,condition,that,has,to,be,satisfied,by,an,event,in,order,to,be,considered,a,match,if,another,condition,has,already,been,set,the,new,one,is,going,to,be,combined,with,the,previous,with,a,logical,code,or,in,other,case,this,is,going,to,be,the,only,condition,param,condition,the,condition,as,an,link,iterative,condition,return,the,pattern,with,the,new,condition,is,set;public,pattern,t,f,or,iterative,condition,f,condition,preconditions,check,not,null,condition,the,condition,cannot,be,null,closure,cleaner,clean,condition,true,if,this,condition,null,this,condition,condition,else,this,condition,new,or,condition,this,condition,condition,return,this
Pattern -> public Pattern<T, F> or(IterativeCondition<F> condition);1503558242;Adds a condition that has to be satisfied by an event_in order to be considered a match. If another condition has already been_set, the new one is going to be combined with the previous with a_logical {@code OR}. In other case, this is going to be the only_condition.__@param condition The condition as an {@link IterativeCondition}._@return The pattern with the new condition is set.;public Pattern<T, F> or(IterativeCondition<F> condition) {_		Preconditions.checkNotNull(condition, "The condition cannot be null.")___		ClosureCleaner.clean(condition, true)___		if (this.condition == null) {_			this.condition = condition__		} else {_			this.condition = new OrCondition<>(this.condition, condition)__		}_		return this__	};adds,a,condition,that,has,to,be,satisfied,by,an,event,in,order,to,be,considered,a,match,if,another,condition,has,already,been,set,the,new,one,is,going,to,be,combined,with,the,previous,with,a,logical,code,or,in,other,case,this,is,going,to,be,the,only,condition,param,condition,the,condition,as,an,link,iterative,condition,return,the,pattern,with,the,new,condition,is,set;public,pattern,t,f,or,iterative,condition,f,condition,preconditions,check,not,null,condition,the,condition,cannot,be,null,closure,cleaner,clean,condition,true,if,this,condition,null,this,condition,condition,else,this,condition,new,or,condition,this,condition,condition,return,this
Pattern -> public Pattern<T, F> or(IterativeCondition<F> condition);1504268438;Adds a condition that has to be satisfied by an event_in order to be considered a match. If another condition has already been_set, the new one is going to be combined with the previous with a_logical {@code OR}. In other case, this is going to be the only_condition.__@param condition The condition as an {@link IterativeCondition}._@return The pattern with the new condition is set.;public Pattern<T, F> or(IterativeCondition<F> condition) {_		Preconditions.checkNotNull(condition, "The condition cannot be null.")___		ClosureCleaner.clean(condition, true)___		if (this.condition == null) {_			this.condition = condition__		} else {_			this.condition = new OrCondition<>(this.condition, condition)__		}_		return this__	};adds,a,condition,that,has,to,be,satisfied,by,an,event,in,order,to,be,considered,a,match,if,another,condition,has,already,been,set,the,new,one,is,going,to,be,combined,with,the,previous,with,a,logical,code,or,in,other,case,this,is,going,to,be,the,only,condition,param,condition,the,condition,as,an,link,iterative,condition,return,the,pattern,with,the,new,condition,is,set;public,pattern,t,f,or,iterative,condition,f,condition,preconditions,check,not,null,condition,the,condition,cannot,be,null,closure,cleaner,clean,condition,true,if,this,condition,null,this,condition,condition,else,this,condition,new,or,condition,this,condition,condition,return,this
Pattern -> public Pattern<T, F> or(IterativeCondition<F> condition);1530798894;Adds a condition that has to be satisfied by an event_in order to be considered a match. If another condition has already been_set, the new one is going to be combined with the previous with a_logical {@code OR}. In other case, this is going to be the only_condition.__@param condition The condition as an {@link IterativeCondition}._@return The pattern with the new condition is set.;public Pattern<T, F> or(IterativeCondition<F> condition) {_		Preconditions.checkNotNull(condition, "The condition cannot be null.")___		ClosureCleaner.clean(condition, true)___		if (this.condition == null) {_			this.condition = condition__		} else {_			this.condition = new OrCondition<>(this.condition, condition)__		}_		return this__	};adds,a,condition,that,has,to,be,satisfied,by,an,event,in,order,to,be,considered,a,match,if,another,condition,has,already,been,set,the,new,one,is,going,to,be,combined,with,the,previous,with,a,logical,code,or,in,other,case,this,is,going,to,be,the,only,condition,param,condition,the,condition,as,an,link,iterative,condition,return,the,pattern,with,the,new,condition,is,set;public,pattern,t,f,or,iterative,condition,f,condition,preconditions,check,not,null,condition,the,condition,cannot,be,null,closure,cleaner,clean,condition,true,if,this,condition,null,this,condition,condition,else,this,condition,new,or,condition,this,condition,condition,return,this
Pattern -> public Pattern<T, F> or(IterativeCondition<F> condition);1540208358;Adds a condition that has to be satisfied by an event_in order to be considered a match. If another condition has already been_set, the new one is going to be combined with the previous with a_logical {@code OR}. In other case, this is going to be the only_condition.__@param condition The condition as an {@link IterativeCondition}._@return The pattern with the new condition is set.;public Pattern<T, F> or(IterativeCondition<F> condition) {_		Preconditions.checkNotNull(condition, "The condition cannot be null.")___		ClosureCleaner.clean(condition, true)___		if (this.condition == null) {_			this.condition = condition__		} else {_			this.condition = new OrCondition<>(this.condition, condition)__		}_		return this__	};adds,a,condition,that,has,to,be,satisfied,by,an,event,in,order,to,be,considered,a,match,if,another,condition,has,already,been,set,the,new,one,is,going,to,be,combined,with,the,previous,with,a,logical,code,or,in,other,case,this,is,going,to,be,the,only,condition,param,condition,the,condition,as,an,link,iterative,condition,return,the,pattern,with,the,new,condition,is,set;public,pattern,t,f,or,iterative,condition,f,condition,preconditions,check,not,null,condition,the,condition,cannot,be,null,closure,cleaner,clean,condition,true,if,this,condition,null,this,condition,condition,else,this,condition,new,or,condition,this,condition,condition,return,this
Pattern -> public Pattern<T, F> or(IterativeCondition<F> condition);1543413704;Adds a condition that has to be satisfied by an event_in order to be considered a match. If another condition has already been_set, the new one is going to be combined with the previous with a_logical {@code OR}. In other case, this is going to be the only_condition.__@param condition The condition as an {@link IterativeCondition}._@return The pattern with the new condition is set.;public Pattern<T, F> or(IterativeCondition<F> condition) {_		Preconditions.checkNotNull(condition, "The condition cannot be null.")___		ClosureCleaner.clean(condition, true)___		if (this.condition == null) {_			this.condition = condition__		} else {_			this.condition = new RichOrCondition<>(this.condition, condition)__		}_		return this__	};adds,a,condition,that,has,to,be,satisfied,by,an,event,in,order,to,be,considered,a,match,if,another,condition,has,already,been,set,the,new,one,is,going,to,be,combined,with,the,previous,with,a,logical,code,or,in,other,case,this,is,going,to,be,the,only,condition,param,condition,the,condition,as,an,link,iterative,condition,return,the,pattern,with,the,new,condition,is,set;public,pattern,t,f,or,iterative,condition,f,condition,preconditions,check,not,null,condition,the,condition,cannot,be,null,closure,cleaner,clean,condition,true,if,this,condition,null,this,condition,condition,else,this,condition,new,rich,or,condition,this,condition,condition,return,this
Pattern -> public Pattern<T, F> or(FilterFunction<F> orFilterFunction);1471614454;Specifies a filter condition which is ORed with an existing filter function.__@param orFilterFunction OR filter condition_@return The same pattern operator where the new filter condition is set;public Pattern<T, F> or(FilterFunction<F> orFilterFunction) {_		ClosureCleaner.clean(orFilterFunction, true)___		if (this.filterFunction == null) {_			this.filterFunction = orFilterFunction__		} else {_			this.filterFunction = new OrFilterFunction<>(this.filterFunction, orFilterFunction)__		}__		return this__	};specifies,a,filter,condition,which,is,ored,with,an,existing,filter,function,param,or,filter,function,or,filter,condition,return,the,same,pattern,operator,where,the,new,filter,condition,is,set;public,pattern,t,f,or,filter,function,f,or,filter,function,closure,cleaner,clean,or,filter,function,true,if,this,filter,function,null,this,filter,function,or,filter,function,else,this,filter,function,new,or,filter,function,this,filter,function,or,filter,function,return,this
Pattern -> public Pattern<T, F> or(FilterFunction<F> orFilterFunction);1488270949;Specifies a filter condition which is OR'ed with an existing filter function.__@param orFilterFunction OR filter condition_@return The same pattern operator where the new filter condition is set;public Pattern<T, F> or(FilterFunction<F> orFilterFunction) {_		ClosureCleaner.clean(orFilterFunction, true)___		if (this.filterFunction == null) {_			this.filterFunction = orFilterFunction__		} else {_			this.filterFunction = new OrFilterFunction<>(this.filterFunction, orFilterFunction)__		}__		return this__	};specifies,a,filter,condition,which,is,or,ed,with,an,existing,filter,function,param,or,filter,function,or,filter,condition,return,the,same,pattern,operator,where,the,new,filter,condition,is,set;public,pattern,t,f,or,filter,function,f,or,filter,function,closure,cleaner,clean,or,filter,function,true,if,this,filter,function,null,this,filter,function,or,filter,function,else,this,filter,function,new,or,filter,function,this,filter,function,or,filter,function,return,this
Pattern -> public Pattern<T, F> or(FilterFunction<F> orFilterFunction);1490262475;Specifies a filter condition which is OR'ed with an existing filter function.__@param orFilterFunction OR filter condition_@return The same pattern operator where the new filter condition is set;public Pattern<T, F> or(FilterFunction<F> orFilterFunction) {_		ClosureCleaner.clean(orFilterFunction, true)___		if (this.filterFunction == null) {_			this.filterFunction = orFilterFunction__		} else {_			this.filterFunction = new OrFilterFunction<>(this.filterFunction, orFilterFunction)__		}__		return this__	};specifies,a,filter,condition,which,is,or,ed,with,an,existing,filter,function,param,or,filter,function,or,filter,condition,return,the,same,pattern,operator,where,the,new,filter,condition,is,set;public,pattern,t,f,or,filter,function,f,or,filter,function,closure,cleaner,clean,or,filter,function,true,if,this,filter,function,null,this,filter,function,or,filter,function,else,this,filter,function,new,or,filter,function,this,filter,function,or,filter,function,return,this
Pattern -> public Pattern<T, F> optional();1490262475;Specifies that this pattern can occur zero or once.__@return The same pattern with applied Kleene ? operator__@throws MalformedPatternException if quantifier already applied;public Pattern<T, F> optional() {_		checkIfQuantifierApplied()__		this.quantifier = Quantifier.OPTIONAL__		return this__	};specifies,that,this,pattern,can,occur,zero,or,once,return,the,same,pattern,with,applied,kleene,operator,throws,malformed,pattern,exception,if,quantifier,already,applied;public,pattern,t,f,optional,check,if,quantifier,applied,this,quantifier,quantifier,optional,return,this
Pattern -> public Pattern<T, F> optional();1490638274;Specifies that this pattern can occur zero or once.__@return The same pattern with applied Kleene ? operator__@throws MalformedPatternException if quantifier already applied;public Pattern<T, F> optional() {_		checkIfQuantifierApplied()__		this.quantifier = Quantifier.OPTIONAL__		return this__	};specifies,that,this,pattern,can,occur,zero,or,once,return,the,same,pattern,with,applied,kleene,operator,throws,malformed,pattern,exception,if,quantifier,already,applied;public,pattern,t,f,optional,check,if,quantifier,applied,this,quantifier,quantifier,optional,return,this
Pattern -> public Pattern<T, F> optional();1490862259;Specifies that this pattern can occur zero or once.__@return The same pattern with applied Kleene ? operator__@throws MalformedPatternException if quantifier already applied;public Pattern<T, F> optional() {_		checkIfQuantifierApplied()__		this.quantifier = Quantifier.OPTIONAL__		return this__	};specifies,that,this,pattern,can,occur,zero,or,once,return,the,same,pattern,with,applied,kleene,operator,throws,malformed,pattern,exception,if,quantifier,already,applied;public,pattern,t,f,optional,check,if,quantifier,applied,this,quantifier,quantifier,optional,return,this
Pattern -> public Pattern<T, F> optional();1491647251;Specifies that this pattern can occur zero or once.__@return The same pattern with applied Kleene ? operator__@throws MalformedPatternException if quantifier already applied;public Pattern<T, F> optional() {_		checkIfQuantifierApplied()__		this.quantifier = Quantifier.OPTIONAL__		return this__	};specifies,that,this,pattern,can,occur,zero,or,once,return,the,same,pattern,with,applied,kleene,operator,throws,malformed,pattern,exception,if,quantifier,already,applied;public,pattern,t,f,optional,check,if,quantifier,applied,this,quantifier,quantifier,optional,return,this
Pattern -> public Pattern<T, F> optional();1493201751;Specifies that this pattern is optional for a final match of the pattern_sequence to happen.__@return The same pattern as optional._@throws MalformedPatternException if the quantifier is not applicable to this pattern.;public Pattern<T, F> optional() {_		quantifier.makeOptional()__		return this__	};specifies,that,this,pattern,is,optional,for,a,final,match,of,the,pattern,sequence,to,happen,return,the,same,pattern,as,optional,throws,malformed,pattern,exception,if,the,quantifier,is,not,applicable,to,this,pattern;public,pattern,t,f,optional,quantifier,make,optional,return,this
Pattern -> public Pattern<T, F> optional();1493201753;Specifies that this pattern is optional for a final match of the pattern_sequence to happen.__@return The same pattern as optional._@throws MalformedPatternException if the quantifier is not applicable to this pattern.;public Pattern<T, F> optional() {_		quantifier.optional()__		return this__	};specifies,that,this,pattern,is,optional,for,a,final,match,of,the,pattern,sequence,to,happen,return,the,same,pattern,as,optional,throws,malformed,pattern,exception,if,the,quantifier,is,not,applicable,to,this,pattern;public,pattern,t,f,optional,quantifier,optional,return,this
Pattern -> public Pattern<T, F> optional();1493382517;Specifies that this pattern is optional for a final match of the pattern_sequence to happen.__@return The same pattern as optional._@throws MalformedPatternException if the quantifier is not applicable to this pattern.;public Pattern<T, F> optional() {_		quantifier.optional()__		return this__	};specifies,that,this,pattern,is,optional,for,a,final,match,of,the,pattern,sequence,to,happen,return,the,same,pattern,as,optional,throws,malformed,pattern,exception,if,the,quantifier,is,not,applicable,to,this,pattern;public,pattern,t,f,optional,quantifier,optional,return,this
Pattern -> public Pattern<T, F> optional();1493906327;Specifies that this pattern is optional for a final match of the pattern_sequence to happen.__@return The same pattern as optional._@throws MalformedPatternException if the quantifier is not applicable to this pattern.;public Pattern<T, F> optional() {_		quantifier.optional()__		return this__	};specifies,that,this,pattern,is,optional,for,a,final,match,of,the,pattern,sequence,to,happen,return,the,same,pattern,as,optional,throws,malformed,pattern,exception,if,the,quantifier,is,not,applicable,to,this,pattern;public,pattern,t,f,optional,quantifier,optional,return,this
Pattern -> public Pattern<T, F> optional();1493985576;Specifies that this pattern is optional for a final match of the pattern_sequence to happen.__@return The same pattern as optional._@throws MalformedPatternException if the quantifier is not applicable to this pattern.;public Pattern<T, F> optional() {_		quantifier.optional()__		return this__	};specifies,that,this,pattern,is,optional,for,a,final,match,of,the,pattern,sequence,to,happen,return,the,same,pattern,as,optional,throws,malformed,pattern,exception,if,the,quantifier,is,not,applicable,to,this,pattern;public,pattern,t,f,optional,quantifier,optional,return,this
Pattern -> public Pattern<T, F> optional();1493997908;Specifies that this pattern is optional for a final match of the pattern_sequence to happen.__@return The same pattern as optional._@throws MalformedPatternException if the quantifier is not applicable to this pattern.;public Pattern<T, F> optional() {_		quantifier.optional()__		return this__	};specifies,that,this,pattern,is,optional,for,a,final,match,of,the,pattern,sequence,to,happen,return,the,same,pattern,as,optional,throws,malformed,pattern,exception,if,the,quantifier,is,not,applicable,to,this,pattern;public,pattern,t,f,optional,quantifier,optional,return,this
Pattern -> public Pattern<T, F> optional();1495961498;Specifies that this pattern is optional for a final match of the pattern_sequence to happen.__@return The same pattern as optional._@throws MalformedPatternException if the quantifier is not applicable to this pattern.;public Pattern<T, F> optional() {_		quantifier.optional()__		return this__	};specifies,that,this,pattern,is,optional,for,a,final,match,of,the,pattern,sequence,to,happen,return,the,same,pattern,as,optional,throws,malformed,pattern,exception,if,the,quantifier,is,not,applicable,to,this,pattern;public,pattern,t,f,optional,quantifier,optional,return,this
Pattern -> public Pattern<T, F> optional();1497940477;Specifies that this pattern is optional for a final match of the pattern_sequence to happen.__@return The same pattern as optional._@throws MalformedPatternException if the quantifier is not applicable to this pattern.;public Pattern<T, F> optional() {_		quantifier.optional()__		return this__	};specifies,that,this,pattern,is,optional,for,a,final,match,of,the,pattern,sequence,to,happen,return,the,same,pattern,as,optional,throws,malformed,pattern,exception,if,the,quantifier,is,not,applicable,to,this,pattern;public,pattern,t,f,optional,quantifier,optional,return,this
Pattern -> public Pattern<T, F> optional();1498548074;Specifies that this pattern is optional for a final match of the pattern_sequence to happen.__@return The same pattern as optional._@throws MalformedPatternException if the quantifier is not applicable to this pattern.;public Pattern<T, F> optional() {_		quantifier.optional()__		return this__	};specifies,that,this,pattern,is,optional,for,a,final,match,of,the,pattern,sequence,to,happen,return,the,same,pattern,as,optional,throws,malformed,pattern,exception,if,the,quantifier,is,not,applicable,to,this,pattern;public,pattern,t,f,optional,quantifier,optional,return,this
Pattern -> public Pattern<T, F> optional();1499244360;Specifies that this pattern is optional for a final match of the pattern_sequence to happen.__@return The same pattern as optional._@throws MalformedPatternException if the quantifier is not applicable to this pattern.;public Pattern<T, F> optional() {_		quantifier.optional()__		return this__	};specifies,that,this,pattern,is,optional,for,a,final,match,of,the,pattern,sequence,to,happen,return,the,same,pattern,as,optional,throws,malformed,pattern,exception,if,the,quantifier,is,not,applicable,to,this,pattern;public,pattern,t,f,optional,quantifier,optional,return,this
Pattern -> public Pattern<T, F> optional();1499248439;Specifies that this pattern is optional for a final match of the pattern_sequence to happen.__@return The same pattern as optional._@throws MalformedPatternException if the quantifier is not applicable to this pattern.;public Pattern<T, F> optional() {_		quantifier.optional()__		return this__	};specifies,that,this,pattern,is,optional,for,a,final,match,of,the,pattern,sequence,to,happen,return,the,same,pattern,as,optional,throws,malformed,pattern,exception,if,the,quantifier,is,not,applicable,to,this,pattern;public,pattern,t,f,optional,quantifier,optional,return,this
Pattern -> public Pattern<T, F> optional();1503420807;Specifies that this pattern is optional for a final match of the pattern_sequence to happen.__@return The same pattern as optional._@throws MalformedPatternException if the quantifier is not applicable to this pattern.;public Pattern<T, F> optional() {_		quantifier.optional()__		return this__	};specifies,that,this,pattern,is,optional,for,a,final,match,of,the,pattern,sequence,to,happen,return,the,same,pattern,as,optional,throws,malformed,pattern,exception,if,the,quantifier,is,not,applicable,to,this,pattern;public,pattern,t,f,optional,quantifier,optional,return,this
Pattern -> public Pattern<T, F> optional();1503558242;Specifies that this pattern is optional for a final match of the pattern_sequence to happen.__@return The same pattern as optional._@throws MalformedPatternException if the quantifier is not applicable to this pattern.;public Pattern<T, F> optional() {_		checkIfPreviousPatternGreedy()__		quantifier.optional()__		return this__	};specifies,that,this,pattern,is,optional,for,a,final,match,of,the,pattern,sequence,to,happen,return,the,same,pattern,as,optional,throws,malformed,pattern,exception,if,the,quantifier,is,not,applicable,to,this,pattern;public,pattern,t,f,optional,check,if,previous,pattern,greedy,quantifier,optional,return,this
Pattern -> public Pattern<T, F> optional();1504268438;Specifies that this pattern is optional for a final match of the pattern_sequence to happen.__@return The same pattern as optional._@throws MalformedPatternException if the quantifier is not applicable to this pattern.;public Pattern<T, F> optional() {_		checkIfPreviousPatternGreedy()__		quantifier.optional()__		return this__	};specifies,that,this,pattern,is,optional,for,a,final,match,of,the,pattern,sequence,to,happen,return,the,same,pattern,as,optional,throws,malformed,pattern,exception,if,the,quantifier,is,not,applicable,to,this,pattern;public,pattern,t,f,optional,check,if,previous,pattern,greedy,quantifier,optional,return,this
Pattern -> public Pattern<T, F> optional();1530798894;Specifies that this pattern is optional for a final match of the pattern_sequence to happen.__@return The same pattern as optional._@throws MalformedPatternException if the quantifier is not applicable to this pattern.;public Pattern<T, F> optional() {_		checkIfPreviousPatternGreedy()__		quantifier.optional()__		return this__	};specifies,that,this,pattern,is,optional,for,a,final,match,of,the,pattern,sequence,to,happen,return,the,same,pattern,as,optional,throws,malformed,pattern,exception,if,the,quantifier,is,not,applicable,to,this,pattern;public,pattern,t,f,optional,check,if,previous,pattern,greedy,quantifier,optional,return,this
Pattern -> public Pattern<T, F> optional();1540208358;Specifies that this pattern is optional for a final match of the pattern_sequence to happen.__@return The same pattern as optional._@throws MalformedPatternException if the quantifier is not applicable to this pattern.;public Pattern<T, F> optional() {_		checkIfPreviousPatternGreedy()__		quantifier.optional()__		return this__	};specifies,that,this,pattern,is,optional,for,a,final,match,of,the,pattern,sequence,to,happen,return,the,same,pattern,as,optional,throws,malformed,pattern,exception,if,the,quantifier,is,not,applicable,to,this,pattern;public,pattern,t,f,optional,check,if,previous,pattern,greedy,quantifier,optional,return,this
Pattern -> public Pattern<T, F> optional();1543413704;Specifies that this pattern is optional for a final match of the pattern_sequence to happen.__@return The same pattern as optional._@throws MalformedPatternException if the quantifier is not applicable to this pattern.;public Pattern<T, F> optional() {_		checkIfPreviousPatternGreedy()__		quantifier.optional()__		return this__	};specifies,that,this,pattern,is,optional,for,a,final,match,of,the,pattern,sequence,to,happen,return,the,same,pattern,as,optional,throws,malformed,pattern,exception,if,the,quantifier,is,not,applicable,to,this,pattern;public,pattern,t,f,optional,check,if,previous,pattern,greedy,quantifier,optional,return,this
Pattern -> public Pattern<T, F> where(IterativeCondition<F> condition);1490638274;Specifies a filter condition which has to be fulfilled by an event in order to be matched.__@param condition Filter condition_@return The same pattern operator where the new filter condition is set;public Pattern<T, F> where(IterativeCondition<F> condition) {_		ClosureCleaner.clean(condition, true)___		if (this.condition == null) {_			this.condition = condition__		} else {_			this.condition = new AndCondition<>(this.condition, condition)__		}_		return this__	};specifies,a,filter,condition,which,has,to,be,fulfilled,by,an,event,in,order,to,be,matched,param,condition,filter,condition,return,the,same,pattern,operator,where,the,new,filter,condition,is,set;public,pattern,t,f,where,iterative,condition,f,condition,closure,cleaner,clean,condition,true,if,this,condition,null,this,condition,condition,else,this,condition,new,and,condition,this,condition,condition,return,this
Pattern -> public Pattern<T, F> where(IterativeCondition<F> condition);1490862259;Specifies a filter condition which has to be fulfilled by an event in order to be matched.__@param condition Filter condition_@return The same pattern operator where the new filter condition is set;public Pattern<T, F> where(IterativeCondition<F> condition) {_		ClosureCleaner.clean(condition, true)___		if (this.condition == null) {_			this.condition = condition__		} else {_			this.condition = new AndCondition<>(this.condition, condition)__		}_		return this__	};specifies,a,filter,condition,which,has,to,be,fulfilled,by,an,event,in,order,to,be,matched,param,condition,filter,condition,return,the,same,pattern,operator,where,the,new,filter,condition,is,set;public,pattern,t,f,where,iterative,condition,f,condition,closure,cleaner,clean,condition,true,if,this,condition,null,this,condition,condition,else,this,condition,new,and,condition,this,condition,condition,return,this
Pattern -> public Pattern<T, F> where(IterativeCondition<F> condition);1491647251;Specifies a filter condition which has to be fulfilled by an event in order to be matched.__@param condition Filter condition_@return The same pattern operator where the new filter condition is set;public Pattern<T, F> where(IterativeCondition<F> condition) {_		ClosureCleaner.clean(condition, true)___		if (this.condition == null) {_			this.condition = condition__		} else {_			this.condition = new AndCondition<>(this.condition, condition)__		}_		return this__	};specifies,a,filter,condition,which,has,to,be,fulfilled,by,an,event,in,order,to,be,matched,param,condition,filter,condition,return,the,same,pattern,operator,where,the,new,filter,condition,is,set;public,pattern,t,f,where,iterative,condition,f,condition,closure,cleaner,clean,condition,true,if,this,condition,null,this,condition,condition,else,this,condition,new,and,condition,this,condition,condition,return,this
Pattern -> public Pattern<T, F> where(IterativeCondition<F> condition);1493201751;Adds a condition that has to be satisfied by an event_in order to be considered a match. If another condition has already been_set, the new one is going to be combined with the previous with a_logical {@code AND}. In other case, this is going to be the only_condition.__@param condition The condition as an {@link IterativeCondition}._@return The pattern with the new condition is set.;public Pattern<T, F> where(IterativeCondition<F> condition) {_		ClosureCleaner.clean(condition, true)___		if (this.condition == null) {_			this.condition = condition__		} else {_			this.condition = new AndCondition<>(this.condition, condition)__		}_		return this__	};adds,a,condition,that,has,to,be,satisfied,by,an,event,in,order,to,be,considered,a,match,if,another,condition,has,already,been,set,the,new,one,is,going,to,be,combined,with,the,previous,with,a,logical,code,and,in,other,case,this,is,going,to,be,the,only,condition,param,condition,the,condition,as,an,link,iterative,condition,return,the,pattern,with,the,new,condition,is,set;public,pattern,t,f,where,iterative,condition,f,condition,closure,cleaner,clean,condition,true,if,this,condition,null,this,condition,condition,else,this,condition,new,and,condition,this,condition,condition,return,this
Pattern -> public Pattern<T, F> where(IterativeCondition<F> condition);1493201753;Adds a condition that has to be satisfied by an event_in order to be considered a match. If another condition has already been_set, the new one is going to be combined with the previous with a_logical {@code AND}. In other case, this is going to be the only_condition.__@param condition The condition as an {@link IterativeCondition}._@return The pattern with the new condition is set.;public Pattern<T, F> where(IterativeCondition<F> condition) {_		ClosureCleaner.clean(condition, true)___		if (this.condition == null) {_			this.condition = condition__		} else {_			this.condition = new AndCondition<>(this.condition, condition)__		}_		return this__	};adds,a,condition,that,has,to,be,satisfied,by,an,event,in,order,to,be,considered,a,match,if,another,condition,has,already,been,set,the,new,one,is,going,to,be,combined,with,the,previous,with,a,logical,code,and,in,other,case,this,is,going,to,be,the,only,condition,param,condition,the,condition,as,an,link,iterative,condition,return,the,pattern,with,the,new,condition,is,set;public,pattern,t,f,where,iterative,condition,f,condition,closure,cleaner,clean,condition,true,if,this,condition,null,this,condition,condition,else,this,condition,new,and,condition,this,condition,condition,return,this
Pattern -> public Pattern<T, F> where(IterativeCondition<F> condition);1493382517;Adds a condition that has to be satisfied by an event_in order to be considered a match. If another condition has already been_set, the new one is going to be combined with the previous with a_logical {@code AND}. In other case, this is going to be the only_condition.__@param condition The condition as an {@link IterativeCondition}._@return The pattern with the new condition is set.;public Pattern<T, F> where(IterativeCondition<F> condition) {_		ClosureCleaner.clean(condition, true)___		if (this.condition == null) {_			this.condition = condition__		} else {_			this.condition = new AndCondition<>(this.condition, condition)__		}_		return this__	};adds,a,condition,that,has,to,be,satisfied,by,an,event,in,order,to,be,considered,a,match,if,another,condition,has,already,been,set,the,new,one,is,going,to,be,combined,with,the,previous,with,a,logical,code,and,in,other,case,this,is,going,to,be,the,only,condition,param,condition,the,condition,as,an,link,iterative,condition,return,the,pattern,with,the,new,condition,is,set;public,pattern,t,f,where,iterative,condition,f,condition,closure,cleaner,clean,condition,true,if,this,condition,null,this,condition,condition,else,this,condition,new,and,condition,this,condition,condition,return,this
Pattern -> public Pattern<T, F> where(IterativeCondition<F> condition);1493906327;Adds a condition that has to be satisfied by an event_in order to be considered a match. If another condition has already been_set, the new one is going to be combined with the previous with a_logical {@code AND}. In other case, this is going to be the only_condition.__@param condition The condition as an {@link IterativeCondition}._@return The pattern with the new condition is set.;public Pattern<T, F> where(IterativeCondition<F> condition) {_		Preconditions.checkNotNull(condition, "The condition cannot be null.")___		ClosureCleaner.clean(condition, true)__		if (this.condition == null) {_			this.condition = condition__		} else {_			this.condition = new AndCondition<>(this.condition, condition)__		}_		return this__	};adds,a,condition,that,has,to,be,satisfied,by,an,event,in,order,to,be,considered,a,match,if,another,condition,has,already,been,set,the,new,one,is,going,to,be,combined,with,the,previous,with,a,logical,code,and,in,other,case,this,is,going,to,be,the,only,condition,param,condition,the,condition,as,an,link,iterative,condition,return,the,pattern,with,the,new,condition,is,set;public,pattern,t,f,where,iterative,condition,f,condition,preconditions,check,not,null,condition,the,condition,cannot,be,null,closure,cleaner,clean,condition,true,if,this,condition,null,this,condition,condition,else,this,condition,new,and,condition,this,condition,condition,return,this
Pattern -> public Pattern<T, F> where(IterativeCondition<F> condition);1493985576;Adds a condition that has to be satisfied by an event_in order to be considered a match. If another condition has already been_set, the new one is going to be combined with the previous with a_logical {@code AND}. In other case, this is going to be the only_condition.__@param condition The condition as an {@link IterativeCondition}._@return The pattern with the new condition is set.;public Pattern<T, F> where(IterativeCondition<F> condition) {_		Preconditions.checkNotNull(condition, "The condition cannot be null.")___		ClosureCleaner.clean(condition, true)__		if (this.condition == null) {_			this.condition = condition__		} else {_			this.condition = new AndCondition<>(this.condition, condition)__		}_		return this__	};adds,a,condition,that,has,to,be,satisfied,by,an,event,in,order,to,be,considered,a,match,if,another,condition,has,already,been,set,the,new,one,is,going,to,be,combined,with,the,previous,with,a,logical,code,and,in,other,case,this,is,going,to,be,the,only,condition,param,condition,the,condition,as,an,link,iterative,condition,return,the,pattern,with,the,new,condition,is,set;public,pattern,t,f,where,iterative,condition,f,condition,preconditions,check,not,null,condition,the,condition,cannot,be,null,closure,cleaner,clean,condition,true,if,this,condition,null,this,condition,condition,else,this,condition,new,and,condition,this,condition,condition,return,this
Pattern -> public Pattern<T, F> where(IterativeCondition<F> condition);1493997908;Adds a condition that has to be satisfied by an event_in order to be considered a match. If another condition has already been_set, the new one is going to be combined with the previous with a_logical {@code AND}. In other case, this is going to be the only_condition.__@param condition The condition as an {@link IterativeCondition}._@return The pattern with the new condition is set.;public Pattern<T, F> where(IterativeCondition<F> condition) {_		Preconditions.checkNotNull(condition, "The condition cannot be null.")___		ClosureCleaner.clean(condition, true)__		if (this.condition == null) {_			this.condition = condition__		} else {_			this.condition = new AndCondition<>(this.condition, condition)__		}_		return this__	};adds,a,condition,that,has,to,be,satisfied,by,an,event,in,order,to,be,considered,a,match,if,another,condition,has,already,been,set,the,new,one,is,going,to,be,combined,with,the,previous,with,a,logical,code,and,in,other,case,this,is,going,to,be,the,only,condition,param,condition,the,condition,as,an,link,iterative,condition,return,the,pattern,with,the,new,condition,is,set;public,pattern,t,f,where,iterative,condition,f,condition,preconditions,check,not,null,condition,the,condition,cannot,be,null,closure,cleaner,clean,condition,true,if,this,condition,null,this,condition,condition,else,this,condition,new,and,condition,this,condition,condition,return,this
Pattern -> public Pattern<T, F> where(IterativeCondition<F> condition);1495961498;Adds a condition that has to be satisfied by an event_in order to be considered a match. If another condition has already been_set, the new one is going to be combined with the previous with a_logical {@code AND}. In other case, this is going to be the only_condition.__@param condition The condition as an {@link IterativeCondition}._@return The pattern with the new condition is set.;public Pattern<T, F> where(IterativeCondition<F> condition) {_		Preconditions.checkNotNull(condition, "The condition cannot be null.")___		ClosureCleaner.clean(condition, true)__		if (this.condition == null) {_			this.condition = condition__		} else {_			this.condition = new AndCondition<>(this.condition, condition)__		}_		return this__	};adds,a,condition,that,has,to,be,satisfied,by,an,event,in,order,to,be,considered,a,match,if,another,condition,has,already,been,set,the,new,one,is,going,to,be,combined,with,the,previous,with,a,logical,code,and,in,other,case,this,is,going,to,be,the,only,condition,param,condition,the,condition,as,an,link,iterative,condition,return,the,pattern,with,the,new,condition,is,set;public,pattern,t,f,where,iterative,condition,f,condition,preconditions,check,not,null,condition,the,condition,cannot,be,null,closure,cleaner,clean,condition,true,if,this,condition,null,this,condition,condition,else,this,condition,new,and,condition,this,condition,condition,return,this
Pattern -> public Pattern<T, F> where(IterativeCondition<F> condition);1497940477;Adds a condition that has to be satisfied by an event_in order to be considered a match. If another condition has already been_set, the new one is going to be combined with the previous with a_logical {@code AND}. In other case, this is going to be the only_condition.__@param condition The condition as an {@link IterativeCondition}._@return The pattern with the new condition is set.;public Pattern<T, F> where(IterativeCondition<F> condition) {_		Preconditions.checkNotNull(condition, "The condition cannot be null.")___		ClosureCleaner.clean(condition, true)__		if (this.condition == null) {_			this.condition = condition__		} else {_			this.condition = new AndCondition<>(this.condition, condition)__		}_		return this__	};adds,a,condition,that,has,to,be,satisfied,by,an,event,in,order,to,be,considered,a,match,if,another,condition,has,already,been,set,the,new,one,is,going,to,be,combined,with,the,previous,with,a,logical,code,and,in,other,case,this,is,going,to,be,the,only,condition,param,condition,the,condition,as,an,link,iterative,condition,return,the,pattern,with,the,new,condition,is,set;public,pattern,t,f,where,iterative,condition,f,condition,preconditions,check,not,null,condition,the,condition,cannot,be,null,closure,cleaner,clean,condition,true,if,this,condition,null,this,condition,condition,else,this,condition,new,and,condition,this,condition,condition,return,this
Pattern -> public Pattern<T, F> where(IterativeCondition<F> condition);1498548074;Adds a condition that has to be satisfied by an event_in order to be considered a match. If another condition has already been_set, the new one is going to be combined with the previous with a_logical {@code AND}. In other case, this is going to be the only_condition.__@param condition The condition as an {@link IterativeCondition}._@return The pattern with the new condition is set.;public Pattern<T, F> where(IterativeCondition<F> condition) {_		Preconditions.checkNotNull(condition, "The condition cannot be null.")___		ClosureCleaner.clean(condition, true)__		if (this.condition == null) {_			this.condition = condition__		} else {_			this.condition = new AndCondition<>(this.condition, condition)__		}_		return this__	};adds,a,condition,that,has,to,be,satisfied,by,an,event,in,order,to,be,considered,a,match,if,another,condition,has,already,been,set,the,new,one,is,going,to,be,combined,with,the,previous,with,a,logical,code,and,in,other,case,this,is,going,to,be,the,only,condition,param,condition,the,condition,as,an,link,iterative,condition,return,the,pattern,with,the,new,condition,is,set;public,pattern,t,f,where,iterative,condition,f,condition,preconditions,check,not,null,condition,the,condition,cannot,be,null,closure,cleaner,clean,condition,true,if,this,condition,null,this,condition,condition,else,this,condition,new,and,condition,this,condition,condition,return,this
Pattern -> public Pattern<T, F> where(IterativeCondition<F> condition);1499244360;Adds a condition that has to be satisfied by an event_in order to be considered a match. If another condition has already been_set, the new one is going to be combined with the previous with a_logical {@code AND}. In other case, this is going to be the only_condition.__@param condition The condition as an {@link IterativeCondition}._@return The pattern with the new condition is set.;public Pattern<T, F> where(IterativeCondition<F> condition) {_		Preconditions.checkNotNull(condition, "The condition cannot be null.")___		ClosureCleaner.clean(condition, true)__		if (this.condition == null) {_			this.condition = condition__		} else {_			this.condition = new AndCondition<>(this.condition, condition)__		}_		return this__	};adds,a,condition,that,has,to,be,satisfied,by,an,event,in,order,to,be,considered,a,match,if,another,condition,has,already,been,set,the,new,one,is,going,to,be,combined,with,the,previous,with,a,logical,code,and,in,other,case,this,is,going,to,be,the,only,condition,param,condition,the,condition,as,an,link,iterative,condition,return,the,pattern,with,the,new,condition,is,set;public,pattern,t,f,where,iterative,condition,f,condition,preconditions,check,not,null,condition,the,condition,cannot,be,null,closure,cleaner,clean,condition,true,if,this,condition,null,this,condition,condition,else,this,condition,new,and,condition,this,condition,condition,return,this
Pattern -> public Pattern<T, F> where(IterativeCondition<F> condition);1499248439;Adds a condition that has to be satisfied by an event_in order to be considered a match. If another condition has already been_set, the new one is going to be combined with the previous with a_logical {@code AND}. In other case, this is going to be the only_condition.__@param condition The condition as an {@link IterativeCondition}._@return The pattern with the new condition is set.;public Pattern<T, F> where(IterativeCondition<F> condition) {_		Preconditions.checkNotNull(condition, "The condition cannot be null.")___		ClosureCleaner.clean(condition, true)__		if (this.condition == null) {_			this.condition = condition__		} else {_			this.condition = new AndCondition<>(this.condition, condition)__		}_		return this__	};adds,a,condition,that,has,to,be,satisfied,by,an,event,in,order,to,be,considered,a,match,if,another,condition,has,already,been,set,the,new,one,is,going,to,be,combined,with,the,previous,with,a,logical,code,and,in,other,case,this,is,going,to,be,the,only,condition,param,condition,the,condition,as,an,link,iterative,condition,return,the,pattern,with,the,new,condition,is,set;public,pattern,t,f,where,iterative,condition,f,condition,preconditions,check,not,null,condition,the,condition,cannot,be,null,closure,cleaner,clean,condition,true,if,this,condition,null,this,condition,condition,else,this,condition,new,and,condition,this,condition,condition,return,this
Pattern -> public Pattern<T, F> where(IterativeCondition<F> condition);1503420807;Adds a condition that has to be satisfied by an event_in order to be considered a match. If another condition has already been_set, the new one is going to be combined with the previous with a_logical {@code AND}. In other case, this is going to be the only_condition.__@param condition The condition as an {@link IterativeCondition}._@return The pattern with the new condition is set.;public Pattern<T, F> where(IterativeCondition<F> condition) {_		Preconditions.checkNotNull(condition, "The condition cannot be null.")___		ClosureCleaner.clean(condition, true)__		if (this.condition == null) {_			this.condition = condition__		} else {_			this.condition = new AndCondition<>(this.condition, condition)__		}_		return this__	};adds,a,condition,that,has,to,be,satisfied,by,an,event,in,order,to,be,considered,a,match,if,another,condition,has,already,been,set,the,new,one,is,going,to,be,combined,with,the,previous,with,a,logical,code,and,in,other,case,this,is,going,to,be,the,only,condition,param,condition,the,condition,as,an,link,iterative,condition,return,the,pattern,with,the,new,condition,is,set;public,pattern,t,f,where,iterative,condition,f,condition,preconditions,check,not,null,condition,the,condition,cannot,be,null,closure,cleaner,clean,condition,true,if,this,condition,null,this,condition,condition,else,this,condition,new,and,condition,this,condition,condition,return,this
Pattern -> public Pattern<T, F> where(IterativeCondition<F> condition);1503558242;Adds a condition that has to be satisfied by an event_in order to be considered a match. If another condition has already been_set, the new one is going to be combined with the previous with a_logical {@code AND}. In other case, this is going to be the only_condition.__@param condition The condition as an {@link IterativeCondition}._@return The pattern with the new condition is set.;public Pattern<T, F> where(IterativeCondition<F> condition) {_		Preconditions.checkNotNull(condition, "The condition cannot be null.")___		ClosureCleaner.clean(condition, true)__		if (this.condition == null) {_			this.condition = condition__		} else {_			this.condition = new AndCondition<>(this.condition, condition)__		}_		return this__	};adds,a,condition,that,has,to,be,satisfied,by,an,event,in,order,to,be,considered,a,match,if,another,condition,has,already,been,set,the,new,one,is,going,to,be,combined,with,the,previous,with,a,logical,code,and,in,other,case,this,is,going,to,be,the,only,condition,param,condition,the,condition,as,an,link,iterative,condition,return,the,pattern,with,the,new,condition,is,set;public,pattern,t,f,where,iterative,condition,f,condition,preconditions,check,not,null,condition,the,condition,cannot,be,null,closure,cleaner,clean,condition,true,if,this,condition,null,this,condition,condition,else,this,condition,new,and,condition,this,condition,condition,return,this
Pattern -> public Pattern<T, F> where(IterativeCondition<F> condition);1504268438;Adds a condition that has to be satisfied by an event_in order to be considered a match. If another condition has already been_set, the new one is going to be combined with the previous with a_logical {@code AND}. In other case, this is going to be the only_condition.__@param condition The condition as an {@link IterativeCondition}._@return The pattern with the new condition is set.;public Pattern<T, F> where(IterativeCondition<F> condition) {_		Preconditions.checkNotNull(condition, "The condition cannot be null.")___		ClosureCleaner.clean(condition, true)__		if (this.condition == null) {_			this.condition = condition__		} else {_			this.condition = new AndCondition<>(this.condition, condition)__		}_		return this__	};adds,a,condition,that,has,to,be,satisfied,by,an,event,in,order,to,be,considered,a,match,if,another,condition,has,already,been,set,the,new,one,is,going,to,be,combined,with,the,previous,with,a,logical,code,and,in,other,case,this,is,going,to,be,the,only,condition,param,condition,the,condition,as,an,link,iterative,condition,return,the,pattern,with,the,new,condition,is,set;public,pattern,t,f,where,iterative,condition,f,condition,preconditions,check,not,null,condition,the,condition,cannot,be,null,closure,cleaner,clean,condition,true,if,this,condition,null,this,condition,condition,else,this,condition,new,and,condition,this,condition,condition,return,this
Pattern -> public Pattern<T, F> where(IterativeCondition<F> condition);1530798894;Adds a condition that has to be satisfied by an event_in order to be considered a match. If another condition has already been_set, the new one is going to be combined with the previous with a_logical {@code AND}. In other case, this is going to be the only_condition.__@param condition The condition as an {@link IterativeCondition}._@return The pattern with the new condition is set.;public Pattern<T, F> where(IterativeCondition<F> condition) {_		Preconditions.checkNotNull(condition, "The condition cannot be null.")___		ClosureCleaner.clean(condition, true)__		if (this.condition == null) {_			this.condition = condition__		} else {_			this.condition = new AndCondition<>(this.condition, condition)__		}_		return this__	};adds,a,condition,that,has,to,be,satisfied,by,an,event,in,order,to,be,considered,a,match,if,another,condition,has,already,been,set,the,new,one,is,going,to,be,combined,with,the,previous,with,a,logical,code,and,in,other,case,this,is,going,to,be,the,only,condition,param,condition,the,condition,as,an,link,iterative,condition,return,the,pattern,with,the,new,condition,is,set;public,pattern,t,f,where,iterative,condition,f,condition,preconditions,check,not,null,condition,the,condition,cannot,be,null,closure,cleaner,clean,condition,true,if,this,condition,null,this,condition,condition,else,this,condition,new,and,condition,this,condition,condition,return,this
Pattern -> public Pattern<T, F> where(IterativeCondition<F> condition);1540208358;Adds a condition that has to be satisfied by an event_in order to be considered a match. If another condition has already been_set, the new one is going to be combined with the previous with a_logical {@code AND}. In other case, this is going to be the only_condition.__@param condition The condition as an {@link IterativeCondition}._@return The pattern with the new condition is set.;public Pattern<T, F> where(IterativeCondition<F> condition) {_		Preconditions.checkNotNull(condition, "The condition cannot be null.")___		ClosureCleaner.clean(condition, true)__		if (this.condition == null) {_			this.condition = condition__		} else {_			this.condition = new AndCondition<>(this.condition, condition)__		}_		return this__	};adds,a,condition,that,has,to,be,satisfied,by,an,event,in,order,to,be,considered,a,match,if,another,condition,has,already,been,set,the,new,one,is,going,to,be,combined,with,the,previous,with,a,logical,code,and,in,other,case,this,is,going,to,be,the,only,condition,param,condition,the,condition,as,an,link,iterative,condition,return,the,pattern,with,the,new,condition,is,set;public,pattern,t,f,where,iterative,condition,f,condition,preconditions,check,not,null,condition,the,condition,cannot,be,null,closure,cleaner,clean,condition,true,if,this,condition,null,this,condition,condition,else,this,condition,new,and,condition,this,condition,condition,return,this
Pattern -> public Pattern<T, F> where(IterativeCondition<F> condition);1543413704;Adds a condition that has to be satisfied by an event_in order to be considered a match. If another condition has already been_set, the new one is going to be combined with the previous with a_logical {@code AND}. In other case, this is going to be the only_condition.__@param condition The condition as an {@link IterativeCondition}._@return The pattern with the new condition is set.;public Pattern<T, F> where(IterativeCondition<F> condition) {_		Preconditions.checkNotNull(condition, "The condition cannot be null.")___		ClosureCleaner.clean(condition, true)__		if (this.condition == null) {_			this.condition = condition__		} else {_			this.condition = new RichAndCondition<>(this.condition, condition)__		}_		return this__	};adds,a,condition,that,has,to,be,satisfied,by,an,event,in,order,to,be,considered,a,match,if,another,condition,has,already,been,set,the,new,one,is,going,to,be,combined,with,the,previous,with,a,logical,code,and,in,other,case,this,is,going,to,be,the,only,condition,param,condition,the,condition,as,an,link,iterative,condition,return,the,pattern,with,the,new,condition,is,set;public,pattern,t,f,where,iterative,condition,f,condition,preconditions,check,not,null,condition,the,condition,cannot,be,null,closure,cleaner,clean,condition,true,if,this,condition,null,this,condition,condition,else,this,condition,new,rich,and,condition,this,condition,condition,return,this
Pattern -> public Pattern<T, F> within(Time windowTime);1454421848;Defines the maximum time interval for a matching pattern. This means that the time gap_between first and the last event must not be longer than the window time.__@param windowTime Time of the matching window_@return The same pattenr operator with the new window length;public Pattern<T, F> within(Time windowTime) {_		if (windowTime != null) {_			this.windowTime = windowTime__		}__		return this__	};defines,the,maximum,time,interval,for,a,matching,pattern,this,means,that,the,time,gap,between,first,and,the,last,event,must,not,be,longer,than,the,window,time,param,window,time,time,of,the,matching,window,return,the,same,pattenr,operator,with,the,new,window,length;public,pattern,t,f,within,time,window,time,if,window,time,null,this,window,time,window,time,return,this
Pattern -> public Pattern<T, F> within(Time windowTime);1456442894;Defines the maximum time interval for a matching pattern. This means that the time gap_between first and the last event must not be longer than the window time.__@param windowTime Time of the matching window_@return The same pattenr operator with the new window length;public Pattern<T, F> within(Time windowTime) {_		if (windowTime != null) {_			this.windowTime = windowTime__		}__		return this__	};defines,the,maximum,time,interval,for,a,matching,pattern,this,means,that,the,time,gap,between,first,and,the,last,event,must,not,be,longer,than,the,window,time,param,window,time,time,of,the,matching,window,return,the,same,pattenr,operator,with,the,new,window,length;public,pattern,t,f,within,time,window,time,if,window,time,null,this,window,time,window,time,return,this
Pattern -> public Pattern<T, F> within(Time windowTime);1461689259;Defines the maximum time interval for a matching pattern. This means that the time gap_between first and the last event must not be longer than the window time.__@param windowTime Time of the matching window_@return The same pattenr operator with the new window length;public Pattern<T, F> within(Time windowTime) {_		if (windowTime != null) {_			this.windowTime = windowTime__		}__		return this__	};defines,the,maximum,time,interval,for,a,matching,pattern,this,means,that,the,time,gap,between,first,and,the,last,event,must,not,be,longer,than,the,window,time,param,window,time,time,of,the,matching,window,return,the,same,pattenr,operator,with,the,new,window,length;public,pattern,t,f,within,time,window,time,if,window,time,null,this,window,time,window,time,return,this
Pattern -> public Pattern<T, F> within(Time windowTime);1471613162;Defines the maximum time interval for a matching pattern. This means that the time gap_between first and the last event must not be longer than the window time.__@param windowTime Time of the matching window_@return The same pattenr operator with the new window length;public Pattern<T, F> within(Time windowTime) {_		if (windowTime != null) {_			this.windowTime = windowTime__		}__		return this__	};defines,the,maximum,time,interval,for,a,matching,pattern,this,means,that,the,time,gap,between,first,and,the,last,event,must,not,be,longer,than,the,window,time,param,window,time,time,of,the,matching,window,return,the,same,pattenr,operator,with,the,new,window,length;public,pattern,t,f,within,time,window,time,if,window,time,null,this,window,time,window,time,return,this
Pattern -> public Pattern<T, F> within(Time windowTime);1471614454;Defines the maximum time interval for a matching pattern. This means that the time gap_between first and the last event must not be longer than the window time.__@param windowTime Time of the matching window_@return The same pattenr operator with the new window length;public Pattern<T, F> within(Time windowTime) {_		if (windowTime != null) {_			this.windowTime = windowTime__		}__		return this__	};defines,the,maximum,time,interval,for,a,matching,pattern,this,means,that,the,time,gap,between,first,and,the,last,event,must,not,be,longer,than,the,window,time,param,window,time,time,of,the,matching,window,return,the,same,pattenr,operator,with,the,new,window,length;public,pattern,t,f,within,time,window,time,if,window,time,null,this,window,time,window,time,return,this
Pattern -> public Pattern<T, F> within(Time windowTime);1488270949;Defines the maximum time interval for a matching pattern. This means that the time gap_between first and the last event must not be longer than the window time.__@param windowTime Time of the matching window_@return The same pattenr operator with the new window length;public Pattern<T, F> within(Time windowTime) {_		if (windowTime != null) {_			this.windowTime = windowTime__		}__		return this__	};defines,the,maximum,time,interval,for,a,matching,pattern,this,means,that,the,time,gap,between,first,and,the,last,event,must,not,be,longer,than,the,window,time,param,window,time,time,of,the,matching,window,return,the,same,pattenr,operator,with,the,new,window,length;public,pattern,t,f,within,time,window,time,if,window,time,null,this,window,time,window,time,return,this
Pattern -> public Pattern<T, F> within(Time windowTime);1490262475;Defines the maximum time interval for a matching pattern. This means that the time gap_between first and the last event must not be longer than the window time.__@param windowTime Time of the matching window_@return The same pattenr operator with the new window length;public Pattern<T, F> within(Time windowTime) {_		if (windowTime != null) {_			this.windowTime = windowTime__		}__		return this__	};defines,the,maximum,time,interval,for,a,matching,pattern,this,means,that,the,time,gap,between,first,and,the,last,event,must,not,be,longer,than,the,window,time,param,window,time,time,of,the,matching,window,return,the,same,pattenr,operator,with,the,new,window,length;public,pattern,t,f,within,time,window,time,if,window,time,null,this,window,time,window,time,return,this
Pattern -> public Pattern<T, F> within(Time windowTime);1490638274;Defines the maximum time interval for a matching pattern. This means that the time gap_between first and the last event must not be longer than the window time.__@param windowTime Time of the matching window_@return The same pattenr operator with the new window length;public Pattern<T, F> within(Time windowTime) {_		if (windowTime != null) {_			this.windowTime = windowTime__		}__		return this__	};defines,the,maximum,time,interval,for,a,matching,pattern,this,means,that,the,time,gap,between,first,and,the,last,event,must,not,be,longer,than,the,window,time,param,window,time,time,of,the,matching,window,return,the,same,pattenr,operator,with,the,new,window,length;public,pattern,t,f,within,time,window,time,if,window,time,null,this,window,time,window,time,return,this
Pattern -> public Pattern<T, F> within(Time windowTime);1490862259;Defines the maximum time interval for a matching pattern. This means that the time gap_between first and the last event must not be longer than the window time.__@param windowTime Time of the matching window_@return The same pattenr operator with the new window length;public Pattern<T, F> within(Time windowTime) {_		if (windowTime != null) {_			this.windowTime = windowTime__		}__		return this__	};defines,the,maximum,time,interval,for,a,matching,pattern,this,means,that,the,time,gap,between,first,and,the,last,event,must,not,be,longer,than,the,window,time,param,window,time,time,of,the,matching,window,return,the,same,pattenr,operator,with,the,new,window,length;public,pattern,t,f,within,time,window,time,if,window,time,null,this,window,time,window,time,return,this
Pattern -> public Pattern<T, F> within(Time windowTime);1491647251;Defines the maximum time interval for a matching pattern. This means that the time gap_between first and the last event must not be longer than the window time.__@param windowTime Time of the matching window_@return The same pattern operator with the new window length;public Pattern<T, F> within(Time windowTime) {_		if (windowTime != null) {_			this.windowTime = windowTime__		}__		return this__	};defines,the,maximum,time,interval,for,a,matching,pattern,this,means,that,the,time,gap,between,first,and,the,last,event,must,not,be,longer,than,the,window,time,param,window,time,time,of,the,matching,window,return,the,same,pattern,operator,with,the,new,window,length;public,pattern,t,f,within,time,window,time,if,window,time,null,this,window,time,window,time,return,this
Pattern -> public Pattern<T, F> within(Time windowTime);1493201751;Defines the maximum time interval in which a matching pattern has to be completed in_order to be considered valid. This interval corresponds to the maximum time gap between first_and the last event.__@param windowTime Time of the matching window_@return The same pattern operator with the new window length;public Pattern<T, F> within(Time windowTime) {_		if (windowTime != null) {_			this.windowTime = windowTime__		}__		return this__	};defines,the,maximum,time,interval,in,which,a,matching,pattern,has,to,be,completed,in,order,to,be,considered,valid,this,interval,corresponds,to,the,maximum,time,gap,between,first,and,the,last,event,param,window,time,time,of,the,matching,window,return,the,same,pattern,operator,with,the,new,window,length;public,pattern,t,f,within,time,window,time,if,window,time,null,this,window,time,window,time,return,this
Pattern -> public Pattern<T, F> within(Time windowTime);1493201753;Defines the maximum time interval in which a matching pattern has to be completed in_order to be considered valid. This interval corresponds to the maximum time gap between first_and the last event.__@param windowTime Time of the matching window_@return The same pattern operator with the new window length;public Pattern<T, F> within(Time windowTime) {_		if (windowTime != null) {_			this.windowTime = windowTime__		}__		return this__	};defines,the,maximum,time,interval,in,which,a,matching,pattern,has,to,be,completed,in,order,to,be,considered,valid,this,interval,corresponds,to,the,maximum,time,gap,between,first,and,the,last,event,param,window,time,time,of,the,matching,window,return,the,same,pattern,operator,with,the,new,window,length;public,pattern,t,f,within,time,window,time,if,window,time,null,this,window,time,window,time,return,this
Pattern -> public Pattern<T, F> within(Time windowTime);1493382517;Defines the maximum time interval in which a matching pattern has to be completed in_order to be considered valid. This interval corresponds to the maximum time gap between first_and the last event.__@param windowTime Time of the matching window_@return The same pattern operator with the new window length;public Pattern<T, F> within(Time windowTime) {_		if (windowTime != null) {_			this.windowTime = windowTime__		}__		return this__	};defines,the,maximum,time,interval,in,which,a,matching,pattern,has,to,be,completed,in,order,to,be,considered,valid,this,interval,corresponds,to,the,maximum,time,gap,between,first,and,the,last,event,param,window,time,time,of,the,matching,window,return,the,same,pattern,operator,with,the,new,window,length;public,pattern,t,f,within,time,window,time,if,window,time,null,this,window,time,window,time,return,this
Pattern -> public Pattern<T, F> within(Time windowTime);1493906327;Defines the maximum time interval in which a matching pattern has to be completed in_order to be considered valid. This interval corresponds to the maximum time gap between first_and the last event.__@param windowTime Time of the matching window_@return The same pattern operator with the new window length;public Pattern<T, F> within(Time windowTime) {_		if (windowTime != null) {_			this.windowTime = windowTime__		}__		return this__	};defines,the,maximum,time,interval,in,which,a,matching,pattern,has,to,be,completed,in,order,to,be,considered,valid,this,interval,corresponds,to,the,maximum,time,gap,between,first,and,the,last,event,param,window,time,time,of,the,matching,window,return,the,same,pattern,operator,with,the,new,window,length;public,pattern,t,f,within,time,window,time,if,window,time,null,this,window,time,window,time,return,this
Pattern -> public Pattern<T, F> within(Time windowTime);1493985576;Defines the maximum time interval in which a matching pattern has to be completed in_order to be considered valid. This interval corresponds to the maximum time gap between first_and the last event.__@param windowTime Time of the matching window_@return The same pattern operator with the new window length;public Pattern<T, F> within(Time windowTime) {_		if (windowTime != null) {_			this.windowTime = windowTime__		}__		return this__	};defines,the,maximum,time,interval,in,which,a,matching,pattern,has,to,be,completed,in,order,to,be,considered,valid,this,interval,corresponds,to,the,maximum,time,gap,between,first,and,the,last,event,param,window,time,time,of,the,matching,window,return,the,same,pattern,operator,with,the,new,window,length;public,pattern,t,f,within,time,window,time,if,window,time,null,this,window,time,window,time,return,this
Pattern -> public Pattern<T, F> within(Time windowTime);1493997908;Defines the maximum time interval in which a matching pattern has to be completed in_order to be considered valid. This interval corresponds to the maximum time gap between first_and the last event.__@param windowTime Time of the matching window_@return The same pattern operator with the new window length;public Pattern<T, F> within(Time windowTime) {_		if (windowTime != null) {_			this.windowTime = windowTime__		}__		return this__	};defines,the,maximum,time,interval,in,which,a,matching,pattern,has,to,be,completed,in,order,to,be,considered,valid,this,interval,corresponds,to,the,maximum,time,gap,between,first,and,the,last,event,param,window,time,time,of,the,matching,window,return,the,same,pattern,operator,with,the,new,window,length;public,pattern,t,f,within,time,window,time,if,window,time,null,this,window,time,window,time,return,this
Pattern -> public Pattern<T, F> within(Time windowTime);1495961498;Defines the maximum time interval in which a matching pattern has to be completed in_order to be considered valid. This interval corresponds to the maximum time gap between first_and the last event.__@param windowTime Time of the matching window_@return The same pattern operator with the new window length;public Pattern<T, F> within(Time windowTime) {_		if (windowTime != null) {_			this.windowTime = windowTime__		}__		return this__	};defines,the,maximum,time,interval,in,which,a,matching,pattern,has,to,be,completed,in,order,to,be,considered,valid,this,interval,corresponds,to,the,maximum,time,gap,between,first,and,the,last,event,param,window,time,time,of,the,matching,window,return,the,same,pattern,operator,with,the,new,window,length;public,pattern,t,f,within,time,window,time,if,window,time,null,this,window,time,window,time,return,this
Pattern -> public Pattern<T, F> within(Time windowTime);1497940477;Defines the maximum time interval in which a matching pattern has to be completed in_order to be considered valid. This interval corresponds to the maximum time gap between first_and the last event.__@param windowTime Time of the matching window_@return The same pattern operator with the new window length;public Pattern<T, F> within(Time windowTime) {_		if (windowTime != null) {_			this.windowTime = windowTime__		}__		return this__	};defines,the,maximum,time,interval,in,which,a,matching,pattern,has,to,be,completed,in,order,to,be,considered,valid,this,interval,corresponds,to,the,maximum,time,gap,between,first,and,the,last,event,param,window,time,time,of,the,matching,window,return,the,same,pattern,operator,with,the,new,window,length;public,pattern,t,f,within,time,window,time,if,window,time,null,this,window,time,window,time,return,this
Pattern -> public Pattern<T, F> within(Time windowTime);1498548074;Defines the maximum time interval in which a matching pattern has to be completed in_order to be considered valid. This interval corresponds to the maximum time gap between first_and the last event.__@param windowTime Time of the matching window_@return The same pattern operator with the new window length;public Pattern<T, F> within(Time windowTime) {_		if (windowTime != null) {_			this.windowTime = windowTime__		}__		return this__	};defines,the,maximum,time,interval,in,which,a,matching,pattern,has,to,be,completed,in,order,to,be,considered,valid,this,interval,corresponds,to,the,maximum,time,gap,between,first,and,the,last,event,param,window,time,time,of,the,matching,window,return,the,same,pattern,operator,with,the,new,window,length;public,pattern,t,f,within,time,window,time,if,window,time,null,this,window,time,window,time,return,this
Pattern -> public Pattern<T, F> within(Time windowTime);1499244360;Defines the maximum time interval in which a matching pattern has to be completed in_order to be considered valid. This interval corresponds to the maximum time gap between first_and the last event.__@param windowTime Time of the matching window_@return The same pattern operator with the new window length;public Pattern<T, F> within(Time windowTime) {_		if (windowTime != null) {_			this.windowTime = windowTime__		}__		return this__	};defines,the,maximum,time,interval,in,which,a,matching,pattern,has,to,be,completed,in,order,to,be,considered,valid,this,interval,corresponds,to,the,maximum,time,gap,between,first,and,the,last,event,param,window,time,time,of,the,matching,window,return,the,same,pattern,operator,with,the,new,window,length;public,pattern,t,f,within,time,window,time,if,window,time,null,this,window,time,window,time,return,this
Pattern -> public Pattern<T, F> within(Time windowTime);1499248439;Defines the maximum time interval in which a matching pattern has to be completed in_order to be considered valid. This interval corresponds to the maximum time gap between first_and the last event.__@param windowTime Time of the matching window_@return The same pattern operator with the new window length;public Pattern<T, F> within(Time windowTime) {_		if (windowTime != null) {_			this.windowTime = windowTime__		}__		return this__	};defines,the,maximum,time,interval,in,which,a,matching,pattern,has,to,be,completed,in,order,to,be,considered,valid,this,interval,corresponds,to,the,maximum,time,gap,between,first,and,the,last,event,param,window,time,time,of,the,matching,window,return,the,same,pattern,operator,with,the,new,window,length;public,pattern,t,f,within,time,window,time,if,window,time,null,this,window,time,window,time,return,this
Pattern -> public Pattern<T, F> within(Time windowTime);1503420807;Defines the maximum time interval in which a matching pattern has to be completed in_order to be considered valid. This interval corresponds to the maximum time gap between first_and the last event.__@param windowTime Time of the matching window_@return The same pattern operator with the new window length;public Pattern<T, F> within(Time windowTime) {_		if (windowTime != null) {_			this.windowTime = windowTime__		}__		return this__	};defines,the,maximum,time,interval,in,which,a,matching,pattern,has,to,be,completed,in,order,to,be,considered,valid,this,interval,corresponds,to,the,maximum,time,gap,between,first,and,the,last,event,param,window,time,time,of,the,matching,window,return,the,same,pattern,operator,with,the,new,window,length;public,pattern,t,f,within,time,window,time,if,window,time,null,this,window,time,window,time,return,this
Pattern -> public Pattern<T, F> within(Time windowTime);1503558242;Defines the maximum time interval in which a matching pattern has to be completed in_order to be considered valid. This interval corresponds to the maximum time gap between first_and the last event.__@param windowTime Time of the matching window_@return The same pattern operator with the new window length;public Pattern<T, F> within(Time windowTime) {_		if (windowTime != null) {_			this.windowTime = windowTime__		}__		return this__	};defines,the,maximum,time,interval,in,which,a,matching,pattern,has,to,be,completed,in,order,to,be,considered,valid,this,interval,corresponds,to,the,maximum,time,gap,between,first,and,the,last,event,param,window,time,time,of,the,matching,window,return,the,same,pattern,operator,with,the,new,window,length;public,pattern,t,f,within,time,window,time,if,window,time,null,this,window,time,window,time,return,this
Pattern -> public Pattern<T, F> within(Time windowTime);1504268438;Defines the maximum time interval in which a matching pattern has to be completed in_order to be considered valid. This interval corresponds to the maximum time gap between first_and the last event.__@param windowTime Time of the matching window_@return The same pattern operator with the new window length;public Pattern<T, F> within(Time windowTime) {_		if (windowTime != null) {_			this.windowTime = windowTime__		}__		return this__	};defines,the,maximum,time,interval,in,which,a,matching,pattern,has,to,be,completed,in,order,to,be,considered,valid,this,interval,corresponds,to,the,maximum,time,gap,between,first,and,the,last,event,param,window,time,time,of,the,matching,window,return,the,same,pattern,operator,with,the,new,window,length;public,pattern,t,f,within,time,window,time,if,window,time,null,this,window,time,window,time,return,this
Pattern -> public Pattern<T, F> within(Time windowTime);1530798894;Defines the maximum time interval in which a matching pattern has to be completed in_order to be considered valid. This interval corresponds to the maximum time gap between first_and the last event.__@param windowTime Time of the matching window_@return The same pattern operator with the new window length;public Pattern<T, F> within(Time windowTime) {_		if (windowTime != null) {_			this.windowTime = windowTime__		}__		return this__	};defines,the,maximum,time,interval,in,which,a,matching,pattern,has,to,be,completed,in,order,to,be,considered,valid,this,interval,corresponds,to,the,maximum,time,gap,between,first,and,the,last,event,param,window,time,time,of,the,matching,window,return,the,same,pattern,operator,with,the,new,window,length;public,pattern,t,f,within,time,window,time,if,window,time,null,this,window,time,window,time,return,this
Pattern -> public Pattern<T, F> within(Time windowTime);1540208358;Defines the maximum time interval in which a matching pattern has to be completed in_order to be considered valid. This interval corresponds to the maximum time gap between first_and the last event.__@param windowTime Time of the matching window_@return The same pattern operator with the new window length;public Pattern<T, F> within(Time windowTime) {_		if (windowTime != null) {_			this.windowTime = windowTime__		}__		return this__	};defines,the,maximum,time,interval,in,which,a,matching,pattern,has,to,be,completed,in,order,to,be,considered,valid,this,interval,corresponds,to,the,maximum,time,gap,between,first,and,the,last,event,param,window,time,time,of,the,matching,window,return,the,same,pattern,operator,with,the,new,window,length;public,pattern,t,f,within,time,window,time,if,window,time,null,this,window,time,window,time,return,this
Pattern -> public Pattern<T, F> within(Time windowTime);1543413704;Defines the maximum time interval in which a matching pattern has to be completed in_order to be considered valid. This interval corresponds to the maximum time gap between first_and the last event.__@param windowTime Time of the matching window_@return The same pattern operator with the new window length;public Pattern<T, F> within(Time windowTime) {_		if (windowTime != null) {_			this.windowTime = windowTime__		}__		return this__	};defines,the,maximum,time,interval,in,which,a,matching,pattern,has,to,be,completed,in,order,to,be,considered,valid,this,interval,corresponds,to,the,maximum,time,gap,between,first,and,the,last,event,param,window,time,time,of,the,matching,window,return,the,same,pattern,operator,with,the,new,window,length;public,pattern,t,f,within,time,window,time,if,window,time,null,this,window,time,window,time,return,this
Pattern -> public Pattern<T, F> until(IterativeCondition<F> untilCondition);1498548074;Applies a stop condition for a looping state. It allows cleaning the underlying state.__@param untilCondition a condition an event has to satisfy to stop collecting events into looping state_@return The same pattern with applied untilCondition;public Pattern<T, F> until(IterativeCondition<F> untilCondition) {_		Preconditions.checkNotNull(untilCondition, "The condition cannot be null")___		if (this.untilCondition != null) {_			throw new MalformedPatternException("Only one until condition can be applied.")__		}__		if (!quantifier.hasProperty(Quantifier.QuantifierProperty.LOOPING)) {_			throw new MalformedPatternException("The until condition is only applicable to looping states.")__		}__		ClosureCleaner.clean(untilCondition, true)__		this.untilCondition = untilCondition___		return this__	};applies,a,stop,condition,for,a,looping,state,it,allows,cleaning,the,underlying,state,param,until,condition,a,condition,an,event,has,to,satisfy,to,stop,collecting,events,into,looping,state,return,the,same,pattern,with,applied,until,condition;public,pattern,t,f,until,iterative,condition,f,until,condition,preconditions,check,not,null,until,condition,the,condition,cannot,be,null,if,this,until,condition,null,throw,new,malformed,pattern,exception,only,one,until,condition,can,be,applied,if,quantifier,has,property,quantifier,quantifier,property,looping,throw,new,malformed,pattern,exception,the,until,condition,is,only,applicable,to,looping,states,closure,cleaner,clean,until,condition,true,this,until,condition,until,condition,return,this
Pattern -> public Pattern<T, F> until(IterativeCondition<F> untilCondition);1499244360;Applies a stop condition for a looping state. It allows cleaning the underlying state.__@param untilCondition a condition an event has to satisfy to stop collecting events into looping state_@return The same pattern with applied untilCondition;public Pattern<T, F> until(IterativeCondition<F> untilCondition) {_		Preconditions.checkNotNull(untilCondition, "The condition cannot be null")___		if (this.untilCondition != null) {_			throw new MalformedPatternException("Only one until condition can be applied.")__		}__		if (!quantifier.hasProperty(Quantifier.QuantifierProperty.LOOPING)) {_			throw new MalformedPatternException("The until condition is only applicable to looping states.")__		}__		ClosureCleaner.clean(untilCondition, true)__		this.untilCondition = untilCondition___		return this__	};applies,a,stop,condition,for,a,looping,state,it,allows,cleaning,the,underlying,state,param,until,condition,a,condition,an,event,has,to,satisfy,to,stop,collecting,events,into,looping,state,return,the,same,pattern,with,applied,until,condition;public,pattern,t,f,until,iterative,condition,f,until,condition,preconditions,check,not,null,until,condition,the,condition,cannot,be,null,if,this,until,condition,null,throw,new,malformed,pattern,exception,only,one,until,condition,can,be,applied,if,quantifier,has,property,quantifier,quantifier,property,looping,throw,new,malformed,pattern,exception,the,until,condition,is,only,applicable,to,looping,states,closure,cleaner,clean,until,condition,true,this,until,condition,until,condition,return,this
Pattern -> public Pattern<T, F> until(IterativeCondition<F> untilCondition);1499248439;Applies a stop condition for a looping state. It allows cleaning the underlying state.__@param untilCondition a condition an event has to satisfy to stop collecting events into looping state_@return The same pattern with applied untilCondition;public Pattern<T, F> until(IterativeCondition<F> untilCondition) {_		Preconditions.checkNotNull(untilCondition, "The condition cannot be null")___		if (this.untilCondition != null) {_			throw new MalformedPatternException("Only one until condition can be applied.")__		}__		if (!quantifier.hasProperty(Quantifier.QuantifierProperty.LOOPING)) {_			throw new MalformedPatternException("The until condition is only applicable to looping states.")__		}__		ClosureCleaner.clean(untilCondition, true)__		this.untilCondition = untilCondition___		return this__	};applies,a,stop,condition,for,a,looping,state,it,allows,cleaning,the,underlying,state,param,until,condition,a,condition,an,event,has,to,satisfy,to,stop,collecting,events,into,looping,state,return,the,same,pattern,with,applied,until,condition;public,pattern,t,f,until,iterative,condition,f,until,condition,preconditions,check,not,null,until,condition,the,condition,cannot,be,null,if,this,until,condition,null,throw,new,malformed,pattern,exception,only,one,until,condition,can,be,applied,if,quantifier,has,property,quantifier,quantifier,property,looping,throw,new,malformed,pattern,exception,the,until,condition,is,only,applicable,to,looping,states,closure,cleaner,clean,until,condition,true,this,until,condition,until,condition,return,this
Pattern -> public Pattern<T, F> until(IterativeCondition<F> untilCondition);1503420807;Applies a stop condition for a looping state. It allows cleaning the underlying state.__@param untilCondition a condition an event has to satisfy to stop collecting events into looping state_@return The same pattern with applied untilCondition;public Pattern<T, F> until(IterativeCondition<F> untilCondition) {_		Preconditions.checkNotNull(untilCondition, "The condition cannot be null")___		if (this.untilCondition != null) {_			throw new MalformedPatternException("Only one until condition can be applied.")__		}__		if (!quantifier.hasProperty(Quantifier.QuantifierProperty.LOOPING)) {_			throw new MalformedPatternException("The until condition is only applicable to looping states.")__		}__		ClosureCleaner.clean(untilCondition, true)__		this.untilCondition = untilCondition___		return this__	};applies,a,stop,condition,for,a,looping,state,it,allows,cleaning,the,underlying,state,param,until,condition,a,condition,an,event,has,to,satisfy,to,stop,collecting,events,into,looping,state,return,the,same,pattern,with,applied,until,condition;public,pattern,t,f,until,iterative,condition,f,until,condition,preconditions,check,not,null,until,condition,the,condition,cannot,be,null,if,this,until,condition,null,throw,new,malformed,pattern,exception,only,one,until,condition,can,be,applied,if,quantifier,has,property,quantifier,quantifier,property,looping,throw,new,malformed,pattern,exception,the,until,condition,is,only,applicable,to,looping,states,closure,cleaner,clean,until,condition,true,this,until,condition,until,condition,return,this
Pattern -> public Pattern<T, F> until(IterativeCondition<F> untilCondition);1503558242;Applies a stop condition for a looping state. It allows cleaning the underlying state.__@param untilCondition a condition an event has to satisfy to stop collecting events into looping state_@return The same pattern with applied untilCondition;public Pattern<T, F> until(IterativeCondition<F> untilCondition) {_		Preconditions.checkNotNull(untilCondition, "The condition cannot be null")___		if (this.untilCondition != null) {_			throw new MalformedPatternException("Only one until condition can be applied.")__		}__		if (!quantifier.hasProperty(Quantifier.QuantifierProperty.LOOPING)) {_			throw new MalformedPatternException("The until condition is only applicable to looping states.")__		}__		ClosureCleaner.clean(untilCondition, true)__		this.untilCondition = untilCondition___		return this__	};applies,a,stop,condition,for,a,looping,state,it,allows,cleaning,the,underlying,state,param,until,condition,a,condition,an,event,has,to,satisfy,to,stop,collecting,events,into,looping,state,return,the,same,pattern,with,applied,until,condition;public,pattern,t,f,until,iterative,condition,f,until,condition,preconditions,check,not,null,until,condition,the,condition,cannot,be,null,if,this,until,condition,null,throw,new,malformed,pattern,exception,only,one,until,condition,can,be,applied,if,quantifier,has,property,quantifier,quantifier,property,looping,throw,new,malformed,pattern,exception,the,until,condition,is,only,applicable,to,looping,states,closure,cleaner,clean,until,condition,true,this,until,condition,until,condition,return,this
Pattern -> public Pattern<T, F> until(IterativeCondition<F> untilCondition);1504268438;Applies a stop condition for a looping state. It allows cleaning the underlying state.__@param untilCondition a condition an event has to satisfy to stop collecting events into looping state_@return The same pattern with applied untilCondition;public Pattern<T, F> until(IterativeCondition<F> untilCondition) {_		Preconditions.checkNotNull(untilCondition, "The condition cannot be null")___		if (this.untilCondition != null) {_			throw new MalformedPatternException("Only one until condition can be applied.")__		}__		if (!quantifier.hasProperty(Quantifier.QuantifierProperty.LOOPING)) {_			throw new MalformedPatternException("The until condition is only applicable to looping states.")__		}__		ClosureCleaner.clean(untilCondition, true)__		this.untilCondition = untilCondition___		return this__	};applies,a,stop,condition,for,a,looping,state,it,allows,cleaning,the,underlying,state,param,until,condition,a,condition,an,event,has,to,satisfy,to,stop,collecting,events,into,looping,state,return,the,same,pattern,with,applied,until,condition;public,pattern,t,f,until,iterative,condition,f,until,condition,preconditions,check,not,null,until,condition,the,condition,cannot,be,null,if,this,until,condition,null,throw,new,malformed,pattern,exception,only,one,until,condition,can,be,applied,if,quantifier,has,property,quantifier,quantifier,property,looping,throw,new,malformed,pattern,exception,the,until,condition,is,only,applicable,to,looping,states,closure,cleaner,clean,until,condition,true,this,until,condition,until,condition,return,this
Pattern -> public Pattern<T, F> until(IterativeCondition<F> untilCondition);1530798894;Applies a stop condition for a looping state. It allows cleaning the underlying state.__@param untilCondition a condition an event has to satisfy to stop collecting events into looping state_@return The same pattern with applied untilCondition;public Pattern<T, F> until(IterativeCondition<F> untilCondition) {_		Preconditions.checkNotNull(untilCondition, "The condition cannot be null")___		if (this.untilCondition != null) {_			throw new MalformedPatternException("Only one until condition can be applied.")__		}__		if (!quantifier.hasProperty(Quantifier.QuantifierProperty.LOOPING)) {_			throw new MalformedPatternException("The until condition is only applicable to looping states.")__		}__		ClosureCleaner.clean(untilCondition, true)__		this.untilCondition = untilCondition___		return this__	};applies,a,stop,condition,for,a,looping,state,it,allows,cleaning,the,underlying,state,param,until,condition,a,condition,an,event,has,to,satisfy,to,stop,collecting,events,into,looping,state,return,the,same,pattern,with,applied,until,condition;public,pattern,t,f,until,iterative,condition,f,until,condition,preconditions,check,not,null,until,condition,the,condition,cannot,be,null,if,this,until,condition,null,throw,new,malformed,pattern,exception,only,one,until,condition,can,be,applied,if,quantifier,has,property,quantifier,quantifier,property,looping,throw,new,malformed,pattern,exception,the,until,condition,is,only,applicable,to,looping,states,closure,cleaner,clean,until,condition,true,this,until,condition,until,condition,return,this
Pattern -> public Pattern<T, F> until(IterativeCondition<F> untilCondition);1540208358;Applies a stop condition for a looping state. It allows cleaning the underlying state.__@param untilCondition a condition an event has to satisfy to stop collecting events into looping state_@return The same pattern with applied untilCondition;public Pattern<T, F> until(IterativeCondition<F> untilCondition) {_		Preconditions.checkNotNull(untilCondition, "The condition cannot be null")___		if (this.untilCondition != null) {_			throw new MalformedPatternException("Only one until condition can be applied.")__		}__		if (!quantifier.hasProperty(Quantifier.QuantifierProperty.LOOPING)) {_			throw new MalformedPatternException("The until condition is only applicable to looping states.")__		}__		ClosureCleaner.clean(untilCondition, true)__		this.untilCondition = untilCondition___		return this__	};applies,a,stop,condition,for,a,looping,state,it,allows,cleaning,the,underlying,state,param,until,condition,a,condition,an,event,has,to,satisfy,to,stop,collecting,events,into,looping,state,return,the,same,pattern,with,applied,until,condition;public,pattern,t,f,until,iterative,condition,f,until,condition,preconditions,check,not,null,until,condition,the,condition,cannot,be,null,if,this,until,condition,null,throw,new,malformed,pattern,exception,only,one,until,condition,can,be,applied,if,quantifier,has,property,quantifier,quantifier,property,looping,throw,new,malformed,pattern,exception,the,until,condition,is,only,applicable,to,looping,states,closure,cleaner,clean,until,condition,true,this,until,condition,until,condition,return,this
Pattern -> public Pattern<T, F> until(IterativeCondition<F> untilCondition);1543413704;Applies a stop condition for a looping state. It allows cleaning the underlying state.__@param untilCondition a condition an event has to satisfy to stop collecting events into looping state_@return The same pattern with applied untilCondition;public Pattern<T, F> until(IterativeCondition<F> untilCondition) {_		Preconditions.checkNotNull(untilCondition, "The condition cannot be null")___		if (this.untilCondition != null) {_			throw new MalformedPatternException("Only one until condition can be applied.")__		}__		if (!quantifier.hasProperty(Quantifier.QuantifierProperty.LOOPING)) {_			throw new MalformedPatternException("The until condition is only applicable to looping states.")__		}__		ClosureCleaner.clean(untilCondition, true)__		this.untilCondition = untilCondition___		return this__	};applies,a,stop,condition,for,a,looping,state,it,allows,cleaning,the,underlying,state,param,until,condition,a,condition,an,event,has,to,satisfy,to,stop,collecting,events,into,looping,state,return,the,same,pattern,with,applied,until,condition;public,pattern,t,f,until,iterative,condition,f,until,condition,preconditions,check,not,null,until,condition,the,condition,cannot,be,null,if,this,until,condition,null,throw,new,malformed,pattern,exception,only,one,until,condition,can,be,applied,if,quantifier,has,property,quantifier,quantifier,property,looping,throw,new,malformed,pattern,exception,the,until,condition,is,only,applicable,to,looping,states,closure,cleaner,clean,until,condition,true,this,until,condition,until,condition,return,this
Pattern -> public Pattern<T, F> greedy();1503558242;Specifies that this pattern is greedy._This means as many events as possible will be matched to this pattern.__@return The same pattern with {@link Quantifier#greedy} set to true._@throws MalformedPatternException if the quantifier is not applicable to this pattern.;public Pattern<T, F> greedy() {_		checkIfNoNotPattern()__		checkIfNoGroupPattern()__		this.quantifier.greedy()__		return this__	};specifies,that,this,pattern,is,greedy,this,means,as,many,events,as,possible,will,be,matched,to,this,pattern,return,the,same,pattern,with,link,quantifier,greedy,set,to,true,throws,malformed,pattern,exception,if,the,quantifier,is,not,applicable,to,this,pattern;public,pattern,t,f,greedy,check,if,no,not,pattern,check,if,no,group,pattern,this,quantifier,greedy,return,this
Pattern -> public Pattern<T, F> greedy();1504268438;Specifies that this pattern is greedy._This means as many events as possible will be matched to this pattern.__@return The same pattern with {@link Quantifier#greedy} set to true._@throws MalformedPatternException if the quantifier is not applicable to this pattern.;public Pattern<T, F> greedy() {_		checkIfNoNotPattern()__		checkIfNoGroupPattern()__		this.quantifier.greedy()__		return this__	};specifies,that,this,pattern,is,greedy,this,means,as,many,events,as,possible,will,be,matched,to,this,pattern,return,the,same,pattern,with,link,quantifier,greedy,set,to,true,throws,malformed,pattern,exception,if,the,quantifier,is,not,applicable,to,this,pattern;public,pattern,t,f,greedy,check,if,no,not,pattern,check,if,no,group,pattern,this,quantifier,greedy,return,this
Pattern -> public Pattern<T, F> greedy();1530798894;Specifies that this pattern is greedy._This means as many events as possible will be matched to this pattern.__@return The same pattern with {@link Quantifier#greedy} set to true._@throws MalformedPatternException if the quantifier is not applicable to this pattern.;public Pattern<T, F> greedy() {_		checkIfNoNotPattern()__		checkIfNoGroupPattern()__		this.quantifier.greedy()__		return this__	};specifies,that,this,pattern,is,greedy,this,means,as,many,events,as,possible,will,be,matched,to,this,pattern,return,the,same,pattern,with,link,quantifier,greedy,set,to,true,throws,malformed,pattern,exception,if,the,quantifier,is,not,applicable,to,this,pattern;public,pattern,t,f,greedy,check,if,no,not,pattern,check,if,no,group,pattern,this,quantifier,greedy,return,this
Pattern -> public Pattern<T, F> greedy();1540208358;Specifies that this pattern is greedy._This means as many events as possible will be matched to this pattern.__@return The same pattern with {@link Quantifier#greedy} set to true._@throws MalformedPatternException if the quantifier is not applicable to this pattern.;public Pattern<T, F> greedy() {_		checkIfNoNotPattern()__		checkIfNoGroupPattern()__		this.quantifier.greedy()__		return this__	};specifies,that,this,pattern,is,greedy,this,means,as,many,events,as,possible,will,be,matched,to,this,pattern,return,the,same,pattern,with,link,quantifier,greedy,set,to,true,throws,malformed,pattern,exception,if,the,quantifier,is,not,applicable,to,this,pattern;public,pattern,t,f,greedy,check,if,no,not,pattern,check,if,no,group,pattern,this,quantifier,greedy,return,this
Pattern -> public Pattern<T, F> greedy();1543413704;Specifies that this pattern is greedy._This means as many events as possible will be matched to this pattern.__@return The same pattern with {@link Quantifier#greedy} set to true._@throws MalformedPatternException if the quantifier is not applicable to this pattern.;public Pattern<T, F> greedy() {_		checkIfNoNotPattern()__		checkIfNoGroupPattern()__		this.quantifier.greedy()__		return this__	};specifies,that,this,pattern,is,greedy,this,means,as,many,events,as,possible,will,be,matched,to,this,pattern,return,the,same,pattern,with,link,quantifier,greedy,set,to,true,throws,malformed,pattern,exception,if,the,quantifier,is,not,applicable,to,this,pattern;public,pattern,t,f,greedy,check,if,no,not,pattern,check,if,no,group,pattern,this,quantifier,greedy,return,this
Pattern -> public static <T, F extends T> GroupPattern<T, F> begin(final Pattern<T, F> group, final AfterMatchSkipStrategy afterMatchSkipStrategy);1504268438;Starts a new pattern sequence. The provided pattern is the initial pattern_of the new sequence.___@param group the pattern to begin with_@param afterMatchSkipStrategy the {@link AfterMatchSkipStrategy.SkipStrategy} to use after each match._@return The first pattern of a pattern sequence;public static <T, F extends T> GroupPattern<T, F> begin(final Pattern<T, F> group, final AfterMatchSkipStrategy afterMatchSkipStrategy) {_		return new GroupPattern<>(null, group, ConsumingStrategy.STRICT, afterMatchSkipStrategy)__	};starts,a,new,pattern,sequence,the,provided,pattern,is,the,initial,pattern,of,the,new,sequence,param,group,the,pattern,to,begin,with,param,after,match,skip,strategy,the,link,after,match,skip,strategy,skip,strategy,to,use,after,each,match,return,the,first,pattern,of,a,pattern,sequence;public,static,t,f,extends,t,group,pattern,t,f,begin,final,pattern,t,f,group,final,after,match,skip,strategy,after,match,skip,strategy,return,new,group,pattern,null,group,consuming,strategy,strict,after,match,skip,strategy
Pattern -> public static <T, F extends T> GroupPattern<T, F> begin(final Pattern<T, F> group, final AfterMatchSkipStrategy afterMatchSkipStrategy);1530798894;Starts a new pattern sequence. The provided pattern is the initial pattern_of the new sequence.___@param group the pattern to begin with_@param afterMatchSkipStrategy the {@link AfterMatchSkipStrategy.SkipStrategy} to use after each match._@return The first pattern of a pattern sequence;public static <T, F extends T> GroupPattern<T, F> begin(final Pattern<T, F> group, final AfterMatchSkipStrategy afterMatchSkipStrategy) {_		return new GroupPattern<>(null, group, ConsumingStrategy.STRICT, afterMatchSkipStrategy)__	};starts,a,new,pattern,sequence,the,provided,pattern,is,the,initial,pattern,of,the,new,sequence,param,group,the,pattern,to,begin,with,param,after,match,skip,strategy,the,link,after,match,skip,strategy,skip,strategy,to,use,after,each,match,return,the,first,pattern,of,a,pattern,sequence;public,static,t,f,extends,t,group,pattern,t,f,begin,final,pattern,t,f,group,final,after,match,skip,strategy,after,match,skip,strategy,return,new,group,pattern,null,group,consuming,strategy,strict,after,match,skip,strategy
Pattern -> public static <T, F extends T> GroupPattern<T, F> begin(final Pattern<T, F> group, final AfterMatchSkipStrategy afterMatchSkipStrategy);1540208358;Starts a new pattern sequence. The provided pattern is the initial pattern_of the new sequence.___@param group the pattern to begin with_@param afterMatchSkipStrategy the {@link AfterMatchSkipStrategy.SkipStrategy} to use after each match._@return The first pattern of a pattern sequence;public static <T, F extends T> GroupPattern<T, F> begin(final Pattern<T, F> group, final AfterMatchSkipStrategy afterMatchSkipStrategy) {_		return new GroupPattern<>(null, group, ConsumingStrategy.STRICT, afterMatchSkipStrategy)__	};starts,a,new,pattern,sequence,the,provided,pattern,is,the,initial,pattern,of,the,new,sequence,param,group,the,pattern,to,begin,with,param,after,match,skip,strategy,the,link,after,match,skip,strategy,skip,strategy,to,use,after,each,match,return,the,first,pattern,of,a,pattern,sequence;public,static,t,f,extends,t,group,pattern,t,f,begin,final,pattern,t,f,group,final,after,match,skip,strategy,after,match,skip,strategy,return,new,group,pattern,null,group,consuming,strategy,strict,after,match,skip,strategy
Pattern -> public static <T, F extends T> GroupPattern<T, F> begin(final Pattern<T, F> group, final AfterMatchSkipStrategy afterMatchSkipStrategy);1543413704;Starts a new pattern sequence. The provided pattern is the initial pattern_of the new sequence.___@param group the pattern to begin with_@param afterMatchSkipStrategy the {@link AfterMatchSkipStrategy.SkipStrategy} to use after each match._@return The first pattern of a pattern sequence;public static <T, F extends T> GroupPattern<T, F> begin(final Pattern<T, F> group, final AfterMatchSkipStrategy afterMatchSkipStrategy) {_		return new GroupPattern<>(null, group, ConsumingStrategy.STRICT, afterMatchSkipStrategy)__	};starts,a,new,pattern,sequence,the,provided,pattern,is,the,initial,pattern,of,the,new,sequence,param,group,the,pattern,to,begin,with,param,after,match,skip,strategy,the,link,after,match,skip,strategy,skip,strategy,to,use,after,each,match,return,the,first,pattern,of,a,pattern,sequence;public,static,t,f,extends,t,group,pattern,t,f,begin,final,pattern,t,f,group,final,after,match,skip,strategy,after,match,skip,strategy,return,new,group,pattern,null,group,consuming,strategy,strict,after,match,skip,strategy
Pattern -> public static <X> Pattern<X, X> begin(final String name, final AfterMatchSkipStrategy afterMatchSkipStrategy);1504268438;Starts a new pattern sequence. The provided name is the one of the initial pattern_of the new sequence. Furthermore, the base type of the event sequence is set.__@param name The name of starting pattern of the new pattern sequence_@param afterMatchSkipStrategy the {@link AfterMatchSkipStrategy.SkipStrategy} to use after each match._@param <X> Base type of the event pattern_@return The first pattern of a pattern sequence;public static <X> Pattern<X, X> begin(final String name, final AfterMatchSkipStrategy afterMatchSkipStrategy) {_		return new Pattern<X, X>(name, null, ConsumingStrategy.STRICT, afterMatchSkipStrategy)__	};starts,a,new,pattern,sequence,the,provided,name,is,the,one,of,the,initial,pattern,of,the,new,sequence,furthermore,the,base,type,of,the,event,sequence,is,set,param,name,the,name,of,starting,pattern,of,the,new,pattern,sequence,param,after,match,skip,strategy,the,link,after,match,skip,strategy,skip,strategy,to,use,after,each,match,param,x,base,type,of,the,event,pattern,return,the,first,pattern,of,a,pattern,sequence;public,static,x,pattern,x,x,begin,final,string,name,final,after,match,skip,strategy,after,match,skip,strategy,return,new,pattern,x,x,name,null,consuming,strategy,strict,after,match,skip,strategy
Pattern -> public static <X> Pattern<X, X> begin(final String name, final AfterMatchSkipStrategy afterMatchSkipStrategy);1530798894;Starts a new pattern sequence. The provided name is the one of the initial pattern_of the new sequence. Furthermore, the base type of the event sequence is set.__@param name The name of starting pattern of the new pattern sequence_@param afterMatchSkipStrategy the {@link AfterMatchSkipStrategy.SkipStrategy} to use after each match._@param <X> Base type of the event pattern_@return The first pattern of a pattern sequence;public static <X> Pattern<X, X> begin(final String name, final AfterMatchSkipStrategy afterMatchSkipStrategy) {_		return new Pattern<X, X>(name, null, ConsumingStrategy.STRICT, afterMatchSkipStrategy)__	};starts,a,new,pattern,sequence,the,provided,name,is,the,one,of,the,initial,pattern,of,the,new,sequence,furthermore,the,base,type,of,the,event,sequence,is,set,param,name,the,name,of,starting,pattern,of,the,new,pattern,sequence,param,after,match,skip,strategy,the,link,after,match,skip,strategy,skip,strategy,to,use,after,each,match,param,x,base,type,of,the,event,pattern,return,the,first,pattern,of,a,pattern,sequence;public,static,x,pattern,x,x,begin,final,string,name,final,after,match,skip,strategy,after,match,skip,strategy,return,new,pattern,x,x,name,null,consuming,strategy,strict,after,match,skip,strategy
Pattern -> public static <X> Pattern<X, X> begin(final String name, final AfterMatchSkipStrategy afterMatchSkipStrategy);1540208358;Starts a new pattern sequence. The provided name is the one of the initial pattern_of the new sequence. Furthermore, the base type of the event sequence is set.__@param name The name of starting pattern of the new pattern sequence_@param afterMatchSkipStrategy the {@link AfterMatchSkipStrategy.SkipStrategy} to use after each match._@param <X> Base type of the event pattern_@return The first pattern of a pattern sequence;public static <X> Pattern<X, X> begin(final String name, final AfterMatchSkipStrategy afterMatchSkipStrategy) {_		return new Pattern<X, X>(name, null, ConsumingStrategy.STRICT, afterMatchSkipStrategy)__	};starts,a,new,pattern,sequence,the,provided,name,is,the,one,of,the,initial,pattern,of,the,new,sequence,furthermore,the,base,type,of,the,event,sequence,is,set,param,name,the,name,of,starting,pattern,of,the,new,pattern,sequence,param,after,match,skip,strategy,the,link,after,match,skip,strategy,skip,strategy,to,use,after,each,match,param,x,base,type,of,the,event,pattern,return,the,first,pattern,of,a,pattern,sequence;public,static,x,pattern,x,x,begin,final,string,name,final,after,match,skip,strategy,after,match,skip,strategy,return,new,pattern,x,x,name,null,consuming,strategy,strict,after,match,skip,strategy
Pattern -> public static <X> Pattern<X, X> begin(final String name, final AfterMatchSkipStrategy afterMatchSkipStrategy);1543413704;Starts a new pattern sequence. The provided name is the one of the initial pattern_of the new sequence. Furthermore, the base type of the event sequence is set.__@param name The name of starting pattern of the new pattern sequence_@param afterMatchSkipStrategy the {@link AfterMatchSkipStrategy.SkipStrategy} to use after each match._@param <X> Base type of the event pattern_@return The first pattern of a pattern sequence;public static <X> Pattern<X, X> begin(final String name, final AfterMatchSkipStrategy afterMatchSkipStrategy) {_		return new Pattern<X, X>(name, null, ConsumingStrategy.STRICT, afterMatchSkipStrategy)__	};starts,a,new,pattern,sequence,the,provided,name,is,the,one,of,the,initial,pattern,of,the,new,sequence,furthermore,the,base,type,of,the,event,sequence,is,set,param,name,the,name,of,starting,pattern,of,the,new,pattern,sequence,param,after,match,skip,strategy,the,link,after,match,skip,strategy,skip,strategy,to,use,after,each,match,param,x,base,type,of,the,event,pattern,return,the,first,pattern,of,a,pattern,sequence;public,static,x,pattern,x,x,begin,final,string,name,final,after,match,skip,strategy,after,match,skip,strategy,return,new,pattern,x,x,name,null,consuming,strategy,strict,after,match,skip,strategy
Pattern -> public AfterMatchSkipStrategy getAfterMatchSkipStrategy();1504268438;@return the pattern's {@link AfterMatchSkipStrategy.SkipStrategy} after match.;public AfterMatchSkipStrategy getAfterMatchSkipStrategy() {_		return afterMatchSkipStrategy__	};return,the,pattern,s,link,after,match,skip,strategy,skip,strategy,after,match;public,after,match,skip,strategy,get,after,match,skip,strategy,return,after,match,skip,strategy
Pattern -> public AfterMatchSkipStrategy getAfterMatchSkipStrategy();1530798894;@return the pattern's {@link AfterMatchSkipStrategy.SkipStrategy} after match.;public AfterMatchSkipStrategy getAfterMatchSkipStrategy() {_		return afterMatchSkipStrategy__	};return,the,pattern,s,link,after,match,skip,strategy,skip,strategy,after,match;public,after,match,skip,strategy,get,after,match,skip,strategy,return,after,match,skip,strategy
Pattern -> public AfterMatchSkipStrategy getAfterMatchSkipStrategy();1540208358;@return the pattern's {@link AfterMatchSkipStrategy.SkipStrategy} after match.;public AfterMatchSkipStrategy getAfterMatchSkipStrategy() {_		return afterMatchSkipStrategy__	};return,the,pattern,s,link,after,match,skip,strategy,skip,strategy,after,match;public,after,match,skip,strategy,get,after,match,skip,strategy,return,after,match,skip,strategy
Pattern -> public AfterMatchSkipStrategy getAfterMatchSkipStrategy();1543413704;@return the pattern's {@link AfterMatchSkipStrategy.SkipStrategy} after match.;public AfterMatchSkipStrategy getAfterMatchSkipStrategy() {_		return afterMatchSkipStrategy__	};return,the,pattern,s,link,after,match,skip,strategy,skip,strategy,after,match;public,after,match,skip,strategy,get,after,match,skip,strategy,return,after,match,skip,strategy
Pattern -> public Pattern<T, T> next(final String name);1454421848;Appends a new pattern operator to the existing one. The new pattern operator enforces strict_temporal contiguity. This means that the whole pattern only matches if an event which matches_this operator directly follows the preceding matching event. Thus, there cannot be any_events in between two matching events.__@param name Name of the new pattern operator_@return A new pattern operator which is appended to this pattern operator;public Pattern<T, T> next(final String name) {_		return new Pattern<T, T>(name, this)__	};appends,a,new,pattern,operator,to,the,existing,one,the,new,pattern,operator,enforces,strict,temporal,contiguity,this,means,that,the,whole,pattern,only,matches,if,an,event,which,matches,this,operator,directly,follows,the,preceding,matching,event,thus,there,cannot,be,any,events,in,between,two,matching,events,param,name,name,of,the,new,pattern,operator,return,a,new,pattern,operator,which,is,appended,to,this,pattern,operator;public,pattern,t,t,next,final,string,name,return,new,pattern,t,t,name,this
Pattern -> public Pattern<T, T> next(final String name);1456442894;Appends a new pattern operator to the existing one. The new pattern operator enforces strict_temporal contiguity. This means that the whole pattern only matches if an event which matches_this operator directly follows the preceding matching event. Thus, there cannot be any_events in between two matching events.__@param name Name of the new pattern operator_@return A new pattern operator which is appended to this pattern operator;public Pattern<T, T> next(final String name) {_		return new Pattern<T, T>(name, this)__	};appends,a,new,pattern,operator,to,the,existing,one,the,new,pattern,operator,enforces,strict,temporal,contiguity,this,means,that,the,whole,pattern,only,matches,if,an,event,which,matches,this,operator,directly,follows,the,preceding,matching,event,thus,there,cannot,be,any,events,in,between,two,matching,events,param,name,name,of,the,new,pattern,operator,return,a,new,pattern,operator,which,is,appended,to,this,pattern,operator;public,pattern,t,t,next,final,string,name,return,new,pattern,t,t,name,this
Pattern -> public Pattern<T, T> next(final String name);1461689259;Appends a new pattern operator to the existing one. The new pattern operator enforces strict_temporal contiguity. This means that the whole pattern only matches if an event which matches_this operator directly follows the preceding matching event. Thus, there cannot be any_events in between two matching events.__@param name Name of the new pattern operator_@return A new pattern operator which is appended to this pattern operator;public Pattern<T, T> next(final String name) {_		return new Pattern<T, T>(name, this)__	};appends,a,new,pattern,operator,to,the,existing,one,the,new,pattern,operator,enforces,strict,temporal,contiguity,this,means,that,the,whole,pattern,only,matches,if,an,event,which,matches,this,operator,directly,follows,the,preceding,matching,event,thus,there,cannot,be,any,events,in,between,two,matching,events,param,name,name,of,the,new,pattern,operator,return,a,new,pattern,operator,which,is,appended,to,this,pattern,operator;public,pattern,t,t,next,final,string,name,return,new,pattern,t,t,name,this
Pattern -> public Pattern<T, T> next(final String name);1471613162;Appends a new pattern operator to the existing one. The new pattern operator enforces strict_temporal contiguity. This means that the whole pattern only matches if an event which matches_this operator directly follows the preceding matching event. Thus, there cannot be any_events in between two matching events.__@param name Name of the new pattern operator_@return A new pattern operator which is appended to this pattern operator;public Pattern<T, T> next(final String name) {_		return new Pattern<T, T>(name, this)__	};appends,a,new,pattern,operator,to,the,existing,one,the,new,pattern,operator,enforces,strict,temporal,contiguity,this,means,that,the,whole,pattern,only,matches,if,an,event,which,matches,this,operator,directly,follows,the,preceding,matching,event,thus,there,cannot,be,any,events,in,between,two,matching,events,param,name,name,of,the,new,pattern,operator,return,a,new,pattern,operator,which,is,appended,to,this,pattern,operator;public,pattern,t,t,next,final,string,name,return,new,pattern,t,t,name,this
Pattern -> public Pattern<T, T> next(final String name);1471614454;Appends a new pattern operator to the existing one. The new pattern operator enforces strict_temporal contiguity. This means that the whole pattern only matches if an event which matches_this operator directly follows the preceding matching event. Thus, there cannot be any_events in between two matching events.__@param name Name of the new pattern operator_@return A new pattern operator which is appended to this pattern operator;public Pattern<T, T> next(final String name) {_		return new Pattern<T, T>(name, this)__	};appends,a,new,pattern,operator,to,the,existing,one,the,new,pattern,operator,enforces,strict,temporal,contiguity,this,means,that,the,whole,pattern,only,matches,if,an,event,which,matches,this,operator,directly,follows,the,preceding,matching,event,thus,there,cannot,be,any,events,in,between,two,matching,events,param,name,name,of,the,new,pattern,operator,return,a,new,pattern,operator,which,is,appended,to,this,pattern,operator;public,pattern,t,t,next,final,string,name,return,new,pattern,t,t,name,this
Pattern -> public Pattern<T, T> next(final String name);1488270949;Appends a new pattern operator to the existing one. The new pattern operator enforces strict_temporal contiguity. This means that the whole pattern only matches if an event which matches_this operator directly follows the preceding matching event. Thus, there cannot be any_events in between two matching events.__@param name Name of the new pattern operator_@return A new pattern operator which is appended to this pattern operator;public Pattern<T, T> next(final String name) {_		return new Pattern<T, T>(name, this)__	};appends,a,new,pattern,operator,to,the,existing,one,the,new,pattern,operator,enforces,strict,temporal,contiguity,this,means,that,the,whole,pattern,only,matches,if,an,event,which,matches,this,operator,directly,follows,the,preceding,matching,event,thus,there,cannot,be,any,events,in,between,two,matching,events,param,name,name,of,the,new,pattern,operator,return,a,new,pattern,operator,which,is,appended,to,this,pattern,operator;public,pattern,t,t,next,final,string,name,return,new,pattern,t,t,name,this
Pattern -> public Pattern<T, T> next(final String name);1490262475;Appends a new pattern operator to the existing one. The new pattern operator enforces strict_temporal contiguity. This means that the whole pattern only matches if an event which matches_this operator directly follows the preceding matching event. Thus, there cannot be any_events in between two matching events.__@param name Name of the new pattern operator_@return A new pattern operator which is appended to this pattern operator;public Pattern<T, T> next(final String name) {_		return new Pattern<T, T>(name, this)__	};appends,a,new,pattern,operator,to,the,existing,one,the,new,pattern,operator,enforces,strict,temporal,contiguity,this,means,that,the,whole,pattern,only,matches,if,an,event,which,matches,this,operator,directly,follows,the,preceding,matching,event,thus,there,cannot,be,any,events,in,between,two,matching,events,param,name,name,of,the,new,pattern,operator,return,a,new,pattern,operator,which,is,appended,to,this,pattern,operator;public,pattern,t,t,next,final,string,name,return,new,pattern,t,t,name,this
Pattern -> public Pattern<T, T> next(final String name);1490638274;Appends a new pattern operator to the existing one. The new pattern operator enforces strict_temporal contiguity. This means that the whole pattern only matches if an event which matches_this operator directly follows the preceding matching event. Thus, there cannot be any_events in between two matching events.__@param name Name of the new pattern operator_@return A new pattern operator which is appended to this pattern operator;public Pattern<T, T> next(final String name) {_		return new Pattern<T, T>(name, this)__	};appends,a,new,pattern,operator,to,the,existing,one,the,new,pattern,operator,enforces,strict,temporal,contiguity,this,means,that,the,whole,pattern,only,matches,if,an,event,which,matches,this,operator,directly,follows,the,preceding,matching,event,thus,there,cannot,be,any,events,in,between,two,matching,events,param,name,name,of,the,new,pattern,operator,return,a,new,pattern,operator,which,is,appended,to,this,pattern,operator;public,pattern,t,t,next,final,string,name,return,new,pattern,t,t,name,this
Pattern -> public Pattern<T, T> next(final String name);1490862259;Appends a new pattern operator to the existing one. The new pattern operator enforces strict_temporal contiguity. This means that the whole pattern only matches if an event which matches_this operator directly follows the preceding matching event. Thus, there cannot be any_events in between two matching events.__@param name Name of the new pattern operator_@return A new pattern operator which is appended to this pattern operator;public Pattern<T, T> next(final String name) {_		return new Pattern<T, T>(name, this)__	};appends,a,new,pattern,operator,to,the,existing,one,the,new,pattern,operator,enforces,strict,temporal,contiguity,this,means,that,the,whole,pattern,only,matches,if,an,event,which,matches,this,operator,directly,follows,the,preceding,matching,event,thus,there,cannot,be,any,events,in,between,two,matching,events,param,name,name,of,the,new,pattern,operator,return,a,new,pattern,operator,which,is,appended,to,this,pattern,operator;public,pattern,t,t,next,final,string,name,return,new,pattern,t,t,name,this
Pattern -> public Pattern<T, T> next(final String name);1491647251;Appends a new pattern operator to the existing one. The new pattern operator enforces strict_temporal contiguity. This means that the whole pattern only matches if an event which matches_this operator directly follows the preceding matching event. Thus, there cannot be any_events in between two matching events.__@param name Name of the new pattern operator_@return A new pattern operator which is appended to this pattern operator;public Pattern<T, T> next(final String name) {_		return new Pattern<T, T>(name, this)__	};appends,a,new,pattern,operator,to,the,existing,one,the,new,pattern,operator,enforces,strict,temporal,contiguity,this,means,that,the,whole,pattern,only,matches,if,an,event,which,matches,this,operator,directly,follows,the,preceding,matching,event,thus,there,cannot,be,any,events,in,between,two,matching,events,param,name,name,of,the,new,pattern,operator,return,a,new,pattern,operator,which,is,appended,to,this,pattern,operator;public,pattern,t,t,next,final,string,name,return,new,pattern,t,t,name,this
Pattern -> public Pattern<T, T> next(final String name);1493201751;Appends a new pattern to the existing one. The new pattern enforces strict_temporal contiguity. This means that the whole pattern sequence matches only_if an event which matches this pattern directly follows the preceding matching_event. Thus, there cannot be any events in between two matching events.__@param name Name of the new pattern_@return A new pattern which is appended to this one;public Pattern<T, T> next(final String name) {_		return new Pattern<T, T>(name, this)__	};appends,a,new,pattern,to,the,existing,one,the,new,pattern,enforces,strict,temporal,contiguity,this,means,that,the,whole,pattern,sequence,matches,only,if,an,event,which,matches,this,pattern,directly,follows,the,preceding,matching,event,thus,there,cannot,be,any,events,in,between,two,matching,events,param,name,name,of,the,new,pattern,return,a,new,pattern,which,is,appended,to,this,one;public,pattern,t,t,next,final,string,name,return,new,pattern,t,t,name,this
Pattern -> public Pattern<T, T> next(final String name);1493201753;Appends a new pattern to the existing one. The new pattern enforces strict_temporal contiguity. This means that the whole pattern sequence matches only_if an event which matches this pattern directly follows the preceding matching_event. Thus, there cannot be any events in between two matching events.__@param name Name of the new pattern_@return A new pattern which is appended to this one;public Pattern<T, T> next(final String name) {_		return new Pattern<T, T>(name, this)__	};appends,a,new,pattern,to,the,existing,one,the,new,pattern,enforces,strict,temporal,contiguity,this,means,that,the,whole,pattern,sequence,matches,only,if,an,event,which,matches,this,pattern,directly,follows,the,preceding,matching,event,thus,there,cannot,be,any,events,in,between,two,matching,events,param,name,name,of,the,new,pattern,return,a,new,pattern,which,is,appended,to,this,one;public,pattern,t,t,next,final,string,name,return,new,pattern,t,t,name,this
Pattern -> public Pattern<T, T> next(final String name);1493382517;Appends a new pattern to the existing one. The new pattern enforces strict_temporal contiguity. This means that the whole pattern sequence matches only_if an event which matches this pattern directly follows the preceding matching_event. Thus, there cannot be any events in between two matching events.__@param name Name of the new pattern_@return A new pattern which is appended to this one;public Pattern<T, T> next(final String name) {_		return new Pattern<T, T>(name, this, ConsumingStrategy.STRICT)__	};appends,a,new,pattern,to,the,existing,one,the,new,pattern,enforces,strict,temporal,contiguity,this,means,that,the,whole,pattern,sequence,matches,only,if,an,event,which,matches,this,pattern,directly,follows,the,preceding,matching,event,thus,there,cannot,be,any,events,in,between,two,matching,events,param,name,name,of,the,new,pattern,return,a,new,pattern,which,is,appended,to,this,one;public,pattern,t,t,next,final,string,name,return,new,pattern,t,t,name,this,consuming,strategy,strict
Pattern -> public Pattern<T, T> next(final String name);1493906327;Appends a new pattern to the existing one. The new pattern enforces strict_temporal contiguity. This means that the whole pattern sequence matches only_if an event which matches this pattern directly follows the preceding matching_event. Thus, there cannot be any events in between two matching events.__@param name Name of the new pattern_@return A new pattern which is appended to this one;public Pattern<T, T> next(final String name) {_		return new Pattern<T, T>(name, this, ConsumingStrategy.STRICT)__	};appends,a,new,pattern,to,the,existing,one,the,new,pattern,enforces,strict,temporal,contiguity,this,means,that,the,whole,pattern,sequence,matches,only,if,an,event,which,matches,this,pattern,directly,follows,the,preceding,matching,event,thus,there,cannot,be,any,events,in,between,two,matching,events,param,name,name,of,the,new,pattern,return,a,new,pattern,which,is,appended,to,this,one;public,pattern,t,t,next,final,string,name,return,new,pattern,t,t,name,this,consuming,strategy,strict
Pattern -> public Pattern<T, T> next(final String name);1493985576;Appends a new pattern to the existing one. The new pattern enforces strict_temporal contiguity. This means that the whole pattern sequence matches only_if an event which matches this pattern directly follows the preceding matching_event. Thus, there cannot be any events in between two matching events.__@param name Name of the new pattern_@return A new pattern which is appended to this one;public Pattern<T, T> next(final String name) {_		return new Pattern<>(name, this, ConsumingStrategy.STRICT)__	};appends,a,new,pattern,to,the,existing,one,the,new,pattern,enforces,strict,temporal,contiguity,this,means,that,the,whole,pattern,sequence,matches,only,if,an,event,which,matches,this,pattern,directly,follows,the,preceding,matching,event,thus,there,cannot,be,any,events,in,between,two,matching,events,param,name,name,of,the,new,pattern,return,a,new,pattern,which,is,appended,to,this,one;public,pattern,t,t,next,final,string,name,return,new,pattern,name,this,consuming,strategy,strict
Pattern -> public Pattern<T, T> next(final String name);1493997908;Appends a new pattern to the existing one. The new pattern enforces strict_temporal contiguity. This means that the whole pattern sequence matches only_if an event which matches this pattern directly follows the preceding matching_event. Thus, there cannot be any events in between two matching events.__@param name Name of the new pattern_@return A new pattern which is appended to this one;public Pattern<T, T> next(final String name) {_		return new Pattern<>(name, this, ConsumingStrategy.STRICT)__	};appends,a,new,pattern,to,the,existing,one,the,new,pattern,enforces,strict,temporal,contiguity,this,means,that,the,whole,pattern,sequence,matches,only,if,an,event,which,matches,this,pattern,directly,follows,the,preceding,matching,event,thus,there,cannot,be,any,events,in,between,two,matching,events,param,name,name,of,the,new,pattern,return,a,new,pattern,which,is,appended,to,this,one;public,pattern,t,t,next,final,string,name,return,new,pattern,name,this,consuming,strategy,strict
Pattern -> public Pattern<T, T> next(final String name);1495961498;Appends a new pattern to the existing one. The new pattern enforces strict_temporal contiguity. This means that the whole pattern sequence matches only_if an event which matches this pattern directly follows the preceding matching_event. Thus, there cannot be any events in between two matching events.__@param name Name of the new pattern_@return A new pattern which is appended to this one;public Pattern<T, T> next(final String name) {_		return new Pattern<>(name, this, ConsumingStrategy.STRICT)__	};appends,a,new,pattern,to,the,existing,one,the,new,pattern,enforces,strict,temporal,contiguity,this,means,that,the,whole,pattern,sequence,matches,only,if,an,event,which,matches,this,pattern,directly,follows,the,preceding,matching,event,thus,there,cannot,be,any,events,in,between,two,matching,events,param,name,name,of,the,new,pattern,return,a,new,pattern,which,is,appended,to,this,one;public,pattern,t,t,next,final,string,name,return,new,pattern,name,this,consuming,strategy,strict
Pattern -> public Pattern<T, T> next(final String name);1497940477;Appends a new pattern to the existing one. The new pattern enforces strict_temporal contiguity. This means that the whole pattern sequence matches only_if an event which matches this pattern directly follows the preceding matching_event. Thus, there cannot be any events in between two matching events.__@param name Name of the new pattern_@return A new pattern which is appended to this one;public Pattern<T, T> next(final String name) {_		return new Pattern<>(name, this, ConsumingStrategy.STRICT)__	};appends,a,new,pattern,to,the,existing,one,the,new,pattern,enforces,strict,temporal,contiguity,this,means,that,the,whole,pattern,sequence,matches,only,if,an,event,which,matches,this,pattern,directly,follows,the,preceding,matching,event,thus,there,cannot,be,any,events,in,between,two,matching,events,param,name,name,of,the,new,pattern,return,a,new,pattern,which,is,appended,to,this,one;public,pattern,t,t,next,final,string,name,return,new,pattern,name,this,consuming,strategy,strict
Pattern -> public Pattern<T, T> next(final String name);1498548074;Appends a new pattern to the existing one. The new pattern enforces strict_temporal contiguity. This means that the whole pattern sequence matches only_if an event which matches this pattern directly follows the preceding matching_event. Thus, there cannot be any events in between two matching events.__@param name Name of the new pattern_@return A new pattern which is appended to this one;public Pattern<T, T> next(final String name) {_		return new Pattern<>(name, this, ConsumingStrategy.STRICT)__	};appends,a,new,pattern,to,the,existing,one,the,new,pattern,enforces,strict,temporal,contiguity,this,means,that,the,whole,pattern,sequence,matches,only,if,an,event,which,matches,this,pattern,directly,follows,the,preceding,matching,event,thus,there,cannot,be,any,events,in,between,two,matching,events,param,name,name,of,the,new,pattern,return,a,new,pattern,which,is,appended,to,this,one;public,pattern,t,t,next,final,string,name,return,new,pattern,name,this,consuming,strategy,strict
Pattern -> public Pattern<T, T> next(final String name);1499244360;Appends a new pattern to the existing one. The new pattern enforces strict_temporal contiguity. This means that the whole pattern sequence matches only_if an event which matches this pattern directly follows the preceding matching_event. Thus, there cannot be any events in between two matching events.__@param name Name of the new pattern_@return A new pattern which is appended to this one;public Pattern<T, T> next(final String name) {_		return new Pattern<>(name, this, ConsumingStrategy.STRICT)__	};appends,a,new,pattern,to,the,existing,one,the,new,pattern,enforces,strict,temporal,contiguity,this,means,that,the,whole,pattern,sequence,matches,only,if,an,event,which,matches,this,pattern,directly,follows,the,preceding,matching,event,thus,there,cannot,be,any,events,in,between,two,matching,events,param,name,name,of,the,new,pattern,return,a,new,pattern,which,is,appended,to,this,one;public,pattern,t,t,next,final,string,name,return,new,pattern,name,this,consuming,strategy,strict
Pattern -> public Pattern<T, T> next(final String name);1499248439;Appends a new pattern to the existing one. The new pattern enforces strict_temporal contiguity. This means that the whole pattern sequence matches only_if an event which matches this pattern directly follows the preceding matching_event. Thus, there cannot be any events in between two matching events.__@param name Name of the new pattern_@return A new pattern which is appended to this one;public Pattern<T, T> next(final String name) {_		return new Pattern<>(name, this, ConsumingStrategy.STRICT)__	};appends,a,new,pattern,to,the,existing,one,the,new,pattern,enforces,strict,temporal,contiguity,this,means,that,the,whole,pattern,sequence,matches,only,if,an,event,which,matches,this,pattern,directly,follows,the,preceding,matching,event,thus,there,cannot,be,any,events,in,between,two,matching,events,param,name,name,of,the,new,pattern,return,a,new,pattern,which,is,appended,to,this,one;public,pattern,t,t,next,final,string,name,return,new,pattern,name,this,consuming,strategy,strict
Pattern -> public Pattern<T, T> next(final String name);1503420807;Appends a new pattern to the existing one. The new pattern enforces strict_temporal contiguity. This means that the whole pattern sequence matches only_if an event which matches this pattern directly follows the preceding matching_event. Thus, there cannot be any events in between two matching events.__@param name Name of the new pattern_@return A new pattern which is appended to this one;public Pattern<T, T> next(final String name) {_		return new Pattern<>(name, this, ConsumingStrategy.STRICT)__	};appends,a,new,pattern,to,the,existing,one,the,new,pattern,enforces,strict,temporal,contiguity,this,means,that,the,whole,pattern,sequence,matches,only,if,an,event,which,matches,this,pattern,directly,follows,the,preceding,matching,event,thus,there,cannot,be,any,events,in,between,two,matching,events,param,name,name,of,the,new,pattern,return,a,new,pattern,which,is,appended,to,this,one;public,pattern,t,t,next,final,string,name,return,new,pattern,name,this,consuming,strategy,strict
Pattern -> public Pattern<T, T> next(final String name);1503558242;Appends a new pattern to the existing one. The new pattern enforces strict_temporal contiguity. This means that the whole pattern sequence matches only_if an event which matches this pattern directly follows the preceding matching_event. Thus, there cannot be any events in between two matching events.__@param name Name of the new pattern_@return A new pattern which is appended to this one;public Pattern<T, T> next(final String name) {_		return new Pattern<>(name, this, ConsumingStrategy.STRICT)__	};appends,a,new,pattern,to,the,existing,one,the,new,pattern,enforces,strict,temporal,contiguity,this,means,that,the,whole,pattern,sequence,matches,only,if,an,event,which,matches,this,pattern,directly,follows,the,preceding,matching,event,thus,there,cannot,be,any,events,in,between,two,matching,events,param,name,name,of,the,new,pattern,return,a,new,pattern,which,is,appended,to,this,one;public,pattern,t,t,next,final,string,name,return,new,pattern,name,this,consuming,strategy,strict
Pattern -> public Pattern<T, T> next(final String name);1504268438;Appends a new pattern to the existing one. The new pattern enforces strict_temporal contiguity. This means that the whole pattern sequence matches only_if an event which matches this pattern directly follows the preceding matching_event. Thus, there cannot be any events in between two matching events.__@param name Name of the new pattern_@return A new pattern which is appended to this one;public Pattern<T, T> next(final String name) {_		return new Pattern<>(name, this, ConsumingStrategy.STRICT, afterMatchSkipStrategy)__	};appends,a,new,pattern,to,the,existing,one,the,new,pattern,enforces,strict,temporal,contiguity,this,means,that,the,whole,pattern,sequence,matches,only,if,an,event,which,matches,this,pattern,directly,follows,the,preceding,matching,event,thus,there,cannot,be,any,events,in,between,two,matching,events,param,name,name,of,the,new,pattern,return,a,new,pattern,which,is,appended,to,this,one;public,pattern,t,t,next,final,string,name,return,new,pattern,name,this,consuming,strategy,strict,after,match,skip,strategy
Pattern -> public Pattern<T, T> next(final String name);1530798894;Appends a new pattern to the existing one. The new pattern enforces strict_temporal contiguity. This means that the whole pattern sequence matches only_if an event which matches this pattern directly follows the preceding matching_event. Thus, there cannot be any events in between two matching events.__@param name Name of the new pattern_@return A new pattern which is appended to this one;public Pattern<T, T> next(final String name) {_		return new Pattern<>(name, this, ConsumingStrategy.STRICT, afterMatchSkipStrategy)__	};appends,a,new,pattern,to,the,existing,one,the,new,pattern,enforces,strict,temporal,contiguity,this,means,that,the,whole,pattern,sequence,matches,only,if,an,event,which,matches,this,pattern,directly,follows,the,preceding,matching,event,thus,there,cannot,be,any,events,in,between,two,matching,events,param,name,name,of,the,new,pattern,return,a,new,pattern,which,is,appended,to,this,one;public,pattern,t,t,next,final,string,name,return,new,pattern,name,this,consuming,strategy,strict,after,match,skip,strategy
Pattern -> public Pattern<T, T> next(final String name);1540208358;Appends a new pattern to the existing one. The new pattern enforces strict_temporal contiguity. This means that the whole pattern sequence matches only_if an event which matches this pattern directly follows the preceding matching_event. Thus, there cannot be any events in between two matching events.__@param name Name of the new pattern_@return A new pattern which is appended to this one;public Pattern<T, T> next(final String name) {_		return new Pattern<>(name, this, ConsumingStrategy.STRICT, afterMatchSkipStrategy)__	};appends,a,new,pattern,to,the,existing,one,the,new,pattern,enforces,strict,temporal,contiguity,this,means,that,the,whole,pattern,sequence,matches,only,if,an,event,which,matches,this,pattern,directly,follows,the,preceding,matching,event,thus,there,cannot,be,any,events,in,between,two,matching,events,param,name,name,of,the,new,pattern,return,a,new,pattern,which,is,appended,to,this,one;public,pattern,t,t,next,final,string,name,return,new,pattern,name,this,consuming,strategy,strict,after,match,skip,strategy
Pattern -> public Pattern<T, T> next(final String name);1543413704;Appends a new pattern to the existing one. The new pattern enforces strict_temporal contiguity. This means that the whole pattern sequence matches only_if an event which matches this pattern directly follows the preceding matching_event. Thus, there cannot be any events in between two matching events.__@param name Name of the new pattern_@return A new pattern which is appended to this one;public Pattern<T, T> next(final String name) {_		return new Pattern<>(name, this, ConsumingStrategy.STRICT, afterMatchSkipStrategy)__	};appends,a,new,pattern,to,the,existing,one,the,new,pattern,enforces,strict,temporal,contiguity,this,means,that,the,whole,pattern,sequence,matches,only,if,an,event,which,matches,this,pattern,directly,follows,the,preceding,matching,event,thus,there,cannot,be,any,events,in,between,two,matching,events,param,name,name,of,the,new,pattern,return,a,new,pattern,which,is,appended,to,this,one;public,pattern,t,t,next,final,string,name,return,new,pattern,name,this,consuming,strategy,strict,after,match,skip,strategy
Pattern -> public Pattern<T, T> followedBy(final String name);1493382517;Appends a new pattern to the existing one. The new pattern enforces non-strict_temporal contiguity. This means that a matching event of this pattern and the_preceding matching event might be interleaved with other events which are ignored.__@param name Name of the new pattern_@return A new pattern which is appended to this one;public Pattern<T, T> followedBy(final String name) {_		return new Pattern<>(name, this, ConsumingStrategy.SKIP_TILL_NEXT)__	};appends,a,new,pattern,to,the,existing,one,the,new,pattern,enforces,non,strict,temporal,contiguity,this,means,that,a,matching,event,of,this,pattern,and,the,preceding,matching,event,might,be,interleaved,with,other,events,which,are,ignored,param,name,name,of,the,new,pattern,return,a,new,pattern,which,is,appended,to,this,one;public,pattern,t,t,followed,by,final,string,name,return,new,pattern,name,this,consuming,strategy
Pattern -> public Pattern<T, T> followedBy(final String name);1493906327;Appends a new pattern to the existing one. The new pattern enforces non-strict_temporal contiguity. This means that a matching event of this pattern and the_preceding matching event might be interleaved with other events which are ignored.__@param name Name of the new pattern_@return A new pattern which is appended to this one;public Pattern<T, T> followedBy(final String name) {_		return new Pattern<>(name, this, ConsumingStrategy.SKIP_TILL_NEXT)__	};appends,a,new,pattern,to,the,existing,one,the,new,pattern,enforces,non,strict,temporal,contiguity,this,means,that,a,matching,event,of,this,pattern,and,the,preceding,matching,event,might,be,interleaved,with,other,events,which,are,ignored,param,name,name,of,the,new,pattern,return,a,new,pattern,which,is,appended,to,this,one;public,pattern,t,t,followed,by,final,string,name,return,new,pattern,name,this,consuming,strategy
Pattern -> public Pattern<T, T> followedBy(final String name);1493985576;Appends a new pattern to the existing one. The new pattern enforces non-strict_temporal contiguity. This means that a matching event of this pattern and the_preceding matching event might be interleaved with other events which are ignored.__@param name Name of the new pattern_@return A new pattern which is appended to this one;public Pattern<T, T> followedBy(final String name) {_		return new Pattern<>(name, this, ConsumingStrategy.SKIP_TILL_NEXT)__	};appends,a,new,pattern,to,the,existing,one,the,new,pattern,enforces,non,strict,temporal,contiguity,this,means,that,a,matching,event,of,this,pattern,and,the,preceding,matching,event,might,be,interleaved,with,other,events,which,are,ignored,param,name,name,of,the,new,pattern,return,a,new,pattern,which,is,appended,to,this,one;public,pattern,t,t,followed,by,final,string,name,return,new,pattern,name,this,consuming,strategy
Pattern -> public Pattern<T, T> followedBy(final String name);1493997908;Appends a new pattern to the existing one. The new pattern enforces non-strict_temporal contiguity. This means that a matching event of this pattern and the_preceding matching event might be interleaved with other events which are ignored.__@param name Name of the new pattern_@return A new pattern which is appended to this one;public Pattern<T, T> followedBy(final String name) {_		return new Pattern<>(name, this, ConsumingStrategy.SKIP_TILL_NEXT)__	};appends,a,new,pattern,to,the,existing,one,the,new,pattern,enforces,non,strict,temporal,contiguity,this,means,that,a,matching,event,of,this,pattern,and,the,preceding,matching,event,might,be,interleaved,with,other,events,which,are,ignored,param,name,name,of,the,new,pattern,return,a,new,pattern,which,is,appended,to,this,one;public,pattern,t,t,followed,by,final,string,name,return,new,pattern,name,this,consuming,strategy
Pattern -> public Pattern<T, T> followedBy(final String name);1495961498;Appends a new pattern to the existing one. The new pattern enforces non-strict_temporal contiguity. This means that a matching event of this pattern and the_preceding matching event might be interleaved with other events which are ignored.__@param name Name of the new pattern_@return A new pattern which is appended to this one;public Pattern<T, T> followedBy(final String name) {_		return new Pattern<>(name, this, ConsumingStrategy.SKIP_TILL_NEXT)__	};appends,a,new,pattern,to,the,existing,one,the,new,pattern,enforces,non,strict,temporal,contiguity,this,means,that,a,matching,event,of,this,pattern,and,the,preceding,matching,event,might,be,interleaved,with,other,events,which,are,ignored,param,name,name,of,the,new,pattern,return,a,new,pattern,which,is,appended,to,this,one;public,pattern,t,t,followed,by,final,string,name,return,new,pattern,name,this,consuming,strategy
Pattern -> public Pattern<T, T> followedBy(final String name);1497940477;Appends a new pattern to the existing one. The new pattern enforces non-strict_temporal contiguity. This means that a matching event of this pattern and the_preceding matching event might be interleaved with other events which are ignored.__@param name Name of the new pattern_@return A new pattern which is appended to this one;public Pattern<T, T> followedBy(final String name) {_		return new Pattern<>(name, this, ConsumingStrategy.SKIP_TILL_NEXT)__	};appends,a,new,pattern,to,the,existing,one,the,new,pattern,enforces,non,strict,temporal,contiguity,this,means,that,a,matching,event,of,this,pattern,and,the,preceding,matching,event,might,be,interleaved,with,other,events,which,are,ignored,param,name,name,of,the,new,pattern,return,a,new,pattern,which,is,appended,to,this,one;public,pattern,t,t,followed,by,final,string,name,return,new,pattern,name,this,consuming,strategy
Pattern -> public Pattern<T, T> followedBy(final String name);1498548074;Appends a new pattern to the existing one. The new pattern enforces non-strict_temporal contiguity. This means that a matching event of this pattern and the_preceding matching event might be interleaved with other events which are ignored.__@param name Name of the new pattern_@return A new pattern which is appended to this one;public Pattern<T, T> followedBy(final String name) {_		return new Pattern<>(name, this, ConsumingStrategy.SKIP_TILL_NEXT)__	};appends,a,new,pattern,to,the,existing,one,the,new,pattern,enforces,non,strict,temporal,contiguity,this,means,that,a,matching,event,of,this,pattern,and,the,preceding,matching,event,might,be,interleaved,with,other,events,which,are,ignored,param,name,name,of,the,new,pattern,return,a,new,pattern,which,is,appended,to,this,one;public,pattern,t,t,followed,by,final,string,name,return,new,pattern,name,this,consuming,strategy
Pattern -> public Pattern<T, T> followedBy(final String name);1499244360;Appends a new pattern to the existing one. The new pattern enforces non-strict_temporal contiguity. This means that a matching event of this pattern and the_preceding matching event might be interleaved with other events which are ignored.__@param name Name of the new pattern_@return A new pattern which is appended to this one;public Pattern<T, T> followedBy(final String name) {_		return new Pattern<>(name, this, ConsumingStrategy.SKIP_TILL_NEXT)__	};appends,a,new,pattern,to,the,existing,one,the,new,pattern,enforces,non,strict,temporal,contiguity,this,means,that,a,matching,event,of,this,pattern,and,the,preceding,matching,event,might,be,interleaved,with,other,events,which,are,ignored,param,name,name,of,the,new,pattern,return,a,new,pattern,which,is,appended,to,this,one;public,pattern,t,t,followed,by,final,string,name,return,new,pattern,name,this,consuming,strategy
Pattern -> public Pattern<T, T> followedBy(final String name);1499248439;Appends a new pattern to the existing one. The new pattern enforces non-strict_temporal contiguity. This means that a matching event of this pattern and the_preceding matching event might be interleaved with other events which are ignored.__@param name Name of the new pattern_@return A new pattern which is appended to this one;public Pattern<T, T> followedBy(final String name) {_		return new Pattern<>(name, this, ConsumingStrategy.SKIP_TILL_NEXT)__	};appends,a,new,pattern,to,the,existing,one,the,new,pattern,enforces,non,strict,temporal,contiguity,this,means,that,a,matching,event,of,this,pattern,and,the,preceding,matching,event,might,be,interleaved,with,other,events,which,are,ignored,param,name,name,of,the,new,pattern,return,a,new,pattern,which,is,appended,to,this,one;public,pattern,t,t,followed,by,final,string,name,return,new,pattern,name,this,consuming,strategy
Pattern -> public Pattern<T, T> followedBy(final String name);1503420807;Appends a new pattern to the existing one. The new pattern enforces non-strict_temporal contiguity. This means that a matching event of this pattern and the_preceding matching event might be interleaved with other events which are ignored.__@param name Name of the new pattern_@return A new pattern which is appended to this one;public Pattern<T, T> followedBy(final String name) {_		return new Pattern<>(name, this, ConsumingStrategy.SKIP_TILL_NEXT)__	};appends,a,new,pattern,to,the,existing,one,the,new,pattern,enforces,non,strict,temporal,contiguity,this,means,that,a,matching,event,of,this,pattern,and,the,preceding,matching,event,might,be,interleaved,with,other,events,which,are,ignored,param,name,name,of,the,new,pattern,return,a,new,pattern,which,is,appended,to,this,one;public,pattern,t,t,followed,by,final,string,name,return,new,pattern,name,this,consuming,strategy
Pattern -> public Pattern<T, T> followedBy(final String name);1503558242;Appends a new pattern to the existing one. The new pattern enforces non-strict_temporal contiguity. This means that a matching event of this pattern and the_preceding matching event might be interleaved with other events which are ignored.__@param name Name of the new pattern_@return A new pattern which is appended to this one;public Pattern<T, T> followedBy(final String name) {_		return new Pattern<>(name, this, ConsumingStrategy.SKIP_TILL_NEXT)__	};appends,a,new,pattern,to,the,existing,one,the,new,pattern,enforces,non,strict,temporal,contiguity,this,means,that,a,matching,event,of,this,pattern,and,the,preceding,matching,event,might,be,interleaved,with,other,events,which,are,ignored,param,name,name,of,the,new,pattern,return,a,new,pattern,which,is,appended,to,this,one;public,pattern,t,t,followed,by,final,string,name,return,new,pattern,name,this,consuming,strategy
Pattern -> public Pattern<T, T> followedBy(final String name);1504268438;Appends a new pattern to the existing one. The new pattern enforces non-strict_temporal contiguity. This means that a matching event of this pattern and the_preceding matching event might be interleaved with other events which are ignored.__@param name Name of the new pattern_@return A new pattern which is appended to this one;public Pattern<T, T> followedBy(final String name) {_		return new Pattern<>(name, this, ConsumingStrategy.SKIP_TILL_NEXT, afterMatchSkipStrategy)__	};appends,a,new,pattern,to,the,existing,one,the,new,pattern,enforces,non,strict,temporal,contiguity,this,means,that,a,matching,event,of,this,pattern,and,the,preceding,matching,event,might,be,interleaved,with,other,events,which,are,ignored,param,name,name,of,the,new,pattern,return,a,new,pattern,which,is,appended,to,this,one;public,pattern,t,t,followed,by,final,string,name,return,new,pattern,name,this,consuming,strategy,after,match,skip,strategy
Pattern -> public Pattern<T, T> followedBy(final String name);1530798894;Appends a new pattern to the existing one. The new pattern enforces non-strict_temporal contiguity. This means that a matching event of this pattern and the_preceding matching event might be interleaved with other events which are ignored.__@param name Name of the new pattern_@return A new pattern which is appended to this one;public Pattern<T, T> followedBy(final String name) {_		return new Pattern<>(name, this, ConsumingStrategy.SKIP_TILL_NEXT, afterMatchSkipStrategy)__	};appends,a,new,pattern,to,the,existing,one,the,new,pattern,enforces,non,strict,temporal,contiguity,this,means,that,a,matching,event,of,this,pattern,and,the,preceding,matching,event,might,be,interleaved,with,other,events,which,are,ignored,param,name,name,of,the,new,pattern,return,a,new,pattern,which,is,appended,to,this,one;public,pattern,t,t,followed,by,final,string,name,return,new,pattern,name,this,consuming,strategy,after,match,skip,strategy
Pattern -> public Pattern<T, T> followedBy(final String name);1540208358;Appends a new pattern to the existing one. The new pattern enforces non-strict_temporal contiguity. This means that a matching event of this pattern and the_preceding matching event might be interleaved with other events which are ignored.__@param name Name of the new pattern_@return A new pattern which is appended to this one;public Pattern<T, T> followedBy(final String name) {_		return new Pattern<>(name, this, ConsumingStrategy.SKIP_TILL_NEXT, afterMatchSkipStrategy)__	};appends,a,new,pattern,to,the,existing,one,the,new,pattern,enforces,non,strict,temporal,contiguity,this,means,that,a,matching,event,of,this,pattern,and,the,preceding,matching,event,might,be,interleaved,with,other,events,which,are,ignored,param,name,name,of,the,new,pattern,return,a,new,pattern,which,is,appended,to,this,one;public,pattern,t,t,followed,by,final,string,name,return,new,pattern,name,this,consuming,strategy,after,match,skip,strategy
Pattern -> public Pattern<T, T> followedBy(final String name);1543413704;Appends a new pattern to the existing one. The new pattern enforces non-strict_temporal contiguity. This means that a matching event of this pattern and the_preceding matching event might be interleaved with other events which are ignored.__@param name Name of the new pattern_@return A new pattern which is appended to this one;public Pattern<T, T> followedBy(final String name) {_		return new Pattern<>(name, this, ConsumingStrategy.SKIP_TILL_NEXT, afterMatchSkipStrategy)__	};appends,a,new,pattern,to,the,existing,one,the,new,pattern,enforces,non,strict,temporal,contiguity,this,means,that,a,matching,event,of,this,pattern,and,the,preceding,matching,event,might,be,interleaved,with,other,events,which,are,ignored,param,name,name,of,the,new,pattern,return,a,new,pattern,which,is,appended,to,this,one;public,pattern,t,t,followed,by,final,string,name,return,new,pattern,name,this,consuming,strategy,after,match,skip,strategy
Pattern -> public Pattern<T, F> oneOrMore();1490262475;Specifies that this pattern can occur one or more times(kleene star)._This means at least one and at most infinite number of events can be matched in this state.__@return The same pattern with applied Kleene plus operator__@throws MalformedPatternException if quantifier already applied;public Pattern<T, F> oneOrMore() {_		return oneOrMore(true)__	};specifies,that,this,pattern,can,occur,one,or,more,times,kleene,star,this,means,at,least,one,and,at,most,infinite,number,of,events,can,be,matched,in,this,state,return,the,same,pattern,with,applied,kleene,plus,operator,throws,malformed,pattern,exception,if,quantifier,already,applied;public,pattern,t,f,one,or,more,return,one,or,more,true
Pattern -> public Pattern<T, F> oneOrMore();1490638274;Specifies that this pattern can occur one or more times(kleene star)._This means at least one and at most infinite number of events can be matched in this state.__@return The same pattern with applied Kleene plus operator__@throws MalformedPatternException if quantifier already applied;public Pattern<T, F> oneOrMore() {_		return oneOrMore(true)__	};specifies,that,this,pattern,can,occur,one,or,more,times,kleene,star,this,means,at,least,one,and,at,most,infinite,number,of,events,can,be,matched,in,this,state,return,the,same,pattern,with,applied,kleene,plus,operator,throws,malformed,pattern,exception,if,quantifier,already,applied;public,pattern,t,f,one,or,more,return,one,or,more,true
Pattern -> public Pattern<T, F> oneOrMore();1490862259;Specifies that this pattern can occur one or more times(kleene star)._This means at least one and at most infinite number of events can be matched in this state.__@return The same pattern with applied Kleene plus operator__@throws MalformedPatternException if quantifier already applied;public Pattern<T, F> oneOrMore() {_		return oneOrMore(true)__	};specifies,that,this,pattern,can,occur,one,or,more,times,kleene,star,this,means,at,least,one,and,at,most,infinite,number,of,events,can,be,matched,in,this,state,return,the,same,pattern,with,applied,kleene,plus,operator,throws,malformed,pattern,exception,if,quantifier,already,applied;public,pattern,t,f,one,or,more,return,one,or,more,true
Pattern -> public Pattern<T, F> oneOrMore();1491647251;Specifies that this pattern can occur one or more times(kleene star)._This means at least one and at most infinite number of events can be matched in this state.__@return The same pattern with applied Kleene plus operator__@throws MalformedPatternException if quantifier already applied;public Pattern<T, F> oneOrMore() {_		return oneOrMore(true)__	};specifies,that,this,pattern,can,occur,one,or,more,times,kleene,star,this,means,at,least,one,and,at,most,infinite,number,of,events,can,be,matched,in,this,state,return,the,same,pattern,with,applied,kleene,plus,operator,throws,malformed,pattern,exception,if,quantifier,already,applied;public,pattern,t,f,one,or,more,return,one,or,more,true
Pattern -> public Pattern<T, F> oneOrMore();1493201751;Specifies that this pattern can occur {@code one or more} times._This means at least one and at most infinite number of events can_be matched to this pattern.__<p>If this quantifier is enabled for a_pattern {@code A.oneOrMore().followedBy(B)} and a sequence of events_{@code A1 A2 B} appears, this will generate patterns:_{@code A1 B} and {@code A1 A2 B}. See also {@link #allowCombinations()}.__@return The same pattern with a {@link Quantifier#ONE_OR_MORE()} quantifier applied._@throws MalformedPatternException if the quantifier is not applicable to this pattern.;public Pattern<T, F> oneOrMore() {_		checkIfQuantifierApplied()__		this.quantifier = Quantifier.ONE_OR_MORE()__		return this__	};specifies,that,this,pattern,can,occur,code,one,or,more,times,this,means,at,least,one,and,at,most,infinite,number,of,events,can,be,matched,to,this,pattern,p,if,this,quantifier,is,enabled,for,a,pattern,code,a,one,or,more,followed,by,b,and,a,sequence,of,events,code,a1,a2,b,appears,this,will,generate,patterns,code,a1,b,and,code,a1,a2,b,see,also,link,allow,combinations,return,the,same,pattern,with,a,link,quantifier,quantifier,applied,throws,malformed,pattern,exception,if,the,quantifier,is,not,applicable,to,this,pattern;public,pattern,t,f,one,or,more,check,if,quantifier,applied,this,quantifier,quantifier,return,this
Pattern -> public Pattern<T, F> oneOrMore();1493201753;Specifies that this pattern can occur {@code one or more} times._This means at least one and at most infinite number of events can_be matched to this pattern.__<p>If this quantifier is enabled for a_pattern {@code A.oneOrMore().followedBy(B)} and a sequence of events_{@code A1 A2 B} appears, this will generate patterns:_{@code A1 B} and {@code A1 A2 B}. See also {@link #allowCombinations()}.__@return The same pattern with a {@link Quantifier#ONE_OR_MORE()} quantifier applied._@throws MalformedPatternException if the quantifier is not applicable to this pattern.;public Pattern<T, F> oneOrMore() {_		checkIfQuantifierApplied()__		this.quantifier = Quantifier.ONE_OR_MORE()__		return this__	};specifies,that,this,pattern,can,occur,code,one,or,more,times,this,means,at,least,one,and,at,most,infinite,number,of,events,can,be,matched,to,this,pattern,p,if,this,quantifier,is,enabled,for,a,pattern,code,a,one,or,more,followed,by,b,and,a,sequence,of,events,code,a1,a2,b,appears,this,will,generate,patterns,code,a1,b,and,code,a1,a2,b,see,also,link,allow,combinations,return,the,same,pattern,with,a,link,quantifier,quantifier,applied,throws,malformed,pattern,exception,if,the,quantifier,is,not,applicable,to,this,pattern;public,pattern,t,f,one,or,more,check,if,quantifier,applied,this,quantifier,quantifier,return,this
Pattern -> public Pattern<T, F> oneOrMore();1493382517;Specifies that this pattern can occur {@code one or more} times._This means at least one and at most infinite number of events can_be matched to this pattern.__<p>If this quantifier is enabled for a_pattern {@code A.oneOrMore().followedBy(B)} and a sequence of events_{@code A1 A2 B} appears, this will generate patterns:_{@code A1 B} and {@code A1 A2 B}. See also {@link #allowCombinations()}.__@return The same pattern with a {@link Quantifier#ONE_OR_MORE(ConsumingStrategy)} quantifier applied._@throws MalformedPatternException if the quantifier is not applicable to this pattern.;public Pattern<T, F> oneOrMore() {_		checkIfQuantifierApplied()__		this.quantifier = Quantifier.ONE_OR_MORE(quantifier.getConsumingStrategy())__		return this__	};specifies,that,this,pattern,can,occur,code,one,or,more,times,this,means,at,least,one,and,at,most,infinite,number,of,events,can,be,matched,to,this,pattern,p,if,this,quantifier,is,enabled,for,a,pattern,code,a,one,or,more,followed,by,b,and,a,sequence,of,events,code,a1,a2,b,appears,this,will,generate,patterns,code,a1,b,and,code,a1,a2,b,see,also,link,allow,combinations,return,the,same,pattern,with,a,link,quantifier,consuming,strategy,quantifier,applied,throws,malformed,pattern,exception,if,the,quantifier,is,not,applicable,to,this,pattern;public,pattern,t,f,one,or,more,check,if,quantifier,applied,this,quantifier,quantifier,quantifier,get,consuming,strategy,return,this
Pattern -> public Pattern<T, F> oneOrMore();1493906327;Specifies that this pattern can occur {@code one or more} times._This means at least one and at most infinite number of events can_be matched to this pattern.__<p>If this quantifier is enabled for a_pattern {@code A.oneOrMore().followedBy(B)} and a sequence of events_{@code A1 A2 B} appears, this will generate patterns:_{@code A1 B} and {@code A1 A2 B}. See also {@link #allowCombinations()}.__@return The same pattern with a {@link Quantifier#ONE_OR_MORE(ConsumingStrategy)} quantifier applied._@throws MalformedPatternException if the quantifier is not applicable to this pattern.;public Pattern<T, F> oneOrMore() {_		checkIfQuantifierApplied()__		this.quantifier = Quantifier.ONE_OR_MORE(quantifier.getConsumingStrategy())__		return this__	};specifies,that,this,pattern,can,occur,code,one,or,more,times,this,means,at,least,one,and,at,most,infinite,number,of,events,can,be,matched,to,this,pattern,p,if,this,quantifier,is,enabled,for,a,pattern,code,a,one,or,more,followed,by,b,and,a,sequence,of,events,code,a1,a2,b,appears,this,will,generate,patterns,code,a1,b,and,code,a1,a2,b,see,also,link,allow,combinations,return,the,same,pattern,with,a,link,quantifier,consuming,strategy,quantifier,applied,throws,malformed,pattern,exception,if,the,quantifier,is,not,applicable,to,this,pattern;public,pattern,t,f,one,or,more,check,if,quantifier,applied,this,quantifier,quantifier,quantifier,get,consuming,strategy,return,this
Pattern -> public Pattern<T, F> oneOrMore();1493985576;Specifies that this pattern can occur {@code one or more} times._This means at least one and at most infinite number of events can_be matched to this pattern.__<p>If this quantifier is enabled for a_pattern {@code A.oneOrMore().followedBy(B)} and a sequence of events_{@code A1 A2 B} appears, this will generate patterns:_{@code A1 B} and {@code A1 A2 B}. See also {@link #allowCombinations()}.__@return The same pattern with a {@link Quantifier#ONE_OR_MORE(ConsumingStrategy)} quantifier applied._@throws MalformedPatternException if the quantifier is not applicable to this pattern.;public Pattern<T, F> oneOrMore() {_		checkIfNoNotPattern()__		checkIfQuantifierApplied()__		this.quantifier = Quantifier.ONE_OR_MORE(quantifier.getConsumingStrategy())__		return this__	};specifies,that,this,pattern,can,occur,code,one,or,more,times,this,means,at,least,one,and,at,most,infinite,number,of,events,can,be,matched,to,this,pattern,p,if,this,quantifier,is,enabled,for,a,pattern,code,a,one,or,more,followed,by,b,and,a,sequence,of,events,code,a1,a2,b,appears,this,will,generate,patterns,code,a1,b,and,code,a1,a2,b,see,also,link,allow,combinations,return,the,same,pattern,with,a,link,quantifier,consuming,strategy,quantifier,applied,throws,malformed,pattern,exception,if,the,quantifier,is,not,applicable,to,this,pattern;public,pattern,t,f,one,or,more,check,if,no,not,pattern,check,if,quantifier,applied,this,quantifier,quantifier,quantifier,get,consuming,strategy,return,this
Pattern -> public Pattern<T, F> oneOrMore();1493997908;Specifies that this pattern can occur {@code one or more} times._This means at least one and at most infinite number of events can_be matched to this pattern.__<p>If this quantifier is enabled for a_pattern {@code A.oneOrMore().followedBy(B)} and a sequence of events_{@code A1 A2 B} appears, this will generate patterns:_{@code A1 B} and {@code A1 A2 B}. See also {@link #allowCombinations()}.__@return The same pattern with a {@link Quantifier#ONE_OR_MORE(ConsumingStrategy)} quantifier applied._@throws MalformedPatternException if the quantifier is not applicable to this pattern.;public Pattern<T, F> oneOrMore() {_		checkIfNoNotPattern()__		checkIfQuantifierApplied()__		this.quantifier = Quantifier.ONE_OR_MORE(quantifier.getConsumingStrategy())__		return this__	};specifies,that,this,pattern,can,occur,code,one,or,more,times,this,means,at,least,one,and,at,most,infinite,number,of,events,can,be,matched,to,this,pattern,p,if,this,quantifier,is,enabled,for,a,pattern,code,a,one,or,more,followed,by,b,and,a,sequence,of,events,code,a1,a2,b,appears,this,will,generate,patterns,code,a1,b,and,code,a1,a2,b,see,also,link,allow,combinations,return,the,same,pattern,with,a,link,quantifier,consuming,strategy,quantifier,applied,throws,malformed,pattern,exception,if,the,quantifier,is,not,applicable,to,this,pattern;public,pattern,t,f,one,or,more,check,if,no,not,pattern,check,if,quantifier,applied,this,quantifier,quantifier,quantifier,get,consuming,strategy,return,this
Pattern -> public Pattern<T, F> oneOrMore();1495961498;Specifies that this pattern can occur {@code one or more} times._This means at least one and at most infinite number of events can_be matched to this pattern.__<p>If this quantifier is enabled for a_pattern {@code A.oneOrMore().followedBy(B)} and a sequence of events_{@code A1 A2 B} appears, this will generate patterns:_{@code A1 B} and {@code A1 A2 B}. See also {@link #allowCombinations()}.__@return The same pattern with a {@link Quantifier#oneOrMore(ConsumingStrategy)} quantifier applied._@throws MalformedPatternException if the quantifier is not applicable to this pattern.;public Pattern<T, F> oneOrMore() {_		checkIfNoNotPattern()__		checkIfQuantifierApplied()__		this.quantifier = Quantifier.oneOrMore(quantifier.getConsumingStrategy())__		return this__	};specifies,that,this,pattern,can,occur,code,one,or,more,times,this,means,at,least,one,and,at,most,infinite,number,of,events,can,be,matched,to,this,pattern,p,if,this,quantifier,is,enabled,for,a,pattern,code,a,one,or,more,followed,by,b,and,a,sequence,of,events,code,a1,a2,b,appears,this,will,generate,patterns,code,a1,b,and,code,a1,a2,b,see,also,link,allow,combinations,return,the,same,pattern,with,a,link,quantifier,one,or,more,consuming,strategy,quantifier,applied,throws,malformed,pattern,exception,if,the,quantifier,is,not,applicable,to,this,pattern;public,pattern,t,f,one,or,more,check,if,no,not,pattern,check,if,quantifier,applied,this,quantifier,quantifier,one,or,more,quantifier,get,consuming,strategy,return,this
Pattern -> public Pattern<T, F> oneOrMore();1497940477;Specifies that this pattern can occur {@code one or more} times._This means at least one and at most infinite number of events can_be matched to this pattern.__<p>If this quantifier is enabled for a_pattern {@code A.oneOrMore().followedBy(B)} and a sequence of events_{@code A1 A2 B} appears, this will generate patterns:_{@code A1 B} and {@code A1 A2 B}. See also {@link #allowCombinations()}.__@return The same pattern with a {@link Quantifier#oneOrMore(ConsumingStrategy)} quantifier applied._@throws MalformedPatternException if the quantifier is not applicable to this pattern.;public Pattern<T, F> oneOrMore() {_		checkIfNoNotPattern()__		checkIfQuantifierApplied()__		this.quantifier = Quantifier.oneOrMore(quantifier.getConsumingStrategy())__		return this__	};specifies,that,this,pattern,can,occur,code,one,or,more,times,this,means,at,least,one,and,at,most,infinite,number,of,events,can,be,matched,to,this,pattern,p,if,this,quantifier,is,enabled,for,a,pattern,code,a,one,or,more,followed,by,b,and,a,sequence,of,events,code,a1,a2,b,appears,this,will,generate,patterns,code,a1,b,and,code,a1,a2,b,see,also,link,allow,combinations,return,the,same,pattern,with,a,link,quantifier,one,or,more,consuming,strategy,quantifier,applied,throws,malformed,pattern,exception,if,the,quantifier,is,not,applicable,to,this,pattern;public,pattern,t,f,one,or,more,check,if,no,not,pattern,check,if,quantifier,applied,this,quantifier,quantifier,one,or,more,quantifier,get,consuming,strategy,return,this
Pattern -> public Pattern<T, F> oneOrMore();1498548074;Specifies that this pattern can occur {@code one or more} times._This means at least one and at most infinite number of events can_be matched to this pattern.__<p>If this quantifier is enabled for a_pattern {@code A.oneOrMore().followedBy(B)} and a sequence of events_{@code A1 A2 B} appears, this will generate patterns:_{@code A1 B} and {@code A1 A2 B}. See also {@link #allowCombinations()}.__@return The same pattern with a {@link Quantifier#oneOrMore(ConsumingStrategy)} quantifier applied._@throws MalformedPatternException if the quantifier is not applicable to this pattern.;public Pattern<T, F> oneOrMore() {_		checkIfNoNotPattern()__		checkIfQuantifierApplied()__		this.quantifier = Quantifier.oneOrMore(quantifier.getConsumingStrategy())__		return this__	};specifies,that,this,pattern,can,occur,code,one,or,more,times,this,means,at,least,one,and,at,most,infinite,number,of,events,can,be,matched,to,this,pattern,p,if,this,quantifier,is,enabled,for,a,pattern,code,a,one,or,more,followed,by,b,and,a,sequence,of,events,code,a1,a2,b,appears,this,will,generate,patterns,code,a1,b,and,code,a1,a2,b,see,also,link,allow,combinations,return,the,same,pattern,with,a,link,quantifier,one,or,more,consuming,strategy,quantifier,applied,throws,malformed,pattern,exception,if,the,quantifier,is,not,applicable,to,this,pattern;public,pattern,t,f,one,or,more,check,if,no,not,pattern,check,if,quantifier,applied,this,quantifier,quantifier,one,or,more,quantifier,get,consuming,strategy,return,this
Pattern -> public Pattern<T, F> oneOrMore();1499244360;Specifies that this pattern can occur {@code one or more} times._This means at least one and at most infinite number of events can_be matched to this pattern.__<p>If this quantifier is enabled for a_pattern {@code A.oneOrMore().followedBy(B)} and a sequence of events_{@code A1 A2 B} appears, this will generate patterns:_{@code A1 B} and {@code A1 A2 B}. See also {@link #allowCombinations()}.__@return The same pattern with a {@link Quantifier#oneOrMore(ConsumingStrategy)} quantifier applied._@throws MalformedPatternException if the quantifier is not applicable to this pattern.;public Pattern<T, F> oneOrMore() {_		checkIfNoNotPattern()__		checkIfQuantifierApplied()__		this.quantifier = Quantifier.oneOrMore(quantifier.getConsumingStrategy())__		return this__	};specifies,that,this,pattern,can,occur,code,one,or,more,times,this,means,at,least,one,and,at,most,infinite,number,of,events,can,be,matched,to,this,pattern,p,if,this,quantifier,is,enabled,for,a,pattern,code,a,one,or,more,followed,by,b,and,a,sequence,of,events,code,a1,a2,b,appears,this,will,generate,patterns,code,a1,b,and,code,a1,a2,b,see,also,link,allow,combinations,return,the,same,pattern,with,a,link,quantifier,one,or,more,consuming,strategy,quantifier,applied,throws,malformed,pattern,exception,if,the,quantifier,is,not,applicable,to,this,pattern;public,pattern,t,f,one,or,more,check,if,no,not,pattern,check,if,quantifier,applied,this,quantifier,quantifier,one,or,more,quantifier,get,consuming,strategy,return,this
Pattern -> public Pattern<T, F> oneOrMore();1499248439;Specifies that this pattern can occur {@code one or more} times._This means at least one and at most infinite number of events can_be matched to this pattern.__<p>If this quantifier is enabled for a_pattern {@code A.oneOrMore().followedBy(B)} and a sequence of events_{@code A1 A2 B} appears, this will generate patterns:_{@code A1 B} and {@code A1 A2 B}. See also {@link #allowCombinations()}.__@return The same pattern with a {@link Quantifier#oneOrMore(ConsumingStrategy)} quantifier applied._@throws MalformedPatternException if the quantifier is not applicable to this pattern.;public Pattern<T, F> oneOrMore() {_		checkIfNoNotPattern()__		checkIfQuantifierApplied()__		this.quantifier = Quantifier.oneOrMore(quantifier.getConsumingStrategy())__		return this__	};specifies,that,this,pattern,can,occur,code,one,or,more,times,this,means,at,least,one,and,at,most,infinite,number,of,events,can,be,matched,to,this,pattern,p,if,this,quantifier,is,enabled,for,a,pattern,code,a,one,or,more,followed,by,b,and,a,sequence,of,events,code,a1,a2,b,appears,this,will,generate,patterns,code,a1,b,and,code,a1,a2,b,see,also,link,allow,combinations,return,the,same,pattern,with,a,link,quantifier,one,or,more,consuming,strategy,quantifier,applied,throws,malformed,pattern,exception,if,the,quantifier,is,not,applicable,to,this,pattern;public,pattern,t,f,one,or,more,check,if,no,not,pattern,check,if,quantifier,applied,this,quantifier,quantifier,one,or,more,quantifier,get,consuming,strategy,return,this
Pattern -> public Pattern<T, F> oneOrMore();1503420807;Specifies that this pattern can occur {@code one or more} times._This means at least one and at most infinite number of events can_be matched to this pattern.__<p>If this quantifier is enabled for a_pattern {@code A.oneOrMore().followedBy(B)} and a sequence of events_{@code A1 A2 B} appears, this will generate patterns:_{@code A1 B} and {@code A1 A2 B}. See also {@link #allowCombinations()}.__@return The same pattern with a {@link Quantifier#looping(ConsumingStrategy)} quantifier applied._@throws MalformedPatternException if the quantifier is not applicable to this pattern.;public Pattern<T, F> oneOrMore() {_		checkIfNoNotPattern()__		checkIfQuantifierApplied()__		this.quantifier = Quantifier.looping(quantifier.getConsumingStrategy())__		this.times = Times.of(1)__		return this__	};specifies,that,this,pattern,can,occur,code,one,or,more,times,this,means,at,least,one,and,at,most,infinite,number,of,events,can,be,matched,to,this,pattern,p,if,this,quantifier,is,enabled,for,a,pattern,code,a,one,or,more,followed,by,b,and,a,sequence,of,events,code,a1,a2,b,appears,this,will,generate,patterns,code,a1,b,and,code,a1,a2,b,see,also,link,allow,combinations,return,the,same,pattern,with,a,link,quantifier,looping,consuming,strategy,quantifier,applied,throws,malformed,pattern,exception,if,the,quantifier,is,not,applicable,to,this,pattern;public,pattern,t,f,one,or,more,check,if,no,not,pattern,check,if,quantifier,applied,this,quantifier,quantifier,looping,quantifier,get,consuming,strategy,this,times,times,of,1,return,this
Pattern -> public Pattern<T, F> oneOrMore();1503558242;Specifies that this pattern can occur {@code one or more} times._This means at least one and at most infinite number of events can_be matched to this pattern.__<p>If this quantifier is enabled for a_pattern {@code A.oneOrMore().followedBy(B)} and a sequence of events_{@code A1 A2 B} appears, this will generate patterns:_{@code A1 B} and {@code A1 A2 B}. See also {@link #allowCombinations()}.__@return The same pattern with a {@link Quantifier#looping(ConsumingStrategy)} quantifier applied._@throws MalformedPatternException if the quantifier is not applicable to this pattern.;public Pattern<T, F> oneOrMore() {_		checkIfNoNotPattern()__		checkIfQuantifierApplied()__		this.quantifier = Quantifier.looping(quantifier.getConsumingStrategy())__		this.times = Times.of(1)__		return this__	};specifies,that,this,pattern,can,occur,code,one,or,more,times,this,means,at,least,one,and,at,most,infinite,number,of,events,can,be,matched,to,this,pattern,p,if,this,quantifier,is,enabled,for,a,pattern,code,a,one,or,more,followed,by,b,and,a,sequence,of,events,code,a1,a2,b,appears,this,will,generate,patterns,code,a1,b,and,code,a1,a2,b,see,also,link,allow,combinations,return,the,same,pattern,with,a,link,quantifier,looping,consuming,strategy,quantifier,applied,throws,malformed,pattern,exception,if,the,quantifier,is,not,applicable,to,this,pattern;public,pattern,t,f,one,or,more,check,if,no,not,pattern,check,if,quantifier,applied,this,quantifier,quantifier,looping,quantifier,get,consuming,strategy,this,times,times,of,1,return,this
Pattern -> public Pattern<T, F> oneOrMore();1504268438;Specifies that this pattern can occur {@code one or more} times._This means at least one and at most infinite number of events can_be matched to this pattern.__<p>If this quantifier is enabled for a_pattern {@code A.oneOrMore().followedBy(B)} and a sequence of events_{@code A1 A2 B} appears, this will generate patterns:_{@code A1 B} and {@code A1 A2 B}. See also {@link #allowCombinations()}.__@return The same pattern with a {@link Quantifier#looping(ConsumingStrategy)} quantifier applied._@throws MalformedPatternException if the quantifier is not applicable to this pattern.;public Pattern<T, F> oneOrMore() {_		checkIfNoNotPattern()__		checkIfQuantifierApplied()__		this.quantifier = Quantifier.looping(quantifier.getConsumingStrategy())__		this.times = Times.of(1)__		return this__	};specifies,that,this,pattern,can,occur,code,one,or,more,times,this,means,at,least,one,and,at,most,infinite,number,of,events,can,be,matched,to,this,pattern,p,if,this,quantifier,is,enabled,for,a,pattern,code,a,one,or,more,followed,by,b,and,a,sequence,of,events,code,a1,a2,b,appears,this,will,generate,patterns,code,a1,b,and,code,a1,a2,b,see,also,link,allow,combinations,return,the,same,pattern,with,a,link,quantifier,looping,consuming,strategy,quantifier,applied,throws,malformed,pattern,exception,if,the,quantifier,is,not,applicable,to,this,pattern;public,pattern,t,f,one,or,more,check,if,no,not,pattern,check,if,quantifier,applied,this,quantifier,quantifier,looping,quantifier,get,consuming,strategy,this,times,times,of,1,return,this
Pattern -> public Pattern<T, F> oneOrMore();1530798894;Specifies that this pattern can occur {@code one or more} times._This means at least one and at most infinite number of events can_be matched to this pattern.__<p>If this quantifier is enabled for a_pattern {@code A.oneOrMore().followedBy(B)} and a sequence of events_{@code A1 A2 B} appears, this will generate patterns:_{@code A1 B} and {@code A1 A2 B}. See also {@link #allowCombinations()}.__@return The same pattern with a {@link Quantifier#looping(ConsumingStrategy)} quantifier applied._@throws MalformedPatternException if the quantifier is not applicable to this pattern.;public Pattern<T, F> oneOrMore() {_		checkIfNoNotPattern()__		checkIfQuantifierApplied()__		this.quantifier = Quantifier.looping(quantifier.getConsumingStrategy())__		this.times = Times.of(1)__		return this__	};specifies,that,this,pattern,can,occur,code,one,or,more,times,this,means,at,least,one,and,at,most,infinite,number,of,events,can,be,matched,to,this,pattern,p,if,this,quantifier,is,enabled,for,a,pattern,code,a,one,or,more,followed,by,b,and,a,sequence,of,events,code,a1,a2,b,appears,this,will,generate,patterns,code,a1,b,and,code,a1,a2,b,see,also,link,allow,combinations,return,the,same,pattern,with,a,link,quantifier,looping,consuming,strategy,quantifier,applied,throws,malformed,pattern,exception,if,the,quantifier,is,not,applicable,to,this,pattern;public,pattern,t,f,one,or,more,check,if,no,not,pattern,check,if,quantifier,applied,this,quantifier,quantifier,looping,quantifier,get,consuming,strategy,this,times,times,of,1,return,this
Pattern -> public Pattern<T, F> oneOrMore();1540208358;Specifies that this pattern can occur {@code one or more} times._This means at least one and at most infinite number of events can_be matched to this pattern.__<p>If this quantifier is enabled for a_pattern {@code A.oneOrMore().followedBy(B)} and a sequence of events_{@code A1 A2 B} appears, this will generate patterns:_{@code A1 B} and {@code A1 A2 B}. See also {@link #allowCombinations()}.__@return The same pattern with a {@link Quantifier#looping(ConsumingStrategy)} quantifier applied._@throws MalformedPatternException if the quantifier is not applicable to this pattern.;public Pattern<T, F> oneOrMore() {_		checkIfNoNotPattern()__		checkIfQuantifierApplied()__		this.quantifier = Quantifier.looping(quantifier.getConsumingStrategy())__		this.times = Times.of(1)__		return this__	};specifies,that,this,pattern,can,occur,code,one,or,more,times,this,means,at,least,one,and,at,most,infinite,number,of,events,can,be,matched,to,this,pattern,p,if,this,quantifier,is,enabled,for,a,pattern,code,a,one,or,more,followed,by,b,and,a,sequence,of,events,code,a1,a2,b,appears,this,will,generate,patterns,code,a1,b,and,code,a1,a2,b,see,also,link,allow,combinations,return,the,same,pattern,with,a,link,quantifier,looping,consuming,strategy,quantifier,applied,throws,malformed,pattern,exception,if,the,quantifier,is,not,applicable,to,this,pattern;public,pattern,t,f,one,or,more,check,if,no,not,pattern,check,if,quantifier,applied,this,quantifier,quantifier,looping,quantifier,get,consuming,strategy,this,times,times,of,1,return,this
Pattern -> public Pattern<T, F> oneOrMore();1543413704;Specifies that this pattern can occur {@code one or more} times._This means at least one and at most infinite number of events can_be matched to this pattern.__<p>If this quantifier is enabled for a_pattern {@code A.oneOrMore().followedBy(B)} and a sequence of events_{@code A1 A2 B} appears, this will generate patterns:_{@code A1 B} and {@code A1 A2 B}. See also {@link #allowCombinations()}.__@return The same pattern with a {@link Quantifier#looping(ConsumingStrategy)} quantifier applied._@throws MalformedPatternException if the quantifier is not applicable to this pattern.;public Pattern<T, F> oneOrMore() {_		checkIfNoNotPattern()__		checkIfQuantifierApplied()__		this.quantifier = Quantifier.looping(quantifier.getConsumingStrategy())__		this.times = Times.of(1)__		return this__	};specifies,that,this,pattern,can,occur,code,one,or,more,times,this,means,at,least,one,and,at,most,infinite,number,of,events,can,be,matched,to,this,pattern,p,if,this,quantifier,is,enabled,for,a,pattern,code,a,one,or,more,followed,by,b,and,a,sequence,of,events,code,a1,a2,b,appears,this,will,generate,patterns,code,a1,b,and,code,a1,a2,b,see,also,link,allow,combinations,return,the,same,pattern,with,a,link,quantifier,looping,consuming,strategy,quantifier,applied,throws,malformed,pattern,exception,if,the,quantifier,is,not,applicable,to,this,pattern;public,pattern,t,f,one,or,more,check,if,no,not,pattern,check,if,quantifier,applied,this,quantifier,quantifier,looping,quantifier,get,consuming,strategy,this,times,times,of,1,return,this
Pattern -> public Pattern<T, F> consecutive();1490862259;Works in conjunction with {@link Pattern#zeroOrMore()}, {@link Pattern#oneOrMore()} or {@link Pattern#times(int)}._Specifies that any not matching element breaks the loop.__<p>E.g. a pattern like:_<pre>{@code_Pattern.<Event>begin("start").where(new FilterFunction<Event>() {_@Override_public boolean filter(Event value) throws Exception {_return value.getName().equals("c")____.followedBy("middle").where(new FilterFunction<Event>() {_@Override_public boolean filter(Event value) throws Exception {_return value.getName().equals("a")____}<b>.oneOrMore(true).consecutive()</b>{@code_.followedBy("end1").where(new FilterFunction<Event>() {_@Override_public boolean filter(Event value) throws Exception {_return value.getName().equals("b")___})__}</pre>__<p>for a sequence: C D A1 A2 A3 D A4 B__<p>will generate matches: {C A1 B}, {C A1 A2 B}, {C A1 A2 A3 B}__<p><b>NOTICE:</b> This operator can be applied only when either zeroOrMore,_oneOrMore or times was previously applied!__<p>By default a relaxed continuity is applied.__@return pattern with continuity changed to strict;public Pattern<T, F> consecutive() {_		switch (this.quantifier) {__			case ZERO_OR_MORE_EAGER:_				this.quantifier = Quantifier.ZERO_OR_MORE_EAGER_STRICT__				break__			case ZERO_OR_MORE_COMBINATIONS:_				this.quantifier = Quantifier.ZERO_OR_MORE_COMBINATIONS_STRICT__				break__			case ONE_OR_MORE_EAGER:_				this.quantifier = Quantifier.ONE_OR_MORE_EAGER_STRICT__				break__			case ONE_OR_MORE_COMBINATIONS:_				this.quantifier = Quantifier.ONE_OR_MORE_COMBINATIONS_STRICT__				break__			case TIMES:_				this.quantifier = Quantifier.TIMES_STRICT__				break__			case ZERO_OR_MORE_COMBINATIONS_STRICT:_			case ONE_OR_MORE_EAGER_STRICT:_			case ONE_OR_MORE_COMBINATIONS_STRICT:_			case ZERO_OR_MORE_EAGER_STRICT:_			case TIMES_STRICT:_				throw new MalformedPatternException("Strict continuity already applied! consecutive() called twice.")__			case ONE:_			case OPTIONAL:_				throw new MalformedPatternException("Strict continuity cannot be applied to " + this.quantifier)__		}__		return this__	};works,in,conjunction,with,link,pattern,zero,or,more,link,pattern,one,or,more,or,link,pattern,times,int,specifies,that,any,not,matching,element,breaks,the,loop,p,e,g,a,pattern,like,pre,code,pattern,event,begin,start,where,new,filter,function,event,override,public,boolean,filter,event,value,throws,exception,return,value,get,name,equals,c,followed,by,middle,where,new,filter,function,event,override,public,boolean,filter,event,value,throws,exception,return,value,get,name,equals,a,b,one,or,more,true,consecutive,b,code,followed,by,end1,where,new,filter,function,event,override,public,boolean,filter,event,value,throws,exception,return,value,get,name,equals,b,pre,p,for,a,sequence,c,d,a1,a2,a3,d,a4,b,p,will,generate,matches,c,a1,b,c,a1,a2,b,c,a1,a2,a3,b,p,b,notice,b,this,operator,can,be,applied,only,when,either,zero,or,more,one,or,more,or,times,was,previously,applied,p,by,default,a,relaxed,continuity,is,applied,return,pattern,with,continuity,changed,to,strict;public,pattern,t,f,consecutive,switch,this,quantifier,case,this,quantifier,quantifier,break,case,this,quantifier,quantifier,break,case,this,quantifier,quantifier,break,case,this,quantifier,quantifier,break,case,times,this,quantifier,quantifier,break,case,case,case,case,case,throw,new,malformed,pattern,exception,strict,continuity,already,applied,consecutive,called,twice,case,one,case,optional,throw,new,malformed,pattern,exception,strict,continuity,cannot,be,applied,to,this,quantifier,return,this
Pattern -> public Pattern<T, F> consecutive();1491647251;Works in conjunction with {@link Pattern#zeroOrMore()}, {@link Pattern#oneOrMore()} or {@link Pattern#times(int)}._Specifies that any not matching element breaks the loop.__<p>E.g. a pattern like:_<pre>{@code_Pattern.<Event>begin("start").where(new FilterFunction<Event>() {_@Override_public boolean filter(Event value) throws Exception {_return value.getName().equals("c")____.followedBy("middle").where(new FilterFunction<Event>() {_@Override_public boolean filter(Event value) throws Exception {_return value.getName().equals("a")____}<b>.oneOrMore(true).consecutive()</b>{@code_.followedBy("end1").where(new FilterFunction<Event>() {_@Override_public boolean filter(Event value) throws Exception {_return value.getName().equals("b")___})__}</pre>__<p>for a sequence: C D A1 A2 A3 D A4 B__<p>will generate matches: {C A1 B}, {C A1 A2 B}, {C A1 A2 A3 B}__<p><b>NOTICE:</b> This operator can be applied only when either zeroOrMore,_oneOrMore or times was previously applied!__<p>By default a relaxed continuity is applied.__@return pattern with continuity changed to strict;public Pattern<T, F> consecutive() {_		switch (this.quantifier) {__			case ZERO_OR_MORE_EAGER:_				this.quantifier = Quantifier.ZERO_OR_MORE_EAGER_STRICT__				break__			case ZERO_OR_MORE_COMBINATIONS:_				this.quantifier = Quantifier.ZERO_OR_MORE_COMBINATIONS_STRICT__				break__			case ONE_OR_MORE_EAGER:_				this.quantifier = Quantifier.ONE_OR_MORE_EAGER_STRICT__				break__			case ONE_OR_MORE_COMBINATIONS:_				this.quantifier = Quantifier.ONE_OR_MORE_COMBINATIONS_STRICT__				break__			case TIMES:_				this.quantifier = Quantifier.TIMES_STRICT__				break__			case ZERO_OR_MORE_COMBINATIONS_STRICT:_			case ONE_OR_MORE_EAGER_STRICT:_			case ONE_OR_MORE_COMBINATIONS_STRICT:_			case ZERO_OR_MORE_EAGER_STRICT:_			case TIMES_STRICT:_				throw new MalformedPatternException("Strict continuity already applied! consecutive() called twice.")__			case ONE:_			case OPTIONAL:_				throw new MalformedPatternException("Strict continuity cannot be applied to " + this.quantifier)__		}__		return this__	};works,in,conjunction,with,link,pattern,zero,or,more,link,pattern,one,or,more,or,link,pattern,times,int,specifies,that,any,not,matching,element,breaks,the,loop,p,e,g,a,pattern,like,pre,code,pattern,event,begin,start,where,new,filter,function,event,override,public,boolean,filter,event,value,throws,exception,return,value,get,name,equals,c,followed,by,middle,where,new,filter,function,event,override,public,boolean,filter,event,value,throws,exception,return,value,get,name,equals,a,b,one,or,more,true,consecutive,b,code,followed,by,end1,where,new,filter,function,event,override,public,boolean,filter,event,value,throws,exception,return,value,get,name,equals,b,pre,p,for,a,sequence,c,d,a1,a2,a3,d,a4,b,p,will,generate,matches,c,a1,b,c,a1,a2,b,c,a1,a2,a3,b,p,b,notice,b,this,operator,can,be,applied,only,when,either,zero,or,more,one,or,more,or,times,was,previously,applied,p,by,default,a,relaxed,continuity,is,applied,return,pattern,with,continuity,changed,to,strict;public,pattern,t,f,consecutive,switch,this,quantifier,case,this,quantifier,quantifier,break,case,this,quantifier,quantifier,break,case,this,quantifier,quantifier,break,case,this,quantifier,quantifier,break,case,times,this,quantifier,quantifier,break,case,case,case,case,case,throw,new,malformed,pattern,exception,strict,continuity,already,applied,consecutive,called,twice,case,one,case,optional,throw,new,malformed,pattern,exception,strict,continuity,cannot,be,applied,to,this,quantifier,return,this
Pattern -> public Pattern<T, F> consecutive();1493201751;Works in conjunction with {@link Pattern#oneOrMore()} or {@link Pattern#times(int)}._Specifies that any not matching element breaks the loop.__<p>E.g. a pattern like:_<pre>{@code_Pattern.<Event>begin("start").where(new SimpleCondition<Event>() {_@Override_public boolean filter(Event value) throws Exception {_return value.getName().equals("c")____.followedBy("middle").where(new SimpleCondition<Event>() {_@Override_public boolean filter(Event value) throws Exception {_return value.getName().equals("a")___}).oneOrMore().consecutive()_.followedBy("end1").where(new SimpleCondition<Event>() {_@Override_public boolean filter(Event value) throws Exception {_return value.getName().equals("b")___})__}</pre>__<p>for a sequence: C D A1 A2 A3 D A4 B__<p>will generate matches: {C A1 B}, {C A1 A2 B}, {C A1 A2 A3 B}__<p>By default a relaxed continuity is applied.__@return pattern with continuity changed to strict;public Pattern<T, F> consecutive() {_		quantifier.makeConsecutive()__		return this__	};works,in,conjunction,with,link,pattern,one,or,more,or,link,pattern,times,int,specifies,that,any,not,matching,element,breaks,the,loop,p,e,g,a,pattern,like,pre,code,pattern,event,begin,start,where,new,simple,condition,event,override,public,boolean,filter,event,value,throws,exception,return,value,get,name,equals,c,followed,by,middle,where,new,simple,condition,event,override,public,boolean,filter,event,value,throws,exception,return,value,get,name,equals,a,one,or,more,consecutive,followed,by,end1,where,new,simple,condition,event,override,public,boolean,filter,event,value,throws,exception,return,value,get,name,equals,b,pre,p,for,a,sequence,c,d,a1,a2,a3,d,a4,b,p,will,generate,matches,c,a1,b,c,a1,a2,b,c,a1,a2,a3,b,p,by,default,a,relaxed,continuity,is,applied,return,pattern,with,continuity,changed,to,strict;public,pattern,t,f,consecutive,quantifier,make,consecutive,return,this
Pattern -> public Pattern<T, F> consecutive();1493201753;Works in conjunction with {@link Pattern#oneOrMore()} or {@link Pattern#times(int)}._Specifies that any not matching element breaks the loop.__<p>E.g. a pattern like:_<pre>{@code_Pattern.<Event>begin("start").where(new SimpleCondition<Event>() {_@Override_public boolean filter(Event value) throws Exception {_return value.getName().equals("c")____.followedBy("middle").where(new SimpleCondition<Event>() {_@Override_public boolean filter(Event value) throws Exception {_return value.getName().equals("a")___}).oneOrMore().consecutive()_.followedBy("end1").where(new SimpleCondition<Event>() {_@Override_public boolean filter(Event value) throws Exception {_return value.getName().equals("b")___})__}</pre>__<p>for a sequence: C D A1 A2 A3 D A4 B__<p>will generate matches: {C A1 B}, {C A1 A2 B}, {C A1 A2 A3 B}__<p>By default a relaxed continuity is applied.__@return pattern with continuity changed to strict;public Pattern<T, F> consecutive() {_		quantifier.consecutive()__		return this__	};works,in,conjunction,with,link,pattern,one,or,more,or,link,pattern,times,int,specifies,that,any,not,matching,element,breaks,the,loop,p,e,g,a,pattern,like,pre,code,pattern,event,begin,start,where,new,simple,condition,event,override,public,boolean,filter,event,value,throws,exception,return,value,get,name,equals,c,followed,by,middle,where,new,simple,condition,event,override,public,boolean,filter,event,value,throws,exception,return,value,get,name,equals,a,one,or,more,consecutive,followed,by,end1,where,new,simple,condition,event,override,public,boolean,filter,event,value,throws,exception,return,value,get,name,equals,b,pre,p,for,a,sequence,c,d,a1,a2,a3,d,a4,b,p,will,generate,matches,c,a1,b,c,a1,a2,b,c,a1,a2,a3,b,p,by,default,a,relaxed,continuity,is,applied,return,pattern,with,continuity,changed,to,strict;public,pattern,t,f,consecutive,quantifier,consecutive,return,this
Pattern -> public Pattern<T, F> consecutive();1493382517;Works in conjunction with {@link Pattern#oneOrMore()} or {@link Pattern#times(int)}._Specifies that any not matching element breaks the loop.__<p>E.g. a pattern like:_<pre>{@code_Pattern.<Event>begin("start").where(new SimpleCondition<Event>() {_@Override_public boolean filter(Event value) throws Exception {_return value.getName().equals("c")____.followedBy("middle").where(new SimpleCondition<Event>() {_@Override_public boolean filter(Event value) throws Exception {_return value.getName().equals("a")___}).oneOrMore().consecutive()_.followedBy("end1").where(new SimpleCondition<Event>() {_@Override_public boolean filter(Event value) throws Exception {_return value.getName().equals("b")___})__}</pre>__<p>for a sequence: C D A1 A2 A3 D A4 B__<p>will generate matches: {C A1 B}, {C A1 A2 B}, {C A1 A2 A3 B}__<p>By default a relaxed continuity is applied.__@return pattern with continuity changed to strict;public Pattern<T, F> consecutive() {_		quantifier.consecutive()__		return this__	};works,in,conjunction,with,link,pattern,one,or,more,or,link,pattern,times,int,specifies,that,any,not,matching,element,breaks,the,loop,p,e,g,a,pattern,like,pre,code,pattern,event,begin,start,where,new,simple,condition,event,override,public,boolean,filter,event,value,throws,exception,return,value,get,name,equals,c,followed,by,middle,where,new,simple,condition,event,override,public,boolean,filter,event,value,throws,exception,return,value,get,name,equals,a,one,or,more,consecutive,followed,by,end1,where,new,simple,condition,event,override,public,boolean,filter,event,value,throws,exception,return,value,get,name,equals,b,pre,p,for,a,sequence,c,d,a1,a2,a3,d,a4,b,p,will,generate,matches,c,a1,b,c,a1,a2,b,c,a1,a2,a3,b,p,by,default,a,relaxed,continuity,is,applied,return,pattern,with,continuity,changed,to,strict;public,pattern,t,f,consecutive,quantifier,consecutive,return,this
Pattern -> public Pattern<T, F> consecutive();1493906327;Works in conjunction with {@link Pattern#oneOrMore()} or {@link Pattern#times(int)}._Specifies that any not matching element breaks the loop.__<p>E.g. a pattern like:_<pre>{@code_Pattern.<Event>begin("start").where(new SimpleCondition<Event>() {_@Override_public boolean filter(Event value) throws Exception {_return value.getName().equals("c")____.followedBy("middle").where(new SimpleCondition<Event>() {_@Override_public boolean filter(Event value) throws Exception {_return value.getName().equals("a")___}).oneOrMore().consecutive()_.followedBy("end1").where(new SimpleCondition<Event>() {_@Override_public boolean filter(Event value) throws Exception {_return value.getName().equals("b")___})__}</pre>__<p>for a sequence: C D A1 A2 A3 D A4 B__<p>will generate matches: {C A1 B}, {C A1 A2 B}, {C A1 A2 A3 B}__<p>By default a relaxed continuity is applied.__@return pattern with continuity changed to strict;public Pattern<T, F> consecutive() {_		quantifier.consecutive()__		return this__	};works,in,conjunction,with,link,pattern,one,or,more,or,link,pattern,times,int,specifies,that,any,not,matching,element,breaks,the,loop,p,e,g,a,pattern,like,pre,code,pattern,event,begin,start,where,new,simple,condition,event,override,public,boolean,filter,event,value,throws,exception,return,value,get,name,equals,c,followed,by,middle,where,new,simple,condition,event,override,public,boolean,filter,event,value,throws,exception,return,value,get,name,equals,a,one,or,more,consecutive,followed,by,end1,where,new,simple,condition,event,override,public,boolean,filter,event,value,throws,exception,return,value,get,name,equals,b,pre,p,for,a,sequence,c,d,a1,a2,a3,d,a4,b,p,will,generate,matches,c,a1,b,c,a1,a2,b,c,a1,a2,a3,b,p,by,default,a,relaxed,continuity,is,applied,return,pattern,with,continuity,changed,to,strict;public,pattern,t,f,consecutive,quantifier,consecutive,return,this
Pattern -> public Pattern<T, F> consecutive();1493985576;Works in conjunction with {@link Pattern#oneOrMore()} or {@link Pattern#times(int)}._Specifies that any not matching element breaks the loop.__<p>E.g. a pattern like:_<pre>{@code_Pattern.<Event>begin("start").where(new SimpleCondition<Event>() {_@Override_public boolean filter(Event value) throws Exception {_return value.getName().equals("c")____.followedBy("middle").where(new SimpleCondition<Event>() {_@Override_public boolean filter(Event value) throws Exception {_return value.getName().equals("a")___}).oneOrMore().consecutive()_.followedBy("end1").where(new SimpleCondition<Event>() {_@Override_public boolean filter(Event value) throws Exception {_return value.getName().equals("b")___})__}</pre>__<p>for a sequence: C D A1 A2 A3 D A4 B__<p>will generate matches: {C A1 B}, {C A1 A2 B}, {C A1 A2 A3 B}__<p>By default a relaxed continuity is applied.__@return pattern with continuity changed to strict;public Pattern<T, F> consecutive() {_		quantifier.consecutive()__		return this__	};works,in,conjunction,with,link,pattern,one,or,more,or,link,pattern,times,int,specifies,that,any,not,matching,element,breaks,the,loop,p,e,g,a,pattern,like,pre,code,pattern,event,begin,start,where,new,simple,condition,event,override,public,boolean,filter,event,value,throws,exception,return,value,get,name,equals,c,followed,by,middle,where,new,simple,condition,event,override,public,boolean,filter,event,value,throws,exception,return,value,get,name,equals,a,one,or,more,consecutive,followed,by,end1,where,new,simple,condition,event,override,public,boolean,filter,event,value,throws,exception,return,value,get,name,equals,b,pre,p,for,a,sequence,c,d,a1,a2,a3,d,a4,b,p,will,generate,matches,c,a1,b,c,a1,a2,b,c,a1,a2,a3,b,p,by,default,a,relaxed,continuity,is,applied,return,pattern,with,continuity,changed,to,strict;public,pattern,t,f,consecutive,quantifier,consecutive,return,this
Pattern -> public Pattern<T, F> consecutive();1493997908;Works in conjunction with {@link Pattern#oneOrMore()} or {@link Pattern#times(int)}._Specifies that any not matching element breaks the loop.__<p>E.g. a pattern like:_<pre>{@code_Pattern.<Event>begin("start").where(new SimpleCondition<Event>() {_@Override_public boolean filter(Event value) throws Exception {_return value.getName().equals("c")____.followedBy("middle").where(new SimpleCondition<Event>() {_@Override_public boolean filter(Event value) throws Exception {_return value.getName().equals("a")___}).oneOrMore().consecutive()_.followedBy("end1").where(new SimpleCondition<Event>() {_@Override_public boolean filter(Event value) throws Exception {_return value.getName().equals("b")___})__}</pre>__<p>for a sequence: C D A1 A2 A3 D A4 B__<p>will generate matches: {C A1 B}, {C A1 A2 B}, {C A1 A2 A3 B}__<p>By default a relaxed continuity is applied.__@return pattern with continuity changed to strict;public Pattern<T, F> consecutive() {_		quantifier.consecutive()__		return this__	};works,in,conjunction,with,link,pattern,one,or,more,or,link,pattern,times,int,specifies,that,any,not,matching,element,breaks,the,loop,p,e,g,a,pattern,like,pre,code,pattern,event,begin,start,where,new,simple,condition,event,override,public,boolean,filter,event,value,throws,exception,return,value,get,name,equals,c,followed,by,middle,where,new,simple,condition,event,override,public,boolean,filter,event,value,throws,exception,return,value,get,name,equals,a,one,or,more,consecutive,followed,by,end1,where,new,simple,condition,event,override,public,boolean,filter,event,value,throws,exception,return,value,get,name,equals,b,pre,p,for,a,sequence,c,d,a1,a2,a3,d,a4,b,p,will,generate,matches,c,a1,b,c,a1,a2,b,c,a1,a2,a3,b,p,by,default,a,relaxed,continuity,is,applied,return,pattern,with,continuity,changed,to,strict;public,pattern,t,f,consecutive,quantifier,consecutive,return,this
Pattern -> public Pattern<T, F> consecutive();1495961498;Works in conjunction with {@link Pattern#oneOrMore()} or {@link Pattern#times(int)}._Specifies that any not matching element breaks the loop.__<p>E.g. a pattern like:_<pre>{@code_Pattern.<Event>begin("start").where(new SimpleCondition<Event>() {_@Override_public boolean filter(Event value) throws Exception {_return value.getName().equals("c")____.followedBy("middle").where(new SimpleCondition<Event>() {_@Override_public boolean filter(Event value) throws Exception {_return value.getName().equals("a")___}).oneOrMore().consecutive()_.followedBy("end1").where(new SimpleCondition<Event>() {_@Override_public boolean filter(Event value) throws Exception {_return value.getName().equals("b")___})__}</pre>__<p>for a sequence: C D A1 A2 A3 D A4 B__<p>will generate matches: {C A1 B}, {C A1 A2 B}, {C A1 A2 A3 B}__<p>By default a relaxed continuity is applied.__@return pattern with continuity changed to strict;public Pattern<T, F> consecutive() {_		quantifier.consecutive()__		return this__	};works,in,conjunction,with,link,pattern,one,or,more,or,link,pattern,times,int,specifies,that,any,not,matching,element,breaks,the,loop,p,e,g,a,pattern,like,pre,code,pattern,event,begin,start,where,new,simple,condition,event,override,public,boolean,filter,event,value,throws,exception,return,value,get,name,equals,c,followed,by,middle,where,new,simple,condition,event,override,public,boolean,filter,event,value,throws,exception,return,value,get,name,equals,a,one,or,more,consecutive,followed,by,end1,where,new,simple,condition,event,override,public,boolean,filter,event,value,throws,exception,return,value,get,name,equals,b,pre,p,for,a,sequence,c,d,a1,a2,a3,d,a4,b,p,will,generate,matches,c,a1,b,c,a1,a2,b,c,a1,a2,a3,b,p,by,default,a,relaxed,continuity,is,applied,return,pattern,with,continuity,changed,to,strict;public,pattern,t,f,consecutive,quantifier,consecutive,return,this
Pattern -> public Pattern<T, F> consecutive();1497940477;Works in conjunction with {@link Pattern#oneOrMore()} or {@link Pattern#times(int)}._Specifies that any not matching element breaks the loop.__<p>E.g. a pattern like:_<pre>{@code_Pattern.<Event>begin("start").where(new SimpleCondition<Event>() {_@Override_public boolean filter(Event value) throws Exception {_return value.getName().equals("c")____.followedBy("middle").where(new SimpleCondition<Event>() {_@Override_public boolean filter(Event value) throws Exception {_return value.getName().equals("a")___}).oneOrMore().consecutive()_.followedBy("end1").where(new SimpleCondition<Event>() {_@Override_public boolean filter(Event value) throws Exception {_return value.getName().equals("b")___})__}</pre>__<p>for a sequence: C D A1 A2 A3 D A4 B__<p>will generate matches: {C A1 B}, {C A1 A2 B}, {C A1 A2 A3 B}__<p>By default a relaxed continuity is applied.__@return pattern with continuity changed to strict;public Pattern<T, F> consecutive() {_		quantifier.consecutive()__		return this__	};works,in,conjunction,with,link,pattern,one,or,more,or,link,pattern,times,int,specifies,that,any,not,matching,element,breaks,the,loop,p,e,g,a,pattern,like,pre,code,pattern,event,begin,start,where,new,simple,condition,event,override,public,boolean,filter,event,value,throws,exception,return,value,get,name,equals,c,followed,by,middle,where,new,simple,condition,event,override,public,boolean,filter,event,value,throws,exception,return,value,get,name,equals,a,one,or,more,consecutive,followed,by,end1,where,new,simple,condition,event,override,public,boolean,filter,event,value,throws,exception,return,value,get,name,equals,b,pre,p,for,a,sequence,c,d,a1,a2,a3,d,a4,b,p,will,generate,matches,c,a1,b,c,a1,a2,b,c,a1,a2,a3,b,p,by,default,a,relaxed,continuity,is,applied,return,pattern,with,continuity,changed,to,strict;public,pattern,t,f,consecutive,quantifier,consecutive,return,this
Pattern -> public Pattern<T, F> consecutive();1498548074;Works in conjunction with {@link Pattern#oneOrMore()} or {@link Pattern#times(int)}._Specifies that any not matching element breaks the loop.__<p>E.g. a pattern like:_<pre>{@code_Pattern.<Event>begin("start").where(new SimpleCondition<Event>() {_@Override_public boolean filter(Event value) throws Exception {_return value.getName().equals("c")____.followedBy("middle").where(new SimpleCondition<Event>() {_@Override_public boolean filter(Event value) throws Exception {_return value.getName().equals("a")___}).oneOrMore().consecutive()_.followedBy("end1").where(new SimpleCondition<Event>() {_@Override_public boolean filter(Event value) throws Exception {_return value.getName().equals("b")___})__}</pre>__<p>for a sequence: C D A1 A2 A3 D A4 B__<p>will generate matches: {C A1 B}, {C A1 A2 B}, {C A1 A2 A3 B}__<p>By default a relaxed continuity is applied.__@return pattern with continuity changed to strict;public Pattern<T, F> consecutive() {_		quantifier.consecutive()__		return this__	};works,in,conjunction,with,link,pattern,one,or,more,or,link,pattern,times,int,specifies,that,any,not,matching,element,breaks,the,loop,p,e,g,a,pattern,like,pre,code,pattern,event,begin,start,where,new,simple,condition,event,override,public,boolean,filter,event,value,throws,exception,return,value,get,name,equals,c,followed,by,middle,where,new,simple,condition,event,override,public,boolean,filter,event,value,throws,exception,return,value,get,name,equals,a,one,or,more,consecutive,followed,by,end1,where,new,simple,condition,event,override,public,boolean,filter,event,value,throws,exception,return,value,get,name,equals,b,pre,p,for,a,sequence,c,d,a1,a2,a3,d,a4,b,p,will,generate,matches,c,a1,b,c,a1,a2,b,c,a1,a2,a3,b,p,by,default,a,relaxed,continuity,is,applied,return,pattern,with,continuity,changed,to,strict;public,pattern,t,f,consecutive,quantifier,consecutive,return,this
Pattern -> public Pattern<T, F> consecutive();1499244360;Works in conjunction with {@link Pattern#oneOrMore()} or {@link Pattern#times(int)}._Specifies that any not matching element breaks the loop.__<p>E.g. a pattern like:_<pre>{@code_Pattern.<Event>begin("start").where(new SimpleCondition<Event>() {_@Override_public boolean filter(Event value) throws Exception {_return value.getName().equals("c")____.followedBy("middle").where(new SimpleCondition<Event>() {_@Override_public boolean filter(Event value) throws Exception {_return value.getName().equals("a")___}).oneOrMore().consecutive()_.followedBy("end1").where(new SimpleCondition<Event>() {_@Override_public boolean filter(Event value) throws Exception {_return value.getName().equals("b")___})__}</pre>__<p>for a sequence: C D A1 A2 A3 D A4 B__<p>will generate matches: {C A1 B}, {C A1 A2 B}, {C A1 A2 A3 B}__<p>By default a relaxed continuity is applied.__@return pattern with continuity changed to strict;public Pattern<T, F> consecutive() {_		quantifier.consecutive()__		return this__	};works,in,conjunction,with,link,pattern,one,or,more,or,link,pattern,times,int,specifies,that,any,not,matching,element,breaks,the,loop,p,e,g,a,pattern,like,pre,code,pattern,event,begin,start,where,new,simple,condition,event,override,public,boolean,filter,event,value,throws,exception,return,value,get,name,equals,c,followed,by,middle,where,new,simple,condition,event,override,public,boolean,filter,event,value,throws,exception,return,value,get,name,equals,a,one,or,more,consecutive,followed,by,end1,where,new,simple,condition,event,override,public,boolean,filter,event,value,throws,exception,return,value,get,name,equals,b,pre,p,for,a,sequence,c,d,a1,a2,a3,d,a4,b,p,will,generate,matches,c,a1,b,c,a1,a2,b,c,a1,a2,a3,b,p,by,default,a,relaxed,continuity,is,applied,return,pattern,with,continuity,changed,to,strict;public,pattern,t,f,consecutive,quantifier,consecutive,return,this
Pattern -> public Pattern<T, F> consecutive();1499248439;Works in conjunction with {@link Pattern#oneOrMore()} or {@link Pattern#times(int)}._Specifies that any not matching element breaks the loop.__<p>E.g. a pattern like:_<pre>{@code_Pattern.<Event>begin("start").where(new SimpleCondition<Event>() {_@Override_public boolean filter(Event value) throws Exception {_return value.getName().equals("c")____.followedBy("middle").where(new SimpleCondition<Event>() {_@Override_public boolean filter(Event value) throws Exception {_return value.getName().equals("a")___}).oneOrMore().consecutive()_.followedBy("end1").where(new SimpleCondition<Event>() {_@Override_public boolean filter(Event value) throws Exception {_return value.getName().equals("b")___})__}</pre>__<p>for a sequence: C D A1 A2 A3 D A4 B__<p>will generate matches: {C A1 B}, {C A1 A2 B}, {C A1 A2 A3 B}__<p>By default a relaxed continuity is applied.__@return pattern with continuity changed to strict;public Pattern<T, F> consecutive() {_		quantifier.consecutive()__		return this__	};works,in,conjunction,with,link,pattern,one,or,more,or,link,pattern,times,int,specifies,that,any,not,matching,element,breaks,the,loop,p,e,g,a,pattern,like,pre,code,pattern,event,begin,start,where,new,simple,condition,event,override,public,boolean,filter,event,value,throws,exception,return,value,get,name,equals,c,followed,by,middle,where,new,simple,condition,event,override,public,boolean,filter,event,value,throws,exception,return,value,get,name,equals,a,one,or,more,consecutive,followed,by,end1,where,new,simple,condition,event,override,public,boolean,filter,event,value,throws,exception,return,value,get,name,equals,b,pre,p,for,a,sequence,c,d,a1,a2,a3,d,a4,b,p,will,generate,matches,c,a1,b,c,a1,a2,b,c,a1,a2,a3,b,p,by,default,a,relaxed,continuity,is,applied,return,pattern,with,continuity,changed,to,strict;public,pattern,t,f,consecutive,quantifier,consecutive,return,this
Pattern -> public Pattern<T, F> consecutive();1503420807;Works in conjunction with {@link Pattern#oneOrMore()} or {@link Pattern#times(int)}._Specifies that any not matching element breaks the loop.__<p>E.g. a pattern like:_<pre>{@code_Pattern.<Event>begin("start").where(new SimpleCondition<Event>() {_@Override_public boolean filter(Event value) throws Exception {_return value.getName().equals("c")____.followedBy("middle").where(new SimpleCondition<Event>() {_@Override_public boolean filter(Event value) throws Exception {_return value.getName().equals("a")___}).oneOrMore().consecutive()_.followedBy("end1").where(new SimpleCondition<Event>() {_@Override_public boolean filter(Event value) throws Exception {_return value.getName().equals("b")___})__}</pre>__<p>for a sequence: C D A1 A2 A3 D A4 B__<p>will generate matches: {C A1 B}, {C A1 A2 B}, {C A1 A2 A3 B}__<p>By default a relaxed continuity is applied.__@return pattern with continuity changed to strict;public Pattern<T, F> consecutive() {_		quantifier.consecutive()__		return this__	};works,in,conjunction,with,link,pattern,one,or,more,or,link,pattern,times,int,specifies,that,any,not,matching,element,breaks,the,loop,p,e,g,a,pattern,like,pre,code,pattern,event,begin,start,where,new,simple,condition,event,override,public,boolean,filter,event,value,throws,exception,return,value,get,name,equals,c,followed,by,middle,where,new,simple,condition,event,override,public,boolean,filter,event,value,throws,exception,return,value,get,name,equals,a,one,or,more,consecutive,followed,by,end1,where,new,simple,condition,event,override,public,boolean,filter,event,value,throws,exception,return,value,get,name,equals,b,pre,p,for,a,sequence,c,d,a1,a2,a3,d,a4,b,p,will,generate,matches,c,a1,b,c,a1,a2,b,c,a1,a2,a3,b,p,by,default,a,relaxed,continuity,is,applied,return,pattern,with,continuity,changed,to,strict;public,pattern,t,f,consecutive,quantifier,consecutive,return,this
Pattern -> public Pattern<T, F> consecutive();1503558242;Works in conjunction with {@link Pattern#oneOrMore()} or {@link Pattern#times(int)}._Specifies that any not matching element breaks the loop.__<p>E.g. a pattern like:_<pre>{@code_Pattern.<Event>begin("start").where(new SimpleCondition<Event>() {_@Override_public boolean filter(Event value) throws Exception {_return value.getName().equals("c")____.followedBy("middle").where(new SimpleCondition<Event>() {_@Override_public boolean filter(Event value) throws Exception {_return value.getName().equals("a")___}).oneOrMore().consecutive()_.followedBy("end1").where(new SimpleCondition<Event>() {_@Override_public boolean filter(Event value) throws Exception {_return value.getName().equals("b")___})__}</pre>__<p>for a sequence: C D A1 A2 A3 D A4 B__<p>will generate matches: {C A1 B}, {C A1 A2 B}, {C A1 A2 A3 B}__<p>By default a relaxed continuity is applied.__@return pattern with continuity changed to strict;public Pattern<T, F> consecutive() {_		quantifier.consecutive()__		return this__	};works,in,conjunction,with,link,pattern,one,or,more,or,link,pattern,times,int,specifies,that,any,not,matching,element,breaks,the,loop,p,e,g,a,pattern,like,pre,code,pattern,event,begin,start,where,new,simple,condition,event,override,public,boolean,filter,event,value,throws,exception,return,value,get,name,equals,c,followed,by,middle,where,new,simple,condition,event,override,public,boolean,filter,event,value,throws,exception,return,value,get,name,equals,a,one,or,more,consecutive,followed,by,end1,where,new,simple,condition,event,override,public,boolean,filter,event,value,throws,exception,return,value,get,name,equals,b,pre,p,for,a,sequence,c,d,a1,a2,a3,d,a4,b,p,will,generate,matches,c,a1,b,c,a1,a2,b,c,a1,a2,a3,b,p,by,default,a,relaxed,continuity,is,applied,return,pattern,with,continuity,changed,to,strict;public,pattern,t,f,consecutive,quantifier,consecutive,return,this
Pattern -> public Pattern<T, F> consecutive();1504268438;Works in conjunction with {@link Pattern#oneOrMore()} or {@link Pattern#times(int)}._Specifies that any not matching element breaks the loop.__<p>E.g. a pattern like:_<pre>{@code_Pattern.<Event>begin("start").where(new SimpleCondition<Event>() {_@Override_public boolean filter(Event value) throws Exception {_return value.getName().equals("c")____.followedBy("middle").where(new SimpleCondition<Event>() {_@Override_public boolean filter(Event value) throws Exception {_return value.getName().equals("a")___}).oneOrMore().consecutive()_.followedBy("end1").where(new SimpleCondition<Event>() {_@Override_public boolean filter(Event value) throws Exception {_return value.getName().equals("b")___})__}</pre>__<p>for a sequence: C D A1 A2 A3 D A4 B__<p>will generate matches: {C A1 B}, {C A1 A2 B}, {C A1 A2 A3 B}__<p>By default a relaxed continuity is applied.__@return pattern with continuity changed to strict;public Pattern<T, F> consecutive() {_		quantifier.consecutive()__		return this__	};works,in,conjunction,with,link,pattern,one,or,more,or,link,pattern,times,int,specifies,that,any,not,matching,element,breaks,the,loop,p,e,g,a,pattern,like,pre,code,pattern,event,begin,start,where,new,simple,condition,event,override,public,boolean,filter,event,value,throws,exception,return,value,get,name,equals,c,followed,by,middle,where,new,simple,condition,event,override,public,boolean,filter,event,value,throws,exception,return,value,get,name,equals,a,one,or,more,consecutive,followed,by,end1,where,new,simple,condition,event,override,public,boolean,filter,event,value,throws,exception,return,value,get,name,equals,b,pre,p,for,a,sequence,c,d,a1,a2,a3,d,a4,b,p,will,generate,matches,c,a1,b,c,a1,a2,b,c,a1,a2,a3,b,p,by,default,a,relaxed,continuity,is,applied,return,pattern,with,continuity,changed,to,strict;public,pattern,t,f,consecutive,quantifier,consecutive,return,this
Pattern -> public Pattern<T, F> consecutive();1530798894;Works in conjunction with {@link Pattern#oneOrMore()} or {@link Pattern#times(int)}._Specifies that any not matching element breaks the loop.__<p>E.g. a pattern like:_<pre>{@code_Pattern.<Event>begin("start").where(new SimpleCondition<Event>() {_@Override_public boolean filter(Event value) throws Exception {_return value.getName().equals("c")____.followedBy("middle").where(new SimpleCondition<Event>() {_@Override_public boolean filter(Event value) throws Exception {_return value.getName().equals("a")___}).oneOrMore().consecutive()_.followedBy("end1").where(new SimpleCondition<Event>() {_@Override_public boolean filter(Event value) throws Exception {_return value.getName().equals("b")___})__}</pre>__<p>for a sequence: C D A1 A2 A3 D A4 B__<p>will generate matches: {C A1 B}, {C A1 A2 B}, {C A1 A2 A3 B}__<p>By default a relaxed continuity is applied.__@return pattern with continuity changed to strict;public Pattern<T, F> consecutive() {_		quantifier.consecutive()__		return this__	};works,in,conjunction,with,link,pattern,one,or,more,or,link,pattern,times,int,specifies,that,any,not,matching,element,breaks,the,loop,p,e,g,a,pattern,like,pre,code,pattern,event,begin,start,where,new,simple,condition,event,override,public,boolean,filter,event,value,throws,exception,return,value,get,name,equals,c,followed,by,middle,where,new,simple,condition,event,override,public,boolean,filter,event,value,throws,exception,return,value,get,name,equals,a,one,or,more,consecutive,followed,by,end1,where,new,simple,condition,event,override,public,boolean,filter,event,value,throws,exception,return,value,get,name,equals,b,pre,p,for,a,sequence,c,d,a1,a2,a3,d,a4,b,p,will,generate,matches,c,a1,b,c,a1,a2,b,c,a1,a2,a3,b,p,by,default,a,relaxed,continuity,is,applied,return,pattern,with,continuity,changed,to,strict;public,pattern,t,f,consecutive,quantifier,consecutive,return,this
Pattern -> public Pattern<T, F> consecutive();1540208358;Works in conjunction with {@link Pattern#oneOrMore()} or {@link Pattern#times(int)}._Specifies that any not matching element breaks the loop.__<p>E.g. a pattern like:_<pre>{@code_Pattern.<Event>begin("start").where(new SimpleCondition<Event>() {_@Override_public boolean filter(Event value) throws Exception {_return value.getName().equals("c")____.followedBy("middle").where(new SimpleCondition<Event>() {_@Override_public boolean filter(Event value) throws Exception {_return value.getName().equals("a")___}).oneOrMore().consecutive()_.followedBy("end1").where(new SimpleCondition<Event>() {_@Override_public boolean filter(Event value) throws Exception {_return value.getName().equals("b")___})__}</pre>__<p>for a sequence: C D A1 A2 A3 D A4 B__<p>will generate matches: {C A1 B}, {C A1 A2 B}, {C A1 A2 A3 B}__<p>By default a relaxed continuity is applied.__@return pattern with continuity changed to strict;public Pattern<T, F> consecutive() {_		quantifier.consecutive()__		return this__	};works,in,conjunction,with,link,pattern,one,or,more,or,link,pattern,times,int,specifies,that,any,not,matching,element,breaks,the,loop,p,e,g,a,pattern,like,pre,code,pattern,event,begin,start,where,new,simple,condition,event,override,public,boolean,filter,event,value,throws,exception,return,value,get,name,equals,c,followed,by,middle,where,new,simple,condition,event,override,public,boolean,filter,event,value,throws,exception,return,value,get,name,equals,a,one,or,more,consecutive,followed,by,end1,where,new,simple,condition,event,override,public,boolean,filter,event,value,throws,exception,return,value,get,name,equals,b,pre,p,for,a,sequence,c,d,a1,a2,a3,d,a4,b,p,will,generate,matches,c,a1,b,c,a1,a2,b,c,a1,a2,a3,b,p,by,default,a,relaxed,continuity,is,applied,return,pattern,with,continuity,changed,to,strict;public,pattern,t,f,consecutive,quantifier,consecutive,return,this
Pattern -> public Pattern<T, F> consecutive();1543413704;Works in conjunction with {@link Pattern#oneOrMore()} or {@link Pattern#times(int)}._Specifies that any not matching element breaks the loop.__<p>E.g. a pattern like:_<pre>{@code_Pattern.<Event>begin("start").where(new SimpleCondition<Event>() {_@Override_public boolean filter(Event value) throws Exception {_return value.getName().equals("c")____.followedBy("middle").where(new SimpleCondition<Event>() {_@Override_public boolean filter(Event value) throws Exception {_return value.getName().equals("a")___}).oneOrMore().consecutive()_.followedBy("end1").where(new SimpleCondition<Event>() {_@Override_public boolean filter(Event value) throws Exception {_return value.getName().equals("b")___})__}</pre>__<p>for a sequence: C D A1 A2 A3 D A4 B__<p>will generate matches: {C A1 B}, {C A1 A2 B}, {C A1 A2 A3 B}__<p>By default a relaxed continuity is applied.__@return pattern with continuity changed to strict;public Pattern<T, F> consecutive() {_		quantifier.consecutive()__		return this__	};works,in,conjunction,with,link,pattern,one,or,more,or,link,pattern,times,int,specifies,that,any,not,matching,element,breaks,the,loop,p,e,g,a,pattern,like,pre,code,pattern,event,begin,start,where,new,simple,condition,event,override,public,boolean,filter,event,value,throws,exception,return,value,get,name,equals,c,followed,by,middle,where,new,simple,condition,event,override,public,boolean,filter,event,value,throws,exception,return,value,get,name,equals,a,one,or,more,consecutive,followed,by,end1,where,new,simple,condition,event,override,public,boolean,filter,event,value,throws,exception,return,value,get,name,equals,b,pre,p,for,a,sequence,c,d,a1,a2,a3,d,a4,b,p,will,generate,matches,c,a1,b,c,a1,a2,b,c,a1,a2,a3,b,p,by,default,a,relaxed,continuity,is,applied,return,pattern,with,continuity,changed,to,strict;public,pattern,t,f,consecutive,quantifier,consecutive,return,this
Pattern -> public static <X> Pattern<X, X> begin(final String name);1454421848;Starts a new pattern with the initial pattern operator whose name is provided. Furthermore,_the base type of the event sequence is set.__@param name Name of the new pattern operator_@param <X> Base type of the event pattern_@return The first pattern operator of a pattern;public static <X> Pattern<X, X> begin(final String name) {_		return new Pattern<X, X>(name, null)__	};starts,a,new,pattern,with,the,initial,pattern,operator,whose,name,is,provided,furthermore,the,base,type,of,the,event,sequence,is,set,param,name,name,of,the,new,pattern,operator,param,x,base,type,of,the,event,pattern,return,the,first,pattern,operator,of,a,pattern;public,static,x,pattern,x,x,begin,final,string,name,return,new,pattern,x,x,name,null
Pattern -> public static <X> Pattern<X, X> begin(final String name);1456442894;Starts a new pattern with the initial pattern operator whose name is provided. Furthermore,_the base type of the event sequence is set.__@param name Name of the new pattern operator_@param <X> Base type of the event pattern_@return The first pattern operator of a pattern;public static <X> Pattern<X, X> begin(final String name) {_		return new Pattern<X, X>(name, null)__	};starts,a,new,pattern,with,the,initial,pattern,operator,whose,name,is,provided,furthermore,the,base,type,of,the,event,sequence,is,set,param,name,name,of,the,new,pattern,operator,param,x,base,type,of,the,event,pattern,return,the,first,pattern,operator,of,a,pattern;public,static,x,pattern,x,x,begin,final,string,name,return,new,pattern,x,x,name,null
Pattern -> public static <X> Pattern<X, X> begin(final String name);1461689259;Starts a new pattern with the initial pattern operator whose name is provided. Furthermore,_the base type of the event sequence is set.__@param name Name of the new pattern operator_@param <X> Base type of the event pattern_@return The first pattern operator of a pattern;public static <X> Pattern<X, X> begin(final String name) {_		return new Pattern<X, X>(name, null)__	};starts,a,new,pattern,with,the,initial,pattern,operator,whose,name,is,provided,furthermore,the,base,type,of,the,event,sequence,is,set,param,name,name,of,the,new,pattern,operator,param,x,base,type,of,the,event,pattern,return,the,first,pattern,operator,of,a,pattern;public,static,x,pattern,x,x,begin,final,string,name,return,new,pattern,x,x,name,null
Pattern -> public static <X> Pattern<X, X> begin(final String name);1471613162;Starts a new pattern with the initial pattern operator whose name is provided. Furthermore,_the base type of the event sequence is set.__@param name Name of the new pattern operator_@param <X> Base type of the event pattern_@return The first pattern operator of a pattern;public static <X> Pattern<X, X> begin(final String name) {_		return new Pattern<X, X>(name, null)__	};starts,a,new,pattern,with,the,initial,pattern,operator,whose,name,is,provided,furthermore,the,base,type,of,the,event,sequence,is,set,param,name,name,of,the,new,pattern,operator,param,x,base,type,of,the,event,pattern,return,the,first,pattern,operator,of,a,pattern;public,static,x,pattern,x,x,begin,final,string,name,return,new,pattern,x,x,name,null
Pattern -> public static <X> Pattern<X, X> begin(final String name);1471614454;Starts a new pattern with the initial pattern operator whose name is provided. Furthermore,_the base type of the event sequence is set.__@param name Name of the new pattern operator_@param <X> Base type of the event pattern_@return The first pattern operator of a pattern;public static <X> Pattern<X, X> begin(final String name) {_		return new Pattern<X, X>(name, null)__	};starts,a,new,pattern,with,the,initial,pattern,operator,whose,name,is,provided,furthermore,the,base,type,of,the,event,sequence,is,set,param,name,name,of,the,new,pattern,operator,param,x,base,type,of,the,event,pattern,return,the,first,pattern,operator,of,a,pattern;public,static,x,pattern,x,x,begin,final,string,name,return,new,pattern,x,x,name,null
Pattern -> public static <X> Pattern<X, X> begin(final String name);1488270949;Starts a new pattern with the initial pattern operator whose name is provided. Furthermore,_the base type of the event sequence is set.__@param name Name of the new pattern operator_@param <X> Base type of the event pattern_@return The first pattern operator of a pattern;public static <X> Pattern<X, X> begin(final String name) {_		return new Pattern<X, X>(name, null)__	};starts,a,new,pattern,with,the,initial,pattern,operator,whose,name,is,provided,furthermore,the,base,type,of,the,event,sequence,is,set,param,name,name,of,the,new,pattern,operator,param,x,base,type,of,the,event,pattern,return,the,first,pattern,operator,of,a,pattern;public,static,x,pattern,x,x,begin,final,string,name,return,new,pattern,x,x,name,null
Pattern -> public static <X> Pattern<X, X> begin(final String name);1490262475;Starts a new pattern with the initial pattern operator whose name is provided. Furthermore,_the base type of the event sequence is set.__@param name Name of the new pattern operator_@param <X> Base type of the event pattern_@return The first pattern operator of a pattern;public static <X> Pattern<X, X> begin(final String name) {_		return new Pattern<X, X>(name, null)__	};starts,a,new,pattern,with,the,initial,pattern,operator,whose,name,is,provided,furthermore,the,base,type,of,the,event,sequence,is,set,param,name,name,of,the,new,pattern,operator,param,x,base,type,of,the,event,pattern,return,the,first,pattern,operator,of,a,pattern;public,static,x,pattern,x,x,begin,final,string,name,return,new,pattern,x,x,name,null
Pattern -> public static <X> Pattern<X, X> begin(final String name);1490638274;Starts a new pattern with the initial pattern operator whose name is provided. Furthermore,_the base type of the event sequence is set.__@param name Name of the new pattern operator_@param <X> Base type of the event pattern_@return The first pattern operator of a pattern;public static <X> Pattern<X, X> begin(final String name) {_		return new Pattern<X, X>(name, null)__	};starts,a,new,pattern,with,the,initial,pattern,operator,whose,name,is,provided,furthermore,the,base,type,of,the,event,sequence,is,set,param,name,name,of,the,new,pattern,operator,param,x,base,type,of,the,event,pattern,return,the,first,pattern,operator,of,a,pattern;public,static,x,pattern,x,x,begin,final,string,name,return,new,pattern,x,x,name,null
Pattern -> public static <X> Pattern<X, X> begin(final String name);1490862259;Starts a new pattern with the initial pattern operator whose name is provided. Furthermore,_the base type of the event sequence is set.__@param name Name of the new pattern operator_@param <X> Base type of the event pattern_@return The first pattern operator of a pattern;public static <X> Pattern<X, X> begin(final String name) {_		return new Pattern<X, X>(name, null)__	};starts,a,new,pattern,with,the,initial,pattern,operator,whose,name,is,provided,furthermore,the,base,type,of,the,event,sequence,is,set,param,name,name,of,the,new,pattern,operator,param,x,base,type,of,the,event,pattern,return,the,first,pattern,operator,of,a,pattern;public,static,x,pattern,x,x,begin,final,string,name,return,new,pattern,x,x,name,null
Pattern -> public static <X> Pattern<X, X> begin(final String name);1491647251;Starts a new pattern with the initial pattern operator whose name is provided. Furthermore,_the base type of the event sequence is set.__@param name Name of the new pattern operator_@param <X> Base type of the event pattern_@return The first pattern operator of a pattern;public static <X> Pattern<X, X> begin(final String name) {_		return new Pattern<X, X>(name, null)__	};starts,a,new,pattern,with,the,initial,pattern,operator,whose,name,is,provided,furthermore,the,base,type,of,the,event,sequence,is,set,param,name,name,of,the,new,pattern,operator,param,x,base,type,of,the,event,pattern,return,the,first,pattern,operator,of,a,pattern;public,static,x,pattern,x,x,begin,final,string,name,return,new,pattern,x,x,name,null
Pattern -> public static <X> Pattern<X, X> begin(final String name);1493201751;Starts a new pattern sequence. The provided name is the one of the initial pattern_of the new sequence. Furthermore, the base type of the event sequence is set.__@param name The name of starting pattern of the new pattern sequence_@param <X> Base type of the event pattern_@return The first pattern of a pattern sequence;public static <X> Pattern<X, X> begin(final String name) {_		return new Pattern<X, X>(name, null)__	};starts,a,new,pattern,sequence,the,provided,name,is,the,one,of,the,initial,pattern,of,the,new,sequence,furthermore,the,base,type,of,the,event,sequence,is,set,param,name,the,name,of,starting,pattern,of,the,new,pattern,sequence,param,x,base,type,of,the,event,pattern,return,the,first,pattern,of,a,pattern,sequence;public,static,x,pattern,x,x,begin,final,string,name,return,new,pattern,x,x,name,null
Pattern -> public static <X> Pattern<X, X> begin(final String name);1493201753;Starts a new pattern sequence. The provided name is the one of the initial pattern_of the new sequence. Furthermore, the base type of the event sequence is set.__@param name The name of starting pattern of the new pattern sequence_@param <X> Base type of the event pattern_@return The first pattern of a pattern sequence;public static <X> Pattern<X, X> begin(final String name) {_		return new Pattern<X, X>(name, null)__	};starts,a,new,pattern,sequence,the,provided,name,is,the,one,of,the,initial,pattern,of,the,new,sequence,furthermore,the,base,type,of,the,event,sequence,is,set,param,name,the,name,of,starting,pattern,of,the,new,pattern,sequence,param,x,base,type,of,the,event,pattern,return,the,first,pattern,of,a,pattern,sequence;public,static,x,pattern,x,x,begin,final,string,name,return,new,pattern,x,x,name,null
Pattern -> public static <X> Pattern<X, X> begin(final String name);1493382517;Starts a new pattern sequence. The provided name is the one of the initial pattern_of the new sequence. Furthermore, the base type of the event sequence is set.__@param name The name of starting pattern of the new pattern sequence_@param <X> Base type of the event pattern_@return The first pattern of a pattern sequence;public static <X> Pattern<X, X> begin(final String name) {_		return new Pattern<X, X>(name, null)__	};starts,a,new,pattern,sequence,the,provided,name,is,the,one,of,the,initial,pattern,of,the,new,sequence,furthermore,the,base,type,of,the,event,sequence,is,set,param,name,the,name,of,starting,pattern,of,the,new,pattern,sequence,param,x,base,type,of,the,event,pattern,return,the,first,pattern,of,a,pattern,sequence;public,static,x,pattern,x,x,begin,final,string,name,return,new,pattern,x,x,name,null
Pattern -> public static <X> Pattern<X, X> begin(final String name);1493906327;Starts a new pattern sequence. The provided name is the one of the initial pattern_of the new sequence. Furthermore, the base type of the event sequence is set.__@param name The name of starting pattern of the new pattern sequence_@param <X> Base type of the event pattern_@return The first pattern of a pattern sequence;public static <X> Pattern<X, X> begin(final String name) {_		return new Pattern<X, X>(name, null)__	};starts,a,new,pattern,sequence,the,provided,name,is,the,one,of,the,initial,pattern,of,the,new,sequence,furthermore,the,base,type,of,the,event,sequence,is,set,param,name,the,name,of,starting,pattern,of,the,new,pattern,sequence,param,x,base,type,of,the,event,pattern,return,the,first,pattern,of,a,pattern,sequence;public,static,x,pattern,x,x,begin,final,string,name,return,new,pattern,x,x,name,null
Pattern -> public static <X> Pattern<X, X> begin(final String name);1493985576;Starts a new pattern sequence. The provided name is the one of the initial pattern_of the new sequence. Furthermore, the base type of the event sequence is set.__@param name The name of starting pattern of the new pattern sequence_@param <X> Base type of the event pattern_@return The first pattern of a pattern sequence;public static <X> Pattern<X, X> begin(final String name) {_		return new Pattern<X, X>(name, null)__	};starts,a,new,pattern,sequence,the,provided,name,is,the,one,of,the,initial,pattern,of,the,new,sequence,furthermore,the,base,type,of,the,event,sequence,is,set,param,name,the,name,of,starting,pattern,of,the,new,pattern,sequence,param,x,base,type,of,the,event,pattern,return,the,first,pattern,of,a,pattern,sequence;public,static,x,pattern,x,x,begin,final,string,name,return,new,pattern,x,x,name,null
Pattern -> public static <X> Pattern<X, X> begin(final String name);1493997908;Starts a new pattern sequence. The provided name is the one of the initial pattern_of the new sequence. Furthermore, the base type of the event sequence is set.__@param name The name of starting pattern of the new pattern sequence_@param <X> Base type of the event pattern_@return The first pattern of a pattern sequence;public static <X> Pattern<X, X> begin(final String name) {_		return new Pattern<X, X>(name, null)__	};starts,a,new,pattern,sequence,the,provided,name,is,the,one,of,the,initial,pattern,of,the,new,sequence,furthermore,the,base,type,of,the,event,sequence,is,set,param,name,the,name,of,starting,pattern,of,the,new,pattern,sequence,param,x,base,type,of,the,event,pattern,return,the,first,pattern,of,a,pattern,sequence;public,static,x,pattern,x,x,begin,final,string,name,return,new,pattern,x,x,name,null
Pattern -> public static <X> Pattern<X, X> begin(final String name);1495961498;Starts a new pattern sequence. The provided name is the one of the initial pattern_of the new sequence. Furthermore, the base type of the event sequence is set.__@param name The name of starting pattern of the new pattern sequence_@param <X> Base type of the event pattern_@return The first pattern of a pattern sequence;public static <X> Pattern<X, X> begin(final String name) {_		return new Pattern<X, X>(name, null)__	};starts,a,new,pattern,sequence,the,provided,name,is,the,one,of,the,initial,pattern,of,the,new,sequence,furthermore,the,base,type,of,the,event,sequence,is,set,param,name,the,name,of,starting,pattern,of,the,new,pattern,sequence,param,x,base,type,of,the,event,pattern,return,the,first,pattern,of,a,pattern,sequence;public,static,x,pattern,x,x,begin,final,string,name,return,new,pattern,x,x,name,null
Pattern -> public static <X> Pattern<X, X> begin(final String name);1497940477;Starts a new pattern sequence. The provided name is the one of the initial pattern_of the new sequence. Furthermore, the base type of the event sequence is set.__@param name The name of starting pattern of the new pattern sequence_@param <X> Base type of the event pattern_@return The first pattern of a pattern sequence;public static <X> Pattern<X, X> begin(final String name) {_		return new Pattern<X, X>(name, null)__	};starts,a,new,pattern,sequence,the,provided,name,is,the,one,of,the,initial,pattern,of,the,new,sequence,furthermore,the,base,type,of,the,event,sequence,is,set,param,name,the,name,of,starting,pattern,of,the,new,pattern,sequence,param,x,base,type,of,the,event,pattern,return,the,first,pattern,of,a,pattern,sequence;public,static,x,pattern,x,x,begin,final,string,name,return,new,pattern,x,x,name,null
Pattern -> public static <X> Pattern<X, X> begin(final String name);1498548074;Starts a new pattern sequence. The provided name is the one of the initial pattern_of the new sequence. Furthermore, the base type of the event sequence is set.__@param name The name of starting pattern of the new pattern sequence_@param <X> Base type of the event pattern_@return The first pattern of a pattern sequence;public static <X> Pattern<X, X> begin(final String name) {_		return new Pattern<X, X>(name, null)__	};starts,a,new,pattern,sequence,the,provided,name,is,the,one,of,the,initial,pattern,of,the,new,sequence,furthermore,the,base,type,of,the,event,sequence,is,set,param,name,the,name,of,starting,pattern,of,the,new,pattern,sequence,param,x,base,type,of,the,event,pattern,return,the,first,pattern,of,a,pattern,sequence;public,static,x,pattern,x,x,begin,final,string,name,return,new,pattern,x,x,name,null
Pattern -> public static <X> Pattern<X, X> begin(final String name);1499244360;Starts a new pattern sequence. The provided name is the one of the initial pattern_of the new sequence. Furthermore, the base type of the event sequence is set.__@param name The name of starting pattern of the new pattern sequence_@param <X> Base type of the event pattern_@return The first pattern of a pattern sequence;public static <X> Pattern<X, X> begin(final String name) {_		return new Pattern<X, X>(name, null)__	};starts,a,new,pattern,sequence,the,provided,name,is,the,one,of,the,initial,pattern,of,the,new,sequence,furthermore,the,base,type,of,the,event,sequence,is,set,param,name,the,name,of,starting,pattern,of,the,new,pattern,sequence,param,x,base,type,of,the,event,pattern,return,the,first,pattern,of,a,pattern,sequence;public,static,x,pattern,x,x,begin,final,string,name,return,new,pattern,x,x,name,null
Pattern -> public static <X> Pattern<X, X> begin(final String name);1499248439;Starts a new pattern sequence. The provided name is the one of the initial pattern_of the new sequence. Furthermore, the base type of the event sequence is set.__@param name The name of starting pattern of the new pattern sequence_@param <X> Base type of the event pattern_@return The first pattern of a pattern sequence;public static <X> Pattern<X, X> begin(final String name) {_		return new Pattern<X, X>(name, null)__	};starts,a,new,pattern,sequence,the,provided,name,is,the,one,of,the,initial,pattern,of,the,new,sequence,furthermore,the,base,type,of,the,event,sequence,is,set,param,name,the,name,of,starting,pattern,of,the,new,pattern,sequence,param,x,base,type,of,the,event,pattern,return,the,first,pattern,of,a,pattern,sequence;public,static,x,pattern,x,x,begin,final,string,name,return,new,pattern,x,x,name,null
Pattern -> public static <X> Pattern<X, X> begin(final String name);1503420807;Starts a new pattern sequence. The provided name is the one of the initial pattern_of the new sequence. Furthermore, the base type of the event sequence is set.__@param name The name of starting pattern of the new pattern sequence_@param <X> Base type of the event pattern_@return The first pattern of a pattern sequence;public static <X> Pattern<X, X> begin(final String name) {_		return new Pattern<X, X>(name, null)__	};starts,a,new,pattern,sequence,the,provided,name,is,the,one,of,the,initial,pattern,of,the,new,sequence,furthermore,the,base,type,of,the,event,sequence,is,set,param,name,the,name,of,starting,pattern,of,the,new,pattern,sequence,param,x,base,type,of,the,event,pattern,return,the,first,pattern,of,a,pattern,sequence;public,static,x,pattern,x,x,begin,final,string,name,return,new,pattern,x,x,name,null
Pattern -> public static <X> Pattern<X, X> begin(final String name);1503558242;Starts a new pattern sequence. The provided name is the one of the initial pattern_of the new sequence. Furthermore, the base type of the event sequence is set.__@param name The name of starting pattern of the new pattern sequence_@param <X> Base type of the event pattern_@return The first pattern of a pattern sequence;public static <X> Pattern<X, X> begin(final String name) {_		return new Pattern<X, X>(name, null)__	};starts,a,new,pattern,sequence,the,provided,name,is,the,one,of,the,initial,pattern,of,the,new,sequence,furthermore,the,base,type,of,the,event,sequence,is,set,param,name,the,name,of,starting,pattern,of,the,new,pattern,sequence,param,x,base,type,of,the,event,pattern,return,the,first,pattern,of,a,pattern,sequence;public,static,x,pattern,x,x,begin,final,string,name,return,new,pattern,x,x,name,null
Pattern -> public static <X> Pattern<X, X> begin(final String name);1504268438;Starts a new pattern sequence. The provided name is the one of the initial pattern_of the new sequence. Furthermore, the base type of the event sequence is set.__@param name The name of starting pattern of the new pattern sequence_@param <X> Base type of the event pattern_@return The first pattern of a pattern sequence;public static <X> Pattern<X, X> begin(final String name) {_		return new Pattern<>(name, null, ConsumingStrategy.STRICT, AfterMatchSkipStrategy.noSkip())__	};starts,a,new,pattern,sequence,the,provided,name,is,the,one,of,the,initial,pattern,of,the,new,sequence,furthermore,the,base,type,of,the,event,sequence,is,set,param,name,the,name,of,starting,pattern,of,the,new,pattern,sequence,param,x,base,type,of,the,event,pattern,return,the,first,pattern,of,a,pattern,sequence;public,static,x,pattern,x,x,begin,final,string,name,return,new,pattern,name,null,consuming,strategy,strict,after,match,skip,strategy,no,skip
Pattern -> public static <X> Pattern<X, X> begin(final String name);1530798894;Starts a new pattern sequence. The provided name is the one of the initial pattern_of the new sequence. Furthermore, the base type of the event sequence is set.__@param name The name of starting pattern of the new pattern sequence_@param <X> Base type of the event pattern_@return The first pattern of a pattern sequence;public static <X> Pattern<X, X> begin(final String name) {_		return new Pattern<>(name, null, ConsumingStrategy.STRICT, AfterMatchSkipStrategy.noSkip())__	};starts,a,new,pattern,sequence,the,provided,name,is,the,one,of,the,initial,pattern,of,the,new,sequence,furthermore,the,base,type,of,the,event,sequence,is,set,param,name,the,name,of,starting,pattern,of,the,new,pattern,sequence,param,x,base,type,of,the,event,pattern,return,the,first,pattern,of,a,pattern,sequence;public,static,x,pattern,x,x,begin,final,string,name,return,new,pattern,name,null,consuming,strategy,strict,after,match,skip,strategy,no,skip
Pattern -> public static <X> Pattern<X, X> begin(final String name);1540208358;Starts a new pattern sequence. The provided name is the one of the initial pattern_of the new sequence. Furthermore, the base type of the event sequence is set.__@param name The name of starting pattern of the new pattern sequence_@param <X> Base type of the event pattern_@return The first pattern of a pattern sequence;public static <X> Pattern<X, X> begin(final String name) {_		return new Pattern<>(name, null, ConsumingStrategy.STRICT, AfterMatchSkipStrategy.noSkip())__	};starts,a,new,pattern,sequence,the,provided,name,is,the,one,of,the,initial,pattern,of,the,new,sequence,furthermore,the,base,type,of,the,event,sequence,is,set,param,name,the,name,of,starting,pattern,of,the,new,pattern,sequence,param,x,base,type,of,the,event,pattern,return,the,first,pattern,of,a,pattern,sequence;public,static,x,pattern,x,x,begin,final,string,name,return,new,pattern,name,null,consuming,strategy,strict,after,match,skip,strategy,no,skip
Pattern -> public static <X> Pattern<X, X> begin(final String name);1543413704;Starts a new pattern sequence. The provided name is the one of the initial pattern_of the new sequence. Furthermore, the base type of the event sequence is set.__@param name The name of starting pattern of the new pattern sequence_@param <X> Base type of the event pattern_@return The first pattern of a pattern sequence;public static <X> Pattern<X, X> begin(final String name) {_		return new Pattern<>(name, null, ConsumingStrategy.STRICT, AfterMatchSkipStrategy.noSkip())__	};starts,a,new,pattern,sequence,the,provided,name,is,the,one,of,the,initial,pattern,of,the,new,sequence,furthermore,the,base,type,of,the,event,sequence,is,set,param,name,the,name,of,starting,pattern,of,the,new,pattern,sequence,param,x,base,type,of,the,event,pattern,return,the,first,pattern,of,a,pattern,sequence;public,static,x,pattern,x,x,begin,final,string,name,return,new,pattern,name,null,consuming,strategy,strict,after,match,skip,strategy,no,skip
Pattern -> public GroupPattern<T, F> next(Pattern<T, F> group);1499244360;Appends a new group pattern to the existing one. The new pattern enforces strict_temporal contiguity. This means that the whole pattern sequence matches only_if an event which matches this pattern directly follows the preceding matching_event. Thus, there cannot be any events in between two matching events.__@param group the pattern to append_@return A new pattern which is appended to this one;public GroupPattern<T, F> next(Pattern<T, F> group) {_		return new GroupPattern<>(this, group, ConsumingStrategy.STRICT)__	};appends,a,new,group,pattern,to,the,existing,one,the,new,pattern,enforces,strict,temporal,contiguity,this,means,that,the,whole,pattern,sequence,matches,only,if,an,event,which,matches,this,pattern,directly,follows,the,preceding,matching,event,thus,there,cannot,be,any,events,in,between,two,matching,events,param,group,the,pattern,to,append,return,a,new,pattern,which,is,appended,to,this,one;public,group,pattern,t,f,next,pattern,t,f,group,return,new,group,pattern,this,group,consuming,strategy,strict
Pattern -> public GroupPattern<T, F> next(Pattern<T, F> group);1499248439;Appends a new group pattern to the existing one. The new pattern enforces strict_temporal contiguity. This means that the whole pattern sequence matches only_if an event which matches this pattern directly follows the preceding matching_event. Thus, there cannot be any events in between two matching events.__@param group the pattern to append_@return A new pattern which is appended to this one;public GroupPattern<T, F> next(Pattern<T, F> group) {_		return new GroupPattern<>(this, group, ConsumingStrategy.STRICT)__	};appends,a,new,group,pattern,to,the,existing,one,the,new,pattern,enforces,strict,temporal,contiguity,this,means,that,the,whole,pattern,sequence,matches,only,if,an,event,which,matches,this,pattern,directly,follows,the,preceding,matching,event,thus,there,cannot,be,any,events,in,between,two,matching,events,param,group,the,pattern,to,append,return,a,new,pattern,which,is,appended,to,this,one;public,group,pattern,t,f,next,pattern,t,f,group,return,new,group,pattern,this,group,consuming,strategy,strict
Pattern -> public GroupPattern<T, F> next(Pattern<T, F> group);1503420807;Appends a new group pattern to the existing one. The new pattern enforces strict_temporal contiguity. This means that the whole pattern sequence matches only_if an event which matches this pattern directly follows the preceding matching_event. Thus, there cannot be any events in between two matching events.__@param group the pattern to append_@return A new pattern which is appended to this one;public GroupPattern<T, F> next(Pattern<T, F> group) {_		return new GroupPattern<>(this, group, ConsumingStrategy.STRICT)__	};appends,a,new,group,pattern,to,the,existing,one,the,new,pattern,enforces,strict,temporal,contiguity,this,means,that,the,whole,pattern,sequence,matches,only,if,an,event,which,matches,this,pattern,directly,follows,the,preceding,matching,event,thus,there,cannot,be,any,events,in,between,two,matching,events,param,group,the,pattern,to,append,return,a,new,pattern,which,is,appended,to,this,one;public,group,pattern,t,f,next,pattern,t,f,group,return,new,group,pattern,this,group,consuming,strategy,strict
Pattern -> public GroupPattern<T, F> next(Pattern<T, F> group);1503558242;Appends a new group pattern to the existing one. The new pattern enforces strict_temporal contiguity. This means that the whole pattern sequence matches only_if an event which matches this pattern directly follows the preceding matching_event. Thus, there cannot be any events in between two matching events.__@param group the pattern to append_@return A new pattern which is appended to this one;public GroupPattern<T, F> next(Pattern<T, F> group) {_		return new GroupPattern<>(this, group, ConsumingStrategy.STRICT)__	};appends,a,new,group,pattern,to,the,existing,one,the,new,pattern,enforces,strict,temporal,contiguity,this,means,that,the,whole,pattern,sequence,matches,only,if,an,event,which,matches,this,pattern,directly,follows,the,preceding,matching,event,thus,there,cannot,be,any,events,in,between,two,matching,events,param,group,the,pattern,to,append,return,a,new,pattern,which,is,appended,to,this,one;public,group,pattern,t,f,next,pattern,t,f,group,return,new,group,pattern,this,group,consuming,strategy,strict
Pattern -> public GroupPattern<T, F> next(Pattern<T, F> group);1504268438;Appends a new group pattern to the existing one. The new pattern enforces strict_temporal contiguity. This means that the whole pattern sequence matches only_if an event which matches this pattern directly follows the preceding matching_event. Thus, there cannot be any events in between two matching events.__@param group the pattern to append_@return A new pattern which is appended to this one;public GroupPattern<T, F> next(Pattern<T, F> group) {_		return new GroupPattern<>(this, group, ConsumingStrategy.STRICT, afterMatchSkipStrategy)__	};appends,a,new,group,pattern,to,the,existing,one,the,new,pattern,enforces,strict,temporal,contiguity,this,means,that,the,whole,pattern,sequence,matches,only,if,an,event,which,matches,this,pattern,directly,follows,the,preceding,matching,event,thus,there,cannot,be,any,events,in,between,two,matching,events,param,group,the,pattern,to,append,return,a,new,pattern,which,is,appended,to,this,one;public,group,pattern,t,f,next,pattern,t,f,group,return,new,group,pattern,this,group,consuming,strategy,strict,after,match,skip,strategy
Pattern -> public GroupPattern<T, F> next(Pattern<T, F> group);1530798894;Appends a new group pattern to the existing one. The new pattern enforces strict_temporal contiguity. This means that the whole pattern sequence matches only_if an event which matches this pattern directly follows the preceding matching_event. Thus, there cannot be any events in between two matching events.__@param group the pattern to append_@return A new pattern which is appended to this one;public GroupPattern<T, F> next(Pattern<T, F> group) {_		return new GroupPattern<>(this, group, ConsumingStrategy.STRICT, afterMatchSkipStrategy)__	};appends,a,new,group,pattern,to,the,existing,one,the,new,pattern,enforces,strict,temporal,contiguity,this,means,that,the,whole,pattern,sequence,matches,only,if,an,event,which,matches,this,pattern,directly,follows,the,preceding,matching,event,thus,there,cannot,be,any,events,in,between,two,matching,events,param,group,the,pattern,to,append,return,a,new,pattern,which,is,appended,to,this,one;public,group,pattern,t,f,next,pattern,t,f,group,return,new,group,pattern,this,group,consuming,strategy,strict,after,match,skip,strategy
Pattern -> public GroupPattern<T, F> next(Pattern<T, F> group);1540208358;Appends a new group pattern to the existing one. The new pattern enforces strict_temporal contiguity. This means that the whole pattern sequence matches only_if an event which matches this pattern directly follows the preceding matching_event. Thus, there cannot be any events in between two matching events.__@param group the pattern to append_@return A new pattern which is appended to this one;public GroupPattern<T, F> next(Pattern<T, F> group) {_		return new GroupPattern<>(this, group, ConsumingStrategy.STRICT, afterMatchSkipStrategy)__	};appends,a,new,group,pattern,to,the,existing,one,the,new,pattern,enforces,strict,temporal,contiguity,this,means,that,the,whole,pattern,sequence,matches,only,if,an,event,which,matches,this,pattern,directly,follows,the,preceding,matching,event,thus,there,cannot,be,any,events,in,between,two,matching,events,param,group,the,pattern,to,append,return,a,new,pattern,which,is,appended,to,this,one;public,group,pattern,t,f,next,pattern,t,f,group,return,new,group,pattern,this,group,consuming,strategy,strict,after,match,skip,strategy
Pattern -> public GroupPattern<T, F> next(Pattern<T, F> group);1543413704;Appends a new group pattern to the existing one. The new pattern enforces strict_temporal contiguity. This means that the whole pattern sequence matches only_if an event which matches this pattern directly follows the preceding matching_event. Thus, there cannot be any events in between two matching events.__@param group the pattern to append_@return A new pattern which is appended to this one;public GroupPattern<T, F> next(Pattern<T, F> group) {_		return new GroupPattern<>(this, group, ConsumingStrategy.STRICT, afterMatchSkipStrategy)__	};appends,a,new,group,pattern,to,the,existing,one,the,new,pattern,enforces,strict,temporal,contiguity,this,means,that,the,whole,pattern,sequence,matches,only,if,an,event,which,matches,this,pattern,directly,follows,the,preceding,matching,event,thus,there,cannot,be,any,events,in,between,two,matching,events,param,group,the,pattern,to,append,return,a,new,pattern,which,is,appended,to,this,one;public,group,pattern,t,f,next,pattern,t,f,group,return,new,group,pattern,this,group,consuming,strategy,strict,after,match,skip,strategy
Pattern -> public Pattern<T, F> timesOrMore(int times);1503420807;Specifies that this pattern can occur the specified times at least._This means at least the specified times and at most infinite number of events can_be matched to this pattern.__@return The same pattern with a {@link Quantifier#looping(ConsumingStrategy)} quantifier applied._@throws MalformedPatternException if the quantifier is not applicable to this pattern.;public Pattern<T, F> timesOrMore(int times) {_		checkIfNoNotPattern()__		checkIfQuantifierApplied()__		this.quantifier = Quantifier.looping(quantifier.getConsumingStrategy())__		this.times = Times.of(times)__		return this__	};specifies,that,this,pattern,can,occur,the,specified,times,at,least,this,means,at,least,the,specified,times,and,at,most,infinite,number,of,events,can,be,matched,to,this,pattern,return,the,same,pattern,with,a,link,quantifier,looping,consuming,strategy,quantifier,applied,throws,malformed,pattern,exception,if,the,quantifier,is,not,applicable,to,this,pattern;public,pattern,t,f,times,or,more,int,times,check,if,no,not,pattern,check,if,quantifier,applied,this,quantifier,quantifier,looping,quantifier,get,consuming,strategy,this,times,times,of,times,return,this
Pattern -> public Pattern<T, F> timesOrMore(int times);1503558242;Specifies that this pattern can occur the specified times at least._This means at least the specified times and at most infinite number of events can_be matched to this pattern.__@return The same pattern with a {@link Quantifier#looping(ConsumingStrategy)} quantifier applied._@throws MalformedPatternException if the quantifier is not applicable to this pattern.;public Pattern<T, F> timesOrMore(int times) {_		checkIfNoNotPattern()__		checkIfQuantifierApplied()__		this.quantifier = Quantifier.looping(quantifier.getConsumingStrategy())__		this.times = Times.of(times)__		return this__	};specifies,that,this,pattern,can,occur,the,specified,times,at,least,this,means,at,least,the,specified,times,and,at,most,infinite,number,of,events,can,be,matched,to,this,pattern,return,the,same,pattern,with,a,link,quantifier,looping,consuming,strategy,quantifier,applied,throws,malformed,pattern,exception,if,the,quantifier,is,not,applicable,to,this,pattern;public,pattern,t,f,times,or,more,int,times,check,if,no,not,pattern,check,if,quantifier,applied,this,quantifier,quantifier,looping,quantifier,get,consuming,strategy,this,times,times,of,times,return,this
Pattern -> public Pattern<T, F> timesOrMore(int times);1504268438;Specifies that this pattern can occur the specified times at least._This means at least the specified times and at most infinite number of events can_be matched to this pattern.__@return The same pattern with a {@link Quantifier#looping(ConsumingStrategy)} quantifier applied._@throws MalformedPatternException if the quantifier is not applicable to this pattern.;public Pattern<T, F> timesOrMore(int times) {_		checkIfNoNotPattern()__		checkIfQuantifierApplied()__		this.quantifier = Quantifier.looping(quantifier.getConsumingStrategy())__		this.times = Times.of(times)__		return this__	};specifies,that,this,pattern,can,occur,the,specified,times,at,least,this,means,at,least,the,specified,times,and,at,most,infinite,number,of,events,can,be,matched,to,this,pattern,return,the,same,pattern,with,a,link,quantifier,looping,consuming,strategy,quantifier,applied,throws,malformed,pattern,exception,if,the,quantifier,is,not,applicable,to,this,pattern;public,pattern,t,f,times,or,more,int,times,check,if,no,not,pattern,check,if,quantifier,applied,this,quantifier,quantifier,looping,quantifier,get,consuming,strategy,this,times,times,of,times,return,this
Pattern -> public Pattern<T, F> timesOrMore(int times);1530798894;Specifies that this pattern can occur the specified times at least._This means at least the specified times and at most infinite number of events can_be matched to this pattern.__@return The same pattern with a {@link Quantifier#looping(ConsumingStrategy)} quantifier applied._@throws MalformedPatternException if the quantifier is not applicable to this pattern.;public Pattern<T, F> timesOrMore(int times) {_		checkIfNoNotPattern()__		checkIfQuantifierApplied()__		this.quantifier = Quantifier.looping(quantifier.getConsumingStrategy())__		this.times = Times.of(times)__		return this__	};specifies,that,this,pattern,can,occur,the,specified,times,at,least,this,means,at,least,the,specified,times,and,at,most,infinite,number,of,events,can,be,matched,to,this,pattern,return,the,same,pattern,with,a,link,quantifier,looping,consuming,strategy,quantifier,applied,throws,malformed,pattern,exception,if,the,quantifier,is,not,applicable,to,this,pattern;public,pattern,t,f,times,or,more,int,times,check,if,no,not,pattern,check,if,quantifier,applied,this,quantifier,quantifier,looping,quantifier,get,consuming,strategy,this,times,times,of,times,return,this
Pattern -> public Pattern<T, F> timesOrMore(int times);1540208358;Specifies that this pattern can occur the specified times at least._This means at least the specified times and at most infinite number of events can_be matched to this pattern.__@return The same pattern with a {@link Quantifier#looping(ConsumingStrategy)} quantifier applied._@throws MalformedPatternException if the quantifier is not applicable to this pattern.;public Pattern<T, F> timesOrMore(int times) {_		checkIfNoNotPattern()__		checkIfQuantifierApplied()__		this.quantifier = Quantifier.looping(quantifier.getConsumingStrategy())__		this.times = Times.of(times)__		return this__	};specifies,that,this,pattern,can,occur,the,specified,times,at,least,this,means,at,least,the,specified,times,and,at,most,infinite,number,of,events,can,be,matched,to,this,pattern,return,the,same,pattern,with,a,link,quantifier,looping,consuming,strategy,quantifier,applied,throws,malformed,pattern,exception,if,the,quantifier,is,not,applicable,to,this,pattern;public,pattern,t,f,times,or,more,int,times,check,if,no,not,pattern,check,if,quantifier,applied,this,quantifier,quantifier,looping,quantifier,get,consuming,strategy,this,times,times,of,times,return,this
Pattern -> public Pattern<T, F> timesOrMore(int times);1543413704;Specifies that this pattern can occur the specified times at least._This means at least the specified times and at most infinite number of events can_be matched to this pattern.__@return The same pattern with a {@link Quantifier#looping(ConsumingStrategy)} quantifier applied._@throws MalformedPatternException if the quantifier is not applicable to this pattern.;public Pattern<T, F> timesOrMore(int times) {_		checkIfNoNotPattern()__		checkIfQuantifierApplied()__		this.quantifier = Quantifier.looping(quantifier.getConsumingStrategy())__		this.times = Times.of(times)__		return this__	};specifies,that,this,pattern,can,occur,the,specified,times,at,least,this,means,at,least,the,specified,times,and,at,most,infinite,number,of,events,can,be,matched,to,this,pattern,return,the,same,pattern,with,a,link,quantifier,looping,consuming,strategy,quantifier,applied,throws,malformed,pattern,exception,if,the,quantifier,is,not,applicable,to,this,pattern;public,pattern,t,f,times,or,more,int,times,check,if,no,not,pattern,check,if,quantifier,applied,this,quantifier,quantifier,looping,quantifier,get,consuming,strategy,this,times,times,of,times,return,this
Pattern -> public Pattern<T, T> notNext(final String name);1493985576;Appends a new pattern to the existing one. The new pattern enforces that there is no event matching this pattern_right after the preceding matched event.__@param name Name of the new pattern_@return A new pattern which is appended to this one;public Pattern<T, T> notNext(final String name) {_		return new Pattern<>(name, this, ConsumingStrategy.NOT_NEXT)__	};appends,a,new,pattern,to,the,existing,one,the,new,pattern,enforces,that,there,is,no,event,matching,this,pattern,right,after,the,preceding,matched,event,param,name,name,of,the,new,pattern,return,a,new,pattern,which,is,appended,to,this,one;public,pattern,t,t,not,next,final,string,name,return,new,pattern,name,this,consuming,strategy
Pattern -> public Pattern<T, T> notNext(final String name);1493997908;Appends a new pattern to the existing one. The new pattern enforces that there is no event matching this pattern_right after the preceding matched event.__@param name Name of the new pattern_@return A new pattern which is appended to this one;public Pattern<T, T> notNext(final String name) {_		if (quantifier.hasProperty(Quantifier.QuantifierProperty.OPTIONAL)) {_			throw new UnsupportedOperationException(_					"Specifying a pattern with an optional path to NOT condition is not supported yet. " +_					"You can simulate such pattern with two independent patterns, one with and the other without " +_					"the optional part.")__		}_		return new Pattern<>(name, this, ConsumingStrategy.NOT_NEXT)__	};appends,a,new,pattern,to,the,existing,one,the,new,pattern,enforces,that,there,is,no,event,matching,this,pattern,right,after,the,preceding,matched,event,param,name,name,of,the,new,pattern,return,a,new,pattern,which,is,appended,to,this,one;public,pattern,t,t,not,next,final,string,name,if,quantifier,has,property,quantifier,quantifier,property,optional,throw,new,unsupported,operation,exception,specifying,a,pattern,with,an,optional,path,to,not,condition,is,not,supported,yet,you,can,simulate,such,pattern,with,two,independent,patterns,one,with,and,the,other,without,the,optional,part,return,new,pattern,name,this,consuming,strategy
Pattern -> public Pattern<T, T> notNext(final String name);1495961498;Appends a new pattern to the existing one. The new pattern enforces that there is no event matching this pattern_right after the preceding matched event.__@param name Name of the new pattern_@return A new pattern which is appended to this one;public Pattern<T, T> notNext(final String name) {_		if (quantifier.hasProperty(Quantifier.QuantifierProperty.OPTIONAL)) {_			throw new UnsupportedOperationException(_					"Specifying a pattern with an optional path to NOT condition is not supported yet. " +_					"You can simulate such pattern with two independent patterns, one with and the other without " +_					"the optional part.")__		}_		return new Pattern<>(name, this, ConsumingStrategy.NOT_NEXT)__	};appends,a,new,pattern,to,the,existing,one,the,new,pattern,enforces,that,there,is,no,event,matching,this,pattern,right,after,the,preceding,matched,event,param,name,name,of,the,new,pattern,return,a,new,pattern,which,is,appended,to,this,one;public,pattern,t,t,not,next,final,string,name,if,quantifier,has,property,quantifier,quantifier,property,optional,throw,new,unsupported,operation,exception,specifying,a,pattern,with,an,optional,path,to,not,condition,is,not,supported,yet,you,can,simulate,such,pattern,with,two,independent,patterns,one,with,and,the,other,without,the,optional,part,return,new,pattern,name,this,consuming,strategy
Pattern -> public Pattern<T, T> notNext(final String name);1497940477;Appends a new pattern to the existing one. The new pattern enforces that there is no event matching this pattern_right after the preceding matched event.__@param name Name of the new pattern_@return A new pattern which is appended to this one;public Pattern<T, T> notNext(final String name) {_		if (quantifier.hasProperty(Quantifier.QuantifierProperty.OPTIONAL)) {_			throw new UnsupportedOperationException(_					"Specifying a pattern with an optional path to NOT condition is not supported yet. " +_					"You can simulate such pattern with two independent patterns, one with and the other without " +_					"the optional part.")__		}_		return new Pattern<>(name, this, ConsumingStrategy.NOT_NEXT)__	};appends,a,new,pattern,to,the,existing,one,the,new,pattern,enforces,that,there,is,no,event,matching,this,pattern,right,after,the,preceding,matched,event,param,name,name,of,the,new,pattern,return,a,new,pattern,which,is,appended,to,this,one;public,pattern,t,t,not,next,final,string,name,if,quantifier,has,property,quantifier,quantifier,property,optional,throw,new,unsupported,operation,exception,specifying,a,pattern,with,an,optional,path,to,not,condition,is,not,supported,yet,you,can,simulate,such,pattern,with,two,independent,patterns,one,with,and,the,other,without,the,optional,part,return,new,pattern,name,this,consuming,strategy
Pattern -> public Pattern<T, T> notNext(final String name);1498548074;Appends a new pattern to the existing one. The new pattern enforces that there is no event matching this pattern_right after the preceding matched event.__@param name Name of the new pattern_@return A new pattern which is appended to this one;public Pattern<T, T> notNext(final String name) {_		if (quantifier.hasProperty(Quantifier.QuantifierProperty.OPTIONAL)) {_			throw new UnsupportedOperationException(_					"Specifying a pattern with an optional path to NOT condition is not supported yet. " +_					"You can simulate such pattern with two independent patterns, one with and the other without " +_					"the optional part.")__		}_		return new Pattern<>(name, this, ConsumingStrategy.NOT_NEXT)__	};appends,a,new,pattern,to,the,existing,one,the,new,pattern,enforces,that,there,is,no,event,matching,this,pattern,right,after,the,preceding,matched,event,param,name,name,of,the,new,pattern,return,a,new,pattern,which,is,appended,to,this,one;public,pattern,t,t,not,next,final,string,name,if,quantifier,has,property,quantifier,quantifier,property,optional,throw,new,unsupported,operation,exception,specifying,a,pattern,with,an,optional,path,to,not,condition,is,not,supported,yet,you,can,simulate,such,pattern,with,two,independent,patterns,one,with,and,the,other,without,the,optional,part,return,new,pattern,name,this,consuming,strategy
Pattern -> public Pattern<T, T> notNext(final String name);1499244360;Appends a new pattern to the existing one. The new pattern enforces that there is no event matching this pattern_right after the preceding matched event.__@param name Name of the new pattern_@return A new pattern which is appended to this one;public Pattern<T, T> notNext(final String name) {_		if (quantifier.hasProperty(Quantifier.QuantifierProperty.OPTIONAL)) {_			throw new UnsupportedOperationException(_					"Specifying a pattern with an optional path to NOT condition is not supported yet. " +_					"You can simulate such pattern with two independent patterns, one with and the other without " +_					"the optional part.")__		}_		return new Pattern<>(name, this, ConsumingStrategy.NOT_NEXT)__	};appends,a,new,pattern,to,the,existing,one,the,new,pattern,enforces,that,there,is,no,event,matching,this,pattern,right,after,the,preceding,matched,event,param,name,name,of,the,new,pattern,return,a,new,pattern,which,is,appended,to,this,one;public,pattern,t,t,not,next,final,string,name,if,quantifier,has,property,quantifier,quantifier,property,optional,throw,new,unsupported,operation,exception,specifying,a,pattern,with,an,optional,path,to,not,condition,is,not,supported,yet,you,can,simulate,such,pattern,with,two,independent,patterns,one,with,and,the,other,without,the,optional,part,return,new,pattern,name,this,consuming,strategy
Pattern -> public Pattern<T, T> notNext(final String name);1499248439;Appends a new pattern to the existing one. The new pattern enforces that there is no event matching this pattern_right after the preceding matched event.__@param name Name of the new pattern_@return A new pattern which is appended to this one;public Pattern<T, T> notNext(final String name) {_		if (quantifier.hasProperty(Quantifier.QuantifierProperty.OPTIONAL)) {_			throw new UnsupportedOperationException(_					"Specifying a pattern with an optional path to NOT condition is not supported yet. " +_					"You can simulate such pattern with two independent patterns, one with and the other without " +_					"the optional part.")__		}_		return new Pattern<>(name, this, ConsumingStrategy.NOT_NEXT)__	};appends,a,new,pattern,to,the,existing,one,the,new,pattern,enforces,that,there,is,no,event,matching,this,pattern,right,after,the,preceding,matched,event,param,name,name,of,the,new,pattern,return,a,new,pattern,which,is,appended,to,this,one;public,pattern,t,t,not,next,final,string,name,if,quantifier,has,property,quantifier,quantifier,property,optional,throw,new,unsupported,operation,exception,specifying,a,pattern,with,an,optional,path,to,not,condition,is,not,supported,yet,you,can,simulate,such,pattern,with,two,independent,patterns,one,with,and,the,other,without,the,optional,part,return,new,pattern,name,this,consuming,strategy
Pattern -> public Pattern<T, T> notNext(final String name);1503420807;Appends a new pattern to the existing one. The new pattern enforces that there is no event matching this pattern_right after the preceding matched event.__@param name Name of the new pattern_@return A new pattern which is appended to this one;public Pattern<T, T> notNext(final String name) {_		if (quantifier.hasProperty(Quantifier.QuantifierProperty.OPTIONAL)) {_			throw new UnsupportedOperationException(_					"Specifying a pattern with an optional path to NOT condition is not supported yet. " +_					"You can simulate such pattern with two independent patterns, one with and the other without " +_					"the optional part.")__		}_		return new Pattern<>(name, this, ConsumingStrategy.NOT_NEXT)__	};appends,a,new,pattern,to,the,existing,one,the,new,pattern,enforces,that,there,is,no,event,matching,this,pattern,right,after,the,preceding,matched,event,param,name,name,of,the,new,pattern,return,a,new,pattern,which,is,appended,to,this,one;public,pattern,t,t,not,next,final,string,name,if,quantifier,has,property,quantifier,quantifier,property,optional,throw,new,unsupported,operation,exception,specifying,a,pattern,with,an,optional,path,to,not,condition,is,not,supported,yet,you,can,simulate,such,pattern,with,two,independent,patterns,one,with,and,the,other,without,the,optional,part,return,new,pattern,name,this,consuming,strategy
Pattern -> public Pattern<T, T> notNext(final String name);1503558242;Appends a new pattern to the existing one. The new pattern enforces that there is no event matching this pattern_right after the preceding matched event.__@param name Name of the new pattern_@return A new pattern which is appended to this one;public Pattern<T, T> notNext(final String name) {_		if (quantifier.hasProperty(Quantifier.QuantifierProperty.OPTIONAL)) {_			throw new UnsupportedOperationException(_					"Specifying a pattern with an optional path to NOT condition is not supported yet. " +_					"You can simulate such pattern with two independent patterns, one with and the other without " +_					"the optional part.")__		}_		return new Pattern<>(name, this, ConsumingStrategy.NOT_NEXT)__	};appends,a,new,pattern,to,the,existing,one,the,new,pattern,enforces,that,there,is,no,event,matching,this,pattern,right,after,the,preceding,matched,event,param,name,name,of,the,new,pattern,return,a,new,pattern,which,is,appended,to,this,one;public,pattern,t,t,not,next,final,string,name,if,quantifier,has,property,quantifier,quantifier,property,optional,throw,new,unsupported,operation,exception,specifying,a,pattern,with,an,optional,path,to,not,condition,is,not,supported,yet,you,can,simulate,such,pattern,with,two,independent,patterns,one,with,and,the,other,without,the,optional,part,return,new,pattern,name,this,consuming,strategy
Pattern -> public Pattern<T, T> notNext(final String name);1504268438;Appends a new pattern to the existing one. The new pattern enforces that there is no event matching this pattern_right after the preceding matched event.__@param name Name of the new pattern_@return A new pattern which is appended to this one;public Pattern<T, T> notNext(final String name) {_		if (quantifier.hasProperty(Quantifier.QuantifierProperty.OPTIONAL)) {_			throw new UnsupportedOperationException(_					"Specifying a pattern with an optional path to NOT condition is not supported yet. " +_					"You can simulate such pattern with two independent patterns, one with and the other without " +_					"the optional part.")__		}_		return new Pattern<>(name, this, ConsumingStrategy.NOT_NEXT, afterMatchSkipStrategy)__	};appends,a,new,pattern,to,the,existing,one,the,new,pattern,enforces,that,there,is,no,event,matching,this,pattern,right,after,the,preceding,matched,event,param,name,name,of,the,new,pattern,return,a,new,pattern,which,is,appended,to,this,one;public,pattern,t,t,not,next,final,string,name,if,quantifier,has,property,quantifier,quantifier,property,optional,throw,new,unsupported,operation,exception,specifying,a,pattern,with,an,optional,path,to,not,condition,is,not,supported,yet,you,can,simulate,such,pattern,with,two,independent,patterns,one,with,and,the,other,without,the,optional,part,return,new,pattern,name,this,consuming,strategy,after,match,skip,strategy
Pattern -> public Pattern<T, T> notNext(final String name);1530798894;Appends a new pattern to the existing one. The new pattern enforces that there is no event matching this pattern_right after the preceding matched event.__@param name Name of the new pattern_@return A new pattern which is appended to this one;public Pattern<T, T> notNext(final String name) {_		if (quantifier.hasProperty(Quantifier.QuantifierProperty.OPTIONAL)) {_			throw new UnsupportedOperationException(_					"Specifying a pattern with an optional path to NOT condition is not supported yet. " +_					"You can simulate such pattern with two independent patterns, one with and the other without " +_					"the optional part.")__		}_		return new Pattern<>(name, this, ConsumingStrategy.NOT_NEXT, afterMatchSkipStrategy)__	};appends,a,new,pattern,to,the,existing,one,the,new,pattern,enforces,that,there,is,no,event,matching,this,pattern,right,after,the,preceding,matched,event,param,name,name,of,the,new,pattern,return,a,new,pattern,which,is,appended,to,this,one;public,pattern,t,t,not,next,final,string,name,if,quantifier,has,property,quantifier,quantifier,property,optional,throw,new,unsupported,operation,exception,specifying,a,pattern,with,an,optional,path,to,not,condition,is,not,supported,yet,you,can,simulate,such,pattern,with,two,independent,patterns,one,with,and,the,other,without,the,optional,part,return,new,pattern,name,this,consuming,strategy,after,match,skip,strategy
Pattern -> public Pattern<T, T> notNext(final String name);1540208358;Appends a new pattern to the existing one. The new pattern enforces that there is no event matching this pattern_right after the preceding matched event.__@param name Name of the new pattern_@return A new pattern which is appended to this one;public Pattern<T, T> notNext(final String name) {_		if (quantifier.hasProperty(Quantifier.QuantifierProperty.OPTIONAL)) {_			throw new UnsupportedOperationException(_					"Specifying a pattern with an optional path to NOT condition is not supported yet. " +_					"You can simulate such pattern with two independent patterns, one with and the other without " +_					"the optional part.")__		}_		return new Pattern<>(name, this, ConsumingStrategy.NOT_NEXT, afterMatchSkipStrategy)__	};appends,a,new,pattern,to,the,existing,one,the,new,pattern,enforces,that,there,is,no,event,matching,this,pattern,right,after,the,preceding,matched,event,param,name,name,of,the,new,pattern,return,a,new,pattern,which,is,appended,to,this,one;public,pattern,t,t,not,next,final,string,name,if,quantifier,has,property,quantifier,quantifier,property,optional,throw,new,unsupported,operation,exception,specifying,a,pattern,with,an,optional,path,to,not,condition,is,not,supported,yet,you,can,simulate,such,pattern,with,two,independent,patterns,one,with,and,the,other,without,the,optional,part,return,new,pattern,name,this,consuming,strategy,after,match,skip,strategy
Pattern -> public Pattern<T, T> notNext(final String name);1543413704;Appends a new pattern to the existing one. The new pattern enforces that there is no event matching this pattern_right after the preceding matched event.__@param name Name of the new pattern_@return A new pattern which is appended to this one;public Pattern<T, T> notNext(final String name) {_		if (quantifier.hasProperty(Quantifier.QuantifierProperty.OPTIONAL)) {_			throw new UnsupportedOperationException(_					"Specifying a pattern with an optional path to NOT condition is not supported yet. " +_					"You can simulate such pattern with two independent patterns, one with and the other without " +_					"the optional part.")__		}_		return new Pattern<>(name, this, ConsumingStrategy.NOT_NEXT, afterMatchSkipStrategy)__	};appends,a,new,pattern,to,the,existing,one,the,new,pattern,enforces,that,there,is,no,event,matching,this,pattern,right,after,the,preceding,matched,event,param,name,name,of,the,new,pattern,return,a,new,pattern,which,is,appended,to,this,one;public,pattern,t,t,not,next,final,string,name,if,quantifier,has,property,quantifier,quantifier,property,optional,throw,new,unsupported,operation,exception,specifying,a,pattern,with,an,optional,path,to,not,condition,is,not,supported,yet,you,can,simulate,such,pattern,with,two,independent,patterns,one,with,and,the,other,without,the,optional,part,return,new,pattern,name,this,consuming,strategy,after,match,skip,strategy
Pattern -> public Pattern<T, F> where(FilterFunction<F> newFilterFunction);1454421848;Specifies a filter condition which has to be fulfilled by an event in order to be matched.__@param newFilterFunction Filter condition_@return The same pattern operator where the new filter condition is set;public Pattern<T, F> where(FilterFunction<F> newFilterFunction) {_		ClosureCleaner.clean(newFilterFunction, true)___		if (this.filterFunction == null) {_			this.filterFunction = newFilterFunction__		} else {_			this.filterFunction = new AndFilterFunction<F>(this.filterFunction, newFilterFunction)__		}__		return this__	};specifies,a,filter,condition,which,has,to,be,fulfilled,by,an,event,in,order,to,be,matched,param,new,filter,function,filter,condition,return,the,same,pattern,operator,where,the,new,filter,condition,is,set;public,pattern,t,f,where,filter,function,f,new,filter,function,closure,cleaner,clean,new,filter,function,true,if,this,filter,function,null,this,filter,function,new,filter,function,else,this,filter,function,new,and,filter,function,f,this,filter,function,new,filter,function,return,this
Pattern -> public Pattern<T, F> where(FilterFunction<F> newFilterFunction);1456442894;Specifies a filter condition which has to be fulfilled by an event in order to be matched.__@param newFilterFunction Filter condition_@return The same pattern operator where the new filter condition is set;public Pattern<T, F> where(FilterFunction<F> newFilterFunction) {_		ClosureCleaner.clean(newFilterFunction, true)___		if (this.filterFunction == null) {_			this.filterFunction = newFilterFunction__		} else {_			this.filterFunction = new AndFilterFunction<F>(this.filterFunction, newFilterFunction)__		}__		return this__	};specifies,a,filter,condition,which,has,to,be,fulfilled,by,an,event,in,order,to,be,matched,param,new,filter,function,filter,condition,return,the,same,pattern,operator,where,the,new,filter,condition,is,set;public,pattern,t,f,where,filter,function,f,new,filter,function,closure,cleaner,clean,new,filter,function,true,if,this,filter,function,null,this,filter,function,new,filter,function,else,this,filter,function,new,and,filter,function,f,this,filter,function,new,filter,function,return,this
Pattern -> public Pattern<T, F> where(FilterFunction<F> newFilterFunction);1461689259;Specifies a filter condition which has to be fulfilled by an event in order to be matched.__@param newFilterFunction Filter condition_@return The same pattern operator where the new filter condition is set;public Pattern<T, F> where(FilterFunction<F> newFilterFunction) {_		ClosureCleaner.clean(newFilterFunction, true)___		if (this.filterFunction == null) {_			this.filterFunction = newFilterFunction__		} else {_			this.filterFunction = new AndFilterFunction<F>(this.filterFunction, newFilterFunction)__		}__		return this__	};specifies,a,filter,condition,which,has,to,be,fulfilled,by,an,event,in,order,to,be,matched,param,new,filter,function,filter,condition,return,the,same,pattern,operator,where,the,new,filter,condition,is,set;public,pattern,t,f,where,filter,function,f,new,filter,function,closure,cleaner,clean,new,filter,function,true,if,this,filter,function,null,this,filter,function,new,filter,function,else,this,filter,function,new,and,filter,function,f,this,filter,function,new,filter,function,return,this
Pattern -> public Pattern<T, F> where(FilterFunction<F> newFilterFunction);1471613162;Specifies a filter condition which has to be fulfilled by an event in order to be matched.__@param newFilterFunction Filter condition_@return The same pattern operator where the new filter condition is set;public Pattern<T, F> where(FilterFunction<F> newFilterFunction) {_		ClosureCleaner.clean(newFilterFunction, true)___		if (this.filterFunction == null) {_			this.filterFunction = newFilterFunction__		} else {_			this.filterFunction = new AndFilterFunction<F>(this.filterFunction, newFilterFunction)__		}__		return this__	};specifies,a,filter,condition,which,has,to,be,fulfilled,by,an,event,in,order,to,be,matched,param,new,filter,function,filter,condition,return,the,same,pattern,operator,where,the,new,filter,condition,is,set;public,pattern,t,f,where,filter,function,f,new,filter,function,closure,cleaner,clean,new,filter,function,true,if,this,filter,function,null,this,filter,function,new,filter,function,else,this,filter,function,new,and,filter,function,f,this,filter,function,new,filter,function,return,this
Pattern -> public Pattern<T, F> where(FilterFunction<F> newFilterFunction);1471614454;Specifies a filter condition which has to be fulfilled by an event in order to be matched.__@param newFilterFunction Filter condition_@return The same pattern operator where the new filter condition is set;public Pattern<T, F> where(FilterFunction<F> newFilterFunction) {_		ClosureCleaner.clean(newFilterFunction, true)___		if (this.filterFunction == null) {_			this.filterFunction = newFilterFunction__		} else {_			this.filterFunction = new AndFilterFunction<F>(this.filterFunction, newFilterFunction)__		}__		return this__	};specifies,a,filter,condition,which,has,to,be,fulfilled,by,an,event,in,order,to,be,matched,param,new,filter,function,filter,condition,return,the,same,pattern,operator,where,the,new,filter,condition,is,set;public,pattern,t,f,where,filter,function,f,new,filter,function,closure,cleaner,clean,new,filter,function,true,if,this,filter,function,null,this,filter,function,new,filter,function,else,this,filter,function,new,and,filter,function,f,this,filter,function,new,filter,function,return,this
Pattern -> public Pattern<T, F> where(FilterFunction<F> newFilterFunction);1488270949;Specifies a filter condition which has to be fulfilled by an event in order to be matched.__@param newFilterFunction Filter condition_@return The same pattern operator where the new filter condition is set;public Pattern<T, F> where(FilterFunction<F> newFilterFunction) {_		ClosureCleaner.clean(newFilterFunction, true)___		if (this.filterFunction == null) {_			this.filterFunction = newFilterFunction__		} else {_			this.filterFunction = new AndFilterFunction<F>(this.filterFunction, newFilterFunction)__		}__		return this__	};specifies,a,filter,condition,which,has,to,be,fulfilled,by,an,event,in,order,to,be,matched,param,new,filter,function,filter,condition,return,the,same,pattern,operator,where,the,new,filter,condition,is,set;public,pattern,t,f,where,filter,function,f,new,filter,function,closure,cleaner,clean,new,filter,function,true,if,this,filter,function,null,this,filter,function,new,filter,function,else,this,filter,function,new,and,filter,function,f,this,filter,function,new,filter,function,return,this
Pattern -> public Pattern<T, F> where(FilterFunction<F> newFilterFunction);1490262475;Specifies a filter condition which has to be fulfilled by an event in order to be matched.__@param newFilterFunction Filter condition_@return The same pattern operator where the new filter condition is set;public Pattern<T, F> where(FilterFunction<F> newFilterFunction) {_		ClosureCleaner.clean(newFilterFunction, true)___		if (this.filterFunction == null) {_			this.filterFunction = newFilterFunction__		} else {_			this.filterFunction = new AndFilterFunction<F>(this.filterFunction, newFilterFunction)__		}__		return this__	};specifies,a,filter,condition,which,has,to,be,fulfilled,by,an,event,in,order,to,be,matched,param,new,filter,function,filter,condition,return,the,same,pattern,operator,where,the,new,filter,condition,is,set;public,pattern,t,f,where,filter,function,f,new,filter,function,closure,cleaner,clean,new,filter,function,true,if,this,filter,function,null,this,filter,function,new,filter,function,else,this,filter,function,new,and,filter,function,f,this,filter,function,new,filter,function,return,this
Pattern -> public Pattern<T, F> zeroOrMore(final boolean eager);1490262475;Specifies that this pattern can occur zero or more times(kleene star)._This means any number of events can be matched in this state.__If eagerness is enabled for a pattern A*B and sequence A1 A2 B will generate patterns:_B, A1 B and A1 A2 B. If disabled B, A1 B, A2 B and A1 A2 B.__@param eager if true the pattern always consumes earlier events_@return The same pattern with applied Kleene star operator__@throws MalformedPatternException if quantifier already applied;public Pattern<T, F> zeroOrMore(final boolean eager) {_		checkIfQuantifierApplied()__		if (eager) {_			this.quantifier = Quantifier.ZERO_OR_MORE_EAGER__		} else {_			this.quantifier = Quantifier.ZERO_OR_MORE_COMBINATIONS__		}_		return this__	};specifies,that,this,pattern,can,occur,zero,or,more,times,kleene,star,this,means,any,number,of,events,can,be,matched,in,this,state,if,eagerness,is,enabled,for,a,pattern,a,b,and,sequence,a1,a2,b,will,generate,patterns,b,a1,b,and,a1,a2,b,if,disabled,b,a1,b,a2,b,and,a1,a2,b,param,eager,if,true,the,pattern,always,consumes,earlier,events,return,the,same,pattern,with,applied,kleene,star,operator,throws,malformed,pattern,exception,if,quantifier,already,applied;public,pattern,t,f,zero,or,more,final,boolean,eager,check,if,quantifier,applied,if,eager,this,quantifier,quantifier,else,this,quantifier,quantifier,return,this
Pattern -> public Pattern<T, F> zeroOrMore(final boolean eager);1490638274;Specifies that this pattern can occur zero or more times(kleene star)._This means any number of events can be matched in this state.__If eagerness is enabled for a pattern A*B and sequence A1 A2 B will generate patterns:_B, A1 B and A1 A2 B. If disabled B, A1 B, A2 B and A1 A2 B.__@param eager if true the pattern always consumes earlier events_@return The same pattern with applied Kleene star operator__@throws MalformedPatternException if quantifier already applied;public Pattern<T, F> zeroOrMore(final boolean eager) {_		checkIfQuantifierApplied()__		if (eager) {_			this.quantifier = Quantifier.ZERO_OR_MORE_EAGER__		} else {_			this.quantifier = Quantifier.ZERO_OR_MORE_COMBINATIONS__		}_		return this__	};specifies,that,this,pattern,can,occur,zero,or,more,times,kleene,star,this,means,any,number,of,events,can,be,matched,in,this,state,if,eagerness,is,enabled,for,a,pattern,a,b,and,sequence,a1,a2,b,will,generate,patterns,b,a1,b,and,a1,a2,b,if,disabled,b,a1,b,a2,b,and,a1,a2,b,param,eager,if,true,the,pattern,always,consumes,earlier,events,return,the,same,pattern,with,applied,kleene,star,operator,throws,malformed,pattern,exception,if,quantifier,already,applied;public,pattern,t,f,zero,or,more,final,boolean,eager,check,if,quantifier,applied,if,eager,this,quantifier,quantifier,else,this,quantifier,quantifier,return,this
Pattern -> public Pattern<T, F> zeroOrMore(final boolean eager);1490862259;Specifies that this pattern can occur zero or more times(kleene star)._This means any number of events can be matched in this state.__If eagerness is enabled for a pattern A*B and sequence A1 A2 B will generate patterns:_B, A1 B and A1 A2 B. If disabled B, A1 B, A2 B and A1 A2 B.__@param eager if true the pattern always consumes earlier events_@return The same pattern with applied Kleene star operator__@throws MalformedPatternException if quantifier already applied;public Pattern<T, F> zeroOrMore(final boolean eager) {_		checkIfQuantifierApplied()__		if (eager) {_			this.quantifier = Quantifier.ZERO_OR_MORE_EAGER__		} else {_			this.quantifier = Quantifier.ZERO_OR_MORE_COMBINATIONS__		}_		return this__	};specifies,that,this,pattern,can,occur,zero,or,more,times,kleene,star,this,means,any,number,of,events,can,be,matched,in,this,state,if,eagerness,is,enabled,for,a,pattern,a,b,and,sequence,a1,a2,b,will,generate,patterns,b,a1,b,and,a1,a2,b,if,disabled,b,a1,b,a2,b,and,a1,a2,b,param,eager,if,true,the,pattern,always,consumes,earlier,events,return,the,same,pattern,with,applied,kleene,star,operator,throws,malformed,pattern,exception,if,quantifier,already,applied;public,pattern,t,f,zero,or,more,final,boolean,eager,check,if,quantifier,applied,if,eager,this,quantifier,quantifier,else,this,quantifier,quantifier,return,this
Pattern -> public Pattern<T, F> zeroOrMore(final boolean eager);1491647251;Specifies that this pattern can occur zero or more times(kleene star)._This means any number of events can be matched in this state.__If eagerness is enabled for a pattern A*B and sequence A1 A2 B will generate patterns:_B, A1 B and A1 A2 B. If disabled B, A1 B, A2 B and A1 A2 B.__@param eager if true the pattern always consumes earlier events_@return The same pattern with applied Kleene star operator__@throws MalformedPatternException if quantifier already applied;public Pattern<T, F> zeroOrMore(final boolean eager) {_		checkIfQuantifierApplied()__		if (eager) {_			this.quantifier = Quantifier.ZERO_OR_MORE_EAGER__		} else {_			this.quantifier = Quantifier.ZERO_OR_MORE_COMBINATIONS__		}_		return this__	};specifies,that,this,pattern,can,occur,zero,or,more,times,kleene,star,this,means,any,number,of,events,can,be,matched,in,this,state,if,eagerness,is,enabled,for,a,pattern,a,b,and,sequence,a1,a2,b,will,generate,patterns,b,a1,b,and,a1,a2,b,if,disabled,b,a1,b,a2,b,and,a1,a2,b,param,eager,if,true,the,pattern,always,consumes,earlier,events,return,the,same,pattern,with,applied,kleene,star,operator,throws,malformed,pattern,exception,if,quantifier,already,applied;public,pattern,t,f,zero,or,more,final,boolean,eager,check,if,quantifier,applied,if,eager,this,quantifier,quantifier,else,this,quantifier,quantifier,return,this
Pattern -> public static <T, F extends T> GroupPattern<T, F> begin(Pattern<T, F> group);1499244360;Starts a new pattern sequence. The provided pattern is the initial pattern_of the new sequence.__@param group the pattern to begin with_@return the first pattern of a pattern sequence;public static <T, F extends T> GroupPattern<T, F> begin(Pattern<T, F> group) {_		return new GroupPattern<>(null, group)__	};starts,a,new,pattern,sequence,the,provided,pattern,is,the,initial,pattern,of,the,new,sequence,param,group,the,pattern,to,begin,with,return,the,first,pattern,of,a,pattern,sequence;public,static,t,f,extends,t,group,pattern,t,f,begin,pattern,t,f,group,return,new,group,pattern,null,group
Pattern -> public static <T, F extends T> GroupPattern<T, F> begin(Pattern<T, F> group);1499248439;Starts a new pattern sequence. The provided pattern is the initial pattern_of the new sequence.__@param group the pattern to begin with_@return the first pattern of a pattern sequence;public static <T, F extends T> GroupPattern<T, F> begin(Pattern<T, F> group) {_		return new GroupPattern<>(null, group)__	};starts,a,new,pattern,sequence,the,provided,pattern,is,the,initial,pattern,of,the,new,sequence,param,group,the,pattern,to,begin,with,return,the,first,pattern,of,a,pattern,sequence;public,static,t,f,extends,t,group,pattern,t,f,begin,pattern,t,f,group,return,new,group,pattern,null,group
Pattern -> public static <T, F extends T> GroupPattern<T, F> begin(Pattern<T, F> group);1503420807;Starts a new pattern sequence. The provided pattern is the initial pattern_of the new sequence.__@param group the pattern to begin with_@return the first pattern of a pattern sequence;public static <T, F extends T> GroupPattern<T, F> begin(Pattern<T, F> group) {_		return new GroupPattern<>(null, group)__	};starts,a,new,pattern,sequence,the,provided,pattern,is,the,initial,pattern,of,the,new,sequence,param,group,the,pattern,to,begin,with,return,the,first,pattern,of,a,pattern,sequence;public,static,t,f,extends,t,group,pattern,t,f,begin,pattern,t,f,group,return,new,group,pattern,null,group
Pattern -> public static <T, F extends T> GroupPattern<T, F> begin(Pattern<T, F> group);1503558242;Starts a new pattern sequence. The provided pattern is the initial pattern_of the new sequence.__@param group the pattern to begin with_@return the first pattern of a pattern sequence;public static <T, F extends T> GroupPattern<T, F> begin(Pattern<T, F> group) {_		return new GroupPattern<>(null, group)__	};starts,a,new,pattern,sequence,the,provided,pattern,is,the,initial,pattern,of,the,new,sequence,param,group,the,pattern,to,begin,with,return,the,first,pattern,of,a,pattern,sequence;public,static,t,f,extends,t,group,pattern,t,f,begin,pattern,t,f,group,return,new,group,pattern,null,group
Pattern -> public static <T, F extends T> GroupPattern<T, F> begin(Pattern<T, F> group);1504268438;Starts a new pattern sequence. The provided pattern is the initial pattern_of the new sequence.__@param group the pattern to begin with_@return the first pattern of a pattern sequence;public static <T, F extends T> GroupPattern<T, F> begin(Pattern<T, F> group) {_		return new GroupPattern<>(null, group, ConsumingStrategy.STRICT, AfterMatchSkipStrategy.noSkip())__	};starts,a,new,pattern,sequence,the,provided,pattern,is,the,initial,pattern,of,the,new,sequence,param,group,the,pattern,to,begin,with,return,the,first,pattern,of,a,pattern,sequence;public,static,t,f,extends,t,group,pattern,t,f,begin,pattern,t,f,group,return,new,group,pattern,null,group,consuming,strategy,strict,after,match,skip,strategy,no,skip
Pattern -> public static <T, F extends T> GroupPattern<T, F> begin(Pattern<T, F> group);1530798894;Starts a new pattern sequence. The provided pattern is the initial pattern_of the new sequence.__@param group the pattern to begin with_@return the first pattern of a pattern sequence;public static <T, F extends T> GroupPattern<T, F> begin(Pattern<T, F> group) {_		return new GroupPattern<>(null, group, ConsumingStrategy.STRICT, AfterMatchSkipStrategy.noSkip())__	};starts,a,new,pattern,sequence,the,provided,pattern,is,the,initial,pattern,of,the,new,sequence,param,group,the,pattern,to,begin,with,return,the,first,pattern,of,a,pattern,sequence;public,static,t,f,extends,t,group,pattern,t,f,begin,pattern,t,f,group,return,new,group,pattern,null,group,consuming,strategy,strict,after,match,skip,strategy,no,skip
Pattern -> public static <T, F extends T> GroupPattern<T, F> begin(Pattern<T, F> group);1540208358;Starts a new pattern sequence. The provided pattern is the initial pattern_of the new sequence.__@param group the pattern to begin with_@return the first pattern of a pattern sequence;public static <T, F extends T> GroupPattern<T, F> begin(Pattern<T, F> group) {_		return new GroupPattern<>(null, group, ConsumingStrategy.STRICT, AfterMatchSkipStrategy.noSkip())__	};starts,a,new,pattern,sequence,the,provided,pattern,is,the,initial,pattern,of,the,new,sequence,param,group,the,pattern,to,begin,with,return,the,first,pattern,of,a,pattern,sequence;public,static,t,f,extends,t,group,pattern,t,f,begin,pattern,t,f,group,return,new,group,pattern,null,group,consuming,strategy,strict,after,match,skip,strategy,no,skip
Pattern -> public static <T, F extends T> GroupPattern<T, F> begin(Pattern<T, F> group);1543413704;Starts a new pattern sequence. The provided pattern is the initial pattern_of the new sequence.__@param group the pattern to begin with_@return the first pattern of a pattern sequence;public static <T, F extends T> GroupPattern<T, F> begin(Pattern<T, F> group) {_		return new GroupPattern<>(null, group, ConsumingStrategy.STRICT, AfterMatchSkipStrategy.noSkip())__	};starts,a,new,pattern,sequence,the,provided,pattern,is,the,initial,pattern,of,the,new,sequence,param,group,the,pattern,to,begin,with,return,the,first,pattern,of,a,pattern,sequence;public,static,t,f,extends,t,group,pattern,t,f,begin,pattern,t,f,group,return,new,group,pattern,null,group,consuming,strategy,strict,after,match,skip,strategy,no,skip
Pattern -> public Pattern<T, F> allowCombinations();1493201751;Applicable only to {@link Quantifier#ONE_OR_MORE()} patterns, this option_allows more flexibility to the matching events.__<p>If {@code allowCombinations()} is not applied for a_pattern {@code A.oneOrMore().followedBy(B)} and a sequence of events_{@code A1 A2 B} appears, this will generate patterns:_{@code A1 B} and {@code A1 A2 B}. If this method is applied, we_will have {@code A1 B}, {@code A2 B} and {@code A1 A2 B}.__@return The same pattern with the updated quantifier.	 *_@throws MalformedPatternException if the quantifier is not applicable to this pattern.;public Pattern<T, F> allowCombinations() {_		quantifier.allowAllCombinations()__		return this__	};applicable,only,to,link,quantifier,patterns,this,option,allows,more,flexibility,to,the,matching,events,p,if,code,allow,combinations,is,not,applied,for,a,pattern,code,a,one,or,more,followed,by,b,and,a,sequence,of,events,code,a1,a2,b,appears,this,will,generate,patterns,code,a1,b,and,code,a1,a2,b,if,this,method,is,applied,we,will,have,code,a1,b,code,a2,b,and,code,a1,a2,b,return,the,same,pattern,with,the,updated,quantifier,throws,malformed,pattern,exception,if,the,quantifier,is,not,applicable,to,this,pattern;public,pattern,t,f,allow,combinations,quantifier,allow,all,combinations,return,this
Pattern -> public Pattern<T, F> allowCombinations();1493201753;Applicable only to {@link Quantifier#ONE_OR_MORE()} and {@link Quantifier#TIMES()} patterns,_this option allows more flexibility to the matching events.__<p>If {@code allowCombinations()} is not applied for a_pattern {@code A.oneOrMore().followedBy(B)} and a sequence of events_{@code A1 A2 B} appears, this will generate patterns:_{@code A1 B} and {@code A1 A2 B}. If this method is applied, we_will have {@code A1 B}, {@code A2 B} and {@code A1 A2 B}.__@return The same pattern with the updated quantifier.	 *_@throws MalformedPatternException if the quantifier is not applicable to this pattern.;public Pattern<T, F> allowCombinations() {_		quantifier.combinations()__		return this__	};applicable,only,to,link,quantifier,and,link,quantifier,times,patterns,this,option,allows,more,flexibility,to,the,matching,events,p,if,code,allow,combinations,is,not,applied,for,a,pattern,code,a,one,or,more,followed,by,b,and,a,sequence,of,events,code,a1,a2,b,appears,this,will,generate,patterns,code,a1,b,and,code,a1,a2,b,if,this,method,is,applied,we,will,have,code,a1,b,code,a2,b,and,code,a1,a2,b,return,the,same,pattern,with,the,updated,quantifier,throws,malformed,pattern,exception,if,the,quantifier,is,not,applicable,to,this,pattern;public,pattern,t,f,allow,combinations,quantifier,combinations,return,this
Pattern -> public Pattern<T, F> allowCombinations();1493382517;Applicable only to {@link Quantifier#ONE_OR_MORE(ConsumingStrategy)} and_{@link Quantifier#TIMES(ConsumingStrategy)} patterns, this option allows more flexibility to the matching events.__<p>If {@code allowCombinations()} is not applied for a_pattern {@code A.oneOrMore().followedBy(B)} and a sequence of events_{@code A1 A2 B} appears, this will generate patterns:_{@code A1 B} and {@code A1 A2 B}. If this method is applied, we_will have {@code A1 B}, {@code A2 B} and {@code A1 A2 B}.__@return The same pattern with the updated quantifier.	 *_@throws MalformedPatternException if the quantifier is not applicable to this pattern.;public Pattern<T, F> allowCombinations() {_		quantifier.combinations()__		return this__	};applicable,only,to,link,quantifier,consuming,strategy,and,link,quantifier,times,consuming,strategy,patterns,this,option,allows,more,flexibility,to,the,matching,events,p,if,code,allow,combinations,is,not,applied,for,a,pattern,code,a,one,or,more,followed,by,b,and,a,sequence,of,events,code,a1,a2,b,appears,this,will,generate,patterns,code,a1,b,and,code,a1,a2,b,if,this,method,is,applied,we,will,have,code,a1,b,code,a2,b,and,code,a1,a2,b,return,the,same,pattern,with,the,updated,quantifier,throws,malformed,pattern,exception,if,the,quantifier,is,not,applicable,to,this,pattern;public,pattern,t,f,allow,combinations,quantifier,combinations,return,this
Pattern -> public Pattern<T, F> allowCombinations();1493906327;Applicable only to {@link Quantifier#ONE_OR_MORE(ConsumingStrategy)} and_{@link Quantifier#TIMES(ConsumingStrategy)} patterns, this option allows more flexibility to the matching events.__<p>If {@code allowCombinations()} is not applied for a_pattern {@code A.oneOrMore().followedBy(B)} and a sequence of events_{@code A1 A2 B} appears, this will generate patterns:_{@code A1 B} and {@code A1 A2 B}. If this method is applied, we_will have {@code A1 B}, {@code A2 B} and {@code A1 A2 B}.__@return The same pattern with the updated quantifier.	 *_@throws MalformedPatternException if the quantifier is not applicable to this pattern.;public Pattern<T, F> allowCombinations() {_		quantifier.combinations()__		return this__	};applicable,only,to,link,quantifier,consuming,strategy,and,link,quantifier,times,consuming,strategy,patterns,this,option,allows,more,flexibility,to,the,matching,events,p,if,code,allow,combinations,is,not,applied,for,a,pattern,code,a,one,or,more,followed,by,b,and,a,sequence,of,events,code,a1,a2,b,appears,this,will,generate,patterns,code,a1,b,and,code,a1,a2,b,if,this,method,is,applied,we,will,have,code,a1,b,code,a2,b,and,code,a1,a2,b,return,the,same,pattern,with,the,updated,quantifier,throws,malformed,pattern,exception,if,the,quantifier,is,not,applicable,to,this,pattern;public,pattern,t,f,allow,combinations,quantifier,combinations,return,this
Pattern -> public Pattern<T, F> allowCombinations();1493985576;Applicable only to {@link Quantifier#ONE_OR_MORE(ConsumingStrategy)} and_{@link Quantifier#TIMES(ConsumingStrategy)} patterns, this option allows more flexibility to the matching events.__<p>If {@code allowCombinations()} is not applied for a_pattern {@code A.oneOrMore().followedBy(B)} and a sequence of events_{@code A1 A2 B} appears, this will generate patterns:_{@code A1 B} and {@code A1 A2 B}. If this method is applied, we_will have {@code A1 B}, {@code A2 B} and {@code A1 A2 B}.__@return The same pattern with the updated quantifier.	 *_@throws MalformedPatternException if the quantifier is not applicable to this pattern.;public Pattern<T, F> allowCombinations() {_		quantifier.combinations()__		return this__	};applicable,only,to,link,quantifier,consuming,strategy,and,link,quantifier,times,consuming,strategy,patterns,this,option,allows,more,flexibility,to,the,matching,events,p,if,code,allow,combinations,is,not,applied,for,a,pattern,code,a,one,or,more,followed,by,b,and,a,sequence,of,events,code,a1,a2,b,appears,this,will,generate,patterns,code,a1,b,and,code,a1,a2,b,if,this,method,is,applied,we,will,have,code,a1,b,code,a2,b,and,code,a1,a2,b,return,the,same,pattern,with,the,updated,quantifier,throws,malformed,pattern,exception,if,the,quantifier,is,not,applicable,to,this,pattern;public,pattern,t,f,allow,combinations,quantifier,combinations,return,this
Pattern -> public Pattern<T, F> allowCombinations();1493997908;Applicable only to {@link Quantifier#ONE_OR_MORE(ConsumingStrategy)} and_{@link Quantifier#TIMES(ConsumingStrategy)} patterns, this option allows more flexibility to the matching events.__<p>If {@code allowCombinations()} is not applied for a_pattern {@code A.oneOrMore().followedBy(B)} and a sequence of events_{@code A1 A2 B} appears, this will generate patterns:_{@code A1 B} and {@code A1 A2 B}. If this method is applied, we_will have {@code A1 B}, {@code A2 B} and {@code A1 A2 B}.__@return The same pattern with the updated quantifier.	 *_@throws MalformedPatternException if the quantifier is not applicable to this pattern.;public Pattern<T, F> allowCombinations() {_		quantifier.combinations()__		return this__	};applicable,only,to,link,quantifier,consuming,strategy,and,link,quantifier,times,consuming,strategy,patterns,this,option,allows,more,flexibility,to,the,matching,events,p,if,code,allow,combinations,is,not,applied,for,a,pattern,code,a,one,or,more,followed,by,b,and,a,sequence,of,events,code,a1,a2,b,appears,this,will,generate,patterns,code,a1,b,and,code,a1,a2,b,if,this,method,is,applied,we,will,have,code,a1,b,code,a2,b,and,code,a1,a2,b,return,the,same,pattern,with,the,updated,quantifier,throws,malformed,pattern,exception,if,the,quantifier,is,not,applicable,to,this,pattern;public,pattern,t,f,allow,combinations,quantifier,combinations,return,this
Pattern -> public Pattern<T, F> allowCombinations();1495961498;Applicable only to {@link Quantifier#oneOrMore(ConsumingStrategy)} and_{@link Quantifier#times(ConsumingStrategy)} patterns, this option allows more flexibility to the matching events.__<p>If {@code allowCombinations()} is not applied for a_pattern {@code A.oneOrMore().followedBy(B)} and a sequence of events_{@code A1 A2 B} appears, this will generate patterns:_{@code A1 B} and {@code A1 A2 B}. If this method is applied, we_will have {@code A1 B}, {@code A2 B} and {@code A1 A2 B}.__@return The same pattern with the updated quantifier.	 *_@throws MalformedPatternException if the quantifier is not applicable to this pattern.;public Pattern<T, F> allowCombinations() {_		quantifier.combinations()__		return this__	};applicable,only,to,link,quantifier,one,or,more,consuming,strategy,and,link,quantifier,times,consuming,strategy,patterns,this,option,allows,more,flexibility,to,the,matching,events,p,if,code,allow,combinations,is,not,applied,for,a,pattern,code,a,one,or,more,followed,by,b,and,a,sequence,of,events,code,a1,a2,b,appears,this,will,generate,patterns,code,a1,b,and,code,a1,a2,b,if,this,method,is,applied,we,will,have,code,a1,b,code,a2,b,and,code,a1,a2,b,return,the,same,pattern,with,the,updated,quantifier,throws,malformed,pattern,exception,if,the,quantifier,is,not,applicable,to,this,pattern;public,pattern,t,f,allow,combinations,quantifier,combinations,return,this
Pattern -> public Pattern<T, F> allowCombinations();1497940477;Applicable only to {@link Quantifier#oneOrMore(ConsumingStrategy)} and_{@link Quantifier#times(ConsumingStrategy)} patterns, this option allows more flexibility to the matching events.__<p>If {@code allowCombinations()} is not applied for a_pattern {@code A.oneOrMore().followedBy(B)} and a sequence of events_{@code A1 A2 B} appears, this will generate patterns:_{@code A1 B} and {@code A1 A2 B}. If this method is applied, we_will have {@code A1 B}, {@code A2 B} and {@code A1 A2 B}.__@return The same pattern with the updated quantifier.	 *_@throws MalformedPatternException if the quantifier is not applicable to this pattern.;public Pattern<T, F> allowCombinations() {_		quantifier.combinations()__		return this__	};applicable,only,to,link,quantifier,one,or,more,consuming,strategy,and,link,quantifier,times,consuming,strategy,patterns,this,option,allows,more,flexibility,to,the,matching,events,p,if,code,allow,combinations,is,not,applied,for,a,pattern,code,a,one,or,more,followed,by,b,and,a,sequence,of,events,code,a1,a2,b,appears,this,will,generate,patterns,code,a1,b,and,code,a1,a2,b,if,this,method,is,applied,we,will,have,code,a1,b,code,a2,b,and,code,a1,a2,b,return,the,same,pattern,with,the,updated,quantifier,throws,malformed,pattern,exception,if,the,quantifier,is,not,applicable,to,this,pattern;public,pattern,t,f,allow,combinations,quantifier,combinations,return,this
Pattern -> public Pattern<T, F> allowCombinations();1498548074;Applicable only to {@link Quantifier#oneOrMore(ConsumingStrategy)} and_{@link Quantifier#times(ConsumingStrategy)} patterns, this option allows more flexibility to the matching events.__<p>If {@code allowCombinations()} is not applied for a_pattern {@code A.oneOrMore().followedBy(B)} and a sequence of events_{@code A1 A2 B} appears, this will generate patterns:_{@code A1 B} and {@code A1 A2 B}. If this method is applied, we_will have {@code A1 B}, {@code A2 B} and {@code A1 A2 B}.__@return The same pattern with the updated quantifier.	 *_@throws MalformedPatternException if the quantifier is not applicable to this pattern.;public Pattern<T, F> allowCombinations() {_		quantifier.combinations()__		return this__	};applicable,only,to,link,quantifier,one,or,more,consuming,strategy,and,link,quantifier,times,consuming,strategy,patterns,this,option,allows,more,flexibility,to,the,matching,events,p,if,code,allow,combinations,is,not,applied,for,a,pattern,code,a,one,or,more,followed,by,b,and,a,sequence,of,events,code,a1,a2,b,appears,this,will,generate,patterns,code,a1,b,and,code,a1,a2,b,if,this,method,is,applied,we,will,have,code,a1,b,code,a2,b,and,code,a1,a2,b,return,the,same,pattern,with,the,updated,quantifier,throws,malformed,pattern,exception,if,the,quantifier,is,not,applicable,to,this,pattern;public,pattern,t,f,allow,combinations,quantifier,combinations,return,this
Pattern -> public Pattern<T, F> allowCombinations();1499244360;Applicable only to {@link Quantifier#oneOrMore(ConsumingStrategy)} and_{@link Quantifier#times(ConsumingStrategy)} patterns, this option allows more flexibility to the matching events.__<p>If {@code allowCombinations()} is not applied for a_pattern {@code A.oneOrMore().followedBy(B)} and a sequence of events_{@code A1 A2 B} appears, this will generate patterns:_{@code A1 B} and {@code A1 A2 B}. If this method is applied, we_will have {@code A1 B}, {@code A2 B} and {@code A1 A2 B}.__@return The same pattern with the updated quantifier.	 *_@throws MalformedPatternException if the quantifier is not applicable to this pattern.;public Pattern<T, F> allowCombinations() {_		quantifier.combinations()__		return this__	};applicable,only,to,link,quantifier,one,or,more,consuming,strategy,and,link,quantifier,times,consuming,strategy,patterns,this,option,allows,more,flexibility,to,the,matching,events,p,if,code,allow,combinations,is,not,applied,for,a,pattern,code,a,one,or,more,followed,by,b,and,a,sequence,of,events,code,a1,a2,b,appears,this,will,generate,patterns,code,a1,b,and,code,a1,a2,b,if,this,method,is,applied,we,will,have,code,a1,b,code,a2,b,and,code,a1,a2,b,return,the,same,pattern,with,the,updated,quantifier,throws,malformed,pattern,exception,if,the,quantifier,is,not,applicable,to,this,pattern;public,pattern,t,f,allow,combinations,quantifier,combinations,return,this
Pattern -> public Pattern<T, F> allowCombinations();1499248439;Applicable only to {@link Quantifier#oneOrMore(ConsumingStrategy)} and_{@link Quantifier#times(ConsumingStrategy)} patterns, this option allows more flexibility to the matching events.__<p>If {@code allowCombinations()} is not applied for a_pattern {@code A.oneOrMore().followedBy(B)} and a sequence of events_{@code A1 A2 B} appears, this will generate patterns:_{@code A1 B} and {@code A1 A2 B}. If this method is applied, we_will have {@code A1 B}, {@code A2 B} and {@code A1 A2 B}.__@return The same pattern with the updated quantifier.	 *_@throws MalformedPatternException if the quantifier is not applicable to this pattern.;public Pattern<T, F> allowCombinations() {_		quantifier.combinations()__		return this__	};applicable,only,to,link,quantifier,one,or,more,consuming,strategy,and,link,quantifier,times,consuming,strategy,patterns,this,option,allows,more,flexibility,to,the,matching,events,p,if,code,allow,combinations,is,not,applied,for,a,pattern,code,a,one,or,more,followed,by,b,and,a,sequence,of,events,code,a1,a2,b,appears,this,will,generate,patterns,code,a1,b,and,code,a1,a2,b,if,this,method,is,applied,we,will,have,code,a1,b,code,a2,b,and,code,a1,a2,b,return,the,same,pattern,with,the,updated,quantifier,throws,malformed,pattern,exception,if,the,quantifier,is,not,applicable,to,this,pattern;public,pattern,t,f,allow,combinations,quantifier,combinations,return,this
Pattern -> public Pattern<T, F> allowCombinations();1503420807;Applicable only to {@link Quantifier#looping(ConsumingStrategy)} and_{@link Quantifier#times(ConsumingStrategy)} patterns, this option allows more flexibility to the matching events.__<p>If {@code allowCombinations()} is not applied for a_pattern {@code A.oneOrMore().followedBy(B)} and a sequence of events_{@code A1 A2 B} appears, this will generate patterns:_{@code A1 B} and {@code A1 A2 B}. If this method is applied, we_will have {@code A1 B}, {@code A2 B} and {@code A1 A2 B}.__@return The same pattern with the updated quantifier.	 *_@throws MalformedPatternException if the quantifier is not applicable to this pattern.;public Pattern<T, F> allowCombinations() {_		quantifier.combinations()__		return this__	};applicable,only,to,link,quantifier,looping,consuming,strategy,and,link,quantifier,times,consuming,strategy,patterns,this,option,allows,more,flexibility,to,the,matching,events,p,if,code,allow,combinations,is,not,applied,for,a,pattern,code,a,one,or,more,followed,by,b,and,a,sequence,of,events,code,a1,a2,b,appears,this,will,generate,patterns,code,a1,b,and,code,a1,a2,b,if,this,method,is,applied,we,will,have,code,a1,b,code,a2,b,and,code,a1,a2,b,return,the,same,pattern,with,the,updated,quantifier,throws,malformed,pattern,exception,if,the,quantifier,is,not,applicable,to,this,pattern;public,pattern,t,f,allow,combinations,quantifier,combinations,return,this
Pattern -> public Pattern<T, F> allowCombinations();1503558242;Applicable only to {@link Quantifier#looping(ConsumingStrategy)} and_{@link Quantifier#times(ConsumingStrategy)} patterns, this option allows more flexibility to the matching events.__<p>If {@code allowCombinations()} is not applied for a_pattern {@code A.oneOrMore().followedBy(B)} and a sequence of events_{@code A1 A2 B} appears, this will generate patterns:_{@code A1 B} and {@code A1 A2 B}. If this method is applied, we_will have {@code A1 B}, {@code A2 B} and {@code A1 A2 B}.__@return The same pattern with the updated quantifier.	 *_@throws MalformedPatternException if the quantifier is not applicable to this pattern.;public Pattern<T, F> allowCombinations() {_		quantifier.combinations()__		return this__	};applicable,only,to,link,quantifier,looping,consuming,strategy,and,link,quantifier,times,consuming,strategy,patterns,this,option,allows,more,flexibility,to,the,matching,events,p,if,code,allow,combinations,is,not,applied,for,a,pattern,code,a,one,or,more,followed,by,b,and,a,sequence,of,events,code,a1,a2,b,appears,this,will,generate,patterns,code,a1,b,and,code,a1,a2,b,if,this,method,is,applied,we,will,have,code,a1,b,code,a2,b,and,code,a1,a2,b,return,the,same,pattern,with,the,updated,quantifier,throws,malformed,pattern,exception,if,the,quantifier,is,not,applicable,to,this,pattern;public,pattern,t,f,allow,combinations,quantifier,combinations,return,this
Pattern -> public Pattern<T, F> allowCombinations();1504268438;Applicable only to {@link Quantifier#looping(ConsumingStrategy)} and_{@link Quantifier#times(ConsumingStrategy)} patterns, this option allows more flexibility to the matching events.__<p>If {@code allowCombinations()} is not applied for a_pattern {@code A.oneOrMore().followedBy(B)} and a sequence of events_{@code A1 A2 B} appears, this will generate patterns:_{@code A1 B} and {@code A1 A2 B}. If this method is applied, we_will have {@code A1 B}, {@code A2 B} and {@code A1 A2 B}.__@return The same pattern with the updated quantifier.	 *_@throws MalformedPatternException if the quantifier is not applicable to this pattern.;public Pattern<T, F> allowCombinations() {_		quantifier.combinations()__		return this__	};applicable,only,to,link,quantifier,looping,consuming,strategy,and,link,quantifier,times,consuming,strategy,patterns,this,option,allows,more,flexibility,to,the,matching,events,p,if,code,allow,combinations,is,not,applied,for,a,pattern,code,a,one,or,more,followed,by,b,and,a,sequence,of,events,code,a1,a2,b,appears,this,will,generate,patterns,code,a1,b,and,code,a1,a2,b,if,this,method,is,applied,we,will,have,code,a1,b,code,a2,b,and,code,a1,a2,b,return,the,same,pattern,with,the,updated,quantifier,throws,malformed,pattern,exception,if,the,quantifier,is,not,applicable,to,this,pattern;public,pattern,t,f,allow,combinations,quantifier,combinations,return,this
Pattern -> public Pattern<T, F> allowCombinations();1530798894;Applicable only to {@link Quantifier#looping(ConsumingStrategy)} and_{@link Quantifier#times(ConsumingStrategy)} patterns, this option allows more flexibility to the matching events.__<p>If {@code allowCombinations()} is not applied for a_pattern {@code A.oneOrMore().followedBy(B)} and a sequence of events_{@code A1 A2 B} appears, this will generate patterns:_{@code A1 B} and {@code A1 A2 B}. If this method is applied, we_will have {@code A1 B}, {@code A2 B} and {@code A1 A2 B}.__@return The same pattern with the updated quantifier.	 *_@throws MalformedPatternException if the quantifier is not applicable to this pattern.;public Pattern<T, F> allowCombinations() {_		quantifier.combinations()__		return this__	};applicable,only,to,link,quantifier,looping,consuming,strategy,and,link,quantifier,times,consuming,strategy,patterns,this,option,allows,more,flexibility,to,the,matching,events,p,if,code,allow,combinations,is,not,applied,for,a,pattern,code,a,one,or,more,followed,by,b,and,a,sequence,of,events,code,a1,a2,b,appears,this,will,generate,patterns,code,a1,b,and,code,a1,a2,b,if,this,method,is,applied,we,will,have,code,a1,b,code,a2,b,and,code,a1,a2,b,return,the,same,pattern,with,the,updated,quantifier,throws,malformed,pattern,exception,if,the,quantifier,is,not,applicable,to,this,pattern;public,pattern,t,f,allow,combinations,quantifier,combinations,return,this
Pattern -> public Pattern<T, F> allowCombinations();1540208358;Applicable only to {@link Quantifier#looping(ConsumingStrategy)} and_{@link Quantifier#times(ConsumingStrategy)} patterns, this option allows more flexibility to the matching events.__<p>If {@code allowCombinations()} is not applied for a_pattern {@code A.oneOrMore().followedBy(B)} and a sequence of events_{@code A1 A2 B} appears, this will generate patterns:_{@code A1 B} and {@code A1 A2 B}. If this method is applied, we_will have {@code A1 B}, {@code A2 B} and {@code A1 A2 B}.__@return The same pattern with the updated quantifier.	 *_@throws MalformedPatternException if the quantifier is not applicable to this pattern.;public Pattern<T, F> allowCombinations() {_		quantifier.combinations()__		return this__	};applicable,only,to,link,quantifier,looping,consuming,strategy,and,link,quantifier,times,consuming,strategy,patterns,this,option,allows,more,flexibility,to,the,matching,events,p,if,code,allow,combinations,is,not,applied,for,a,pattern,code,a,one,or,more,followed,by,b,and,a,sequence,of,events,code,a1,a2,b,appears,this,will,generate,patterns,code,a1,b,and,code,a1,a2,b,if,this,method,is,applied,we,will,have,code,a1,b,code,a2,b,and,code,a1,a2,b,return,the,same,pattern,with,the,updated,quantifier,throws,malformed,pattern,exception,if,the,quantifier,is,not,applicable,to,this,pattern;public,pattern,t,f,allow,combinations,quantifier,combinations,return,this
Pattern -> public Pattern<T, F> allowCombinations();1543413704;Applicable only to {@link Quantifier#looping(ConsumingStrategy)} and_{@link Quantifier#times(ConsumingStrategy)} patterns, this option allows more flexibility to the matching events.__<p>If {@code allowCombinations()} is not applied for a_pattern {@code A.oneOrMore().followedBy(B)} and a sequence of events_{@code A1 A2 B} appears, this will generate patterns:_{@code A1 B} and {@code A1 A2 B}. If this method is applied, we_will have {@code A1 B}, {@code A2 B} and {@code A1 A2 B}.__@return The same pattern with the updated quantifier.	 *_@throws MalformedPatternException if the quantifier is not applicable to this pattern.;public Pattern<T, F> allowCombinations() {_		quantifier.combinations()__		return this__	};applicable,only,to,link,quantifier,looping,consuming,strategy,and,link,quantifier,times,consuming,strategy,patterns,this,option,allows,more,flexibility,to,the,matching,events,p,if,code,allow,combinations,is,not,applied,for,a,pattern,code,a,one,or,more,followed,by,b,and,a,sequence,of,events,code,a1,a2,b,appears,this,will,generate,patterns,code,a1,b,and,code,a1,a2,b,if,this,method,is,applied,we,will,have,code,a1,b,code,a2,b,and,code,a1,a2,b,return,the,same,pattern,with,the,updated,quantifier,throws,malformed,pattern,exception,if,the,quantifier,is,not,applicable,to,this,pattern;public,pattern,t,f,allow,combinations,quantifier,combinations,return,this
Pattern -> public Pattern<T, F> times(int from, int to);1497940477;Specifies that the pattern can occur between from and to times.__@param from number of times matching event must appear at least_@param to number of times matching event must appear at most_@return The same pattern with the number of times range applied__@throws MalformedPatternException if the quantifier is not applicable to this pattern.;public Pattern<T, F> times(int from, int to) {_		checkIfNoNotPattern()__		checkIfQuantifierApplied()__		this.quantifier = Quantifier.times(quantifier.getConsumingStrategy())__		if (from == 0) {_			this.quantifier.optional()__		}_		this.times = Times.of(from, to)__		return this__	};specifies,that,the,pattern,can,occur,between,from,and,to,times,param,from,number,of,times,matching,event,must,appear,at,least,param,to,number,of,times,matching,event,must,appear,at,most,return,the,same,pattern,with,the,number,of,times,range,applied,throws,malformed,pattern,exception,if,the,quantifier,is,not,applicable,to,this,pattern;public,pattern,t,f,times,int,from,int,to,check,if,no,not,pattern,check,if,quantifier,applied,this,quantifier,quantifier,times,quantifier,get,consuming,strategy,if,from,0,this,quantifier,optional,this,times,times,of,from,to,return,this
Pattern -> public Pattern<T, F> times(int from, int to);1498548074;Specifies that the pattern can occur between from and to times.__@param from number of times matching event must appear at least_@param to number of times matching event must appear at most_@return The same pattern with the number of times range applied__@throws MalformedPatternException if the quantifier is not applicable to this pattern.;public Pattern<T, F> times(int from, int to) {_		checkIfNoNotPattern()__		checkIfQuantifierApplied()__		this.quantifier = Quantifier.times(quantifier.getConsumingStrategy())__		if (from == 0) {_			this.quantifier.optional()__		}_		this.times = Times.of(from, to)__		return this__	};specifies,that,the,pattern,can,occur,between,from,and,to,times,param,from,number,of,times,matching,event,must,appear,at,least,param,to,number,of,times,matching,event,must,appear,at,most,return,the,same,pattern,with,the,number,of,times,range,applied,throws,malformed,pattern,exception,if,the,quantifier,is,not,applicable,to,this,pattern;public,pattern,t,f,times,int,from,int,to,check,if,no,not,pattern,check,if,quantifier,applied,this,quantifier,quantifier,times,quantifier,get,consuming,strategy,if,from,0,this,quantifier,optional,this,times,times,of,from,to,return,this
Pattern -> public Pattern<T, F> times(int from, int to);1499244360;Specifies that the pattern can occur between from and to times.__@param from number of times matching event must appear at least_@param to number of times matching event must appear at most_@return The same pattern with the number of times range applied__@throws MalformedPatternException if the quantifier is not applicable to this pattern.;public Pattern<T, F> times(int from, int to) {_		checkIfNoNotPattern()__		checkIfQuantifierApplied()__		this.quantifier = Quantifier.times(quantifier.getConsumingStrategy())__		if (from == 0) {_			this.quantifier.optional()__		}_		this.times = Times.of(from, to)__		return this__	};specifies,that,the,pattern,can,occur,between,from,and,to,times,param,from,number,of,times,matching,event,must,appear,at,least,param,to,number,of,times,matching,event,must,appear,at,most,return,the,same,pattern,with,the,number,of,times,range,applied,throws,malformed,pattern,exception,if,the,quantifier,is,not,applicable,to,this,pattern;public,pattern,t,f,times,int,from,int,to,check,if,no,not,pattern,check,if,quantifier,applied,this,quantifier,quantifier,times,quantifier,get,consuming,strategy,if,from,0,this,quantifier,optional,this,times,times,of,from,to,return,this
Pattern -> public Pattern<T, F> times(int from, int to);1499248439;Specifies that the pattern can occur between from and to times.__@param from number of times matching event must appear at least_@param to number of times matching event must appear at most_@return The same pattern with the number of times range applied__@throws MalformedPatternException if the quantifier is not applicable to this pattern.;public Pattern<T, F> times(int from, int to) {_		checkIfNoNotPattern()__		checkIfQuantifierApplied()__		this.quantifier = Quantifier.times(quantifier.getConsumingStrategy())__		if (from == 0) {_			this.quantifier.optional()__			from = 1__		}_		this.times = Times.of(from, to)__		return this__	};specifies,that,the,pattern,can,occur,between,from,and,to,times,param,from,number,of,times,matching,event,must,appear,at,least,param,to,number,of,times,matching,event,must,appear,at,most,return,the,same,pattern,with,the,number,of,times,range,applied,throws,malformed,pattern,exception,if,the,quantifier,is,not,applicable,to,this,pattern;public,pattern,t,f,times,int,from,int,to,check,if,no,not,pattern,check,if,quantifier,applied,this,quantifier,quantifier,times,quantifier,get,consuming,strategy,if,from,0,this,quantifier,optional,from,1,this,times,times,of,from,to,return,this
Pattern -> public Pattern<T, F> times(int from, int to);1503420807;Specifies that the pattern can occur between from and to times.__@param from number of times matching event must appear at least_@param to number of times matching event must appear at most_@return The same pattern with the number of times range applied__@throws MalformedPatternException if the quantifier is not applicable to this pattern.;public Pattern<T, F> times(int from, int to) {_		checkIfNoNotPattern()__		checkIfQuantifierApplied()__		this.quantifier = Quantifier.times(quantifier.getConsumingStrategy())__		if (from == 0) {_			this.quantifier.optional()__			from = 1__		}_		this.times = Times.of(from, to)__		return this__	};specifies,that,the,pattern,can,occur,between,from,and,to,times,param,from,number,of,times,matching,event,must,appear,at,least,param,to,number,of,times,matching,event,must,appear,at,most,return,the,same,pattern,with,the,number,of,times,range,applied,throws,malformed,pattern,exception,if,the,quantifier,is,not,applicable,to,this,pattern;public,pattern,t,f,times,int,from,int,to,check,if,no,not,pattern,check,if,quantifier,applied,this,quantifier,quantifier,times,quantifier,get,consuming,strategy,if,from,0,this,quantifier,optional,from,1,this,times,times,of,from,to,return,this
Pattern -> public Pattern<T, F> times(int from, int to);1503558242;Specifies that the pattern can occur between from and to times.__@param from number of times matching event must appear at least_@param to number of times matching event must appear at most_@return The same pattern with the number of times range applied__@throws MalformedPatternException if the quantifier is not applicable to this pattern.;public Pattern<T, F> times(int from, int to) {_		checkIfNoNotPattern()__		checkIfQuantifierApplied()__		this.quantifier = Quantifier.times(quantifier.getConsumingStrategy())__		if (from == 0) {_			this.quantifier.optional()__			from = 1__		}_		this.times = Times.of(from, to)__		return this__	};specifies,that,the,pattern,can,occur,between,from,and,to,times,param,from,number,of,times,matching,event,must,appear,at,least,param,to,number,of,times,matching,event,must,appear,at,most,return,the,same,pattern,with,the,number,of,times,range,applied,throws,malformed,pattern,exception,if,the,quantifier,is,not,applicable,to,this,pattern;public,pattern,t,f,times,int,from,int,to,check,if,no,not,pattern,check,if,quantifier,applied,this,quantifier,quantifier,times,quantifier,get,consuming,strategy,if,from,0,this,quantifier,optional,from,1,this,times,times,of,from,to,return,this
Pattern -> public Pattern<T, F> times(int from, int to);1504268438;Specifies that the pattern can occur between from and to times.__@param from number of times matching event must appear at least_@param to number of times matching event must appear at most_@return The same pattern with the number of times range applied__@throws MalformedPatternException if the quantifier is not applicable to this pattern.;public Pattern<T, F> times(int from, int to) {_		checkIfNoNotPattern()__		checkIfQuantifierApplied()__		this.quantifier = Quantifier.times(quantifier.getConsumingStrategy())__		if (from == 0) {_			this.quantifier.optional()__			from = 1__		}_		this.times = Times.of(from, to)__		return this__	};specifies,that,the,pattern,can,occur,between,from,and,to,times,param,from,number,of,times,matching,event,must,appear,at,least,param,to,number,of,times,matching,event,must,appear,at,most,return,the,same,pattern,with,the,number,of,times,range,applied,throws,malformed,pattern,exception,if,the,quantifier,is,not,applicable,to,this,pattern;public,pattern,t,f,times,int,from,int,to,check,if,no,not,pattern,check,if,quantifier,applied,this,quantifier,quantifier,times,quantifier,get,consuming,strategy,if,from,0,this,quantifier,optional,from,1,this,times,times,of,from,to,return,this
Pattern -> public Pattern<T, F> times(int from, int to);1530798894;Specifies that the pattern can occur between from and to times.__@param from number of times matching event must appear at least_@param to number of times matching event must appear at most_@return The same pattern with the number of times range applied__@throws MalformedPatternException if the quantifier is not applicable to this pattern.;public Pattern<T, F> times(int from, int to) {_		checkIfNoNotPattern()__		checkIfQuantifierApplied()__		this.quantifier = Quantifier.times(quantifier.getConsumingStrategy())__		if (from == 0) {_			this.quantifier.optional()__			from = 1__		}_		this.times = Times.of(from, to)__		return this__	};specifies,that,the,pattern,can,occur,between,from,and,to,times,param,from,number,of,times,matching,event,must,appear,at,least,param,to,number,of,times,matching,event,must,appear,at,most,return,the,same,pattern,with,the,number,of,times,range,applied,throws,malformed,pattern,exception,if,the,quantifier,is,not,applicable,to,this,pattern;public,pattern,t,f,times,int,from,int,to,check,if,no,not,pattern,check,if,quantifier,applied,this,quantifier,quantifier,times,quantifier,get,consuming,strategy,if,from,0,this,quantifier,optional,from,1,this,times,times,of,from,to,return,this
Pattern -> public Pattern<T, F> times(int from, int to);1540208358;Specifies that the pattern can occur between from and to times.__@param from number of times matching event must appear at least_@param to number of times matching event must appear at most_@return The same pattern with the number of times range applied__@throws MalformedPatternException if the quantifier is not applicable to this pattern.;public Pattern<T, F> times(int from, int to) {_		checkIfNoNotPattern()__		checkIfQuantifierApplied()__		this.quantifier = Quantifier.times(quantifier.getConsumingStrategy())__		if (from == 0) {_			this.quantifier.optional()__			from = 1__		}_		this.times = Times.of(from, to)__		return this__	};specifies,that,the,pattern,can,occur,between,from,and,to,times,param,from,number,of,times,matching,event,must,appear,at,least,param,to,number,of,times,matching,event,must,appear,at,most,return,the,same,pattern,with,the,number,of,times,range,applied,throws,malformed,pattern,exception,if,the,quantifier,is,not,applicable,to,this,pattern;public,pattern,t,f,times,int,from,int,to,check,if,no,not,pattern,check,if,quantifier,applied,this,quantifier,quantifier,times,quantifier,get,consuming,strategy,if,from,0,this,quantifier,optional,from,1,this,times,times,of,from,to,return,this
Pattern -> public Pattern<T, F> times(int from, int to);1543413704;Specifies that the pattern can occur between from and to times.__@param from number of times matching event must appear at least_@param to number of times matching event must appear at most_@return The same pattern with the number of times range applied__@throws MalformedPatternException if the quantifier is not applicable to this pattern.;public Pattern<T, F> times(int from, int to) {_		checkIfNoNotPattern()__		checkIfQuantifierApplied()__		this.quantifier = Quantifier.times(quantifier.getConsumingStrategy())__		if (from == 0) {_			this.quantifier.optional()__			from = 1__		}_		this.times = Times.of(from, to)__		return this__	};specifies,that,the,pattern,can,occur,between,from,and,to,times,param,from,number,of,times,matching,event,must,appear,at,least,param,to,number,of,times,matching,event,must,appear,at,most,return,the,same,pattern,with,the,number,of,times,range,applied,throws,malformed,pattern,exception,if,the,quantifier,is,not,applicable,to,this,pattern;public,pattern,t,f,times,int,from,int,to,check,if,no,not,pattern,check,if,quantifier,applied,this,quantifier,quantifier,times,quantifier,get,consuming,strategy,if,from,0,this,quantifier,optional,from,1,this,times,times,of,from,to,return,this
