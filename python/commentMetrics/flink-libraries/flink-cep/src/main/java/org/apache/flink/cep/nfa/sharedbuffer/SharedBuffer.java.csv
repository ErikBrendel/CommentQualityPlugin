# id;timestamp;commentText;codeText;commentWords;codeWords
SharedBuffer -> public NodeId put( 			final String stateName, 			final EventId eventId, 			@Nullable final NodeId previousNodeId, 			final DeweyNumber version) throws Exception;1528894799;Stores given value (value + timestamp) under the given state. It assigns a preceding element_relation to the previous entry.__@param stateName     name of the state that the event should be assigned to_@param eventId       unique id of event assigned by this SharedBuffer_@param previousNodeId id of previous entry_@param version       Version of the previous relation_@return assigned id of this element_@throws Exception Thrown if the system cannot access the state.;public NodeId put(_			final String stateName,_			final EventId eventId,_			@Nullable final NodeId previousNodeId,_			final DeweyNumber version) throws Exception {__		if (previousNodeId != null) {_			lockNode(previousNodeId)__		}__		NodeId currentNodeId = new NodeId(eventId, getOriginalNameFromInternal(stateName))__		Lockable<SharedBufferNode> currentNode = pages.get(currentNodeId)__		if (currentNode == null) {_			currentNode = new Lockable<>(new SharedBufferNode(), 0)__			lockEvent(eventId)__		}__		currentNode.getElement().addEdge(new SharedBufferEdge(_			previousNodeId,_			version))__		pages.put(currentNodeId, currentNode)___		return currentNodeId__	};stores,given,value,value,timestamp,under,the,given,state,it,assigns,a,preceding,element,relation,to,the,previous,entry,param,state,name,name,of,the,state,that,the,event,should,be,assigned,to,param,event,id,unique,id,of,event,assigned,by,this,shared,buffer,param,previous,node,id,id,of,previous,entry,param,version,version,of,the,previous,relation,return,assigned,id,of,this,element,throws,exception,thrown,if,the,system,cannot,access,the,state;public,node,id,put,final,string,state,name,final,event,id,event,id,nullable,final,node,id,previous,node,id,final,dewey,number,version,throws,exception,if,previous,node,id,null,lock,node,previous,node,id,node,id,current,node,id,new,node,id,event,id,get,original,name,from,internal,state,name,lockable,shared,buffer,node,current,node,pages,get,current,node,id,if,current,node,null,current,node,new,lockable,new,shared,buffer,node,0,lock,event,event,id,current,node,get,element,add,edge,new,shared,buffer,edge,previous,node,id,version,pages,put,current,node,id,current,node,return,current,node,id
SharedBuffer -> public NodeId put( 			final String stateName, 			final EventId eventId, 			@Nullable final NodeId previousNodeId, 			final DeweyNumber version) throws Exception;1528894799;Stores given value (value + timestamp) under the given state. It assigns a preceding element_relation to the previous entry.__@param stateName      name of the state that the event should be assigned to_@param eventId        unique id of event assigned by this SharedBuffer_@param previousNodeId id of previous entry (might be null if start of new run)_@param version        Version of the previous relation_@return assigned id of this element_@throws Exception Thrown if the system cannot access the state.;public NodeId put(_			final String stateName,_			final EventId eventId,_			@Nullable final NodeId previousNodeId,_			final DeweyNumber version) throws Exception {__		if (previousNodeId != null) {_			lockNode(previousNodeId)__		}__		NodeId currentNodeId = new NodeId(eventId, getOriginalNameFromInternal(stateName))__		Lockable<SharedBufferNode> currentNode = entries.get(currentNodeId)__		if (currentNode == null) {_			currentNode = new Lockable<>(new SharedBufferNode(), 0)__			lockEvent(eventId)__		}__		currentNode.getElement().addEdge(new SharedBufferEdge(_			previousNodeId,_			version))__		entries.put(currentNodeId, currentNode)___		return currentNodeId__	};stores,given,value,value,timestamp,under,the,given,state,it,assigns,a,preceding,element,relation,to,the,previous,entry,param,state,name,name,of,the,state,that,the,event,should,be,assigned,to,param,event,id,unique,id,of,event,assigned,by,this,shared,buffer,param,previous,node,id,id,of,previous,entry,might,be,null,if,start,of,new,run,param,version,version,of,the,previous,relation,return,assigned,id,of,this,element,throws,exception,thrown,if,the,system,cannot,access,the,state;public,node,id,put,final,string,state,name,final,event,id,event,id,nullable,final,node,id,previous,node,id,final,dewey,number,version,throws,exception,if,previous,node,id,null,lock,node,previous,node,id,node,id,current,node,id,new,node,id,event,id,get,original,name,from,internal,state,name,lockable,shared,buffer,node,current,node,entries,get,current,node,id,if,current,node,null,current,node,new,lockable,new,shared,buffer,node,0,lock,event,event,id,current,node,get,element,add,edge,new,shared,buffer,edge,previous,node,id,version,entries,put,current,node,id,current,node,return,current,node,id
SharedBuffer -> public NodeId put( 			final String stateName, 			final EventId eventId, 			@Nullable final NodeId previousNodeId, 			final DeweyNumber version) throws Exception;1530798894;Stores given value (value + timestamp) under the given state. It assigns a preceding element_relation to the previous entry.__@param stateName      name of the state that the event should be assigned to_@param eventId        unique id of event assigned by this SharedBuffer_@param previousNodeId id of previous entry (might be null if start of new run)_@param version        Version of the previous relation_@return assigned id of this element_@throws Exception Thrown if the system cannot access the state.;public NodeId put(_			final String stateName,_			final EventId eventId,_			@Nullable final NodeId previousNodeId,_			final DeweyNumber version) throws Exception {__		if (previousNodeId != null) {_			lockNode(previousNodeId)__		}__		NodeId currentNodeId = new NodeId(eventId, getOriginalNameFromInternal(stateName))__		Lockable<SharedBufferNode> currentNode = entries.get(currentNodeId)__		if (currentNode == null) {_			currentNode = new Lockable<>(new SharedBufferNode(), 0)__			lockEvent(eventId)__		}__		currentNode.getElement().addEdge(new SharedBufferEdge(_			previousNodeId,_			version))__		entries.put(currentNodeId, currentNode)___		return currentNodeId__	};stores,given,value,value,timestamp,under,the,given,state,it,assigns,a,preceding,element,relation,to,the,previous,entry,param,state,name,name,of,the,state,that,the,event,should,be,assigned,to,param,event,id,unique,id,of,event,assigned,by,this,shared,buffer,param,previous,node,id,id,of,previous,entry,might,be,null,if,start,of,new,run,param,version,version,of,the,previous,relation,return,assigned,id,of,this,element,throws,exception,thrown,if,the,system,cannot,access,the,state;public,node,id,put,final,string,state,name,final,event,id,event,id,nullable,final,node,id,previous,node,id,final,dewey,number,version,throws,exception,if,previous,node,id,null,lock,node,previous,node,id,node,id,current,node,id,new,node,id,event,id,get,original,name,from,internal,state,name,lockable,shared,buffer,node,current,node,entries,get,current,node,id,if,current,node,null,current,node,new,lockable,new,shared,buffer,node,0,lock,event,event,id,current,node,get,element,add,edge,new,shared,buffer,edge,previous,node,id,version,entries,put,current,node,id,current,node,return,current,node,id
SharedBuffer -> public boolean isEmpty() throws Exception;1528894799;Checks if there is no elements in the buffer.__@return true if there is no elements in the buffer_@throws Exception Thrown if the system cannot access the state.;public boolean isEmpty() throws Exception {_		return Iterables.isEmpty(eventsBuffer.keys())__	};checks,if,there,is,no,elements,in,the,buffer,return,true,if,there,is,no,elements,in,the,buffer,throws,exception,thrown,if,the,system,cannot,access,the,state;public,boolean,is,empty,throws,exception,return,iterables,is,empty,events,buffer,keys
SharedBuffer -> public boolean isEmpty() throws Exception;1528894799;Checks if there is no elements in the buffer.__@return true if there is no elements in the buffer_@throws Exception Thrown if the system cannot access the state.;public boolean isEmpty() throws Exception {_		return Iterables.isEmpty(eventsBuffer.keys())__	};checks,if,there,is,no,elements,in,the,buffer,return,true,if,there,is,no,elements,in,the,buffer,throws,exception,thrown,if,the,system,cannot,access,the,state;public,boolean,is,empty,throws,exception,return,iterables,is,empty,events,buffer,keys
SharedBuffer -> public boolean isEmpty() throws Exception;1530798894;Checks if there is no elements in the buffer.__@return true if there is no elements in the buffer_@throws Exception Thrown if the system cannot access the state.;public boolean isEmpty() throws Exception {_		return Iterables.isEmpty(eventsBuffer.keys())__	};checks,if,there,is,no,elements,in,the,buffer,return,true,if,there,is,no,elements,in,the,buffer,throws,exception,thrown,if,the,system,cannot,access,the,state;public,boolean,is,empty,throws,exception,return,iterables,is,empty,events,buffer,keys
SharedBuffer -> public boolean isEmpty() throws Exception;1535555335;Checks if there is no elements in the buffer.__@return true if there is no elements in the buffer_@throws Exception Thrown if the system cannot access the state.;public boolean isEmpty() throws Exception {_		return Iterables.isEmpty(eventsBufferCache.keySet()) && Iterables.isEmpty(eventsBuffer.keys())__	};checks,if,there,is,no,elements,in,the,buffer,return,true,if,there,is,no,elements,in,the,buffer,throws,exception,thrown,if,the,system,cannot,access,the,state;public,boolean,is,empty,throws,exception,return,iterables,is,empty,events,buffer,cache,key,set,iterables,is,empty,events,buffer,keys
SharedBuffer -> public boolean isEmpty() throws Exception;1548235180;Checks if there is no elements in the buffer.__@return true if there is no elements in the buffer_@throws Exception Thrown if the system cannot access the state.;public boolean isEmpty() throws Exception {_		return Iterables.isEmpty(eventsBufferCache.keySet()) && Iterables.isEmpty(eventsBuffer.keys())__	};checks,if,there,is,no,elements,in,the,buffer,return,true,if,there,is,no,elements,in,the,buffer,throws,exception,thrown,if,the,system,cannot,access,the,state;public,boolean,is,empty,throws,exception,return,iterables,is,empty,events,buffer,cache,key,set,iterables,is,empty,events,buffer,keys
SharedBuffer -> Lockable<SharedBufferNode> getEntry(NodeId nodeId);1535555335;It always returns node either from state or cache.__@param nodeId id of the node_@return SharedBufferNode;Lockable<SharedBufferNode> getEntry(NodeId nodeId) {_		return entryCache.computeIfAbsent(nodeId, id -> {_			try {_				return entries.get(id)__			} catch (Exception ex) {_				throw new WrappingRuntimeException(ex)__			}_		})__	};it,always,returns,node,either,from,state,or,cache,param,node,id,id,of,the,node,return,shared,buffer,node;lockable,shared,buffer,node,get,entry,node,id,node,id,return,entry,cache,compute,if,absent,node,id,id,try,return,entries,get,id,catch,exception,ex,throw,new,wrapping,runtime,exception,ex
SharedBuffer -> Lockable<SharedBufferNode> getEntry(NodeId nodeId);1548235180;It always returns node either from state or cache.__@param nodeId id of the node_@return SharedBufferNode;Lockable<SharedBufferNode> getEntry(NodeId nodeId) {_		return entryCache.computeIfAbsent(nodeId, id -> {_			try {_				return entries.get(id)__			} catch (Exception ex) {_				throw new WrappingRuntimeException(ex)__			}_		})__	};it,always,returns,node,either,from,state,or,cache,param,node,id,id,of,the,node,return,shared,buffer,node;lockable,shared,buffer,node,get,entry,node,id,node,id,return,entry,cache,compute,if,absent,node,id,id,try,return,entries,get,id,catch,exception,ex,throw,new,wrapping,runtime,exception,ex
SharedBuffer -> @Deprecated 	public void init( 			Map<EventId, Lockable<V>> events, 			Map<NodeId, Lockable<SharedBufferNode>> entries) throws Exception;1528894799;Initializes underlying state with given map of events and entries. Should be used only in case of migration from_old state.__@param events  map of events with assigned unique ids_@param entries map of SharedBufferNodes_@throws Exception Thrown if the system cannot access the state._@deprecated Only for state migration!;@Deprecated_	public void init(_			Map<EventId, Lockable<V>> events,_			Map<NodeId, Lockable<SharedBufferNode>> entries) throws Exception {_		eventsBuffer.putAll(events)__		pages.putAll(entries)___		Map<Long, Long> maxIds = events.keySet().stream().collect(Collectors.toMap(_			EventId::getTimestamp,_			EventId::getId,_			Math::max_		))__		eventsCount.putAll(maxIds)__	};initializes,underlying,state,with,given,map,of,events,and,entries,should,be,used,only,in,case,of,migration,from,old,state,param,events,map,of,events,with,assigned,unique,ids,param,entries,map,of,shared,buffer,nodes,throws,exception,thrown,if,the,system,cannot,access,the,state,deprecated,only,for,state,migration;deprecated,public,void,init,map,event,id,lockable,v,events,map,node,id,lockable,shared,buffer,node,entries,throws,exception,events,buffer,put,all,events,pages,put,all,entries,map,long,long,max,ids,events,key,set,stream,collect,collectors,to,map,event,id,get,timestamp,event,id,get,id,math,max,events,count,put,all,max,ids
SharedBuffer -> @Deprecated 	public void init( 			Map<EventId, Lockable<V>> events, 			Map<NodeId, Lockable<SharedBufferNode>> entries) throws Exception;1528894799;Initializes underlying state with given map of events and entries. Should be used only in case of migration from_old state.__@param events  map of events with assigned unique ids_@param entries map of SharedBufferNodes_@throws Exception Thrown if the system cannot access the state._@deprecated Only for state migration!;@Deprecated_	public void init(_			Map<EventId, Lockable<V>> events,_			Map<NodeId, Lockable<SharedBufferNode>> entries) throws Exception {_		eventsBuffer.putAll(events)__		this.entries.putAll(entries)___		Map<Long, Integer> maxIds = events.keySet().stream().collect(Collectors.toMap(_			EventId::getTimestamp,_			EventId::getId,_			Math::max_		))__		eventsCount.putAll(maxIds)__	};initializes,underlying,state,with,given,map,of,events,and,entries,should,be,used,only,in,case,of,migration,from,old,state,param,events,map,of,events,with,assigned,unique,ids,param,entries,map,of,shared,buffer,nodes,throws,exception,thrown,if,the,system,cannot,access,the,state,deprecated,only,for,state,migration;deprecated,public,void,init,map,event,id,lockable,v,events,map,node,id,lockable,shared,buffer,node,entries,throws,exception,events,buffer,put,all,events,this,entries,put,all,entries,map,long,integer,max,ids,events,key,set,stream,collect,collectors,to,map,event,id,get,timestamp,event,id,get,id,math,max,events,count,put,all,max,ids
SharedBuffer -> @Deprecated 	public void init( 			Map<EventId, Lockable<V>> events, 			Map<NodeId, Lockable<SharedBufferNode>> entries) throws Exception;1530798894;Initializes underlying state with given map of events and entries. Should be used only in case of migration from_old state.__@param events  map of events with assigned unique ids_@param entries map of SharedBufferNodes_@throws Exception Thrown if the system cannot access the state._@deprecated Only for state migration!;@Deprecated_	public void init(_			Map<EventId, Lockable<V>> events,_			Map<NodeId, Lockable<SharedBufferNode>> entries) throws Exception {_		eventsBuffer.putAll(events)__		this.entries.putAll(entries)___		Map<Long, Integer> maxIds = events.keySet().stream().collect(Collectors.toMap(_			EventId::getTimestamp,_			EventId::getId,_			Math::max_		))__		eventsCount.putAll(maxIds)__	};initializes,underlying,state,with,given,map,of,events,and,entries,should,be,used,only,in,case,of,migration,from,old,state,param,events,map,of,events,with,assigned,unique,ids,param,entries,map,of,shared,buffer,nodes,throws,exception,thrown,if,the,system,cannot,access,the,state,deprecated,only,for,state,migration;deprecated,public,void,init,map,event,id,lockable,v,events,map,node,id,lockable,shared,buffer,node,entries,throws,exception,events,buffer,put,all,events,this,entries,put,all,entries,map,long,integer,max,ids,events,key,set,stream,collect,collectors,to,map,event,id,get,timestamp,event,id,get,id,math,max,events,count,put,all,max,ids
SharedBuffer -> @Deprecated 	public void init( 			Map<EventId, Lockable<V>> events, 			Map<NodeId, Lockable<SharedBufferNode>> entries) throws Exception;1535555335;Initializes underlying state with given map of events and entries. Should be used only in case of migration from_old state.__@param events  map of events with assigned unique ids_@param entries map of SharedBufferNodes_@throws Exception Thrown if the system cannot access the state._@deprecated Only for state migration!;@Deprecated_	public void init(_			Map<EventId, Lockable<V>> events,_			Map<NodeId, Lockable<SharedBufferNode>> entries) throws Exception {_		eventsBuffer.putAll(events)__		this.entries.putAll(entries)___		Map<Long, Integer> maxIds = events.keySet().stream().collect(Collectors.toMap(_			EventId::getTimestamp,_			EventId::getId,_			Math::max_		))__		eventsCount.putAll(maxIds)__	};initializes,underlying,state,with,given,map,of,events,and,entries,should,be,used,only,in,case,of,migration,from,old,state,param,events,map,of,events,with,assigned,unique,ids,param,entries,map,of,shared,buffer,nodes,throws,exception,thrown,if,the,system,cannot,access,the,state,deprecated,only,for,state,migration;deprecated,public,void,init,map,event,id,lockable,v,events,map,node,id,lockable,shared,buffer,node,entries,throws,exception,events,buffer,put,all,events,this,entries,put,all,entries,map,long,integer,max,ids,events,key,set,stream,collect,collectors,to,map,event,id,get,timestamp,event,id,get,id,math,max,events,count,put,all,max,ids
SharedBuffer -> @Deprecated 	public void init( 			Map<EventId, Lockable<V>> events, 			Map<NodeId, Lockable<SharedBufferNode>> entries) throws Exception;1548235180;Initializes underlying state with given map of events and entries. Should be used only in case of migration from_old state.__@param events  map of events with assigned unique ids_@param entries map of SharedBufferNodes_@throws Exception Thrown if the system cannot access the state._@deprecated Only for state migration!;@Deprecated_	public void init(_			Map<EventId, Lockable<V>> events,_			Map<NodeId, Lockable<SharedBufferNode>> entries) throws Exception {_		eventsBuffer.putAll(events)__		this.entries.putAll(entries)___		Map<Long, Integer> maxIds = events.keySet().stream().collect(Collectors.toMap(_			EventId::getTimestamp,_			EventId::getId,_			Math::max_		))__		eventsCount.putAll(maxIds)__	};initializes,underlying,state,with,given,map,of,events,and,entries,should,be,used,only,in,case,of,migration,from,old,state,param,events,map,of,events,with,assigned,unique,ids,param,entries,map,of,shared,buffer,nodes,throws,exception,thrown,if,the,system,cannot,access,the,state,deprecated,only,for,state,migration;deprecated,public,void,init,map,event,id,lockable,v,events,map,node,id,lockable,shared,buffer,node,entries,throws,exception,events,buffer,put,all,events,this,entries,put,all,entries,map,long,integer,max,ids,events,key,set,stream,collect,collectors,to,map,event,id,get,timestamp,event,id,get,id,math,max,events,count,put,all,max,ids
SharedBuffer -> public void lockNode(final NodeId node) throws Exception;1528894799;Increases the reference counter for the given entry so that it is not_accidentally removed.__@param node id of the entry_@throws Exception Thrown if the system cannot access the state.;public void lockNode(final NodeId node) throws Exception {_		Lockable<SharedBufferNode> sharedBufferNode = pages.get(node)__		if (sharedBufferNode != null) {_			sharedBufferNode.lock()__			pages.put(node, sharedBufferNode)__		}_	};increases,the,reference,counter,for,the,given,entry,so,that,it,is,not,accidentally,removed,param,node,id,of,the,entry,throws,exception,thrown,if,the,system,cannot,access,the,state;public,void,lock,node,final,node,id,node,throws,exception,lockable,shared,buffer,node,shared,buffer,node,pages,get,node,if,shared,buffer,node,null,shared,buffer,node,lock,pages,put,node,shared,buffer,node
SharedBuffer -> public void lockNode(final NodeId node) throws Exception;1528894799;Increases the reference counter for the given entry so that it is not_accidentally removed.__@param node id of the entry_@throws Exception Thrown if the system cannot access the state.;public void lockNode(final NodeId node) throws Exception {_		Lockable<SharedBufferNode> sharedBufferNode = entries.get(node)__		if (sharedBufferNode != null) {_			sharedBufferNode.lock()__			entries.put(node, sharedBufferNode)__		}_	};increases,the,reference,counter,for,the,given,entry,so,that,it,is,not,accidentally,removed,param,node,id,of,the,entry,throws,exception,thrown,if,the,system,cannot,access,the,state;public,void,lock,node,final,node,id,node,throws,exception,lockable,shared,buffer,node,shared,buffer,node,entries,get,node,if,shared,buffer,node,null,shared,buffer,node,lock,entries,put,node,shared,buffer,node
SharedBuffer -> public void lockNode(final NodeId node) throws Exception;1530798894;Increases the reference counter for the given entry so that it is not_accidentally removed.__@param node id of the entry_@throws Exception Thrown if the system cannot access the state.;public void lockNode(final NodeId node) throws Exception {_		Lockable<SharedBufferNode> sharedBufferNode = entries.get(node)__		if (sharedBufferNode != null) {_			sharedBufferNode.lock()__			entries.put(node, sharedBufferNode)__		}_	};increases,the,reference,counter,for,the,given,entry,so,that,it,is,not,accidentally,removed,param,node,id,of,the,entry,throws,exception,thrown,if,the,system,cannot,access,the,state;public,void,lock,node,final,node,id,node,throws,exception,lockable,shared,buffer,node,shared,buffer,node,entries,get,node,if,shared,buffer,node,null,shared,buffer,node,lock,entries,put,node,shared,buffer,node
SharedBuffer -> void flushCache() throws Exception;1535555335;Flush the event and node from cache to state.__@throws Exception Thrown if the system cannot access the state.;void flushCache() throws Exception {_		if (!entryCache.isEmpty()) {_			entries.putAll(entryCache)__			entryCache.clear()__		}_		if (!eventsBufferCache.isEmpty()) {_			eventsBuffer.putAll(eventsBufferCache)__			eventsBufferCache.clear()__		}_	};flush,the,event,and,node,from,cache,to,state,throws,exception,thrown,if,the,system,cannot,access,the,state;void,flush,cache,throws,exception,if,entry,cache,is,empty,entries,put,all,entry,cache,entry,cache,clear,if,events,buffer,cache,is,empty,events,buffer,put,all,events,buffer,cache,events,buffer,cache,clear
SharedBuffer -> void flushCache() throws Exception;1548235180;Flush the event and node from cache to state.__@throws Exception Thrown if the system cannot access the state.;void flushCache() throws Exception {_		if (!entryCache.isEmpty()) {_			entries.putAll(entryCache)__			entryCache.clear()__		}_		if (!eventsBufferCache.isEmpty()) {_			eventsBuffer.putAll(eventsBufferCache)__			eventsBufferCache.clear()__		}_	};flush,the,event,and,node,from,cache,to,state,throws,exception,thrown,if,the,system,cannot,access,the,state;void,flush,cache,throws,exception,if,entry,cache,is,empty,entries,put,all,entry,cache,entry,cache,clear,if,events,buffer,cache,is,empty,events,buffer,put,all,events,buffer,cache,events,buffer,cache,clear
SharedBuffer -> void removeEvent(EventId eventId) throws Exception;1535555335;Removes an event from cache and state.__@param eventId id of the event;void removeEvent(EventId eventId) throws Exception {_		this.eventsBufferCache.remove(eventId)__		this.eventsBuffer.remove(eventId)__	};removes,an,event,from,cache,and,state,param,event,id,id,of,the,event;void,remove,event,event,id,event,id,throws,exception,this,events,buffer,cache,remove,event,id,this,events,buffer,remove,event,id
SharedBuffer -> void removeEvent(EventId eventId) throws Exception;1548235180;Removes an event from cache and state.__@param eventId id of the event;void removeEvent(EventId eventId) throws Exception {_		this.eventsBufferCache.remove(eventId)__		this.eventsBuffer.remove(eventId)__	};removes,an,event,from,cache,and,state,param,event,id,id,of,the,event;void,remove,event,event,id,event,id,throws,exception,this,events,buffer,cache,remove,event,id,this,events,buffer,remove,event,id
SharedBuffer -> Lockable<V> getEvent(EventId eventId);1535555335;It always returns event either from state or cache.__@param eventId id of the event_@return event;Lockable<V> getEvent(EventId eventId) {_		return eventsBufferCache.computeIfAbsent(eventId, id -> {_			try {_				return eventsBuffer.get(id)__			} catch (Exception ex) {_				throw new WrappingRuntimeException(ex)__			}_		})__	};it,always,returns,event,either,from,state,or,cache,param,event,id,id,of,the,event,return,event;lockable,v,get,event,event,id,event,id,return,events,buffer,cache,compute,if,absent,event,id,id,try,return,events,buffer,get,id,catch,exception,ex,throw,new,wrapping,runtime,exception,ex
SharedBuffer -> Lockable<V> getEvent(EventId eventId);1548235180;It always returns event either from state or cache.__@param eventId id of the event_@return event;Lockable<V> getEvent(EventId eventId) {_		return eventsBufferCache.computeIfAbsent(eventId, id -> {_			try {_				return eventsBuffer.get(id)__			} catch (Exception ex) {_				throw new WrappingRuntimeException(ex)__			}_		})__	};it,always,returns,event,either,from,state,or,cache,param,event,id,id,of,the,event,return,event;lockable,v,get,event,event,id,event,id,return,events,buffer,cache,compute,if,absent,event,id,id,try,return,events,buffer,get,id,catch,exception,ex,throw,new,wrapping,runtime,exception,ex
SharedBuffer -> public void advanceTime(long timestamp) throws Exception;1528894799;Notifies shared buffer that there will be no events with timestamp &lt_&eq_ the given value. I allows to clear_internal counters for number of events seen so far per timestamp.__@param timestamp watermark, no earlier events will arrive_@throws Exception Thrown if the system cannot access the state.;public void advanceTime(long timestamp) throws Exception {_		Iterator<Long> iterator = eventsCount.keys().iterator()__		while (iterator.hasNext()) {_			Long next = iterator.next()__			if (next < timestamp) {_				iterator.remove()__			}_		}_	};notifies,shared,buffer,that,there,will,be,no,events,with,timestamp,lt,eq,the,given,value,i,allows,to,clear,internal,counters,for,number,of,events,seen,so,far,per,timestamp,param,timestamp,watermark,no,earlier,events,will,arrive,throws,exception,thrown,if,the,system,cannot,access,the,state;public,void,advance,time,long,timestamp,throws,exception,iterator,long,iterator,events,count,keys,iterator,while,iterator,has,next,long,next,iterator,next,if,next,timestamp,iterator,remove
SharedBuffer -> public void advanceTime(long timestamp) throws Exception;1530798894;Notifies shared buffer that there will be no events with timestamp &lt_&eq_ the given value. I allows to clear_internal counters for number of events seen so far per timestamp.__@param timestamp watermark, no earlier events will arrive_@throws Exception Thrown if the system cannot access the state.;public void advanceTime(long timestamp) throws Exception {_		Iterator<Long> iterator = eventsCount.keys().iterator()__		while (iterator.hasNext()) {_			Long next = iterator.next()__			if (next < timestamp) {_				iterator.remove()__			}_		}_	};notifies,shared,buffer,that,there,will,be,no,events,with,timestamp,lt,eq,the,given,value,i,allows,to,clear,internal,counters,for,number,of,events,seen,so,far,per,timestamp,param,timestamp,watermark,no,earlier,events,will,arrive,throws,exception,thrown,if,the,system,cannot,access,the,state;public,void,advance,time,long,timestamp,throws,exception,iterator,long,iterator,events,count,keys,iterator,while,iterator,has,next,long,next,iterator,next,if,next,timestamp,iterator,remove
SharedBuffer -> void removeEntry(NodeId nodeId) throws Exception;1535555335;Removes a ShareBufferNode from cache and state.__@param nodeId id of the event;void removeEntry(NodeId nodeId) throws Exception {_		this.entryCache.remove(nodeId)__		this.entries.remove(nodeId)__	};removes,a,share,buffer,node,from,cache,and,state,param,node,id,id,of,the,event;void,remove,entry,node,id,node,id,throws,exception,this,entry,cache,remove,node,id,this,entries,remove,node,id
SharedBuffer -> void removeEntry(NodeId nodeId) throws Exception;1548235180;Removes a ShareBufferNode from cache and state.__@param nodeId id of the event;void removeEntry(NodeId nodeId) throws Exception {_		this.entryCache.remove(nodeId)__		this.entries.remove(nodeId)__	};removes,a,share,buffer,node,from,cache,and,state,param,node,id,id,of,the,event;void,remove,entry,node,id,node,id,throws,exception,this,entry,cache,remove,node,id,this,entries,remove,node,id
SharedBuffer -> public EventId registerEvent(V value, long timestamp) throws Exception;1528894799;Adds another unique event to the shared buffer and assigns a unique id for it. It automatically creates a_lock on this event, so it won't be removed during processing of that event. Therefore the lock should be removed_after processing all {@link org.apache.flink.cep.nfa.ComputationState}s__<p><b>NOTE:</b>Should be called only once for each unique event!__@param value event to be registered_@return unique id of that event that should be used when putting entries to the buffer._@throws Exception Thrown if the system cannot access the state.;public EventId registerEvent(V value, long timestamp) throws Exception {_		Long id = eventsCount.get(timestamp)__		if (id == null) {_			id = 0L__		}__		EventId eventId = new EventId(id, timestamp)__		eventsBuffer.put(eventId, new Lockable<>(value, 1))__		eventsCount.put(timestamp, id + 1L)__		return eventId__	};adds,another,unique,event,to,the,shared,buffer,and,assigns,a,unique,id,for,it,it,automatically,creates,a,lock,on,this,event,so,it,won,t,be,removed,during,processing,of,that,event,therefore,the,lock,should,be,removed,after,processing,all,link,org,apache,flink,cep,nfa,computation,state,s,p,b,note,b,should,be,called,only,once,for,each,unique,event,param,value,event,to,be,registered,return,unique,id,of,that,event,that,should,be,used,when,putting,entries,to,the,buffer,throws,exception,thrown,if,the,system,cannot,access,the,state;public,event,id,register,event,v,value,long,timestamp,throws,exception,long,id,events,count,get,timestamp,if,id,null,id,0l,event,id,event,id,new,event,id,id,timestamp,events,buffer,put,event,id,new,lockable,value,1,events,count,put,timestamp,id,1l,return,event,id
SharedBuffer -> public EventId registerEvent(V value, long timestamp) throws Exception;1528894799;Adds another unique event to the shared buffer and assigns a unique id for it. It automatically creates a_lock on this event, so it won't be removed during processing of that event. Therefore the lock should be removed_after processing all {@link org.apache.flink.cep.nfa.ComputationState}s__<p><b>NOTE:</b>Should be called only once for each unique event!__@param value event to be registered_@return unique id of that event that should be used when putting entries to the buffer._@throws Exception Thrown if the system cannot access the state.;public EventId registerEvent(V value, long timestamp) throws Exception {_		Integer id = eventsCount.get(timestamp)__		if (id == null) {_			id = 0__		}__		EventId eventId = new EventId(id, timestamp)__		eventsBuffer.put(eventId, new Lockable<>(value, 1))__		eventsCount.put(timestamp, id + 1)__		return eventId__	};adds,another,unique,event,to,the,shared,buffer,and,assigns,a,unique,id,for,it,it,automatically,creates,a,lock,on,this,event,so,it,won,t,be,removed,during,processing,of,that,event,therefore,the,lock,should,be,removed,after,processing,all,link,org,apache,flink,cep,nfa,computation,state,s,p,b,note,b,should,be,called,only,once,for,each,unique,event,param,value,event,to,be,registered,return,unique,id,of,that,event,that,should,be,used,when,putting,entries,to,the,buffer,throws,exception,thrown,if,the,system,cannot,access,the,state;public,event,id,register,event,v,value,long,timestamp,throws,exception,integer,id,events,count,get,timestamp,if,id,null,id,0,event,id,event,id,new,event,id,id,timestamp,events,buffer,put,event,id,new,lockable,value,1,events,count,put,timestamp,id,1,return,event,id
SharedBuffer -> public EventId registerEvent(V value, long timestamp) throws Exception;1530798894;Adds another unique event to the shared buffer and assigns a unique id for it. It automatically creates a_lock on this event, so it won't be removed during processing of that event. Therefore the lock should be removed_after processing all {@link org.apache.flink.cep.nfa.ComputationState}s__<p><b>NOTE:</b>Should be called only once for each unique event!__@param value event to be registered_@return unique id of that event that should be used when putting entries to the buffer._@throws Exception Thrown if the system cannot access the state.;public EventId registerEvent(V value, long timestamp) throws Exception {_		Integer id = eventsCount.get(timestamp)__		if (id == null) {_			id = 0__		}__		EventId eventId = new EventId(id, timestamp)__		eventsBuffer.put(eventId, new Lockable<>(value, 1))__		eventsCount.put(timestamp, id + 1)__		return eventId__	};adds,another,unique,event,to,the,shared,buffer,and,assigns,a,unique,id,for,it,it,automatically,creates,a,lock,on,this,event,so,it,won,t,be,removed,during,processing,of,that,event,therefore,the,lock,should,be,removed,after,processing,all,link,org,apache,flink,cep,nfa,computation,state,s,p,b,note,b,should,be,called,only,once,for,each,unique,event,param,value,event,to,be,registered,return,unique,id,of,that,event,that,should,be,used,when,putting,entries,to,the,buffer,throws,exception,thrown,if,the,system,cannot,access,the,state;public,event,id,register,event,v,value,long,timestamp,throws,exception,integer,id,events,count,get,timestamp,if,id,null,id,0,event,id,event,id,new,event,id,id,timestamp,events,buffer,put,event,id,new,lockable,value,1,events,count,put,timestamp,id,1,return,event,id
SharedBuffer -> public void releaseEvent(EventId eventId) throws Exception;1528894799;Decreases the reference counter for the given event so that it can be_removed once the reference counter reaches 0.__@param eventId id of the event_@throws Exception Thrown if the system cannot access the state.;public void releaseEvent(EventId eventId) throws Exception {_		Lockable<V> eventWrapper = eventsBuffer.get(eventId)__		if (eventWrapper != null) {_			if (eventWrapper.release()) {_				eventsBuffer.remove(eventId)__			} else {_				eventsBuffer.put(eventId, eventWrapper)__			}_		}_	};decreases,the,reference,counter,for,the,given,event,so,that,it,can,be,removed,once,the,reference,counter,reaches,0,param,event,id,id,of,the,event,throws,exception,thrown,if,the,system,cannot,access,the,state;public,void,release,event,event,id,event,id,throws,exception,lockable,v,event,wrapper,events,buffer,get,event,id,if,event,wrapper,null,if,event,wrapper,release,events,buffer,remove,event,id,else,events,buffer,put,event,id,event,wrapper
SharedBuffer -> public void releaseEvent(EventId eventId) throws Exception;1528894799;Decreases the reference counter for the given event so that it can be_removed once the reference counter reaches 0.__@param eventId id of the event_@throws Exception Thrown if the system cannot access the state.;public void releaseEvent(EventId eventId) throws Exception {_		Lockable<V> eventWrapper = eventsBuffer.get(eventId)__		if (eventWrapper != null) {_			if (eventWrapper.release()) {_				eventsBuffer.remove(eventId)__			} else {_				eventsBuffer.put(eventId, eventWrapper)__			}_		}_	};decreases,the,reference,counter,for,the,given,event,so,that,it,can,be,removed,once,the,reference,counter,reaches,0,param,event,id,id,of,the,event,throws,exception,thrown,if,the,system,cannot,access,the,state;public,void,release,event,event,id,event,id,throws,exception,lockable,v,event,wrapper,events,buffer,get,event,id,if,event,wrapper,null,if,event,wrapper,release,events,buffer,remove,event,id,else,events,buffer,put,event,id,event,wrapper
SharedBuffer -> public void releaseEvent(EventId eventId) throws Exception;1530798894;Decreases the reference counter for the given event so that it can be_removed once the reference counter reaches 0.__@param eventId id of the event_@throws Exception Thrown if the system cannot access the state.;public void releaseEvent(EventId eventId) throws Exception {_		Lockable<V> eventWrapper = eventsBuffer.get(eventId)__		if (eventWrapper != null) {_			if (eventWrapper.release()) {_				eventsBuffer.remove(eventId)__			} else {_				eventsBuffer.put(eventId, eventWrapper)__			}_		}_	};decreases,the,reference,counter,for,the,given,event,so,that,it,can,be,removed,once,the,reference,counter,reaches,0,param,event,id,id,of,the,event,throws,exception,thrown,if,the,system,cannot,access,the,state;public,void,release,event,event,id,event,id,throws,exception,lockable,v,event,wrapper,events,buffer,get,event,id,if,event,wrapper,null,if,event,wrapper,release,events,buffer,remove,event,id,else,events,buffer,put,event,id,event,wrapper
SharedBuffer -> public SharedBufferAccessor<V> getAccessor();1535555335;Construct an accessor to deal with this sharedBuffer.__@return an accessor to deal with this sharedBuffer.;public SharedBufferAccessor<V> getAccessor() {_		return new SharedBufferAccessor<>(this)__	};construct,an,accessor,to,deal,with,this,shared,buffer,return,an,accessor,to,deal,with,this,shared,buffer;public,shared,buffer,accessor,v,get,accessor,return,new,shared,buffer,accessor,this
SharedBuffer -> public SharedBufferAccessor<V> getAccessor();1548235180;Construct an accessor to deal with this sharedBuffer.__@return an accessor to deal with this sharedBuffer.;public SharedBufferAccessor<V> getAccessor() {_		return new SharedBufferAccessor<>(this)__	};construct,an,accessor,to,deal,with,this,shared,buffer,return,an,accessor,to,deal,with,this,shared,buffer;public,shared,buffer,accessor,v,get,accessor,return,new,shared,buffer,accessor,this
SharedBuffer -> void upsertEntry(NodeId nodeId, Lockable<SharedBufferNode> entry);1535555335;Inserts or updates a shareBufferNode in cache.__@param nodeId id of the event_@param entry SharedBufferNode;void upsertEntry(NodeId nodeId, Lockable<SharedBufferNode> entry) {_		this.entryCache.put(nodeId, entry)__	};inserts,or,updates,a,share,buffer,node,in,cache,param,node,id,id,of,the,event,param,entry,shared,buffer,node;void,upsert,entry,node,id,node,id,lockable,shared,buffer,node,entry,this,entry,cache,put,node,id,entry
SharedBuffer -> void upsertEntry(NodeId nodeId, Lockable<SharedBufferNode> entry);1548235180;Inserts or updates a shareBufferNode in cache.__@param nodeId id of the event_@param entry SharedBufferNode;void upsertEntry(NodeId nodeId, Lockable<SharedBufferNode> entry) {_		this.entryCache.put(nodeId, entry)__	};inserts,or,updates,a,share,buffer,node,in,cache,param,node,id,id,of,the,event,param,entry,shared,buffer,node;void,upsert,entry,node,id,node,id,lockable,shared,buffer,node,entry,this,entry,cache,put,node,id,entry
SharedBuffer -> void upsertEvent(EventId eventId, Lockable<V> event);1535555335;Inserts or updates an event in cache.__@param eventId id of the event_@param event event body;void upsertEvent(EventId eventId, Lockable<V> event) {_		this.eventsBufferCache.put(eventId, event)__	};inserts,or,updates,an,event,in,cache,param,event,id,id,of,the,event,param,event,event,body;void,upsert,event,event,id,event,id,lockable,v,event,this,events,buffer,cache,put,event,id,event
SharedBuffer -> void upsertEvent(EventId eventId, Lockable<V> event);1548235180;Inserts or updates an event in cache.__@param eventId id of the event_@param event event body;void upsertEvent(EventId eventId, Lockable<V> event) {_		this.eventsBufferCache.put(eventId, event)__	};inserts,or,updates,an,event,in,cache,param,event,id,id,of,the,event,param,event,event,body;void,upsert,event,event,id,event,id,lockable,v,event,this,events,buffer,cache,put,event,id,event
SharedBuffer -> public List<Map<String, List<V>>> extractPatterns( 			final NodeId nodeId, 			final DeweyNumber version) throws Exception;1528894799;Returns all elements from the previous relation starting at the given entry.__@param nodeId  id of the starting entry_@param version Version of the previous relation which shall be extracted_@return Collection of previous relations starting with the given value_@throws Exception Thrown if the system cannot access the state.;public List<Map<String, List<V>>> extractPatterns(_			final NodeId nodeId,_			final DeweyNumber version) throws Exception {__		List<Map<String, List<V>>> result = new ArrayList<>()___		_		Stack<ExtractionState> extractionStates = new Stack<>()___		_		Lockable<SharedBufferNode> entryLock = pages.get(nodeId)___		if (entryLock != null) {_			SharedBufferNode entry = entryLock.getElement()__			extractionStates.add(new ExtractionState(Tuple2.of(nodeId, entry), version, new Stack<>()))___			_			while (!extractionStates.isEmpty()) {_				final ExtractionState extractionState = extractionStates.pop()__				_				final Stack<Tuple2<NodeId, SharedBufferNode>> currentPath = extractionState.getPath()__				final Tuple2<NodeId, SharedBufferNode> currentEntry = extractionState.getEntry()___				_				if (currentEntry == null) {_					final Map<String, List<V>> completePath = new LinkedHashMap<>()___					while (!currentPath.isEmpty()) {_						final NodeId currentPathEntry = currentPath.pop().f0___						String page = currentPathEntry.getPageName()__						List<V> values = completePath_							.computeIfAbsent(page, k -> new ArrayList<>())__						values.add(eventsBuffer.get(currentPathEntry.getEventId()).getElement())__					}_					result.add(completePath)__				} else {__					_					currentPath.push(currentEntry)___					boolean firstMatch = true__					for (SharedBufferEdge edge : currentEntry.f1.getEdges()) {_						_						_						final DeweyNumber currentVersion = extractionState.getVersion()__						if (currentVersion.isCompatibleWith(edge.getDeweyNumber())) {_							final NodeId target = edge.getTarget()__							Stack<Tuple2<NodeId, SharedBufferNode>> newPath___							if (firstMatch) {_								_								newPath = currentPath__								firstMatch = false__							} else {_								newPath = new Stack<>()__								newPath.addAll(currentPath)__							}__							extractionStates.push(new ExtractionState(_								target != null ? Tuple2.of(target, pages.get(target).getElement()) : null,_								edge.getDeweyNumber(),_								newPath))__						}_					}_				}__			}_		}_		return result__	};returns,all,elements,from,the,previous,relation,starting,at,the,given,entry,param,node,id,id,of,the,starting,entry,param,version,version,of,the,previous,relation,which,shall,be,extracted,return,collection,of,previous,relations,starting,with,the,given,value,throws,exception,thrown,if,the,system,cannot,access,the,state;public,list,map,string,list,v,extract,patterns,final,node,id,node,id,final,dewey,number,version,throws,exception,list,map,string,list,v,result,new,array,list,stack,extraction,state,extraction,states,new,stack,lockable,shared,buffer,node,entry,lock,pages,get,node,id,if,entry,lock,null,shared,buffer,node,entry,entry,lock,get,element,extraction,states,add,new,extraction,state,tuple2,of,node,id,entry,version,new,stack,while,extraction,states,is,empty,final,extraction,state,extraction,state,extraction,states,pop,final,stack,tuple2,node,id,shared,buffer,node,current,path,extraction,state,get,path,final,tuple2,node,id,shared,buffer,node,current,entry,extraction,state,get,entry,if,current,entry,null,final,map,string,list,v,complete,path,new,linked,hash,map,while,current,path,is,empty,final,node,id,current,path,entry,current,path,pop,f0,string,page,current,path,entry,get,page,name,list,v,values,complete,path,compute,if,absent,page,k,new,array,list,values,add,events,buffer,get,current,path,entry,get,event,id,get,element,result,add,complete,path,else,current,path,push,current,entry,boolean,first,match,true,for,shared,buffer,edge,edge,current,entry,f1,get,edges,final,dewey,number,current,version,extraction,state,get,version,if,current,version,is,compatible,with,edge,get,dewey,number,final,node,id,target,edge,get,target,stack,tuple2,node,id,shared,buffer,node,new,path,if,first,match,new,path,current,path,first,match,false,else,new,path,new,stack,new,path,add,all,current,path,extraction,states,push,new,extraction,state,target,null,tuple2,of,target,pages,get,target,get,element,null,edge,get,dewey,number,new,path,return,result
SharedBuffer -> public List<Map<String, List<V>>> extractPatterns( 			final NodeId nodeId, 			final DeweyNumber version) throws Exception;1528894799;Returns all elements from the previous relation starting at the given entry.__@param nodeId  id of the starting entry_@param version Version of the previous relation which shall be extracted_@return Collection of previous relations starting with the given value_@throws Exception Thrown if the system cannot access the state.;public List<Map<String, List<V>>> extractPatterns(_			final NodeId nodeId,_			final DeweyNumber version) throws Exception {__		List<Map<String, List<V>>> result = new ArrayList<>()___		_		Stack<ExtractionState> extractionStates = new Stack<>()___		_		Lockable<SharedBufferNode> entryLock = entries.get(nodeId)___		if (entryLock != null) {_			SharedBufferNode entry = entryLock.getElement()__			extractionStates.add(new ExtractionState(Tuple2.of(nodeId, entry), version, new Stack<>()))___			_			while (!extractionStates.isEmpty()) {_				final ExtractionState extractionState = extractionStates.pop()__				_				final Stack<Tuple2<NodeId, SharedBufferNode>> currentPath = extractionState.getPath()__				final Tuple2<NodeId, SharedBufferNode> currentEntry = extractionState.getEntry()___				_				if (currentEntry == null) {_					final Map<String, List<V>> completePath = new LinkedHashMap<>()___					while (!currentPath.isEmpty()) {_						final NodeId currentPathEntry = currentPath.pop().f0___						String page = currentPathEntry.getPageName()__						List<V> values = completePath_							.computeIfAbsent(page, k -> new ArrayList<>())__						values.add(eventsBuffer.get(currentPathEntry.getEventId()).getElement())__					}_					result.add(completePath)__				} else {__					_					currentPath.push(currentEntry)___					boolean firstMatch = true__					for (SharedBufferEdge edge : currentEntry.f1.getEdges()) {_						_						_						final DeweyNumber currentVersion = extractionState.getVersion()__						if (currentVersion.isCompatibleWith(edge.getDeweyNumber())) {_							final NodeId target = edge.getTarget()__							Stack<Tuple2<NodeId, SharedBufferNode>> newPath___							if (firstMatch) {_								_								newPath = currentPath__								firstMatch = false__							} else {_								newPath = new Stack<>()__								newPath.addAll(currentPath)__							}__							extractionStates.push(new ExtractionState(_								target != null ? Tuple2.of(target, entries.get(target).getElement()) : null,_								edge.getDeweyNumber(),_								newPath))__						}_					}_				}__			}_		}_		return result__	};returns,all,elements,from,the,previous,relation,starting,at,the,given,entry,param,node,id,id,of,the,starting,entry,param,version,version,of,the,previous,relation,which,shall,be,extracted,return,collection,of,previous,relations,starting,with,the,given,value,throws,exception,thrown,if,the,system,cannot,access,the,state;public,list,map,string,list,v,extract,patterns,final,node,id,node,id,final,dewey,number,version,throws,exception,list,map,string,list,v,result,new,array,list,stack,extraction,state,extraction,states,new,stack,lockable,shared,buffer,node,entry,lock,entries,get,node,id,if,entry,lock,null,shared,buffer,node,entry,entry,lock,get,element,extraction,states,add,new,extraction,state,tuple2,of,node,id,entry,version,new,stack,while,extraction,states,is,empty,final,extraction,state,extraction,state,extraction,states,pop,final,stack,tuple2,node,id,shared,buffer,node,current,path,extraction,state,get,path,final,tuple2,node,id,shared,buffer,node,current,entry,extraction,state,get,entry,if,current,entry,null,final,map,string,list,v,complete,path,new,linked,hash,map,while,current,path,is,empty,final,node,id,current,path,entry,current,path,pop,f0,string,page,current,path,entry,get,page,name,list,v,values,complete,path,compute,if,absent,page,k,new,array,list,values,add,events,buffer,get,current,path,entry,get,event,id,get,element,result,add,complete,path,else,current,path,push,current,entry,boolean,first,match,true,for,shared,buffer,edge,edge,current,entry,f1,get,edges,final,dewey,number,current,version,extraction,state,get,version,if,current,version,is,compatible,with,edge,get,dewey,number,final,node,id,target,edge,get,target,stack,tuple2,node,id,shared,buffer,node,new,path,if,first,match,new,path,current,path,first,match,false,else,new,path,new,stack,new,path,add,all,current,path,extraction,states,push,new,extraction,state,target,null,tuple2,of,target,entries,get,target,get,element,null,edge,get,dewey,number,new,path,return,result
SharedBuffer -> public void releaseNode(final NodeId node) throws Exception;1528894799;Decreases the reference counter for the given entry so that it can be_removed once the reference counter reaches 0.__@param node id of the entry_@throws Exception Thrown if the system cannot access the state.;public void releaseNode(final NodeId node) throws Exception {_		Lockable<SharedBufferNode> sharedBufferNode = pages.get(node)__		if (sharedBufferNode != null) {_			if (sharedBufferNode.release()) {_				removeNode(node, sharedBufferNode.getElement())__			} else {_				pages.put(node, sharedBufferNode)__			}_		}_	};decreases,the,reference,counter,for,the,given,entry,so,that,it,can,be,removed,once,the,reference,counter,reaches,0,param,node,id,of,the,entry,throws,exception,thrown,if,the,system,cannot,access,the,state;public,void,release,node,final,node,id,node,throws,exception,lockable,shared,buffer,node,shared,buffer,node,pages,get,node,if,shared,buffer,node,null,if,shared,buffer,node,release,remove,node,node,shared,buffer,node,get,element,else,pages,put,node,shared,buffer,node
SharedBuffer -> public void releaseNode(final NodeId node) throws Exception;1528894799;Decreases the reference counter for the given entry so that it can be_removed once the reference counter reaches 0.__@param node id of the entry_@throws Exception Thrown if the system cannot access the state.;public void releaseNode(final NodeId node) throws Exception {_		Lockable<SharedBufferNode> sharedBufferNode = entries.get(node)__		if (sharedBufferNode != null) {_			if (sharedBufferNode.release()) {_				removeNode(node, sharedBufferNode.getElement())__			} else {_				entries.put(node, sharedBufferNode)__			}_		}_	};decreases,the,reference,counter,for,the,given,entry,so,that,it,can,be,removed,once,the,reference,counter,reaches,0,param,node,id,of,the,entry,throws,exception,thrown,if,the,system,cannot,access,the,state;public,void,release,node,final,node,id,node,throws,exception,lockable,shared,buffer,node,shared,buffer,node,entries,get,node,if,shared,buffer,node,null,if,shared,buffer,node,release,remove,node,node,shared,buffer,node,get,element,else,entries,put,node,shared,buffer,node
SharedBuffer -> public void releaseNode(final NodeId node) throws Exception;1530798894;Decreases the reference counter for the given entry so that it can be_removed once the reference counter reaches 0.__@param node id of the entry_@throws Exception Thrown if the system cannot access the state.;public void releaseNode(final NodeId node) throws Exception {_		Lockable<SharedBufferNode> sharedBufferNode = entries.get(node)__		if (sharedBufferNode != null) {_			if (sharedBufferNode.release()) {_				removeNode(node, sharedBufferNode.getElement())__			} else {_				entries.put(node, sharedBufferNode)__			}_		}_	};decreases,the,reference,counter,for,the,given,entry,so,that,it,can,be,removed,once,the,reference,counter,reaches,0,param,node,id,of,the,entry,throws,exception,thrown,if,the,system,cannot,access,the,state;public,void,release,node,final,node,id,node,throws,exception,lockable,shared,buffer,node,shared,buffer,node,entries,get,node,if,shared,buffer,node,null,if,shared,buffer,node,release,remove,node,node,shared,buffer,node,get,element,else,entries,put,node,shared,buffer,node
