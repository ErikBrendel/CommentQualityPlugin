# id;timestamp;commentText;codeText;commentWords;codeWords
ScatterGatherIteration -> public static <K, VV, Message, EV> ScatterGatherIteration<K, VV, Message, EV> withEdges( 		DataSet<Edge<K, EV>> edgesWithValue, ScatterFunction<K, VV, Message, EV> sf, 		GatherFunction<K, VV, Message> gf, int maximumNumberOfIterations);1475517578;Creates a new scatter-gather iteration operator for graphs where the edges are associated with a value (such as_a weight or distance).__@param edgesWithValue The data set containing edges._@param sf The function that turns changed vertex states into messages along the edges._@param gf The function that updates the state of the vertices from the incoming messages.__@param <K> The type of the vertex key (the vertex identifier)._@param <VV> The type of the vertex value (the state of the vertex)._@param <Message> The type of the message sent between vertices along the edges._@param <EV> The type of the values that are associated with the edges.__@return An in stance of the scatter-gather graph computation operator.;public static <K, VV, Message, EV> ScatterGatherIteration<K, VV, Message, EV> withEdges(_		DataSet<Edge<K, EV>> edgesWithValue, ScatterFunction<K, VV, Message, EV> sf,_		GatherFunction<K, VV, Message> gf, int maximumNumberOfIterations)_	{_		return new ScatterGatherIteration<>(sf, gf, edgesWithValue, maximumNumberOfIterations)__	};creates,a,new,scatter,gather,iteration,operator,for,graphs,where,the,edges,are,associated,with,a,value,such,as,a,weight,or,distance,param,edges,with,value,the,data,set,containing,edges,param,sf,the,function,that,turns,changed,vertex,states,into,messages,along,the,edges,param,gf,the,function,that,updates,the,state,of,the,vertices,from,the,incoming,messages,param,k,the,type,of,the,vertex,key,the,vertex,identifier,param,vv,the,type,of,the,vertex,value,the,state,of,the,vertex,param,message,the,type,of,the,message,sent,between,vertices,along,the,edges,param,ev,the,type,of,the,values,that,are,associated,with,the,edges,return,an,in,stance,of,the,scatter,gather,graph,computation,operator;public,static,k,vv,message,ev,scatter,gather,iteration,k,vv,message,ev,with,edges,data,set,edge,k,ev,edges,with,value,scatter,function,k,vv,message,ev,sf,gather,function,k,vv,message,gf,int,maximum,number,of,iterations,return,new,scatter,gather,iteration,sf,gf,edges,with,value,maximum,number,of,iterations
ScatterGatherIteration -> public static <K, VV, Message, EV> ScatterGatherIteration<K, VV, Message, EV> withEdges( 		DataSet<Edge<K, EV>> edgesWithValue, ScatterFunction<K, VV, Message, EV> sf, 		GatherFunction<K, VV, Message> gf, int maximumNumberOfIterations);1475589042;Creates a new scatter-gather iteration operator for graphs where the edges are associated with a value (such as_a weight or distance).__@param edgesWithValue The data set containing edges._@param sf The function that turns changed vertex states into messages along the edges._@param gf The function that updates the state of the vertices from the incoming messages.__@param <K> The type of the vertex key (the vertex identifier)._@param <VV> The type of the vertex value (the state of the vertex)._@param <Message> The type of the message sent between vertices along the edges._@param <EV> The type of the values that are associated with the edges.__@return An in stance of the scatter-gather graph computation operator.;public static <K, VV, Message, EV> ScatterGatherIteration<K, VV, Message, EV> withEdges(_		DataSet<Edge<K, EV>> edgesWithValue, ScatterFunction<K, VV, Message, EV> sf,_		GatherFunction<K, VV, Message> gf, int maximumNumberOfIterations)_	{_		return new ScatterGatherIteration<>(sf, gf, edgesWithValue, maximumNumberOfIterations)__	};creates,a,new,scatter,gather,iteration,operator,for,graphs,where,the,edges,are,associated,with,a,value,such,as,a,weight,or,distance,param,edges,with,value,the,data,set,containing,edges,param,sf,the,function,that,turns,changed,vertex,states,into,messages,along,the,edges,param,gf,the,function,that,updates,the,state,of,the,vertices,from,the,incoming,messages,param,k,the,type,of,the,vertex,key,the,vertex,identifier,param,vv,the,type,of,the,vertex,value,the,state,of,the,vertex,param,message,the,type,of,the,message,sent,between,vertices,along,the,edges,param,ev,the,type,of,the,values,that,are,associated,with,the,edges,return,an,in,stance,of,the,scatter,gather,graph,computation,operator;public,static,k,vv,message,ev,scatter,gather,iteration,k,vv,message,ev,with,edges,data,set,edge,k,ev,edges,with,value,scatter,function,k,vv,message,ev,sf,gather,function,k,vv,message,gf,int,maximum,number,of,iterations,return,new,scatter,gather,iteration,sf,gf,edges,with,value,maximum,number,of,iterations
ScatterGatherIteration -> public static <K, VV, Message, EV> ScatterGatherIteration<K, VV, Message, EV> withEdges( 		DataSet<Edge<K, EV>> edgesWithValue, ScatterFunction<K, VV, Message, EV> sf, 		GatherFunction<K, VV, Message> gf, int maximumNumberOfIterations);1484681137;Creates a new scatter-gather iteration operator for graphs where the edges are associated with a value (such as_a weight or distance).__@param edgesWithValue The data set containing edges._@param sf The function that turns changed vertex states into messages along the edges._@param gf The function that updates the state of the vertices from the incoming messages.__@param <K> The type of the vertex key (the vertex identifier)._@param <VV> The type of the vertex value (the state of the vertex)._@param <Message> The type of the message sent between vertices along the edges._@param <EV> The type of the values that are associated with the edges.__@return An in stance of the scatter-gather graph computation operator.;public static <K, VV, Message, EV> ScatterGatherIteration<K, VV, Message, EV> withEdges(_		DataSet<Edge<K, EV>> edgesWithValue, ScatterFunction<K, VV, Message, EV> sf,_		GatherFunction<K, VV, Message> gf, int maximumNumberOfIterations)_	{_		return new ScatterGatherIteration<>(sf, gf, edgesWithValue, maximumNumberOfIterations)__	};creates,a,new,scatter,gather,iteration,operator,for,graphs,where,the,edges,are,associated,with,a,value,such,as,a,weight,or,distance,param,edges,with,value,the,data,set,containing,edges,param,sf,the,function,that,turns,changed,vertex,states,into,messages,along,the,edges,param,gf,the,function,that,updates,the,state,of,the,vertices,from,the,incoming,messages,param,k,the,type,of,the,vertex,key,the,vertex,identifier,param,vv,the,type,of,the,vertex,value,the,state,of,the,vertex,param,message,the,type,of,the,message,sent,between,vertices,along,the,edges,param,ev,the,type,of,the,values,that,are,associated,with,the,edges,return,an,in,stance,of,the,scatter,gather,graph,computation,operator;public,static,k,vv,message,ev,scatter,gather,iteration,k,vv,message,ev,with,edges,data,set,edge,k,ev,edges,with,value,scatter,function,k,vv,message,ev,sf,gather,function,k,vv,message,gf,int,maximum,number,of,iterations,return,new,scatter,gather,iteration,sf,gf,edges,with,value,maximum,number,of,iterations
ScatterGatherIteration -> @SuppressWarnings("serial") 	private DataSet<Vertex<K, VV>> createResultVerticesWithDegrees(Graph<K, VV, EV> graph, EdgeDirection messagingDirection, 			TypeInformation<Tuple2<K, Message>> messageTypeInfo, DataSet<LongValue> numberOfVertices);1455810039;Creates the operator that represents this scatter-gather graph computation for a vertex with in_and out degrees added to the vertex value.__@param graph_@param messagingDirection_@param messageTypeInfo_@param numberOfVertices_@return the operator;@SuppressWarnings("serial")_	private DataSet<Vertex<K, VV>> createResultVerticesWithDegrees(Graph<K, VV, EV> graph, EdgeDirection messagingDirection,_			TypeInformation<Tuple2<K, Message>> messageTypeInfo, DataSet<LongValue> numberOfVertices) {__		DataSet<Tuple2<K, Message>> messages___		this.updateFunction.setOptDegrees(this.configuration.isOptDegrees())___		DataSet<Tuple2<K, LongValue>> inDegrees = graph.inDegrees()__		DataSet<Tuple2<K, LongValue>> outDegrees = graph.outDegrees()___		DataSet<Tuple3<K, LongValue, LongValue>> degrees = inDegrees.join(outDegrees).where(0).equalTo(0)_				.with(new FlatJoinFunction<Tuple2<K, LongValue>, Tuple2<K, LongValue>, Tuple3<K, LongValue, LongValue>>() {__					@Override_					public void join(Tuple2<K, LongValue> first, Tuple2<K, LongValue> second, Collector<Tuple3<K, LongValue, LongValue>> out) {_						out.collect(new Tuple3<K, LongValue, LongValue>(first.f0, first.f1, second.f1))__					}_				}).withForwardedFieldsFirst("f0_f1").withForwardedFieldsSecond("f1")___		DataSet<Vertex<K, Tuple3<VV, LongValue, LongValue>>> verticesWithDegrees = initialVertices_				.join(degrees).where(0).equalTo(0)_				.with(new FlatJoinFunction<Vertex<K,VV>, Tuple3<K, LongValue, LongValue>, Vertex<K, Tuple3<VV, LongValue, LongValue>>>() {_					@Override_					public void join(Vertex<K, VV> vertex, Tuple3<K, LongValue, LongValue> degrees,_									Collector<Vertex<K, Tuple3<VV, LongValue, LongValue>>> out) throws Exception {__						out.collect(new Vertex<K, Tuple3<VV, LongValue, LongValue>>(vertex.getId(),_								new Tuple3<VV, LongValue, LongValue>(vertex.getValue(), degrees.f1, degrees.f2)))__					}_				}).withForwardedFieldsFirst("f0")___		_		TypeInformation<Vertex<K, Tuple3<VV, LongValue, LongValue>>> vertexTypes = verticesWithDegrees.getType()___		final DeltaIteration<Vertex<K, Tuple3<VV, LongValue, LongValue>>, Vertex<K, Tuple3<VV, LongValue, LongValue>>> iteration =_				verticesWithDegrees.iterateDelta(verticesWithDegrees, this.maximumNumberOfIterations, 0)__				setUpIteration(iteration)___		switch (messagingDirection) {_			case IN:_				messages = buildMessagingFunctionVerticesWithDegrees(iteration, messageTypeInfo, 1, 0, numberOfVertices)__				break__			case OUT:_				messages = buildMessagingFunctionVerticesWithDegrees(iteration, messageTypeInfo, 0, 0, numberOfVertices)__				break__			case ALL:_				messages = buildMessagingFunctionVerticesWithDegrees(iteration, messageTypeInfo, 1, 0, numberOfVertices)_						.union(buildMessagingFunctionVerticesWithDegrees(iteration, messageTypeInfo, 0, 0, numberOfVertices)) __				break__			default:_				throw new IllegalArgumentException("Illegal edge direction")__		}__		@SuppressWarnings({ "unchecked", "rawtypes" })_		VertexUpdateUdf<K, Tuple3<VV, LongValue, LongValue>, Message> updateUdf =_				new VertexUpdateUdfVVWithDegrees(updateFunction, vertexTypes)___		_		CoGroupOperator<?, ?, Vertex<K, Tuple3<VV, LongValue, LongValue>>> updates =_				messages.coGroup(iteration.getSolutionSet()).where(0).equalTo(0).with(updateUdf)___		if (this.configuration != null && this.configuration.isOptNumVertices()) {_			updates = updates.withBroadcastSet(numberOfVertices, "number of vertices")__		}__		configureUpdateFunction(updates)___		return iteration.closeWith(updates, updates).map(_				new MapFunction<Vertex<K, Tuple3<VV, LongValue, LongValue>>, Vertex<K, VV>>() {__					public Vertex<K, VV> map(Vertex<K, Tuple3<VV, LongValue, LongValue>> vertex) {_						return new Vertex<K, VV>(vertex.getId(), vertex.getValue().f0)__					}_				})__	};creates,the,operator,that,represents,this,scatter,gather,graph,computation,for,a,vertex,with,in,and,out,degrees,added,to,the,vertex,value,param,graph,param,messaging,direction,param,message,type,info,param,number,of,vertices,return,the,operator;suppress,warnings,serial,private,data,set,vertex,k,vv,create,result,vertices,with,degrees,graph,k,vv,ev,graph,edge,direction,messaging,direction,type,information,tuple2,k,message,message,type,info,data,set,long,value,number,of,vertices,data,set,tuple2,k,message,messages,this,update,function,set,opt,degrees,this,configuration,is,opt,degrees,data,set,tuple2,k,long,value,in,degrees,graph,in,degrees,data,set,tuple2,k,long,value,out,degrees,graph,out,degrees,data,set,tuple3,k,long,value,long,value,degrees,in,degrees,join,out,degrees,where,0,equal,to,0,with,new,flat,join,function,tuple2,k,long,value,tuple2,k,long,value,tuple3,k,long,value,long,value,override,public,void,join,tuple2,k,long,value,first,tuple2,k,long,value,second,collector,tuple3,k,long,value,long,value,out,out,collect,new,tuple3,k,long,value,long,value,first,f0,first,f1,second,f1,with,forwarded,fields,first,f0,f1,with,forwarded,fields,second,f1,data,set,vertex,k,tuple3,vv,long,value,long,value,vertices,with,degrees,initial,vertices,join,degrees,where,0,equal,to,0,with,new,flat,join,function,vertex,k,vv,tuple3,k,long,value,long,value,vertex,k,tuple3,vv,long,value,long,value,override,public,void,join,vertex,k,vv,vertex,tuple3,k,long,value,long,value,degrees,collector,vertex,k,tuple3,vv,long,value,long,value,out,throws,exception,out,collect,new,vertex,k,tuple3,vv,long,value,long,value,vertex,get,id,new,tuple3,vv,long,value,long,value,vertex,get,value,degrees,f1,degrees,f2,with,forwarded,fields,first,f0,type,information,vertex,k,tuple3,vv,long,value,long,value,vertex,types,vertices,with,degrees,get,type,final,delta,iteration,vertex,k,tuple3,vv,long,value,long,value,vertex,k,tuple3,vv,long,value,long,value,iteration,vertices,with,degrees,iterate,delta,vertices,with,degrees,this,maximum,number,of,iterations,0,set,up,iteration,iteration,switch,messaging,direction,case,in,messages,build,messaging,function,vertices,with,degrees,iteration,message,type,info,1,0,number,of,vertices,break,case,out,messages,build,messaging,function,vertices,with,degrees,iteration,message,type,info,0,0,number,of,vertices,break,case,all,messages,build,messaging,function,vertices,with,degrees,iteration,message,type,info,1,0,number,of,vertices,union,build,messaging,function,vertices,with,degrees,iteration,message,type,info,0,0,number,of,vertices,break,default,throw,new,illegal,argument,exception,illegal,edge,direction,suppress,warnings,unchecked,rawtypes,vertex,update,udf,k,tuple3,vv,long,value,long,value,message,update,udf,new,vertex,update,udf,vvwith,degrees,update,function,vertex,types,co,group,operator,vertex,k,tuple3,vv,long,value,long,value,updates,messages,co,group,iteration,get,solution,set,where,0,equal,to,0,with,update,udf,if,this,configuration,null,this,configuration,is,opt,num,vertices,updates,updates,with,broadcast,set,number,of,vertices,number,of,vertices,configure,update,function,updates,return,iteration,close,with,updates,updates,map,new,map,function,vertex,k,tuple3,vv,long,value,long,value,vertex,k,vv,public,vertex,k,vv,map,vertex,k,tuple3,vv,long,value,long,value,vertex,return,new,vertex,k,vv,vertex,get,id,vertex,get,value,f0
ScatterGatherIteration -> @SuppressWarnings("serial") 	private DataSet<Vertex<K, VV>> createResultVerticesWithDegrees(Graph<K, VV, EV> graph, EdgeDirection messagingDirection, 			TypeInformation<Tuple2<K, Message>> messageTypeInfo, DataSet<LongValue> numberOfVertices);1462563578;Creates the operator that represents this scatter-gather graph computation for a vertex with in_and out degrees added to the vertex value.__@param graph_@param messagingDirection_@param messageTypeInfo_@param numberOfVertices_@return the operator;@SuppressWarnings("serial")_	private DataSet<Vertex<K, VV>> createResultVerticesWithDegrees(Graph<K, VV, EV> graph, EdgeDirection messagingDirection,_			TypeInformation<Tuple2<K, Message>> messageTypeInfo, DataSet<LongValue> numberOfVertices) {__		DataSet<Tuple2<K, Message>> messages___		this.gatherFunction.setOptDegrees(this.configuration.isOptDegrees())___		DataSet<Tuple2<K, LongValue>> inDegrees = graph.inDegrees()__		DataSet<Tuple2<K, LongValue>> outDegrees = graph.outDegrees()___		DataSet<Tuple3<K, LongValue, LongValue>> degrees = inDegrees.join(outDegrees).where(0).equalTo(0)_				.with(new FlatJoinFunction<Tuple2<K, LongValue>, Tuple2<K, LongValue>, Tuple3<K, LongValue, LongValue>>() {__					@Override_					public void join(Tuple2<K, LongValue> first, Tuple2<K, LongValue> second, Collector<Tuple3<K, LongValue, LongValue>> out) {_						out.collect(new Tuple3<>(first.f0, first.f1, second.f1))__					}_				}).withForwardedFieldsFirst("f0_f1").withForwardedFieldsSecond("f1")___		DataSet<Vertex<K, Tuple3<VV, LongValue, LongValue>>> verticesWithDegrees = initialVertices_				.join(degrees).where(0).equalTo(0)_				.with(new FlatJoinFunction<Vertex<K,VV>, Tuple3<K, LongValue, LongValue>, Vertex<K, Tuple3<VV, LongValue, LongValue>>>() {_					@Override_					public void join(Vertex<K, VV> vertex, Tuple3<K, LongValue, LongValue> degrees,_									Collector<Vertex<K, Tuple3<VV, LongValue, LongValue>>> out) throws Exception {_						out.collect(new Vertex<>(vertex.getId(),_									new Tuple3<>(vertex.getValue(), degrees.f1, degrees.f2)))__					}_				}).withForwardedFieldsFirst("f0")___		_		TypeInformation<Vertex<K, Tuple3<VV, LongValue, LongValue>>> vertexTypes = verticesWithDegrees.getType()___		final DeltaIteration<Vertex<K, Tuple3<VV, LongValue, LongValue>>, Vertex<K, Tuple3<VV, LongValue, LongValue>>> iteration =_				verticesWithDegrees.iterateDelta(verticesWithDegrees, this.maximumNumberOfIterations, 0)__				setUpIteration(iteration)___		switch (messagingDirection) {_			case IN:_				messages = buildScatterFunctionVerticesWithDegrees(iteration, messageTypeInfo, 1, 0, numberOfVertices)__				break__			case OUT:_				messages = buildScatterFunctionVerticesWithDegrees(iteration, messageTypeInfo, 0, 0, numberOfVertices)__				break__			case ALL:_				messages = buildScatterFunctionVerticesWithDegrees(iteration, messageTypeInfo, 1, 0, numberOfVertices)_						.union(buildScatterFunctionVerticesWithDegrees(iteration, messageTypeInfo, 0, 0, numberOfVertices)) __				break__			default:_				throw new IllegalArgumentException("Illegal edge direction")__		}__		@SuppressWarnings({ "unchecked", "rawtypes" })_		GatherUdf<K, Tuple3<VV, LongValue, LongValue>, Message> updateUdf =_				new GatherUdfVVWithDegrees(gatherFunction, vertexTypes)___		_		CoGroupOperator<?, ?, Vertex<K, Tuple3<VV, LongValue, LongValue>>> updates =_				messages.coGroup(iteration.getSolutionSet()).where(0).equalTo(0).with(updateUdf)___		if (this.configuration != null && this.configuration.isOptNumVertices()) {_			updates = updates.withBroadcastSet(numberOfVertices, "number of vertices")__		}__		configureUpdateFunction(updates)___		return iteration.closeWith(updates, updates).map(_				new MapFunction<Vertex<K, Tuple3<VV, LongValue, LongValue>>, Vertex<K, VV>>() {__					public Vertex<K, VV> map(Vertex<K, Tuple3<VV, LongValue, LongValue>> vertex) {_						return new Vertex<>(vertex.getId(), vertex.getValue().f0)__					}_				})__	};creates,the,operator,that,represents,this,scatter,gather,graph,computation,for,a,vertex,with,in,and,out,degrees,added,to,the,vertex,value,param,graph,param,messaging,direction,param,message,type,info,param,number,of,vertices,return,the,operator;suppress,warnings,serial,private,data,set,vertex,k,vv,create,result,vertices,with,degrees,graph,k,vv,ev,graph,edge,direction,messaging,direction,type,information,tuple2,k,message,message,type,info,data,set,long,value,number,of,vertices,data,set,tuple2,k,message,messages,this,gather,function,set,opt,degrees,this,configuration,is,opt,degrees,data,set,tuple2,k,long,value,in,degrees,graph,in,degrees,data,set,tuple2,k,long,value,out,degrees,graph,out,degrees,data,set,tuple3,k,long,value,long,value,degrees,in,degrees,join,out,degrees,where,0,equal,to,0,with,new,flat,join,function,tuple2,k,long,value,tuple2,k,long,value,tuple3,k,long,value,long,value,override,public,void,join,tuple2,k,long,value,first,tuple2,k,long,value,second,collector,tuple3,k,long,value,long,value,out,out,collect,new,tuple3,first,f0,first,f1,second,f1,with,forwarded,fields,first,f0,f1,with,forwarded,fields,second,f1,data,set,vertex,k,tuple3,vv,long,value,long,value,vertices,with,degrees,initial,vertices,join,degrees,where,0,equal,to,0,with,new,flat,join,function,vertex,k,vv,tuple3,k,long,value,long,value,vertex,k,tuple3,vv,long,value,long,value,override,public,void,join,vertex,k,vv,vertex,tuple3,k,long,value,long,value,degrees,collector,vertex,k,tuple3,vv,long,value,long,value,out,throws,exception,out,collect,new,vertex,vertex,get,id,new,tuple3,vertex,get,value,degrees,f1,degrees,f2,with,forwarded,fields,first,f0,type,information,vertex,k,tuple3,vv,long,value,long,value,vertex,types,vertices,with,degrees,get,type,final,delta,iteration,vertex,k,tuple3,vv,long,value,long,value,vertex,k,tuple3,vv,long,value,long,value,iteration,vertices,with,degrees,iterate,delta,vertices,with,degrees,this,maximum,number,of,iterations,0,set,up,iteration,iteration,switch,messaging,direction,case,in,messages,build,scatter,function,vertices,with,degrees,iteration,message,type,info,1,0,number,of,vertices,break,case,out,messages,build,scatter,function,vertices,with,degrees,iteration,message,type,info,0,0,number,of,vertices,break,case,all,messages,build,scatter,function,vertices,with,degrees,iteration,message,type,info,1,0,number,of,vertices,union,build,scatter,function,vertices,with,degrees,iteration,message,type,info,0,0,number,of,vertices,break,default,throw,new,illegal,argument,exception,illegal,edge,direction,suppress,warnings,unchecked,rawtypes,gather,udf,k,tuple3,vv,long,value,long,value,message,update,udf,new,gather,udf,vvwith,degrees,gather,function,vertex,types,co,group,operator,vertex,k,tuple3,vv,long,value,long,value,updates,messages,co,group,iteration,get,solution,set,where,0,equal,to,0,with,update,udf,if,this,configuration,null,this,configuration,is,opt,num,vertices,updates,updates,with,broadcast,set,number,of,vertices,number,of,vertices,configure,update,function,updates,return,iteration,close,with,updates,updates,map,new,map,function,vertex,k,tuple3,vv,long,value,long,value,vertex,k,vv,public,vertex,k,vv,map,vertex,k,tuple3,vv,long,value,long,value,vertex,return,new,vertex,vertex,get,id,vertex,get,value,f0
ScatterGatherIteration -> @SuppressWarnings("serial") 	private DataSet<Vertex<K, VV>> createResultVerticesWithDegrees(Graph<K, VV, EV> graph, EdgeDirection messagingDirection, 			TypeInformation<Tuple2<K, Message>> messageTypeInfo, DataSet<LongValue> numberOfVertices);1464188761;Creates the operator that represents this scatter-gather graph computation for a vertex with in_and out degrees added to the vertex value.__@param graph_@param messagingDirection_@param messageTypeInfo_@param numberOfVertices_@return the operator;@SuppressWarnings("serial")_	private DataSet<Vertex<K, VV>> createResultVerticesWithDegrees(Graph<K, VV, EV> graph, EdgeDirection messagingDirection,_			TypeInformation<Tuple2<K, Message>> messageTypeInfo, DataSet<LongValue> numberOfVertices) {__		DataSet<Tuple2<K, Message>> messages___		this.updateFunction.setOptDegrees(this.configuration.isOptDegrees())___		DataSet<Tuple2<K, Long>> inDegrees = graph.inDegrees()__		DataSet<Tuple2<K, Long>> outDegrees = graph.outDegrees()___		DataSet<Tuple3<K, Long, Long>> degrees = inDegrees.join(outDegrees).where(0).equalTo(0)_				.with(new FlatJoinFunction<Tuple2<K, Long>, Tuple2<K, Long>, Tuple3<K, Long, Long>>() {__					@Override_					public void join(Tuple2<K, Long> first, Tuple2<K, Long> second,	Collector<Tuple3<K, Long, Long>> out) {_						out.collect(new Tuple3<K, Long, Long>(first.f0, first.f1, second.f1))__					}_				}).withForwardedFieldsFirst("f0_f1").withForwardedFieldsSecond("f1")___		DataSet<Vertex<K, Tuple3<VV, Long, Long>>> verticesWithDegrees = initialVertices_				.join(degrees).where(0).equalTo(0)_				.with(new FlatJoinFunction<Vertex<K,VV>, Tuple3<K,Long,Long>, Vertex<K, Tuple3<VV, Long, Long>>>() {_					@Override_					public void join(Vertex<K, VV> vertex, Tuple3<K, Long, Long> degrees,_									Collector<Vertex<K, Tuple3<VV, Long, Long>>> out) throws Exception {__						out.collect(new Vertex<K, Tuple3<VV, Long, Long>>(vertex.getId(),_								new Tuple3<VV, Long, Long>(vertex.getValue(), degrees.f1, degrees.f2)))__					}_				}).withForwardedFieldsFirst("f0")___		_		TypeInformation<Vertex<K, Tuple3<VV, Long, Long>>> vertexTypes = verticesWithDegrees.getType()___		final DeltaIteration<Vertex<K, Tuple3<VV, Long, Long>>,	Vertex<K, Tuple3<VV, Long, Long>>> iteration =_				verticesWithDegrees.iterateDelta(verticesWithDegrees, this.maximumNumberOfIterations, 0)__				setUpIteration(iteration)___		switch (messagingDirection) {_			case IN:_				messages = buildMessagingFunctionVerticesWithDegrees(iteration, messageTypeInfo, 1, 0, numberOfVertices)__				break__			case OUT:_				messages = buildMessagingFunctionVerticesWithDegrees(iteration, messageTypeInfo, 0, 0, numberOfVertices)__				break__			case ALL:_				messages = buildMessagingFunctionVerticesWithDegrees(iteration, messageTypeInfo, 1, 0, numberOfVertices)_						.union(buildMessagingFunctionVerticesWithDegrees(iteration, messageTypeInfo, 0, 0, numberOfVertices)) __				break__			default:_				throw new IllegalArgumentException("Illegal edge direction")__		}__		@SuppressWarnings({ "unchecked", "rawtypes" })_		VertexUpdateUdf<K, Tuple3<VV, Long, Long>, Message> updateUdf =_				new VertexUpdateUdfVVWithDegrees(updateFunction, vertexTypes)___		_		CoGroupOperator<?, ?, Vertex<K, Tuple3<VV, Long, Long>>> updates =_				messages.coGroup(iteration.getSolutionSet()).where(0).equalTo(0).with(updateUdf)___		if (this.configuration != null && this.configuration.isOptNumVertices()) {_			updates = updates.withBroadcastSet(numberOfVertices, "number of vertices")__		}__		configureUpdateFunction(updates)___		return iteration.closeWith(updates, updates).map(_				new MapFunction<Vertex<K, Tuple3<VV, Long, Long>>, Vertex<K, VV>>() {__					public Vertex<K, VV> map(Vertex<K, Tuple3<VV, Long, Long>> vertex) {_						return new Vertex<K, VV>(vertex.getId(), vertex.getValue().f0)__					}_				})__	};creates,the,operator,that,represents,this,scatter,gather,graph,computation,for,a,vertex,with,in,and,out,degrees,added,to,the,vertex,value,param,graph,param,messaging,direction,param,message,type,info,param,number,of,vertices,return,the,operator;suppress,warnings,serial,private,data,set,vertex,k,vv,create,result,vertices,with,degrees,graph,k,vv,ev,graph,edge,direction,messaging,direction,type,information,tuple2,k,message,message,type,info,data,set,long,value,number,of,vertices,data,set,tuple2,k,message,messages,this,update,function,set,opt,degrees,this,configuration,is,opt,degrees,data,set,tuple2,k,long,in,degrees,graph,in,degrees,data,set,tuple2,k,long,out,degrees,graph,out,degrees,data,set,tuple3,k,long,long,degrees,in,degrees,join,out,degrees,where,0,equal,to,0,with,new,flat,join,function,tuple2,k,long,tuple2,k,long,tuple3,k,long,long,override,public,void,join,tuple2,k,long,first,tuple2,k,long,second,collector,tuple3,k,long,long,out,out,collect,new,tuple3,k,long,long,first,f0,first,f1,second,f1,with,forwarded,fields,first,f0,f1,with,forwarded,fields,second,f1,data,set,vertex,k,tuple3,vv,long,long,vertices,with,degrees,initial,vertices,join,degrees,where,0,equal,to,0,with,new,flat,join,function,vertex,k,vv,tuple3,k,long,long,vertex,k,tuple3,vv,long,long,override,public,void,join,vertex,k,vv,vertex,tuple3,k,long,long,degrees,collector,vertex,k,tuple3,vv,long,long,out,throws,exception,out,collect,new,vertex,k,tuple3,vv,long,long,vertex,get,id,new,tuple3,vv,long,long,vertex,get,value,degrees,f1,degrees,f2,with,forwarded,fields,first,f0,type,information,vertex,k,tuple3,vv,long,long,vertex,types,vertices,with,degrees,get,type,final,delta,iteration,vertex,k,tuple3,vv,long,long,vertex,k,tuple3,vv,long,long,iteration,vertices,with,degrees,iterate,delta,vertices,with,degrees,this,maximum,number,of,iterations,0,set,up,iteration,iteration,switch,messaging,direction,case,in,messages,build,messaging,function,vertices,with,degrees,iteration,message,type,info,1,0,number,of,vertices,break,case,out,messages,build,messaging,function,vertices,with,degrees,iteration,message,type,info,0,0,number,of,vertices,break,case,all,messages,build,messaging,function,vertices,with,degrees,iteration,message,type,info,1,0,number,of,vertices,union,build,messaging,function,vertices,with,degrees,iteration,message,type,info,0,0,number,of,vertices,break,default,throw,new,illegal,argument,exception,illegal,edge,direction,suppress,warnings,unchecked,rawtypes,vertex,update,udf,k,tuple3,vv,long,long,message,update,udf,new,vertex,update,udf,vvwith,degrees,update,function,vertex,types,co,group,operator,vertex,k,tuple3,vv,long,long,updates,messages,co,group,iteration,get,solution,set,where,0,equal,to,0,with,update,udf,if,this,configuration,null,this,configuration,is,opt,num,vertices,updates,updates,with,broadcast,set,number,of,vertices,number,of,vertices,configure,update,function,updates,return,iteration,close,with,updates,updates,map,new,map,function,vertex,k,tuple3,vv,long,long,vertex,k,vv,public,vertex,k,vv,map,vertex,k,tuple3,vv,long,long,vertex,return,new,vertex,k,vv,vertex,get,id,vertex,get,value,f0
ScatterGatherIteration -> @SuppressWarnings("serial") 	private DataSet<Vertex<K, VV>> createResultVerticesWithDegrees(Graph<K, VV, EV> graph, EdgeDirection messagingDirection, 			TypeInformation<Tuple2<K, Message>> messageTypeInfo, DataSet<LongValue> numberOfVertices);1475517578;Creates the operator that represents this scatter-gather graph computation for a vertex with in_and out degrees added to the vertex value.__@param graph_@param messagingDirection_@param messageTypeInfo_@param numberOfVertices_@return the operator;@SuppressWarnings("serial")_	private DataSet<Vertex<K, VV>> createResultVerticesWithDegrees(Graph<K, VV, EV> graph, EdgeDirection messagingDirection,_			TypeInformation<Tuple2<K, Message>> messageTypeInfo, DataSet<LongValue> numberOfVertices) {__		DataSet<Tuple2<K, Message>> messages___		this.gatherFunction.setOptDegrees(this.configuration.isOptDegrees())___		DataSet<Tuple2<K, LongValue>> inDegrees = graph.inDegrees()__		DataSet<Tuple2<K, LongValue>> outDegrees = graph.outDegrees()___		DataSet<Tuple3<K, LongValue, LongValue>> degrees = inDegrees.join(outDegrees).where(0).equalTo(0)_				.with(new FlatJoinFunction<Tuple2<K, LongValue>, Tuple2<K, LongValue>, Tuple3<K, LongValue, LongValue>>() {__					@Override_					public void join(Tuple2<K, LongValue> first, Tuple2<K, LongValue> second, Collector<Tuple3<K, LongValue, LongValue>> out) {_						out.collect(new Tuple3<>(first.f0, first.f1, second.f1))__					}_				}).withForwardedFieldsFirst("f0_f1").withForwardedFieldsSecond("f1")___		DataSet<Vertex<K, Tuple3<VV, LongValue, LongValue>>> verticesWithDegrees = initialVertices_				.join(degrees).where(0).equalTo(0)_				.with(new FlatJoinFunction<Vertex<K,VV>, Tuple3<K, LongValue, LongValue>, Vertex<K, Tuple3<VV, LongValue, LongValue>>>() {_					@Override_					public void join(Vertex<K, VV> vertex, Tuple3<K, LongValue, LongValue> degrees,_									Collector<Vertex<K, Tuple3<VV, LongValue, LongValue>>> out) throws Exception {_						out.collect(new Vertex<>(vertex.getId(),_									new Tuple3<>(vertex.getValue(), degrees.f1, degrees.f2)))__					}_				}).withForwardedFieldsFirst("f0")___		_		TypeInformation<Vertex<K, Tuple3<VV, LongValue, LongValue>>> vertexTypes = verticesWithDegrees.getType()___		final DeltaIteration<Vertex<K, Tuple3<VV, LongValue, LongValue>>, Vertex<K, Tuple3<VV, LongValue, LongValue>>> iteration =_				verticesWithDegrees.iterateDelta(verticesWithDegrees, this.maximumNumberOfIterations, 0)__				setUpIteration(iteration)___		switch (messagingDirection) {_			case IN:_				messages = buildScatterFunctionVerticesWithDegrees(iteration, messageTypeInfo, 1, 0, numberOfVertices)__				break__			case OUT:_				messages = buildScatterFunctionVerticesWithDegrees(iteration, messageTypeInfo, 0, 0, numberOfVertices)__				break__			case ALL:_				messages = buildScatterFunctionVerticesWithDegrees(iteration, messageTypeInfo, 1, 0, numberOfVertices)_						.union(buildScatterFunctionVerticesWithDegrees(iteration, messageTypeInfo, 0, 0, numberOfVertices)) __				break__			default:_				throw new IllegalArgumentException("Illegal edge direction")__		}__		@SuppressWarnings({ "unchecked", "rawtypes" })_		GatherUdf<K, Tuple3<VV, LongValue, LongValue>, Message> updateUdf =_				new GatherUdfVVWithDegrees(gatherFunction, vertexTypes)___		_		CoGroupOperator<?, ?, Vertex<K, Tuple3<VV, LongValue, LongValue>>> updates =_				messages.coGroup(iteration.getSolutionSet()).where(0).equalTo(0).with(updateUdf)___		if (this.configuration != null && this.configuration.isOptNumVertices()) {_			updates = updates.withBroadcastSet(numberOfVertices, "number of vertices")__		}__		configureUpdateFunction(updates)___		return iteration.closeWith(updates, updates).map(_				new MapFunction<Vertex<K, Tuple3<VV, LongValue, LongValue>>, Vertex<K, VV>>() {__					public Vertex<K, VV> map(Vertex<K, Tuple3<VV, LongValue, LongValue>> vertex) {_						return new Vertex<>(vertex.getId(), vertex.getValue().f0)__					}_				})__	};creates,the,operator,that,represents,this,scatter,gather,graph,computation,for,a,vertex,with,in,and,out,degrees,added,to,the,vertex,value,param,graph,param,messaging,direction,param,message,type,info,param,number,of,vertices,return,the,operator;suppress,warnings,serial,private,data,set,vertex,k,vv,create,result,vertices,with,degrees,graph,k,vv,ev,graph,edge,direction,messaging,direction,type,information,tuple2,k,message,message,type,info,data,set,long,value,number,of,vertices,data,set,tuple2,k,message,messages,this,gather,function,set,opt,degrees,this,configuration,is,opt,degrees,data,set,tuple2,k,long,value,in,degrees,graph,in,degrees,data,set,tuple2,k,long,value,out,degrees,graph,out,degrees,data,set,tuple3,k,long,value,long,value,degrees,in,degrees,join,out,degrees,where,0,equal,to,0,with,new,flat,join,function,tuple2,k,long,value,tuple2,k,long,value,tuple3,k,long,value,long,value,override,public,void,join,tuple2,k,long,value,first,tuple2,k,long,value,second,collector,tuple3,k,long,value,long,value,out,out,collect,new,tuple3,first,f0,first,f1,second,f1,with,forwarded,fields,first,f0,f1,with,forwarded,fields,second,f1,data,set,vertex,k,tuple3,vv,long,value,long,value,vertices,with,degrees,initial,vertices,join,degrees,where,0,equal,to,0,with,new,flat,join,function,vertex,k,vv,tuple3,k,long,value,long,value,vertex,k,tuple3,vv,long,value,long,value,override,public,void,join,vertex,k,vv,vertex,tuple3,k,long,value,long,value,degrees,collector,vertex,k,tuple3,vv,long,value,long,value,out,throws,exception,out,collect,new,vertex,vertex,get,id,new,tuple3,vertex,get,value,degrees,f1,degrees,f2,with,forwarded,fields,first,f0,type,information,vertex,k,tuple3,vv,long,value,long,value,vertex,types,vertices,with,degrees,get,type,final,delta,iteration,vertex,k,tuple3,vv,long,value,long,value,vertex,k,tuple3,vv,long,value,long,value,iteration,vertices,with,degrees,iterate,delta,vertices,with,degrees,this,maximum,number,of,iterations,0,set,up,iteration,iteration,switch,messaging,direction,case,in,messages,build,scatter,function,vertices,with,degrees,iteration,message,type,info,1,0,number,of,vertices,break,case,out,messages,build,scatter,function,vertices,with,degrees,iteration,message,type,info,0,0,number,of,vertices,break,case,all,messages,build,scatter,function,vertices,with,degrees,iteration,message,type,info,1,0,number,of,vertices,union,build,scatter,function,vertices,with,degrees,iteration,message,type,info,0,0,number,of,vertices,break,default,throw,new,illegal,argument,exception,illegal,edge,direction,suppress,warnings,unchecked,rawtypes,gather,udf,k,tuple3,vv,long,value,long,value,message,update,udf,new,gather,udf,vvwith,degrees,gather,function,vertex,types,co,group,operator,vertex,k,tuple3,vv,long,value,long,value,updates,messages,co,group,iteration,get,solution,set,where,0,equal,to,0,with,update,udf,if,this,configuration,null,this,configuration,is,opt,num,vertices,updates,updates,with,broadcast,set,number,of,vertices,number,of,vertices,configure,update,function,updates,return,iteration,close,with,updates,updates,map,new,map,function,vertex,k,tuple3,vv,long,value,long,value,vertex,k,vv,public,vertex,k,vv,map,vertex,k,tuple3,vv,long,value,long,value,vertex,return,new,vertex,vertex,get,id,vertex,get,value,f0
ScatterGatherIteration -> @SuppressWarnings("serial") 	private DataSet<Vertex<K, VV>> createResultVerticesWithDegrees(Graph<K, VV, EV> graph, EdgeDirection messagingDirection, 			TypeInformation<Tuple2<K, Message>> messageTypeInfo, DataSet<LongValue> numberOfVertices);1475589042;Creates the operator that represents this scatter-gather graph computation for a vertex with in_and out degrees added to the vertex value.__@param graph_@param messagingDirection_@param messageTypeInfo_@param numberOfVertices_@return the operator;@SuppressWarnings("serial")_	private DataSet<Vertex<K, VV>> createResultVerticesWithDegrees(Graph<K, VV, EV> graph, EdgeDirection messagingDirection,_			TypeInformation<Tuple2<K, Message>> messageTypeInfo, DataSet<LongValue> numberOfVertices) {__		DataSet<Tuple2<K, Message>> messages___		this.gatherFunction.setOptDegrees(this.configuration.isOptDegrees())___		DataSet<Tuple2<K, LongValue>> inDegrees = graph.inDegrees()__		DataSet<Tuple2<K, LongValue>> outDegrees = graph.outDegrees()___		DataSet<Tuple3<K, LongValue, LongValue>> degrees = inDegrees.join(outDegrees).where(0).equalTo(0)_				.with(new FlatJoinFunction<Tuple2<K, LongValue>, Tuple2<K, LongValue>, Tuple3<K, LongValue, LongValue>>() {__					@Override_					public void join(Tuple2<K, LongValue> first, Tuple2<K, LongValue> second, Collector<Tuple3<K, LongValue, LongValue>> out) {_						out.collect(new Tuple3<>(first.f0, first.f1, second.f1))__					}_				}).withForwardedFieldsFirst("f0_f1").withForwardedFieldsSecond("f1")___		DataSet<Vertex<K, Tuple3<VV, LongValue, LongValue>>> verticesWithDegrees = initialVertices_				.join(degrees).where(0).equalTo(0)_				.with(new FlatJoinFunction<Vertex<K,VV>, Tuple3<K, LongValue, LongValue>, Vertex<K, Tuple3<VV, LongValue, LongValue>>>() {_					@Override_					public void join(Vertex<K, VV> vertex, Tuple3<K, LongValue, LongValue> degrees,_									Collector<Vertex<K, Tuple3<VV, LongValue, LongValue>>> out) throws Exception {_						out.collect(new Vertex<>(vertex.getId(),_									new Tuple3<>(vertex.getValue(), degrees.f1, degrees.f2)))__					}_				}).withForwardedFieldsFirst("f0")___		_		TypeInformation<Vertex<K, Tuple3<VV, LongValue, LongValue>>> vertexTypes = verticesWithDegrees.getType()___		final DeltaIteration<Vertex<K, Tuple3<VV, LongValue, LongValue>>, Vertex<K, Tuple3<VV, LongValue, LongValue>>> iteration =_				verticesWithDegrees.iterateDelta(verticesWithDegrees, this.maximumNumberOfIterations, 0)__				setUpIteration(iteration)___		switch (messagingDirection) {_			case IN:_				messages = buildScatterFunctionVerticesWithDegrees(iteration, messageTypeInfo, 1, 0, numberOfVertices)__				break__			case OUT:_				messages = buildScatterFunctionVerticesWithDegrees(iteration, messageTypeInfo, 0, 0, numberOfVertices)__				break__			case ALL:_				messages = buildScatterFunctionVerticesWithDegrees(iteration, messageTypeInfo, 1, 0, numberOfVertices)_						.union(buildScatterFunctionVerticesWithDegrees(iteration, messageTypeInfo, 0, 0, numberOfVertices)) __				break__			default:_				throw new IllegalArgumentException("Illegal edge direction")__		}__		@SuppressWarnings({ "unchecked", "rawtypes" })_		GatherUdf<K, Tuple3<VV, LongValue, LongValue>, Message> updateUdf =_				new GatherUdfVVWithDegrees(gatherFunction, vertexTypes)___		_		CoGroupOperator<?, ?, Vertex<K, Tuple3<VV, LongValue, LongValue>>> updates =_				messages.coGroup(iteration.getSolutionSet()).where(0).equalTo(0).with(updateUdf)___		if (this.configuration != null && this.configuration.isOptNumVertices()) {_			updates = updates.withBroadcastSet(numberOfVertices, "number of vertices")__		}__		configureUpdateFunction(updates)___		return iteration.closeWith(updates, updates).map(_				new MapFunction<Vertex<K, Tuple3<VV, LongValue, LongValue>>, Vertex<K, VV>>() {__					public Vertex<K, VV> map(Vertex<K, Tuple3<VV, LongValue, LongValue>> vertex) {_						return new Vertex<>(vertex.getId(), vertex.getValue().f0)__					}_				})__	};creates,the,operator,that,represents,this,scatter,gather,graph,computation,for,a,vertex,with,in,and,out,degrees,added,to,the,vertex,value,param,graph,param,messaging,direction,param,message,type,info,param,number,of,vertices,return,the,operator;suppress,warnings,serial,private,data,set,vertex,k,vv,create,result,vertices,with,degrees,graph,k,vv,ev,graph,edge,direction,messaging,direction,type,information,tuple2,k,message,message,type,info,data,set,long,value,number,of,vertices,data,set,tuple2,k,message,messages,this,gather,function,set,opt,degrees,this,configuration,is,opt,degrees,data,set,tuple2,k,long,value,in,degrees,graph,in,degrees,data,set,tuple2,k,long,value,out,degrees,graph,out,degrees,data,set,tuple3,k,long,value,long,value,degrees,in,degrees,join,out,degrees,where,0,equal,to,0,with,new,flat,join,function,tuple2,k,long,value,tuple2,k,long,value,tuple3,k,long,value,long,value,override,public,void,join,tuple2,k,long,value,first,tuple2,k,long,value,second,collector,tuple3,k,long,value,long,value,out,out,collect,new,tuple3,first,f0,first,f1,second,f1,with,forwarded,fields,first,f0,f1,with,forwarded,fields,second,f1,data,set,vertex,k,tuple3,vv,long,value,long,value,vertices,with,degrees,initial,vertices,join,degrees,where,0,equal,to,0,with,new,flat,join,function,vertex,k,vv,tuple3,k,long,value,long,value,vertex,k,tuple3,vv,long,value,long,value,override,public,void,join,vertex,k,vv,vertex,tuple3,k,long,value,long,value,degrees,collector,vertex,k,tuple3,vv,long,value,long,value,out,throws,exception,out,collect,new,vertex,vertex,get,id,new,tuple3,vertex,get,value,degrees,f1,degrees,f2,with,forwarded,fields,first,f0,type,information,vertex,k,tuple3,vv,long,value,long,value,vertex,types,vertices,with,degrees,get,type,final,delta,iteration,vertex,k,tuple3,vv,long,value,long,value,vertex,k,tuple3,vv,long,value,long,value,iteration,vertices,with,degrees,iterate,delta,vertices,with,degrees,this,maximum,number,of,iterations,0,set,up,iteration,iteration,switch,messaging,direction,case,in,messages,build,scatter,function,vertices,with,degrees,iteration,message,type,info,1,0,number,of,vertices,break,case,out,messages,build,scatter,function,vertices,with,degrees,iteration,message,type,info,0,0,number,of,vertices,break,case,all,messages,build,scatter,function,vertices,with,degrees,iteration,message,type,info,1,0,number,of,vertices,union,build,scatter,function,vertices,with,degrees,iteration,message,type,info,0,0,number,of,vertices,break,default,throw,new,illegal,argument,exception,illegal,edge,direction,suppress,warnings,unchecked,rawtypes,gather,udf,k,tuple3,vv,long,value,long,value,message,update,udf,new,gather,udf,vvwith,degrees,gather,function,vertex,types,co,group,operator,vertex,k,tuple3,vv,long,value,long,value,updates,messages,co,group,iteration,get,solution,set,where,0,equal,to,0,with,update,udf,if,this,configuration,null,this,configuration,is,opt,num,vertices,updates,updates,with,broadcast,set,number,of,vertices,number,of,vertices,configure,update,function,updates,return,iteration,close,with,updates,updates,map,new,map,function,vertex,k,tuple3,vv,long,value,long,value,vertex,k,vv,public,vertex,k,vv,map,vertex,k,tuple3,vv,long,value,long,value,vertex,return,new,vertex,vertex,get,id,vertex,get,value,f0
ScatterGatherIteration -> @SuppressWarnings("serial") 	private DataSet<Vertex<K, VV>> createResultVerticesWithDegrees(Graph<K, VV, EV> graph, EdgeDirection messagingDirection, 			TypeInformation<Tuple2<K, Message>> messageTypeInfo, DataSet<LongValue> numberOfVertices);1484681137;Creates the operator that represents this scatter-gather graph computation for a vertex with in_and out degrees added to the vertex value.__@param graph_@param messagingDirection_@param messageTypeInfo_@param numberOfVertices_@return the operator;@SuppressWarnings("serial")_	private DataSet<Vertex<K, VV>> createResultVerticesWithDegrees(Graph<K, VV, EV> graph, EdgeDirection messagingDirection,_			TypeInformation<Tuple2<K, Message>> messageTypeInfo, DataSet<LongValue> numberOfVertices) {__		DataSet<Tuple2<K, Message>> messages___		this.gatherFunction.setOptDegrees(this.configuration.isOptDegrees())___		DataSet<Tuple2<K, LongValue>> inDegrees = graph.inDegrees()__		DataSet<Tuple2<K, LongValue>> outDegrees = graph.outDegrees()___		DataSet<Tuple3<K, LongValue, LongValue>> degrees = inDegrees.join(outDegrees).where(0).equalTo(0)_				.with(new FlatJoinFunction<Tuple2<K, LongValue>, Tuple2<K, LongValue>, Tuple3<K, LongValue, LongValue>>() {__					@Override_					public void join(Tuple2<K, LongValue> first, Tuple2<K, LongValue> second, Collector<Tuple3<K, LongValue, LongValue>> out) {_						out.collect(new Tuple3<>(first.f0, first.f1, second.f1))__					}_				}).withForwardedFieldsFirst("f0_f1").withForwardedFieldsSecond("f1")___		DataSet<Vertex<K, Tuple3<VV, LongValue, LongValue>>> verticesWithDegrees = initialVertices_				.join(degrees).where(0).equalTo(0)_				.with(new FlatJoinFunction<Vertex<K, VV>, Tuple3<K, LongValue, LongValue>, Vertex<K, Tuple3<VV, LongValue, LongValue>>>() {_					@Override_					public void join(Vertex<K, VV> vertex, Tuple3<K, LongValue, LongValue> degrees,_									Collector<Vertex<K, Tuple3<VV, LongValue, LongValue>>> out) throws Exception {_						out.collect(new Vertex<>(vertex.getId(),_									new Tuple3<>(vertex.getValue(), degrees.f1, degrees.f2)))__					}_				}).withForwardedFieldsFirst("f0")___		_		TypeInformation<Vertex<K, Tuple3<VV, LongValue, LongValue>>> vertexTypes = verticesWithDegrees.getType()___		final DeltaIteration<Vertex<K, Tuple3<VV, LongValue, LongValue>>, Vertex<K, Tuple3<VV, LongValue, LongValue>>> iteration =_				verticesWithDegrees.iterateDelta(verticesWithDegrees, this.maximumNumberOfIterations, 0)__				setUpIteration(iteration)___		switch (messagingDirection) {_			case IN:_				messages = buildScatterFunctionVerticesWithDegrees(iteration, messageTypeInfo, 1, 0, numberOfVertices)__				break__			case OUT:_				messages = buildScatterFunctionVerticesWithDegrees(iteration, messageTypeInfo, 0, 0, numberOfVertices)__				break__			case ALL:_				messages = buildScatterFunctionVerticesWithDegrees(iteration, messageTypeInfo, 1, 0, numberOfVertices)_						.union(buildScatterFunctionVerticesWithDegrees(iteration, messageTypeInfo, 0, 0, numberOfVertices)) __				break__			default:_				throw new IllegalArgumentException("Illegal edge direction")__		}__		@SuppressWarnings({ "unchecked", "rawtypes" })_		GatherUdf<K, Tuple3<VV, LongValue, LongValue>, Message> updateUdf =_				new GatherUdfVVWithDegrees(gatherFunction, vertexTypes)___		_		CoGroupOperator<?, ?, Vertex<K, Tuple3<VV, LongValue, LongValue>>> updates =_				messages.coGroup(iteration.getSolutionSet()).where(0).equalTo(0).with(updateUdf)___		if (this.configuration != null && this.configuration.isOptNumVertices()) {_			updates = updates.withBroadcastSet(numberOfVertices, "number of vertices")__		}__		configureUpdateFunction(updates)___		return iteration.closeWith(updates, updates).map(_				new MapFunction<Vertex<K, Tuple3<VV, LongValue, LongValue>>, Vertex<K, VV>>() {__					public Vertex<K, VV> map(Vertex<K, Tuple3<VV, LongValue, LongValue>> vertex) {_						return new Vertex<>(vertex.getId(), vertex.getValue().f0)__					}_				})__	};creates,the,operator,that,represents,this,scatter,gather,graph,computation,for,a,vertex,with,in,and,out,degrees,added,to,the,vertex,value,param,graph,param,messaging,direction,param,message,type,info,param,number,of,vertices,return,the,operator;suppress,warnings,serial,private,data,set,vertex,k,vv,create,result,vertices,with,degrees,graph,k,vv,ev,graph,edge,direction,messaging,direction,type,information,tuple2,k,message,message,type,info,data,set,long,value,number,of,vertices,data,set,tuple2,k,message,messages,this,gather,function,set,opt,degrees,this,configuration,is,opt,degrees,data,set,tuple2,k,long,value,in,degrees,graph,in,degrees,data,set,tuple2,k,long,value,out,degrees,graph,out,degrees,data,set,tuple3,k,long,value,long,value,degrees,in,degrees,join,out,degrees,where,0,equal,to,0,with,new,flat,join,function,tuple2,k,long,value,tuple2,k,long,value,tuple3,k,long,value,long,value,override,public,void,join,tuple2,k,long,value,first,tuple2,k,long,value,second,collector,tuple3,k,long,value,long,value,out,out,collect,new,tuple3,first,f0,first,f1,second,f1,with,forwarded,fields,first,f0,f1,with,forwarded,fields,second,f1,data,set,vertex,k,tuple3,vv,long,value,long,value,vertices,with,degrees,initial,vertices,join,degrees,where,0,equal,to,0,with,new,flat,join,function,vertex,k,vv,tuple3,k,long,value,long,value,vertex,k,tuple3,vv,long,value,long,value,override,public,void,join,vertex,k,vv,vertex,tuple3,k,long,value,long,value,degrees,collector,vertex,k,tuple3,vv,long,value,long,value,out,throws,exception,out,collect,new,vertex,vertex,get,id,new,tuple3,vertex,get,value,degrees,f1,degrees,f2,with,forwarded,fields,first,f0,type,information,vertex,k,tuple3,vv,long,value,long,value,vertex,types,vertices,with,degrees,get,type,final,delta,iteration,vertex,k,tuple3,vv,long,value,long,value,vertex,k,tuple3,vv,long,value,long,value,iteration,vertices,with,degrees,iterate,delta,vertices,with,degrees,this,maximum,number,of,iterations,0,set,up,iteration,iteration,switch,messaging,direction,case,in,messages,build,scatter,function,vertices,with,degrees,iteration,message,type,info,1,0,number,of,vertices,break,case,out,messages,build,scatter,function,vertices,with,degrees,iteration,message,type,info,0,0,number,of,vertices,break,case,all,messages,build,scatter,function,vertices,with,degrees,iteration,message,type,info,1,0,number,of,vertices,union,build,scatter,function,vertices,with,degrees,iteration,message,type,info,0,0,number,of,vertices,break,default,throw,new,illegal,argument,exception,illegal,edge,direction,suppress,warnings,unchecked,rawtypes,gather,udf,k,tuple3,vv,long,value,long,value,message,update,udf,new,gather,udf,vvwith,degrees,gather,function,vertex,types,co,group,operator,vertex,k,tuple3,vv,long,value,long,value,updates,messages,co,group,iteration,get,solution,set,where,0,equal,to,0,with,update,udf,if,this,configuration,null,this,configuration,is,opt,num,vertices,updates,updates,with,broadcast,set,number,of,vertices,number,of,vertices,configure,update,function,updates,return,iteration,close,with,updates,updates,map,new,map,function,vertex,k,tuple3,vv,long,value,long,value,vertex,k,vv,public,vertex,k,vv,map,vertex,k,tuple3,vv,long,value,long,value,vertex,return,new,vertex,vertex,get,id,vertex,get,value,f0
ScatterGatherIteration -> @SuppressWarnings("serial") 	private DataSet<Vertex<K, VV>> createResultVerticesWithDegrees(Graph<K, VV, EV> graph, EdgeDirection messagingDirection, 			TypeInformation<Tuple2<K, Message>> messageTypeInfo, DataSet<LongValue> numberOfVertices);1495653033;Creates the operator that represents this scatter-gather graph computation for a vertex with in_and out degrees added to the vertex value.__@param graph_@param messagingDirection_@param messageTypeInfo_@param numberOfVertices_@return the operator;@SuppressWarnings("serial")_	private DataSet<Vertex<K, VV>> createResultVerticesWithDegrees(Graph<K, VV, EV> graph, EdgeDirection messagingDirection,_			TypeInformation<Tuple2<K, Message>> messageTypeInfo, DataSet<LongValue> numberOfVertices) {__		DataSet<Tuple2<K, Message>> messages___		this.gatherFunction.setOptDegrees(this.configuration.isOptDegrees())___		DataSet<Tuple2<K, LongValue>> inDegrees = graph.inDegrees()__		DataSet<Tuple2<K, LongValue>> outDegrees = graph.outDegrees()___		DataSet<Tuple3<K, LongValue, LongValue>> degrees = inDegrees.join(outDegrees).where(0).equalTo(0)_				.with(new FlatJoinFunction<Tuple2<K, LongValue>, Tuple2<K, LongValue>, Tuple3<K, LongValue, LongValue>>() {__					@Override_					public void join(Tuple2<K, LongValue> first, Tuple2<K, LongValue> second, Collector<Tuple3<K, LongValue, LongValue>> out) {_						out.collect(new Tuple3<>(first.f0, first.f1, second.f1))__					}_				}).withForwardedFieldsFirst("f0_f1").withForwardedFieldsSecond("f1")___		DataSet<Vertex<K, Tuple3<VV, LongValue, LongValue>>> verticesWithDegrees = initialVertices_				.join(degrees).where(0).equalTo(0)_				.with(new FlatJoinFunction<Vertex<K, VV>, Tuple3<K, LongValue, LongValue>, Vertex<K, Tuple3<VV, LongValue, LongValue>>>() {_					@Override_					public void join(Vertex<K, VV> vertex, Tuple3<K, LongValue, LongValue> degrees,_									Collector<Vertex<K, Tuple3<VV, LongValue, LongValue>>> out) throws Exception {_						out.collect(new Vertex<>(vertex.getId(),_									new Tuple3<>(vertex.getValue(), degrees.f1, degrees.f2)))__					}_				}).withForwardedFieldsFirst("f0")___		_		TypeInformation<Vertex<K, Tuple3<VV, LongValue, LongValue>>> vertexTypes = verticesWithDegrees.getType()___		final DeltaIteration<Vertex<K, Tuple3<VV, LongValue, LongValue>>, Vertex<K, Tuple3<VV, LongValue, LongValue>>> iteration =_				verticesWithDegrees.iterateDelta(verticesWithDegrees, this.maximumNumberOfIterations, 0)__				setUpIteration(iteration)___		switch (messagingDirection) {_			case IN:_				messages = buildScatterFunctionVerticesWithDegrees(iteration, messageTypeInfo, 1, 0, numberOfVertices)__				break__			case OUT:_				messages = buildScatterFunctionVerticesWithDegrees(iteration, messageTypeInfo, 0, 0, numberOfVertices)__				break__			case ALL:_				messages = buildScatterFunctionVerticesWithDegrees(iteration, messageTypeInfo, 1, 0, numberOfVertices)_						.union(buildScatterFunctionVerticesWithDegrees(iteration, messageTypeInfo, 0, 0, numberOfVertices))__				break__			default:_				throw new IllegalArgumentException("Illegal edge direction")__		}__		@SuppressWarnings({ "unchecked", "rawtypes" })_		GatherUdf<K, Tuple3<VV, LongValue, LongValue>, Message> updateUdf =_				new GatherUdfVVWithDegrees(gatherFunction, vertexTypes)___		_		CoGroupOperator<?, ?, Vertex<K, Tuple3<VV, LongValue, LongValue>>> updates =_				messages.coGroup(iteration.getSolutionSet()).where(0).equalTo(0).with(updateUdf)___		if (this.configuration != null && this.configuration.isOptNumVertices()) {_			updates = updates.withBroadcastSet(numberOfVertices, "number of vertices")__		}__		configureUpdateFunction(updates)___		return iteration.closeWith(updates, updates).map(_				new MapFunction<Vertex<K, Tuple3<VV, LongValue, LongValue>>, Vertex<K, VV>>() {__					public Vertex<K, VV> map(Vertex<K, Tuple3<VV, LongValue, LongValue>> vertex) {_						return new Vertex<>(vertex.getId(), vertex.getValue().f0)__					}_				})__	};creates,the,operator,that,represents,this,scatter,gather,graph,computation,for,a,vertex,with,in,and,out,degrees,added,to,the,vertex,value,param,graph,param,messaging,direction,param,message,type,info,param,number,of,vertices,return,the,operator;suppress,warnings,serial,private,data,set,vertex,k,vv,create,result,vertices,with,degrees,graph,k,vv,ev,graph,edge,direction,messaging,direction,type,information,tuple2,k,message,message,type,info,data,set,long,value,number,of,vertices,data,set,tuple2,k,message,messages,this,gather,function,set,opt,degrees,this,configuration,is,opt,degrees,data,set,tuple2,k,long,value,in,degrees,graph,in,degrees,data,set,tuple2,k,long,value,out,degrees,graph,out,degrees,data,set,tuple3,k,long,value,long,value,degrees,in,degrees,join,out,degrees,where,0,equal,to,0,with,new,flat,join,function,tuple2,k,long,value,tuple2,k,long,value,tuple3,k,long,value,long,value,override,public,void,join,tuple2,k,long,value,first,tuple2,k,long,value,second,collector,tuple3,k,long,value,long,value,out,out,collect,new,tuple3,first,f0,first,f1,second,f1,with,forwarded,fields,first,f0,f1,with,forwarded,fields,second,f1,data,set,vertex,k,tuple3,vv,long,value,long,value,vertices,with,degrees,initial,vertices,join,degrees,where,0,equal,to,0,with,new,flat,join,function,vertex,k,vv,tuple3,k,long,value,long,value,vertex,k,tuple3,vv,long,value,long,value,override,public,void,join,vertex,k,vv,vertex,tuple3,k,long,value,long,value,degrees,collector,vertex,k,tuple3,vv,long,value,long,value,out,throws,exception,out,collect,new,vertex,vertex,get,id,new,tuple3,vertex,get,value,degrees,f1,degrees,f2,with,forwarded,fields,first,f0,type,information,vertex,k,tuple3,vv,long,value,long,value,vertex,types,vertices,with,degrees,get,type,final,delta,iteration,vertex,k,tuple3,vv,long,value,long,value,vertex,k,tuple3,vv,long,value,long,value,iteration,vertices,with,degrees,iterate,delta,vertices,with,degrees,this,maximum,number,of,iterations,0,set,up,iteration,iteration,switch,messaging,direction,case,in,messages,build,scatter,function,vertices,with,degrees,iteration,message,type,info,1,0,number,of,vertices,break,case,out,messages,build,scatter,function,vertices,with,degrees,iteration,message,type,info,0,0,number,of,vertices,break,case,all,messages,build,scatter,function,vertices,with,degrees,iteration,message,type,info,1,0,number,of,vertices,union,build,scatter,function,vertices,with,degrees,iteration,message,type,info,0,0,number,of,vertices,break,default,throw,new,illegal,argument,exception,illegal,edge,direction,suppress,warnings,unchecked,rawtypes,gather,udf,k,tuple3,vv,long,value,long,value,message,update,udf,new,gather,udf,vvwith,degrees,gather,function,vertex,types,co,group,operator,vertex,k,tuple3,vv,long,value,long,value,updates,messages,co,group,iteration,get,solution,set,where,0,equal,to,0,with,update,udf,if,this,configuration,null,this,configuration,is,opt,num,vertices,updates,updates,with,broadcast,set,number,of,vertices,number,of,vertices,configure,update,function,updates,return,iteration,close,with,updates,updates,map,new,map,function,vertex,k,tuple3,vv,long,value,long,value,vertex,k,vv,public,vertex,k,vv,map,vertex,k,tuple3,vv,long,value,long,value,vertex,return,new,vertex,vertex,get,id,vertex,get,value,f0
ScatterGatherIteration -> private CoGroupOperator<?, ?, Tuple2<K, Message>> buildMessagingFunction( 			DeltaIteration<Vertex<K, VV>, Vertex<K, VV>> iteration, 			TypeInformation<Tuple2<K, Message>> messageTypeInfo, int whereArg, int equalToArg, 			DataSet<LongValue> numberOfVertices);1455810039;Method that builds the messaging function using a coGroup operator for a simple vertex(without_degrees)._It afterwards configures the function with a custom name and broadcast variables.__@param iteration_@param messageTypeInfo_@param whereArg the argument for the where within the coGroup_@param equalToArg the argument for the equalTo within the coGroup_@return the messaging function;private CoGroupOperator<?, ?, Tuple2<K, Message>> buildMessagingFunction(_			DeltaIteration<Vertex<K, VV>, Vertex<K, VV>> iteration,_			TypeInformation<Tuple2<K, Message>> messageTypeInfo, int whereArg, int equalToArg,_			DataSet<LongValue> numberOfVertices) {__		_		CoGroupOperator<?, ?, Tuple2<K, Message>> messages__		MessagingUdfWithEdgeValues<K, VV, VV, Message, EV> messenger =_				new MessagingUdfWithEVsSimpleVV<K, VV, Message, EV>(messagingFunction, messageTypeInfo)___		messages = this.edgesWithValue.coGroup(iteration.getWorkset()).where(whereArg)_				.equalTo(equalToArg).with(messenger)___		_		messages = messages.name("Messaging")__		if(this.configuration != null) {_			for (Tuple2<String, DataSet<?>> e : this.configuration.getMessagingBcastVars()) {_				messages = messages.withBroadcastSet(e.f1, e.f0)__			}_			if (this.configuration.isOptNumVertices()) {_				messages = messages.withBroadcastSet(numberOfVertices, "number of vertices")__			}_		}__		return messages__	};method,that,builds,the,messaging,function,using,a,co,group,operator,for,a,simple,vertex,without,degrees,it,afterwards,configures,the,function,with,a,custom,name,and,broadcast,variables,param,iteration,param,message,type,info,param,where,arg,the,argument,for,the,where,within,the,co,group,param,equal,to,arg,the,argument,for,the,equal,to,within,the,co,group,return,the,messaging,function;private,co,group,operator,tuple2,k,message,build,messaging,function,delta,iteration,vertex,k,vv,vertex,k,vv,iteration,type,information,tuple2,k,message,message,type,info,int,where,arg,int,equal,to,arg,data,set,long,value,number,of,vertices,co,group,operator,tuple2,k,message,messages,messaging,udf,with,edge,values,k,vv,vv,message,ev,messenger,new,messaging,udf,with,evs,simple,vv,k,vv,message,ev,messaging,function,message,type,info,messages,this,edges,with,value,co,group,iteration,get,workset,where,where,arg,equal,to,equal,to,arg,with,messenger,messages,messages,name,messaging,if,this,configuration,null,for,tuple2,string,data,set,e,this,configuration,get,messaging,bcast,vars,messages,messages,with,broadcast,set,e,f1,e,f0,if,this,configuration,is,opt,num,vertices,messages,messages,with,broadcast,set,number,of,vertices,number,of,vertices,return,messages
ScatterGatherIteration -> private CoGroupOperator<?, ?, Tuple2<K, Message>> buildMessagingFunction( 			DeltaIteration<Vertex<K, VV>, Vertex<K, VV>> iteration, 			TypeInformation<Tuple2<K, Message>> messageTypeInfo, int whereArg, int equalToArg, 			DataSet<LongValue> numberOfVertices);1464188761;Method that builds the messaging function using a coGroup operator for a simple vertex(without_degrees)._It afterwards configures the function with a custom name and broadcast variables.__@param iteration_@param messageTypeInfo_@param whereArg the argument for the where within the coGroup_@param equalToArg the argument for the equalTo within the coGroup_@return the messaging function;private CoGroupOperator<?, ?, Tuple2<K, Message>> buildMessagingFunction(_			DeltaIteration<Vertex<K, VV>, Vertex<K, VV>> iteration,_			TypeInformation<Tuple2<K, Message>> messageTypeInfo, int whereArg, int equalToArg,_			DataSet<LongValue> numberOfVertices) {__		_		CoGroupOperator<?, ?, Tuple2<K, Message>> messages__		MessagingUdfWithEdgeValues<K, VV, VV, Message, EV> messenger =_				new MessagingUdfWithEVsSimpleVV<K, VV, Message, EV>(messagingFunction, messageTypeInfo)___		messages = this.edgesWithValue.coGroup(iteration.getWorkset()).where(whereArg)_				.equalTo(equalToArg).with(messenger)___		_		messages = messages.name("Messaging")__		if(this.configuration != null) {_			for (Tuple2<String, DataSet<?>> e : this.configuration.getMessagingBcastVars()) {_				messages = messages.withBroadcastSet(e.f1, e.f0)__			}_			if (this.configuration.isOptNumVertices()) {_				messages = messages.withBroadcastSet(numberOfVertices, "number of vertices")__			}_		}__		return messages__	};method,that,builds,the,messaging,function,using,a,co,group,operator,for,a,simple,vertex,without,degrees,it,afterwards,configures,the,function,with,a,custom,name,and,broadcast,variables,param,iteration,param,message,type,info,param,where,arg,the,argument,for,the,where,within,the,co,group,param,equal,to,arg,the,argument,for,the,equal,to,within,the,co,group,return,the,messaging,function;private,co,group,operator,tuple2,k,message,build,messaging,function,delta,iteration,vertex,k,vv,vertex,k,vv,iteration,type,information,tuple2,k,message,message,type,info,int,where,arg,int,equal,to,arg,data,set,long,value,number,of,vertices,co,group,operator,tuple2,k,message,messages,messaging,udf,with,edge,values,k,vv,vv,message,ev,messenger,new,messaging,udf,with,evs,simple,vv,k,vv,message,ev,messaging,function,message,type,info,messages,this,edges,with,value,co,group,iteration,get,workset,where,where,arg,equal,to,equal,to,arg,with,messenger,messages,messages,name,messaging,if,this,configuration,null,for,tuple2,string,data,set,e,this,configuration,get,messaging,bcast,vars,messages,messages,with,broadcast,set,e,f1,e,f0,if,this,configuration,is,opt,num,vertices,messages,messages,with,broadcast,set,number,of,vertices,number,of,vertices,return,messages
ScatterGatherIteration -> private CoGroupOperator<?, ?, Tuple2<K, Message>> buildMessagingFunctionVerticesWithDegrees( 			DeltaIteration<Vertex<K, Tuple3<VV, Long, Long>>, Vertex<K, Tuple3<VV, Long, Long>>> iteration, 			TypeInformation<Tuple2<K, Message>> messageTypeInfo, int whereArg, int equalToArg);1452884884;Method that builds the messaging function using a coGroup operator for a vertex_containing degree information._It afterwards configures the function with a custom name and broadcast variables.__@param iteration_@param messageTypeInfo_@param whereArg the argument for the where within the coGroup_@param equalToArg the argument for the equalTo within the coGroup_@return the messaging function;private CoGroupOperator<?, ?, Tuple2<K, Message>> buildMessagingFunctionVerticesWithDegrees(_			DeltaIteration<Vertex<K, Tuple3<VV, Long, Long>>, Vertex<K, Tuple3<VV, Long, Long>>> iteration,_			TypeInformation<Tuple2<K, Message>> messageTypeInfo, int whereArg, int equalToArg) {__		_		CoGroupOperator<?, ?, Tuple2<K, Message>> messages__		MessagingUdfWithEdgeValues<K, Tuple3<VV, Long, Long>, VV, Message, EV> messenger =_				new MessagingUdfWithEVsVVWithDegrees<K, VV, Message, EV>(messagingFunction, messageTypeInfo)___		messages = this.edgesWithValue.coGroup(iteration.getWorkset()).where(whereArg)_				.equalTo(equalToArg).with(messenger)___		_		messages = messages.name("Messaging")___		if (this.configuration != null) {_			for (Tuple2<String, DataSet<?>> e : this.configuration.getMessagingBcastVars()) {_				messages = messages.withBroadcastSet(e.f1, e.f0)__			}_		}__		return messages__	};method,that,builds,the,messaging,function,using,a,co,group,operator,for,a,vertex,containing,degree,information,it,afterwards,configures,the,function,with,a,custom,name,and,broadcast,variables,param,iteration,param,message,type,info,param,where,arg,the,argument,for,the,where,within,the,co,group,param,equal,to,arg,the,argument,for,the,equal,to,within,the,co,group,return,the,messaging,function;private,co,group,operator,tuple2,k,message,build,messaging,function,vertices,with,degrees,delta,iteration,vertex,k,tuple3,vv,long,long,vertex,k,tuple3,vv,long,long,iteration,type,information,tuple2,k,message,message,type,info,int,where,arg,int,equal,to,arg,co,group,operator,tuple2,k,message,messages,messaging,udf,with,edge,values,k,tuple3,vv,long,long,vv,message,ev,messenger,new,messaging,udf,with,evs,vvwith,degrees,k,vv,message,ev,messaging,function,message,type,info,messages,this,edges,with,value,co,group,iteration,get,workset,where,where,arg,equal,to,equal,to,arg,with,messenger,messages,messages,name,messaging,if,this,configuration,null,for,tuple2,string,data,set,e,this,configuration,get,messaging,bcast,vars,messages,messages,with,broadcast,set,e,f1,e,f0,return,messages
ScatterGatherIteration -> private CoGroupOperator<?, ?, Tuple2<K, Message>> buildMessagingFunctionVerticesWithDegrees( 			DeltaIteration<Vertex<K, Tuple3<VV, Long, Long>>, Vertex<K, Tuple3<VV, Long, Long>>> iteration, 			TypeInformation<Tuple2<K, Message>> messageTypeInfo, int whereArg, int equalToArg);1461669017;Method that builds the messaging function using a coGroup operator for a vertex_containing degree information._It afterwards configures the function with a custom name and broadcast variables.__@param iteration_@param messageTypeInfo_@param whereArg the argument for the where within the coGroup_@param equalToArg the argument for the equalTo within the coGroup_@return the messaging function;private CoGroupOperator<?, ?, Tuple2<K, Message>> buildMessagingFunctionVerticesWithDegrees(_			DeltaIteration<Vertex<K, Tuple3<VV, Long, Long>>, Vertex<K, Tuple3<VV, Long, Long>>> iteration,_			TypeInformation<Tuple2<K, Message>> messageTypeInfo, int whereArg, int equalToArg) {__		_		CoGroupOperator<?, ?, Tuple2<K, Message>> messages__		MessagingUdfWithEdgeValues<K, Tuple3<VV, Long, Long>, VV, Message, EV> messenger =_				new MessagingUdfWithEVsVVWithDegrees<K, VV, Message, EV>(messagingFunction, messageTypeInfo)___		messages = this.edgesWithValue.coGroup(iteration.getWorkset()).where(whereArg)_				.equalTo(equalToArg).with(messenger)___		_		messages = messages.name("Messaging")___		if (this.configuration != null) {_			for (Tuple2<String, DataSet<?>> e : this.configuration.getMessagingBcastVars()) {_				messages = messages.withBroadcastSet(e.f1, e.f0)__			}_		}__		return messages__	};method,that,builds,the,messaging,function,using,a,co,group,operator,for,a,vertex,containing,degree,information,it,afterwards,configures,the,function,with,a,custom,name,and,broadcast,variables,param,iteration,param,message,type,info,param,where,arg,the,argument,for,the,where,within,the,co,group,param,equal,to,arg,the,argument,for,the,equal,to,within,the,co,group,return,the,messaging,function;private,co,group,operator,tuple2,k,message,build,messaging,function,vertices,with,degrees,delta,iteration,vertex,k,tuple3,vv,long,long,vertex,k,tuple3,vv,long,long,iteration,type,information,tuple2,k,message,message,type,info,int,where,arg,int,equal,to,arg,co,group,operator,tuple2,k,message,messages,messaging,udf,with,edge,values,k,tuple3,vv,long,long,vv,message,ev,messenger,new,messaging,udf,with,evs,vvwith,degrees,k,vv,message,ev,messaging,function,message,type,info,messages,this,edges,with,value,co,group,iteration,get,workset,where,where,arg,equal,to,equal,to,arg,with,messenger,messages,messages,name,messaging,if,this,configuration,null,for,tuple2,string,data,set,e,this,configuration,get,messaging,bcast,vars,messages,messages,with,broadcast,set,e,f1,e,f0,return,messages
ScatterGatherIteration -> private DataSet<Vertex<K, VV>> createResultSimpleVertex(EdgeDirection messagingDirection, 		TypeInformation<Tuple2<K, Message>> messageTypeInfo, DataSet<LongValue> numberOfVertices);1455810039;Creates the operator that represents this scatter-gather graph computation for a simple vertex.__@param messagingDirection_@param messageTypeInfo_@param numberOfVertices_@return the operator;private DataSet<Vertex<K, VV>> createResultSimpleVertex(EdgeDirection messagingDirection,_		TypeInformation<Tuple2<K, Message>> messageTypeInfo, DataSet<LongValue> numberOfVertices) {__		DataSet<Tuple2<K, Message>> messages___		TypeInformation<Vertex<K, VV>> vertexTypes = initialVertices.getType()___		final DeltaIteration<Vertex<K, VV>,	Vertex<K, VV>> iteration =_				initialVertices.iterateDelta(initialVertices, this.maximumNumberOfIterations, 0)__				setUpIteration(iteration)___		switch (messagingDirection) {_			case IN:_				messages = buildMessagingFunction(iteration, messageTypeInfo, 1, 0, numberOfVertices)__				break__			case OUT:_				messages = buildMessagingFunction(iteration, messageTypeInfo, 0, 0, numberOfVertices)__				break__			case ALL:_				messages = buildMessagingFunction(iteration, messageTypeInfo, 1, 0, numberOfVertices)_						.union(buildMessagingFunction(iteration, messageTypeInfo, 0, 0, numberOfVertices)) __				break__			default:_				throw new IllegalArgumentException("Illegal edge direction")__		}__		VertexUpdateUdf<K, VV, Message> updateUdf =_				new VertexUpdateUdfSimpleVV<K, VV, Message>(updateFunction, vertexTypes)___		_		CoGroupOperator<?, ?, Vertex<K, VV>> updates =_				messages.coGroup(iteration.getSolutionSet()).where(0).equalTo(0).with(updateUdf)___		if (this.configuration != null && this.configuration.isOptNumVertices()) {_			updates = updates.withBroadcastSet(numberOfVertices, "number of vertices")__		}__		configureUpdateFunction(updates)___		return iteration.closeWith(updates, updates)__	};creates,the,operator,that,represents,this,scatter,gather,graph,computation,for,a,simple,vertex,param,messaging,direction,param,message,type,info,param,number,of,vertices,return,the,operator;private,data,set,vertex,k,vv,create,result,simple,vertex,edge,direction,messaging,direction,type,information,tuple2,k,message,message,type,info,data,set,long,value,number,of,vertices,data,set,tuple2,k,message,messages,type,information,vertex,k,vv,vertex,types,initial,vertices,get,type,final,delta,iteration,vertex,k,vv,vertex,k,vv,iteration,initial,vertices,iterate,delta,initial,vertices,this,maximum,number,of,iterations,0,set,up,iteration,iteration,switch,messaging,direction,case,in,messages,build,messaging,function,iteration,message,type,info,1,0,number,of,vertices,break,case,out,messages,build,messaging,function,iteration,message,type,info,0,0,number,of,vertices,break,case,all,messages,build,messaging,function,iteration,message,type,info,1,0,number,of,vertices,union,build,messaging,function,iteration,message,type,info,0,0,number,of,vertices,break,default,throw,new,illegal,argument,exception,illegal,edge,direction,vertex,update,udf,k,vv,message,update,udf,new,vertex,update,udf,simple,vv,k,vv,message,update,function,vertex,types,co,group,operator,vertex,k,vv,updates,messages,co,group,iteration,get,solution,set,where,0,equal,to,0,with,update,udf,if,this,configuration,null,this,configuration,is,opt,num,vertices,updates,updates,with,broadcast,set,number,of,vertices,number,of,vertices,configure,update,function,updates,return,iteration,close,with,updates,updates
ScatterGatherIteration -> private DataSet<Vertex<K, VV>> createResultSimpleVertex(EdgeDirection messagingDirection, 		TypeInformation<Tuple2<K, Message>> messageTypeInfo, DataSet<LongValue> numberOfVertices);1462563578;Creates the operator that represents this scatter-gather graph computation for a simple vertex.__@param messagingDirection_@param messageTypeInfo_@param numberOfVertices_@return the operator;private DataSet<Vertex<K, VV>> createResultSimpleVertex(EdgeDirection messagingDirection,_		TypeInformation<Tuple2<K, Message>> messageTypeInfo, DataSet<LongValue> numberOfVertices) {__		DataSet<Tuple2<K, Message>> messages___		TypeInformation<Vertex<K, VV>> vertexTypes = initialVertices.getType()___		final DeltaIteration<Vertex<K, VV>,	Vertex<K, VV>> iteration =_				initialVertices.iterateDelta(initialVertices, this.maximumNumberOfIterations, 0)__				setUpIteration(iteration)___		switch (messagingDirection) {_			case IN:_				messages = buildScatterFunction(iteration, messageTypeInfo, 1, 0, numberOfVertices)__				break__			case OUT:_				messages = buildScatterFunction(iteration, messageTypeInfo, 0, 0, numberOfVertices)__				break__			case ALL:_				messages = buildScatterFunction(iteration, messageTypeInfo, 1, 0, numberOfVertices)_						.union(buildScatterFunction(iteration, messageTypeInfo, 0, 0, numberOfVertices)) __				break__			default:_				throw new IllegalArgumentException("Illegal edge direction")__		}__		GatherUdf<K, VV, Message> updateUdf =_				new GatherUdfSimpleVV<K, VV, Message>(gatherFunction, vertexTypes)___		_		CoGroupOperator<?, ?, Vertex<K, VV>> updates =_				messages.coGroup(iteration.getSolutionSet()).where(0).equalTo(0).with(updateUdf)___		if (this.configuration != null && this.configuration.isOptNumVertices()) {_			updates = updates.withBroadcastSet(numberOfVertices, "number of vertices")__		}__		configureUpdateFunction(updates)___		return iteration.closeWith(updates, updates)__	};creates,the,operator,that,represents,this,scatter,gather,graph,computation,for,a,simple,vertex,param,messaging,direction,param,message,type,info,param,number,of,vertices,return,the,operator;private,data,set,vertex,k,vv,create,result,simple,vertex,edge,direction,messaging,direction,type,information,tuple2,k,message,message,type,info,data,set,long,value,number,of,vertices,data,set,tuple2,k,message,messages,type,information,vertex,k,vv,vertex,types,initial,vertices,get,type,final,delta,iteration,vertex,k,vv,vertex,k,vv,iteration,initial,vertices,iterate,delta,initial,vertices,this,maximum,number,of,iterations,0,set,up,iteration,iteration,switch,messaging,direction,case,in,messages,build,scatter,function,iteration,message,type,info,1,0,number,of,vertices,break,case,out,messages,build,scatter,function,iteration,message,type,info,0,0,number,of,vertices,break,case,all,messages,build,scatter,function,iteration,message,type,info,1,0,number,of,vertices,union,build,scatter,function,iteration,message,type,info,0,0,number,of,vertices,break,default,throw,new,illegal,argument,exception,illegal,edge,direction,gather,udf,k,vv,message,update,udf,new,gather,udf,simple,vv,k,vv,message,gather,function,vertex,types,co,group,operator,vertex,k,vv,updates,messages,co,group,iteration,get,solution,set,where,0,equal,to,0,with,update,udf,if,this,configuration,null,this,configuration,is,opt,num,vertices,updates,updates,with,broadcast,set,number,of,vertices,number,of,vertices,configure,update,function,updates,return,iteration,close,with,updates,updates
ScatterGatherIteration -> private DataSet<Vertex<K, VV>> createResultSimpleVertex(EdgeDirection messagingDirection, 		TypeInformation<Tuple2<K, Message>> messageTypeInfo, DataSet<LongValue> numberOfVertices);1464188761;Creates the operator that represents this scatter-gather graph computation for a simple vertex.__@param messagingDirection_@param messageTypeInfo_@param numberOfVertices_@return the operator;private DataSet<Vertex<K, VV>> createResultSimpleVertex(EdgeDirection messagingDirection,_		TypeInformation<Tuple2<K, Message>> messageTypeInfo, DataSet<LongValue> numberOfVertices) {__		DataSet<Tuple2<K, Message>> messages___		TypeInformation<Vertex<K, VV>> vertexTypes = initialVertices.getType()___		final DeltaIteration<Vertex<K, VV>,	Vertex<K, VV>> iteration =_				initialVertices.iterateDelta(initialVertices, this.maximumNumberOfIterations, 0)__				setUpIteration(iteration)___		switch (messagingDirection) {_			case IN:_				messages = buildMessagingFunction(iteration, messageTypeInfo, 1, 0, numberOfVertices)__				break__			case OUT:_				messages = buildMessagingFunction(iteration, messageTypeInfo, 0, 0, numberOfVertices)__				break__			case ALL:_				messages = buildMessagingFunction(iteration, messageTypeInfo, 1, 0, numberOfVertices)_						.union(buildMessagingFunction(iteration, messageTypeInfo, 0, 0, numberOfVertices)) __				break__			default:_				throw new IllegalArgumentException("Illegal edge direction")__		}__		VertexUpdateUdf<K, VV, Message> updateUdf =_				new VertexUpdateUdfSimpleVV<K, VV, Message>(updateFunction, vertexTypes)___		_		CoGroupOperator<?, ?, Vertex<K, VV>> updates =_				messages.coGroup(iteration.getSolutionSet()).where(0).equalTo(0).with(updateUdf)___		if (this.configuration != null && this.configuration.isOptNumVertices()) {_			updates = updates.withBroadcastSet(numberOfVertices, "number of vertices")__		}__		configureUpdateFunction(updates)___		return iteration.closeWith(updates, updates)__	};creates,the,operator,that,represents,this,scatter,gather,graph,computation,for,a,simple,vertex,param,messaging,direction,param,message,type,info,param,number,of,vertices,return,the,operator;private,data,set,vertex,k,vv,create,result,simple,vertex,edge,direction,messaging,direction,type,information,tuple2,k,message,message,type,info,data,set,long,value,number,of,vertices,data,set,tuple2,k,message,messages,type,information,vertex,k,vv,vertex,types,initial,vertices,get,type,final,delta,iteration,vertex,k,vv,vertex,k,vv,iteration,initial,vertices,iterate,delta,initial,vertices,this,maximum,number,of,iterations,0,set,up,iteration,iteration,switch,messaging,direction,case,in,messages,build,messaging,function,iteration,message,type,info,1,0,number,of,vertices,break,case,out,messages,build,messaging,function,iteration,message,type,info,0,0,number,of,vertices,break,case,all,messages,build,messaging,function,iteration,message,type,info,1,0,number,of,vertices,union,build,messaging,function,iteration,message,type,info,0,0,number,of,vertices,break,default,throw,new,illegal,argument,exception,illegal,edge,direction,vertex,update,udf,k,vv,message,update,udf,new,vertex,update,udf,simple,vv,k,vv,message,update,function,vertex,types,co,group,operator,vertex,k,vv,updates,messages,co,group,iteration,get,solution,set,where,0,equal,to,0,with,update,udf,if,this,configuration,null,this,configuration,is,opt,num,vertices,updates,updates,with,broadcast,set,number,of,vertices,number,of,vertices,configure,update,function,updates,return,iteration,close,with,updates,updates
ScatterGatherIteration -> private DataSet<Vertex<K, VV>> createResultSimpleVertex(EdgeDirection messagingDirection, 		TypeInformation<Tuple2<K, Message>> messageTypeInfo, DataSet<LongValue> numberOfVertices);1475517578;Creates the operator that represents this scatter-gather graph computation for a simple vertex.__@param messagingDirection_@param messageTypeInfo_@param numberOfVertices_@return the operator;private DataSet<Vertex<K, VV>> createResultSimpleVertex(EdgeDirection messagingDirection,_		TypeInformation<Tuple2<K, Message>> messageTypeInfo, DataSet<LongValue> numberOfVertices) {__		DataSet<Tuple2<K, Message>> messages___		TypeInformation<Vertex<K, VV>> vertexTypes = initialVertices.getType()___		final DeltaIteration<Vertex<K, VV>,	Vertex<K, VV>> iteration =_				initialVertices.iterateDelta(initialVertices, this.maximumNumberOfIterations, 0)__				setUpIteration(iteration)___		switch (messagingDirection) {_			case IN:_				messages = buildScatterFunction(iteration, messageTypeInfo, 1, 0, numberOfVertices)__				break__			case OUT:_				messages = buildScatterFunction(iteration, messageTypeInfo, 0, 0, numberOfVertices)__				break__			case ALL:_				messages = buildScatterFunction(iteration, messageTypeInfo, 1, 0, numberOfVertices)_						.union(buildScatterFunction(iteration, messageTypeInfo, 0, 0, numberOfVertices)) __				break__			default:_				throw new IllegalArgumentException("Illegal edge direction")__		}__		GatherUdf<K, VV, Message> updateUdf = new GatherUdfSimpleVV<>(gatherFunction, vertexTypes)___		_		CoGroupOperator<?, ?, Vertex<K, VV>> updates =_				messages.coGroup(iteration.getSolutionSet()).where(0).equalTo(0).with(updateUdf)___		if (this.configuration != null && this.configuration.isOptNumVertices()) {_			updates = updates.withBroadcastSet(numberOfVertices, "number of vertices")__		}__		configureUpdateFunction(updates)___		return iteration.closeWith(updates, updates)__	};creates,the,operator,that,represents,this,scatter,gather,graph,computation,for,a,simple,vertex,param,messaging,direction,param,message,type,info,param,number,of,vertices,return,the,operator;private,data,set,vertex,k,vv,create,result,simple,vertex,edge,direction,messaging,direction,type,information,tuple2,k,message,message,type,info,data,set,long,value,number,of,vertices,data,set,tuple2,k,message,messages,type,information,vertex,k,vv,vertex,types,initial,vertices,get,type,final,delta,iteration,vertex,k,vv,vertex,k,vv,iteration,initial,vertices,iterate,delta,initial,vertices,this,maximum,number,of,iterations,0,set,up,iteration,iteration,switch,messaging,direction,case,in,messages,build,scatter,function,iteration,message,type,info,1,0,number,of,vertices,break,case,out,messages,build,scatter,function,iteration,message,type,info,0,0,number,of,vertices,break,case,all,messages,build,scatter,function,iteration,message,type,info,1,0,number,of,vertices,union,build,scatter,function,iteration,message,type,info,0,0,number,of,vertices,break,default,throw,new,illegal,argument,exception,illegal,edge,direction,gather,udf,k,vv,message,update,udf,new,gather,udf,simple,vv,gather,function,vertex,types,co,group,operator,vertex,k,vv,updates,messages,co,group,iteration,get,solution,set,where,0,equal,to,0,with,update,udf,if,this,configuration,null,this,configuration,is,opt,num,vertices,updates,updates,with,broadcast,set,number,of,vertices,number,of,vertices,configure,update,function,updates,return,iteration,close,with,updates,updates
ScatterGatherIteration -> private DataSet<Vertex<K, VV>> createResultSimpleVertex(EdgeDirection messagingDirection, 		TypeInformation<Tuple2<K, Message>> messageTypeInfo, DataSet<LongValue> numberOfVertices);1475589042;Creates the operator that represents this scatter-gather graph computation for a simple vertex.__@param messagingDirection_@param messageTypeInfo_@param numberOfVertices_@return the operator;private DataSet<Vertex<K, VV>> createResultSimpleVertex(EdgeDirection messagingDirection,_		TypeInformation<Tuple2<K, Message>> messageTypeInfo, DataSet<LongValue> numberOfVertices) {__		DataSet<Tuple2<K, Message>> messages___		TypeInformation<Vertex<K, VV>> vertexTypes = initialVertices.getType()___		final DeltaIteration<Vertex<K, VV>,	Vertex<K, VV>> iteration =_				initialVertices.iterateDelta(initialVertices, this.maximumNumberOfIterations, 0)__				setUpIteration(iteration)___		switch (messagingDirection) {_			case IN:_				messages = buildScatterFunction(iteration, messageTypeInfo, 1, 0, numberOfVertices)__				break__			case OUT:_				messages = buildScatterFunction(iteration, messageTypeInfo, 0, 0, numberOfVertices)__				break__			case ALL:_				messages = buildScatterFunction(iteration, messageTypeInfo, 1, 0, numberOfVertices)_						.union(buildScatterFunction(iteration, messageTypeInfo, 0, 0, numberOfVertices)) __				break__			default:_				throw new IllegalArgumentException("Illegal edge direction")__		}__		GatherUdf<K, VV, Message> updateUdf = new GatherUdfSimpleVV<>(gatherFunction, vertexTypes)___		_		CoGroupOperator<?, ?, Vertex<K, VV>> updates =_				messages.coGroup(iteration.getSolutionSet()).where(0).equalTo(0).with(updateUdf)___		if (this.configuration != null && this.configuration.isOptNumVertices()) {_			updates = updates.withBroadcastSet(numberOfVertices, "number of vertices")__		}__		configureUpdateFunction(updates)___		return iteration.closeWith(updates, updates)__	};creates,the,operator,that,represents,this,scatter,gather,graph,computation,for,a,simple,vertex,param,messaging,direction,param,message,type,info,param,number,of,vertices,return,the,operator;private,data,set,vertex,k,vv,create,result,simple,vertex,edge,direction,messaging,direction,type,information,tuple2,k,message,message,type,info,data,set,long,value,number,of,vertices,data,set,tuple2,k,message,messages,type,information,vertex,k,vv,vertex,types,initial,vertices,get,type,final,delta,iteration,vertex,k,vv,vertex,k,vv,iteration,initial,vertices,iterate,delta,initial,vertices,this,maximum,number,of,iterations,0,set,up,iteration,iteration,switch,messaging,direction,case,in,messages,build,scatter,function,iteration,message,type,info,1,0,number,of,vertices,break,case,out,messages,build,scatter,function,iteration,message,type,info,0,0,number,of,vertices,break,case,all,messages,build,scatter,function,iteration,message,type,info,1,0,number,of,vertices,union,build,scatter,function,iteration,message,type,info,0,0,number,of,vertices,break,default,throw,new,illegal,argument,exception,illegal,edge,direction,gather,udf,k,vv,message,update,udf,new,gather,udf,simple,vv,gather,function,vertex,types,co,group,operator,vertex,k,vv,updates,messages,co,group,iteration,get,solution,set,where,0,equal,to,0,with,update,udf,if,this,configuration,null,this,configuration,is,opt,num,vertices,updates,updates,with,broadcast,set,number,of,vertices,number,of,vertices,configure,update,function,updates,return,iteration,close,with,updates,updates
ScatterGatherIteration -> private DataSet<Vertex<K, VV>> createResultSimpleVertex(EdgeDirection messagingDirection, 		TypeInformation<Tuple2<K, Message>> messageTypeInfo, DataSet<LongValue> numberOfVertices);1484681137;Creates the operator that represents this scatter-gather graph computation for a simple vertex.__@param messagingDirection_@param messageTypeInfo_@param numberOfVertices_@return the operator;private DataSet<Vertex<K, VV>> createResultSimpleVertex(EdgeDirection messagingDirection,_		TypeInformation<Tuple2<K, Message>> messageTypeInfo, DataSet<LongValue> numberOfVertices) {__		DataSet<Tuple2<K, Message>> messages___		TypeInformation<Vertex<K, VV>> vertexTypes = initialVertices.getType()___		final DeltaIteration<Vertex<K, VV>, Vertex<K, VV>> iteration =_				initialVertices.iterateDelta(initialVertices, this.maximumNumberOfIterations, 0)__				setUpIteration(iteration)___		switch (messagingDirection) {_			case IN:_				messages = buildScatterFunction(iteration, messageTypeInfo, 1, 0, numberOfVertices)__				break__			case OUT:_				messages = buildScatterFunction(iteration, messageTypeInfo, 0, 0, numberOfVertices)__				break__			case ALL:_				messages = buildScatterFunction(iteration, messageTypeInfo, 1, 0, numberOfVertices)_						.union(buildScatterFunction(iteration, messageTypeInfo, 0, 0, numberOfVertices)) __				break__			default:_				throw new IllegalArgumentException("Illegal edge direction")__		}__		GatherUdf<K, VV, Message> updateUdf = new GatherUdfSimpleVV<>(gatherFunction, vertexTypes)___		_		CoGroupOperator<?, ?, Vertex<K, VV>> updates =_				messages.coGroup(iteration.getSolutionSet()).where(0).equalTo(0).with(updateUdf)___		if (this.configuration != null && this.configuration.isOptNumVertices()) {_			updates = updates.withBroadcastSet(numberOfVertices, "number of vertices")__		}__		configureUpdateFunction(updates)___		return iteration.closeWith(updates, updates)__	};creates,the,operator,that,represents,this,scatter,gather,graph,computation,for,a,simple,vertex,param,messaging,direction,param,message,type,info,param,number,of,vertices,return,the,operator;private,data,set,vertex,k,vv,create,result,simple,vertex,edge,direction,messaging,direction,type,information,tuple2,k,message,message,type,info,data,set,long,value,number,of,vertices,data,set,tuple2,k,message,messages,type,information,vertex,k,vv,vertex,types,initial,vertices,get,type,final,delta,iteration,vertex,k,vv,vertex,k,vv,iteration,initial,vertices,iterate,delta,initial,vertices,this,maximum,number,of,iterations,0,set,up,iteration,iteration,switch,messaging,direction,case,in,messages,build,scatter,function,iteration,message,type,info,1,0,number,of,vertices,break,case,out,messages,build,scatter,function,iteration,message,type,info,0,0,number,of,vertices,break,case,all,messages,build,scatter,function,iteration,message,type,info,1,0,number,of,vertices,union,build,scatter,function,iteration,message,type,info,0,0,number,of,vertices,break,default,throw,new,illegal,argument,exception,illegal,edge,direction,gather,udf,k,vv,message,update,udf,new,gather,udf,simple,vv,gather,function,vertex,types,co,group,operator,vertex,k,vv,updates,messages,co,group,iteration,get,solution,set,where,0,equal,to,0,with,update,udf,if,this,configuration,null,this,configuration,is,opt,num,vertices,updates,updates,with,broadcast,set,number,of,vertices,number,of,vertices,configure,update,function,updates,return,iteration,close,with,updates,updates
ScatterGatherIteration -> private DataSet<Vertex<K, VV>> createResultSimpleVertex(EdgeDirection messagingDirection, 		TypeInformation<Tuple2<K, Message>> messageTypeInfo, DataSet<LongValue> numberOfVertices);1495653033;Creates the operator that represents this scatter-gather graph computation for a simple vertex.__@param messagingDirection_@param messageTypeInfo_@param numberOfVertices_@return the operator;private DataSet<Vertex<K, VV>> createResultSimpleVertex(EdgeDirection messagingDirection,_		TypeInformation<Tuple2<K, Message>> messageTypeInfo, DataSet<LongValue> numberOfVertices) {__		DataSet<Tuple2<K, Message>> messages___		TypeInformation<Vertex<K, VV>> vertexTypes = initialVertices.getType()___		final DeltaIteration<Vertex<K, VV>, Vertex<K, VV>> iteration =_				initialVertices.iterateDelta(initialVertices, this.maximumNumberOfIterations, 0)__				setUpIteration(iteration)___		switch (messagingDirection) {_			case IN:_				messages = buildScatterFunction(iteration, messageTypeInfo, 1, 0, numberOfVertices)__				break__			case OUT:_				messages = buildScatterFunction(iteration, messageTypeInfo, 0, 0, numberOfVertices)__				break__			case ALL:_				messages = buildScatterFunction(iteration, messageTypeInfo, 1, 0, numberOfVertices)_						.union(buildScatterFunction(iteration, messageTypeInfo, 0, 0, numberOfVertices))__				break__			default:_				throw new IllegalArgumentException("Illegal edge direction")__		}__		GatherUdf<K, VV, Message> updateUdf = new GatherUdfSimpleVV<>(gatherFunction, vertexTypes)___		_		CoGroupOperator<?, ?, Vertex<K, VV>> updates =_				messages.coGroup(iteration.getSolutionSet()).where(0).equalTo(0).with(updateUdf)___		if (this.configuration != null && this.configuration.isOptNumVertices()) {_			updates = updates.withBroadcastSet(numberOfVertices, "number of vertices")__		}__		configureUpdateFunction(updates)___		return iteration.closeWith(updates, updates)__	};creates,the,operator,that,represents,this,scatter,gather,graph,computation,for,a,simple,vertex,param,messaging,direction,param,message,type,info,param,number,of,vertices,return,the,operator;private,data,set,vertex,k,vv,create,result,simple,vertex,edge,direction,messaging,direction,type,information,tuple2,k,message,message,type,info,data,set,long,value,number,of,vertices,data,set,tuple2,k,message,messages,type,information,vertex,k,vv,vertex,types,initial,vertices,get,type,final,delta,iteration,vertex,k,vv,vertex,k,vv,iteration,initial,vertices,iterate,delta,initial,vertices,this,maximum,number,of,iterations,0,set,up,iteration,iteration,switch,messaging,direction,case,in,messages,build,scatter,function,iteration,message,type,info,1,0,number,of,vertices,break,case,out,messages,build,scatter,function,iteration,message,type,info,0,0,number,of,vertices,break,case,all,messages,build,scatter,function,iteration,message,type,info,1,0,number,of,vertices,union,build,scatter,function,iteration,message,type,info,0,0,number,of,vertices,break,default,throw,new,illegal,argument,exception,illegal,edge,direction,gather,udf,k,vv,message,update,udf,new,gather,udf,simple,vv,gather,function,vertex,types,co,group,operator,vertex,k,vv,updates,messages,co,group,iteration,get,solution,set,where,0,equal,to,0,with,update,udf,if,this,configuration,null,this,configuration,is,opt,num,vertices,updates,updates,with,broadcast,set,number,of,vertices,number,of,vertices,configure,update,function,updates,return,iteration,close,with,updates,updates
ScatterGatherIteration -> private CoGroupOperator<?, ?, Tuple2<K, Message>> buildScatterFunction( 			DeltaIteration<Vertex<K, VV>, Vertex<K, VV>> iteration, 			TypeInformation<Tuple2<K, Message>> messageTypeInfo, int whereArg, int equalToArg, 			DataSet<LongValue> numberOfVertices);1462563578;Method that builds the scatter function using a coGroup operator for a simple vertex (without_degrees)._It afterwards configures the function with a custom name and broadcast variables.__@param iteration_@param messageTypeInfo_@param whereArg the argument for the where within the coGroup_@param equalToArg the argument for the equalTo within the coGroup_@return the scatter function;private CoGroupOperator<?, ?, Tuple2<K, Message>> buildScatterFunction(_			DeltaIteration<Vertex<K, VV>, Vertex<K, VV>> iteration,_			TypeInformation<Tuple2<K, Message>> messageTypeInfo, int whereArg, int equalToArg,_			DataSet<LongValue> numberOfVertices) {__		_		CoGroupOperator<?, ?, Tuple2<K, Message>> messages__		ScatterUdfWithEdgeValues<K, VV, VV, Message, EV> messenger =_				new ScatterUdfWithEVsSimpleVV<>(scatterFunction, messageTypeInfo)___		messages = this.edgesWithValue.coGroup(iteration.getWorkset()).where(whereArg)_				.equalTo(equalToArg).with(messenger)___		_		messages = messages.name("Messaging")__		if(this.configuration != null) {_			for (Tuple2<String, DataSet<?>> e : this.configuration.getScatterBcastVars()) {_				messages = messages.withBroadcastSet(e.f1, e.f0)__			}_			if (this.configuration.isOptNumVertices()) {_				messages = messages.withBroadcastSet(numberOfVertices, "number of vertices")__			}_		}__		return messages__	};method,that,builds,the,scatter,function,using,a,co,group,operator,for,a,simple,vertex,without,degrees,it,afterwards,configures,the,function,with,a,custom,name,and,broadcast,variables,param,iteration,param,message,type,info,param,where,arg,the,argument,for,the,where,within,the,co,group,param,equal,to,arg,the,argument,for,the,equal,to,within,the,co,group,return,the,scatter,function;private,co,group,operator,tuple2,k,message,build,scatter,function,delta,iteration,vertex,k,vv,vertex,k,vv,iteration,type,information,tuple2,k,message,message,type,info,int,where,arg,int,equal,to,arg,data,set,long,value,number,of,vertices,co,group,operator,tuple2,k,message,messages,scatter,udf,with,edge,values,k,vv,vv,message,ev,messenger,new,scatter,udf,with,evs,simple,vv,scatter,function,message,type,info,messages,this,edges,with,value,co,group,iteration,get,workset,where,where,arg,equal,to,equal,to,arg,with,messenger,messages,messages,name,messaging,if,this,configuration,null,for,tuple2,string,data,set,e,this,configuration,get,scatter,bcast,vars,messages,messages,with,broadcast,set,e,f1,e,f0,if,this,configuration,is,opt,num,vertices,messages,messages,with,broadcast,set,number,of,vertices,number,of,vertices,return,messages
ScatterGatherIteration -> private CoGroupOperator<?, ?, Tuple2<K, Message>> buildScatterFunction( 			DeltaIteration<Vertex<K, VV>, Vertex<K, VV>> iteration, 			TypeInformation<Tuple2<K, Message>> messageTypeInfo, int whereArg, int equalToArg, 			DataSet<LongValue> numberOfVertices);1475517578;Method that builds the scatter function using a coGroup operator for a simple vertex (without_degrees)._It afterwards configures the function with a custom name and broadcast variables.__@param iteration_@param messageTypeInfo_@param whereArg the argument for the where within the coGroup_@param equalToArg the argument for the equalTo within the coGroup_@return the scatter function;private CoGroupOperator<?, ?, Tuple2<K, Message>> buildScatterFunction(_			DeltaIteration<Vertex<K, VV>, Vertex<K, VV>> iteration,_			TypeInformation<Tuple2<K, Message>> messageTypeInfo, int whereArg, int equalToArg,_			DataSet<LongValue> numberOfVertices) {__		_		CoGroupOperator<?, ?, Tuple2<K, Message>> messages__		ScatterUdfWithEdgeValues<K, VV, VV, Message, EV> messenger =_				new ScatterUdfWithEVsSimpleVV<>(scatterFunction, messageTypeInfo)___		messages = this.edgesWithValue.coGroup(iteration.getWorkset()).where(whereArg)_				.equalTo(equalToArg).with(messenger)___		_		messages = messages.name("Messaging")__		if(this.configuration != null) {_			for (Tuple2<String, DataSet<?>> e : this.configuration.getScatterBcastVars()) {_				messages = messages.withBroadcastSet(e.f1, e.f0)__			}_			if (this.configuration.isOptNumVertices()) {_				messages = messages.withBroadcastSet(numberOfVertices, "number of vertices")__			}_		}__		return messages__	};method,that,builds,the,scatter,function,using,a,co,group,operator,for,a,simple,vertex,without,degrees,it,afterwards,configures,the,function,with,a,custom,name,and,broadcast,variables,param,iteration,param,message,type,info,param,where,arg,the,argument,for,the,where,within,the,co,group,param,equal,to,arg,the,argument,for,the,equal,to,within,the,co,group,return,the,scatter,function;private,co,group,operator,tuple2,k,message,build,scatter,function,delta,iteration,vertex,k,vv,vertex,k,vv,iteration,type,information,tuple2,k,message,message,type,info,int,where,arg,int,equal,to,arg,data,set,long,value,number,of,vertices,co,group,operator,tuple2,k,message,messages,scatter,udf,with,edge,values,k,vv,vv,message,ev,messenger,new,scatter,udf,with,evs,simple,vv,scatter,function,message,type,info,messages,this,edges,with,value,co,group,iteration,get,workset,where,where,arg,equal,to,equal,to,arg,with,messenger,messages,messages,name,messaging,if,this,configuration,null,for,tuple2,string,data,set,e,this,configuration,get,scatter,bcast,vars,messages,messages,with,broadcast,set,e,f1,e,f0,if,this,configuration,is,opt,num,vertices,messages,messages,with,broadcast,set,number,of,vertices,number,of,vertices,return,messages
ScatterGatherIteration -> private CoGroupOperator<?, ?, Tuple2<K, Message>> buildScatterFunction( 			DeltaIteration<Vertex<K, VV>, Vertex<K, VV>> iteration, 			TypeInformation<Tuple2<K, Message>> messageTypeInfo, int whereArg, int equalToArg, 			DataSet<LongValue> numberOfVertices);1475589042;Method that builds the scatter function using a coGroup operator for a simple vertex (without_degrees)._It afterwards configures the function with a custom name and broadcast variables.__@param iteration_@param messageTypeInfo_@param whereArg the argument for the where within the coGroup_@param equalToArg the argument for the equalTo within the coGroup_@return the scatter function;private CoGroupOperator<?, ?, Tuple2<K, Message>> buildScatterFunction(_			DeltaIteration<Vertex<K, VV>, Vertex<K, VV>> iteration,_			TypeInformation<Tuple2<K, Message>> messageTypeInfo, int whereArg, int equalToArg,_			DataSet<LongValue> numberOfVertices) {__		_		CoGroupOperator<?, ?, Tuple2<K, Message>> messages__		ScatterUdfWithEdgeValues<K, VV, VV, Message, EV> messenger =_				new ScatterUdfWithEVsSimpleVV<>(scatterFunction, messageTypeInfo)___		messages = this.edgesWithValue.coGroup(iteration.getWorkset()).where(whereArg)_				.equalTo(equalToArg).with(messenger)___		_		messages = messages.name("Messaging")__		if(this.configuration != null) {_			for (Tuple2<String, DataSet<?>> e : this.configuration.getScatterBcastVars()) {_				messages = messages.withBroadcastSet(e.f1, e.f0)__			}_			if (this.configuration.isOptNumVertices()) {_				messages = messages.withBroadcastSet(numberOfVertices, "number of vertices")__			}_		}__		return messages__	};method,that,builds,the,scatter,function,using,a,co,group,operator,for,a,simple,vertex,without,degrees,it,afterwards,configures,the,function,with,a,custom,name,and,broadcast,variables,param,iteration,param,message,type,info,param,where,arg,the,argument,for,the,where,within,the,co,group,param,equal,to,arg,the,argument,for,the,equal,to,within,the,co,group,return,the,scatter,function;private,co,group,operator,tuple2,k,message,build,scatter,function,delta,iteration,vertex,k,vv,vertex,k,vv,iteration,type,information,tuple2,k,message,message,type,info,int,where,arg,int,equal,to,arg,data,set,long,value,number,of,vertices,co,group,operator,tuple2,k,message,messages,scatter,udf,with,edge,values,k,vv,vv,message,ev,messenger,new,scatter,udf,with,evs,simple,vv,scatter,function,message,type,info,messages,this,edges,with,value,co,group,iteration,get,workset,where,where,arg,equal,to,equal,to,arg,with,messenger,messages,messages,name,messaging,if,this,configuration,null,for,tuple2,string,data,set,e,this,configuration,get,scatter,bcast,vars,messages,messages,with,broadcast,set,e,f1,e,f0,if,this,configuration,is,opt,num,vertices,messages,messages,with,broadcast,set,number,of,vertices,number,of,vertices,return,messages
ScatterGatherIteration -> private CoGroupOperator<?, ?, Tuple2<K, Message>> buildScatterFunction( 			DeltaIteration<Vertex<K, VV>, Vertex<K, VV>> iteration, 			TypeInformation<Tuple2<K, Message>> messageTypeInfo, int whereArg, int equalToArg, 			DataSet<LongValue> numberOfVertices);1484681137;Method that builds the scatter function using a coGroup operator for a simple vertex (without_degrees)._It afterwards configures the function with a custom name and broadcast variables.__@param iteration_@param messageTypeInfo_@param whereArg the argument for the where within the coGroup_@param equalToArg the argument for the equalTo within the coGroup_@return the scatter function;private CoGroupOperator<?, ?, Tuple2<K, Message>> buildScatterFunction(_			DeltaIteration<Vertex<K, VV>, Vertex<K, VV>> iteration,_			TypeInformation<Tuple2<K, Message>> messageTypeInfo, int whereArg, int equalToArg,_			DataSet<LongValue> numberOfVertices) {__		_		CoGroupOperator<?, ?, Tuple2<K, Message>> messages__		ScatterUdfWithEdgeValues<K, VV, VV, Message, EV> messenger =_				new ScatterUdfWithEVsSimpleVV<>(scatterFunction, messageTypeInfo)___		messages = this.edgesWithValue.coGroup(iteration.getWorkset()).where(whereArg)_				.equalTo(equalToArg).with(messenger)___		_		messages = messages.name("Messaging")__		if(this.configuration != null) {_			for (Tuple2<String, DataSet<?>> e : this.configuration.getScatterBcastVars()) {_				messages = messages.withBroadcastSet(e.f1, e.f0)__			}_			if (this.configuration.isOptNumVertices()) {_				messages = messages.withBroadcastSet(numberOfVertices, "number of vertices")__			}_		}__		return messages__	};method,that,builds,the,scatter,function,using,a,co,group,operator,for,a,simple,vertex,without,degrees,it,afterwards,configures,the,function,with,a,custom,name,and,broadcast,variables,param,iteration,param,message,type,info,param,where,arg,the,argument,for,the,where,within,the,co,group,param,equal,to,arg,the,argument,for,the,equal,to,within,the,co,group,return,the,scatter,function;private,co,group,operator,tuple2,k,message,build,scatter,function,delta,iteration,vertex,k,vv,vertex,k,vv,iteration,type,information,tuple2,k,message,message,type,info,int,where,arg,int,equal,to,arg,data,set,long,value,number,of,vertices,co,group,operator,tuple2,k,message,messages,scatter,udf,with,edge,values,k,vv,vv,message,ev,messenger,new,scatter,udf,with,evs,simple,vv,scatter,function,message,type,info,messages,this,edges,with,value,co,group,iteration,get,workset,where,where,arg,equal,to,equal,to,arg,with,messenger,messages,messages,name,messaging,if,this,configuration,null,for,tuple2,string,data,set,e,this,configuration,get,scatter,bcast,vars,messages,messages,with,broadcast,set,e,f1,e,f0,if,this,configuration,is,opt,num,vertices,messages,messages,with,broadcast,set,number,of,vertices,number,of,vertices,return,messages
ScatterGatherIteration -> private CoGroupOperator<?, ?, Tuple2<K, Message>> buildScatterFunction( 			DeltaIteration<Vertex<K, VV>, Vertex<K, VV>> iteration, 			TypeInformation<Tuple2<K, Message>> messageTypeInfo, int whereArg, int equalToArg, 			DataSet<LongValue> numberOfVertices);1495653033;Method that builds the scatter function using a coGroup operator for a simple vertex (without_degrees)._It afterwards configures the function with a custom name and broadcast variables.__@param iteration_@param messageTypeInfo_@param whereArg the argument for the where within the coGroup_@param equalToArg the argument for the equalTo within the coGroup_@return the scatter function;private CoGroupOperator<?, ?, Tuple2<K, Message>> buildScatterFunction(_			DeltaIteration<Vertex<K, VV>, Vertex<K, VV>> iteration,_			TypeInformation<Tuple2<K, Message>> messageTypeInfo, int whereArg, int equalToArg,_			DataSet<LongValue> numberOfVertices) {__		_		CoGroupOperator<?, ?, Tuple2<K, Message>> messages__		ScatterUdfWithEdgeValues<K, VV, VV, Message, EV> messenger =_				new ScatterUdfWithEVsSimpleVV<>(scatterFunction, messageTypeInfo)___		messages = this.edgesWithValue.coGroup(iteration.getWorkset()).where(whereArg)_				.equalTo(equalToArg).with(messenger)___		_		messages = messages.name("Messaging")__		if (this.configuration != null) {_			for (Tuple2<String, DataSet<?>> e : this.configuration.getScatterBcastVars()) {_				messages = messages.withBroadcastSet(e.f1, e.f0)__			}_			if (this.configuration.isOptNumVertices()) {_				messages = messages.withBroadcastSet(numberOfVertices, "number of vertices")__			}_		}__		return messages__	};method,that,builds,the,scatter,function,using,a,co,group,operator,for,a,simple,vertex,without,degrees,it,afterwards,configures,the,function,with,a,custom,name,and,broadcast,variables,param,iteration,param,message,type,info,param,where,arg,the,argument,for,the,where,within,the,co,group,param,equal,to,arg,the,argument,for,the,equal,to,within,the,co,group,return,the,scatter,function;private,co,group,operator,tuple2,k,message,build,scatter,function,delta,iteration,vertex,k,vv,vertex,k,vv,iteration,type,information,tuple2,k,message,message,type,info,int,where,arg,int,equal,to,arg,data,set,long,value,number,of,vertices,co,group,operator,tuple2,k,message,messages,scatter,udf,with,edge,values,k,vv,vv,message,ev,messenger,new,scatter,udf,with,evs,simple,vv,scatter,function,message,type,info,messages,this,edges,with,value,co,group,iteration,get,workset,where,where,arg,equal,to,equal,to,arg,with,messenger,messages,messages,name,messaging,if,this,configuration,null,for,tuple2,string,data,set,e,this,configuration,get,scatter,bcast,vars,messages,messages,with,broadcast,set,e,f1,e,f0,if,this,configuration,is,opt,num,vertices,messages,messages,with,broadcast,set,number,of,vertices,number,of,vertices,return,messages
ScatterGatherIteration -> private CoGroupOperator<?, ?, Tuple2<K, Message>> buildMessagingFunction( 			DeltaIteration<Vertex<K, VV>, Vertex<K, VV>> iteration, 			TypeInformation<Tuple2<K, Message>> messageTypeInfo, int whereArg, int equalToArg);1452884884;Method that builds the messaging function using a coGroup operator for a simple vertex(without_degrees)._It afterwards configures the function with a custom name and broadcast variables.__@param iteration_@param messageTypeInfo_@param whereArg the argument for the where within the coGroup_@param equalToArg the argument for the equalTo within the coGroup_@return the messaging function;private CoGroupOperator<?, ?, Tuple2<K, Message>> buildMessagingFunction(_			DeltaIteration<Vertex<K, VV>, Vertex<K, VV>> iteration,_			TypeInformation<Tuple2<K, Message>> messageTypeInfo, int whereArg, int equalToArg) {__		_		CoGroupOperator<?, ?, Tuple2<K, Message>> messages__		MessagingUdfWithEdgeValues<K, VV, VV, Message, EV> messenger =_				new MessagingUdfWithEVsSimpleVV<K, VV, Message, EV>(messagingFunction, messageTypeInfo)___		messages = this.edgesWithValue.coGroup(iteration.getWorkset()).where(whereArg)_				.equalTo(equalToArg).with(messenger)___		_		messages = messages.name("Messaging")__		if(this.configuration != null) {_			for (Tuple2<String, DataSet<?>> e : this.configuration.getMessagingBcastVars()) {_				messages = messages.withBroadcastSet(e.f1, e.f0)__			}_		}__		return messages__	};method,that,builds,the,messaging,function,using,a,co,group,operator,for,a,simple,vertex,without,degrees,it,afterwards,configures,the,function,with,a,custom,name,and,broadcast,variables,param,iteration,param,message,type,info,param,where,arg,the,argument,for,the,where,within,the,co,group,param,equal,to,arg,the,argument,for,the,equal,to,within,the,co,group,return,the,messaging,function;private,co,group,operator,tuple2,k,message,build,messaging,function,delta,iteration,vertex,k,vv,vertex,k,vv,iteration,type,information,tuple2,k,message,message,type,info,int,where,arg,int,equal,to,arg,co,group,operator,tuple2,k,message,messages,messaging,udf,with,edge,values,k,vv,vv,message,ev,messenger,new,messaging,udf,with,evs,simple,vv,k,vv,message,ev,messaging,function,message,type,info,messages,this,edges,with,value,co,group,iteration,get,workset,where,where,arg,equal,to,equal,to,arg,with,messenger,messages,messages,name,messaging,if,this,configuration,null,for,tuple2,string,data,set,e,this,configuration,get,messaging,bcast,vars,messages,messages,with,broadcast,set,e,f1,e,f0,return,messages
ScatterGatherIteration -> private CoGroupOperator<?, ?, Tuple2<K, Message>> buildMessagingFunction( 			DeltaIteration<Vertex<K, VV>, Vertex<K, VV>> iteration, 			TypeInformation<Tuple2<K, Message>> messageTypeInfo, int whereArg, int equalToArg);1461669017;Method that builds the messaging function using a coGroup operator for a simple vertex(without_degrees)._It afterwards configures the function with a custom name and broadcast variables.__@param iteration_@param messageTypeInfo_@param whereArg the argument for the where within the coGroup_@param equalToArg the argument for the equalTo within the coGroup_@return the messaging function;private CoGroupOperator<?, ?, Tuple2<K, Message>> buildMessagingFunction(_			DeltaIteration<Vertex<K, VV>, Vertex<K, VV>> iteration,_			TypeInformation<Tuple2<K, Message>> messageTypeInfo, int whereArg, int equalToArg) {__		_		CoGroupOperator<?, ?, Tuple2<K, Message>> messages__		MessagingUdfWithEdgeValues<K, VV, VV, Message, EV> messenger =_				new MessagingUdfWithEVsSimpleVV<K, VV, Message, EV>(messagingFunction, messageTypeInfo)___		messages = this.edgesWithValue.coGroup(iteration.getWorkset()).where(whereArg)_				.equalTo(equalToArg).with(messenger)___		_		messages = messages.name("Messaging")__		if(this.configuration != null) {_			for (Tuple2<String, DataSet<?>> e : this.configuration.getMessagingBcastVars()) {_				messages = messages.withBroadcastSet(e.f1, e.f0)__			}_		}__		return messages__	};method,that,builds,the,messaging,function,using,a,co,group,operator,for,a,simple,vertex,without,degrees,it,afterwards,configures,the,function,with,a,custom,name,and,broadcast,variables,param,iteration,param,message,type,info,param,where,arg,the,argument,for,the,where,within,the,co,group,param,equal,to,arg,the,argument,for,the,equal,to,within,the,co,group,return,the,messaging,function;private,co,group,operator,tuple2,k,message,build,messaging,function,delta,iteration,vertex,k,vv,vertex,k,vv,iteration,type,information,tuple2,k,message,message,type,info,int,where,arg,int,equal,to,arg,co,group,operator,tuple2,k,message,messages,messaging,udf,with,edge,values,k,vv,vv,message,ev,messenger,new,messaging,udf,with,evs,simple,vv,k,vv,message,ev,messaging,function,message,type,info,messages,this,edges,with,value,co,group,iteration,get,workset,where,where,arg,equal,to,equal,to,arg,with,messenger,messages,messages,name,messaging,if,this,configuration,null,for,tuple2,string,data,set,e,this,configuration,get,messaging,bcast,vars,messages,messages,with,broadcast,set,e,f1,e,f0,return,messages
ScatterGatherIteration -> private CoGroupOperator<?, ?, Tuple2<K, Message>> buildScatterFunctionVerticesWithDegrees( 			DeltaIteration<Vertex<K, Tuple3<VV, LongValue, LongValue>>, Vertex<K, Tuple3<VV, LongValue, LongValue>>> iteration, 			TypeInformation<Tuple2<K, Message>> messageTypeInfo, int whereArg, int equalToArg, 			DataSet<LongValue> numberOfVertices);1462563578;Method that builds the scatter function using a coGroup operator for a vertex_containing degree information._It afterwards configures the function with a custom name and broadcast variables.__@param iteration_@param messageTypeInfo_@param whereArg the argument for the where within the coGroup_@param equalToArg the argument for the equalTo within the coGroup_@return the scatter function;private CoGroupOperator<?, ?, Tuple2<K, Message>> buildScatterFunctionVerticesWithDegrees(_			DeltaIteration<Vertex<K, Tuple3<VV, LongValue, LongValue>>, Vertex<K, Tuple3<VV, LongValue, LongValue>>> iteration,_			TypeInformation<Tuple2<K, Message>> messageTypeInfo, int whereArg, int equalToArg,_			DataSet<LongValue> numberOfVertices) {__		_		CoGroupOperator<?, ?, Tuple2<K, Message>> messages__		ScatterUdfWithEdgeValues<K, Tuple3<VV, LongValue, LongValue>, VV, Message, EV> messenger =_				new ScatterUdfWithEVsVVWithDegrees<>(scatterFunction, messageTypeInfo)___		messages = this.edgesWithValue.coGroup(iteration.getWorkset()).where(whereArg)_				.equalTo(equalToArg).with(messenger)___		_		messages = messages.name("Messaging")___		if (this.configuration != null) {_			for (Tuple2<String, DataSet<?>> e : this.configuration.getScatterBcastVars()) {_				messages = messages.withBroadcastSet(e.f1, e.f0)__			}_			if (this.configuration.isOptNumVertices()) {_				messages = messages.withBroadcastSet(numberOfVertices, "number of vertices")__			}_		}__		return messages__	};method,that,builds,the,scatter,function,using,a,co,group,operator,for,a,vertex,containing,degree,information,it,afterwards,configures,the,function,with,a,custom,name,and,broadcast,variables,param,iteration,param,message,type,info,param,where,arg,the,argument,for,the,where,within,the,co,group,param,equal,to,arg,the,argument,for,the,equal,to,within,the,co,group,return,the,scatter,function;private,co,group,operator,tuple2,k,message,build,scatter,function,vertices,with,degrees,delta,iteration,vertex,k,tuple3,vv,long,value,long,value,vertex,k,tuple3,vv,long,value,long,value,iteration,type,information,tuple2,k,message,message,type,info,int,where,arg,int,equal,to,arg,data,set,long,value,number,of,vertices,co,group,operator,tuple2,k,message,messages,scatter,udf,with,edge,values,k,tuple3,vv,long,value,long,value,vv,message,ev,messenger,new,scatter,udf,with,evs,vvwith,degrees,scatter,function,message,type,info,messages,this,edges,with,value,co,group,iteration,get,workset,where,where,arg,equal,to,equal,to,arg,with,messenger,messages,messages,name,messaging,if,this,configuration,null,for,tuple2,string,data,set,e,this,configuration,get,scatter,bcast,vars,messages,messages,with,broadcast,set,e,f1,e,f0,if,this,configuration,is,opt,num,vertices,messages,messages,with,broadcast,set,number,of,vertices,number,of,vertices,return,messages
ScatterGatherIteration -> private CoGroupOperator<?, ?, Tuple2<K, Message>> buildScatterFunctionVerticesWithDegrees( 			DeltaIteration<Vertex<K, Tuple3<VV, LongValue, LongValue>>, Vertex<K, Tuple3<VV, LongValue, LongValue>>> iteration, 			TypeInformation<Tuple2<K, Message>> messageTypeInfo, int whereArg, int equalToArg, 			DataSet<LongValue> numberOfVertices);1475517578;Method that builds the scatter function using a coGroup operator for a vertex_containing degree information._It afterwards configures the function with a custom name and broadcast variables.__@param iteration_@param messageTypeInfo_@param whereArg the argument for the where within the coGroup_@param equalToArg the argument for the equalTo within the coGroup_@return the scatter function;private CoGroupOperator<?, ?, Tuple2<K, Message>> buildScatterFunctionVerticesWithDegrees(_			DeltaIteration<Vertex<K, Tuple3<VV, LongValue, LongValue>>, Vertex<K, Tuple3<VV, LongValue, LongValue>>> iteration,_			TypeInformation<Tuple2<K, Message>> messageTypeInfo, int whereArg, int equalToArg,_			DataSet<LongValue> numberOfVertices) {__		_		CoGroupOperator<?, ?, Tuple2<K, Message>> messages__		ScatterUdfWithEdgeValues<K, Tuple3<VV, LongValue, LongValue>, VV, Message, EV> messenger =_				new ScatterUdfWithEVsVVWithDegrees<>(scatterFunction, messageTypeInfo)___		messages = this.edgesWithValue.coGroup(iteration.getWorkset()).where(whereArg)_				.equalTo(equalToArg).with(messenger)___		_		messages = messages.name("Messaging")___		if (this.configuration != null) {_			for (Tuple2<String, DataSet<?>> e : this.configuration.getScatterBcastVars()) {_				messages = messages.withBroadcastSet(e.f1, e.f0)__			}_			if (this.configuration.isOptNumVertices()) {_				messages = messages.withBroadcastSet(numberOfVertices, "number of vertices")__			}_		}__		return messages__	};method,that,builds,the,scatter,function,using,a,co,group,operator,for,a,vertex,containing,degree,information,it,afterwards,configures,the,function,with,a,custom,name,and,broadcast,variables,param,iteration,param,message,type,info,param,where,arg,the,argument,for,the,where,within,the,co,group,param,equal,to,arg,the,argument,for,the,equal,to,within,the,co,group,return,the,scatter,function;private,co,group,operator,tuple2,k,message,build,scatter,function,vertices,with,degrees,delta,iteration,vertex,k,tuple3,vv,long,value,long,value,vertex,k,tuple3,vv,long,value,long,value,iteration,type,information,tuple2,k,message,message,type,info,int,where,arg,int,equal,to,arg,data,set,long,value,number,of,vertices,co,group,operator,tuple2,k,message,messages,scatter,udf,with,edge,values,k,tuple3,vv,long,value,long,value,vv,message,ev,messenger,new,scatter,udf,with,evs,vvwith,degrees,scatter,function,message,type,info,messages,this,edges,with,value,co,group,iteration,get,workset,where,where,arg,equal,to,equal,to,arg,with,messenger,messages,messages,name,messaging,if,this,configuration,null,for,tuple2,string,data,set,e,this,configuration,get,scatter,bcast,vars,messages,messages,with,broadcast,set,e,f1,e,f0,if,this,configuration,is,opt,num,vertices,messages,messages,with,broadcast,set,number,of,vertices,number,of,vertices,return,messages
ScatterGatherIteration -> private CoGroupOperator<?, ?, Tuple2<K, Message>> buildScatterFunctionVerticesWithDegrees( 			DeltaIteration<Vertex<K, Tuple3<VV, LongValue, LongValue>>, Vertex<K, Tuple3<VV, LongValue, LongValue>>> iteration, 			TypeInformation<Tuple2<K, Message>> messageTypeInfo, int whereArg, int equalToArg, 			DataSet<LongValue> numberOfVertices);1475589042;Method that builds the scatter function using a coGroup operator for a vertex_containing degree information._It afterwards configures the function with a custom name and broadcast variables.__@param iteration_@param messageTypeInfo_@param whereArg the argument for the where within the coGroup_@param equalToArg the argument for the equalTo within the coGroup_@return the scatter function;private CoGroupOperator<?, ?, Tuple2<K, Message>> buildScatterFunctionVerticesWithDegrees(_			DeltaIteration<Vertex<K, Tuple3<VV, LongValue, LongValue>>, Vertex<K, Tuple3<VV, LongValue, LongValue>>> iteration,_			TypeInformation<Tuple2<K, Message>> messageTypeInfo, int whereArg, int equalToArg,_			DataSet<LongValue> numberOfVertices) {__		_		CoGroupOperator<?, ?, Tuple2<K, Message>> messages__		ScatterUdfWithEdgeValues<K, Tuple3<VV, LongValue, LongValue>, VV, Message, EV> messenger =_				new ScatterUdfWithEVsVVWithDegrees<>(scatterFunction, messageTypeInfo)___		messages = this.edgesWithValue.coGroup(iteration.getWorkset()).where(whereArg)_				.equalTo(equalToArg).with(messenger)___		_		messages = messages.name("Messaging")___		if (this.configuration != null) {_			for (Tuple2<String, DataSet<?>> e : this.configuration.getScatterBcastVars()) {_				messages = messages.withBroadcastSet(e.f1, e.f0)__			}_			if (this.configuration.isOptNumVertices()) {_				messages = messages.withBroadcastSet(numberOfVertices, "number of vertices")__			}_		}__		return messages__	};method,that,builds,the,scatter,function,using,a,co,group,operator,for,a,vertex,containing,degree,information,it,afterwards,configures,the,function,with,a,custom,name,and,broadcast,variables,param,iteration,param,message,type,info,param,where,arg,the,argument,for,the,where,within,the,co,group,param,equal,to,arg,the,argument,for,the,equal,to,within,the,co,group,return,the,scatter,function;private,co,group,operator,tuple2,k,message,build,scatter,function,vertices,with,degrees,delta,iteration,vertex,k,tuple3,vv,long,value,long,value,vertex,k,tuple3,vv,long,value,long,value,iteration,type,information,tuple2,k,message,message,type,info,int,where,arg,int,equal,to,arg,data,set,long,value,number,of,vertices,co,group,operator,tuple2,k,message,messages,scatter,udf,with,edge,values,k,tuple3,vv,long,value,long,value,vv,message,ev,messenger,new,scatter,udf,with,evs,vvwith,degrees,scatter,function,message,type,info,messages,this,edges,with,value,co,group,iteration,get,workset,where,where,arg,equal,to,equal,to,arg,with,messenger,messages,messages,name,messaging,if,this,configuration,null,for,tuple2,string,data,set,e,this,configuration,get,scatter,bcast,vars,messages,messages,with,broadcast,set,e,f1,e,f0,if,this,configuration,is,opt,num,vertices,messages,messages,with,broadcast,set,number,of,vertices,number,of,vertices,return,messages
ScatterGatherIteration -> private CoGroupOperator<?, ?, Tuple2<K, Message>> buildScatterFunctionVerticesWithDegrees( 			DeltaIteration<Vertex<K, Tuple3<VV, LongValue, LongValue>>, Vertex<K, Tuple3<VV, LongValue, LongValue>>> iteration, 			TypeInformation<Tuple2<K, Message>> messageTypeInfo, int whereArg, int equalToArg, 			DataSet<LongValue> numberOfVertices);1484681137;Method that builds the scatter function using a coGroup operator for a vertex_containing degree information._It afterwards configures the function with a custom name and broadcast variables.__@param iteration_@param messageTypeInfo_@param whereArg the argument for the where within the coGroup_@param equalToArg the argument for the equalTo within the coGroup_@return the scatter function;private CoGroupOperator<?, ?, Tuple2<K, Message>> buildScatterFunctionVerticesWithDegrees(_			DeltaIteration<Vertex<K, Tuple3<VV, LongValue, LongValue>>, Vertex<K, Tuple3<VV, LongValue, LongValue>>> iteration,_			TypeInformation<Tuple2<K, Message>> messageTypeInfo, int whereArg, int equalToArg,_			DataSet<LongValue> numberOfVertices) {__		_		CoGroupOperator<?, ?, Tuple2<K, Message>> messages__		ScatterUdfWithEdgeValues<K, Tuple3<VV, LongValue, LongValue>, VV, Message, EV> messenger =_				new ScatterUdfWithEVsVVWithDegrees<>(scatterFunction, messageTypeInfo)___		messages = this.edgesWithValue.coGroup(iteration.getWorkset()).where(whereArg)_				.equalTo(equalToArg).with(messenger)___		_		messages = messages.name("Messaging")___		if (this.configuration != null) {_			for (Tuple2<String, DataSet<?>> e : this.configuration.getScatterBcastVars()) {_				messages = messages.withBroadcastSet(e.f1, e.f0)__			}_			if (this.configuration.isOptNumVertices()) {_				messages = messages.withBroadcastSet(numberOfVertices, "number of vertices")__			}_		}__		return messages__	};method,that,builds,the,scatter,function,using,a,co,group,operator,for,a,vertex,containing,degree,information,it,afterwards,configures,the,function,with,a,custom,name,and,broadcast,variables,param,iteration,param,message,type,info,param,where,arg,the,argument,for,the,where,within,the,co,group,param,equal,to,arg,the,argument,for,the,equal,to,within,the,co,group,return,the,scatter,function;private,co,group,operator,tuple2,k,message,build,scatter,function,vertices,with,degrees,delta,iteration,vertex,k,tuple3,vv,long,value,long,value,vertex,k,tuple3,vv,long,value,long,value,iteration,type,information,tuple2,k,message,message,type,info,int,where,arg,int,equal,to,arg,data,set,long,value,number,of,vertices,co,group,operator,tuple2,k,message,messages,scatter,udf,with,edge,values,k,tuple3,vv,long,value,long,value,vv,message,ev,messenger,new,scatter,udf,with,evs,vvwith,degrees,scatter,function,message,type,info,messages,this,edges,with,value,co,group,iteration,get,workset,where,where,arg,equal,to,equal,to,arg,with,messenger,messages,messages,name,messaging,if,this,configuration,null,for,tuple2,string,data,set,e,this,configuration,get,scatter,bcast,vars,messages,messages,with,broadcast,set,e,f1,e,f0,if,this,configuration,is,opt,num,vertices,messages,messages,with,broadcast,set,number,of,vertices,number,of,vertices,return,messages
ScatterGatherIteration -> private CoGroupOperator<?, ?, Tuple2<K, Message>> buildScatterFunctionVerticesWithDegrees( 			DeltaIteration<Vertex<K, Tuple3<VV, LongValue, LongValue>>, Vertex<K, Tuple3<VV, LongValue, LongValue>>> iteration, 			TypeInformation<Tuple2<K, Message>> messageTypeInfo, int whereArg, int equalToArg, 			DataSet<LongValue> numberOfVertices);1495653033;Method that builds the scatter function using a coGroup operator for a vertex_containing degree information._It afterwards configures the function with a custom name and broadcast variables.__@param iteration_@param messageTypeInfo_@param whereArg the argument for the where within the coGroup_@param equalToArg the argument for the equalTo within the coGroup_@return the scatter function;private CoGroupOperator<?, ?, Tuple2<K, Message>> buildScatterFunctionVerticesWithDegrees(_			DeltaIteration<Vertex<K, Tuple3<VV, LongValue, LongValue>>, Vertex<K, Tuple3<VV, LongValue, LongValue>>> iteration,_			TypeInformation<Tuple2<K, Message>> messageTypeInfo, int whereArg, int equalToArg,_			DataSet<LongValue> numberOfVertices) {__		_		CoGroupOperator<?, ?, Tuple2<K, Message>> messages__		ScatterUdfWithEdgeValues<K, Tuple3<VV, LongValue, LongValue>, VV, Message, EV> messenger =_				new ScatterUdfWithEVsVVWithDegrees<>(scatterFunction, messageTypeInfo)___		messages = this.edgesWithValue.coGroup(iteration.getWorkset()).where(whereArg)_				.equalTo(equalToArg).with(messenger)___		_		messages = messages.name("Messaging")___		if (this.configuration != null) {_			for (Tuple2<String, DataSet<?>> e : this.configuration.getScatterBcastVars()) {_				messages = messages.withBroadcastSet(e.f1, e.f0)__			}_			if (this.configuration.isOptNumVertices()) {_				messages = messages.withBroadcastSet(numberOfVertices, "number of vertices")__			}_		}__		return messages__	};method,that,builds,the,scatter,function,using,a,co,group,operator,for,a,vertex,containing,degree,information,it,afterwards,configures,the,function,with,a,custom,name,and,broadcast,variables,param,iteration,param,message,type,info,param,where,arg,the,argument,for,the,where,within,the,co,group,param,equal,to,arg,the,argument,for,the,equal,to,within,the,co,group,return,the,scatter,function;private,co,group,operator,tuple2,k,message,build,scatter,function,vertices,with,degrees,delta,iteration,vertex,k,tuple3,vv,long,value,long,value,vertex,k,tuple3,vv,long,value,long,value,iteration,type,information,tuple2,k,message,message,type,info,int,where,arg,int,equal,to,arg,data,set,long,value,number,of,vertices,co,group,operator,tuple2,k,message,messages,scatter,udf,with,edge,values,k,tuple3,vv,long,value,long,value,vv,message,ev,messenger,new,scatter,udf,with,evs,vvwith,degrees,scatter,function,message,type,info,messages,this,edges,with,value,co,group,iteration,get,workset,where,where,arg,equal,to,equal,to,arg,with,messenger,messages,messages,name,messaging,if,this,configuration,null,for,tuple2,string,data,set,e,this,configuration,get,scatter,bcast,vars,messages,messages,with,broadcast,set,e,f1,e,f0,if,this,configuration,is,opt,num,vertices,messages,messages,with,broadcast,set,number,of,vertices,number,of,vertices,return,messages
ScatterGatherIteration -> @SuppressWarnings("serial") 	private DataSet<Vertex<K, VV>> createResultVerticesWithDegrees(Graph<K, VV, EV> graph, EdgeDirection messagingDirection, 			TypeInformation<Tuple2<K, Message>> messageTypeInfo);1452884884;Creates the operator that represents this scatter-gather graph computation for a vertex with in_and out degrees added to the vertex value.__@param graph_@param messagingDirection_@param messageTypeInfo_@return the operator;@SuppressWarnings("serial")_	private DataSet<Vertex<K, VV>> createResultVerticesWithDegrees(Graph<K, VV, EV> graph, EdgeDirection messagingDirection,_			TypeInformation<Tuple2<K, Message>> messageTypeInfo) {__		DataSet<Tuple2<K, Message>> messages___		this.updateFunction.setOptDegrees(this.configuration.isOptDegrees())___		DataSet<Tuple2<K, Long>> inDegrees = graph.inDegrees()__		DataSet<Tuple2<K, Long>> outDegrees = graph.outDegrees()___		DataSet<Tuple3<K, Long, Long>> degrees = inDegrees.join(outDegrees).where(0).equalTo(0)_				.with(new FlatJoinFunction<Tuple2<K, Long>, Tuple2<K, Long>, Tuple3<K, Long, Long>>() {__					@Override_					public void join(Tuple2<K, Long> first, Tuple2<K, Long> second,	Collector<Tuple3<K, Long, Long>> out) {_						out.collect(new Tuple3<K, Long, Long>(first.f0, first.f1, second.f1))__					}_				}).withForwardedFieldsFirst("f0_f1").withForwardedFieldsSecond("f1")___		DataSet<Vertex<K, Tuple3<VV, Long, Long>>> verticesWithDegrees = initialVertices_				.join(degrees).where(0).equalTo(0)_				.with(new FlatJoinFunction<Vertex<K,VV>, Tuple3<K,Long,Long>, Vertex<K, Tuple3<VV, Long, Long>>>() {_					@Override_					public void join(Vertex<K, VV> vertex, Tuple3<K, Long, Long> degrees,_									Collector<Vertex<K, Tuple3<VV, Long, Long>>> out) throws Exception {__						out.collect(new Vertex<K, Tuple3<VV, Long, Long>>(vertex.getId(),_								new Tuple3<VV, Long, Long>(vertex.getValue(), degrees.f1, degrees.f2)))__					}_				}).withForwardedFieldsFirst("f0")___		_		TypeInformation<Vertex<K, Tuple3<VV, Long, Long>>> vertexTypes = verticesWithDegrees.getType()___		final DeltaIteration<Vertex<K, Tuple3<VV, Long, Long>>,	Vertex<K, Tuple3<VV, Long, Long>>> iteration =_				verticesWithDegrees.iterateDelta(verticesWithDegrees, this.maximumNumberOfIterations, 0)__				setUpIteration(iteration)___		switch (messagingDirection) {_			case IN:_				messages = buildMessagingFunctionVerticesWithDegrees(iteration, messageTypeInfo, 1, 0)__				break__			case OUT:_				messages = buildMessagingFunctionVerticesWithDegrees(iteration, messageTypeInfo, 0, 0)__				break__			case ALL:_				messages = buildMessagingFunctionVerticesWithDegrees(iteration, messageTypeInfo, 1, 0)_						.union(buildMessagingFunctionVerticesWithDegrees(iteration, messageTypeInfo, 0, 0)) __				break__			default:_				throw new IllegalArgumentException("Illegal edge direction")__		}__		@SuppressWarnings({ "unchecked", "rawtypes" })_		VertexUpdateUdf<K, Tuple3<VV, Long, Long>, Message> updateUdf =_				new VertexUpdateUdfVVWithDegrees(updateFunction, vertexTypes)___		_		CoGroupOperator<?, ?, Vertex<K, Tuple3<VV, Long, Long>>> updates =_				messages.coGroup(iteration.getSolutionSet()).where(0).equalTo(0).with(updateUdf)___		configureUpdateFunction(updates)___		return iteration.closeWith(updates, updates).map(_				new MapFunction<Vertex<K, Tuple3<VV, Long, Long>>, Vertex<K, VV>>() {__					public Vertex<K, VV> map(Vertex<K, Tuple3<VV, Long, Long>> vertex) {_						return new Vertex<K, VV>(vertex.getId(), vertex.getValue().f0)__					}_				})__	};creates,the,operator,that,represents,this,scatter,gather,graph,computation,for,a,vertex,with,in,and,out,degrees,added,to,the,vertex,value,param,graph,param,messaging,direction,param,message,type,info,return,the,operator;suppress,warnings,serial,private,data,set,vertex,k,vv,create,result,vertices,with,degrees,graph,k,vv,ev,graph,edge,direction,messaging,direction,type,information,tuple2,k,message,message,type,info,data,set,tuple2,k,message,messages,this,update,function,set,opt,degrees,this,configuration,is,opt,degrees,data,set,tuple2,k,long,in,degrees,graph,in,degrees,data,set,tuple2,k,long,out,degrees,graph,out,degrees,data,set,tuple3,k,long,long,degrees,in,degrees,join,out,degrees,where,0,equal,to,0,with,new,flat,join,function,tuple2,k,long,tuple2,k,long,tuple3,k,long,long,override,public,void,join,tuple2,k,long,first,tuple2,k,long,second,collector,tuple3,k,long,long,out,out,collect,new,tuple3,k,long,long,first,f0,first,f1,second,f1,with,forwarded,fields,first,f0,f1,with,forwarded,fields,second,f1,data,set,vertex,k,tuple3,vv,long,long,vertices,with,degrees,initial,vertices,join,degrees,where,0,equal,to,0,with,new,flat,join,function,vertex,k,vv,tuple3,k,long,long,vertex,k,tuple3,vv,long,long,override,public,void,join,vertex,k,vv,vertex,tuple3,k,long,long,degrees,collector,vertex,k,tuple3,vv,long,long,out,throws,exception,out,collect,new,vertex,k,tuple3,vv,long,long,vertex,get,id,new,tuple3,vv,long,long,vertex,get,value,degrees,f1,degrees,f2,with,forwarded,fields,first,f0,type,information,vertex,k,tuple3,vv,long,long,vertex,types,vertices,with,degrees,get,type,final,delta,iteration,vertex,k,tuple3,vv,long,long,vertex,k,tuple3,vv,long,long,iteration,vertices,with,degrees,iterate,delta,vertices,with,degrees,this,maximum,number,of,iterations,0,set,up,iteration,iteration,switch,messaging,direction,case,in,messages,build,messaging,function,vertices,with,degrees,iteration,message,type,info,1,0,break,case,out,messages,build,messaging,function,vertices,with,degrees,iteration,message,type,info,0,0,break,case,all,messages,build,messaging,function,vertices,with,degrees,iteration,message,type,info,1,0,union,build,messaging,function,vertices,with,degrees,iteration,message,type,info,0,0,break,default,throw,new,illegal,argument,exception,illegal,edge,direction,suppress,warnings,unchecked,rawtypes,vertex,update,udf,k,tuple3,vv,long,long,message,update,udf,new,vertex,update,udf,vvwith,degrees,update,function,vertex,types,co,group,operator,vertex,k,tuple3,vv,long,long,updates,messages,co,group,iteration,get,solution,set,where,0,equal,to,0,with,update,udf,configure,update,function,updates,return,iteration,close,with,updates,updates,map,new,map,function,vertex,k,tuple3,vv,long,long,vertex,k,vv,public,vertex,k,vv,map,vertex,k,tuple3,vv,long,long,vertex,return,new,vertex,k,vv,vertex,get,id,vertex,get,value,f0
ScatterGatherIteration -> @SuppressWarnings("serial") 	private DataSet<Vertex<K, VV>> createResultVerticesWithDegrees(Graph<K, VV, EV> graph, EdgeDirection messagingDirection, 			TypeInformation<Tuple2<K, Message>> messageTypeInfo);1461669017;Creates the operator that represents this scatter-gather graph computation for a vertex with in_and out degrees added to the vertex value.__@param graph_@param messagingDirection_@param messageTypeInfo_@return the operator;@SuppressWarnings("serial")_	private DataSet<Vertex<K, VV>> createResultVerticesWithDegrees(Graph<K, VV, EV> graph, EdgeDirection messagingDirection,_			TypeInformation<Tuple2<K, Message>> messageTypeInfo) {__		DataSet<Tuple2<K, Message>> messages___		this.updateFunction.setOptDegrees(this.configuration.isOptDegrees())___		DataSet<Tuple2<K, Long>> inDegrees = graph.inDegrees()__		DataSet<Tuple2<K, Long>> outDegrees = graph.outDegrees()___		DataSet<Tuple3<K, Long, Long>> degrees = inDegrees.join(outDegrees).where(0).equalTo(0)_				.with(new FlatJoinFunction<Tuple2<K, Long>, Tuple2<K, Long>, Tuple3<K, Long, Long>>() {__					@Override_					public void join(Tuple2<K, Long> first, Tuple2<K, Long> second,	Collector<Tuple3<K, Long, Long>> out) {_						out.collect(new Tuple3<K, Long, Long>(first.f0, first.f1, second.f1))__					}_				}).withForwardedFieldsFirst("f0_f1").withForwardedFieldsSecond("f1")___		DataSet<Vertex<K, Tuple3<VV, Long, Long>>> verticesWithDegrees = initialVertices_				.join(degrees).where(0).equalTo(0)_				.with(new FlatJoinFunction<Vertex<K,VV>, Tuple3<K,Long,Long>, Vertex<K, Tuple3<VV, Long, Long>>>() {_					@Override_					public void join(Vertex<K, VV> vertex, Tuple3<K, Long, Long> degrees,_									Collector<Vertex<K, Tuple3<VV, Long, Long>>> out) throws Exception {__						out.collect(new Vertex<K, Tuple3<VV, Long, Long>>(vertex.getId(),_								new Tuple3<VV, Long, Long>(vertex.getValue(), degrees.f1, degrees.f2)))__					}_				}).withForwardedFieldsFirst("f0")___		_		TypeInformation<Vertex<K, Tuple3<VV, Long, Long>>> vertexTypes = verticesWithDegrees.getType()___		final DeltaIteration<Vertex<K, Tuple3<VV, Long, Long>>,	Vertex<K, Tuple3<VV, Long, Long>>> iteration =_				verticesWithDegrees.iterateDelta(verticesWithDegrees, this.maximumNumberOfIterations, 0)__				setUpIteration(iteration)___		switch (messagingDirection) {_			case IN:_				messages = buildMessagingFunctionVerticesWithDegrees(iteration, messageTypeInfo, 1, 0)__				break__			case OUT:_				messages = buildMessagingFunctionVerticesWithDegrees(iteration, messageTypeInfo, 0, 0)__				break__			case ALL:_				messages = buildMessagingFunctionVerticesWithDegrees(iteration, messageTypeInfo, 1, 0)_						.union(buildMessagingFunctionVerticesWithDegrees(iteration, messageTypeInfo, 0, 0)) __				break__			default:_				throw new IllegalArgumentException("Illegal edge direction")__		}__		@SuppressWarnings({ "unchecked", "rawtypes" })_		VertexUpdateUdf<K, Tuple3<VV, Long, Long>, Message> updateUdf =_				new VertexUpdateUdfVVWithDegrees(updateFunction, vertexTypes)___		_		CoGroupOperator<?, ?, Vertex<K, Tuple3<VV, Long, Long>>> updates =_				messages.coGroup(iteration.getSolutionSet()).where(0).equalTo(0).with(updateUdf)___		configureUpdateFunction(updates)___		return iteration.closeWith(updates, updates).map(_				new MapFunction<Vertex<K, Tuple3<VV, Long, Long>>, Vertex<K, VV>>() {__					public Vertex<K, VV> map(Vertex<K, Tuple3<VV, Long, Long>> vertex) {_						return new Vertex<K, VV>(vertex.getId(), vertex.getValue().f0)__					}_				})__	};creates,the,operator,that,represents,this,scatter,gather,graph,computation,for,a,vertex,with,in,and,out,degrees,added,to,the,vertex,value,param,graph,param,messaging,direction,param,message,type,info,return,the,operator;suppress,warnings,serial,private,data,set,vertex,k,vv,create,result,vertices,with,degrees,graph,k,vv,ev,graph,edge,direction,messaging,direction,type,information,tuple2,k,message,message,type,info,data,set,tuple2,k,message,messages,this,update,function,set,opt,degrees,this,configuration,is,opt,degrees,data,set,tuple2,k,long,in,degrees,graph,in,degrees,data,set,tuple2,k,long,out,degrees,graph,out,degrees,data,set,tuple3,k,long,long,degrees,in,degrees,join,out,degrees,where,0,equal,to,0,with,new,flat,join,function,tuple2,k,long,tuple2,k,long,tuple3,k,long,long,override,public,void,join,tuple2,k,long,first,tuple2,k,long,second,collector,tuple3,k,long,long,out,out,collect,new,tuple3,k,long,long,first,f0,first,f1,second,f1,with,forwarded,fields,first,f0,f1,with,forwarded,fields,second,f1,data,set,vertex,k,tuple3,vv,long,long,vertices,with,degrees,initial,vertices,join,degrees,where,0,equal,to,0,with,new,flat,join,function,vertex,k,vv,tuple3,k,long,long,vertex,k,tuple3,vv,long,long,override,public,void,join,vertex,k,vv,vertex,tuple3,k,long,long,degrees,collector,vertex,k,tuple3,vv,long,long,out,throws,exception,out,collect,new,vertex,k,tuple3,vv,long,long,vertex,get,id,new,tuple3,vv,long,long,vertex,get,value,degrees,f1,degrees,f2,with,forwarded,fields,first,f0,type,information,vertex,k,tuple3,vv,long,long,vertex,types,vertices,with,degrees,get,type,final,delta,iteration,vertex,k,tuple3,vv,long,long,vertex,k,tuple3,vv,long,long,iteration,vertices,with,degrees,iterate,delta,vertices,with,degrees,this,maximum,number,of,iterations,0,set,up,iteration,iteration,switch,messaging,direction,case,in,messages,build,messaging,function,vertices,with,degrees,iteration,message,type,info,1,0,break,case,out,messages,build,messaging,function,vertices,with,degrees,iteration,message,type,info,0,0,break,case,all,messages,build,messaging,function,vertices,with,degrees,iteration,message,type,info,1,0,union,build,messaging,function,vertices,with,degrees,iteration,message,type,info,0,0,break,default,throw,new,illegal,argument,exception,illegal,edge,direction,suppress,warnings,unchecked,rawtypes,vertex,update,udf,k,tuple3,vv,long,long,message,update,udf,new,vertex,update,udf,vvwith,degrees,update,function,vertex,types,co,group,operator,vertex,k,tuple3,vv,long,long,updates,messages,co,group,iteration,get,solution,set,where,0,equal,to,0,with,update,udf,configure,update,function,updates,return,iteration,close,with,updates,updates,map,new,map,function,vertex,k,tuple3,vv,long,long,vertex,k,vv,public,vertex,k,vv,map,vertex,k,tuple3,vv,long,long,vertex,return,new,vertex,k,vv,vertex,get,id,vertex,get,value,f0
ScatterGatherIteration -> private DataSet<Vertex<K, VV>> createResultSimpleVertex(EdgeDirection messagingDirection, 		TypeInformation<Tuple2<K, Message>> messageTypeInfo);1452884884;Creates the operator that represents this scatter-gather graph computation for a simple vertex.__@param messagingDirection_@param messageTypeInfo_@return the operator;private DataSet<Vertex<K, VV>> createResultSimpleVertex(EdgeDirection messagingDirection,_		TypeInformation<Tuple2<K, Message>> messageTypeInfo) {__		DataSet<Tuple2<K, Message>> messages___		TypeInformation<Vertex<K, VV>> vertexTypes = initialVertices.getType()___		final DeltaIteration<Vertex<K, VV>,	Vertex<K, VV>> iteration =_				initialVertices.iterateDelta(initialVertices, this.maximumNumberOfIterations, 0)__				setUpIteration(iteration)___		switch (messagingDirection) {_			case IN:_				messages = buildMessagingFunction(iteration, messageTypeInfo, 1, 0)__				break__			case OUT:_				messages = buildMessagingFunction(iteration, messageTypeInfo, 0, 0)__				break__			case ALL:_				messages = buildMessagingFunction(iteration, messageTypeInfo, 1, 0)_						.union(buildMessagingFunction(iteration, messageTypeInfo, 0, 0)) __				break__			default:_				throw new IllegalArgumentException("Illegal edge direction")__		}__		VertexUpdateUdf<K, VV, Message> updateUdf =_				new VertexUpdateUdfSimpleVV<K, VV, Message>(updateFunction, vertexTypes)___		_		CoGroupOperator<?, ?, Vertex<K, VV>> updates =_				messages.coGroup(iteration.getSolutionSet()).where(0).equalTo(0).with(updateUdf)___		configureUpdateFunction(updates)___		return iteration.closeWith(updates, updates)__	};creates,the,operator,that,represents,this,scatter,gather,graph,computation,for,a,simple,vertex,param,messaging,direction,param,message,type,info,return,the,operator;private,data,set,vertex,k,vv,create,result,simple,vertex,edge,direction,messaging,direction,type,information,tuple2,k,message,message,type,info,data,set,tuple2,k,message,messages,type,information,vertex,k,vv,vertex,types,initial,vertices,get,type,final,delta,iteration,vertex,k,vv,vertex,k,vv,iteration,initial,vertices,iterate,delta,initial,vertices,this,maximum,number,of,iterations,0,set,up,iteration,iteration,switch,messaging,direction,case,in,messages,build,messaging,function,iteration,message,type,info,1,0,break,case,out,messages,build,messaging,function,iteration,message,type,info,0,0,break,case,all,messages,build,messaging,function,iteration,message,type,info,1,0,union,build,messaging,function,iteration,message,type,info,0,0,break,default,throw,new,illegal,argument,exception,illegal,edge,direction,vertex,update,udf,k,vv,message,update,udf,new,vertex,update,udf,simple,vv,k,vv,message,update,function,vertex,types,co,group,operator,vertex,k,vv,updates,messages,co,group,iteration,get,solution,set,where,0,equal,to,0,with,update,udf,configure,update,function,updates,return,iteration,close,with,updates,updates
ScatterGatherIteration -> private DataSet<Vertex<K, VV>> createResultSimpleVertex(EdgeDirection messagingDirection, 		TypeInformation<Tuple2<K, Message>> messageTypeInfo);1461669017;Creates the operator that represents this scatter-gather graph computation for a simple vertex.__@param messagingDirection_@param messageTypeInfo_@return the operator;private DataSet<Vertex<K, VV>> createResultSimpleVertex(EdgeDirection messagingDirection,_		TypeInformation<Tuple2<K, Message>> messageTypeInfo) {__		DataSet<Tuple2<K, Message>> messages___		TypeInformation<Vertex<K, VV>> vertexTypes = initialVertices.getType()___		final DeltaIteration<Vertex<K, VV>,	Vertex<K, VV>> iteration =_				initialVertices.iterateDelta(initialVertices, this.maximumNumberOfIterations, 0)__				setUpIteration(iteration)___		switch (messagingDirection) {_			case IN:_				messages = buildMessagingFunction(iteration, messageTypeInfo, 1, 0)__				break__			case OUT:_				messages = buildMessagingFunction(iteration, messageTypeInfo, 0, 0)__				break__			case ALL:_				messages = buildMessagingFunction(iteration, messageTypeInfo, 1, 0)_						.union(buildMessagingFunction(iteration, messageTypeInfo, 0, 0)) __				break__			default:_				throw new IllegalArgumentException("Illegal edge direction")__		}__		VertexUpdateUdf<K, VV, Message> updateUdf =_				new VertexUpdateUdfSimpleVV<K, VV, Message>(updateFunction, vertexTypes)___		_		CoGroupOperator<?, ?, Vertex<K, VV>> updates =_				messages.coGroup(iteration.getSolutionSet()).where(0).equalTo(0).with(updateUdf)___		configureUpdateFunction(updates)___		return iteration.closeWith(updates, updates)__	};creates,the,operator,that,represents,this,scatter,gather,graph,computation,for,a,simple,vertex,param,messaging,direction,param,message,type,info,return,the,operator;private,data,set,vertex,k,vv,create,result,simple,vertex,edge,direction,messaging,direction,type,information,tuple2,k,message,message,type,info,data,set,tuple2,k,message,messages,type,information,vertex,k,vv,vertex,types,initial,vertices,get,type,final,delta,iteration,vertex,k,vv,vertex,k,vv,iteration,initial,vertices,iterate,delta,initial,vertices,this,maximum,number,of,iterations,0,set,up,iteration,iteration,switch,messaging,direction,case,in,messages,build,messaging,function,iteration,message,type,info,1,0,break,case,out,messages,build,messaging,function,iteration,message,type,info,0,0,break,case,all,messages,build,messaging,function,iteration,message,type,info,1,0,union,build,messaging,function,iteration,message,type,info,0,0,break,default,throw,new,illegal,argument,exception,illegal,edge,direction,vertex,update,udf,k,vv,message,update,udf,new,vertex,update,udf,simple,vv,k,vv,message,update,function,vertex,types,co,group,operator,vertex,k,vv,updates,messages,co,group,iteration,get,solution,set,where,0,equal,to,0,with,update,udf,configure,update,function,updates,return,iteration,close,with,updates,updates
ScatterGatherIteration -> public ScatterGatherConfiguration getIterationConfiguration();1452884884;@return the configuration parameters of this scatter-gather iteration;public ScatterGatherConfiguration getIterationConfiguration() {_		return this.configuration__	};return,the,configuration,parameters,of,this,scatter,gather,iteration;public,scatter,gather,configuration,get,iteration,configuration,return,this,configuration
ScatterGatherIteration -> public ScatterGatherConfiguration getIterationConfiguration();1455810039;@return the configuration parameters of this scatter-gather iteration;public ScatterGatherConfiguration getIterationConfiguration() {_		return this.configuration__	};return,the,configuration,parameters,of,this,scatter,gather,iteration;public,scatter,gather,configuration,get,iteration,configuration,return,this,configuration
ScatterGatherIteration -> public ScatterGatherConfiguration getIterationConfiguration();1461669017;@return the configuration parameters of this scatter-gather iteration;public ScatterGatherConfiguration getIterationConfiguration() {_		return this.configuration__	};return,the,configuration,parameters,of,this,scatter,gather,iteration;public,scatter,gather,configuration,get,iteration,configuration,return,this,configuration
ScatterGatherIteration -> public ScatterGatherConfiguration getIterationConfiguration();1462563578;@return the configuration parameters of this scatter-gather iteration;public ScatterGatherConfiguration getIterationConfiguration() {_		return this.configuration__	};return,the,configuration,parameters,of,this,scatter,gather,iteration;public,scatter,gather,configuration,get,iteration,configuration,return,this,configuration
ScatterGatherIteration -> public ScatterGatherConfiguration getIterationConfiguration();1464188761;@return the configuration parameters of this scatter-gather iteration;public ScatterGatherConfiguration getIterationConfiguration() {_		return this.configuration__	};return,the,configuration,parameters,of,this,scatter,gather,iteration;public,scatter,gather,configuration,get,iteration,configuration,return,this,configuration
ScatterGatherIteration -> public ScatterGatherConfiguration getIterationConfiguration();1475517578;@return the configuration parameters of this scatter-gather iteration;public ScatterGatherConfiguration getIterationConfiguration() {_		return this.configuration__	};return,the,configuration,parameters,of,this,scatter,gather,iteration;public,scatter,gather,configuration,get,iteration,configuration,return,this,configuration
ScatterGatherIteration -> public ScatterGatherConfiguration getIterationConfiguration();1475589042;@return the configuration parameters of this scatter-gather iteration;public ScatterGatherConfiguration getIterationConfiguration() {_		return this.configuration__	};return,the,configuration,parameters,of,this,scatter,gather,iteration;public,scatter,gather,configuration,get,iteration,configuration,return,this,configuration
ScatterGatherIteration -> public ScatterGatherConfiguration getIterationConfiguration();1484681137;@return the configuration parameters of this scatter-gather iteration;public ScatterGatherConfiguration getIterationConfiguration() {_		return this.configuration__	};return,the,configuration,parameters,of,this,scatter,gather,iteration;public,scatter,gather,configuration,get,iteration,configuration,return,this,configuration
ScatterGatherIteration -> public ScatterGatherConfiguration getIterationConfiguration();1495653033;@return the configuration parameters of this scatter-gather iteration;public ScatterGatherConfiguration getIterationConfiguration() {_		return this.configuration__	};return,the,configuration,parameters,of,this,scatter,gather,iteration;public,scatter,gather,configuration,get,iteration,configuration,return,this,configuration
ScatterGatherIteration -> public static final <K, VV, Message, EV> 			ScatterGatherIteration<K, VV, Message, EV> withEdges( 					DataSet<Edge<K, EV>> edgesWithValue, 					VertexUpdateFunction<K, VV, Message> uf, 					MessagingFunction<K, VV, Message, EV> mf, 					int maximumNumberOfIterations);1452884884;Creates a new scatter-gather iteration operator for graphs where the edges are associated with a value (such as_a weight or distance).__@param edgesWithValue The data set containing edges._@param uf The function that updates the state of the vertices from the incoming messages._@param mf The function that turns changed vertex states into messages along the edges.__@param <K> The type of the vertex key (the vertex identifier)._@param <VV> The type of the vertex value (the state of the vertex)._@param <Message> The type of the message sent between vertices along the edges._@param <EV> The type of the values that are associated with the edges.__@return An in stance of the scatter-gather graph computation operator.;public static final <K, VV, Message, EV>_			ScatterGatherIteration<K, VV, Message, EV> withEdges(_					DataSet<Edge<K, EV>> edgesWithValue,_					VertexUpdateFunction<K, VV, Message> uf,_					MessagingFunction<K, VV, Message, EV> mf,_					int maximumNumberOfIterations)_	{_		return new ScatterGatherIteration<K, VV, Message, EV>(uf, mf, edgesWithValue, maximumNumberOfIterations)__	};creates,a,new,scatter,gather,iteration,operator,for,graphs,where,the,edges,are,associated,with,a,value,such,as,a,weight,or,distance,param,edges,with,value,the,data,set,containing,edges,param,uf,the,function,that,updates,the,state,of,the,vertices,from,the,incoming,messages,param,mf,the,function,that,turns,changed,vertex,states,into,messages,along,the,edges,param,k,the,type,of,the,vertex,key,the,vertex,identifier,param,vv,the,type,of,the,vertex,value,the,state,of,the,vertex,param,message,the,type,of,the,message,sent,between,vertices,along,the,edges,param,ev,the,type,of,the,values,that,are,associated,with,the,edges,return,an,in,stance,of,the,scatter,gather,graph,computation,operator;public,static,final,k,vv,message,ev,scatter,gather,iteration,k,vv,message,ev,with,edges,data,set,edge,k,ev,edges,with,value,vertex,update,function,k,vv,message,uf,messaging,function,k,vv,message,ev,mf,int,maximum,number,of,iterations,return,new,scatter,gather,iteration,k,vv,message,ev,uf,mf,edges,with,value,maximum,number,of,iterations
ScatterGatherIteration -> public static final <K, VV, Message, EV> 			ScatterGatherIteration<K, VV, Message, EV> withEdges( 					DataSet<Edge<K, EV>> edgesWithValue, 					VertexUpdateFunction<K, VV, Message> uf, 					MessagingFunction<K, VV, Message, EV> mf, 					int maximumNumberOfIterations);1455810039;Creates a new scatter-gather iteration operator for graphs where the edges are associated with a value (such as_a weight or distance).__@param edgesWithValue The data set containing edges._@param uf The function that updates the state of the vertices from the incoming messages._@param mf The function that turns changed vertex states into messages along the edges.__@param <K> The type of the vertex key (the vertex identifier)._@param <VV> The type of the vertex value (the state of the vertex)._@param <Message> The type of the message sent between vertices along the edges._@param <EV> The type of the values that are associated with the edges.__@return An in stance of the scatter-gather graph computation operator.;public static final <K, VV, Message, EV>_			ScatterGatherIteration<K, VV, Message, EV> withEdges(_					DataSet<Edge<K, EV>> edgesWithValue,_					VertexUpdateFunction<K, VV, Message> uf,_					MessagingFunction<K, VV, Message, EV> mf,_					int maximumNumberOfIterations)_	{_		return new ScatterGatherIteration<K, VV, Message, EV>(uf, mf, edgesWithValue, maximumNumberOfIterations)__	};creates,a,new,scatter,gather,iteration,operator,for,graphs,where,the,edges,are,associated,with,a,value,such,as,a,weight,or,distance,param,edges,with,value,the,data,set,containing,edges,param,uf,the,function,that,updates,the,state,of,the,vertices,from,the,incoming,messages,param,mf,the,function,that,turns,changed,vertex,states,into,messages,along,the,edges,param,k,the,type,of,the,vertex,key,the,vertex,identifier,param,vv,the,type,of,the,vertex,value,the,state,of,the,vertex,param,message,the,type,of,the,message,sent,between,vertices,along,the,edges,param,ev,the,type,of,the,values,that,are,associated,with,the,edges,return,an,in,stance,of,the,scatter,gather,graph,computation,operator;public,static,final,k,vv,message,ev,scatter,gather,iteration,k,vv,message,ev,with,edges,data,set,edge,k,ev,edges,with,value,vertex,update,function,k,vv,message,uf,messaging,function,k,vv,message,ev,mf,int,maximum,number,of,iterations,return,new,scatter,gather,iteration,k,vv,message,ev,uf,mf,edges,with,value,maximum,number,of,iterations
ScatterGatherIteration -> public static final <K, VV, Message, EV> 			ScatterGatherIteration<K, VV, Message, EV> withEdges( 					DataSet<Edge<K, EV>> edgesWithValue, 					VertexUpdateFunction<K, VV, Message> uf, 					MessagingFunction<K, VV, Message, EV> mf, 					int maximumNumberOfIterations);1461669017;Creates a new scatter-gather iteration operator for graphs where the edges are associated with a value (such as_a weight or distance).__@param edgesWithValue The data set containing edges._@param uf The function that updates the state of the vertices from the incoming messages._@param mf The function that turns changed vertex states into messages along the edges.__@param <K> The type of the vertex key (the vertex identifier)._@param <VV> The type of the vertex value (the state of the vertex)._@param <Message> The type of the message sent between vertices along the edges._@param <EV> The type of the values that are associated with the edges.__@return An in stance of the scatter-gather graph computation operator.;public static final <K, VV, Message, EV>_			ScatterGatherIteration<K, VV, Message, EV> withEdges(_					DataSet<Edge<K, EV>> edgesWithValue,_					VertexUpdateFunction<K, VV, Message> uf,_					MessagingFunction<K, VV, Message, EV> mf,_					int maximumNumberOfIterations)_	{_		return new ScatterGatherIteration<K, VV, Message, EV>(uf, mf, edgesWithValue, maximumNumberOfIterations)__	};creates,a,new,scatter,gather,iteration,operator,for,graphs,where,the,edges,are,associated,with,a,value,such,as,a,weight,or,distance,param,edges,with,value,the,data,set,containing,edges,param,uf,the,function,that,updates,the,state,of,the,vertices,from,the,incoming,messages,param,mf,the,function,that,turns,changed,vertex,states,into,messages,along,the,edges,param,k,the,type,of,the,vertex,key,the,vertex,identifier,param,vv,the,type,of,the,vertex,value,the,state,of,the,vertex,param,message,the,type,of,the,message,sent,between,vertices,along,the,edges,param,ev,the,type,of,the,values,that,are,associated,with,the,edges,return,an,in,stance,of,the,scatter,gather,graph,computation,operator;public,static,final,k,vv,message,ev,scatter,gather,iteration,k,vv,message,ev,with,edges,data,set,edge,k,ev,edges,with,value,vertex,update,function,k,vv,message,uf,messaging,function,k,vv,message,ev,mf,int,maximum,number,of,iterations,return,new,scatter,gather,iteration,k,vv,message,ev,uf,mf,edges,with,value,maximum,number,of,iterations
ScatterGatherIteration -> public static final <K, VV, Message, EV> 			ScatterGatherIteration<K, VV, Message, EV> withEdges( 					DataSet<Edge<K, EV>> edgesWithValue, 					VertexUpdateFunction<K, VV, Message> uf, 					MessagingFunction<K, VV, Message, EV> mf, 					int maximumNumberOfIterations);1464188761;Creates a new scatter-gather iteration operator for graphs where the edges are associated with a value (such as_a weight or distance).__@param edgesWithValue The data set containing edges._@param uf The function that updates the state of the vertices from the incoming messages._@param mf The function that turns changed vertex states into messages along the edges.__@param <K> The type of the vertex key (the vertex identifier)._@param <VV> The type of the vertex value (the state of the vertex)._@param <Message> The type of the message sent between vertices along the edges._@param <EV> The type of the values that are associated with the edges.__@return An in stance of the scatter-gather graph computation operator.;public static final <K, VV, Message, EV>_			ScatterGatherIteration<K, VV, Message, EV> withEdges(_					DataSet<Edge<K, EV>> edgesWithValue,_					VertexUpdateFunction<K, VV, Message> uf,_					MessagingFunction<K, VV, Message, EV> mf,_					int maximumNumberOfIterations)_	{_		return new ScatterGatherIteration<K, VV, Message, EV>(uf, mf, edgesWithValue, maximumNumberOfIterations)__	};creates,a,new,scatter,gather,iteration,operator,for,graphs,where,the,edges,are,associated,with,a,value,such,as,a,weight,or,distance,param,edges,with,value,the,data,set,containing,edges,param,uf,the,function,that,updates,the,state,of,the,vertices,from,the,incoming,messages,param,mf,the,function,that,turns,changed,vertex,states,into,messages,along,the,edges,param,k,the,type,of,the,vertex,key,the,vertex,identifier,param,vv,the,type,of,the,vertex,value,the,state,of,the,vertex,param,message,the,type,of,the,message,sent,between,vertices,along,the,edges,param,ev,the,type,of,the,values,that,are,associated,with,the,edges,return,an,in,stance,of,the,scatter,gather,graph,computation,operator;public,static,final,k,vv,message,ev,scatter,gather,iteration,k,vv,message,ev,with,edges,data,set,edge,k,ev,edges,with,value,vertex,update,function,k,vv,message,uf,messaging,function,k,vv,message,ev,mf,int,maximum,number,of,iterations,return,new,scatter,gather,iteration,k,vv,message,ev,uf,mf,edges,with,value,maximum,number,of,iterations
ScatterGatherIteration -> @Override 	public void setInput(DataSet<Vertex<K, VV>> inputData);1452884884;Sets the input data set for this operator. In the case of this operator this input data set represents_the set of vertices with their initial state.__@param inputData The input data set, which in the case of this operator represents the set of_vertices with their initial state.__@see org.apache.flink.api.java.operators.CustomUnaryOperation#setInput(org.apache.flink.api.java.DataSet);@Override_	public void setInput(DataSet<Vertex<K, VV>> inputData) {_		this.initialVertices = inputData__	};sets,the,input,data,set,for,this,operator,in,the,case,of,this,operator,this,input,data,set,represents,the,set,of,vertices,with,their,initial,state,param,input,data,the,input,data,set,which,in,the,case,of,this,operator,represents,the,set,of,vertices,with,their,initial,state,see,org,apache,flink,api,java,operators,custom,unary,operation,set,input,org,apache,flink,api,java,data,set;override,public,void,set,input,data,set,vertex,k,vv,input,data,this,initial,vertices,input,data
ScatterGatherIteration -> @Override 	public void setInput(DataSet<Vertex<K, VV>> inputData);1455810039;Sets the input data set for this operator. In the case of this operator this input data set represents_the set of vertices with their initial state.__@param inputData The input data set, which in the case of this operator represents the set of_vertices with their initial state.__@see org.apache.flink.api.java.operators.CustomUnaryOperation#setInput(org.apache.flink.api.java.DataSet);@Override_	public void setInput(DataSet<Vertex<K, VV>> inputData) {_		this.initialVertices = inputData__	};sets,the,input,data,set,for,this,operator,in,the,case,of,this,operator,this,input,data,set,represents,the,set,of,vertices,with,their,initial,state,param,input,data,the,input,data,set,which,in,the,case,of,this,operator,represents,the,set,of,vertices,with,their,initial,state,see,org,apache,flink,api,java,operators,custom,unary,operation,set,input,org,apache,flink,api,java,data,set;override,public,void,set,input,data,set,vertex,k,vv,input,data,this,initial,vertices,input,data
ScatterGatherIteration -> @Override 	public void setInput(DataSet<Vertex<K, VV>> inputData);1461669017;Sets the input data set for this operator. In the case of this operator this input data set represents_the set of vertices with their initial state.__@param inputData The input data set, which in the case of this operator represents the set of_vertices with their initial state.__@see org.apache.flink.api.java.operators.CustomUnaryOperation#setInput(org.apache.flink.api.java.DataSet);@Override_	public void setInput(DataSet<Vertex<K, VV>> inputData) {_		this.initialVertices = inputData__	};sets,the,input,data,set,for,this,operator,in,the,case,of,this,operator,this,input,data,set,represents,the,set,of,vertices,with,their,initial,state,param,input,data,the,input,data,set,which,in,the,case,of,this,operator,represents,the,set,of,vertices,with,their,initial,state,see,org,apache,flink,api,java,operators,custom,unary,operation,set,input,org,apache,flink,api,java,data,set;override,public,void,set,input,data,set,vertex,k,vv,input,data,this,initial,vertices,input,data
ScatterGatherIteration -> @Override 	public void setInput(DataSet<Vertex<K, VV>> inputData);1462563578;Sets the input data set for this operator. In the case of this operator this input data set represents_the set of vertices with their initial state.__@param inputData The input data set, which in the case of this operator represents the set of_vertices with their initial state.__@see org.apache.flink.api.java.operators.CustomUnaryOperation#setInput(org.apache.flink.api.java.DataSet);@Override_	public void setInput(DataSet<Vertex<K, VV>> inputData) {_		this.initialVertices = inputData__	};sets,the,input,data,set,for,this,operator,in,the,case,of,this,operator,this,input,data,set,represents,the,set,of,vertices,with,their,initial,state,param,input,data,the,input,data,set,which,in,the,case,of,this,operator,represents,the,set,of,vertices,with,their,initial,state,see,org,apache,flink,api,java,operators,custom,unary,operation,set,input,org,apache,flink,api,java,data,set;override,public,void,set,input,data,set,vertex,k,vv,input,data,this,initial,vertices,input,data
ScatterGatherIteration -> @Override 	public void setInput(DataSet<Vertex<K, VV>> inputData);1464188761;Sets the input data set for this operator. In the case of this operator this input data set represents_the set of vertices with their initial state.__@param inputData The input data set, which in the case of this operator represents the set of_vertices with their initial state.__@see org.apache.flink.api.java.operators.CustomUnaryOperation#setInput(org.apache.flink.api.java.DataSet);@Override_	public void setInput(DataSet<Vertex<K, VV>> inputData) {_		this.initialVertices = inputData__	};sets,the,input,data,set,for,this,operator,in,the,case,of,this,operator,this,input,data,set,represents,the,set,of,vertices,with,their,initial,state,param,input,data,the,input,data,set,which,in,the,case,of,this,operator,represents,the,set,of,vertices,with,their,initial,state,see,org,apache,flink,api,java,operators,custom,unary,operation,set,input,org,apache,flink,api,java,data,set;override,public,void,set,input,data,set,vertex,k,vv,input,data,this,initial,vertices,input,data
ScatterGatherIteration -> @Override 	public void setInput(DataSet<Vertex<K, VV>> inputData);1475517578;Sets the input data set for this operator. In the case of this operator this input data set represents_the set of vertices with their initial state.__@param inputData The input data set, which in the case of this operator represents the set of_vertices with their initial state.__@see org.apache.flink.api.java.operators.CustomUnaryOperation#setInput(org.apache.flink.api.java.DataSet);@Override_	public void setInput(DataSet<Vertex<K, VV>> inputData) {_		this.initialVertices = inputData__	};sets,the,input,data,set,for,this,operator,in,the,case,of,this,operator,this,input,data,set,represents,the,set,of,vertices,with,their,initial,state,param,input,data,the,input,data,set,which,in,the,case,of,this,operator,represents,the,set,of,vertices,with,their,initial,state,see,org,apache,flink,api,java,operators,custom,unary,operation,set,input,org,apache,flink,api,java,data,set;override,public,void,set,input,data,set,vertex,k,vv,input,data,this,initial,vertices,input,data
ScatterGatherIteration -> @Override 	public void setInput(DataSet<Vertex<K, VV>> inputData);1475589042;Sets the input data set for this operator. In the case of this operator this input data set represents_the set of vertices with their initial state.__@param inputData The input data set, which in the case of this operator represents the set of_vertices with their initial state.__@see org.apache.flink.api.java.operators.CustomUnaryOperation#setInput(org.apache.flink.api.java.DataSet);@Override_	public void setInput(DataSet<Vertex<K, VV>> inputData) {_		this.initialVertices = inputData__	};sets,the,input,data,set,for,this,operator,in,the,case,of,this,operator,this,input,data,set,represents,the,set,of,vertices,with,their,initial,state,param,input,data,the,input,data,set,which,in,the,case,of,this,operator,represents,the,set,of,vertices,with,their,initial,state,see,org,apache,flink,api,java,operators,custom,unary,operation,set,input,org,apache,flink,api,java,data,set;override,public,void,set,input,data,set,vertex,k,vv,input,data,this,initial,vertices,input,data
ScatterGatherIteration -> @Override 	public void setInput(DataSet<Vertex<K, VV>> inputData);1484681137;Sets the input data set for this operator. In the case of this operator this input data set represents_the set of vertices with their initial state.__@param inputData The input data set, which in the case of this operator represents the set of_vertices with their initial state.__@see org.apache.flink.api.java.operators.CustomUnaryOperation#setInput(org.apache.flink.api.java.DataSet);@Override_	public void setInput(DataSet<Vertex<K, VV>> inputData) {_		this.initialVertices = inputData__	};sets,the,input,data,set,for,this,operator,in,the,case,of,this,operator,this,input,data,set,represents,the,set,of,vertices,with,their,initial,state,param,input,data,the,input,data,set,which,in,the,case,of,this,operator,represents,the,set,of,vertices,with,their,initial,state,see,org,apache,flink,api,java,operators,custom,unary,operation,set,input,org,apache,flink,api,java,data,set;override,public,void,set,input,data,set,vertex,k,vv,input,data,this,initial,vertices,input,data
ScatterGatherIteration -> @Override 	public void setInput(DataSet<Vertex<K, VV>> inputData);1495653033;Sets the input data set for this operator. In the case of this operator this input data set represents_the set of vertices with their initial state.__@param inputData The input data set, which in the case of this operator represents the set of_vertices with their initial state.__@see org.apache.flink.api.java.operators.CustomUnaryOperation#setInput(org.apache.flink.api.java.DataSet);@Override_	public void setInput(DataSet<Vertex<K, VV>> inputData) {_		this.initialVertices = inputData__	};sets,the,input,data,set,for,this,operator,in,the,case,of,this,operator,this,input,data,set,represents,the,set,of,vertices,with,their,initial,state,param,input,data,the,input,data,set,which,in,the,case,of,this,operator,represents,the,set,of,vertices,with,their,initial,state,see,org,apache,flink,api,java,operators,custom,unary,operation,set,input,org,apache,flink,api,java,data,set;override,public,void,set,input,data,set,vertex,k,vv,input,data,this,initial,vertices,input,data
ScatterGatherIteration -> private void setUpIteration(DeltaIteration<?, ?> iteration);1452884884;Helper method which sets up an iteration with the given vertex value(either simple or with degrees)__@param iteration;private void setUpIteration(DeltaIteration<?, ?> iteration) {__		_		if (this.configuration != null) {__			iteration.name(this.configuration.getName("Scatter-gather iteration (" + updateFunction + " | " + messagingFunction + ")"))__			iteration.parallelism(this.configuration.getParallelism())__			iteration.setSolutionSetUnManaged(this.configuration.isSolutionSetUnmanagedMemory())___			_			for (Map.Entry<String, Aggregator<?>> entry : this.configuration.getAggregators().entrySet()) {_				iteration.registerAggregator(entry.getKey(), entry.getValue())__			}_		}_		else {_			_			iteration.name("Scatter-gather iteration (" + updateFunction + " | " + messagingFunction + ")")__		}_	};helper,method,which,sets,up,an,iteration,with,the,given,vertex,value,either,simple,or,with,degrees,param,iteration;private,void,set,up,iteration,delta,iteration,iteration,if,this,configuration,null,iteration,name,this,configuration,get,name,scatter,gather,iteration,update,function,messaging,function,iteration,parallelism,this,configuration,get,parallelism,iteration,set,solution,set,un,managed,this,configuration,is,solution,set,unmanaged,memory,for,map,entry,string,aggregator,entry,this,configuration,get,aggregators,entry,set,iteration,register,aggregator,entry,get,key,entry,get,value,else,iteration,name,scatter,gather,iteration,update,function,messaging,function
ScatterGatherIteration -> private void setUpIteration(DeltaIteration<?, ?> iteration);1455810039;Helper method which sets up an iteration with the given vertex value(either simple or with degrees)__@param iteration;private void setUpIteration(DeltaIteration<?, ?> iteration) {__		_		if (this.configuration != null) {__			iteration.name(this.configuration.getName("Scatter-gather iteration (" + updateFunction + " | " + messagingFunction + ")"))__			iteration.parallelism(this.configuration.getParallelism())__			iteration.setSolutionSetUnManaged(this.configuration.isSolutionSetUnmanagedMemory())___			_			for (Map.Entry<String, Aggregator<?>> entry : this.configuration.getAggregators().entrySet()) {_				iteration.registerAggregator(entry.getKey(), entry.getValue())__			}_		}_		else {_			_			iteration.name("Scatter-gather iteration (" + updateFunction + " | " + messagingFunction + ")")__		}_	};helper,method,which,sets,up,an,iteration,with,the,given,vertex,value,either,simple,or,with,degrees,param,iteration;private,void,set,up,iteration,delta,iteration,iteration,if,this,configuration,null,iteration,name,this,configuration,get,name,scatter,gather,iteration,update,function,messaging,function,iteration,parallelism,this,configuration,get,parallelism,iteration,set,solution,set,un,managed,this,configuration,is,solution,set,unmanaged,memory,for,map,entry,string,aggregator,entry,this,configuration,get,aggregators,entry,set,iteration,register,aggregator,entry,get,key,entry,get,value,else,iteration,name,scatter,gather,iteration,update,function,messaging,function
ScatterGatherIteration -> private void setUpIteration(DeltaIteration<?, ?> iteration);1461669017;Helper method which sets up an iteration with the given vertex value(either simple or with degrees)__@param iteration;private void setUpIteration(DeltaIteration<?, ?> iteration) {__		_		if (this.configuration != null) {__			iteration.name(this.configuration.getName("Scatter-gather iteration (" + updateFunction + " | " + messagingFunction + ")"))__			iteration.parallelism(this.configuration.getParallelism())__			iteration.setSolutionSetUnManaged(this.configuration.isSolutionSetUnmanagedMemory())___			_			for (Map.Entry<String, Aggregator<?>> entry : this.configuration.getAggregators().entrySet()) {_				iteration.registerAggregator(entry.getKey(), entry.getValue())__			}_		}_		else {_			_			iteration.name("Scatter-gather iteration (" + updateFunction + " | " + messagingFunction + ")")__		}_	};helper,method,which,sets,up,an,iteration,with,the,given,vertex,value,either,simple,or,with,degrees,param,iteration;private,void,set,up,iteration,delta,iteration,iteration,if,this,configuration,null,iteration,name,this,configuration,get,name,scatter,gather,iteration,update,function,messaging,function,iteration,parallelism,this,configuration,get,parallelism,iteration,set,solution,set,un,managed,this,configuration,is,solution,set,unmanaged,memory,for,map,entry,string,aggregator,entry,this,configuration,get,aggregators,entry,set,iteration,register,aggregator,entry,get,key,entry,get,value,else,iteration,name,scatter,gather,iteration,update,function,messaging,function
ScatterGatherIteration -> private void setUpIteration(DeltaIteration<?, ?> iteration);1462563578;Helper method which sets up an iteration with the given vertex value(either simple or with degrees)__@param iteration;private void setUpIteration(DeltaIteration<?, ?> iteration) {__		_		if (this.configuration != null) {__			iteration.name(this.configuration.getName("Scatter-gather iteration (" + gatherFunction + " | " + scatterFunction + ")"))__			iteration.parallelism(this.configuration.getParallelism())__			iteration.setSolutionSetUnManaged(this.configuration.isSolutionSetUnmanagedMemory())___			_			for (Map.Entry<String, Aggregator<?>> entry : this.configuration.getAggregators().entrySet()) {_				iteration.registerAggregator(entry.getKey(), entry.getValue())__			}_		}_		else {_			_			iteration.name("Scatter-gather iteration (" + gatherFunction + " | " + scatterFunction + ")")__		}_	};helper,method,which,sets,up,an,iteration,with,the,given,vertex,value,either,simple,or,with,degrees,param,iteration;private,void,set,up,iteration,delta,iteration,iteration,if,this,configuration,null,iteration,name,this,configuration,get,name,scatter,gather,iteration,gather,function,scatter,function,iteration,parallelism,this,configuration,get,parallelism,iteration,set,solution,set,un,managed,this,configuration,is,solution,set,unmanaged,memory,for,map,entry,string,aggregator,entry,this,configuration,get,aggregators,entry,set,iteration,register,aggregator,entry,get,key,entry,get,value,else,iteration,name,scatter,gather,iteration,gather,function,scatter,function
ScatterGatherIteration -> private void setUpIteration(DeltaIteration<?, ?> iteration);1464188761;Helper method which sets up an iteration with the given vertex value(either simple or with degrees)__@param iteration;private void setUpIteration(DeltaIteration<?, ?> iteration) {__		_		if (this.configuration != null) {__			iteration.name(this.configuration.getName("Scatter-gather iteration (" + updateFunction + " | " + messagingFunction + ")"))__			iteration.parallelism(this.configuration.getParallelism())__			iteration.setSolutionSetUnManaged(this.configuration.isSolutionSetUnmanagedMemory())___			_			for (Map.Entry<String, Aggregator<?>> entry : this.configuration.getAggregators().entrySet()) {_				iteration.registerAggregator(entry.getKey(), entry.getValue())__			}_		}_		else {_			_			iteration.name("Scatter-gather iteration (" + updateFunction + " | " + messagingFunction + ")")__		}_	};helper,method,which,sets,up,an,iteration,with,the,given,vertex,value,either,simple,or,with,degrees,param,iteration;private,void,set,up,iteration,delta,iteration,iteration,if,this,configuration,null,iteration,name,this,configuration,get,name,scatter,gather,iteration,update,function,messaging,function,iteration,parallelism,this,configuration,get,parallelism,iteration,set,solution,set,un,managed,this,configuration,is,solution,set,unmanaged,memory,for,map,entry,string,aggregator,entry,this,configuration,get,aggregators,entry,set,iteration,register,aggregator,entry,get,key,entry,get,value,else,iteration,name,scatter,gather,iteration,update,function,messaging,function
ScatterGatherIteration -> private void setUpIteration(DeltaIteration<?, ?> iteration);1475517578;Helper method which sets up an iteration with the given vertex value(either simple or with degrees)__@param iteration;private void setUpIteration(DeltaIteration<?, ?> iteration) {__		_		if (this.configuration != null) {__			iteration.name(this.configuration.getName("Scatter-gather iteration (" + gatherFunction + " | " + scatterFunction + ")"))__			iteration.parallelism(this.configuration.getParallelism())__			iteration.setSolutionSetUnManaged(this.configuration.isSolutionSetUnmanagedMemory())___			_			for (Map.Entry<String, Aggregator<?>> entry : this.configuration.getAggregators().entrySet()) {_				iteration.registerAggregator(entry.getKey(), entry.getValue())__			}_		}_		else {_			_			iteration.name("Scatter-gather iteration (" + gatherFunction + " | " + scatterFunction + ")")__		}_	};helper,method,which,sets,up,an,iteration,with,the,given,vertex,value,either,simple,or,with,degrees,param,iteration;private,void,set,up,iteration,delta,iteration,iteration,if,this,configuration,null,iteration,name,this,configuration,get,name,scatter,gather,iteration,gather,function,scatter,function,iteration,parallelism,this,configuration,get,parallelism,iteration,set,solution,set,un,managed,this,configuration,is,solution,set,unmanaged,memory,for,map,entry,string,aggregator,entry,this,configuration,get,aggregators,entry,set,iteration,register,aggregator,entry,get,key,entry,get,value,else,iteration,name,scatter,gather,iteration,gather,function,scatter,function
ScatterGatherIteration -> private void setUpIteration(DeltaIteration<?, ?> iteration);1475589042;Helper method which sets up an iteration with the given vertex value(either simple or with degrees)__@param iteration;private void setUpIteration(DeltaIteration<?, ?> iteration) {__		_		if (this.configuration != null) {__			iteration.name(this.configuration.getName("Scatter-gather iteration (" + gatherFunction + " | " + scatterFunction + ")"))__			iteration.parallelism(this.configuration.getParallelism())__			iteration.setSolutionSetUnManaged(this.configuration.isSolutionSetUnmanagedMemory())___			_			for (Map.Entry<String, Aggregator<?>> entry : this.configuration.getAggregators().entrySet()) {_				iteration.registerAggregator(entry.getKey(), entry.getValue())__			}_		}_		else {_			_			iteration.name("Scatter-gather iteration (" + gatherFunction + " | " + scatterFunction + ")")__		}_	};helper,method,which,sets,up,an,iteration,with,the,given,vertex,value,either,simple,or,with,degrees,param,iteration;private,void,set,up,iteration,delta,iteration,iteration,if,this,configuration,null,iteration,name,this,configuration,get,name,scatter,gather,iteration,gather,function,scatter,function,iteration,parallelism,this,configuration,get,parallelism,iteration,set,solution,set,un,managed,this,configuration,is,solution,set,unmanaged,memory,for,map,entry,string,aggregator,entry,this,configuration,get,aggregators,entry,set,iteration,register,aggregator,entry,get,key,entry,get,value,else,iteration,name,scatter,gather,iteration,gather,function,scatter,function
ScatterGatherIteration -> private void setUpIteration(DeltaIteration<?, ?> iteration);1484681137;Helper method which sets up an iteration with the given vertex value(either simple or with degrees)__@param iteration;private void setUpIteration(DeltaIteration<?, ?> iteration) {__		_		if (this.configuration != null) {__			iteration.name(this.configuration.getName("Scatter-gather iteration (" + gatherFunction + " | " + scatterFunction + ")"))__			iteration.parallelism(this.configuration.getParallelism())__			iteration.setSolutionSetUnManaged(this.configuration.isSolutionSetUnmanagedMemory())___			_			for (Map.Entry<String, Aggregator<?>> entry : this.configuration.getAggregators().entrySet()) {_				iteration.registerAggregator(entry.getKey(), entry.getValue())__			}_		}_		else {_			_			iteration.name("Scatter-gather iteration (" + gatherFunction + " | " + scatterFunction + ")")__		}_	};helper,method,which,sets,up,an,iteration,with,the,given,vertex,value,either,simple,or,with,degrees,param,iteration;private,void,set,up,iteration,delta,iteration,iteration,if,this,configuration,null,iteration,name,this,configuration,get,name,scatter,gather,iteration,gather,function,scatter,function,iteration,parallelism,this,configuration,get,parallelism,iteration,set,solution,set,un,managed,this,configuration,is,solution,set,unmanaged,memory,for,map,entry,string,aggregator,entry,this,configuration,get,aggregators,entry,set,iteration,register,aggregator,entry,get,key,entry,get,value,else,iteration,name,scatter,gather,iteration,gather,function,scatter,function
ScatterGatherIteration -> private void setUpIteration(DeltaIteration<?, ?> iteration);1495653033;Helper method which sets up an iteration with the given vertex value(either simple or with degrees).__@param iteration;private void setUpIteration(DeltaIteration<?, ?> iteration) {__		_		if (this.configuration != null) {__			iteration.name(this.configuration.getName("Scatter-gather iteration (" + gatherFunction + " | " + scatterFunction + ")"))__			iteration.parallelism(this.configuration.getParallelism())__			iteration.setSolutionSetUnManaged(this.configuration.isSolutionSetUnmanagedMemory())___			_			for (Map.Entry<String, Aggregator<?>> entry : this.configuration.getAggregators().entrySet()) {_				iteration.registerAggregator(entry.getKey(), entry.getValue())__			}_		}_		else {_			_			iteration.name("Scatter-gather iteration (" + gatherFunction + " | " + scatterFunction + ")")__		}_	};helper,method,which,sets,up,an,iteration,with,the,given,vertex,value,either,simple,or,with,degrees,param,iteration;private,void,set,up,iteration,delta,iteration,iteration,if,this,configuration,null,iteration,name,this,configuration,get,name,scatter,gather,iteration,gather,function,scatter,function,iteration,parallelism,this,configuration,get,parallelism,iteration,set,solution,set,un,managed,this,configuration,is,solution,set,unmanaged,memory,for,map,entry,string,aggregator,entry,this,configuration,get,aggregators,entry,set,iteration,register,aggregator,entry,get,key,entry,get,value,else,iteration,name,scatter,gather,iteration,gather,function,scatter,function
ScatterGatherIteration -> public void configure(ScatterGatherConfiguration parameters);1452884884;Configures this scatter-gather iteration with the provided parameters.__@param parameters the configuration parameters;public void configure(ScatterGatherConfiguration parameters) {_		this.configuration = parameters__	};configures,this,scatter,gather,iteration,with,the,provided,parameters,param,parameters,the,configuration,parameters;public,void,configure,scatter,gather,configuration,parameters,this,configuration,parameters
ScatterGatherIteration -> public void configure(ScatterGatherConfiguration parameters);1455810039;Configures this scatter-gather iteration with the provided parameters.__@param parameters the configuration parameters;public void configure(ScatterGatherConfiguration parameters) {_		this.configuration = parameters__	};configures,this,scatter,gather,iteration,with,the,provided,parameters,param,parameters,the,configuration,parameters;public,void,configure,scatter,gather,configuration,parameters,this,configuration,parameters
ScatterGatherIteration -> public void configure(ScatterGatherConfiguration parameters);1461669017;Configures this scatter-gather iteration with the provided parameters.__@param parameters the configuration parameters;public void configure(ScatterGatherConfiguration parameters) {_		this.configuration = parameters__	};configures,this,scatter,gather,iteration,with,the,provided,parameters,param,parameters,the,configuration,parameters;public,void,configure,scatter,gather,configuration,parameters,this,configuration,parameters
ScatterGatherIteration -> public void configure(ScatterGatherConfiguration parameters);1462563578;Configures this scatter-gather iteration with the provided parameters.__@param parameters the configuration parameters;public void configure(ScatterGatherConfiguration parameters) {_		this.configuration = parameters__	};configures,this,scatter,gather,iteration,with,the,provided,parameters,param,parameters,the,configuration,parameters;public,void,configure,scatter,gather,configuration,parameters,this,configuration,parameters
ScatterGatherIteration -> public void configure(ScatterGatherConfiguration parameters);1464188761;Configures this scatter-gather iteration with the provided parameters.__@param parameters the configuration parameters;public void configure(ScatterGatherConfiguration parameters) {_		this.configuration = parameters__	};configures,this,scatter,gather,iteration,with,the,provided,parameters,param,parameters,the,configuration,parameters;public,void,configure,scatter,gather,configuration,parameters,this,configuration,parameters
ScatterGatherIteration -> public void configure(ScatterGatherConfiguration parameters);1475517578;Configures this scatter-gather iteration with the provided parameters.__@param parameters the configuration parameters;public void configure(ScatterGatherConfiguration parameters) {_		this.configuration = parameters__	};configures,this,scatter,gather,iteration,with,the,provided,parameters,param,parameters,the,configuration,parameters;public,void,configure,scatter,gather,configuration,parameters,this,configuration,parameters
ScatterGatherIteration -> public void configure(ScatterGatherConfiguration parameters);1475589042;Configures this scatter-gather iteration with the provided parameters.__@param parameters the configuration parameters;public void configure(ScatterGatherConfiguration parameters) {_		this.configuration = parameters__	};configures,this,scatter,gather,iteration,with,the,provided,parameters,param,parameters,the,configuration,parameters;public,void,configure,scatter,gather,configuration,parameters,this,configuration,parameters
ScatterGatherIteration -> public void configure(ScatterGatherConfiguration parameters);1484681137;Configures this scatter-gather iteration with the provided parameters.__@param parameters the configuration parameters;public void configure(ScatterGatherConfiguration parameters) {_		this.configuration = parameters__	};configures,this,scatter,gather,iteration,with,the,provided,parameters,param,parameters,the,configuration,parameters;public,void,configure,scatter,gather,configuration,parameters,this,configuration,parameters
ScatterGatherIteration -> public void configure(ScatterGatherConfiguration parameters);1495653033;Configures this scatter-gather iteration with the provided parameters.__@param parameters the configuration parameters;public void configure(ScatterGatherConfiguration parameters) {_		this.configuration = parameters__	};configures,this,scatter,gather,iteration,with,the,provided,parameters,param,parameters,the,configuration,parameters;public,void,configure,scatter,gather,configuration,parameters,this,configuration,parameters
ScatterGatherIteration -> @Override 	public DataSet<Vertex<K, VV>> createResult();1452884884;Creates the operator that represents this scatter-gather graph computation.__@return The operator that represents this scatter-gather graph computation.;@Override_	public DataSet<Vertex<K, VV>> createResult() {_		if (this.initialVertices == null) {_			throw new IllegalStateException("The input data set has not been set.")__		}__		_		TypeInformation<K> keyType = ((TupleTypeInfo<?>) initialVertices.getType()).getTypeAt(0)__		TypeInformation<Tuple2<K, Message>> messageTypeInfo = new TupleTypeInfo<Tuple2<K,Message>>(keyType, messageType)___		_		Graph<K, VV, EV> graph =_				Graph.fromDataSet(initialVertices, edgesWithValue, initialVertices.getExecutionEnvironment())___		_		__		if (this.configuration != null && this.configuration.isOptNumVertices()) {_			try {_				long numberOfVertices = graph.numberOfVertices()__				messagingFunction.setNumberOfVertices(numberOfVertices)__				updateFunction.setNumberOfVertices(numberOfVertices)__			} catch (Exception e) {_				e.printStackTrace()__			}_		}__		if(this.configuration != null) {_			messagingFunction.setDirection(this.configuration.getDirection())__		} else {_			messagingFunction.setDirection(EdgeDirection.OUT)__		}__		_		EdgeDirection messagingDirection = messagingFunction.getDirection()___		_		_		if(this.configuration != null && this.configuration.isOptDegrees()) {_			return createResultVerticesWithDegrees(graph, messagingDirection, messageTypeInfo)__		} else {_			return createResultSimpleVertex(messagingDirection, messageTypeInfo)__		}_	};creates,the,operator,that,represents,this,scatter,gather,graph,computation,return,the,operator,that,represents,this,scatter,gather,graph,computation;override,public,data,set,vertex,k,vv,create,result,if,this,initial,vertices,null,throw,new,illegal,state,exception,the,input,data,set,has,not,been,set,type,information,k,key,type,tuple,type,info,initial,vertices,get,type,get,type,at,0,type,information,tuple2,k,message,message,type,info,new,tuple,type,info,tuple2,k,message,key,type,message,type,graph,k,vv,ev,graph,graph,from,data,set,initial,vertices,edges,with,value,initial,vertices,get,execution,environment,if,this,configuration,null,this,configuration,is,opt,num,vertices,try,long,number,of,vertices,graph,number,of,vertices,messaging,function,set,number,of,vertices,number,of,vertices,update,function,set,number,of,vertices,number,of,vertices,catch,exception,e,e,print,stack,trace,if,this,configuration,null,messaging,function,set,direction,this,configuration,get,direction,else,messaging,function,set,direction,edge,direction,out,edge,direction,messaging,direction,messaging,function,get,direction,if,this,configuration,null,this,configuration,is,opt,degrees,return,create,result,vertices,with,degrees,graph,messaging,direction,message,type,info,else,return,create,result,simple,vertex,messaging,direction,message,type,info
ScatterGatherIteration -> @Override 	public DataSet<Vertex<K, VV>> createResult();1455810039;Creates the operator that represents this scatter-gather graph computation.__@return The operator that represents this scatter-gather graph computation.;@Override_	public DataSet<Vertex<K, VV>> createResult() {_		if (this.initialVertices == null) {_			throw new IllegalStateException("The input data set has not been set.")__		}__		_		TypeInformation<K> keyType = ((TupleTypeInfo<?>) initialVertices.getType()).getTypeAt(0)__		TypeInformation<Tuple2<K, Message>> messageTypeInfo = new TupleTypeInfo<Tuple2<K,Message>>(keyType, messageType)___		_		Graph<K, VV, EV> graph =_				Graph.fromDataSet(initialVertices, edgesWithValue, initialVertices.getExecutionEnvironment())___		_		__		DataSet<LongValue> numberOfVertices = null__		if (this.configuration != null && this.configuration.isOptNumVertices()) {_			try {_				numberOfVertices = GraphUtils.count(this.initialVertices)__			} catch (Exception e) {_				e.printStackTrace()__			}_		}__		if(this.configuration != null) {_			messagingFunction.setDirection(this.configuration.getDirection())__		} else {_			messagingFunction.setDirection(EdgeDirection.OUT)__		}__		_		EdgeDirection messagingDirection = messagingFunction.getDirection()___		_		_		if(this.configuration != null && this.configuration.isOptDegrees()) {_			return createResultVerticesWithDegrees(graph, messagingDirection, messageTypeInfo, numberOfVertices)__		} else {_			return createResultSimpleVertex(messagingDirection, messageTypeInfo, numberOfVertices)__		}_	};creates,the,operator,that,represents,this,scatter,gather,graph,computation,return,the,operator,that,represents,this,scatter,gather,graph,computation;override,public,data,set,vertex,k,vv,create,result,if,this,initial,vertices,null,throw,new,illegal,state,exception,the,input,data,set,has,not,been,set,type,information,k,key,type,tuple,type,info,initial,vertices,get,type,get,type,at,0,type,information,tuple2,k,message,message,type,info,new,tuple,type,info,tuple2,k,message,key,type,message,type,graph,k,vv,ev,graph,graph,from,data,set,initial,vertices,edges,with,value,initial,vertices,get,execution,environment,data,set,long,value,number,of,vertices,null,if,this,configuration,null,this,configuration,is,opt,num,vertices,try,number,of,vertices,graph,utils,count,this,initial,vertices,catch,exception,e,e,print,stack,trace,if,this,configuration,null,messaging,function,set,direction,this,configuration,get,direction,else,messaging,function,set,direction,edge,direction,out,edge,direction,messaging,direction,messaging,function,get,direction,if,this,configuration,null,this,configuration,is,opt,degrees,return,create,result,vertices,with,degrees,graph,messaging,direction,message,type,info,number,of,vertices,else,return,create,result,simple,vertex,messaging,direction,message,type,info,number,of,vertices
ScatterGatherIteration -> @Override 	public DataSet<Vertex<K, VV>> createResult();1461669017;Creates the operator that represents this scatter-gather graph computation.__@return The operator that represents this scatter-gather graph computation.;@Override_	public DataSet<Vertex<K, VV>> createResult() {_		if (this.initialVertices == null) {_			throw new IllegalStateException("The input data set has not been set.")__		}__		_		TypeInformation<K> keyType = ((TupleTypeInfo<?>) initialVertices.getType()).getTypeAt(0)__		TypeInformation<Tuple2<K, Message>> messageTypeInfo = new TupleTypeInfo<Tuple2<K,Message>>(keyType, messageType)___		_		Graph<K, VV, EV> graph =_				Graph.fromDataSet(initialVertices, edgesWithValue, initialVertices.getExecutionEnvironment())___		_		__		if (this.configuration != null && this.configuration.isOptNumVertices()) {_			try {_				long numberOfVertices = graph.numberOfVertices()__				messagingFunction.setNumberOfVertices(numberOfVertices)__				updateFunction.setNumberOfVertices(numberOfVertices)__			} catch (Exception e) {_				e.printStackTrace()__			}_		}__		if(this.configuration != null) {_			messagingFunction.setDirection(this.configuration.getDirection())__		} else {_			messagingFunction.setDirection(EdgeDirection.OUT)__		}__		_		EdgeDirection messagingDirection = messagingFunction.getDirection()___		_		_		if(this.configuration != null && this.configuration.isOptDegrees()) {_			return createResultVerticesWithDegrees(graph, messagingDirection, messageTypeInfo)__		} else {_			return createResultSimpleVertex(messagingDirection, messageTypeInfo)__		}_	};creates,the,operator,that,represents,this,scatter,gather,graph,computation,return,the,operator,that,represents,this,scatter,gather,graph,computation;override,public,data,set,vertex,k,vv,create,result,if,this,initial,vertices,null,throw,new,illegal,state,exception,the,input,data,set,has,not,been,set,type,information,k,key,type,tuple,type,info,initial,vertices,get,type,get,type,at,0,type,information,tuple2,k,message,message,type,info,new,tuple,type,info,tuple2,k,message,key,type,message,type,graph,k,vv,ev,graph,graph,from,data,set,initial,vertices,edges,with,value,initial,vertices,get,execution,environment,if,this,configuration,null,this,configuration,is,opt,num,vertices,try,long,number,of,vertices,graph,number,of,vertices,messaging,function,set,number,of,vertices,number,of,vertices,update,function,set,number,of,vertices,number,of,vertices,catch,exception,e,e,print,stack,trace,if,this,configuration,null,messaging,function,set,direction,this,configuration,get,direction,else,messaging,function,set,direction,edge,direction,out,edge,direction,messaging,direction,messaging,function,get,direction,if,this,configuration,null,this,configuration,is,opt,degrees,return,create,result,vertices,with,degrees,graph,messaging,direction,message,type,info,else,return,create,result,simple,vertex,messaging,direction,message,type,info
ScatterGatherIteration -> @Override 	public DataSet<Vertex<K, VV>> createResult();1462563578;Creates the operator that represents this scatter-gather graph computation.__@return The operator that represents this scatter-gather graph computation.;@Override_	public DataSet<Vertex<K, VV>> createResult() {_		if (this.initialVertices == null) {_			throw new IllegalStateException("The input data set has not been set.")__		}__		_		TypeInformation<K> keyType = ((TupleTypeInfo<?>) initialVertices.getType()).getTypeAt(0)__		TypeInformation<Tuple2<K, Message>> messageTypeInfo = new TupleTypeInfo<>(keyType, messageType)___		_		Graph<K, VV, EV> graph =_				Graph.fromDataSet(initialVertices, edgesWithValue, initialVertices.getExecutionEnvironment())___		_		__		DataSet<LongValue> numberOfVertices = null__		if (this.configuration != null && this.configuration.isOptNumVertices()) {_			try {_				numberOfVertices = GraphUtils.count(this.initialVertices)__			} catch (Exception e) {_				e.printStackTrace()__			}_		}__		if(this.configuration != null) {_			scatterFunction.setDirection(this.configuration.getDirection())__		} else {_			scatterFunction.setDirection(EdgeDirection.OUT)__		}__		_		EdgeDirection messagingDirection = scatterFunction.getDirection()___		_		_		if(this.configuration != null && this.configuration.isOptDegrees()) {_			return createResultVerticesWithDegrees(graph, messagingDirection, messageTypeInfo, numberOfVertices)__		} else {_			return createResultSimpleVertex(messagingDirection, messageTypeInfo, numberOfVertices)__		}_	};creates,the,operator,that,represents,this,scatter,gather,graph,computation,return,the,operator,that,represents,this,scatter,gather,graph,computation;override,public,data,set,vertex,k,vv,create,result,if,this,initial,vertices,null,throw,new,illegal,state,exception,the,input,data,set,has,not,been,set,type,information,k,key,type,tuple,type,info,initial,vertices,get,type,get,type,at,0,type,information,tuple2,k,message,message,type,info,new,tuple,type,info,key,type,message,type,graph,k,vv,ev,graph,graph,from,data,set,initial,vertices,edges,with,value,initial,vertices,get,execution,environment,data,set,long,value,number,of,vertices,null,if,this,configuration,null,this,configuration,is,opt,num,vertices,try,number,of,vertices,graph,utils,count,this,initial,vertices,catch,exception,e,e,print,stack,trace,if,this,configuration,null,scatter,function,set,direction,this,configuration,get,direction,else,scatter,function,set,direction,edge,direction,out,edge,direction,messaging,direction,scatter,function,get,direction,if,this,configuration,null,this,configuration,is,opt,degrees,return,create,result,vertices,with,degrees,graph,messaging,direction,message,type,info,number,of,vertices,else,return,create,result,simple,vertex,messaging,direction,message,type,info,number,of,vertices
ScatterGatherIteration -> @Override 	public DataSet<Vertex<K, VV>> createResult();1464188761;Creates the operator that represents this scatter-gather graph computation.__@return The operator that represents this scatter-gather graph computation.;@Override_	public DataSet<Vertex<K, VV>> createResult() {_		if (this.initialVertices == null) {_			throw new IllegalStateException("The input data set has not been set.")__		}__		_		TypeInformation<K> keyType = ((TupleTypeInfo<?>) initialVertices.getType()).getTypeAt(0)__		TypeInformation<Tuple2<K, Message>> messageTypeInfo = new TupleTypeInfo<Tuple2<K,Message>>(keyType, messageType)___		_		Graph<K, VV, EV> graph =_				Graph.fromDataSet(initialVertices, edgesWithValue, initialVertices.getExecutionEnvironment())___		_		__		DataSet<LongValue> numberOfVertices = null__		if (this.configuration != null && this.configuration.isOptNumVertices()) {_			try {_				numberOfVertices = GraphUtils.count(this.initialVertices)__			} catch (Exception e) {_				e.printStackTrace()__			}_		}__		if(this.configuration != null) {_			messagingFunction.setDirection(this.configuration.getDirection())__		} else {_			messagingFunction.setDirection(EdgeDirection.OUT)__		}__		_		EdgeDirection messagingDirection = messagingFunction.getDirection()___		_		_		if(this.configuration != null && this.configuration.isOptDegrees()) {_			return createResultVerticesWithDegrees(graph, messagingDirection, messageTypeInfo, numberOfVertices)__		} else {_			return createResultSimpleVertex(messagingDirection, messageTypeInfo, numberOfVertices)__		}_	};creates,the,operator,that,represents,this,scatter,gather,graph,computation,return,the,operator,that,represents,this,scatter,gather,graph,computation;override,public,data,set,vertex,k,vv,create,result,if,this,initial,vertices,null,throw,new,illegal,state,exception,the,input,data,set,has,not,been,set,type,information,k,key,type,tuple,type,info,initial,vertices,get,type,get,type,at,0,type,information,tuple2,k,message,message,type,info,new,tuple,type,info,tuple2,k,message,key,type,message,type,graph,k,vv,ev,graph,graph,from,data,set,initial,vertices,edges,with,value,initial,vertices,get,execution,environment,data,set,long,value,number,of,vertices,null,if,this,configuration,null,this,configuration,is,opt,num,vertices,try,number,of,vertices,graph,utils,count,this,initial,vertices,catch,exception,e,e,print,stack,trace,if,this,configuration,null,messaging,function,set,direction,this,configuration,get,direction,else,messaging,function,set,direction,edge,direction,out,edge,direction,messaging,direction,messaging,function,get,direction,if,this,configuration,null,this,configuration,is,opt,degrees,return,create,result,vertices,with,degrees,graph,messaging,direction,message,type,info,number,of,vertices,else,return,create,result,simple,vertex,messaging,direction,message,type,info,number,of,vertices
ScatterGatherIteration -> @Override 	public DataSet<Vertex<K, VV>> createResult();1475517578;Creates the operator that represents this scatter-gather graph computation.__@return The operator that represents this scatter-gather graph computation.;@Override_	public DataSet<Vertex<K, VV>> createResult() {_		if (this.initialVertices == null) {_			throw new IllegalStateException("The input data set has not been set.")__		}__		_		TypeInformation<K> keyType = ((TupleTypeInfo<?>) initialVertices.getType()).getTypeAt(0)__		TypeInformation<Tuple2<K, Message>> messageTypeInfo = new TupleTypeInfo<>(keyType, messageType)___		_		Graph<K, VV, EV> graph =_				Graph.fromDataSet(initialVertices, edgesWithValue, initialVertices.getExecutionEnvironment())___		_		__		DataSet<LongValue> numberOfVertices = null__		if (this.configuration != null && this.configuration.isOptNumVertices()) {_			try {_				numberOfVertices = GraphUtils.count(this.initialVertices)__			} catch (Exception e) {_				e.printStackTrace()__			}_		}__		if(this.configuration != null) {_			scatterFunction.setDirection(this.configuration.getDirection())__		} else {_			scatterFunction.setDirection(EdgeDirection.OUT)__		}__		_		EdgeDirection messagingDirection = scatterFunction.getDirection()___		_		_		if(this.configuration != null && this.configuration.isOptDegrees()) {_			return createResultVerticesWithDegrees(graph, messagingDirection, messageTypeInfo, numberOfVertices)__		} else {_			return createResultSimpleVertex(messagingDirection, messageTypeInfo, numberOfVertices)__		}_	};creates,the,operator,that,represents,this,scatter,gather,graph,computation,return,the,operator,that,represents,this,scatter,gather,graph,computation;override,public,data,set,vertex,k,vv,create,result,if,this,initial,vertices,null,throw,new,illegal,state,exception,the,input,data,set,has,not,been,set,type,information,k,key,type,tuple,type,info,initial,vertices,get,type,get,type,at,0,type,information,tuple2,k,message,message,type,info,new,tuple,type,info,key,type,message,type,graph,k,vv,ev,graph,graph,from,data,set,initial,vertices,edges,with,value,initial,vertices,get,execution,environment,data,set,long,value,number,of,vertices,null,if,this,configuration,null,this,configuration,is,opt,num,vertices,try,number,of,vertices,graph,utils,count,this,initial,vertices,catch,exception,e,e,print,stack,trace,if,this,configuration,null,scatter,function,set,direction,this,configuration,get,direction,else,scatter,function,set,direction,edge,direction,out,edge,direction,messaging,direction,scatter,function,get,direction,if,this,configuration,null,this,configuration,is,opt,degrees,return,create,result,vertices,with,degrees,graph,messaging,direction,message,type,info,number,of,vertices,else,return,create,result,simple,vertex,messaging,direction,message,type,info,number,of,vertices
ScatterGatherIteration -> @Override 	public DataSet<Vertex<K, VV>> createResult();1475589042;Creates the operator that represents this scatter-gather graph computation.__@return The operator that represents this scatter-gather graph computation.;@Override_	public DataSet<Vertex<K, VV>> createResult() {_		if (this.initialVertices == null) {_			throw new IllegalStateException("The input data set has not been set.")__		}__		_		TypeInformation<K> keyType = ((TupleTypeInfo<?>) initialVertices.getType()).getTypeAt(0)__		TypeInformation<Tuple2<K, Message>> messageTypeInfo = new TupleTypeInfo<>(keyType, messageType)___		_		Graph<K, VV, EV> graph =_				Graph.fromDataSet(initialVertices, edgesWithValue, initialVertices.getExecutionEnvironment())___		_		__		DataSet<LongValue> numberOfVertices = null__		if (this.configuration != null && this.configuration.isOptNumVertices()) {_			try {_				numberOfVertices = GraphUtils.count(this.initialVertices)__			} catch (Exception e) {_				e.printStackTrace()__			}_		}__		if(this.configuration != null) {_			scatterFunction.setDirection(this.configuration.getDirection())__		} else {_			scatterFunction.setDirection(EdgeDirection.OUT)__		}__		_		EdgeDirection messagingDirection = scatterFunction.getDirection()___		_		_		if(this.configuration != null && this.configuration.isOptDegrees()) {_			return createResultVerticesWithDegrees(graph, messagingDirection, messageTypeInfo, numberOfVertices)__		} else {_			return createResultSimpleVertex(messagingDirection, messageTypeInfo, numberOfVertices)__		}_	};creates,the,operator,that,represents,this,scatter,gather,graph,computation,return,the,operator,that,represents,this,scatter,gather,graph,computation;override,public,data,set,vertex,k,vv,create,result,if,this,initial,vertices,null,throw,new,illegal,state,exception,the,input,data,set,has,not,been,set,type,information,k,key,type,tuple,type,info,initial,vertices,get,type,get,type,at,0,type,information,tuple2,k,message,message,type,info,new,tuple,type,info,key,type,message,type,graph,k,vv,ev,graph,graph,from,data,set,initial,vertices,edges,with,value,initial,vertices,get,execution,environment,data,set,long,value,number,of,vertices,null,if,this,configuration,null,this,configuration,is,opt,num,vertices,try,number,of,vertices,graph,utils,count,this,initial,vertices,catch,exception,e,e,print,stack,trace,if,this,configuration,null,scatter,function,set,direction,this,configuration,get,direction,else,scatter,function,set,direction,edge,direction,out,edge,direction,messaging,direction,scatter,function,get,direction,if,this,configuration,null,this,configuration,is,opt,degrees,return,create,result,vertices,with,degrees,graph,messaging,direction,message,type,info,number,of,vertices,else,return,create,result,simple,vertex,messaging,direction,message,type,info,number,of,vertices
ScatterGatherIteration -> @Override 	public DataSet<Vertex<K, VV>> createResult();1484681137;Creates the operator that represents this scatter-gather graph computation.__@return The operator that represents this scatter-gather graph computation.;@Override_	public DataSet<Vertex<K, VV>> createResult() {_		if (this.initialVertices == null) {_			throw new IllegalStateException("The input data set has not been set.")__		}__		_		TypeInformation<K> keyType = ((TupleTypeInfo<?>) initialVertices.getType()).getTypeAt(0)__		TypeInformation<Tuple2<K, Message>> messageTypeInfo = new TupleTypeInfo<>(keyType, messageType)___		_		Graph<K, VV, EV> graph =_				Graph.fromDataSet(initialVertices, edgesWithValue, initialVertices.getExecutionEnvironment())___		_		__		DataSet<LongValue> numberOfVertices = null__		if (this.configuration != null && this.configuration.isOptNumVertices()) {_			try {_				numberOfVertices = GraphUtils.count(this.initialVertices)__			} catch (Exception e) {_				e.printStackTrace()__			}_		}__		if(this.configuration != null) {_			scatterFunction.setDirection(this.configuration.getDirection())__		} else {_			scatterFunction.setDirection(EdgeDirection.OUT)__		}__		_		EdgeDirection messagingDirection = scatterFunction.getDirection()___		_		_		if(this.configuration != null && this.configuration.isOptDegrees()) {_			return createResultVerticesWithDegrees(graph, messagingDirection, messageTypeInfo, numberOfVertices)__		} else {_			return createResultSimpleVertex(messagingDirection, messageTypeInfo, numberOfVertices)__		}_	};creates,the,operator,that,represents,this,scatter,gather,graph,computation,return,the,operator,that,represents,this,scatter,gather,graph,computation;override,public,data,set,vertex,k,vv,create,result,if,this,initial,vertices,null,throw,new,illegal,state,exception,the,input,data,set,has,not,been,set,type,information,k,key,type,tuple,type,info,initial,vertices,get,type,get,type,at,0,type,information,tuple2,k,message,message,type,info,new,tuple,type,info,key,type,message,type,graph,k,vv,ev,graph,graph,from,data,set,initial,vertices,edges,with,value,initial,vertices,get,execution,environment,data,set,long,value,number,of,vertices,null,if,this,configuration,null,this,configuration,is,opt,num,vertices,try,number,of,vertices,graph,utils,count,this,initial,vertices,catch,exception,e,e,print,stack,trace,if,this,configuration,null,scatter,function,set,direction,this,configuration,get,direction,else,scatter,function,set,direction,edge,direction,out,edge,direction,messaging,direction,scatter,function,get,direction,if,this,configuration,null,this,configuration,is,opt,degrees,return,create,result,vertices,with,degrees,graph,messaging,direction,message,type,info,number,of,vertices,else,return,create,result,simple,vertex,messaging,direction,message,type,info,number,of,vertices
ScatterGatherIteration -> @Override 	public DataSet<Vertex<K, VV>> createResult();1495653033;Creates the operator that represents this scatter-gather graph computation.__@return The operator that represents this scatter-gather graph computation.;@Override_	public DataSet<Vertex<K, VV>> createResult() {_		if (this.initialVertices == null) {_			throw new IllegalStateException("The input data set has not been set.")__		}__		_		TypeInformation<K> keyType = ((TupleTypeInfo<?>) initialVertices.getType()).getTypeAt(0)__		TypeInformation<Tuple2<K, Message>> messageTypeInfo = new TupleTypeInfo<>(keyType, messageType)___		_		Graph<K, VV, EV> graph =_				Graph.fromDataSet(initialVertices, edgesWithValue, initialVertices.getExecutionEnvironment())___		_		__		DataSet<LongValue> numberOfVertices = null__		if (this.configuration != null && this.configuration.isOptNumVertices()) {_			try {_				numberOfVertices = GraphUtils.count(this.initialVertices)__			} catch (Exception e) {_				e.printStackTrace()__			}_		}__		if (this.configuration != null) {_			scatterFunction.setDirection(this.configuration.getDirection())__		} else {_			scatterFunction.setDirection(EdgeDirection.OUT)__		}__		_		EdgeDirection messagingDirection = scatterFunction.getDirection()___		_		_		if (this.configuration != null && this.configuration.isOptDegrees()) {_			return createResultVerticesWithDegrees(graph, messagingDirection, messageTypeInfo, numberOfVertices)__		} else {_			return createResultSimpleVertex(messagingDirection, messageTypeInfo, numberOfVertices)__		}_	};creates,the,operator,that,represents,this,scatter,gather,graph,computation,return,the,operator,that,represents,this,scatter,gather,graph,computation;override,public,data,set,vertex,k,vv,create,result,if,this,initial,vertices,null,throw,new,illegal,state,exception,the,input,data,set,has,not,been,set,type,information,k,key,type,tuple,type,info,initial,vertices,get,type,get,type,at,0,type,information,tuple2,k,message,message,type,info,new,tuple,type,info,key,type,message,type,graph,k,vv,ev,graph,graph,from,data,set,initial,vertices,edges,with,value,initial,vertices,get,execution,environment,data,set,long,value,number,of,vertices,null,if,this,configuration,null,this,configuration,is,opt,num,vertices,try,number,of,vertices,graph,utils,count,this,initial,vertices,catch,exception,e,e,print,stack,trace,if,this,configuration,null,scatter,function,set,direction,this,configuration,get,direction,else,scatter,function,set,direction,edge,direction,out,edge,direction,messaging,direction,scatter,function,get,direction,if,this,configuration,null,this,configuration,is,opt,degrees,return,create,result,vertices,with,degrees,graph,messaging,direction,message,type,info,number,of,vertices,else,return,create,result,simple,vertex,messaging,direction,message,type,info,number,of,vertices
