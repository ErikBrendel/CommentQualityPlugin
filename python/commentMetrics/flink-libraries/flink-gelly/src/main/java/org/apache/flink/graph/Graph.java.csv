# id;timestamp;commentText;codeText;commentWords;codeWords
Graph -> public long numberOfEdges() throws Exception;1444404795;@return a long integer representing the number of edges;public long numberOfEdges() throws Exception {_		return edges.count()__	};return,a,long,integer,representing,the,number,of,edges;public,long,number,of,edges,throws,exception,return,edges,count
Graph -> public long numberOfEdges() throws Exception;1445261977;@return a long integer representing the number of edges;public long numberOfEdges() throws Exception {_		return edges.count()__	};return,a,long,integer,representing,the,number,of,edges;public,long,number,of,edges,throws,exception,return,edges,count
Graph -> public long numberOfEdges() throws Exception;1445854323;@return a long integer representing the number of edges;public long numberOfEdges() throws Exception {_		return edges.count()__	};return,a,long,integer,representing,the,number,of,edges;public,long,number,of,edges,throws,exception,return,edges,count
Graph -> public long numberOfEdges() throws Exception;1446112342;@return a long integer representing the number of edges;public long numberOfEdges() throws Exception {_		return edges.count()__	};return,a,long,integer,representing,the,number,of,edges;public,long,number,of,edges,throws,exception,return,edges,count
Graph -> public long numberOfEdges() throws Exception;1447073368;@return a long integer representing the number of edges;public long numberOfEdges() throws Exception {_		return edges.count()__	};return,a,long,integer,representing,the,number,of,edges;public,long,number,of,edges,throws,exception,return,edges,count
Graph -> public long numberOfEdges() throws Exception;1454404649;@return a long integer representing the number of edges;public long numberOfEdges() throws Exception {_		return edges.count()__	};return,a,long,integer,representing,the,number,of,edges;public,long,number,of,edges,throws,exception,return,edges,count
Graph -> public long numberOfEdges() throws Exception;1458583829;@return a long integer representing the number of edges;public long numberOfEdges() throws Exception {_		return edges.count()__	};return,a,long,integer,representing,the,number,of,edges;public,long,number,of,edges,throws,exception,return,edges,count
Graph -> public long numberOfEdges() throws Exception;1458583829;@return a long integer representing the number of edges;public long numberOfEdges() throws Exception {_		return edges.count()__	};return,a,long,integer,representing,the,number,of,edges;public,long,number,of,edges,throws,exception,return,edges,count
Graph -> public long numberOfEdges() throws Exception;1462100316;@return a long integer representing the number of edges;public long numberOfEdges() throws Exception {_		return edges.count()__	};return,a,long,integer,representing,the,number,of,edges;public,long,number,of,edges,throws,exception,return,edges,count
Graph -> public long numberOfEdges() throws Exception;1462100316;@return a long integer representing the number of edges;public long numberOfEdges() throws Exception {_		return edges.count()__	};return,a,long,integer,representing,the,number,of,edges;public,long,number,of,edges,throws,exception,return,edges,count
Graph -> public long numberOfEdges() throws Exception;1462205213;@return a long integer representing the number of edges;public long numberOfEdges() throws Exception {_		return edges.count()__	};return,a,long,integer,representing,the,number,of,edges;public,long,number,of,edges,throws,exception,return,edges,count
Graph -> public long numberOfEdges() throws Exception;1462208859;@return a long integer representing the number of edges;public long numberOfEdges() throws Exception {_		return edges.count()__	};return,a,long,integer,representing,the,number,of,edges;public,long,number,of,edges,throws,exception,return,edges,count
Graph -> public long numberOfEdges() throws Exception;1462809297;@return a long integer representing the number of edges;public long numberOfEdges() throws Exception {_		return edges.count()__	};return,a,long,integer,representing,the,number,of,edges;public,long,number,of,edges,throws,exception,return,edges,count
Graph -> public long numberOfEdges() throws Exception;1465316775;@return a long integer representing the number of edges;public long numberOfEdges() throws Exception {_		return edges.count()__	};return,a,long,integer,representing,the,number,of,edges;public,long,number,of,edges,throws,exception,return,edges,count
Graph -> public long numberOfEdges() throws Exception;1466789678;@return a long integer representing the number of edges;public long numberOfEdges() throws Exception {_		return edges.count()__	};return,a,long,integer,representing,the,number,of,edges;public,long,number,of,edges,throws,exception,return,edges,count
Graph -> public long numberOfEdges() throws Exception;1467140656;@return a long integer representing the number of edges;public long numberOfEdges() throws Exception {_		return edges.count()__	};return,a,long,integer,representing,the,number,of,edges;public,long,number,of,edges,throws,exception,return,edges,count
Graph -> public long numberOfEdges() throws Exception;1467306272;@return a long integer representing the number of edges;public long numberOfEdges() throws Exception {_		return edges.count()__	};return,a,long,integer,representing,the,number,of,edges;public,long,number,of,edges,throws,exception,return,edges,count
Graph -> public long numberOfEdges() throws Exception;1470042815;@return a long integer representing the number of edges;public long numberOfEdges() throws Exception {_		return edges.count()__	};return,a,long,integer,representing,the,number,of,edges;public,long,number,of,edges,throws,exception,return,edges,count
Graph -> public long numberOfEdges() throws Exception;1475684776;@return a long integer representing the number of edges;public long numberOfEdges() throws Exception {_		return edges.count()__	};return,a,long,integer,representing,the,number,of,edges;public,long,number,of,edges,throws,exception,return,edges,count
Graph -> public long numberOfEdges() throws Exception;1475685606;@return a long integer representing the number of edges;public long numberOfEdges() throws Exception {_		return edges.count()__	};return,a,long,integer,representing,the,number,of,edges;public,long,number,of,edges,throws,exception,return,edges,count
Graph -> public long numberOfEdges() throws Exception;1481745825;@return a long integer representing the number of edges;public long numberOfEdges() throws Exception {_		return edges.count()__	};return,a,long,integer,representing,the,number,of,edges;public,long,number,of,edges,throws,exception,return,edges,count
Graph -> public long numberOfEdges() throws Exception;1481881009;@return a long integer representing the number of edges;public long numberOfEdges() throws Exception {_		return edges.count()__	};return,a,long,integer,representing,the,number,of,edges;public,long,number,of,edges,throws,exception,return,edges,count
Graph -> public long numberOfEdges() throws Exception;1484160227;@return a long integer representing the number of edges;public long numberOfEdges() throws Exception {_		return edges.count()__	};return,a,long,integer,representing,the,number,of,edges;public,long,number,of,edges,throws,exception,return,edges,count
Graph -> public long numberOfEdges() throws Exception;1484685504;@return a long integer representing the number of edges;public long numberOfEdges() throws Exception {_		return edges.count()__	};return,a,long,integer,representing,the,number,of,edges;public,long,number,of,edges,throws,exception,return,edges,count
Graph -> public long numberOfEdges() throws Exception;1489068942;@return a long integer representing the number of edges;public long numberOfEdges() throws Exception {_		return edges.count()__	};return,a,long,integer,representing,the,number,of,edges;public,long,number,of,edges,throws,exception,return,edges,count
Graph -> public long numberOfEdges() throws Exception;1490973446;@return a long integer representing the number of edges;public long numberOfEdges() throws Exception {_		return edges.count()__	};return,a,long,integer,representing,the,number,of,edges;public,long,number,of,edges,throws,exception,return,edges,count
Graph -> public long numberOfEdges() throws Exception;1495819075;@return a long integer representing the number of edges;public long numberOfEdges() throws Exception {_		return edges.count()__	};return,a,long,integer,representing,the,number,of,edges;public,long,number,of,edges,throws,exception,return,edges,count
Graph -> public long numberOfEdges() throws Exception;1502111816;@return a long integer representing the number of edges;public long numberOfEdges() throws Exception {_		return edges.count()__	};return,a,long,integer,representing,the,number,of,edges;public,long,number,of,edges,throws,exception,return,edges,count
Graph -> @SuppressWarnings({ "unchecked", "rawtypes" }) 	public <NV> Graph<K, VV, NV> mapEdges(final MapFunction<Edge<K, EV>, NV> mapper);1444404795;Apply a function to the attribute of each edge in the graph.__@param mapper the map function to apply._@return a new graph;@SuppressWarnings({ "unchecked", "rawtypes" })_	public <NV> Graph<K, VV, NV> mapEdges(final MapFunction<Edge<K, EV>, NV> mapper) {__		TypeInformation<K> keyType = ((TupleTypeInfo<?>) edges.getType()).getTypeAt(0)___		TypeInformation<NV> valueType = TypeExtractor.createTypeInfo(MapFunction.class, mapper.getClass(), 1, null, null)___		TypeInformation<Edge<K, NV>> returnType = (TypeInformation<Edge<K, NV>>) new TupleTypeInfo(_				Edge.class, keyType, keyType, valueType)___		return mapEdges(mapper, returnType)__	};apply,a,function,to,the,attribute,of,each,edge,in,the,graph,param,mapper,the,map,function,to,apply,return,a,new,graph;suppress,warnings,unchecked,rawtypes,public,nv,graph,k,vv,nv,map,edges,final,map,function,edge,k,ev,nv,mapper,type,information,k,key,type,tuple,type,info,edges,get,type,get,type,at,0,type,information,nv,value,type,type,extractor,create,type,info,map,function,class,mapper,get,class,1,null,null,type,information,edge,k,nv,return,type,type,information,edge,k,nv,new,tuple,type,info,edge,class,key,type,key,type,value,type,return,map,edges,mapper,return,type
Graph -> @SuppressWarnings({ "unchecked", "rawtypes" }) 	public <NV> Graph<K, VV, NV> mapEdges(final MapFunction<Edge<K, EV>, NV> mapper);1445261977;Apply a function to the attribute of each edge in the graph.__@param mapper the map function to apply._@return a new graph;@SuppressWarnings({ "unchecked", "rawtypes" })_	public <NV> Graph<K, VV, NV> mapEdges(final MapFunction<Edge<K, EV>, NV> mapper) {__		TypeInformation<K> keyType = ((TupleTypeInfo<?>) edges.getType()).getTypeAt(0)___		TypeInformation<NV> valueType = TypeExtractor.createTypeInfo(MapFunction.class, mapper.getClass(), 1, null, null)___		TypeInformation<Edge<K, NV>> returnType = (TypeInformation<Edge<K, NV>>) new TupleTypeInfo(_				Edge.class, keyType, keyType, valueType)___		return mapEdges(mapper, returnType)__	};apply,a,function,to,the,attribute,of,each,edge,in,the,graph,param,mapper,the,map,function,to,apply,return,a,new,graph;suppress,warnings,unchecked,rawtypes,public,nv,graph,k,vv,nv,map,edges,final,map,function,edge,k,ev,nv,mapper,type,information,k,key,type,tuple,type,info,edges,get,type,get,type,at,0,type,information,nv,value,type,type,extractor,create,type,info,map,function,class,mapper,get,class,1,null,null,type,information,edge,k,nv,return,type,type,information,edge,k,nv,new,tuple,type,info,edge,class,key,type,key,type,value,type,return,map,edges,mapper,return,type
Graph -> @SuppressWarnings({ "unchecked", "rawtypes" }) 	public <NV> Graph<K, VV, NV> mapEdges(final MapFunction<Edge<K, EV>, NV> mapper);1445854323;Apply a function to the attribute of each edge in the graph.__@param mapper the map function to apply._@return a new graph;@SuppressWarnings({ "unchecked", "rawtypes" })_	public <NV> Graph<K, VV, NV> mapEdges(final MapFunction<Edge<K, EV>, NV> mapper) {__		TypeInformation<K> keyType = ((TupleTypeInfo<?>) edges.getType()).getTypeAt(0)___		TypeInformation<NV> valueType = TypeExtractor.createTypeInfo(MapFunction.class, mapper.getClass(), 1, null, null)___		TypeInformation<Edge<K, NV>> returnType = (TypeInformation<Edge<K, NV>>) new TupleTypeInfo(_				Edge.class, keyType, keyType, valueType)___		return mapEdges(mapper, returnType)__	};apply,a,function,to,the,attribute,of,each,edge,in,the,graph,param,mapper,the,map,function,to,apply,return,a,new,graph;suppress,warnings,unchecked,rawtypes,public,nv,graph,k,vv,nv,map,edges,final,map,function,edge,k,ev,nv,mapper,type,information,k,key,type,tuple,type,info,edges,get,type,get,type,at,0,type,information,nv,value,type,type,extractor,create,type,info,map,function,class,mapper,get,class,1,null,null,type,information,edge,k,nv,return,type,type,information,edge,k,nv,new,tuple,type,info,edge,class,key,type,key,type,value,type,return,map,edges,mapper,return,type
Graph -> @SuppressWarnings({ "unchecked", "rawtypes" }) 	public <NV> Graph<K, VV, NV> mapEdges(final MapFunction<Edge<K, EV>, NV> mapper);1446112342;Apply a function to the attribute of each edge in the graph.__@param mapper the map function to apply._@return a new graph;@SuppressWarnings({ "unchecked", "rawtypes" })_	public <NV> Graph<K, VV, NV> mapEdges(final MapFunction<Edge<K, EV>, NV> mapper) {__		TypeInformation<K> keyType = ((TupleTypeInfo<?>) edges.getType()).getTypeAt(0)___		TypeInformation<NV> valueType = TypeExtractor.createTypeInfo(MapFunction.class, mapper.getClass(), 1, null, null)___		TypeInformation<Edge<K, NV>> returnType = (TypeInformation<Edge<K, NV>>) new TupleTypeInfo(_				Edge.class, keyType, keyType, valueType)___		return mapEdges(mapper, returnType)__	};apply,a,function,to,the,attribute,of,each,edge,in,the,graph,param,mapper,the,map,function,to,apply,return,a,new,graph;suppress,warnings,unchecked,rawtypes,public,nv,graph,k,vv,nv,map,edges,final,map,function,edge,k,ev,nv,mapper,type,information,k,key,type,tuple,type,info,edges,get,type,get,type,at,0,type,information,nv,value,type,type,extractor,create,type,info,map,function,class,mapper,get,class,1,null,null,type,information,edge,k,nv,return,type,type,information,edge,k,nv,new,tuple,type,info,edge,class,key,type,key,type,value,type,return,map,edges,mapper,return,type
Graph -> @SuppressWarnings({ "unchecked", "rawtypes" }) 	public <NV> Graph<K, VV, NV> mapEdges(final MapFunction<Edge<K, EV>, NV> mapper);1447073368;Apply a function to the attribute of each edge in the graph.__@param mapper the map function to apply._@return a new graph;@SuppressWarnings({ "unchecked", "rawtypes" })_	public <NV> Graph<K, VV, NV> mapEdges(final MapFunction<Edge<K, EV>, NV> mapper) {__		TypeInformation<K> keyType = ((TupleTypeInfo<?>) edges.getType()).getTypeAt(0)___		TypeInformation<NV> valueType = TypeExtractor.createTypeInfo(MapFunction.class, mapper.getClass(), 1, null, null)___		TypeInformation<Edge<K, NV>> returnType = (TypeInformation<Edge<K, NV>>) new TupleTypeInfo(_				Edge.class, keyType, keyType, valueType)___		return mapEdges(mapper, returnType)__	};apply,a,function,to,the,attribute,of,each,edge,in,the,graph,param,mapper,the,map,function,to,apply,return,a,new,graph;suppress,warnings,unchecked,rawtypes,public,nv,graph,k,vv,nv,map,edges,final,map,function,edge,k,ev,nv,mapper,type,information,k,key,type,tuple,type,info,edges,get,type,get,type,at,0,type,information,nv,value,type,type,extractor,create,type,info,map,function,class,mapper,get,class,1,null,null,type,information,edge,k,nv,return,type,type,information,edge,k,nv,new,tuple,type,info,edge,class,key,type,key,type,value,type,return,map,edges,mapper,return,type
Graph -> @SuppressWarnings({ "unchecked", "rawtypes" }) 	public <NV> Graph<K, VV, NV> mapEdges(final MapFunction<Edge<K, EV>, NV> mapper);1454404649;Apply a function to the attribute of each edge in the graph.__@param mapper the map function to apply._@return a new graph;@SuppressWarnings({ "unchecked", "rawtypes" })_	public <NV> Graph<K, VV, NV> mapEdges(final MapFunction<Edge<K, EV>, NV> mapper) {__		TypeInformation<K> keyType = ((TupleTypeInfo<?>) edges.getType()).getTypeAt(0)___		TypeInformation<NV> valueType = TypeExtractor.createTypeInfo(MapFunction.class, mapper.getClass(), 1, null, null)___		TypeInformation<Edge<K, NV>> returnType = (TypeInformation<Edge<K, NV>>) new TupleTypeInfo(_				Edge.class, keyType, keyType, valueType)___		return mapEdges(mapper, returnType)__	};apply,a,function,to,the,attribute,of,each,edge,in,the,graph,param,mapper,the,map,function,to,apply,return,a,new,graph;suppress,warnings,unchecked,rawtypes,public,nv,graph,k,vv,nv,map,edges,final,map,function,edge,k,ev,nv,mapper,type,information,k,key,type,tuple,type,info,edges,get,type,get,type,at,0,type,information,nv,value,type,type,extractor,create,type,info,map,function,class,mapper,get,class,1,null,null,type,information,edge,k,nv,return,type,type,information,edge,k,nv,new,tuple,type,info,edge,class,key,type,key,type,value,type,return,map,edges,mapper,return,type
Graph -> @SuppressWarnings({ "unchecked", "rawtypes" }) 	public <NV> Graph<K, VV, NV> mapEdges(final MapFunction<Edge<K, EV>, NV> mapper);1458583829;Apply a function to the attribute of each edge in the graph.__@param mapper the map function to apply._@return a new graph;@SuppressWarnings({ "unchecked", "rawtypes" })_	public <NV> Graph<K, VV, NV> mapEdges(final MapFunction<Edge<K, EV>, NV> mapper) {__		TypeInformation<K> keyType = ((TupleTypeInfo<?>) edges.getType()).getTypeAt(0)___		TypeInformation<NV> valueType = TypeExtractor.createTypeInfo(MapFunction.class, mapper.getClass(), 1, null, null)___		TypeInformation<Edge<K, NV>> returnType = (TypeInformation<Edge<K, NV>>) new TupleTypeInfo(_				Edge.class, keyType, keyType, valueType)___		return mapEdges(mapper, returnType)__	};apply,a,function,to,the,attribute,of,each,edge,in,the,graph,param,mapper,the,map,function,to,apply,return,a,new,graph;suppress,warnings,unchecked,rawtypes,public,nv,graph,k,vv,nv,map,edges,final,map,function,edge,k,ev,nv,mapper,type,information,k,key,type,tuple,type,info,edges,get,type,get,type,at,0,type,information,nv,value,type,type,extractor,create,type,info,map,function,class,mapper,get,class,1,null,null,type,information,edge,k,nv,return,type,type,information,edge,k,nv,new,tuple,type,info,edge,class,key,type,key,type,value,type,return,map,edges,mapper,return,type
Graph -> @SuppressWarnings({ "unchecked", "rawtypes" }) 	public <NV> Graph<K, VV, NV> mapEdges(final MapFunction<Edge<K, EV>, NV> mapper);1458583829;Apply a function to the attribute of each edge in the graph.__@param mapper the map function to apply._@return a new graph;@SuppressWarnings({ "unchecked", "rawtypes" })_	public <NV> Graph<K, VV, NV> mapEdges(final MapFunction<Edge<K, EV>, NV> mapper) {__		TypeInformation<K> keyType = ((TupleTypeInfo<?>) edges.getType()).getTypeAt(0)___		TypeInformation<NV> valueType = TypeExtractor.createTypeInfo(MapFunction.class, mapper.getClass(), 1, null, null)___		TypeInformation<Edge<K, NV>> returnType = (TypeInformation<Edge<K, NV>>) new TupleTypeInfo(_				Edge.class, keyType, keyType, valueType)___		return mapEdges(mapper, returnType)__	};apply,a,function,to,the,attribute,of,each,edge,in,the,graph,param,mapper,the,map,function,to,apply,return,a,new,graph;suppress,warnings,unchecked,rawtypes,public,nv,graph,k,vv,nv,map,edges,final,map,function,edge,k,ev,nv,mapper,type,information,k,key,type,tuple,type,info,edges,get,type,get,type,at,0,type,information,nv,value,type,type,extractor,create,type,info,map,function,class,mapper,get,class,1,null,null,type,information,edge,k,nv,return,type,type,information,edge,k,nv,new,tuple,type,info,edge,class,key,type,key,type,value,type,return,map,edges,mapper,return,type
Graph -> @SuppressWarnings({ "unchecked", "rawtypes" }) 	public <NV> Graph<K, VV, NV> mapEdges(final MapFunction<Edge<K, EV>, NV> mapper);1462100316;Apply a function to the attribute of each edge in the graph.__@param mapper the map function to apply._@return a new graph;@SuppressWarnings({ "unchecked", "rawtypes" })_	public <NV> Graph<K, VV, NV> mapEdges(final MapFunction<Edge<K, EV>, NV> mapper) {__		TypeInformation<K> keyType = ((TupleTypeInfo<?>) edges.getType()).getTypeAt(0)___		TypeInformation<NV> valueType = TypeExtractor.createTypeInfo(MapFunction.class, mapper.getClass(), 1, null, null)___		TypeInformation<Edge<K, NV>> returnType = (TypeInformation<Edge<K, NV>>) new TupleTypeInfo(_				Edge.class, keyType, keyType, valueType)___		return mapEdges(mapper, returnType)__	};apply,a,function,to,the,attribute,of,each,edge,in,the,graph,param,mapper,the,map,function,to,apply,return,a,new,graph;suppress,warnings,unchecked,rawtypes,public,nv,graph,k,vv,nv,map,edges,final,map,function,edge,k,ev,nv,mapper,type,information,k,key,type,tuple,type,info,edges,get,type,get,type,at,0,type,information,nv,value,type,type,extractor,create,type,info,map,function,class,mapper,get,class,1,null,null,type,information,edge,k,nv,return,type,type,information,edge,k,nv,new,tuple,type,info,edge,class,key,type,key,type,value,type,return,map,edges,mapper,return,type
Graph -> @SuppressWarnings({ "unchecked", "rawtypes" }) 	public <NV> Graph<K, VV, NV> mapEdges(final MapFunction<Edge<K, EV>, NV> mapper);1462100316;Apply a function to the attribute of each edge in the graph.__@param mapper the map function to apply._@return a new graph;@SuppressWarnings({ "unchecked", "rawtypes" })_	public <NV> Graph<K, VV, NV> mapEdges(final MapFunction<Edge<K, EV>, NV> mapper) {__		TypeInformation<K> keyType = ((TupleTypeInfo<?>) edges.getType()).getTypeAt(0)___		TypeInformation<NV> valueType = TypeExtractor.createTypeInfo(MapFunction.class, mapper.getClass(), 1, null, null)___		TypeInformation<Edge<K, NV>> returnType = (TypeInformation<Edge<K, NV>>) new TupleTypeInfo(_				Edge.class, keyType, keyType, valueType)___		return mapEdges(mapper, returnType)__	};apply,a,function,to,the,attribute,of,each,edge,in,the,graph,param,mapper,the,map,function,to,apply,return,a,new,graph;suppress,warnings,unchecked,rawtypes,public,nv,graph,k,vv,nv,map,edges,final,map,function,edge,k,ev,nv,mapper,type,information,k,key,type,tuple,type,info,edges,get,type,get,type,at,0,type,information,nv,value,type,type,extractor,create,type,info,map,function,class,mapper,get,class,1,null,null,type,information,edge,k,nv,return,type,type,information,edge,k,nv,new,tuple,type,info,edge,class,key,type,key,type,value,type,return,map,edges,mapper,return,type
Graph -> @SuppressWarnings({ "unchecked", "rawtypes" }) 	public <NV> Graph<K, VV, NV> mapEdges(final MapFunction<Edge<K, EV>, NV> mapper);1462205213;Apply a function to the attribute of each edge in the graph.__@param mapper the map function to apply._@return a new graph;@SuppressWarnings({ "unchecked", "rawtypes" })_	public <NV> Graph<K, VV, NV> mapEdges(final MapFunction<Edge<K, EV>, NV> mapper) {__		TypeInformation<K> keyType = ((TupleTypeInfo<?>) edges.getType()).getTypeAt(0)___		TypeInformation<NV> valueType = TypeExtractor.createTypeInfo(MapFunction.class, mapper.getClass(), 1, null, null)___		TypeInformation<Edge<K, NV>> returnType = (TypeInformation<Edge<K, NV>>) new TupleTypeInfo(_				Edge.class, keyType, keyType, valueType)___		return mapEdges(mapper, returnType)__	};apply,a,function,to,the,attribute,of,each,edge,in,the,graph,param,mapper,the,map,function,to,apply,return,a,new,graph;suppress,warnings,unchecked,rawtypes,public,nv,graph,k,vv,nv,map,edges,final,map,function,edge,k,ev,nv,mapper,type,information,k,key,type,tuple,type,info,edges,get,type,get,type,at,0,type,information,nv,value,type,type,extractor,create,type,info,map,function,class,mapper,get,class,1,null,null,type,information,edge,k,nv,return,type,type,information,edge,k,nv,new,tuple,type,info,edge,class,key,type,key,type,value,type,return,map,edges,mapper,return,type
Graph -> @SuppressWarnings({ "unchecked", "rawtypes" }) 	public <NV> Graph<K, VV, NV> mapEdges(final MapFunction<Edge<K, EV>, NV> mapper);1462208859;Apply a function to the attribute of each edge in the graph.__@param mapper the map function to apply._@return a new graph;@SuppressWarnings({ "unchecked", "rawtypes" })_	public <NV> Graph<K, VV, NV> mapEdges(final MapFunction<Edge<K, EV>, NV> mapper) {__		TypeInformation<K> keyType = ((TupleTypeInfo<?>) edges.getType()).getTypeAt(0)___		TypeInformation<NV> valueType = TypeExtractor.createTypeInfo(MapFunction.class, mapper.getClass(), 1, null, null)___		TypeInformation<Edge<K, NV>> returnType = (TypeInformation<Edge<K, NV>>) new TupleTypeInfo(_				Edge.class, keyType, keyType, valueType)___		return mapEdges(mapper, returnType)__	};apply,a,function,to,the,attribute,of,each,edge,in,the,graph,param,mapper,the,map,function,to,apply,return,a,new,graph;suppress,warnings,unchecked,rawtypes,public,nv,graph,k,vv,nv,map,edges,final,map,function,edge,k,ev,nv,mapper,type,information,k,key,type,tuple,type,info,edges,get,type,get,type,at,0,type,information,nv,value,type,type,extractor,create,type,info,map,function,class,mapper,get,class,1,null,null,type,information,edge,k,nv,return,type,type,information,edge,k,nv,new,tuple,type,info,edge,class,key,type,key,type,value,type,return,map,edges,mapper,return,type
Graph -> @SuppressWarnings({ "unchecked", "rawtypes" }) 	public <NV> Graph<K, VV, NV> mapEdges(final MapFunction<Edge<K, EV>, NV> mapper);1462809297;Apply a function to the attribute of each edge in the graph.__@param mapper the map function to apply._@return a new graph;@SuppressWarnings({ "unchecked", "rawtypes" })_	public <NV> Graph<K, VV, NV> mapEdges(final MapFunction<Edge<K, EV>, NV> mapper) {__		TypeInformation<K> keyType = ((TupleTypeInfo<?>) edges.getType()).getTypeAt(0)___		TypeInformation<NV> valueType = TypeExtractor.createTypeInfo(MapFunction.class, mapper.getClass(), 1, null, null)___		TypeInformation<Edge<K, NV>> returnType = (TypeInformation<Edge<K, NV>>) new TupleTypeInfo(_				Edge.class, keyType, keyType, valueType)___		return mapEdges(mapper, returnType)__	};apply,a,function,to,the,attribute,of,each,edge,in,the,graph,param,mapper,the,map,function,to,apply,return,a,new,graph;suppress,warnings,unchecked,rawtypes,public,nv,graph,k,vv,nv,map,edges,final,map,function,edge,k,ev,nv,mapper,type,information,k,key,type,tuple,type,info,edges,get,type,get,type,at,0,type,information,nv,value,type,type,extractor,create,type,info,map,function,class,mapper,get,class,1,null,null,type,information,edge,k,nv,return,type,type,information,edge,k,nv,new,tuple,type,info,edge,class,key,type,key,type,value,type,return,map,edges,mapper,return,type
Graph -> @SuppressWarnings({ "unchecked", "rawtypes" }) 	public <NV> Graph<K, VV, NV> mapEdges(final MapFunction<Edge<K, EV>, NV> mapper);1465316775;Apply a function to the attribute of each edge in the graph.__@param mapper the map function to apply._@return a new graph;@SuppressWarnings({ "unchecked", "rawtypes" })_	public <NV> Graph<K, VV, NV> mapEdges(final MapFunction<Edge<K, EV>, NV> mapper) {__		TypeInformation<K> keyType = ((TupleTypeInfo<?>) edges.getType()).getTypeAt(0)___		TypeInformation<NV> valueType = TypeExtractor.createTypeInfo(MapFunction.class, mapper.getClass(), 1, null, null)___		TypeInformation<Edge<K, NV>> returnType = (TypeInformation<Edge<K, NV>>) new TupleTypeInfo(_				Edge.class, keyType, keyType, valueType)___		return mapEdges(mapper, returnType)__	};apply,a,function,to,the,attribute,of,each,edge,in,the,graph,param,mapper,the,map,function,to,apply,return,a,new,graph;suppress,warnings,unchecked,rawtypes,public,nv,graph,k,vv,nv,map,edges,final,map,function,edge,k,ev,nv,mapper,type,information,k,key,type,tuple,type,info,edges,get,type,get,type,at,0,type,information,nv,value,type,type,extractor,create,type,info,map,function,class,mapper,get,class,1,null,null,type,information,edge,k,nv,return,type,type,information,edge,k,nv,new,tuple,type,info,edge,class,key,type,key,type,value,type,return,map,edges,mapper,return,type
Graph -> @SuppressWarnings({ "unchecked", "rawtypes" }) 	public <NV> Graph<K, VV, NV> mapEdges(final MapFunction<Edge<K, EV>, NV> mapper);1466789678;Apply a function to the attribute of each edge in the graph.__@param mapper the map function to apply._@return a new graph;@SuppressWarnings({ "unchecked", "rawtypes" })_	public <NV> Graph<K, VV, NV> mapEdges(final MapFunction<Edge<K, EV>, NV> mapper) {__		TypeInformation<K> keyType = ((TupleTypeInfo<?>) edges.getType()).getTypeAt(0)___		TypeInformation<NV> valueType = TypeExtractor.createTypeInfo(MapFunction.class, mapper.getClass(), 1, null, null)___		TypeInformation<Edge<K, NV>> returnType = (TypeInformation<Edge<K, NV>>) new TupleTypeInfo(_				Edge.class, keyType, keyType, valueType)___		return mapEdges(mapper, returnType)__	};apply,a,function,to,the,attribute,of,each,edge,in,the,graph,param,mapper,the,map,function,to,apply,return,a,new,graph;suppress,warnings,unchecked,rawtypes,public,nv,graph,k,vv,nv,map,edges,final,map,function,edge,k,ev,nv,mapper,type,information,k,key,type,tuple,type,info,edges,get,type,get,type,at,0,type,information,nv,value,type,type,extractor,create,type,info,map,function,class,mapper,get,class,1,null,null,type,information,edge,k,nv,return,type,type,information,edge,k,nv,new,tuple,type,info,edge,class,key,type,key,type,value,type,return,map,edges,mapper,return,type
Graph -> @SuppressWarnings({ "unchecked", "rawtypes" }) 	public <NV> Graph<K, VV, NV> mapEdges(final MapFunction<Edge<K, EV>, NV> mapper);1467140656;Apply a function to the attribute of each edge in the graph.__@param mapper the map function to apply._@return a new graph;@SuppressWarnings({ "unchecked", "rawtypes" })_	public <NV> Graph<K, VV, NV> mapEdges(final MapFunction<Edge<K, EV>, NV> mapper) {__		TypeInformation<K> keyType = ((TupleTypeInfo<?>) edges.getType()).getTypeAt(0)___		TypeInformation<NV> valueType = TypeExtractor.createTypeInfo(MapFunction.class, mapper.getClass(), 1, null, null)___		TypeInformation<Edge<K, NV>> returnType = (TypeInformation<Edge<K, NV>>) new TupleTypeInfo(_				Edge.class, keyType, keyType, valueType)___		return mapEdges(mapper, returnType)__	};apply,a,function,to,the,attribute,of,each,edge,in,the,graph,param,mapper,the,map,function,to,apply,return,a,new,graph;suppress,warnings,unchecked,rawtypes,public,nv,graph,k,vv,nv,map,edges,final,map,function,edge,k,ev,nv,mapper,type,information,k,key,type,tuple,type,info,edges,get,type,get,type,at,0,type,information,nv,value,type,type,extractor,create,type,info,map,function,class,mapper,get,class,1,null,null,type,information,edge,k,nv,return,type,type,information,edge,k,nv,new,tuple,type,info,edge,class,key,type,key,type,value,type,return,map,edges,mapper,return,type
Graph -> @SuppressWarnings({ "unchecked", "rawtypes" }) 	public <NV> Graph<K, VV, NV> mapEdges(final MapFunction<Edge<K, EV>, NV> mapper);1467306272;Apply a function to the attribute of each edge in the graph.__@param mapper the map function to apply._@return a new graph;@SuppressWarnings({ "unchecked", "rawtypes" })_	public <NV> Graph<K, VV, NV> mapEdges(final MapFunction<Edge<K, EV>, NV> mapper) {__		TypeInformation<K> keyType = ((TupleTypeInfo<?>) edges.getType()).getTypeAt(0)___		TypeInformation<NV> valueType = TypeExtractor.createTypeInfo(MapFunction.class, mapper.getClass(), 1, null, null)___		TypeInformation<Edge<K, NV>> returnType = (TypeInformation<Edge<K, NV>>) new TupleTypeInfo(_				Edge.class, keyType, keyType, valueType)___		return mapEdges(mapper, returnType)__	};apply,a,function,to,the,attribute,of,each,edge,in,the,graph,param,mapper,the,map,function,to,apply,return,a,new,graph;suppress,warnings,unchecked,rawtypes,public,nv,graph,k,vv,nv,map,edges,final,map,function,edge,k,ev,nv,mapper,type,information,k,key,type,tuple,type,info,edges,get,type,get,type,at,0,type,information,nv,value,type,type,extractor,create,type,info,map,function,class,mapper,get,class,1,null,null,type,information,edge,k,nv,return,type,type,information,edge,k,nv,new,tuple,type,info,edge,class,key,type,key,type,value,type,return,map,edges,mapper,return,type
Graph -> @SuppressWarnings({ "unchecked", "rawtypes" }) 	public <NV> Graph<K, VV, NV> mapEdges(final MapFunction<Edge<K, EV>, NV> mapper);1470042815;Apply a function to the attribute of each edge in the graph.__@param mapper the map function to apply._@return a new graph;@SuppressWarnings({ "unchecked", "rawtypes" })_	public <NV> Graph<K, VV, NV> mapEdges(final MapFunction<Edge<K, EV>, NV> mapper) {__		TypeInformation<K> keyType = ((TupleTypeInfo<?>) edges.getType()).getTypeAt(0)___		TypeInformation<NV> valueType = TypeExtractor.createTypeInfo(MapFunction.class, mapper.getClass(), 1, null, null)___		TypeInformation<Edge<K, NV>> returnType = (TypeInformation<Edge<K, NV>>) new TupleTypeInfo(_				Edge.class, keyType, keyType, valueType)___		return mapEdges(mapper, returnType)__	};apply,a,function,to,the,attribute,of,each,edge,in,the,graph,param,mapper,the,map,function,to,apply,return,a,new,graph;suppress,warnings,unchecked,rawtypes,public,nv,graph,k,vv,nv,map,edges,final,map,function,edge,k,ev,nv,mapper,type,information,k,key,type,tuple,type,info,edges,get,type,get,type,at,0,type,information,nv,value,type,type,extractor,create,type,info,map,function,class,mapper,get,class,1,null,null,type,information,edge,k,nv,return,type,type,information,edge,k,nv,new,tuple,type,info,edge,class,key,type,key,type,value,type,return,map,edges,mapper,return,type
Graph -> @SuppressWarnings({ "unchecked", "rawtypes" }) 	public <NV> Graph<K, VV, NV> mapEdges(final MapFunction<Edge<K, EV>, NV> mapper);1475684776;Apply a function to the attribute of each edge in the graph.__@param mapper the map function to apply._@return a new graph;@SuppressWarnings({ "unchecked", "rawtypes" })_	public <NV> Graph<K, VV, NV> mapEdges(final MapFunction<Edge<K, EV>, NV> mapper) {__		TypeInformation<K> keyType = ((TupleTypeInfo<?>) edges.getType()).getTypeAt(0)___		TypeInformation<NV> valueType = TypeExtractor.createTypeInfo(MapFunction.class, mapper.getClass(), 1, null, null)___		TypeInformation<Edge<K, NV>> returnType = (TypeInformation<Edge<K, NV>>) new TupleTypeInfo(_				Edge.class, keyType, keyType, valueType)___		return mapEdges(mapper, returnType)__	};apply,a,function,to,the,attribute,of,each,edge,in,the,graph,param,mapper,the,map,function,to,apply,return,a,new,graph;suppress,warnings,unchecked,rawtypes,public,nv,graph,k,vv,nv,map,edges,final,map,function,edge,k,ev,nv,mapper,type,information,k,key,type,tuple,type,info,edges,get,type,get,type,at,0,type,information,nv,value,type,type,extractor,create,type,info,map,function,class,mapper,get,class,1,null,null,type,information,edge,k,nv,return,type,type,information,edge,k,nv,new,tuple,type,info,edge,class,key,type,key,type,value,type,return,map,edges,mapper,return,type
Graph -> @SuppressWarnings({ "unchecked", "rawtypes" }) 	public <NV> Graph<K, VV, NV> mapEdges(final MapFunction<Edge<K, EV>, NV> mapper);1475685606;Apply a function to the attribute of each edge in the graph.__@param mapper the map function to apply._@return a new graph;@SuppressWarnings({ "unchecked", "rawtypes" })_	public <NV> Graph<K, VV, NV> mapEdges(final MapFunction<Edge<K, EV>, NV> mapper) {__		TypeInformation<K> keyType = ((TupleTypeInfo<?>) edges.getType()).getTypeAt(0)___		TypeInformation<NV> valueType = TypeExtractor.createTypeInfo(MapFunction.class, mapper.getClass(), 1, null, null)___		TypeInformation<Edge<K, NV>> returnType = (TypeInformation<Edge<K, NV>>) new TupleTypeInfo(_				Edge.class, keyType, keyType, valueType)___		return mapEdges(mapper, returnType)__	};apply,a,function,to,the,attribute,of,each,edge,in,the,graph,param,mapper,the,map,function,to,apply,return,a,new,graph;suppress,warnings,unchecked,rawtypes,public,nv,graph,k,vv,nv,map,edges,final,map,function,edge,k,ev,nv,mapper,type,information,k,key,type,tuple,type,info,edges,get,type,get,type,at,0,type,information,nv,value,type,type,extractor,create,type,info,map,function,class,mapper,get,class,1,null,null,type,information,edge,k,nv,return,type,type,information,edge,k,nv,new,tuple,type,info,edge,class,key,type,key,type,value,type,return,map,edges,mapper,return,type
Graph -> @SuppressWarnings({ "unchecked", "rawtypes" }) 	public <NV> Graph<K, VV, NV> mapEdges(final MapFunction<Edge<K, EV>, NV> mapper);1481745825;Apply a function to the attribute of each edge in the graph.__@param mapper the map function to apply._@return a new graph;@SuppressWarnings({ "unchecked", "rawtypes" })_	public <NV> Graph<K, VV, NV> mapEdges(final MapFunction<Edge<K, EV>, NV> mapper) {__		TypeInformation<K> keyType = ((TupleTypeInfo<?>) edges.getType()).getTypeAt(0)___		TypeInformation<NV> valueType = TypeExtractor.createTypeInfo(MapFunction.class, mapper.getClass(), 1, null, null)___		TypeInformation<Edge<K, NV>> returnType = (TypeInformation<Edge<K, NV>>) new TupleTypeInfo(_				Edge.class, keyType, keyType, valueType)___		return mapEdges(mapper, returnType)__	};apply,a,function,to,the,attribute,of,each,edge,in,the,graph,param,mapper,the,map,function,to,apply,return,a,new,graph;suppress,warnings,unchecked,rawtypes,public,nv,graph,k,vv,nv,map,edges,final,map,function,edge,k,ev,nv,mapper,type,information,k,key,type,tuple,type,info,edges,get,type,get,type,at,0,type,information,nv,value,type,type,extractor,create,type,info,map,function,class,mapper,get,class,1,null,null,type,information,edge,k,nv,return,type,type,information,edge,k,nv,new,tuple,type,info,edge,class,key,type,key,type,value,type,return,map,edges,mapper,return,type
Graph -> @SuppressWarnings({ "unchecked", "rawtypes" }) 	public <NV> Graph<K, VV, NV> mapEdges(final MapFunction<Edge<K, EV>, NV> mapper);1481881009;Apply a function to the attribute of each edge in the graph.__@param mapper the map function to apply._@return a new graph;@SuppressWarnings({ "unchecked", "rawtypes" })_	public <NV> Graph<K, VV, NV> mapEdges(final MapFunction<Edge<K, EV>, NV> mapper) {__		TypeInformation<K> keyType = ((TupleTypeInfo<?>) edges.getType()).getTypeAt(0)___		TypeInformation<NV> valueType = TypeExtractor.createTypeInfo(MapFunction.class, mapper.getClass(), 1, edges.getType(), null)___		TypeInformation<Edge<K, NV>> returnType = (TypeInformation<Edge<K, NV>>) new TupleTypeInfo(_				Edge.class, keyType, keyType, valueType)___		return mapEdges(mapper, returnType)__	};apply,a,function,to,the,attribute,of,each,edge,in,the,graph,param,mapper,the,map,function,to,apply,return,a,new,graph;suppress,warnings,unchecked,rawtypes,public,nv,graph,k,vv,nv,map,edges,final,map,function,edge,k,ev,nv,mapper,type,information,k,key,type,tuple,type,info,edges,get,type,get,type,at,0,type,information,nv,value,type,type,extractor,create,type,info,map,function,class,mapper,get,class,1,edges,get,type,null,type,information,edge,k,nv,return,type,type,information,edge,k,nv,new,tuple,type,info,edge,class,key,type,key,type,value,type,return,map,edges,mapper,return,type
Graph -> @SuppressWarnings({ "unchecked", "rawtypes" }) 	public <NV> Graph<K, VV, NV> mapEdges(final MapFunction<Edge<K, EV>, NV> mapper);1484160227;Apply a function to the attribute of each edge in the graph.__@param mapper the map function to apply._@return a new graph;@SuppressWarnings({ "unchecked", "rawtypes" })_	public <NV> Graph<K, VV, NV> mapEdges(final MapFunction<Edge<K, EV>, NV> mapper) {__		TypeInformation<K> keyType = ((TupleTypeInfo<?>) edges.getType()).getTypeAt(0)___		TypeInformation<NV> valueType = TypeExtractor.createTypeInfo(MapFunction.class, mapper.getClass(), 1, edges.getType(), null)___		TypeInformation<Edge<K, NV>> returnType = (TypeInformation<Edge<K, NV>>) new TupleTypeInfo(_				Edge.class, keyType, keyType, valueType)___		return mapEdges(mapper, returnType)__	};apply,a,function,to,the,attribute,of,each,edge,in,the,graph,param,mapper,the,map,function,to,apply,return,a,new,graph;suppress,warnings,unchecked,rawtypes,public,nv,graph,k,vv,nv,map,edges,final,map,function,edge,k,ev,nv,mapper,type,information,k,key,type,tuple,type,info,edges,get,type,get,type,at,0,type,information,nv,value,type,type,extractor,create,type,info,map,function,class,mapper,get,class,1,edges,get,type,null,type,information,edge,k,nv,return,type,type,information,edge,k,nv,new,tuple,type,info,edge,class,key,type,key,type,value,type,return,map,edges,mapper,return,type
Graph -> @SuppressWarnings({ "unchecked", "rawtypes" }) 	public <NV> Graph<K, VV, NV> mapEdges(final MapFunction<Edge<K, EV>, NV> mapper);1484685504;Apply a function to the attribute of each edge in the graph.__@param mapper the map function to apply._@return a new graph;@SuppressWarnings({ "unchecked", "rawtypes" })_	public <NV> Graph<K, VV, NV> mapEdges(final MapFunction<Edge<K, EV>, NV> mapper) {__		TypeInformation<K> keyType = ((TupleTypeInfo<?>) edges.getType()).getTypeAt(0)___		TypeInformation<NV> valueType = TypeExtractor.createTypeInfo(MapFunction.class, mapper.getClass(), 1, edges.getType(), null)___		TypeInformation<Edge<K, NV>> returnType = (TypeInformation<Edge<K, NV>>) new TupleTypeInfo(_				Edge.class, keyType, keyType, valueType)___		return mapEdges(mapper, returnType)__	};apply,a,function,to,the,attribute,of,each,edge,in,the,graph,param,mapper,the,map,function,to,apply,return,a,new,graph;suppress,warnings,unchecked,rawtypes,public,nv,graph,k,vv,nv,map,edges,final,map,function,edge,k,ev,nv,mapper,type,information,k,key,type,tuple,type,info,edges,get,type,get,type,at,0,type,information,nv,value,type,type,extractor,create,type,info,map,function,class,mapper,get,class,1,edges,get,type,null,type,information,edge,k,nv,return,type,type,information,edge,k,nv,new,tuple,type,info,edge,class,key,type,key,type,value,type,return,map,edges,mapper,return,type
Graph -> @SuppressWarnings({ "unchecked", "rawtypes" }) 	public <NV> Graph<K, VV, NV> mapEdges(final MapFunction<Edge<K, EV>, NV> mapper);1489068942;Apply a function to the attribute of each edge in the graph.__@param mapper the map function to apply._@return a new graph;@SuppressWarnings({ "unchecked", "rawtypes" })_	public <NV> Graph<K, VV, NV> mapEdges(final MapFunction<Edge<K, EV>, NV> mapper) {__		TypeInformation<K> keyType = ((TupleTypeInfo<?>) edges.getType()).getTypeAt(0)___		TypeInformation<NV> valueType = TypeExtractor.createTypeInfo(MapFunction.class, mapper.getClass(), 1, edges.getType(), null)___		TypeInformation<Edge<K, NV>> returnType = (TypeInformation<Edge<K, NV>>) new TupleTypeInfo(_				Edge.class, keyType, keyType, valueType)___		return mapEdges(mapper, returnType)__	};apply,a,function,to,the,attribute,of,each,edge,in,the,graph,param,mapper,the,map,function,to,apply,return,a,new,graph;suppress,warnings,unchecked,rawtypes,public,nv,graph,k,vv,nv,map,edges,final,map,function,edge,k,ev,nv,mapper,type,information,k,key,type,tuple,type,info,edges,get,type,get,type,at,0,type,information,nv,value,type,type,extractor,create,type,info,map,function,class,mapper,get,class,1,edges,get,type,null,type,information,edge,k,nv,return,type,type,information,edge,k,nv,new,tuple,type,info,edge,class,key,type,key,type,value,type,return,map,edges,mapper,return,type
Graph -> @SuppressWarnings({ "unchecked", "rawtypes" }) 	public <NV> Graph<K, VV, NV> mapEdges(final MapFunction<Edge<K, EV>, NV> mapper);1490973446;Apply a function to the attribute of each edge in the graph.__@param mapper the map function to apply._@return a new graph;@SuppressWarnings({ "unchecked", "rawtypes" })_	public <NV> Graph<K, VV, NV> mapEdges(final MapFunction<Edge<K, EV>, NV> mapper) {__		TypeInformation<K> keyType = ((TupleTypeInfo<?>) edges.getType()).getTypeAt(0)___		TypeInformation<NV> valueType___		if (mapper instanceof ResultTypeQueryable) {_			valueType = ((ResultTypeQueryable) mapper).getProducedType()__		} else {_			valueType = TypeExtractor.createTypeInfo(MapFunction.class, mapper.getClass(), 1, edges.getType(), null)__		}__		TypeInformation<Edge<K, NV>> returnType = (TypeInformation<Edge<K, NV>>) new TupleTypeInfo(_				Edge.class, keyType, keyType, valueType)___		return mapEdges(mapper, returnType)__	};apply,a,function,to,the,attribute,of,each,edge,in,the,graph,param,mapper,the,map,function,to,apply,return,a,new,graph;suppress,warnings,unchecked,rawtypes,public,nv,graph,k,vv,nv,map,edges,final,map,function,edge,k,ev,nv,mapper,type,information,k,key,type,tuple,type,info,edges,get,type,get,type,at,0,type,information,nv,value,type,if,mapper,instanceof,result,type,queryable,value,type,result,type,queryable,mapper,get,produced,type,else,value,type,type,extractor,create,type,info,map,function,class,mapper,get,class,1,edges,get,type,null,type,information,edge,k,nv,return,type,type,information,edge,k,nv,new,tuple,type,info,edge,class,key,type,key,type,value,type,return,map,edges,mapper,return,type
Graph -> @SuppressWarnings({ "unchecked", "rawtypes" }) 	public <NV> Graph<K, VV, NV> mapEdges(final MapFunction<Edge<K, EV>, NV> mapper);1495819075;Apply a function to the attribute of each edge in the graph.__@param mapper the map function to apply._@return a new graph;@SuppressWarnings({ "unchecked", "rawtypes" })_	public <NV> Graph<K, VV, NV> mapEdges(final MapFunction<Edge<K, EV>, NV> mapper) {__		TypeInformation<K> keyType = ((TupleTypeInfo<?>) edges.getType()).getTypeAt(0)___		TypeInformation<NV> valueType___		if (mapper instanceof ResultTypeQueryable) {_			valueType = ((ResultTypeQueryable) mapper).getProducedType()__		} else {_			valueType = TypeExtractor.createTypeInfo(MapFunction.class, mapper.getClass(), 1, edges.getType(), null)__		}__		TypeInformation<Edge<K, NV>> returnType = (TypeInformation<Edge<K, NV>>) new TupleTypeInfo(_				Edge.class, keyType, keyType, valueType)___		return mapEdges(mapper, returnType)__	};apply,a,function,to,the,attribute,of,each,edge,in,the,graph,param,mapper,the,map,function,to,apply,return,a,new,graph;suppress,warnings,unchecked,rawtypes,public,nv,graph,k,vv,nv,map,edges,final,map,function,edge,k,ev,nv,mapper,type,information,k,key,type,tuple,type,info,edges,get,type,get,type,at,0,type,information,nv,value,type,if,mapper,instanceof,result,type,queryable,value,type,result,type,queryable,mapper,get,produced,type,else,value,type,type,extractor,create,type,info,map,function,class,mapper,get,class,1,edges,get,type,null,type,information,edge,k,nv,return,type,type,information,edge,k,nv,new,tuple,type,info,edge,class,key,type,key,type,value,type,return,map,edges,mapper,return,type
Graph -> @SuppressWarnings({ "unchecked", "rawtypes" }) 	public <NV> Graph<K, VV, NV> mapEdges(final MapFunction<Edge<K, EV>, NV> mapper);1502111816;Apply a function to the attribute of each edge in the graph.__@param mapper the map function to apply._@return a new graph;@SuppressWarnings({ "unchecked", "rawtypes" })_	public <NV> Graph<K, VV, NV> mapEdges(final MapFunction<Edge<K, EV>, NV> mapper) {__		TypeInformation<K> keyType = ((TupleTypeInfo<?>) edges.getType()).getTypeAt(0)___		TypeInformation<NV> valueType___		if (mapper instanceof ResultTypeQueryable) {_			valueType = ((ResultTypeQueryable) mapper).getProducedType()__		} else {_			valueType = TypeExtractor.createTypeInfo(MapFunction.class, mapper.getClass(), 1, edges.getType(), null)__		}__		TypeInformation<Edge<K, NV>> returnType = (TypeInformation<Edge<K, NV>>) new TupleTypeInfo(_				Edge.class, keyType, keyType, valueType)___		return mapEdges(mapper, returnType)__	};apply,a,function,to,the,attribute,of,each,edge,in,the,graph,param,mapper,the,map,function,to,apply,return,a,new,graph;suppress,warnings,unchecked,rawtypes,public,nv,graph,k,vv,nv,map,edges,final,map,function,edge,k,ev,nv,mapper,type,information,k,key,type,tuple,type,info,edges,get,type,get,type,at,0,type,information,nv,value,type,if,mapper,instanceof,result,type,queryable,value,type,result,type,queryable,mapper,get,produced,type,else,value,type,type,extractor,create,type,info,map,function,class,mapper,get,class,1,edges,get,type,null,type,information,edge,k,nv,return,type,type,information,edge,k,nv,new,tuple,type,info,edge,class,key,type,key,type,value,type,return,map,edges,mapper,return,type
Graph -> public <NV> Graph<K, VV, NV> mapEdges(final MapFunction<Edge<K, EV>, NV> mapper, TypeInformation<Edge<K,NV>> returnType);1444404795;Apply a function to the attribute of each edge in the graph.__@param mapper the map function to apply._@param returnType the explicit return type._@return a new graph;public <NV> Graph<K, VV, NV> mapEdges(final MapFunction<Edge<K, EV>, NV> mapper, TypeInformation<Edge<K,NV>> returnType) {_		DataSet<Edge<K, NV>> mappedEdges = edges.map(_				new MapFunction<Edge<K, EV>, Edge<K, NV>>() {_					public Edge<K, NV> map(Edge<K, EV> value) throws Exception {_						return new Edge<K, NV>(value.f0, value.f1, mapper_								.map(value))__					}_				})_				.returns(returnType)_				.withForwardedFields("f0_ f1")___		return new Graph<K, VV, NV>(this.vertices, mappedEdges, this.context)__	};apply,a,function,to,the,attribute,of,each,edge,in,the,graph,param,mapper,the,map,function,to,apply,param,return,type,the,explicit,return,type,return,a,new,graph;public,nv,graph,k,vv,nv,map,edges,final,map,function,edge,k,ev,nv,mapper,type,information,edge,k,nv,return,type,data,set,edge,k,nv,mapped,edges,edges,map,new,map,function,edge,k,ev,edge,k,nv,public,edge,k,nv,map,edge,k,ev,value,throws,exception,return,new,edge,k,nv,value,f0,value,f1,mapper,map,value,returns,return,type,with,forwarded,fields,f0,f1,return,new,graph,k,vv,nv,this,vertices,mapped,edges,this,context
Graph -> public <NV> Graph<K, VV, NV> mapEdges(final MapFunction<Edge<K, EV>, NV> mapper, TypeInformation<Edge<K,NV>> returnType);1445261977;Apply a function to the attribute of each edge in the graph.__@param mapper the map function to apply._@param returnType the explicit return type._@return a new graph;public <NV> Graph<K, VV, NV> mapEdges(final MapFunction<Edge<K, EV>, NV> mapper, TypeInformation<Edge<K,NV>> returnType) {_		DataSet<Edge<K, NV>> mappedEdges = edges.map(_				new MapFunction<Edge<K, EV>, Edge<K, NV>>() {_					public Edge<K, NV> map(Edge<K, EV> value) throws Exception {_						return new Edge<K, NV>(value.f0, value.f1, mapper_								.map(value))__					}_				})_				.returns(returnType)_				.withForwardedFields("f0_ f1")___		return new Graph<K, VV, NV>(this.vertices, mappedEdges, this.context)__	};apply,a,function,to,the,attribute,of,each,edge,in,the,graph,param,mapper,the,map,function,to,apply,param,return,type,the,explicit,return,type,return,a,new,graph;public,nv,graph,k,vv,nv,map,edges,final,map,function,edge,k,ev,nv,mapper,type,information,edge,k,nv,return,type,data,set,edge,k,nv,mapped,edges,edges,map,new,map,function,edge,k,ev,edge,k,nv,public,edge,k,nv,map,edge,k,ev,value,throws,exception,return,new,edge,k,nv,value,f0,value,f1,mapper,map,value,returns,return,type,with,forwarded,fields,f0,f1,return,new,graph,k,vv,nv,this,vertices,mapped,edges,this,context
Graph -> public <NV> Graph<K, VV, NV> mapEdges(final MapFunction<Edge<K, EV>, NV> mapper, TypeInformation<Edge<K,NV>> returnType);1445854323;Apply a function to the attribute of each edge in the graph.__@param mapper the map function to apply._@param returnType the explicit return type._@return a new graph;public <NV> Graph<K, VV, NV> mapEdges(final MapFunction<Edge<K, EV>, NV> mapper, TypeInformation<Edge<K,NV>> returnType) {_		DataSet<Edge<K, NV>> mappedEdges = edges.map(_				new MapFunction<Edge<K, EV>, Edge<K, NV>>() {_					public Edge<K, NV> map(Edge<K, EV> value) throws Exception {_						return new Edge<K, NV>(value.f0, value.f1, mapper_								.map(value))__					}_				})_				.returns(returnType)_				.withForwardedFields("f0_ f1")___		return new Graph<K, VV, NV>(this.vertices, mappedEdges, this.context)__	};apply,a,function,to,the,attribute,of,each,edge,in,the,graph,param,mapper,the,map,function,to,apply,param,return,type,the,explicit,return,type,return,a,new,graph;public,nv,graph,k,vv,nv,map,edges,final,map,function,edge,k,ev,nv,mapper,type,information,edge,k,nv,return,type,data,set,edge,k,nv,mapped,edges,edges,map,new,map,function,edge,k,ev,edge,k,nv,public,edge,k,nv,map,edge,k,ev,value,throws,exception,return,new,edge,k,nv,value,f0,value,f1,mapper,map,value,returns,return,type,with,forwarded,fields,f0,f1,return,new,graph,k,vv,nv,this,vertices,mapped,edges,this,context
Graph -> public <NV> Graph<K, VV, NV> mapEdges(final MapFunction<Edge<K, EV>, NV> mapper, TypeInformation<Edge<K,NV>> returnType);1446112342;Apply a function to the attribute of each edge in the graph.__@param mapper the map function to apply._@param returnType the explicit return type._@return a new graph;public <NV> Graph<K, VV, NV> mapEdges(final MapFunction<Edge<K, EV>, NV> mapper, TypeInformation<Edge<K,NV>> returnType) {_		DataSet<Edge<K, NV>> mappedEdges = edges.map(_				new MapFunction<Edge<K, EV>, Edge<K, NV>>() {_					public Edge<K, NV> map(Edge<K, EV> value) throws Exception {_						return new Edge<K, NV>(value.f0, value.f1, mapper_								.map(value))__					}_				})_				.returns(returnType)_				.withForwardedFields("f0_ f1")___		return new Graph<K, VV, NV>(this.vertices, mappedEdges, this.context)__	};apply,a,function,to,the,attribute,of,each,edge,in,the,graph,param,mapper,the,map,function,to,apply,param,return,type,the,explicit,return,type,return,a,new,graph;public,nv,graph,k,vv,nv,map,edges,final,map,function,edge,k,ev,nv,mapper,type,information,edge,k,nv,return,type,data,set,edge,k,nv,mapped,edges,edges,map,new,map,function,edge,k,ev,edge,k,nv,public,edge,k,nv,map,edge,k,ev,value,throws,exception,return,new,edge,k,nv,value,f0,value,f1,mapper,map,value,returns,return,type,with,forwarded,fields,f0,f1,return,new,graph,k,vv,nv,this,vertices,mapped,edges,this,context
Graph -> public <NV> Graph<K, VV, NV> mapEdges(final MapFunction<Edge<K, EV>, NV> mapper, TypeInformation<Edge<K,NV>> returnType);1447073368;Apply a function to the attribute of each edge in the graph.__@param mapper the map function to apply._@param returnType the explicit return type._@return a new graph;public <NV> Graph<K, VV, NV> mapEdges(final MapFunction<Edge<K, EV>, NV> mapper, TypeInformation<Edge<K,NV>> returnType) {_		DataSet<Edge<K, NV>> mappedEdges = edges.map(_				new MapFunction<Edge<K, EV>, Edge<K, NV>>() {_					public Edge<K, NV> map(Edge<K, EV> value) throws Exception {_						return new Edge<K, NV>(value.f0, value.f1, mapper_								.map(value))__					}_				})_				.returns(returnType)_				.withForwardedFields("f0_ f1")___		return new Graph<K, VV, NV>(this.vertices, mappedEdges, this.context)__	};apply,a,function,to,the,attribute,of,each,edge,in,the,graph,param,mapper,the,map,function,to,apply,param,return,type,the,explicit,return,type,return,a,new,graph;public,nv,graph,k,vv,nv,map,edges,final,map,function,edge,k,ev,nv,mapper,type,information,edge,k,nv,return,type,data,set,edge,k,nv,mapped,edges,edges,map,new,map,function,edge,k,ev,edge,k,nv,public,edge,k,nv,map,edge,k,ev,value,throws,exception,return,new,edge,k,nv,value,f0,value,f1,mapper,map,value,returns,return,type,with,forwarded,fields,f0,f1,return,new,graph,k,vv,nv,this,vertices,mapped,edges,this,context
Graph -> public <NV> Graph<K, VV, NV> mapEdges(final MapFunction<Edge<K, EV>, NV> mapper, TypeInformation<Edge<K,NV>> returnType);1454404649;Apply a function to the attribute of each edge in the graph.__@param mapper the map function to apply._@param returnType the explicit return type._@return a new graph;public <NV> Graph<K, VV, NV> mapEdges(final MapFunction<Edge<K, EV>, NV> mapper, TypeInformation<Edge<K,NV>> returnType) {_		DataSet<Edge<K, NV>> mappedEdges = edges.map(_				new MapFunction<Edge<K, EV>, Edge<K, NV>>() {_					public Edge<K, NV> map(Edge<K, EV> value) throws Exception {_						return new Edge<K, NV>(value.f0, value.f1, mapper_								.map(value))__					}_				})_				.returns(returnType)_				.withForwardedFields("f0_ f1")___		return new Graph<K, VV, NV>(this.vertices, mappedEdges, this.context)__	};apply,a,function,to,the,attribute,of,each,edge,in,the,graph,param,mapper,the,map,function,to,apply,param,return,type,the,explicit,return,type,return,a,new,graph;public,nv,graph,k,vv,nv,map,edges,final,map,function,edge,k,ev,nv,mapper,type,information,edge,k,nv,return,type,data,set,edge,k,nv,mapped,edges,edges,map,new,map,function,edge,k,ev,edge,k,nv,public,edge,k,nv,map,edge,k,ev,value,throws,exception,return,new,edge,k,nv,value,f0,value,f1,mapper,map,value,returns,return,type,with,forwarded,fields,f0,f1,return,new,graph,k,vv,nv,this,vertices,mapped,edges,this,context
Graph -> public <NV> Graph<K, VV, NV> mapEdges(final MapFunction<Edge<K, EV>, NV> mapper, TypeInformation<Edge<K,NV>> returnType);1458583829;Apply a function to the attribute of each edge in the graph.__@param mapper the map function to apply._@param returnType the explicit return type._@return a new graph;public <NV> Graph<K, VV, NV> mapEdges(final MapFunction<Edge<K, EV>, NV> mapper, TypeInformation<Edge<K,NV>> returnType) {_		DataSet<Edge<K, NV>> mappedEdges = edges.map(_				new MapFunction<Edge<K, EV>, Edge<K, NV>>() {_					public Edge<K, NV> map(Edge<K, EV> value) throws Exception {_						return new Edge<K, NV>(value.f0, value.f1, mapper_								.map(value))__					}_				})_				.returns(returnType)_				.withForwardedFields("f0_ f1")___		return new Graph<K, VV, NV>(this.vertices, mappedEdges, this.context)__	};apply,a,function,to,the,attribute,of,each,edge,in,the,graph,param,mapper,the,map,function,to,apply,param,return,type,the,explicit,return,type,return,a,new,graph;public,nv,graph,k,vv,nv,map,edges,final,map,function,edge,k,ev,nv,mapper,type,information,edge,k,nv,return,type,data,set,edge,k,nv,mapped,edges,edges,map,new,map,function,edge,k,ev,edge,k,nv,public,edge,k,nv,map,edge,k,ev,value,throws,exception,return,new,edge,k,nv,value,f0,value,f1,mapper,map,value,returns,return,type,with,forwarded,fields,f0,f1,return,new,graph,k,vv,nv,this,vertices,mapped,edges,this,context
Graph -> public <NV> Graph<K, VV, NV> mapEdges(final MapFunction<Edge<K, EV>, NV> mapper, TypeInformation<Edge<K,NV>> returnType);1458583829;Apply a function to the attribute of each edge in the graph.__@param mapper the map function to apply._@param returnType the explicit return type._@return a new graph;public <NV> Graph<K, VV, NV> mapEdges(final MapFunction<Edge<K, EV>, NV> mapper, TypeInformation<Edge<K,NV>> returnType) {_		DataSet<Edge<K, NV>> mappedEdges = edges.map(_				new MapFunction<Edge<K, EV>, Edge<K, NV>>() {_					public Edge<K, NV> map(Edge<K, EV> value) throws Exception {_						return new Edge<K, NV>(value.f0, value.f1, mapper_								.map(value))__					}_				})_				.returns(returnType)_				.withForwardedFields("f0_ f1")___		return new Graph<K, VV, NV>(this.vertices, mappedEdges, this.context)__	};apply,a,function,to,the,attribute,of,each,edge,in,the,graph,param,mapper,the,map,function,to,apply,param,return,type,the,explicit,return,type,return,a,new,graph;public,nv,graph,k,vv,nv,map,edges,final,map,function,edge,k,ev,nv,mapper,type,information,edge,k,nv,return,type,data,set,edge,k,nv,mapped,edges,edges,map,new,map,function,edge,k,ev,edge,k,nv,public,edge,k,nv,map,edge,k,ev,value,throws,exception,return,new,edge,k,nv,value,f0,value,f1,mapper,map,value,returns,return,type,with,forwarded,fields,f0,f1,return,new,graph,k,vv,nv,this,vertices,mapped,edges,this,context
Graph -> public <NV> Graph<K, VV, NV> mapEdges(final MapFunction<Edge<K, EV>, NV> mapper, TypeInformation<Edge<K,NV>> returnType);1462100316;Apply a function to the attribute of each edge in the graph.__@param mapper the map function to apply._@param returnType the explicit return type._@return a new graph;public <NV> Graph<K, VV, NV> mapEdges(final MapFunction<Edge<K, EV>, NV> mapper, TypeInformation<Edge<K,NV>> returnType) {_		DataSet<Edge<K, NV>> mappedEdges = edges.map(_				new MapFunction<Edge<K, EV>, Edge<K, NV>>() {_					public Edge<K, NV> map(Edge<K, EV> value) throws Exception {_						return new Edge<K, NV>(value.f0, value.f1, mapper_								.map(value))__					}_				})_				.returns(returnType)_				.withForwardedFields("f0_ f1")___		return new Graph<K, VV, NV>(this.vertices, mappedEdges, this.context)__	};apply,a,function,to,the,attribute,of,each,edge,in,the,graph,param,mapper,the,map,function,to,apply,param,return,type,the,explicit,return,type,return,a,new,graph;public,nv,graph,k,vv,nv,map,edges,final,map,function,edge,k,ev,nv,mapper,type,information,edge,k,nv,return,type,data,set,edge,k,nv,mapped,edges,edges,map,new,map,function,edge,k,ev,edge,k,nv,public,edge,k,nv,map,edge,k,ev,value,throws,exception,return,new,edge,k,nv,value,f0,value,f1,mapper,map,value,returns,return,type,with,forwarded,fields,f0,f1,return,new,graph,k,vv,nv,this,vertices,mapped,edges,this,context
Graph -> public <NV> Graph<K, VV, NV> mapEdges(final MapFunction<Edge<K, EV>, NV> mapper, TypeInformation<Edge<K,NV>> returnType);1462100316;Apply a function to the attribute of each edge in the graph.__@param mapper the map function to apply._@param returnType the explicit return type._@return a new graph;public <NV> Graph<K, VV, NV> mapEdges(final MapFunction<Edge<K, EV>, NV> mapper, TypeInformation<Edge<K,NV>> returnType) {_		DataSet<Edge<K, NV>> mappedEdges = edges.map(_				new MapFunction<Edge<K, EV>, Edge<K, NV>>() {_					public Edge<K, NV> map(Edge<K, EV> value) throws Exception {_						return new Edge<K, NV>(value.f0, value.f1, mapper_								.map(value))__					}_				})_				.returns(returnType)_				.withForwardedFields("f0_ f1")___		return new Graph<K, VV, NV>(this.vertices, mappedEdges, this.context)__	};apply,a,function,to,the,attribute,of,each,edge,in,the,graph,param,mapper,the,map,function,to,apply,param,return,type,the,explicit,return,type,return,a,new,graph;public,nv,graph,k,vv,nv,map,edges,final,map,function,edge,k,ev,nv,mapper,type,information,edge,k,nv,return,type,data,set,edge,k,nv,mapped,edges,edges,map,new,map,function,edge,k,ev,edge,k,nv,public,edge,k,nv,map,edge,k,ev,value,throws,exception,return,new,edge,k,nv,value,f0,value,f1,mapper,map,value,returns,return,type,with,forwarded,fields,f0,f1,return,new,graph,k,vv,nv,this,vertices,mapped,edges,this,context
Graph -> public <NV> Graph<K, VV, NV> mapEdges(final MapFunction<Edge<K, EV>, NV> mapper, TypeInformation<Edge<K,NV>> returnType);1462205213;Apply a function to the attribute of each edge in the graph.__@param mapper the map function to apply._@param returnType the explicit return type._@return a new graph;public <NV> Graph<K, VV, NV> mapEdges(final MapFunction<Edge<K, EV>, NV> mapper, TypeInformation<Edge<K,NV>> returnType) {_		DataSet<Edge<K, NV>> mappedEdges = edges.map(_				new MapFunction<Edge<K, EV>, Edge<K, NV>>() {_					public Edge<K, NV> map(Edge<K, EV> value) throws Exception {_						return new Edge<K, NV>(value.f0, value.f1, mapper_								.map(value))__					}_				})_				.returns(returnType)_				.withForwardedFields("f0_ f1")___		return new Graph<K, VV, NV>(this.vertices, mappedEdges, this.context)__	};apply,a,function,to,the,attribute,of,each,edge,in,the,graph,param,mapper,the,map,function,to,apply,param,return,type,the,explicit,return,type,return,a,new,graph;public,nv,graph,k,vv,nv,map,edges,final,map,function,edge,k,ev,nv,mapper,type,information,edge,k,nv,return,type,data,set,edge,k,nv,mapped,edges,edges,map,new,map,function,edge,k,ev,edge,k,nv,public,edge,k,nv,map,edge,k,ev,value,throws,exception,return,new,edge,k,nv,value,f0,value,f1,mapper,map,value,returns,return,type,with,forwarded,fields,f0,f1,return,new,graph,k,vv,nv,this,vertices,mapped,edges,this,context
Graph -> public <NV> Graph<K, VV, NV> mapEdges(final MapFunction<Edge<K, EV>, NV> mapper, TypeInformation<Edge<K,NV>> returnType);1462208859;Apply a function to the attribute of each edge in the graph.__@param mapper the map function to apply._@param returnType the explicit return type._@return a new graph;public <NV> Graph<K, VV, NV> mapEdges(final MapFunction<Edge<K, EV>, NV> mapper, TypeInformation<Edge<K,NV>> returnType) {_		DataSet<Edge<K, NV>> mappedEdges = edges.map(_				new MapFunction<Edge<K, EV>, Edge<K, NV>>() {_					public Edge<K, NV> map(Edge<K, EV> value) throws Exception {_						return new Edge<K, NV>(value.f0, value.f1, mapper_								.map(value))__					}_				})_				.returns(returnType)_				.withForwardedFields("f0_ f1")___		return new Graph<K, VV, NV>(this.vertices, mappedEdges, this.context)__	};apply,a,function,to,the,attribute,of,each,edge,in,the,graph,param,mapper,the,map,function,to,apply,param,return,type,the,explicit,return,type,return,a,new,graph;public,nv,graph,k,vv,nv,map,edges,final,map,function,edge,k,ev,nv,mapper,type,information,edge,k,nv,return,type,data,set,edge,k,nv,mapped,edges,edges,map,new,map,function,edge,k,ev,edge,k,nv,public,edge,k,nv,map,edge,k,ev,value,throws,exception,return,new,edge,k,nv,value,f0,value,f1,mapper,map,value,returns,return,type,with,forwarded,fields,f0,f1,return,new,graph,k,vv,nv,this,vertices,mapped,edges,this,context
Graph -> public <NV> Graph<K, VV, NV> mapEdges(final MapFunction<Edge<K, EV>, NV> mapper, TypeInformation<Edge<K,NV>> returnType);1462809297;Apply a function to the attribute of each edge in the graph.__@param mapper the map function to apply._@param returnType the explicit return type._@return a new graph;public <NV> Graph<K, VV, NV> mapEdges(final MapFunction<Edge<K, EV>, NV> mapper, TypeInformation<Edge<K,NV>> returnType) {_		DataSet<Edge<K, NV>> mappedEdges = edges.map(_				new MapFunction<Edge<K, EV>, Edge<K, NV>>() {_					public Edge<K, NV> map(Edge<K, EV> value) throws Exception {_						return new Edge<K, NV>(value.f0, value.f1, mapper_								.map(value))__					}_				})_				.returns(returnType)_				.withForwardedFields("f0_ f1")___		return new Graph<K, VV, NV>(this.vertices, mappedEdges, this.context)__	};apply,a,function,to,the,attribute,of,each,edge,in,the,graph,param,mapper,the,map,function,to,apply,param,return,type,the,explicit,return,type,return,a,new,graph;public,nv,graph,k,vv,nv,map,edges,final,map,function,edge,k,ev,nv,mapper,type,information,edge,k,nv,return,type,data,set,edge,k,nv,mapped,edges,edges,map,new,map,function,edge,k,ev,edge,k,nv,public,edge,k,nv,map,edge,k,ev,value,throws,exception,return,new,edge,k,nv,value,f0,value,f1,mapper,map,value,returns,return,type,with,forwarded,fields,f0,f1,return,new,graph,k,vv,nv,this,vertices,mapped,edges,this,context
Graph -> public <NV> Graph<K, VV, NV> mapEdges(final MapFunction<Edge<K, EV>, NV> mapper, TypeInformation<Edge<K,NV>> returnType);1465316775;Apply a function to the attribute of each edge in the graph.__@param mapper the map function to apply._@param returnType the explicit return type._@return a new graph;public <NV> Graph<K, VV, NV> mapEdges(final MapFunction<Edge<K, EV>, NV> mapper, TypeInformation<Edge<K,NV>> returnType) {_		DataSet<Edge<K, NV>> mappedEdges = edges.map(_				new MapFunction<Edge<K, EV>, Edge<K, NV>>() {_					public Edge<K, NV> map(Edge<K, EV> value) throws Exception {_						return new Edge<K, NV>(value.f0, value.f1, mapper_								.map(value))__					}_				})_				.returns(returnType)_				.withForwardedFields("f0_ f1")___		return new Graph<K, VV, NV>(this.vertices, mappedEdges, this.context)__	};apply,a,function,to,the,attribute,of,each,edge,in,the,graph,param,mapper,the,map,function,to,apply,param,return,type,the,explicit,return,type,return,a,new,graph;public,nv,graph,k,vv,nv,map,edges,final,map,function,edge,k,ev,nv,mapper,type,information,edge,k,nv,return,type,data,set,edge,k,nv,mapped,edges,edges,map,new,map,function,edge,k,ev,edge,k,nv,public,edge,k,nv,map,edge,k,ev,value,throws,exception,return,new,edge,k,nv,value,f0,value,f1,mapper,map,value,returns,return,type,with,forwarded,fields,f0,f1,return,new,graph,k,vv,nv,this,vertices,mapped,edges,this,context
Graph -> public <NV> Graph<K, VV, NV> mapEdges(final MapFunction<Edge<K, EV>, NV> mapper, TypeInformation<Edge<K,NV>> returnType);1466789678;Apply a function to the attribute of each edge in the graph.__@param mapper the map function to apply._@param returnType the explicit return type._@return a new graph;public <NV> Graph<K, VV, NV> mapEdges(final MapFunction<Edge<K, EV>, NV> mapper, TypeInformation<Edge<K,NV>> returnType) {_		DataSet<Edge<K, NV>> mappedEdges = edges.map(_				new MapFunction<Edge<K, EV>, Edge<K, NV>>() {_					public Edge<K, NV> map(Edge<K, EV> value) throws Exception {_						return new Edge<K, NV>(value.f0, value.f1, mapper_								.map(value))__					}_				})_				.returns(returnType)_				.withForwardedFields("f0_ f1")___		return new Graph<K, VV, NV>(this.vertices, mappedEdges, this.context)__	};apply,a,function,to,the,attribute,of,each,edge,in,the,graph,param,mapper,the,map,function,to,apply,param,return,type,the,explicit,return,type,return,a,new,graph;public,nv,graph,k,vv,nv,map,edges,final,map,function,edge,k,ev,nv,mapper,type,information,edge,k,nv,return,type,data,set,edge,k,nv,mapped,edges,edges,map,new,map,function,edge,k,ev,edge,k,nv,public,edge,k,nv,map,edge,k,ev,value,throws,exception,return,new,edge,k,nv,value,f0,value,f1,mapper,map,value,returns,return,type,with,forwarded,fields,f0,f1,return,new,graph,k,vv,nv,this,vertices,mapped,edges,this,context
Graph -> public <NV> Graph<K, VV, NV> mapEdges(final MapFunction<Edge<K, EV>, NV> mapper, TypeInformation<Edge<K,NV>> returnType);1467140656;Apply a function to the attribute of each edge in the graph.__@param mapper the map function to apply._@param returnType the explicit return type._@return a new graph;public <NV> Graph<K, VV, NV> mapEdges(final MapFunction<Edge<K, EV>, NV> mapper, TypeInformation<Edge<K,NV>> returnType) {_		DataSet<Edge<K, NV>> mappedEdges = edges.map(_				new MapFunction<Edge<K, EV>, Edge<K, NV>>() {_					public Edge<K, NV> map(Edge<K, EV> value) throws Exception {_						return new Edge<K, NV>(value.f0, value.f1, mapper_								.map(value))__					}_				})_				.returns(returnType)_				.withForwardedFields("f0_ f1")___		return new Graph<K, VV, NV>(this.vertices, mappedEdges, this.context)__	};apply,a,function,to,the,attribute,of,each,edge,in,the,graph,param,mapper,the,map,function,to,apply,param,return,type,the,explicit,return,type,return,a,new,graph;public,nv,graph,k,vv,nv,map,edges,final,map,function,edge,k,ev,nv,mapper,type,information,edge,k,nv,return,type,data,set,edge,k,nv,mapped,edges,edges,map,new,map,function,edge,k,ev,edge,k,nv,public,edge,k,nv,map,edge,k,ev,value,throws,exception,return,new,edge,k,nv,value,f0,value,f1,mapper,map,value,returns,return,type,with,forwarded,fields,f0,f1,return,new,graph,k,vv,nv,this,vertices,mapped,edges,this,context
Graph -> public <NV> Graph<K, VV, NV> mapEdges(final MapFunction<Edge<K, EV>, NV> mapper, TypeInformation<Edge<K,NV>> returnType);1467306272;Apply a function to the attribute of each edge in the graph.__@param mapper the map function to apply._@param returnType the explicit return type._@return a new graph;public <NV> Graph<K, VV, NV> mapEdges(final MapFunction<Edge<K, EV>, NV> mapper, TypeInformation<Edge<K,NV>> returnType) {_		DataSet<Edge<K, NV>> mappedEdges = edges.map(_				new MapFunction<Edge<K, EV>, Edge<K, NV>>() {_					public Edge<K, NV> map(Edge<K, EV> value) throws Exception {_						return new Edge<K, NV>(value.f0, value.f1, mapper_								.map(value))__					}_				})_				.returns(returnType)_				.withForwardedFields("f0_ f1")___		return new Graph<K, VV, NV>(this.vertices, mappedEdges, this.context)__	};apply,a,function,to,the,attribute,of,each,edge,in,the,graph,param,mapper,the,map,function,to,apply,param,return,type,the,explicit,return,type,return,a,new,graph;public,nv,graph,k,vv,nv,map,edges,final,map,function,edge,k,ev,nv,mapper,type,information,edge,k,nv,return,type,data,set,edge,k,nv,mapped,edges,edges,map,new,map,function,edge,k,ev,edge,k,nv,public,edge,k,nv,map,edge,k,ev,value,throws,exception,return,new,edge,k,nv,value,f0,value,f1,mapper,map,value,returns,return,type,with,forwarded,fields,f0,f1,return,new,graph,k,vv,nv,this,vertices,mapped,edges,this,context
Graph -> public <NV> Graph<K, VV, NV> mapEdges(final MapFunction<Edge<K, EV>, NV> mapper, TypeInformation<Edge<K,NV>> returnType);1470042815;Apply a function to the attribute of each edge in the graph.__@param mapper the map function to apply._@param returnType the explicit return type._@return a new graph;public <NV> Graph<K, VV, NV> mapEdges(final MapFunction<Edge<K, EV>, NV> mapper, TypeInformation<Edge<K,NV>> returnType) {_		DataSet<Edge<K, NV>> mappedEdges = edges.map(_				new MapFunction<Edge<K, EV>, Edge<K, NV>>() {_					public Edge<K, NV> map(Edge<K, EV> value) throws Exception {_						return new Edge<K, NV>(value.f0, value.f1, mapper_								.map(value))__					}_				})_				.returns(returnType)_				.withForwardedFields("f0_ f1")___		return new Graph<K, VV, NV>(this.vertices, mappedEdges, this.context)__	};apply,a,function,to,the,attribute,of,each,edge,in,the,graph,param,mapper,the,map,function,to,apply,param,return,type,the,explicit,return,type,return,a,new,graph;public,nv,graph,k,vv,nv,map,edges,final,map,function,edge,k,ev,nv,mapper,type,information,edge,k,nv,return,type,data,set,edge,k,nv,mapped,edges,edges,map,new,map,function,edge,k,ev,edge,k,nv,public,edge,k,nv,map,edge,k,ev,value,throws,exception,return,new,edge,k,nv,value,f0,value,f1,mapper,map,value,returns,return,type,with,forwarded,fields,f0,f1,return,new,graph,k,vv,nv,this,vertices,mapped,edges,this,context
Graph -> public <NV> Graph<K, VV, NV> mapEdges(final MapFunction<Edge<K, EV>, NV> mapper, TypeInformation<Edge<K,NV>> returnType);1475684776;Apply a function to the attribute of each edge in the graph.__@param mapper the map function to apply._@param returnType the explicit return type._@return a new graph;public <NV> Graph<K, VV, NV> mapEdges(final MapFunction<Edge<K, EV>, NV> mapper, TypeInformation<Edge<K,NV>> returnType) {_		DataSet<Edge<K, NV>> mappedEdges = edges.map(_				new MapFunction<Edge<K, EV>, Edge<K, NV>>() {_					public Edge<K, NV> map(Edge<K, EV> value) throws Exception {_						return new Edge<>(value.f0, value.f1, mapper.map(value))__					}_				})_				.returns(returnType)_				.withForwardedFields("f0_ f1")___		return new Graph<>(this.vertices, mappedEdges, this.context)__	};apply,a,function,to,the,attribute,of,each,edge,in,the,graph,param,mapper,the,map,function,to,apply,param,return,type,the,explicit,return,type,return,a,new,graph;public,nv,graph,k,vv,nv,map,edges,final,map,function,edge,k,ev,nv,mapper,type,information,edge,k,nv,return,type,data,set,edge,k,nv,mapped,edges,edges,map,new,map,function,edge,k,ev,edge,k,nv,public,edge,k,nv,map,edge,k,ev,value,throws,exception,return,new,edge,value,f0,value,f1,mapper,map,value,returns,return,type,with,forwarded,fields,f0,f1,return,new,graph,this,vertices,mapped,edges,this,context
Graph -> public <NV> Graph<K, VV, NV> mapEdges(final MapFunction<Edge<K, EV>, NV> mapper, TypeInformation<Edge<K,NV>> returnType);1475685606;Apply a function to the attribute of each edge in the graph.__@param mapper the map function to apply._@param returnType the explicit return type._@return a new graph;public <NV> Graph<K, VV, NV> mapEdges(final MapFunction<Edge<K, EV>, NV> mapper, TypeInformation<Edge<K,NV>> returnType) {_		DataSet<Edge<K, NV>> mappedEdges = edges.map(_				new MapFunction<Edge<K, EV>, Edge<K, NV>>() {_					public Edge<K, NV> map(Edge<K, EV> value) throws Exception {_						return new Edge<>(value.f0, value.f1, mapper.map(value))__					}_				})_				.returns(returnType)_				.withForwardedFields("f0_ f1")___		return new Graph<>(this.vertices, mappedEdges, this.context)__	};apply,a,function,to,the,attribute,of,each,edge,in,the,graph,param,mapper,the,map,function,to,apply,param,return,type,the,explicit,return,type,return,a,new,graph;public,nv,graph,k,vv,nv,map,edges,final,map,function,edge,k,ev,nv,mapper,type,information,edge,k,nv,return,type,data,set,edge,k,nv,mapped,edges,edges,map,new,map,function,edge,k,ev,edge,k,nv,public,edge,k,nv,map,edge,k,ev,value,throws,exception,return,new,edge,value,f0,value,f1,mapper,map,value,returns,return,type,with,forwarded,fields,f0,f1,return,new,graph,this,vertices,mapped,edges,this,context
Graph -> public <NV> Graph<K, VV, NV> mapEdges(final MapFunction<Edge<K, EV>, NV> mapper, TypeInformation<Edge<K,NV>> returnType);1481745825;Apply a function to the attribute of each edge in the graph.__@param mapper the map function to apply._@param returnType the explicit return type._@return a new graph;public <NV> Graph<K, VV, NV> mapEdges(final MapFunction<Edge<K, EV>, NV> mapper, TypeInformation<Edge<K,NV>> returnType) {_		DataSet<Edge<K, NV>> mappedEdges = edges.map(_			new MapFunction<Edge<K, EV>, Edge<K, NV>>() {_				private Edge<K, NV> output = new Edge<>()___				public Edge<K, NV> map(Edge<K, EV> value) throws Exception {_					output.f0 = value.f0__					output.f1 = value.f1__					output.f2 = mapper.map(value)__					return output__				}_			})_			.returns(returnType)_			.withForwardedFields("f0_ f1")_				.name("Map edges")___		return new Graph<>(this.vertices, mappedEdges, this.context)__	};apply,a,function,to,the,attribute,of,each,edge,in,the,graph,param,mapper,the,map,function,to,apply,param,return,type,the,explicit,return,type,return,a,new,graph;public,nv,graph,k,vv,nv,map,edges,final,map,function,edge,k,ev,nv,mapper,type,information,edge,k,nv,return,type,data,set,edge,k,nv,mapped,edges,edges,map,new,map,function,edge,k,ev,edge,k,nv,private,edge,k,nv,output,new,edge,public,edge,k,nv,map,edge,k,ev,value,throws,exception,output,f0,value,f0,output,f1,value,f1,output,f2,mapper,map,value,return,output,returns,return,type,with,forwarded,fields,f0,f1,name,map,edges,return,new,graph,this,vertices,mapped,edges,this,context
Graph -> public <NV> Graph<K, VV, NV> mapEdges(final MapFunction<Edge<K, EV>, NV> mapper, TypeInformation<Edge<K,NV>> returnType);1481881009;Apply a function to the attribute of each edge in the graph.__@param mapper the map function to apply._@param returnType the explicit return type._@return a new graph;public <NV> Graph<K, VV, NV> mapEdges(final MapFunction<Edge<K, EV>, NV> mapper, TypeInformation<Edge<K,NV>> returnType) {_		DataSet<Edge<K, NV>> mappedEdges = edges.map(_			new MapFunction<Edge<K, EV>, Edge<K, NV>>() {_				private Edge<K, NV> output = new Edge<>()___				public Edge<K, NV> map(Edge<K, EV> value) throws Exception {_					output.f0 = value.f0__					output.f1 = value.f1__					output.f2 = mapper.map(value)__					return output__				}_			})_			.returns(returnType)_			.withForwardedFields("f0_ f1")_				.name("Map edges")___		return new Graph<>(this.vertices, mappedEdges, this.context)__	};apply,a,function,to,the,attribute,of,each,edge,in,the,graph,param,mapper,the,map,function,to,apply,param,return,type,the,explicit,return,type,return,a,new,graph;public,nv,graph,k,vv,nv,map,edges,final,map,function,edge,k,ev,nv,mapper,type,information,edge,k,nv,return,type,data,set,edge,k,nv,mapped,edges,edges,map,new,map,function,edge,k,ev,edge,k,nv,private,edge,k,nv,output,new,edge,public,edge,k,nv,map,edge,k,ev,value,throws,exception,output,f0,value,f0,output,f1,value,f1,output,f2,mapper,map,value,return,output,returns,return,type,with,forwarded,fields,f0,f1,name,map,edges,return,new,graph,this,vertices,mapped,edges,this,context
Graph -> public <NV> Graph<K, VV, NV> mapEdges(final MapFunction<Edge<K, EV>, NV> mapper, TypeInformation<Edge<K,NV>> returnType);1484160227;Apply a function to the attribute of each edge in the graph.__@param mapper the map function to apply._@param returnType the explicit return type._@return a new graph;public <NV> Graph<K, VV, NV> mapEdges(final MapFunction<Edge<K, EV>, NV> mapper, TypeInformation<Edge<K,NV>> returnType) {_		DataSet<Edge<K, NV>> mappedEdges = edges.map(_			new MapFunction<Edge<K, EV>, Edge<K, NV>>() {_				private Edge<K, NV> output = new Edge<>()___				public Edge<K, NV> map(Edge<K, EV> value) throws Exception {_					output.f0 = value.f0__					output.f1 = value.f1__					output.f2 = mapper.map(value)__					return output__				}_			})_			.returns(returnType)_			.withForwardedFields("f0_ f1")_				.name("Map edges")___		return new Graph<>(this.vertices, mappedEdges, this.context)__	};apply,a,function,to,the,attribute,of,each,edge,in,the,graph,param,mapper,the,map,function,to,apply,param,return,type,the,explicit,return,type,return,a,new,graph;public,nv,graph,k,vv,nv,map,edges,final,map,function,edge,k,ev,nv,mapper,type,information,edge,k,nv,return,type,data,set,edge,k,nv,mapped,edges,edges,map,new,map,function,edge,k,ev,edge,k,nv,private,edge,k,nv,output,new,edge,public,edge,k,nv,map,edge,k,ev,value,throws,exception,output,f0,value,f0,output,f1,value,f1,output,f2,mapper,map,value,return,output,returns,return,type,with,forwarded,fields,f0,f1,name,map,edges,return,new,graph,this,vertices,mapped,edges,this,context
Graph -> public static <K, VV, EV> Graph<K, VV, EV> fromTupleDataSet(DataSet<Tuple3<K, K, EV>> edges, 			final MapFunction<K, VV> vertexValueInitializer, ExecutionEnvironment context);1445261977;Creates a graph from a DataSet of Tuple3 objects for edges._<p>_Each Tuple3 will become one Edge, where the source ID will be the first field of the Tuple2,_the target ID will be the second field of the Tuple2_and the Edge value will be the third field of the Tuple3._<p>_Vertices are created automatically and their values are initialized_by applying the provided vertexValueInitializer map function to the vertex IDs.__@param edges a DataSet of Tuple3._@param vertexValueInitializer the mapper function that initializes the vertex values._It allows to apply a map transformation on the vertex ID to produce an initial vertex value._@param context the flink execution environment._@return the newly created graph.;public static <K, VV, EV> Graph<K, VV, EV> fromTupleDataSet(DataSet<Tuple3<K, K, EV>> edges,_			final MapFunction<K, VV> vertexValueInitializer, ExecutionEnvironment context) {__		DataSet<Edge<K, EV>> edgeDataSet = edges.map(new Tuple3ToEdgeMap<K, EV>())__		return fromDataSet(edgeDataSet, vertexValueInitializer, context)__	};creates,a,graph,from,a,data,set,of,tuple3,objects,for,edges,p,each,tuple3,will,become,one,edge,where,the,source,id,will,be,the,first,field,of,the,tuple2,the,target,id,will,be,the,second,field,of,the,tuple2,and,the,edge,value,will,be,the,third,field,of,the,tuple3,p,vertices,are,created,automatically,and,their,values,are,initialized,by,applying,the,provided,vertex,value,initializer,map,function,to,the,vertex,ids,param,edges,a,data,set,of,tuple3,param,vertex,value,initializer,the,mapper,function,that,initializes,the,vertex,values,it,allows,to,apply,a,map,transformation,on,the,vertex,id,to,produce,an,initial,vertex,value,param,context,the,flink,execution,environment,return,the,newly,created,graph;public,static,k,vv,ev,graph,k,vv,ev,from,tuple,data,set,data,set,tuple3,k,k,ev,edges,final,map,function,k,vv,vertex,value,initializer,execution,environment,context,data,set,edge,k,ev,edge,data,set,edges,map,new,tuple3to,edge,map,k,ev,return,from,data,set,edge,data,set,vertex,value,initializer,context
Graph -> public static <K, VV, EV> Graph<K, VV, EV> fromTupleDataSet(DataSet<Tuple3<K, K, EV>> edges, 			final MapFunction<K, VV> vertexValueInitializer, ExecutionEnvironment context);1445854323;Creates a graph from a DataSet of Tuple3 objects for edges._<p>_Each Tuple3 will become one Edge, where the source ID will be the first field of the Tuple2,_the target ID will be the second field of the Tuple2_and the Edge value will be the third field of the Tuple3._<p>_Vertices are created automatically and their values are initialized_by applying the provided vertexValueInitializer map function to the vertex IDs.__@param edges a DataSet of Tuple3._@param vertexValueInitializer the mapper function that initializes the vertex values._It allows to apply a map transformation on the vertex ID to produce an initial vertex value._@param context the flink execution environment._@return the newly created graph.;public static <K, VV, EV> Graph<K, VV, EV> fromTupleDataSet(DataSet<Tuple3<K, K, EV>> edges,_			final MapFunction<K, VV> vertexValueInitializer, ExecutionEnvironment context) {__		DataSet<Edge<K, EV>> edgeDataSet = edges.map(new Tuple3ToEdgeMap<K, EV>())__		return fromDataSet(edgeDataSet, vertexValueInitializer, context)__	};creates,a,graph,from,a,data,set,of,tuple3,objects,for,edges,p,each,tuple3,will,become,one,edge,where,the,source,id,will,be,the,first,field,of,the,tuple2,the,target,id,will,be,the,second,field,of,the,tuple2,and,the,edge,value,will,be,the,third,field,of,the,tuple3,p,vertices,are,created,automatically,and,their,values,are,initialized,by,applying,the,provided,vertex,value,initializer,map,function,to,the,vertex,ids,param,edges,a,data,set,of,tuple3,param,vertex,value,initializer,the,mapper,function,that,initializes,the,vertex,values,it,allows,to,apply,a,map,transformation,on,the,vertex,id,to,produce,an,initial,vertex,value,param,context,the,flink,execution,environment,return,the,newly,created,graph;public,static,k,vv,ev,graph,k,vv,ev,from,tuple,data,set,data,set,tuple3,k,k,ev,edges,final,map,function,k,vv,vertex,value,initializer,execution,environment,context,data,set,edge,k,ev,edge,data,set,edges,map,new,tuple3to,edge,map,k,ev,return,from,data,set,edge,data,set,vertex,value,initializer,context
Graph -> public static <K, VV, EV> Graph<K, VV, EV> fromTupleDataSet(DataSet<Tuple3<K, K, EV>> edges, 			final MapFunction<K, VV> vertexValueInitializer, ExecutionEnvironment context);1446112342;Creates a graph from a DataSet of Tuple3 objects for edges._<p>_Each Tuple3 will become one Edge, where the source ID will be the first field of the Tuple2,_the target ID will be the second field of the Tuple2_and the Edge value will be the third field of the Tuple3._<p>_Vertices are created automatically and their values are initialized_by applying the provided vertexValueInitializer map function to the vertex IDs.__@param edges a DataSet of Tuple3._@param vertexValueInitializer the mapper function that initializes the vertex values._It allows to apply a map transformation on the vertex ID to produce an initial vertex value._@param context the flink execution environment._@return the newly created graph.;public static <K, VV, EV> Graph<K, VV, EV> fromTupleDataSet(DataSet<Tuple3<K, K, EV>> edges,_			final MapFunction<K, VV> vertexValueInitializer, ExecutionEnvironment context) {__		DataSet<Edge<K, EV>> edgeDataSet = edges.map(new Tuple3ToEdgeMap<K, EV>())__		return fromDataSet(edgeDataSet, vertexValueInitializer, context)__	};creates,a,graph,from,a,data,set,of,tuple3,objects,for,edges,p,each,tuple3,will,become,one,edge,where,the,source,id,will,be,the,first,field,of,the,tuple2,the,target,id,will,be,the,second,field,of,the,tuple2,and,the,edge,value,will,be,the,third,field,of,the,tuple3,p,vertices,are,created,automatically,and,their,values,are,initialized,by,applying,the,provided,vertex,value,initializer,map,function,to,the,vertex,ids,param,edges,a,data,set,of,tuple3,param,vertex,value,initializer,the,mapper,function,that,initializes,the,vertex,values,it,allows,to,apply,a,map,transformation,on,the,vertex,id,to,produce,an,initial,vertex,value,param,context,the,flink,execution,environment,return,the,newly,created,graph;public,static,k,vv,ev,graph,k,vv,ev,from,tuple,data,set,data,set,tuple3,k,k,ev,edges,final,map,function,k,vv,vertex,value,initializer,execution,environment,context,data,set,edge,k,ev,edge,data,set,edges,map,new,tuple3to,edge,map,k,ev,return,from,data,set,edge,data,set,vertex,value,initializer,context
Graph -> public static <K, VV, EV> Graph<K, VV, EV> fromTupleDataSet(DataSet<Tuple3<K, K, EV>> edges, 			final MapFunction<K, VV> vertexValueInitializer, ExecutionEnvironment context);1447073368;Creates a graph from a DataSet of Tuple3 objects for edges._<p>_Each Tuple3 will become one Edge, where the source ID will be the first field of the Tuple2,_the target ID will be the second field of the Tuple2_and the Edge value will be the third field of the Tuple3._<p>_Vertices are created automatically and their values are initialized_by applying the provided vertexValueInitializer map function to the vertex IDs.__@param edges a DataSet of Tuple3._@param vertexValueInitializer the mapper function that initializes the vertex values._It allows to apply a map transformation on the vertex ID to produce an initial vertex value._@param context the flink execution environment._@return the newly created graph.;public static <K, VV, EV> Graph<K, VV, EV> fromTupleDataSet(DataSet<Tuple3<K, K, EV>> edges,_			final MapFunction<K, VV> vertexValueInitializer, ExecutionEnvironment context) {__		DataSet<Edge<K, EV>> edgeDataSet = edges.map(new Tuple3ToEdgeMap<K, EV>())__		return fromDataSet(edgeDataSet, vertexValueInitializer, context)__	};creates,a,graph,from,a,data,set,of,tuple3,objects,for,edges,p,each,tuple3,will,become,one,edge,where,the,source,id,will,be,the,first,field,of,the,tuple2,the,target,id,will,be,the,second,field,of,the,tuple2,and,the,edge,value,will,be,the,third,field,of,the,tuple3,p,vertices,are,created,automatically,and,their,values,are,initialized,by,applying,the,provided,vertex,value,initializer,map,function,to,the,vertex,ids,param,edges,a,data,set,of,tuple3,param,vertex,value,initializer,the,mapper,function,that,initializes,the,vertex,values,it,allows,to,apply,a,map,transformation,on,the,vertex,id,to,produce,an,initial,vertex,value,param,context,the,flink,execution,environment,return,the,newly,created,graph;public,static,k,vv,ev,graph,k,vv,ev,from,tuple,data,set,data,set,tuple3,k,k,ev,edges,final,map,function,k,vv,vertex,value,initializer,execution,environment,context,data,set,edge,k,ev,edge,data,set,edges,map,new,tuple3to,edge,map,k,ev,return,from,data,set,edge,data,set,vertex,value,initializer,context
Graph -> public static <K, VV, EV> Graph<K, VV, EV> fromTupleDataSet(DataSet<Tuple3<K, K, EV>> edges, 			final MapFunction<K, VV> vertexValueInitializer, ExecutionEnvironment context);1454404649;Creates a graph from a DataSet of Tuple3 objects for edges._<p>_Each Tuple3 will become one Edge, where the source ID will be the first field of the Tuple2,_the target ID will be the second field of the Tuple2_and the Edge value will be the third field of the Tuple3._<p>_Vertices are created automatically and their values are initialized_by applying the provided vertexValueInitializer map function to the vertex IDs.__@param edges a DataSet of Tuple3._@param vertexValueInitializer the mapper function that initializes the vertex values._It allows to apply a map transformation on the vertex ID to produce an initial vertex value._@param context the flink execution environment._@return the newly created graph.;public static <K, VV, EV> Graph<K, VV, EV> fromTupleDataSet(DataSet<Tuple3<K, K, EV>> edges,_			final MapFunction<K, VV> vertexValueInitializer, ExecutionEnvironment context) {__		DataSet<Edge<K, EV>> edgeDataSet = edges.map(new Tuple3ToEdgeMap<K, EV>())__		return fromDataSet(edgeDataSet, vertexValueInitializer, context)__	};creates,a,graph,from,a,data,set,of,tuple3,objects,for,edges,p,each,tuple3,will,become,one,edge,where,the,source,id,will,be,the,first,field,of,the,tuple2,the,target,id,will,be,the,second,field,of,the,tuple2,and,the,edge,value,will,be,the,third,field,of,the,tuple3,p,vertices,are,created,automatically,and,their,values,are,initialized,by,applying,the,provided,vertex,value,initializer,map,function,to,the,vertex,ids,param,edges,a,data,set,of,tuple3,param,vertex,value,initializer,the,mapper,function,that,initializes,the,vertex,values,it,allows,to,apply,a,map,transformation,on,the,vertex,id,to,produce,an,initial,vertex,value,param,context,the,flink,execution,environment,return,the,newly,created,graph;public,static,k,vv,ev,graph,k,vv,ev,from,tuple,data,set,data,set,tuple3,k,k,ev,edges,final,map,function,k,vv,vertex,value,initializer,execution,environment,context,data,set,edge,k,ev,edge,data,set,edges,map,new,tuple3to,edge,map,k,ev,return,from,data,set,edge,data,set,vertex,value,initializer,context
Graph -> public static <K, VV, EV> Graph<K, VV, EV> fromTupleDataSet(DataSet<Tuple3<K, K, EV>> edges, 			final MapFunction<K, VV> vertexValueInitializer, ExecutionEnvironment context);1458583829;Creates a graph from a DataSet of Tuple3 objects for edges._<p>_Each Tuple3 will become one Edge, where the source ID will be the first field of the Tuple2,_the target ID will be the second field of the Tuple2_and the Edge value will be the third field of the Tuple3._<p>_Vertices are created automatically and their values are initialized_by applying the provided vertexValueInitializer map function to the vertex IDs.__@param edges a DataSet of Tuple3._@param vertexValueInitializer the mapper function that initializes the vertex values._It allows to apply a map transformation on the vertex ID to produce an initial vertex value._@param context the flink execution environment._@return the newly created graph.;public static <K, VV, EV> Graph<K, VV, EV> fromTupleDataSet(DataSet<Tuple3<K, K, EV>> edges,_			final MapFunction<K, VV> vertexValueInitializer, ExecutionEnvironment context) {__		DataSet<Edge<K, EV>> edgeDataSet = edges.map(new Tuple3ToEdgeMap<K, EV>())__		return fromDataSet(edgeDataSet, vertexValueInitializer, context)__	};creates,a,graph,from,a,data,set,of,tuple3,objects,for,edges,p,each,tuple3,will,become,one,edge,where,the,source,id,will,be,the,first,field,of,the,tuple2,the,target,id,will,be,the,second,field,of,the,tuple2,and,the,edge,value,will,be,the,third,field,of,the,tuple3,p,vertices,are,created,automatically,and,their,values,are,initialized,by,applying,the,provided,vertex,value,initializer,map,function,to,the,vertex,ids,param,edges,a,data,set,of,tuple3,param,vertex,value,initializer,the,mapper,function,that,initializes,the,vertex,values,it,allows,to,apply,a,map,transformation,on,the,vertex,id,to,produce,an,initial,vertex,value,param,context,the,flink,execution,environment,return,the,newly,created,graph;public,static,k,vv,ev,graph,k,vv,ev,from,tuple,data,set,data,set,tuple3,k,k,ev,edges,final,map,function,k,vv,vertex,value,initializer,execution,environment,context,data,set,edge,k,ev,edge,data,set,edges,map,new,tuple3to,edge,map,k,ev,return,from,data,set,edge,data,set,vertex,value,initializer,context
Graph -> public static <K, VV, EV> Graph<K, VV, EV> fromTupleDataSet(DataSet<Tuple3<K, K, EV>> edges, 			final MapFunction<K, VV> vertexValueInitializer, ExecutionEnvironment context);1458583829;Creates a graph from a DataSet of Tuple3 objects for edges._<p>_Each Tuple3 will become one Edge, where the source ID will be the first field of the Tuple2,_the target ID will be the second field of the Tuple2_and the Edge value will be the third field of the Tuple3._<p>_Vertices are created automatically and their values are initialized_by applying the provided vertexValueInitializer map function to the vertex IDs.__@param edges a DataSet of Tuple3._@param vertexValueInitializer the mapper function that initializes the vertex values._It allows to apply a map transformation on the vertex ID to produce an initial vertex value._@param context the flink execution environment._@return the newly created graph.;public static <K, VV, EV> Graph<K, VV, EV> fromTupleDataSet(DataSet<Tuple3<K, K, EV>> edges,_			final MapFunction<K, VV> vertexValueInitializer, ExecutionEnvironment context) {__		DataSet<Edge<K, EV>> edgeDataSet = edges.map(new Tuple3ToEdgeMap<K, EV>())__		return fromDataSet(edgeDataSet, vertexValueInitializer, context)__	};creates,a,graph,from,a,data,set,of,tuple3,objects,for,edges,p,each,tuple3,will,become,one,edge,where,the,source,id,will,be,the,first,field,of,the,tuple2,the,target,id,will,be,the,second,field,of,the,tuple2,and,the,edge,value,will,be,the,third,field,of,the,tuple3,p,vertices,are,created,automatically,and,their,values,are,initialized,by,applying,the,provided,vertex,value,initializer,map,function,to,the,vertex,ids,param,edges,a,data,set,of,tuple3,param,vertex,value,initializer,the,mapper,function,that,initializes,the,vertex,values,it,allows,to,apply,a,map,transformation,on,the,vertex,id,to,produce,an,initial,vertex,value,param,context,the,flink,execution,environment,return,the,newly,created,graph;public,static,k,vv,ev,graph,k,vv,ev,from,tuple,data,set,data,set,tuple3,k,k,ev,edges,final,map,function,k,vv,vertex,value,initializer,execution,environment,context,data,set,edge,k,ev,edge,data,set,edges,map,new,tuple3to,edge,map,k,ev,return,from,data,set,edge,data,set,vertex,value,initializer,context
Graph -> public static <K, VV, EV> Graph<K, VV, EV> fromTupleDataSet(DataSet<Tuple3<K, K, EV>> edges, 			final MapFunction<K, VV> vertexValueInitializer, ExecutionEnvironment context);1462100316;Creates a graph from a DataSet of Tuple3 objects for edges._<p>_Each Tuple3 will become one Edge, where the source ID will be the first field of the Tuple2,_the target ID will be the second field of the Tuple2_and the Edge value will be the third field of the Tuple3._<p>_Vertices are created automatically and their values are initialized_by applying the provided vertexValueInitializer map function to the vertex IDs.__@param edges a DataSet of Tuple3._@param vertexValueInitializer the mapper function that initializes the vertex values._It allows to apply a map transformation on the vertex ID to produce an initial vertex value._@param context the flink execution environment._@return the newly created graph.;public static <K, VV, EV> Graph<K, VV, EV> fromTupleDataSet(DataSet<Tuple3<K, K, EV>> edges,_			final MapFunction<K, VV> vertexValueInitializer, ExecutionEnvironment context) {__		DataSet<Edge<K, EV>> edgeDataSet = edges.map(new Tuple3ToEdgeMap<K, EV>())__		return fromDataSet(edgeDataSet, vertexValueInitializer, context)__	};creates,a,graph,from,a,data,set,of,tuple3,objects,for,edges,p,each,tuple3,will,become,one,edge,where,the,source,id,will,be,the,first,field,of,the,tuple2,the,target,id,will,be,the,second,field,of,the,tuple2,and,the,edge,value,will,be,the,third,field,of,the,tuple3,p,vertices,are,created,automatically,and,their,values,are,initialized,by,applying,the,provided,vertex,value,initializer,map,function,to,the,vertex,ids,param,edges,a,data,set,of,tuple3,param,vertex,value,initializer,the,mapper,function,that,initializes,the,vertex,values,it,allows,to,apply,a,map,transformation,on,the,vertex,id,to,produce,an,initial,vertex,value,param,context,the,flink,execution,environment,return,the,newly,created,graph;public,static,k,vv,ev,graph,k,vv,ev,from,tuple,data,set,data,set,tuple3,k,k,ev,edges,final,map,function,k,vv,vertex,value,initializer,execution,environment,context,data,set,edge,k,ev,edge,data,set,edges,map,new,tuple3to,edge,map,k,ev,return,from,data,set,edge,data,set,vertex,value,initializer,context
Graph -> public static <K, VV, EV> Graph<K, VV, EV> fromTupleDataSet(DataSet<Tuple3<K, K, EV>> edges, 			final MapFunction<K, VV> vertexValueInitializer, ExecutionEnvironment context);1462100316;Creates a graph from a DataSet of Tuple3 objects for edges._<p>_Each Tuple3 will become one Edge, where the source ID will be the first field of the Tuple2,_the target ID will be the second field of the Tuple2_and the Edge value will be the third field of the Tuple3._<p>_Vertices are created automatically and their values are initialized_by applying the provided vertexValueInitializer map function to the vertex IDs.__@param edges a DataSet of Tuple3._@param vertexValueInitializer the mapper function that initializes the vertex values._It allows to apply a map transformation on the vertex ID to produce an initial vertex value._@param context the flink execution environment._@return the newly created graph.;public static <K, VV, EV> Graph<K, VV, EV> fromTupleDataSet(DataSet<Tuple3<K, K, EV>> edges,_			final MapFunction<K, VV> vertexValueInitializer, ExecutionEnvironment context) {__		DataSet<Edge<K, EV>> edgeDataSet = edges.map(new Tuple3ToEdgeMap<K, EV>())__		return fromDataSet(edgeDataSet, vertexValueInitializer, context)__	};creates,a,graph,from,a,data,set,of,tuple3,objects,for,edges,p,each,tuple3,will,become,one,edge,where,the,source,id,will,be,the,first,field,of,the,tuple2,the,target,id,will,be,the,second,field,of,the,tuple2,and,the,edge,value,will,be,the,third,field,of,the,tuple3,p,vertices,are,created,automatically,and,their,values,are,initialized,by,applying,the,provided,vertex,value,initializer,map,function,to,the,vertex,ids,param,edges,a,data,set,of,tuple3,param,vertex,value,initializer,the,mapper,function,that,initializes,the,vertex,values,it,allows,to,apply,a,map,transformation,on,the,vertex,id,to,produce,an,initial,vertex,value,param,context,the,flink,execution,environment,return,the,newly,created,graph;public,static,k,vv,ev,graph,k,vv,ev,from,tuple,data,set,data,set,tuple3,k,k,ev,edges,final,map,function,k,vv,vertex,value,initializer,execution,environment,context,data,set,edge,k,ev,edge,data,set,edges,map,new,tuple3to,edge,map,k,ev,return,from,data,set,edge,data,set,vertex,value,initializer,context
Graph -> public static <K, VV, EV> Graph<K, VV, EV> fromTupleDataSet(DataSet<Tuple3<K, K, EV>> edges, 			final MapFunction<K, VV> vertexValueInitializer, ExecutionEnvironment context);1462205213;Creates a graph from a DataSet of Tuple3 objects for edges._<p>_Each Tuple3 will become one Edge, where the source ID will be the first field of the Tuple2,_the target ID will be the second field of the Tuple2_and the Edge value will be the third field of the Tuple3._<p>_Vertices are created automatically and their values are initialized_by applying the provided vertexValueInitializer map function to the vertex IDs.__@param edges a DataSet of Tuple3._@param vertexValueInitializer the mapper function that initializes the vertex values._It allows to apply a map transformation on the vertex ID to produce an initial vertex value._@param context the flink execution environment._@return the newly created graph.;public static <K, VV, EV> Graph<K, VV, EV> fromTupleDataSet(DataSet<Tuple3<K, K, EV>> edges,_			final MapFunction<K, VV> vertexValueInitializer, ExecutionEnvironment context) {__		DataSet<Edge<K, EV>> edgeDataSet = edges.map(new Tuple3ToEdgeMap<K, EV>())__		return fromDataSet(edgeDataSet, vertexValueInitializer, context)__	};creates,a,graph,from,a,data,set,of,tuple3,objects,for,edges,p,each,tuple3,will,become,one,edge,where,the,source,id,will,be,the,first,field,of,the,tuple2,the,target,id,will,be,the,second,field,of,the,tuple2,and,the,edge,value,will,be,the,third,field,of,the,tuple3,p,vertices,are,created,automatically,and,their,values,are,initialized,by,applying,the,provided,vertex,value,initializer,map,function,to,the,vertex,ids,param,edges,a,data,set,of,tuple3,param,vertex,value,initializer,the,mapper,function,that,initializes,the,vertex,values,it,allows,to,apply,a,map,transformation,on,the,vertex,id,to,produce,an,initial,vertex,value,param,context,the,flink,execution,environment,return,the,newly,created,graph;public,static,k,vv,ev,graph,k,vv,ev,from,tuple,data,set,data,set,tuple3,k,k,ev,edges,final,map,function,k,vv,vertex,value,initializer,execution,environment,context,data,set,edge,k,ev,edge,data,set,edges,map,new,tuple3to,edge,map,k,ev,return,from,data,set,edge,data,set,vertex,value,initializer,context
Graph -> public static <K, VV, EV> Graph<K, VV, EV> fromTupleDataSet(DataSet<Tuple3<K, K, EV>> edges, 			final MapFunction<K, VV> vertexValueInitializer, ExecutionEnvironment context);1462208859;Creates a graph from a DataSet of Tuple3 objects for edges._<p>_Each Tuple3 will become one Edge, where the source ID will be the first field of the Tuple2,_the target ID will be the second field of the Tuple2_and the Edge value will be the third field of the Tuple3._<p>_Vertices are created automatically and their values are initialized_by applying the provided vertexValueInitializer map function to the vertex IDs.__@param edges a DataSet of Tuple3._@param vertexValueInitializer the mapper function that initializes the vertex values._It allows to apply a map transformation on the vertex ID to produce an initial vertex value._@param context the flink execution environment._@return the newly created graph.;public static <K, VV, EV> Graph<K, VV, EV> fromTupleDataSet(DataSet<Tuple3<K, K, EV>> edges,_			final MapFunction<K, VV> vertexValueInitializer, ExecutionEnvironment context) {__		DataSet<Edge<K, EV>> edgeDataSet = edges.map(new Tuple3ToEdgeMap<K, EV>())__		return fromDataSet(edgeDataSet, vertexValueInitializer, context)__	};creates,a,graph,from,a,data,set,of,tuple3,objects,for,edges,p,each,tuple3,will,become,one,edge,where,the,source,id,will,be,the,first,field,of,the,tuple2,the,target,id,will,be,the,second,field,of,the,tuple2,and,the,edge,value,will,be,the,third,field,of,the,tuple3,p,vertices,are,created,automatically,and,their,values,are,initialized,by,applying,the,provided,vertex,value,initializer,map,function,to,the,vertex,ids,param,edges,a,data,set,of,tuple3,param,vertex,value,initializer,the,mapper,function,that,initializes,the,vertex,values,it,allows,to,apply,a,map,transformation,on,the,vertex,id,to,produce,an,initial,vertex,value,param,context,the,flink,execution,environment,return,the,newly,created,graph;public,static,k,vv,ev,graph,k,vv,ev,from,tuple,data,set,data,set,tuple3,k,k,ev,edges,final,map,function,k,vv,vertex,value,initializer,execution,environment,context,data,set,edge,k,ev,edge,data,set,edges,map,new,tuple3to,edge,map,k,ev,return,from,data,set,edge,data,set,vertex,value,initializer,context
Graph -> public static <K, VV, EV> Graph<K, VV, EV> fromTupleDataSet(DataSet<Tuple3<K, K, EV>> edges, 			final MapFunction<K, VV> vertexValueInitializer, ExecutionEnvironment context);1462809297;Creates a graph from a DataSet of Tuple3 objects for edges._<p>_Each Tuple3 will become one Edge, where the source ID will be the first field of the Tuple2,_the target ID will be the second field of the Tuple2_and the Edge value will be the third field of the Tuple3._<p>_Vertices are created automatically and their values are initialized_by applying the provided vertexValueInitializer map function to the vertex IDs.__@param edges a DataSet of Tuple3._@param vertexValueInitializer the mapper function that initializes the vertex values._It allows to apply a map transformation on the vertex ID to produce an initial vertex value._@param context the flink execution environment._@return the newly created graph.;public static <K, VV, EV> Graph<K, VV, EV> fromTupleDataSet(DataSet<Tuple3<K, K, EV>> edges,_			final MapFunction<K, VV> vertexValueInitializer, ExecutionEnvironment context) {__		DataSet<Edge<K, EV>> edgeDataSet = edges.map(new Tuple3ToEdgeMap<K, EV>())__		return fromDataSet(edgeDataSet, vertexValueInitializer, context)__	};creates,a,graph,from,a,data,set,of,tuple3,objects,for,edges,p,each,tuple3,will,become,one,edge,where,the,source,id,will,be,the,first,field,of,the,tuple2,the,target,id,will,be,the,second,field,of,the,tuple2,and,the,edge,value,will,be,the,third,field,of,the,tuple3,p,vertices,are,created,automatically,and,their,values,are,initialized,by,applying,the,provided,vertex,value,initializer,map,function,to,the,vertex,ids,param,edges,a,data,set,of,tuple3,param,vertex,value,initializer,the,mapper,function,that,initializes,the,vertex,values,it,allows,to,apply,a,map,transformation,on,the,vertex,id,to,produce,an,initial,vertex,value,param,context,the,flink,execution,environment,return,the,newly,created,graph;public,static,k,vv,ev,graph,k,vv,ev,from,tuple,data,set,data,set,tuple3,k,k,ev,edges,final,map,function,k,vv,vertex,value,initializer,execution,environment,context,data,set,edge,k,ev,edge,data,set,edges,map,new,tuple3to,edge,map,k,ev,return,from,data,set,edge,data,set,vertex,value,initializer,context
Graph -> public static <K, VV, EV> Graph<K, VV, EV> fromTupleDataSet(DataSet<Tuple3<K, K, EV>> edges, 			final MapFunction<K, VV> vertexValueInitializer, ExecutionEnvironment context);1465316775;Creates a graph from a DataSet of Tuple3 objects for edges._<p>_Each Tuple3 will become one Edge, where the source ID will be the first field of the Tuple2,_the target ID will be the second field of the Tuple2_and the Edge value will be the third field of the Tuple3._<p>_Vertices are created automatically and their values are initialized_by applying the provided vertexValueInitializer map function to the vertex IDs.__@param edges a DataSet of Tuple3._@param vertexValueInitializer the mapper function that initializes the vertex values._It allows to apply a map transformation on the vertex ID to produce an initial vertex value._@param context the flink execution environment._@return the newly created graph.;public static <K, VV, EV> Graph<K, VV, EV> fromTupleDataSet(DataSet<Tuple3<K, K, EV>> edges,_			final MapFunction<K, VV> vertexValueInitializer, ExecutionEnvironment context) {__		DataSet<Edge<K, EV>> edgeDataSet = edges.map(new Tuple3ToEdgeMap<K, EV>())__		return fromDataSet(edgeDataSet, vertexValueInitializer, context)__	};creates,a,graph,from,a,data,set,of,tuple3,objects,for,edges,p,each,tuple3,will,become,one,edge,where,the,source,id,will,be,the,first,field,of,the,tuple2,the,target,id,will,be,the,second,field,of,the,tuple2,and,the,edge,value,will,be,the,third,field,of,the,tuple3,p,vertices,are,created,automatically,and,their,values,are,initialized,by,applying,the,provided,vertex,value,initializer,map,function,to,the,vertex,ids,param,edges,a,data,set,of,tuple3,param,vertex,value,initializer,the,mapper,function,that,initializes,the,vertex,values,it,allows,to,apply,a,map,transformation,on,the,vertex,id,to,produce,an,initial,vertex,value,param,context,the,flink,execution,environment,return,the,newly,created,graph;public,static,k,vv,ev,graph,k,vv,ev,from,tuple,data,set,data,set,tuple3,k,k,ev,edges,final,map,function,k,vv,vertex,value,initializer,execution,environment,context,data,set,edge,k,ev,edge,data,set,edges,map,new,tuple3to,edge,map,k,ev,return,from,data,set,edge,data,set,vertex,value,initializer,context
Graph -> public static <K, VV, EV> Graph<K, VV, EV> fromTupleDataSet(DataSet<Tuple3<K, K, EV>> edges, 			final MapFunction<K, VV> vertexValueInitializer, ExecutionEnvironment context);1466789678;Creates a graph from a DataSet of Tuple3 objects for edges._<p>_Each Tuple3 will become one Edge, where the source ID will be the first field of the Tuple2,_the target ID will be the second field of the Tuple2_and the Edge value will be the third field of the Tuple3._<p>_Vertices are created automatically and their values are initialized_by applying the provided vertexValueInitializer map function to the vertex IDs.__@param edges a DataSet of Tuple3._@param vertexValueInitializer the mapper function that initializes the vertex values._It allows to apply a map transformation on the vertex ID to produce an initial vertex value._@param context the flink execution environment._@return the newly created graph.;public static <K, VV, EV> Graph<K, VV, EV> fromTupleDataSet(DataSet<Tuple3<K, K, EV>> edges,_			final MapFunction<K, VV> vertexValueInitializer, ExecutionEnvironment context) {__		DataSet<Edge<K, EV>> edgeDataSet = edges.map(new Tuple3ToEdgeMap<K, EV>())__		return fromDataSet(edgeDataSet, vertexValueInitializer, context)__	};creates,a,graph,from,a,data,set,of,tuple3,objects,for,edges,p,each,tuple3,will,become,one,edge,where,the,source,id,will,be,the,first,field,of,the,tuple2,the,target,id,will,be,the,second,field,of,the,tuple2,and,the,edge,value,will,be,the,third,field,of,the,tuple3,p,vertices,are,created,automatically,and,their,values,are,initialized,by,applying,the,provided,vertex,value,initializer,map,function,to,the,vertex,ids,param,edges,a,data,set,of,tuple3,param,vertex,value,initializer,the,mapper,function,that,initializes,the,vertex,values,it,allows,to,apply,a,map,transformation,on,the,vertex,id,to,produce,an,initial,vertex,value,param,context,the,flink,execution,environment,return,the,newly,created,graph;public,static,k,vv,ev,graph,k,vv,ev,from,tuple,data,set,data,set,tuple3,k,k,ev,edges,final,map,function,k,vv,vertex,value,initializer,execution,environment,context,data,set,edge,k,ev,edge,data,set,edges,map,new,tuple3to,edge,map,k,ev,return,from,data,set,edge,data,set,vertex,value,initializer,context
Graph -> public static <K, VV, EV> Graph<K, VV, EV> fromTupleDataSet(DataSet<Tuple3<K, K, EV>> edges, 			final MapFunction<K, VV> vertexValueInitializer, ExecutionEnvironment context);1467140656;Creates a graph from a DataSet of Tuple3 objects for edges._<p>_Each Tuple3 will become one Edge, where the source ID will be the first field of the Tuple2,_the target ID will be the second field of the Tuple2_and the Edge value will be the third field of the Tuple3._<p>_Vertices are created automatically and their values are initialized_by applying the provided vertexValueInitializer map function to the vertex IDs.__@param edges a DataSet of Tuple3._@param vertexValueInitializer the mapper function that initializes the vertex values._It allows to apply a map transformation on the vertex ID to produce an initial vertex value._@param context the flink execution environment._@return the newly created graph.;public static <K, VV, EV> Graph<K, VV, EV> fromTupleDataSet(DataSet<Tuple3<K, K, EV>> edges,_			final MapFunction<K, VV> vertexValueInitializer, ExecutionEnvironment context) {__		DataSet<Edge<K, EV>> edgeDataSet = edges.map(new Tuple3ToEdgeMap<K, EV>())__		return fromDataSet(edgeDataSet, vertexValueInitializer, context)__	};creates,a,graph,from,a,data,set,of,tuple3,objects,for,edges,p,each,tuple3,will,become,one,edge,where,the,source,id,will,be,the,first,field,of,the,tuple2,the,target,id,will,be,the,second,field,of,the,tuple2,and,the,edge,value,will,be,the,third,field,of,the,tuple3,p,vertices,are,created,automatically,and,their,values,are,initialized,by,applying,the,provided,vertex,value,initializer,map,function,to,the,vertex,ids,param,edges,a,data,set,of,tuple3,param,vertex,value,initializer,the,mapper,function,that,initializes,the,vertex,values,it,allows,to,apply,a,map,transformation,on,the,vertex,id,to,produce,an,initial,vertex,value,param,context,the,flink,execution,environment,return,the,newly,created,graph;public,static,k,vv,ev,graph,k,vv,ev,from,tuple,data,set,data,set,tuple3,k,k,ev,edges,final,map,function,k,vv,vertex,value,initializer,execution,environment,context,data,set,edge,k,ev,edge,data,set,edges,map,new,tuple3to,edge,map,k,ev,return,from,data,set,edge,data,set,vertex,value,initializer,context
Graph -> public static <K, VV, EV> Graph<K, VV, EV> fromTupleDataSet(DataSet<Tuple3<K, K, EV>> edges, 			final MapFunction<K, VV> vertexValueInitializer, ExecutionEnvironment context);1467306272;Creates a graph from a DataSet of Tuple3 objects for edges._<p>_Each Tuple3 will become one Edge, where the source ID will be the first field of the Tuple2,_the target ID will be the second field of the Tuple2_and the Edge value will be the third field of the Tuple3._<p>_Vertices are created automatically and their values are initialized_by applying the provided vertexValueInitializer map function to the vertex IDs.__@param edges a DataSet of Tuple3._@param vertexValueInitializer the mapper function that initializes the vertex values._It allows to apply a map transformation on the vertex ID to produce an initial vertex value._@param context the flink execution environment._@return the newly created graph.;public static <K, VV, EV> Graph<K, VV, EV> fromTupleDataSet(DataSet<Tuple3<K, K, EV>> edges,_			final MapFunction<K, VV> vertexValueInitializer, ExecutionEnvironment context) {__		DataSet<Edge<K, EV>> edgeDataSet = edges.map(new Tuple3ToEdgeMap<K, EV>())__		return fromDataSet(edgeDataSet, vertexValueInitializer, context)__	};creates,a,graph,from,a,data,set,of,tuple3,objects,for,edges,p,each,tuple3,will,become,one,edge,where,the,source,id,will,be,the,first,field,of,the,tuple2,the,target,id,will,be,the,second,field,of,the,tuple2,and,the,edge,value,will,be,the,third,field,of,the,tuple3,p,vertices,are,created,automatically,and,their,values,are,initialized,by,applying,the,provided,vertex,value,initializer,map,function,to,the,vertex,ids,param,edges,a,data,set,of,tuple3,param,vertex,value,initializer,the,mapper,function,that,initializes,the,vertex,values,it,allows,to,apply,a,map,transformation,on,the,vertex,id,to,produce,an,initial,vertex,value,param,context,the,flink,execution,environment,return,the,newly,created,graph;public,static,k,vv,ev,graph,k,vv,ev,from,tuple,data,set,data,set,tuple3,k,k,ev,edges,final,map,function,k,vv,vertex,value,initializer,execution,environment,context,data,set,edge,k,ev,edge,data,set,edges,map,new,tuple3to,edge,map,k,ev,return,from,data,set,edge,data,set,vertex,value,initializer,context
Graph -> public static <K, VV, EV> Graph<K, VV, EV> fromTupleDataSet(DataSet<Tuple3<K, K, EV>> edges, 			final MapFunction<K, VV> vertexValueInitializer, ExecutionEnvironment context);1470042815;Creates a graph from a DataSet of Tuple3 objects for edges._<p>_Each Tuple3 will become one Edge, where the source ID will be the first field of the Tuple2,_the target ID will be the second field of the Tuple2_and the Edge value will be the third field of the Tuple3._<p>_Vertices are created automatically and their values are initialized_by applying the provided vertexValueInitializer map function to the vertex IDs.__@param edges a DataSet of Tuple3._@param vertexValueInitializer the mapper function that initializes the vertex values._It allows to apply a map transformation on the vertex ID to produce an initial vertex value._@param context the flink execution environment._@return the newly created graph.;public static <K, VV, EV> Graph<K, VV, EV> fromTupleDataSet(DataSet<Tuple3<K, K, EV>> edges,_			final MapFunction<K, VV> vertexValueInitializer, ExecutionEnvironment context) {__		DataSet<Edge<K, EV>> edgeDataSet = edges.map(new Tuple3ToEdgeMap<K, EV>())__		return fromDataSet(edgeDataSet, vertexValueInitializer, context)__	};creates,a,graph,from,a,data,set,of,tuple3,objects,for,edges,p,each,tuple3,will,become,one,edge,where,the,source,id,will,be,the,first,field,of,the,tuple2,the,target,id,will,be,the,second,field,of,the,tuple2,and,the,edge,value,will,be,the,third,field,of,the,tuple3,p,vertices,are,created,automatically,and,their,values,are,initialized,by,applying,the,provided,vertex,value,initializer,map,function,to,the,vertex,ids,param,edges,a,data,set,of,tuple3,param,vertex,value,initializer,the,mapper,function,that,initializes,the,vertex,values,it,allows,to,apply,a,map,transformation,on,the,vertex,id,to,produce,an,initial,vertex,value,param,context,the,flink,execution,environment,return,the,newly,created,graph;public,static,k,vv,ev,graph,k,vv,ev,from,tuple,data,set,data,set,tuple3,k,k,ev,edges,final,map,function,k,vv,vertex,value,initializer,execution,environment,context,data,set,edge,k,ev,edge,data,set,edges,map,new,tuple3to,edge,map,k,ev,return,from,data,set,edge,data,set,vertex,value,initializer,context
Graph -> public static <K, VV, EV> Graph<K, VV, EV> fromTupleDataSet(DataSet<Tuple3<K, K, EV>> edges, 			final MapFunction<K, VV> vertexValueInitializer, ExecutionEnvironment context);1475684776;Creates a graph from a DataSet of Tuple3 objects for edges._<p>_Each Tuple3 will become one Edge, where the source ID will be the first field of the Tuple2,_the target ID will be the second field of the Tuple2_and the Edge value will be the third field of the Tuple3._<p>_Vertices are created automatically and their values are initialized_by applying the provided vertexValueInitializer map function to the vertex IDs.__@param edges a DataSet of Tuple3._@param vertexValueInitializer the mapper function that initializes the vertex values._It allows to apply a map transformation on the vertex ID to produce an initial vertex value._@param context the flink execution environment._@return the newly created graph.;public static <K, VV, EV> Graph<K, VV, EV> fromTupleDataSet(DataSet<Tuple3<K, K, EV>> edges,_			final MapFunction<K, VV> vertexValueInitializer, ExecutionEnvironment context) {__		DataSet<Edge<K, EV>> edgeDataSet = edges.map(new Tuple3ToEdgeMap<K, EV>())__		return fromDataSet(edgeDataSet, vertexValueInitializer, context)__	};creates,a,graph,from,a,data,set,of,tuple3,objects,for,edges,p,each,tuple3,will,become,one,edge,where,the,source,id,will,be,the,first,field,of,the,tuple2,the,target,id,will,be,the,second,field,of,the,tuple2,and,the,edge,value,will,be,the,third,field,of,the,tuple3,p,vertices,are,created,automatically,and,their,values,are,initialized,by,applying,the,provided,vertex,value,initializer,map,function,to,the,vertex,ids,param,edges,a,data,set,of,tuple3,param,vertex,value,initializer,the,mapper,function,that,initializes,the,vertex,values,it,allows,to,apply,a,map,transformation,on,the,vertex,id,to,produce,an,initial,vertex,value,param,context,the,flink,execution,environment,return,the,newly,created,graph;public,static,k,vv,ev,graph,k,vv,ev,from,tuple,data,set,data,set,tuple3,k,k,ev,edges,final,map,function,k,vv,vertex,value,initializer,execution,environment,context,data,set,edge,k,ev,edge,data,set,edges,map,new,tuple3to,edge,map,k,ev,return,from,data,set,edge,data,set,vertex,value,initializer,context
Graph -> public static <K, VV, EV> Graph<K, VV, EV> fromTupleDataSet(DataSet<Tuple3<K, K, EV>> edges, 			final MapFunction<K, VV> vertexValueInitializer, ExecutionEnvironment context);1475685606;Creates a graph from a DataSet of Tuple3 objects for edges._<p>_Each Tuple3 will become one Edge, where the source ID will be the first field of the Tuple2,_the target ID will be the second field of the Tuple2_and the Edge value will be the third field of the Tuple3._<p>_Vertices are created automatically and their values are initialized_by applying the provided vertexValueInitializer map function to the vertex IDs.__@param edges a DataSet of Tuple3._@param vertexValueInitializer the mapper function that initializes the vertex values._It allows to apply a map transformation on the vertex ID to produce an initial vertex value._@param context the flink execution environment._@return the newly created graph.;public static <K, VV, EV> Graph<K, VV, EV> fromTupleDataSet(DataSet<Tuple3<K, K, EV>> edges,_			final MapFunction<K, VV> vertexValueInitializer, ExecutionEnvironment context) {__		DataSet<Edge<K, EV>> edgeDataSet = edges.map(new Tuple3ToEdgeMap<K, EV>())__		return fromDataSet(edgeDataSet, vertexValueInitializer, context)__	};creates,a,graph,from,a,data,set,of,tuple3,objects,for,edges,p,each,tuple3,will,become,one,edge,where,the,source,id,will,be,the,first,field,of,the,tuple2,the,target,id,will,be,the,second,field,of,the,tuple2,and,the,edge,value,will,be,the,third,field,of,the,tuple3,p,vertices,are,created,automatically,and,their,values,are,initialized,by,applying,the,provided,vertex,value,initializer,map,function,to,the,vertex,ids,param,edges,a,data,set,of,tuple3,param,vertex,value,initializer,the,mapper,function,that,initializes,the,vertex,values,it,allows,to,apply,a,map,transformation,on,the,vertex,id,to,produce,an,initial,vertex,value,param,context,the,flink,execution,environment,return,the,newly,created,graph;public,static,k,vv,ev,graph,k,vv,ev,from,tuple,data,set,data,set,tuple3,k,k,ev,edges,final,map,function,k,vv,vertex,value,initializer,execution,environment,context,data,set,edge,k,ev,edge,data,set,edges,map,new,tuple3to,edge,map,k,ev,return,from,data,set,edge,data,set,vertex,value,initializer,context
Graph -> public static <K, VV, EV> Graph<K, VV, EV> fromTupleDataSet(DataSet<Tuple3<K, K, EV>> edges, 			final MapFunction<K, VV> vertexValueInitializer, ExecutionEnvironment context);1481745825;Creates a graph from a DataSet of Tuple3 objects for edges._<p>_Each Tuple3 will become one Edge, where the source ID will be the first field of the Tuple2,_the target ID will be the second field of the Tuple2_and the Edge value will be the third field of the Tuple3._<p>_Vertices are created automatically and their values are initialized_by applying the provided vertexValueInitializer map function to the vertex IDs.__@param edges a DataSet of Tuple3._@param vertexValueInitializer the mapper function that initializes the vertex values._It allows to apply a map transformation on the vertex ID to produce an initial vertex value._@param context the flink execution environment._@return the newly created graph.;public static <K, VV, EV> Graph<K, VV, EV> fromTupleDataSet(DataSet<Tuple3<K, K, EV>> edges,_			final MapFunction<K, VV> vertexValueInitializer, ExecutionEnvironment context) {__		DataSet<Edge<K, EV>> edgeDataSet = edges_			.map(new Tuple3ToEdgeMap<K, EV>())_				.name("Type conversion")___		return fromDataSet(edgeDataSet, vertexValueInitializer, context)__	};creates,a,graph,from,a,data,set,of,tuple3,objects,for,edges,p,each,tuple3,will,become,one,edge,where,the,source,id,will,be,the,first,field,of,the,tuple2,the,target,id,will,be,the,second,field,of,the,tuple2,and,the,edge,value,will,be,the,third,field,of,the,tuple3,p,vertices,are,created,automatically,and,their,values,are,initialized,by,applying,the,provided,vertex,value,initializer,map,function,to,the,vertex,ids,param,edges,a,data,set,of,tuple3,param,vertex,value,initializer,the,mapper,function,that,initializes,the,vertex,values,it,allows,to,apply,a,map,transformation,on,the,vertex,id,to,produce,an,initial,vertex,value,param,context,the,flink,execution,environment,return,the,newly,created,graph;public,static,k,vv,ev,graph,k,vv,ev,from,tuple,data,set,data,set,tuple3,k,k,ev,edges,final,map,function,k,vv,vertex,value,initializer,execution,environment,context,data,set,edge,k,ev,edge,data,set,edges,map,new,tuple3to,edge,map,k,ev,name,type,conversion,return,from,data,set,edge,data,set,vertex,value,initializer,context
Graph -> public static <K, VV, EV> Graph<K, VV, EV> fromTupleDataSet(DataSet<Tuple3<K, K, EV>> edges, 			final MapFunction<K, VV> vertexValueInitializer, ExecutionEnvironment context);1481881009;Creates a graph from a DataSet of Tuple3 objects for edges._<p>_Each Tuple3 will become one Edge, where the source ID will be the first field of the Tuple2,_the target ID will be the second field of the Tuple2_and the Edge value will be the third field of the Tuple3._<p>_Vertices are created automatically and their values are initialized_by applying the provided vertexValueInitializer map function to the vertex IDs.__@param edges a DataSet of Tuple3._@param vertexValueInitializer the mapper function that initializes the vertex values._It allows to apply a map transformation on the vertex ID to produce an initial vertex value._@param context the flink execution environment._@return the newly created graph.;public static <K, VV, EV> Graph<K, VV, EV> fromTupleDataSet(DataSet<Tuple3<K, K, EV>> edges,_			final MapFunction<K, VV> vertexValueInitializer, ExecutionEnvironment context) {__		DataSet<Edge<K, EV>> edgeDataSet = edges_			.map(new Tuple3ToEdgeMap<K, EV>())_				.name("Type conversion")___		return fromDataSet(edgeDataSet, vertexValueInitializer, context)__	};creates,a,graph,from,a,data,set,of,tuple3,objects,for,edges,p,each,tuple3,will,become,one,edge,where,the,source,id,will,be,the,first,field,of,the,tuple2,the,target,id,will,be,the,second,field,of,the,tuple2,and,the,edge,value,will,be,the,third,field,of,the,tuple3,p,vertices,are,created,automatically,and,their,values,are,initialized,by,applying,the,provided,vertex,value,initializer,map,function,to,the,vertex,ids,param,edges,a,data,set,of,tuple3,param,vertex,value,initializer,the,mapper,function,that,initializes,the,vertex,values,it,allows,to,apply,a,map,transformation,on,the,vertex,id,to,produce,an,initial,vertex,value,param,context,the,flink,execution,environment,return,the,newly,created,graph;public,static,k,vv,ev,graph,k,vv,ev,from,tuple,data,set,data,set,tuple3,k,k,ev,edges,final,map,function,k,vv,vertex,value,initializer,execution,environment,context,data,set,edge,k,ev,edge,data,set,edges,map,new,tuple3to,edge,map,k,ev,name,type,conversion,return,from,data,set,edge,data,set,vertex,value,initializer,context
Graph -> public static <K, VV, EV> Graph<K, VV, EV> fromTupleDataSet(DataSet<Tuple3<K, K, EV>> edges, 			final MapFunction<K, VV> vertexValueInitializer, ExecutionEnvironment context);1484160227;Creates a graph from a DataSet of Tuple3 objects for edges._<p>_Each Tuple3 will become one Edge, where the source ID will be the first field of the Tuple2,_the target ID will be the second field of the Tuple2_and the Edge value will be the third field of the Tuple3._<p>_Vertices are created automatically and their values are initialized_by applying the provided vertexValueInitializer map function to the vertex IDs.__@param edges a DataSet of Tuple3._@param vertexValueInitializer the mapper function that initializes the vertex values._It allows to apply a map transformation on the vertex ID to produce an initial vertex value._@param context the flink execution environment._@return the newly created graph.;public static <K, VV, EV> Graph<K, VV, EV> fromTupleDataSet(DataSet<Tuple3<K, K, EV>> edges,_			final MapFunction<K, VV> vertexValueInitializer, ExecutionEnvironment context) {__		DataSet<Edge<K, EV>> edgeDataSet = edges_			.map(new Tuple3ToEdgeMap<K, EV>())_				.name("Type conversion")___		return fromDataSet(edgeDataSet, vertexValueInitializer, context)__	};creates,a,graph,from,a,data,set,of,tuple3,objects,for,edges,p,each,tuple3,will,become,one,edge,where,the,source,id,will,be,the,first,field,of,the,tuple2,the,target,id,will,be,the,second,field,of,the,tuple2,and,the,edge,value,will,be,the,third,field,of,the,tuple3,p,vertices,are,created,automatically,and,their,values,are,initialized,by,applying,the,provided,vertex,value,initializer,map,function,to,the,vertex,ids,param,edges,a,data,set,of,tuple3,param,vertex,value,initializer,the,mapper,function,that,initializes,the,vertex,values,it,allows,to,apply,a,map,transformation,on,the,vertex,id,to,produce,an,initial,vertex,value,param,context,the,flink,execution,environment,return,the,newly,created,graph;public,static,k,vv,ev,graph,k,vv,ev,from,tuple,data,set,data,set,tuple3,k,k,ev,edges,final,map,function,k,vv,vertex,value,initializer,execution,environment,context,data,set,edge,k,ev,edge,data,set,edges,map,new,tuple3to,edge,map,k,ev,name,type,conversion,return,from,data,set,edge,data,set,vertex,value,initializer,context
Graph -> public static <K, VV, EV> Graph<K, VV, EV> fromTupleDataSet(DataSet<Tuple3<K, K, EV>> edges, 			final MapFunction<K, VV> vertexValueInitializer, ExecutionEnvironment context);1484685504;Creates a graph from a DataSet of Tuple3 objects for edges._<p>_Each Tuple3 will become one Edge, where the source ID will be the first field of the Tuple2,_the target ID will be the second field of the Tuple2_and the Edge value will be the third field of the Tuple3._<p>_Vertices are created automatically and their values are initialized_by applying the provided vertexValueInitializer map function to the vertex IDs.__@param edges a DataSet of Tuple3._@param vertexValueInitializer the mapper function that initializes the vertex values._It allows to apply a map transformation on the vertex ID to produce an initial vertex value._@param context the flink execution environment._@return the newly created graph.;public static <K, VV, EV> Graph<K, VV, EV> fromTupleDataSet(DataSet<Tuple3<K, K, EV>> edges,_			final MapFunction<K, VV> vertexValueInitializer, ExecutionEnvironment context) {__		DataSet<Edge<K, EV>> edgeDataSet = edges_			.map(new Tuple3ToEdgeMap<K, EV>())_				.name("Type conversion")___		return fromDataSet(edgeDataSet, vertexValueInitializer, context)__	};creates,a,graph,from,a,data,set,of,tuple3,objects,for,edges,p,each,tuple3,will,become,one,edge,where,the,source,id,will,be,the,first,field,of,the,tuple2,the,target,id,will,be,the,second,field,of,the,tuple2,and,the,edge,value,will,be,the,third,field,of,the,tuple3,p,vertices,are,created,automatically,and,their,values,are,initialized,by,applying,the,provided,vertex,value,initializer,map,function,to,the,vertex,ids,param,edges,a,data,set,of,tuple3,param,vertex,value,initializer,the,mapper,function,that,initializes,the,vertex,values,it,allows,to,apply,a,map,transformation,on,the,vertex,id,to,produce,an,initial,vertex,value,param,context,the,flink,execution,environment,return,the,newly,created,graph;public,static,k,vv,ev,graph,k,vv,ev,from,tuple,data,set,data,set,tuple3,k,k,ev,edges,final,map,function,k,vv,vertex,value,initializer,execution,environment,context,data,set,edge,k,ev,edge,data,set,edges,map,new,tuple3to,edge,map,k,ev,name,type,conversion,return,from,data,set,edge,data,set,vertex,value,initializer,context
Graph -> public static <K, VV, EV> Graph<K, VV, EV> fromTupleDataSet(DataSet<Tuple3<K, K, EV>> edges, 			final MapFunction<K, VV> vertexValueInitializer, ExecutionEnvironment context);1489068942;Creates a graph from a DataSet of Tuple3 objects for edges._<p>_Each Tuple3 will become one Edge, where the source ID will be the first field of the Tuple2,_the target ID will be the second field of the Tuple2_and the Edge value will be the third field of the Tuple3._<p>_Vertices are created automatically and their values are initialized_by applying the provided vertexValueInitializer map function to the vertex IDs.__@param edges a DataSet of Tuple3._@param vertexValueInitializer the mapper function that initializes the vertex values._It allows to apply a map transformation on the vertex ID to produce an initial vertex value._@param context the flink execution environment._@return the newly created graph.;public static <K, VV, EV> Graph<K, VV, EV> fromTupleDataSet(DataSet<Tuple3<K, K, EV>> edges,_			final MapFunction<K, VV> vertexValueInitializer, ExecutionEnvironment context) {__		DataSet<Edge<K, EV>> edgeDataSet = edges_			.map(new Tuple3ToEdgeMap<K, EV>())_				.name("Type conversion")___		return fromDataSet(edgeDataSet, vertexValueInitializer, context)__	};creates,a,graph,from,a,data,set,of,tuple3,objects,for,edges,p,each,tuple3,will,become,one,edge,where,the,source,id,will,be,the,first,field,of,the,tuple2,the,target,id,will,be,the,second,field,of,the,tuple2,and,the,edge,value,will,be,the,third,field,of,the,tuple3,p,vertices,are,created,automatically,and,their,values,are,initialized,by,applying,the,provided,vertex,value,initializer,map,function,to,the,vertex,ids,param,edges,a,data,set,of,tuple3,param,vertex,value,initializer,the,mapper,function,that,initializes,the,vertex,values,it,allows,to,apply,a,map,transformation,on,the,vertex,id,to,produce,an,initial,vertex,value,param,context,the,flink,execution,environment,return,the,newly,created,graph;public,static,k,vv,ev,graph,k,vv,ev,from,tuple,data,set,data,set,tuple3,k,k,ev,edges,final,map,function,k,vv,vertex,value,initializer,execution,environment,context,data,set,edge,k,ev,edge,data,set,edges,map,new,tuple3to,edge,map,k,ev,name,type,conversion,return,from,data,set,edge,data,set,vertex,value,initializer,context
Graph -> public static <K, VV, EV> Graph<K, VV, EV> fromTupleDataSet(DataSet<Tuple3<K, K, EV>> edges, 			final MapFunction<K, VV> vertexValueInitializer, ExecutionEnvironment context);1490973446;Creates a graph from a DataSet of Tuple3 objects for edges._<p>_Each Tuple3 will become one Edge, where the source ID will be the first field of the Tuple2,_the target ID will be the second field of the Tuple2_and the Edge value will be the third field of the Tuple3._<p>_Vertices are created automatically and their values are initialized_by applying the provided vertexValueInitializer map function to the vertex IDs.__@param edges a DataSet of Tuple3._@param vertexValueInitializer the mapper function that initializes the vertex values._It allows to apply a map transformation on the vertex ID to produce an initial vertex value._@param context the flink execution environment._@return the newly created graph.;public static <K, VV, EV> Graph<K, VV, EV> fromTupleDataSet(DataSet<Tuple3<K, K, EV>> edges,_			final MapFunction<K, VV> vertexValueInitializer, ExecutionEnvironment context) {__		DataSet<Edge<K, EV>> edgeDataSet = edges_			.map(new Tuple3ToEdgeMap<K, EV>())_				.name("Type conversion")___		return fromDataSet(edgeDataSet, vertexValueInitializer, context)__	};creates,a,graph,from,a,data,set,of,tuple3,objects,for,edges,p,each,tuple3,will,become,one,edge,where,the,source,id,will,be,the,first,field,of,the,tuple2,the,target,id,will,be,the,second,field,of,the,tuple2,and,the,edge,value,will,be,the,third,field,of,the,tuple3,p,vertices,are,created,automatically,and,their,values,are,initialized,by,applying,the,provided,vertex,value,initializer,map,function,to,the,vertex,ids,param,edges,a,data,set,of,tuple3,param,vertex,value,initializer,the,mapper,function,that,initializes,the,vertex,values,it,allows,to,apply,a,map,transformation,on,the,vertex,id,to,produce,an,initial,vertex,value,param,context,the,flink,execution,environment,return,the,newly,created,graph;public,static,k,vv,ev,graph,k,vv,ev,from,tuple,data,set,data,set,tuple3,k,k,ev,edges,final,map,function,k,vv,vertex,value,initializer,execution,environment,context,data,set,edge,k,ev,edge,data,set,edges,map,new,tuple3to,edge,map,k,ev,name,type,conversion,return,from,data,set,edge,data,set,vertex,value,initializer,context
Graph -> public static <K, VV, EV> Graph<K, VV, EV> fromTupleDataSet(DataSet<Tuple3<K, K, EV>> edges, 			final MapFunction<K, VV> vertexValueInitializer, ExecutionEnvironment context);1495819075;Creates a graph from a DataSet of Tuple3 objects for edges.__<p>Each Tuple3 will become one Edge, where the source ID will be the first field of the Tuple2,_the target ID will be the second field of the Tuple2_and the Edge value will be the third field of the Tuple3.__<p>Vertices are created automatically and their values are initialized_by applying the provided vertexValueInitializer map function to the vertex IDs.__@param edges a DataSet of Tuple3._@param vertexValueInitializer the mapper function that initializes the vertex values._It allows to apply a map transformation on the vertex ID to produce an initial vertex value._@param context the flink execution environment._@return the newly created graph.;public static <K, VV, EV> Graph<K, VV, EV> fromTupleDataSet(DataSet<Tuple3<K, K, EV>> edges,_			final MapFunction<K, VV> vertexValueInitializer, ExecutionEnvironment context) {__		DataSet<Edge<K, EV>> edgeDataSet = edges_			.map(new Tuple3ToEdgeMap<K, EV>())_				.name("Type conversion")___		return fromDataSet(edgeDataSet, vertexValueInitializer, context)__	};creates,a,graph,from,a,data,set,of,tuple3,objects,for,edges,p,each,tuple3,will,become,one,edge,where,the,source,id,will,be,the,first,field,of,the,tuple2,the,target,id,will,be,the,second,field,of,the,tuple2,and,the,edge,value,will,be,the,third,field,of,the,tuple3,p,vertices,are,created,automatically,and,their,values,are,initialized,by,applying,the,provided,vertex,value,initializer,map,function,to,the,vertex,ids,param,edges,a,data,set,of,tuple3,param,vertex,value,initializer,the,mapper,function,that,initializes,the,vertex,values,it,allows,to,apply,a,map,transformation,on,the,vertex,id,to,produce,an,initial,vertex,value,param,context,the,flink,execution,environment,return,the,newly,created,graph;public,static,k,vv,ev,graph,k,vv,ev,from,tuple,data,set,data,set,tuple3,k,k,ev,edges,final,map,function,k,vv,vertex,value,initializer,execution,environment,context,data,set,edge,k,ev,edge,data,set,edges,map,new,tuple3to,edge,map,k,ev,name,type,conversion,return,from,data,set,edge,data,set,vertex,value,initializer,context
Graph -> public static <K, VV, EV> Graph<K, VV, EV> fromTupleDataSet(DataSet<Tuple3<K, K, EV>> edges, 			final MapFunction<K, VV> vertexValueInitializer, ExecutionEnvironment context);1502111816;Creates a graph from a DataSet of Tuple3 objects for edges.__<p>Each Tuple3 will become one Edge, where the source ID will be the first field of the Tuple2,_the target ID will be the second field of the Tuple2_and the Edge value will be the third field of the Tuple3.__<p>Vertices are created automatically and their values are initialized_by applying the provided vertexValueInitializer map function to the vertex IDs.__@param edges a DataSet of Tuple3._@param vertexValueInitializer the mapper function that initializes the vertex values._It allows to apply a map transformation on the vertex ID to produce an initial vertex value._@param context the flink execution environment._@return the newly created graph.;public static <K, VV, EV> Graph<K, VV, EV> fromTupleDataSet(DataSet<Tuple3<K, K, EV>> edges,_			final MapFunction<K, VV> vertexValueInitializer, ExecutionEnvironment context) {__		DataSet<Edge<K, EV>> edgeDataSet = edges_			.map(new Tuple3ToEdgeMap<>())_				.name("Type conversion")___		return fromDataSet(edgeDataSet, vertexValueInitializer, context)__	};creates,a,graph,from,a,data,set,of,tuple3,objects,for,edges,p,each,tuple3,will,become,one,edge,where,the,source,id,will,be,the,first,field,of,the,tuple2,the,target,id,will,be,the,second,field,of,the,tuple2,and,the,edge,value,will,be,the,third,field,of,the,tuple3,p,vertices,are,created,automatically,and,their,values,are,initialized,by,applying,the,provided,vertex,value,initializer,map,function,to,the,vertex,ids,param,edges,a,data,set,of,tuple3,param,vertex,value,initializer,the,mapper,function,that,initializes,the,vertex,values,it,allows,to,apply,a,map,transformation,on,the,vertex,id,to,produce,an,initial,vertex,value,param,context,the,flink,execution,environment,return,the,newly,created,graph;public,static,k,vv,ev,graph,k,vv,ev,from,tuple,data,set,data,set,tuple3,k,k,ev,edges,final,map,function,k,vv,vertex,value,initializer,execution,environment,context,data,set,edge,k,ev,edge,data,set,edges,map,new,tuple3to,edge,map,name,type,conversion,return,from,data,set,edge,data,set,vertex,value,initializer,context
Graph -> public <M> Graph<K, VV, EV> runScatterGatherIteration( 			VertexUpdateFunction<K, VV, M> vertexUpdateFunction, 			MessagingFunction<K, VV, M, EV> messagingFunction, 			int maximumNumberOfIterations, ScatterGatherConfiguration parameters);1454404649;Runs a ScatterGather iteration on the graph with configuration options.__@param vertexUpdateFunction the vertex update function_@param messagingFunction the messaging function_@param maximumNumberOfIterations maximum number of iterations to perform_@param parameters the iteration configuration parameters__@return the updated Graph after the scatter-gather iteration has converged or_after maximumNumberOfIterations.;public <M> Graph<K, VV, EV> runScatterGatherIteration(_			VertexUpdateFunction<K, VV, M> vertexUpdateFunction,_			MessagingFunction<K, VV, M, EV> messagingFunction,_			int maximumNumberOfIterations, ScatterGatherConfiguration parameters) {__		ScatterGatherIteration<K, VV, M, EV> iteration = ScatterGatherIteration.withEdges(_				edges, vertexUpdateFunction, messagingFunction, maximumNumberOfIterations)___		iteration.configure(parameters)___		DataSet<Vertex<K, VV>> newVertices = this.getVertices().runOperation(iteration)___		return new Graph<K, VV, EV>(newVertices, this.edges, this.context)__	};runs,a,scatter,gather,iteration,on,the,graph,with,configuration,options,param,vertex,update,function,the,vertex,update,function,param,messaging,function,the,messaging,function,param,maximum,number,of,iterations,maximum,number,of,iterations,to,perform,param,parameters,the,iteration,configuration,parameters,return,the,updated,graph,after,the,scatter,gather,iteration,has,converged,or,after,maximum,number,of,iterations;public,m,graph,k,vv,ev,run,scatter,gather,iteration,vertex,update,function,k,vv,m,vertex,update,function,messaging,function,k,vv,m,ev,messaging,function,int,maximum,number,of,iterations,scatter,gather,configuration,parameters,scatter,gather,iteration,k,vv,m,ev,iteration,scatter,gather,iteration,with,edges,edges,vertex,update,function,messaging,function,maximum,number,of,iterations,iteration,configure,parameters,data,set,vertex,k,vv,new,vertices,this,get,vertices,run,operation,iteration,return,new,graph,k,vv,ev,new,vertices,this,edges,this,context
Graph -> public <M> Graph<K, VV, EV> runScatterGatherIteration( 			VertexUpdateFunction<K, VV, M> vertexUpdateFunction, 			MessagingFunction<K, VV, M, EV> messagingFunction, 			int maximumNumberOfIterations, ScatterGatherConfiguration parameters);1458583829;Runs a ScatterGather iteration on the graph with configuration options.__@param vertexUpdateFunction the vertex update function_@param messagingFunction the messaging function_@param maximumNumberOfIterations maximum number of iterations to perform_@param parameters the iteration configuration parameters__@return the updated Graph after the scatter-gather iteration has converged or_after maximumNumberOfIterations.;public <M> Graph<K, VV, EV> runScatterGatherIteration(_			VertexUpdateFunction<K, VV, M> vertexUpdateFunction,_			MessagingFunction<K, VV, M, EV> messagingFunction,_			int maximumNumberOfIterations, ScatterGatherConfiguration parameters) {__		ScatterGatherIteration<K, VV, M, EV> iteration = ScatterGatherIteration.withEdges(_				edges, vertexUpdateFunction, messagingFunction, maximumNumberOfIterations)___		iteration.configure(parameters)___		DataSet<Vertex<K, VV>> newVertices = this.getVertices().runOperation(iteration)___		return new Graph<K, VV, EV>(newVertices, this.edges, this.context)__	};runs,a,scatter,gather,iteration,on,the,graph,with,configuration,options,param,vertex,update,function,the,vertex,update,function,param,messaging,function,the,messaging,function,param,maximum,number,of,iterations,maximum,number,of,iterations,to,perform,param,parameters,the,iteration,configuration,parameters,return,the,updated,graph,after,the,scatter,gather,iteration,has,converged,or,after,maximum,number,of,iterations;public,m,graph,k,vv,ev,run,scatter,gather,iteration,vertex,update,function,k,vv,m,vertex,update,function,messaging,function,k,vv,m,ev,messaging,function,int,maximum,number,of,iterations,scatter,gather,configuration,parameters,scatter,gather,iteration,k,vv,m,ev,iteration,scatter,gather,iteration,with,edges,edges,vertex,update,function,messaging,function,maximum,number,of,iterations,iteration,configure,parameters,data,set,vertex,k,vv,new,vertices,this,get,vertices,run,operation,iteration,return,new,graph,k,vv,ev,new,vertices,this,edges,this,context
Graph -> public <M> Graph<K, VV, EV> runScatterGatherIteration( 			VertexUpdateFunction<K, VV, M> vertexUpdateFunction, 			MessagingFunction<K, VV, M, EV> messagingFunction, 			int maximumNumberOfIterations, ScatterGatherConfiguration parameters);1458583829;Runs a ScatterGather iteration on the graph with configuration options.__@param vertexUpdateFunction the vertex update function_@param messagingFunction the messaging function_@param maximumNumberOfIterations maximum number of iterations to perform_@param parameters the iteration configuration parameters__@return the updated Graph after the scatter-gather iteration has converged or_after maximumNumberOfIterations.;public <M> Graph<K, VV, EV> runScatterGatherIteration(_			VertexUpdateFunction<K, VV, M> vertexUpdateFunction,_			MessagingFunction<K, VV, M, EV> messagingFunction,_			int maximumNumberOfIterations, ScatterGatherConfiguration parameters) {__		ScatterGatherIteration<K, VV, M, EV> iteration = ScatterGatherIteration.withEdges(_				edges, vertexUpdateFunction, messagingFunction, maximumNumberOfIterations)___		iteration.configure(parameters)___		DataSet<Vertex<K, VV>> newVertices = this.getVertices().runOperation(iteration)___		return new Graph<K, VV, EV>(newVertices, this.edges, this.context)__	};runs,a,scatter,gather,iteration,on,the,graph,with,configuration,options,param,vertex,update,function,the,vertex,update,function,param,messaging,function,the,messaging,function,param,maximum,number,of,iterations,maximum,number,of,iterations,to,perform,param,parameters,the,iteration,configuration,parameters,return,the,updated,graph,after,the,scatter,gather,iteration,has,converged,or,after,maximum,number,of,iterations;public,m,graph,k,vv,ev,run,scatter,gather,iteration,vertex,update,function,k,vv,m,vertex,update,function,messaging,function,k,vv,m,ev,messaging,function,int,maximum,number,of,iterations,scatter,gather,configuration,parameters,scatter,gather,iteration,k,vv,m,ev,iteration,scatter,gather,iteration,with,edges,edges,vertex,update,function,messaging,function,maximum,number,of,iterations,iteration,configure,parameters,data,set,vertex,k,vv,new,vertices,this,get,vertices,run,operation,iteration,return,new,graph,k,vv,ev,new,vertices,this,edges,this,context
Graph -> public <M> Graph<K, VV, EV> runScatterGatherIteration( 			VertexUpdateFunction<K, VV, M> vertexUpdateFunction, 			MessagingFunction<K, VV, M, EV> messagingFunction, 			int maximumNumberOfIterations, ScatterGatherConfiguration parameters);1462100316;Runs a ScatterGather iteration on the graph with configuration options.__@param vertexUpdateFunction the vertex update function_@param messagingFunction the messaging function_@param maximumNumberOfIterations maximum number of iterations to perform_@param parameters the iteration configuration parameters__@return the updated Graph after the scatter-gather iteration has converged or_after maximumNumberOfIterations.;public <M> Graph<K, VV, EV> runScatterGatherIteration(_			VertexUpdateFunction<K, VV, M> vertexUpdateFunction,_			MessagingFunction<K, VV, M, EV> messagingFunction,_			int maximumNumberOfIterations, ScatterGatherConfiguration parameters) {__		ScatterGatherIteration<K, VV, M, EV> iteration = ScatterGatherIteration.withEdges(_				edges, vertexUpdateFunction, messagingFunction, maximumNumberOfIterations)___		iteration.configure(parameters)___		DataSet<Vertex<K, VV>> newVertices = this.getVertices().runOperation(iteration)___		return new Graph<K, VV, EV>(newVertices, this.edges, this.context)__	};runs,a,scatter,gather,iteration,on,the,graph,with,configuration,options,param,vertex,update,function,the,vertex,update,function,param,messaging,function,the,messaging,function,param,maximum,number,of,iterations,maximum,number,of,iterations,to,perform,param,parameters,the,iteration,configuration,parameters,return,the,updated,graph,after,the,scatter,gather,iteration,has,converged,or,after,maximum,number,of,iterations;public,m,graph,k,vv,ev,run,scatter,gather,iteration,vertex,update,function,k,vv,m,vertex,update,function,messaging,function,k,vv,m,ev,messaging,function,int,maximum,number,of,iterations,scatter,gather,configuration,parameters,scatter,gather,iteration,k,vv,m,ev,iteration,scatter,gather,iteration,with,edges,edges,vertex,update,function,messaging,function,maximum,number,of,iterations,iteration,configure,parameters,data,set,vertex,k,vv,new,vertices,this,get,vertices,run,operation,iteration,return,new,graph,k,vv,ev,new,vertices,this,edges,this,context
Graph -> public <M> Graph<K, VV, EV> runScatterGatherIteration( 			VertexUpdateFunction<K, VV, M> vertexUpdateFunction, 			MessagingFunction<K, VV, M, EV> messagingFunction, 			int maximumNumberOfIterations, ScatterGatherConfiguration parameters);1462100316;Runs a ScatterGather iteration on the graph with configuration options.__@param vertexUpdateFunction the vertex update function_@param messagingFunction the messaging function_@param maximumNumberOfIterations maximum number of iterations to perform_@param parameters the iteration configuration parameters__@return the updated Graph after the scatter-gather iteration has converged or_after maximumNumberOfIterations.;public <M> Graph<K, VV, EV> runScatterGatherIteration(_			VertexUpdateFunction<K, VV, M> vertexUpdateFunction,_			MessagingFunction<K, VV, M, EV> messagingFunction,_			int maximumNumberOfIterations, ScatterGatherConfiguration parameters) {__		ScatterGatherIteration<K, VV, M, EV> iteration = ScatterGatherIteration.withEdges(_				edges, vertexUpdateFunction, messagingFunction, maximumNumberOfIterations)___		iteration.configure(parameters)___		DataSet<Vertex<K, VV>> newVertices = this.getVertices().runOperation(iteration)___		return new Graph<K, VV, EV>(newVertices, this.edges, this.context)__	};runs,a,scatter,gather,iteration,on,the,graph,with,configuration,options,param,vertex,update,function,the,vertex,update,function,param,messaging,function,the,messaging,function,param,maximum,number,of,iterations,maximum,number,of,iterations,to,perform,param,parameters,the,iteration,configuration,parameters,return,the,updated,graph,after,the,scatter,gather,iteration,has,converged,or,after,maximum,number,of,iterations;public,m,graph,k,vv,ev,run,scatter,gather,iteration,vertex,update,function,k,vv,m,vertex,update,function,messaging,function,k,vv,m,ev,messaging,function,int,maximum,number,of,iterations,scatter,gather,configuration,parameters,scatter,gather,iteration,k,vv,m,ev,iteration,scatter,gather,iteration,with,edges,edges,vertex,update,function,messaging,function,maximum,number,of,iterations,iteration,configure,parameters,data,set,vertex,k,vv,new,vertices,this,get,vertices,run,operation,iteration,return,new,graph,k,vv,ev,new,vertices,this,edges,this,context
Graph -> public <M> Graph<K, VV, EV> runScatterGatherIteration( 			VertexUpdateFunction<K, VV, M> vertexUpdateFunction, 			MessagingFunction<K, VV, M, EV> messagingFunction, 			int maximumNumberOfIterations, ScatterGatherConfiguration parameters);1462205213;Runs a ScatterGather iteration on the graph with configuration options.__@param vertexUpdateFunction the vertex update function_@param messagingFunction the messaging function_@param maximumNumberOfIterations maximum number of iterations to perform_@param parameters the iteration configuration parameters__@return the updated Graph after the scatter-gather iteration has converged or_after maximumNumberOfIterations.;public <M> Graph<K, VV, EV> runScatterGatherIteration(_			VertexUpdateFunction<K, VV, M> vertexUpdateFunction,_			MessagingFunction<K, VV, M, EV> messagingFunction,_			int maximumNumberOfIterations, ScatterGatherConfiguration parameters) {__		ScatterGatherIteration<K, VV, M, EV> iteration = ScatterGatherIteration.withEdges(_				edges, vertexUpdateFunction, messagingFunction, maximumNumberOfIterations)___		iteration.configure(parameters)___		DataSet<Vertex<K, VV>> newVertices = this.getVertices().runOperation(iteration)___		return new Graph<K, VV, EV>(newVertices, this.edges, this.context)__	};runs,a,scatter,gather,iteration,on,the,graph,with,configuration,options,param,vertex,update,function,the,vertex,update,function,param,messaging,function,the,messaging,function,param,maximum,number,of,iterations,maximum,number,of,iterations,to,perform,param,parameters,the,iteration,configuration,parameters,return,the,updated,graph,after,the,scatter,gather,iteration,has,converged,or,after,maximum,number,of,iterations;public,m,graph,k,vv,ev,run,scatter,gather,iteration,vertex,update,function,k,vv,m,vertex,update,function,messaging,function,k,vv,m,ev,messaging,function,int,maximum,number,of,iterations,scatter,gather,configuration,parameters,scatter,gather,iteration,k,vv,m,ev,iteration,scatter,gather,iteration,with,edges,edges,vertex,update,function,messaging,function,maximum,number,of,iterations,iteration,configure,parameters,data,set,vertex,k,vv,new,vertices,this,get,vertices,run,operation,iteration,return,new,graph,k,vv,ev,new,vertices,this,edges,this,context
Graph -> public <M> Graph<K, VV, EV> runScatterGatherIteration( 			VertexUpdateFunction<K, VV, M> vertexUpdateFunction, 			MessagingFunction<K, VV, M, EV> messagingFunction, 			int maximumNumberOfIterations, ScatterGatherConfiguration parameters);1462208859;Runs a ScatterGather iteration on the graph with configuration options.__@param vertexUpdateFunction the vertex update function_@param messagingFunction the messaging function_@param maximumNumberOfIterations maximum number of iterations to perform_@param parameters the iteration configuration parameters__@return the updated Graph after the scatter-gather iteration has converged or_after maximumNumberOfIterations.;public <M> Graph<K, VV, EV> runScatterGatherIteration(_			VertexUpdateFunction<K, VV, M> vertexUpdateFunction,_			MessagingFunction<K, VV, M, EV> messagingFunction,_			int maximumNumberOfIterations, ScatterGatherConfiguration parameters) {__		ScatterGatherIteration<K, VV, M, EV> iteration = ScatterGatherIteration.withEdges(_				edges, vertexUpdateFunction, messagingFunction, maximumNumberOfIterations)___		iteration.configure(parameters)___		DataSet<Vertex<K, VV>> newVertices = this.getVertices().runOperation(iteration)___		return new Graph<K, VV, EV>(newVertices, this.edges, this.context)__	};runs,a,scatter,gather,iteration,on,the,graph,with,configuration,options,param,vertex,update,function,the,vertex,update,function,param,messaging,function,the,messaging,function,param,maximum,number,of,iterations,maximum,number,of,iterations,to,perform,param,parameters,the,iteration,configuration,parameters,return,the,updated,graph,after,the,scatter,gather,iteration,has,converged,or,after,maximum,number,of,iterations;public,m,graph,k,vv,ev,run,scatter,gather,iteration,vertex,update,function,k,vv,m,vertex,update,function,messaging,function,k,vv,m,ev,messaging,function,int,maximum,number,of,iterations,scatter,gather,configuration,parameters,scatter,gather,iteration,k,vv,m,ev,iteration,scatter,gather,iteration,with,edges,edges,vertex,update,function,messaging,function,maximum,number,of,iterations,iteration,configure,parameters,data,set,vertex,k,vv,new,vertices,this,get,vertices,run,operation,iteration,return,new,graph,k,vv,ev,new,vertices,this,edges,this,context
Graph -> public <M> Graph<K, VV, EV> runScatterGatherIteration( 			VertexUpdateFunction<K, VV, M> vertexUpdateFunction, 			MessagingFunction<K, VV, M, EV> messagingFunction, 			int maximumNumberOfIterations, ScatterGatherConfiguration parameters);1462809297;Runs a ScatterGather iteration on the graph with configuration options.__@param vertexUpdateFunction the vertex update function_@param messagingFunction the messaging function_@param maximumNumberOfIterations maximum number of iterations to perform_@param parameters the iteration configuration parameters__@return the updated Graph after the scatter-gather iteration has converged or_after maximumNumberOfIterations.;public <M> Graph<K, VV, EV> runScatterGatherIteration(_			VertexUpdateFunction<K, VV, M> vertexUpdateFunction,_			MessagingFunction<K, VV, M, EV> messagingFunction,_			int maximumNumberOfIterations, ScatterGatherConfiguration parameters) {__		ScatterGatherIteration<K, VV, M, EV> iteration = ScatterGatherIteration.withEdges(_				edges, vertexUpdateFunction, messagingFunction, maximumNumberOfIterations)___		iteration.configure(parameters)___		DataSet<Vertex<K, VV>> newVertices = this.getVertices().runOperation(iteration)___		return new Graph<K, VV, EV>(newVertices, this.edges, this.context)__	};runs,a,scatter,gather,iteration,on,the,graph,with,configuration,options,param,vertex,update,function,the,vertex,update,function,param,messaging,function,the,messaging,function,param,maximum,number,of,iterations,maximum,number,of,iterations,to,perform,param,parameters,the,iteration,configuration,parameters,return,the,updated,graph,after,the,scatter,gather,iteration,has,converged,or,after,maximum,number,of,iterations;public,m,graph,k,vv,ev,run,scatter,gather,iteration,vertex,update,function,k,vv,m,vertex,update,function,messaging,function,k,vv,m,ev,messaging,function,int,maximum,number,of,iterations,scatter,gather,configuration,parameters,scatter,gather,iteration,k,vv,m,ev,iteration,scatter,gather,iteration,with,edges,edges,vertex,update,function,messaging,function,maximum,number,of,iterations,iteration,configure,parameters,data,set,vertex,k,vv,new,vertices,this,get,vertices,run,operation,iteration,return,new,graph,k,vv,ev,new,vertices,this,edges,this,context
Graph -> public <M> Graph<K, VV, EV> runScatterGatherIteration( 			VertexUpdateFunction<K, VV, M> vertexUpdateFunction, 			MessagingFunction<K, VV, M, EV> messagingFunction, 			int maximumNumberOfIterations, ScatterGatherConfiguration parameters);1465316775;Runs a ScatterGather iteration on the graph with configuration options.__@param vertexUpdateFunction the vertex update function_@param messagingFunction the messaging function_@param maximumNumberOfIterations maximum number of iterations to perform_@param parameters the iteration configuration parameters__@return the updated Graph after the scatter-gather iteration has converged or_after maximumNumberOfIterations.;public <M> Graph<K, VV, EV> runScatterGatherIteration(_			VertexUpdateFunction<K, VV, M> vertexUpdateFunction,_			MessagingFunction<K, VV, M, EV> messagingFunction,_			int maximumNumberOfIterations, ScatterGatherConfiguration parameters) {__		ScatterGatherIteration<K, VV, M, EV> iteration = ScatterGatherIteration.withEdges(_				edges, vertexUpdateFunction, messagingFunction, maximumNumberOfIterations)___		iteration.configure(parameters)___		DataSet<Vertex<K, VV>> newVertices = this.getVertices().runOperation(iteration)___		return new Graph<K, VV, EV>(newVertices, this.edges, this.context)__	};runs,a,scatter,gather,iteration,on,the,graph,with,configuration,options,param,vertex,update,function,the,vertex,update,function,param,messaging,function,the,messaging,function,param,maximum,number,of,iterations,maximum,number,of,iterations,to,perform,param,parameters,the,iteration,configuration,parameters,return,the,updated,graph,after,the,scatter,gather,iteration,has,converged,or,after,maximum,number,of,iterations;public,m,graph,k,vv,ev,run,scatter,gather,iteration,vertex,update,function,k,vv,m,vertex,update,function,messaging,function,k,vv,m,ev,messaging,function,int,maximum,number,of,iterations,scatter,gather,configuration,parameters,scatter,gather,iteration,k,vv,m,ev,iteration,scatter,gather,iteration,with,edges,edges,vertex,update,function,messaging,function,maximum,number,of,iterations,iteration,configure,parameters,data,set,vertex,k,vv,new,vertices,this,get,vertices,run,operation,iteration,return,new,graph,k,vv,ev,new,vertices,this,edges,this,context
Graph -> public <M> Graph<K, VV, EV> runScatterGatherIteration( 			VertexUpdateFunction<K, VV, M> vertexUpdateFunction, 			MessagingFunction<K, VV, M, EV> messagingFunction, 			int maximumNumberOfIterations, ScatterGatherConfiguration parameters);1466789678;Runs a ScatterGather iteration on the graph with configuration options.__@param vertexUpdateFunction the vertex update function_@param messagingFunction the messaging function_@param maximumNumberOfIterations maximum number of iterations to perform_@param parameters the iteration configuration parameters__@return the updated Graph after the scatter-gather iteration has converged or_after maximumNumberOfIterations.;public <M> Graph<K, VV, EV> runScatterGatherIteration(_			VertexUpdateFunction<K, VV, M> vertexUpdateFunction,_			MessagingFunction<K, VV, M, EV> messagingFunction,_			int maximumNumberOfIterations, ScatterGatherConfiguration parameters) {__		ScatterGatherIteration<K, VV, M, EV> iteration = ScatterGatherIteration.withEdges(_				edges, vertexUpdateFunction, messagingFunction, maximumNumberOfIterations)___		iteration.configure(parameters)___		DataSet<Vertex<K, VV>> newVertices = this.getVertices().runOperation(iteration)___		return new Graph<K, VV, EV>(newVertices, this.edges, this.context)__	};runs,a,scatter,gather,iteration,on,the,graph,with,configuration,options,param,vertex,update,function,the,vertex,update,function,param,messaging,function,the,messaging,function,param,maximum,number,of,iterations,maximum,number,of,iterations,to,perform,param,parameters,the,iteration,configuration,parameters,return,the,updated,graph,after,the,scatter,gather,iteration,has,converged,or,after,maximum,number,of,iterations;public,m,graph,k,vv,ev,run,scatter,gather,iteration,vertex,update,function,k,vv,m,vertex,update,function,messaging,function,k,vv,m,ev,messaging,function,int,maximum,number,of,iterations,scatter,gather,configuration,parameters,scatter,gather,iteration,k,vv,m,ev,iteration,scatter,gather,iteration,with,edges,edges,vertex,update,function,messaging,function,maximum,number,of,iterations,iteration,configure,parameters,data,set,vertex,k,vv,new,vertices,this,get,vertices,run,operation,iteration,return,new,graph,k,vv,ev,new,vertices,this,edges,this,context
Graph -> public <M> Graph<K, VV, EV> runScatterGatherIteration( 			VertexUpdateFunction<K, VV, M> vertexUpdateFunction, 			MessagingFunction<K, VV, M, EV> messagingFunction, 			int maximumNumberOfIterations, ScatterGatherConfiguration parameters);1467140656;Runs a ScatterGather iteration on the graph with configuration options.__@param vertexUpdateFunction the vertex update function_@param messagingFunction the messaging function_@param maximumNumberOfIterations maximum number of iterations to perform_@param parameters the iteration configuration parameters__@return the updated Graph after the scatter-gather iteration has converged or_after maximumNumberOfIterations.;public <M> Graph<K, VV, EV> runScatterGatherIteration(_			VertexUpdateFunction<K, VV, M> vertexUpdateFunction,_			MessagingFunction<K, VV, M, EV> messagingFunction,_			int maximumNumberOfIterations, ScatterGatherConfiguration parameters) {__		ScatterGatherIteration<K, VV, M, EV> iteration = ScatterGatherIteration.withEdges(_				edges, vertexUpdateFunction, messagingFunction, maximumNumberOfIterations)___		iteration.configure(parameters)___		DataSet<Vertex<K, VV>> newVertices = this.getVertices().runOperation(iteration)___		return new Graph<K, VV, EV>(newVertices, this.edges, this.context)__	};runs,a,scatter,gather,iteration,on,the,graph,with,configuration,options,param,vertex,update,function,the,vertex,update,function,param,messaging,function,the,messaging,function,param,maximum,number,of,iterations,maximum,number,of,iterations,to,perform,param,parameters,the,iteration,configuration,parameters,return,the,updated,graph,after,the,scatter,gather,iteration,has,converged,or,after,maximum,number,of,iterations;public,m,graph,k,vv,ev,run,scatter,gather,iteration,vertex,update,function,k,vv,m,vertex,update,function,messaging,function,k,vv,m,ev,messaging,function,int,maximum,number,of,iterations,scatter,gather,configuration,parameters,scatter,gather,iteration,k,vv,m,ev,iteration,scatter,gather,iteration,with,edges,edges,vertex,update,function,messaging,function,maximum,number,of,iterations,iteration,configure,parameters,data,set,vertex,k,vv,new,vertices,this,get,vertices,run,operation,iteration,return,new,graph,k,vv,ev,new,vertices,this,edges,this,context
Graph -> public <T> DataSet<T> groupReduceOnEdges(EdgesFunctionWithVertexValue<K, VV, EV, T> edgesFunction, 			EdgeDirection direction, TypeInformation<T> typeInfo) throws IllegalArgumentException;1445261977;Groups by vertex and computes a GroupReduce transformation over the edge values of each vertex._The edgesFunction applied on the edges has access to both the id and the value_of the grouping vertex.__For each vertex, the edgesFunction can iterate over all edges of this vertex_with the specified direction, and emit any number of output elements, including none.__@param edgesFunction the group reduce function to apply to the neighboring edges of each vertex._@param direction the edge direction (in-, out-, all-)._@param <T> the output type_@param typeInfo the explicit return type._@return a DataSet containing elements of type T_@throws IllegalArgumentException;public <T> DataSet<T> groupReduceOnEdges(EdgesFunctionWithVertexValue<K, VV, EV, T> edgesFunction,_			EdgeDirection direction, TypeInformation<T> typeInfo) throws IllegalArgumentException {__		switch (direction) {_			case IN:_				return vertices.coGroup(edges).where(0).equalTo(1)_						.with(new ApplyCoGroupFunction<K, VV, EV, T>(edgesFunction)).returns(typeInfo)__			case OUT:_				return vertices.coGroup(edges).where(0).equalTo(0)_						.with(new ApplyCoGroupFunction<K, VV, EV, T>(edgesFunction)).returns(typeInfo)__			case ALL:_				return vertices.coGroup(edges.flatMap(new EmitOneEdgePerNode<K, VV, EV>()))_						.where(0).equalTo(0).with(new ApplyCoGroupFunctionOnAllEdges<K, VV, EV, T>(edgesFunction)).returns(typeInfo)__			default:_				throw new IllegalArgumentException("Illegal edge direction")__		}_	};groups,by,vertex,and,computes,a,group,reduce,transformation,over,the,edge,values,of,each,vertex,the,edges,function,applied,on,the,edges,has,access,to,both,the,id,and,the,value,of,the,grouping,vertex,for,each,vertex,the,edges,function,can,iterate,over,all,edges,of,this,vertex,with,the,specified,direction,and,emit,any,number,of,output,elements,including,none,param,edges,function,the,group,reduce,function,to,apply,to,the,neighboring,edges,of,each,vertex,param,direction,the,edge,direction,in,out,all,param,t,the,output,type,param,type,info,the,explicit,return,type,return,a,data,set,containing,elements,of,type,t,throws,illegal,argument,exception;public,t,data,set,t,group,reduce,on,edges,edges,function,with,vertex,value,k,vv,ev,t,edges,function,edge,direction,direction,type,information,t,type,info,throws,illegal,argument,exception,switch,direction,case,in,return,vertices,co,group,edges,where,0,equal,to,1,with,new,apply,co,group,function,k,vv,ev,t,edges,function,returns,type,info,case,out,return,vertices,co,group,edges,where,0,equal,to,0,with,new,apply,co,group,function,k,vv,ev,t,edges,function,returns,type,info,case,all,return,vertices,co,group,edges,flat,map,new,emit,one,edge,per,node,k,vv,ev,where,0,equal,to,0,with,new,apply,co,group,function,on,all,edges,k,vv,ev,t,edges,function,returns,type,info,default,throw,new,illegal,argument,exception,illegal,edge,direction
Graph -> public <T> DataSet<T> groupReduceOnEdges(EdgesFunctionWithVertexValue<K, VV, EV, T> edgesFunction, 			EdgeDirection direction, TypeInformation<T> typeInfo) throws IllegalArgumentException;1445854323;Groups by vertex and computes a GroupReduce transformation over the edge values of each vertex._The edgesFunction applied on the edges has access to both the id and the value_of the grouping vertex.__For each vertex, the edgesFunction can iterate over all edges of this vertex_with the specified direction, and emit any number of output elements, including none.__@param edgesFunction the group reduce function to apply to the neighboring edges of each vertex._@param direction the edge direction (in-, out-, all-)._@param <T> the output type_@param typeInfo the explicit return type._@return a DataSet containing elements of type T_@throws IllegalArgumentException;public <T> DataSet<T> groupReduceOnEdges(EdgesFunctionWithVertexValue<K, VV, EV, T> edgesFunction,_			EdgeDirection direction, TypeInformation<T> typeInfo) throws IllegalArgumentException {__		switch (direction) {_			case IN:_				return vertices.coGroup(edges).where(0).equalTo(1)_						.with(new ApplyCoGroupFunction<K, VV, EV, T>(edgesFunction)).returns(typeInfo)__			case OUT:_				return vertices.coGroup(edges).where(0).equalTo(0)_						.with(new ApplyCoGroupFunction<K, VV, EV, T>(edgesFunction)).returns(typeInfo)__			case ALL:_				return vertices.coGroup(edges.flatMap(new EmitOneEdgePerNode<K, VV, EV>()))_						.where(0).equalTo(0).with(new ApplyCoGroupFunctionOnAllEdges<K, VV, EV, T>(edgesFunction)).returns(typeInfo)__			default:_				throw new IllegalArgumentException("Illegal edge direction")__		}_	};groups,by,vertex,and,computes,a,group,reduce,transformation,over,the,edge,values,of,each,vertex,the,edges,function,applied,on,the,edges,has,access,to,both,the,id,and,the,value,of,the,grouping,vertex,for,each,vertex,the,edges,function,can,iterate,over,all,edges,of,this,vertex,with,the,specified,direction,and,emit,any,number,of,output,elements,including,none,param,edges,function,the,group,reduce,function,to,apply,to,the,neighboring,edges,of,each,vertex,param,direction,the,edge,direction,in,out,all,param,t,the,output,type,param,type,info,the,explicit,return,type,return,a,data,set,containing,elements,of,type,t,throws,illegal,argument,exception;public,t,data,set,t,group,reduce,on,edges,edges,function,with,vertex,value,k,vv,ev,t,edges,function,edge,direction,direction,type,information,t,type,info,throws,illegal,argument,exception,switch,direction,case,in,return,vertices,co,group,edges,where,0,equal,to,1,with,new,apply,co,group,function,k,vv,ev,t,edges,function,returns,type,info,case,out,return,vertices,co,group,edges,where,0,equal,to,0,with,new,apply,co,group,function,k,vv,ev,t,edges,function,returns,type,info,case,all,return,vertices,co,group,edges,flat,map,new,emit,one,edge,per,node,k,vv,ev,where,0,equal,to,0,with,new,apply,co,group,function,on,all,edges,k,vv,ev,t,edges,function,returns,type,info,default,throw,new,illegal,argument,exception,illegal,edge,direction
Graph -> public <T> DataSet<T> groupReduceOnEdges(EdgesFunctionWithVertexValue<K, VV, EV, T> edgesFunction, 			EdgeDirection direction, TypeInformation<T> typeInfo) throws IllegalArgumentException;1446112342;Groups by vertex and computes a GroupReduce transformation over the edge values of each vertex._The edgesFunction applied on the edges has access to both the id and the value_of the grouping vertex.__For each vertex, the edgesFunction can iterate over all edges of this vertex_with the specified direction, and emit any number of output elements, including none.__@param edgesFunction the group reduce function to apply to the neighboring edges of each vertex._@param direction the edge direction (in-, out-, all-)._@param <T> the output type_@param typeInfo the explicit return type._@return a DataSet containing elements of type T_@throws IllegalArgumentException;public <T> DataSet<T> groupReduceOnEdges(EdgesFunctionWithVertexValue<K, VV, EV, T> edgesFunction,_			EdgeDirection direction, TypeInformation<T> typeInfo) throws IllegalArgumentException {__		switch (direction) {_			case IN:_				return vertices.coGroup(edges).where(0).equalTo(1)_						.with(new ApplyCoGroupFunction<K, VV, EV, T>(edgesFunction)).returns(typeInfo)__			case OUT:_				return vertices.coGroup(edges).where(0).equalTo(0)_						.with(new ApplyCoGroupFunction<K, VV, EV, T>(edgesFunction)).returns(typeInfo)__			case ALL:_				return vertices.coGroup(edges.flatMap(new EmitOneEdgePerNode<K, VV, EV>()))_						.where(0).equalTo(0).with(new ApplyCoGroupFunctionOnAllEdges<K, VV, EV, T>(edgesFunction)).returns(typeInfo)__			default:_				throw new IllegalArgumentException("Illegal edge direction")__		}_	};groups,by,vertex,and,computes,a,group,reduce,transformation,over,the,edge,values,of,each,vertex,the,edges,function,applied,on,the,edges,has,access,to,both,the,id,and,the,value,of,the,grouping,vertex,for,each,vertex,the,edges,function,can,iterate,over,all,edges,of,this,vertex,with,the,specified,direction,and,emit,any,number,of,output,elements,including,none,param,edges,function,the,group,reduce,function,to,apply,to,the,neighboring,edges,of,each,vertex,param,direction,the,edge,direction,in,out,all,param,t,the,output,type,param,type,info,the,explicit,return,type,return,a,data,set,containing,elements,of,type,t,throws,illegal,argument,exception;public,t,data,set,t,group,reduce,on,edges,edges,function,with,vertex,value,k,vv,ev,t,edges,function,edge,direction,direction,type,information,t,type,info,throws,illegal,argument,exception,switch,direction,case,in,return,vertices,co,group,edges,where,0,equal,to,1,with,new,apply,co,group,function,k,vv,ev,t,edges,function,returns,type,info,case,out,return,vertices,co,group,edges,where,0,equal,to,0,with,new,apply,co,group,function,k,vv,ev,t,edges,function,returns,type,info,case,all,return,vertices,co,group,edges,flat,map,new,emit,one,edge,per,node,k,vv,ev,where,0,equal,to,0,with,new,apply,co,group,function,on,all,edges,k,vv,ev,t,edges,function,returns,type,info,default,throw,new,illegal,argument,exception,illegal,edge,direction
Graph -> public <T> DataSet<T> groupReduceOnEdges(EdgesFunctionWithVertexValue<K, VV, EV, T> edgesFunction, 			EdgeDirection direction, TypeInformation<T> typeInfo) throws IllegalArgumentException;1447073368;Groups by vertex and computes a GroupReduce transformation over the edge values of each vertex._The edgesFunction applied on the edges has access to both the id and the value_of the grouping vertex.__For each vertex, the edgesFunction can iterate over all edges of this vertex_with the specified direction, and emit any number of output elements, including none.__@param edgesFunction the group reduce function to apply to the neighboring edges of each vertex._@param direction the edge direction (in-, out-, all-)._@param <T> the output type_@param typeInfo the explicit return type._@return a DataSet containing elements of type T_@throws IllegalArgumentException;public <T> DataSet<T> groupReduceOnEdges(EdgesFunctionWithVertexValue<K, VV, EV, T> edgesFunction,_			EdgeDirection direction, TypeInformation<T> typeInfo) throws IllegalArgumentException {__		switch (direction) {_			case IN:_				return vertices.coGroup(edges).where(0).equalTo(1)_						.with(new ApplyCoGroupFunction<K, VV, EV, T>(edgesFunction)).returns(typeInfo)__			case OUT:_				return vertices.coGroup(edges).where(0).equalTo(0)_						.with(new ApplyCoGroupFunction<K, VV, EV, T>(edgesFunction)).returns(typeInfo)__			case ALL:_				return vertices.coGroup(edges.flatMap(new EmitOneEdgePerNode<K, VV, EV>()))_						.where(0).equalTo(0).with(new ApplyCoGroupFunctionOnAllEdges<K, VV, EV, T>(edgesFunction)).returns(typeInfo)__			default:_				throw new IllegalArgumentException("Illegal edge direction")__		}_	};groups,by,vertex,and,computes,a,group,reduce,transformation,over,the,edge,values,of,each,vertex,the,edges,function,applied,on,the,edges,has,access,to,both,the,id,and,the,value,of,the,grouping,vertex,for,each,vertex,the,edges,function,can,iterate,over,all,edges,of,this,vertex,with,the,specified,direction,and,emit,any,number,of,output,elements,including,none,param,edges,function,the,group,reduce,function,to,apply,to,the,neighboring,edges,of,each,vertex,param,direction,the,edge,direction,in,out,all,param,t,the,output,type,param,type,info,the,explicit,return,type,return,a,data,set,containing,elements,of,type,t,throws,illegal,argument,exception;public,t,data,set,t,group,reduce,on,edges,edges,function,with,vertex,value,k,vv,ev,t,edges,function,edge,direction,direction,type,information,t,type,info,throws,illegal,argument,exception,switch,direction,case,in,return,vertices,co,group,edges,where,0,equal,to,1,with,new,apply,co,group,function,k,vv,ev,t,edges,function,returns,type,info,case,out,return,vertices,co,group,edges,where,0,equal,to,0,with,new,apply,co,group,function,k,vv,ev,t,edges,function,returns,type,info,case,all,return,vertices,co,group,edges,flat,map,new,emit,one,edge,per,node,k,vv,ev,where,0,equal,to,0,with,new,apply,co,group,function,on,all,edges,k,vv,ev,t,edges,function,returns,type,info,default,throw,new,illegal,argument,exception,illegal,edge,direction
Graph -> public <T> DataSet<T> groupReduceOnEdges(EdgesFunctionWithVertexValue<K, VV, EV, T> edgesFunction, 			EdgeDirection direction, TypeInformation<T> typeInfo) throws IllegalArgumentException;1454404649;Groups by vertex and computes a GroupReduce transformation over the edge values of each vertex._The edgesFunction applied on the edges has access to both the id and the value_of the grouping vertex.__For each vertex, the edgesFunction can iterate over all edges of this vertex_with the specified direction, and emit any number of output elements, including none.__@param edgesFunction the group reduce function to apply to the neighboring edges of each vertex._@param direction the edge direction (in-, out-, all-)._@param <T> the output type_@param typeInfo the explicit return type._@return a DataSet containing elements of type T_@throws IllegalArgumentException;public <T> DataSet<T> groupReduceOnEdges(EdgesFunctionWithVertexValue<K, VV, EV, T> edgesFunction,_			EdgeDirection direction, TypeInformation<T> typeInfo) throws IllegalArgumentException {__		switch (direction) {_			case IN:_				return vertices.coGroup(edges).where(0).equalTo(1)_						.with(new ApplyCoGroupFunction<K, VV, EV, T>(edgesFunction)).returns(typeInfo)__			case OUT:_				return vertices.coGroup(edges).where(0).equalTo(0)_						.with(new ApplyCoGroupFunction<K, VV, EV, T>(edgesFunction)).returns(typeInfo)__			case ALL:_				return vertices.coGroup(edges.flatMap(new EmitOneEdgePerNode<K, VV, EV>()))_						.where(0).equalTo(0).with(new ApplyCoGroupFunctionOnAllEdges<K, VV, EV, T>(edgesFunction)).returns(typeInfo)__			default:_				throw new IllegalArgumentException("Illegal edge direction")__		}_	};groups,by,vertex,and,computes,a,group,reduce,transformation,over,the,edge,values,of,each,vertex,the,edges,function,applied,on,the,edges,has,access,to,both,the,id,and,the,value,of,the,grouping,vertex,for,each,vertex,the,edges,function,can,iterate,over,all,edges,of,this,vertex,with,the,specified,direction,and,emit,any,number,of,output,elements,including,none,param,edges,function,the,group,reduce,function,to,apply,to,the,neighboring,edges,of,each,vertex,param,direction,the,edge,direction,in,out,all,param,t,the,output,type,param,type,info,the,explicit,return,type,return,a,data,set,containing,elements,of,type,t,throws,illegal,argument,exception;public,t,data,set,t,group,reduce,on,edges,edges,function,with,vertex,value,k,vv,ev,t,edges,function,edge,direction,direction,type,information,t,type,info,throws,illegal,argument,exception,switch,direction,case,in,return,vertices,co,group,edges,where,0,equal,to,1,with,new,apply,co,group,function,k,vv,ev,t,edges,function,returns,type,info,case,out,return,vertices,co,group,edges,where,0,equal,to,0,with,new,apply,co,group,function,k,vv,ev,t,edges,function,returns,type,info,case,all,return,vertices,co,group,edges,flat,map,new,emit,one,edge,per,node,k,vv,ev,where,0,equal,to,0,with,new,apply,co,group,function,on,all,edges,k,vv,ev,t,edges,function,returns,type,info,default,throw,new,illegal,argument,exception,illegal,edge,direction
Graph -> public <T> DataSet<T> groupReduceOnEdges(EdgesFunctionWithVertexValue<K, VV, EV, T> edgesFunction, 			EdgeDirection direction, TypeInformation<T> typeInfo) throws IllegalArgumentException;1458583829;Groups by vertex and computes a GroupReduce transformation over the edge values of each vertex._The edgesFunction applied on the edges has access to both the id and the value_of the grouping vertex.__For each vertex, the edgesFunction can iterate over all edges of this vertex_with the specified direction, and emit any number of output elements, including none.__@param edgesFunction the group reduce function to apply to the neighboring edges of each vertex._@param direction the edge direction (in-, out-, all-)._@param <T> the output type_@param typeInfo the explicit return type._@return a DataSet containing elements of type T_@throws IllegalArgumentException;public <T> DataSet<T> groupReduceOnEdges(EdgesFunctionWithVertexValue<K, VV, EV, T> edgesFunction,_			EdgeDirection direction, TypeInformation<T> typeInfo) throws IllegalArgumentException {__		switch (direction) {_			case IN:_				return vertices.coGroup(edges).where(0).equalTo(1)_						.with(new ApplyCoGroupFunction<K, VV, EV, T>(edgesFunction)).returns(typeInfo)__			case OUT:_				return vertices.coGroup(edges).where(0).equalTo(0)_						.with(new ApplyCoGroupFunction<K, VV, EV, T>(edgesFunction)).returns(typeInfo)__			case ALL:_				return vertices.coGroup(edges.flatMap(new EmitOneEdgePerNode<K, VV, EV>()))_						.where(0).equalTo(0).with(new ApplyCoGroupFunctionOnAllEdges<K, VV, EV, T>(edgesFunction)).returns(typeInfo)__			default:_				throw new IllegalArgumentException("Illegal edge direction")__		}_	};groups,by,vertex,and,computes,a,group,reduce,transformation,over,the,edge,values,of,each,vertex,the,edges,function,applied,on,the,edges,has,access,to,both,the,id,and,the,value,of,the,grouping,vertex,for,each,vertex,the,edges,function,can,iterate,over,all,edges,of,this,vertex,with,the,specified,direction,and,emit,any,number,of,output,elements,including,none,param,edges,function,the,group,reduce,function,to,apply,to,the,neighboring,edges,of,each,vertex,param,direction,the,edge,direction,in,out,all,param,t,the,output,type,param,type,info,the,explicit,return,type,return,a,data,set,containing,elements,of,type,t,throws,illegal,argument,exception;public,t,data,set,t,group,reduce,on,edges,edges,function,with,vertex,value,k,vv,ev,t,edges,function,edge,direction,direction,type,information,t,type,info,throws,illegal,argument,exception,switch,direction,case,in,return,vertices,co,group,edges,where,0,equal,to,1,with,new,apply,co,group,function,k,vv,ev,t,edges,function,returns,type,info,case,out,return,vertices,co,group,edges,where,0,equal,to,0,with,new,apply,co,group,function,k,vv,ev,t,edges,function,returns,type,info,case,all,return,vertices,co,group,edges,flat,map,new,emit,one,edge,per,node,k,vv,ev,where,0,equal,to,0,with,new,apply,co,group,function,on,all,edges,k,vv,ev,t,edges,function,returns,type,info,default,throw,new,illegal,argument,exception,illegal,edge,direction
Graph -> public <T> DataSet<T> groupReduceOnEdges(EdgesFunctionWithVertexValue<K, VV, EV, T> edgesFunction, 			EdgeDirection direction, TypeInformation<T> typeInfo) throws IllegalArgumentException;1458583829;Groups by vertex and computes a GroupReduce transformation over the edge values of each vertex._The edgesFunction applied on the edges has access to both the id and the value_of the grouping vertex.__For each vertex, the edgesFunction can iterate over all edges of this vertex_with the specified direction, and emit any number of output elements, including none.__@param edgesFunction the group reduce function to apply to the neighboring edges of each vertex._@param direction the edge direction (in-, out-, all-)._@param <T> the output type_@param typeInfo the explicit return type._@return a DataSet containing elements of type T_@throws IllegalArgumentException;public <T> DataSet<T> groupReduceOnEdges(EdgesFunctionWithVertexValue<K, VV, EV, T> edgesFunction,_			EdgeDirection direction, TypeInformation<T> typeInfo) throws IllegalArgumentException {__		switch (direction) {_			case IN:_				return vertices.coGroup(edges).where(0).equalTo(1)_						.with(new ApplyCoGroupFunction<K, VV, EV, T>(edgesFunction)).returns(typeInfo)__			case OUT:_				return vertices.coGroup(edges).where(0).equalTo(0)_						.with(new ApplyCoGroupFunction<K, VV, EV, T>(edgesFunction)).returns(typeInfo)__			case ALL:_				return vertices.coGroup(edges.flatMap(new EmitOneEdgePerNode<K, VV, EV>()))_						.where(0).equalTo(0).with(new ApplyCoGroupFunctionOnAllEdges<K, VV, EV, T>(edgesFunction)).returns(typeInfo)__			default:_				throw new IllegalArgumentException("Illegal edge direction")__		}_	};groups,by,vertex,and,computes,a,group,reduce,transformation,over,the,edge,values,of,each,vertex,the,edges,function,applied,on,the,edges,has,access,to,both,the,id,and,the,value,of,the,grouping,vertex,for,each,vertex,the,edges,function,can,iterate,over,all,edges,of,this,vertex,with,the,specified,direction,and,emit,any,number,of,output,elements,including,none,param,edges,function,the,group,reduce,function,to,apply,to,the,neighboring,edges,of,each,vertex,param,direction,the,edge,direction,in,out,all,param,t,the,output,type,param,type,info,the,explicit,return,type,return,a,data,set,containing,elements,of,type,t,throws,illegal,argument,exception;public,t,data,set,t,group,reduce,on,edges,edges,function,with,vertex,value,k,vv,ev,t,edges,function,edge,direction,direction,type,information,t,type,info,throws,illegal,argument,exception,switch,direction,case,in,return,vertices,co,group,edges,where,0,equal,to,1,with,new,apply,co,group,function,k,vv,ev,t,edges,function,returns,type,info,case,out,return,vertices,co,group,edges,where,0,equal,to,0,with,new,apply,co,group,function,k,vv,ev,t,edges,function,returns,type,info,case,all,return,vertices,co,group,edges,flat,map,new,emit,one,edge,per,node,k,vv,ev,where,0,equal,to,0,with,new,apply,co,group,function,on,all,edges,k,vv,ev,t,edges,function,returns,type,info,default,throw,new,illegal,argument,exception,illegal,edge,direction
Graph -> public <T> DataSet<T> groupReduceOnEdges(EdgesFunctionWithVertexValue<K, VV, EV, T> edgesFunction, 			EdgeDirection direction, TypeInformation<T> typeInfo) throws IllegalArgumentException;1462100316;Groups by vertex and computes a GroupReduce transformation over the edge values of each vertex._The edgesFunction applied on the edges has access to both the id and the value_of the grouping vertex.__For each vertex, the edgesFunction can iterate over all edges of this vertex_with the specified direction, and emit any number of output elements, including none.__@param edgesFunction the group reduce function to apply to the neighboring edges of each vertex._@param direction the edge direction (in-, out-, all-)._@param <T> the output type_@param typeInfo the explicit return type._@return a DataSet containing elements of type T_@throws IllegalArgumentException;public <T> DataSet<T> groupReduceOnEdges(EdgesFunctionWithVertexValue<K, VV, EV, T> edgesFunction,_			EdgeDirection direction, TypeInformation<T> typeInfo) throws IllegalArgumentException {__		switch (direction) {_			case IN:_				return vertices.coGroup(edges).where(0).equalTo(1)_						.with(new ApplyCoGroupFunction<K, VV, EV, T>(edgesFunction)).returns(typeInfo)__			case OUT:_				return vertices.coGroup(edges).where(0).equalTo(0)_						.with(new ApplyCoGroupFunction<K, VV, EV, T>(edgesFunction)).returns(typeInfo)__			case ALL:_				return vertices.coGroup(edges.flatMap(new EmitOneEdgePerNode<K, VV, EV>()))_						.where(0).equalTo(0).with(new ApplyCoGroupFunctionOnAllEdges<K, VV, EV, T>(edgesFunction)).returns(typeInfo)__			default:_				throw new IllegalArgumentException("Illegal edge direction")__		}_	};groups,by,vertex,and,computes,a,group,reduce,transformation,over,the,edge,values,of,each,vertex,the,edges,function,applied,on,the,edges,has,access,to,both,the,id,and,the,value,of,the,grouping,vertex,for,each,vertex,the,edges,function,can,iterate,over,all,edges,of,this,vertex,with,the,specified,direction,and,emit,any,number,of,output,elements,including,none,param,edges,function,the,group,reduce,function,to,apply,to,the,neighboring,edges,of,each,vertex,param,direction,the,edge,direction,in,out,all,param,t,the,output,type,param,type,info,the,explicit,return,type,return,a,data,set,containing,elements,of,type,t,throws,illegal,argument,exception;public,t,data,set,t,group,reduce,on,edges,edges,function,with,vertex,value,k,vv,ev,t,edges,function,edge,direction,direction,type,information,t,type,info,throws,illegal,argument,exception,switch,direction,case,in,return,vertices,co,group,edges,where,0,equal,to,1,with,new,apply,co,group,function,k,vv,ev,t,edges,function,returns,type,info,case,out,return,vertices,co,group,edges,where,0,equal,to,0,with,new,apply,co,group,function,k,vv,ev,t,edges,function,returns,type,info,case,all,return,vertices,co,group,edges,flat,map,new,emit,one,edge,per,node,k,vv,ev,where,0,equal,to,0,with,new,apply,co,group,function,on,all,edges,k,vv,ev,t,edges,function,returns,type,info,default,throw,new,illegal,argument,exception,illegal,edge,direction
Graph -> public <T> DataSet<T> groupReduceOnEdges(EdgesFunctionWithVertexValue<K, VV, EV, T> edgesFunction, 			EdgeDirection direction, TypeInformation<T> typeInfo) throws IllegalArgumentException;1462100316;Groups by vertex and computes a GroupReduce transformation over the edge values of each vertex._The edgesFunction applied on the edges has access to both the id and the value_of the grouping vertex.__For each vertex, the edgesFunction can iterate over all edges of this vertex_with the specified direction, and emit any number of output elements, including none.__@param edgesFunction the group reduce function to apply to the neighboring edges of each vertex._@param direction the edge direction (in-, out-, all-)._@param <T> the output type_@param typeInfo the explicit return type._@return a DataSet containing elements of type T_@throws IllegalArgumentException;public <T> DataSet<T> groupReduceOnEdges(EdgesFunctionWithVertexValue<K, VV, EV, T> edgesFunction,_			EdgeDirection direction, TypeInformation<T> typeInfo) throws IllegalArgumentException {__		switch (direction) {_			case IN:_				return vertices.coGroup(edges).where(0).equalTo(1)_						.with(new ApplyCoGroupFunction<K, VV, EV, T>(edgesFunction)).returns(typeInfo)__			case OUT:_				return vertices.coGroup(edges).where(0).equalTo(0)_						.with(new ApplyCoGroupFunction<K, VV, EV, T>(edgesFunction)).returns(typeInfo)__			case ALL:_				return vertices.coGroup(edges.flatMap(new EmitOneEdgePerNode<K, VV, EV>()))_						.where(0).equalTo(0).with(new ApplyCoGroupFunctionOnAllEdges<K, VV, EV, T>(edgesFunction)).returns(typeInfo)__			default:_				throw new IllegalArgumentException("Illegal edge direction")__		}_	};groups,by,vertex,and,computes,a,group,reduce,transformation,over,the,edge,values,of,each,vertex,the,edges,function,applied,on,the,edges,has,access,to,both,the,id,and,the,value,of,the,grouping,vertex,for,each,vertex,the,edges,function,can,iterate,over,all,edges,of,this,vertex,with,the,specified,direction,and,emit,any,number,of,output,elements,including,none,param,edges,function,the,group,reduce,function,to,apply,to,the,neighboring,edges,of,each,vertex,param,direction,the,edge,direction,in,out,all,param,t,the,output,type,param,type,info,the,explicit,return,type,return,a,data,set,containing,elements,of,type,t,throws,illegal,argument,exception;public,t,data,set,t,group,reduce,on,edges,edges,function,with,vertex,value,k,vv,ev,t,edges,function,edge,direction,direction,type,information,t,type,info,throws,illegal,argument,exception,switch,direction,case,in,return,vertices,co,group,edges,where,0,equal,to,1,with,new,apply,co,group,function,k,vv,ev,t,edges,function,returns,type,info,case,out,return,vertices,co,group,edges,where,0,equal,to,0,with,new,apply,co,group,function,k,vv,ev,t,edges,function,returns,type,info,case,all,return,vertices,co,group,edges,flat,map,new,emit,one,edge,per,node,k,vv,ev,where,0,equal,to,0,with,new,apply,co,group,function,on,all,edges,k,vv,ev,t,edges,function,returns,type,info,default,throw,new,illegal,argument,exception,illegal,edge,direction
Graph -> public <T> DataSet<T> groupReduceOnEdges(EdgesFunctionWithVertexValue<K, VV, EV, T> edgesFunction, 			EdgeDirection direction, TypeInformation<T> typeInfo) throws IllegalArgumentException;1462205213;Groups by vertex and computes a GroupReduce transformation over the edge values of each vertex._The edgesFunction applied on the edges has access to both the id and the value_of the grouping vertex.__For each vertex, the edgesFunction can iterate over all edges of this vertex_with the specified direction, and emit any number of output elements, including none.__@param edgesFunction the group reduce function to apply to the neighboring edges of each vertex._@param direction the edge direction (in-, out-, all-)._@param <T> the output type_@param typeInfo the explicit return type._@return a DataSet containing elements of type T_@throws IllegalArgumentException;public <T> DataSet<T> groupReduceOnEdges(EdgesFunctionWithVertexValue<K, VV, EV, T> edgesFunction,_			EdgeDirection direction, TypeInformation<T> typeInfo) throws IllegalArgumentException {__		switch (direction) {_			case IN:_				return vertices.coGroup(edges).where(0).equalTo(1)_						.with(new ApplyCoGroupFunction<K, VV, EV, T>(edgesFunction)).returns(typeInfo)__			case OUT:_				return vertices.coGroup(edges).where(0).equalTo(0)_						.with(new ApplyCoGroupFunction<K, VV, EV, T>(edgesFunction)).returns(typeInfo)__			case ALL:_				return vertices.coGroup(edges.flatMap(new EmitOneEdgePerNode<K, VV, EV>()))_						.where(0).equalTo(0).with(new ApplyCoGroupFunctionOnAllEdges<K, VV, EV, T>(edgesFunction)).returns(typeInfo)__			default:_				throw new IllegalArgumentException("Illegal edge direction")__		}_	};groups,by,vertex,and,computes,a,group,reduce,transformation,over,the,edge,values,of,each,vertex,the,edges,function,applied,on,the,edges,has,access,to,both,the,id,and,the,value,of,the,grouping,vertex,for,each,vertex,the,edges,function,can,iterate,over,all,edges,of,this,vertex,with,the,specified,direction,and,emit,any,number,of,output,elements,including,none,param,edges,function,the,group,reduce,function,to,apply,to,the,neighboring,edges,of,each,vertex,param,direction,the,edge,direction,in,out,all,param,t,the,output,type,param,type,info,the,explicit,return,type,return,a,data,set,containing,elements,of,type,t,throws,illegal,argument,exception;public,t,data,set,t,group,reduce,on,edges,edges,function,with,vertex,value,k,vv,ev,t,edges,function,edge,direction,direction,type,information,t,type,info,throws,illegal,argument,exception,switch,direction,case,in,return,vertices,co,group,edges,where,0,equal,to,1,with,new,apply,co,group,function,k,vv,ev,t,edges,function,returns,type,info,case,out,return,vertices,co,group,edges,where,0,equal,to,0,with,new,apply,co,group,function,k,vv,ev,t,edges,function,returns,type,info,case,all,return,vertices,co,group,edges,flat,map,new,emit,one,edge,per,node,k,vv,ev,where,0,equal,to,0,with,new,apply,co,group,function,on,all,edges,k,vv,ev,t,edges,function,returns,type,info,default,throw,new,illegal,argument,exception,illegal,edge,direction
Graph -> public <T> DataSet<T> groupReduceOnEdges(EdgesFunctionWithVertexValue<K, VV, EV, T> edgesFunction, 			EdgeDirection direction, TypeInformation<T> typeInfo) throws IllegalArgumentException;1462208859;Groups by vertex and computes a GroupReduce transformation over the edge values of each vertex._The edgesFunction applied on the edges has access to both the id and the value_of the grouping vertex.__For each vertex, the edgesFunction can iterate over all edges of this vertex_with the specified direction, and emit any number of output elements, including none.__@param edgesFunction the group reduce function to apply to the neighboring edges of each vertex._@param direction the edge direction (in-, out-, all-)._@param <T> the output type_@param typeInfo the explicit return type._@return a DataSet containing elements of type T_@throws IllegalArgumentException;public <T> DataSet<T> groupReduceOnEdges(EdgesFunctionWithVertexValue<K, VV, EV, T> edgesFunction,_			EdgeDirection direction, TypeInformation<T> typeInfo) throws IllegalArgumentException {__		switch (direction) {_			case IN:_				return vertices.coGroup(edges).where(0).equalTo(1)_						.with(new ApplyCoGroupFunction<K, VV, EV, T>(edgesFunction)).returns(typeInfo)__			case OUT:_				return vertices.coGroup(edges).where(0).equalTo(0)_						.with(new ApplyCoGroupFunction<K, VV, EV, T>(edgesFunction)).returns(typeInfo)__			case ALL:_				return vertices.coGroup(edges.flatMap(new EmitOneEdgePerNode<K, VV, EV>()))_						.where(0).equalTo(0).with(new ApplyCoGroupFunctionOnAllEdges<K, VV, EV, T>(edgesFunction)).returns(typeInfo)__			default:_				throw new IllegalArgumentException("Illegal edge direction")__		}_	};groups,by,vertex,and,computes,a,group,reduce,transformation,over,the,edge,values,of,each,vertex,the,edges,function,applied,on,the,edges,has,access,to,both,the,id,and,the,value,of,the,grouping,vertex,for,each,vertex,the,edges,function,can,iterate,over,all,edges,of,this,vertex,with,the,specified,direction,and,emit,any,number,of,output,elements,including,none,param,edges,function,the,group,reduce,function,to,apply,to,the,neighboring,edges,of,each,vertex,param,direction,the,edge,direction,in,out,all,param,t,the,output,type,param,type,info,the,explicit,return,type,return,a,data,set,containing,elements,of,type,t,throws,illegal,argument,exception;public,t,data,set,t,group,reduce,on,edges,edges,function,with,vertex,value,k,vv,ev,t,edges,function,edge,direction,direction,type,information,t,type,info,throws,illegal,argument,exception,switch,direction,case,in,return,vertices,co,group,edges,where,0,equal,to,1,with,new,apply,co,group,function,k,vv,ev,t,edges,function,returns,type,info,case,out,return,vertices,co,group,edges,where,0,equal,to,0,with,new,apply,co,group,function,k,vv,ev,t,edges,function,returns,type,info,case,all,return,vertices,co,group,edges,flat,map,new,emit,one,edge,per,node,k,vv,ev,where,0,equal,to,0,with,new,apply,co,group,function,on,all,edges,k,vv,ev,t,edges,function,returns,type,info,default,throw,new,illegal,argument,exception,illegal,edge,direction
Graph -> public <T> DataSet<T> groupReduceOnEdges(EdgesFunctionWithVertexValue<K, VV, EV, T> edgesFunction, 			EdgeDirection direction, TypeInformation<T> typeInfo) throws IllegalArgumentException;1462809297;Groups by vertex and computes a GroupReduce transformation over the edge values of each vertex._The edgesFunction applied on the edges has access to both the id and the value_of the grouping vertex.__For each vertex, the edgesFunction can iterate over all edges of this vertex_with the specified direction, and emit any number of output elements, including none.__@param edgesFunction the group reduce function to apply to the neighboring edges of each vertex._@param direction the edge direction (in-, out-, all-)._@param <T> the output type_@param typeInfo the explicit return type._@return a DataSet containing elements of type T_@throws IllegalArgumentException;public <T> DataSet<T> groupReduceOnEdges(EdgesFunctionWithVertexValue<K, VV, EV, T> edgesFunction,_			EdgeDirection direction, TypeInformation<T> typeInfo) throws IllegalArgumentException {__		switch (direction) {_			case IN:_				return vertices.coGroup(edges).where(0).equalTo(1)_						.with(new ApplyCoGroupFunction<K, VV, EV, T>(edgesFunction)).returns(typeInfo)__			case OUT:_				return vertices.coGroup(edges).where(0).equalTo(0)_						.with(new ApplyCoGroupFunction<K, VV, EV, T>(edgesFunction)).returns(typeInfo)__			case ALL:_				return vertices.coGroup(edges.flatMap(new EmitOneEdgePerNode<K, VV, EV>()))_						.where(0).equalTo(0).with(new ApplyCoGroupFunctionOnAllEdges<K, VV, EV, T>(edgesFunction)).returns(typeInfo)__			default:_				throw new IllegalArgumentException("Illegal edge direction")__		}_	};groups,by,vertex,and,computes,a,group,reduce,transformation,over,the,edge,values,of,each,vertex,the,edges,function,applied,on,the,edges,has,access,to,both,the,id,and,the,value,of,the,grouping,vertex,for,each,vertex,the,edges,function,can,iterate,over,all,edges,of,this,vertex,with,the,specified,direction,and,emit,any,number,of,output,elements,including,none,param,edges,function,the,group,reduce,function,to,apply,to,the,neighboring,edges,of,each,vertex,param,direction,the,edge,direction,in,out,all,param,t,the,output,type,param,type,info,the,explicit,return,type,return,a,data,set,containing,elements,of,type,t,throws,illegal,argument,exception;public,t,data,set,t,group,reduce,on,edges,edges,function,with,vertex,value,k,vv,ev,t,edges,function,edge,direction,direction,type,information,t,type,info,throws,illegal,argument,exception,switch,direction,case,in,return,vertices,co,group,edges,where,0,equal,to,1,with,new,apply,co,group,function,k,vv,ev,t,edges,function,returns,type,info,case,out,return,vertices,co,group,edges,where,0,equal,to,0,with,new,apply,co,group,function,k,vv,ev,t,edges,function,returns,type,info,case,all,return,vertices,co,group,edges,flat,map,new,emit,one,edge,per,node,k,vv,ev,where,0,equal,to,0,with,new,apply,co,group,function,on,all,edges,k,vv,ev,t,edges,function,returns,type,info,default,throw,new,illegal,argument,exception,illegal,edge,direction
Graph -> public <T> DataSet<T> groupReduceOnEdges(EdgesFunctionWithVertexValue<K, VV, EV, T> edgesFunction, 			EdgeDirection direction, TypeInformation<T> typeInfo) throws IllegalArgumentException;1465316775;Groups by vertex and computes a GroupReduce transformation over the edge values of each vertex._The edgesFunction applied on the edges has access to both the id and the value_of the grouping vertex.__For each vertex, the edgesFunction can iterate over all edges of this vertex_with the specified direction, and emit any number of output elements, including none.__@param edgesFunction the group reduce function to apply to the neighboring edges of each vertex._@param direction the edge direction (in-, out-, all-)._@param <T> the output type_@param typeInfo the explicit return type._@return a DataSet containing elements of type T_@throws IllegalArgumentException;public <T> DataSet<T> groupReduceOnEdges(EdgesFunctionWithVertexValue<K, VV, EV, T> edgesFunction,_			EdgeDirection direction, TypeInformation<T> typeInfo) throws IllegalArgumentException {__		switch (direction) {_			case IN:_				return vertices.coGroup(edges).where(0).equalTo(1)_						.with(new ApplyCoGroupFunction<K, VV, EV, T>(edgesFunction)).returns(typeInfo)__			case OUT:_				return vertices.coGroup(edges).where(0).equalTo(0)_						.with(new ApplyCoGroupFunction<K, VV, EV, T>(edgesFunction)).returns(typeInfo)__			case ALL:_				return vertices.coGroup(edges.flatMap(new EmitOneEdgePerNode<K, VV, EV>()))_						.where(0).equalTo(0).with(new ApplyCoGroupFunctionOnAllEdges<K, VV, EV, T>(edgesFunction)).returns(typeInfo)__			default:_				throw new IllegalArgumentException("Illegal edge direction")__		}_	};groups,by,vertex,and,computes,a,group,reduce,transformation,over,the,edge,values,of,each,vertex,the,edges,function,applied,on,the,edges,has,access,to,both,the,id,and,the,value,of,the,grouping,vertex,for,each,vertex,the,edges,function,can,iterate,over,all,edges,of,this,vertex,with,the,specified,direction,and,emit,any,number,of,output,elements,including,none,param,edges,function,the,group,reduce,function,to,apply,to,the,neighboring,edges,of,each,vertex,param,direction,the,edge,direction,in,out,all,param,t,the,output,type,param,type,info,the,explicit,return,type,return,a,data,set,containing,elements,of,type,t,throws,illegal,argument,exception;public,t,data,set,t,group,reduce,on,edges,edges,function,with,vertex,value,k,vv,ev,t,edges,function,edge,direction,direction,type,information,t,type,info,throws,illegal,argument,exception,switch,direction,case,in,return,vertices,co,group,edges,where,0,equal,to,1,with,new,apply,co,group,function,k,vv,ev,t,edges,function,returns,type,info,case,out,return,vertices,co,group,edges,where,0,equal,to,0,with,new,apply,co,group,function,k,vv,ev,t,edges,function,returns,type,info,case,all,return,vertices,co,group,edges,flat,map,new,emit,one,edge,per,node,k,vv,ev,where,0,equal,to,0,with,new,apply,co,group,function,on,all,edges,k,vv,ev,t,edges,function,returns,type,info,default,throw,new,illegal,argument,exception,illegal,edge,direction
Graph -> public <T> DataSet<T> groupReduceOnEdges(EdgesFunctionWithVertexValue<K, VV, EV, T> edgesFunction, 			EdgeDirection direction, TypeInformation<T> typeInfo) throws IllegalArgumentException;1466789678;Groups by vertex and computes a GroupReduce transformation over the edge values of each vertex._The edgesFunction applied on the edges has access to both the id and the value_of the grouping vertex.__For each vertex, the edgesFunction can iterate over all edges of this vertex_with the specified direction, and emit any number of output elements, including none.__@param edgesFunction the group reduce function to apply to the neighboring edges of each vertex._@param direction the edge direction (in-, out-, all-)._@param <T> the output type_@param typeInfo the explicit return type._@return a DataSet containing elements of type T_@throws IllegalArgumentException;public <T> DataSet<T> groupReduceOnEdges(EdgesFunctionWithVertexValue<K, VV, EV, T> edgesFunction,_			EdgeDirection direction, TypeInformation<T> typeInfo) throws IllegalArgumentException {__		switch (direction) {_			case IN:_				return vertices.coGroup(edges).where(0).equalTo(1)_						.with(new ApplyCoGroupFunction<K, VV, EV, T>(edgesFunction)).returns(typeInfo)__			case OUT:_				return vertices.coGroup(edges).where(0).equalTo(0)_						.with(new ApplyCoGroupFunction<K, VV, EV, T>(edgesFunction)).returns(typeInfo)__			case ALL:_				return vertices.coGroup(edges.flatMap(new EmitOneEdgePerNode<K, VV, EV>()))_						.where(0).equalTo(0).with(new ApplyCoGroupFunctionOnAllEdges<K, VV, EV, T>(edgesFunction)).returns(typeInfo)__			default:_				throw new IllegalArgumentException("Illegal edge direction")__		}_	};groups,by,vertex,and,computes,a,group,reduce,transformation,over,the,edge,values,of,each,vertex,the,edges,function,applied,on,the,edges,has,access,to,both,the,id,and,the,value,of,the,grouping,vertex,for,each,vertex,the,edges,function,can,iterate,over,all,edges,of,this,vertex,with,the,specified,direction,and,emit,any,number,of,output,elements,including,none,param,edges,function,the,group,reduce,function,to,apply,to,the,neighboring,edges,of,each,vertex,param,direction,the,edge,direction,in,out,all,param,t,the,output,type,param,type,info,the,explicit,return,type,return,a,data,set,containing,elements,of,type,t,throws,illegal,argument,exception;public,t,data,set,t,group,reduce,on,edges,edges,function,with,vertex,value,k,vv,ev,t,edges,function,edge,direction,direction,type,information,t,type,info,throws,illegal,argument,exception,switch,direction,case,in,return,vertices,co,group,edges,where,0,equal,to,1,with,new,apply,co,group,function,k,vv,ev,t,edges,function,returns,type,info,case,out,return,vertices,co,group,edges,where,0,equal,to,0,with,new,apply,co,group,function,k,vv,ev,t,edges,function,returns,type,info,case,all,return,vertices,co,group,edges,flat,map,new,emit,one,edge,per,node,k,vv,ev,where,0,equal,to,0,with,new,apply,co,group,function,on,all,edges,k,vv,ev,t,edges,function,returns,type,info,default,throw,new,illegal,argument,exception,illegal,edge,direction
Graph -> public <T> DataSet<T> groupReduceOnEdges(EdgesFunctionWithVertexValue<K, VV, EV, T> edgesFunction, 			EdgeDirection direction, TypeInformation<T> typeInfo) throws IllegalArgumentException;1467140656;Groups by vertex and computes a GroupReduce transformation over the edge values of each vertex._The edgesFunction applied on the edges has access to both the id and the value_of the grouping vertex.__For each vertex, the edgesFunction can iterate over all edges of this vertex_with the specified direction, and emit any number of output elements, including none.__@param edgesFunction the group reduce function to apply to the neighboring edges of each vertex._@param direction the edge direction (in-, out-, all-)._@param <T> the output type_@param typeInfo the explicit return type._@return a DataSet containing elements of type T_@throws IllegalArgumentException;public <T> DataSet<T> groupReduceOnEdges(EdgesFunctionWithVertexValue<K, VV, EV, T> edgesFunction,_			EdgeDirection direction, TypeInformation<T> typeInfo) throws IllegalArgumentException {__		switch (direction) {_			case IN:_				return vertices.coGroup(edges).where(0).equalTo(1)_						.with(new ApplyCoGroupFunction<K, VV, EV, T>(edgesFunction)).returns(typeInfo)__			case OUT:_				return vertices.coGroup(edges).where(0).equalTo(0)_						.with(new ApplyCoGroupFunction<K, VV, EV, T>(edgesFunction)).returns(typeInfo)__			case ALL:_				return vertices.coGroup(edges.flatMap(new EmitOneEdgePerNode<K, VV, EV>()))_						.where(0).equalTo(0).with(new ApplyCoGroupFunctionOnAllEdges<K, VV, EV, T>(edgesFunction)).returns(typeInfo)__			default:_				throw new IllegalArgumentException("Illegal edge direction")__		}_	};groups,by,vertex,and,computes,a,group,reduce,transformation,over,the,edge,values,of,each,vertex,the,edges,function,applied,on,the,edges,has,access,to,both,the,id,and,the,value,of,the,grouping,vertex,for,each,vertex,the,edges,function,can,iterate,over,all,edges,of,this,vertex,with,the,specified,direction,and,emit,any,number,of,output,elements,including,none,param,edges,function,the,group,reduce,function,to,apply,to,the,neighboring,edges,of,each,vertex,param,direction,the,edge,direction,in,out,all,param,t,the,output,type,param,type,info,the,explicit,return,type,return,a,data,set,containing,elements,of,type,t,throws,illegal,argument,exception;public,t,data,set,t,group,reduce,on,edges,edges,function,with,vertex,value,k,vv,ev,t,edges,function,edge,direction,direction,type,information,t,type,info,throws,illegal,argument,exception,switch,direction,case,in,return,vertices,co,group,edges,where,0,equal,to,1,with,new,apply,co,group,function,k,vv,ev,t,edges,function,returns,type,info,case,out,return,vertices,co,group,edges,where,0,equal,to,0,with,new,apply,co,group,function,k,vv,ev,t,edges,function,returns,type,info,case,all,return,vertices,co,group,edges,flat,map,new,emit,one,edge,per,node,k,vv,ev,where,0,equal,to,0,with,new,apply,co,group,function,on,all,edges,k,vv,ev,t,edges,function,returns,type,info,default,throw,new,illegal,argument,exception,illegal,edge,direction
Graph -> public <T> DataSet<T> groupReduceOnEdges(EdgesFunctionWithVertexValue<K, VV, EV, T> edgesFunction, 			EdgeDirection direction, TypeInformation<T> typeInfo) throws IllegalArgumentException;1467306272;Groups by vertex and computes a GroupReduce transformation over the edge values of each vertex._The edgesFunction applied on the edges has access to both the id and the value_of the grouping vertex.__For each vertex, the edgesFunction can iterate over all edges of this vertex_with the specified direction, and emit any number of output elements, including none.__@param edgesFunction the group reduce function to apply to the neighboring edges of each vertex._@param direction the edge direction (in-, out-, all-)._@param <T> the output type_@param typeInfo the explicit return type._@return a DataSet containing elements of type T_@throws IllegalArgumentException;public <T> DataSet<T> groupReduceOnEdges(EdgesFunctionWithVertexValue<K, VV, EV, T> edgesFunction,_			EdgeDirection direction, TypeInformation<T> typeInfo) throws IllegalArgumentException {__		switch (direction) {_			case IN:_				return vertices.coGroup(edges).where(0).equalTo(1)_						.with(new ApplyCoGroupFunction<K, VV, EV, T>(edgesFunction)).returns(typeInfo)__			case OUT:_				return vertices.coGroup(edges).where(0).equalTo(0)_						.with(new ApplyCoGroupFunction<K, VV, EV, T>(edgesFunction)).returns(typeInfo)__			case ALL:_				return vertices.coGroup(edges.flatMap(new EmitOneEdgePerNode<K, VV, EV>()))_						.where(0).equalTo(0).with(new ApplyCoGroupFunctionOnAllEdges<K, VV, EV, T>(edgesFunction)).returns(typeInfo)__			default:_				throw new IllegalArgumentException("Illegal edge direction")__		}_	};groups,by,vertex,and,computes,a,group,reduce,transformation,over,the,edge,values,of,each,vertex,the,edges,function,applied,on,the,edges,has,access,to,both,the,id,and,the,value,of,the,grouping,vertex,for,each,vertex,the,edges,function,can,iterate,over,all,edges,of,this,vertex,with,the,specified,direction,and,emit,any,number,of,output,elements,including,none,param,edges,function,the,group,reduce,function,to,apply,to,the,neighboring,edges,of,each,vertex,param,direction,the,edge,direction,in,out,all,param,t,the,output,type,param,type,info,the,explicit,return,type,return,a,data,set,containing,elements,of,type,t,throws,illegal,argument,exception;public,t,data,set,t,group,reduce,on,edges,edges,function,with,vertex,value,k,vv,ev,t,edges,function,edge,direction,direction,type,information,t,type,info,throws,illegal,argument,exception,switch,direction,case,in,return,vertices,co,group,edges,where,0,equal,to,1,with,new,apply,co,group,function,k,vv,ev,t,edges,function,returns,type,info,case,out,return,vertices,co,group,edges,where,0,equal,to,0,with,new,apply,co,group,function,k,vv,ev,t,edges,function,returns,type,info,case,all,return,vertices,co,group,edges,flat,map,new,emit,one,edge,per,node,k,vv,ev,where,0,equal,to,0,with,new,apply,co,group,function,on,all,edges,k,vv,ev,t,edges,function,returns,type,info,default,throw,new,illegal,argument,exception,illegal,edge,direction
Graph -> public <T> DataSet<T> groupReduceOnEdges(EdgesFunctionWithVertexValue<K, VV, EV, T> edgesFunction, 			EdgeDirection direction, TypeInformation<T> typeInfo) throws IllegalArgumentException;1470042815;Groups by vertex and computes a GroupReduce transformation over the edge values of each vertex._The edgesFunction applied on the edges has access to both the id and the value_of the grouping vertex.__For each vertex, the edgesFunction can iterate over all edges of this vertex_with the specified direction, and emit any number of output elements, including none.__@param edgesFunction the group reduce function to apply to the neighboring edges of each vertex._@param direction the edge direction (in-, out-, all-)._@param <T> the output type_@param typeInfo the explicit return type._@return a DataSet containing elements of type T_@throws IllegalArgumentException;public <T> DataSet<T> groupReduceOnEdges(EdgesFunctionWithVertexValue<K, VV, EV, T> edgesFunction,_			EdgeDirection direction, TypeInformation<T> typeInfo) throws IllegalArgumentException {__		switch (direction) {_			case IN:_				return vertices.coGroup(edges).where(0).equalTo(1)_						.with(new ApplyCoGroupFunction<K, VV, EV, T>(edgesFunction)).returns(typeInfo)__			case OUT:_				return vertices.coGroup(edges).where(0).equalTo(0)_						.with(new ApplyCoGroupFunction<K, VV, EV, T>(edgesFunction)).returns(typeInfo)__			case ALL:_				return vertices.coGroup(edges.flatMap(new EmitOneEdgePerNode<K, VV, EV>()))_						.where(0).equalTo(0).with(new ApplyCoGroupFunctionOnAllEdges<K, VV, EV, T>(edgesFunction)).returns(typeInfo)__			default:_				throw new IllegalArgumentException("Illegal edge direction")__		}_	};groups,by,vertex,and,computes,a,group,reduce,transformation,over,the,edge,values,of,each,vertex,the,edges,function,applied,on,the,edges,has,access,to,both,the,id,and,the,value,of,the,grouping,vertex,for,each,vertex,the,edges,function,can,iterate,over,all,edges,of,this,vertex,with,the,specified,direction,and,emit,any,number,of,output,elements,including,none,param,edges,function,the,group,reduce,function,to,apply,to,the,neighboring,edges,of,each,vertex,param,direction,the,edge,direction,in,out,all,param,t,the,output,type,param,type,info,the,explicit,return,type,return,a,data,set,containing,elements,of,type,t,throws,illegal,argument,exception;public,t,data,set,t,group,reduce,on,edges,edges,function,with,vertex,value,k,vv,ev,t,edges,function,edge,direction,direction,type,information,t,type,info,throws,illegal,argument,exception,switch,direction,case,in,return,vertices,co,group,edges,where,0,equal,to,1,with,new,apply,co,group,function,k,vv,ev,t,edges,function,returns,type,info,case,out,return,vertices,co,group,edges,where,0,equal,to,0,with,new,apply,co,group,function,k,vv,ev,t,edges,function,returns,type,info,case,all,return,vertices,co,group,edges,flat,map,new,emit,one,edge,per,node,k,vv,ev,where,0,equal,to,0,with,new,apply,co,group,function,on,all,edges,k,vv,ev,t,edges,function,returns,type,info,default,throw,new,illegal,argument,exception,illegal,edge,direction
Graph -> public <T> DataSet<T> groupReduceOnEdges(EdgesFunctionWithVertexValue<K, VV, EV, T> edgesFunction, 			EdgeDirection direction, TypeInformation<T> typeInfo) throws IllegalArgumentException;1475684776;Groups by vertex and computes a GroupReduce transformation over the edge values of each vertex._The edgesFunction applied on the edges has access to both the id and the value_of the grouping vertex.__For each vertex, the edgesFunction can iterate over all edges of this vertex_with the specified direction, and emit any number of output elements, including none.__@param edgesFunction the group reduce function to apply to the neighboring edges of each vertex._@param direction the edge direction (in-, out-, all-)._@param <T> the output type_@param typeInfo the explicit return type._@return a DataSet containing elements of type T_@throws IllegalArgumentException;public <T> DataSet<T> groupReduceOnEdges(EdgesFunctionWithVertexValue<K, VV, EV, T> edgesFunction,_			EdgeDirection direction, TypeInformation<T> typeInfo) throws IllegalArgumentException {__		switch (direction) {_			case IN:_				return vertices.coGroup(edges).where(0).equalTo(1)_						.with(new ApplyCoGroupFunction<>(edgesFunction)).returns(typeInfo)__			case OUT:_				return vertices.coGroup(edges).where(0).equalTo(0)_						.with(new ApplyCoGroupFunction<>(edgesFunction)).returns(typeInfo)__			case ALL:_				return vertices.coGroup(edges.flatMap(new EmitOneEdgePerNode<K, VV, EV>()))_						.where(0).equalTo(0).with(new ApplyCoGroupFunctionOnAllEdges<>(edgesFunction)).returns(typeInfo)__			default:_				throw new IllegalArgumentException("Illegal edge direction")__		}_	};groups,by,vertex,and,computes,a,group,reduce,transformation,over,the,edge,values,of,each,vertex,the,edges,function,applied,on,the,edges,has,access,to,both,the,id,and,the,value,of,the,grouping,vertex,for,each,vertex,the,edges,function,can,iterate,over,all,edges,of,this,vertex,with,the,specified,direction,and,emit,any,number,of,output,elements,including,none,param,edges,function,the,group,reduce,function,to,apply,to,the,neighboring,edges,of,each,vertex,param,direction,the,edge,direction,in,out,all,param,t,the,output,type,param,type,info,the,explicit,return,type,return,a,data,set,containing,elements,of,type,t,throws,illegal,argument,exception;public,t,data,set,t,group,reduce,on,edges,edges,function,with,vertex,value,k,vv,ev,t,edges,function,edge,direction,direction,type,information,t,type,info,throws,illegal,argument,exception,switch,direction,case,in,return,vertices,co,group,edges,where,0,equal,to,1,with,new,apply,co,group,function,edges,function,returns,type,info,case,out,return,vertices,co,group,edges,where,0,equal,to,0,with,new,apply,co,group,function,edges,function,returns,type,info,case,all,return,vertices,co,group,edges,flat,map,new,emit,one,edge,per,node,k,vv,ev,where,0,equal,to,0,with,new,apply,co,group,function,on,all,edges,edges,function,returns,type,info,default,throw,new,illegal,argument,exception,illegal,edge,direction
Graph -> public <T> DataSet<T> groupReduceOnEdges(EdgesFunctionWithVertexValue<K, VV, EV, T> edgesFunction, 			EdgeDirection direction, TypeInformation<T> typeInfo) throws IllegalArgumentException;1475685606;Groups by vertex and computes a GroupReduce transformation over the edge values of each vertex._The edgesFunction applied on the edges has access to both the id and the value_of the grouping vertex.__For each vertex, the edgesFunction can iterate over all edges of this vertex_with the specified direction, and emit any number of output elements, including none.__@param edgesFunction the group reduce function to apply to the neighboring edges of each vertex._@param direction the edge direction (in-, out-, all-)._@param <T> the output type_@param typeInfo the explicit return type._@return a DataSet containing elements of type T_@throws IllegalArgumentException;public <T> DataSet<T> groupReduceOnEdges(EdgesFunctionWithVertexValue<K, VV, EV, T> edgesFunction,_			EdgeDirection direction, TypeInformation<T> typeInfo) throws IllegalArgumentException {__		switch (direction) {_			case IN:_				return vertices.coGroup(edges).where(0).equalTo(1)_						.with(new ApplyCoGroupFunction<>(edgesFunction)).returns(typeInfo)__			case OUT:_				return vertices.coGroup(edges).where(0).equalTo(0)_						.with(new ApplyCoGroupFunction<>(edgesFunction)).returns(typeInfo)__			case ALL:_				return vertices.coGroup(edges.flatMap(new EmitOneEdgePerNode<K, VV, EV>()))_						.where(0).equalTo(0).with(new ApplyCoGroupFunctionOnAllEdges<>(edgesFunction)).returns(typeInfo)__			default:_				throw new IllegalArgumentException("Illegal edge direction")__		}_	};groups,by,vertex,and,computes,a,group,reduce,transformation,over,the,edge,values,of,each,vertex,the,edges,function,applied,on,the,edges,has,access,to,both,the,id,and,the,value,of,the,grouping,vertex,for,each,vertex,the,edges,function,can,iterate,over,all,edges,of,this,vertex,with,the,specified,direction,and,emit,any,number,of,output,elements,including,none,param,edges,function,the,group,reduce,function,to,apply,to,the,neighboring,edges,of,each,vertex,param,direction,the,edge,direction,in,out,all,param,t,the,output,type,param,type,info,the,explicit,return,type,return,a,data,set,containing,elements,of,type,t,throws,illegal,argument,exception;public,t,data,set,t,group,reduce,on,edges,edges,function,with,vertex,value,k,vv,ev,t,edges,function,edge,direction,direction,type,information,t,type,info,throws,illegal,argument,exception,switch,direction,case,in,return,vertices,co,group,edges,where,0,equal,to,1,with,new,apply,co,group,function,edges,function,returns,type,info,case,out,return,vertices,co,group,edges,where,0,equal,to,0,with,new,apply,co,group,function,edges,function,returns,type,info,case,all,return,vertices,co,group,edges,flat,map,new,emit,one,edge,per,node,k,vv,ev,where,0,equal,to,0,with,new,apply,co,group,function,on,all,edges,edges,function,returns,type,info,default,throw,new,illegal,argument,exception,illegal,edge,direction
Graph -> public <T> DataSet<T> groupReduceOnEdges(EdgesFunctionWithVertexValue<K, VV, EV, T> edgesFunction, 			EdgeDirection direction, TypeInformation<T> typeInfo) throws IllegalArgumentException;1481745825;Groups by vertex and computes a GroupReduce transformation over the edge values of each vertex._The edgesFunction applied on the edges has access to both the id and the value_of the grouping vertex.__For each vertex, the edgesFunction can iterate over all edges of this vertex_with the specified direction, and emit any number of output elements, including none.__@param edgesFunction the group reduce function to apply to the neighboring edges of each vertex._@param direction the edge direction (in-, out-, all-)._@param <T> the output type_@param typeInfo the explicit return type._@return a DataSet containing elements of type T_@throws IllegalArgumentException;public <T> DataSet<T> groupReduceOnEdges(EdgesFunctionWithVertexValue<K, VV, EV, T> edgesFunction,_			EdgeDirection direction, TypeInformation<T> typeInfo) throws IllegalArgumentException {__		switch (direction) {_			case IN:_				return vertices.coGroup(edges).where(0).equalTo(1)_						.with(new ApplyCoGroupFunction<>(edgesFunction))_							.name("GroupReduce on in-edges").returns(typeInfo)__			case OUT:_				return vertices.coGroup(edges).where(0).equalTo(0)_						.with(new ApplyCoGroupFunction<>(edgesFunction))_							.name("GroupReduce on out-edges").returns(typeInfo)__			case ALL:_				return vertices.coGroup(edges.flatMap(new EmitOneEdgePerNode<K, VV, EV>())_							.name("Emit edge"))_						.where(0).equalTo(0).with(new ApplyCoGroupFunctionOnAllEdges<>(edgesFunction))_							.name("GroupReduce on in- and out-edges").returns(typeInfo)__			default:_				throw new IllegalArgumentException("Illegal edge direction")__		}_	};groups,by,vertex,and,computes,a,group,reduce,transformation,over,the,edge,values,of,each,vertex,the,edges,function,applied,on,the,edges,has,access,to,both,the,id,and,the,value,of,the,grouping,vertex,for,each,vertex,the,edges,function,can,iterate,over,all,edges,of,this,vertex,with,the,specified,direction,and,emit,any,number,of,output,elements,including,none,param,edges,function,the,group,reduce,function,to,apply,to,the,neighboring,edges,of,each,vertex,param,direction,the,edge,direction,in,out,all,param,t,the,output,type,param,type,info,the,explicit,return,type,return,a,data,set,containing,elements,of,type,t,throws,illegal,argument,exception;public,t,data,set,t,group,reduce,on,edges,edges,function,with,vertex,value,k,vv,ev,t,edges,function,edge,direction,direction,type,information,t,type,info,throws,illegal,argument,exception,switch,direction,case,in,return,vertices,co,group,edges,where,0,equal,to,1,with,new,apply,co,group,function,edges,function,name,group,reduce,on,in,edges,returns,type,info,case,out,return,vertices,co,group,edges,where,0,equal,to,0,with,new,apply,co,group,function,edges,function,name,group,reduce,on,out,edges,returns,type,info,case,all,return,vertices,co,group,edges,flat,map,new,emit,one,edge,per,node,k,vv,ev,name,emit,edge,where,0,equal,to,0,with,new,apply,co,group,function,on,all,edges,edges,function,name,group,reduce,on,in,and,out,edges,returns,type,info,default,throw,new,illegal,argument,exception,illegal,edge,direction
Graph -> public <T> DataSet<T> groupReduceOnEdges(EdgesFunctionWithVertexValue<K, VV, EV, T> edgesFunction, 			EdgeDirection direction, TypeInformation<T> typeInfo) throws IllegalArgumentException;1481881009;Groups by vertex and computes a GroupReduce transformation over the edge values of each vertex._The edgesFunction applied on the edges has access to both the id and the value_of the grouping vertex.__For each vertex, the edgesFunction can iterate over all edges of this vertex_with the specified direction, and emit any number of output elements, including none.__@param edgesFunction the group reduce function to apply to the neighboring edges of each vertex._@param direction the edge direction (in-, out-, all-)._@param <T> the output type_@param typeInfo the explicit return type._@return a DataSet containing elements of type T_@throws IllegalArgumentException;public <T> DataSet<T> groupReduceOnEdges(EdgesFunctionWithVertexValue<K, VV, EV, T> edgesFunction,_			EdgeDirection direction, TypeInformation<T> typeInfo) throws IllegalArgumentException {__		switch (direction) {_			case IN:_				return vertices.coGroup(edges).where(0).equalTo(1)_						.with(new ApplyCoGroupFunction<>(edgesFunction))_							.name("GroupReduce on in-edges").returns(typeInfo)__			case OUT:_				return vertices.coGroup(edges).where(0).equalTo(0)_						.with(new ApplyCoGroupFunction<>(edgesFunction))_							.name("GroupReduce on out-edges").returns(typeInfo)__			case ALL:_				return vertices.coGroup(edges.flatMap(new EmitOneEdgePerNode<K, EV>())_							.name("Emit edge"))_						.where(0).equalTo(0).with(new ApplyCoGroupFunctionOnAllEdges<>(edgesFunction))_							.name("GroupReduce on in- and out-edges").returns(typeInfo)__			default:_				throw new IllegalArgumentException("Illegal edge direction")__		}_	};groups,by,vertex,and,computes,a,group,reduce,transformation,over,the,edge,values,of,each,vertex,the,edges,function,applied,on,the,edges,has,access,to,both,the,id,and,the,value,of,the,grouping,vertex,for,each,vertex,the,edges,function,can,iterate,over,all,edges,of,this,vertex,with,the,specified,direction,and,emit,any,number,of,output,elements,including,none,param,edges,function,the,group,reduce,function,to,apply,to,the,neighboring,edges,of,each,vertex,param,direction,the,edge,direction,in,out,all,param,t,the,output,type,param,type,info,the,explicit,return,type,return,a,data,set,containing,elements,of,type,t,throws,illegal,argument,exception;public,t,data,set,t,group,reduce,on,edges,edges,function,with,vertex,value,k,vv,ev,t,edges,function,edge,direction,direction,type,information,t,type,info,throws,illegal,argument,exception,switch,direction,case,in,return,vertices,co,group,edges,where,0,equal,to,1,with,new,apply,co,group,function,edges,function,name,group,reduce,on,in,edges,returns,type,info,case,out,return,vertices,co,group,edges,where,0,equal,to,0,with,new,apply,co,group,function,edges,function,name,group,reduce,on,out,edges,returns,type,info,case,all,return,vertices,co,group,edges,flat,map,new,emit,one,edge,per,node,k,ev,name,emit,edge,where,0,equal,to,0,with,new,apply,co,group,function,on,all,edges,edges,function,name,group,reduce,on,in,and,out,edges,returns,type,info,default,throw,new,illegal,argument,exception,illegal,edge,direction
Graph -> public <T> DataSet<T> groupReduceOnEdges(EdgesFunctionWithVertexValue<K, VV, EV, T> edgesFunction, 			EdgeDirection direction, TypeInformation<T> typeInfo) throws IllegalArgumentException;1484160227;Groups by vertex and computes a GroupReduce transformation over the edge values of each vertex._The edgesFunction applied on the edges has access to both the id and the value_of the grouping vertex.__For each vertex, the edgesFunction can iterate over all edges of this vertex_with the specified direction, and emit any number of output elements, including none.__@param edgesFunction the group reduce function to apply to the neighboring edges of each vertex._@param direction the edge direction (in-, out-, all-)._@param <T> the output type_@param typeInfo the explicit return type._@return a DataSet containing elements of type T_@throws IllegalArgumentException;public <T> DataSet<T> groupReduceOnEdges(EdgesFunctionWithVertexValue<K, VV, EV, T> edgesFunction,_			EdgeDirection direction, TypeInformation<T> typeInfo) throws IllegalArgumentException {__		switch (direction) {_			case IN:_				return vertices.coGroup(edges).where(0).equalTo(1)_						.with(new ApplyCoGroupFunction<>(edgesFunction))_							.name("GroupReduce on in-edges").returns(typeInfo)__			case OUT:_				return vertices.coGroup(edges).where(0).equalTo(0)_						.with(new ApplyCoGroupFunction<>(edgesFunction))_							.name("GroupReduce on out-edges").returns(typeInfo)__			case ALL:_				return vertices.coGroup(edges.flatMap(new EmitOneEdgePerNode<K, EV>())_							.name("Emit edge"))_						.where(0).equalTo(0).with(new ApplyCoGroupFunctionOnAllEdges<>(edgesFunction))_							.name("GroupReduce on in- and out-edges").returns(typeInfo)__			default:_				throw new IllegalArgumentException("Illegal edge direction")__		}_	};groups,by,vertex,and,computes,a,group,reduce,transformation,over,the,edge,values,of,each,vertex,the,edges,function,applied,on,the,edges,has,access,to,both,the,id,and,the,value,of,the,grouping,vertex,for,each,vertex,the,edges,function,can,iterate,over,all,edges,of,this,vertex,with,the,specified,direction,and,emit,any,number,of,output,elements,including,none,param,edges,function,the,group,reduce,function,to,apply,to,the,neighboring,edges,of,each,vertex,param,direction,the,edge,direction,in,out,all,param,t,the,output,type,param,type,info,the,explicit,return,type,return,a,data,set,containing,elements,of,type,t,throws,illegal,argument,exception;public,t,data,set,t,group,reduce,on,edges,edges,function,with,vertex,value,k,vv,ev,t,edges,function,edge,direction,direction,type,information,t,type,info,throws,illegal,argument,exception,switch,direction,case,in,return,vertices,co,group,edges,where,0,equal,to,1,with,new,apply,co,group,function,edges,function,name,group,reduce,on,in,edges,returns,type,info,case,out,return,vertices,co,group,edges,where,0,equal,to,0,with,new,apply,co,group,function,edges,function,name,group,reduce,on,out,edges,returns,type,info,case,all,return,vertices,co,group,edges,flat,map,new,emit,one,edge,per,node,k,ev,name,emit,edge,where,0,equal,to,0,with,new,apply,co,group,function,on,all,edges,edges,function,name,group,reduce,on,in,and,out,edges,returns,type,info,default,throw,new,illegal,argument,exception,illegal,edge,direction
Graph -> public <T> DataSet<T> groupReduceOnEdges(EdgesFunctionWithVertexValue<K, VV, EV, T> edgesFunction, 			EdgeDirection direction, TypeInformation<T> typeInfo) throws IllegalArgumentException;1484685504;Groups by vertex and computes a GroupReduce transformation over the edge values of each vertex._The edgesFunction applied on the edges has access to both the id and the value_of the grouping vertex.__For each vertex, the edgesFunction can iterate over all edges of this vertex_with the specified direction, and emit any number of output elements, including none.__@param edgesFunction the group reduce function to apply to the neighboring edges of each vertex._@param direction the edge direction (in-, out-, all-)._@param <T> the output type_@param typeInfo the explicit return type._@return a DataSet containing elements of type T_@throws IllegalArgumentException;public <T> DataSet<T> groupReduceOnEdges(EdgesFunctionWithVertexValue<K, VV, EV, T> edgesFunction,_			EdgeDirection direction, TypeInformation<T> typeInfo) throws IllegalArgumentException {__		switch (direction) {_			case IN:_				return vertices.coGroup(edges).where(0).equalTo(1)_						.with(new ApplyCoGroupFunction<>(edgesFunction))_							.name("GroupReduce on in-edges").returns(typeInfo)__			case OUT:_				return vertices.coGroup(edges).where(0).equalTo(0)_						.with(new ApplyCoGroupFunction<>(edgesFunction))_							.name("GroupReduce on out-edges").returns(typeInfo)__			case ALL:_				return vertices.coGroup(edges.flatMap(new EmitOneEdgePerNode<K, EV>())_							.name("Emit edge"))_						.where(0).equalTo(0).with(new ApplyCoGroupFunctionOnAllEdges<>(edgesFunction))_							.name("GroupReduce on in- and out-edges").returns(typeInfo)__			default:_				throw new IllegalArgumentException("Illegal edge direction")__		}_	};groups,by,vertex,and,computes,a,group,reduce,transformation,over,the,edge,values,of,each,vertex,the,edges,function,applied,on,the,edges,has,access,to,both,the,id,and,the,value,of,the,grouping,vertex,for,each,vertex,the,edges,function,can,iterate,over,all,edges,of,this,vertex,with,the,specified,direction,and,emit,any,number,of,output,elements,including,none,param,edges,function,the,group,reduce,function,to,apply,to,the,neighboring,edges,of,each,vertex,param,direction,the,edge,direction,in,out,all,param,t,the,output,type,param,type,info,the,explicit,return,type,return,a,data,set,containing,elements,of,type,t,throws,illegal,argument,exception;public,t,data,set,t,group,reduce,on,edges,edges,function,with,vertex,value,k,vv,ev,t,edges,function,edge,direction,direction,type,information,t,type,info,throws,illegal,argument,exception,switch,direction,case,in,return,vertices,co,group,edges,where,0,equal,to,1,with,new,apply,co,group,function,edges,function,name,group,reduce,on,in,edges,returns,type,info,case,out,return,vertices,co,group,edges,where,0,equal,to,0,with,new,apply,co,group,function,edges,function,name,group,reduce,on,out,edges,returns,type,info,case,all,return,vertices,co,group,edges,flat,map,new,emit,one,edge,per,node,k,ev,name,emit,edge,where,0,equal,to,0,with,new,apply,co,group,function,on,all,edges,edges,function,name,group,reduce,on,in,and,out,edges,returns,type,info,default,throw,new,illegal,argument,exception,illegal,edge,direction
Graph -> public <T> DataSet<T> groupReduceOnEdges(EdgesFunctionWithVertexValue<K, VV, EV, T> edgesFunction, 			EdgeDirection direction, TypeInformation<T> typeInfo) throws IllegalArgumentException;1489068942;Groups by vertex and computes a GroupReduce transformation over the edge values of each vertex._The edgesFunction applied on the edges has access to both the id and the value_of the grouping vertex.__For each vertex, the edgesFunction can iterate over all edges of this vertex_with the specified direction, and emit any number of output elements, including none.__@param edgesFunction the group reduce function to apply to the neighboring edges of each vertex._@param direction the edge direction (in-, out-, all-)._@param <T> the output type_@param typeInfo the explicit return type._@return a DataSet containing elements of type T_@throws IllegalArgumentException;public <T> DataSet<T> groupReduceOnEdges(EdgesFunctionWithVertexValue<K, VV, EV, T> edgesFunction,_			EdgeDirection direction, TypeInformation<T> typeInfo) throws IllegalArgumentException {__		switch (direction) {_			case IN:_				return vertices.coGroup(edges).where(0).equalTo(1)_						.with(new ApplyCoGroupFunction<>(edgesFunction))_							.name("GroupReduce on in-edges").returns(typeInfo)__			case OUT:_				return vertices.coGroup(edges).where(0).equalTo(0)_						.with(new ApplyCoGroupFunction<>(edgesFunction))_							.name("GroupReduce on out-edges").returns(typeInfo)__			case ALL:_				return vertices.coGroup(edges.flatMap(new EmitOneEdgePerNode<K, EV>())_							.name("Emit edge"))_						.where(0).equalTo(0).with(new ApplyCoGroupFunctionOnAllEdges<>(edgesFunction))_							.name("GroupReduce on in- and out-edges").returns(typeInfo)__			default:_				throw new IllegalArgumentException("Illegal edge direction")__		}_	};groups,by,vertex,and,computes,a,group,reduce,transformation,over,the,edge,values,of,each,vertex,the,edges,function,applied,on,the,edges,has,access,to,both,the,id,and,the,value,of,the,grouping,vertex,for,each,vertex,the,edges,function,can,iterate,over,all,edges,of,this,vertex,with,the,specified,direction,and,emit,any,number,of,output,elements,including,none,param,edges,function,the,group,reduce,function,to,apply,to,the,neighboring,edges,of,each,vertex,param,direction,the,edge,direction,in,out,all,param,t,the,output,type,param,type,info,the,explicit,return,type,return,a,data,set,containing,elements,of,type,t,throws,illegal,argument,exception;public,t,data,set,t,group,reduce,on,edges,edges,function,with,vertex,value,k,vv,ev,t,edges,function,edge,direction,direction,type,information,t,type,info,throws,illegal,argument,exception,switch,direction,case,in,return,vertices,co,group,edges,where,0,equal,to,1,with,new,apply,co,group,function,edges,function,name,group,reduce,on,in,edges,returns,type,info,case,out,return,vertices,co,group,edges,where,0,equal,to,0,with,new,apply,co,group,function,edges,function,name,group,reduce,on,out,edges,returns,type,info,case,all,return,vertices,co,group,edges,flat,map,new,emit,one,edge,per,node,k,ev,name,emit,edge,where,0,equal,to,0,with,new,apply,co,group,function,on,all,edges,edges,function,name,group,reduce,on,in,and,out,edges,returns,type,info,default,throw,new,illegal,argument,exception,illegal,edge,direction
Graph -> public <T> DataSet<T> groupReduceOnEdges(EdgesFunctionWithVertexValue<K, VV, EV, T> edgesFunction, 			EdgeDirection direction, TypeInformation<T> typeInfo) throws IllegalArgumentException;1490973446;Groups by vertex and computes a GroupReduce transformation over the edge values of each vertex._The edgesFunction applied on the edges has access to both the id and the value_of the grouping vertex.__For each vertex, the edgesFunction can iterate over all edges of this vertex_with the specified direction, and emit any number of output elements, including none.__@param edgesFunction the group reduce function to apply to the neighboring edges of each vertex._@param direction the edge direction (in-, out-, all-)._@param <T> the output type_@param typeInfo the explicit return type._@return a DataSet containing elements of type T_@throws IllegalArgumentException;public <T> DataSet<T> groupReduceOnEdges(EdgesFunctionWithVertexValue<K, VV, EV, T> edgesFunction,_			EdgeDirection direction, TypeInformation<T> typeInfo) throws IllegalArgumentException {__		switch (direction) {_			case IN:_				return vertices.coGroup(edges).where(0).equalTo(1)_						.with(new ApplyCoGroupFunction<>(edgesFunction))_							.name("GroupReduce on in-edges").returns(typeInfo)__			case OUT:_				return vertices.coGroup(edges).where(0).equalTo(0)_						.with(new ApplyCoGroupFunction<>(edgesFunction))_							.name("GroupReduce on out-edges").returns(typeInfo)__			case ALL:_				return vertices.coGroup(edges.flatMap(new EmitOneEdgePerNode<K, EV>())_							.name("Emit edge"))_						.where(0).equalTo(0).with(new ApplyCoGroupFunctionOnAllEdges<>(edgesFunction))_							.name("GroupReduce on in- and out-edges").returns(typeInfo)__			default:_				throw new IllegalArgumentException("Illegal edge direction")__		}_	};groups,by,vertex,and,computes,a,group,reduce,transformation,over,the,edge,values,of,each,vertex,the,edges,function,applied,on,the,edges,has,access,to,both,the,id,and,the,value,of,the,grouping,vertex,for,each,vertex,the,edges,function,can,iterate,over,all,edges,of,this,vertex,with,the,specified,direction,and,emit,any,number,of,output,elements,including,none,param,edges,function,the,group,reduce,function,to,apply,to,the,neighboring,edges,of,each,vertex,param,direction,the,edge,direction,in,out,all,param,t,the,output,type,param,type,info,the,explicit,return,type,return,a,data,set,containing,elements,of,type,t,throws,illegal,argument,exception;public,t,data,set,t,group,reduce,on,edges,edges,function,with,vertex,value,k,vv,ev,t,edges,function,edge,direction,direction,type,information,t,type,info,throws,illegal,argument,exception,switch,direction,case,in,return,vertices,co,group,edges,where,0,equal,to,1,with,new,apply,co,group,function,edges,function,name,group,reduce,on,in,edges,returns,type,info,case,out,return,vertices,co,group,edges,where,0,equal,to,0,with,new,apply,co,group,function,edges,function,name,group,reduce,on,out,edges,returns,type,info,case,all,return,vertices,co,group,edges,flat,map,new,emit,one,edge,per,node,k,ev,name,emit,edge,where,0,equal,to,0,with,new,apply,co,group,function,on,all,edges,edges,function,name,group,reduce,on,in,and,out,edges,returns,type,info,default,throw,new,illegal,argument,exception,illegal,edge,direction
Graph -> public <T> DataSet<T> groupReduceOnEdges(EdgesFunctionWithVertexValue<K, VV, EV, T> edgesFunction, 			EdgeDirection direction, TypeInformation<T> typeInfo) throws IllegalArgumentException;1495819075;Groups by vertex and computes a GroupReduce transformation over the edge values of each vertex._The edgesFunction applied on the edges has access to both the id and the value_of the grouping vertex.__<p>For each vertex, the edgesFunction can iterate over all edges of this vertex_with the specified direction, and emit any number of output elements, including none.__@param edgesFunction the group reduce function to apply to the neighboring edges of each vertex._@param direction the edge direction (in-, out-, all-)._@param <T> the output type_@param typeInfo the explicit return type._@return a DataSet containing elements of type T_@throws IllegalArgumentException;public <T> DataSet<T> groupReduceOnEdges(EdgesFunctionWithVertexValue<K, VV, EV, T> edgesFunction,_			EdgeDirection direction, TypeInformation<T> typeInfo) throws IllegalArgumentException {__		switch (direction) {_			case IN:_				return vertices.coGroup(edges).where(0).equalTo(1)_						.with(new ApplyCoGroupFunction<>(edgesFunction))_							.name("GroupReduce on in-edges").returns(typeInfo)__			case OUT:_				return vertices.coGroup(edges).where(0).equalTo(0)_						.with(new ApplyCoGroupFunction<>(edgesFunction))_							.name("GroupReduce on out-edges").returns(typeInfo)__			case ALL:_				return vertices.coGroup(edges.flatMap(new EmitOneEdgePerNode<K, EV>())_							.name("Emit edge"))_						.where(0).equalTo(0).with(new ApplyCoGroupFunctionOnAllEdges<>(edgesFunction))_							.name("GroupReduce on in- and out-edges").returns(typeInfo)__			default:_				throw new IllegalArgumentException("Illegal edge direction")__		}_	};groups,by,vertex,and,computes,a,group,reduce,transformation,over,the,edge,values,of,each,vertex,the,edges,function,applied,on,the,edges,has,access,to,both,the,id,and,the,value,of,the,grouping,vertex,p,for,each,vertex,the,edges,function,can,iterate,over,all,edges,of,this,vertex,with,the,specified,direction,and,emit,any,number,of,output,elements,including,none,param,edges,function,the,group,reduce,function,to,apply,to,the,neighboring,edges,of,each,vertex,param,direction,the,edge,direction,in,out,all,param,t,the,output,type,param,type,info,the,explicit,return,type,return,a,data,set,containing,elements,of,type,t,throws,illegal,argument,exception;public,t,data,set,t,group,reduce,on,edges,edges,function,with,vertex,value,k,vv,ev,t,edges,function,edge,direction,direction,type,information,t,type,info,throws,illegal,argument,exception,switch,direction,case,in,return,vertices,co,group,edges,where,0,equal,to,1,with,new,apply,co,group,function,edges,function,name,group,reduce,on,in,edges,returns,type,info,case,out,return,vertices,co,group,edges,where,0,equal,to,0,with,new,apply,co,group,function,edges,function,name,group,reduce,on,out,edges,returns,type,info,case,all,return,vertices,co,group,edges,flat,map,new,emit,one,edge,per,node,k,ev,name,emit,edge,where,0,equal,to,0,with,new,apply,co,group,function,on,all,edges,edges,function,name,group,reduce,on,in,and,out,edges,returns,type,info,default,throw,new,illegal,argument,exception,illegal,edge,direction
Graph -> public <T> DataSet<T> groupReduceOnEdges(EdgesFunctionWithVertexValue<K, VV, EV, T> edgesFunction, 			EdgeDirection direction, TypeInformation<T> typeInfo) throws IllegalArgumentException;1502111816;Groups by vertex and computes a GroupReduce transformation over the edge values of each vertex._The edgesFunction applied on the edges has access to both the id and the value_of the grouping vertex.__<p>For each vertex, the edgesFunction can iterate over all edges of this vertex_with the specified direction, and emit any number of output elements, including none.__@param edgesFunction the group reduce function to apply to the neighboring edges of each vertex._@param direction the edge direction (in-, out-, all-)._@param <T> the output type_@param typeInfo the explicit return type._@return a DataSet containing elements of type T_@throws IllegalArgumentException;public <T> DataSet<T> groupReduceOnEdges(EdgesFunctionWithVertexValue<K, VV, EV, T> edgesFunction,_			EdgeDirection direction, TypeInformation<T> typeInfo) throws IllegalArgumentException {__		switch (direction) {_			case IN:_				return vertices.coGroup(edges).where(0).equalTo(1)_						.with(new ApplyCoGroupFunction<>(edgesFunction))_							.name("GroupReduce on in-edges").returns(typeInfo)__			case OUT:_				return vertices.coGroup(edges).where(0).equalTo(0)_						.with(new ApplyCoGroupFunction<>(edgesFunction))_							.name("GroupReduce on out-edges").returns(typeInfo)__			case ALL:_				return vertices.coGroup(edges.flatMap(new EmitOneEdgePerNode<>())_							.name("Emit edge"))_						.where(0).equalTo(0).with(new ApplyCoGroupFunctionOnAllEdges<>(edgesFunction))_							.name("GroupReduce on in- and out-edges").returns(typeInfo)__			default:_				throw new IllegalArgumentException("Illegal edge direction")__		}_	};groups,by,vertex,and,computes,a,group,reduce,transformation,over,the,edge,values,of,each,vertex,the,edges,function,applied,on,the,edges,has,access,to,both,the,id,and,the,value,of,the,grouping,vertex,p,for,each,vertex,the,edges,function,can,iterate,over,all,edges,of,this,vertex,with,the,specified,direction,and,emit,any,number,of,output,elements,including,none,param,edges,function,the,group,reduce,function,to,apply,to,the,neighboring,edges,of,each,vertex,param,direction,the,edge,direction,in,out,all,param,t,the,output,type,param,type,info,the,explicit,return,type,return,a,data,set,containing,elements,of,type,t,throws,illegal,argument,exception;public,t,data,set,t,group,reduce,on,edges,edges,function,with,vertex,value,k,vv,ev,t,edges,function,edge,direction,direction,type,information,t,type,info,throws,illegal,argument,exception,switch,direction,case,in,return,vertices,co,group,edges,where,0,equal,to,1,with,new,apply,co,group,function,edges,function,name,group,reduce,on,in,edges,returns,type,info,case,out,return,vertices,co,group,edges,where,0,equal,to,0,with,new,apply,co,group,function,edges,function,name,group,reduce,on,out,edges,returns,type,info,case,all,return,vertices,co,group,edges,flat,map,new,emit,one,edge,per,node,name,emit,edge,where,0,equal,to,0,with,new,apply,co,group,function,on,all,edges,edges,function,name,group,reduce,on,in,and,out,edges,returns,type,info,default,throw,new,illegal,argument,exception,illegal,edge,direction
Graph -> public Graph<K, VV, EV> filterOnVertices(FilterFunction<Vertex<K, VV>> vertexFilter);1444404795;Apply a filtering function to the graph and return a sub-graph that_satisfies the predicates only for the vertices.__@param vertexFilter the filter function for vertices._@return the resulting sub-graph.;public Graph<K, VV, EV> filterOnVertices(FilterFunction<Vertex<K, VV>> vertexFilter) {__		DataSet<Vertex<K, VV>> filteredVertices = this.vertices.filter(vertexFilter)___		DataSet<Edge<K, EV>> remainingEdges = this.edges.join(filteredVertices)_				.where(0).equalTo(0).with(new ProjectEdge<K, VV, EV>())_				.join(filteredVertices).where(1).equalTo(0)_				.with(new ProjectEdge<K, VV, EV>())___		return new Graph<K, VV, EV>(filteredVertices, remainingEdges, this.context)__	};apply,a,filtering,function,to,the,graph,and,return,a,sub,graph,that,satisfies,the,predicates,only,for,the,vertices,param,vertex,filter,the,filter,function,for,vertices,return,the,resulting,sub,graph;public,graph,k,vv,ev,filter,on,vertices,filter,function,vertex,k,vv,vertex,filter,data,set,vertex,k,vv,filtered,vertices,this,vertices,filter,vertex,filter,data,set,edge,k,ev,remaining,edges,this,edges,join,filtered,vertices,where,0,equal,to,0,with,new,project,edge,k,vv,ev,join,filtered,vertices,where,1,equal,to,0,with,new,project,edge,k,vv,ev,return,new,graph,k,vv,ev,filtered,vertices,remaining,edges,this,context
Graph -> public Graph<K, VV, EV> filterOnVertices(FilterFunction<Vertex<K, VV>> vertexFilter);1445261977;Apply a filtering function to the graph and return a sub-graph that_satisfies the predicates only for the vertices.__@param vertexFilter the filter function for vertices._@return the resulting sub-graph.;public Graph<K, VV, EV> filterOnVertices(FilterFunction<Vertex<K, VV>> vertexFilter) {__		DataSet<Vertex<K, VV>> filteredVertices = this.vertices.filter(vertexFilter)___		DataSet<Edge<K, EV>> remainingEdges = this.edges.join(filteredVertices)_				.where(0).equalTo(0).with(new ProjectEdge<K, VV, EV>())_				.join(filteredVertices).where(1).equalTo(0)_				.with(new ProjectEdge<K, VV, EV>())___		return new Graph<K, VV, EV>(filteredVertices, remainingEdges, this.context)__	};apply,a,filtering,function,to,the,graph,and,return,a,sub,graph,that,satisfies,the,predicates,only,for,the,vertices,param,vertex,filter,the,filter,function,for,vertices,return,the,resulting,sub,graph;public,graph,k,vv,ev,filter,on,vertices,filter,function,vertex,k,vv,vertex,filter,data,set,vertex,k,vv,filtered,vertices,this,vertices,filter,vertex,filter,data,set,edge,k,ev,remaining,edges,this,edges,join,filtered,vertices,where,0,equal,to,0,with,new,project,edge,k,vv,ev,join,filtered,vertices,where,1,equal,to,0,with,new,project,edge,k,vv,ev,return,new,graph,k,vv,ev,filtered,vertices,remaining,edges,this,context
Graph -> public Graph<K, VV, EV> filterOnVertices(FilterFunction<Vertex<K, VV>> vertexFilter);1445854323;Apply a filtering function to the graph and return a sub-graph that_satisfies the predicates only for the vertices.__@param vertexFilter the filter function for vertices._@return the resulting sub-graph.;public Graph<K, VV, EV> filterOnVertices(FilterFunction<Vertex<K, VV>> vertexFilter) {__		DataSet<Vertex<K, VV>> filteredVertices = this.vertices.filter(vertexFilter)___		DataSet<Edge<K, EV>> remainingEdges = this.edges.join(filteredVertices)_				.where(0).equalTo(0).with(new ProjectEdge<K, VV, EV>())_				.join(filteredVertices).where(1).equalTo(0)_				.with(new ProjectEdge<K, VV, EV>())___		return new Graph<K, VV, EV>(filteredVertices, remainingEdges, this.context)__	};apply,a,filtering,function,to,the,graph,and,return,a,sub,graph,that,satisfies,the,predicates,only,for,the,vertices,param,vertex,filter,the,filter,function,for,vertices,return,the,resulting,sub,graph;public,graph,k,vv,ev,filter,on,vertices,filter,function,vertex,k,vv,vertex,filter,data,set,vertex,k,vv,filtered,vertices,this,vertices,filter,vertex,filter,data,set,edge,k,ev,remaining,edges,this,edges,join,filtered,vertices,where,0,equal,to,0,with,new,project,edge,k,vv,ev,join,filtered,vertices,where,1,equal,to,0,with,new,project,edge,k,vv,ev,return,new,graph,k,vv,ev,filtered,vertices,remaining,edges,this,context
Graph -> public Graph<K, VV, EV> filterOnVertices(FilterFunction<Vertex<K, VV>> vertexFilter);1446112342;Apply a filtering function to the graph and return a sub-graph that_satisfies the predicates only for the vertices.__@param vertexFilter the filter function for vertices._@return the resulting sub-graph.;public Graph<K, VV, EV> filterOnVertices(FilterFunction<Vertex<K, VV>> vertexFilter) {__		DataSet<Vertex<K, VV>> filteredVertices = this.vertices.filter(vertexFilter)___		DataSet<Edge<K, EV>> remainingEdges = this.edges.join(filteredVertices)_				.where(0).equalTo(0).with(new ProjectEdge<K, VV, EV>())_				.join(filteredVertices).where(1).equalTo(0)_				.with(new ProjectEdge<K, VV, EV>())___		return new Graph<K, VV, EV>(filteredVertices, remainingEdges, this.context)__	};apply,a,filtering,function,to,the,graph,and,return,a,sub,graph,that,satisfies,the,predicates,only,for,the,vertices,param,vertex,filter,the,filter,function,for,vertices,return,the,resulting,sub,graph;public,graph,k,vv,ev,filter,on,vertices,filter,function,vertex,k,vv,vertex,filter,data,set,vertex,k,vv,filtered,vertices,this,vertices,filter,vertex,filter,data,set,edge,k,ev,remaining,edges,this,edges,join,filtered,vertices,where,0,equal,to,0,with,new,project,edge,k,vv,ev,join,filtered,vertices,where,1,equal,to,0,with,new,project,edge,k,vv,ev,return,new,graph,k,vv,ev,filtered,vertices,remaining,edges,this,context
Graph -> public Graph<K, VV, EV> filterOnVertices(FilterFunction<Vertex<K, VV>> vertexFilter);1447073368;Apply a filtering function to the graph and return a sub-graph that_satisfies the predicates only for the vertices.__@param vertexFilter the filter function for vertices._@return the resulting sub-graph.;public Graph<K, VV, EV> filterOnVertices(FilterFunction<Vertex<K, VV>> vertexFilter) {__		DataSet<Vertex<K, VV>> filteredVertices = this.vertices.filter(vertexFilter)___		DataSet<Edge<K, EV>> remainingEdges = this.edges.join(filteredVertices)_				.where(0).equalTo(0).with(new ProjectEdge<K, VV, EV>())_				.join(filteredVertices).where(1).equalTo(0)_				.with(new ProjectEdge<K, VV, EV>())___		return new Graph<K, VV, EV>(filteredVertices, remainingEdges, this.context)__	};apply,a,filtering,function,to,the,graph,and,return,a,sub,graph,that,satisfies,the,predicates,only,for,the,vertices,param,vertex,filter,the,filter,function,for,vertices,return,the,resulting,sub,graph;public,graph,k,vv,ev,filter,on,vertices,filter,function,vertex,k,vv,vertex,filter,data,set,vertex,k,vv,filtered,vertices,this,vertices,filter,vertex,filter,data,set,edge,k,ev,remaining,edges,this,edges,join,filtered,vertices,where,0,equal,to,0,with,new,project,edge,k,vv,ev,join,filtered,vertices,where,1,equal,to,0,with,new,project,edge,k,vv,ev,return,new,graph,k,vv,ev,filtered,vertices,remaining,edges,this,context
Graph -> public Graph<K, VV, EV> filterOnVertices(FilterFunction<Vertex<K, VV>> vertexFilter);1454404649;Apply a filtering function to the graph and return a sub-graph that_satisfies the predicates only for the vertices.__@param vertexFilter the filter function for vertices._@return the resulting sub-graph.;public Graph<K, VV, EV> filterOnVertices(FilterFunction<Vertex<K, VV>> vertexFilter) {__		DataSet<Vertex<K, VV>> filteredVertices = this.vertices.filter(vertexFilter)___		DataSet<Edge<K, EV>> remainingEdges = this.edges.join(filteredVertices)_				.where(0).equalTo(0).with(new ProjectEdge<K, VV, EV>())_				.join(filteredVertices).where(1).equalTo(0)_				.with(new ProjectEdge<K, VV, EV>())___		return new Graph<K, VV, EV>(filteredVertices, remainingEdges, this.context)__	};apply,a,filtering,function,to,the,graph,and,return,a,sub,graph,that,satisfies,the,predicates,only,for,the,vertices,param,vertex,filter,the,filter,function,for,vertices,return,the,resulting,sub,graph;public,graph,k,vv,ev,filter,on,vertices,filter,function,vertex,k,vv,vertex,filter,data,set,vertex,k,vv,filtered,vertices,this,vertices,filter,vertex,filter,data,set,edge,k,ev,remaining,edges,this,edges,join,filtered,vertices,where,0,equal,to,0,with,new,project,edge,k,vv,ev,join,filtered,vertices,where,1,equal,to,0,with,new,project,edge,k,vv,ev,return,new,graph,k,vv,ev,filtered,vertices,remaining,edges,this,context
Graph -> public Graph<K, VV, EV> filterOnVertices(FilterFunction<Vertex<K, VV>> vertexFilter);1458583829;Apply a filtering function to the graph and return a sub-graph that_satisfies the predicates only for the vertices.__@param vertexFilter the filter function for vertices._@return the resulting sub-graph.;public Graph<K, VV, EV> filterOnVertices(FilterFunction<Vertex<K, VV>> vertexFilter) {__		DataSet<Vertex<K, VV>> filteredVertices = this.vertices.filter(vertexFilter)___		DataSet<Edge<K, EV>> remainingEdges = this.edges.join(filteredVertices)_				.where(0).equalTo(0).with(new ProjectEdge<K, VV, EV>())_				.join(filteredVertices).where(1).equalTo(0)_				.with(new ProjectEdge<K, VV, EV>())___		return new Graph<K, VV, EV>(filteredVertices, remainingEdges, this.context)__	};apply,a,filtering,function,to,the,graph,and,return,a,sub,graph,that,satisfies,the,predicates,only,for,the,vertices,param,vertex,filter,the,filter,function,for,vertices,return,the,resulting,sub,graph;public,graph,k,vv,ev,filter,on,vertices,filter,function,vertex,k,vv,vertex,filter,data,set,vertex,k,vv,filtered,vertices,this,vertices,filter,vertex,filter,data,set,edge,k,ev,remaining,edges,this,edges,join,filtered,vertices,where,0,equal,to,0,with,new,project,edge,k,vv,ev,join,filtered,vertices,where,1,equal,to,0,with,new,project,edge,k,vv,ev,return,new,graph,k,vv,ev,filtered,vertices,remaining,edges,this,context
Graph -> public Graph<K, VV, EV> filterOnVertices(FilterFunction<Vertex<K, VV>> vertexFilter);1458583829;Apply a filtering function to the graph and return a sub-graph that_satisfies the predicates only for the vertices.__@param vertexFilter the filter function for vertices._@return the resulting sub-graph.;public Graph<K, VV, EV> filterOnVertices(FilterFunction<Vertex<K, VV>> vertexFilter) {__		DataSet<Vertex<K, VV>> filteredVertices = this.vertices.filter(vertexFilter)___		DataSet<Edge<K, EV>> remainingEdges = this.edges.join(filteredVertices)_				.where(0).equalTo(0).with(new ProjectEdge<K, VV, EV>())_				.join(filteredVertices).where(1).equalTo(0)_				.with(new ProjectEdge<K, VV, EV>())___		return new Graph<K, VV, EV>(filteredVertices, remainingEdges, this.context)__	};apply,a,filtering,function,to,the,graph,and,return,a,sub,graph,that,satisfies,the,predicates,only,for,the,vertices,param,vertex,filter,the,filter,function,for,vertices,return,the,resulting,sub,graph;public,graph,k,vv,ev,filter,on,vertices,filter,function,vertex,k,vv,vertex,filter,data,set,vertex,k,vv,filtered,vertices,this,vertices,filter,vertex,filter,data,set,edge,k,ev,remaining,edges,this,edges,join,filtered,vertices,where,0,equal,to,0,with,new,project,edge,k,vv,ev,join,filtered,vertices,where,1,equal,to,0,with,new,project,edge,k,vv,ev,return,new,graph,k,vv,ev,filtered,vertices,remaining,edges,this,context
Graph -> public Graph<K, VV, EV> filterOnVertices(FilterFunction<Vertex<K, VV>> vertexFilter);1462100316;Apply a filtering function to the graph and return a sub-graph that_satisfies the predicates only for the vertices.__@param vertexFilter the filter function for vertices._@return the resulting sub-graph.;public Graph<K, VV, EV> filterOnVertices(FilterFunction<Vertex<K, VV>> vertexFilter) {__		DataSet<Vertex<K, VV>> filteredVertices = this.vertices.filter(vertexFilter)___		DataSet<Edge<K, EV>> remainingEdges = this.edges.join(filteredVertices)_				.where(0).equalTo(0).with(new ProjectEdge<K, VV, EV>())_				.join(filteredVertices).where(1).equalTo(0)_				.with(new ProjectEdge<K, VV, EV>())___		return new Graph<K, VV, EV>(filteredVertices, remainingEdges, this.context)__	};apply,a,filtering,function,to,the,graph,and,return,a,sub,graph,that,satisfies,the,predicates,only,for,the,vertices,param,vertex,filter,the,filter,function,for,vertices,return,the,resulting,sub,graph;public,graph,k,vv,ev,filter,on,vertices,filter,function,vertex,k,vv,vertex,filter,data,set,vertex,k,vv,filtered,vertices,this,vertices,filter,vertex,filter,data,set,edge,k,ev,remaining,edges,this,edges,join,filtered,vertices,where,0,equal,to,0,with,new,project,edge,k,vv,ev,join,filtered,vertices,where,1,equal,to,0,with,new,project,edge,k,vv,ev,return,new,graph,k,vv,ev,filtered,vertices,remaining,edges,this,context
Graph -> public Graph<K, VV, EV> filterOnVertices(FilterFunction<Vertex<K, VV>> vertexFilter);1462100316;Apply a filtering function to the graph and return a sub-graph that_satisfies the predicates only for the vertices.__@param vertexFilter the filter function for vertices._@return the resulting sub-graph.;public Graph<K, VV, EV> filterOnVertices(FilterFunction<Vertex<K, VV>> vertexFilter) {__		DataSet<Vertex<K, VV>> filteredVertices = this.vertices.filter(vertexFilter)___		DataSet<Edge<K, EV>> remainingEdges = this.edges.join(filteredVertices)_				.where(0).equalTo(0).with(new ProjectEdge<K, VV, EV>())_				.join(filteredVertices).where(1).equalTo(0)_				.with(new ProjectEdge<K, VV, EV>())___		return new Graph<K, VV, EV>(filteredVertices, remainingEdges, this.context)__	};apply,a,filtering,function,to,the,graph,and,return,a,sub,graph,that,satisfies,the,predicates,only,for,the,vertices,param,vertex,filter,the,filter,function,for,vertices,return,the,resulting,sub,graph;public,graph,k,vv,ev,filter,on,vertices,filter,function,vertex,k,vv,vertex,filter,data,set,vertex,k,vv,filtered,vertices,this,vertices,filter,vertex,filter,data,set,edge,k,ev,remaining,edges,this,edges,join,filtered,vertices,where,0,equal,to,0,with,new,project,edge,k,vv,ev,join,filtered,vertices,where,1,equal,to,0,with,new,project,edge,k,vv,ev,return,new,graph,k,vv,ev,filtered,vertices,remaining,edges,this,context
Graph -> public Graph<K, VV, EV> filterOnVertices(FilterFunction<Vertex<K, VV>> vertexFilter);1462205213;Apply a filtering function to the graph and return a sub-graph that_satisfies the predicates only for the vertices.__@param vertexFilter the filter function for vertices._@return the resulting sub-graph.;public Graph<K, VV, EV> filterOnVertices(FilterFunction<Vertex<K, VV>> vertexFilter) {__		DataSet<Vertex<K, VV>> filteredVertices = this.vertices.filter(vertexFilter)___		DataSet<Edge<K, EV>> remainingEdges = this.edges.join(filteredVertices)_				.where(0).equalTo(0).with(new ProjectEdge<K, VV, EV>())_				.join(filteredVertices).where(1).equalTo(0)_				.with(new ProjectEdge<K, VV, EV>())___		return new Graph<K, VV, EV>(filteredVertices, remainingEdges, this.context)__	};apply,a,filtering,function,to,the,graph,and,return,a,sub,graph,that,satisfies,the,predicates,only,for,the,vertices,param,vertex,filter,the,filter,function,for,vertices,return,the,resulting,sub,graph;public,graph,k,vv,ev,filter,on,vertices,filter,function,vertex,k,vv,vertex,filter,data,set,vertex,k,vv,filtered,vertices,this,vertices,filter,vertex,filter,data,set,edge,k,ev,remaining,edges,this,edges,join,filtered,vertices,where,0,equal,to,0,with,new,project,edge,k,vv,ev,join,filtered,vertices,where,1,equal,to,0,with,new,project,edge,k,vv,ev,return,new,graph,k,vv,ev,filtered,vertices,remaining,edges,this,context
Graph -> public Graph<K, VV, EV> filterOnVertices(FilterFunction<Vertex<K, VV>> vertexFilter);1462208859;Apply a filtering function to the graph and return a sub-graph that_satisfies the predicates only for the vertices.__@param vertexFilter the filter function for vertices._@return the resulting sub-graph.;public Graph<K, VV, EV> filterOnVertices(FilterFunction<Vertex<K, VV>> vertexFilter) {__		DataSet<Vertex<K, VV>> filteredVertices = this.vertices.filter(vertexFilter)___		DataSet<Edge<K, EV>> remainingEdges = this.edges.join(filteredVertices)_				.where(0).equalTo(0).with(new ProjectEdge<K, VV, EV>())_				.join(filteredVertices).where(1).equalTo(0)_				.with(new ProjectEdge<K, VV, EV>())___		return new Graph<K, VV, EV>(filteredVertices, remainingEdges, this.context)__	};apply,a,filtering,function,to,the,graph,and,return,a,sub,graph,that,satisfies,the,predicates,only,for,the,vertices,param,vertex,filter,the,filter,function,for,vertices,return,the,resulting,sub,graph;public,graph,k,vv,ev,filter,on,vertices,filter,function,vertex,k,vv,vertex,filter,data,set,vertex,k,vv,filtered,vertices,this,vertices,filter,vertex,filter,data,set,edge,k,ev,remaining,edges,this,edges,join,filtered,vertices,where,0,equal,to,0,with,new,project,edge,k,vv,ev,join,filtered,vertices,where,1,equal,to,0,with,new,project,edge,k,vv,ev,return,new,graph,k,vv,ev,filtered,vertices,remaining,edges,this,context
Graph -> public Graph<K, VV, EV> filterOnVertices(FilterFunction<Vertex<K, VV>> vertexFilter);1462809297;Apply a filtering function to the graph and return a sub-graph that_satisfies the predicates only for the vertices.__@param vertexFilter the filter function for vertices._@return the resulting sub-graph.;public Graph<K, VV, EV> filterOnVertices(FilterFunction<Vertex<K, VV>> vertexFilter) {__		DataSet<Vertex<K, VV>> filteredVertices = this.vertices.filter(vertexFilter)___		DataSet<Edge<K, EV>> remainingEdges = this.edges.join(filteredVertices)_				.where(0).equalTo(0).with(new ProjectEdge<K, VV, EV>())_				.join(filteredVertices).where(1).equalTo(0)_				.with(new ProjectEdge<K, VV, EV>())___		return new Graph<K, VV, EV>(filteredVertices, remainingEdges, this.context)__	};apply,a,filtering,function,to,the,graph,and,return,a,sub,graph,that,satisfies,the,predicates,only,for,the,vertices,param,vertex,filter,the,filter,function,for,vertices,return,the,resulting,sub,graph;public,graph,k,vv,ev,filter,on,vertices,filter,function,vertex,k,vv,vertex,filter,data,set,vertex,k,vv,filtered,vertices,this,vertices,filter,vertex,filter,data,set,edge,k,ev,remaining,edges,this,edges,join,filtered,vertices,where,0,equal,to,0,with,new,project,edge,k,vv,ev,join,filtered,vertices,where,1,equal,to,0,with,new,project,edge,k,vv,ev,return,new,graph,k,vv,ev,filtered,vertices,remaining,edges,this,context
Graph -> public Graph<K, VV, EV> filterOnVertices(FilterFunction<Vertex<K, VV>> vertexFilter);1465316775;Apply a filtering function to the graph and return a sub-graph that_satisfies the predicates only for the vertices.__@param vertexFilter the filter function for vertices._@return the resulting sub-graph.;public Graph<K, VV, EV> filterOnVertices(FilterFunction<Vertex<K, VV>> vertexFilter) {__		DataSet<Vertex<K, VV>> filteredVertices = this.vertices.filter(vertexFilter)___		DataSet<Edge<K, EV>> remainingEdges = this.edges.join(filteredVertices)_				.where(0).equalTo(0).with(new ProjectEdge<K, VV, EV>())_				.join(filteredVertices).where(1).equalTo(0)_				.with(new ProjectEdge<K, VV, EV>())___		return new Graph<K, VV, EV>(filteredVertices, remainingEdges, this.context)__	};apply,a,filtering,function,to,the,graph,and,return,a,sub,graph,that,satisfies,the,predicates,only,for,the,vertices,param,vertex,filter,the,filter,function,for,vertices,return,the,resulting,sub,graph;public,graph,k,vv,ev,filter,on,vertices,filter,function,vertex,k,vv,vertex,filter,data,set,vertex,k,vv,filtered,vertices,this,vertices,filter,vertex,filter,data,set,edge,k,ev,remaining,edges,this,edges,join,filtered,vertices,where,0,equal,to,0,with,new,project,edge,k,vv,ev,join,filtered,vertices,where,1,equal,to,0,with,new,project,edge,k,vv,ev,return,new,graph,k,vv,ev,filtered,vertices,remaining,edges,this,context
Graph -> public Graph<K, VV, EV> filterOnVertices(FilterFunction<Vertex<K, VV>> vertexFilter);1466789678;Apply a filtering function to the graph and return a sub-graph that_satisfies the predicates only for the vertices.__@param vertexFilter the filter function for vertices._@return the resulting sub-graph.;public Graph<K, VV, EV> filterOnVertices(FilterFunction<Vertex<K, VV>> vertexFilter) {__		DataSet<Vertex<K, VV>> filteredVertices = this.vertices.filter(vertexFilter)___		DataSet<Edge<K, EV>> remainingEdges = this.edges.join(filteredVertices)_				.where(0).equalTo(0).with(new ProjectEdge<K, VV, EV>())_				.join(filteredVertices).where(1).equalTo(0)_				.with(new ProjectEdge<K, VV, EV>())___		return new Graph<K, VV, EV>(filteredVertices, remainingEdges, this.context)__	};apply,a,filtering,function,to,the,graph,and,return,a,sub,graph,that,satisfies,the,predicates,only,for,the,vertices,param,vertex,filter,the,filter,function,for,vertices,return,the,resulting,sub,graph;public,graph,k,vv,ev,filter,on,vertices,filter,function,vertex,k,vv,vertex,filter,data,set,vertex,k,vv,filtered,vertices,this,vertices,filter,vertex,filter,data,set,edge,k,ev,remaining,edges,this,edges,join,filtered,vertices,where,0,equal,to,0,with,new,project,edge,k,vv,ev,join,filtered,vertices,where,1,equal,to,0,with,new,project,edge,k,vv,ev,return,new,graph,k,vv,ev,filtered,vertices,remaining,edges,this,context
Graph -> public Graph<K, VV, EV> filterOnVertices(FilterFunction<Vertex<K, VV>> vertexFilter);1467140656;Apply a filtering function to the graph and return a sub-graph that_satisfies the predicates only for the vertices.__@param vertexFilter the filter function for vertices._@return the resulting sub-graph.;public Graph<K, VV, EV> filterOnVertices(FilterFunction<Vertex<K, VV>> vertexFilter) {__		DataSet<Vertex<K, VV>> filteredVertices = this.vertices.filter(vertexFilter)___		DataSet<Edge<K, EV>> remainingEdges = this.edges.join(filteredVertices)_				.where(0).equalTo(0).with(new ProjectEdge<K, VV, EV>())_				.join(filteredVertices).where(1).equalTo(0)_				.with(new ProjectEdge<K, VV, EV>())___		return new Graph<K, VV, EV>(filteredVertices, remainingEdges, this.context)__	};apply,a,filtering,function,to,the,graph,and,return,a,sub,graph,that,satisfies,the,predicates,only,for,the,vertices,param,vertex,filter,the,filter,function,for,vertices,return,the,resulting,sub,graph;public,graph,k,vv,ev,filter,on,vertices,filter,function,vertex,k,vv,vertex,filter,data,set,vertex,k,vv,filtered,vertices,this,vertices,filter,vertex,filter,data,set,edge,k,ev,remaining,edges,this,edges,join,filtered,vertices,where,0,equal,to,0,with,new,project,edge,k,vv,ev,join,filtered,vertices,where,1,equal,to,0,with,new,project,edge,k,vv,ev,return,new,graph,k,vv,ev,filtered,vertices,remaining,edges,this,context
Graph -> public Graph<K, VV, EV> filterOnVertices(FilterFunction<Vertex<K, VV>> vertexFilter);1467306272;Apply a filtering function to the graph and return a sub-graph that_satisfies the predicates only for the vertices.__@param vertexFilter the filter function for vertices._@return the resulting sub-graph.;public Graph<K, VV, EV> filterOnVertices(FilterFunction<Vertex<K, VV>> vertexFilter) {__		DataSet<Vertex<K, VV>> filteredVertices = this.vertices.filter(vertexFilter)___		DataSet<Edge<K, EV>> remainingEdges = this.edges.join(filteredVertices)_				.where(0).equalTo(0).with(new ProjectEdge<K, VV, EV>())_				.join(filteredVertices).where(1).equalTo(0)_				.with(new ProjectEdge<K, VV, EV>())___		return new Graph<K, VV, EV>(filteredVertices, remainingEdges, this.context)__	};apply,a,filtering,function,to,the,graph,and,return,a,sub,graph,that,satisfies,the,predicates,only,for,the,vertices,param,vertex,filter,the,filter,function,for,vertices,return,the,resulting,sub,graph;public,graph,k,vv,ev,filter,on,vertices,filter,function,vertex,k,vv,vertex,filter,data,set,vertex,k,vv,filtered,vertices,this,vertices,filter,vertex,filter,data,set,edge,k,ev,remaining,edges,this,edges,join,filtered,vertices,where,0,equal,to,0,with,new,project,edge,k,vv,ev,join,filtered,vertices,where,1,equal,to,0,with,new,project,edge,k,vv,ev,return,new,graph,k,vv,ev,filtered,vertices,remaining,edges,this,context
Graph -> public Graph<K, VV, EV> filterOnVertices(FilterFunction<Vertex<K, VV>> vertexFilter);1470042815;Apply a filtering function to the graph and return a sub-graph that_satisfies the predicates only for the vertices.__@param vertexFilter the filter function for vertices._@return the resulting sub-graph.;public Graph<K, VV, EV> filterOnVertices(FilterFunction<Vertex<K, VV>> vertexFilter) {__		DataSet<Vertex<K, VV>> filteredVertices = this.vertices.filter(vertexFilter)___		DataSet<Edge<K, EV>> remainingEdges = this.edges.join(filteredVertices)_				.where(0).equalTo(0).with(new ProjectEdge<K, VV, EV>())_				.join(filteredVertices).where(1).equalTo(0)_				.with(new ProjectEdge<K, VV, EV>())___		return new Graph<K, VV, EV>(filteredVertices, remainingEdges, this.context)__	};apply,a,filtering,function,to,the,graph,and,return,a,sub,graph,that,satisfies,the,predicates,only,for,the,vertices,param,vertex,filter,the,filter,function,for,vertices,return,the,resulting,sub,graph;public,graph,k,vv,ev,filter,on,vertices,filter,function,vertex,k,vv,vertex,filter,data,set,vertex,k,vv,filtered,vertices,this,vertices,filter,vertex,filter,data,set,edge,k,ev,remaining,edges,this,edges,join,filtered,vertices,where,0,equal,to,0,with,new,project,edge,k,vv,ev,join,filtered,vertices,where,1,equal,to,0,with,new,project,edge,k,vv,ev,return,new,graph,k,vv,ev,filtered,vertices,remaining,edges,this,context
Graph -> public Graph<K, VV, EV> filterOnVertices(FilterFunction<Vertex<K, VV>> vertexFilter);1475684776;Apply a filtering function to the graph and return a sub-graph that_satisfies the predicates only for the vertices.__@param vertexFilter the filter function for vertices._@return the resulting sub-graph.;public Graph<K, VV, EV> filterOnVertices(FilterFunction<Vertex<K, VV>> vertexFilter) {__		DataSet<Vertex<K, VV>> filteredVertices = this.vertices.filter(vertexFilter)___		DataSet<Edge<K, EV>> remainingEdges = this.edges.join(filteredVertices)_				.where(0).equalTo(0).with(new ProjectEdge<K, VV, EV>())_				.join(filteredVertices).where(1).equalTo(0)_				.with(new ProjectEdge<K, VV, EV>())___		return new Graph<>(filteredVertices, remainingEdges, this.context)__	};apply,a,filtering,function,to,the,graph,and,return,a,sub,graph,that,satisfies,the,predicates,only,for,the,vertices,param,vertex,filter,the,filter,function,for,vertices,return,the,resulting,sub,graph;public,graph,k,vv,ev,filter,on,vertices,filter,function,vertex,k,vv,vertex,filter,data,set,vertex,k,vv,filtered,vertices,this,vertices,filter,vertex,filter,data,set,edge,k,ev,remaining,edges,this,edges,join,filtered,vertices,where,0,equal,to,0,with,new,project,edge,k,vv,ev,join,filtered,vertices,where,1,equal,to,0,with,new,project,edge,k,vv,ev,return,new,graph,filtered,vertices,remaining,edges,this,context
Graph -> public Graph<K, VV, EV> filterOnVertices(FilterFunction<Vertex<K, VV>> vertexFilter);1475685606;Apply a filtering function to the graph and return a sub-graph that_satisfies the predicates only for the vertices.__@param vertexFilter the filter function for vertices._@return the resulting sub-graph.;public Graph<K, VV, EV> filterOnVertices(FilterFunction<Vertex<K, VV>> vertexFilter) {__		DataSet<Vertex<K, VV>> filteredVertices = this.vertices.filter(vertexFilter)___		DataSet<Edge<K, EV>> remainingEdges = this.edges.join(filteredVertices)_				.where(0).equalTo(0).with(new ProjectEdge<K, VV, EV>())_				.join(filteredVertices).where(1).equalTo(0)_				.with(new ProjectEdge<K, VV, EV>())___		return new Graph<>(filteredVertices, remainingEdges, this.context)__	};apply,a,filtering,function,to,the,graph,and,return,a,sub,graph,that,satisfies,the,predicates,only,for,the,vertices,param,vertex,filter,the,filter,function,for,vertices,return,the,resulting,sub,graph;public,graph,k,vv,ev,filter,on,vertices,filter,function,vertex,k,vv,vertex,filter,data,set,vertex,k,vv,filtered,vertices,this,vertices,filter,vertex,filter,data,set,edge,k,ev,remaining,edges,this,edges,join,filtered,vertices,where,0,equal,to,0,with,new,project,edge,k,vv,ev,join,filtered,vertices,where,1,equal,to,0,with,new,project,edge,k,vv,ev,return,new,graph,filtered,vertices,remaining,edges,this,context
Graph -> public Graph<K, VV, EV> filterOnVertices(FilterFunction<Vertex<K, VV>> vertexFilter);1481745825;Apply a filtering function to the graph and return a sub-graph that_satisfies the predicates only for the vertices.__@param vertexFilter the filter function for vertices._@return the resulting sub-graph.;public Graph<K, VV, EV> filterOnVertices(FilterFunction<Vertex<K, VV>> vertexFilter) {__		DataSet<Vertex<K, VV>> filteredVertices = this.vertices.filter(vertexFilter)___		DataSet<Edge<K, EV>> remainingEdges = this.edges.join(filteredVertices)_				.where(0).equalTo(0).with(new ProjectEdge<K, VV, EV>())_				.join(filteredVertices).where(1).equalTo(0)_				.with(new ProjectEdge<K, VV, EV>()).name("Filter on vertices")___		return new Graph<>(filteredVertices, remainingEdges, this.context)__	};apply,a,filtering,function,to,the,graph,and,return,a,sub,graph,that,satisfies,the,predicates,only,for,the,vertices,param,vertex,filter,the,filter,function,for,vertices,return,the,resulting,sub,graph;public,graph,k,vv,ev,filter,on,vertices,filter,function,vertex,k,vv,vertex,filter,data,set,vertex,k,vv,filtered,vertices,this,vertices,filter,vertex,filter,data,set,edge,k,ev,remaining,edges,this,edges,join,filtered,vertices,where,0,equal,to,0,with,new,project,edge,k,vv,ev,join,filtered,vertices,where,1,equal,to,0,with,new,project,edge,k,vv,ev,name,filter,on,vertices,return,new,graph,filtered,vertices,remaining,edges,this,context
Graph -> public Graph<K, VV, EV> filterOnVertices(FilterFunction<Vertex<K, VV>> vertexFilter);1481881009;Apply a filtering function to the graph and return a sub-graph that_satisfies the predicates only for the vertices.__@param vertexFilter the filter function for vertices._@return the resulting sub-graph.;public Graph<K, VV, EV> filterOnVertices(FilterFunction<Vertex<K, VV>> vertexFilter) {__		DataSet<Vertex<K, VV>> filteredVertices = this.vertices.filter(vertexFilter)___		DataSet<Edge<K, EV>> remainingEdges = this.edges.join(filteredVertices)_				.where(0).equalTo(0).with(new ProjectEdge<K, VV, EV>())_				.join(filteredVertices).where(1).equalTo(0)_				.with(new ProjectEdge<K, VV, EV>()).name("Filter on vertices")___		return new Graph<>(filteredVertices, remainingEdges, this.context)__	};apply,a,filtering,function,to,the,graph,and,return,a,sub,graph,that,satisfies,the,predicates,only,for,the,vertices,param,vertex,filter,the,filter,function,for,vertices,return,the,resulting,sub,graph;public,graph,k,vv,ev,filter,on,vertices,filter,function,vertex,k,vv,vertex,filter,data,set,vertex,k,vv,filtered,vertices,this,vertices,filter,vertex,filter,data,set,edge,k,ev,remaining,edges,this,edges,join,filtered,vertices,where,0,equal,to,0,with,new,project,edge,k,vv,ev,join,filtered,vertices,where,1,equal,to,0,with,new,project,edge,k,vv,ev,name,filter,on,vertices,return,new,graph,filtered,vertices,remaining,edges,this,context
Graph -> public Graph<K, VV, EV> filterOnVertices(FilterFunction<Vertex<K, VV>> vertexFilter);1484160227;Apply a filtering function to the graph and return a sub-graph that_satisfies the predicates only for the vertices.__@param vertexFilter the filter function for vertices._@return the resulting sub-graph.;public Graph<K, VV, EV> filterOnVertices(FilterFunction<Vertex<K, VV>> vertexFilter) {__		DataSet<Vertex<K, VV>> filteredVertices = this.vertices.filter(vertexFilter)___		DataSet<Edge<K, EV>> remainingEdges = this.edges.join(filteredVertices)_				.where(0).equalTo(0).with(new ProjectEdge<K, VV, EV>())_				.join(filteredVertices).where(1).equalTo(0)_				.with(new ProjectEdge<K, VV, EV>()).name("Filter on vertices")___		return new Graph<>(filteredVertices, remainingEdges, this.context)__	};apply,a,filtering,function,to,the,graph,and,return,a,sub,graph,that,satisfies,the,predicates,only,for,the,vertices,param,vertex,filter,the,filter,function,for,vertices,return,the,resulting,sub,graph;public,graph,k,vv,ev,filter,on,vertices,filter,function,vertex,k,vv,vertex,filter,data,set,vertex,k,vv,filtered,vertices,this,vertices,filter,vertex,filter,data,set,edge,k,ev,remaining,edges,this,edges,join,filtered,vertices,where,0,equal,to,0,with,new,project,edge,k,vv,ev,join,filtered,vertices,where,1,equal,to,0,with,new,project,edge,k,vv,ev,name,filter,on,vertices,return,new,graph,filtered,vertices,remaining,edges,this,context
Graph -> public Graph<K, VV, EV> filterOnVertices(FilterFunction<Vertex<K, VV>> vertexFilter);1484685504;Apply a filtering function to the graph and return a sub-graph that_satisfies the predicates only for the vertices.__@param vertexFilter the filter function for vertices._@return the resulting sub-graph.;public Graph<K, VV, EV> filterOnVertices(FilterFunction<Vertex<K, VV>> vertexFilter) {__		DataSet<Vertex<K, VV>> filteredVertices = this.vertices.filter(vertexFilter)___		DataSet<Edge<K, EV>> remainingEdges = this.edges.join(filteredVertices)_				.where(0).equalTo(0).with(new ProjectEdge<K, VV, EV>())_				.join(filteredVertices).where(1).equalTo(0)_				.with(new ProjectEdge<K, VV, EV>()).name("Filter on vertices")___		return new Graph<>(filteredVertices, remainingEdges, this.context)__	};apply,a,filtering,function,to,the,graph,and,return,a,sub,graph,that,satisfies,the,predicates,only,for,the,vertices,param,vertex,filter,the,filter,function,for,vertices,return,the,resulting,sub,graph;public,graph,k,vv,ev,filter,on,vertices,filter,function,vertex,k,vv,vertex,filter,data,set,vertex,k,vv,filtered,vertices,this,vertices,filter,vertex,filter,data,set,edge,k,ev,remaining,edges,this,edges,join,filtered,vertices,where,0,equal,to,0,with,new,project,edge,k,vv,ev,join,filtered,vertices,where,1,equal,to,0,with,new,project,edge,k,vv,ev,name,filter,on,vertices,return,new,graph,filtered,vertices,remaining,edges,this,context
Graph -> public Graph<K, VV, EV> filterOnVertices(FilterFunction<Vertex<K, VV>> vertexFilter);1489068942;Apply a filtering function to the graph and return a sub-graph that_satisfies the predicates only for the vertices.__@param vertexFilter the filter function for vertices._@return the resulting sub-graph.;public Graph<K, VV, EV> filterOnVertices(FilterFunction<Vertex<K, VV>> vertexFilter) {__		DataSet<Vertex<K, VV>> filteredVertices = this.vertices.filter(vertexFilter)___		DataSet<Edge<K, EV>> remainingEdges = this.edges.join(filteredVertices)_				.where(0).equalTo(0).with(new ProjectEdge<K, VV, EV>())_				.join(filteredVertices).where(1).equalTo(0)_				.with(new ProjectEdge<K, VV, EV>()).name("Filter on vertices")___		return new Graph<>(filteredVertices, remainingEdges, this.context)__	};apply,a,filtering,function,to,the,graph,and,return,a,sub,graph,that,satisfies,the,predicates,only,for,the,vertices,param,vertex,filter,the,filter,function,for,vertices,return,the,resulting,sub,graph;public,graph,k,vv,ev,filter,on,vertices,filter,function,vertex,k,vv,vertex,filter,data,set,vertex,k,vv,filtered,vertices,this,vertices,filter,vertex,filter,data,set,edge,k,ev,remaining,edges,this,edges,join,filtered,vertices,where,0,equal,to,0,with,new,project,edge,k,vv,ev,join,filtered,vertices,where,1,equal,to,0,with,new,project,edge,k,vv,ev,name,filter,on,vertices,return,new,graph,filtered,vertices,remaining,edges,this,context
Graph -> public Graph<K, VV, EV> filterOnVertices(FilterFunction<Vertex<K, VV>> vertexFilter);1490973446;Apply a filtering function to the graph and return a sub-graph that_satisfies the predicates only for the vertices.__@param vertexFilter the filter function for vertices._@return the resulting sub-graph.;public Graph<K, VV, EV> filterOnVertices(FilterFunction<Vertex<K, VV>> vertexFilter) {__		DataSet<Vertex<K, VV>> filteredVertices = this.vertices.filter(vertexFilter)___		DataSet<Edge<K, EV>> remainingEdges = this.edges.join(filteredVertices)_				.where(0).equalTo(0).with(new ProjectEdge<K, VV, EV>())_				.join(filteredVertices).where(1).equalTo(0)_				.with(new ProjectEdge<K, VV, EV>()).name("Filter on vertices")___		return new Graph<>(filteredVertices, remainingEdges, this.context)__	};apply,a,filtering,function,to,the,graph,and,return,a,sub,graph,that,satisfies,the,predicates,only,for,the,vertices,param,vertex,filter,the,filter,function,for,vertices,return,the,resulting,sub,graph;public,graph,k,vv,ev,filter,on,vertices,filter,function,vertex,k,vv,vertex,filter,data,set,vertex,k,vv,filtered,vertices,this,vertices,filter,vertex,filter,data,set,edge,k,ev,remaining,edges,this,edges,join,filtered,vertices,where,0,equal,to,0,with,new,project,edge,k,vv,ev,join,filtered,vertices,where,1,equal,to,0,with,new,project,edge,k,vv,ev,name,filter,on,vertices,return,new,graph,filtered,vertices,remaining,edges,this,context
Graph -> public Graph<K, VV, EV> filterOnVertices(FilterFunction<Vertex<K, VV>> vertexFilter);1495819075;Apply a filtering function to the graph and return a sub-graph that_satisfies the predicates only for the vertices.__@param vertexFilter the filter function for vertices._@return the resulting sub-graph.;public Graph<K, VV, EV> filterOnVertices(FilterFunction<Vertex<K, VV>> vertexFilter) {__		DataSet<Vertex<K, VV>> filteredVertices = this.vertices.filter(vertexFilter)___		DataSet<Edge<K, EV>> remainingEdges = this.edges.join(filteredVertices)_				.where(0).equalTo(0).with(new ProjectEdge<K, VV, EV>())_				.join(filteredVertices).where(1).equalTo(0)_				.with(new ProjectEdge<K, VV, EV>()).name("Filter on vertices")___		return new Graph<>(filteredVertices, remainingEdges, this.context)__	};apply,a,filtering,function,to,the,graph,and,return,a,sub,graph,that,satisfies,the,predicates,only,for,the,vertices,param,vertex,filter,the,filter,function,for,vertices,return,the,resulting,sub,graph;public,graph,k,vv,ev,filter,on,vertices,filter,function,vertex,k,vv,vertex,filter,data,set,vertex,k,vv,filtered,vertices,this,vertices,filter,vertex,filter,data,set,edge,k,ev,remaining,edges,this,edges,join,filtered,vertices,where,0,equal,to,0,with,new,project,edge,k,vv,ev,join,filtered,vertices,where,1,equal,to,0,with,new,project,edge,k,vv,ev,name,filter,on,vertices,return,new,graph,filtered,vertices,remaining,edges,this,context
Graph -> public Graph<K, VV, EV> filterOnVertices(FilterFunction<Vertex<K, VV>> vertexFilter);1502111816;Apply a filtering function to the graph and return a sub-graph that_satisfies the predicates only for the vertices.__@param vertexFilter the filter function for vertices._@return the resulting sub-graph.;public Graph<K, VV, EV> filterOnVertices(FilterFunction<Vertex<K, VV>> vertexFilter) {__		DataSet<Vertex<K, VV>> filteredVertices = this.vertices.filter(vertexFilter)___		DataSet<Edge<K, EV>> remainingEdges = this.edges.join(filteredVertices)_				.where(0).equalTo(0).with(new ProjectEdge<>())_				.join(filteredVertices).where(1).equalTo(0)_				.with(new ProjectEdge<>()).name("Filter on vertices")___		return new Graph<>(filteredVertices, remainingEdges, this.context)__	};apply,a,filtering,function,to,the,graph,and,return,a,sub,graph,that,satisfies,the,predicates,only,for,the,vertices,param,vertex,filter,the,filter,function,for,vertices,return,the,resulting,sub,graph;public,graph,k,vv,ev,filter,on,vertices,filter,function,vertex,k,vv,vertex,filter,data,set,vertex,k,vv,filtered,vertices,this,vertices,filter,vertex,filter,data,set,edge,k,ev,remaining,edges,this,edges,join,filtered,vertices,where,0,equal,to,0,with,new,project,edge,join,filtered,vertices,where,1,equal,to,0,with,new,project,edge,name,filter,on,vertices,return,new,graph,filtered,vertices,remaining,edges,this,context
Graph -> public <NEW> Graph<K, NEW, EV> translateVertexValues(MapFunction<VV, NEW> translator) throws Exception;1462205213;Translate {@link Vertex} values using the given {@link MapFunction}.__@param translator implements conversion from {@code VV} to {@code NEW}_@param <NEW> new vertex value type_@return graph with translated vertex values_@throws Exception;public <NEW> Graph<K, NEW, EV> translateVertexValues(MapFunction<VV, NEW> translator) throws Exception {_		return run(new TranslateVertexValues<K, VV, NEW, EV>(translator))__	};translate,link,vertex,values,using,the,given,link,map,function,param,translator,implements,conversion,from,code,vv,to,code,new,param,new,new,vertex,value,type,return,graph,with,translated,vertex,values,throws,exception;public,new,graph,k,new,ev,translate,vertex,values,map,function,vv,new,translator,throws,exception,return,run,new,translate,vertex,values,k,vv,new,ev,translator
Graph -> public <NEW> Graph<K, NEW, EV> translateVertexValues(MapFunction<VV, NEW> translator) throws Exception;1462208859;Translate {@link Vertex} values using the given {@link MapFunction}.__@param translator implements conversion from {@code VV} to {@code NEW}_@param <NEW> new vertex value type_@return graph with translated vertex values_@throws Exception;public <NEW> Graph<K, NEW, EV> translateVertexValues(MapFunction<VV, NEW> translator) throws Exception {_		return run(new TranslateVertexValues<K, VV, NEW, EV>(translator))__	};translate,link,vertex,values,using,the,given,link,map,function,param,translator,implements,conversion,from,code,vv,to,code,new,param,new,new,vertex,value,type,return,graph,with,translated,vertex,values,throws,exception;public,new,graph,k,new,ev,translate,vertex,values,map,function,vv,new,translator,throws,exception,return,run,new,translate,vertex,values,k,vv,new,ev,translator
Graph -> public Graph<K, VV, EV> removeVertices(List<Vertex<K, VV>> verticesToBeRemoved);1444404795;Removes the given list of vertices and its edges from the graph.__@param verticesToBeRemoved the list of vertices to be removed_@return the resulted graph containing the initial vertices and edges minus the vertices_and edges removed.;public Graph<K, VV, EV> removeVertices(List<Vertex<K, VV>> verticesToBeRemoved)_	{_		return removeVertices(this.context.fromCollection(verticesToBeRemoved))__	};removes,the,given,list,of,vertices,and,its,edges,from,the,graph,param,vertices,to,be,removed,the,list,of,vertices,to,be,removed,return,the,resulted,graph,containing,the,initial,vertices,and,edges,minus,the,vertices,and,edges,removed;public,graph,k,vv,ev,remove,vertices,list,vertex,k,vv,vertices,to,be,removed,return,remove,vertices,this,context,from,collection,vertices,to,be,removed
Graph -> public Graph<K, VV, EV> removeVertices(List<Vertex<K, VV>> verticesToBeRemoved);1445261977;Removes the given list of vertices and its edges from the graph.__@param verticesToBeRemoved the list of vertices to be removed_@return the resulted graph containing the initial vertices and edges minus the vertices_and edges removed.;public Graph<K, VV, EV> removeVertices(List<Vertex<K, VV>> verticesToBeRemoved)_	{_		return removeVertices(this.context.fromCollection(verticesToBeRemoved))__	};removes,the,given,list,of,vertices,and,its,edges,from,the,graph,param,vertices,to,be,removed,the,list,of,vertices,to,be,removed,return,the,resulted,graph,containing,the,initial,vertices,and,edges,minus,the,vertices,and,edges,removed;public,graph,k,vv,ev,remove,vertices,list,vertex,k,vv,vertices,to,be,removed,return,remove,vertices,this,context,from,collection,vertices,to,be,removed
Graph -> public Graph<K, VV, EV> removeVertices(List<Vertex<K, VV>> verticesToBeRemoved);1445854323;Removes the given list of vertices and its edges from the graph.__@param verticesToBeRemoved the list of vertices to be removed_@return the resulted graph containing the initial vertices and edges minus the vertices_and edges removed.;public Graph<K, VV, EV> removeVertices(List<Vertex<K, VV>> verticesToBeRemoved)_	{_		return removeVertices(this.context.fromCollection(verticesToBeRemoved))__	};removes,the,given,list,of,vertices,and,its,edges,from,the,graph,param,vertices,to,be,removed,the,list,of,vertices,to,be,removed,return,the,resulted,graph,containing,the,initial,vertices,and,edges,minus,the,vertices,and,edges,removed;public,graph,k,vv,ev,remove,vertices,list,vertex,k,vv,vertices,to,be,removed,return,remove,vertices,this,context,from,collection,vertices,to,be,removed
Graph -> public Graph<K, VV, EV> removeVertices(List<Vertex<K, VV>> verticesToBeRemoved);1446112342;Removes the given list of vertices and its edges from the graph.__@param verticesToBeRemoved the list of vertices to be removed_@return the resulted graph containing the initial vertices and edges minus the vertices_and edges removed.;public Graph<K, VV, EV> removeVertices(List<Vertex<K, VV>> verticesToBeRemoved)_	{_		return removeVertices(this.context.fromCollection(verticesToBeRemoved))__	};removes,the,given,list,of,vertices,and,its,edges,from,the,graph,param,vertices,to,be,removed,the,list,of,vertices,to,be,removed,return,the,resulted,graph,containing,the,initial,vertices,and,edges,minus,the,vertices,and,edges,removed;public,graph,k,vv,ev,remove,vertices,list,vertex,k,vv,vertices,to,be,removed,return,remove,vertices,this,context,from,collection,vertices,to,be,removed
Graph -> public Graph<K, VV, EV> removeVertices(List<Vertex<K, VV>> verticesToBeRemoved);1447073368;Removes the given list of vertices and its edges from the graph.__@param verticesToBeRemoved the list of vertices to be removed_@return the resulted graph containing the initial vertices and edges minus the vertices_and edges removed.;public Graph<K, VV, EV> removeVertices(List<Vertex<K, VV>> verticesToBeRemoved)_	{_		return removeVertices(this.context.fromCollection(verticesToBeRemoved))__	};removes,the,given,list,of,vertices,and,its,edges,from,the,graph,param,vertices,to,be,removed,the,list,of,vertices,to,be,removed,return,the,resulted,graph,containing,the,initial,vertices,and,edges,minus,the,vertices,and,edges,removed;public,graph,k,vv,ev,remove,vertices,list,vertex,k,vv,vertices,to,be,removed,return,remove,vertices,this,context,from,collection,vertices,to,be,removed
Graph -> public Graph<K, VV, EV> removeVertices(List<Vertex<K, VV>> verticesToBeRemoved);1454404649;Removes the given list of vertices and its edges from the graph.__@param verticesToBeRemoved the list of vertices to be removed_@return the resulted graph containing the initial vertices and edges minus the vertices_and edges removed.;public Graph<K, VV, EV> removeVertices(List<Vertex<K, VV>> verticesToBeRemoved)_	{_		return removeVertices(this.context.fromCollection(verticesToBeRemoved))__	};removes,the,given,list,of,vertices,and,its,edges,from,the,graph,param,vertices,to,be,removed,the,list,of,vertices,to,be,removed,return,the,resulted,graph,containing,the,initial,vertices,and,edges,minus,the,vertices,and,edges,removed;public,graph,k,vv,ev,remove,vertices,list,vertex,k,vv,vertices,to,be,removed,return,remove,vertices,this,context,from,collection,vertices,to,be,removed
Graph -> public Graph<K, VV, EV> removeVertices(List<Vertex<K, VV>> verticesToBeRemoved);1458583829;Removes the given list of vertices and its edges from the graph.__@param verticesToBeRemoved the list of vertices to be removed_@return the resulted graph containing the initial vertices and edges minus the vertices_and edges removed.;public Graph<K, VV, EV> removeVertices(List<Vertex<K, VV>> verticesToBeRemoved)_	{_		return removeVertices(this.context.fromCollection(verticesToBeRemoved))__	};removes,the,given,list,of,vertices,and,its,edges,from,the,graph,param,vertices,to,be,removed,the,list,of,vertices,to,be,removed,return,the,resulted,graph,containing,the,initial,vertices,and,edges,minus,the,vertices,and,edges,removed;public,graph,k,vv,ev,remove,vertices,list,vertex,k,vv,vertices,to,be,removed,return,remove,vertices,this,context,from,collection,vertices,to,be,removed
Graph -> public Graph<K, VV, EV> removeVertices(List<Vertex<K, VV>> verticesToBeRemoved);1458583829;Removes the given list of vertices and its edges from the graph.__@param verticesToBeRemoved the list of vertices to be removed_@return the resulted graph containing the initial vertices and edges minus the vertices_and edges removed.;public Graph<K, VV, EV> removeVertices(List<Vertex<K, VV>> verticesToBeRemoved)_	{_		return removeVertices(this.context.fromCollection(verticesToBeRemoved))__	};removes,the,given,list,of,vertices,and,its,edges,from,the,graph,param,vertices,to,be,removed,the,list,of,vertices,to,be,removed,return,the,resulted,graph,containing,the,initial,vertices,and,edges,minus,the,vertices,and,edges,removed;public,graph,k,vv,ev,remove,vertices,list,vertex,k,vv,vertices,to,be,removed,return,remove,vertices,this,context,from,collection,vertices,to,be,removed
Graph -> public Graph<K, VV, EV> removeVertices(List<Vertex<K, VV>> verticesToBeRemoved);1462100316;Removes the given list of vertices and its edges from the graph.__@param verticesToBeRemoved the list of vertices to be removed_@return the resulted graph containing the initial vertices and edges minus the vertices_and edges removed.;public Graph<K, VV, EV> removeVertices(List<Vertex<K, VV>> verticesToBeRemoved)_	{_		return removeVertices(this.context.fromCollection(verticesToBeRemoved))__	};removes,the,given,list,of,vertices,and,its,edges,from,the,graph,param,vertices,to,be,removed,the,list,of,vertices,to,be,removed,return,the,resulted,graph,containing,the,initial,vertices,and,edges,minus,the,vertices,and,edges,removed;public,graph,k,vv,ev,remove,vertices,list,vertex,k,vv,vertices,to,be,removed,return,remove,vertices,this,context,from,collection,vertices,to,be,removed
Graph -> public Graph<K, VV, EV> removeVertices(List<Vertex<K, VV>> verticesToBeRemoved);1462100316;Removes the given list of vertices and its edges from the graph.__@param verticesToBeRemoved the list of vertices to be removed_@return the resulted graph containing the initial vertices and edges minus the vertices_and edges removed.;public Graph<K, VV, EV> removeVertices(List<Vertex<K, VV>> verticesToBeRemoved)_	{_		return removeVertices(this.context.fromCollection(verticesToBeRemoved))__	};removes,the,given,list,of,vertices,and,its,edges,from,the,graph,param,vertices,to,be,removed,the,list,of,vertices,to,be,removed,return,the,resulted,graph,containing,the,initial,vertices,and,edges,minus,the,vertices,and,edges,removed;public,graph,k,vv,ev,remove,vertices,list,vertex,k,vv,vertices,to,be,removed,return,remove,vertices,this,context,from,collection,vertices,to,be,removed
Graph -> public Graph<K, VV, EV> removeVertices(List<Vertex<K, VV>> verticesToBeRemoved);1462205213;Removes the given list of vertices and its edges from the graph.__@param verticesToBeRemoved the list of vertices to be removed_@return the resulted graph containing the initial vertices and edges minus the vertices_and edges removed.;public Graph<K, VV, EV> removeVertices(List<Vertex<K, VV>> verticesToBeRemoved)_	{_		return removeVertices(this.context.fromCollection(verticesToBeRemoved))__	};removes,the,given,list,of,vertices,and,its,edges,from,the,graph,param,vertices,to,be,removed,the,list,of,vertices,to,be,removed,return,the,resulted,graph,containing,the,initial,vertices,and,edges,minus,the,vertices,and,edges,removed;public,graph,k,vv,ev,remove,vertices,list,vertex,k,vv,vertices,to,be,removed,return,remove,vertices,this,context,from,collection,vertices,to,be,removed
Graph -> public Graph<K, VV, EV> removeVertices(List<Vertex<K, VV>> verticesToBeRemoved);1462208859;Removes the given list of vertices and its edges from the graph.__@param verticesToBeRemoved the list of vertices to be removed_@return the resulted graph containing the initial vertices and edges minus the vertices_and edges removed.;public Graph<K, VV, EV> removeVertices(List<Vertex<K, VV>> verticesToBeRemoved)_	{_		return removeVertices(this.context.fromCollection(verticesToBeRemoved))__	};removes,the,given,list,of,vertices,and,its,edges,from,the,graph,param,vertices,to,be,removed,the,list,of,vertices,to,be,removed,return,the,resulted,graph,containing,the,initial,vertices,and,edges,minus,the,vertices,and,edges,removed;public,graph,k,vv,ev,remove,vertices,list,vertex,k,vv,vertices,to,be,removed,return,remove,vertices,this,context,from,collection,vertices,to,be,removed
Graph -> public Graph<K, VV, EV> removeVertices(List<Vertex<K, VV>> verticesToBeRemoved);1462809297;Removes the given list of vertices and its edges from the graph.__@param verticesToBeRemoved the list of vertices to be removed_@return the resulted graph containing the initial vertices and edges minus the vertices_and edges removed.;public Graph<K, VV, EV> removeVertices(List<Vertex<K, VV>> verticesToBeRemoved)_	{_		return removeVertices(this.context.fromCollection(verticesToBeRemoved))__	};removes,the,given,list,of,vertices,and,its,edges,from,the,graph,param,vertices,to,be,removed,the,list,of,vertices,to,be,removed,return,the,resulted,graph,containing,the,initial,vertices,and,edges,minus,the,vertices,and,edges,removed;public,graph,k,vv,ev,remove,vertices,list,vertex,k,vv,vertices,to,be,removed,return,remove,vertices,this,context,from,collection,vertices,to,be,removed
Graph -> public Graph<K, VV, EV> removeVertices(List<Vertex<K, VV>> verticesToBeRemoved);1465316775;Removes the given list of vertices and its edges from the graph.__@param verticesToBeRemoved the list of vertices to be removed_@return the resulted graph containing the initial vertices and edges minus the vertices_and edges removed.;public Graph<K, VV, EV> removeVertices(List<Vertex<K, VV>> verticesToBeRemoved)_	{_		return removeVertices(this.context.fromCollection(verticesToBeRemoved))__	};removes,the,given,list,of,vertices,and,its,edges,from,the,graph,param,vertices,to,be,removed,the,list,of,vertices,to,be,removed,return,the,resulted,graph,containing,the,initial,vertices,and,edges,minus,the,vertices,and,edges,removed;public,graph,k,vv,ev,remove,vertices,list,vertex,k,vv,vertices,to,be,removed,return,remove,vertices,this,context,from,collection,vertices,to,be,removed
Graph -> public Graph<K, VV, EV> removeVertices(List<Vertex<K, VV>> verticesToBeRemoved);1466789678;Removes the given list of vertices and its edges from the graph.__@param verticesToBeRemoved the list of vertices to be removed_@return the resulted graph containing the initial vertices and edges minus the vertices_and edges removed.;public Graph<K, VV, EV> removeVertices(List<Vertex<K, VV>> verticesToBeRemoved)_	{_		return removeVertices(this.context.fromCollection(verticesToBeRemoved))__	};removes,the,given,list,of,vertices,and,its,edges,from,the,graph,param,vertices,to,be,removed,the,list,of,vertices,to,be,removed,return,the,resulted,graph,containing,the,initial,vertices,and,edges,minus,the,vertices,and,edges,removed;public,graph,k,vv,ev,remove,vertices,list,vertex,k,vv,vertices,to,be,removed,return,remove,vertices,this,context,from,collection,vertices,to,be,removed
Graph -> public Graph<K, VV, EV> removeVertices(List<Vertex<K, VV>> verticesToBeRemoved);1467140656;Removes the given list of vertices and its edges from the graph.__@param verticesToBeRemoved the list of vertices to be removed_@return the resulted graph containing the initial vertices and edges minus the vertices_and edges removed.;public Graph<K, VV, EV> removeVertices(List<Vertex<K, VV>> verticesToBeRemoved)_	{_		return removeVertices(this.context.fromCollection(verticesToBeRemoved))__	};removes,the,given,list,of,vertices,and,its,edges,from,the,graph,param,vertices,to,be,removed,the,list,of,vertices,to,be,removed,return,the,resulted,graph,containing,the,initial,vertices,and,edges,minus,the,vertices,and,edges,removed;public,graph,k,vv,ev,remove,vertices,list,vertex,k,vv,vertices,to,be,removed,return,remove,vertices,this,context,from,collection,vertices,to,be,removed
Graph -> public Graph<K, VV, EV> removeVertices(List<Vertex<K, VV>> verticesToBeRemoved);1467306272;Removes the given list of vertices and its edges from the graph.__@param verticesToBeRemoved the list of vertices to be removed_@return the resulted graph containing the initial vertices and edges minus the vertices_and edges removed.;public Graph<K, VV, EV> removeVertices(List<Vertex<K, VV>> verticesToBeRemoved)_	{_		return removeVertices(this.context.fromCollection(verticesToBeRemoved))__	};removes,the,given,list,of,vertices,and,its,edges,from,the,graph,param,vertices,to,be,removed,the,list,of,vertices,to,be,removed,return,the,resulted,graph,containing,the,initial,vertices,and,edges,minus,the,vertices,and,edges,removed;public,graph,k,vv,ev,remove,vertices,list,vertex,k,vv,vertices,to,be,removed,return,remove,vertices,this,context,from,collection,vertices,to,be,removed
Graph -> public Graph<K, VV, EV> removeVertices(List<Vertex<K, VV>> verticesToBeRemoved);1470042815;Removes the given list of vertices and its edges from the graph.__@param verticesToBeRemoved the list of vertices to be removed_@return the resulted graph containing the initial vertices and edges minus the vertices_and edges removed.;public Graph<K, VV, EV> removeVertices(List<Vertex<K, VV>> verticesToBeRemoved)_	{_		return removeVertices(this.context.fromCollection(verticesToBeRemoved))__	};removes,the,given,list,of,vertices,and,its,edges,from,the,graph,param,vertices,to,be,removed,the,list,of,vertices,to,be,removed,return,the,resulted,graph,containing,the,initial,vertices,and,edges,minus,the,vertices,and,edges,removed;public,graph,k,vv,ev,remove,vertices,list,vertex,k,vv,vertices,to,be,removed,return,remove,vertices,this,context,from,collection,vertices,to,be,removed
Graph -> public Graph<K, VV, EV> removeVertices(List<Vertex<K, VV>> verticesToBeRemoved);1475684776;Removes the given list of vertices and its edges from the graph.__@param verticesToBeRemoved the list of vertices to be removed_@return the resulted graph containing the initial vertices and edges minus the vertices_and edges removed.;public Graph<K, VV, EV> removeVertices(List<Vertex<K, VV>> verticesToBeRemoved)_	{_		return removeVertices(this.context.fromCollection(verticesToBeRemoved))__	};removes,the,given,list,of,vertices,and,its,edges,from,the,graph,param,vertices,to,be,removed,the,list,of,vertices,to,be,removed,return,the,resulted,graph,containing,the,initial,vertices,and,edges,minus,the,vertices,and,edges,removed;public,graph,k,vv,ev,remove,vertices,list,vertex,k,vv,vertices,to,be,removed,return,remove,vertices,this,context,from,collection,vertices,to,be,removed
Graph -> public Graph<K, VV, EV> removeVertices(List<Vertex<K, VV>> verticesToBeRemoved);1475685606;Removes the given list of vertices and its edges from the graph.__@param verticesToBeRemoved the list of vertices to be removed_@return the resulted graph containing the initial vertices and edges minus the vertices_and edges removed.;public Graph<K, VV, EV> removeVertices(List<Vertex<K, VV>> verticesToBeRemoved)_	{_		return removeVertices(this.context.fromCollection(verticesToBeRemoved))__	};removes,the,given,list,of,vertices,and,its,edges,from,the,graph,param,vertices,to,be,removed,the,list,of,vertices,to,be,removed,return,the,resulted,graph,containing,the,initial,vertices,and,edges,minus,the,vertices,and,edges,removed;public,graph,k,vv,ev,remove,vertices,list,vertex,k,vv,vertices,to,be,removed,return,remove,vertices,this,context,from,collection,vertices,to,be,removed
Graph -> public Graph<K, VV, EV> removeVertices(List<Vertex<K, VV>> verticesToBeRemoved);1481745825;Removes the given list of vertices and its edges from the graph.__@param verticesToBeRemoved the list of vertices to be removed_@return the resulted graph containing the initial vertices and edges minus the vertices_and edges removed.;public Graph<K, VV, EV> removeVertices(List<Vertex<K, VV>> verticesToBeRemoved)_	{_		return removeVertices(this.context.fromCollection(verticesToBeRemoved))__	};removes,the,given,list,of,vertices,and,its,edges,from,the,graph,param,vertices,to,be,removed,the,list,of,vertices,to,be,removed,return,the,resulted,graph,containing,the,initial,vertices,and,edges,minus,the,vertices,and,edges,removed;public,graph,k,vv,ev,remove,vertices,list,vertex,k,vv,vertices,to,be,removed,return,remove,vertices,this,context,from,collection,vertices,to,be,removed
Graph -> public Graph<K, VV, EV> removeVertices(List<Vertex<K, VV>> verticesToBeRemoved);1481881009;Removes the given list of vertices and its edges from the graph.__@param verticesToBeRemoved the list of vertices to be removed_@return the resulted graph containing the initial vertices and edges minus the vertices_and edges removed.;public Graph<K, VV, EV> removeVertices(List<Vertex<K, VV>> verticesToBeRemoved)_	{_		return removeVertices(this.context.fromCollection(verticesToBeRemoved))__	};removes,the,given,list,of,vertices,and,its,edges,from,the,graph,param,vertices,to,be,removed,the,list,of,vertices,to,be,removed,return,the,resulted,graph,containing,the,initial,vertices,and,edges,minus,the,vertices,and,edges,removed;public,graph,k,vv,ev,remove,vertices,list,vertex,k,vv,vertices,to,be,removed,return,remove,vertices,this,context,from,collection,vertices,to,be,removed
Graph -> public Graph<K, VV, EV> removeVertices(List<Vertex<K, VV>> verticesToBeRemoved);1484160227;Removes the given list of vertices and its edges from the graph.__@param verticesToBeRemoved the list of vertices to be removed_@return the resulted graph containing the initial vertices and edges minus the vertices_and edges removed.;public Graph<K, VV, EV> removeVertices(List<Vertex<K, VV>> verticesToBeRemoved)_	{_		return removeVertices(this.context.fromCollection(verticesToBeRemoved))__	};removes,the,given,list,of,vertices,and,its,edges,from,the,graph,param,vertices,to,be,removed,the,list,of,vertices,to,be,removed,return,the,resulted,graph,containing,the,initial,vertices,and,edges,minus,the,vertices,and,edges,removed;public,graph,k,vv,ev,remove,vertices,list,vertex,k,vv,vertices,to,be,removed,return,remove,vertices,this,context,from,collection,vertices,to,be,removed
Graph -> public Graph<K, VV, EV> removeVertices(List<Vertex<K, VV>> verticesToBeRemoved);1484685504;Removes the given list of vertices and its edges from the graph.__@param verticesToBeRemoved the list of vertices to be removed_@return the resulted graph containing the initial vertices and edges minus the vertices_and edges removed.;public Graph<K, VV, EV> removeVertices(List<Vertex<K, VV>> verticesToBeRemoved)_	{_		return removeVertices(this.context.fromCollection(verticesToBeRemoved))__	};removes,the,given,list,of,vertices,and,its,edges,from,the,graph,param,vertices,to,be,removed,the,list,of,vertices,to,be,removed,return,the,resulted,graph,containing,the,initial,vertices,and,edges,minus,the,vertices,and,edges,removed;public,graph,k,vv,ev,remove,vertices,list,vertex,k,vv,vertices,to,be,removed,return,remove,vertices,this,context,from,collection,vertices,to,be,removed
Graph -> public Graph<K, VV, EV> removeVertices(List<Vertex<K, VV>> verticesToBeRemoved);1489068942;Removes the given list of vertices and its edges from the graph.__@param verticesToBeRemoved the list of vertices to be removed_@return the resulted graph containing the initial vertices and edges minus the vertices_and edges removed.;public Graph<K, VV, EV> removeVertices(List<Vertex<K, VV>> verticesToBeRemoved)_	{_		return removeVertices(this.context.fromCollection(verticesToBeRemoved))__	};removes,the,given,list,of,vertices,and,its,edges,from,the,graph,param,vertices,to,be,removed,the,list,of,vertices,to,be,removed,return,the,resulted,graph,containing,the,initial,vertices,and,edges,minus,the,vertices,and,edges,removed;public,graph,k,vv,ev,remove,vertices,list,vertex,k,vv,vertices,to,be,removed,return,remove,vertices,this,context,from,collection,vertices,to,be,removed
Graph -> public Graph<K, VV, EV> removeVertices(List<Vertex<K, VV>> verticesToBeRemoved);1490973446;Removes the given list of vertices and its edges from the graph.__@param verticesToBeRemoved the list of vertices to be removed_@return the resulted graph containing the initial vertices and edges minus the vertices_and edges removed.;public Graph<K, VV, EV> removeVertices(List<Vertex<K, VV>> verticesToBeRemoved)_	{_		return removeVertices(this.context.fromCollection(verticesToBeRemoved))__	};removes,the,given,list,of,vertices,and,its,edges,from,the,graph,param,vertices,to,be,removed,the,list,of,vertices,to,be,removed,return,the,resulted,graph,containing,the,initial,vertices,and,edges,minus,the,vertices,and,edges,removed;public,graph,k,vv,ev,remove,vertices,list,vertex,k,vv,vertices,to,be,removed,return,remove,vertices,this,context,from,collection,vertices,to,be,removed
Graph -> public Graph<K, VV, EV> removeVertices(List<Vertex<K, VV>> verticesToBeRemoved);1495819075;Removes the given list of vertices and its edges from the graph.__@param verticesToBeRemoved the list of vertices to be removed_@return the resulted graph containing the initial vertices and edges minus the vertices_and edges removed.;public Graph<K, VV, EV> removeVertices(List<Vertex<K, VV>> verticesToBeRemoved) {_		return removeVertices(this.context.fromCollection(verticesToBeRemoved))__	};removes,the,given,list,of,vertices,and,its,edges,from,the,graph,param,vertices,to,be,removed,the,list,of,vertices,to,be,removed,return,the,resulted,graph,containing,the,initial,vertices,and,edges,minus,the,vertices,and,edges,removed;public,graph,k,vv,ev,remove,vertices,list,vertex,k,vv,vertices,to,be,removed,return,remove,vertices,this,context,from,collection,vertices,to,be,removed
Graph -> public Graph<K, VV, EV> removeVertices(List<Vertex<K, VV>> verticesToBeRemoved);1502111816;Removes the given list of vertices and its edges from the graph.__@param verticesToBeRemoved the list of vertices to be removed_@return the resulted graph containing the initial vertices and edges minus the vertices_and edges removed.;public Graph<K, VV, EV> removeVertices(List<Vertex<K, VV>> verticesToBeRemoved) {_		return removeVertices(this.context.fromCollection(verticesToBeRemoved))__	};removes,the,given,list,of,vertices,and,its,edges,from,the,graph,param,vertices,to,be,removed,the,list,of,vertices,to,be,removed,return,the,resulted,graph,containing,the,initial,vertices,and,edges,minus,the,vertices,and,edges,removed;public,graph,k,vv,ev,remove,vertices,list,vertex,k,vv,vertices,to,be,removed,return,remove,vertices,this,context,from,collection,vertices,to,be,removed
Graph -> public Graph<K, VV, EV> reverse() throws UnsupportedOperationException;1444404795;Reverse the direction of the edges in the graph__@return a new graph with all edges reversed_@throws UnsupportedOperationException;public Graph<K, VV, EV> reverse() throws UnsupportedOperationException {_		DataSet<Edge<K, EV>> reversedEdges = edges.map(new ReverseEdgesMap<K, EV>())__		return new Graph<K, VV, EV>(vertices, reversedEdges, this.context)__	};reverse,the,direction,of,the,edges,in,the,graph,return,a,new,graph,with,all,edges,reversed,throws,unsupported,operation,exception;public,graph,k,vv,ev,reverse,throws,unsupported,operation,exception,data,set,edge,k,ev,reversed,edges,edges,map,new,reverse,edges,map,k,ev,return,new,graph,k,vv,ev,vertices,reversed,edges,this,context
Graph -> public Graph<K, VV, EV> reverse() throws UnsupportedOperationException;1445261977;Reverse the direction of the edges in the graph__@return a new graph with all edges reversed_@throws UnsupportedOperationException;public Graph<K, VV, EV> reverse() throws UnsupportedOperationException {_		DataSet<Edge<K, EV>> reversedEdges = edges.map(new ReverseEdgesMap<K, EV>())__		return new Graph<K, VV, EV>(vertices, reversedEdges, this.context)__	};reverse,the,direction,of,the,edges,in,the,graph,return,a,new,graph,with,all,edges,reversed,throws,unsupported,operation,exception;public,graph,k,vv,ev,reverse,throws,unsupported,operation,exception,data,set,edge,k,ev,reversed,edges,edges,map,new,reverse,edges,map,k,ev,return,new,graph,k,vv,ev,vertices,reversed,edges,this,context
Graph -> public Graph<K, VV, EV> reverse() throws UnsupportedOperationException;1445854323;Reverse the direction of the edges in the graph__@return a new graph with all edges reversed_@throws UnsupportedOperationException;public Graph<K, VV, EV> reverse() throws UnsupportedOperationException {_		DataSet<Edge<K, EV>> reversedEdges = edges.map(new ReverseEdgesMap<K, EV>())__		return new Graph<K, VV, EV>(vertices, reversedEdges, this.context)__	};reverse,the,direction,of,the,edges,in,the,graph,return,a,new,graph,with,all,edges,reversed,throws,unsupported,operation,exception;public,graph,k,vv,ev,reverse,throws,unsupported,operation,exception,data,set,edge,k,ev,reversed,edges,edges,map,new,reverse,edges,map,k,ev,return,new,graph,k,vv,ev,vertices,reversed,edges,this,context
Graph -> public Graph<K, VV, EV> reverse() throws UnsupportedOperationException;1446112342;Reverse the direction of the edges in the graph__@return a new graph with all edges reversed_@throws UnsupportedOperationException;public Graph<K, VV, EV> reverse() throws UnsupportedOperationException {_		DataSet<Edge<K, EV>> reversedEdges = edges.map(new ReverseEdgesMap<K, EV>())__		return new Graph<K, VV, EV>(vertices, reversedEdges, this.context)__	};reverse,the,direction,of,the,edges,in,the,graph,return,a,new,graph,with,all,edges,reversed,throws,unsupported,operation,exception;public,graph,k,vv,ev,reverse,throws,unsupported,operation,exception,data,set,edge,k,ev,reversed,edges,edges,map,new,reverse,edges,map,k,ev,return,new,graph,k,vv,ev,vertices,reversed,edges,this,context
Graph -> public Graph<K, VV, EV> reverse() throws UnsupportedOperationException;1447073368;Reverse the direction of the edges in the graph__@return a new graph with all edges reversed_@throws UnsupportedOperationException;public Graph<K, VV, EV> reverse() throws UnsupportedOperationException {_		DataSet<Edge<K, EV>> reversedEdges = edges.map(new ReverseEdgesMap<K, EV>())__		return new Graph<K, VV, EV>(vertices, reversedEdges, this.context)__	};reverse,the,direction,of,the,edges,in,the,graph,return,a,new,graph,with,all,edges,reversed,throws,unsupported,operation,exception;public,graph,k,vv,ev,reverse,throws,unsupported,operation,exception,data,set,edge,k,ev,reversed,edges,edges,map,new,reverse,edges,map,k,ev,return,new,graph,k,vv,ev,vertices,reversed,edges,this,context
Graph -> public Graph<K, VV, EV> reverse() throws UnsupportedOperationException;1454404649;Reverse the direction of the edges in the graph__@return a new graph with all edges reversed_@throws UnsupportedOperationException;public Graph<K, VV, EV> reverse() throws UnsupportedOperationException {_		DataSet<Edge<K, EV>> reversedEdges = edges.map(new ReverseEdgesMap<K, EV>())__		return new Graph<K, VV, EV>(vertices, reversedEdges, this.context)__	};reverse,the,direction,of,the,edges,in,the,graph,return,a,new,graph,with,all,edges,reversed,throws,unsupported,operation,exception;public,graph,k,vv,ev,reverse,throws,unsupported,operation,exception,data,set,edge,k,ev,reversed,edges,edges,map,new,reverse,edges,map,k,ev,return,new,graph,k,vv,ev,vertices,reversed,edges,this,context
Graph -> public Graph<K, VV, EV> reverse() throws UnsupportedOperationException;1458583829;Reverse the direction of the edges in the graph__@return a new graph with all edges reversed_@throws UnsupportedOperationException;public Graph<K, VV, EV> reverse() throws UnsupportedOperationException {_		DataSet<Edge<K, EV>> reversedEdges = edges.map(new ReverseEdgesMap<K, EV>())__		return new Graph<K, VV, EV>(vertices, reversedEdges, this.context)__	};reverse,the,direction,of,the,edges,in,the,graph,return,a,new,graph,with,all,edges,reversed,throws,unsupported,operation,exception;public,graph,k,vv,ev,reverse,throws,unsupported,operation,exception,data,set,edge,k,ev,reversed,edges,edges,map,new,reverse,edges,map,k,ev,return,new,graph,k,vv,ev,vertices,reversed,edges,this,context
Graph -> public Graph<K, VV, EV> reverse() throws UnsupportedOperationException;1458583829;Reverse the direction of the edges in the graph__@return a new graph with all edges reversed_@throws UnsupportedOperationException;public Graph<K, VV, EV> reverse() throws UnsupportedOperationException {_		DataSet<Edge<K, EV>> reversedEdges = edges.map(new ReverseEdgesMap<K, EV>())__		return new Graph<K, VV, EV>(vertices, reversedEdges, this.context)__	};reverse,the,direction,of,the,edges,in,the,graph,return,a,new,graph,with,all,edges,reversed,throws,unsupported,operation,exception;public,graph,k,vv,ev,reverse,throws,unsupported,operation,exception,data,set,edge,k,ev,reversed,edges,edges,map,new,reverse,edges,map,k,ev,return,new,graph,k,vv,ev,vertices,reversed,edges,this,context
Graph -> public Graph<K, VV, EV> reverse() throws UnsupportedOperationException;1462100316;Reverse the direction of the edges in the graph__@return a new graph with all edges reversed_@throws UnsupportedOperationException;public Graph<K, VV, EV> reverse() throws UnsupportedOperationException {_		DataSet<Edge<K, EV>> reversedEdges = edges.map(new ReverseEdgesMap<K, EV>())__		return new Graph<K, VV, EV>(vertices, reversedEdges, this.context)__	};reverse,the,direction,of,the,edges,in,the,graph,return,a,new,graph,with,all,edges,reversed,throws,unsupported,operation,exception;public,graph,k,vv,ev,reverse,throws,unsupported,operation,exception,data,set,edge,k,ev,reversed,edges,edges,map,new,reverse,edges,map,k,ev,return,new,graph,k,vv,ev,vertices,reversed,edges,this,context
Graph -> public Graph<K, VV, EV> reverse() throws UnsupportedOperationException;1462100316;Reverse the direction of the edges in the graph__@return a new graph with all edges reversed_@throws UnsupportedOperationException;public Graph<K, VV, EV> reverse() throws UnsupportedOperationException {_		DataSet<Edge<K, EV>> reversedEdges = edges.map(new ReverseEdgesMap<K, EV>())__		return new Graph<K, VV, EV>(vertices, reversedEdges, this.context)__	};reverse,the,direction,of,the,edges,in,the,graph,return,a,new,graph,with,all,edges,reversed,throws,unsupported,operation,exception;public,graph,k,vv,ev,reverse,throws,unsupported,operation,exception,data,set,edge,k,ev,reversed,edges,edges,map,new,reverse,edges,map,k,ev,return,new,graph,k,vv,ev,vertices,reversed,edges,this,context
Graph -> public Graph<K, VV, EV> reverse() throws UnsupportedOperationException;1462205213;Reverse the direction of the edges in the graph__@return a new graph with all edges reversed_@throws UnsupportedOperationException;public Graph<K, VV, EV> reverse() throws UnsupportedOperationException {_		DataSet<Edge<K, EV>> reversedEdges = edges.map(new ReverseEdgesMap<K, EV>())__		return new Graph<K, VV, EV>(vertices, reversedEdges, this.context)__	};reverse,the,direction,of,the,edges,in,the,graph,return,a,new,graph,with,all,edges,reversed,throws,unsupported,operation,exception;public,graph,k,vv,ev,reverse,throws,unsupported,operation,exception,data,set,edge,k,ev,reversed,edges,edges,map,new,reverse,edges,map,k,ev,return,new,graph,k,vv,ev,vertices,reversed,edges,this,context
Graph -> public Graph<K, VV, EV> reverse() throws UnsupportedOperationException;1462208859;Reverse the direction of the edges in the graph__@return a new graph with all edges reversed_@throws UnsupportedOperationException;public Graph<K, VV, EV> reverse() throws UnsupportedOperationException {_		DataSet<Edge<K, EV>> reversedEdges = edges.map(new ReverseEdgesMap<K, EV>())__		return new Graph<K, VV, EV>(vertices, reversedEdges, this.context)__	};reverse,the,direction,of,the,edges,in,the,graph,return,a,new,graph,with,all,edges,reversed,throws,unsupported,operation,exception;public,graph,k,vv,ev,reverse,throws,unsupported,operation,exception,data,set,edge,k,ev,reversed,edges,edges,map,new,reverse,edges,map,k,ev,return,new,graph,k,vv,ev,vertices,reversed,edges,this,context
Graph -> public Graph<K, VV, EV> reverse() throws UnsupportedOperationException;1462809297;Reverse the direction of the edges in the graph__@return a new graph with all edges reversed_@throws UnsupportedOperationException;public Graph<K, VV, EV> reverse() throws UnsupportedOperationException {_		DataSet<Edge<K, EV>> reversedEdges = edges.map(new ReverseEdgesMap<K, EV>())__		return new Graph<K, VV, EV>(vertices, reversedEdges, this.context)__	};reverse,the,direction,of,the,edges,in,the,graph,return,a,new,graph,with,all,edges,reversed,throws,unsupported,operation,exception;public,graph,k,vv,ev,reverse,throws,unsupported,operation,exception,data,set,edge,k,ev,reversed,edges,edges,map,new,reverse,edges,map,k,ev,return,new,graph,k,vv,ev,vertices,reversed,edges,this,context
Graph -> public Graph<K, VV, EV> reverse() throws UnsupportedOperationException;1465316775;Reverse the direction of the edges in the graph__@return a new graph with all edges reversed_@throws UnsupportedOperationException;public Graph<K, VV, EV> reverse() throws UnsupportedOperationException {_		DataSet<Edge<K, EV>> reversedEdges = edges.map(new ReverseEdgesMap<K, EV>())__		return new Graph<K, VV, EV>(vertices, reversedEdges, this.context)__	};reverse,the,direction,of,the,edges,in,the,graph,return,a,new,graph,with,all,edges,reversed,throws,unsupported,operation,exception;public,graph,k,vv,ev,reverse,throws,unsupported,operation,exception,data,set,edge,k,ev,reversed,edges,edges,map,new,reverse,edges,map,k,ev,return,new,graph,k,vv,ev,vertices,reversed,edges,this,context
Graph -> public Graph<K, VV, EV> reverse() throws UnsupportedOperationException;1466789678;Reverse the direction of the edges in the graph__@return a new graph with all edges reversed_@throws UnsupportedOperationException;public Graph<K, VV, EV> reverse() throws UnsupportedOperationException {_		DataSet<Edge<K, EV>> reversedEdges = edges.map(new ReverseEdgesMap<K, EV>())__		return new Graph<K, VV, EV>(vertices, reversedEdges, this.context)__	};reverse,the,direction,of,the,edges,in,the,graph,return,a,new,graph,with,all,edges,reversed,throws,unsupported,operation,exception;public,graph,k,vv,ev,reverse,throws,unsupported,operation,exception,data,set,edge,k,ev,reversed,edges,edges,map,new,reverse,edges,map,k,ev,return,new,graph,k,vv,ev,vertices,reversed,edges,this,context
Graph -> public Graph<K, VV, EV> reverse() throws UnsupportedOperationException;1467140656;Reverse the direction of the edges in the graph__@return a new graph with all edges reversed_@throws UnsupportedOperationException;public Graph<K, VV, EV> reverse() throws UnsupportedOperationException {_		DataSet<Edge<K, EV>> reversedEdges = edges.map(new ReverseEdgesMap<K, EV>())__		return new Graph<K, VV, EV>(vertices, reversedEdges, this.context)__	};reverse,the,direction,of,the,edges,in,the,graph,return,a,new,graph,with,all,edges,reversed,throws,unsupported,operation,exception;public,graph,k,vv,ev,reverse,throws,unsupported,operation,exception,data,set,edge,k,ev,reversed,edges,edges,map,new,reverse,edges,map,k,ev,return,new,graph,k,vv,ev,vertices,reversed,edges,this,context
Graph -> public Graph<K, VV, EV> reverse() throws UnsupportedOperationException;1467306272;Reverse the direction of the edges in the graph__@return a new graph with all edges reversed_@throws UnsupportedOperationException;public Graph<K, VV, EV> reverse() throws UnsupportedOperationException {_		DataSet<Edge<K, EV>> reversedEdges = edges.map(new ReverseEdgesMap<K, EV>())__		return new Graph<K, VV, EV>(vertices, reversedEdges, this.context)__	};reverse,the,direction,of,the,edges,in,the,graph,return,a,new,graph,with,all,edges,reversed,throws,unsupported,operation,exception;public,graph,k,vv,ev,reverse,throws,unsupported,operation,exception,data,set,edge,k,ev,reversed,edges,edges,map,new,reverse,edges,map,k,ev,return,new,graph,k,vv,ev,vertices,reversed,edges,this,context
Graph -> public Graph<K, VV, EV> reverse() throws UnsupportedOperationException;1470042815;Reverse the direction of the edges in the graph__@return a new graph with all edges reversed_@throws UnsupportedOperationException;public Graph<K, VV, EV> reverse() throws UnsupportedOperationException {_		DataSet<Edge<K, EV>> reversedEdges = edges.map(new ReverseEdgesMap<K, EV>())__		return new Graph<K, VV, EV>(vertices, reversedEdges, this.context)__	};reverse,the,direction,of,the,edges,in,the,graph,return,a,new,graph,with,all,edges,reversed,throws,unsupported,operation,exception;public,graph,k,vv,ev,reverse,throws,unsupported,operation,exception,data,set,edge,k,ev,reversed,edges,edges,map,new,reverse,edges,map,k,ev,return,new,graph,k,vv,ev,vertices,reversed,edges,this,context
Graph -> public Graph<K, VV, EV> reverse() throws UnsupportedOperationException;1475684776;Reverse the direction of the edges in the graph__@return a new graph with all edges reversed_@throws UnsupportedOperationException;public Graph<K, VV, EV> reverse() throws UnsupportedOperationException {_		DataSet<Edge<K, EV>> reversedEdges = edges.map(new ReverseEdgesMap<K, EV>())__		return new Graph<>(vertices, reversedEdges, this.context)__	};reverse,the,direction,of,the,edges,in,the,graph,return,a,new,graph,with,all,edges,reversed,throws,unsupported,operation,exception;public,graph,k,vv,ev,reverse,throws,unsupported,operation,exception,data,set,edge,k,ev,reversed,edges,edges,map,new,reverse,edges,map,k,ev,return,new,graph,vertices,reversed,edges,this,context
Graph -> public Graph<K, VV, EV> reverse() throws UnsupportedOperationException;1475685606;Reverse the direction of the edges in the graph__@return a new graph with all edges reversed_@throws UnsupportedOperationException;public Graph<K, VV, EV> reverse() throws UnsupportedOperationException {_		DataSet<Edge<K, EV>> reversedEdges = edges.map(new ReverseEdgesMap<K, EV>())__		return new Graph<>(vertices, reversedEdges, this.context)__	};reverse,the,direction,of,the,edges,in,the,graph,return,a,new,graph,with,all,edges,reversed,throws,unsupported,operation,exception;public,graph,k,vv,ev,reverse,throws,unsupported,operation,exception,data,set,edge,k,ev,reversed,edges,edges,map,new,reverse,edges,map,k,ev,return,new,graph,vertices,reversed,edges,this,context
Graph -> public Graph<K, VV, EV> reverse() throws UnsupportedOperationException;1481745825;Reverse the direction of the edges in the graph__@return a new graph with all edges reversed_@throws UnsupportedOperationException;public Graph<K, VV, EV> reverse() throws UnsupportedOperationException {_		DataSet<Edge<K, EV>> reversedEdges = edges.map(new ReverseEdgesMap<K, EV>()).name("Reverse edges")__		return new Graph<>(vertices, reversedEdges, this.context)__	};reverse,the,direction,of,the,edges,in,the,graph,return,a,new,graph,with,all,edges,reversed,throws,unsupported,operation,exception;public,graph,k,vv,ev,reverse,throws,unsupported,operation,exception,data,set,edge,k,ev,reversed,edges,edges,map,new,reverse,edges,map,k,ev,name,reverse,edges,return,new,graph,vertices,reversed,edges,this,context
Graph -> public Graph<K, VV, EV> reverse() throws UnsupportedOperationException;1481881009;Reverse the direction of the edges in the graph__@return a new graph with all edges reversed_@throws UnsupportedOperationException;public Graph<K, VV, EV> reverse() throws UnsupportedOperationException {_		DataSet<Edge<K, EV>> reversedEdges = edges.map(new ReverseEdgesMap<K, EV>()).name("Reverse edges")__		return new Graph<>(vertices, reversedEdges, this.context)__	};reverse,the,direction,of,the,edges,in,the,graph,return,a,new,graph,with,all,edges,reversed,throws,unsupported,operation,exception;public,graph,k,vv,ev,reverse,throws,unsupported,operation,exception,data,set,edge,k,ev,reversed,edges,edges,map,new,reverse,edges,map,k,ev,name,reverse,edges,return,new,graph,vertices,reversed,edges,this,context
Graph -> public Graph<K, VV, EV> reverse() throws UnsupportedOperationException;1484160227;Reverse the direction of the edges in the graph__@return a new graph with all edges reversed_@throws UnsupportedOperationException;public Graph<K, VV, EV> reverse() throws UnsupportedOperationException {_		DataSet<Edge<K, EV>> reversedEdges = edges.map(new ReverseEdgesMap<K, EV>()).name("Reverse edges")__		return new Graph<>(vertices, reversedEdges, this.context)__	};reverse,the,direction,of,the,edges,in,the,graph,return,a,new,graph,with,all,edges,reversed,throws,unsupported,operation,exception;public,graph,k,vv,ev,reverse,throws,unsupported,operation,exception,data,set,edge,k,ev,reversed,edges,edges,map,new,reverse,edges,map,k,ev,name,reverse,edges,return,new,graph,vertices,reversed,edges,this,context
Graph -> public Graph<K, VV, EV> reverse() throws UnsupportedOperationException;1484685504;Reverse the direction of the edges in the graph__@return a new graph with all edges reversed_@throws UnsupportedOperationException;public Graph<K, VV, EV> reverse() throws UnsupportedOperationException {_		DataSet<Edge<K, EV>> reversedEdges = edges.map(new ReverseEdgesMap<K, EV>()).name("Reverse edges")__		return new Graph<>(vertices, reversedEdges, this.context)__	};reverse,the,direction,of,the,edges,in,the,graph,return,a,new,graph,with,all,edges,reversed,throws,unsupported,operation,exception;public,graph,k,vv,ev,reverse,throws,unsupported,operation,exception,data,set,edge,k,ev,reversed,edges,edges,map,new,reverse,edges,map,k,ev,name,reverse,edges,return,new,graph,vertices,reversed,edges,this,context
Graph -> public Graph<K, VV, EV> reverse() throws UnsupportedOperationException;1489068942;Reverse the direction of the edges in the graph__@return a new graph with all edges reversed_@throws UnsupportedOperationException;public Graph<K, VV, EV> reverse() throws UnsupportedOperationException {_		DataSet<Edge<K, EV>> reversedEdges = edges.map(new ReverseEdgesMap<K, EV>()).name("Reverse edges")__		return new Graph<>(vertices, reversedEdges, this.context)__	};reverse,the,direction,of,the,edges,in,the,graph,return,a,new,graph,with,all,edges,reversed,throws,unsupported,operation,exception;public,graph,k,vv,ev,reverse,throws,unsupported,operation,exception,data,set,edge,k,ev,reversed,edges,edges,map,new,reverse,edges,map,k,ev,name,reverse,edges,return,new,graph,vertices,reversed,edges,this,context
Graph -> public Graph<K, VV, EV> reverse() throws UnsupportedOperationException;1490973446;Reverse the direction of the edges in the graph__@return a new graph with all edges reversed_@throws UnsupportedOperationException;public Graph<K, VV, EV> reverse() throws UnsupportedOperationException {_		DataSet<Edge<K, EV>> reversedEdges = edges.map(new ReverseEdgesMap<K, EV>()).name("Reverse edges")__		return new Graph<>(vertices, reversedEdges, this.context)__	};reverse,the,direction,of,the,edges,in,the,graph,return,a,new,graph,with,all,edges,reversed,throws,unsupported,operation,exception;public,graph,k,vv,ev,reverse,throws,unsupported,operation,exception,data,set,edge,k,ev,reversed,edges,edges,map,new,reverse,edges,map,k,ev,name,reverse,edges,return,new,graph,vertices,reversed,edges,this,context
Graph -> public Graph<K, VV, EV> reverse() throws UnsupportedOperationException;1495819075;Reverse the direction of the edges in the graph.__@return a new graph with all edges reversed_@throws UnsupportedOperationException;public Graph<K, VV, EV> reverse() throws UnsupportedOperationException {_		DataSet<Edge<K, EV>> reversedEdges = edges.map(new ReverseEdgesMap<K, EV>()).name("Reverse edges")__		return new Graph<>(vertices, reversedEdges, this.context)__	};reverse,the,direction,of,the,edges,in,the,graph,return,a,new,graph,with,all,edges,reversed,throws,unsupported,operation,exception;public,graph,k,vv,ev,reverse,throws,unsupported,operation,exception,data,set,edge,k,ev,reversed,edges,edges,map,new,reverse,edges,map,k,ev,name,reverse,edges,return,new,graph,vertices,reversed,edges,this,context
Graph -> public Graph<K, VV, EV> reverse() throws UnsupportedOperationException;1502111816;Reverse the direction of the edges in the graph.__@return a new graph with all edges reversed_@throws UnsupportedOperationException;public Graph<K, VV, EV> reverse() throws UnsupportedOperationException {_		DataSet<Edge<K, EV>> reversedEdges = edges.map(new ReverseEdgesMap<>()).name("Reverse edges")__		return new Graph<>(vertices, reversedEdges, this.context)__	};reverse,the,direction,of,the,edges,in,the,graph,return,a,new,graph,with,all,edges,reversed,throws,unsupported,operation,exception;public,graph,k,vv,ev,reverse,throws,unsupported,operation,exception,data,set,edge,k,ev,reversed,edges,edges,map,new,reverse,edges,map,name,reverse,edges,return,new,graph,vertices,reversed,edges,this,context
Graph -> public <T> DataSet<T> groupReduceOnNeighbors(NeighborsFunction<K, VV, EV, T> neighborsFunction, 			EdgeDirection direction, TypeInformation<T> typeInfo) throws IllegalArgumentException;1445261977;Groups by vertex and computes a GroupReduce transformation over the neighbors (both edges and vertices)_of each vertex. The neighborsFunction applied on the neighbors only has access to the vertex id_(not the vertex value) of the grouping vertex.__For each vertex, the neighborsFunction can iterate over all neighbors of this vertex_with the specified direction, and emit any number of output elements, including none.__@param neighborsFunction the group reduce function to apply to the neighboring edges and vertices_of each vertex._@param direction the edge direction (in-, out-, all-)._@param <T> the output type_@param typeInfo the explicit return type_@return a DataSet containing elements of type T_@throws IllegalArgumentException;public <T> DataSet<T> groupReduceOnNeighbors(NeighborsFunction<K, VV, EV, T> neighborsFunction,_			EdgeDirection direction, TypeInformation<T> typeInfo) throws IllegalArgumentException {_		switch (direction) {_			case IN:_				_				DataSet<Tuple3<K, Edge<K, EV>, Vertex<K, VV>>> edgesWithSources = edges_						.join(this.vertices).where(0).equalTo(0)_						.with(new ProjectVertexIdJoin<K, VV, EV>(1))_						.withForwardedFieldsFirst("f1->f0")__				return edgesWithSources.groupBy(0).reduceGroup(_						new ApplyNeighborGroupReduceFunction<K, VV, EV, T>(neighborsFunction)).returns(typeInfo)__			case OUT:_				_				DataSet<Tuple3<K, Edge<K, EV>, Vertex<K, VV>>> edgesWithTargets = edges_						.join(this.vertices).where(1).equalTo(0)_						.with(new ProjectVertexIdJoin<K, VV, EV>(0))_						.withForwardedFieldsFirst("f0")__				return edgesWithTargets.groupBy(0).reduceGroup(_						new ApplyNeighborGroupReduceFunction<K, VV, EV, T>(neighborsFunction)).returns(typeInfo)__			case ALL:_				_				DataSet<Tuple3<K, Edge<K, EV>, Vertex<K, VV>>> edgesWithNeighbors = edges_						.flatMap(new EmitOneEdgeWithNeighborPerNode<K, EV>())_						.join(this.vertices).where(1).equalTo(0)_						.with(new ProjectEdgeWithNeighbor<K, VV, EV>())___				return edgesWithNeighbors.groupBy(0).reduceGroup(_						new ApplyNeighborGroupReduceFunction<K, VV, EV, T>(neighborsFunction)).returns(typeInfo)__			default:_				throw new IllegalArgumentException("Illegal edge direction")__		}_	};groups,by,vertex,and,computes,a,group,reduce,transformation,over,the,neighbors,both,edges,and,vertices,of,each,vertex,the,neighbors,function,applied,on,the,neighbors,only,has,access,to,the,vertex,id,not,the,vertex,value,of,the,grouping,vertex,for,each,vertex,the,neighbors,function,can,iterate,over,all,neighbors,of,this,vertex,with,the,specified,direction,and,emit,any,number,of,output,elements,including,none,param,neighbors,function,the,group,reduce,function,to,apply,to,the,neighboring,edges,and,vertices,of,each,vertex,param,direction,the,edge,direction,in,out,all,param,t,the,output,type,param,type,info,the,explicit,return,type,return,a,data,set,containing,elements,of,type,t,throws,illegal,argument,exception;public,t,data,set,t,group,reduce,on,neighbors,neighbors,function,k,vv,ev,t,neighbors,function,edge,direction,direction,type,information,t,type,info,throws,illegal,argument,exception,switch,direction,case,in,data,set,tuple3,k,edge,k,ev,vertex,k,vv,edges,with,sources,edges,join,this,vertices,where,0,equal,to,0,with,new,project,vertex,id,join,k,vv,ev,1,with,forwarded,fields,first,f1,f0,return,edges,with,sources,group,by,0,reduce,group,new,apply,neighbor,group,reduce,function,k,vv,ev,t,neighbors,function,returns,type,info,case,out,data,set,tuple3,k,edge,k,ev,vertex,k,vv,edges,with,targets,edges,join,this,vertices,where,1,equal,to,0,with,new,project,vertex,id,join,k,vv,ev,0,with,forwarded,fields,first,f0,return,edges,with,targets,group,by,0,reduce,group,new,apply,neighbor,group,reduce,function,k,vv,ev,t,neighbors,function,returns,type,info,case,all,data,set,tuple3,k,edge,k,ev,vertex,k,vv,edges,with,neighbors,edges,flat,map,new,emit,one,edge,with,neighbor,per,node,k,ev,join,this,vertices,where,1,equal,to,0,with,new,project,edge,with,neighbor,k,vv,ev,return,edges,with,neighbors,group,by,0,reduce,group,new,apply,neighbor,group,reduce,function,k,vv,ev,t,neighbors,function,returns,type,info,default,throw,new,illegal,argument,exception,illegal,edge,direction
Graph -> public <T> DataSet<T> groupReduceOnNeighbors(NeighborsFunction<K, VV, EV, T> neighborsFunction, 			EdgeDirection direction, TypeInformation<T> typeInfo) throws IllegalArgumentException;1445854323;Groups by vertex and computes a GroupReduce transformation over the neighbors (both edges and vertices)_of each vertex. The neighborsFunction applied on the neighbors only has access to the vertex id_(not the vertex value) of the grouping vertex.__For each vertex, the neighborsFunction can iterate over all neighbors of this vertex_with the specified direction, and emit any number of output elements, including none.__@param neighborsFunction the group reduce function to apply to the neighboring edges and vertices_of each vertex._@param direction the edge direction (in-, out-, all-)._@param <T> the output type_@param typeInfo the explicit return type_@return a DataSet containing elements of type T_@throws IllegalArgumentException;public <T> DataSet<T> groupReduceOnNeighbors(NeighborsFunction<K, VV, EV, T> neighborsFunction,_			EdgeDirection direction, TypeInformation<T> typeInfo) throws IllegalArgumentException {_		switch (direction) {_			case IN:_				_				DataSet<Tuple3<K, Edge<K, EV>, Vertex<K, VV>>> edgesWithSources = edges_						.join(this.vertices).where(0).equalTo(0)_						.with(new ProjectVertexIdJoin<K, VV, EV>(1))_						.withForwardedFieldsFirst("f1->f0")__				return edgesWithSources.groupBy(0).reduceGroup(_						new ApplyNeighborGroupReduceFunction<K, VV, EV, T>(neighborsFunction)).returns(typeInfo)__			case OUT:_				_				DataSet<Tuple3<K, Edge<K, EV>, Vertex<K, VV>>> edgesWithTargets = edges_						.join(this.vertices).where(1).equalTo(0)_						.with(new ProjectVertexIdJoin<K, VV, EV>(0))_						.withForwardedFieldsFirst("f0")__				return edgesWithTargets.groupBy(0).reduceGroup(_						new ApplyNeighborGroupReduceFunction<K, VV, EV, T>(neighborsFunction)).returns(typeInfo)__			case ALL:_				_				DataSet<Tuple3<K, Edge<K, EV>, Vertex<K, VV>>> edgesWithNeighbors = edges_						.flatMap(new EmitOneEdgeWithNeighborPerNode<K, EV>())_						.join(this.vertices).where(1).equalTo(0)_						.with(new ProjectEdgeWithNeighbor<K, VV, EV>())___				return edgesWithNeighbors.groupBy(0).reduceGroup(_						new ApplyNeighborGroupReduceFunction<K, VV, EV, T>(neighborsFunction)).returns(typeInfo)__			default:_				throw new IllegalArgumentException("Illegal edge direction")__		}_	};groups,by,vertex,and,computes,a,group,reduce,transformation,over,the,neighbors,both,edges,and,vertices,of,each,vertex,the,neighbors,function,applied,on,the,neighbors,only,has,access,to,the,vertex,id,not,the,vertex,value,of,the,grouping,vertex,for,each,vertex,the,neighbors,function,can,iterate,over,all,neighbors,of,this,vertex,with,the,specified,direction,and,emit,any,number,of,output,elements,including,none,param,neighbors,function,the,group,reduce,function,to,apply,to,the,neighboring,edges,and,vertices,of,each,vertex,param,direction,the,edge,direction,in,out,all,param,t,the,output,type,param,type,info,the,explicit,return,type,return,a,data,set,containing,elements,of,type,t,throws,illegal,argument,exception;public,t,data,set,t,group,reduce,on,neighbors,neighbors,function,k,vv,ev,t,neighbors,function,edge,direction,direction,type,information,t,type,info,throws,illegal,argument,exception,switch,direction,case,in,data,set,tuple3,k,edge,k,ev,vertex,k,vv,edges,with,sources,edges,join,this,vertices,where,0,equal,to,0,with,new,project,vertex,id,join,k,vv,ev,1,with,forwarded,fields,first,f1,f0,return,edges,with,sources,group,by,0,reduce,group,new,apply,neighbor,group,reduce,function,k,vv,ev,t,neighbors,function,returns,type,info,case,out,data,set,tuple3,k,edge,k,ev,vertex,k,vv,edges,with,targets,edges,join,this,vertices,where,1,equal,to,0,with,new,project,vertex,id,join,k,vv,ev,0,with,forwarded,fields,first,f0,return,edges,with,targets,group,by,0,reduce,group,new,apply,neighbor,group,reduce,function,k,vv,ev,t,neighbors,function,returns,type,info,case,all,data,set,tuple3,k,edge,k,ev,vertex,k,vv,edges,with,neighbors,edges,flat,map,new,emit,one,edge,with,neighbor,per,node,k,ev,join,this,vertices,where,1,equal,to,0,with,new,project,edge,with,neighbor,k,vv,ev,return,edges,with,neighbors,group,by,0,reduce,group,new,apply,neighbor,group,reduce,function,k,vv,ev,t,neighbors,function,returns,type,info,default,throw,new,illegal,argument,exception,illegal,edge,direction
Graph -> public <T> DataSet<T> groupReduceOnNeighbors(NeighborsFunction<K, VV, EV, T> neighborsFunction, 			EdgeDirection direction, TypeInformation<T> typeInfo) throws IllegalArgumentException;1446112342;Groups by vertex and computes a GroupReduce transformation over the neighbors (both edges and vertices)_of each vertex. The neighborsFunction applied on the neighbors only has access to the vertex id_(not the vertex value) of the grouping vertex.__For each vertex, the neighborsFunction can iterate over all neighbors of this vertex_with the specified direction, and emit any number of output elements, including none.__@param neighborsFunction the group reduce function to apply to the neighboring edges and vertices_of each vertex._@param direction the edge direction (in-, out-, all-)._@param <T> the output type_@param typeInfo the explicit return type_@return a DataSet containing elements of type T_@throws IllegalArgumentException;public <T> DataSet<T> groupReduceOnNeighbors(NeighborsFunction<K, VV, EV, T> neighborsFunction,_			EdgeDirection direction, TypeInformation<T> typeInfo) throws IllegalArgumentException {_		switch (direction) {_			case IN:_				_				DataSet<Tuple3<K, Edge<K, EV>, Vertex<K, VV>>> edgesWithSources = edges_						.join(this.vertices).where(0).equalTo(0)_						.with(new ProjectVertexIdJoin<K, VV, EV>(1))_						.withForwardedFieldsFirst("f1->f0")__				return edgesWithSources.groupBy(0).reduceGroup(_						new ApplyNeighborGroupReduceFunction<K, VV, EV, T>(neighborsFunction)).returns(typeInfo)__			case OUT:_				_				DataSet<Tuple3<K, Edge<K, EV>, Vertex<K, VV>>> edgesWithTargets = edges_						.join(this.vertices).where(1).equalTo(0)_						.with(new ProjectVertexIdJoin<K, VV, EV>(0))_						.withForwardedFieldsFirst("f0")__				return edgesWithTargets.groupBy(0).reduceGroup(_						new ApplyNeighborGroupReduceFunction<K, VV, EV, T>(neighborsFunction)).returns(typeInfo)__			case ALL:_				_				DataSet<Tuple3<K, Edge<K, EV>, Vertex<K, VV>>> edgesWithNeighbors = edges_						.flatMap(new EmitOneEdgeWithNeighborPerNode<K, EV>())_						.join(this.vertices).where(1).equalTo(0)_						.with(new ProjectEdgeWithNeighbor<K, VV, EV>())___				return edgesWithNeighbors.groupBy(0).reduceGroup(_						new ApplyNeighborGroupReduceFunction<K, VV, EV, T>(neighborsFunction)).returns(typeInfo)__			default:_				throw new IllegalArgumentException("Illegal edge direction")__		}_	};groups,by,vertex,and,computes,a,group,reduce,transformation,over,the,neighbors,both,edges,and,vertices,of,each,vertex,the,neighbors,function,applied,on,the,neighbors,only,has,access,to,the,vertex,id,not,the,vertex,value,of,the,grouping,vertex,for,each,vertex,the,neighbors,function,can,iterate,over,all,neighbors,of,this,vertex,with,the,specified,direction,and,emit,any,number,of,output,elements,including,none,param,neighbors,function,the,group,reduce,function,to,apply,to,the,neighboring,edges,and,vertices,of,each,vertex,param,direction,the,edge,direction,in,out,all,param,t,the,output,type,param,type,info,the,explicit,return,type,return,a,data,set,containing,elements,of,type,t,throws,illegal,argument,exception;public,t,data,set,t,group,reduce,on,neighbors,neighbors,function,k,vv,ev,t,neighbors,function,edge,direction,direction,type,information,t,type,info,throws,illegal,argument,exception,switch,direction,case,in,data,set,tuple3,k,edge,k,ev,vertex,k,vv,edges,with,sources,edges,join,this,vertices,where,0,equal,to,0,with,new,project,vertex,id,join,k,vv,ev,1,with,forwarded,fields,first,f1,f0,return,edges,with,sources,group,by,0,reduce,group,new,apply,neighbor,group,reduce,function,k,vv,ev,t,neighbors,function,returns,type,info,case,out,data,set,tuple3,k,edge,k,ev,vertex,k,vv,edges,with,targets,edges,join,this,vertices,where,1,equal,to,0,with,new,project,vertex,id,join,k,vv,ev,0,with,forwarded,fields,first,f0,return,edges,with,targets,group,by,0,reduce,group,new,apply,neighbor,group,reduce,function,k,vv,ev,t,neighbors,function,returns,type,info,case,all,data,set,tuple3,k,edge,k,ev,vertex,k,vv,edges,with,neighbors,edges,flat,map,new,emit,one,edge,with,neighbor,per,node,k,ev,join,this,vertices,where,1,equal,to,0,with,new,project,edge,with,neighbor,k,vv,ev,return,edges,with,neighbors,group,by,0,reduce,group,new,apply,neighbor,group,reduce,function,k,vv,ev,t,neighbors,function,returns,type,info,default,throw,new,illegal,argument,exception,illegal,edge,direction
Graph -> public <T> DataSet<T> groupReduceOnNeighbors(NeighborsFunction<K, VV, EV, T> neighborsFunction, 			EdgeDirection direction, TypeInformation<T> typeInfo) throws IllegalArgumentException;1447073368;Groups by vertex and computes a GroupReduce transformation over the neighbors (both edges and vertices)_of each vertex. The neighborsFunction applied on the neighbors only has access to the vertex id_(not the vertex value) of the grouping vertex.__For each vertex, the neighborsFunction can iterate over all neighbors of this vertex_with the specified direction, and emit any number of output elements, including none.__@param neighborsFunction the group reduce function to apply to the neighboring edges and vertices_of each vertex._@param direction the edge direction (in-, out-, all-)._@param <T> the output type_@param typeInfo the explicit return type_@return a DataSet containing elements of type T_@throws IllegalArgumentException;public <T> DataSet<T> groupReduceOnNeighbors(NeighborsFunction<K, VV, EV, T> neighborsFunction,_			EdgeDirection direction, TypeInformation<T> typeInfo) throws IllegalArgumentException {_		switch (direction) {_			case IN:_				_				DataSet<Tuple3<K, Edge<K, EV>, Vertex<K, VV>>> edgesWithSources = edges_						.join(this.vertices).where(0).equalTo(0)_						.with(new ProjectVertexIdJoin<K, VV, EV>(1))_						.withForwardedFieldsFirst("f1->f0")__				return edgesWithSources.groupBy(0).reduceGroup(_						new ApplyNeighborGroupReduceFunction<K, VV, EV, T>(neighborsFunction)).returns(typeInfo)__			case OUT:_				_				DataSet<Tuple3<K, Edge<K, EV>, Vertex<K, VV>>> edgesWithTargets = edges_						.join(this.vertices).where(1).equalTo(0)_						.with(new ProjectVertexIdJoin<K, VV, EV>(0))_						.withForwardedFieldsFirst("f0")__				return edgesWithTargets.groupBy(0).reduceGroup(_						new ApplyNeighborGroupReduceFunction<K, VV, EV, T>(neighborsFunction)).returns(typeInfo)__			case ALL:_				_				DataSet<Tuple3<K, Edge<K, EV>, Vertex<K, VV>>> edgesWithNeighbors = edges_						.flatMap(new EmitOneEdgeWithNeighborPerNode<K, EV>())_						.join(this.vertices).where(1).equalTo(0)_						.with(new ProjectEdgeWithNeighbor<K, VV, EV>())___				return edgesWithNeighbors.groupBy(0).reduceGroup(_						new ApplyNeighborGroupReduceFunction<K, VV, EV, T>(neighborsFunction)).returns(typeInfo)__			default:_				throw new IllegalArgumentException("Illegal edge direction")__		}_	};groups,by,vertex,and,computes,a,group,reduce,transformation,over,the,neighbors,both,edges,and,vertices,of,each,vertex,the,neighbors,function,applied,on,the,neighbors,only,has,access,to,the,vertex,id,not,the,vertex,value,of,the,grouping,vertex,for,each,vertex,the,neighbors,function,can,iterate,over,all,neighbors,of,this,vertex,with,the,specified,direction,and,emit,any,number,of,output,elements,including,none,param,neighbors,function,the,group,reduce,function,to,apply,to,the,neighboring,edges,and,vertices,of,each,vertex,param,direction,the,edge,direction,in,out,all,param,t,the,output,type,param,type,info,the,explicit,return,type,return,a,data,set,containing,elements,of,type,t,throws,illegal,argument,exception;public,t,data,set,t,group,reduce,on,neighbors,neighbors,function,k,vv,ev,t,neighbors,function,edge,direction,direction,type,information,t,type,info,throws,illegal,argument,exception,switch,direction,case,in,data,set,tuple3,k,edge,k,ev,vertex,k,vv,edges,with,sources,edges,join,this,vertices,where,0,equal,to,0,with,new,project,vertex,id,join,k,vv,ev,1,with,forwarded,fields,first,f1,f0,return,edges,with,sources,group,by,0,reduce,group,new,apply,neighbor,group,reduce,function,k,vv,ev,t,neighbors,function,returns,type,info,case,out,data,set,tuple3,k,edge,k,ev,vertex,k,vv,edges,with,targets,edges,join,this,vertices,where,1,equal,to,0,with,new,project,vertex,id,join,k,vv,ev,0,with,forwarded,fields,first,f0,return,edges,with,targets,group,by,0,reduce,group,new,apply,neighbor,group,reduce,function,k,vv,ev,t,neighbors,function,returns,type,info,case,all,data,set,tuple3,k,edge,k,ev,vertex,k,vv,edges,with,neighbors,edges,flat,map,new,emit,one,edge,with,neighbor,per,node,k,ev,join,this,vertices,where,1,equal,to,0,with,new,project,edge,with,neighbor,k,vv,ev,return,edges,with,neighbors,group,by,0,reduce,group,new,apply,neighbor,group,reduce,function,k,vv,ev,t,neighbors,function,returns,type,info,default,throw,new,illegal,argument,exception,illegal,edge,direction
Graph -> public <T> DataSet<T> groupReduceOnNeighbors(NeighborsFunction<K, VV, EV, T> neighborsFunction, 			EdgeDirection direction, TypeInformation<T> typeInfo) throws IllegalArgumentException;1454404649;Groups by vertex and computes a GroupReduce transformation over the neighbors (both edges and vertices)_of each vertex. The neighborsFunction applied on the neighbors only has access to the vertex id_(not the vertex value) of the grouping vertex.__For each vertex, the neighborsFunction can iterate over all neighbors of this vertex_with the specified direction, and emit any number of output elements, including none.__@param neighborsFunction the group reduce function to apply to the neighboring edges and vertices_of each vertex._@param direction the edge direction (in-, out-, all-)._@param <T> the output type_@param typeInfo the explicit return type_@return a DataSet containing elements of type T_@throws IllegalArgumentException;public <T> DataSet<T> groupReduceOnNeighbors(NeighborsFunction<K, VV, EV, T> neighborsFunction,_			EdgeDirection direction, TypeInformation<T> typeInfo) throws IllegalArgumentException {_		switch (direction) {_			case IN:_				_				DataSet<Tuple3<K, Edge<K, EV>, Vertex<K, VV>>> edgesWithSources = edges_						.join(this.vertices).where(0).equalTo(0)_						.with(new ProjectVertexIdJoin<K, VV, EV>(1))_						.withForwardedFieldsFirst("f1->f0")__				return edgesWithSources.groupBy(0).reduceGroup(_						new ApplyNeighborGroupReduceFunction<K, VV, EV, T>(neighborsFunction)).returns(typeInfo)__			case OUT:_				_				DataSet<Tuple3<K, Edge<K, EV>, Vertex<K, VV>>> edgesWithTargets = edges_						.join(this.vertices).where(1).equalTo(0)_						.with(new ProjectVertexIdJoin<K, VV, EV>(0))_						.withForwardedFieldsFirst("f0")__				return edgesWithTargets.groupBy(0).reduceGroup(_						new ApplyNeighborGroupReduceFunction<K, VV, EV, T>(neighborsFunction)).returns(typeInfo)__			case ALL:_				_				DataSet<Tuple3<K, Edge<K, EV>, Vertex<K, VV>>> edgesWithNeighbors = edges_						.flatMap(new EmitOneEdgeWithNeighborPerNode<K, EV>())_						.join(this.vertices).where(1).equalTo(0)_						.with(new ProjectEdgeWithNeighbor<K, VV, EV>())___				return edgesWithNeighbors.groupBy(0).reduceGroup(_						new ApplyNeighborGroupReduceFunction<K, VV, EV, T>(neighborsFunction)).returns(typeInfo)__			default:_				throw new IllegalArgumentException("Illegal edge direction")__		}_	};groups,by,vertex,and,computes,a,group,reduce,transformation,over,the,neighbors,both,edges,and,vertices,of,each,vertex,the,neighbors,function,applied,on,the,neighbors,only,has,access,to,the,vertex,id,not,the,vertex,value,of,the,grouping,vertex,for,each,vertex,the,neighbors,function,can,iterate,over,all,neighbors,of,this,vertex,with,the,specified,direction,and,emit,any,number,of,output,elements,including,none,param,neighbors,function,the,group,reduce,function,to,apply,to,the,neighboring,edges,and,vertices,of,each,vertex,param,direction,the,edge,direction,in,out,all,param,t,the,output,type,param,type,info,the,explicit,return,type,return,a,data,set,containing,elements,of,type,t,throws,illegal,argument,exception;public,t,data,set,t,group,reduce,on,neighbors,neighbors,function,k,vv,ev,t,neighbors,function,edge,direction,direction,type,information,t,type,info,throws,illegal,argument,exception,switch,direction,case,in,data,set,tuple3,k,edge,k,ev,vertex,k,vv,edges,with,sources,edges,join,this,vertices,where,0,equal,to,0,with,new,project,vertex,id,join,k,vv,ev,1,with,forwarded,fields,first,f1,f0,return,edges,with,sources,group,by,0,reduce,group,new,apply,neighbor,group,reduce,function,k,vv,ev,t,neighbors,function,returns,type,info,case,out,data,set,tuple3,k,edge,k,ev,vertex,k,vv,edges,with,targets,edges,join,this,vertices,where,1,equal,to,0,with,new,project,vertex,id,join,k,vv,ev,0,with,forwarded,fields,first,f0,return,edges,with,targets,group,by,0,reduce,group,new,apply,neighbor,group,reduce,function,k,vv,ev,t,neighbors,function,returns,type,info,case,all,data,set,tuple3,k,edge,k,ev,vertex,k,vv,edges,with,neighbors,edges,flat,map,new,emit,one,edge,with,neighbor,per,node,k,ev,join,this,vertices,where,1,equal,to,0,with,new,project,edge,with,neighbor,k,vv,ev,return,edges,with,neighbors,group,by,0,reduce,group,new,apply,neighbor,group,reduce,function,k,vv,ev,t,neighbors,function,returns,type,info,default,throw,new,illegal,argument,exception,illegal,edge,direction
Graph -> public <T> DataSet<T> groupReduceOnNeighbors(NeighborsFunction<K, VV, EV, T> neighborsFunction, 			EdgeDirection direction, TypeInformation<T> typeInfo) throws IllegalArgumentException;1458583829;Groups by vertex and computes a GroupReduce transformation over the neighbors (both edges and vertices)_of each vertex. The neighborsFunction applied on the neighbors only has access to the vertex id_(not the vertex value) of the grouping vertex.__For each vertex, the neighborsFunction can iterate over all neighbors of this vertex_with the specified direction, and emit any number of output elements, including none.__@param neighborsFunction the group reduce function to apply to the neighboring edges and vertices_of each vertex._@param direction the edge direction (in-, out-, all-)._@param <T> the output type_@param typeInfo the explicit return type_@return a DataSet containing elements of type T_@throws IllegalArgumentException;public <T> DataSet<T> groupReduceOnNeighbors(NeighborsFunction<K, VV, EV, T> neighborsFunction,_			EdgeDirection direction, TypeInformation<T> typeInfo) throws IllegalArgumentException {_		switch (direction) {_			case IN:_				_				DataSet<Tuple3<K, Edge<K, EV>, Vertex<K, VV>>> edgesWithSources = edges_						.join(this.vertices).where(0).equalTo(0)_						.with(new ProjectVertexIdJoin<K, VV, EV>(1))_						.withForwardedFieldsFirst("f1->f0")__				return edgesWithSources.groupBy(0).reduceGroup(_						new ApplyNeighborGroupReduceFunction<K, VV, EV, T>(neighborsFunction)).returns(typeInfo)__			case OUT:_				_				DataSet<Tuple3<K, Edge<K, EV>, Vertex<K, VV>>> edgesWithTargets = edges_						.join(this.vertices).where(1).equalTo(0)_						.with(new ProjectVertexIdJoin<K, VV, EV>(0))_						.withForwardedFieldsFirst("f0")__				return edgesWithTargets.groupBy(0).reduceGroup(_						new ApplyNeighborGroupReduceFunction<K, VV, EV, T>(neighborsFunction)).returns(typeInfo)__			case ALL:_				_				DataSet<Tuple3<K, Edge<K, EV>, Vertex<K, VV>>> edgesWithNeighbors = edges_						.flatMap(new EmitOneEdgeWithNeighborPerNode<K, EV>())_						.join(this.vertices).where(1).equalTo(0)_						.with(new ProjectEdgeWithNeighbor<K, VV, EV>())___				return edgesWithNeighbors.groupBy(0).reduceGroup(_						new ApplyNeighborGroupReduceFunction<K, VV, EV, T>(neighborsFunction)).returns(typeInfo)__			default:_				throw new IllegalArgumentException("Illegal edge direction")__		}_	};groups,by,vertex,and,computes,a,group,reduce,transformation,over,the,neighbors,both,edges,and,vertices,of,each,vertex,the,neighbors,function,applied,on,the,neighbors,only,has,access,to,the,vertex,id,not,the,vertex,value,of,the,grouping,vertex,for,each,vertex,the,neighbors,function,can,iterate,over,all,neighbors,of,this,vertex,with,the,specified,direction,and,emit,any,number,of,output,elements,including,none,param,neighbors,function,the,group,reduce,function,to,apply,to,the,neighboring,edges,and,vertices,of,each,vertex,param,direction,the,edge,direction,in,out,all,param,t,the,output,type,param,type,info,the,explicit,return,type,return,a,data,set,containing,elements,of,type,t,throws,illegal,argument,exception;public,t,data,set,t,group,reduce,on,neighbors,neighbors,function,k,vv,ev,t,neighbors,function,edge,direction,direction,type,information,t,type,info,throws,illegal,argument,exception,switch,direction,case,in,data,set,tuple3,k,edge,k,ev,vertex,k,vv,edges,with,sources,edges,join,this,vertices,where,0,equal,to,0,with,new,project,vertex,id,join,k,vv,ev,1,with,forwarded,fields,first,f1,f0,return,edges,with,sources,group,by,0,reduce,group,new,apply,neighbor,group,reduce,function,k,vv,ev,t,neighbors,function,returns,type,info,case,out,data,set,tuple3,k,edge,k,ev,vertex,k,vv,edges,with,targets,edges,join,this,vertices,where,1,equal,to,0,with,new,project,vertex,id,join,k,vv,ev,0,with,forwarded,fields,first,f0,return,edges,with,targets,group,by,0,reduce,group,new,apply,neighbor,group,reduce,function,k,vv,ev,t,neighbors,function,returns,type,info,case,all,data,set,tuple3,k,edge,k,ev,vertex,k,vv,edges,with,neighbors,edges,flat,map,new,emit,one,edge,with,neighbor,per,node,k,ev,join,this,vertices,where,1,equal,to,0,with,new,project,edge,with,neighbor,k,vv,ev,return,edges,with,neighbors,group,by,0,reduce,group,new,apply,neighbor,group,reduce,function,k,vv,ev,t,neighbors,function,returns,type,info,default,throw,new,illegal,argument,exception,illegal,edge,direction
Graph -> public <T> DataSet<T> groupReduceOnNeighbors(NeighborsFunction<K, VV, EV, T> neighborsFunction, 			EdgeDirection direction, TypeInformation<T> typeInfo) throws IllegalArgumentException;1458583829;Groups by vertex and computes a GroupReduce transformation over the neighbors (both edges and vertices)_of each vertex. The neighborsFunction applied on the neighbors only has access to the vertex id_(not the vertex value) of the grouping vertex.__For each vertex, the neighborsFunction can iterate over all neighbors of this vertex_with the specified direction, and emit any number of output elements, including none.__@param neighborsFunction the group reduce function to apply to the neighboring edges and vertices_of each vertex._@param direction the edge direction (in-, out-, all-)._@param <T> the output type_@param typeInfo the explicit return type_@return a DataSet containing elements of type T_@throws IllegalArgumentException;public <T> DataSet<T> groupReduceOnNeighbors(NeighborsFunction<K, VV, EV, T> neighborsFunction,_			EdgeDirection direction, TypeInformation<T> typeInfo) throws IllegalArgumentException {_		switch (direction) {_			case IN:_				_				DataSet<Tuple3<K, Edge<K, EV>, Vertex<K, VV>>> edgesWithSources = edges_						.join(this.vertices).where(0).equalTo(0)_						.with(new ProjectVertexIdJoin<K, VV, EV>(1))_						.withForwardedFieldsFirst("f1->f0")__				return edgesWithSources.groupBy(0).reduceGroup(_						new ApplyNeighborGroupReduceFunction<K, VV, EV, T>(neighborsFunction)).returns(typeInfo)__			case OUT:_				_				DataSet<Tuple3<K, Edge<K, EV>, Vertex<K, VV>>> edgesWithTargets = edges_						.join(this.vertices).where(1).equalTo(0)_						.with(new ProjectVertexIdJoin<K, VV, EV>(0))_						.withForwardedFieldsFirst("f0")__				return edgesWithTargets.groupBy(0).reduceGroup(_						new ApplyNeighborGroupReduceFunction<K, VV, EV, T>(neighborsFunction)).returns(typeInfo)__			case ALL:_				_				DataSet<Tuple3<K, Edge<K, EV>, Vertex<K, VV>>> edgesWithNeighbors = edges_						.flatMap(new EmitOneEdgeWithNeighborPerNode<K, EV>())_						.join(this.vertices).where(1).equalTo(0)_						.with(new ProjectEdgeWithNeighbor<K, VV, EV>())___				return edgesWithNeighbors.groupBy(0).reduceGroup(_						new ApplyNeighborGroupReduceFunction<K, VV, EV, T>(neighborsFunction)).returns(typeInfo)__			default:_				throw new IllegalArgumentException("Illegal edge direction")__		}_	};groups,by,vertex,and,computes,a,group,reduce,transformation,over,the,neighbors,both,edges,and,vertices,of,each,vertex,the,neighbors,function,applied,on,the,neighbors,only,has,access,to,the,vertex,id,not,the,vertex,value,of,the,grouping,vertex,for,each,vertex,the,neighbors,function,can,iterate,over,all,neighbors,of,this,vertex,with,the,specified,direction,and,emit,any,number,of,output,elements,including,none,param,neighbors,function,the,group,reduce,function,to,apply,to,the,neighboring,edges,and,vertices,of,each,vertex,param,direction,the,edge,direction,in,out,all,param,t,the,output,type,param,type,info,the,explicit,return,type,return,a,data,set,containing,elements,of,type,t,throws,illegal,argument,exception;public,t,data,set,t,group,reduce,on,neighbors,neighbors,function,k,vv,ev,t,neighbors,function,edge,direction,direction,type,information,t,type,info,throws,illegal,argument,exception,switch,direction,case,in,data,set,tuple3,k,edge,k,ev,vertex,k,vv,edges,with,sources,edges,join,this,vertices,where,0,equal,to,0,with,new,project,vertex,id,join,k,vv,ev,1,with,forwarded,fields,first,f1,f0,return,edges,with,sources,group,by,0,reduce,group,new,apply,neighbor,group,reduce,function,k,vv,ev,t,neighbors,function,returns,type,info,case,out,data,set,tuple3,k,edge,k,ev,vertex,k,vv,edges,with,targets,edges,join,this,vertices,where,1,equal,to,0,with,new,project,vertex,id,join,k,vv,ev,0,with,forwarded,fields,first,f0,return,edges,with,targets,group,by,0,reduce,group,new,apply,neighbor,group,reduce,function,k,vv,ev,t,neighbors,function,returns,type,info,case,all,data,set,tuple3,k,edge,k,ev,vertex,k,vv,edges,with,neighbors,edges,flat,map,new,emit,one,edge,with,neighbor,per,node,k,ev,join,this,vertices,where,1,equal,to,0,with,new,project,edge,with,neighbor,k,vv,ev,return,edges,with,neighbors,group,by,0,reduce,group,new,apply,neighbor,group,reduce,function,k,vv,ev,t,neighbors,function,returns,type,info,default,throw,new,illegal,argument,exception,illegal,edge,direction
Graph -> public <T> DataSet<T> groupReduceOnNeighbors(NeighborsFunction<K, VV, EV, T> neighborsFunction, 			EdgeDirection direction, TypeInformation<T> typeInfo) throws IllegalArgumentException;1462100316;Groups by vertex and computes a GroupReduce transformation over the neighbors (both edges and vertices)_of each vertex. The neighborsFunction applied on the neighbors only has access to the vertex id_(not the vertex value) of the grouping vertex.__For each vertex, the neighborsFunction can iterate over all neighbors of this vertex_with the specified direction, and emit any number of output elements, including none.__@param neighborsFunction the group reduce function to apply to the neighboring edges and vertices_of each vertex._@param direction the edge direction (in-, out-, all-)._@param <T> the output type_@param typeInfo the explicit return type_@return a DataSet containing elements of type T_@throws IllegalArgumentException;public <T> DataSet<T> groupReduceOnNeighbors(NeighborsFunction<K, VV, EV, T> neighborsFunction,_			EdgeDirection direction, TypeInformation<T> typeInfo) throws IllegalArgumentException {_		switch (direction) {_			case IN:_				_				DataSet<Tuple3<K, Edge<K, EV>, Vertex<K, VV>>> edgesWithSources = edges_						.join(this.vertices).where(0).equalTo(0)_						.with(new ProjectVertexIdJoin<K, VV, EV>(1))_						.withForwardedFieldsFirst("f1->f0")__				return edgesWithSources.groupBy(0).reduceGroup(_						new ApplyNeighborGroupReduceFunction<K, VV, EV, T>(neighborsFunction)).returns(typeInfo)__			case OUT:_				_				DataSet<Tuple3<K, Edge<K, EV>, Vertex<K, VV>>> edgesWithTargets = edges_						.join(this.vertices).where(1).equalTo(0)_						.with(new ProjectVertexIdJoin<K, VV, EV>(0))_						.withForwardedFieldsFirst("f0")__				return edgesWithTargets.groupBy(0).reduceGroup(_						new ApplyNeighborGroupReduceFunction<K, VV, EV, T>(neighborsFunction)).returns(typeInfo)__			case ALL:_				_				DataSet<Tuple3<K, Edge<K, EV>, Vertex<K, VV>>> edgesWithNeighbors = edges_						.flatMap(new EmitOneEdgeWithNeighborPerNode<K, EV>())_						.join(this.vertices).where(1).equalTo(0)_						.with(new ProjectEdgeWithNeighbor<K, VV, EV>())___				return edgesWithNeighbors.groupBy(0).reduceGroup(_						new ApplyNeighborGroupReduceFunction<K, VV, EV, T>(neighborsFunction)).returns(typeInfo)__			default:_				throw new IllegalArgumentException("Illegal edge direction")__		}_	};groups,by,vertex,and,computes,a,group,reduce,transformation,over,the,neighbors,both,edges,and,vertices,of,each,vertex,the,neighbors,function,applied,on,the,neighbors,only,has,access,to,the,vertex,id,not,the,vertex,value,of,the,grouping,vertex,for,each,vertex,the,neighbors,function,can,iterate,over,all,neighbors,of,this,vertex,with,the,specified,direction,and,emit,any,number,of,output,elements,including,none,param,neighbors,function,the,group,reduce,function,to,apply,to,the,neighboring,edges,and,vertices,of,each,vertex,param,direction,the,edge,direction,in,out,all,param,t,the,output,type,param,type,info,the,explicit,return,type,return,a,data,set,containing,elements,of,type,t,throws,illegal,argument,exception;public,t,data,set,t,group,reduce,on,neighbors,neighbors,function,k,vv,ev,t,neighbors,function,edge,direction,direction,type,information,t,type,info,throws,illegal,argument,exception,switch,direction,case,in,data,set,tuple3,k,edge,k,ev,vertex,k,vv,edges,with,sources,edges,join,this,vertices,where,0,equal,to,0,with,new,project,vertex,id,join,k,vv,ev,1,with,forwarded,fields,first,f1,f0,return,edges,with,sources,group,by,0,reduce,group,new,apply,neighbor,group,reduce,function,k,vv,ev,t,neighbors,function,returns,type,info,case,out,data,set,tuple3,k,edge,k,ev,vertex,k,vv,edges,with,targets,edges,join,this,vertices,where,1,equal,to,0,with,new,project,vertex,id,join,k,vv,ev,0,with,forwarded,fields,first,f0,return,edges,with,targets,group,by,0,reduce,group,new,apply,neighbor,group,reduce,function,k,vv,ev,t,neighbors,function,returns,type,info,case,all,data,set,tuple3,k,edge,k,ev,vertex,k,vv,edges,with,neighbors,edges,flat,map,new,emit,one,edge,with,neighbor,per,node,k,ev,join,this,vertices,where,1,equal,to,0,with,new,project,edge,with,neighbor,k,vv,ev,return,edges,with,neighbors,group,by,0,reduce,group,new,apply,neighbor,group,reduce,function,k,vv,ev,t,neighbors,function,returns,type,info,default,throw,new,illegal,argument,exception,illegal,edge,direction
Graph -> public <T> DataSet<T> groupReduceOnNeighbors(NeighborsFunction<K, VV, EV, T> neighborsFunction, 			EdgeDirection direction, TypeInformation<T> typeInfo) throws IllegalArgumentException;1462100316;Groups by vertex and computes a GroupReduce transformation over the neighbors (both edges and vertices)_of each vertex. The neighborsFunction applied on the neighbors only has access to the vertex id_(not the vertex value) of the grouping vertex.__For each vertex, the neighborsFunction can iterate over all neighbors of this vertex_with the specified direction, and emit any number of output elements, including none.__@param neighborsFunction the group reduce function to apply to the neighboring edges and vertices_of each vertex._@param direction the edge direction (in-, out-, all-)._@param <T> the output type_@param typeInfo the explicit return type_@return a DataSet containing elements of type T_@throws IllegalArgumentException;public <T> DataSet<T> groupReduceOnNeighbors(NeighborsFunction<K, VV, EV, T> neighborsFunction,_			EdgeDirection direction, TypeInformation<T> typeInfo) throws IllegalArgumentException {_		switch (direction) {_			case IN:_				_				DataSet<Tuple3<K, Edge<K, EV>, Vertex<K, VV>>> edgesWithSources = edges_						.join(this.vertices).where(0).equalTo(0)_						.with(new ProjectVertexIdJoin<K, VV, EV>(1))_						.withForwardedFieldsFirst("f1->f0")__				return edgesWithSources.groupBy(0).reduceGroup(_						new ApplyNeighborGroupReduceFunction<K, VV, EV, T>(neighborsFunction)).returns(typeInfo)__			case OUT:_				_				DataSet<Tuple3<K, Edge<K, EV>, Vertex<K, VV>>> edgesWithTargets = edges_						.join(this.vertices).where(1).equalTo(0)_						.with(new ProjectVertexIdJoin<K, VV, EV>(0))_						.withForwardedFieldsFirst("f0")__				return edgesWithTargets.groupBy(0).reduceGroup(_						new ApplyNeighborGroupReduceFunction<K, VV, EV, T>(neighborsFunction)).returns(typeInfo)__			case ALL:_				_				DataSet<Tuple3<K, Edge<K, EV>, Vertex<K, VV>>> edgesWithNeighbors = edges_						.flatMap(new EmitOneEdgeWithNeighborPerNode<K, EV>())_						.join(this.vertices).where(1).equalTo(0)_						.with(new ProjectEdgeWithNeighbor<K, VV, EV>())___				return edgesWithNeighbors.groupBy(0).reduceGroup(_						new ApplyNeighborGroupReduceFunction<K, VV, EV, T>(neighborsFunction)).returns(typeInfo)__			default:_				throw new IllegalArgumentException("Illegal edge direction")__		}_	};groups,by,vertex,and,computes,a,group,reduce,transformation,over,the,neighbors,both,edges,and,vertices,of,each,vertex,the,neighbors,function,applied,on,the,neighbors,only,has,access,to,the,vertex,id,not,the,vertex,value,of,the,grouping,vertex,for,each,vertex,the,neighbors,function,can,iterate,over,all,neighbors,of,this,vertex,with,the,specified,direction,and,emit,any,number,of,output,elements,including,none,param,neighbors,function,the,group,reduce,function,to,apply,to,the,neighboring,edges,and,vertices,of,each,vertex,param,direction,the,edge,direction,in,out,all,param,t,the,output,type,param,type,info,the,explicit,return,type,return,a,data,set,containing,elements,of,type,t,throws,illegal,argument,exception;public,t,data,set,t,group,reduce,on,neighbors,neighbors,function,k,vv,ev,t,neighbors,function,edge,direction,direction,type,information,t,type,info,throws,illegal,argument,exception,switch,direction,case,in,data,set,tuple3,k,edge,k,ev,vertex,k,vv,edges,with,sources,edges,join,this,vertices,where,0,equal,to,0,with,new,project,vertex,id,join,k,vv,ev,1,with,forwarded,fields,first,f1,f0,return,edges,with,sources,group,by,0,reduce,group,new,apply,neighbor,group,reduce,function,k,vv,ev,t,neighbors,function,returns,type,info,case,out,data,set,tuple3,k,edge,k,ev,vertex,k,vv,edges,with,targets,edges,join,this,vertices,where,1,equal,to,0,with,new,project,vertex,id,join,k,vv,ev,0,with,forwarded,fields,first,f0,return,edges,with,targets,group,by,0,reduce,group,new,apply,neighbor,group,reduce,function,k,vv,ev,t,neighbors,function,returns,type,info,case,all,data,set,tuple3,k,edge,k,ev,vertex,k,vv,edges,with,neighbors,edges,flat,map,new,emit,one,edge,with,neighbor,per,node,k,ev,join,this,vertices,where,1,equal,to,0,with,new,project,edge,with,neighbor,k,vv,ev,return,edges,with,neighbors,group,by,0,reduce,group,new,apply,neighbor,group,reduce,function,k,vv,ev,t,neighbors,function,returns,type,info,default,throw,new,illegal,argument,exception,illegal,edge,direction
Graph -> public <T> DataSet<T> groupReduceOnNeighbors(NeighborsFunction<K, VV, EV, T> neighborsFunction, 			EdgeDirection direction, TypeInformation<T> typeInfo) throws IllegalArgumentException;1462205213;Groups by vertex and computes a GroupReduce transformation over the neighbors (both edges and vertices)_of each vertex. The neighborsFunction applied on the neighbors only has access to the vertex id_(not the vertex value) of the grouping vertex.__For each vertex, the neighborsFunction can iterate over all neighbors of this vertex_with the specified direction, and emit any number of output elements, including none.__@param neighborsFunction the group reduce function to apply to the neighboring edges and vertices_of each vertex._@param direction the edge direction (in-, out-, all-)._@param <T> the output type_@param typeInfo the explicit return type_@return a DataSet containing elements of type T_@throws IllegalArgumentException;public <T> DataSet<T> groupReduceOnNeighbors(NeighborsFunction<K, VV, EV, T> neighborsFunction,_			EdgeDirection direction, TypeInformation<T> typeInfo) throws IllegalArgumentException {_		switch (direction) {_			case IN:_				_				DataSet<Tuple3<K, Edge<K, EV>, Vertex<K, VV>>> edgesWithSources = edges_						.join(this.vertices).where(0).equalTo(0)_						.with(new ProjectVertexIdJoin<K, VV, EV>(1))_						.withForwardedFieldsFirst("f1->f0")__				return edgesWithSources.groupBy(0).reduceGroup(_						new ApplyNeighborGroupReduceFunction<K, VV, EV, T>(neighborsFunction)).returns(typeInfo)__			case OUT:_				_				DataSet<Tuple3<K, Edge<K, EV>, Vertex<K, VV>>> edgesWithTargets = edges_						.join(this.vertices).where(1).equalTo(0)_						.with(new ProjectVertexIdJoin<K, VV, EV>(0))_						.withForwardedFieldsFirst("f0")__				return edgesWithTargets.groupBy(0).reduceGroup(_						new ApplyNeighborGroupReduceFunction<K, VV, EV, T>(neighborsFunction)).returns(typeInfo)__			case ALL:_				_				DataSet<Tuple3<K, Edge<K, EV>, Vertex<K, VV>>> edgesWithNeighbors = edges_						.flatMap(new EmitOneEdgeWithNeighborPerNode<K, EV>())_						.join(this.vertices).where(1).equalTo(0)_						.with(new ProjectEdgeWithNeighbor<K, VV, EV>())___				return edgesWithNeighbors.groupBy(0).reduceGroup(_						new ApplyNeighborGroupReduceFunction<K, VV, EV, T>(neighborsFunction)).returns(typeInfo)__			default:_				throw new IllegalArgumentException("Illegal edge direction")__		}_	};groups,by,vertex,and,computes,a,group,reduce,transformation,over,the,neighbors,both,edges,and,vertices,of,each,vertex,the,neighbors,function,applied,on,the,neighbors,only,has,access,to,the,vertex,id,not,the,vertex,value,of,the,grouping,vertex,for,each,vertex,the,neighbors,function,can,iterate,over,all,neighbors,of,this,vertex,with,the,specified,direction,and,emit,any,number,of,output,elements,including,none,param,neighbors,function,the,group,reduce,function,to,apply,to,the,neighboring,edges,and,vertices,of,each,vertex,param,direction,the,edge,direction,in,out,all,param,t,the,output,type,param,type,info,the,explicit,return,type,return,a,data,set,containing,elements,of,type,t,throws,illegal,argument,exception;public,t,data,set,t,group,reduce,on,neighbors,neighbors,function,k,vv,ev,t,neighbors,function,edge,direction,direction,type,information,t,type,info,throws,illegal,argument,exception,switch,direction,case,in,data,set,tuple3,k,edge,k,ev,vertex,k,vv,edges,with,sources,edges,join,this,vertices,where,0,equal,to,0,with,new,project,vertex,id,join,k,vv,ev,1,with,forwarded,fields,first,f1,f0,return,edges,with,sources,group,by,0,reduce,group,new,apply,neighbor,group,reduce,function,k,vv,ev,t,neighbors,function,returns,type,info,case,out,data,set,tuple3,k,edge,k,ev,vertex,k,vv,edges,with,targets,edges,join,this,vertices,where,1,equal,to,0,with,new,project,vertex,id,join,k,vv,ev,0,with,forwarded,fields,first,f0,return,edges,with,targets,group,by,0,reduce,group,new,apply,neighbor,group,reduce,function,k,vv,ev,t,neighbors,function,returns,type,info,case,all,data,set,tuple3,k,edge,k,ev,vertex,k,vv,edges,with,neighbors,edges,flat,map,new,emit,one,edge,with,neighbor,per,node,k,ev,join,this,vertices,where,1,equal,to,0,with,new,project,edge,with,neighbor,k,vv,ev,return,edges,with,neighbors,group,by,0,reduce,group,new,apply,neighbor,group,reduce,function,k,vv,ev,t,neighbors,function,returns,type,info,default,throw,new,illegal,argument,exception,illegal,edge,direction
Graph -> public <T> DataSet<T> groupReduceOnNeighbors(NeighborsFunction<K, VV, EV, T> neighborsFunction, 			EdgeDirection direction, TypeInformation<T> typeInfo) throws IllegalArgumentException;1462208859;Groups by vertex and computes a GroupReduce transformation over the neighbors (both edges and vertices)_of each vertex. The neighborsFunction applied on the neighbors only has access to the vertex id_(not the vertex value) of the grouping vertex.__For each vertex, the neighborsFunction can iterate over all neighbors of this vertex_with the specified direction, and emit any number of output elements, including none.__@param neighborsFunction the group reduce function to apply to the neighboring edges and vertices_of each vertex._@param direction the edge direction (in-, out-, all-)._@param <T> the output type_@param typeInfo the explicit return type_@return a DataSet containing elements of type T_@throws IllegalArgumentException;public <T> DataSet<T> groupReduceOnNeighbors(NeighborsFunction<K, VV, EV, T> neighborsFunction,_			EdgeDirection direction, TypeInformation<T> typeInfo) throws IllegalArgumentException {_		switch (direction) {_			case IN:_				_				DataSet<Tuple3<K, Edge<K, EV>, Vertex<K, VV>>> edgesWithSources = edges_						.join(this.vertices).where(0).equalTo(0)_						.with(new ProjectVertexIdJoin<K, VV, EV>(1))_						.withForwardedFieldsFirst("f1->f0")__				return edgesWithSources.groupBy(0).reduceGroup(_						new ApplyNeighborGroupReduceFunction<K, VV, EV, T>(neighborsFunction)).returns(typeInfo)__			case OUT:_				_				DataSet<Tuple3<K, Edge<K, EV>, Vertex<K, VV>>> edgesWithTargets = edges_						.join(this.vertices).where(1).equalTo(0)_						.with(new ProjectVertexIdJoin<K, VV, EV>(0))_						.withForwardedFieldsFirst("f0")__				return edgesWithTargets.groupBy(0).reduceGroup(_						new ApplyNeighborGroupReduceFunction<K, VV, EV, T>(neighborsFunction)).returns(typeInfo)__			case ALL:_				_				DataSet<Tuple3<K, Edge<K, EV>, Vertex<K, VV>>> edgesWithNeighbors = edges_						.flatMap(new EmitOneEdgeWithNeighborPerNode<K, EV>())_						.join(this.vertices).where(1).equalTo(0)_						.with(new ProjectEdgeWithNeighbor<K, VV, EV>())___				return edgesWithNeighbors.groupBy(0).reduceGroup(_						new ApplyNeighborGroupReduceFunction<K, VV, EV, T>(neighborsFunction)).returns(typeInfo)__			default:_				throw new IllegalArgumentException("Illegal edge direction")__		}_	};groups,by,vertex,and,computes,a,group,reduce,transformation,over,the,neighbors,both,edges,and,vertices,of,each,vertex,the,neighbors,function,applied,on,the,neighbors,only,has,access,to,the,vertex,id,not,the,vertex,value,of,the,grouping,vertex,for,each,vertex,the,neighbors,function,can,iterate,over,all,neighbors,of,this,vertex,with,the,specified,direction,and,emit,any,number,of,output,elements,including,none,param,neighbors,function,the,group,reduce,function,to,apply,to,the,neighboring,edges,and,vertices,of,each,vertex,param,direction,the,edge,direction,in,out,all,param,t,the,output,type,param,type,info,the,explicit,return,type,return,a,data,set,containing,elements,of,type,t,throws,illegal,argument,exception;public,t,data,set,t,group,reduce,on,neighbors,neighbors,function,k,vv,ev,t,neighbors,function,edge,direction,direction,type,information,t,type,info,throws,illegal,argument,exception,switch,direction,case,in,data,set,tuple3,k,edge,k,ev,vertex,k,vv,edges,with,sources,edges,join,this,vertices,where,0,equal,to,0,with,new,project,vertex,id,join,k,vv,ev,1,with,forwarded,fields,first,f1,f0,return,edges,with,sources,group,by,0,reduce,group,new,apply,neighbor,group,reduce,function,k,vv,ev,t,neighbors,function,returns,type,info,case,out,data,set,tuple3,k,edge,k,ev,vertex,k,vv,edges,with,targets,edges,join,this,vertices,where,1,equal,to,0,with,new,project,vertex,id,join,k,vv,ev,0,with,forwarded,fields,first,f0,return,edges,with,targets,group,by,0,reduce,group,new,apply,neighbor,group,reduce,function,k,vv,ev,t,neighbors,function,returns,type,info,case,all,data,set,tuple3,k,edge,k,ev,vertex,k,vv,edges,with,neighbors,edges,flat,map,new,emit,one,edge,with,neighbor,per,node,k,ev,join,this,vertices,where,1,equal,to,0,with,new,project,edge,with,neighbor,k,vv,ev,return,edges,with,neighbors,group,by,0,reduce,group,new,apply,neighbor,group,reduce,function,k,vv,ev,t,neighbors,function,returns,type,info,default,throw,new,illegal,argument,exception,illegal,edge,direction
Graph -> public <T> DataSet<T> groupReduceOnNeighbors(NeighborsFunction<K, VV, EV, T> neighborsFunction, 			EdgeDirection direction, TypeInformation<T> typeInfo) throws IllegalArgumentException;1462809297;Groups by vertex and computes a GroupReduce transformation over the neighbors (both edges and vertices)_of each vertex. The neighborsFunction applied on the neighbors only has access to the vertex id_(not the vertex value) of the grouping vertex.__For each vertex, the neighborsFunction can iterate over all neighbors of this vertex_with the specified direction, and emit any number of output elements, including none.__@param neighborsFunction the group reduce function to apply to the neighboring edges and vertices_of each vertex._@param direction the edge direction (in-, out-, all-)._@param <T> the output type_@param typeInfo the explicit return type_@return a DataSet containing elements of type T_@throws IllegalArgumentException;public <T> DataSet<T> groupReduceOnNeighbors(NeighborsFunction<K, VV, EV, T> neighborsFunction,_			EdgeDirection direction, TypeInformation<T> typeInfo) throws IllegalArgumentException {_		switch (direction) {_			case IN:_				_				DataSet<Tuple3<K, Edge<K, EV>, Vertex<K, VV>>> edgesWithSources = edges_						.join(this.vertices).where(0).equalTo(0)_						.with(new ProjectVertexIdJoin<K, VV, EV>(1))_						.withForwardedFieldsFirst("f1->f0")__				return edgesWithSources.groupBy(0).reduceGroup(_						new ApplyNeighborGroupReduceFunction<K, VV, EV, T>(neighborsFunction)).returns(typeInfo)__			case OUT:_				_				DataSet<Tuple3<K, Edge<K, EV>, Vertex<K, VV>>> edgesWithTargets = edges_						.join(this.vertices).where(1).equalTo(0)_						.with(new ProjectVertexIdJoin<K, VV, EV>(0))_						.withForwardedFieldsFirst("f0")__				return edgesWithTargets.groupBy(0).reduceGroup(_						new ApplyNeighborGroupReduceFunction<K, VV, EV, T>(neighborsFunction)).returns(typeInfo)__			case ALL:_				_				DataSet<Tuple3<K, Edge<K, EV>, Vertex<K, VV>>> edgesWithNeighbors = edges_						.flatMap(new EmitOneEdgeWithNeighborPerNode<K, EV>())_						.join(this.vertices).where(1).equalTo(0)_						.with(new ProjectEdgeWithNeighbor<K, VV, EV>())___				return edgesWithNeighbors.groupBy(0).reduceGroup(_						new ApplyNeighborGroupReduceFunction<K, VV, EV, T>(neighborsFunction)).returns(typeInfo)__			default:_				throw new IllegalArgumentException("Illegal edge direction")__		}_	};groups,by,vertex,and,computes,a,group,reduce,transformation,over,the,neighbors,both,edges,and,vertices,of,each,vertex,the,neighbors,function,applied,on,the,neighbors,only,has,access,to,the,vertex,id,not,the,vertex,value,of,the,grouping,vertex,for,each,vertex,the,neighbors,function,can,iterate,over,all,neighbors,of,this,vertex,with,the,specified,direction,and,emit,any,number,of,output,elements,including,none,param,neighbors,function,the,group,reduce,function,to,apply,to,the,neighboring,edges,and,vertices,of,each,vertex,param,direction,the,edge,direction,in,out,all,param,t,the,output,type,param,type,info,the,explicit,return,type,return,a,data,set,containing,elements,of,type,t,throws,illegal,argument,exception;public,t,data,set,t,group,reduce,on,neighbors,neighbors,function,k,vv,ev,t,neighbors,function,edge,direction,direction,type,information,t,type,info,throws,illegal,argument,exception,switch,direction,case,in,data,set,tuple3,k,edge,k,ev,vertex,k,vv,edges,with,sources,edges,join,this,vertices,where,0,equal,to,0,with,new,project,vertex,id,join,k,vv,ev,1,with,forwarded,fields,first,f1,f0,return,edges,with,sources,group,by,0,reduce,group,new,apply,neighbor,group,reduce,function,k,vv,ev,t,neighbors,function,returns,type,info,case,out,data,set,tuple3,k,edge,k,ev,vertex,k,vv,edges,with,targets,edges,join,this,vertices,where,1,equal,to,0,with,new,project,vertex,id,join,k,vv,ev,0,with,forwarded,fields,first,f0,return,edges,with,targets,group,by,0,reduce,group,new,apply,neighbor,group,reduce,function,k,vv,ev,t,neighbors,function,returns,type,info,case,all,data,set,tuple3,k,edge,k,ev,vertex,k,vv,edges,with,neighbors,edges,flat,map,new,emit,one,edge,with,neighbor,per,node,k,ev,join,this,vertices,where,1,equal,to,0,with,new,project,edge,with,neighbor,k,vv,ev,return,edges,with,neighbors,group,by,0,reduce,group,new,apply,neighbor,group,reduce,function,k,vv,ev,t,neighbors,function,returns,type,info,default,throw,new,illegal,argument,exception,illegal,edge,direction
Graph -> public <T> DataSet<T> groupReduceOnNeighbors(NeighborsFunction<K, VV, EV, T> neighborsFunction, 			EdgeDirection direction, TypeInformation<T> typeInfo) throws IllegalArgumentException;1465316775;Groups by vertex and computes a GroupReduce transformation over the neighbors (both edges and vertices)_of each vertex. The neighborsFunction applied on the neighbors only has access to the vertex id_(not the vertex value) of the grouping vertex.__For each vertex, the neighborsFunction can iterate over all neighbors of this vertex_with the specified direction, and emit any number of output elements, including none.__@param neighborsFunction the group reduce function to apply to the neighboring edges and vertices_of each vertex._@param direction the edge direction (in-, out-, all-)._@param <T> the output type_@param typeInfo the explicit return type_@return a DataSet containing elements of type T_@throws IllegalArgumentException;public <T> DataSet<T> groupReduceOnNeighbors(NeighborsFunction<K, VV, EV, T> neighborsFunction,_			EdgeDirection direction, TypeInformation<T> typeInfo) throws IllegalArgumentException {_		switch (direction) {_			case IN:_				_				DataSet<Tuple3<K, Edge<K, EV>, Vertex<K, VV>>> edgesWithSources = edges_						.join(this.vertices).where(0).equalTo(0)_						.with(new ProjectVertexIdJoin<K, VV, EV>(1))_						.withForwardedFieldsFirst("f1->f0")__				return edgesWithSources.groupBy(0).reduceGroup(_						new ApplyNeighborGroupReduceFunction<K, VV, EV, T>(neighborsFunction)).returns(typeInfo)__			case OUT:_				_				DataSet<Tuple3<K, Edge<K, EV>, Vertex<K, VV>>> edgesWithTargets = edges_						.join(this.vertices).where(1).equalTo(0)_						.with(new ProjectVertexIdJoin<K, VV, EV>(0))_						.withForwardedFieldsFirst("f0")__				return edgesWithTargets.groupBy(0).reduceGroup(_						new ApplyNeighborGroupReduceFunction<K, VV, EV, T>(neighborsFunction)).returns(typeInfo)__			case ALL:_				_				DataSet<Tuple3<K, Edge<K, EV>, Vertex<K, VV>>> edgesWithNeighbors = edges_						.flatMap(new EmitOneEdgeWithNeighborPerNode<K, EV>())_						.join(this.vertices).where(1).equalTo(0)_						.with(new ProjectEdgeWithNeighbor<K, VV, EV>())___				return edgesWithNeighbors.groupBy(0).reduceGroup(_						new ApplyNeighborGroupReduceFunction<K, VV, EV, T>(neighborsFunction)).returns(typeInfo)__			default:_				throw new IllegalArgumentException("Illegal edge direction")__		}_	};groups,by,vertex,and,computes,a,group,reduce,transformation,over,the,neighbors,both,edges,and,vertices,of,each,vertex,the,neighbors,function,applied,on,the,neighbors,only,has,access,to,the,vertex,id,not,the,vertex,value,of,the,grouping,vertex,for,each,vertex,the,neighbors,function,can,iterate,over,all,neighbors,of,this,vertex,with,the,specified,direction,and,emit,any,number,of,output,elements,including,none,param,neighbors,function,the,group,reduce,function,to,apply,to,the,neighboring,edges,and,vertices,of,each,vertex,param,direction,the,edge,direction,in,out,all,param,t,the,output,type,param,type,info,the,explicit,return,type,return,a,data,set,containing,elements,of,type,t,throws,illegal,argument,exception;public,t,data,set,t,group,reduce,on,neighbors,neighbors,function,k,vv,ev,t,neighbors,function,edge,direction,direction,type,information,t,type,info,throws,illegal,argument,exception,switch,direction,case,in,data,set,tuple3,k,edge,k,ev,vertex,k,vv,edges,with,sources,edges,join,this,vertices,where,0,equal,to,0,with,new,project,vertex,id,join,k,vv,ev,1,with,forwarded,fields,first,f1,f0,return,edges,with,sources,group,by,0,reduce,group,new,apply,neighbor,group,reduce,function,k,vv,ev,t,neighbors,function,returns,type,info,case,out,data,set,tuple3,k,edge,k,ev,vertex,k,vv,edges,with,targets,edges,join,this,vertices,where,1,equal,to,0,with,new,project,vertex,id,join,k,vv,ev,0,with,forwarded,fields,first,f0,return,edges,with,targets,group,by,0,reduce,group,new,apply,neighbor,group,reduce,function,k,vv,ev,t,neighbors,function,returns,type,info,case,all,data,set,tuple3,k,edge,k,ev,vertex,k,vv,edges,with,neighbors,edges,flat,map,new,emit,one,edge,with,neighbor,per,node,k,ev,join,this,vertices,where,1,equal,to,0,with,new,project,edge,with,neighbor,k,vv,ev,return,edges,with,neighbors,group,by,0,reduce,group,new,apply,neighbor,group,reduce,function,k,vv,ev,t,neighbors,function,returns,type,info,default,throw,new,illegal,argument,exception,illegal,edge,direction
Graph -> public <T> DataSet<T> groupReduceOnNeighbors(NeighborsFunction<K, VV, EV, T> neighborsFunction, 			EdgeDirection direction, TypeInformation<T> typeInfo) throws IllegalArgumentException;1466789678;Groups by vertex and computes a GroupReduce transformation over the neighbors (both edges and vertices)_of each vertex. The neighborsFunction applied on the neighbors only has access to the vertex id_(not the vertex value) of the grouping vertex.__For each vertex, the neighborsFunction can iterate over all neighbors of this vertex_with the specified direction, and emit any number of output elements, including none.__@param neighborsFunction the group reduce function to apply to the neighboring edges and vertices_of each vertex._@param direction the edge direction (in-, out-, all-)._@param <T> the output type_@param typeInfo the explicit return type_@return a DataSet containing elements of type T_@throws IllegalArgumentException;public <T> DataSet<T> groupReduceOnNeighbors(NeighborsFunction<K, VV, EV, T> neighborsFunction,_			EdgeDirection direction, TypeInformation<T> typeInfo) throws IllegalArgumentException {_		switch (direction) {_			case IN:_				_				DataSet<Tuple3<K, Edge<K, EV>, Vertex<K, VV>>> edgesWithSources = edges_						.join(this.vertices).where(0).equalTo(0)_						.with(new ProjectVertexIdJoin<K, VV, EV>(1))_						.withForwardedFieldsFirst("f1->f0")__				return edgesWithSources.groupBy(0).reduceGroup(_						new ApplyNeighborGroupReduceFunction<K, VV, EV, T>(neighborsFunction)).returns(typeInfo)__			case OUT:_				_				DataSet<Tuple3<K, Edge<K, EV>, Vertex<K, VV>>> edgesWithTargets = edges_						.join(this.vertices).where(1).equalTo(0)_						.with(new ProjectVertexIdJoin<K, VV, EV>(0))_						.withForwardedFieldsFirst("f0")__				return edgesWithTargets.groupBy(0).reduceGroup(_						new ApplyNeighborGroupReduceFunction<K, VV, EV, T>(neighborsFunction)).returns(typeInfo)__			case ALL:_				_				DataSet<Tuple3<K, Edge<K, EV>, Vertex<K, VV>>> edgesWithNeighbors = edges_						.flatMap(new EmitOneEdgeWithNeighborPerNode<K, EV>())_						.join(this.vertices).where(1).equalTo(0)_						.with(new ProjectEdgeWithNeighbor<K, VV, EV>())___				return edgesWithNeighbors.groupBy(0).reduceGroup(_						new ApplyNeighborGroupReduceFunction<K, VV, EV, T>(neighborsFunction)).returns(typeInfo)__			default:_				throw new IllegalArgumentException("Illegal edge direction")__		}_	};groups,by,vertex,and,computes,a,group,reduce,transformation,over,the,neighbors,both,edges,and,vertices,of,each,vertex,the,neighbors,function,applied,on,the,neighbors,only,has,access,to,the,vertex,id,not,the,vertex,value,of,the,grouping,vertex,for,each,vertex,the,neighbors,function,can,iterate,over,all,neighbors,of,this,vertex,with,the,specified,direction,and,emit,any,number,of,output,elements,including,none,param,neighbors,function,the,group,reduce,function,to,apply,to,the,neighboring,edges,and,vertices,of,each,vertex,param,direction,the,edge,direction,in,out,all,param,t,the,output,type,param,type,info,the,explicit,return,type,return,a,data,set,containing,elements,of,type,t,throws,illegal,argument,exception;public,t,data,set,t,group,reduce,on,neighbors,neighbors,function,k,vv,ev,t,neighbors,function,edge,direction,direction,type,information,t,type,info,throws,illegal,argument,exception,switch,direction,case,in,data,set,tuple3,k,edge,k,ev,vertex,k,vv,edges,with,sources,edges,join,this,vertices,where,0,equal,to,0,with,new,project,vertex,id,join,k,vv,ev,1,with,forwarded,fields,first,f1,f0,return,edges,with,sources,group,by,0,reduce,group,new,apply,neighbor,group,reduce,function,k,vv,ev,t,neighbors,function,returns,type,info,case,out,data,set,tuple3,k,edge,k,ev,vertex,k,vv,edges,with,targets,edges,join,this,vertices,where,1,equal,to,0,with,new,project,vertex,id,join,k,vv,ev,0,with,forwarded,fields,first,f0,return,edges,with,targets,group,by,0,reduce,group,new,apply,neighbor,group,reduce,function,k,vv,ev,t,neighbors,function,returns,type,info,case,all,data,set,tuple3,k,edge,k,ev,vertex,k,vv,edges,with,neighbors,edges,flat,map,new,emit,one,edge,with,neighbor,per,node,k,ev,join,this,vertices,where,1,equal,to,0,with,new,project,edge,with,neighbor,k,vv,ev,return,edges,with,neighbors,group,by,0,reduce,group,new,apply,neighbor,group,reduce,function,k,vv,ev,t,neighbors,function,returns,type,info,default,throw,new,illegal,argument,exception,illegal,edge,direction
Graph -> public <T> DataSet<T> groupReduceOnNeighbors(NeighborsFunction<K, VV, EV, T> neighborsFunction, 			EdgeDirection direction, TypeInformation<T> typeInfo) throws IllegalArgumentException;1467140656;Groups by vertex and computes a GroupReduce transformation over the neighbors (both edges and vertices)_of each vertex. The neighborsFunction applied on the neighbors only has access to the vertex id_(not the vertex value) of the grouping vertex.__For each vertex, the neighborsFunction can iterate over all neighbors of this vertex_with the specified direction, and emit any number of output elements, including none.__@param neighborsFunction the group reduce function to apply to the neighboring edges and vertices_of each vertex._@param direction the edge direction (in-, out-, all-)._@param <T> the output type_@param typeInfo the explicit return type_@return a DataSet containing elements of type T_@throws IllegalArgumentException;public <T> DataSet<T> groupReduceOnNeighbors(NeighborsFunction<K, VV, EV, T> neighborsFunction,_			EdgeDirection direction, TypeInformation<T> typeInfo) throws IllegalArgumentException {_		switch (direction) {_			case IN:_				_				DataSet<Tuple3<K, Edge<K, EV>, Vertex<K, VV>>> edgesWithSources = edges_						.join(this.vertices).where(0).equalTo(0)_						.with(new ProjectVertexIdJoin<K, VV, EV>(1))_						.withForwardedFieldsFirst("f1->f0")__				return edgesWithSources.groupBy(0).reduceGroup(_						new ApplyNeighborGroupReduceFunction<K, VV, EV, T>(neighborsFunction)).returns(typeInfo)__			case OUT:_				_				DataSet<Tuple3<K, Edge<K, EV>, Vertex<K, VV>>> edgesWithTargets = edges_						.join(this.vertices).where(1).equalTo(0)_						.with(new ProjectVertexIdJoin<K, VV, EV>(0))_						.withForwardedFieldsFirst("f0")__				return edgesWithTargets.groupBy(0).reduceGroup(_						new ApplyNeighborGroupReduceFunction<K, VV, EV, T>(neighborsFunction)).returns(typeInfo)__			case ALL:_				_				DataSet<Tuple3<K, Edge<K, EV>, Vertex<K, VV>>> edgesWithNeighbors = edges_						.flatMap(new EmitOneEdgeWithNeighborPerNode<K, EV>())_						.join(this.vertices).where(1).equalTo(0)_						.with(new ProjectEdgeWithNeighbor<K, VV, EV>())___				return edgesWithNeighbors.groupBy(0).reduceGroup(_						new ApplyNeighborGroupReduceFunction<K, VV, EV, T>(neighborsFunction)).returns(typeInfo)__			default:_				throw new IllegalArgumentException("Illegal edge direction")__		}_	};groups,by,vertex,and,computes,a,group,reduce,transformation,over,the,neighbors,both,edges,and,vertices,of,each,vertex,the,neighbors,function,applied,on,the,neighbors,only,has,access,to,the,vertex,id,not,the,vertex,value,of,the,grouping,vertex,for,each,vertex,the,neighbors,function,can,iterate,over,all,neighbors,of,this,vertex,with,the,specified,direction,and,emit,any,number,of,output,elements,including,none,param,neighbors,function,the,group,reduce,function,to,apply,to,the,neighboring,edges,and,vertices,of,each,vertex,param,direction,the,edge,direction,in,out,all,param,t,the,output,type,param,type,info,the,explicit,return,type,return,a,data,set,containing,elements,of,type,t,throws,illegal,argument,exception;public,t,data,set,t,group,reduce,on,neighbors,neighbors,function,k,vv,ev,t,neighbors,function,edge,direction,direction,type,information,t,type,info,throws,illegal,argument,exception,switch,direction,case,in,data,set,tuple3,k,edge,k,ev,vertex,k,vv,edges,with,sources,edges,join,this,vertices,where,0,equal,to,0,with,new,project,vertex,id,join,k,vv,ev,1,with,forwarded,fields,first,f1,f0,return,edges,with,sources,group,by,0,reduce,group,new,apply,neighbor,group,reduce,function,k,vv,ev,t,neighbors,function,returns,type,info,case,out,data,set,tuple3,k,edge,k,ev,vertex,k,vv,edges,with,targets,edges,join,this,vertices,where,1,equal,to,0,with,new,project,vertex,id,join,k,vv,ev,0,with,forwarded,fields,first,f0,return,edges,with,targets,group,by,0,reduce,group,new,apply,neighbor,group,reduce,function,k,vv,ev,t,neighbors,function,returns,type,info,case,all,data,set,tuple3,k,edge,k,ev,vertex,k,vv,edges,with,neighbors,edges,flat,map,new,emit,one,edge,with,neighbor,per,node,k,ev,join,this,vertices,where,1,equal,to,0,with,new,project,edge,with,neighbor,k,vv,ev,return,edges,with,neighbors,group,by,0,reduce,group,new,apply,neighbor,group,reduce,function,k,vv,ev,t,neighbors,function,returns,type,info,default,throw,new,illegal,argument,exception,illegal,edge,direction
Graph -> public <T> DataSet<T> groupReduceOnNeighbors(NeighborsFunction<K, VV, EV, T> neighborsFunction, 			EdgeDirection direction, TypeInformation<T> typeInfo) throws IllegalArgumentException;1467306272;Groups by vertex and computes a GroupReduce transformation over the neighbors (both edges and vertices)_of each vertex. The neighborsFunction applied on the neighbors only has access to the vertex id_(not the vertex value) of the grouping vertex.__For each vertex, the neighborsFunction can iterate over all neighbors of this vertex_with the specified direction, and emit any number of output elements, including none.__@param neighborsFunction the group reduce function to apply to the neighboring edges and vertices_of each vertex._@param direction the edge direction (in-, out-, all-)._@param <T> the output type_@param typeInfo the explicit return type_@return a DataSet containing elements of type T_@throws IllegalArgumentException;public <T> DataSet<T> groupReduceOnNeighbors(NeighborsFunction<K, VV, EV, T> neighborsFunction,_			EdgeDirection direction, TypeInformation<T> typeInfo) throws IllegalArgumentException {_		switch (direction) {_			case IN:_				_				DataSet<Tuple3<K, Edge<K, EV>, Vertex<K, VV>>> edgesWithSources = edges_						.join(this.vertices).where(0).equalTo(0)_						.with(new ProjectVertexIdJoin<K, VV, EV>(1))_						.withForwardedFieldsFirst("f1->f0")__				return edgesWithSources.groupBy(0).reduceGroup(_						new ApplyNeighborGroupReduceFunction<K, VV, EV, T>(neighborsFunction)).returns(typeInfo)__			case OUT:_				_				DataSet<Tuple3<K, Edge<K, EV>, Vertex<K, VV>>> edgesWithTargets = edges_						.join(this.vertices).where(1).equalTo(0)_						.with(new ProjectVertexIdJoin<K, VV, EV>(0))_						.withForwardedFieldsFirst("f0")__				return edgesWithTargets.groupBy(0).reduceGroup(_						new ApplyNeighborGroupReduceFunction<K, VV, EV, T>(neighborsFunction)).returns(typeInfo)__			case ALL:_				_				DataSet<Tuple3<K, Edge<K, EV>, Vertex<K, VV>>> edgesWithNeighbors = edges_						.flatMap(new EmitOneEdgeWithNeighborPerNode<K, EV>())_						.join(this.vertices).where(1).equalTo(0)_						.with(new ProjectEdgeWithNeighbor<K, VV, EV>())___				return edgesWithNeighbors.groupBy(0).reduceGroup(_						new ApplyNeighborGroupReduceFunction<K, VV, EV, T>(neighborsFunction)).returns(typeInfo)__			default:_				throw new IllegalArgumentException("Illegal edge direction")__		}_	};groups,by,vertex,and,computes,a,group,reduce,transformation,over,the,neighbors,both,edges,and,vertices,of,each,vertex,the,neighbors,function,applied,on,the,neighbors,only,has,access,to,the,vertex,id,not,the,vertex,value,of,the,grouping,vertex,for,each,vertex,the,neighbors,function,can,iterate,over,all,neighbors,of,this,vertex,with,the,specified,direction,and,emit,any,number,of,output,elements,including,none,param,neighbors,function,the,group,reduce,function,to,apply,to,the,neighboring,edges,and,vertices,of,each,vertex,param,direction,the,edge,direction,in,out,all,param,t,the,output,type,param,type,info,the,explicit,return,type,return,a,data,set,containing,elements,of,type,t,throws,illegal,argument,exception;public,t,data,set,t,group,reduce,on,neighbors,neighbors,function,k,vv,ev,t,neighbors,function,edge,direction,direction,type,information,t,type,info,throws,illegal,argument,exception,switch,direction,case,in,data,set,tuple3,k,edge,k,ev,vertex,k,vv,edges,with,sources,edges,join,this,vertices,where,0,equal,to,0,with,new,project,vertex,id,join,k,vv,ev,1,with,forwarded,fields,first,f1,f0,return,edges,with,sources,group,by,0,reduce,group,new,apply,neighbor,group,reduce,function,k,vv,ev,t,neighbors,function,returns,type,info,case,out,data,set,tuple3,k,edge,k,ev,vertex,k,vv,edges,with,targets,edges,join,this,vertices,where,1,equal,to,0,with,new,project,vertex,id,join,k,vv,ev,0,with,forwarded,fields,first,f0,return,edges,with,targets,group,by,0,reduce,group,new,apply,neighbor,group,reduce,function,k,vv,ev,t,neighbors,function,returns,type,info,case,all,data,set,tuple3,k,edge,k,ev,vertex,k,vv,edges,with,neighbors,edges,flat,map,new,emit,one,edge,with,neighbor,per,node,k,ev,join,this,vertices,where,1,equal,to,0,with,new,project,edge,with,neighbor,k,vv,ev,return,edges,with,neighbors,group,by,0,reduce,group,new,apply,neighbor,group,reduce,function,k,vv,ev,t,neighbors,function,returns,type,info,default,throw,new,illegal,argument,exception,illegal,edge,direction
Graph -> public <T> DataSet<T> groupReduceOnNeighbors(NeighborsFunction<K, VV, EV, T> neighborsFunction, 			EdgeDirection direction, TypeInformation<T> typeInfo) throws IllegalArgumentException;1470042815;Groups by vertex and computes a GroupReduce transformation over the neighbors (both edges and vertices)_of each vertex. The neighborsFunction applied on the neighbors only has access to the vertex id_(not the vertex value) of the grouping vertex.__For each vertex, the neighborsFunction can iterate over all neighbors of this vertex_with the specified direction, and emit any number of output elements, including none.__@param neighborsFunction the group reduce function to apply to the neighboring edges and vertices_of each vertex._@param direction the edge direction (in-, out-, all-)._@param <T> the output type_@param typeInfo the explicit return type_@return a DataSet containing elements of type T_@throws IllegalArgumentException;public <T> DataSet<T> groupReduceOnNeighbors(NeighborsFunction<K, VV, EV, T> neighborsFunction,_			EdgeDirection direction, TypeInformation<T> typeInfo) throws IllegalArgumentException {_		switch (direction) {_			case IN:_				_				DataSet<Tuple3<K, Edge<K, EV>, Vertex<K, VV>>> edgesWithSources = edges_						.join(this.vertices).where(0).equalTo(0)_						.with(new ProjectVertexIdJoin<K, VV, EV>(1))_						.withForwardedFieldsFirst("f1->f0")__				return edgesWithSources.groupBy(0).reduceGroup(_						new ApplyNeighborGroupReduceFunction<K, VV, EV, T>(neighborsFunction)).returns(typeInfo)__			case OUT:_				_				DataSet<Tuple3<K, Edge<K, EV>, Vertex<K, VV>>> edgesWithTargets = edges_						.join(this.vertices).where(1).equalTo(0)_						.with(new ProjectVertexIdJoin<K, VV, EV>(0))_						.withForwardedFieldsFirst("f0")__				return edgesWithTargets.groupBy(0).reduceGroup(_						new ApplyNeighborGroupReduceFunction<K, VV, EV, T>(neighborsFunction)).returns(typeInfo)__			case ALL:_				_				DataSet<Tuple3<K, Edge<K, EV>, Vertex<K, VV>>> edgesWithNeighbors = edges_						.flatMap(new EmitOneEdgeWithNeighborPerNode<K, EV>())_						.join(this.vertices).where(1).equalTo(0)_						.with(new ProjectEdgeWithNeighbor<K, VV, EV>())___				return edgesWithNeighbors.groupBy(0).reduceGroup(_						new ApplyNeighborGroupReduceFunction<K, VV, EV, T>(neighborsFunction)).returns(typeInfo)__			default:_				throw new IllegalArgumentException("Illegal edge direction")__		}_	};groups,by,vertex,and,computes,a,group,reduce,transformation,over,the,neighbors,both,edges,and,vertices,of,each,vertex,the,neighbors,function,applied,on,the,neighbors,only,has,access,to,the,vertex,id,not,the,vertex,value,of,the,grouping,vertex,for,each,vertex,the,neighbors,function,can,iterate,over,all,neighbors,of,this,vertex,with,the,specified,direction,and,emit,any,number,of,output,elements,including,none,param,neighbors,function,the,group,reduce,function,to,apply,to,the,neighboring,edges,and,vertices,of,each,vertex,param,direction,the,edge,direction,in,out,all,param,t,the,output,type,param,type,info,the,explicit,return,type,return,a,data,set,containing,elements,of,type,t,throws,illegal,argument,exception;public,t,data,set,t,group,reduce,on,neighbors,neighbors,function,k,vv,ev,t,neighbors,function,edge,direction,direction,type,information,t,type,info,throws,illegal,argument,exception,switch,direction,case,in,data,set,tuple3,k,edge,k,ev,vertex,k,vv,edges,with,sources,edges,join,this,vertices,where,0,equal,to,0,with,new,project,vertex,id,join,k,vv,ev,1,with,forwarded,fields,first,f1,f0,return,edges,with,sources,group,by,0,reduce,group,new,apply,neighbor,group,reduce,function,k,vv,ev,t,neighbors,function,returns,type,info,case,out,data,set,tuple3,k,edge,k,ev,vertex,k,vv,edges,with,targets,edges,join,this,vertices,where,1,equal,to,0,with,new,project,vertex,id,join,k,vv,ev,0,with,forwarded,fields,first,f0,return,edges,with,targets,group,by,0,reduce,group,new,apply,neighbor,group,reduce,function,k,vv,ev,t,neighbors,function,returns,type,info,case,all,data,set,tuple3,k,edge,k,ev,vertex,k,vv,edges,with,neighbors,edges,flat,map,new,emit,one,edge,with,neighbor,per,node,k,ev,join,this,vertices,where,1,equal,to,0,with,new,project,edge,with,neighbor,k,vv,ev,return,edges,with,neighbors,group,by,0,reduce,group,new,apply,neighbor,group,reduce,function,k,vv,ev,t,neighbors,function,returns,type,info,default,throw,new,illegal,argument,exception,illegal,edge,direction
Graph -> public <T> DataSet<T> groupReduceOnNeighbors(NeighborsFunction<K, VV, EV, T> neighborsFunction, 			EdgeDirection direction, TypeInformation<T> typeInfo) throws IllegalArgumentException;1475684776;Groups by vertex and computes a GroupReduce transformation over the neighbors (both edges and vertices)_of each vertex. The neighborsFunction applied on the neighbors only has access to the vertex id_(not the vertex value) of the grouping vertex.__For each vertex, the neighborsFunction can iterate over all neighbors of this vertex_with the specified direction, and emit any number of output elements, including none.__@param neighborsFunction the group reduce function to apply to the neighboring edges and vertices_of each vertex._@param direction the edge direction (in-, out-, all-)._@param <T> the output type_@param typeInfo the explicit return type_@return a DataSet containing elements of type T_@throws IllegalArgumentException;public <T> DataSet<T> groupReduceOnNeighbors(NeighborsFunction<K, VV, EV, T> neighborsFunction,_			EdgeDirection direction, TypeInformation<T> typeInfo) throws IllegalArgumentException {_		switch (direction) {_			case IN:_				_				DataSet<Tuple3<K, Edge<K, EV>, Vertex<K, VV>>> edgesWithSources = edges_						.join(this.vertices).where(0).equalTo(0)_						.with(new ProjectVertexIdJoin<K, VV, EV>(1))_						.withForwardedFieldsFirst("f1->f0")__				return edgesWithSources.groupBy(0).reduceGroup(_					new ApplyNeighborGroupReduceFunction<>(neighborsFunction)).returns(typeInfo)__			case OUT:_				_				DataSet<Tuple3<K, Edge<K, EV>, Vertex<K, VV>>> edgesWithTargets = edges_						.join(this.vertices).where(1).equalTo(0)_						.with(new ProjectVertexIdJoin<K, VV, EV>(0))_						.withForwardedFieldsFirst("f0")__				return edgesWithTargets.groupBy(0).reduceGroup(_					new ApplyNeighborGroupReduceFunction<>(neighborsFunction)).returns(typeInfo)__			case ALL:_				_				DataSet<Tuple3<K, Edge<K, EV>, Vertex<K, VV>>> edgesWithNeighbors = edges_						.flatMap(new EmitOneEdgeWithNeighborPerNode<K, EV>())_						.join(this.vertices).where(1).equalTo(0)_						.with(new ProjectEdgeWithNeighbor<K, VV, EV>())___				return edgesWithNeighbors.groupBy(0).reduceGroup(_					new ApplyNeighborGroupReduceFunction<>(neighborsFunction)).returns(typeInfo)__			default:_				throw new IllegalArgumentException("Illegal edge direction")__		}_	};groups,by,vertex,and,computes,a,group,reduce,transformation,over,the,neighbors,both,edges,and,vertices,of,each,vertex,the,neighbors,function,applied,on,the,neighbors,only,has,access,to,the,vertex,id,not,the,vertex,value,of,the,grouping,vertex,for,each,vertex,the,neighbors,function,can,iterate,over,all,neighbors,of,this,vertex,with,the,specified,direction,and,emit,any,number,of,output,elements,including,none,param,neighbors,function,the,group,reduce,function,to,apply,to,the,neighboring,edges,and,vertices,of,each,vertex,param,direction,the,edge,direction,in,out,all,param,t,the,output,type,param,type,info,the,explicit,return,type,return,a,data,set,containing,elements,of,type,t,throws,illegal,argument,exception;public,t,data,set,t,group,reduce,on,neighbors,neighbors,function,k,vv,ev,t,neighbors,function,edge,direction,direction,type,information,t,type,info,throws,illegal,argument,exception,switch,direction,case,in,data,set,tuple3,k,edge,k,ev,vertex,k,vv,edges,with,sources,edges,join,this,vertices,where,0,equal,to,0,with,new,project,vertex,id,join,k,vv,ev,1,with,forwarded,fields,first,f1,f0,return,edges,with,sources,group,by,0,reduce,group,new,apply,neighbor,group,reduce,function,neighbors,function,returns,type,info,case,out,data,set,tuple3,k,edge,k,ev,vertex,k,vv,edges,with,targets,edges,join,this,vertices,where,1,equal,to,0,with,new,project,vertex,id,join,k,vv,ev,0,with,forwarded,fields,first,f0,return,edges,with,targets,group,by,0,reduce,group,new,apply,neighbor,group,reduce,function,neighbors,function,returns,type,info,case,all,data,set,tuple3,k,edge,k,ev,vertex,k,vv,edges,with,neighbors,edges,flat,map,new,emit,one,edge,with,neighbor,per,node,k,ev,join,this,vertices,where,1,equal,to,0,with,new,project,edge,with,neighbor,k,vv,ev,return,edges,with,neighbors,group,by,0,reduce,group,new,apply,neighbor,group,reduce,function,neighbors,function,returns,type,info,default,throw,new,illegal,argument,exception,illegal,edge,direction
Graph -> public <T> DataSet<T> groupReduceOnNeighbors(NeighborsFunction<K, VV, EV, T> neighborsFunction, 			EdgeDirection direction, TypeInformation<T> typeInfo) throws IllegalArgumentException;1475685606;Groups by vertex and computes a GroupReduce transformation over the neighbors (both edges and vertices)_of each vertex. The neighborsFunction applied on the neighbors only has access to the vertex id_(not the vertex value) of the grouping vertex.__For each vertex, the neighborsFunction can iterate over all neighbors of this vertex_with the specified direction, and emit any number of output elements, including none.__@param neighborsFunction the group reduce function to apply to the neighboring edges and vertices_of each vertex._@param direction the edge direction (in-, out-, all-)._@param <T> the output type_@param typeInfo the explicit return type_@return a DataSet containing elements of type T_@throws IllegalArgumentException;public <T> DataSet<T> groupReduceOnNeighbors(NeighborsFunction<K, VV, EV, T> neighborsFunction,_			EdgeDirection direction, TypeInformation<T> typeInfo) throws IllegalArgumentException {_		switch (direction) {_			case IN:_				_				DataSet<Tuple3<K, Edge<K, EV>, Vertex<K, VV>>> edgesWithSources = edges_						.join(this.vertices).where(0).equalTo(0)_						.with(new ProjectVertexIdJoin<K, VV, EV>(1))_						.withForwardedFieldsFirst("f1->f0")__				return edgesWithSources.groupBy(0).reduceGroup(_					new ApplyNeighborGroupReduceFunction<>(neighborsFunction)).returns(typeInfo)__			case OUT:_				_				DataSet<Tuple3<K, Edge<K, EV>, Vertex<K, VV>>> edgesWithTargets = edges_						.join(this.vertices).where(1).equalTo(0)_						.with(new ProjectVertexIdJoin<K, VV, EV>(0))_						.withForwardedFieldsFirst("f0")__				return edgesWithTargets.groupBy(0).reduceGroup(_					new ApplyNeighborGroupReduceFunction<>(neighborsFunction)).returns(typeInfo)__			case ALL:_				_				DataSet<Tuple3<K, Edge<K, EV>, Vertex<K, VV>>> edgesWithNeighbors = edges_						.flatMap(new EmitOneEdgeWithNeighborPerNode<K, EV>())_						.join(this.vertices).where(1).equalTo(0)_						.with(new ProjectEdgeWithNeighbor<K, VV, EV>())___				return edgesWithNeighbors.groupBy(0).reduceGroup(_					new ApplyNeighborGroupReduceFunction<>(neighborsFunction)).returns(typeInfo)__			default:_				throw new IllegalArgumentException("Illegal edge direction")__		}_	};groups,by,vertex,and,computes,a,group,reduce,transformation,over,the,neighbors,both,edges,and,vertices,of,each,vertex,the,neighbors,function,applied,on,the,neighbors,only,has,access,to,the,vertex,id,not,the,vertex,value,of,the,grouping,vertex,for,each,vertex,the,neighbors,function,can,iterate,over,all,neighbors,of,this,vertex,with,the,specified,direction,and,emit,any,number,of,output,elements,including,none,param,neighbors,function,the,group,reduce,function,to,apply,to,the,neighboring,edges,and,vertices,of,each,vertex,param,direction,the,edge,direction,in,out,all,param,t,the,output,type,param,type,info,the,explicit,return,type,return,a,data,set,containing,elements,of,type,t,throws,illegal,argument,exception;public,t,data,set,t,group,reduce,on,neighbors,neighbors,function,k,vv,ev,t,neighbors,function,edge,direction,direction,type,information,t,type,info,throws,illegal,argument,exception,switch,direction,case,in,data,set,tuple3,k,edge,k,ev,vertex,k,vv,edges,with,sources,edges,join,this,vertices,where,0,equal,to,0,with,new,project,vertex,id,join,k,vv,ev,1,with,forwarded,fields,first,f1,f0,return,edges,with,sources,group,by,0,reduce,group,new,apply,neighbor,group,reduce,function,neighbors,function,returns,type,info,case,out,data,set,tuple3,k,edge,k,ev,vertex,k,vv,edges,with,targets,edges,join,this,vertices,where,1,equal,to,0,with,new,project,vertex,id,join,k,vv,ev,0,with,forwarded,fields,first,f0,return,edges,with,targets,group,by,0,reduce,group,new,apply,neighbor,group,reduce,function,neighbors,function,returns,type,info,case,all,data,set,tuple3,k,edge,k,ev,vertex,k,vv,edges,with,neighbors,edges,flat,map,new,emit,one,edge,with,neighbor,per,node,k,ev,join,this,vertices,where,1,equal,to,0,with,new,project,edge,with,neighbor,k,vv,ev,return,edges,with,neighbors,group,by,0,reduce,group,new,apply,neighbor,group,reduce,function,neighbors,function,returns,type,info,default,throw,new,illegal,argument,exception,illegal,edge,direction
Graph -> public <T> DataSet<T> groupReduceOnNeighbors(NeighborsFunction<K, VV, EV, T> neighborsFunction, 			EdgeDirection direction, TypeInformation<T> typeInfo) throws IllegalArgumentException;1481745825;Groups by vertex and computes a GroupReduce transformation over the neighbors (both edges and vertices)_of each vertex. The neighborsFunction applied on the neighbors only has access to the vertex id_(not the vertex value) of the grouping vertex.__For each vertex, the neighborsFunction can iterate over all neighbors of this vertex_with the specified direction, and emit any number of output elements, including none.__@param neighborsFunction the group reduce function to apply to the neighboring edges and vertices_of each vertex._@param direction the edge direction (in-, out-, all-)._@param <T> the output type_@param typeInfo the explicit return type_@return a DataSet containing elements of type T_@throws IllegalArgumentException;public <T> DataSet<T> groupReduceOnNeighbors(NeighborsFunction<K, VV, EV, T> neighborsFunction,_			EdgeDirection direction, TypeInformation<T> typeInfo) throws IllegalArgumentException {_		switch (direction) {_			case IN:_				_				DataSet<Tuple3<K, Edge<K, EV>, Vertex<K, VV>>> edgesWithSources = edges_						.join(this.vertices).where(0).equalTo(0)_						.with(new ProjectVertexIdJoin<K, VV, EV>(1))_						.withForwardedFieldsFirst("f1->f0").name("Edge with source vertex ID")__				return edgesWithSources.groupBy(0).reduceGroup(_					new ApplyNeighborGroupReduceFunction<>(neighborsFunction))_						.name("Neighbors function").returns(typeInfo)__			case OUT:_				_				DataSet<Tuple3<K, Edge<K, EV>, Vertex<K, VV>>> edgesWithTargets = edges_						.join(this.vertices).where(1).equalTo(0)_						.with(new ProjectVertexIdJoin<K, VV, EV>(0))_						.withForwardedFieldsFirst("f0").name("Edge with target vertex ID")__				return edgesWithTargets.groupBy(0).reduceGroup(_					new ApplyNeighborGroupReduceFunction<>(neighborsFunction))_						.name("Neighbors function").returns(typeInfo)__			case ALL:_				_				DataSet<Tuple3<K, Edge<K, EV>, Vertex<K, VV>>> edgesWithNeighbors = edges_						.flatMap(new EmitOneEdgeWithNeighborPerNode<K, EV>())_						.join(this.vertices).where(1).equalTo(0)_						.with(new ProjectEdgeWithNeighbor<K, VV, EV>()).name("Edge with vertex ID")___				return edgesWithNeighbors.groupBy(0).reduceGroup(_					new ApplyNeighborGroupReduceFunction<>(neighborsFunction))_						.name("Neighbors function").returns(typeInfo)__			default:_				throw new IllegalArgumentException("Illegal edge direction")__		}_	};groups,by,vertex,and,computes,a,group,reduce,transformation,over,the,neighbors,both,edges,and,vertices,of,each,vertex,the,neighbors,function,applied,on,the,neighbors,only,has,access,to,the,vertex,id,not,the,vertex,value,of,the,grouping,vertex,for,each,vertex,the,neighbors,function,can,iterate,over,all,neighbors,of,this,vertex,with,the,specified,direction,and,emit,any,number,of,output,elements,including,none,param,neighbors,function,the,group,reduce,function,to,apply,to,the,neighboring,edges,and,vertices,of,each,vertex,param,direction,the,edge,direction,in,out,all,param,t,the,output,type,param,type,info,the,explicit,return,type,return,a,data,set,containing,elements,of,type,t,throws,illegal,argument,exception;public,t,data,set,t,group,reduce,on,neighbors,neighbors,function,k,vv,ev,t,neighbors,function,edge,direction,direction,type,information,t,type,info,throws,illegal,argument,exception,switch,direction,case,in,data,set,tuple3,k,edge,k,ev,vertex,k,vv,edges,with,sources,edges,join,this,vertices,where,0,equal,to,0,with,new,project,vertex,id,join,k,vv,ev,1,with,forwarded,fields,first,f1,f0,name,edge,with,source,vertex,id,return,edges,with,sources,group,by,0,reduce,group,new,apply,neighbor,group,reduce,function,neighbors,function,name,neighbors,function,returns,type,info,case,out,data,set,tuple3,k,edge,k,ev,vertex,k,vv,edges,with,targets,edges,join,this,vertices,where,1,equal,to,0,with,new,project,vertex,id,join,k,vv,ev,0,with,forwarded,fields,first,f0,name,edge,with,target,vertex,id,return,edges,with,targets,group,by,0,reduce,group,new,apply,neighbor,group,reduce,function,neighbors,function,name,neighbors,function,returns,type,info,case,all,data,set,tuple3,k,edge,k,ev,vertex,k,vv,edges,with,neighbors,edges,flat,map,new,emit,one,edge,with,neighbor,per,node,k,ev,join,this,vertices,where,1,equal,to,0,with,new,project,edge,with,neighbor,k,vv,ev,name,edge,with,vertex,id,return,edges,with,neighbors,group,by,0,reduce,group,new,apply,neighbor,group,reduce,function,neighbors,function,name,neighbors,function,returns,type,info,default,throw,new,illegal,argument,exception,illegal,edge,direction
Graph -> public <T> DataSet<T> groupReduceOnNeighbors(NeighborsFunction<K, VV, EV, T> neighborsFunction, 			EdgeDirection direction, TypeInformation<T> typeInfo) throws IllegalArgumentException;1481881009;Groups by vertex and computes a GroupReduce transformation over the neighbors (both edges and vertices)_of each vertex. The neighborsFunction applied on the neighbors only has access to the vertex id_(not the vertex value) of the grouping vertex.__For each vertex, the neighborsFunction can iterate over all neighbors of this vertex_with the specified direction, and emit any number of output elements, including none.__@param neighborsFunction the group reduce function to apply to the neighboring edges and vertices_of each vertex._@param direction the edge direction (in-, out-, all-)._@param <T> the output type_@param typeInfo the explicit return type_@return a DataSet containing elements of type T_@throws IllegalArgumentException;public <T> DataSet<T> groupReduceOnNeighbors(NeighborsFunction<K, VV, EV, T> neighborsFunction,_			EdgeDirection direction, TypeInformation<T> typeInfo) throws IllegalArgumentException {_		switch (direction) {_			case IN:_				_				DataSet<Tuple3<K, Edge<K, EV>, Vertex<K, VV>>> edgesWithSources = edges_						.join(this.vertices).where(0).equalTo(0)_						.with(new ProjectVertexIdJoin<K, VV, EV>(1))_						.withForwardedFieldsFirst("f1->f0").name("Edge with source vertex ID")__				return edgesWithSources.groupBy(0).reduceGroup(_					new ApplyNeighborGroupReduceFunction<>(neighborsFunction))_						.name("Neighbors function").returns(typeInfo)__			case OUT:_				_				DataSet<Tuple3<K, Edge<K, EV>, Vertex<K, VV>>> edgesWithTargets = edges_						.join(this.vertices).where(1).equalTo(0)_						.with(new ProjectVertexIdJoin<K, VV, EV>(0))_						.withForwardedFieldsFirst("f0").name("Edge with target vertex ID")__				return edgesWithTargets.groupBy(0).reduceGroup(_					new ApplyNeighborGroupReduceFunction<>(neighborsFunction))_						.name("Neighbors function").returns(typeInfo)__			case ALL:_				_				DataSet<Tuple3<K, Edge<K, EV>, Vertex<K, VV>>> edgesWithNeighbors = edges_						.flatMap(new EmitOneEdgeWithNeighborPerNode<K, EV>())_						.join(this.vertices).where(1).equalTo(0)_						.with(new ProjectEdgeWithNeighbor<K, VV, EV>()).name("Edge with vertex ID")___				return edgesWithNeighbors.groupBy(0).reduceGroup(_					new ApplyNeighborGroupReduceFunction<>(neighborsFunction))_						.name("Neighbors function").returns(typeInfo)__			default:_				throw new IllegalArgumentException("Illegal edge direction")__		}_	};groups,by,vertex,and,computes,a,group,reduce,transformation,over,the,neighbors,both,edges,and,vertices,of,each,vertex,the,neighbors,function,applied,on,the,neighbors,only,has,access,to,the,vertex,id,not,the,vertex,value,of,the,grouping,vertex,for,each,vertex,the,neighbors,function,can,iterate,over,all,neighbors,of,this,vertex,with,the,specified,direction,and,emit,any,number,of,output,elements,including,none,param,neighbors,function,the,group,reduce,function,to,apply,to,the,neighboring,edges,and,vertices,of,each,vertex,param,direction,the,edge,direction,in,out,all,param,t,the,output,type,param,type,info,the,explicit,return,type,return,a,data,set,containing,elements,of,type,t,throws,illegal,argument,exception;public,t,data,set,t,group,reduce,on,neighbors,neighbors,function,k,vv,ev,t,neighbors,function,edge,direction,direction,type,information,t,type,info,throws,illegal,argument,exception,switch,direction,case,in,data,set,tuple3,k,edge,k,ev,vertex,k,vv,edges,with,sources,edges,join,this,vertices,where,0,equal,to,0,with,new,project,vertex,id,join,k,vv,ev,1,with,forwarded,fields,first,f1,f0,name,edge,with,source,vertex,id,return,edges,with,sources,group,by,0,reduce,group,new,apply,neighbor,group,reduce,function,neighbors,function,name,neighbors,function,returns,type,info,case,out,data,set,tuple3,k,edge,k,ev,vertex,k,vv,edges,with,targets,edges,join,this,vertices,where,1,equal,to,0,with,new,project,vertex,id,join,k,vv,ev,0,with,forwarded,fields,first,f0,name,edge,with,target,vertex,id,return,edges,with,targets,group,by,0,reduce,group,new,apply,neighbor,group,reduce,function,neighbors,function,name,neighbors,function,returns,type,info,case,all,data,set,tuple3,k,edge,k,ev,vertex,k,vv,edges,with,neighbors,edges,flat,map,new,emit,one,edge,with,neighbor,per,node,k,ev,join,this,vertices,where,1,equal,to,0,with,new,project,edge,with,neighbor,k,vv,ev,name,edge,with,vertex,id,return,edges,with,neighbors,group,by,0,reduce,group,new,apply,neighbor,group,reduce,function,neighbors,function,name,neighbors,function,returns,type,info,default,throw,new,illegal,argument,exception,illegal,edge,direction
Graph -> public <T> DataSet<T> groupReduceOnNeighbors(NeighborsFunction<K, VV, EV, T> neighborsFunction, 			EdgeDirection direction, TypeInformation<T> typeInfo) throws IllegalArgumentException;1484160227;Groups by vertex and computes a GroupReduce transformation over the neighbors (both edges and vertices)_of each vertex. The neighborsFunction applied on the neighbors only has access to the vertex id_(not the vertex value) of the grouping vertex.__For each vertex, the neighborsFunction can iterate over all neighbors of this vertex_with the specified direction, and emit any number of output elements, including none.__@param neighborsFunction the group reduce function to apply to the neighboring edges and vertices_of each vertex._@param direction the edge direction (in-, out-, all-)._@param <T> the output type_@param typeInfo the explicit return type_@return a DataSet containing elements of type T_@throws IllegalArgumentException;public <T> DataSet<T> groupReduceOnNeighbors(NeighborsFunction<K, VV, EV, T> neighborsFunction,_			EdgeDirection direction, TypeInformation<T> typeInfo) throws IllegalArgumentException {_		switch (direction) {_			case IN:_				_				DataSet<Tuple3<K, Edge<K, EV>, Vertex<K, VV>>> edgesWithSources = edges_						.join(this.vertices).where(0).equalTo(0)_						.with(new ProjectVertexIdJoin<K, VV, EV>(1))_						.withForwardedFieldsFirst("f1->f0").name("Edge with source vertex ID")__				return edgesWithSources.groupBy(0).reduceGroup(_					new ApplyNeighborGroupReduceFunction<>(neighborsFunction))_						.name("Neighbors function").returns(typeInfo)__			case OUT:_				_				DataSet<Tuple3<K, Edge<K, EV>, Vertex<K, VV>>> edgesWithTargets = edges_						.join(this.vertices).where(1).equalTo(0)_						.with(new ProjectVertexIdJoin<K, VV, EV>(0))_						.withForwardedFieldsFirst("f0").name("Edge with target vertex ID")__				return edgesWithTargets.groupBy(0).reduceGroup(_					new ApplyNeighborGroupReduceFunction<>(neighborsFunction))_						.name("Neighbors function").returns(typeInfo)__			case ALL:_				_				DataSet<Tuple3<K, Edge<K, EV>, Vertex<K, VV>>> edgesWithNeighbors = edges_						.flatMap(new EmitOneEdgeWithNeighborPerNode<K, EV>())_						.join(this.vertices).where(1).equalTo(0)_						.with(new ProjectEdgeWithNeighbor<K, VV, EV>()).name("Edge with vertex ID")___				return edgesWithNeighbors.groupBy(0).reduceGroup(_					new ApplyNeighborGroupReduceFunction<>(neighborsFunction))_						.name("Neighbors function").returns(typeInfo)__			default:_				throw new IllegalArgumentException("Illegal edge direction")__		}_	};groups,by,vertex,and,computes,a,group,reduce,transformation,over,the,neighbors,both,edges,and,vertices,of,each,vertex,the,neighbors,function,applied,on,the,neighbors,only,has,access,to,the,vertex,id,not,the,vertex,value,of,the,grouping,vertex,for,each,vertex,the,neighbors,function,can,iterate,over,all,neighbors,of,this,vertex,with,the,specified,direction,and,emit,any,number,of,output,elements,including,none,param,neighbors,function,the,group,reduce,function,to,apply,to,the,neighboring,edges,and,vertices,of,each,vertex,param,direction,the,edge,direction,in,out,all,param,t,the,output,type,param,type,info,the,explicit,return,type,return,a,data,set,containing,elements,of,type,t,throws,illegal,argument,exception;public,t,data,set,t,group,reduce,on,neighbors,neighbors,function,k,vv,ev,t,neighbors,function,edge,direction,direction,type,information,t,type,info,throws,illegal,argument,exception,switch,direction,case,in,data,set,tuple3,k,edge,k,ev,vertex,k,vv,edges,with,sources,edges,join,this,vertices,where,0,equal,to,0,with,new,project,vertex,id,join,k,vv,ev,1,with,forwarded,fields,first,f1,f0,name,edge,with,source,vertex,id,return,edges,with,sources,group,by,0,reduce,group,new,apply,neighbor,group,reduce,function,neighbors,function,name,neighbors,function,returns,type,info,case,out,data,set,tuple3,k,edge,k,ev,vertex,k,vv,edges,with,targets,edges,join,this,vertices,where,1,equal,to,0,with,new,project,vertex,id,join,k,vv,ev,0,with,forwarded,fields,first,f0,name,edge,with,target,vertex,id,return,edges,with,targets,group,by,0,reduce,group,new,apply,neighbor,group,reduce,function,neighbors,function,name,neighbors,function,returns,type,info,case,all,data,set,tuple3,k,edge,k,ev,vertex,k,vv,edges,with,neighbors,edges,flat,map,new,emit,one,edge,with,neighbor,per,node,k,ev,join,this,vertices,where,1,equal,to,0,with,new,project,edge,with,neighbor,k,vv,ev,name,edge,with,vertex,id,return,edges,with,neighbors,group,by,0,reduce,group,new,apply,neighbor,group,reduce,function,neighbors,function,name,neighbors,function,returns,type,info,default,throw,new,illegal,argument,exception,illegal,edge,direction
Graph -> public <T> DataSet<T> groupReduceOnNeighbors(NeighborsFunction<K, VV, EV, T> neighborsFunction, 			EdgeDirection direction, TypeInformation<T> typeInfo) throws IllegalArgumentException;1484685504;Groups by vertex and computes a GroupReduce transformation over the neighbors (both edges and vertices)_of each vertex. The neighborsFunction applied on the neighbors only has access to the vertex id_(not the vertex value) of the grouping vertex.__For each vertex, the neighborsFunction can iterate over all neighbors of this vertex_with the specified direction, and emit any number of output elements, including none.__@param neighborsFunction the group reduce function to apply to the neighboring edges and vertices_of each vertex._@param direction the edge direction (in-, out-, all-)._@param <T> the output type_@param typeInfo the explicit return type_@return a DataSet containing elements of type T_@throws IllegalArgumentException;public <T> DataSet<T> groupReduceOnNeighbors(NeighborsFunction<K, VV, EV, T> neighborsFunction,_			EdgeDirection direction, TypeInformation<T> typeInfo) throws IllegalArgumentException {_		switch (direction) {_			case IN:_				_				DataSet<Tuple3<K, Edge<K, EV>, Vertex<K, VV>>> edgesWithSources = edges_						.join(this.vertices).where(0).equalTo(0)_						.with(new ProjectVertexIdJoin<K, VV, EV>(1))_						.withForwardedFieldsFirst("f1->f0").name("Edge with source vertex ID")__				return edgesWithSources.groupBy(0).reduceGroup(_					new ApplyNeighborGroupReduceFunction<>(neighborsFunction))_						.name("Neighbors function").returns(typeInfo)__			case OUT:_				_				DataSet<Tuple3<K, Edge<K, EV>, Vertex<K, VV>>> edgesWithTargets = edges_						.join(this.vertices).where(1).equalTo(0)_						.with(new ProjectVertexIdJoin<K, VV, EV>(0))_						.withForwardedFieldsFirst("f0").name("Edge with target vertex ID")__				return edgesWithTargets.groupBy(0).reduceGroup(_					new ApplyNeighborGroupReduceFunction<>(neighborsFunction))_						.name("Neighbors function").returns(typeInfo)__			case ALL:_				_				DataSet<Tuple3<K, Edge<K, EV>, Vertex<K, VV>>> edgesWithNeighbors = edges_						.flatMap(new EmitOneEdgeWithNeighborPerNode<K, EV>())_						.join(this.vertices).where(1).equalTo(0)_						.with(new ProjectEdgeWithNeighbor<K, VV, EV>()).name("Edge with vertex ID")___				return edgesWithNeighbors.groupBy(0).reduceGroup(_					new ApplyNeighborGroupReduceFunction<>(neighborsFunction))_						.name("Neighbors function").returns(typeInfo)__			default:_				throw new IllegalArgumentException("Illegal edge direction")__		}_	};groups,by,vertex,and,computes,a,group,reduce,transformation,over,the,neighbors,both,edges,and,vertices,of,each,vertex,the,neighbors,function,applied,on,the,neighbors,only,has,access,to,the,vertex,id,not,the,vertex,value,of,the,grouping,vertex,for,each,vertex,the,neighbors,function,can,iterate,over,all,neighbors,of,this,vertex,with,the,specified,direction,and,emit,any,number,of,output,elements,including,none,param,neighbors,function,the,group,reduce,function,to,apply,to,the,neighboring,edges,and,vertices,of,each,vertex,param,direction,the,edge,direction,in,out,all,param,t,the,output,type,param,type,info,the,explicit,return,type,return,a,data,set,containing,elements,of,type,t,throws,illegal,argument,exception;public,t,data,set,t,group,reduce,on,neighbors,neighbors,function,k,vv,ev,t,neighbors,function,edge,direction,direction,type,information,t,type,info,throws,illegal,argument,exception,switch,direction,case,in,data,set,tuple3,k,edge,k,ev,vertex,k,vv,edges,with,sources,edges,join,this,vertices,where,0,equal,to,0,with,new,project,vertex,id,join,k,vv,ev,1,with,forwarded,fields,first,f1,f0,name,edge,with,source,vertex,id,return,edges,with,sources,group,by,0,reduce,group,new,apply,neighbor,group,reduce,function,neighbors,function,name,neighbors,function,returns,type,info,case,out,data,set,tuple3,k,edge,k,ev,vertex,k,vv,edges,with,targets,edges,join,this,vertices,where,1,equal,to,0,with,new,project,vertex,id,join,k,vv,ev,0,with,forwarded,fields,first,f0,name,edge,with,target,vertex,id,return,edges,with,targets,group,by,0,reduce,group,new,apply,neighbor,group,reduce,function,neighbors,function,name,neighbors,function,returns,type,info,case,all,data,set,tuple3,k,edge,k,ev,vertex,k,vv,edges,with,neighbors,edges,flat,map,new,emit,one,edge,with,neighbor,per,node,k,ev,join,this,vertices,where,1,equal,to,0,with,new,project,edge,with,neighbor,k,vv,ev,name,edge,with,vertex,id,return,edges,with,neighbors,group,by,0,reduce,group,new,apply,neighbor,group,reduce,function,neighbors,function,name,neighbors,function,returns,type,info,default,throw,new,illegal,argument,exception,illegal,edge,direction
Graph -> public <T> DataSet<T> groupReduceOnNeighbors(NeighborsFunction<K, VV, EV, T> neighborsFunction, 			EdgeDirection direction, TypeInformation<T> typeInfo) throws IllegalArgumentException;1489068942;Groups by vertex and computes a GroupReduce transformation over the neighbors (both edges and vertices)_of each vertex. The neighborsFunction applied on the neighbors only has access to the vertex id_(not the vertex value) of the grouping vertex.__For each vertex, the neighborsFunction can iterate over all neighbors of this vertex_with the specified direction, and emit any number of output elements, including none.__@param neighborsFunction the group reduce function to apply to the neighboring edges and vertices_of each vertex._@param direction the edge direction (in-, out-, all-)._@param <T> the output type_@param typeInfo the explicit return type_@return a DataSet containing elements of type T_@throws IllegalArgumentException;public <T> DataSet<T> groupReduceOnNeighbors(NeighborsFunction<K, VV, EV, T> neighborsFunction,_			EdgeDirection direction, TypeInformation<T> typeInfo) throws IllegalArgumentException {_		switch (direction) {_			case IN:_				_				DataSet<Tuple3<K, Edge<K, EV>, Vertex<K, VV>>> edgesWithSources = edges_						.join(this.vertices).where(0).equalTo(0)_						.with(new ProjectVertexIdJoin<K, VV, EV>(1))_						.withForwardedFieldsFirst("f1->f0").name("Edge with source vertex ID")__				return edgesWithSources.groupBy(0).reduceGroup(_					new ApplyNeighborGroupReduceFunction<>(neighborsFunction))_						.name("Neighbors function").returns(typeInfo)__			case OUT:_				_				DataSet<Tuple3<K, Edge<K, EV>, Vertex<K, VV>>> edgesWithTargets = edges_						.join(this.vertices).where(1).equalTo(0)_						.with(new ProjectVertexIdJoin<K, VV, EV>(0))_						.withForwardedFieldsFirst("f0").name("Edge with target vertex ID")__				return edgesWithTargets.groupBy(0).reduceGroup(_					new ApplyNeighborGroupReduceFunction<>(neighborsFunction))_						.name("Neighbors function").returns(typeInfo)__			case ALL:_				_				DataSet<Tuple3<K, Edge<K, EV>, Vertex<K, VV>>> edgesWithNeighbors = edges_						.flatMap(new EmitOneEdgeWithNeighborPerNode<K, EV>())_						.join(this.vertices).where(1).equalTo(0)_						.with(new ProjectEdgeWithNeighbor<K, VV, EV>()).name("Edge with vertex ID")___				return edgesWithNeighbors.groupBy(0).reduceGroup(_					new ApplyNeighborGroupReduceFunction<>(neighborsFunction))_						.name("Neighbors function").returns(typeInfo)__			default:_				throw new IllegalArgumentException("Illegal edge direction")__		}_	};groups,by,vertex,and,computes,a,group,reduce,transformation,over,the,neighbors,both,edges,and,vertices,of,each,vertex,the,neighbors,function,applied,on,the,neighbors,only,has,access,to,the,vertex,id,not,the,vertex,value,of,the,grouping,vertex,for,each,vertex,the,neighbors,function,can,iterate,over,all,neighbors,of,this,vertex,with,the,specified,direction,and,emit,any,number,of,output,elements,including,none,param,neighbors,function,the,group,reduce,function,to,apply,to,the,neighboring,edges,and,vertices,of,each,vertex,param,direction,the,edge,direction,in,out,all,param,t,the,output,type,param,type,info,the,explicit,return,type,return,a,data,set,containing,elements,of,type,t,throws,illegal,argument,exception;public,t,data,set,t,group,reduce,on,neighbors,neighbors,function,k,vv,ev,t,neighbors,function,edge,direction,direction,type,information,t,type,info,throws,illegal,argument,exception,switch,direction,case,in,data,set,tuple3,k,edge,k,ev,vertex,k,vv,edges,with,sources,edges,join,this,vertices,where,0,equal,to,0,with,new,project,vertex,id,join,k,vv,ev,1,with,forwarded,fields,first,f1,f0,name,edge,with,source,vertex,id,return,edges,with,sources,group,by,0,reduce,group,new,apply,neighbor,group,reduce,function,neighbors,function,name,neighbors,function,returns,type,info,case,out,data,set,tuple3,k,edge,k,ev,vertex,k,vv,edges,with,targets,edges,join,this,vertices,where,1,equal,to,0,with,new,project,vertex,id,join,k,vv,ev,0,with,forwarded,fields,first,f0,name,edge,with,target,vertex,id,return,edges,with,targets,group,by,0,reduce,group,new,apply,neighbor,group,reduce,function,neighbors,function,name,neighbors,function,returns,type,info,case,all,data,set,tuple3,k,edge,k,ev,vertex,k,vv,edges,with,neighbors,edges,flat,map,new,emit,one,edge,with,neighbor,per,node,k,ev,join,this,vertices,where,1,equal,to,0,with,new,project,edge,with,neighbor,k,vv,ev,name,edge,with,vertex,id,return,edges,with,neighbors,group,by,0,reduce,group,new,apply,neighbor,group,reduce,function,neighbors,function,name,neighbors,function,returns,type,info,default,throw,new,illegal,argument,exception,illegal,edge,direction
Graph -> public <T> DataSet<T> groupReduceOnNeighbors(NeighborsFunction<K, VV, EV, T> neighborsFunction, 			EdgeDirection direction, TypeInformation<T> typeInfo) throws IllegalArgumentException;1490973446;Groups by vertex and computes a GroupReduce transformation over the neighbors (both edges and vertices)_of each vertex. The neighborsFunction applied on the neighbors only has access to the vertex id_(not the vertex value) of the grouping vertex.__For each vertex, the neighborsFunction can iterate over all neighbors of this vertex_with the specified direction, and emit any number of output elements, including none.__@param neighborsFunction the group reduce function to apply to the neighboring edges and vertices_of each vertex._@param direction the edge direction (in-, out-, all-)._@param <T> the output type_@param typeInfo the explicit return type_@return a DataSet containing elements of type T_@throws IllegalArgumentException;public <T> DataSet<T> groupReduceOnNeighbors(NeighborsFunction<K, VV, EV, T> neighborsFunction,_			EdgeDirection direction, TypeInformation<T> typeInfo) throws IllegalArgumentException {_		switch (direction) {_			case IN:_				_				DataSet<Tuple3<K, Edge<K, EV>, Vertex<K, VV>>> edgesWithSources = edges_						.join(this.vertices).where(0).equalTo(0)_						.with(new ProjectVertexIdJoin<K, VV, EV>(1))_						.withForwardedFieldsFirst("f1->f0").name("Edge with source vertex ID")__				return edgesWithSources.groupBy(0).reduceGroup(_					new ApplyNeighborGroupReduceFunction<>(neighborsFunction))_						.name("Neighbors function").returns(typeInfo)__			case OUT:_				_				DataSet<Tuple3<K, Edge<K, EV>, Vertex<K, VV>>> edgesWithTargets = edges_						.join(this.vertices).where(1).equalTo(0)_						.with(new ProjectVertexIdJoin<K, VV, EV>(0))_						.withForwardedFieldsFirst("f0").name("Edge with target vertex ID")__				return edgesWithTargets.groupBy(0).reduceGroup(_					new ApplyNeighborGroupReduceFunction<>(neighborsFunction))_						.name("Neighbors function").returns(typeInfo)__			case ALL:_				_				DataSet<Tuple3<K, Edge<K, EV>, Vertex<K, VV>>> edgesWithNeighbors = edges_						.flatMap(new EmitOneEdgeWithNeighborPerNode<K, EV>())_						.join(this.vertices).where(1).equalTo(0)_						.with(new ProjectEdgeWithNeighbor<K, VV, EV>()).name("Edge with vertex ID")___				return edgesWithNeighbors.groupBy(0).reduceGroup(_					new ApplyNeighborGroupReduceFunction<>(neighborsFunction))_						.name("Neighbors function").returns(typeInfo)__			default:_				throw new IllegalArgumentException("Illegal edge direction")__		}_	};groups,by,vertex,and,computes,a,group,reduce,transformation,over,the,neighbors,both,edges,and,vertices,of,each,vertex,the,neighbors,function,applied,on,the,neighbors,only,has,access,to,the,vertex,id,not,the,vertex,value,of,the,grouping,vertex,for,each,vertex,the,neighbors,function,can,iterate,over,all,neighbors,of,this,vertex,with,the,specified,direction,and,emit,any,number,of,output,elements,including,none,param,neighbors,function,the,group,reduce,function,to,apply,to,the,neighboring,edges,and,vertices,of,each,vertex,param,direction,the,edge,direction,in,out,all,param,t,the,output,type,param,type,info,the,explicit,return,type,return,a,data,set,containing,elements,of,type,t,throws,illegal,argument,exception;public,t,data,set,t,group,reduce,on,neighbors,neighbors,function,k,vv,ev,t,neighbors,function,edge,direction,direction,type,information,t,type,info,throws,illegal,argument,exception,switch,direction,case,in,data,set,tuple3,k,edge,k,ev,vertex,k,vv,edges,with,sources,edges,join,this,vertices,where,0,equal,to,0,with,new,project,vertex,id,join,k,vv,ev,1,with,forwarded,fields,first,f1,f0,name,edge,with,source,vertex,id,return,edges,with,sources,group,by,0,reduce,group,new,apply,neighbor,group,reduce,function,neighbors,function,name,neighbors,function,returns,type,info,case,out,data,set,tuple3,k,edge,k,ev,vertex,k,vv,edges,with,targets,edges,join,this,vertices,where,1,equal,to,0,with,new,project,vertex,id,join,k,vv,ev,0,with,forwarded,fields,first,f0,name,edge,with,target,vertex,id,return,edges,with,targets,group,by,0,reduce,group,new,apply,neighbor,group,reduce,function,neighbors,function,name,neighbors,function,returns,type,info,case,all,data,set,tuple3,k,edge,k,ev,vertex,k,vv,edges,with,neighbors,edges,flat,map,new,emit,one,edge,with,neighbor,per,node,k,ev,join,this,vertices,where,1,equal,to,0,with,new,project,edge,with,neighbor,k,vv,ev,name,edge,with,vertex,id,return,edges,with,neighbors,group,by,0,reduce,group,new,apply,neighbor,group,reduce,function,neighbors,function,name,neighbors,function,returns,type,info,default,throw,new,illegal,argument,exception,illegal,edge,direction
Graph -> public <T> DataSet<T> groupReduceOnNeighbors(NeighborsFunction<K, VV, EV, T> neighborsFunction, 			EdgeDirection direction, TypeInformation<T> typeInfo) throws IllegalArgumentException;1495819075;Groups by vertex and computes a GroupReduce transformation over the neighbors (both edges and vertices)_of each vertex. The neighborsFunction applied on the neighbors only has access to the vertex id_(not the vertex value) of the grouping vertex.__<p>For each vertex, the neighborsFunction can iterate over all neighbors of this vertex_with the specified direction, and emit any number of output elements, including none.__@param neighborsFunction the group reduce function to apply to the neighboring edges and vertices_of each vertex._@param direction the edge direction (in-, out-, all-)._@param <T> the output type_@param typeInfo the explicit return type_@return a DataSet containing elements of type T_@throws IllegalArgumentException;public <T> DataSet<T> groupReduceOnNeighbors(NeighborsFunction<K, VV, EV, T> neighborsFunction,_			EdgeDirection direction, TypeInformation<T> typeInfo) throws IllegalArgumentException {_		switch (direction) {_			case IN:_				_				DataSet<Tuple3<K, Edge<K, EV>, Vertex<K, VV>>> edgesWithSources = edges_						.join(this.vertices).where(0).equalTo(0)_						.with(new ProjectVertexIdJoin<K, VV, EV>(1))_						.withForwardedFieldsFirst("f1->f0").name("Edge with source vertex ID")__				return edgesWithSources.groupBy(0).reduceGroup(_					new ApplyNeighborGroupReduceFunction<>(neighborsFunction))_						.name("Neighbors function").returns(typeInfo)__			case OUT:_				_				DataSet<Tuple3<K, Edge<K, EV>, Vertex<K, VV>>> edgesWithTargets = edges_						.join(this.vertices).where(1).equalTo(0)_						.with(new ProjectVertexIdJoin<K, VV, EV>(0))_						.withForwardedFieldsFirst("f0").name("Edge with target vertex ID")__				return edgesWithTargets.groupBy(0).reduceGroup(_					new ApplyNeighborGroupReduceFunction<>(neighborsFunction))_						.name("Neighbors function").returns(typeInfo)__			case ALL:_				_				DataSet<Tuple3<K, Edge<K, EV>, Vertex<K, VV>>> edgesWithNeighbors = edges_						.flatMap(new EmitOneEdgeWithNeighborPerNode<K, EV>())_						.join(this.vertices).where(1).equalTo(0)_						.with(new ProjectEdgeWithNeighbor<K, VV, EV>()).name("Edge with vertex ID")___				return edgesWithNeighbors.groupBy(0).reduceGroup(_					new ApplyNeighborGroupReduceFunction<>(neighborsFunction))_						.name("Neighbors function").returns(typeInfo)__			default:_				throw new IllegalArgumentException("Illegal edge direction")__		}_	};groups,by,vertex,and,computes,a,group,reduce,transformation,over,the,neighbors,both,edges,and,vertices,of,each,vertex,the,neighbors,function,applied,on,the,neighbors,only,has,access,to,the,vertex,id,not,the,vertex,value,of,the,grouping,vertex,p,for,each,vertex,the,neighbors,function,can,iterate,over,all,neighbors,of,this,vertex,with,the,specified,direction,and,emit,any,number,of,output,elements,including,none,param,neighbors,function,the,group,reduce,function,to,apply,to,the,neighboring,edges,and,vertices,of,each,vertex,param,direction,the,edge,direction,in,out,all,param,t,the,output,type,param,type,info,the,explicit,return,type,return,a,data,set,containing,elements,of,type,t,throws,illegal,argument,exception;public,t,data,set,t,group,reduce,on,neighbors,neighbors,function,k,vv,ev,t,neighbors,function,edge,direction,direction,type,information,t,type,info,throws,illegal,argument,exception,switch,direction,case,in,data,set,tuple3,k,edge,k,ev,vertex,k,vv,edges,with,sources,edges,join,this,vertices,where,0,equal,to,0,with,new,project,vertex,id,join,k,vv,ev,1,with,forwarded,fields,first,f1,f0,name,edge,with,source,vertex,id,return,edges,with,sources,group,by,0,reduce,group,new,apply,neighbor,group,reduce,function,neighbors,function,name,neighbors,function,returns,type,info,case,out,data,set,tuple3,k,edge,k,ev,vertex,k,vv,edges,with,targets,edges,join,this,vertices,where,1,equal,to,0,with,new,project,vertex,id,join,k,vv,ev,0,with,forwarded,fields,first,f0,name,edge,with,target,vertex,id,return,edges,with,targets,group,by,0,reduce,group,new,apply,neighbor,group,reduce,function,neighbors,function,name,neighbors,function,returns,type,info,case,all,data,set,tuple3,k,edge,k,ev,vertex,k,vv,edges,with,neighbors,edges,flat,map,new,emit,one,edge,with,neighbor,per,node,k,ev,join,this,vertices,where,1,equal,to,0,with,new,project,edge,with,neighbor,k,vv,ev,name,edge,with,vertex,id,return,edges,with,neighbors,group,by,0,reduce,group,new,apply,neighbor,group,reduce,function,neighbors,function,name,neighbors,function,returns,type,info,default,throw,new,illegal,argument,exception,illegal,edge,direction
Graph -> public <T> DataSet<T> groupReduceOnNeighbors(NeighborsFunction<K, VV, EV, T> neighborsFunction, 			EdgeDirection direction, TypeInformation<T> typeInfo) throws IllegalArgumentException;1502111816;Groups by vertex and computes a GroupReduce transformation over the neighbors (both edges and vertices)_of each vertex. The neighborsFunction applied on the neighbors only has access to the vertex id_(not the vertex value) of the grouping vertex.__<p>For each vertex, the neighborsFunction can iterate over all neighbors of this vertex_with the specified direction, and emit any number of output elements, including none.__@param neighborsFunction the group reduce function to apply to the neighboring edges and vertices_of each vertex._@param direction the edge direction (in-, out-, all-)._@param <T> the output type_@param typeInfo the explicit return type_@return a DataSet containing elements of type T_@throws IllegalArgumentException;public <T> DataSet<T> groupReduceOnNeighbors(NeighborsFunction<K, VV, EV, T> neighborsFunction,_			EdgeDirection direction, TypeInformation<T> typeInfo) throws IllegalArgumentException {_		switch (direction) {_			case IN:_				_				DataSet<Tuple3<K, Edge<K, EV>, Vertex<K, VV>>> edgesWithSources = edges_						.join(this.vertices).where(0).equalTo(0)_						.with(new ProjectVertexIdJoin<>(1))_						.withForwardedFieldsFirst("f1->f0").name("Edge with source vertex ID")__				return edgesWithSources.groupBy(0).reduceGroup(_					new ApplyNeighborGroupReduceFunction<>(neighborsFunction))_						.name("Neighbors function").returns(typeInfo)__			case OUT:_				_				DataSet<Tuple3<K, Edge<K, EV>, Vertex<K, VV>>> edgesWithTargets = edges_						.join(this.vertices).where(1).equalTo(0)_						.with(new ProjectVertexIdJoin<>(0))_						.withForwardedFieldsFirst("f0").name("Edge with target vertex ID")__				return edgesWithTargets.groupBy(0).reduceGroup(_					new ApplyNeighborGroupReduceFunction<>(neighborsFunction))_						.name("Neighbors function").returns(typeInfo)__			case ALL:_				_				DataSet<Tuple3<K, Edge<K, EV>, Vertex<K, VV>>> edgesWithNeighbors = edges_						.flatMap(new EmitOneEdgeWithNeighborPerNode<>())_						.join(this.vertices).where(1).equalTo(0)_						.with(new ProjectEdgeWithNeighbor<>()).name("Edge with vertex ID")___				return edgesWithNeighbors.groupBy(0).reduceGroup(_					new ApplyNeighborGroupReduceFunction<>(neighborsFunction))_						.name("Neighbors function").returns(typeInfo)__			default:_				throw new IllegalArgumentException("Illegal edge direction")__		}_	};groups,by,vertex,and,computes,a,group,reduce,transformation,over,the,neighbors,both,edges,and,vertices,of,each,vertex,the,neighbors,function,applied,on,the,neighbors,only,has,access,to,the,vertex,id,not,the,vertex,value,of,the,grouping,vertex,p,for,each,vertex,the,neighbors,function,can,iterate,over,all,neighbors,of,this,vertex,with,the,specified,direction,and,emit,any,number,of,output,elements,including,none,param,neighbors,function,the,group,reduce,function,to,apply,to,the,neighboring,edges,and,vertices,of,each,vertex,param,direction,the,edge,direction,in,out,all,param,t,the,output,type,param,type,info,the,explicit,return,type,return,a,data,set,containing,elements,of,type,t,throws,illegal,argument,exception;public,t,data,set,t,group,reduce,on,neighbors,neighbors,function,k,vv,ev,t,neighbors,function,edge,direction,direction,type,information,t,type,info,throws,illegal,argument,exception,switch,direction,case,in,data,set,tuple3,k,edge,k,ev,vertex,k,vv,edges,with,sources,edges,join,this,vertices,where,0,equal,to,0,with,new,project,vertex,id,join,1,with,forwarded,fields,first,f1,f0,name,edge,with,source,vertex,id,return,edges,with,sources,group,by,0,reduce,group,new,apply,neighbor,group,reduce,function,neighbors,function,name,neighbors,function,returns,type,info,case,out,data,set,tuple3,k,edge,k,ev,vertex,k,vv,edges,with,targets,edges,join,this,vertices,where,1,equal,to,0,with,new,project,vertex,id,join,0,with,forwarded,fields,first,f0,name,edge,with,target,vertex,id,return,edges,with,targets,group,by,0,reduce,group,new,apply,neighbor,group,reduce,function,neighbors,function,name,neighbors,function,returns,type,info,case,all,data,set,tuple3,k,edge,k,ev,vertex,k,vv,edges,with,neighbors,edges,flat,map,new,emit,one,edge,with,neighbor,per,node,join,this,vertices,where,1,equal,to,0,with,new,project,edge,with,neighbor,name,edge,with,vertex,id,return,edges,with,neighbors,group,by,0,reduce,group,new,apply,neighbor,group,reduce,function,neighbors,function,name,neighbors,function,returns,type,info,default,throw,new,illegal,argument,exception,illegal,edge,direction
Graph -> public Graph<K, VV, EV> subgraph(FilterFunction<Vertex<K, VV>> vertexFilter, FilterFunction<Edge<K, EV>> edgeFilter);1444404795;Apply filtering functions to the graph and return a sub-graph that_satisfies the predicates for both vertices and edges.__@param vertexFilter the filter function for vertices._@param edgeFilter the filter function for edges._@return the resulting sub-graph.;public Graph<K, VV, EV> subgraph(FilterFunction<Vertex<K, VV>> vertexFilter, FilterFunction<Edge<K, EV>> edgeFilter) {__		DataSet<Vertex<K, VV>> filteredVertices = this.vertices.filter(vertexFilter)___		DataSet<Edge<K, EV>> remainingEdges = this.edges.join(filteredVertices)_				.where(0).equalTo(0).with(new ProjectEdge<K, VV, EV>())_				.join(filteredVertices).where(1).equalTo(0)_				.with(new ProjectEdge<K, VV, EV>())___		DataSet<Edge<K, EV>> filteredEdges = remainingEdges.filter(edgeFilter)___		return new Graph<K, VV, EV>(filteredVertices, filteredEdges,_				this.context)__	};apply,filtering,functions,to,the,graph,and,return,a,sub,graph,that,satisfies,the,predicates,for,both,vertices,and,edges,param,vertex,filter,the,filter,function,for,vertices,param,edge,filter,the,filter,function,for,edges,return,the,resulting,sub,graph;public,graph,k,vv,ev,subgraph,filter,function,vertex,k,vv,vertex,filter,filter,function,edge,k,ev,edge,filter,data,set,vertex,k,vv,filtered,vertices,this,vertices,filter,vertex,filter,data,set,edge,k,ev,remaining,edges,this,edges,join,filtered,vertices,where,0,equal,to,0,with,new,project,edge,k,vv,ev,join,filtered,vertices,where,1,equal,to,0,with,new,project,edge,k,vv,ev,data,set,edge,k,ev,filtered,edges,remaining,edges,filter,edge,filter,return,new,graph,k,vv,ev,filtered,vertices,filtered,edges,this,context
Graph -> public Graph<K, VV, EV> subgraph(FilterFunction<Vertex<K, VV>> vertexFilter, FilterFunction<Edge<K, EV>> edgeFilter);1445261977;Apply filtering functions to the graph and return a sub-graph that_satisfies the predicates for both vertices and edges.__@param vertexFilter the filter function for vertices._@param edgeFilter the filter function for edges._@return the resulting sub-graph.;public Graph<K, VV, EV> subgraph(FilterFunction<Vertex<K, VV>> vertexFilter, FilterFunction<Edge<K, EV>> edgeFilter) {__		DataSet<Vertex<K, VV>> filteredVertices = this.vertices.filter(vertexFilter)___		DataSet<Edge<K, EV>> remainingEdges = this.edges.join(filteredVertices)_				.where(0).equalTo(0).with(new ProjectEdge<K, VV, EV>())_				.join(filteredVertices).where(1).equalTo(0)_				.with(new ProjectEdge<K, VV, EV>())___		DataSet<Edge<K, EV>> filteredEdges = remainingEdges.filter(edgeFilter)___		return new Graph<K, VV, EV>(filteredVertices, filteredEdges,_				this.context)__	};apply,filtering,functions,to,the,graph,and,return,a,sub,graph,that,satisfies,the,predicates,for,both,vertices,and,edges,param,vertex,filter,the,filter,function,for,vertices,param,edge,filter,the,filter,function,for,edges,return,the,resulting,sub,graph;public,graph,k,vv,ev,subgraph,filter,function,vertex,k,vv,vertex,filter,filter,function,edge,k,ev,edge,filter,data,set,vertex,k,vv,filtered,vertices,this,vertices,filter,vertex,filter,data,set,edge,k,ev,remaining,edges,this,edges,join,filtered,vertices,where,0,equal,to,0,with,new,project,edge,k,vv,ev,join,filtered,vertices,where,1,equal,to,0,with,new,project,edge,k,vv,ev,data,set,edge,k,ev,filtered,edges,remaining,edges,filter,edge,filter,return,new,graph,k,vv,ev,filtered,vertices,filtered,edges,this,context
Graph -> public Graph<K, VV, EV> subgraph(FilterFunction<Vertex<K, VV>> vertexFilter, FilterFunction<Edge<K, EV>> edgeFilter);1445854323;Apply filtering functions to the graph and return a sub-graph that_satisfies the predicates for both vertices and edges.__@param vertexFilter the filter function for vertices._@param edgeFilter the filter function for edges._@return the resulting sub-graph.;public Graph<K, VV, EV> subgraph(FilterFunction<Vertex<K, VV>> vertexFilter, FilterFunction<Edge<K, EV>> edgeFilter) {__		DataSet<Vertex<K, VV>> filteredVertices = this.vertices.filter(vertexFilter)___		DataSet<Edge<K, EV>> remainingEdges = this.edges.join(filteredVertices)_				.where(0).equalTo(0).with(new ProjectEdge<K, VV, EV>())_				.join(filteredVertices).where(1).equalTo(0)_				.with(new ProjectEdge<K, VV, EV>())___		DataSet<Edge<K, EV>> filteredEdges = remainingEdges.filter(edgeFilter)___		return new Graph<K, VV, EV>(filteredVertices, filteredEdges,_				this.context)__	};apply,filtering,functions,to,the,graph,and,return,a,sub,graph,that,satisfies,the,predicates,for,both,vertices,and,edges,param,vertex,filter,the,filter,function,for,vertices,param,edge,filter,the,filter,function,for,edges,return,the,resulting,sub,graph;public,graph,k,vv,ev,subgraph,filter,function,vertex,k,vv,vertex,filter,filter,function,edge,k,ev,edge,filter,data,set,vertex,k,vv,filtered,vertices,this,vertices,filter,vertex,filter,data,set,edge,k,ev,remaining,edges,this,edges,join,filtered,vertices,where,0,equal,to,0,with,new,project,edge,k,vv,ev,join,filtered,vertices,where,1,equal,to,0,with,new,project,edge,k,vv,ev,data,set,edge,k,ev,filtered,edges,remaining,edges,filter,edge,filter,return,new,graph,k,vv,ev,filtered,vertices,filtered,edges,this,context
Graph -> public Graph<K, VV, EV> subgraph(FilterFunction<Vertex<K, VV>> vertexFilter, FilterFunction<Edge<K, EV>> edgeFilter);1446112342;Apply filtering functions to the graph and return a sub-graph that_satisfies the predicates for both vertices and edges.__@param vertexFilter the filter function for vertices._@param edgeFilter the filter function for edges._@return the resulting sub-graph.;public Graph<K, VV, EV> subgraph(FilterFunction<Vertex<K, VV>> vertexFilter, FilterFunction<Edge<K, EV>> edgeFilter) {__		DataSet<Vertex<K, VV>> filteredVertices = this.vertices.filter(vertexFilter)___		DataSet<Edge<K, EV>> remainingEdges = this.edges.join(filteredVertices)_				.where(0).equalTo(0).with(new ProjectEdge<K, VV, EV>())_				.join(filteredVertices).where(1).equalTo(0)_				.with(new ProjectEdge<K, VV, EV>())___		DataSet<Edge<K, EV>> filteredEdges = remainingEdges.filter(edgeFilter)___		return new Graph<K, VV, EV>(filteredVertices, filteredEdges,_				this.context)__	};apply,filtering,functions,to,the,graph,and,return,a,sub,graph,that,satisfies,the,predicates,for,both,vertices,and,edges,param,vertex,filter,the,filter,function,for,vertices,param,edge,filter,the,filter,function,for,edges,return,the,resulting,sub,graph;public,graph,k,vv,ev,subgraph,filter,function,vertex,k,vv,vertex,filter,filter,function,edge,k,ev,edge,filter,data,set,vertex,k,vv,filtered,vertices,this,vertices,filter,vertex,filter,data,set,edge,k,ev,remaining,edges,this,edges,join,filtered,vertices,where,0,equal,to,0,with,new,project,edge,k,vv,ev,join,filtered,vertices,where,1,equal,to,0,with,new,project,edge,k,vv,ev,data,set,edge,k,ev,filtered,edges,remaining,edges,filter,edge,filter,return,new,graph,k,vv,ev,filtered,vertices,filtered,edges,this,context
Graph -> public Graph<K, VV, EV> subgraph(FilterFunction<Vertex<K, VV>> vertexFilter, FilterFunction<Edge<K, EV>> edgeFilter);1447073368;Apply filtering functions to the graph and return a sub-graph that_satisfies the predicates for both vertices and edges.__@param vertexFilter the filter function for vertices._@param edgeFilter the filter function for edges._@return the resulting sub-graph.;public Graph<K, VV, EV> subgraph(FilterFunction<Vertex<K, VV>> vertexFilter, FilterFunction<Edge<K, EV>> edgeFilter) {__		DataSet<Vertex<K, VV>> filteredVertices = this.vertices.filter(vertexFilter)___		DataSet<Edge<K, EV>> remainingEdges = this.edges.join(filteredVertices)_				.where(0).equalTo(0).with(new ProjectEdge<K, VV, EV>())_				.join(filteredVertices).where(1).equalTo(0)_				.with(new ProjectEdge<K, VV, EV>())___		DataSet<Edge<K, EV>> filteredEdges = remainingEdges.filter(edgeFilter)___		return new Graph<K, VV, EV>(filteredVertices, filteredEdges,_				this.context)__	};apply,filtering,functions,to,the,graph,and,return,a,sub,graph,that,satisfies,the,predicates,for,both,vertices,and,edges,param,vertex,filter,the,filter,function,for,vertices,param,edge,filter,the,filter,function,for,edges,return,the,resulting,sub,graph;public,graph,k,vv,ev,subgraph,filter,function,vertex,k,vv,vertex,filter,filter,function,edge,k,ev,edge,filter,data,set,vertex,k,vv,filtered,vertices,this,vertices,filter,vertex,filter,data,set,edge,k,ev,remaining,edges,this,edges,join,filtered,vertices,where,0,equal,to,0,with,new,project,edge,k,vv,ev,join,filtered,vertices,where,1,equal,to,0,with,new,project,edge,k,vv,ev,data,set,edge,k,ev,filtered,edges,remaining,edges,filter,edge,filter,return,new,graph,k,vv,ev,filtered,vertices,filtered,edges,this,context
Graph -> public Graph<K, VV, EV> subgraph(FilterFunction<Vertex<K, VV>> vertexFilter, FilterFunction<Edge<K, EV>> edgeFilter);1454404649;Apply filtering functions to the graph and return a sub-graph that_satisfies the predicates for both vertices and edges.__@param vertexFilter the filter function for vertices._@param edgeFilter the filter function for edges._@return the resulting sub-graph.;public Graph<K, VV, EV> subgraph(FilterFunction<Vertex<K, VV>> vertexFilter, FilterFunction<Edge<K, EV>> edgeFilter) {__		DataSet<Vertex<K, VV>> filteredVertices = this.vertices.filter(vertexFilter)___		DataSet<Edge<K, EV>> remainingEdges = this.edges.join(filteredVertices)_				.where(0).equalTo(0).with(new ProjectEdge<K, VV, EV>())_				.join(filteredVertices).where(1).equalTo(0)_				.with(new ProjectEdge<K, VV, EV>())___		DataSet<Edge<K, EV>> filteredEdges = remainingEdges.filter(edgeFilter)___		return new Graph<K, VV, EV>(filteredVertices, filteredEdges,_				this.context)__	};apply,filtering,functions,to,the,graph,and,return,a,sub,graph,that,satisfies,the,predicates,for,both,vertices,and,edges,param,vertex,filter,the,filter,function,for,vertices,param,edge,filter,the,filter,function,for,edges,return,the,resulting,sub,graph;public,graph,k,vv,ev,subgraph,filter,function,vertex,k,vv,vertex,filter,filter,function,edge,k,ev,edge,filter,data,set,vertex,k,vv,filtered,vertices,this,vertices,filter,vertex,filter,data,set,edge,k,ev,remaining,edges,this,edges,join,filtered,vertices,where,0,equal,to,0,with,new,project,edge,k,vv,ev,join,filtered,vertices,where,1,equal,to,0,with,new,project,edge,k,vv,ev,data,set,edge,k,ev,filtered,edges,remaining,edges,filter,edge,filter,return,new,graph,k,vv,ev,filtered,vertices,filtered,edges,this,context
Graph -> public Graph<K, VV, EV> subgraph(FilterFunction<Vertex<K, VV>> vertexFilter, FilterFunction<Edge<K, EV>> edgeFilter);1458583829;Apply filtering functions to the graph and return a sub-graph that_satisfies the predicates for both vertices and edges.__@param vertexFilter the filter function for vertices._@param edgeFilter the filter function for edges._@return the resulting sub-graph.;public Graph<K, VV, EV> subgraph(FilterFunction<Vertex<K, VV>> vertexFilter, FilterFunction<Edge<K, EV>> edgeFilter) {__		DataSet<Vertex<K, VV>> filteredVertices = this.vertices.filter(vertexFilter)___		DataSet<Edge<K, EV>> remainingEdges = this.edges.join(filteredVertices)_				.where(0).equalTo(0).with(new ProjectEdge<K, VV, EV>())_				.join(filteredVertices).where(1).equalTo(0)_				.with(new ProjectEdge<K, VV, EV>())___		DataSet<Edge<K, EV>> filteredEdges = remainingEdges.filter(edgeFilter)___		return new Graph<K, VV, EV>(filteredVertices, filteredEdges,_				this.context)__	};apply,filtering,functions,to,the,graph,and,return,a,sub,graph,that,satisfies,the,predicates,for,both,vertices,and,edges,param,vertex,filter,the,filter,function,for,vertices,param,edge,filter,the,filter,function,for,edges,return,the,resulting,sub,graph;public,graph,k,vv,ev,subgraph,filter,function,vertex,k,vv,vertex,filter,filter,function,edge,k,ev,edge,filter,data,set,vertex,k,vv,filtered,vertices,this,vertices,filter,vertex,filter,data,set,edge,k,ev,remaining,edges,this,edges,join,filtered,vertices,where,0,equal,to,0,with,new,project,edge,k,vv,ev,join,filtered,vertices,where,1,equal,to,0,with,new,project,edge,k,vv,ev,data,set,edge,k,ev,filtered,edges,remaining,edges,filter,edge,filter,return,new,graph,k,vv,ev,filtered,vertices,filtered,edges,this,context
Graph -> public Graph<K, VV, EV> subgraph(FilterFunction<Vertex<K, VV>> vertexFilter, FilterFunction<Edge<K, EV>> edgeFilter);1458583829;Apply filtering functions to the graph and return a sub-graph that_satisfies the predicates for both vertices and edges.__@param vertexFilter the filter function for vertices._@param edgeFilter the filter function for edges._@return the resulting sub-graph.;public Graph<K, VV, EV> subgraph(FilterFunction<Vertex<K, VV>> vertexFilter, FilterFunction<Edge<K, EV>> edgeFilter) {__		DataSet<Vertex<K, VV>> filteredVertices = this.vertices.filter(vertexFilter)___		DataSet<Edge<K, EV>> remainingEdges = this.edges.join(filteredVertices)_				.where(0).equalTo(0).with(new ProjectEdge<K, VV, EV>())_				.join(filteredVertices).where(1).equalTo(0)_				.with(new ProjectEdge<K, VV, EV>())___		DataSet<Edge<K, EV>> filteredEdges = remainingEdges.filter(edgeFilter)___		return new Graph<K, VV, EV>(filteredVertices, filteredEdges,_				this.context)__	};apply,filtering,functions,to,the,graph,and,return,a,sub,graph,that,satisfies,the,predicates,for,both,vertices,and,edges,param,vertex,filter,the,filter,function,for,vertices,param,edge,filter,the,filter,function,for,edges,return,the,resulting,sub,graph;public,graph,k,vv,ev,subgraph,filter,function,vertex,k,vv,vertex,filter,filter,function,edge,k,ev,edge,filter,data,set,vertex,k,vv,filtered,vertices,this,vertices,filter,vertex,filter,data,set,edge,k,ev,remaining,edges,this,edges,join,filtered,vertices,where,0,equal,to,0,with,new,project,edge,k,vv,ev,join,filtered,vertices,where,1,equal,to,0,with,new,project,edge,k,vv,ev,data,set,edge,k,ev,filtered,edges,remaining,edges,filter,edge,filter,return,new,graph,k,vv,ev,filtered,vertices,filtered,edges,this,context
Graph -> public Graph<K, VV, EV> subgraph(FilterFunction<Vertex<K, VV>> vertexFilter, FilterFunction<Edge<K, EV>> edgeFilter);1462100316;Apply filtering functions to the graph and return a sub-graph that_satisfies the predicates for both vertices and edges.__@param vertexFilter the filter function for vertices._@param edgeFilter the filter function for edges._@return the resulting sub-graph.;public Graph<K, VV, EV> subgraph(FilterFunction<Vertex<K, VV>> vertexFilter, FilterFunction<Edge<K, EV>> edgeFilter) {__		DataSet<Vertex<K, VV>> filteredVertices = this.vertices.filter(vertexFilter)___		DataSet<Edge<K, EV>> remainingEdges = this.edges.join(filteredVertices)_				.where(0).equalTo(0).with(new ProjectEdge<K, VV, EV>())_				.join(filteredVertices).where(1).equalTo(0)_				.with(new ProjectEdge<K, VV, EV>())___		DataSet<Edge<K, EV>> filteredEdges = remainingEdges.filter(edgeFilter)___		return new Graph<K, VV, EV>(filteredVertices, filteredEdges,_				this.context)__	};apply,filtering,functions,to,the,graph,and,return,a,sub,graph,that,satisfies,the,predicates,for,both,vertices,and,edges,param,vertex,filter,the,filter,function,for,vertices,param,edge,filter,the,filter,function,for,edges,return,the,resulting,sub,graph;public,graph,k,vv,ev,subgraph,filter,function,vertex,k,vv,vertex,filter,filter,function,edge,k,ev,edge,filter,data,set,vertex,k,vv,filtered,vertices,this,vertices,filter,vertex,filter,data,set,edge,k,ev,remaining,edges,this,edges,join,filtered,vertices,where,0,equal,to,0,with,new,project,edge,k,vv,ev,join,filtered,vertices,where,1,equal,to,0,with,new,project,edge,k,vv,ev,data,set,edge,k,ev,filtered,edges,remaining,edges,filter,edge,filter,return,new,graph,k,vv,ev,filtered,vertices,filtered,edges,this,context
Graph -> public Graph<K, VV, EV> subgraph(FilterFunction<Vertex<K, VV>> vertexFilter, FilterFunction<Edge<K, EV>> edgeFilter);1462100316;Apply filtering functions to the graph and return a sub-graph that_satisfies the predicates for both vertices and edges.__@param vertexFilter the filter function for vertices._@param edgeFilter the filter function for edges._@return the resulting sub-graph.;public Graph<K, VV, EV> subgraph(FilterFunction<Vertex<K, VV>> vertexFilter, FilterFunction<Edge<K, EV>> edgeFilter) {__		DataSet<Vertex<K, VV>> filteredVertices = this.vertices.filter(vertexFilter)___		DataSet<Edge<K, EV>> remainingEdges = this.edges.join(filteredVertices)_				.where(0).equalTo(0).with(new ProjectEdge<K, VV, EV>())_				.join(filteredVertices).where(1).equalTo(0)_				.with(new ProjectEdge<K, VV, EV>())___		DataSet<Edge<K, EV>> filteredEdges = remainingEdges.filter(edgeFilter)___		return new Graph<K, VV, EV>(filteredVertices, filteredEdges,_				this.context)__	};apply,filtering,functions,to,the,graph,and,return,a,sub,graph,that,satisfies,the,predicates,for,both,vertices,and,edges,param,vertex,filter,the,filter,function,for,vertices,param,edge,filter,the,filter,function,for,edges,return,the,resulting,sub,graph;public,graph,k,vv,ev,subgraph,filter,function,vertex,k,vv,vertex,filter,filter,function,edge,k,ev,edge,filter,data,set,vertex,k,vv,filtered,vertices,this,vertices,filter,vertex,filter,data,set,edge,k,ev,remaining,edges,this,edges,join,filtered,vertices,where,0,equal,to,0,with,new,project,edge,k,vv,ev,join,filtered,vertices,where,1,equal,to,0,with,new,project,edge,k,vv,ev,data,set,edge,k,ev,filtered,edges,remaining,edges,filter,edge,filter,return,new,graph,k,vv,ev,filtered,vertices,filtered,edges,this,context
Graph -> public Graph<K, VV, EV> subgraph(FilterFunction<Vertex<K, VV>> vertexFilter, FilterFunction<Edge<K, EV>> edgeFilter);1462205213;Apply filtering functions to the graph and return a sub-graph that_satisfies the predicates for both vertices and edges.__@param vertexFilter the filter function for vertices._@param edgeFilter the filter function for edges._@return the resulting sub-graph.;public Graph<K, VV, EV> subgraph(FilterFunction<Vertex<K, VV>> vertexFilter, FilterFunction<Edge<K, EV>> edgeFilter) {__		DataSet<Vertex<K, VV>> filteredVertices = this.vertices.filter(vertexFilter)___		DataSet<Edge<K, EV>> remainingEdges = this.edges.join(filteredVertices)_				.where(0).equalTo(0).with(new ProjectEdge<K, VV, EV>())_				.join(filteredVertices).where(1).equalTo(0)_				.with(new ProjectEdge<K, VV, EV>())___		DataSet<Edge<K, EV>> filteredEdges = remainingEdges.filter(edgeFilter)___		return new Graph<K, VV, EV>(filteredVertices, filteredEdges,_				this.context)__	};apply,filtering,functions,to,the,graph,and,return,a,sub,graph,that,satisfies,the,predicates,for,both,vertices,and,edges,param,vertex,filter,the,filter,function,for,vertices,param,edge,filter,the,filter,function,for,edges,return,the,resulting,sub,graph;public,graph,k,vv,ev,subgraph,filter,function,vertex,k,vv,vertex,filter,filter,function,edge,k,ev,edge,filter,data,set,vertex,k,vv,filtered,vertices,this,vertices,filter,vertex,filter,data,set,edge,k,ev,remaining,edges,this,edges,join,filtered,vertices,where,0,equal,to,0,with,new,project,edge,k,vv,ev,join,filtered,vertices,where,1,equal,to,0,with,new,project,edge,k,vv,ev,data,set,edge,k,ev,filtered,edges,remaining,edges,filter,edge,filter,return,new,graph,k,vv,ev,filtered,vertices,filtered,edges,this,context
Graph -> public Graph<K, VV, EV> subgraph(FilterFunction<Vertex<K, VV>> vertexFilter, FilterFunction<Edge<K, EV>> edgeFilter);1462208859;Apply filtering functions to the graph and return a sub-graph that_satisfies the predicates for both vertices and edges.__@param vertexFilter the filter function for vertices._@param edgeFilter the filter function for edges._@return the resulting sub-graph.;public Graph<K, VV, EV> subgraph(FilterFunction<Vertex<K, VV>> vertexFilter, FilterFunction<Edge<K, EV>> edgeFilter) {__		DataSet<Vertex<K, VV>> filteredVertices = this.vertices.filter(vertexFilter)___		DataSet<Edge<K, EV>> remainingEdges = this.edges.join(filteredVertices)_				.where(0).equalTo(0).with(new ProjectEdge<K, VV, EV>())_				.join(filteredVertices).where(1).equalTo(0)_				.with(new ProjectEdge<K, VV, EV>())___		DataSet<Edge<K, EV>> filteredEdges = remainingEdges.filter(edgeFilter)___		return new Graph<K, VV, EV>(filteredVertices, filteredEdges,_				this.context)__	};apply,filtering,functions,to,the,graph,and,return,a,sub,graph,that,satisfies,the,predicates,for,both,vertices,and,edges,param,vertex,filter,the,filter,function,for,vertices,param,edge,filter,the,filter,function,for,edges,return,the,resulting,sub,graph;public,graph,k,vv,ev,subgraph,filter,function,vertex,k,vv,vertex,filter,filter,function,edge,k,ev,edge,filter,data,set,vertex,k,vv,filtered,vertices,this,vertices,filter,vertex,filter,data,set,edge,k,ev,remaining,edges,this,edges,join,filtered,vertices,where,0,equal,to,0,with,new,project,edge,k,vv,ev,join,filtered,vertices,where,1,equal,to,0,with,new,project,edge,k,vv,ev,data,set,edge,k,ev,filtered,edges,remaining,edges,filter,edge,filter,return,new,graph,k,vv,ev,filtered,vertices,filtered,edges,this,context
Graph -> public Graph<K, VV, EV> subgraph(FilterFunction<Vertex<K, VV>> vertexFilter, FilterFunction<Edge<K, EV>> edgeFilter);1462809297;Apply filtering functions to the graph and return a sub-graph that_satisfies the predicates for both vertices and edges.__@param vertexFilter the filter function for vertices._@param edgeFilter the filter function for edges._@return the resulting sub-graph.;public Graph<K, VV, EV> subgraph(FilterFunction<Vertex<K, VV>> vertexFilter, FilterFunction<Edge<K, EV>> edgeFilter) {__		DataSet<Vertex<K, VV>> filteredVertices = this.vertices.filter(vertexFilter)___		DataSet<Edge<K, EV>> remainingEdges = this.edges.join(filteredVertices)_				.where(0).equalTo(0).with(new ProjectEdge<K, VV, EV>())_				.join(filteredVertices).where(1).equalTo(0)_				.with(new ProjectEdge<K, VV, EV>())___		DataSet<Edge<K, EV>> filteredEdges = remainingEdges.filter(edgeFilter)___		return new Graph<K, VV, EV>(filteredVertices, filteredEdges,_				this.context)__	};apply,filtering,functions,to,the,graph,and,return,a,sub,graph,that,satisfies,the,predicates,for,both,vertices,and,edges,param,vertex,filter,the,filter,function,for,vertices,param,edge,filter,the,filter,function,for,edges,return,the,resulting,sub,graph;public,graph,k,vv,ev,subgraph,filter,function,vertex,k,vv,vertex,filter,filter,function,edge,k,ev,edge,filter,data,set,vertex,k,vv,filtered,vertices,this,vertices,filter,vertex,filter,data,set,edge,k,ev,remaining,edges,this,edges,join,filtered,vertices,where,0,equal,to,0,with,new,project,edge,k,vv,ev,join,filtered,vertices,where,1,equal,to,0,with,new,project,edge,k,vv,ev,data,set,edge,k,ev,filtered,edges,remaining,edges,filter,edge,filter,return,new,graph,k,vv,ev,filtered,vertices,filtered,edges,this,context
Graph -> public Graph<K, VV, EV> subgraph(FilterFunction<Vertex<K, VV>> vertexFilter, FilterFunction<Edge<K, EV>> edgeFilter);1465316775;Apply filtering functions to the graph and return a sub-graph that_satisfies the predicates for both vertices and edges.__@param vertexFilter the filter function for vertices._@param edgeFilter the filter function for edges._@return the resulting sub-graph.;public Graph<K, VV, EV> subgraph(FilterFunction<Vertex<K, VV>> vertexFilter, FilterFunction<Edge<K, EV>> edgeFilter) {__		DataSet<Vertex<K, VV>> filteredVertices = this.vertices.filter(vertexFilter)___		DataSet<Edge<K, EV>> remainingEdges = this.edges.join(filteredVertices)_				.where(0).equalTo(0).with(new ProjectEdge<K, VV, EV>())_				.join(filteredVertices).where(1).equalTo(0)_				.with(new ProjectEdge<K, VV, EV>())___		DataSet<Edge<K, EV>> filteredEdges = remainingEdges.filter(edgeFilter)___		return new Graph<K, VV, EV>(filteredVertices, filteredEdges,_				this.context)__	};apply,filtering,functions,to,the,graph,and,return,a,sub,graph,that,satisfies,the,predicates,for,both,vertices,and,edges,param,vertex,filter,the,filter,function,for,vertices,param,edge,filter,the,filter,function,for,edges,return,the,resulting,sub,graph;public,graph,k,vv,ev,subgraph,filter,function,vertex,k,vv,vertex,filter,filter,function,edge,k,ev,edge,filter,data,set,vertex,k,vv,filtered,vertices,this,vertices,filter,vertex,filter,data,set,edge,k,ev,remaining,edges,this,edges,join,filtered,vertices,where,0,equal,to,0,with,new,project,edge,k,vv,ev,join,filtered,vertices,where,1,equal,to,0,with,new,project,edge,k,vv,ev,data,set,edge,k,ev,filtered,edges,remaining,edges,filter,edge,filter,return,new,graph,k,vv,ev,filtered,vertices,filtered,edges,this,context
Graph -> public Graph<K, VV, EV> subgraph(FilterFunction<Vertex<K, VV>> vertexFilter, FilterFunction<Edge<K, EV>> edgeFilter);1466789678;Apply filtering functions to the graph and return a sub-graph that_satisfies the predicates for both vertices and edges.__@param vertexFilter the filter function for vertices._@param edgeFilter the filter function for edges._@return the resulting sub-graph.;public Graph<K, VV, EV> subgraph(FilterFunction<Vertex<K, VV>> vertexFilter, FilterFunction<Edge<K, EV>> edgeFilter) {__		DataSet<Vertex<K, VV>> filteredVertices = this.vertices.filter(vertexFilter)___		DataSet<Edge<K, EV>> remainingEdges = this.edges.join(filteredVertices)_				.where(0).equalTo(0).with(new ProjectEdge<K, VV, EV>())_				.join(filteredVertices).where(1).equalTo(0)_				.with(new ProjectEdge<K, VV, EV>())___		DataSet<Edge<K, EV>> filteredEdges = remainingEdges.filter(edgeFilter)___		return new Graph<K, VV, EV>(filteredVertices, filteredEdges,_				this.context)__	};apply,filtering,functions,to,the,graph,and,return,a,sub,graph,that,satisfies,the,predicates,for,both,vertices,and,edges,param,vertex,filter,the,filter,function,for,vertices,param,edge,filter,the,filter,function,for,edges,return,the,resulting,sub,graph;public,graph,k,vv,ev,subgraph,filter,function,vertex,k,vv,vertex,filter,filter,function,edge,k,ev,edge,filter,data,set,vertex,k,vv,filtered,vertices,this,vertices,filter,vertex,filter,data,set,edge,k,ev,remaining,edges,this,edges,join,filtered,vertices,where,0,equal,to,0,with,new,project,edge,k,vv,ev,join,filtered,vertices,where,1,equal,to,0,with,new,project,edge,k,vv,ev,data,set,edge,k,ev,filtered,edges,remaining,edges,filter,edge,filter,return,new,graph,k,vv,ev,filtered,vertices,filtered,edges,this,context
Graph -> public Graph<K, VV, EV> subgraph(FilterFunction<Vertex<K, VV>> vertexFilter, FilterFunction<Edge<K, EV>> edgeFilter);1467140656;Apply filtering functions to the graph and return a sub-graph that_satisfies the predicates for both vertices and edges.__@param vertexFilter the filter function for vertices._@param edgeFilter the filter function for edges._@return the resulting sub-graph.;public Graph<K, VV, EV> subgraph(FilterFunction<Vertex<K, VV>> vertexFilter, FilterFunction<Edge<K, EV>> edgeFilter) {__		DataSet<Vertex<K, VV>> filteredVertices = this.vertices.filter(vertexFilter)___		DataSet<Edge<K, EV>> remainingEdges = this.edges.join(filteredVertices)_				.where(0).equalTo(0).with(new ProjectEdge<K, VV, EV>())_				.join(filteredVertices).where(1).equalTo(0)_				.with(new ProjectEdge<K, VV, EV>())___		DataSet<Edge<K, EV>> filteredEdges = remainingEdges.filter(edgeFilter)___		return new Graph<K, VV, EV>(filteredVertices, filteredEdges,_				this.context)__	};apply,filtering,functions,to,the,graph,and,return,a,sub,graph,that,satisfies,the,predicates,for,both,vertices,and,edges,param,vertex,filter,the,filter,function,for,vertices,param,edge,filter,the,filter,function,for,edges,return,the,resulting,sub,graph;public,graph,k,vv,ev,subgraph,filter,function,vertex,k,vv,vertex,filter,filter,function,edge,k,ev,edge,filter,data,set,vertex,k,vv,filtered,vertices,this,vertices,filter,vertex,filter,data,set,edge,k,ev,remaining,edges,this,edges,join,filtered,vertices,where,0,equal,to,0,with,new,project,edge,k,vv,ev,join,filtered,vertices,where,1,equal,to,0,with,new,project,edge,k,vv,ev,data,set,edge,k,ev,filtered,edges,remaining,edges,filter,edge,filter,return,new,graph,k,vv,ev,filtered,vertices,filtered,edges,this,context
Graph -> public Graph<K, VV, EV> subgraph(FilterFunction<Vertex<K, VV>> vertexFilter, FilterFunction<Edge<K, EV>> edgeFilter);1467306272;Apply filtering functions to the graph and return a sub-graph that_satisfies the predicates for both vertices and edges.__@param vertexFilter the filter function for vertices._@param edgeFilter the filter function for edges._@return the resulting sub-graph.;public Graph<K, VV, EV> subgraph(FilterFunction<Vertex<K, VV>> vertexFilter, FilterFunction<Edge<K, EV>> edgeFilter) {__		DataSet<Vertex<K, VV>> filteredVertices = this.vertices.filter(vertexFilter)___		DataSet<Edge<K, EV>> remainingEdges = this.edges.join(filteredVertices)_				.where(0).equalTo(0).with(new ProjectEdge<K, VV, EV>())_				.join(filteredVertices).where(1).equalTo(0)_				.with(new ProjectEdge<K, VV, EV>())___		DataSet<Edge<K, EV>> filteredEdges = remainingEdges.filter(edgeFilter)___		return new Graph<K, VV, EV>(filteredVertices, filteredEdges,_				this.context)__	};apply,filtering,functions,to,the,graph,and,return,a,sub,graph,that,satisfies,the,predicates,for,both,vertices,and,edges,param,vertex,filter,the,filter,function,for,vertices,param,edge,filter,the,filter,function,for,edges,return,the,resulting,sub,graph;public,graph,k,vv,ev,subgraph,filter,function,vertex,k,vv,vertex,filter,filter,function,edge,k,ev,edge,filter,data,set,vertex,k,vv,filtered,vertices,this,vertices,filter,vertex,filter,data,set,edge,k,ev,remaining,edges,this,edges,join,filtered,vertices,where,0,equal,to,0,with,new,project,edge,k,vv,ev,join,filtered,vertices,where,1,equal,to,0,with,new,project,edge,k,vv,ev,data,set,edge,k,ev,filtered,edges,remaining,edges,filter,edge,filter,return,new,graph,k,vv,ev,filtered,vertices,filtered,edges,this,context
Graph -> public Graph<K, VV, EV> subgraph(FilterFunction<Vertex<K, VV>> vertexFilter, FilterFunction<Edge<K, EV>> edgeFilter);1470042815;Apply filtering functions to the graph and return a sub-graph that_satisfies the predicates for both vertices and edges.__@param vertexFilter the filter function for vertices._@param edgeFilter the filter function for edges._@return the resulting sub-graph.;public Graph<K, VV, EV> subgraph(FilterFunction<Vertex<K, VV>> vertexFilter, FilterFunction<Edge<K, EV>> edgeFilter) {__		DataSet<Vertex<K, VV>> filteredVertices = this.vertices.filter(vertexFilter)___		DataSet<Edge<K, EV>> remainingEdges = this.edges.join(filteredVertices)_				.where(0).equalTo(0).with(new ProjectEdge<K, VV, EV>())_				.join(filteredVertices).where(1).equalTo(0)_				.with(new ProjectEdge<K, VV, EV>())___		DataSet<Edge<K, EV>> filteredEdges = remainingEdges.filter(edgeFilter)___		return new Graph<K, VV, EV>(filteredVertices, filteredEdges,_				this.context)__	};apply,filtering,functions,to,the,graph,and,return,a,sub,graph,that,satisfies,the,predicates,for,both,vertices,and,edges,param,vertex,filter,the,filter,function,for,vertices,param,edge,filter,the,filter,function,for,edges,return,the,resulting,sub,graph;public,graph,k,vv,ev,subgraph,filter,function,vertex,k,vv,vertex,filter,filter,function,edge,k,ev,edge,filter,data,set,vertex,k,vv,filtered,vertices,this,vertices,filter,vertex,filter,data,set,edge,k,ev,remaining,edges,this,edges,join,filtered,vertices,where,0,equal,to,0,with,new,project,edge,k,vv,ev,join,filtered,vertices,where,1,equal,to,0,with,new,project,edge,k,vv,ev,data,set,edge,k,ev,filtered,edges,remaining,edges,filter,edge,filter,return,new,graph,k,vv,ev,filtered,vertices,filtered,edges,this,context
Graph -> public Graph<K, VV, EV> subgraph(FilterFunction<Vertex<K, VV>> vertexFilter, FilterFunction<Edge<K, EV>> edgeFilter);1475684776;Apply filtering functions to the graph and return a sub-graph that_satisfies the predicates for both vertices and edges.__@param vertexFilter the filter function for vertices._@param edgeFilter the filter function for edges._@return the resulting sub-graph.;public Graph<K, VV, EV> subgraph(FilterFunction<Vertex<K, VV>> vertexFilter, FilterFunction<Edge<K, EV>> edgeFilter) {__		DataSet<Vertex<K, VV>> filteredVertices = this.vertices.filter(vertexFilter)___		DataSet<Edge<K, EV>> remainingEdges = this.edges.join(filteredVertices)_				.where(0).equalTo(0).with(new ProjectEdge<K, VV, EV>())_				.join(filteredVertices).where(1).equalTo(0)_				.with(new ProjectEdge<K, VV, EV>())___		DataSet<Edge<K, EV>> filteredEdges = remainingEdges.filter(edgeFilter)___		return new Graph<>(filteredVertices, filteredEdges, this.context)__	};apply,filtering,functions,to,the,graph,and,return,a,sub,graph,that,satisfies,the,predicates,for,both,vertices,and,edges,param,vertex,filter,the,filter,function,for,vertices,param,edge,filter,the,filter,function,for,edges,return,the,resulting,sub,graph;public,graph,k,vv,ev,subgraph,filter,function,vertex,k,vv,vertex,filter,filter,function,edge,k,ev,edge,filter,data,set,vertex,k,vv,filtered,vertices,this,vertices,filter,vertex,filter,data,set,edge,k,ev,remaining,edges,this,edges,join,filtered,vertices,where,0,equal,to,0,with,new,project,edge,k,vv,ev,join,filtered,vertices,where,1,equal,to,0,with,new,project,edge,k,vv,ev,data,set,edge,k,ev,filtered,edges,remaining,edges,filter,edge,filter,return,new,graph,filtered,vertices,filtered,edges,this,context
Graph -> public Graph<K, VV, EV> subgraph(FilterFunction<Vertex<K, VV>> vertexFilter, FilterFunction<Edge<K, EV>> edgeFilter);1475685606;Apply filtering functions to the graph and return a sub-graph that_satisfies the predicates for both vertices and edges.__@param vertexFilter the filter function for vertices._@param edgeFilter the filter function for edges._@return the resulting sub-graph.;public Graph<K, VV, EV> subgraph(FilterFunction<Vertex<K, VV>> vertexFilter, FilterFunction<Edge<K, EV>> edgeFilter) {__		DataSet<Vertex<K, VV>> filteredVertices = this.vertices.filter(vertexFilter)___		DataSet<Edge<K, EV>> remainingEdges = this.edges.join(filteredVertices)_				.where(0).equalTo(0).with(new ProjectEdge<K, VV, EV>())_				.join(filteredVertices).where(1).equalTo(0)_				.with(new ProjectEdge<K, VV, EV>())___		DataSet<Edge<K, EV>> filteredEdges = remainingEdges.filter(edgeFilter)___		return new Graph<>(filteredVertices, filteredEdges, this.context)__	};apply,filtering,functions,to,the,graph,and,return,a,sub,graph,that,satisfies,the,predicates,for,both,vertices,and,edges,param,vertex,filter,the,filter,function,for,vertices,param,edge,filter,the,filter,function,for,edges,return,the,resulting,sub,graph;public,graph,k,vv,ev,subgraph,filter,function,vertex,k,vv,vertex,filter,filter,function,edge,k,ev,edge,filter,data,set,vertex,k,vv,filtered,vertices,this,vertices,filter,vertex,filter,data,set,edge,k,ev,remaining,edges,this,edges,join,filtered,vertices,where,0,equal,to,0,with,new,project,edge,k,vv,ev,join,filtered,vertices,where,1,equal,to,0,with,new,project,edge,k,vv,ev,data,set,edge,k,ev,filtered,edges,remaining,edges,filter,edge,filter,return,new,graph,filtered,vertices,filtered,edges,this,context
Graph -> public Graph<K, VV, EV> subgraph(FilterFunction<Vertex<K, VV>> vertexFilter, FilterFunction<Edge<K, EV>> edgeFilter);1481745825;Apply filtering functions to the graph and return a sub-graph that_satisfies the predicates for both vertices and edges.__@param vertexFilter the filter function for vertices._@param edgeFilter the filter function for edges._@return the resulting sub-graph.;public Graph<K, VV, EV> subgraph(FilterFunction<Vertex<K, VV>> vertexFilter, FilterFunction<Edge<K, EV>> edgeFilter) {__		DataSet<Vertex<K, VV>> filteredVertices = this.vertices.filter(vertexFilter)___		DataSet<Edge<K, EV>> remainingEdges = this.edges.join(filteredVertices)_				.where(0).equalTo(0).with(new ProjectEdge<K, VV, EV>())_				.join(filteredVertices).where(1).equalTo(0)_				.with(new ProjectEdge<K, VV, EV>()).name("Subgraph")___		DataSet<Edge<K, EV>> filteredEdges = remainingEdges.filter(edgeFilter)___		return new Graph<>(filteredVertices, filteredEdges, this.context)__	};apply,filtering,functions,to,the,graph,and,return,a,sub,graph,that,satisfies,the,predicates,for,both,vertices,and,edges,param,vertex,filter,the,filter,function,for,vertices,param,edge,filter,the,filter,function,for,edges,return,the,resulting,sub,graph;public,graph,k,vv,ev,subgraph,filter,function,vertex,k,vv,vertex,filter,filter,function,edge,k,ev,edge,filter,data,set,vertex,k,vv,filtered,vertices,this,vertices,filter,vertex,filter,data,set,edge,k,ev,remaining,edges,this,edges,join,filtered,vertices,where,0,equal,to,0,with,new,project,edge,k,vv,ev,join,filtered,vertices,where,1,equal,to,0,with,new,project,edge,k,vv,ev,name,subgraph,data,set,edge,k,ev,filtered,edges,remaining,edges,filter,edge,filter,return,new,graph,filtered,vertices,filtered,edges,this,context
Graph -> public Graph<K, VV, EV> subgraph(FilterFunction<Vertex<K, VV>> vertexFilter, FilterFunction<Edge<K, EV>> edgeFilter);1481881009;Apply filtering functions to the graph and return a sub-graph that_satisfies the predicates for both vertices and edges.__@param vertexFilter the filter function for vertices._@param edgeFilter the filter function for edges._@return the resulting sub-graph.;public Graph<K, VV, EV> subgraph(FilterFunction<Vertex<K, VV>> vertexFilter, FilterFunction<Edge<K, EV>> edgeFilter) {__		DataSet<Vertex<K, VV>> filteredVertices = this.vertices.filter(vertexFilter)___		DataSet<Edge<K, EV>> remainingEdges = this.edges.join(filteredVertices)_				.where(0).equalTo(0).with(new ProjectEdge<K, VV, EV>())_				.join(filteredVertices).where(1).equalTo(0)_				.with(new ProjectEdge<K, VV, EV>()).name("Subgraph")___		DataSet<Edge<K, EV>> filteredEdges = remainingEdges.filter(edgeFilter)___		return new Graph<>(filteredVertices, filteredEdges, this.context)__	};apply,filtering,functions,to,the,graph,and,return,a,sub,graph,that,satisfies,the,predicates,for,both,vertices,and,edges,param,vertex,filter,the,filter,function,for,vertices,param,edge,filter,the,filter,function,for,edges,return,the,resulting,sub,graph;public,graph,k,vv,ev,subgraph,filter,function,vertex,k,vv,vertex,filter,filter,function,edge,k,ev,edge,filter,data,set,vertex,k,vv,filtered,vertices,this,vertices,filter,vertex,filter,data,set,edge,k,ev,remaining,edges,this,edges,join,filtered,vertices,where,0,equal,to,0,with,new,project,edge,k,vv,ev,join,filtered,vertices,where,1,equal,to,0,with,new,project,edge,k,vv,ev,name,subgraph,data,set,edge,k,ev,filtered,edges,remaining,edges,filter,edge,filter,return,new,graph,filtered,vertices,filtered,edges,this,context
Graph -> public Graph<K, VV, EV> subgraph(FilterFunction<Vertex<K, VV>> vertexFilter, FilterFunction<Edge<K, EV>> edgeFilter);1484160227;Apply filtering functions to the graph and return a sub-graph that_satisfies the predicates for both vertices and edges.__@param vertexFilter the filter function for vertices._@param edgeFilter the filter function for edges._@return the resulting sub-graph.;public Graph<K, VV, EV> subgraph(FilterFunction<Vertex<K, VV>> vertexFilter, FilterFunction<Edge<K, EV>> edgeFilter) {__		DataSet<Vertex<K, VV>> filteredVertices = this.vertices.filter(vertexFilter)___		DataSet<Edge<K, EV>> remainingEdges = this.edges.join(filteredVertices)_				.where(0).equalTo(0).with(new ProjectEdge<K, VV, EV>())_				.join(filteredVertices).where(1).equalTo(0)_				.with(new ProjectEdge<K, VV, EV>()).name("Subgraph")___		DataSet<Edge<K, EV>> filteredEdges = remainingEdges.filter(edgeFilter)___		return new Graph<>(filteredVertices, filteredEdges, this.context)__	};apply,filtering,functions,to,the,graph,and,return,a,sub,graph,that,satisfies,the,predicates,for,both,vertices,and,edges,param,vertex,filter,the,filter,function,for,vertices,param,edge,filter,the,filter,function,for,edges,return,the,resulting,sub,graph;public,graph,k,vv,ev,subgraph,filter,function,vertex,k,vv,vertex,filter,filter,function,edge,k,ev,edge,filter,data,set,vertex,k,vv,filtered,vertices,this,vertices,filter,vertex,filter,data,set,edge,k,ev,remaining,edges,this,edges,join,filtered,vertices,where,0,equal,to,0,with,new,project,edge,k,vv,ev,join,filtered,vertices,where,1,equal,to,0,with,new,project,edge,k,vv,ev,name,subgraph,data,set,edge,k,ev,filtered,edges,remaining,edges,filter,edge,filter,return,new,graph,filtered,vertices,filtered,edges,this,context
Graph -> public Graph<K, VV, EV> subgraph(FilterFunction<Vertex<K, VV>> vertexFilter, FilterFunction<Edge<K, EV>> edgeFilter);1484685504;Apply filtering functions to the graph and return a sub-graph that_satisfies the predicates for both vertices and edges.__@param vertexFilter the filter function for vertices._@param edgeFilter the filter function for edges._@return the resulting sub-graph.;public Graph<K, VV, EV> subgraph(FilterFunction<Vertex<K, VV>> vertexFilter, FilterFunction<Edge<K, EV>> edgeFilter) {__		DataSet<Vertex<K, VV>> filteredVertices = this.vertices.filter(vertexFilter)___		DataSet<Edge<K, EV>> remainingEdges = this.edges.join(filteredVertices)_				.where(0).equalTo(0).with(new ProjectEdge<K, VV, EV>())_				.join(filteredVertices).where(1).equalTo(0)_				.with(new ProjectEdge<K, VV, EV>()).name("Subgraph")___		DataSet<Edge<K, EV>> filteredEdges = remainingEdges.filter(edgeFilter)___		return new Graph<>(filteredVertices, filteredEdges, this.context)__	};apply,filtering,functions,to,the,graph,and,return,a,sub,graph,that,satisfies,the,predicates,for,both,vertices,and,edges,param,vertex,filter,the,filter,function,for,vertices,param,edge,filter,the,filter,function,for,edges,return,the,resulting,sub,graph;public,graph,k,vv,ev,subgraph,filter,function,vertex,k,vv,vertex,filter,filter,function,edge,k,ev,edge,filter,data,set,vertex,k,vv,filtered,vertices,this,vertices,filter,vertex,filter,data,set,edge,k,ev,remaining,edges,this,edges,join,filtered,vertices,where,0,equal,to,0,with,new,project,edge,k,vv,ev,join,filtered,vertices,where,1,equal,to,0,with,new,project,edge,k,vv,ev,name,subgraph,data,set,edge,k,ev,filtered,edges,remaining,edges,filter,edge,filter,return,new,graph,filtered,vertices,filtered,edges,this,context
Graph -> public Graph<K, VV, EV> subgraph(FilterFunction<Vertex<K, VV>> vertexFilter, FilterFunction<Edge<K, EV>> edgeFilter);1489068942;Apply filtering functions to the graph and return a sub-graph that_satisfies the predicates for both vertices and edges.__@param vertexFilter the filter function for vertices._@param edgeFilter the filter function for edges._@return the resulting sub-graph.;public Graph<K, VV, EV> subgraph(FilterFunction<Vertex<K, VV>> vertexFilter, FilterFunction<Edge<K, EV>> edgeFilter) {__		DataSet<Vertex<K, VV>> filteredVertices = this.vertices.filter(vertexFilter)___		DataSet<Edge<K, EV>> remainingEdges = this.edges.join(filteredVertices)_				.where(0).equalTo(0).with(new ProjectEdge<K, VV, EV>())_				.join(filteredVertices).where(1).equalTo(0)_				.with(new ProjectEdge<K, VV, EV>()).name("Subgraph")___		DataSet<Edge<K, EV>> filteredEdges = remainingEdges.filter(edgeFilter)___		return new Graph<>(filteredVertices, filteredEdges, this.context)__	};apply,filtering,functions,to,the,graph,and,return,a,sub,graph,that,satisfies,the,predicates,for,both,vertices,and,edges,param,vertex,filter,the,filter,function,for,vertices,param,edge,filter,the,filter,function,for,edges,return,the,resulting,sub,graph;public,graph,k,vv,ev,subgraph,filter,function,vertex,k,vv,vertex,filter,filter,function,edge,k,ev,edge,filter,data,set,vertex,k,vv,filtered,vertices,this,vertices,filter,vertex,filter,data,set,edge,k,ev,remaining,edges,this,edges,join,filtered,vertices,where,0,equal,to,0,with,new,project,edge,k,vv,ev,join,filtered,vertices,where,1,equal,to,0,with,new,project,edge,k,vv,ev,name,subgraph,data,set,edge,k,ev,filtered,edges,remaining,edges,filter,edge,filter,return,new,graph,filtered,vertices,filtered,edges,this,context
Graph -> public Graph<K, VV, EV> subgraph(FilterFunction<Vertex<K, VV>> vertexFilter, FilterFunction<Edge<K, EV>> edgeFilter);1490973446;Apply filtering functions to the graph and return a sub-graph that_satisfies the predicates for both vertices and edges.__@param vertexFilter the filter function for vertices._@param edgeFilter the filter function for edges._@return the resulting sub-graph.;public Graph<K, VV, EV> subgraph(FilterFunction<Vertex<K, VV>> vertexFilter, FilterFunction<Edge<K, EV>> edgeFilter) {__		DataSet<Vertex<K, VV>> filteredVertices = this.vertices.filter(vertexFilter)___		DataSet<Edge<K, EV>> remainingEdges = this.edges.join(filteredVertices)_				.where(0).equalTo(0).with(new ProjectEdge<K, VV, EV>())_				.join(filteredVertices).where(1).equalTo(0)_				.with(new ProjectEdge<K, VV, EV>()).name("Subgraph")___		DataSet<Edge<K, EV>> filteredEdges = remainingEdges.filter(edgeFilter)___		return new Graph<>(filteredVertices, filteredEdges, this.context)__	};apply,filtering,functions,to,the,graph,and,return,a,sub,graph,that,satisfies,the,predicates,for,both,vertices,and,edges,param,vertex,filter,the,filter,function,for,vertices,param,edge,filter,the,filter,function,for,edges,return,the,resulting,sub,graph;public,graph,k,vv,ev,subgraph,filter,function,vertex,k,vv,vertex,filter,filter,function,edge,k,ev,edge,filter,data,set,vertex,k,vv,filtered,vertices,this,vertices,filter,vertex,filter,data,set,edge,k,ev,remaining,edges,this,edges,join,filtered,vertices,where,0,equal,to,0,with,new,project,edge,k,vv,ev,join,filtered,vertices,where,1,equal,to,0,with,new,project,edge,k,vv,ev,name,subgraph,data,set,edge,k,ev,filtered,edges,remaining,edges,filter,edge,filter,return,new,graph,filtered,vertices,filtered,edges,this,context
Graph -> public Graph<K, VV, EV> subgraph(FilterFunction<Vertex<K, VV>> vertexFilter, FilterFunction<Edge<K, EV>> edgeFilter);1495819075;Apply filtering functions to the graph and return a sub-graph that_satisfies the predicates for both vertices and edges.__@param vertexFilter the filter function for vertices._@param edgeFilter the filter function for edges._@return the resulting sub-graph.;public Graph<K, VV, EV> subgraph(FilterFunction<Vertex<K, VV>> vertexFilter, FilterFunction<Edge<K, EV>> edgeFilter) {__		DataSet<Vertex<K, VV>> filteredVertices = this.vertices.filter(vertexFilter)___		DataSet<Edge<K, EV>> remainingEdges = this.edges.join(filteredVertices)_				.where(0).equalTo(0).with(new ProjectEdge<K, VV, EV>())_				.join(filteredVertices).where(1).equalTo(0)_				.with(new ProjectEdge<K, VV, EV>()).name("Subgraph")___		DataSet<Edge<K, EV>> filteredEdges = remainingEdges.filter(edgeFilter)___		return new Graph<>(filteredVertices, filteredEdges, this.context)__	};apply,filtering,functions,to,the,graph,and,return,a,sub,graph,that,satisfies,the,predicates,for,both,vertices,and,edges,param,vertex,filter,the,filter,function,for,vertices,param,edge,filter,the,filter,function,for,edges,return,the,resulting,sub,graph;public,graph,k,vv,ev,subgraph,filter,function,vertex,k,vv,vertex,filter,filter,function,edge,k,ev,edge,filter,data,set,vertex,k,vv,filtered,vertices,this,vertices,filter,vertex,filter,data,set,edge,k,ev,remaining,edges,this,edges,join,filtered,vertices,where,0,equal,to,0,with,new,project,edge,k,vv,ev,join,filtered,vertices,where,1,equal,to,0,with,new,project,edge,k,vv,ev,name,subgraph,data,set,edge,k,ev,filtered,edges,remaining,edges,filter,edge,filter,return,new,graph,filtered,vertices,filtered,edges,this,context
Graph -> public Graph<K, VV, EV> subgraph(FilterFunction<Vertex<K, VV>> vertexFilter, FilterFunction<Edge<K, EV>> edgeFilter);1502111816;Apply filtering functions to the graph and return a sub-graph that_satisfies the predicates for both vertices and edges.__@param vertexFilter the filter function for vertices._@param edgeFilter the filter function for edges._@return the resulting sub-graph.;public Graph<K, VV, EV> subgraph(FilterFunction<Vertex<K, VV>> vertexFilter, FilterFunction<Edge<K, EV>> edgeFilter) {__		DataSet<Vertex<K, VV>> filteredVertices = this.vertices.filter(vertexFilter)___		DataSet<Edge<K, EV>> remainingEdges = this.edges.join(filteredVertices)_				.where(0).equalTo(0).with(new ProjectEdge<>())_				.join(filteredVertices).where(1).equalTo(0)_				.with(new ProjectEdge<>()).name("Subgraph")___		DataSet<Edge<K, EV>> filteredEdges = remainingEdges.filter(edgeFilter)___		return new Graph<>(filteredVertices, filteredEdges, this.context)__	};apply,filtering,functions,to,the,graph,and,return,a,sub,graph,that,satisfies,the,predicates,for,both,vertices,and,edges,param,vertex,filter,the,filter,function,for,vertices,param,edge,filter,the,filter,function,for,edges,return,the,resulting,sub,graph;public,graph,k,vv,ev,subgraph,filter,function,vertex,k,vv,vertex,filter,filter,function,edge,k,ev,edge,filter,data,set,vertex,k,vv,filtered,vertices,this,vertices,filter,vertex,filter,data,set,edge,k,ev,remaining,edges,this,edges,join,filtered,vertices,where,0,equal,to,0,with,new,project,edge,join,filtered,vertices,where,1,equal,to,0,with,new,project,edge,name,subgraph,data,set,edge,k,ev,filtered,edges,remaining,edges,filter,edge,filter,return,new,graph,filtered,vertices,filtered,edges,this,context
Graph -> public Graph<K, VV, EV> filterOnEdges(FilterFunction<Edge<K, EV>> edgeFilter);1444404795;Apply a filtering function to the graph and return a sub-graph that_satisfies the predicates only for the edges.__@param edgeFilter the filter function for edges._@return the resulting sub-graph.;public Graph<K, VV, EV> filterOnEdges(FilterFunction<Edge<K, EV>> edgeFilter) {_		DataSet<Edge<K, EV>> filteredEdges = this.edges.filter(edgeFilter)___		return new Graph<K, VV, EV>(this.vertices, filteredEdges, this.context)__	};apply,a,filtering,function,to,the,graph,and,return,a,sub,graph,that,satisfies,the,predicates,only,for,the,edges,param,edge,filter,the,filter,function,for,edges,return,the,resulting,sub,graph;public,graph,k,vv,ev,filter,on,edges,filter,function,edge,k,ev,edge,filter,data,set,edge,k,ev,filtered,edges,this,edges,filter,edge,filter,return,new,graph,k,vv,ev,this,vertices,filtered,edges,this,context
Graph -> public Graph<K, VV, EV> filterOnEdges(FilterFunction<Edge<K, EV>> edgeFilter);1445261977;Apply a filtering function to the graph and return a sub-graph that_satisfies the predicates only for the edges.__@param edgeFilter the filter function for edges._@return the resulting sub-graph.;public Graph<K, VV, EV> filterOnEdges(FilterFunction<Edge<K, EV>> edgeFilter) {_		DataSet<Edge<K, EV>> filteredEdges = this.edges.filter(edgeFilter)___		return new Graph<K, VV, EV>(this.vertices, filteredEdges, this.context)__	};apply,a,filtering,function,to,the,graph,and,return,a,sub,graph,that,satisfies,the,predicates,only,for,the,edges,param,edge,filter,the,filter,function,for,edges,return,the,resulting,sub,graph;public,graph,k,vv,ev,filter,on,edges,filter,function,edge,k,ev,edge,filter,data,set,edge,k,ev,filtered,edges,this,edges,filter,edge,filter,return,new,graph,k,vv,ev,this,vertices,filtered,edges,this,context
Graph -> public Graph<K, VV, EV> filterOnEdges(FilterFunction<Edge<K, EV>> edgeFilter);1445854323;Apply a filtering function to the graph and return a sub-graph that_satisfies the predicates only for the edges.__@param edgeFilter the filter function for edges._@return the resulting sub-graph.;public Graph<K, VV, EV> filterOnEdges(FilterFunction<Edge<K, EV>> edgeFilter) {_		DataSet<Edge<K, EV>> filteredEdges = this.edges.filter(edgeFilter)___		return new Graph<K, VV, EV>(this.vertices, filteredEdges, this.context)__	};apply,a,filtering,function,to,the,graph,and,return,a,sub,graph,that,satisfies,the,predicates,only,for,the,edges,param,edge,filter,the,filter,function,for,edges,return,the,resulting,sub,graph;public,graph,k,vv,ev,filter,on,edges,filter,function,edge,k,ev,edge,filter,data,set,edge,k,ev,filtered,edges,this,edges,filter,edge,filter,return,new,graph,k,vv,ev,this,vertices,filtered,edges,this,context
Graph -> public Graph<K, VV, EV> filterOnEdges(FilterFunction<Edge<K, EV>> edgeFilter);1446112342;Apply a filtering function to the graph and return a sub-graph that_satisfies the predicates only for the edges.__@param edgeFilter the filter function for edges._@return the resulting sub-graph.;public Graph<K, VV, EV> filterOnEdges(FilterFunction<Edge<K, EV>> edgeFilter) {_		DataSet<Edge<K, EV>> filteredEdges = this.edges.filter(edgeFilter)___		return new Graph<K, VV, EV>(this.vertices, filteredEdges, this.context)__	};apply,a,filtering,function,to,the,graph,and,return,a,sub,graph,that,satisfies,the,predicates,only,for,the,edges,param,edge,filter,the,filter,function,for,edges,return,the,resulting,sub,graph;public,graph,k,vv,ev,filter,on,edges,filter,function,edge,k,ev,edge,filter,data,set,edge,k,ev,filtered,edges,this,edges,filter,edge,filter,return,new,graph,k,vv,ev,this,vertices,filtered,edges,this,context
Graph -> public Graph<K, VV, EV> filterOnEdges(FilterFunction<Edge<K, EV>> edgeFilter);1447073368;Apply a filtering function to the graph and return a sub-graph that_satisfies the predicates only for the edges.__@param edgeFilter the filter function for edges._@return the resulting sub-graph.;public Graph<K, VV, EV> filterOnEdges(FilterFunction<Edge<K, EV>> edgeFilter) {_		DataSet<Edge<K, EV>> filteredEdges = this.edges.filter(edgeFilter)___		return new Graph<K, VV, EV>(this.vertices, filteredEdges, this.context)__	};apply,a,filtering,function,to,the,graph,and,return,a,sub,graph,that,satisfies,the,predicates,only,for,the,edges,param,edge,filter,the,filter,function,for,edges,return,the,resulting,sub,graph;public,graph,k,vv,ev,filter,on,edges,filter,function,edge,k,ev,edge,filter,data,set,edge,k,ev,filtered,edges,this,edges,filter,edge,filter,return,new,graph,k,vv,ev,this,vertices,filtered,edges,this,context
Graph -> public Graph<K, VV, EV> filterOnEdges(FilterFunction<Edge<K, EV>> edgeFilter);1454404649;Apply a filtering function to the graph and return a sub-graph that_satisfies the predicates only for the edges.__@param edgeFilter the filter function for edges._@return the resulting sub-graph.;public Graph<K, VV, EV> filterOnEdges(FilterFunction<Edge<K, EV>> edgeFilter) {_		DataSet<Edge<K, EV>> filteredEdges = this.edges.filter(edgeFilter)___		return new Graph<K, VV, EV>(this.vertices, filteredEdges, this.context)__	};apply,a,filtering,function,to,the,graph,and,return,a,sub,graph,that,satisfies,the,predicates,only,for,the,edges,param,edge,filter,the,filter,function,for,edges,return,the,resulting,sub,graph;public,graph,k,vv,ev,filter,on,edges,filter,function,edge,k,ev,edge,filter,data,set,edge,k,ev,filtered,edges,this,edges,filter,edge,filter,return,new,graph,k,vv,ev,this,vertices,filtered,edges,this,context
Graph -> public Graph<K, VV, EV> filterOnEdges(FilterFunction<Edge<K, EV>> edgeFilter);1458583829;Apply a filtering function to the graph and return a sub-graph that_satisfies the predicates only for the edges.__@param edgeFilter the filter function for edges._@return the resulting sub-graph.;public Graph<K, VV, EV> filterOnEdges(FilterFunction<Edge<K, EV>> edgeFilter) {_		DataSet<Edge<K, EV>> filteredEdges = this.edges.filter(edgeFilter)___		return new Graph<K, VV, EV>(this.vertices, filteredEdges, this.context)__	};apply,a,filtering,function,to,the,graph,and,return,a,sub,graph,that,satisfies,the,predicates,only,for,the,edges,param,edge,filter,the,filter,function,for,edges,return,the,resulting,sub,graph;public,graph,k,vv,ev,filter,on,edges,filter,function,edge,k,ev,edge,filter,data,set,edge,k,ev,filtered,edges,this,edges,filter,edge,filter,return,new,graph,k,vv,ev,this,vertices,filtered,edges,this,context
Graph -> public Graph<K, VV, EV> filterOnEdges(FilterFunction<Edge<K, EV>> edgeFilter);1458583829;Apply a filtering function to the graph and return a sub-graph that_satisfies the predicates only for the edges.__@param edgeFilter the filter function for edges._@return the resulting sub-graph.;public Graph<K, VV, EV> filterOnEdges(FilterFunction<Edge<K, EV>> edgeFilter) {_		DataSet<Edge<K, EV>> filteredEdges = this.edges.filter(edgeFilter)___		return new Graph<K, VV, EV>(this.vertices, filteredEdges, this.context)__	};apply,a,filtering,function,to,the,graph,and,return,a,sub,graph,that,satisfies,the,predicates,only,for,the,edges,param,edge,filter,the,filter,function,for,edges,return,the,resulting,sub,graph;public,graph,k,vv,ev,filter,on,edges,filter,function,edge,k,ev,edge,filter,data,set,edge,k,ev,filtered,edges,this,edges,filter,edge,filter,return,new,graph,k,vv,ev,this,vertices,filtered,edges,this,context
Graph -> public Graph<K, VV, EV> filterOnEdges(FilterFunction<Edge<K, EV>> edgeFilter);1462100316;Apply a filtering function to the graph and return a sub-graph that_satisfies the predicates only for the edges.__@param edgeFilter the filter function for edges._@return the resulting sub-graph.;public Graph<K, VV, EV> filterOnEdges(FilterFunction<Edge<K, EV>> edgeFilter) {_		DataSet<Edge<K, EV>> filteredEdges = this.edges.filter(edgeFilter)___		return new Graph<K, VV, EV>(this.vertices, filteredEdges, this.context)__	};apply,a,filtering,function,to,the,graph,and,return,a,sub,graph,that,satisfies,the,predicates,only,for,the,edges,param,edge,filter,the,filter,function,for,edges,return,the,resulting,sub,graph;public,graph,k,vv,ev,filter,on,edges,filter,function,edge,k,ev,edge,filter,data,set,edge,k,ev,filtered,edges,this,edges,filter,edge,filter,return,new,graph,k,vv,ev,this,vertices,filtered,edges,this,context
Graph -> public Graph<K, VV, EV> filterOnEdges(FilterFunction<Edge<K, EV>> edgeFilter);1462100316;Apply a filtering function to the graph and return a sub-graph that_satisfies the predicates only for the edges.__@param edgeFilter the filter function for edges._@return the resulting sub-graph.;public Graph<K, VV, EV> filterOnEdges(FilterFunction<Edge<K, EV>> edgeFilter) {_		DataSet<Edge<K, EV>> filteredEdges = this.edges.filter(edgeFilter)___		return new Graph<K, VV, EV>(this.vertices, filteredEdges, this.context)__	};apply,a,filtering,function,to,the,graph,and,return,a,sub,graph,that,satisfies,the,predicates,only,for,the,edges,param,edge,filter,the,filter,function,for,edges,return,the,resulting,sub,graph;public,graph,k,vv,ev,filter,on,edges,filter,function,edge,k,ev,edge,filter,data,set,edge,k,ev,filtered,edges,this,edges,filter,edge,filter,return,new,graph,k,vv,ev,this,vertices,filtered,edges,this,context
Graph -> public Graph<K, VV, EV> filterOnEdges(FilterFunction<Edge<K, EV>> edgeFilter);1462205213;Apply a filtering function to the graph and return a sub-graph that_satisfies the predicates only for the edges.__@param edgeFilter the filter function for edges._@return the resulting sub-graph.;public Graph<K, VV, EV> filterOnEdges(FilterFunction<Edge<K, EV>> edgeFilter) {_		DataSet<Edge<K, EV>> filteredEdges = this.edges.filter(edgeFilter)___		return new Graph<K, VV, EV>(this.vertices, filteredEdges, this.context)__	};apply,a,filtering,function,to,the,graph,and,return,a,sub,graph,that,satisfies,the,predicates,only,for,the,edges,param,edge,filter,the,filter,function,for,edges,return,the,resulting,sub,graph;public,graph,k,vv,ev,filter,on,edges,filter,function,edge,k,ev,edge,filter,data,set,edge,k,ev,filtered,edges,this,edges,filter,edge,filter,return,new,graph,k,vv,ev,this,vertices,filtered,edges,this,context
Graph -> public Graph<K, VV, EV> filterOnEdges(FilterFunction<Edge<K, EV>> edgeFilter);1462208859;Apply a filtering function to the graph and return a sub-graph that_satisfies the predicates only for the edges.__@param edgeFilter the filter function for edges._@return the resulting sub-graph.;public Graph<K, VV, EV> filterOnEdges(FilterFunction<Edge<K, EV>> edgeFilter) {_		DataSet<Edge<K, EV>> filteredEdges = this.edges.filter(edgeFilter)___		return new Graph<K, VV, EV>(this.vertices, filteredEdges, this.context)__	};apply,a,filtering,function,to,the,graph,and,return,a,sub,graph,that,satisfies,the,predicates,only,for,the,edges,param,edge,filter,the,filter,function,for,edges,return,the,resulting,sub,graph;public,graph,k,vv,ev,filter,on,edges,filter,function,edge,k,ev,edge,filter,data,set,edge,k,ev,filtered,edges,this,edges,filter,edge,filter,return,new,graph,k,vv,ev,this,vertices,filtered,edges,this,context
Graph -> public Graph<K, VV, EV> filterOnEdges(FilterFunction<Edge<K, EV>> edgeFilter);1462809297;Apply a filtering function to the graph and return a sub-graph that_satisfies the predicates only for the edges.__@param edgeFilter the filter function for edges._@return the resulting sub-graph.;public Graph<K, VV, EV> filterOnEdges(FilterFunction<Edge<K, EV>> edgeFilter) {_		DataSet<Edge<K, EV>> filteredEdges = this.edges.filter(edgeFilter)___		return new Graph<K, VV, EV>(this.vertices, filteredEdges, this.context)__	};apply,a,filtering,function,to,the,graph,and,return,a,sub,graph,that,satisfies,the,predicates,only,for,the,edges,param,edge,filter,the,filter,function,for,edges,return,the,resulting,sub,graph;public,graph,k,vv,ev,filter,on,edges,filter,function,edge,k,ev,edge,filter,data,set,edge,k,ev,filtered,edges,this,edges,filter,edge,filter,return,new,graph,k,vv,ev,this,vertices,filtered,edges,this,context
Graph -> public Graph<K, VV, EV> filterOnEdges(FilterFunction<Edge<K, EV>> edgeFilter);1465316775;Apply a filtering function to the graph and return a sub-graph that_satisfies the predicates only for the edges.__@param edgeFilter the filter function for edges._@return the resulting sub-graph.;public Graph<K, VV, EV> filterOnEdges(FilterFunction<Edge<K, EV>> edgeFilter) {_		DataSet<Edge<K, EV>> filteredEdges = this.edges.filter(edgeFilter)___		return new Graph<K, VV, EV>(this.vertices, filteredEdges, this.context)__	};apply,a,filtering,function,to,the,graph,and,return,a,sub,graph,that,satisfies,the,predicates,only,for,the,edges,param,edge,filter,the,filter,function,for,edges,return,the,resulting,sub,graph;public,graph,k,vv,ev,filter,on,edges,filter,function,edge,k,ev,edge,filter,data,set,edge,k,ev,filtered,edges,this,edges,filter,edge,filter,return,new,graph,k,vv,ev,this,vertices,filtered,edges,this,context
Graph -> public Graph<K, VV, EV> filterOnEdges(FilterFunction<Edge<K, EV>> edgeFilter);1466789678;Apply a filtering function to the graph and return a sub-graph that_satisfies the predicates only for the edges.__@param edgeFilter the filter function for edges._@return the resulting sub-graph.;public Graph<K, VV, EV> filterOnEdges(FilterFunction<Edge<K, EV>> edgeFilter) {_		DataSet<Edge<K, EV>> filteredEdges = this.edges.filter(edgeFilter)___		return new Graph<K, VV, EV>(this.vertices, filteredEdges, this.context)__	};apply,a,filtering,function,to,the,graph,and,return,a,sub,graph,that,satisfies,the,predicates,only,for,the,edges,param,edge,filter,the,filter,function,for,edges,return,the,resulting,sub,graph;public,graph,k,vv,ev,filter,on,edges,filter,function,edge,k,ev,edge,filter,data,set,edge,k,ev,filtered,edges,this,edges,filter,edge,filter,return,new,graph,k,vv,ev,this,vertices,filtered,edges,this,context
Graph -> public Graph<K, VV, EV> filterOnEdges(FilterFunction<Edge<K, EV>> edgeFilter);1467140656;Apply a filtering function to the graph and return a sub-graph that_satisfies the predicates only for the edges.__@param edgeFilter the filter function for edges._@return the resulting sub-graph.;public Graph<K, VV, EV> filterOnEdges(FilterFunction<Edge<K, EV>> edgeFilter) {_		DataSet<Edge<K, EV>> filteredEdges = this.edges.filter(edgeFilter)___		return new Graph<K, VV, EV>(this.vertices, filteredEdges, this.context)__	};apply,a,filtering,function,to,the,graph,and,return,a,sub,graph,that,satisfies,the,predicates,only,for,the,edges,param,edge,filter,the,filter,function,for,edges,return,the,resulting,sub,graph;public,graph,k,vv,ev,filter,on,edges,filter,function,edge,k,ev,edge,filter,data,set,edge,k,ev,filtered,edges,this,edges,filter,edge,filter,return,new,graph,k,vv,ev,this,vertices,filtered,edges,this,context
Graph -> public Graph<K, VV, EV> filterOnEdges(FilterFunction<Edge<K, EV>> edgeFilter);1467306272;Apply a filtering function to the graph and return a sub-graph that_satisfies the predicates only for the edges.__@param edgeFilter the filter function for edges._@return the resulting sub-graph.;public Graph<K, VV, EV> filterOnEdges(FilterFunction<Edge<K, EV>> edgeFilter) {_		DataSet<Edge<K, EV>> filteredEdges = this.edges.filter(edgeFilter)___		return new Graph<K, VV, EV>(this.vertices, filteredEdges, this.context)__	};apply,a,filtering,function,to,the,graph,and,return,a,sub,graph,that,satisfies,the,predicates,only,for,the,edges,param,edge,filter,the,filter,function,for,edges,return,the,resulting,sub,graph;public,graph,k,vv,ev,filter,on,edges,filter,function,edge,k,ev,edge,filter,data,set,edge,k,ev,filtered,edges,this,edges,filter,edge,filter,return,new,graph,k,vv,ev,this,vertices,filtered,edges,this,context
Graph -> public Graph<K, VV, EV> filterOnEdges(FilterFunction<Edge<K, EV>> edgeFilter);1470042815;Apply a filtering function to the graph and return a sub-graph that_satisfies the predicates only for the edges.__@param edgeFilter the filter function for edges._@return the resulting sub-graph.;public Graph<K, VV, EV> filterOnEdges(FilterFunction<Edge<K, EV>> edgeFilter) {_		DataSet<Edge<K, EV>> filteredEdges = this.edges.filter(edgeFilter)___		return new Graph<K, VV, EV>(this.vertices, filteredEdges, this.context)__	};apply,a,filtering,function,to,the,graph,and,return,a,sub,graph,that,satisfies,the,predicates,only,for,the,edges,param,edge,filter,the,filter,function,for,edges,return,the,resulting,sub,graph;public,graph,k,vv,ev,filter,on,edges,filter,function,edge,k,ev,edge,filter,data,set,edge,k,ev,filtered,edges,this,edges,filter,edge,filter,return,new,graph,k,vv,ev,this,vertices,filtered,edges,this,context
Graph -> public Graph<K, VV, EV> filterOnEdges(FilterFunction<Edge<K, EV>> edgeFilter);1475684776;Apply a filtering function to the graph and return a sub-graph that_satisfies the predicates only for the edges.__@param edgeFilter the filter function for edges._@return the resulting sub-graph.;public Graph<K, VV, EV> filterOnEdges(FilterFunction<Edge<K, EV>> edgeFilter) {_		DataSet<Edge<K, EV>> filteredEdges = this.edges.filter(edgeFilter)___		return new Graph<>(this.vertices, filteredEdges, this.context)__	};apply,a,filtering,function,to,the,graph,and,return,a,sub,graph,that,satisfies,the,predicates,only,for,the,edges,param,edge,filter,the,filter,function,for,edges,return,the,resulting,sub,graph;public,graph,k,vv,ev,filter,on,edges,filter,function,edge,k,ev,edge,filter,data,set,edge,k,ev,filtered,edges,this,edges,filter,edge,filter,return,new,graph,this,vertices,filtered,edges,this,context
Graph -> public Graph<K, VV, EV> filterOnEdges(FilterFunction<Edge<K, EV>> edgeFilter);1475685606;Apply a filtering function to the graph and return a sub-graph that_satisfies the predicates only for the edges.__@param edgeFilter the filter function for edges._@return the resulting sub-graph.;public Graph<K, VV, EV> filterOnEdges(FilterFunction<Edge<K, EV>> edgeFilter) {_		DataSet<Edge<K, EV>> filteredEdges = this.edges.filter(edgeFilter)___		return new Graph<>(this.vertices, filteredEdges, this.context)__	};apply,a,filtering,function,to,the,graph,and,return,a,sub,graph,that,satisfies,the,predicates,only,for,the,edges,param,edge,filter,the,filter,function,for,edges,return,the,resulting,sub,graph;public,graph,k,vv,ev,filter,on,edges,filter,function,edge,k,ev,edge,filter,data,set,edge,k,ev,filtered,edges,this,edges,filter,edge,filter,return,new,graph,this,vertices,filtered,edges,this,context
Graph -> public Graph<K, VV, EV> filterOnEdges(FilterFunction<Edge<K, EV>> edgeFilter);1481745825;Apply a filtering function to the graph and return a sub-graph that_satisfies the predicates only for the edges.__@param edgeFilter the filter function for edges._@return the resulting sub-graph.;public Graph<K, VV, EV> filterOnEdges(FilterFunction<Edge<K, EV>> edgeFilter) {_		DataSet<Edge<K, EV>> filteredEdges = this.edges.filter(edgeFilter).name("Filter on edges")___		return new Graph<>(this.vertices, filteredEdges, this.context)__	};apply,a,filtering,function,to,the,graph,and,return,a,sub,graph,that,satisfies,the,predicates,only,for,the,edges,param,edge,filter,the,filter,function,for,edges,return,the,resulting,sub,graph;public,graph,k,vv,ev,filter,on,edges,filter,function,edge,k,ev,edge,filter,data,set,edge,k,ev,filtered,edges,this,edges,filter,edge,filter,name,filter,on,edges,return,new,graph,this,vertices,filtered,edges,this,context
Graph -> public Graph<K, VV, EV> filterOnEdges(FilterFunction<Edge<K, EV>> edgeFilter);1481881009;Apply a filtering function to the graph and return a sub-graph that_satisfies the predicates only for the edges.__@param edgeFilter the filter function for edges._@return the resulting sub-graph.;public Graph<K, VV, EV> filterOnEdges(FilterFunction<Edge<K, EV>> edgeFilter) {_		DataSet<Edge<K, EV>> filteredEdges = this.edges.filter(edgeFilter).name("Filter on edges")___		return new Graph<>(this.vertices, filteredEdges, this.context)__	};apply,a,filtering,function,to,the,graph,and,return,a,sub,graph,that,satisfies,the,predicates,only,for,the,edges,param,edge,filter,the,filter,function,for,edges,return,the,resulting,sub,graph;public,graph,k,vv,ev,filter,on,edges,filter,function,edge,k,ev,edge,filter,data,set,edge,k,ev,filtered,edges,this,edges,filter,edge,filter,name,filter,on,edges,return,new,graph,this,vertices,filtered,edges,this,context
Graph -> public Graph<K, VV, EV> filterOnEdges(FilterFunction<Edge<K, EV>> edgeFilter);1484160227;Apply a filtering function to the graph and return a sub-graph that_satisfies the predicates only for the edges.__@param edgeFilter the filter function for edges._@return the resulting sub-graph.;public Graph<K, VV, EV> filterOnEdges(FilterFunction<Edge<K, EV>> edgeFilter) {_		DataSet<Edge<K, EV>> filteredEdges = this.edges.filter(edgeFilter).name("Filter on edges")___		return new Graph<>(this.vertices, filteredEdges, this.context)__	};apply,a,filtering,function,to,the,graph,and,return,a,sub,graph,that,satisfies,the,predicates,only,for,the,edges,param,edge,filter,the,filter,function,for,edges,return,the,resulting,sub,graph;public,graph,k,vv,ev,filter,on,edges,filter,function,edge,k,ev,edge,filter,data,set,edge,k,ev,filtered,edges,this,edges,filter,edge,filter,name,filter,on,edges,return,new,graph,this,vertices,filtered,edges,this,context
Graph -> public Graph<K, VV, EV> filterOnEdges(FilterFunction<Edge<K, EV>> edgeFilter);1484685504;Apply a filtering function to the graph and return a sub-graph that_satisfies the predicates only for the edges.__@param edgeFilter the filter function for edges._@return the resulting sub-graph.;public Graph<K, VV, EV> filterOnEdges(FilterFunction<Edge<K, EV>> edgeFilter) {_		DataSet<Edge<K, EV>> filteredEdges = this.edges.filter(edgeFilter).name("Filter on edges")___		return new Graph<>(this.vertices, filteredEdges, this.context)__	};apply,a,filtering,function,to,the,graph,and,return,a,sub,graph,that,satisfies,the,predicates,only,for,the,edges,param,edge,filter,the,filter,function,for,edges,return,the,resulting,sub,graph;public,graph,k,vv,ev,filter,on,edges,filter,function,edge,k,ev,edge,filter,data,set,edge,k,ev,filtered,edges,this,edges,filter,edge,filter,name,filter,on,edges,return,new,graph,this,vertices,filtered,edges,this,context
Graph -> public Graph<K, VV, EV> filterOnEdges(FilterFunction<Edge<K, EV>> edgeFilter);1489068942;Apply a filtering function to the graph and return a sub-graph that_satisfies the predicates only for the edges.__@param edgeFilter the filter function for edges._@return the resulting sub-graph.;public Graph<K, VV, EV> filterOnEdges(FilterFunction<Edge<K, EV>> edgeFilter) {_		DataSet<Edge<K, EV>> filteredEdges = this.edges.filter(edgeFilter).name("Filter on edges")___		return new Graph<>(this.vertices, filteredEdges, this.context)__	};apply,a,filtering,function,to,the,graph,and,return,a,sub,graph,that,satisfies,the,predicates,only,for,the,edges,param,edge,filter,the,filter,function,for,edges,return,the,resulting,sub,graph;public,graph,k,vv,ev,filter,on,edges,filter,function,edge,k,ev,edge,filter,data,set,edge,k,ev,filtered,edges,this,edges,filter,edge,filter,name,filter,on,edges,return,new,graph,this,vertices,filtered,edges,this,context
Graph -> public Graph<K, VV, EV> filterOnEdges(FilterFunction<Edge<K, EV>> edgeFilter);1490973446;Apply a filtering function to the graph and return a sub-graph that_satisfies the predicates only for the edges.__@param edgeFilter the filter function for edges._@return the resulting sub-graph.;public Graph<K, VV, EV> filterOnEdges(FilterFunction<Edge<K, EV>> edgeFilter) {_		DataSet<Edge<K, EV>> filteredEdges = this.edges.filter(edgeFilter).name("Filter on edges")___		return new Graph<>(this.vertices, filteredEdges, this.context)__	};apply,a,filtering,function,to,the,graph,and,return,a,sub,graph,that,satisfies,the,predicates,only,for,the,edges,param,edge,filter,the,filter,function,for,edges,return,the,resulting,sub,graph;public,graph,k,vv,ev,filter,on,edges,filter,function,edge,k,ev,edge,filter,data,set,edge,k,ev,filtered,edges,this,edges,filter,edge,filter,name,filter,on,edges,return,new,graph,this,vertices,filtered,edges,this,context
Graph -> public Graph<K, VV, EV> filterOnEdges(FilterFunction<Edge<K, EV>> edgeFilter);1495819075;Apply a filtering function to the graph and return a sub-graph that_satisfies the predicates only for the edges.__@param edgeFilter the filter function for edges._@return the resulting sub-graph.;public Graph<K, VV, EV> filterOnEdges(FilterFunction<Edge<K, EV>> edgeFilter) {_		DataSet<Edge<K, EV>> filteredEdges = this.edges.filter(edgeFilter).name("Filter on edges")___		return new Graph<>(this.vertices, filteredEdges, this.context)__	};apply,a,filtering,function,to,the,graph,and,return,a,sub,graph,that,satisfies,the,predicates,only,for,the,edges,param,edge,filter,the,filter,function,for,edges,return,the,resulting,sub,graph;public,graph,k,vv,ev,filter,on,edges,filter,function,edge,k,ev,edge,filter,data,set,edge,k,ev,filtered,edges,this,edges,filter,edge,filter,name,filter,on,edges,return,new,graph,this,vertices,filtered,edges,this,context
Graph -> public Graph<K, VV, EV> filterOnEdges(FilterFunction<Edge<K, EV>> edgeFilter);1502111816;Apply a filtering function to the graph and return a sub-graph that_satisfies the predicates only for the edges.__@param edgeFilter the filter function for edges._@return the resulting sub-graph.;public Graph<K, VV, EV> filterOnEdges(FilterFunction<Edge<K, EV>> edgeFilter) {_		DataSet<Edge<K, EV>> filteredEdges = this.edges.filter(edgeFilter).name("Filter on edges")___		return new Graph<>(this.vertices, filteredEdges, this.context)__	};apply,a,filtering,function,to,the,graph,and,return,a,sub,graph,that,satisfies,the,predicates,only,for,the,edges,param,edge,filter,the,filter,function,for,edges,return,the,resulting,sub,graph;public,graph,k,vv,ev,filter,on,edges,filter,function,edge,k,ev,edge,filter,data,set,edge,k,ev,filtered,edges,this,edges,filter,edge,filter,name,filter,on,edges,return,new,graph,this,vertices,filtered,edges,this,context
Graph -> public Graph<K, VV, EV> removeEdges(List<Edge<K, EV>> edgesToBeRemoved);1444404795;Removes all the edges that match the edges in the given data set from the graph.__@param edgesToBeRemoved the list of edges to be removed_@return a new graph where the edges have been removed and in which the vertices remained intact;public Graph<K, VV, EV> removeEdges(List<Edge<K, EV>> edgesToBeRemoved) {__		DataSet<Edge<K, EV>> newEdges = getEdges().coGroup(this.context.fromCollection(edgesToBeRemoved))_				.where(0,1).equalTo(0,1).with(new EdgeRemovalCoGroup<K, EV>())___		return new Graph<K, VV, EV>(this.vertices, newEdges, context)__	};removes,all,the,edges,that,match,the,edges,in,the,given,data,set,from,the,graph,param,edges,to,be,removed,the,list,of,edges,to,be,removed,return,a,new,graph,where,the,edges,have,been,removed,and,in,which,the,vertices,remained,intact;public,graph,k,vv,ev,remove,edges,list,edge,k,ev,edges,to,be,removed,data,set,edge,k,ev,new,edges,get,edges,co,group,this,context,from,collection,edges,to,be,removed,where,0,1,equal,to,0,1,with,new,edge,removal,co,group,k,ev,return,new,graph,k,vv,ev,this,vertices,new,edges,context
Graph -> public Graph<K, VV, EV> removeEdges(List<Edge<K, EV>> edgesToBeRemoved);1445261977;Removes all the edges that match the edges in the given data set from the graph.__@param edgesToBeRemoved the list of edges to be removed_@return a new graph where the edges have been removed and in which the vertices remained intact;public Graph<K, VV, EV> removeEdges(List<Edge<K, EV>> edgesToBeRemoved) {__		DataSet<Edge<K, EV>> newEdges = getEdges().coGroup(this.context.fromCollection(edgesToBeRemoved))_				.where(0,1).equalTo(0,1).with(new EdgeRemovalCoGroup<K, EV>())___		return new Graph<K, VV, EV>(this.vertices, newEdges, context)__	};removes,all,the,edges,that,match,the,edges,in,the,given,data,set,from,the,graph,param,edges,to,be,removed,the,list,of,edges,to,be,removed,return,a,new,graph,where,the,edges,have,been,removed,and,in,which,the,vertices,remained,intact;public,graph,k,vv,ev,remove,edges,list,edge,k,ev,edges,to,be,removed,data,set,edge,k,ev,new,edges,get,edges,co,group,this,context,from,collection,edges,to,be,removed,where,0,1,equal,to,0,1,with,new,edge,removal,co,group,k,ev,return,new,graph,k,vv,ev,this,vertices,new,edges,context
Graph -> public Graph<K, VV, EV> removeEdges(List<Edge<K, EV>> edgesToBeRemoved);1445854323;Removes all the edges that match the edges in the given data set from the graph.__@param edgesToBeRemoved the list of edges to be removed_@return a new graph where the edges have been removed and in which the vertices remained intact;public Graph<K, VV, EV> removeEdges(List<Edge<K, EV>> edgesToBeRemoved) {__		DataSet<Edge<K, EV>> newEdges = getEdges().coGroup(this.context.fromCollection(edgesToBeRemoved))_				.where(0,1).equalTo(0,1).with(new EdgeRemovalCoGroup<K, EV>())___		return new Graph<K, VV, EV>(this.vertices, newEdges, context)__	};removes,all,the,edges,that,match,the,edges,in,the,given,data,set,from,the,graph,param,edges,to,be,removed,the,list,of,edges,to,be,removed,return,a,new,graph,where,the,edges,have,been,removed,and,in,which,the,vertices,remained,intact;public,graph,k,vv,ev,remove,edges,list,edge,k,ev,edges,to,be,removed,data,set,edge,k,ev,new,edges,get,edges,co,group,this,context,from,collection,edges,to,be,removed,where,0,1,equal,to,0,1,with,new,edge,removal,co,group,k,ev,return,new,graph,k,vv,ev,this,vertices,new,edges,context
Graph -> public Graph<K, VV, EV> removeEdges(List<Edge<K, EV>> edgesToBeRemoved);1446112342;Removes all the edges that match the edges in the given data set from the graph.__@param edgesToBeRemoved the list of edges to be removed_@return a new graph where the edges have been removed and in which the vertices remained intact;public Graph<K, VV, EV> removeEdges(List<Edge<K, EV>> edgesToBeRemoved) {__		DataSet<Edge<K, EV>> newEdges = getEdges().coGroup(this.context.fromCollection(edgesToBeRemoved))_				.where(0,1).equalTo(0,1).with(new EdgeRemovalCoGroup<K, EV>())___		return new Graph<K, VV, EV>(this.vertices, newEdges, context)__	};removes,all,the,edges,that,match,the,edges,in,the,given,data,set,from,the,graph,param,edges,to,be,removed,the,list,of,edges,to,be,removed,return,a,new,graph,where,the,edges,have,been,removed,and,in,which,the,vertices,remained,intact;public,graph,k,vv,ev,remove,edges,list,edge,k,ev,edges,to,be,removed,data,set,edge,k,ev,new,edges,get,edges,co,group,this,context,from,collection,edges,to,be,removed,where,0,1,equal,to,0,1,with,new,edge,removal,co,group,k,ev,return,new,graph,k,vv,ev,this,vertices,new,edges,context
Graph -> public Graph<K, VV, EV> removeEdges(List<Edge<K, EV>> edgesToBeRemoved);1447073368;Removes all the edges that match the edges in the given data set from the graph.__@param edgesToBeRemoved the list of edges to be removed_@return a new graph where the edges have been removed and in which the vertices remained intact;public Graph<K, VV, EV> removeEdges(List<Edge<K, EV>> edgesToBeRemoved) {__		DataSet<Edge<K, EV>> newEdges = getEdges().coGroup(this.context.fromCollection(edgesToBeRemoved))_				.where(0,1).equalTo(0,1).with(new EdgeRemovalCoGroup<K, EV>())___		return new Graph<K, VV, EV>(this.vertices, newEdges, context)__	};removes,all,the,edges,that,match,the,edges,in,the,given,data,set,from,the,graph,param,edges,to,be,removed,the,list,of,edges,to,be,removed,return,a,new,graph,where,the,edges,have,been,removed,and,in,which,the,vertices,remained,intact;public,graph,k,vv,ev,remove,edges,list,edge,k,ev,edges,to,be,removed,data,set,edge,k,ev,new,edges,get,edges,co,group,this,context,from,collection,edges,to,be,removed,where,0,1,equal,to,0,1,with,new,edge,removal,co,group,k,ev,return,new,graph,k,vv,ev,this,vertices,new,edges,context
Graph -> public Graph<K, VV, EV> removeEdges(List<Edge<K, EV>> edgesToBeRemoved);1454404649;Removes all the edges that match the edges in the given data set from the graph.__@param edgesToBeRemoved the list of edges to be removed_@return a new graph where the edges have been removed and in which the vertices remained intact;public Graph<K, VV, EV> removeEdges(List<Edge<K, EV>> edgesToBeRemoved) {__		DataSet<Edge<K, EV>> newEdges = getEdges().coGroup(this.context.fromCollection(edgesToBeRemoved))_				.where(0,1).equalTo(0,1).with(new EdgeRemovalCoGroup<K, EV>())___		return new Graph<K, VV, EV>(this.vertices, newEdges, context)__	};removes,all,the,edges,that,match,the,edges,in,the,given,data,set,from,the,graph,param,edges,to,be,removed,the,list,of,edges,to,be,removed,return,a,new,graph,where,the,edges,have,been,removed,and,in,which,the,vertices,remained,intact;public,graph,k,vv,ev,remove,edges,list,edge,k,ev,edges,to,be,removed,data,set,edge,k,ev,new,edges,get,edges,co,group,this,context,from,collection,edges,to,be,removed,where,0,1,equal,to,0,1,with,new,edge,removal,co,group,k,ev,return,new,graph,k,vv,ev,this,vertices,new,edges,context
Graph -> public Graph<K, VV, EV> removeEdges(List<Edge<K, EV>> edgesToBeRemoved);1458583829;Removes all the edges that match the edges in the given data set from the graph.__@param edgesToBeRemoved the list of edges to be removed_@return a new graph where the edges have been removed and in which the vertices remained intact;public Graph<K, VV, EV> removeEdges(List<Edge<K, EV>> edgesToBeRemoved) {__		DataSet<Edge<K, EV>> newEdges = getEdges().coGroup(this.context.fromCollection(edgesToBeRemoved))_				.where(0,1).equalTo(0,1).with(new EdgeRemovalCoGroup<K, EV>())___		return new Graph<K, VV, EV>(this.vertices, newEdges, context)__	};removes,all,the,edges,that,match,the,edges,in,the,given,data,set,from,the,graph,param,edges,to,be,removed,the,list,of,edges,to,be,removed,return,a,new,graph,where,the,edges,have,been,removed,and,in,which,the,vertices,remained,intact;public,graph,k,vv,ev,remove,edges,list,edge,k,ev,edges,to,be,removed,data,set,edge,k,ev,new,edges,get,edges,co,group,this,context,from,collection,edges,to,be,removed,where,0,1,equal,to,0,1,with,new,edge,removal,co,group,k,ev,return,new,graph,k,vv,ev,this,vertices,new,edges,context
Graph -> public Graph<K, VV, EV> removeEdges(List<Edge<K, EV>> edgesToBeRemoved);1458583829;Removes all the edges that match the edges in the given data set from the graph.__@param edgesToBeRemoved the list of edges to be removed_@return a new graph where the edges have been removed and in which the vertices remained intact;public Graph<K, VV, EV> removeEdges(List<Edge<K, EV>> edgesToBeRemoved) {__		DataSet<Edge<K, EV>> newEdges = getEdges().coGroup(this.context.fromCollection(edgesToBeRemoved))_				.where(0,1).equalTo(0,1).with(new EdgeRemovalCoGroup<K, EV>())___		return new Graph<K, VV, EV>(this.vertices, newEdges, context)__	};removes,all,the,edges,that,match,the,edges,in,the,given,data,set,from,the,graph,param,edges,to,be,removed,the,list,of,edges,to,be,removed,return,a,new,graph,where,the,edges,have,been,removed,and,in,which,the,vertices,remained,intact;public,graph,k,vv,ev,remove,edges,list,edge,k,ev,edges,to,be,removed,data,set,edge,k,ev,new,edges,get,edges,co,group,this,context,from,collection,edges,to,be,removed,where,0,1,equal,to,0,1,with,new,edge,removal,co,group,k,ev,return,new,graph,k,vv,ev,this,vertices,new,edges,context
Graph -> public Graph<K, VV, EV> removeEdges(List<Edge<K, EV>> edgesToBeRemoved);1462100316;Removes all the edges that match the edges in the given data set from the graph.__@param edgesToBeRemoved the list of edges to be removed_@return a new graph where the edges have been removed and in which the vertices remained intact;public Graph<K, VV, EV> removeEdges(List<Edge<K, EV>> edgesToBeRemoved) {__		DataSet<Edge<K, EV>> newEdges = getEdges().coGroup(this.context.fromCollection(edgesToBeRemoved))_				.where(0,1).equalTo(0,1).with(new EdgeRemovalCoGroup<K, EV>())___		return new Graph<K, VV, EV>(this.vertices, newEdges, context)__	};removes,all,the,edges,that,match,the,edges,in,the,given,data,set,from,the,graph,param,edges,to,be,removed,the,list,of,edges,to,be,removed,return,a,new,graph,where,the,edges,have,been,removed,and,in,which,the,vertices,remained,intact;public,graph,k,vv,ev,remove,edges,list,edge,k,ev,edges,to,be,removed,data,set,edge,k,ev,new,edges,get,edges,co,group,this,context,from,collection,edges,to,be,removed,where,0,1,equal,to,0,1,with,new,edge,removal,co,group,k,ev,return,new,graph,k,vv,ev,this,vertices,new,edges,context
Graph -> public Graph<K, VV, EV> removeEdges(List<Edge<K, EV>> edgesToBeRemoved);1462100316;Removes all the edges that match the edges in the given data set from the graph.__@param edgesToBeRemoved the list of edges to be removed_@return a new graph where the edges have been removed and in which the vertices remained intact;public Graph<K, VV, EV> removeEdges(List<Edge<K, EV>> edgesToBeRemoved) {__		DataSet<Edge<K, EV>> newEdges = getEdges().coGroup(this.context.fromCollection(edgesToBeRemoved))_				.where(0,1).equalTo(0,1).with(new EdgeRemovalCoGroup<K, EV>())___		return new Graph<K, VV, EV>(this.vertices, newEdges, context)__	};removes,all,the,edges,that,match,the,edges,in,the,given,data,set,from,the,graph,param,edges,to,be,removed,the,list,of,edges,to,be,removed,return,a,new,graph,where,the,edges,have,been,removed,and,in,which,the,vertices,remained,intact;public,graph,k,vv,ev,remove,edges,list,edge,k,ev,edges,to,be,removed,data,set,edge,k,ev,new,edges,get,edges,co,group,this,context,from,collection,edges,to,be,removed,where,0,1,equal,to,0,1,with,new,edge,removal,co,group,k,ev,return,new,graph,k,vv,ev,this,vertices,new,edges,context
Graph -> public Graph<K, VV, EV> removeEdges(List<Edge<K, EV>> edgesToBeRemoved);1462205213;Removes all the edges that match the edges in the given data set from the graph.__@param edgesToBeRemoved the list of edges to be removed_@return a new graph where the edges have been removed and in which the vertices remained intact;public Graph<K, VV, EV> removeEdges(List<Edge<K, EV>> edgesToBeRemoved) {__		DataSet<Edge<K, EV>> newEdges = getEdges().coGroup(this.context.fromCollection(edgesToBeRemoved))_				.where(0,1).equalTo(0,1).with(new EdgeRemovalCoGroup<K, EV>())___		return new Graph<K, VV, EV>(this.vertices, newEdges, context)__	};removes,all,the,edges,that,match,the,edges,in,the,given,data,set,from,the,graph,param,edges,to,be,removed,the,list,of,edges,to,be,removed,return,a,new,graph,where,the,edges,have,been,removed,and,in,which,the,vertices,remained,intact;public,graph,k,vv,ev,remove,edges,list,edge,k,ev,edges,to,be,removed,data,set,edge,k,ev,new,edges,get,edges,co,group,this,context,from,collection,edges,to,be,removed,where,0,1,equal,to,0,1,with,new,edge,removal,co,group,k,ev,return,new,graph,k,vv,ev,this,vertices,new,edges,context
Graph -> public Graph<K, VV, EV> removeEdges(List<Edge<K, EV>> edgesToBeRemoved);1462208859;Removes all the edges that match the edges in the given data set from the graph.__@param edgesToBeRemoved the list of edges to be removed_@return a new graph where the edges have been removed and in which the vertices remained intact;public Graph<K, VV, EV> removeEdges(List<Edge<K, EV>> edgesToBeRemoved) {__		DataSet<Edge<K, EV>> newEdges = getEdges().coGroup(this.context.fromCollection(edgesToBeRemoved))_				.where(0,1).equalTo(0,1).with(new EdgeRemovalCoGroup<K, EV>())___		return new Graph<K, VV, EV>(this.vertices, newEdges, context)__	};removes,all,the,edges,that,match,the,edges,in,the,given,data,set,from,the,graph,param,edges,to,be,removed,the,list,of,edges,to,be,removed,return,a,new,graph,where,the,edges,have,been,removed,and,in,which,the,vertices,remained,intact;public,graph,k,vv,ev,remove,edges,list,edge,k,ev,edges,to,be,removed,data,set,edge,k,ev,new,edges,get,edges,co,group,this,context,from,collection,edges,to,be,removed,where,0,1,equal,to,0,1,with,new,edge,removal,co,group,k,ev,return,new,graph,k,vv,ev,this,vertices,new,edges,context
Graph -> public Graph<K, VV, EV> removeEdges(List<Edge<K, EV>> edgesToBeRemoved);1462809297;Removes all the edges that match the edges in the given data set from the graph.__@param edgesToBeRemoved the list of edges to be removed_@return a new graph where the edges have been removed and in which the vertices remained intact;public Graph<K, VV, EV> removeEdges(List<Edge<K, EV>> edgesToBeRemoved) {__		DataSet<Edge<K, EV>> newEdges = getEdges().coGroup(this.context.fromCollection(edgesToBeRemoved))_				.where(0,1).equalTo(0,1).with(new EdgeRemovalCoGroup<K, EV>())___		return new Graph<K, VV, EV>(this.vertices, newEdges, context)__	};removes,all,the,edges,that,match,the,edges,in,the,given,data,set,from,the,graph,param,edges,to,be,removed,the,list,of,edges,to,be,removed,return,a,new,graph,where,the,edges,have,been,removed,and,in,which,the,vertices,remained,intact;public,graph,k,vv,ev,remove,edges,list,edge,k,ev,edges,to,be,removed,data,set,edge,k,ev,new,edges,get,edges,co,group,this,context,from,collection,edges,to,be,removed,where,0,1,equal,to,0,1,with,new,edge,removal,co,group,k,ev,return,new,graph,k,vv,ev,this,vertices,new,edges,context
Graph -> public Graph<K, VV, EV> removeEdges(List<Edge<K, EV>> edgesToBeRemoved);1465316775;Removes all the edges that match the edges in the given data set from the graph.__@param edgesToBeRemoved the list of edges to be removed_@return a new graph where the edges have been removed and in which the vertices remained intact;public Graph<K, VV, EV> removeEdges(List<Edge<K, EV>> edgesToBeRemoved) {__		DataSet<Edge<K, EV>> newEdges = getEdges().coGroup(this.context.fromCollection(edgesToBeRemoved))_				.where(0,1).equalTo(0,1).with(new EdgeRemovalCoGroup<K, EV>())___		return new Graph<K, VV, EV>(this.vertices, newEdges, context)__	};removes,all,the,edges,that,match,the,edges,in,the,given,data,set,from,the,graph,param,edges,to,be,removed,the,list,of,edges,to,be,removed,return,a,new,graph,where,the,edges,have,been,removed,and,in,which,the,vertices,remained,intact;public,graph,k,vv,ev,remove,edges,list,edge,k,ev,edges,to,be,removed,data,set,edge,k,ev,new,edges,get,edges,co,group,this,context,from,collection,edges,to,be,removed,where,0,1,equal,to,0,1,with,new,edge,removal,co,group,k,ev,return,new,graph,k,vv,ev,this,vertices,new,edges,context
Graph -> public Graph<K, VV, EV> removeEdges(List<Edge<K, EV>> edgesToBeRemoved);1466789678;Removes all the edges that match the edges in the given data set from the graph.__@param edgesToBeRemoved the list of edges to be removed_@return a new graph where the edges have been removed and in which the vertices remained intact;public Graph<K, VV, EV> removeEdges(List<Edge<K, EV>> edgesToBeRemoved) {__		DataSet<Edge<K, EV>> newEdges = getEdges().coGroup(this.context.fromCollection(edgesToBeRemoved))_				.where(0,1).equalTo(0,1).with(new EdgeRemovalCoGroup<K, EV>())___		return new Graph<K, VV, EV>(this.vertices, newEdges, context)__	};removes,all,the,edges,that,match,the,edges,in,the,given,data,set,from,the,graph,param,edges,to,be,removed,the,list,of,edges,to,be,removed,return,a,new,graph,where,the,edges,have,been,removed,and,in,which,the,vertices,remained,intact;public,graph,k,vv,ev,remove,edges,list,edge,k,ev,edges,to,be,removed,data,set,edge,k,ev,new,edges,get,edges,co,group,this,context,from,collection,edges,to,be,removed,where,0,1,equal,to,0,1,with,new,edge,removal,co,group,k,ev,return,new,graph,k,vv,ev,this,vertices,new,edges,context
Graph -> public Graph<K, VV, EV> removeEdges(List<Edge<K, EV>> edgesToBeRemoved);1467140656;Removes all the edges that match the edges in the given data set from the graph.__@param edgesToBeRemoved the list of edges to be removed_@return a new graph where the edges have been removed and in which the vertices remained intact;public Graph<K, VV, EV> removeEdges(List<Edge<K, EV>> edgesToBeRemoved) {__		DataSet<Edge<K, EV>> newEdges = getEdges().coGroup(this.context.fromCollection(edgesToBeRemoved))_				.where(0,1).equalTo(0,1).with(new EdgeRemovalCoGroup<K, EV>())___		return new Graph<K, VV, EV>(this.vertices, newEdges, context)__	};removes,all,the,edges,that,match,the,edges,in,the,given,data,set,from,the,graph,param,edges,to,be,removed,the,list,of,edges,to,be,removed,return,a,new,graph,where,the,edges,have,been,removed,and,in,which,the,vertices,remained,intact;public,graph,k,vv,ev,remove,edges,list,edge,k,ev,edges,to,be,removed,data,set,edge,k,ev,new,edges,get,edges,co,group,this,context,from,collection,edges,to,be,removed,where,0,1,equal,to,0,1,with,new,edge,removal,co,group,k,ev,return,new,graph,k,vv,ev,this,vertices,new,edges,context
Graph -> public Graph<K, VV, EV> removeEdges(List<Edge<K, EV>> edgesToBeRemoved);1467306272;Removes all the edges that match the edges in the given data set from the graph.__@param edgesToBeRemoved the list of edges to be removed_@return a new graph where the edges have been removed and in which the vertices remained intact;public Graph<K, VV, EV> removeEdges(List<Edge<K, EV>> edgesToBeRemoved) {__		DataSet<Edge<K, EV>> newEdges = getEdges().coGroup(this.context.fromCollection(edgesToBeRemoved))_				.where(0,1).equalTo(0,1).with(new EdgeRemovalCoGroup<K, EV>())___		return new Graph<K, VV, EV>(this.vertices, newEdges, context)__	};removes,all,the,edges,that,match,the,edges,in,the,given,data,set,from,the,graph,param,edges,to,be,removed,the,list,of,edges,to,be,removed,return,a,new,graph,where,the,edges,have,been,removed,and,in,which,the,vertices,remained,intact;public,graph,k,vv,ev,remove,edges,list,edge,k,ev,edges,to,be,removed,data,set,edge,k,ev,new,edges,get,edges,co,group,this,context,from,collection,edges,to,be,removed,where,0,1,equal,to,0,1,with,new,edge,removal,co,group,k,ev,return,new,graph,k,vv,ev,this,vertices,new,edges,context
Graph -> public Graph<K, VV, EV> removeEdges(List<Edge<K, EV>> edgesToBeRemoved);1470042815;Removes all the edges that match the edges in the given data set from the graph.__@param edgesToBeRemoved the list of edges to be removed_@return a new graph where the edges have been removed and in which the vertices remained intact;public Graph<K, VV, EV> removeEdges(List<Edge<K, EV>> edgesToBeRemoved) {__		DataSet<Edge<K, EV>> newEdges = getEdges().coGroup(this.context.fromCollection(edgesToBeRemoved))_				.where(0,1).equalTo(0,1).with(new EdgeRemovalCoGroup<K, EV>())___		return new Graph<K, VV, EV>(this.vertices, newEdges, context)__	};removes,all,the,edges,that,match,the,edges,in,the,given,data,set,from,the,graph,param,edges,to,be,removed,the,list,of,edges,to,be,removed,return,a,new,graph,where,the,edges,have,been,removed,and,in,which,the,vertices,remained,intact;public,graph,k,vv,ev,remove,edges,list,edge,k,ev,edges,to,be,removed,data,set,edge,k,ev,new,edges,get,edges,co,group,this,context,from,collection,edges,to,be,removed,where,0,1,equal,to,0,1,with,new,edge,removal,co,group,k,ev,return,new,graph,k,vv,ev,this,vertices,new,edges,context
Graph -> public Graph<K, VV, EV> removeEdges(List<Edge<K, EV>> edgesToBeRemoved);1475684776;Removes all the edges that match the edges in the given data set from the graph.__@param edgesToBeRemoved the list of edges to be removed_@return a new graph where the edges have been removed and in which the vertices remained intact;public Graph<K, VV, EV> removeEdges(List<Edge<K, EV>> edgesToBeRemoved) {__		DataSet<Edge<K, EV>> newEdges = getEdges().coGroup(this.context.fromCollection(edgesToBeRemoved))_				.where(0,1).equalTo(0,1).with(new EdgeRemovalCoGroup<K, EV>())___		return new Graph<>(this.vertices, newEdges, context)__	};removes,all,the,edges,that,match,the,edges,in,the,given,data,set,from,the,graph,param,edges,to,be,removed,the,list,of,edges,to,be,removed,return,a,new,graph,where,the,edges,have,been,removed,and,in,which,the,vertices,remained,intact;public,graph,k,vv,ev,remove,edges,list,edge,k,ev,edges,to,be,removed,data,set,edge,k,ev,new,edges,get,edges,co,group,this,context,from,collection,edges,to,be,removed,where,0,1,equal,to,0,1,with,new,edge,removal,co,group,k,ev,return,new,graph,this,vertices,new,edges,context
Graph -> public Graph<K, VV, EV> removeEdges(List<Edge<K, EV>> edgesToBeRemoved);1475685606;Removes all the edges that match the edges in the given data set from the graph.__@param edgesToBeRemoved the list of edges to be removed_@return a new graph where the edges have been removed and in which the vertices remained intact;public Graph<K, VV, EV> removeEdges(List<Edge<K, EV>> edgesToBeRemoved) {__		DataSet<Edge<K, EV>> newEdges = getEdges().coGroup(this.context.fromCollection(edgesToBeRemoved))_				.where(0,1).equalTo(0,1).with(new EdgeRemovalCoGroup<K, EV>())___		return new Graph<>(this.vertices, newEdges, context)__	};removes,all,the,edges,that,match,the,edges,in,the,given,data,set,from,the,graph,param,edges,to,be,removed,the,list,of,edges,to,be,removed,return,a,new,graph,where,the,edges,have,been,removed,and,in,which,the,vertices,remained,intact;public,graph,k,vv,ev,remove,edges,list,edge,k,ev,edges,to,be,removed,data,set,edge,k,ev,new,edges,get,edges,co,group,this,context,from,collection,edges,to,be,removed,where,0,1,equal,to,0,1,with,new,edge,removal,co,group,k,ev,return,new,graph,this,vertices,new,edges,context
Graph -> public Graph<K, VV, EV> removeEdges(List<Edge<K, EV>> edgesToBeRemoved);1481745825;Removes all the edges that match the edges in the given data set from the graph.__@param edgesToBeRemoved the list of edges to be removed_@return a new graph where the edges have been removed and in which the vertices remained intact;public Graph<K, VV, EV> removeEdges(List<Edge<K, EV>> edgesToBeRemoved) {__		DataSet<Edge<K, EV>> newEdges = getEdges().coGroup(this.context.fromCollection(edgesToBeRemoved))_				.where(0,1).equalTo(0,1).with(new EdgeRemovalCoGroup<K, EV>()).name("Remove edges")___		return new Graph<>(this.vertices, newEdges, context)__	};removes,all,the,edges,that,match,the,edges,in,the,given,data,set,from,the,graph,param,edges,to,be,removed,the,list,of,edges,to,be,removed,return,a,new,graph,where,the,edges,have,been,removed,and,in,which,the,vertices,remained,intact;public,graph,k,vv,ev,remove,edges,list,edge,k,ev,edges,to,be,removed,data,set,edge,k,ev,new,edges,get,edges,co,group,this,context,from,collection,edges,to,be,removed,where,0,1,equal,to,0,1,with,new,edge,removal,co,group,k,ev,name,remove,edges,return,new,graph,this,vertices,new,edges,context
Graph -> public Graph<K, VV, EV> removeEdges(List<Edge<K, EV>> edgesToBeRemoved);1481881009;Removes all the edges that match the edges in the given data set from the graph.__@param edgesToBeRemoved the list of edges to be removed_@return a new graph where the edges have been removed and in which the vertices remained intact;public Graph<K, VV, EV> removeEdges(List<Edge<K, EV>> edgesToBeRemoved) {__		DataSet<Edge<K, EV>> newEdges = getEdges().coGroup(this.context.fromCollection(edgesToBeRemoved))_				.where(0,1).equalTo(0,1).with(new EdgeRemovalCoGroup<K, EV>()).name("Remove edges")___		return new Graph<>(this.vertices, newEdges, context)__	};removes,all,the,edges,that,match,the,edges,in,the,given,data,set,from,the,graph,param,edges,to,be,removed,the,list,of,edges,to,be,removed,return,a,new,graph,where,the,edges,have,been,removed,and,in,which,the,vertices,remained,intact;public,graph,k,vv,ev,remove,edges,list,edge,k,ev,edges,to,be,removed,data,set,edge,k,ev,new,edges,get,edges,co,group,this,context,from,collection,edges,to,be,removed,where,0,1,equal,to,0,1,with,new,edge,removal,co,group,k,ev,name,remove,edges,return,new,graph,this,vertices,new,edges,context
Graph -> public Graph<K, VV, EV> removeEdges(List<Edge<K, EV>> edgesToBeRemoved);1484160227;Removes all the edges that match the edges in the given data set from the graph.__@param edgesToBeRemoved the list of edges to be removed_@return a new graph where the edges have been removed and in which the vertices remained intact;public Graph<K, VV, EV> removeEdges(List<Edge<K, EV>> edgesToBeRemoved) {__		DataSet<Edge<K, EV>> newEdges = getEdges().coGroup(this.context.fromCollection(edgesToBeRemoved))_				.where(0,1).equalTo(0,1).with(new EdgeRemovalCoGroup<K, EV>()).name("Remove edges")___		return new Graph<>(this.vertices, newEdges, context)__	};removes,all,the,edges,that,match,the,edges,in,the,given,data,set,from,the,graph,param,edges,to,be,removed,the,list,of,edges,to,be,removed,return,a,new,graph,where,the,edges,have,been,removed,and,in,which,the,vertices,remained,intact;public,graph,k,vv,ev,remove,edges,list,edge,k,ev,edges,to,be,removed,data,set,edge,k,ev,new,edges,get,edges,co,group,this,context,from,collection,edges,to,be,removed,where,0,1,equal,to,0,1,with,new,edge,removal,co,group,k,ev,name,remove,edges,return,new,graph,this,vertices,new,edges,context
Graph -> public Graph<K, VV, EV> removeEdges(List<Edge<K, EV>> edgesToBeRemoved);1484685504;Removes all the edges that match the edges in the given data set from the graph.__@param edgesToBeRemoved the list of edges to be removed_@return a new graph where the edges have been removed and in which the vertices remained intact;public Graph<K, VV, EV> removeEdges(List<Edge<K, EV>> edgesToBeRemoved) {__		DataSet<Edge<K, EV>> newEdges = getEdges().coGroup(this.context.fromCollection(edgesToBeRemoved))_				.where(0, 1).equalTo(0, 1).with(new EdgeRemovalCoGroup<K, EV>()).name("Remove edges")___		return new Graph<>(this.vertices, newEdges, context)__	};removes,all,the,edges,that,match,the,edges,in,the,given,data,set,from,the,graph,param,edges,to,be,removed,the,list,of,edges,to,be,removed,return,a,new,graph,where,the,edges,have,been,removed,and,in,which,the,vertices,remained,intact;public,graph,k,vv,ev,remove,edges,list,edge,k,ev,edges,to,be,removed,data,set,edge,k,ev,new,edges,get,edges,co,group,this,context,from,collection,edges,to,be,removed,where,0,1,equal,to,0,1,with,new,edge,removal,co,group,k,ev,name,remove,edges,return,new,graph,this,vertices,new,edges,context
Graph -> public Graph<K, VV, EV> removeEdges(List<Edge<K, EV>> edgesToBeRemoved);1489068942;Removes all the edges that match the edges in the given data set from the graph.__@param edgesToBeRemoved the list of edges to be removed_@return a new graph where the edges have been removed and in which the vertices remained intact;public Graph<K, VV, EV> removeEdges(List<Edge<K, EV>> edgesToBeRemoved) {__		DataSet<Edge<K, EV>> newEdges = getEdges().coGroup(this.context.fromCollection(edgesToBeRemoved))_				.where(0, 1).equalTo(0, 1).with(new EdgeRemovalCoGroup<K, EV>()).name("Remove edges")___		return new Graph<>(this.vertices, newEdges, context)__	};removes,all,the,edges,that,match,the,edges,in,the,given,data,set,from,the,graph,param,edges,to,be,removed,the,list,of,edges,to,be,removed,return,a,new,graph,where,the,edges,have,been,removed,and,in,which,the,vertices,remained,intact;public,graph,k,vv,ev,remove,edges,list,edge,k,ev,edges,to,be,removed,data,set,edge,k,ev,new,edges,get,edges,co,group,this,context,from,collection,edges,to,be,removed,where,0,1,equal,to,0,1,with,new,edge,removal,co,group,k,ev,name,remove,edges,return,new,graph,this,vertices,new,edges,context
Graph -> public Graph<K, VV, EV> removeEdges(List<Edge<K, EV>> edgesToBeRemoved);1490973446;Removes all the edges that match the edges in the given data set from the graph.__@param edgesToBeRemoved the list of edges to be removed_@return a new graph where the edges have been removed and in which the vertices remained intact;public Graph<K, VV, EV> removeEdges(List<Edge<K, EV>> edgesToBeRemoved) {__		DataSet<Edge<K, EV>> newEdges = getEdges().coGroup(this.context.fromCollection(edgesToBeRemoved))_				.where(0, 1).equalTo(0, 1).with(new EdgeRemovalCoGroup<K, EV>()).name("Remove edges")___		return new Graph<>(this.vertices, newEdges, context)__	};removes,all,the,edges,that,match,the,edges,in,the,given,data,set,from,the,graph,param,edges,to,be,removed,the,list,of,edges,to,be,removed,return,a,new,graph,where,the,edges,have,been,removed,and,in,which,the,vertices,remained,intact;public,graph,k,vv,ev,remove,edges,list,edge,k,ev,edges,to,be,removed,data,set,edge,k,ev,new,edges,get,edges,co,group,this,context,from,collection,edges,to,be,removed,where,0,1,equal,to,0,1,with,new,edge,removal,co,group,k,ev,name,remove,edges,return,new,graph,this,vertices,new,edges,context
Graph -> public Graph<K, VV, EV> removeEdges(List<Edge<K, EV>> edgesToBeRemoved);1495819075;Removes all the edges that match the edges in the given data set from the graph.__@param edgesToBeRemoved the list of edges to be removed_@return a new graph where the edges have been removed and in which the vertices remained intact;public Graph<K, VV, EV> removeEdges(List<Edge<K, EV>> edgesToBeRemoved) {__		DataSet<Edge<K, EV>> newEdges = getEdges().coGroup(this.context.fromCollection(edgesToBeRemoved))_				.where(0, 1).equalTo(0, 1).with(new EdgeRemovalCoGroup<K, EV>()).name("Remove edges")___		return new Graph<>(this.vertices, newEdges, context)__	};removes,all,the,edges,that,match,the,edges,in,the,given,data,set,from,the,graph,param,edges,to,be,removed,the,list,of,edges,to,be,removed,return,a,new,graph,where,the,edges,have,been,removed,and,in,which,the,vertices,remained,intact;public,graph,k,vv,ev,remove,edges,list,edge,k,ev,edges,to,be,removed,data,set,edge,k,ev,new,edges,get,edges,co,group,this,context,from,collection,edges,to,be,removed,where,0,1,equal,to,0,1,with,new,edge,removal,co,group,k,ev,name,remove,edges,return,new,graph,this,vertices,new,edges,context
Graph -> public Graph<K, VV, EV> removeEdges(List<Edge<K, EV>> edgesToBeRemoved);1502111816;Removes all the edges that match the edges in the given data set from the graph.__@param edgesToBeRemoved the list of edges to be removed_@return a new graph where the edges have been removed and in which the vertices remained intact;public Graph<K, VV, EV> removeEdges(List<Edge<K, EV>> edgesToBeRemoved) {__		DataSet<Edge<K, EV>> newEdges = getEdges().coGroup(this.context.fromCollection(edgesToBeRemoved))_				.where(0, 1).equalTo(0, 1).with(new EdgeRemovalCoGroup<>()).name("Remove edges")___		return new Graph<>(this.vertices, newEdges, context)__	};removes,all,the,edges,that,match,the,edges,in,the,given,data,set,from,the,graph,param,edges,to,be,removed,the,list,of,edges,to,be,removed,return,a,new,graph,where,the,edges,have,been,removed,and,in,which,the,vertices,remained,intact;public,graph,k,vv,ev,remove,edges,list,edge,k,ev,edges,to,be,removed,data,set,edge,k,ev,new,edges,get,edges,co,group,this,context,from,collection,edges,to,be,removed,where,0,1,equal,to,0,1,with,new,edge,removal,co,group,name,remove,edges,return,new,graph,this,vertices,new,edges,context
Graph -> public Graph<K, VV, EV> addVertices(List<Vertex<K, VV>> verticesToAdd);1444404795;Adds the list of vertices, passed as input, to the graph._If the vertices already exist in the graph, they will not be added once more.__@param verticesToAdd the list of vertices to add_@return the new graph containing the existing and newly added vertices;public Graph<K, VV, EV> addVertices(List<Vertex<K, VV>> verticesToAdd) {_		_		DataSet<Vertex<K, VV>> newVertices = this.vertices.union(this.context.fromCollection(verticesToAdd)).distinct()___		return new Graph<K, VV, EV>(newVertices, this.edges, this.context)__	};adds,the,list,of,vertices,passed,as,input,to,the,graph,if,the,vertices,already,exist,in,the,graph,they,will,not,be,added,once,more,param,vertices,to,add,the,list,of,vertices,to,add,return,the,new,graph,containing,the,existing,and,newly,added,vertices;public,graph,k,vv,ev,add,vertices,list,vertex,k,vv,vertices,to,add,data,set,vertex,k,vv,new,vertices,this,vertices,union,this,context,from,collection,vertices,to,add,distinct,return,new,graph,k,vv,ev,new,vertices,this,edges,this,context
Graph -> public Graph<K, VV, EV> addVertices(List<Vertex<K, VV>> verticesToAdd);1445261977;Adds the list of vertices, passed as input, to the graph._If the vertices already exist in the graph, they will not be added once more.__@param verticesToAdd the list of vertices to add_@return the new graph containing the existing and newly added vertices;public Graph<K, VV, EV> addVertices(List<Vertex<K, VV>> verticesToAdd) {_		_		DataSet<Vertex<K, VV>> newVertices = this.vertices.union(this.context.fromCollection(verticesToAdd)).distinct()___		return new Graph<K, VV, EV>(newVertices, this.edges, this.context)__	};adds,the,list,of,vertices,passed,as,input,to,the,graph,if,the,vertices,already,exist,in,the,graph,they,will,not,be,added,once,more,param,vertices,to,add,the,list,of,vertices,to,add,return,the,new,graph,containing,the,existing,and,newly,added,vertices;public,graph,k,vv,ev,add,vertices,list,vertex,k,vv,vertices,to,add,data,set,vertex,k,vv,new,vertices,this,vertices,union,this,context,from,collection,vertices,to,add,distinct,return,new,graph,k,vv,ev,new,vertices,this,edges,this,context
Graph -> public Graph<K, VV, EV> addVertices(List<Vertex<K, VV>> verticesToAdd);1445854323;Adds the list of vertices, passed as input, to the graph._If the vertices already exist in the graph, they will not be added once more.__@param verticesToAdd the list of vertices to add_@return the new graph containing the existing and newly added vertices;public Graph<K, VV, EV> addVertices(List<Vertex<K, VV>> verticesToAdd) {_		_		DataSet<Vertex<K, VV>> newVertices = this.vertices.union(this.context.fromCollection(verticesToAdd)).distinct()___		return new Graph<K, VV, EV>(newVertices, this.edges, this.context)__	};adds,the,list,of,vertices,passed,as,input,to,the,graph,if,the,vertices,already,exist,in,the,graph,they,will,not,be,added,once,more,param,vertices,to,add,the,list,of,vertices,to,add,return,the,new,graph,containing,the,existing,and,newly,added,vertices;public,graph,k,vv,ev,add,vertices,list,vertex,k,vv,vertices,to,add,data,set,vertex,k,vv,new,vertices,this,vertices,union,this,context,from,collection,vertices,to,add,distinct,return,new,graph,k,vv,ev,new,vertices,this,edges,this,context
Graph -> public Graph<K, VV, EV> addVertices(List<Vertex<K, VV>> verticesToAdd);1446112342;Adds the list of vertices, passed as input, to the graph._If the vertices already exist in the graph, they will not be added once more.__@param verticesToAdd the list of vertices to add_@return the new graph containing the existing and newly added vertices;public Graph<K, VV, EV> addVertices(List<Vertex<K, VV>> verticesToAdd) {_		_		DataSet<Vertex<K, VV>> newVertices = this.vertices.union(this.context.fromCollection(verticesToAdd)).distinct()___		return new Graph<K, VV, EV>(newVertices, this.edges, this.context)__	};adds,the,list,of,vertices,passed,as,input,to,the,graph,if,the,vertices,already,exist,in,the,graph,they,will,not,be,added,once,more,param,vertices,to,add,the,list,of,vertices,to,add,return,the,new,graph,containing,the,existing,and,newly,added,vertices;public,graph,k,vv,ev,add,vertices,list,vertex,k,vv,vertices,to,add,data,set,vertex,k,vv,new,vertices,this,vertices,union,this,context,from,collection,vertices,to,add,distinct,return,new,graph,k,vv,ev,new,vertices,this,edges,this,context
Graph -> public Graph<K, VV, EV> addVertices(List<Vertex<K, VV>> verticesToAdd);1447073368;Adds the list of vertices, passed as input, to the graph._If the vertices already exist in the graph, they will not be added once more.__@param verticesToAdd the list of vertices to add_@return the new graph containing the existing and newly added vertices;public Graph<K, VV, EV> addVertices(List<Vertex<K, VV>> verticesToAdd) {_		_		DataSet<Vertex<K, VV>> newVertices = this.vertices.union(this.context.fromCollection(verticesToAdd)).distinct()___		return new Graph<K, VV, EV>(newVertices, this.edges, this.context)__	};adds,the,list,of,vertices,passed,as,input,to,the,graph,if,the,vertices,already,exist,in,the,graph,they,will,not,be,added,once,more,param,vertices,to,add,the,list,of,vertices,to,add,return,the,new,graph,containing,the,existing,and,newly,added,vertices;public,graph,k,vv,ev,add,vertices,list,vertex,k,vv,vertices,to,add,data,set,vertex,k,vv,new,vertices,this,vertices,union,this,context,from,collection,vertices,to,add,distinct,return,new,graph,k,vv,ev,new,vertices,this,edges,this,context
Graph -> public Graph<K, VV, EV> addVertices(List<Vertex<K, VV>> verticesToAdd);1454404649;Adds the list of vertices, passed as input, to the graph._If the vertices already exist in the graph, they will not be added once more.__@param verticesToAdd the list of vertices to add_@return the new graph containing the existing and newly added vertices;public Graph<K, VV, EV> addVertices(List<Vertex<K, VV>> verticesToAdd) {_		_		DataSet<Vertex<K, VV>> newVertices = this.vertices.union(this.context.fromCollection(verticesToAdd)).distinct()___		return new Graph<K, VV, EV>(newVertices, this.edges, this.context)__	};adds,the,list,of,vertices,passed,as,input,to,the,graph,if,the,vertices,already,exist,in,the,graph,they,will,not,be,added,once,more,param,vertices,to,add,the,list,of,vertices,to,add,return,the,new,graph,containing,the,existing,and,newly,added,vertices;public,graph,k,vv,ev,add,vertices,list,vertex,k,vv,vertices,to,add,data,set,vertex,k,vv,new,vertices,this,vertices,union,this,context,from,collection,vertices,to,add,distinct,return,new,graph,k,vv,ev,new,vertices,this,edges,this,context
Graph -> public Graph<K, VV, EV> addVertices(List<Vertex<K, VV>> verticesToAdd);1458583829;Adds the list of vertices, passed as input, to the graph._If the vertices already exist in the graph, they will not be added once more.__@param verticesToAdd the list of vertices to add_@return the new graph containing the existing and newly added vertices;public Graph<K, VV, EV> addVertices(List<Vertex<K, VV>> verticesToAdd) {_		_		DataSet<Vertex<K, VV>> newVertices = this.vertices.union(this.context.fromCollection(verticesToAdd)).distinct()___		return new Graph<K, VV, EV>(newVertices, this.edges, this.context)__	};adds,the,list,of,vertices,passed,as,input,to,the,graph,if,the,vertices,already,exist,in,the,graph,they,will,not,be,added,once,more,param,vertices,to,add,the,list,of,vertices,to,add,return,the,new,graph,containing,the,existing,and,newly,added,vertices;public,graph,k,vv,ev,add,vertices,list,vertex,k,vv,vertices,to,add,data,set,vertex,k,vv,new,vertices,this,vertices,union,this,context,from,collection,vertices,to,add,distinct,return,new,graph,k,vv,ev,new,vertices,this,edges,this,context
Graph -> public Graph<K, VV, EV> addVertices(List<Vertex<K, VV>> verticesToAdd);1458583829;Adds the list of vertices, passed as input, to the graph._If the vertices already exist in the graph, they will not be added once more.__@param verticesToAdd the list of vertices to add_@return the new graph containing the existing and newly added vertices;public Graph<K, VV, EV> addVertices(List<Vertex<K, VV>> verticesToAdd) {_		_		DataSet<Vertex<K, VV>> newVertices = this.vertices.union(this.context.fromCollection(verticesToAdd)).distinct()___		return new Graph<K, VV, EV>(newVertices, this.edges, this.context)__	};adds,the,list,of,vertices,passed,as,input,to,the,graph,if,the,vertices,already,exist,in,the,graph,they,will,not,be,added,once,more,param,vertices,to,add,the,list,of,vertices,to,add,return,the,new,graph,containing,the,existing,and,newly,added,vertices;public,graph,k,vv,ev,add,vertices,list,vertex,k,vv,vertices,to,add,data,set,vertex,k,vv,new,vertices,this,vertices,union,this,context,from,collection,vertices,to,add,distinct,return,new,graph,k,vv,ev,new,vertices,this,edges,this,context
Graph -> public Graph<K, VV, EV> addVertices(List<Vertex<K, VV>> verticesToAdd);1462100316;Adds the list of vertices, passed as input, to the graph._If the vertices already exist in the graph, they will not be added once more.__@param verticesToAdd the list of vertices to add_@return the new graph containing the existing and newly added vertices;public Graph<K, VV, EV> addVertices(List<Vertex<K, VV>> verticesToAdd) {_		_		DataSet<Vertex<K, VV>> newVertices = this.vertices.union(this.context.fromCollection(verticesToAdd)).distinct()___		return new Graph<K, VV, EV>(newVertices, this.edges, this.context)__	};adds,the,list,of,vertices,passed,as,input,to,the,graph,if,the,vertices,already,exist,in,the,graph,they,will,not,be,added,once,more,param,vertices,to,add,the,list,of,vertices,to,add,return,the,new,graph,containing,the,existing,and,newly,added,vertices;public,graph,k,vv,ev,add,vertices,list,vertex,k,vv,vertices,to,add,data,set,vertex,k,vv,new,vertices,this,vertices,union,this,context,from,collection,vertices,to,add,distinct,return,new,graph,k,vv,ev,new,vertices,this,edges,this,context
Graph -> public Graph<K, VV, EV> addVertices(List<Vertex<K, VV>> verticesToAdd);1462100316;Adds the list of vertices, passed as input, to the graph._If the vertices already exist in the graph, they will not be added once more.__@param verticesToAdd the list of vertices to add_@return the new graph containing the existing and newly added vertices;public Graph<K, VV, EV> addVertices(List<Vertex<K, VV>> verticesToAdd) {_		_		DataSet<Vertex<K, VV>> newVertices = this.vertices.union(this.context.fromCollection(verticesToAdd)).distinct()___		return new Graph<K, VV, EV>(newVertices, this.edges, this.context)__	};adds,the,list,of,vertices,passed,as,input,to,the,graph,if,the,vertices,already,exist,in,the,graph,they,will,not,be,added,once,more,param,vertices,to,add,the,list,of,vertices,to,add,return,the,new,graph,containing,the,existing,and,newly,added,vertices;public,graph,k,vv,ev,add,vertices,list,vertex,k,vv,vertices,to,add,data,set,vertex,k,vv,new,vertices,this,vertices,union,this,context,from,collection,vertices,to,add,distinct,return,new,graph,k,vv,ev,new,vertices,this,edges,this,context
Graph -> public Graph<K, VV, EV> addVertices(List<Vertex<K, VV>> verticesToAdd);1462205213;Adds the list of vertices, passed as input, to the graph._If the vertices already exist in the graph, they will not be added once more.__@param verticesToAdd the list of vertices to add_@return the new graph containing the existing and newly added vertices;public Graph<K, VV, EV> addVertices(List<Vertex<K, VV>> verticesToAdd) {_		_		DataSet<Vertex<K, VV>> newVertices = this.vertices.union(this.context.fromCollection(verticesToAdd)).distinct()___		return new Graph<K, VV, EV>(newVertices, this.edges, this.context)__	};adds,the,list,of,vertices,passed,as,input,to,the,graph,if,the,vertices,already,exist,in,the,graph,they,will,not,be,added,once,more,param,vertices,to,add,the,list,of,vertices,to,add,return,the,new,graph,containing,the,existing,and,newly,added,vertices;public,graph,k,vv,ev,add,vertices,list,vertex,k,vv,vertices,to,add,data,set,vertex,k,vv,new,vertices,this,vertices,union,this,context,from,collection,vertices,to,add,distinct,return,new,graph,k,vv,ev,new,vertices,this,edges,this,context
Graph -> public Graph<K, VV, EV> addVertices(List<Vertex<K, VV>> verticesToAdd);1462208859;Adds the list of vertices, passed as input, to the graph._If the vertices already exist in the graph, they will not be added once more.__@param verticesToAdd the list of vertices to add_@return the new graph containing the existing and newly added vertices;public Graph<K, VV, EV> addVertices(List<Vertex<K, VV>> verticesToAdd) {_		_		DataSet<Vertex<K, VV>> newVertices = this.vertices.coGroup(this.context.fromCollection(verticesToAdd))_				.where(0).equalTo(0).with(new VerticesUnionCoGroup<K, VV>())___		return new Graph<>(newVertices, this.edges, this.context)__	};adds,the,list,of,vertices,passed,as,input,to,the,graph,if,the,vertices,already,exist,in,the,graph,they,will,not,be,added,once,more,param,vertices,to,add,the,list,of,vertices,to,add,return,the,new,graph,containing,the,existing,and,newly,added,vertices;public,graph,k,vv,ev,add,vertices,list,vertex,k,vv,vertices,to,add,data,set,vertex,k,vv,new,vertices,this,vertices,co,group,this,context,from,collection,vertices,to,add,where,0,equal,to,0,with,new,vertices,union,co,group,k,vv,return,new,graph,new,vertices,this,edges,this,context
Graph -> public Graph<K, VV, EV> addVertices(List<Vertex<K, VV>> verticesToAdd);1462809297;Adds the list of vertices, passed as input, to the graph._If the vertices already exist in the graph, they will not be added once more.__@param verticesToAdd the list of vertices to add_@return the new graph containing the existing and newly added vertices;public Graph<K, VV, EV> addVertices(List<Vertex<K, VV>> verticesToAdd) {_		_		DataSet<Vertex<K, VV>> newVertices = this.vertices.coGroup(this.context.fromCollection(verticesToAdd))_				.where(0).equalTo(0).with(new VerticesUnionCoGroup<K, VV>())___		return new Graph<>(newVertices, this.edges, this.context)__	};adds,the,list,of,vertices,passed,as,input,to,the,graph,if,the,vertices,already,exist,in,the,graph,they,will,not,be,added,once,more,param,vertices,to,add,the,list,of,vertices,to,add,return,the,new,graph,containing,the,existing,and,newly,added,vertices;public,graph,k,vv,ev,add,vertices,list,vertex,k,vv,vertices,to,add,data,set,vertex,k,vv,new,vertices,this,vertices,co,group,this,context,from,collection,vertices,to,add,where,0,equal,to,0,with,new,vertices,union,co,group,k,vv,return,new,graph,new,vertices,this,edges,this,context
Graph -> public Graph<K, VV, EV> addVertices(List<Vertex<K, VV>> verticesToAdd);1465316775;Adds the list of vertices, passed as input, to the graph._If the vertices already exist in the graph, they will not be added once more.__@param verticesToAdd the list of vertices to add_@return the new graph containing the existing and newly added vertices;public Graph<K, VV, EV> addVertices(List<Vertex<K, VV>> verticesToAdd) {_		_		DataSet<Vertex<K, VV>> newVertices = this.vertices.coGroup(this.context.fromCollection(verticesToAdd))_				.where(0).equalTo(0).with(new VerticesUnionCoGroup<K, VV>())___		return new Graph<>(newVertices, this.edges, this.context)__	};adds,the,list,of,vertices,passed,as,input,to,the,graph,if,the,vertices,already,exist,in,the,graph,they,will,not,be,added,once,more,param,vertices,to,add,the,list,of,vertices,to,add,return,the,new,graph,containing,the,existing,and,newly,added,vertices;public,graph,k,vv,ev,add,vertices,list,vertex,k,vv,vertices,to,add,data,set,vertex,k,vv,new,vertices,this,vertices,co,group,this,context,from,collection,vertices,to,add,where,0,equal,to,0,with,new,vertices,union,co,group,k,vv,return,new,graph,new,vertices,this,edges,this,context
Graph -> public Graph<K, VV, EV> addVertices(List<Vertex<K, VV>> verticesToAdd);1466789678;Adds the list of vertices, passed as input, to the graph._If the vertices already exist in the graph, they will not be added once more.__@param verticesToAdd the list of vertices to add_@return the new graph containing the existing and newly added vertices;public Graph<K, VV, EV> addVertices(List<Vertex<K, VV>> verticesToAdd) {_		_		DataSet<Vertex<K, VV>> newVertices = this.vertices.coGroup(this.context.fromCollection(verticesToAdd))_				.where(0).equalTo(0).with(new VerticesUnionCoGroup<K, VV>())___		return new Graph<>(newVertices, this.edges, this.context)__	};adds,the,list,of,vertices,passed,as,input,to,the,graph,if,the,vertices,already,exist,in,the,graph,they,will,not,be,added,once,more,param,vertices,to,add,the,list,of,vertices,to,add,return,the,new,graph,containing,the,existing,and,newly,added,vertices;public,graph,k,vv,ev,add,vertices,list,vertex,k,vv,vertices,to,add,data,set,vertex,k,vv,new,vertices,this,vertices,co,group,this,context,from,collection,vertices,to,add,where,0,equal,to,0,with,new,vertices,union,co,group,k,vv,return,new,graph,new,vertices,this,edges,this,context
Graph -> public Graph<K, VV, EV> addVertices(List<Vertex<K, VV>> verticesToAdd);1467140656;Adds the list of vertices, passed as input, to the graph._If the vertices already exist in the graph, they will not be added once more.__@param verticesToAdd the list of vertices to add_@return the new graph containing the existing and newly added vertices;public Graph<K, VV, EV> addVertices(List<Vertex<K, VV>> verticesToAdd) {_		_		DataSet<Vertex<K, VV>> newVertices = this.vertices.coGroup(this.context.fromCollection(verticesToAdd))_				.where(0).equalTo(0).with(new VerticesUnionCoGroup<K, VV>())___		return new Graph<>(newVertices, this.edges, this.context)__	};adds,the,list,of,vertices,passed,as,input,to,the,graph,if,the,vertices,already,exist,in,the,graph,they,will,not,be,added,once,more,param,vertices,to,add,the,list,of,vertices,to,add,return,the,new,graph,containing,the,existing,and,newly,added,vertices;public,graph,k,vv,ev,add,vertices,list,vertex,k,vv,vertices,to,add,data,set,vertex,k,vv,new,vertices,this,vertices,co,group,this,context,from,collection,vertices,to,add,where,0,equal,to,0,with,new,vertices,union,co,group,k,vv,return,new,graph,new,vertices,this,edges,this,context
Graph -> public Graph<K, VV, EV> addVertices(List<Vertex<K, VV>> verticesToAdd);1467306272;Adds the list of vertices, passed as input, to the graph._If the vertices already exist in the graph, they will not be added once more.__@param verticesToAdd the list of vertices to add_@return the new graph containing the existing and newly added vertices;public Graph<K, VV, EV> addVertices(List<Vertex<K, VV>> verticesToAdd) {_		_		DataSet<Vertex<K, VV>> newVertices = this.vertices.coGroup(this.context.fromCollection(verticesToAdd))_				.where(0).equalTo(0).with(new VerticesUnionCoGroup<K, VV>())___		return new Graph<>(newVertices, this.edges, this.context)__	};adds,the,list,of,vertices,passed,as,input,to,the,graph,if,the,vertices,already,exist,in,the,graph,they,will,not,be,added,once,more,param,vertices,to,add,the,list,of,vertices,to,add,return,the,new,graph,containing,the,existing,and,newly,added,vertices;public,graph,k,vv,ev,add,vertices,list,vertex,k,vv,vertices,to,add,data,set,vertex,k,vv,new,vertices,this,vertices,co,group,this,context,from,collection,vertices,to,add,where,0,equal,to,0,with,new,vertices,union,co,group,k,vv,return,new,graph,new,vertices,this,edges,this,context
Graph -> public Graph<K, VV, EV> addVertices(List<Vertex<K, VV>> verticesToAdd);1470042815;Adds the list of vertices, passed as input, to the graph._If the vertices already exist in the graph, they will not be added once more.__@param verticesToAdd the list of vertices to add_@return the new graph containing the existing and newly added vertices;public Graph<K, VV, EV> addVertices(List<Vertex<K, VV>> verticesToAdd) {_		_		DataSet<Vertex<K, VV>> newVertices = this.vertices.coGroup(this.context.fromCollection(verticesToAdd))_				.where(0).equalTo(0).with(new VerticesUnionCoGroup<K, VV>())___		return new Graph<>(newVertices, this.edges, this.context)__	};adds,the,list,of,vertices,passed,as,input,to,the,graph,if,the,vertices,already,exist,in,the,graph,they,will,not,be,added,once,more,param,vertices,to,add,the,list,of,vertices,to,add,return,the,new,graph,containing,the,existing,and,newly,added,vertices;public,graph,k,vv,ev,add,vertices,list,vertex,k,vv,vertices,to,add,data,set,vertex,k,vv,new,vertices,this,vertices,co,group,this,context,from,collection,vertices,to,add,where,0,equal,to,0,with,new,vertices,union,co,group,k,vv,return,new,graph,new,vertices,this,edges,this,context
Graph -> public Graph<K, VV, EV> addVertices(List<Vertex<K, VV>> verticesToAdd);1475684776;Adds the list of vertices, passed as input, to the graph._If the vertices already exist in the graph, they will not be added once more.__@param verticesToAdd the list of vertices to add_@return the new graph containing the existing and newly added vertices;public Graph<K, VV, EV> addVertices(List<Vertex<K, VV>> verticesToAdd) {_		_		DataSet<Vertex<K, VV>> newVertices = this.vertices.coGroup(this.context.fromCollection(verticesToAdd))_				.where(0).equalTo(0).with(new VerticesUnionCoGroup<K, VV>())___		return new Graph<>(newVertices, this.edges, this.context)__	};adds,the,list,of,vertices,passed,as,input,to,the,graph,if,the,vertices,already,exist,in,the,graph,they,will,not,be,added,once,more,param,vertices,to,add,the,list,of,vertices,to,add,return,the,new,graph,containing,the,existing,and,newly,added,vertices;public,graph,k,vv,ev,add,vertices,list,vertex,k,vv,vertices,to,add,data,set,vertex,k,vv,new,vertices,this,vertices,co,group,this,context,from,collection,vertices,to,add,where,0,equal,to,0,with,new,vertices,union,co,group,k,vv,return,new,graph,new,vertices,this,edges,this,context
Graph -> public Graph<K, VV, EV> addVertices(List<Vertex<K, VV>> verticesToAdd);1475685606;Adds the list of vertices, passed as input, to the graph._If the vertices already exist in the graph, they will not be added once more.__@param verticesToAdd the list of vertices to add_@return the new graph containing the existing and newly added vertices;public Graph<K, VV, EV> addVertices(List<Vertex<K, VV>> verticesToAdd) {_		_		DataSet<Vertex<K, VV>> newVertices = this.vertices.coGroup(this.context.fromCollection(verticesToAdd))_				.where(0).equalTo(0).with(new VerticesUnionCoGroup<K, VV>())___		return new Graph<>(newVertices, this.edges, this.context)__	};adds,the,list,of,vertices,passed,as,input,to,the,graph,if,the,vertices,already,exist,in,the,graph,they,will,not,be,added,once,more,param,vertices,to,add,the,list,of,vertices,to,add,return,the,new,graph,containing,the,existing,and,newly,added,vertices;public,graph,k,vv,ev,add,vertices,list,vertex,k,vv,vertices,to,add,data,set,vertex,k,vv,new,vertices,this,vertices,co,group,this,context,from,collection,vertices,to,add,where,0,equal,to,0,with,new,vertices,union,co,group,k,vv,return,new,graph,new,vertices,this,edges,this,context
Graph -> public Graph<K, VV, EV> addVertices(List<Vertex<K, VV>> verticesToAdd);1481745825;Adds the list of vertices, passed as input, to the graph._If the vertices already exist in the graph, they will not be added once more.__@param verticesToAdd the list of vertices to add_@return the new graph containing the existing and newly added vertices;public Graph<K, VV, EV> addVertices(List<Vertex<K, VV>> verticesToAdd) {_		_		DataSet<Vertex<K, VV>> newVertices = this.vertices.coGroup(this.context.fromCollection(verticesToAdd))_				.where(0).equalTo(0).with(new VerticesUnionCoGroup<K, VV>()).name("Add vertices")___		return new Graph<>(newVertices, this.edges, this.context)__	};adds,the,list,of,vertices,passed,as,input,to,the,graph,if,the,vertices,already,exist,in,the,graph,they,will,not,be,added,once,more,param,vertices,to,add,the,list,of,vertices,to,add,return,the,new,graph,containing,the,existing,and,newly,added,vertices;public,graph,k,vv,ev,add,vertices,list,vertex,k,vv,vertices,to,add,data,set,vertex,k,vv,new,vertices,this,vertices,co,group,this,context,from,collection,vertices,to,add,where,0,equal,to,0,with,new,vertices,union,co,group,k,vv,name,add,vertices,return,new,graph,new,vertices,this,edges,this,context
Graph -> public Graph<K, VV, EV> addVertices(List<Vertex<K, VV>> verticesToAdd);1481881009;Adds the list of vertices, passed as input, to the graph._If the vertices already exist in the graph, they will not be added once more.__@param verticesToAdd the list of vertices to add_@return the new graph containing the existing and newly added vertices;public Graph<K, VV, EV> addVertices(List<Vertex<K, VV>> verticesToAdd) {_		_		DataSet<Vertex<K, VV>> newVertices = this.vertices.coGroup(this.context.fromCollection(verticesToAdd))_				.where(0).equalTo(0).with(new VerticesUnionCoGroup<K, VV>()).name("Add vertices")___		return new Graph<>(newVertices, this.edges, this.context)__	};adds,the,list,of,vertices,passed,as,input,to,the,graph,if,the,vertices,already,exist,in,the,graph,they,will,not,be,added,once,more,param,vertices,to,add,the,list,of,vertices,to,add,return,the,new,graph,containing,the,existing,and,newly,added,vertices;public,graph,k,vv,ev,add,vertices,list,vertex,k,vv,vertices,to,add,data,set,vertex,k,vv,new,vertices,this,vertices,co,group,this,context,from,collection,vertices,to,add,where,0,equal,to,0,with,new,vertices,union,co,group,k,vv,name,add,vertices,return,new,graph,new,vertices,this,edges,this,context
Graph -> public Graph<K, VV, EV> addVertices(List<Vertex<K, VV>> verticesToAdd);1484160227;Adds the list of vertices, passed as input, to the graph._If the vertices already exist in the graph, they will not be added once more.__@param verticesToAdd the list of vertices to add_@return the new graph containing the existing and newly added vertices;public Graph<K, VV, EV> addVertices(List<Vertex<K, VV>> verticesToAdd) {_		_		DataSet<Vertex<K, VV>> newVertices = this.vertices.coGroup(this.context.fromCollection(verticesToAdd))_				.where(0).equalTo(0).with(new VerticesUnionCoGroup<K, VV>()).name("Add vertices")___		return new Graph<>(newVertices, this.edges, this.context)__	};adds,the,list,of,vertices,passed,as,input,to,the,graph,if,the,vertices,already,exist,in,the,graph,they,will,not,be,added,once,more,param,vertices,to,add,the,list,of,vertices,to,add,return,the,new,graph,containing,the,existing,and,newly,added,vertices;public,graph,k,vv,ev,add,vertices,list,vertex,k,vv,vertices,to,add,data,set,vertex,k,vv,new,vertices,this,vertices,co,group,this,context,from,collection,vertices,to,add,where,0,equal,to,0,with,new,vertices,union,co,group,k,vv,name,add,vertices,return,new,graph,new,vertices,this,edges,this,context
Graph -> public Graph<K, VV, EV> addVertices(List<Vertex<K, VV>> verticesToAdd);1484685504;Adds the list of vertices, passed as input, to the graph._If the vertices already exist in the graph, they will not be added once more.__@param verticesToAdd the list of vertices to add_@return the new graph containing the existing and newly added vertices;public Graph<K, VV, EV> addVertices(List<Vertex<K, VV>> verticesToAdd) {_		_		DataSet<Vertex<K, VV>> newVertices = this.vertices.coGroup(this.context.fromCollection(verticesToAdd))_				.where(0).equalTo(0).with(new VerticesUnionCoGroup<K, VV>()).name("Add vertices")___		return new Graph<>(newVertices, this.edges, this.context)__	};adds,the,list,of,vertices,passed,as,input,to,the,graph,if,the,vertices,already,exist,in,the,graph,they,will,not,be,added,once,more,param,vertices,to,add,the,list,of,vertices,to,add,return,the,new,graph,containing,the,existing,and,newly,added,vertices;public,graph,k,vv,ev,add,vertices,list,vertex,k,vv,vertices,to,add,data,set,vertex,k,vv,new,vertices,this,vertices,co,group,this,context,from,collection,vertices,to,add,where,0,equal,to,0,with,new,vertices,union,co,group,k,vv,name,add,vertices,return,new,graph,new,vertices,this,edges,this,context
Graph -> public Graph<K, VV, EV> addVertices(List<Vertex<K, VV>> verticesToAdd);1489068942;Adds the list of vertices, passed as input, to the graph._If the vertices already exist in the graph, they will not be added once more.__@param verticesToAdd the list of vertices to add_@return the new graph containing the existing and newly added vertices;public Graph<K, VV, EV> addVertices(List<Vertex<K, VV>> verticesToAdd) {_		_		DataSet<Vertex<K, VV>> newVertices = this.vertices.coGroup(this.context.fromCollection(verticesToAdd))_				.where(0).equalTo(0).with(new VerticesUnionCoGroup<K, VV>()).name("Add vertices")___		return new Graph<>(newVertices, this.edges, this.context)__	};adds,the,list,of,vertices,passed,as,input,to,the,graph,if,the,vertices,already,exist,in,the,graph,they,will,not,be,added,once,more,param,vertices,to,add,the,list,of,vertices,to,add,return,the,new,graph,containing,the,existing,and,newly,added,vertices;public,graph,k,vv,ev,add,vertices,list,vertex,k,vv,vertices,to,add,data,set,vertex,k,vv,new,vertices,this,vertices,co,group,this,context,from,collection,vertices,to,add,where,0,equal,to,0,with,new,vertices,union,co,group,k,vv,name,add,vertices,return,new,graph,new,vertices,this,edges,this,context
Graph -> public Graph<K, VV, EV> addVertices(List<Vertex<K, VV>> verticesToAdd);1490973446;Adds the list of vertices, passed as input, to the graph._If the vertices already exist in the graph, they will not be added once more.__@param verticesToAdd the list of vertices to add_@return the new graph containing the existing and newly added vertices;public Graph<K, VV, EV> addVertices(List<Vertex<K, VV>> verticesToAdd) {_		_		DataSet<Vertex<K, VV>> newVertices = this.vertices.coGroup(this.context.fromCollection(verticesToAdd))_				.where(0).equalTo(0).with(new VerticesUnionCoGroup<K, VV>()).name("Add vertices")___		return new Graph<>(newVertices, this.edges, this.context)__	};adds,the,list,of,vertices,passed,as,input,to,the,graph,if,the,vertices,already,exist,in,the,graph,they,will,not,be,added,once,more,param,vertices,to,add,the,list,of,vertices,to,add,return,the,new,graph,containing,the,existing,and,newly,added,vertices;public,graph,k,vv,ev,add,vertices,list,vertex,k,vv,vertices,to,add,data,set,vertex,k,vv,new,vertices,this,vertices,co,group,this,context,from,collection,vertices,to,add,where,0,equal,to,0,with,new,vertices,union,co,group,k,vv,name,add,vertices,return,new,graph,new,vertices,this,edges,this,context
Graph -> public Graph<K, VV, EV> addVertices(List<Vertex<K, VV>> verticesToAdd);1495819075;Adds the list of vertices, passed as input, to the graph._If the vertices already exist in the graph, they will not be added once more.__@param verticesToAdd the list of vertices to add_@return the new graph containing the existing and newly added vertices;public Graph<K, VV, EV> addVertices(List<Vertex<K, VV>> verticesToAdd) {_		_		DataSet<Vertex<K, VV>> newVertices = this.vertices.coGroup(this.context.fromCollection(verticesToAdd))_				.where(0).equalTo(0).with(new VerticesUnionCoGroup<K, VV>()).name("Add vertices")___		return new Graph<>(newVertices, this.edges, this.context)__	};adds,the,list,of,vertices,passed,as,input,to,the,graph,if,the,vertices,already,exist,in,the,graph,they,will,not,be,added,once,more,param,vertices,to,add,the,list,of,vertices,to,add,return,the,new,graph,containing,the,existing,and,newly,added,vertices;public,graph,k,vv,ev,add,vertices,list,vertex,k,vv,vertices,to,add,data,set,vertex,k,vv,new,vertices,this,vertices,co,group,this,context,from,collection,vertices,to,add,where,0,equal,to,0,with,new,vertices,union,co,group,k,vv,name,add,vertices,return,new,graph,new,vertices,this,edges,this,context
Graph -> public Graph<K, VV, EV> addVertices(List<Vertex<K, VV>> verticesToAdd);1502111816;Adds the list of vertices, passed as input, to the graph._If the vertices already exist in the graph, they will not be added once more.__@param verticesToAdd the list of vertices to add_@return the new graph containing the existing and newly added vertices;public Graph<K, VV, EV> addVertices(List<Vertex<K, VV>> verticesToAdd) {_		_		DataSet<Vertex<K, VV>> newVertices = this.vertices.coGroup(this.context.fromCollection(verticesToAdd))_				.where(0).equalTo(0).with(new VerticesUnionCoGroup<>()).name("Add vertices")___		return new Graph<>(newVertices, this.edges, this.context)__	};adds,the,list,of,vertices,passed,as,input,to,the,graph,if,the,vertices,already,exist,in,the,graph,they,will,not,be,added,once,more,param,vertices,to,add,the,list,of,vertices,to,add,return,the,new,graph,containing,the,existing,and,newly,added,vertices;public,graph,k,vv,ev,add,vertices,list,vertex,k,vv,vertices,to,add,data,set,vertex,k,vv,new,vertices,this,vertices,co,group,this,context,from,collection,vertices,to,add,where,0,equal,to,0,with,new,vertices,union,co,group,name,add,vertices,return,new,graph,new,vertices,this,edges,this,context
Graph -> private Graph<K, VV, EV> removeVertices(DataSet<Vertex<K, VV>> verticesToBeRemoved);1444404795;Removes the given list of vertices and its edges from the graph.__@param verticesToBeRemoved the DataSet of vertices to be removed_@return the resulted graph containing the initial vertices and edges minus the vertices_and edges removed.;private Graph<K, VV, EV> removeVertices(DataSet<Vertex<K, VV>> verticesToBeRemoved) {__		DataSet<Vertex<K, VV>> newVertices = getVertices().coGroup(verticesToBeRemoved).where(0).equalTo(0)_				.with(new VerticesRemovalCoGroup<K, VV>())___		DataSet < Edge < K, EV >> newEdges = newVertices.join(getEdges()).where(0).equalTo(0)_				_				.with(new ProjectEdgeToBeRemoved<K, VV, EV>())_				_				.join(newVertices).where(1).equalTo(0)_				.with(new ProjectEdge<K, VV, EV>())___		return new Graph<K, VV, EV>(newVertices, newEdges, context)__	};removes,the,given,list,of,vertices,and,its,edges,from,the,graph,param,vertices,to,be,removed,the,data,set,of,vertices,to,be,removed,return,the,resulted,graph,containing,the,initial,vertices,and,edges,minus,the,vertices,and,edges,removed;private,graph,k,vv,ev,remove,vertices,data,set,vertex,k,vv,vertices,to,be,removed,data,set,vertex,k,vv,new,vertices,get,vertices,co,group,vertices,to,be,removed,where,0,equal,to,0,with,new,vertices,removal,co,group,k,vv,data,set,edge,k,ev,new,edges,new,vertices,join,get,edges,where,0,equal,to,0,with,new,project,edge,to,be,removed,k,vv,ev,join,new,vertices,where,1,equal,to,0,with,new,project,edge,k,vv,ev,return,new,graph,k,vv,ev,new,vertices,new,edges,context
Graph -> private Graph<K, VV, EV> removeVertices(DataSet<Vertex<K, VV>> verticesToBeRemoved);1445261977;Removes the given list of vertices and its edges from the graph.__@param verticesToBeRemoved the DataSet of vertices to be removed_@return the resulted graph containing the initial vertices and edges minus the vertices_and edges removed.;private Graph<K, VV, EV> removeVertices(DataSet<Vertex<K, VV>> verticesToBeRemoved) {__		DataSet<Vertex<K, VV>> newVertices = getVertices().coGroup(verticesToBeRemoved).where(0).equalTo(0)_				.with(new VerticesRemovalCoGroup<K, VV>())___		DataSet < Edge < K, EV >> newEdges = newVertices.join(getEdges()).where(0).equalTo(0)_				_				.with(new ProjectEdgeToBeRemoved<K, VV, EV>())_				_				.join(newVertices).where(1).equalTo(0)_				.with(new ProjectEdge<K, VV, EV>())___		return new Graph<K, VV, EV>(newVertices, newEdges, context)__	};removes,the,given,list,of,vertices,and,its,edges,from,the,graph,param,vertices,to,be,removed,the,data,set,of,vertices,to,be,removed,return,the,resulted,graph,containing,the,initial,vertices,and,edges,minus,the,vertices,and,edges,removed;private,graph,k,vv,ev,remove,vertices,data,set,vertex,k,vv,vertices,to,be,removed,data,set,vertex,k,vv,new,vertices,get,vertices,co,group,vertices,to,be,removed,where,0,equal,to,0,with,new,vertices,removal,co,group,k,vv,data,set,edge,k,ev,new,edges,new,vertices,join,get,edges,where,0,equal,to,0,with,new,project,edge,to,be,removed,k,vv,ev,join,new,vertices,where,1,equal,to,0,with,new,project,edge,k,vv,ev,return,new,graph,k,vv,ev,new,vertices,new,edges,context
Graph -> private Graph<K, VV, EV> removeVertices(DataSet<Vertex<K, VV>> verticesToBeRemoved);1445854323;Removes the given list of vertices and its edges from the graph.__@param verticesToBeRemoved the DataSet of vertices to be removed_@return the resulted graph containing the initial vertices and edges minus the vertices_and edges removed.;private Graph<K, VV, EV> removeVertices(DataSet<Vertex<K, VV>> verticesToBeRemoved) {__		DataSet<Vertex<K, VV>> newVertices = getVertices().coGroup(verticesToBeRemoved).where(0).equalTo(0)_				.with(new VerticesRemovalCoGroup<K, VV>())___		DataSet <Edge< K, EV>> newEdges = newVertices.join(getEdges()).where(0).equalTo(0)_				_				.with(new ProjectEdgeToBeRemoved<K, VV, EV>())_				_				.join(newVertices).where(1).equalTo(0)_				.with(new ProjectEdge<K, VV, EV>())___		return new Graph<K, VV, EV>(newVertices, newEdges, context)__	};removes,the,given,list,of,vertices,and,its,edges,from,the,graph,param,vertices,to,be,removed,the,data,set,of,vertices,to,be,removed,return,the,resulted,graph,containing,the,initial,vertices,and,edges,minus,the,vertices,and,edges,removed;private,graph,k,vv,ev,remove,vertices,data,set,vertex,k,vv,vertices,to,be,removed,data,set,vertex,k,vv,new,vertices,get,vertices,co,group,vertices,to,be,removed,where,0,equal,to,0,with,new,vertices,removal,co,group,k,vv,data,set,edge,k,ev,new,edges,new,vertices,join,get,edges,where,0,equal,to,0,with,new,project,edge,to,be,removed,k,vv,ev,join,new,vertices,where,1,equal,to,0,with,new,project,edge,k,vv,ev,return,new,graph,k,vv,ev,new,vertices,new,edges,context
Graph -> private Graph<K, VV, EV> removeVertices(DataSet<Vertex<K, VV>> verticesToBeRemoved);1446112342;Removes the given list of vertices and its edges from the graph.__@param verticesToBeRemoved the DataSet of vertices to be removed_@return the resulted graph containing the initial vertices and edges minus the vertices_and edges removed.;private Graph<K, VV, EV> removeVertices(DataSet<Vertex<K, VV>> verticesToBeRemoved) {__		DataSet<Vertex<K, VV>> newVertices = getVertices().coGroup(verticesToBeRemoved).where(0).equalTo(0)_				.with(new VerticesRemovalCoGroup<K, VV>())___		DataSet <Edge< K, EV>> newEdges = newVertices.join(getEdges()).where(0).equalTo(0)_				_				.with(new ProjectEdgeToBeRemoved<K, VV, EV>())_				_				.join(newVertices).where(1).equalTo(0)_				.with(new ProjectEdge<K, VV, EV>())___		return new Graph<K, VV, EV>(newVertices, newEdges, context)__	};removes,the,given,list,of,vertices,and,its,edges,from,the,graph,param,vertices,to,be,removed,the,data,set,of,vertices,to,be,removed,return,the,resulted,graph,containing,the,initial,vertices,and,edges,minus,the,vertices,and,edges,removed;private,graph,k,vv,ev,remove,vertices,data,set,vertex,k,vv,vertices,to,be,removed,data,set,vertex,k,vv,new,vertices,get,vertices,co,group,vertices,to,be,removed,where,0,equal,to,0,with,new,vertices,removal,co,group,k,vv,data,set,edge,k,ev,new,edges,new,vertices,join,get,edges,where,0,equal,to,0,with,new,project,edge,to,be,removed,k,vv,ev,join,new,vertices,where,1,equal,to,0,with,new,project,edge,k,vv,ev,return,new,graph,k,vv,ev,new,vertices,new,edges,context
Graph -> private Graph<K, VV, EV> removeVertices(DataSet<Vertex<K, VV>> verticesToBeRemoved);1447073368;Removes the given list of vertices and its edges from the graph.__@param verticesToBeRemoved the DataSet of vertices to be removed_@return the resulted graph containing the initial vertices and edges minus the vertices_and edges removed.;private Graph<K, VV, EV> removeVertices(DataSet<Vertex<K, VV>> verticesToBeRemoved) {__		DataSet<Vertex<K, VV>> newVertices = getVertices().coGroup(verticesToBeRemoved).where(0).equalTo(0)_				.with(new VerticesRemovalCoGroup<K, VV>())___		DataSet <Edge< K, EV>> newEdges = newVertices.join(getEdges()).where(0).equalTo(0)_				_				.with(new ProjectEdgeToBeRemoved<K, VV, EV>())_				_				.join(newVertices).where(1).equalTo(0)_				.with(new ProjectEdge<K, VV, EV>())___		return new Graph<K, VV, EV>(newVertices, newEdges, context)__	};removes,the,given,list,of,vertices,and,its,edges,from,the,graph,param,vertices,to,be,removed,the,data,set,of,vertices,to,be,removed,return,the,resulted,graph,containing,the,initial,vertices,and,edges,minus,the,vertices,and,edges,removed;private,graph,k,vv,ev,remove,vertices,data,set,vertex,k,vv,vertices,to,be,removed,data,set,vertex,k,vv,new,vertices,get,vertices,co,group,vertices,to,be,removed,where,0,equal,to,0,with,new,vertices,removal,co,group,k,vv,data,set,edge,k,ev,new,edges,new,vertices,join,get,edges,where,0,equal,to,0,with,new,project,edge,to,be,removed,k,vv,ev,join,new,vertices,where,1,equal,to,0,with,new,project,edge,k,vv,ev,return,new,graph,k,vv,ev,new,vertices,new,edges,context
Graph -> private Graph<K, VV, EV> removeVertices(DataSet<Vertex<K, VV>> verticesToBeRemoved);1454404649;Removes the given list of vertices and its edges from the graph.__@param verticesToBeRemoved the DataSet of vertices to be removed_@return the resulted graph containing the initial vertices and edges minus the vertices_and edges removed.;private Graph<K, VV, EV> removeVertices(DataSet<Vertex<K, VV>> verticesToBeRemoved) {__		DataSet<Vertex<K, VV>> newVertices = getVertices().coGroup(verticesToBeRemoved).where(0).equalTo(0)_				.with(new VerticesRemovalCoGroup<K, VV>())___		DataSet <Edge< K, EV>> newEdges = newVertices.join(getEdges()).where(0).equalTo(0)_				_				.with(new ProjectEdgeToBeRemoved<K, VV, EV>())_				_				.join(newVertices).where(1).equalTo(0)_				.with(new ProjectEdge<K, VV, EV>())___		return new Graph<K, VV, EV>(newVertices, newEdges, context)__	};removes,the,given,list,of,vertices,and,its,edges,from,the,graph,param,vertices,to,be,removed,the,data,set,of,vertices,to,be,removed,return,the,resulted,graph,containing,the,initial,vertices,and,edges,minus,the,vertices,and,edges,removed;private,graph,k,vv,ev,remove,vertices,data,set,vertex,k,vv,vertices,to,be,removed,data,set,vertex,k,vv,new,vertices,get,vertices,co,group,vertices,to,be,removed,where,0,equal,to,0,with,new,vertices,removal,co,group,k,vv,data,set,edge,k,ev,new,edges,new,vertices,join,get,edges,where,0,equal,to,0,with,new,project,edge,to,be,removed,k,vv,ev,join,new,vertices,where,1,equal,to,0,with,new,project,edge,k,vv,ev,return,new,graph,k,vv,ev,new,vertices,new,edges,context
Graph -> private Graph<K, VV, EV> removeVertices(DataSet<Vertex<K, VV>> verticesToBeRemoved);1458583829;Removes the given list of vertices and its edges from the graph.__@param verticesToBeRemoved the DataSet of vertices to be removed_@return the resulted graph containing the initial vertices and edges minus the vertices_and edges removed.;private Graph<K, VV, EV> removeVertices(DataSet<Vertex<K, VV>> verticesToBeRemoved) {__		DataSet<Vertex<K, VV>> newVertices = getVertices().coGroup(verticesToBeRemoved).where(0).equalTo(0)_				.with(new VerticesRemovalCoGroup<K, VV>())___		DataSet <Edge< K, EV>> newEdges = newVertices.join(getEdges()).where(0).equalTo(0)_				_				.with(new ProjectEdgeToBeRemoved<K, VV, EV>())_				_				.join(newVertices).where(1).equalTo(0)_				.with(new ProjectEdge<K, VV, EV>())___		return new Graph<K, VV, EV>(newVertices, newEdges, context)__	};removes,the,given,list,of,vertices,and,its,edges,from,the,graph,param,vertices,to,be,removed,the,data,set,of,vertices,to,be,removed,return,the,resulted,graph,containing,the,initial,vertices,and,edges,minus,the,vertices,and,edges,removed;private,graph,k,vv,ev,remove,vertices,data,set,vertex,k,vv,vertices,to,be,removed,data,set,vertex,k,vv,new,vertices,get,vertices,co,group,vertices,to,be,removed,where,0,equal,to,0,with,new,vertices,removal,co,group,k,vv,data,set,edge,k,ev,new,edges,new,vertices,join,get,edges,where,0,equal,to,0,with,new,project,edge,to,be,removed,k,vv,ev,join,new,vertices,where,1,equal,to,0,with,new,project,edge,k,vv,ev,return,new,graph,k,vv,ev,new,vertices,new,edges,context
Graph -> private Graph<K, VV, EV> removeVertices(DataSet<Vertex<K, VV>> verticesToBeRemoved);1458583829;Removes the given list of vertices and its edges from the graph.__@param verticesToBeRemoved the DataSet of vertices to be removed_@return the resulted graph containing the initial vertices and edges minus the vertices_and edges removed.;private Graph<K, VV, EV> removeVertices(DataSet<Vertex<K, VV>> verticesToBeRemoved) {__		DataSet<Vertex<K, VV>> newVertices = getVertices().coGroup(verticesToBeRemoved).where(0).equalTo(0)_				.with(new VerticesRemovalCoGroup<K, VV>())___		DataSet <Edge< K, EV>> newEdges = newVertices.join(getEdges()).where(0).equalTo(0)_				_				.with(new ProjectEdgeToBeRemoved<K, VV, EV>())_				_				.join(newVertices).where(1).equalTo(0)_				.with(new ProjectEdge<K, VV, EV>())___		return new Graph<K, VV, EV>(newVertices, newEdges, context)__	};removes,the,given,list,of,vertices,and,its,edges,from,the,graph,param,vertices,to,be,removed,the,data,set,of,vertices,to,be,removed,return,the,resulted,graph,containing,the,initial,vertices,and,edges,minus,the,vertices,and,edges,removed;private,graph,k,vv,ev,remove,vertices,data,set,vertex,k,vv,vertices,to,be,removed,data,set,vertex,k,vv,new,vertices,get,vertices,co,group,vertices,to,be,removed,where,0,equal,to,0,with,new,vertices,removal,co,group,k,vv,data,set,edge,k,ev,new,edges,new,vertices,join,get,edges,where,0,equal,to,0,with,new,project,edge,to,be,removed,k,vv,ev,join,new,vertices,where,1,equal,to,0,with,new,project,edge,k,vv,ev,return,new,graph,k,vv,ev,new,vertices,new,edges,context
Graph -> private Graph<K, VV, EV> removeVertices(DataSet<Vertex<K, VV>> verticesToBeRemoved);1462100316;Removes the given list of vertices and its edges from the graph.__@param verticesToBeRemoved the DataSet of vertices to be removed_@return the resulted graph containing the initial vertices and edges minus the vertices_and edges removed.;private Graph<K, VV, EV> removeVertices(DataSet<Vertex<K, VV>> verticesToBeRemoved) {__		DataSet<Vertex<K, VV>> newVertices = getVertices().coGroup(verticesToBeRemoved).where(0).equalTo(0)_				.with(new VerticesRemovalCoGroup<K, VV>())___		DataSet <Edge< K, EV>> newEdges = newVertices.join(getEdges()).where(0).equalTo(0)_				_				.with(new ProjectEdgeToBeRemoved<K, VV, EV>())_				_				.join(newVertices).where(1).equalTo(0)_				.with(new ProjectEdge<K, VV, EV>())___		return new Graph<K, VV, EV>(newVertices, newEdges, context)__	};removes,the,given,list,of,vertices,and,its,edges,from,the,graph,param,vertices,to,be,removed,the,data,set,of,vertices,to,be,removed,return,the,resulted,graph,containing,the,initial,vertices,and,edges,minus,the,vertices,and,edges,removed;private,graph,k,vv,ev,remove,vertices,data,set,vertex,k,vv,vertices,to,be,removed,data,set,vertex,k,vv,new,vertices,get,vertices,co,group,vertices,to,be,removed,where,0,equal,to,0,with,new,vertices,removal,co,group,k,vv,data,set,edge,k,ev,new,edges,new,vertices,join,get,edges,where,0,equal,to,0,with,new,project,edge,to,be,removed,k,vv,ev,join,new,vertices,where,1,equal,to,0,with,new,project,edge,k,vv,ev,return,new,graph,k,vv,ev,new,vertices,new,edges,context
Graph -> private Graph<K, VV, EV> removeVertices(DataSet<Vertex<K, VV>> verticesToBeRemoved);1462100316;Removes the given list of vertices and its edges from the graph.__@param verticesToBeRemoved the DataSet of vertices to be removed_@return the resulted graph containing the initial vertices and edges minus the vertices_and edges removed.;private Graph<K, VV, EV> removeVertices(DataSet<Vertex<K, VV>> verticesToBeRemoved) {__		DataSet<Vertex<K, VV>> newVertices = getVertices().coGroup(verticesToBeRemoved).where(0).equalTo(0)_				.with(new VerticesRemovalCoGroup<K, VV>())___		DataSet <Edge< K, EV>> newEdges = newVertices.join(getEdges()).where(0).equalTo(0)_				_				.with(new ProjectEdgeToBeRemoved<K, VV, EV>())_				_				.join(newVertices).where(1).equalTo(0)_				.with(new ProjectEdge<K, VV, EV>())___		return new Graph<K, VV, EV>(newVertices, newEdges, context)__	};removes,the,given,list,of,vertices,and,its,edges,from,the,graph,param,vertices,to,be,removed,the,data,set,of,vertices,to,be,removed,return,the,resulted,graph,containing,the,initial,vertices,and,edges,minus,the,vertices,and,edges,removed;private,graph,k,vv,ev,remove,vertices,data,set,vertex,k,vv,vertices,to,be,removed,data,set,vertex,k,vv,new,vertices,get,vertices,co,group,vertices,to,be,removed,where,0,equal,to,0,with,new,vertices,removal,co,group,k,vv,data,set,edge,k,ev,new,edges,new,vertices,join,get,edges,where,0,equal,to,0,with,new,project,edge,to,be,removed,k,vv,ev,join,new,vertices,where,1,equal,to,0,with,new,project,edge,k,vv,ev,return,new,graph,k,vv,ev,new,vertices,new,edges,context
Graph -> private Graph<K, VV, EV> removeVertices(DataSet<Vertex<K, VV>> verticesToBeRemoved);1462205213;Removes the given list of vertices and its edges from the graph.__@param verticesToBeRemoved the DataSet of vertices to be removed_@return the resulted graph containing the initial vertices and edges minus the vertices_and edges removed.;private Graph<K, VV, EV> removeVertices(DataSet<Vertex<K, VV>> verticesToBeRemoved) {__		DataSet<Vertex<K, VV>> newVertices = getVertices().coGroup(verticesToBeRemoved).where(0).equalTo(0)_				.with(new VerticesRemovalCoGroup<K, VV>())___		DataSet <Edge< K, EV>> newEdges = newVertices.join(getEdges()).where(0).equalTo(0)_				_				.with(new ProjectEdgeToBeRemoved<K, VV, EV>())_				_				.join(newVertices).where(1).equalTo(0)_				.with(new ProjectEdge<K, VV, EV>())___		return new Graph<K, VV, EV>(newVertices, newEdges, context)__	};removes,the,given,list,of,vertices,and,its,edges,from,the,graph,param,vertices,to,be,removed,the,data,set,of,vertices,to,be,removed,return,the,resulted,graph,containing,the,initial,vertices,and,edges,minus,the,vertices,and,edges,removed;private,graph,k,vv,ev,remove,vertices,data,set,vertex,k,vv,vertices,to,be,removed,data,set,vertex,k,vv,new,vertices,get,vertices,co,group,vertices,to,be,removed,where,0,equal,to,0,with,new,vertices,removal,co,group,k,vv,data,set,edge,k,ev,new,edges,new,vertices,join,get,edges,where,0,equal,to,0,with,new,project,edge,to,be,removed,k,vv,ev,join,new,vertices,where,1,equal,to,0,with,new,project,edge,k,vv,ev,return,new,graph,k,vv,ev,new,vertices,new,edges,context
Graph -> private Graph<K, VV, EV> removeVertices(DataSet<Vertex<K, VV>> verticesToBeRemoved);1462208859;Removes the given list of vertices and its edges from the graph.__@param verticesToBeRemoved the DataSet of vertices to be removed_@return the resulted graph containing the initial vertices and edges minus the vertices_and edges removed.;private Graph<K, VV, EV> removeVertices(DataSet<Vertex<K, VV>> verticesToBeRemoved) {__		DataSet<Vertex<K, VV>> newVertices = getVertices().coGroup(verticesToBeRemoved).where(0).equalTo(0)_				.with(new VerticesRemovalCoGroup<K, VV>())___		DataSet <Edge< K, EV>> newEdges = newVertices.join(getEdges()).where(0).equalTo(0)_				_				.with(new ProjectEdgeToBeRemoved<K, VV, EV>())_				_				.join(newVertices).where(1).equalTo(0)_				.with(new ProjectEdge<K, VV, EV>())___		return new Graph<K, VV, EV>(newVertices, newEdges, context)__	};removes,the,given,list,of,vertices,and,its,edges,from,the,graph,param,vertices,to,be,removed,the,data,set,of,vertices,to,be,removed,return,the,resulted,graph,containing,the,initial,vertices,and,edges,minus,the,vertices,and,edges,removed;private,graph,k,vv,ev,remove,vertices,data,set,vertex,k,vv,vertices,to,be,removed,data,set,vertex,k,vv,new,vertices,get,vertices,co,group,vertices,to,be,removed,where,0,equal,to,0,with,new,vertices,removal,co,group,k,vv,data,set,edge,k,ev,new,edges,new,vertices,join,get,edges,where,0,equal,to,0,with,new,project,edge,to,be,removed,k,vv,ev,join,new,vertices,where,1,equal,to,0,with,new,project,edge,k,vv,ev,return,new,graph,k,vv,ev,new,vertices,new,edges,context
Graph -> private Graph<K, VV, EV> removeVertices(DataSet<Vertex<K, VV>> verticesToBeRemoved);1462809297;Removes the given list of vertices and its edges from the graph.__@param verticesToBeRemoved the DataSet of vertices to be removed_@return the resulted graph containing the initial vertices and edges minus the vertices_and edges removed.;private Graph<K, VV, EV> removeVertices(DataSet<Vertex<K, VV>> verticesToBeRemoved) {__		DataSet<Vertex<K, VV>> newVertices = getVertices().coGroup(verticesToBeRemoved).where(0).equalTo(0)_				.with(new VerticesRemovalCoGroup<K, VV>())___		DataSet <Edge< K, EV>> newEdges = newVertices.join(getEdges()).where(0).equalTo(0)_				_				.with(new ProjectEdgeToBeRemoved<K, VV, EV>())_				_				.join(newVertices).where(1).equalTo(0)_				.with(new ProjectEdge<K, VV, EV>())___		return new Graph<K, VV, EV>(newVertices, newEdges, context)__	};removes,the,given,list,of,vertices,and,its,edges,from,the,graph,param,vertices,to,be,removed,the,data,set,of,vertices,to,be,removed,return,the,resulted,graph,containing,the,initial,vertices,and,edges,minus,the,vertices,and,edges,removed;private,graph,k,vv,ev,remove,vertices,data,set,vertex,k,vv,vertices,to,be,removed,data,set,vertex,k,vv,new,vertices,get,vertices,co,group,vertices,to,be,removed,where,0,equal,to,0,with,new,vertices,removal,co,group,k,vv,data,set,edge,k,ev,new,edges,new,vertices,join,get,edges,where,0,equal,to,0,with,new,project,edge,to,be,removed,k,vv,ev,join,new,vertices,where,1,equal,to,0,with,new,project,edge,k,vv,ev,return,new,graph,k,vv,ev,new,vertices,new,edges,context
Graph -> private Graph<K, VV, EV> removeVertices(DataSet<Vertex<K, VV>> verticesToBeRemoved);1465316775;Removes the given list of vertices and its edges from the graph.__@param verticesToBeRemoved the DataSet of vertices to be removed_@return the resulted graph containing the initial vertices and edges minus the vertices_and edges removed.;private Graph<K, VV, EV> removeVertices(DataSet<Vertex<K, VV>> verticesToBeRemoved) {__		DataSet<Vertex<K, VV>> newVertices = getVertices().coGroup(verticesToBeRemoved).where(0).equalTo(0)_				.with(new VerticesRemovalCoGroup<K, VV>())___		DataSet <Edge< K, EV>> newEdges = newVertices.join(getEdges()).where(0).equalTo(0)_				_				.with(new ProjectEdgeToBeRemoved<K, VV, EV>())_				_				.join(newVertices).where(1).equalTo(0)_				.with(new ProjectEdge<K, VV, EV>())___		return new Graph<K, VV, EV>(newVertices, newEdges, context)__	};removes,the,given,list,of,vertices,and,its,edges,from,the,graph,param,vertices,to,be,removed,the,data,set,of,vertices,to,be,removed,return,the,resulted,graph,containing,the,initial,vertices,and,edges,minus,the,vertices,and,edges,removed;private,graph,k,vv,ev,remove,vertices,data,set,vertex,k,vv,vertices,to,be,removed,data,set,vertex,k,vv,new,vertices,get,vertices,co,group,vertices,to,be,removed,where,0,equal,to,0,with,new,vertices,removal,co,group,k,vv,data,set,edge,k,ev,new,edges,new,vertices,join,get,edges,where,0,equal,to,0,with,new,project,edge,to,be,removed,k,vv,ev,join,new,vertices,where,1,equal,to,0,with,new,project,edge,k,vv,ev,return,new,graph,k,vv,ev,new,vertices,new,edges,context
Graph -> private Graph<K, VV, EV> removeVertices(DataSet<Vertex<K, VV>> verticesToBeRemoved);1466789678;Removes the given list of vertices and its edges from the graph.__@param verticesToBeRemoved the DataSet of vertices to be removed_@return the resulted graph containing the initial vertices and edges minus the vertices_and edges removed.;private Graph<K, VV, EV> removeVertices(DataSet<Vertex<K, VV>> verticesToBeRemoved) {__		DataSet<Vertex<K, VV>> newVertices = getVertices().coGroup(verticesToBeRemoved).where(0).equalTo(0)_				.with(new VerticesRemovalCoGroup<K, VV>())___		DataSet <Edge< K, EV>> newEdges = newVertices.join(getEdges()).where(0).equalTo(0)_				_				.with(new ProjectEdgeToBeRemoved<K, VV, EV>())_				_				.join(newVertices).where(1).equalTo(0)_				.with(new ProjectEdge<K, VV, EV>())___		return new Graph<K, VV, EV>(newVertices, newEdges, context)__	};removes,the,given,list,of,vertices,and,its,edges,from,the,graph,param,vertices,to,be,removed,the,data,set,of,vertices,to,be,removed,return,the,resulted,graph,containing,the,initial,vertices,and,edges,minus,the,vertices,and,edges,removed;private,graph,k,vv,ev,remove,vertices,data,set,vertex,k,vv,vertices,to,be,removed,data,set,vertex,k,vv,new,vertices,get,vertices,co,group,vertices,to,be,removed,where,0,equal,to,0,with,new,vertices,removal,co,group,k,vv,data,set,edge,k,ev,new,edges,new,vertices,join,get,edges,where,0,equal,to,0,with,new,project,edge,to,be,removed,k,vv,ev,join,new,vertices,where,1,equal,to,0,with,new,project,edge,k,vv,ev,return,new,graph,k,vv,ev,new,vertices,new,edges,context
Graph -> private Graph<K, VV, EV> removeVertices(DataSet<Vertex<K, VV>> verticesToBeRemoved);1467140656;Removes the given list of vertices and its edges from the graph.__@param verticesToBeRemoved the DataSet of vertices to be removed_@return the resulted graph containing the initial vertices and edges minus the vertices_and edges removed.;private Graph<K, VV, EV> removeVertices(DataSet<Vertex<K, VV>> verticesToBeRemoved) {__		DataSet<Vertex<K, VV>> newVertices = getVertices().coGroup(verticesToBeRemoved).where(0).equalTo(0)_				.with(new VerticesRemovalCoGroup<K, VV>())___		DataSet <Edge< K, EV>> newEdges = newVertices.join(getEdges()).where(0).equalTo(0)_				_				.with(new ProjectEdgeToBeRemoved<K, VV, EV>())_				_				.join(newVertices).where(1).equalTo(0)_				.with(new ProjectEdge<K, VV, EV>())___		return new Graph<K, VV, EV>(newVertices, newEdges, context)__	};removes,the,given,list,of,vertices,and,its,edges,from,the,graph,param,vertices,to,be,removed,the,data,set,of,vertices,to,be,removed,return,the,resulted,graph,containing,the,initial,vertices,and,edges,minus,the,vertices,and,edges,removed;private,graph,k,vv,ev,remove,vertices,data,set,vertex,k,vv,vertices,to,be,removed,data,set,vertex,k,vv,new,vertices,get,vertices,co,group,vertices,to,be,removed,where,0,equal,to,0,with,new,vertices,removal,co,group,k,vv,data,set,edge,k,ev,new,edges,new,vertices,join,get,edges,where,0,equal,to,0,with,new,project,edge,to,be,removed,k,vv,ev,join,new,vertices,where,1,equal,to,0,with,new,project,edge,k,vv,ev,return,new,graph,k,vv,ev,new,vertices,new,edges,context
Graph -> private Graph<K, VV, EV> removeVertices(DataSet<Vertex<K, VV>> verticesToBeRemoved);1467306272;Removes the given list of vertices and its edges from the graph.__@param verticesToBeRemoved the DataSet of vertices to be removed_@return the resulted graph containing the initial vertices and edges minus the vertices_and edges removed.;private Graph<K, VV, EV> removeVertices(DataSet<Vertex<K, VV>> verticesToBeRemoved) {__		DataSet<Vertex<K, VV>> newVertices = getVertices().coGroup(verticesToBeRemoved).where(0).equalTo(0)_				.with(new VerticesRemovalCoGroup<K, VV>())___		DataSet <Edge< K, EV>> newEdges = newVertices.join(getEdges()).where(0).equalTo(0)_				_				.with(new ProjectEdgeToBeRemoved<K, VV, EV>())_				_				.join(newVertices).where(1).equalTo(0)_				.with(new ProjectEdge<K, VV, EV>())___		return new Graph<K, VV, EV>(newVertices, newEdges, context)__	};removes,the,given,list,of,vertices,and,its,edges,from,the,graph,param,vertices,to,be,removed,the,data,set,of,vertices,to,be,removed,return,the,resulted,graph,containing,the,initial,vertices,and,edges,minus,the,vertices,and,edges,removed;private,graph,k,vv,ev,remove,vertices,data,set,vertex,k,vv,vertices,to,be,removed,data,set,vertex,k,vv,new,vertices,get,vertices,co,group,vertices,to,be,removed,where,0,equal,to,0,with,new,vertices,removal,co,group,k,vv,data,set,edge,k,ev,new,edges,new,vertices,join,get,edges,where,0,equal,to,0,with,new,project,edge,to,be,removed,k,vv,ev,join,new,vertices,where,1,equal,to,0,with,new,project,edge,k,vv,ev,return,new,graph,k,vv,ev,new,vertices,new,edges,context
Graph -> private Graph<K, VV, EV> removeVertices(DataSet<Vertex<K, VV>> verticesToBeRemoved);1470042815;Removes the given list of vertices and its edges from the graph.__@param verticesToBeRemoved the DataSet of vertices to be removed_@return the resulted graph containing the initial vertices and edges minus the vertices_and edges removed.;private Graph<K, VV, EV> removeVertices(DataSet<Vertex<K, VV>> verticesToBeRemoved) {__		DataSet<Vertex<K, VV>> newVertices = getVertices().coGroup(verticesToBeRemoved).where(0).equalTo(0)_				.with(new VerticesRemovalCoGroup<K, VV>())___		DataSet <Edge< K, EV>> newEdges = newVertices.join(getEdges()).where(0).equalTo(0)_				_				.with(new ProjectEdgeToBeRemoved<K, VV, EV>())_				_				.join(newVertices).where(1).equalTo(0)_				.with(new ProjectEdge<K, VV, EV>())___		return new Graph<K, VV, EV>(newVertices, newEdges, context)__	};removes,the,given,list,of,vertices,and,its,edges,from,the,graph,param,vertices,to,be,removed,the,data,set,of,vertices,to,be,removed,return,the,resulted,graph,containing,the,initial,vertices,and,edges,minus,the,vertices,and,edges,removed;private,graph,k,vv,ev,remove,vertices,data,set,vertex,k,vv,vertices,to,be,removed,data,set,vertex,k,vv,new,vertices,get,vertices,co,group,vertices,to,be,removed,where,0,equal,to,0,with,new,vertices,removal,co,group,k,vv,data,set,edge,k,ev,new,edges,new,vertices,join,get,edges,where,0,equal,to,0,with,new,project,edge,to,be,removed,k,vv,ev,join,new,vertices,where,1,equal,to,0,with,new,project,edge,k,vv,ev,return,new,graph,k,vv,ev,new,vertices,new,edges,context
Graph -> private Graph<K, VV, EV> removeVertices(DataSet<Vertex<K, VV>> verticesToBeRemoved);1475684776;Removes the given list of vertices and its edges from the graph.__@param verticesToBeRemoved the DataSet of vertices to be removed_@return the resulted graph containing the initial vertices and edges minus the vertices_and edges removed.;private Graph<K, VV, EV> removeVertices(DataSet<Vertex<K, VV>> verticesToBeRemoved) {__		DataSet<Vertex<K, VV>> newVertices = getVertices().coGroup(verticesToBeRemoved).where(0).equalTo(0)_				.with(new VerticesRemovalCoGroup<K, VV>())___		DataSet <Edge< K, EV>> newEdges = newVertices.join(getEdges()).where(0).equalTo(0)_				_				.with(new ProjectEdgeToBeRemoved<K, VV, EV>())_				_				.join(newVertices).where(1).equalTo(0)_				.with(new ProjectEdge<K, VV, EV>())___		return new Graph<>(newVertices, newEdges, context)__	};removes,the,given,list,of,vertices,and,its,edges,from,the,graph,param,vertices,to,be,removed,the,data,set,of,vertices,to,be,removed,return,the,resulted,graph,containing,the,initial,vertices,and,edges,minus,the,vertices,and,edges,removed;private,graph,k,vv,ev,remove,vertices,data,set,vertex,k,vv,vertices,to,be,removed,data,set,vertex,k,vv,new,vertices,get,vertices,co,group,vertices,to,be,removed,where,0,equal,to,0,with,new,vertices,removal,co,group,k,vv,data,set,edge,k,ev,new,edges,new,vertices,join,get,edges,where,0,equal,to,0,with,new,project,edge,to,be,removed,k,vv,ev,join,new,vertices,where,1,equal,to,0,with,new,project,edge,k,vv,ev,return,new,graph,new,vertices,new,edges,context
Graph -> private Graph<K, VV, EV> removeVertices(DataSet<Vertex<K, VV>> verticesToBeRemoved);1475685606;Removes the given list of vertices and its edges from the graph.__@param verticesToBeRemoved the DataSet of vertices to be removed_@return the resulted graph containing the initial vertices and edges minus the vertices_and edges removed.;private Graph<K, VV, EV> removeVertices(DataSet<Vertex<K, VV>> verticesToBeRemoved) {__		DataSet<Vertex<K, VV>> newVertices = getVertices().coGroup(verticesToBeRemoved).where(0).equalTo(0)_				.with(new VerticesRemovalCoGroup<K, VV>())___		DataSet <Edge< K, EV>> newEdges = newVertices.join(getEdges()).where(0).equalTo(0)_				_				.with(new ProjectEdgeToBeRemoved<K, VV, EV>())_				_				.join(newVertices).where(1).equalTo(0)_				.with(new ProjectEdge<K, VV, EV>())___		return new Graph<>(newVertices, newEdges, context)__	};removes,the,given,list,of,vertices,and,its,edges,from,the,graph,param,vertices,to,be,removed,the,data,set,of,vertices,to,be,removed,return,the,resulted,graph,containing,the,initial,vertices,and,edges,minus,the,vertices,and,edges,removed;private,graph,k,vv,ev,remove,vertices,data,set,vertex,k,vv,vertices,to,be,removed,data,set,vertex,k,vv,new,vertices,get,vertices,co,group,vertices,to,be,removed,where,0,equal,to,0,with,new,vertices,removal,co,group,k,vv,data,set,edge,k,ev,new,edges,new,vertices,join,get,edges,where,0,equal,to,0,with,new,project,edge,to,be,removed,k,vv,ev,join,new,vertices,where,1,equal,to,0,with,new,project,edge,k,vv,ev,return,new,graph,new,vertices,new,edges,context
Graph -> private Graph<K, VV, EV> removeVertices(DataSet<Vertex<K, VV>> verticesToBeRemoved);1481745825;Removes the given list of vertices and its edges from the graph.__@param verticesToBeRemoved the DataSet of vertices to be removed_@return the resulted graph containing the initial vertices and edges minus the vertices_and edges removed.;private Graph<K, VV, EV> removeVertices(DataSet<Vertex<K, VV>> verticesToBeRemoved) {__		DataSet<Vertex<K, VV>> newVertices = getVertices().coGroup(verticesToBeRemoved).where(0).equalTo(0)_				.with(new VerticesRemovalCoGroup<K, VV>()).name("Remove vertices")___		DataSet <Edge< K, EV>> newEdges = newVertices.join(getEdges()).where(0).equalTo(0)_				_				.with(new ProjectEdgeToBeRemoved<K, VV, EV>()).name("Edges to be removed")_				_				.join(newVertices).where(1).equalTo(0)_				.with(new ProjectEdge<K, VV, EV>()).name("Remove edges")___		return new Graph<>(newVertices, newEdges, context)__	};removes,the,given,list,of,vertices,and,its,edges,from,the,graph,param,vertices,to,be,removed,the,data,set,of,vertices,to,be,removed,return,the,resulted,graph,containing,the,initial,vertices,and,edges,minus,the,vertices,and,edges,removed;private,graph,k,vv,ev,remove,vertices,data,set,vertex,k,vv,vertices,to,be,removed,data,set,vertex,k,vv,new,vertices,get,vertices,co,group,vertices,to,be,removed,where,0,equal,to,0,with,new,vertices,removal,co,group,k,vv,name,remove,vertices,data,set,edge,k,ev,new,edges,new,vertices,join,get,edges,where,0,equal,to,0,with,new,project,edge,to,be,removed,k,vv,ev,name,edges,to,be,removed,join,new,vertices,where,1,equal,to,0,with,new,project,edge,k,vv,ev,name,remove,edges,return,new,graph,new,vertices,new,edges,context
Graph -> private Graph<K, VV, EV> removeVertices(DataSet<Vertex<K, VV>> verticesToBeRemoved);1481881009;Removes the given list of vertices and its edges from the graph.__@param verticesToBeRemoved the DataSet of vertices to be removed_@return the resulted graph containing the initial vertices and edges minus the vertices_and edges removed.;private Graph<K, VV, EV> removeVertices(DataSet<Vertex<K, VV>> verticesToBeRemoved) {__		DataSet<Vertex<K, VV>> newVertices = getVertices().coGroup(verticesToBeRemoved).where(0).equalTo(0)_				.with(new VerticesRemovalCoGroup<K, VV>()).name("Remove vertices")___		DataSet <Edge< K, EV>> newEdges = newVertices.join(getEdges()).where(0).equalTo(0)_				_				.with(new ProjectEdgeToBeRemoved<K, VV, EV>()).name("Edges to be removed")_				_				.join(newVertices).where(1).equalTo(0)_				.with(new ProjectEdge<K, VV, EV>()).name("Remove edges")___		return new Graph<>(newVertices, newEdges, context)__	};removes,the,given,list,of,vertices,and,its,edges,from,the,graph,param,vertices,to,be,removed,the,data,set,of,vertices,to,be,removed,return,the,resulted,graph,containing,the,initial,vertices,and,edges,minus,the,vertices,and,edges,removed;private,graph,k,vv,ev,remove,vertices,data,set,vertex,k,vv,vertices,to,be,removed,data,set,vertex,k,vv,new,vertices,get,vertices,co,group,vertices,to,be,removed,where,0,equal,to,0,with,new,vertices,removal,co,group,k,vv,name,remove,vertices,data,set,edge,k,ev,new,edges,new,vertices,join,get,edges,where,0,equal,to,0,with,new,project,edge,to,be,removed,k,vv,ev,name,edges,to,be,removed,join,new,vertices,where,1,equal,to,0,with,new,project,edge,k,vv,ev,name,remove,edges,return,new,graph,new,vertices,new,edges,context
Graph -> private Graph<K, VV, EV> removeVertices(DataSet<Vertex<K, VV>> verticesToBeRemoved);1484160227;Removes the given list of vertices and its edges from the graph.__@param verticesToBeRemoved the DataSet of vertices to be removed_@return the resulted graph containing the initial vertices and edges minus the vertices_and edges removed.;private Graph<K, VV, EV> removeVertices(DataSet<Vertex<K, VV>> verticesToBeRemoved) {__		DataSet<Vertex<K, VV>> newVertices = getVertices().coGroup(verticesToBeRemoved).where(0).equalTo(0)_				.with(new VerticesRemovalCoGroup<K, VV>()).name("Remove vertices")___		DataSet <Edge< K, EV>> newEdges = newVertices.join(getEdges()).where(0).equalTo(0)_				_				.with(new ProjectEdgeToBeRemoved<K, VV, EV>()).name("Edges to be removed")_				_				.join(newVertices).where(1).equalTo(0)_				.with(new ProjectEdge<K, VV, EV>()).name("Remove edges")___		return new Graph<>(newVertices, newEdges, context)__	};removes,the,given,list,of,vertices,and,its,edges,from,the,graph,param,vertices,to,be,removed,the,data,set,of,vertices,to,be,removed,return,the,resulted,graph,containing,the,initial,vertices,and,edges,minus,the,vertices,and,edges,removed;private,graph,k,vv,ev,remove,vertices,data,set,vertex,k,vv,vertices,to,be,removed,data,set,vertex,k,vv,new,vertices,get,vertices,co,group,vertices,to,be,removed,where,0,equal,to,0,with,new,vertices,removal,co,group,k,vv,name,remove,vertices,data,set,edge,k,ev,new,edges,new,vertices,join,get,edges,where,0,equal,to,0,with,new,project,edge,to,be,removed,k,vv,ev,name,edges,to,be,removed,join,new,vertices,where,1,equal,to,0,with,new,project,edge,k,vv,ev,name,remove,edges,return,new,graph,new,vertices,new,edges,context
Graph -> private Graph<K, VV, EV> removeVertices(DataSet<Vertex<K, VV>> verticesToBeRemoved);1484685504;Removes the given list of vertices and its edges from the graph.__@param verticesToBeRemoved the DataSet of vertices to be removed_@return the resulted graph containing the initial vertices and edges minus the vertices_and edges removed.;private Graph<K, VV, EV> removeVertices(DataSet<Vertex<K, VV>> verticesToBeRemoved) {__		DataSet<Vertex<K, VV>> newVertices = getVertices().coGroup(verticesToBeRemoved).where(0).equalTo(0)_				.with(new VerticesRemovalCoGroup<K, VV>()).name("Remove vertices")___		DataSet <Edge< K, EV>> newEdges = newVertices.join(getEdges()).where(0).equalTo(0)_				_				.with(new ProjectEdgeToBeRemoved<K, VV, EV>()).name("Edges to be removed")_				_				.join(newVertices).where(1).equalTo(0)_				.with(new ProjectEdge<K, VV, EV>()).name("Remove edges")___		return new Graph<>(newVertices, newEdges, context)__	};removes,the,given,list,of,vertices,and,its,edges,from,the,graph,param,vertices,to,be,removed,the,data,set,of,vertices,to,be,removed,return,the,resulted,graph,containing,the,initial,vertices,and,edges,minus,the,vertices,and,edges,removed;private,graph,k,vv,ev,remove,vertices,data,set,vertex,k,vv,vertices,to,be,removed,data,set,vertex,k,vv,new,vertices,get,vertices,co,group,vertices,to,be,removed,where,0,equal,to,0,with,new,vertices,removal,co,group,k,vv,name,remove,vertices,data,set,edge,k,ev,new,edges,new,vertices,join,get,edges,where,0,equal,to,0,with,new,project,edge,to,be,removed,k,vv,ev,name,edges,to,be,removed,join,new,vertices,where,1,equal,to,0,with,new,project,edge,k,vv,ev,name,remove,edges,return,new,graph,new,vertices,new,edges,context
Graph -> private Graph<K, VV, EV> removeVertices(DataSet<Vertex<K, VV>> verticesToBeRemoved);1489068942;Removes the given list of vertices and its edges from the graph.__@param verticesToBeRemoved the DataSet of vertices to be removed_@return the resulted graph containing the initial vertices and edges minus the vertices_and edges removed.;private Graph<K, VV, EV> removeVertices(DataSet<Vertex<K, VV>> verticesToBeRemoved) {__		DataSet<Vertex<K, VV>> newVertices = getVertices().coGroup(verticesToBeRemoved).where(0).equalTo(0)_				.with(new VerticesRemovalCoGroup<K, VV>()).name("Remove vertices")___		DataSet <Edge< K, EV>> newEdges = newVertices.join(getEdges()).where(0).equalTo(0)_				_				.with(new ProjectEdgeToBeRemoved<K, VV, EV>()).name("Edges to be removed")_				_				.join(newVertices).where(1).equalTo(0)_				.with(new ProjectEdge<K, VV, EV>()).name("Remove edges")___		return new Graph<>(newVertices, newEdges, context)__	};removes,the,given,list,of,vertices,and,its,edges,from,the,graph,param,vertices,to,be,removed,the,data,set,of,vertices,to,be,removed,return,the,resulted,graph,containing,the,initial,vertices,and,edges,minus,the,vertices,and,edges,removed;private,graph,k,vv,ev,remove,vertices,data,set,vertex,k,vv,vertices,to,be,removed,data,set,vertex,k,vv,new,vertices,get,vertices,co,group,vertices,to,be,removed,where,0,equal,to,0,with,new,vertices,removal,co,group,k,vv,name,remove,vertices,data,set,edge,k,ev,new,edges,new,vertices,join,get,edges,where,0,equal,to,0,with,new,project,edge,to,be,removed,k,vv,ev,name,edges,to,be,removed,join,new,vertices,where,1,equal,to,0,with,new,project,edge,k,vv,ev,name,remove,edges,return,new,graph,new,vertices,new,edges,context
Graph -> private Graph<K, VV, EV> removeVertices(DataSet<Vertex<K, VV>> verticesToBeRemoved);1490973446;Removes the given list of vertices and its edges from the graph.__@param verticesToBeRemoved the DataSet of vertices to be removed_@return the resulted graph containing the initial vertices and edges minus the vertices_and edges removed.;private Graph<K, VV, EV> removeVertices(DataSet<Vertex<K, VV>> verticesToBeRemoved) {__		DataSet<Vertex<K, VV>> newVertices = getVertices().coGroup(verticesToBeRemoved).where(0).equalTo(0)_				.with(new VerticesRemovalCoGroup<K, VV>()).name("Remove vertices")___		DataSet <Edge< K, EV>> newEdges = newVertices.join(getEdges()).where(0).equalTo(0)_				_				.with(new ProjectEdgeToBeRemoved<K, VV, EV>()).name("Edges to be removed")_				_				.join(newVertices).where(1).equalTo(0)_				.with(new ProjectEdge<K, VV, EV>()).name("Remove edges")___		return new Graph<>(newVertices, newEdges, context)__	};removes,the,given,list,of,vertices,and,its,edges,from,the,graph,param,vertices,to,be,removed,the,data,set,of,vertices,to,be,removed,return,the,resulted,graph,containing,the,initial,vertices,and,edges,minus,the,vertices,and,edges,removed;private,graph,k,vv,ev,remove,vertices,data,set,vertex,k,vv,vertices,to,be,removed,data,set,vertex,k,vv,new,vertices,get,vertices,co,group,vertices,to,be,removed,where,0,equal,to,0,with,new,vertices,removal,co,group,k,vv,name,remove,vertices,data,set,edge,k,ev,new,edges,new,vertices,join,get,edges,where,0,equal,to,0,with,new,project,edge,to,be,removed,k,vv,ev,name,edges,to,be,removed,join,new,vertices,where,1,equal,to,0,with,new,project,edge,k,vv,ev,name,remove,edges,return,new,graph,new,vertices,new,edges,context
Graph -> private Graph<K, VV, EV> removeVertices(DataSet<Vertex<K, VV>> verticesToBeRemoved);1495819075;Removes the given list of vertices and its edges from the graph.__@param verticesToBeRemoved the DataSet of vertices to be removed_@return the resulted graph containing the initial vertices and edges minus the vertices_and edges removed.;private Graph<K, VV, EV> removeVertices(DataSet<Vertex<K, VV>> verticesToBeRemoved) {__		DataSet<Vertex<K, VV>> newVertices = getVertices().coGroup(verticesToBeRemoved).where(0).equalTo(0)_				.with(new VerticesRemovalCoGroup<K, VV>()).name("Remove vertices")___		DataSet <Edge< K, EV>> newEdges = newVertices.join(getEdges()).where(0).equalTo(0)_				_				.with(new ProjectEdgeToBeRemoved<K, VV, EV>()).name("Edges to be removed")_				_				.join(newVertices).where(1).equalTo(0)_				.with(new ProjectEdge<K, VV, EV>()).name("Remove edges")___		return new Graph<>(newVertices, newEdges, context)__	};removes,the,given,list,of,vertices,and,its,edges,from,the,graph,param,vertices,to,be,removed,the,data,set,of,vertices,to,be,removed,return,the,resulted,graph,containing,the,initial,vertices,and,edges,minus,the,vertices,and,edges,removed;private,graph,k,vv,ev,remove,vertices,data,set,vertex,k,vv,vertices,to,be,removed,data,set,vertex,k,vv,new,vertices,get,vertices,co,group,vertices,to,be,removed,where,0,equal,to,0,with,new,vertices,removal,co,group,k,vv,name,remove,vertices,data,set,edge,k,ev,new,edges,new,vertices,join,get,edges,where,0,equal,to,0,with,new,project,edge,to,be,removed,k,vv,ev,name,edges,to,be,removed,join,new,vertices,where,1,equal,to,0,with,new,project,edge,k,vv,ev,name,remove,edges,return,new,graph,new,vertices,new,edges,context
Graph -> private Graph<K, VV, EV> removeVertices(DataSet<Vertex<K, VV>> verticesToBeRemoved);1502111816;Removes the given list of vertices and its edges from the graph.__@param verticesToBeRemoved the DataSet of vertices to be removed_@return the resulted graph containing the initial vertices and edges minus the vertices_and edges removed.;private Graph<K, VV, EV> removeVertices(DataSet<Vertex<K, VV>> verticesToBeRemoved) {__		DataSet<Vertex<K, VV>> newVertices = getVertices().coGroup(verticesToBeRemoved).where(0).equalTo(0)_				.with(new VerticesRemovalCoGroup<>()).name("Remove vertices")___		DataSet <Edge< K, EV>> newEdges = newVertices.join(getEdges()).where(0).equalTo(0)_				_				.with(new ProjectEdgeToBeRemoved<>()).name("Edges to be removed")_				_				.join(newVertices).where(1).equalTo(0)_				.with(new ProjectEdge<>()).name("Remove edges")___		return new Graph<>(newVertices, newEdges, context)__	};removes,the,given,list,of,vertices,and,its,edges,from,the,graph,param,vertices,to,be,removed,the,data,set,of,vertices,to,be,removed,return,the,resulted,graph,containing,the,initial,vertices,and,edges,minus,the,vertices,and,edges,removed;private,graph,k,vv,ev,remove,vertices,data,set,vertex,k,vv,vertices,to,be,removed,data,set,vertex,k,vv,new,vertices,get,vertices,co,group,vertices,to,be,removed,where,0,equal,to,0,with,new,vertices,removal,co,group,name,remove,vertices,data,set,edge,k,ev,new,edges,new,vertices,join,get,edges,where,0,equal,to,0,with,new,project,edge,to,be,removed,name,edges,to,be,removed,join,new,vertices,where,1,equal,to,0,with,new,project,edge,name,remove,edges,return,new,graph,new,vertices,new,edges,context
Graph -> public DataSet<Tuple2<K, LongValue>> getDegrees();1467140656;Return the degree of all vertices in the graph__@return A DataSet of {@code Tuple2<vertexId, degree>};public DataSet<Tuple2<K, LongValue>> getDegrees() {_		return outDegrees().union(inDegrees()).groupBy(0).sum(1)__	};return,the,degree,of,all,vertices,in,the,graph,return,a,data,set,of,code,tuple2,vertex,id,degree;public,data,set,tuple2,k,long,value,get,degrees,return,out,degrees,union,in,degrees,group,by,0,sum,1
Graph -> public DataSet<Tuple2<K, LongValue>> getDegrees();1467306272;Return the degree of all vertices in the graph__@return A DataSet of {@code Tuple2<vertexId, degree>};public DataSet<Tuple2<K, LongValue>> getDegrees() {_		return outDegrees().union(inDegrees()).groupBy(0).sum(1)__	};return,the,degree,of,all,vertices,in,the,graph,return,a,data,set,of,code,tuple2,vertex,id,degree;public,data,set,tuple2,k,long,value,get,degrees,return,out,degrees,union,in,degrees,group,by,0,sum,1
Graph -> public DataSet<Tuple2<K, LongValue>> getDegrees();1470042815;Return the degree of all vertices in the graph__@return A DataSet of {@code Tuple2<vertexId, degree>};public DataSet<Tuple2<K, LongValue>> getDegrees() {_		return outDegrees().union(inDegrees()).groupBy(0).sum(1)__	};return,the,degree,of,all,vertices,in,the,graph,return,a,data,set,of,code,tuple2,vertex,id,degree;public,data,set,tuple2,k,long,value,get,degrees,return,out,degrees,union,in,degrees,group,by,0,sum,1
Graph -> public DataSet<Tuple2<K, LongValue>> getDegrees();1475684776;Return the degree of all vertices in the graph__@return A DataSet of {@code Tuple2<vertexId, degree>};public DataSet<Tuple2<K, LongValue>> getDegrees() {_		return outDegrees().union(inDegrees()).groupBy(0).sum(1)__	};return,the,degree,of,all,vertices,in,the,graph,return,a,data,set,of,code,tuple2,vertex,id,degree;public,data,set,tuple2,k,long,value,get,degrees,return,out,degrees,union,in,degrees,group,by,0,sum,1
Graph -> public DataSet<Tuple2<K, LongValue>> getDegrees();1475685606;Return the degree of all vertices in the graph__@return A DataSet of {@code Tuple2<vertexId, degree>};public DataSet<Tuple2<K, LongValue>> getDegrees() {_		return outDegrees().union(inDegrees()).groupBy(0).sum(1)__	};return,the,degree,of,all,vertices,in,the,graph,return,a,data,set,of,code,tuple2,vertex,id,degree;public,data,set,tuple2,k,long,value,get,degrees,return,out,degrees,union,in,degrees,group,by,0,sum,1
Graph -> public DataSet<Tuple2<K, LongValue>> getDegrees();1481745825;Return the degree of all vertices in the graph__@return A DataSet of {@code Tuple2<vertexId, degree>};public DataSet<Tuple2<K, LongValue>> getDegrees() {_		return outDegrees()_			.union(inDegrees()).name("In- and out-degree")_			.groupBy(0).sum(1).name("Sum")__	};return,the,degree,of,all,vertices,in,the,graph,return,a,data,set,of,code,tuple2,vertex,id,degree;public,data,set,tuple2,k,long,value,get,degrees,return,out,degrees,union,in,degrees,name,in,and,out,degree,group,by,0,sum,1,name,sum
Graph -> public DataSet<Tuple2<K, LongValue>> getDegrees();1481881009;Return the degree of all vertices in the graph__@return A DataSet of {@code Tuple2<vertexId, degree>};public DataSet<Tuple2<K, LongValue>> getDegrees() {_		return outDegrees()_			.union(inDegrees()).name("In- and out-degree")_			.groupBy(0).sum(1).name("Sum")__	};return,the,degree,of,all,vertices,in,the,graph,return,a,data,set,of,code,tuple2,vertex,id,degree;public,data,set,tuple2,k,long,value,get,degrees,return,out,degrees,union,in,degrees,name,in,and,out,degree,group,by,0,sum,1,name,sum
Graph -> public DataSet<Tuple2<K, LongValue>> getDegrees();1484160227;Return the degree of all vertices in the graph__@return A DataSet of {@code Tuple2<vertexId, degree>};public DataSet<Tuple2<K, LongValue>> getDegrees() {_		return outDegrees()_			.union(inDegrees()).name("In- and out-degree")_			.groupBy(0).sum(1).name("Sum")__	};return,the,degree,of,all,vertices,in,the,graph,return,a,data,set,of,code,tuple2,vertex,id,degree;public,data,set,tuple2,k,long,value,get,degrees,return,out,degrees,union,in,degrees,name,in,and,out,degree,group,by,0,sum,1,name,sum
Graph -> public DataSet<Tuple2<K, LongValue>> getDegrees();1484685504;Return the degree of all vertices in the graph__@return A DataSet of {@code Tuple2<vertexId, degree>};public DataSet<Tuple2<K, LongValue>> getDegrees() {_		return outDegrees()_			.union(inDegrees()).name("In- and out-degree")_			.groupBy(0).sum(1).name("Sum")__	};return,the,degree,of,all,vertices,in,the,graph,return,a,data,set,of,code,tuple2,vertex,id,degree;public,data,set,tuple2,k,long,value,get,degrees,return,out,degrees,union,in,degrees,name,in,and,out,degree,group,by,0,sum,1,name,sum
Graph -> public DataSet<Tuple2<K, LongValue>> getDegrees();1489068942;Return the degree of all vertices in the graph__@return A DataSet of {@code Tuple2<vertexId, degree>};public DataSet<Tuple2<K, LongValue>> getDegrees() {_		return outDegrees()_			.union(inDegrees()).name("In- and out-degree")_			.groupBy(0).sum(1).name("Sum")__	};return,the,degree,of,all,vertices,in,the,graph,return,a,data,set,of,code,tuple2,vertex,id,degree;public,data,set,tuple2,k,long,value,get,degrees,return,out,degrees,union,in,degrees,name,in,and,out,degree,group,by,0,sum,1,name,sum
Graph -> public DataSet<Tuple2<K, LongValue>> getDegrees();1490973446;Return the degree of all vertices in the graph__@return A DataSet of {@code Tuple2<vertexId, degree>};public DataSet<Tuple2<K, LongValue>> getDegrees() {_		return outDegrees()_			.union(inDegrees()).name("In- and out-degree")_			.groupBy(0).sum(1).name("Sum")__	};return,the,degree,of,all,vertices,in,the,graph,return,a,data,set,of,code,tuple2,vertex,id,degree;public,data,set,tuple2,k,long,value,get,degrees,return,out,degrees,union,in,degrees,name,in,and,out,degree,group,by,0,sum,1,name,sum
Graph -> public DataSet<Tuple2<K, LongValue>> getDegrees();1495819075;Return the degree of all vertices in the graph.__@return A DataSet of {@code Tuple2<vertexId, degree>};public DataSet<Tuple2<K, LongValue>> getDegrees() {_		return outDegrees()_			.union(inDegrees()).name("In- and out-degree")_			.groupBy(0).sum(1).name("Sum")__	};return,the,degree,of,all,vertices,in,the,graph,return,a,data,set,of,code,tuple2,vertex,id,degree;public,data,set,tuple2,k,long,value,get,degrees,return,out,degrees,union,in,degrees,name,in,and,out,degree,group,by,0,sum,1,name,sum
Graph -> public DataSet<Tuple2<K, LongValue>> getDegrees();1502111816;Return the degree of all vertices in the graph.__@return A DataSet of {@code Tuple2<vertexId, degree>};public DataSet<Tuple2<K, LongValue>> getDegrees() {_		return outDegrees()_			.union(inDegrees()).name("In- and out-degree")_			.groupBy(0).sum(1).name("Sum")__	};return,the,degree,of,all,vertices,in,the,graph,return,a,data,set,of,code,tuple2,vertex,id,degree;public,data,set,tuple2,k,long,value,get,degrees,return,out,degrees,union,in,degrees,name,in,and,out,degree,group,by,0,sum,1,name,sum
Graph -> public <M> Graph<K, VV, EV> runScatterGatherIteration( 			ScatterFunction<K, VV, M, EV> scatterFunction, 			org.apache.flink.graph.spargel.GatherFunction<K, VV, M> gatherFunction, 			int maximumNumberOfIterations);1467306272;Runs a ScatterGather iteration on the graph._No configuration options are provided.__@param scatterFunction the scatter function_@param gatherFunction the gather function_@param maximumNumberOfIterations maximum number of iterations to perform__@return the updated Graph after the scatter-gather iteration has converged or_after maximumNumberOfIterations.;public <M> Graph<K, VV, EV> runScatterGatherIteration(_			ScatterFunction<K, VV, M, EV> scatterFunction,_			org.apache.flink.graph.spargel.GatherFunction<K, VV, M> gatherFunction,_			int maximumNumberOfIterations) {__		return this.runScatterGatherIteration(scatterFunction, gatherFunction,_				maximumNumberOfIterations, null)__	};runs,a,scatter,gather,iteration,on,the,graph,no,configuration,options,are,provided,param,scatter,function,the,scatter,function,param,gather,function,the,gather,function,param,maximum,number,of,iterations,maximum,number,of,iterations,to,perform,return,the,updated,graph,after,the,scatter,gather,iteration,has,converged,or,after,maximum,number,of,iterations;public,m,graph,k,vv,ev,run,scatter,gather,iteration,scatter,function,k,vv,m,ev,scatter,function,org,apache,flink,graph,spargel,gather,function,k,vv,m,gather,function,int,maximum,number,of,iterations,return,this,run,scatter,gather,iteration,scatter,function,gather,function,maximum,number,of,iterations,null
Graph -> public <M> Graph<K, VV, EV> runScatterGatherIteration( 			ScatterFunction<K, VV, M, EV> scatterFunction, 			org.apache.flink.graph.spargel.GatherFunction<K, VV, M> gatherFunction, 			int maximumNumberOfIterations);1470042815;Runs a ScatterGather iteration on the graph._No configuration options are provided.__@param scatterFunction the scatter function_@param gatherFunction the gather function_@param maximumNumberOfIterations maximum number of iterations to perform__@return the updated Graph after the scatter-gather iteration has converged or_after maximumNumberOfIterations.;public <M> Graph<K, VV, EV> runScatterGatherIteration(_			ScatterFunction<K, VV, M, EV> scatterFunction,_			org.apache.flink.graph.spargel.GatherFunction<K, VV, M> gatherFunction,_			int maximumNumberOfIterations) {__		return this.runScatterGatherIteration(scatterFunction, gatherFunction,_				maximumNumberOfIterations, null)__	};runs,a,scatter,gather,iteration,on,the,graph,no,configuration,options,are,provided,param,scatter,function,the,scatter,function,param,gather,function,the,gather,function,param,maximum,number,of,iterations,maximum,number,of,iterations,to,perform,return,the,updated,graph,after,the,scatter,gather,iteration,has,converged,or,after,maximum,number,of,iterations;public,m,graph,k,vv,ev,run,scatter,gather,iteration,scatter,function,k,vv,m,ev,scatter,function,org,apache,flink,graph,spargel,gather,function,k,vv,m,gather,function,int,maximum,number,of,iterations,return,this,run,scatter,gather,iteration,scatter,function,gather,function,maximum,number,of,iterations,null
Graph -> public <M> Graph<K, VV, EV> runScatterGatherIteration( 			ScatterFunction<K, VV, M, EV> scatterFunction, 			org.apache.flink.graph.spargel.GatherFunction<K, VV, M> gatherFunction, 			int maximumNumberOfIterations);1475684776;Runs a ScatterGather iteration on the graph._No configuration options are provided.__@param scatterFunction the scatter function_@param gatherFunction the gather function_@param maximumNumberOfIterations maximum number of iterations to perform__@return the updated Graph after the scatter-gather iteration has converged or_after maximumNumberOfIterations.;public <M> Graph<K, VV, EV> runScatterGatherIteration(_			ScatterFunction<K, VV, M, EV> scatterFunction,_			org.apache.flink.graph.spargel.GatherFunction<K, VV, M> gatherFunction,_			int maximumNumberOfIterations) {__		return this.runScatterGatherIteration(scatterFunction, gatherFunction,_				maximumNumberOfIterations, null)__	};runs,a,scatter,gather,iteration,on,the,graph,no,configuration,options,are,provided,param,scatter,function,the,scatter,function,param,gather,function,the,gather,function,param,maximum,number,of,iterations,maximum,number,of,iterations,to,perform,return,the,updated,graph,after,the,scatter,gather,iteration,has,converged,or,after,maximum,number,of,iterations;public,m,graph,k,vv,ev,run,scatter,gather,iteration,scatter,function,k,vv,m,ev,scatter,function,org,apache,flink,graph,spargel,gather,function,k,vv,m,gather,function,int,maximum,number,of,iterations,return,this,run,scatter,gather,iteration,scatter,function,gather,function,maximum,number,of,iterations,null
Graph -> public <M> Graph<K, VV, EV> runScatterGatherIteration( 			ScatterFunction<K, VV, M, EV> scatterFunction, 			org.apache.flink.graph.spargel.GatherFunction<K, VV, M> gatherFunction, 			int maximumNumberOfIterations);1475685606;Runs a ScatterGather iteration on the graph._No configuration options are provided.__@param scatterFunction the scatter function_@param gatherFunction the gather function_@param maximumNumberOfIterations maximum number of iterations to perform__@return the updated Graph after the scatter-gather iteration has converged or_after maximumNumberOfIterations.;public <M> Graph<K, VV, EV> runScatterGatherIteration(_			ScatterFunction<K, VV, M, EV> scatterFunction,_			org.apache.flink.graph.spargel.GatherFunction<K, VV, M> gatherFunction,_			int maximumNumberOfIterations) {__		return this.runScatterGatherIteration(scatterFunction, gatherFunction,_				maximumNumberOfIterations, null)__	};runs,a,scatter,gather,iteration,on,the,graph,no,configuration,options,are,provided,param,scatter,function,the,scatter,function,param,gather,function,the,gather,function,param,maximum,number,of,iterations,maximum,number,of,iterations,to,perform,return,the,updated,graph,after,the,scatter,gather,iteration,has,converged,or,after,maximum,number,of,iterations;public,m,graph,k,vv,ev,run,scatter,gather,iteration,scatter,function,k,vv,m,ev,scatter,function,org,apache,flink,graph,spargel,gather,function,k,vv,m,gather,function,int,maximum,number,of,iterations,return,this,run,scatter,gather,iteration,scatter,function,gather,function,maximum,number,of,iterations,null
Graph -> public <M> Graph<K, VV, EV> runScatterGatherIteration( 			ScatterFunction<K, VV, M, EV> scatterFunction, 			org.apache.flink.graph.spargel.GatherFunction<K, VV, M> gatherFunction, 			int maximumNumberOfIterations);1481745825;Runs a ScatterGather iteration on the graph._No configuration options are provided.__@param scatterFunction the scatter function_@param gatherFunction the gather function_@param maximumNumberOfIterations maximum number of iterations to perform__@return the updated Graph after the scatter-gather iteration has converged or_after maximumNumberOfIterations.;public <M> Graph<K, VV, EV> runScatterGatherIteration(_			ScatterFunction<K, VV, M, EV> scatterFunction,_			org.apache.flink.graph.spargel.GatherFunction<K, VV, M> gatherFunction,_			int maximumNumberOfIterations) {__		return this.runScatterGatherIteration(scatterFunction, gatherFunction,_				maximumNumberOfIterations, null)__	};runs,a,scatter,gather,iteration,on,the,graph,no,configuration,options,are,provided,param,scatter,function,the,scatter,function,param,gather,function,the,gather,function,param,maximum,number,of,iterations,maximum,number,of,iterations,to,perform,return,the,updated,graph,after,the,scatter,gather,iteration,has,converged,or,after,maximum,number,of,iterations;public,m,graph,k,vv,ev,run,scatter,gather,iteration,scatter,function,k,vv,m,ev,scatter,function,org,apache,flink,graph,spargel,gather,function,k,vv,m,gather,function,int,maximum,number,of,iterations,return,this,run,scatter,gather,iteration,scatter,function,gather,function,maximum,number,of,iterations,null
Graph -> public <M> Graph<K, VV, EV> runScatterGatherIteration( 			ScatterFunction<K, VV, M, EV> scatterFunction, 			org.apache.flink.graph.spargel.GatherFunction<K, VV, M> gatherFunction, 			int maximumNumberOfIterations);1481881009;Runs a ScatterGather iteration on the graph._No configuration options are provided.__@param scatterFunction the scatter function_@param gatherFunction the gather function_@param maximumNumberOfIterations maximum number of iterations to perform__@return the updated Graph after the scatter-gather iteration has converged or_after maximumNumberOfIterations.;public <M> Graph<K, VV, EV> runScatterGatherIteration(_			ScatterFunction<K, VV, M, EV> scatterFunction,_			org.apache.flink.graph.spargel.GatherFunction<K, VV, M> gatherFunction,_			int maximumNumberOfIterations) {__		return this.runScatterGatherIteration(scatterFunction, gatherFunction,_				maximumNumberOfIterations, null)__	};runs,a,scatter,gather,iteration,on,the,graph,no,configuration,options,are,provided,param,scatter,function,the,scatter,function,param,gather,function,the,gather,function,param,maximum,number,of,iterations,maximum,number,of,iterations,to,perform,return,the,updated,graph,after,the,scatter,gather,iteration,has,converged,or,after,maximum,number,of,iterations;public,m,graph,k,vv,ev,run,scatter,gather,iteration,scatter,function,k,vv,m,ev,scatter,function,org,apache,flink,graph,spargel,gather,function,k,vv,m,gather,function,int,maximum,number,of,iterations,return,this,run,scatter,gather,iteration,scatter,function,gather,function,maximum,number,of,iterations,null
Graph -> public <M> Graph<K, VV, EV> runScatterGatherIteration( 			ScatterFunction<K, VV, M, EV> scatterFunction, 			org.apache.flink.graph.spargel.GatherFunction<K, VV, M> gatherFunction, 			int maximumNumberOfIterations);1484160227;Runs a ScatterGather iteration on the graph._No configuration options are provided.__@param scatterFunction the scatter function_@param gatherFunction the gather function_@param maximumNumberOfIterations maximum number of iterations to perform__@return the updated Graph after the scatter-gather iteration has converged or_after maximumNumberOfIterations.;public <M> Graph<K, VV, EV> runScatterGatherIteration(_			ScatterFunction<K, VV, M, EV> scatterFunction,_			org.apache.flink.graph.spargel.GatherFunction<K, VV, M> gatherFunction,_			int maximumNumberOfIterations) {__		return this.runScatterGatherIteration(scatterFunction, gatherFunction,_				maximumNumberOfIterations, null)__	};runs,a,scatter,gather,iteration,on,the,graph,no,configuration,options,are,provided,param,scatter,function,the,scatter,function,param,gather,function,the,gather,function,param,maximum,number,of,iterations,maximum,number,of,iterations,to,perform,return,the,updated,graph,after,the,scatter,gather,iteration,has,converged,or,after,maximum,number,of,iterations;public,m,graph,k,vv,ev,run,scatter,gather,iteration,scatter,function,k,vv,m,ev,scatter,function,org,apache,flink,graph,spargel,gather,function,k,vv,m,gather,function,int,maximum,number,of,iterations,return,this,run,scatter,gather,iteration,scatter,function,gather,function,maximum,number,of,iterations,null
Graph -> public <M> Graph<K, VV, EV> runScatterGatherIteration( 			ScatterFunction<K, VV, M, EV> scatterFunction, 			org.apache.flink.graph.spargel.GatherFunction<K, VV, M> gatherFunction, 			int maximumNumberOfIterations);1484685504;Runs a ScatterGather iteration on the graph._No configuration options are provided.__@param scatterFunction the scatter function_@param gatherFunction the gather function_@param maximumNumberOfIterations maximum number of iterations to perform__@return the updated Graph after the scatter-gather iteration has converged or_after maximumNumberOfIterations.;public <M> Graph<K, VV, EV> runScatterGatherIteration(_			ScatterFunction<K, VV, M, EV> scatterFunction,_			org.apache.flink.graph.spargel.GatherFunction<K, VV, M> gatherFunction,_			int maximumNumberOfIterations) {__		return this.runScatterGatherIteration(scatterFunction, gatherFunction,_				maximumNumberOfIterations, null)__	};runs,a,scatter,gather,iteration,on,the,graph,no,configuration,options,are,provided,param,scatter,function,the,scatter,function,param,gather,function,the,gather,function,param,maximum,number,of,iterations,maximum,number,of,iterations,to,perform,return,the,updated,graph,after,the,scatter,gather,iteration,has,converged,or,after,maximum,number,of,iterations;public,m,graph,k,vv,ev,run,scatter,gather,iteration,scatter,function,k,vv,m,ev,scatter,function,org,apache,flink,graph,spargel,gather,function,k,vv,m,gather,function,int,maximum,number,of,iterations,return,this,run,scatter,gather,iteration,scatter,function,gather,function,maximum,number,of,iterations,null
Graph -> public <M> Graph<K, VV, EV> runScatterGatherIteration( 			ScatterFunction<K, VV, M, EV> scatterFunction, 			org.apache.flink.graph.spargel.GatherFunction<K, VV, M> gatherFunction, 			int maximumNumberOfIterations);1489068942;Runs a ScatterGather iteration on the graph._No configuration options are provided.__@param scatterFunction the scatter function_@param gatherFunction the gather function_@param maximumNumberOfIterations maximum number of iterations to perform__@return the updated Graph after the scatter-gather iteration has converged or_after maximumNumberOfIterations.;public <M> Graph<K, VV, EV> runScatterGatherIteration(_			ScatterFunction<K, VV, M, EV> scatterFunction,_			org.apache.flink.graph.spargel.GatherFunction<K, VV, M> gatherFunction,_			int maximumNumberOfIterations) {__		return this.runScatterGatherIteration(scatterFunction, gatherFunction,_				maximumNumberOfIterations, null)__	};runs,a,scatter,gather,iteration,on,the,graph,no,configuration,options,are,provided,param,scatter,function,the,scatter,function,param,gather,function,the,gather,function,param,maximum,number,of,iterations,maximum,number,of,iterations,to,perform,return,the,updated,graph,after,the,scatter,gather,iteration,has,converged,or,after,maximum,number,of,iterations;public,m,graph,k,vv,ev,run,scatter,gather,iteration,scatter,function,k,vv,m,ev,scatter,function,org,apache,flink,graph,spargel,gather,function,k,vv,m,gather,function,int,maximum,number,of,iterations,return,this,run,scatter,gather,iteration,scatter,function,gather,function,maximum,number,of,iterations,null
Graph -> public <M> Graph<K, VV, EV> runScatterGatherIteration( 			ScatterFunction<K, VV, M, EV> scatterFunction, 			org.apache.flink.graph.spargel.GatherFunction<K, VV, M> gatherFunction, 			int maximumNumberOfIterations);1490973446;Runs a ScatterGather iteration on the graph._No configuration options are provided.__@param scatterFunction the scatter function_@param gatherFunction the gather function_@param maximumNumberOfIterations maximum number of iterations to perform__@return the updated Graph after the scatter-gather iteration has converged or_after maximumNumberOfIterations.;public <M> Graph<K, VV, EV> runScatterGatherIteration(_			ScatterFunction<K, VV, M, EV> scatterFunction,_			org.apache.flink.graph.spargel.GatherFunction<K, VV, M> gatherFunction,_			int maximumNumberOfIterations) {__		return this.runScatterGatherIteration(scatterFunction, gatherFunction,_				maximumNumberOfIterations, null)__	};runs,a,scatter,gather,iteration,on,the,graph,no,configuration,options,are,provided,param,scatter,function,the,scatter,function,param,gather,function,the,gather,function,param,maximum,number,of,iterations,maximum,number,of,iterations,to,perform,return,the,updated,graph,after,the,scatter,gather,iteration,has,converged,or,after,maximum,number,of,iterations;public,m,graph,k,vv,ev,run,scatter,gather,iteration,scatter,function,k,vv,m,ev,scatter,function,org,apache,flink,graph,spargel,gather,function,k,vv,m,gather,function,int,maximum,number,of,iterations,return,this,run,scatter,gather,iteration,scatter,function,gather,function,maximum,number,of,iterations,null
Graph -> public <M> Graph<K, VV, EV> runScatterGatherIteration( 			ScatterFunction<K, VV, M, EV> scatterFunction, 			org.apache.flink.graph.spargel.GatherFunction<K, VV, M> gatherFunction, 			int maximumNumberOfIterations);1495819075;Runs a ScatterGather iteration on the graph._No configuration options are provided.__@param scatterFunction the scatter function_@param gatherFunction the gather function_@param maximumNumberOfIterations maximum number of iterations to perform__@return the updated Graph after the scatter-gather iteration has converged or_after maximumNumberOfIterations.;public <M> Graph<K, VV, EV> runScatterGatherIteration(_			ScatterFunction<K, VV, M, EV> scatterFunction,_			org.apache.flink.graph.spargel.GatherFunction<K, VV, M> gatherFunction,_			int maximumNumberOfIterations) {__		return this.runScatterGatherIteration(scatterFunction, gatherFunction,_				maximumNumberOfIterations, null)__	};runs,a,scatter,gather,iteration,on,the,graph,no,configuration,options,are,provided,param,scatter,function,the,scatter,function,param,gather,function,the,gather,function,param,maximum,number,of,iterations,maximum,number,of,iterations,to,perform,return,the,updated,graph,after,the,scatter,gather,iteration,has,converged,or,after,maximum,number,of,iterations;public,m,graph,k,vv,ev,run,scatter,gather,iteration,scatter,function,k,vv,m,ev,scatter,function,org,apache,flink,graph,spargel,gather,function,k,vv,m,gather,function,int,maximum,number,of,iterations,return,this,run,scatter,gather,iteration,scatter,function,gather,function,maximum,number,of,iterations,null
Graph -> public <M> Graph<K, VV, EV> runScatterGatherIteration( 			ScatterFunction<K, VV, M, EV> scatterFunction, 			org.apache.flink.graph.spargel.GatherFunction<K, VV, M> gatherFunction, 			int maximumNumberOfIterations);1502111816;Runs a ScatterGather iteration on the graph._No configuration options are provided.__@param scatterFunction the scatter function_@param gatherFunction the gather function_@param maximumNumberOfIterations maximum number of iterations to perform__@return the updated Graph after the scatter-gather iteration has converged or_after maximumNumberOfIterations.;public <M> Graph<K, VV, EV> runScatterGatherIteration(_			ScatterFunction<K, VV, M, EV> scatterFunction,_			org.apache.flink.graph.spargel.GatherFunction<K, VV, M> gatherFunction,_			int maximumNumberOfIterations) {__		return this.runScatterGatherIteration(scatterFunction, gatherFunction,_				maximumNumberOfIterations, null)__	};runs,a,scatter,gather,iteration,on,the,graph,no,configuration,options,are,provided,param,scatter,function,the,scatter,function,param,gather,function,the,gather,function,param,maximum,number,of,iterations,maximum,number,of,iterations,to,perform,return,the,updated,graph,after,the,scatter,gather,iteration,has,converged,or,after,maximum,number,of,iterations;public,m,graph,k,vv,ev,run,scatter,gather,iteration,scatter,function,k,vv,m,ev,scatter,function,org,apache,flink,graph,spargel,gather,function,k,vv,m,gather,function,int,maximum,number,of,iterations,return,this,run,scatter,gather,iteration,scatter,function,gather,function,maximum,number,of,iterations,null
Graph -> public static <K, VV> Graph<K, VV, NullValue> fromTuple2DataSet(DataSet<Tuple2<K, K>> edges, 			final MapFunction<K, VV> vertexValueInitializer, ExecutionEnvironment context);1445261977;Creates a graph from a DataSet of Tuple2 objects for edges._Each Tuple2 will become one Edge, where the source ID will be the first field of the Tuple2_and the target ID will be the second field of the Tuple2._<p>_Edge value types will be set to NullValue._Vertex values can be initialized by applying a user-defined map function on the vertex IDs.__@param edges a DataSet of Tuple2, where the first field corresponds to the source ID_and the second field corresponds to the target ID._@param vertexValueInitializer the mapper function that initializes the vertex values._It allows to apply a map transformation on the vertex ID to produce an initial vertex value._@param context the flink execution environment._@return the newly created graph.;public static <K, VV> Graph<K, VV, NullValue> fromTuple2DataSet(DataSet<Tuple2<K, K>> edges,_			final MapFunction<K, VV> vertexValueInitializer, ExecutionEnvironment context) {__		DataSet<Edge<K, NullValue>> edgeDataSet = edges.map(_				new MapFunction<Tuple2<K, K>, Edge<K, NullValue>>() {__					public Edge<K, NullValue> map(Tuple2<K, K> input) {_						return new Edge<K, NullValue>(input.f0, input.f1, NullValue.getInstance())__					}_				}).withForwardedFields("f0_ f1")__		return fromDataSet(edgeDataSet, vertexValueInitializer, context)__	};creates,a,graph,from,a,data,set,of,tuple2,objects,for,edges,each,tuple2,will,become,one,edge,where,the,source,id,will,be,the,first,field,of,the,tuple2,and,the,target,id,will,be,the,second,field,of,the,tuple2,p,edge,value,types,will,be,set,to,null,value,vertex,values,can,be,initialized,by,applying,a,user,defined,map,function,on,the,vertex,ids,param,edges,a,data,set,of,tuple2,where,the,first,field,corresponds,to,the,source,id,and,the,second,field,corresponds,to,the,target,id,param,vertex,value,initializer,the,mapper,function,that,initializes,the,vertex,values,it,allows,to,apply,a,map,transformation,on,the,vertex,id,to,produce,an,initial,vertex,value,param,context,the,flink,execution,environment,return,the,newly,created,graph;public,static,k,vv,graph,k,vv,null,value,from,tuple2data,set,data,set,tuple2,k,k,edges,final,map,function,k,vv,vertex,value,initializer,execution,environment,context,data,set,edge,k,null,value,edge,data,set,edges,map,new,map,function,tuple2,k,k,edge,k,null,value,public,edge,k,null,value,map,tuple2,k,k,input,return,new,edge,k,null,value,input,f0,input,f1,null,value,get,instance,with,forwarded,fields,f0,f1,return,from,data,set,edge,data,set,vertex,value,initializer,context
Graph -> public static <K, VV> Graph<K, VV, NullValue> fromTuple2DataSet(DataSet<Tuple2<K, K>> edges, 			final MapFunction<K, VV> vertexValueInitializer, ExecutionEnvironment context);1445854323;Creates a graph from a DataSet of Tuple2 objects for edges._Each Tuple2 will become one Edge, where the source ID will be the first field of the Tuple2_and the target ID will be the second field of the Tuple2._<p>_Edge value types will be set to NullValue._Vertex values can be initialized by applying a user-defined map function on the vertex IDs.__@param edges a DataSet of Tuple2, where the first field corresponds to the source ID_and the second field corresponds to the target ID._@param vertexValueInitializer the mapper function that initializes the vertex values._It allows to apply a map transformation on the vertex ID to produce an initial vertex value._@param context the flink execution environment._@return the newly created graph.;public static <K, VV> Graph<K, VV, NullValue> fromTuple2DataSet(DataSet<Tuple2<K, K>> edges,_			final MapFunction<K, VV> vertexValueInitializer, ExecutionEnvironment context) {__		DataSet<Edge<K, NullValue>> edgeDataSet = edges.map(_				new MapFunction<Tuple2<K, K>, Edge<K, NullValue>>() {__					public Edge<K, NullValue> map(Tuple2<K, K> input) {_						return new Edge<K, NullValue>(input.f0, input.f1, NullValue.getInstance())__					}_				}).withForwardedFields("f0_ f1")__		return fromDataSet(edgeDataSet, vertexValueInitializer, context)__	};creates,a,graph,from,a,data,set,of,tuple2,objects,for,edges,each,tuple2,will,become,one,edge,where,the,source,id,will,be,the,first,field,of,the,tuple2,and,the,target,id,will,be,the,second,field,of,the,tuple2,p,edge,value,types,will,be,set,to,null,value,vertex,values,can,be,initialized,by,applying,a,user,defined,map,function,on,the,vertex,ids,param,edges,a,data,set,of,tuple2,where,the,first,field,corresponds,to,the,source,id,and,the,second,field,corresponds,to,the,target,id,param,vertex,value,initializer,the,mapper,function,that,initializes,the,vertex,values,it,allows,to,apply,a,map,transformation,on,the,vertex,id,to,produce,an,initial,vertex,value,param,context,the,flink,execution,environment,return,the,newly,created,graph;public,static,k,vv,graph,k,vv,null,value,from,tuple2data,set,data,set,tuple2,k,k,edges,final,map,function,k,vv,vertex,value,initializer,execution,environment,context,data,set,edge,k,null,value,edge,data,set,edges,map,new,map,function,tuple2,k,k,edge,k,null,value,public,edge,k,null,value,map,tuple2,k,k,input,return,new,edge,k,null,value,input,f0,input,f1,null,value,get,instance,with,forwarded,fields,f0,f1,return,from,data,set,edge,data,set,vertex,value,initializer,context
Graph -> public static <K, VV> Graph<K, VV, NullValue> fromTuple2DataSet(DataSet<Tuple2<K, K>> edges, 			final MapFunction<K, VV> vertexValueInitializer, ExecutionEnvironment context);1446112342;Creates a graph from a DataSet of Tuple2 objects for edges._Each Tuple2 will become one Edge, where the source ID will be the first field of the Tuple2_and the target ID will be the second field of the Tuple2._<p>_Edge value types will be set to NullValue._Vertex values can be initialized by applying a user-defined map function on the vertex IDs.__@param edges a DataSet of Tuple2, where the first field corresponds to the source ID_and the second field corresponds to the target ID._@param vertexValueInitializer the mapper function that initializes the vertex values._It allows to apply a map transformation on the vertex ID to produce an initial vertex value._@param context the flink execution environment._@return the newly created graph.;public static <K, VV> Graph<K, VV, NullValue> fromTuple2DataSet(DataSet<Tuple2<K, K>> edges,_			final MapFunction<K, VV> vertexValueInitializer, ExecutionEnvironment context) {__		DataSet<Edge<K, NullValue>> edgeDataSet = edges.map(_				new MapFunction<Tuple2<K, K>, Edge<K, NullValue>>() {__					public Edge<K, NullValue> map(Tuple2<K, K> input) {_						return new Edge<K, NullValue>(input.f0, input.f1, NullValue.getInstance())__					}_				}).withForwardedFields("f0_ f1")__		return fromDataSet(edgeDataSet, vertexValueInitializer, context)__	};creates,a,graph,from,a,data,set,of,tuple2,objects,for,edges,each,tuple2,will,become,one,edge,where,the,source,id,will,be,the,first,field,of,the,tuple2,and,the,target,id,will,be,the,second,field,of,the,tuple2,p,edge,value,types,will,be,set,to,null,value,vertex,values,can,be,initialized,by,applying,a,user,defined,map,function,on,the,vertex,ids,param,edges,a,data,set,of,tuple2,where,the,first,field,corresponds,to,the,source,id,and,the,second,field,corresponds,to,the,target,id,param,vertex,value,initializer,the,mapper,function,that,initializes,the,vertex,values,it,allows,to,apply,a,map,transformation,on,the,vertex,id,to,produce,an,initial,vertex,value,param,context,the,flink,execution,environment,return,the,newly,created,graph;public,static,k,vv,graph,k,vv,null,value,from,tuple2data,set,data,set,tuple2,k,k,edges,final,map,function,k,vv,vertex,value,initializer,execution,environment,context,data,set,edge,k,null,value,edge,data,set,edges,map,new,map,function,tuple2,k,k,edge,k,null,value,public,edge,k,null,value,map,tuple2,k,k,input,return,new,edge,k,null,value,input,f0,input,f1,null,value,get,instance,with,forwarded,fields,f0,f1,return,from,data,set,edge,data,set,vertex,value,initializer,context
Graph -> public static <K, VV> Graph<K, VV, NullValue> fromTuple2DataSet(DataSet<Tuple2<K, K>> edges, 			final MapFunction<K, VV> vertexValueInitializer, ExecutionEnvironment context);1447073368;Creates a graph from a DataSet of Tuple2 objects for edges._Each Tuple2 will become one Edge, where the source ID will be the first field of the Tuple2_and the target ID will be the second field of the Tuple2._<p>_Edge value types will be set to NullValue._Vertex values can be initialized by applying a user-defined map function on the vertex IDs.__@param edges a DataSet of Tuple2, where the first field corresponds to the source ID_and the second field corresponds to the target ID._@param vertexValueInitializer the mapper function that initializes the vertex values._It allows to apply a map transformation on the vertex ID to produce an initial vertex value._@param context the flink execution environment._@return the newly created graph.;public static <K, VV> Graph<K, VV, NullValue> fromTuple2DataSet(DataSet<Tuple2<K, K>> edges,_			final MapFunction<K, VV> vertexValueInitializer, ExecutionEnvironment context) {__		DataSet<Edge<K, NullValue>> edgeDataSet = edges.map(_				new MapFunction<Tuple2<K, K>, Edge<K, NullValue>>() {__					public Edge<K, NullValue> map(Tuple2<K, K> input) {_						return new Edge<K, NullValue>(input.f0, input.f1, NullValue.getInstance())__					}_				}).withForwardedFields("f0_ f1")__		return fromDataSet(edgeDataSet, vertexValueInitializer, context)__	};creates,a,graph,from,a,data,set,of,tuple2,objects,for,edges,each,tuple2,will,become,one,edge,where,the,source,id,will,be,the,first,field,of,the,tuple2,and,the,target,id,will,be,the,second,field,of,the,tuple2,p,edge,value,types,will,be,set,to,null,value,vertex,values,can,be,initialized,by,applying,a,user,defined,map,function,on,the,vertex,ids,param,edges,a,data,set,of,tuple2,where,the,first,field,corresponds,to,the,source,id,and,the,second,field,corresponds,to,the,target,id,param,vertex,value,initializer,the,mapper,function,that,initializes,the,vertex,values,it,allows,to,apply,a,map,transformation,on,the,vertex,id,to,produce,an,initial,vertex,value,param,context,the,flink,execution,environment,return,the,newly,created,graph;public,static,k,vv,graph,k,vv,null,value,from,tuple2data,set,data,set,tuple2,k,k,edges,final,map,function,k,vv,vertex,value,initializer,execution,environment,context,data,set,edge,k,null,value,edge,data,set,edges,map,new,map,function,tuple2,k,k,edge,k,null,value,public,edge,k,null,value,map,tuple2,k,k,input,return,new,edge,k,null,value,input,f0,input,f1,null,value,get,instance,with,forwarded,fields,f0,f1,return,from,data,set,edge,data,set,vertex,value,initializer,context
Graph -> public static <K, VV> Graph<K, VV, NullValue> fromTuple2DataSet(DataSet<Tuple2<K, K>> edges, 			final MapFunction<K, VV> vertexValueInitializer, ExecutionEnvironment context);1454404649;Creates a graph from a DataSet of Tuple2 objects for edges._Each Tuple2 will become one Edge, where the source ID will be the first field of the Tuple2_and the target ID will be the second field of the Tuple2._<p>_Edge value types will be set to NullValue._Vertex values can be initialized by applying a user-defined map function on the vertex IDs.__@param edges a DataSet of Tuple2, where the first field corresponds to the source ID_and the second field corresponds to the target ID._@param vertexValueInitializer the mapper function that initializes the vertex values._It allows to apply a map transformation on the vertex ID to produce an initial vertex value._@param context the flink execution environment._@return the newly created graph.;public static <K, VV> Graph<K, VV, NullValue> fromTuple2DataSet(DataSet<Tuple2<K, K>> edges,_			final MapFunction<K, VV> vertexValueInitializer, ExecutionEnvironment context) {__		DataSet<Edge<K, NullValue>> edgeDataSet = edges.map(_				new MapFunction<Tuple2<K, K>, Edge<K, NullValue>>() {__					public Edge<K, NullValue> map(Tuple2<K, K> input) {_						return new Edge<K, NullValue>(input.f0, input.f1, NullValue.getInstance())__					}_				}).withForwardedFields("f0_ f1")__		return fromDataSet(edgeDataSet, vertexValueInitializer, context)__	};creates,a,graph,from,a,data,set,of,tuple2,objects,for,edges,each,tuple2,will,become,one,edge,where,the,source,id,will,be,the,first,field,of,the,tuple2,and,the,target,id,will,be,the,second,field,of,the,tuple2,p,edge,value,types,will,be,set,to,null,value,vertex,values,can,be,initialized,by,applying,a,user,defined,map,function,on,the,vertex,ids,param,edges,a,data,set,of,tuple2,where,the,first,field,corresponds,to,the,source,id,and,the,second,field,corresponds,to,the,target,id,param,vertex,value,initializer,the,mapper,function,that,initializes,the,vertex,values,it,allows,to,apply,a,map,transformation,on,the,vertex,id,to,produce,an,initial,vertex,value,param,context,the,flink,execution,environment,return,the,newly,created,graph;public,static,k,vv,graph,k,vv,null,value,from,tuple2data,set,data,set,tuple2,k,k,edges,final,map,function,k,vv,vertex,value,initializer,execution,environment,context,data,set,edge,k,null,value,edge,data,set,edges,map,new,map,function,tuple2,k,k,edge,k,null,value,public,edge,k,null,value,map,tuple2,k,k,input,return,new,edge,k,null,value,input,f0,input,f1,null,value,get,instance,with,forwarded,fields,f0,f1,return,from,data,set,edge,data,set,vertex,value,initializer,context
Graph -> public static <K, VV> Graph<K, VV, NullValue> fromTuple2DataSet(DataSet<Tuple2<K, K>> edges, 			final MapFunction<K, VV> vertexValueInitializer, ExecutionEnvironment context);1458583829;Creates a graph from a DataSet of Tuple2 objects for edges._Each Tuple2 will become one Edge, where the source ID will be the first field of the Tuple2_and the target ID will be the second field of the Tuple2._<p>_Edge value types will be set to NullValue._Vertex values can be initialized by applying a user-defined map function on the vertex IDs.__@param edges a DataSet of Tuple2, where the first field corresponds to the source ID_and the second field corresponds to the target ID._@param vertexValueInitializer the mapper function that initializes the vertex values._It allows to apply a map transformation on the vertex ID to produce an initial vertex value._@param context the flink execution environment._@return the newly created graph.;public static <K, VV> Graph<K, VV, NullValue> fromTuple2DataSet(DataSet<Tuple2<K, K>> edges,_			final MapFunction<K, VV> vertexValueInitializer, ExecutionEnvironment context) {__		DataSet<Edge<K, NullValue>> edgeDataSet = edges.map(_				new MapFunction<Tuple2<K, K>, Edge<K, NullValue>>() {__					public Edge<K, NullValue> map(Tuple2<K, K> input) {_						return new Edge<K, NullValue>(input.f0, input.f1, NullValue.getInstance())__					}_				}).withForwardedFields("f0_ f1")__		return fromDataSet(edgeDataSet, vertexValueInitializer, context)__	};creates,a,graph,from,a,data,set,of,tuple2,objects,for,edges,each,tuple2,will,become,one,edge,where,the,source,id,will,be,the,first,field,of,the,tuple2,and,the,target,id,will,be,the,second,field,of,the,tuple2,p,edge,value,types,will,be,set,to,null,value,vertex,values,can,be,initialized,by,applying,a,user,defined,map,function,on,the,vertex,ids,param,edges,a,data,set,of,tuple2,where,the,first,field,corresponds,to,the,source,id,and,the,second,field,corresponds,to,the,target,id,param,vertex,value,initializer,the,mapper,function,that,initializes,the,vertex,values,it,allows,to,apply,a,map,transformation,on,the,vertex,id,to,produce,an,initial,vertex,value,param,context,the,flink,execution,environment,return,the,newly,created,graph;public,static,k,vv,graph,k,vv,null,value,from,tuple2data,set,data,set,tuple2,k,k,edges,final,map,function,k,vv,vertex,value,initializer,execution,environment,context,data,set,edge,k,null,value,edge,data,set,edges,map,new,map,function,tuple2,k,k,edge,k,null,value,public,edge,k,null,value,map,tuple2,k,k,input,return,new,edge,k,null,value,input,f0,input,f1,null,value,get,instance,with,forwarded,fields,f0,f1,return,from,data,set,edge,data,set,vertex,value,initializer,context
Graph -> public static <K, VV> Graph<K, VV, NullValue> fromTuple2DataSet(DataSet<Tuple2<K, K>> edges, 			final MapFunction<K, VV> vertexValueInitializer, ExecutionEnvironment context);1458583829;Creates a graph from a DataSet of Tuple2 objects for edges._Each Tuple2 will become one Edge, where the source ID will be the first field of the Tuple2_and the target ID will be the second field of the Tuple2._<p>_Edge value types will be set to NullValue._Vertex values can be initialized by applying a user-defined map function on the vertex IDs.__@param edges a DataSet of Tuple2, where the first field corresponds to the source ID_and the second field corresponds to the target ID._@param vertexValueInitializer the mapper function that initializes the vertex values._It allows to apply a map transformation on the vertex ID to produce an initial vertex value._@param context the flink execution environment._@return the newly created graph.;public static <K, VV> Graph<K, VV, NullValue> fromTuple2DataSet(DataSet<Tuple2<K, K>> edges,_			final MapFunction<K, VV> vertexValueInitializer, ExecutionEnvironment context) {__		DataSet<Edge<K, NullValue>> edgeDataSet = edges.map(_				new MapFunction<Tuple2<K, K>, Edge<K, NullValue>>() {__					public Edge<K, NullValue> map(Tuple2<K, K> input) {_						return new Edge<K, NullValue>(input.f0, input.f1, NullValue.getInstance())__					}_				}).withForwardedFields("f0_ f1")__		return fromDataSet(edgeDataSet, vertexValueInitializer, context)__	};creates,a,graph,from,a,data,set,of,tuple2,objects,for,edges,each,tuple2,will,become,one,edge,where,the,source,id,will,be,the,first,field,of,the,tuple2,and,the,target,id,will,be,the,second,field,of,the,tuple2,p,edge,value,types,will,be,set,to,null,value,vertex,values,can,be,initialized,by,applying,a,user,defined,map,function,on,the,vertex,ids,param,edges,a,data,set,of,tuple2,where,the,first,field,corresponds,to,the,source,id,and,the,second,field,corresponds,to,the,target,id,param,vertex,value,initializer,the,mapper,function,that,initializes,the,vertex,values,it,allows,to,apply,a,map,transformation,on,the,vertex,id,to,produce,an,initial,vertex,value,param,context,the,flink,execution,environment,return,the,newly,created,graph;public,static,k,vv,graph,k,vv,null,value,from,tuple2data,set,data,set,tuple2,k,k,edges,final,map,function,k,vv,vertex,value,initializer,execution,environment,context,data,set,edge,k,null,value,edge,data,set,edges,map,new,map,function,tuple2,k,k,edge,k,null,value,public,edge,k,null,value,map,tuple2,k,k,input,return,new,edge,k,null,value,input,f0,input,f1,null,value,get,instance,with,forwarded,fields,f0,f1,return,from,data,set,edge,data,set,vertex,value,initializer,context
Graph -> public static <K, VV> Graph<K, VV, NullValue> fromTuple2DataSet(DataSet<Tuple2<K, K>> edges, 			final MapFunction<K, VV> vertexValueInitializer, ExecutionEnvironment context);1462100316;Creates a graph from a DataSet of Tuple2 objects for edges._Each Tuple2 will become one Edge, where the source ID will be the first field of the Tuple2_and the target ID will be the second field of the Tuple2._<p>_Edge value types will be set to NullValue._Vertex values can be initialized by applying a user-defined map function on the vertex IDs.__@param edges a DataSet of Tuple2, where the first field corresponds to the source ID_and the second field corresponds to the target ID._@param vertexValueInitializer the mapper function that initializes the vertex values._It allows to apply a map transformation on the vertex ID to produce an initial vertex value._@param context the flink execution environment._@return the newly created graph.;public static <K, VV> Graph<K, VV, NullValue> fromTuple2DataSet(DataSet<Tuple2<K, K>> edges,_			final MapFunction<K, VV> vertexValueInitializer, ExecutionEnvironment context) {__		DataSet<Edge<K, NullValue>> edgeDataSet = edges.map(_				new MapFunction<Tuple2<K, K>, Edge<K, NullValue>>() {__					public Edge<K, NullValue> map(Tuple2<K, K> input) {_						return new Edge<K, NullValue>(input.f0, input.f1, NullValue.getInstance())__					}_				}).withForwardedFields("f0_ f1")__		return fromDataSet(edgeDataSet, vertexValueInitializer, context)__	};creates,a,graph,from,a,data,set,of,tuple2,objects,for,edges,each,tuple2,will,become,one,edge,where,the,source,id,will,be,the,first,field,of,the,tuple2,and,the,target,id,will,be,the,second,field,of,the,tuple2,p,edge,value,types,will,be,set,to,null,value,vertex,values,can,be,initialized,by,applying,a,user,defined,map,function,on,the,vertex,ids,param,edges,a,data,set,of,tuple2,where,the,first,field,corresponds,to,the,source,id,and,the,second,field,corresponds,to,the,target,id,param,vertex,value,initializer,the,mapper,function,that,initializes,the,vertex,values,it,allows,to,apply,a,map,transformation,on,the,vertex,id,to,produce,an,initial,vertex,value,param,context,the,flink,execution,environment,return,the,newly,created,graph;public,static,k,vv,graph,k,vv,null,value,from,tuple2data,set,data,set,tuple2,k,k,edges,final,map,function,k,vv,vertex,value,initializer,execution,environment,context,data,set,edge,k,null,value,edge,data,set,edges,map,new,map,function,tuple2,k,k,edge,k,null,value,public,edge,k,null,value,map,tuple2,k,k,input,return,new,edge,k,null,value,input,f0,input,f1,null,value,get,instance,with,forwarded,fields,f0,f1,return,from,data,set,edge,data,set,vertex,value,initializer,context
Graph -> public static <K, VV> Graph<K, VV, NullValue> fromTuple2DataSet(DataSet<Tuple2<K, K>> edges, 			final MapFunction<K, VV> vertexValueInitializer, ExecutionEnvironment context);1462100316;Creates a graph from a DataSet of Tuple2 objects for edges._Each Tuple2 will become one Edge, where the source ID will be the first field of the Tuple2_and the target ID will be the second field of the Tuple2._<p>_Edge value types will be set to NullValue._Vertex values can be initialized by applying a user-defined map function on the vertex IDs.__@param edges a DataSet of Tuple2, where the first field corresponds to the source ID_and the second field corresponds to the target ID._@param vertexValueInitializer the mapper function that initializes the vertex values._It allows to apply a map transformation on the vertex ID to produce an initial vertex value._@param context the flink execution environment._@return the newly created graph.;public static <K, VV> Graph<K, VV, NullValue> fromTuple2DataSet(DataSet<Tuple2<K, K>> edges,_			final MapFunction<K, VV> vertexValueInitializer, ExecutionEnvironment context) {__		DataSet<Edge<K, NullValue>> edgeDataSet = edges.map(_				new MapFunction<Tuple2<K, K>, Edge<K, NullValue>>() {__					public Edge<K, NullValue> map(Tuple2<K, K> input) {_						return new Edge<K, NullValue>(input.f0, input.f1, NullValue.getInstance())__					}_				}).withForwardedFields("f0_ f1")__		return fromDataSet(edgeDataSet, vertexValueInitializer, context)__	};creates,a,graph,from,a,data,set,of,tuple2,objects,for,edges,each,tuple2,will,become,one,edge,where,the,source,id,will,be,the,first,field,of,the,tuple2,and,the,target,id,will,be,the,second,field,of,the,tuple2,p,edge,value,types,will,be,set,to,null,value,vertex,values,can,be,initialized,by,applying,a,user,defined,map,function,on,the,vertex,ids,param,edges,a,data,set,of,tuple2,where,the,first,field,corresponds,to,the,source,id,and,the,second,field,corresponds,to,the,target,id,param,vertex,value,initializer,the,mapper,function,that,initializes,the,vertex,values,it,allows,to,apply,a,map,transformation,on,the,vertex,id,to,produce,an,initial,vertex,value,param,context,the,flink,execution,environment,return,the,newly,created,graph;public,static,k,vv,graph,k,vv,null,value,from,tuple2data,set,data,set,tuple2,k,k,edges,final,map,function,k,vv,vertex,value,initializer,execution,environment,context,data,set,edge,k,null,value,edge,data,set,edges,map,new,map,function,tuple2,k,k,edge,k,null,value,public,edge,k,null,value,map,tuple2,k,k,input,return,new,edge,k,null,value,input,f0,input,f1,null,value,get,instance,with,forwarded,fields,f0,f1,return,from,data,set,edge,data,set,vertex,value,initializer,context
Graph -> public static <K, VV> Graph<K, VV, NullValue> fromTuple2DataSet(DataSet<Tuple2<K, K>> edges, 			final MapFunction<K, VV> vertexValueInitializer, ExecutionEnvironment context);1462205213;Creates a graph from a DataSet of Tuple2 objects for edges._Each Tuple2 will become one Edge, where the source ID will be the first field of the Tuple2_and the target ID will be the second field of the Tuple2._<p>_Edge value types will be set to NullValue._Vertex values can be initialized by applying a user-defined map function on the vertex IDs.__@param edges a DataSet of Tuple2, where the first field corresponds to the source ID_and the second field corresponds to the target ID._@param vertexValueInitializer the mapper function that initializes the vertex values._It allows to apply a map transformation on the vertex ID to produce an initial vertex value._@param context the flink execution environment._@return the newly created graph.;public static <K, VV> Graph<K, VV, NullValue> fromTuple2DataSet(DataSet<Tuple2<K, K>> edges,_			final MapFunction<K, VV> vertexValueInitializer, ExecutionEnvironment context) {__		DataSet<Edge<K, NullValue>> edgeDataSet = edges.map(_				new MapFunction<Tuple2<K, K>, Edge<K, NullValue>>() {__					public Edge<K, NullValue> map(Tuple2<K, K> input) {_						return new Edge<K, NullValue>(input.f0, input.f1, NullValue.getInstance())__					}_				}).withForwardedFields("f0_ f1")__		return fromDataSet(edgeDataSet, vertexValueInitializer, context)__	};creates,a,graph,from,a,data,set,of,tuple2,objects,for,edges,each,tuple2,will,become,one,edge,where,the,source,id,will,be,the,first,field,of,the,tuple2,and,the,target,id,will,be,the,second,field,of,the,tuple2,p,edge,value,types,will,be,set,to,null,value,vertex,values,can,be,initialized,by,applying,a,user,defined,map,function,on,the,vertex,ids,param,edges,a,data,set,of,tuple2,where,the,first,field,corresponds,to,the,source,id,and,the,second,field,corresponds,to,the,target,id,param,vertex,value,initializer,the,mapper,function,that,initializes,the,vertex,values,it,allows,to,apply,a,map,transformation,on,the,vertex,id,to,produce,an,initial,vertex,value,param,context,the,flink,execution,environment,return,the,newly,created,graph;public,static,k,vv,graph,k,vv,null,value,from,tuple2data,set,data,set,tuple2,k,k,edges,final,map,function,k,vv,vertex,value,initializer,execution,environment,context,data,set,edge,k,null,value,edge,data,set,edges,map,new,map,function,tuple2,k,k,edge,k,null,value,public,edge,k,null,value,map,tuple2,k,k,input,return,new,edge,k,null,value,input,f0,input,f1,null,value,get,instance,with,forwarded,fields,f0,f1,return,from,data,set,edge,data,set,vertex,value,initializer,context
Graph -> public static <K, VV> Graph<K, VV, NullValue> fromTuple2DataSet(DataSet<Tuple2<K, K>> edges, 			final MapFunction<K, VV> vertexValueInitializer, ExecutionEnvironment context);1462208859;Creates a graph from a DataSet of Tuple2 objects for edges._Each Tuple2 will become one Edge, where the source ID will be the first field of the Tuple2_and the target ID will be the second field of the Tuple2._<p>_Edge value types will be set to NullValue._Vertex values can be initialized by applying a user-defined map function on the vertex IDs.__@param edges a DataSet of Tuple2, where the first field corresponds to the source ID_and the second field corresponds to the target ID._@param vertexValueInitializer the mapper function that initializes the vertex values._It allows to apply a map transformation on the vertex ID to produce an initial vertex value._@param context the flink execution environment._@return the newly created graph.;public static <K, VV> Graph<K, VV, NullValue> fromTuple2DataSet(DataSet<Tuple2<K, K>> edges,_			final MapFunction<K, VV> vertexValueInitializer, ExecutionEnvironment context) {__		DataSet<Edge<K, NullValue>> edgeDataSet = edges.map(_				new MapFunction<Tuple2<K, K>, Edge<K, NullValue>>() {__					public Edge<K, NullValue> map(Tuple2<K, K> input) {_						return new Edge<K, NullValue>(input.f0, input.f1, NullValue.getInstance())__					}_				}).withForwardedFields("f0_ f1")__		return fromDataSet(edgeDataSet, vertexValueInitializer, context)__	};creates,a,graph,from,a,data,set,of,tuple2,objects,for,edges,each,tuple2,will,become,one,edge,where,the,source,id,will,be,the,first,field,of,the,tuple2,and,the,target,id,will,be,the,second,field,of,the,tuple2,p,edge,value,types,will,be,set,to,null,value,vertex,values,can,be,initialized,by,applying,a,user,defined,map,function,on,the,vertex,ids,param,edges,a,data,set,of,tuple2,where,the,first,field,corresponds,to,the,source,id,and,the,second,field,corresponds,to,the,target,id,param,vertex,value,initializer,the,mapper,function,that,initializes,the,vertex,values,it,allows,to,apply,a,map,transformation,on,the,vertex,id,to,produce,an,initial,vertex,value,param,context,the,flink,execution,environment,return,the,newly,created,graph;public,static,k,vv,graph,k,vv,null,value,from,tuple2data,set,data,set,tuple2,k,k,edges,final,map,function,k,vv,vertex,value,initializer,execution,environment,context,data,set,edge,k,null,value,edge,data,set,edges,map,new,map,function,tuple2,k,k,edge,k,null,value,public,edge,k,null,value,map,tuple2,k,k,input,return,new,edge,k,null,value,input,f0,input,f1,null,value,get,instance,with,forwarded,fields,f0,f1,return,from,data,set,edge,data,set,vertex,value,initializer,context
Graph -> public static <K, VV> Graph<K, VV, NullValue> fromTuple2DataSet(DataSet<Tuple2<K, K>> edges, 			final MapFunction<K, VV> vertexValueInitializer, ExecutionEnvironment context);1462809297;Creates a graph from a DataSet of Tuple2 objects for edges._Each Tuple2 will become one Edge, where the source ID will be the first field of the Tuple2_and the target ID will be the second field of the Tuple2._<p>_Edge value types will be set to NullValue._Vertex values can be initialized by applying a user-defined map function on the vertex IDs.__@param edges a DataSet of Tuple2, where the first field corresponds to the source ID_and the second field corresponds to the target ID._@param vertexValueInitializer the mapper function that initializes the vertex values._It allows to apply a map transformation on the vertex ID to produce an initial vertex value._@param context the flink execution environment._@return the newly created graph.;public static <K, VV> Graph<K, VV, NullValue> fromTuple2DataSet(DataSet<Tuple2<K, K>> edges,_			final MapFunction<K, VV> vertexValueInitializer, ExecutionEnvironment context) {__		DataSet<Edge<K, NullValue>> edgeDataSet = edges.map(_				new MapFunction<Tuple2<K, K>, Edge<K, NullValue>>() {__					public Edge<K, NullValue> map(Tuple2<K, K> input) {_						return new Edge<K, NullValue>(input.f0, input.f1, NullValue.getInstance())__					}_				}).withForwardedFields("f0_ f1")__		return fromDataSet(edgeDataSet, vertexValueInitializer, context)__	};creates,a,graph,from,a,data,set,of,tuple2,objects,for,edges,each,tuple2,will,become,one,edge,where,the,source,id,will,be,the,first,field,of,the,tuple2,and,the,target,id,will,be,the,second,field,of,the,tuple2,p,edge,value,types,will,be,set,to,null,value,vertex,values,can,be,initialized,by,applying,a,user,defined,map,function,on,the,vertex,ids,param,edges,a,data,set,of,tuple2,where,the,first,field,corresponds,to,the,source,id,and,the,second,field,corresponds,to,the,target,id,param,vertex,value,initializer,the,mapper,function,that,initializes,the,vertex,values,it,allows,to,apply,a,map,transformation,on,the,vertex,id,to,produce,an,initial,vertex,value,param,context,the,flink,execution,environment,return,the,newly,created,graph;public,static,k,vv,graph,k,vv,null,value,from,tuple2data,set,data,set,tuple2,k,k,edges,final,map,function,k,vv,vertex,value,initializer,execution,environment,context,data,set,edge,k,null,value,edge,data,set,edges,map,new,map,function,tuple2,k,k,edge,k,null,value,public,edge,k,null,value,map,tuple2,k,k,input,return,new,edge,k,null,value,input,f0,input,f1,null,value,get,instance,with,forwarded,fields,f0,f1,return,from,data,set,edge,data,set,vertex,value,initializer,context
Graph -> public static <K, VV> Graph<K, VV, NullValue> fromTuple2DataSet(DataSet<Tuple2<K, K>> edges, 			final MapFunction<K, VV> vertexValueInitializer, ExecutionEnvironment context);1465316775;Creates a graph from a DataSet of Tuple2 objects for edges._Each Tuple2 will become one Edge, where the source ID will be the first field of the Tuple2_and the target ID will be the second field of the Tuple2._<p>_Edge value types will be set to NullValue._Vertex values can be initialized by applying a user-defined map function on the vertex IDs.__@param edges a DataSet of Tuple2, where the first field corresponds to the source ID_and the second field corresponds to the target ID._@param vertexValueInitializer the mapper function that initializes the vertex values._It allows to apply a map transformation on the vertex ID to produce an initial vertex value._@param context the flink execution environment._@return the newly created graph.;public static <K, VV> Graph<K, VV, NullValue> fromTuple2DataSet(DataSet<Tuple2<K, K>> edges,_			final MapFunction<K, VV> vertexValueInitializer, ExecutionEnvironment context) {__		DataSet<Edge<K, NullValue>> edgeDataSet = edges.map(_				new MapFunction<Tuple2<K, K>, Edge<K, NullValue>>() {__					public Edge<K, NullValue> map(Tuple2<K, K> input) {_						return new Edge<K, NullValue>(input.f0, input.f1, NullValue.getInstance())__					}_				}).withForwardedFields("f0_ f1")__		return fromDataSet(edgeDataSet, vertexValueInitializer, context)__	};creates,a,graph,from,a,data,set,of,tuple2,objects,for,edges,each,tuple2,will,become,one,edge,where,the,source,id,will,be,the,first,field,of,the,tuple2,and,the,target,id,will,be,the,second,field,of,the,tuple2,p,edge,value,types,will,be,set,to,null,value,vertex,values,can,be,initialized,by,applying,a,user,defined,map,function,on,the,vertex,ids,param,edges,a,data,set,of,tuple2,where,the,first,field,corresponds,to,the,source,id,and,the,second,field,corresponds,to,the,target,id,param,vertex,value,initializer,the,mapper,function,that,initializes,the,vertex,values,it,allows,to,apply,a,map,transformation,on,the,vertex,id,to,produce,an,initial,vertex,value,param,context,the,flink,execution,environment,return,the,newly,created,graph;public,static,k,vv,graph,k,vv,null,value,from,tuple2data,set,data,set,tuple2,k,k,edges,final,map,function,k,vv,vertex,value,initializer,execution,environment,context,data,set,edge,k,null,value,edge,data,set,edges,map,new,map,function,tuple2,k,k,edge,k,null,value,public,edge,k,null,value,map,tuple2,k,k,input,return,new,edge,k,null,value,input,f0,input,f1,null,value,get,instance,with,forwarded,fields,f0,f1,return,from,data,set,edge,data,set,vertex,value,initializer,context
Graph -> public static <K, VV> Graph<K, VV, NullValue> fromTuple2DataSet(DataSet<Tuple2<K, K>> edges, 			final MapFunction<K, VV> vertexValueInitializer, ExecutionEnvironment context);1466789678;Creates a graph from a DataSet of Tuple2 objects for edges._Each Tuple2 will become one Edge, where the source ID will be the first field of the Tuple2_and the target ID will be the second field of the Tuple2._<p>_Edge value types will be set to NullValue._Vertex values can be initialized by applying a user-defined map function on the vertex IDs.__@param edges a DataSet of Tuple2, where the first field corresponds to the source ID_and the second field corresponds to the target ID._@param vertexValueInitializer the mapper function that initializes the vertex values._It allows to apply a map transformation on the vertex ID to produce an initial vertex value._@param context the flink execution environment._@return the newly created graph.;public static <K, VV> Graph<K, VV, NullValue> fromTuple2DataSet(DataSet<Tuple2<K, K>> edges,_			final MapFunction<K, VV> vertexValueInitializer, ExecutionEnvironment context) {__		DataSet<Edge<K, NullValue>> edgeDataSet = edges.map(_				new MapFunction<Tuple2<K, K>, Edge<K, NullValue>>() {__					public Edge<K, NullValue> map(Tuple2<K, K> input) {_						return new Edge<K, NullValue>(input.f0, input.f1, NullValue.getInstance())__					}_				}).withForwardedFields("f0_ f1")__		return fromDataSet(edgeDataSet, vertexValueInitializer, context)__	};creates,a,graph,from,a,data,set,of,tuple2,objects,for,edges,each,tuple2,will,become,one,edge,where,the,source,id,will,be,the,first,field,of,the,tuple2,and,the,target,id,will,be,the,second,field,of,the,tuple2,p,edge,value,types,will,be,set,to,null,value,vertex,values,can,be,initialized,by,applying,a,user,defined,map,function,on,the,vertex,ids,param,edges,a,data,set,of,tuple2,where,the,first,field,corresponds,to,the,source,id,and,the,second,field,corresponds,to,the,target,id,param,vertex,value,initializer,the,mapper,function,that,initializes,the,vertex,values,it,allows,to,apply,a,map,transformation,on,the,vertex,id,to,produce,an,initial,vertex,value,param,context,the,flink,execution,environment,return,the,newly,created,graph;public,static,k,vv,graph,k,vv,null,value,from,tuple2data,set,data,set,tuple2,k,k,edges,final,map,function,k,vv,vertex,value,initializer,execution,environment,context,data,set,edge,k,null,value,edge,data,set,edges,map,new,map,function,tuple2,k,k,edge,k,null,value,public,edge,k,null,value,map,tuple2,k,k,input,return,new,edge,k,null,value,input,f0,input,f1,null,value,get,instance,with,forwarded,fields,f0,f1,return,from,data,set,edge,data,set,vertex,value,initializer,context
Graph -> public static <K, VV> Graph<K, VV, NullValue> fromTuple2DataSet(DataSet<Tuple2<K, K>> edges, 			final MapFunction<K, VV> vertexValueInitializer, ExecutionEnvironment context);1467140656;Creates a graph from a DataSet of Tuple2 objects for edges._Each Tuple2 will become one Edge, where the source ID will be the first field of the Tuple2_and the target ID will be the second field of the Tuple2._<p>_Edge value types will be set to NullValue._Vertex values can be initialized by applying a user-defined map function on the vertex IDs.__@param edges a DataSet of Tuple2, where the first field corresponds to the source ID_and the second field corresponds to the target ID._@param vertexValueInitializer the mapper function that initializes the vertex values._It allows to apply a map transformation on the vertex ID to produce an initial vertex value._@param context the flink execution environment._@return the newly created graph.;public static <K, VV> Graph<K, VV, NullValue> fromTuple2DataSet(DataSet<Tuple2<K, K>> edges,_			final MapFunction<K, VV> vertexValueInitializer, ExecutionEnvironment context) {__		DataSet<Edge<K, NullValue>> edgeDataSet = edges.map(_				new MapFunction<Tuple2<K, K>, Edge<K, NullValue>>() {__					public Edge<K, NullValue> map(Tuple2<K, K> input) {_						return new Edge<K, NullValue>(input.f0, input.f1, NullValue.getInstance())__					}_				}).withForwardedFields("f0_ f1")__		return fromDataSet(edgeDataSet, vertexValueInitializer, context)__	};creates,a,graph,from,a,data,set,of,tuple2,objects,for,edges,each,tuple2,will,become,one,edge,where,the,source,id,will,be,the,first,field,of,the,tuple2,and,the,target,id,will,be,the,second,field,of,the,tuple2,p,edge,value,types,will,be,set,to,null,value,vertex,values,can,be,initialized,by,applying,a,user,defined,map,function,on,the,vertex,ids,param,edges,a,data,set,of,tuple2,where,the,first,field,corresponds,to,the,source,id,and,the,second,field,corresponds,to,the,target,id,param,vertex,value,initializer,the,mapper,function,that,initializes,the,vertex,values,it,allows,to,apply,a,map,transformation,on,the,vertex,id,to,produce,an,initial,vertex,value,param,context,the,flink,execution,environment,return,the,newly,created,graph;public,static,k,vv,graph,k,vv,null,value,from,tuple2data,set,data,set,tuple2,k,k,edges,final,map,function,k,vv,vertex,value,initializer,execution,environment,context,data,set,edge,k,null,value,edge,data,set,edges,map,new,map,function,tuple2,k,k,edge,k,null,value,public,edge,k,null,value,map,tuple2,k,k,input,return,new,edge,k,null,value,input,f0,input,f1,null,value,get,instance,with,forwarded,fields,f0,f1,return,from,data,set,edge,data,set,vertex,value,initializer,context
Graph -> public static <K, VV> Graph<K, VV, NullValue> fromTuple2DataSet(DataSet<Tuple2<K, K>> edges, 			final MapFunction<K, VV> vertexValueInitializer, ExecutionEnvironment context);1467306272;Creates a graph from a DataSet of Tuple2 objects for edges._Each Tuple2 will become one Edge, where the source ID will be the first field of the Tuple2_and the target ID will be the second field of the Tuple2._<p>_Edge value types will be set to NullValue._Vertex values can be initialized by applying a user-defined map function on the vertex IDs.__@param edges a DataSet of Tuple2, where the first field corresponds to the source ID_and the second field corresponds to the target ID._@param vertexValueInitializer the mapper function that initializes the vertex values._It allows to apply a map transformation on the vertex ID to produce an initial vertex value._@param context the flink execution environment._@return the newly created graph.;public static <K, VV> Graph<K, VV, NullValue> fromTuple2DataSet(DataSet<Tuple2<K, K>> edges,_			final MapFunction<K, VV> vertexValueInitializer, ExecutionEnvironment context) {__		DataSet<Edge<K, NullValue>> edgeDataSet = edges.map(_				new MapFunction<Tuple2<K, K>, Edge<K, NullValue>>() {__					public Edge<K, NullValue> map(Tuple2<K, K> input) {_						return new Edge<K, NullValue>(input.f0, input.f1, NullValue.getInstance())__					}_				}).withForwardedFields("f0_ f1")__		return fromDataSet(edgeDataSet, vertexValueInitializer, context)__	};creates,a,graph,from,a,data,set,of,tuple2,objects,for,edges,each,tuple2,will,become,one,edge,where,the,source,id,will,be,the,first,field,of,the,tuple2,and,the,target,id,will,be,the,second,field,of,the,tuple2,p,edge,value,types,will,be,set,to,null,value,vertex,values,can,be,initialized,by,applying,a,user,defined,map,function,on,the,vertex,ids,param,edges,a,data,set,of,tuple2,where,the,first,field,corresponds,to,the,source,id,and,the,second,field,corresponds,to,the,target,id,param,vertex,value,initializer,the,mapper,function,that,initializes,the,vertex,values,it,allows,to,apply,a,map,transformation,on,the,vertex,id,to,produce,an,initial,vertex,value,param,context,the,flink,execution,environment,return,the,newly,created,graph;public,static,k,vv,graph,k,vv,null,value,from,tuple2data,set,data,set,tuple2,k,k,edges,final,map,function,k,vv,vertex,value,initializer,execution,environment,context,data,set,edge,k,null,value,edge,data,set,edges,map,new,map,function,tuple2,k,k,edge,k,null,value,public,edge,k,null,value,map,tuple2,k,k,input,return,new,edge,k,null,value,input,f0,input,f1,null,value,get,instance,with,forwarded,fields,f0,f1,return,from,data,set,edge,data,set,vertex,value,initializer,context
Graph -> public static <K, VV> Graph<K, VV, NullValue> fromTuple2DataSet(DataSet<Tuple2<K, K>> edges, 			final MapFunction<K, VV> vertexValueInitializer, ExecutionEnvironment context);1470042815;Creates a graph from a DataSet of Tuple2 objects for edges._Each Tuple2 will become one Edge, where the source ID will be the first field of the Tuple2_and the target ID will be the second field of the Tuple2._<p>_Edge value types will be set to NullValue._Vertex values can be initialized by applying a user-defined map function on the vertex IDs.__@param edges a DataSet of Tuple2, where the first field corresponds to the source ID_and the second field corresponds to the target ID._@param vertexValueInitializer the mapper function that initializes the vertex values._It allows to apply a map transformation on the vertex ID to produce an initial vertex value._@param context the flink execution environment._@return the newly created graph.;public static <K, VV> Graph<K, VV, NullValue> fromTuple2DataSet(DataSet<Tuple2<K, K>> edges,_			final MapFunction<K, VV> vertexValueInitializer, ExecutionEnvironment context) {__		DataSet<Edge<K, NullValue>> edgeDataSet = edges.map(_				new MapFunction<Tuple2<K, K>, Edge<K, NullValue>>() {__					public Edge<K, NullValue> map(Tuple2<K, K> input) {_						return new Edge<K, NullValue>(input.f0, input.f1, NullValue.getInstance())__					}_				}).withForwardedFields("f0_ f1")__		return fromDataSet(edgeDataSet, vertexValueInitializer, context)__	};creates,a,graph,from,a,data,set,of,tuple2,objects,for,edges,each,tuple2,will,become,one,edge,where,the,source,id,will,be,the,first,field,of,the,tuple2,and,the,target,id,will,be,the,second,field,of,the,tuple2,p,edge,value,types,will,be,set,to,null,value,vertex,values,can,be,initialized,by,applying,a,user,defined,map,function,on,the,vertex,ids,param,edges,a,data,set,of,tuple2,where,the,first,field,corresponds,to,the,source,id,and,the,second,field,corresponds,to,the,target,id,param,vertex,value,initializer,the,mapper,function,that,initializes,the,vertex,values,it,allows,to,apply,a,map,transformation,on,the,vertex,id,to,produce,an,initial,vertex,value,param,context,the,flink,execution,environment,return,the,newly,created,graph;public,static,k,vv,graph,k,vv,null,value,from,tuple2data,set,data,set,tuple2,k,k,edges,final,map,function,k,vv,vertex,value,initializer,execution,environment,context,data,set,edge,k,null,value,edge,data,set,edges,map,new,map,function,tuple2,k,k,edge,k,null,value,public,edge,k,null,value,map,tuple2,k,k,input,return,new,edge,k,null,value,input,f0,input,f1,null,value,get,instance,with,forwarded,fields,f0,f1,return,from,data,set,edge,data,set,vertex,value,initializer,context
Graph -> public static <K, VV> Graph<K, VV, NullValue> fromTuple2DataSet(DataSet<Tuple2<K, K>> edges, 			final MapFunction<K, VV> vertexValueInitializer, ExecutionEnvironment context);1475684776;Creates a graph from a DataSet of Tuple2 objects for edges._Each Tuple2 will become one Edge, where the source ID will be the first field of the Tuple2_and the target ID will be the second field of the Tuple2._<p>_Edge value types will be set to NullValue._Vertex values can be initialized by applying a user-defined map function on the vertex IDs.__@param edges a DataSet of Tuple2, where the first field corresponds to the source ID_and the second field corresponds to the target ID._@param vertexValueInitializer the mapper function that initializes the vertex values._It allows to apply a map transformation on the vertex ID to produce an initial vertex value._@param context the flink execution environment._@return the newly created graph.;public static <K, VV> Graph<K, VV, NullValue> fromTuple2DataSet(DataSet<Tuple2<K, K>> edges,_			final MapFunction<K, VV> vertexValueInitializer, ExecutionEnvironment context) {__		DataSet<Edge<K, NullValue>> edgeDataSet = edges.map(_				new MapFunction<Tuple2<K, K>, Edge<K, NullValue>>() {__					public Edge<K, NullValue> map(Tuple2<K, K> input) {_						return new Edge<>(input.f0, input.f1, NullValue.getInstance())__					}_				}).withForwardedFields("f0_ f1")__		return fromDataSet(edgeDataSet, vertexValueInitializer, context)__	};creates,a,graph,from,a,data,set,of,tuple2,objects,for,edges,each,tuple2,will,become,one,edge,where,the,source,id,will,be,the,first,field,of,the,tuple2,and,the,target,id,will,be,the,second,field,of,the,tuple2,p,edge,value,types,will,be,set,to,null,value,vertex,values,can,be,initialized,by,applying,a,user,defined,map,function,on,the,vertex,ids,param,edges,a,data,set,of,tuple2,where,the,first,field,corresponds,to,the,source,id,and,the,second,field,corresponds,to,the,target,id,param,vertex,value,initializer,the,mapper,function,that,initializes,the,vertex,values,it,allows,to,apply,a,map,transformation,on,the,vertex,id,to,produce,an,initial,vertex,value,param,context,the,flink,execution,environment,return,the,newly,created,graph;public,static,k,vv,graph,k,vv,null,value,from,tuple2data,set,data,set,tuple2,k,k,edges,final,map,function,k,vv,vertex,value,initializer,execution,environment,context,data,set,edge,k,null,value,edge,data,set,edges,map,new,map,function,tuple2,k,k,edge,k,null,value,public,edge,k,null,value,map,tuple2,k,k,input,return,new,edge,input,f0,input,f1,null,value,get,instance,with,forwarded,fields,f0,f1,return,from,data,set,edge,data,set,vertex,value,initializer,context
Graph -> public static <K, VV> Graph<K, VV, NullValue> fromTuple2DataSet(DataSet<Tuple2<K, K>> edges, 			final MapFunction<K, VV> vertexValueInitializer, ExecutionEnvironment context);1475685606;Creates a graph from a DataSet of Tuple2 objects for edges._Each Tuple2 will become one Edge, where the source ID will be the first field of the Tuple2_and the target ID will be the second field of the Tuple2._<p>_Edge value types will be set to NullValue._Vertex values can be initialized by applying a user-defined map function on the vertex IDs.__@param edges a DataSet of Tuple2, where the first field corresponds to the source ID_and the second field corresponds to the target ID._@param vertexValueInitializer the mapper function that initializes the vertex values._It allows to apply a map transformation on the vertex ID to produce an initial vertex value._@param context the flink execution environment._@return the newly created graph.;public static <K, VV> Graph<K, VV, NullValue> fromTuple2DataSet(DataSet<Tuple2<K, K>> edges,_			final MapFunction<K, VV> vertexValueInitializer, ExecutionEnvironment context) {__		DataSet<Edge<K, NullValue>> edgeDataSet = edges.map(_				new MapFunction<Tuple2<K, K>, Edge<K, NullValue>>() {__					public Edge<K, NullValue> map(Tuple2<K, K> input) {_						return new Edge<>(input.f0, input.f1, NullValue.getInstance())__					}_				}).withForwardedFields("f0_ f1")__		return fromDataSet(edgeDataSet, vertexValueInitializer, context)__	};creates,a,graph,from,a,data,set,of,tuple2,objects,for,edges,each,tuple2,will,become,one,edge,where,the,source,id,will,be,the,first,field,of,the,tuple2,and,the,target,id,will,be,the,second,field,of,the,tuple2,p,edge,value,types,will,be,set,to,null,value,vertex,values,can,be,initialized,by,applying,a,user,defined,map,function,on,the,vertex,ids,param,edges,a,data,set,of,tuple2,where,the,first,field,corresponds,to,the,source,id,and,the,second,field,corresponds,to,the,target,id,param,vertex,value,initializer,the,mapper,function,that,initializes,the,vertex,values,it,allows,to,apply,a,map,transformation,on,the,vertex,id,to,produce,an,initial,vertex,value,param,context,the,flink,execution,environment,return,the,newly,created,graph;public,static,k,vv,graph,k,vv,null,value,from,tuple2data,set,data,set,tuple2,k,k,edges,final,map,function,k,vv,vertex,value,initializer,execution,environment,context,data,set,edge,k,null,value,edge,data,set,edges,map,new,map,function,tuple2,k,k,edge,k,null,value,public,edge,k,null,value,map,tuple2,k,k,input,return,new,edge,input,f0,input,f1,null,value,get,instance,with,forwarded,fields,f0,f1,return,from,data,set,edge,data,set,vertex,value,initializer,context
Graph -> public static <K, VV> Graph<K, VV, NullValue> fromTuple2DataSet(DataSet<Tuple2<K, K>> edges, 			final MapFunction<K, VV> vertexValueInitializer, ExecutionEnvironment context);1481745825;Creates a graph from a DataSet of Tuple2 objects for edges._Each Tuple2 will become one Edge, where the source ID will be the first field of the Tuple2_and the target ID will be the second field of the Tuple2._<p>_Edge value types will be set to NullValue._Vertex values can be initialized by applying a user-defined map function on the vertex IDs.__@param edges a DataSet of Tuple2, where the first field corresponds to the source ID_and the second field corresponds to the target ID._@param vertexValueInitializer the mapper function that initializes the vertex values._It allows to apply a map transformation on the vertex ID to produce an initial vertex value._@param context the flink execution environment._@return the newly created graph.;public static <K, VV> Graph<K, VV, NullValue> fromTuple2DataSet(DataSet<Tuple2<K, K>> edges,_			final MapFunction<K, VV> vertexValueInitializer, ExecutionEnvironment context) {__		DataSet<Edge<K, NullValue>> edgeDataSet = edges_			.map(new Tuple2ToEdgeMap<K>())_				.name("To Edge")___		return fromDataSet(edgeDataSet, vertexValueInitializer, context)__	};creates,a,graph,from,a,data,set,of,tuple2,objects,for,edges,each,tuple2,will,become,one,edge,where,the,source,id,will,be,the,first,field,of,the,tuple2,and,the,target,id,will,be,the,second,field,of,the,tuple2,p,edge,value,types,will,be,set,to,null,value,vertex,values,can,be,initialized,by,applying,a,user,defined,map,function,on,the,vertex,ids,param,edges,a,data,set,of,tuple2,where,the,first,field,corresponds,to,the,source,id,and,the,second,field,corresponds,to,the,target,id,param,vertex,value,initializer,the,mapper,function,that,initializes,the,vertex,values,it,allows,to,apply,a,map,transformation,on,the,vertex,id,to,produce,an,initial,vertex,value,param,context,the,flink,execution,environment,return,the,newly,created,graph;public,static,k,vv,graph,k,vv,null,value,from,tuple2data,set,data,set,tuple2,k,k,edges,final,map,function,k,vv,vertex,value,initializer,execution,environment,context,data,set,edge,k,null,value,edge,data,set,edges,map,new,tuple2to,edge,map,k,name,to,edge,return,from,data,set,edge,data,set,vertex,value,initializer,context
Graph -> public static <K, VV> Graph<K, VV, NullValue> fromTuple2DataSet(DataSet<Tuple2<K, K>> edges, 			final MapFunction<K, VV> vertexValueInitializer, ExecutionEnvironment context);1481881009;Creates a graph from a DataSet of Tuple2 objects for edges._Each Tuple2 will become one Edge, where the source ID will be the first field of the Tuple2_and the target ID will be the second field of the Tuple2._<p>_Edge value types will be set to NullValue._Vertex values can be initialized by applying a user-defined map function on the vertex IDs.__@param edges a DataSet of Tuple2, where the first field corresponds to the source ID_and the second field corresponds to the target ID._@param vertexValueInitializer the mapper function that initializes the vertex values._It allows to apply a map transformation on the vertex ID to produce an initial vertex value._@param context the flink execution environment._@return the newly created graph.;public static <K, VV> Graph<K, VV, NullValue> fromTuple2DataSet(DataSet<Tuple2<K, K>> edges,_			final MapFunction<K, VV> vertexValueInitializer, ExecutionEnvironment context) {__		DataSet<Edge<K, NullValue>> edgeDataSet = edges_			.map(new Tuple2ToEdgeMap<K>())_				.name("To Edge")___		return fromDataSet(edgeDataSet, vertexValueInitializer, context)__	};creates,a,graph,from,a,data,set,of,tuple2,objects,for,edges,each,tuple2,will,become,one,edge,where,the,source,id,will,be,the,first,field,of,the,tuple2,and,the,target,id,will,be,the,second,field,of,the,tuple2,p,edge,value,types,will,be,set,to,null,value,vertex,values,can,be,initialized,by,applying,a,user,defined,map,function,on,the,vertex,ids,param,edges,a,data,set,of,tuple2,where,the,first,field,corresponds,to,the,source,id,and,the,second,field,corresponds,to,the,target,id,param,vertex,value,initializer,the,mapper,function,that,initializes,the,vertex,values,it,allows,to,apply,a,map,transformation,on,the,vertex,id,to,produce,an,initial,vertex,value,param,context,the,flink,execution,environment,return,the,newly,created,graph;public,static,k,vv,graph,k,vv,null,value,from,tuple2data,set,data,set,tuple2,k,k,edges,final,map,function,k,vv,vertex,value,initializer,execution,environment,context,data,set,edge,k,null,value,edge,data,set,edges,map,new,tuple2to,edge,map,k,name,to,edge,return,from,data,set,edge,data,set,vertex,value,initializer,context
Graph -> public static <K, VV> Graph<K, VV, NullValue> fromTuple2DataSet(DataSet<Tuple2<K, K>> edges, 			final MapFunction<K, VV> vertexValueInitializer, ExecutionEnvironment context);1484160227;Creates a graph from a DataSet of Tuple2 objects for edges._Each Tuple2 will become one Edge, where the source ID will be the first field of the Tuple2_and the target ID will be the second field of the Tuple2._<p>_Edge value types will be set to NullValue._Vertex values can be initialized by applying a user-defined map function on the vertex IDs.__@param edges a DataSet of Tuple2, where the first field corresponds to the source ID_and the second field corresponds to the target ID._@param vertexValueInitializer the mapper function that initializes the vertex values._It allows to apply a map transformation on the vertex ID to produce an initial vertex value._@param context the flink execution environment._@return the newly created graph.;public static <K, VV> Graph<K, VV, NullValue> fromTuple2DataSet(DataSet<Tuple2<K, K>> edges,_			final MapFunction<K, VV> vertexValueInitializer, ExecutionEnvironment context) {__		DataSet<Edge<K, NullValue>> edgeDataSet = edges_			.map(new Tuple2ToEdgeMap<K>())_				.name("To Edge")___		return fromDataSet(edgeDataSet, vertexValueInitializer, context)__	};creates,a,graph,from,a,data,set,of,tuple2,objects,for,edges,each,tuple2,will,become,one,edge,where,the,source,id,will,be,the,first,field,of,the,tuple2,and,the,target,id,will,be,the,second,field,of,the,tuple2,p,edge,value,types,will,be,set,to,null,value,vertex,values,can,be,initialized,by,applying,a,user,defined,map,function,on,the,vertex,ids,param,edges,a,data,set,of,tuple2,where,the,first,field,corresponds,to,the,source,id,and,the,second,field,corresponds,to,the,target,id,param,vertex,value,initializer,the,mapper,function,that,initializes,the,vertex,values,it,allows,to,apply,a,map,transformation,on,the,vertex,id,to,produce,an,initial,vertex,value,param,context,the,flink,execution,environment,return,the,newly,created,graph;public,static,k,vv,graph,k,vv,null,value,from,tuple2data,set,data,set,tuple2,k,k,edges,final,map,function,k,vv,vertex,value,initializer,execution,environment,context,data,set,edge,k,null,value,edge,data,set,edges,map,new,tuple2to,edge,map,k,name,to,edge,return,from,data,set,edge,data,set,vertex,value,initializer,context
Graph -> public static <K, VV> Graph<K, VV, NullValue> fromTuple2DataSet(DataSet<Tuple2<K, K>> edges, 			final MapFunction<K, VV> vertexValueInitializer, ExecutionEnvironment context);1484685504;Creates a graph from a DataSet of Tuple2 objects for edges._Each Tuple2 will become one Edge, where the source ID will be the first field of the Tuple2_and the target ID will be the second field of the Tuple2._<p>_Edge value types will be set to NullValue._Vertex values can be initialized by applying a user-defined map function on the vertex IDs.__@param edges a DataSet of Tuple2, where the first field corresponds to the source ID_and the second field corresponds to the target ID._@param vertexValueInitializer the mapper function that initializes the vertex values._It allows to apply a map transformation on the vertex ID to produce an initial vertex value._@param context the flink execution environment._@return the newly created graph.;public static <K, VV> Graph<K, VV, NullValue> fromTuple2DataSet(DataSet<Tuple2<K, K>> edges,_			final MapFunction<K, VV> vertexValueInitializer, ExecutionEnvironment context) {__		DataSet<Edge<K, NullValue>> edgeDataSet = edges_			.map(new Tuple2ToEdgeMap<K>())_				.name("To Edge")___		return fromDataSet(edgeDataSet, vertexValueInitializer, context)__	};creates,a,graph,from,a,data,set,of,tuple2,objects,for,edges,each,tuple2,will,become,one,edge,where,the,source,id,will,be,the,first,field,of,the,tuple2,and,the,target,id,will,be,the,second,field,of,the,tuple2,p,edge,value,types,will,be,set,to,null,value,vertex,values,can,be,initialized,by,applying,a,user,defined,map,function,on,the,vertex,ids,param,edges,a,data,set,of,tuple2,where,the,first,field,corresponds,to,the,source,id,and,the,second,field,corresponds,to,the,target,id,param,vertex,value,initializer,the,mapper,function,that,initializes,the,vertex,values,it,allows,to,apply,a,map,transformation,on,the,vertex,id,to,produce,an,initial,vertex,value,param,context,the,flink,execution,environment,return,the,newly,created,graph;public,static,k,vv,graph,k,vv,null,value,from,tuple2data,set,data,set,tuple2,k,k,edges,final,map,function,k,vv,vertex,value,initializer,execution,environment,context,data,set,edge,k,null,value,edge,data,set,edges,map,new,tuple2to,edge,map,k,name,to,edge,return,from,data,set,edge,data,set,vertex,value,initializer,context
Graph -> public static <K, VV> Graph<K, VV, NullValue> fromTuple2DataSet(DataSet<Tuple2<K, K>> edges, 			final MapFunction<K, VV> vertexValueInitializer, ExecutionEnvironment context);1489068942;Creates a graph from a DataSet of Tuple2 objects for edges._Each Tuple2 will become one Edge, where the source ID will be the first field of the Tuple2_and the target ID will be the second field of the Tuple2._<p>_Edge value types will be set to NullValue._Vertex values can be initialized by applying a user-defined map function on the vertex IDs.__@param edges a DataSet of Tuple2, where the first field corresponds to the source ID_and the second field corresponds to the target ID._@param vertexValueInitializer the mapper function that initializes the vertex values._It allows to apply a map transformation on the vertex ID to produce an initial vertex value._@param context the flink execution environment._@return the newly created graph.;public static <K, VV> Graph<K, VV, NullValue> fromTuple2DataSet(DataSet<Tuple2<K, K>> edges,_			final MapFunction<K, VV> vertexValueInitializer, ExecutionEnvironment context) {__		DataSet<Edge<K, NullValue>> edgeDataSet = edges_			.map(new Tuple2ToEdgeMap<K>())_				.name("To Edge")___		return fromDataSet(edgeDataSet, vertexValueInitializer, context)__	};creates,a,graph,from,a,data,set,of,tuple2,objects,for,edges,each,tuple2,will,become,one,edge,where,the,source,id,will,be,the,first,field,of,the,tuple2,and,the,target,id,will,be,the,second,field,of,the,tuple2,p,edge,value,types,will,be,set,to,null,value,vertex,values,can,be,initialized,by,applying,a,user,defined,map,function,on,the,vertex,ids,param,edges,a,data,set,of,tuple2,where,the,first,field,corresponds,to,the,source,id,and,the,second,field,corresponds,to,the,target,id,param,vertex,value,initializer,the,mapper,function,that,initializes,the,vertex,values,it,allows,to,apply,a,map,transformation,on,the,vertex,id,to,produce,an,initial,vertex,value,param,context,the,flink,execution,environment,return,the,newly,created,graph;public,static,k,vv,graph,k,vv,null,value,from,tuple2data,set,data,set,tuple2,k,k,edges,final,map,function,k,vv,vertex,value,initializer,execution,environment,context,data,set,edge,k,null,value,edge,data,set,edges,map,new,tuple2to,edge,map,k,name,to,edge,return,from,data,set,edge,data,set,vertex,value,initializer,context
Graph -> public static <K, VV> Graph<K, VV, NullValue> fromTuple2DataSet(DataSet<Tuple2<K, K>> edges, 			final MapFunction<K, VV> vertexValueInitializer, ExecutionEnvironment context);1490973446;Creates a graph from a DataSet of Tuple2 objects for edges._Each Tuple2 will become one Edge, where the source ID will be the first field of the Tuple2_and the target ID will be the second field of the Tuple2._<p>_Edge value types will be set to NullValue._Vertex values can be initialized by applying a user-defined map function on the vertex IDs.__@param edges a DataSet of Tuple2, where the first field corresponds to the source ID_and the second field corresponds to the target ID._@param vertexValueInitializer the mapper function that initializes the vertex values._It allows to apply a map transformation on the vertex ID to produce an initial vertex value._@param context the flink execution environment._@return the newly created graph.;public static <K, VV> Graph<K, VV, NullValue> fromTuple2DataSet(DataSet<Tuple2<K, K>> edges,_			final MapFunction<K, VV> vertexValueInitializer, ExecutionEnvironment context) {__		DataSet<Edge<K, NullValue>> edgeDataSet = edges_			.map(new Tuple2ToEdgeMap<K>())_				.name("To Edge")___		return fromDataSet(edgeDataSet, vertexValueInitializer, context)__	};creates,a,graph,from,a,data,set,of,tuple2,objects,for,edges,each,tuple2,will,become,one,edge,where,the,source,id,will,be,the,first,field,of,the,tuple2,and,the,target,id,will,be,the,second,field,of,the,tuple2,p,edge,value,types,will,be,set,to,null,value,vertex,values,can,be,initialized,by,applying,a,user,defined,map,function,on,the,vertex,ids,param,edges,a,data,set,of,tuple2,where,the,first,field,corresponds,to,the,source,id,and,the,second,field,corresponds,to,the,target,id,param,vertex,value,initializer,the,mapper,function,that,initializes,the,vertex,values,it,allows,to,apply,a,map,transformation,on,the,vertex,id,to,produce,an,initial,vertex,value,param,context,the,flink,execution,environment,return,the,newly,created,graph;public,static,k,vv,graph,k,vv,null,value,from,tuple2data,set,data,set,tuple2,k,k,edges,final,map,function,k,vv,vertex,value,initializer,execution,environment,context,data,set,edge,k,null,value,edge,data,set,edges,map,new,tuple2to,edge,map,k,name,to,edge,return,from,data,set,edge,data,set,vertex,value,initializer,context
Graph -> public static <K, VV> Graph<K, VV, NullValue> fromTuple2DataSet(DataSet<Tuple2<K, K>> edges, 			final MapFunction<K, VV> vertexValueInitializer, ExecutionEnvironment context);1495819075;Creates a graph from a DataSet of Tuple2 objects for edges._Each Tuple2 will become one Edge, where the source ID will be the first field of the Tuple2_and the target ID will be the second field of the Tuple2.__<p>Edge value types will be set to NullValue._Vertex values can be initialized by applying a user-defined map function on the vertex IDs.__@param edges a DataSet of Tuple2, where the first field corresponds to the source ID_and the second field corresponds to the target ID._@param vertexValueInitializer the mapper function that initializes the vertex values._It allows to apply a map transformation on the vertex ID to produce an initial vertex value._@param context the flink execution environment._@return the newly created graph.;public static <K, VV> Graph<K, VV, NullValue> fromTuple2DataSet(DataSet<Tuple2<K, K>> edges,_			final MapFunction<K, VV> vertexValueInitializer, ExecutionEnvironment context) {__		DataSet<Edge<K, NullValue>> edgeDataSet = edges_			.map(new Tuple2ToEdgeMap<K>())_				.name("To Edge")___		return fromDataSet(edgeDataSet, vertexValueInitializer, context)__	};creates,a,graph,from,a,data,set,of,tuple2,objects,for,edges,each,tuple2,will,become,one,edge,where,the,source,id,will,be,the,first,field,of,the,tuple2,and,the,target,id,will,be,the,second,field,of,the,tuple2,p,edge,value,types,will,be,set,to,null,value,vertex,values,can,be,initialized,by,applying,a,user,defined,map,function,on,the,vertex,ids,param,edges,a,data,set,of,tuple2,where,the,first,field,corresponds,to,the,source,id,and,the,second,field,corresponds,to,the,target,id,param,vertex,value,initializer,the,mapper,function,that,initializes,the,vertex,values,it,allows,to,apply,a,map,transformation,on,the,vertex,id,to,produce,an,initial,vertex,value,param,context,the,flink,execution,environment,return,the,newly,created,graph;public,static,k,vv,graph,k,vv,null,value,from,tuple2data,set,data,set,tuple2,k,k,edges,final,map,function,k,vv,vertex,value,initializer,execution,environment,context,data,set,edge,k,null,value,edge,data,set,edges,map,new,tuple2to,edge,map,k,name,to,edge,return,from,data,set,edge,data,set,vertex,value,initializer,context
Graph -> public static <K, VV> Graph<K, VV, NullValue> fromTuple2DataSet(DataSet<Tuple2<K, K>> edges, 			final MapFunction<K, VV> vertexValueInitializer, ExecutionEnvironment context);1502111816;Creates a graph from a DataSet of Tuple2 objects for edges._Each Tuple2 will become one Edge, where the source ID will be the first field of the Tuple2_and the target ID will be the second field of the Tuple2.__<p>Edge value types will be set to NullValue._Vertex values can be initialized by applying a user-defined map function on the vertex IDs.__@param edges a DataSet of Tuple2, where the first field corresponds to the source ID_and the second field corresponds to the target ID._@param vertexValueInitializer the mapper function that initializes the vertex values._It allows to apply a map transformation on the vertex ID to produce an initial vertex value._@param context the flink execution environment._@return the newly created graph.;public static <K, VV> Graph<K, VV, NullValue> fromTuple2DataSet(DataSet<Tuple2<K, K>> edges,_			final MapFunction<K, VV> vertexValueInitializer, ExecutionEnvironment context) {__		DataSet<Edge<K, NullValue>> edgeDataSet = edges_			.map(new Tuple2ToEdgeMap<>())_				.name("To Edge")___		return fromDataSet(edgeDataSet, vertexValueInitializer, context)__	};creates,a,graph,from,a,data,set,of,tuple2,objects,for,edges,each,tuple2,will,become,one,edge,where,the,source,id,will,be,the,first,field,of,the,tuple2,and,the,target,id,will,be,the,second,field,of,the,tuple2,p,edge,value,types,will,be,set,to,null,value,vertex,values,can,be,initialized,by,applying,a,user,defined,map,function,on,the,vertex,ids,param,edges,a,data,set,of,tuple2,where,the,first,field,corresponds,to,the,source,id,and,the,second,field,corresponds,to,the,target,id,param,vertex,value,initializer,the,mapper,function,that,initializes,the,vertex,values,it,allows,to,apply,a,map,transformation,on,the,vertex,id,to,produce,an,initial,vertex,value,param,context,the,flink,execution,environment,return,the,newly,created,graph;public,static,k,vv,graph,k,vv,null,value,from,tuple2data,set,data,set,tuple2,k,k,edges,final,map,function,k,vv,vertex,value,initializer,execution,environment,context,data,set,edge,k,null,value,edge,data,set,edges,map,new,tuple2to,edge,map,name,to,edge,return,from,data,set,edge,data,set,vertex,value,initializer,context
Graph -> public static <K, EV> Graph<K, NullValue, EV> fromCollection(Collection<Edge<K, EV>> edges, 			ExecutionEnvironment context);1444404795;Creates a graph from a Collection of edges, vertices are induced from the_edges. Vertices are created automatically and their values are set to_NullValue.__@param edges a Collection of vertices._@param context the flink execution environment._@return the newly created graph.;public static <K, EV> Graph<K, NullValue, EV> fromCollection(Collection<Edge<K, EV>> edges,_			ExecutionEnvironment context) {__		return fromDataSet(context.fromCollection(edges), context)__	};creates,a,graph,from,a,collection,of,edges,vertices,are,induced,from,the,edges,vertices,are,created,automatically,and,their,values,are,set,to,null,value,param,edges,a,collection,of,vertices,param,context,the,flink,execution,environment,return,the,newly,created,graph;public,static,k,ev,graph,k,null,value,ev,from,collection,collection,edge,k,ev,edges,execution,environment,context,return,from,data,set,context,from,collection,edges,context
Graph -> public static <K, EV> Graph<K, NullValue, EV> fromCollection(Collection<Edge<K, EV>> edges, 			ExecutionEnvironment context);1445261977;Creates a graph from a Collection of edges._Vertices are created automatically and their values are set to_NullValue.__@param edges a Collection of edges._@param context the flink execution environment._@return the newly created graph.;public static <K, EV> Graph<K, NullValue, EV> fromCollection(Collection<Edge<K, EV>> edges,_			ExecutionEnvironment context) {__		return fromDataSet(context.fromCollection(edges), context)__	};creates,a,graph,from,a,collection,of,edges,vertices,are,created,automatically,and,their,values,are,set,to,null,value,param,edges,a,collection,of,edges,param,context,the,flink,execution,environment,return,the,newly,created,graph;public,static,k,ev,graph,k,null,value,ev,from,collection,collection,edge,k,ev,edges,execution,environment,context,return,from,data,set,context,from,collection,edges,context
Graph -> public static <K, EV> Graph<K, NullValue, EV> fromCollection(Collection<Edge<K, EV>> edges, 			ExecutionEnvironment context);1445854323;Creates a graph from a Collection of edges._Vertices are created automatically and their values are set to_NullValue.__@param edges a Collection of edges._@param context the flink execution environment._@return the newly created graph.;public static <K, EV> Graph<K, NullValue, EV> fromCollection(Collection<Edge<K, EV>> edges,_			ExecutionEnvironment context) {__		return fromDataSet(context.fromCollection(edges), context)__	};creates,a,graph,from,a,collection,of,edges,vertices,are,created,automatically,and,their,values,are,set,to,null,value,param,edges,a,collection,of,edges,param,context,the,flink,execution,environment,return,the,newly,created,graph;public,static,k,ev,graph,k,null,value,ev,from,collection,collection,edge,k,ev,edges,execution,environment,context,return,from,data,set,context,from,collection,edges,context
Graph -> public static <K, EV> Graph<K, NullValue, EV> fromCollection(Collection<Edge<K, EV>> edges, 			ExecutionEnvironment context);1446112342;Creates a graph from a Collection of edges._Vertices are created automatically and their values are set to_NullValue.__@param edges a Collection of edges._@param context the flink execution environment._@return the newly created graph.;public static <K, EV> Graph<K, NullValue, EV> fromCollection(Collection<Edge<K, EV>> edges,_			ExecutionEnvironment context) {__		return fromDataSet(context.fromCollection(edges), context)__	};creates,a,graph,from,a,collection,of,edges,vertices,are,created,automatically,and,their,values,are,set,to,null,value,param,edges,a,collection,of,edges,param,context,the,flink,execution,environment,return,the,newly,created,graph;public,static,k,ev,graph,k,null,value,ev,from,collection,collection,edge,k,ev,edges,execution,environment,context,return,from,data,set,context,from,collection,edges,context
Graph -> public static <K, EV> Graph<K, NullValue, EV> fromCollection(Collection<Edge<K, EV>> edges, 			ExecutionEnvironment context);1447073368;Creates a graph from a Collection of edges._Vertices are created automatically and their values are set to_NullValue.__@param edges a Collection of edges._@param context the flink execution environment._@return the newly created graph.;public static <K, EV> Graph<K, NullValue, EV> fromCollection(Collection<Edge<K, EV>> edges,_			ExecutionEnvironment context) {__		return fromDataSet(context.fromCollection(edges), context)__	};creates,a,graph,from,a,collection,of,edges,vertices,are,created,automatically,and,their,values,are,set,to,null,value,param,edges,a,collection,of,edges,param,context,the,flink,execution,environment,return,the,newly,created,graph;public,static,k,ev,graph,k,null,value,ev,from,collection,collection,edge,k,ev,edges,execution,environment,context,return,from,data,set,context,from,collection,edges,context
Graph -> public static <K, EV> Graph<K, NullValue, EV> fromCollection(Collection<Edge<K, EV>> edges, 			ExecutionEnvironment context);1454404649;Creates a graph from a Collection of edges._Vertices are created automatically and their values are set to_NullValue.__@param edges a Collection of edges._@param context the flink execution environment._@return the newly created graph.;public static <K, EV> Graph<K, NullValue, EV> fromCollection(Collection<Edge<K, EV>> edges,_			ExecutionEnvironment context) {__		return fromDataSet(context.fromCollection(edges), context)__	};creates,a,graph,from,a,collection,of,edges,vertices,are,created,automatically,and,their,values,are,set,to,null,value,param,edges,a,collection,of,edges,param,context,the,flink,execution,environment,return,the,newly,created,graph;public,static,k,ev,graph,k,null,value,ev,from,collection,collection,edge,k,ev,edges,execution,environment,context,return,from,data,set,context,from,collection,edges,context
Graph -> public static <K, EV> Graph<K, NullValue, EV> fromCollection(Collection<Edge<K, EV>> edges, 			ExecutionEnvironment context);1458583829;Creates a graph from a Collection of edges._Vertices are created automatically and their values are set to_NullValue.__@param edges a Collection of edges._@param context the flink execution environment._@return the newly created graph.;public static <K, EV> Graph<K, NullValue, EV> fromCollection(Collection<Edge<K, EV>> edges,_			ExecutionEnvironment context) {__		return fromDataSet(context.fromCollection(edges), context)__	};creates,a,graph,from,a,collection,of,edges,vertices,are,created,automatically,and,their,values,are,set,to,null,value,param,edges,a,collection,of,edges,param,context,the,flink,execution,environment,return,the,newly,created,graph;public,static,k,ev,graph,k,null,value,ev,from,collection,collection,edge,k,ev,edges,execution,environment,context,return,from,data,set,context,from,collection,edges,context
Graph -> public static <K, EV> Graph<K, NullValue, EV> fromCollection(Collection<Edge<K, EV>> edges, 			ExecutionEnvironment context);1458583829;Creates a graph from a Collection of edges._Vertices are created automatically and their values are set to_NullValue.__@param edges a Collection of edges._@param context the flink execution environment._@return the newly created graph.;public static <K, EV> Graph<K, NullValue, EV> fromCollection(Collection<Edge<K, EV>> edges,_			ExecutionEnvironment context) {__		return fromDataSet(context.fromCollection(edges), context)__	};creates,a,graph,from,a,collection,of,edges,vertices,are,created,automatically,and,their,values,are,set,to,null,value,param,edges,a,collection,of,edges,param,context,the,flink,execution,environment,return,the,newly,created,graph;public,static,k,ev,graph,k,null,value,ev,from,collection,collection,edge,k,ev,edges,execution,environment,context,return,from,data,set,context,from,collection,edges,context
Graph -> public static <K, EV> Graph<K, NullValue, EV> fromCollection(Collection<Edge<K, EV>> edges, 			ExecutionEnvironment context);1462100316;Creates a graph from a Collection of edges._Vertices are created automatically and their values are set to_NullValue.__@param edges a Collection of edges._@param context the flink execution environment._@return the newly created graph.;public static <K, EV> Graph<K, NullValue, EV> fromCollection(Collection<Edge<K, EV>> edges,_			ExecutionEnvironment context) {__		return fromDataSet(context.fromCollection(edges), context)__	};creates,a,graph,from,a,collection,of,edges,vertices,are,created,automatically,and,their,values,are,set,to,null,value,param,edges,a,collection,of,edges,param,context,the,flink,execution,environment,return,the,newly,created,graph;public,static,k,ev,graph,k,null,value,ev,from,collection,collection,edge,k,ev,edges,execution,environment,context,return,from,data,set,context,from,collection,edges,context
Graph -> public static <K, EV> Graph<K, NullValue, EV> fromCollection(Collection<Edge<K, EV>> edges, 			ExecutionEnvironment context);1462100316;Creates a graph from a Collection of edges._Vertices are created automatically and their values are set to_NullValue.__@param edges a Collection of edges._@param context the flink execution environment._@return the newly created graph.;public static <K, EV> Graph<K, NullValue, EV> fromCollection(Collection<Edge<K, EV>> edges,_			ExecutionEnvironment context) {__		return fromDataSet(context.fromCollection(edges), context)__	};creates,a,graph,from,a,collection,of,edges,vertices,are,created,automatically,and,their,values,are,set,to,null,value,param,edges,a,collection,of,edges,param,context,the,flink,execution,environment,return,the,newly,created,graph;public,static,k,ev,graph,k,null,value,ev,from,collection,collection,edge,k,ev,edges,execution,environment,context,return,from,data,set,context,from,collection,edges,context
Graph -> public static <K, EV> Graph<K, NullValue, EV> fromCollection(Collection<Edge<K, EV>> edges, 			ExecutionEnvironment context);1462205213;Creates a graph from a Collection of edges._Vertices are created automatically and their values are set to_NullValue.__@param edges a Collection of edges._@param context the flink execution environment._@return the newly created graph.;public static <K, EV> Graph<K, NullValue, EV> fromCollection(Collection<Edge<K, EV>> edges,_			ExecutionEnvironment context) {__		return fromDataSet(context.fromCollection(edges), context)__	};creates,a,graph,from,a,collection,of,edges,vertices,are,created,automatically,and,their,values,are,set,to,null,value,param,edges,a,collection,of,edges,param,context,the,flink,execution,environment,return,the,newly,created,graph;public,static,k,ev,graph,k,null,value,ev,from,collection,collection,edge,k,ev,edges,execution,environment,context,return,from,data,set,context,from,collection,edges,context
Graph -> public static <K, EV> Graph<K, NullValue, EV> fromCollection(Collection<Edge<K, EV>> edges, 			ExecutionEnvironment context);1462208859;Creates a graph from a Collection of edges._Vertices are created automatically and their values are set to_NullValue.__@param edges a Collection of edges._@param context the flink execution environment._@return the newly created graph.;public static <K, EV> Graph<K, NullValue, EV> fromCollection(Collection<Edge<K, EV>> edges,_			ExecutionEnvironment context) {__		return fromDataSet(context.fromCollection(edges), context)__	};creates,a,graph,from,a,collection,of,edges,vertices,are,created,automatically,and,their,values,are,set,to,null,value,param,edges,a,collection,of,edges,param,context,the,flink,execution,environment,return,the,newly,created,graph;public,static,k,ev,graph,k,null,value,ev,from,collection,collection,edge,k,ev,edges,execution,environment,context,return,from,data,set,context,from,collection,edges,context
Graph -> public static <K, EV> Graph<K, NullValue, EV> fromCollection(Collection<Edge<K, EV>> edges, 			ExecutionEnvironment context);1462809297;Creates a graph from a Collection of edges._Vertices are created automatically and their values are set to_NullValue.__@param edges a Collection of edges._@param context the flink execution environment._@return the newly created graph.;public static <K, EV> Graph<K, NullValue, EV> fromCollection(Collection<Edge<K, EV>> edges,_			ExecutionEnvironment context) {__		return fromDataSet(context.fromCollection(edges), context)__	};creates,a,graph,from,a,collection,of,edges,vertices,are,created,automatically,and,their,values,are,set,to,null,value,param,edges,a,collection,of,edges,param,context,the,flink,execution,environment,return,the,newly,created,graph;public,static,k,ev,graph,k,null,value,ev,from,collection,collection,edge,k,ev,edges,execution,environment,context,return,from,data,set,context,from,collection,edges,context
Graph -> public static <K, EV> Graph<K, NullValue, EV> fromCollection(Collection<Edge<K, EV>> edges, 			ExecutionEnvironment context);1465316775;Creates a graph from a Collection of edges._Vertices are created automatically and their values are set to_NullValue.__@param edges a Collection of edges._@param context the flink execution environment._@return the newly created graph.;public static <K, EV> Graph<K, NullValue, EV> fromCollection(Collection<Edge<K, EV>> edges,_			ExecutionEnvironment context) {__		return fromDataSet(context.fromCollection(edges), context)__	};creates,a,graph,from,a,collection,of,edges,vertices,are,created,automatically,and,their,values,are,set,to,null,value,param,edges,a,collection,of,edges,param,context,the,flink,execution,environment,return,the,newly,created,graph;public,static,k,ev,graph,k,null,value,ev,from,collection,collection,edge,k,ev,edges,execution,environment,context,return,from,data,set,context,from,collection,edges,context
Graph -> public static <K, EV> Graph<K, NullValue, EV> fromCollection(Collection<Edge<K, EV>> edges, 			ExecutionEnvironment context);1466789678;Creates a graph from a Collection of edges._Vertices are created automatically and their values are set to_NullValue.__@param edges a Collection of edges._@param context the flink execution environment._@return the newly created graph.;public static <K, EV> Graph<K, NullValue, EV> fromCollection(Collection<Edge<K, EV>> edges,_			ExecutionEnvironment context) {__		return fromDataSet(context.fromCollection(edges), context)__	};creates,a,graph,from,a,collection,of,edges,vertices,are,created,automatically,and,their,values,are,set,to,null,value,param,edges,a,collection,of,edges,param,context,the,flink,execution,environment,return,the,newly,created,graph;public,static,k,ev,graph,k,null,value,ev,from,collection,collection,edge,k,ev,edges,execution,environment,context,return,from,data,set,context,from,collection,edges,context
Graph -> public static <K, EV> Graph<K, NullValue, EV> fromCollection(Collection<Edge<K, EV>> edges, 			ExecutionEnvironment context);1467140656;Creates a graph from a Collection of edges._Vertices are created automatically and their values are set to_NullValue.__@param edges a Collection of edges._@param context the flink execution environment._@return the newly created graph.;public static <K, EV> Graph<K, NullValue, EV> fromCollection(Collection<Edge<K, EV>> edges,_			ExecutionEnvironment context) {__		return fromDataSet(context.fromCollection(edges), context)__	};creates,a,graph,from,a,collection,of,edges,vertices,are,created,automatically,and,their,values,are,set,to,null,value,param,edges,a,collection,of,edges,param,context,the,flink,execution,environment,return,the,newly,created,graph;public,static,k,ev,graph,k,null,value,ev,from,collection,collection,edge,k,ev,edges,execution,environment,context,return,from,data,set,context,from,collection,edges,context
Graph -> public static <K, EV> Graph<K, NullValue, EV> fromCollection(Collection<Edge<K, EV>> edges, 			ExecutionEnvironment context);1467306272;Creates a graph from a Collection of edges._Vertices are created automatically and their values are set to_NullValue.__@param edges a Collection of edges._@param context the flink execution environment._@return the newly created graph.;public static <K, EV> Graph<K, NullValue, EV> fromCollection(Collection<Edge<K, EV>> edges,_			ExecutionEnvironment context) {__		return fromDataSet(context.fromCollection(edges), context)__	};creates,a,graph,from,a,collection,of,edges,vertices,are,created,automatically,and,their,values,are,set,to,null,value,param,edges,a,collection,of,edges,param,context,the,flink,execution,environment,return,the,newly,created,graph;public,static,k,ev,graph,k,null,value,ev,from,collection,collection,edge,k,ev,edges,execution,environment,context,return,from,data,set,context,from,collection,edges,context
Graph -> public static <K, EV> Graph<K, NullValue, EV> fromCollection(Collection<Edge<K, EV>> edges, 			ExecutionEnvironment context);1470042815;Creates a graph from a Collection of edges._Vertices are created automatically and their values are set to_NullValue.__@param edges a Collection of edges._@param context the flink execution environment._@return the newly created graph.;public static <K, EV> Graph<K, NullValue, EV> fromCollection(Collection<Edge<K, EV>> edges,_			ExecutionEnvironment context) {__		return fromDataSet(context.fromCollection(edges), context)__	};creates,a,graph,from,a,collection,of,edges,vertices,are,created,automatically,and,their,values,are,set,to,null,value,param,edges,a,collection,of,edges,param,context,the,flink,execution,environment,return,the,newly,created,graph;public,static,k,ev,graph,k,null,value,ev,from,collection,collection,edge,k,ev,edges,execution,environment,context,return,from,data,set,context,from,collection,edges,context
Graph -> public static <K, EV> Graph<K, NullValue, EV> fromCollection(Collection<Edge<K, EV>> edges, 			ExecutionEnvironment context);1475684776;Creates a graph from a Collection of edges._Vertices are created automatically and their values are set to_NullValue.__@param edges a Collection of edges._@param context the flink execution environment._@return the newly created graph.;public static <K, EV> Graph<K, NullValue, EV> fromCollection(Collection<Edge<K, EV>> edges,_			ExecutionEnvironment context) {__		return fromDataSet(context.fromCollection(edges), context)__	};creates,a,graph,from,a,collection,of,edges,vertices,are,created,automatically,and,their,values,are,set,to,null,value,param,edges,a,collection,of,edges,param,context,the,flink,execution,environment,return,the,newly,created,graph;public,static,k,ev,graph,k,null,value,ev,from,collection,collection,edge,k,ev,edges,execution,environment,context,return,from,data,set,context,from,collection,edges,context
Graph -> public static <K, EV> Graph<K, NullValue, EV> fromCollection(Collection<Edge<K, EV>> edges, 			ExecutionEnvironment context);1475685606;Creates a graph from a Collection of edges._Vertices are created automatically and their values are set to_NullValue.__@param edges a Collection of edges._@param context the flink execution environment._@return the newly created graph.;public static <K, EV> Graph<K, NullValue, EV> fromCollection(Collection<Edge<K, EV>> edges,_			ExecutionEnvironment context) {__		return fromDataSet(context.fromCollection(edges), context)__	};creates,a,graph,from,a,collection,of,edges,vertices,are,created,automatically,and,their,values,are,set,to,null,value,param,edges,a,collection,of,edges,param,context,the,flink,execution,environment,return,the,newly,created,graph;public,static,k,ev,graph,k,null,value,ev,from,collection,collection,edge,k,ev,edges,execution,environment,context,return,from,data,set,context,from,collection,edges,context
Graph -> public static <K, EV> Graph<K, NullValue, EV> fromCollection(Collection<Edge<K, EV>> edges, 			ExecutionEnvironment context);1481745825;Creates a graph from a Collection of edges._Vertices are created automatically and their values are set to_NullValue.__@param edges a Collection of edges._@param context the flink execution environment._@return the newly created graph.;public static <K, EV> Graph<K, NullValue, EV> fromCollection(Collection<Edge<K, EV>> edges,_			ExecutionEnvironment context) {__		return fromDataSet(context.fromCollection(edges), context)__	};creates,a,graph,from,a,collection,of,edges,vertices,are,created,automatically,and,their,values,are,set,to,null,value,param,edges,a,collection,of,edges,param,context,the,flink,execution,environment,return,the,newly,created,graph;public,static,k,ev,graph,k,null,value,ev,from,collection,collection,edge,k,ev,edges,execution,environment,context,return,from,data,set,context,from,collection,edges,context
Graph -> public static <K, EV> Graph<K, NullValue, EV> fromCollection(Collection<Edge<K, EV>> edges, 			ExecutionEnvironment context);1481881009;Creates a graph from a Collection of edges._Vertices are created automatically and their values are set to_NullValue.__@param edges a Collection of edges._@param context the flink execution environment._@return the newly created graph.;public static <K, EV> Graph<K, NullValue, EV> fromCollection(Collection<Edge<K, EV>> edges,_			ExecutionEnvironment context) {__		return fromDataSet(context.fromCollection(edges), context)__	};creates,a,graph,from,a,collection,of,edges,vertices,are,created,automatically,and,their,values,are,set,to,null,value,param,edges,a,collection,of,edges,param,context,the,flink,execution,environment,return,the,newly,created,graph;public,static,k,ev,graph,k,null,value,ev,from,collection,collection,edge,k,ev,edges,execution,environment,context,return,from,data,set,context,from,collection,edges,context
Graph -> public static <K, EV> Graph<K, NullValue, EV> fromCollection(Collection<Edge<K, EV>> edges, 			ExecutionEnvironment context);1484160227;Creates a graph from a Collection of edges._Vertices are created automatically and their values are set to_NullValue.__@param edges a Collection of edges._@param context the flink execution environment._@return the newly created graph.;public static <K, EV> Graph<K, NullValue, EV> fromCollection(Collection<Edge<K, EV>> edges,_			ExecutionEnvironment context) {__		return fromDataSet(context.fromCollection(edges), context)__	};creates,a,graph,from,a,collection,of,edges,vertices,are,created,automatically,and,their,values,are,set,to,null,value,param,edges,a,collection,of,edges,param,context,the,flink,execution,environment,return,the,newly,created,graph;public,static,k,ev,graph,k,null,value,ev,from,collection,collection,edge,k,ev,edges,execution,environment,context,return,from,data,set,context,from,collection,edges,context
Graph -> public static <K, EV> Graph<K, NullValue, EV> fromCollection(Collection<Edge<K, EV>> edges, 			ExecutionEnvironment context);1484685504;Creates a graph from a Collection of edges._Vertices are created automatically and their values are set to_NullValue.__@param edges a Collection of edges._@param context the flink execution environment._@return the newly created graph.;public static <K, EV> Graph<K, NullValue, EV> fromCollection(Collection<Edge<K, EV>> edges,_			ExecutionEnvironment context) {__		return fromDataSet(context.fromCollection(edges), context)__	};creates,a,graph,from,a,collection,of,edges,vertices,are,created,automatically,and,their,values,are,set,to,null,value,param,edges,a,collection,of,edges,param,context,the,flink,execution,environment,return,the,newly,created,graph;public,static,k,ev,graph,k,null,value,ev,from,collection,collection,edge,k,ev,edges,execution,environment,context,return,from,data,set,context,from,collection,edges,context
Graph -> public static <K, EV> Graph<K, NullValue, EV> fromCollection(Collection<Edge<K, EV>> edges, 			ExecutionEnvironment context);1489068942;Creates a graph from a Collection of edges._Vertices are created automatically and their values are set to_NullValue.__@param edges a Collection of edges._@param context the flink execution environment._@return the newly created graph.;public static <K, EV> Graph<K, NullValue, EV> fromCollection(Collection<Edge<K, EV>> edges,_			ExecutionEnvironment context) {__		return fromDataSet(context.fromCollection(edges), context)__	};creates,a,graph,from,a,collection,of,edges,vertices,are,created,automatically,and,their,values,are,set,to,null,value,param,edges,a,collection,of,edges,param,context,the,flink,execution,environment,return,the,newly,created,graph;public,static,k,ev,graph,k,null,value,ev,from,collection,collection,edge,k,ev,edges,execution,environment,context,return,from,data,set,context,from,collection,edges,context
Graph -> public static <K, EV> Graph<K, NullValue, EV> fromCollection(Collection<Edge<K, EV>> edges, 			ExecutionEnvironment context);1490973446;Creates a graph from a Collection of edges._Vertices are created automatically and their values are set to_NullValue.__@param edges a Collection of edges._@param context the flink execution environment._@return the newly created graph.;public static <K, EV> Graph<K, NullValue, EV> fromCollection(Collection<Edge<K, EV>> edges,_			ExecutionEnvironment context) {__		return fromDataSet(context.fromCollection(edges), context)__	};creates,a,graph,from,a,collection,of,edges,vertices,are,created,automatically,and,their,values,are,set,to,null,value,param,edges,a,collection,of,edges,param,context,the,flink,execution,environment,return,the,newly,created,graph;public,static,k,ev,graph,k,null,value,ev,from,collection,collection,edge,k,ev,edges,execution,environment,context,return,from,data,set,context,from,collection,edges,context
Graph -> public static <K, EV> Graph<K, NullValue, EV> fromCollection(Collection<Edge<K, EV>> edges, 			ExecutionEnvironment context);1495819075;Creates a graph from a Collection of edges._Vertices are created automatically and their values are set to_NullValue.__@param edges a Collection of edges._@param context the flink execution environment._@return the newly created graph.;public static <K, EV> Graph<K, NullValue, EV> fromCollection(Collection<Edge<K, EV>> edges,_			ExecutionEnvironment context) {__		return fromDataSet(context.fromCollection(edges), context)__	};creates,a,graph,from,a,collection,of,edges,vertices,are,created,automatically,and,their,values,are,set,to,null,value,param,edges,a,collection,of,edges,param,context,the,flink,execution,environment,return,the,newly,created,graph;public,static,k,ev,graph,k,null,value,ev,from,collection,collection,edge,k,ev,edges,execution,environment,context,return,from,data,set,context,from,collection,edges,context
Graph -> public static <K, EV> Graph<K, NullValue, EV> fromCollection(Collection<Edge<K, EV>> edges, 			ExecutionEnvironment context);1502111816;Creates a graph from a Collection of edges._Vertices are created automatically and their values are set to_NullValue.__@param edges a Collection of edges._@param context the flink execution environment._@return the newly created graph.;public static <K, EV> Graph<K, NullValue, EV> fromCollection(Collection<Edge<K, EV>> edges,_			ExecutionEnvironment context) {__		return fromDataSet(context.fromCollection(edges), context)__	};creates,a,graph,from,a,collection,of,edges,vertices,are,created,automatically,and,their,values,are,set,to,null,value,param,edges,a,collection,of,edges,param,context,the,flink,execution,environment,return,the,newly,created,graph;public,static,k,ev,graph,k,null,value,ev,from,collection,collection,edge,k,ev,edges,execution,environment,context,return,from,data,set,context,from,collection,edges,context
Graph -> public <M> Graph<K, VV, EV> runScatterGatherIteration( 			VertexUpdateFunction<K, VV, M> vertexUpdateFunction, 			MessagingFunction<K, VV, M, EV> messagingFunction, 			int maximumNumberOfIterations);1454404649;Runs a ScatterGather iteration on the graph._No configuration options are provided.__@param vertexUpdateFunction the vertex update function_@param messagingFunction the messaging function_@param maximumNumberOfIterations maximum number of iterations to perform__@return the updated Graph after the scatter-gather iteration has converged or_after maximumNumberOfIterations.;public <M> Graph<K, VV, EV> runScatterGatherIteration(_			VertexUpdateFunction<K, VV, M> vertexUpdateFunction,_			MessagingFunction<K, VV, M, EV> messagingFunction,_			int maximumNumberOfIterations) {__		return this.runScatterGatherIteration(vertexUpdateFunction, messagingFunction,_				maximumNumberOfIterations, null)__	};runs,a,scatter,gather,iteration,on,the,graph,no,configuration,options,are,provided,param,vertex,update,function,the,vertex,update,function,param,messaging,function,the,messaging,function,param,maximum,number,of,iterations,maximum,number,of,iterations,to,perform,return,the,updated,graph,after,the,scatter,gather,iteration,has,converged,or,after,maximum,number,of,iterations;public,m,graph,k,vv,ev,run,scatter,gather,iteration,vertex,update,function,k,vv,m,vertex,update,function,messaging,function,k,vv,m,ev,messaging,function,int,maximum,number,of,iterations,return,this,run,scatter,gather,iteration,vertex,update,function,messaging,function,maximum,number,of,iterations,null
Graph -> public <M> Graph<K, VV, EV> runScatterGatherIteration( 			VertexUpdateFunction<K, VV, M> vertexUpdateFunction, 			MessagingFunction<K, VV, M, EV> messagingFunction, 			int maximumNumberOfIterations);1458583829;Runs a ScatterGather iteration on the graph._No configuration options are provided.__@param vertexUpdateFunction the vertex update function_@param messagingFunction the messaging function_@param maximumNumberOfIterations maximum number of iterations to perform__@return the updated Graph after the scatter-gather iteration has converged or_after maximumNumberOfIterations.;public <M> Graph<K, VV, EV> runScatterGatherIteration(_			VertexUpdateFunction<K, VV, M> vertexUpdateFunction,_			MessagingFunction<K, VV, M, EV> messagingFunction,_			int maximumNumberOfIterations) {__		return this.runScatterGatherIteration(vertexUpdateFunction, messagingFunction,_				maximumNumberOfIterations, null)__	};runs,a,scatter,gather,iteration,on,the,graph,no,configuration,options,are,provided,param,vertex,update,function,the,vertex,update,function,param,messaging,function,the,messaging,function,param,maximum,number,of,iterations,maximum,number,of,iterations,to,perform,return,the,updated,graph,after,the,scatter,gather,iteration,has,converged,or,after,maximum,number,of,iterations;public,m,graph,k,vv,ev,run,scatter,gather,iteration,vertex,update,function,k,vv,m,vertex,update,function,messaging,function,k,vv,m,ev,messaging,function,int,maximum,number,of,iterations,return,this,run,scatter,gather,iteration,vertex,update,function,messaging,function,maximum,number,of,iterations,null
Graph -> public <M> Graph<K, VV, EV> runScatterGatherIteration( 			VertexUpdateFunction<K, VV, M> vertexUpdateFunction, 			MessagingFunction<K, VV, M, EV> messagingFunction, 			int maximumNumberOfIterations);1458583829;Runs a ScatterGather iteration on the graph._No configuration options are provided.__@param vertexUpdateFunction the vertex update function_@param messagingFunction the messaging function_@param maximumNumberOfIterations maximum number of iterations to perform__@return the updated Graph after the scatter-gather iteration has converged or_after maximumNumberOfIterations.;public <M> Graph<K, VV, EV> runScatterGatherIteration(_			VertexUpdateFunction<K, VV, M> vertexUpdateFunction,_			MessagingFunction<K, VV, M, EV> messagingFunction,_			int maximumNumberOfIterations) {__		return this.runScatterGatherIteration(vertexUpdateFunction, messagingFunction,_				maximumNumberOfIterations, null)__	};runs,a,scatter,gather,iteration,on,the,graph,no,configuration,options,are,provided,param,vertex,update,function,the,vertex,update,function,param,messaging,function,the,messaging,function,param,maximum,number,of,iterations,maximum,number,of,iterations,to,perform,return,the,updated,graph,after,the,scatter,gather,iteration,has,converged,or,after,maximum,number,of,iterations;public,m,graph,k,vv,ev,run,scatter,gather,iteration,vertex,update,function,k,vv,m,vertex,update,function,messaging,function,k,vv,m,ev,messaging,function,int,maximum,number,of,iterations,return,this,run,scatter,gather,iteration,vertex,update,function,messaging,function,maximum,number,of,iterations,null
Graph -> public <M> Graph<K, VV, EV> runScatterGatherIteration( 			VertexUpdateFunction<K, VV, M> vertexUpdateFunction, 			MessagingFunction<K, VV, M, EV> messagingFunction, 			int maximumNumberOfIterations);1462100316;Runs a ScatterGather iteration on the graph._No configuration options are provided.__@param vertexUpdateFunction the vertex update function_@param messagingFunction the messaging function_@param maximumNumberOfIterations maximum number of iterations to perform__@return the updated Graph after the scatter-gather iteration has converged or_after maximumNumberOfIterations.;public <M> Graph<K, VV, EV> runScatterGatherIteration(_			VertexUpdateFunction<K, VV, M> vertexUpdateFunction,_			MessagingFunction<K, VV, M, EV> messagingFunction,_			int maximumNumberOfIterations) {__		return this.runScatterGatherIteration(vertexUpdateFunction, messagingFunction,_				maximumNumberOfIterations, null)__	};runs,a,scatter,gather,iteration,on,the,graph,no,configuration,options,are,provided,param,vertex,update,function,the,vertex,update,function,param,messaging,function,the,messaging,function,param,maximum,number,of,iterations,maximum,number,of,iterations,to,perform,return,the,updated,graph,after,the,scatter,gather,iteration,has,converged,or,after,maximum,number,of,iterations;public,m,graph,k,vv,ev,run,scatter,gather,iteration,vertex,update,function,k,vv,m,vertex,update,function,messaging,function,k,vv,m,ev,messaging,function,int,maximum,number,of,iterations,return,this,run,scatter,gather,iteration,vertex,update,function,messaging,function,maximum,number,of,iterations,null
Graph -> public <M> Graph<K, VV, EV> runScatterGatherIteration( 			VertexUpdateFunction<K, VV, M> vertexUpdateFunction, 			MessagingFunction<K, VV, M, EV> messagingFunction, 			int maximumNumberOfIterations);1462100316;Runs a ScatterGather iteration on the graph._No configuration options are provided.__@param vertexUpdateFunction the vertex update function_@param messagingFunction the messaging function_@param maximumNumberOfIterations maximum number of iterations to perform__@return the updated Graph after the scatter-gather iteration has converged or_after maximumNumberOfIterations.;public <M> Graph<K, VV, EV> runScatterGatherIteration(_			VertexUpdateFunction<K, VV, M> vertexUpdateFunction,_			MessagingFunction<K, VV, M, EV> messagingFunction,_			int maximumNumberOfIterations) {__		return this.runScatterGatherIteration(vertexUpdateFunction, messagingFunction,_				maximumNumberOfIterations, null)__	};runs,a,scatter,gather,iteration,on,the,graph,no,configuration,options,are,provided,param,vertex,update,function,the,vertex,update,function,param,messaging,function,the,messaging,function,param,maximum,number,of,iterations,maximum,number,of,iterations,to,perform,return,the,updated,graph,after,the,scatter,gather,iteration,has,converged,or,after,maximum,number,of,iterations;public,m,graph,k,vv,ev,run,scatter,gather,iteration,vertex,update,function,k,vv,m,vertex,update,function,messaging,function,k,vv,m,ev,messaging,function,int,maximum,number,of,iterations,return,this,run,scatter,gather,iteration,vertex,update,function,messaging,function,maximum,number,of,iterations,null
Graph -> public <M> Graph<K, VV, EV> runScatterGatherIteration( 			VertexUpdateFunction<K, VV, M> vertexUpdateFunction, 			MessagingFunction<K, VV, M, EV> messagingFunction, 			int maximumNumberOfIterations);1462205213;Runs a ScatterGather iteration on the graph._No configuration options are provided.__@param vertexUpdateFunction the vertex update function_@param messagingFunction the messaging function_@param maximumNumberOfIterations maximum number of iterations to perform__@return the updated Graph after the scatter-gather iteration has converged or_after maximumNumberOfIterations.;public <M> Graph<K, VV, EV> runScatterGatherIteration(_			VertexUpdateFunction<K, VV, M> vertexUpdateFunction,_			MessagingFunction<K, VV, M, EV> messagingFunction,_			int maximumNumberOfIterations) {__		return this.runScatterGatherIteration(vertexUpdateFunction, messagingFunction,_				maximumNumberOfIterations, null)__	};runs,a,scatter,gather,iteration,on,the,graph,no,configuration,options,are,provided,param,vertex,update,function,the,vertex,update,function,param,messaging,function,the,messaging,function,param,maximum,number,of,iterations,maximum,number,of,iterations,to,perform,return,the,updated,graph,after,the,scatter,gather,iteration,has,converged,or,after,maximum,number,of,iterations;public,m,graph,k,vv,ev,run,scatter,gather,iteration,vertex,update,function,k,vv,m,vertex,update,function,messaging,function,k,vv,m,ev,messaging,function,int,maximum,number,of,iterations,return,this,run,scatter,gather,iteration,vertex,update,function,messaging,function,maximum,number,of,iterations,null
Graph -> public <M> Graph<K, VV, EV> runScatterGatherIteration( 			VertexUpdateFunction<K, VV, M> vertexUpdateFunction, 			MessagingFunction<K, VV, M, EV> messagingFunction, 			int maximumNumberOfIterations);1462208859;Runs a ScatterGather iteration on the graph._No configuration options are provided.__@param vertexUpdateFunction the vertex update function_@param messagingFunction the messaging function_@param maximumNumberOfIterations maximum number of iterations to perform__@return the updated Graph after the scatter-gather iteration has converged or_after maximumNumberOfIterations.;public <M> Graph<K, VV, EV> runScatterGatherIteration(_			VertexUpdateFunction<K, VV, M> vertexUpdateFunction,_			MessagingFunction<K, VV, M, EV> messagingFunction,_			int maximumNumberOfIterations) {__		return this.runScatterGatherIteration(vertexUpdateFunction, messagingFunction,_				maximumNumberOfIterations, null)__	};runs,a,scatter,gather,iteration,on,the,graph,no,configuration,options,are,provided,param,vertex,update,function,the,vertex,update,function,param,messaging,function,the,messaging,function,param,maximum,number,of,iterations,maximum,number,of,iterations,to,perform,return,the,updated,graph,after,the,scatter,gather,iteration,has,converged,or,after,maximum,number,of,iterations;public,m,graph,k,vv,ev,run,scatter,gather,iteration,vertex,update,function,k,vv,m,vertex,update,function,messaging,function,k,vv,m,ev,messaging,function,int,maximum,number,of,iterations,return,this,run,scatter,gather,iteration,vertex,update,function,messaging,function,maximum,number,of,iterations,null
Graph -> public <M> Graph<K, VV, EV> runScatterGatherIteration( 			VertexUpdateFunction<K, VV, M> vertexUpdateFunction, 			MessagingFunction<K, VV, M, EV> messagingFunction, 			int maximumNumberOfIterations);1462809297;Runs a ScatterGather iteration on the graph._No configuration options are provided.__@param vertexUpdateFunction the vertex update function_@param messagingFunction the messaging function_@param maximumNumberOfIterations maximum number of iterations to perform__@return the updated Graph after the scatter-gather iteration has converged or_after maximumNumberOfIterations.;public <M> Graph<K, VV, EV> runScatterGatherIteration(_			VertexUpdateFunction<K, VV, M> vertexUpdateFunction,_			MessagingFunction<K, VV, M, EV> messagingFunction,_			int maximumNumberOfIterations) {__		return this.runScatterGatherIteration(vertexUpdateFunction, messagingFunction,_				maximumNumberOfIterations, null)__	};runs,a,scatter,gather,iteration,on,the,graph,no,configuration,options,are,provided,param,vertex,update,function,the,vertex,update,function,param,messaging,function,the,messaging,function,param,maximum,number,of,iterations,maximum,number,of,iterations,to,perform,return,the,updated,graph,after,the,scatter,gather,iteration,has,converged,or,after,maximum,number,of,iterations;public,m,graph,k,vv,ev,run,scatter,gather,iteration,vertex,update,function,k,vv,m,vertex,update,function,messaging,function,k,vv,m,ev,messaging,function,int,maximum,number,of,iterations,return,this,run,scatter,gather,iteration,vertex,update,function,messaging,function,maximum,number,of,iterations,null
Graph -> public <M> Graph<K, VV, EV> runScatterGatherIteration( 			VertexUpdateFunction<K, VV, M> vertexUpdateFunction, 			MessagingFunction<K, VV, M, EV> messagingFunction, 			int maximumNumberOfIterations);1465316775;Runs a ScatterGather iteration on the graph._No configuration options are provided.__@param vertexUpdateFunction the vertex update function_@param messagingFunction the messaging function_@param maximumNumberOfIterations maximum number of iterations to perform__@return the updated Graph after the scatter-gather iteration has converged or_after maximumNumberOfIterations.;public <M> Graph<K, VV, EV> runScatterGatherIteration(_			VertexUpdateFunction<K, VV, M> vertexUpdateFunction,_			MessagingFunction<K, VV, M, EV> messagingFunction,_			int maximumNumberOfIterations) {__		return this.runScatterGatherIteration(vertexUpdateFunction, messagingFunction,_				maximumNumberOfIterations, null)__	};runs,a,scatter,gather,iteration,on,the,graph,no,configuration,options,are,provided,param,vertex,update,function,the,vertex,update,function,param,messaging,function,the,messaging,function,param,maximum,number,of,iterations,maximum,number,of,iterations,to,perform,return,the,updated,graph,after,the,scatter,gather,iteration,has,converged,or,after,maximum,number,of,iterations;public,m,graph,k,vv,ev,run,scatter,gather,iteration,vertex,update,function,k,vv,m,vertex,update,function,messaging,function,k,vv,m,ev,messaging,function,int,maximum,number,of,iterations,return,this,run,scatter,gather,iteration,vertex,update,function,messaging,function,maximum,number,of,iterations,null
Graph -> public <M> Graph<K, VV, EV> runScatterGatherIteration( 			VertexUpdateFunction<K, VV, M> vertexUpdateFunction, 			MessagingFunction<K, VV, M, EV> messagingFunction, 			int maximumNumberOfIterations);1466789678;Runs a ScatterGather iteration on the graph._No configuration options are provided.__@param vertexUpdateFunction the vertex update function_@param messagingFunction the messaging function_@param maximumNumberOfIterations maximum number of iterations to perform__@return the updated Graph after the scatter-gather iteration has converged or_after maximumNumberOfIterations.;public <M> Graph<K, VV, EV> runScatterGatherIteration(_			VertexUpdateFunction<K, VV, M> vertexUpdateFunction,_			MessagingFunction<K, VV, M, EV> messagingFunction,_			int maximumNumberOfIterations) {__		return this.runScatterGatherIteration(vertexUpdateFunction, messagingFunction,_				maximumNumberOfIterations, null)__	};runs,a,scatter,gather,iteration,on,the,graph,no,configuration,options,are,provided,param,vertex,update,function,the,vertex,update,function,param,messaging,function,the,messaging,function,param,maximum,number,of,iterations,maximum,number,of,iterations,to,perform,return,the,updated,graph,after,the,scatter,gather,iteration,has,converged,or,after,maximum,number,of,iterations;public,m,graph,k,vv,ev,run,scatter,gather,iteration,vertex,update,function,k,vv,m,vertex,update,function,messaging,function,k,vv,m,ev,messaging,function,int,maximum,number,of,iterations,return,this,run,scatter,gather,iteration,vertex,update,function,messaging,function,maximum,number,of,iterations,null
Graph -> public <M> Graph<K, VV, EV> runScatterGatherIteration( 			VertexUpdateFunction<K, VV, M> vertexUpdateFunction, 			MessagingFunction<K, VV, M, EV> messagingFunction, 			int maximumNumberOfIterations);1467140656;Runs a ScatterGather iteration on the graph._No configuration options are provided.__@param vertexUpdateFunction the vertex update function_@param messagingFunction the messaging function_@param maximumNumberOfIterations maximum number of iterations to perform__@return the updated Graph after the scatter-gather iteration has converged or_after maximumNumberOfIterations.;public <M> Graph<K, VV, EV> runScatterGatherIteration(_			VertexUpdateFunction<K, VV, M> vertexUpdateFunction,_			MessagingFunction<K, VV, M, EV> messagingFunction,_			int maximumNumberOfIterations) {__		return this.runScatterGatherIteration(vertexUpdateFunction, messagingFunction,_				maximumNumberOfIterations, null)__	};runs,a,scatter,gather,iteration,on,the,graph,no,configuration,options,are,provided,param,vertex,update,function,the,vertex,update,function,param,messaging,function,the,messaging,function,param,maximum,number,of,iterations,maximum,number,of,iterations,to,perform,return,the,updated,graph,after,the,scatter,gather,iteration,has,converged,or,after,maximum,number,of,iterations;public,m,graph,k,vv,ev,run,scatter,gather,iteration,vertex,update,function,k,vv,m,vertex,update,function,messaging,function,k,vv,m,ev,messaging,function,int,maximum,number,of,iterations,return,this,run,scatter,gather,iteration,vertex,update,function,messaging,function,maximum,number,of,iterations,null
Graph -> public static <K, VV> GraphCsvReader fromCsvReader(String edgesPath, 			final MapFunction<K, VV> vertexValueInitializer, ExecutionEnvironment context);1445261977;Creates a graph from a CSV file of edges. Vertices will be created automatically and_Vertex values can be initialized using a user-defined mapper.__@param edgesPath a path to a CSV file with the Edge data_@param vertexValueInitializer the mapper function that initializes the vertex values._It allows to apply a map transformation on the vertex ID to produce an initial vertex value._@param context the execution environment._@return An instance of {@link org.apache.flink.graph.GraphCsvReader},_on which calling methods to specify types of the Vertex ID, Vertex Value and Edge value returns a Graph.__@see {@link org.apache.flink.graph.GraphCsvReader#types(Class, Class, Class)},_{@link org.apache.flink.graph.GraphCsvReader#vertexTypes(Class, Class)},_{@link org.apache.flink.graph.GraphCsvReader#edgeTypes(Class, Class)} and_{@link org.apache.flink.graph.GraphCsvReader#keyType(Class)}.;public static <K, VV> GraphCsvReader fromCsvReader(String edgesPath,_			final MapFunction<K, VV> vertexValueInitializer, ExecutionEnvironment context) {_		return new GraphCsvReader(edgesPath, vertexValueInitializer, context)__	};creates,a,graph,from,a,csv,file,of,edges,vertices,will,be,created,automatically,and,vertex,values,can,be,initialized,using,a,user,defined,mapper,param,edges,path,a,path,to,a,csv,file,with,the,edge,data,param,vertex,value,initializer,the,mapper,function,that,initializes,the,vertex,values,it,allows,to,apply,a,map,transformation,on,the,vertex,id,to,produce,an,initial,vertex,value,param,context,the,execution,environment,return,an,instance,of,link,org,apache,flink,graph,graph,csv,reader,on,which,calling,methods,to,specify,types,of,the,vertex,id,vertex,value,and,edge,value,returns,a,graph,see,link,org,apache,flink,graph,graph,csv,reader,types,class,class,class,link,org,apache,flink,graph,graph,csv,reader,vertex,types,class,class,link,org,apache,flink,graph,graph,csv,reader,edge,types,class,class,and,link,org,apache,flink,graph,graph,csv,reader,key,type,class;public,static,k,vv,graph,csv,reader,from,csv,reader,string,edges,path,final,map,function,k,vv,vertex,value,initializer,execution,environment,context,return,new,graph,csv,reader,edges,path,vertex,value,initializer,context
Graph -> public static <K, VV> GraphCsvReader fromCsvReader(String edgesPath, 			final MapFunction<K, VV> vertexValueInitializer, ExecutionEnvironment context);1445854323;Creates a graph from a CSV file of edges. Vertices will be created automatically and_Vertex values can be initialized using a user-defined mapper.__@param edgesPath a path to a CSV file with the Edge data_@param vertexValueInitializer the mapper function that initializes the vertex values._It allows to apply a map transformation on the vertex ID to produce an initial vertex value._@param context the execution environment._@return An instance of {@link org.apache.flink.graph.GraphCsvReader},_on which calling methods to specify types of the Vertex ID, Vertex Value and Edge value returns a Graph.__@see {@link org.apache.flink.graph.GraphCsvReader#types(Class, Class, Class)},_{@link org.apache.flink.graph.GraphCsvReader#vertexTypes(Class, Class)},_{@link org.apache.flink.graph.GraphCsvReader#edgeTypes(Class, Class)} and_{@link org.apache.flink.graph.GraphCsvReader#keyType(Class)}.;public static <K, VV> GraphCsvReader fromCsvReader(String edgesPath,_			final MapFunction<K, VV> vertexValueInitializer, ExecutionEnvironment context) {_		return new GraphCsvReader(edgesPath, vertexValueInitializer, context)__	};creates,a,graph,from,a,csv,file,of,edges,vertices,will,be,created,automatically,and,vertex,values,can,be,initialized,using,a,user,defined,mapper,param,edges,path,a,path,to,a,csv,file,with,the,edge,data,param,vertex,value,initializer,the,mapper,function,that,initializes,the,vertex,values,it,allows,to,apply,a,map,transformation,on,the,vertex,id,to,produce,an,initial,vertex,value,param,context,the,execution,environment,return,an,instance,of,link,org,apache,flink,graph,graph,csv,reader,on,which,calling,methods,to,specify,types,of,the,vertex,id,vertex,value,and,edge,value,returns,a,graph,see,link,org,apache,flink,graph,graph,csv,reader,types,class,class,class,link,org,apache,flink,graph,graph,csv,reader,vertex,types,class,class,link,org,apache,flink,graph,graph,csv,reader,edge,types,class,class,and,link,org,apache,flink,graph,graph,csv,reader,key,type,class;public,static,k,vv,graph,csv,reader,from,csv,reader,string,edges,path,final,map,function,k,vv,vertex,value,initializer,execution,environment,context,return,new,graph,csv,reader,edges,path,vertex,value,initializer,context
Graph -> public static <K, VV> GraphCsvReader fromCsvReader(String edgesPath, 			final MapFunction<K, VV> vertexValueInitializer, ExecutionEnvironment context);1446112342;Creates a graph from a CSV file of edges. Vertices will be created automatically and_Vertex values can be initialized using a user-defined mapper.__@param edgesPath a path to a CSV file with the Edge data_@param vertexValueInitializer the mapper function that initializes the vertex values._It allows to apply a map transformation on the vertex ID to produce an initial vertex value._@param context the execution environment._@return An instance of {@link org.apache.flink.graph.GraphCsvReader},_on which calling methods to specify types of the Vertex ID, Vertex Value and Edge value returns a Graph.__@see org.apache.flink.graph.GraphCsvReader#types(Class, Class, Class)_@see org.apache.flink.graph.GraphCsvReader#vertexTypes(Class, Class)_@see org.apache.flink.graph.GraphCsvReader#edgeTypes(Class, Class)_@see org.apache.flink.graph.GraphCsvReader#keyType(Class);public static <K, VV> GraphCsvReader fromCsvReader(String edgesPath,_			final MapFunction<K, VV> vertexValueInitializer, ExecutionEnvironment context) {_		return new GraphCsvReader(edgesPath, vertexValueInitializer, context)__	};creates,a,graph,from,a,csv,file,of,edges,vertices,will,be,created,automatically,and,vertex,values,can,be,initialized,using,a,user,defined,mapper,param,edges,path,a,path,to,a,csv,file,with,the,edge,data,param,vertex,value,initializer,the,mapper,function,that,initializes,the,vertex,values,it,allows,to,apply,a,map,transformation,on,the,vertex,id,to,produce,an,initial,vertex,value,param,context,the,execution,environment,return,an,instance,of,link,org,apache,flink,graph,graph,csv,reader,on,which,calling,methods,to,specify,types,of,the,vertex,id,vertex,value,and,edge,value,returns,a,graph,see,org,apache,flink,graph,graph,csv,reader,types,class,class,class,see,org,apache,flink,graph,graph,csv,reader,vertex,types,class,class,see,org,apache,flink,graph,graph,csv,reader,edge,types,class,class,see,org,apache,flink,graph,graph,csv,reader,key,type,class;public,static,k,vv,graph,csv,reader,from,csv,reader,string,edges,path,final,map,function,k,vv,vertex,value,initializer,execution,environment,context,return,new,graph,csv,reader,edges,path,vertex,value,initializer,context
Graph -> public static <K, VV> GraphCsvReader fromCsvReader(String edgesPath, 			final MapFunction<K, VV> vertexValueInitializer, ExecutionEnvironment context);1447073368;Creates a graph from a CSV file of edges. Vertices will be created automatically and_Vertex values can be initialized using a user-defined mapper.__@param edgesPath a path to a CSV file with the Edge data_@param vertexValueInitializer the mapper function that initializes the vertex values._It allows to apply a map transformation on the vertex ID to produce an initial vertex value._@param context the execution environment._@return An instance of {@link org.apache.flink.graph.GraphCsvReader},_on which calling methods to specify types of the Vertex ID, Vertex Value and Edge value returns a Graph.__@see org.apache.flink.graph.GraphCsvReader#types(Class, Class, Class)_@see org.apache.flink.graph.GraphCsvReader#vertexTypes(Class, Class)_@see org.apache.flink.graph.GraphCsvReader#edgeTypes(Class, Class)_@see org.apache.flink.graph.GraphCsvReader#keyType(Class);public static <K, VV> GraphCsvReader fromCsvReader(String edgesPath,_			final MapFunction<K, VV> vertexValueInitializer, ExecutionEnvironment context) {_		return new GraphCsvReader(edgesPath, vertexValueInitializer, context)__	};creates,a,graph,from,a,csv,file,of,edges,vertices,will,be,created,automatically,and,vertex,values,can,be,initialized,using,a,user,defined,mapper,param,edges,path,a,path,to,a,csv,file,with,the,edge,data,param,vertex,value,initializer,the,mapper,function,that,initializes,the,vertex,values,it,allows,to,apply,a,map,transformation,on,the,vertex,id,to,produce,an,initial,vertex,value,param,context,the,execution,environment,return,an,instance,of,link,org,apache,flink,graph,graph,csv,reader,on,which,calling,methods,to,specify,types,of,the,vertex,id,vertex,value,and,edge,value,returns,a,graph,see,org,apache,flink,graph,graph,csv,reader,types,class,class,class,see,org,apache,flink,graph,graph,csv,reader,vertex,types,class,class,see,org,apache,flink,graph,graph,csv,reader,edge,types,class,class,see,org,apache,flink,graph,graph,csv,reader,key,type,class;public,static,k,vv,graph,csv,reader,from,csv,reader,string,edges,path,final,map,function,k,vv,vertex,value,initializer,execution,environment,context,return,new,graph,csv,reader,edges,path,vertex,value,initializer,context
Graph -> public static <K, VV> GraphCsvReader fromCsvReader(String edgesPath, 			final MapFunction<K, VV> vertexValueInitializer, ExecutionEnvironment context);1454404649;Creates a graph from a CSV file of edges. Vertices will be created automatically and_Vertex values can be initialized using a user-defined mapper.__@param edgesPath a path to a CSV file with the Edge data_@param vertexValueInitializer the mapper function that initializes the vertex values._It allows to apply a map transformation on the vertex ID to produce an initial vertex value._@param context the execution environment._@return An instance of {@link org.apache.flink.graph.GraphCsvReader},_on which calling methods to specify types of the Vertex ID, Vertex Value and Edge value returns a Graph.__@see org.apache.flink.graph.GraphCsvReader#types(Class, Class, Class)_@see org.apache.flink.graph.GraphCsvReader#vertexTypes(Class, Class)_@see org.apache.flink.graph.GraphCsvReader#edgeTypes(Class, Class)_@see org.apache.flink.graph.GraphCsvReader#keyType(Class);public static <K, VV> GraphCsvReader fromCsvReader(String edgesPath,_			final MapFunction<K, VV> vertexValueInitializer, ExecutionEnvironment context) {_		return new GraphCsvReader(edgesPath, vertexValueInitializer, context)__	};creates,a,graph,from,a,csv,file,of,edges,vertices,will,be,created,automatically,and,vertex,values,can,be,initialized,using,a,user,defined,mapper,param,edges,path,a,path,to,a,csv,file,with,the,edge,data,param,vertex,value,initializer,the,mapper,function,that,initializes,the,vertex,values,it,allows,to,apply,a,map,transformation,on,the,vertex,id,to,produce,an,initial,vertex,value,param,context,the,execution,environment,return,an,instance,of,link,org,apache,flink,graph,graph,csv,reader,on,which,calling,methods,to,specify,types,of,the,vertex,id,vertex,value,and,edge,value,returns,a,graph,see,org,apache,flink,graph,graph,csv,reader,types,class,class,class,see,org,apache,flink,graph,graph,csv,reader,vertex,types,class,class,see,org,apache,flink,graph,graph,csv,reader,edge,types,class,class,see,org,apache,flink,graph,graph,csv,reader,key,type,class;public,static,k,vv,graph,csv,reader,from,csv,reader,string,edges,path,final,map,function,k,vv,vertex,value,initializer,execution,environment,context,return,new,graph,csv,reader,edges,path,vertex,value,initializer,context
Graph -> public static <K, VV> GraphCsvReader fromCsvReader(String edgesPath, 			final MapFunction<K, VV> vertexValueInitializer, ExecutionEnvironment context);1458583829;Creates a graph from a CSV file of edges. Vertices will be created automatically and_Vertex values can be initialized using a user-defined mapper.__@param edgesPath a path to a CSV file with the Edge data_@param vertexValueInitializer the mapper function that initializes the vertex values._It allows to apply a map transformation on the vertex ID to produce an initial vertex value._@param context the execution environment._@return An instance of {@link org.apache.flink.graph.GraphCsvReader},_on which calling methods to specify types of the Vertex ID, Vertex Value and Edge value returns a Graph.__@see org.apache.flink.graph.GraphCsvReader#types(Class, Class, Class)_@see org.apache.flink.graph.GraphCsvReader#vertexTypes(Class, Class)_@see org.apache.flink.graph.GraphCsvReader#edgeTypes(Class, Class)_@see org.apache.flink.graph.GraphCsvReader#keyType(Class);public static <K, VV> GraphCsvReader fromCsvReader(String edgesPath,_			final MapFunction<K, VV> vertexValueInitializer, ExecutionEnvironment context) {_		return new GraphCsvReader(edgesPath, vertexValueInitializer, context)__	};creates,a,graph,from,a,csv,file,of,edges,vertices,will,be,created,automatically,and,vertex,values,can,be,initialized,using,a,user,defined,mapper,param,edges,path,a,path,to,a,csv,file,with,the,edge,data,param,vertex,value,initializer,the,mapper,function,that,initializes,the,vertex,values,it,allows,to,apply,a,map,transformation,on,the,vertex,id,to,produce,an,initial,vertex,value,param,context,the,execution,environment,return,an,instance,of,link,org,apache,flink,graph,graph,csv,reader,on,which,calling,methods,to,specify,types,of,the,vertex,id,vertex,value,and,edge,value,returns,a,graph,see,org,apache,flink,graph,graph,csv,reader,types,class,class,class,see,org,apache,flink,graph,graph,csv,reader,vertex,types,class,class,see,org,apache,flink,graph,graph,csv,reader,edge,types,class,class,see,org,apache,flink,graph,graph,csv,reader,key,type,class;public,static,k,vv,graph,csv,reader,from,csv,reader,string,edges,path,final,map,function,k,vv,vertex,value,initializer,execution,environment,context,return,new,graph,csv,reader,edges,path,vertex,value,initializer,context
Graph -> public static <K, VV> GraphCsvReader fromCsvReader(String edgesPath, 			final MapFunction<K, VV> vertexValueInitializer, ExecutionEnvironment context);1458583829;Creates a graph from a CSV file of edges. Vertices will be created automatically and_Vertex values can be initialized using a user-defined mapper.__@param edgesPath a path to a CSV file with the Edge data_@param vertexValueInitializer the mapper function that initializes the vertex values._It allows to apply a map transformation on the vertex ID to produce an initial vertex value._@param context the execution environment._@return An instance of {@link org.apache.flink.graph.GraphCsvReader},_on which calling methods to specify types of the Vertex ID, Vertex Value and Edge value returns a Graph.__@see org.apache.flink.graph.GraphCsvReader#types(Class, Class, Class)_@see org.apache.flink.graph.GraphCsvReader#vertexTypes(Class, Class)_@see org.apache.flink.graph.GraphCsvReader#edgeTypes(Class, Class)_@see org.apache.flink.graph.GraphCsvReader#keyType(Class);public static <K, VV> GraphCsvReader fromCsvReader(String edgesPath,_			final MapFunction<K, VV> vertexValueInitializer, ExecutionEnvironment context) {_		return new GraphCsvReader(edgesPath, vertexValueInitializer, context)__	};creates,a,graph,from,a,csv,file,of,edges,vertices,will,be,created,automatically,and,vertex,values,can,be,initialized,using,a,user,defined,mapper,param,edges,path,a,path,to,a,csv,file,with,the,edge,data,param,vertex,value,initializer,the,mapper,function,that,initializes,the,vertex,values,it,allows,to,apply,a,map,transformation,on,the,vertex,id,to,produce,an,initial,vertex,value,param,context,the,execution,environment,return,an,instance,of,link,org,apache,flink,graph,graph,csv,reader,on,which,calling,methods,to,specify,types,of,the,vertex,id,vertex,value,and,edge,value,returns,a,graph,see,org,apache,flink,graph,graph,csv,reader,types,class,class,class,see,org,apache,flink,graph,graph,csv,reader,vertex,types,class,class,see,org,apache,flink,graph,graph,csv,reader,edge,types,class,class,see,org,apache,flink,graph,graph,csv,reader,key,type,class;public,static,k,vv,graph,csv,reader,from,csv,reader,string,edges,path,final,map,function,k,vv,vertex,value,initializer,execution,environment,context,return,new,graph,csv,reader,edges,path,vertex,value,initializer,context
Graph -> public static <K, VV> GraphCsvReader fromCsvReader(String edgesPath, 			final MapFunction<K, VV> vertexValueInitializer, ExecutionEnvironment context);1462100316;Creates a graph from a CSV file of edges. Vertices will be created automatically and_Vertex values can be initialized using a user-defined mapper.__@param edgesPath a path to a CSV file with the Edge data_@param vertexValueInitializer the mapper function that initializes the vertex values._It allows to apply a map transformation on the vertex ID to produce an initial vertex value._@param context the execution environment._@return An instance of {@link org.apache.flink.graph.GraphCsvReader},_on which calling methods to specify types of the Vertex ID, Vertex Value and Edge value returns a Graph.__@see org.apache.flink.graph.GraphCsvReader#types(Class, Class, Class)_@see org.apache.flink.graph.GraphCsvReader#vertexTypes(Class, Class)_@see org.apache.flink.graph.GraphCsvReader#edgeTypes(Class, Class)_@see org.apache.flink.graph.GraphCsvReader#keyType(Class);public static <K, VV> GraphCsvReader fromCsvReader(String edgesPath,_			final MapFunction<K, VV> vertexValueInitializer, ExecutionEnvironment context) {_		return new GraphCsvReader(edgesPath, vertexValueInitializer, context)__	};creates,a,graph,from,a,csv,file,of,edges,vertices,will,be,created,automatically,and,vertex,values,can,be,initialized,using,a,user,defined,mapper,param,edges,path,a,path,to,a,csv,file,with,the,edge,data,param,vertex,value,initializer,the,mapper,function,that,initializes,the,vertex,values,it,allows,to,apply,a,map,transformation,on,the,vertex,id,to,produce,an,initial,vertex,value,param,context,the,execution,environment,return,an,instance,of,link,org,apache,flink,graph,graph,csv,reader,on,which,calling,methods,to,specify,types,of,the,vertex,id,vertex,value,and,edge,value,returns,a,graph,see,org,apache,flink,graph,graph,csv,reader,types,class,class,class,see,org,apache,flink,graph,graph,csv,reader,vertex,types,class,class,see,org,apache,flink,graph,graph,csv,reader,edge,types,class,class,see,org,apache,flink,graph,graph,csv,reader,key,type,class;public,static,k,vv,graph,csv,reader,from,csv,reader,string,edges,path,final,map,function,k,vv,vertex,value,initializer,execution,environment,context,return,new,graph,csv,reader,edges,path,vertex,value,initializer,context
Graph -> public static <K, VV> GraphCsvReader fromCsvReader(String edgesPath, 			final MapFunction<K, VV> vertexValueInitializer, ExecutionEnvironment context);1462100316;Creates a graph from a CSV file of edges. Vertices will be created automatically and_Vertex values can be initialized using a user-defined mapper.__@param edgesPath a path to a CSV file with the Edge data_@param vertexValueInitializer the mapper function that initializes the vertex values._It allows to apply a map transformation on the vertex ID to produce an initial vertex value._@param context the execution environment._@return An instance of {@link org.apache.flink.graph.GraphCsvReader},_on which calling methods to specify types of the Vertex ID, Vertex Value and Edge value returns a Graph.__@see org.apache.flink.graph.GraphCsvReader#types(Class, Class, Class)_@see org.apache.flink.graph.GraphCsvReader#vertexTypes(Class, Class)_@see org.apache.flink.graph.GraphCsvReader#edgeTypes(Class, Class)_@see org.apache.flink.graph.GraphCsvReader#keyType(Class);public static <K, VV> GraphCsvReader fromCsvReader(String edgesPath,_			final MapFunction<K, VV> vertexValueInitializer, ExecutionEnvironment context) {_		return new GraphCsvReader(edgesPath, vertexValueInitializer, context)__	};creates,a,graph,from,a,csv,file,of,edges,vertices,will,be,created,automatically,and,vertex,values,can,be,initialized,using,a,user,defined,mapper,param,edges,path,a,path,to,a,csv,file,with,the,edge,data,param,vertex,value,initializer,the,mapper,function,that,initializes,the,vertex,values,it,allows,to,apply,a,map,transformation,on,the,vertex,id,to,produce,an,initial,vertex,value,param,context,the,execution,environment,return,an,instance,of,link,org,apache,flink,graph,graph,csv,reader,on,which,calling,methods,to,specify,types,of,the,vertex,id,vertex,value,and,edge,value,returns,a,graph,see,org,apache,flink,graph,graph,csv,reader,types,class,class,class,see,org,apache,flink,graph,graph,csv,reader,vertex,types,class,class,see,org,apache,flink,graph,graph,csv,reader,edge,types,class,class,see,org,apache,flink,graph,graph,csv,reader,key,type,class;public,static,k,vv,graph,csv,reader,from,csv,reader,string,edges,path,final,map,function,k,vv,vertex,value,initializer,execution,environment,context,return,new,graph,csv,reader,edges,path,vertex,value,initializer,context
Graph -> public static <K, VV> GraphCsvReader fromCsvReader(String edgesPath, 			final MapFunction<K, VV> vertexValueInitializer, ExecutionEnvironment context);1462205213;Creates a graph from a CSV file of edges. Vertices will be created automatically and_Vertex values can be initialized using a user-defined mapper.__@param edgesPath a path to a CSV file with the Edge data_@param vertexValueInitializer the mapper function that initializes the vertex values._It allows to apply a map transformation on the vertex ID to produce an initial vertex value._@param context the execution environment._@return An instance of {@link org.apache.flink.graph.GraphCsvReader},_on which calling methods to specify types of the Vertex ID, Vertex Value and Edge value returns a Graph.__@see org.apache.flink.graph.GraphCsvReader#types(Class, Class, Class)_@see org.apache.flink.graph.GraphCsvReader#vertexTypes(Class, Class)_@see org.apache.flink.graph.GraphCsvReader#edgeTypes(Class, Class)_@see org.apache.flink.graph.GraphCsvReader#keyType(Class);public static <K, VV> GraphCsvReader fromCsvReader(String edgesPath,_			final MapFunction<K, VV> vertexValueInitializer, ExecutionEnvironment context) {_		return new GraphCsvReader(edgesPath, vertexValueInitializer, context)__	};creates,a,graph,from,a,csv,file,of,edges,vertices,will,be,created,automatically,and,vertex,values,can,be,initialized,using,a,user,defined,mapper,param,edges,path,a,path,to,a,csv,file,with,the,edge,data,param,vertex,value,initializer,the,mapper,function,that,initializes,the,vertex,values,it,allows,to,apply,a,map,transformation,on,the,vertex,id,to,produce,an,initial,vertex,value,param,context,the,execution,environment,return,an,instance,of,link,org,apache,flink,graph,graph,csv,reader,on,which,calling,methods,to,specify,types,of,the,vertex,id,vertex,value,and,edge,value,returns,a,graph,see,org,apache,flink,graph,graph,csv,reader,types,class,class,class,see,org,apache,flink,graph,graph,csv,reader,vertex,types,class,class,see,org,apache,flink,graph,graph,csv,reader,edge,types,class,class,see,org,apache,flink,graph,graph,csv,reader,key,type,class;public,static,k,vv,graph,csv,reader,from,csv,reader,string,edges,path,final,map,function,k,vv,vertex,value,initializer,execution,environment,context,return,new,graph,csv,reader,edges,path,vertex,value,initializer,context
Graph -> public static <K, VV> GraphCsvReader fromCsvReader(String edgesPath, 			final MapFunction<K, VV> vertexValueInitializer, ExecutionEnvironment context);1462208859;Creates a graph from a CSV file of edges. Vertices will be created automatically and_Vertex values can be initialized using a user-defined mapper.__@param edgesPath a path to a CSV file with the Edge data_@param vertexValueInitializer the mapper function that initializes the vertex values._It allows to apply a map transformation on the vertex ID to produce an initial vertex value._@param context the execution environment._@return An instance of {@link org.apache.flink.graph.GraphCsvReader},_on which calling methods to specify types of the Vertex ID, Vertex Value and Edge value returns a Graph.__@see org.apache.flink.graph.GraphCsvReader#types(Class, Class, Class)_@see org.apache.flink.graph.GraphCsvReader#vertexTypes(Class, Class)_@see org.apache.flink.graph.GraphCsvReader#edgeTypes(Class, Class)_@see org.apache.flink.graph.GraphCsvReader#keyType(Class);public static <K, VV> GraphCsvReader fromCsvReader(String edgesPath,_			final MapFunction<K, VV> vertexValueInitializer, ExecutionEnvironment context) {_		return new GraphCsvReader(edgesPath, vertexValueInitializer, context)__	};creates,a,graph,from,a,csv,file,of,edges,vertices,will,be,created,automatically,and,vertex,values,can,be,initialized,using,a,user,defined,mapper,param,edges,path,a,path,to,a,csv,file,with,the,edge,data,param,vertex,value,initializer,the,mapper,function,that,initializes,the,vertex,values,it,allows,to,apply,a,map,transformation,on,the,vertex,id,to,produce,an,initial,vertex,value,param,context,the,execution,environment,return,an,instance,of,link,org,apache,flink,graph,graph,csv,reader,on,which,calling,methods,to,specify,types,of,the,vertex,id,vertex,value,and,edge,value,returns,a,graph,see,org,apache,flink,graph,graph,csv,reader,types,class,class,class,see,org,apache,flink,graph,graph,csv,reader,vertex,types,class,class,see,org,apache,flink,graph,graph,csv,reader,edge,types,class,class,see,org,apache,flink,graph,graph,csv,reader,key,type,class;public,static,k,vv,graph,csv,reader,from,csv,reader,string,edges,path,final,map,function,k,vv,vertex,value,initializer,execution,environment,context,return,new,graph,csv,reader,edges,path,vertex,value,initializer,context
Graph -> public static <K, VV> GraphCsvReader fromCsvReader(String edgesPath, 			final MapFunction<K, VV> vertexValueInitializer, ExecutionEnvironment context);1462809297;Creates a graph from a CSV file of edges. Vertices will be created automatically and_Vertex values can be initialized using a user-defined mapper.__@param edgesPath a path to a CSV file with the Edge data_@param vertexValueInitializer the mapper function that initializes the vertex values._It allows to apply a map transformation on the vertex ID to produce an initial vertex value._@param context the execution environment._@return An instance of {@link org.apache.flink.graph.GraphCsvReader},_on which calling methods to specify types of the Vertex ID, Vertex Value and Edge value returns a Graph.__@see org.apache.flink.graph.GraphCsvReader#types(Class, Class, Class)_@see org.apache.flink.graph.GraphCsvReader#vertexTypes(Class, Class)_@see org.apache.flink.graph.GraphCsvReader#edgeTypes(Class, Class)_@see org.apache.flink.graph.GraphCsvReader#keyType(Class);public static <K, VV> GraphCsvReader fromCsvReader(String edgesPath,_			final MapFunction<K, VV> vertexValueInitializer, ExecutionEnvironment context) {_		return new GraphCsvReader(edgesPath, vertexValueInitializer, context)__	};creates,a,graph,from,a,csv,file,of,edges,vertices,will,be,created,automatically,and,vertex,values,can,be,initialized,using,a,user,defined,mapper,param,edges,path,a,path,to,a,csv,file,with,the,edge,data,param,vertex,value,initializer,the,mapper,function,that,initializes,the,vertex,values,it,allows,to,apply,a,map,transformation,on,the,vertex,id,to,produce,an,initial,vertex,value,param,context,the,execution,environment,return,an,instance,of,link,org,apache,flink,graph,graph,csv,reader,on,which,calling,methods,to,specify,types,of,the,vertex,id,vertex,value,and,edge,value,returns,a,graph,see,org,apache,flink,graph,graph,csv,reader,types,class,class,class,see,org,apache,flink,graph,graph,csv,reader,vertex,types,class,class,see,org,apache,flink,graph,graph,csv,reader,edge,types,class,class,see,org,apache,flink,graph,graph,csv,reader,key,type,class;public,static,k,vv,graph,csv,reader,from,csv,reader,string,edges,path,final,map,function,k,vv,vertex,value,initializer,execution,environment,context,return,new,graph,csv,reader,edges,path,vertex,value,initializer,context
Graph -> public static <K, VV> GraphCsvReader fromCsvReader(String edgesPath, 			final MapFunction<K, VV> vertexValueInitializer, ExecutionEnvironment context);1465316775;Creates a graph from a CSV file of edges. Vertices will be created automatically and_Vertex values can be initialized using a user-defined mapper.__@param edgesPath a path to a CSV file with the Edge data_@param vertexValueInitializer the mapper function that initializes the vertex values._It allows to apply a map transformation on the vertex ID to produce an initial vertex value._@param context the execution environment._@return An instance of {@link org.apache.flink.graph.GraphCsvReader},_on which calling methods to specify types of the Vertex ID, Vertex Value and Edge value returns a Graph.__@see org.apache.flink.graph.GraphCsvReader#types(Class, Class, Class)_@see org.apache.flink.graph.GraphCsvReader#vertexTypes(Class, Class)_@see org.apache.flink.graph.GraphCsvReader#edgeTypes(Class, Class)_@see org.apache.flink.graph.GraphCsvReader#keyType(Class);public static <K, VV> GraphCsvReader fromCsvReader(String edgesPath,_			final MapFunction<K, VV> vertexValueInitializer, ExecutionEnvironment context) {_		return new GraphCsvReader(edgesPath, vertexValueInitializer, context)__	};creates,a,graph,from,a,csv,file,of,edges,vertices,will,be,created,automatically,and,vertex,values,can,be,initialized,using,a,user,defined,mapper,param,edges,path,a,path,to,a,csv,file,with,the,edge,data,param,vertex,value,initializer,the,mapper,function,that,initializes,the,vertex,values,it,allows,to,apply,a,map,transformation,on,the,vertex,id,to,produce,an,initial,vertex,value,param,context,the,execution,environment,return,an,instance,of,link,org,apache,flink,graph,graph,csv,reader,on,which,calling,methods,to,specify,types,of,the,vertex,id,vertex,value,and,edge,value,returns,a,graph,see,org,apache,flink,graph,graph,csv,reader,types,class,class,class,see,org,apache,flink,graph,graph,csv,reader,vertex,types,class,class,see,org,apache,flink,graph,graph,csv,reader,edge,types,class,class,see,org,apache,flink,graph,graph,csv,reader,key,type,class;public,static,k,vv,graph,csv,reader,from,csv,reader,string,edges,path,final,map,function,k,vv,vertex,value,initializer,execution,environment,context,return,new,graph,csv,reader,edges,path,vertex,value,initializer,context
Graph -> public static <K, VV> GraphCsvReader fromCsvReader(String edgesPath, 			final MapFunction<K, VV> vertexValueInitializer, ExecutionEnvironment context);1466789678;Creates a graph from a CSV file of edges. Vertices will be created automatically and_Vertex values can be initialized using a user-defined mapper.__@param edgesPath a path to a CSV file with the Edge data_@param vertexValueInitializer the mapper function that initializes the vertex values._It allows to apply a map transformation on the vertex ID to produce an initial vertex value._@param context the execution environment._@return An instance of {@link org.apache.flink.graph.GraphCsvReader},_on which calling methods to specify types of the Vertex ID, Vertex Value and Edge value returns a Graph.__@see org.apache.flink.graph.GraphCsvReader#types(Class, Class, Class)_@see org.apache.flink.graph.GraphCsvReader#vertexTypes(Class, Class)_@see org.apache.flink.graph.GraphCsvReader#edgeTypes(Class, Class)_@see org.apache.flink.graph.GraphCsvReader#keyType(Class);public static <K, VV> GraphCsvReader fromCsvReader(String edgesPath,_			final MapFunction<K, VV> vertexValueInitializer, ExecutionEnvironment context) {_		return new GraphCsvReader(edgesPath, vertexValueInitializer, context)__	};creates,a,graph,from,a,csv,file,of,edges,vertices,will,be,created,automatically,and,vertex,values,can,be,initialized,using,a,user,defined,mapper,param,edges,path,a,path,to,a,csv,file,with,the,edge,data,param,vertex,value,initializer,the,mapper,function,that,initializes,the,vertex,values,it,allows,to,apply,a,map,transformation,on,the,vertex,id,to,produce,an,initial,vertex,value,param,context,the,execution,environment,return,an,instance,of,link,org,apache,flink,graph,graph,csv,reader,on,which,calling,methods,to,specify,types,of,the,vertex,id,vertex,value,and,edge,value,returns,a,graph,see,org,apache,flink,graph,graph,csv,reader,types,class,class,class,see,org,apache,flink,graph,graph,csv,reader,vertex,types,class,class,see,org,apache,flink,graph,graph,csv,reader,edge,types,class,class,see,org,apache,flink,graph,graph,csv,reader,key,type,class;public,static,k,vv,graph,csv,reader,from,csv,reader,string,edges,path,final,map,function,k,vv,vertex,value,initializer,execution,environment,context,return,new,graph,csv,reader,edges,path,vertex,value,initializer,context
Graph -> public static <K, VV> GraphCsvReader fromCsvReader(String edgesPath, 			final MapFunction<K, VV> vertexValueInitializer, ExecutionEnvironment context);1467140656;Creates a graph from a CSV file of edges. Vertices will be created automatically and_Vertex values can be initialized using a user-defined mapper.__@param edgesPath a path to a CSV file with the Edge data_@param vertexValueInitializer the mapper function that initializes the vertex values._It allows to apply a map transformation on the vertex ID to produce an initial vertex value._@param context the execution environment._@return An instance of {@link org.apache.flink.graph.GraphCsvReader},_on which calling methods to specify types of the Vertex ID, Vertex Value and Edge value returns a Graph.__@see org.apache.flink.graph.GraphCsvReader#types(Class, Class, Class)_@see org.apache.flink.graph.GraphCsvReader#vertexTypes(Class, Class)_@see org.apache.flink.graph.GraphCsvReader#edgeTypes(Class, Class)_@see org.apache.flink.graph.GraphCsvReader#keyType(Class);public static <K, VV> GraphCsvReader fromCsvReader(String edgesPath,_			final MapFunction<K, VV> vertexValueInitializer, ExecutionEnvironment context) {_		return new GraphCsvReader(edgesPath, vertexValueInitializer, context)__	};creates,a,graph,from,a,csv,file,of,edges,vertices,will,be,created,automatically,and,vertex,values,can,be,initialized,using,a,user,defined,mapper,param,edges,path,a,path,to,a,csv,file,with,the,edge,data,param,vertex,value,initializer,the,mapper,function,that,initializes,the,vertex,values,it,allows,to,apply,a,map,transformation,on,the,vertex,id,to,produce,an,initial,vertex,value,param,context,the,execution,environment,return,an,instance,of,link,org,apache,flink,graph,graph,csv,reader,on,which,calling,methods,to,specify,types,of,the,vertex,id,vertex,value,and,edge,value,returns,a,graph,see,org,apache,flink,graph,graph,csv,reader,types,class,class,class,see,org,apache,flink,graph,graph,csv,reader,vertex,types,class,class,see,org,apache,flink,graph,graph,csv,reader,edge,types,class,class,see,org,apache,flink,graph,graph,csv,reader,key,type,class;public,static,k,vv,graph,csv,reader,from,csv,reader,string,edges,path,final,map,function,k,vv,vertex,value,initializer,execution,environment,context,return,new,graph,csv,reader,edges,path,vertex,value,initializer,context
Graph -> public static <K, VV> GraphCsvReader fromCsvReader(String edgesPath, 			final MapFunction<K, VV> vertexValueInitializer, ExecutionEnvironment context);1467306272;Creates a graph from a CSV file of edges. Vertices will be created automatically and_Vertex values can be initialized using a user-defined mapper.__@param edgesPath a path to a CSV file with the Edge data_@param vertexValueInitializer the mapper function that initializes the vertex values._It allows to apply a map transformation on the vertex ID to produce an initial vertex value._@param context the execution environment._@return An instance of {@link org.apache.flink.graph.GraphCsvReader},_on which calling methods to specify types of the Vertex ID, Vertex Value and Edge value returns a Graph.__@see org.apache.flink.graph.GraphCsvReader#types(Class, Class, Class)_@see org.apache.flink.graph.GraphCsvReader#vertexTypes(Class, Class)_@see org.apache.flink.graph.GraphCsvReader#edgeTypes(Class, Class)_@see org.apache.flink.graph.GraphCsvReader#keyType(Class);public static <K, VV> GraphCsvReader fromCsvReader(String edgesPath,_			final MapFunction<K, VV> vertexValueInitializer, ExecutionEnvironment context) {_		return new GraphCsvReader(edgesPath, vertexValueInitializer, context)__	};creates,a,graph,from,a,csv,file,of,edges,vertices,will,be,created,automatically,and,vertex,values,can,be,initialized,using,a,user,defined,mapper,param,edges,path,a,path,to,a,csv,file,with,the,edge,data,param,vertex,value,initializer,the,mapper,function,that,initializes,the,vertex,values,it,allows,to,apply,a,map,transformation,on,the,vertex,id,to,produce,an,initial,vertex,value,param,context,the,execution,environment,return,an,instance,of,link,org,apache,flink,graph,graph,csv,reader,on,which,calling,methods,to,specify,types,of,the,vertex,id,vertex,value,and,edge,value,returns,a,graph,see,org,apache,flink,graph,graph,csv,reader,types,class,class,class,see,org,apache,flink,graph,graph,csv,reader,vertex,types,class,class,see,org,apache,flink,graph,graph,csv,reader,edge,types,class,class,see,org,apache,flink,graph,graph,csv,reader,key,type,class;public,static,k,vv,graph,csv,reader,from,csv,reader,string,edges,path,final,map,function,k,vv,vertex,value,initializer,execution,environment,context,return,new,graph,csv,reader,edges,path,vertex,value,initializer,context
Graph -> public static <K, VV> GraphCsvReader fromCsvReader(String edgesPath, 			final MapFunction<K, VV> vertexValueInitializer, ExecutionEnvironment context);1470042815;Creates a graph from a CSV file of edges. Vertices will be created automatically and_Vertex values can be initialized using a user-defined mapper.__@param edgesPath a path to a CSV file with the Edge data_@param vertexValueInitializer the mapper function that initializes the vertex values._It allows to apply a map transformation on the vertex ID to produce an initial vertex value._@param context the execution environment._@return An instance of {@link org.apache.flink.graph.GraphCsvReader},_on which calling methods to specify types of the Vertex ID, Vertex Value and Edge value returns a Graph.__@see org.apache.flink.graph.GraphCsvReader#types(Class, Class, Class)_@see org.apache.flink.graph.GraphCsvReader#vertexTypes(Class, Class)_@see org.apache.flink.graph.GraphCsvReader#edgeTypes(Class, Class)_@see org.apache.flink.graph.GraphCsvReader#keyType(Class);public static <K, VV> GraphCsvReader fromCsvReader(String edgesPath,_			final MapFunction<K, VV> vertexValueInitializer, ExecutionEnvironment context) {_		return new GraphCsvReader(edgesPath, vertexValueInitializer, context)__	};creates,a,graph,from,a,csv,file,of,edges,vertices,will,be,created,automatically,and,vertex,values,can,be,initialized,using,a,user,defined,mapper,param,edges,path,a,path,to,a,csv,file,with,the,edge,data,param,vertex,value,initializer,the,mapper,function,that,initializes,the,vertex,values,it,allows,to,apply,a,map,transformation,on,the,vertex,id,to,produce,an,initial,vertex,value,param,context,the,execution,environment,return,an,instance,of,link,org,apache,flink,graph,graph,csv,reader,on,which,calling,methods,to,specify,types,of,the,vertex,id,vertex,value,and,edge,value,returns,a,graph,see,org,apache,flink,graph,graph,csv,reader,types,class,class,class,see,org,apache,flink,graph,graph,csv,reader,vertex,types,class,class,see,org,apache,flink,graph,graph,csv,reader,edge,types,class,class,see,org,apache,flink,graph,graph,csv,reader,key,type,class;public,static,k,vv,graph,csv,reader,from,csv,reader,string,edges,path,final,map,function,k,vv,vertex,value,initializer,execution,environment,context,return,new,graph,csv,reader,edges,path,vertex,value,initializer,context
Graph -> public static <K, VV> GraphCsvReader fromCsvReader(String edgesPath, 			final MapFunction<K, VV> vertexValueInitializer, ExecutionEnvironment context);1475684776;Creates a graph from a CSV file of edges. Vertices will be created automatically and_Vertex values can be initialized using a user-defined mapper.__@param edgesPath a path to a CSV file with the Edge data_@param vertexValueInitializer the mapper function that initializes the vertex values._It allows to apply a map transformation on the vertex ID to produce an initial vertex value._@param context the execution environment._@return An instance of {@link org.apache.flink.graph.GraphCsvReader},_on which calling methods to specify types of the Vertex ID, Vertex Value and Edge value returns a Graph.__@see org.apache.flink.graph.GraphCsvReader#types(Class, Class, Class)_@see org.apache.flink.graph.GraphCsvReader#vertexTypes(Class, Class)_@see org.apache.flink.graph.GraphCsvReader#edgeTypes(Class, Class)_@see org.apache.flink.graph.GraphCsvReader#keyType(Class);public static <K, VV> GraphCsvReader fromCsvReader(String edgesPath,_			final MapFunction<K, VV> vertexValueInitializer, ExecutionEnvironment context) {_		return new GraphCsvReader(edgesPath, vertexValueInitializer, context)__	};creates,a,graph,from,a,csv,file,of,edges,vertices,will,be,created,automatically,and,vertex,values,can,be,initialized,using,a,user,defined,mapper,param,edges,path,a,path,to,a,csv,file,with,the,edge,data,param,vertex,value,initializer,the,mapper,function,that,initializes,the,vertex,values,it,allows,to,apply,a,map,transformation,on,the,vertex,id,to,produce,an,initial,vertex,value,param,context,the,execution,environment,return,an,instance,of,link,org,apache,flink,graph,graph,csv,reader,on,which,calling,methods,to,specify,types,of,the,vertex,id,vertex,value,and,edge,value,returns,a,graph,see,org,apache,flink,graph,graph,csv,reader,types,class,class,class,see,org,apache,flink,graph,graph,csv,reader,vertex,types,class,class,see,org,apache,flink,graph,graph,csv,reader,edge,types,class,class,see,org,apache,flink,graph,graph,csv,reader,key,type,class;public,static,k,vv,graph,csv,reader,from,csv,reader,string,edges,path,final,map,function,k,vv,vertex,value,initializer,execution,environment,context,return,new,graph,csv,reader,edges,path,vertex,value,initializer,context
Graph -> public static <K, VV> GraphCsvReader fromCsvReader(String edgesPath, 			final MapFunction<K, VV> vertexValueInitializer, ExecutionEnvironment context);1475685606;Creates a graph from a CSV file of edges. Vertices will be created automatically and_Vertex values can be initialized using a user-defined mapper.__@param edgesPath a path to a CSV file with the Edge data_@param vertexValueInitializer the mapper function that initializes the vertex values._It allows to apply a map transformation on the vertex ID to produce an initial vertex value._@param context the execution environment._@return An instance of {@link org.apache.flink.graph.GraphCsvReader},_on which calling methods to specify types of the Vertex ID, Vertex Value and Edge value returns a Graph.__@see org.apache.flink.graph.GraphCsvReader#types(Class, Class, Class)_@see org.apache.flink.graph.GraphCsvReader#vertexTypes(Class, Class)_@see org.apache.flink.graph.GraphCsvReader#edgeTypes(Class, Class)_@see org.apache.flink.graph.GraphCsvReader#keyType(Class);public static <K, VV> GraphCsvReader fromCsvReader(String edgesPath,_			final MapFunction<K, VV> vertexValueInitializer, ExecutionEnvironment context) {_		return new GraphCsvReader(edgesPath, vertexValueInitializer, context)__	};creates,a,graph,from,a,csv,file,of,edges,vertices,will,be,created,automatically,and,vertex,values,can,be,initialized,using,a,user,defined,mapper,param,edges,path,a,path,to,a,csv,file,with,the,edge,data,param,vertex,value,initializer,the,mapper,function,that,initializes,the,vertex,values,it,allows,to,apply,a,map,transformation,on,the,vertex,id,to,produce,an,initial,vertex,value,param,context,the,execution,environment,return,an,instance,of,link,org,apache,flink,graph,graph,csv,reader,on,which,calling,methods,to,specify,types,of,the,vertex,id,vertex,value,and,edge,value,returns,a,graph,see,org,apache,flink,graph,graph,csv,reader,types,class,class,class,see,org,apache,flink,graph,graph,csv,reader,vertex,types,class,class,see,org,apache,flink,graph,graph,csv,reader,edge,types,class,class,see,org,apache,flink,graph,graph,csv,reader,key,type,class;public,static,k,vv,graph,csv,reader,from,csv,reader,string,edges,path,final,map,function,k,vv,vertex,value,initializer,execution,environment,context,return,new,graph,csv,reader,edges,path,vertex,value,initializer,context
Graph -> public static <K, VV> GraphCsvReader fromCsvReader(String edgesPath, 			final MapFunction<K, VV> vertexValueInitializer, ExecutionEnvironment context);1481745825;Creates a graph from a CSV file of edges. Vertices will be created automatically and_Vertex values can be initialized using a user-defined mapper.__@param edgesPath a path to a CSV file with the Edge data_@param vertexValueInitializer the mapper function that initializes the vertex values._It allows to apply a map transformation on the vertex ID to produce an initial vertex value._@param context the execution environment._@return An instance of {@link org.apache.flink.graph.GraphCsvReader},_on which calling methods to specify types of the Vertex ID, Vertex Value and Edge value returns a Graph.__@see org.apache.flink.graph.GraphCsvReader#types(Class, Class, Class)_@see org.apache.flink.graph.GraphCsvReader#vertexTypes(Class, Class)_@see org.apache.flink.graph.GraphCsvReader#edgeTypes(Class, Class)_@see org.apache.flink.graph.GraphCsvReader#keyType(Class);public static <K, VV> GraphCsvReader fromCsvReader(String edgesPath,_			final MapFunction<K, VV> vertexValueInitializer, ExecutionEnvironment context) {_		return new GraphCsvReader(edgesPath, vertexValueInitializer, context)__	};creates,a,graph,from,a,csv,file,of,edges,vertices,will,be,created,automatically,and,vertex,values,can,be,initialized,using,a,user,defined,mapper,param,edges,path,a,path,to,a,csv,file,with,the,edge,data,param,vertex,value,initializer,the,mapper,function,that,initializes,the,vertex,values,it,allows,to,apply,a,map,transformation,on,the,vertex,id,to,produce,an,initial,vertex,value,param,context,the,execution,environment,return,an,instance,of,link,org,apache,flink,graph,graph,csv,reader,on,which,calling,methods,to,specify,types,of,the,vertex,id,vertex,value,and,edge,value,returns,a,graph,see,org,apache,flink,graph,graph,csv,reader,types,class,class,class,see,org,apache,flink,graph,graph,csv,reader,vertex,types,class,class,see,org,apache,flink,graph,graph,csv,reader,edge,types,class,class,see,org,apache,flink,graph,graph,csv,reader,key,type,class;public,static,k,vv,graph,csv,reader,from,csv,reader,string,edges,path,final,map,function,k,vv,vertex,value,initializer,execution,environment,context,return,new,graph,csv,reader,edges,path,vertex,value,initializer,context
Graph -> public static <K, VV> GraphCsvReader fromCsvReader(String edgesPath, 			final MapFunction<K, VV> vertexValueInitializer, ExecutionEnvironment context);1481881009;Creates a graph from a CSV file of edges. Vertices will be created automatically and_Vertex values can be initialized using a user-defined mapper.__@param edgesPath a path to a CSV file with the Edge data_@param vertexValueInitializer the mapper function that initializes the vertex values._It allows to apply a map transformation on the vertex ID to produce an initial vertex value._@param context the execution environment._@return An instance of {@link org.apache.flink.graph.GraphCsvReader},_on which calling methods to specify types of the Vertex ID, Vertex Value and Edge value returns a Graph.__@see org.apache.flink.graph.GraphCsvReader#types(Class, Class, Class)_@see org.apache.flink.graph.GraphCsvReader#vertexTypes(Class, Class)_@see org.apache.flink.graph.GraphCsvReader#edgeTypes(Class, Class)_@see org.apache.flink.graph.GraphCsvReader#keyType(Class);public static <K, VV> GraphCsvReader fromCsvReader(String edgesPath,_			final MapFunction<K, VV> vertexValueInitializer, ExecutionEnvironment context) {_		return new GraphCsvReader(edgesPath, vertexValueInitializer, context)__	};creates,a,graph,from,a,csv,file,of,edges,vertices,will,be,created,automatically,and,vertex,values,can,be,initialized,using,a,user,defined,mapper,param,edges,path,a,path,to,a,csv,file,with,the,edge,data,param,vertex,value,initializer,the,mapper,function,that,initializes,the,vertex,values,it,allows,to,apply,a,map,transformation,on,the,vertex,id,to,produce,an,initial,vertex,value,param,context,the,execution,environment,return,an,instance,of,link,org,apache,flink,graph,graph,csv,reader,on,which,calling,methods,to,specify,types,of,the,vertex,id,vertex,value,and,edge,value,returns,a,graph,see,org,apache,flink,graph,graph,csv,reader,types,class,class,class,see,org,apache,flink,graph,graph,csv,reader,vertex,types,class,class,see,org,apache,flink,graph,graph,csv,reader,edge,types,class,class,see,org,apache,flink,graph,graph,csv,reader,key,type,class;public,static,k,vv,graph,csv,reader,from,csv,reader,string,edges,path,final,map,function,k,vv,vertex,value,initializer,execution,environment,context,return,new,graph,csv,reader,edges,path,vertex,value,initializer,context
Graph -> public static <K, VV> GraphCsvReader fromCsvReader(String edgesPath, 			final MapFunction<K, VV> vertexValueInitializer, ExecutionEnvironment context);1484160227;Creates a graph from a CSV file of edges. Vertices will be created automatically and_Vertex values can be initialized using a user-defined mapper.__@param edgesPath a path to a CSV file with the Edge data_@param vertexValueInitializer the mapper function that initializes the vertex values._It allows to apply a map transformation on the vertex ID to produce an initial vertex value._@param context the execution environment._@return An instance of {@link org.apache.flink.graph.GraphCsvReader},_on which calling methods to specify types of the Vertex ID, Vertex Value and Edge value returns a Graph.__@see org.apache.flink.graph.GraphCsvReader#types(Class, Class, Class)_@see org.apache.flink.graph.GraphCsvReader#vertexTypes(Class, Class)_@see org.apache.flink.graph.GraphCsvReader#edgeTypes(Class, Class)_@see org.apache.flink.graph.GraphCsvReader#keyType(Class);public static <K, VV> GraphCsvReader fromCsvReader(String edgesPath,_			final MapFunction<K, VV> vertexValueInitializer, ExecutionEnvironment context) {_		return new GraphCsvReader(edgesPath, vertexValueInitializer, context)__	};creates,a,graph,from,a,csv,file,of,edges,vertices,will,be,created,automatically,and,vertex,values,can,be,initialized,using,a,user,defined,mapper,param,edges,path,a,path,to,a,csv,file,with,the,edge,data,param,vertex,value,initializer,the,mapper,function,that,initializes,the,vertex,values,it,allows,to,apply,a,map,transformation,on,the,vertex,id,to,produce,an,initial,vertex,value,param,context,the,execution,environment,return,an,instance,of,link,org,apache,flink,graph,graph,csv,reader,on,which,calling,methods,to,specify,types,of,the,vertex,id,vertex,value,and,edge,value,returns,a,graph,see,org,apache,flink,graph,graph,csv,reader,types,class,class,class,see,org,apache,flink,graph,graph,csv,reader,vertex,types,class,class,see,org,apache,flink,graph,graph,csv,reader,edge,types,class,class,see,org,apache,flink,graph,graph,csv,reader,key,type,class;public,static,k,vv,graph,csv,reader,from,csv,reader,string,edges,path,final,map,function,k,vv,vertex,value,initializer,execution,environment,context,return,new,graph,csv,reader,edges,path,vertex,value,initializer,context
Graph -> public static <K, VV> GraphCsvReader fromCsvReader(String edgesPath, 			final MapFunction<K, VV> vertexValueInitializer, ExecutionEnvironment context);1484685504;Creates a graph from a CSV file of edges. Vertices will be created automatically and_Vertex values can be initialized using a user-defined mapper.__@param edgesPath a path to a CSV file with the Edge data_@param vertexValueInitializer the mapper function that initializes the vertex values._It allows to apply a map transformation on the vertex ID to produce an initial vertex value._@param context the execution environment._@return An instance of {@link org.apache.flink.graph.GraphCsvReader},_on which calling methods to specify types of the Vertex ID, Vertex Value and Edge value returns a Graph.__@see org.apache.flink.graph.GraphCsvReader#types(Class, Class, Class)_@see org.apache.flink.graph.GraphCsvReader#vertexTypes(Class, Class)_@see org.apache.flink.graph.GraphCsvReader#edgeTypes(Class, Class)_@see org.apache.flink.graph.GraphCsvReader#keyType(Class);public static <K, VV> GraphCsvReader fromCsvReader(String edgesPath,_			final MapFunction<K, VV> vertexValueInitializer, ExecutionEnvironment context) {_		return new GraphCsvReader(edgesPath, vertexValueInitializer, context)__	};creates,a,graph,from,a,csv,file,of,edges,vertices,will,be,created,automatically,and,vertex,values,can,be,initialized,using,a,user,defined,mapper,param,edges,path,a,path,to,a,csv,file,with,the,edge,data,param,vertex,value,initializer,the,mapper,function,that,initializes,the,vertex,values,it,allows,to,apply,a,map,transformation,on,the,vertex,id,to,produce,an,initial,vertex,value,param,context,the,execution,environment,return,an,instance,of,link,org,apache,flink,graph,graph,csv,reader,on,which,calling,methods,to,specify,types,of,the,vertex,id,vertex,value,and,edge,value,returns,a,graph,see,org,apache,flink,graph,graph,csv,reader,types,class,class,class,see,org,apache,flink,graph,graph,csv,reader,vertex,types,class,class,see,org,apache,flink,graph,graph,csv,reader,edge,types,class,class,see,org,apache,flink,graph,graph,csv,reader,key,type,class;public,static,k,vv,graph,csv,reader,from,csv,reader,string,edges,path,final,map,function,k,vv,vertex,value,initializer,execution,environment,context,return,new,graph,csv,reader,edges,path,vertex,value,initializer,context
Graph -> public static <K, VV> GraphCsvReader fromCsvReader(String edgesPath, 			final MapFunction<K, VV> vertexValueInitializer, ExecutionEnvironment context);1489068942;Creates a graph from a CSV file of edges. Vertices will be created automatically and_Vertex values can be initialized using a user-defined mapper.__@param edgesPath a path to a CSV file with the Edge data_@param vertexValueInitializer the mapper function that initializes the vertex values._It allows to apply a map transformation on the vertex ID to produce an initial vertex value._@param context the execution environment._@return An instance of {@link org.apache.flink.graph.GraphCsvReader},_on which calling methods to specify types of the Vertex ID, Vertex Value and Edge value returns a Graph.__@see org.apache.flink.graph.GraphCsvReader#types(Class, Class, Class)_@see org.apache.flink.graph.GraphCsvReader#vertexTypes(Class, Class)_@see org.apache.flink.graph.GraphCsvReader#edgeTypes(Class, Class)_@see org.apache.flink.graph.GraphCsvReader#keyType(Class);public static <K, VV> GraphCsvReader fromCsvReader(String edgesPath,_			final MapFunction<K, VV> vertexValueInitializer, ExecutionEnvironment context) {_		return new GraphCsvReader(edgesPath, vertexValueInitializer, context)__	};creates,a,graph,from,a,csv,file,of,edges,vertices,will,be,created,automatically,and,vertex,values,can,be,initialized,using,a,user,defined,mapper,param,edges,path,a,path,to,a,csv,file,with,the,edge,data,param,vertex,value,initializer,the,mapper,function,that,initializes,the,vertex,values,it,allows,to,apply,a,map,transformation,on,the,vertex,id,to,produce,an,initial,vertex,value,param,context,the,execution,environment,return,an,instance,of,link,org,apache,flink,graph,graph,csv,reader,on,which,calling,methods,to,specify,types,of,the,vertex,id,vertex,value,and,edge,value,returns,a,graph,see,org,apache,flink,graph,graph,csv,reader,types,class,class,class,see,org,apache,flink,graph,graph,csv,reader,vertex,types,class,class,see,org,apache,flink,graph,graph,csv,reader,edge,types,class,class,see,org,apache,flink,graph,graph,csv,reader,key,type,class;public,static,k,vv,graph,csv,reader,from,csv,reader,string,edges,path,final,map,function,k,vv,vertex,value,initializer,execution,environment,context,return,new,graph,csv,reader,edges,path,vertex,value,initializer,context
Graph -> public static <K, VV> GraphCsvReader fromCsvReader(String edgesPath, 			final MapFunction<K, VV> vertexValueInitializer, ExecutionEnvironment context);1490973446;Creates a graph from a CSV file of edges. Vertices will be created automatically and_Vertex values can be initialized using a user-defined mapper.__@param edgesPath a path to a CSV file with the Edge data_@param vertexValueInitializer the mapper function that initializes the vertex values._It allows to apply a map transformation on the vertex ID to produce an initial vertex value._@param context the execution environment._@return An instance of {@link org.apache.flink.graph.GraphCsvReader},_on which calling methods to specify types of the Vertex ID, Vertex Value and Edge value returns a Graph.__@see org.apache.flink.graph.GraphCsvReader#types(Class, Class, Class)_@see org.apache.flink.graph.GraphCsvReader#vertexTypes(Class, Class)_@see org.apache.flink.graph.GraphCsvReader#edgeTypes(Class, Class)_@see org.apache.flink.graph.GraphCsvReader#keyType(Class);public static <K, VV> GraphCsvReader fromCsvReader(String edgesPath,_			final MapFunction<K, VV> vertexValueInitializer, ExecutionEnvironment context) {_		return new GraphCsvReader(edgesPath, vertexValueInitializer, context)__	};creates,a,graph,from,a,csv,file,of,edges,vertices,will,be,created,automatically,and,vertex,values,can,be,initialized,using,a,user,defined,mapper,param,edges,path,a,path,to,a,csv,file,with,the,edge,data,param,vertex,value,initializer,the,mapper,function,that,initializes,the,vertex,values,it,allows,to,apply,a,map,transformation,on,the,vertex,id,to,produce,an,initial,vertex,value,param,context,the,execution,environment,return,an,instance,of,link,org,apache,flink,graph,graph,csv,reader,on,which,calling,methods,to,specify,types,of,the,vertex,id,vertex,value,and,edge,value,returns,a,graph,see,org,apache,flink,graph,graph,csv,reader,types,class,class,class,see,org,apache,flink,graph,graph,csv,reader,vertex,types,class,class,see,org,apache,flink,graph,graph,csv,reader,edge,types,class,class,see,org,apache,flink,graph,graph,csv,reader,key,type,class;public,static,k,vv,graph,csv,reader,from,csv,reader,string,edges,path,final,map,function,k,vv,vertex,value,initializer,execution,environment,context,return,new,graph,csv,reader,edges,path,vertex,value,initializer,context
Graph -> public static <K, VV> GraphCsvReader fromCsvReader(String edgesPath, 			final MapFunction<K, VV> vertexValueInitializer, ExecutionEnvironment context);1495819075;Creates a graph from a CSV file of edges. Vertices will be created automatically and_Vertex values can be initialized using a user-defined mapper.__@param edgesPath a path to a CSV file with the Edge data_@param vertexValueInitializer the mapper function that initializes the vertex values._It allows to apply a map transformation on the vertex ID to produce an initial vertex value._@param context the execution environment._@return An instance of {@link org.apache.flink.graph.GraphCsvReader},_on which calling methods to specify types of the Vertex ID, Vertex Value and Edge value returns a Graph.__@see org.apache.flink.graph.GraphCsvReader#types(Class, Class, Class)_@see org.apache.flink.graph.GraphCsvReader#vertexTypes(Class, Class)_@see org.apache.flink.graph.GraphCsvReader#edgeTypes(Class, Class)_@see org.apache.flink.graph.GraphCsvReader#keyType(Class);public static <K, VV> GraphCsvReader fromCsvReader(String edgesPath,_			final MapFunction<K, VV> vertexValueInitializer, ExecutionEnvironment context) {_		return new GraphCsvReader(edgesPath, vertexValueInitializer, context)__	};creates,a,graph,from,a,csv,file,of,edges,vertices,will,be,created,automatically,and,vertex,values,can,be,initialized,using,a,user,defined,mapper,param,edges,path,a,path,to,a,csv,file,with,the,edge,data,param,vertex,value,initializer,the,mapper,function,that,initializes,the,vertex,values,it,allows,to,apply,a,map,transformation,on,the,vertex,id,to,produce,an,initial,vertex,value,param,context,the,execution,environment,return,an,instance,of,link,org,apache,flink,graph,graph,csv,reader,on,which,calling,methods,to,specify,types,of,the,vertex,id,vertex,value,and,edge,value,returns,a,graph,see,org,apache,flink,graph,graph,csv,reader,types,class,class,class,see,org,apache,flink,graph,graph,csv,reader,vertex,types,class,class,see,org,apache,flink,graph,graph,csv,reader,edge,types,class,class,see,org,apache,flink,graph,graph,csv,reader,key,type,class;public,static,k,vv,graph,csv,reader,from,csv,reader,string,edges,path,final,map,function,k,vv,vertex,value,initializer,execution,environment,context,return,new,graph,csv,reader,edges,path,vertex,value,initializer,context
Graph -> public static <K, VV> GraphCsvReader fromCsvReader(String edgesPath, 			final MapFunction<K, VV> vertexValueInitializer, ExecutionEnvironment context);1502111816;Creates a graph from a CSV file of edges. Vertices will be created automatically and_Vertex values can be initialized using a user-defined mapper.__@param edgesPath a path to a CSV file with the Edge data_@param vertexValueInitializer the mapper function that initializes the vertex values._It allows to apply a map transformation on the vertex ID to produce an initial vertex value._@param context the execution environment._@return An instance of {@link org.apache.flink.graph.GraphCsvReader},_on which calling methods to specify types of the Vertex ID, Vertex Value and Edge value returns a Graph.__@see org.apache.flink.graph.GraphCsvReader#types(Class, Class, Class)_@see org.apache.flink.graph.GraphCsvReader#vertexTypes(Class, Class)_@see org.apache.flink.graph.GraphCsvReader#edgeTypes(Class, Class)_@see org.apache.flink.graph.GraphCsvReader#keyType(Class);public static <K, VV> GraphCsvReader fromCsvReader(String edgesPath,_			final MapFunction<K, VV> vertexValueInitializer, ExecutionEnvironment context) {_		return new GraphCsvReader(edgesPath, vertexValueInitializer, context)__	};creates,a,graph,from,a,csv,file,of,edges,vertices,will,be,created,automatically,and,vertex,values,can,be,initialized,using,a,user,defined,mapper,param,edges,path,a,path,to,a,csv,file,with,the,edge,data,param,vertex,value,initializer,the,mapper,function,that,initializes,the,vertex,values,it,allows,to,apply,a,map,transformation,on,the,vertex,id,to,produce,an,initial,vertex,value,param,context,the,execution,environment,return,an,instance,of,link,org,apache,flink,graph,graph,csv,reader,on,which,calling,methods,to,specify,types,of,the,vertex,id,vertex,value,and,edge,value,returns,a,graph,see,org,apache,flink,graph,graph,csv,reader,types,class,class,class,see,org,apache,flink,graph,graph,csv,reader,vertex,types,class,class,see,org,apache,flink,graph,graph,csv,reader,edge,types,class,class,see,org,apache,flink,graph,graph,csv,reader,key,type,class;public,static,k,vv,graph,csv,reader,from,csv,reader,string,edges,path,final,map,function,k,vv,vertex,value,initializer,execution,environment,context,return,new,graph,csv,reader,edges,path,vertex,value,initializer,context
Graph -> public Graph<K, VV, EV> getUndirected();1444404795;This operation adds all inverse-direction edges to the graph.__@return the undirected graph.;public Graph<K, VV, EV> getUndirected() {__		DataSet<Edge<K, EV>> undirectedEdges = edges.flatMap(new RegularAndReversedEdgesMap<K, EV>())__		return new Graph<K, VV, EV>(vertices, undirectedEdges, this.context)__	};this,operation,adds,all,inverse,direction,edges,to,the,graph,return,the,undirected,graph;public,graph,k,vv,ev,get,undirected,data,set,edge,k,ev,undirected,edges,edges,flat,map,new,regular,and,reversed,edges,map,k,ev,return,new,graph,k,vv,ev,vertices,undirected,edges,this,context
Graph -> public Graph<K, VV, EV> getUndirected();1445261977;This operation adds all inverse-direction edges to the graph.__@return the undirected graph.;public Graph<K, VV, EV> getUndirected() {__		DataSet<Edge<K, EV>> undirectedEdges = edges.flatMap(new RegularAndReversedEdgesMap<K, EV>())__		return new Graph<K, VV, EV>(vertices, undirectedEdges, this.context)__	};this,operation,adds,all,inverse,direction,edges,to,the,graph,return,the,undirected,graph;public,graph,k,vv,ev,get,undirected,data,set,edge,k,ev,undirected,edges,edges,flat,map,new,regular,and,reversed,edges,map,k,ev,return,new,graph,k,vv,ev,vertices,undirected,edges,this,context
Graph -> public Graph<K, VV, EV> getUndirected();1445854323;This operation adds all inverse-direction edges to the graph.__@return the undirected graph.;public Graph<K, VV, EV> getUndirected() {__		DataSet<Edge<K, EV>> undirectedEdges = edges.flatMap(new RegularAndReversedEdgesMap<K, EV>())__		return new Graph<K, VV, EV>(vertices, undirectedEdges, this.context)__	};this,operation,adds,all,inverse,direction,edges,to,the,graph,return,the,undirected,graph;public,graph,k,vv,ev,get,undirected,data,set,edge,k,ev,undirected,edges,edges,flat,map,new,regular,and,reversed,edges,map,k,ev,return,new,graph,k,vv,ev,vertices,undirected,edges,this,context
Graph -> public Graph<K, VV, EV> getUndirected();1446112342;This operation adds all inverse-direction edges to the graph.__@return the undirected graph.;public Graph<K, VV, EV> getUndirected() {__		DataSet<Edge<K, EV>> undirectedEdges = edges.flatMap(new RegularAndReversedEdgesMap<K, EV>())__		return new Graph<K, VV, EV>(vertices, undirectedEdges, this.context)__	};this,operation,adds,all,inverse,direction,edges,to,the,graph,return,the,undirected,graph;public,graph,k,vv,ev,get,undirected,data,set,edge,k,ev,undirected,edges,edges,flat,map,new,regular,and,reversed,edges,map,k,ev,return,new,graph,k,vv,ev,vertices,undirected,edges,this,context
Graph -> public Graph<K, VV, EV> getUndirected();1447073368;This operation adds all inverse-direction edges to the graph.__@return the undirected graph.;public Graph<K, VV, EV> getUndirected() {__		DataSet<Edge<K, EV>> undirectedEdges = edges.flatMap(new RegularAndReversedEdgesMap<K, EV>())__		return new Graph<K, VV, EV>(vertices, undirectedEdges, this.context)__	};this,operation,adds,all,inverse,direction,edges,to,the,graph,return,the,undirected,graph;public,graph,k,vv,ev,get,undirected,data,set,edge,k,ev,undirected,edges,edges,flat,map,new,regular,and,reversed,edges,map,k,ev,return,new,graph,k,vv,ev,vertices,undirected,edges,this,context
Graph -> public Graph<K, VV, EV> getUndirected();1454404649;This operation adds all inverse-direction edges to the graph.__@return the undirected graph.;public Graph<K, VV, EV> getUndirected() {__		DataSet<Edge<K, EV>> undirectedEdges = edges.flatMap(new RegularAndReversedEdgesMap<K, EV>())__		return new Graph<K, VV, EV>(vertices, undirectedEdges, this.context)__	};this,operation,adds,all,inverse,direction,edges,to,the,graph,return,the,undirected,graph;public,graph,k,vv,ev,get,undirected,data,set,edge,k,ev,undirected,edges,edges,flat,map,new,regular,and,reversed,edges,map,k,ev,return,new,graph,k,vv,ev,vertices,undirected,edges,this,context
Graph -> public Graph<K, VV, EV> getUndirected();1458583829;This operation adds all inverse-direction edges to the graph.__@return the undirected graph.;public Graph<K, VV, EV> getUndirected() {__		DataSet<Edge<K, EV>> undirectedEdges = edges.flatMap(new RegularAndReversedEdgesMap<K, EV>())__		return new Graph<K, VV, EV>(vertices, undirectedEdges, this.context)__	};this,operation,adds,all,inverse,direction,edges,to,the,graph,return,the,undirected,graph;public,graph,k,vv,ev,get,undirected,data,set,edge,k,ev,undirected,edges,edges,flat,map,new,regular,and,reversed,edges,map,k,ev,return,new,graph,k,vv,ev,vertices,undirected,edges,this,context
Graph -> public Graph<K, VV, EV> getUndirected();1458583829;This operation adds all inverse-direction edges to the graph.__@return the undirected graph.;public Graph<K, VV, EV> getUndirected() {__		DataSet<Edge<K, EV>> undirectedEdges = edges.flatMap(new RegularAndReversedEdgesMap<K, EV>())__		return new Graph<K, VV, EV>(vertices, undirectedEdges, this.context)__	};this,operation,adds,all,inverse,direction,edges,to,the,graph,return,the,undirected,graph;public,graph,k,vv,ev,get,undirected,data,set,edge,k,ev,undirected,edges,edges,flat,map,new,regular,and,reversed,edges,map,k,ev,return,new,graph,k,vv,ev,vertices,undirected,edges,this,context
Graph -> public Graph<K, VV, EV> getUndirected();1462100316;This operation adds all inverse-direction edges to the graph.__@return the undirected graph.;public Graph<K, VV, EV> getUndirected() {__		DataSet<Edge<K, EV>> undirectedEdges = edges.flatMap(new RegularAndReversedEdgesMap<K, EV>())__		return new Graph<K, VV, EV>(vertices, undirectedEdges, this.context)__	};this,operation,adds,all,inverse,direction,edges,to,the,graph,return,the,undirected,graph;public,graph,k,vv,ev,get,undirected,data,set,edge,k,ev,undirected,edges,edges,flat,map,new,regular,and,reversed,edges,map,k,ev,return,new,graph,k,vv,ev,vertices,undirected,edges,this,context
Graph -> public Graph<K, VV, EV> getUndirected();1462100316;This operation adds all inverse-direction edges to the graph.__@return the undirected graph.;public Graph<K, VV, EV> getUndirected() {__		DataSet<Edge<K, EV>> undirectedEdges = edges.flatMap(new RegularAndReversedEdgesMap<K, EV>())__		return new Graph<K, VV, EV>(vertices, undirectedEdges, this.context)__	};this,operation,adds,all,inverse,direction,edges,to,the,graph,return,the,undirected,graph;public,graph,k,vv,ev,get,undirected,data,set,edge,k,ev,undirected,edges,edges,flat,map,new,regular,and,reversed,edges,map,k,ev,return,new,graph,k,vv,ev,vertices,undirected,edges,this,context
Graph -> public Graph<K, VV, EV> getUndirected();1462205213;This operation adds all inverse-direction edges to the graph.__@return the undirected graph.;public Graph<K, VV, EV> getUndirected() {__		DataSet<Edge<K, EV>> undirectedEdges = edges.flatMap(new RegularAndReversedEdgesMap<K, EV>())__		return new Graph<K, VV, EV>(vertices, undirectedEdges, this.context)__	};this,operation,adds,all,inverse,direction,edges,to,the,graph,return,the,undirected,graph;public,graph,k,vv,ev,get,undirected,data,set,edge,k,ev,undirected,edges,edges,flat,map,new,regular,and,reversed,edges,map,k,ev,return,new,graph,k,vv,ev,vertices,undirected,edges,this,context
Graph -> public Graph<K, VV, EV> getUndirected();1462208859;This operation adds all inverse-direction edges to the graph.__@return the undirected graph.;public Graph<K, VV, EV> getUndirected() {__		DataSet<Edge<K, EV>> undirectedEdges = edges.flatMap(new RegularAndReversedEdgesMap<K, EV>())__		return new Graph<K, VV, EV>(vertices, undirectedEdges, this.context)__	};this,operation,adds,all,inverse,direction,edges,to,the,graph,return,the,undirected,graph;public,graph,k,vv,ev,get,undirected,data,set,edge,k,ev,undirected,edges,edges,flat,map,new,regular,and,reversed,edges,map,k,ev,return,new,graph,k,vv,ev,vertices,undirected,edges,this,context
Graph -> public Graph<K, VV, EV> getUndirected();1462809297;This operation adds all inverse-direction edges to the graph.__@return the undirected graph.;public Graph<K, VV, EV> getUndirected() {__		DataSet<Edge<K, EV>> undirectedEdges = edges.flatMap(new RegularAndReversedEdgesMap<K, EV>())__		return new Graph<K, VV, EV>(vertices, undirectedEdges, this.context)__	};this,operation,adds,all,inverse,direction,edges,to,the,graph,return,the,undirected,graph;public,graph,k,vv,ev,get,undirected,data,set,edge,k,ev,undirected,edges,edges,flat,map,new,regular,and,reversed,edges,map,k,ev,return,new,graph,k,vv,ev,vertices,undirected,edges,this,context
Graph -> public Graph<K, VV, EV> getUndirected();1465316775;This operation adds all inverse-direction edges to the graph.__@return the undirected graph.;public Graph<K, VV, EV> getUndirected() {__		DataSet<Edge<K, EV>> undirectedEdges = edges.flatMap(new RegularAndReversedEdgesMap<K, EV>())__		return new Graph<K, VV, EV>(vertices, undirectedEdges, this.context)__	};this,operation,adds,all,inverse,direction,edges,to,the,graph,return,the,undirected,graph;public,graph,k,vv,ev,get,undirected,data,set,edge,k,ev,undirected,edges,edges,flat,map,new,regular,and,reversed,edges,map,k,ev,return,new,graph,k,vv,ev,vertices,undirected,edges,this,context
Graph -> public Graph<K, VV, EV> getUndirected();1466789678;This operation adds all inverse-direction edges to the graph.__@return the undirected graph.;public Graph<K, VV, EV> getUndirected() {__		DataSet<Edge<K, EV>> undirectedEdges = edges.flatMap(new RegularAndReversedEdgesMap<K, EV>())__		return new Graph<K, VV, EV>(vertices, undirectedEdges, this.context)__	};this,operation,adds,all,inverse,direction,edges,to,the,graph,return,the,undirected,graph;public,graph,k,vv,ev,get,undirected,data,set,edge,k,ev,undirected,edges,edges,flat,map,new,regular,and,reversed,edges,map,k,ev,return,new,graph,k,vv,ev,vertices,undirected,edges,this,context
Graph -> public Graph<K, VV, EV> getUndirected();1467140656;This operation adds all inverse-direction edges to the graph.__@return the undirected graph.;public Graph<K, VV, EV> getUndirected() {__		DataSet<Edge<K, EV>> undirectedEdges = edges.flatMap(new RegularAndReversedEdgesMap<K, EV>())__		return new Graph<K, VV, EV>(vertices, undirectedEdges, this.context)__	};this,operation,adds,all,inverse,direction,edges,to,the,graph,return,the,undirected,graph;public,graph,k,vv,ev,get,undirected,data,set,edge,k,ev,undirected,edges,edges,flat,map,new,regular,and,reversed,edges,map,k,ev,return,new,graph,k,vv,ev,vertices,undirected,edges,this,context
Graph -> public Graph<K, VV, EV> getUndirected();1467306272;This operation adds all inverse-direction edges to the graph.__@return the undirected graph.;public Graph<K, VV, EV> getUndirected() {__		DataSet<Edge<K, EV>> undirectedEdges = edges.flatMap(new RegularAndReversedEdgesMap<K, EV>())__		return new Graph<K, VV, EV>(vertices, undirectedEdges, this.context)__	};this,operation,adds,all,inverse,direction,edges,to,the,graph,return,the,undirected,graph;public,graph,k,vv,ev,get,undirected,data,set,edge,k,ev,undirected,edges,edges,flat,map,new,regular,and,reversed,edges,map,k,ev,return,new,graph,k,vv,ev,vertices,undirected,edges,this,context
Graph -> public Graph<K, VV, EV> getUndirected();1470042815;This operation adds all inverse-direction edges to the graph.__@return the undirected graph.;public Graph<K, VV, EV> getUndirected() {__		DataSet<Edge<K, EV>> undirectedEdges = edges.flatMap(new RegularAndReversedEdgesMap<K, EV>())__		return new Graph<K, VV, EV>(vertices, undirectedEdges, this.context)__	};this,operation,adds,all,inverse,direction,edges,to,the,graph,return,the,undirected,graph;public,graph,k,vv,ev,get,undirected,data,set,edge,k,ev,undirected,edges,edges,flat,map,new,regular,and,reversed,edges,map,k,ev,return,new,graph,k,vv,ev,vertices,undirected,edges,this,context
Graph -> public Graph<K, VV, EV> getUndirected();1475684776;This operation adds all inverse-direction edges to the graph.__@return the undirected graph.;public Graph<K, VV, EV> getUndirected() {__		DataSet<Edge<K, EV>> undirectedEdges = edges.flatMap(new RegularAndReversedEdgesMap<K, EV>())__		return new Graph<>(vertices, undirectedEdges, this.context)__	};this,operation,adds,all,inverse,direction,edges,to,the,graph,return,the,undirected,graph;public,graph,k,vv,ev,get,undirected,data,set,edge,k,ev,undirected,edges,edges,flat,map,new,regular,and,reversed,edges,map,k,ev,return,new,graph,vertices,undirected,edges,this,context
Graph -> public Graph<K, VV, EV> getUndirected();1475685606;This operation adds all inverse-direction edges to the graph.__@return the undirected graph.;public Graph<K, VV, EV> getUndirected() {__		DataSet<Edge<K, EV>> undirectedEdges = edges.flatMap(new RegularAndReversedEdgesMap<K, EV>())__		return new Graph<>(vertices, undirectedEdges, this.context)__	};this,operation,adds,all,inverse,direction,edges,to,the,graph,return,the,undirected,graph;public,graph,k,vv,ev,get,undirected,data,set,edge,k,ev,undirected,edges,edges,flat,map,new,regular,and,reversed,edges,map,k,ev,return,new,graph,vertices,undirected,edges,this,context
Graph -> public Graph<K, VV, EV> getUndirected();1481745825;This operation adds all inverse-direction edges to the graph.__@return the undirected graph.;public Graph<K, VV, EV> getUndirected() {__		DataSet<Edge<K, EV>> undirectedEdges = edges._			flatMap(new RegularAndReversedEdgesMap<K, EV>()).name("To undirected graph")__		return new Graph<>(vertices, undirectedEdges, this.context)__	};this,operation,adds,all,inverse,direction,edges,to,the,graph,return,the,undirected,graph;public,graph,k,vv,ev,get,undirected,data,set,edge,k,ev,undirected,edges,edges,flat,map,new,regular,and,reversed,edges,map,k,ev,name,to,undirected,graph,return,new,graph,vertices,undirected,edges,this,context
Graph -> public Graph<K, VV, EV> getUndirected();1481881009;This operation adds all inverse-direction edges to the graph.__@return the undirected graph.;public Graph<K, VV, EV> getUndirected() {__		DataSet<Edge<K, EV>> undirectedEdges = edges._			flatMap(new RegularAndReversedEdgesMap<K, EV>()).name("To undirected graph")__		return new Graph<>(vertices, undirectedEdges, this.context)__	};this,operation,adds,all,inverse,direction,edges,to,the,graph,return,the,undirected,graph;public,graph,k,vv,ev,get,undirected,data,set,edge,k,ev,undirected,edges,edges,flat,map,new,regular,and,reversed,edges,map,k,ev,name,to,undirected,graph,return,new,graph,vertices,undirected,edges,this,context
Graph -> public Graph<K, VV, EV> getUndirected();1484160227;This operation adds all inverse-direction edges to the graph.__@return the undirected graph.;public Graph<K, VV, EV> getUndirected() {__		DataSet<Edge<K, EV>> undirectedEdges = edges._			flatMap(new RegularAndReversedEdgesMap<K, EV>()).name("To undirected graph")__		return new Graph<>(vertices, undirectedEdges, this.context)__	};this,operation,adds,all,inverse,direction,edges,to,the,graph,return,the,undirected,graph;public,graph,k,vv,ev,get,undirected,data,set,edge,k,ev,undirected,edges,edges,flat,map,new,regular,and,reversed,edges,map,k,ev,name,to,undirected,graph,return,new,graph,vertices,undirected,edges,this,context
Graph -> public Graph<K, VV, EV> getUndirected();1484685504;This operation adds all inverse-direction edges to the graph.__@return the undirected graph.;public Graph<K, VV, EV> getUndirected() {__		DataSet<Edge<K, EV>> undirectedEdges = edges._			flatMap(new RegularAndReversedEdgesMap<K, EV>()).name("To undirected graph")__		return new Graph<>(vertices, undirectedEdges, this.context)__	};this,operation,adds,all,inverse,direction,edges,to,the,graph,return,the,undirected,graph;public,graph,k,vv,ev,get,undirected,data,set,edge,k,ev,undirected,edges,edges,flat,map,new,regular,and,reversed,edges,map,k,ev,name,to,undirected,graph,return,new,graph,vertices,undirected,edges,this,context
Graph -> public Graph<K, VV, EV> getUndirected();1489068942;This operation adds all inverse-direction edges to the graph.__@return the undirected graph.;public Graph<K, VV, EV> getUndirected() {__		DataSet<Edge<K, EV>> undirectedEdges = edges._			flatMap(new RegularAndReversedEdgesMap<K, EV>()).name("To undirected graph")__		return new Graph<>(vertices, undirectedEdges, this.context)__	};this,operation,adds,all,inverse,direction,edges,to,the,graph,return,the,undirected,graph;public,graph,k,vv,ev,get,undirected,data,set,edge,k,ev,undirected,edges,edges,flat,map,new,regular,and,reversed,edges,map,k,ev,name,to,undirected,graph,return,new,graph,vertices,undirected,edges,this,context
Graph -> public Graph<K, VV, EV> getUndirected();1490973446;This operation adds all inverse-direction edges to the graph.__@return the undirected graph.;public Graph<K, VV, EV> getUndirected() {__		DataSet<Edge<K, EV>> undirectedEdges = edges._			flatMap(new RegularAndReversedEdgesMap<K, EV>()).name("To undirected graph")__		return new Graph<>(vertices, undirectedEdges, this.context)__	};this,operation,adds,all,inverse,direction,edges,to,the,graph,return,the,undirected,graph;public,graph,k,vv,ev,get,undirected,data,set,edge,k,ev,undirected,edges,edges,flat,map,new,regular,and,reversed,edges,map,k,ev,name,to,undirected,graph,return,new,graph,vertices,undirected,edges,this,context
Graph -> public Graph<K, VV, EV> getUndirected();1495819075;This operation adds all inverse-direction edges to the graph.__@return the undirected graph.;public Graph<K, VV, EV> getUndirected() {__		DataSet<Edge<K, EV>> undirectedEdges = edges._			flatMap(new RegularAndReversedEdgesMap<K, EV>()).name("To undirected graph")__		return new Graph<>(vertices, undirectedEdges, this.context)__	};this,operation,adds,all,inverse,direction,edges,to,the,graph,return,the,undirected,graph;public,graph,k,vv,ev,get,undirected,data,set,edge,k,ev,undirected,edges,edges,flat,map,new,regular,and,reversed,edges,map,k,ev,name,to,undirected,graph,return,new,graph,vertices,undirected,edges,this,context
Graph -> public Graph<K, VV, EV> getUndirected();1502111816;This operation adds all inverse-direction edges to the graph.__@return the undirected graph.;public Graph<K, VV, EV> getUndirected() {__		DataSet<Edge<K, EV>> undirectedEdges = edges._			flatMap(new RegularAndReversedEdgesMap<>()).name("To undirected graph")__		return new Graph<>(vertices, undirectedEdges, this.context)__	};this,operation,adds,all,inverse,direction,edges,to,the,graph,return,the,undirected,graph;public,graph,k,vv,ev,get,undirected,data,set,edge,k,ev,undirected,edges,edges,flat,map,new,regular,and,reversed,edges,map,name,to,undirected,graph,return,new,graph,vertices,undirected,edges,this,context
Graph -> public <T> DataSet<T> groupReduceOnEdges(EdgesFunction<K, EV, T> edgesFunction, 			EdgeDirection direction) throws IllegalArgumentException;1445261977;Groups by vertex and computes a GroupReduce transformation over the edge values of each vertex._The edgesFunction applied on the edges only has access to the vertex id (not the vertex value)_of the grouping vertex.__For each vertex, the edgesFunction can iterate over all edges of this vertex_with the specified direction, and emit any number of output elements, including none.__@param edgesFunction the group reduce function to apply to the neighboring edges of each vertex._@param direction the edge direction (in-, out-, all-)._@param <T> the output type_@return a DataSet containing elements of type T_@throws IllegalArgumentException;public <T> DataSet<T> groupReduceOnEdges(EdgesFunction<K, EV, T> edgesFunction,_			EdgeDirection direction) throws IllegalArgumentException {__		switch (direction) {_		case IN:_			return edges.map(new ProjectVertexIdMap<K, EV>(1))_					.withForwardedFields("f1->f0")_					.groupBy(0).reduceGroup(new ApplyGroupReduceFunction<K, EV, T>(edgesFunction))__		case OUT:_			return edges.map(new ProjectVertexIdMap<K, EV>(0))_					.withForwardedFields("f0")_					.groupBy(0).reduceGroup(new ApplyGroupReduceFunction<K, EV, T>(edgesFunction))__		case ALL:_			return edges.flatMap(new EmitOneEdgePerNode<K, VV, EV>())_					.groupBy(0).reduceGroup(new ApplyGroupReduceFunction<K, EV, T>(edgesFunction))__		default:_			throw new IllegalArgumentException("Illegal edge direction")__		}_	};groups,by,vertex,and,computes,a,group,reduce,transformation,over,the,edge,values,of,each,vertex,the,edges,function,applied,on,the,edges,only,has,access,to,the,vertex,id,not,the,vertex,value,of,the,grouping,vertex,for,each,vertex,the,edges,function,can,iterate,over,all,edges,of,this,vertex,with,the,specified,direction,and,emit,any,number,of,output,elements,including,none,param,edges,function,the,group,reduce,function,to,apply,to,the,neighboring,edges,of,each,vertex,param,direction,the,edge,direction,in,out,all,param,t,the,output,type,return,a,data,set,containing,elements,of,type,t,throws,illegal,argument,exception;public,t,data,set,t,group,reduce,on,edges,edges,function,k,ev,t,edges,function,edge,direction,direction,throws,illegal,argument,exception,switch,direction,case,in,return,edges,map,new,project,vertex,id,map,k,ev,1,with,forwarded,fields,f1,f0,group,by,0,reduce,group,new,apply,group,reduce,function,k,ev,t,edges,function,case,out,return,edges,map,new,project,vertex,id,map,k,ev,0,with,forwarded,fields,f0,group,by,0,reduce,group,new,apply,group,reduce,function,k,ev,t,edges,function,case,all,return,edges,flat,map,new,emit,one,edge,per,node,k,vv,ev,group,by,0,reduce,group,new,apply,group,reduce,function,k,ev,t,edges,function,default,throw,new,illegal,argument,exception,illegal,edge,direction
Graph -> public <T> DataSet<T> groupReduceOnEdges(EdgesFunction<K, EV, T> edgesFunction, 			EdgeDirection direction) throws IllegalArgumentException;1445854323;Groups by vertex and computes a GroupReduce transformation over the edge values of each vertex._The edgesFunction applied on the edges only has access to the vertex id (not the vertex value)_of the grouping vertex.__For each vertex, the edgesFunction can iterate over all edges of this vertex_with the specified direction, and emit any number of output elements, including none.__@param edgesFunction the group reduce function to apply to the neighboring edges of each vertex._@param direction the edge direction (in-, out-, all-)._@param <T> the output type_@return a DataSet containing elements of type T_@throws IllegalArgumentException;public <T> DataSet<T> groupReduceOnEdges(EdgesFunction<K, EV, T> edgesFunction,_			EdgeDirection direction) throws IllegalArgumentException {__		switch (direction) {_		case IN:_			return edges.map(new ProjectVertexIdMap<K, EV>(1))_					.withForwardedFields("f1->f0")_					.groupBy(0).reduceGroup(new ApplyGroupReduceFunction<K, EV, T>(edgesFunction))__		case OUT:_			return edges.map(new ProjectVertexIdMap<K, EV>(0))_					.withForwardedFields("f0")_					.groupBy(0).reduceGroup(new ApplyGroupReduceFunction<K, EV, T>(edgesFunction))__		case ALL:_			return edges.flatMap(new EmitOneEdgePerNode<K, VV, EV>())_					.groupBy(0).reduceGroup(new ApplyGroupReduceFunction<K, EV, T>(edgesFunction))__		default:_			throw new IllegalArgumentException("Illegal edge direction")__		}_	};groups,by,vertex,and,computes,a,group,reduce,transformation,over,the,edge,values,of,each,vertex,the,edges,function,applied,on,the,edges,only,has,access,to,the,vertex,id,not,the,vertex,value,of,the,grouping,vertex,for,each,vertex,the,edges,function,can,iterate,over,all,edges,of,this,vertex,with,the,specified,direction,and,emit,any,number,of,output,elements,including,none,param,edges,function,the,group,reduce,function,to,apply,to,the,neighboring,edges,of,each,vertex,param,direction,the,edge,direction,in,out,all,param,t,the,output,type,return,a,data,set,containing,elements,of,type,t,throws,illegal,argument,exception;public,t,data,set,t,group,reduce,on,edges,edges,function,k,ev,t,edges,function,edge,direction,direction,throws,illegal,argument,exception,switch,direction,case,in,return,edges,map,new,project,vertex,id,map,k,ev,1,with,forwarded,fields,f1,f0,group,by,0,reduce,group,new,apply,group,reduce,function,k,ev,t,edges,function,case,out,return,edges,map,new,project,vertex,id,map,k,ev,0,with,forwarded,fields,f0,group,by,0,reduce,group,new,apply,group,reduce,function,k,ev,t,edges,function,case,all,return,edges,flat,map,new,emit,one,edge,per,node,k,vv,ev,group,by,0,reduce,group,new,apply,group,reduce,function,k,ev,t,edges,function,default,throw,new,illegal,argument,exception,illegal,edge,direction
Graph -> public <T> DataSet<T> groupReduceOnEdges(EdgesFunction<K, EV, T> edgesFunction, 			EdgeDirection direction) throws IllegalArgumentException;1446112342;Groups by vertex and computes a GroupReduce transformation over the edge values of each vertex._The edgesFunction applied on the edges only has access to the vertex id (not the vertex value)_of the grouping vertex.__For each vertex, the edgesFunction can iterate over all edges of this vertex_with the specified direction, and emit any number of output elements, including none.__@param edgesFunction the group reduce function to apply to the neighboring edges of each vertex._@param direction the edge direction (in-, out-, all-)._@param <T> the output type_@return a DataSet containing elements of type T_@throws IllegalArgumentException;public <T> DataSet<T> groupReduceOnEdges(EdgesFunction<K, EV, T> edgesFunction,_			EdgeDirection direction) throws IllegalArgumentException {__		switch (direction) {_		case IN:_			return edges.map(new ProjectVertexIdMap<K, EV>(1))_					.withForwardedFields("f1->f0")_					.groupBy(0).reduceGroup(new ApplyGroupReduceFunction<K, EV, T>(edgesFunction))__		case OUT:_			return edges.map(new ProjectVertexIdMap<K, EV>(0))_					.withForwardedFields("f0")_					.groupBy(0).reduceGroup(new ApplyGroupReduceFunction<K, EV, T>(edgesFunction))__		case ALL:_			return edges.flatMap(new EmitOneEdgePerNode<K, VV, EV>())_					.groupBy(0).reduceGroup(new ApplyGroupReduceFunction<K, EV, T>(edgesFunction))__		default:_			throw new IllegalArgumentException("Illegal edge direction")__		}_	};groups,by,vertex,and,computes,a,group,reduce,transformation,over,the,edge,values,of,each,vertex,the,edges,function,applied,on,the,edges,only,has,access,to,the,vertex,id,not,the,vertex,value,of,the,grouping,vertex,for,each,vertex,the,edges,function,can,iterate,over,all,edges,of,this,vertex,with,the,specified,direction,and,emit,any,number,of,output,elements,including,none,param,edges,function,the,group,reduce,function,to,apply,to,the,neighboring,edges,of,each,vertex,param,direction,the,edge,direction,in,out,all,param,t,the,output,type,return,a,data,set,containing,elements,of,type,t,throws,illegal,argument,exception;public,t,data,set,t,group,reduce,on,edges,edges,function,k,ev,t,edges,function,edge,direction,direction,throws,illegal,argument,exception,switch,direction,case,in,return,edges,map,new,project,vertex,id,map,k,ev,1,with,forwarded,fields,f1,f0,group,by,0,reduce,group,new,apply,group,reduce,function,k,ev,t,edges,function,case,out,return,edges,map,new,project,vertex,id,map,k,ev,0,with,forwarded,fields,f0,group,by,0,reduce,group,new,apply,group,reduce,function,k,ev,t,edges,function,case,all,return,edges,flat,map,new,emit,one,edge,per,node,k,vv,ev,group,by,0,reduce,group,new,apply,group,reduce,function,k,ev,t,edges,function,default,throw,new,illegal,argument,exception,illegal,edge,direction
Graph -> public <T> DataSet<T> groupReduceOnEdges(EdgesFunction<K, EV, T> edgesFunction, 			EdgeDirection direction) throws IllegalArgumentException;1447073368;Groups by vertex and computes a GroupReduce transformation over the edge values of each vertex._The edgesFunction applied on the edges only has access to the vertex id (not the vertex value)_of the grouping vertex.__For each vertex, the edgesFunction can iterate over all edges of this vertex_with the specified direction, and emit any number of output elements, including none.__@param edgesFunction the group reduce function to apply to the neighboring edges of each vertex._@param direction the edge direction (in-, out-, all-)._@param <T> the output type_@return a DataSet containing elements of type T_@throws IllegalArgumentException;public <T> DataSet<T> groupReduceOnEdges(EdgesFunction<K, EV, T> edgesFunction,_			EdgeDirection direction) throws IllegalArgumentException {__		switch (direction) {_		case IN:_			return edges.map(new ProjectVertexIdMap<K, EV>(1))_					.withForwardedFields("f1->f0")_					.groupBy(0).reduceGroup(new ApplyGroupReduceFunction<K, EV, T>(edgesFunction))__		case OUT:_			return edges.map(new ProjectVertexIdMap<K, EV>(0))_					.withForwardedFields("f0")_					.groupBy(0).reduceGroup(new ApplyGroupReduceFunction<K, EV, T>(edgesFunction))__		case ALL:_			return edges.flatMap(new EmitOneEdgePerNode<K, VV, EV>())_					.groupBy(0).reduceGroup(new ApplyGroupReduceFunction<K, EV, T>(edgesFunction))__		default:_			throw new IllegalArgumentException("Illegal edge direction")__		}_	};groups,by,vertex,and,computes,a,group,reduce,transformation,over,the,edge,values,of,each,vertex,the,edges,function,applied,on,the,edges,only,has,access,to,the,vertex,id,not,the,vertex,value,of,the,grouping,vertex,for,each,vertex,the,edges,function,can,iterate,over,all,edges,of,this,vertex,with,the,specified,direction,and,emit,any,number,of,output,elements,including,none,param,edges,function,the,group,reduce,function,to,apply,to,the,neighboring,edges,of,each,vertex,param,direction,the,edge,direction,in,out,all,param,t,the,output,type,return,a,data,set,containing,elements,of,type,t,throws,illegal,argument,exception;public,t,data,set,t,group,reduce,on,edges,edges,function,k,ev,t,edges,function,edge,direction,direction,throws,illegal,argument,exception,switch,direction,case,in,return,edges,map,new,project,vertex,id,map,k,ev,1,with,forwarded,fields,f1,f0,group,by,0,reduce,group,new,apply,group,reduce,function,k,ev,t,edges,function,case,out,return,edges,map,new,project,vertex,id,map,k,ev,0,with,forwarded,fields,f0,group,by,0,reduce,group,new,apply,group,reduce,function,k,ev,t,edges,function,case,all,return,edges,flat,map,new,emit,one,edge,per,node,k,vv,ev,group,by,0,reduce,group,new,apply,group,reduce,function,k,ev,t,edges,function,default,throw,new,illegal,argument,exception,illegal,edge,direction
Graph -> public <T> DataSet<T> groupReduceOnEdges(EdgesFunction<K, EV, T> edgesFunction, 			EdgeDirection direction) throws IllegalArgumentException;1454404649;Groups by vertex and computes a GroupReduce transformation over the edge values of each vertex._The edgesFunction applied on the edges only has access to the vertex id (not the vertex value)_of the grouping vertex.__For each vertex, the edgesFunction can iterate over all edges of this vertex_with the specified direction, and emit any number of output elements, including none.__@param edgesFunction the group reduce function to apply to the neighboring edges of each vertex._@param direction the edge direction (in-, out-, all-)._@param <T> the output type_@return a DataSet containing elements of type T_@throws IllegalArgumentException;public <T> DataSet<T> groupReduceOnEdges(EdgesFunction<K, EV, T> edgesFunction,_			EdgeDirection direction) throws IllegalArgumentException {__		switch (direction) {_		case IN:_			return edges.map(new ProjectVertexIdMap<K, EV>(1))_					.withForwardedFields("f1->f0")_					.groupBy(0).reduceGroup(new ApplyGroupReduceFunction<K, EV, T>(edgesFunction))__		case OUT:_			return edges.map(new ProjectVertexIdMap<K, EV>(0))_					.withForwardedFields("f0")_					.groupBy(0).reduceGroup(new ApplyGroupReduceFunction<K, EV, T>(edgesFunction))__		case ALL:_			return edges.flatMap(new EmitOneEdgePerNode<K, VV, EV>())_					.groupBy(0).reduceGroup(new ApplyGroupReduceFunction<K, EV, T>(edgesFunction))__		default:_			throw new IllegalArgumentException("Illegal edge direction")__		}_	};groups,by,vertex,and,computes,a,group,reduce,transformation,over,the,edge,values,of,each,vertex,the,edges,function,applied,on,the,edges,only,has,access,to,the,vertex,id,not,the,vertex,value,of,the,grouping,vertex,for,each,vertex,the,edges,function,can,iterate,over,all,edges,of,this,vertex,with,the,specified,direction,and,emit,any,number,of,output,elements,including,none,param,edges,function,the,group,reduce,function,to,apply,to,the,neighboring,edges,of,each,vertex,param,direction,the,edge,direction,in,out,all,param,t,the,output,type,return,a,data,set,containing,elements,of,type,t,throws,illegal,argument,exception;public,t,data,set,t,group,reduce,on,edges,edges,function,k,ev,t,edges,function,edge,direction,direction,throws,illegal,argument,exception,switch,direction,case,in,return,edges,map,new,project,vertex,id,map,k,ev,1,with,forwarded,fields,f1,f0,group,by,0,reduce,group,new,apply,group,reduce,function,k,ev,t,edges,function,case,out,return,edges,map,new,project,vertex,id,map,k,ev,0,with,forwarded,fields,f0,group,by,0,reduce,group,new,apply,group,reduce,function,k,ev,t,edges,function,case,all,return,edges,flat,map,new,emit,one,edge,per,node,k,vv,ev,group,by,0,reduce,group,new,apply,group,reduce,function,k,ev,t,edges,function,default,throw,new,illegal,argument,exception,illegal,edge,direction
Graph -> public <T> DataSet<T> groupReduceOnEdges(EdgesFunction<K, EV, T> edgesFunction, 			EdgeDirection direction) throws IllegalArgumentException;1458583829;Groups by vertex and computes a GroupReduce transformation over the edge values of each vertex._The edgesFunction applied on the edges only has access to the vertex id (not the vertex value)_of the grouping vertex.__For each vertex, the edgesFunction can iterate over all edges of this vertex_with the specified direction, and emit any number of output elements, including none.__@param edgesFunction the group reduce function to apply to the neighboring edges of each vertex._@param direction the edge direction (in-, out-, all-)._@param <T> the output type_@return a DataSet containing elements of type T_@throws IllegalArgumentException;public <T> DataSet<T> groupReduceOnEdges(EdgesFunction<K, EV, T> edgesFunction,_			EdgeDirection direction) throws IllegalArgumentException {__		switch (direction) {_		case IN:_			return edges.map(new ProjectVertexIdMap<K, EV>(1))_					.withForwardedFields("f1->f0")_					.groupBy(0).reduceGroup(new ApplyGroupReduceFunction<K, EV, T>(edgesFunction))__		case OUT:_			return edges.map(new ProjectVertexIdMap<K, EV>(0))_					.withForwardedFields("f0")_					.groupBy(0).reduceGroup(new ApplyGroupReduceFunction<K, EV, T>(edgesFunction))__		case ALL:_			return edges.flatMap(new EmitOneEdgePerNode<K, VV, EV>())_					.groupBy(0).reduceGroup(new ApplyGroupReduceFunction<K, EV, T>(edgesFunction))__		default:_			throw new IllegalArgumentException("Illegal edge direction")__		}_	};groups,by,vertex,and,computes,a,group,reduce,transformation,over,the,edge,values,of,each,vertex,the,edges,function,applied,on,the,edges,only,has,access,to,the,vertex,id,not,the,vertex,value,of,the,grouping,vertex,for,each,vertex,the,edges,function,can,iterate,over,all,edges,of,this,vertex,with,the,specified,direction,and,emit,any,number,of,output,elements,including,none,param,edges,function,the,group,reduce,function,to,apply,to,the,neighboring,edges,of,each,vertex,param,direction,the,edge,direction,in,out,all,param,t,the,output,type,return,a,data,set,containing,elements,of,type,t,throws,illegal,argument,exception;public,t,data,set,t,group,reduce,on,edges,edges,function,k,ev,t,edges,function,edge,direction,direction,throws,illegal,argument,exception,switch,direction,case,in,return,edges,map,new,project,vertex,id,map,k,ev,1,with,forwarded,fields,f1,f0,group,by,0,reduce,group,new,apply,group,reduce,function,k,ev,t,edges,function,case,out,return,edges,map,new,project,vertex,id,map,k,ev,0,with,forwarded,fields,f0,group,by,0,reduce,group,new,apply,group,reduce,function,k,ev,t,edges,function,case,all,return,edges,flat,map,new,emit,one,edge,per,node,k,vv,ev,group,by,0,reduce,group,new,apply,group,reduce,function,k,ev,t,edges,function,default,throw,new,illegal,argument,exception,illegal,edge,direction
Graph -> public <T> DataSet<T> groupReduceOnEdges(EdgesFunction<K, EV, T> edgesFunction, 			EdgeDirection direction) throws IllegalArgumentException;1458583829;Groups by vertex and computes a GroupReduce transformation over the edge values of each vertex._The edgesFunction applied on the edges only has access to the vertex id (not the vertex value)_of the grouping vertex.__For each vertex, the edgesFunction can iterate over all edges of this vertex_with the specified direction, and emit any number of output elements, including none.__@param edgesFunction the group reduce function to apply to the neighboring edges of each vertex._@param direction the edge direction (in-, out-, all-)._@param <T> the output type_@return a DataSet containing elements of type T_@throws IllegalArgumentException;public <T> DataSet<T> groupReduceOnEdges(EdgesFunction<K, EV, T> edgesFunction,_			EdgeDirection direction) throws IllegalArgumentException {__		switch (direction) {_		case IN:_			return edges.map(new ProjectVertexIdMap<K, EV>(1))_					.withForwardedFields("f1->f0")_					.groupBy(0).reduceGroup(new ApplyGroupReduceFunction<K, EV, T>(edgesFunction))__		case OUT:_			return edges.map(new ProjectVertexIdMap<K, EV>(0))_					.withForwardedFields("f0")_					.groupBy(0).reduceGroup(new ApplyGroupReduceFunction<K, EV, T>(edgesFunction))__		case ALL:_			return edges.flatMap(new EmitOneEdgePerNode<K, VV, EV>())_					.groupBy(0).reduceGroup(new ApplyGroupReduceFunction<K, EV, T>(edgesFunction))__		default:_			throw new IllegalArgumentException("Illegal edge direction")__		}_	};groups,by,vertex,and,computes,a,group,reduce,transformation,over,the,edge,values,of,each,vertex,the,edges,function,applied,on,the,edges,only,has,access,to,the,vertex,id,not,the,vertex,value,of,the,grouping,vertex,for,each,vertex,the,edges,function,can,iterate,over,all,edges,of,this,vertex,with,the,specified,direction,and,emit,any,number,of,output,elements,including,none,param,edges,function,the,group,reduce,function,to,apply,to,the,neighboring,edges,of,each,vertex,param,direction,the,edge,direction,in,out,all,param,t,the,output,type,return,a,data,set,containing,elements,of,type,t,throws,illegal,argument,exception;public,t,data,set,t,group,reduce,on,edges,edges,function,k,ev,t,edges,function,edge,direction,direction,throws,illegal,argument,exception,switch,direction,case,in,return,edges,map,new,project,vertex,id,map,k,ev,1,with,forwarded,fields,f1,f0,group,by,0,reduce,group,new,apply,group,reduce,function,k,ev,t,edges,function,case,out,return,edges,map,new,project,vertex,id,map,k,ev,0,with,forwarded,fields,f0,group,by,0,reduce,group,new,apply,group,reduce,function,k,ev,t,edges,function,case,all,return,edges,flat,map,new,emit,one,edge,per,node,k,vv,ev,group,by,0,reduce,group,new,apply,group,reduce,function,k,ev,t,edges,function,default,throw,new,illegal,argument,exception,illegal,edge,direction
Graph -> public <T> DataSet<T> groupReduceOnEdges(EdgesFunction<K, EV, T> edgesFunction, 			EdgeDirection direction) throws IllegalArgumentException;1462100316;Groups by vertex and computes a GroupReduce transformation over the edge values of each vertex._The edgesFunction applied on the edges only has access to the vertex id (not the vertex value)_of the grouping vertex.__For each vertex, the edgesFunction can iterate over all edges of this vertex_with the specified direction, and emit any number of output elements, including none.__@param edgesFunction the group reduce function to apply to the neighboring edges of each vertex._@param direction the edge direction (in-, out-, all-)._@param <T> the output type_@return a DataSet containing elements of type T_@throws IllegalArgumentException;public <T> DataSet<T> groupReduceOnEdges(EdgesFunction<K, EV, T> edgesFunction,_			EdgeDirection direction) throws IllegalArgumentException {__		switch (direction) {_		case IN:_			return edges.map(new ProjectVertexIdMap<K, EV>(1))_					.withForwardedFields("f1->f0")_					.groupBy(0).reduceGroup(new ApplyGroupReduceFunction<K, EV, T>(edgesFunction))__		case OUT:_			return edges.map(new ProjectVertexIdMap<K, EV>(0))_					.withForwardedFields("f0")_					.groupBy(0).reduceGroup(new ApplyGroupReduceFunction<K, EV, T>(edgesFunction))__		case ALL:_			return edges.flatMap(new EmitOneEdgePerNode<K, VV, EV>())_					.groupBy(0).reduceGroup(new ApplyGroupReduceFunction<K, EV, T>(edgesFunction))__		default:_			throw new IllegalArgumentException("Illegal edge direction")__		}_	};groups,by,vertex,and,computes,a,group,reduce,transformation,over,the,edge,values,of,each,vertex,the,edges,function,applied,on,the,edges,only,has,access,to,the,vertex,id,not,the,vertex,value,of,the,grouping,vertex,for,each,vertex,the,edges,function,can,iterate,over,all,edges,of,this,vertex,with,the,specified,direction,and,emit,any,number,of,output,elements,including,none,param,edges,function,the,group,reduce,function,to,apply,to,the,neighboring,edges,of,each,vertex,param,direction,the,edge,direction,in,out,all,param,t,the,output,type,return,a,data,set,containing,elements,of,type,t,throws,illegal,argument,exception;public,t,data,set,t,group,reduce,on,edges,edges,function,k,ev,t,edges,function,edge,direction,direction,throws,illegal,argument,exception,switch,direction,case,in,return,edges,map,new,project,vertex,id,map,k,ev,1,with,forwarded,fields,f1,f0,group,by,0,reduce,group,new,apply,group,reduce,function,k,ev,t,edges,function,case,out,return,edges,map,new,project,vertex,id,map,k,ev,0,with,forwarded,fields,f0,group,by,0,reduce,group,new,apply,group,reduce,function,k,ev,t,edges,function,case,all,return,edges,flat,map,new,emit,one,edge,per,node,k,vv,ev,group,by,0,reduce,group,new,apply,group,reduce,function,k,ev,t,edges,function,default,throw,new,illegal,argument,exception,illegal,edge,direction
Graph -> public <T> DataSet<T> groupReduceOnEdges(EdgesFunction<K, EV, T> edgesFunction, 			EdgeDirection direction) throws IllegalArgumentException;1462100316;Groups by vertex and computes a GroupReduce transformation over the edge values of each vertex._The edgesFunction applied on the edges only has access to the vertex id (not the vertex value)_of the grouping vertex.__For each vertex, the edgesFunction can iterate over all edges of this vertex_with the specified direction, and emit any number of output elements, including none.__@param edgesFunction the group reduce function to apply to the neighboring edges of each vertex._@param direction the edge direction (in-, out-, all-)._@param <T> the output type_@return a DataSet containing elements of type T_@throws IllegalArgumentException;public <T> DataSet<T> groupReduceOnEdges(EdgesFunction<K, EV, T> edgesFunction,_			EdgeDirection direction) throws IllegalArgumentException {__		switch (direction) {_		case IN:_			return edges.map(new ProjectVertexIdMap<K, EV>(1))_					.withForwardedFields("f1->f0")_					.groupBy(0).reduceGroup(new ApplyGroupReduceFunction<K, EV, T>(edgesFunction))__		case OUT:_			return edges.map(new ProjectVertexIdMap<K, EV>(0))_					.withForwardedFields("f0")_					.groupBy(0).reduceGroup(new ApplyGroupReduceFunction<K, EV, T>(edgesFunction))__		case ALL:_			return edges.flatMap(new EmitOneEdgePerNode<K, VV, EV>())_					.groupBy(0).reduceGroup(new ApplyGroupReduceFunction<K, EV, T>(edgesFunction))__		default:_			throw new IllegalArgumentException("Illegal edge direction")__		}_	};groups,by,vertex,and,computes,a,group,reduce,transformation,over,the,edge,values,of,each,vertex,the,edges,function,applied,on,the,edges,only,has,access,to,the,vertex,id,not,the,vertex,value,of,the,grouping,vertex,for,each,vertex,the,edges,function,can,iterate,over,all,edges,of,this,vertex,with,the,specified,direction,and,emit,any,number,of,output,elements,including,none,param,edges,function,the,group,reduce,function,to,apply,to,the,neighboring,edges,of,each,vertex,param,direction,the,edge,direction,in,out,all,param,t,the,output,type,return,a,data,set,containing,elements,of,type,t,throws,illegal,argument,exception;public,t,data,set,t,group,reduce,on,edges,edges,function,k,ev,t,edges,function,edge,direction,direction,throws,illegal,argument,exception,switch,direction,case,in,return,edges,map,new,project,vertex,id,map,k,ev,1,with,forwarded,fields,f1,f0,group,by,0,reduce,group,new,apply,group,reduce,function,k,ev,t,edges,function,case,out,return,edges,map,new,project,vertex,id,map,k,ev,0,with,forwarded,fields,f0,group,by,0,reduce,group,new,apply,group,reduce,function,k,ev,t,edges,function,case,all,return,edges,flat,map,new,emit,one,edge,per,node,k,vv,ev,group,by,0,reduce,group,new,apply,group,reduce,function,k,ev,t,edges,function,default,throw,new,illegal,argument,exception,illegal,edge,direction
Graph -> public <T> DataSet<T> groupReduceOnEdges(EdgesFunction<K, EV, T> edgesFunction, 			EdgeDirection direction) throws IllegalArgumentException;1462205213;Groups by vertex and computes a GroupReduce transformation over the edge values of each vertex._The edgesFunction applied on the edges only has access to the vertex id (not the vertex value)_of the grouping vertex.__For each vertex, the edgesFunction can iterate over all edges of this vertex_with the specified direction, and emit any number of output elements, including none.__@param edgesFunction the group reduce function to apply to the neighboring edges of each vertex._@param direction the edge direction (in-, out-, all-)._@param <T> the output type_@return a DataSet containing elements of type T_@throws IllegalArgumentException;public <T> DataSet<T> groupReduceOnEdges(EdgesFunction<K, EV, T> edgesFunction,_			EdgeDirection direction) throws IllegalArgumentException {__		switch (direction) {_		case IN:_			return edges.map(new ProjectVertexIdMap<K, EV>(1))_					.withForwardedFields("f1->f0")_					.groupBy(0).reduceGroup(new ApplyGroupReduceFunction<K, EV, T>(edgesFunction))__		case OUT:_			return edges.map(new ProjectVertexIdMap<K, EV>(0))_					.withForwardedFields("f0")_					.groupBy(0).reduceGroup(new ApplyGroupReduceFunction<K, EV, T>(edgesFunction))__		case ALL:_			return edges.flatMap(new EmitOneEdgePerNode<K, VV, EV>())_					.groupBy(0).reduceGroup(new ApplyGroupReduceFunction<K, EV, T>(edgesFunction))__		default:_			throw new IllegalArgumentException("Illegal edge direction")__		}_	};groups,by,vertex,and,computes,a,group,reduce,transformation,over,the,edge,values,of,each,vertex,the,edges,function,applied,on,the,edges,only,has,access,to,the,vertex,id,not,the,vertex,value,of,the,grouping,vertex,for,each,vertex,the,edges,function,can,iterate,over,all,edges,of,this,vertex,with,the,specified,direction,and,emit,any,number,of,output,elements,including,none,param,edges,function,the,group,reduce,function,to,apply,to,the,neighboring,edges,of,each,vertex,param,direction,the,edge,direction,in,out,all,param,t,the,output,type,return,a,data,set,containing,elements,of,type,t,throws,illegal,argument,exception;public,t,data,set,t,group,reduce,on,edges,edges,function,k,ev,t,edges,function,edge,direction,direction,throws,illegal,argument,exception,switch,direction,case,in,return,edges,map,new,project,vertex,id,map,k,ev,1,with,forwarded,fields,f1,f0,group,by,0,reduce,group,new,apply,group,reduce,function,k,ev,t,edges,function,case,out,return,edges,map,new,project,vertex,id,map,k,ev,0,with,forwarded,fields,f0,group,by,0,reduce,group,new,apply,group,reduce,function,k,ev,t,edges,function,case,all,return,edges,flat,map,new,emit,one,edge,per,node,k,vv,ev,group,by,0,reduce,group,new,apply,group,reduce,function,k,ev,t,edges,function,default,throw,new,illegal,argument,exception,illegal,edge,direction
Graph -> public <T> DataSet<T> groupReduceOnEdges(EdgesFunction<K, EV, T> edgesFunction, 			EdgeDirection direction) throws IllegalArgumentException;1462208859;Groups by vertex and computes a GroupReduce transformation over the edge values of each vertex._The edgesFunction applied on the edges only has access to the vertex id (not the vertex value)_of the grouping vertex.__For each vertex, the edgesFunction can iterate over all edges of this vertex_with the specified direction, and emit any number of output elements, including none.__@param edgesFunction the group reduce function to apply to the neighboring edges of each vertex._@param direction the edge direction (in-, out-, all-)._@param <T> the output type_@return a DataSet containing elements of type T_@throws IllegalArgumentException;public <T> DataSet<T> groupReduceOnEdges(EdgesFunction<K, EV, T> edgesFunction,_			EdgeDirection direction) throws IllegalArgumentException {__		switch (direction) {_		case IN:_			return edges.map(new ProjectVertexIdMap<K, EV>(1))_					.withForwardedFields("f1->f0")_					.groupBy(0).reduceGroup(new ApplyGroupReduceFunction<K, EV, T>(edgesFunction))__		case OUT:_			return edges.map(new ProjectVertexIdMap<K, EV>(0))_					.withForwardedFields("f0")_					.groupBy(0).reduceGroup(new ApplyGroupReduceFunction<K, EV, T>(edgesFunction))__		case ALL:_			return edges.flatMap(new EmitOneEdgePerNode<K, VV, EV>())_					.groupBy(0).reduceGroup(new ApplyGroupReduceFunction<K, EV, T>(edgesFunction))__		default:_			throw new IllegalArgumentException("Illegal edge direction")__		}_	};groups,by,vertex,and,computes,a,group,reduce,transformation,over,the,edge,values,of,each,vertex,the,edges,function,applied,on,the,edges,only,has,access,to,the,vertex,id,not,the,vertex,value,of,the,grouping,vertex,for,each,vertex,the,edges,function,can,iterate,over,all,edges,of,this,vertex,with,the,specified,direction,and,emit,any,number,of,output,elements,including,none,param,edges,function,the,group,reduce,function,to,apply,to,the,neighboring,edges,of,each,vertex,param,direction,the,edge,direction,in,out,all,param,t,the,output,type,return,a,data,set,containing,elements,of,type,t,throws,illegal,argument,exception;public,t,data,set,t,group,reduce,on,edges,edges,function,k,ev,t,edges,function,edge,direction,direction,throws,illegal,argument,exception,switch,direction,case,in,return,edges,map,new,project,vertex,id,map,k,ev,1,with,forwarded,fields,f1,f0,group,by,0,reduce,group,new,apply,group,reduce,function,k,ev,t,edges,function,case,out,return,edges,map,new,project,vertex,id,map,k,ev,0,with,forwarded,fields,f0,group,by,0,reduce,group,new,apply,group,reduce,function,k,ev,t,edges,function,case,all,return,edges,flat,map,new,emit,one,edge,per,node,k,vv,ev,group,by,0,reduce,group,new,apply,group,reduce,function,k,ev,t,edges,function,default,throw,new,illegal,argument,exception,illegal,edge,direction
Graph -> public <T> DataSet<T> groupReduceOnEdges(EdgesFunction<K, EV, T> edgesFunction, 			EdgeDirection direction) throws IllegalArgumentException;1462809297;Groups by vertex and computes a GroupReduce transformation over the edge values of each vertex._The edgesFunction applied on the edges only has access to the vertex id (not the vertex value)_of the grouping vertex.__For each vertex, the edgesFunction can iterate over all edges of this vertex_with the specified direction, and emit any number of output elements, including none.__@param edgesFunction the group reduce function to apply to the neighboring edges of each vertex._@param direction the edge direction (in-, out-, all-)._@param <T> the output type_@return a DataSet containing elements of type T_@throws IllegalArgumentException;public <T> DataSet<T> groupReduceOnEdges(EdgesFunction<K, EV, T> edgesFunction,_			EdgeDirection direction) throws IllegalArgumentException {__		switch (direction) {_		case IN:_			return edges.map(new ProjectVertexIdMap<K, EV>(1))_					.withForwardedFields("f1->f0")_					.groupBy(0).reduceGroup(new ApplyGroupReduceFunction<K, EV, T>(edgesFunction))__		case OUT:_			return edges.map(new ProjectVertexIdMap<K, EV>(0))_					.withForwardedFields("f0")_					.groupBy(0).reduceGroup(new ApplyGroupReduceFunction<K, EV, T>(edgesFunction))__		case ALL:_			return edges.flatMap(new EmitOneEdgePerNode<K, VV, EV>())_					.groupBy(0).reduceGroup(new ApplyGroupReduceFunction<K, EV, T>(edgesFunction))__		default:_			throw new IllegalArgumentException("Illegal edge direction")__		}_	};groups,by,vertex,and,computes,a,group,reduce,transformation,over,the,edge,values,of,each,vertex,the,edges,function,applied,on,the,edges,only,has,access,to,the,vertex,id,not,the,vertex,value,of,the,grouping,vertex,for,each,vertex,the,edges,function,can,iterate,over,all,edges,of,this,vertex,with,the,specified,direction,and,emit,any,number,of,output,elements,including,none,param,edges,function,the,group,reduce,function,to,apply,to,the,neighboring,edges,of,each,vertex,param,direction,the,edge,direction,in,out,all,param,t,the,output,type,return,a,data,set,containing,elements,of,type,t,throws,illegal,argument,exception;public,t,data,set,t,group,reduce,on,edges,edges,function,k,ev,t,edges,function,edge,direction,direction,throws,illegal,argument,exception,switch,direction,case,in,return,edges,map,new,project,vertex,id,map,k,ev,1,with,forwarded,fields,f1,f0,group,by,0,reduce,group,new,apply,group,reduce,function,k,ev,t,edges,function,case,out,return,edges,map,new,project,vertex,id,map,k,ev,0,with,forwarded,fields,f0,group,by,0,reduce,group,new,apply,group,reduce,function,k,ev,t,edges,function,case,all,return,edges,flat,map,new,emit,one,edge,per,node,k,vv,ev,group,by,0,reduce,group,new,apply,group,reduce,function,k,ev,t,edges,function,default,throw,new,illegal,argument,exception,illegal,edge,direction
Graph -> public <T> DataSet<T> groupReduceOnEdges(EdgesFunction<K, EV, T> edgesFunction, 			EdgeDirection direction) throws IllegalArgumentException;1465316775;Groups by vertex and computes a GroupReduce transformation over the edge values of each vertex._The edgesFunction applied on the edges only has access to the vertex id (not the vertex value)_of the grouping vertex.__For each vertex, the edgesFunction can iterate over all edges of this vertex_with the specified direction, and emit any number of output elements, including none.__@param edgesFunction the group reduce function to apply to the neighboring edges of each vertex._@param direction the edge direction (in-, out-, all-)._@param <T> the output type_@return a DataSet containing elements of type T_@throws IllegalArgumentException;public <T> DataSet<T> groupReduceOnEdges(EdgesFunction<K, EV, T> edgesFunction,_			EdgeDirection direction) throws IllegalArgumentException {__		switch (direction) {_		case IN:_			return edges.map(new ProjectVertexIdMap<K, EV>(1))_					.withForwardedFields("f1->f0")_					.groupBy(0).reduceGroup(new ApplyGroupReduceFunction<K, EV, T>(edgesFunction))__		case OUT:_			return edges.map(new ProjectVertexIdMap<K, EV>(0))_					.withForwardedFields("f0")_					.groupBy(0).reduceGroup(new ApplyGroupReduceFunction<K, EV, T>(edgesFunction))__		case ALL:_			return edges.flatMap(new EmitOneEdgePerNode<K, VV, EV>())_					.groupBy(0).reduceGroup(new ApplyGroupReduceFunction<K, EV, T>(edgesFunction))__		default:_			throw new IllegalArgumentException("Illegal edge direction")__		}_	};groups,by,vertex,and,computes,a,group,reduce,transformation,over,the,edge,values,of,each,vertex,the,edges,function,applied,on,the,edges,only,has,access,to,the,vertex,id,not,the,vertex,value,of,the,grouping,vertex,for,each,vertex,the,edges,function,can,iterate,over,all,edges,of,this,vertex,with,the,specified,direction,and,emit,any,number,of,output,elements,including,none,param,edges,function,the,group,reduce,function,to,apply,to,the,neighboring,edges,of,each,vertex,param,direction,the,edge,direction,in,out,all,param,t,the,output,type,return,a,data,set,containing,elements,of,type,t,throws,illegal,argument,exception;public,t,data,set,t,group,reduce,on,edges,edges,function,k,ev,t,edges,function,edge,direction,direction,throws,illegal,argument,exception,switch,direction,case,in,return,edges,map,new,project,vertex,id,map,k,ev,1,with,forwarded,fields,f1,f0,group,by,0,reduce,group,new,apply,group,reduce,function,k,ev,t,edges,function,case,out,return,edges,map,new,project,vertex,id,map,k,ev,0,with,forwarded,fields,f0,group,by,0,reduce,group,new,apply,group,reduce,function,k,ev,t,edges,function,case,all,return,edges,flat,map,new,emit,one,edge,per,node,k,vv,ev,group,by,0,reduce,group,new,apply,group,reduce,function,k,ev,t,edges,function,default,throw,new,illegal,argument,exception,illegal,edge,direction
Graph -> public <T> DataSet<T> groupReduceOnEdges(EdgesFunction<K, EV, T> edgesFunction, 			EdgeDirection direction) throws IllegalArgumentException;1466789678;Groups by vertex and computes a GroupReduce transformation over the edge values of each vertex._The edgesFunction applied on the edges only has access to the vertex id (not the vertex value)_of the grouping vertex.__For each vertex, the edgesFunction can iterate over all edges of this vertex_with the specified direction, and emit any number of output elements, including none.__@param edgesFunction the group reduce function to apply to the neighboring edges of each vertex._@param direction the edge direction (in-, out-, all-)._@param <T> the output type_@return a DataSet containing elements of type T_@throws IllegalArgumentException;public <T> DataSet<T> groupReduceOnEdges(EdgesFunction<K, EV, T> edgesFunction,_			EdgeDirection direction) throws IllegalArgumentException {__		switch (direction) {_		case IN:_			return edges.map(new ProjectVertexIdMap<K, EV>(1))_					.withForwardedFields("f1->f0")_					.groupBy(0).reduceGroup(new ApplyGroupReduceFunction<K, EV, T>(edgesFunction))__		case OUT:_			return edges.map(new ProjectVertexIdMap<K, EV>(0))_					.withForwardedFields("f0")_					.groupBy(0).reduceGroup(new ApplyGroupReduceFunction<K, EV, T>(edgesFunction))__		case ALL:_			return edges.flatMap(new EmitOneEdgePerNode<K, VV, EV>())_					.groupBy(0).reduceGroup(new ApplyGroupReduceFunction<K, EV, T>(edgesFunction))__		default:_			throw new IllegalArgumentException("Illegal edge direction")__		}_	};groups,by,vertex,and,computes,a,group,reduce,transformation,over,the,edge,values,of,each,vertex,the,edges,function,applied,on,the,edges,only,has,access,to,the,vertex,id,not,the,vertex,value,of,the,grouping,vertex,for,each,vertex,the,edges,function,can,iterate,over,all,edges,of,this,vertex,with,the,specified,direction,and,emit,any,number,of,output,elements,including,none,param,edges,function,the,group,reduce,function,to,apply,to,the,neighboring,edges,of,each,vertex,param,direction,the,edge,direction,in,out,all,param,t,the,output,type,return,a,data,set,containing,elements,of,type,t,throws,illegal,argument,exception;public,t,data,set,t,group,reduce,on,edges,edges,function,k,ev,t,edges,function,edge,direction,direction,throws,illegal,argument,exception,switch,direction,case,in,return,edges,map,new,project,vertex,id,map,k,ev,1,with,forwarded,fields,f1,f0,group,by,0,reduce,group,new,apply,group,reduce,function,k,ev,t,edges,function,case,out,return,edges,map,new,project,vertex,id,map,k,ev,0,with,forwarded,fields,f0,group,by,0,reduce,group,new,apply,group,reduce,function,k,ev,t,edges,function,case,all,return,edges,flat,map,new,emit,one,edge,per,node,k,vv,ev,group,by,0,reduce,group,new,apply,group,reduce,function,k,ev,t,edges,function,default,throw,new,illegal,argument,exception,illegal,edge,direction
Graph -> public <T> DataSet<T> groupReduceOnEdges(EdgesFunction<K, EV, T> edgesFunction, 			EdgeDirection direction) throws IllegalArgumentException;1467140656;Groups by vertex and computes a GroupReduce transformation over the edge values of each vertex._The edgesFunction applied on the edges only has access to the vertex id (not the vertex value)_of the grouping vertex.__For each vertex, the edgesFunction can iterate over all edges of this vertex_with the specified direction, and emit any number of output elements, including none.__@param edgesFunction the group reduce function to apply to the neighboring edges of each vertex._@param direction the edge direction (in-, out-, all-)._@param <T> the output type_@return a DataSet containing elements of type T_@throws IllegalArgumentException;public <T> DataSet<T> groupReduceOnEdges(EdgesFunction<K, EV, T> edgesFunction,_			EdgeDirection direction) throws IllegalArgumentException {__		switch (direction) {_		case IN:_			return edges.map(new ProjectVertexIdMap<K, EV>(1))_					.withForwardedFields("f1->f0")_					.groupBy(0).reduceGroup(new ApplyGroupReduceFunction<K, EV, T>(edgesFunction))__		case OUT:_			return edges.map(new ProjectVertexIdMap<K, EV>(0))_					.withForwardedFields("f0")_					.groupBy(0).reduceGroup(new ApplyGroupReduceFunction<K, EV, T>(edgesFunction))__		case ALL:_			return edges.flatMap(new EmitOneEdgePerNode<K, VV, EV>())_					.groupBy(0).reduceGroup(new ApplyGroupReduceFunction<K, EV, T>(edgesFunction))__		default:_			throw new IllegalArgumentException("Illegal edge direction")__		}_	};groups,by,vertex,and,computes,a,group,reduce,transformation,over,the,edge,values,of,each,vertex,the,edges,function,applied,on,the,edges,only,has,access,to,the,vertex,id,not,the,vertex,value,of,the,grouping,vertex,for,each,vertex,the,edges,function,can,iterate,over,all,edges,of,this,vertex,with,the,specified,direction,and,emit,any,number,of,output,elements,including,none,param,edges,function,the,group,reduce,function,to,apply,to,the,neighboring,edges,of,each,vertex,param,direction,the,edge,direction,in,out,all,param,t,the,output,type,return,a,data,set,containing,elements,of,type,t,throws,illegal,argument,exception;public,t,data,set,t,group,reduce,on,edges,edges,function,k,ev,t,edges,function,edge,direction,direction,throws,illegal,argument,exception,switch,direction,case,in,return,edges,map,new,project,vertex,id,map,k,ev,1,with,forwarded,fields,f1,f0,group,by,0,reduce,group,new,apply,group,reduce,function,k,ev,t,edges,function,case,out,return,edges,map,new,project,vertex,id,map,k,ev,0,with,forwarded,fields,f0,group,by,0,reduce,group,new,apply,group,reduce,function,k,ev,t,edges,function,case,all,return,edges,flat,map,new,emit,one,edge,per,node,k,vv,ev,group,by,0,reduce,group,new,apply,group,reduce,function,k,ev,t,edges,function,default,throw,new,illegal,argument,exception,illegal,edge,direction
Graph -> public <T> DataSet<T> groupReduceOnEdges(EdgesFunction<K, EV, T> edgesFunction, 			EdgeDirection direction) throws IllegalArgumentException;1467306272;Groups by vertex and computes a GroupReduce transformation over the edge values of each vertex._The edgesFunction applied on the edges only has access to the vertex id (not the vertex value)_of the grouping vertex.__For each vertex, the edgesFunction can iterate over all edges of this vertex_with the specified direction, and emit any number of output elements, including none.__@param edgesFunction the group reduce function to apply to the neighboring edges of each vertex._@param direction the edge direction (in-, out-, all-)._@param <T> the output type_@return a DataSet containing elements of type T_@throws IllegalArgumentException;public <T> DataSet<T> groupReduceOnEdges(EdgesFunction<K, EV, T> edgesFunction,_			EdgeDirection direction) throws IllegalArgumentException {__		switch (direction) {_		case IN:_			return edges.map(new ProjectVertexIdMap<K, EV>(1))_					.withForwardedFields("f1->f0")_					.groupBy(0).reduceGroup(new ApplyGroupReduceFunction<K, EV, T>(edgesFunction))__		case OUT:_			return edges.map(new ProjectVertexIdMap<K, EV>(0))_					.withForwardedFields("f0")_					.groupBy(0).reduceGroup(new ApplyGroupReduceFunction<K, EV, T>(edgesFunction))__		case ALL:_			return edges.flatMap(new EmitOneEdgePerNode<K, VV, EV>())_					.groupBy(0).reduceGroup(new ApplyGroupReduceFunction<K, EV, T>(edgesFunction))__		default:_			throw new IllegalArgumentException("Illegal edge direction")__		}_	};groups,by,vertex,and,computes,a,group,reduce,transformation,over,the,edge,values,of,each,vertex,the,edges,function,applied,on,the,edges,only,has,access,to,the,vertex,id,not,the,vertex,value,of,the,grouping,vertex,for,each,vertex,the,edges,function,can,iterate,over,all,edges,of,this,vertex,with,the,specified,direction,and,emit,any,number,of,output,elements,including,none,param,edges,function,the,group,reduce,function,to,apply,to,the,neighboring,edges,of,each,vertex,param,direction,the,edge,direction,in,out,all,param,t,the,output,type,return,a,data,set,containing,elements,of,type,t,throws,illegal,argument,exception;public,t,data,set,t,group,reduce,on,edges,edges,function,k,ev,t,edges,function,edge,direction,direction,throws,illegal,argument,exception,switch,direction,case,in,return,edges,map,new,project,vertex,id,map,k,ev,1,with,forwarded,fields,f1,f0,group,by,0,reduce,group,new,apply,group,reduce,function,k,ev,t,edges,function,case,out,return,edges,map,new,project,vertex,id,map,k,ev,0,with,forwarded,fields,f0,group,by,0,reduce,group,new,apply,group,reduce,function,k,ev,t,edges,function,case,all,return,edges,flat,map,new,emit,one,edge,per,node,k,vv,ev,group,by,0,reduce,group,new,apply,group,reduce,function,k,ev,t,edges,function,default,throw,new,illegal,argument,exception,illegal,edge,direction
Graph -> public <T> DataSet<T> groupReduceOnEdges(EdgesFunction<K, EV, T> edgesFunction, 			EdgeDirection direction) throws IllegalArgumentException;1470042815;Groups by vertex and computes a GroupReduce transformation over the edge values of each vertex._The edgesFunction applied on the edges only has access to the vertex id (not the vertex value)_of the grouping vertex.__For each vertex, the edgesFunction can iterate over all edges of this vertex_with the specified direction, and emit any number of output elements, including none.__@param edgesFunction the group reduce function to apply to the neighboring edges of each vertex._@param direction the edge direction (in-, out-, all-)._@param <T> the output type_@return a DataSet containing elements of type T_@throws IllegalArgumentException;public <T> DataSet<T> groupReduceOnEdges(EdgesFunction<K, EV, T> edgesFunction,_			EdgeDirection direction) throws IllegalArgumentException {__		switch (direction) {_		case IN:_			return edges.map(new ProjectVertexIdMap<K, EV>(1))_					.withForwardedFields("f1->f0")_					.groupBy(0).reduceGroup(new ApplyGroupReduceFunction<K, EV, T>(edgesFunction))__		case OUT:_			return edges.map(new ProjectVertexIdMap<K, EV>(0))_					.withForwardedFields("f0")_					.groupBy(0).reduceGroup(new ApplyGroupReduceFunction<K, EV, T>(edgesFunction))__		case ALL:_			return edges.flatMap(new EmitOneEdgePerNode<K, VV, EV>())_					.groupBy(0).reduceGroup(new ApplyGroupReduceFunction<K, EV, T>(edgesFunction))__		default:_			throw new IllegalArgumentException("Illegal edge direction")__		}_	};groups,by,vertex,and,computes,a,group,reduce,transformation,over,the,edge,values,of,each,vertex,the,edges,function,applied,on,the,edges,only,has,access,to,the,vertex,id,not,the,vertex,value,of,the,grouping,vertex,for,each,vertex,the,edges,function,can,iterate,over,all,edges,of,this,vertex,with,the,specified,direction,and,emit,any,number,of,output,elements,including,none,param,edges,function,the,group,reduce,function,to,apply,to,the,neighboring,edges,of,each,vertex,param,direction,the,edge,direction,in,out,all,param,t,the,output,type,return,a,data,set,containing,elements,of,type,t,throws,illegal,argument,exception;public,t,data,set,t,group,reduce,on,edges,edges,function,k,ev,t,edges,function,edge,direction,direction,throws,illegal,argument,exception,switch,direction,case,in,return,edges,map,new,project,vertex,id,map,k,ev,1,with,forwarded,fields,f1,f0,group,by,0,reduce,group,new,apply,group,reduce,function,k,ev,t,edges,function,case,out,return,edges,map,new,project,vertex,id,map,k,ev,0,with,forwarded,fields,f0,group,by,0,reduce,group,new,apply,group,reduce,function,k,ev,t,edges,function,case,all,return,edges,flat,map,new,emit,one,edge,per,node,k,vv,ev,group,by,0,reduce,group,new,apply,group,reduce,function,k,ev,t,edges,function,default,throw,new,illegal,argument,exception,illegal,edge,direction
Graph -> public <T> DataSet<T> groupReduceOnEdges(EdgesFunction<K, EV, T> edgesFunction, 			EdgeDirection direction) throws IllegalArgumentException;1475684776;Groups by vertex and computes a GroupReduce transformation over the edge values of each vertex._The edgesFunction applied on the edges only has access to the vertex id (not the vertex value)_of the grouping vertex.__For each vertex, the edgesFunction can iterate over all edges of this vertex_with the specified direction, and emit any number of output elements, including none.__@param edgesFunction the group reduce function to apply to the neighboring edges of each vertex._@param direction the edge direction (in-, out-, all-)._@param <T> the output type_@return a DataSet containing elements of type T_@throws IllegalArgumentException;public <T> DataSet<T> groupReduceOnEdges(EdgesFunction<K, EV, T> edgesFunction,_			EdgeDirection direction) throws IllegalArgumentException {__		switch (direction) {_		case IN:_			return edges.map(new ProjectVertexIdMap<K, EV>(1))_					.withForwardedFields("f1->f0")_					.groupBy(0).reduceGroup(new ApplyGroupReduceFunction<>(edgesFunction))__		case OUT:_			return edges.map(new ProjectVertexIdMap<K, EV>(0))_					.withForwardedFields("f0")_					.groupBy(0).reduceGroup(new ApplyGroupReduceFunction<>(edgesFunction))__		case ALL:_			return edges.flatMap(new EmitOneEdgePerNode<K, VV, EV>())_					.groupBy(0).reduceGroup(new ApplyGroupReduceFunction<>(edgesFunction))__		default:_			throw new IllegalArgumentException("Illegal edge direction")__		}_	};groups,by,vertex,and,computes,a,group,reduce,transformation,over,the,edge,values,of,each,vertex,the,edges,function,applied,on,the,edges,only,has,access,to,the,vertex,id,not,the,vertex,value,of,the,grouping,vertex,for,each,vertex,the,edges,function,can,iterate,over,all,edges,of,this,vertex,with,the,specified,direction,and,emit,any,number,of,output,elements,including,none,param,edges,function,the,group,reduce,function,to,apply,to,the,neighboring,edges,of,each,vertex,param,direction,the,edge,direction,in,out,all,param,t,the,output,type,return,a,data,set,containing,elements,of,type,t,throws,illegal,argument,exception;public,t,data,set,t,group,reduce,on,edges,edges,function,k,ev,t,edges,function,edge,direction,direction,throws,illegal,argument,exception,switch,direction,case,in,return,edges,map,new,project,vertex,id,map,k,ev,1,with,forwarded,fields,f1,f0,group,by,0,reduce,group,new,apply,group,reduce,function,edges,function,case,out,return,edges,map,new,project,vertex,id,map,k,ev,0,with,forwarded,fields,f0,group,by,0,reduce,group,new,apply,group,reduce,function,edges,function,case,all,return,edges,flat,map,new,emit,one,edge,per,node,k,vv,ev,group,by,0,reduce,group,new,apply,group,reduce,function,edges,function,default,throw,new,illegal,argument,exception,illegal,edge,direction
Graph -> public <T> DataSet<T> groupReduceOnEdges(EdgesFunction<K, EV, T> edgesFunction, 			EdgeDirection direction) throws IllegalArgumentException;1475685606;Groups by vertex and computes a GroupReduce transformation over the edge values of each vertex._The edgesFunction applied on the edges only has access to the vertex id (not the vertex value)_of the grouping vertex.__For each vertex, the edgesFunction can iterate over all edges of this vertex_with the specified direction, and emit any number of output elements, including none.__@param edgesFunction the group reduce function to apply to the neighboring edges of each vertex._@param direction the edge direction (in-, out-, all-)._@param <T> the output type_@return a DataSet containing elements of type T_@throws IllegalArgumentException;public <T> DataSet<T> groupReduceOnEdges(EdgesFunction<K, EV, T> edgesFunction,_			EdgeDirection direction) throws IllegalArgumentException {__		switch (direction) {_		case IN:_			return edges.map(new ProjectVertexIdMap<K, EV>(1))_					.withForwardedFields("f1->f0")_					.groupBy(0).reduceGroup(new ApplyGroupReduceFunction<>(edgesFunction))__		case OUT:_			return edges.map(new ProjectVertexIdMap<K, EV>(0))_					.withForwardedFields("f0")_					.groupBy(0).reduceGroup(new ApplyGroupReduceFunction<>(edgesFunction))__		case ALL:_			return edges.flatMap(new EmitOneEdgePerNode<K, VV, EV>())_					.groupBy(0).reduceGroup(new ApplyGroupReduceFunction<>(edgesFunction))__		default:_			throw new IllegalArgumentException("Illegal edge direction")__		}_	};groups,by,vertex,and,computes,a,group,reduce,transformation,over,the,edge,values,of,each,vertex,the,edges,function,applied,on,the,edges,only,has,access,to,the,vertex,id,not,the,vertex,value,of,the,grouping,vertex,for,each,vertex,the,edges,function,can,iterate,over,all,edges,of,this,vertex,with,the,specified,direction,and,emit,any,number,of,output,elements,including,none,param,edges,function,the,group,reduce,function,to,apply,to,the,neighboring,edges,of,each,vertex,param,direction,the,edge,direction,in,out,all,param,t,the,output,type,return,a,data,set,containing,elements,of,type,t,throws,illegal,argument,exception;public,t,data,set,t,group,reduce,on,edges,edges,function,k,ev,t,edges,function,edge,direction,direction,throws,illegal,argument,exception,switch,direction,case,in,return,edges,map,new,project,vertex,id,map,k,ev,1,with,forwarded,fields,f1,f0,group,by,0,reduce,group,new,apply,group,reduce,function,edges,function,case,out,return,edges,map,new,project,vertex,id,map,k,ev,0,with,forwarded,fields,f0,group,by,0,reduce,group,new,apply,group,reduce,function,edges,function,case,all,return,edges,flat,map,new,emit,one,edge,per,node,k,vv,ev,group,by,0,reduce,group,new,apply,group,reduce,function,edges,function,default,throw,new,illegal,argument,exception,illegal,edge,direction
Graph -> public <T> DataSet<T> groupReduceOnEdges(EdgesFunction<K, EV, T> edgesFunction, 			EdgeDirection direction) throws IllegalArgumentException;1481745825;Groups by vertex and computes a GroupReduce transformation over the edge values of each vertex._The edgesFunction applied on the edges only has access to the vertex id (not the vertex value)_of the grouping vertex.__For each vertex, the edgesFunction can iterate over all edges of this vertex_with the specified direction, and emit any number of output elements, including none.__@param edgesFunction the group reduce function to apply to the neighboring edges of each vertex._@param direction the edge direction (in-, out-, all-)._@param <T> the output type_@return a DataSet containing elements of type T_@throws IllegalArgumentException;public <T> DataSet<T> groupReduceOnEdges(EdgesFunction<K, EV, T> edgesFunction,_			EdgeDirection direction) throws IllegalArgumentException {__		switch (direction) {_		case IN:_			return edges.map(new ProjectVertexIdMap<K, EV>(1))_					.withForwardedFields("f1->f0").name("Vertex ID")_					.groupBy(0).reduceGroup(new ApplyGroupReduceFunction<>(edgesFunction))_						.name("GroupReduce on in-edges")__		case OUT:_			return edges.map(new ProjectVertexIdMap<K, EV>(0))_					.withForwardedFields("f0").name("Vertex ID")_					.groupBy(0).reduceGroup(new ApplyGroupReduceFunction<>(edgesFunction))_						.name("GroupReduce on out-edges")__		case ALL:_			return edges.flatMap(new EmitOneEdgePerNode<K, VV, EV>()).name("Emit edge")_				.groupBy(0).reduceGroup(new ApplyGroupReduceFunction<>(edgesFunction))_					.name("GroupReduce on in- and out-edges")__		default:_			throw new IllegalArgumentException("Illegal edge direction")__		}_	};groups,by,vertex,and,computes,a,group,reduce,transformation,over,the,edge,values,of,each,vertex,the,edges,function,applied,on,the,edges,only,has,access,to,the,vertex,id,not,the,vertex,value,of,the,grouping,vertex,for,each,vertex,the,edges,function,can,iterate,over,all,edges,of,this,vertex,with,the,specified,direction,and,emit,any,number,of,output,elements,including,none,param,edges,function,the,group,reduce,function,to,apply,to,the,neighboring,edges,of,each,vertex,param,direction,the,edge,direction,in,out,all,param,t,the,output,type,return,a,data,set,containing,elements,of,type,t,throws,illegal,argument,exception;public,t,data,set,t,group,reduce,on,edges,edges,function,k,ev,t,edges,function,edge,direction,direction,throws,illegal,argument,exception,switch,direction,case,in,return,edges,map,new,project,vertex,id,map,k,ev,1,with,forwarded,fields,f1,f0,name,vertex,id,group,by,0,reduce,group,new,apply,group,reduce,function,edges,function,name,group,reduce,on,in,edges,case,out,return,edges,map,new,project,vertex,id,map,k,ev,0,with,forwarded,fields,f0,name,vertex,id,group,by,0,reduce,group,new,apply,group,reduce,function,edges,function,name,group,reduce,on,out,edges,case,all,return,edges,flat,map,new,emit,one,edge,per,node,k,vv,ev,name,emit,edge,group,by,0,reduce,group,new,apply,group,reduce,function,edges,function,name,group,reduce,on,in,and,out,edges,default,throw,new,illegal,argument,exception,illegal,edge,direction
Graph -> public <T> DataSet<T> groupReduceOnEdges(EdgesFunction<K, EV, T> edgesFunction, 			EdgeDirection direction) throws IllegalArgumentException;1481881009;Groups by vertex and computes a GroupReduce transformation over the edge values of each vertex._The edgesFunction applied on the edges only has access to the vertex id (not the vertex value)_of the grouping vertex.__For each vertex, the edgesFunction can iterate over all edges of this vertex_with the specified direction, and emit any number of output elements, including none.__@param edgesFunction the group reduce function to apply to the neighboring edges of each vertex._@param direction the edge direction (in-, out-, all-)._@param <T> the output type_@return a DataSet containing elements of type T_@throws IllegalArgumentException;public <T> DataSet<T> groupReduceOnEdges(EdgesFunction<K, EV, T> edgesFunction,_			EdgeDirection direction) throws IllegalArgumentException {__		TypeInformation<K> keyType = ((TupleTypeInfo<?>) vertices.getType()).getTypeAt(0)__		TypeInformation<EV> edgeValueType = ((TupleTypeInfo<?>) edges.getType()).getTypeAt(2)__		TypeInformation<T> returnType = TypeExtractor.createTypeInfo(EdgesFunction.class, edgesFunction.getClass(), 2,_			keyType, edgeValueType)___		return groupReduceOnEdges(edgesFunction, direction, returnType)__	};groups,by,vertex,and,computes,a,group,reduce,transformation,over,the,edge,values,of,each,vertex,the,edges,function,applied,on,the,edges,only,has,access,to,the,vertex,id,not,the,vertex,value,of,the,grouping,vertex,for,each,vertex,the,edges,function,can,iterate,over,all,edges,of,this,vertex,with,the,specified,direction,and,emit,any,number,of,output,elements,including,none,param,edges,function,the,group,reduce,function,to,apply,to,the,neighboring,edges,of,each,vertex,param,direction,the,edge,direction,in,out,all,param,t,the,output,type,return,a,data,set,containing,elements,of,type,t,throws,illegal,argument,exception;public,t,data,set,t,group,reduce,on,edges,edges,function,k,ev,t,edges,function,edge,direction,direction,throws,illegal,argument,exception,type,information,k,key,type,tuple,type,info,vertices,get,type,get,type,at,0,type,information,ev,edge,value,type,tuple,type,info,edges,get,type,get,type,at,2,type,information,t,return,type,type,extractor,create,type,info,edges,function,class,edges,function,get,class,2,key,type,edge,value,type,return,group,reduce,on,edges,edges,function,direction,return,type
Graph -> public <T> DataSet<T> groupReduceOnEdges(EdgesFunction<K, EV, T> edgesFunction, 			EdgeDirection direction) throws IllegalArgumentException;1484160227;Groups by vertex and computes a GroupReduce transformation over the edge values of each vertex._The edgesFunction applied on the edges only has access to the vertex id (not the vertex value)_of the grouping vertex.__For each vertex, the edgesFunction can iterate over all edges of this vertex_with the specified direction, and emit any number of output elements, including none.__@param edgesFunction the group reduce function to apply to the neighboring edges of each vertex._@param direction the edge direction (in-, out-, all-)._@param <T> the output type_@return a DataSet containing elements of type T_@throws IllegalArgumentException;public <T> DataSet<T> groupReduceOnEdges(EdgesFunction<K, EV, T> edgesFunction,_			EdgeDirection direction) throws IllegalArgumentException {__		TypeInformation<K> keyType = ((TupleTypeInfo<?>) vertices.getType()).getTypeAt(0)__		TypeInformation<EV> edgeValueType = ((TupleTypeInfo<?>) edges.getType()).getTypeAt(2)__		TypeInformation<T> returnType = TypeExtractor.createTypeInfo(EdgesFunction.class, edgesFunction.getClass(), 2,_			keyType, edgeValueType)___		return groupReduceOnEdges(edgesFunction, direction, returnType)__	};groups,by,vertex,and,computes,a,group,reduce,transformation,over,the,edge,values,of,each,vertex,the,edges,function,applied,on,the,edges,only,has,access,to,the,vertex,id,not,the,vertex,value,of,the,grouping,vertex,for,each,vertex,the,edges,function,can,iterate,over,all,edges,of,this,vertex,with,the,specified,direction,and,emit,any,number,of,output,elements,including,none,param,edges,function,the,group,reduce,function,to,apply,to,the,neighboring,edges,of,each,vertex,param,direction,the,edge,direction,in,out,all,param,t,the,output,type,return,a,data,set,containing,elements,of,type,t,throws,illegal,argument,exception;public,t,data,set,t,group,reduce,on,edges,edges,function,k,ev,t,edges,function,edge,direction,direction,throws,illegal,argument,exception,type,information,k,key,type,tuple,type,info,vertices,get,type,get,type,at,0,type,information,ev,edge,value,type,tuple,type,info,edges,get,type,get,type,at,2,type,information,t,return,type,type,extractor,create,type,info,edges,function,class,edges,function,get,class,2,key,type,edge,value,type,return,group,reduce,on,edges,edges,function,direction,return,type
Graph -> public <T> DataSet<T> groupReduceOnEdges(EdgesFunction<K, EV, T> edgesFunction, 			EdgeDirection direction) throws IllegalArgumentException;1484685504;Groups by vertex and computes a GroupReduce transformation over the edge values of each vertex._The edgesFunction applied on the edges only has access to the vertex id (not the vertex value)_of the grouping vertex.__For each vertex, the edgesFunction can iterate over all edges of this vertex_with the specified direction, and emit any number of output elements, including none.__@param edgesFunction the group reduce function to apply to the neighboring edges of each vertex._@param direction the edge direction (in-, out-, all-)._@param <T> the output type_@return a DataSet containing elements of type T_@throws IllegalArgumentException;public <T> DataSet<T> groupReduceOnEdges(EdgesFunction<K, EV, T> edgesFunction,_			EdgeDirection direction) throws IllegalArgumentException {__		TypeInformation<K> keyType = ((TupleTypeInfo<?>) vertices.getType()).getTypeAt(0)__		TypeInformation<EV> edgeValueType = ((TupleTypeInfo<?>) edges.getType()).getTypeAt(2)__		TypeInformation<T> returnType = TypeExtractor.createTypeInfo(EdgesFunction.class, edgesFunction.getClass(), 2,_			keyType, edgeValueType)___		return groupReduceOnEdges(edgesFunction, direction, returnType)__	};groups,by,vertex,and,computes,a,group,reduce,transformation,over,the,edge,values,of,each,vertex,the,edges,function,applied,on,the,edges,only,has,access,to,the,vertex,id,not,the,vertex,value,of,the,grouping,vertex,for,each,vertex,the,edges,function,can,iterate,over,all,edges,of,this,vertex,with,the,specified,direction,and,emit,any,number,of,output,elements,including,none,param,edges,function,the,group,reduce,function,to,apply,to,the,neighboring,edges,of,each,vertex,param,direction,the,edge,direction,in,out,all,param,t,the,output,type,return,a,data,set,containing,elements,of,type,t,throws,illegal,argument,exception;public,t,data,set,t,group,reduce,on,edges,edges,function,k,ev,t,edges,function,edge,direction,direction,throws,illegal,argument,exception,type,information,k,key,type,tuple,type,info,vertices,get,type,get,type,at,0,type,information,ev,edge,value,type,tuple,type,info,edges,get,type,get,type,at,2,type,information,t,return,type,type,extractor,create,type,info,edges,function,class,edges,function,get,class,2,key,type,edge,value,type,return,group,reduce,on,edges,edges,function,direction,return,type
Graph -> public <T> DataSet<T> groupReduceOnEdges(EdgesFunction<K, EV, T> edgesFunction, 			EdgeDirection direction) throws IllegalArgumentException;1489068942;Groups by vertex and computes a GroupReduce transformation over the edge values of each vertex._The edgesFunction applied on the edges only has access to the vertex id (not the vertex value)_of the grouping vertex.__For each vertex, the edgesFunction can iterate over all edges of this vertex_with the specified direction, and emit any number of output elements, including none.__@param edgesFunction the group reduce function to apply to the neighboring edges of each vertex._@param direction the edge direction (in-, out-, all-)._@param <T> the output type_@return a DataSet containing elements of type T_@throws IllegalArgumentException;public <T> DataSet<T> groupReduceOnEdges(EdgesFunction<K, EV, T> edgesFunction,_			EdgeDirection direction) throws IllegalArgumentException {__		TypeInformation<K> keyType = ((TupleTypeInfo<?>) vertices.getType()).getTypeAt(0)__		TypeInformation<EV> edgeValueType = ((TupleTypeInfo<?>) edges.getType()).getTypeAt(2)__		TypeInformation<T> returnType = TypeExtractor.createTypeInfo(EdgesFunction.class, edgesFunction.getClass(), 2,_			keyType, edgeValueType)___		return groupReduceOnEdges(edgesFunction, direction, returnType)__	};groups,by,vertex,and,computes,a,group,reduce,transformation,over,the,edge,values,of,each,vertex,the,edges,function,applied,on,the,edges,only,has,access,to,the,vertex,id,not,the,vertex,value,of,the,grouping,vertex,for,each,vertex,the,edges,function,can,iterate,over,all,edges,of,this,vertex,with,the,specified,direction,and,emit,any,number,of,output,elements,including,none,param,edges,function,the,group,reduce,function,to,apply,to,the,neighboring,edges,of,each,vertex,param,direction,the,edge,direction,in,out,all,param,t,the,output,type,return,a,data,set,containing,elements,of,type,t,throws,illegal,argument,exception;public,t,data,set,t,group,reduce,on,edges,edges,function,k,ev,t,edges,function,edge,direction,direction,throws,illegal,argument,exception,type,information,k,key,type,tuple,type,info,vertices,get,type,get,type,at,0,type,information,ev,edge,value,type,tuple,type,info,edges,get,type,get,type,at,2,type,information,t,return,type,type,extractor,create,type,info,edges,function,class,edges,function,get,class,2,key,type,edge,value,type,return,group,reduce,on,edges,edges,function,direction,return,type
Graph -> public <T> DataSet<T> groupReduceOnEdges(EdgesFunction<K, EV, T> edgesFunction, 			EdgeDirection direction) throws IllegalArgumentException;1490973446;Groups by vertex and computes a GroupReduce transformation over the edge values of each vertex._The edgesFunction applied on the edges only has access to the vertex id (not the vertex value)_of the grouping vertex.__For each vertex, the edgesFunction can iterate over all edges of this vertex_with the specified direction, and emit any number of output elements, including none.__@param edgesFunction the group reduce function to apply to the neighboring edges of each vertex._@param direction the edge direction (in-, out-, all-)._@param <T> the output type_@return a DataSet containing elements of type T_@throws IllegalArgumentException;public <T> DataSet<T> groupReduceOnEdges(EdgesFunction<K, EV, T> edgesFunction,_			EdgeDirection direction) throws IllegalArgumentException {__		TypeInformation<K> keyType = ((TupleTypeInfo<?>) vertices.getType()).getTypeAt(0)__		TypeInformation<EV> edgeValueType = ((TupleTypeInfo<?>) edges.getType()).getTypeAt(2)__		TypeInformation<T> returnType = TypeExtractor.createTypeInfo(EdgesFunction.class, edgesFunction.getClass(), 2,_			keyType, edgeValueType)___		return groupReduceOnEdges(edgesFunction, direction, returnType)__	};groups,by,vertex,and,computes,a,group,reduce,transformation,over,the,edge,values,of,each,vertex,the,edges,function,applied,on,the,edges,only,has,access,to,the,vertex,id,not,the,vertex,value,of,the,grouping,vertex,for,each,vertex,the,edges,function,can,iterate,over,all,edges,of,this,vertex,with,the,specified,direction,and,emit,any,number,of,output,elements,including,none,param,edges,function,the,group,reduce,function,to,apply,to,the,neighboring,edges,of,each,vertex,param,direction,the,edge,direction,in,out,all,param,t,the,output,type,return,a,data,set,containing,elements,of,type,t,throws,illegal,argument,exception;public,t,data,set,t,group,reduce,on,edges,edges,function,k,ev,t,edges,function,edge,direction,direction,throws,illegal,argument,exception,type,information,k,key,type,tuple,type,info,vertices,get,type,get,type,at,0,type,information,ev,edge,value,type,tuple,type,info,edges,get,type,get,type,at,2,type,information,t,return,type,type,extractor,create,type,info,edges,function,class,edges,function,get,class,2,key,type,edge,value,type,return,group,reduce,on,edges,edges,function,direction,return,type
Graph -> public <T> DataSet<T> groupReduceOnEdges(EdgesFunction<K, EV, T> edgesFunction, 			EdgeDirection direction) throws IllegalArgumentException;1495819075;Groups by vertex and computes a GroupReduce transformation over the edge values of each vertex._The edgesFunction applied on the edges only has access to the vertex id (not the vertex value)_of the grouping vertex.__<p>For each vertex, the edgesFunction can iterate over all edges of this vertex_with the specified direction, and emit any number of output elements, including none.__@param edgesFunction the group reduce function to apply to the neighboring edges of each vertex._@param direction the edge direction (in-, out-, all-)._@param <T> the output type_@return a DataSet containing elements of type T_@throws IllegalArgumentException;public <T> DataSet<T> groupReduceOnEdges(EdgesFunction<K, EV, T> edgesFunction,_			EdgeDirection direction) throws IllegalArgumentException {__		TypeInformation<K> keyType = ((TupleTypeInfo<?>) vertices.getType()).getTypeAt(0)__		TypeInformation<EV> edgeValueType = ((TupleTypeInfo<?>) edges.getType()).getTypeAt(2)__		TypeInformation<T> returnType = TypeExtractor.createTypeInfo(EdgesFunction.class, edgesFunction.getClass(), 2,_			keyType, edgeValueType)___		return groupReduceOnEdges(edgesFunction, direction, returnType)__	};groups,by,vertex,and,computes,a,group,reduce,transformation,over,the,edge,values,of,each,vertex,the,edges,function,applied,on,the,edges,only,has,access,to,the,vertex,id,not,the,vertex,value,of,the,grouping,vertex,p,for,each,vertex,the,edges,function,can,iterate,over,all,edges,of,this,vertex,with,the,specified,direction,and,emit,any,number,of,output,elements,including,none,param,edges,function,the,group,reduce,function,to,apply,to,the,neighboring,edges,of,each,vertex,param,direction,the,edge,direction,in,out,all,param,t,the,output,type,return,a,data,set,containing,elements,of,type,t,throws,illegal,argument,exception;public,t,data,set,t,group,reduce,on,edges,edges,function,k,ev,t,edges,function,edge,direction,direction,throws,illegal,argument,exception,type,information,k,key,type,tuple,type,info,vertices,get,type,get,type,at,0,type,information,ev,edge,value,type,tuple,type,info,edges,get,type,get,type,at,2,type,information,t,return,type,type,extractor,create,type,info,edges,function,class,edges,function,get,class,2,key,type,edge,value,type,return,group,reduce,on,edges,edges,function,direction,return,type
Graph -> public <T> DataSet<T> groupReduceOnEdges(EdgesFunction<K, EV, T> edgesFunction, 			EdgeDirection direction) throws IllegalArgumentException;1502111816;Groups by vertex and computes a GroupReduce transformation over the edge values of each vertex._The edgesFunction applied on the edges only has access to the vertex id (not the vertex value)_of the grouping vertex.__<p>For each vertex, the edgesFunction can iterate over all edges of this vertex_with the specified direction, and emit any number of output elements, including none.__@param edgesFunction the group reduce function to apply to the neighboring edges of each vertex._@param direction the edge direction (in-, out-, all-)._@param <T> the output type_@return a DataSet containing elements of type T_@throws IllegalArgumentException;public <T> DataSet<T> groupReduceOnEdges(EdgesFunction<K, EV, T> edgesFunction,_			EdgeDirection direction) throws IllegalArgumentException {__		TypeInformation<K> keyType = ((TupleTypeInfo<?>) vertices.getType()).getTypeAt(0)__		TypeInformation<EV> edgeValueType = ((TupleTypeInfo<?>) edges.getType()).getTypeAt(2)__		TypeInformation<T> returnType = TypeExtractor.createTypeInfo(EdgesFunction.class, edgesFunction.getClass(), 2,_			keyType, edgeValueType)___		return groupReduceOnEdges(edgesFunction, direction, returnType)__	};groups,by,vertex,and,computes,a,group,reduce,transformation,over,the,edge,values,of,each,vertex,the,edges,function,applied,on,the,edges,only,has,access,to,the,vertex,id,not,the,vertex,value,of,the,grouping,vertex,p,for,each,vertex,the,edges,function,can,iterate,over,all,edges,of,this,vertex,with,the,specified,direction,and,emit,any,number,of,output,elements,including,none,param,edges,function,the,group,reduce,function,to,apply,to,the,neighboring,edges,of,each,vertex,param,direction,the,edge,direction,in,out,all,param,t,the,output,type,return,a,data,set,containing,elements,of,type,t,throws,illegal,argument,exception;public,t,data,set,t,group,reduce,on,edges,edges,function,k,ev,t,edges,function,edge,direction,direction,throws,illegal,argument,exception,type,information,k,key,type,tuple,type,info,vertices,get,type,get,type,at,0,type,information,ev,edge,value,type,tuple,type,info,edges,get,type,get,type,at,2,type,information,t,return,type,type,extractor,create,type,info,edges,function,class,edges,function,get,class,2,key,type,edge,value,type,return,group,reduce,on,edges,edges,function,direction,return,type
Graph -> public <NV> Graph<K, NV, EV> mapVertices(final MapFunction<Vertex<K, VV>, NV> mapper, TypeInformation<Vertex<K, NV>> returnType);1484685504;Apply a function to the attribute of each vertex in the graph.__@param mapper the map function to apply._@param returnType the explicit return type._@return a new graph;public <NV> Graph<K, NV, EV> mapVertices(final MapFunction<Vertex<K, VV>, NV> mapper, TypeInformation<Vertex<K, NV>> returnType) {_		DataSet<Vertex<K, NV>> mappedVertices = vertices.map(_				new MapFunction<Vertex<K, VV>, Vertex<K, NV>>() {_					private Vertex<K, NV> output = new Vertex<>()___					public Vertex<K, NV> map(Vertex<K, VV> value) throws Exception {_						output.f0 = value.f0__						output.f1 = mapper.map(value)__						return output__					}_				})_				.returns(returnType)_				.withForwardedFields("f0")_					.name("Map vertices")___		return new Graph<>(mappedVertices, this.edges, this.context)__	};apply,a,function,to,the,attribute,of,each,vertex,in,the,graph,param,mapper,the,map,function,to,apply,param,return,type,the,explicit,return,type,return,a,new,graph;public,nv,graph,k,nv,ev,map,vertices,final,map,function,vertex,k,vv,nv,mapper,type,information,vertex,k,nv,return,type,data,set,vertex,k,nv,mapped,vertices,vertices,map,new,map,function,vertex,k,vv,vertex,k,nv,private,vertex,k,nv,output,new,vertex,public,vertex,k,nv,map,vertex,k,vv,value,throws,exception,output,f0,value,f0,output,f1,mapper,map,value,return,output,returns,return,type,with,forwarded,fields,f0,name,map,vertices,return,new,graph,mapped,vertices,this,edges,this,context
Graph -> public <NV> Graph<K, NV, EV> mapVertices(final MapFunction<Vertex<K, VV>, NV> mapper, TypeInformation<Vertex<K, NV>> returnType);1489068942;Apply a function to the attribute of each vertex in the graph.__@param mapper the map function to apply._@param returnType the explicit return type._@return a new graph;public <NV> Graph<K, NV, EV> mapVertices(final MapFunction<Vertex<K, VV>, NV> mapper, TypeInformation<Vertex<K, NV>> returnType) {_		DataSet<Vertex<K, NV>> mappedVertices = vertices.map(_				new MapFunction<Vertex<K, VV>, Vertex<K, NV>>() {_					private Vertex<K, NV> output = new Vertex<>()___					public Vertex<K, NV> map(Vertex<K, VV> value) throws Exception {_						output.f0 = value.f0__						output.f1 = mapper.map(value)__						return output__					}_				})_				.returns(returnType)_				.withForwardedFields("f0")_					.name("Map vertices")___		return new Graph<>(mappedVertices, this.edges, this.context)__	};apply,a,function,to,the,attribute,of,each,vertex,in,the,graph,param,mapper,the,map,function,to,apply,param,return,type,the,explicit,return,type,return,a,new,graph;public,nv,graph,k,nv,ev,map,vertices,final,map,function,vertex,k,vv,nv,mapper,type,information,vertex,k,nv,return,type,data,set,vertex,k,nv,mapped,vertices,vertices,map,new,map,function,vertex,k,vv,vertex,k,nv,private,vertex,k,nv,output,new,vertex,public,vertex,k,nv,map,vertex,k,vv,value,throws,exception,output,f0,value,f0,output,f1,mapper,map,value,return,output,returns,return,type,with,forwarded,fields,f0,name,map,vertices,return,new,graph,mapped,vertices,this,edges,this,context
Graph -> public <NV> Graph<K, NV, EV> mapVertices(final MapFunction<Vertex<K, VV>, NV> mapper, TypeInformation<Vertex<K, NV>> returnType);1490973446;Apply a function to the attribute of each vertex in the graph.__@param mapper the map function to apply._@param returnType the explicit return type._@return a new graph;public <NV> Graph<K, NV, EV> mapVertices(final MapFunction<Vertex<K, VV>, NV> mapper, TypeInformation<Vertex<K, NV>> returnType) {_		DataSet<Vertex<K, NV>> mappedVertices = vertices.map(_				new MapFunction<Vertex<K, VV>, Vertex<K, NV>>() {_					private Vertex<K, NV> output = new Vertex<>()___					public Vertex<K, NV> map(Vertex<K, VV> value) throws Exception {_						output.f0 = value.f0__						output.f1 = mapper.map(value)__						return output__					}_				})_				.returns(returnType)_				.withForwardedFields("f0")_					.name("Map vertices")___		return new Graph<>(mappedVertices, this.edges, this.context)__	};apply,a,function,to,the,attribute,of,each,vertex,in,the,graph,param,mapper,the,map,function,to,apply,param,return,type,the,explicit,return,type,return,a,new,graph;public,nv,graph,k,nv,ev,map,vertices,final,map,function,vertex,k,vv,nv,mapper,type,information,vertex,k,nv,return,type,data,set,vertex,k,nv,mapped,vertices,vertices,map,new,map,function,vertex,k,vv,vertex,k,nv,private,vertex,k,nv,output,new,vertex,public,vertex,k,nv,map,vertex,k,vv,value,throws,exception,output,f0,value,f0,output,f1,mapper,map,value,return,output,returns,return,type,with,forwarded,fields,f0,name,map,vertices,return,new,graph,mapped,vertices,this,edges,this,context
Graph -> public <NV> Graph<K, NV, EV> mapVertices(final MapFunction<Vertex<K, VV>, NV> mapper, TypeInformation<Vertex<K, NV>> returnType);1495819075;Apply a function to the attribute of each vertex in the graph.__@param mapper the map function to apply._@param returnType the explicit return type._@return a new graph;public <NV> Graph<K, NV, EV> mapVertices(final MapFunction<Vertex<K, VV>, NV> mapper, TypeInformation<Vertex<K, NV>> returnType) {_		DataSet<Vertex<K, NV>> mappedVertices = vertices.map(_				new MapFunction<Vertex<K, VV>, Vertex<K, NV>>() {_					private Vertex<K, NV> output = new Vertex<>()___					public Vertex<K, NV> map(Vertex<K, VV> value) throws Exception {_						output.f0 = value.f0__						output.f1 = mapper.map(value)__						return output__					}_				})_				.returns(returnType)_				.withForwardedFields("f0")_					.name("Map vertices")___		return new Graph<>(mappedVertices, this.edges, this.context)__	};apply,a,function,to,the,attribute,of,each,vertex,in,the,graph,param,mapper,the,map,function,to,apply,param,return,type,the,explicit,return,type,return,a,new,graph;public,nv,graph,k,nv,ev,map,vertices,final,map,function,vertex,k,vv,nv,mapper,type,information,vertex,k,nv,return,type,data,set,vertex,k,nv,mapped,vertices,vertices,map,new,map,function,vertex,k,vv,vertex,k,nv,private,vertex,k,nv,output,new,vertex,public,vertex,k,nv,map,vertex,k,vv,value,throws,exception,output,f0,value,f0,output,f1,mapper,map,value,return,output,returns,return,type,with,forwarded,fields,f0,name,map,vertices,return,new,graph,mapped,vertices,this,edges,this,context
Graph -> public <NV> Graph<K, NV, EV> mapVertices(final MapFunction<Vertex<K, VV>, NV> mapper, TypeInformation<Vertex<K, NV>> returnType);1502111816;Apply a function to the attribute of each vertex in the graph.__@param mapper the map function to apply._@param returnType the explicit return type._@return a new graph;public <NV> Graph<K, NV, EV> mapVertices(final MapFunction<Vertex<K, VV>, NV> mapper, TypeInformation<Vertex<K, NV>> returnType) {_		DataSet<Vertex<K, NV>> mappedVertices = vertices.map(_				new MapFunction<Vertex<K, VV>, Vertex<K, NV>>() {_					private Vertex<K, NV> output = new Vertex<>()___					public Vertex<K, NV> map(Vertex<K, VV> value) throws Exception {_						output.f0 = value.f0__						output.f1 = mapper.map(value)__						return output__					}_				})_				.returns(returnType)_				.withForwardedFields("f0")_					.name("Map vertices")___		return new Graph<>(mappedVertices, this.edges, this.context)__	};apply,a,function,to,the,attribute,of,each,vertex,in,the,graph,param,mapper,the,map,function,to,apply,param,return,type,the,explicit,return,type,return,a,new,graph;public,nv,graph,k,nv,ev,map,vertices,final,map,function,vertex,k,vv,nv,mapper,type,information,vertex,k,nv,return,type,data,set,vertex,k,nv,mapped,vertices,vertices,map,new,map,function,vertex,k,vv,vertex,k,nv,private,vertex,k,nv,output,new,vertex,public,vertex,k,nv,map,vertex,k,vv,value,throws,exception,output,f0,value,f0,output,f1,mapper,map,value,return,output,returns,return,type,with,forwarded,fields,f0,name,map,vertices,return,new,graph,mapped,vertices,this,edges,this,context
Graph -> private Graph(DataSet<Vertex<K, VV>> vertices, DataSet<Edge<K, EV>> edges, ExecutionEnvironment context);1444404795;Creates a graph from two DataSets: vertices and edges__@param vertices a DataSet of vertices._@param edges a DataSet of edges._@param context the flink execution environment.;private Graph(DataSet<Vertex<K, VV>> vertices, DataSet<Edge<K, EV>> edges, ExecutionEnvironment context) {_		this.vertices = vertices__		this.edges = edges__		this.context = context__	};creates,a,graph,from,two,data,sets,vertices,and,edges,param,vertices,a,data,set,of,vertices,param,edges,a,data,set,of,edges,param,context,the,flink,execution,environment;private,graph,data,set,vertex,k,vv,vertices,data,set,edge,k,ev,edges,execution,environment,context,this,vertices,vertices,this,edges,edges,this,context,context
Graph -> private Graph(DataSet<Vertex<K, VV>> vertices, DataSet<Edge<K, EV>> edges, ExecutionEnvironment context);1445261977;Creates a graph from two DataSets: vertices and edges__@param vertices a DataSet of vertices._@param edges a DataSet of edges._@param context the flink execution environment.;private Graph(DataSet<Vertex<K, VV>> vertices, DataSet<Edge<K, EV>> edges, ExecutionEnvironment context) {_		this.vertices = vertices__		this.edges = edges__		this.context = context__	};creates,a,graph,from,two,data,sets,vertices,and,edges,param,vertices,a,data,set,of,vertices,param,edges,a,data,set,of,edges,param,context,the,flink,execution,environment;private,graph,data,set,vertex,k,vv,vertices,data,set,edge,k,ev,edges,execution,environment,context,this,vertices,vertices,this,edges,edges,this,context,context
Graph -> private Graph(DataSet<Vertex<K, VV>> vertices, DataSet<Edge<K, EV>> edges, ExecutionEnvironment context);1445854323;Creates a graph from two DataSets: vertices and edges__@param vertices a DataSet of vertices._@param edges a DataSet of edges._@param context the flink execution environment.;private Graph(DataSet<Vertex<K, VV>> vertices, DataSet<Edge<K, EV>> edges, ExecutionEnvironment context) {_		this.vertices = vertices__		this.edges = edges__		this.context = context__	};creates,a,graph,from,two,data,sets,vertices,and,edges,param,vertices,a,data,set,of,vertices,param,edges,a,data,set,of,edges,param,context,the,flink,execution,environment;private,graph,data,set,vertex,k,vv,vertices,data,set,edge,k,ev,edges,execution,environment,context,this,vertices,vertices,this,edges,edges,this,context,context
Graph -> private Graph(DataSet<Vertex<K, VV>> vertices, DataSet<Edge<K, EV>> edges, ExecutionEnvironment context);1446112342;Creates a graph from two DataSets: vertices and edges__@param vertices a DataSet of vertices._@param edges a DataSet of edges._@param context the flink execution environment.;private Graph(DataSet<Vertex<K, VV>> vertices, DataSet<Edge<K, EV>> edges, ExecutionEnvironment context) {_		this.vertices = vertices__		this.edges = edges__		this.context = context__	};creates,a,graph,from,two,data,sets,vertices,and,edges,param,vertices,a,data,set,of,vertices,param,edges,a,data,set,of,edges,param,context,the,flink,execution,environment;private,graph,data,set,vertex,k,vv,vertices,data,set,edge,k,ev,edges,execution,environment,context,this,vertices,vertices,this,edges,edges,this,context,context
Graph -> private Graph(DataSet<Vertex<K, VV>> vertices, DataSet<Edge<K, EV>> edges, ExecutionEnvironment context);1447073368;Creates a graph from two DataSets: vertices and edges__@param vertices a DataSet of vertices._@param edges a DataSet of edges._@param context the flink execution environment.;private Graph(DataSet<Vertex<K, VV>> vertices, DataSet<Edge<K, EV>> edges, ExecutionEnvironment context) {_		this.vertices = vertices__		this.edges = edges__		this.context = context__	};creates,a,graph,from,two,data,sets,vertices,and,edges,param,vertices,a,data,set,of,vertices,param,edges,a,data,set,of,edges,param,context,the,flink,execution,environment;private,graph,data,set,vertex,k,vv,vertices,data,set,edge,k,ev,edges,execution,environment,context,this,vertices,vertices,this,edges,edges,this,context,context
Graph -> private Graph(DataSet<Vertex<K, VV>> vertices, DataSet<Edge<K, EV>> edges, ExecutionEnvironment context);1454404649;Creates a graph from two DataSets: vertices and edges__@param vertices a DataSet of vertices._@param edges a DataSet of edges._@param context the flink execution environment.;private Graph(DataSet<Vertex<K, VV>> vertices, DataSet<Edge<K, EV>> edges, ExecutionEnvironment context) {_		this.vertices = vertices__		this.edges = edges__		this.context = context__	};creates,a,graph,from,two,data,sets,vertices,and,edges,param,vertices,a,data,set,of,vertices,param,edges,a,data,set,of,edges,param,context,the,flink,execution,environment;private,graph,data,set,vertex,k,vv,vertices,data,set,edge,k,ev,edges,execution,environment,context,this,vertices,vertices,this,edges,edges,this,context,context
Graph -> private Graph(DataSet<Vertex<K, VV>> vertices, DataSet<Edge<K, EV>> edges, ExecutionEnvironment context);1458583829;Creates a graph from two DataSets: vertices and edges__@param vertices a DataSet of vertices._@param edges a DataSet of edges._@param context the flink execution environment.;private Graph(DataSet<Vertex<K, VV>> vertices, DataSet<Edge<K, EV>> edges, ExecutionEnvironment context) {_		this.vertices = vertices__		this.edges = edges__		this.context = context__	};creates,a,graph,from,two,data,sets,vertices,and,edges,param,vertices,a,data,set,of,vertices,param,edges,a,data,set,of,edges,param,context,the,flink,execution,environment;private,graph,data,set,vertex,k,vv,vertices,data,set,edge,k,ev,edges,execution,environment,context,this,vertices,vertices,this,edges,edges,this,context,context
Graph -> private Graph(DataSet<Vertex<K, VV>> vertices, DataSet<Edge<K, EV>> edges, ExecutionEnvironment context);1458583829;Creates a graph from two DataSets: vertices and edges__@param vertices a DataSet of vertices._@param edges a DataSet of edges._@param context the flink execution environment.;private Graph(DataSet<Vertex<K, VV>> vertices, DataSet<Edge<K, EV>> edges, ExecutionEnvironment context) {_		this.vertices = vertices__		this.edges = edges__		this.context = context__	};creates,a,graph,from,two,data,sets,vertices,and,edges,param,vertices,a,data,set,of,vertices,param,edges,a,data,set,of,edges,param,context,the,flink,execution,environment;private,graph,data,set,vertex,k,vv,vertices,data,set,edge,k,ev,edges,execution,environment,context,this,vertices,vertices,this,edges,edges,this,context,context
Graph -> private Graph(DataSet<Vertex<K, VV>> vertices, DataSet<Edge<K, EV>> edges, ExecutionEnvironment context);1462100316;Creates a graph from two DataSets: vertices and edges__@param vertices a DataSet of vertices._@param edges a DataSet of edges._@param context the flink execution environment.;private Graph(DataSet<Vertex<K, VV>> vertices, DataSet<Edge<K, EV>> edges, ExecutionEnvironment context) {_		this.vertices = vertices__		this.edges = edges__		this.context = context__	};creates,a,graph,from,two,data,sets,vertices,and,edges,param,vertices,a,data,set,of,vertices,param,edges,a,data,set,of,edges,param,context,the,flink,execution,environment;private,graph,data,set,vertex,k,vv,vertices,data,set,edge,k,ev,edges,execution,environment,context,this,vertices,vertices,this,edges,edges,this,context,context
Graph -> private Graph(DataSet<Vertex<K, VV>> vertices, DataSet<Edge<K, EV>> edges, ExecutionEnvironment context);1462100316;Creates a graph from two DataSets: vertices and edges__@param vertices a DataSet of vertices._@param edges a DataSet of edges._@param context the flink execution environment.;private Graph(DataSet<Vertex<K, VV>> vertices, DataSet<Edge<K, EV>> edges, ExecutionEnvironment context) {_		this.vertices = vertices__		this.edges = edges__		this.context = context__	};creates,a,graph,from,two,data,sets,vertices,and,edges,param,vertices,a,data,set,of,vertices,param,edges,a,data,set,of,edges,param,context,the,flink,execution,environment;private,graph,data,set,vertex,k,vv,vertices,data,set,edge,k,ev,edges,execution,environment,context,this,vertices,vertices,this,edges,edges,this,context,context
Graph -> private Graph(DataSet<Vertex<K, VV>> vertices, DataSet<Edge<K, EV>> edges, ExecutionEnvironment context);1462205213;Creates a graph from two DataSets: vertices and edges__@param vertices a DataSet of vertices._@param edges a DataSet of edges._@param context the flink execution environment.;private Graph(DataSet<Vertex<K, VV>> vertices, DataSet<Edge<K, EV>> edges, ExecutionEnvironment context) {_		this.vertices = vertices__		this.edges = edges__		this.context = context__	};creates,a,graph,from,two,data,sets,vertices,and,edges,param,vertices,a,data,set,of,vertices,param,edges,a,data,set,of,edges,param,context,the,flink,execution,environment;private,graph,data,set,vertex,k,vv,vertices,data,set,edge,k,ev,edges,execution,environment,context,this,vertices,vertices,this,edges,edges,this,context,context
Graph -> private Graph(DataSet<Vertex<K, VV>> vertices, DataSet<Edge<K, EV>> edges, ExecutionEnvironment context);1462208859;Creates a graph from two DataSets: vertices and edges__@param vertices a DataSet of vertices._@param edges a DataSet of edges._@param context the flink execution environment.;private Graph(DataSet<Vertex<K, VV>> vertices, DataSet<Edge<K, EV>> edges, ExecutionEnvironment context) {_		this.vertices = vertices__		this.edges = edges__		this.context = context__	};creates,a,graph,from,two,data,sets,vertices,and,edges,param,vertices,a,data,set,of,vertices,param,edges,a,data,set,of,edges,param,context,the,flink,execution,environment;private,graph,data,set,vertex,k,vv,vertices,data,set,edge,k,ev,edges,execution,environment,context,this,vertices,vertices,this,edges,edges,this,context,context
Graph -> private Graph(DataSet<Vertex<K, VV>> vertices, DataSet<Edge<K, EV>> edges, ExecutionEnvironment context);1462809297;Creates a graph from two DataSets: vertices and edges__@param vertices a DataSet of vertices._@param edges a DataSet of edges._@param context the flink execution environment.;private Graph(DataSet<Vertex<K, VV>> vertices, DataSet<Edge<K, EV>> edges, ExecutionEnvironment context) {_		this.vertices = vertices__		this.edges = edges__		this.context = context__	};creates,a,graph,from,two,data,sets,vertices,and,edges,param,vertices,a,data,set,of,vertices,param,edges,a,data,set,of,edges,param,context,the,flink,execution,environment;private,graph,data,set,vertex,k,vv,vertices,data,set,edge,k,ev,edges,execution,environment,context,this,vertices,vertices,this,edges,edges,this,context,context
Graph -> private Graph(DataSet<Vertex<K, VV>> vertices, DataSet<Edge<K, EV>> edges, ExecutionEnvironment context);1465316775;Creates a graph from two DataSets: vertices and edges__@param vertices a DataSet of vertices._@param edges a DataSet of edges._@param context the flink execution environment.;private Graph(DataSet<Vertex<K, VV>> vertices, DataSet<Edge<K, EV>> edges, ExecutionEnvironment context) {_		this.vertices = vertices__		this.edges = edges__		this.context = context__	};creates,a,graph,from,two,data,sets,vertices,and,edges,param,vertices,a,data,set,of,vertices,param,edges,a,data,set,of,edges,param,context,the,flink,execution,environment;private,graph,data,set,vertex,k,vv,vertices,data,set,edge,k,ev,edges,execution,environment,context,this,vertices,vertices,this,edges,edges,this,context,context
Graph -> private Graph(DataSet<Vertex<K, VV>> vertices, DataSet<Edge<K, EV>> edges, ExecutionEnvironment context);1466789678;Creates a graph from two DataSets: vertices and edges__@param vertices a DataSet of vertices._@param edges a DataSet of edges._@param context the flink execution environment.;private Graph(DataSet<Vertex<K, VV>> vertices, DataSet<Edge<K, EV>> edges, ExecutionEnvironment context) {_		this.vertices = vertices__		this.edges = edges__		this.context = context__	};creates,a,graph,from,two,data,sets,vertices,and,edges,param,vertices,a,data,set,of,vertices,param,edges,a,data,set,of,edges,param,context,the,flink,execution,environment;private,graph,data,set,vertex,k,vv,vertices,data,set,edge,k,ev,edges,execution,environment,context,this,vertices,vertices,this,edges,edges,this,context,context
Graph -> private Graph(DataSet<Vertex<K, VV>> vertices, DataSet<Edge<K, EV>> edges, ExecutionEnvironment context);1467140656;Creates a graph from two DataSets: vertices and edges__@param vertices a DataSet of vertices._@param edges a DataSet of edges._@param context the flink execution environment.;private Graph(DataSet<Vertex<K, VV>> vertices, DataSet<Edge<K, EV>> edges, ExecutionEnvironment context) {_		this.vertices = vertices__		this.edges = edges__		this.context = context__	};creates,a,graph,from,two,data,sets,vertices,and,edges,param,vertices,a,data,set,of,vertices,param,edges,a,data,set,of,edges,param,context,the,flink,execution,environment;private,graph,data,set,vertex,k,vv,vertices,data,set,edge,k,ev,edges,execution,environment,context,this,vertices,vertices,this,edges,edges,this,context,context
Graph -> private Graph(DataSet<Vertex<K, VV>> vertices, DataSet<Edge<K, EV>> edges, ExecutionEnvironment context);1467306272;Creates a graph from two DataSets: vertices and edges__@param vertices a DataSet of vertices._@param edges a DataSet of edges._@param context the flink execution environment.;private Graph(DataSet<Vertex<K, VV>> vertices, DataSet<Edge<K, EV>> edges, ExecutionEnvironment context) {_		this.vertices = vertices__		this.edges = edges__		this.context = context__	};creates,a,graph,from,two,data,sets,vertices,and,edges,param,vertices,a,data,set,of,vertices,param,edges,a,data,set,of,edges,param,context,the,flink,execution,environment;private,graph,data,set,vertex,k,vv,vertices,data,set,edge,k,ev,edges,execution,environment,context,this,vertices,vertices,this,edges,edges,this,context,context
Graph -> private Graph(DataSet<Vertex<K, VV>> vertices, DataSet<Edge<K, EV>> edges, ExecutionEnvironment context);1470042815;Creates a graph from two DataSets: vertices and edges__@param vertices a DataSet of vertices._@param edges a DataSet of edges._@param context the flink execution environment.;private Graph(DataSet<Vertex<K, VV>> vertices, DataSet<Edge<K, EV>> edges, ExecutionEnvironment context) {_		this.vertices = vertices__		this.edges = edges__		this.context = context__	};creates,a,graph,from,two,data,sets,vertices,and,edges,param,vertices,a,data,set,of,vertices,param,edges,a,data,set,of,edges,param,context,the,flink,execution,environment;private,graph,data,set,vertex,k,vv,vertices,data,set,edge,k,ev,edges,execution,environment,context,this,vertices,vertices,this,edges,edges,this,context,context
Graph -> private Graph(DataSet<Vertex<K, VV>> vertices, DataSet<Edge<K, EV>> edges, ExecutionEnvironment context);1475684776;Creates a graph from two DataSets: vertices and edges__@param vertices a DataSet of vertices._@param edges a DataSet of edges._@param context the flink execution environment.;private Graph(DataSet<Vertex<K, VV>> vertices, DataSet<Edge<K, EV>> edges, ExecutionEnvironment context) {_		this.vertices = vertices__		this.edges = edges__		this.context = context__	};creates,a,graph,from,two,data,sets,vertices,and,edges,param,vertices,a,data,set,of,vertices,param,edges,a,data,set,of,edges,param,context,the,flink,execution,environment;private,graph,data,set,vertex,k,vv,vertices,data,set,edge,k,ev,edges,execution,environment,context,this,vertices,vertices,this,edges,edges,this,context,context
Graph -> private Graph(DataSet<Vertex<K, VV>> vertices, DataSet<Edge<K, EV>> edges, ExecutionEnvironment context);1475685606;Creates a graph from two DataSets: vertices and edges__@param vertices a DataSet of vertices._@param edges a DataSet of edges._@param context the flink execution environment.;private Graph(DataSet<Vertex<K, VV>> vertices, DataSet<Edge<K, EV>> edges, ExecutionEnvironment context) {_		this.vertices = vertices__		this.edges = edges__		this.context = context__	};creates,a,graph,from,two,data,sets,vertices,and,edges,param,vertices,a,data,set,of,vertices,param,edges,a,data,set,of,edges,param,context,the,flink,execution,environment;private,graph,data,set,vertex,k,vv,vertices,data,set,edge,k,ev,edges,execution,environment,context,this,vertices,vertices,this,edges,edges,this,context,context
Graph -> private Graph(DataSet<Vertex<K, VV>> vertices, DataSet<Edge<K, EV>> edges, ExecutionEnvironment context);1481745825;Creates a graph from two DataSets: vertices and edges__@param vertices a DataSet of vertices._@param edges a DataSet of edges._@param context the flink execution environment.;private Graph(DataSet<Vertex<K, VV>> vertices, DataSet<Edge<K, EV>> edges, ExecutionEnvironment context) {_		this.vertices = vertices__		this.edges = edges__		this.context = context__	};creates,a,graph,from,two,data,sets,vertices,and,edges,param,vertices,a,data,set,of,vertices,param,edges,a,data,set,of,edges,param,context,the,flink,execution,environment;private,graph,data,set,vertex,k,vv,vertices,data,set,edge,k,ev,edges,execution,environment,context,this,vertices,vertices,this,edges,edges,this,context,context
Graph -> private Graph(DataSet<Vertex<K, VV>> vertices, DataSet<Edge<K, EV>> edges, ExecutionEnvironment context);1481881009;Creates a graph from two DataSets: vertices and edges__@param vertices a DataSet of vertices._@param edges a DataSet of edges._@param context the flink execution environment.;private Graph(DataSet<Vertex<K, VV>> vertices, DataSet<Edge<K, EV>> edges, ExecutionEnvironment context) {_		this.vertices = vertices__		this.edges = edges__		this.context = context__	};creates,a,graph,from,two,data,sets,vertices,and,edges,param,vertices,a,data,set,of,vertices,param,edges,a,data,set,of,edges,param,context,the,flink,execution,environment;private,graph,data,set,vertex,k,vv,vertices,data,set,edge,k,ev,edges,execution,environment,context,this,vertices,vertices,this,edges,edges,this,context,context
Graph -> public static GraphCsvReader fromCsvReader(String verticesPath, String edgesPath, ExecutionEnvironment context);1444404795;Creates a Graph from a CSV file of vertices and a CSV file of edges.__@param verticesPath path to a CSV file with the Vertex data._@param edgesPath path to a CSV file with the Edge data_@param context the Flink execution environment._@return An instance of {@link org.apache.flink.graph.GraphCsvReader},_on which calling methods to specify types of the Vertex ID, Vertex value and Edge value returns a Graph.__@see {@link org.apache.flink.graph.GraphCsvReader#types(Class, Class, Class)},_{@link org.apache.flink.graph.GraphCsvReader#vertexTypes(Class, Class)},_{@link org.apache.flink.graph.GraphCsvReader#edgeTypes(Class, Class)} and_{@link org.apache.flink.graph.GraphCsvReader#keyType(Class)}.;public static GraphCsvReader fromCsvReader(String verticesPath, String edgesPath, ExecutionEnvironment context) {_		return new GraphCsvReader(verticesPath, edgesPath, context)__	};creates,a,graph,from,a,csv,file,of,vertices,and,a,csv,file,of,edges,param,vertices,path,path,to,a,csv,file,with,the,vertex,data,param,edges,path,path,to,a,csv,file,with,the,edge,data,param,context,the,flink,execution,environment,return,an,instance,of,link,org,apache,flink,graph,graph,csv,reader,on,which,calling,methods,to,specify,types,of,the,vertex,id,vertex,value,and,edge,value,returns,a,graph,see,link,org,apache,flink,graph,graph,csv,reader,types,class,class,class,link,org,apache,flink,graph,graph,csv,reader,vertex,types,class,class,link,org,apache,flink,graph,graph,csv,reader,edge,types,class,class,and,link,org,apache,flink,graph,graph,csv,reader,key,type,class;public,static,graph,csv,reader,from,csv,reader,string,vertices,path,string,edges,path,execution,environment,context,return,new,graph,csv,reader,vertices,path,edges,path,context
Graph -> public static GraphCsvReader fromCsvReader(String verticesPath, String edgesPath, ExecutionEnvironment context);1445261977;Creates a Graph from a CSV file of vertices and a CSV file of edges.__@param verticesPath path to a CSV file with the Vertex data._@param edgesPath path to a CSV file with the Edge data_@param context the Flink execution environment._@return An instance of {@link org.apache.flink.graph.GraphCsvReader},_on which calling methods to specify types of the Vertex ID, Vertex value and Edge value returns a Graph.__@see {@link org.apache.flink.graph.GraphCsvReader#types(Class, Class, Class)},_{@link org.apache.flink.graph.GraphCsvReader#vertexTypes(Class, Class)},_{@link org.apache.flink.graph.GraphCsvReader#edgeTypes(Class, Class)} and_{@link org.apache.flink.graph.GraphCsvReader#keyType(Class)}.;public static GraphCsvReader fromCsvReader(String verticesPath, String edgesPath, ExecutionEnvironment context) {_		return new GraphCsvReader(verticesPath, edgesPath, context)__	};creates,a,graph,from,a,csv,file,of,vertices,and,a,csv,file,of,edges,param,vertices,path,path,to,a,csv,file,with,the,vertex,data,param,edges,path,path,to,a,csv,file,with,the,edge,data,param,context,the,flink,execution,environment,return,an,instance,of,link,org,apache,flink,graph,graph,csv,reader,on,which,calling,methods,to,specify,types,of,the,vertex,id,vertex,value,and,edge,value,returns,a,graph,see,link,org,apache,flink,graph,graph,csv,reader,types,class,class,class,link,org,apache,flink,graph,graph,csv,reader,vertex,types,class,class,link,org,apache,flink,graph,graph,csv,reader,edge,types,class,class,and,link,org,apache,flink,graph,graph,csv,reader,key,type,class;public,static,graph,csv,reader,from,csv,reader,string,vertices,path,string,edges,path,execution,environment,context,return,new,graph,csv,reader,vertices,path,edges,path,context
Graph -> public static GraphCsvReader fromCsvReader(String verticesPath, String edgesPath, ExecutionEnvironment context);1445854323;Creates a Graph from a CSV file of vertices and a CSV file of edges.__@param verticesPath path to a CSV file with the Vertex data._@param edgesPath path to a CSV file with the Edge data_@param context the Flink execution environment._@return An instance of {@link org.apache.flink.graph.GraphCsvReader},_on which calling methods to specify types of the Vertex ID, Vertex value and Edge value returns a Graph.__@see {@link org.apache.flink.graph.GraphCsvReader#types(Class, Class, Class)},_{@link org.apache.flink.graph.GraphCsvReader#vertexTypes(Class, Class)},_{@link org.apache.flink.graph.GraphCsvReader#edgeTypes(Class, Class)} and_{@link org.apache.flink.graph.GraphCsvReader#keyType(Class)}.;public static GraphCsvReader fromCsvReader(String verticesPath, String edgesPath, ExecutionEnvironment context) {_		return new GraphCsvReader(verticesPath, edgesPath, context)__	};creates,a,graph,from,a,csv,file,of,vertices,and,a,csv,file,of,edges,param,vertices,path,path,to,a,csv,file,with,the,vertex,data,param,edges,path,path,to,a,csv,file,with,the,edge,data,param,context,the,flink,execution,environment,return,an,instance,of,link,org,apache,flink,graph,graph,csv,reader,on,which,calling,methods,to,specify,types,of,the,vertex,id,vertex,value,and,edge,value,returns,a,graph,see,link,org,apache,flink,graph,graph,csv,reader,types,class,class,class,link,org,apache,flink,graph,graph,csv,reader,vertex,types,class,class,link,org,apache,flink,graph,graph,csv,reader,edge,types,class,class,and,link,org,apache,flink,graph,graph,csv,reader,key,type,class;public,static,graph,csv,reader,from,csv,reader,string,vertices,path,string,edges,path,execution,environment,context,return,new,graph,csv,reader,vertices,path,edges,path,context
Graph -> public static GraphCsvReader fromCsvReader(String verticesPath, String edgesPath, ExecutionEnvironment context);1446112342;Creates a Graph from a CSV file of vertices and a CSV file of edges.__@param verticesPath path to a CSV file with the Vertex data._@param edgesPath path to a CSV file with the Edge data_@param context the Flink execution environment._@return An instance of {@link org.apache.flink.graph.GraphCsvReader},_on which calling methods to specify types of the Vertex ID, Vertex value and Edge value returns a Graph.__@see org.apache.flink.graph.GraphCsvReader#types(Class, Class, Class)_@see org.apache.flink.graph.GraphCsvReader#vertexTypes(Class, Class)_@see org.apache.flink.graph.GraphCsvReader#edgeTypes(Class, Class)_@see org.apache.flink.graph.GraphCsvReader#keyType(Class);public static GraphCsvReader fromCsvReader(String verticesPath, String edgesPath, ExecutionEnvironment context) {_		return new GraphCsvReader(verticesPath, edgesPath, context)__	};creates,a,graph,from,a,csv,file,of,vertices,and,a,csv,file,of,edges,param,vertices,path,path,to,a,csv,file,with,the,vertex,data,param,edges,path,path,to,a,csv,file,with,the,edge,data,param,context,the,flink,execution,environment,return,an,instance,of,link,org,apache,flink,graph,graph,csv,reader,on,which,calling,methods,to,specify,types,of,the,vertex,id,vertex,value,and,edge,value,returns,a,graph,see,org,apache,flink,graph,graph,csv,reader,types,class,class,class,see,org,apache,flink,graph,graph,csv,reader,vertex,types,class,class,see,org,apache,flink,graph,graph,csv,reader,edge,types,class,class,see,org,apache,flink,graph,graph,csv,reader,key,type,class;public,static,graph,csv,reader,from,csv,reader,string,vertices,path,string,edges,path,execution,environment,context,return,new,graph,csv,reader,vertices,path,edges,path,context
Graph -> public static GraphCsvReader fromCsvReader(String verticesPath, String edgesPath, ExecutionEnvironment context);1447073368;Creates a Graph from a CSV file of vertices and a CSV file of edges.__@param verticesPath path to a CSV file with the Vertex data._@param edgesPath path to a CSV file with the Edge data_@param context the Flink execution environment._@return An instance of {@link org.apache.flink.graph.GraphCsvReader},_on which calling methods to specify types of the Vertex ID, Vertex value and Edge value returns a Graph.__@see org.apache.flink.graph.GraphCsvReader#types(Class, Class, Class)_@see org.apache.flink.graph.GraphCsvReader#vertexTypes(Class, Class)_@see org.apache.flink.graph.GraphCsvReader#edgeTypes(Class, Class)_@see org.apache.flink.graph.GraphCsvReader#keyType(Class);public static GraphCsvReader fromCsvReader(String verticesPath, String edgesPath, ExecutionEnvironment context) {_		return new GraphCsvReader(verticesPath, edgesPath, context)__	};creates,a,graph,from,a,csv,file,of,vertices,and,a,csv,file,of,edges,param,vertices,path,path,to,a,csv,file,with,the,vertex,data,param,edges,path,path,to,a,csv,file,with,the,edge,data,param,context,the,flink,execution,environment,return,an,instance,of,link,org,apache,flink,graph,graph,csv,reader,on,which,calling,methods,to,specify,types,of,the,vertex,id,vertex,value,and,edge,value,returns,a,graph,see,org,apache,flink,graph,graph,csv,reader,types,class,class,class,see,org,apache,flink,graph,graph,csv,reader,vertex,types,class,class,see,org,apache,flink,graph,graph,csv,reader,edge,types,class,class,see,org,apache,flink,graph,graph,csv,reader,key,type,class;public,static,graph,csv,reader,from,csv,reader,string,vertices,path,string,edges,path,execution,environment,context,return,new,graph,csv,reader,vertices,path,edges,path,context
Graph -> public static GraphCsvReader fromCsvReader(String verticesPath, String edgesPath, ExecutionEnvironment context);1454404649;Creates a Graph from a CSV file of vertices and a CSV file of edges.__@param verticesPath path to a CSV file with the Vertex data._@param edgesPath path to a CSV file with the Edge data_@param context the Flink execution environment._@return An instance of {@link org.apache.flink.graph.GraphCsvReader},_on which calling methods to specify types of the Vertex ID, Vertex value and Edge value returns a Graph.__@see org.apache.flink.graph.GraphCsvReader#types(Class, Class, Class)_@see org.apache.flink.graph.GraphCsvReader#vertexTypes(Class, Class)_@see org.apache.flink.graph.GraphCsvReader#edgeTypes(Class, Class)_@see org.apache.flink.graph.GraphCsvReader#keyType(Class);public static GraphCsvReader fromCsvReader(String verticesPath, String edgesPath, ExecutionEnvironment context) {_		return new GraphCsvReader(verticesPath, edgesPath, context)__	};creates,a,graph,from,a,csv,file,of,vertices,and,a,csv,file,of,edges,param,vertices,path,path,to,a,csv,file,with,the,vertex,data,param,edges,path,path,to,a,csv,file,with,the,edge,data,param,context,the,flink,execution,environment,return,an,instance,of,link,org,apache,flink,graph,graph,csv,reader,on,which,calling,methods,to,specify,types,of,the,vertex,id,vertex,value,and,edge,value,returns,a,graph,see,org,apache,flink,graph,graph,csv,reader,types,class,class,class,see,org,apache,flink,graph,graph,csv,reader,vertex,types,class,class,see,org,apache,flink,graph,graph,csv,reader,edge,types,class,class,see,org,apache,flink,graph,graph,csv,reader,key,type,class;public,static,graph,csv,reader,from,csv,reader,string,vertices,path,string,edges,path,execution,environment,context,return,new,graph,csv,reader,vertices,path,edges,path,context
Graph -> public static GraphCsvReader fromCsvReader(String verticesPath, String edgesPath, ExecutionEnvironment context);1458583829;Creates a Graph from a CSV file of vertices and a CSV file of edges.__@param verticesPath path to a CSV file with the Vertex data._@param edgesPath path to a CSV file with the Edge data_@param context the Flink execution environment._@return An instance of {@link org.apache.flink.graph.GraphCsvReader},_on which calling methods to specify types of the Vertex ID, Vertex value and Edge value returns a Graph.__@see org.apache.flink.graph.GraphCsvReader#types(Class, Class, Class)_@see org.apache.flink.graph.GraphCsvReader#vertexTypes(Class, Class)_@see org.apache.flink.graph.GraphCsvReader#edgeTypes(Class, Class)_@see org.apache.flink.graph.GraphCsvReader#keyType(Class);public static GraphCsvReader fromCsvReader(String verticesPath, String edgesPath, ExecutionEnvironment context) {_		return new GraphCsvReader(verticesPath, edgesPath, context)__	};creates,a,graph,from,a,csv,file,of,vertices,and,a,csv,file,of,edges,param,vertices,path,path,to,a,csv,file,with,the,vertex,data,param,edges,path,path,to,a,csv,file,with,the,edge,data,param,context,the,flink,execution,environment,return,an,instance,of,link,org,apache,flink,graph,graph,csv,reader,on,which,calling,methods,to,specify,types,of,the,vertex,id,vertex,value,and,edge,value,returns,a,graph,see,org,apache,flink,graph,graph,csv,reader,types,class,class,class,see,org,apache,flink,graph,graph,csv,reader,vertex,types,class,class,see,org,apache,flink,graph,graph,csv,reader,edge,types,class,class,see,org,apache,flink,graph,graph,csv,reader,key,type,class;public,static,graph,csv,reader,from,csv,reader,string,vertices,path,string,edges,path,execution,environment,context,return,new,graph,csv,reader,vertices,path,edges,path,context
Graph -> public static GraphCsvReader fromCsvReader(String verticesPath, String edgesPath, ExecutionEnvironment context);1458583829;Creates a Graph from a CSV file of vertices and a CSV file of edges.__@param verticesPath path to a CSV file with the Vertex data._@param edgesPath path to a CSV file with the Edge data_@param context the Flink execution environment._@return An instance of {@link org.apache.flink.graph.GraphCsvReader},_on which calling methods to specify types of the Vertex ID, Vertex value and Edge value returns a Graph.__@see org.apache.flink.graph.GraphCsvReader#types(Class, Class, Class)_@see org.apache.flink.graph.GraphCsvReader#vertexTypes(Class, Class)_@see org.apache.flink.graph.GraphCsvReader#edgeTypes(Class, Class)_@see org.apache.flink.graph.GraphCsvReader#keyType(Class);public static GraphCsvReader fromCsvReader(String verticesPath, String edgesPath, ExecutionEnvironment context) {_		return new GraphCsvReader(verticesPath, edgesPath, context)__	};creates,a,graph,from,a,csv,file,of,vertices,and,a,csv,file,of,edges,param,vertices,path,path,to,a,csv,file,with,the,vertex,data,param,edges,path,path,to,a,csv,file,with,the,edge,data,param,context,the,flink,execution,environment,return,an,instance,of,link,org,apache,flink,graph,graph,csv,reader,on,which,calling,methods,to,specify,types,of,the,vertex,id,vertex,value,and,edge,value,returns,a,graph,see,org,apache,flink,graph,graph,csv,reader,types,class,class,class,see,org,apache,flink,graph,graph,csv,reader,vertex,types,class,class,see,org,apache,flink,graph,graph,csv,reader,edge,types,class,class,see,org,apache,flink,graph,graph,csv,reader,key,type,class;public,static,graph,csv,reader,from,csv,reader,string,vertices,path,string,edges,path,execution,environment,context,return,new,graph,csv,reader,vertices,path,edges,path,context
Graph -> public static GraphCsvReader fromCsvReader(String verticesPath, String edgesPath, ExecutionEnvironment context);1462100316;Creates a Graph from a CSV file of vertices and a CSV file of edges.__@param verticesPath path to a CSV file with the Vertex data._@param edgesPath path to a CSV file with the Edge data_@param context the Flink execution environment._@return An instance of {@link org.apache.flink.graph.GraphCsvReader},_on which calling methods to specify types of the Vertex ID, Vertex value and Edge value returns a Graph.__@see org.apache.flink.graph.GraphCsvReader#types(Class, Class, Class)_@see org.apache.flink.graph.GraphCsvReader#vertexTypes(Class, Class)_@see org.apache.flink.graph.GraphCsvReader#edgeTypes(Class, Class)_@see org.apache.flink.graph.GraphCsvReader#keyType(Class);public static GraphCsvReader fromCsvReader(String verticesPath, String edgesPath, ExecutionEnvironment context) {_		return new GraphCsvReader(verticesPath, edgesPath, context)__	};creates,a,graph,from,a,csv,file,of,vertices,and,a,csv,file,of,edges,param,vertices,path,path,to,a,csv,file,with,the,vertex,data,param,edges,path,path,to,a,csv,file,with,the,edge,data,param,context,the,flink,execution,environment,return,an,instance,of,link,org,apache,flink,graph,graph,csv,reader,on,which,calling,methods,to,specify,types,of,the,vertex,id,vertex,value,and,edge,value,returns,a,graph,see,org,apache,flink,graph,graph,csv,reader,types,class,class,class,see,org,apache,flink,graph,graph,csv,reader,vertex,types,class,class,see,org,apache,flink,graph,graph,csv,reader,edge,types,class,class,see,org,apache,flink,graph,graph,csv,reader,key,type,class;public,static,graph,csv,reader,from,csv,reader,string,vertices,path,string,edges,path,execution,environment,context,return,new,graph,csv,reader,vertices,path,edges,path,context
Graph -> public static GraphCsvReader fromCsvReader(String verticesPath, String edgesPath, ExecutionEnvironment context);1462100316;Creates a Graph from a CSV file of vertices and a CSV file of edges.__@param verticesPath path to a CSV file with the Vertex data._@param edgesPath path to a CSV file with the Edge data_@param context the Flink execution environment._@return An instance of {@link org.apache.flink.graph.GraphCsvReader},_on which calling methods to specify types of the Vertex ID, Vertex value and Edge value returns a Graph.__@see org.apache.flink.graph.GraphCsvReader#types(Class, Class, Class)_@see org.apache.flink.graph.GraphCsvReader#vertexTypes(Class, Class)_@see org.apache.flink.graph.GraphCsvReader#edgeTypes(Class, Class)_@see org.apache.flink.graph.GraphCsvReader#keyType(Class);public static GraphCsvReader fromCsvReader(String verticesPath, String edgesPath, ExecutionEnvironment context) {_		return new GraphCsvReader(verticesPath, edgesPath, context)__	};creates,a,graph,from,a,csv,file,of,vertices,and,a,csv,file,of,edges,param,vertices,path,path,to,a,csv,file,with,the,vertex,data,param,edges,path,path,to,a,csv,file,with,the,edge,data,param,context,the,flink,execution,environment,return,an,instance,of,link,org,apache,flink,graph,graph,csv,reader,on,which,calling,methods,to,specify,types,of,the,vertex,id,vertex,value,and,edge,value,returns,a,graph,see,org,apache,flink,graph,graph,csv,reader,types,class,class,class,see,org,apache,flink,graph,graph,csv,reader,vertex,types,class,class,see,org,apache,flink,graph,graph,csv,reader,edge,types,class,class,see,org,apache,flink,graph,graph,csv,reader,key,type,class;public,static,graph,csv,reader,from,csv,reader,string,vertices,path,string,edges,path,execution,environment,context,return,new,graph,csv,reader,vertices,path,edges,path,context
Graph -> public static GraphCsvReader fromCsvReader(String verticesPath, String edgesPath, ExecutionEnvironment context);1462205213;Creates a Graph from a CSV file of vertices and a CSV file of edges.__@param verticesPath path to a CSV file with the Vertex data._@param edgesPath path to a CSV file with the Edge data_@param context the Flink execution environment._@return An instance of {@link org.apache.flink.graph.GraphCsvReader},_on which calling methods to specify types of the Vertex ID, Vertex value and Edge value returns a Graph.__@see org.apache.flink.graph.GraphCsvReader#types(Class, Class, Class)_@see org.apache.flink.graph.GraphCsvReader#vertexTypes(Class, Class)_@see org.apache.flink.graph.GraphCsvReader#edgeTypes(Class, Class)_@see org.apache.flink.graph.GraphCsvReader#keyType(Class);public static GraphCsvReader fromCsvReader(String verticesPath, String edgesPath, ExecutionEnvironment context) {_		return new GraphCsvReader(verticesPath, edgesPath, context)__	};creates,a,graph,from,a,csv,file,of,vertices,and,a,csv,file,of,edges,param,vertices,path,path,to,a,csv,file,with,the,vertex,data,param,edges,path,path,to,a,csv,file,with,the,edge,data,param,context,the,flink,execution,environment,return,an,instance,of,link,org,apache,flink,graph,graph,csv,reader,on,which,calling,methods,to,specify,types,of,the,vertex,id,vertex,value,and,edge,value,returns,a,graph,see,org,apache,flink,graph,graph,csv,reader,types,class,class,class,see,org,apache,flink,graph,graph,csv,reader,vertex,types,class,class,see,org,apache,flink,graph,graph,csv,reader,edge,types,class,class,see,org,apache,flink,graph,graph,csv,reader,key,type,class;public,static,graph,csv,reader,from,csv,reader,string,vertices,path,string,edges,path,execution,environment,context,return,new,graph,csv,reader,vertices,path,edges,path,context
Graph -> public static GraphCsvReader fromCsvReader(String verticesPath, String edgesPath, ExecutionEnvironment context);1462208859;Creates a Graph from a CSV file of vertices and a CSV file of edges.__@param verticesPath path to a CSV file with the Vertex data._@param edgesPath path to a CSV file with the Edge data_@param context the Flink execution environment._@return An instance of {@link org.apache.flink.graph.GraphCsvReader},_on which calling methods to specify types of the Vertex ID, Vertex value and Edge value returns a Graph.__@see org.apache.flink.graph.GraphCsvReader#types(Class, Class, Class)_@see org.apache.flink.graph.GraphCsvReader#vertexTypes(Class, Class)_@see org.apache.flink.graph.GraphCsvReader#edgeTypes(Class, Class)_@see org.apache.flink.graph.GraphCsvReader#keyType(Class);public static GraphCsvReader fromCsvReader(String verticesPath, String edgesPath, ExecutionEnvironment context) {_		return new GraphCsvReader(verticesPath, edgesPath, context)__	};creates,a,graph,from,a,csv,file,of,vertices,and,a,csv,file,of,edges,param,vertices,path,path,to,a,csv,file,with,the,vertex,data,param,edges,path,path,to,a,csv,file,with,the,edge,data,param,context,the,flink,execution,environment,return,an,instance,of,link,org,apache,flink,graph,graph,csv,reader,on,which,calling,methods,to,specify,types,of,the,vertex,id,vertex,value,and,edge,value,returns,a,graph,see,org,apache,flink,graph,graph,csv,reader,types,class,class,class,see,org,apache,flink,graph,graph,csv,reader,vertex,types,class,class,see,org,apache,flink,graph,graph,csv,reader,edge,types,class,class,see,org,apache,flink,graph,graph,csv,reader,key,type,class;public,static,graph,csv,reader,from,csv,reader,string,vertices,path,string,edges,path,execution,environment,context,return,new,graph,csv,reader,vertices,path,edges,path,context
Graph -> public static GraphCsvReader fromCsvReader(String verticesPath, String edgesPath, ExecutionEnvironment context);1462809297;Creates a Graph from a CSV file of vertices and a CSV file of edges.__@param verticesPath path to a CSV file with the Vertex data._@param edgesPath path to a CSV file with the Edge data_@param context the Flink execution environment._@return An instance of {@link org.apache.flink.graph.GraphCsvReader},_on which calling methods to specify types of the Vertex ID, Vertex value and Edge value returns a Graph.__@see org.apache.flink.graph.GraphCsvReader#types(Class, Class, Class)_@see org.apache.flink.graph.GraphCsvReader#vertexTypes(Class, Class)_@see org.apache.flink.graph.GraphCsvReader#edgeTypes(Class, Class)_@see org.apache.flink.graph.GraphCsvReader#keyType(Class);public static GraphCsvReader fromCsvReader(String verticesPath, String edgesPath, ExecutionEnvironment context) {_		return new GraphCsvReader(verticesPath, edgesPath, context)__	};creates,a,graph,from,a,csv,file,of,vertices,and,a,csv,file,of,edges,param,vertices,path,path,to,a,csv,file,with,the,vertex,data,param,edges,path,path,to,a,csv,file,with,the,edge,data,param,context,the,flink,execution,environment,return,an,instance,of,link,org,apache,flink,graph,graph,csv,reader,on,which,calling,methods,to,specify,types,of,the,vertex,id,vertex,value,and,edge,value,returns,a,graph,see,org,apache,flink,graph,graph,csv,reader,types,class,class,class,see,org,apache,flink,graph,graph,csv,reader,vertex,types,class,class,see,org,apache,flink,graph,graph,csv,reader,edge,types,class,class,see,org,apache,flink,graph,graph,csv,reader,key,type,class;public,static,graph,csv,reader,from,csv,reader,string,vertices,path,string,edges,path,execution,environment,context,return,new,graph,csv,reader,vertices,path,edges,path,context
Graph -> public static GraphCsvReader fromCsvReader(String verticesPath, String edgesPath, ExecutionEnvironment context);1465316775;Creates a Graph from a CSV file of vertices and a CSV file of edges.__@param verticesPath path to a CSV file with the Vertex data._@param edgesPath path to a CSV file with the Edge data_@param context the Flink execution environment._@return An instance of {@link org.apache.flink.graph.GraphCsvReader},_on which calling methods to specify types of the Vertex ID, Vertex value and Edge value returns a Graph.__@see org.apache.flink.graph.GraphCsvReader#types(Class, Class, Class)_@see org.apache.flink.graph.GraphCsvReader#vertexTypes(Class, Class)_@see org.apache.flink.graph.GraphCsvReader#edgeTypes(Class, Class)_@see org.apache.flink.graph.GraphCsvReader#keyType(Class);public static GraphCsvReader fromCsvReader(String verticesPath, String edgesPath, ExecutionEnvironment context) {_		return new GraphCsvReader(verticesPath, edgesPath, context)__	};creates,a,graph,from,a,csv,file,of,vertices,and,a,csv,file,of,edges,param,vertices,path,path,to,a,csv,file,with,the,vertex,data,param,edges,path,path,to,a,csv,file,with,the,edge,data,param,context,the,flink,execution,environment,return,an,instance,of,link,org,apache,flink,graph,graph,csv,reader,on,which,calling,methods,to,specify,types,of,the,vertex,id,vertex,value,and,edge,value,returns,a,graph,see,org,apache,flink,graph,graph,csv,reader,types,class,class,class,see,org,apache,flink,graph,graph,csv,reader,vertex,types,class,class,see,org,apache,flink,graph,graph,csv,reader,edge,types,class,class,see,org,apache,flink,graph,graph,csv,reader,key,type,class;public,static,graph,csv,reader,from,csv,reader,string,vertices,path,string,edges,path,execution,environment,context,return,new,graph,csv,reader,vertices,path,edges,path,context
Graph -> public static GraphCsvReader fromCsvReader(String verticesPath, String edgesPath, ExecutionEnvironment context);1466789678;Creates a Graph from a CSV file of vertices and a CSV file of edges.__@param verticesPath path to a CSV file with the Vertex data._@param edgesPath path to a CSV file with the Edge data_@param context the Flink execution environment._@return An instance of {@link org.apache.flink.graph.GraphCsvReader},_on which calling methods to specify types of the Vertex ID, Vertex value and Edge value returns a Graph.__@see org.apache.flink.graph.GraphCsvReader#types(Class, Class, Class)_@see org.apache.flink.graph.GraphCsvReader#vertexTypes(Class, Class)_@see org.apache.flink.graph.GraphCsvReader#edgeTypes(Class, Class)_@see org.apache.flink.graph.GraphCsvReader#keyType(Class);public static GraphCsvReader fromCsvReader(String verticesPath, String edgesPath, ExecutionEnvironment context) {_		return new GraphCsvReader(verticesPath, edgesPath, context)__	};creates,a,graph,from,a,csv,file,of,vertices,and,a,csv,file,of,edges,param,vertices,path,path,to,a,csv,file,with,the,vertex,data,param,edges,path,path,to,a,csv,file,with,the,edge,data,param,context,the,flink,execution,environment,return,an,instance,of,link,org,apache,flink,graph,graph,csv,reader,on,which,calling,methods,to,specify,types,of,the,vertex,id,vertex,value,and,edge,value,returns,a,graph,see,org,apache,flink,graph,graph,csv,reader,types,class,class,class,see,org,apache,flink,graph,graph,csv,reader,vertex,types,class,class,see,org,apache,flink,graph,graph,csv,reader,edge,types,class,class,see,org,apache,flink,graph,graph,csv,reader,key,type,class;public,static,graph,csv,reader,from,csv,reader,string,vertices,path,string,edges,path,execution,environment,context,return,new,graph,csv,reader,vertices,path,edges,path,context
Graph -> public static GraphCsvReader fromCsvReader(String verticesPath, String edgesPath, ExecutionEnvironment context);1467140656;Creates a Graph from a CSV file of vertices and a CSV file of edges.__@param verticesPath path to a CSV file with the Vertex data._@param edgesPath path to a CSV file with the Edge data_@param context the Flink execution environment._@return An instance of {@link org.apache.flink.graph.GraphCsvReader},_on which calling methods to specify types of the Vertex ID, Vertex value and Edge value returns a Graph.__@see org.apache.flink.graph.GraphCsvReader#types(Class, Class, Class)_@see org.apache.flink.graph.GraphCsvReader#vertexTypes(Class, Class)_@see org.apache.flink.graph.GraphCsvReader#edgeTypes(Class, Class)_@see org.apache.flink.graph.GraphCsvReader#keyType(Class);public static GraphCsvReader fromCsvReader(String verticesPath, String edgesPath, ExecutionEnvironment context) {_		return new GraphCsvReader(verticesPath, edgesPath, context)__	};creates,a,graph,from,a,csv,file,of,vertices,and,a,csv,file,of,edges,param,vertices,path,path,to,a,csv,file,with,the,vertex,data,param,edges,path,path,to,a,csv,file,with,the,edge,data,param,context,the,flink,execution,environment,return,an,instance,of,link,org,apache,flink,graph,graph,csv,reader,on,which,calling,methods,to,specify,types,of,the,vertex,id,vertex,value,and,edge,value,returns,a,graph,see,org,apache,flink,graph,graph,csv,reader,types,class,class,class,see,org,apache,flink,graph,graph,csv,reader,vertex,types,class,class,see,org,apache,flink,graph,graph,csv,reader,edge,types,class,class,see,org,apache,flink,graph,graph,csv,reader,key,type,class;public,static,graph,csv,reader,from,csv,reader,string,vertices,path,string,edges,path,execution,environment,context,return,new,graph,csv,reader,vertices,path,edges,path,context
Graph -> public static GraphCsvReader fromCsvReader(String verticesPath, String edgesPath, ExecutionEnvironment context);1467306272;Creates a Graph from a CSV file of vertices and a CSV file of edges.__@param verticesPath path to a CSV file with the Vertex data._@param edgesPath path to a CSV file with the Edge data_@param context the Flink execution environment._@return An instance of {@link org.apache.flink.graph.GraphCsvReader},_on which calling methods to specify types of the Vertex ID, Vertex value and Edge value returns a Graph.__@see org.apache.flink.graph.GraphCsvReader#types(Class, Class, Class)_@see org.apache.flink.graph.GraphCsvReader#vertexTypes(Class, Class)_@see org.apache.flink.graph.GraphCsvReader#edgeTypes(Class, Class)_@see org.apache.flink.graph.GraphCsvReader#keyType(Class);public static GraphCsvReader fromCsvReader(String verticesPath, String edgesPath, ExecutionEnvironment context) {_		return new GraphCsvReader(verticesPath, edgesPath, context)__	};creates,a,graph,from,a,csv,file,of,vertices,and,a,csv,file,of,edges,param,vertices,path,path,to,a,csv,file,with,the,vertex,data,param,edges,path,path,to,a,csv,file,with,the,edge,data,param,context,the,flink,execution,environment,return,an,instance,of,link,org,apache,flink,graph,graph,csv,reader,on,which,calling,methods,to,specify,types,of,the,vertex,id,vertex,value,and,edge,value,returns,a,graph,see,org,apache,flink,graph,graph,csv,reader,types,class,class,class,see,org,apache,flink,graph,graph,csv,reader,vertex,types,class,class,see,org,apache,flink,graph,graph,csv,reader,edge,types,class,class,see,org,apache,flink,graph,graph,csv,reader,key,type,class;public,static,graph,csv,reader,from,csv,reader,string,vertices,path,string,edges,path,execution,environment,context,return,new,graph,csv,reader,vertices,path,edges,path,context
Graph -> public static GraphCsvReader fromCsvReader(String verticesPath, String edgesPath, ExecutionEnvironment context);1470042815;Creates a Graph from a CSV file of vertices and a CSV file of edges.__@param verticesPath path to a CSV file with the Vertex data._@param edgesPath path to a CSV file with the Edge data_@param context the Flink execution environment._@return An instance of {@link org.apache.flink.graph.GraphCsvReader},_on which calling methods to specify types of the Vertex ID, Vertex value and Edge value returns a Graph.__@see org.apache.flink.graph.GraphCsvReader#types(Class, Class, Class)_@see org.apache.flink.graph.GraphCsvReader#vertexTypes(Class, Class)_@see org.apache.flink.graph.GraphCsvReader#edgeTypes(Class, Class)_@see org.apache.flink.graph.GraphCsvReader#keyType(Class);public static GraphCsvReader fromCsvReader(String verticesPath, String edgesPath, ExecutionEnvironment context) {_		return new GraphCsvReader(verticesPath, edgesPath, context)__	};creates,a,graph,from,a,csv,file,of,vertices,and,a,csv,file,of,edges,param,vertices,path,path,to,a,csv,file,with,the,vertex,data,param,edges,path,path,to,a,csv,file,with,the,edge,data,param,context,the,flink,execution,environment,return,an,instance,of,link,org,apache,flink,graph,graph,csv,reader,on,which,calling,methods,to,specify,types,of,the,vertex,id,vertex,value,and,edge,value,returns,a,graph,see,org,apache,flink,graph,graph,csv,reader,types,class,class,class,see,org,apache,flink,graph,graph,csv,reader,vertex,types,class,class,see,org,apache,flink,graph,graph,csv,reader,edge,types,class,class,see,org,apache,flink,graph,graph,csv,reader,key,type,class;public,static,graph,csv,reader,from,csv,reader,string,vertices,path,string,edges,path,execution,environment,context,return,new,graph,csv,reader,vertices,path,edges,path,context
Graph -> public static GraphCsvReader fromCsvReader(String verticesPath, String edgesPath, ExecutionEnvironment context);1475684776;Creates a Graph from a CSV file of vertices and a CSV file of edges.__@param verticesPath path to a CSV file with the Vertex data._@param edgesPath path to a CSV file with the Edge data_@param context the Flink execution environment._@return An instance of {@link org.apache.flink.graph.GraphCsvReader},_on which calling methods to specify types of the Vertex ID, Vertex value and Edge value returns a Graph.__@see org.apache.flink.graph.GraphCsvReader#types(Class, Class, Class)_@see org.apache.flink.graph.GraphCsvReader#vertexTypes(Class, Class)_@see org.apache.flink.graph.GraphCsvReader#edgeTypes(Class, Class)_@see org.apache.flink.graph.GraphCsvReader#keyType(Class);public static GraphCsvReader fromCsvReader(String verticesPath, String edgesPath, ExecutionEnvironment context) {_		return new GraphCsvReader(verticesPath, edgesPath, context)__	};creates,a,graph,from,a,csv,file,of,vertices,and,a,csv,file,of,edges,param,vertices,path,path,to,a,csv,file,with,the,vertex,data,param,edges,path,path,to,a,csv,file,with,the,edge,data,param,context,the,flink,execution,environment,return,an,instance,of,link,org,apache,flink,graph,graph,csv,reader,on,which,calling,methods,to,specify,types,of,the,vertex,id,vertex,value,and,edge,value,returns,a,graph,see,org,apache,flink,graph,graph,csv,reader,types,class,class,class,see,org,apache,flink,graph,graph,csv,reader,vertex,types,class,class,see,org,apache,flink,graph,graph,csv,reader,edge,types,class,class,see,org,apache,flink,graph,graph,csv,reader,key,type,class;public,static,graph,csv,reader,from,csv,reader,string,vertices,path,string,edges,path,execution,environment,context,return,new,graph,csv,reader,vertices,path,edges,path,context
Graph -> public static GraphCsvReader fromCsvReader(String verticesPath, String edgesPath, ExecutionEnvironment context);1475685606;Creates a Graph from a CSV file of vertices and a CSV file of edges.__@param verticesPath path to a CSV file with the Vertex data._@param edgesPath path to a CSV file with the Edge data_@param context the Flink execution environment._@return An instance of {@link org.apache.flink.graph.GraphCsvReader},_on which calling methods to specify types of the Vertex ID, Vertex value and Edge value returns a Graph.__@see org.apache.flink.graph.GraphCsvReader#types(Class, Class, Class)_@see org.apache.flink.graph.GraphCsvReader#vertexTypes(Class, Class)_@see org.apache.flink.graph.GraphCsvReader#edgeTypes(Class, Class)_@see org.apache.flink.graph.GraphCsvReader#keyType(Class);public static GraphCsvReader fromCsvReader(String verticesPath, String edgesPath, ExecutionEnvironment context) {_		return new GraphCsvReader(verticesPath, edgesPath, context)__	};creates,a,graph,from,a,csv,file,of,vertices,and,a,csv,file,of,edges,param,vertices,path,path,to,a,csv,file,with,the,vertex,data,param,edges,path,path,to,a,csv,file,with,the,edge,data,param,context,the,flink,execution,environment,return,an,instance,of,link,org,apache,flink,graph,graph,csv,reader,on,which,calling,methods,to,specify,types,of,the,vertex,id,vertex,value,and,edge,value,returns,a,graph,see,org,apache,flink,graph,graph,csv,reader,types,class,class,class,see,org,apache,flink,graph,graph,csv,reader,vertex,types,class,class,see,org,apache,flink,graph,graph,csv,reader,edge,types,class,class,see,org,apache,flink,graph,graph,csv,reader,key,type,class;public,static,graph,csv,reader,from,csv,reader,string,vertices,path,string,edges,path,execution,environment,context,return,new,graph,csv,reader,vertices,path,edges,path,context
Graph -> public static GraphCsvReader fromCsvReader(String verticesPath, String edgesPath, ExecutionEnvironment context);1481745825;Creates a Graph from a CSV file of vertices and a CSV file of edges.__@param verticesPath path to a CSV file with the Vertex data._@param edgesPath path to a CSV file with the Edge data_@param context the Flink execution environment._@return An instance of {@link org.apache.flink.graph.GraphCsvReader},_on which calling methods to specify types of the Vertex ID, Vertex value and Edge value returns a Graph.__@see org.apache.flink.graph.GraphCsvReader#types(Class, Class, Class)_@see org.apache.flink.graph.GraphCsvReader#vertexTypes(Class, Class)_@see org.apache.flink.graph.GraphCsvReader#edgeTypes(Class, Class)_@see org.apache.flink.graph.GraphCsvReader#keyType(Class);public static GraphCsvReader fromCsvReader(String verticesPath, String edgesPath, ExecutionEnvironment context) {_		return new GraphCsvReader(verticesPath, edgesPath, context)__	};creates,a,graph,from,a,csv,file,of,vertices,and,a,csv,file,of,edges,param,vertices,path,path,to,a,csv,file,with,the,vertex,data,param,edges,path,path,to,a,csv,file,with,the,edge,data,param,context,the,flink,execution,environment,return,an,instance,of,link,org,apache,flink,graph,graph,csv,reader,on,which,calling,methods,to,specify,types,of,the,vertex,id,vertex,value,and,edge,value,returns,a,graph,see,org,apache,flink,graph,graph,csv,reader,types,class,class,class,see,org,apache,flink,graph,graph,csv,reader,vertex,types,class,class,see,org,apache,flink,graph,graph,csv,reader,edge,types,class,class,see,org,apache,flink,graph,graph,csv,reader,key,type,class;public,static,graph,csv,reader,from,csv,reader,string,vertices,path,string,edges,path,execution,environment,context,return,new,graph,csv,reader,vertices,path,edges,path,context
Graph -> public static GraphCsvReader fromCsvReader(String verticesPath, String edgesPath, ExecutionEnvironment context);1481881009;Creates a Graph from a CSV file of vertices and a CSV file of edges.__@param verticesPath path to a CSV file with the Vertex data._@param edgesPath path to a CSV file with the Edge data_@param context the Flink execution environment._@return An instance of {@link org.apache.flink.graph.GraphCsvReader},_on which calling methods to specify types of the Vertex ID, Vertex value and Edge value returns a Graph.__@see org.apache.flink.graph.GraphCsvReader#types(Class, Class, Class)_@see org.apache.flink.graph.GraphCsvReader#vertexTypes(Class, Class)_@see org.apache.flink.graph.GraphCsvReader#edgeTypes(Class, Class)_@see org.apache.flink.graph.GraphCsvReader#keyType(Class);public static GraphCsvReader fromCsvReader(String verticesPath, String edgesPath, ExecutionEnvironment context) {_		return new GraphCsvReader(verticesPath, edgesPath, context)__	};creates,a,graph,from,a,csv,file,of,vertices,and,a,csv,file,of,edges,param,vertices,path,path,to,a,csv,file,with,the,vertex,data,param,edges,path,path,to,a,csv,file,with,the,edge,data,param,context,the,flink,execution,environment,return,an,instance,of,link,org,apache,flink,graph,graph,csv,reader,on,which,calling,methods,to,specify,types,of,the,vertex,id,vertex,value,and,edge,value,returns,a,graph,see,org,apache,flink,graph,graph,csv,reader,types,class,class,class,see,org,apache,flink,graph,graph,csv,reader,vertex,types,class,class,see,org,apache,flink,graph,graph,csv,reader,edge,types,class,class,see,org,apache,flink,graph,graph,csv,reader,key,type,class;public,static,graph,csv,reader,from,csv,reader,string,vertices,path,string,edges,path,execution,environment,context,return,new,graph,csv,reader,vertices,path,edges,path,context
Graph -> public static GraphCsvReader fromCsvReader(String verticesPath, String edgesPath, ExecutionEnvironment context);1484160227;Creates a Graph from a CSV file of vertices and a CSV file of edges.__@param verticesPath path to a CSV file with the Vertex data._@param edgesPath path to a CSV file with the Edge data_@param context the Flink execution environment._@return An instance of {@link org.apache.flink.graph.GraphCsvReader},_on which calling methods to specify types of the Vertex ID, Vertex value and Edge value returns a Graph.__@see org.apache.flink.graph.GraphCsvReader#types(Class, Class, Class)_@see org.apache.flink.graph.GraphCsvReader#vertexTypes(Class, Class)_@see org.apache.flink.graph.GraphCsvReader#edgeTypes(Class, Class)_@see org.apache.flink.graph.GraphCsvReader#keyType(Class);public static GraphCsvReader fromCsvReader(String verticesPath, String edgesPath, ExecutionEnvironment context) {_		return new GraphCsvReader(verticesPath, edgesPath, context)__	};creates,a,graph,from,a,csv,file,of,vertices,and,a,csv,file,of,edges,param,vertices,path,path,to,a,csv,file,with,the,vertex,data,param,edges,path,path,to,a,csv,file,with,the,edge,data,param,context,the,flink,execution,environment,return,an,instance,of,link,org,apache,flink,graph,graph,csv,reader,on,which,calling,methods,to,specify,types,of,the,vertex,id,vertex,value,and,edge,value,returns,a,graph,see,org,apache,flink,graph,graph,csv,reader,types,class,class,class,see,org,apache,flink,graph,graph,csv,reader,vertex,types,class,class,see,org,apache,flink,graph,graph,csv,reader,edge,types,class,class,see,org,apache,flink,graph,graph,csv,reader,key,type,class;public,static,graph,csv,reader,from,csv,reader,string,vertices,path,string,edges,path,execution,environment,context,return,new,graph,csv,reader,vertices,path,edges,path,context
Graph -> public static GraphCsvReader fromCsvReader(String verticesPath, String edgesPath, ExecutionEnvironment context);1484685504;Creates a Graph from a CSV file of vertices and a CSV file of edges.__@param verticesPath path to a CSV file with the Vertex data._@param edgesPath path to a CSV file with the Edge data_@param context the Flink execution environment._@return An instance of {@link org.apache.flink.graph.GraphCsvReader},_on which calling methods to specify types of the Vertex ID, Vertex value and Edge value returns a Graph.__@see org.apache.flink.graph.GraphCsvReader#types(Class, Class, Class)_@see org.apache.flink.graph.GraphCsvReader#vertexTypes(Class, Class)_@see org.apache.flink.graph.GraphCsvReader#edgeTypes(Class, Class)_@see org.apache.flink.graph.GraphCsvReader#keyType(Class);public static GraphCsvReader fromCsvReader(String verticesPath, String edgesPath, ExecutionEnvironment context) {_		return new GraphCsvReader(verticesPath, edgesPath, context)__	};creates,a,graph,from,a,csv,file,of,vertices,and,a,csv,file,of,edges,param,vertices,path,path,to,a,csv,file,with,the,vertex,data,param,edges,path,path,to,a,csv,file,with,the,edge,data,param,context,the,flink,execution,environment,return,an,instance,of,link,org,apache,flink,graph,graph,csv,reader,on,which,calling,methods,to,specify,types,of,the,vertex,id,vertex,value,and,edge,value,returns,a,graph,see,org,apache,flink,graph,graph,csv,reader,types,class,class,class,see,org,apache,flink,graph,graph,csv,reader,vertex,types,class,class,see,org,apache,flink,graph,graph,csv,reader,edge,types,class,class,see,org,apache,flink,graph,graph,csv,reader,key,type,class;public,static,graph,csv,reader,from,csv,reader,string,vertices,path,string,edges,path,execution,environment,context,return,new,graph,csv,reader,vertices,path,edges,path,context
Graph -> public static GraphCsvReader fromCsvReader(String verticesPath, String edgesPath, ExecutionEnvironment context);1489068942;Creates a Graph from a CSV file of vertices and a CSV file of edges.__@param verticesPath path to a CSV file with the Vertex data._@param edgesPath path to a CSV file with the Edge data_@param context the Flink execution environment._@return An instance of {@link org.apache.flink.graph.GraphCsvReader},_on which calling methods to specify types of the Vertex ID, Vertex value and Edge value returns a Graph.__@see org.apache.flink.graph.GraphCsvReader#types(Class, Class, Class)_@see org.apache.flink.graph.GraphCsvReader#vertexTypes(Class, Class)_@see org.apache.flink.graph.GraphCsvReader#edgeTypes(Class, Class)_@see org.apache.flink.graph.GraphCsvReader#keyType(Class);public static GraphCsvReader fromCsvReader(String verticesPath, String edgesPath, ExecutionEnvironment context) {_		return new GraphCsvReader(verticesPath, edgesPath, context)__	};creates,a,graph,from,a,csv,file,of,vertices,and,a,csv,file,of,edges,param,vertices,path,path,to,a,csv,file,with,the,vertex,data,param,edges,path,path,to,a,csv,file,with,the,edge,data,param,context,the,flink,execution,environment,return,an,instance,of,link,org,apache,flink,graph,graph,csv,reader,on,which,calling,methods,to,specify,types,of,the,vertex,id,vertex,value,and,edge,value,returns,a,graph,see,org,apache,flink,graph,graph,csv,reader,types,class,class,class,see,org,apache,flink,graph,graph,csv,reader,vertex,types,class,class,see,org,apache,flink,graph,graph,csv,reader,edge,types,class,class,see,org,apache,flink,graph,graph,csv,reader,key,type,class;public,static,graph,csv,reader,from,csv,reader,string,vertices,path,string,edges,path,execution,environment,context,return,new,graph,csv,reader,vertices,path,edges,path,context
Graph -> public static GraphCsvReader fromCsvReader(String verticesPath, String edgesPath, ExecutionEnvironment context);1490973446;Creates a Graph from a CSV file of vertices and a CSV file of edges.__@param verticesPath path to a CSV file with the Vertex data._@param edgesPath path to a CSV file with the Edge data_@param context the Flink execution environment._@return An instance of {@link org.apache.flink.graph.GraphCsvReader},_on which calling methods to specify types of the Vertex ID, Vertex value and Edge value returns a Graph.__@see org.apache.flink.graph.GraphCsvReader#types(Class, Class, Class)_@see org.apache.flink.graph.GraphCsvReader#vertexTypes(Class, Class)_@see org.apache.flink.graph.GraphCsvReader#edgeTypes(Class, Class)_@see org.apache.flink.graph.GraphCsvReader#keyType(Class);public static GraphCsvReader fromCsvReader(String verticesPath, String edgesPath, ExecutionEnvironment context) {_		return new GraphCsvReader(verticesPath, edgesPath, context)__	};creates,a,graph,from,a,csv,file,of,vertices,and,a,csv,file,of,edges,param,vertices,path,path,to,a,csv,file,with,the,vertex,data,param,edges,path,path,to,a,csv,file,with,the,edge,data,param,context,the,flink,execution,environment,return,an,instance,of,link,org,apache,flink,graph,graph,csv,reader,on,which,calling,methods,to,specify,types,of,the,vertex,id,vertex,value,and,edge,value,returns,a,graph,see,org,apache,flink,graph,graph,csv,reader,types,class,class,class,see,org,apache,flink,graph,graph,csv,reader,vertex,types,class,class,see,org,apache,flink,graph,graph,csv,reader,edge,types,class,class,see,org,apache,flink,graph,graph,csv,reader,key,type,class;public,static,graph,csv,reader,from,csv,reader,string,vertices,path,string,edges,path,execution,environment,context,return,new,graph,csv,reader,vertices,path,edges,path,context
Graph -> public static GraphCsvReader fromCsvReader(String verticesPath, String edgesPath, ExecutionEnvironment context);1495819075;Creates a Graph from a CSV file of vertices and a CSV file of edges.__@param verticesPath path to a CSV file with the Vertex data._@param edgesPath path to a CSV file with the Edge data_@param context the Flink execution environment._@return An instance of {@link org.apache.flink.graph.GraphCsvReader},_on which calling methods to specify types of the Vertex ID, Vertex value and Edge value returns a Graph.__@see org.apache.flink.graph.GraphCsvReader#types(Class, Class, Class)_@see org.apache.flink.graph.GraphCsvReader#vertexTypes(Class, Class)_@see org.apache.flink.graph.GraphCsvReader#edgeTypes(Class, Class)_@see org.apache.flink.graph.GraphCsvReader#keyType(Class);public static GraphCsvReader fromCsvReader(String verticesPath, String edgesPath, ExecutionEnvironment context) {_		return new GraphCsvReader(verticesPath, edgesPath, context)__	};creates,a,graph,from,a,csv,file,of,vertices,and,a,csv,file,of,edges,param,vertices,path,path,to,a,csv,file,with,the,vertex,data,param,edges,path,path,to,a,csv,file,with,the,edge,data,param,context,the,flink,execution,environment,return,an,instance,of,link,org,apache,flink,graph,graph,csv,reader,on,which,calling,methods,to,specify,types,of,the,vertex,id,vertex,value,and,edge,value,returns,a,graph,see,org,apache,flink,graph,graph,csv,reader,types,class,class,class,see,org,apache,flink,graph,graph,csv,reader,vertex,types,class,class,see,org,apache,flink,graph,graph,csv,reader,edge,types,class,class,see,org,apache,flink,graph,graph,csv,reader,key,type,class;public,static,graph,csv,reader,from,csv,reader,string,vertices,path,string,edges,path,execution,environment,context,return,new,graph,csv,reader,vertices,path,edges,path,context
Graph -> public static GraphCsvReader fromCsvReader(String verticesPath, String edgesPath, ExecutionEnvironment context);1502111816;Creates a Graph from a CSV file of vertices and a CSV file of edges.__@param verticesPath path to a CSV file with the Vertex data._@param edgesPath path to a CSV file with the Edge data_@param context the Flink execution environment._@return An instance of {@link org.apache.flink.graph.GraphCsvReader},_on which calling methods to specify types of the Vertex ID, Vertex value and Edge value returns a Graph.__@see org.apache.flink.graph.GraphCsvReader#types(Class, Class, Class)_@see org.apache.flink.graph.GraphCsvReader#vertexTypes(Class, Class)_@see org.apache.flink.graph.GraphCsvReader#edgeTypes(Class, Class)_@see org.apache.flink.graph.GraphCsvReader#keyType(Class);public static GraphCsvReader fromCsvReader(String verticesPath, String edgesPath, ExecutionEnvironment context) {_		return new GraphCsvReader(verticesPath, edgesPath, context)__	};creates,a,graph,from,a,csv,file,of,vertices,and,a,csv,file,of,edges,param,vertices,path,path,to,a,csv,file,with,the,vertex,data,param,edges,path,path,to,a,csv,file,with,the,edge,data,param,context,the,flink,execution,environment,return,an,instance,of,link,org,apache,flink,graph,graph,csv,reader,on,which,calling,methods,to,specify,types,of,the,vertex,id,vertex,value,and,edge,value,returns,a,graph,see,org,apache,flink,graph,graph,csv,reader,types,class,class,class,see,org,apache,flink,graph,graph,csv,reader,vertex,types,class,class,see,org,apache,flink,graph,graph,csv,reader,edge,types,class,class,see,org,apache,flink,graph,graph,csv,reader,key,type,class;public,static,graph,csv,reader,from,csv,reader,string,vertices,path,string,edges,path,execution,environment,context,return,new,graph,csv,reader,vertices,path,edges,path,context
Graph -> public <M> Graph<K, VV, EV> runGatherSumApplyIteration( 			GatherFunction<VV, EV, M> gatherFunction, SumFunction<VV, EV, M> sumFunction, 			ApplyFunction<K, VV, M> applyFunction, int maximumNumberOfIterations);1444404795;Runs a Gather-Sum-Apply iteration on the graph._No configuration options are provided.__@param gatherFunction the gather function collects information about adjacent vertices and edges_@param sumFunction the sum function aggregates the gathered information_@param applyFunction the apply function updates the vertex values with the aggregates_@param maximumNumberOfIterations maximum number of iterations to perform_@param <M> the intermediate type used between gather, sum and apply__@return the updated Graph after the gather-sum-apply iteration has converged or_after maximumNumberOfIterations.;public <M> Graph<K, VV, EV> runGatherSumApplyIteration(_			GatherFunction<VV, EV, M> gatherFunction, SumFunction<VV, EV, M> sumFunction,_			ApplyFunction<K, VV, M> applyFunction, int maximumNumberOfIterations) {__		return this.runGatherSumApplyIteration(gatherFunction, sumFunction, applyFunction,_				maximumNumberOfIterations, null)__	};runs,a,gather,sum,apply,iteration,on,the,graph,no,configuration,options,are,provided,param,gather,function,the,gather,function,collects,information,about,adjacent,vertices,and,edges,param,sum,function,the,sum,function,aggregates,the,gathered,information,param,apply,function,the,apply,function,updates,the,vertex,values,with,the,aggregates,param,maximum,number,of,iterations,maximum,number,of,iterations,to,perform,param,m,the,intermediate,type,used,between,gather,sum,and,apply,return,the,updated,graph,after,the,gather,sum,apply,iteration,has,converged,or,after,maximum,number,of,iterations;public,m,graph,k,vv,ev,run,gather,sum,apply,iteration,gather,function,vv,ev,m,gather,function,sum,function,vv,ev,m,sum,function,apply,function,k,vv,m,apply,function,int,maximum,number,of,iterations,return,this,run,gather,sum,apply,iteration,gather,function,sum,function,apply,function,maximum,number,of,iterations,null
Graph -> public <M> Graph<K, VV, EV> runGatherSumApplyIteration( 			GatherFunction<VV, EV, M> gatherFunction, SumFunction<VV, EV, M> sumFunction, 			ApplyFunction<K, VV, M> applyFunction, int maximumNumberOfIterations);1445261977;Runs a Gather-Sum-Apply iteration on the graph._No configuration options are provided.__@param gatherFunction the gather function collects information about adjacent vertices and edges_@param sumFunction the sum function aggregates the gathered information_@param applyFunction the apply function updates the vertex values with the aggregates_@param maximumNumberOfIterations maximum number of iterations to perform_@param <M> the intermediate type used between gather, sum and apply__@return the updated Graph after the gather-sum-apply iteration has converged or_after maximumNumberOfIterations.;public <M> Graph<K, VV, EV> runGatherSumApplyIteration(_			GatherFunction<VV, EV, M> gatherFunction, SumFunction<VV, EV, M> sumFunction,_			ApplyFunction<K, VV, M> applyFunction, int maximumNumberOfIterations) {__		return this.runGatherSumApplyIteration(gatherFunction, sumFunction, applyFunction,_				maximumNumberOfIterations, null)__	};runs,a,gather,sum,apply,iteration,on,the,graph,no,configuration,options,are,provided,param,gather,function,the,gather,function,collects,information,about,adjacent,vertices,and,edges,param,sum,function,the,sum,function,aggregates,the,gathered,information,param,apply,function,the,apply,function,updates,the,vertex,values,with,the,aggregates,param,maximum,number,of,iterations,maximum,number,of,iterations,to,perform,param,m,the,intermediate,type,used,between,gather,sum,and,apply,return,the,updated,graph,after,the,gather,sum,apply,iteration,has,converged,or,after,maximum,number,of,iterations;public,m,graph,k,vv,ev,run,gather,sum,apply,iteration,gather,function,vv,ev,m,gather,function,sum,function,vv,ev,m,sum,function,apply,function,k,vv,m,apply,function,int,maximum,number,of,iterations,return,this,run,gather,sum,apply,iteration,gather,function,sum,function,apply,function,maximum,number,of,iterations,null
Graph -> public <M> Graph<K, VV, EV> runGatherSumApplyIteration( 			GatherFunction<VV, EV, M> gatherFunction, SumFunction<VV, EV, M> sumFunction, 			ApplyFunction<K, VV, M> applyFunction, int maximumNumberOfIterations);1445854323;Runs a Gather-Sum-Apply iteration on the graph._No configuration options are provided.__@param gatherFunction the gather function collects information about adjacent vertices and edges_@param sumFunction the sum function aggregates the gathered information_@param applyFunction the apply function updates the vertex values with the aggregates_@param maximumNumberOfIterations maximum number of iterations to perform_@param <M> the intermediate type used between gather, sum and apply__@return the updated Graph after the gather-sum-apply iteration has converged or_after maximumNumberOfIterations.;public <M> Graph<K, VV, EV> runGatherSumApplyIteration(_			GatherFunction<VV, EV, M> gatherFunction, SumFunction<VV, EV, M> sumFunction,_			ApplyFunction<K, VV, M> applyFunction, int maximumNumberOfIterations) {__		return this.runGatherSumApplyIteration(gatherFunction, sumFunction, applyFunction,_				maximumNumberOfIterations, null)__	};runs,a,gather,sum,apply,iteration,on,the,graph,no,configuration,options,are,provided,param,gather,function,the,gather,function,collects,information,about,adjacent,vertices,and,edges,param,sum,function,the,sum,function,aggregates,the,gathered,information,param,apply,function,the,apply,function,updates,the,vertex,values,with,the,aggregates,param,maximum,number,of,iterations,maximum,number,of,iterations,to,perform,param,m,the,intermediate,type,used,between,gather,sum,and,apply,return,the,updated,graph,after,the,gather,sum,apply,iteration,has,converged,or,after,maximum,number,of,iterations;public,m,graph,k,vv,ev,run,gather,sum,apply,iteration,gather,function,vv,ev,m,gather,function,sum,function,vv,ev,m,sum,function,apply,function,k,vv,m,apply,function,int,maximum,number,of,iterations,return,this,run,gather,sum,apply,iteration,gather,function,sum,function,apply,function,maximum,number,of,iterations,null
Graph -> public <M> Graph<K, VV, EV> runGatherSumApplyIteration( 			GatherFunction<VV, EV, M> gatherFunction, SumFunction<VV, EV, M> sumFunction, 			ApplyFunction<K, VV, M> applyFunction, int maximumNumberOfIterations);1446112342;Runs a Gather-Sum-Apply iteration on the graph._No configuration options are provided.__@param gatherFunction the gather function collects information about adjacent vertices and edges_@param sumFunction the sum function aggregates the gathered information_@param applyFunction the apply function updates the vertex values with the aggregates_@param maximumNumberOfIterations maximum number of iterations to perform_@param <M> the intermediate type used between gather, sum and apply__@return the updated Graph after the gather-sum-apply iteration has converged or_after maximumNumberOfIterations.;public <M> Graph<K, VV, EV> runGatherSumApplyIteration(_			GatherFunction<VV, EV, M> gatherFunction, SumFunction<VV, EV, M> sumFunction,_			ApplyFunction<K, VV, M> applyFunction, int maximumNumberOfIterations) {__		return this.runGatherSumApplyIteration(gatherFunction, sumFunction, applyFunction,_				maximumNumberOfIterations, null)__	};runs,a,gather,sum,apply,iteration,on,the,graph,no,configuration,options,are,provided,param,gather,function,the,gather,function,collects,information,about,adjacent,vertices,and,edges,param,sum,function,the,sum,function,aggregates,the,gathered,information,param,apply,function,the,apply,function,updates,the,vertex,values,with,the,aggregates,param,maximum,number,of,iterations,maximum,number,of,iterations,to,perform,param,m,the,intermediate,type,used,between,gather,sum,and,apply,return,the,updated,graph,after,the,gather,sum,apply,iteration,has,converged,or,after,maximum,number,of,iterations;public,m,graph,k,vv,ev,run,gather,sum,apply,iteration,gather,function,vv,ev,m,gather,function,sum,function,vv,ev,m,sum,function,apply,function,k,vv,m,apply,function,int,maximum,number,of,iterations,return,this,run,gather,sum,apply,iteration,gather,function,sum,function,apply,function,maximum,number,of,iterations,null
Graph -> public <M> Graph<K, VV, EV> runGatherSumApplyIteration( 			GatherFunction<VV, EV, M> gatherFunction, SumFunction<VV, EV, M> sumFunction, 			ApplyFunction<K, VV, M> applyFunction, int maximumNumberOfIterations);1447073368;Runs a Gather-Sum-Apply iteration on the graph._No configuration options are provided.__@param gatherFunction the gather function collects information about adjacent vertices and edges_@param sumFunction the sum function aggregates the gathered information_@param applyFunction the apply function updates the vertex values with the aggregates_@param maximumNumberOfIterations maximum number of iterations to perform_@param <M> the intermediate type used between gather, sum and apply__@return the updated Graph after the gather-sum-apply iteration has converged or_after maximumNumberOfIterations.;public <M> Graph<K, VV, EV> runGatherSumApplyIteration(_			GatherFunction<VV, EV, M> gatherFunction, SumFunction<VV, EV, M> sumFunction,_			ApplyFunction<K, VV, M> applyFunction, int maximumNumberOfIterations) {__		return this.runGatherSumApplyIteration(gatherFunction, sumFunction, applyFunction,_				maximumNumberOfIterations, null)__	};runs,a,gather,sum,apply,iteration,on,the,graph,no,configuration,options,are,provided,param,gather,function,the,gather,function,collects,information,about,adjacent,vertices,and,edges,param,sum,function,the,sum,function,aggregates,the,gathered,information,param,apply,function,the,apply,function,updates,the,vertex,values,with,the,aggregates,param,maximum,number,of,iterations,maximum,number,of,iterations,to,perform,param,m,the,intermediate,type,used,between,gather,sum,and,apply,return,the,updated,graph,after,the,gather,sum,apply,iteration,has,converged,or,after,maximum,number,of,iterations;public,m,graph,k,vv,ev,run,gather,sum,apply,iteration,gather,function,vv,ev,m,gather,function,sum,function,vv,ev,m,sum,function,apply,function,k,vv,m,apply,function,int,maximum,number,of,iterations,return,this,run,gather,sum,apply,iteration,gather,function,sum,function,apply,function,maximum,number,of,iterations,null
Graph -> public <M> Graph<K, VV, EV> runGatherSumApplyIteration( 			GatherFunction<VV, EV, M> gatherFunction, SumFunction<VV, EV, M> sumFunction, 			ApplyFunction<K, VV, M> applyFunction, int maximumNumberOfIterations);1454404649;Runs a Gather-Sum-Apply iteration on the graph._No configuration options are provided.__@param gatherFunction the gather function collects information about adjacent vertices and edges_@param sumFunction the sum function aggregates the gathered information_@param applyFunction the apply function updates the vertex values with the aggregates_@param maximumNumberOfIterations maximum number of iterations to perform_@param <M> the intermediate type used between gather, sum and apply__@return the updated Graph after the gather-sum-apply iteration has converged or_after maximumNumberOfIterations.;public <M> Graph<K, VV, EV> runGatherSumApplyIteration(_			GatherFunction<VV, EV, M> gatherFunction, SumFunction<VV, EV, M> sumFunction,_			ApplyFunction<K, VV, M> applyFunction, int maximumNumberOfIterations) {__		return this.runGatherSumApplyIteration(gatherFunction, sumFunction, applyFunction,_				maximumNumberOfIterations, null)__	};runs,a,gather,sum,apply,iteration,on,the,graph,no,configuration,options,are,provided,param,gather,function,the,gather,function,collects,information,about,adjacent,vertices,and,edges,param,sum,function,the,sum,function,aggregates,the,gathered,information,param,apply,function,the,apply,function,updates,the,vertex,values,with,the,aggregates,param,maximum,number,of,iterations,maximum,number,of,iterations,to,perform,param,m,the,intermediate,type,used,between,gather,sum,and,apply,return,the,updated,graph,after,the,gather,sum,apply,iteration,has,converged,or,after,maximum,number,of,iterations;public,m,graph,k,vv,ev,run,gather,sum,apply,iteration,gather,function,vv,ev,m,gather,function,sum,function,vv,ev,m,sum,function,apply,function,k,vv,m,apply,function,int,maximum,number,of,iterations,return,this,run,gather,sum,apply,iteration,gather,function,sum,function,apply,function,maximum,number,of,iterations,null
Graph -> public <M> Graph<K, VV, EV> runGatherSumApplyIteration( 			GatherFunction<VV, EV, M> gatherFunction, SumFunction<VV, EV, M> sumFunction, 			ApplyFunction<K, VV, M> applyFunction, int maximumNumberOfIterations);1458583829;Runs a Gather-Sum-Apply iteration on the graph._No configuration options are provided.__@param gatherFunction the gather function collects information about adjacent vertices and edges_@param sumFunction the sum function aggregates the gathered information_@param applyFunction the apply function updates the vertex values with the aggregates_@param maximumNumberOfIterations maximum number of iterations to perform_@param <M> the intermediate type used between gather, sum and apply__@return the updated Graph after the gather-sum-apply iteration has converged or_after maximumNumberOfIterations.;public <M> Graph<K, VV, EV> runGatherSumApplyIteration(_			GatherFunction<VV, EV, M> gatherFunction, SumFunction<VV, EV, M> sumFunction,_			ApplyFunction<K, VV, M> applyFunction, int maximumNumberOfIterations) {__		return this.runGatherSumApplyIteration(gatherFunction, sumFunction, applyFunction,_				maximumNumberOfIterations, null)__	};runs,a,gather,sum,apply,iteration,on,the,graph,no,configuration,options,are,provided,param,gather,function,the,gather,function,collects,information,about,adjacent,vertices,and,edges,param,sum,function,the,sum,function,aggregates,the,gathered,information,param,apply,function,the,apply,function,updates,the,vertex,values,with,the,aggregates,param,maximum,number,of,iterations,maximum,number,of,iterations,to,perform,param,m,the,intermediate,type,used,between,gather,sum,and,apply,return,the,updated,graph,after,the,gather,sum,apply,iteration,has,converged,or,after,maximum,number,of,iterations;public,m,graph,k,vv,ev,run,gather,sum,apply,iteration,gather,function,vv,ev,m,gather,function,sum,function,vv,ev,m,sum,function,apply,function,k,vv,m,apply,function,int,maximum,number,of,iterations,return,this,run,gather,sum,apply,iteration,gather,function,sum,function,apply,function,maximum,number,of,iterations,null
Graph -> public <M> Graph<K, VV, EV> runGatherSumApplyIteration( 			GatherFunction<VV, EV, M> gatherFunction, SumFunction<VV, EV, M> sumFunction, 			ApplyFunction<K, VV, M> applyFunction, int maximumNumberOfIterations);1458583829;Runs a Gather-Sum-Apply iteration on the graph._No configuration options are provided.__@param gatherFunction the gather function collects information about adjacent vertices and edges_@param sumFunction the sum function aggregates the gathered information_@param applyFunction the apply function updates the vertex values with the aggregates_@param maximumNumberOfIterations maximum number of iterations to perform_@param <M> the intermediate type used between gather, sum and apply__@return the updated Graph after the gather-sum-apply iteration has converged or_after maximumNumberOfIterations.;public <M> Graph<K, VV, EV> runGatherSumApplyIteration(_			GatherFunction<VV, EV, M> gatherFunction, SumFunction<VV, EV, M> sumFunction,_			ApplyFunction<K, VV, M> applyFunction, int maximumNumberOfIterations) {__		return this.runGatherSumApplyIteration(gatherFunction, sumFunction, applyFunction,_				maximumNumberOfIterations, null)__	};runs,a,gather,sum,apply,iteration,on,the,graph,no,configuration,options,are,provided,param,gather,function,the,gather,function,collects,information,about,adjacent,vertices,and,edges,param,sum,function,the,sum,function,aggregates,the,gathered,information,param,apply,function,the,apply,function,updates,the,vertex,values,with,the,aggregates,param,maximum,number,of,iterations,maximum,number,of,iterations,to,perform,param,m,the,intermediate,type,used,between,gather,sum,and,apply,return,the,updated,graph,after,the,gather,sum,apply,iteration,has,converged,or,after,maximum,number,of,iterations;public,m,graph,k,vv,ev,run,gather,sum,apply,iteration,gather,function,vv,ev,m,gather,function,sum,function,vv,ev,m,sum,function,apply,function,k,vv,m,apply,function,int,maximum,number,of,iterations,return,this,run,gather,sum,apply,iteration,gather,function,sum,function,apply,function,maximum,number,of,iterations,null
Graph -> public <M> Graph<K, VV, EV> runGatherSumApplyIteration( 			GatherFunction<VV, EV, M> gatherFunction, SumFunction<VV, EV, M> sumFunction, 			ApplyFunction<K, VV, M> applyFunction, int maximumNumberOfIterations);1462100316;Runs a Gather-Sum-Apply iteration on the graph._No configuration options are provided.__@param gatherFunction the gather function collects information about adjacent vertices and edges_@param sumFunction the sum function aggregates the gathered information_@param applyFunction the apply function updates the vertex values with the aggregates_@param maximumNumberOfIterations maximum number of iterations to perform_@param <M> the intermediate type used between gather, sum and apply__@return the updated Graph after the gather-sum-apply iteration has converged or_after maximumNumberOfIterations.;public <M> Graph<K, VV, EV> runGatherSumApplyIteration(_			GatherFunction<VV, EV, M> gatherFunction, SumFunction<VV, EV, M> sumFunction,_			ApplyFunction<K, VV, M> applyFunction, int maximumNumberOfIterations) {__		return this.runGatherSumApplyIteration(gatherFunction, sumFunction, applyFunction,_				maximumNumberOfIterations, null)__	};runs,a,gather,sum,apply,iteration,on,the,graph,no,configuration,options,are,provided,param,gather,function,the,gather,function,collects,information,about,adjacent,vertices,and,edges,param,sum,function,the,sum,function,aggregates,the,gathered,information,param,apply,function,the,apply,function,updates,the,vertex,values,with,the,aggregates,param,maximum,number,of,iterations,maximum,number,of,iterations,to,perform,param,m,the,intermediate,type,used,between,gather,sum,and,apply,return,the,updated,graph,after,the,gather,sum,apply,iteration,has,converged,or,after,maximum,number,of,iterations;public,m,graph,k,vv,ev,run,gather,sum,apply,iteration,gather,function,vv,ev,m,gather,function,sum,function,vv,ev,m,sum,function,apply,function,k,vv,m,apply,function,int,maximum,number,of,iterations,return,this,run,gather,sum,apply,iteration,gather,function,sum,function,apply,function,maximum,number,of,iterations,null
Graph -> public <M> Graph<K, VV, EV> runGatherSumApplyIteration( 			GatherFunction<VV, EV, M> gatherFunction, SumFunction<VV, EV, M> sumFunction, 			ApplyFunction<K, VV, M> applyFunction, int maximumNumberOfIterations);1462100316;Runs a Gather-Sum-Apply iteration on the graph._No configuration options are provided.__@param gatherFunction the gather function collects information about adjacent vertices and edges_@param sumFunction the sum function aggregates the gathered information_@param applyFunction the apply function updates the vertex values with the aggregates_@param maximumNumberOfIterations maximum number of iterations to perform_@param <M> the intermediate type used between gather, sum and apply__@return the updated Graph after the gather-sum-apply iteration has converged or_after maximumNumberOfIterations.;public <M> Graph<K, VV, EV> runGatherSumApplyIteration(_			GatherFunction<VV, EV, M> gatherFunction, SumFunction<VV, EV, M> sumFunction,_			ApplyFunction<K, VV, M> applyFunction, int maximumNumberOfIterations) {__		return this.runGatherSumApplyIteration(gatherFunction, sumFunction, applyFunction,_				maximumNumberOfIterations, null)__	};runs,a,gather,sum,apply,iteration,on,the,graph,no,configuration,options,are,provided,param,gather,function,the,gather,function,collects,information,about,adjacent,vertices,and,edges,param,sum,function,the,sum,function,aggregates,the,gathered,information,param,apply,function,the,apply,function,updates,the,vertex,values,with,the,aggregates,param,maximum,number,of,iterations,maximum,number,of,iterations,to,perform,param,m,the,intermediate,type,used,between,gather,sum,and,apply,return,the,updated,graph,after,the,gather,sum,apply,iteration,has,converged,or,after,maximum,number,of,iterations;public,m,graph,k,vv,ev,run,gather,sum,apply,iteration,gather,function,vv,ev,m,gather,function,sum,function,vv,ev,m,sum,function,apply,function,k,vv,m,apply,function,int,maximum,number,of,iterations,return,this,run,gather,sum,apply,iteration,gather,function,sum,function,apply,function,maximum,number,of,iterations,null
Graph -> public <M> Graph<K, VV, EV> runGatherSumApplyIteration( 			GatherFunction<VV, EV, M> gatherFunction, SumFunction<VV, EV, M> sumFunction, 			ApplyFunction<K, VV, M> applyFunction, int maximumNumberOfIterations);1462205213;Runs a Gather-Sum-Apply iteration on the graph._No configuration options are provided.__@param gatherFunction the gather function collects information about adjacent vertices and edges_@param sumFunction the sum function aggregates the gathered information_@param applyFunction the apply function updates the vertex values with the aggregates_@param maximumNumberOfIterations maximum number of iterations to perform_@param <M> the intermediate type used between gather, sum and apply__@return the updated Graph after the gather-sum-apply iteration has converged or_after maximumNumberOfIterations.;public <M> Graph<K, VV, EV> runGatherSumApplyIteration(_			GatherFunction<VV, EV, M> gatherFunction, SumFunction<VV, EV, M> sumFunction,_			ApplyFunction<K, VV, M> applyFunction, int maximumNumberOfIterations) {__		return this.runGatherSumApplyIteration(gatherFunction, sumFunction, applyFunction,_				maximumNumberOfIterations, null)__	};runs,a,gather,sum,apply,iteration,on,the,graph,no,configuration,options,are,provided,param,gather,function,the,gather,function,collects,information,about,adjacent,vertices,and,edges,param,sum,function,the,sum,function,aggregates,the,gathered,information,param,apply,function,the,apply,function,updates,the,vertex,values,with,the,aggregates,param,maximum,number,of,iterations,maximum,number,of,iterations,to,perform,param,m,the,intermediate,type,used,between,gather,sum,and,apply,return,the,updated,graph,after,the,gather,sum,apply,iteration,has,converged,or,after,maximum,number,of,iterations;public,m,graph,k,vv,ev,run,gather,sum,apply,iteration,gather,function,vv,ev,m,gather,function,sum,function,vv,ev,m,sum,function,apply,function,k,vv,m,apply,function,int,maximum,number,of,iterations,return,this,run,gather,sum,apply,iteration,gather,function,sum,function,apply,function,maximum,number,of,iterations,null
Graph -> public <M> Graph<K, VV, EV> runGatherSumApplyIteration( 			GatherFunction<VV, EV, M> gatherFunction, SumFunction<VV, EV, M> sumFunction, 			ApplyFunction<K, VV, M> applyFunction, int maximumNumberOfIterations);1462208859;Runs a Gather-Sum-Apply iteration on the graph._No configuration options are provided.__@param gatherFunction the gather function collects information about adjacent vertices and edges_@param sumFunction the sum function aggregates the gathered information_@param applyFunction the apply function updates the vertex values with the aggregates_@param maximumNumberOfIterations maximum number of iterations to perform_@param <M> the intermediate type used between gather, sum and apply__@return the updated Graph after the gather-sum-apply iteration has converged or_after maximumNumberOfIterations.;public <M> Graph<K, VV, EV> runGatherSumApplyIteration(_			GatherFunction<VV, EV, M> gatherFunction, SumFunction<VV, EV, M> sumFunction,_			ApplyFunction<K, VV, M> applyFunction, int maximumNumberOfIterations) {__		return this.runGatherSumApplyIteration(gatherFunction, sumFunction, applyFunction,_				maximumNumberOfIterations, null)__	};runs,a,gather,sum,apply,iteration,on,the,graph,no,configuration,options,are,provided,param,gather,function,the,gather,function,collects,information,about,adjacent,vertices,and,edges,param,sum,function,the,sum,function,aggregates,the,gathered,information,param,apply,function,the,apply,function,updates,the,vertex,values,with,the,aggregates,param,maximum,number,of,iterations,maximum,number,of,iterations,to,perform,param,m,the,intermediate,type,used,between,gather,sum,and,apply,return,the,updated,graph,after,the,gather,sum,apply,iteration,has,converged,or,after,maximum,number,of,iterations;public,m,graph,k,vv,ev,run,gather,sum,apply,iteration,gather,function,vv,ev,m,gather,function,sum,function,vv,ev,m,sum,function,apply,function,k,vv,m,apply,function,int,maximum,number,of,iterations,return,this,run,gather,sum,apply,iteration,gather,function,sum,function,apply,function,maximum,number,of,iterations,null
Graph -> public <M> Graph<K, VV, EV> runGatherSumApplyIteration( 			GatherFunction<VV, EV, M> gatherFunction, SumFunction<VV, EV, M> sumFunction, 			ApplyFunction<K, VV, M> applyFunction, int maximumNumberOfIterations);1462809297;Runs a Gather-Sum-Apply iteration on the graph._No configuration options are provided.__@param gatherFunction the gather function collects information about adjacent vertices and edges_@param sumFunction the sum function aggregates the gathered information_@param applyFunction the apply function updates the vertex values with the aggregates_@param maximumNumberOfIterations maximum number of iterations to perform_@param <M> the intermediate type used between gather, sum and apply__@return the updated Graph after the gather-sum-apply iteration has converged or_after maximumNumberOfIterations.;public <M> Graph<K, VV, EV> runGatherSumApplyIteration(_			GatherFunction<VV, EV, M> gatherFunction, SumFunction<VV, EV, M> sumFunction,_			ApplyFunction<K, VV, M> applyFunction, int maximumNumberOfIterations) {__		return this.runGatherSumApplyIteration(gatherFunction, sumFunction, applyFunction,_				maximumNumberOfIterations, null)__	};runs,a,gather,sum,apply,iteration,on,the,graph,no,configuration,options,are,provided,param,gather,function,the,gather,function,collects,information,about,adjacent,vertices,and,edges,param,sum,function,the,sum,function,aggregates,the,gathered,information,param,apply,function,the,apply,function,updates,the,vertex,values,with,the,aggregates,param,maximum,number,of,iterations,maximum,number,of,iterations,to,perform,param,m,the,intermediate,type,used,between,gather,sum,and,apply,return,the,updated,graph,after,the,gather,sum,apply,iteration,has,converged,or,after,maximum,number,of,iterations;public,m,graph,k,vv,ev,run,gather,sum,apply,iteration,gather,function,vv,ev,m,gather,function,sum,function,vv,ev,m,sum,function,apply,function,k,vv,m,apply,function,int,maximum,number,of,iterations,return,this,run,gather,sum,apply,iteration,gather,function,sum,function,apply,function,maximum,number,of,iterations,null
Graph -> public <M> Graph<K, VV, EV> runGatherSumApplyIteration( 			GatherFunction<VV, EV, M> gatherFunction, SumFunction<VV, EV, M> sumFunction, 			ApplyFunction<K, VV, M> applyFunction, int maximumNumberOfIterations);1465316775;Runs a Gather-Sum-Apply iteration on the graph._No configuration options are provided.__@param gatherFunction the gather function collects information about adjacent vertices and edges_@param sumFunction the sum function aggregates the gathered information_@param applyFunction the apply function updates the vertex values with the aggregates_@param maximumNumberOfIterations maximum number of iterations to perform_@param <M> the intermediate type used between gather, sum and apply__@return the updated Graph after the gather-sum-apply iteration has converged or_after maximumNumberOfIterations.;public <M> Graph<K, VV, EV> runGatherSumApplyIteration(_			GatherFunction<VV, EV, M> gatherFunction, SumFunction<VV, EV, M> sumFunction,_			ApplyFunction<K, VV, M> applyFunction, int maximumNumberOfIterations) {__		return this.runGatherSumApplyIteration(gatherFunction, sumFunction, applyFunction,_				maximumNumberOfIterations, null)__	};runs,a,gather,sum,apply,iteration,on,the,graph,no,configuration,options,are,provided,param,gather,function,the,gather,function,collects,information,about,adjacent,vertices,and,edges,param,sum,function,the,sum,function,aggregates,the,gathered,information,param,apply,function,the,apply,function,updates,the,vertex,values,with,the,aggregates,param,maximum,number,of,iterations,maximum,number,of,iterations,to,perform,param,m,the,intermediate,type,used,between,gather,sum,and,apply,return,the,updated,graph,after,the,gather,sum,apply,iteration,has,converged,or,after,maximum,number,of,iterations;public,m,graph,k,vv,ev,run,gather,sum,apply,iteration,gather,function,vv,ev,m,gather,function,sum,function,vv,ev,m,sum,function,apply,function,k,vv,m,apply,function,int,maximum,number,of,iterations,return,this,run,gather,sum,apply,iteration,gather,function,sum,function,apply,function,maximum,number,of,iterations,null
Graph -> public <M> Graph<K, VV, EV> runGatherSumApplyIteration( 			GatherFunction<VV, EV, M> gatherFunction, SumFunction<VV, EV, M> sumFunction, 			ApplyFunction<K, VV, M> applyFunction, int maximumNumberOfIterations);1466789678;Runs a Gather-Sum-Apply iteration on the graph._No configuration options are provided.__@param gatherFunction the gather function collects information about adjacent vertices and edges_@param sumFunction the sum function aggregates the gathered information_@param applyFunction the apply function updates the vertex values with the aggregates_@param maximumNumberOfIterations maximum number of iterations to perform_@param <M> the intermediate type used between gather, sum and apply__@return the updated Graph after the gather-sum-apply iteration has converged or_after maximumNumberOfIterations.;public <M> Graph<K, VV, EV> runGatherSumApplyIteration(_			GatherFunction<VV, EV, M> gatherFunction, SumFunction<VV, EV, M> sumFunction,_			ApplyFunction<K, VV, M> applyFunction, int maximumNumberOfIterations) {__		return this.runGatherSumApplyIteration(gatherFunction, sumFunction, applyFunction,_				maximumNumberOfIterations, null)__	};runs,a,gather,sum,apply,iteration,on,the,graph,no,configuration,options,are,provided,param,gather,function,the,gather,function,collects,information,about,adjacent,vertices,and,edges,param,sum,function,the,sum,function,aggregates,the,gathered,information,param,apply,function,the,apply,function,updates,the,vertex,values,with,the,aggregates,param,maximum,number,of,iterations,maximum,number,of,iterations,to,perform,param,m,the,intermediate,type,used,between,gather,sum,and,apply,return,the,updated,graph,after,the,gather,sum,apply,iteration,has,converged,or,after,maximum,number,of,iterations;public,m,graph,k,vv,ev,run,gather,sum,apply,iteration,gather,function,vv,ev,m,gather,function,sum,function,vv,ev,m,sum,function,apply,function,k,vv,m,apply,function,int,maximum,number,of,iterations,return,this,run,gather,sum,apply,iteration,gather,function,sum,function,apply,function,maximum,number,of,iterations,null
Graph -> public <M> Graph<K, VV, EV> runGatherSumApplyIteration( 			GatherFunction<VV, EV, M> gatherFunction, SumFunction<VV, EV, M> sumFunction, 			ApplyFunction<K, VV, M> applyFunction, int maximumNumberOfIterations);1467140656;Runs a Gather-Sum-Apply iteration on the graph._No configuration options are provided.__@param gatherFunction the gather function collects information about adjacent vertices and edges_@param sumFunction the sum function aggregates the gathered information_@param applyFunction the apply function updates the vertex values with the aggregates_@param maximumNumberOfIterations maximum number of iterations to perform_@param <M> the intermediate type used between gather, sum and apply__@return the updated Graph after the gather-sum-apply iteration has converged or_after maximumNumberOfIterations.;public <M> Graph<K, VV, EV> runGatherSumApplyIteration(_			GatherFunction<VV, EV, M> gatherFunction, SumFunction<VV, EV, M> sumFunction,_			ApplyFunction<K, VV, M> applyFunction, int maximumNumberOfIterations) {__		return this.runGatherSumApplyIteration(gatherFunction, sumFunction, applyFunction,_				maximumNumberOfIterations, null)__	};runs,a,gather,sum,apply,iteration,on,the,graph,no,configuration,options,are,provided,param,gather,function,the,gather,function,collects,information,about,adjacent,vertices,and,edges,param,sum,function,the,sum,function,aggregates,the,gathered,information,param,apply,function,the,apply,function,updates,the,vertex,values,with,the,aggregates,param,maximum,number,of,iterations,maximum,number,of,iterations,to,perform,param,m,the,intermediate,type,used,between,gather,sum,and,apply,return,the,updated,graph,after,the,gather,sum,apply,iteration,has,converged,or,after,maximum,number,of,iterations;public,m,graph,k,vv,ev,run,gather,sum,apply,iteration,gather,function,vv,ev,m,gather,function,sum,function,vv,ev,m,sum,function,apply,function,k,vv,m,apply,function,int,maximum,number,of,iterations,return,this,run,gather,sum,apply,iteration,gather,function,sum,function,apply,function,maximum,number,of,iterations,null
Graph -> public Graph<K, VV, EV> union(Graph<K, VV, EV> graph);1444404795;Performs union on the vertices and edges sets of the input graphs_removing duplicate vertices but maintaining duplicate edges.__@param graph the graph to perform union with_@return a new graph;public Graph<K, VV, EV> union(Graph<K, VV, EV> graph) {__		DataSet<Vertex<K, VV>> unionedVertices = graph.getVertices().union(this.getVertices()).distinct()__		DataSet<Edge<K, EV>> unionedEdges = graph.getEdges().union(this.getEdges())__		return new Graph<K, VV, EV>(unionedVertices, unionedEdges, this.context)__	};performs,union,on,the,vertices,and,edges,sets,of,the,input,graphs,removing,duplicate,vertices,but,maintaining,duplicate,edges,param,graph,the,graph,to,perform,union,with,return,a,new,graph;public,graph,k,vv,ev,union,graph,k,vv,ev,graph,data,set,vertex,k,vv,unioned,vertices,graph,get,vertices,union,this,get,vertices,distinct,data,set,edge,k,ev,unioned,edges,graph,get,edges,union,this,get,edges,return,new,graph,k,vv,ev,unioned,vertices,unioned,edges,this,context
Graph -> public Graph<K, VV, EV> union(Graph<K, VV, EV> graph);1445261977;Performs union on the vertices and edges sets of the input graphs_removing duplicate vertices but maintaining duplicate edges.__@param graph the graph to perform union with_@return a new graph;public Graph<K, VV, EV> union(Graph<K, VV, EV> graph) {__		DataSet<Vertex<K, VV>> unionedVertices = graph.getVertices().union(this.getVertices()).distinct()__		DataSet<Edge<K, EV>> unionedEdges = graph.getEdges().union(this.getEdges())__		return new Graph<K, VV, EV>(unionedVertices, unionedEdges, this.context)__	};performs,union,on,the,vertices,and,edges,sets,of,the,input,graphs,removing,duplicate,vertices,but,maintaining,duplicate,edges,param,graph,the,graph,to,perform,union,with,return,a,new,graph;public,graph,k,vv,ev,union,graph,k,vv,ev,graph,data,set,vertex,k,vv,unioned,vertices,graph,get,vertices,union,this,get,vertices,distinct,data,set,edge,k,ev,unioned,edges,graph,get,edges,union,this,get,edges,return,new,graph,k,vv,ev,unioned,vertices,unioned,edges,this,context
Graph -> public Graph<K, VV, EV> union(Graph<K, VV, EV> graph);1445854323;Performs union on the vertices and edges sets of the input graphs_removing duplicate vertices but maintaining duplicate edges.__@param graph the graph to perform union with_@return a new graph;public Graph<K, VV, EV> union(Graph<K, VV, EV> graph) {__		DataSet<Vertex<K, VV>> unionedVertices = graph.getVertices().union(this.getVertices()).distinct()__		DataSet<Edge<K, EV>> unionedEdges = graph.getEdges().union(this.getEdges())__		return new Graph<K, VV, EV>(unionedVertices, unionedEdges, this.context)__	};performs,union,on,the,vertices,and,edges,sets,of,the,input,graphs,removing,duplicate,vertices,but,maintaining,duplicate,edges,param,graph,the,graph,to,perform,union,with,return,a,new,graph;public,graph,k,vv,ev,union,graph,k,vv,ev,graph,data,set,vertex,k,vv,unioned,vertices,graph,get,vertices,union,this,get,vertices,distinct,data,set,edge,k,ev,unioned,edges,graph,get,edges,union,this,get,edges,return,new,graph,k,vv,ev,unioned,vertices,unioned,edges,this,context
Graph -> public Graph<K, VV, EV> union(Graph<K, VV, EV> graph);1446112342;Performs union on the vertices and edges sets of the input graphs_removing duplicate vertices but maintaining duplicate edges.__@param graph the graph to perform union with_@return a new graph;public Graph<K, VV, EV> union(Graph<K, VV, EV> graph) {__		DataSet<Vertex<K, VV>> unionedVertices = graph.getVertices().union(this.getVertices()).distinct()__		DataSet<Edge<K, EV>> unionedEdges = graph.getEdges().union(this.getEdges())__		return new Graph<K, VV, EV>(unionedVertices, unionedEdges, this.context)__	};performs,union,on,the,vertices,and,edges,sets,of,the,input,graphs,removing,duplicate,vertices,but,maintaining,duplicate,edges,param,graph,the,graph,to,perform,union,with,return,a,new,graph;public,graph,k,vv,ev,union,graph,k,vv,ev,graph,data,set,vertex,k,vv,unioned,vertices,graph,get,vertices,union,this,get,vertices,distinct,data,set,edge,k,ev,unioned,edges,graph,get,edges,union,this,get,edges,return,new,graph,k,vv,ev,unioned,vertices,unioned,edges,this,context
Graph -> public Graph<K, VV, EV> union(Graph<K, VV, EV> graph);1447073368;Performs union on the vertices and edges sets of the input graphs_removing duplicate vertices but maintaining duplicate edges.__@param graph the graph to perform union with_@return a new graph;public Graph<K, VV, EV> union(Graph<K, VV, EV> graph) {_		DataSet<Vertex<K, VV>> unionedVertices = graph.getVertices().union(this.getVertices()).distinct()__		DataSet<Edge<K, EV>> unionedEdges = graph.getEdges().union(this.getEdges())__		return new Graph<K, VV, EV>(unionedVertices, unionedEdges, this.context)__	};performs,union,on,the,vertices,and,edges,sets,of,the,input,graphs,removing,duplicate,vertices,but,maintaining,duplicate,edges,param,graph,the,graph,to,perform,union,with,return,a,new,graph;public,graph,k,vv,ev,union,graph,k,vv,ev,graph,data,set,vertex,k,vv,unioned,vertices,graph,get,vertices,union,this,get,vertices,distinct,data,set,edge,k,ev,unioned,edges,graph,get,edges,union,this,get,edges,return,new,graph,k,vv,ev,unioned,vertices,unioned,edges,this,context
Graph -> public Graph<K, VV, EV> union(Graph<K, VV, EV> graph);1454404649;Performs union on the vertices and edges sets of the input graphs_removing duplicate vertices but maintaining duplicate edges.__@param graph the graph to perform union with_@return a new graph;public Graph<K, VV, EV> union(Graph<K, VV, EV> graph) {_		DataSet<Vertex<K, VV>> unionedVertices = graph.getVertices().union(this.getVertices()).distinct()__		DataSet<Edge<K, EV>> unionedEdges = graph.getEdges().union(this.getEdges())__		return new Graph<K, VV, EV>(unionedVertices, unionedEdges, this.context)__	};performs,union,on,the,vertices,and,edges,sets,of,the,input,graphs,removing,duplicate,vertices,but,maintaining,duplicate,edges,param,graph,the,graph,to,perform,union,with,return,a,new,graph;public,graph,k,vv,ev,union,graph,k,vv,ev,graph,data,set,vertex,k,vv,unioned,vertices,graph,get,vertices,union,this,get,vertices,distinct,data,set,edge,k,ev,unioned,edges,graph,get,edges,union,this,get,edges,return,new,graph,k,vv,ev,unioned,vertices,unioned,edges,this,context
Graph -> public Graph<K, VV, EV> union(Graph<K, VV, EV> graph);1458583829;Performs union on the vertices and edges sets of the input graphs_removing duplicate vertices but maintaining duplicate edges.__@param graph the graph to perform union with_@return a new graph;public Graph<K, VV, EV> union(Graph<K, VV, EV> graph) {_		DataSet<Vertex<K, VV>> unionedVertices = graph.getVertices().union(this.getVertices()).distinct()__		DataSet<Edge<K, EV>> unionedEdges = graph.getEdges().union(this.getEdges())__		return new Graph<K, VV, EV>(unionedVertices, unionedEdges, this.context)__	};performs,union,on,the,vertices,and,edges,sets,of,the,input,graphs,removing,duplicate,vertices,but,maintaining,duplicate,edges,param,graph,the,graph,to,perform,union,with,return,a,new,graph;public,graph,k,vv,ev,union,graph,k,vv,ev,graph,data,set,vertex,k,vv,unioned,vertices,graph,get,vertices,union,this,get,vertices,distinct,data,set,edge,k,ev,unioned,edges,graph,get,edges,union,this,get,edges,return,new,graph,k,vv,ev,unioned,vertices,unioned,edges,this,context
Graph -> public Graph<K, VV, EV> union(Graph<K, VV, EV> graph);1458583829;Performs union on the vertices and edges sets of the input graphs_removing duplicate vertices but maintaining duplicate edges.__@param graph the graph to perform union with_@return a new graph;public Graph<K, VV, EV> union(Graph<K, VV, EV> graph) {_		DataSet<Vertex<K, VV>> unionedVertices = graph.getVertices().union(this.getVertices()).distinct()__		DataSet<Edge<K, EV>> unionedEdges = graph.getEdges().union(this.getEdges())__		return new Graph<K, VV, EV>(unionedVertices, unionedEdges, this.context)__	};performs,union,on,the,vertices,and,edges,sets,of,the,input,graphs,removing,duplicate,vertices,but,maintaining,duplicate,edges,param,graph,the,graph,to,perform,union,with,return,a,new,graph;public,graph,k,vv,ev,union,graph,k,vv,ev,graph,data,set,vertex,k,vv,unioned,vertices,graph,get,vertices,union,this,get,vertices,distinct,data,set,edge,k,ev,unioned,edges,graph,get,edges,union,this,get,edges,return,new,graph,k,vv,ev,unioned,vertices,unioned,edges,this,context
Graph -> public Graph<K, VV, EV> union(Graph<K, VV, EV> graph);1462100316;Performs union on the vertices and edges sets of the input graphs_removing duplicate vertices but maintaining duplicate edges.__@param graph the graph to perform union with_@return a new graph;public Graph<K, VV, EV> union(Graph<K, VV, EV> graph) {_		DataSet<Vertex<K, VV>> unionedVertices = graph.getVertices().union(this.getVertices()).distinct()__		DataSet<Edge<K, EV>> unionedEdges = graph.getEdges().union(this.getEdges())__		return new Graph<K, VV, EV>(unionedVertices, unionedEdges, this.context)__	};performs,union,on,the,vertices,and,edges,sets,of,the,input,graphs,removing,duplicate,vertices,but,maintaining,duplicate,edges,param,graph,the,graph,to,perform,union,with,return,a,new,graph;public,graph,k,vv,ev,union,graph,k,vv,ev,graph,data,set,vertex,k,vv,unioned,vertices,graph,get,vertices,union,this,get,vertices,distinct,data,set,edge,k,ev,unioned,edges,graph,get,edges,union,this,get,edges,return,new,graph,k,vv,ev,unioned,vertices,unioned,edges,this,context
Graph -> public Graph<K, VV, EV> union(Graph<K, VV, EV> graph);1462100316;Performs union on the vertices and edges sets of the input graphs_removing duplicate vertices but maintaining duplicate edges.__@param graph the graph to perform union with_@return a new graph;public Graph<K, VV, EV> union(Graph<K, VV, EV> graph) {_		DataSet<Vertex<K, VV>> unionedVertices = graph.getVertices().union(this.getVertices()).distinct()__		DataSet<Edge<K, EV>> unionedEdges = graph.getEdges().union(this.getEdges())__		return new Graph<K, VV, EV>(unionedVertices, unionedEdges, this.context)__	};performs,union,on,the,vertices,and,edges,sets,of,the,input,graphs,removing,duplicate,vertices,but,maintaining,duplicate,edges,param,graph,the,graph,to,perform,union,with,return,a,new,graph;public,graph,k,vv,ev,union,graph,k,vv,ev,graph,data,set,vertex,k,vv,unioned,vertices,graph,get,vertices,union,this,get,vertices,distinct,data,set,edge,k,ev,unioned,edges,graph,get,edges,union,this,get,edges,return,new,graph,k,vv,ev,unioned,vertices,unioned,edges,this,context
Graph -> public Graph<K, VV, EV> union(Graph<K, VV, EV> graph);1462205213;Performs union on the vertices and edges sets of the input graphs_removing duplicate vertices but maintaining duplicate edges.__@param graph the graph to perform union with_@return a new graph;public Graph<K, VV, EV> union(Graph<K, VV, EV> graph) {_		DataSet<Vertex<K, VV>> unionedVertices = graph.getVertices().union(this.getVertices()).distinct()__		DataSet<Edge<K, EV>> unionedEdges = graph.getEdges().union(this.getEdges())__		return new Graph<K, VV, EV>(unionedVertices, unionedEdges, this.context)__	};performs,union,on,the,vertices,and,edges,sets,of,the,input,graphs,removing,duplicate,vertices,but,maintaining,duplicate,edges,param,graph,the,graph,to,perform,union,with,return,a,new,graph;public,graph,k,vv,ev,union,graph,k,vv,ev,graph,data,set,vertex,k,vv,unioned,vertices,graph,get,vertices,union,this,get,vertices,distinct,data,set,edge,k,ev,unioned,edges,graph,get,edges,union,this,get,edges,return,new,graph,k,vv,ev,unioned,vertices,unioned,edges,this,context
Graph -> public Graph<K, VV, EV> union(Graph<K, VV, EV> graph);1462208859;Performs union on the vertices and edges sets of the input graphs_removing duplicate vertices but maintaining duplicate edges.__@param graph the graph to perform union with_@return a new graph;public Graph<K, VV, EV> union(Graph<K, VV, EV> graph) {_		DataSet<Vertex<K, VV>> unionedVertices = graph.getVertices().union(this.getVertices()).distinct()__		DataSet<Edge<K, EV>> unionedEdges = graph.getEdges().union(this.getEdges())__		return new Graph<K, VV, EV>(unionedVertices, unionedEdges, this.context)__	};performs,union,on,the,vertices,and,edges,sets,of,the,input,graphs,removing,duplicate,vertices,but,maintaining,duplicate,edges,param,graph,the,graph,to,perform,union,with,return,a,new,graph;public,graph,k,vv,ev,union,graph,k,vv,ev,graph,data,set,vertex,k,vv,unioned,vertices,graph,get,vertices,union,this,get,vertices,distinct,data,set,edge,k,ev,unioned,edges,graph,get,edges,union,this,get,edges,return,new,graph,k,vv,ev,unioned,vertices,unioned,edges,this,context
Graph -> public Graph<K, VV, EV> union(Graph<K, VV, EV> graph);1462809297;Performs union on the vertices and edges sets of the input graphs_removing duplicate vertices but maintaining duplicate edges.__@param graph the graph to perform union with_@return a new graph;public Graph<K, VV, EV> union(Graph<K, VV, EV> graph) {_		DataSet<Vertex<K, VV>> unionedVertices = graph.getVertices().union(this.getVertices()).distinct()__		DataSet<Edge<K, EV>> unionedEdges = graph.getEdges().union(this.getEdges())__		return new Graph<K, VV, EV>(unionedVertices, unionedEdges, this.context)__	};performs,union,on,the,vertices,and,edges,sets,of,the,input,graphs,removing,duplicate,vertices,but,maintaining,duplicate,edges,param,graph,the,graph,to,perform,union,with,return,a,new,graph;public,graph,k,vv,ev,union,graph,k,vv,ev,graph,data,set,vertex,k,vv,unioned,vertices,graph,get,vertices,union,this,get,vertices,distinct,data,set,edge,k,ev,unioned,edges,graph,get,edges,union,this,get,edges,return,new,graph,k,vv,ev,unioned,vertices,unioned,edges,this,context
Graph -> public Graph<K, VV, EV> union(Graph<K, VV, EV> graph);1465316775;Performs union on the vertices and edges sets of the input graphs_removing duplicate vertices but maintaining duplicate edges.__@param graph the graph to perform union with_@return a new graph;public Graph<K, VV, EV> union(Graph<K, VV, EV> graph) {_		DataSet<Vertex<K, VV>> unionedVertices = graph.getVertices().union(this.getVertices()).distinct()__		DataSet<Edge<K, EV>> unionedEdges = graph.getEdges().union(this.getEdges())__		return new Graph<K, VV, EV>(unionedVertices, unionedEdges, this.context)__	};performs,union,on,the,vertices,and,edges,sets,of,the,input,graphs,removing,duplicate,vertices,but,maintaining,duplicate,edges,param,graph,the,graph,to,perform,union,with,return,a,new,graph;public,graph,k,vv,ev,union,graph,k,vv,ev,graph,data,set,vertex,k,vv,unioned,vertices,graph,get,vertices,union,this,get,vertices,distinct,data,set,edge,k,ev,unioned,edges,graph,get,edges,union,this,get,edges,return,new,graph,k,vv,ev,unioned,vertices,unioned,edges,this,context
Graph -> public Graph<K, VV, EV> union(Graph<K, VV, EV> graph);1466789678;Performs union on the vertices and edges sets of the input graphs_removing duplicate vertices but maintaining duplicate edges.__@param graph the graph to perform union with_@return a new graph;public Graph<K, VV, EV> union(Graph<K, VV, EV> graph) {_		DataSet<Vertex<K, VV>> unionedVertices = graph.getVertices().union(this.getVertices()).distinct()__		DataSet<Edge<K, EV>> unionedEdges = graph.getEdges().union(this.getEdges())__		return new Graph<K, VV, EV>(unionedVertices, unionedEdges, this.context)__	};performs,union,on,the,vertices,and,edges,sets,of,the,input,graphs,removing,duplicate,vertices,but,maintaining,duplicate,edges,param,graph,the,graph,to,perform,union,with,return,a,new,graph;public,graph,k,vv,ev,union,graph,k,vv,ev,graph,data,set,vertex,k,vv,unioned,vertices,graph,get,vertices,union,this,get,vertices,distinct,data,set,edge,k,ev,unioned,edges,graph,get,edges,union,this,get,edges,return,new,graph,k,vv,ev,unioned,vertices,unioned,edges,this,context
Graph -> public Graph<K, VV, EV> union(Graph<K, VV, EV> graph);1467140656;Performs union on the vertices and edges sets of the input graphs_removing duplicate vertices but maintaining duplicate edges.__@param graph the graph to perform union with_@return a new graph;public Graph<K, VV, EV> union(Graph<K, VV, EV> graph) {_		DataSet<Vertex<K, VV>> unionedVertices = graph.getVertices().union(this.getVertices()).distinct()__		DataSet<Edge<K, EV>> unionedEdges = graph.getEdges().union(this.getEdges())__		return new Graph<K, VV, EV>(unionedVertices, unionedEdges, this.context)__	};performs,union,on,the,vertices,and,edges,sets,of,the,input,graphs,removing,duplicate,vertices,but,maintaining,duplicate,edges,param,graph,the,graph,to,perform,union,with,return,a,new,graph;public,graph,k,vv,ev,union,graph,k,vv,ev,graph,data,set,vertex,k,vv,unioned,vertices,graph,get,vertices,union,this,get,vertices,distinct,data,set,edge,k,ev,unioned,edges,graph,get,edges,union,this,get,edges,return,new,graph,k,vv,ev,unioned,vertices,unioned,edges,this,context
Graph -> public Graph<K, VV, EV> union(Graph<K, VV, EV> graph);1467306272;Performs union on the vertices and edges sets of the input graphs_removing duplicate vertices but maintaining duplicate edges.__@param graph the graph to perform union with_@return a new graph;public Graph<K, VV, EV> union(Graph<K, VV, EV> graph) {_		DataSet<Vertex<K, VV>> unionedVertices = graph.getVertices().union(this.getVertices()).distinct()__		DataSet<Edge<K, EV>> unionedEdges = graph.getEdges().union(this.getEdges())__		return new Graph<K, VV, EV>(unionedVertices, unionedEdges, this.context)__	};performs,union,on,the,vertices,and,edges,sets,of,the,input,graphs,removing,duplicate,vertices,but,maintaining,duplicate,edges,param,graph,the,graph,to,perform,union,with,return,a,new,graph;public,graph,k,vv,ev,union,graph,k,vv,ev,graph,data,set,vertex,k,vv,unioned,vertices,graph,get,vertices,union,this,get,vertices,distinct,data,set,edge,k,ev,unioned,edges,graph,get,edges,union,this,get,edges,return,new,graph,k,vv,ev,unioned,vertices,unioned,edges,this,context
Graph -> public Graph<K, VV, EV> union(Graph<K, VV, EV> graph);1470042815;Performs union on the vertices and edges sets of the input graphs_removing duplicate vertices but maintaining duplicate edges.__@param graph the graph to perform union with_@return a new graph;public Graph<K, VV, EV> union(Graph<K, VV, EV> graph) {_		DataSet<Vertex<K, VV>> unionedVertices = graph.getVertices().union(this.getVertices()).distinct()__		DataSet<Edge<K, EV>> unionedEdges = graph.getEdges().union(this.getEdges())__		return new Graph<K, VV, EV>(unionedVertices, unionedEdges, this.context)__	};performs,union,on,the,vertices,and,edges,sets,of,the,input,graphs,removing,duplicate,vertices,but,maintaining,duplicate,edges,param,graph,the,graph,to,perform,union,with,return,a,new,graph;public,graph,k,vv,ev,union,graph,k,vv,ev,graph,data,set,vertex,k,vv,unioned,vertices,graph,get,vertices,union,this,get,vertices,distinct,data,set,edge,k,ev,unioned,edges,graph,get,edges,union,this,get,edges,return,new,graph,k,vv,ev,unioned,vertices,unioned,edges,this,context
Graph -> public Graph<K, VV, EV> union(Graph<K, VV, EV> graph);1475684776;Performs union on the vertices and edges sets of the input graphs_removing duplicate vertices but maintaining duplicate edges.__@param graph the graph to perform union with_@return a new graph;public Graph<K, VV, EV> union(Graph<K, VV, EV> graph) {_		DataSet<Vertex<K, VV>> unionedVertices = graph.getVertices().union(this.getVertices()).distinct()__		DataSet<Edge<K, EV>> unionedEdges = graph.getEdges().union(this.getEdges())__		return new Graph<>(unionedVertices, unionedEdges, this.context)__	};performs,union,on,the,vertices,and,edges,sets,of,the,input,graphs,removing,duplicate,vertices,but,maintaining,duplicate,edges,param,graph,the,graph,to,perform,union,with,return,a,new,graph;public,graph,k,vv,ev,union,graph,k,vv,ev,graph,data,set,vertex,k,vv,unioned,vertices,graph,get,vertices,union,this,get,vertices,distinct,data,set,edge,k,ev,unioned,edges,graph,get,edges,union,this,get,edges,return,new,graph,unioned,vertices,unioned,edges,this,context
Graph -> public Graph<K, VV, EV> union(Graph<K, VV, EV> graph);1475685606;Performs union on the vertices and edges sets of the input graphs_removing duplicate vertices but maintaining duplicate edges.__@param graph the graph to perform union with_@return a new graph;public Graph<K, VV, EV> union(Graph<K, VV, EV> graph) {_		DataSet<Vertex<K, VV>> unionedVertices = graph.getVertices().union(this.getVertices()).distinct()__		DataSet<Edge<K, EV>> unionedEdges = graph.getEdges().union(this.getEdges())__		return new Graph<>(unionedVertices, unionedEdges, this.context)__	};performs,union,on,the,vertices,and,edges,sets,of,the,input,graphs,removing,duplicate,vertices,but,maintaining,duplicate,edges,param,graph,the,graph,to,perform,union,with,return,a,new,graph;public,graph,k,vv,ev,union,graph,k,vv,ev,graph,data,set,vertex,k,vv,unioned,vertices,graph,get,vertices,union,this,get,vertices,distinct,data,set,edge,k,ev,unioned,edges,graph,get,edges,union,this,get,edges,return,new,graph,unioned,vertices,unioned,edges,this,context
Graph -> public Graph<K, VV, EV> union(Graph<K, VV, EV> graph);1481745825;Performs union on the vertices and edges sets of the input graphs_removing duplicate vertices but maintaining duplicate edges.__@param graph the graph to perform union with_@return a new graph;public Graph<K, VV, EV> union(Graph<K, VV, EV> graph) {_		DataSet<Vertex<K, VV>> unionedVertices = graph_			.getVertices()_			.union(this.getVertices())_				.name("Vertices")_			.distinct()_				.name("Vertices")___		DataSet<Edge<K, EV>> unionedEdges = graph_			.getEdges()_			.union(this.getEdges())_				.name("Edges")___		return new Graph<>(unionedVertices, unionedEdges, this.context)__	};performs,union,on,the,vertices,and,edges,sets,of,the,input,graphs,removing,duplicate,vertices,but,maintaining,duplicate,edges,param,graph,the,graph,to,perform,union,with,return,a,new,graph;public,graph,k,vv,ev,union,graph,k,vv,ev,graph,data,set,vertex,k,vv,unioned,vertices,graph,get,vertices,union,this,get,vertices,name,vertices,distinct,name,vertices,data,set,edge,k,ev,unioned,edges,graph,get,edges,union,this,get,edges,name,edges,return,new,graph,unioned,vertices,unioned,edges,this,context
Graph -> public Graph<K, VV, EV> union(Graph<K, VV, EV> graph);1481881009;Performs union on the vertices and edges sets of the input graphs_removing duplicate vertices but maintaining duplicate edges.__@param graph the graph to perform union with_@return a new graph;public Graph<K, VV, EV> union(Graph<K, VV, EV> graph) {_		DataSet<Vertex<K, VV>> unionedVertices = graph_			.getVertices()_			.union(this.getVertices())_				.name("Vertices")_			.distinct()_				.name("Vertices")___		DataSet<Edge<K, EV>> unionedEdges = graph_			.getEdges()_			.union(this.getEdges())_				.name("Edges")___		return new Graph<>(unionedVertices, unionedEdges, this.context)__	};performs,union,on,the,vertices,and,edges,sets,of,the,input,graphs,removing,duplicate,vertices,but,maintaining,duplicate,edges,param,graph,the,graph,to,perform,union,with,return,a,new,graph;public,graph,k,vv,ev,union,graph,k,vv,ev,graph,data,set,vertex,k,vv,unioned,vertices,graph,get,vertices,union,this,get,vertices,name,vertices,distinct,name,vertices,data,set,edge,k,ev,unioned,edges,graph,get,edges,union,this,get,edges,name,edges,return,new,graph,unioned,vertices,unioned,edges,this,context
Graph -> public Graph<K, VV, EV> union(Graph<K, VV, EV> graph);1484160227;Performs union on the vertices and edges sets of the input graphs_removing duplicate vertices but maintaining duplicate edges.__@param graph the graph to perform union with_@return a new graph;public Graph<K, VV, EV> union(Graph<K, VV, EV> graph) {_		DataSet<Vertex<K, VV>> unionedVertices = graph_			.getVertices()_			.union(this.getVertices())_				.name("Vertices")_			.distinct()_				.name("Vertices")___		DataSet<Edge<K, EV>> unionedEdges = graph_			.getEdges()_			.union(this.getEdges())_				.name("Edges")___		return new Graph<>(unionedVertices, unionedEdges, this.context)__	};performs,union,on,the,vertices,and,edges,sets,of,the,input,graphs,removing,duplicate,vertices,but,maintaining,duplicate,edges,param,graph,the,graph,to,perform,union,with,return,a,new,graph;public,graph,k,vv,ev,union,graph,k,vv,ev,graph,data,set,vertex,k,vv,unioned,vertices,graph,get,vertices,union,this,get,vertices,name,vertices,distinct,name,vertices,data,set,edge,k,ev,unioned,edges,graph,get,edges,union,this,get,edges,name,edges,return,new,graph,unioned,vertices,unioned,edges,this,context
Graph -> public Graph<K, VV, EV> union(Graph<K, VV, EV> graph);1484685504;Performs union on the vertices and edges sets of the input graphs_removing duplicate vertices but maintaining duplicate edges.__@param graph the graph to perform union with_@return a new graph;public Graph<K, VV, EV> union(Graph<K, VV, EV> graph) {_		DataSet<Vertex<K, VV>> unionedVertices = graph_			.getVertices()_			.union(this.getVertices())_				.name("Vertices")_			.distinct()_				.name("Vertices")___		DataSet<Edge<K, EV>> unionedEdges = graph_			.getEdges()_			.union(this.getEdges())_				.name("Edges")___		return new Graph<>(unionedVertices, unionedEdges, this.context)__	};performs,union,on,the,vertices,and,edges,sets,of,the,input,graphs,removing,duplicate,vertices,but,maintaining,duplicate,edges,param,graph,the,graph,to,perform,union,with,return,a,new,graph;public,graph,k,vv,ev,union,graph,k,vv,ev,graph,data,set,vertex,k,vv,unioned,vertices,graph,get,vertices,union,this,get,vertices,name,vertices,distinct,name,vertices,data,set,edge,k,ev,unioned,edges,graph,get,edges,union,this,get,edges,name,edges,return,new,graph,unioned,vertices,unioned,edges,this,context
Graph -> public Graph<K, VV, EV> union(Graph<K, VV, EV> graph);1489068942;Performs union on the vertices and edges sets of the input graphs_removing duplicate vertices but maintaining duplicate edges.__@param graph the graph to perform union with_@return a new graph;public Graph<K, VV, EV> union(Graph<K, VV, EV> graph) {_		DataSet<Vertex<K, VV>> unionedVertices = graph_			.getVertices()_			.union(this.getVertices())_				.name("Vertices")_			.distinct()_				.name("Vertices")___		DataSet<Edge<K, EV>> unionedEdges = graph_			.getEdges()_			.union(this.getEdges())_				.name("Edges")___		return new Graph<>(unionedVertices, unionedEdges, this.context)__	};performs,union,on,the,vertices,and,edges,sets,of,the,input,graphs,removing,duplicate,vertices,but,maintaining,duplicate,edges,param,graph,the,graph,to,perform,union,with,return,a,new,graph;public,graph,k,vv,ev,union,graph,k,vv,ev,graph,data,set,vertex,k,vv,unioned,vertices,graph,get,vertices,union,this,get,vertices,name,vertices,distinct,name,vertices,data,set,edge,k,ev,unioned,edges,graph,get,edges,union,this,get,edges,name,edges,return,new,graph,unioned,vertices,unioned,edges,this,context
Graph -> public Graph<K, VV, EV> union(Graph<K, VV, EV> graph);1490973446;Performs union on the vertices and edges sets of the input graphs_removing duplicate vertices but maintaining duplicate edges.__@param graph the graph to perform union with_@return a new graph;public Graph<K, VV, EV> union(Graph<K, VV, EV> graph) {_		DataSet<Vertex<K, VV>> unionedVertices = graph_			.getVertices()_			.union(this.getVertices())_				.name("Vertices")_			.distinct()_				.name("Vertices")___		DataSet<Edge<K, EV>> unionedEdges = graph_			.getEdges()_			.union(this.getEdges())_				.name("Edges")___		return new Graph<>(unionedVertices, unionedEdges, this.context)__	};performs,union,on,the,vertices,and,edges,sets,of,the,input,graphs,removing,duplicate,vertices,but,maintaining,duplicate,edges,param,graph,the,graph,to,perform,union,with,return,a,new,graph;public,graph,k,vv,ev,union,graph,k,vv,ev,graph,data,set,vertex,k,vv,unioned,vertices,graph,get,vertices,union,this,get,vertices,name,vertices,distinct,name,vertices,data,set,edge,k,ev,unioned,edges,graph,get,edges,union,this,get,edges,name,edges,return,new,graph,unioned,vertices,unioned,edges,this,context
Graph -> public Graph<K, VV, EV> union(Graph<K, VV, EV> graph);1495819075;Performs union on the vertices and edges sets of the input graphs_removing duplicate vertices but maintaining duplicate edges.__@param graph the graph to perform union with_@return a new graph;public Graph<K, VV, EV> union(Graph<K, VV, EV> graph) {_		DataSet<Vertex<K, VV>> unionedVertices = graph_			.getVertices()_			.union(this.getVertices())_				.name("Vertices")_			.distinct()_				.name("Vertices")___		DataSet<Edge<K, EV>> unionedEdges = graph_			.getEdges()_			.union(this.getEdges())_				.name("Edges")___		return new Graph<>(unionedVertices, unionedEdges, this.context)__	};performs,union,on,the,vertices,and,edges,sets,of,the,input,graphs,removing,duplicate,vertices,but,maintaining,duplicate,edges,param,graph,the,graph,to,perform,union,with,return,a,new,graph;public,graph,k,vv,ev,union,graph,k,vv,ev,graph,data,set,vertex,k,vv,unioned,vertices,graph,get,vertices,union,this,get,vertices,name,vertices,distinct,name,vertices,data,set,edge,k,ev,unioned,edges,graph,get,edges,union,this,get,edges,name,edges,return,new,graph,unioned,vertices,unioned,edges,this,context
Graph -> public Graph<K, VV, EV> union(Graph<K, VV, EV> graph);1502111816;Performs union on the vertices and edges sets of the input graphs_removing duplicate vertices but maintaining duplicate edges.__@param graph the graph to perform union with_@return a new graph;public Graph<K, VV, EV> union(Graph<K, VV, EV> graph) {_		DataSet<Vertex<K, VV>> unionedVertices = graph_			.getVertices()_			.union(this.getVertices())_				.name("Vertices")_			.distinct()_				.name("Vertices")___		DataSet<Edge<K, EV>> unionedEdges = graph_			.getEdges()_			.union(this.getEdges())_				.name("Edges")___		return new Graph<>(unionedVertices, unionedEdges, this.context)__	};performs,union,on,the,vertices,and,edges,sets,of,the,input,graphs,removing,duplicate,vertices,but,maintaining,duplicate,edges,param,graph,the,graph,to,perform,union,with,return,a,new,graph;public,graph,k,vv,ev,union,graph,k,vv,ev,graph,data,set,vertex,k,vv,unioned,vertices,graph,get,vertices,union,this,get,vertices,name,vertices,distinct,name,vertices,data,set,edge,k,ev,unioned,edges,graph,get,edges,union,this,get,edges,name,edges,return,new,graph,unioned,vertices,unioned,edges,this,context
Graph -> public <M> Graph<K, VV, EV> runVertexCentricIteration( 			VertexUpdateFunction<K, VV, M> vertexUpdateFunction, 			MessagingFunction<K, VV, M, EV> messagingFunction, 			int maximumNumberOfIterations, VertexCentricConfiguration parameters);1444404795;Runs a Vertex-Centric iteration on the graph with configuration options.__@param vertexUpdateFunction the vertex update function_@param messagingFunction the messaging function_@param maximumNumberOfIterations maximum number of iterations to perform_@param parameters the iteration configuration parameters__@return the updated Graph after the vertex-centric iteration has converged or_after maximumNumberOfIterations.;public <M> Graph<K, VV, EV> runVertexCentricIteration(_			VertexUpdateFunction<K, VV, M> vertexUpdateFunction,_			MessagingFunction<K, VV, M, EV> messagingFunction,_			int maximumNumberOfIterations, VertexCentricConfiguration parameters) {__		VertexCentricIteration<K, VV, M, EV> iteration = VertexCentricIteration.withEdges(_				edges, vertexUpdateFunction, messagingFunction, maximumNumberOfIterations)___		iteration.configure(parameters)___		DataSet<Vertex<K, VV>> newVertices = this.getVertices().runOperation(iteration)___		return new Graph<K, VV, EV>(newVertices, this.edges, this.context)__	};runs,a,vertex,centric,iteration,on,the,graph,with,configuration,options,param,vertex,update,function,the,vertex,update,function,param,messaging,function,the,messaging,function,param,maximum,number,of,iterations,maximum,number,of,iterations,to,perform,param,parameters,the,iteration,configuration,parameters,return,the,updated,graph,after,the,vertex,centric,iteration,has,converged,or,after,maximum,number,of,iterations;public,m,graph,k,vv,ev,run,vertex,centric,iteration,vertex,update,function,k,vv,m,vertex,update,function,messaging,function,k,vv,m,ev,messaging,function,int,maximum,number,of,iterations,vertex,centric,configuration,parameters,vertex,centric,iteration,k,vv,m,ev,iteration,vertex,centric,iteration,with,edges,edges,vertex,update,function,messaging,function,maximum,number,of,iterations,iteration,configure,parameters,data,set,vertex,k,vv,new,vertices,this,get,vertices,run,operation,iteration,return,new,graph,k,vv,ev,new,vertices,this,edges,this,context
Graph -> public <M> Graph<K, VV, EV> runVertexCentricIteration( 			VertexUpdateFunction<K, VV, M> vertexUpdateFunction, 			MessagingFunction<K, VV, M, EV> messagingFunction, 			int maximumNumberOfIterations, VertexCentricConfiguration parameters);1445261977;Runs a Vertex-Centric iteration on the graph with configuration options.__@param vertexUpdateFunction the vertex update function_@param messagingFunction the messaging function_@param maximumNumberOfIterations maximum number of iterations to perform_@param parameters the iteration configuration parameters__@return the updated Graph after the vertex-centric iteration has converged or_after maximumNumberOfIterations.;public <M> Graph<K, VV, EV> runVertexCentricIteration(_			VertexUpdateFunction<K, VV, M> vertexUpdateFunction,_			MessagingFunction<K, VV, M, EV> messagingFunction,_			int maximumNumberOfIterations, VertexCentricConfiguration parameters) {__		VertexCentricIteration<K, VV, M, EV> iteration = VertexCentricIteration.withEdges(_				edges, vertexUpdateFunction, messagingFunction, maximumNumberOfIterations)___		iteration.configure(parameters)___		DataSet<Vertex<K, VV>> newVertices = this.getVertices().runOperation(iteration)___		return new Graph<K, VV, EV>(newVertices, this.edges, this.context)__	};runs,a,vertex,centric,iteration,on,the,graph,with,configuration,options,param,vertex,update,function,the,vertex,update,function,param,messaging,function,the,messaging,function,param,maximum,number,of,iterations,maximum,number,of,iterations,to,perform,param,parameters,the,iteration,configuration,parameters,return,the,updated,graph,after,the,vertex,centric,iteration,has,converged,or,after,maximum,number,of,iterations;public,m,graph,k,vv,ev,run,vertex,centric,iteration,vertex,update,function,k,vv,m,vertex,update,function,messaging,function,k,vv,m,ev,messaging,function,int,maximum,number,of,iterations,vertex,centric,configuration,parameters,vertex,centric,iteration,k,vv,m,ev,iteration,vertex,centric,iteration,with,edges,edges,vertex,update,function,messaging,function,maximum,number,of,iterations,iteration,configure,parameters,data,set,vertex,k,vv,new,vertices,this,get,vertices,run,operation,iteration,return,new,graph,k,vv,ev,new,vertices,this,edges,this,context
Graph -> public <M> Graph<K, VV, EV> runVertexCentricIteration( 			VertexUpdateFunction<K, VV, M> vertexUpdateFunction, 			MessagingFunction<K, VV, M, EV> messagingFunction, 			int maximumNumberOfIterations, VertexCentricConfiguration parameters);1445854323;Runs a Vertex-Centric iteration on the graph with configuration options.__@param vertexUpdateFunction the vertex update function_@param messagingFunction the messaging function_@param maximumNumberOfIterations maximum number of iterations to perform_@param parameters the iteration configuration parameters__@return the updated Graph after the vertex-centric iteration has converged or_after maximumNumberOfIterations.;public <M> Graph<K, VV, EV> runVertexCentricIteration(_			VertexUpdateFunction<K, VV, M> vertexUpdateFunction,_			MessagingFunction<K, VV, M, EV> messagingFunction,_			int maximumNumberOfIterations, VertexCentricConfiguration parameters) {__		VertexCentricIteration<K, VV, M, EV> iteration = VertexCentricIteration.withEdges(_				edges, vertexUpdateFunction, messagingFunction, maximumNumberOfIterations)___		iteration.configure(parameters)___		DataSet<Vertex<K, VV>> newVertices = this.getVertices().runOperation(iteration)___		return new Graph<K, VV, EV>(newVertices, this.edges, this.context)__	};runs,a,vertex,centric,iteration,on,the,graph,with,configuration,options,param,vertex,update,function,the,vertex,update,function,param,messaging,function,the,messaging,function,param,maximum,number,of,iterations,maximum,number,of,iterations,to,perform,param,parameters,the,iteration,configuration,parameters,return,the,updated,graph,after,the,vertex,centric,iteration,has,converged,or,after,maximum,number,of,iterations;public,m,graph,k,vv,ev,run,vertex,centric,iteration,vertex,update,function,k,vv,m,vertex,update,function,messaging,function,k,vv,m,ev,messaging,function,int,maximum,number,of,iterations,vertex,centric,configuration,parameters,vertex,centric,iteration,k,vv,m,ev,iteration,vertex,centric,iteration,with,edges,edges,vertex,update,function,messaging,function,maximum,number,of,iterations,iteration,configure,parameters,data,set,vertex,k,vv,new,vertices,this,get,vertices,run,operation,iteration,return,new,graph,k,vv,ev,new,vertices,this,edges,this,context
Graph -> public <M> Graph<K, VV, EV> runVertexCentricIteration( 			VertexUpdateFunction<K, VV, M> vertexUpdateFunction, 			MessagingFunction<K, VV, M, EV> messagingFunction, 			int maximumNumberOfIterations, VertexCentricConfiguration parameters);1446112342;Runs a Vertex-Centric iteration on the graph with configuration options.__@param vertexUpdateFunction the vertex update function_@param messagingFunction the messaging function_@param maximumNumberOfIterations maximum number of iterations to perform_@param parameters the iteration configuration parameters__@return the updated Graph after the vertex-centric iteration has converged or_after maximumNumberOfIterations.;public <M> Graph<K, VV, EV> runVertexCentricIteration(_			VertexUpdateFunction<K, VV, M> vertexUpdateFunction,_			MessagingFunction<K, VV, M, EV> messagingFunction,_			int maximumNumberOfIterations, VertexCentricConfiguration parameters) {__		VertexCentricIteration<K, VV, M, EV> iteration = VertexCentricIteration.withEdges(_				edges, vertexUpdateFunction, messagingFunction, maximumNumberOfIterations)___		iteration.configure(parameters)___		DataSet<Vertex<K, VV>> newVertices = this.getVertices().runOperation(iteration)___		return new Graph<K, VV, EV>(newVertices, this.edges, this.context)__	};runs,a,vertex,centric,iteration,on,the,graph,with,configuration,options,param,vertex,update,function,the,vertex,update,function,param,messaging,function,the,messaging,function,param,maximum,number,of,iterations,maximum,number,of,iterations,to,perform,param,parameters,the,iteration,configuration,parameters,return,the,updated,graph,after,the,vertex,centric,iteration,has,converged,or,after,maximum,number,of,iterations;public,m,graph,k,vv,ev,run,vertex,centric,iteration,vertex,update,function,k,vv,m,vertex,update,function,messaging,function,k,vv,m,ev,messaging,function,int,maximum,number,of,iterations,vertex,centric,configuration,parameters,vertex,centric,iteration,k,vv,m,ev,iteration,vertex,centric,iteration,with,edges,edges,vertex,update,function,messaging,function,maximum,number,of,iterations,iteration,configure,parameters,data,set,vertex,k,vv,new,vertices,this,get,vertices,run,operation,iteration,return,new,graph,k,vv,ev,new,vertices,this,edges,this,context
Graph -> public <M> Graph<K, VV, EV> runVertexCentricIteration( 			VertexUpdateFunction<K, VV, M> vertexUpdateFunction, 			MessagingFunction<K, VV, M, EV> messagingFunction, 			int maximumNumberOfIterations, VertexCentricConfiguration parameters);1447073368;Runs a Vertex-Centric iteration on the graph with configuration options.__@param vertexUpdateFunction the vertex update function_@param messagingFunction the messaging function_@param maximumNumberOfIterations maximum number of iterations to perform_@param parameters the iteration configuration parameters__@return the updated Graph after the vertex-centric iteration has converged or_after maximumNumberOfIterations.;public <M> Graph<K, VV, EV> runVertexCentricIteration(_			VertexUpdateFunction<K, VV, M> vertexUpdateFunction,_			MessagingFunction<K, VV, M, EV> messagingFunction,_			int maximumNumberOfIterations, VertexCentricConfiguration parameters) {__		VertexCentricIteration<K, VV, M, EV> iteration = VertexCentricIteration.withEdges(_				edges, vertexUpdateFunction, messagingFunction, maximumNumberOfIterations)___		iteration.configure(parameters)___		DataSet<Vertex<K, VV>> newVertices = this.getVertices().runOperation(iteration)___		return new Graph<K, VV, EV>(newVertices, this.edges, this.context)__	};runs,a,vertex,centric,iteration,on,the,graph,with,configuration,options,param,vertex,update,function,the,vertex,update,function,param,messaging,function,the,messaging,function,param,maximum,number,of,iterations,maximum,number,of,iterations,to,perform,param,parameters,the,iteration,configuration,parameters,return,the,updated,graph,after,the,vertex,centric,iteration,has,converged,or,after,maximum,number,of,iterations;public,m,graph,k,vv,ev,run,vertex,centric,iteration,vertex,update,function,k,vv,m,vertex,update,function,messaging,function,k,vv,m,ev,messaging,function,int,maximum,number,of,iterations,vertex,centric,configuration,parameters,vertex,centric,iteration,k,vv,m,ev,iteration,vertex,centric,iteration,with,edges,edges,vertex,update,function,messaging,function,maximum,number,of,iterations,iteration,configure,parameters,data,set,vertex,k,vv,new,vertices,this,get,vertices,run,operation,iteration,return,new,graph,k,vv,ev,new,vertices,this,edges,this,context
Graph -> public static <K, VV, EV> Graph<K, VV, EV> fromDataSet(DataSet<Vertex<K, VV>> vertices, 			DataSet<Edge<K, EV>> edges, ExecutionEnvironment context);1444404795;Creates a graph from a DataSet of vertices and a DataSet of edges.__@param vertices a DataSet of vertices._@param edges a DataSet of edges._@param context the flink execution environment._@return the newly created graph.;public static <K, VV, EV> Graph<K, VV, EV> fromDataSet(DataSet<Vertex<K, VV>> vertices,_			DataSet<Edge<K, EV>> edges, ExecutionEnvironment context) {__		return new Graph<K, VV, EV>(vertices, edges, context)__	};creates,a,graph,from,a,data,set,of,vertices,and,a,data,set,of,edges,param,vertices,a,data,set,of,vertices,param,edges,a,data,set,of,edges,param,context,the,flink,execution,environment,return,the,newly,created,graph;public,static,k,vv,ev,graph,k,vv,ev,from,data,set,data,set,vertex,k,vv,vertices,data,set,edge,k,ev,edges,execution,environment,context,return,new,graph,k,vv,ev,vertices,edges,context
Graph -> public static <K, VV, EV> Graph<K, VV, EV> fromDataSet(DataSet<Vertex<K, VV>> vertices, 			DataSet<Edge<K, EV>> edges, ExecutionEnvironment context);1445261977;Creates a graph from a DataSet of vertices and a DataSet of edges.__@param vertices a DataSet of vertices._@param edges a DataSet of edges._@param context the flink execution environment._@return the newly created graph.;public static <K, VV, EV> Graph<K, VV, EV> fromDataSet(DataSet<Vertex<K, VV>> vertices,_			DataSet<Edge<K, EV>> edges, ExecutionEnvironment context) {__		return new Graph<K, VV, EV>(vertices, edges, context)__	};creates,a,graph,from,a,data,set,of,vertices,and,a,data,set,of,edges,param,vertices,a,data,set,of,vertices,param,edges,a,data,set,of,edges,param,context,the,flink,execution,environment,return,the,newly,created,graph;public,static,k,vv,ev,graph,k,vv,ev,from,data,set,data,set,vertex,k,vv,vertices,data,set,edge,k,ev,edges,execution,environment,context,return,new,graph,k,vv,ev,vertices,edges,context
Graph -> public static <K, VV, EV> Graph<K, VV, EV> fromDataSet(DataSet<Vertex<K, VV>> vertices, 			DataSet<Edge<K, EV>> edges, ExecutionEnvironment context);1445854323;Creates a graph from a DataSet of vertices and a DataSet of edges.__@param vertices a DataSet of vertices._@param edges a DataSet of edges._@param context the flink execution environment._@return the newly created graph.;public static <K, VV, EV> Graph<K, VV, EV> fromDataSet(DataSet<Vertex<K, VV>> vertices,_			DataSet<Edge<K, EV>> edges, ExecutionEnvironment context) {__		return new Graph<K, VV, EV>(vertices, edges, context)__	};creates,a,graph,from,a,data,set,of,vertices,and,a,data,set,of,edges,param,vertices,a,data,set,of,vertices,param,edges,a,data,set,of,edges,param,context,the,flink,execution,environment,return,the,newly,created,graph;public,static,k,vv,ev,graph,k,vv,ev,from,data,set,data,set,vertex,k,vv,vertices,data,set,edge,k,ev,edges,execution,environment,context,return,new,graph,k,vv,ev,vertices,edges,context
Graph -> public static <K, VV, EV> Graph<K, VV, EV> fromDataSet(DataSet<Vertex<K, VV>> vertices, 			DataSet<Edge<K, EV>> edges, ExecutionEnvironment context);1446112342;Creates a graph from a DataSet of vertices and a DataSet of edges.__@param vertices a DataSet of vertices._@param edges a DataSet of edges._@param context the flink execution environment._@return the newly created graph.;public static <K, VV, EV> Graph<K, VV, EV> fromDataSet(DataSet<Vertex<K, VV>> vertices,_			DataSet<Edge<K, EV>> edges, ExecutionEnvironment context) {__		return new Graph<K, VV, EV>(vertices, edges, context)__	};creates,a,graph,from,a,data,set,of,vertices,and,a,data,set,of,edges,param,vertices,a,data,set,of,vertices,param,edges,a,data,set,of,edges,param,context,the,flink,execution,environment,return,the,newly,created,graph;public,static,k,vv,ev,graph,k,vv,ev,from,data,set,data,set,vertex,k,vv,vertices,data,set,edge,k,ev,edges,execution,environment,context,return,new,graph,k,vv,ev,vertices,edges,context
Graph -> public static <K, VV, EV> Graph<K, VV, EV> fromDataSet(DataSet<Vertex<K, VV>> vertices, 			DataSet<Edge<K, EV>> edges, ExecutionEnvironment context);1447073368;Creates a graph from a DataSet of vertices and a DataSet of edges.__@param vertices a DataSet of vertices._@param edges a DataSet of edges._@param context the flink execution environment._@return the newly created graph.;public static <K, VV, EV> Graph<K, VV, EV> fromDataSet(DataSet<Vertex<K, VV>> vertices,_			DataSet<Edge<K, EV>> edges, ExecutionEnvironment context) {__		return new Graph<K, VV, EV>(vertices, edges, context)__	};creates,a,graph,from,a,data,set,of,vertices,and,a,data,set,of,edges,param,vertices,a,data,set,of,vertices,param,edges,a,data,set,of,edges,param,context,the,flink,execution,environment,return,the,newly,created,graph;public,static,k,vv,ev,graph,k,vv,ev,from,data,set,data,set,vertex,k,vv,vertices,data,set,edge,k,ev,edges,execution,environment,context,return,new,graph,k,vv,ev,vertices,edges,context
Graph -> public static <K, VV, EV> Graph<K, VV, EV> fromDataSet(DataSet<Vertex<K, VV>> vertices, 			DataSet<Edge<K, EV>> edges, ExecutionEnvironment context);1454404649;Creates a graph from a DataSet of vertices and a DataSet of edges.__@param vertices a DataSet of vertices._@param edges a DataSet of edges._@param context the flink execution environment._@return the newly created graph.;public static <K, VV, EV> Graph<K, VV, EV> fromDataSet(DataSet<Vertex<K, VV>> vertices,_			DataSet<Edge<K, EV>> edges, ExecutionEnvironment context) {__		return new Graph<K, VV, EV>(vertices, edges, context)__	};creates,a,graph,from,a,data,set,of,vertices,and,a,data,set,of,edges,param,vertices,a,data,set,of,vertices,param,edges,a,data,set,of,edges,param,context,the,flink,execution,environment,return,the,newly,created,graph;public,static,k,vv,ev,graph,k,vv,ev,from,data,set,data,set,vertex,k,vv,vertices,data,set,edge,k,ev,edges,execution,environment,context,return,new,graph,k,vv,ev,vertices,edges,context
Graph -> public static <K, VV, EV> Graph<K, VV, EV> fromDataSet(DataSet<Vertex<K, VV>> vertices, 			DataSet<Edge<K, EV>> edges, ExecutionEnvironment context);1458583829;Creates a graph from a DataSet of vertices and a DataSet of edges.__@param vertices a DataSet of vertices._@param edges a DataSet of edges._@param context the flink execution environment._@return the newly created graph.;public static <K, VV, EV> Graph<K, VV, EV> fromDataSet(DataSet<Vertex<K, VV>> vertices,_			DataSet<Edge<K, EV>> edges, ExecutionEnvironment context) {__		return new Graph<K, VV, EV>(vertices, edges, context)__	};creates,a,graph,from,a,data,set,of,vertices,and,a,data,set,of,edges,param,vertices,a,data,set,of,vertices,param,edges,a,data,set,of,edges,param,context,the,flink,execution,environment,return,the,newly,created,graph;public,static,k,vv,ev,graph,k,vv,ev,from,data,set,data,set,vertex,k,vv,vertices,data,set,edge,k,ev,edges,execution,environment,context,return,new,graph,k,vv,ev,vertices,edges,context
Graph -> public static <K, VV, EV> Graph<K, VV, EV> fromDataSet(DataSet<Vertex<K, VV>> vertices, 			DataSet<Edge<K, EV>> edges, ExecutionEnvironment context);1458583829;Creates a graph from a DataSet of vertices and a DataSet of edges.__@param vertices a DataSet of vertices._@param edges a DataSet of edges._@param context the flink execution environment._@return the newly created graph.;public static <K, VV, EV> Graph<K, VV, EV> fromDataSet(DataSet<Vertex<K, VV>> vertices,_			DataSet<Edge<K, EV>> edges, ExecutionEnvironment context) {__		return new Graph<K, VV, EV>(vertices, edges, context)__	};creates,a,graph,from,a,data,set,of,vertices,and,a,data,set,of,edges,param,vertices,a,data,set,of,vertices,param,edges,a,data,set,of,edges,param,context,the,flink,execution,environment,return,the,newly,created,graph;public,static,k,vv,ev,graph,k,vv,ev,from,data,set,data,set,vertex,k,vv,vertices,data,set,edge,k,ev,edges,execution,environment,context,return,new,graph,k,vv,ev,vertices,edges,context
Graph -> public static <K, VV, EV> Graph<K, VV, EV> fromDataSet(DataSet<Vertex<K, VV>> vertices, 			DataSet<Edge<K, EV>> edges, ExecutionEnvironment context);1462100316;Creates a graph from a DataSet of vertices and a DataSet of edges.__@param vertices a DataSet of vertices._@param edges a DataSet of edges._@param context the flink execution environment._@return the newly created graph.;public static <K, VV, EV> Graph<K, VV, EV> fromDataSet(DataSet<Vertex<K, VV>> vertices,_			DataSet<Edge<K, EV>> edges, ExecutionEnvironment context) {__		return new Graph<K, VV, EV>(vertices, edges, context)__	};creates,a,graph,from,a,data,set,of,vertices,and,a,data,set,of,edges,param,vertices,a,data,set,of,vertices,param,edges,a,data,set,of,edges,param,context,the,flink,execution,environment,return,the,newly,created,graph;public,static,k,vv,ev,graph,k,vv,ev,from,data,set,data,set,vertex,k,vv,vertices,data,set,edge,k,ev,edges,execution,environment,context,return,new,graph,k,vv,ev,vertices,edges,context
Graph -> public static <K, VV, EV> Graph<K, VV, EV> fromDataSet(DataSet<Vertex<K, VV>> vertices, 			DataSet<Edge<K, EV>> edges, ExecutionEnvironment context);1462100316;Creates a graph from a DataSet of vertices and a DataSet of edges.__@param vertices a DataSet of vertices._@param edges a DataSet of edges._@param context the flink execution environment._@return the newly created graph.;public static <K, VV, EV> Graph<K, VV, EV> fromDataSet(DataSet<Vertex<K, VV>> vertices,_			DataSet<Edge<K, EV>> edges, ExecutionEnvironment context) {__		return new Graph<K, VV, EV>(vertices, edges, context)__	};creates,a,graph,from,a,data,set,of,vertices,and,a,data,set,of,edges,param,vertices,a,data,set,of,vertices,param,edges,a,data,set,of,edges,param,context,the,flink,execution,environment,return,the,newly,created,graph;public,static,k,vv,ev,graph,k,vv,ev,from,data,set,data,set,vertex,k,vv,vertices,data,set,edge,k,ev,edges,execution,environment,context,return,new,graph,k,vv,ev,vertices,edges,context
Graph -> public static <K, VV, EV> Graph<K, VV, EV> fromDataSet(DataSet<Vertex<K, VV>> vertices, 			DataSet<Edge<K, EV>> edges, ExecutionEnvironment context);1462205213;Creates a graph from a DataSet of vertices and a DataSet of edges.__@param vertices a DataSet of vertices._@param edges a DataSet of edges._@param context the flink execution environment._@return the newly created graph.;public static <K, VV, EV> Graph<K, VV, EV> fromDataSet(DataSet<Vertex<K, VV>> vertices,_			DataSet<Edge<K, EV>> edges, ExecutionEnvironment context) {__		return new Graph<K, VV, EV>(vertices, edges, context)__	};creates,a,graph,from,a,data,set,of,vertices,and,a,data,set,of,edges,param,vertices,a,data,set,of,vertices,param,edges,a,data,set,of,edges,param,context,the,flink,execution,environment,return,the,newly,created,graph;public,static,k,vv,ev,graph,k,vv,ev,from,data,set,data,set,vertex,k,vv,vertices,data,set,edge,k,ev,edges,execution,environment,context,return,new,graph,k,vv,ev,vertices,edges,context
Graph -> public static <K, VV, EV> Graph<K, VV, EV> fromDataSet(DataSet<Vertex<K, VV>> vertices, 			DataSet<Edge<K, EV>> edges, ExecutionEnvironment context);1462208859;Creates a graph from a DataSet of vertices and a DataSet of edges.__@param vertices a DataSet of vertices._@param edges a DataSet of edges._@param context the flink execution environment._@return the newly created graph.;public static <K, VV, EV> Graph<K, VV, EV> fromDataSet(DataSet<Vertex<K, VV>> vertices,_			DataSet<Edge<K, EV>> edges, ExecutionEnvironment context) {__		return new Graph<K, VV, EV>(vertices, edges, context)__	};creates,a,graph,from,a,data,set,of,vertices,and,a,data,set,of,edges,param,vertices,a,data,set,of,vertices,param,edges,a,data,set,of,edges,param,context,the,flink,execution,environment,return,the,newly,created,graph;public,static,k,vv,ev,graph,k,vv,ev,from,data,set,data,set,vertex,k,vv,vertices,data,set,edge,k,ev,edges,execution,environment,context,return,new,graph,k,vv,ev,vertices,edges,context
Graph -> public static <K, VV, EV> Graph<K, VV, EV> fromDataSet(DataSet<Vertex<K, VV>> vertices, 			DataSet<Edge<K, EV>> edges, ExecutionEnvironment context);1462809297;Creates a graph from a DataSet of vertices and a DataSet of edges.__@param vertices a DataSet of vertices._@param edges a DataSet of edges._@param context the flink execution environment._@return the newly created graph.;public static <K, VV, EV> Graph<K, VV, EV> fromDataSet(DataSet<Vertex<K, VV>> vertices,_			DataSet<Edge<K, EV>> edges, ExecutionEnvironment context) {__		return new Graph<K, VV, EV>(vertices, edges, context)__	};creates,a,graph,from,a,data,set,of,vertices,and,a,data,set,of,edges,param,vertices,a,data,set,of,vertices,param,edges,a,data,set,of,edges,param,context,the,flink,execution,environment,return,the,newly,created,graph;public,static,k,vv,ev,graph,k,vv,ev,from,data,set,data,set,vertex,k,vv,vertices,data,set,edge,k,ev,edges,execution,environment,context,return,new,graph,k,vv,ev,vertices,edges,context
Graph -> public static <K, VV, EV> Graph<K, VV, EV> fromDataSet(DataSet<Vertex<K, VV>> vertices, 			DataSet<Edge<K, EV>> edges, ExecutionEnvironment context);1465316775;Creates a graph from a DataSet of vertices and a DataSet of edges.__@param vertices a DataSet of vertices._@param edges a DataSet of edges._@param context the flink execution environment._@return the newly created graph.;public static <K, VV, EV> Graph<K, VV, EV> fromDataSet(DataSet<Vertex<K, VV>> vertices,_			DataSet<Edge<K, EV>> edges, ExecutionEnvironment context) {__		return new Graph<K, VV, EV>(vertices, edges, context)__	};creates,a,graph,from,a,data,set,of,vertices,and,a,data,set,of,edges,param,vertices,a,data,set,of,vertices,param,edges,a,data,set,of,edges,param,context,the,flink,execution,environment,return,the,newly,created,graph;public,static,k,vv,ev,graph,k,vv,ev,from,data,set,data,set,vertex,k,vv,vertices,data,set,edge,k,ev,edges,execution,environment,context,return,new,graph,k,vv,ev,vertices,edges,context
Graph -> public static <K, VV, EV> Graph<K, VV, EV> fromDataSet(DataSet<Vertex<K, VV>> vertices, 			DataSet<Edge<K, EV>> edges, ExecutionEnvironment context);1466789678;Creates a graph from a DataSet of vertices and a DataSet of edges.__@param vertices a DataSet of vertices._@param edges a DataSet of edges._@param context the flink execution environment._@return the newly created graph.;public static <K, VV, EV> Graph<K, VV, EV> fromDataSet(DataSet<Vertex<K, VV>> vertices,_			DataSet<Edge<K, EV>> edges, ExecutionEnvironment context) {__		return new Graph<K, VV, EV>(vertices, edges, context)__	};creates,a,graph,from,a,data,set,of,vertices,and,a,data,set,of,edges,param,vertices,a,data,set,of,vertices,param,edges,a,data,set,of,edges,param,context,the,flink,execution,environment,return,the,newly,created,graph;public,static,k,vv,ev,graph,k,vv,ev,from,data,set,data,set,vertex,k,vv,vertices,data,set,edge,k,ev,edges,execution,environment,context,return,new,graph,k,vv,ev,vertices,edges,context
Graph -> public static <K, VV, EV> Graph<K, VV, EV> fromDataSet(DataSet<Vertex<K, VV>> vertices, 			DataSet<Edge<K, EV>> edges, ExecutionEnvironment context);1467140656;Creates a graph from a DataSet of vertices and a DataSet of edges.__@param vertices a DataSet of vertices._@param edges a DataSet of edges._@param context the flink execution environment._@return the newly created graph.;public static <K, VV, EV> Graph<K, VV, EV> fromDataSet(DataSet<Vertex<K, VV>> vertices,_			DataSet<Edge<K, EV>> edges, ExecutionEnvironment context) {__		return new Graph<K, VV, EV>(vertices, edges, context)__	};creates,a,graph,from,a,data,set,of,vertices,and,a,data,set,of,edges,param,vertices,a,data,set,of,vertices,param,edges,a,data,set,of,edges,param,context,the,flink,execution,environment,return,the,newly,created,graph;public,static,k,vv,ev,graph,k,vv,ev,from,data,set,data,set,vertex,k,vv,vertices,data,set,edge,k,ev,edges,execution,environment,context,return,new,graph,k,vv,ev,vertices,edges,context
Graph -> public static <K, VV, EV> Graph<K, VV, EV> fromDataSet(DataSet<Vertex<K, VV>> vertices, 			DataSet<Edge<K, EV>> edges, ExecutionEnvironment context);1467306272;Creates a graph from a DataSet of vertices and a DataSet of edges.__@param vertices a DataSet of vertices._@param edges a DataSet of edges._@param context the flink execution environment._@return the newly created graph.;public static <K, VV, EV> Graph<K, VV, EV> fromDataSet(DataSet<Vertex<K, VV>> vertices,_			DataSet<Edge<K, EV>> edges, ExecutionEnvironment context) {__		return new Graph<K, VV, EV>(vertices, edges, context)__	};creates,a,graph,from,a,data,set,of,vertices,and,a,data,set,of,edges,param,vertices,a,data,set,of,vertices,param,edges,a,data,set,of,edges,param,context,the,flink,execution,environment,return,the,newly,created,graph;public,static,k,vv,ev,graph,k,vv,ev,from,data,set,data,set,vertex,k,vv,vertices,data,set,edge,k,ev,edges,execution,environment,context,return,new,graph,k,vv,ev,vertices,edges,context
Graph -> public static <K, VV, EV> Graph<K, VV, EV> fromDataSet(DataSet<Vertex<K, VV>> vertices, 			DataSet<Edge<K, EV>> edges, ExecutionEnvironment context);1470042815;Creates a graph from a DataSet of vertices and a DataSet of edges.__@param vertices a DataSet of vertices._@param edges a DataSet of edges._@param context the flink execution environment._@return the newly created graph.;public static <K, VV, EV> Graph<K, VV, EV> fromDataSet(DataSet<Vertex<K, VV>> vertices,_			DataSet<Edge<K, EV>> edges, ExecutionEnvironment context) {__		return new Graph<K, VV, EV>(vertices, edges, context)__	};creates,a,graph,from,a,data,set,of,vertices,and,a,data,set,of,edges,param,vertices,a,data,set,of,vertices,param,edges,a,data,set,of,edges,param,context,the,flink,execution,environment,return,the,newly,created,graph;public,static,k,vv,ev,graph,k,vv,ev,from,data,set,data,set,vertex,k,vv,vertices,data,set,edge,k,ev,edges,execution,environment,context,return,new,graph,k,vv,ev,vertices,edges,context
Graph -> public static <K, VV, EV> Graph<K, VV, EV> fromDataSet(DataSet<Vertex<K, VV>> vertices, 			DataSet<Edge<K, EV>> edges, ExecutionEnvironment context);1475684776;Creates a graph from a DataSet of vertices and a DataSet of edges.__@param vertices a DataSet of vertices._@param edges a DataSet of edges._@param context the flink execution environment._@return the newly created graph.;public static <K, VV, EV> Graph<K, VV, EV> fromDataSet(DataSet<Vertex<K, VV>> vertices,_			DataSet<Edge<K, EV>> edges, ExecutionEnvironment context) {__		return new Graph<>(vertices, edges, context)__	};creates,a,graph,from,a,data,set,of,vertices,and,a,data,set,of,edges,param,vertices,a,data,set,of,vertices,param,edges,a,data,set,of,edges,param,context,the,flink,execution,environment,return,the,newly,created,graph;public,static,k,vv,ev,graph,k,vv,ev,from,data,set,data,set,vertex,k,vv,vertices,data,set,edge,k,ev,edges,execution,environment,context,return,new,graph,vertices,edges,context
Graph -> public static <K, VV, EV> Graph<K, VV, EV> fromDataSet(DataSet<Vertex<K, VV>> vertices, 			DataSet<Edge<K, EV>> edges, ExecutionEnvironment context);1475685606;Creates a graph from a DataSet of vertices and a DataSet of edges.__@param vertices a DataSet of vertices._@param edges a DataSet of edges._@param context the flink execution environment._@return the newly created graph.;public static <K, VV, EV> Graph<K, VV, EV> fromDataSet(DataSet<Vertex<K, VV>> vertices,_			DataSet<Edge<K, EV>> edges, ExecutionEnvironment context) {__		return new Graph<>(vertices, edges, context)__	};creates,a,graph,from,a,data,set,of,vertices,and,a,data,set,of,edges,param,vertices,a,data,set,of,vertices,param,edges,a,data,set,of,edges,param,context,the,flink,execution,environment,return,the,newly,created,graph;public,static,k,vv,ev,graph,k,vv,ev,from,data,set,data,set,vertex,k,vv,vertices,data,set,edge,k,ev,edges,execution,environment,context,return,new,graph,vertices,edges,context
Graph -> public static <K, VV, EV> Graph<K, VV, EV> fromDataSet(DataSet<Vertex<K, VV>> vertices, 			DataSet<Edge<K, EV>> edges, ExecutionEnvironment context);1481745825;Creates a graph from a DataSet of vertices and a DataSet of edges.__@param vertices a DataSet of vertices._@param edges a DataSet of edges._@param context the flink execution environment._@return the newly created graph.;public static <K, VV, EV> Graph<K, VV, EV> fromDataSet(DataSet<Vertex<K, VV>> vertices,_			DataSet<Edge<K, EV>> edges, ExecutionEnvironment context) {__		return new Graph<>(vertices, edges, context)__	};creates,a,graph,from,a,data,set,of,vertices,and,a,data,set,of,edges,param,vertices,a,data,set,of,vertices,param,edges,a,data,set,of,edges,param,context,the,flink,execution,environment,return,the,newly,created,graph;public,static,k,vv,ev,graph,k,vv,ev,from,data,set,data,set,vertex,k,vv,vertices,data,set,edge,k,ev,edges,execution,environment,context,return,new,graph,vertices,edges,context
Graph -> public static <K, VV, EV> Graph<K, VV, EV> fromDataSet(DataSet<Vertex<K, VV>> vertices, 			DataSet<Edge<K, EV>> edges, ExecutionEnvironment context);1481881009;Creates a graph from a DataSet of vertices and a DataSet of edges.__@param vertices a DataSet of vertices._@param edges a DataSet of edges._@param context the flink execution environment._@return the newly created graph.;public static <K, VV, EV> Graph<K, VV, EV> fromDataSet(DataSet<Vertex<K, VV>> vertices,_			DataSet<Edge<K, EV>> edges, ExecutionEnvironment context) {__		return new Graph<>(vertices, edges, context)__	};creates,a,graph,from,a,data,set,of,vertices,and,a,data,set,of,edges,param,vertices,a,data,set,of,vertices,param,edges,a,data,set,of,edges,param,context,the,flink,execution,environment,return,the,newly,created,graph;public,static,k,vv,ev,graph,k,vv,ev,from,data,set,data,set,vertex,k,vv,vertices,data,set,edge,k,ev,edges,execution,environment,context,return,new,graph,vertices,edges,context
Graph -> public static <K, VV, EV> Graph<K, VV, EV> fromDataSet(DataSet<Vertex<K, VV>> vertices, 			DataSet<Edge<K, EV>> edges, ExecutionEnvironment context);1484160227;Creates a graph from a DataSet of vertices and a DataSet of edges.__@param vertices a DataSet of vertices._@param edges a DataSet of edges._@param context the flink execution environment._@return the newly created graph.;public static <K, VV, EV> Graph<K, VV, EV> fromDataSet(DataSet<Vertex<K, VV>> vertices,_			DataSet<Edge<K, EV>> edges, ExecutionEnvironment context) {__		return new Graph<>(vertices, edges, context)__	};creates,a,graph,from,a,data,set,of,vertices,and,a,data,set,of,edges,param,vertices,a,data,set,of,vertices,param,edges,a,data,set,of,edges,param,context,the,flink,execution,environment,return,the,newly,created,graph;public,static,k,vv,ev,graph,k,vv,ev,from,data,set,data,set,vertex,k,vv,vertices,data,set,edge,k,ev,edges,execution,environment,context,return,new,graph,vertices,edges,context
Graph -> public static <K, VV, EV> Graph<K, VV, EV> fromDataSet(DataSet<Vertex<K, VV>> vertices, 			DataSet<Edge<K, EV>> edges, ExecutionEnvironment context);1484685504;Creates a graph from a DataSet of vertices and a DataSet of edges.__@param vertices a DataSet of vertices._@param edges a DataSet of edges._@param context the flink execution environment._@return the newly created graph.;public static <K, VV, EV> Graph<K, VV, EV> fromDataSet(DataSet<Vertex<K, VV>> vertices,_			DataSet<Edge<K, EV>> edges, ExecutionEnvironment context) {__		return new Graph<>(vertices, edges, context)__	};creates,a,graph,from,a,data,set,of,vertices,and,a,data,set,of,edges,param,vertices,a,data,set,of,vertices,param,edges,a,data,set,of,edges,param,context,the,flink,execution,environment,return,the,newly,created,graph;public,static,k,vv,ev,graph,k,vv,ev,from,data,set,data,set,vertex,k,vv,vertices,data,set,edge,k,ev,edges,execution,environment,context,return,new,graph,vertices,edges,context
Graph -> public static <K, VV, EV> Graph<K, VV, EV> fromDataSet(DataSet<Vertex<K, VV>> vertices, 			DataSet<Edge<K, EV>> edges, ExecutionEnvironment context);1489068942;Creates a graph from a DataSet of vertices and a DataSet of edges.__@param vertices a DataSet of vertices._@param edges a DataSet of edges._@param context the flink execution environment._@return the newly created graph.;public static <K, VV, EV> Graph<K, VV, EV> fromDataSet(DataSet<Vertex<K, VV>> vertices,_			DataSet<Edge<K, EV>> edges, ExecutionEnvironment context) {__		return new Graph<>(vertices, edges, context)__	};creates,a,graph,from,a,data,set,of,vertices,and,a,data,set,of,edges,param,vertices,a,data,set,of,vertices,param,edges,a,data,set,of,edges,param,context,the,flink,execution,environment,return,the,newly,created,graph;public,static,k,vv,ev,graph,k,vv,ev,from,data,set,data,set,vertex,k,vv,vertices,data,set,edge,k,ev,edges,execution,environment,context,return,new,graph,vertices,edges,context
Graph -> public static <K, VV, EV> Graph<K, VV, EV> fromDataSet(DataSet<Vertex<K, VV>> vertices, 			DataSet<Edge<K, EV>> edges, ExecutionEnvironment context);1490973446;Creates a graph from a DataSet of vertices and a DataSet of edges.__@param vertices a DataSet of vertices._@param edges a DataSet of edges._@param context the flink execution environment._@return the newly created graph.;public static <K, VV, EV> Graph<K, VV, EV> fromDataSet(DataSet<Vertex<K, VV>> vertices,_			DataSet<Edge<K, EV>> edges, ExecutionEnvironment context) {__		return new Graph<>(vertices, edges, context)__	};creates,a,graph,from,a,data,set,of,vertices,and,a,data,set,of,edges,param,vertices,a,data,set,of,vertices,param,edges,a,data,set,of,edges,param,context,the,flink,execution,environment,return,the,newly,created,graph;public,static,k,vv,ev,graph,k,vv,ev,from,data,set,data,set,vertex,k,vv,vertices,data,set,edge,k,ev,edges,execution,environment,context,return,new,graph,vertices,edges,context
Graph -> public static <K, VV, EV> Graph<K, VV, EV> fromDataSet(DataSet<Vertex<K, VV>> vertices, 			DataSet<Edge<K, EV>> edges, ExecutionEnvironment context);1495819075;Creates a graph from a DataSet of vertices and a DataSet of edges.__@param vertices a DataSet of vertices._@param edges a DataSet of edges._@param context the flink execution environment._@return the newly created graph.;public static <K, VV, EV> Graph<K, VV, EV> fromDataSet(DataSet<Vertex<K, VV>> vertices,_			DataSet<Edge<K, EV>> edges, ExecutionEnvironment context) {__		return new Graph<>(vertices, edges, context)__	};creates,a,graph,from,a,data,set,of,vertices,and,a,data,set,of,edges,param,vertices,a,data,set,of,vertices,param,edges,a,data,set,of,edges,param,context,the,flink,execution,environment,return,the,newly,created,graph;public,static,k,vv,ev,graph,k,vv,ev,from,data,set,data,set,vertex,k,vv,vertices,data,set,edge,k,ev,edges,execution,environment,context,return,new,graph,vertices,edges,context
Graph -> public static <K, VV, EV> Graph<K, VV, EV> fromDataSet(DataSet<Vertex<K, VV>> vertices, 			DataSet<Edge<K, EV>> edges, ExecutionEnvironment context);1502111816;Creates a graph from a DataSet of vertices and a DataSet of edges.__@param vertices a DataSet of vertices._@param edges a DataSet of edges._@param context the flink execution environment._@return the newly created graph.;public static <K, VV, EV> Graph<K, VV, EV> fromDataSet(DataSet<Vertex<K, VV>> vertices,_			DataSet<Edge<K, EV>> edges, ExecutionEnvironment context) {__		return new Graph<>(vertices, edges, context)__	};creates,a,graph,from,a,data,set,of,vertices,and,a,data,set,of,edges,param,vertices,a,data,set,of,vertices,param,edges,a,data,set,of,edges,param,context,the,flink,execution,environment,return,the,newly,created,graph;public,static,k,vv,ev,graph,k,vv,ev,from,data,set,data,set,vertex,k,vv,vertices,data,set,edge,k,ev,edges,execution,environment,context,return,new,graph,vertices,edges,context
Graph -> public <M> Graph<K, VV, EV> runGatherSumApplyIteration( 			GatherFunction<VV, EV, M> gatherFunction, SumFunction<VV, EV, M> sumFunction, 			ApplyFunction<K, VV, M> applyFunction, int maximumNumberOfIterations, 			GSAConfiguration parameters);1444404795;Runs a Gather-Sum-Apply iteration on the graph with configuration options.__@param gatherFunction the gather function collects information about adjacent vertices and edges_@param sumFunction the sum function aggregates the gathered information_@param applyFunction the apply function updates the vertex values with the aggregates_@param maximumNumberOfIterations maximum number of iterations to perform_@param parameters the iteration configuration parameters_@param <M> the intermediate type used between gather, sum and apply__@return the updated Graph after the gather-sum-apply iteration has converged or_after maximumNumberOfIterations.;public <M> Graph<K, VV, EV> runGatherSumApplyIteration(_			GatherFunction<VV, EV, M> gatherFunction, SumFunction<VV, EV, M> sumFunction,_			ApplyFunction<K, VV, M> applyFunction, int maximumNumberOfIterations,_			GSAConfiguration parameters) {__		GatherSumApplyIteration<K, VV, EV, M> iteration = GatherSumApplyIteration.withEdges(_				edges, gatherFunction, sumFunction, applyFunction, maximumNumberOfIterations)___		iteration.configure(parameters)___		DataSet<Vertex<K, VV>> newVertices = vertices.runOperation(iteration)___		return new Graph<K, VV, EV>(newVertices, this.edges, this.context)__	};runs,a,gather,sum,apply,iteration,on,the,graph,with,configuration,options,param,gather,function,the,gather,function,collects,information,about,adjacent,vertices,and,edges,param,sum,function,the,sum,function,aggregates,the,gathered,information,param,apply,function,the,apply,function,updates,the,vertex,values,with,the,aggregates,param,maximum,number,of,iterations,maximum,number,of,iterations,to,perform,param,parameters,the,iteration,configuration,parameters,param,m,the,intermediate,type,used,between,gather,sum,and,apply,return,the,updated,graph,after,the,gather,sum,apply,iteration,has,converged,or,after,maximum,number,of,iterations;public,m,graph,k,vv,ev,run,gather,sum,apply,iteration,gather,function,vv,ev,m,gather,function,sum,function,vv,ev,m,sum,function,apply,function,k,vv,m,apply,function,int,maximum,number,of,iterations,gsaconfiguration,parameters,gather,sum,apply,iteration,k,vv,ev,m,iteration,gather,sum,apply,iteration,with,edges,edges,gather,function,sum,function,apply,function,maximum,number,of,iterations,iteration,configure,parameters,data,set,vertex,k,vv,new,vertices,vertices,run,operation,iteration,return,new,graph,k,vv,ev,new,vertices,this,edges,this,context
Graph -> public <M> Graph<K, VV, EV> runGatherSumApplyIteration( 			GatherFunction<VV, EV, M> gatherFunction, SumFunction<VV, EV, M> sumFunction, 			ApplyFunction<K, VV, M> applyFunction, int maximumNumberOfIterations, 			GSAConfiguration parameters);1445261977;Runs a Gather-Sum-Apply iteration on the graph with configuration options.__@param gatherFunction the gather function collects information about adjacent vertices and edges_@param sumFunction the sum function aggregates the gathered information_@param applyFunction the apply function updates the vertex values with the aggregates_@param maximumNumberOfIterations maximum number of iterations to perform_@param parameters the iteration configuration parameters_@param <M> the intermediate type used between gather, sum and apply__@return the updated Graph after the gather-sum-apply iteration has converged or_after maximumNumberOfIterations.;public <M> Graph<K, VV, EV> runGatherSumApplyIteration(_			GatherFunction<VV, EV, M> gatherFunction, SumFunction<VV, EV, M> sumFunction,_			ApplyFunction<K, VV, M> applyFunction, int maximumNumberOfIterations,_			GSAConfiguration parameters) {__		GatherSumApplyIteration<K, VV, EV, M> iteration = GatherSumApplyIteration.withEdges(_				edges, gatherFunction, sumFunction, applyFunction, maximumNumberOfIterations)___		iteration.configure(parameters)___		DataSet<Vertex<K, VV>> newVertices = vertices.runOperation(iteration)___		return new Graph<K, VV, EV>(newVertices, this.edges, this.context)__	};runs,a,gather,sum,apply,iteration,on,the,graph,with,configuration,options,param,gather,function,the,gather,function,collects,information,about,adjacent,vertices,and,edges,param,sum,function,the,sum,function,aggregates,the,gathered,information,param,apply,function,the,apply,function,updates,the,vertex,values,with,the,aggregates,param,maximum,number,of,iterations,maximum,number,of,iterations,to,perform,param,parameters,the,iteration,configuration,parameters,param,m,the,intermediate,type,used,between,gather,sum,and,apply,return,the,updated,graph,after,the,gather,sum,apply,iteration,has,converged,or,after,maximum,number,of,iterations;public,m,graph,k,vv,ev,run,gather,sum,apply,iteration,gather,function,vv,ev,m,gather,function,sum,function,vv,ev,m,sum,function,apply,function,k,vv,m,apply,function,int,maximum,number,of,iterations,gsaconfiguration,parameters,gather,sum,apply,iteration,k,vv,ev,m,iteration,gather,sum,apply,iteration,with,edges,edges,gather,function,sum,function,apply,function,maximum,number,of,iterations,iteration,configure,parameters,data,set,vertex,k,vv,new,vertices,vertices,run,operation,iteration,return,new,graph,k,vv,ev,new,vertices,this,edges,this,context
Graph -> public <M> Graph<K, VV, EV> runGatherSumApplyIteration( 			GatherFunction<VV, EV, M> gatherFunction, SumFunction<VV, EV, M> sumFunction, 			ApplyFunction<K, VV, M> applyFunction, int maximumNumberOfIterations, 			GSAConfiguration parameters);1445854323;Runs a Gather-Sum-Apply iteration on the graph with configuration options.__@param gatherFunction the gather function collects information about adjacent vertices and edges_@param sumFunction the sum function aggregates the gathered information_@param applyFunction the apply function updates the vertex values with the aggregates_@param maximumNumberOfIterations maximum number of iterations to perform_@param parameters the iteration configuration parameters_@param <M> the intermediate type used between gather, sum and apply__@return the updated Graph after the gather-sum-apply iteration has converged or_after maximumNumberOfIterations.;public <M> Graph<K, VV, EV> runGatherSumApplyIteration(_			GatherFunction<VV, EV, M> gatherFunction, SumFunction<VV, EV, M> sumFunction,_			ApplyFunction<K, VV, M> applyFunction, int maximumNumberOfIterations,_			GSAConfiguration parameters) {__		GatherSumApplyIteration<K, VV, EV, M> iteration = GatherSumApplyIteration.withEdges(_				edges, gatherFunction, sumFunction, applyFunction, maximumNumberOfIterations)___		iteration.configure(parameters)___		DataSet<Vertex<K, VV>> newVertices = vertices.runOperation(iteration)___		return new Graph<K, VV, EV>(newVertices, this.edges, this.context)__	};runs,a,gather,sum,apply,iteration,on,the,graph,with,configuration,options,param,gather,function,the,gather,function,collects,information,about,adjacent,vertices,and,edges,param,sum,function,the,sum,function,aggregates,the,gathered,information,param,apply,function,the,apply,function,updates,the,vertex,values,with,the,aggregates,param,maximum,number,of,iterations,maximum,number,of,iterations,to,perform,param,parameters,the,iteration,configuration,parameters,param,m,the,intermediate,type,used,between,gather,sum,and,apply,return,the,updated,graph,after,the,gather,sum,apply,iteration,has,converged,or,after,maximum,number,of,iterations;public,m,graph,k,vv,ev,run,gather,sum,apply,iteration,gather,function,vv,ev,m,gather,function,sum,function,vv,ev,m,sum,function,apply,function,k,vv,m,apply,function,int,maximum,number,of,iterations,gsaconfiguration,parameters,gather,sum,apply,iteration,k,vv,ev,m,iteration,gather,sum,apply,iteration,with,edges,edges,gather,function,sum,function,apply,function,maximum,number,of,iterations,iteration,configure,parameters,data,set,vertex,k,vv,new,vertices,vertices,run,operation,iteration,return,new,graph,k,vv,ev,new,vertices,this,edges,this,context
Graph -> public <M> Graph<K, VV, EV> runGatherSumApplyIteration( 			GatherFunction<VV, EV, M> gatherFunction, SumFunction<VV, EV, M> sumFunction, 			ApplyFunction<K, VV, M> applyFunction, int maximumNumberOfIterations, 			GSAConfiguration parameters);1446112342;Runs a Gather-Sum-Apply iteration on the graph with configuration options.__@param gatherFunction the gather function collects information about adjacent vertices and edges_@param sumFunction the sum function aggregates the gathered information_@param applyFunction the apply function updates the vertex values with the aggregates_@param maximumNumberOfIterations maximum number of iterations to perform_@param parameters the iteration configuration parameters_@param <M> the intermediate type used between gather, sum and apply__@return the updated Graph after the gather-sum-apply iteration has converged or_after maximumNumberOfIterations.;public <M> Graph<K, VV, EV> runGatherSumApplyIteration(_			GatherFunction<VV, EV, M> gatherFunction, SumFunction<VV, EV, M> sumFunction,_			ApplyFunction<K, VV, M> applyFunction, int maximumNumberOfIterations,_			GSAConfiguration parameters) {__		GatherSumApplyIteration<K, VV, EV, M> iteration = GatherSumApplyIteration.withEdges(_				edges, gatherFunction, sumFunction, applyFunction, maximumNumberOfIterations)___		iteration.configure(parameters)___		DataSet<Vertex<K, VV>> newVertices = vertices.runOperation(iteration)___		return new Graph<K, VV, EV>(newVertices, this.edges, this.context)__	};runs,a,gather,sum,apply,iteration,on,the,graph,with,configuration,options,param,gather,function,the,gather,function,collects,information,about,adjacent,vertices,and,edges,param,sum,function,the,sum,function,aggregates,the,gathered,information,param,apply,function,the,apply,function,updates,the,vertex,values,with,the,aggregates,param,maximum,number,of,iterations,maximum,number,of,iterations,to,perform,param,parameters,the,iteration,configuration,parameters,param,m,the,intermediate,type,used,between,gather,sum,and,apply,return,the,updated,graph,after,the,gather,sum,apply,iteration,has,converged,or,after,maximum,number,of,iterations;public,m,graph,k,vv,ev,run,gather,sum,apply,iteration,gather,function,vv,ev,m,gather,function,sum,function,vv,ev,m,sum,function,apply,function,k,vv,m,apply,function,int,maximum,number,of,iterations,gsaconfiguration,parameters,gather,sum,apply,iteration,k,vv,ev,m,iteration,gather,sum,apply,iteration,with,edges,edges,gather,function,sum,function,apply,function,maximum,number,of,iterations,iteration,configure,parameters,data,set,vertex,k,vv,new,vertices,vertices,run,operation,iteration,return,new,graph,k,vv,ev,new,vertices,this,edges,this,context
Graph -> public <M> Graph<K, VV, EV> runGatherSumApplyIteration( 			GatherFunction<VV, EV, M> gatherFunction, SumFunction<VV, EV, M> sumFunction, 			ApplyFunction<K, VV, M> applyFunction, int maximumNumberOfIterations, 			GSAConfiguration parameters);1447073368;Runs a Gather-Sum-Apply iteration on the graph with configuration options.__@param gatherFunction the gather function collects information about adjacent vertices and edges_@param sumFunction the sum function aggregates the gathered information_@param applyFunction the apply function updates the vertex values with the aggregates_@param maximumNumberOfIterations maximum number of iterations to perform_@param parameters the iteration configuration parameters_@param <M> the intermediate type used between gather, sum and apply__@return the updated Graph after the gather-sum-apply iteration has converged or_after maximumNumberOfIterations.;public <M> Graph<K, VV, EV> runGatherSumApplyIteration(_			GatherFunction<VV, EV, M> gatherFunction, SumFunction<VV, EV, M> sumFunction,_			ApplyFunction<K, VV, M> applyFunction, int maximumNumberOfIterations,_			GSAConfiguration parameters) {__		GatherSumApplyIteration<K, VV, EV, M> iteration = GatherSumApplyIteration.withEdges(_				edges, gatherFunction, sumFunction, applyFunction, maximumNumberOfIterations)___		iteration.configure(parameters)___		DataSet<Vertex<K, VV>> newVertices = vertices.runOperation(iteration)___		return new Graph<K, VV, EV>(newVertices, this.edges, this.context)__	};runs,a,gather,sum,apply,iteration,on,the,graph,with,configuration,options,param,gather,function,the,gather,function,collects,information,about,adjacent,vertices,and,edges,param,sum,function,the,sum,function,aggregates,the,gathered,information,param,apply,function,the,apply,function,updates,the,vertex,values,with,the,aggregates,param,maximum,number,of,iterations,maximum,number,of,iterations,to,perform,param,parameters,the,iteration,configuration,parameters,param,m,the,intermediate,type,used,between,gather,sum,and,apply,return,the,updated,graph,after,the,gather,sum,apply,iteration,has,converged,or,after,maximum,number,of,iterations;public,m,graph,k,vv,ev,run,gather,sum,apply,iteration,gather,function,vv,ev,m,gather,function,sum,function,vv,ev,m,sum,function,apply,function,k,vv,m,apply,function,int,maximum,number,of,iterations,gsaconfiguration,parameters,gather,sum,apply,iteration,k,vv,ev,m,iteration,gather,sum,apply,iteration,with,edges,edges,gather,function,sum,function,apply,function,maximum,number,of,iterations,iteration,configure,parameters,data,set,vertex,k,vv,new,vertices,vertices,run,operation,iteration,return,new,graph,k,vv,ev,new,vertices,this,edges,this,context
Graph -> public <M> Graph<K, VV, EV> runGatherSumApplyIteration( 			GatherFunction<VV, EV, M> gatherFunction, SumFunction<VV, EV, M> sumFunction, 			ApplyFunction<K, VV, M> applyFunction, int maximumNumberOfIterations, 			GSAConfiguration parameters);1454404649;Runs a Gather-Sum-Apply iteration on the graph with configuration options.__@param gatherFunction the gather function collects information about adjacent vertices and edges_@param sumFunction the sum function aggregates the gathered information_@param applyFunction the apply function updates the vertex values with the aggregates_@param maximumNumberOfIterations maximum number of iterations to perform_@param parameters the iteration configuration parameters_@param <M> the intermediate type used between gather, sum and apply__@return the updated Graph after the gather-sum-apply iteration has converged or_after maximumNumberOfIterations.;public <M> Graph<K, VV, EV> runGatherSumApplyIteration(_			GatherFunction<VV, EV, M> gatherFunction, SumFunction<VV, EV, M> sumFunction,_			ApplyFunction<K, VV, M> applyFunction, int maximumNumberOfIterations,_			GSAConfiguration parameters) {__		GatherSumApplyIteration<K, VV, EV, M> iteration = GatherSumApplyIteration.withEdges(_				edges, gatherFunction, sumFunction, applyFunction, maximumNumberOfIterations)___		iteration.configure(parameters)___		DataSet<Vertex<K, VV>> newVertices = vertices.runOperation(iteration)___		return new Graph<K, VV, EV>(newVertices, this.edges, this.context)__	};runs,a,gather,sum,apply,iteration,on,the,graph,with,configuration,options,param,gather,function,the,gather,function,collects,information,about,adjacent,vertices,and,edges,param,sum,function,the,sum,function,aggregates,the,gathered,information,param,apply,function,the,apply,function,updates,the,vertex,values,with,the,aggregates,param,maximum,number,of,iterations,maximum,number,of,iterations,to,perform,param,parameters,the,iteration,configuration,parameters,param,m,the,intermediate,type,used,between,gather,sum,and,apply,return,the,updated,graph,after,the,gather,sum,apply,iteration,has,converged,or,after,maximum,number,of,iterations;public,m,graph,k,vv,ev,run,gather,sum,apply,iteration,gather,function,vv,ev,m,gather,function,sum,function,vv,ev,m,sum,function,apply,function,k,vv,m,apply,function,int,maximum,number,of,iterations,gsaconfiguration,parameters,gather,sum,apply,iteration,k,vv,ev,m,iteration,gather,sum,apply,iteration,with,edges,edges,gather,function,sum,function,apply,function,maximum,number,of,iterations,iteration,configure,parameters,data,set,vertex,k,vv,new,vertices,vertices,run,operation,iteration,return,new,graph,k,vv,ev,new,vertices,this,edges,this,context
Graph -> public <M> Graph<K, VV, EV> runGatherSumApplyIteration( 			GatherFunction<VV, EV, M> gatherFunction, SumFunction<VV, EV, M> sumFunction, 			ApplyFunction<K, VV, M> applyFunction, int maximumNumberOfIterations, 			GSAConfiguration parameters);1458583829;Runs a Gather-Sum-Apply iteration on the graph with configuration options.__@param gatherFunction the gather function collects information about adjacent vertices and edges_@param sumFunction the sum function aggregates the gathered information_@param applyFunction the apply function updates the vertex values with the aggregates_@param maximumNumberOfIterations maximum number of iterations to perform_@param parameters the iteration configuration parameters_@param <M> the intermediate type used between gather, sum and apply__@return the updated Graph after the gather-sum-apply iteration has converged or_after maximumNumberOfIterations.;public <M> Graph<K, VV, EV> runGatherSumApplyIteration(_			GatherFunction<VV, EV, M> gatherFunction, SumFunction<VV, EV, M> sumFunction,_			ApplyFunction<K, VV, M> applyFunction, int maximumNumberOfIterations,_			GSAConfiguration parameters) {__		GatherSumApplyIteration<K, VV, EV, M> iteration = GatherSumApplyIteration.withEdges(_				edges, gatherFunction, sumFunction, applyFunction, maximumNumberOfIterations)___		iteration.configure(parameters)___		DataSet<Vertex<K, VV>> newVertices = vertices.runOperation(iteration)___		return new Graph<K, VV, EV>(newVertices, this.edges, this.context)__	};runs,a,gather,sum,apply,iteration,on,the,graph,with,configuration,options,param,gather,function,the,gather,function,collects,information,about,adjacent,vertices,and,edges,param,sum,function,the,sum,function,aggregates,the,gathered,information,param,apply,function,the,apply,function,updates,the,vertex,values,with,the,aggregates,param,maximum,number,of,iterations,maximum,number,of,iterations,to,perform,param,parameters,the,iteration,configuration,parameters,param,m,the,intermediate,type,used,between,gather,sum,and,apply,return,the,updated,graph,after,the,gather,sum,apply,iteration,has,converged,or,after,maximum,number,of,iterations;public,m,graph,k,vv,ev,run,gather,sum,apply,iteration,gather,function,vv,ev,m,gather,function,sum,function,vv,ev,m,sum,function,apply,function,k,vv,m,apply,function,int,maximum,number,of,iterations,gsaconfiguration,parameters,gather,sum,apply,iteration,k,vv,ev,m,iteration,gather,sum,apply,iteration,with,edges,edges,gather,function,sum,function,apply,function,maximum,number,of,iterations,iteration,configure,parameters,data,set,vertex,k,vv,new,vertices,vertices,run,operation,iteration,return,new,graph,k,vv,ev,new,vertices,this,edges,this,context
Graph -> public <M> Graph<K, VV, EV> runGatherSumApplyIteration( 			GatherFunction<VV, EV, M> gatherFunction, SumFunction<VV, EV, M> sumFunction, 			ApplyFunction<K, VV, M> applyFunction, int maximumNumberOfIterations, 			GSAConfiguration parameters);1458583829;Runs a Gather-Sum-Apply iteration on the graph with configuration options.__@param gatherFunction the gather function collects information about adjacent vertices and edges_@param sumFunction the sum function aggregates the gathered information_@param applyFunction the apply function updates the vertex values with the aggregates_@param maximumNumberOfIterations maximum number of iterations to perform_@param parameters the iteration configuration parameters_@param <M> the intermediate type used between gather, sum and apply__@return the updated Graph after the gather-sum-apply iteration has converged or_after maximumNumberOfIterations.;public <M> Graph<K, VV, EV> runGatherSumApplyIteration(_			GatherFunction<VV, EV, M> gatherFunction, SumFunction<VV, EV, M> sumFunction,_			ApplyFunction<K, VV, M> applyFunction, int maximumNumberOfIterations,_			GSAConfiguration parameters) {__		GatherSumApplyIteration<K, VV, EV, M> iteration = GatherSumApplyIteration.withEdges(_				edges, gatherFunction, sumFunction, applyFunction, maximumNumberOfIterations)___		iteration.configure(parameters)___		DataSet<Vertex<K, VV>> newVertices = vertices.runOperation(iteration)___		return new Graph<K, VV, EV>(newVertices, this.edges, this.context)__	};runs,a,gather,sum,apply,iteration,on,the,graph,with,configuration,options,param,gather,function,the,gather,function,collects,information,about,adjacent,vertices,and,edges,param,sum,function,the,sum,function,aggregates,the,gathered,information,param,apply,function,the,apply,function,updates,the,vertex,values,with,the,aggregates,param,maximum,number,of,iterations,maximum,number,of,iterations,to,perform,param,parameters,the,iteration,configuration,parameters,param,m,the,intermediate,type,used,between,gather,sum,and,apply,return,the,updated,graph,after,the,gather,sum,apply,iteration,has,converged,or,after,maximum,number,of,iterations;public,m,graph,k,vv,ev,run,gather,sum,apply,iteration,gather,function,vv,ev,m,gather,function,sum,function,vv,ev,m,sum,function,apply,function,k,vv,m,apply,function,int,maximum,number,of,iterations,gsaconfiguration,parameters,gather,sum,apply,iteration,k,vv,ev,m,iteration,gather,sum,apply,iteration,with,edges,edges,gather,function,sum,function,apply,function,maximum,number,of,iterations,iteration,configure,parameters,data,set,vertex,k,vv,new,vertices,vertices,run,operation,iteration,return,new,graph,k,vv,ev,new,vertices,this,edges,this,context
Graph -> public <M> Graph<K, VV, EV> runGatherSumApplyIteration( 			GatherFunction<VV, EV, M> gatherFunction, SumFunction<VV, EV, M> sumFunction, 			ApplyFunction<K, VV, M> applyFunction, int maximumNumberOfIterations, 			GSAConfiguration parameters);1462100316;Runs a Gather-Sum-Apply iteration on the graph with configuration options.__@param gatherFunction the gather function collects information about adjacent vertices and edges_@param sumFunction the sum function aggregates the gathered information_@param applyFunction the apply function updates the vertex values with the aggregates_@param maximumNumberOfIterations maximum number of iterations to perform_@param parameters the iteration configuration parameters_@param <M> the intermediate type used between gather, sum and apply__@return the updated Graph after the gather-sum-apply iteration has converged or_after maximumNumberOfIterations.;public <M> Graph<K, VV, EV> runGatherSumApplyIteration(_			GatherFunction<VV, EV, M> gatherFunction, SumFunction<VV, EV, M> sumFunction,_			ApplyFunction<K, VV, M> applyFunction, int maximumNumberOfIterations,_			GSAConfiguration parameters) {__		GatherSumApplyIteration<K, VV, EV, M> iteration = GatherSumApplyIteration.withEdges(_				edges, gatherFunction, sumFunction, applyFunction, maximumNumberOfIterations)___		iteration.configure(parameters)___		DataSet<Vertex<K, VV>> newVertices = vertices.runOperation(iteration)___		return new Graph<K, VV, EV>(newVertices, this.edges, this.context)__	};runs,a,gather,sum,apply,iteration,on,the,graph,with,configuration,options,param,gather,function,the,gather,function,collects,information,about,adjacent,vertices,and,edges,param,sum,function,the,sum,function,aggregates,the,gathered,information,param,apply,function,the,apply,function,updates,the,vertex,values,with,the,aggregates,param,maximum,number,of,iterations,maximum,number,of,iterations,to,perform,param,parameters,the,iteration,configuration,parameters,param,m,the,intermediate,type,used,between,gather,sum,and,apply,return,the,updated,graph,after,the,gather,sum,apply,iteration,has,converged,or,after,maximum,number,of,iterations;public,m,graph,k,vv,ev,run,gather,sum,apply,iteration,gather,function,vv,ev,m,gather,function,sum,function,vv,ev,m,sum,function,apply,function,k,vv,m,apply,function,int,maximum,number,of,iterations,gsaconfiguration,parameters,gather,sum,apply,iteration,k,vv,ev,m,iteration,gather,sum,apply,iteration,with,edges,edges,gather,function,sum,function,apply,function,maximum,number,of,iterations,iteration,configure,parameters,data,set,vertex,k,vv,new,vertices,vertices,run,operation,iteration,return,new,graph,k,vv,ev,new,vertices,this,edges,this,context
Graph -> public <M> Graph<K, VV, EV> runGatherSumApplyIteration( 			GatherFunction<VV, EV, M> gatherFunction, SumFunction<VV, EV, M> sumFunction, 			ApplyFunction<K, VV, M> applyFunction, int maximumNumberOfIterations, 			GSAConfiguration parameters);1462100316;Runs a Gather-Sum-Apply iteration on the graph with configuration options.__@param gatherFunction the gather function collects information about adjacent vertices and edges_@param sumFunction the sum function aggregates the gathered information_@param applyFunction the apply function updates the vertex values with the aggregates_@param maximumNumberOfIterations maximum number of iterations to perform_@param parameters the iteration configuration parameters_@param <M> the intermediate type used between gather, sum and apply__@return the updated Graph after the gather-sum-apply iteration has converged or_after maximumNumberOfIterations.;public <M> Graph<K, VV, EV> runGatherSumApplyIteration(_			GatherFunction<VV, EV, M> gatherFunction, SumFunction<VV, EV, M> sumFunction,_			ApplyFunction<K, VV, M> applyFunction, int maximumNumberOfIterations,_			GSAConfiguration parameters) {__		GatherSumApplyIteration<K, VV, EV, M> iteration = GatherSumApplyIteration.withEdges(_				edges, gatherFunction, sumFunction, applyFunction, maximumNumberOfIterations)___		iteration.configure(parameters)___		DataSet<Vertex<K, VV>> newVertices = vertices.runOperation(iteration)___		return new Graph<K, VV, EV>(newVertices, this.edges, this.context)__	};runs,a,gather,sum,apply,iteration,on,the,graph,with,configuration,options,param,gather,function,the,gather,function,collects,information,about,adjacent,vertices,and,edges,param,sum,function,the,sum,function,aggregates,the,gathered,information,param,apply,function,the,apply,function,updates,the,vertex,values,with,the,aggregates,param,maximum,number,of,iterations,maximum,number,of,iterations,to,perform,param,parameters,the,iteration,configuration,parameters,param,m,the,intermediate,type,used,between,gather,sum,and,apply,return,the,updated,graph,after,the,gather,sum,apply,iteration,has,converged,or,after,maximum,number,of,iterations;public,m,graph,k,vv,ev,run,gather,sum,apply,iteration,gather,function,vv,ev,m,gather,function,sum,function,vv,ev,m,sum,function,apply,function,k,vv,m,apply,function,int,maximum,number,of,iterations,gsaconfiguration,parameters,gather,sum,apply,iteration,k,vv,ev,m,iteration,gather,sum,apply,iteration,with,edges,edges,gather,function,sum,function,apply,function,maximum,number,of,iterations,iteration,configure,parameters,data,set,vertex,k,vv,new,vertices,vertices,run,operation,iteration,return,new,graph,k,vv,ev,new,vertices,this,edges,this,context
Graph -> public <M> Graph<K, VV, EV> runGatherSumApplyIteration( 			GatherFunction<VV, EV, M> gatherFunction, SumFunction<VV, EV, M> sumFunction, 			ApplyFunction<K, VV, M> applyFunction, int maximumNumberOfIterations, 			GSAConfiguration parameters);1462205213;Runs a Gather-Sum-Apply iteration on the graph with configuration options.__@param gatherFunction the gather function collects information about adjacent vertices and edges_@param sumFunction the sum function aggregates the gathered information_@param applyFunction the apply function updates the vertex values with the aggregates_@param maximumNumberOfIterations maximum number of iterations to perform_@param parameters the iteration configuration parameters_@param <M> the intermediate type used between gather, sum and apply__@return the updated Graph after the gather-sum-apply iteration has converged or_after maximumNumberOfIterations.;public <M> Graph<K, VV, EV> runGatherSumApplyIteration(_			GatherFunction<VV, EV, M> gatherFunction, SumFunction<VV, EV, M> sumFunction,_			ApplyFunction<K, VV, M> applyFunction, int maximumNumberOfIterations,_			GSAConfiguration parameters) {__		GatherSumApplyIteration<K, VV, EV, M> iteration = GatherSumApplyIteration.withEdges(_				edges, gatherFunction, sumFunction, applyFunction, maximumNumberOfIterations)___		iteration.configure(parameters)___		DataSet<Vertex<K, VV>> newVertices = vertices.runOperation(iteration)___		return new Graph<K, VV, EV>(newVertices, this.edges, this.context)__	};runs,a,gather,sum,apply,iteration,on,the,graph,with,configuration,options,param,gather,function,the,gather,function,collects,information,about,adjacent,vertices,and,edges,param,sum,function,the,sum,function,aggregates,the,gathered,information,param,apply,function,the,apply,function,updates,the,vertex,values,with,the,aggregates,param,maximum,number,of,iterations,maximum,number,of,iterations,to,perform,param,parameters,the,iteration,configuration,parameters,param,m,the,intermediate,type,used,between,gather,sum,and,apply,return,the,updated,graph,after,the,gather,sum,apply,iteration,has,converged,or,after,maximum,number,of,iterations;public,m,graph,k,vv,ev,run,gather,sum,apply,iteration,gather,function,vv,ev,m,gather,function,sum,function,vv,ev,m,sum,function,apply,function,k,vv,m,apply,function,int,maximum,number,of,iterations,gsaconfiguration,parameters,gather,sum,apply,iteration,k,vv,ev,m,iteration,gather,sum,apply,iteration,with,edges,edges,gather,function,sum,function,apply,function,maximum,number,of,iterations,iteration,configure,parameters,data,set,vertex,k,vv,new,vertices,vertices,run,operation,iteration,return,new,graph,k,vv,ev,new,vertices,this,edges,this,context
Graph -> public <M> Graph<K, VV, EV> runGatherSumApplyIteration( 			GatherFunction<VV, EV, M> gatherFunction, SumFunction<VV, EV, M> sumFunction, 			ApplyFunction<K, VV, M> applyFunction, int maximumNumberOfIterations, 			GSAConfiguration parameters);1462208859;Runs a Gather-Sum-Apply iteration on the graph with configuration options.__@param gatherFunction the gather function collects information about adjacent vertices and edges_@param sumFunction the sum function aggregates the gathered information_@param applyFunction the apply function updates the vertex values with the aggregates_@param maximumNumberOfIterations maximum number of iterations to perform_@param parameters the iteration configuration parameters_@param <M> the intermediate type used between gather, sum and apply__@return the updated Graph after the gather-sum-apply iteration has converged or_after maximumNumberOfIterations.;public <M> Graph<K, VV, EV> runGatherSumApplyIteration(_			GatherFunction<VV, EV, M> gatherFunction, SumFunction<VV, EV, M> sumFunction,_			ApplyFunction<K, VV, M> applyFunction, int maximumNumberOfIterations,_			GSAConfiguration parameters) {__		GatherSumApplyIteration<K, VV, EV, M> iteration = GatherSumApplyIteration.withEdges(_				edges, gatherFunction, sumFunction, applyFunction, maximumNumberOfIterations)___		iteration.configure(parameters)___		DataSet<Vertex<K, VV>> newVertices = vertices.runOperation(iteration)___		return new Graph<K, VV, EV>(newVertices, this.edges, this.context)__	};runs,a,gather,sum,apply,iteration,on,the,graph,with,configuration,options,param,gather,function,the,gather,function,collects,information,about,adjacent,vertices,and,edges,param,sum,function,the,sum,function,aggregates,the,gathered,information,param,apply,function,the,apply,function,updates,the,vertex,values,with,the,aggregates,param,maximum,number,of,iterations,maximum,number,of,iterations,to,perform,param,parameters,the,iteration,configuration,parameters,param,m,the,intermediate,type,used,between,gather,sum,and,apply,return,the,updated,graph,after,the,gather,sum,apply,iteration,has,converged,or,after,maximum,number,of,iterations;public,m,graph,k,vv,ev,run,gather,sum,apply,iteration,gather,function,vv,ev,m,gather,function,sum,function,vv,ev,m,sum,function,apply,function,k,vv,m,apply,function,int,maximum,number,of,iterations,gsaconfiguration,parameters,gather,sum,apply,iteration,k,vv,ev,m,iteration,gather,sum,apply,iteration,with,edges,edges,gather,function,sum,function,apply,function,maximum,number,of,iterations,iteration,configure,parameters,data,set,vertex,k,vv,new,vertices,vertices,run,operation,iteration,return,new,graph,k,vv,ev,new,vertices,this,edges,this,context
Graph -> public <M> Graph<K, VV, EV> runGatherSumApplyIteration( 			GatherFunction<VV, EV, M> gatherFunction, SumFunction<VV, EV, M> sumFunction, 			ApplyFunction<K, VV, M> applyFunction, int maximumNumberOfIterations, 			GSAConfiguration parameters);1462809297;Runs a Gather-Sum-Apply iteration on the graph with configuration options.__@param gatherFunction the gather function collects information about adjacent vertices and edges_@param sumFunction the sum function aggregates the gathered information_@param applyFunction the apply function updates the vertex values with the aggregates_@param maximumNumberOfIterations maximum number of iterations to perform_@param parameters the iteration configuration parameters_@param <M> the intermediate type used between gather, sum and apply__@return the updated Graph after the gather-sum-apply iteration has converged or_after maximumNumberOfIterations.;public <M> Graph<K, VV, EV> runGatherSumApplyIteration(_			GatherFunction<VV, EV, M> gatherFunction, SumFunction<VV, EV, M> sumFunction,_			ApplyFunction<K, VV, M> applyFunction, int maximumNumberOfIterations,_			GSAConfiguration parameters) {__		GatherSumApplyIteration<K, VV, EV, M> iteration = GatherSumApplyIteration.withEdges(_				edges, gatherFunction, sumFunction, applyFunction, maximumNumberOfIterations)___		iteration.configure(parameters)___		DataSet<Vertex<K, VV>> newVertices = vertices.runOperation(iteration)___		return new Graph<K, VV, EV>(newVertices, this.edges, this.context)__	};runs,a,gather,sum,apply,iteration,on,the,graph,with,configuration,options,param,gather,function,the,gather,function,collects,information,about,adjacent,vertices,and,edges,param,sum,function,the,sum,function,aggregates,the,gathered,information,param,apply,function,the,apply,function,updates,the,vertex,values,with,the,aggregates,param,maximum,number,of,iterations,maximum,number,of,iterations,to,perform,param,parameters,the,iteration,configuration,parameters,param,m,the,intermediate,type,used,between,gather,sum,and,apply,return,the,updated,graph,after,the,gather,sum,apply,iteration,has,converged,or,after,maximum,number,of,iterations;public,m,graph,k,vv,ev,run,gather,sum,apply,iteration,gather,function,vv,ev,m,gather,function,sum,function,vv,ev,m,sum,function,apply,function,k,vv,m,apply,function,int,maximum,number,of,iterations,gsaconfiguration,parameters,gather,sum,apply,iteration,k,vv,ev,m,iteration,gather,sum,apply,iteration,with,edges,edges,gather,function,sum,function,apply,function,maximum,number,of,iterations,iteration,configure,parameters,data,set,vertex,k,vv,new,vertices,vertices,run,operation,iteration,return,new,graph,k,vv,ev,new,vertices,this,edges,this,context
Graph -> public <M> Graph<K, VV, EV> runGatherSumApplyIteration( 			GatherFunction<VV, EV, M> gatherFunction, SumFunction<VV, EV, M> sumFunction, 			ApplyFunction<K, VV, M> applyFunction, int maximumNumberOfIterations, 			GSAConfiguration parameters);1465316775;Runs a Gather-Sum-Apply iteration on the graph with configuration options.__@param gatherFunction the gather function collects information about adjacent vertices and edges_@param sumFunction the sum function aggregates the gathered information_@param applyFunction the apply function updates the vertex values with the aggregates_@param maximumNumberOfIterations maximum number of iterations to perform_@param parameters the iteration configuration parameters_@param <M> the intermediate type used between gather, sum and apply__@return the updated Graph after the gather-sum-apply iteration has converged or_after maximumNumberOfIterations.;public <M> Graph<K, VV, EV> runGatherSumApplyIteration(_			GatherFunction<VV, EV, M> gatherFunction, SumFunction<VV, EV, M> sumFunction,_			ApplyFunction<K, VV, M> applyFunction, int maximumNumberOfIterations,_			GSAConfiguration parameters) {__		GatherSumApplyIteration<K, VV, EV, M> iteration = GatherSumApplyIteration.withEdges(_				edges, gatherFunction, sumFunction, applyFunction, maximumNumberOfIterations)___		iteration.configure(parameters)___		DataSet<Vertex<K, VV>> newVertices = vertices.runOperation(iteration)___		return new Graph<K, VV, EV>(newVertices, this.edges, this.context)__	};runs,a,gather,sum,apply,iteration,on,the,graph,with,configuration,options,param,gather,function,the,gather,function,collects,information,about,adjacent,vertices,and,edges,param,sum,function,the,sum,function,aggregates,the,gathered,information,param,apply,function,the,apply,function,updates,the,vertex,values,with,the,aggregates,param,maximum,number,of,iterations,maximum,number,of,iterations,to,perform,param,parameters,the,iteration,configuration,parameters,param,m,the,intermediate,type,used,between,gather,sum,and,apply,return,the,updated,graph,after,the,gather,sum,apply,iteration,has,converged,or,after,maximum,number,of,iterations;public,m,graph,k,vv,ev,run,gather,sum,apply,iteration,gather,function,vv,ev,m,gather,function,sum,function,vv,ev,m,sum,function,apply,function,k,vv,m,apply,function,int,maximum,number,of,iterations,gsaconfiguration,parameters,gather,sum,apply,iteration,k,vv,ev,m,iteration,gather,sum,apply,iteration,with,edges,edges,gather,function,sum,function,apply,function,maximum,number,of,iterations,iteration,configure,parameters,data,set,vertex,k,vv,new,vertices,vertices,run,operation,iteration,return,new,graph,k,vv,ev,new,vertices,this,edges,this,context
Graph -> public <M> Graph<K, VV, EV> runGatherSumApplyIteration( 			GatherFunction<VV, EV, M> gatherFunction, SumFunction<VV, EV, M> sumFunction, 			ApplyFunction<K, VV, M> applyFunction, int maximumNumberOfIterations, 			GSAConfiguration parameters);1466789678;Runs a Gather-Sum-Apply iteration on the graph with configuration options.__@param gatherFunction the gather function collects information about adjacent vertices and edges_@param sumFunction the sum function aggregates the gathered information_@param applyFunction the apply function updates the vertex values with the aggregates_@param maximumNumberOfIterations maximum number of iterations to perform_@param parameters the iteration configuration parameters_@param <M> the intermediate type used between gather, sum and apply__@return the updated Graph after the gather-sum-apply iteration has converged or_after maximumNumberOfIterations.;public <M> Graph<K, VV, EV> runGatherSumApplyIteration(_			GatherFunction<VV, EV, M> gatherFunction, SumFunction<VV, EV, M> sumFunction,_			ApplyFunction<K, VV, M> applyFunction, int maximumNumberOfIterations,_			GSAConfiguration parameters) {__		GatherSumApplyIteration<K, VV, EV, M> iteration = GatherSumApplyIteration.withEdges(_				edges, gatherFunction, sumFunction, applyFunction, maximumNumberOfIterations)___		iteration.configure(parameters)___		DataSet<Vertex<K, VV>> newVertices = vertices.runOperation(iteration)___		return new Graph<K, VV, EV>(newVertices, this.edges, this.context)__	};runs,a,gather,sum,apply,iteration,on,the,graph,with,configuration,options,param,gather,function,the,gather,function,collects,information,about,adjacent,vertices,and,edges,param,sum,function,the,sum,function,aggregates,the,gathered,information,param,apply,function,the,apply,function,updates,the,vertex,values,with,the,aggregates,param,maximum,number,of,iterations,maximum,number,of,iterations,to,perform,param,parameters,the,iteration,configuration,parameters,param,m,the,intermediate,type,used,between,gather,sum,and,apply,return,the,updated,graph,after,the,gather,sum,apply,iteration,has,converged,or,after,maximum,number,of,iterations;public,m,graph,k,vv,ev,run,gather,sum,apply,iteration,gather,function,vv,ev,m,gather,function,sum,function,vv,ev,m,sum,function,apply,function,k,vv,m,apply,function,int,maximum,number,of,iterations,gsaconfiguration,parameters,gather,sum,apply,iteration,k,vv,ev,m,iteration,gather,sum,apply,iteration,with,edges,edges,gather,function,sum,function,apply,function,maximum,number,of,iterations,iteration,configure,parameters,data,set,vertex,k,vv,new,vertices,vertices,run,operation,iteration,return,new,graph,k,vv,ev,new,vertices,this,edges,this,context
Graph -> public <M> Graph<K, VV, EV> runGatherSumApplyIteration( 			GatherFunction<VV, EV, M> gatherFunction, SumFunction<VV, EV, M> sumFunction, 			ApplyFunction<K, VV, M> applyFunction, int maximumNumberOfIterations, 			GSAConfiguration parameters);1467140656;Runs a Gather-Sum-Apply iteration on the graph with configuration options.__@param gatherFunction the gather function collects information about adjacent vertices and edges_@param sumFunction the sum function aggregates the gathered information_@param applyFunction the apply function updates the vertex values with the aggregates_@param maximumNumberOfIterations maximum number of iterations to perform_@param parameters the iteration configuration parameters_@param <M> the intermediate type used between gather, sum and apply__@return the updated Graph after the gather-sum-apply iteration has converged or_after maximumNumberOfIterations.;public <M> Graph<K, VV, EV> runGatherSumApplyIteration(_			GatherFunction<VV, EV, M> gatherFunction, SumFunction<VV, EV, M> sumFunction,_			ApplyFunction<K, VV, M> applyFunction, int maximumNumberOfIterations,_			GSAConfiguration parameters) {__		GatherSumApplyIteration<K, VV, EV, M> iteration = GatherSumApplyIteration.withEdges(_				edges, gatherFunction, sumFunction, applyFunction, maximumNumberOfIterations)___		iteration.configure(parameters)___		DataSet<Vertex<K, VV>> newVertices = vertices.runOperation(iteration)___		return new Graph<K, VV, EV>(newVertices, this.edges, this.context)__	};runs,a,gather,sum,apply,iteration,on,the,graph,with,configuration,options,param,gather,function,the,gather,function,collects,information,about,adjacent,vertices,and,edges,param,sum,function,the,sum,function,aggregates,the,gathered,information,param,apply,function,the,apply,function,updates,the,vertex,values,with,the,aggregates,param,maximum,number,of,iterations,maximum,number,of,iterations,to,perform,param,parameters,the,iteration,configuration,parameters,param,m,the,intermediate,type,used,between,gather,sum,and,apply,return,the,updated,graph,after,the,gather,sum,apply,iteration,has,converged,or,after,maximum,number,of,iterations;public,m,graph,k,vv,ev,run,gather,sum,apply,iteration,gather,function,vv,ev,m,gather,function,sum,function,vv,ev,m,sum,function,apply,function,k,vv,m,apply,function,int,maximum,number,of,iterations,gsaconfiguration,parameters,gather,sum,apply,iteration,k,vv,ev,m,iteration,gather,sum,apply,iteration,with,edges,edges,gather,function,sum,function,apply,function,maximum,number,of,iterations,iteration,configure,parameters,data,set,vertex,k,vv,new,vertices,vertices,run,operation,iteration,return,new,graph,k,vv,ev,new,vertices,this,edges,this,context
Graph -> private DataSet<Edge<K, EV>> getPairwiseEdgeIntersection(DataSet<Edge<K, EV>> edges);1447073368;Computes the intersection between the edge set and the given edge set. For all matching pairs, both edges will be_in the resulting data set.__@param edges edges to compute intersection with_@return edge set containing both edges from all matching pairs of the same edge;private DataSet<Edge<K, EV>> getPairwiseEdgeIntersection(DataSet<Edge<K, EV>> edges) {_		return this.getEdges()_				.coGroup(edges)_				.where(0, 1, 2)_				.equalTo(0, 1, 2)_				.with(new MatchingEdgeReducer<K, EV>())__	};computes,the,intersection,between,the,edge,set,and,the,given,edge,set,for,all,matching,pairs,both,edges,will,be,in,the,resulting,data,set,param,edges,edges,to,compute,intersection,with,return,edge,set,containing,both,edges,from,all,matching,pairs,of,the,same,edge;private,data,set,edge,k,ev,get,pairwise,edge,intersection,data,set,edge,k,ev,edges,return,this,get,edges,co,group,edges,where,0,1,2,equal,to,0,1,2,with,new,matching,edge,reducer,k,ev
Graph -> private DataSet<Edge<K, EV>> getPairwiseEdgeIntersection(DataSet<Edge<K, EV>> edges);1454404649;Computes the intersection between the edge set and the given edge set. For all matching pairs, both edges will be_in the resulting data set.__@param edges edges to compute intersection with_@return edge set containing both edges from all matching pairs of the same edge;private DataSet<Edge<K, EV>> getPairwiseEdgeIntersection(DataSet<Edge<K, EV>> edges) {_		return this.getEdges()_				.coGroup(edges)_				.where(0, 1, 2)_				.equalTo(0, 1, 2)_				.with(new MatchingEdgeReducer<K, EV>())__	};computes,the,intersection,between,the,edge,set,and,the,given,edge,set,for,all,matching,pairs,both,edges,will,be,in,the,resulting,data,set,param,edges,edges,to,compute,intersection,with,return,edge,set,containing,both,edges,from,all,matching,pairs,of,the,same,edge;private,data,set,edge,k,ev,get,pairwise,edge,intersection,data,set,edge,k,ev,edges,return,this,get,edges,co,group,edges,where,0,1,2,equal,to,0,1,2,with,new,matching,edge,reducer,k,ev
Graph -> private DataSet<Edge<K, EV>> getPairwiseEdgeIntersection(DataSet<Edge<K, EV>> edges);1458583829;Computes the intersection between the edge set and the given edge set. For all matching pairs, both edges will be_in the resulting data set.__@param edges edges to compute intersection with_@return edge set containing both edges from all matching pairs of the same edge;private DataSet<Edge<K, EV>> getPairwiseEdgeIntersection(DataSet<Edge<K, EV>> edges) {_		return this.getEdges()_				.coGroup(edges)_				.where(0, 1, 2)_				.equalTo(0, 1, 2)_				.with(new MatchingEdgeReducer<K, EV>())__	};computes,the,intersection,between,the,edge,set,and,the,given,edge,set,for,all,matching,pairs,both,edges,will,be,in,the,resulting,data,set,param,edges,edges,to,compute,intersection,with,return,edge,set,containing,both,edges,from,all,matching,pairs,of,the,same,edge;private,data,set,edge,k,ev,get,pairwise,edge,intersection,data,set,edge,k,ev,edges,return,this,get,edges,co,group,edges,where,0,1,2,equal,to,0,1,2,with,new,matching,edge,reducer,k,ev
Graph -> private DataSet<Edge<K, EV>> getPairwiseEdgeIntersection(DataSet<Edge<K, EV>> edges);1458583829;Computes the intersection between the edge set and the given edge set. For all matching pairs, both edges will be_in the resulting data set.__@param edges edges to compute intersection with_@return edge set containing both edges from all matching pairs of the same edge;private DataSet<Edge<K, EV>> getPairwiseEdgeIntersection(DataSet<Edge<K, EV>> edges) {_		return this.getEdges()_				.coGroup(edges)_				.where(0, 1, 2)_				.equalTo(0, 1, 2)_				.with(new MatchingEdgeReducer<K, EV>())__	};computes,the,intersection,between,the,edge,set,and,the,given,edge,set,for,all,matching,pairs,both,edges,will,be,in,the,resulting,data,set,param,edges,edges,to,compute,intersection,with,return,edge,set,containing,both,edges,from,all,matching,pairs,of,the,same,edge;private,data,set,edge,k,ev,get,pairwise,edge,intersection,data,set,edge,k,ev,edges,return,this,get,edges,co,group,edges,where,0,1,2,equal,to,0,1,2,with,new,matching,edge,reducer,k,ev
Graph -> private DataSet<Edge<K, EV>> getPairwiseEdgeIntersection(DataSet<Edge<K, EV>> edges);1462100316;Computes the intersection between the edge set and the given edge set. For all matching pairs, both edges will be_in the resulting data set.__@param edges edges to compute intersection with_@return edge set containing both edges from all matching pairs of the same edge;private DataSet<Edge<K, EV>> getPairwiseEdgeIntersection(DataSet<Edge<K, EV>> edges) {_		return this.getEdges()_				.coGroup(edges)_				.where(0, 1, 2)_				.equalTo(0, 1, 2)_				.with(new MatchingEdgeReducer<K, EV>())__	};computes,the,intersection,between,the,edge,set,and,the,given,edge,set,for,all,matching,pairs,both,edges,will,be,in,the,resulting,data,set,param,edges,edges,to,compute,intersection,with,return,edge,set,containing,both,edges,from,all,matching,pairs,of,the,same,edge;private,data,set,edge,k,ev,get,pairwise,edge,intersection,data,set,edge,k,ev,edges,return,this,get,edges,co,group,edges,where,0,1,2,equal,to,0,1,2,with,new,matching,edge,reducer,k,ev
Graph -> private DataSet<Edge<K, EV>> getPairwiseEdgeIntersection(DataSet<Edge<K, EV>> edges);1462100316;Computes the intersection between the edge set and the given edge set. For all matching pairs, both edges will be_in the resulting data set.__@param edges edges to compute intersection with_@return edge set containing both edges from all matching pairs of the same edge;private DataSet<Edge<K, EV>> getPairwiseEdgeIntersection(DataSet<Edge<K, EV>> edges) {_		return this.getEdges()_				.coGroup(edges)_				.where(0, 1, 2)_				.equalTo(0, 1, 2)_				.with(new MatchingEdgeReducer<K, EV>())__	};computes,the,intersection,between,the,edge,set,and,the,given,edge,set,for,all,matching,pairs,both,edges,will,be,in,the,resulting,data,set,param,edges,edges,to,compute,intersection,with,return,edge,set,containing,both,edges,from,all,matching,pairs,of,the,same,edge;private,data,set,edge,k,ev,get,pairwise,edge,intersection,data,set,edge,k,ev,edges,return,this,get,edges,co,group,edges,where,0,1,2,equal,to,0,1,2,with,new,matching,edge,reducer,k,ev
Graph -> private DataSet<Edge<K, EV>> getPairwiseEdgeIntersection(DataSet<Edge<K, EV>> edges);1462205213;Computes the intersection between the edge set and the given edge set. For all matching pairs, both edges will be_in the resulting data set.__@param edges edges to compute intersection with_@return edge set containing both edges from all matching pairs of the same edge;private DataSet<Edge<K, EV>> getPairwiseEdgeIntersection(DataSet<Edge<K, EV>> edges) {_		return this.getEdges()_				.coGroup(edges)_				.where(0, 1, 2)_				.equalTo(0, 1, 2)_				.with(new MatchingEdgeReducer<K, EV>())__	};computes,the,intersection,between,the,edge,set,and,the,given,edge,set,for,all,matching,pairs,both,edges,will,be,in,the,resulting,data,set,param,edges,edges,to,compute,intersection,with,return,edge,set,containing,both,edges,from,all,matching,pairs,of,the,same,edge;private,data,set,edge,k,ev,get,pairwise,edge,intersection,data,set,edge,k,ev,edges,return,this,get,edges,co,group,edges,where,0,1,2,equal,to,0,1,2,with,new,matching,edge,reducer,k,ev
Graph -> private DataSet<Edge<K, EV>> getPairwiseEdgeIntersection(DataSet<Edge<K, EV>> edges);1462208859;Computes the intersection between the edge set and the given edge set. For all matching pairs, both edges will be_in the resulting data set.__@param edges edges to compute intersection with_@return edge set containing both edges from all matching pairs of the same edge;private DataSet<Edge<K, EV>> getPairwiseEdgeIntersection(DataSet<Edge<K, EV>> edges) {_		return this.getEdges()_				.coGroup(edges)_				.where(0, 1, 2)_				.equalTo(0, 1, 2)_				.with(new MatchingEdgeReducer<K, EV>())__	};computes,the,intersection,between,the,edge,set,and,the,given,edge,set,for,all,matching,pairs,both,edges,will,be,in,the,resulting,data,set,param,edges,edges,to,compute,intersection,with,return,edge,set,containing,both,edges,from,all,matching,pairs,of,the,same,edge;private,data,set,edge,k,ev,get,pairwise,edge,intersection,data,set,edge,k,ev,edges,return,this,get,edges,co,group,edges,where,0,1,2,equal,to,0,1,2,with,new,matching,edge,reducer,k,ev
Graph -> private DataSet<Edge<K, EV>> getPairwiseEdgeIntersection(DataSet<Edge<K, EV>> edges);1462809297;Computes the intersection between the edge set and the given edge set. For all matching pairs, both edges will be_in the resulting data set.__@param edges edges to compute intersection with_@return edge set containing both edges from all matching pairs of the same edge;private DataSet<Edge<K, EV>> getPairwiseEdgeIntersection(DataSet<Edge<K, EV>> edges) {_		return this.getEdges()_				.coGroup(edges)_				.where(0, 1, 2)_				.equalTo(0, 1, 2)_				.with(new MatchingEdgeReducer<K, EV>())__	};computes,the,intersection,between,the,edge,set,and,the,given,edge,set,for,all,matching,pairs,both,edges,will,be,in,the,resulting,data,set,param,edges,edges,to,compute,intersection,with,return,edge,set,containing,both,edges,from,all,matching,pairs,of,the,same,edge;private,data,set,edge,k,ev,get,pairwise,edge,intersection,data,set,edge,k,ev,edges,return,this,get,edges,co,group,edges,where,0,1,2,equal,to,0,1,2,with,new,matching,edge,reducer,k,ev
Graph -> private DataSet<Edge<K, EV>> getPairwiseEdgeIntersection(DataSet<Edge<K, EV>> edges);1465316775;Computes the intersection between the edge set and the given edge set. For all matching pairs, both edges will be_in the resulting data set.__@param edges edges to compute intersection with_@return edge set containing both edges from all matching pairs of the same edge;private DataSet<Edge<K, EV>> getPairwiseEdgeIntersection(DataSet<Edge<K, EV>> edges) {_		return this.getEdges()_				.coGroup(edges)_				.where(0, 1, 2)_				.equalTo(0, 1, 2)_				.with(new MatchingEdgeReducer<K, EV>())__	};computes,the,intersection,between,the,edge,set,and,the,given,edge,set,for,all,matching,pairs,both,edges,will,be,in,the,resulting,data,set,param,edges,edges,to,compute,intersection,with,return,edge,set,containing,both,edges,from,all,matching,pairs,of,the,same,edge;private,data,set,edge,k,ev,get,pairwise,edge,intersection,data,set,edge,k,ev,edges,return,this,get,edges,co,group,edges,where,0,1,2,equal,to,0,1,2,with,new,matching,edge,reducer,k,ev
Graph -> private DataSet<Edge<K, EV>> getPairwiseEdgeIntersection(DataSet<Edge<K, EV>> edges);1466789678;Computes the intersection between the edge set and the given edge set. For all matching pairs, both edges will be_in the resulting data set.__@param edges edges to compute intersection with_@return edge set containing both edges from all matching pairs of the same edge;private DataSet<Edge<K, EV>> getPairwiseEdgeIntersection(DataSet<Edge<K, EV>> edges) {_		return this.getEdges()_				.coGroup(edges)_				.where(0, 1, 2)_				.equalTo(0, 1, 2)_				.with(new MatchingEdgeReducer<K, EV>())__	};computes,the,intersection,between,the,edge,set,and,the,given,edge,set,for,all,matching,pairs,both,edges,will,be,in,the,resulting,data,set,param,edges,edges,to,compute,intersection,with,return,edge,set,containing,both,edges,from,all,matching,pairs,of,the,same,edge;private,data,set,edge,k,ev,get,pairwise,edge,intersection,data,set,edge,k,ev,edges,return,this,get,edges,co,group,edges,where,0,1,2,equal,to,0,1,2,with,new,matching,edge,reducer,k,ev
Graph -> private DataSet<Edge<K, EV>> getPairwiseEdgeIntersection(DataSet<Edge<K, EV>> edges);1467140656;Computes the intersection between the edge set and the given edge set. For all matching pairs, both edges will be_in the resulting data set.__@param edges edges to compute intersection with_@return edge set containing both edges from all matching pairs of the same edge;private DataSet<Edge<K, EV>> getPairwiseEdgeIntersection(DataSet<Edge<K, EV>> edges) {_		return this.getEdges()_				.coGroup(edges)_				.where(0, 1, 2)_				.equalTo(0, 1, 2)_				.with(new MatchingEdgeReducer<K, EV>())__	};computes,the,intersection,between,the,edge,set,and,the,given,edge,set,for,all,matching,pairs,both,edges,will,be,in,the,resulting,data,set,param,edges,edges,to,compute,intersection,with,return,edge,set,containing,both,edges,from,all,matching,pairs,of,the,same,edge;private,data,set,edge,k,ev,get,pairwise,edge,intersection,data,set,edge,k,ev,edges,return,this,get,edges,co,group,edges,where,0,1,2,equal,to,0,1,2,with,new,matching,edge,reducer,k,ev
Graph -> private DataSet<Edge<K, EV>> getPairwiseEdgeIntersection(DataSet<Edge<K, EV>> edges);1467306272;Computes the intersection between the edge set and the given edge set. For all matching pairs, both edges will be_in the resulting data set.__@param edges edges to compute intersection with_@return edge set containing both edges from all matching pairs of the same edge;private DataSet<Edge<K, EV>> getPairwiseEdgeIntersection(DataSet<Edge<K, EV>> edges) {_		return this.getEdges()_				.coGroup(edges)_				.where(0, 1, 2)_				.equalTo(0, 1, 2)_				.with(new MatchingEdgeReducer<K, EV>())__	};computes,the,intersection,between,the,edge,set,and,the,given,edge,set,for,all,matching,pairs,both,edges,will,be,in,the,resulting,data,set,param,edges,edges,to,compute,intersection,with,return,edge,set,containing,both,edges,from,all,matching,pairs,of,the,same,edge;private,data,set,edge,k,ev,get,pairwise,edge,intersection,data,set,edge,k,ev,edges,return,this,get,edges,co,group,edges,where,0,1,2,equal,to,0,1,2,with,new,matching,edge,reducer,k,ev
Graph -> private DataSet<Edge<K, EV>> getPairwiseEdgeIntersection(DataSet<Edge<K, EV>> edges);1470042815;Computes the intersection between the edge set and the given edge set. For all matching pairs, both edges will be_in the resulting data set.__@param edges edges to compute intersection with_@return edge set containing both edges from all matching pairs of the same edge;private DataSet<Edge<K, EV>> getPairwiseEdgeIntersection(DataSet<Edge<K, EV>> edges) {_		return this.getEdges()_				.coGroup(edges)_				.where(0, 1, 2)_				.equalTo(0, 1, 2)_				.with(new MatchingEdgeReducer<K, EV>())__	};computes,the,intersection,between,the,edge,set,and,the,given,edge,set,for,all,matching,pairs,both,edges,will,be,in,the,resulting,data,set,param,edges,edges,to,compute,intersection,with,return,edge,set,containing,both,edges,from,all,matching,pairs,of,the,same,edge;private,data,set,edge,k,ev,get,pairwise,edge,intersection,data,set,edge,k,ev,edges,return,this,get,edges,co,group,edges,where,0,1,2,equal,to,0,1,2,with,new,matching,edge,reducer,k,ev
Graph -> private DataSet<Edge<K, EV>> getPairwiseEdgeIntersection(DataSet<Edge<K, EV>> edges);1475684776;Computes the intersection between the edge set and the given edge set. For all matching pairs, both edges will be_in the resulting data set.__@param edges edges to compute intersection with_@return edge set containing both edges from all matching pairs of the same edge;private DataSet<Edge<K, EV>> getPairwiseEdgeIntersection(DataSet<Edge<K, EV>> edges) {_		return this.getEdges()_				.coGroup(edges)_				.where(0, 1, 2)_				.equalTo(0, 1, 2)_				.with(new MatchingEdgeReducer<K, EV>())__	};computes,the,intersection,between,the,edge,set,and,the,given,edge,set,for,all,matching,pairs,both,edges,will,be,in,the,resulting,data,set,param,edges,edges,to,compute,intersection,with,return,edge,set,containing,both,edges,from,all,matching,pairs,of,the,same,edge;private,data,set,edge,k,ev,get,pairwise,edge,intersection,data,set,edge,k,ev,edges,return,this,get,edges,co,group,edges,where,0,1,2,equal,to,0,1,2,with,new,matching,edge,reducer,k,ev
Graph -> private DataSet<Edge<K, EV>> getPairwiseEdgeIntersection(DataSet<Edge<K, EV>> edges);1475685606;Computes the intersection between the edge set and the given edge set. For all matching pairs, both edges will be_in the resulting data set.__@param edges edges to compute intersection with_@return edge set containing both edges from all matching pairs of the same edge;private DataSet<Edge<K, EV>> getPairwiseEdgeIntersection(DataSet<Edge<K, EV>> edges) {_		return this.getEdges()_				.coGroup(edges)_				.where(0, 1, 2)_				.equalTo(0, 1, 2)_				.with(new MatchingEdgeReducer<K, EV>())__	};computes,the,intersection,between,the,edge,set,and,the,given,edge,set,for,all,matching,pairs,both,edges,will,be,in,the,resulting,data,set,param,edges,edges,to,compute,intersection,with,return,edge,set,containing,both,edges,from,all,matching,pairs,of,the,same,edge;private,data,set,edge,k,ev,get,pairwise,edge,intersection,data,set,edge,k,ev,edges,return,this,get,edges,co,group,edges,where,0,1,2,equal,to,0,1,2,with,new,matching,edge,reducer,k,ev
Graph -> private DataSet<Edge<K, EV>> getPairwiseEdgeIntersection(DataSet<Edge<K, EV>> edges);1481745825;Computes the intersection between the edge set and the given edge set. For all matching pairs, both edges will be_in the resulting data set.__@param edges edges to compute intersection with_@return edge set containing both edges from all matching pairs of the same edge;private DataSet<Edge<K, EV>> getPairwiseEdgeIntersection(DataSet<Edge<K, EV>> edges) {_		return this.getEdges()_				.coGroup(edges)_				.where(0, 1, 2)_				.equalTo(0, 1, 2)_				.with(new MatchingEdgeReducer<K, EV>())_					.name("Intersect edges")__	};computes,the,intersection,between,the,edge,set,and,the,given,edge,set,for,all,matching,pairs,both,edges,will,be,in,the,resulting,data,set,param,edges,edges,to,compute,intersection,with,return,edge,set,containing,both,edges,from,all,matching,pairs,of,the,same,edge;private,data,set,edge,k,ev,get,pairwise,edge,intersection,data,set,edge,k,ev,edges,return,this,get,edges,co,group,edges,where,0,1,2,equal,to,0,1,2,with,new,matching,edge,reducer,k,ev,name,intersect,edges
Graph -> private DataSet<Edge<K, EV>> getPairwiseEdgeIntersection(DataSet<Edge<K, EV>> edges);1481881009;Computes the intersection between the edge set and the given edge set. For all matching pairs, both edges will be_in the resulting data set.__@param edges edges to compute intersection with_@return edge set containing both edges from all matching pairs of the same edge;private DataSet<Edge<K, EV>> getPairwiseEdgeIntersection(DataSet<Edge<K, EV>> edges) {_		return this.getEdges()_				.coGroup(edges)_				.where(0, 1, 2)_				.equalTo(0, 1, 2)_				.with(new MatchingEdgeReducer<K, EV>())_					.name("Intersect edges")__	};computes,the,intersection,between,the,edge,set,and,the,given,edge,set,for,all,matching,pairs,both,edges,will,be,in,the,resulting,data,set,param,edges,edges,to,compute,intersection,with,return,edge,set,containing,both,edges,from,all,matching,pairs,of,the,same,edge;private,data,set,edge,k,ev,get,pairwise,edge,intersection,data,set,edge,k,ev,edges,return,this,get,edges,co,group,edges,where,0,1,2,equal,to,0,1,2,with,new,matching,edge,reducer,k,ev,name,intersect,edges
Graph -> private DataSet<Edge<K, EV>> getPairwiseEdgeIntersection(DataSet<Edge<K, EV>> edges);1484160227;Computes the intersection between the edge set and the given edge set. For all matching pairs, both edges will be_in the resulting data set.__@param edges edges to compute intersection with_@return edge set containing both edges from all matching pairs of the same edge;private DataSet<Edge<K, EV>> getPairwiseEdgeIntersection(DataSet<Edge<K, EV>> edges) {_		return this.getEdges()_				.coGroup(edges)_				.where(0, 1, 2)_				.equalTo(0, 1, 2)_				.with(new MatchingEdgeReducer<K, EV>())_					.name("Intersect edges")__	};computes,the,intersection,between,the,edge,set,and,the,given,edge,set,for,all,matching,pairs,both,edges,will,be,in,the,resulting,data,set,param,edges,edges,to,compute,intersection,with,return,edge,set,containing,both,edges,from,all,matching,pairs,of,the,same,edge;private,data,set,edge,k,ev,get,pairwise,edge,intersection,data,set,edge,k,ev,edges,return,this,get,edges,co,group,edges,where,0,1,2,equal,to,0,1,2,with,new,matching,edge,reducer,k,ev,name,intersect,edges
Graph -> private DataSet<Edge<K, EV>> getPairwiseEdgeIntersection(DataSet<Edge<K, EV>> edges);1484685504;Computes the intersection between the edge set and the given edge set. For all matching pairs, both edges will be_in the resulting data set.__@param edges edges to compute intersection with_@return edge set containing both edges from all matching pairs of the same edge;private DataSet<Edge<K, EV>> getPairwiseEdgeIntersection(DataSet<Edge<K, EV>> edges) {_		return this.getEdges()_				.coGroup(edges)_				.where(0, 1, 2)_				.equalTo(0, 1, 2)_				.with(new MatchingEdgeReducer<K, EV>())_					.name("Intersect edges")__	};computes,the,intersection,between,the,edge,set,and,the,given,edge,set,for,all,matching,pairs,both,edges,will,be,in,the,resulting,data,set,param,edges,edges,to,compute,intersection,with,return,edge,set,containing,both,edges,from,all,matching,pairs,of,the,same,edge;private,data,set,edge,k,ev,get,pairwise,edge,intersection,data,set,edge,k,ev,edges,return,this,get,edges,co,group,edges,where,0,1,2,equal,to,0,1,2,with,new,matching,edge,reducer,k,ev,name,intersect,edges
Graph -> private DataSet<Edge<K, EV>> getPairwiseEdgeIntersection(DataSet<Edge<K, EV>> edges);1489068942;Computes the intersection between the edge set and the given edge set. For all matching pairs, both edges will be_in the resulting data set.__@param edges edges to compute intersection with_@return edge set containing both edges from all matching pairs of the same edge;private DataSet<Edge<K, EV>> getPairwiseEdgeIntersection(DataSet<Edge<K, EV>> edges) {_		return this.getEdges()_				.coGroup(edges)_				.where(0, 1, 2)_				.equalTo(0, 1, 2)_				.with(new MatchingEdgeReducer<K, EV>())_					.name("Intersect edges")__	};computes,the,intersection,between,the,edge,set,and,the,given,edge,set,for,all,matching,pairs,both,edges,will,be,in,the,resulting,data,set,param,edges,edges,to,compute,intersection,with,return,edge,set,containing,both,edges,from,all,matching,pairs,of,the,same,edge;private,data,set,edge,k,ev,get,pairwise,edge,intersection,data,set,edge,k,ev,edges,return,this,get,edges,co,group,edges,where,0,1,2,equal,to,0,1,2,with,new,matching,edge,reducer,k,ev,name,intersect,edges
Graph -> private DataSet<Edge<K, EV>> getPairwiseEdgeIntersection(DataSet<Edge<K, EV>> edges);1490973446;Computes the intersection between the edge set and the given edge set. For all matching pairs, both edges will be_in the resulting data set.__@param edges edges to compute intersection with_@return edge set containing both edges from all matching pairs of the same edge;private DataSet<Edge<K, EV>> getPairwiseEdgeIntersection(DataSet<Edge<K, EV>> edges) {_		return this.getEdges()_				.coGroup(edges)_				.where(0, 1, 2)_				.equalTo(0, 1, 2)_				.with(new MatchingEdgeReducer<K, EV>())_					.name("Intersect edges")__	};computes,the,intersection,between,the,edge,set,and,the,given,edge,set,for,all,matching,pairs,both,edges,will,be,in,the,resulting,data,set,param,edges,edges,to,compute,intersection,with,return,edge,set,containing,both,edges,from,all,matching,pairs,of,the,same,edge;private,data,set,edge,k,ev,get,pairwise,edge,intersection,data,set,edge,k,ev,edges,return,this,get,edges,co,group,edges,where,0,1,2,equal,to,0,1,2,with,new,matching,edge,reducer,k,ev,name,intersect,edges
Graph -> private DataSet<Edge<K, EV>> getPairwiseEdgeIntersection(DataSet<Edge<K, EV>> edges);1495819075;Computes the intersection between the edge set and the given edge set. For all matching pairs, both edges will be_in the resulting data set.__@param edges edges to compute intersection with_@return edge set containing both edges from all matching pairs of the same edge;private DataSet<Edge<K, EV>> getPairwiseEdgeIntersection(DataSet<Edge<K, EV>> edges) {_		return this.getEdges()_				.coGroup(edges)_				.where(0, 1, 2)_				.equalTo(0, 1, 2)_				.with(new MatchingEdgeReducer<K, EV>())_					.name("Intersect edges")__	};computes,the,intersection,between,the,edge,set,and,the,given,edge,set,for,all,matching,pairs,both,edges,will,be,in,the,resulting,data,set,param,edges,edges,to,compute,intersection,with,return,edge,set,containing,both,edges,from,all,matching,pairs,of,the,same,edge;private,data,set,edge,k,ev,get,pairwise,edge,intersection,data,set,edge,k,ev,edges,return,this,get,edges,co,group,edges,where,0,1,2,equal,to,0,1,2,with,new,matching,edge,reducer,k,ev,name,intersect,edges
Graph -> private DataSet<Edge<K, EV>> getPairwiseEdgeIntersection(DataSet<Edge<K, EV>> edges);1502111816;Computes the intersection between the edge set and the given edge set. For all matching pairs, both edges will be_in the resulting data set.__@param edges edges to compute intersection with_@return edge set containing both edges from all matching pairs of the same edge;private DataSet<Edge<K, EV>> getPairwiseEdgeIntersection(DataSet<Edge<K, EV>> edges) {_		return this.getEdges()_				.coGroup(edges)_				.where(0, 1, 2)_				.equalTo(0, 1, 2)_				.with(new MatchingEdgeReducer<>())_					.name("Intersect edges")__	};computes,the,intersection,between,the,edge,set,and,the,given,edge,set,for,all,matching,pairs,both,edges,will,be,in,the,resulting,data,set,param,edges,edges,to,compute,intersection,with,return,edge,set,containing,both,edges,from,all,matching,pairs,of,the,same,edge;private,data,set,edge,k,ev,get,pairwise,edge,intersection,data,set,edge,k,ev,edges,return,this,get,edges,co,group,edges,where,0,1,2,equal,to,0,1,2,with,new,matching,edge,reducer,name,intersect,edges
Graph -> public <NEW> Graph<K, VV, NEW> translateEdgeValues(MapFunction<EV, NEW> translator) throws Exception;1462205213;Translate {@link Edge} values using the given {@link MapFunction}.__@param translator implements conversion from {@code EV} to {@code NEW}_@param <NEW> new edge value type_@return graph with translated edge values_@throws Exception;public <NEW> Graph<K, VV, NEW> translateEdgeValues(MapFunction<EV, NEW> translator) throws Exception {_		return run(new TranslateEdgeValues<K, VV, EV, NEW>(translator))__	};translate,link,edge,values,using,the,given,link,map,function,param,translator,implements,conversion,from,code,ev,to,code,new,param,new,new,edge,value,type,return,graph,with,translated,edge,values,throws,exception;public,new,graph,k,vv,new,translate,edge,values,map,function,ev,new,translator,throws,exception,return,run,new,translate,edge,values,k,vv,ev,new,translator
Graph -> public <NEW> Graph<K, VV, NEW> translateEdgeValues(MapFunction<EV, NEW> translator) throws Exception;1462208859;Translate {@link Edge} values using the given {@link MapFunction}.__@param translator implements conversion from {@code EV} to {@code NEW}_@param <NEW> new edge value type_@return graph with translated edge values_@throws Exception;public <NEW> Graph<K, VV, NEW> translateEdgeValues(MapFunction<EV, NEW> translator) throws Exception {_		return run(new TranslateEdgeValues<K, VV, EV, NEW>(translator))__	};translate,link,edge,values,using,the,given,link,map,function,param,translator,implements,conversion,from,code,ev,to,code,new,param,new,new,edge,value,type,return,graph,with,translated,edge,values,throws,exception;public,new,graph,k,vv,new,translate,edge,values,map,function,ev,new,translator,throws,exception,return,run,new,translate,edge,values,k,vv,ev,new,translator
Graph -> public <M> Graph<K, VV, EV> runGatherSumApplyIteration( 			org.apache.flink.graph.gsa.GatherFunction<VV, EV, M> gatherFunction, SumFunction<VV, EV, M> sumFunction, 			ApplyFunction<K, VV, M> applyFunction, int maximumNumberOfIterations);1475684776;Runs a Gather-Sum-Apply iteration on the graph._No configuration options are provided.__@param gatherFunction the gather function collects information about adjacent vertices and edges_@param sumFunction the sum function aggregates the gathered information_@param applyFunction the apply function updates the vertex values with the aggregates_@param maximumNumberOfIterations maximum number of iterations to perform_@param <M> the intermediate type used between gather, sum and apply__@return the updated Graph after the gather-sum-apply iteration has converged or_after maximumNumberOfIterations.;public <M> Graph<K, VV, EV> runGatherSumApplyIteration(_			org.apache.flink.graph.gsa.GatherFunction<VV, EV, M> gatherFunction, SumFunction<VV, EV, M> sumFunction,_			ApplyFunction<K, VV, M> applyFunction, int maximumNumberOfIterations) {__		return this.runGatherSumApplyIteration(gatherFunction, sumFunction, applyFunction,_				maximumNumberOfIterations, null)__	};runs,a,gather,sum,apply,iteration,on,the,graph,no,configuration,options,are,provided,param,gather,function,the,gather,function,collects,information,about,adjacent,vertices,and,edges,param,sum,function,the,sum,function,aggregates,the,gathered,information,param,apply,function,the,apply,function,updates,the,vertex,values,with,the,aggregates,param,maximum,number,of,iterations,maximum,number,of,iterations,to,perform,param,m,the,intermediate,type,used,between,gather,sum,and,apply,return,the,updated,graph,after,the,gather,sum,apply,iteration,has,converged,or,after,maximum,number,of,iterations;public,m,graph,k,vv,ev,run,gather,sum,apply,iteration,org,apache,flink,graph,gsa,gather,function,vv,ev,m,gather,function,sum,function,vv,ev,m,sum,function,apply,function,k,vv,m,apply,function,int,maximum,number,of,iterations,return,this,run,gather,sum,apply,iteration,gather,function,sum,function,apply,function,maximum,number,of,iterations,null
Graph -> public <M> Graph<K, VV, EV> runGatherSumApplyIteration( 			org.apache.flink.graph.gsa.GatherFunction<VV, EV, M> gatherFunction, SumFunction<VV, EV, M> sumFunction, 			ApplyFunction<K, VV, M> applyFunction, int maximumNumberOfIterations);1475685606;Runs a Gather-Sum-Apply iteration on the graph._No configuration options are provided.__@param gatherFunction the gather function collects information about adjacent vertices and edges_@param sumFunction the sum function aggregates the gathered information_@param applyFunction the apply function updates the vertex values with the aggregates_@param maximumNumberOfIterations maximum number of iterations to perform_@param <M> the intermediate type used between gather, sum and apply__@return the updated Graph after the gather-sum-apply iteration has converged or_after maximumNumberOfIterations.;public <M> Graph<K, VV, EV> runGatherSumApplyIteration(_			org.apache.flink.graph.gsa.GatherFunction<VV, EV, M> gatherFunction, SumFunction<VV, EV, M> sumFunction,_			ApplyFunction<K, VV, M> applyFunction, int maximumNumberOfIterations) {__		return this.runGatherSumApplyIteration(gatherFunction, sumFunction, applyFunction,_				maximumNumberOfIterations, null)__	};runs,a,gather,sum,apply,iteration,on,the,graph,no,configuration,options,are,provided,param,gather,function,the,gather,function,collects,information,about,adjacent,vertices,and,edges,param,sum,function,the,sum,function,aggregates,the,gathered,information,param,apply,function,the,apply,function,updates,the,vertex,values,with,the,aggregates,param,maximum,number,of,iterations,maximum,number,of,iterations,to,perform,param,m,the,intermediate,type,used,between,gather,sum,and,apply,return,the,updated,graph,after,the,gather,sum,apply,iteration,has,converged,or,after,maximum,number,of,iterations;public,m,graph,k,vv,ev,run,gather,sum,apply,iteration,org,apache,flink,graph,gsa,gather,function,vv,ev,m,gather,function,sum,function,vv,ev,m,sum,function,apply,function,k,vv,m,apply,function,int,maximum,number,of,iterations,return,this,run,gather,sum,apply,iteration,gather,function,sum,function,apply,function,maximum,number,of,iterations,null
Graph -> public <M> Graph<K, VV, EV> runGatherSumApplyIteration( 			org.apache.flink.graph.gsa.GatherFunction<VV, EV, M> gatherFunction, SumFunction<VV, EV, M> sumFunction, 			ApplyFunction<K, VV, M> applyFunction, int maximumNumberOfIterations);1481745825;Runs a Gather-Sum-Apply iteration on the graph._No configuration options are provided.__@param gatherFunction the gather function collects information about adjacent vertices and edges_@param sumFunction the sum function aggregates the gathered information_@param applyFunction the apply function updates the vertex values with the aggregates_@param maximumNumberOfIterations maximum number of iterations to perform_@param <M> the intermediate type used between gather, sum and apply__@return the updated Graph after the gather-sum-apply iteration has converged or_after maximumNumberOfIterations.;public <M> Graph<K, VV, EV> runGatherSumApplyIteration(_			org.apache.flink.graph.gsa.GatherFunction<VV, EV, M> gatherFunction, SumFunction<VV, EV, M> sumFunction,_			ApplyFunction<K, VV, M> applyFunction, int maximumNumberOfIterations) {__		return this.runGatherSumApplyIteration(gatherFunction, sumFunction, applyFunction,_				maximumNumberOfIterations, null)__	};runs,a,gather,sum,apply,iteration,on,the,graph,no,configuration,options,are,provided,param,gather,function,the,gather,function,collects,information,about,adjacent,vertices,and,edges,param,sum,function,the,sum,function,aggregates,the,gathered,information,param,apply,function,the,apply,function,updates,the,vertex,values,with,the,aggregates,param,maximum,number,of,iterations,maximum,number,of,iterations,to,perform,param,m,the,intermediate,type,used,between,gather,sum,and,apply,return,the,updated,graph,after,the,gather,sum,apply,iteration,has,converged,or,after,maximum,number,of,iterations;public,m,graph,k,vv,ev,run,gather,sum,apply,iteration,org,apache,flink,graph,gsa,gather,function,vv,ev,m,gather,function,sum,function,vv,ev,m,sum,function,apply,function,k,vv,m,apply,function,int,maximum,number,of,iterations,return,this,run,gather,sum,apply,iteration,gather,function,sum,function,apply,function,maximum,number,of,iterations,null
Graph -> public <M> Graph<K, VV, EV> runGatherSumApplyIteration( 			org.apache.flink.graph.gsa.GatherFunction<VV, EV, M> gatherFunction, SumFunction<VV, EV, M> sumFunction, 			ApplyFunction<K, VV, M> applyFunction, int maximumNumberOfIterations);1481881009;Runs a Gather-Sum-Apply iteration on the graph._No configuration options are provided.__@param gatherFunction the gather function collects information about adjacent vertices and edges_@param sumFunction the sum function aggregates the gathered information_@param applyFunction the apply function updates the vertex values with the aggregates_@param maximumNumberOfIterations maximum number of iterations to perform_@param <M> the intermediate type used between gather, sum and apply__@return the updated Graph after the gather-sum-apply iteration has converged or_after maximumNumberOfIterations.;public <M> Graph<K, VV, EV> runGatherSumApplyIteration(_			org.apache.flink.graph.gsa.GatherFunction<VV, EV, M> gatherFunction, SumFunction<VV, EV, M> sumFunction,_			ApplyFunction<K, VV, M> applyFunction, int maximumNumberOfIterations) {__		return this.runGatherSumApplyIteration(gatherFunction, sumFunction, applyFunction,_				maximumNumberOfIterations, null)__	};runs,a,gather,sum,apply,iteration,on,the,graph,no,configuration,options,are,provided,param,gather,function,the,gather,function,collects,information,about,adjacent,vertices,and,edges,param,sum,function,the,sum,function,aggregates,the,gathered,information,param,apply,function,the,apply,function,updates,the,vertex,values,with,the,aggregates,param,maximum,number,of,iterations,maximum,number,of,iterations,to,perform,param,m,the,intermediate,type,used,between,gather,sum,and,apply,return,the,updated,graph,after,the,gather,sum,apply,iteration,has,converged,or,after,maximum,number,of,iterations;public,m,graph,k,vv,ev,run,gather,sum,apply,iteration,org,apache,flink,graph,gsa,gather,function,vv,ev,m,gather,function,sum,function,vv,ev,m,sum,function,apply,function,k,vv,m,apply,function,int,maximum,number,of,iterations,return,this,run,gather,sum,apply,iteration,gather,function,sum,function,apply,function,maximum,number,of,iterations,null
Graph -> public <M> Graph<K, VV, EV> runGatherSumApplyIteration( 			org.apache.flink.graph.gsa.GatherFunction<VV, EV, M> gatherFunction, SumFunction<VV, EV, M> sumFunction, 			ApplyFunction<K, VV, M> applyFunction, int maximumNumberOfIterations);1484160227;Runs a Gather-Sum-Apply iteration on the graph._No configuration options are provided.__@param gatherFunction the gather function collects information about adjacent vertices and edges_@param sumFunction the sum function aggregates the gathered information_@param applyFunction the apply function updates the vertex values with the aggregates_@param maximumNumberOfIterations maximum number of iterations to perform_@param <M> the intermediate type used between gather, sum and apply__@return the updated Graph after the gather-sum-apply iteration has converged or_after maximumNumberOfIterations.;public <M> Graph<K, VV, EV> runGatherSumApplyIteration(_			org.apache.flink.graph.gsa.GatherFunction<VV, EV, M> gatherFunction, SumFunction<VV, EV, M> sumFunction,_			ApplyFunction<K, VV, M> applyFunction, int maximumNumberOfIterations) {__		return this.runGatherSumApplyIteration(gatherFunction, sumFunction, applyFunction,_				maximumNumberOfIterations, null)__	};runs,a,gather,sum,apply,iteration,on,the,graph,no,configuration,options,are,provided,param,gather,function,the,gather,function,collects,information,about,adjacent,vertices,and,edges,param,sum,function,the,sum,function,aggregates,the,gathered,information,param,apply,function,the,apply,function,updates,the,vertex,values,with,the,aggregates,param,maximum,number,of,iterations,maximum,number,of,iterations,to,perform,param,m,the,intermediate,type,used,between,gather,sum,and,apply,return,the,updated,graph,after,the,gather,sum,apply,iteration,has,converged,or,after,maximum,number,of,iterations;public,m,graph,k,vv,ev,run,gather,sum,apply,iteration,org,apache,flink,graph,gsa,gather,function,vv,ev,m,gather,function,sum,function,vv,ev,m,sum,function,apply,function,k,vv,m,apply,function,int,maximum,number,of,iterations,return,this,run,gather,sum,apply,iteration,gather,function,sum,function,apply,function,maximum,number,of,iterations,null
Graph -> public <M> Graph<K, VV, EV> runGatherSumApplyIteration( 			org.apache.flink.graph.gsa.GatherFunction<VV, EV, M> gatherFunction, SumFunction<VV, EV, M> sumFunction, 			ApplyFunction<K, VV, M> applyFunction, int maximumNumberOfIterations);1484685504;Runs a Gather-Sum-Apply iteration on the graph._No configuration options are provided.__@param gatherFunction the gather function collects information about adjacent vertices and edges_@param sumFunction the sum function aggregates the gathered information_@param applyFunction the apply function updates the vertex values with the aggregates_@param maximumNumberOfIterations maximum number of iterations to perform_@param <M> the intermediate type used between gather, sum and apply__@return the updated Graph after the gather-sum-apply iteration has converged or_after maximumNumberOfIterations.;public <M> Graph<K, VV, EV> runGatherSumApplyIteration(_			org.apache.flink.graph.gsa.GatherFunction<VV, EV, M> gatherFunction, SumFunction<VV, EV, M> sumFunction,_			ApplyFunction<K, VV, M> applyFunction, int maximumNumberOfIterations) {__		return this.runGatherSumApplyIteration(gatherFunction, sumFunction, applyFunction,_				maximumNumberOfIterations, null)__	};runs,a,gather,sum,apply,iteration,on,the,graph,no,configuration,options,are,provided,param,gather,function,the,gather,function,collects,information,about,adjacent,vertices,and,edges,param,sum,function,the,sum,function,aggregates,the,gathered,information,param,apply,function,the,apply,function,updates,the,vertex,values,with,the,aggregates,param,maximum,number,of,iterations,maximum,number,of,iterations,to,perform,param,m,the,intermediate,type,used,between,gather,sum,and,apply,return,the,updated,graph,after,the,gather,sum,apply,iteration,has,converged,or,after,maximum,number,of,iterations;public,m,graph,k,vv,ev,run,gather,sum,apply,iteration,org,apache,flink,graph,gsa,gather,function,vv,ev,m,gather,function,sum,function,vv,ev,m,sum,function,apply,function,k,vv,m,apply,function,int,maximum,number,of,iterations,return,this,run,gather,sum,apply,iteration,gather,function,sum,function,apply,function,maximum,number,of,iterations,null
Graph -> public <M> Graph<K, VV, EV> runGatherSumApplyIteration( 			org.apache.flink.graph.gsa.GatherFunction<VV, EV, M> gatherFunction, SumFunction<VV, EV, M> sumFunction, 			ApplyFunction<K, VV, M> applyFunction, int maximumNumberOfIterations);1489068942;Runs a Gather-Sum-Apply iteration on the graph._No configuration options are provided.__@param gatherFunction the gather function collects information about adjacent vertices and edges_@param sumFunction the sum function aggregates the gathered information_@param applyFunction the apply function updates the vertex values with the aggregates_@param maximumNumberOfIterations maximum number of iterations to perform_@param <M> the intermediate type used between gather, sum and apply__@return the updated Graph after the gather-sum-apply iteration has converged or_after maximumNumberOfIterations.;public <M> Graph<K, VV, EV> runGatherSumApplyIteration(_			org.apache.flink.graph.gsa.GatherFunction<VV, EV, M> gatherFunction, SumFunction<VV, EV, M> sumFunction,_			ApplyFunction<K, VV, M> applyFunction, int maximumNumberOfIterations) {__		return this.runGatherSumApplyIteration(gatherFunction, sumFunction, applyFunction,_				maximumNumberOfIterations, null)__	};runs,a,gather,sum,apply,iteration,on,the,graph,no,configuration,options,are,provided,param,gather,function,the,gather,function,collects,information,about,adjacent,vertices,and,edges,param,sum,function,the,sum,function,aggregates,the,gathered,information,param,apply,function,the,apply,function,updates,the,vertex,values,with,the,aggregates,param,maximum,number,of,iterations,maximum,number,of,iterations,to,perform,param,m,the,intermediate,type,used,between,gather,sum,and,apply,return,the,updated,graph,after,the,gather,sum,apply,iteration,has,converged,or,after,maximum,number,of,iterations;public,m,graph,k,vv,ev,run,gather,sum,apply,iteration,org,apache,flink,graph,gsa,gather,function,vv,ev,m,gather,function,sum,function,vv,ev,m,sum,function,apply,function,k,vv,m,apply,function,int,maximum,number,of,iterations,return,this,run,gather,sum,apply,iteration,gather,function,sum,function,apply,function,maximum,number,of,iterations,null
Graph -> public <M> Graph<K, VV, EV> runGatherSumApplyIteration( 			org.apache.flink.graph.gsa.GatherFunction<VV, EV, M> gatherFunction, SumFunction<VV, EV, M> sumFunction, 			ApplyFunction<K, VV, M> applyFunction, int maximumNumberOfIterations);1490973446;Runs a Gather-Sum-Apply iteration on the graph._No configuration options are provided.__@param gatherFunction the gather function collects information about adjacent vertices and edges_@param sumFunction the sum function aggregates the gathered information_@param applyFunction the apply function updates the vertex values with the aggregates_@param maximumNumberOfIterations maximum number of iterations to perform_@param <M> the intermediate type used between gather, sum and apply__@return the updated Graph after the gather-sum-apply iteration has converged or_after maximumNumberOfIterations.;public <M> Graph<K, VV, EV> runGatherSumApplyIteration(_			org.apache.flink.graph.gsa.GatherFunction<VV, EV, M> gatherFunction, SumFunction<VV, EV, M> sumFunction,_			ApplyFunction<K, VV, M> applyFunction, int maximumNumberOfIterations) {__		return this.runGatherSumApplyIteration(gatherFunction, sumFunction, applyFunction,_				maximumNumberOfIterations, null)__	};runs,a,gather,sum,apply,iteration,on,the,graph,no,configuration,options,are,provided,param,gather,function,the,gather,function,collects,information,about,adjacent,vertices,and,edges,param,sum,function,the,sum,function,aggregates,the,gathered,information,param,apply,function,the,apply,function,updates,the,vertex,values,with,the,aggregates,param,maximum,number,of,iterations,maximum,number,of,iterations,to,perform,param,m,the,intermediate,type,used,between,gather,sum,and,apply,return,the,updated,graph,after,the,gather,sum,apply,iteration,has,converged,or,after,maximum,number,of,iterations;public,m,graph,k,vv,ev,run,gather,sum,apply,iteration,org,apache,flink,graph,gsa,gather,function,vv,ev,m,gather,function,sum,function,vv,ev,m,sum,function,apply,function,k,vv,m,apply,function,int,maximum,number,of,iterations,return,this,run,gather,sum,apply,iteration,gather,function,sum,function,apply,function,maximum,number,of,iterations,null
Graph -> public <M> Graph<K, VV, EV> runGatherSumApplyIteration( 			org.apache.flink.graph.gsa.GatherFunction<VV, EV, M> gatherFunction, SumFunction<VV, EV, M> sumFunction, 			ApplyFunction<K, VV, M> applyFunction, int maximumNumberOfIterations);1495819075;Runs a Gather-Sum-Apply iteration on the graph._No configuration options are provided.__@param gatherFunction the gather function collects information about adjacent vertices and edges_@param sumFunction the sum function aggregates the gathered information_@param applyFunction the apply function updates the vertex values with the aggregates_@param maximumNumberOfIterations maximum number of iterations to perform_@param <M> the intermediate type used between gather, sum and apply__@return the updated Graph after the gather-sum-apply iteration has converged or_after maximumNumberOfIterations.;public <M> Graph<K, VV, EV> runGatherSumApplyIteration(_			org.apache.flink.graph.gsa.GatherFunction<VV, EV, M> gatherFunction, SumFunction<VV, EV, M> sumFunction,_			ApplyFunction<K, VV, M> applyFunction, int maximumNumberOfIterations) {__		return this.runGatherSumApplyIteration(gatherFunction, sumFunction, applyFunction,_				maximumNumberOfIterations, null)__	};runs,a,gather,sum,apply,iteration,on,the,graph,no,configuration,options,are,provided,param,gather,function,the,gather,function,collects,information,about,adjacent,vertices,and,edges,param,sum,function,the,sum,function,aggregates,the,gathered,information,param,apply,function,the,apply,function,updates,the,vertex,values,with,the,aggregates,param,maximum,number,of,iterations,maximum,number,of,iterations,to,perform,param,m,the,intermediate,type,used,between,gather,sum,and,apply,return,the,updated,graph,after,the,gather,sum,apply,iteration,has,converged,or,after,maximum,number,of,iterations;public,m,graph,k,vv,ev,run,gather,sum,apply,iteration,org,apache,flink,graph,gsa,gather,function,vv,ev,m,gather,function,sum,function,vv,ev,m,sum,function,apply,function,k,vv,m,apply,function,int,maximum,number,of,iterations,return,this,run,gather,sum,apply,iteration,gather,function,sum,function,apply,function,maximum,number,of,iterations,null
Graph -> public <M> Graph<K, VV, EV> runGatherSumApplyIteration( 			org.apache.flink.graph.gsa.GatherFunction<VV, EV, M> gatherFunction, SumFunction<VV, EV, M> sumFunction, 			ApplyFunction<K, VV, M> applyFunction, int maximumNumberOfIterations);1502111816;Runs a Gather-Sum-Apply iteration on the graph._No configuration options are provided.__@param gatherFunction the gather function collects information about adjacent vertices and edges_@param sumFunction the sum function aggregates the gathered information_@param applyFunction the apply function updates the vertex values with the aggregates_@param maximumNumberOfIterations maximum number of iterations to perform_@param <M> the intermediate type used between gather, sum and apply__@return the updated Graph after the gather-sum-apply iteration has converged or_after maximumNumberOfIterations.;public <M> Graph<K, VV, EV> runGatherSumApplyIteration(_			org.apache.flink.graph.gsa.GatherFunction<VV, EV, M> gatherFunction, SumFunction<VV, EV, M> sumFunction,_			ApplyFunction<K, VV, M> applyFunction, int maximumNumberOfIterations) {__		return this.runGatherSumApplyIteration(gatherFunction, sumFunction, applyFunction,_				maximumNumberOfIterations, null)__	};runs,a,gather,sum,apply,iteration,on,the,graph,no,configuration,options,are,provided,param,gather,function,the,gather,function,collects,information,about,adjacent,vertices,and,edges,param,sum,function,the,sum,function,aggregates,the,gathered,information,param,apply,function,the,apply,function,updates,the,vertex,values,with,the,aggregates,param,maximum,number,of,iterations,maximum,number,of,iterations,to,perform,param,m,the,intermediate,type,used,between,gather,sum,and,apply,return,the,updated,graph,after,the,gather,sum,apply,iteration,has,converged,or,after,maximum,number,of,iterations;public,m,graph,k,vv,ev,run,gather,sum,apply,iteration,org,apache,flink,graph,gsa,gather,function,vv,ev,m,gather,function,sum,function,vv,ev,m,sum,function,apply,function,k,vv,m,apply,function,int,maximum,number,of,iterations,return,this,run,gather,sum,apply,iteration,gather,function,sum,function,apply,function,maximum,number,of,iterations,null
Graph -> public static GraphCsvReader fromCsvReader(String edgesPath, ExecutionEnvironment context);1444404795;Creates a graph from a CSV file of edges. Vertices will be created automatically.__@param edgesPath a path to a CSV file with the Edges data_@param context the execution environment._@return An instance of {@link org.apache.flink.graph.GraphCsvReader},_on which calling methods to specify types of the Vertex ID, Vertex value and Edge value returns a Graph.__@see {@link org.apache.flink.graph.GraphCsvReader#types(Class, Class, Class)},_{@link org.apache.flink.graph.GraphCsvReader#vertexTypes(Class, Class)},_{@link org.apache.flink.graph.GraphCsvReader#edgeTypes(Class, Class)} and_{@link org.apache.flink.graph.GraphCsvReader#keyType(Class)}.;public static GraphCsvReader fromCsvReader(String edgesPath, ExecutionEnvironment context) {_		return new GraphCsvReader(edgesPath, context)__	};creates,a,graph,from,a,csv,file,of,edges,vertices,will,be,created,automatically,param,edges,path,a,path,to,a,csv,file,with,the,edges,data,param,context,the,execution,environment,return,an,instance,of,link,org,apache,flink,graph,graph,csv,reader,on,which,calling,methods,to,specify,types,of,the,vertex,id,vertex,value,and,edge,value,returns,a,graph,see,link,org,apache,flink,graph,graph,csv,reader,types,class,class,class,link,org,apache,flink,graph,graph,csv,reader,vertex,types,class,class,link,org,apache,flink,graph,graph,csv,reader,edge,types,class,class,and,link,org,apache,flink,graph,graph,csv,reader,key,type,class;public,static,graph,csv,reader,from,csv,reader,string,edges,path,execution,environment,context,return,new,graph,csv,reader,edges,path,context
Graph -> public static GraphCsvReader fromCsvReader(String edgesPath, ExecutionEnvironment context);1445261977;Creates a graph from a CSV file of edges. Vertices will be created automatically.__@param edgesPath a path to a CSV file with the Edges data_@param context the execution environment._@return An instance of {@link org.apache.flink.graph.GraphCsvReader},_on which calling methods to specify types of the Vertex ID, Vertex value and Edge value returns a Graph.__@see {@link org.apache.flink.graph.GraphCsvReader#types(Class, Class, Class)},_{@link org.apache.flink.graph.GraphCsvReader#vertexTypes(Class, Class)},_{@link org.apache.flink.graph.GraphCsvReader#edgeTypes(Class, Class)} and_{@link org.apache.flink.graph.GraphCsvReader#keyType(Class)}.;public static GraphCsvReader fromCsvReader(String edgesPath, ExecutionEnvironment context) {_		return new GraphCsvReader(edgesPath, context)__	};creates,a,graph,from,a,csv,file,of,edges,vertices,will,be,created,automatically,param,edges,path,a,path,to,a,csv,file,with,the,edges,data,param,context,the,execution,environment,return,an,instance,of,link,org,apache,flink,graph,graph,csv,reader,on,which,calling,methods,to,specify,types,of,the,vertex,id,vertex,value,and,edge,value,returns,a,graph,see,link,org,apache,flink,graph,graph,csv,reader,types,class,class,class,link,org,apache,flink,graph,graph,csv,reader,vertex,types,class,class,link,org,apache,flink,graph,graph,csv,reader,edge,types,class,class,and,link,org,apache,flink,graph,graph,csv,reader,key,type,class;public,static,graph,csv,reader,from,csv,reader,string,edges,path,execution,environment,context,return,new,graph,csv,reader,edges,path,context
Graph -> public static GraphCsvReader fromCsvReader(String edgesPath, ExecutionEnvironment context);1445854323;Creates a graph from a CSV file of edges. Vertices will be created automatically.__@param edgesPath a path to a CSV file with the Edges data_@param context the execution environment._@return An instance of {@link org.apache.flink.graph.GraphCsvReader},_on which calling methods to specify types of the Vertex ID, Vertex value and Edge value returns a Graph.__@see {@link org.apache.flink.graph.GraphCsvReader#types(Class, Class, Class)},_{@link org.apache.flink.graph.GraphCsvReader#vertexTypes(Class, Class)},_{@link org.apache.flink.graph.GraphCsvReader#edgeTypes(Class, Class)} and_{@link org.apache.flink.graph.GraphCsvReader#keyType(Class)}.;public static GraphCsvReader fromCsvReader(String edgesPath, ExecutionEnvironment context) {_		return new GraphCsvReader(edgesPath, context)__	};creates,a,graph,from,a,csv,file,of,edges,vertices,will,be,created,automatically,param,edges,path,a,path,to,a,csv,file,with,the,edges,data,param,context,the,execution,environment,return,an,instance,of,link,org,apache,flink,graph,graph,csv,reader,on,which,calling,methods,to,specify,types,of,the,vertex,id,vertex,value,and,edge,value,returns,a,graph,see,link,org,apache,flink,graph,graph,csv,reader,types,class,class,class,link,org,apache,flink,graph,graph,csv,reader,vertex,types,class,class,link,org,apache,flink,graph,graph,csv,reader,edge,types,class,class,and,link,org,apache,flink,graph,graph,csv,reader,key,type,class;public,static,graph,csv,reader,from,csv,reader,string,edges,path,execution,environment,context,return,new,graph,csv,reader,edges,path,context
Graph -> public static GraphCsvReader fromCsvReader(String edgesPath, ExecutionEnvironment context);1446112342;Creates a graph from a CSV file of edges. Vertices will be created automatically.__@param edgesPath a path to a CSV file with the Edges data_@param context the execution environment._@return An instance of {@link org.apache.flink.graph.GraphCsvReader},_on which calling methods to specify types of the Vertex ID, Vertex value and Edge value returns a Graph.__@see org.apache.flink.graph.GraphCsvReader#types(Class, Class, Class)_@see org.apache.flink.graph.GraphCsvReader#vertexTypes(Class, Class)_@see org.apache.flink.graph.GraphCsvReader#edgeTypes(Class, Class)_@see org.apache.flink.graph.GraphCsvReader#keyType(Class);public static GraphCsvReader fromCsvReader(String edgesPath, ExecutionEnvironment context) {_		return new GraphCsvReader(edgesPath, context)__	};creates,a,graph,from,a,csv,file,of,edges,vertices,will,be,created,automatically,param,edges,path,a,path,to,a,csv,file,with,the,edges,data,param,context,the,execution,environment,return,an,instance,of,link,org,apache,flink,graph,graph,csv,reader,on,which,calling,methods,to,specify,types,of,the,vertex,id,vertex,value,and,edge,value,returns,a,graph,see,org,apache,flink,graph,graph,csv,reader,types,class,class,class,see,org,apache,flink,graph,graph,csv,reader,vertex,types,class,class,see,org,apache,flink,graph,graph,csv,reader,edge,types,class,class,see,org,apache,flink,graph,graph,csv,reader,key,type,class;public,static,graph,csv,reader,from,csv,reader,string,edges,path,execution,environment,context,return,new,graph,csv,reader,edges,path,context
Graph -> public static GraphCsvReader fromCsvReader(String edgesPath, ExecutionEnvironment context);1447073368;Creates a graph from a CSV file of edges. Vertices will be created automatically.__@param edgesPath a path to a CSV file with the Edges data_@param context the execution environment._@return An instance of {@link org.apache.flink.graph.GraphCsvReader},_on which calling methods to specify types of the Vertex ID, Vertex value and Edge value returns a Graph.__@see org.apache.flink.graph.GraphCsvReader#types(Class, Class, Class)_@see org.apache.flink.graph.GraphCsvReader#vertexTypes(Class, Class)_@see org.apache.flink.graph.GraphCsvReader#edgeTypes(Class, Class)_@see org.apache.flink.graph.GraphCsvReader#keyType(Class);public static GraphCsvReader fromCsvReader(String edgesPath, ExecutionEnvironment context) {_		return new GraphCsvReader(edgesPath, context)__	};creates,a,graph,from,a,csv,file,of,edges,vertices,will,be,created,automatically,param,edges,path,a,path,to,a,csv,file,with,the,edges,data,param,context,the,execution,environment,return,an,instance,of,link,org,apache,flink,graph,graph,csv,reader,on,which,calling,methods,to,specify,types,of,the,vertex,id,vertex,value,and,edge,value,returns,a,graph,see,org,apache,flink,graph,graph,csv,reader,types,class,class,class,see,org,apache,flink,graph,graph,csv,reader,vertex,types,class,class,see,org,apache,flink,graph,graph,csv,reader,edge,types,class,class,see,org,apache,flink,graph,graph,csv,reader,key,type,class;public,static,graph,csv,reader,from,csv,reader,string,edges,path,execution,environment,context,return,new,graph,csv,reader,edges,path,context
Graph -> public static GraphCsvReader fromCsvReader(String edgesPath, ExecutionEnvironment context);1454404649;Creates a graph from a CSV file of edges. Vertices will be created automatically.__@param edgesPath a path to a CSV file with the Edges data_@param context the execution environment._@return An instance of {@link org.apache.flink.graph.GraphCsvReader},_on which calling methods to specify types of the Vertex ID, Vertex value and Edge value returns a Graph.__@see org.apache.flink.graph.GraphCsvReader#types(Class, Class, Class)_@see org.apache.flink.graph.GraphCsvReader#vertexTypes(Class, Class)_@see org.apache.flink.graph.GraphCsvReader#edgeTypes(Class, Class)_@see org.apache.flink.graph.GraphCsvReader#keyType(Class);public static GraphCsvReader fromCsvReader(String edgesPath, ExecutionEnvironment context) {_		return new GraphCsvReader(edgesPath, context)__	};creates,a,graph,from,a,csv,file,of,edges,vertices,will,be,created,automatically,param,edges,path,a,path,to,a,csv,file,with,the,edges,data,param,context,the,execution,environment,return,an,instance,of,link,org,apache,flink,graph,graph,csv,reader,on,which,calling,methods,to,specify,types,of,the,vertex,id,vertex,value,and,edge,value,returns,a,graph,see,org,apache,flink,graph,graph,csv,reader,types,class,class,class,see,org,apache,flink,graph,graph,csv,reader,vertex,types,class,class,see,org,apache,flink,graph,graph,csv,reader,edge,types,class,class,see,org,apache,flink,graph,graph,csv,reader,key,type,class;public,static,graph,csv,reader,from,csv,reader,string,edges,path,execution,environment,context,return,new,graph,csv,reader,edges,path,context
Graph -> public static GraphCsvReader fromCsvReader(String edgesPath, ExecutionEnvironment context);1458583829;Creates a graph from a CSV file of edges. Vertices will be created automatically.__@param edgesPath a path to a CSV file with the Edges data_@param context the execution environment._@return An instance of {@link org.apache.flink.graph.GraphCsvReader},_on which calling methods to specify types of the Vertex ID, Vertex value and Edge value returns a Graph.__@see org.apache.flink.graph.GraphCsvReader#types(Class, Class, Class)_@see org.apache.flink.graph.GraphCsvReader#vertexTypes(Class, Class)_@see org.apache.flink.graph.GraphCsvReader#edgeTypes(Class, Class)_@see org.apache.flink.graph.GraphCsvReader#keyType(Class);public static GraphCsvReader fromCsvReader(String edgesPath, ExecutionEnvironment context) {_		return new GraphCsvReader(edgesPath, context)__	};creates,a,graph,from,a,csv,file,of,edges,vertices,will,be,created,automatically,param,edges,path,a,path,to,a,csv,file,with,the,edges,data,param,context,the,execution,environment,return,an,instance,of,link,org,apache,flink,graph,graph,csv,reader,on,which,calling,methods,to,specify,types,of,the,vertex,id,vertex,value,and,edge,value,returns,a,graph,see,org,apache,flink,graph,graph,csv,reader,types,class,class,class,see,org,apache,flink,graph,graph,csv,reader,vertex,types,class,class,see,org,apache,flink,graph,graph,csv,reader,edge,types,class,class,see,org,apache,flink,graph,graph,csv,reader,key,type,class;public,static,graph,csv,reader,from,csv,reader,string,edges,path,execution,environment,context,return,new,graph,csv,reader,edges,path,context
Graph -> public static GraphCsvReader fromCsvReader(String edgesPath, ExecutionEnvironment context);1458583829;Creates a graph from a CSV file of edges. Vertices will be created automatically.__@param edgesPath a path to a CSV file with the Edges data_@param context the execution environment._@return An instance of {@link org.apache.flink.graph.GraphCsvReader},_on which calling methods to specify types of the Vertex ID, Vertex value and Edge value returns a Graph.__@see org.apache.flink.graph.GraphCsvReader#types(Class, Class, Class)_@see org.apache.flink.graph.GraphCsvReader#vertexTypes(Class, Class)_@see org.apache.flink.graph.GraphCsvReader#edgeTypes(Class, Class)_@see org.apache.flink.graph.GraphCsvReader#keyType(Class);public static GraphCsvReader fromCsvReader(String edgesPath, ExecutionEnvironment context) {_		return new GraphCsvReader(edgesPath, context)__	};creates,a,graph,from,a,csv,file,of,edges,vertices,will,be,created,automatically,param,edges,path,a,path,to,a,csv,file,with,the,edges,data,param,context,the,execution,environment,return,an,instance,of,link,org,apache,flink,graph,graph,csv,reader,on,which,calling,methods,to,specify,types,of,the,vertex,id,vertex,value,and,edge,value,returns,a,graph,see,org,apache,flink,graph,graph,csv,reader,types,class,class,class,see,org,apache,flink,graph,graph,csv,reader,vertex,types,class,class,see,org,apache,flink,graph,graph,csv,reader,edge,types,class,class,see,org,apache,flink,graph,graph,csv,reader,key,type,class;public,static,graph,csv,reader,from,csv,reader,string,edges,path,execution,environment,context,return,new,graph,csv,reader,edges,path,context
Graph -> public static GraphCsvReader fromCsvReader(String edgesPath, ExecutionEnvironment context);1462100316;Creates a graph from a CSV file of edges. Vertices will be created automatically.__@param edgesPath a path to a CSV file with the Edges data_@param context the execution environment._@return An instance of {@link org.apache.flink.graph.GraphCsvReader},_on which calling methods to specify types of the Vertex ID, Vertex value and Edge value returns a Graph.__@see org.apache.flink.graph.GraphCsvReader#types(Class, Class, Class)_@see org.apache.flink.graph.GraphCsvReader#vertexTypes(Class, Class)_@see org.apache.flink.graph.GraphCsvReader#edgeTypes(Class, Class)_@see org.apache.flink.graph.GraphCsvReader#keyType(Class);public static GraphCsvReader fromCsvReader(String edgesPath, ExecutionEnvironment context) {_		return new GraphCsvReader(edgesPath, context)__	};creates,a,graph,from,a,csv,file,of,edges,vertices,will,be,created,automatically,param,edges,path,a,path,to,a,csv,file,with,the,edges,data,param,context,the,execution,environment,return,an,instance,of,link,org,apache,flink,graph,graph,csv,reader,on,which,calling,methods,to,specify,types,of,the,vertex,id,vertex,value,and,edge,value,returns,a,graph,see,org,apache,flink,graph,graph,csv,reader,types,class,class,class,see,org,apache,flink,graph,graph,csv,reader,vertex,types,class,class,see,org,apache,flink,graph,graph,csv,reader,edge,types,class,class,see,org,apache,flink,graph,graph,csv,reader,key,type,class;public,static,graph,csv,reader,from,csv,reader,string,edges,path,execution,environment,context,return,new,graph,csv,reader,edges,path,context
Graph -> public static GraphCsvReader fromCsvReader(String edgesPath, ExecutionEnvironment context);1462100316;Creates a graph from a CSV file of edges. Vertices will be created automatically.__@param edgesPath a path to a CSV file with the Edges data_@param context the execution environment._@return An instance of {@link org.apache.flink.graph.GraphCsvReader},_on which calling methods to specify types of the Vertex ID, Vertex value and Edge value returns a Graph.__@see org.apache.flink.graph.GraphCsvReader#types(Class, Class, Class)_@see org.apache.flink.graph.GraphCsvReader#vertexTypes(Class, Class)_@see org.apache.flink.graph.GraphCsvReader#edgeTypes(Class, Class)_@see org.apache.flink.graph.GraphCsvReader#keyType(Class);public static GraphCsvReader fromCsvReader(String edgesPath, ExecutionEnvironment context) {_		return new GraphCsvReader(edgesPath, context)__	};creates,a,graph,from,a,csv,file,of,edges,vertices,will,be,created,automatically,param,edges,path,a,path,to,a,csv,file,with,the,edges,data,param,context,the,execution,environment,return,an,instance,of,link,org,apache,flink,graph,graph,csv,reader,on,which,calling,methods,to,specify,types,of,the,vertex,id,vertex,value,and,edge,value,returns,a,graph,see,org,apache,flink,graph,graph,csv,reader,types,class,class,class,see,org,apache,flink,graph,graph,csv,reader,vertex,types,class,class,see,org,apache,flink,graph,graph,csv,reader,edge,types,class,class,see,org,apache,flink,graph,graph,csv,reader,key,type,class;public,static,graph,csv,reader,from,csv,reader,string,edges,path,execution,environment,context,return,new,graph,csv,reader,edges,path,context
Graph -> public static GraphCsvReader fromCsvReader(String edgesPath, ExecutionEnvironment context);1462205213;Creates a graph from a CSV file of edges. Vertices will be created automatically.__@param edgesPath a path to a CSV file with the Edges data_@param context the execution environment._@return An instance of {@link org.apache.flink.graph.GraphCsvReader},_on which calling methods to specify types of the Vertex ID, Vertex value and Edge value returns a Graph.__@see org.apache.flink.graph.GraphCsvReader#types(Class, Class, Class)_@see org.apache.flink.graph.GraphCsvReader#vertexTypes(Class, Class)_@see org.apache.flink.graph.GraphCsvReader#edgeTypes(Class, Class)_@see org.apache.flink.graph.GraphCsvReader#keyType(Class);public static GraphCsvReader fromCsvReader(String edgesPath, ExecutionEnvironment context) {_		return new GraphCsvReader(edgesPath, context)__	};creates,a,graph,from,a,csv,file,of,edges,vertices,will,be,created,automatically,param,edges,path,a,path,to,a,csv,file,with,the,edges,data,param,context,the,execution,environment,return,an,instance,of,link,org,apache,flink,graph,graph,csv,reader,on,which,calling,methods,to,specify,types,of,the,vertex,id,vertex,value,and,edge,value,returns,a,graph,see,org,apache,flink,graph,graph,csv,reader,types,class,class,class,see,org,apache,flink,graph,graph,csv,reader,vertex,types,class,class,see,org,apache,flink,graph,graph,csv,reader,edge,types,class,class,see,org,apache,flink,graph,graph,csv,reader,key,type,class;public,static,graph,csv,reader,from,csv,reader,string,edges,path,execution,environment,context,return,new,graph,csv,reader,edges,path,context
Graph -> public static GraphCsvReader fromCsvReader(String edgesPath, ExecutionEnvironment context);1462208859;Creates a graph from a CSV file of edges. Vertices will be created automatically.__@param edgesPath a path to a CSV file with the Edges data_@param context the execution environment._@return An instance of {@link org.apache.flink.graph.GraphCsvReader},_on which calling methods to specify types of the Vertex ID, Vertex value and Edge value returns a Graph.__@see org.apache.flink.graph.GraphCsvReader#types(Class, Class, Class)_@see org.apache.flink.graph.GraphCsvReader#vertexTypes(Class, Class)_@see org.apache.flink.graph.GraphCsvReader#edgeTypes(Class, Class)_@see org.apache.flink.graph.GraphCsvReader#keyType(Class);public static GraphCsvReader fromCsvReader(String edgesPath, ExecutionEnvironment context) {_		return new GraphCsvReader(edgesPath, context)__	};creates,a,graph,from,a,csv,file,of,edges,vertices,will,be,created,automatically,param,edges,path,a,path,to,a,csv,file,with,the,edges,data,param,context,the,execution,environment,return,an,instance,of,link,org,apache,flink,graph,graph,csv,reader,on,which,calling,methods,to,specify,types,of,the,vertex,id,vertex,value,and,edge,value,returns,a,graph,see,org,apache,flink,graph,graph,csv,reader,types,class,class,class,see,org,apache,flink,graph,graph,csv,reader,vertex,types,class,class,see,org,apache,flink,graph,graph,csv,reader,edge,types,class,class,see,org,apache,flink,graph,graph,csv,reader,key,type,class;public,static,graph,csv,reader,from,csv,reader,string,edges,path,execution,environment,context,return,new,graph,csv,reader,edges,path,context
Graph -> public static GraphCsvReader fromCsvReader(String edgesPath, ExecutionEnvironment context);1462809297;Creates a graph from a CSV file of edges. Vertices will be created automatically.__@param edgesPath a path to a CSV file with the Edges data_@param context the execution environment._@return An instance of {@link org.apache.flink.graph.GraphCsvReader},_on which calling methods to specify types of the Vertex ID, Vertex value and Edge value returns a Graph.__@see org.apache.flink.graph.GraphCsvReader#types(Class, Class, Class)_@see org.apache.flink.graph.GraphCsvReader#vertexTypes(Class, Class)_@see org.apache.flink.graph.GraphCsvReader#edgeTypes(Class, Class)_@see org.apache.flink.graph.GraphCsvReader#keyType(Class);public static GraphCsvReader fromCsvReader(String edgesPath, ExecutionEnvironment context) {_		return new GraphCsvReader(edgesPath, context)__	};creates,a,graph,from,a,csv,file,of,edges,vertices,will,be,created,automatically,param,edges,path,a,path,to,a,csv,file,with,the,edges,data,param,context,the,execution,environment,return,an,instance,of,link,org,apache,flink,graph,graph,csv,reader,on,which,calling,methods,to,specify,types,of,the,vertex,id,vertex,value,and,edge,value,returns,a,graph,see,org,apache,flink,graph,graph,csv,reader,types,class,class,class,see,org,apache,flink,graph,graph,csv,reader,vertex,types,class,class,see,org,apache,flink,graph,graph,csv,reader,edge,types,class,class,see,org,apache,flink,graph,graph,csv,reader,key,type,class;public,static,graph,csv,reader,from,csv,reader,string,edges,path,execution,environment,context,return,new,graph,csv,reader,edges,path,context
Graph -> public static GraphCsvReader fromCsvReader(String edgesPath, ExecutionEnvironment context);1465316775;Creates a graph from a CSV file of edges. Vertices will be created automatically.__@param edgesPath a path to a CSV file with the Edges data_@param context the execution environment._@return An instance of {@link org.apache.flink.graph.GraphCsvReader},_on which calling methods to specify types of the Vertex ID, Vertex value and Edge value returns a Graph.__@see org.apache.flink.graph.GraphCsvReader#types(Class, Class, Class)_@see org.apache.flink.graph.GraphCsvReader#vertexTypes(Class, Class)_@see org.apache.flink.graph.GraphCsvReader#edgeTypes(Class, Class)_@see org.apache.flink.graph.GraphCsvReader#keyType(Class);public static GraphCsvReader fromCsvReader(String edgesPath, ExecutionEnvironment context) {_		return new GraphCsvReader(edgesPath, context)__	};creates,a,graph,from,a,csv,file,of,edges,vertices,will,be,created,automatically,param,edges,path,a,path,to,a,csv,file,with,the,edges,data,param,context,the,execution,environment,return,an,instance,of,link,org,apache,flink,graph,graph,csv,reader,on,which,calling,methods,to,specify,types,of,the,vertex,id,vertex,value,and,edge,value,returns,a,graph,see,org,apache,flink,graph,graph,csv,reader,types,class,class,class,see,org,apache,flink,graph,graph,csv,reader,vertex,types,class,class,see,org,apache,flink,graph,graph,csv,reader,edge,types,class,class,see,org,apache,flink,graph,graph,csv,reader,key,type,class;public,static,graph,csv,reader,from,csv,reader,string,edges,path,execution,environment,context,return,new,graph,csv,reader,edges,path,context
Graph -> public static GraphCsvReader fromCsvReader(String edgesPath, ExecutionEnvironment context);1466789678;Creates a graph from a CSV file of edges. Vertices will be created automatically.__@param edgesPath a path to a CSV file with the Edges data_@param context the execution environment._@return An instance of {@link org.apache.flink.graph.GraphCsvReader},_on which calling methods to specify types of the Vertex ID, Vertex value and Edge value returns a Graph.__@see org.apache.flink.graph.GraphCsvReader#types(Class, Class, Class)_@see org.apache.flink.graph.GraphCsvReader#vertexTypes(Class, Class)_@see org.apache.flink.graph.GraphCsvReader#edgeTypes(Class, Class)_@see org.apache.flink.graph.GraphCsvReader#keyType(Class);public static GraphCsvReader fromCsvReader(String edgesPath, ExecutionEnvironment context) {_		return new GraphCsvReader(edgesPath, context)__	};creates,a,graph,from,a,csv,file,of,edges,vertices,will,be,created,automatically,param,edges,path,a,path,to,a,csv,file,with,the,edges,data,param,context,the,execution,environment,return,an,instance,of,link,org,apache,flink,graph,graph,csv,reader,on,which,calling,methods,to,specify,types,of,the,vertex,id,vertex,value,and,edge,value,returns,a,graph,see,org,apache,flink,graph,graph,csv,reader,types,class,class,class,see,org,apache,flink,graph,graph,csv,reader,vertex,types,class,class,see,org,apache,flink,graph,graph,csv,reader,edge,types,class,class,see,org,apache,flink,graph,graph,csv,reader,key,type,class;public,static,graph,csv,reader,from,csv,reader,string,edges,path,execution,environment,context,return,new,graph,csv,reader,edges,path,context
Graph -> public static GraphCsvReader fromCsvReader(String edgesPath, ExecutionEnvironment context);1467140656;Creates a graph from a CSV file of edges. Vertices will be created automatically.__@param edgesPath a path to a CSV file with the Edges data_@param context the execution environment._@return An instance of {@link org.apache.flink.graph.GraphCsvReader},_on which calling methods to specify types of the Vertex ID, Vertex value and Edge value returns a Graph.__@see org.apache.flink.graph.GraphCsvReader#types(Class, Class, Class)_@see org.apache.flink.graph.GraphCsvReader#vertexTypes(Class, Class)_@see org.apache.flink.graph.GraphCsvReader#edgeTypes(Class, Class)_@see org.apache.flink.graph.GraphCsvReader#keyType(Class);public static GraphCsvReader fromCsvReader(String edgesPath, ExecutionEnvironment context) {_		return new GraphCsvReader(edgesPath, context)__	};creates,a,graph,from,a,csv,file,of,edges,vertices,will,be,created,automatically,param,edges,path,a,path,to,a,csv,file,with,the,edges,data,param,context,the,execution,environment,return,an,instance,of,link,org,apache,flink,graph,graph,csv,reader,on,which,calling,methods,to,specify,types,of,the,vertex,id,vertex,value,and,edge,value,returns,a,graph,see,org,apache,flink,graph,graph,csv,reader,types,class,class,class,see,org,apache,flink,graph,graph,csv,reader,vertex,types,class,class,see,org,apache,flink,graph,graph,csv,reader,edge,types,class,class,see,org,apache,flink,graph,graph,csv,reader,key,type,class;public,static,graph,csv,reader,from,csv,reader,string,edges,path,execution,environment,context,return,new,graph,csv,reader,edges,path,context
Graph -> public static GraphCsvReader fromCsvReader(String edgesPath, ExecutionEnvironment context);1467306272;Creates a graph from a CSV file of edges. Vertices will be created automatically.__@param edgesPath a path to a CSV file with the Edges data_@param context the execution environment._@return An instance of {@link org.apache.flink.graph.GraphCsvReader},_on which calling methods to specify types of the Vertex ID, Vertex value and Edge value returns a Graph.__@see org.apache.flink.graph.GraphCsvReader#types(Class, Class, Class)_@see org.apache.flink.graph.GraphCsvReader#vertexTypes(Class, Class)_@see org.apache.flink.graph.GraphCsvReader#edgeTypes(Class, Class)_@see org.apache.flink.graph.GraphCsvReader#keyType(Class);public static GraphCsvReader fromCsvReader(String edgesPath, ExecutionEnvironment context) {_		return new GraphCsvReader(edgesPath, context)__	};creates,a,graph,from,a,csv,file,of,edges,vertices,will,be,created,automatically,param,edges,path,a,path,to,a,csv,file,with,the,edges,data,param,context,the,execution,environment,return,an,instance,of,link,org,apache,flink,graph,graph,csv,reader,on,which,calling,methods,to,specify,types,of,the,vertex,id,vertex,value,and,edge,value,returns,a,graph,see,org,apache,flink,graph,graph,csv,reader,types,class,class,class,see,org,apache,flink,graph,graph,csv,reader,vertex,types,class,class,see,org,apache,flink,graph,graph,csv,reader,edge,types,class,class,see,org,apache,flink,graph,graph,csv,reader,key,type,class;public,static,graph,csv,reader,from,csv,reader,string,edges,path,execution,environment,context,return,new,graph,csv,reader,edges,path,context
Graph -> public static GraphCsvReader fromCsvReader(String edgesPath, ExecutionEnvironment context);1470042815;Creates a graph from a CSV file of edges. Vertices will be created automatically.__@param edgesPath a path to a CSV file with the Edges data_@param context the execution environment._@return An instance of {@link org.apache.flink.graph.GraphCsvReader},_on which calling methods to specify types of the Vertex ID, Vertex value and Edge value returns a Graph.__@see org.apache.flink.graph.GraphCsvReader#types(Class, Class, Class)_@see org.apache.flink.graph.GraphCsvReader#vertexTypes(Class, Class)_@see org.apache.flink.graph.GraphCsvReader#edgeTypes(Class, Class)_@see org.apache.flink.graph.GraphCsvReader#keyType(Class);public static GraphCsvReader fromCsvReader(String edgesPath, ExecutionEnvironment context) {_		return new GraphCsvReader(edgesPath, context)__	};creates,a,graph,from,a,csv,file,of,edges,vertices,will,be,created,automatically,param,edges,path,a,path,to,a,csv,file,with,the,edges,data,param,context,the,execution,environment,return,an,instance,of,link,org,apache,flink,graph,graph,csv,reader,on,which,calling,methods,to,specify,types,of,the,vertex,id,vertex,value,and,edge,value,returns,a,graph,see,org,apache,flink,graph,graph,csv,reader,types,class,class,class,see,org,apache,flink,graph,graph,csv,reader,vertex,types,class,class,see,org,apache,flink,graph,graph,csv,reader,edge,types,class,class,see,org,apache,flink,graph,graph,csv,reader,key,type,class;public,static,graph,csv,reader,from,csv,reader,string,edges,path,execution,environment,context,return,new,graph,csv,reader,edges,path,context
Graph -> public static GraphCsvReader fromCsvReader(String edgesPath, ExecutionEnvironment context);1475684776;Creates a graph from a CSV file of edges. Vertices will be created automatically.__@param edgesPath a path to a CSV file with the Edges data_@param context the execution environment._@return An instance of {@link org.apache.flink.graph.GraphCsvReader},_on which calling methods to specify types of the Vertex ID, Vertex value and Edge value returns a Graph.__@see org.apache.flink.graph.GraphCsvReader#types(Class, Class, Class)_@see org.apache.flink.graph.GraphCsvReader#vertexTypes(Class, Class)_@see org.apache.flink.graph.GraphCsvReader#edgeTypes(Class, Class)_@see org.apache.flink.graph.GraphCsvReader#keyType(Class);public static GraphCsvReader fromCsvReader(String edgesPath, ExecutionEnvironment context) {_		return new GraphCsvReader(edgesPath, context)__	};creates,a,graph,from,a,csv,file,of,edges,vertices,will,be,created,automatically,param,edges,path,a,path,to,a,csv,file,with,the,edges,data,param,context,the,execution,environment,return,an,instance,of,link,org,apache,flink,graph,graph,csv,reader,on,which,calling,methods,to,specify,types,of,the,vertex,id,vertex,value,and,edge,value,returns,a,graph,see,org,apache,flink,graph,graph,csv,reader,types,class,class,class,see,org,apache,flink,graph,graph,csv,reader,vertex,types,class,class,see,org,apache,flink,graph,graph,csv,reader,edge,types,class,class,see,org,apache,flink,graph,graph,csv,reader,key,type,class;public,static,graph,csv,reader,from,csv,reader,string,edges,path,execution,environment,context,return,new,graph,csv,reader,edges,path,context
Graph -> public static GraphCsvReader fromCsvReader(String edgesPath, ExecutionEnvironment context);1475685606;Creates a graph from a CSV file of edges. Vertices will be created automatically.__@param edgesPath a path to a CSV file with the Edges data_@param context the execution environment._@return An instance of {@link org.apache.flink.graph.GraphCsvReader},_on which calling methods to specify types of the Vertex ID, Vertex value and Edge value returns a Graph.__@see org.apache.flink.graph.GraphCsvReader#types(Class, Class, Class)_@see org.apache.flink.graph.GraphCsvReader#vertexTypes(Class, Class)_@see org.apache.flink.graph.GraphCsvReader#edgeTypes(Class, Class)_@see org.apache.flink.graph.GraphCsvReader#keyType(Class);public static GraphCsvReader fromCsvReader(String edgesPath, ExecutionEnvironment context) {_		return new GraphCsvReader(edgesPath, context)__	};creates,a,graph,from,a,csv,file,of,edges,vertices,will,be,created,automatically,param,edges,path,a,path,to,a,csv,file,with,the,edges,data,param,context,the,execution,environment,return,an,instance,of,link,org,apache,flink,graph,graph,csv,reader,on,which,calling,methods,to,specify,types,of,the,vertex,id,vertex,value,and,edge,value,returns,a,graph,see,org,apache,flink,graph,graph,csv,reader,types,class,class,class,see,org,apache,flink,graph,graph,csv,reader,vertex,types,class,class,see,org,apache,flink,graph,graph,csv,reader,edge,types,class,class,see,org,apache,flink,graph,graph,csv,reader,key,type,class;public,static,graph,csv,reader,from,csv,reader,string,edges,path,execution,environment,context,return,new,graph,csv,reader,edges,path,context
Graph -> public static GraphCsvReader fromCsvReader(String edgesPath, ExecutionEnvironment context);1481745825;Creates a graph from a CSV file of edges. Vertices will be created automatically.__@param edgesPath a path to a CSV file with the Edges data_@param context the execution environment._@return An instance of {@link org.apache.flink.graph.GraphCsvReader},_on which calling methods to specify types of the Vertex ID, Vertex value and Edge value returns a Graph.__@see org.apache.flink.graph.GraphCsvReader#types(Class, Class, Class)_@see org.apache.flink.graph.GraphCsvReader#vertexTypes(Class, Class)_@see org.apache.flink.graph.GraphCsvReader#edgeTypes(Class, Class)_@see org.apache.flink.graph.GraphCsvReader#keyType(Class);public static GraphCsvReader fromCsvReader(String edgesPath, ExecutionEnvironment context) {_		return new GraphCsvReader(edgesPath, context)__	};creates,a,graph,from,a,csv,file,of,edges,vertices,will,be,created,automatically,param,edges,path,a,path,to,a,csv,file,with,the,edges,data,param,context,the,execution,environment,return,an,instance,of,link,org,apache,flink,graph,graph,csv,reader,on,which,calling,methods,to,specify,types,of,the,vertex,id,vertex,value,and,edge,value,returns,a,graph,see,org,apache,flink,graph,graph,csv,reader,types,class,class,class,see,org,apache,flink,graph,graph,csv,reader,vertex,types,class,class,see,org,apache,flink,graph,graph,csv,reader,edge,types,class,class,see,org,apache,flink,graph,graph,csv,reader,key,type,class;public,static,graph,csv,reader,from,csv,reader,string,edges,path,execution,environment,context,return,new,graph,csv,reader,edges,path,context
Graph -> public static GraphCsvReader fromCsvReader(String edgesPath, ExecutionEnvironment context);1481881009;Creates a graph from a CSV file of edges. Vertices will be created automatically.__@param edgesPath a path to a CSV file with the Edges data_@param context the execution environment._@return An instance of {@link org.apache.flink.graph.GraphCsvReader},_on which calling methods to specify types of the Vertex ID, Vertex value and Edge value returns a Graph.__@see org.apache.flink.graph.GraphCsvReader#types(Class, Class, Class)_@see org.apache.flink.graph.GraphCsvReader#vertexTypes(Class, Class)_@see org.apache.flink.graph.GraphCsvReader#edgeTypes(Class, Class)_@see org.apache.flink.graph.GraphCsvReader#keyType(Class);public static GraphCsvReader fromCsvReader(String edgesPath, ExecutionEnvironment context) {_		return new GraphCsvReader(edgesPath, context)__	};creates,a,graph,from,a,csv,file,of,edges,vertices,will,be,created,automatically,param,edges,path,a,path,to,a,csv,file,with,the,edges,data,param,context,the,execution,environment,return,an,instance,of,link,org,apache,flink,graph,graph,csv,reader,on,which,calling,methods,to,specify,types,of,the,vertex,id,vertex,value,and,edge,value,returns,a,graph,see,org,apache,flink,graph,graph,csv,reader,types,class,class,class,see,org,apache,flink,graph,graph,csv,reader,vertex,types,class,class,see,org,apache,flink,graph,graph,csv,reader,edge,types,class,class,see,org,apache,flink,graph,graph,csv,reader,key,type,class;public,static,graph,csv,reader,from,csv,reader,string,edges,path,execution,environment,context,return,new,graph,csv,reader,edges,path,context
Graph -> public static GraphCsvReader fromCsvReader(String edgesPath, ExecutionEnvironment context);1484160227;Creates a graph from a CSV file of edges. Vertices will be created automatically.__@param edgesPath a path to a CSV file with the Edges data_@param context the execution environment._@return An instance of {@link org.apache.flink.graph.GraphCsvReader},_on which calling methods to specify types of the Vertex ID, Vertex value and Edge value returns a Graph.__@see org.apache.flink.graph.GraphCsvReader#types(Class, Class, Class)_@see org.apache.flink.graph.GraphCsvReader#vertexTypes(Class, Class)_@see org.apache.flink.graph.GraphCsvReader#edgeTypes(Class, Class)_@see org.apache.flink.graph.GraphCsvReader#keyType(Class);public static GraphCsvReader fromCsvReader(String edgesPath, ExecutionEnvironment context) {_		return new GraphCsvReader(edgesPath, context)__	};creates,a,graph,from,a,csv,file,of,edges,vertices,will,be,created,automatically,param,edges,path,a,path,to,a,csv,file,with,the,edges,data,param,context,the,execution,environment,return,an,instance,of,link,org,apache,flink,graph,graph,csv,reader,on,which,calling,methods,to,specify,types,of,the,vertex,id,vertex,value,and,edge,value,returns,a,graph,see,org,apache,flink,graph,graph,csv,reader,types,class,class,class,see,org,apache,flink,graph,graph,csv,reader,vertex,types,class,class,see,org,apache,flink,graph,graph,csv,reader,edge,types,class,class,see,org,apache,flink,graph,graph,csv,reader,key,type,class;public,static,graph,csv,reader,from,csv,reader,string,edges,path,execution,environment,context,return,new,graph,csv,reader,edges,path,context
Graph -> public static GraphCsvReader fromCsvReader(String edgesPath, ExecutionEnvironment context);1484685504;Creates a graph from a CSV file of edges. Vertices will be created automatically.__@param edgesPath a path to a CSV file with the Edges data_@param context the execution environment._@return An instance of {@link org.apache.flink.graph.GraphCsvReader},_on which calling methods to specify types of the Vertex ID, Vertex value and Edge value returns a Graph.__@see org.apache.flink.graph.GraphCsvReader#types(Class, Class, Class)_@see org.apache.flink.graph.GraphCsvReader#vertexTypes(Class, Class)_@see org.apache.flink.graph.GraphCsvReader#edgeTypes(Class, Class)_@see org.apache.flink.graph.GraphCsvReader#keyType(Class);public static GraphCsvReader fromCsvReader(String edgesPath, ExecutionEnvironment context) {_		return new GraphCsvReader(edgesPath, context)__	};creates,a,graph,from,a,csv,file,of,edges,vertices,will,be,created,automatically,param,edges,path,a,path,to,a,csv,file,with,the,edges,data,param,context,the,execution,environment,return,an,instance,of,link,org,apache,flink,graph,graph,csv,reader,on,which,calling,methods,to,specify,types,of,the,vertex,id,vertex,value,and,edge,value,returns,a,graph,see,org,apache,flink,graph,graph,csv,reader,types,class,class,class,see,org,apache,flink,graph,graph,csv,reader,vertex,types,class,class,see,org,apache,flink,graph,graph,csv,reader,edge,types,class,class,see,org,apache,flink,graph,graph,csv,reader,key,type,class;public,static,graph,csv,reader,from,csv,reader,string,edges,path,execution,environment,context,return,new,graph,csv,reader,edges,path,context
Graph -> public static GraphCsvReader fromCsvReader(String edgesPath, ExecutionEnvironment context);1489068942;Creates a graph from a CSV file of edges. Vertices will be created automatically.__@param edgesPath a path to a CSV file with the Edges data_@param context the execution environment._@return An instance of {@link org.apache.flink.graph.GraphCsvReader},_on which calling methods to specify types of the Vertex ID, Vertex value and Edge value returns a Graph.__@see org.apache.flink.graph.GraphCsvReader#types(Class, Class, Class)_@see org.apache.flink.graph.GraphCsvReader#vertexTypes(Class, Class)_@see org.apache.flink.graph.GraphCsvReader#edgeTypes(Class, Class)_@see org.apache.flink.graph.GraphCsvReader#keyType(Class);public static GraphCsvReader fromCsvReader(String edgesPath, ExecutionEnvironment context) {_		return new GraphCsvReader(edgesPath, context)__	};creates,a,graph,from,a,csv,file,of,edges,vertices,will,be,created,automatically,param,edges,path,a,path,to,a,csv,file,with,the,edges,data,param,context,the,execution,environment,return,an,instance,of,link,org,apache,flink,graph,graph,csv,reader,on,which,calling,methods,to,specify,types,of,the,vertex,id,vertex,value,and,edge,value,returns,a,graph,see,org,apache,flink,graph,graph,csv,reader,types,class,class,class,see,org,apache,flink,graph,graph,csv,reader,vertex,types,class,class,see,org,apache,flink,graph,graph,csv,reader,edge,types,class,class,see,org,apache,flink,graph,graph,csv,reader,key,type,class;public,static,graph,csv,reader,from,csv,reader,string,edges,path,execution,environment,context,return,new,graph,csv,reader,edges,path,context
Graph -> public static GraphCsvReader fromCsvReader(String edgesPath, ExecutionEnvironment context);1490973446;Creates a graph from a CSV file of edges. Vertices will be created automatically.__@param edgesPath a path to a CSV file with the Edges data_@param context the execution environment._@return An instance of {@link org.apache.flink.graph.GraphCsvReader},_on which calling methods to specify types of the Vertex ID, Vertex value and Edge value returns a Graph.__@see org.apache.flink.graph.GraphCsvReader#types(Class, Class, Class)_@see org.apache.flink.graph.GraphCsvReader#vertexTypes(Class, Class)_@see org.apache.flink.graph.GraphCsvReader#edgeTypes(Class, Class)_@see org.apache.flink.graph.GraphCsvReader#keyType(Class);public static GraphCsvReader fromCsvReader(String edgesPath, ExecutionEnvironment context) {_		return new GraphCsvReader(edgesPath, context)__	};creates,a,graph,from,a,csv,file,of,edges,vertices,will,be,created,automatically,param,edges,path,a,path,to,a,csv,file,with,the,edges,data,param,context,the,execution,environment,return,an,instance,of,link,org,apache,flink,graph,graph,csv,reader,on,which,calling,methods,to,specify,types,of,the,vertex,id,vertex,value,and,edge,value,returns,a,graph,see,org,apache,flink,graph,graph,csv,reader,types,class,class,class,see,org,apache,flink,graph,graph,csv,reader,vertex,types,class,class,see,org,apache,flink,graph,graph,csv,reader,edge,types,class,class,see,org,apache,flink,graph,graph,csv,reader,key,type,class;public,static,graph,csv,reader,from,csv,reader,string,edges,path,execution,environment,context,return,new,graph,csv,reader,edges,path,context
Graph -> public static GraphCsvReader fromCsvReader(String edgesPath, ExecutionEnvironment context);1495819075;Creates a graph from a CSV file of edges. Vertices will be created automatically.__@param edgesPath a path to a CSV file with the Edges data_@param context the execution environment._@return An instance of {@link org.apache.flink.graph.GraphCsvReader},_on which calling methods to specify types of the Vertex ID, Vertex value and Edge value returns a Graph.__@see org.apache.flink.graph.GraphCsvReader#types(Class, Class, Class)_@see org.apache.flink.graph.GraphCsvReader#vertexTypes(Class, Class)_@see org.apache.flink.graph.GraphCsvReader#edgeTypes(Class, Class)_@see org.apache.flink.graph.GraphCsvReader#keyType(Class);public static GraphCsvReader fromCsvReader(String edgesPath, ExecutionEnvironment context) {_		return new GraphCsvReader(edgesPath, context)__	};creates,a,graph,from,a,csv,file,of,edges,vertices,will,be,created,automatically,param,edges,path,a,path,to,a,csv,file,with,the,edges,data,param,context,the,execution,environment,return,an,instance,of,link,org,apache,flink,graph,graph,csv,reader,on,which,calling,methods,to,specify,types,of,the,vertex,id,vertex,value,and,edge,value,returns,a,graph,see,org,apache,flink,graph,graph,csv,reader,types,class,class,class,see,org,apache,flink,graph,graph,csv,reader,vertex,types,class,class,see,org,apache,flink,graph,graph,csv,reader,edge,types,class,class,see,org,apache,flink,graph,graph,csv,reader,key,type,class;public,static,graph,csv,reader,from,csv,reader,string,edges,path,execution,environment,context,return,new,graph,csv,reader,edges,path,context
Graph -> public static GraphCsvReader fromCsvReader(String edgesPath, ExecutionEnvironment context);1502111816;Creates a graph from a CSV file of edges. Vertices will be created automatically.__@param edgesPath a path to a CSV file with the Edges data_@param context the execution environment._@return An instance of {@link org.apache.flink.graph.GraphCsvReader},_on which calling methods to specify types of the Vertex ID, Vertex value and Edge value returns a Graph.__@see org.apache.flink.graph.GraphCsvReader#types(Class, Class, Class)_@see org.apache.flink.graph.GraphCsvReader#vertexTypes(Class, Class)_@see org.apache.flink.graph.GraphCsvReader#edgeTypes(Class, Class)_@see org.apache.flink.graph.GraphCsvReader#keyType(Class);public static GraphCsvReader fromCsvReader(String edgesPath, ExecutionEnvironment context) {_		return new GraphCsvReader(edgesPath, context)__	};creates,a,graph,from,a,csv,file,of,edges,vertices,will,be,created,automatically,param,edges,path,a,path,to,a,csv,file,with,the,edges,data,param,context,the,execution,environment,return,an,instance,of,link,org,apache,flink,graph,graph,csv,reader,on,which,calling,methods,to,specify,types,of,the,vertex,id,vertex,value,and,edge,value,returns,a,graph,see,org,apache,flink,graph,graph,csv,reader,types,class,class,class,see,org,apache,flink,graph,graph,csv,reader,vertex,types,class,class,see,org,apache,flink,graph,graph,csv,reader,edge,types,class,class,see,org,apache,flink,graph,graph,csv,reader,key,type,class;public,static,graph,csv,reader,from,csv,reader,string,edges,path,execution,environment,context,return,new,graph,csv,reader,edges,path,context
Graph -> public DataSet<Tuple2<K, EV>> reduceOnEdges(ReduceEdgesFunction<EV> reduceEdgesFunction, 			EdgeDirection direction) throws IllegalArgumentException;1445261977;Compute a reduce transformation over the edge values of each vertex._For each vertex, the transformation consecutively calls a_{@link ReduceEdgesFunction} until only a single value for each edge remains._The {@link ReduceEdgesFunction} combines two edge values into one new value of the same type.__@param reduceEdgesFunction the reduce function to apply to the neighbors of each vertex._@param direction the edge direction (in-, out-, all-)_@return a Dataset of Tuple2, with one tuple per vertex._The first field of the Tuple2 is the vertex ID and the second field_is the aggregate value computed by the provided {@link ReduceEdgesFunction}._@throws IllegalArgumentException;public DataSet<Tuple2<K, EV>> reduceOnEdges(ReduceEdgesFunction<EV> reduceEdgesFunction,_			EdgeDirection direction) throws IllegalArgumentException {__		switch (direction) {_			case IN:_				return edges.map(new ProjectVertexWithEdgeValueMap<K, EV>(1))_						.withForwardedFields("f1->f0")_						.groupBy(0).reduce(new ApplyReduceFunction<K, EV>(reduceEdgesFunction))__			case OUT:_				return edges.map(new ProjectVertexWithEdgeValueMap<K, EV>(0))_						.withForwardedFields("f0->f0")_						.groupBy(0).reduce(new ApplyReduceFunction<K, EV>(reduceEdgesFunction))__			case ALL:_				return edges.flatMap(new EmitOneVertexWithEdgeValuePerNode<K, EV>())_						.withForwardedFields("f2->f1")_						.groupBy(0).reduce(new ApplyReduceFunction<K, EV>(reduceEdgesFunction))__			default:_				throw new IllegalArgumentException("Illegal edge direction")__		}_	};compute,a,reduce,transformation,over,the,edge,values,of,each,vertex,for,each,vertex,the,transformation,consecutively,calls,a,link,reduce,edges,function,until,only,a,single,value,for,each,edge,remains,the,link,reduce,edges,function,combines,two,edge,values,into,one,new,value,of,the,same,type,param,reduce,edges,function,the,reduce,function,to,apply,to,the,neighbors,of,each,vertex,param,direction,the,edge,direction,in,out,all,return,a,dataset,of,tuple2,with,one,tuple,per,vertex,the,first,field,of,the,tuple2,is,the,vertex,id,and,the,second,field,is,the,aggregate,value,computed,by,the,provided,link,reduce,edges,function,throws,illegal,argument,exception;public,data,set,tuple2,k,ev,reduce,on,edges,reduce,edges,function,ev,reduce,edges,function,edge,direction,direction,throws,illegal,argument,exception,switch,direction,case,in,return,edges,map,new,project,vertex,with,edge,value,map,k,ev,1,with,forwarded,fields,f1,f0,group,by,0,reduce,new,apply,reduce,function,k,ev,reduce,edges,function,case,out,return,edges,map,new,project,vertex,with,edge,value,map,k,ev,0,with,forwarded,fields,f0,f0,group,by,0,reduce,new,apply,reduce,function,k,ev,reduce,edges,function,case,all,return,edges,flat,map,new,emit,one,vertex,with,edge,value,per,node,k,ev,with,forwarded,fields,f2,f1,group,by,0,reduce,new,apply,reduce,function,k,ev,reduce,edges,function,default,throw,new,illegal,argument,exception,illegal,edge,direction
Graph -> public DataSet<Tuple2<K, EV>> reduceOnEdges(ReduceEdgesFunction<EV> reduceEdgesFunction, 			EdgeDirection direction) throws IllegalArgumentException;1445854323;Compute a reduce transformation over the edge values of each vertex._For each vertex, the transformation consecutively calls a_{@link ReduceEdgesFunction} until only a single value for each edge remains._The {@link ReduceEdgesFunction} combines two edge values into one new value of the same type.__@param reduceEdgesFunction the reduce function to apply to the neighbors of each vertex._@param direction the edge direction (in-, out-, all-)_@return a Dataset of Tuple2, with one tuple per vertex._The first field of the Tuple2 is the vertex ID and the second field_is the aggregate value computed by the provided {@link ReduceEdgesFunction}._@throws IllegalArgumentException;public DataSet<Tuple2<K, EV>> reduceOnEdges(ReduceEdgesFunction<EV> reduceEdgesFunction,_			EdgeDirection direction) throws IllegalArgumentException {__		switch (direction) {_			case IN:_				return edges.map(new ProjectVertexWithEdgeValueMap<K, EV>(1))_						.withForwardedFields("f1->f0")_						.groupBy(0).reduce(new ApplyReduceFunction<K, EV>(reduceEdgesFunction))__			case OUT:_				return edges.map(new ProjectVertexWithEdgeValueMap<K, EV>(0))_						.withForwardedFields("f0->f0")_						.groupBy(0).reduce(new ApplyReduceFunction<K, EV>(reduceEdgesFunction))__			case ALL:_				return edges.flatMap(new EmitOneVertexWithEdgeValuePerNode<K, EV>())_						.withForwardedFields("f2->f1")_						.groupBy(0).reduce(new ApplyReduceFunction<K, EV>(reduceEdgesFunction))__			default:_				throw new IllegalArgumentException("Illegal edge direction")__		}_	};compute,a,reduce,transformation,over,the,edge,values,of,each,vertex,for,each,vertex,the,transformation,consecutively,calls,a,link,reduce,edges,function,until,only,a,single,value,for,each,edge,remains,the,link,reduce,edges,function,combines,two,edge,values,into,one,new,value,of,the,same,type,param,reduce,edges,function,the,reduce,function,to,apply,to,the,neighbors,of,each,vertex,param,direction,the,edge,direction,in,out,all,return,a,dataset,of,tuple2,with,one,tuple,per,vertex,the,first,field,of,the,tuple2,is,the,vertex,id,and,the,second,field,is,the,aggregate,value,computed,by,the,provided,link,reduce,edges,function,throws,illegal,argument,exception;public,data,set,tuple2,k,ev,reduce,on,edges,reduce,edges,function,ev,reduce,edges,function,edge,direction,direction,throws,illegal,argument,exception,switch,direction,case,in,return,edges,map,new,project,vertex,with,edge,value,map,k,ev,1,with,forwarded,fields,f1,f0,group,by,0,reduce,new,apply,reduce,function,k,ev,reduce,edges,function,case,out,return,edges,map,new,project,vertex,with,edge,value,map,k,ev,0,with,forwarded,fields,f0,f0,group,by,0,reduce,new,apply,reduce,function,k,ev,reduce,edges,function,case,all,return,edges,flat,map,new,emit,one,vertex,with,edge,value,per,node,k,ev,with,forwarded,fields,f2,f1,group,by,0,reduce,new,apply,reduce,function,k,ev,reduce,edges,function,default,throw,new,illegal,argument,exception,illegal,edge,direction
Graph -> public DataSet<Tuple2<K, EV>> reduceOnEdges(ReduceEdgesFunction<EV> reduceEdgesFunction, 			EdgeDirection direction) throws IllegalArgumentException;1446112342;Compute a reduce transformation over the edge values of each vertex._For each vertex, the transformation consecutively calls a_{@link ReduceEdgesFunction} until only a single value for each edge remains._The {@link ReduceEdgesFunction} combines two edge values into one new value of the same type.__@param reduceEdgesFunction the reduce function to apply to the neighbors of each vertex._@param direction the edge direction (in-, out-, all-)_@return a Dataset of Tuple2, with one tuple per vertex._The first field of the Tuple2 is the vertex ID and the second field_is the aggregate value computed by the provided {@link ReduceEdgesFunction}._@throws IllegalArgumentException;public DataSet<Tuple2<K, EV>> reduceOnEdges(ReduceEdgesFunction<EV> reduceEdgesFunction,_			EdgeDirection direction) throws IllegalArgumentException {__		switch (direction) {_			case IN:_				return edges.map(new ProjectVertexWithEdgeValueMap<K, EV>(1))_						.withForwardedFields("f1->f0")_						.groupBy(0).reduce(new ApplyReduceFunction<K, EV>(reduceEdgesFunction))__			case OUT:_				return edges.map(new ProjectVertexWithEdgeValueMap<K, EV>(0))_						.withForwardedFields("f0->f0")_						.groupBy(0).reduce(new ApplyReduceFunction<K, EV>(reduceEdgesFunction))__			case ALL:_				return edges.flatMap(new EmitOneVertexWithEdgeValuePerNode<K, EV>())_						.withForwardedFields("f2->f1")_						.groupBy(0).reduce(new ApplyReduceFunction<K, EV>(reduceEdgesFunction))__			default:_				throw new IllegalArgumentException("Illegal edge direction")__		}_	};compute,a,reduce,transformation,over,the,edge,values,of,each,vertex,for,each,vertex,the,transformation,consecutively,calls,a,link,reduce,edges,function,until,only,a,single,value,for,each,edge,remains,the,link,reduce,edges,function,combines,two,edge,values,into,one,new,value,of,the,same,type,param,reduce,edges,function,the,reduce,function,to,apply,to,the,neighbors,of,each,vertex,param,direction,the,edge,direction,in,out,all,return,a,dataset,of,tuple2,with,one,tuple,per,vertex,the,first,field,of,the,tuple2,is,the,vertex,id,and,the,second,field,is,the,aggregate,value,computed,by,the,provided,link,reduce,edges,function,throws,illegal,argument,exception;public,data,set,tuple2,k,ev,reduce,on,edges,reduce,edges,function,ev,reduce,edges,function,edge,direction,direction,throws,illegal,argument,exception,switch,direction,case,in,return,edges,map,new,project,vertex,with,edge,value,map,k,ev,1,with,forwarded,fields,f1,f0,group,by,0,reduce,new,apply,reduce,function,k,ev,reduce,edges,function,case,out,return,edges,map,new,project,vertex,with,edge,value,map,k,ev,0,with,forwarded,fields,f0,f0,group,by,0,reduce,new,apply,reduce,function,k,ev,reduce,edges,function,case,all,return,edges,flat,map,new,emit,one,vertex,with,edge,value,per,node,k,ev,with,forwarded,fields,f2,f1,group,by,0,reduce,new,apply,reduce,function,k,ev,reduce,edges,function,default,throw,new,illegal,argument,exception,illegal,edge,direction
Graph -> public DataSet<Tuple2<K, EV>> reduceOnEdges(ReduceEdgesFunction<EV> reduceEdgesFunction, 			EdgeDirection direction) throws IllegalArgumentException;1447073368;Compute a reduce transformation over the edge values of each vertex._For each vertex, the transformation consecutively calls a_{@link ReduceEdgesFunction} until only a single value for each edge remains._The {@link ReduceEdgesFunction} combines two edge values into one new value of the same type.__@param reduceEdgesFunction the reduce function to apply to the neighbors of each vertex._@param direction the edge direction (in-, out-, all-)_@return a Dataset of Tuple2, with one tuple per vertex._The first field of the Tuple2 is the vertex ID and the second field_is the aggregate value computed by the provided {@link ReduceEdgesFunction}._@throws IllegalArgumentException;public DataSet<Tuple2<K, EV>> reduceOnEdges(ReduceEdgesFunction<EV> reduceEdgesFunction,_			EdgeDirection direction) throws IllegalArgumentException {__		switch (direction) {_			case IN:_				return edges.map(new ProjectVertexWithEdgeValueMap<K, EV>(1))_						.withForwardedFields("f1->f0")_						.groupBy(0).reduce(new ApplyReduceFunction<K, EV>(reduceEdgesFunction))__			case OUT:_				return edges.map(new ProjectVertexWithEdgeValueMap<K, EV>(0))_						.withForwardedFields("f0->f0")_						.groupBy(0).reduce(new ApplyReduceFunction<K, EV>(reduceEdgesFunction))__			case ALL:_				return edges.flatMap(new EmitOneVertexWithEdgeValuePerNode<K, EV>())_						.withForwardedFields("f2->f1")_						.groupBy(0).reduce(new ApplyReduceFunction<K, EV>(reduceEdgesFunction))__			default:_				throw new IllegalArgumentException("Illegal edge direction")__		}_	};compute,a,reduce,transformation,over,the,edge,values,of,each,vertex,for,each,vertex,the,transformation,consecutively,calls,a,link,reduce,edges,function,until,only,a,single,value,for,each,edge,remains,the,link,reduce,edges,function,combines,two,edge,values,into,one,new,value,of,the,same,type,param,reduce,edges,function,the,reduce,function,to,apply,to,the,neighbors,of,each,vertex,param,direction,the,edge,direction,in,out,all,return,a,dataset,of,tuple2,with,one,tuple,per,vertex,the,first,field,of,the,tuple2,is,the,vertex,id,and,the,second,field,is,the,aggregate,value,computed,by,the,provided,link,reduce,edges,function,throws,illegal,argument,exception;public,data,set,tuple2,k,ev,reduce,on,edges,reduce,edges,function,ev,reduce,edges,function,edge,direction,direction,throws,illegal,argument,exception,switch,direction,case,in,return,edges,map,new,project,vertex,with,edge,value,map,k,ev,1,with,forwarded,fields,f1,f0,group,by,0,reduce,new,apply,reduce,function,k,ev,reduce,edges,function,case,out,return,edges,map,new,project,vertex,with,edge,value,map,k,ev,0,with,forwarded,fields,f0,f0,group,by,0,reduce,new,apply,reduce,function,k,ev,reduce,edges,function,case,all,return,edges,flat,map,new,emit,one,vertex,with,edge,value,per,node,k,ev,with,forwarded,fields,f2,f1,group,by,0,reduce,new,apply,reduce,function,k,ev,reduce,edges,function,default,throw,new,illegal,argument,exception,illegal,edge,direction
Graph -> public DataSet<Tuple2<K, EV>> reduceOnEdges(ReduceEdgesFunction<EV> reduceEdgesFunction, 			EdgeDirection direction) throws IllegalArgumentException;1454404649;Compute a reduce transformation over the edge values of each vertex._For each vertex, the transformation consecutively calls a_{@link ReduceEdgesFunction} until only a single value for each edge remains._The {@link ReduceEdgesFunction} combines two edge values into one new value of the same type.__@param reduceEdgesFunction the reduce function to apply to the neighbors of each vertex._@param direction the edge direction (in-, out-, all-)_@return a Dataset of Tuple2, with one tuple per vertex._The first field of the Tuple2 is the vertex ID and the second field_is the aggregate value computed by the provided {@link ReduceEdgesFunction}._@throws IllegalArgumentException;public DataSet<Tuple2<K, EV>> reduceOnEdges(ReduceEdgesFunction<EV> reduceEdgesFunction,_			EdgeDirection direction) throws IllegalArgumentException {__		switch (direction) {_			case IN:_				return edges.map(new ProjectVertexWithEdgeValueMap<K, EV>(1))_						.withForwardedFields("f1->f0")_						.groupBy(0).reduce(new ApplyReduceFunction<K, EV>(reduceEdgesFunction))__			case OUT:_				return edges.map(new ProjectVertexWithEdgeValueMap<K, EV>(0))_						.withForwardedFields("f0->f0")_						.groupBy(0).reduce(new ApplyReduceFunction<K, EV>(reduceEdgesFunction))__			case ALL:_				return edges.flatMap(new EmitOneVertexWithEdgeValuePerNode<K, EV>())_						.withForwardedFields("f2->f1")_						.groupBy(0).reduce(new ApplyReduceFunction<K, EV>(reduceEdgesFunction))__			default:_				throw new IllegalArgumentException("Illegal edge direction")__		}_	};compute,a,reduce,transformation,over,the,edge,values,of,each,vertex,for,each,vertex,the,transformation,consecutively,calls,a,link,reduce,edges,function,until,only,a,single,value,for,each,edge,remains,the,link,reduce,edges,function,combines,two,edge,values,into,one,new,value,of,the,same,type,param,reduce,edges,function,the,reduce,function,to,apply,to,the,neighbors,of,each,vertex,param,direction,the,edge,direction,in,out,all,return,a,dataset,of,tuple2,with,one,tuple,per,vertex,the,first,field,of,the,tuple2,is,the,vertex,id,and,the,second,field,is,the,aggregate,value,computed,by,the,provided,link,reduce,edges,function,throws,illegal,argument,exception;public,data,set,tuple2,k,ev,reduce,on,edges,reduce,edges,function,ev,reduce,edges,function,edge,direction,direction,throws,illegal,argument,exception,switch,direction,case,in,return,edges,map,new,project,vertex,with,edge,value,map,k,ev,1,with,forwarded,fields,f1,f0,group,by,0,reduce,new,apply,reduce,function,k,ev,reduce,edges,function,case,out,return,edges,map,new,project,vertex,with,edge,value,map,k,ev,0,with,forwarded,fields,f0,f0,group,by,0,reduce,new,apply,reduce,function,k,ev,reduce,edges,function,case,all,return,edges,flat,map,new,emit,one,vertex,with,edge,value,per,node,k,ev,with,forwarded,fields,f2,f1,group,by,0,reduce,new,apply,reduce,function,k,ev,reduce,edges,function,default,throw,new,illegal,argument,exception,illegal,edge,direction
Graph -> public DataSet<Tuple2<K, EV>> reduceOnEdges(ReduceEdgesFunction<EV> reduceEdgesFunction, 			EdgeDirection direction) throws IllegalArgumentException;1458583829;Compute a reduce transformation over the edge values of each vertex._For each vertex, the transformation consecutively calls a_{@link ReduceEdgesFunction} until only a single value for each edge remains._The {@link ReduceEdgesFunction} combines two edge values into one new value of the same type.__@param reduceEdgesFunction the reduce function to apply to the neighbors of each vertex._@param direction the edge direction (in-, out-, all-)_@return a Dataset of Tuple2, with one tuple per vertex._The first field of the Tuple2 is the vertex ID and the second field_is the aggregate value computed by the provided {@link ReduceEdgesFunction}._@throws IllegalArgumentException;public DataSet<Tuple2<K, EV>> reduceOnEdges(ReduceEdgesFunction<EV> reduceEdgesFunction,_			EdgeDirection direction) throws IllegalArgumentException {__		switch (direction) {_			case IN:_				return edges.map(new ProjectVertexWithEdgeValueMap<K, EV>(1))_						.withForwardedFields("f1->f0")_						.groupBy(0).reduce(new ApplyReduceFunction<K, EV>(reduceEdgesFunction))__			case OUT:_				return edges.map(new ProjectVertexWithEdgeValueMap<K, EV>(0))_						.withForwardedFields("f0->f0")_						.groupBy(0).reduce(new ApplyReduceFunction<K, EV>(reduceEdgesFunction))__			case ALL:_				return edges.flatMap(new EmitOneVertexWithEdgeValuePerNode<K, EV>())_						.withForwardedFields("f2->f1")_						.groupBy(0).reduce(new ApplyReduceFunction<K, EV>(reduceEdgesFunction))__			default:_				throw new IllegalArgumentException("Illegal edge direction")__		}_	};compute,a,reduce,transformation,over,the,edge,values,of,each,vertex,for,each,vertex,the,transformation,consecutively,calls,a,link,reduce,edges,function,until,only,a,single,value,for,each,edge,remains,the,link,reduce,edges,function,combines,two,edge,values,into,one,new,value,of,the,same,type,param,reduce,edges,function,the,reduce,function,to,apply,to,the,neighbors,of,each,vertex,param,direction,the,edge,direction,in,out,all,return,a,dataset,of,tuple2,with,one,tuple,per,vertex,the,first,field,of,the,tuple2,is,the,vertex,id,and,the,second,field,is,the,aggregate,value,computed,by,the,provided,link,reduce,edges,function,throws,illegal,argument,exception;public,data,set,tuple2,k,ev,reduce,on,edges,reduce,edges,function,ev,reduce,edges,function,edge,direction,direction,throws,illegal,argument,exception,switch,direction,case,in,return,edges,map,new,project,vertex,with,edge,value,map,k,ev,1,with,forwarded,fields,f1,f0,group,by,0,reduce,new,apply,reduce,function,k,ev,reduce,edges,function,case,out,return,edges,map,new,project,vertex,with,edge,value,map,k,ev,0,with,forwarded,fields,f0,f0,group,by,0,reduce,new,apply,reduce,function,k,ev,reduce,edges,function,case,all,return,edges,flat,map,new,emit,one,vertex,with,edge,value,per,node,k,ev,with,forwarded,fields,f2,f1,group,by,0,reduce,new,apply,reduce,function,k,ev,reduce,edges,function,default,throw,new,illegal,argument,exception,illegal,edge,direction
Graph -> public DataSet<Tuple2<K, EV>> reduceOnEdges(ReduceEdgesFunction<EV> reduceEdgesFunction, 			EdgeDirection direction) throws IllegalArgumentException;1458583829;Compute a reduce transformation over the edge values of each vertex._For each vertex, the transformation consecutively calls a_{@link ReduceEdgesFunction} until only a single value for each edge remains._The {@link ReduceEdgesFunction} combines two edge values into one new value of the same type.__@param reduceEdgesFunction the reduce function to apply to the neighbors of each vertex._@param direction the edge direction (in-, out-, all-)_@return a Dataset of Tuple2, with one tuple per vertex._The first field of the Tuple2 is the vertex ID and the second field_is the aggregate value computed by the provided {@link ReduceEdgesFunction}._@throws IllegalArgumentException;public DataSet<Tuple2<K, EV>> reduceOnEdges(ReduceEdgesFunction<EV> reduceEdgesFunction,_			EdgeDirection direction) throws IllegalArgumentException {__		switch (direction) {_			case IN:_				return edges.map(new ProjectVertexWithEdgeValueMap<K, EV>(1))_						.withForwardedFields("f1->f0")_						.groupBy(0).reduce(new ApplyReduceFunction<K, EV>(reduceEdgesFunction))__			case OUT:_				return edges.map(new ProjectVertexWithEdgeValueMap<K, EV>(0))_						.withForwardedFields("f0->f0")_						.groupBy(0).reduce(new ApplyReduceFunction<K, EV>(reduceEdgesFunction))__			case ALL:_				return edges.flatMap(new EmitOneVertexWithEdgeValuePerNode<K, EV>())_						.withForwardedFields("f2->f1")_						.groupBy(0).reduce(new ApplyReduceFunction<K, EV>(reduceEdgesFunction))__			default:_				throw new IllegalArgumentException("Illegal edge direction")__		}_	};compute,a,reduce,transformation,over,the,edge,values,of,each,vertex,for,each,vertex,the,transformation,consecutively,calls,a,link,reduce,edges,function,until,only,a,single,value,for,each,edge,remains,the,link,reduce,edges,function,combines,two,edge,values,into,one,new,value,of,the,same,type,param,reduce,edges,function,the,reduce,function,to,apply,to,the,neighbors,of,each,vertex,param,direction,the,edge,direction,in,out,all,return,a,dataset,of,tuple2,with,one,tuple,per,vertex,the,first,field,of,the,tuple2,is,the,vertex,id,and,the,second,field,is,the,aggregate,value,computed,by,the,provided,link,reduce,edges,function,throws,illegal,argument,exception;public,data,set,tuple2,k,ev,reduce,on,edges,reduce,edges,function,ev,reduce,edges,function,edge,direction,direction,throws,illegal,argument,exception,switch,direction,case,in,return,edges,map,new,project,vertex,with,edge,value,map,k,ev,1,with,forwarded,fields,f1,f0,group,by,0,reduce,new,apply,reduce,function,k,ev,reduce,edges,function,case,out,return,edges,map,new,project,vertex,with,edge,value,map,k,ev,0,with,forwarded,fields,f0,f0,group,by,0,reduce,new,apply,reduce,function,k,ev,reduce,edges,function,case,all,return,edges,flat,map,new,emit,one,vertex,with,edge,value,per,node,k,ev,with,forwarded,fields,f2,f1,group,by,0,reduce,new,apply,reduce,function,k,ev,reduce,edges,function,default,throw,new,illegal,argument,exception,illegal,edge,direction
Graph -> public DataSet<Tuple2<K, EV>> reduceOnEdges(ReduceEdgesFunction<EV> reduceEdgesFunction, 			EdgeDirection direction) throws IllegalArgumentException;1462100316;Compute a reduce transformation over the edge values of each vertex._For each vertex, the transformation consecutively calls a_{@link ReduceEdgesFunction} until only a single value for each edge remains._The {@link ReduceEdgesFunction} combines two edge values into one new value of the same type.__@param reduceEdgesFunction the reduce function to apply to the neighbors of each vertex._@param direction the edge direction (in-, out-, all-)_@return a Dataset of Tuple2, with one tuple per vertex._The first field of the Tuple2 is the vertex ID and the second field_is the aggregate value computed by the provided {@link ReduceEdgesFunction}._@throws IllegalArgumentException;public DataSet<Tuple2<K, EV>> reduceOnEdges(ReduceEdgesFunction<EV> reduceEdgesFunction,_			EdgeDirection direction) throws IllegalArgumentException {__		switch (direction) {_			case IN:_				return edges.map(new ProjectVertexWithEdgeValueMap<K, EV>(1))_						.withForwardedFields("f1->f0")_						.groupBy(0).reduce(new ApplyReduceFunction<K, EV>(reduceEdgesFunction))__			case OUT:_				return edges.map(new ProjectVertexWithEdgeValueMap<K, EV>(0))_						.withForwardedFields("f0->f0")_						.groupBy(0).reduce(new ApplyReduceFunction<K, EV>(reduceEdgesFunction))__			case ALL:_				return edges.flatMap(new EmitOneVertexWithEdgeValuePerNode<K, EV>())_						.withForwardedFields("f2->f1")_						.groupBy(0).reduce(new ApplyReduceFunction<K, EV>(reduceEdgesFunction))__			default:_				throw new IllegalArgumentException("Illegal edge direction")__		}_	};compute,a,reduce,transformation,over,the,edge,values,of,each,vertex,for,each,vertex,the,transformation,consecutively,calls,a,link,reduce,edges,function,until,only,a,single,value,for,each,edge,remains,the,link,reduce,edges,function,combines,two,edge,values,into,one,new,value,of,the,same,type,param,reduce,edges,function,the,reduce,function,to,apply,to,the,neighbors,of,each,vertex,param,direction,the,edge,direction,in,out,all,return,a,dataset,of,tuple2,with,one,tuple,per,vertex,the,first,field,of,the,tuple2,is,the,vertex,id,and,the,second,field,is,the,aggregate,value,computed,by,the,provided,link,reduce,edges,function,throws,illegal,argument,exception;public,data,set,tuple2,k,ev,reduce,on,edges,reduce,edges,function,ev,reduce,edges,function,edge,direction,direction,throws,illegal,argument,exception,switch,direction,case,in,return,edges,map,new,project,vertex,with,edge,value,map,k,ev,1,with,forwarded,fields,f1,f0,group,by,0,reduce,new,apply,reduce,function,k,ev,reduce,edges,function,case,out,return,edges,map,new,project,vertex,with,edge,value,map,k,ev,0,with,forwarded,fields,f0,f0,group,by,0,reduce,new,apply,reduce,function,k,ev,reduce,edges,function,case,all,return,edges,flat,map,new,emit,one,vertex,with,edge,value,per,node,k,ev,with,forwarded,fields,f2,f1,group,by,0,reduce,new,apply,reduce,function,k,ev,reduce,edges,function,default,throw,new,illegal,argument,exception,illegal,edge,direction
Graph -> public DataSet<Tuple2<K, EV>> reduceOnEdges(ReduceEdgesFunction<EV> reduceEdgesFunction, 			EdgeDirection direction) throws IllegalArgumentException;1462100316;Compute a reduce transformation over the edge values of each vertex._For each vertex, the transformation consecutively calls a_{@link ReduceEdgesFunction} until only a single value for each edge remains._The {@link ReduceEdgesFunction} combines two edge values into one new value of the same type.__@param reduceEdgesFunction the reduce function to apply to the neighbors of each vertex._@param direction the edge direction (in-, out-, all-)_@return a Dataset of Tuple2, with one tuple per vertex._The first field of the Tuple2 is the vertex ID and the second field_is the aggregate value computed by the provided {@link ReduceEdgesFunction}._@throws IllegalArgumentException;public DataSet<Tuple2<K, EV>> reduceOnEdges(ReduceEdgesFunction<EV> reduceEdgesFunction,_			EdgeDirection direction) throws IllegalArgumentException {__		switch (direction) {_			case IN:_				return edges.map(new ProjectVertexWithEdgeValueMap<K, EV>(1))_						.withForwardedFields("f1->f0")_						.groupBy(0).reduce(new ApplyReduceFunction<K, EV>(reduceEdgesFunction))__			case OUT:_				return edges.map(new ProjectVertexWithEdgeValueMap<K, EV>(0))_						.withForwardedFields("f0->f0")_						.groupBy(0).reduce(new ApplyReduceFunction<K, EV>(reduceEdgesFunction))__			case ALL:_				return edges.flatMap(new EmitOneVertexWithEdgeValuePerNode<K, EV>())_						.withForwardedFields("f2->f1")_						.groupBy(0).reduce(new ApplyReduceFunction<K, EV>(reduceEdgesFunction))__			default:_				throw new IllegalArgumentException("Illegal edge direction")__		}_	};compute,a,reduce,transformation,over,the,edge,values,of,each,vertex,for,each,vertex,the,transformation,consecutively,calls,a,link,reduce,edges,function,until,only,a,single,value,for,each,edge,remains,the,link,reduce,edges,function,combines,two,edge,values,into,one,new,value,of,the,same,type,param,reduce,edges,function,the,reduce,function,to,apply,to,the,neighbors,of,each,vertex,param,direction,the,edge,direction,in,out,all,return,a,dataset,of,tuple2,with,one,tuple,per,vertex,the,first,field,of,the,tuple2,is,the,vertex,id,and,the,second,field,is,the,aggregate,value,computed,by,the,provided,link,reduce,edges,function,throws,illegal,argument,exception;public,data,set,tuple2,k,ev,reduce,on,edges,reduce,edges,function,ev,reduce,edges,function,edge,direction,direction,throws,illegal,argument,exception,switch,direction,case,in,return,edges,map,new,project,vertex,with,edge,value,map,k,ev,1,with,forwarded,fields,f1,f0,group,by,0,reduce,new,apply,reduce,function,k,ev,reduce,edges,function,case,out,return,edges,map,new,project,vertex,with,edge,value,map,k,ev,0,with,forwarded,fields,f0,f0,group,by,0,reduce,new,apply,reduce,function,k,ev,reduce,edges,function,case,all,return,edges,flat,map,new,emit,one,vertex,with,edge,value,per,node,k,ev,with,forwarded,fields,f2,f1,group,by,0,reduce,new,apply,reduce,function,k,ev,reduce,edges,function,default,throw,new,illegal,argument,exception,illegal,edge,direction
Graph -> public DataSet<Tuple2<K, EV>> reduceOnEdges(ReduceEdgesFunction<EV> reduceEdgesFunction, 			EdgeDirection direction) throws IllegalArgumentException;1462205213;Compute a reduce transformation over the edge values of each vertex._For each vertex, the transformation consecutively calls a_{@link ReduceEdgesFunction} until only a single value for each edge remains._The {@link ReduceEdgesFunction} combines two edge values into one new value of the same type.__@param reduceEdgesFunction the reduce function to apply to the neighbors of each vertex._@param direction the edge direction (in-, out-, all-)_@return a Dataset of Tuple2, with one tuple per vertex._The first field of the Tuple2 is the vertex ID and the second field_is the aggregate value computed by the provided {@link ReduceEdgesFunction}._@throws IllegalArgumentException;public DataSet<Tuple2<K, EV>> reduceOnEdges(ReduceEdgesFunction<EV> reduceEdgesFunction,_			EdgeDirection direction) throws IllegalArgumentException {__		switch (direction) {_			case IN:_				return edges.map(new ProjectVertexWithEdgeValueMap<K, EV>(1))_						.withForwardedFields("f1->f0")_						.groupBy(0).reduce(new ApplyReduceFunction<K, EV>(reduceEdgesFunction))__			case OUT:_				return edges.map(new ProjectVertexWithEdgeValueMap<K, EV>(0))_						.withForwardedFields("f0->f0")_						.groupBy(0).reduce(new ApplyReduceFunction<K, EV>(reduceEdgesFunction))__			case ALL:_				return edges.flatMap(new EmitOneVertexWithEdgeValuePerNode<K, EV>())_						.withForwardedFields("f2->f1")_						.groupBy(0).reduce(new ApplyReduceFunction<K, EV>(reduceEdgesFunction))__			default:_				throw new IllegalArgumentException("Illegal edge direction")__		}_	};compute,a,reduce,transformation,over,the,edge,values,of,each,vertex,for,each,vertex,the,transformation,consecutively,calls,a,link,reduce,edges,function,until,only,a,single,value,for,each,edge,remains,the,link,reduce,edges,function,combines,two,edge,values,into,one,new,value,of,the,same,type,param,reduce,edges,function,the,reduce,function,to,apply,to,the,neighbors,of,each,vertex,param,direction,the,edge,direction,in,out,all,return,a,dataset,of,tuple2,with,one,tuple,per,vertex,the,first,field,of,the,tuple2,is,the,vertex,id,and,the,second,field,is,the,aggregate,value,computed,by,the,provided,link,reduce,edges,function,throws,illegal,argument,exception;public,data,set,tuple2,k,ev,reduce,on,edges,reduce,edges,function,ev,reduce,edges,function,edge,direction,direction,throws,illegal,argument,exception,switch,direction,case,in,return,edges,map,new,project,vertex,with,edge,value,map,k,ev,1,with,forwarded,fields,f1,f0,group,by,0,reduce,new,apply,reduce,function,k,ev,reduce,edges,function,case,out,return,edges,map,new,project,vertex,with,edge,value,map,k,ev,0,with,forwarded,fields,f0,f0,group,by,0,reduce,new,apply,reduce,function,k,ev,reduce,edges,function,case,all,return,edges,flat,map,new,emit,one,vertex,with,edge,value,per,node,k,ev,with,forwarded,fields,f2,f1,group,by,0,reduce,new,apply,reduce,function,k,ev,reduce,edges,function,default,throw,new,illegal,argument,exception,illegal,edge,direction
Graph -> public DataSet<Tuple2<K, EV>> reduceOnEdges(ReduceEdgesFunction<EV> reduceEdgesFunction, 			EdgeDirection direction) throws IllegalArgumentException;1462208859;Compute a reduce transformation over the edge values of each vertex._For each vertex, the transformation consecutively calls a_{@link ReduceEdgesFunction} until only a single value for each edge remains._The {@link ReduceEdgesFunction} combines two edge values into one new value of the same type.__@param reduceEdgesFunction the reduce function to apply to the neighbors of each vertex._@param direction the edge direction (in-, out-, all-)_@return a Dataset of Tuple2, with one tuple per vertex._The first field of the Tuple2 is the vertex ID and the second field_is the aggregate value computed by the provided {@link ReduceEdgesFunction}._@throws IllegalArgumentException;public DataSet<Tuple2<K, EV>> reduceOnEdges(ReduceEdgesFunction<EV> reduceEdgesFunction,_			EdgeDirection direction) throws IllegalArgumentException {__		switch (direction) {_			case IN:_				return edges.map(new ProjectVertexWithEdgeValueMap<K, EV>(1))_						.withForwardedFields("f1->f0")_						.groupBy(0).reduce(new ApplyReduceFunction<K, EV>(reduceEdgesFunction))__			case OUT:_				return edges.map(new ProjectVertexWithEdgeValueMap<K, EV>(0))_						.withForwardedFields("f0->f0")_						.groupBy(0).reduce(new ApplyReduceFunction<K, EV>(reduceEdgesFunction))__			case ALL:_				return edges.flatMap(new EmitOneVertexWithEdgeValuePerNode<K, EV>())_						.withForwardedFields("f2->f1")_						.groupBy(0).reduce(new ApplyReduceFunction<K, EV>(reduceEdgesFunction))__			default:_				throw new IllegalArgumentException("Illegal edge direction")__		}_	};compute,a,reduce,transformation,over,the,edge,values,of,each,vertex,for,each,vertex,the,transformation,consecutively,calls,a,link,reduce,edges,function,until,only,a,single,value,for,each,edge,remains,the,link,reduce,edges,function,combines,two,edge,values,into,one,new,value,of,the,same,type,param,reduce,edges,function,the,reduce,function,to,apply,to,the,neighbors,of,each,vertex,param,direction,the,edge,direction,in,out,all,return,a,dataset,of,tuple2,with,one,tuple,per,vertex,the,first,field,of,the,tuple2,is,the,vertex,id,and,the,second,field,is,the,aggregate,value,computed,by,the,provided,link,reduce,edges,function,throws,illegal,argument,exception;public,data,set,tuple2,k,ev,reduce,on,edges,reduce,edges,function,ev,reduce,edges,function,edge,direction,direction,throws,illegal,argument,exception,switch,direction,case,in,return,edges,map,new,project,vertex,with,edge,value,map,k,ev,1,with,forwarded,fields,f1,f0,group,by,0,reduce,new,apply,reduce,function,k,ev,reduce,edges,function,case,out,return,edges,map,new,project,vertex,with,edge,value,map,k,ev,0,with,forwarded,fields,f0,f0,group,by,0,reduce,new,apply,reduce,function,k,ev,reduce,edges,function,case,all,return,edges,flat,map,new,emit,one,vertex,with,edge,value,per,node,k,ev,with,forwarded,fields,f2,f1,group,by,0,reduce,new,apply,reduce,function,k,ev,reduce,edges,function,default,throw,new,illegal,argument,exception,illegal,edge,direction
Graph -> public DataSet<Tuple2<K, EV>> reduceOnEdges(ReduceEdgesFunction<EV> reduceEdgesFunction, 			EdgeDirection direction) throws IllegalArgumentException;1462809297;Compute a reduce transformation over the edge values of each vertex._For each vertex, the transformation consecutively calls a_{@link ReduceEdgesFunction} until only a single value for each edge remains._The {@link ReduceEdgesFunction} combines two edge values into one new value of the same type.__@param reduceEdgesFunction the reduce function to apply to the neighbors of each vertex._@param direction the edge direction (in-, out-, all-)_@return a Dataset of Tuple2, with one tuple per vertex._The first field of the Tuple2 is the vertex ID and the second field_is the aggregate value computed by the provided {@link ReduceEdgesFunction}._@throws IllegalArgumentException;public DataSet<Tuple2<K, EV>> reduceOnEdges(ReduceEdgesFunction<EV> reduceEdgesFunction,_			EdgeDirection direction) throws IllegalArgumentException {__		switch (direction) {_			case IN:_				return edges.map(new ProjectVertexWithEdgeValueMap<K, EV>(1))_						.withForwardedFields("f1->f0")_						.groupBy(0).reduce(new ApplyReduceFunction<K, EV>(reduceEdgesFunction))__			case OUT:_				return edges.map(new ProjectVertexWithEdgeValueMap<K, EV>(0))_						.withForwardedFields("f0->f0")_						.groupBy(0).reduce(new ApplyReduceFunction<K, EV>(reduceEdgesFunction))__			case ALL:_				return edges.flatMap(new EmitOneVertexWithEdgeValuePerNode<K, EV>())_						.withForwardedFields("f2->f1")_						.groupBy(0).reduce(new ApplyReduceFunction<K, EV>(reduceEdgesFunction))__			default:_				throw new IllegalArgumentException("Illegal edge direction")__		}_	};compute,a,reduce,transformation,over,the,edge,values,of,each,vertex,for,each,vertex,the,transformation,consecutively,calls,a,link,reduce,edges,function,until,only,a,single,value,for,each,edge,remains,the,link,reduce,edges,function,combines,two,edge,values,into,one,new,value,of,the,same,type,param,reduce,edges,function,the,reduce,function,to,apply,to,the,neighbors,of,each,vertex,param,direction,the,edge,direction,in,out,all,return,a,dataset,of,tuple2,with,one,tuple,per,vertex,the,first,field,of,the,tuple2,is,the,vertex,id,and,the,second,field,is,the,aggregate,value,computed,by,the,provided,link,reduce,edges,function,throws,illegal,argument,exception;public,data,set,tuple2,k,ev,reduce,on,edges,reduce,edges,function,ev,reduce,edges,function,edge,direction,direction,throws,illegal,argument,exception,switch,direction,case,in,return,edges,map,new,project,vertex,with,edge,value,map,k,ev,1,with,forwarded,fields,f1,f0,group,by,0,reduce,new,apply,reduce,function,k,ev,reduce,edges,function,case,out,return,edges,map,new,project,vertex,with,edge,value,map,k,ev,0,with,forwarded,fields,f0,f0,group,by,0,reduce,new,apply,reduce,function,k,ev,reduce,edges,function,case,all,return,edges,flat,map,new,emit,one,vertex,with,edge,value,per,node,k,ev,with,forwarded,fields,f2,f1,group,by,0,reduce,new,apply,reduce,function,k,ev,reduce,edges,function,default,throw,new,illegal,argument,exception,illegal,edge,direction
Graph -> public DataSet<Tuple2<K, EV>> reduceOnEdges(ReduceEdgesFunction<EV> reduceEdgesFunction, 			EdgeDirection direction) throws IllegalArgumentException;1465316775;Compute a reduce transformation over the edge values of each vertex._For each vertex, the transformation consecutively calls a_{@link ReduceEdgesFunction} until only a single value for each edge remains._The {@link ReduceEdgesFunction} combines two edge values into one new value of the same type.__@param reduceEdgesFunction the reduce function to apply to the neighbors of each vertex._@param direction the edge direction (in-, out-, all-)_@return a Dataset of Tuple2, with one tuple per vertex._The first field of the Tuple2 is the vertex ID and the second field_is the aggregate value computed by the provided {@link ReduceEdgesFunction}._@throws IllegalArgumentException;public DataSet<Tuple2<K, EV>> reduceOnEdges(ReduceEdgesFunction<EV> reduceEdgesFunction,_			EdgeDirection direction) throws IllegalArgumentException {__		switch (direction) {_			case IN:_				return edges.map(new ProjectVertexWithEdgeValueMap<K, EV>(1))_						.withForwardedFields("f1->f0")_						.groupBy(0).reduce(new ApplyReduceFunction<K, EV>(reduceEdgesFunction))__			case OUT:_				return edges.map(new ProjectVertexWithEdgeValueMap<K, EV>(0))_						.withForwardedFields("f0->f0")_						.groupBy(0).reduce(new ApplyReduceFunction<K, EV>(reduceEdgesFunction))__			case ALL:_				return edges.flatMap(new EmitOneVertexWithEdgeValuePerNode<K, EV>())_						.withForwardedFields("f2->f1")_						.groupBy(0).reduce(new ApplyReduceFunction<K, EV>(reduceEdgesFunction))__			default:_				throw new IllegalArgumentException("Illegal edge direction")__		}_	};compute,a,reduce,transformation,over,the,edge,values,of,each,vertex,for,each,vertex,the,transformation,consecutively,calls,a,link,reduce,edges,function,until,only,a,single,value,for,each,edge,remains,the,link,reduce,edges,function,combines,two,edge,values,into,one,new,value,of,the,same,type,param,reduce,edges,function,the,reduce,function,to,apply,to,the,neighbors,of,each,vertex,param,direction,the,edge,direction,in,out,all,return,a,dataset,of,tuple2,with,one,tuple,per,vertex,the,first,field,of,the,tuple2,is,the,vertex,id,and,the,second,field,is,the,aggregate,value,computed,by,the,provided,link,reduce,edges,function,throws,illegal,argument,exception;public,data,set,tuple2,k,ev,reduce,on,edges,reduce,edges,function,ev,reduce,edges,function,edge,direction,direction,throws,illegal,argument,exception,switch,direction,case,in,return,edges,map,new,project,vertex,with,edge,value,map,k,ev,1,with,forwarded,fields,f1,f0,group,by,0,reduce,new,apply,reduce,function,k,ev,reduce,edges,function,case,out,return,edges,map,new,project,vertex,with,edge,value,map,k,ev,0,with,forwarded,fields,f0,f0,group,by,0,reduce,new,apply,reduce,function,k,ev,reduce,edges,function,case,all,return,edges,flat,map,new,emit,one,vertex,with,edge,value,per,node,k,ev,with,forwarded,fields,f2,f1,group,by,0,reduce,new,apply,reduce,function,k,ev,reduce,edges,function,default,throw,new,illegal,argument,exception,illegal,edge,direction
Graph -> public DataSet<Tuple2<K, EV>> reduceOnEdges(ReduceEdgesFunction<EV> reduceEdgesFunction, 			EdgeDirection direction) throws IllegalArgumentException;1466789678;Compute a reduce transformation over the edge values of each vertex._For each vertex, the transformation consecutively calls a_{@link ReduceEdgesFunction} until only a single value for each edge remains._The {@link ReduceEdgesFunction} combines two edge values into one new value of the same type.__@param reduceEdgesFunction the reduce function to apply to the neighbors of each vertex._@param direction the edge direction (in-, out-, all-)_@return a Dataset of Tuple2, with one tuple per vertex._The first field of the Tuple2 is the vertex ID and the second field_is the aggregate value computed by the provided {@link ReduceEdgesFunction}._@throws IllegalArgumentException;public DataSet<Tuple2<K, EV>> reduceOnEdges(ReduceEdgesFunction<EV> reduceEdgesFunction,_			EdgeDirection direction) throws IllegalArgumentException {__		switch (direction) {_			case IN:_				return edges.map(new ProjectVertexWithEdgeValueMap<K, EV>(1))_						.withForwardedFields("f1->f0")_						.groupBy(0).reduce(new ApplyReduceFunction<K, EV>(reduceEdgesFunction))__			case OUT:_				return edges.map(new ProjectVertexWithEdgeValueMap<K, EV>(0))_						.withForwardedFields("f0->f0")_						.groupBy(0).reduce(new ApplyReduceFunction<K, EV>(reduceEdgesFunction))__			case ALL:_				return edges.flatMap(new EmitOneVertexWithEdgeValuePerNode<K, EV>())_						.withForwardedFields("f2->f1")_						.groupBy(0).reduce(new ApplyReduceFunction<K, EV>(reduceEdgesFunction))__			default:_				throw new IllegalArgumentException("Illegal edge direction")__		}_	};compute,a,reduce,transformation,over,the,edge,values,of,each,vertex,for,each,vertex,the,transformation,consecutively,calls,a,link,reduce,edges,function,until,only,a,single,value,for,each,edge,remains,the,link,reduce,edges,function,combines,two,edge,values,into,one,new,value,of,the,same,type,param,reduce,edges,function,the,reduce,function,to,apply,to,the,neighbors,of,each,vertex,param,direction,the,edge,direction,in,out,all,return,a,dataset,of,tuple2,with,one,tuple,per,vertex,the,first,field,of,the,tuple2,is,the,vertex,id,and,the,second,field,is,the,aggregate,value,computed,by,the,provided,link,reduce,edges,function,throws,illegal,argument,exception;public,data,set,tuple2,k,ev,reduce,on,edges,reduce,edges,function,ev,reduce,edges,function,edge,direction,direction,throws,illegal,argument,exception,switch,direction,case,in,return,edges,map,new,project,vertex,with,edge,value,map,k,ev,1,with,forwarded,fields,f1,f0,group,by,0,reduce,new,apply,reduce,function,k,ev,reduce,edges,function,case,out,return,edges,map,new,project,vertex,with,edge,value,map,k,ev,0,with,forwarded,fields,f0,f0,group,by,0,reduce,new,apply,reduce,function,k,ev,reduce,edges,function,case,all,return,edges,flat,map,new,emit,one,vertex,with,edge,value,per,node,k,ev,with,forwarded,fields,f2,f1,group,by,0,reduce,new,apply,reduce,function,k,ev,reduce,edges,function,default,throw,new,illegal,argument,exception,illegal,edge,direction
Graph -> public DataSet<Tuple2<K, EV>> reduceOnEdges(ReduceEdgesFunction<EV> reduceEdgesFunction, 			EdgeDirection direction) throws IllegalArgumentException;1467140656;Compute a reduce transformation over the edge values of each vertex._For each vertex, the transformation consecutively calls a_{@link ReduceEdgesFunction} until only a single value for each edge remains._The {@link ReduceEdgesFunction} combines two edge values into one new value of the same type.__@param reduceEdgesFunction the reduce function to apply to the neighbors of each vertex._@param direction the edge direction (in-, out-, all-)_@return a Dataset of Tuple2, with one tuple per vertex._The first field of the Tuple2 is the vertex ID and the second field_is the aggregate value computed by the provided {@link ReduceEdgesFunction}._@throws IllegalArgumentException;public DataSet<Tuple2<K, EV>> reduceOnEdges(ReduceEdgesFunction<EV> reduceEdgesFunction,_			EdgeDirection direction) throws IllegalArgumentException {__		switch (direction) {_			case IN:_				return edges.map(new ProjectVertexWithEdgeValueMap<K, EV>(1))_						.withForwardedFields("f1->f0")_						.groupBy(0).reduce(new ApplyReduceFunction<K, EV>(reduceEdgesFunction))__			case OUT:_				return edges.map(new ProjectVertexWithEdgeValueMap<K, EV>(0))_						.withForwardedFields("f0->f0")_						.groupBy(0).reduce(new ApplyReduceFunction<K, EV>(reduceEdgesFunction))__			case ALL:_				return edges.flatMap(new EmitOneVertexWithEdgeValuePerNode<K, EV>())_						.withForwardedFields("f2->f1")_						.groupBy(0).reduce(new ApplyReduceFunction<K, EV>(reduceEdgesFunction))__			default:_				throw new IllegalArgumentException("Illegal edge direction")__		}_	};compute,a,reduce,transformation,over,the,edge,values,of,each,vertex,for,each,vertex,the,transformation,consecutively,calls,a,link,reduce,edges,function,until,only,a,single,value,for,each,edge,remains,the,link,reduce,edges,function,combines,two,edge,values,into,one,new,value,of,the,same,type,param,reduce,edges,function,the,reduce,function,to,apply,to,the,neighbors,of,each,vertex,param,direction,the,edge,direction,in,out,all,return,a,dataset,of,tuple2,with,one,tuple,per,vertex,the,first,field,of,the,tuple2,is,the,vertex,id,and,the,second,field,is,the,aggregate,value,computed,by,the,provided,link,reduce,edges,function,throws,illegal,argument,exception;public,data,set,tuple2,k,ev,reduce,on,edges,reduce,edges,function,ev,reduce,edges,function,edge,direction,direction,throws,illegal,argument,exception,switch,direction,case,in,return,edges,map,new,project,vertex,with,edge,value,map,k,ev,1,with,forwarded,fields,f1,f0,group,by,0,reduce,new,apply,reduce,function,k,ev,reduce,edges,function,case,out,return,edges,map,new,project,vertex,with,edge,value,map,k,ev,0,with,forwarded,fields,f0,f0,group,by,0,reduce,new,apply,reduce,function,k,ev,reduce,edges,function,case,all,return,edges,flat,map,new,emit,one,vertex,with,edge,value,per,node,k,ev,with,forwarded,fields,f2,f1,group,by,0,reduce,new,apply,reduce,function,k,ev,reduce,edges,function,default,throw,new,illegal,argument,exception,illegal,edge,direction
Graph -> public DataSet<Tuple2<K, EV>> reduceOnEdges(ReduceEdgesFunction<EV> reduceEdgesFunction, 			EdgeDirection direction) throws IllegalArgumentException;1467306272;Compute a reduce transformation over the edge values of each vertex._For each vertex, the transformation consecutively calls a_{@link ReduceEdgesFunction} until only a single value for each edge remains._The {@link ReduceEdgesFunction} combines two edge values into one new value of the same type.__@param reduceEdgesFunction the reduce function to apply to the neighbors of each vertex._@param direction the edge direction (in-, out-, all-)_@return a Dataset of Tuple2, with one tuple per vertex._The first field of the Tuple2 is the vertex ID and the second field_is the aggregate value computed by the provided {@link ReduceEdgesFunction}._@throws IllegalArgumentException;public DataSet<Tuple2<K, EV>> reduceOnEdges(ReduceEdgesFunction<EV> reduceEdgesFunction,_			EdgeDirection direction) throws IllegalArgumentException {__		switch (direction) {_			case IN:_				return edges.map(new ProjectVertexWithEdgeValueMap<K, EV>(1))_						.withForwardedFields("f1->f0")_						.groupBy(0).reduce(new ApplyReduceFunction<K, EV>(reduceEdgesFunction))__			case OUT:_				return edges.map(new ProjectVertexWithEdgeValueMap<K, EV>(0))_						.withForwardedFields("f0->f0")_						.groupBy(0).reduce(new ApplyReduceFunction<K, EV>(reduceEdgesFunction))__			case ALL:_				return edges.flatMap(new EmitOneVertexWithEdgeValuePerNode<K, EV>())_						.withForwardedFields("f2->f1")_						.groupBy(0).reduce(new ApplyReduceFunction<K, EV>(reduceEdgesFunction))__			default:_				throw new IllegalArgumentException("Illegal edge direction")__		}_	};compute,a,reduce,transformation,over,the,edge,values,of,each,vertex,for,each,vertex,the,transformation,consecutively,calls,a,link,reduce,edges,function,until,only,a,single,value,for,each,edge,remains,the,link,reduce,edges,function,combines,two,edge,values,into,one,new,value,of,the,same,type,param,reduce,edges,function,the,reduce,function,to,apply,to,the,neighbors,of,each,vertex,param,direction,the,edge,direction,in,out,all,return,a,dataset,of,tuple2,with,one,tuple,per,vertex,the,first,field,of,the,tuple2,is,the,vertex,id,and,the,second,field,is,the,aggregate,value,computed,by,the,provided,link,reduce,edges,function,throws,illegal,argument,exception;public,data,set,tuple2,k,ev,reduce,on,edges,reduce,edges,function,ev,reduce,edges,function,edge,direction,direction,throws,illegal,argument,exception,switch,direction,case,in,return,edges,map,new,project,vertex,with,edge,value,map,k,ev,1,with,forwarded,fields,f1,f0,group,by,0,reduce,new,apply,reduce,function,k,ev,reduce,edges,function,case,out,return,edges,map,new,project,vertex,with,edge,value,map,k,ev,0,with,forwarded,fields,f0,f0,group,by,0,reduce,new,apply,reduce,function,k,ev,reduce,edges,function,case,all,return,edges,flat,map,new,emit,one,vertex,with,edge,value,per,node,k,ev,with,forwarded,fields,f2,f1,group,by,0,reduce,new,apply,reduce,function,k,ev,reduce,edges,function,default,throw,new,illegal,argument,exception,illegal,edge,direction
Graph -> public DataSet<Tuple2<K, EV>> reduceOnEdges(ReduceEdgesFunction<EV> reduceEdgesFunction, 			EdgeDirection direction) throws IllegalArgumentException;1470042815;Compute a reduce transformation over the edge values of each vertex._For each vertex, the transformation consecutively calls a_{@link ReduceEdgesFunction} until only a single value for each edge remains._The {@link ReduceEdgesFunction} combines two edge values into one new value of the same type.__@param reduceEdgesFunction the reduce function to apply to the neighbors of each vertex._@param direction the edge direction (in-, out-, all-)_@return a Dataset of Tuple2, with one tuple per vertex._The first field of the Tuple2 is the vertex ID and the second field_is the aggregate value computed by the provided {@link ReduceEdgesFunction}._@throws IllegalArgumentException;public DataSet<Tuple2<K, EV>> reduceOnEdges(ReduceEdgesFunction<EV> reduceEdgesFunction,_			EdgeDirection direction) throws IllegalArgumentException {__		switch (direction) {_			case IN:_				return edges.map(new ProjectVertexWithEdgeValueMap<K, EV>(1))_						.withForwardedFields("f1->f0")_						.groupBy(0).reduce(new ApplyReduceFunction<K, EV>(reduceEdgesFunction))__			case OUT:_				return edges.map(new ProjectVertexWithEdgeValueMap<K, EV>(0))_						.withForwardedFields("f0->f0")_						.groupBy(0).reduce(new ApplyReduceFunction<K, EV>(reduceEdgesFunction))__			case ALL:_				return edges.flatMap(new EmitOneVertexWithEdgeValuePerNode<K, EV>())_						.withForwardedFields("f2->f1")_						.groupBy(0).reduce(new ApplyReduceFunction<K, EV>(reduceEdgesFunction))__			default:_				throw new IllegalArgumentException("Illegal edge direction")__		}_	};compute,a,reduce,transformation,over,the,edge,values,of,each,vertex,for,each,vertex,the,transformation,consecutively,calls,a,link,reduce,edges,function,until,only,a,single,value,for,each,edge,remains,the,link,reduce,edges,function,combines,two,edge,values,into,one,new,value,of,the,same,type,param,reduce,edges,function,the,reduce,function,to,apply,to,the,neighbors,of,each,vertex,param,direction,the,edge,direction,in,out,all,return,a,dataset,of,tuple2,with,one,tuple,per,vertex,the,first,field,of,the,tuple2,is,the,vertex,id,and,the,second,field,is,the,aggregate,value,computed,by,the,provided,link,reduce,edges,function,throws,illegal,argument,exception;public,data,set,tuple2,k,ev,reduce,on,edges,reduce,edges,function,ev,reduce,edges,function,edge,direction,direction,throws,illegal,argument,exception,switch,direction,case,in,return,edges,map,new,project,vertex,with,edge,value,map,k,ev,1,with,forwarded,fields,f1,f0,group,by,0,reduce,new,apply,reduce,function,k,ev,reduce,edges,function,case,out,return,edges,map,new,project,vertex,with,edge,value,map,k,ev,0,with,forwarded,fields,f0,f0,group,by,0,reduce,new,apply,reduce,function,k,ev,reduce,edges,function,case,all,return,edges,flat,map,new,emit,one,vertex,with,edge,value,per,node,k,ev,with,forwarded,fields,f2,f1,group,by,0,reduce,new,apply,reduce,function,k,ev,reduce,edges,function,default,throw,new,illegal,argument,exception,illegal,edge,direction
Graph -> public DataSet<Tuple2<K, EV>> reduceOnEdges(ReduceEdgesFunction<EV> reduceEdgesFunction, 			EdgeDirection direction) throws IllegalArgumentException;1475684776;Compute a reduce transformation over the edge values of each vertex._For each vertex, the transformation consecutively calls a_{@link ReduceEdgesFunction} until only a single value for each edge remains._The {@link ReduceEdgesFunction} combines two edge values into one new value of the same type.__@param reduceEdgesFunction the reduce function to apply to the neighbors of each vertex._@param direction the edge direction (in-, out-, all-)_@return a Dataset of Tuple2, with one tuple per vertex._The first field of the Tuple2 is the vertex ID and the second field_is the aggregate value computed by the provided {@link ReduceEdgesFunction}._@throws IllegalArgumentException;public DataSet<Tuple2<K, EV>> reduceOnEdges(ReduceEdgesFunction<EV> reduceEdgesFunction,_			EdgeDirection direction) throws IllegalArgumentException {__		switch (direction) {_			case IN:_				return edges.map(new ProjectVertexWithEdgeValueMap<K, EV>(1))_						.withForwardedFields("f1->f0")_						.groupBy(0).reduce(new ApplyReduceFunction<K, EV>(reduceEdgesFunction))__			case OUT:_				return edges.map(new ProjectVertexWithEdgeValueMap<K, EV>(0))_						.withForwardedFields("f0->f0")_						.groupBy(0).reduce(new ApplyReduceFunction<K, EV>(reduceEdgesFunction))__			case ALL:_				return edges.flatMap(new EmitOneVertexWithEdgeValuePerNode<K, EV>())_						.withForwardedFields("f2->f1")_						.groupBy(0).reduce(new ApplyReduceFunction<K, EV>(reduceEdgesFunction))__			default:_				throw new IllegalArgumentException("Illegal edge direction")__		}_	};compute,a,reduce,transformation,over,the,edge,values,of,each,vertex,for,each,vertex,the,transformation,consecutively,calls,a,link,reduce,edges,function,until,only,a,single,value,for,each,edge,remains,the,link,reduce,edges,function,combines,two,edge,values,into,one,new,value,of,the,same,type,param,reduce,edges,function,the,reduce,function,to,apply,to,the,neighbors,of,each,vertex,param,direction,the,edge,direction,in,out,all,return,a,dataset,of,tuple2,with,one,tuple,per,vertex,the,first,field,of,the,tuple2,is,the,vertex,id,and,the,second,field,is,the,aggregate,value,computed,by,the,provided,link,reduce,edges,function,throws,illegal,argument,exception;public,data,set,tuple2,k,ev,reduce,on,edges,reduce,edges,function,ev,reduce,edges,function,edge,direction,direction,throws,illegal,argument,exception,switch,direction,case,in,return,edges,map,new,project,vertex,with,edge,value,map,k,ev,1,with,forwarded,fields,f1,f0,group,by,0,reduce,new,apply,reduce,function,k,ev,reduce,edges,function,case,out,return,edges,map,new,project,vertex,with,edge,value,map,k,ev,0,with,forwarded,fields,f0,f0,group,by,0,reduce,new,apply,reduce,function,k,ev,reduce,edges,function,case,all,return,edges,flat,map,new,emit,one,vertex,with,edge,value,per,node,k,ev,with,forwarded,fields,f2,f1,group,by,0,reduce,new,apply,reduce,function,k,ev,reduce,edges,function,default,throw,new,illegal,argument,exception,illegal,edge,direction
Graph -> public DataSet<Tuple2<K, EV>> reduceOnEdges(ReduceEdgesFunction<EV> reduceEdgesFunction, 			EdgeDirection direction) throws IllegalArgumentException;1475685606;Compute a reduce transformation over the edge values of each vertex._For each vertex, the transformation consecutively calls a_{@link ReduceEdgesFunction} until only a single value for each edge remains._The {@link ReduceEdgesFunction} combines two edge values into one new value of the same type.__@param reduceEdgesFunction the reduce function to apply to the neighbors of each vertex._@param direction the edge direction (in-, out-, all-)_@return a Dataset of Tuple2, with one tuple per vertex._The first field of the Tuple2 is the vertex ID and the second field_is the aggregate value computed by the provided {@link ReduceEdgesFunction}._@throws IllegalArgumentException;public DataSet<Tuple2<K, EV>> reduceOnEdges(ReduceEdgesFunction<EV> reduceEdgesFunction,_			EdgeDirection direction) throws IllegalArgumentException {__		switch (direction) {_			case IN:_				return edges.map(new ProjectVertexWithEdgeValueMap<K, EV>(1))_						.withForwardedFields("f1->f0")_						.groupBy(0).reduce(new ApplyReduceFunction<K, EV>(reduceEdgesFunction))__			case OUT:_				return edges.map(new ProjectVertexWithEdgeValueMap<K, EV>(0))_						.withForwardedFields("f0->f0")_						.groupBy(0).reduce(new ApplyReduceFunction<K, EV>(reduceEdgesFunction))__			case ALL:_				return edges.flatMap(new EmitOneVertexWithEdgeValuePerNode<K, EV>())_						.withForwardedFields("f2->f1")_						.groupBy(0).reduce(new ApplyReduceFunction<K, EV>(reduceEdgesFunction))__			default:_				throw new IllegalArgumentException("Illegal edge direction")__		}_	};compute,a,reduce,transformation,over,the,edge,values,of,each,vertex,for,each,vertex,the,transformation,consecutively,calls,a,link,reduce,edges,function,until,only,a,single,value,for,each,edge,remains,the,link,reduce,edges,function,combines,two,edge,values,into,one,new,value,of,the,same,type,param,reduce,edges,function,the,reduce,function,to,apply,to,the,neighbors,of,each,vertex,param,direction,the,edge,direction,in,out,all,return,a,dataset,of,tuple2,with,one,tuple,per,vertex,the,first,field,of,the,tuple2,is,the,vertex,id,and,the,second,field,is,the,aggregate,value,computed,by,the,provided,link,reduce,edges,function,throws,illegal,argument,exception;public,data,set,tuple2,k,ev,reduce,on,edges,reduce,edges,function,ev,reduce,edges,function,edge,direction,direction,throws,illegal,argument,exception,switch,direction,case,in,return,edges,map,new,project,vertex,with,edge,value,map,k,ev,1,with,forwarded,fields,f1,f0,group,by,0,reduce,new,apply,reduce,function,k,ev,reduce,edges,function,case,out,return,edges,map,new,project,vertex,with,edge,value,map,k,ev,0,with,forwarded,fields,f0,f0,group,by,0,reduce,new,apply,reduce,function,k,ev,reduce,edges,function,case,all,return,edges,flat,map,new,emit,one,vertex,with,edge,value,per,node,k,ev,with,forwarded,fields,f2,f1,group,by,0,reduce,new,apply,reduce,function,k,ev,reduce,edges,function,default,throw,new,illegal,argument,exception,illegal,edge,direction
Graph -> public DataSet<Tuple2<K, EV>> reduceOnEdges(ReduceEdgesFunction<EV> reduceEdgesFunction, 			EdgeDirection direction) throws IllegalArgumentException;1481745825;Compute a reduce transformation over the edge values of each vertex._For each vertex, the transformation consecutively calls a_{@link ReduceEdgesFunction} until only a single value for each edge remains._The {@link ReduceEdgesFunction} combines two edge values into one new value of the same type.__@param reduceEdgesFunction the reduce function to apply to the neighbors of each vertex._@param direction the edge direction (in-, out-, all-)_@return a Dataset of Tuple2, with one tuple per vertex._The first field of the Tuple2 is the vertex ID and the second field_is the aggregate value computed by the provided {@link ReduceEdgesFunction}._@throws IllegalArgumentException;public DataSet<Tuple2<K, EV>> reduceOnEdges(ReduceEdgesFunction<EV> reduceEdgesFunction,_			EdgeDirection direction) throws IllegalArgumentException {__		switch (direction) {_			case IN:_				return edges.map(new ProjectVertexWithEdgeValueMap<K, EV>(1))_						.withForwardedFields("f1->f0")_							.name("Vertex with in-edges")_						.groupBy(0).reduce(new ApplyReduceFunction<K, EV>(reduceEdgesFunction))_							.name("Reduce on edges")__			case OUT:_				return edges.map(new ProjectVertexWithEdgeValueMap<K, EV>(0))_						.withForwardedFields("f0->f0")_							.name("Vertex with out-edges")_						.groupBy(0).reduce(new ApplyReduceFunction<K, EV>(reduceEdgesFunction))_							.name("Reduce on edges")__			case ALL:_				return edges.flatMap(new EmitOneVertexWithEdgeValuePerNode<K, EV>())_						.withForwardedFields("f2->f1")_							.name("Vertex with all edges")_						.groupBy(0).reduce(new ApplyReduceFunction<K, EV>(reduceEdgesFunction))_							.name("Reduce on edges")__			default:_				throw new IllegalArgumentException("Illegal edge direction")__		}_	};compute,a,reduce,transformation,over,the,edge,values,of,each,vertex,for,each,vertex,the,transformation,consecutively,calls,a,link,reduce,edges,function,until,only,a,single,value,for,each,edge,remains,the,link,reduce,edges,function,combines,two,edge,values,into,one,new,value,of,the,same,type,param,reduce,edges,function,the,reduce,function,to,apply,to,the,neighbors,of,each,vertex,param,direction,the,edge,direction,in,out,all,return,a,dataset,of,tuple2,with,one,tuple,per,vertex,the,first,field,of,the,tuple2,is,the,vertex,id,and,the,second,field,is,the,aggregate,value,computed,by,the,provided,link,reduce,edges,function,throws,illegal,argument,exception;public,data,set,tuple2,k,ev,reduce,on,edges,reduce,edges,function,ev,reduce,edges,function,edge,direction,direction,throws,illegal,argument,exception,switch,direction,case,in,return,edges,map,new,project,vertex,with,edge,value,map,k,ev,1,with,forwarded,fields,f1,f0,name,vertex,with,in,edges,group,by,0,reduce,new,apply,reduce,function,k,ev,reduce,edges,function,name,reduce,on,edges,case,out,return,edges,map,new,project,vertex,with,edge,value,map,k,ev,0,with,forwarded,fields,f0,f0,name,vertex,with,out,edges,group,by,0,reduce,new,apply,reduce,function,k,ev,reduce,edges,function,name,reduce,on,edges,case,all,return,edges,flat,map,new,emit,one,vertex,with,edge,value,per,node,k,ev,with,forwarded,fields,f2,f1,name,vertex,with,all,edges,group,by,0,reduce,new,apply,reduce,function,k,ev,reduce,edges,function,name,reduce,on,edges,default,throw,new,illegal,argument,exception,illegal,edge,direction
Graph -> public DataSet<Tuple2<K, EV>> reduceOnEdges(ReduceEdgesFunction<EV> reduceEdgesFunction, 			EdgeDirection direction) throws IllegalArgumentException;1481881009;Compute a reduce transformation over the edge values of each vertex._For each vertex, the transformation consecutively calls a_{@link ReduceEdgesFunction} until only a single value for each edge remains._The {@link ReduceEdgesFunction} combines two edge values into one new value of the same type.__@param reduceEdgesFunction the reduce function to apply to the neighbors of each vertex._@param direction the edge direction (in-, out-, all-)_@return a Dataset of Tuple2, with one tuple per vertex._The first field of the Tuple2 is the vertex ID and the second field_is the aggregate value computed by the provided {@link ReduceEdgesFunction}._@throws IllegalArgumentException;public DataSet<Tuple2<K, EV>> reduceOnEdges(ReduceEdgesFunction<EV> reduceEdgesFunction,_			EdgeDirection direction) throws IllegalArgumentException {__		switch (direction) {_			case IN:_				return edges.map(new ProjectVertexWithEdgeValueMap<K, EV>(1))_						.withForwardedFields("f1->f0")_							.name("Vertex with in-edges")_						.groupBy(0).reduce(new ApplyReduceFunction<K, EV>(reduceEdgesFunction))_							.name("Reduce on edges")__			case OUT:_				return edges.map(new ProjectVertexWithEdgeValueMap<K, EV>(0))_						.withForwardedFields("f0->f0")_							.name("Vertex with out-edges")_						.groupBy(0).reduce(new ApplyReduceFunction<K, EV>(reduceEdgesFunction))_							.name("Reduce on edges")__			case ALL:_				return edges.flatMap(new EmitOneVertexWithEdgeValuePerNode<K, EV>())_						.withForwardedFields("f2->f1")_							.name("Vertex with all edges")_						.groupBy(0).reduce(new ApplyReduceFunction<K, EV>(reduceEdgesFunction))_							.name("Reduce on edges")__			default:_				throw new IllegalArgumentException("Illegal edge direction")__		}_	};compute,a,reduce,transformation,over,the,edge,values,of,each,vertex,for,each,vertex,the,transformation,consecutively,calls,a,link,reduce,edges,function,until,only,a,single,value,for,each,edge,remains,the,link,reduce,edges,function,combines,two,edge,values,into,one,new,value,of,the,same,type,param,reduce,edges,function,the,reduce,function,to,apply,to,the,neighbors,of,each,vertex,param,direction,the,edge,direction,in,out,all,return,a,dataset,of,tuple2,with,one,tuple,per,vertex,the,first,field,of,the,tuple2,is,the,vertex,id,and,the,second,field,is,the,aggregate,value,computed,by,the,provided,link,reduce,edges,function,throws,illegal,argument,exception;public,data,set,tuple2,k,ev,reduce,on,edges,reduce,edges,function,ev,reduce,edges,function,edge,direction,direction,throws,illegal,argument,exception,switch,direction,case,in,return,edges,map,new,project,vertex,with,edge,value,map,k,ev,1,with,forwarded,fields,f1,f0,name,vertex,with,in,edges,group,by,0,reduce,new,apply,reduce,function,k,ev,reduce,edges,function,name,reduce,on,edges,case,out,return,edges,map,new,project,vertex,with,edge,value,map,k,ev,0,with,forwarded,fields,f0,f0,name,vertex,with,out,edges,group,by,0,reduce,new,apply,reduce,function,k,ev,reduce,edges,function,name,reduce,on,edges,case,all,return,edges,flat,map,new,emit,one,vertex,with,edge,value,per,node,k,ev,with,forwarded,fields,f2,f1,name,vertex,with,all,edges,group,by,0,reduce,new,apply,reduce,function,k,ev,reduce,edges,function,name,reduce,on,edges,default,throw,new,illegal,argument,exception,illegal,edge,direction
Graph -> public DataSet<Tuple2<K, EV>> reduceOnEdges(ReduceEdgesFunction<EV> reduceEdgesFunction, 			EdgeDirection direction) throws IllegalArgumentException;1484160227;Compute a reduce transformation over the edge values of each vertex._For each vertex, the transformation consecutively calls a_{@link ReduceEdgesFunction} until only a single value for each edge remains._The {@link ReduceEdgesFunction} combines two edge values into one new value of the same type.__@param reduceEdgesFunction the reduce function to apply to the neighbors of each vertex._@param direction the edge direction (in-, out-, all-)_@return a Dataset of Tuple2, with one tuple per vertex._The first field of the Tuple2 is the vertex ID and the second field_is the aggregate value computed by the provided {@link ReduceEdgesFunction}._@throws IllegalArgumentException;public DataSet<Tuple2<K, EV>> reduceOnEdges(ReduceEdgesFunction<EV> reduceEdgesFunction,_			EdgeDirection direction) throws IllegalArgumentException {__		switch (direction) {_			case IN:_				return edges.map(new ProjectVertexWithEdgeValueMap<K, EV>(1))_						.withForwardedFields("f1->f0")_							.name("Vertex with in-edges")_						.groupBy(0).reduce(new ApplyReduceFunction<K, EV>(reduceEdgesFunction))_							.name("Reduce on edges")__			case OUT:_				return edges.map(new ProjectVertexWithEdgeValueMap<K, EV>(0))_						.withForwardedFields("f0->f0")_							.name("Vertex with out-edges")_						.groupBy(0).reduce(new ApplyReduceFunction<K, EV>(reduceEdgesFunction))_							.name("Reduce on edges")__			case ALL:_				return edges.flatMap(new EmitOneVertexWithEdgeValuePerNode<K, EV>())_						.withForwardedFields("f2->f1")_							.name("Vertex with all edges")_						.groupBy(0).reduce(new ApplyReduceFunction<K, EV>(reduceEdgesFunction))_							.name("Reduce on edges")__			default:_				throw new IllegalArgumentException("Illegal edge direction")__		}_	};compute,a,reduce,transformation,over,the,edge,values,of,each,vertex,for,each,vertex,the,transformation,consecutively,calls,a,link,reduce,edges,function,until,only,a,single,value,for,each,edge,remains,the,link,reduce,edges,function,combines,two,edge,values,into,one,new,value,of,the,same,type,param,reduce,edges,function,the,reduce,function,to,apply,to,the,neighbors,of,each,vertex,param,direction,the,edge,direction,in,out,all,return,a,dataset,of,tuple2,with,one,tuple,per,vertex,the,first,field,of,the,tuple2,is,the,vertex,id,and,the,second,field,is,the,aggregate,value,computed,by,the,provided,link,reduce,edges,function,throws,illegal,argument,exception;public,data,set,tuple2,k,ev,reduce,on,edges,reduce,edges,function,ev,reduce,edges,function,edge,direction,direction,throws,illegal,argument,exception,switch,direction,case,in,return,edges,map,new,project,vertex,with,edge,value,map,k,ev,1,with,forwarded,fields,f1,f0,name,vertex,with,in,edges,group,by,0,reduce,new,apply,reduce,function,k,ev,reduce,edges,function,name,reduce,on,edges,case,out,return,edges,map,new,project,vertex,with,edge,value,map,k,ev,0,with,forwarded,fields,f0,f0,name,vertex,with,out,edges,group,by,0,reduce,new,apply,reduce,function,k,ev,reduce,edges,function,name,reduce,on,edges,case,all,return,edges,flat,map,new,emit,one,vertex,with,edge,value,per,node,k,ev,with,forwarded,fields,f2,f1,name,vertex,with,all,edges,group,by,0,reduce,new,apply,reduce,function,k,ev,reduce,edges,function,name,reduce,on,edges,default,throw,new,illegal,argument,exception,illegal,edge,direction
Graph -> public DataSet<Tuple2<K, EV>> reduceOnEdges(ReduceEdgesFunction<EV> reduceEdgesFunction, 			EdgeDirection direction) throws IllegalArgumentException;1484685504;Compute a reduce transformation over the edge values of each vertex._For each vertex, the transformation consecutively calls a_{@link ReduceEdgesFunction} until only a single value for each edge remains._The {@link ReduceEdgesFunction} combines two edge values into one new value of the same type.__@param reduceEdgesFunction the reduce function to apply to the neighbors of each vertex._@param direction the edge direction (in-, out-, all-)_@return a Dataset of Tuple2, with one tuple per vertex._The first field of the Tuple2 is the vertex ID and the second field_is the aggregate value computed by the provided {@link ReduceEdgesFunction}._@throws IllegalArgumentException;public DataSet<Tuple2<K, EV>> reduceOnEdges(ReduceEdgesFunction<EV> reduceEdgesFunction,_			EdgeDirection direction) throws IllegalArgumentException {__		switch (direction) {_			case IN:_				return edges.map(new ProjectVertexWithEdgeValueMap<K, EV>(1))_						.withForwardedFields("f1->f0")_							.name("Vertex with in-edges")_						.groupBy(0).reduce(new ApplyReduceFunction<K, EV>(reduceEdgesFunction))_							.name("Reduce on edges")__			case OUT:_				return edges.map(new ProjectVertexWithEdgeValueMap<K, EV>(0))_						.withForwardedFields("f0->f0")_							.name("Vertex with out-edges")_						.groupBy(0).reduce(new ApplyReduceFunction<K, EV>(reduceEdgesFunction))_							.name("Reduce on edges")__			case ALL:_				return edges.flatMap(new EmitOneVertexWithEdgeValuePerNode<K, EV>())_						.withForwardedFields("f2->f1")_							.name("Vertex with all edges")_						.groupBy(0).reduce(new ApplyReduceFunction<K, EV>(reduceEdgesFunction))_							.name("Reduce on edges")__			default:_				throw new IllegalArgumentException("Illegal edge direction")__		}_	};compute,a,reduce,transformation,over,the,edge,values,of,each,vertex,for,each,vertex,the,transformation,consecutively,calls,a,link,reduce,edges,function,until,only,a,single,value,for,each,edge,remains,the,link,reduce,edges,function,combines,two,edge,values,into,one,new,value,of,the,same,type,param,reduce,edges,function,the,reduce,function,to,apply,to,the,neighbors,of,each,vertex,param,direction,the,edge,direction,in,out,all,return,a,dataset,of,tuple2,with,one,tuple,per,vertex,the,first,field,of,the,tuple2,is,the,vertex,id,and,the,second,field,is,the,aggregate,value,computed,by,the,provided,link,reduce,edges,function,throws,illegal,argument,exception;public,data,set,tuple2,k,ev,reduce,on,edges,reduce,edges,function,ev,reduce,edges,function,edge,direction,direction,throws,illegal,argument,exception,switch,direction,case,in,return,edges,map,new,project,vertex,with,edge,value,map,k,ev,1,with,forwarded,fields,f1,f0,name,vertex,with,in,edges,group,by,0,reduce,new,apply,reduce,function,k,ev,reduce,edges,function,name,reduce,on,edges,case,out,return,edges,map,new,project,vertex,with,edge,value,map,k,ev,0,with,forwarded,fields,f0,f0,name,vertex,with,out,edges,group,by,0,reduce,new,apply,reduce,function,k,ev,reduce,edges,function,name,reduce,on,edges,case,all,return,edges,flat,map,new,emit,one,vertex,with,edge,value,per,node,k,ev,with,forwarded,fields,f2,f1,name,vertex,with,all,edges,group,by,0,reduce,new,apply,reduce,function,k,ev,reduce,edges,function,name,reduce,on,edges,default,throw,new,illegal,argument,exception,illegal,edge,direction
Graph -> public DataSet<Tuple2<K, EV>> reduceOnEdges(ReduceEdgesFunction<EV> reduceEdgesFunction, 			EdgeDirection direction) throws IllegalArgumentException;1489068942;Compute a reduce transformation over the edge values of each vertex._For each vertex, the transformation consecutively calls a_{@link ReduceEdgesFunction} until only a single value for each edge remains._The {@link ReduceEdgesFunction} combines two edge values into one new value of the same type.__@param reduceEdgesFunction the reduce function to apply to the neighbors of each vertex._@param direction the edge direction (in-, out-, all-)_@return a Dataset of Tuple2, with one tuple per vertex._The first field of the Tuple2 is the vertex ID and the second field_is the aggregate value computed by the provided {@link ReduceEdgesFunction}._@throws IllegalArgumentException;public DataSet<Tuple2<K, EV>> reduceOnEdges(ReduceEdgesFunction<EV> reduceEdgesFunction,_			EdgeDirection direction) throws IllegalArgumentException {__		switch (direction) {_			case IN:_				return edges.map(new ProjectVertexWithEdgeValueMap<K, EV>(1))_						.withForwardedFields("f1->f0")_							.name("Vertex with in-edges")_						.groupBy(0).reduce(new ApplyReduceFunction<K, EV>(reduceEdgesFunction))_							.name("Reduce on edges")__			case OUT:_				return edges.map(new ProjectVertexWithEdgeValueMap<K, EV>(0))_						.withForwardedFields("f0->f0")_							.name("Vertex with out-edges")_						.groupBy(0).reduce(new ApplyReduceFunction<K, EV>(reduceEdgesFunction))_							.name("Reduce on edges")__			case ALL:_				return edges.flatMap(new EmitOneVertexWithEdgeValuePerNode<K, EV>())_						.withForwardedFields("f2->f1")_							.name("Vertex with all edges")_						.groupBy(0).reduce(new ApplyReduceFunction<K, EV>(reduceEdgesFunction))_							.name("Reduce on edges")__			default:_				throw new IllegalArgumentException("Illegal edge direction")__		}_	};compute,a,reduce,transformation,over,the,edge,values,of,each,vertex,for,each,vertex,the,transformation,consecutively,calls,a,link,reduce,edges,function,until,only,a,single,value,for,each,edge,remains,the,link,reduce,edges,function,combines,two,edge,values,into,one,new,value,of,the,same,type,param,reduce,edges,function,the,reduce,function,to,apply,to,the,neighbors,of,each,vertex,param,direction,the,edge,direction,in,out,all,return,a,dataset,of,tuple2,with,one,tuple,per,vertex,the,first,field,of,the,tuple2,is,the,vertex,id,and,the,second,field,is,the,aggregate,value,computed,by,the,provided,link,reduce,edges,function,throws,illegal,argument,exception;public,data,set,tuple2,k,ev,reduce,on,edges,reduce,edges,function,ev,reduce,edges,function,edge,direction,direction,throws,illegal,argument,exception,switch,direction,case,in,return,edges,map,new,project,vertex,with,edge,value,map,k,ev,1,with,forwarded,fields,f1,f0,name,vertex,with,in,edges,group,by,0,reduce,new,apply,reduce,function,k,ev,reduce,edges,function,name,reduce,on,edges,case,out,return,edges,map,new,project,vertex,with,edge,value,map,k,ev,0,with,forwarded,fields,f0,f0,name,vertex,with,out,edges,group,by,0,reduce,new,apply,reduce,function,k,ev,reduce,edges,function,name,reduce,on,edges,case,all,return,edges,flat,map,new,emit,one,vertex,with,edge,value,per,node,k,ev,with,forwarded,fields,f2,f1,name,vertex,with,all,edges,group,by,0,reduce,new,apply,reduce,function,k,ev,reduce,edges,function,name,reduce,on,edges,default,throw,new,illegal,argument,exception,illegal,edge,direction
Graph -> public DataSet<Tuple2<K, EV>> reduceOnEdges(ReduceEdgesFunction<EV> reduceEdgesFunction, 			EdgeDirection direction) throws IllegalArgumentException;1490973446;Compute a reduce transformation over the edge values of each vertex._For each vertex, the transformation consecutively calls a_{@link ReduceEdgesFunction} until only a single value for each edge remains._The {@link ReduceEdgesFunction} combines two edge values into one new value of the same type.__@param reduceEdgesFunction the reduce function to apply to the neighbors of each vertex._@param direction the edge direction (in-, out-, all-)_@return a Dataset of Tuple2, with one tuple per vertex._The first field of the Tuple2 is the vertex ID and the second field_is the aggregate value computed by the provided {@link ReduceEdgesFunction}._@throws IllegalArgumentException;public DataSet<Tuple2<K, EV>> reduceOnEdges(ReduceEdgesFunction<EV> reduceEdgesFunction,_			EdgeDirection direction) throws IllegalArgumentException {__		switch (direction) {_			case IN:_				return edges.map(new ProjectVertexWithEdgeValueMap<K, EV>(1))_						.withForwardedFields("f1->f0")_							.name("Vertex with in-edges")_						.groupBy(0).reduce(new ApplyReduceFunction<K, EV>(reduceEdgesFunction))_							.name("Reduce on edges")__			case OUT:_				return edges.map(new ProjectVertexWithEdgeValueMap<K, EV>(0))_						.withForwardedFields("f0->f0")_							.name("Vertex with out-edges")_						.groupBy(0).reduce(new ApplyReduceFunction<K, EV>(reduceEdgesFunction))_							.name("Reduce on edges")__			case ALL:_				return edges.flatMap(new EmitOneVertexWithEdgeValuePerNode<K, EV>())_						.withForwardedFields("f2->f1")_							.name("Vertex with all edges")_						.groupBy(0).reduce(new ApplyReduceFunction<K, EV>(reduceEdgesFunction))_							.name("Reduce on edges")__			default:_				throw new IllegalArgumentException("Illegal edge direction")__		}_	};compute,a,reduce,transformation,over,the,edge,values,of,each,vertex,for,each,vertex,the,transformation,consecutively,calls,a,link,reduce,edges,function,until,only,a,single,value,for,each,edge,remains,the,link,reduce,edges,function,combines,two,edge,values,into,one,new,value,of,the,same,type,param,reduce,edges,function,the,reduce,function,to,apply,to,the,neighbors,of,each,vertex,param,direction,the,edge,direction,in,out,all,return,a,dataset,of,tuple2,with,one,tuple,per,vertex,the,first,field,of,the,tuple2,is,the,vertex,id,and,the,second,field,is,the,aggregate,value,computed,by,the,provided,link,reduce,edges,function,throws,illegal,argument,exception;public,data,set,tuple2,k,ev,reduce,on,edges,reduce,edges,function,ev,reduce,edges,function,edge,direction,direction,throws,illegal,argument,exception,switch,direction,case,in,return,edges,map,new,project,vertex,with,edge,value,map,k,ev,1,with,forwarded,fields,f1,f0,name,vertex,with,in,edges,group,by,0,reduce,new,apply,reduce,function,k,ev,reduce,edges,function,name,reduce,on,edges,case,out,return,edges,map,new,project,vertex,with,edge,value,map,k,ev,0,with,forwarded,fields,f0,f0,name,vertex,with,out,edges,group,by,0,reduce,new,apply,reduce,function,k,ev,reduce,edges,function,name,reduce,on,edges,case,all,return,edges,flat,map,new,emit,one,vertex,with,edge,value,per,node,k,ev,with,forwarded,fields,f2,f1,name,vertex,with,all,edges,group,by,0,reduce,new,apply,reduce,function,k,ev,reduce,edges,function,name,reduce,on,edges,default,throw,new,illegal,argument,exception,illegal,edge,direction
Graph -> public DataSet<Tuple2<K, EV>> reduceOnEdges(ReduceEdgesFunction<EV> reduceEdgesFunction, 			EdgeDirection direction) throws IllegalArgumentException;1495819075;Compute a reduce transformation over the edge values of each vertex._For each vertex, the transformation consecutively calls a_{@link ReduceEdgesFunction} until only a single value for each edge remains._The {@link ReduceEdgesFunction} combines two edge values into one new value of the same type.__@param reduceEdgesFunction the reduce function to apply to the neighbors of each vertex._@param direction the edge direction (in-, out-, all-)_@return a Dataset of Tuple2, with one tuple per vertex._The first field of the Tuple2 is the vertex ID and the second field_is the aggregate value computed by the provided {@link ReduceEdgesFunction}._@throws IllegalArgumentException;public DataSet<Tuple2<K, EV>> reduceOnEdges(ReduceEdgesFunction<EV> reduceEdgesFunction,_			EdgeDirection direction) throws IllegalArgumentException {__		switch (direction) {_			case IN:_				return edges.map(new ProjectVertexWithEdgeValueMap<K, EV>(1))_						.withForwardedFields("f1->f0")_							.name("Vertex with in-edges")_						.groupBy(0).reduce(new ApplyReduceFunction<K, EV>(reduceEdgesFunction))_							.name("Reduce on edges")__			case OUT:_				return edges.map(new ProjectVertexWithEdgeValueMap<K, EV>(0))_						.withForwardedFields("f0->f0")_							.name("Vertex with out-edges")_						.groupBy(0).reduce(new ApplyReduceFunction<K, EV>(reduceEdgesFunction))_							.name("Reduce on edges")__			case ALL:_				return edges.flatMap(new EmitOneVertexWithEdgeValuePerNode<K, EV>())_						.withForwardedFields("f2->f1")_							.name("Vertex with all edges")_						.groupBy(0).reduce(new ApplyReduceFunction<K, EV>(reduceEdgesFunction))_							.name("Reduce on edges")__			default:_				throw new IllegalArgumentException("Illegal edge direction")__		}_	};compute,a,reduce,transformation,over,the,edge,values,of,each,vertex,for,each,vertex,the,transformation,consecutively,calls,a,link,reduce,edges,function,until,only,a,single,value,for,each,edge,remains,the,link,reduce,edges,function,combines,two,edge,values,into,one,new,value,of,the,same,type,param,reduce,edges,function,the,reduce,function,to,apply,to,the,neighbors,of,each,vertex,param,direction,the,edge,direction,in,out,all,return,a,dataset,of,tuple2,with,one,tuple,per,vertex,the,first,field,of,the,tuple2,is,the,vertex,id,and,the,second,field,is,the,aggregate,value,computed,by,the,provided,link,reduce,edges,function,throws,illegal,argument,exception;public,data,set,tuple2,k,ev,reduce,on,edges,reduce,edges,function,ev,reduce,edges,function,edge,direction,direction,throws,illegal,argument,exception,switch,direction,case,in,return,edges,map,new,project,vertex,with,edge,value,map,k,ev,1,with,forwarded,fields,f1,f0,name,vertex,with,in,edges,group,by,0,reduce,new,apply,reduce,function,k,ev,reduce,edges,function,name,reduce,on,edges,case,out,return,edges,map,new,project,vertex,with,edge,value,map,k,ev,0,with,forwarded,fields,f0,f0,name,vertex,with,out,edges,group,by,0,reduce,new,apply,reduce,function,k,ev,reduce,edges,function,name,reduce,on,edges,case,all,return,edges,flat,map,new,emit,one,vertex,with,edge,value,per,node,k,ev,with,forwarded,fields,f2,f1,name,vertex,with,all,edges,group,by,0,reduce,new,apply,reduce,function,k,ev,reduce,edges,function,name,reduce,on,edges,default,throw,new,illegal,argument,exception,illegal,edge,direction
Graph -> public DataSet<Tuple2<K, EV>> reduceOnEdges(ReduceEdgesFunction<EV> reduceEdgesFunction, 			EdgeDirection direction) throws IllegalArgumentException;1502111816;Compute a reduce transformation over the edge values of each vertex._For each vertex, the transformation consecutively calls a_{@link ReduceEdgesFunction} until only a single value for each edge remains._The {@link ReduceEdgesFunction} combines two edge values into one new value of the same type.__@param reduceEdgesFunction the reduce function to apply to the neighbors of each vertex._@param direction the edge direction (in-, out-, all-)_@return a Dataset of Tuple2, with one tuple per vertex._The first field of the Tuple2 is the vertex ID and the second field_is the aggregate value computed by the provided {@link ReduceEdgesFunction}._@throws IllegalArgumentException;public DataSet<Tuple2<K, EV>> reduceOnEdges(ReduceEdgesFunction<EV> reduceEdgesFunction,_			EdgeDirection direction) throws IllegalArgumentException {__		switch (direction) {_			case IN:_				return edges.map(new ProjectVertexWithEdgeValueMap<>(1))_						.withForwardedFields("f1->f0")_							.name("Vertex with in-edges")_						.groupBy(0).reduce(new ApplyReduceFunction<>(reduceEdgesFunction))_							.name("Reduce on edges")__			case OUT:_				return edges.map(new ProjectVertexWithEdgeValueMap<>(0))_						.withForwardedFields("f0->f0")_							.name("Vertex with out-edges")_						.groupBy(0).reduce(new ApplyReduceFunction<>(reduceEdgesFunction))_							.name("Reduce on edges")__			case ALL:_				return edges.flatMap(new EmitOneVertexWithEdgeValuePerNode<>())_						.withForwardedFields("f2->f1")_							.name("Vertex with all edges")_						.groupBy(0).reduce(new ApplyReduceFunction<>(reduceEdgesFunction))_							.name("Reduce on edges")__			default:_				throw new IllegalArgumentException("Illegal edge direction")__		}_	};compute,a,reduce,transformation,over,the,edge,values,of,each,vertex,for,each,vertex,the,transformation,consecutively,calls,a,link,reduce,edges,function,until,only,a,single,value,for,each,edge,remains,the,link,reduce,edges,function,combines,two,edge,values,into,one,new,value,of,the,same,type,param,reduce,edges,function,the,reduce,function,to,apply,to,the,neighbors,of,each,vertex,param,direction,the,edge,direction,in,out,all,return,a,dataset,of,tuple2,with,one,tuple,per,vertex,the,first,field,of,the,tuple2,is,the,vertex,id,and,the,second,field,is,the,aggregate,value,computed,by,the,provided,link,reduce,edges,function,throws,illegal,argument,exception;public,data,set,tuple2,k,ev,reduce,on,edges,reduce,edges,function,ev,reduce,edges,function,edge,direction,direction,throws,illegal,argument,exception,switch,direction,case,in,return,edges,map,new,project,vertex,with,edge,value,map,1,with,forwarded,fields,f1,f0,name,vertex,with,in,edges,group,by,0,reduce,new,apply,reduce,function,reduce,edges,function,name,reduce,on,edges,case,out,return,edges,map,new,project,vertex,with,edge,value,map,0,with,forwarded,fields,f0,f0,name,vertex,with,out,edges,group,by,0,reduce,new,apply,reduce,function,reduce,edges,function,name,reduce,on,edges,case,all,return,edges,flat,map,new,emit,one,vertex,with,edge,value,per,node,with,forwarded,fields,f2,f1,name,vertex,with,all,edges,group,by,0,reduce,new,apply,reduce,function,reduce,edges,function,name,reduce,on,edges,default,throw,new,illegal,argument,exception,illegal,edge,direction
Graph -> public <M> Graph<K, VV, EV> runGatherSumApplyIteration( 			org.apache.flink.graph.gsa.GatherFunction gatherFunction, SumFunction<VV, EV, M> sumFunction, 			ApplyFunction<K, VV, M> applyFunction, int maximumNumberOfIterations, 			GSAConfiguration parameters);1467306272;Runs a Gather-Sum-Apply iteration on the graph with configuration options.__@param gatherFunction the gather function collects information about adjacent vertices and edges_@param sumFunction the sum function aggregates the gathered information_@param applyFunction the apply function updates the vertex values with the aggregates_@param maximumNumberOfIterations maximum number of iterations to perform_@param parameters the iteration configuration parameters_@param <M> the intermediate type used between gather, sum and apply__@return the updated Graph after the gather-sum-apply iteration has converged or_after maximumNumberOfIterations.;public <M> Graph<K, VV, EV> runGatherSumApplyIteration(_			org.apache.flink.graph.gsa.GatherFunction gatherFunction, SumFunction<VV, EV, M> sumFunction,_			ApplyFunction<K, VV, M> applyFunction, int maximumNumberOfIterations,_			GSAConfiguration parameters) {__		GatherSumApplyIteration<K, VV, EV, M> iteration = GatherSumApplyIteration.withEdges(_				edges, gatherFunction, sumFunction, applyFunction, maximumNumberOfIterations)___		iteration.configure(parameters)___		DataSet<Vertex<K, VV>> newVertices = vertices.runOperation(iteration)___		return new Graph<K, VV, EV>(newVertices, this.edges, this.context)__	};runs,a,gather,sum,apply,iteration,on,the,graph,with,configuration,options,param,gather,function,the,gather,function,collects,information,about,adjacent,vertices,and,edges,param,sum,function,the,sum,function,aggregates,the,gathered,information,param,apply,function,the,apply,function,updates,the,vertex,values,with,the,aggregates,param,maximum,number,of,iterations,maximum,number,of,iterations,to,perform,param,parameters,the,iteration,configuration,parameters,param,m,the,intermediate,type,used,between,gather,sum,and,apply,return,the,updated,graph,after,the,gather,sum,apply,iteration,has,converged,or,after,maximum,number,of,iterations;public,m,graph,k,vv,ev,run,gather,sum,apply,iteration,org,apache,flink,graph,gsa,gather,function,gather,function,sum,function,vv,ev,m,sum,function,apply,function,k,vv,m,apply,function,int,maximum,number,of,iterations,gsaconfiguration,parameters,gather,sum,apply,iteration,k,vv,ev,m,iteration,gather,sum,apply,iteration,with,edges,edges,gather,function,sum,function,apply,function,maximum,number,of,iterations,iteration,configure,parameters,data,set,vertex,k,vv,new,vertices,vertices,run,operation,iteration,return,new,graph,k,vv,ev,new,vertices,this,edges,this,context
Graph -> public <M> Graph<K, VV, EV> runGatherSumApplyIteration( 			org.apache.flink.graph.gsa.GatherFunction gatherFunction, SumFunction<VV, EV, M> sumFunction, 			ApplyFunction<K, VV, M> applyFunction, int maximumNumberOfIterations, 			GSAConfiguration parameters);1470042815;Runs a Gather-Sum-Apply iteration on the graph with configuration options.__@param gatherFunction the gather function collects information about adjacent vertices and edges_@param sumFunction the sum function aggregates the gathered information_@param applyFunction the apply function updates the vertex values with the aggregates_@param maximumNumberOfIterations maximum number of iterations to perform_@param parameters the iteration configuration parameters_@param <M> the intermediate type used between gather, sum and apply__@return the updated Graph after the gather-sum-apply iteration has converged or_after maximumNumberOfIterations.;public <M> Graph<K, VV, EV> runGatherSumApplyIteration(_			org.apache.flink.graph.gsa.GatherFunction gatherFunction, SumFunction<VV, EV, M> sumFunction,_			ApplyFunction<K, VV, M> applyFunction, int maximumNumberOfIterations,_			GSAConfiguration parameters) {__		GatherSumApplyIteration<K, VV, EV, M> iteration = GatherSumApplyIteration.withEdges(_				edges, gatherFunction, sumFunction, applyFunction, maximumNumberOfIterations)___		iteration.configure(parameters)___		DataSet<Vertex<K, VV>> newVertices = vertices.runOperation(iteration)___		return new Graph<K, VV, EV>(newVertices, this.edges, this.context)__	};runs,a,gather,sum,apply,iteration,on,the,graph,with,configuration,options,param,gather,function,the,gather,function,collects,information,about,adjacent,vertices,and,edges,param,sum,function,the,sum,function,aggregates,the,gathered,information,param,apply,function,the,apply,function,updates,the,vertex,values,with,the,aggregates,param,maximum,number,of,iterations,maximum,number,of,iterations,to,perform,param,parameters,the,iteration,configuration,parameters,param,m,the,intermediate,type,used,between,gather,sum,and,apply,return,the,updated,graph,after,the,gather,sum,apply,iteration,has,converged,or,after,maximum,number,of,iterations;public,m,graph,k,vv,ev,run,gather,sum,apply,iteration,org,apache,flink,graph,gsa,gather,function,gather,function,sum,function,vv,ev,m,sum,function,apply,function,k,vv,m,apply,function,int,maximum,number,of,iterations,gsaconfiguration,parameters,gather,sum,apply,iteration,k,vv,ev,m,iteration,gather,sum,apply,iteration,with,edges,edges,gather,function,sum,function,apply,function,maximum,number,of,iterations,iteration,configure,parameters,data,set,vertex,k,vv,new,vertices,vertices,run,operation,iteration,return,new,graph,k,vv,ev,new,vertices,this,edges,this,context
Graph -> public Graph<K, VV, EV> addVertex(final Vertex<K, VV> vertex);1444404795;Adds the input vertex to the graph. If the vertex already_exists in the graph, it will not be added again.__@param vertex the vertex to be added_@return the new graph containing the existing vertices as well as the one just added;public Graph<K, VV, EV> addVertex(final Vertex<K, VV> vertex) {_		List<Vertex<K, VV>> newVertex = new ArrayList<Vertex<K, VV>>()__		newVertex.add(vertex)___		return addVertices(newVertex)__	};adds,the,input,vertex,to,the,graph,if,the,vertex,already,exists,in,the,graph,it,will,not,be,added,again,param,vertex,the,vertex,to,be,added,return,the,new,graph,containing,the,existing,vertices,as,well,as,the,one,just,added;public,graph,k,vv,ev,add,vertex,final,vertex,k,vv,vertex,list,vertex,k,vv,new,vertex,new,array,list,vertex,k,vv,new,vertex,add,vertex,return,add,vertices,new,vertex
Graph -> public Graph<K, VV, EV> addVertex(final Vertex<K, VV> vertex);1445261977;Adds the input vertex to the graph. If the vertex already_exists in the graph, it will not be added again.__@param vertex the vertex to be added_@return the new graph containing the existing vertices as well as the one just added;public Graph<K, VV, EV> addVertex(final Vertex<K, VV> vertex) {_		List<Vertex<K, VV>> newVertex = new ArrayList<Vertex<K, VV>>()__		newVertex.add(vertex)___		return addVertices(newVertex)__	};adds,the,input,vertex,to,the,graph,if,the,vertex,already,exists,in,the,graph,it,will,not,be,added,again,param,vertex,the,vertex,to,be,added,return,the,new,graph,containing,the,existing,vertices,as,well,as,the,one,just,added;public,graph,k,vv,ev,add,vertex,final,vertex,k,vv,vertex,list,vertex,k,vv,new,vertex,new,array,list,vertex,k,vv,new,vertex,add,vertex,return,add,vertices,new,vertex
Graph -> public Graph<K, VV, EV> addVertex(final Vertex<K, VV> vertex);1445854323;Adds the input vertex to the graph. If the vertex already_exists in the graph, it will not be added again.__@param vertex the vertex to be added_@return the new graph containing the existing vertices as well as the one just added;public Graph<K, VV, EV> addVertex(final Vertex<K, VV> vertex) {_		List<Vertex<K, VV>> newVertex = new ArrayList<Vertex<K, VV>>()__		newVertex.add(vertex)___		return addVertices(newVertex)__	};adds,the,input,vertex,to,the,graph,if,the,vertex,already,exists,in,the,graph,it,will,not,be,added,again,param,vertex,the,vertex,to,be,added,return,the,new,graph,containing,the,existing,vertices,as,well,as,the,one,just,added;public,graph,k,vv,ev,add,vertex,final,vertex,k,vv,vertex,list,vertex,k,vv,new,vertex,new,array,list,vertex,k,vv,new,vertex,add,vertex,return,add,vertices,new,vertex
Graph -> public Graph<K, VV, EV> addVertex(final Vertex<K, VV> vertex);1446112342;Adds the input vertex to the graph. If the vertex already_exists in the graph, it will not be added again.__@param vertex the vertex to be added_@return the new graph containing the existing vertices as well as the one just added;public Graph<K, VV, EV> addVertex(final Vertex<K, VV> vertex) {_		List<Vertex<K, VV>> newVertex = new ArrayList<Vertex<K, VV>>()__		newVertex.add(vertex)___		return addVertices(newVertex)__	};adds,the,input,vertex,to,the,graph,if,the,vertex,already,exists,in,the,graph,it,will,not,be,added,again,param,vertex,the,vertex,to,be,added,return,the,new,graph,containing,the,existing,vertices,as,well,as,the,one,just,added;public,graph,k,vv,ev,add,vertex,final,vertex,k,vv,vertex,list,vertex,k,vv,new,vertex,new,array,list,vertex,k,vv,new,vertex,add,vertex,return,add,vertices,new,vertex
Graph -> public Graph<K, VV, EV> addVertex(final Vertex<K, VV> vertex);1447073368;Adds the input vertex to the graph. If the vertex already_exists in the graph, it will not be added again.__@param vertex the vertex to be added_@return the new graph containing the existing vertices as well as the one just added;public Graph<K, VV, EV> addVertex(final Vertex<K, VV> vertex) {_		List<Vertex<K, VV>> newVertex = new ArrayList<Vertex<K, VV>>()__		newVertex.add(vertex)___		return addVertices(newVertex)__	};adds,the,input,vertex,to,the,graph,if,the,vertex,already,exists,in,the,graph,it,will,not,be,added,again,param,vertex,the,vertex,to,be,added,return,the,new,graph,containing,the,existing,vertices,as,well,as,the,one,just,added;public,graph,k,vv,ev,add,vertex,final,vertex,k,vv,vertex,list,vertex,k,vv,new,vertex,new,array,list,vertex,k,vv,new,vertex,add,vertex,return,add,vertices,new,vertex
Graph -> public Graph<K, VV, EV> addVertex(final Vertex<K, VV> vertex);1454404649;Adds the input vertex to the graph. If the vertex already_exists in the graph, it will not be added again.__@param vertex the vertex to be added_@return the new graph containing the existing vertices as well as the one just added;public Graph<K, VV, EV> addVertex(final Vertex<K, VV> vertex) {_		List<Vertex<K, VV>> newVertex = new ArrayList<Vertex<K, VV>>()__		newVertex.add(vertex)___		return addVertices(newVertex)__	};adds,the,input,vertex,to,the,graph,if,the,vertex,already,exists,in,the,graph,it,will,not,be,added,again,param,vertex,the,vertex,to,be,added,return,the,new,graph,containing,the,existing,vertices,as,well,as,the,one,just,added;public,graph,k,vv,ev,add,vertex,final,vertex,k,vv,vertex,list,vertex,k,vv,new,vertex,new,array,list,vertex,k,vv,new,vertex,add,vertex,return,add,vertices,new,vertex
Graph -> public Graph<K, VV, EV> addVertex(final Vertex<K, VV> vertex);1458583829;Adds the input vertex to the graph. If the vertex already_exists in the graph, it will not be added again.__@param vertex the vertex to be added_@return the new graph containing the existing vertices as well as the one just added;public Graph<K, VV, EV> addVertex(final Vertex<K, VV> vertex) {_		List<Vertex<K, VV>> newVertex = new ArrayList<Vertex<K, VV>>()__		newVertex.add(vertex)___		return addVertices(newVertex)__	};adds,the,input,vertex,to,the,graph,if,the,vertex,already,exists,in,the,graph,it,will,not,be,added,again,param,vertex,the,vertex,to,be,added,return,the,new,graph,containing,the,existing,vertices,as,well,as,the,one,just,added;public,graph,k,vv,ev,add,vertex,final,vertex,k,vv,vertex,list,vertex,k,vv,new,vertex,new,array,list,vertex,k,vv,new,vertex,add,vertex,return,add,vertices,new,vertex
Graph -> public Graph<K, VV, EV> addVertex(final Vertex<K, VV> vertex);1458583829;Adds the input vertex to the graph. If the vertex already_exists in the graph, it will not be added again.__@param vertex the vertex to be added_@return the new graph containing the existing vertices as well as the one just added;public Graph<K, VV, EV> addVertex(final Vertex<K, VV> vertex) {_		List<Vertex<K, VV>> newVertex = new ArrayList<Vertex<K, VV>>()__		newVertex.add(vertex)___		return addVertices(newVertex)__	};adds,the,input,vertex,to,the,graph,if,the,vertex,already,exists,in,the,graph,it,will,not,be,added,again,param,vertex,the,vertex,to,be,added,return,the,new,graph,containing,the,existing,vertices,as,well,as,the,one,just,added;public,graph,k,vv,ev,add,vertex,final,vertex,k,vv,vertex,list,vertex,k,vv,new,vertex,new,array,list,vertex,k,vv,new,vertex,add,vertex,return,add,vertices,new,vertex
Graph -> public Graph<K, VV, EV> addVertex(final Vertex<K, VV> vertex);1462100316;Adds the input vertex to the graph. If the vertex already_exists in the graph, it will not be added again.__@param vertex the vertex to be added_@return the new graph containing the existing vertices as well as the one just added;public Graph<K, VV, EV> addVertex(final Vertex<K, VV> vertex) {_		List<Vertex<K, VV>> newVertex = new ArrayList<Vertex<K, VV>>()__		newVertex.add(vertex)___		return addVertices(newVertex)__	};adds,the,input,vertex,to,the,graph,if,the,vertex,already,exists,in,the,graph,it,will,not,be,added,again,param,vertex,the,vertex,to,be,added,return,the,new,graph,containing,the,existing,vertices,as,well,as,the,one,just,added;public,graph,k,vv,ev,add,vertex,final,vertex,k,vv,vertex,list,vertex,k,vv,new,vertex,new,array,list,vertex,k,vv,new,vertex,add,vertex,return,add,vertices,new,vertex
Graph -> public Graph<K, VV, EV> addVertex(final Vertex<K, VV> vertex);1462100316;Adds the input vertex to the graph. If the vertex already_exists in the graph, it will not be added again.__@param vertex the vertex to be added_@return the new graph containing the existing vertices as well as the one just added;public Graph<K, VV, EV> addVertex(final Vertex<K, VV> vertex) {_		List<Vertex<K, VV>> newVertex = new ArrayList<Vertex<K, VV>>()__		newVertex.add(vertex)___		return addVertices(newVertex)__	};adds,the,input,vertex,to,the,graph,if,the,vertex,already,exists,in,the,graph,it,will,not,be,added,again,param,vertex,the,vertex,to,be,added,return,the,new,graph,containing,the,existing,vertices,as,well,as,the,one,just,added;public,graph,k,vv,ev,add,vertex,final,vertex,k,vv,vertex,list,vertex,k,vv,new,vertex,new,array,list,vertex,k,vv,new,vertex,add,vertex,return,add,vertices,new,vertex
Graph -> public Graph<K, VV, EV> addVertex(final Vertex<K, VV> vertex);1462205213;Adds the input vertex to the graph. If the vertex already_exists in the graph, it will not be added again.__@param vertex the vertex to be added_@return the new graph containing the existing vertices as well as the one just added;public Graph<K, VV, EV> addVertex(final Vertex<K, VV> vertex) {_		List<Vertex<K, VV>> newVertex = new ArrayList<Vertex<K, VV>>()__		newVertex.add(vertex)___		return addVertices(newVertex)__	};adds,the,input,vertex,to,the,graph,if,the,vertex,already,exists,in,the,graph,it,will,not,be,added,again,param,vertex,the,vertex,to,be,added,return,the,new,graph,containing,the,existing,vertices,as,well,as,the,one,just,added;public,graph,k,vv,ev,add,vertex,final,vertex,k,vv,vertex,list,vertex,k,vv,new,vertex,new,array,list,vertex,k,vv,new,vertex,add,vertex,return,add,vertices,new,vertex
Graph -> public Graph<K, VV, EV> addVertex(final Vertex<K, VV> vertex);1462208859;Adds the input vertex to the graph. If the vertex already_exists in the graph, it will not be added again.__@param vertex the vertex to be added_@return the new graph containing the existing vertices as well as the one just added;public Graph<K, VV, EV> addVertex(final Vertex<K, VV> vertex) {_		List<Vertex<K, VV>> newVertex = new ArrayList<Vertex<K, VV>>()__		newVertex.add(vertex)___		return addVertices(newVertex)__	};adds,the,input,vertex,to,the,graph,if,the,vertex,already,exists,in,the,graph,it,will,not,be,added,again,param,vertex,the,vertex,to,be,added,return,the,new,graph,containing,the,existing,vertices,as,well,as,the,one,just,added;public,graph,k,vv,ev,add,vertex,final,vertex,k,vv,vertex,list,vertex,k,vv,new,vertex,new,array,list,vertex,k,vv,new,vertex,add,vertex,return,add,vertices,new,vertex
Graph -> public Graph<K, VV, EV> addVertex(final Vertex<K, VV> vertex);1462809297;Adds the input vertex to the graph. If the vertex already_exists in the graph, it will not be added again.__@param vertex the vertex to be added_@return the new graph containing the existing vertices as well as the one just added;public Graph<K, VV, EV> addVertex(final Vertex<K, VV> vertex) {_		List<Vertex<K, VV>> newVertex = new ArrayList<Vertex<K, VV>>()__		newVertex.add(vertex)___		return addVertices(newVertex)__	};adds,the,input,vertex,to,the,graph,if,the,vertex,already,exists,in,the,graph,it,will,not,be,added,again,param,vertex,the,vertex,to,be,added,return,the,new,graph,containing,the,existing,vertices,as,well,as,the,one,just,added;public,graph,k,vv,ev,add,vertex,final,vertex,k,vv,vertex,list,vertex,k,vv,new,vertex,new,array,list,vertex,k,vv,new,vertex,add,vertex,return,add,vertices,new,vertex
Graph -> public Graph<K, VV, EV> addVertex(final Vertex<K, VV> vertex);1465316775;Adds the input vertex to the graph. If the vertex already_exists in the graph, it will not be added again.__@param vertex the vertex to be added_@return the new graph containing the existing vertices as well as the one just added;public Graph<K, VV, EV> addVertex(final Vertex<K, VV> vertex) {_		List<Vertex<K, VV>> newVertex = new ArrayList<Vertex<K, VV>>()__		newVertex.add(vertex)___		return addVertices(newVertex)__	};adds,the,input,vertex,to,the,graph,if,the,vertex,already,exists,in,the,graph,it,will,not,be,added,again,param,vertex,the,vertex,to,be,added,return,the,new,graph,containing,the,existing,vertices,as,well,as,the,one,just,added;public,graph,k,vv,ev,add,vertex,final,vertex,k,vv,vertex,list,vertex,k,vv,new,vertex,new,array,list,vertex,k,vv,new,vertex,add,vertex,return,add,vertices,new,vertex
Graph -> public Graph<K, VV, EV> addVertex(final Vertex<K, VV> vertex);1466789678;Adds the input vertex to the graph. If the vertex already_exists in the graph, it will not be added again.__@param vertex the vertex to be added_@return the new graph containing the existing vertices as well as the one just added;public Graph<K, VV, EV> addVertex(final Vertex<K, VV> vertex) {_		List<Vertex<K, VV>> newVertex = new ArrayList<Vertex<K, VV>>()__		newVertex.add(vertex)___		return addVertices(newVertex)__	};adds,the,input,vertex,to,the,graph,if,the,vertex,already,exists,in,the,graph,it,will,not,be,added,again,param,vertex,the,vertex,to,be,added,return,the,new,graph,containing,the,existing,vertices,as,well,as,the,one,just,added;public,graph,k,vv,ev,add,vertex,final,vertex,k,vv,vertex,list,vertex,k,vv,new,vertex,new,array,list,vertex,k,vv,new,vertex,add,vertex,return,add,vertices,new,vertex
Graph -> public Graph<K, VV, EV> addVertex(final Vertex<K, VV> vertex);1467140656;Adds the input vertex to the graph. If the vertex already_exists in the graph, it will not be added again.__@param vertex the vertex to be added_@return the new graph containing the existing vertices as well as the one just added;public Graph<K, VV, EV> addVertex(final Vertex<K, VV> vertex) {_		List<Vertex<K, VV>> newVertex = new ArrayList<Vertex<K, VV>>()__		newVertex.add(vertex)___		return addVertices(newVertex)__	};adds,the,input,vertex,to,the,graph,if,the,vertex,already,exists,in,the,graph,it,will,not,be,added,again,param,vertex,the,vertex,to,be,added,return,the,new,graph,containing,the,existing,vertices,as,well,as,the,one,just,added;public,graph,k,vv,ev,add,vertex,final,vertex,k,vv,vertex,list,vertex,k,vv,new,vertex,new,array,list,vertex,k,vv,new,vertex,add,vertex,return,add,vertices,new,vertex
Graph -> public Graph<K, VV, EV> addVertex(final Vertex<K, VV> vertex);1467306272;Adds the input vertex to the graph. If the vertex already_exists in the graph, it will not be added again.__@param vertex the vertex to be added_@return the new graph containing the existing vertices as well as the one just added;public Graph<K, VV, EV> addVertex(final Vertex<K, VV> vertex) {_		List<Vertex<K, VV>> newVertex = new ArrayList<Vertex<K, VV>>()__		newVertex.add(vertex)___		return addVertices(newVertex)__	};adds,the,input,vertex,to,the,graph,if,the,vertex,already,exists,in,the,graph,it,will,not,be,added,again,param,vertex,the,vertex,to,be,added,return,the,new,graph,containing,the,existing,vertices,as,well,as,the,one,just,added;public,graph,k,vv,ev,add,vertex,final,vertex,k,vv,vertex,list,vertex,k,vv,new,vertex,new,array,list,vertex,k,vv,new,vertex,add,vertex,return,add,vertices,new,vertex
Graph -> public Graph<K, VV, EV> addVertex(final Vertex<K, VV> vertex);1470042815;Adds the input vertex to the graph. If the vertex already_exists in the graph, it will not be added again.__@param vertex the vertex to be added_@return the new graph containing the existing vertices as well as the one just added;public Graph<K, VV, EV> addVertex(final Vertex<K, VV> vertex) {_		List<Vertex<K, VV>> newVertex = new ArrayList<Vertex<K, VV>>()__		newVertex.add(vertex)___		return addVertices(newVertex)__	};adds,the,input,vertex,to,the,graph,if,the,vertex,already,exists,in,the,graph,it,will,not,be,added,again,param,vertex,the,vertex,to,be,added,return,the,new,graph,containing,the,existing,vertices,as,well,as,the,one,just,added;public,graph,k,vv,ev,add,vertex,final,vertex,k,vv,vertex,list,vertex,k,vv,new,vertex,new,array,list,vertex,k,vv,new,vertex,add,vertex,return,add,vertices,new,vertex
Graph -> public Graph<K, VV, EV> addVertex(final Vertex<K, VV> vertex);1475684776;Adds the input vertex to the graph. If the vertex already_exists in the graph, it will not be added again.__@param vertex the vertex to be added_@return the new graph containing the existing vertices as well as the one just added;public Graph<K, VV, EV> addVertex(final Vertex<K, VV> vertex) {_		List<Vertex<K, VV>> newVertex = new ArrayList<>()__		newVertex.add(vertex)___		return addVertices(newVertex)__	};adds,the,input,vertex,to,the,graph,if,the,vertex,already,exists,in,the,graph,it,will,not,be,added,again,param,vertex,the,vertex,to,be,added,return,the,new,graph,containing,the,existing,vertices,as,well,as,the,one,just,added;public,graph,k,vv,ev,add,vertex,final,vertex,k,vv,vertex,list,vertex,k,vv,new,vertex,new,array,list,new,vertex,add,vertex,return,add,vertices,new,vertex
Graph -> public Graph<K, VV, EV> addVertex(final Vertex<K, VV> vertex);1475685606;Adds the input vertex to the graph. If the vertex already_exists in the graph, it will not be added again.__@param vertex the vertex to be added_@return the new graph containing the existing vertices as well as the one just added;public Graph<K, VV, EV> addVertex(final Vertex<K, VV> vertex) {_		List<Vertex<K, VV>> newVertex = new ArrayList<>()__		newVertex.add(vertex)___		return addVertices(newVertex)__	};adds,the,input,vertex,to,the,graph,if,the,vertex,already,exists,in,the,graph,it,will,not,be,added,again,param,vertex,the,vertex,to,be,added,return,the,new,graph,containing,the,existing,vertices,as,well,as,the,one,just,added;public,graph,k,vv,ev,add,vertex,final,vertex,k,vv,vertex,list,vertex,k,vv,new,vertex,new,array,list,new,vertex,add,vertex,return,add,vertices,new,vertex
Graph -> public Graph<K, VV, EV> addVertex(final Vertex<K, VV> vertex);1481745825;Adds the input vertex to the graph. If the vertex already_exists in the graph, it will not be added again.__@param vertex the vertex to be added_@return the new graph containing the existing vertices as well as the one just added;public Graph<K, VV, EV> addVertex(final Vertex<K, VV> vertex) {_		List<Vertex<K, VV>> newVertex = new ArrayList<>()__		newVertex.add(vertex)___		return addVertices(newVertex)__	};adds,the,input,vertex,to,the,graph,if,the,vertex,already,exists,in,the,graph,it,will,not,be,added,again,param,vertex,the,vertex,to,be,added,return,the,new,graph,containing,the,existing,vertices,as,well,as,the,one,just,added;public,graph,k,vv,ev,add,vertex,final,vertex,k,vv,vertex,list,vertex,k,vv,new,vertex,new,array,list,new,vertex,add,vertex,return,add,vertices,new,vertex
Graph -> public Graph<K, VV, EV> addVertex(final Vertex<K, VV> vertex);1481881009;Adds the input vertex to the graph. If the vertex already_exists in the graph, it will not be added again.__@param vertex the vertex to be added_@return the new graph containing the existing vertices as well as the one just added;public Graph<K, VV, EV> addVertex(final Vertex<K, VV> vertex) {_		List<Vertex<K, VV>> newVertex = new ArrayList<>()__		newVertex.add(vertex)___		return addVertices(newVertex)__	};adds,the,input,vertex,to,the,graph,if,the,vertex,already,exists,in,the,graph,it,will,not,be,added,again,param,vertex,the,vertex,to,be,added,return,the,new,graph,containing,the,existing,vertices,as,well,as,the,one,just,added;public,graph,k,vv,ev,add,vertex,final,vertex,k,vv,vertex,list,vertex,k,vv,new,vertex,new,array,list,new,vertex,add,vertex,return,add,vertices,new,vertex
Graph -> public Graph<K, VV, EV> addVertex(final Vertex<K, VV> vertex);1484160227;Adds the input vertex to the graph. If the vertex already_exists in the graph, it will not be added again.__@param vertex the vertex to be added_@return the new graph containing the existing vertices as well as the one just added;public Graph<K, VV, EV> addVertex(final Vertex<K, VV> vertex) {_		List<Vertex<K, VV>> newVertex = new ArrayList<>()__		newVertex.add(vertex)___		return addVertices(newVertex)__	};adds,the,input,vertex,to,the,graph,if,the,vertex,already,exists,in,the,graph,it,will,not,be,added,again,param,vertex,the,vertex,to,be,added,return,the,new,graph,containing,the,existing,vertices,as,well,as,the,one,just,added;public,graph,k,vv,ev,add,vertex,final,vertex,k,vv,vertex,list,vertex,k,vv,new,vertex,new,array,list,new,vertex,add,vertex,return,add,vertices,new,vertex
Graph -> public Graph<K, VV, EV> addVertex(final Vertex<K, VV> vertex);1484685504;Adds the input vertex to the graph. If the vertex already_exists in the graph, it will not be added again.__@param vertex the vertex to be added_@return the new graph containing the existing vertices as well as the one just added;public Graph<K, VV, EV> addVertex(final Vertex<K, VV> vertex) {_		List<Vertex<K, VV>> newVertex = new ArrayList<>()__		newVertex.add(vertex)___		return addVertices(newVertex)__	};adds,the,input,vertex,to,the,graph,if,the,vertex,already,exists,in,the,graph,it,will,not,be,added,again,param,vertex,the,vertex,to,be,added,return,the,new,graph,containing,the,existing,vertices,as,well,as,the,one,just,added;public,graph,k,vv,ev,add,vertex,final,vertex,k,vv,vertex,list,vertex,k,vv,new,vertex,new,array,list,new,vertex,add,vertex,return,add,vertices,new,vertex
Graph -> public Graph<K, VV, EV> addVertex(final Vertex<K, VV> vertex);1489068942;Adds the input vertex to the graph. If the vertex already_exists in the graph, it will not be added again.__@param vertex the vertex to be added_@return the new graph containing the existing vertices as well as the one just added;public Graph<K, VV, EV> addVertex(final Vertex<K, VV> vertex) {_		List<Vertex<K, VV>> newVertex = new ArrayList<>()__		newVertex.add(vertex)___		return addVertices(newVertex)__	};adds,the,input,vertex,to,the,graph,if,the,vertex,already,exists,in,the,graph,it,will,not,be,added,again,param,vertex,the,vertex,to,be,added,return,the,new,graph,containing,the,existing,vertices,as,well,as,the,one,just,added;public,graph,k,vv,ev,add,vertex,final,vertex,k,vv,vertex,list,vertex,k,vv,new,vertex,new,array,list,new,vertex,add,vertex,return,add,vertices,new,vertex
Graph -> public Graph<K, VV, EV> addVertex(final Vertex<K, VV> vertex);1490973446;Adds the input vertex to the graph. If the vertex already_exists in the graph, it will not be added again.__@param vertex the vertex to be added_@return the new graph containing the existing vertices as well as the one just added;public Graph<K, VV, EV> addVertex(final Vertex<K, VV> vertex) {_		List<Vertex<K, VV>> newVertex = new ArrayList<>()__		newVertex.add(vertex)___		return addVertices(newVertex)__	};adds,the,input,vertex,to,the,graph,if,the,vertex,already,exists,in,the,graph,it,will,not,be,added,again,param,vertex,the,vertex,to,be,added,return,the,new,graph,containing,the,existing,vertices,as,well,as,the,one,just,added;public,graph,k,vv,ev,add,vertex,final,vertex,k,vv,vertex,list,vertex,k,vv,new,vertex,new,array,list,new,vertex,add,vertex,return,add,vertices,new,vertex
Graph -> public Graph<K, VV, EV> addVertex(final Vertex<K, VV> vertex);1495819075;Adds the input vertex to the graph. If the vertex already_exists in the graph, it will not be added again.__@param vertex the vertex to be added_@return the new graph containing the existing vertices as well as the one just added;public Graph<K, VV, EV> addVertex(final Vertex<K, VV> vertex) {_		List<Vertex<K, VV>> newVertex = new ArrayList<>()__		newVertex.add(vertex)___		return addVertices(newVertex)__	};adds,the,input,vertex,to,the,graph,if,the,vertex,already,exists,in,the,graph,it,will,not,be,added,again,param,vertex,the,vertex,to,be,added,return,the,new,graph,containing,the,existing,vertices,as,well,as,the,one,just,added;public,graph,k,vv,ev,add,vertex,final,vertex,k,vv,vertex,list,vertex,k,vv,new,vertex,new,array,list,new,vertex,add,vertex,return,add,vertices,new,vertex
Graph -> public Graph<K, VV, EV> addVertex(final Vertex<K, VV> vertex);1502111816;Adds the input vertex to the graph. If the vertex already_exists in the graph, it will not be added again.__@param vertex the vertex to be added_@return the new graph containing the existing vertices as well as the one just added;public Graph<K, VV, EV> addVertex(final Vertex<K, VV> vertex) {_		List<Vertex<K, VV>> newVertex = new ArrayList<>()__		newVertex.add(vertex)___		return addVertices(newVertex)__	};adds,the,input,vertex,to,the,graph,if,the,vertex,already,exists,in,the,graph,it,will,not,be,added,again,param,vertex,the,vertex,to,be,added,return,the,new,graph,containing,the,existing,vertices,as,well,as,the,one,just,added;public,graph,k,vv,ev,add,vertex,final,vertex,k,vv,vertex,list,vertex,k,vv,new,vertex,new,array,list,new,vertex,add,vertex,return,add,vertices,new,vertex
Graph -> public static <K, VV, EV> Graph<K, VV, EV> fromCollection(Collection<Edge<K, EV>> edges, 			final MapFunction<K, VV> vertexValueInitializer, ExecutionEnvironment context);1445261977;Creates a graph from a Collection of edges._Vertices are created automatically and their values are set_by applying the provided map function to the vertex IDs.__@param edges a Collection of edges._@param vertexValueInitializer a map function that initializes the vertex values._It allows to apply a map transformation on the vertex ID to produce an initial vertex value._@param context the flink execution environment._@return the newly created graph.;public static <K, VV, EV> Graph<K, VV, EV> fromCollection(Collection<Edge<K, EV>> edges,_			final MapFunction<K, VV> vertexValueInitializer, ExecutionEnvironment context) {__		return fromDataSet(context.fromCollection(edges), vertexValueInitializer, context)__	};creates,a,graph,from,a,collection,of,edges,vertices,are,created,automatically,and,their,values,are,set,by,applying,the,provided,map,function,to,the,vertex,ids,param,edges,a,collection,of,edges,param,vertex,value,initializer,a,map,function,that,initializes,the,vertex,values,it,allows,to,apply,a,map,transformation,on,the,vertex,id,to,produce,an,initial,vertex,value,param,context,the,flink,execution,environment,return,the,newly,created,graph;public,static,k,vv,ev,graph,k,vv,ev,from,collection,collection,edge,k,ev,edges,final,map,function,k,vv,vertex,value,initializer,execution,environment,context,return,from,data,set,context,from,collection,edges,vertex,value,initializer,context
Graph -> public static <K, VV, EV> Graph<K, VV, EV> fromCollection(Collection<Edge<K, EV>> edges, 			final MapFunction<K, VV> vertexValueInitializer, ExecutionEnvironment context);1445854323;Creates a graph from a Collection of edges._Vertices are created automatically and their values are set_by applying the provided map function to the vertex IDs.__@param edges a Collection of edges._@param vertexValueInitializer a map function that initializes the vertex values._It allows to apply a map transformation on the vertex ID to produce an initial vertex value._@param context the flink execution environment._@return the newly created graph.;public static <K, VV, EV> Graph<K, VV, EV> fromCollection(Collection<Edge<K, EV>> edges,_			final MapFunction<K, VV> vertexValueInitializer, ExecutionEnvironment context) {__		return fromDataSet(context.fromCollection(edges), vertexValueInitializer, context)__	};creates,a,graph,from,a,collection,of,edges,vertices,are,created,automatically,and,their,values,are,set,by,applying,the,provided,map,function,to,the,vertex,ids,param,edges,a,collection,of,edges,param,vertex,value,initializer,a,map,function,that,initializes,the,vertex,values,it,allows,to,apply,a,map,transformation,on,the,vertex,id,to,produce,an,initial,vertex,value,param,context,the,flink,execution,environment,return,the,newly,created,graph;public,static,k,vv,ev,graph,k,vv,ev,from,collection,collection,edge,k,ev,edges,final,map,function,k,vv,vertex,value,initializer,execution,environment,context,return,from,data,set,context,from,collection,edges,vertex,value,initializer,context
Graph -> public static <K, VV, EV> Graph<K, VV, EV> fromCollection(Collection<Edge<K, EV>> edges, 			final MapFunction<K, VV> vertexValueInitializer, ExecutionEnvironment context);1446112342;Creates a graph from a Collection of edges._Vertices are created automatically and their values are set_by applying the provided map function to the vertex IDs.__@param edges a Collection of edges._@param vertexValueInitializer a map function that initializes the vertex values._It allows to apply a map transformation on the vertex ID to produce an initial vertex value._@param context the flink execution environment._@return the newly created graph.;public static <K, VV, EV> Graph<K, VV, EV> fromCollection(Collection<Edge<K, EV>> edges,_			final MapFunction<K, VV> vertexValueInitializer, ExecutionEnvironment context) {__		return fromDataSet(context.fromCollection(edges), vertexValueInitializer, context)__	};creates,a,graph,from,a,collection,of,edges,vertices,are,created,automatically,and,their,values,are,set,by,applying,the,provided,map,function,to,the,vertex,ids,param,edges,a,collection,of,edges,param,vertex,value,initializer,a,map,function,that,initializes,the,vertex,values,it,allows,to,apply,a,map,transformation,on,the,vertex,id,to,produce,an,initial,vertex,value,param,context,the,flink,execution,environment,return,the,newly,created,graph;public,static,k,vv,ev,graph,k,vv,ev,from,collection,collection,edge,k,ev,edges,final,map,function,k,vv,vertex,value,initializer,execution,environment,context,return,from,data,set,context,from,collection,edges,vertex,value,initializer,context
Graph -> public static <K, VV, EV> Graph<K, VV, EV> fromCollection(Collection<Edge<K, EV>> edges, 			final MapFunction<K, VV> vertexValueInitializer, ExecutionEnvironment context);1447073368;Creates a graph from a Collection of edges._Vertices are created automatically and their values are set_by applying the provided map function to the vertex IDs.__@param edges a Collection of edges._@param vertexValueInitializer a map function that initializes the vertex values._It allows to apply a map transformation on the vertex ID to produce an initial vertex value._@param context the flink execution environment._@return the newly created graph.;public static <K, VV, EV> Graph<K, VV, EV> fromCollection(Collection<Edge<K, EV>> edges,_			final MapFunction<K, VV> vertexValueInitializer, ExecutionEnvironment context) {__		return fromDataSet(context.fromCollection(edges), vertexValueInitializer, context)__	};creates,a,graph,from,a,collection,of,edges,vertices,are,created,automatically,and,their,values,are,set,by,applying,the,provided,map,function,to,the,vertex,ids,param,edges,a,collection,of,edges,param,vertex,value,initializer,a,map,function,that,initializes,the,vertex,values,it,allows,to,apply,a,map,transformation,on,the,vertex,id,to,produce,an,initial,vertex,value,param,context,the,flink,execution,environment,return,the,newly,created,graph;public,static,k,vv,ev,graph,k,vv,ev,from,collection,collection,edge,k,ev,edges,final,map,function,k,vv,vertex,value,initializer,execution,environment,context,return,from,data,set,context,from,collection,edges,vertex,value,initializer,context
Graph -> public static <K, VV, EV> Graph<K, VV, EV> fromCollection(Collection<Edge<K, EV>> edges, 			final MapFunction<K, VV> vertexValueInitializer, ExecutionEnvironment context);1454404649;Creates a graph from a Collection of edges._Vertices are created automatically and their values are set_by applying the provided map function to the vertex IDs.__@param edges a Collection of edges._@param vertexValueInitializer a map function that initializes the vertex values._It allows to apply a map transformation on the vertex ID to produce an initial vertex value._@param context the flink execution environment._@return the newly created graph.;public static <K, VV, EV> Graph<K, VV, EV> fromCollection(Collection<Edge<K, EV>> edges,_			final MapFunction<K, VV> vertexValueInitializer, ExecutionEnvironment context) {__		return fromDataSet(context.fromCollection(edges), vertexValueInitializer, context)__	};creates,a,graph,from,a,collection,of,edges,vertices,are,created,automatically,and,their,values,are,set,by,applying,the,provided,map,function,to,the,vertex,ids,param,edges,a,collection,of,edges,param,vertex,value,initializer,a,map,function,that,initializes,the,vertex,values,it,allows,to,apply,a,map,transformation,on,the,vertex,id,to,produce,an,initial,vertex,value,param,context,the,flink,execution,environment,return,the,newly,created,graph;public,static,k,vv,ev,graph,k,vv,ev,from,collection,collection,edge,k,ev,edges,final,map,function,k,vv,vertex,value,initializer,execution,environment,context,return,from,data,set,context,from,collection,edges,vertex,value,initializer,context
Graph -> public static <K, VV, EV> Graph<K, VV, EV> fromCollection(Collection<Edge<K, EV>> edges, 			final MapFunction<K, VV> vertexValueInitializer, ExecutionEnvironment context);1458583829;Creates a graph from a Collection of edges._Vertices are created automatically and their values are set_by applying the provided map function to the vertex IDs.__@param edges a Collection of edges._@param vertexValueInitializer a map function that initializes the vertex values._It allows to apply a map transformation on the vertex ID to produce an initial vertex value._@param context the flink execution environment._@return the newly created graph.;public static <K, VV, EV> Graph<K, VV, EV> fromCollection(Collection<Edge<K, EV>> edges,_			final MapFunction<K, VV> vertexValueInitializer, ExecutionEnvironment context) {__		return fromDataSet(context.fromCollection(edges), vertexValueInitializer, context)__	};creates,a,graph,from,a,collection,of,edges,vertices,are,created,automatically,and,their,values,are,set,by,applying,the,provided,map,function,to,the,vertex,ids,param,edges,a,collection,of,edges,param,vertex,value,initializer,a,map,function,that,initializes,the,vertex,values,it,allows,to,apply,a,map,transformation,on,the,vertex,id,to,produce,an,initial,vertex,value,param,context,the,flink,execution,environment,return,the,newly,created,graph;public,static,k,vv,ev,graph,k,vv,ev,from,collection,collection,edge,k,ev,edges,final,map,function,k,vv,vertex,value,initializer,execution,environment,context,return,from,data,set,context,from,collection,edges,vertex,value,initializer,context
Graph -> public static <K, VV, EV> Graph<K, VV, EV> fromCollection(Collection<Edge<K, EV>> edges, 			final MapFunction<K, VV> vertexValueInitializer, ExecutionEnvironment context);1458583829;Creates a graph from a Collection of edges._Vertices are created automatically and their values are set_by applying the provided map function to the vertex IDs.__@param edges a Collection of edges._@param vertexValueInitializer a map function that initializes the vertex values._It allows to apply a map transformation on the vertex ID to produce an initial vertex value._@param context the flink execution environment._@return the newly created graph.;public static <K, VV, EV> Graph<K, VV, EV> fromCollection(Collection<Edge<K, EV>> edges,_			final MapFunction<K, VV> vertexValueInitializer, ExecutionEnvironment context) {__		return fromDataSet(context.fromCollection(edges), vertexValueInitializer, context)__	};creates,a,graph,from,a,collection,of,edges,vertices,are,created,automatically,and,their,values,are,set,by,applying,the,provided,map,function,to,the,vertex,ids,param,edges,a,collection,of,edges,param,vertex,value,initializer,a,map,function,that,initializes,the,vertex,values,it,allows,to,apply,a,map,transformation,on,the,vertex,id,to,produce,an,initial,vertex,value,param,context,the,flink,execution,environment,return,the,newly,created,graph;public,static,k,vv,ev,graph,k,vv,ev,from,collection,collection,edge,k,ev,edges,final,map,function,k,vv,vertex,value,initializer,execution,environment,context,return,from,data,set,context,from,collection,edges,vertex,value,initializer,context
Graph -> public static <K, VV, EV> Graph<K, VV, EV> fromCollection(Collection<Edge<K, EV>> edges, 			final MapFunction<K, VV> vertexValueInitializer, ExecutionEnvironment context);1462100316;Creates a graph from a Collection of edges._Vertices are created automatically and their values are set_by applying the provided map function to the vertex IDs.__@param edges a Collection of edges._@param vertexValueInitializer a map function that initializes the vertex values._It allows to apply a map transformation on the vertex ID to produce an initial vertex value._@param context the flink execution environment._@return the newly created graph.;public static <K, VV, EV> Graph<K, VV, EV> fromCollection(Collection<Edge<K, EV>> edges,_			final MapFunction<K, VV> vertexValueInitializer, ExecutionEnvironment context) {__		return fromDataSet(context.fromCollection(edges), vertexValueInitializer, context)__	};creates,a,graph,from,a,collection,of,edges,vertices,are,created,automatically,and,their,values,are,set,by,applying,the,provided,map,function,to,the,vertex,ids,param,edges,a,collection,of,edges,param,vertex,value,initializer,a,map,function,that,initializes,the,vertex,values,it,allows,to,apply,a,map,transformation,on,the,vertex,id,to,produce,an,initial,vertex,value,param,context,the,flink,execution,environment,return,the,newly,created,graph;public,static,k,vv,ev,graph,k,vv,ev,from,collection,collection,edge,k,ev,edges,final,map,function,k,vv,vertex,value,initializer,execution,environment,context,return,from,data,set,context,from,collection,edges,vertex,value,initializer,context
Graph -> public static <K, VV, EV> Graph<K, VV, EV> fromCollection(Collection<Edge<K, EV>> edges, 			final MapFunction<K, VV> vertexValueInitializer, ExecutionEnvironment context);1462100316;Creates a graph from a Collection of edges._Vertices are created automatically and their values are set_by applying the provided map function to the vertex IDs.__@param edges a Collection of edges._@param vertexValueInitializer a map function that initializes the vertex values._It allows to apply a map transformation on the vertex ID to produce an initial vertex value._@param context the flink execution environment._@return the newly created graph.;public static <K, VV, EV> Graph<K, VV, EV> fromCollection(Collection<Edge<K, EV>> edges,_			final MapFunction<K, VV> vertexValueInitializer, ExecutionEnvironment context) {__		return fromDataSet(context.fromCollection(edges), vertexValueInitializer, context)__	};creates,a,graph,from,a,collection,of,edges,vertices,are,created,automatically,and,their,values,are,set,by,applying,the,provided,map,function,to,the,vertex,ids,param,edges,a,collection,of,edges,param,vertex,value,initializer,a,map,function,that,initializes,the,vertex,values,it,allows,to,apply,a,map,transformation,on,the,vertex,id,to,produce,an,initial,vertex,value,param,context,the,flink,execution,environment,return,the,newly,created,graph;public,static,k,vv,ev,graph,k,vv,ev,from,collection,collection,edge,k,ev,edges,final,map,function,k,vv,vertex,value,initializer,execution,environment,context,return,from,data,set,context,from,collection,edges,vertex,value,initializer,context
Graph -> public static <K, VV, EV> Graph<K, VV, EV> fromCollection(Collection<Edge<K, EV>> edges, 			final MapFunction<K, VV> vertexValueInitializer, ExecutionEnvironment context);1462205213;Creates a graph from a Collection of edges._Vertices are created automatically and their values are set_by applying the provided map function to the vertex IDs.__@param edges a Collection of edges._@param vertexValueInitializer a map function that initializes the vertex values._It allows to apply a map transformation on the vertex ID to produce an initial vertex value._@param context the flink execution environment._@return the newly created graph.;public static <K, VV, EV> Graph<K, VV, EV> fromCollection(Collection<Edge<K, EV>> edges,_			final MapFunction<K, VV> vertexValueInitializer, ExecutionEnvironment context) {__		return fromDataSet(context.fromCollection(edges), vertexValueInitializer, context)__	};creates,a,graph,from,a,collection,of,edges,vertices,are,created,automatically,and,their,values,are,set,by,applying,the,provided,map,function,to,the,vertex,ids,param,edges,a,collection,of,edges,param,vertex,value,initializer,a,map,function,that,initializes,the,vertex,values,it,allows,to,apply,a,map,transformation,on,the,vertex,id,to,produce,an,initial,vertex,value,param,context,the,flink,execution,environment,return,the,newly,created,graph;public,static,k,vv,ev,graph,k,vv,ev,from,collection,collection,edge,k,ev,edges,final,map,function,k,vv,vertex,value,initializer,execution,environment,context,return,from,data,set,context,from,collection,edges,vertex,value,initializer,context
Graph -> public static <K, VV, EV> Graph<K, VV, EV> fromCollection(Collection<Edge<K, EV>> edges, 			final MapFunction<K, VV> vertexValueInitializer, ExecutionEnvironment context);1462208859;Creates a graph from a Collection of edges._Vertices are created automatically and their values are set_by applying the provided map function to the vertex IDs.__@param edges a Collection of edges._@param vertexValueInitializer a map function that initializes the vertex values._It allows to apply a map transformation on the vertex ID to produce an initial vertex value._@param context the flink execution environment._@return the newly created graph.;public static <K, VV, EV> Graph<K, VV, EV> fromCollection(Collection<Edge<K, EV>> edges,_			final MapFunction<K, VV> vertexValueInitializer, ExecutionEnvironment context) {__		return fromDataSet(context.fromCollection(edges), vertexValueInitializer, context)__	};creates,a,graph,from,a,collection,of,edges,vertices,are,created,automatically,and,their,values,are,set,by,applying,the,provided,map,function,to,the,vertex,ids,param,edges,a,collection,of,edges,param,vertex,value,initializer,a,map,function,that,initializes,the,vertex,values,it,allows,to,apply,a,map,transformation,on,the,vertex,id,to,produce,an,initial,vertex,value,param,context,the,flink,execution,environment,return,the,newly,created,graph;public,static,k,vv,ev,graph,k,vv,ev,from,collection,collection,edge,k,ev,edges,final,map,function,k,vv,vertex,value,initializer,execution,environment,context,return,from,data,set,context,from,collection,edges,vertex,value,initializer,context
Graph -> public static <K, VV, EV> Graph<K, VV, EV> fromCollection(Collection<Edge<K, EV>> edges, 			final MapFunction<K, VV> vertexValueInitializer, ExecutionEnvironment context);1462809297;Creates a graph from a Collection of edges._Vertices are created automatically and their values are set_by applying the provided map function to the vertex IDs.__@param edges a Collection of edges._@param vertexValueInitializer a map function that initializes the vertex values._It allows to apply a map transformation on the vertex ID to produce an initial vertex value._@param context the flink execution environment._@return the newly created graph.;public static <K, VV, EV> Graph<K, VV, EV> fromCollection(Collection<Edge<K, EV>> edges,_			final MapFunction<K, VV> vertexValueInitializer, ExecutionEnvironment context) {__		return fromDataSet(context.fromCollection(edges), vertexValueInitializer, context)__	};creates,a,graph,from,a,collection,of,edges,vertices,are,created,automatically,and,their,values,are,set,by,applying,the,provided,map,function,to,the,vertex,ids,param,edges,a,collection,of,edges,param,vertex,value,initializer,a,map,function,that,initializes,the,vertex,values,it,allows,to,apply,a,map,transformation,on,the,vertex,id,to,produce,an,initial,vertex,value,param,context,the,flink,execution,environment,return,the,newly,created,graph;public,static,k,vv,ev,graph,k,vv,ev,from,collection,collection,edge,k,ev,edges,final,map,function,k,vv,vertex,value,initializer,execution,environment,context,return,from,data,set,context,from,collection,edges,vertex,value,initializer,context
Graph -> public static <K, VV, EV> Graph<K, VV, EV> fromCollection(Collection<Edge<K, EV>> edges, 			final MapFunction<K, VV> vertexValueInitializer, ExecutionEnvironment context);1465316775;Creates a graph from a Collection of edges._Vertices are created automatically and their values are set_by applying the provided map function to the vertex IDs.__@param edges a Collection of edges._@param vertexValueInitializer a map function that initializes the vertex values._It allows to apply a map transformation on the vertex ID to produce an initial vertex value._@param context the flink execution environment._@return the newly created graph.;public static <K, VV, EV> Graph<K, VV, EV> fromCollection(Collection<Edge<K, EV>> edges,_			final MapFunction<K, VV> vertexValueInitializer, ExecutionEnvironment context) {__		return fromDataSet(context.fromCollection(edges), vertexValueInitializer, context)__	};creates,a,graph,from,a,collection,of,edges,vertices,are,created,automatically,and,their,values,are,set,by,applying,the,provided,map,function,to,the,vertex,ids,param,edges,a,collection,of,edges,param,vertex,value,initializer,a,map,function,that,initializes,the,vertex,values,it,allows,to,apply,a,map,transformation,on,the,vertex,id,to,produce,an,initial,vertex,value,param,context,the,flink,execution,environment,return,the,newly,created,graph;public,static,k,vv,ev,graph,k,vv,ev,from,collection,collection,edge,k,ev,edges,final,map,function,k,vv,vertex,value,initializer,execution,environment,context,return,from,data,set,context,from,collection,edges,vertex,value,initializer,context
Graph -> public static <K, VV, EV> Graph<K, VV, EV> fromCollection(Collection<Edge<K, EV>> edges, 			final MapFunction<K, VV> vertexValueInitializer, ExecutionEnvironment context);1466789678;Creates a graph from a Collection of edges._Vertices are created automatically and their values are set_by applying the provided map function to the vertex IDs.__@param edges a Collection of edges._@param vertexValueInitializer a map function that initializes the vertex values._It allows to apply a map transformation on the vertex ID to produce an initial vertex value._@param context the flink execution environment._@return the newly created graph.;public static <K, VV, EV> Graph<K, VV, EV> fromCollection(Collection<Edge<K, EV>> edges,_			final MapFunction<K, VV> vertexValueInitializer, ExecutionEnvironment context) {__		return fromDataSet(context.fromCollection(edges), vertexValueInitializer, context)__	};creates,a,graph,from,a,collection,of,edges,vertices,are,created,automatically,and,their,values,are,set,by,applying,the,provided,map,function,to,the,vertex,ids,param,edges,a,collection,of,edges,param,vertex,value,initializer,a,map,function,that,initializes,the,vertex,values,it,allows,to,apply,a,map,transformation,on,the,vertex,id,to,produce,an,initial,vertex,value,param,context,the,flink,execution,environment,return,the,newly,created,graph;public,static,k,vv,ev,graph,k,vv,ev,from,collection,collection,edge,k,ev,edges,final,map,function,k,vv,vertex,value,initializer,execution,environment,context,return,from,data,set,context,from,collection,edges,vertex,value,initializer,context
Graph -> public static <K, VV, EV> Graph<K, VV, EV> fromCollection(Collection<Edge<K, EV>> edges, 			final MapFunction<K, VV> vertexValueInitializer, ExecutionEnvironment context);1467140656;Creates a graph from a Collection of edges._Vertices are created automatically and their values are set_by applying the provided map function to the vertex IDs.__@param edges a Collection of edges._@param vertexValueInitializer a map function that initializes the vertex values._It allows to apply a map transformation on the vertex ID to produce an initial vertex value._@param context the flink execution environment._@return the newly created graph.;public static <K, VV, EV> Graph<K, VV, EV> fromCollection(Collection<Edge<K, EV>> edges,_			final MapFunction<K, VV> vertexValueInitializer, ExecutionEnvironment context) {__		return fromDataSet(context.fromCollection(edges), vertexValueInitializer, context)__	};creates,a,graph,from,a,collection,of,edges,vertices,are,created,automatically,and,their,values,are,set,by,applying,the,provided,map,function,to,the,vertex,ids,param,edges,a,collection,of,edges,param,vertex,value,initializer,a,map,function,that,initializes,the,vertex,values,it,allows,to,apply,a,map,transformation,on,the,vertex,id,to,produce,an,initial,vertex,value,param,context,the,flink,execution,environment,return,the,newly,created,graph;public,static,k,vv,ev,graph,k,vv,ev,from,collection,collection,edge,k,ev,edges,final,map,function,k,vv,vertex,value,initializer,execution,environment,context,return,from,data,set,context,from,collection,edges,vertex,value,initializer,context
Graph -> public static <K, VV, EV> Graph<K, VV, EV> fromCollection(Collection<Edge<K, EV>> edges, 			final MapFunction<K, VV> vertexValueInitializer, ExecutionEnvironment context);1467306272;Creates a graph from a Collection of edges._Vertices are created automatically and their values are set_by applying the provided map function to the vertex IDs.__@param edges a Collection of edges._@param vertexValueInitializer a map function that initializes the vertex values._It allows to apply a map transformation on the vertex ID to produce an initial vertex value._@param context the flink execution environment._@return the newly created graph.;public static <K, VV, EV> Graph<K, VV, EV> fromCollection(Collection<Edge<K, EV>> edges,_			final MapFunction<K, VV> vertexValueInitializer, ExecutionEnvironment context) {__		return fromDataSet(context.fromCollection(edges), vertexValueInitializer, context)__	};creates,a,graph,from,a,collection,of,edges,vertices,are,created,automatically,and,their,values,are,set,by,applying,the,provided,map,function,to,the,vertex,ids,param,edges,a,collection,of,edges,param,vertex,value,initializer,a,map,function,that,initializes,the,vertex,values,it,allows,to,apply,a,map,transformation,on,the,vertex,id,to,produce,an,initial,vertex,value,param,context,the,flink,execution,environment,return,the,newly,created,graph;public,static,k,vv,ev,graph,k,vv,ev,from,collection,collection,edge,k,ev,edges,final,map,function,k,vv,vertex,value,initializer,execution,environment,context,return,from,data,set,context,from,collection,edges,vertex,value,initializer,context
Graph -> public static <K, VV, EV> Graph<K, VV, EV> fromCollection(Collection<Edge<K, EV>> edges, 			final MapFunction<K, VV> vertexValueInitializer, ExecutionEnvironment context);1470042815;Creates a graph from a Collection of edges._Vertices are created automatically and their values are set_by applying the provided map function to the vertex IDs.__@param edges a Collection of edges._@param vertexValueInitializer a map function that initializes the vertex values._It allows to apply a map transformation on the vertex ID to produce an initial vertex value._@param context the flink execution environment._@return the newly created graph.;public static <K, VV, EV> Graph<K, VV, EV> fromCollection(Collection<Edge<K, EV>> edges,_			final MapFunction<K, VV> vertexValueInitializer, ExecutionEnvironment context) {__		return fromDataSet(context.fromCollection(edges), vertexValueInitializer, context)__	};creates,a,graph,from,a,collection,of,edges,vertices,are,created,automatically,and,their,values,are,set,by,applying,the,provided,map,function,to,the,vertex,ids,param,edges,a,collection,of,edges,param,vertex,value,initializer,a,map,function,that,initializes,the,vertex,values,it,allows,to,apply,a,map,transformation,on,the,vertex,id,to,produce,an,initial,vertex,value,param,context,the,flink,execution,environment,return,the,newly,created,graph;public,static,k,vv,ev,graph,k,vv,ev,from,collection,collection,edge,k,ev,edges,final,map,function,k,vv,vertex,value,initializer,execution,environment,context,return,from,data,set,context,from,collection,edges,vertex,value,initializer,context
Graph -> public static <K, VV, EV> Graph<K, VV, EV> fromCollection(Collection<Edge<K, EV>> edges, 			final MapFunction<K, VV> vertexValueInitializer, ExecutionEnvironment context);1475684776;Creates a graph from a Collection of edges._Vertices are created automatically and their values are set_by applying the provided map function to the vertex IDs.__@param edges a Collection of edges._@param vertexValueInitializer a map function that initializes the vertex values._It allows to apply a map transformation on the vertex ID to produce an initial vertex value._@param context the flink execution environment._@return the newly created graph.;public static <K, VV, EV> Graph<K, VV, EV> fromCollection(Collection<Edge<K, EV>> edges,_			final MapFunction<K, VV> vertexValueInitializer, ExecutionEnvironment context) {__		return fromDataSet(context.fromCollection(edges), vertexValueInitializer, context)__	};creates,a,graph,from,a,collection,of,edges,vertices,are,created,automatically,and,their,values,are,set,by,applying,the,provided,map,function,to,the,vertex,ids,param,edges,a,collection,of,edges,param,vertex,value,initializer,a,map,function,that,initializes,the,vertex,values,it,allows,to,apply,a,map,transformation,on,the,vertex,id,to,produce,an,initial,vertex,value,param,context,the,flink,execution,environment,return,the,newly,created,graph;public,static,k,vv,ev,graph,k,vv,ev,from,collection,collection,edge,k,ev,edges,final,map,function,k,vv,vertex,value,initializer,execution,environment,context,return,from,data,set,context,from,collection,edges,vertex,value,initializer,context
Graph -> public static <K, VV, EV> Graph<K, VV, EV> fromCollection(Collection<Edge<K, EV>> edges, 			final MapFunction<K, VV> vertexValueInitializer, ExecutionEnvironment context);1475685606;Creates a graph from a Collection of edges._Vertices are created automatically and their values are set_by applying the provided map function to the vertex IDs.__@param edges a Collection of edges._@param vertexValueInitializer a map function that initializes the vertex values._It allows to apply a map transformation on the vertex ID to produce an initial vertex value._@param context the flink execution environment._@return the newly created graph.;public static <K, VV, EV> Graph<K, VV, EV> fromCollection(Collection<Edge<K, EV>> edges,_			final MapFunction<K, VV> vertexValueInitializer, ExecutionEnvironment context) {__		return fromDataSet(context.fromCollection(edges), vertexValueInitializer, context)__	};creates,a,graph,from,a,collection,of,edges,vertices,are,created,automatically,and,their,values,are,set,by,applying,the,provided,map,function,to,the,vertex,ids,param,edges,a,collection,of,edges,param,vertex,value,initializer,a,map,function,that,initializes,the,vertex,values,it,allows,to,apply,a,map,transformation,on,the,vertex,id,to,produce,an,initial,vertex,value,param,context,the,flink,execution,environment,return,the,newly,created,graph;public,static,k,vv,ev,graph,k,vv,ev,from,collection,collection,edge,k,ev,edges,final,map,function,k,vv,vertex,value,initializer,execution,environment,context,return,from,data,set,context,from,collection,edges,vertex,value,initializer,context
Graph -> public static <K, VV, EV> Graph<K, VV, EV> fromCollection(Collection<Edge<K, EV>> edges, 			final MapFunction<K, VV> vertexValueInitializer, ExecutionEnvironment context);1481745825;Creates a graph from a Collection of edges._Vertices are created automatically and their values are set_by applying the provided map function to the vertex IDs.__@param edges a Collection of edges._@param vertexValueInitializer a map function that initializes the vertex values._It allows to apply a map transformation on the vertex ID to produce an initial vertex value._@param context the flink execution environment._@return the newly created graph.;public static <K, VV, EV> Graph<K, VV, EV> fromCollection(Collection<Edge<K, EV>> edges,_			final MapFunction<K, VV> vertexValueInitializer, ExecutionEnvironment context) {__		return fromDataSet(context.fromCollection(edges), vertexValueInitializer, context)__	};creates,a,graph,from,a,collection,of,edges,vertices,are,created,automatically,and,their,values,are,set,by,applying,the,provided,map,function,to,the,vertex,ids,param,edges,a,collection,of,edges,param,vertex,value,initializer,a,map,function,that,initializes,the,vertex,values,it,allows,to,apply,a,map,transformation,on,the,vertex,id,to,produce,an,initial,vertex,value,param,context,the,flink,execution,environment,return,the,newly,created,graph;public,static,k,vv,ev,graph,k,vv,ev,from,collection,collection,edge,k,ev,edges,final,map,function,k,vv,vertex,value,initializer,execution,environment,context,return,from,data,set,context,from,collection,edges,vertex,value,initializer,context
Graph -> public static <K, VV, EV> Graph<K, VV, EV> fromCollection(Collection<Edge<K, EV>> edges, 			final MapFunction<K, VV> vertexValueInitializer, ExecutionEnvironment context);1481881009;Creates a graph from a Collection of edges._Vertices are created automatically and their values are set_by applying the provided map function to the vertex IDs.__@param edges a Collection of edges._@param vertexValueInitializer a map function that initializes the vertex values._It allows to apply a map transformation on the vertex ID to produce an initial vertex value._@param context the flink execution environment._@return the newly created graph.;public static <K, VV, EV> Graph<K, VV, EV> fromCollection(Collection<Edge<K, EV>> edges,_			final MapFunction<K, VV> vertexValueInitializer, ExecutionEnvironment context) {__		return fromDataSet(context.fromCollection(edges), vertexValueInitializer, context)__	};creates,a,graph,from,a,collection,of,edges,vertices,are,created,automatically,and,their,values,are,set,by,applying,the,provided,map,function,to,the,vertex,ids,param,edges,a,collection,of,edges,param,vertex,value,initializer,a,map,function,that,initializes,the,vertex,values,it,allows,to,apply,a,map,transformation,on,the,vertex,id,to,produce,an,initial,vertex,value,param,context,the,flink,execution,environment,return,the,newly,created,graph;public,static,k,vv,ev,graph,k,vv,ev,from,collection,collection,edge,k,ev,edges,final,map,function,k,vv,vertex,value,initializer,execution,environment,context,return,from,data,set,context,from,collection,edges,vertex,value,initializer,context
Graph -> public static <K, VV, EV> Graph<K, VV, EV> fromCollection(Collection<Edge<K, EV>> edges, 			final MapFunction<K, VV> vertexValueInitializer, ExecutionEnvironment context);1484160227;Creates a graph from a Collection of edges._Vertices are created automatically and their values are set_by applying the provided map function to the vertex IDs.__@param edges a Collection of edges._@param vertexValueInitializer a map function that initializes the vertex values._It allows to apply a map transformation on the vertex ID to produce an initial vertex value._@param context the flink execution environment._@return the newly created graph.;public static <K, VV, EV> Graph<K, VV, EV> fromCollection(Collection<Edge<K, EV>> edges,_			final MapFunction<K, VV> vertexValueInitializer, ExecutionEnvironment context) {__		return fromDataSet(context.fromCollection(edges), vertexValueInitializer, context)__	};creates,a,graph,from,a,collection,of,edges,vertices,are,created,automatically,and,their,values,are,set,by,applying,the,provided,map,function,to,the,vertex,ids,param,edges,a,collection,of,edges,param,vertex,value,initializer,a,map,function,that,initializes,the,vertex,values,it,allows,to,apply,a,map,transformation,on,the,vertex,id,to,produce,an,initial,vertex,value,param,context,the,flink,execution,environment,return,the,newly,created,graph;public,static,k,vv,ev,graph,k,vv,ev,from,collection,collection,edge,k,ev,edges,final,map,function,k,vv,vertex,value,initializer,execution,environment,context,return,from,data,set,context,from,collection,edges,vertex,value,initializer,context
Graph -> public static <K, VV, EV> Graph<K, VV, EV> fromCollection(Collection<Edge<K, EV>> edges, 			final MapFunction<K, VV> vertexValueInitializer, ExecutionEnvironment context);1484685504;Creates a graph from a Collection of edges._Vertices are created automatically and their values are set_by applying the provided map function to the vertex IDs.__@param edges a Collection of edges._@param vertexValueInitializer a map function that initializes the vertex values._It allows to apply a map transformation on the vertex ID to produce an initial vertex value._@param context the flink execution environment._@return the newly created graph.;public static <K, VV, EV> Graph<K, VV, EV> fromCollection(Collection<Edge<K, EV>> edges,_			final MapFunction<K, VV> vertexValueInitializer, ExecutionEnvironment context) {__		return fromDataSet(context.fromCollection(edges), vertexValueInitializer, context)__	};creates,a,graph,from,a,collection,of,edges,vertices,are,created,automatically,and,their,values,are,set,by,applying,the,provided,map,function,to,the,vertex,ids,param,edges,a,collection,of,edges,param,vertex,value,initializer,a,map,function,that,initializes,the,vertex,values,it,allows,to,apply,a,map,transformation,on,the,vertex,id,to,produce,an,initial,vertex,value,param,context,the,flink,execution,environment,return,the,newly,created,graph;public,static,k,vv,ev,graph,k,vv,ev,from,collection,collection,edge,k,ev,edges,final,map,function,k,vv,vertex,value,initializer,execution,environment,context,return,from,data,set,context,from,collection,edges,vertex,value,initializer,context
Graph -> public static <K, VV, EV> Graph<K, VV, EV> fromCollection(Collection<Edge<K, EV>> edges, 			final MapFunction<K, VV> vertexValueInitializer, ExecutionEnvironment context);1489068942;Creates a graph from a Collection of edges._Vertices are created automatically and their values are set_by applying the provided map function to the vertex IDs.__@param edges a Collection of edges._@param vertexValueInitializer a map function that initializes the vertex values._It allows to apply a map transformation on the vertex ID to produce an initial vertex value._@param context the flink execution environment._@return the newly created graph.;public static <K, VV, EV> Graph<K, VV, EV> fromCollection(Collection<Edge<K, EV>> edges,_			final MapFunction<K, VV> vertexValueInitializer, ExecutionEnvironment context) {__		return fromDataSet(context.fromCollection(edges), vertexValueInitializer, context)__	};creates,a,graph,from,a,collection,of,edges,vertices,are,created,automatically,and,their,values,are,set,by,applying,the,provided,map,function,to,the,vertex,ids,param,edges,a,collection,of,edges,param,vertex,value,initializer,a,map,function,that,initializes,the,vertex,values,it,allows,to,apply,a,map,transformation,on,the,vertex,id,to,produce,an,initial,vertex,value,param,context,the,flink,execution,environment,return,the,newly,created,graph;public,static,k,vv,ev,graph,k,vv,ev,from,collection,collection,edge,k,ev,edges,final,map,function,k,vv,vertex,value,initializer,execution,environment,context,return,from,data,set,context,from,collection,edges,vertex,value,initializer,context
Graph -> public static <K, VV, EV> Graph<K, VV, EV> fromCollection(Collection<Edge<K, EV>> edges, 			final MapFunction<K, VV> vertexValueInitializer, ExecutionEnvironment context);1490973446;Creates a graph from a Collection of edges._Vertices are created automatically and their values are set_by applying the provided map function to the vertex IDs.__@param edges a Collection of edges._@param vertexValueInitializer a map function that initializes the vertex values._It allows to apply a map transformation on the vertex ID to produce an initial vertex value._@param context the flink execution environment._@return the newly created graph.;public static <K, VV, EV> Graph<K, VV, EV> fromCollection(Collection<Edge<K, EV>> edges,_			final MapFunction<K, VV> vertexValueInitializer, ExecutionEnvironment context) {__		return fromDataSet(context.fromCollection(edges), vertexValueInitializer, context)__	};creates,a,graph,from,a,collection,of,edges,vertices,are,created,automatically,and,their,values,are,set,by,applying,the,provided,map,function,to,the,vertex,ids,param,edges,a,collection,of,edges,param,vertex,value,initializer,a,map,function,that,initializes,the,vertex,values,it,allows,to,apply,a,map,transformation,on,the,vertex,id,to,produce,an,initial,vertex,value,param,context,the,flink,execution,environment,return,the,newly,created,graph;public,static,k,vv,ev,graph,k,vv,ev,from,collection,collection,edge,k,ev,edges,final,map,function,k,vv,vertex,value,initializer,execution,environment,context,return,from,data,set,context,from,collection,edges,vertex,value,initializer,context
Graph -> public static <K, VV, EV> Graph<K, VV, EV> fromCollection(Collection<Edge<K, EV>> edges, 			final MapFunction<K, VV> vertexValueInitializer, ExecutionEnvironment context);1495819075;Creates a graph from a Collection of edges._Vertices are created automatically and their values are set_by applying the provided map function to the vertex IDs.__@param edges a Collection of edges._@param vertexValueInitializer a map function that initializes the vertex values._It allows to apply a map transformation on the vertex ID to produce an initial vertex value._@param context the flink execution environment._@return the newly created graph.;public static <K, VV, EV> Graph<K, VV, EV> fromCollection(Collection<Edge<K, EV>> edges,_			final MapFunction<K, VV> vertexValueInitializer, ExecutionEnvironment context) {__		return fromDataSet(context.fromCollection(edges), vertexValueInitializer, context)__	};creates,a,graph,from,a,collection,of,edges,vertices,are,created,automatically,and,their,values,are,set,by,applying,the,provided,map,function,to,the,vertex,ids,param,edges,a,collection,of,edges,param,vertex,value,initializer,a,map,function,that,initializes,the,vertex,values,it,allows,to,apply,a,map,transformation,on,the,vertex,id,to,produce,an,initial,vertex,value,param,context,the,flink,execution,environment,return,the,newly,created,graph;public,static,k,vv,ev,graph,k,vv,ev,from,collection,collection,edge,k,ev,edges,final,map,function,k,vv,vertex,value,initializer,execution,environment,context,return,from,data,set,context,from,collection,edges,vertex,value,initializer,context
Graph -> public static <K, VV, EV> Graph<K, VV, EV> fromCollection(Collection<Edge<K, EV>> edges, 			final MapFunction<K, VV> vertexValueInitializer, ExecutionEnvironment context);1502111816;Creates a graph from a Collection of edges._Vertices are created automatically and their values are set_by applying the provided map function to the vertex IDs.__@param edges a Collection of edges._@param vertexValueInitializer a map function that initializes the vertex values._It allows to apply a map transformation on the vertex ID to produce an initial vertex value._@param context the flink execution environment._@return the newly created graph.;public static <K, VV, EV> Graph<K, VV, EV> fromCollection(Collection<Edge<K, EV>> edges,_			final MapFunction<K, VV> vertexValueInitializer, ExecutionEnvironment context) {__		return fromDataSet(context.fromCollection(edges), vertexValueInitializer, context)__	};creates,a,graph,from,a,collection,of,edges,vertices,are,created,automatically,and,their,values,are,set,by,applying,the,provided,map,function,to,the,vertex,ids,param,edges,a,collection,of,edges,param,vertex,value,initializer,a,map,function,that,initializes,the,vertex,values,it,allows,to,apply,a,map,transformation,on,the,vertex,id,to,produce,an,initial,vertex,value,param,context,the,flink,execution,environment,return,the,newly,created,graph;public,static,k,vv,ev,graph,k,vv,ev,from,collection,collection,edge,k,ev,edges,final,map,function,k,vv,vertex,value,initializer,execution,environment,context,return,from,data,set,context,from,collection,edges,vertex,value,initializer,context
Graph -> protected Graph(DataSet<Vertex<K, VV>> vertices, DataSet<Edge<K, EV>> edges, ExecutionEnvironment context);1484160227;Creates a graph from two DataSets: vertices and edges__@param vertices a DataSet of vertices._@param edges a DataSet of edges._@param context the flink execution environment.;protected Graph(DataSet<Vertex<K, VV>> vertices, DataSet<Edge<K, EV>> edges, ExecutionEnvironment context) {_		this.vertices = vertices__		this.edges = edges__		this.context = context__	};creates,a,graph,from,two,data,sets,vertices,and,edges,param,vertices,a,data,set,of,vertices,param,edges,a,data,set,of,edges,param,context,the,flink,execution,environment;protected,graph,data,set,vertex,k,vv,vertices,data,set,edge,k,ev,edges,execution,environment,context,this,vertices,vertices,this,edges,edges,this,context,context
Graph -> protected Graph(DataSet<Vertex<K, VV>> vertices, DataSet<Edge<K, EV>> edges, ExecutionEnvironment context);1484685504;Creates a graph from two DataSets: vertices and edges__@param vertices a DataSet of vertices._@param edges a DataSet of edges._@param context the flink execution environment.;protected Graph(DataSet<Vertex<K, VV>> vertices, DataSet<Edge<K, EV>> edges, ExecutionEnvironment context) {_		this.vertices = vertices__		this.edges = edges__		this.context = context__	};creates,a,graph,from,two,data,sets,vertices,and,edges,param,vertices,a,data,set,of,vertices,param,edges,a,data,set,of,edges,param,context,the,flink,execution,environment;protected,graph,data,set,vertex,k,vv,vertices,data,set,edge,k,ev,edges,execution,environment,context,this,vertices,vertices,this,edges,edges,this,context,context
Graph -> protected Graph(DataSet<Vertex<K, VV>> vertices, DataSet<Edge<K, EV>> edges, ExecutionEnvironment context);1489068942;Creates a graph from two DataSets: vertices and edges__@param vertices a DataSet of vertices._@param edges a DataSet of edges._@param context the flink execution environment.;protected Graph(DataSet<Vertex<K, VV>> vertices, DataSet<Edge<K, EV>> edges, ExecutionEnvironment context) {_		this.vertices = vertices__		this.edges = edges__		this.context = context__	};creates,a,graph,from,two,data,sets,vertices,and,edges,param,vertices,a,data,set,of,vertices,param,edges,a,data,set,of,edges,param,context,the,flink,execution,environment;protected,graph,data,set,vertex,k,vv,vertices,data,set,edge,k,ev,edges,execution,environment,context,this,vertices,vertices,this,edges,edges,this,context,context
Graph -> protected Graph(DataSet<Vertex<K, VV>> vertices, DataSet<Edge<K, EV>> edges, ExecutionEnvironment context);1490973446;Creates a graph from two DataSets: vertices and edges__@param vertices a DataSet of vertices._@param edges a DataSet of edges._@param context the flink execution environment.;protected Graph(DataSet<Vertex<K, VV>> vertices, DataSet<Edge<K, EV>> edges, ExecutionEnvironment context) {_		this.vertices = vertices__		this.edges = edges__		this.context = context__	};creates,a,graph,from,two,data,sets,vertices,and,edges,param,vertices,a,data,set,of,vertices,param,edges,a,data,set,of,edges,param,context,the,flink,execution,environment;protected,graph,data,set,vertex,k,vv,vertices,data,set,edge,k,ev,edges,execution,environment,context,this,vertices,vertices,this,edges,edges,this,context,context
Graph -> protected Graph(DataSet<Vertex<K, VV>> vertices, DataSet<Edge<K, EV>> edges, ExecutionEnvironment context);1495819075;Creates a graph from two DataSets: vertices and edges.__@param vertices a DataSet of vertices._@param edges a DataSet of edges._@param context the flink execution environment.;protected Graph(DataSet<Vertex<K, VV>> vertices, DataSet<Edge<K, EV>> edges, ExecutionEnvironment context) {_		this.vertices = vertices__		this.edges = edges__		this.context = context__	};creates,a,graph,from,two,data,sets,vertices,and,edges,param,vertices,a,data,set,of,vertices,param,edges,a,data,set,of,edges,param,context,the,flink,execution,environment;protected,graph,data,set,vertex,k,vv,vertices,data,set,edge,k,ev,edges,execution,environment,context,this,vertices,vertices,this,edges,edges,this,context,context
Graph -> protected Graph(DataSet<Vertex<K, VV>> vertices, DataSet<Edge<K, EV>> edges, ExecutionEnvironment context);1502111816;Creates a graph from two DataSets: vertices and edges.__@param vertices a DataSet of vertices._@param edges a DataSet of edges._@param context the flink execution environment.;protected Graph(DataSet<Vertex<K, VV>> vertices, DataSet<Edge<K, EV>> edges, ExecutionEnvironment context) {_		this.vertices = vertices__		this.edges = edges__		this.context = context__	};creates,a,graph,from,two,data,sets,vertices,and,edges,param,vertices,a,data,set,of,vertices,param,edges,a,data,set,of,edges,param,context,the,flink,execution,environment;protected,graph,data,set,vertex,k,vv,vertices,data,set,edge,k,ev,edges,execution,environment,context,this,vertices,vertices,this,edges,edges,this,context,context
Graph -> public <T> DataSet<T> groupReduceOnNeighbors(NeighborsFunction<K, VV, EV, T> neighborsFunction, 			EdgeDirection direction) throws IllegalArgumentException;1445261977;Groups by vertex and computes a GroupReduce transformation over the neighbors (both edges and vertices)_of each vertex. The neighborsFunction applied on the neighbors only has access to the vertex id_(not the vertex value) of the grouping vertex.__For each vertex, the neighborsFunction can iterate over all neighbors of this vertex_with the specified direction, and emit any number of output elements, including none.__@param neighborsFunction the group reduce function to apply to the neighboring edges and vertices_of each vertex._@param direction the edge direction (in-, out-, all-)._@param <T> the output type_@return a DataSet containing elements of type T_@throws IllegalArgumentException;public <T> DataSet<T> groupReduceOnNeighbors(NeighborsFunction<K, VV, EV, T> neighborsFunction,_			EdgeDirection direction) throws IllegalArgumentException {_		switch (direction) {_		case IN:_			_			DataSet<Tuple3<K, Edge<K, EV>, Vertex<K, VV>>> edgesWithSources = edges_					.join(this.vertices).where(0).equalTo(0)_					.with(new ProjectVertexIdJoin<K, VV, EV>(1))_					.withForwardedFieldsFirst("f1->f0")__			return edgesWithSources.groupBy(0).reduceGroup(_					new ApplyNeighborGroupReduceFunction<K, VV, EV, T>(neighborsFunction))__		case OUT:_			_			DataSet<Tuple3<K, Edge<K, EV>, Vertex<K, VV>>> edgesWithTargets = edges_					.join(this.vertices).where(1).equalTo(0)_					.with(new ProjectVertexIdJoin<K, VV, EV>(0))_					.withForwardedFieldsFirst("f0")__			return edgesWithTargets.groupBy(0).reduceGroup(_					new ApplyNeighborGroupReduceFunction<K, VV, EV, T>(neighborsFunction))__		case ALL:_			_			DataSet<Tuple3<K, Edge<K, EV>, Vertex<K, VV>>> edgesWithNeighbors = edges_					.flatMap(new EmitOneEdgeWithNeighborPerNode<K, EV>())_					.join(this.vertices).where(1).equalTo(0)_					.with(new ProjectEdgeWithNeighbor<K, VV, EV>())___			return edgesWithNeighbors.groupBy(0).reduceGroup(_					new ApplyNeighborGroupReduceFunction<K, VV, EV, T>(neighborsFunction))__		default:_			throw new IllegalArgumentException("Illegal edge direction")__		}_	};groups,by,vertex,and,computes,a,group,reduce,transformation,over,the,neighbors,both,edges,and,vertices,of,each,vertex,the,neighbors,function,applied,on,the,neighbors,only,has,access,to,the,vertex,id,not,the,vertex,value,of,the,grouping,vertex,for,each,vertex,the,neighbors,function,can,iterate,over,all,neighbors,of,this,vertex,with,the,specified,direction,and,emit,any,number,of,output,elements,including,none,param,neighbors,function,the,group,reduce,function,to,apply,to,the,neighboring,edges,and,vertices,of,each,vertex,param,direction,the,edge,direction,in,out,all,param,t,the,output,type,return,a,data,set,containing,elements,of,type,t,throws,illegal,argument,exception;public,t,data,set,t,group,reduce,on,neighbors,neighbors,function,k,vv,ev,t,neighbors,function,edge,direction,direction,throws,illegal,argument,exception,switch,direction,case,in,data,set,tuple3,k,edge,k,ev,vertex,k,vv,edges,with,sources,edges,join,this,vertices,where,0,equal,to,0,with,new,project,vertex,id,join,k,vv,ev,1,with,forwarded,fields,first,f1,f0,return,edges,with,sources,group,by,0,reduce,group,new,apply,neighbor,group,reduce,function,k,vv,ev,t,neighbors,function,case,out,data,set,tuple3,k,edge,k,ev,vertex,k,vv,edges,with,targets,edges,join,this,vertices,where,1,equal,to,0,with,new,project,vertex,id,join,k,vv,ev,0,with,forwarded,fields,first,f0,return,edges,with,targets,group,by,0,reduce,group,new,apply,neighbor,group,reduce,function,k,vv,ev,t,neighbors,function,case,all,data,set,tuple3,k,edge,k,ev,vertex,k,vv,edges,with,neighbors,edges,flat,map,new,emit,one,edge,with,neighbor,per,node,k,ev,join,this,vertices,where,1,equal,to,0,with,new,project,edge,with,neighbor,k,vv,ev,return,edges,with,neighbors,group,by,0,reduce,group,new,apply,neighbor,group,reduce,function,k,vv,ev,t,neighbors,function,default,throw,new,illegal,argument,exception,illegal,edge,direction
Graph -> public <T> DataSet<T> groupReduceOnNeighbors(NeighborsFunction<K, VV, EV, T> neighborsFunction, 			EdgeDirection direction) throws IllegalArgumentException;1445854323;Groups by vertex and computes a GroupReduce transformation over the neighbors (both edges and vertices)_of each vertex. The neighborsFunction applied on the neighbors only has access to the vertex id_(not the vertex value) of the grouping vertex.__For each vertex, the neighborsFunction can iterate over all neighbors of this vertex_with the specified direction, and emit any number of output elements, including none.__@param neighborsFunction the group reduce function to apply to the neighboring edges and vertices_of each vertex._@param direction the edge direction (in-, out-, all-)._@param <T> the output type_@return a DataSet containing elements of type T_@throws IllegalArgumentException;public <T> DataSet<T> groupReduceOnNeighbors(NeighborsFunction<K, VV, EV, T> neighborsFunction,_			EdgeDirection direction) throws IllegalArgumentException {_		switch (direction) {_		case IN:_			_			DataSet<Tuple3<K, Edge<K, EV>, Vertex<K, VV>>> edgesWithSources = edges_					.join(this.vertices).where(0).equalTo(0)_					.with(new ProjectVertexIdJoin<K, VV, EV>(1))_					.withForwardedFieldsFirst("f1->f0")__			return edgesWithSources.groupBy(0).reduceGroup(_					new ApplyNeighborGroupReduceFunction<K, VV, EV, T>(neighborsFunction))__		case OUT:_			_			DataSet<Tuple3<K, Edge<K, EV>, Vertex<K, VV>>> edgesWithTargets = edges_					.join(this.vertices).where(1).equalTo(0)_					.with(new ProjectVertexIdJoin<K, VV, EV>(0))_					.withForwardedFieldsFirst("f0")__			return edgesWithTargets.groupBy(0).reduceGroup(_					new ApplyNeighborGroupReduceFunction<K, VV, EV, T>(neighborsFunction))__		case ALL:_			_			DataSet<Tuple3<K, Edge<K, EV>, Vertex<K, VV>>> edgesWithNeighbors = edges_					.flatMap(new EmitOneEdgeWithNeighborPerNode<K, EV>())_					.join(this.vertices).where(1).equalTo(0)_					.with(new ProjectEdgeWithNeighbor<K, VV, EV>())___			return edgesWithNeighbors.groupBy(0).reduceGroup(_					new ApplyNeighborGroupReduceFunction<K, VV, EV, T>(neighborsFunction))__		default:_			throw new IllegalArgumentException("Illegal edge direction")__		}_	};groups,by,vertex,and,computes,a,group,reduce,transformation,over,the,neighbors,both,edges,and,vertices,of,each,vertex,the,neighbors,function,applied,on,the,neighbors,only,has,access,to,the,vertex,id,not,the,vertex,value,of,the,grouping,vertex,for,each,vertex,the,neighbors,function,can,iterate,over,all,neighbors,of,this,vertex,with,the,specified,direction,and,emit,any,number,of,output,elements,including,none,param,neighbors,function,the,group,reduce,function,to,apply,to,the,neighboring,edges,and,vertices,of,each,vertex,param,direction,the,edge,direction,in,out,all,param,t,the,output,type,return,a,data,set,containing,elements,of,type,t,throws,illegal,argument,exception;public,t,data,set,t,group,reduce,on,neighbors,neighbors,function,k,vv,ev,t,neighbors,function,edge,direction,direction,throws,illegal,argument,exception,switch,direction,case,in,data,set,tuple3,k,edge,k,ev,vertex,k,vv,edges,with,sources,edges,join,this,vertices,where,0,equal,to,0,with,new,project,vertex,id,join,k,vv,ev,1,with,forwarded,fields,first,f1,f0,return,edges,with,sources,group,by,0,reduce,group,new,apply,neighbor,group,reduce,function,k,vv,ev,t,neighbors,function,case,out,data,set,tuple3,k,edge,k,ev,vertex,k,vv,edges,with,targets,edges,join,this,vertices,where,1,equal,to,0,with,new,project,vertex,id,join,k,vv,ev,0,with,forwarded,fields,first,f0,return,edges,with,targets,group,by,0,reduce,group,new,apply,neighbor,group,reduce,function,k,vv,ev,t,neighbors,function,case,all,data,set,tuple3,k,edge,k,ev,vertex,k,vv,edges,with,neighbors,edges,flat,map,new,emit,one,edge,with,neighbor,per,node,k,ev,join,this,vertices,where,1,equal,to,0,with,new,project,edge,with,neighbor,k,vv,ev,return,edges,with,neighbors,group,by,0,reduce,group,new,apply,neighbor,group,reduce,function,k,vv,ev,t,neighbors,function,default,throw,new,illegal,argument,exception,illegal,edge,direction
Graph -> public <T> DataSet<T> groupReduceOnNeighbors(NeighborsFunction<K, VV, EV, T> neighborsFunction, 			EdgeDirection direction) throws IllegalArgumentException;1446112342;Groups by vertex and computes a GroupReduce transformation over the neighbors (both edges and vertices)_of each vertex. The neighborsFunction applied on the neighbors only has access to the vertex id_(not the vertex value) of the grouping vertex.__For each vertex, the neighborsFunction can iterate over all neighbors of this vertex_with the specified direction, and emit any number of output elements, including none.__@param neighborsFunction the group reduce function to apply to the neighboring edges and vertices_of each vertex._@param direction the edge direction (in-, out-, all-)._@param <T> the output type_@return a DataSet containing elements of type T_@throws IllegalArgumentException;public <T> DataSet<T> groupReduceOnNeighbors(NeighborsFunction<K, VV, EV, T> neighborsFunction,_			EdgeDirection direction) throws IllegalArgumentException {_		switch (direction) {_		case IN:_			_			DataSet<Tuple3<K, Edge<K, EV>, Vertex<K, VV>>> edgesWithSources = edges_					.join(this.vertices).where(0).equalTo(0)_					.with(new ProjectVertexIdJoin<K, VV, EV>(1))_					.withForwardedFieldsFirst("f1->f0")__			return edgesWithSources.groupBy(0).reduceGroup(_					new ApplyNeighborGroupReduceFunction<K, VV, EV, T>(neighborsFunction))__		case OUT:_			_			DataSet<Tuple3<K, Edge<K, EV>, Vertex<K, VV>>> edgesWithTargets = edges_					.join(this.vertices).where(1).equalTo(0)_					.with(new ProjectVertexIdJoin<K, VV, EV>(0))_					.withForwardedFieldsFirst("f0")__			return edgesWithTargets.groupBy(0).reduceGroup(_					new ApplyNeighborGroupReduceFunction<K, VV, EV, T>(neighborsFunction))__		case ALL:_			_			DataSet<Tuple3<K, Edge<K, EV>, Vertex<K, VV>>> edgesWithNeighbors = edges_					.flatMap(new EmitOneEdgeWithNeighborPerNode<K, EV>())_					.join(this.vertices).where(1).equalTo(0)_					.with(new ProjectEdgeWithNeighbor<K, VV, EV>())___			return edgesWithNeighbors.groupBy(0).reduceGroup(_					new ApplyNeighborGroupReduceFunction<K, VV, EV, T>(neighborsFunction))__		default:_			throw new IllegalArgumentException("Illegal edge direction")__		}_	};groups,by,vertex,and,computes,a,group,reduce,transformation,over,the,neighbors,both,edges,and,vertices,of,each,vertex,the,neighbors,function,applied,on,the,neighbors,only,has,access,to,the,vertex,id,not,the,vertex,value,of,the,grouping,vertex,for,each,vertex,the,neighbors,function,can,iterate,over,all,neighbors,of,this,vertex,with,the,specified,direction,and,emit,any,number,of,output,elements,including,none,param,neighbors,function,the,group,reduce,function,to,apply,to,the,neighboring,edges,and,vertices,of,each,vertex,param,direction,the,edge,direction,in,out,all,param,t,the,output,type,return,a,data,set,containing,elements,of,type,t,throws,illegal,argument,exception;public,t,data,set,t,group,reduce,on,neighbors,neighbors,function,k,vv,ev,t,neighbors,function,edge,direction,direction,throws,illegal,argument,exception,switch,direction,case,in,data,set,tuple3,k,edge,k,ev,vertex,k,vv,edges,with,sources,edges,join,this,vertices,where,0,equal,to,0,with,new,project,vertex,id,join,k,vv,ev,1,with,forwarded,fields,first,f1,f0,return,edges,with,sources,group,by,0,reduce,group,new,apply,neighbor,group,reduce,function,k,vv,ev,t,neighbors,function,case,out,data,set,tuple3,k,edge,k,ev,vertex,k,vv,edges,with,targets,edges,join,this,vertices,where,1,equal,to,0,with,new,project,vertex,id,join,k,vv,ev,0,with,forwarded,fields,first,f0,return,edges,with,targets,group,by,0,reduce,group,new,apply,neighbor,group,reduce,function,k,vv,ev,t,neighbors,function,case,all,data,set,tuple3,k,edge,k,ev,vertex,k,vv,edges,with,neighbors,edges,flat,map,new,emit,one,edge,with,neighbor,per,node,k,ev,join,this,vertices,where,1,equal,to,0,with,new,project,edge,with,neighbor,k,vv,ev,return,edges,with,neighbors,group,by,0,reduce,group,new,apply,neighbor,group,reduce,function,k,vv,ev,t,neighbors,function,default,throw,new,illegal,argument,exception,illegal,edge,direction
Graph -> public <T> DataSet<T> groupReduceOnNeighbors(NeighborsFunction<K, VV, EV, T> neighborsFunction, 			EdgeDirection direction) throws IllegalArgumentException;1447073368;Groups by vertex and computes a GroupReduce transformation over the neighbors (both edges and vertices)_of each vertex. The neighborsFunction applied on the neighbors only has access to the vertex id_(not the vertex value) of the grouping vertex.__For each vertex, the neighborsFunction can iterate over all neighbors of this vertex_with the specified direction, and emit any number of output elements, including none.__@param neighborsFunction the group reduce function to apply to the neighboring edges and vertices_of each vertex._@param direction the edge direction (in-, out-, all-)._@param <T> the output type_@return a DataSet containing elements of type T_@throws IllegalArgumentException;public <T> DataSet<T> groupReduceOnNeighbors(NeighborsFunction<K, VV, EV, T> neighborsFunction,_			EdgeDirection direction) throws IllegalArgumentException {_		switch (direction) {_		case IN:_			_			DataSet<Tuple3<K, Edge<K, EV>, Vertex<K, VV>>> edgesWithSources = edges_					.join(this.vertices).where(0).equalTo(0)_					.with(new ProjectVertexIdJoin<K, VV, EV>(1))_					.withForwardedFieldsFirst("f1->f0")__			return edgesWithSources.groupBy(0).reduceGroup(_					new ApplyNeighborGroupReduceFunction<K, VV, EV, T>(neighborsFunction))__		case OUT:_			_			DataSet<Tuple3<K, Edge<K, EV>, Vertex<K, VV>>> edgesWithTargets = edges_					.join(this.vertices).where(1).equalTo(0)_					.with(new ProjectVertexIdJoin<K, VV, EV>(0))_					.withForwardedFieldsFirst("f0")__			return edgesWithTargets.groupBy(0).reduceGroup(_					new ApplyNeighborGroupReduceFunction<K, VV, EV, T>(neighborsFunction))__		case ALL:_			_			DataSet<Tuple3<K, Edge<K, EV>, Vertex<K, VV>>> edgesWithNeighbors = edges_					.flatMap(new EmitOneEdgeWithNeighborPerNode<K, EV>())_					.join(this.vertices).where(1).equalTo(0)_					.with(new ProjectEdgeWithNeighbor<K, VV, EV>())___			return edgesWithNeighbors.groupBy(0).reduceGroup(_					new ApplyNeighborGroupReduceFunction<K, VV, EV, T>(neighborsFunction))__		default:_			throw new IllegalArgumentException("Illegal edge direction")__		}_	};groups,by,vertex,and,computes,a,group,reduce,transformation,over,the,neighbors,both,edges,and,vertices,of,each,vertex,the,neighbors,function,applied,on,the,neighbors,only,has,access,to,the,vertex,id,not,the,vertex,value,of,the,grouping,vertex,for,each,vertex,the,neighbors,function,can,iterate,over,all,neighbors,of,this,vertex,with,the,specified,direction,and,emit,any,number,of,output,elements,including,none,param,neighbors,function,the,group,reduce,function,to,apply,to,the,neighboring,edges,and,vertices,of,each,vertex,param,direction,the,edge,direction,in,out,all,param,t,the,output,type,return,a,data,set,containing,elements,of,type,t,throws,illegal,argument,exception;public,t,data,set,t,group,reduce,on,neighbors,neighbors,function,k,vv,ev,t,neighbors,function,edge,direction,direction,throws,illegal,argument,exception,switch,direction,case,in,data,set,tuple3,k,edge,k,ev,vertex,k,vv,edges,with,sources,edges,join,this,vertices,where,0,equal,to,0,with,new,project,vertex,id,join,k,vv,ev,1,with,forwarded,fields,first,f1,f0,return,edges,with,sources,group,by,0,reduce,group,new,apply,neighbor,group,reduce,function,k,vv,ev,t,neighbors,function,case,out,data,set,tuple3,k,edge,k,ev,vertex,k,vv,edges,with,targets,edges,join,this,vertices,where,1,equal,to,0,with,new,project,vertex,id,join,k,vv,ev,0,with,forwarded,fields,first,f0,return,edges,with,targets,group,by,0,reduce,group,new,apply,neighbor,group,reduce,function,k,vv,ev,t,neighbors,function,case,all,data,set,tuple3,k,edge,k,ev,vertex,k,vv,edges,with,neighbors,edges,flat,map,new,emit,one,edge,with,neighbor,per,node,k,ev,join,this,vertices,where,1,equal,to,0,with,new,project,edge,with,neighbor,k,vv,ev,return,edges,with,neighbors,group,by,0,reduce,group,new,apply,neighbor,group,reduce,function,k,vv,ev,t,neighbors,function,default,throw,new,illegal,argument,exception,illegal,edge,direction
Graph -> public <T> DataSet<T> groupReduceOnNeighbors(NeighborsFunction<K, VV, EV, T> neighborsFunction, 			EdgeDirection direction) throws IllegalArgumentException;1454404649;Groups by vertex and computes a GroupReduce transformation over the neighbors (both edges and vertices)_of each vertex. The neighborsFunction applied on the neighbors only has access to the vertex id_(not the vertex value) of the grouping vertex.__For each vertex, the neighborsFunction can iterate over all neighbors of this vertex_with the specified direction, and emit any number of output elements, including none.__@param neighborsFunction the group reduce function to apply to the neighboring edges and vertices_of each vertex._@param direction the edge direction (in-, out-, all-)._@param <T> the output type_@return a DataSet containing elements of type T_@throws IllegalArgumentException;public <T> DataSet<T> groupReduceOnNeighbors(NeighborsFunction<K, VV, EV, T> neighborsFunction,_			EdgeDirection direction) throws IllegalArgumentException {_		switch (direction) {_		case IN:_			_			DataSet<Tuple3<K, Edge<K, EV>, Vertex<K, VV>>> edgesWithSources = edges_					.join(this.vertices).where(0).equalTo(0)_					.with(new ProjectVertexIdJoin<K, VV, EV>(1))_					.withForwardedFieldsFirst("f1->f0")__			return edgesWithSources.groupBy(0).reduceGroup(_					new ApplyNeighborGroupReduceFunction<K, VV, EV, T>(neighborsFunction))__		case OUT:_			_			DataSet<Tuple3<K, Edge<K, EV>, Vertex<K, VV>>> edgesWithTargets = edges_					.join(this.vertices).where(1).equalTo(0)_					.with(new ProjectVertexIdJoin<K, VV, EV>(0))_					.withForwardedFieldsFirst("f0")__			return edgesWithTargets.groupBy(0).reduceGroup(_					new ApplyNeighborGroupReduceFunction<K, VV, EV, T>(neighborsFunction))__		case ALL:_			_			DataSet<Tuple3<K, Edge<K, EV>, Vertex<K, VV>>> edgesWithNeighbors = edges_					.flatMap(new EmitOneEdgeWithNeighborPerNode<K, EV>())_					.join(this.vertices).where(1).equalTo(0)_					.with(new ProjectEdgeWithNeighbor<K, VV, EV>())___			return edgesWithNeighbors.groupBy(0).reduceGroup(_					new ApplyNeighborGroupReduceFunction<K, VV, EV, T>(neighborsFunction))__		default:_			throw new IllegalArgumentException("Illegal edge direction")__		}_	};groups,by,vertex,and,computes,a,group,reduce,transformation,over,the,neighbors,both,edges,and,vertices,of,each,vertex,the,neighbors,function,applied,on,the,neighbors,only,has,access,to,the,vertex,id,not,the,vertex,value,of,the,grouping,vertex,for,each,vertex,the,neighbors,function,can,iterate,over,all,neighbors,of,this,vertex,with,the,specified,direction,and,emit,any,number,of,output,elements,including,none,param,neighbors,function,the,group,reduce,function,to,apply,to,the,neighboring,edges,and,vertices,of,each,vertex,param,direction,the,edge,direction,in,out,all,param,t,the,output,type,return,a,data,set,containing,elements,of,type,t,throws,illegal,argument,exception;public,t,data,set,t,group,reduce,on,neighbors,neighbors,function,k,vv,ev,t,neighbors,function,edge,direction,direction,throws,illegal,argument,exception,switch,direction,case,in,data,set,tuple3,k,edge,k,ev,vertex,k,vv,edges,with,sources,edges,join,this,vertices,where,0,equal,to,0,with,new,project,vertex,id,join,k,vv,ev,1,with,forwarded,fields,first,f1,f0,return,edges,with,sources,group,by,0,reduce,group,new,apply,neighbor,group,reduce,function,k,vv,ev,t,neighbors,function,case,out,data,set,tuple3,k,edge,k,ev,vertex,k,vv,edges,with,targets,edges,join,this,vertices,where,1,equal,to,0,with,new,project,vertex,id,join,k,vv,ev,0,with,forwarded,fields,first,f0,return,edges,with,targets,group,by,0,reduce,group,new,apply,neighbor,group,reduce,function,k,vv,ev,t,neighbors,function,case,all,data,set,tuple3,k,edge,k,ev,vertex,k,vv,edges,with,neighbors,edges,flat,map,new,emit,one,edge,with,neighbor,per,node,k,ev,join,this,vertices,where,1,equal,to,0,with,new,project,edge,with,neighbor,k,vv,ev,return,edges,with,neighbors,group,by,0,reduce,group,new,apply,neighbor,group,reduce,function,k,vv,ev,t,neighbors,function,default,throw,new,illegal,argument,exception,illegal,edge,direction
Graph -> public <T> DataSet<T> groupReduceOnNeighbors(NeighborsFunction<K, VV, EV, T> neighborsFunction, 			EdgeDirection direction) throws IllegalArgumentException;1458583829;Groups by vertex and computes a GroupReduce transformation over the neighbors (both edges and vertices)_of each vertex. The neighborsFunction applied on the neighbors only has access to the vertex id_(not the vertex value) of the grouping vertex.__For each vertex, the neighborsFunction can iterate over all neighbors of this vertex_with the specified direction, and emit any number of output elements, including none.__@param neighborsFunction the group reduce function to apply to the neighboring edges and vertices_of each vertex._@param direction the edge direction (in-, out-, all-)._@param <T> the output type_@return a DataSet containing elements of type T_@throws IllegalArgumentException;public <T> DataSet<T> groupReduceOnNeighbors(NeighborsFunction<K, VV, EV, T> neighborsFunction,_			EdgeDirection direction) throws IllegalArgumentException {_		switch (direction) {_		case IN:_			_			DataSet<Tuple3<K, Edge<K, EV>, Vertex<K, VV>>> edgesWithSources = edges_					.join(this.vertices).where(0).equalTo(0)_					.with(new ProjectVertexIdJoin<K, VV, EV>(1))_					.withForwardedFieldsFirst("f1->f0")__			return edgesWithSources.groupBy(0).reduceGroup(_					new ApplyNeighborGroupReduceFunction<K, VV, EV, T>(neighborsFunction))__		case OUT:_			_			DataSet<Tuple3<K, Edge<K, EV>, Vertex<K, VV>>> edgesWithTargets = edges_					.join(this.vertices).where(1).equalTo(0)_					.with(new ProjectVertexIdJoin<K, VV, EV>(0))_					.withForwardedFieldsFirst("f0")__			return edgesWithTargets.groupBy(0).reduceGroup(_					new ApplyNeighborGroupReduceFunction<K, VV, EV, T>(neighborsFunction))__		case ALL:_			_			DataSet<Tuple3<K, Edge<K, EV>, Vertex<K, VV>>> edgesWithNeighbors = edges_					.flatMap(new EmitOneEdgeWithNeighborPerNode<K, EV>())_					.join(this.vertices).where(1).equalTo(0)_					.with(new ProjectEdgeWithNeighbor<K, VV, EV>())___			return edgesWithNeighbors.groupBy(0).reduceGroup(_					new ApplyNeighborGroupReduceFunction<K, VV, EV, T>(neighborsFunction))__		default:_			throw new IllegalArgumentException("Illegal edge direction")__		}_	};groups,by,vertex,and,computes,a,group,reduce,transformation,over,the,neighbors,both,edges,and,vertices,of,each,vertex,the,neighbors,function,applied,on,the,neighbors,only,has,access,to,the,vertex,id,not,the,vertex,value,of,the,grouping,vertex,for,each,vertex,the,neighbors,function,can,iterate,over,all,neighbors,of,this,vertex,with,the,specified,direction,and,emit,any,number,of,output,elements,including,none,param,neighbors,function,the,group,reduce,function,to,apply,to,the,neighboring,edges,and,vertices,of,each,vertex,param,direction,the,edge,direction,in,out,all,param,t,the,output,type,return,a,data,set,containing,elements,of,type,t,throws,illegal,argument,exception;public,t,data,set,t,group,reduce,on,neighbors,neighbors,function,k,vv,ev,t,neighbors,function,edge,direction,direction,throws,illegal,argument,exception,switch,direction,case,in,data,set,tuple3,k,edge,k,ev,vertex,k,vv,edges,with,sources,edges,join,this,vertices,where,0,equal,to,0,with,new,project,vertex,id,join,k,vv,ev,1,with,forwarded,fields,first,f1,f0,return,edges,with,sources,group,by,0,reduce,group,new,apply,neighbor,group,reduce,function,k,vv,ev,t,neighbors,function,case,out,data,set,tuple3,k,edge,k,ev,vertex,k,vv,edges,with,targets,edges,join,this,vertices,where,1,equal,to,0,with,new,project,vertex,id,join,k,vv,ev,0,with,forwarded,fields,first,f0,return,edges,with,targets,group,by,0,reduce,group,new,apply,neighbor,group,reduce,function,k,vv,ev,t,neighbors,function,case,all,data,set,tuple3,k,edge,k,ev,vertex,k,vv,edges,with,neighbors,edges,flat,map,new,emit,one,edge,with,neighbor,per,node,k,ev,join,this,vertices,where,1,equal,to,0,with,new,project,edge,with,neighbor,k,vv,ev,return,edges,with,neighbors,group,by,0,reduce,group,new,apply,neighbor,group,reduce,function,k,vv,ev,t,neighbors,function,default,throw,new,illegal,argument,exception,illegal,edge,direction
Graph -> public <T> DataSet<T> groupReduceOnNeighbors(NeighborsFunction<K, VV, EV, T> neighborsFunction, 			EdgeDirection direction) throws IllegalArgumentException;1458583829;Groups by vertex and computes a GroupReduce transformation over the neighbors (both edges and vertices)_of each vertex. The neighborsFunction applied on the neighbors only has access to the vertex id_(not the vertex value) of the grouping vertex.__For each vertex, the neighborsFunction can iterate over all neighbors of this vertex_with the specified direction, and emit any number of output elements, including none.__@param neighborsFunction the group reduce function to apply to the neighboring edges and vertices_of each vertex._@param direction the edge direction (in-, out-, all-)._@param <T> the output type_@return a DataSet containing elements of type T_@throws IllegalArgumentException;public <T> DataSet<T> groupReduceOnNeighbors(NeighborsFunction<K, VV, EV, T> neighborsFunction,_			EdgeDirection direction) throws IllegalArgumentException {_		switch (direction) {_		case IN:_			_			DataSet<Tuple3<K, Edge<K, EV>, Vertex<K, VV>>> edgesWithSources = edges_					.join(this.vertices).where(0).equalTo(0)_					.with(new ProjectVertexIdJoin<K, VV, EV>(1))_					.withForwardedFieldsFirst("f1->f0")__			return edgesWithSources.groupBy(0).reduceGroup(_					new ApplyNeighborGroupReduceFunction<K, VV, EV, T>(neighborsFunction))__		case OUT:_			_			DataSet<Tuple3<K, Edge<K, EV>, Vertex<K, VV>>> edgesWithTargets = edges_					.join(this.vertices).where(1).equalTo(0)_					.with(new ProjectVertexIdJoin<K, VV, EV>(0))_					.withForwardedFieldsFirst("f0")__			return edgesWithTargets.groupBy(0).reduceGroup(_					new ApplyNeighborGroupReduceFunction<K, VV, EV, T>(neighborsFunction))__		case ALL:_			_			DataSet<Tuple3<K, Edge<K, EV>, Vertex<K, VV>>> edgesWithNeighbors = edges_					.flatMap(new EmitOneEdgeWithNeighborPerNode<K, EV>())_					.join(this.vertices).where(1).equalTo(0)_					.with(new ProjectEdgeWithNeighbor<K, VV, EV>())___			return edgesWithNeighbors.groupBy(0).reduceGroup(_					new ApplyNeighborGroupReduceFunction<K, VV, EV, T>(neighborsFunction))__		default:_			throw new IllegalArgumentException("Illegal edge direction")__		}_	};groups,by,vertex,and,computes,a,group,reduce,transformation,over,the,neighbors,both,edges,and,vertices,of,each,vertex,the,neighbors,function,applied,on,the,neighbors,only,has,access,to,the,vertex,id,not,the,vertex,value,of,the,grouping,vertex,for,each,vertex,the,neighbors,function,can,iterate,over,all,neighbors,of,this,vertex,with,the,specified,direction,and,emit,any,number,of,output,elements,including,none,param,neighbors,function,the,group,reduce,function,to,apply,to,the,neighboring,edges,and,vertices,of,each,vertex,param,direction,the,edge,direction,in,out,all,param,t,the,output,type,return,a,data,set,containing,elements,of,type,t,throws,illegal,argument,exception;public,t,data,set,t,group,reduce,on,neighbors,neighbors,function,k,vv,ev,t,neighbors,function,edge,direction,direction,throws,illegal,argument,exception,switch,direction,case,in,data,set,tuple3,k,edge,k,ev,vertex,k,vv,edges,with,sources,edges,join,this,vertices,where,0,equal,to,0,with,new,project,vertex,id,join,k,vv,ev,1,with,forwarded,fields,first,f1,f0,return,edges,with,sources,group,by,0,reduce,group,new,apply,neighbor,group,reduce,function,k,vv,ev,t,neighbors,function,case,out,data,set,tuple3,k,edge,k,ev,vertex,k,vv,edges,with,targets,edges,join,this,vertices,where,1,equal,to,0,with,new,project,vertex,id,join,k,vv,ev,0,with,forwarded,fields,first,f0,return,edges,with,targets,group,by,0,reduce,group,new,apply,neighbor,group,reduce,function,k,vv,ev,t,neighbors,function,case,all,data,set,tuple3,k,edge,k,ev,vertex,k,vv,edges,with,neighbors,edges,flat,map,new,emit,one,edge,with,neighbor,per,node,k,ev,join,this,vertices,where,1,equal,to,0,with,new,project,edge,with,neighbor,k,vv,ev,return,edges,with,neighbors,group,by,0,reduce,group,new,apply,neighbor,group,reduce,function,k,vv,ev,t,neighbors,function,default,throw,new,illegal,argument,exception,illegal,edge,direction
Graph -> public <T> DataSet<T> groupReduceOnNeighbors(NeighborsFunction<K, VV, EV, T> neighborsFunction, 			EdgeDirection direction) throws IllegalArgumentException;1462100316;Groups by vertex and computes a GroupReduce transformation over the neighbors (both edges and vertices)_of each vertex. The neighborsFunction applied on the neighbors only has access to the vertex id_(not the vertex value) of the grouping vertex.__For each vertex, the neighborsFunction can iterate over all neighbors of this vertex_with the specified direction, and emit any number of output elements, including none.__@param neighborsFunction the group reduce function to apply to the neighboring edges and vertices_of each vertex._@param direction the edge direction (in-, out-, all-)._@param <T> the output type_@return a DataSet containing elements of type T_@throws IllegalArgumentException;public <T> DataSet<T> groupReduceOnNeighbors(NeighborsFunction<K, VV, EV, T> neighborsFunction,_			EdgeDirection direction) throws IllegalArgumentException {_		switch (direction) {_		case IN:_			_			DataSet<Tuple3<K, Edge<K, EV>, Vertex<K, VV>>> edgesWithSources = edges_					.join(this.vertices).where(0).equalTo(0)_					.with(new ProjectVertexIdJoin<K, VV, EV>(1))_					.withForwardedFieldsFirst("f1->f0")__			return edgesWithSources.groupBy(0).reduceGroup(_					new ApplyNeighborGroupReduceFunction<K, VV, EV, T>(neighborsFunction))__		case OUT:_			_			DataSet<Tuple3<K, Edge<K, EV>, Vertex<K, VV>>> edgesWithTargets = edges_					.join(this.vertices).where(1).equalTo(0)_					.with(new ProjectVertexIdJoin<K, VV, EV>(0))_					.withForwardedFieldsFirst("f0")__			return edgesWithTargets.groupBy(0).reduceGroup(_					new ApplyNeighborGroupReduceFunction<K, VV, EV, T>(neighborsFunction))__		case ALL:_			_			DataSet<Tuple3<K, Edge<K, EV>, Vertex<K, VV>>> edgesWithNeighbors = edges_					.flatMap(new EmitOneEdgeWithNeighborPerNode<K, EV>())_					.join(this.vertices).where(1).equalTo(0)_					.with(new ProjectEdgeWithNeighbor<K, VV, EV>())___			return edgesWithNeighbors.groupBy(0).reduceGroup(_					new ApplyNeighborGroupReduceFunction<K, VV, EV, T>(neighborsFunction))__		default:_			throw new IllegalArgumentException("Illegal edge direction")__		}_	};groups,by,vertex,and,computes,a,group,reduce,transformation,over,the,neighbors,both,edges,and,vertices,of,each,vertex,the,neighbors,function,applied,on,the,neighbors,only,has,access,to,the,vertex,id,not,the,vertex,value,of,the,grouping,vertex,for,each,vertex,the,neighbors,function,can,iterate,over,all,neighbors,of,this,vertex,with,the,specified,direction,and,emit,any,number,of,output,elements,including,none,param,neighbors,function,the,group,reduce,function,to,apply,to,the,neighboring,edges,and,vertices,of,each,vertex,param,direction,the,edge,direction,in,out,all,param,t,the,output,type,return,a,data,set,containing,elements,of,type,t,throws,illegal,argument,exception;public,t,data,set,t,group,reduce,on,neighbors,neighbors,function,k,vv,ev,t,neighbors,function,edge,direction,direction,throws,illegal,argument,exception,switch,direction,case,in,data,set,tuple3,k,edge,k,ev,vertex,k,vv,edges,with,sources,edges,join,this,vertices,where,0,equal,to,0,with,new,project,vertex,id,join,k,vv,ev,1,with,forwarded,fields,first,f1,f0,return,edges,with,sources,group,by,0,reduce,group,new,apply,neighbor,group,reduce,function,k,vv,ev,t,neighbors,function,case,out,data,set,tuple3,k,edge,k,ev,vertex,k,vv,edges,with,targets,edges,join,this,vertices,where,1,equal,to,0,with,new,project,vertex,id,join,k,vv,ev,0,with,forwarded,fields,first,f0,return,edges,with,targets,group,by,0,reduce,group,new,apply,neighbor,group,reduce,function,k,vv,ev,t,neighbors,function,case,all,data,set,tuple3,k,edge,k,ev,vertex,k,vv,edges,with,neighbors,edges,flat,map,new,emit,one,edge,with,neighbor,per,node,k,ev,join,this,vertices,where,1,equal,to,0,with,new,project,edge,with,neighbor,k,vv,ev,return,edges,with,neighbors,group,by,0,reduce,group,new,apply,neighbor,group,reduce,function,k,vv,ev,t,neighbors,function,default,throw,new,illegal,argument,exception,illegal,edge,direction
Graph -> public <T> DataSet<T> groupReduceOnNeighbors(NeighborsFunction<K, VV, EV, T> neighborsFunction, 			EdgeDirection direction) throws IllegalArgumentException;1462100316;Groups by vertex and computes a GroupReduce transformation over the neighbors (both edges and vertices)_of each vertex. The neighborsFunction applied on the neighbors only has access to the vertex id_(not the vertex value) of the grouping vertex.__For each vertex, the neighborsFunction can iterate over all neighbors of this vertex_with the specified direction, and emit any number of output elements, including none.__@param neighborsFunction the group reduce function to apply to the neighboring edges and vertices_of each vertex._@param direction the edge direction (in-, out-, all-)._@param <T> the output type_@return a DataSet containing elements of type T_@throws IllegalArgumentException;public <T> DataSet<T> groupReduceOnNeighbors(NeighborsFunction<K, VV, EV, T> neighborsFunction,_			EdgeDirection direction) throws IllegalArgumentException {_		switch (direction) {_		case IN:_			_			DataSet<Tuple3<K, Edge<K, EV>, Vertex<K, VV>>> edgesWithSources = edges_					.join(this.vertices).where(0).equalTo(0)_					.with(new ProjectVertexIdJoin<K, VV, EV>(1))_					.withForwardedFieldsFirst("f1->f0")__			return edgesWithSources.groupBy(0).reduceGroup(_					new ApplyNeighborGroupReduceFunction<K, VV, EV, T>(neighborsFunction))__		case OUT:_			_			DataSet<Tuple3<K, Edge<K, EV>, Vertex<K, VV>>> edgesWithTargets = edges_					.join(this.vertices).where(1).equalTo(0)_					.with(new ProjectVertexIdJoin<K, VV, EV>(0))_					.withForwardedFieldsFirst("f0")__			return edgesWithTargets.groupBy(0).reduceGroup(_					new ApplyNeighborGroupReduceFunction<K, VV, EV, T>(neighborsFunction))__		case ALL:_			_			DataSet<Tuple3<K, Edge<K, EV>, Vertex<K, VV>>> edgesWithNeighbors = edges_					.flatMap(new EmitOneEdgeWithNeighborPerNode<K, EV>())_					.join(this.vertices).where(1).equalTo(0)_					.with(new ProjectEdgeWithNeighbor<K, VV, EV>())___			return edgesWithNeighbors.groupBy(0).reduceGroup(_					new ApplyNeighborGroupReduceFunction<K, VV, EV, T>(neighborsFunction))__		default:_			throw new IllegalArgumentException("Illegal edge direction")__		}_	};groups,by,vertex,and,computes,a,group,reduce,transformation,over,the,neighbors,both,edges,and,vertices,of,each,vertex,the,neighbors,function,applied,on,the,neighbors,only,has,access,to,the,vertex,id,not,the,vertex,value,of,the,grouping,vertex,for,each,vertex,the,neighbors,function,can,iterate,over,all,neighbors,of,this,vertex,with,the,specified,direction,and,emit,any,number,of,output,elements,including,none,param,neighbors,function,the,group,reduce,function,to,apply,to,the,neighboring,edges,and,vertices,of,each,vertex,param,direction,the,edge,direction,in,out,all,param,t,the,output,type,return,a,data,set,containing,elements,of,type,t,throws,illegal,argument,exception;public,t,data,set,t,group,reduce,on,neighbors,neighbors,function,k,vv,ev,t,neighbors,function,edge,direction,direction,throws,illegal,argument,exception,switch,direction,case,in,data,set,tuple3,k,edge,k,ev,vertex,k,vv,edges,with,sources,edges,join,this,vertices,where,0,equal,to,0,with,new,project,vertex,id,join,k,vv,ev,1,with,forwarded,fields,first,f1,f0,return,edges,with,sources,group,by,0,reduce,group,new,apply,neighbor,group,reduce,function,k,vv,ev,t,neighbors,function,case,out,data,set,tuple3,k,edge,k,ev,vertex,k,vv,edges,with,targets,edges,join,this,vertices,where,1,equal,to,0,with,new,project,vertex,id,join,k,vv,ev,0,with,forwarded,fields,first,f0,return,edges,with,targets,group,by,0,reduce,group,new,apply,neighbor,group,reduce,function,k,vv,ev,t,neighbors,function,case,all,data,set,tuple3,k,edge,k,ev,vertex,k,vv,edges,with,neighbors,edges,flat,map,new,emit,one,edge,with,neighbor,per,node,k,ev,join,this,vertices,where,1,equal,to,0,with,new,project,edge,with,neighbor,k,vv,ev,return,edges,with,neighbors,group,by,0,reduce,group,new,apply,neighbor,group,reduce,function,k,vv,ev,t,neighbors,function,default,throw,new,illegal,argument,exception,illegal,edge,direction
Graph -> public <T> DataSet<T> groupReduceOnNeighbors(NeighborsFunction<K, VV, EV, T> neighborsFunction, 			EdgeDirection direction) throws IllegalArgumentException;1462205213;Groups by vertex and computes a GroupReduce transformation over the neighbors (both edges and vertices)_of each vertex. The neighborsFunction applied on the neighbors only has access to the vertex id_(not the vertex value) of the grouping vertex.__For each vertex, the neighborsFunction can iterate over all neighbors of this vertex_with the specified direction, and emit any number of output elements, including none.__@param neighborsFunction the group reduce function to apply to the neighboring edges and vertices_of each vertex._@param direction the edge direction (in-, out-, all-)._@param <T> the output type_@return a DataSet containing elements of type T_@throws IllegalArgumentException;public <T> DataSet<T> groupReduceOnNeighbors(NeighborsFunction<K, VV, EV, T> neighborsFunction,_			EdgeDirection direction) throws IllegalArgumentException {_		switch (direction) {_		case IN:_			_			DataSet<Tuple3<K, Edge<K, EV>, Vertex<K, VV>>> edgesWithSources = edges_					.join(this.vertices).where(0).equalTo(0)_					.with(new ProjectVertexIdJoin<K, VV, EV>(1))_					.withForwardedFieldsFirst("f1->f0")__			return edgesWithSources.groupBy(0).reduceGroup(_					new ApplyNeighborGroupReduceFunction<K, VV, EV, T>(neighborsFunction))__		case OUT:_			_			DataSet<Tuple3<K, Edge<K, EV>, Vertex<K, VV>>> edgesWithTargets = edges_					.join(this.vertices).where(1).equalTo(0)_					.with(new ProjectVertexIdJoin<K, VV, EV>(0))_					.withForwardedFieldsFirst("f0")__			return edgesWithTargets.groupBy(0).reduceGroup(_					new ApplyNeighborGroupReduceFunction<K, VV, EV, T>(neighborsFunction))__		case ALL:_			_			DataSet<Tuple3<K, Edge<K, EV>, Vertex<K, VV>>> edgesWithNeighbors = edges_					.flatMap(new EmitOneEdgeWithNeighborPerNode<K, EV>())_					.join(this.vertices).where(1).equalTo(0)_					.with(new ProjectEdgeWithNeighbor<K, VV, EV>())___			return edgesWithNeighbors.groupBy(0).reduceGroup(_					new ApplyNeighborGroupReduceFunction<K, VV, EV, T>(neighborsFunction))__		default:_			throw new IllegalArgumentException("Illegal edge direction")__		}_	};groups,by,vertex,and,computes,a,group,reduce,transformation,over,the,neighbors,both,edges,and,vertices,of,each,vertex,the,neighbors,function,applied,on,the,neighbors,only,has,access,to,the,vertex,id,not,the,vertex,value,of,the,grouping,vertex,for,each,vertex,the,neighbors,function,can,iterate,over,all,neighbors,of,this,vertex,with,the,specified,direction,and,emit,any,number,of,output,elements,including,none,param,neighbors,function,the,group,reduce,function,to,apply,to,the,neighboring,edges,and,vertices,of,each,vertex,param,direction,the,edge,direction,in,out,all,param,t,the,output,type,return,a,data,set,containing,elements,of,type,t,throws,illegal,argument,exception;public,t,data,set,t,group,reduce,on,neighbors,neighbors,function,k,vv,ev,t,neighbors,function,edge,direction,direction,throws,illegal,argument,exception,switch,direction,case,in,data,set,tuple3,k,edge,k,ev,vertex,k,vv,edges,with,sources,edges,join,this,vertices,where,0,equal,to,0,with,new,project,vertex,id,join,k,vv,ev,1,with,forwarded,fields,first,f1,f0,return,edges,with,sources,group,by,0,reduce,group,new,apply,neighbor,group,reduce,function,k,vv,ev,t,neighbors,function,case,out,data,set,tuple3,k,edge,k,ev,vertex,k,vv,edges,with,targets,edges,join,this,vertices,where,1,equal,to,0,with,new,project,vertex,id,join,k,vv,ev,0,with,forwarded,fields,first,f0,return,edges,with,targets,group,by,0,reduce,group,new,apply,neighbor,group,reduce,function,k,vv,ev,t,neighbors,function,case,all,data,set,tuple3,k,edge,k,ev,vertex,k,vv,edges,with,neighbors,edges,flat,map,new,emit,one,edge,with,neighbor,per,node,k,ev,join,this,vertices,where,1,equal,to,0,with,new,project,edge,with,neighbor,k,vv,ev,return,edges,with,neighbors,group,by,0,reduce,group,new,apply,neighbor,group,reduce,function,k,vv,ev,t,neighbors,function,default,throw,new,illegal,argument,exception,illegal,edge,direction
Graph -> public <T> DataSet<T> groupReduceOnNeighbors(NeighborsFunction<K, VV, EV, T> neighborsFunction, 			EdgeDirection direction) throws IllegalArgumentException;1462208859;Groups by vertex and computes a GroupReduce transformation over the neighbors (both edges and vertices)_of each vertex. The neighborsFunction applied on the neighbors only has access to the vertex id_(not the vertex value) of the grouping vertex.__For each vertex, the neighborsFunction can iterate over all neighbors of this vertex_with the specified direction, and emit any number of output elements, including none.__@param neighborsFunction the group reduce function to apply to the neighboring edges and vertices_of each vertex._@param direction the edge direction (in-, out-, all-)._@param <T> the output type_@return a DataSet containing elements of type T_@throws IllegalArgumentException;public <T> DataSet<T> groupReduceOnNeighbors(NeighborsFunction<K, VV, EV, T> neighborsFunction,_			EdgeDirection direction) throws IllegalArgumentException {_		switch (direction) {_		case IN:_			_			DataSet<Tuple3<K, Edge<K, EV>, Vertex<K, VV>>> edgesWithSources = edges_					.join(this.vertices).where(0).equalTo(0)_					.with(new ProjectVertexIdJoin<K, VV, EV>(1))_					.withForwardedFieldsFirst("f1->f0")__			return edgesWithSources.groupBy(0).reduceGroup(_					new ApplyNeighborGroupReduceFunction<K, VV, EV, T>(neighborsFunction))__		case OUT:_			_			DataSet<Tuple3<K, Edge<K, EV>, Vertex<K, VV>>> edgesWithTargets = edges_					.join(this.vertices).where(1).equalTo(0)_					.with(new ProjectVertexIdJoin<K, VV, EV>(0))_					.withForwardedFieldsFirst("f0")__			return edgesWithTargets.groupBy(0).reduceGroup(_					new ApplyNeighborGroupReduceFunction<K, VV, EV, T>(neighborsFunction))__		case ALL:_			_			DataSet<Tuple3<K, Edge<K, EV>, Vertex<K, VV>>> edgesWithNeighbors = edges_					.flatMap(new EmitOneEdgeWithNeighborPerNode<K, EV>())_					.join(this.vertices).where(1).equalTo(0)_					.with(new ProjectEdgeWithNeighbor<K, VV, EV>())___			return edgesWithNeighbors.groupBy(0).reduceGroup(_					new ApplyNeighborGroupReduceFunction<K, VV, EV, T>(neighborsFunction))__		default:_			throw new IllegalArgumentException("Illegal edge direction")__		}_	};groups,by,vertex,and,computes,a,group,reduce,transformation,over,the,neighbors,both,edges,and,vertices,of,each,vertex,the,neighbors,function,applied,on,the,neighbors,only,has,access,to,the,vertex,id,not,the,vertex,value,of,the,grouping,vertex,for,each,vertex,the,neighbors,function,can,iterate,over,all,neighbors,of,this,vertex,with,the,specified,direction,and,emit,any,number,of,output,elements,including,none,param,neighbors,function,the,group,reduce,function,to,apply,to,the,neighboring,edges,and,vertices,of,each,vertex,param,direction,the,edge,direction,in,out,all,param,t,the,output,type,return,a,data,set,containing,elements,of,type,t,throws,illegal,argument,exception;public,t,data,set,t,group,reduce,on,neighbors,neighbors,function,k,vv,ev,t,neighbors,function,edge,direction,direction,throws,illegal,argument,exception,switch,direction,case,in,data,set,tuple3,k,edge,k,ev,vertex,k,vv,edges,with,sources,edges,join,this,vertices,where,0,equal,to,0,with,new,project,vertex,id,join,k,vv,ev,1,with,forwarded,fields,first,f1,f0,return,edges,with,sources,group,by,0,reduce,group,new,apply,neighbor,group,reduce,function,k,vv,ev,t,neighbors,function,case,out,data,set,tuple3,k,edge,k,ev,vertex,k,vv,edges,with,targets,edges,join,this,vertices,where,1,equal,to,0,with,new,project,vertex,id,join,k,vv,ev,0,with,forwarded,fields,first,f0,return,edges,with,targets,group,by,0,reduce,group,new,apply,neighbor,group,reduce,function,k,vv,ev,t,neighbors,function,case,all,data,set,tuple3,k,edge,k,ev,vertex,k,vv,edges,with,neighbors,edges,flat,map,new,emit,one,edge,with,neighbor,per,node,k,ev,join,this,vertices,where,1,equal,to,0,with,new,project,edge,with,neighbor,k,vv,ev,return,edges,with,neighbors,group,by,0,reduce,group,new,apply,neighbor,group,reduce,function,k,vv,ev,t,neighbors,function,default,throw,new,illegal,argument,exception,illegal,edge,direction
Graph -> public <T> DataSet<T> groupReduceOnNeighbors(NeighborsFunction<K, VV, EV, T> neighborsFunction, 			EdgeDirection direction) throws IllegalArgumentException;1462809297;Groups by vertex and computes a GroupReduce transformation over the neighbors (both edges and vertices)_of each vertex. The neighborsFunction applied on the neighbors only has access to the vertex id_(not the vertex value) of the grouping vertex.__For each vertex, the neighborsFunction can iterate over all neighbors of this vertex_with the specified direction, and emit any number of output elements, including none.__@param neighborsFunction the group reduce function to apply to the neighboring edges and vertices_of each vertex._@param direction the edge direction (in-, out-, all-)._@param <T> the output type_@return a DataSet containing elements of type T_@throws IllegalArgumentException;public <T> DataSet<T> groupReduceOnNeighbors(NeighborsFunction<K, VV, EV, T> neighborsFunction,_			EdgeDirection direction) throws IllegalArgumentException {_		switch (direction) {_		case IN:_			_			DataSet<Tuple3<K, Edge<K, EV>, Vertex<K, VV>>> edgesWithSources = edges_					.join(this.vertices).where(0).equalTo(0)_					.with(new ProjectVertexIdJoin<K, VV, EV>(1))_					.withForwardedFieldsFirst("f1->f0")__			return edgesWithSources.groupBy(0).reduceGroup(_					new ApplyNeighborGroupReduceFunction<K, VV, EV, T>(neighborsFunction))__		case OUT:_			_			DataSet<Tuple3<K, Edge<K, EV>, Vertex<K, VV>>> edgesWithTargets = edges_					.join(this.vertices).where(1).equalTo(0)_					.with(new ProjectVertexIdJoin<K, VV, EV>(0))_					.withForwardedFieldsFirst("f0")__			return edgesWithTargets.groupBy(0).reduceGroup(_					new ApplyNeighborGroupReduceFunction<K, VV, EV, T>(neighborsFunction))__		case ALL:_			_			DataSet<Tuple3<K, Edge<K, EV>, Vertex<K, VV>>> edgesWithNeighbors = edges_					.flatMap(new EmitOneEdgeWithNeighborPerNode<K, EV>())_					.join(this.vertices).where(1).equalTo(0)_					.with(new ProjectEdgeWithNeighbor<K, VV, EV>())___			return edgesWithNeighbors.groupBy(0).reduceGroup(_					new ApplyNeighborGroupReduceFunction<K, VV, EV, T>(neighborsFunction))__		default:_			throw new IllegalArgumentException("Illegal edge direction")__		}_	};groups,by,vertex,and,computes,a,group,reduce,transformation,over,the,neighbors,both,edges,and,vertices,of,each,vertex,the,neighbors,function,applied,on,the,neighbors,only,has,access,to,the,vertex,id,not,the,vertex,value,of,the,grouping,vertex,for,each,vertex,the,neighbors,function,can,iterate,over,all,neighbors,of,this,vertex,with,the,specified,direction,and,emit,any,number,of,output,elements,including,none,param,neighbors,function,the,group,reduce,function,to,apply,to,the,neighboring,edges,and,vertices,of,each,vertex,param,direction,the,edge,direction,in,out,all,param,t,the,output,type,return,a,data,set,containing,elements,of,type,t,throws,illegal,argument,exception;public,t,data,set,t,group,reduce,on,neighbors,neighbors,function,k,vv,ev,t,neighbors,function,edge,direction,direction,throws,illegal,argument,exception,switch,direction,case,in,data,set,tuple3,k,edge,k,ev,vertex,k,vv,edges,with,sources,edges,join,this,vertices,where,0,equal,to,0,with,new,project,vertex,id,join,k,vv,ev,1,with,forwarded,fields,first,f1,f0,return,edges,with,sources,group,by,0,reduce,group,new,apply,neighbor,group,reduce,function,k,vv,ev,t,neighbors,function,case,out,data,set,tuple3,k,edge,k,ev,vertex,k,vv,edges,with,targets,edges,join,this,vertices,where,1,equal,to,0,with,new,project,vertex,id,join,k,vv,ev,0,with,forwarded,fields,first,f0,return,edges,with,targets,group,by,0,reduce,group,new,apply,neighbor,group,reduce,function,k,vv,ev,t,neighbors,function,case,all,data,set,tuple3,k,edge,k,ev,vertex,k,vv,edges,with,neighbors,edges,flat,map,new,emit,one,edge,with,neighbor,per,node,k,ev,join,this,vertices,where,1,equal,to,0,with,new,project,edge,with,neighbor,k,vv,ev,return,edges,with,neighbors,group,by,0,reduce,group,new,apply,neighbor,group,reduce,function,k,vv,ev,t,neighbors,function,default,throw,new,illegal,argument,exception,illegal,edge,direction
Graph -> public <T> DataSet<T> groupReduceOnNeighbors(NeighborsFunction<K, VV, EV, T> neighborsFunction, 			EdgeDirection direction) throws IllegalArgumentException;1465316775;Groups by vertex and computes a GroupReduce transformation over the neighbors (both edges and vertices)_of each vertex. The neighborsFunction applied on the neighbors only has access to the vertex id_(not the vertex value) of the grouping vertex.__For each vertex, the neighborsFunction can iterate over all neighbors of this vertex_with the specified direction, and emit any number of output elements, including none.__@param neighborsFunction the group reduce function to apply to the neighboring edges and vertices_of each vertex._@param direction the edge direction (in-, out-, all-)._@param <T> the output type_@return a DataSet containing elements of type T_@throws IllegalArgumentException;public <T> DataSet<T> groupReduceOnNeighbors(NeighborsFunction<K, VV, EV, T> neighborsFunction,_			EdgeDirection direction) throws IllegalArgumentException {_		switch (direction) {_		case IN:_			_			DataSet<Tuple3<K, Edge<K, EV>, Vertex<K, VV>>> edgesWithSources = edges_					.join(this.vertices).where(0).equalTo(0)_					.with(new ProjectVertexIdJoin<K, VV, EV>(1))_					.withForwardedFieldsFirst("f1->f0")__			return edgesWithSources.groupBy(0).reduceGroup(_					new ApplyNeighborGroupReduceFunction<K, VV, EV, T>(neighborsFunction))__		case OUT:_			_			DataSet<Tuple3<K, Edge<K, EV>, Vertex<K, VV>>> edgesWithTargets = edges_					.join(this.vertices).where(1).equalTo(0)_					.with(new ProjectVertexIdJoin<K, VV, EV>(0))_					.withForwardedFieldsFirst("f0")__			return edgesWithTargets.groupBy(0).reduceGroup(_					new ApplyNeighborGroupReduceFunction<K, VV, EV, T>(neighborsFunction))__		case ALL:_			_			DataSet<Tuple3<K, Edge<K, EV>, Vertex<K, VV>>> edgesWithNeighbors = edges_					.flatMap(new EmitOneEdgeWithNeighborPerNode<K, EV>())_					.join(this.vertices).where(1).equalTo(0)_					.with(new ProjectEdgeWithNeighbor<K, VV, EV>())___			return edgesWithNeighbors.groupBy(0).reduceGroup(_					new ApplyNeighborGroupReduceFunction<K, VV, EV, T>(neighborsFunction))__		default:_			throw new IllegalArgumentException("Illegal edge direction")__		}_	};groups,by,vertex,and,computes,a,group,reduce,transformation,over,the,neighbors,both,edges,and,vertices,of,each,vertex,the,neighbors,function,applied,on,the,neighbors,only,has,access,to,the,vertex,id,not,the,vertex,value,of,the,grouping,vertex,for,each,vertex,the,neighbors,function,can,iterate,over,all,neighbors,of,this,vertex,with,the,specified,direction,and,emit,any,number,of,output,elements,including,none,param,neighbors,function,the,group,reduce,function,to,apply,to,the,neighboring,edges,and,vertices,of,each,vertex,param,direction,the,edge,direction,in,out,all,param,t,the,output,type,return,a,data,set,containing,elements,of,type,t,throws,illegal,argument,exception;public,t,data,set,t,group,reduce,on,neighbors,neighbors,function,k,vv,ev,t,neighbors,function,edge,direction,direction,throws,illegal,argument,exception,switch,direction,case,in,data,set,tuple3,k,edge,k,ev,vertex,k,vv,edges,with,sources,edges,join,this,vertices,where,0,equal,to,0,with,new,project,vertex,id,join,k,vv,ev,1,with,forwarded,fields,first,f1,f0,return,edges,with,sources,group,by,0,reduce,group,new,apply,neighbor,group,reduce,function,k,vv,ev,t,neighbors,function,case,out,data,set,tuple3,k,edge,k,ev,vertex,k,vv,edges,with,targets,edges,join,this,vertices,where,1,equal,to,0,with,new,project,vertex,id,join,k,vv,ev,0,with,forwarded,fields,first,f0,return,edges,with,targets,group,by,0,reduce,group,new,apply,neighbor,group,reduce,function,k,vv,ev,t,neighbors,function,case,all,data,set,tuple3,k,edge,k,ev,vertex,k,vv,edges,with,neighbors,edges,flat,map,new,emit,one,edge,with,neighbor,per,node,k,ev,join,this,vertices,where,1,equal,to,0,with,new,project,edge,with,neighbor,k,vv,ev,return,edges,with,neighbors,group,by,0,reduce,group,new,apply,neighbor,group,reduce,function,k,vv,ev,t,neighbors,function,default,throw,new,illegal,argument,exception,illegal,edge,direction
Graph -> public <T> DataSet<T> groupReduceOnNeighbors(NeighborsFunction<K, VV, EV, T> neighborsFunction, 			EdgeDirection direction) throws IllegalArgumentException;1466789678;Groups by vertex and computes a GroupReduce transformation over the neighbors (both edges and vertices)_of each vertex. The neighborsFunction applied on the neighbors only has access to the vertex id_(not the vertex value) of the grouping vertex.__For each vertex, the neighborsFunction can iterate over all neighbors of this vertex_with the specified direction, and emit any number of output elements, including none.__@param neighborsFunction the group reduce function to apply to the neighboring edges and vertices_of each vertex._@param direction the edge direction (in-, out-, all-)._@param <T> the output type_@return a DataSet containing elements of type T_@throws IllegalArgumentException;public <T> DataSet<T> groupReduceOnNeighbors(NeighborsFunction<K, VV, EV, T> neighborsFunction,_			EdgeDirection direction) throws IllegalArgumentException {_		switch (direction) {_		case IN:_			_			DataSet<Tuple3<K, Edge<K, EV>, Vertex<K, VV>>> edgesWithSources = edges_					.join(this.vertices).where(0).equalTo(0)_					.with(new ProjectVertexIdJoin<K, VV, EV>(1))_					.withForwardedFieldsFirst("f1->f0")__			return edgesWithSources.groupBy(0).reduceGroup(_					new ApplyNeighborGroupReduceFunction<K, VV, EV, T>(neighborsFunction))__		case OUT:_			_			DataSet<Tuple3<K, Edge<K, EV>, Vertex<K, VV>>> edgesWithTargets = edges_					.join(this.vertices).where(1).equalTo(0)_					.with(new ProjectVertexIdJoin<K, VV, EV>(0))_					.withForwardedFieldsFirst("f0")__			return edgesWithTargets.groupBy(0).reduceGroup(_					new ApplyNeighborGroupReduceFunction<K, VV, EV, T>(neighborsFunction))__		case ALL:_			_			DataSet<Tuple3<K, Edge<K, EV>, Vertex<K, VV>>> edgesWithNeighbors = edges_					.flatMap(new EmitOneEdgeWithNeighborPerNode<K, EV>())_					.join(this.vertices).where(1).equalTo(0)_					.with(new ProjectEdgeWithNeighbor<K, VV, EV>())___			return edgesWithNeighbors.groupBy(0).reduceGroup(_					new ApplyNeighborGroupReduceFunction<K, VV, EV, T>(neighborsFunction))__		default:_			throw new IllegalArgumentException("Illegal edge direction")__		}_	};groups,by,vertex,and,computes,a,group,reduce,transformation,over,the,neighbors,both,edges,and,vertices,of,each,vertex,the,neighbors,function,applied,on,the,neighbors,only,has,access,to,the,vertex,id,not,the,vertex,value,of,the,grouping,vertex,for,each,vertex,the,neighbors,function,can,iterate,over,all,neighbors,of,this,vertex,with,the,specified,direction,and,emit,any,number,of,output,elements,including,none,param,neighbors,function,the,group,reduce,function,to,apply,to,the,neighboring,edges,and,vertices,of,each,vertex,param,direction,the,edge,direction,in,out,all,param,t,the,output,type,return,a,data,set,containing,elements,of,type,t,throws,illegal,argument,exception;public,t,data,set,t,group,reduce,on,neighbors,neighbors,function,k,vv,ev,t,neighbors,function,edge,direction,direction,throws,illegal,argument,exception,switch,direction,case,in,data,set,tuple3,k,edge,k,ev,vertex,k,vv,edges,with,sources,edges,join,this,vertices,where,0,equal,to,0,with,new,project,vertex,id,join,k,vv,ev,1,with,forwarded,fields,first,f1,f0,return,edges,with,sources,group,by,0,reduce,group,new,apply,neighbor,group,reduce,function,k,vv,ev,t,neighbors,function,case,out,data,set,tuple3,k,edge,k,ev,vertex,k,vv,edges,with,targets,edges,join,this,vertices,where,1,equal,to,0,with,new,project,vertex,id,join,k,vv,ev,0,with,forwarded,fields,first,f0,return,edges,with,targets,group,by,0,reduce,group,new,apply,neighbor,group,reduce,function,k,vv,ev,t,neighbors,function,case,all,data,set,tuple3,k,edge,k,ev,vertex,k,vv,edges,with,neighbors,edges,flat,map,new,emit,one,edge,with,neighbor,per,node,k,ev,join,this,vertices,where,1,equal,to,0,with,new,project,edge,with,neighbor,k,vv,ev,return,edges,with,neighbors,group,by,0,reduce,group,new,apply,neighbor,group,reduce,function,k,vv,ev,t,neighbors,function,default,throw,new,illegal,argument,exception,illegal,edge,direction
Graph -> public <T> DataSet<T> groupReduceOnNeighbors(NeighborsFunction<K, VV, EV, T> neighborsFunction, 			EdgeDirection direction) throws IllegalArgumentException;1467140656;Groups by vertex and computes a GroupReduce transformation over the neighbors (both edges and vertices)_of each vertex. The neighborsFunction applied on the neighbors only has access to the vertex id_(not the vertex value) of the grouping vertex.__For each vertex, the neighborsFunction can iterate over all neighbors of this vertex_with the specified direction, and emit any number of output elements, including none.__@param neighborsFunction the group reduce function to apply to the neighboring edges and vertices_of each vertex._@param direction the edge direction (in-, out-, all-)._@param <T> the output type_@return a DataSet containing elements of type T_@throws IllegalArgumentException;public <T> DataSet<T> groupReduceOnNeighbors(NeighborsFunction<K, VV, EV, T> neighborsFunction,_			EdgeDirection direction) throws IllegalArgumentException {_		switch (direction) {_		case IN:_			_			DataSet<Tuple3<K, Edge<K, EV>, Vertex<K, VV>>> edgesWithSources = edges_					.join(this.vertices).where(0).equalTo(0)_					.with(new ProjectVertexIdJoin<K, VV, EV>(1))_					.withForwardedFieldsFirst("f1->f0")__			return edgesWithSources.groupBy(0).reduceGroup(_					new ApplyNeighborGroupReduceFunction<K, VV, EV, T>(neighborsFunction))__		case OUT:_			_			DataSet<Tuple3<K, Edge<K, EV>, Vertex<K, VV>>> edgesWithTargets = edges_					.join(this.vertices).where(1).equalTo(0)_					.with(new ProjectVertexIdJoin<K, VV, EV>(0))_					.withForwardedFieldsFirst("f0")__			return edgesWithTargets.groupBy(0).reduceGroup(_					new ApplyNeighborGroupReduceFunction<K, VV, EV, T>(neighborsFunction))__		case ALL:_			_			DataSet<Tuple3<K, Edge<K, EV>, Vertex<K, VV>>> edgesWithNeighbors = edges_					.flatMap(new EmitOneEdgeWithNeighborPerNode<K, EV>())_					.join(this.vertices).where(1).equalTo(0)_					.with(new ProjectEdgeWithNeighbor<K, VV, EV>())___			return edgesWithNeighbors.groupBy(0).reduceGroup(_					new ApplyNeighborGroupReduceFunction<K, VV, EV, T>(neighborsFunction))__		default:_			throw new IllegalArgumentException("Illegal edge direction")__		}_	};groups,by,vertex,and,computes,a,group,reduce,transformation,over,the,neighbors,both,edges,and,vertices,of,each,vertex,the,neighbors,function,applied,on,the,neighbors,only,has,access,to,the,vertex,id,not,the,vertex,value,of,the,grouping,vertex,for,each,vertex,the,neighbors,function,can,iterate,over,all,neighbors,of,this,vertex,with,the,specified,direction,and,emit,any,number,of,output,elements,including,none,param,neighbors,function,the,group,reduce,function,to,apply,to,the,neighboring,edges,and,vertices,of,each,vertex,param,direction,the,edge,direction,in,out,all,param,t,the,output,type,return,a,data,set,containing,elements,of,type,t,throws,illegal,argument,exception;public,t,data,set,t,group,reduce,on,neighbors,neighbors,function,k,vv,ev,t,neighbors,function,edge,direction,direction,throws,illegal,argument,exception,switch,direction,case,in,data,set,tuple3,k,edge,k,ev,vertex,k,vv,edges,with,sources,edges,join,this,vertices,where,0,equal,to,0,with,new,project,vertex,id,join,k,vv,ev,1,with,forwarded,fields,first,f1,f0,return,edges,with,sources,group,by,0,reduce,group,new,apply,neighbor,group,reduce,function,k,vv,ev,t,neighbors,function,case,out,data,set,tuple3,k,edge,k,ev,vertex,k,vv,edges,with,targets,edges,join,this,vertices,where,1,equal,to,0,with,new,project,vertex,id,join,k,vv,ev,0,with,forwarded,fields,first,f0,return,edges,with,targets,group,by,0,reduce,group,new,apply,neighbor,group,reduce,function,k,vv,ev,t,neighbors,function,case,all,data,set,tuple3,k,edge,k,ev,vertex,k,vv,edges,with,neighbors,edges,flat,map,new,emit,one,edge,with,neighbor,per,node,k,ev,join,this,vertices,where,1,equal,to,0,with,new,project,edge,with,neighbor,k,vv,ev,return,edges,with,neighbors,group,by,0,reduce,group,new,apply,neighbor,group,reduce,function,k,vv,ev,t,neighbors,function,default,throw,new,illegal,argument,exception,illegal,edge,direction
Graph -> public <T> DataSet<T> groupReduceOnNeighbors(NeighborsFunction<K, VV, EV, T> neighborsFunction, 			EdgeDirection direction) throws IllegalArgumentException;1467306272;Groups by vertex and computes a GroupReduce transformation over the neighbors (both edges and vertices)_of each vertex. The neighborsFunction applied on the neighbors only has access to the vertex id_(not the vertex value) of the grouping vertex.__For each vertex, the neighborsFunction can iterate over all neighbors of this vertex_with the specified direction, and emit any number of output elements, including none.__@param neighborsFunction the group reduce function to apply to the neighboring edges and vertices_of each vertex._@param direction the edge direction (in-, out-, all-)._@param <T> the output type_@return a DataSet containing elements of type T_@throws IllegalArgumentException;public <T> DataSet<T> groupReduceOnNeighbors(NeighborsFunction<K, VV, EV, T> neighborsFunction,_			EdgeDirection direction) throws IllegalArgumentException {_		switch (direction) {_		case IN:_			_			DataSet<Tuple3<K, Edge<K, EV>, Vertex<K, VV>>> edgesWithSources = edges_					.join(this.vertices).where(0).equalTo(0)_					.with(new ProjectVertexIdJoin<K, VV, EV>(1))_					.withForwardedFieldsFirst("f1->f0")__			return edgesWithSources.groupBy(0).reduceGroup(_					new ApplyNeighborGroupReduceFunction<K, VV, EV, T>(neighborsFunction))__		case OUT:_			_			DataSet<Tuple3<K, Edge<K, EV>, Vertex<K, VV>>> edgesWithTargets = edges_					.join(this.vertices).where(1).equalTo(0)_					.with(new ProjectVertexIdJoin<K, VV, EV>(0))_					.withForwardedFieldsFirst("f0")__			return edgesWithTargets.groupBy(0).reduceGroup(_					new ApplyNeighborGroupReduceFunction<K, VV, EV, T>(neighborsFunction))__		case ALL:_			_			DataSet<Tuple3<K, Edge<K, EV>, Vertex<K, VV>>> edgesWithNeighbors = edges_					.flatMap(new EmitOneEdgeWithNeighborPerNode<K, EV>())_					.join(this.vertices).where(1).equalTo(0)_					.with(new ProjectEdgeWithNeighbor<K, VV, EV>())___			return edgesWithNeighbors.groupBy(0).reduceGroup(_					new ApplyNeighborGroupReduceFunction<K, VV, EV, T>(neighborsFunction))__		default:_			throw new IllegalArgumentException("Illegal edge direction")__		}_	};groups,by,vertex,and,computes,a,group,reduce,transformation,over,the,neighbors,both,edges,and,vertices,of,each,vertex,the,neighbors,function,applied,on,the,neighbors,only,has,access,to,the,vertex,id,not,the,vertex,value,of,the,grouping,vertex,for,each,vertex,the,neighbors,function,can,iterate,over,all,neighbors,of,this,vertex,with,the,specified,direction,and,emit,any,number,of,output,elements,including,none,param,neighbors,function,the,group,reduce,function,to,apply,to,the,neighboring,edges,and,vertices,of,each,vertex,param,direction,the,edge,direction,in,out,all,param,t,the,output,type,return,a,data,set,containing,elements,of,type,t,throws,illegal,argument,exception;public,t,data,set,t,group,reduce,on,neighbors,neighbors,function,k,vv,ev,t,neighbors,function,edge,direction,direction,throws,illegal,argument,exception,switch,direction,case,in,data,set,tuple3,k,edge,k,ev,vertex,k,vv,edges,with,sources,edges,join,this,vertices,where,0,equal,to,0,with,new,project,vertex,id,join,k,vv,ev,1,with,forwarded,fields,first,f1,f0,return,edges,with,sources,group,by,0,reduce,group,new,apply,neighbor,group,reduce,function,k,vv,ev,t,neighbors,function,case,out,data,set,tuple3,k,edge,k,ev,vertex,k,vv,edges,with,targets,edges,join,this,vertices,where,1,equal,to,0,with,new,project,vertex,id,join,k,vv,ev,0,with,forwarded,fields,first,f0,return,edges,with,targets,group,by,0,reduce,group,new,apply,neighbor,group,reduce,function,k,vv,ev,t,neighbors,function,case,all,data,set,tuple3,k,edge,k,ev,vertex,k,vv,edges,with,neighbors,edges,flat,map,new,emit,one,edge,with,neighbor,per,node,k,ev,join,this,vertices,where,1,equal,to,0,with,new,project,edge,with,neighbor,k,vv,ev,return,edges,with,neighbors,group,by,0,reduce,group,new,apply,neighbor,group,reduce,function,k,vv,ev,t,neighbors,function,default,throw,new,illegal,argument,exception,illegal,edge,direction
Graph -> public <T> DataSet<T> groupReduceOnNeighbors(NeighborsFunction<K, VV, EV, T> neighborsFunction, 			EdgeDirection direction) throws IllegalArgumentException;1470042815;Groups by vertex and computes a GroupReduce transformation over the neighbors (both edges and vertices)_of each vertex. The neighborsFunction applied on the neighbors only has access to the vertex id_(not the vertex value) of the grouping vertex.__For each vertex, the neighborsFunction can iterate over all neighbors of this vertex_with the specified direction, and emit any number of output elements, including none.__@param neighborsFunction the group reduce function to apply to the neighboring edges and vertices_of each vertex._@param direction the edge direction (in-, out-, all-)._@param <T> the output type_@return a DataSet containing elements of type T_@throws IllegalArgumentException;public <T> DataSet<T> groupReduceOnNeighbors(NeighborsFunction<K, VV, EV, T> neighborsFunction,_			EdgeDirection direction) throws IllegalArgumentException {_		switch (direction) {_		case IN:_			_			DataSet<Tuple3<K, Edge<K, EV>, Vertex<K, VV>>> edgesWithSources = edges_					.join(this.vertices).where(0).equalTo(0)_					.with(new ProjectVertexIdJoin<K, VV, EV>(1))_					.withForwardedFieldsFirst("f1->f0")__			return edgesWithSources.groupBy(0).reduceGroup(_					new ApplyNeighborGroupReduceFunction<K, VV, EV, T>(neighborsFunction))__		case OUT:_			_			DataSet<Tuple3<K, Edge<K, EV>, Vertex<K, VV>>> edgesWithTargets = edges_					.join(this.vertices).where(1).equalTo(0)_					.with(new ProjectVertexIdJoin<K, VV, EV>(0))_					.withForwardedFieldsFirst("f0")__			return edgesWithTargets.groupBy(0).reduceGroup(_					new ApplyNeighborGroupReduceFunction<K, VV, EV, T>(neighborsFunction))__		case ALL:_			_			DataSet<Tuple3<K, Edge<K, EV>, Vertex<K, VV>>> edgesWithNeighbors = edges_					.flatMap(new EmitOneEdgeWithNeighborPerNode<K, EV>())_					.join(this.vertices).where(1).equalTo(0)_					.with(new ProjectEdgeWithNeighbor<K, VV, EV>())___			return edgesWithNeighbors.groupBy(0).reduceGroup(_					new ApplyNeighborGroupReduceFunction<K, VV, EV, T>(neighborsFunction))__		default:_			throw new IllegalArgumentException("Illegal edge direction")__		}_	};groups,by,vertex,and,computes,a,group,reduce,transformation,over,the,neighbors,both,edges,and,vertices,of,each,vertex,the,neighbors,function,applied,on,the,neighbors,only,has,access,to,the,vertex,id,not,the,vertex,value,of,the,grouping,vertex,for,each,vertex,the,neighbors,function,can,iterate,over,all,neighbors,of,this,vertex,with,the,specified,direction,and,emit,any,number,of,output,elements,including,none,param,neighbors,function,the,group,reduce,function,to,apply,to,the,neighboring,edges,and,vertices,of,each,vertex,param,direction,the,edge,direction,in,out,all,param,t,the,output,type,return,a,data,set,containing,elements,of,type,t,throws,illegal,argument,exception;public,t,data,set,t,group,reduce,on,neighbors,neighbors,function,k,vv,ev,t,neighbors,function,edge,direction,direction,throws,illegal,argument,exception,switch,direction,case,in,data,set,tuple3,k,edge,k,ev,vertex,k,vv,edges,with,sources,edges,join,this,vertices,where,0,equal,to,0,with,new,project,vertex,id,join,k,vv,ev,1,with,forwarded,fields,first,f1,f0,return,edges,with,sources,group,by,0,reduce,group,new,apply,neighbor,group,reduce,function,k,vv,ev,t,neighbors,function,case,out,data,set,tuple3,k,edge,k,ev,vertex,k,vv,edges,with,targets,edges,join,this,vertices,where,1,equal,to,0,with,new,project,vertex,id,join,k,vv,ev,0,with,forwarded,fields,first,f0,return,edges,with,targets,group,by,0,reduce,group,new,apply,neighbor,group,reduce,function,k,vv,ev,t,neighbors,function,case,all,data,set,tuple3,k,edge,k,ev,vertex,k,vv,edges,with,neighbors,edges,flat,map,new,emit,one,edge,with,neighbor,per,node,k,ev,join,this,vertices,where,1,equal,to,0,with,new,project,edge,with,neighbor,k,vv,ev,return,edges,with,neighbors,group,by,0,reduce,group,new,apply,neighbor,group,reduce,function,k,vv,ev,t,neighbors,function,default,throw,new,illegal,argument,exception,illegal,edge,direction
Graph -> public <T> DataSet<T> groupReduceOnNeighbors(NeighborsFunction<K, VV, EV, T> neighborsFunction, 			EdgeDirection direction) throws IllegalArgumentException;1475684776;Groups by vertex and computes a GroupReduce transformation over the neighbors (both edges and vertices)_of each vertex. The neighborsFunction applied on the neighbors only has access to the vertex id_(not the vertex value) of the grouping vertex.__For each vertex, the neighborsFunction can iterate over all neighbors of this vertex_with the specified direction, and emit any number of output elements, including none.__@param neighborsFunction the group reduce function to apply to the neighboring edges and vertices_of each vertex._@param direction the edge direction (in-, out-, all-)._@param <T> the output type_@return a DataSet containing elements of type T_@throws IllegalArgumentException;public <T> DataSet<T> groupReduceOnNeighbors(NeighborsFunction<K, VV, EV, T> neighborsFunction,_			EdgeDirection direction) throws IllegalArgumentException {_		switch (direction) {_		case IN:_			_			DataSet<Tuple3<K, Edge<K, EV>, Vertex<K, VV>>> edgesWithSources = edges_					.join(this.vertices).where(0).equalTo(0)_					.with(new ProjectVertexIdJoin<K, VV, EV>(1))_					.withForwardedFieldsFirst("f1->f0")__			return edgesWithSources.groupBy(0).reduceGroup(_				new ApplyNeighborGroupReduceFunction<>(neighborsFunction))__		case OUT:_			_			DataSet<Tuple3<K, Edge<K, EV>, Vertex<K, VV>>> edgesWithTargets = edges_					.join(this.vertices).where(1).equalTo(0)_					.with(new ProjectVertexIdJoin<K, VV, EV>(0))_					.withForwardedFieldsFirst("f0")__			return edgesWithTargets.groupBy(0).reduceGroup(_				new ApplyNeighborGroupReduceFunction<>(neighborsFunction))__		case ALL:_			_			DataSet<Tuple3<K, Edge<K, EV>, Vertex<K, VV>>> edgesWithNeighbors = edges_					.flatMap(new EmitOneEdgeWithNeighborPerNode<K, EV>())_					.join(this.vertices).where(1).equalTo(0)_					.with(new ProjectEdgeWithNeighbor<K, VV, EV>())___			return edgesWithNeighbors.groupBy(0).reduceGroup(_				new ApplyNeighborGroupReduceFunction<>(neighborsFunction))__		default:_			throw new IllegalArgumentException("Illegal edge direction")__		}_	};groups,by,vertex,and,computes,a,group,reduce,transformation,over,the,neighbors,both,edges,and,vertices,of,each,vertex,the,neighbors,function,applied,on,the,neighbors,only,has,access,to,the,vertex,id,not,the,vertex,value,of,the,grouping,vertex,for,each,vertex,the,neighbors,function,can,iterate,over,all,neighbors,of,this,vertex,with,the,specified,direction,and,emit,any,number,of,output,elements,including,none,param,neighbors,function,the,group,reduce,function,to,apply,to,the,neighboring,edges,and,vertices,of,each,vertex,param,direction,the,edge,direction,in,out,all,param,t,the,output,type,return,a,data,set,containing,elements,of,type,t,throws,illegal,argument,exception;public,t,data,set,t,group,reduce,on,neighbors,neighbors,function,k,vv,ev,t,neighbors,function,edge,direction,direction,throws,illegal,argument,exception,switch,direction,case,in,data,set,tuple3,k,edge,k,ev,vertex,k,vv,edges,with,sources,edges,join,this,vertices,where,0,equal,to,0,with,new,project,vertex,id,join,k,vv,ev,1,with,forwarded,fields,first,f1,f0,return,edges,with,sources,group,by,0,reduce,group,new,apply,neighbor,group,reduce,function,neighbors,function,case,out,data,set,tuple3,k,edge,k,ev,vertex,k,vv,edges,with,targets,edges,join,this,vertices,where,1,equal,to,0,with,new,project,vertex,id,join,k,vv,ev,0,with,forwarded,fields,first,f0,return,edges,with,targets,group,by,0,reduce,group,new,apply,neighbor,group,reduce,function,neighbors,function,case,all,data,set,tuple3,k,edge,k,ev,vertex,k,vv,edges,with,neighbors,edges,flat,map,new,emit,one,edge,with,neighbor,per,node,k,ev,join,this,vertices,where,1,equal,to,0,with,new,project,edge,with,neighbor,k,vv,ev,return,edges,with,neighbors,group,by,0,reduce,group,new,apply,neighbor,group,reduce,function,neighbors,function,default,throw,new,illegal,argument,exception,illegal,edge,direction
Graph -> public <T> DataSet<T> groupReduceOnNeighbors(NeighborsFunction<K, VV, EV, T> neighborsFunction, 			EdgeDirection direction) throws IllegalArgumentException;1475685606;Groups by vertex and computes a GroupReduce transformation over the neighbors (both edges and vertices)_of each vertex. The neighborsFunction applied on the neighbors only has access to the vertex id_(not the vertex value) of the grouping vertex.__For each vertex, the neighborsFunction can iterate over all neighbors of this vertex_with the specified direction, and emit any number of output elements, including none.__@param neighborsFunction the group reduce function to apply to the neighboring edges and vertices_of each vertex._@param direction the edge direction (in-, out-, all-)._@param <T> the output type_@return a DataSet containing elements of type T_@throws IllegalArgumentException;public <T> DataSet<T> groupReduceOnNeighbors(NeighborsFunction<K, VV, EV, T> neighborsFunction,_			EdgeDirection direction) throws IllegalArgumentException {_		switch (direction) {_		case IN:_			_			DataSet<Tuple3<K, Edge<K, EV>, Vertex<K, VV>>> edgesWithSources = edges_					.join(this.vertices).where(0).equalTo(0)_					.with(new ProjectVertexIdJoin<K, VV, EV>(1))_					.withForwardedFieldsFirst("f1->f0")__			return edgesWithSources.groupBy(0).reduceGroup(_				new ApplyNeighborGroupReduceFunction<>(neighborsFunction))__		case OUT:_			_			DataSet<Tuple3<K, Edge<K, EV>, Vertex<K, VV>>> edgesWithTargets = edges_					.join(this.vertices).where(1).equalTo(0)_					.with(new ProjectVertexIdJoin<K, VV, EV>(0))_					.withForwardedFieldsFirst("f0")__			return edgesWithTargets.groupBy(0).reduceGroup(_				new ApplyNeighborGroupReduceFunction<>(neighborsFunction))__		case ALL:_			_			DataSet<Tuple3<K, Edge<K, EV>, Vertex<K, VV>>> edgesWithNeighbors = edges_					.flatMap(new EmitOneEdgeWithNeighborPerNode<K, EV>())_					.join(this.vertices).where(1).equalTo(0)_					.with(new ProjectEdgeWithNeighbor<K, VV, EV>())___			return edgesWithNeighbors.groupBy(0).reduceGroup(_				new ApplyNeighborGroupReduceFunction<>(neighborsFunction))__		default:_			throw new IllegalArgumentException("Illegal edge direction")__		}_	};groups,by,vertex,and,computes,a,group,reduce,transformation,over,the,neighbors,both,edges,and,vertices,of,each,vertex,the,neighbors,function,applied,on,the,neighbors,only,has,access,to,the,vertex,id,not,the,vertex,value,of,the,grouping,vertex,for,each,vertex,the,neighbors,function,can,iterate,over,all,neighbors,of,this,vertex,with,the,specified,direction,and,emit,any,number,of,output,elements,including,none,param,neighbors,function,the,group,reduce,function,to,apply,to,the,neighboring,edges,and,vertices,of,each,vertex,param,direction,the,edge,direction,in,out,all,param,t,the,output,type,return,a,data,set,containing,elements,of,type,t,throws,illegal,argument,exception;public,t,data,set,t,group,reduce,on,neighbors,neighbors,function,k,vv,ev,t,neighbors,function,edge,direction,direction,throws,illegal,argument,exception,switch,direction,case,in,data,set,tuple3,k,edge,k,ev,vertex,k,vv,edges,with,sources,edges,join,this,vertices,where,0,equal,to,0,with,new,project,vertex,id,join,k,vv,ev,1,with,forwarded,fields,first,f1,f0,return,edges,with,sources,group,by,0,reduce,group,new,apply,neighbor,group,reduce,function,neighbors,function,case,out,data,set,tuple3,k,edge,k,ev,vertex,k,vv,edges,with,targets,edges,join,this,vertices,where,1,equal,to,0,with,new,project,vertex,id,join,k,vv,ev,0,with,forwarded,fields,first,f0,return,edges,with,targets,group,by,0,reduce,group,new,apply,neighbor,group,reduce,function,neighbors,function,case,all,data,set,tuple3,k,edge,k,ev,vertex,k,vv,edges,with,neighbors,edges,flat,map,new,emit,one,edge,with,neighbor,per,node,k,ev,join,this,vertices,where,1,equal,to,0,with,new,project,edge,with,neighbor,k,vv,ev,return,edges,with,neighbors,group,by,0,reduce,group,new,apply,neighbor,group,reduce,function,neighbors,function,default,throw,new,illegal,argument,exception,illegal,edge,direction
Graph -> public <T> DataSet<T> groupReduceOnNeighbors(NeighborsFunction<K, VV, EV, T> neighborsFunction, 			EdgeDirection direction) throws IllegalArgumentException;1481745825;Groups by vertex and computes a GroupReduce transformation over the neighbors (both edges and vertices)_of each vertex. The neighborsFunction applied on the neighbors only has access to the vertex id_(not the vertex value) of the grouping vertex.__For each vertex, the neighborsFunction can iterate over all neighbors of this vertex_with the specified direction, and emit any number of output elements, including none.__@param neighborsFunction the group reduce function to apply to the neighboring edges and vertices_of each vertex._@param direction the edge direction (in-, out-, all-)._@param <T> the output type_@return a DataSet containing elements of type T_@throws IllegalArgumentException;public <T> DataSet<T> groupReduceOnNeighbors(NeighborsFunction<K, VV, EV, T> neighborsFunction,_			EdgeDirection direction) throws IllegalArgumentException {_		switch (direction) {_		case IN:_			_			DataSet<Tuple3<K, Edge<K, EV>, Vertex<K, VV>>> edgesWithSources = edges_					.join(this.vertices).where(0).equalTo(0)_					.with(new ProjectVertexIdJoin<K, VV, EV>(1))_					.withForwardedFieldsFirst("f1->f0").name("Edge with source vertex ID")__			return edgesWithSources.groupBy(0).reduceGroup(_				new ApplyNeighborGroupReduceFunction<>(neighborsFunction)).name("Neighbors function")__		case OUT:_			_			DataSet<Tuple3<K, Edge<K, EV>, Vertex<K, VV>>> edgesWithTargets = edges_					.join(this.vertices).where(1).equalTo(0)_					.with(new ProjectVertexIdJoin<K, VV, EV>(0))_					.withForwardedFieldsFirst("f0").name("Edge with target vertex ID")__			return edgesWithTargets.groupBy(0).reduceGroup(_				new ApplyNeighborGroupReduceFunction<>(neighborsFunction)).name("Neighbors function")__		case ALL:_			_			DataSet<Tuple3<K, Edge<K, EV>, Vertex<K, VV>>> edgesWithNeighbors = edges_					.flatMap(new EmitOneEdgeWithNeighborPerNode<K, EV>()).name("Forward and reverse edges")_					.join(this.vertices).where(1).equalTo(0)_					.with(new ProjectEdgeWithNeighbor<K, VV, EV>()).name("Edge with vertex ID")___			return edgesWithNeighbors.groupBy(0).reduceGroup(_				new ApplyNeighborGroupReduceFunction<>(neighborsFunction)).name("Neighbors function")__		default:_			throw new IllegalArgumentException("Illegal edge direction")__		}_	};groups,by,vertex,and,computes,a,group,reduce,transformation,over,the,neighbors,both,edges,and,vertices,of,each,vertex,the,neighbors,function,applied,on,the,neighbors,only,has,access,to,the,vertex,id,not,the,vertex,value,of,the,grouping,vertex,for,each,vertex,the,neighbors,function,can,iterate,over,all,neighbors,of,this,vertex,with,the,specified,direction,and,emit,any,number,of,output,elements,including,none,param,neighbors,function,the,group,reduce,function,to,apply,to,the,neighboring,edges,and,vertices,of,each,vertex,param,direction,the,edge,direction,in,out,all,param,t,the,output,type,return,a,data,set,containing,elements,of,type,t,throws,illegal,argument,exception;public,t,data,set,t,group,reduce,on,neighbors,neighbors,function,k,vv,ev,t,neighbors,function,edge,direction,direction,throws,illegal,argument,exception,switch,direction,case,in,data,set,tuple3,k,edge,k,ev,vertex,k,vv,edges,with,sources,edges,join,this,vertices,where,0,equal,to,0,with,new,project,vertex,id,join,k,vv,ev,1,with,forwarded,fields,first,f1,f0,name,edge,with,source,vertex,id,return,edges,with,sources,group,by,0,reduce,group,new,apply,neighbor,group,reduce,function,neighbors,function,name,neighbors,function,case,out,data,set,tuple3,k,edge,k,ev,vertex,k,vv,edges,with,targets,edges,join,this,vertices,where,1,equal,to,0,with,new,project,vertex,id,join,k,vv,ev,0,with,forwarded,fields,first,f0,name,edge,with,target,vertex,id,return,edges,with,targets,group,by,0,reduce,group,new,apply,neighbor,group,reduce,function,neighbors,function,name,neighbors,function,case,all,data,set,tuple3,k,edge,k,ev,vertex,k,vv,edges,with,neighbors,edges,flat,map,new,emit,one,edge,with,neighbor,per,node,k,ev,name,forward,and,reverse,edges,join,this,vertices,where,1,equal,to,0,with,new,project,edge,with,neighbor,k,vv,ev,name,edge,with,vertex,id,return,edges,with,neighbors,group,by,0,reduce,group,new,apply,neighbor,group,reduce,function,neighbors,function,name,neighbors,function,default,throw,new,illegal,argument,exception,illegal,edge,direction
Graph -> public <T> DataSet<T> groupReduceOnNeighbors(NeighborsFunction<K, VV, EV, T> neighborsFunction, 			EdgeDirection direction) throws IllegalArgumentException;1481881009;Groups by vertex and computes a GroupReduce transformation over the neighbors (both edges and vertices)_of each vertex. The neighborsFunction applied on the neighbors only has access to the vertex id_(not the vertex value) of the grouping vertex.__For each vertex, the neighborsFunction can iterate over all neighbors of this vertex_with the specified direction, and emit any number of output elements, including none.__@param neighborsFunction the group reduce function to apply to the neighboring edges and vertices_of each vertex._@param direction the edge direction (in-, out-, all-)._@param <T> the output type_@return a DataSet containing elements of type T_@throws IllegalArgumentException;public <T> DataSet<T> groupReduceOnNeighbors(NeighborsFunction<K, VV, EV, T> neighborsFunction,_			EdgeDirection direction) throws IllegalArgumentException {_		switch (direction) {_		case IN:_			_			DataSet<Tuple3<K, Edge<K, EV>, Vertex<K, VV>>> edgesWithSources = edges_					.join(this.vertices).where(0).equalTo(0)_					.with(new ProjectVertexIdJoin<K, VV, EV>(1))_					.withForwardedFieldsFirst("f1->f0").name("Edge with source vertex ID")__			return edgesWithSources.groupBy(0).reduceGroup(_				new ApplyNeighborGroupReduceFunction<>(neighborsFunction)).name("Neighbors function")__		case OUT:_			_			DataSet<Tuple3<K, Edge<K, EV>, Vertex<K, VV>>> edgesWithTargets = edges_					.join(this.vertices).where(1).equalTo(0)_					.with(new ProjectVertexIdJoin<K, VV, EV>(0))_					.withForwardedFieldsFirst("f0").name("Edge with target vertex ID")__			return edgesWithTargets.groupBy(0).reduceGroup(_				new ApplyNeighborGroupReduceFunction<>(neighborsFunction)).name("Neighbors function")__		case ALL:_			_			DataSet<Tuple3<K, Edge<K, EV>, Vertex<K, VV>>> edgesWithNeighbors = edges_					.flatMap(new EmitOneEdgeWithNeighborPerNode<K, EV>()).name("Forward and reverse edges")_					.join(this.vertices).where(1).equalTo(0)_					.with(new ProjectEdgeWithNeighbor<K, VV, EV>()).name("Edge with vertex ID")___			return edgesWithNeighbors.groupBy(0).reduceGroup(_				new ApplyNeighborGroupReduceFunction<>(neighborsFunction)).name("Neighbors function")__		default:_			throw new IllegalArgumentException("Illegal edge direction")__		}_	};groups,by,vertex,and,computes,a,group,reduce,transformation,over,the,neighbors,both,edges,and,vertices,of,each,vertex,the,neighbors,function,applied,on,the,neighbors,only,has,access,to,the,vertex,id,not,the,vertex,value,of,the,grouping,vertex,for,each,vertex,the,neighbors,function,can,iterate,over,all,neighbors,of,this,vertex,with,the,specified,direction,and,emit,any,number,of,output,elements,including,none,param,neighbors,function,the,group,reduce,function,to,apply,to,the,neighboring,edges,and,vertices,of,each,vertex,param,direction,the,edge,direction,in,out,all,param,t,the,output,type,return,a,data,set,containing,elements,of,type,t,throws,illegal,argument,exception;public,t,data,set,t,group,reduce,on,neighbors,neighbors,function,k,vv,ev,t,neighbors,function,edge,direction,direction,throws,illegal,argument,exception,switch,direction,case,in,data,set,tuple3,k,edge,k,ev,vertex,k,vv,edges,with,sources,edges,join,this,vertices,where,0,equal,to,0,with,new,project,vertex,id,join,k,vv,ev,1,with,forwarded,fields,first,f1,f0,name,edge,with,source,vertex,id,return,edges,with,sources,group,by,0,reduce,group,new,apply,neighbor,group,reduce,function,neighbors,function,name,neighbors,function,case,out,data,set,tuple3,k,edge,k,ev,vertex,k,vv,edges,with,targets,edges,join,this,vertices,where,1,equal,to,0,with,new,project,vertex,id,join,k,vv,ev,0,with,forwarded,fields,first,f0,name,edge,with,target,vertex,id,return,edges,with,targets,group,by,0,reduce,group,new,apply,neighbor,group,reduce,function,neighbors,function,name,neighbors,function,case,all,data,set,tuple3,k,edge,k,ev,vertex,k,vv,edges,with,neighbors,edges,flat,map,new,emit,one,edge,with,neighbor,per,node,k,ev,name,forward,and,reverse,edges,join,this,vertices,where,1,equal,to,0,with,new,project,edge,with,neighbor,k,vv,ev,name,edge,with,vertex,id,return,edges,with,neighbors,group,by,0,reduce,group,new,apply,neighbor,group,reduce,function,neighbors,function,name,neighbors,function,default,throw,new,illegal,argument,exception,illegal,edge,direction
Graph -> public <T> DataSet<T> groupReduceOnNeighbors(NeighborsFunction<K, VV, EV, T> neighborsFunction, 			EdgeDirection direction) throws IllegalArgumentException;1484160227;Groups by vertex and computes a GroupReduce transformation over the neighbors (both edges and vertices)_of each vertex. The neighborsFunction applied on the neighbors only has access to the vertex id_(not the vertex value) of the grouping vertex.__For each vertex, the neighborsFunction can iterate over all neighbors of this vertex_with the specified direction, and emit any number of output elements, including none.__@param neighborsFunction the group reduce function to apply to the neighboring edges and vertices_of each vertex._@param direction the edge direction (in-, out-, all-)._@param <T> the output type_@return a DataSet containing elements of type T_@throws IllegalArgumentException;public <T> DataSet<T> groupReduceOnNeighbors(NeighborsFunction<K, VV, EV, T> neighborsFunction,_			EdgeDirection direction) throws IllegalArgumentException {_		switch (direction) {_		case IN:_			_			DataSet<Tuple3<K, Edge<K, EV>, Vertex<K, VV>>> edgesWithSources = edges_					.join(this.vertices).where(0).equalTo(0)_					.with(new ProjectVertexIdJoin<K, VV, EV>(1))_					.withForwardedFieldsFirst("f1->f0").name("Edge with source vertex ID")__			return edgesWithSources.groupBy(0).reduceGroup(_				new ApplyNeighborGroupReduceFunction<>(neighborsFunction)).name("Neighbors function")__		case OUT:_			_			DataSet<Tuple3<K, Edge<K, EV>, Vertex<K, VV>>> edgesWithTargets = edges_					.join(this.vertices).where(1).equalTo(0)_					.with(new ProjectVertexIdJoin<K, VV, EV>(0))_					.withForwardedFieldsFirst("f0").name("Edge with target vertex ID")__			return edgesWithTargets.groupBy(0).reduceGroup(_				new ApplyNeighborGroupReduceFunction<>(neighborsFunction)).name("Neighbors function")__		case ALL:_			_			DataSet<Tuple3<K, Edge<K, EV>, Vertex<K, VV>>> edgesWithNeighbors = edges_					.flatMap(new EmitOneEdgeWithNeighborPerNode<K, EV>()).name("Forward and reverse edges")_					.join(this.vertices).where(1).equalTo(0)_					.with(new ProjectEdgeWithNeighbor<K, VV, EV>()).name("Edge with vertex ID")___			return edgesWithNeighbors.groupBy(0).reduceGroup(_				new ApplyNeighborGroupReduceFunction<>(neighborsFunction)).name("Neighbors function")__		default:_			throw new IllegalArgumentException("Illegal edge direction")__		}_	};groups,by,vertex,and,computes,a,group,reduce,transformation,over,the,neighbors,both,edges,and,vertices,of,each,vertex,the,neighbors,function,applied,on,the,neighbors,only,has,access,to,the,vertex,id,not,the,vertex,value,of,the,grouping,vertex,for,each,vertex,the,neighbors,function,can,iterate,over,all,neighbors,of,this,vertex,with,the,specified,direction,and,emit,any,number,of,output,elements,including,none,param,neighbors,function,the,group,reduce,function,to,apply,to,the,neighboring,edges,and,vertices,of,each,vertex,param,direction,the,edge,direction,in,out,all,param,t,the,output,type,return,a,data,set,containing,elements,of,type,t,throws,illegal,argument,exception;public,t,data,set,t,group,reduce,on,neighbors,neighbors,function,k,vv,ev,t,neighbors,function,edge,direction,direction,throws,illegal,argument,exception,switch,direction,case,in,data,set,tuple3,k,edge,k,ev,vertex,k,vv,edges,with,sources,edges,join,this,vertices,where,0,equal,to,0,with,new,project,vertex,id,join,k,vv,ev,1,with,forwarded,fields,first,f1,f0,name,edge,with,source,vertex,id,return,edges,with,sources,group,by,0,reduce,group,new,apply,neighbor,group,reduce,function,neighbors,function,name,neighbors,function,case,out,data,set,tuple3,k,edge,k,ev,vertex,k,vv,edges,with,targets,edges,join,this,vertices,where,1,equal,to,0,with,new,project,vertex,id,join,k,vv,ev,0,with,forwarded,fields,first,f0,name,edge,with,target,vertex,id,return,edges,with,targets,group,by,0,reduce,group,new,apply,neighbor,group,reduce,function,neighbors,function,name,neighbors,function,case,all,data,set,tuple3,k,edge,k,ev,vertex,k,vv,edges,with,neighbors,edges,flat,map,new,emit,one,edge,with,neighbor,per,node,k,ev,name,forward,and,reverse,edges,join,this,vertices,where,1,equal,to,0,with,new,project,edge,with,neighbor,k,vv,ev,name,edge,with,vertex,id,return,edges,with,neighbors,group,by,0,reduce,group,new,apply,neighbor,group,reduce,function,neighbors,function,name,neighbors,function,default,throw,new,illegal,argument,exception,illegal,edge,direction
Graph -> public <T> DataSet<T> groupReduceOnNeighbors(NeighborsFunction<K, VV, EV, T> neighborsFunction, 			EdgeDirection direction) throws IllegalArgumentException;1484685504;Groups by vertex and computes a GroupReduce transformation over the neighbors (both edges and vertices)_of each vertex. The neighborsFunction applied on the neighbors only has access to the vertex id_(not the vertex value) of the grouping vertex.__For each vertex, the neighborsFunction can iterate over all neighbors of this vertex_with the specified direction, and emit any number of output elements, including none.__@param neighborsFunction the group reduce function to apply to the neighboring edges and vertices_of each vertex._@param direction the edge direction (in-, out-, all-)._@param <T> the output type_@return a DataSet containing elements of type T_@throws IllegalArgumentException;public <T> DataSet<T> groupReduceOnNeighbors(NeighborsFunction<K, VV, EV, T> neighborsFunction,_			EdgeDirection direction) throws IllegalArgumentException {_		switch (direction) {_		case IN:_			_			DataSet<Tuple3<K, Edge<K, EV>, Vertex<K, VV>>> edgesWithSources = edges_					.join(this.vertices).where(0).equalTo(0)_					.with(new ProjectVertexIdJoin<K, VV, EV>(1))_					.withForwardedFieldsFirst("f1->f0").name("Edge with source vertex ID")__			return edgesWithSources.groupBy(0).reduceGroup(_				new ApplyNeighborGroupReduceFunction<>(neighborsFunction)).name("Neighbors function")__		case OUT:_			_			DataSet<Tuple3<K, Edge<K, EV>, Vertex<K, VV>>> edgesWithTargets = edges_					.join(this.vertices).where(1).equalTo(0)_					.with(new ProjectVertexIdJoin<K, VV, EV>(0))_					.withForwardedFieldsFirst("f0").name("Edge with target vertex ID")__			return edgesWithTargets.groupBy(0).reduceGroup(_				new ApplyNeighborGroupReduceFunction<>(neighborsFunction)).name("Neighbors function")__		case ALL:_			_			DataSet<Tuple3<K, Edge<K, EV>, Vertex<K, VV>>> edgesWithNeighbors = edges_					.flatMap(new EmitOneEdgeWithNeighborPerNode<K, EV>()).name("Forward and reverse edges")_					.join(this.vertices).where(1).equalTo(0)_					.with(new ProjectEdgeWithNeighbor<K, VV, EV>()).name("Edge with vertex ID")___			return edgesWithNeighbors.groupBy(0).reduceGroup(_				new ApplyNeighborGroupReduceFunction<>(neighborsFunction)).name("Neighbors function")__		default:_			throw new IllegalArgumentException("Illegal edge direction")__		}_	};groups,by,vertex,and,computes,a,group,reduce,transformation,over,the,neighbors,both,edges,and,vertices,of,each,vertex,the,neighbors,function,applied,on,the,neighbors,only,has,access,to,the,vertex,id,not,the,vertex,value,of,the,grouping,vertex,for,each,vertex,the,neighbors,function,can,iterate,over,all,neighbors,of,this,vertex,with,the,specified,direction,and,emit,any,number,of,output,elements,including,none,param,neighbors,function,the,group,reduce,function,to,apply,to,the,neighboring,edges,and,vertices,of,each,vertex,param,direction,the,edge,direction,in,out,all,param,t,the,output,type,return,a,data,set,containing,elements,of,type,t,throws,illegal,argument,exception;public,t,data,set,t,group,reduce,on,neighbors,neighbors,function,k,vv,ev,t,neighbors,function,edge,direction,direction,throws,illegal,argument,exception,switch,direction,case,in,data,set,tuple3,k,edge,k,ev,vertex,k,vv,edges,with,sources,edges,join,this,vertices,where,0,equal,to,0,with,new,project,vertex,id,join,k,vv,ev,1,with,forwarded,fields,first,f1,f0,name,edge,with,source,vertex,id,return,edges,with,sources,group,by,0,reduce,group,new,apply,neighbor,group,reduce,function,neighbors,function,name,neighbors,function,case,out,data,set,tuple3,k,edge,k,ev,vertex,k,vv,edges,with,targets,edges,join,this,vertices,where,1,equal,to,0,with,new,project,vertex,id,join,k,vv,ev,0,with,forwarded,fields,first,f0,name,edge,with,target,vertex,id,return,edges,with,targets,group,by,0,reduce,group,new,apply,neighbor,group,reduce,function,neighbors,function,name,neighbors,function,case,all,data,set,tuple3,k,edge,k,ev,vertex,k,vv,edges,with,neighbors,edges,flat,map,new,emit,one,edge,with,neighbor,per,node,k,ev,name,forward,and,reverse,edges,join,this,vertices,where,1,equal,to,0,with,new,project,edge,with,neighbor,k,vv,ev,name,edge,with,vertex,id,return,edges,with,neighbors,group,by,0,reduce,group,new,apply,neighbor,group,reduce,function,neighbors,function,name,neighbors,function,default,throw,new,illegal,argument,exception,illegal,edge,direction
Graph -> public <T> DataSet<T> groupReduceOnNeighbors(NeighborsFunction<K, VV, EV, T> neighborsFunction, 			EdgeDirection direction) throws IllegalArgumentException;1489068942;Groups by vertex and computes a GroupReduce transformation over the neighbors (both edges and vertices)_of each vertex. The neighborsFunction applied on the neighbors only has access to the vertex id_(not the vertex value) of the grouping vertex.__For each vertex, the neighborsFunction can iterate over all neighbors of this vertex_with the specified direction, and emit any number of output elements, including none.__@param neighborsFunction the group reduce function to apply to the neighboring edges and vertices_of each vertex._@param direction the edge direction (in-, out-, all-)._@param <T> the output type_@return a DataSet containing elements of type T_@throws IllegalArgumentException;public <T> DataSet<T> groupReduceOnNeighbors(NeighborsFunction<K, VV, EV, T> neighborsFunction,_			EdgeDirection direction) throws IllegalArgumentException {_		switch (direction) {_		case IN:_			_			DataSet<Tuple3<K, Edge<K, EV>, Vertex<K, VV>>> edgesWithSources = edges_					.join(this.vertices).where(0).equalTo(0)_					.with(new ProjectVertexIdJoin<K, VV, EV>(1))_					.withForwardedFieldsFirst("f1->f0").name("Edge with source vertex ID")__			return edgesWithSources.groupBy(0).reduceGroup(_				new ApplyNeighborGroupReduceFunction<>(neighborsFunction)).name("Neighbors function")__		case OUT:_			_			DataSet<Tuple3<K, Edge<K, EV>, Vertex<K, VV>>> edgesWithTargets = edges_					.join(this.vertices).where(1).equalTo(0)_					.with(new ProjectVertexIdJoin<K, VV, EV>(0))_					.withForwardedFieldsFirst("f0").name("Edge with target vertex ID")__			return edgesWithTargets.groupBy(0).reduceGroup(_				new ApplyNeighborGroupReduceFunction<>(neighborsFunction)).name("Neighbors function")__		case ALL:_			_			DataSet<Tuple3<K, Edge<K, EV>, Vertex<K, VV>>> edgesWithNeighbors = edges_					.flatMap(new EmitOneEdgeWithNeighborPerNode<K, EV>()).name("Forward and reverse edges")_					.join(this.vertices).where(1).equalTo(0)_					.with(new ProjectEdgeWithNeighbor<K, VV, EV>()).name("Edge with vertex ID")___			return edgesWithNeighbors.groupBy(0).reduceGroup(_				new ApplyNeighborGroupReduceFunction<>(neighborsFunction)).name("Neighbors function")__		default:_			throw new IllegalArgumentException("Illegal edge direction")__		}_	};groups,by,vertex,and,computes,a,group,reduce,transformation,over,the,neighbors,both,edges,and,vertices,of,each,vertex,the,neighbors,function,applied,on,the,neighbors,only,has,access,to,the,vertex,id,not,the,vertex,value,of,the,grouping,vertex,for,each,vertex,the,neighbors,function,can,iterate,over,all,neighbors,of,this,vertex,with,the,specified,direction,and,emit,any,number,of,output,elements,including,none,param,neighbors,function,the,group,reduce,function,to,apply,to,the,neighboring,edges,and,vertices,of,each,vertex,param,direction,the,edge,direction,in,out,all,param,t,the,output,type,return,a,data,set,containing,elements,of,type,t,throws,illegal,argument,exception;public,t,data,set,t,group,reduce,on,neighbors,neighbors,function,k,vv,ev,t,neighbors,function,edge,direction,direction,throws,illegal,argument,exception,switch,direction,case,in,data,set,tuple3,k,edge,k,ev,vertex,k,vv,edges,with,sources,edges,join,this,vertices,where,0,equal,to,0,with,new,project,vertex,id,join,k,vv,ev,1,with,forwarded,fields,first,f1,f0,name,edge,with,source,vertex,id,return,edges,with,sources,group,by,0,reduce,group,new,apply,neighbor,group,reduce,function,neighbors,function,name,neighbors,function,case,out,data,set,tuple3,k,edge,k,ev,vertex,k,vv,edges,with,targets,edges,join,this,vertices,where,1,equal,to,0,with,new,project,vertex,id,join,k,vv,ev,0,with,forwarded,fields,first,f0,name,edge,with,target,vertex,id,return,edges,with,targets,group,by,0,reduce,group,new,apply,neighbor,group,reduce,function,neighbors,function,name,neighbors,function,case,all,data,set,tuple3,k,edge,k,ev,vertex,k,vv,edges,with,neighbors,edges,flat,map,new,emit,one,edge,with,neighbor,per,node,k,ev,name,forward,and,reverse,edges,join,this,vertices,where,1,equal,to,0,with,new,project,edge,with,neighbor,k,vv,ev,name,edge,with,vertex,id,return,edges,with,neighbors,group,by,0,reduce,group,new,apply,neighbor,group,reduce,function,neighbors,function,name,neighbors,function,default,throw,new,illegal,argument,exception,illegal,edge,direction
Graph -> public <T> DataSet<T> groupReduceOnNeighbors(NeighborsFunction<K, VV, EV, T> neighborsFunction, 			EdgeDirection direction) throws IllegalArgumentException;1490973446;Groups by vertex and computes a GroupReduce transformation over the neighbors (both edges and vertices)_of each vertex. The neighborsFunction applied on the neighbors only has access to the vertex id_(not the vertex value) of the grouping vertex.__For each vertex, the neighborsFunction can iterate over all neighbors of this vertex_with the specified direction, and emit any number of output elements, including none.__@param neighborsFunction the group reduce function to apply to the neighboring edges and vertices_of each vertex._@param direction the edge direction (in-, out-, all-)._@param <T> the output type_@return a DataSet containing elements of type T_@throws IllegalArgumentException;public <T> DataSet<T> groupReduceOnNeighbors(NeighborsFunction<K, VV, EV, T> neighborsFunction,_			EdgeDirection direction) throws IllegalArgumentException {_		switch (direction) {_		case IN:_			_			DataSet<Tuple3<K, Edge<K, EV>, Vertex<K, VV>>> edgesWithSources = edges_					.join(this.vertices).where(0).equalTo(0)_					.with(new ProjectVertexIdJoin<K, VV, EV>(1))_					.withForwardedFieldsFirst("f1->f0").name("Edge with source vertex ID")__			return edgesWithSources.groupBy(0).reduceGroup(_				new ApplyNeighborGroupReduceFunction<>(neighborsFunction)).name("Neighbors function")__		case OUT:_			_			DataSet<Tuple3<K, Edge<K, EV>, Vertex<K, VV>>> edgesWithTargets = edges_					.join(this.vertices).where(1).equalTo(0)_					.with(new ProjectVertexIdJoin<K, VV, EV>(0))_					.withForwardedFieldsFirst("f0").name("Edge with target vertex ID")__			return edgesWithTargets.groupBy(0).reduceGroup(_				new ApplyNeighborGroupReduceFunction<>(neighborsFunction)).name("Neighbors function")__		case ALL:_			_			DataSet<Tuple3<K, Edge<K, EV>, Vertex<K, VV>>> edgesWithNeighbors = edges_					.flatMap(new EmitOneEdgeWithNeighborPerNode<K, EV>()).name("Forward and reverse edges")_					.join(this.vertices).where(1).equalTo(0)_					.with(new ProjectEdgeWithNeighbor<K, VV, EV>()).name("Edge with vertex ID")___			return edgesWithNeighbors.groupBy(0).reduceGroup(_				new ApplyNeighborGroupReduceFunction<>(neighborsFunction)).name("Neighbors function")__		default:_			throw new IllegalArgumentException("Illegal edge direction")__		}_	};groups,by,vertex,and,computes,a,group,reduce,transformation,over,the,neighbors,both,edges,and,vertices,of,each,vertex,the,neighbors,function,applied,on,the,neighbors,only,has,access,to,the,vertex,id,not,the,vertex,value,of,the,grouping,vertex,for,each,vertex,the,neighbors,function,can,iterate,over,all,neighbors,of,this,vertex,with,the,specified,direction,and,emit,any,number,of,output,elements,including,none,param,neighbors,function,the,group,reduce,function,to,apply,to,the,neighboring,edges,and,vertices,of,each,vertex,param,direction,the,edge,direction,in,out,all,param,t,the,output,type,return,a,data,set,containing,elements,of,type,t,throws,illegal,argument,exception;public,t,data,set,t,group,reduce,on,neighbors,neighbors,function,k,vv,ev,t,neighbors,function,edge,direction,direction,throws,illegal,argument,exception,switch,direction,case,in,data,set,tuple3,k,edge,k,ev,vertex,k,vv,edges,with,sources,edges,join,this,vertices,where,0,equal,to,0,with,new,project,vertex,id,join,k,vv,ev,1,with,forwarded,fields,first,f1,f0,name,edge,with,source,vertex,id,return,edges,with,sources,group,by,0,reduce,group,new,apply,neighbor,group,reduce,function,neighbors,function,name,neighbors,function,case,out,data,set,tuple3,k,edge,k,ev,vertex,k,vv,edges,with,targets,edges,join,this,vertices,where,1,equal,to,0,with,new,project,vertex,id,join,k,vv,ev,0,with,forwarded,fields,first,f0,name,edge,with,target,vertex,id,return,edges,with,targets,group,by,0,reduce,group,new,apply,neighbor,group,reduce,function,neighbors,function,name,neighbors,function,case,all,data,set,tuple3,k,edge,k,ev,vertex,k,vv,edges,with,neighbors,edges,flat,map,new,emit,one,edge,with,neighbor,per,node,k,ev,name,forward,and,reverse,edges,join,this,vertices,where,1,equal,to,0,with,new,project,edge,with,neighbor,k,vv,ev,name,edge,with,vertex,id,return,edges,with,neighbors,group,by,0,reduce,group,new,apply,neighbor,group,reduce,function,neighbors,function,name,neighbors,function,default,throw,new,illegal,argument,exception,illegal,edge,direction
Graph -> public <T> DataSet<T> groupReduceOnNeighbors(NeighborsFunction<K, VV, EV, T> neighborsFunction, 			EdgeDirection direction) throws IllegalArgumentException;1495819075;Groups by vertex and computes a GroupReduce transformation over the neighbors (both edges and vertices)_of each vertex. The neighborsFunction applied on the neighbors only has access to the vertex id_(not the vertex value) of the grouping vertex.__<p>For each vertex, the neighborsFunction can iterate over all neighbors of this vertex_with the specified direction, and emit any number of output elements, including none.__@param neighborsFunction the group reduce function to apply to the neighboring edges and vertices_of each vertex._@param direction the edge direction (in-, out-, all-)._@param <T> the output type_@return a DataSet containing elements of type T_@throws IllegalArgumentException;public <T> DataSet<T> groupReduceOnNeighbors(NeighborsFunction<K, VV, EV, T> neighborsFunction,_			EdgeDirection direction) throws IllegalArgumentException {_		switch (direction) {_		case IN:_			_			DataSet<Tuple3<K, Edge<K, EV>, Vertex<K, VV>>> edgesWithSources = edges_					.join(this.vertices).where(0).equalTo(0)_					.with(new ProjectVertexIdJoin<K, VV, EV>(1))_					.withForwardedFieldsFirst("f1->f0").name("Edge with source vertex ID")__			return edgesWithSources.groupBy(0).reduceGroup(_				new ApplyNeighborGroupReduceFunction<>(neighborsFunction)).name("Neighbors function")__		case OUT:_			_			DataSet<Tuple3<K, Edge<K, EV>, Vertex<K, VV>>> edgesWithTargets = edges_					.join(this.vertices).where(1).equalTo(0)_					.with(new ProjectVertexIdJoin<K, VV, EV>(0))_					.withForwardedFieldsFirst("f0").name("Edge with target vertex ID")__			return edgesWithTargets.groupBy(0).reduceGroup(_				new ApplyNeighborGroupReduceFunction<>(neighborsFunction)).name("Neighbors function")__		case ALL:_			_			DataSet<Tuple3<K, Edge<K, EV>, Vertex<K, VV>>> edgesWithNeighbors = edges_					.flatMap(new EmitOneEdgeWithNeighborPerNode<K, EV>()).name("Forward and reverse edges")_					.join(this.vertices).where(1).equalTo(0)_					.with(new ProjectEdgeWithNeighbor<K, VV, EV>()).name("Edge with vertex ID")___			return edgesWithNeighbors.groupBy(0).reduceGroup(_				new ApplyNeighborGroupReduceFunction<>(neighborsFunction)).name("Neighbors function")__		default:_			throw new IllegalArgumentException("Illegal edge direction")__		}_	};groups,by,vertex,and,computes,a,group,reduce,transformation,over,the,neighbors,both,edges,and,vertices,of,each,vertex,the,neighbors,function,applied,on,the,neighbors,only,has,access,to,the,vertex,id,not,the,vertex,value,of,the,grouping,vertex,p,for,each,vertex,the,neighbors,function,can,iterate,over,all,neighbors,of,this,vertex,with,the,specified,direction,and,emit,any,number,of,output,elements,including,none,param,neighbors,function,the,group,reduce,function,to,apply,to,the,neighboring,edges,and,vertices,of,each,vertex,param,direction,the,edge,direction,in,out,all,param,t,the,output,type,return,a,data,set,containing,elements,of,type,t,throws,illegal,argument,exception;public,t,data,set,t,group,reduce,on,neighbors,neighbors,function,k,vv,ev,t,neighbors,function,edge,direction,direction,throws,illegal,argument,exception,switch,direction,case,in,data,set,tuple3,k,edge,k,ev,vertex,k,vv,edges,with,sources,edges,join,this,vertices,where,0,equal,to,0,with,new,project,vertex,id,join,k,vv,ev,1,with,forwarded,fields,first,f1,f0,name,edge,with,source,vertex,id,return,edges,with,sources,group,by,0,reduce,group,new,apply,neighbor,group,reduce,function,neighbors,function,name,neighbors,function,case,out,data,set,tuple3,k,edge,k,ev,vertex,k,vv,edges,with,targets,edges,join,this,vertices,where,1,equal,to,0,with,new,project,vertex,id,join,k,vv,ev,0,with,forwarded,fields,first,f0,name,edge,with,target,vertex,id,return,edges,with,targets,group,by,0,reduce,group,new,apply,neighbor,group,reduce,function,neighbors,function,name,neighbors,function,case,all,data,set,tuple3,k,edge,k,ev,vertex,k,vv,edges,with,neighbors,edges,flat,map,new,emit,one,edge,with,neighbor,per,node,k,ev,name,forward,and,reverse,edges,join,this,vertices,where,1,equal,to,0,with,new,project,edge,with,neighbor,k,vv,ev,name,edge,with,vertex,id,return,edges,with,neighbors,group,by,0,reduce,group,new,apply,neighbor,group,reduce,function,neighbors,function,name,neighbors,function,default,throw,new,illegal,argument,exception,illegal,edge,direction
Graph -> public <T> DataSet<T> groupReduceOnNeighbors(NeighborsFunction<K, VV, EV, T> neighborsFunction, 			EdgeDirection direction) throws IllegalArgumentException;1502111816;Groups by vertex and computes a GroupReduce transformation over the neighbors (both edges and vertices)_of each vertex. The neighborsFunction applied on the neighbors only has access to the vertex id_(not the vertex value) of the grouping vertex.__<p>For each vertex, the neighborsFunction can iterate over all neighbors of this vertex_with the specified direction, and emit any number of output elements, including none.__@param neighborsFunction the group reduce function to apply to the neighboring edges and vertices_of each vertex._@param direction the edge direction (in-, out-, all-)._@param <T> the output type_@return a DataSet containing elements of type T_@throws IllegalArgumentException;public <T> DataSet<T> groupReduceOnNeighbors(NeighborsFunction<K, VV, EV, T> neighborsFunction,_			EdgeDirection direction) throws IllegalArgumentException {_		switch (direction) {_		case IN:_			_			DataSet<Tuple3<K, Edge<K, EV>, Vertex<K, VV>>> edgesWithSources = edges_					.join(this.vertices).where(0).equalTo(0)_					.with(new ProjectVertexIdJoin<>(1))_					.withForwardedFieldsFirst("f1->f0").name("Edge with source vertex ID")__			return edgesWithSources.groupBy(0).reduceGroup(_				new ApplyNeighborGroupReduceFunction<>(neighborsFunction)).name("Neighbors function")__		case OUT:_			_			DataSet<Tuple3<K, Edge<K, EV>, Vertex<K, VV>>> edgesWithTargets = edges_					.join(this.vertices).where(1).equalTo(0)_					.with(new ProjectVertexIdJoin<>(0))_					.withForwardedFieldsFirst("f0").name("Edge with target vertex ID")__			return edgesWithTargets.groupBy(0).reduceGroup(_				new ApplyNeighborGroupReduceFunction<>(neighborsFunction)).name("Neighbors function")__		case ALL:_			_			DataSet<Tuple3<K, Edge<K, EV>, Vertex<K, VV>>> edgesWithNeighbors = edges_					.flatMap(new EmitOneEdgeWithNeighborPerNode<>()).name("Forward and reverse edges")_					.join(this.vertices).where(1).equalTo(0)_					.with(new ProjectEdgeWithNeighbor<>()).name("Edge with vertex ID")___			return edgesWithNeighbors.groupBy(0).reduceGroup(_				new ApplyNeighborGroupReduceFunction<>(neighborsFunction)).name("Neighbors function")__		default:_			throw new IllegalArgumentException("Illegal edge direction")__		}_	};groups,by,vertex,and,computes,a,group,reduce,transformation,over,the,neighbors,both,edges,and,vertices,of,each,vertex,the,neighbors,function,applied,on,the,neighbors,only,has,access,to,the,vertex,id,not,the,vertex,value,of,the,grouping,vertex,p,for,each,vertex,the,neighbors,function,can,iterate,over,all,neighbors,of,this,vertex,with,the,specified,direction,and,emit,any,number,of,output,elements,including,none,param,neighbors,function,the,group,reduce,function,to,apply,to,the,neighboring,edges,and,vertices,of,each,vertex,param,direction,the,edge,direction,in,out,all,param,t,the,output,type,return,a,data,set,containing,elements,of,type,t,throws,illegal,argument,exception;public,t,data,set,t,group,reduce,on,neighbors,neighbors,function,k,vv,ev,t,neighbors,function,edge,direction,direction,throws,illegal,argument,exception,switch,direction,case,in,data,set,tuple3,k,edge,k,ev,vertex,k,vv,edges,with,sources,edges,join,this,vertices,where,0,equal,to,0,with,new,project,vertex,id,join,1,with,forwarded,fields,first,f1,f0,name,edge,with,source,vertex,id,return,edges,with,sources,group,by,0,reduce,group,new,apply,neighbor,group,reduce,function,neighbors,function,name,neighbors,function,case,out,data,set,tuple3,k,edge,k,ev,vertex,k,vv,edges,with,targets,edges,join,this,vertices,where,1,equal,to,0,with,new,project,vertex,id,join,0,with,forwarded,fields,first,f0,name,edge,with,target,vertex,id,return,edges,with,targets,group,by,0,reduce,group,new,apply,neighbor,group,reduce,function,neighbors,function,name,neighbors,function,case,all,data,set,tuple3,k,edge,k,ev,vertex,k,vv,edges,with,neighbors,edges,flat,map,new,emit,one,edge,with,neighbor,per,node,name,forward,and,reverse,edges,join,this,vertices,where,1,equal,to,0,with,new,project,edge,with,neighbor,name,edge,with,vertex,id,return,edges,with,neighbors,group,by,0,reduce,group,new,apply,neighbor,group,reduce,function,neighbors,function,name,neighbors,function,default,throw,new,illegal,argument,exception,illegal,edge,direction
Graph -> public DataSet<Tuple2<K, K>> getEdgeIds();1444404795;@return The IDs of the edges as DataSet;public DataSet<Tuple2<K, K>> getEdgeIds() {_		return edges.map(new ExtractEdgeIDsMapper<K, EV>())__	};return,the,ids,of,the,edges,as,data,set;public,data,set,tuple2,k,k,get,edge,ids,return,edges,map,new,extract,edge,ids,mapper,k,ev
Graph -> public DataSet<Tuple2<K, K>> getEdgeIds();1445261977;@return The IDs of the edges as DataSet;public DataSet<Tuple2<K, K>> getEdgeIds() {_		return edges.map(new ExtractEdgeIDsMapper<K, EV>())__	};return,the,ids,of,the,edges,as,data,set;public,data,set,tuple2,k,k,get,edge,ids,return,edges,map,new,extract,edge,ids,mapper,k,ev
Graph -> public DataSet<Tuple2<K, K>> getEdgeIds();1445854323;@return The IDs of the edges as DataSet;public DataSet<Tuple2<K, K>> getEdgeIds() {_		return edges.map(new ExtractEdgeIDsMapper<K, EV>())__	};return,the,ids,of,the,edges,as,data,set;public,data,set,tuple2,k,k,get,edge,ids,return,edges,map,new,extract,edge,ids,mapper,k,ev
Graph -> public DataSet<Tuple2<K, K>> getEdgeIds();1446112342;@return The IDs of the edges as DataSet;public DataSet<Tuple2<K, K>> getEdgeIds() {_		return edges.map(new ExtractEdgeIDsMapper<K, EV>())__	};return,the,ids,of,the,edges,as,data,set;public,data,set,tuple2,k,k,get,edge,ids,return,edges,map,new,extract,edge,ids,mapper,k,ev
Graph -> public DataSet<Tuple2<K, K>> getEdgeIds();1447073368;@return The IDs of the edges as DataSet;public DataSet<Tuple2<K, K>> getEdgeIds() {_		return edges.map(new ExtractEdgeIDsMapper<K, EV>())__	};return,the,ids,of,the,edges,as,data,set;public,data,set,tuple2,k,k,get,edge,ids,return,edges,map,new,extract,edge,ids,mapper,k,ev
Graph -> public DataSet<Tuple2<K, K>> getEdgeIds();1454404649;@return The IDs of the edges as DataSet;public DataSet<Tuple2<K, K>> getEdgeIds() {_		return edges.map(new ExtractEdgeIDsMapper<K, EV>())__	};return,the,ids,of,the,edges,as,data,set;public,data,set,tuple2,k,k,get,edge,ids,return,edges,map,new,extract,edge,ids,mapper,k,ev
Graph -> public DataSet<Tuple2<K, K>> getEdgeIds();1458583829;@return The IDs of the edges as DataSet;public DataSet<Tuple2<K, K>> getEdgeIds() {_		return edges.map(new ExtractEdgeIDsMapper<K, EV>())__	};return,the,ids,of,the,edges,as,data,set;public,data,set,tuple2,k,k,get,edge,ids,return,edges,map,new,extract,edge,ids,mapper,k,ev
Graph -> public DataSet<Tuple2<K, K>> getEdgeIds();1458583829;@return The IDs of the edges as DataSet;public DataSet<Tuple2<K, K>> getEdgeIds() {_		return edges.map(new ExtractEdgeIDsMapper<K, EV>())__	};return,the,ids,of,the,edges,as,data,set;public,data,set,tuple2,k,k,get,edge,ids,return,edges,map,new,extract,edge,ids,mapper,k,ev
Graph -> public DataSet<Tuple2<K, K>> getEdgeIds();1462100316;@return The IDs of the edges as DataSet;public DataSet<Tuple2<K, K>> getEdgeIds() {_		return edges.map(new ExtractEdgeIDsMapper<K, EV>())__	};return,the,ids,of,the,edges,as,data,set;public,data,set,tuple2,k,k,get,edge,ids,return,edges,map,new,extract,edge,ids,mapper,k,ev
Graph -> public DataSet<Tuple2<K, K>> getEdgeIds();1462100316;@return The IDs of the edges as DataSet;public DataSet<Tuple2<K, K>> getEdgeIds() {_		return edges.map(new ExtractEdgeIDsMapper<K, EV>())__	};return,the,ids,of,the,edges,as,data,set;public,data,set,tuple2,k,k,get,edge,ids,return,edges,map,new,extract,edge,ids,mapper,k,ev
Graph -> public DataSet<Tuple2<K, K>> getEdgeIds();1462205213;@return The IDs of the edges as DataSet;public DataSet<Tuple2<K, K>> getEdgeIds() {_		return edges.map(new ExtractEdgeIDsMapper<K, EV>())__	};return,the,ids,of,the,edges,as,data,set;public,data,set,tuple2,k,k,get,edge,ids,return,edges,map,new,extract,edge,ids,mapper,k,ev
Graph -> public DataSet<Tuple2<K, K>> getEdgeIds();1462208859;@return The IDs of the edges as DataSet;public DataSet<Tuple2<K, K>> getEdgeIds() {_		return edges.map(new ExtractEdgeIDsMapper<K, EV>())__	};return,the,ids,of,the,edges,as,data,set;public,data,set,tuple2,k,k,get,edge,ids,return,edges,map,new,extract,edge,ids,mapper,k,ev
Graph -> public DataSet<Tuple2<K, K>> getEdgeIds();1462809297;@return The IDs of the edges as DataSet;public DataSet<Tuple2<K, K>> getEdgeIds() {_		return edges.map(new ExtractEdgeIDsMapper<K, EV>())__	};return,the,ids,of,the,edges,as,data,set;public,data,set,tuple2,k,k,get,edge,ids,return,edges,map,new,extract,edge,ids,mapper,k,ev
Graph -> public DataSet<Tuple2<K, K>> getEdgeIds();1465316775;@return The IDs of the edges as DataSet;public DataSet<Tuple2<K, K>> getEdgeIds() {_		return edges.map(new ExtractEdgeIDsMapper<K, EV>())__	};return,the,ids,of,the,edges,as,data,set;public,data,set,tuple2,k,k,get,edge,ids,return,edges,map,new,extract,edge,ids,mapper,k,ev
Graph -> public DataSet<Tuple2<K, K>> getEdgeIds();1466789678;@return The IDs of the edges as DataSet;public DataSet<Tuple2<K, K>> getEdgeIds() {_		return edges.map(new ExtractEdgeIDsMapper<K, EV>())__	};return,the,ids,of,the,edges,as,data,set;public,data,set,tuple2,k,k,get,edge,ids,return,edges,map,new,extract,edge,ids,mapper,k,ev
Graph -> public DataSet<Tuple2<K, K>> getEdgeIds();1467140656;@return The IDs of the edges as DataSet;public DataSet<Tuple2<K, K>> getEdgeIds() {_		return edges.map(new ExtractEdgeIDsMapper<K, EV>())__	};return,the,ids,of,the,edges,as,data,set;public,data,set,tuple2,k,k,get,edge,ids,return,edges,map,new,extract,edge,ids,mapper,k,ev
Graph -> public DataSet<Tuple2<K, K>> getEdgeIds();1467306272;@return The IDs of the edges as DataSet;public DataSet<Tuple2<K, K>> getEdgeIds() {_		return edges.map(new ExtractEdgeIDsMapper<K, EV>())__	};return,the,ids,of,the,edges,as,data,set;public,data,set,tuple2,k,k,get,edge,ids,return,edges,map,new,extract,edge,ids,mapper,k,ev
Graph -> public DataSet<Tuple2<K, K>> getEdgeIds();1470042815;@return The IDs of the edges as DataSet;public DataSet<Tuple2<K, K>> getEdgeIds() {_		return edges.map(new ExtractEdgeIDsMapper<K, EV>())__	};return,the,ids,of,the,edges,as,data,set;public,data,set,tuple2,k,k,get,edge,ids,return,edges,map,new,extract,edge,ids,mapper,k,ev
Graph -> public DataSet<Tuple2<K, K>> getEdgeIds();1475684776;@return The IDs of the edges as DataSet;public DataSet<Tuple2<K, K>> getEdgeIds() {_		return edges.map(new ExtractEdgeIDsMapper<K, EV>())__	};return,the,ids,of,the,edges,as,data,set;public,data,set,tuple2,k,k,get,edge,ids,return,edges,map,new,extract,edge,ids,mapper,k,ev
Graph -> public DataSet<Tuple2<K, K>> getEdgeIds();1475685606;@return The IDs of the edges as DataSet;public DataSet<Tuple2<K, K>> getEdgeIds() {_		return edges.map(new ExtractEdgeIDsMapper<K, EV>())__	};return,the,ids,of,the,edges,as,data,set;public,data,set,tuple2,k,k,get,edge,ids,return,edges,map,new,extract,edge,ids,mapper,k,ev
Graph -> public DataSet<Tuple2<K, K>> getEdgeIds();1481745825;@return The IDs of the edges as DataSet;public DataSet<Tuple2<K, K>> getEdgeIds() {_		return edges.map(new ExtractEdgeIDsMapper<K, EV>()).name("Edge IDs")__	};return,the,ids,of,the,edges,as,data,set;public,data,set,tuple2,k,k,get,edge,ids,return,edges,map,new,extract,edge,ids,mapper,k,ev,name,edge,ids
Graph -> public DataSet<Tuple2<K, K>> getEdgeIds();1481881009;@return The IDs of the edges as DataSet;public DataSet<Tuple2<K, K>> getEdgeIds() {_		return edges.map(new ExtractEdgeIDsMapper<K, EV>()).name("Edge IDs")__	};return,the,ids,of,the,edges,as,data,set;public,data,set,tuple2,k,k,get,edge,ids,return,edges,map,new,extract,edge,ids,mapper,k,ev,name,edge,ids
Graph -> public DataSet<Tuple2<K, K>> getEdgeIds();1484160227;@return The IDs of the edges as DataSet;public DataSet<Tuple2<K, K>> getEdgeIds() {_		return edges.map(new ExtractEdgeIDsMapper<K, EV>()).name("Edge IDs")__	};return,the,ids,of,the,edges,as,data,set;public,data,set,tuple2,k,k,get,edge,ids,return,edges,map,new,extract,edge,ids,mapper,k,ev,name,edge,ids
Graph -> public DataSet<Tuple2<K, K>> getEdgeIds();1484685504;@return The IDs of the edges as DataSet;public DataSet<Tuple2<K, K>> getEdgeIds() {_		return edges.map(new ExtractEdgeIDsMapper<K, EV>()).name("Edge IDs")__	};return,the,ids,of,the,edges,as,data,set;public,data,set,tuple2,k,k,get,edge,ids,return,edges,map,new,extract,edge,ids,mapper,k,ev,name,edge,ids
Graph -> public DataSet<Tuple2<K, K>> getEdgeIds();1489068942;@return The IDs of the edges as DataSet;public DataSet<Tuple2<K, K>> getEdgeIds() {_		return edges.map(new ExtractEdgeIDsMapper<K, EV>()).name("Edge IDs")__	};return,the,ids,of,the,edges,as,data,set;public,data,set,tuple2,k,k,get,edge,ids,return,edges,map,new,extract,edge,ids,mapper,k,ev,name,edge,ids
Graph -> public DataSet<Tuple2<K, K>> getEdgeIds();1490973446;@return The IDs of the edges as DataSet;public DataSet<Tuple2<K, K>> getEdgeIds() {_		return edges.map(new ExtractEdgeIDsMapper<K, EV>()).name("Edge IDs")__	};return,the,ids,of,the,edges,as,data,set;public,data,set,tuple2,k,k,get,edge,ids,return,edges,map,new,extract,edge,ids,mapper,k,ev,name,edge,ids
Graph -> public DataSet<Tuple2<K, K>> getEdgeIds();1495819075;@return The IDs of the edges as DataSet;public DataSet<Tuple2<K, K>> getEdgeIds() {_		return edges.map(new ExtractEdgeIDsMapper<K, EV>()).name("Edge IDs")__	};return,the,ids,of,the,edges,as,data,set;public,data,set,tuple2,k,k,get,edge,ids,return,edges,map,new,extract,edge,ids,mapper,k,ev,name,edge,ids
Graph -> public DataSet<Tuple2<K, K>> getEdgeIds();1502111816;@return The IDs of the edges as DataSet;public DataSet<Tuple2<K, K>> getEdgeIds() {_		return edges.map(new ExtractEdgeIDsMapper<>()).name("Edge IDs")__	};return,the,ids,of,the,edges,as,data,set;public,data,set,tuple2,k,k,get,edge,ids,return,edges,map,new,extract,edge,ids,mapper,name,edge,ids
Graph -> public Graph<K, VV, EV> addEdges(List<Edge<K, EV>> newEdges);1444404795;Adds the given list edges to the graph.__When adding an edge for a non-existing set of vertices, the edge is considered invalid and ignored.__@param newEdges the data set of edges to be added_@return a new graph containing the existing edges plus the newly added edges.;public Graph<K, VV, EV> addEdges(List<Edge<K, EV>> newEdges) {__		DataSet<Edge<K,EV>> newEdgesDataSet = this.context.fromCollection(newEdges)___		DataSet<Edge<K,EV>> validNewEdges = this.getVertices().join(newEdgesDataSet)_				.where(0).equalTo(0)_				.with(new JoinVerticesWithEdgesOnSrc<K, VV, EV>())_				.join(this.getVertices()).where(1).equalTo(0)_				.with(new JoinWithVerticesOnTrg<K, VV, EV>())___		return Graph.fromDataSet(this.vertices, this.edges.union(validNewEdges), this.context)__	};adds,the,given,list,edges,to,the,graph,when,adding,an,edge,for,a,non,existing,set,of,vertices,the,edge,is,considered,invalid,and,ignored,param,new,edges,the,data,set,of,edges,to,be,added,return,a,new,graph,containing,the,existing,edges,plus,the,newly,added,edges;public,graph,k,vv,ev,add,edges,list,edge,k,ev,new,edges,data,set,edge,k,ev,new,edges,data,set,this,context,from,collection,new,edges,data,set,edge,k,ev,valid,new,edges,this,get,vertices,join,new,edges,data,set,where,0,equal,to,0,with,new,join,vertices,with,edges,on,src,k,vv,ev,join,this,get,vertices,where,1,equal,to,0,with,new,join,with,vertices,on,trg,k,vv,ev,return,graph,from,data,set,this,vertices,this,edges,union,valid,new,edges,this,context
Graph -> public Graph<K, VV, EV> addEdges(List<Edge<K, EV>> newEdges);1445261977;Adds the given list edges to the graph.__When adding an edge for a non-existing set of vertices, the edge is considered invalid and ignored.__@param newEdges the data set of edges to be added_@return a new graph containing the existing edges plus the newly added edges.;public Graph<K, VV, EV> addEdges(List<Edge<K, EV>> newEdges) {__		DataSet<Edge<K,EV>> newEdgesDataSet = this.context.fromCollection(newEdges)___		DataSet<Edge<K,EV>> validNewEdges = this.getVertices().join(newEdgesDataSet)_				.where(0).equalTo(0)_				.with(new JoinVerticesWithEdgesOnSrc<K, VV, EV>())_				.join(this.getVertices()).where(1).equalTo(0)_				.with(new JoinWithVerticesOnTrg<K, VV, EV>())___		return Graph.fromDataSet(this.vertices, this.edges.union(validNewEdges), this.context)__	};adds,the,given,list,edges,to,the,graph,when,adding,an,edge,for,a,non,existing,set,of,vertices,the,edge,is,considered,invalid,and,ignored,param,new,edges,the,data,set,of,edges,to,be,added,return,a,new,graph,containing,the,existing,edges,plus,the,newly,added,edges;public,graph,k,vv,ev,add,edges,list,edge,k,ev,new,edges,data,set,edge,k,ev,new,edges,data,set,this,context,from,collection,new,edges,data,set,edge,k,ev,valid,new,edges,this,get,vertices,join,new,edges,data,set,where,0,equal,to,0,with,new,join,vertices,with,edges,on,src,k,vv,ev,join,this,get,vertices,where,1,equal,to,0,with,new,join,with,vertices,on,trg,k,vv,ev,return,graph,from,data,set,this,vertices,this,edges,union,valid,new,edges,this,context
Graph -> public Graph<K, VV, EV> addEdges(List<Edge<K, EV>> newEdges);1445854323;Adds the given list edges to the graph.__When adding an edge for a non-existing set of vertices, the edge is considered invalid and ignored.__@param newEdges the data set of edges to be added_@return a new graph containing the existing edges plus the newly added edges.;public Graph<K, VV, EV> addEdges(List<Edge<K, EV>> newEdges) {__		DataSet<Edge<K,EV>> newEdgesDataSet = this.context.fromCollection(newEdges)___		DataSet<Edge<K,EV>> validNewEdges = this.getVertices().join(newEdgesDataSet)_				.where(0).equalTo(0)_				.with(new JoinVerticesWithEdgesOnSrc<K, VV, EV>())_				.join(this.getVertices()).where(1).equalTo(0)_				.with(new JoinWithVerticesOnTrg<K, VV, EV>())___		return Graph.fromDataSet(this.vertices, this.edges.union(validNewEdges), this.context)__	};adds,the,given,list,edges,to,the,graph,when,adding,an,edge,for,a,non,existing,set,of,vertices,the,edge,is,considered,invalid,and,ignored,param,new,edges,the,data,set,of,edges,to,be,added,return,a,new,graph,containing,the,existing,edges,plus,the,newly,added,edges;public,graph,k,vv,ev,add,edges,list,edge,k,ev,new,edges,data,set,edge,k,ev,new,edges,data,set,this,context,from,collection,new,edges,data,set,edge,k,ev,valid,new,edges,this,get,vertices,join,new,edges,data,set,where,0,equal,to,0,with,new,join,vertices,with,edges,on,src,k,vv,ev,join,this,get,vertices,where,1,equal,to,0,with,new,join,with,vertices,on,trg,k,vv,ev,return,graph,from,data,set,this,vertices,this,edges,union,valid,new,edges,this,context
Graph -> public Graph<K, VV, EV> addEdges(List<Edge<K, EV>> newEdges);1446112342;Adds the given list edges to the graph.__When adding an edge for a non-existing set of vertices, the edge is considered invalid and ignored.__@param newEdges the data set of edges to be added_@return a new graph containing the existing edges plus the newly added edges.;public Graph<K, VV, EV> addEdges(List<Edge<K, EV>> newEdges) {__		DataSet<Edge<K,EV>> newEdgesDataSet = this.context.fromCollection(newEdges)___		DataSet<Edge<K,EV>> validNewEdges = this.getVertices().join(newEdgesDataSet)_				.where(0).equalTo(0)_				.with(new JoinVerticesWithEdgesOnSrc<K, VV, EV>())_				.join(this.getVertices()).where(1).equalTo(0)_				.with(new JoinWithVerticesOnTrg<K, VV, EV>())___		return Graph.fromDataSet(this.vertices, this.edges.union(validNewEdges), this.context)__	};adds,the,given,list,edges,to,the,graph,when,adding,an,edge,for,a,non,existing,set,of,vertices,the,edge,is,considered,invalid,and,ignored,param,new,edges,the,data,set,of,edges,to,be,added,return,a,new,graph,containing,the,existing,edges,plus,the,newly,added,edges;public,graph,k,vv,ev,add,edges,list,edge,k,ev,new,edges,data,set,edge,k,ev,new,edges,data,set,this,context,from,collection,new,edges,data,set,edge,k,ev,valid,new,edges,this,get,vertices,join,new,edges,data,set,where,0,equal,to,0,with,new,join,vertices,with,edges,on,src,k,vv,ev,join,this,get,vertices,where,1,equal,to,0,with,new,join,with,vertices,on,trg,k,vv,ev,return,graph,from,data,set,this,vertices,this,edges,union,valid,new,edges,this,context
Graph -> public Graph<K, VV, EV> addEdges(List<Edge<K, EV>> newEdges);1447073368;Adds the given list edges to the graph.__When adding an edge for a non-existing set of vertices, the edge is considered invalid and ignored.__@param newEdges the data set of edges to be added_@return a new graph containing the existing edges plus the newly added edges.;public Graph<K, VV, EV> addEdges(List<Edge<K, EV>> newEdges) {__		DataSet<Edge<K,EV>> newEdgesDataSet = this.context.fromCollection(newEdges)___		DataSet<Edge<K,EV>> validNewEdges = this.getVertices().join(newEdgesDataSet)_				.where(0).equalTo(0)_				.with(new JoinVerticesWithEdgesOnSrc<K, VV, EV>())_				.join(this.getVertices()).where(1).equalTo(0)_				.with(new JoinWithVerticesOnTrg<K, VV, EV>())___		return Graph.fromDataSet(this.vertices, this.edges.union(validNewEdges), this.context)__	};adds,the,given,list,edges,to,the,graph,when,adding,an,edge,for,a,non,existing,set,of,vertices,the,edge,is,considered,invalid,and,ignored,param,new,edges,the,data,set,of,edges,to,be,added,return,a,new,graph,containing,the,existing,edges,plus,the,newly,added,edges;public,graph,k,vv,ev,add,edges,list,edge,k,ev,new,edges,data,set,edge,k,ev,new,edges,data,set,this,context,from,collection,new,edges,data,set,edge,k,ev,valid,new,edges,this,get,vertices,join,new,edges,data,set,where,0,equal,to,0,with,new,join,vertices,with,edges,on,src,k,vv,ev,join,this,get,vertices,where,1,equal,to,0,with,new,join,with,vertices,on,trg,k,vv,ev,return,graph,from,data,set,this,vertices,this,edges,union,valid,new,edges,this,context
Graph -> public Graph<K, VV, EV> addEdges(List<Edge<K, EV>> newEdges);1454404649;Adds the given list edges to the graph.__When adding an edge for a non-existing set of vertices, the edge is considered invalid and ignored.__@param newEdges the data set of edges to be added_@return a new graph containing the existing edges plus the newly added edges.;public Graph<K, VV, EV> addEdges(List<Edge<K, EV>> newEdges) {__		DataSet<Edge<K,EV>> newEdgesDataSet = this.context.fromCollection(newEdges)___		DataSet<Edge<K,EV>> validNewEdges = this.getVertices().join(newEdgesDataSet)_				.where(0).equalTo(0)_				.with(new JoinVerticesWithEdgesOnSrc<K, VV, EV>())_				.join(this.getVertices()).where(1).equalTo(0)_				.with(new JoinWithVerticesOnTrg<K, VV, EV>())___		return Graph.fromDataSet(this.vertices, this.edges.union(validNewEdges), this.context)__	};adds,the,given,list,edges,to,the,graph,when,adding,an,edge,for,a,non,existing,set,of,vertices,the,edge,is,considered,invalid,and,ignored,param,new,edges,the,data,set,of,edges,to,be,added,return,a,new,graph,containing,the,existing,edges,plus,the,newly,added,edges;public,graph,k,vv,ev,add,edges,list,edge,k,ev,new,edges,data,set,edge,k,ev,new,edges,data,set,this,context,from,collection,new,edges,data,set,edge,k,ev,valid,new,edges,this,get,vertices,join,new,edges,data,set,where,0,equal,to,0,with,new,join,vertices,with,edges,on,src,k,vv,ev,join,this,get,vertices,where,1,equal,to,0,with,new,join,with,vertices,on,trg,k,vv,ev,return,graph,from,data,set,this,vertices,this,edges,union,valid,new,edges,this,context
Graph -> public Graph<K, VV, EV> addEdges(List<Edge<K, EV>> newEdges);1458583829;Adds the given list edges to the graph.__When adding an edge for a non-existing set of vertices, the edge is considered invalid and ignored.__@param newEdges the data set of edges to be added_@return a new graph containing the existing edges plus the newly added edges.;public Graph<K, VV, EV> addEdges(List<Edge<K, EV>> newEdges) {__		DataSet<Edge<K,EV>> newEdgesDataSet = this.context.fromCollection(newEdges)___		DataSet<Edge<K,EV>> validNewEdges = this.getVertices().join(newEdgesDataSet)_				.where(0).equalTo(0)_				.with(new JoinVerticesWithEdgesOnSrc<K, VV, EV>())_				.join(this.getVertices()).where(1).equalTo(0)_				.with(new JoinWithVerticesOnTrg<K, VV, EV>())___		return Graph.fromDataSet(this.vertices, this.edges.union(validNewEdges), this.context)__	};adds,the,given,list,edges,to,the,graph,when,adding,an,edge,for,a,non,existing,set,of,vertices,the,edge,is,considered,invalid,and,ignored,param,new,edges,the,data,set,of,edges,to,be,added,return,a,new,graph,containing,the,existing,edges,plus,the,newly,added,edges;public,graph,k,vv,ev,add,edges,list,edge,k,ev,new,edges,data,set,edge,k,ev,new,edges,data,set,this,context,from,collection,new,edges,data,set,edge,k,ev,valid,new,edges,this,get,vertices,join,new,edges,data,set,where,0,equal,to,0,with,new,join,vertices,with,edges,on,src,k,vv,ev,join,this,get,vertices,where,1,equal,to,0,with,new,join,with,vertices,on,trg,k,vv,ev,return,graph,from,data,set,this,vertices,this,edges,union,valid,new,edges,this,context
Graph -> public Graph<K, VV, EV> addEdges(List<Edge<K, EV>> newEdges);1458583829;Adds the given list edges to the graph.__When adding an edge for a non-existing set of vertices, the edge is considered invalid and ignored.__@param newEdges the data set of edges to be added_@return a new graph containing the existing edges plus the newly added edges.;public Graph<K, VV, EV> addEdges(List<Edge<K, EV>> newEdges) {__		DataSet<Edge<K,EV>> newEdgesDataSet = this.context.fromCollection(newEdges)___		DataSet<Edge<K,EV>> validNewEdges = this.getVertices().join(newEdgesDataSet)_				.where(0).equalTo(0)_				.with(new JoinVerticesWithEdgesOnSrc<K, VV, EV>())_				.join(this.getVertices()).where(1).equalTo(0)_				.with(new JoinWithVerticesOnTrg<K, VV, EV>())___		return Graph.fromDataSet(this.vertices, this.edges.union(validNewEdges), this.context)__	};adds,the,given,list,edges,to,the,graph,when,adding,an,edge,for,a,non,existing,set,of,vertices,the,edge,is,considered,invalid,and,ignored,param,new,edges,the,data,set,of,edges,to,be,added,return,a,new,graph,containing,the,existing,edges,plus,the,newly,added,edges;public,graph,k,vv,ev,add,edges,list,edge,k,ev,new,edges,data,set,edge,k,ev,new,edges,data,set,this,context,from,collection,new,edges,data,set,edge,k,ev,valid,new,edges,this,get,vertices,join,new,edges,data,set,where,0,equal,to,0,with,new,join,vertices,with,edges,on,src,k,vv,ev,join,this,get,vertices,where,1,equal,to,0,with,new,join,with,vertices,on,trg,k,vv,ev,return,graph,from,data,set,this,vertices,this,edges,union,valid,new,edges,this,context
Graph -> public Graph<K, VV, EV> addEdges(List<Edge<K, EV>> newEdges);1462100316;Adds the given list edges to the graph.__When adding an edge for a non-existing set of vertices, the edge is considered invalid and ignored.__@param newEdges the data set of edges to be added_@return a new graph containing the existing edges plus the newly added edges.;public Graph<K, VV, EV> addEdges(List<Edge<K, EV>> newEdges) {__		DataSet<Edge<K,EV>> newEdgesDataSet = this.context.fromCollection(newEdges)___		DataSet<Edge<K,EV>> validNewEdges = this.getVertices().join(newEdgesDataSet)_				.where(0).equalTo(0)_				.with(new JoinVerticesWithEdgesOnSrc<K, VV, EV>())_				.join(this.getVertices()).where(1).equalTo(0)_				.with(new JoinWithVerticesOnTrg<K, VV, EV>())___		return Graph.fromDataSet(this.vertices, this.edges.union(validNewEdges), this.context)__	};adds,the,given,list,edges,to,the,graph,when,adding,an,edge,for,a,non,existing,set,of,vertices,the,edge,is,considered,invalid,and,ignored,param,new,edges,the,data,set,of,edges,to,be,added,return,a,new,graph,containing,the,existing,edges,plus,the,newly,added,edges;public,graph,k,vv,ev,add,edges,list,edge,k,ev,new,edges,data,set,edge,k,ev,new,edges,data,set,this,context,from,collection,new,edges,data,set,edge,k,ev,valid,new,edges,this,get,vertices,join,new,edges,data,set,where,0,equal,to,0,with,new,join,vertices,with,edges,on,src,k,vv,ev,join,this,get,vertices,where,1,equal,to,0,with,new,join,with,vertices,on,trg,k,vv,ev,return,graph,from,data,set,this,vertices,this,edges,union,valid,new,edges,this,context
Graph -> public Graph<K, VV, EV> addEdges(List<Edge<K, EV>> newEdges);1462100316;Adds the given list edges to the graph.__When adding an edge for a non-existing set of vertices, the edge is considered invalid and ignored.__@param newEdges the data set of edges to be added_@return a new graph containing the existing edges plus the newly added edges.;public Graph<K, VV, EV> addEdges(List<Edge<K, EV>> newEdges) {__		DataSet<Edge<K,EV>> newEdgesDataSet = this.context.fromCollection(newEdges)___		DataSet<Edge<K,EV>> validNewEdges = this.getVertices().join(newEdgesDataSet)_				.where(0).equalTo(0)_				.with(new JoinVerticesWithEdgesOnSrc<K, VV, EV>())_				.join(this.getVertices()).where(1).equalTo(0)_				.with(new JoinWithVerticesOnTrg<K, VV, EV>())___		return Graph.fromDataSet(this.vertices, this.edges.union(validNewEdges), this.context)__	};adds,the,given,list,edges,to,the,graph,when,adding,an,edge,for,a,non,existing,set,of,vertices,the,edge,is,considered,invalid,and,ignored,param,new,edges,the,data,set,of,edges,to,be,added,return,a,new,graph,containing,the,existing,edges,plus,the,newly,added,edges;public,graph,k,vv,ev,add,edges,list,edge,k,ev,new,edges,data,set,edge,k,ev,new,edges,data,set,this,context,from,collection,new,edges,data,set,edge,k,ev,valid,new,edges,this,get,vertices,join,new,edges,data,set,where,0,equal,to,0,with,new,join,vertices,with,edges,on,src,k,vv,ev,join,this,get,vertices,where,1,equal,to,0,with,new,join,with,vertices,on,trg,k,vv,ev,return,graph,from,data,set,this,vertices,this,edges,union,valid,new,edges,this,context
Graph -> public Graph<K, VV, EV> addEdges(List<Edge<K, EV>> newEdges);1462205213;Adds the given list edges to the graph.__When adding an edge for a non-existing set of vertices, the edge is considered invalid and ignored.__@param newEdges the data set of edges to be added_@return a new graph containing the existing edges plus the newly added edges.;public Graph<K, VV, EV> addEdges(List<Edge<K, EV>> newEdges) {__		DataSet<Edge<K,EV>> newEdgesDataSet = this.context.fromCollection(newEdges)___		DataSet<Edge<K,EV>> validNewEdges = this.getVertices().join(newEdgesDataSet)_				.where(0).equalTo(0)_				.with(new JoinVerticesWithEdgesOnSrc<K, VV, EV>())_				.join(this.getVertices()).where(1).equalTo(0)_				.with(new JoinWithVerticesOnTrg<K, VV, EV>())___		return Graph.fromDataSet(this.vertices, this.edges.union(validNewEdges), this.context)__	};adds,the,given,list,edges,to,the,graph,when,adding,an,edge,for,a,non,existing,set,of,vertices,the,edge,is,considered,invalid,and,ignored,param,new,edges,the,data,set,of,edges,to,be,added,return,a,new,graph,containing,the,existing,edges,plus,the,newly,added,edges;public,graph,k,vv,ev,add,edges,list,edge,k,ev,new,edges,data,set,edge,k,ev,new,edges,data,set,this,context,from,collection,new,edges,data,set,edge,k,ev,valid,new,edges,this,get,vertices,join,new,edges,data,set,where,0,equal,to,0,with,new,join,vertices,with,edges,on,src,k,vv,ev,join,this,get,vertices,where,1,equal,to,0,with,new,join,with,vertices,on,trg,k,vv,ev,return,graph,from,data,set,this,vertices,this,edges,union,valid,new,edges,this,context
Graph -> public Graph<K, VV, EV> addEdges(List<Edge<K, EV>> newEdges);1462208859;Adds the given list edges to the graph.__When adding an edge for a non-existing set of vertices, the edge is considered invalid and ignored.__@param newEdges the data set of edges to be added_@return a new graph containing the existing edges plus the newly added edges.;public Graph<K, VV, EV> addEdges(List<Edge<K, EV>> newEdges) {__		DataSet<Edge<K,EV>> newEdgesDataSet = this.context.fromCollection(newEdges)___		DataSet<Edge<K,EV>> validNewEdges = this.getVertices().join(newEdgesDataSet)_				.where(0).equalTo(0)_				.with(new JoinVerticesWithEdgesOnSrc<K, VV, EV>())_				.join(this.getVertices()).where(1).equalTo(0)_				.with(new JoinWithVerticesOnTrg<K, VV, EV>())___		return Graph.fromDataSet(this.vertices, this.edges.union(validNewEdges), this.context)__	};adds,the,given,list,edges,to,the,graph,when,adding,an,edge,for,a,non,existing,set,of,vertices,the,edge,is,considered,invalid,and,ignored,param,new,edges,the,data,set,of,edges,to,be,added,return,a,new,graph,containing,the,existing,edges,plus,the,newly,added,edges;public,graph,k,vv,ev,add,edges,list,edge,k,ev,new,edges,data,set,edge,k,ev,new,edges,data,set,this,context,from,collection,new,edges,data,set,edge,k,ev,valid,new,edges,this,get,vertices,join,new,edges,data,set,where,0,equal,to,0,with,new,join,vertices,with,edges,on,src,k,vv,ev,join,this,get,vertices,where,1,equal,to,0,with,new,join,with,vertices,on,trg,k,vv,ev,return,graph,from,data,set,this,vertices,this,edges,union,valid,new,edges,this,context
Graph -> public Graph<K, VV, EV> addEdges(List<Edge<K, EV>> newEdges);1462809297;Adds the given list edges to the graph.__When adding an edge for a non-existing set of vertices, the edge is considered invalid and ignored.__@param newEdges the data set of edges to be added_@return a new graph containing the existing edges plus the newly added edges.;public Graph<K, VV, EV> addEdges(List<Edge<K, EV>> newEdges) {__		DataSet<Edge<K,EV>> newEdgesDataSet = this.context.fromCollection(newEdges)___		DataSet<Edge<K,EV>> validNewEdges = this.getVertices().join(newEdgesDataSet)_				.where(0).equalTo(0)_				.with(new JoinVerticesWithEdgesOnSrc<K, VV, EV>())_				.join(this.getVertices()).where(1).equalTo(0)_				.with(new JoinWithVerticesOnTrg<K, VV, EV>())___		return Graph.fromDataSet(this.vertices, this.edges.union(validNewEdges), this.context)__	};adds,the,given,list,edges,to,the,graph,when,adding,an,edge,for,a,non,existing,set,of,vertices,the,edge,is,considered,invalid,and,ignored,param,new,edges,the,data,set,of,edges,to,be,added,return,a,new,graph,containing,the,existing,edges,plus,the,newly,added,edges;public,graph,k,vv,ev,add,edges,list,edge,k,ev,new,edges,data,set,edge,k,ev,new,edges,data,set,this,context,from,collection,new,edges,data,set,edge,k,ev,valid,new,edges,this,get,vertices,join,new,edges,data,set,where,0,equal,to,0,with,new,join,vertices,with,edges,on,src,k,vv,ev,join,this,get,vertices,where,1,equal,to,0,with,new,join,with,vertices,on,trg,k,vv,ev,return,graph,from,data,set,this,vertices,this,edges,union,valid,new,edges,this,context
Graph -> public Graph<K, VV, EV> addEdges(List<Edge<K, EV>> newEdges);1465316775;Adds the given list edges to the graph.__When adding an edge for a non-existing set of vertices, the edge is considered invalid and ignored.__@param newEdges the data set of edges to be added_@return a new graph containing the existing edges plus the newly added edges.;public Graph<K, VV, EV> addEdges(List<Edge<K, EV>> newEdges) {__		DataSet<Edge<K,EV>> newEdgesDataSet = this.context.fromCollection(newEdges)___		DataSet<Edge<K,EV>> validNewEdges = this.getVertices().join(newEdgesDataSet)_				.where(0).equalTo(0)_				.with(new JoinVerticesWithEdgesOnSrc<K, VV, EV>())_				.join(this.getVertices()).where(1).equalTo(0)_				.with(new JoinWithVerticesOnTrg<K, VV, EV>())___		return Graph.fromDataSet(this.vertices, this.edges.union(validNewEdges), this.context)__	};adds,the,given,list,edges,to,the,graph,when,adding,an,edge,for,a,non,existing,set,of,vertices,the,edge,is,considered,invalid,and,ignored,param,new,edges,the,data,set,of,edges,to,be,added,return,a,new,graph,containing,the,existing,edges,plus,the,newly,added,edges;public,graph,k,vv,ev,add,edges,list,edge,k,ev,new,edges,data,set,edge,k,ev,new,edges,data,set,this,context,from,collection,new,edges,data,set,edge,k,ev,valid,new,edges,this,get,vertices,join,new,edges,data,set,where,0,equal,to,0,with,new,join,vertices,with,edges,on,src,k,vv,ev,join,this,get,vertices,where,1,equal,to,0,with,new,join,with,vertices,on,trg,k,vv,ev,return,graph,from,data,set,this,vertices,this,edges,union,valid,new,edges,this,context
Graph -> public Graph<K, VV, EV> addEdges(List<Edge<K, EV>> newEdges);1466789678;Adds the given list edges to the graph.__When adding an edge for a non-existing set of vertices, the edge is considered invalid and ignored.__@param newEdges the data set of edges to be added_@return a new graph containing the existing edges plus the newly added edges.;public Graph<K, VV, EV> addEdges(List<Edge<K, EV>> newEdges) {__		DataSet<Edge<K,EV>> newEdgesDataSet = this.context.fromCollection(newEdges)___		DataSet<Edge<K,EV>> validNewEdges = this.getVertices().join(newEdgesDataSet)_				.where(0).equalTo(0)_				.with(new JoinVerticesWithEdgesOnSrc<K, VV, EV>())_				.join(this.getVertices()).where(1).equalTo(0)_				.with(new JoinWithVerticesOnTrg<K, VV, EV>())___		return Graph.fromDataSet(this.vertices, this.edges.union(validNewEdges), this.context)__	};adds,the,given,list,edges,to,the,graph,when,adding,an,edge,for,a,non,existing,set,of,vertices,the,edge,is,considered,invalid,and,ignored,param,new,edges,the,data,set,of,edges,to,be,added,return,a,new,graph,containing,the,existing,edges,plus,the,newly,added,edges;public,graph,k,vv,ev,add,edges,list,edge,k,ev,new,edges,data,set,edge,k,ev,new,edges,data,set,this,context,from,collection,new,edges,data,set,edge,k,ev,valid,new,edges,this,get,vertices,join,new,edges,data,set,where,0,equal,to,0,with,new,join,vertices,with,edges,on,src,k,vv,ev,join,this,get,vertices,where,1,equal,to,0,with,new,join,with,vertices,on,trg,k,vv,ev,return,graph,from,data,set,this,vertices,this,edges,union,valid,new,edges,this,context
Graph -> public Graph<K, VV, EV> addEdges(List<Edge<K, EV>> newEdges);1467140656;Adds the given list edges to the graph.__When adding an edge for a non-existing set of vertices, the edge is considered invalid and ignored.__@param newEdges the data set of edges to be added_@return a new graph containing the existing edges plus the newly added edges.;public Graph<K, VV, EV> addEdges(List<Edge<K, EV>> newEdges) {__		DataSet<Edge<K,EV>> newEdgesDataSet = this.context.fromCollection(newEdges)___		DataSet<Edge<K,EV>> validNewEdges = this.getVertices().join(newEdgesDataSet)_				.where(0).equalTo(0)_				.with(new JoinVerticesWithEdgesOnSrc<K, VV, EV>())_				.join(this.getVertices()).where(1).equalTo(0)_				.with(new JoinWithVerticesOnTrg<K, VV, EV>())___		return Graph.fromDataSet(this.vertices, this.edges.union(validNewEdges), this.context)__	};adds,the,given,list,edges,to,the,graph,when,adding,an,edge,for,a,non,existing,set,of,vertices,the,edge,is,considered,invalid,and,ignored,param,new,edges,the,data,set,of,edges,to,be,added,return,a,new,graph,containing,the,existing,edges,plus,the,newly,added,edges;public,graph,k,vv,ev,add,edges,list,edge,k,ev,new,edges,data,set,edge,k,ev,new,edges,data,set,this,context,from,collection,new,edges,data,set,edge,k,ev,valid,new,edges,this,get,vertices,join,new,edges,data,set,where,0,equal,to,0,with,new,join,vertices,with,edges,on,src,k,vv,ev,join,this,get,vertices,where,1,equal,to,0,with,new,join,with,vertices,on,trg,k,vv,ev,return,graph,from,data,set,this,vertices,this,edges,union,valid,new,edges,this,context
Graph -> public Graph<K, VV, EV> addEdges(List<Edge<K, EV>> newEdges);1467306272;Adds the given list edges to the graph.__When adding an edge for a non-existing set of vertices, the edge is considered invalid and ignored.__@param newEdges the data set of edges to be added_@return a new graph containing the existing edges plus the newly added edges.;public Graph<K, VV, EV> addEdges(List<Edge<K, EV>> newEdges) {__		DataSet<Edge<K,EV>> newEdgesDataSet = this.context.fromCollection(newEdges)___		DataSet<Edge<K,EV>> validNewEdges = this.getVertices().join(newEdgesDataSet)_				.where(0).equalTo(0)_				.with(new JoinVerticesWithEdgesOnSrc<K, VV, EV>())_				.join(this.getVertices()).where(1).equalTo(0)_				.with(new JoinWithVerticesOnTrg<K, VV, EV>())___		return Graph.fromDataSet(this.vertices, this.edges.union(validNewEdges), this.context)__	};adds,the,given,list,edges,to,the,graph,when,adding,an,edge,for,a,non,existing,set,of,vertices,the,edge,is,considered,invalid,and,ignored,param,new,edges,the,data,set,of,edges,to,be,added,return,a,new,graph,containing,the,existing,edges,plus,the,newly,added,edges;public,graph,k,vv,ev,add,edges,list,edge,k,ev,new,edges,data,set,edge,k,ev,new,edges,data,set,this,context,from,collection,new,edges,data,set,edge,k,ev,valid,new,edges,this,get,vertices,join,new,edges,data,set,where,0,equal,to,0,with,new,join,vertices,with,edges,on,src,k,vv,ev,join,this,get,vertices,where,1,equal,to,0,with,new,join,with,vertices,on,trg,k,vv,ev,return,graph,from,data,set,this,vertices,this,edges,union,valid,new,edges,this,context
Graph -> public Graph<K, VV, EV> addEdges(List<Edge<K, EV>> newEdges);1470042815;Adds the given list edges to the graph.__When adding an edge for a non-existing set of vertices, the edge is considered invalid and ignored.__@param newEdges the data set of edges to be added_@return a new graph containing the existing edges plus the newly added edges.;public Graph<K, VV, EV> addEdges(List<Edge<K, EV>> newEdges) {__		DataSet<Edge<K,EV>> newEdgesDataSet = this.context.fromCollection(newEdges)___		DataSet<Edge<K,EV>> validNewEdges = this.getVertices().join(newEdgesDataSet)_				.where(0).equalTo(0)_				.with(new JoinVerticesWithEdgesOnSrc<K, VV, EV>())_				.join(this.getVertices()).where(1).equalTo(0)_				.with(new JoinWithVerticesOnTrg<K, VV, EV>())___		return Graph.fromDataSet(this.vertices, this.edges.union(validNewEdges), this.context)__	};adds,the,given,list,edges,to,the,graph,when,adding,an,edge,for,a,non,existing,set,of,vertices,the,edge,is,considered,invalid,and,ignored,param,new,edges,the,data,set,of,edges,to,be,added,return,a,new,graph,containing,the,existing,edges,plus,the,newly,added,edges;public,graph,k,vv,ev,add,edges,list,edge,k,ev,new,edges,data,set,edge,k,ev,new,edges,data,set,this,context,from,collection,new,edges,data,set,edge,k,ev,valid,new,edges,this,get,vertices,join,new,edges,data,set,where,0,equal,to,0,with,new,join,vertices,with,edges,on,src,k,vv,ev,join,this,get,vertices,where,1,equal,to,0,with,new,join,with,vertices,on,trg,k,vv,ev,return,graph,from,data,set,this,vertices,this,edges,union,valid,new,edges,this,context
Graph -> public Graph<K, VV, EV> addEdges(List<Edge<K, EV>> newEdges);1475684776;Adds the given list edges to the graph.__When adding an edge for a non-existing set of vertices, the edge is considered invalid and ignored.__@param newEdges the data set of edges to be added_@return a new graph containing the existing edges plus the newly added edges.;public Graph<K, VV, EV> addEdges(List<Edge<K, EV>> newEdges) {__		DataSet<Edge<K,EV>> newEdgesDataSet = this.context.fromCollection(newEdges)___		DataSet<Edge<K,EV>> validNewEdges = this.getVertices().join(newEdgesDataSet)_				.where(0).equalTo(0)_				.with(new JoinVerticesWithEdgesOnSrc<K, VV, EV>())_				.join(this.getVertices()).where(1).equalTo(0)_				.with(new JoinWithVerticesOnTrg<K, VV, EV>())___		return Graph.fromDataSet(this.vertices, this.edges.union(validNewEdges), this.context)__	};adds,the,given,list,edges,to,the,graph,when,adding,an,edge,for,a,non,existing,set,of,vertices,the,edge,is,considered,invalid,and,ignored,param,new,edges,the,data,set,of,edges,to,be,added,return,a,new,graph,containing,the,existing,edges,plus,the,newly,added,edges;public,graph,k,vv,ev,add,edges,list,edge,k,ev,new,edges,data,set,edge,k,ev,new,edges,data,set,this,context,from,collection,new,edges,data,set,edge,k,ev,valid,new,edges,this,get,vertices,join,new,edges,data,set,where,0,equal,to,0,with,new,join,vertices,with,edges,on,src,k,vv,ev,join,this,get,vertices,where,1,equal,to,0,with,new,join,with,vertices,on,trg,k,vv,ev,return,graph,from,data,set,this,vertices,this,edges,union,valid,new,edges,this,context
Graph -> public Graph<K, VV, EV> addEdges(List<Edge<K, EV>> newEdges);1475685606;Adds the given list edges to the graph.__When adding an edge for a non-existing set of vertices, the edge is considered invalid and ignored.__@param newEdges the data set of edges to be added_@return a new graph containing the existing edges plus the newly added edges.;public Graph<K, VV, EV> addEdges(List<Edge<K, EV>> newEdges) {__		DataSet<Edge<K,EV>> newEdgesDataSet = this.context.fromCollection(newEdges)___		DataSet<Edge<K,EV>> validNewEdges = this.getVertices().join(newEdgesDataSet)_				.where(0).equalTo(0)_				.with(new JoinVerticesWithEdgesOnSrc<K, VV, EV>())_				.join(this.getVertices()).where(1).equalTo(0)_				.with(new JoinWithVerticesOnTrg<K, VV, EV>())___		return Graph.fromDataSet(this.vertices, this.edges.union(validNewEdges), this.context)__	};adds,the,given,list,edges,to,the,graph,when,adding,an,edge,for,a,non,existing,set,of,vertices,the,edge,is,considered,invalid,and,ignored,param,new,edges,the,data,set,of,edges,to,be,added,return,a,new,graph,containing,the,existing,edges,plus,the,newly,added,edges;public,graph,k,vv,ev,add,edges,list,edge,k,ev,new,edges,data,set,edge,k,ev,new,edges,data,set,this,context,from,collection,new,edges,data,set,edge,k,ev,valid,new,edges,this,get,vertices,join,new,edges,data,set,where,0,equal,to,0,with,new,join,vertices,with,edges,on,src,k,vv,ev,join,this,get,vertices,where,1,equal,to,0,with,new,join,with,vertices,on,trg,k,vv,ev,return,graph,from,data,set,this,vertices,this,edges,union,valid,new,edges,this,context
Graph -> public Graph<K, VV, EV> addEdges(List<Edge<K, EV>> newEdges);1481745825;Adds the given list edges to the graph.__When adding an edge for a non-existing set of vertices, the edge is considered invalid and ignored.__@param newEdges the data set of edges to be added_@return a new graph containing the existing edges plus the newly added edges.;public Graph<K, VV, EV> addEdges(List<Edge<K, EV>> newEdges) {__		DataSet<Edge<K,EV>> newEdgesDataSet = this.context.fromCollection(newEdges)___		DataSet<Edge<K,EV>> validNewEdges = this.getVertices().join(newEdgesDataSet)_				.where(0).equalTo(0)_				.with(new JoinVerticesWithEdgesOnSrc<K, VV, EV>()).name("Join with source")_				.join(this.getVertices()).where(1).equalTo(0)_				.with(new JoinWithVerticesOnTrg<K, VV, EV>()).name("Join with target")___		return Graph.fromDataSet(this.vertices, this.edges.union(validNewEdges), this.context)__	};adds,the,given,list,edges,to,the,graph,when,adding,an,edge,for,a,non,existing,set,of,vertices,the,edge,is,considered,invalid,and,ignored,param,new,edges,the,data,set,of,edges,to,be,added,return,a,new,graph,containing,the,existing,edges,plus,the,newly,added,edges;public,graph,k,vv,ev,add,edges,list,edge,k,ev,new,edges,data,set,edge,k,ev,new,edges,data,set,this,context,from,collection,new,edges,data,set,edge,k,ev,valid,new,edges,this,get,vertices,join,new,edges,data,set,where,0,equal,to,0,with,new,join,vertices,with,edges,on,src,k,vv,ev,name,join,with,source,join,this,get,vertices,where,1,equal,to,0,with,new,join,with,vertices,on,trg,k,vv,ev,name,join,with,target,return,graph,from,data,set,this,vertices,this,edges,union,valid,new,edges,this,context
Graph -> public Graph<K, VV, EV> addEdges(List<Edge<K, EV>> newEdges);1481881009;Adds the given list edges to the graph.__When adding an edge for a non-existing set of vertices, the edge is considered invalid and ignored.__@param newEdges the data set of edges to be added_@return a new graph containing the existing edges plus the newly added edges.;public Graph<K, VV, EV> addEdges(List<Edge<K, EV>> newEdges) {__		DataSet<Edge<K,EV>> newEdgesDataSet = this.context.fromCollection(newEdges)___		DataSet<Edge<K,EV>> validNewEdges = this.getVertices().join(newEdgesDataSet)_				.where(0).equalTo(0)_				.with(new JoinVerticesWithEdgesOnSrc<K, VV, EV>()).name("Join with source")_				.join(this.getVertices()).where(1).equalTo(0)_				.with(new JoinWithVerticesOnTrg<K, VV, EV>()).name("Join with target")___		return Graph.fromDataSet(this.vertices, this.edges.union(validNewEdges), this.context)__	};adds,the,given,list,edges,to,the,graph,when,adding,an,edge,for,a,non,existing,set,of,vertices,the,edge,is,considered,invalid,and,ignored,param,new,edges,the,data,set,of,edges,to,be,added,return,a,new,graph,containing,the,existing,edges,plus,the,newly,added,edges;public,graph,k,vv,ev,add,edges,list,edge,k,ev,new,edges,data,set,edge,k,ev,new,edges,data,set,this,context,from,collection,new,edges,data,set,edge,k,ev,valid,new,edges,this,get,vertices,join,new,edges,data,set,where,0,equal,to,0,with,new,join,vertices,with,edges,on,src,k,vv,ev,name,join,with,source,join,this,get,vertices,where,1,equal,to,0,with,new,join,with,vertices,on,trg,k,vv,ev,name,join,with,target,return,graph,from,data,set,this,vertices,this,edges,union,valid,new,edges,this,context
Graph -> public Graph<K, VV, EV> addEdges(List<Edge<K, EV>> newEdges);1484160227;Adds the given list edges to the graph.__When adding an edge for a non-existing set of vertices, the edge is considered invalid and ignored.__@param newEdges the data set of edges to be added_@return a new graph containing the existing edges plus the newly added edges.;public Graph<K, VV, EV> addEdges(List<Edge<K, EV>> newEdges) {__		DataSet<Edge<K,EV>> newEdgesDataSet = this.context.fromCollection(newEdges)___		DataSet<Edge<K,EV>> validNewEdges = this.getVertices().join(newEdgesDataSet)_				.where(0).equalTo(0)_				.with(new JoinVerticesWithEdgesOnSrc<K, VV, EV>()).name("Join with source")_				.join(this.getVertices()).where(1).equalTo(0)_				.with(new JoinWithVerticesOnTrg<K, VV, EV>()).name("Join with target")___		return Graph.fromDataSet(this.vertices, this.edges.union(validNewEdges), this.context)__	};adds,the,given,list,edges,to,the,graph,when,adding,an,edge,for,a,non,existing,set,of,vertices,the,edge,is,considered,invalid,and,ignored,param,new,edges,the,data,set,of,edges,to,be,added,return,a,new,graph,containing,the,existing,edges,plus,the,newly,added,edges;public,graph,k,vv,ev,add,edges,list,edge,k,ev,new,edges,data,set,edge,k,ev,new,edges,data,set,this,context,from,collection,new,edges,data,set,edge,k,ev,valid,new,edges,this,get,vertices,join,new,edges,data,set,where,0,equal,to,0,with,new,join,vertices,with,edges,on,src,k,vv,ev,name,join,with,source,join,this,get,vertices,where,1,equal,to,0,with,new,join,with,vertices,on,trg,k,vv,ev,name,join,with,target,return,graph,from,data,set,this,vertices,this,edges,union,valid,new,edges,this,context
Graph -> public Graph<K, VV, EV> addEdges(List<Edge<K, EV>> newEdges);1484685504;Adds the given list edges to the graph.__When adding an edge for a non-existing set of vertices, the edge is considered invalid and ignored.__@param newEdges the data set of edges to be added_@return a new graph containing the existing edges plus the newly added edges.;public Graph<K, VV, EV> addEdges(List<Edge<K, EV>> newEdges) {__		DataSet<Edge<K, EV>> newEdgesDataSet = this.context.fromCollection(newEdges)___		DataSet<Edge<K, EV>> validNewEdges = this.getVertices().join(newEdgesDataSet)_				.where(0).equalTo(0)_				.with(new JoinVerticesWithEdgesOnSrc<K, VV, EV>()).name("Join with source")_				.join(this.getVertices()).where(1).equalTo(0)_				.with(new JoinWithVerticesOnTrg<K, VV, EV>()).name("Join with target")___		return Graph.fromDataSet(this.vertices, this.edges.union(validNewEdges), this.context)__	};adds,the,given,list,edges,to,the,graph,when,adding,an,edge,for,a,non,existing,set,of,vertices,the,edge,is,considered,invalid,and,ignored,param,new,edges,the,data,set,of,edges,to,be,added,return,a,new,graph,containing,the,existing,edges,plus,the,newly,added,edges;public,graph,k,vv,ev,add,edges,list,edge,k,ev,new,edges,data,set,edge,k,ev,new,edges,data,set,this,context,from,collection,new,edges,data,set,edge,k,ev,valid,new,edges,this,get,vertices,join,new,edges,data,set,where,0,equal,to,0,with,new,join,vertices,with,edges,on,src,k,vv,ev,name,join,with,source,join,this,get,vertices,where,1,equal,to,0,with,new,join,with,vertices,on,trg,k,vv,ev,name,join,with,target,return,graph,from,data,set,this,vertices,this,edges,union,valid,new,edges,this,context
Graph -> public Graph<K, VV, EV> addEdges(List<Edge<K, EV>> newEdges);1489068942;Adds the given list edges to the graph.__When adding an edge for a non-existing set of vertices, the edge is considered invalid and ignored.__@param newEdges the data set of edges to be added_@return a new graph containing the existing edges plus the newly added edges.;public Graph<K, VV, EV> addEdges(List<Edge<K, EV>> newEdges) {__		DataSet<Edge<K, EV>> newEdgesDataSet = this.context.fromCollection(newEdges)___		DataSet<Edge<K, EV>> validNewEdges = this.getVertices().join(newEdgesDataSet)_				.where(0).equalTo(0)_				.with(new JoinVerticesWithEdgesOnSrc<K, VV, EV>()).name("Join with source")_				.join(this.getVertices()).where(1).equalTo(0)_				.with(new JoinWithVerticesOnTrg<K, VV, EV>()).name("Join with target")___		return Graph.fromDataSet(this.vertices, this.edges.union(validNewEdges), this.context)__	};adds,the,given,list,edges,to,the,graph,when,adding,an,edge,for,a,non,existing,set,of,vertices,the,edge,is,considered,invalid,and,ignored,param,new,edges,the,data,set,of,edges,to,be,added,return,a,new,graph,containing,the,existing,edges,plus,the,newly,added,edges;public,graph,k,vv,ev,add,edges,list,edge,k,ev,new,edges,data,set,edge,k,ev,new,edges,data,set,this,context,from,collection,new,edges,data,set,edge,k,ev,valid,new,edges,this,get,vertices,join,new,edges,data,set,where,0,equal,to,0,with,new,join,vertices,with,edges,on,src,k,vv,ev,name,join,with,source,join,this,get,vertices,where,1,equal,to,0,with,new,join,with,vertices,on,trg,k,vv,ev,name,join,with,target,return,graph,from,data,set,this,vertices,this,edges,union,valid,new,edges,this,context
Graph -> public Graph<K, VV, EV> addEdges(List<Edge<K, EV>> newEdges);1490973446;Adds the given list edges to the graph.__When adding an edge for a non-existing set of vertices, the edge is considered invalid and ignored.__@param newEdges the data set of edges to be added_@return a new graph containing the existing edges plus the newly added edges.;public Graph<K, VV, EV> addEdges(List<Edge<K, EV>> newEdges) {__		DataSet<Edge<K, EV>> newEdgesDataSet = this.context.fromCollection(newEdges)___		DataSet<Edge<K, EV>> validNewEdges = this.getVertices().join(newEdgesDataSet)_				.where(0).equalTo(0)_				.with(new JoinVerticesWithEdgesOnSrc<K, VV, EV>()).name("Join with source")_				.join(this.getVertices()).where(1).equalTo(0)_				.with(new JoinWithVerticesOnTrg<K, VV, EV>()).name("Join with target")___		return Graph.fromDataSet(this.vertices, this.edges.union(validNewEdges), this.context)__	};adds,the,given,list,edges,to,the,graph,when,adding,an,edge,for,a,non,existing,set,of,vertices,the,edge,is,considered,invalid,and,ignored,param,new,edges,the,data,set,of,edges,to,be,added,return,a,new,graph,containing,the,existing,edges,plus,the,newly,added,edges;public,graph,k,vv,ev,add,edges,list,edge,k,ev,new,edges,data,set,edge,k,ev,new,edges,data,set,this,context,from,collection,new,edges,data,set,edge,k,ev,valid,new,edges,this,get,vertices,join,new,edges,data,set,where,0,equal,to,0,with,new,join,vertices,with,edges,on,src,k,vv,ev,name,join,with,source,join,this,get,vertices,where,1,equal,to,0,with,new,join,with,vertices,on,trg,k,vv,ev,name,join,with,target,return,graph,from,data,set,this,vertices,this,edges,union,valid,new,edges,this,context
Graph -> public Graph<K, VV, EV> addEdges(List<Edge<K, EV>> newEdges);1495819075;Adds the given list edges to the graph.__<p>When adding an edge for a non-existing set of vertices, the edge is considered invalid and ignored.__@param newEdges the data set of edges to be added_@return a new graph containing the existing edges plus the newly added edges.;public Graph<K, VV, EV> addEdges(List<Edge<K, EV>> newEdges) {__		DataSet<Edge<K, EV>> newEdgesDataSet = this.context.fromCollection(newEdges)___		DataSet<Edge<K, EV>> validNewEdges = this.getVertices().join(newEdgesDataSet)_				.where(0).equalTo(0)_				.with(new JoinVerticesWithEdgesOnSrc<K, VV, EV>()).name("Join with source")_				.join(this.getVertices()).where(1).equalTo(0)_				.with(new JoinWithVerticesOnTrg<K, VV, EV>()).name("Join with target")___		return Graph.fromDataSet(this.vertices, this.edges.union(validNewEdges), this.context)__	};adds,the,given,list,edges,to,the,graph,p,when,adding,an,edge,for,a,non,existing,set,of,vertices,the,edge,is,considered,invalid,and,ignored,param,new,edges,the,data,set,of,edges,to,be,added,return,a,new,graph,containing,the,existing,edges,plus,the,newly,added,edges;public,graph,k,vv,ev,add,edges,list,edge,k,ev,new,edges,data,set,edge,k,ev,new,edges,data,set,this,context,from,collection,new,edges,data,set,edge,k,ev,valid,new,edges,this,get,vertices,join,new,edges,data,set,where,0,equal,to,0,with,new,join,vertices,with,edges,on,src,k,vv,ev,name,join,with,source,join,this,get,vertices,where,1,equal,to,0,with,new,join,with,vertices,on,trg,k,vv,ev,name,join,with,target,return,graph,from,data,set,this,vertices,this,edges,union,valid,new,edges,this,context
Graph -> public Graph<K, VV, EV> addEdges(List<Edge<K, EV>> newEdges);1502111816;Adds the given list edges to the graph.__<p>When adding an edge for a non-existing set of vertices, the edge is considered invalid and ignored.__@param newEdges the data set of edges to be added_@return a new graph containing the existing edges plus the newly added edges.;public Graph<K, VV, EV> addEdges(List<Edge<K, EV>> newEdges) {__		DataSet<Edge<K, EV>> newEdgesDataSet = this.context.fromCollection(newEdges)___		DataSet<Edge<K, EV>> validNewEdges = this.getVertices().join(newEdgesDataSet)_				.where(0).equalTo(0)_				.with(new JoinVerticesWithEdgesOnSrc<>()).name("Join with source")_				.join(this.getVertices()).where(1).equalTo(0)_				.with(new JoinWithVerticesOnTrg<>()).name("Join with target")___		return Graph.fromDataSet(this.vertices, this.edges.union(validNewEdges), this.context)__	};adds,the,given,list,edges,to,the,graph,p,when,adding,an,edge,for,a,non,existing,set,of,vertices,the,edge,is,considered,invalid,and,ignored,param,new,edges,the,data,set,of,edges,to,be,added,return,a,new,graph,containing,the,existing,edges,plus,the,newly,added,edges;public,graph,k,vv,ev,add,edges,list,edge,k,ev,new,edges,data,set,edge,k,ev,new,edges,data,set,this,context,from,collection,new,edges,data,set,edge,k,ev,valid,new,edges,this,get,vertices,join,new,edges,data,set,where,0,equal,to,0,with,new,join,vertices,with,edges,on,src,name,join,with,source,join,this,get,vertices,where,1,equal,to,0,with,new,join,with,vertices,on,trg,name,join,with,target,return,graph,from,data,set,this,vertices,this,edges,union,valid,new,edges,this,context
Graph -> public Graph<K, NullValue, EV> intersect(Graph<K, VV, EV> graph, boolean distinctEdges);1447073368;Performs intersect on the edge sets of the input graphs. Edges are considered equal, if they_have the same source identifier, target identifier and edge value._<p>_The method computes pairs of equal edges from the input graphs. If the same edge occurs_multiple times in the input graphs, there will be multiple edge pairs to be considered. Each_edge instance can only be part of one pair. If the given parameter {@code distinctEdges} is set_to {@code true}, there will be exactly one edge in the output graph representing all pairs of_equal edges. If the parameter is set to {@code false}, both edges of each pair will be in the_output._<p>_Vertices in the output graph will have no vertex values.__@param graph the graph to perform intersect with_@param distinctEdges if set to {@code true}, there will be exactly one edge in the output graph_representing all pairs of equal edges, otherwise, for each pair, both_edges will be in the output graph_@return a new graph which contains only common vertices and edges from the input graphs;public Graph<K, NullValue, EV> intersect(Graph<K, VV, EV> graph, boolean distinctEdges) {_		DataSet<Edge<K, EV>> intersectEdges__		if (distinctEdges) {_			intersectEdges = getDistinctEdgeIntersection(graph.getEdges())__		} else {_			intersectEdges = getPairwiseEdgeIntersection(graph.getEdges())__		}__		return Graph.fromDataSet(intersectEdges, getContext())__	};performs,intersect,on,the,edge,sets,of,the,input,graphs,edges,are,considered,equal,if,they,have,the,same,source,identifier,target,identifier,and,edge,value,p,the,method,computes,pairs,of,equal,edges,from,the,input,graphs,if,the,same,edge,occurs,multiple,times,in,the,input,graphs,there,will,be,multiple,edge,pairs,to,be,considered,each,edge,instance,can,only,be,part,of,one,pair,if,the,given,parameter,code,distinct,edges,is,set,to,code,true,there,will,be,exactly,one,edge,in,the,output,graph,representing,all,pairs,of,equal,edges,if,the,parameter,is,set,to,code,false,both,edges,of,each,pair,will,be,in,the,output,p,vertices,in,the,output,graph,will,have,no,vertex,values,param,graph,the,graph,to,perform,intersect,with,param,distinct,edges,if,set,to,code,true,there,will,be,exactly,one,edge,in,the,output,graph,representing,all,pairs,of,equal,edges,otherwise,for,each,pair,both,edges,will,be,in,the,output,graph,return,a,new,graph,which,contains,only,common,vertices,and,edges,from,the,input,graphs;public,graph,k,null,value,ev,intersect,graph,k,vv,ev,graph,boolean,distinct,edges,data,set,edge,k,ev,intersect,edges,if,distinct,edges,intersect,edges,get,distinct,edge,intersection,graph,get,edges,else,intersect,edges,get,pairwise,edge,intersection,graph,get,edges,return,graph,from,data,set,intersect,edges,get,context
Graph -> public Graph<K, NullValue, EV> intersect(Graph<K, VV, EV> graph, boolean distinctEdges);1454404649;Performs intersect on the edge sets of the input graphs. Edges are considered equal, if they_have the same source identifier, target identifier and edge value._<p>_The method computes pairs of equal edges from the input graphs. If the same edge occurs_multiple times in the input graphs, there will be multiple edge pairs to be considered. Each_edge instance can only be part of one pair. If the given parameter {@code distinctEdges} is set_to {@code true}, there will be exactly one edge in the output graph representing all pairs of_equal edges. If the parameter is set to {@code false}, both edges of each pair will be in the_output._<p>_Vertices in the output graph will have no vertex values.__@param graph the graph to perform intersect with_@param distinctEdges if set to {@code true}, there will be exactly one edge in the output graph_representing all pairs of equal edges, otherwise, for each pair, both_edges will be in the output graph_@return a new graph which contains only common vertices and edges from the input graphs;public Graph<K, NullValue, EV> intersect(Graph<K, VV, EV> graph, boolean distinctEdges) {_		DataSet<Edge<K, EV>> intersectEdges__		if (distinctEdges) {_			intersectEdges = getDistinctEdgeIntersection(graph.getEdges())__		} else {_			intersectEdges = getPairwiseEdgeIntersection(graph.getEdges())__		}__		return Graph.fromDataSet(intersectEdges, getContext())__	};performs,intersect,on,the,edge,sets,of,the,input,graphs,edges,are,considered,equal,if,they,have,the,same,source,identifier,target,identifier,and,edge,value,p,the,method,computes,pairs,of,equal,edges,from,the,input,graphs,if,the,same,edge,occurs,multiple,times,in,the,input,graphs,there,will,be,multiple,edge,pairs,to,be,considered,each,edge,instance,can,only,be,part,of,one,pair,if,the,given,parameter,code,distinct,edges,is,set,to,code,true,there,will,be,exactly,one,edge,in,the,output,graph,representing,all,pairs,of,equal,edges,if,the,parameter,is,set,to,code,false,both,edges,of,each,pair,will,be,in,the,output,p,vertices,in,the,output,graph,will,have,no,vertex,values,param,graph,the,graph,to,perform,intersect,with,param,distinct,edges,if,set,to,code,true,there,will,be,exactly,one,edge,in,the,output,graph,representing,all,pairs,of,equal,edges,otherwise,for,each,pair,both,edges,will,be,in,the,output,graph,return,a,new,graph,which,contains,only,common,vertices,and,edges,from,the,input,graphs;public,graph,k,null,value,ev,intersect,graph,k,vv,ev,graph,boolean,distinct,edges,data,set,edge,k,ev,intersect,edges,if,distinct,edges,intersect,edges,get,distinct,edge,intersection,graph,get,edges,else,intersect,edges,get,pairwise,edge,intersection,graph,get,edges,return,graph,from,data,set,intersect,edges,get,context
Graph -> public Graph<K, NullValue, EV> intersect(Graph<K, VV, EV> graph, boolean distinctEdges);1458583829;Performs intersect on the edge sets of the input graphs. Edges are considered equal, if they_have the same source identifier, target identifier and edge value._<p>_The method computes pairs of equal edges from the input graphs. If the same edge occurs_multiple times in the input graphs, there will be multiple edge pairs to be considered. Each_edge instance can only be part of one pair. If the given parameter {@code distinctEdges} is set_to {@code true}, there will be exactly one edge in the output graph representing all pairs of_equal edges. If the parameter is set to {@code false}, both edges of each pair will be in the_output._<p>_Vertices in the output graph will have no vertex values.__@param graph the graph to perform intersect with_@param distinctEdges if set to {@code true}, there will be exactly one edge in the output graph_representing all pairs of equal edges, otherwise, for each pair, both_edges will be in the output graph_@return a new graph which contains only common vertices and edges from the input graphs;public Graph<K, NullValue, EV> intersect(Graph<K, VV, EV> graph, boolean distinctEdges) {_		DataSet<Edge<K, EV>> intersectEdges__		if (distinctEdges) {_			intersectEdges = getDistinctEdgeIntersection(graph.getEdges())__		} else {_			intersectEdges = getPairwiseEdgeIntersection(graph.getEdges())__		}__		return Graph.fromDataSet(intersectEdges, getContext())__	};performs,intersect,on,the,edge,sets,of,the,input,graphs,edges,are,considered,equal,if,they,have,the,same,source,identifier,target,identifier,and,edge,value,p,the,method,computes,pairs,of,equal,edges,from,the,input,graphs,if,the,same,edge,occurs,multiple,times,in,the,input,graphs,there,will,be,multiple,edge,pairs,to,be,considered,each,edge,instance,can,only,be,part,of,one,pair,if,the,given,parameter,code,distinct,edges,is,set,to,code,true,there,will,be,exactly,one,edge,in,the,output,graph,representing,all,pairs,of,equal,edges,if,the,parameter,is,set,to,code,false,both,edges,of,each,pair,will,be,in,the,output,p,vertices,in,the,output,graph,will,have,no,vertex,values,param,graph,the,graph,to,perform,intersect,with,param,distinct,edges,if,set,to,code,true,there,will,be,exactly,one,edge,in,the,output,graph,representing,all,pairs,of,equal,edges,otherwise,for,each,pair,both,edges,will,be,in,the,output,graph,return,a,new,graph,which,contains,only,common,vertices,and,edges,from,the,input,graphs;public,graph,k,null,value,ev,intersect,graph,k,vv,ev,graph,boolean,distinct,edges,data,set,edge,k,ev,intersect,edges,if,distinct,edges,intersect,edges,get,distinct,edge,intersection,graph,get,edges,else,intersect,edges,get,pairwise,edge,intersection,graph,get,edges,return,graph,from,data,set,intersect,edges,get,context
Graph -> public Graph<K, NullValue, EV> intersect(Graph<K, VV, EV> graph, boolean distinctEdges);1458583829;Performs intersect on the edge sets of the input graphs. Edges are considered equal, if they_have the same source identifier, target identifier and edge value._<p>_The method computes pairs of equal edges from the input graphs. If the same edge occurs_multiple times in the input graphs, there will be multiple edge pairs to be considered. Each_edge instance can only be part of one pair. If the given parameter {@code distinctEdges} is set_to {@code true}, there will be exactly one edge in the output graph representing all pairs of_equal edges. If the parameter is set to {@code false}, both edges of each pair will be in the_output._<p>_Vertices in the output graph will have no vertex values.__@param graph the graph to perform intersect with_@param distinctEdges if set to {@code true}, there will be exactly one edge in the output graph_representing all pairs of equal edges, otherwise, for each pair, both_edges will be in the output graph_@return a new graph which contains only common vertices and edges from the input graphs;public Graph<K, NullValue, EV> intersect(Graph<K, VV, EV> graph, boolean distinctEdges) {_		DataSet<Edge<K, EV>> intersectEdges__		if (distinctEdges) {_			intersectEdges = getDistinctEdgeIntersection(graph.getEdges())__		} else {_			intersectEdges = getPairwiseEdgeIntersection(graph.getEdges())__		}__		return Graph.fromDataSet(intersectEdges, getContext())__	};performs,intersect,on,the,edge,sets,of,the,input,graphs,edges,are,considered,equal,if,they,have,the,same,source,identifier,target,identifier,and,edge,value,p,the,method,computes,pairs,of,equal,edges,from,the,input,graphs,if,the,same,edge,occurs,multiple,times,in,the,input,graphs,there,will,be,multiple,edge,pairs,to,be,considered,each,edge,instance,can,only,be,part,of,one,pair,if,the,given,parameter,code,distinct,edges,is,set,to,code,true,there,will,be,exactly,one,edge,in,the,output,graph,representing,all,pairs,of,equal,edges,if,the,parameter,is,set,to,code,false,both,edges,of,each,pair,will,be,in,the,output,p,vertices,in,the,output,graph,will,have,no,vertex,values,param,graph,the,graph,to,perform,intersect,with,param,distinct,edges,if,set,to,code,true,there,will,be,exactly,one,edge,in,the,output,graph,representing,all,pairs,of,equal,edges,otherwise,for,each,pair,both,edges,will,be,in,the,output,graph,return,a,new,graph,which,contains,only,common,vertices,and,edges,from,the,input,graphs;public,graph,k,null,value,ev,intersect,graph,k,vv,ev,graph,boolean,distinct,edges,data,set,edge,k,ev,intersect,edges,if,distinct,edges,intersect,edges,get,distinct,edge,intersection,graph,get,edges,else,intersect,edges,get,pairwise,edge,intersection,graph,get,edges,return,graph,from,data,set,intersect,edges,get,context
Graph -> public Graph<K, NullValue, EV> intersect(Graph<K, VV, EV> graph, boolean distinctEdges);1462100316;Performs intersect on the edge sets of the input graphs. Edges are considered equal, if they_have the same source identifier, target identifier and edge value._<p>_The method computes pairs of equal edges from the input graphs. If the same edge occurs_multiple times in the input graphs, there will be multiple edge pairs to be considered. Each_edge instance can only be part of one pair. If the given parameter {@code distinctEdges} is set_to {@code true}, there will be exactly one edge in the output graph representing all pairs of_equal edges. If the parameter is set to {@code false}, both edges of each pair will be in the_output._<p>_Vertices in the output graph will have no vertex values.__@param graph the graph to perform intersect with_@param distinctEdges if set to {@code true}, there will be exactly one edge in the output graph_representing all pairs of equal edges, otherwise, for each pair, both_edges will be in the output graph_@return a new graph which contains only common vertices and edges from the input graphs;public Graph<K, NullValue, EV> intersect(Graph<K, VV, EV> graph, boolean distinctEdges) {_		DataSet<Edge<K, EV>> intersectEdges__		if (distinctEdges) {_			intersectEdges = getDistinctEdgeIntersection(graph.getEdges())__		} else {_			intersectEdges = getPairwiseEdgeIntersection(graph.getEdges())__		}__		return Graph.fromDataSet(intersectEdges, getContext())__	};performs,intersect,on,the,edge,sets,of,the,input,graphs,edges,are,considered,equal,if,they,have,the,same,source,identifier,target,identifier,and,edge,value,p,the,method,computes,pairs,of,equal,edges,from,the,input,graphs,if,the,same,edge,occurs,multiple,times,in,the,input,graphs,there,will,be,multiple,edge,pairs,to,be,considered,each,edge,instance,can,only,be,part,of,one,pair,if,the,given,parameter,code,distinct,edges,is,set,to,code,true,there,will,be,exactly,one,edge,in,the,output,graph,representing,all,pairs,of,equal,edges,if,the,parameter,is,set,to,code,false,both,edges,of,each,pair,will,be,in,the,output,p,vertices,in,the,output,graph,will,have,no,vertex,values,param,graph,the,graph,to,perform,intersect,with,param,distinct,edges,if,set,to,code,true,there,will,be,exactly,one,edge,in,the,output,graph,representing,all,pairs,of,equal,edges,otherwise,for,each,pair,both,edges,will,be,in,the,output,graph,return,a,new,graph,which,contains,only,common,vertices,and,edges,from,the,input,graphs;public,graph,k,null,value,ev,intersect,graph,k,vv,ev,graph,boolean,distinct,edges,data,set,edge,k,ev,intersect,edges,if,distinct,edges,intersect,edges,get,distinct,edge,intersection,graph,get,edges,else,intersect,edges,get,pairwise,edge,intersection,graph,get,edges,return,graph,from,data,set,intersect,edges,get,context
Graph -> public Graph<K, NullValue, EV> intersect(Graph<K, VV, EV> graph, boolean distinctEdges);1462100316;Performs intersect on the edge sets of the input graphs. Edges are considered equal, if they_have the same source identifier, target identifier and edge value._<p>_The method computes pairs of equal edges from the input graphs. If the same edge occurs_multiple times in the input graphs, there will be multiple edge pairs to be considered. Each_edge instance can only be part of one pair. If the given parameter {@code distinctEdges} is set_to {@code true}, there will be exactly one edge in the output graph representing all pairs of_equal edges. If the parameter is set to {@code false}, both edges of each pair will be in the_output._<p>_Vertices in the output graph will have no vertex values.__@param graph the graph to perform intersect with_@param distinctEdges if set to {@code true}, there will be exactly one edge in the output graph_representing all pairs of equal edges, otherwise, for each pair, both_edges will be in the output graph_@return a new graph which contains only common vertices and edges from the input graphs;public Graph<K, NullValue, EV> intersect(Graph<K, VV, EV> graph, boolean distinctEdges) {_		DataSet<Edge<K, EV>> intersectEdges__		if (distinctEdges) {_			intersectEdges = getDistinctEdgeIntersection(graph.getEdges())__		} else {_			intersectEdges = getPairwiseEdgeIntersection(graph.getEdges())__		}__		return Graph.fromDataSet(intersectEdges, getContext())__	};performs,intersect,on,the,edge,sets,of,the,input,graphs,edges,are,considered,equal,if,they,have,the,same,source,identifier,target,identifier,and,edge,value,p,the,method,computes,pairs,of,equal,edges,from,the,input,graphs,if,the,same,edge,occurs,multiple,times,in,the,input,graphs,there,will,be,multiple,edge,pairs,to,be,considered,each,edge,instance,can,only,be,part,of,one,pair,if,the,given,parameter,code,distinct,edges,is,set,to,code,true,there,will,be,exactly,one,edge,in,the,output,graph,representing,all,pairs,of,equal,edges,if,the,parameter,is,set,to,code,false,both,edges,of,each,pair,will,be,in,the,output,p,vertices,in,the,output,graph,will,have,no,vertex,values,param,graph,the,graph,to,perform,intersect,with,param,distinct,edges,if,set,to,code,true,there,will,be,exactly,one,edge,in,the,output,graph,representing,all,pairs,of,equal,edges,otherwise,for,each,pair,both,edges,will,be,in,the,output,graph,return,a,new,graph,which,contains,only,common,vertices,and,edges,from,the,input,graphs;public,graph,k,null,value,ev,intersect,graph,k,vv,ev,graph,boolean,distinct,edges,data,set,edge,k,ev,intersect,edges,if,distinct,edges,intersect,edges,get,distinct,edge,intersection,graph,get,edges,else,intersect,edges,get,pairwise,edge,intersection,graph,get,edges,return,graph,from,data,set,intersect,edges,get,context
Graph -> public Graph<K, NullValue, EV> intersect(Graph<K, VV, EV> graph, boolean distinctEdges);1462205213;Performs intersect on the edge sets of the input graphs. Edges are considered equal, if they_have the same source identifier, target identifier and edge value._<p>_The method computes pairs of equal edges from the input graphs. If the same edge occurs_multiple times in the input graphs, there will be multiple edge pairs to be considered. Each_edge instance can only be part of one pair. If the given parameter {@code distinctEdges} is set_to {@code true}, there will be exactly one edge in the output graph representing all pairs of_equal edges. If the parameter is set to {@code false}, both edges of each pair will be in the_output._<p>_Vertices in the output graph will have no vertex values.__@param graph the graph to perform intersect with_@param distinctEdges if set to {@code true}, there will be exactly one edge in the output graph_representing all pairs of equal edges, otherwise, for each pair, both_edges will be in the output graph_@return a new graph which contains only common vertices and edges from the input graphs;public Graph<K, NullValue, EV> intersect(Graph<K, VV, EV> graph, boolean distinctEdges) {_		DataSet<Edge<K, EV>> intersectEdges__		if (distinctEdges) {_			intersectEdges = getDistinctEdgeIntersection(graph.getEdges())__		} else {_			intersectEdges = getPairwiseEdgeIntersection(graph.getEdges())__		}__		return Graph.fromDataSet(intersectEdges, getContext())__	};performs,intersect,on,the,edge,sets,of,the,input,graphs,edges,are,considered,equal,if,they,have,the,same,source,identifier,target,identifier,and,edge,value,p,the,method,computes,pairs,of,equal,edges,from,the,input,graphs,if,the,same,edge,occurs,multiple,times,in,the,input,graphs,there,will,be,multiple,edge,pairs,to,be,considered,each,edge,instance,can,only,be,part,of,one,pair,if,the,given,parameter,code,distinct,edges,is,set,to,code,true,there,will,be,exactly,one,edge,in,the,output,graph,representing,all,pairs,of,equal,edges,if,the,parameter,is,set,to,code,false,both,edges,of,each,pair,will,be,in,the,output,p,vertices,in,the,output,graph,will,have,no,vertex,values,param,graph,the,graph,to,perform,intersect,with,param,distinct,edges,if,set,to,code,true,there,will,be,exactly,one,edge,in,the,output,graph,representing,all,pairs,of,equal,edges,otherwise,for,each,pair,both,edges,will,be,in,the,output,graph,return,a,new,graph,which,contains,only,common,vertices,and,edges,from,the,input,graphs;public,graph,k,null,value,ev,intersect,graph,k,vv,ev,graph,boolean,distinct,edges,data,set,edge,k,ev,intersect,edges,if,distinct,edges,intersect,edges,get,distinct,edge,intersection,graph,get,edges,else,intersect,edges,get,pairwise,edge,intersection,graph,get,edges,return,graph,from,data,set,intersect,edges,get,context
Graph -> public Graph<K, NullValue, EV> intersect(Graph<K, VV, EV> graph, boolean distinctEdges);1462208859;Performs intersect on the edge sets of the input graphs. Edges are considered equal, if they_have the same source identifier, target identifier and edge value._<p>_The method computes pairs of equal edges from the input graphs. If the same edge occurs_multiple times in the input graphs, there will be multiple edge pairs to be considered. Each_edge instance can only be part of one pair. If the given parameter {@code distinctEdges} is set_to {@code true}, there will be exactly one edge in the output graph representing all pairs of_equal edges. If the parameter is set to {@code false}, both edges of each pair will be in the_output._<p>_Vertices in the output graph will have no vertex values.__@param graph the graph to perform intersect with_@param distinctEdges if set to {@code true}, there will be exactly one edge in the output graph_representing all pairs of equal edges, otherwise, for each pair, both_edges will be in the output graph_@return a new graph which contains only common vertices and edges from the input graphs;public Graph<K, NullValue, EV> intersect(Graph<K, VV, EV> graph, boolean distinctEdges) {_		DataSet<Edge<K, EV>> intersectEdges__		if (distinctEdges) {_			intersectEdges = getDistinctEdgeIntersection(graph.getEdges())__		} else {_			intersectEdges = getPairwiseEdgeIntersection(graph.getEdges())__		}__		return Graph.fromDataSet(intersectEdges, getContext())__	};performs,intersect,on,the,edge,sets,of,the,input,graphs,edges,are,considered,equal,if,they,have,the,same,source,identifier,target,identifier,and,edge,value,p,the,method,computes,pairs,of,equal,edges,from,the,input,graphs,if,the,same,edge,occurs,multiple,times,in,the,input,graphs,there,will,be,multiple,edge,pairs,to,be,considered,each,edge,instance,can,only,be,part,of,one,pair,if,the,given,parameter,code,distinct,edges,is,set,to,code,true,there,will,be,exactly,one,edge,in,the,output,graph,representing,all,pairs,of,equal,edges,if,the,parameter,is,set,to,code,false,both,edges,of,each,pair,will,be,in,the,output,p,vertices,in,the,output,graph,will,have,no,vertex,values,param,graph,the,graph,to,perform,intersect,with,param,distinct,edges,if,set,to,code,true,there,will,be,exactly,one,edge,in,the,output,graph,representing,all,pairs,of,equal,edges,otherwise,for,each,pair,both,edges,will,be,in,the,output,graph,return,a,new,graph,which,contains,only,common,vertices,and,edges,from,the,input,graphs;public,graph,k,null,value,ev,intersect,graph,k,vv,ev,graph,boolean,distinct,edges,data,set,edge,k,ev,intersect,edges,if,distinct,edges,intersect,edges,get,distinct,edge,intersection,graph,get,edges,else,intersect,edges,get,pairwise,edge,intersection,graph,get,edges,return,graph,from,data,set,intersect,edges,get,context
Graph -> public Graph<K, NullValue, EV> intersect(Graph<K, VV, EV> graph, boolean distinctEdges);1462809297;Performs intersect on the edge sets of the input graphs. Edges are considered equal, if they_have the same source identifier, target identifier and edge value._<p>_The method computes pairs of equal edges from the input graphs. If the same edge occurs_multiple times in the input graphs, there will be multiple edge pairs to be considered. Each_edge instance can only be part of one pair. If the given parameter {@code distinctEdges} is set_to {@code true}, there will be exactly one edge in the output graph representing all pairs of_equal edges. If the parameter is set to {@code false}, both edges of each pair will be in the_output._<p>_Vertices in the output graph will have no vertex values.__@param graph the graph to perform intersect with_@param distinctEdges if set to {@code true}, there will be exactly one edge in the output graph_representing all pairs of equal edges, otherwise, for each pair, both_edges will be in the output graph_@return a new graph which contains only common vertices and edges from the input graphs;public Graph<K, NullValue, EV> intersect(Graph<K, VV, EV> graph, boolean distinctEdges) {_		DataSet<Edge<K, EV>> intersectEdges__		if (distinctEdges) {_			intersectEdges = getDistinctEdgeIntersection(graph.getEdges())__		} else {_			intersectEdges = getPairwiseEdgeIntersection(graph.getEdges())__		}__		return Graph.fromDataSet(intersectEdges, getContext())__	};performs,intersect,on,the,edge,sets,of,the,input,graphs,edges,are,considered,equal,if,they,have,the,same,source,identifier,target,identifier,and,edge,value,p,the,method,computes,pairs,of,equal,edges,from,the,input,graphs,if,the,same,edge,occurs,multiple,times,in,the,input,graphs,there,will,be,multiple,edge,pairs,to,be,considered,each,edge,instance,can,only,be,part,of,one,pair,if,the,given,parameter,code,distinct,edges,is,set,to,code,true,there,will,be,exactly,one,edge,in,the,output,graph,representing,all,pairs,of,equal,edges,if,the,parameter,is,set,to,code,false,both,edges,of,each,pair,will,be,in,the,output,p,vertices,in,the,output,graph,will,have,no,vertex,values,param,graph,the,graph,to,perform,intersect,with,param,distinct,edges,if,set,to,code,true,there,will,be,exactly,one,edge,in,the,output,graph,representing,all,pairs,of,equal,edges,otherwise,for,each,pair,both,edges,will,be,in,the,output,graph,return,a,new,graph,which,contains,only,common,vertices,and,edges,from,the,input,graphs;public,graph,k,null,value,ev,intersect,graph,k,vv,ev,graph,boolean,distinct,edges,data,set,edge,k,ev,intersect,edges,if,distinct,edges,intersect,edges,get,distinct,edge,intersection,graph,get,edges,else,intersect,edges,get,pairwise,edge,intersection,graph,get,edges,return,graph,from,data,set,intersect,edges,get,context
Graph -> public Graph<K, NullValue, EV> intersect(Graph<K, VV, EV> graph, boolean distinctEdges);1465316775;Performs intersect on the edge sets of the input graphs. Edges are considered equal, if they_have the same source identifier, target identifier and edge value._<p>_The method computes pairs of equal edges from the input graphs. If the same edge occurs_multiple times in the input graphs, there will be multiple edge pairs to be considered. Each_edge instance can only be part of one pair. If the given parameter {@code distinctEdges} is set_to {@code true}, there will be exactly one edge in the output graph representing all pairs of_equal edges. If the parameter is set to {@code false}, both edges of each pair will be in the_output._<p>_Vertices in the output graph will have no vertex values.__@param graph the graph to perform intersect with_@param distinctEdges if set to {@code true}, there will be exactly one edge in the output graph_representing all pairs of equal edges, otherwise, for each pair, both_edges will be in the output graph_@return a new graph which contains only common vertices and edges from the input graphs;public Graph<K, NullValue, EV> intersect(Graph<K, VV, EV> graph, boolean distinctEdges) {_		DataSet<Edge<K, EV>> intersectEdges__		if (distinctEdges) {_			intersectEdges = getDistinctEdgeIntersection(graph.getEdges())__		} else {_			intersectEdges = getPairwiseEdgeIntersection(graph.getEdges())__		}__		return Graph.fromDataSet(intersectEdges, getContext())__	};performs,intersect,on,the,edge,sets,of,the,input,graphs,edges,are,considered,equal,if,they,have,the,same,source,identifier,target,identifier,and,edge,value,p,the,method,computes,pairs,of,equal,edges,from,the,input,graphs,if,the,same,edge,occurs,multiple,times,in,the,input,graphs,there,will,be,multiple,edge,pairs,to,be,considered,each,edge,instance,can,only,be,part,of,one,pair,if,the,given,parameter,code,distinct,edges,is,set,to,code,true,there,will,be,exactly,one,edge,in,the,output,graph,representing,all,pairs,of,equal,edges,if,the,parameter,is,set,to,code,false,both,edges,of,each,pair,will,be,in,the,output,p,vertices,in,the,output,graph,will,have,no,vertex,values,param,graph,the,graph,to,perform,intersect,with,param,distinct,edges,if,set,to,code,true,there,will,be,exactly,one,edge,in,the,output,graph,representing,all,pairs,of,equal,edges,otherwise,for,each,pair,both,edges,will,be,in,the,output,graph,return,a,new,graph,which,contains,only,common,vertices,and,edges,from,the,input,graphs;public,graph,k,null,value,ev,intersect,graph,k,vv,ev,graph,boolean,distinct,edges,data,set,edge,k,ev,intersect,edges,if,distinct,edges,intersect,edges,get,distinct,edge,intersection,graph,get,edges,else,intersect,edges,get,pairwise,edge,intersection,graph,get,edges,return,graph,from,data,set,intersect,edges,get,context
Graph -> public Graph<K, NullValue, EV> intersect(Graph<K, VV, EV> graph, boolean distinctEdges);1466789678;Performs intersect on the edge sets of the input graphs. Edges are considered equal, if they_have the same source identifier, target identifier and edge value._<p>_The method computes pairs of equal edges from the input graphs. If the same edge occurs_multiple times in the input graphs, there will be multiple edge pairs to be considered. Each_edge instance can only be part of one pair. If the given parameter {@code distinctEdges} is set_to {@code true}, there will be exactly one edge in the output graph representing all pairs of_equal edges. If the parameter is set to {@code false}, both edges of each pair will be in the_output._<p>_Vertices in the output graph will have no vertex values.__@param graph the graph to perform intersect with_@param distinctEdges if set to {@code true}, there will be exactly one edge in the output graph_representing all pairs of equal edges, otherwise, for each pair, both_edges will be in the output graph_@return a new graph which contains only common vertices and edges from the input graphs;public Graph<K, NullValue, EV> intersect(Graph<K, VV, EV> graph, boolean distinctEdges) {_		DataSet<Edge<K, EV>> intersectEdges__		if (distinctEdges) {_			intersectEdges = getDistinctEdgeIntersection(graph.getEdges())__		} else {_			intersectEdges = getPairwiseEdgeIntersection(graph.getEdges())__		}__		return Graph.fromDataSet(intersectEdges, getContext())__	};performs,intersect,on,the,edge,sets,of,the,input,graphs,edges,are,considered,equal,if,they,have,the,same,source,identifier,target,identifier,and,edge,value,p,the,method,computes,pairs,of,equal,edges,from,the,input,graphs,if,the,same,edge,occurs,multiple,times,in,the,input,graphs,there,will,be,multiple,edge,pairs,to,be,considered,each,edge,instance,can,only,be,part,of,one,pair,if,the,given,parameter,code,distinct,edges,is,set,to,code,true,there,will,be,exactly,one,edge,in,the,output,graph,representing,all,pairs,of,equal,edges,if,the,parameter,is,set,to,code,false,both,edges,of,each,pair,will,be,in,the,output,p,vertices,in,the,output,graph,will,have,no,vertex,values,param,graph,the,graph,to,perform,intersect,with,param,distinct,edges,if,set,to,code,true,there,will,be,exactly,one,edge,in,the,output,graph,representing,all,pairs,of,equal,edges,otherwise,for,each,pair,both,edges,will,be,in,the,output,graph,return,a,new,graph,which,contains,only,common,vertices,and,edges,from,the,input,graphs;public,graph,k,null,value,ev,intersect,graph,k,vv,ev,graph,boolean,distinct,edges,data,set,edge,k,ev,intersect,edges,if,distinct,edges,intersect,edges,get,distinct,edge,intersection,graph,get,edges,else,intersect,edges,get,pairwise,edge,intersection,graph,get,edges,return,graph,from,data,set,intersect,edges,get,context
Graph -> public Graph<K, NullValue, EV> intersect(Graph<K, VV, EV> graph, boolean distinctEdges);1467140656;Performs intersect on the edge sets of the input graphs. Edges are considered equal, if they_have the same source identifier, target identifier and edge value._<p>_The method computes pairs of equal edges from the input graphs. If the same edge occurs_multiple times in the input graphs, there will be multiple edge pairs to be considered. Each_edge instance can only be part of one pair. If the given parameter {@code distinctEdges} is set_to {@code true}, there will be exactly one edge in the output graph representing all pairs of_equal edges. If the parameter is set to {@code false}, both edges of each pair will be in the_output._<p>_Vertices in the output graph will have no vertex values.__@param graph the graph to perform intersect with_@param distinctEdges if set to {@code true}, there will be exactly one edge in the output graph_representing all pairs of equal edges, otherwise, for each pair, both_edges will be in the output graph_@return a new graph which contains only common vertices and edges from the input graphs;public Graph<K, NullValue, EV> intersect(Graph<K, VV, EV> graph, boolean distinctEdges) {_		DataSet<Edge<K, EV>> intersectEdges__		if (distinctEdges) {_			intersectEdges = getDistinctEdgeIntersection(graph.getEdges())__		} else {_			intersectEdges = getPairwiseEdgeIntersection(graph.getEdges())__		}__		return Graph.fromDataSet(intersectEdges, getContext())__	};performs,intersect,on,the,edge,sets,of,the,input,graphs,edges,are,considered,equal,if,they,have,the,same,source,identifier,target,identifier,and,edge,value,p,the,method,computes,pairs,of,equal,edges,from,the,input,graphs,if,the,same,edge,occurs,multiple,times,in,the,input,graphs,there,will,be,multiple,edge,pairs,to,be,considered,each,edge,instance,can,only,be,part,of,one,pair,if,the,given,parameter,code,distinct,edges,is,set,to,code,true,there,will,be,exactly,one,edge,in,the,output,graph,representing,all,pairs,of,equal,edges,if,the,parameter,is,set,to,code,false,both,edges,of,each,pair,will,be,in,the,output,p,vertices,in,the,output,graph,will,have,no,vertex,values,param,graph,the,graph,to,perform,intersect,with,param,distinct,edges,if,set,to,code,true,there,will,be,exactly,one,edge,in,the,output,graph,representing,all,pairs,of,equal,edges,otherwise,for,each,pair,both,edges,will,be,in,the,output,graph,return,a,new,graph,which,contains,only,common,vertices,and,edges,from,the,input,graphs;public,graph,k,null,value,ev,intersect,graph,k,vv,ev,graph,boolean,distinct,edges,data,set,edge,k,ev,intersect,edges,if,distinct,edges,intersect,edges,get,distinct,edge,intersection,graph,get,edges,else,intersect,edges,get,pairwise,edge,intersection,graph,get,edges,return,graph,from,data,set,intersect,edges,get,context
Graph -> public Graph<K, NullValue, EV> intersect(Graph<K, VV, EV> graph, boolean distinctEdges);1467306272;Performs intersect on the edge sets of the input graphs. Edges are considered equal, if they_have the same source identifier, target identifier and edge value._<p>_The method computes pairs of equal edges from the input graphs. If the same edge occurs_multiple times in the input graphs, there will be multiple edge pairs to be considered. Each_edge instance can only be part of one pair. If the given parameter {@code distinctEdges} is set_to {@code true}, there will be exactly one edge in the output graph representing all pairs of_equal edges. If the parameter is set to {@code false}, both edges of each pair will be in the_output._<p>_Vertices in the output graph will have no vertex values.__@param graph the graph to perform intersect with_@param distinctEdges if set to {@code true}, there will be exactly one edge in the output graph_representing all pairs of equal edges, otherwise, for each pair, both_edges will be in the output graph_@return a new graph which contains only common vertices and edges from the input graphs;public Graph<K, NullValue, EV> intersect(Graph<K, VV, EV> graph, boolean distinctEdges) {_		DataSet<Edge<K, EV>> intersectEdges__		if (distinctEdges) {_			intersectEdges = getDistinctEdgeIntersection(graph.getEdges())__		} else {_			intersectEdges = getPairwiseEdgeIntersection(graph.getEdges())__		}__		return Graph.fromDataSet(intersectEdges, getContext())__	};performs,intersect,on,the,edge,sets,of,the,input,graphs,edges,are,considered,equal,if,they,have,the,same,source,identifier,target,identifier,and,edge,value,p,the,method,computes,pairs,of,equal,edges,from,the,input,graphs,if,the,same,edge,occurs,multiple,times,in,the,input,graphs,there,will,be,multiple,edge,pairs,to,be,considered,each,edge,instance,can,only,be,part,of,one,pair,if,the,given,parameter,code,distinct,edges,is,set,to,code,true,there,will,be,exactly,one,edge,in,the,output,graph,representing,all,pairs,of,equal,edges,if,the,parameter,is,set,to,code,false,both,edges,of,each,pair,will,be,in,the,output,p,vertices,in,the,output,graph,will,have,no,vertex,values,param,graph,the,graph,to,perform,intersect,with,param,distinct,edges,if,set,to,code,true,there,will,be,exactly,one,edge,in,the,output,graph,representing,all,pairs,of,equal,edges,otherwise,for,each,pair,both,edges,will,be,in,the,output,graph,return,a,new,graph,which,contains,only,common,vertices,and,edges,from,the,input,graphs;public,graph,k,null,value,ev,intersect,graph,k,vv,ev,graph,boolean,distinct,edges,data,set,edge,k,ev,intersect,edges,if,distinct,edges,intersect,edges,get,distinct,edge,intersection,graph,get,edges,else,intersect,edges,get,pairwise,edge,intersection,graph,get,edges,return,graph,from,data,set,intersect,edges,get,context
Graph -> public Graph<K, NullValue, EV> intersect(Graph<K, VV, EV> graph, boolean distinctEdges);1470042815;Performs intersect on the edge sets of the input graphs. Edges are considered equal, if they_have the same source identifier, target identifier and edge value._<p>_The method computes pairs of equal edges from the input graphs. If the same edge occurs_multiple times in the input graphs, there will be multiple edge pairs to be considered. Each_edge instance can only be part of one pair. If the given parameter {@code distinctEdges} is set_to {@code true}, there will be exactly one edge in the output graph representing all pairs of_equal edges. If the parameter is set to {@code false}, both edges of each pair will be in the_output._<p>_Vertices in the output graph will have no vertex values.__@param graph the graph to perform intersect with_@param distinctEdges if set to {@code true}, there will be exactly one edge in the output graph_representing all pairs of equal edges, otherwise, for each pair, both_edges will be in the output graph_@return a new graph which contains only common vertices and edges from the input graphs;public Graph<K, NullValue, EV> intersect(Graph<K, VV, EV> graph, boolean distinctEdges) {_		DataSet<Edge<K, EV>> intersectEdges__		if (distinctEdges) {_			intersectEdges = getDistinctEdgeIntersection(graph.getEdges())__		} else {_			intersectEdges = getPairwiseEdgeIntersection(graph.getEdges())__		}__		return Graph.fromDataSet(intersectEdges, getContext())__	};performs,intersect,on,the,edge,sets,of,the,input,graphs,edges,are,considered,equal,if,they,have,the,same,source,identifier,target,identifier,and,edge,value,p,the,method,computes,pairs,of,equal,edges,from,the,input,graphs,if,the,same,edge,occurs,multiple,times,in,the,input,graphs,there,will,be,multiple,edge,pairs,to,be,considered,each,edge,instance,can,only,be,part,of,one,pair,if,the,given,parameter,code,distinct,edges,is,set,to,code,true,there,will,be,exactly,one,edge,in,the,output,graph,representing,all,pairs,of,equal,edges,if,the,parameter,is,set,to,code,false,both,edges,of,each,pair,will,be,in,the,output,p,vertices,in,the,output,graph,will,have,no,vertex,values,param,graph,the,graph,to,perform,intersect,with,param,distinct,edges,if,set,to,code,true,there,will,be,exactly,one,edge,in,the,output,graph,representing,all,pairs,of,equal,edges,otherwise,for,each,pair,both,edges,will,be,in,the,output,graph,return,a,new,graph,which,contains,only,common,vertices,and,edges,from,the,input,graphs;public,graph,k,null,value,ev,intersect,graph,k,vv,ev,graph,boolean,distinct,edges,data,set,edge,k,ev,intersect,edges,if,distinct,edges,intersect,edges,get,distinct,edge,intersection,graph,get,edges,else,intersect,edges,get,pairwise,edge,intersection,graph,get,edges,return,graph,from,data,set,intersect,edges,get,context
Graph -> public Graph<K, NullValue, EV> intersect(Graph<K, VV, EV> graph, boolean distinctEdges);1475684776;Performs intersect on the edge sets of the input graphs. Edges are considered equal, if they_have the same source identifier, target identifier and edge value._<p>_The method computes pairs of equal edges from the input graphs. If the same edge occurs_multiple times in the input graphs, there will be multiple edge pairs to be considered. Each_edge instance can only be part of one pair. If the given parameter {@code distinctEdges} is set_to {@code true}, there will be exactly one edge in the output graph representing all pairs of_equal edges. If the parameter is set to {@code false}, both edges of each pair will be in the_output._<p>_Vertices in the output graph will have no vertex values.__@param graph the graph to perform intersect with_@param distinctEdges if set to {@code true}, there will be exactly one edge in the output graph_representing all pairs of equal edges, otherwise, for each pair, both_edges will be in the output graph_@return a new graph which contains only common vertices and edges from the input graphs;public Graph<K, NullValue, EV> intersect(Graph<K, VV, EV> graph, boolean distinctEdges) {_		DataSet<Edge<K, EV>> intersectEdges__		if (distinctEdges) {_			intersectEdges = getDistinctEdgeIntersection(graph.getEdges())__		} else {_			intersectEdges = getPairwiseEdgeIntersection(graph.getEdges())__		}__		return Graph.fromDataSet(intersectEdges, getContext())__	};performs,intersect,on,the,edge,sets,of,the,input,graphs,edges,are,considered,equal,if,they,have,the,same,source,identifier,target,identifier,and,edge,value,p,the,method,computes,pairs,of,equal,edges,from,the,input,graphs,if,the,same,edge,occurs,multiple,times,in,the,input,graphs,there,will,be,multiple,edge,pairs,to,be,considered,each,edge,instance,can,only,be,part,of,one,pair,if,the,given,parameter,code,distinct,edges,is,set,to,code,true,there,will,be,exactly,one,edge,in,the,output,graph,representing,all,pairs,of,equal,edges,if,the,parameter,is,set,to,code,false,both,edges,of,each,pair,will,be,in,the,output,p,vertices,in,the,output,graph,will,have,no,vertex,values,param,graph,the,graph,to,perform,intersect,with,param,distinct,edges,if,set,to,code,true,there,will,be,exactly,one,edge,in,the,output,graph,representing,all,pairs,of,equal,edges,otherwise,for,each,pair,both,edges,will,be,in,the,output,graph,return,a,new,graph,which,contains,only,common,vertices,and,edges,from,the,input,graphs;public,graph,k,null,value,ev,intersect,graph,k,vv,ev,graph,boolean,distinct,edges,data,set,edge,k,ev,intersect,edges,if,distinct,edges,intersect,edges,get,distinct,edge,intersection,graph,get,edges,else,intersect,edges,get,pairwise,edge,intersection,graph,get,edges,return,graph,from,data,set,intersect,edges,get,context
Graph -> public Graph<K, NullValue, EV> intersect(Graph<K, VV, EV> graph, boolean distinctEdges);1475685606;Performs intersect on the edge sets of the input graphs. Edges are considered equal, if they_have the same source identifier, target identifier and edge value._<p>_The method computes pairs of equal edges from the input graphs. If the same edge occurs_multiple times in the input graphs, there will be multiple edge pairs to be considered. Each_edge instance can only be part of one pair. If the given parameter {@code distinctEdges} is set_to {@code true}, there will be exactly one edge in the output graph representing all pairs of_equal edges. If the parameter is set to {@code false}, both edges of each pair will be in the_output._<p>_Vertices in the output graph will have no vertex values.__@param graph the graph to perform intersect with_@param distinctEdges if set to {@code true}, there will be exactly one edge in the output graph_representing all pairs of equal edges, otherwise, for each pair, both_edges will be in the output graph_@return a new graph which contains only common vertices and edges from the input graphs;public Graph<K, NullValue, EV> intersect(Graph<K, VV, EV> graph, boolean distinctEdges) {_		DataSet<Edge<K, EV>> intersectEdges__		if (distinctEdges) {_			intersectEdges = getDistinctEdgeIntersection(graph.getEdges())__		} else {_			intersectEdges = getPairwiseEdgeIntersection(graph.getEdges())__		}__		return Graph.fromDataSet(intersectEdges, getContext())__	};performs,intersect,on,the,edge,sets,of,the,input,graphs,edges,are,considered,equal,if,they,have,the,same,source,identifier,target,identifier,and,edge,value,p,the,method,computes,pairs,of,equal,edges,from,the,input,graphs,if,the,same,edge,occurs,multiple,times,in,the,input,graphs,there,will,be,multiple,edge,pairs,to,be,considered,each,edge,instance,can,only,be,part,of,one,pair,if,the,given,parameter,code,distinct,edges,is,set,to,code,true,there,will,be,exactly,one,edge,in,the,output,graph,representing,all,pairs,of,equal,edges,if,the,parameter,is,set,to,code,false,both,edges,of,each,pair,will,be,in,the,output,p,vertices,in,the,output,graph,will,have,no,vertex,values,param,graph,the,graph,to,perform,intersect,with,param,distinct,edges,if,set,to,code,true,there,will,be,exactly,one,edge,in,the,output,graph,representing,all,pairs,of,equal,edges,otherwise,for,each,pair,both,edges,will,be,in,the,output,graph,return,a,new,graph,which,contains,only,common,vertices,and,edges,from,the,input,graphs;public,graph,k,null,value,ev,intersect,graph,k,vv,ev,graph,boolean,distinct,edges,data,set,edge,k,ev,intersect,edges,if,distinct,edges,intersect,edges,get,distinct,edge,intersection,graph,get,edges,else,intersect,edges,get,pairwise,edge,intersection,graph,get,edges,return,graph,from,data,set,intersect,edges,get,context
Graph -> public Graph<K, NullValue, EV> intersect(Graph<K, VV, EV> graph, boolean distinctEdges);1481745825;Performs intersect on the edge sets of the input graphs. Edges are considered equal, if they_have the same source identifier, target identifier and edge value._<p>_The method computes pairs of equal edges from the input graphs. If the same edge occurs_multiple times in the input graphs, there will be multiple edge pairs to be considered. Each_edge instance can only be part of one pair. If the given parameter {@code distinctEdges} is set_to {@code true}, there will be exactly one edge in the output graph representing all pairs of_equal edges. If the parameter is set to {@code false}, both edges of each pair will be in the_output._<p>_Vertices in the output graph will have no vertex values.__@param graph the graph to perform intersect with_@param distinctEdges if set to {@code true}, there will be exactly one edge in the output graph_representing all pairs of equal edges, otherwise, for each pair, both_edges will be in the output graph_@return a new graph which contains only common vertices and edges from the input graphs;public Graph<K, NullValue, EV> intersect(Graph<K, VV, EV> graph, boolean distinctEdges) {_		DataSet<Edge<K, EV>> intersectEdges__		if (distinctEdges) {_			intersectEdges = getDistinctEdgeIntersection(graph.getEdges())__		} else {_			intersectEdges = getPairwiseEdgeIntersection(graph.getEdges())__		}__		return Graph.fromDataSet(intersectEdges, getContext())__	};performs,intersect,on,the,edge,sets,of,the,input,graphs,edges,are,considered,equal,if,they,have,the,same,source,identifier,target,identifier,and,edge,value,p,the,method,computes,pairs,of,equal,edges,from,the,input,graphs,if,the,same,edge,occurs,multiple,times,in,the,input,graphs,there,will,be,multiple,edge,pairs,to,be,considered,each,edge,instance,can,only,be,part,of,one,pair,if,the,given,parameter,code,distinct,edges,is,set,to,code,true,there,will,be,exactly,one,edge,in,the,output,graph,representing,all,pairs,of,equal,edges,if,the,parameter,is,set,to,code,false,both,edges,of,each,pair,will,be,in,the,output,p,vertices,in,the,output,graph,will,have,no,vertex,values,param,graph,the,graph,to,perform,intersect,with,param,distinct,edges,if,set,to,code,true,there,will,be,exactly,one,edge,in,the,output,graph,representing,all,pairs,of,equal,edges,otherwise,for,each,pair,both,edges,will,be,in,the,output,graph,return,a,new,graph,which,contains,only,common,vertices,and,edges,from,the,input,graphs;public,graph,k,null,value,ev,intersect,graph,k,vv,ev,graph,boolean,distinct,edges,data,set,edge,k,ev,intersect,edges,if,distinct,edges,intersect,edges,get,distinct,edge,intersection,graph,get,edges,else,intersect,edges,get,pairwise,edge,intersection,graph,get,edges,return,graph,from,data,set,intersect,edges,get,context
Graph -> public Graph<K, NullValue, EV> intersect(Graph<K, VV, EV> graph, boolean distinctEdges);1481881009;Performs intersect on the edge sets of the input graphs. Edges are considered equal, if they_have the same source identifier, target identifier and edge value._<p>_The method computes pairs of equal edges from the input graphs. If the same edge occurs_multiple times in the input graphs, there will be multiple edge pairs to be considered. Each_edge instance can only be part of one pair. If the given parameter {@code distinctEdges} is set_to {@code true}, there will be exactly one edge in the output graph representing all pairs of_equal edges. If the parameter is set to {@code false}, both edges of each pair will be in the_output._<p>_Vertices in the output graph will have no vertex values.__@param graph the graph to perform intersect with_@param distinctEdges if set to {@code true}, there will be exactly one edge in the output graph_representing all pairs of equal edges, otherwise, for each pair, both_edges will be in the output graph_@return a new graph which contains only common vertices and edges from the input graphs;public Graph<K, NullValue, EV> intersect(Graph<K, VV, EV> graph, boolean distinctEdges) {_		DataSet<Edge<K, EV>> intersectEdges__		if (distinctEdges) {_			intersectEdges = getDistinctEdgeIntersection(graph.getEdges())__		} else {_			intersectEdges = getPairwiseEdgeIntersection(graph.getEdges())__		}__		return Graph.fromDataSet(intersectEdges, getContext())__	};performs,intersect,on,the,edge,sets,of,the,input,graphs,edges,are,considered,equal,if,they,have,the,same,source,identifier,target,identifier,and,edge,value,p,the,method,computes,pairs,of,equal,edges,from,the,input,graphs,if,the,same,edge,occurs,multiple,times,in,the,input,graphs,there,will,be,multiple,edge,pairs,to,be,considered,each,edge,instance,can,only,be,part,of,one,pair,if,the,given,parameter,code,distinct,edges,is,set,to,code,true,there,will,be,exactly,one,edge,in,the,output,graph,representing,all,pairs,of,equal,edges,if,the,parameter,is,set,to,code,false,both,edges,of,each,pair,will,be,in,the,output,p,vertices,in,the,output,graph,will,have,no,vertex,values,param,graph,the,graph,to,perform,intersect,with,param,distinct,edges,if,set,to,code,true,there,will,be,exactly,one,edge,in,the,output,graph,representing,all,pairs,of,equal,edges,otherwise,for,each,pair,both,edges,will,be,in,the,output,graph,return,a,new,graph,which,contains,only,common,vertices,and,edges,from,the,input,graphs;public,graph,k,null,value,ev,intersect,graph,k,vv,ev,graph,boolean,distinct,edges,data,set,edge,k,ev,intersect,edges,if,distinct,edges,intersect,edges,get,distinct,edge,intersection,graph,get,edges,else,intersect,edges,get,pairwise,edge,intersection,graph,get,edges,return,graph,from,data,set,intersect,edges,get,context
Graph -> public Graph<K, NullValue, EV> intersect(Graph<K, VV, EV> graph, boolean distinctEdges);1484160227;Performs intersect on the edge sets of the input graphs. Edges are considered equal, if they_have the same source identifier, target identifier and edge value._<p>_The method computes pairs of equal edges from the input graphs. If the same edge occurs_multiple times in the input graphs, there will be multiple edge pairs to be considered. Each_edge instance can only be part of one pair. If the given parameter {@code distinctEdges} is set_to {@code true}, there will be exactly one edge in the output graph representing all pairs of_equal edges. If the parameter is set to {@code false}, both edges of each pair will be in the_output._<p>_Vertices in the output graph will have no vertex values.__@param graph the graph to perform intersect with_@param distinctEdges if set to {@code true}, there will be exactly one edge in the output graph_representing all pairs of equal edges, otherwise, for each pair, both_edges will be in the output graph_@return a new graph which contains only common vertices and edges from the input graphs;public Graph<K, NullValue, EV> intersect(Graph<K, VV, EV> graph, boolean distinctEdges) {_		DataSet<Edge<K, EV>> intersectEdges__		if (distinctEdges) {_			intersectEdges = getDistinctEdgeIntersection(graph.getEdges())__		} else {_			intersectEdges = getPairwiseEdgeIntersection(graph.getEdges())__		}__		return Graph.fromDataSet(intersectEdges, getContext())__	};performs,intersect,on,the,edge,sets,of,the,input,graphs,edges,are,considered,equal,if,they,have,the,same,source,identifier,target,identifier,and,edge,value,p,the,method,computes,pairs,of,equal,edges,from,the,input,graphs,if,the,same,edge,occurs,multiple,times,in,the,input,graphs,there,will,be,multiple,edge,pairs,to,be,considered,each,edge,instance,can,only,be,part,of,one,pair,if,the,given,parameter,code,distinct,edges,is,set,to,code,true,there,will,be,exactly,one,edge,in,the,output,graph,representing,all,pairs,of,equal,edges,if,the,parameter,is,set,to,code,false,both,edges,of,each,pair,will,be,in,the,output,p,vertices,in,the,output,graph,will,have,no,vertex,values,param,graph,the,graph,to,perform,intersect,with,param,distinct,edges,if,set,to,code,true,there,will,be,exactly,one,edge,in,the,output,graph,representing,all,pairs,of,equal,edges,otherwise,for,each,pair,both,edges,will,be,in,the,output,graph,return,a,new,graph,which,contains,only,common,vertices,and,edges,from,the,input,graphs;public,graph,k,null,value,ev,intersect,graph,k,vv,ev,graph,boolean,distinct,edges,data,set,edge,k,ev,intersect,edges,if,distinct,edges,intersect,edges,get,distinct,edge,intersection,graph,get,edges,else,intersect,edges,get,pairwise,edge,intersection,graph,get,edges,return,graph,from,data,set,intersect,edges,get,context
Graph -> public Graph<K, NullValue, EV> intersect(Graph<K, VV, EV> graph, boolean distinctEdges);1484685504;Performs intersect on the edge sets of the input graphs. Edges are considered equal, if they_have the same source identifier, target identifier and edge value._<p>_The method computes pairs of equal edges from the input graphs. If the same edge occurs_multiple times in the input graphs, there will be multiple edge pairs to be considered. Each_edge instance can only be part of one pair. If the given parameter {@code distinctEdges} is set_to {@code true}, there will be exactly one edge in the output graph representing all pairs of_equal edges. If the parameter is set to {@code false}, both edges of each pair will be in the_output._<p>_Vertices in the output graph will have no vertex values.__@param graph the graph to perform intersect with_@param distinctEdges if set to {@code true}, there will be exactly one edge in the output graph_representing all pairs of equal edges, otherwise, for each pair, both_edges will be in the output graph_@return a new graph which contains only common vertices and edges from the input graphs;public Graph<K, NullValue, EV> intersect(Graph<K, VV, EV> graph, boolean distinctEdges) {_		DataSet<Edge<K, EV>> intersectEdges__		if (distinctEdges) {_			intersectEdges = getDistinctEdgeIntersection(graph.getEdges())__		} else {_			intersectEdges = getPairwiseEdgeIntersection(graph.getEdges())__		}__		return Graph.fromDataSet(intersectEdges, getContext())__	};performs,intersect,on,the,edge,sets,of,the,input,graphs,edges,are,considered,equal,if,they,have,the,same,source,identifier,target,identifier,and,edge,value,p,the,method,computes,pairs,of,equal,edges,from,the,input,graphs,if,the,same,edge,occurs,multiple,times,in,the,input,graphs,there,will,be,multiple,edge,pairs,to,be,considered,each,edge,instance,can,only,be,part,of,one,pair,if,the,given,parameter,code,distinct,edges,is,set,to,code,true,there,will,be,exactly,one,edge,in,the,output,graph,representing,all,pairs,of,equal,edges,if,the,parameter,is,set,to,code,false,both,edges,of,each,pair,will,be,in,the,output,p,vertices,in,the,output,graph,will,have,no,vertex,values,param,graph,the,graph,to,perform,intersect,with,param,distinct,edges,if,set,to,code,true,there,will,be,exactly,one,edge,in,the,output,graph,representing,all,pairs,of,equal,edges,otherwise,for,each,pair,both,edges,will,be,in,the,output,graph,return,a,new,graph,which,contains,only,common,vertices,and,edges,from,the,input,graphs;public,graph,k,null,value,ev,intersect,graph,k,vv,ev,graph,boolean,distinct,edges,data,set,edge,k,ev,intersect,edges,if,distinct,edges,intersect,edges,get,distinct,edge,intersection,graph,get,edges,else,intersect,edges,get,pairwise,edge,intersection,graph,get,edges,return,graph,from,data,set,intersect,edges,get,context
Graph -> public Graph<K, NullValue, EV> intersect(Graph<K, VV, EV> graph, boolean distinctEdges);1489068942;Performs intersect on the edge sets of the input graphs. Edges are considered equal, if they_have the same source identifier, target identifier and edge value._<p>_The method computes pairs of equal edges from the input graphs. If the same edge occurs_multiple times in the input graphs, there will be multiple edge pairs to be considered. Each_edge instance can only be part of one pair. If the given parameter {@code distinctEdges} is set_to {@code true}, there will be exactly one edge in the output graph representing all pairs of_equal edges. If the parameter is set to {@code false}, both edges of each pair will be in the_output._<p>_Vertices in the output graph will have no vertex values.__@param graph the graph to perform intersect with_@param distinctEdges if set to {@code true}, there will be exactly one edge in the output graph_representing all pairs of equal edges, otherwise, for each pair, both_edges will be in the output graph_@return a new graph which contains only common vertices and edges from the input graphs;public Graph<K, NullValue, EV> intersect(Graph<K, VV, EV> graph, boolean distinctEdges) {_		DataSet<Edge<K, EV>> intersectEdges__		if (distinctEdges) {_			intersectEdges = getDistinctEdgeIntersection(graph.getEdges())__		} else {_			intersectEdges = getPairwiseEdgeIntersection(graph.getEdges())__		}__		return Graph.fromDataSet(intersectEdges, getContext())__	};performs,intersect,on,the,edge,sets,of,the,input,graphs,edges,are,considered,equal,if,they,have,the,same,source,identifier,target,identifier,and,edge,value,p,the,method,computes,pairs,of,equal,edges,from,the,input,graphs,if,the,same,edge,occurs,multiple,times,in,the,input,graphs,there,will,be,multiple,edge,pairs,to,be,considered,each,edge,instance,can,only,be,part,of,one,pair,if,the,given,parameter,code,distinct,edges,is,set,to,code,true,there,will,be,exactly,one,edge,in,the,output,graph,representing,all,pairs,of,equal,edges,if,the,parameter,is,set,to,code,false,both,edges,of,each,pair,will,be,in,the,output,p,vertices,in,the,output,graph,will,have,no,vertex,values,param,graph,the,graph,to,perform,intersect,with,param,distinct,edges,if,set,to,code,true,there,will,be,exactly,one,edge,in,the,output,graph,representing,all,pairs,of,equal,edges,otherwise,for,each,pair,both,edges,will,be,in,the,output,graph,return,a,new,graph,which,contains,only,common,vertices,and,edges,from,the,input,graphs;public,graph,k,null,value,ev,intersect,graph,k,vv,ev,graph,boolean,distinct,edges,data,set,edge,k,ev,intersect,edges,if,distinct,edges,intersect,edges,get,distinct,edge,intersection,graph,get,edges,else,intersect,edges,get,pairwise,edge,intersection,graph,get,edges,return,graph,from,data,set,intersect,edges,get,context
Graph -> public Graph<K, NullValue, EV> intersect(Graph<K, VV, EV> graph, boolean distinctEdges);1490973446;Performs intersect on the edge sets of the input graphs. Edges are considered equal, if they_have the same source identifier, target identifier and edge value._<p>_The method computes pairs of equal edges from the input graphs. If the same edge occurs_multiple times in the input graphs, there will be multiple edge pairs to be considered. Each_edge instance can only be part of one pair. If the given parameter {@code distinctEdges} is set_to {@code true}, there will be exactly one edge in the output graph representing all pairs of_equal edges. If the parameter is set to {@code false}, both edges of each pair will be in the_output._<p>_Vertices in the output graph will have no vertex values.__@param graph the graph to perform intersect with_@param distinctEdges if set to {@code true}, there will be exactly one edge in the output graph_representing all pairs of equal edges, otherwise, for each pair, both_edges will be in the output graph_@return a new graph which contains only common vertices and edges from the input graphs;public Graph<K, NullValue, EV> intersect(Graph<K, VV, EV> graph, boolean distinctEdges) {_		DataSet<Edge<K, EV>> intersectEdges__		if (distinctEdges) {_			intersectEdges = getDistinctEdgeIntersection(graph.getEdges())__		} else {_			intersectEdges = getPairwiseEdgeIntersection(graph.getEdges())__		}__		return Graph.fromDataSet(intersectEdges, getContext())__	};performs,intersect,on,the,edge,sets,of,the,input,graphs,edges,are,considered,equal,if,they,have,the,same,source,identifier,target,identifier,and,edge,value,p,the,method,computes,pairs,of,equal,edges,from,the,input,graphs,if,the,same,edge,occurs,multiple,times,in,the,input,graphs,there,will,be,multiple,edge,pairs,to,be,considered,each,edge,instance,can,only,be,part,of,one,pair,if,the,given,parameter,code,distinct,edges,is,set,to,code,true,there,will,be,exactly,one,edge,in,the,output,graph,representing,all,pairs,of,equal,edges,if,the,parameter,is,set,to,code,false,both,edges,of,each,pair,will,be,in,the,output,p,vertices,in,the,output,graph,will,have,no,vertex,values,param,graph,the,graph,to,perform,intersect,with,param,distinct,edges,if,set,to,code,true,there,will,be,exactly,one,edge,in,the,output,graph,representing,all,pairs,of,equal,edges,otherwise,for,each,pair,both,edges,will,be,in,the,output,graph,return,a,new,graph,which,contains,only,common,vertices,and,edges,from,the,input,graphs;public,graph,k,null,value,ev,intersect,graph,k,vv,ev,graph,boolean,distinct,edges,data,set,edge,k,ev,intersect,edges,if,distinct,edges,intersect,edges,get,distinct,edge,intersection,graph,get,edges,else,intersect,edges,get,pairwise,edge,intersection,graph,get,edges,return,graph,from,data,set,intersect,edges,get,context
Graph -> public Graph<K, NullValue, EV> intersect(Graph<K, VV, EV> graph, boolean distinctEdges);1495819075;Performs intersect on the edge sets of the input graphs. Edges are considered equal, if they_have the same source identifier, target identifier and edge value.__<p>The method computes pairs of equal edges from the input graphs. If the same edge occurs_multiple times in the input graphs, there will be multiple edge pairs to be considered. Each_edge instance can only be part of one pair. If the given parameter {@code distinctEdges} is set_to {@code true}, there will be exactly one edge in the output graph representing all pairs of_equal edges. If the parameter is set to {@code false}, both edges of each pair will be in the_output.__<p>Vertices in the output graph will have no vertex values.__@param graph the graph to perform intersect with_@param distinctEdges if set to {@code true}, there will be exactly one edge in the output graph_representing all pairs of equal edges, otherwise, for each pair, both_edges will be in the output graph_@return a new graph which contains only common vertices and edges from the input graphs;public Graph<K, NullValue, EV> intersect(Graph<K, VV, EV> graph, boolean distinctEdges) {_		DataSet<Edge<K, EV>> intersectEdges__		if (distinctEdges) {_			intersectEdges = getDistinctEdgeIntersection(graph.getEdges())__		} else {_			intersectEdges = getPairwiseEdgeIntersection(graph.getEdges())__		}__		return Graph.fromDataSet(intersectEdges, getContext())__	};performs,intersect,on,the,edge,sets,of,the,input,graphs,edges,are,considered,equal,if,they,have,the,same,source,identifier,target,identifier,and,edge,value,p,the,method,computes,pairs,of,equal,edges,from,the,input,graphs,if,the,same,edge,occurs,multiple,times,in,the,input,graphs,there,will,be,multiple,edge,pairs,to,be,considered,each,edge,instance,can,only,be,part,of,one,pair,if,the,given,parameter,code,distinct,edges,is,set,to,code,true,there,will,be,exactly,one,edge,in,the,output,graph,representing,all,pairs,of,equal,edges,if,the,parameter,is,set,to,code,false,both,edges,of,each,pair,will,be,in,the,output,p,vertices,in,the,output,graph,will,have,no,vertex,values,param,graph,the,graph,to,perform,intersect,with,param,distinct,edges,if,set,to,code,true,there,will,be,exactly,one,edge,in,the,output,graph,representing,all,pairs,of,equal,edges,otherwise,for,each,pair,both,edges,will,be,in,the,output,graph,return,a,new,graph,which,contains,only,common,vertices,and,edges,from,the,input,graphs;public,graph,k,null,value,ev,intersect,graph,k,vv,ev,graph,boolean,distinct,edges,data,set,edge,k,ev,intersect,edges,if,distinct,edges,intersect,edges,get,distinct,edge,intersection,graph,get,edges,else,intersect,edges,get,pairwise,edge,intersection,graph,get,edges,return,graph,from,data,set,intersect,edges,get,context
Graph -> public Graph<K, NullValue, EV> intersect(Graph<K, VV, EV> graph, boolean distinctEdges);1502111816;Performs intersect on the edge sets of the input graphs. Edges are considered equal, if they_have the same source identifier, target identifier and edge value.__<p>The method computes pairs of equal edges from the input graphs. If the same edge occurs_multiple times in the input graphs, there will be multiple edge pairs to be considered. Each_edge instance can only be part of one pair. If the given parameter {@code distinctEdges} is set_to {@code true}, there will be exactly one edge in the output graph representing all pairs of_equal edges. If the parameter is set to {@code false}, both edges of each pair will be in the_output.__<p>Vertices in the output graph will have no vertex values.__@param graph the graph to perform intersect with_@param distinctEdges if set to {@code true}, there will be exactly one edge in the output graph_representing all pairs of equal edges, otherwise, for each pair, both_edges will be in the output graph_@return a new graph which contains only common vertices and edges from the input graphs;public Graph<K, NullValue, EV> intersect(Graph<K, VV, EV> graph, boolean distinctEdges) {_		DataSet<Edge<K, EV>> intersectEdges__		if (distinctEdges) {_			intersectEdges = getDistinctEdgeIntersection(graph.getEdges())__		} else {_			intersectEdges = getPairwiseEdgeIntersection(graph.getEdges())__		}__		return Graph.fromDataSet(intersectEdges, getContext())__	};performs,intersect,on,the,edge,sets,of,the,input,graphs,edges,are,considered,equal,if,they,have,the,same,source,identifier,target,identifier,and,edge,value,p,the,method,computes,pairs,of,equal,edges,from,the,input,graphs,if,the,same,edge,occurs,multiple,times,in,the,input,graphs,there,will,be,multiple,edge,pairs,to,be,considered,each,edge,instance,can,only,be,part,of,one,pair,if,the,given,parameter,code,distinct,edges,is,set,to,code,true,there,will,be,exactly,one,edge,in,the,output,graph,representing,all,pairs,of,equal,edges,if,the,parameter,is,set,to,code,false,both,edges,of,each,pair,will,be,in,the,output,p,vertices,in,the,output,graph,will,have,no,vertex,values,param,graph,the,graph,to,perform,intersect,with,param,distinct,edges,if,set,to,code,true,there,will,be,exactly,one,edge,in,the,output,graph,representing,all,pairs,of,equal,edges,otherwise,for,each,pair,both,edges,will,be,in,the,output,graph,return,a,new,graph,which,contains,only,common,vertices,and,edges,from,the,input,graphs;public,graph,k,null,value,ev,intersect,graph,k,vv,ev,graph,boolean,distinct,edges,data,set,edge,k,ev,intersect,edges,if,distinct,edges,intersect,edges,get,distinct,edge,intersection,graph,get,edges,else,intersect,edges,get,pairwise,edge,intersection,graph,get,edges,return,graph,from,data,set,intersect,edges,get,context
Graph -> public <M> Graph<K, VV, EV> runScatterGatherIteration( 			ScatterFunction<K, VV, M, EV> scatterFunction, 			org.apache.flink.graph.spargel.GatherFunction<K, VV, M> gatherFunction, 			int maximumNumberOfIterations, ScatterGatherConfiguration parameters);1467306272;Runs a ScatterGather iteration on the graph with configuration options.__@param scatterFunction the scatter function_@param gatherFunction the gather function_@param maximumNumberOfIterations maximum number of iterations to perform_@param parameters the iteration configuration parameters__@return the updated Graph after the scatter-gather iteration has converged or_after maximumNumberOfIterations.;public <M> Graph<K, VV, EV> runScatterGatherIteration(_			ScatterFunction<K, VV, M, EV> scatterFunction,_			org.apache.flink.graph.spargel.GatherFunction<K, VV, M> gatherFunction,_			int maximumNumberOfIterations, ScatterGatherConfiguration parameters) {__		ScatterGatherIteration<K, VV, M, EV> iteration = ScatterGatherIteration.withEdges(_				edges, scatterFunction, gatherFunction, maximumNumberOfIterations)___		iteration.configure(parameters)___		DataSet<Vertex<K, VV>> newVertices = this.getVertices().runOperation(iteration)___		return new Graph<K, VV, EV>(newVertices, this.edges, this.context)__	};runs,a,scatter,gather,iteration,on,the,graph,with,configuration,options,param,scatter,function,the,scatter,function,param,gather,function,the,gather,function,param,maximum,number,of,iterations,maximum,number,of,iterations,to,perform,param,parameters,the,iteration,configuration,parameters,return,the,updated,graph,after,the,scatter,gather,iteration,has,converged,or,after,maximum,number,of,iterations;public,m,graph,k,vv,ev,run,scatter,gather,iteration,scatter,function,k,vv,m,ev,scatter,function,org,apache,flink,graph,spargel,gather,function,k,vv,m,gather,function,int,maximum,number,of,iterations,scatter,gather,configuration,parameters,scatter,gather,iteration,k,vv,m,ev,iteration,scatter,gather,iteration,with,edges,edges,scatter,function,gather,function,maximum,number,of,iterations,iteration,configure,parameters,data,set,vertex,k,vv,new,vertices,this,get,vertices,run,operation,iteration,return,new,graph,k,vv,ev,new,vertices,this,edges,this,context
Graph -> public <M> Graph<K, VV, EV> runScatterGatherIteration( 			ScatterFunction<K, VV, M, EV> scatterFunction, 			org.apache.flink.graph.spargel.GatherFunction<K, VV, M> gatherFunction, 			int maximumNumberOfIterations, ScatterGatherConfiguration parameters);1470042815;Runs a ScatterGather iteration on the graph with configuration options.__@param scatterFunction the scatter function_@param gatherFunction the gather function_@param maximumNumberOfIterations maximum number of iterations to perform_@param parameters the iteration configuration parameters__@return the updated Graph after the scatter-gather iteration has converged or_after maximumNumberOfIterations.;public <M> Graph<K, VV, EV> runScatterGatherIteration(_			ScatterFunction<K, VV, M, EV> scatterFunction,_			org.apache.flink.graph.spargel.GatherFunction<K, VV, M> gatherFunction,_			int maximumNumberOfIterations, ScatterGatherConfiguration parameters) {__		ScatterGatherIteration<K, VV, M, EV> iteration = ScatterGatherIteration.withEdges(_				edges, scatterFunction, gatherFunction, maximumNumberOfIterations)___		iteration.configure(parameters)___		DataSet<Vertex<K, VV>> newVertices = this.getVertices().runOperation(iteration)___		return new Graph<K, VV, EV>(newVertices, this.edges, this.context)__	};runs,a,scatter,gather,iteration,on,the,graph,with,configuration,options,param,scatter,function,the,scatter,function,param,gather,function,the,gather,function,param,maximum,number,of,iterations,maximum,number,of,iterations,to,perform,param,parameters,the,iteration,configuration,parameters,return,the,updated,graph,after,the,scatter,gather,iteration,has,converged,or,after,maximum,number,of,iterations;public,m,graph,k,vv,ev,run,scatter,gather,iteration,scatter,function,k,vv,m,ev,scatter,function,org,apache,flink,graph,spargel,gather,function,k,vv,m,gather,function,int,maximum,number,of,iterations,scatter,gather,configuration,parameters,scatter,gather,iteration,k,vv,m,ev,iteration,scatter,gather,iteration,with,edges,edges,scatter,function,gather,function,maximum,number,of,iterations,iteration,configure,parameters,data,set,vertex,k,vv,new,vertices,this,get,vertices,run,operation,iteration,return,new,graph,k,vv,ev,new,vertices,this,edges,this,context
Graph -> public <M> Graph<K, VV, EV> runScatterGatherIteration( 			ScatterFunction<K, VV, M, EV> scatterFunction, 			org.apache.flink.graph.spargel.GatherFunction<K, VV, M> gatherFunction, 			int maximumNumberOfIterations, ScatterGatherConfiguration parameters);1475684776;Runs a ScatterGather iteration on the graph with configuration options.__@param scatterFunction the scatter function_@param gatherFunction the gather function_@param maximumNumberOfIterations maximum number of iterations to perform_@param parameters the iteration configuration parameters__@return the updated Graph after the scatter-gather iteration has converged or_after maximumNumberOfIterations.;public <M> Graph<K, VV, EV> runScatterGatherIteration(_			ScatterFunction<K, VV, M, EV> scatterFunction,_			org.apache.flink.graph.spargel.GatherFunction<K, VV, M> gatherFunction,_			int maximumNumberOfIterations, ScatterGatherConfiguration parameters) {__		ScatterGatherIteration<K, VV, M, EV> iteration = ScatterGatherIteration.withEdges(_				edges, scatterFunction, gatherFunction, maximumNumberOfIterations)___		iteration.configure(parameters)___		DataSet<Vertex<K, VV>> newVertices = this.getVertices().runOperation(iteration)___		return new Graph<>(newVertices, this.edges, this.context)__	};runs,a,scatter,gather,iteration,on,the,graph,with,configuration,options,param,scatter,function,the,scatter,function,param,gather,function,the,gather,function,param,maximum,number,of,iterations,maximum,number,of,iterations,to,perform,param,parameters,the,iteration,configuration,parameters,return,the,updated,graph,after,the,scatter,gather,iteration,has,converged,or,after,maximum,number,of,iterations;public,m,graph,k,vv,ev,run,scatter,gather,iteration,scatter,function,k,vv,m,ev,scatter,function,org,apache,flink,graph,spargel,gather,function,k,vv,m,gather,function,int,maximum,number,of,iterations,scatter,gather,configuration,parameters,scatter,gather,iteration,k,vv,m,ev,iteration,scatter,gather,iteration,with,edges,edges,scatter,function,gather,function,maximum,number,of,iterations,iteration,configure,parameters,data,set,vertex,k,vv,new,vertices,this,get,vertices,run,operation,iteration,return,new,graph,new,vertices,this,edges,this,context
Graph -> public <M> Graph<K, VV, EV> runScatterGatherIteration( 			ScatterFunction<K, VV, M, EV> scatterFunction, 			org.apache.flink.graph.spargel.GatherFunction<K, VV, M> gatherFunction, 			int maximumNumberOfIterations, ScatterGatherConfiguration parameters);1475685606;Runs a ScatterGather iteration on the graph with configuration options.__@param scatterFunction the scatter function_@param gatherFunction the gather function_@param maximumNumberOfIterations maximum number of iterations to perform_@param parameters the iteration configuration parameters__@return the updated Graph after the scatter-gather iteration has converged or_after maximumNumberOfIterations.;public <M> Graph<K, VV, EV> runScatterGatherIteration(_			ScatterFunction<K, VV, M, EV> scatterFunction,_			org.apache.flink.graph.spargel.GatherFunction<K, VV, M> gatherFunction,_			int maximumNumberOfIterations, ScatterGatherConfiguration parameters) {__		ScatterGatherIteration<K, VV, M, EV> iteration = ScatterGatherIteration.withEdges(_				edges, scatterFunction, gatherFunction, maximumNumberOfIterations)___		iteration.configure(parameters)___		DataSet<Vertex<K, VV>> newVertices = this.getVertices().runOperation(iteration)___		return new Graph<>(newVertices, this.edges, this.context)__	};runs,a,scatter,gather,iteration,on,the,graph,with,configuration,options,param,scatter,function,the,scatter,function,param,gather,function,the,gather,function,param,maximum,number,of,iterations,maximum,number,of,iterations,to,perform,param,parameters,the,iteration,configuration,parameters,return,the,updated,graph,after,the,scatter,gather,iteration,has,converged,or,after,maximum,number,of,iterations;public,m,graph,k,vv,ev,run,scatter,gather,iteration,scatter,function,k,vv,m,ev,scatter,function,org,apache,flink,graph,spargel,gather,function,k,vv,m,gather,function,int,maximum,number,of,iterations,scatter,gather,configuration,parameters,scatter,gather,iteration,k,vv,m,ev,iteration,scatter,gather,iteration,with,edges,edges,scatter,function,gather,function,maximum,number,of,iterations,iteration,configure,parameters,data,set,vertex,k,vv,new,vertices,this,get,vertices,run,operation,iteration,return,new,graph,new,vertices,this,edges,this,context
Graph -> public <M> Graph<K, VV, EV> runScatterGatherIteration( 			ScatterFunction<K, VV, M, EV> scatterFunction, 			org.apache.flink.graph.spargel.GatherFunction<K, VV, M> gatherFunction, 			int maximumNumberOfIterations, ScatterGatherConfiguration parameters);1481745825;Runs a ScatterGather iteration on the graph with configuration options.__@param scatterFunction the scatter function_@param gatherFunction the gather function_@param maximumNumberOfIterations maximum number of iterations to perform_@param parameters the iteration configuration parameters__@return the updated Graph after the scatter-gather iteration has converged or_after maximumNumberOfIterations.;public <M> Graph<K, VV, EV> runScatterGatherIteration(_			ScatterFunction<K, VV, M, EV> scatterFunction,_			org.apache.flink.graph.spargel.GatherFunction<K, VV, M> gatherFunction,_			int maximumNumberOfIterations, ScatterGatherConfiguration parameters) {__		ScatterGatherIteration<K, VV, M, EV> iteration = ScatterGatherIteration.withEdges(_				edges, scatterFunction, gatherFunction, maximumNumberOfIterations)___		iteration.configure(parameters)___		DataSet<Vertex<K, VV>> newVertices = this.getVertices().runOperation(iteration)___		return new Graph<>(newVertices, this.edges, this.context)__	};runs,a,scatter,gather,iteration,on,the,graph,with,configuration,options,param,scatter,function,the,scatter,function,param,gather,function,the,gather,function,param,maximum,number,of,iterations,maximum,number,of,iterations,to,perform,param,parameters,the,iteration,configuration,parameters,return,the,updated,graph,after,the,scatter,gather,iteration,has,converged,or,after,maximum,number,of,iterations;public,m,graph,k,vv,ev,run,scatter,gather,iteration,scatter,function,k,vv,m,ev,scatter,function,org,apache,flink,graph,spargel,gather,function,k,vv,m,gather,function,int,maximum,number,of,iterations,scatter,gather,configuration,parameters,scatter,gather,iteration,k,vv,m,ev,iteration,scatter,gather,iteration,with,edges,edges,scatter,function,gather,function,maximum,number,of,iterations,iteration,configure,parameters,data,set,vertex,k,vv,new,vertices,this,get,vertices,run,operation,iteration,return,new,graph,new,vertices,this,edges,this,context
Graph -> public <M> Graph<K, VV, EV> runScatterGatherIteration( 			ScatterFunction<K, VV, M, EV> scatterFunction, 			org.apache.flink.graph.spargel.GatherFunction<K, VV, M> gatherFunction, 			int maximumNumberOfIterations, ScatterGatherConfiguration parameters);1481881009;Runs a ScatterGather iteration on the graph with configuration options.__@param scatterFunction the scatter function_@param gatherFunction the gather function_@param maximumNumberOfIterations maximum number of iterations to perform_@param parameters the iteration configuration parameters__@return the updated Graph after the scatter-gather iteration has converged or_after maximumNumberOfIterations.;public <M> Graph<K, VV, EV> runScatterGatherIteration(_			ScatterFunction<K, VV, M, EV> scatterFunction,_			org.apache.flink.graph.spargel.GatherFunction<K, VV, M> gatherFunction,_			int maximumNumberOfIterations, ScatterGatherConfiguration parameters) {__		ScatterGatherIteration<K, VV, M, EV> iteration = ScatterGatherIteration.withEdges(_				edges, scatterFunction, gatherFunction, maximumNumberOfIterations)___		iteration.configure(parameters)___		DataSet<Vertex<K, VV>> newVertices = this.getVertices().runOperation(iteration)___		return new Graph<>(newVertices, this.edges, this.context)__	};runs,a,scatter,gather,iteration,on,the,graph,with,configuration,options,param,scatter,function,the,scatter,function,param,gather,function,the,gather,function,param,maximum,number,of,iterations,maximum,number,of,iterations,to,perform,param,parameters,the,iteration,configuration,parameters,return,the,updated,graph,after,the,scatter,gather,iteration,has,converged,or,after,maximum,number,of,iterations;public,m,graph,k,vv,ev,run,scatter,gather,iteration,scatter,function,k,vv,m,ev,scatter,function,org,apache,flink,graph,spargel,gather,function,k,vv,m,gather,function,int,maximum,number,of,iterations,scatter,gather,configuration,parameters,scatter,gather,iteration,k,vv,m,ev,iteration,scatter,gather,iteration,with,edges,edges,scatter,function,gather,function,maximum,number,of,iterations,iteration,configure,parameters,data,set,vertex,k,vv,new,vertices,this,get,vertices,run,operation,iteration,return,new,graph,new,vertices,this,edges,this,context
Graph -> public <M> Graph<K, VV, EV> runScatterGatherIteration( 			ScatterFunction<K, VV, M, EV> scatterFunction, 			org.apache.flink.graph.spargel.GatherFunction<K, VV, M> gatherFunction, 			int maximumNumberOfIterations, ScatterGatherConfiguration parameters);1484160227;Runs a ScatterGather iteration on the graph with configuration options.__@param scatterFunction the scatter function_@param gatherFunction the gather function_@param maximumNumberOfIterations maximum number of iterations to perform_@param parameters the iteration configuration parameters__@return the updated Graph after the scatter-gather iteration has converged or_after maximumNumberOfIterations.;public <M> Graph<K, VV, EV> runScatterGatherIteration(_			ScatterFunction<K, VV, M, EV> scatterFunction,_			org.apache.flink.graph.spargel.GatherFunction<K, VV, M> gatherFunction,_			int maximumNumberOfIterations, ScatterGatherConfiguration parameters) {__		ScatterGatherIteration<K, VV, M, EV> iteration = ScatterGatherIteration.withEdges(_				edges, scatterFunction, gatherFunction, maximumNumberOfIterations)___		iteration.configure(parameters)___		DataSet<Vertex<K, VV>> newVertices = this.getVertices().runOperation(iteration)___		return new Graph<>(newVertices, this.edges, this.context)__	};runs,a,scatter,gather,iteration,on,the,graph,with,configuration,options,param,scatter,function,the,scatter,function,param,gather,function,the,gather,function,param,maximum,number,of,iterations,maximum,number,of,iterations,to,perform,param,parameters,the,iteration,configuration,parameters,return,the,updated,graph,after,the,scatter,gather,iteration,has,converged,or,after,maximum,number,of,iterations;public,m,graph,k,vv,ev,run,scatter,gather,iteration,scatter,function,k,vv,m,ev,scatter,function,org,apache,flink,graph,spargel,gather,function,k,vv,m,gather,function,int,maximum,number,of,iterations,scatter,gather,configuration,parameters,scatter,gather,iteration,k,vv,m,ev,iteration,scatter,gather,iteration,with,edges,edges,scatter,function,gather,function,maximum,number,of,iterations,iteration,configure,parameters,data,set,vertex,k,vv,new,vertices,this,get,vertices,run,operation,iteration,return,new,graph,new,vertices,this,edges,this,context
Graph -> public <M> Graph<K, VV, EV> runScatterGatherIteration( 			ScatterFunction<K, VV, M, EV> scatterFunction, 			org.apache.flink.graph.spargel.GatherFunction<K, VV, M> gatherFunction, 			int maximumNumberOfIterations, ScatterGatherConfiguration parameters);1484685504;Runs a ScatterGather iteration on the graph with configuration options.__@param scatterFunction the scatter function_@param gatherFunction the gather function_@param maximumNumberOfIterations maximum number of iterations to perform_@param parameters the iteration configuration parameters__@return the updated Graph after the scatter-gather iteration has converged or_after maximumNumberOfIterations.;public <M> Graph<K, VV, EV> runScatterGatherIteration(_			ScatterFunction<K, VV, M, EV> scatterFunction,_			org.apache.flink.graph.spargel.GatherFunction<K, VV, M> gatherFunction,_			int maximumNumberOfIterations, ScatterGatherConfiguration parameters) {__		ScatterGatherIteration<K, VV, M, EV> iteration = ScatterGatherIteration.withEdges(_				edges, scatterFunction, gatherFunction, maximumNumberOfIterations)___		iteration.configure(parameters)___		DataSet<Vertex<K, VV>> newVertices = this.getVertices().runOperation(iteration)___		return new Graph<>(newVertices, this.edges, this.context)__	};runs,a,scatter,gather,iteration,on,the,graph,with,configuration,options,param,scatter,function,the,scatter,function,param,gather,function,the,gather,function,param,maximum,number,of,iterations,maximum,number,of,iterations,to,perform,param,parameters,the,iteration,configuration,parameters,return,the,updated,graph,after,the,scatter,gather,iteration,has,converged,or,after,maximum,number,of,iterations;public,m,graph,k,vv,ev,run,scatter,gather,iteration,scatter,function,k,vv,m,ev,scatter,function,org,apache,flink,graph,spargel,gather,function,k,vv,m,gather,function,int,maximum,number,of,iterations,scatter,gather,configuration,parameters,scatter,gather,iteration,k,vv,m,ev,iteration,scatter,gather,iteration,with,edges,edges,scatter,function,gather,function,maximum,number,of,iterations,iteration,configure,parameters,data,set,vertex,k,vv,new,vertices,this,get,vertices,run,operation,iteration,return,new,graph,new,vertices,this,edges,this,context
Graph -> public <M> Graph<K, VV, EV> runScatterGatherIteration( 			ScatterFunction<K, VV, M, EV> scatterFunction, 			org.apache.flink.graph.spargel.GatherFunction<K, VV, M> gatherFunction, 			int maximumNumberOfIterations, ScatterGatherConfiguration parameters);1489068942;Runs a ScatterGather iteration on the graph with configuration options.__@param scatterFunction the scatter function_@param gatherFunction the gather function_@param maximumNumberOfIterations maximum number of iterations to perform_@param parameters the iteration configuration parameters__@return the updated Graph after the scatter-gather iteration has converged or_after maximumNumberOfIterations.;public <M> Graph<K, VV, EV> runScatterGatherIteration(_			ScatterFunction<K, VV, M, EV> scatterFunction,_			org.apache.flink.graph.spargel.GatherFunction<K, VV, M> gatherFunction,_			int maximumNumberOfIterations, ScatterGatherConfiguration parameters) {__		ScatterGatherIteration<K, VV, M, EV> iteration = ScatterGatherIteration.withEdges(_				edges, scatterFunction, gatherFunction, maximumNumberOfIterations)___		iteration.configure(parameters)___		DataSet<Vertex<K, VV>> newVertices = this.getVertices().runOperation(iteration)___		return new Graph<>(newVertices, this.edges, this.context)__	};runs,a,scatter,gather,iteration,on,the,graph,with,configuration,options,param,scatter,function,the,scatter,function,param,gather,function,the,gather,function,param,maximum,number,of,iterations,maximum,number,of,iterations,to,perform,param,parameters,the,iteration,configuration,parameters,return,the,updated,graph,after,the,scatter,gather,iteration,has,converged,or,after,maximum,number,of,iterations;public,m,graph,k,vv,ev,run,scatter,gather,iteration,scatter,function,k,vv,m,ev,scatter,function,org,apache,flink,graph,spargel,gather,function,k,vv,m,gather,function,int,maximum,number,of,iterations,scatter,gather,configuration,parameters,scatter,gather,iteration,k,vv,m,ev,iteration,scatter,gather,iteration,with,edges,edges,scatter,function,gather,function,maximum,number,of,iterations,iteration,configure,parameters,data,set,vertex,k,vv,new,vertices,this,get,vertices,run,operation,iteration,return,new,graph,new,vertices,this,edges,this,context
Graph -> public <M> Graph<K, VV, EV> runScatterGatherIteration( 			ScatterFunction<K, VV, M, EV> scatterFunction, 			org.apache.flink.graph.spargel.GatherFunction<K, VV, M> gatherFunction, 			int maximumNumberOfIterations, ScatterGatherConfiguration parameters);1490973446;Runs a ScatterGather iteration on the graph with configuration options.__@param scatterFunction the scatter function_@param gatherFunction the gather function_@param maximumNumberOfIterations maximum number of iterations to perform_@param parameters the iteration configuration parameters__@return the updated Graph after the scatter-gather iteration has converged or_after maximumNumberOfIterations.;public <M> Graph<K, VV, EV> runScatterGatherIteration(_			ScatterFunction<K, VV, M, EV> scatterFunction,_			org.apache.flink.graph.spargel.GatherFunction<K, VV, M> gatherFunction,_			int maximumNumberOfIterations, ScatterGatherConfiguration parameters) {__		ScatterGatherIteration<K, VV, M, EV> iteration = ScatterGatherIteration.withEdges(_				edges, scatterFunction, gatherFunction, maximumNumberOfIterations)___		iteration.configure(parameters)___		DataSet<Vertex<K, VV>> newVertices = this.getVertices().runOperation(iteration)___		return new Graph<>(newVertices, this.edges, this.context)__	};runs,a,scatter,gather,iteration,on,the,graph,with,configuration,options,param,scatter,function,the,scatter,function,param,gather,function,the,gather,function,param,maximum,number,of,iterations,maximum,number,of,iterations,to,perform,param,parameters,the,iteration,configuration,parameters,return,the,updated,graph,after,the,scatter,gather,iteration,has,converged,or,after,maximum,number,of,iterations;public,m,graph,k,vv,ev,run,scatter,gather,iteration,scatter,function,k,vv,m,ev,scatter,function,org,apache,flink,graph,spargel,gather,function,k,vv,m,gather,function,int,maximum,number,of,iterations,scatter,gather,configuration,parameters,scatter,gather,iteration,k,vv,m,ev,iteration,scatter,gather,iteration,with,edges,edges,scatter,function,gather,function,maximum,number,of,iterations,iteration,configure,parameters,data,set,vertex,k,vv,new,vertices,this,get,vertices,run,operation,iteration,return,new,graph,new,vertices,this,edges,this,context
Graph -> public <M> Graph<K, VV, EV> runScatterGatherIteration( 			ScatterFunction<K, VV, M, EV> scatterFunction, 			org.apache.flink.graph.spargel.GatherFunction<K, VV, M> gatherFunction, 			int maximumNumberOfIterations, ScatterGatherConfiguration parameters);1495819075;Runs a ScatterGather iteration on the graph with configuration options.__@param scatterFunction the scatter function_@param gatherFunction the gather function_@param maximumNumberOfIterations maximum number of iterations to perform_@param parameters the iteration configuration parameters__@return the updated Graph after the scatter-gather iteration has converged or_after maximumNumberOfIterations.;public <M> Graph<K, VV, EV> runScatterGatherIteration(_			ScatterFunction<K, VV, M, EV> scatterFunction,_			org.apache.flink.graph.spargel.GatherFunction<K, VV, M> gatherFunction,_			int maximumNumberOfIterations, ScatterGatherConfiguration parameters) {__		ScatterGatherIteration<K, VV, M, EV> iteration = ScatterGatherIteration.withEdges(_				edges, scatterFunction, gatherFunction, maximumNumberOfIterations)___		iteration.configure(parameters)___		DataSet<Vertex<K, VV>> newVertices = this.getVertices().runOperation(iteration)___		return new Graph<>(newVertices, this.edges, this.context)__	};runs,a,scatter,gather,iteration,on,the,graph,with,configuration,options,param,scatter,function,the,scatter,function,param,gather,function,the,gather,function,param,maximum,number,of,iterations,maximum,number,of,iterations,to,perform,param,parameters,the,iteration,configuration,parameters,return,the,updated,graph,after,the,scatter,gather,iteration,has,converged,or,after,maximum,number,of,iterations;public,m,graph,k,vv,ev,run,scatter,gather,iteration,scatter,function,k,vv,m,ev,scatter,function,org,apache,flink,graph,spargel,gather,function,k,vv,m,gather,function,int,maximum,number,of,iterations,scatter,gather,configuration,parameters,scatter,gather,iteration,k,vv,m,ev,iteration,scatter,gather,iteration,with,edges,edges,scatter,function,gather,function,maximum,number,of,iterations,iteration,configure,parameters,data,set,vertex,k,vv,new,vertices,this,get,vertices,run,operation,iteration,return,new,graph,new,vertices,this,edges,this,context
Graph -> public <M> Graph<K, VV, EV> runScatterGatherIteration( 			ScatterFunction<K, VV, M, EV> scatterFunction, 			org.apache.flink.graph.spargel.GatherFunction<K, VV, M> gatherFunction, 			int maximumNumberOfIterations, ScatterGatherConfiguration parameters);1502111816;Runs a ScatterGather iteration on the graph with configuration options.__@param scatterFunction the scatter function_@param gatherFunction the gather function_@param maximumNumberOfIterations maximum number of iterations to perform_@param parameters the iteration configuration parameters__@return the updated Graph after the scatter-gather iteration has converged or_after maximumNumberOfIterations.;public <M> Graph<K, VV, EV> runScatterGatherIteration(_			ScatterFunction<K, VV, M, EV> scatterFunction,_			org.apache.flink.graph.spargel.GatherFunction<K, VV, M> gatherFunction,_			int maximumNumberOfIterations, ScatterGatherConfiguration parameters) {__		ScatterGatherIteration<K, VV, M, EV> iteration = ScatterGatherIteration.withEdges(_				edges, scatterFunction, gatherFunction, maximumNumberOfIterations)___		iteration.configure(parameters)___		DataSet<Vertex<K, VV>> newVertices = this.getVertices().runOperation(iteration)___		return new Graph<>(newVertices, this.edges, this.context)__	};runs,a,scatter,gather,iteration,on,the,graph,with,configuration,options,param,scatter,function,the,scatter,function,param,gather,function,the,gather,function,param,maximum,number,of,iterations,maximum,number,of,iterations,to,perform,param,parameters,the,iteration,configuration,parameters,return,the,updated,graph,after,the,scatter,gather,iteration,has,converged,or,after,maximum,number,of,iterations;public,m,graph,k,vv,ev,run,scatter,gather,iteration,scatter,function,k,vv,m,ev,scatter,function,org,apache,flink,graph,spargel,gather,function,k,vv,m,gather,function,int,maximum,number,of,iterations,scatter,gather,configuration,parameters,scatter,gather,iteration,k,vv,m,ev,iteration,scatter,gather,iteration,with,edges,edges,scatter,function,gather,function,maximum,number,of,iterations,iteration,configure,parameters,data,set,vertex,k,vv,new,vertices,this,get,vertices,run,operation,iteration,return,new,graph,new,vertices,this,edges,this,context
Graph -> public <M> Graph<K, VV, EV> runVertexCentricIteration( 			VertexUpdateFunction<K, VV, M> vertexUpdateFunction, 			MessagingFunction<K, VV, M, EV> messagingFunction, 			int maximumNumberOfIterations);1444404795;Runs a Vertex-Centric iteration on the graph._No configuration options are provided.__@param vertexUpdateFunction the vertex update function_@param messagingFunction the messaging function_@param maximumNumberOfIterations maximum number of iterations to perform__@return the updated Graph after the vertex-centric iteration has converged or_after maximumNumberOfIterations.;public <M> Graph<K, VV, EV> runVertexCentricIteration(_			VertexUpdateFunction<K, VV, M> vertexUpdateFunction,_			MessagingFunction<K, VV, M, EV> messagingFunction,_			int maximumNumberOfIterations) {__		return this.runVertexCentricIteration(vertexUpdateFunction, messagingFunction,_				maximumNumberOfIterations, null)__	};runs,a,vertex,centric,iteration,on,the,graph,no,configuration,options,are,provided,param,vertex,update,function,the,vertex,update,function,param,messaging,function,the,messaging,function,param,maximum,number,of,iterations,maximum,number,of,iterations,to,perform,return,the,updated,graph,after,the,vertex,centric,iteration,has,converged,or,after,maximum,number,of,iterations;public,m,graph,k,vv,ev,run,vertex,centric,iteration,vertex,update,function,k,vv,m,vertex,update,function,messaging,function,k,vv,m,ev,messaging,function,int,maximum,number,of,iterations,return,this,run,vertex,centric,iteration,vertex,update,function,messaging,function,maximum,number,of,iterations,null
Graph -> public <M> Graph<K, VV, EV> runVertexCentricIteration( 			VertexUpdateFunction<K, VV, M> vertexUpdateFunction, 			MessagingFunction<K, VV, M, EV> messagingFunction, 			int maximumNumberOfIterations);1445261977;Runs a Vertex-Centric iteration on the graph._No configuration options are provided.__@param vertexUpdateFunction the vertex update function_@param messagingFunction the messaging function_@param maximumNumberOfIterations maximum number of iterations to perform__@return the updated Graph after the vertex-centric iteration has converged or_after maximumNumberOfIterations.;public <M> Graph<K, VV, EV> runVertexCentricIteration(_			VertexUpdateFunction<K, VV, M> vertexUpdateFunction,_			MessagingFunction<K, VV, M, EV> messagingFunction,_			int maximumNumberOfIterations) {__		return this.runVertexCentricIteration(vertexUpdateFunction, messagingFunction,_				maximumNumberOfIterations, null)__	};runs,a,vertex,centric,iteration,on,the,graph,no,configuration,options,are,provided,param,vertex,update,function,the,vertex,update,function,param,messaging,function,the,messaging,function,param,maximum,number,of,iterations,maximum,number,of,iterations,to,perform,return,the,updated,graph,after,the,vertex,centric,iteration,has,converged,or,after,maximum,number,of,iterations;public,m,graph,k,vv,ev,run,vertex,centric,iteration,vertex,update,function,k,vv,m,vertex,update,function,messaging,function,k,vv,m,ev,messaging,function,int,maximum,number,of,iterations,return,this,run,vertex,centric,iteration,vertex,update,function,messaging,function,maximum,number,of,iterations,null
Graph -> public <M> Graph<K, VV, EV> runVertexCentricIteration( 			VertexUpdateFunction<K, VV, M> vertexUpdateFunction, 			MessagingFunction<K, VV, M, EV> messagingFunction, 			int maximumNumberOfIterations);1445854323;Runs a Vertex-Centric iteration on the graph._No configuration options are provided.__@param vertexUpdateFunction the vertex update function_@param messagingFunction the messaging function_@param maximumNumberOfIterations maximum number of iterations to perform__@return the updated Graph after the vertex-centric iteration has converged or_after maximumNumberOfIterations.;public <M> Graph<K, VV, EV> runVertexCentricIteration(_			VertexUpdateFunction<K, VV, M> vertexUpdateFunction,_			MessagingFunction<K, VV, M, EV> messagingFunction,_			int maximumNumberOfIterations) {__		return this.runVertexCentricIteration(vertexUpdateFunction, messagingFunction,_				maximumNumberOfIterations, null)__	};runs,a,vertex,centric,iteration,on,the,graph,no,configuration,options,are,provided,param,vertex,update,function,the,vertex,update,function,param,messaging,function,the,messaging,function,param,maximum,number,of,iterations,maximum,number,of,iterations,to,perform,return,the,updated,graph,after,the,vertex,centric,iteration,has,converged,or,after,maximum,number,of,iterations;public,m,graph,k,vv,ev,run,vertex,centric,iteration,vertex,update,function,k,vv,m,vertex,update,function,messaging,function,k,vv,m,ev,messaging,function,int,maximum,number,of,iterations,return,this,run,vertex,centric,iteration,vertex,update,function,messaging,function,maximum,number,of,iterations,null
Graph -> public <M> Graph<K, VV, EV> runVertexCentricIteration( 			VertexUpdateFunction<K, VV, M> vertexUpdateFunction, 			MessagingFunction<K, VV, M, EV> messagingFunction, 			int maximumNumberOfIterations);1446112342;Runs a Vertex-Centric iteration on the graph._No configuration options are provided.__@param vertexUpdateFunction the vertex update function_@param messagingFunction the messaging function_@param maximumNumberOfIterations maximum number of iterations to perform__@return the updated Graph after the vertex-centric iteration has converged or_after maximumNumberOfIterations.;public <M> Graph<K, VV, EV> runVertexCentricIteration(_			VertexUpdateFunction<K, VV, M> vertexUpdateFunction,_			MessagingFunction<K, VV, M, EV> messagingFunction,_			int maximumNumberOfIterations) {__		return this.runVertexCentricIteration(vertexUpdateFunction, messagingFunction,_				maximumNumberOfIterations, null)__	};runs,a,vertex,centric,iteration,on,the,graph,no,configuration,options,are,provided,param,vertex,update,function,the,vertex,update,function,param,messaging,function,the,messaging,function,param,maximum,number,of,iterations,maximum,number,of,iterations,to,perform,return,the,updated,graph,after,the,vertex,centric,iteration,has,converged,or,after,maximum,number,of,iterations;public,m,graph,k,vv,ev,run,vertex,centric,iteration,vertex,update,function,k,vv,m,vertex,update,function,messaging,function,k,vv,m,ev,messaging,function,int,maximum,number,of,iterations,return,this,run,vertex,centric,iteration,vertex,update,function,messaging,function,maximum,number,of,iterations,null
Graph -> public <M> Graph<K, VV, EV> runVertexCentricIteration( 			VertexUpdateFunction<K, VV, M> vertexUpdateFunction, 			MessagingFunction<K, VV, M, EV> messagingFunction, 			int maximumNumberOfIterations);1447073368;Runs a Vertex-Centric iteration on the graph._No configuration options are provided.__@param vertexUpdateFunction the vertex update function_@param messagingFunction the messaging function_@param maximumNumberOfIterations maximum number of iterations to perform__@return the updated Graph after the vertex-centric iteration has converged or_after maximumNumberOfIterations.;public <M> Graph<K, VV, EV> runVertexCentricIteration(_			VertexUpdateFunction<K, VV, M> vertexUpdateFunction,_			MessagingFunction<K, VV, M, EV> messagingFunction,_			int maximumNumberOfIterations) {__		return this.runVertexCentricIteration(vertexUpdateFunction, messagingFunction,_				maximumNumberOfIterations, null)__	};runs,a,vertex,centric,iteration,on,the,graph,no,configuration,options,are,provided,param,vertex,update,function,the,vertex,update,function,param,messaging,function,the,messaging,function,param,maximum,number,of,iterations,maximum,number,of,iterations,to,perform,return,the,updated,graph,after,the,vertex,centric,iteration,has,converged,or,after,maximum,number,of,iterations;public,m,graph,k,vv,ev,run,vertex,centric,iteration,vertex,update,function,k,vv,m,vertex,update,function,messaging,function,k,vv,m,ev,messaging,function,int,maximum,number,of,iterations,return,this,run,vertex,centric,iteration,vertex,update,function,messaging,function,maximum,number,of,iterations,null
Graph -> public <T> Graph<K, VV, EV> joinWithEdgesOnSource(DataSet<Tuple2<K, T>> inputDataSet, 			final EdgeJoinFunction<EV, T> edgeJoinFunction);1445261977;Joins the edge DataSet with an input Tuple2 DataSet and applies a user-defined transformation_on the values of the matched records._The source ID of the edges input and the first field of the input DataSet are used as join keys.__@param inputDataSet the DataSet to join with._The first field of the Tuple2 is used as the join key_and the second field is passed as a parameter to the transformation function._@param edgeJoinFunction the transformation function to apply._The first parameter is the current edge value and the second parameter is the value_of the matched Tuple2 from the input DataSet._@param <T> the type of the second field of the input Tuple2 DataSet._@return a new Graph, where the edge values have been updated according to the_result of the edgeJoinFunction.;public <T> Graph<K, VV, EV> joinWithEdgesOnSource(DataSet<Tuple2<K, T>> inputDataSet,_			final EdgeJoinFunction<EV, T> edgeJoinFunction) {__		DataSet<Edge<K, EV>> resultedEdges = this.getEdges()_				.coGroup(inputDataSet).where(0).equalTo(0)_				.with(new ApplyCoGroupToEdgeValuesOnEitherSourceOrTarget<K, EV, T>(edgeJoinFunction))___		return new Graph<K, VV, EV>(this.vertices, resultedEdges, this.context)__	};joins,the,edge,data,set,with,an,input,tuple2,data,set,and,applies,a,user,defined,transformation,on,the,values,of,the,matched,records,the,source,id,of,the,edges,input,and,the,first,field,of,the,input,data,set,are,used,as,join,keys,param,input,data,set,the,data,set,to,join,with,the,first,field,of,the,tuple2,is,used,as,the,join,key,and,the,second,field,is,passed,as,a,parameter,to,the,transformation,function,param,edge,join,function,the,transformation,function,to,apply,the,first,parameter,is,the,current,edge,value,and,the,second,parameter,is,the,value,of,the,matched,tuple2,from,the,input,data,set,param,t,the,type,of,the,second,field,of,the,input,tuple2,data,set,return,a,new,graph,where,the,edge,values,have,been,updated,according,to,the,result,of,the,edge,join,function;public,t,graph,k,vv,ev,join,with,edges,on,source,data,set,tuple2,k,t,input,data,set,final,edge,join,function,ev,t,edge,join,function,data,set,edge,k,ev,resulted,edges,this,get,edges,co,group,input,data,set,where,0,equal,to,0,with,new,apply,co,group,to,edge,values,on,either,source,or,target,k,ev,t,edge,join,function,return,new,graph,k,vv,ev,this,vertices,resulted,edges,this,context
Graph -> public <T> Graph<K, VV, EV> joinWithEdgesOnSource(DataSet<Tuple2<K, T>> inputDataSet, 			final EdgeJoinFunction<EV, T> edgeJoinFunction);1445854323;Joins the edge DataSet with an input Tuple2 DataSet and applies a user-defined transformation_on the values of the matched records._The source ID of the edges input and the first field of the input DataSet are used as join keys.__@param inputDataSet the DataSet to join with._The first field of the Tuple2 is used as the join key_and the second field is passed as a parameter to the transformation function._@param edgeJoinFunction the transformation function to apply._The first parameter is the current edge value and the second parameter is the value_of the matched Tuple2 from the input DataSet._@param <T> the type of the second field of the input Tuple2 DataSet._@return a new Graph, where the edge values have been updated according to the_result of the edgeJoinFunction.;public <T> Graph<K, VV, EV> joinWithEdgesOnSource(DataSet<Tuple2<K, T>> inputDataSet,_			final EdgeJoinFunction<EV, T> edgeJoinFunction) {__		DataSet<Edge<K, EV>> resultedEdges = this.getEdges()_				.coGroup(inputDataSet).where(0).equalTo(0)_				.with(new ApplyCoGroupToEdgeValuesOnEitherSourceOrTarget<K, EV, T>(edgeJoinFunction))___		return new Graph<K, VV, EV>(this.vertices, resultedEdges, this.context)__	};joins,the,edge,data,set,with,an,input,tuple2,data,set,and,applies,a,user,defined,transformation,on,the,values,of,the,matched,records,the,source,id,of,the,edges,input,and,the,first,field,of,the,input,data,set,are,used,as,join,keys,param,input,data,set,the,data,set,to,join,with,the,first,field,of,the,tuple2,is,used,as,the,join,key,and,the,second,field,is,passed,as,a,parameter,to,the,transformation,function,param,edge,join,function,the,transformation,function,to,apply,the,first,parameter,is,the,current,edge,value,and,the,second,parameter,is,the,value,of,the,matched,tuple2,from,the,input,data,set,param,t,the,type,of,the,second,field,of,the,input,tuple2,data,set,return,a,new,graph,where,the,edge,values,have,been,updated,according,to,the,result,of,the,edge,join,function;public,t,graph,k,vv,ev,join,with,edges,on,source,data,set,tuple2,k,t,input,data,set,final,edge,join,function,ev,t,edge,join,function,data,set,edge,k,ev,resulted,edges,this,get,edges,co,group,input,data,set,where,0,equal,to,0,with,new,apply,co,group,to,edge,values,on,either,source,or,target,k,ev,t,edge,join,function,return,new,graph,k,vv,ev,this,vertices,resulted,edges,this,context
Graph -> public <T> Graph<K, VV, EV> joinWithEdgesOnSource(DataSet<Tuple2<K, T>> inputDataSet, 			final EdgeJoinFunction<EV, T> edgeJoinFunction);1446112342;Joins the edge DataSet with an input Tuple2 DataSet and applies a user-defined transformation_on the values of the matched records._The source ID of the edges input and the first field of the input DataSet are used as join keys.__@param inputDataSet the DataSet to join with._The first field of the Tuple2 is used as the join key_and the second field is passed as a parameter to the transformation function._@param edgeJoinFunction the transformation function to apply._The first parameter is the current edge value and the second parameter is the value_of the matched Tuple2 from the input DataSet._@param <T> the type of the second field of the input Tuple2 DataSet._@return a new Graph, where the edge values have been updated according to the_result of the edgeJoinFunction.;public <T> Graph<K, VV, EV> joinWithEdgesOnSource(DataSet<Tuple2<K, T>> inputDataSet,_			final EdgeJoinFunction<EV, T> edgeJoinFunction) {__		DataSet<Edge<K, EV>> resultedEdges = this.getEdges()_				.coGroup(inputDataSet).where(0).equalTo(0)_				.with(new ApplyCoGroupToEdgeValuesOnEitherSourceOrTarget<K, EV, T>(edgeJoinFunction))___		return new Graph<K, VV, EV>(this.vertices, resultedEdges, this.context)__	};joins,the,edge,data,set,with,an,input,tuple2,data,set,and,applies,a,user,defined,transformation,on,the,values,of,the,matched,records,the,source,id,of,the,edges,input,and,the,first,field,of,the,input,data,set,are,used,as,join,keys,param,input,data,set,the,data,set,to,join,with,the,first,field,of,the,tuple2,is,used,as,the,join,key,and,the,second,field,is,passed,as,a,parameter,to,the,transformation,function,param,edge,join,function,the,transformation,function,to,apply,the,first,parameter,is,the,current,edge,value,and,the,second,parameter,is,the,value,of,the,matched,tuple2,from,the,input,data,set,param,t,the,type,of,the,second,field,of,the,input,tuple2,data,set,return,a,new,graph,where,the,edge,values,have,been,updated,according,to,the,result,of,the,edge,join,function;public,t,graph,k,vv,ev,join,with,edges,on,source,data,set,tuple2,k,t,input,data,set,final,edge,join,function,ev,t,edge,join,function,data,set,edge,k,ev,resulted,edges,this,get,edges,co,group,input,data,set,where,0,equal,to,0,with,new,apply,co,group,to,edge,values,on,either,source,or,target,k,ev,t,edge,join,function,return,new,graph,k,vv,ev,this,vertices,resulted,edges,this,context
Graph -> public <T> Graph<K, VV, EV> joinWithEdgesOnSource(DataSet<Tuple2<K, T>> inputDataSet, 			final EdgeJoinFunction<EV, T> edgeJoinFunction);1447073368;Joins the edge DataSet with an input Tuple2 DataSet and applies a user-defined transformation_on the values of the matched records._The source ID of the edges input and the first field of the input DataSet are used as join keys.__@param inputDataSet the DataSet to join with._The first field of the Tuple2 is used as the join key_and the second field is passed as a parameter to the transformation function._@param edgeJoinFunction the transformation function to apply._The first parameter is the current edge value and the second parameter is the value_of the matched Tuple2 from the input DataSet._@param <T> the type of the second field of the input Tuple2 DataSet._@return a new Graph, where the edge values have been updated according to the_result of the edgeJoinFunction.;public <T> Graph<K, VV, EV> joinWithEdgesOnSource(DataSet<Tuple2<K, T>> inputDataSet,_			final EdgeJoinFunction<EV, T> edgeJoinFunction) {__		DataSet<Edge<K, EV>> resultedEdges = this.getEdges()_				.coGroup(inputDataSet).where(0).equalTo(0)_				.with(new ApplyCoGroupToEdgeValuesOnEitherSourceOrTarget<K, EV, T>(edgeJoinFunction))___		return new Graph<K, VV, EV>(this.vertices, resultedEdges, this.context)__	};joins,the,edge,data,set,with,an,input,tuple2,data,set,and,applies,a,user,defined,transformation,on,the,values,of,the,matched,records,the,source,id,of,the,edges,input,and,the,first,field,of,the,input,data,set,are,used,as,join,keys,param,input,data,set,the,data,set,to,join,with,the,first,field,of,the,tuple2,is,used,as,the,join,key,and,the,second,field,is,passed,as,a,parameter,to,the,transformation,function,param,edge,join,function,the,transformation,function,to,apply,the,first,parameter,is,the,current,edge,value,and,the,second,parameter,is,the,value,of,the,matched,tuple2,from,the,input,data,set,param,t,the,type,of,the,second,field,of,the,input,tuple2,data,set,return,a,new,graph,where,the,edge,values,have,been,updated,according,to,the,result,of,the,edge,join,function;public,t,graph,k,vv,ev,join,with,edges,on,source,data,set,tuple2,k,t,input,data,set,final,edge,join,function,ev,t,edge,join,function,data,set,edge,k,ev,resulted,edges,this,get,edges,co,group,input,data,set,where,0,equal,to,0,with,new,apply,co,group,to,edge,values,on,either,source,or,target,k,ev,t,edge,join,function,return,new,graph,k,vv,ev,this,vertices,resulted,edges,this,context
Graph -> public <T> Graph<K, VV, EV> joinWithEdgesOnSource(DataSet<Tuple2<K, T>> inputDataSet, 			final EdgeJoinFunction<EV, T> edgeJoinFunction);1454404649;Joins the edge DataSet with an input Tuple2 DataSet and applies a user-defined transformation_on the values of the matched records._The source ID of the edges input and the first field of the input DataSet are used as join keys.__@param inputDataSet the DataSet to join with._The first field of the Tuple2 is used as the join key_and the second field is passed as a parameter to the transformation function._@param edgeJoinFunction the transformation function to apply._The first parameter is the current edge value and the second parameter is the value_of the matched Tuple2 from the input DataSet._@param <T> the type of the second field of the input Tuple2 DataSet._@return a new Graph, where the edge values have been updated according to the_result of the edgeJoinFunction.;public <T> Graph<K, VV, EV> joinWithEdgesOnSource(DataSet<Tuple2<K, T>> inputDataSet,_			final EdgeJoinFunction<EV, T> edgeJoinFunction) {__		DataSet<Edge<K, EV>> resultedEdges = this.getEdges()_				.coGroup(inputDataSet).where(0).equalTo(0)_				.with(new ApplyCoGroupToEdgeValuesOnEitherSourceOrTarget<K, EV, T>(edgeJoinFunction))___		return new Graph<K, VV, EV>(this.vertices, resultedEdges, this.context)__	};joins,the,edge,data,set,with,an,input,tuple2,data,set,and,applies,a,user,defined,transformation,on,the,values,of,the,matched,records,the,source,id,of,the,edges,input,and,the,first,field,of,the,input,data,set,are,used,as,join,keys,param,input,data,set,the,data,set,to,join,with,the,first,field,of,the,tuple2,is,used,as,the,join,key,and,the,second,field,is,passed,as,a,parameter,to,the,transformation,function,param,edge,join,function,the,transformation,function,to,apply,the,first,parameter,is,the,current,edge,value,and,the,second,parameter,is,the,value,of,the,matched,tuple2,from,the,input,data,set,param,t,the,type,of,the,second,field,of,the,input,tuple2,data,set,return,a,new,graph,where,the,edge,values,have,been,updated,according,to,the,result,of,the,edge,join,function;public,t,graph,k,vv,ev,join,with,edges,on,source,data,set,tuple2,k,t,input,data,set,final,edge,join,function,ev,t,edge,join,function,data,set,edge,k,ev,resulted,edges,this,get,edges,co,group,input,data,set,where,0,equal,to,0,with,new,apply,co,group,to,edge,values,on,either,source,or,target,k,ev,t,edge,join,function,return,new,graph,k,vv,ev,this,vertices,resulted,edges,this,context
Graph -> public <T> Graph<K, VV, EV> joinWithEdgesOnSource(DataSet<Tuple2<K, T>> inputDataSet, 			final EdgeJoinFunction<EV, T> edgeJoinFunction);1458583829;Joins the edge DataSet with an input Tuple2 DataSet and applies a user-defined transformation_on the values of the matched records._The source ID of the edges input and the first field of the input DataSet are used as join keys.__@param inputDataSet the DataSet to join with._The first field of the Tuple2 is used as the join key_and the second field is passed as a parameter to the transformation function._@param edgeJoinFunction the transformation function to apply._The first parameter is the current edge value and the second parameter is the value_of the matched Tuple2 from the input DataSet._@param <T> the type of the second field of the input Tuple2 DataSet._@return a new Graph, where the edge values have been updated according to the_result of the edgeJoinFunction.;public <T> Graph<K, VV, EV> joinWithEdgesOnSource(DataSet<Tuple2<K, T>> inputDataSet,_			final EdgeJoinFunction<EV, T> edgeJoinFunction) {__		DataSet<Edge<K, EV>> resultedEdges = this.getEdges()_				.coGroup(inputDataSet).where(0).equalTo(0)_				.with(new ApplyCoGroupToEdgeValuesOnEitherSourceOrTarget<K, EV, T>(edgeJoinFunction))___		return new Graph<K, VV, EV>(this.vertices, resultedEdges, this.context)__	};joins,the,edge,data,set,with,an,input,tuple2,data,set,and,applies,a,user,defined,transformation,on,the,values,of,the,matched,records,the,source,id,of,the,edges,input,and,the,first,field,of,the,input,data,set,are,used,as,join,keys,param,input,data,set,the,data,set,to,join,with,the,first,field,of,the,tuple2,is,used,as,the,join,key,and,the,second,field,is,passed,as,a,parameter,to,the,transformation,function,param,edge,join,function,the,transformation,function,to,apply,the,first,parameter,is,the,current,edge,value,and,the,second,parameter,is,the,value,of,the,matched,tuple2,from,the,input,data,set,param,t,the,type,of,the,second,field,of,the,input,tuple2,data,set,return,a,new,graph,where,the,edge,values,have,been,updated,according,to,the,result,of,the,edge,join,function;public,t,graph,k,vv,ev,join,with,edges,on,source,data,set,tuple2,k,t,input,data,set,final,edge,join,function,ev,t,edge,join,function,data,set,edge,k,ev,resulted,edges,this,get,edges,co,group,input,data,set,where,0,equal,to,0,with,new,apply,co,group,to,edge,values,on,either,source,or,target,k,ev,t,edge,join,function,return,new,graph,k,vv,ev,this,vertices,resulted,edges,this,context
Graph -> public <T> Graph<K, VV, EV> joinWithEdgesOnSource(DataSet<Tuple2<K, T>> inputDataSet, 			final EdgeJoinFunction<EV, T> edgeJoinFunction);1458583829;Joins the edge DataSet with an input Tuple2 DataSet and applies a user-defined transformation_on the values of the matched records._The source ID of the edges input and the first field of the input DataSet are used as join keys.__@param inputDataSet the DataSet to join with._The first field of the Tuple2 is used as the join key_and the second field is passed as a parameter to the transformation function._@param edgeJoinFunction the transformation function to apply._The first parameter is the current edge value and the second parameter is the value_of the matched Tuple2 from the input DataSet._@param <T> the type of the second field of the input Tuple2 DataSet._@return a new Graph, where the edge values have been updated according to the_result of the edgeJoinFunction.;public <T> Graph<K, VV, EV> joinWithEdgesOnSource(DataSet<Tuple2<K, T>> inputDataSet,_			final EdgeJoinFunction<EV, T> edgeJoinFunction) {__		DataSet<Edge<K, EV>> resultedEdges = this.getEdges()_				.coGroup(inputDataSet).where(0).equalTo(0)_				.with(new ApplyCoGroupToEdgeValuesOnEitherSourceOrTarget<K, EV, T>(edgeJoinFunction))___		return new Graph<K, VV, EV>(this.vertices, resultedEdges, this.context)__	};joins,the,edge,data,set,with,an,input,tuple2,data,set,and,applies,a,user,defined,transformation,on,the,values,of,the,matched,records,the,source,id,of,the,edges,input,and,the,first,field,of,the,input,data,set,are,used,as,join,keys,param,input,data,set,the,data,set,to,join,with,the,first,field,of,the,tuple2,is,used,as,the,join,key,and,the,second,field,is,passed,as,a,parameter,to,the,transformation,function,param,edge,join,function,the,transformation,function,to,apply,the,first,parameter,is,the,current,edge,value,and,the,second,parameter,is,the,value,of,the,matched,tuple2,from,the,input,data,set,param,t,the,type,of,the,second,field,of,the,input,tuple2,data,set,return,a,new,graph,where,the,edge,values,have,been,updated,according,to,the,result,of,the,edge,join,function;public,t,graph,k,vv,ev,join,with,edges,on,source,data,set,tuple2,k,t,input,data,set,final,edge,join,function,ev,t,edge,join,function,data,set,edge,k,ev,resulted,edges,this,get,edges,co,group,input,data,set,where,0,equal,to,0,with,new,apply,co,group,to,edge,values,on,either,source,or,target,k,ev,t,edge,join,function,return,new,graph,k,vv,ev,this,vertices,resulted,edges,this,context
Graph -> public <T> Graph<K, VV, EV> joinWithEdgesOnSource(DataSet<Tuple2<K, T>> inputDataSet, 			final EdgeJoinFunction<EV, T> edgeJoinFunction);1462100316;Joins the edge DataSet with an input Tuple2 DataSet and applies a user-defined transformation_on the values of the matched records._The source ID of the edges input and the first field of the input DataSet are used as join keys.__@param inputDataSet the DataSet to join with._The first field of the Tuple2 is used as the join key_and the second field is passed as a parameter to the transformation function._@param edgeJoinFunction the transformation function to apply._The first parameter is the current edge value and the second parameter is the value_of the matched Tuple2 from the input DataSet._@param <T> the type of the second field of the input Tuple2 DataSet._@return a new Graph, where the edge values have been updated according to the_result of the edgeJoinFunction.;public <T> Graph<K, VV, EV> joinWithEdgesOnSource(DataSet<Tuple2<K, T>> inputDataSet,_			final EdgeJoinFunction<EV, T> edgeJoinFunction) {__		DataSet<Edge<K, EV>> resultedEdges = this.getEdges()_				.coGroup(inputDataSet).where(0).equalTo(0)_				.with(new ApplyCoGroupToEdgeValuesOnEitherSourceOrTarget<K, EV, T>(edgeJoinFunction))___		return new Graph<K, VV, EV>(this.vertices, resultedEdges, this.context)__	};joins,the,edge,data,set,with,an,input,tuple2,data,set,and,applies,a,user,defined,transformation,on,the,values,of,the,matched,records,the,source,id,of,the,edges,input,and,the,first,field,of,the,input,data,set,are,used,as,join,keys,param,input,data,set,the,data,set,to,join,with,the,first,field,of,the,tuple2,is,used,as,the,join,key,and,the,second,field,is,passed,as,a,parameter,to,the,transformation,function,param,edge,join,function,the,transformation,function,to,apply,the,first,parameter,is,the,current,edge,value,and,the,second,parameter,is,the,value,of,the,matched,tuple2,from,the,input,data,set,param,t,the,type,of,the,second,field,of,the,input,tuple2,data,set,return,a,new,graph,where,the,edge,values,have,been,updated,according,to,the,result,of,the,edge,join,function;public,t,graph,k,vv,ev,join,with,edges,on,source,data,set,tuple2,k,t,input,data,set,final,edge,join,function,ev,t,edge,join,function,data,set,edge,k,ev,resulted,edges,this,get,edges,co,group,input,data,set,where,0,equal,to,0,with,new,apply,co,group,to,edge,values,on,either,source,or,target,k,ev,t,edge,join,function,return,new,graph,k,vv,ev,this,vertices,resulted,edges,this,context
Graph -> public <T> Graph<K, VV, EV> joinWithEdgesOnSource(DataSet<Tuple2<K, T>> inputDataSet, 			final EdgeJoinFunction<EV, T> edgeJoinFunction);1462100316;Joins the edge DataSet with an input Tuple2 DataSet and applies a user-defined transformation_on the values of the matched records._The source ID of the edges input and the first field of the input DataSet are used as join keys.__@param inputDataSet the DataSet to join with._The first field of the Tuple2 is used as the join key_and the second field is passed as a parameter to the transformation function._@param edgeJoinFunction the transformation function to apply._The first parameter is the current edge value and the second parameter is the value_of the matched Tuple2 from the input DataSet._@param <T> the type of the second field of the input Tuple2 DataSet._@return a new Graph, where the edge values have been updated according to the_result of the edgeJoinFunction.;public <T> Graph<K, VV, EV> joinWithEdgesOnSource(DataSet<Tuple2<K, T>> inputDataSet,_			final EdgeJoinFunction<EV, T> edgeJoinFunction) {__		DataSet<Edge<K, EV>> resultedEdges = this.getEdges()_				.coGroup(inputDataSet).where(0).equalTo(0)_				.with(new ApplyCoGroupToEdgeValuesOnEitherSourceOrTarget<K, EV, T>(edgeJoinFunction))___		return new Graph<K, VV, EV>(this.vertices, resultedEdges, this.context)__	};joins,the,edge,data,set,with,an,input,tuple2,data,set,and,applies,a,user,defined,transformation,on,the,values,of,the,matched,records,the,source,id,of,the,edges,input,and,the,first,field,of,the,input,data,set,are,used,as,join,keys,param,input,data,set,the,data,set,to,join,with,the,first,field,of,the,tuple2,is,used,as,the,join,key,and,the,second,field,is,passed,as,a,parameter,to,the,transformation,function,param,edge,join,function,the,transformation,function,to,apply,the,first,parameter,is,the,current,edge,value,and,the,second,parameter,is,the,value,of,the,matched,tuple2,from,the,input,data,set,param,t,the,type,of,the,second,field,of,the,input,tuple2,data,set,return,a,new,graph,where,the,edge,values,have,been,updated,according,to,the,result,of,the,edge,join,function;public,t,graph,k,vv,ev,join,with,edges,on,source,data,set,tuple2,k,t,input,data,set,final,edge,join,function,ev,t,edge,join,function,data,set,edge,k,ev,resulted,edges,this,get,edges,co,group,input,data,set,where,0,equal,to,0,with,new,apply,co,group,to,edge,values,on,either,source,or,target,k,ev,t,edge,join,function,return,new,graph,k,vv,ev,this,vertices,resulted,edges,this,context
Graph -> public <T> Graph<K, VV, EV> joinWithEdgesOnSource(DataSet<Tuple2<K, T>> inputDataSet, 			final EdgeJoinFunction<EV, T> edgeJoinFunction);1462205213;Joins the edge DataSet with an input Tuple2 DataSet and applies a user-defined transformation_on the values of the matched records._The source ID of the edges input and the first field of the input DataSet are used as join keys.__@param inputDataSet the DataSet to join with._The first field of the Tuple2 is used as the join key_and the second field is passed as a parameter to the transformation function._@param edgeJoinFunction the transformation function to apply._The first parameter is the current edge value and the second parameter is the value_of the matched Tuple2 from the input DataSet._@param <T> the type of the second field of the input Tuple2 DataSet._@return a new Graph, where the edge values have been updated according to the_result of the edgeJoinFunction.;public <T> Graph<K, VV, EV> joinWithEdgesOnSource(DataSet<Tuple2<K, T>> inputDataSet,_			final EdgeJoinFunction<EV, T> edgeJoinFunction) {__		DataSet<Edge<K, EV>> resultedEdges = this.getEdges()_				.coGroup(inputDataSet).where(0).equalTo(0)_				.with(new ApplyCoGroupToEdgeValuesOnEitherSourceOrTarget<K, EV, T>(edgeJoinFunction))___		return new Graph<K, VV, EV>(this.vertices, resultedEdges, this.context)__	};joins,the,edge,data,set,with,an,input,tuple2,data,set,and,applies,a,user,defined,transformation,on,the,values,of,the,matched,records,the,source,id,of,the,edges,input,and,the,first,field,of,the,input,data,set,are,used,as,join,keys,param,input,data,set,the,data,set,to,join,with,the,first,field,of,the,tuple2,is,used,as,the,join,key,and,the,second,field,is,passed,as,a,parameter,to,the,transformation,function,param,edge,join,function,the,transformation,function,to,apply,the,first,parameter,is,the,current,edge,value,and,the,second,parameter,is,the,value,of,the,matched,tuple2,from,the,input,data,set,param,t,the,type,of,the,second,field,of,the,input,tuple2,data,set,return,a,new,graph,where,the,edge,values,have,been,updated,according,to,the,result,of,the,edge,join,function;public,t,graph,k,vv,ev,join,with,edges,on,source,data,set,tuple2,k,t,input,data,set,final,edge,join,function,ev,t,edge,join,function,data,set,edge,k,ev,resulted,edges,this,get,edges,co,group,input,data,set,where,0,equal,to,0,with,new,apply,co,group,to,edge,values,on,either,source,or,target,k,ev,t,edge,join,function,return,new,graph,k,vv,ev,this,vertices,resulted,edges,this,context
Graph -> public <T> Graph<K, VV, EV> joinWithEdgesOnSource(DataSet<Tuple2<K, T>> inputDataSet, 			final EdgeJoinFunction<EV, T> edgeJoinFunction);1462208859;Joins the edge DataSet with an input Tuple2 DataSet and applies a user-defined transformation_on the values of the matched records._The source ID of the edges input and the first field of the input DataSet are used as join keys.__@param inputDataSet the DataSet to join with._The first field of the Tuple2 is used as the join key_and the second field is passed as a parameter to the transformation function._@param edgeJoinFunction the transformation function to apply._The first parameter is the current edge value and the second parameter is the value_of the matched Tuple2 from the input DataSet._@param <T> the type of the second field of the input Tuple2 DataSet._@return a new Graph, where the edge values have been updated according to the_result of the edgeJoinFunction.;public <T> Graph<K, VV, EV> joinWithEdgesOnSource(DataSet<Tuple2<K, T>> inputDataSet,_			final EdgeJoinFunction<EV, T> edgeJoinFunction) {__		DataSet<Edge<K, EV>> resultedEdges = this.getEdges()_				.coGroup(inputDataSet).where(0).equalTo(0)_				.with(new ApplyCoGroupToEdgeValuesOnEitherSourceOrTarget<K, EV, T>(edgeJoinFunction))___		return new Graph<K, VV, EV>(this.vertices, resultedEdges, this.context)__	};joins,the,edge,data,set,with,an,input,tuple2,data,set,and,applies,a,user,defined,transformation,on,the,values,of,the,matched,records,the,source,id,of,the,edges,input,and,the,first,field,of,the,input,data,set,are,used,as,join,keys,param,input,data,set,the,data,set,to,join,with,the,first,field,of,the,tuple2,is,used,as,the,join,key,and,the,second,field,is,passed,as,a,parameter,to,the,transformation,function,param,edge,join,function,the,transformation,function,to,apply,the,first,parameter,is,the,current,edge,value,and,the,second,parameter,is,the,value,of,the,matched,tuple2,from,the,input,data,set,param,t,the,type,of,the,second,field,of,the,input,tuple2,data,set,return,a,new,graph,where,the,edge,values,have,been,updated,according,to,the,result,of,the,edge,join,function;public,t,graph,k,vv,ev,join,with,edges,on,source,data,set,tuple2,k,t,input,data,set,final,edge,join,function,ev,t,edge,join,function,data,set,edge,k,ev,resulted,edges,this,get,edges,co,group,input,data,set,where,0,equal,to,0,with,new,apply,co,group,to,edge,values,on,either,source,or,target,k,ev,t,edge,join,function,return,new,graph,k,vv,ev,this,vertices,resulted,edges,this,context
Graph -> public <T> Graph<K, VV, EV> joinWithEdgesOnSource(DataSet<Tuple2<K, T>> inputDataSet, 			final EdgeJoinFunction<EV, T> edgeJoinFunction);1462809297;Joins the edge DataSet with an input Tuple2 DataSet and applies a user-defined transformation_on the values of the matched records._The source ID of the edges input and the first field of the input DataSet are used as join keys.__@param inputDataSet the DataSet to join with._The first field of the Tuple2 is used as the join key_and the second field is passed as a parameter to the transformation function._@param edgeJoinFunction the transformation function to apply._The first parameter is the current edge value and the second parameter is the value_of the matched Tuple2 from the input DataSet._@param <T> the type of the second field of the input Tuple2 DataSet._@return a new Graph, where the edge values have been updated according to the_result of the edgeJoinFunction.;public <T> Graph<K, VV, EV> joinWithEdgesOnSource(DataSet<Tuple2<K, T>> inputDataSet,_			final EdgeJoinFunction<EV, T> edgeJoinFunction) {__		DataSet<Edge<K, EV>> resultedEdges = this.getEdges()_				.coGroup(inputDataSet).where(0).equalTo(0)_				.with(new ApplyCoGroupToEdgeValuesOnEitherSourceOrTarget<K, EV, T>(edgeJoinFunction))___		return new Graph<K, VV, EV>(this.vertices, resultedEdges, this.context)__	};joins,the,edge,data,set,with,an,input,tuple2,data,set,and,applies,a,user,defined,transformation,on,the,values,of,the,matched,records,the,source,id,of,the,edges,input,and,the,first,field,of,the,input,data,set,are,used,as,join,keys,param,input,data,set,the,data,set,to,join,with,the,first,field,of,the,tuple2,is,used,as,the,join,key,and,the,second,field,is,passed,as,a,parameter,to,the,transformation,function,param,edge,join,function,the,transformation,function,to,apply,the,first,parameter,is,the,current,edge,value,and,the,second,parameter,is,the,value,of,the,matched,tuple2,from,the,input,data,set,param,t,the,type,of,the,second,field,of,the,input,tuple2,data,set,return,a,new,graph,where,the,edge,values,have,been,updated,according,to,the,result,of,the,edge,join,function;public,t,graph,k,vv,ev,join,with,edges,on,source,data,set,tuple2,k,t,input,data,set,final,edge,join,function,ev,t,edge,join,function,data,set,edge,k,ev,resulted,edges,this,get,edges,co,group,input,data,set,where,0,equal,to,0,with,new,apply,co,group,to,edge,values,on,either,source,or,target,k,ev,t,edge,join,function,return,new,graph,k,vv,ev,this,vertices,resulted,edges,this,context
Graph -> public <T> Graph<K, VV, EV> joinWithEdgesOnSource(DataSet<Tuple2<K, T>> inputDataSet, 			final EdgeJoinFunction<EV, T> edgeJoinFunction);1465316775;Joins the edge DataSet with an input Tuple2 DataSet and applies a user-defined transformation_on the values of the matched records._The source ID of the edges input and the first field of the input DataSet are used as join keys.__@param inputDataSet the DataSet to join with._The first field of the Tuple2 is used as the join key_and the second field is passed as a parameter to the transformation function._@param edgeJoinFunction the transformation function to apply._The first parameter is the current edge value and the second parameter is the value_of the matched Tuple2 from the input DataSet._@param <T> the type of the second field of the input Tuple2 DataSet._@return a new Graph, where the edge values have been updated according to the_result of the edgeJoinFunction.;public <T> Graph<K, VV, EV> joinWithEdgesOnSource(DataSet<Tuple2<K, T>> inputDataSet,_			final EdgeJoinFunction<EV, T> edgeJoinFunction) {__		DataSet<Edge<K, EV>> resultedEdges = this.getEdges()_				.coGroup(inputDataSet).where(0).equalTo(0)_				.with(new ApplyCoGroupToEdgeValuesOnEitherSourceOrTarget<K, EV, T>(edgeJoinFunction))___		return new Graph<K, VV, EV>(this.vertices, resultedEdges, this.context)__	};joins,the,edge,data,set,with,an,input,tuple2,data,set,and,applies,a,user,defined,transformation,on,the,values,of,the,matched,records,the,source,id,of,the,edges,input,and,the,first,field,of,the,input,data,set,are,used,as,join,keys,param,input,data,set,the,data,set,to,join,with,the,first,field,of,the,tuple2,is,used,as,the,join,key,and,the,second,field,is,passed,as,a,parameter,to,the,transformation,function,param,edge,join,function,the,transformation,function,to,apply,the,first,parameter,is,the,current,edge,value,and,the,second,parameter,is,the,value,of,the,matched,tuple2,from,the,input,data,set,param,t,the,type,of,the,second,field,of,the,input,tuple2,data,set,return,a,new,graph,where,the,edge,values,have,been,updated,according,to,the,result,of,the,edge,join,function;public,t,graph,k,vv,ev,join,with,edges,on,source,data,set,tuple2,k,t,input,data,set,final,edge,join,function,ev,t,edge,join,function,data,set,edge,k,ev,resulted,edges,this,get,edges,co,group,input,data,set,where,0,equal,to,0,with,new,apply,co,group,to,edge,values,on,either,source,or,target,k,ev,t,edge,join,function,return,new,graph,k,vv,ev,this,vertices,resulted,edges,this,context
Graph -> public <T> Graph<K, VV, EV> joinWithEdgesOnSource(DataSet<Tuple2<K, T>> inputDataSet, 			final EdgeJoinFunction<EV, T> edgeJoinFunction);1466789678;Joins the edge DataSet with an input Tuple2 DataSet and applies a user-defined transformation_on the values of the matched records._The source ID of the edges input and the first field of the input DataSet are used as join keys.__@param inputDataSet the DataSet to join with._The first field of the Tuple2 is used as the join key_and the second field is passed as a parameter to the transformation function._@param edgeJoinFunction the transformation function to apply._The first parameter is the current edge value and the second parameter is the value_of the matched Tuple2 from the input DataSet._@param <T> the type of the second field of the input Tuple2 DataSet._@return a new Graph, where the edge values have been updated according to the_result of the edgeJoinFunction.;public <T> Graph<K, VV, EV> joinWithEdgesOnSource(DataSet<Tuple2<K, T>> inputDataSet,_			final EdgeJoinFunction<EV, T> edgeJoinFunction) {__		DataSet<Edge<K, EV>> resultedEdges = this.getEdges()_				.coGroup(inputDataSet).where(0).equalTo(0)_				.with(new ApplyCoGroupToEdgeValuesOnEitherSourceOrTarget<K, EV, T>(edgeJoinFunction))___		return new Graph<K, VV, EV>(this.vertices, resultedEdges, this.context)__	};joins,the,edge,data,set,with,an,input,tuple2,data,set,and,applies,a,user,defined,transformation,on,the,values,of,the,matched,records,the,source,id,of,the,edges,input,and,the,first,field,of,the,input,data,set,are,used,as,join,keys,param,input,data,set,the,data,set,to,join,with,the,first,field,of,the,tuple2,is,used,as,the,join,key,and,the,second,field,is,passed,as,a,parameter,to,the,transformation,function,param,edge,join,function,the,transformation,function,to,apply,the,first,parameter,is,the,current,edge,value,and,the,second,parameter,is,the,value,of,the,matched,tuple2,from,the,input,data,set,param,t,the,type,of,the,second,field,of,the,input,tuple2,data,set,return,a,new,graph,where,the,edge,values,have,been,updated,according,to,the,result,of,the,edge,join,function;public,t,graph,k,vv,ev,join,with,edges,on,source,data,set,tuple2,k,t,input,data,set,final,edge,join,function,ev,t,edge,join,function,data,set,edge,k,ev,resulted,edges,this,get,edges,co,group,input,data,set,where,0,equal,to,0,with,new,apply,co,group,to,edge,values,on,either,source,or,target,k,ev,t,edge,join,function,return,new,graph,k,vv,ev,this,vertices,resulted,edges,this,context
Graph -> public <T> Graph<K, VV, EV> joinWithEdgesOnSource(DataSet<Tuple2<K, T>> inputDataSet, 			final EdgeJoinFunction<EV, T> edgeJoinFunction);1467140656;Joins the edge DataSet with an input Tuple2 DataSet and applies a user-defined transformation_on the values of the matched records._The source ID of the edges input and the first field of the input DataSet are used as join keys.__@param inputDataSet the DataSet to join with._The first field of the Tuple2 is used as the join key_and the second field is passed as a parameter to the transformation function._@param edgeJoinFunction the transformation function to apply._The first parameter is the current edge value and the second parameter is the value_of the matched Tuple2 from the input DataSet._@param <T> the type of the second field of the input Tuple2 DataSet._@return a new Graph, where the edge values have been updated according to the_result of the edgeJoinFunction.;public <T> Graph<K, VV, EV> joinWithEdgesOnSource(DataSet<Tuple2<K, T>> inputDataSet,_			final EdgeJoinFunction<EV, T> edgeJoinFunction) {__		DataSet<Edge<K, EV>> resultedEdges = this.getEdges()_				.coGroup(inputDataSet).where(0).equalTo(0)_				.with(new ApplyCoGroupToEdgeValuesOnEitherSourceOrTarget<K, EV, T>(edgeJoinFunction))___		return new Graph<K, VV, EV>(this.vertices, resultedEdges, this.context)__	};joins,the,edge,data,set,with,an,input,tuple2,data,set,and,applies,a,user,defined,transformation,on,the,values,of,the,matched,records,the,source,id,of,the,edges,input,and,the,first,field,of,the,input,data,set,are,used,as,join,keys,param,input,data,set,the,data,set,to,join,with,the,first,field,of,the,tuple2,is,used,as,the,join,key,and,the,second,field,is,passed,as,a,parameter,to,the,transformation,function,param,edge,join,function,the,transformation,function,to,apply,the,first,parameter,is,the,current,edge,value,and,the,second,parameter,is,the,value,of,the,matched,tuple2,from,the,input,data,set,param,t,the,type,of,the,second,field,of,the,input,tuple2,data,set,return,a,new,graph,where,the,edge,values,have,been,updated,according,to,the,result,of,the,edge,join,function;public,t,graph,k,vv,ev,join,with,edges,on,source,data,set,tuple2,k,t,input,data,set,final,edge,join,function,ev,t,edge,join,function,data,set,edge,k,ev,resulted,edges,this,get,edges,co,group,input,data,set,where,0,equal,to,0,with,new,apply,co,group,to,edge,values,on,either,source,or,target,k,ev,t,edge,join,function,return,new,graph,k,vv,ev,this,vertices,resulted,edges,this,context
Graph -> public <T> Graph<K, VV, EV> joinWithEdgesOnSource(DataSet<Tuple2<K, T>> inputDataSet, 			final EdgeJoinFunction<EV, T> edgeJoinFunction);1467306272;Joins the edge DataSet with an input Tuple2 DataSet and applies a user-defined transformation_on the values of the matched records._The source ID of the edges input and the first field of the input DataSet are used as join keys.__@param inputDataSet the DataSet to join with._The first field of the Tuple2 is used as the join key_and the second field is passed as a parameter to the transformation function._@param edgeJoinFunction the transformation function to apply._The first parameter is the current edge value and the second parameter is the value_of the matched Tuple2 from the input DataSet._@param <T> the type of the second field of the input Tuple2 DataSet._@return a new Graph, where the edge values have been updated according to the_result of the edgeJoinFunction.;public <T> Graph<K, VV, EV> joinWithEdgesOnSource(DataSet<Tuple2<K, T>> inputDataSet,_			final EdgeJoinFunction<EV, T> edgeJoinFunction) {__		DataSet<Edge<K, EV>> resultedEdges = this.getEdges()_				.coGroup(inputDataSet).where(0).equalTo(0)_				.with(new ApplyCoGroupToEdgeValuesOnEitherSourceOrTarget<K, EV, T>(edgeJoinFunction))___		return new Graph<K, VV, EV>(this.vertices, resultedEdges, this.context)__	};joins,the,edge,data,set,with,an,input,tuple2,data,set,and,applies,a,user,defined,transformation,on,the,values,of,the,matched,records,the,source,id,of,the,edges,input,and,the,first,field,of,the,input,data,set,are,used,as,join,keys,param,input,data,set,the,data,set,to,join,with,the,first,field,of,the,tuple2,is,used,as,the,join,key,and,the,second,field,is,passed,as,a,parameter,to,the,transformation,function,param,edge,join,function,the,transformation,function,to,apply,the,first,parameter,is,the,current,edge,value,and,the,second,parameter,is,the,value,of,the,matched,tuple2,from,the,input,data,set,param,t,the,type,of,the,second,field,of,the,input,tuple2,data,set,return,a,new,graph,where,the,edge,values,have,been,updated,according,to,the,result,of,the,edge,join,function;public,t,graph,k,vv,ev,join,with,edges,on,source,data,set,tuple2,k,t,input,data,set,final,edge,join,function,ev,t,edge,join,function,data,set,edge,k,ev,resulted,edges,this,get,edges,co,group,input,data,set,where,0,equal,to,0,with,new,apply,co,group,to,edge,values,on,either,source,or,target,k,ev,t,edge,join,function,return,new,graph,k,vv,ev,this,vertices,resulted,edges,this,context
Graph -> public <T> Graph<K, VV, EV> joinWithEdgesOnSource(DataSet<Tuple2<K, T>> inputDataSet, 			final EdgeJoinFunction<EV, T> edgeJoinFunction);1470042815;Joins the edge DataSet with an input Tuple2 DataSet and applies a user-defined transformation_on the values of the matched records._The source ID of the edges input and the first field of the input DataSet are used as join keys.__@param inputDataSet the DataSet to join with._The first field of the Tuple2 is used as the join key_and the second field is passed as a parameter to the transformation function._@param edgeJoinFunction the transformation function to apply._The first parameter is the current edge value and the second parameter is the value_of the matched Tuple2 from the input DataSet._@param <T> the type of the second field of the input Tuple2 DataSet._@return a new Graph, where the edge values have been updated according to the_result of the edgeJoinFunction.;public <T> Graph<K, VV, EV> joinWithEdgesOnSource(DataSet<Tuple2<K, T>> inputDataSet,_			final EdgeJoinFunction<EV, T> edgeJoinFunction) {__		DataSet<Edge<K, EV>> resultedEdges = this.getEdges()_				.coGroup(inputDataSet).where(0).equalTo(0)_				.with(new ApplyCoGroupToEdgeValuesOnEitherSourceOrTarget<K, EV, T>(edgeJoinFunction))___		return new Graph<K, VV, EV>(this.vertices, resultedEdges, this.context)__	};joins,the,edge,data,set,with,an,input,tuple2,data,set,and,applies,a,user,defined,transformation,on,the,values,of,the,matched,records,the,source,id,of,the,edges,input,and,the,first,field,of,the,input,data,set,are,used,as,join,keys,param,input,data,set,the,data,set,to,join,with,the,first,field,of,the,tuple2,is,used,as,the,join,key,and,the,second,field,is,passed,as,a,parameter,to,the,transformation,function,param,edge,join,function,the,transformation,function,to,apply,the,first,parameter,is,the,current,edge,value,and,the,second,parameter,is,the,value,of,the,matched,tuple2,from,the,input,data,set,param,t,the,type,of,the,second,field,of,the,input,tuple2,data,set,return,a,new,graph,where,the,edge,values,have,been,updated,according,to,the,result,of,the,edge,join,function;public,t,graph,k,vv,ev,join,with,edges,on,source,data,set,tuple2,k,t,input,data,set,final,edge,join,function,ev,t,edge,join,function,data,set,edge,k,ev,resulted,edges,this,get,edges,co,group,input,data,set,where,0,equal,to,0,with,new,apply,co,group,to,edge,values,on,either,source,or,target,k,ev,t,edge,join,function,return,new,graph,k,vv,ev,this,vertices,resulted,edges,this,context
Graph -> public <T> Graph<K, VV, EV> joinWithEdgesOnSource(DataSet<Tuple2<K, T>> inputDataSet, 			final EdgeJoinFunction<EV, T> edgeJoinFunction);1475684776;Joins the edge DataSet with an input Tuple2 DataSet and applies a user-defined transformation_on the values of the matched records._The source ID of the edges input and the first field of the input DataSet are used as join keys.__@param inputDataSet the DataSet to join with._The first field of the Tuple2 is used as the join key_and the second field is passed as a parameter to the transformation function._@param edgeJoinFunction the transformation function to apply._The first parameter is the current edge value and the second parameter is the value_of the matched Tuple2 from the input DataSet._@param <T> the type of the second field of the input Tuple2 DataSet._@return a new Graph, where the edge values have been updated according to the_result of the edgeJoinFunction.;public <T> Graph<K, VV, EV> joinWithEdgesOnSource(DataSet<Tuple2<K, T>> inputDataSet,_			final EdgeJoinFunction<EV, T> edgeJoinFunction) {__		DataSet<Edge<K, EV>> resultedEdges = this.getEdges()_				.coGroup(inputDataSet).where(0).equalTo(0)_				.with(new ApplyCoGroupToEdgeValuesOnEitherSourceOrTarget<K, EV, T>(edgeJoinFunction))___		return new Graph<>(this.vertices, resultedEdges, this.context)__	};joins,the,edge,data,set,with,an,input,tuple2,data,set,and,applies,a,user,defined,transformation,on,the,values,of,the,matched,records,the,source,id,of,the,edges,input,and,the,first,field,of,the,input,data,set,are,used,as,join,keys,param,input,data,set,the,data,set,to,join,with,the,first,field,of,the,tuple2,is,used,as,the,join,key,and,the,second,field,is,passed,as,a,parameter,to,the,transformation,function,param,edge,join,function,the,transformation,function,to,apply,the,first,parameter,is,the,current,edge,value,and,the,second,parameter,is,the,value,of,the,matched,tuple2,from,the,input,data,set,param,t,the,type,of,the,second,field,of,the,input,tuple2,data,set,return,a,new,graph,where,the,edge,values,have,been,updated,according,to,the,result,of,the,edge,join,function;public,t,graph,k,vv,ev,join,with,edges,on,source,data,set,tuple2,k,t,input,data,set,final,edge,join,function,ev,t,edge,join,function,data,set,edge,k,ev,resulted,edges,this,get,edges,co,group,input,data,set,where,0,equal,to,0,with,new,apply,co,group,to,edge,values,on,either,source,or,target,k,ev,t,edge,join,function,return,new,graph,this,vertices,resulted,edges,this,context
Graph -> public <T> Graph<K, VV, EV> joinWithEdgesOnSource(DataSet<Tuple2<K, T>> inputDataSet, 			final EdgeJoinFunction<EV, T> edgeJoinFunction);1475685606;Joins the edge DataSet with an input Tuple2 DataSet and applies a user-defined transformation_on the values of the matched records._The source ID of the edges input and the first field of the input DataSet are used as join keys.__@param inputDataSet the DataSet to join with._The first field of the Tuple2 is used as the join key_and the second field is passed as a parameter to the transformation function._@param edgeJoinFunction the transformation function to apply._The first parameter is the current edge value and the second parameter is the value_of the matched Tuple2 from the input DataSet._@param <T> the type of the second field of the input Tuple2 DataSet._@return a new Graph, where the edge values have been updated according to the_result of the edgeJoinFunction.;public <T> Graph<K, VV, EV> joinWithEdgesOnSource(DataSet<Tuple2<K, T>> inputDataSet,_			final EdgeJoinFunction<EV, T> edgeJoinFunction) {__		DataSet<Edge<K, EV>> resultedEdges = this.getEdges()_				.coGroup(inputDataSet).where(0).equalTo(0)_				.with(new ApplyCoGroupToEdgeValuesOnEitherSourceOrTarget<K, EV, T>(edgeJoinFunction))___		return new Graph<>(this.vertices, resultedEdges, this.context)__	};joins,the,edge,data,set,with,an,input,tuple2,data,set,and,applies,a,user,defined,transformation,on,the,values,of,the,matched,records,the,source,id,of,the,edges,input,and,the,first,field,of,the,input,data,set,are,used,as,join,keys,param,input,data,set,the,data,set,to,join,with,the,first,field,of,the,tuple2,is,used,as,the,join,key,and,the,second,field,is,passed,as,a,parameter,to,the,transformation,function,param,edge,join,function,the,transformation,function,to,apply,the,first,parameter,is,the,current,edge,value,and,the,second,parameter,is,the,value,of,the,matched,tuple2,from,the,input,data,set,param,t,the,type,of,the,second,field,of,the,input,tuple2,data,set,return,a,new,graph,where,the,edge,values,have,been,updated,according,to,the,result,of,the,edge,join,function;public,t,graph,k,vv,ev,join,with,edges,on,source,data,set,tuple2,k,t,input,data,set,final,edge,join,function,ev,t,edge,join,function,data,set,edge,k,ev,resulted,edges,this,get,edges,co,group,input,data,set,where,0,equal,to,0,with,new,apply,co,group,to,edge,values,on,either,source,or,target,k,ev,t,edge,join,function,return,new,graph,this,vertices,resulted,edges,this,context
Graph -> public <T> Graph<K, VV, EV> joinWithEdgesOnSource(DataSet<Tuple2<K, T>> inputDataSet, 			final EdgeJoinFunction<EV, T> edgeJoinFunction);1481745825;Joins the edge DataSet with an input Tuple2 DataSet and applies a user-defined transformation_on the values of the matched records._The source ID of the edges input and the first field of the input DataSet are used as join keys.__@param inputDataSet the DataSet to join with._The first field of the Tuple2 is used as the join key_and the second field is passed as a parameter to the transformation function._@param edgeJoinFunction the transformation function to apply._The first parameter is the current edge value and the second parameter is the value_of the matched Tuple2 from the input DataSet._@param <T> the type of the second field of the input Tuple2 DataSet._@return a new Graph, where the edge values have been updated according to the_result of the edgeJoinFunction.;public <T> Graph<K, VV, EV> joinWithEdgesOnSource(DataSet<Tuple2<K, T>> inputDataSet,_			final EdgeJoinFunction<EV, T> edgeJoinFunction) {__		DataSet<Edge<K, EV>> resultedEdges = this.getEdges()_				.coGroup(inputDataSet).where(0).equalTo(0)_				.with(new ApplyCoGroupToEdgeValuesOnEitherSourceOrTarget<K, EV, T>(edgeJoinFunction))_					.name("Join with edges on source")___		return new Graph<>(this.vertices, resultedEdges, this.context)__	};joins,the,edge,data,set,with,an,input,tuple2,data,set,and,applies,a,user,defined,transformation,on,the,values,of,the,matched,records,the,source,id,of,the,edges,input,and,the,first,field,of,the,input,data,set,are,used,as,join,keys,param,input,data,set,the,data,set,to,join,with,the,first,field,of,the,tuple2,is,used,as,the,join,key,and,the,second,field,is,passed,as,a,parameter,to,the,transformation,function,param,edge,join,function,the,transformation,function,to,apply,the,first,parameter,is,the,current,edge,value,and,the,second,parameter,is,the,value,of,the,matched,tuple2,from,the,input,data,set,param,t,the,type,of,the,second,field,of,the,input,tuple2,data,set,return,a,new,graph,where,the,edge,values,have,been,updated,according,to,the,result,of,the,edge,join,function;public,t,graph,k,vv,ev,join,with,edges,on,source,data,set,tuple2,k,t,input,data,set,final,edge,join,function,ev,t,edge,join,function,data,set,edge,k,ev,resulted,edges,this,get,edges,co,group,input,data,set,where,0,equal,to,0,with,new,apply,co,group,to,edge,values,on,either,source,or,target,k,ev,t,edge,join,function,name,join,with,edges,on,source,return,new,graph,this,vertices,resulted,edges,this,context
Graph -> public <T> Graph<K, VV, EV> joinWithEdgesOnSource(DataSet<Tuple2<K, T>> inputDataSet, 			final EdgeJoinFunction<EV, T> edgeJoinFunction);1481881009;Joins the edge DataSet with an input Tuple2 DataSet and applies a user-defined transformation_on the values of the matched records._The source ID of the edges input and the first field of the input DataSet are used as join keys.__@param inputDataSet the DataSet to join with._The first field of the Tuple2 is used as the join key_and the second field is passed as a parameter to the transformation function._@param edgeJoinFunction the transformation function to apply._The first parameter is the current edge value and the second parameter is the value_of the matched Tuple2 from the input DataSet._@param <T> the type of the second field of the input Tuple2 DataSet._@return a new Graph, where the edge values have been updated according to the_result of the edgeJoinFunction.;public <T> Graph<K, VV, EV> joinWithEdgesOnSource(DataSet<Tuple2<K, T>> inputDataSet,_			final EdgeJoinFunction<EV, T> edgeJoinFunction) {__		DataSet<Edge<K, EV>> resultedEdges = this.getEdges()_				.coGroup(inputDataSet).where(0).equalTo(0)_				.with(new ApplyCoGroupToEdgeValuesOnEitherSourceOrTarget<K, EV, T>(edgeJoinFunction))_					.name("Join with edges on source")___		return new Graph<>(this.vertices, resultedEdges, this.context)__	};joins,the,edge,data,set,with,an,input,tuple2,data,set,and,applies,a,user,defined,transformation,on,the,values,of,the,matched,records,the,source,id,of,the,edges,input,and,the,first,field,of,the,input,data,set,are,used,as,join,keys,param,input,data,set,the,data,set,to,join,with,the,first,field,of,the,tuple2,is,used,as,the,join,key,and,the,second,field,is,passed,as,a,parameter,to,the,transformation,function,param,edge,join,function,the,transformation,function,to,apply,the,first,parameter,is,the,current,edge,value,and,the,second,parameter,is,the,value,of,the,matched,tuple2,from,the,input,data,set,param,t,the,type,of,the,second,field,of,the,input,tuple2,data,set,return,a,new,graph,where,the,edge,values,have,been,updated,according,to,the,result,of,the,edge,join,function;public,t,graph,k,vv,ev,join,with,edges,on,source,data,set,tuple2,k,t,input,data,set,final,edge,join,function,ev,t,edge,join,function,data,set,edge,k,ev,resulted,edges,this,get,edges,co,group,input,data,set,where,0,equal,to,0,with,new,apply,co,group,to,edge,values,on,either,source,or,target,k,ev,t,edge,join,function,name,join,with,edges,on,source,return,new,graph,this,vertices,resulted,edges,this,context
Graph -> public <T> Graph<K, VV, EV> joinWithEdgesOnSource(DataSet<Tuple2<K, T>> inputDataSet, 			final EdgeJoinFunction<EV, T> edgeJoinFunction);1484160227;Joins the edge DataSet with an input Tuple2 DataSet and applies a user-defined transformation_on the values of the matched records._The source ID of the edges input and the first field of the input DataSet are used as join keys.__@param inputDataSet the DataSet to join with._The first field of the Tuple2 is used as the join key_and the second field is passed as a parameter to the transformation function._@param edgeJoinFunction the transformation function to apply._The first parameter is the current edge value and the second parameter is the value_of the matched Tuple2 from the input DataSet._@param <T> the type of the second field of the input Tuple2 DataSet._@return a new Graph, where the edge values have been updated according to the_result of the edgeJoinFunction.;public <T> Graph<K, VV, EV> joinWithEdgesOnSource(DataSet<Tuple2<K, T>> inputDataSet,_			final EdgeJoinFunction<EV, T> edgeJoinFunction) {__		DataSet<Edge<K, EV>> resultedEdges = this.getEdges()_				.coGroup(inputDataSet).where(0).equalTo(0)_				.with(new ApplyCoGroupToEdgeValuesOnEitherSourceOrTarget<K, EV, T>(edgeJoinFunction))_					.name("Join with edges on source")___		return new Graph<>(this.vertices, resultedEdges, this.context)__	};joins,the,edge,data,set,with,an,input,tuple2,data,set,and,applies,a,user,defined,transformation,on,the,values,of,the,matched,records,the,source,id,of,the,edges,input,and,the,first,field,of,the,input,data,set,are,used,as,join,keys,param,input,data,set,the,data,set,to,join,with,the,first,field,of,the,tuple2,is,used,as,the,join,key,and,the,second,field,is,passed,as,a,parameter,to,the,transformation,function,param,edge,join,function,the,transformation,function,to,apply,the,first,parameter,is,the,current,edge,value,and,the,second,parameter,is,the,value,of,the,matched,tuple2,from,the,input,data,set,param,t,the,type,of,the,second,field,of,the,input,tuple2,data,set,return,a,new,graph,where,the,edge,values,have,been,updated,according,to,the,result,of,the,edge,join,function;public,t,graph,k,vv,ev,join,with,edges,on,source,data,set,tuple2,k,t,input,data,set,final,edge,join,function,ev,t,edge,join,function,data,set,edge,k,ev,resulted,edges,this,get,edges,co,group,input,data,set,where,0,equal,to,0,with,new,apply,co,group,to,edge,values,on,either,source,or,target,k,ev,t,edge,join,function,name,join,with,edges,on,source,return,new,graph,this,vertices,resulted,edges,this,context
Graph -> public <T> Graph<K, VV, EV> joinWithEdgesOnSource(DataSet<Tuple2<K, T>> inputDataSet, 			final EdgeJoinFunction<EV, T> edgeJoinFunction);1484685504;Joins the edge DataSet with an input Tuple2 DataSet and applies a user-defined transformation_on the values of the matched records._The source ID of the edges input and the first field of the input DataSet are used as join keys.__@param inputDataSet the DataSet to join with._The first field of the Tuple2 is used as the join key_and the second field is passed as a parameter to the transformation function._@param edgeJoinFunction the transformation function to apply._The first parameter is the current edge value and the second parameter is the value_of the matched Tuple2 from the input DataSet._@param <T> the type of the second field of the input Tuple2 DataSet._@return a new Graph, where the edge values have been updated according to the_result of the edgeJoinFunction.;public <T> Graph<K, VV, EV> joinWithEdgesOnSource(DataSet<Tuple2<K, T>> inputDataSet,_			final EdgeJoinFunction<EV, T> edgeJoinFunction) {__		DataSet<Edge<K, EV>> resultedEdges = this.getEdges()_				.coGroup(inputDataSet).where(0).equalTo(0)_				.with(new ApplyCoGroupToEdgeValuesOnEitherSourceOrTarget<K, EV, T>(edgeJoinFunction))_					.name("Join with edges on source")___		return new Graph<>(this.vertices, resultedEdges, this.context)__	};joins,the,edge,data,set,with,an,input,tuple2,data,set,and,applies,a,user,defined,transformation,on,the,values,of,the,matched,records,the,source,id,of,the,edges,input,and,the,first,field,of,the,input,data,set,are,used,as,join,keys,param,input,data,set,the,data,set,to,join,with,the,first,field,of,the,tuple2,is,used,as,the,join,key,and,the,second,field,is,passed,as,a,parameter,to,the,transformation,function,param,edge,join,function,the,transformation,function,to,apply,the,first,parameter,is,the,current,edge,value,and,the,second,parameter,is,the,value,of,the,matched,tuple2,from,the,input,data,set,param,t,the,type,of,the,second,field,of,the,input,tuple2,data,set,return,a,new,graph,where,the,edge,values,have,been,updated,according,to,the,result,of,the,edge,join,function;public,t,graph,k,vv,ev,join,with,edges,on,source,data,set,tuple2,k,t,input,data,set,final,edge,join,function,ev,t,edge,join,function,data,set,edge,k,ev,resulted,edges,this,get,edges,co,group,input,data,set,where,0,equal,to,0,with,new,apply,co,group,to,edge,values,on,either,source,or,target,k,ev,t,edge,join,function,name,join,with,edges,on,source,return,new,graph,this,vertices,resulted,edges,this,context
Graph -> public <T> Graph<K, VV, EV> joinWithEdgesOnSource(DataSet<Tuple2<K, T>> inputDataSet, 			final EdgeJoinFunction<EV, T> edgeJoinFunction);1489068942;Joins the edge DataSet with an input Tuple2 DataSet and applies a user-defined transformation_on the values of the matched records._The source ID of the edges input and the first field of the input DataSet are used as join keys.__@param inputDataSet the DataSet to join with._The first field of the Tuple2 is used as the join key_and the second field is passed as a parameter to the transformation function._@param edgeJoinFunction the transformation function to apply._The first parameter is the current edge value and the second parameter is the value_of the matched Tuple2 from the input DataSet._@param <T> the type of the second field of the input Tuple2 DataSet._@return a new Graph, where the edge values have been updated according to the_result of the edgeJoinFunction.;public <T> Graph<K, VV, EV> joinWithEdgesOnSource(DataSet<Tuple2<K, T>> inputDataSet,_			final EdgeJoinFunction<EV, T> edgeJoinFunction) {__		DataSet<Edge<K, EV>> resultedEdges = this.getEdges()_				.coGroup(inputDataSet).where(0).equalTo(0)_				.with(new ApplyCoGroupToEdgeValuesOnEitherSourceOrTarget<K, EV, T>(edgeJoinFunction))_					.name("Join with edges on source")___		return new Graph<>(this.vertices, resultedEdges, this.context)__	};joins,the,edge,data,set,with,an,input,tuple2,data,set,and,applies,a,user,defined,transformation,on,the,values,of,the,matched,records,the,source,id,of,the,edges,input,and,the,first,field,of,the,input,data,set,are,used,as,join,keys,param,input,data,set,the,data,set,to,join,with,the,first,field,of,the,tuple2,is,used,as,the,join,key,and,the,second,field,is,passed,as,a,parameter,to,the,transformation,function,param,edge,join,function,the,transformation,function,to,apply,the,first,parameter,is,the,current,edge,value,and,the,second,parameter,is,the,value,of,the,matched,tuple2,from,the,input,data,set,param,t,the,type,of,the,second,field,of,the,input,tuple2,data,set,return,a,new,graph,where,the,edge,values,have,been,updated,according,to,the,result,of,the,edge,join,function;public,t,graph,k,vv,ev,join,with,edges,on,source,data,set,tuple2,k,t,input,data,set,final,edge,join,function,ev,t,edge,join,function,data,set,edge,k,ev,resulted,edges,this,get,edges,co,group,input,data,set,where,0,equal,to,0,with,new,apply,co,group,to,edge,values,on,either,source,or,target,k,ev,t,edge,join,function,name,join,with,edges,on,source,return,new,graph,this,vertices,resulted,edges,this,context
Graph -> public <T> Graph<K, VV, EV> joinWithEdgesOnSource(DataSet<Tuple2<K, T>> inputDataSet, 			final EdgeJoinFunction<EV, T> edgeJoinFunction);1490973446;Joins the edge DataSet with an input Tuple2 DataSet and applies a user-defined transformation_on the values of the matched records._The source ID of the edges input and the first field of the input DataSet are used as join keys.__@param inputDataSet the DataSet to join with._The first field of the Tuple2 is used as the join key_and the second field is passed as a parameter to the transformation function._@param edgeJoinFunction the transformation function to apply._The first parameter is the current edge value and the second parameter is the value_of the matched Tuple2 from the input DataSet._@param <T> the type of the second field of the input Tuple2 DataSet._@return a new Graph, where the edge values have been updated according to the_result of the edgeJoinFunction.;public <T> Graph<K, VV, EV> joinWithEdgesOnSource(DataSet<Tuple2<K, T>> inputDataSet,_			final EdgeJoinFunction<EV, T> edgeJoinFunction) {__		DataSet<Edge<K, EV>> resultedEdges = this.getEdges()_				.coGroup(inputDataSet).where(0).equalTo(0)_				.with(new ApplyCoGroupToEdgeValuesOnEitherSourceOrTarget<K, EV, T>(edgeJoinFunction))_					.name("Join with edges on source")___		return new Graph<>(this.vertices, resultedEdges, this.context)__	};joins,the,edge,data,set,with,an,input,tuple2,data,set,and,applies,a,user,defined,transformation,on,the,values,of,the,matched,records,the,source,id,of,the,edges,input,and,the,first,field,of,the,input,data,set,are,used,as,join,keys,param,input,data,set,the,data,set,to,join,with,the,first,field,of,the,tuple2,is,used,as,the,join,key,and,the,second,field,is,passed,as,a,parameter,to,the,transformation,function,param,edge,join,function,the,transformation,function,to,apply,the,first,parameter,is,the,current,edge,value,and,the,second,parameter,is,the,value,of,the,matched,tuple2,from,the,input,data,set,param,t,the,type,of,the,second,field,of,the,input,tuple2,data,set,return,a,new,graph,where,the,edge,values,have,been,updated,according,to,the,result,of,the,edge,join,function;public,t,graph,k,vv,ev,join,with,edges,on,source,data,set,tuple2,k,t,input,data,set,final,edge,join,function,ev,t,edge,join,function,data,set,edge,k,ev,resulted,edges,this,get,edges,co,group,input,data,set,where,0,equal,to,0,with,new,apply,co,group,to,edge,values,on,either,source,or,target,k,ev,t,edge,join,function,name,join,with,edges,on,source,return,new,graph,this,vertices,resulted,edges,this,context
Graph -> public <T> Graph<K, VV, EV> joinWithEdgesOnSource(DataSet<Tuple2<K, T>> inputDataSet, 			final EdgeJoinFunction<EV, T> edgeJoinFunction);1495819075;Joins the edge DataSet with an input Tuple2 DataSet and applies a user-defined transformation_on the values of the matched records._The source ID of the edges input and the first field of the input DataSet are used as join keys.__@param inputDataSet the DataSet to join with._The first field of the Tuple2 is used as the join key_and the second field is passed as a parameter to the transformation function._@param edgeJoinFunction the transformation function to apply._The first parameter is the current edge value and the second parameter is the value_of the matched Tuple2 from the input DataSet._@param <T> the type of the second field of the input Tuple2 DataSet._@return a new Graph, where the edge values have been updated according to the_result of the edgeJoinFunction.;public <T> Graph<K, VV, EV> joinWithEdgesOnSource(DataSet<Tuple2<K, T>> inputDataSet,_			final EdgeJoinFunction<EV, T> edgeJoinFunction) {__		DataSet<Edge<K, EV>> resultedEdges = this.getEdges()_				.coGroup(inputDataSet).where(0).equalTo(0)_				.with(new ApplyCoGroupToEdgeValuesOnEitherSourceOrTarget<K, EV, T>(edgeJoinFunction))_					.name("Join with edges on source")___		return new Graph<>(this.vertices, resultedEdges, this.context)__	};joins,the,edge,data,set,with,an,input,tuple2,data,set,and,applies,a,user,defined,transformation,on,the,values,of,the,matched,records,the,source,id,of,the,edges,input,and,the,first,field,of,the,input,data,set,are,used,as,join,keys,param,input,data,set,the,data,set,to,join,with,the,first,field,of,the,tuple2,is,used,as,the,join,key,and,the,second,field,is,passed,as,a,parameter,to,the,transformation,function,param,edge,join,function,the,transformation,function,to,apply,the,first,parameter,is,the,current,edge,value,and,the,second,parameter,is,the,value,of,the,matched,tuple2,from,the,input,data,set,param,t,the,type,of,the,second,field,of,the,input,tuple2,data,set,return,a,new,graph,where,the,edge,values,have,been,updated,according,to,the,result,of,the,edge,join,function;public,t,graph,k,vv,ev,join,with,edges,on,source,data,set,tuple2,k,t,input,data,set,final,edge,join,function,ev,t,edge,join,function,data,set,edge,k,ev,resulted,edges,this,get,edges,co,group,input,data,set,where,0,equal,to,0,with,new,apply,co,group,to,edge,values,on,either,source,or,target,k,ev,t,edge,join,function,name,join,with,edges,on,source,return,new,graph,this,vertices,resulted,edges,this,context
Graph -> public <T> Graph<K, VV, EV> joinWithEdgesOnSource(DataSet<Tuple2<K, T>> inputDataSet, 			final EdgeJoinFunction<EV, T> edgeJoinFunction);1502111816;Joins the edge DataSet with an input Tuple2 DataSet and applies a user-defined transformation_on the values of the matched records._The source ID of the edges input and the first field of the input DataSet are used as join keys.__@param inputDataSet the DataSet to join with._The first field of the Tuple2 is used as the join key_and the second field is passed as a parameter to the transformation function._@param edgeJoinFunction the transformation function to apply._The first parameter is the current edge value and the second parameter is the value_of the matched Tuple2 from the input DataSet._@param <T> the type of the second field of the input Tuple2 DataSet._@return a new Graph, where the edge values have been updated according to the_result of the edgeJoinFunction.;public <T> Graph<K, VV, EV> joinWithEdgesOnSource(DataSet<Tuple2<K, T>> inputDataSet,_			final EdgeJoinFunction<EV, T> edgeJoinFunction) {__		DataSet<Edge<K, EV>> resultedEdges = this.getEdges()_				.coGroup(inputDataSet).where(0).equalTo(0)_				.with(new ApplyCoGroupToEdgeValuesOnEitherSourceOrTarget<>(edgeJoinFunction))_					.name("Join with edges on source")___		return new Graph<>(this.vertices, resultedEdges, this.context)__	};joins,the,edge,data,set,with,an,input,tuple2,data,set,and,applies,a,user,defined,transformation,on,the,values,of,the,matched,records,the,source,id,of,the,edges,input,and,the,first,field,of,the,input,data,set,are,used,as,join,keys,param,input,data,set,the,data,set,to,join,with,the,first,field,of,the,tuple2,is,used,as,the,join,key,and,the,second,field,is,passed,as,a,parameter,to,the,transformation,function,param,edge,join,function,the,transformation,function,to,apply,the,first,parameter,is,the,current,edge,value,and,the,second,parameter,is,the,value,of,the,matched,tuple2,from,the,input,data,set,param,t,the,type,of,the,second,field,of,the,input,tuple2,data,set,return,a,new,graph,where,the,edge,values,have,been,updated,according,to,the,result,of,the,edge,join,function;public,t,graph,k,vv,ev,join,with,edges,on,source,data,set,tuple2,k,t,input,data,set,final,edge,join,function,ev,t,edge,join,function,data,set,edge,k,ev,resulted,edges,this,get,edges,co,group,input,data,set,where,0,equal,to,0,with,new,apply,co,group,to,edge,values,on,either,source,or,target,edge,join,function,name,join,with,edges,on,source,return,new,graph,this,vertices,resulted,edges,this,context
Graph -> public DataSet<Tuple2<K, VV>> getVerticesAsTuple2();1444404795;@return the vertex DataSet as Tuple2.;public DataSet<Tuple2<K, VV>> getVerticesAsTuple2() {_		return vertices.map(new VertexToTuple2Map<K, VV>())__	};return,the,vertex,data,set,as,tuple2;public,data,set,tuple2,k,vv,get,vertices,as,tuple2,return,vertices,map,new,vertex,to,tuple2map,k,vv
Graph -> public DataSet<Tuple2<K, VV>> getVerticesAsTuple2();1445261977;@return the vertex DataSet as Tuple2.;public DataSet<Tuple2<K, VV>> getVerticesAsTuple2() {_		return vertices.map(new VertexToTuple2Map<K, VV>())__	};return,the,vertex,data,set,as,tuple2;public,data,set,tuple2,k,vv,get,vertices,as,tuple2,return,vertices,map,new,vertex,to,tuple2map,k,vv
Graph -> public DataSet<Tuple2<K, VV>> getVerticesAsTuple2();1445854323;@return the vertex DataSet as Tuple2.;public DataSet<Tuple2<K, VV>> getVerticesAsTuple2() {_		return vertices.map(new VertexToTuple2Map<K, VV>())__	};return,the,vertex,data,set,as,tuple2;public,data,set,tuple2,k,vv,get,vertices,as,tuple2,return,vertices,map,new,vertex,to,tuple2map,k,vv
Graph -> public DataSet<Tuple2<K, VV>> getVerticesAsTuple2();1446112342;@return the vertex DataSet as Tuple2.;public DataSet<Tuple2<K, VV>> getVerticesAsTuple2() {_		return vertices.map(new VertexToTuple2Map<K, VV>())__	};return,the,vertex,data,set,as,tuple2;public,data,set,tuple2,k,vv,get,vertices,as,tuple2,return,vertices,map,new,vertex,to,tuple2map,k,vv
Graph -> public DataSet<Tuple2<K, VV>> getVerticesAsTuple2();1447073368;@return the vertex DataSet as Tuple2.;public DataSet<Tuple2<K, VV>> getVerticesAsTuple2() {_		return vertices.map(new VertexToTuple2Map<K, VV>())__	};return,the,vertex,data,set,as,tuple2;public,data,set,tuple2,k,vv,get,vertices,as,tuple2,return,vertices,map,new,vertex,to,tuple2map,k,vv
Graph -> public DataSet<Tuple2<K, VV>> getVerticesAsTuple2();1454404649;@return the vertex DataSet as Tuple2.;public DataSet<Tuple2<K, VV>> getVerticesAsTuple2() {_		return vertices.map(new VertexToTuple2Map<K, VV>())__	};return,the,vertex,data,set,as,tuple2;public,data,set,tuple2,k,vv,get,vertices,as,tuple2,return,vertices,map,new,vertex,to,tuple2map,k,vv
Graph -> public DataSet<Tuple2<K, VV>> getVerticesAsTuple2();1458583829;@return the vertex DataSet as Tuple2.;public DataSet<Tuple2<K, VV>> getVerticesAsTuple2() {_		return vertices.map(new VertexToTuple2Map<K, VV>())__	};return,the,vertex,data,set,as,tuple2;public,data,set,tuple2,k,vv,get,vertices,as,tuple2,return,vertices,map,new,vertex,to,tuple2map,k,vv
Graph -> public DataSet<Tuple2<K, VV>> getVerticesAsTuple2();1458583829;@return the vertex DataSet as Tuple2.;public DataSet<Tuple2<K, VV>> getVerticesAsTuple2() {_		return vertices.map(new VertexToTuple2Map<K, VV>())__	};return,the,vertex,data,set,as,tuple2;public,data,set,tuple2,k,vv,get,vertices,as,tuple2,return,vertices,map,new,vertex,to,tuple2map,k,vv
Graph -> public DataSet<Tuple2<K, VV>> getVerticesAsTuple2();1462100316;@return the vertex DataSet as Tuple2.;public DataSet<Tuple2<K, VV>> getVerticesAsTuple2() {_		return vertices.map(new VertexToTuple2Map<K, VV>())__	};return,the,vertex,data,set,as,tuple2;public,data,set,tuple2,k,vv,get,vertices,as,tuple2,return,vertices,map,new,vertex,to,tuple2map,k,vv
Graph -> public DataSet<Tuple2<K, VV>> getVerticesAsTuple2();1462100316;@return the vertex DataSet as Tuple2.;public DataSet<Tuple2<K, VV>> getVerticesAsTuple2() {_		return vertices.map(new VertexToTuple2Map<K, VV>())__	};return,the,vertex,data,set,as,tuple2;public,data,set,tuple2,k,vv,get,vertices,as,tuple2,return,vertices,map,new,vertex,to,tuple2map,k,vv
Graph -> public DataSet<Tuple2<K, VV>> getVerticesAsTuple2();1462205213;@return the vertex DataSet as Tuple2.;public DataSet<Tuple2<K, VV>> getVerticesAsTuple2() {_		return vertices.map(new VertexToTuple2Map<K, VV>())__	};return,the,vertex,data,set,as,tuple2;public,data,set,tuple2,k,vv,get,vertices,as,tuple2,return,vertices,map,new,vertex,to,tuple2map,k,vv
Graph -> public DataSet<Tuple2<K, VV>> getVerticesAsTuple2();1462208859;@return the vertex DataSet as Tuple2.;public DataSet<Tuple2<K, VV>> getVerticesAsTuple2() {_		return vertices.map(new VertexToTuple2Map<K, VV>())__	};return,the,vertex,data,set,as,tuple2;public,data,set,tuple2,k,vv,get,vertices,as,tuple2,return,vertices,map,new,vertex,to,tuple2map,k,vv
Graph -> public DataSet<Tuple2<K, VV>> getVerticesAsTuple2();1462809297;@return the vertex DataSet as Tuple2.;public DataSet<Tuple2<K, VV>> getVerticesAsTuple2() {_		return vertices.map(new VertexToTuple2Map<K, VV>())__	};return,the,vertex,data,set,as,tuple2;public,data,set,tuple2,k,vv,get,vertices,as,tuple2,return,vertices,map,new,vertex,to,tuple2map,k,vv
Graph -> public DataSet<Tuple2<K, VV>> getVerticesAsTuple2();1465316775;@return the vertex DataSet as Tuple2.;public DataSet<Tuple2<K, VV>> getVerticesAsTuple2() {_		return vertices.map(new VertexToTuple2Map<K, VV>())__	};return,the,vertex,data,set,as,tuple2;public,data,set,tuple2,k,vv,get,vertices,as,tuple2,return,vertices,map,new,vertex,to,tuple2map,k,vv
Graph -> public DataSet<Tuple2<K, VV>> getVerticesAsTuple2();1466789678;@return the vertex DataSet as Tuple2.;public DataSet<Tuple2<K, VV>> getVerticesAsTuple2() {_		return vertices.map(new VertexToTuple2Map<K, VV>())__	};return,the,vertex,data,set,as,tuple2;public,data,set,tuple2,k,vv,get,vertices,as,tuple2,return,vertices,map,new,vertex,to,tuple2map,k,vv
Graph -> public DataSet<Tuple2<K, VV>> getVerticesAsTuple2();1467140656;@return the vertex DataSet as Tuple2.;public DataSet<Tuple2<K, VV>> getVerticesAsTuple2() {_		return vertices.map(new VertexToTuple2Map<K, VV>())__	};return,the,vertex,data,set,as,tuple2;public,data,set,tuple2,k,vv,get,vertices,as,tuple2,return,vertices,map,new,vertex,to,tuple2map,k,vv
Graph -> public DataSet<Tuple2<K, VV>> getVerticesAsTuple2();1467306272;@return the vertex DataSet as Tuple2.;public DataSet<Tuple2<K, VV>> getVerticesAsTuple2() {_		return vertices.map(new VertexToTuple2Map<K, VV>())__	};return,the,vertex,data,set,as,tuple2;public,data,set,tuple2,k,vv,get,vertices,as,tuple2,return,vertices,map,new,vertex,to,tuple2map,k,vv
Graph -> public DataSet<Tuple2<K, VV>> getVerticesAsTuple2();1470042815;@return the vertex DataSet as Tuple2.;public DataSet<Tuple2<K, VV>> getVerticesAsTuple2() {_		return vertices.map(new VertexToTuple2Map<K, VV>())__	};return,the,vertex,data,set,as,tuple2;public,data,set,tuple2,k,vv,get,vertices,as,tuple2,return,vertices,map,new,vertex,to,tuple2map,k,vv
Graph -> public DataSet<Tuple2<K, VV>> getVerticesAsTuple2();1475684776;@return the vertex DataSet as Tuple2.;public DataSet<Tuple2<K, VV>> getVerticesAsTuple2() {_		return vertices.map(new VertexToTuple2Map<K, VV>())__	};return,the,vertex,data,set,as,tuple2;public,data,set,tuple2,k,vv,get,vertices,as,tuple2,return,vertices,map,new,vertex,to,tuple2map,k,vv
Graph -> public DataSet<Tuple2<K, VV>> getVerticesAsTuple2();1475685606;@return the vertex DataSet as Tuple2.;public DataSet<Tuple2<K, VV>> getVerticesAsTuple2() {_		return vertices.map(new VertexToTuple2Map<K, VV>())__	};return,the,vertex,data,set,as,tuple2;public,data,set,tuple2,k,vv,get,vertices,as,tuple2,return,vertices,map,new,vertex,to,tuple2map,k,vv
Graph -> public DataSet<Tuple2<K, VV>> getVerticesAsTuple2();1481745825;@return the vertex DataSet as Tuple2.;public DataSet<Tuple2<K, VV>> getVerticesAsTuple2() {_		return vertices.map(new VertexToTuple2Map<K, VV>())__	};return,the,vertex,data,set,as,tuple2;public,data,set,tuple2,k,vv,get,vertices,as,tuple2,return,vertices,map,new,vertex,to,tuple2map,k,vv
Graph -> public DataSet<Tuple2<K, VV>> getVerticesAsTuple2();1481881009;@return the vertex DataSet as Tuple2.;public DataSet<Tuple2<K, VV>> getVerticesAsTuple2() {_		return vertices.map(new VertexToTuple2Map<K, VV>())__	};return,the,vertex,data,set,as,tuple2;public,data,set,tuple2,k,vv,get,vertices,as,tuple2,return,vertices,map,new,vertex,to,tuple2map,k,vv
Graph -> public DataSet<Tuple2<K, VV>> getVerticesAsTuple2();1484160227;@return the vertex DataSet as Tuple2.;public DataSet<Tuple2<K, VV>> getVerticesAsTuple2() {_		return vertices.map(new VertexToTuple2Map<K, VV>())__	};return,the,vertex,data,set,as,tuple2;public,data,set,tuple2,k,vv,get,vertices,as,tuple2,return,vertices,map,new,vertex,to,tuple2map,k,vv
Graph -> public DataSet<Tuple2<K, VV>> getVerticesAsTuple2();1484685504;@return the vertex DataSet as Tuple2.;public DataSet<Tuple2<K, VV>> getVerticesAsTuple2() {_		return vertices.map(new VertexToTuple2Map<K, VV>())__	};return,the,vertex,data,set,as,tuple2;public,data,set,tuple2,k,vv,get,vertices,as,tuple2,return,vertices,map,new,vertex,to,tuple2map,k,vv
Graph -> public DataSet<Tuple2<K, VV>> getVerticesAsTuple2();1489068942;@return the vertex DataSet as Tuple2.;public DataSet<Tuple2<K, VV>> getVerticesAsTuple2() {_		return vertices.map(new VertexToTuple2Map<K, VV>())__	};return,the,vertex,data,set,as,tuple2;public,data,set,tuple2,k,vv,get,vertices,as,tuple2,return,vertices,map,new,vertex,to,tuple2map,k,vv
Graph -> public DataSet<Tuple2<K, VV>> getVerticesAsTuple2();1490973446;@return the vertex DataSet as Tuple2.;public DataSet<Tuple2<K, VV>> getVerticesAsTuple2() {_		return vertices.map(new VertexToTuple2Map<K, VV>())__	};return,the,vertex,data,set,as,tuple2;public,data,set,tuple2,k,vv,get,vertices,as,tuple2,return,vertices,map,new,vertex,to,tuple2map,k,vv
Graph -> public DataSet<Tuple2<K, VV>> getVerticesAsTuple2();1495819075;@return the vertex DataSet as Tuple2.;public DataSet<Tuple2<K, VV>> getVerticesAsTuple2() {_		return vertices.map(new VertexToTuple2Map<K, VV>())__	};return,the,vertex,data,set,as,tuple2;public,data,set,tuple2,k,vv,get,vertices,as,tuple2,return,vertices,map,new,vertex,to,tuple2map,k,vv
Graph -> public DataSet<Tuple2<K, VV>> getVerticesAsTuple2();1502111816;@return the vertex DataSet as Tuple2.;public DataSet<Tuple2<K, VV>> getVerticesAsTuple2() {_		return vertices.map(new VertexToTuple2Map<>())__	};return,the,vertex,data,set,as,tuple2;public,data,set,tuple2,k,vv,get,vertices,as,tuple2,return,vertices,map,new,vertex,to,tuple2map
Graph -> public Graph<K, VV, EV> removeEdge(Edge<K, EV> edge);1444404795;Removes all edges that match the given edge from the graph.__@param edge the edge to remove_@return the new graph containing the existing vertices and edges without_the removed edges;public Graph<K, VV, EV> removeEdge(Edge<K, EV> edge) {_		DataSet<Edge<K, EV>> newEdges = getEdges().filter(new EdgeRemovalEdgeFilter<K, EV>(edge))__		return new Graph<K, VV, EV>(this.vertices, newEdges, this.context)__	};removes,all,edges,that,match,the,given,edge,from,the,graph,param,edge,the,edge,to,remove,return,the,new,graph,containing,the,existing,vertices,and,edges,without,the,removed,edges;public,graph,k,vv,ev,remove,edge,edge,k,ev,edge,data,set,edge,k,ev,new,edges,get,edges,filter,new,edge,removal,edge,filter,k,ev,edge,return,new,graph,k,vv,ev,this,vertices,new,edges,this,context
Graph -> public Graph<K, VV, EV> removeEdge(Edge<K, EV> edge);1445261977;Removes all edges that match the given edge from the graph.__@param edge the edge to remove_@return the new graph containing the existing vertices and edges without_the removed edges;public Graph<K, VV, EV> removeEdge(Edge<K, EV> edge) {_		DataSet<Edge<K, EV>> newEdges = getEdges().filter(new EdgeRemovalEdgeFilter<K, EV>(edge))__		return new Graph<K, VV, EV>(this.vertices, newEdges, this.context)__	};removes,all,edges,that,match,the,given,edge,from,the,graph,param,edge,the,edge,to,remove,return,the,new,graph,containing,the,existing,vertices,and,edges,without,the,removed,edges;public,graph,k,vv,ev,remove,edge,edge,k,ev,edge,data,set,edge,k,ev,new,edges,get,edges,filter,new,edge,removal,edge,filter,k,ev,edge,return,new,graph,k,vv,ev,this,vertices,new,edges,this,context
Graph -> public Graph<K, VV, EV> removeEdge(Edge<K, EV> edge);1445854323;Removes all edges that match the given edge from the graph.__@param edge the edge to remove_@return the new graph containing the existing vertices and edges without_the removed edges;public Graph<K, VV, EV> removeEdge(Edge<K, EV> edge) {_		DataSet<Edge<K, EV>> newEdges = getEdges().filter(new EdgeRemovalEdgeFilter<K, EV>(edge))__		return new Graph<K, VV, EV>(this.vertices, newEdges, this.context)__	};removes,all,edges,that,match,the,given,edge,from,the,graph,param,edge,the,edge,to,remove,return,the,new,graph,containing,the,existing,vertices,and,edges,without,the,removed,edges;public,graph,k,vv,ev,remove,edge,edge,k,ev,edge,data,set,edge,k,ev,new,edges,get,edges,filter,new,edge,removal,edge,filter,k,ev,edge,return,new,graph,k,vv,ev,this,vertices,new,edges,this,context
Graph -> public Graph<K, VV, EV> removeEdge(Edge<K, EV> edge);1446112342;Removes all edges that match the given edge from the graph.__@param edge the edge to remove_@return the new graph containing the existing vertices and edges without_the removed edges;public Graph<K, VV, EV> removeEdge(Edge<K, EV> edge) {_		DataSet<Edge<K, EV>> newEdges = getEdges().filter(new EdgeRemovalEdgeFilter<K, EV>(edge))__		return new Graph<K, VV, EV>(this.vertices, newEdges, this.context)__	};removes,all,edges,that,match,the,given,edge,from,the,graph,param,edge,the,edge,to,remove,return,the,new,graph,containing,the,existing,vertices,and,edges,without,the,removed,edges;public,graph,k,vv,ev,remove,edge,edge,k,ev,edge,data,set,edge,k,ev,new,edges,get,edges,filter,new,edge,removal,edge,filter,k,ev,edge,return,new,graph,k,vv,ev,this,vertices,new,edges,this,context
Graph -> public Graph<K, VV, EV> removeEdge(Edge<K, EV> edge);1447073368;Removes all edges that match the given edge from the graph.__@param edge the edge to remove_@return the new graph containing the existing vertices and edges without_the removed edges;public Graph<K, VV, EV> removeEdge(Edge<K, EV> edge) {_		DataSet<Edge<K, EV>> newEdges = getEdges().filter(new EdgeRemovalEdgeFilter<K, EV>(edge))__		return new Graph<K, VV, EV>(this.vertices, newEdges, this.context)__	};removes,all,edges,that,match,the,given,edge,from,the,graph,param,edge,the,edge,to,remove,return,the,new,graph,containing,the,existing,vertices,and,edges,without,the,removed,edges;public,graph,k,vv,ev,remove,edge,edge,k,ev,edge,data,set,edge,k,ev,new,edges,get,edges,filter,new,edge,removal,edge,filter,k,ev,edge,return,new,graph,k,vv,ev,this,vertices,new,edges,this,context
Graph -> public Graph<K, VV, EV> removeEdge(Edge<K, EV> edge);1454404649;Removes all edges that match the given edge from the graph.__@param edge the edge to remove_@return the new graph containing the existing vertices and edges without_the removed edges;public Graph<K, VV, EV> removeEdge(Edge<K, EV> edge) {_		DataSet<Edge<K, EV>> newEdges = getEdges().filter(new EdgeRemovalEdgeFilter<K, EV>(edge))__		return new Graph<K, VV, EV>(this.vertices, newEdges, this.context)__	};removes,all,edges,that,match,the,given,edge,from,the,graph,param,edge,the,edge,to,remove,return,the,new,graph,containing,the,existing,vertices,and,edges,without,the,removed,edges;public,graph,k,vv,ev,remove,edge,edge,k,ev,edge,data,set,edge,k,ev,new,edges,get,edges,filter,new,edge,removal,edge,filter,k,ev,edge,return,new,graph,k,vv,ev,this,vertices,new,edges,this,context
Graph -> public Graph<K, VV, EV> removeEdge(Edge<K, EV> edge);1458583829;Removes all edges that match the given edge from the graph.__@param edge the edge to remove_@return the new graph containing the existing vertices and edges without_the removed edges;public Graph<K, VV, EV> removeEdge(Edge<K, EV> edge) {_		DataSet<Edge<K, EV>> newEdges = getEdges().filter(new EdgeRemovalEdgeFilter<K, EV>(edge))__		return new Graph<K, VV, EV>(this.vertices, newEdges, this.context)__	};removes,all,edges,that,match,the,given,edge,from,the,graph,param,edge,the,edge,to,remove,return,the,new,graph,containing,the,existing,vertices,and,edges,without,the,removed,edges;public,graph,k,vv,ev,remove,edge,edge,k,ev,edge,data,set,edge,k,ev,new,edges,get,edges,filter,new,edge,removal,edge,filter,k,ev,edge,return,new,graph,k,vv,ev,this,vertices,new,edges,this,context
Graph -> public Graph<K, VV, EV> removeEdge(Edge<K, EV> edge);1458583829;Removes all edges that match the given edge from the graph.__@param edge the edge to remove_@return the new graph containing the existing vertices and edges without_the removed edges;public Graph<K, VV, EV> removeEdge(Edge<K, EV> edge) {_		DataSet<Edge<K, EV>> newEdges = getEdges().filter(new EdgeRemovalEdgeFilter<K, EV>(edge))__		return new Graph<K, VV, EV>(this.vertices, newEdges, this.context)__	};removes,all,edges,that,match,the,given,edge,from,the,graph,param,edge,the,edge,to,remove,return,the,new,graph,containing,the,existing,vertices,and,edges,without,the,removed,edges;public,graph,k,vv,ev,remove,edge,edge,k,ev,edge,data,set,edge,k,ev,new,edges,get,edges,filter,new,edge,removal,edge,filter,k,ev,edge,return,new,graph,k,vv,ev,this,vertices,new,edges,this,context
Graph -> public Graph<K, VV, EV> removeEdge(Edge<K, EV> edge);1462100316;Removes all edges that match the given edge from the graph.__@param edge the edge to remove_@return the new graph containing the existing vertices and edges without_the removed edges;public Graph<K, VV, EV> removeEdge(Edge<K, EV> edge) {_		DataSet<Edge<K, EV>> newEdges = getEdges().filter(new EdgeRemovalEdgeFilter<K, EV>(edge))__		return new Graph<K, VV, EV>(this.vertices, newEdges, this.context)__	};removes,all,edges,that,match,the,given,edge,from,the,graph,param,edge,the,edge,to,remove,return,the,new,graph,containing,the,existing,vertices,and,edges,without,the,removed,edges;public,graph,k,vv,ev,remove,edge,edge,k,ev,edge,data,set,edge,k,ev,new,edges,get,edges,filter,new,edge,removal,edge,filter,k,ev,edge,return,new,graph,k,vv,ev,this,vertices,new,edges,this,context
Graph -> public Graph<K, VV, EV> removeEdge(Edge<K, EV> edge);1462100316;Removes all edges that match the given edge from the graph.__@param edge the edge to remove_@return the new graph containing the existing vertices and edges without_the removed edges;public Graph<K, VV, EV> removeEdge(Edge<K, EV> edge) {_		DataSet<Edge<K, EV>> newEdges = getEdges().filter(new EdgeRemovalEdgeFilter<>(edge))__		return new Graph<>(this.vertices, newEdges, this.context)__	};removes,all,edges,that,match,the,given,edge,from,the,graph,param,edge,the,edge,to,remove,return,the,new,graph,containing,the,existing,vertices,and,edges,without,the,removed,edges;public,graph,k,vv,ev,remove,edge,edge,k,ev,edge,data,set,edge,k,ev,new,edges,get,edges,filter,new,edge,removal,edge,filter,edge,return,new,graph,this,vertices,new,edges,this,context
Graph -> public Graph<K, VV, EV> removeEdge(Edge<K, EV> edge);1462205213;Removes all edges that match the given edge from the graph.__@param edge the edge to remove_@return the new graph containing the existing vertices and edges without_the removed edges;public Graph<K, VV, EV> removeEdge(Edge<K, EV> edge) {_		DataSet<Edge<K, EV>> newEdges = getEdges().filter(new EdgeRemovalEdgeFilter<>(edge))__		return new Graph<>(this.vertices, newEdges, this.context)__	};removes,all,edges,that,match,the,given,edge,from,the,graph,param,edge,the,edge,to,remove,return,the,new,graph,containing,the,existing,vertices,and,edges,without,the,removed,edges;public,graph,k,vv,ev,remove,edge,edge,k,ev,edge,data,set,edge,k,ev,new,edges,get,edges,filter,new,edge,removal,edge,filter,edge,return,new,graph,this,vertices,new,edges,this,context
Graph -> public Graph<K, VV, EV> removeEdge(Edge<K, EV> edge);1462208859;Removes all edges that match the given edge from the graph.__@param edge the edge to remove_@return the new graph containing the existing vertices and edges without_the removed edges;public Graph<K, VV, EV> removeEdge(Edge<K, EV> edge) {_		DataSet<Edge<K, EV>> newEdges = getEdges().filter(new EdgeRemovalEdgeFilter<>(edge))__		return new Graph<>(this.vertices, newEdges, this.context)__	};removes,all,edges,that,match,the,given,edge,from,the,graph,param,edge,the,edge,to,remove,return,the,new,graph,containing,the,existing,vertices,and,edges,without,the,removed,edges;public,graph,k,vv,ev,remove,edge,edge,k,ev,edge,data,set,edge,k,ev,new,edges,get,edges,filter,new,edge,removal,edge,filter,edge,return,new,graph,this,vertices,new,edges,this,context
Graph -> public Graph<K, VV, EV> removeEdge(Edge<K, EV> edge);1462809297;Removes all edges that match the given edge from the graph.__@param edge the edge to remove_@return the new graph containing the existing vertices and edges without_the removed edges;public Graph<K, VV, EV> removeEdge(Edge<K, EV> edge) {_		DataSet<Edge<K, EV>> newEdges = getEdges().filter(new EdgeRemovalEdgeFilter<>(edge))__		return new Graph<>(this.vertices, newEdges, this.context)__	};removes,all,edges,that,match,the,given,edge,from,the,graph,param,edge,the,edge,to,remove,return,the,new,graph,containing,the,existing,vertices,and,edges,without,the,removed,edges;public,graph,k,vv,ev,remove,edge,edge,k,ev,edge,data,set,edge,k,ev,new,edges,get,edges,filter,new,edge,removal,edge,filter,edge,return,new,graph,this,vertices,new,edges,this,context
Graph -> public Graph<K, VV, EV> removeEdge(Edge<K, EV> edge);1465316775;Removes all edges that match the given edge from the graph.__@param edge the edge to remove_@return the new graph containing the existing vertices and edges without_the removed edges;public Graph<K, VV, EV> removeEdge(Edge<K, EV> edge) {_		DataSet<Edge<K, EV>> newEdges = getEdges().filter(new EdgeRemovalEdgeFilter<>(edge))__		return new Graph<>(this.vertices, newEdges, this.context)__	};removes,all,edges,that,match,the,given,edge,from,the,graph,param,edge,the,edge,to,remove,return,the,new,graph,containing,the,existing,vertices,and,edges,without,the,removed,edges;public,graph,k,vv,ev,remove,edge,edge,k,ev,edge,data,set,edge,k,ev,new,edges,get,edges,filter,new,edge,removal,edge,filter,edge,return,new,graph,this,vertices,new,edges,this,context
Graph -> public Graph<K, VV, EV> removeEdge(Edge<K, EV> edge);1466789678;Removes all edges that match the given edge from the graph.__@param edge the edge to remove_@return the new graph containing the existing vertices and edges without_the removed edges;public Graph<K, VV, EV> removeEdge(Edge<K, EV> edge) {_		DataSet<Edge<K, EV>> newEdges = getEdges().filter(new EdgeRemovalEdgeFilter<>(edge))__		return new Graph<>(this.vertices, newEdges, this.context)__	};removes,all,edges,that,match,the,given,edge,from,the,graph,param,edge,the,edge,to,remove,return,the,new,graph,containing,the,existing,vertices,and,edges,without,the,removed,edges;public,graph,k,vv,ev,remove,edge,edge,k,ev,edge,data,set,edge,k,ev,new,edges,get,edges,filter,new,edge,removal,edge,filter,edge,return,new,graph,this,vertices,new,edges,this,context
Graph -> public Graph<K, VV, EV> removeEdge(Edge<K, EV> edge);1467140656;Removes all edges that match the given edge from the graph.__@param edge the edge to remove_@return the new graph containing the existing vertices and edges without_the removed edges;public Graph<K, VV, EV> removeEdge(Edge<K, EV> edge) {_		DataSet<Edge<K, EV>> newEdges = getEdges().filter(new EdgeRemovalEdgeFilter<>(edge))__		return new Graph<>(this.vertices, newEdges, this.context)__	};removes,all,edges,that,match,the,given,edge,from,the,graph,param,edge,the,edge,to,remove,return,the,new,graph,containing,the,existing,vertices,and,edges,without,the,removed,edges;public,graph,k,vv,ev,remove,edge,edge,k,ev,edge,data,set,edge,k,ev,new,edges,get,edges,filter,new,edge,removal,edge,filter,edge,return,new,graph,this,vertices,new,edges,this,context
Graph -> public Graph<K, VV, EV> removeEdge(Edge<K, EV> edge);1467306272;Removes all edges that match the given edge from the graph.__@param edge the edge to remove_@return the new graph containing the existing vertices and edges without_the removed edges;public Graph<K, VV, EV> removeEdge(Edge<K, EV> edge) {_		DataSet<Edge<K, EV>> newEdges = getEdges().filter(new EdgeRemovalEdgeFilter<>(edge))__		return new Graph<>(this.vertices, newEdges, this.context)__	};removes,all,edges,that,match,the,given,edge,from,the,graph,param,edge,the,edge,to,remove,return,the,new,graph,containing,the,existing,vertices,and,edges,without,the,removed,edges;public,graph,k,vv,ev,remove,edge,edge,k,ev,edge,data,set,edge,k,ev,new,edges,get,edges,filter,new,edge,removal,edge,filter,edge,return,new,graph,this,vertices,new,edges,this,context
Graph -> public Graph<K, VV, EV> removeEdge(Edge<K, EV> edge);1470042815;Removes all edges that match the given edge from the graph.__@param edge the edge to remove_@return the new graph containing the existing vertices and edges without_the removed edges;public Graph<K, VV, EV> removeEdge(Edge<K, EV> edge) {_		DataSet<Edge<K, EV>> newEdges = getEdges().filter(new EdgeRemovalEdgeFilter<>(edge))__		return new Graph<>(this.vertices, newEdges, this.context)__	};removes,all,edges,that,match,the,given,edge,from,the,graph,param,edge,the,edge,to,remove,return,the,new,graph,containing,the,existing,vertices,and,edges,without,the,removed,edges;public,graph,k,vv,ev,remove,edge,edge,k,ev,edge,data,set,edge,k,ev,new,edges,get,edges,filter,new,edge,removal,edge,filter,edge,return,new,graph,this,vertices,new,edges,this,context
Graph -> public Graph<K, VV, EV> removeEdge(Edge<K, EV> edge);1475684776;Removes all edges that match the given edge from the graph.__@param edge the edge to remove_@return the new graph containing the existing vertices and edges without_the removed edges;public Graph<K, VV, EV> removeEdge(Edge<K, EV> edge) {_		DataSet<Edge<K, EV>> newEdges = getEdges().filter(new EdgeRemovalEdgeFilter<>(edge))__		return new Graph<>(this.vertices, newEdges, this.context)__	};removes,all,edges,that,match,the,given,edge,from,the,graph,param,edge,the,edge,to,remove,return,the,new,graph,containing,the,existing,vertices,and,edges,without,the,removed,edges;public,graph,k,vv,ev,remove,edge,edge,k,ev,edge,data,set,edge,k,ev,new,edges,get,edges,filter,new,edge,removal,edge,filter,edge,return,new,graph,this,vertices,new,edges,this,context
Graph -> public Graph<K, VV, EV> removeEdge(Edge<K, EV> edge);1475685606;Removes all edges that match the given edge from the graph.__@param edge the edge to remove_@return the new graph containing the existing vertices and edges without_the removed edges;public Graph<K, VV, EV> removeEdge(Edge<K, EV> edge) {_		DataSet<Edge<K, EV>> newEdges = getEdges().filter(new EdgeRemovalEdgeFilter<>(edge))__		return new Graph<>(this.vertices, newEdges, this.context)__	};removes,all,edges,that,match,the,given,edge,from,the,graph,param,edge,the,edge,to,remove,return,the,new,graph,containing,the,existing,vertices,and,edges,without,the,removed,edges;public,graph,k,vv,ev,remove,edge,edge,k,ev,edge,data,set,edge,k,ev,new,edges,get,edges,filter,new,edge,removal,edge,filter,edge,return,new,graph,this,vertices,new,edges,this,context
Graph -> public Graph<K, VV, EV> removeEdge(Edge<K, EV> edge);1481745825;Removes all edges that match the given edge from the graph.__@param edge the edge to remove_@return the new graph containing the existing vertices and edges without_the removed edges;public Graph<K, VV, EV> removeEdge(Edge<K, EV> edge) {_		DataSet<Edge<K, EV>> newEdges = getEdges().filter(new EdgeRemovalEdgeFilter<>(edge)).name("Remove edge")__		return new Graph<>(this.vertices, newEdges, this.context)__	};removes,all,edges,that,match,the,given,edge,from,the,graph,param,edge,the,edge,to,remove,return,the,new,graph,containing,the,existing,vertices,and,edges,without,the,removed,edges;public,graph,k,vv,ev,remove,edge,edge,k,ev,edge,data,set,edge,k,ev,new,edges,get,edges,filter,new,edge,removal,edge,filter,edge,name,remove,edge,return,new,graph,this,vertices,new,edges,this,context
Graph -> public Graph<K, VV, EV> removeEdge(Edge<K, EV> edge);1481881009;Removes all edges that match the given edge from the graph.__@param edge the edge to remove_@return the new graph containing the existing vertices and edges without_the removed edges;public Graph<K, VV, EV> removeEdge(Edge<K, EV> edge) {_		DataSet<Edge<K, EV>> newEdges = getEdges().filter(new EdgeRemovalEdgeFilter<>(edge)).name("Remove edge")__		return new Graph<>(this.vertices, newEdges, this.context)__	};removes,all,edges,that,match,the,given,edge,from,the,graph,param,edge,the,edge,to,remove,return,the,new,graph,containing,the,existing,vertices,and,edges,without,the,removed,edges;public,graph,k,vv,ev,remove,edge,edge,k,ev,edge,data,set,edge,k,ev,new,edges,get,edges,filter,new,edge,removal,edge,filter,edge,name,remove,edge,return,new,graph,this,vertices,new,edges,this,context
Graph -> public Graph<K, VV, EV> removeEdge(Edge<K, EV> edge);1484160227;Removes all edges that match the given edge from the graph.__@param edge the edge to remove_@return the new graph containing the existing vertices and edges without_the removed edges;public Graph<K, VV, EV> removeEdge(Edge<K, EV> edge) {_		DataSet<Edge<K, EV>> newEdges = getEdges().filter(new EdgeRemovalEdgeFilter<>(edge)).name("Remove edge")__		return new Graph<>(this.vertices, newEdges, this.context)__	};removes,all,edges,that,match,the,given,edge,from,the,graph,param,edge,the,edge,to,remove,return,the,new,graph,containing,the,existing,vertices,and,edges,without,the,removed,edges;public,graph,k,vv,ev,remove,edge,edge,k,ev,edge,data,set,edge,k,ev,new,edges,get,edges,filter,new,edge,removal,edge,filter,edge,name,remove,edge,return,new,graph,this,vertices,new,edges,this,context
Graph -> public Graph<K, VV, EV> removeEdge(Edge<K, EV> edge);1484685504;Removes all edges that match the given edge from the graph.__@param edge the edge to remove_@return the new graph containing the existing vertices and edges without_the removed edges;public Graph<K, VV, EV> removeEdge(Edge<K, EV> edge) {_		DataSet<Edge<K, EV>> newEdges = getEdges().filter(new EdgeRemovalEdgeFilter<>(edge)).name("Remove edge")__		return new Graph<>(this.vertices, newEdges, this.context)__	};removes,all,edges,that,match,the,given,edge,from,the,graph,param,edge,the,edge,to,remove,return,the,new,graph,containing,the,existing,vertices,and,edges,without,the,removed,edges;public,graph,k,vv,ev,remove,edge,edge,k,ev,edge,data,set,edge,k,ev,new,edges,get,edges,filter,new,edge,removal,edge,filter,edge,name,remove,edge,return,new,graph,this,vertices,new,edges,this,context
Graph -> public Graph<K, VV, EV> removeEdge(Edge<K, EV> edge);1489068942;Removes all edges that match the given edge from the graph.__@param edge the edge to remove_@return the new graph containing the existing vertices and edges without_the removed edges;public Graph<K, VV, EV> removeEdge(Edge<K, EV> edge) {_		DataSet<Edge<K, EV>> newEdges = getEdges().filter(new EdgeRemovalEdgeFilter<>(edge)).name("Remove edge")__		return new Graph<>(this.vertices, newEdges, this.context)__	};removes,all,edges,that,match,the,given,edge,from,the,graph,param,edge,the,edge,to,remove,return,the,new,graph,containing,the,existing,vertices,and,edges,without,the,removed,edges;public,graph,k,vv,ev,remove,edge,edge,k,ev,edge,data,set,edge,k,ev,new,edges,get,edges,filter,new,edge,removal,edge,filter,edge,name,remove,edge,return,new,graph,this,vertices,new,edges,this,context
Graph -> public Graph<K, VV, EV> removeEdge(Edge<K, EV> edge);1490973446;Removes all edges that match the given edge from the graph.__@param edge the edge to remove_@return the new graph containing the existing vertices and edges without_the removed edges;public Graph<K, VV, EV> removeEdge(Edge<K, EV> edge) {_		DataSet<Edge<K, EV>> newEdges = getEdges().filter(new EdgeRemovalEdgeFilter<>(edge)).name("Remove edge")__		return new Graph<>(this.vertices, newEdges, this.context)__	};removes,all,edges,that,match,the,given,edge,from,the,graph,param,edge,the,edge,to,remove,return,the,new,graph,containing,the,existing,vertices,and,edges,without,the,removed,edges;public,graph,k,vv,ev,remove,edge,edge,k,ev,edge,data,set,edge,k,ev,new,edges,get,edges,filter,new,edge,removal,edge,filter,edge,name,remove,edge,return,new,graph,this,vertices,new,edges,this,context
Graph -> public Graph<K, VV, EV> removeEdge(Edge<K, EV> edge);1495819075;Removes all edges that match the given edge from the graph.__@param edge the edge to remove_@return the new graph containing the existing vertices and edges without_the removed edges;public Graph<K, VV, EV> removeEdge(Edge<K, EV> edge) {_		DataSet<Edge<K, EV>> newEdges = getEdges().filter(new EdgeRemovalEdgeFilter<>(edge)).name("Remove edge")__		return new Graph<>(this.vertices, newEdges, this.context)__	};removes,all,edges,that,match,the,given,edge,from,the,graph,param,edge,the,edge,to,remove,return,the,new,graph,containing,the,existing,vertices,and,edges,without,the,removed,edges;public,graph,k,vv,ev,remove,edge,edge,k,ev,edge,data,set,edge,k,ev,new,edges,get,edges,filter,new,edge,removal,edge,filter,edge,name,remove,edge,return,new,graph,this,vertices,new,edges,this,context
Graph -> public Graph<K, VV, EV> removeEdge(Edge<K, EV> edge);1502111816;Removes all edges that match the given edge from the graph.__@param edge the edge to remove_@return the new graph containing the existing vertices and edges without_the removed edges;public Graph<K, VV, EV> removeEdge(Edge<K, EV> edge) {_		DataSet<Edge<K, EV>> newEdges = getEdges().filter(new EdgeRemovalEdgeFilter<>(edge)).name("Remove edge")__		return new Graph<>(this.vertices, newEdges, this.context)__	};removes,all,edges,that,match,the,given,edge,from,the,graph,param,edge,the,edge,to,remove,return,the,new,graph,containing,the,existing,vertices,and,edges,without,the,removed,edges;public,graph,k,vv,ev,remove,edge,edge,k,ev,edge,data,set,edge,k,ev,new,edges,get,edges,filter,new,edge,removal,edge,filter,edge,name,remove,edge,return,new,graph,this,vertices,new,edges,this,context
Graph -> public static <K, VV, EV> Graph<K, VV, EV> fromCollection(Collection<Vertex<K, VV>> vertices, 			Collection<Edge<K, EV>> edges, ExecutionEnvironment context);1444404795;Creates a graph from a Collection of vertices and a Collection of edges.__@param vertices a Collection of vertices._@param edges a Collection of edges._@param context the flink execution environment._@return the newly created graph.;public static <K, VV, EV> Graph<K, VV, EV> fromCollection(Collection<Vertex<K, VV>> vertices,_			Collection<Edge<K, EV>> edges, ExecutionEnvironment context) {__		return fromDataSet(context.fromCollection(vertices),_				context.fromCollection(edges), context)__	};creates,a,graph,from,a,collection,of,vertices,and,a,collection,of,edges,param,vertices,a,collection,of,vertices,param,edges,a,collection,of,edges,param,context,the,flink,execution,environment,return,the,newly,created,graph;public,static,k,vv,ev,graph,k,vv,ev,from,collection,collection,vertex,k,vv,vertices,collection,edge,k,ev,edges,execution,environment,context,return,from,data,set,context,from,collection,vertices,context,from,collection,edges,context
Graph -> public static <K, VV, EV> Graph<K, VV, EV> fromCollection(Collection<Vertex<K, VV>> vertices, 			Collection<Edge<K, EV>> edges, ExecutionEnvironment context);1445261977;Creates a graph from a Collection of vertices and a Collection of edges.__@param vertices a Collection of vertices._@param edges a Collection of edges._@param context the flink execution environment._@return the newly created graph.;public static <K, VV, EV> Graph<K, VV, EV> fromCollection(Collection<Vertex<K, VV>> vertices,_			Collection<Edge<K, EV>> edges, ExecutionEnvironment context) {__		return fromDataSet(context.fromCollection(vertices),_				context.fromCollection(edges), context)__	};creates,a,graph,from,a,collection,of,vertices,and,a,collection,of,edges,param,vertices,a,collection,of,vertices,param,edges,a,collection,of,edges,param,context,the,flink,execution,environment,return,the,newly,created,graph;public,static,k,vv,ev,graph,k,vv,ev,from,collection,collection,vertex,k,vv,vertices,collection,edge,k,ev,edges,execution,environment,context,return,from,data,set,context,from,collection,vertices,context,from,collection,edges,context
Graph -> public static <K, VV, EV> Graph<K, VV, EV> fromCollection(Collection<Vertex<K, VV>> vertices, 			Collection<Edge<K, EV>> edges, ExecutionEnvironment context);1445854323;Creates a graph from a Collection of vertices and a Collection of edges.__@param vertices a Collection of vertices._@param edges a Collection of edges._@param context the flink execution environment._@return the newly created graph.;public static <K, VV, EV> Graph<K, VV, EV> fromCollection(Collection<Vertex<K, VV>> vertices,_			Collection<Edge<K, EV>> edges, ExecutionEnvironment context) {__		return fromDataSet(context.fromCollection(vertices),_				context.fromCollection(edges), context)__	};creates,a,graph,from,a,collection,of,vertices,and,a,collection,of,edges,param,vertices,a,collection,of,vertices,param,edges,a,collection,of,edges,param,context,the,flink,execution,environment,return,the,newly,created,graph;public,static,k,vv,ev,graph,k,vv,ev,from,collection,collection,vertex,k,vv,vertices,collection,edge,k,ev,edges,execution,environment,context,return,from,data,set,context,from,collection,vertices,context,from,collection,edges,context
Graph -> public static <K, VV, EV> Graph<K, VV, EV> fromCollection(Collection<Vertex<K, VV>> vertices, 			Collection<Edge<K, EV>> edges, ExecutionEnvironment context);1446112342;Creates a graph from a Collection of vertices and a Collection of edges.__@param vertices a Collection of vertices._@param edges a Collection of edges._@param context the flink execution environment._@return the newly created graph.;public static <K, VV, EV> Graph<K, VV, EV> fromCollection(Collection<Vertex<K, VV>> vertices,_			Collection<Edge<K, EV>> edges, ExecutionEnvironment context) {__		return fromDataSet(context.fromCollection(vertices),_				context.fromCollection(edges), context)__	};creates,a,graph,from,a,collection,of,vertices,and,a,collection,of,edges,param,vertices,a,collection,of,vertices,param,edges,a,collection,of,edges,param,context,the,flink,execution,environment,return,the,newly,created,graph;public,static,k,vv,ev,graph,k,vv,ev,from,collection,collection,vertex,k,vv,vertices,collection,edge,k,ev,edges,execution,environment,context,return,from,data,set,context,from,collection,vertices,context,from,collection,edges,context
Graph -> public static <K, VV, EV> Graph<K, VV, EV> fromCollection(Collection<Vertex<K, VV>> vertices, 			Collection<Edge<K, EV>> edges, ExecutionEnvironment context);1447073368;Creates a graph from a Collection of vertices and a Collection of edges.__@param vertices a Collection of vertices._@param edges a Collection of edges._@param context the flink execution environment._@return the newly created graph.;public static <K, VV, EV> Graph<K, VV, EV> fromCollection(Collection<Vertex<K, VV>> vertices,_			Collection<Edge<K, EV>> edges, ExecutionEnvironment context) {__		return fromDataSet(context.fromCollection(vertices),_				context.fromCollection(edges), context)__	};creates,a,graph,from,a,collection,of,vertices,and,a,collection,of,edges,param,vertices,a,collection,of,vertices,param,edges,a,collection,of,edges,param,context,the,flink,execution,environment,return,the,newly,created,graph;public,static,k,vv,ev,graph,k,vv,ev,from,collection,collection,vertex,k,vv,vertices,collection,edge,k,ev,edges,execution,environment,context,return,from,data,set,context,from,collection,vertices,context,from,collection,edges,context
Graph -> public static <K, VV, EV> Graph<K, VV, EV> fromCollection(Collection<Vertex<K, VV>> vertices, 			Collection<Edge<K, EV>> edges, ExecutionEnvironment context);1454404649;Creates a graph from a Collection of vertices and a Collection of edges.__@param vertices a Collection of vertices._@param edges a Collection of edges._@param context the flink execution environment._@return the newly created graph.;public static <K, VV, EV> Graph<K, VV, EV> fromCollection(Collection<Vertex<K, VV>> vertices,_			Collection<Edge<K, EV>> edges, ExecutionEnvironment context) {__		return fromDataSet(context.fromCollection(vertices),_				context.fromCollection(edges), context)__	};creates,a,graph,from,a,collection,of,vertices,and,a,collection,of,edges,param,vertices,a,collection,of,vertices,param,edges,a,collection,of,edges,param,context,the,flink,execution,environment,return,the,newly,created,graph;public,static,k,vv,ev,graph,k,vv,ev,from,collection,collection,vertex,k,vv,vertices,collection,edge,k,ev,edges,execution,environment,context,return,from,data,set,context,from,collection,vertices,context,from,collection,edges,context
Graph -> public static <K, VV, EV> Graph<K, VV, EV> fromCollection(Collection<Vertex<K, VV>> vertices, 			Collection<Edge<K, EV>> edges, ExecutionEnvironment context);1458583829;Creates a graph from a Collection of vertices and a Collection of edges.__@param vertices a Collection of vertices._@param edges a Collection of edges._@param context the flink execution environment._@return the newly created graph.;public static <K, VV, EV> Graph<K, VV, EV> fromCollection(Collection<Vertex<K, VV>> vertices,_			Collection<Edge<K, EV>> edges, ExecutionEnvironment context) {__		return fromDataSet(context.fromCollection(vertices),_				context.fromCollection(edges), context)__	};creates,a,graph,from,a,collection,of,vertices,and,a,collection,of,edges,param,vertices,a,collection,of,vertices,param,edges,a,collection,of,edges,param,context,the,flink,execution,environment,return,the,newly,created,graph;public,static,k,vv,ev,graph,k,vv,ev,from,collection,collection,vertex,k,vv,vertices,collection,edge,k,ev,edges,execution,environment,context,return,from,data,set,context,from,collection,vertices,context,from,collection,edges,context
Graph -> public static <K, VV, EV> Graph<K, VV, EV> fromCollection(Collection<Vertex<K, VV>> vertices, 			Collection<Edge<K, EV>> edges, ExecutionEnvironment context);1458583829;Creates a graph from a Collection of vertices and a Collection of edges.__@param vertices a Collection of vertices._@param edges a Collection of edges._@param context the flink execution environment._@return the newly created graph.;public static <K, VV, EV> Graph<K, VV, EV> fromCollection(Collection<Vertex<K, VV>> vertices,_			Collection<Edge<K, EV>> edges, ExecutionEnvironment context) {__		return fromDataSet(context.fromCollection(vertices),_				context.fromCollection(edges), context)__	};creates,a,graph,from,a,collection,of,vertices,and,a,collection,of,edges,param,vertices,a,collection,of,vertices,param,edges,a,collection,of,edges,param,context,the,flink,execution,environment,return,the,newly,created,graph;public,static,k,vv,ev,graph,k,vv,ev,from,collection,collection,vertex,k,vv,vertices,collection,edge,k,ev,edges,execution,environment,context,return,from,data,set,context,from,collection,vertices,context,from,collection,edges,context
Graph -> public static <K, VV, EV> Graph<K, VV, EV> fromCollection(Collection<Vertex<K, VV>> vertices, 			Collection<Edge<K, EV>> edges, ExecutionEnvironment context);1462100316;Creates a graph from a Collection of vertices and a Collection of edges.__@param vertices a Collection of vertices._@param edges a Collection of edges._@param context the flink execution environment._@return the newly created graph.;public static <K, VV, EV> Graph<K, VV, EV> fromCollection(Collection<Vertex<K, VV>> vertices,_			Collection<Edge<K, EV>> edges, ExecutionEnvironment context) {__		return fromDataSet(context.fromCollection(vertices),_				context.fromCollection(edges), context)__	};creates,a,graph,from,a,collection,of,vertices,and,a,collection,of,edges,param,vertices,a,collection,of,vertices,param,edges,a,collection,of,edges,param,context,the,flink,execution,environment,return,the,newly,created,graph;public,static,k,vv,ev,graph,k,vv,ev,from,collection,collection,vertex,k,vv,vertices,collection,edge,k,ev,edges,execution,environment,context,return,from,data,set,context,from,collection,vertices,context,from,collection,edges,context
Graph -> public static <K, VV, EV> Graph<K, VV, EV> fromCollection(Collection<Vertex<K, VV>> vertices, 			Collection<Edge<K, EV>> edges, ExecutionEnvironment context);1462100316;Creates a graph from a Collection of vertices and a Collection of edges.__@param vertices a Collection of vertices._@param edges a Collection of edges._@param context the flink execution environment._@return the newly created graph.;public static <K, VV, EV> Graph<K, VV, EV> fromCollection(Collection<Vertex<K, VV>> vertices,_			Collection<Edge<K, EV>> edges, ExecutionEnvironment context) {__		return fromDataSet(context.fromCollection(vertices),_				context.fromCollection(edges), context)__	};creates,a,graph,from,a,collection,of,vertices,and,a,collection,of,edges,param,vertices,a,collection,of,vertices,param,edges,a,collection,of,edges,param,context,the,flink,execution,environment,return,the,newly,created,graph;public,static,k,vv,ev,graph,k,vv,ev,from,collection,collection,vertex,k,vv,vertices,collection,edge,k,ev,edges,execution,environment,context,return,from,data,set,context,from,collection,vertices,context,from,collection,edges,context
Graph -> public static <K, VV, EV> Graph<K, VV, EV> fromCollection(Collection<Vertex<K, VV>> vertices, 			Collection<Edge<K, EV>> edges, ExecutionEnvironment context);1462205213;Creates a graph from a Collection of vertices and a Collection of edges.__@param vertices a Collection of vertices._@param edges a Collection of edges._@param context the flink execution environment._@return the newly created graph.;public static <K, VV, EV> Graph<K, VV, EV> fromCollection(Collection<Vertex<K, VV>> vertices,_			Collection<Edge<K, EV>> edges, ExecutionEnvironment context) {__		return fromDataSet(context.fromCollection(vertices),_				context.fromCollection(edges), context)__	};creates,a,graph,from,a,collection,of,vertices,and,a,collection,of,edges,param,vertices,a,collection,of,vertices,param,edges,a,collection,of,edges,param,context,the,flink,execution,environment,return,the,newly,created,graph;public,static,k,vv,ev,graph,k,vv,ev,from,collection,collection,vertex,k,vv,vertices,collection,edge,k,ev,edges,execution,environment,context,return,from,data,set,context,from,collection,vertices,context,from,collection,edges,context
Graph -> public static <K, VV, EV> Graph<K, VV, EV> fromCollection(Collection<Vertex<K, VV>> vertices, 			Collection<Edge<K, EV>> edges, ExecutionEnvironment context);1462208859;Creates a graph from a Collection of vertices and a Collection of edges.__@param vertices a Collection of vertices._@param edges a Collection of edges._@param context the flink execution environment._@return the newly created graph.;public static <K, VV, EV> Graph<K, VV, EV> fromCollection(Collection<Vertex<K, VV>> vertices,_			Collection<Edge<K, EV>> edges, ExecutionEnvironment context) {__		return fromDataSet(context.fromCollection(vertices),_				context.fromCollection(edges), context)__	};creates,a,graph,from,a,collection,of,vertices,and,a,collection,of,edges,param,vertices,a,collection,of,vertices,param,edges,a,collection,of,edges,param,context,the,flink,execution,environment,return,the,newly,created,graph;public,static,k,vv,ev,graph,k,vv,ev,from,collection,collection,vertex,k,vv,vertices,collection,edge,k,ev,edges,execution,environment,context,return,from,data,set,context,from,collection,vertices,context,from,collection,edges,context
Graph -> public static <K, VV, EV> Graph<K, VV, EV> fromCollection(Collection<Vertex<K, VV>> vertices, 			Collection<Edge<K, EV>> edges, ExecutionEnvironment context);1462809297;Creates a graph from a Collection of vertices and a Collection of edges.__@param vertices a Collection of vertices._@param edges a Collection of edges._@param context the flink execution environment._@return the newly created graph.;public static <K, VV, EV> Graph<K, VV, EV> fromCollection(Collection<Vertex<K, VV>> vertices,_			Collection<Edge<K, EV>> edges, ExecutionEnvironment context) {__		return fromDataSet(context.fromCollection(vertices),_				context.fromCollection(edges), context)__	};creates,a,graph,from,a,collection,of,vertices,and,a,collection,of,edges,param,vertices,a,collection,of,vertices,param,edges,a,collection,of,edges,param,context,the,flink,execution,environment,return,the,newly,created,graph;public,static,k,vv,ev,graph,k,vv,ev,from,collection,collection,vertex,k,vv,vertices,collection,edge,k,ev,edges,execution,environment,context,return,from,data,set,context,from,collection,vertices,context,from,collection,edges,context
Graph -> public static <K, VV, EV> Graph<K, VV, EV> fromCollection(Collection<Vertex<K, VV>> vertices, 			Collection<Edge<K, EV>> edges, ExecutionEnvironment context);1465316775;Creates a graph from a Collection of vertices and a Collection of edges.__@param vertices a Collection of vertices._@param edges a Collection of edges._@param context the flink execution environment._@return the newly created graph.;public static <K, VV, EV> Graph<K, VV, EV> fromCollection(Collection<Vertex<K, VV>> vertices,_			Collection<Edge<K, EV>> edges, ExecutionEnvironment context) {__		return fromDataSet(context.fromCollection(vertices),_				context.fromCollection(edges), context)__	};creates,a,graph,from,a,collection,of,vertices,and,a,collection,of,edges,param,vertices,a,collection,of,vertices,param,edges,a,collection,of,edges,param,context,the,flink,execution,environment,return,the,newly,created,graph;public,static,k,vv,ev,graph,k,vv,ev,from,collection,collection,vertex,k,vv,vertices,collection,edge,k,ev,edges,execution,environment,context,return,from,data,set,context,from,collection,vertices,context,from,collection,edges,context
Graph -> public static <K, VV, EV> Graph<K, VV, EV> fromCollection(Collection<Vertex<K, VV>> vertices, 			Collection<Edge<K, EV>> edges, ExecutionEnvironment context);1466789678;Creates a graph from a Collection of vertices and a Collection of edges.__@param vertices a Collection of vertices._@param edges a Collection of edges._@param context the flink execution environment._@return the newly created graph.;public static <K, VV, EV> Graph<K, VV, EV> fromCollection(Collection<Vertex<K, VV>> vertices,_			Collection<Edge<K, EV>> edges, ExecutionEnvironment context) {__		return fromDataSet(context.fromCollection(vertices),_				context.fromCollection(edges), context)__	};creates,a,graph,from,a,collection,of,vertices,and,a,collection,of,edges,param,vertices,a,collection,of,vertices,param,edges,a,collection,of,edges,param,context,the,flink,execution,environment,return,the,newly,created,graph;public,static,k,vv,ev,graph,k,vv,ev,from,collection,collection,vertex,k,vv,vertices,collection,edge,k,ev,edges,execution,environment,context,return,from,data,set,context,from,collection,vertices,context,from,collection,edges,context
Graph -> public static <K, VV, EV> Graph<K, VV, EV> fromCollection(Collection<Vertex<K, VV>> vertices, 			Collection<Edge<K, EV>> edges, ExecutionEnvironment context);1467140656;Creates a graph from a Collection of vertices and a Collection of edges.__@param vertices a Collection of vertices._@param edges a Collection of edges._@param context the flink execution environment._@return the newly created graph.;public static <K, VV, EV> Graph<K, VV, EV> fromCollection(Collection<Vertex<K, VV>> vertices,_			Collection<Edge<K, EV>> edges, ExecutionEnvironment context) {__		return fromDataSet(context.fromCollection(vertices),_				context.fromCollection(edges), context)__	};creates,a,graph,from,a,collection,of,vertices,and,a,collection,of,edges,param,vertices,a,collection,of,vertices,param,edges,a,collection,of,edges,param,context,the,flink,execution,environment,return,the,newly,created,graph;public,static,k,vv,ev,graph,k,vv,ev,from,collection,collection,vertex,k,vv,vertices,collection,edge,k,ev,edges,execution,environment,context,return,from,data,set,context,from,collection,vertices,context,from,collection,edges,context
Graph -> public static <K, VV, EV> Graph<K, VV, EV> fromCollection(Collection<Vertex<K, VV>> vertices, 			Collection<Edge<K, EV>> edges, ExecutionEnvironment context);1467306272;Creates a graph from a Collection of vertices and a Collection of edges.__@param vertices a Collection of vertices._@param edges a Collection of edges._@param context the flink execution environment._@return the newly created graph.;public static <K, VV, EV> Graph<K, VV, EV> fromCollection(Collection<Vertex<K, VV>> vertices,_			Collection<Edge<K, EV>> edges, ExecutionEnvironment context) {__		return fromDataSet(context.fromCollection(vertices),_				context.fromCollection(edges), context)__	};creates,a,graph,from,a,collection,of,vertices,and,a,collection,of,edges,param,vertices,a,collection,of,vertices,param,edges,a,collection,of,edges,param,context,the,flink,execution,environment,return,the,newly,created,graph;public,static,k,vv,ev,graph,k,vv,ev,from,collection,collection,vertex,k,vv,vertices,collection,edge,k,ev,edges,execution,environment,context,return,from,data,set,context,from,collection,vertices,context,from,collection,edges,context
Graph -> public static <K, VV, EV> Graph<K, VV, EV> fromCollection(Collection<Vertex<K, VV>> vertices, 			Collection<Edge<K, EV>> edges, ExecutionEnvironment context);1470042815;Creates a graph from a Collection of vertices and a Collection of edges.__@param vertices a Collection of vertices._@param edges a Collection of edges._@param context the flink execution environment._@return the newly created graph.;public static <K, VV, EV> Graph<K, VV, EV> fromCollection(Collection<Vertex<K, VV>> vertices,_			Collection<Edge<K, EV>> edges, ExecutionEnvironment context) {__		return fromDataSet(context.fromCollection(vertices),_				context.fromCollection(edges), context)__	};creates,a,graph,from,a,collection,of,vertices,and,a,collection,of,edges,param,vertices,a,collection,of,vertices,param,edges,a,collection,of,edges,param,context,the,flink,execution,environment,return,the,newly,created,graph;public,static,k,vv,ev,graph,k,vv,ev,from,collection,collection,vertex,k,vv,vertices,collection,edge,k,ev,edges,execution,environment,context,return,from,data,set,context,from,collection,vertices,context,from,collection,edges,context
Graph -> public static <K, VV, EV> Graph<K, VV, EV> fromCollection(Collection<Vertex<K, VV>> vertices, 			Collection<Edge<K, EV>> edges, ExecutionEnvironment context);1475684776;Creates a graph from a Collection of vertices and a Collection of edges.__@param vertices a Collection of vertices._@param edges a Collection of edges._@param context the flink execution environment._@return the newly created graph.;public static <K, VV, EV> Graph<K, VV, EV> fromCollection(Collection<Vertex<K, VV>> vertices,_			Collection<Edge<K, EV>> edges, ExecutionEnvironment context) {__		return fromDataSet(context.fromCollection(vertices),_				context.fromCollection(edges), context)__	};creates,a,graph,from,a,collection,of,vertices,and,a,collection,of,edges,param,vertices,a,collection,of,vertices,param,edges,a,collection,of,edges,param,context,the,flink,execution,environment,return,the,newly,created,graph;public,static,k,vv,ev,graph,k,vv,ev,from,collection,collection,vertex,k,vv,vertices,collection,edge,k,ev,edges,execution,environment,context,return,from,data,set,context,from,collection,vertices,context,from,collection,edges,context
Graph -> public static <K, VV, EV> Graph<K, VV, EV> fromCollection(Collection<Vertex<K, VV>> vertices, 			Collection<Edge<K, EV>> edges, ExecutionEnvironment context);1475685606;Creates a graph from a Collection of vertices and a Collection of edges.__@param vertices a Collection of vertices._@param edges a Collection of edges._@param context the flink execution environment._@return the newly created graph.;public static <K, VV, EV> Graph<K, VV, EV> fromCollection(Collection<Vertex<K, VV>> vertices,_			Collection<Edge<K, EV>> edges, ExecutionEnvironment context) {__		return fromDataSet(context.fromCollection(vertices),_				context.fromCollection(edges), context)__	};creates,a,graph,from,a,collection,of,vertices,and,a,collection,of,edges,param,vertices,a,collection,of,vertices,param,edges,a,collection,of,edges,param,context,the,flink,execution,environment,return,the,newly,created,graph;public,static,k,vv,ev,graph,k,vv,ev,from,collection,collection,vertex,k,vv,vertices,collection,edge,k,ev,edges,execution,environment,context,return,from,data,set,context,from,collection,vertices,context,from,collection,edges,context
Graph -> public static <K, VV, EV> Graph<K, VV, EV> fromCollection(Collection<Vertex<K, VV>> vertices, 			Collection<Edge<K, EV>> edges, ExecutionEnvironment context);1481745825;Creates a graph from a Collection of vertices and a Collection of edges.__@param vertices a Collection of vertices._@param edges a Collection of edges._@param context the flink execution environment._@return the newly created graph.;public static <K, VV, EV> Graph<K, VV, EV> fromCollection(Collection<Vertex<K, VV>> vertices,_			Collection<Edge<K, EV>> edges, ExecutionEnvironment context) {__		return fromDataSet(context.fromCollection(vertices),_				context.fromCollection(edges), context)__	};creates,a,graph,from,a,collection,of,vertices,and,a,collection,of,edges,param,vertices,a,collection,of,vertices,param,edges,a,collection,of,edges,param,context,the,flink,execution,environment,return,the,newly,created,graph;public,static,k,vv,ev,graph,k,vv,ev,from,collection,collection,vertex,k,vv,vertices,collection,edge,k,ev,edges,execution,environment,context,return,from,data,set,context,from,collection,vertices,context,from,collection,edges,context
Graph -> public static <K, VV, EV> Graph<K, VV, EV> fromCollection(Collection<Vertex<K, VV>> vertices, 			Collection<Edge<K, EV>> edges, ExecutionEnvironment context);1481881009;Creates a graph from a Collection of vertices and a Collection of edges.__@param vertices a Collection of vertices._@param edges a Collection of edges._@param context the flink execution environment._@return the newly created graph.;public static <K, VV, EV> Graph<K, VV, EV> fromCollection(Collection<Vertex<K, VV>> vertices,_			Collection<Edge<K, EV>> edges, ExecutionEnvironment context) {__		return fromDataSet(context.fromCollection(vertices),_				context.fromCollection(edges), context)__	};creates,a,graph,from,a,collection,of,vertices,and,a,collection,of,edges,param,vertices,a,collection,of,vertices,param,edges,a,collection,of,edges,param,context,the,flink,execution,environment,return,the,newly,created,graph;public,static,k,vv,ev,graph,k,vv,ev,from,collection,collection,vertex,k,vv,vertices,collection,edge,k,ev,edges,execution,environment,context,return,from,data,set,context,from,collection,vertices,context,from,collection,edges,context
Graph -> public static <K, VV, EV> Graph<K, VV, EV> fromCollection(Collection<Vertex<K, VV>> vertices, 			Collection<Edge<K, EV>> edges, ExecutionEnvironment context);1484160227;Creates a graph from a Collection of vertices and a Collection of edges.__@param vertices a Collection of vertices._@param edges a Collection of edges._@param context the flink execution environment._@return the newly created graph.;public static <K, VV, EV> Graph<K, VV, EV> fromCollection(Collection<Vertex<K, VV>> vertices,_			Collection<Edge<K, EV>> edges, ExecutionEnvironment context) {__		return fromDataSet(context.fromCollection(vertices),_				context.fromCollection(edges), context)__	};creates,a,graph,from,a,collection,of,vertices,and,a,collection,of,edges,param,vertices,a,collection,of,vertices,param,edges,a,collection,of,edges,param,context,the,flink,execution,environment,return,the,newly,created,graph;public,static,k,vv,ev,graph,k,vv,ev,from,collection,collection,vertex,k,vv,vertices,collection,edge,k,ev,edges,execution,environment,context,return,from,data,set,context,from,collection,vertices,context,from,collection,edges,context
Graph -> public static <K, VV, EV> Graph<K, VV, EV> fromCollection(Collection<Vertex<K, VV>> vertices, 			Collection<Edge<K, EV>> edges, ExecutionEnvironment context);1484685504;Creates a graph from a Collection of vertices and a Collection of edges.__@param vertices a Collection of vertices._@param edges a Collection of edges._@param context the flink execution environment._@return the newly created graph.;public static <K, VV, EV> Graph<K, VV, EV> fromCollection(Collection<Vertex<K, VV>> vertices,_			Collection<Edge<K, EV>> edges, ExecutionEnvironment context) {__		return fromDataSet(context.fromCollection(vertices),_				context.fromCollection(edges), context)__	};creates,a,graph,from,a,collection,of,vertices,and,a,collection,of,edges,param,vertices,a,collection,of,vertices,param,edges,a,collection,of,edges,param,context,the,flink,execution,environment,return,the,newly,created,graph;public,static,k,vv,ev,graph,k,vv,ev,from,collection,collection,vertex,k,vv,vertices,collection,edge,k,ev,edges,execution,environment,context,return,from,data,set,context,from,collection,vertices,context,from,collection,edges,context
Graph -> public static <K, VV, EV> Graph<K, VV, EV> fromCollection(Collection<Vertex<K, VV>> vertices, 			Collection<Edge<K, EV>> edges, ExecutionEnvironment context);1489068942;Creates a graph from a Collection of vertices and a Collection of edges.__@param vertices a Collection of vertices._@param edges a Collection of edges._@param context the flink execution environment._@return the newly created graph.;public static <K, VV, EV> Graph<K, VV, EV> fromCollection(Collection<Vertex<K, VV>> vertices,_			Collection<Edge<K, EV>> edges, ExecutionEnvironment context) {__		return fromDataSet(context.fromCollection(vertices),_				context.fromCollection(edges), context)__	};creates,a,graph,from,a,collection,of,vertices,and,a,collection,of,edges,param,vertices,a,collection,of,vertices,param,edges,a,collection,of,edges,param,context,the,flink,execution,environment,return,the,newly,created,graph;public,static,k,vv,ev,graph,k,vv,ev,from,collection,collection,vertex,k,vv,vertices,collection,edge,k,ev,edges,execution,environment,context,return,from,data,set,context,from,collection,vertices,context,from,collection,edges,context
Graph -> public static <K, VV, EV> Graph<K, VV, EV> fromCollection(Collection<Vertex<K, VV>> vertices, 			Collection<Edge<K, EV>> edges, ExecutionEnvironment context);1490973446;Creates a graph from a Collection of vertices and a Collection of edges.__@param vertices a Collection of vertices._@param edges a Collection of edges._@param context the flink execution environment._@return the newly created graph.;public static <K, VV, EV> Graph<K, VV, EV> fromCollection(Collection<Vertex<K, VV>> vertices,_			Collection<Edge<K, EV>> edges, ExecutionEnvironment context) {__		return fromDataSet(context.fromCollection(vertices),_				context.fromCollection(edges), context)__	};creates,a,graph,from,a,collection,of,vertices,and,a,collection,of,edges,param,vertices,a,collection,of,vertices,param,edges,a,collection,of,edges,param,context,the,flink,execution,environment,return,the,newly,created,graph;public,static,k,vv,ev,graph,k,vv,ev,from,collection,collection,vertex,k,vv,vertices,collection,edge,k,ev,edges,execution,environment,context,return,from,data,set,context,from,collection,vertices,context,from,collection,edges,context
Graph -> public static <K, VV, EV> Graph<K, VV, EV> fromCollection(Collection<Vertex<K, VV>> vertices, 			Collection<Edge<K, EV>> edges, ExecutionEnvironment context);1495819075;Creates a graph from a Collection of vertices and a Collection of edges.__@param vertices a Collection of vertices._@param edges a Collection of edges._@param context the flink execution environment._@return the newly created graph.;public static <K, VV, EV> Graph<K, VV, EV> fromCollection(Collection<Vertex<K, VV>> vertices,_			Collection<Edge<K, EV>> edges, ExecutionEnvironment context) {__		return fromDataSet(context.fromCollection(vertices),_				context.fromCollection(edges), context)__	};creates,a,graph,from,a,collection,of,vertices,and,a,collection,of,edges,param,vertices,a,collection,of,vertices,param,edges,a,collection,of,edges,param,context,the,flink,execution,environment,return,the,newly,created,graph;public,static,k,vv,ev,graph,k,vv,ev,from,collection,collection,vertex,k,vv,vertices,collection,edge,k,ev,edges,execution,environment,context,return,from,data,set,context,from,collection,vertices,context,from,collection,edges,context
Graph -> public static <K, VV, EV> Graph<K, VV, EV> fromCollection(Collection<Vertex<K, VV>> vertices, 			Collection<Edge<K, EV>> edges, ExecutionEnvironment context);1502111816;Creates a graph from a Collection of vertices and a Collection of edges.__@param vertices a Collection of vertices._@param edges a Collection of edges._@param context the flink execution environment._@return the newly created graph.;public static <K, VV, EV> Graph<K, VV, EV> fromCollection(Collection<Vertex<K, VV>> vertices,_			Collection<Edge<K, EV>> edges, ExecutionEnvironment context) {__		return fromDataSet(context.fromCollection(vertices),_				context.fromCollection(edges), context)__	};creates,a,graph,from,a,collection,of,vertices,and,a,collection,of,edges,param,vertices,a,collection,of,vertices,param,edges,a,collection,of,edges,param,context,the,flink,execution,environment,return,the,newly,created,graph;public,static,k,vv,ev,graph,k,vv,ev,from,collection,collection,vertex,k,vv,vertices,collection,edge,k,ev,edges,execution,environment,context,return,from,data,set,context,from,collection,vertices,context,from,collection,edges,context
Graph -> public DataSet<Tuple2<K, VV>> reduceOnNeighbors(ReduceNeighborsFunction<VV> reduceNeighborsFunction, 			EdgeDirection direction) throws IllegalArgumentException;1445261977;Compute a reduce transformation over the neighbors' vertex values of each vertex._For each vertex, the transformation consecutively calls a_{@link ReduceNeighborsFunction} until only a single value for each vertex remains._The {@link ReduceNeighborsFunction} combines a pair of neighbor vertex values_into one new value of the same type.__@param reduceNeighborsFunction the reduce function to apply to the neighbors of each vertex._@param direction the edge direction (in-, out-, all-)_@return a Dataset of Tuple2, with one tuple per vertex._The first field of the Tuple2 is the vertex ID and the second field_is the aggregate value computed by the provided {@link ReduceNeighborsFunction}._@throws IllegalArgumentException;public DataSet<Tuple2<K, VV>> reduceOnNeighbors(ReduceNeighborsFunction<VV> reduceNeighborsFunction,_			EdgeDirection direction) throws IllegalArgumentException {_		switch (direction) {_			case IN:_				_				final DataSet<Tuple2<K, VV>> verticesWithSourceNeighborValues = edges_						.join(this.vertices).where(0).equalTo(0)_						.with(new ProjectVertexWithNeighborValueJoin<K, VV, EV>(1))_						.withForwardedFieldsFirst("f1->f0")__				return verticesWithSourceNeighborValues.groupBy(0).reduce(new ApplyNeighborReduceFunction<K, VV>(_						reduceNeighborsFunction))__			case OUT:_				_				DataSet<Tuple2<K, VV>> verticesWithTargetNeighborValues = edges_						.join(this.vertices).where(1).equalTo(0)_						.with(new ProjectVertexWithNeighborValueJoin<K, VV, EV>(0))_						.withForwardedFieldsFirst("f0")__				return verticesWithTargetNeighborValues.groupBy(0).reduce(new ApplyNeighborReduceFunction<K, VV>(_						reduceNeighborsFunction))__			case ALL:_				_				DataSet<Tuple2<K, VV>> verticesWithNeighborValues = edges_						.flatMap(new EmitOneEdgeWithNeighborPerNode<K, EV>())_						.join(this.vertices).where(1).equalTo(0)_						.with(new ProjectNeighborValue<K, VV, EV>())___				return verticesWithNeighborValues.groupBy(0).reduce(new ApplyNeighborReduceFunction<K, VV>(_						reduceNeighborsFunction))__			default:_				throw new IllegalArgumentException("Illegal edge direction")__		}_	};compute,a,reduce,transformation,over,the,neighbors,vertex,values,of,each,vertex,for,each,vertex,the,transformation,consecutively,calls,a,link,reduce,neighbors,function,until,only,a,single,value,for,each,vertex,remains,the,link,reduce,neighbors,function,combines,a,pair,of,neighbor,vertex,values,into,one,new,value,of,the,same,type,param,reduce,neighbors,function,the,reduce,function,to,apply,to,the,neighbors,of,each,vertex,param,direction,the,edge,direction,in,out,all,return,a,dataset,of,tuple2,with,one,tuple,per,vertex,the,first,field,of,the,tuple2,is,the,vertex,id,and,the,second,field,is,the,aggregate,value,computed,by,the,provided,link,reduce,neighbors,function,throws,illegal,argument,exception;public,data,set,tuple2,k,vv,reduce,on,neighbors,reduce,neighbors,function,vv,reduce,neighbors,function,edge,direction,direction,throws,illegal,argument,exception,switch,direction,case,in,final,data,set,tuple2,k,vv,vertices,with,source,neighbor,values,edges,join,this,vertices,where,0,equal,to,0,with,new,project,vertex,with,neighbor,value,join,k,vv,ev,1,with,forwarded,fields,first,f1,f0,return,vertices,with,source,neighbor,values,group,by,0,reduce,new,apply,neighbor,reduce,function,k,vv,reduce,neighbors,function,case,out,data,set,tuple2,k,vv,vertices,with,target,neighbor,values,edges,join,this,vertices,where,1,equal,to,0,with,new,project,vertex,with,neighbor,value,join,k,vv,ev,0,with,forwarded,fields,first,f0,return,vertices,with,target,neighbor,values,group,by,0,reduce,new,apply,neighbor,reduce,function,k,vv,reduce,neighbors,function,case,all,data,set,tuple2,k,vv,vertices,with,neighbor,values,edges,flat,map,new,emit,one,edge,with,neighbor,per,node,k,ev,join,this,vertices,where,1,equal,to,0,with,new,project,neighbor,value,k,vv,ev,return,vertices,with,neighbor,values,group,by,0,reduce,new,apply,neighbor,reduce,function,k,vv,reduce,neighbors,function,default,throw,new,illegal,argument,exception,illegal,edge,direction
Graph -> public DataSet<Tuple2<K, VV>> reduceOnNeighbors(ReduceNeighborsFunction<VV> reduceNeighborsFunction, 			EdgeDirection direction) throws IllegalArgumentException;1445854323;Compute a reduce transformation over the neighbors' vertex values of each vertex._For each vertex, the transformation consecutively calls a_{@link ReduceNeighborsFunction} until only a single value for each vertex remains._The {@link ReduceNeighborsFunction} combines a pair of neighbor vertex values_into one new value of the same type.__@param reduceNeighborsFunction the reduce function to apply to the neighbors of each vertex._@param direction the edge direction (in-, out-, all-)_@return a Dataset of Tuple2, with one tuple per vertex._The first field of the Tuple2 is the vertex ID and the second field_is the aggregate value computed by the provided {@link ReduceNeighborsFunction}._@throws IllegalArgumentException;public DataSet<Tuple2<K, VV>> reduceOnNeighbors(ReduceNeighborsFunction<VV> reduceNeighborsFunction,_			EdgeDirection direction) throws IllegalArgumentException {_		switch (direction) {_			case IN:_				_				final DataSet<Tuple2<K, VV>> verticesWithSourceNeighborValues = edges_						.join(this.vertices).where(0).equalTo(0)_						.with(new ProjectVertexWithNeighborValueJoin<K, VV, EV>(1))_						.withForwardedFieldsFirst("f1->f0")__				return verticesWithSourceNeighborValues.groupBy(0).reduce(new ApplyNeighborReduceFunction<K, VV>(_						reduceNeighborsFunction))__			case OUT:_				_				DataSet<Tuple2<K, VV>> verticesWithTargetNeighborValues = edges_						.join(this.vertices).where(1).equalTo(0)_						.with(new ProjectVertexWithNeighborValueJoin<K, VV, EV>(0))_						.withForwardedFieldsFirst("f0")__				return verticesWithTargetNeighborValues.groupBy(0).reduce(new ApplyNeighborReduceFunction<K, VV>(_						reduceNeighborsFunction))__			case ALL:_				_				DataSet<Tuple2<K, VV>> verticesWithNeighborValues = edges_						.flatMap(new EmitOneEdgeWithNeighborPerNode<K, EV>())_						.join(this.vertices).where(1).equalTo(0)_						.with(new ProjectNeighborValue<K, VV, EV>())___				return verticesWithNeighborValues.groupBy(0).reduce(new ApplyNeighborReduceFunction<K, VV>(_						reduceNeighborsFunction))__			default:_				throw new IllegalArgumentException("Illegal edge direction")__		}_	};compute,a,reduce,transformation,over,the,neighbors,vertex,values,of,each,vertex,for,each,vertex,the,transformation,consecutively,calls,a,link,reduce,neighbors,function,until,only,a,single,value,for,each,vertex,remains,the,link,reduce,neighbors,function,combines,a,pair,of,neighbor,vertex,values,into,one,new,value,of,the,same,type,param,reduce,neighbors,function,the,reduce,function,to,apply,to,the,neighbors,of,each,vertex,param,direction,the,edge,direction,in,out,all,return,a,dataset,of,tuple2,with,one,tuple,per,vertex,the,first,field,of,the,tuple2,is,the,vertex,id,and,the,second,field,is,the,aggregate,value,computed,by,the,provided,link,reduce,neighbors,function,throws,illegal,argument,exception;public,data,set,tuple2,k,vv,reduce,on,neighbors,reduce,neighbors,function,vv,reduce,neighbors,function,edge,direction,direction,throws,illegal,argument,exception,switch,direction,case,in,final,data,set,tuple2,k,vv,vertices,with,source,neighbor,values,edges,join,this,vertices,where,0,equal,to,0,with,new,project,vertex,with,neighbor,value,join,k,vv,ev,1,with,forwarded,fields,first,f1,f0,return,vertices,with,source,neighbor,values,group,by,0,reduce,new,apply,neighbor,reduce,function,k,vv,reduce,neighbors,function,case,out,data,set,tuple2,k,vv,vertices,with,target,neighbor,values,edges,join,this,vertices,where,1,equal,to,0,with,new,project,vertex,with,neighbor,value,join,k,vv,ev,0,with,forwarded,fields,first,f0,return,vertices,with,target,neighbor,values,group,by,0,reduce,new,apply,neighbor,reduce,function,k,vv,reduce,neighbors,function,case,all,data,set,tuple2,k,vv,vertices,with,neighbor,values,edges,flat,map,new,emit,one,edge,with,neighbor,per,node,k,ev,join,this,vertices,where,1,equal,to,0,with,new,project,neighbor,value,k,vv,ev,return,vertices,with,neighbor,values,group,by,0,reduce,new,apply,neighbor,reduce,function,k,vv,reduce,neighbors,function,default,throw,new,illegal,argument,exception,illegal,edge,direction
Graph -> public DataSet<Tuple2<K, VV>> reduceOnNeighbors(ReduceNeighborsFunction<VV> reduceNeighborsFunction, 			EdgeDirection direction) throws IllegalArgumentException;1446112342;Compute a reduce transformation over the neighbors' vertex values of each vertex._For each vertex, the transformation consecutively calls a_{@link ReduceNeighborsFunction} until only a single value for each vertex remains._The {@link ReduceNeighborsFunction} combines a pair of neighbor vertex values_into one new value of the same type.__@param reduceNeighborsFunction the reduce function to apply to the neighbors of each vertex._@param direction the edge direction (in-, out-, all-)_@return a Dataset of Tuple2, with one tuple per vertex._The first field of the Tuple2 is the vertex ID and the second field_is the aggregate value computed by the provided {@link ReduceNeighborsFunction}._@throws IllegalArgumentException;public DataSet<Tuple2<K, VV>> reduceOnNeighbors(ReduceNeighborsFunction<VV> reduceNeighborsFunction,_			EdgeDirection direction) throws IllegalArgumentException {_		switch (direction) {_			case IN:_				_				final DataSet<Tuple2<K, VV>> verticesWithSourceNeighborValues = edges_						.join(this.vertices).where(0).equalTo(0)_						.with(new ProjectVertexWithNeighborValueJoin<K, VV, EV>(1))_						.withForwardedFieldsFirst("f1->f0")__				return verticesWithSourceNeighborValues.groupBy(0).reduce(new ApplyNeighborReduceFunction<K, VV>(_						reduceNeighborsFunction))__			case OUT:_				_				DataSet<Tuple2<K, VV>> verticesWithTargetNeighborValues = edges_						.join(this.vertices).where(1).equalTo(0)_						.with(new ProjectVertexWithNeighborValueJoin<K, VV, EV>(0))_						.withForwardedFieldsFirst("f0")__				return verticesWithTargetNeighborValues.groupBy(0).reduce(new ApplyNeighborReduceFunction<K, VV>(_						reduceNeighborsFunction))__			case ALL:_				_				DataSet<Tuple2<K, VV>> verticesWithNeighborValues = edges_						.flatMap(new EmitOneEdgeWithNeighborPerNode<K, EV>())_						.join(this.vertices).where(1).equalTo(0)_						.with(new ProjectNeighborValue<K, VV, EV>())___				return verticesWithNeighborValues.groupBy(0).reduce(new ApplyNeighborReduceFunction<K, VV>(_						reduceNeighborsFunction))__			default:_				throw new IllegalArgumentException("Illegal edge direction")__		}_	};compute,a,reduce,transformation,over,the,neighbors,vertex,values,of,each,vertex,for,each,vertex,the,transformation,consecutively,calls,a,link,reduce,neighbors,function,until,only,a,single,value,for,each,vertex,remains,the,link,reduce,neighbors,function,combines,a,pair,of,neighbor,vertex,values,into,one,new,value,of,the,same,type,param,reduce,neighbors,function,the,reduce,function,to,apply,to,the,neighbors,of,each,vertex,param,direction,the,edge,direction,in,out,all,return,a,dataset,of,tuple2,with,one,tuple,per,vertex,the,first,field,of,the,tuple2,is,the,vertex,id,and,the,second,field,is,the,aggregate,value,computed,by,the,provided,link,reduce,neighbors,function,throws,illegal,argument,exception;public,data,set,tuple2,k,vv,reduce,on,neighbors,reduce,neighbors,function,vv,reduce,neighbors,function,edge,direction,direction,throws,illegal,argument,exception,switch,direction,case,in,final,data,set,tuple2,k,vv,vertices,with,source,neighbor,values,edges,join,this,vertices,where,0,equal,to,0,with,new,project,vertex,with,neighbor,value,join,k,vv,ev,1,with,forwarded,fields,first,f1,f0,return,vertices,with,source,neighbor,values,group,by,0,reduce,new,apply,neighbor,reduce,function,k,vv,reduce,neighbors,function,case,out,data,set,tuple2,k,vv,vertices,with,target,neighbor,values,edges,join,this,vertices,where,1,equal,to,0,with,new,project,vertex,with,neighbor,value,join,k,vv,ev,0,with,forwarded,fields,first,f0,return,vertices,with,target,neighbor,values,group,by,0,reduce,new,apply,neighbor,reduce,function,k,vv,reduce,neighbors,function,case,all,data,set,tuple2,k,vv,vertices,with,neighbor,values,edges,flat,map,new,emit,one,edge,with,neighbor,per,node,k,ev,join,this,vertices,where,1,equal,to,0,with,new,project,neighbor,value,k,vv,ev,return,vertices,with,neighbor,values,group,by,0,reduce,new,apply,neighbor,reduce,function,k,vv,reduce,neighbors,function,default,throw,new,illegal,argument,exception,illegal,edge,direction
Graph -> public DataSet<Tuple2<K, VV>> reduceOnNeighbors(ReduceNeighborsFunction<VV> reduceNeighborsFunction, 			EdgeDirection direction) throws IllegalArgumentException;1447073368;Compute a reduce transformation over the neighbors' vertex values of each vertex._For each vertex, the transformation consecutively calls a_{@link ReduceNeighborsFunction} until only a single value for each vertex remains._The {@link ReduceNeighborsFunction} combines a pair of neighbor vertex values_into one new value of the same type.__@param reduceNeighborsFunction the reduce function to apply to the neighbors of each vertex._@param direction the edge direction (in-, out-, all-)_@return a Dataset of Tuple2, with one tuple per vertex._The first field of the Tuple2 is the vertex ID and the second field_is the aggregate value computed by the provided {@link ReduceNeighborsFunction}._@throws IllegalArgumentException;public DataSet<Tuple2<K, VV>> reduceOnNeighbors(ReduceNeighborsFunction<VV> reduceNeighborsFunction,_			EdgeDirection direction) throws IllegalArgumentException {_		switch (direction) {_			case IN:_				_				final DataSet<Tuple2<K, VV>> verticesWithSourceNeighborValues = edges_						.join(this.vertices).where(0).equalTo(0)_						.with(new ProjectVertexWithNeighborValueJoin<K, VV, EV>(1))_						.withForwardedFieldsFirst("f1->f0")__				return verticesWithSourceNeighborValues.groupBy(0).reduce(new ApplyNeighborReduceFunction<K, VV>(_						reduceNeighborsFunction))__			case OUT:_				_				DataSet<Tuple2<K, VV>> verticesWithTargetNeighborValues = edges_						.join(this.vertices).where(1).equalTo(0)_						.with(new ProjectVertexWithNeighborValueJoin<K, VV, EV>(0))_						.withForwardedFieldsFirst("f0")__				return verticesWithTargetNeighborValues.groupBy(0).reduce(new ApplyNeighborReduceFunction<K, VV>(_						reduceNeighborsFunction))__			case ALL:_				_				DataSet<Tuple2<K, VV>> verticesWithNeighborValues = edges_						.flatMap(new EmitOneEdgeWithNeighborPerNode<K, EV>())_						.join(this.vertices).where(1).equalTo(0)_						.with(new ProjectNeighborValue<K, VV, EV>())___				return verticesWithNeighborValues.groupBy(0).reduce(new ApplyNeighborReduceFunction<K, VV>(_						reduceNeighborsFunction))__			default:_				throw new IllegalArgumentException("Illegal edge direction")__		}_	};compute,a,reduce,transformation,over,the,neighbors,vertex,values,of,each,vertex,for,each,vertex,the,transformation,consecutively,calls,a,link,reduce,neighbors,function,until,only,a,single,value,for,each,vertex,remains,the,link,reduce,neighbors,function,combines,a,pair,of,neighbor,vertex,values,into,one,new,value,of,the,same,type,param,reduce,neighbors,function,the,reduce,function,to,apply,to,the,neighbors,of,each,vertex,param,direction,the,edge,direction,in,out,all,return,a,dataset,of,tuple2,with,one,tuple,per,vertex,the,first,field,of,the,tuple2,is,the,vertex,id,and,the,second,field,is,the,aggregate,value,computed,by,the,provided,link,reduce,neighbors,function,throws,illegal,argument,exception;public,data,set,tuple2,k,vv,reduce,on,neighbors,reduce,neighbors,function,vv,reduce,neighbors,function,edge,direction,direction,throws,illegal,argument,exception,switch,direction,case,in,final,data,set,tuple2,k,vv,vertices,with,source,neighbor,values,edges,join,this,vertices,where,0,equal,to,0,with,new,project,vertex,with,neighbor,value,join,k,vv,ev,1,with,forwarded,fields,first,f1,f0,return,vertices,with,source,neighbor,values,group,by,0,reduce,new,apply,neighbor,reduce,function,k,vv,reduce,neighbors,function,case,out,data,set,tuple2,k,vv,vertices,with,target,neighbor,values,edges,join,this,vertices,where,1,equal,to,0,with,new,project,vertex,with,neighbor,value,join,k,vv,ev,0,with,forwarded,fields,first,f0,return,vertices,with,target,neighbor,values,group,by,0,reduce,new,apply,neighbor,reduce,function,k,vv,reduce,neighbors,function,case,all,data,set,tuple2,k,vv,vertices,with,neighbor,values,edges,flat,map,new,emit,one,edge,with,neighbor,per,node,k,ev,join,this,vertices,where,1,equal,to,0,with,new,project,neighbor,value,k,vv,ev,return,vertices,with,neighbor,values,group,by,0,reduce,new,apply,neighbor,reduce,function,k,vv,reduce,neighbors,function,default,throw,new,illegal,argument,exception,illegal,edge,direction
Graph -> public DataSet<Tuple2<K, VV>> reduceOnNeighbors(ReduceNeighborsFunction<VV> reduceNeighborsFunction, 			EdgeDirection direction) throws IllegalArgumentException;1454404649;Compute a reduce transformation over the neighbors' vertex values of each vertex._For each vertex, the transformation consecutively calls a_{@link ReduceNeighborsFunction} until only a single value for each vertex remains._The {@link ReduceNeighborsFunction} combines a pair of neighbor vertex values_into one new value of the same type.__@param reduceNeighborsFunction the reduce function to apply to the neighbors of each vertex._@param direction the edge direction (in-, out-, all-)_@return a Dataset of Tuple2, with one tuple per vertex._The first field of the Tuple2 is the vertex ID and the second field_is the aggregate value computed by the provided {@link ReduceNeighborsFunction}._@throws IllegalArgumentException;public DataSet<Tuple2<K, VV>> reduceOnNeighbors(ReduceNeighborsFunction<VV> reduceNeighborsFunction,_			EdgeDirection direction) throws IllegalArgumentException {_		switch (direction) {_			case IN:_				_				final DataSet<Tuple2<K, VV>> verticesWithSourceNeighborValues = edges_						.join(this.vertices).where(0).equalTo(0)_						.with(new ProjectVertexWithNeighborValueJoin<K, VV, EV>(1))_						.withForwardedFieldsFirst("f1->f0")__				return verticesWithSourceNeighborValues.groupBy(0).reduce(new ApplyNeighborReduceFunction<K, VV>(_						reduceNeighborsFunction))__			case OUT:_				_				DataSet<Tuple2<K, VV>> verticesWithTargetNeighborValues = edges_						.join(this.vertices).where(1).equalTo(0)_						.with(new ProjectVertexWithNeighborValueJoin<K, VV, EV>(0))_						.withForwardedFieldsFirst("f0")__				return verticesWithTargetNeighborValues.groupBy(0).reduce(new ApplyNeighborReduceFunction<K, VV>(_						reduceNeighborsFunction))__			case ALL:_				_				DataSet<Tuple2<K, VV>> verticesWithNeighborValues = edges_						.flatMap(new EmitOneEdgeWithNeighborPerNode<K, EV>())_						.join(this.vertices).where(1).equalTo(0)_						.with(new ProjectNeighborValue<K, VV, EV>())___				return verticesWithNeighborValues.groupBy(0).reduce(new ApplyNeighborReduceFunction<K, VV>(_						reduceNeighborsFunction))__			default:_				throw new IllegalArgumentException("Illegal edge direction")__		}_	};compute,a,reduce,transformation,over,the,neighbors,vertex,values,of,each,vertex,for,each,vertex,the,transformation,consecutively,calls,a,link,reduce,neighbors,function,until,only,a,single,value,for,each,vertex,remains,the,link,reduce,neighbors,function,combines,a,pair,of,neighbor,vertex,values,into,one,new,value,of,the,same,type,param,reduce,neighbors,function,the,reduce,function,to,apply,to,the,neighbors,of,each,vertex,param,direction,the,edge,direction,in,out,all,return,a,dataset,of,tuple2,with,one,tuple,per,vertex,the,first,field,of,the,tuple2,is,the,vertex,id,and,the,second,field,is,the,aggregate,value,computed,by,the,provided,link,reduce,neighbors,function,throws,illegal,argument,exception;public,data,set,tuple2,k,vv,reduce,on,neighbors,reduce,neighbors,function,vv,reduce,neighbors,function,edge,direction,direction,throws,illegal,argument,exception,switch,direction,case,in,final,data,set,tuple2,k,vv,vertices,with,source,neighbor,values,edges,join,this,vertices,where,0,equal,to,0,with,new,project,vertex,with,neighbor,value,join,k,vv,ev,1,with,forwarded,fields,first,f1,f0,return,vertices,with,source,neighbor,values,group,by,0,reduce,new,apply,neighbor,reduce,function,k,vv,reduce,neighbors,function,case,out,data,set,tuple2,k,vv,vertices,with,target,neighbor,values,edges,join,this,vertices,where,1,equal,to,0,with,new,project,vertex,with,neighbor,value,join,k,vv,ev,0,with,forwarded,fields,first,f0,return,vertices,with,target,neighbor,values,group,by,0,reduce,new,apply,neighbor,reduce,function,k,vv,reduce,neighbors,function,case,all,data,set,tuple2,k,vv,vertices,with,neighbor,values,edges,flat,map,new,emit,one,edge,with,neighbor,per,node,k,ev,join,this,vertices,where,1,equal,to,0,with,new,project,neighbor,value,k,vv,ev,return,vertices,with,neighbor,values,group,by,0,reduce,new,apply,neighbor,reduce,function,k,vv,reduce,neighbors,function,default,throw,new,illegal,argument,exception,illegal,edge,direction
Graph -> public DataSet<Tuple2<K, VV>> reduceOnNeighbors(ReduceNeighborsFunction<VV> reduceNeighborsFunction, 			EdgeDirection direction) throws IllegalArgumentException;1458583829;Compute a reduce transformation over the neighbors' vertex values of each vertex._For each vertex, the transformation consecutively calls a_{@link ReduceNeighborsFunction} until only a single value for each vertex remains._The {@link ReduceNeighborsFunction} combines a pair of neighbor vertex values_into one new value of the same type.__@param reduceNeighborsFunction the reduce function to apply to the neighbors of each vertex._@param direction the edge direction (in-, out-, all-)_@return a Dataset of Tuple2, with one tuple per vertex._The first field of the Tuple2 is the vertex ID and the second field_is the aggregate value computed by the provided {@link ReduceNeighborsFunction}._@throws IllegalArgumentException;public DataSet<Tuple2<K, VV>> reduceOnNeighbors(ReduceNeighborsFunction<VV> reduceNeighborsFunction,_			EdgeDirection direction) throws IllegalArgumentException {_		switch (direction) {_			case IN:_				_				final DataSet<Tuple2<K, VV>> verticesWithSourceNeighborValues = edges_						.join(this.vertices).where(0).equalTo(0)_						.with(new ProjectVertexWithNeighborValueJoin<K, VV, EV>(1))_						.withForwardedFieldsFirst("f1->f0")__				return verticesWithSourceNeighborValues.groupBy(0).reduce(new ApplyNeighborReduceFunction<K, VV>(_						reduceNeighborsFunction))__			case OUT:_				_				DataSet<Tuple2<K, VV>> verticesWithTargetNeighborValues = edges_						.join(this.vertices).where(1).equalTo(0)_						.with(new ProjectVertexWithNeighborValueJoin<K, VV, EV>(0))_						.withForwardedFieldsFirst("f0")__				return verticesWithTargetNeighborValues.groupBy(0).reduce(new ApplyNeighborReduceFunction<K, VV>(_						reduceNeighborsFunction))__			case ALL:_				_				DataSet<Tuple2<K, VV>> verticesWithNeighborValues = edges_						.flatMap(new EmitOneEdgeWithNeighborPerNode<K, EV>())_						.join(this.vertices).where(1).equalTo(0)_						.with(new ProjectNeighborValue<K, VV, EV>())___				return verticesWithNeighborValues.groupBy(0).reduce(new ApplyNeighborReduceFunction<K, VV>(_						reduceNeighborsFunction))__			default:_				throw new IllegalArgumentException("Illegal edge direction")__		}_	};compute,a,reduce,transformation,over,the,neighbors,vertex,values,of,each,vertex,for,each,vertex,the,transformation,consecutively,calls,a,link,reduce,neighbors,function,until,only,a,single,value,for,each,vertex,remains,the,link,reduce,neighbors,function,combines,a,pair,of,neighbor,vertex,values,into,one,new,value,of,the,same,type,param,reduce,neighbors,function,the,reduce,function,to,apply,to,the,neighbors,of,each,vertex,param,direction,the,edge,direction,in,out,all,return,a,dataset,of,tuple2,with,one,tuple,per,vertex,the,first,field,of,the,tuple2,is,the,vertex,id,and,the,second,field,is,the,aggregate,value,computed,by,the,provided,link,reduce,neighbors,function,throws,illegal,argument,exception;public,data,set,tuple2,k,vv,reduce,on,neighbors,reduce,neighbors,function,vv,reduce,neighbors,function,edge,direction,direction,throws,illegal,argument,exception,switch,direction,case,in,final,data,set,tuple2,k,vv,vertices,with,source,neighbor,values,edges,join,this,vertices,where,0,equal,to,0,with,new,project,vertex,with,neighbor,value,join,k,vv,ev,1,with,forwarded,fields,first,f1,f0,return,vertices,with,source,neighbor,values,group,by,0,reduce,new,apply,neighbor,reduce,function,k,vv,reduce,neighbors,function,case,out,data,set,tuple2,k,vv,vertices,with,target,neighbor,values,edges,join,this,vertices,where,1,equal,to,0,with,new,project,vertex,with,neighbor,value,join,k,vv,ev,0,with,forwarded,fields,first,f0,return,vertices,with,target,neighbor,values,group,by,0,reduce,new,apply,neighbor,reduce,function,k,vv,reduce,neighbors,function,case,all,data,set,tuple2,k,vv,vertices,with,neighbor,values,edges,flat,map,new,emit,one,edge,with,neighbor,per,node,k,ev,join,this,vertices,where,1,equal,to,0,with,new,project,neighbor,value,k,vv,ev,return,vertices,with,neighbor,values,group,by,0,reduce,new,apply,neighbor,reduce,function,k,vv,reduce,neighbors,function,default,throw,new,illegal,argument,exception,illegal,edge,direction
Graph -> public DataSet<Tuple2<K, VV>> reduceOnNeighbors(ReduceNeighborsFunction<VV> reduceNeighborsFunction, 			EdgeDirection direction) throws IllegalArgumentException;1458583829;Compute a reduce transformation over the neighbors' vertex values of each vertex._For each vertex, the transformation consecutively calls a_{@link ReduceNeighborsFunction} until only a single value for each vertex remains._The {@link ReduceNeighborsFunction} combines a pair of neighbor vertex values_into one new value of the same type.__@param reduceNeighborsFunction the reduce function to apply to the neighbors of each vertex._@param direction the edge direction (in-, out-, all-)_@return a Dataset of Tuple2, with one tuple per vertex._The first field of the Tuple2 is the vertex ID and the second field_is the aggregate value computed by the provided {@link ReduceNeighborsFunction}._@throws IllegalArgumentException;public DataSet<Tuple2<K, VV>> reduceOnNeighbors(ReduceNeighborsFunction<VV> reduceNeighborsFunction,_			EdgeDirection direction) throws IllegalArgumentException {_		switch (direction) {_			case IN:_				_				final DataSet<Tuple2<K, VV>> verticesWithSourceNeighborValues = edges_						.join(this.vertices).where(0).equalTo(0)_						.with(new ProjectVertexWithNeighborValueJoin<K, VV, EV>(1))_						.withForwardedFieldsFirst("f1->f0")__				return verticesWithSourceNeighborValues.groupBy(0).reduce(new ApplyNeighborReduceFunction<K, VV>(_						reduceNeighborsFunction))__			case OUT:_				_				DataSet<Tuple2<K, VV>> verticesWithTargetNeighborValues = edges_						.join(this.vertices).where(1).equalTo(0)_						.with(new ProjectVertexWithNeighborValueJoin<K, VV, EV>(0))_						.withForwardedFieldsFirst("f0")__				return verticesWithTargetNeighborValues.groupBy(0).reduce(new ApplyNeighborReduceFunction<K, VV>(_						reduceNeighborsFunction))__			case ALL:_				_				DataSet<Tuple2<K, VV>> verticesWithNeighborValues = edges_						.flatMap(new EmitOneEdgeWithNeighborPerNode<K, EV>())_						.join(this.vertices).where(1).equalTo(0)_						.with(new ProjectNeighborValue<K, VV, EV>())___				return verticesWithNeighborValues.groupBy(0).reduce(new ApplyNeighborReduceFunction<K, VV>(_						reduceNeighborsFunction))__			default:_				throw new IllegalArgumentException("Illegal edge direction")__		}_	};compute,a,reduce,transformation,over,the,neighbors,vertex,values,of,each,vertex,for,each,vertex,the,transformation,consecutively,calls,a,link,reduce,neighbors,function,until,only,a,single,value,for,each,vertex,remains,the,link,reduce,neighbors,function,combines,a,pair,of,neighbor,vertex,values,into,one,new,value,of,the,same,type,param,reduce,neighbors,function,the,reduce,function,to,apply,to,the,neighbors,of,each,vertex,param,direction,the,edge,direction,in,out,all,return,a,dataset,of,tuple2,with,one,tuple,per,vertex,the,first,field,of,the,tuple2,is,the,vertex,id,and,the,second,field,is,the,aggregate,value,computed,by,the,provided,link,reduce,neighbors,function,throws,illegal,argument,exception;public,data,set,tuple2,k,vv,reduce,on,neighbors,reduce,neighbors,function,vv,reduce,neighbors,function,edge,direction,direction,throws,illegal,argument,exception,switch,direction,case,in,final,data,set,tuple2,k,vv,vertices,with,source,neighbor,values,edges,join,this,vertices,where,0,equal,to,0,with,new,project,vertex,with,neighbor,value,join,k,vv,ev,1,with,forwarded,fields,first,f1,f0,return,vertices,with,source,neighbor,values,group,by,0,reduce,new,apply,neighbor,reduce,function,k,vv,reduce,neighbors,function,case,out,data,set,tuple2,k,vv,vertices,with,target,neighbor,values,edges,join,this,vertices,where,1,equal,to,0,with,new,project,vertex,with,neighbor,value,join,k,vv,ev,0,with,forwarded,fields,first,f0,return,vertices,with,target,neighbor,values,group,by,0,reduce,new,apply,neighbor,reduce,function,k,vv,reduce,neighbors,function,case,all,data,set,tuple2,k,vv,vertices,with,neighbor,values,edges,flat,map,new,emit,one,edge,with,neighbor,per,node,k,ev,join,this,vertices,where,1,equal,to,0,with,new,project,neighbor,value,k,vv,ev,return,vertices,with,neighbor,values,group,by,0,reduce,new,apply,neighbor,reduce,function,k,vv,reduce,neighbors,function,default,throw,new,illegal,argument,exception,illegal,edge,direction
Graph -> public DataSet<Tuple2<K, VV>> reduceOnNeighbors(ReduceNeighborsFunction<VV> reduceNeighborsFunction, 			EdgeDirection direction) throws IllegalArgumentException;1462100316;Compute a reduce transformation over the neighbors' vertex values of each vertex._For each vertex, the transformation consecutively calls a_{@link ReduceNeighborsFunction} until only a single value for each vertex remains._The {@link ReduceNeighborsFunction} combines a pair of neighbor vertex values_into one new value of the same type.__@param reduceNeighborsFunction the reduce function to apply to the neighbors of each vertex._@param direction the edge direction (in-, out-, all-)_@return a Dataset of Tuple2, with one tuple per vertex._The first field of the Tuple2 is the vertex ID and the second field_is the aggregate value computed by the provided {@link ReduceNeighborsFunction}._@throws IllegalArgumentException;public DataSet<Tuple2<K, VV>> reduceOnNeighbors(ReduceNeighborsFunction<VV> reduceNeighborsFunction,_			EdgeDirection direction) throws IllegalArgumentException {_		switch (direction) {_			case IN:_				_				final DataSet<Tuple2<K, VV>> verticesWithSourceNeighborValues = edges_						.join(this.vertices).where(0).equalTo(0)_						.with(new ProjectVertexWithNeighborValueJoin<K, VV, EV>(1))_						.withForwardedFieldsFirst("f1->f0")__				return verticesWithSourceNeighborValues.groupBy(0).reduce(new ApplyNeighborReduceFunction<K, VV>(_						reduceNeighborsFunction))__			case OUT:_				_				DataSet<Tuple2<K, VV>> verticesWithTargetNeighborValues = edges_						.join(this.vertices).where(1).equalTo(0)_						.with(new ProjectVertexWithNeighborValueJoin<K, VV, EV>(0))_						.withForwardedFieldsFirst("f0")__				return verticesWithTargetNeighborValues.groupBy(0).reduce(new ApplyNeighborReduceFunction<K, VV>(_						reduceNeighborsFunction))__			case ALL:_				_				DataSet<Tuple2<K, VV>> verticesWithNeighborValues = edges_						.flatMap(new EmitOneEdgeWithNeighborPerNode<K, EV>())_						.join(this.vertices).where(1).equalTo(0)_						.with(new ProjectNeighborValue<K, VV, EV>())___				return verticesWithNeighborValues.groupBy(0).reduce(new ApplyNeighborReduceFunction<K, VV>(_						reduceNeighborsFunction))__			default:_				throw new IllegalArgumentException("Illegal edge direction")__		}_	};compute,a,reduce,transformation,over,the,neighbors,vertex,values,of,each,vertex,for,each,vertex,the,transformation,consecutively,calls,a,link,reduce,neighbors,function,until,only,a,single,value,for,each,vertex,remains,the,link,reduce,neighbors,function,combines,a,pair,of,neighbor,vertex,values,into,one,new,value,of,the,same,type,param,reduce,neighbors,function,the,reduce,function,to,apply,to,the,neighbors,of,each,vertex,param,direction,the,edge,direction,in,out,all,return,a,dataset,of,tuple2,with,one,tuple,per,vertex,the,first,field,of,the,tuple2,is,the,vertex,id,and,the,second,field,is,the,aggregate,value,computed,by,the,provided,link,reduce,neighbors,function,throws,illegal,argument,exception;public,data,set,tuple2,k,vv,reduce,on,neighbors,reduce,neighbors,function,vv,reduce,neighbors,function,edge,direction,direction,throws,illegal,argument,exception,switch,direction,case,in,final,data,set,tuple2,k,vv,vertices,with,source,neighbor,values,edges,join,this,vertices,where,0,equal,to,0,with,new,project,vertex,with,neighbor,value,join,k,vv,ev,1,with,forwarded,fields,first,f1,f0,return,vertices,with,source,neighbor,values,group,by,0,reduce,new,apply,neighbor,reduce,function,k,vv,reduce,neighbors,function,case,out,data,set,tuple2,k,vv,vertices,with,target,neighbor,values,edges,join,this,vertices,where,1,equal,to,0,with,new,project,vertex,with,neighbor,value,join,k,vv,ev,0,with,forwarded,fields,first,f0,return,vertices,with,target,neighbor,values,group,by,0,reduce,new,apply,neighbor,reduce,function,k,vv,reduce,neighbors,function,case,all,data,set,tuple2,k,vv,vertices,with,neighbor,values,edges,flat,map,new,emit,one,edge,with,neighbor,per,node,k,ev,join,this,vertices,where,1,equal,to,0,with,new,project,neighbor,value,k,vv,ev,return,vertices,with,neighbor,values,group,by,0,reduce,new,apply,neighbor,reduce,function,k,vv,reduce,neighbors,function,default,throw,new,illegal,argument,exception,illegal,edge,direction
Graph -> public DataSet<Tuple2<K, VV>> reduceOnNeighbors(ReduceNeighborsFunction<VV> reduceNeighborsFunction, 			EdgeDirection direction) throws IllegalArgumentException;1462100316;Compute a reduce transformation over the neighbors' vertex values of each vertex._For each vertex, the transformation consecutively calls a_{@link ReduceNeighborsFunction} until only a single value for each vertex remains._The {@link ReduceNeighborsFunction} combines a pair of neighbor vertex values_into one new value of the same type.__@param reduceNeighborsFunction the reduce function to apply to the neighbors of each vertex._@param direction the edge direction (in-, out-, all-)_@return a Dataset of Tuple2, with one tuple per vertex._The first field of the Tuple2 is the vertex ID and the second field_is the aggregate value computed by the provided {@link ReduceNeighborsFunction}._@throws IllegalArgumentException;public DataSet<Tuple2<K, VV>> reduceOnNeighbors(ReduceNeighborsFunction<VV> reduceNeighborsFunction,_			EdgeDirection direction) throws IllegalArgumentException {_		switch (direction) {_			case IN:_				_				final DataSet<Tuple2<K, VV>> verticesWithSourceNeighborValues = edges_						.join(this.vertices).where(0).equalTo(0)_						.with(new ProjectVertexWithNeighborValueJoin<K, VV, EV>(1))_						.withForwardedFieldsFirst("f1->f0")__				return verticesWithSourceNeighborValues.groupBy(0).reduce(new ApplyNeighborReduceFunction<K, VV>(_						reduceNeighborsFunction))__			case OUT:_				_				DataSet<Tuple2<K, VV>> verticesWithTargetNeighborValues = edges_						.join(this.vertices).where(1).equalTo(0)_						.with(new ProjectVertexWithNeighborValueJoin<K, VV, EV>(0))_						.withForwardedFieldsFirst("f0")__				return verticesWithTargetNeighborValues.groupBy(0).reduce(new ApplyNeighborReduceFunction<K, VV>(_						reduceNeighborsFunction))__			case ALL:_				_				DataSet<Tuple2<K, VV>> verticesWithNeighborValues = edges_						.flatMap(new EmitOneEdgeWithNeighborPerNode<K, EV>())_						.join(this.vertices).where(1).equalTo(0)_						.with(new ProjectNeighborValue<K, VV, EV>())___				return verticesWithNeighborValues.groupBy(0).reduce(new ApplyNeighborReduceFunction<K, VV>(_						reduceNeighborsFunction))__			default:_				throw new IllegalArgumentException("Illegal edge direction")__		}_	};compute,a,reduce,transformation,over,the,neighbors,vertex,values,of,each,vertex,for,each,vertex,the,transformation,consecutively,calls,a,link,reduce,neighbors,function,until,only,a,single,value,for,each,vertex,remains,the,link,reduce,neighbors,function,combines,a,pair,of,neighbor,vertex,values,into,one,new,value,of,the,same,type,param,reduce,neighbors,function,the,reduce,function,to,apply,to,the,neighbors,of,each,vertex,param,direction,the,edge,direction,in,out,all,return,a,dataset,of,tuple2,with,one,tuple,per,vertex,the,first,field,of,the,tuple2,is,the,vertex,id,and,the,second,field,is,the,aggregate,value,computed,by,the,provided,link,reduce,neighbors,function,throws,illegal,argument,exception;public,data,set,tuple2,k,vv,reduce,on,neighbors,reduce,neighbors,function,vv,reduce,neighbors,function,edge,direction,direction,throws,illegal,argument,exception,switch,direction,case,in,final,data,set,tuple2,k,vv,vertices,with,source,neighbor,values,edges,join,this,vertices,where,0,equal,to,0,with,new,project,vertex,with,neighbor,value,join,k,vv,ev,1,with,forwarded,fields,first,f1,f0,return,vertices,with,source,neighbor,values,group,by,0,reduce,new,apply,neighbor,reduce,function,k,vv,reduce,neighbors,function,case,out,data,set,tuple2,k,vv,vertices,with,target,neighbor,values,edges,join,this,vertices,where,1,equal,to,0,with,new,project,vertex,with,neighbor,value,join,k,vv,ev,0,with,forwarded,fields,first,f0,return,vertices,with,target,neighbor,values,group,by,0,reduce,new,apply,neighbor,reduce,function,k,vv,reduce,neighbors,function,case,all,data,set,tuple2,k,vv,vertices,with,neighbor,values,edges,flat,map,new,emit,one,edge,with,neighbor,per,node,k,ev,join,this,vertices,where,1,equal,to,0,with,new,project,neighbor,value,k,vv,ev,return,vertices,with,neighbor,values,group,by,0,reduce,new,apply,neighbor,reduce,function,k,vv,reduce,neighbors,function,default,throw,new,illegal,argument,exception,illegal,edge,direction
Graph -> public DataSet<Tuple2<K, VV>> reduceOnNeighbors(ReduceNeighborsFunction<VV> reduceNeighborsFunction, 			EdgeDirection direction) throws IllegalArgumentException;1462205213;Compute a reduce transformation over the neighbors' vertex values of each vertex._For each vertex, the transformation consecutively calls a_{@link ReduceNeighborsFunction} until only a single value for each vertex remains._The {@link ReduceNeighborsFunction} combines a pair of neighbor vertex values_into one new value of the same type.__@param reduceNeighborsFunction the reduce function to apply to the neighbors of each vertex._@param direction the edge direction (in-, out-, all-)_@return a Dataset of Tuple2, with one tuple per vertex._The first field of the Tuple2 is the vertex ID and the second field_is the aggregate value computed by the provided {@link ReduceNeighborsFunction}._@throws IllegalArgumentException;public DataSet<Tuple2<K, VV>> reduceOnNeighbors(ReduceNeighborsFunction<VV> reduceNeighborsFunction,_			EdgeDirection direction) throws IllegalArgumentException {_		switch (direction) {_			case IN:_				_				final DataSet<Tuple2<K, VV>> verticesWithSourceNeighborValues = edges_						.join(this.vertices).where(0).equalTo(0)_						.with(new ProjectVertexWithNeighborValueJoin<K, VV, EV>(1))_						.withForwardedFieldsFirst("f1->f0")__				return verticesWithSourceNeighborValues.groupBy(0).reduce(new ApplyNeighborReduceFunction<K, VV>(_						reduceNeighborsFunction))__			case OUT:_				_				DataSet<Tuple2<K, VV>> verticesWithTargetNeighborValues = edges_						.join(this.vertices).where(1).equalTo(0)_						.with(new ProjectVertexWithNeighborValueJoin<K, VV, EV>(0))_						.withForwardedFieldsFirst("f0")__				return verticesWithTargetNeighborValues.groupBy(0).reduce(new ApplyNeighborReduceFunction<K, VV>(_						reduceNeighborsFunction))__			case ALL:_				_				DataSet<Tuple2<K, VV>> verticesWithNeighborValues = edges_						.flatMap(new EmitOneEdgeWithNeighborPerNode<K, EV>())_						.join(this.vertices).where(1).equalTo(0)_						.with(new ProjectNeighborValue<K, VV, EV>())___				return verticesWithNeighborValues.groupBy(0).reduce(new ApplyNeighborReduceFunction<K, VV>(_						reduceNeighborsFunction))__			default:_				throw new IllegalArgumentException("Illegal edge direction")__		}_	};compute,a,reduce,transformation,over,the,neighbors,vertex,values,of,each,vertex,for,each,vertex,the,transformation,consecutively,calls,a,link,reduce,neighbors,function,until,only,a,single,value,for,each,vertex,remains,the,link,reduce,neighbors,function,combines,a,pair,of,neighbor,vertex,values,into,one,new,value,of,the,same,type,param,reduce,neighbors,function,the,reduce,function,to,apply,to,the,neighbors,of,each,vertex,param,direction,the,edge,direction,in,out,all,return,a,dataset,of,tuple2,with,one,tuple,per,vertex,the,first,field,of,the,tuple2,is,the,vertex,id,and,the,second,field,is,the,aggregate,value,computed,by,the,provided,link,reduce,neighbors,function,throws,illegal,argument,exception;public,data,set,tuple2,k,vv,reduce,on,neighbors,reduce,neighbors,function,vv,reduce,neighbors,function,edge,direction,direction,throws,illegal,argument,exception,switch,direction,case,in,final,data,set,tuple2,k,vv,vertices,with,source,neighbor,values,edges,join,this,vertices,where,0,equal,to,0,with,new,project,vertex,with,neighbor,value,join,k,vv,ev,1,with,forwarded,fields,first,f1,f0,return,vertices,with,source,neighbor,values,group,by,0,reduce,new,apply,neighbor,reduce,function,k,vv,reduce,neighbors,function,case,out,data,set,tuple2,k,vv,vertices,with,target,neighbor,values,edges,join,this,vertices,where,1,equal,to,0,with,new,project,vertex,with,neighbor,value,join,k,vv,ev,0,with,forwarded,fields,first,f0,return,vertices,with,target,neighbor,values,group,by,0,reduce,new,apply,neighbor,reduce,function,k,vv,reduce,neighbors,function,case,all,data,set,tuple2,k,vv,vertices,with,neighbor,values,edges,flat,map,new,emit,one,edge,with,neighbor,per,node,k,ev,join,this,vertices,where,1,equal,to,0,with,new,project,neighbor,value,k,vv,ev,return,vertices,with,neighbor,values,group,by,0,reduce,new,apply,neighbor,reduce,function,k,vv,reduce,neighbors,function,default,throw,new,illegal,argument,exception,illegal,edge,direction
Graph -> public DataSet<Tuple2<K, VV>> reduceOnNeighbors(ReduceNeighborsFunction<VV> reduceNeighborsFunction, 			EdgeDirection direction) throws IllegalArgumentException;1462208859;Compute a reduce transformation over the neighbors' vertex values of each vertex._For each vertex, the transformation consecutively calls a_{@link ReduceNeighborsFunction} until only a single value for each vertex remains._The {@link ReduceNeighborsFunction} combines a pair of neighbor vertex values_into one new value of the same type.__@param reduceNeighborsFunction the reduce function to apply to the neighbors of each vertex._@param direction the edge direction (in-, out-, all-)_@return a Dataset of Tuple2, with one tuple per vertex._The first field of the Tuple2 is the vertex ID and the second field_is the aggregate value computed by the provided {@link ReduceNeighborsFunction}._@throws IllegalArgumentException;public DataSet<Tuple2<K, VV>> reduceOnNeighbors(ReduceNeighborsFunction<VV> reduceNeighborsFunction,_			EdgeDirection direction) throws IllegalArgumentException {_		switch (direction) {_			case IN:_				_				final DataSet<Tuple2<K, VV>> verticesWithSourceNeighborValues = edges_						.join(this.vertices).where(0).equalTo(0)_						.with(new ProjectVertexWithNeighborValueJoin<K, VV, EV>(1))_						.withForwardedFieldsFirst("f1->f0")__				return verticesWithSourceNeighborValues.groupBy(0).reduce(new ApplyNeighborReduceFunction<K, VV>(_						reduceNeighborsFunction))__			case OUT:_				_				DataSet<Tuple2<K, VV>> verticesWithTargetNeighborValues = edges_						.join(this.vertices).where(1).equalTo(0)_						.with(new ProjectVertexWithNeighborValueJoin<K, VV, EV>(0))_						.withForwardedFieldsFirst("f0")__				return verticesWithTargetNeighborValues.groupBy(0).reduce(new ApplyNeighborReduceFunction<K, VV>(_						reduceNeighborsFunction))__			case ALL:_				_				DataSet<Tuple2<K, VV>> verticesWithNeighborValues = edges_						.flatMap(new EmitOneEdgeWithNeighborPerNode<K, EV>())_						.join(this.vertices).where(1).equalTo(0)_						.with(new ProjectNeighborValue<K, VV, EV>())___				return verticesWithNeighborValues.groupBy(0).reduce(new ApplyNeighborReduceFunction<K, VV>(_						reduceNeighborsFunction))__			default:_				throw new IllegalArgumentException("Illegal edge direction")__		}_	};compute,a,reduce,transformation,over,the,neighbors,vertex,values,of,each,vertex,for,each,vertex,the,transformation,consecutively,calls,a,link,reduce,neighbors,function,until,only,a,single,value,for,each,vertex,remains,the,link,reduce,neighbors,function,combines,a,pair,of,neighbor,vertex,values,into,one,new,value,of,the,same,type,param,reduce,neighbors,function,the,reduce,function,to,apply,to,the,neighbors,of,each,vertex,param,direction,the,edge,direction,in,out,all,return,a,dataset,of,tuple2,with,one,tuple,per,vertex,the,first,field,of,the,tuple2,is,the,vertex,id,and,the,second,field,is,the,aggregate,value,computed,by,the,provided,link,reduce,neighbors,function,throws,illegal,argument,exception;public,data,set,tuple2,k,vv,reduce,on,neighbors,reduce,neighbors,function,vv,reduce,neighbors,function,edge,direction,direction,throws,illegal,argument,exception,switch,direction,case,in,final,data,set,tuple2,k,vv,vertices,with,source,neighbor,values,edges,join,this,vertices,where,0,equal,to,0,with,new,project,vertex,with,neighbor,value,join,k,vv,ev,1,with,forwarded,fields,first,f1,f0,return,vertices,with,source,neighbor,values,group,by,0,reduce,new,apply,neighbor,reduce,function,k,vv,reduce,neighbors,function,case,out,data,set,tuple2,k,vv,vertices,with,target,neighbor,values,edges,join,this,vertices,where,1,equal,to,0,with,new,project,vertex,with,neighbor,value,join,k,vv,ev,0,with,forwarded,fields,first,f0,return,vertices,with,target,neighbor,values,group,by,0,reduce,new,apply,neighbor,reduce,function,k,vv,reduce,neighbors,function,case,all,data,set,tuple2,k,vv,vertices,with,neighbor,values,edges,flat,map,new,emit,one,edge,with,neighbor,per,node,k,ev,join,this,vertices,where,1,equal,to,0,with,new,project,neighbor,value,k,vv,ev,return,vertices,with,neighbor,values,group,by,0,reduce,new,apply,neighbor,reduce,function,k,vv,reduce,neighbors,function,default,throw,new,illegal,argument,exception,illegal,edge,direction
Graph -> public DataSet<Tuple2<K, VV>> reduceOnNeighbors(ReduceNeighborsFunction<VV> reduceNeighborsFunction, 			EdgeDirection direction) throws IllegalArgumentException;1462809297;Compute a reduce transformation over the neighbors' vertex values of each vertex._For each vertex, the transformation consecutively calls a_{@link ReduceNeighborsFunction} until only a single value for each vertex remains._The {@link ReduceNeighborsFunction} combines a pair of neighbor vertex values_into one new value of the same type.__@param reduceNeighborsFunction the reduce function to apply to the neighbors of each vertex._@param direction the edge direction (in-, out-, all-)_@return a Dataset of Tuple2, with one tuple per vertex._The first field of the Tuple2 is the vertex ID and the second field_is the aggregate value computed by the provided {@link ReduceNeighborsFunction}._@throws IllegalArgumentException;public DataSet<Tuple2<K, VV>> reduceOnNeighbors(ReduceNeighborsFunction<VV> reduceNeighborsFunction,_			EdgeDirection direction) throws IllegalArgumentException {_		switch (direction) {_			case IN:_				_				final DataSet<Tuple2<K, VV>> verticesWithSourceNeighborValues = edges_						.join(this.vertices).where(0).equalTo(0)_						.with(new ProjectVertexWithNeighborValueJoin<K, VV, EV>(1))_						.withForwardedFieldsFirst("f1->f0")__				return verticesWithSourceNeighborValues.groupBy(0).reduce(new ApplyNeighborReduceFunction<K, VV>(_						reduceNeighborsFunction))__			case OUT:_				_				DataSet<Tuple2<K, VV>> verticesWithTargetNeighborValues = edges_						.join(this.vertices).where(1).equalTo(0)_						.with(new ProjectVertexWithNeighborValueJoin<K, VV, EV>(0))_						.withForwardedFieldsFirst("f0")__				return verticesWithTargetNeighborValues.groupBy(0).reduce(new ApplyNeighborReduceFunction<K, VV>(_						reduceNeighborsFunction))__			case ALL:_				_				DataSet<Tuple2<K, VV>> verticesWithNeighborValues = edges_						.flatMap(new EmitOneEdgeWithNeighborPerNode<K, EV>())_						.join(this.vertices).where(1).equalTo(0)_						.with(new ProjectNeighborValue<K, VV, EV>())___				return verticesWithNeighborValues.groupBy(0).reduce(new ApplyNeighborReduceFunction<K, VV>(_						reduceNeighborsFunction))__			default:_				throw new IllegalArgumentException("Illegal edge direction")__		}_	};compute,a,reduce,transformation,over,the,neighbors,vertex,values,of,each,vertex,for,each,vertex,the,transformation,consecutively,calls,a,link,reduce,neighbors,function,until,only,a,single,value,for,each,vertex,remains,the,link,reduce,neighbors,function,combines,a,pair,of,neighbor,vertex,values,into,one,new,value,of,the,same,type,param,reduce,neighbors,function,the,reduce,function,to,apply,to,the,neighbors,of,each,vertex,param,direction,the,edge,direction,in,out,all,return,a,dataset,of,tuple2,with,one,tuple,per,vertex,the,first,field,of,the,tuple2,is,the,vertex,id,and,the,second,field,is,the,aggregate,value,computed,by,the,provided,link,reduce,neighbors,function,throws,illegal,argument,exception;public,data,set,tuple2,k,vv,reduce,on,neighbors,reduce,neighbors,function,vv,reduce,neighbors,function,edge,direction,direction,throws,illegal,argument,exception,switch,direction,case,in,final,data,set,tuple2,k,vv,vertices,with,source,neighbor,values,edges,join,this,vertices,where,0,equal,to,0,with,new,project,vertex,with,neighbor,value,join,k,vv,ev,1,with,forwarded,fields,first,f1,f0,return,vertices,with,source,neighbor,values,group,by,0,reduce,new,apply,neighbor,reduce,function,k,vv,reduce,neighbors,function,case,out,data,set,tuple2,k,vv,vertices,with,target,neighbor,values,edges,join,this,vertices,where,1,equal,to,0,with,new,project,vertex,with,neighbor,value,join,k,vv,ev,0,with,forwarded,fields,first,f0,return,vertices,with,target,neighbor,values,group,by,0,reduce,new,apply,neighbor,reduce,function,k,vv,reduce,neighbors,function,case,all,data,set,tuple2,k,vv,vertices,with,neighbor,values,edges,flat,map,new,emit,one,edge,with,neighbor,per,node,k,ev,join,this,vertices,where,1,equal,to,0,with,new,project,neighbor,value,k,vv,ev,return,vertices,with,neighbor,values,group,by,0,reduce,new,apply,neighbor,reduce,function,k,vv,reduce,neighbors,function,default,throw,new,illegal,argument,exception,illegal,edge,direction
Graph -> public DataSet<Tuple2<K, VV>> reduceOnNeighbors(ReduceNeighborsFunction<VV> reduceNeighborsFunction, 			EdgeDirection direction) throws IllegalArgumentException;1465316775;Compute a reduce transformation over the neighbors' vertex values of each vertex._For each vertex, the transformation consecutively calls a_{@link ReduceNeighborsFunction} until only a single value for each vertex remains._The {@link ReduceNeighborsFunction} combines a pair of neighbor vertex values_into one new value of the same type.__@param reduceNeighborsFunction the reduce function to apply to the neighbors of each vertex._@param direction the edge direction (in-, out-, all-)_@return a Dataset of Tuple2, with one tuple per vertex._The first field of the Tuple2 is the vertex ID and the second field_is the aggregate value computed by the provided {@link ReduceNeighborsFunction}._@throws IllegalArgumentException;public DataSet<Tuple2<K, VV>> reduceOnNeighbors(ReduceNeighborsFunction<VV> reduceNeighborsFunction,_			EdgeDirection direction) throws IllegalArgumentException {_		switch (direction) {_			case IN:_				_				final DataSet<Tuple2<K, VV>> verticesWithSourceNeighborValues = edges_						.join(this.vertices).where(0).equalTo(0)_						.with(new ProjectVertexWithNeighborValueJoin<K, VV, EV>(1))_						.withForwardedFieldsFirst("f1->f0")__				return verticesWithSourceNeighborValues.groupBy(0).reduce(new ApplyNeighborReduceFunction<K, VV>(_						reduceNeighborsFunction))__			case OUT:_				_				DataSet<Tuple2<K, VV>> verticesWithTargetNeighborValues = edges_						.join(this.vertices).where(1).equalTo(0)_						.with(new ProjectVertexWithNeighborValueJoin<K, VV, EV>(0))_						.withForwardedFieldsFirst("f0")__				return verticesWithTargetNeighborValues.groupBy(0).reduce(new ApplyNeighborReduceFunction<K, VV>(_						reduceNeighborsFunction))__			case ALL:_				_				DataSet<Tuple2<K, VV>> verticesWithNeighborValues = edges_						.flatMap(new EmitOneEdgeWithNeighborPerNode<K, EV>())_						.join(this.vertices).where(1).equalTo(0)_						.with(new ProjectNeighborValue<K, VV, EV>())___				return verticesWithNeighborValues.groupBy(0).reduce(new ApplyNeighborReduceFunction<K, VV>(_						reduceNeighborsFunction))__			default:_				throw new IllegalArgumentException("Illegal edge direction")__		}_	};compute,a,reduce,transformation,over,the,neighbors,vertex,values,of,each,vertex,for,each,vertex,the,transformation,consecutively,calls,a,link,reduce,neighbors,function,until,only,a,single,value,for,each,vertex,remains,the,link,reduce,neighbors,function,combines,a,pair,of,neighbor,vertex,values,into,one,new,value,of,the,same,type,param,reduce,neighbors,function,the,reduce,function,to,apply,to,the,neighbors,of,each,vertex,param,direction,the,edge,direction,in,out,all,return,a,dataset,of,tuple2,with,one,tuple,per,vertex,the,first,field,of,the,tuple2,is,the,vertex,id,and,the,second,field,is,the,aggregate,value,computed,by,the,provided,link,reduce,neighbors,function,throws,illegal,argument,exception;public,data,set,tuple2,k,vv,reduce,on,neighbors,reduce,neighbors,function,vv,reduce,neighbors,function,edge,direction,direction,throws,illegal,argument,exception,switch,direction,case,in,final,data,set,tuple2,k,vv,vertices,with,source,neighbor,values,edges,join,this,vertices,where,0,equal,to,0,with,new,project,vertex,with,neighbor,value,join,k,vv,ev,1,with,forwarded,fields,first,f1,f0,return,vertices,with,source,neighbor,values,group,by,0,reduce,new,apply,neighbor,reduce,function,k,vv,reduce,neighbors,function,case,out,data,set,tuple2,k,vv,vertices,with,target,neighbor,values,edges,join,this,vertices,where,1,equal,to,0,with,new,project,vertex,with,neighbor,value,join,k,vv,ev,0,with,forwarded,fields,first,f0,return,vertices,with,target,neighbor,values,group,by,0,reduce,new,apply,neighbor,reduce,function,k,vv,reduce,neighbors,function,case,all,data,set,tuple2,k,vv,vertices,with,neighbor,values,edges,flat,map,new,emit,one,edge,with,neighbor,per,node,k,ev,join,this,vertices,where,1,equal,to,0,with,new,project,neighbor,value,k,vv,ev,return,vertices,with,neighbor,values,group,by,0,reduce,new,apply,neighbor,reduce,function,k,vv,reduce,neighbors,function,default,throw,new,illegal,argument,exception,illegal,edge,direction
Graph -> public DataSet<Tuple2<K, VV>> reduceOnNeighbors(ReduceNeighborsFunction<VV> reduceNeighborsFunction, 			EdgeDirection direction) throws IllegalArgumentException;1466789678;Compute a reduce transformation over the neighbors' vertex values of each vertex._For each vertex, the transformation consecutively calls a_{@link ReduceNeighborsFunction} until only a single value for each vertex remains._The {@link ReduceNeighborsFunction} combines a pair of neighbor vertex values_into one new value of the same type.__@param reduceNeighborsFunction the reduce function to apply to the neighbors of each vertex._@param direction the edge direction (in-, out-, all-)_@return a Dataset of Tuple2, with one tuple per vertex._The first field of the Tuple2 is the vertex ID and the second field_is the aggregate value computed by the provided {@link ReduceNeighborsFunction}._@throws IllegalArgumentException;public DataSet<Tuple2<K, VV>> reduceOnNeighbors(ReduceNeighborsFunction<VV> reduceNeighborsFunction,_			EdgeDirection direction) throws IllegalArgumentException {_		switch (direction) {_			case IN:_				_				final DataSet<Tuple2<K, VV>> verticesWithSourceNeighborValues = edges_						.join(this.vertices).where(0).equalTo(0)_						.with(new ProjectVertexWithNeighborValueJoin<K, VV, EV>(1))_						.withForwardedFieldsFirst("f1->f0")__				return verticesWithSourceNeighborValues.groupBy(0).reduce(new ApplyNeighborReduceFunction<K, VV>(_						reduceNeighborsFunction))__			case OUT:_				_				DataSet<Tuple2<K, VV>> verticesWithTargetNeighborValues = edges_						.join(this.vertices).where(1).equalTo(0)_						.with(new ProjectVertexWithNeighborValueJoin<K, VV, EV>(0))_						.withForwardedFieldsFirst("f0")__				return verticesWithTargetNeighborValues.groupBy(0).reduce(new ApplyNeighborReduceFunction<K, VV>(_						reduceNeighborsFunction))__			case ALL:_				_				DataSet<Tuple2<K, VV>> verticesWithNeighborValues = edges_						.flatMap(new EmitOneEdgeWithNeighborPerNode<K, EV>())_						.join(this.vertices).where(1).equalTo(0)_						.with(new ProjectNeighborValue<K, VV, EV>())___				return verticesWithNeighborValues.groupBy(0).reduce(new ApplyNeighborReduceFunction<K, VV>(_						reduceNeighborsFunction))__			default:_				throw new IllegalArgumentException("Illegal edge direction")__		}_	};compute,a,reduce,transformation,over,the,neighbors,vertex,values,of,each,vertex,for,each,vertex,the,transformation,consecutively,calls,a,link,reduce,neighbors,function,until,only,a,single,value,for,each,vertex,remains,the,link,reduce,neighbors,function,combines,a,pair,of,neighbor,vertex,values,into,one,new,value,of,the,same,type,param,reduce,neighbors,function,the,reduce,function,to,apply,to,the,neighbors,of,each,vertex,param,direction,the,edge,direction,in,out,all,return,a,dataset,of,tuple2,with,one,tuple,per,vertex,the,first,field,of,the,tuple2,is,the,vertex,id,and,the,second,field,is,the,aggregate,value,computed,by,the,provided,link,reduce,neighbors,function,throws,illegal,argument,exception;public,data,set,tuple2,k,vv,reduce,on,neighbors,reduce,neighbors,function,vv,reduce,neighbors,function,edge,direction,direction,throws,illegal,argument,exception,switch,direction,case,in,final,data,set,tuple2,k,vv,vertices,with,source,neighbor,values,edges,join,this,vertices,where,0,equal,to,0,with,new,project,vertex,with,neighbor,value,join,k,vv,ev,1,with,forwarded,fields,first,f1,f0,return,vertices,with,source,neighbor,values,group,by,0,reduce,new,apply,neighbor,reduce,function,k,vv,reduce,neighbors,function,case,out,data,set,tuple2,k,vv,vertices,with,target,neighbor,values,edges,join,this,vertices,where,1,equal,to,0,with,new,project,vertex,with,neighbor,value,join,k,vv,ev,0,with,forwarded,fields,first,f0,return,vertices,with,target,neighbor,values,group,by,0,reduce,new,apply,neighbor,reduce,function,k,vv,reduce,neighbors,function,case,all,data,set,tuple2,k,vv,vertices,with,neighbor,values,edges,flat,map,new,emit,one,edge,with,neighbor,per,node,k,ev,join,this,vertices,where,1,equal,to,0,with,new,project,neighbor,value,k,vv,ev,return,vertices,with,neighbor,values,group,by,0,reduce,new,apply,neighbor,reduce,function,k,vv,reduce,neighbors,function,default,throw,new,illegal,argument,exception,illegal,edge,direction
Graph -> public DataSet<Tuple2<K, VV>> reduceOnNeighbors(ReduceNeighborsFunction<VV> reduceNeighborsFunction, 			EdgeDirection direction) throws IllegalArgumentException;1467140656;Compute a reduce transformation over the neighbors' vertex values of each vertex._For each vertex, the transformation consecutively calls a_{@link ReduceNeighborsFunction} until only a single value for each vertex remains._The {@link ReduceNeighborsFunction} combines a pair of neighbor vertex values_into one new value of the same type.__@param reduceNeighborsFunction the reduce function to apply to the neighbors of each vertex._@param direction the edge direction (in-, out-, all-)_@return a Dataset of Tuple2, with one tuple per vertex._The first field of the Tuple2 is the vertex ID and the second field_is the aggregate value computed by the provided {@link ReduceNeighborsFunction}._@throws IllegalArgumentException;public DataSet<Tuple2<K, VV>> reduceOnNeighbors(ReduceNeighborsFunction<VV> reduceNeighborsFunction,_			EdgeDirection direction) throws IllegalArgumentException {_		switch (direction) {_			case IN:_				_				final DataSet<Tuple2<K, VV>> verticesWithSourceNeighborValues = edges_						.join(this.vertices).where(0).equalTo(0)_						.with(new ProjectVertexWithNeighborValueJoin<K, VV, EV>(1))_						.withForwardedFieldsFirst("f1->f0")__				return verticesWithSourceNeighborValues.groupBy(0).reduce(new ApplyNeighborReduceFunction<K, VV>(_						reduceNeighborsFunction))__			case OUT:_				_				DataSet<Tuple2<K, VV>> verticesWithTargetNeighborValues = edges_						.join(this.vertices).where(1).equalTo(0)_						.with(new ProjectVertexWithNeighborValueJoin<K, VV, EV>(0))_						.withForwardedFieldsFirst("f0")__				return verticesWithTargetNeighborValues.groupBy(0).reduce(new ApplyNeighborReduceFunction<K, VV>(_						reduceNeighborsFunction))__			case ALL:_				_				DataSet<Tuple2<K, VV>> verticesWithNeighborValues = edges_						.flatMap(new EmitOneEdgeWithNeighborPerNode<K, EV>())_						.join(this.vertices).where(1).equalTo(0)_						.with(new ProjectNeighborValue<K, VV, EV>())___				return verticesWithNeighborValues.groupBy(0).reduce(new ApplyNeighborReduceFunction<K, VV>(_						reduceNeighborsFunction))__			default:_				throw new IllegalArgumentException("Illegal edge direction")__		}_	};compute,a,reduce,transformation,over,the,neighbors,vertex,values,of,each,vertex,for,each,vertex,the,transformation,consecutively,calls,a,link,reduce,neighbors,function,until,only,a,single,value,for,each,vertex,remains,the,link,reduce,neighbors,function,combines,a,pair,of,neighbor,vertex,values,into,one,new,value,of,the,same,type,param,reduce,neighbors,function,the,reduce,function,to,apply,to,the,neighbors,of,each,vertex,param,direction,the,edge,direction,in,out,all,return,a,dataset,of,tuple2,with,one,tuple,per,vertex,the,first,field,of,the,tuple2,is,the,vertex,id,and,the,second,field,is,the,aggregate,value,computed,by,the,provided,link,reduce,neighbors,function,throws,illegal,argument,exception;public,data,set,tuple2,k,vv,reduce,on,neighbors,reduce,neighbors,function,vv,reduce,neighbors,function,edge,direction,direction,throws,illegal,argument,exception,switch,direction,case,in,final,data,set,tuple2,k,vv,vertices,with,source,neighbor,values,edges,join,this,vertices,where,0,equal,to,0,with,new,project,vertex,with,neighbor,value,join,k,vv,ev,1,with,forwarded,fields,first,f1,f0,return,vertices,with,source,neighbor,values,group,by,0,reduce,new,apply,neighbor,reduce,function,k,vv,reduce,neighbors,function,case,out,data,set,tuple2,k,vv,vertices,with,target,neighbor,values,edges,join,this,vertices,where,1,equal,to,0,with,new,project,vertex,with,neighbor,value,join,k,vv,ev,0,with,forwarded,fields,first,f0,return,vertices,with,target,neighbor,values,group,by,0,reduce,new,apply,neighbor,reduce,function,k,vv,reduce,neighbors,function,case,all,data,set,tuple2,k,vv,vertices,with,neighbor,values,edges,flat,map,new,emit,one,edge,with,neighbor,per,node,k,ev,join,this,vertices,where,1,equal,to,0,with,new,project,neighbor,value,k,vv,ev,return,vertices,with,neighbor,values,group,by,0,reduce,new,apply,neighbor,reduce,function,k,vv,reduce,neighbors,function,default,throw,new,illegal,argument,exception,illegal,edge,direction
Graph -> public DataSet<Tuple2<K, VV>> reduceOnNeighbors(ReduceNeighborsFunction<VV> reduceNeighborsFunction, 			EdgeDirection direction) throws IllegalArgumentException;1467306272;Compute a reduce transformation over the neighbors' vertex values of each vertex._For each vertex, the transformation consecutively calls a_{@link ReduceNeighborsFunction} until only a single value for each vertex remains._The {@link ReduceNeighborsFunction} combines a pair of neighbor vertex values_into one new value of the same type.__@param reduceNeighborsFunction the reduce function to apply to the neighbors of each vertex._@param direction the edge direction (in-, out-, all-)_@return a Dataset of Tuple2, with one tuple per vertex._The first field of the Tuple2 is the vertex ID and the second field_is the aggregate value computed by the provided {@link ReduceNeighborsFunction}._@throws IllegalArgumentException;public DataSet<Tuple2<K, VV>> reduceOnNeighbors(ReduceNeighborsFunction<VV> reduceNeighborsFunction,_			EdgeDirection direction) throws IllegalArgumentException {_		switch (direction) {_			case IN:_				_				final DataSet<Tuple2<K, VV>> verticesWithSourceNeighborValues = edges_						.join(this.vertices).where(0).equalTo(0)_						.with(new ProjectVertexWithNeighborValueJoin<K, VV, EV>(1))_						.withForwardedFieldsFirst("f1->f0")__				return verticesWithSourceNeighborValues.groupBy(0).reduce(new ApplyNeighborReduceFunction<K, VV>(_						reduceNeighborsFunction))__			case OUT:_				_				DataSet<Tuple2<K, VV>> verticesWithTargetNeighborValues = edges_						.join(this.vertices).where(1).equalTo(0)_						.with(new ProjectVertexWithNeighborValueJoin<K, VV, EV>(0))_						.withForwardedFieldsFirst("f0")__				return verticesWithTargetNeighborValues.groupBy(0).reduce(new ApplyNeighborReduceFunction<K, VV>(_						reduceNeighborsFunction))__			case ALL:_				_				DataSet<Tuple2<K, VV>> verticesWithNeighborValues = edges_						.flatMap(new EmitOneEdgeWithNeighborPerNode<K, EV>())_						.join(this.vertices).where(1).equalTo(0)_						.with(new ProjectNeighborValue<K, VV, EV>())___				return verticesWithNeighborValues.groupBy(0).reduce(new ApplyNeighborReduceFunction<K, VV>(_						reduceNeighborsFunction))__			default:_				throw new IllegalArgumentException("Illegal edge direction")__		}_	};compute,a,reduce,transformation,over,the,neighbors,vertex,values,of,each,vertex,for,each,vertex,the,transformation,consecutively,calls,a,link,reduce,neighbors,function,until,only,a,single,value,for,each,vertex,remains,the,link,reduce,neighbors,function,combines,a,pair,of,neighbor,vertex,values,into,one,new,value,of,the,same,type,param,reduce,neighbors,function,the,reduce,function,to,apply,to,the,neighbors,of,each,vertex,param,direction,the,edge,direction,in,out,all,return,a,dataset,of,tuple2,with,one,tuple,per,vertex,the,first,field,of,the,tuple2,is,the,vertex,id,and,the,second,field,is,the,aggregate,value,computed,by,the,provided,link,reduce,neighbors,function,throws,illegal,argument,exception;public,data,set,tuple2,k,vv,reduce,on,neighbors,reduce,neighbors,function,vv,reduce,neighbors,function,edge,direction,direction,throws,illegal,argument,exception,switch,direction,case,in,final,data,set,tuple2,k,vv,vertices,with,source,neighbor,values,edges,join,this,vertices,where,0,equal,to,0,with,new,project,vertex,with,neighbor,value,join,k,vv,ev,1,with,forwarded,fields,first,f1,f0,return,vertices,with,source,neighbor,values,group,by,0,reduce,new,apply,neighbor,reduce,function,k,vv,reduce,neighbors,function,case,out,data,set,tuple2,k,vv,vertices,with,target,neighbor,values,edges,join,this,vertices,where,1,equal,to,0,with,new,project,vertex,with,neighbor,value,join,k,vv,ev,0,with,forwarded,fields,first,f0,return,vertices,with,target,neighbor,values,group,by,0,reduce,new,apply,neighbor,reduce,function,k,vv,reduce,neighbors,function,case,all,data,set,tuple2,k,vv,vertices,with,neighbor,values,edges,flat,map,new,emit,one,edge,with,neighbor,per,node,k,ev,join,this,vertices,where,1,equal,to,0,with,new,project,neighbor,value,k,vv,ev,return,vertices,with,neighbor,values,group,by,0,reduce,new,apply,neighbor,reduce,function,k,vv,reduce,neighbors,function,default,throw,new,illegal,argument,exception,illegal,edge,direction
Graph -> public DataSet<Tuple2<K, VV>> reduceOnNeighbors(ReduceNeighborsFunction<VV> reduceNeighborsFunction, 			EdgeDirection direction) throws IllegalArgumentException;1470042815;Compute a reduce transformation over the neighbors' vertex values of each vertex._For each vertex, the transformation consecutively calls a_{@link ReduceNeighborsFunction} until only a single value for each vertex remains._The {@link ReduceNeighborsFunction} combines a pair of neighbor vertex values_into one new value of the same type.__@param reduceNeighborsFunction the reduce function to apply to the neighbors of each vertex._@param direction the edge direction (in-, out-, all-)_@return a Dataset of Tuple2, with one tuple per vertex._The first field of the Tuple2 is the vertex ID and the second field_is the aggregate value computed by the provided {@link ReduceNeighborsFunction}._@throws IllegalArgumentException;public DataSet<Tuple2<K, VV>> reduceOnNeighbors(ReduceNeighborsFunction<VV> reduceNeighborsFunction,_			EdgeDirection direction) throws IllegalArgumentException {_		switch (direction) {_			case IN:_				_				final DataSet<Tuple2<K, VV>> verticesWithSourceNeighborValues = edges_						.join(this.vertices).where(0).equalTo(0)_						.with(new ProjectVertexWithNeighborValueJoin<K, VV, EV>(1))_						.withForwardedFieldsFirst("f1->f0")__				return verticesWithSourceNeighborValues.groupBy(0).reduce(new ApplyNeighborReduceFunction<K, VV>(_						reduceNeighborsFunction))__			case OUT:_				_				DataSet<Tuple2<K, VV>> verticesWithTargetNeighborValues = edges_						.join(this.vertices).where(1).equalTo(0)_						.with(new ProjectVertexWithNeighborValueJoin<K, VV, EV>(0))_						.withForwardedFieldsFirst("f0")__				return verticesWithTargetNeighborValues.groupBy(0).reduce(new ApplyNeighborReduceFunction<K, VV>(_						reduceNeighborsFunction))__			case ALL:_				_				DataSet<Tuple2<K, VV>> verticesWithNeighborValues = edges_						.flatMap(new EmitOneEdgeWithNeighborPerNode<K, EV>())_						.join(this.vertices).where(1).equalTo(0)_						.with(new ProjectNeighborValue<K, VV, EV>())___				return verticesWithNeighborValues.groupBy(0).reduce(new ApplyNeighborReduceFunction<K, VV>(_						reduceNeighborsFunction))__			default:_				throw new IllegalArgumentException("Illegal edge direction")__		}_	};compute,a,reduce,transformation,over,the,neighbors,vertex,values,of,each,vertex,for,each,vertex,the,transformation,consecutively,calls,a,link,reduce,neighbors,function,until,only,a,single,value,for,each,vertex,remains,the,link,reduce,neighbors,function,combines,a,pair,of,neighbor,vertex,values,into,one,new,value,of,the,same,type,param,reduce,neighbors,function,the,reduce,function,to,apply,to,the,neighbors,of,each,vertex,param,direction,the,edge,direction,in,out,all,return,a,dataset,of,tuple2,with,one,tuple,per,vertex,the,first,field,of,the,tuple2,is,the,vertex,id,and,the,second,field,is,the,aggregate,value,computed,by,the,provided,link,reduce,neighbors,function,throws,illegal,argument,exception;public,data,set,tuple2,k,vv,reduce,on,neighbors,reduce,neighbors,function,vv,reduce,neighbors,function,edge,direction,direction,throws,illegal,argument,exception,switch,direction,case,in,final,data,set,tuple2,k,vv,vertices,with,source,neighbor,values,edges,join,this,vertices,where,0,equal,to,0,with,new,project,vertex,with,neighbor,value,join,k,vv,ev,1,with,forwarded,fields,first,f1,f0,return,vertices,with,source,neighbor,values,group,by,0,reduce,new,apply,neighbor,reduce,function,k,vv,reduce,neighbors,function,case,out,data,set,tuple2,k,vv,vertices,with,target,neighbor,values,edges,join,this,vertices,where,1,equal,to,0,with,new,project,vertex,with,neighbor,value,join,k,vv,ev,0,with,forwarded,fields,first,f0,return,vertices,with,target,neighbor,values,group,by,0,reduce,new,apply,neighbor,reduce,function,k,vv,reduce,neighbors,function,case,all,data,set,tuple2,k,vv,vertices,with,neighbor,values,edges,flat,map,new,emit,one,edge,with,neighbor,per,node,k,ev,join,this,vertices,where,1,equal,to,0,with,new,project,neighbor,value,k,vv,ev,return,vertices,with,neighbor,values,group,by,0,reduce,new,apply,neighbor,reduce,function,k,vv,reduce,neighbors,function,default,throw,new,illegal,argument,exception,illegal,edge,direction
Graph -> public DataSet<Tuple2<K, VV>> reduceOnNeighbors(ReduceNeighborsFunction<VV> reduceNeighborsFunction, 			EdgeDirection direction) throws IllegalArgumentException;1475684776;Compute a reduce transformation over the neighbors' vertex values of each vertex._For each vertex, the transformation consecutively calls a_{@link ReduceNeighborsFunction} until only a single value for each vertex remains._The {@link ReduceNeighborsFunction} combines a pair of neighbor vertex values_into one new value of the same type.__@param reduceNeighborsFunction the reduce function to apply to the neighbors of each vertex._@param direction the edge direction (in-, out-, all-)_@return a Dataset of Tuple2, with one tuple per vertex._The first field of the Tuple2 is the vertex ID and the second field_is the aggregate value computed by the provided {@link ReduceNeighborsFunction}._@throws IllegalArgumentException;public DataSet<Tuple2<K, VV>> reduceOnNeighbors(ReduceNeighborsFunction<VV> reduceNeighborsFunction,_			EdgeDirection direction) throws IllegalArgumentException {_		switch (direction) {_			case IN:_				_				final DataSet<Tuple2<K, VV>> verticesWithSourceNeighborValues = edges_						.join(this.vertices).where(0).equalTo(0)_						.with(new ProjectVertexWithNeighborValueJoin<K, VV, EV>(1))_						.withForwardedFieldsFirst("f1->f0")__				return verticesWithSourceNeighborValues.groupBy(0).reduce(new ApplyNeighborReduceFunction<K, VV>(_						reduceNeighborsFunction))__			case OUT:_				_				DataSet<Tuple2<K, VV>> verticesWithTargetNeighborValues = edges_						.join(this.vertices).where(1).equalTo(0)_						.with(new ProjectVertexWithNeighborValueJoin<K, VV, EV>(0))_						.withForwardedFieldsFirst("f0")__				return verticesWithTargetNeighborValues.groupBy(0).reduce(new ApplyNeighborReduceFunction<K, VV>(_						reduceNeighborsFunction))__			case ALL:_				_				DataSet<Tuple2<K, VV>> verticesWithNeighborValues = edges_						.flatMap(new EmitOneEdgeWithNeighborPerNode<K, EV>())_						.join(this.vertices).where(1).equalTo(0)_						.with(new ProjectNeighborValue<K, VV, EV>())___				return verticesWithNeighborValues.groupBy(0).reduce(new ApplyNeighborReduceFunction<K, VV>(_						reduceNeighborsFunction))__			default:_				throw new IllegalArgumentException("Illegal edge direction")__		}_	};compute,a,reduce,transformation,over,the,neighbors,vertex,values,of,each,vertex,for,each,vertex,the,transformation,consecutively,calls,a,link,reduce,neighbors,function,until,only,a,single,value,for,each,vertex,remains,the,link,reduce,neighbors,function,combines,a,pair,of,neighbor,vertex,values,into,one,new,value,of,the,same,type,param,reduce,neighbors,function,the,reduce,function,to,apply,to,the,neighbors,of,each,vertex,param,direction,the,edge,direction,in,out,all,return,a,dataset,of,tuple2,with,one,tuple,per,vertex,the,first,field,of,the,tuple2,is,the,vertex,id,and,the,second,field,is,the,aggregate,value,computed,by,the,provided,link,reduce,neighbors,function,throws,illegal,argument,exception;public,data,set,tuple2,k,vv,reduce,on,neighbors,reduce,neighbors,function,vv,reduce,neighbors,function,edge,direction,direction,throws,illegal,argument,exception,switch,direction,case,in,final,data,set,tuple2,k,vv,vertices,with,source,neighbor,values,edges,join,this,vertices,where,0,equal,to,0,with,new,project,vertex,with,neighbor,value,join,k,vv,ev,1,with,forwarded,fields,first,f1,f0,return,vertices,with,source,neighbor,values,group,by,0,reduce,new,apply,neighbor,reduce,function,k,vv,reduce,neighbors,function,case,out,data,set,tuple2,k,vv,vertices,with,target,neighbor,values,edges,join,this,vertices,where,1,equal,to,0,with,new,project,vertex,with,neighbor,value,join,k,vv,ev,0,with,forwarded,fields,first,f0,return,vertices,with,target,neighbor,values,group,by,0,reduce,new,apply,neighbor,reduce,function,k,vv,reduce,neighbors,function,case,all,data,set,tuple2,k,vv,vertices,with,neighbor,values,edges,flat,map,new,emit,one,edge,with,neighbor,per,node,k,ev,join,this,vertices,where,1,equal,to,0,with,new,project,neighbor,value,k,vv,ev,return,vertices,with,neighbor,values,group,by,0,reduce,new,apply,neighbor,reduce,function,k,vv,reduce,neighbors,function,default,throw,new,illegal,argument,exception,illegal,edge,direction
Graph -> public DataSet<Tuple2<K, VV>> reduceOnNeighbors(ReduceNeighborsFunction<VV> reduceNeighborsFunction, 			EdgeDirection direction) throws IllegalArgumentException;1475685606;Compute a reduce transformation over the neighbors' vertex values of each vertex._For each vertex, the transformation consecutively calls a_{@link ReduceNeighborsFunction} until only a single value for each vertex remains._The {@link ReduceNeighborsFunction} combines a pair of neighbor vertex values_into one new value of the same type.__@param reduceNeighborsFunction the reduce function to apply to the neighbors of each vertex._@param direction the edge direction (in-, out-, all-)_@return a Dataset of Tuple2, with one tuple per vertex._The first field of the Tuple2 is the vertex ID and the second field_is the aggregate value computed by the provided {@link ReduceNeighborsFunction}._@throws IllegalArgumentException;public DataSet<Tuple2<K, VV>> reduceOnNeighbors(ReduceNeighborsFunction<VV> reduceNeighborsFunction,_			EdgeDirection direction) throws IllegalArgumentException {_		switch (direction) {_			case IN:_				_				final DataSet<Tuple2<K, VV>> verticesWithSourceNeighborValues = edges_						.join(this.vertices).where(0).equalTo(0)_						.with(new ProjectVertexWithNeighborValueJoin<K, VV, EV>(1))_						.withForwardedFieldsFirst("f1->f0")__				return verticesWithSourceNeighborValues.groupBy(0).reduce(new ApplyNeighborReduceFunction<K, VV>(_						reduceNeighborsFunction))__			case OUT:_				_				DataSet<Tuple2<K, VV>> verticesWithTargetNeighborValues = edges_						.join(this.vertices).where(1).equalTo(0)_						.with(new ProjectVertexWithNeighborValueJoin<K, VV, EV>(0))_						.withForwardedFieldsFirst("f0")__				return verticesWithTargetNeighborValues.groupBy(0).reduce(new ApplyNeighborReduceFunction<K, VV>(_						reduceNeighborsFunction))__			case ALL:_				_				DataSet<Tuple2<K, VV>> verticesWithNeighborValues = edges_						.flatMap(new EmitOneEdgeWithNeighborPerNode<K, EV>())_						.join(this.vertices).where(1).equalTo(0)_						.with(new ProjectNeighborValue<K, VV, EV>())___				return verticesWithNeighborValues.groupBy(0).reduce(new ApplyNeighborReduceFunction<K, VV>(_						reduceNeighborsFunction))__			default:_				throw new IllegalArgumentException("Illegal edge direction")__		}_	};compute,a,reduce,transformation,over,the,neighbors,vertex,values,of,each,vertex,for,each,vertex,the,transformation,consecutively,calls,a,link,reduce,neighbors,function,until,only,a,single,value,for,each,vertex,remains,the,link,reduce,neighbors,function,combines,a,pair,of,neighbor,vertex,values,into,one,new,value,of,the,same,type,param,reduce,neighbors,function,the,reduce,function,to,apply,to,the,neighbors,of,each,vertex,param,direction,the,edge,direction,in,out,all,return,a,dataset,of,tuple2,with,one,tuple,per,vertex,the,first,field,of,the,tuple2,is,the,vertex,id,and,the,second,field,is,the,aggregate,value,computed,by,the,provided,link,reduce,neighbors,function,throws,illegal,argument,exception;public,data,set,tuple2,k,vv,reduce,on,neighbors,reduce,neighbors,function,vv,reduce,neighbors,function,edge,direction,direction,throws,illegal,argument,exception,switch,direction,case,in,final,data,set,tuple2,k,vv,vertices,with,source,neighbor,values,edges,join,this,vertices,where,0,equal,to,0,with,new,project,vertex,with,neighbor,value,join,k,vv,ev,1,with,forwarded,fields,first,f1,f0,return,vertices,with,source,neighbor,values,group,by,0,reduce,new,apply,neighbor,reduce,function,k,vv,reduce,neighbors,function,case,out,data,set,tuple2,k,vv,vertices,with,target,neighbor,values,edges,join,this,vertices,where,1,equal,to,0,with,new,project,vertex,with,neighbor,value,join,k,vv,ev,0,with,forwarded,fields,first,f0,return,vertices,with,target,neighbor,values,group,by,0,reduce,new,apply,neighbor,reduce,function,k,vv,reduce,neighbors,function,case,all,data,set,tuple2,k,vv,vertices,with,neighbor,values,edges,flat,map,new,emit,one,edge,with,neighbor,per,node,k,ev,join,this,vertices,where,1,equal,to,0,with,new,project,neighbor,value,k,vv,ev,return,vertices,with,neighbor,values,group,by,0,reduce,new,apply,neighbor,reduce,function,k,vv,reduce,neighbors,function,default,throw,new,illegal,argument,exception,illegal,edge,direction
Graph -> public DataSet<Tuple2<K, VV>> reduceOnNeighbors(ReduceNeighborsFunction<VV> reduceNeighborsFunction, 			EdgeDirection direction) throws IllegalArgumentException;1481745825;Compute a reduce transformation over the neighbors' vertex values of each vertex._For each vertex, the transformation consecutively calls a_{@link ReduceNeighborsFunction} until only a single value for each vertex remains._The {@link ReduceNeighborsFunction} combines a pair of neighbor vertex values_into one new value of the same type.__@param reduceNeighborsFunction the reduce function to apply to the neighbors of each vertex._@param direction the edge direction (in-, out-, all-)_@return a Dataset of Tuple2, with one tuple per vertex._The first field of the Tuple2 is the vertex ID and the second field_is the aggregate value computed by the provided {@link ReduceNeighborsFunction}._@throws IllegalArgumentException;public DataSet<Tuple2<K, VV>> reduceOnNeighbors(ReduceNeighborsFunction<VV> reduceNeighborsFunction,_			EdgeDirection direction) throws IllegalArgumentException {_		switch (direction) {_			case IN:_				_				final DataSet<Tuple2<K, VV>> verticesWithSourceNeighborValues = edges_						.join(this.vertices).where(0).equalTo(0)_						.with(new ProjectVertexWithNeighborValueJoin<K, VV, EV>(1))_						.withForwardedFieldsFirst("f1->f0").name("Vertex with in-neighbor value")__				return verticesWithSourceNeighborValues.groupBy(0).reduce(new ApplyNeighborReduceFunction<K, VV>(_						reduceNeighborsFunction)).name("Neighbors function")__			case OUT:_				_				DataSet<Tuple2<K, VV>> verticesWithTargetNeighborValues = edges_						.join(this.vertices).where(1).equalTo(0)_						.with(new ProjectVertexWithNeighborValueJoin<K, VV, EV>(0))_						.withForwardedFieldsFirst("f0").name("Vertex with out-neighbor value")__				return verticesWithTargetNeighborValues.groupBy(0).reduce(new ApplyNeighborReduceFunction<K, VV>(_						reduceNeighborsFunction)).name("Neighbors function")__			case ALL:_				_				DataSet<Tuple2<K, VV>> verticesWithNeighborValues = edges_						.flatMap(new EmitOneEdgeWithNeighborPerNode<K, EV>())_						.join(this.vertices).where(1).equalTo(0)_						.with(new ProjectNeighborValue<K, VV, EV>()).name("Vertex with neighbor value")___				return verticesWithNeighborValues.groupBy(0).reduce(new ApplyNeighborReduceFunction<K, VV>(_						reduceNeighborsFunction)).name("Neighbors function")__			default:_				throw new IllegalArgumentException("Illegal edge direction")__		}_	};compute,a,reduce,transformation,over,the,neighbors,vertex,values,of,each,vertex,for,each,vertex,the,transformation,consecutively,calls,a,link,reduce,neighbors,function,until,only,a,single,value,for,each,vertex,remains,the,link,reduce,neighbors,function,combines,a,pair,of,neighbor,vertex,values,into,one,new,value,of,the,same,type,param,reduce,neighbors,function,the,reduce,function,to,apply,to,the,neighbors,of,each,vertex,param,direction,the,edge,direction,in,out,all,return,a,dataset,of,tuple2,with,one,tuple,per,vertex,the,first,field,of,the,tuple2,is,the,vertex,id,and,the,second,field,is,the,aggregate,value,computed,by,the,provided,link,reduce,neighbors,function,throws,illegal,argument,exception;public,data,set,tuple2,k,vv,reduce,on,neighbors,reduce,neighbors,function,vv,reduce,neighbors,function,edge,direction,direction,throws,illegal,argument,exception,switch,direction,case,in,final,data,set,tuple2,k,vv,vertices,with,source,neighbor,values,edges,join,this,vertices,where,0,equal,to,0,with,new,project,vertex,with,neighbor,value,join,k,vv,ev,1,with,forwarded,fields,first,f1,f0,name,vertex,with,in,neighbor,value,return,vertices,with,source,neighbor,values,group,by,0,reduce,new,apply,neighbor,reduce,function,k,vv,reduce,neighbors,function,name,neighbors,function,case,out,data,set,tuple2,k,vv,vertices,with,target,neighbor,values,edges,join,this,vertices,where,1,equal,to,0,with,new,project,vertex,with,neighbor,value,join,k,vv,ev,0,with,forwarded,fields,first,f0,name,vertex,with,out,neighbor,value,return,vertices,with,target,neighbor,values,group,by,0,reduce,new,apply,neighbor,reduce,function,k,vv,reduce,neighbors,function,name,neighbors,function,case,all,data,set,tuple2,k,vv,vertices,with,neighbor,values,edges,flat,map,new,emit,one,edge,with,neighbor,per,node,k,ev,join,this,vertices,where,1,equal,to,0,with,new,project,neighbor,value,k,vv,ev,name,vertex,with,neighbor,value,return,vertices,with,neighbor,values,group,by,0,reduce,new,apply,neighbor,reduce,function,k,vv,reduce,neighbors,function,name,neighbors,function,default,throw,new,illegal,argument,exception,illegal,edge,direction
Graph -> public DataSet<Tuple2<K, VV>> reduceOnNeighbors(ReduceNeighborsFunction<VV> reduceNeighborsFunction, 			EdgeDirection direction) throws IllegalArgumentException;1481881009;Compute a reduce transformation over the neighbors' vertex values of each vertex._For each vertex, the transformation consecutively calls a_{@link ReduceNeighborsFunction} until only a single value for each vertex remains._The {@link ReduceNeighborsFunction} combines a pair of neighbor vertex values_into one new value of the same type.__@param reduceNeighborsFunction the reduce function to apply to the neighbors of each vertex._@param direction the edge direction (in-, out-, all-)_@return a Dataset of Tuple2, with one tuple per vertex._The first field of the Tuple2 is the vertex ID and the second field_is the aggregate value computed by the provided {@link ReduceNeighborsFunction}._@throws IllegalArgumentException;public DataSet<Tuple2<K, VV>> reduceOnNeighbors(ReduceNeighborsFunction<VV> reduceNeighborsFunction,_			EdgeDirection direction) throws IllegalArgumentException {_		switch (direction) {_			case IN:_				_				final DataSet<Tuple2<K, VV>> verticesWithSourceNeighborValues = edges_						.join(this.vertices).where(0).equalTo(0)_						.with(new ProjectVertexWithNeighborValueJoin<K, VV, EV>(1))_						.withForwardedFieldsFirst("f1->f0").name("Vertex with in-neighbor value")__				return verticesWithSourceNeighborValues.groupBy(0).reduce(new ApplyNeighborReduceFunction<K, VV>(_						reduceNeighborsFunction)).name("Neighbors function")__			case OUT:_				_				DataSet<Tuple2<K, VV>> verticesWithTargetNeighborValues = edges_						.join(this.vertices).where(1).equalTo(0)_						.with(new ProjectVertexWithNeighborValueJoin<K, VV, EV>(0))_						.withForwardedFieldsFirst("f0").name("Vertex with out-neighbor value")__				return verticesWithTargetNeighborValues.groupBy(0).reduce(new ApplyNeighborReduceFunction<K, VV>(_						reduceNeighborsFunction)).name("Neighbors function")__			case ALL:_				_				DataSet<Tuple2<K, VV>> verticesWithNeighborValues = edges_						.flatMap(new EmitOneEdgeWithNeighborPerNode<K, EV>())_						.join(this.vertices).where(1).equalTo(0)_						.with(new ProjectNeighborValue<K, VV, EV>()).name("Vertex with neighbor value")___				return verticesWithNeighborValues.groupBy(0).reduce(new ApplyNeighborReduceFunction<K, VV>(_						reduceNeighborsFunction)).name("Neighbors function")__			default:_				throw new IllegalArgumentException("Illegal edge direction")__		}_	};compute,a,reduce,transformation,over,the,neighbors,vertex,values,of,each,vertex,for,each,vertex,the,transformation,consecutively,calls,a,link,reduce,neighbors,function,until,only,a,single,value,for,each,vertex,remains,the,link,reduce,neighbors,function,combines,a,pair,of,neighbor,vertex,values,into,one,new,value,of,the,same,type,param,reduce,neighbors,function,the,reduce,function,to,apply,to,the,neighbors,of,each,vertex,param,direction,the,edge,direction,in,out,all,return,a,dataset,of,tuple2,with,one,tuple,per,vertex,the,first,field,of,the,tuple2,is,the,vertex,id,and,the,second,field,is,the,aggregate,value,computed,by,the,provided,link,reduce,neighbors,function,throws,illegal,argument,exception;public,data,set,tuple2,k,vv,reduce,on,neighbors,reduce,neighbors,function,vv,reduce,neighbors,function,edge,direction,direction,throws,illegal,argument,exception,switch,direction,case,in,final,data,set,tuple2,k,vv,vertices,with,source,neighbor,values,edges,join,this,vertices,where,0,equal,to,0,with,new,project,vertex,with,neighbor,value,join,k,vv,ev,1,with,forwarded,fields,first,f1,f0,name,vertex,with,in,neighbor,value,return,vertices,with,source,neighbor,values,group,by,0,reduce,new,apply,neighbor,reduce,function,k,vv,reduce,neighbors,function,name,neighbors,function,case,out,data,set,tuple2,k,vv,vertices,with,target,neighbor,values,edges,join,this,vertices,where,1,equal,to,0,with,new,project,vertex,with,neighbor,value,join,k,vv,ev,0,with,forwarded,fields,first,f0,name,vertex,with,out,neighbor,value,return,vertices,with,target,neighbor,values,group,by,0,reduce,new,apply,neighbor,reduce,function,k,vv,reduce,neighbors,function,name,neighbors,function,case,all,data,set,tuple2,k,vv,vertices,with,neighbor,values,edges,flat,map,new,emit,one,edge,with,neighbor,per,node,k,ev,join,this,vertices,where,1,equal,to,0,with,new,project,neighbor,value,k,vv,ev,name,vertex,with,neighbor,value,return,vertices,with,neighbor,values,group,by,0,reduce,new,apply,neighbor,reduce,function,k,vv,reduce,neighbors,function,name,neighbors,function,default,throw,new,illegal,argument,exception,illegal,edge,direction
Graph -> public DataSet<Tuple2<K, VV>> reduceOnNeighbors(ReduceNeighborsFunction<VV> reduceNeighborsFunction, 			EdgeDirection direction) throws IllegalArgumentException;1484160227;Compute a reduce transformation over the neighbors' vertex values of each vertex._For each vertex, the transformation consecutively calls a_{@link ReduceNeighborsFunction} until only a single value for each vertex remains._The {@link ReduceNeighborsFunction} combines a pair of neighbor vertex values_into one new value of the same type.__@param reduceNeighborsFunction the reduce function to apply to the neighbors of each vertex._@param direction the edge direction (in-, out-, all-)_@return a Dataset of Tuple2, with one tuple per vertex._The first field of the Tuple2 is the vertex ID and the second field_is the aggregate value computed by the provided {@link ReduceNeighborsFunction}._@throws IllegalArgumentException;public DataSet<Tuple2<K, VV>> reduceOnNeighbors(ReduceNeighborsFunction<VV> reduceNeighborsFunction,_			EdgeDirection direction) throws IllegalArgumentException {_		switch (direction) {_			case IN:_				_				final DataSet<Tuple2<K, VV>> verticesWithSourceNeighborValues = edges_						.join(this.vertices).where(0).equalTo(0)_						.with(new ProjectVertexWithNeighborValueJoin<K, VV, EV>(1))_						.withForwardedFieldsFirst("f1->f0").name("Vertex with in-neighbor value")__				return verticesWithSourceNeighborValues.groupBy(0).reduce(new ApplyNeighborReduceFunction<K, VV>(_						reduceNeighborsFunction)).name("Neighbors function")__			case OUT:_				_				DataSet<Tuple2<K, VV>> verticesWithTargetNeighborValues = edges_						.join(this.vertices).where(1).equalTo(0)_						.with(new ProjectVertexWithNeighborValueJoin<K, VV, EV>(0))_						.withForwardedFieldsFirst("f0").name("Vertex with out-neighbor value")__				return verticesWithTargetNeighborValues.groupBy(0).reduce(new ApplyNeighborReduceFunction<K, VV>(_						reduceNeighborsFunction)).name("Neighbors function")__			case ALL:_				_				DataSet<Tuple2<K, VV>> verticesWithNeighborValues = edges_						.flatMap(new EmitOneEdgeWithNeighborPerNode<K, EV>())_						.join(this.vertices).where(1).equalTo(0)_						.with(new ProjectNeighborValue<K, VV, EV>()).name("Vertex with neighbor value")___				return verticesWithNeighborValues.groupBy(0).reduce(new ApplyNeighborReduceFunction<K, VV>(_						reduceNeighborsFunction)).name("Neighbors function")__			default:_				throw new IllegalArgumentException("Illegal edge direction")__		}_	};compute,a,reduce,transformation,over,the,neighbors,vertex,values,of,each,vertex,for,each,vertex,the,transformation,consecutively,calls,a,link,reduce,neighbors,function,until,only,a,single,value,for,each,vertex,remains,the,link,reduce,neighbors,function,combines,a,pair,of,neighbor,vertex,values,into,one,new,value,of,the,same,type,param,reduce,neighbors,function,the,reduce,function,to,apply,to,the,neighbors,of,each,vertex,param,direction,the,edge,direction,in,out,all,return,a,dataset,of,tuple2,with,one,tuple,per,vertex,the,first,field,of,the,tuple2,is,the,vertex,id,and,the,second,field,is,the,aggregate,value,computed,by,the,provided,link,reduce,neighbors,function,throws,illegal,argument,exception;public,data,set,tuple2,k,vv,reduce,on,neighbors,reduce,neighbors,function,vv,reduce,neighbors,function,edge,direction,direction,throws,illegal,argument,exception,switch,direction,case,in,final,data,set,tuple2,k,vv,vertices,with,source,neighbor,values,edges,join,this,vertices,where,0,equal,to,0,with,new,project,vertex,with,neighbor,value,join,k,vv,ev,1,with,forwarded,fields,first,f1,f0,name,vertex,with,in,neighbor,value,return,vertices,with,source,neighbor,values,group,by,0,reduce,new,apply,neighbor,reduce,function,k,vv,reduce,neighbors,function,name,neighbors,function,case,out,data,set,tuple2,k,vv,vertices,with,target,neighbor,values,edges,join,this,vertices,where,1,equal,to,0,with,new,project,vertex,with,neighbor,value,join,k,vv,ev,0,with,forwarded,fields,first,f0,name,vertex,with,out,neighbor,value,return,vertices,with,target,neighbor,values,group,by,0,reduce,new,apply,neighbor,reduce,function,k,vv,reduce,neighbors,function,name,neighbors,function,case,all,data,set,tuple2,k,vv,vertices,with,neighbor,values,edges,flat,map,new,emit,one,edge,with,neighbor,per,node,k,ev,join,this,vertices,where,1,equal,to,0,with,new,project,neighbor,value,k,vv,ev,name,vertex,with,neighbor,value,return,vertices,with,neighbor,values,group,by,0,reduce,new,apply,neighbor,reduce,function,k,vv,reduce,neighbors,function,name,neighbors,function,default,throw,new,illegal,argument,exception,illegal,edge,direction
Graph -> public DataSet<Tuple2<K, VV>> reduceOnNeighbors(ReduceNeighborsFunction<VV> reduceNeighborsFunction, 			EdgeDirection direction) throws IllegalArgumentException;1484685504;Compute a reduce transformation over the neighbors' vertex values of each vertex._For each vertex, the transformation consecutively calls a_{@link ReduceNeighborsFunction} until only a single value for each vertex remains._The {@link ReduceNeighborsFunction} combines a pair of neighbor vertex values_into one new value of the same type.__@param reduceNeighborsFunction the reduce function to apply to the neighbors of each vertex._@param direction the edge direction (in-, out-, all-)_@return a Dataset of Tuple2, with one tuple per vertex._The first field of the Tuple2 is the vertex ID and the second field_is the aggregate value computed by the provided {@link ReduceNeighborsFunction}._@throws IllegalArgumentException;public DataSet<Tuple2<K, VV>> reduceOnNeighbors(ReduceNeighborsFunction<VV> reduceNeighborsFunction,_			EdgeDirection direction) throws IllegalArgumentException {_		switch (direction) {_			case IN:_				_				final DataSet<Tuple2<K, VV>> verticesWithSourceNeighborValues = edges_						.join(this.vertices).where(0).equalTo(0)_						.with(new ProjectVertexWithNeighborValueJoin<K, VV, EV>(1))_						.withForwardedFieldsFirst("f1->f0").name("Vertex with in-neighbor value")__				return verticesWithSourceNeighborValues.groupBy(0).reduce(new ApplyNeighborReduceFunction<K, VV>(_						reduceNeighborsFunction)).name("Neighbors function")__			case OUT:_				_				DataSet<Tuple2<K, VV>> verticesWithTargetNeighborValues = edges_						.join(this.vertices).where(1).equalTo(0)_						.with(new ProjectVertexWithNeighborValueJoin<K, VV, EV>(0))_						.withForwardedFieldsFirst("f0").name("Vertex with out-neighbor value")__				return verticesWithTargetNeighborValues.groupBy(0).reduce(new ApplyNeighborReduceFunction<K, VV>(_						reduceNeighborsFunction)).name("Neighbors function")__			case ALL:_				_				DataSet<Tuple2<K, VV>> verticesWithNeighborValues = edges_						.flatMap(new EmitOneEdgeWithNeighborPerNode<K, EV>())_						.join(this.vertices).where(1).equalTo(0)_						.with(new ProjectNeighborValue<K, VV, EV>()).name("Vertex with neighbor value")___				return verticesWithNeighborValues.groupBy(0).reduce(new ApplyNeighborReduceFunction<K, VV>(_						reduceNeighborsFunction)).name("Neighbors function")__			default:_				throw new IllegalArgumentException("Illegal edge direction")__		}_	};compute,a,reduce,transformation,over,the,neighbors,vertex,values,of,each,vertex,for,each,vertex,the,transformation,consecutively,calls,a,link,reduce,neighbors,function,until,only,a,single,value,for,each,vertex,remains,the,link,reduce,neighbors,function,combines,a,pair,of,neighbor,vertex,values,into,one,new,value,of,the,same,type,param,reduce,neighbors,function,the,reduce,function,to,apply,to,the,neighbors,of,each,vertex,param,direction,the,edge,direction,in,out,all,return,a,dataset,of,tuple2,with,one,tuple,per,vertex,the,first,field,of,the,tuple2,is,the,vertex,id,and,the,second,field,is,the,aggregate,value,computed,by,the,provided,link,reduce,neighbors,function,throws,illegal,argument,exception;public,data,set,tuple2,k,vv,reduce,on,neighbors,reduce,neighbors,function,vv,reduce,neighbors,function,edge,direction,direction,throws,illegal,argument,exception,switch,direction,case,in,final,data,set,tuple2,k,vv,vertices,with,source,neighbor,values,edges,join,this,vertices,where,0,equal,to,0,with,new,project,vertex,with,neighbor,value,join,k,vv,ev,1,with,forwarded,fields,first,f1,f0,name,vertex,with,in,neighbor,value,return,vertices,with,source,neighbor,values,group,by,0,reduce,new,apply,neighbor,reduce,function,k,vv,reduce,neighbors,function,name,neighbors,function,case,out,data,set,tuple2,k,vv,vertices,with,target,neighbor,values,edges,join,this,vertices,where,1,equal,to,0,with,new,project,vertex,with,neighbor,value,join,k,vv,ev,0,with,forwarded,fields,first,f0,name,vertex,with,out,neighbor,value,return,vertices,with,target,neighbor,values,group,by,0,reduce,new,apply,neighbor,reduce,function,k,vv,reduce,neighbors,function,name,neighbors,function,case,all,data,set,tuple2,k,vv,vertices,with,neighbor,values,edges,flat,map,new,emit,one,edge,with,neighbor,per,node,k,ev,join,this,vertices,where,1,equal,to,0,with,new,project,neighbor,value,k,vv,ev,name,vertex,with,neighbor,value,return,vertices,with,neighbor,values,group,by,0,reduce,new,apply,neighbor,reduce,function,k,vv,reduce,neighbors,function,name,neighbors,function,default,throw,new,illegal,argument,exception,illegal,edge,direction
Graph -> public DataSet<Tuple2<K, VV>> reduceOnNeighbors(ReduceNeighborsFunction<VV> reduceNeighborsFunction, 			EdgeDirection direction) throws IllegalArgumentException;1489068942;Compute a reduce transformation over the neighbors' vertex values of each vertex._For each vertex, the transformation consecutively calls a_{@link ReduceNeighborsFunction} until only a single value for each vertex remains._The {@link ReduceNeighborsFunction} combines a pair of neighbor vertex values_into one new value of the same type.__@param reduceNeighborsFunction the reduce function to apply to the neighbors of each vertex._@param direction the edge direction (in-, out-, all-)_@return a Dataset of Tuple2, with one tuple per vertex._The first field of the Tuple2 is the vertex ID and the second field_is the aggregate value computed by the provided {@link ReduceNeighborsFunction}._@throws IllegalArgumentException;public DataSet<Tuple2<K, VV>> reduceOnNeighbors(ReduceNeighborsFunction<VV> reduceNeighborsFunction,_			EdgeDirection direction) throws IllegalArgumentException {_		switch (direction) {_			case IN:_				_				final DataSet<Tuple2<K, VV>> verticesWithSourceNeighborValues = edges_						.join(this.vertices).where(0).equalTo(0)_						.with(new ProjectVertexWithNeighborValueJoin<K, VV, EV>(1))_						.withForwardedFieldsFirst("f1->f0").name("Vertex with in-neighbor value")__				return verticesWithSourceNeighborValues.groupBy(0).reduce(new ApplyNeighborReduceFunction<K, VV>(_						reduceNeighborsFunction)).name("Neighbors function")__			case OUT:_				_				DataSet<Tuple2<K, VV>> verticesWithTargetNeighborValues = edges_						.join(this.vertices).where(1).equalTo(0)_						.with(new ProjectVertexWithNeighborValueJoin<K, VV, EV>(0))_						.withForwardedFieldsFirst("f0").name("Vertex with out-neighbor value")__				return verticesWithTargetNeighborValues.groupBy(0).reduce(new ApplyNeighborReduceFunction<K, VV>(_						reduceNeighborsFunction)).name("Neighbors function")__			case ALL:_				_				DataSet<Tuple2<K, VV>> verticesWithNeighborValues = edges_						.flatMap(new EmitOneEdgeWithNeighborPerNode<K, EV>())_						.join(this.vertices).where(1).equalTo(0)_						.with(new ProjectNeighborValue<K, VV, EV>()).name("Vertex with neighbor value")___				return verticesWithNeighborValues.groupBy(0).reduce(new ApplyNeighborReduceFunction<K, VV>(_						reduceNeighborsFunction)).name("Neighbors function")__			default:_				throw new IllegalArgumentException("Illegal edge direction")__		}_	};compute,a,reduce,transformation,over,the,neighbors,vertex,values,of,each,vertex,for,each,vertex,the,transformation,consecutively,calls,a,link,reduce,neighbors,function,until,only,a,single,value,for,each,vertex,remains,the,link,reduce,neighbors,function,combines,a,pair,of,neighbor,vertex,values,into,one,new,value,of,the,same,type,param,reduce,neighbors,function,the,reduce,function,to,apply,to,the,neighbors,of,each,vertex,param,direction,the,edge,direction,in,out,all,return,a,dataset,of,tuple2,with,one,tuple,per,vertex,the,first,field,of,the,tuple2,is,the,vertex,id,and,the,second,field,is,the,aggregate,value,computed,by,the,provided,link,reduce,neighbors,function,throws,illegal,argument,exception;public,data,set,tuple2,k,vv,reduce,on,neighbors,reduce,neighbors,function,vv,reduce,neighbors,function,edge,direction,direction,throws,illegal,argument,exception,switch,direction,case,in,final,data,set,tuple2,k,vv,vertices,with,source,neighbor,values,edges,join,this,vertices,where,0,equal,to,0,with,new,project,vertex,with,neighbor,value,join,k,vv,ev,1,with,forwarded,fields,first,f1,f0,name,vertex,with,in,neighbor,value,return,vertices,with,source,neighbor,values,group,by,0,reduce,new,apply,neighbor,reduce,function,k,vv,reduce,neighbors,function,name,neighbors,function,case,out,data,set,tuple2,k,vv,vertices,with,target,neighbor,values,edges,join,this,vertices,where,1,equal,to,0,with,new,project,vertex,with,neighbor,value,join,k,vv,ev,0,with,forwarded,fields,first,f0,name,vertex,with,out,neighbor,value,return,vertices,with,target,neighbor,values,group,by,0,reduce,new,apply,neighbor,reduce,function,k,vv,reduce,neighbors,function,name,neighbors,function,case,all,data,set,tuple2,k,vv,vertices,with,neighbor,values,edges,flat,map,new,emit,one,edge,with,neighbor,per,node,k,ev,join,this,vertices,where,1,equal,to,0,with,new,project,neighbor,value,k,vv,ev,name,vertex,with,neighbor,value,return,vertices,with,neighbor,values,group,by,0,reduce,new,apply,neighbor,reduce,function,k,vv,reduce,neighbors,function,name,neighbors,function,default,throw,new,illegal,argument,exception,illegal,edge,direction
Graph -> public DataSet<Tuple2<K, VV>> reduceOnNeighbors(ReduceNeighborsFunction<VV> reduceNeighborsFunction, 			EdgeDirection direction) throws IllegalArgumentException;1490973446;Compute a reduce transformation over the neighbors' vertex values of each vertex._For each vertex, the transformation consecutively calls a_{@link ReduceNeighborsFunction} until only a single value for each vertex remains._The {@link ReduceNeighborsFunction} combines a pair of neighbor vertex values_into one new value of the same type.__@param reduceNeighborsFunction the reduce function to apply to the neighbors of each vertex._@param direction the edge direction (in-, out-, all-)_@return a Dataset of Tuple2, with one tuple per vertex._The first field of the Tuple2 is the vertex ID and the second field_is the aggregate value computed by the provided {@link ReduceNeighborsFunction}._@throws IllegalArgumentException;public DataSet<Tuple2<K, VV>> reduceOnNeighbors(ReduceNeighborsFunction<VV> reduceNeighborsFunction,_			EdgeDirection direction) throws IllegalArgumentException {_		switch (direction) {_			case IN:_				_				final DataSet<Tuple2<K, VV>> verticesWithSourceNeighborValues = edges_						.join(this.vertices).where(0).equalTo(0)_						.with(new ProjectVertexWithNeighborValueJoin<K, VV, EV>(1))_						.withForwardedFieldsFirst("f1->f0").name("Vertex with in-neighbor value")__				return verticesWithSourceNeighborValues.groupBy(0).reduce(new ApplyNeighborReduceFunction<K, VV>(_						reduceNeighborsFunction)).name("Neighbors function")__			case OUT:_				_				DataSet<Tuple2<K, VV>> verticesWithTargetNeighborValues = edges_						.join(this.vertices).where(1).equalTo(0)_						.with(new ProjectVertexWithNeighborValueJoin<K, VV, EV>(0))_						.withForwardedFieldsFirst("f0").name("Vertex with out-neighbor value")__				return verticesWithTargetNeighborValues.groupBy(0).reduce(new ApplyNeighborReduceFunction<K, VV>(_						reduceNeighborsFunction)).name("Neighbors function")__			case ALL:_				_				DataSet<Tuple2<K, VV>> verticesWithNeighborValues = edges_						.flatMap(new EmitOneEdgeWithNeighborPerNode<K, EV>())_						.join(this.vertices).where(1).equalTo(0)_						.with(new ProjectNeighborValue<K, VV, EV>()).name("Vertex with neighbor value")___				return verticesWithNeighborValues.groupBy(0).reduce(new ApplyNeighborReduceFunction<K, VV>(_						reduceNeighborsFunction)).name("Neighbors function")__			default:_				throw new IllegalArgumentException("Illegal edge direction")__		}_	};compute,a,reduce,transformation,over,the,neighbors,vertex,values,of,each,vertex,for,each,vertex,the,transformation,consecutively,calls,a,link,reduce,neighbors,function,until,only,a,single,value,for,each,vertex,remains,the,link,reduce,neighbors,function,combines,a,pair,of,neighbor,vertex,values,into,one,new,value,of,the,same,type,param,reduce,neighbors,function,the,reduce,function,to,apply,to,the,neighbors,of,each,vertex,param,direction,the,edge,direction,in,out,all,return,a,dataset,of,tuple2,with,one,tuple,per,vertex,the,first,field,of,the,tuple2,is,the,vertex,id,and,the,second,field,is,the,aggregate,value,computed,by,the,provided,link,reduce,neighbors,function,throws,illegal,argument,exception;public,data,set,tuple2,k,vv,reduce,on,neighbors,reduce,neighbors,function,vv,reduce,neighbors,function,edge,direction,direction,throws,illegal,argument,exception,switch,direction,case,in,final,data,set,tuple2,k,vv,vertices,with,source,neighbor,values,edges,join,this,vertices,where,0,equal,to,0,with,new,project,vertex,with,neighbor,value,join,k,vv,ev,1,with,forwarded,fields,first,f1,f0,name,vertex,with,in,neighbor,value,return,vertices,with,source,neighbor,values,group,by,0,reduce,new,apply,neighbor,reduce,function,k,vv,reduce,neighbors,function,name,neighbors,function,case,out,data,set,tuple2,k,vv,vertices,with,target,neighbor,values,edges,join,this,vertices,where,1,equal,to,0,with,new,project,vertex,with,neighbor,value,join,k,vv,ev,0,with,forwarded,fields,first,f0,name,vertex,with,out,neighbor,value,return,vertices,with,target,neighbor,values,group,by,0,reduce,new,apply,neighbor,reduce,function,k,vv,reduce,neighbors,function,name,neighbors,function,case,all,data,set,tuple2,k,vv,vertices,with,neighbor,values,edges,flat,map,new,emit,one,edge,with,neighbor,per,node,k,ev,join,this,vertices,where,1,equal,to,0,with,new,project,neighbor,value,k,vv,ev,name,vertex,with,neighbor,value,return,vertices,with,neighbor,values,group,by,0,reduce,new,apply,neighbor,reduce,function,k,vv,reduce,neighbors,function,name,neighbors,function,default,throw,new,illegal,argument,exception,illegal,edge,direction
Graph -> public DataSet<Tuple2<K, VV>> reduceOnNeighbors(ReduceNeighborsFunction<VV> reduceNeighborsFunction, 			EdgeDirection direction) throws IllegalArgumentException;1495819075;Compute a reduce transformation over the neighbors' vertex values of each vertex._For each vertex, the transformation consecutively calls a_{@link ReduceNeighborsFunction} until only a single value for each vertex remains._The {@link ReduceNeighborsFunction} combines a pair of neighbor vertex values_into one new value of the same type.__@param reduceNeighborsFunction the reduce function to apply to the neighbors of each vertex._@param direction the edge direction (in-, out-, all-)_@return a Dataset of Tuple2, with one tuple per vertex._The first field of the Tuple2 is the vertex ID and the second field_is the aggregate value computed by the provided {@link ReduceNeighborsFunction}._@throws IllegalArgumentException;public DataSet<Tuple2<K, VV>> reduceOnNeighbors(ReduceNeighborsFunction<VV> reduceNeighborsFunction,_			EdgeDirection direction) throws IllegalArgumentException {_		switch (direction) {_			case IN:_				_				final DataSet<Tuple2<K, VV>> verticesWithSourceNeighborValues = edges_						.join(this.vertices).where(0).equalTo(0)_						.with(new ProjectVertexWithNeighborValueJoin<K, VV, EV>(1))_						.withForwardedFieldsFirst("f1->f0").name("Vertex with in-neighbor value")__				return verticesWithSourceNeighborValues.groupBy(0).reduce(new ApplyNeighborReduceFunction<K, VV>(_						reduceNeighborsFunction)).name("Neighbors function")__			case OUT:_				_				DataSet<Tuple2<K, VV>> verticesWithTargetNeighborValues = edges_						.join(this.vertices).where(1).equalTo(0)_						.with(new ProjectVertexWithNeighborValueJoin<K, VV, EV>(0))_						.withForwardedFieldsFirst("f0").name("Vertex with out-neighbor value")__				return verticesWithTargetNeighborValues.groupBy(0).reduce(new ApplyNeighborReduceFunction<K, VV>(_						reduceNeighborsFunction)).name("Neighbors function")__			case ALL:_				_				DataSet<Tuple2<K, VV>> verticesWithNeighborValues = edges_						.flatMap(new EmitOneEdgeWithNeighborPerNode<K, EV>())_						.join(this.vertices).where(1).equalTo(0)_						.with(new ProjectNeighborValue<K, VV, EV>()).name("Vertex with neighbor value")___				return verticesWithNeighborValues.groupBy(0).reduce(new ApplyNeighborReduceFunction<K, VV>(_						reduceNeighborsFunction)).name("Neighbors function")__			default:_				throw new IllegalArgumentException("Illegal edge direction")__		}_	};compute,a,reduce,transformation,over,the,neighbors,vertex,values,of,each,vertex,for,each,vertex,the,transformation,consecutively,calls,a,link,reduce,neighbors,function,until,only,a,single,value,for,each,vertex,remains,the,link,reduce,neighbors,function,combines,a,pair,of,neighbor,vertex,values,into,one,new,value,of,the,same,type,param,reduce,neighbors,function,the,reduce,function,to,apply,to,the,neighbors,of,each,vertex,param,direction,the,edge,direction,in,out,all,return,a,dataset,of,tuple2,with,one,tuple,per,vertex,the,first,field,of,the,tuple2,is,the,vertex,id,and,the,second,field,is,the,aggregate,value,computed,by,the,provided,link,reduce,neighbors,function,throws,illegal,argument,exception;public,data,set,tuple2,k,vv,reduce,on,neighbors,reduce,neighbors,function,vv,reduce,neighbors,function,edge,direction,direction,throws,illegal,argument,exception,switch,direction,case,in,final,data,set,tuple2,k,vv,vertices,with,source,neighbor,values,edges,join,this,vertices,where,0,equal,to,0,with,new,project,vertex,with,neighbor,value,join,k,vv,ev,1,with,forwarded,fields,first,f1,f0,name,vertex,with,in,neighbor,value,return,vertices,with,source,neighbor,values,group,by,0,reduce,new,apply,neighbor,reduce,function,k,vv,reduce,neighbors,function,name,neighbors,function,case,out,data,set,tuple2,k,vv,vertices,with,target,neighbor,values,edges,join,this,vertices,where,1,equal,to,0,with,new,project,vertex,with,neighbor,value,join,k,vv,ev,0,with,forwarded,fields,first,f0,name,vertex,with,out,neighbor,value,return,vertices,with,target,neighbor,values,group,by,0,reduce,new,apply,neighbor,reduce,function,k,vv,reduce,neighbors,function,name,neighbors,function,case,all,data,set,tuple2,k,vv,vertices,with,neighbor,values,edges,flat,map,new,emit,one,edge,with,neighbor,per,node,k,ev,join,this,vertices,where,1,equal,to,0,with,new,project,neighbor,value,k,vv,ev,name,vertex,with,neighbor,value,return,vertices,with,neighbor,values,group,by,0,reduce,new,apply,neighbor,reduce,function,k,vv,reduce,neighbors,function,name,neighbors,function,default,throw,new,illegal,argument,exception,illegal,edge,direction
Graph -> public DataSet<Tuple2<K, VV>> reduceOnNeighbors(ReduceNeighborsFunction<VV> reduceNeighborsFunction, 			EdgeDirection direction) throws IllegalArgumentException;1502111816;Compute a reduce transformation over the neighbors' vertex values of each vertex._For each vertex, the transformation consecutively calls a_{@link ReduceNeighborsFunction} until only a single value for each vertex remains._The {@link ReduceNeighborsFunction} combines a pair of neighbor vertex values_into one new value of the same type.__@param reduceNeighborsFunction the reduce function to apply to the neighbors of each vertex._@param direction the edge direction (in-, out-, all-)_@return a Dataset of Tuple2, with one tuple per vertex._The first field of the Tuple2 is the vertex ID and the second field_is the aggregate value computed by the provided {@link ReduceNeighborsFunction}._@throws IllegalArgumentException;public DataSet<Tuple2<K, VV>> reduceOnNeighbors(ReduceNeighborsFunction<VV> reduceNeighborsFunction,_			EdgeDirection direction) throws IllegalArgumentException {_		switch (direction) {_			case IN:_				_				final DataSet<Tuple2<K, VV>> verticesWithSourceNeighborValues = edges_						.join(this.vertices).where(0).equalTo(0)_						.with(new ProjectVertexWithNeighborValueJoin<>(1))_						.withForwardedFieldsFirst("f1->f0").name("Vertex with in-neighbor value")__				return verticesWithSourceNeighborValues.groupBy(0).reduce(new ApplyNeighborReduceFunction<>(_					reduceNeighborsFunction)).name("Neighbors function")__			case OUT:_				_				DataSet<Tuple2<K, VV>> verticesWithTargetNeighborValues = edges_						.join(this.vertices).where(1).equalTo(0)_						.with(new ProjectVertexWithNeighborValueJoin<>(0))_						.withForwardedFieldsFirst("f0").name("Vertex with out-neighbor value")__				return verticesWithTargetNeighborValues.groupBy(0).reduce(new ApplyNeighborReduceFunction<>(_					reduceNeighborsFunction)).name("Neighbors function")__			case ALL:_				_				DataSet<Tuple2<K, VV>> verticesWithNeighborValues = edges_						.flatMap(new EmitOneEdgeWithNeighborPerNode<>())_						.join(this.vertices).where(1).equalTo(0)_						.with(new ProjectNeighborValue<>()).name("Vertex with neighbor value")___				return verticesWithNeighborValues.groupBy(0).reduce(new ApplyNeighborReduceFunction<>(_					reduceNeighborsFunction)).name("Neighbors function")__			default:_				throw new IllegalArgumentException("Illegal edge direction")__		}_	};compute,a,reduce,transformation,over,the,neighbors,vertex,values,of,each,vertex,for,each,vertex,the,transformation,consecutively,calls,a,link,reduce,neighbors,function,until,only,a,single,value,for,each,vertex,remains,the,link,reduce,neighbors,function,combines,a,pair,of,neighbor,vertex,values,into,one,new,value,of,the,same,type,param,reduce,neighbors,function,the,reduce,function,to,apply,to,the,neighbors,of,each,vertex,param,direction,the,edge,direction,in,out,all,return,a,dataset,of,tuple2,with,one,tuple,per,vertex,the,first,field,of,the,tuple2,is,the,vertex,id,and,the,second,field,is,the,aggregate,value,computed,by,the,provided,link,reduce,neighbors,function,throws,illegal,argument,exception;public,data,set,tuple2,k,vv,reduce,on,neighbors,reduce,neighbors,function,vv,reduce,neighbors,function,edge,direction,direction,throws,illegal,argument,exception,switch,direction,case,in,final,data,set,tuple2,k,vv,vertices,with,source,neighbor,values,edges,join,this,vertices,where,0,equal,to,0,with,new,project,vertex,with,neighbor,value,join,1,with,forwarded,fields,first,f1,f0,name,vertex,with,in,neighbor,value,return,vertices,with,source,neighbor,values,group,by,0,reduce,new,apply,neighbor,reduce,function,reduce,neighbors,function,name,neighbors,function,case,out,data,set,tuple2,k,vv,vertices,with,target,neighbor,values,edges,join,this,vertices,where,1,equal,to,0,with,new,project,vertex,with,neighbor,value,join,0,with,forwarded,fields,first,f0,name,vertex,with,out,neighbor,value,return,vertices,with,target,neighbor,values,group,by,0,reduce,new,apply,neighbor,reduce,function,reduce,neighbors,function,name,neighbors,function,case,all,data,set,tuple2,k,vv,vertices,with,neighbor,values,edges,flat,map,new,emit,one,edge,with,neighbor,per,node,join,this,vertices,where,1,equal,to,0,with,new,project,neighbor,value,name,vertex,with,neighbor,value,return,vertices,with,neighbor,values,group,by,0,reduce,new,apply,neighbor,reduce,function,reduce,neighbors,function,name,neighbors,function,default,throw,new,illegal,argument,exception,illegal,edge,direction
Graph -> public DataSet<Triplet<K, VV, EV>> getTriplets();1444404795;This method allows access to the graph's edge values along with its source and target vertex values.__@return a triplet DataSet consisting of (srcVertexId, trgVertexId, srcVertexValue, trgVertexValue, edgeValue);public DataSet<Triplet<K, VV, EV>> getTriplets() {_		return this.getVertices().join(this.getEdges()).where(0).equalTo(0)_				.with(new ProjectEdgeWithSrcValue<K, VV, EV>())_				.join(this.getVertices()).where(1).equalTo(0)_				.with(new ProjectEdgeWithVertexValues<K, VV, EV>())__	};this,method,allows,access,to,the,graph,s,edge,values,along,with,its,source,and,target,vertex,values,return,a,triplet,data,set,consisting,of,src,vertex,id,trg,vertex,id,src,vertex,value,trg,vertex,value,edge,value;public,data,set,triplet,k,vv,ev,get,triplets,return,this,get,vertices,join,this,get,edges,where,0,equal,to,0,with,new,project,edge,with,src,value,k,vv,ev,join,this,get,vertices,where,1,equal,to,0,with,new,project,edge,with,vertex,values,k,vv,ev
Graph -> public DataSet<Triplet<K, VV, EV>> getTriplets();1445261977;This method allows access to the graph's edge values along with its source and target vertex values.__@return a triplet DataSet consisting of (srcVertexId, trgVertexId, srcVertexValue, trgVertexValue, edgeValue);public DataSet<Triplet<K, VV, EV>> getTriplets() {_		return this.getVertices().join(this.getEdges()).where(0).equalTo(0)_				.with(new ProjectEdgeWithSrcValue<K, VV, EV>())_				.join(this.getVertices()).where(1).equalTo(0)_				.with(new ProjectEdgeWithVertexValues<K, VV, EV>())__	};this,method,allows,access,to,the,graph,s,edge,values,along,with,its,source,and,target,vertex,values,return,a,triplet,data,set,consisting,of,src,vertex,id,trg,vertex,id,src,vertex,value,trg,vertex,value,edge,value;public,data,set,triplet,k,vv,ev,get,triplets,return,this,get,vertices,join,this,get,edges,where,0,equal,to,0,with,new,project,edge,with,src,value,k,vv,ev,join,this,get,vertices,where,1,equal,to,0,with,new,project,edge,with,vertex,values,k,vv,ev
Graph -> public DataSet<Triplet<K, VV, EV>> getTriplets();1445854323;This method allows access to the graph's edge values along with its source and target vertex values.__@return a triplet DataSet consisting of (srcVertexId, trgVertexId, srcVertexValue, trgVertexValue, edgeValue);public DataSet<Triplet<K, VV, EV>> getTriplets() {_		return this.getVertices().join(this.getEdges()).where(0).equalTo(0)_				.with(new ProjectEdgeWithSrcValue<K, VV, EV>())_				.join(this.getVertices()).where(1).equalTo(0)_				.with(new ProjectEdgeWithVertexValues<K, VV, EV>())__	};this,method,allows,access,to,the,graph,s,edge,values,along,with,its,source,and,target,vertex,values,return,a,triplet,data,set,consisting,of,src,vertex,id,trg,vertex,id,src,vertex,value,trg,vertex,value,edge,value;public,data,set,triplet,k,vv,ev,get,triplets,return,this,get,vertices,join,this,get,edges,where,0,equal,to,0,with,new,project,edge,with,src,value,k,vv,ev,join,this,get,vertices,where,1,equal,to,0,with,new,project,edge,with,vertex,values,k,vv,ev
Graph -> public DataSet<Triplet<K, VV, EV>> getTriplets();1446112342;This method allows access to the graph's edge values along with its source and target vertex values.__@return a triplet DataSet consisting of (srcVertexId, trgVertexId, srcVertexValue, trgVertexValue, edgeValue);public DataSet<Triplet<K, VV, EV>> getTriplets() {_		return this.getVertices().join(this.getEdges()).where(0).equalTo(0)_				.with(new ProjectEdgeWithSrcValue<K, VV, EV>())_				.join(this.getVertices()).where(1).equalTo(0)_				.with(new ProjectEdgeWithVertexValues<K, VV, EV>())__	};this,method,allows,access,to,the,graph,s,edge,values,along,with,its,source,and,target,vertex,values,return,a,triplet,data,set,consisting,of,src,vertex,id,trg,vertex,id,src,vertex,value,trg,vertex,value,edge,value;public,data,set,triplet,k,vv,ev,get,triplets,return,this,get,vertices,join,this,get,edges,where,0,equal,to,0,with,new,project,edge,with,src,value,k,vv,ev,join,this,get,vertices,where,1,equal,to,0,with,new,project,edge,with,vertex,values,k,vv,ev
Graph -> public DataSet<Triplet<K, VV, EV>> getTriplets();1447073368;This method allows access to the graph's edge values along with its source and target vertex values.__@return a triplet DataSet consisting of (srcVertexId, trgVertexId, srcVertexValue, trgVertexValue, edgeValue);public DataSet<Triplet<K, VV, EV>> getTriplets() {_		return this.getVertices().join(this.getEdges()).where(0).equalTo(0)_				.with(new ProjectEdgeWithSrcValue<K, VV, EV>())_				.join(this.getVertices()).where(1).equalTo(0)_				.with(new ProjectEdgeWithVertexValues<K, VV, EV>())__	};this,method,allows,access,to,the,graph,s,edge,values,along,with,its,source,and,target,vertex,values,return,a,triplet,data,set,consisting,of,src,vertex,id,trg,vertex,id,src,vertex,value,trg,vertex,value,edge,value;public,data,set,triplet,k,vv,ev,get,triplets,return,this,get,vertices,join,this,get,edges,where,0,equal,to,0,with,new,project,edge,with,src,value,k,vv,ev,join,this,get,vertices,where,1,equal,to,0,with,new,project,edge,with,vertex,values,k,vv,ev
Graph -> public DataSet<Triplet<K, VV, EV>> getTriplets();1454404649;This method allows access to the graph's edge values along with its source and target vertex values.__@return a triplet DataSet consisting of (srcVertexId, trgVertexId, srcVertexValue, trgVertexValue, edgeValue);public DataSet<Triplet<K, VV, EV>> getTriplets() {_		return this.getVertices().join(this.getEdges()).where(0).equalTo(0)_				.with(new ProjectEdgeWithSrcValue<K, VV, EV>())_				.join(this.getVertices()).where(1).equalTo(0)_				.with(new ProjectEdgeWithVertexValues<K, VV, EV>())__	};this,method,allows,access,to,the,graph,s,edge,values,along,with,its,source,and,target,vertex,values,return,a,triplet,data,set,consisting,of,src,vertex,id,trg,vertex,id,src,vertex,value,trg,vertex,value,edge,value;public,data,set,triplet,k,vv,ev,get,triplets,return,this,get,vertices,join,this,get,edges,where,0,equal,to,0,with,new,project,edge,with,src,value,k,vv,ev,join,this,get,vertices,where,1,equal,to,0,with,new,project,edge,with,vertex,values,k,vv,ev
Graph -> public DataSet<Triplet<K, VV, EV>> getTriplets();1458583829;This method allows access to the graph's edge values along with its source and target vertex values.__@return a triplet DataSet consisting of (srcVertexId, trgVertexId, srcVertexValue, trgVertexValue, edgeValue);public DataSet<Triplet<K, VV, EV>> getTriplets() {_		return this.getVertices().join(this.getEdges()).where(0).equalTo(0)_				.with(new ProjectEdgeWithSrcValue<K, VV, EV>())_				.join(this.getVertices()).where(1).equalTo(0)_				.with(new ProjectEdgeWithVertexValues<K, VV, EV>())__	};this,method,allows,access,to,the,graph,s,edge,values,along,with,its,source,and,target,vertex,values,return,a,triplet,data,set,consisting,of,src,vertex,id,trg,vertex,id,src,vertex,value,trg,vertex,value,edge,value;public,data,set,triplet,k,vv,ev,get,triplets,return,this,get,vertices,join,this,get,edges,where,0,equal,to,0,with,new,project,edge,with,src,value,k,vv,ev,join,this,get,vertices,where,1,equal,to,0,with,new,project,edge,with,vertex,values,k,vv,ev
Graph -> public DataSet<Triplet<K, VV, EV>> getTriplets();1458583829;This method allows access to the graph's edge values along with its source and target vertex values.__@return a triplet DataSet consisting of (srcVertexId, trgVertexId, srcVertexValue, trgVertexValue, edgeValue);public DataSet<Triplet<K, VV, EV>> getTriplets() {_		return this.getVertices().join(this.getEdges()).where(0).equalTo(0)_				.with(new ProjectEdgeWithSrcValue<K, VV, EV>())_				.join(this.getVertices()).where(1).equalTo(0)_				.with(new ProjectEdgeWithVertexValues<K, VV, EV>())__	};this,method,allows,access,to,the,graph,s,edge,values,along,with,its,source,and,target,vertex,values,return,a,triplet,data,set,consisting,of,src,vertex,id,trg,vertex,id,src,vertex,value,trg,vertex,value,edge,value;public,data,set,triplet,k,vv,ev,get,triplets,return,this,get,vertices,join,this,get,edges,where,0,equal,to,0,with,new,project,edge,with,src,value,k,vv,ev,join,this,get,vertices,where,1,equal,to,0,with,new,project,edge,with,vertex,values,k,vv,ev
Graph -> public DataSet<Triplet<K, VV, EV>> getTriplets();1462100316;This method allows access to the graph's edge values along with its source and target vertex values.__@return a triplet DataSet consisting of (srcVertexId, trgVertexId, srcVertexValue, trgVertexValue, edgeValue);public DataSet<Triplet<K, VV, EV>> getTriplets() {_		return this.getVertices().join(this.getEdges()).where(0).equalTo(0)_				.with(new ProjectEdgeWithSrcValue<K, VV, EV>())_				.join(this.getVertices()).where(1).equalTo(0)_				.with(new ProjectEdgeWithVertexValues<K, VV, EV>())__	};this,method,allows,access,to,the,graph,s,edge,values,along,with,its,source,and,target,vertex,values,return,a,triplet,data,set,consisting,of,src,vertex,id,trg,vertex,id,src,vertex,value,trg,vertex,value,edge,value;public,data,set,triplet,k,vv,ev,get,triplets,return,this,get,vertices,join,this,get,edges,where,0,equal,to,0,with,new,project,edge,with,src,value,k,vv,ev,join,this,get,vertices,where,1,equal,to,0,with,new,project,edge,with,vertex,values,k,vv,ev
Graph -> public DataSet<Triplet<K, VV, EV>> getTriplets();1462100316;This method allows access to the graph's edge values along with its source and target vertex values.__@return a triplet DataSet consisting of (srcVertexId, trgVertexId, srcVertexValue, trgVertexValue, edgeValue);public DataSet<Triplet<K, VV, EV>> getTriplets() {_		return this.getVertices().join(this.getEdges()).where(0).equalTo(0)_				.with(new ProjectEdgeWithSrcValue<K, VV, EV>())_				.join(this.getVertices()).where(1).equalTo(0)_				.with(new ProjectEdgeWithVertexValues<K, VV, EV>())__	};this,method,allows,access,to,the,graph,s,edge,values,along,with,its,source,and,target,vertex,values,return,a,triplet,data,set,consisting,of,src,vertex,id,trg,vertex,id,src,vertex,value,trg,vertex,value,edge,value;public,data,set,triplet,k,vv,ev,get,triplets,return,this,get,vertices,join,this,get,edges,where,0,equal,to,0,with,new,project,edge,with,src,value,k,vv,ev,join,this,get,vertices,where,1,equal,to,0,with,new,project,edge,with,vertex,values,k,vv,ev
Graph -> public DataSet<Triplet<K, VV, EV>> getTriplets();1462205213;This method allows access to the graph's edge values along with its source and target vertex values.__@return a triplet DataSet consisting of (srcVertexId, trgVertexId, srcVertexValue, trgVertexValue, edgeValue);public DataSet<Triplet<K, VV, EV>> getTriplets() {_		return this.getVertices().join(this.getEdges()).where(0).equalTo(0)_				.with(new ProjectEdgeWithSrcValue<K, VV, EV>())_				.join(this.getVertices()).where(1).equalTo(0)_				.with(new ProjectEdgeWithVertexValues<K, VV, EV>())__	};this,method,allows,access,to,the,graph,s,edge,values,along,with,its,source,and,target,vertex,values,return,a,triplet,data,set,consisting,of,src,vertex,id,trg,vertex,id,src,vertex,value,trg,vertex,value,edge,value;public,data,set,triplet,k,vv,ev,get,triplets,return,this,get,vertices,join,this,get,edges,where,0,equal,to,0,with,new,project,edge,with,src,value,k,vv,ev,join,this,get,vertices,where,1,equal,to,0,with,new,project,edge,with,vertex,values,k,vv,ev
Graph -> public DataSet<Triplet<K, VV, EV>> getTriplets();1462208859;This method allows access to the graph's edge values along with its source and target vertex values.__@return a triplet DataSet consisting of (srcVertexId, trgVertexId, srcVertexValue, trgVertexValue, edgeValue);public DataSet<Triplet<K, VV, EV>> getTriplets() {_		return this.getVertices().join(this.getEdges()).where(0).equalTo(0)_				.with(new ProjectEdgeWithSrcValue<K, VV, EV>())_				.join(this.getVertices()).where(1).equalTo(0)_				.with(new ProjectEdgeWithVertexValues<K, VV, EV>())__	};this,method,allows,access,to,the,graph,s,edge,values,along,with,its,source,and,target,vertex,values,return,a,triplet,data,set,consisting,of,src,vertex,id,trg,vertex,id,src,vertex,value,trg,vertex,value,edge,value;public,data,set,triplet,k,vv,ev,get,triplets,return,this,get,vertices,join,this,get,edges,where,0,equal,to,0,with,new,project,edge,with,src,value,k,vv,ev,join,this,get,vertices,where,1,equal,to,0,with,new,project,edge,with,vertex,values,k,vv,ev
Graph -> public DataSet<Triplet<K, VV, EV>> getTriplets();1462809297;This method allows access to the graph's edge values along with its source and target vertex values.__@return a triplet DataSet consisting of (srcVertexId, trgVertexId, srcVertexValue, trgVertexValue, edgeValue);public DataSet<Triplet<K, VV, EV>> getTriplets() {_		return this.getVertices().join(this.getEdges()).where(0).equalTo(0)_				.with(new ProjectEdgeWithSrcValue<K, VV, EV>())_				.join(this.getVertices()).where(1).equalTo(0)_				.with(new ProjectEdgeWithVertexValues<K, VV, EV>())__	};this,method,allows,access,to,the,graph,s,edge,values,along,with,its,source,and,target,vertex,values,return,a,triplet,data,set,consisting,of,src,vertex,id,trg,vertex,id,src,vertex,value,trg,vertex,value,edge,value;public,data,set,triplet,k,vv,ev,get,triplets,return,this,get,vertices,join,this,get,edges,where,0,equal,to,0,with,new,project,edge,with,src,value,k,vv,ev,join,this,get,vertices,where,1,equal,to,0,with,new,project,edge,with,vertex,values,k,vv,ev
Graph -> public DataSet<Triplet<K, VV, EV>> getTriplets();1465316775;This method allows access to the graph's edge values along with its source and target vertex values.__@return a triplet DataSet consisting of (srcVertexId, trgVertexId, srcVertexValue, trgVertexValue, edgeValue);public DataSet<Triplet<K, VV, EV>> getTriplets() {_		return this.getVertices().join(this.getEdges()).where(0).equalTo(0)_				.with(new ProjectEdgeWithSrcValue<K, VV, EV>())_				.join(this.getVertices()).where(1).equalTo(0)_				.with(new ProjectEdgeWithVertexValues<K, VV, EV>())__	};this,method,allows,access,to,the,graph,s,edge,values,along,with,its,source,and,target,vertex,values,return,a,triplet,data,set,consisting,of,src,vertex,id,trg,vertex,id,src,vertex,value,trg,vertex,value,edge,value;public,data,set,triplet,k,vv,ev,get,triplets,return,this,get,vertices,join,this,get,edges,where,0,equal,to,0,with,new,project,edge,with,src,value,k,vv,ev,join,this,get,vertices,where,1,equal,to,0,with,new,project,edge,with,vertex,values,k,vv,ev
Graph -> public DataSet<Triplet<K, VV, EV>> getTriplets();1466789678;This method allows access to the graph's edge values along with its source and target vertex values.__@return a triplet DataSet consisting of (srcVertexId, trgVertexId, srcVertexValue, trgVertexValue, edgeValue);public DataSet<Triplet<K, VV, EV>> getTriplets() {_		return this.getVertices().join(this.getEdges()).where(0).equalTo(0)_				.with(new ProjectEdgeWithSrcValue<K, VV, EV>())_				.join(this.getVertices()).where(1).equalTo(0)_				.with(new ProjectEdgeWithVertexValues<K, VV, EV>())__	};this,method,allows,access,to,the,graph,s,edge,values,along,with,its,source,and,target,vertex,values,return,a,triplet,data,set,consisting,of,src,vertex,id,trg,vertex,id,src,vertex,value,trg,vertex,value,edge,value;public,data,set,triplet,k,vv,ev,get,triplets,return,this,get,vertices,join,this,get,edges,where,0,equal,to,0,with,new,project,edge,with,src,value,k,vv,ev,join,this,get,vertices,where,1,equal,to,0,with,new,project,edge,with,vertex,values,k,vv,ev
Graph -> public DataSet<Triplet<K, VV, EV>> getTriplets();1467140656;This method allows access to the graph's edge values along with its source and target vertex values.__@return a triplet DataSet consisting of (srcVertexId, trgVertexId, srcVertexValue, trgVertexValue, edgeValue);public DataSet<Triplet<K, VV, EV>> getTriplets() {_		return this.getVertices().join(this.getEdges()).where(0).equalTo(0)_				.with(new ProjectEdgeWithSrcValue<K, VV, EV>())_				.join(this.getVertices()).where(1).equalTo(0)_				.with(new ProjectEdgeWithVertexValues<K, VV, EV>())__	};this,method,allows,access,to,the,graph,s,edge,values,along,with,its,source,and,target,vertex,values,return,a,triplet,data,set,consisting,of,src,vertex,id,trg,vertex,id,src,vertex,value,trg,vertex,value,edge,value;public,data,set,triplet,k,vv,ev,get,triplets,return,this,get,vertices,join,this,get,edges,where,0,equal,to,0,with,new,project,edge,with,src,value,k,vv,ev,join,this,get,vertices,where,1,equal,to,0,with,new,project,edge,with,vertex,values,k,vv,ev
Graph -> public DataSet<Triplet<K, VV, EV>> getTriplets();1467306272;This method allows access to the graph's edge values along with its source and target vertex values.__@return a triplet DataSet consisting of (srcVertexId, trgVertexId, srcVertexValue, trgVertexValue, edgeValue);public DataSet<Triplet<K, VV, EV>> getTriplets() {_		return this.getVertices().join(this.getEdges()).where(0).equalTo(0)_				.with(new ProjectEdgeWithSrcValue<K, VV, EV>())_				.join(this.getVertices()).where(1).equalTo(0)_				.with(new ProjectEdgeWithVertexValues<K, VV, EV>())__	};this,method,allows,access,to,the,graph,s,edge,values,along,with,its,source,and,target,vertex,values,return,a,triplet,data,set,consisting,of,src,vertex,id,trg,vertex,id,src,vertex,value,trg,vertex,value,edge,value;public,data,set,triplet,k,vv,ev,get,triplets,return,this,get,vertices,join,this,get,edges,where,0,equal,to,0,with,new,project,edge,with,src,value,k,vv,ev,join,this,get,vertices,where,1,equal,to,0,with,new,project,edge,with,vertex,values,k,vv,ev
Graph -> public DataSet<Triplet<K, VV, EV>> getTriplets();1470042815;This method allows access to the graph's edge values along with its source and target vertex values.__@return a triplet DataSet consisting of (srcVertexId, trgVertexId, srcVertexValue, trgVertexValue, edgeValue);public DataSet<Triplet<K, VV, EV>> getTriplets() {_		return this.getVertices().join(this.getEdges()).where(0).equalTo(0)_				.with(new ProjectEdgeWithSrcValue<K, VV, EV>())_				.join(this.getVertices()).where(1).equalTo(0)_				.with(new ProjectEdgeWithVertexValues<K, VV, EV>())__	};this,method,allows,access,to,the,graph,s,edge,values,along,with,its,source,and,target,vertex,values,return,a,triplet,data,set,consisting,of,src,vertex,id,trg,vertex,id,src,vertex,value,trg,vertex,value,edge,value;public,data,set,triplet,k,vv,ev,get,triplets,return,this,get,vertices,join,this,get,edges,where,0,equal,to,0,with,new,project,edge,with,src,value,k,vv,ev,join,this,get,vertices,where,1,equal,to,0,with,new,project,edge,with,vertex,values,k,vv,ev
Graph -> public DataSet<Triplet<K, VV, EV>> getTriplets();1475684776;This method allows access to the graph's edge values along with its source and target vertex values.__@return a triplet DataSet consisting of (srcVertexId, trgVertexId, srcVertexValue, trgVertexValue, edgeValue);public DataSet<Triplet<K, VV, EV>> getTriplets() {_		return this.getVertices().join(this.getEdges()).where(0).equalTo(0)_				.with(new ProjectEdgeWithSrcValue<K, VV, EV>())_				.join(this.getVertices()).where(1).equalTo(0)_				.with(new ProjectEdgeWithVertexValues<K, VV, EV>())__	};this,method,allows,access,to,the,graph,s,edge,values,along,with,its,source,and,target,vertex,values,return,a,triplet,data,set,consisting,of,src,vertex,id,trg,vertex,id,src,vertex,value,trg,vertex,value,edge,value;public,data,set,triplet,k,vv,ev,get,triplets,return,this,get,vertices,join,this,get,edges,where,0,equal,to,0,with,new,project,edge,with,src,value,k,vv,ev,join,this,get,vertices,where,1,equal,to,0,with,new,project,edge,with,vertex,values,k,vv,ev
Graph -> public DataSet<Triplet<K, VV, EV>> getTriplets();1475685606;This method allows access to the graph's edge values along with its source and target vertex values.__@return a triplet DataSet consisting of (srcVertexId, trgVertexId, srcVertexValue, trgVertexValue, edgeValue);public DataSet<Triplet<K, VV, EV>> getTriplets() {_		return this.getVertices().join(this.getEdges()).where(0).equalTo(0)_				.with(new ProjectEdgeWithSrcValue<K, VV, EV>())_				.join(this.getVertices()).where(1).equalTo(0)_				.with(new ProjectEdgeWithVertexValues<K, VV, EV>())__	};this,method,allows,access,to,the,graph,s,edge,values,along,with,its,source,and,target,vertex,values,return,a,triplet,data,set,consisting,of,src,vertex,id,trg,vertex,id,src,vertex,value,trg,vertex,value,edge,value;public,data,set,triplet,k,vv,ev,get,triplets,return,this,get,vertices,join,this,get,edges,where,0,equal,to,0,with,new,project,edge,with,src,value,k,vv,ev,join,this,get,vertices,where,1,equal,to,0,with,new,project,edge,with,vertex,values,k,vv,ev
Graph -> public DataSet<Triplet<K, VV, EV>> getTriplets();1481745825;This method allows access to the graph's edge values along with its source and target vertex values.__@return a triplet DataSet consisting of (srcVertexId, trgVertexId, srcVertexValue, trgVertexValue, edgeValue);public DataSet<Triplet<K, VV, EV>> getTriplets() {_		return this.getVertices()_			.join(this.getEdges()).where(0).equalTo(0)_			.with(new ProjectEdgeWithSrcValue<K, VV, EV>())_				.name("Project edge with source value")_			.join(this.getVertices()).where(1).equalTo(0)_			.with(new ProjectEdgeWithVertexValues<K, VV, EV>())_				.name("Project edge with vertex values")__	};this,method,allows,access,to,the,graph,s,edge,values,along,with,its,source,and,target,vertex,values,return,a,triplet,data,set,consisting,of,src,vertex,id,trg,vertex,id,src,vertex,value,trg,vertex,value,edge,value;public,data,set,triplet,k,vv,ev,get,triplets,return,this,get,vertices,join,this,get,edges,where,0,equal,to,0,with,new,project,edge,with,src,value,k,vv,ev,name,project,edge,with,source,value,join,this,get,vertices,where,1,equal,to,0,with,new,project,edge,with,vertex,values,k,vv,ev,name,project,edge,with,vertex,values
Graph -> public DataSet<Triplet<K, VV, EV>> getTriplets();1481881009;This method allows access to the graph's edge values along with its source and target vertex values.__@return a triplet DataSet consisting of (srcVertexId, trgVertexId, srcVertexValue, trgVertexValue, edgeValue);public DataSet<Triplet<K, VV, EV>> getTriplets() {_		return this.getVertices()_			.join(this.getEdges()).where(0).equalTo(0)_			.with(new ProjectEdgeWithSrcValue<K, VV, EV>())_				.name("Project edge with source value")_			.join(this.getVertices()).where(1).equalTo(0)_			.with(new ProjectEdgeWithVertexValues<K, VV, EV>())_				.name("Project edge with vertex values")__	};this,method,allows,access,to,the,graph,s,edge,values,along,with,its,source,and,target,vertex,values,return,a,triplet,data,set,consisting,of,src,vertex,id,trg,vertex,id,src,vertex,value,trg,vertex,value,edge,value;public,data,set,triplet,k,vv,ev,get,triplets,return,this,get,vertices,join,this,get,edges,where,0,equal,to,0,with,new,project,edge,with,src,value,k,vv,ev,name,project,edge,with,source,value,join,this,get,vertices,where,1,equal,to,0,with,new,project,edge,with,vertex,values,k,vv,ev,name,project,edge,with,vertex,values
Graph -> public DataSet<Triplet<K, VV, EV>> getTriplets();1484160227;This method allows access to the graph's edge values along with its source and target vertex values.__@return a triplet DataSet consisting of (srcVertexId, trgVertexId, srcVertexValue, trgVertexValue, edgeValue);public DataSet<Triplet<K, VV, EV>> getTriplets() {_		return this.getVertices()_			.join(this.getEdges()).where(0).equalTo(0)_			.with(new ProjectEdgeWithSrcValue<K, VV, EV>())_				.name("Project edge with source value")_			.join(this.getVertices()).where(1).equalTo(0)_			.with(new ProjectEdgeWithVertexValues<K, VV, EV>())_				.name("Project edge with vertex values")__	};this,method,allows,access,to,the,graph,s,edge,values,along,with,its,source,and,target,vertex,values,return,a,triplet,data,set,consisting,of,src,vertex,id,trg,vertex,id,src,vertex,value,trg,vertex,value,edge,value;public,data,set,triplet,k,vv,ev,get,triplets,return,this,get,vertices,join,this,get,edges,where,0,equal,to,0,with,new,project,edge,with,src,value,k,vv,ev,name,project,edge,with,source,value,join,this,get,vertices,where,1,equal,to,0,with,new,project,edge,with,vertex,values,k,vv,ev,name,project,edge,with,vertex,values
Graph -> public DataSet<Triplet<K, VV, EV>> getTriplets();1484685504;This method allows access to the graph's edge values along with its source and target vertex values.__@return a triplet DataSet consisting of (srcVertexId, trgVertexId, srcVertexValue, trgVertexValue, edgeValue);public DataSet<Triplet<K, VV, EV>> getTriplets() {_		return this.getVertices()_			.join(this.getEdges()).where(0).equalTo(0)_			.with(new ProjectEdgeWithSrcValue<K, VV, EV>())_				.name("Project edge with source value")_			.join(this.getVertices()).where(1).equalTo(0)_			.with(new ProjectEdgeWithVertexValues<K, VV, EV>())_				.name("Project edge with vertex values")__	};this,method,allows,access,to,the,graph,s,edge,values,along,with,its,source,and,target,vertex,values,return,a,triplet,data,set,consisting,of,src,vertex,id,trg,vertex,id,src,vertex,value,trg,vertex,value,edge,value;public,data,set,triplet,k,vv,ev,get,triplets,return,this,get,vertices,join,this,get,edges,where,0,equal,to,0,with,new,project,edge,with,src,value,k,vv,ev,name,project,edge,with,source,value,join,this,get,vertices,where,1,equal,to,0,with,new,project,edge,with,vertex,values,k,vv,ev,name,project,edge,with,vertex,values
Graph -> public DataSet<Triplet<K, VV, EV>> getTriplets();1489068942;This method allows access to the graph's edge values along with its source and target vertex values.__@return a triplet DataSet consisting of (srcVertexId, trgVertexId, srcVertexValue, trgVertexValue, edgeValue);public DataSet<Triplet<K, VV, EV>> getTriplets() {_		return this.getVertices()_			.join(this.getEdges()).where(0).equalTo(0)_			.with(new ProjectEdgeWithSrcValue<K, VV, EV>())_				.name("Project edge with source value")_			.join(this.getVertices()).where(1).equalTo(0)_			.with(new ProjectEdgeWithVertexValues<K, VV, EV>())_				.name("Project edge with vertex values")__	};this,method,allows,access,to,the,graph,s,edge,values,along,with,its,source,and,target,vertex,values,return,a,triplet,data,set,consisting,of,src,vertex,id,trg,vertex,id,src,vertex,value,trg,vertex,value,edge,value;public,data,set,triplet,k,vv,ev,get,triplets,return,this,get,vertices,join,this,get,edges,where,0,equal,to,0,with,new,project,edge,with,src,value,k,vv,ev,name,project,edge,with,source,value,join,this,get,vertices,where,1,equal,to,0,with,new,project,edge,with,vertex,values,k,vv,ev,name,project,edge,with,vertex,values
Graph -> public DataSet<Triplet<K, VV, EV>> getTriplets();1490973446;This method allows access to the graph's edge values along with its source and target vertex values.__@return a triplet DataSet consisting of (srcVertexId, trgVertexId, srcVertexValue, trgVertexValue, edgeValue);public DataSet<Triplet<K, VV, EV>> getTriplets() {_		return this.getVertices()_			.join(this.getEdges()).where(0).equalTo(0)_			.with(new ProjectEdgeWithSrcValue<K, VV, EV>())_				.name("Project edge with source value")_			.join(this.getVertices()).where(1).equalTo(0)_			.with(new ProjectEdgeWithVertexValues<K, VV, EV>())_				.name("Project edge with vertex values")__	};this,method,allows,access,to,the,graph,s,edge,values,along,with,its,source,and,target,vertex,values,return,a,triplet,data,set,consisting,of,src,vertex,id,trg,vertex,id,src,vertex,value,trg,vertex,value,edge,value;public,data,set,triplet,k,vv,ev,get,triplets,return,this,get,vertices,join,this,get,edges,where,0,equal,to,0,with,new,project,edge,with,src,value,k,vv,ev,name,project,edge,with,source,value,join,this,get,vertices,where,1,equal,to,0,with,new,project,edge,with,vertex,values,k,vv,ev,name,project,edge,with,vertex,values
Graph -> public DataSet<Triplet<K, VV, EV>> getTriplets();1495819075;This method allows access to the graph's edge values along with its source and target vertex values.__@return a triplet DataSet consisting of (srcVertexId, trgVertexId, srcVertexValue, trgVertexValue, edgeValue);public DataSet<Triplet<K, VV, EV>> getTriplets() {_		return this.getVertices()_			.join(this.getEdges()).where(0).equalTo(0)_			.with(new ProjectEdgeWithSrcValue<K, VV, EV>())_				.name("Project edge with source value")_			.join(this.getVertices()).where(1).equalTo(0)_			.with(new ProjectEdgeWithVertexValues<K, VV, EV>())_				.name("Project edge with vertex values")__	};this,method,allows,access,to,the,graph,s,edge,values,along,with,its,source,and,target,vertex,values,return,a,triplet,data,set,consisting,of,src,vertex,id,trg,vertex,id,src,vertex,value,trg,vertex,value,edge,value;public,data,set,triplet,k,vv,ev,get,triplets,return,this,get,vertices,join,this,get,edges,where,0,equal,to,0,with,new,project,edge,with,src,value,k,vv,ev,name,project,edge,with,source,value,join,this,get,vertices,where,1,equal,to,0,with,new,project,edge,with,vertex,values,k,vv,ev,name,project,edge,with,vertex,values
Graph -> public DataSet<Triplet<K, VV, EV>> getTriplets();1502111816;This method allows access to the graph's edge values along with its source and target vertex values.__@return a triplet DataSet consisting of (srcVertexId, trgVertexId, srcVertexValue, trgVertexValue, edgeValue);public DataSet<Triplet<K, VV, EV>> getTriplets() {_		return this.getVertices()_			.join(this.getEdges()).where(0).equalTo(0)_			.with(new ProjectEdgeWithSrcValue<>())_				.name("Project edge with source value")_			.join(this.getVertices()).where(1).equalTo(0)_			.with(new ProjectEdgeWithVertexValues<>())_				.name("Project edge with vertex values")__	};this,method,allows,access,to,the,graph,s,edge,values,along,with,its,source,and,target,vertex,values,return,a,triplet,data,set,consisting,of,src,vertex,id,trg,vertex,id,src,vertex,value,trg,vertex,value,edge,value;public,data,set,triplet,k,vv,ev,get,triplets,return,this,get,vertices,join,this,get,edges,where,0,equal,to,0,with,new,project,edge,with,src,value,name,project,edge,with,source,value,join,this,get,vertices,where,1,equal,to,0,with,new,project,edge,with,vertex,values,name,project,edge,with,vertex,values
Graph -> public <M> Graph<K, VV, EV> runGatherSumApplyIteration( 			org.apache.flink.graph.gsa.GatherFunction gatherFunction, SumFunction<VV, EV, M> sumFunction, 			ApplyFunction<K, VV, M> applyFunction, int maximumNumberOfIterations);1467306272;Runs a Gather-Sum-Apply iteration on the graph._No configuration options are provided.__@param gatherFunction the gather function collects information about adjacent vertices and edges_@param sumFunction the sum function aggregates the gathered information_@param applyFunction the apply function updates the vertex values with the aggregates_@param maximumNumberOfIterations maximum number of iterations to perform_@param <M> the intermediate type used between gather, sum and apply__@return the updated Graph after the gather-sum-apply iteration has converged or_after maximumNumberOfIterations.;public <M> Graph<K, VV, EV> runGatherSumApplyIteration(_			org.apache.flink.graph.gsa.GatherFunction gatherFunction, SumFunction<VV, EV, M> sumFunction,_			ApplyFunction<K, VV, M> applyFunction, int maximumNumberOfIterations) {__		return this.runGatherSumApplyIteration(gatherFunction, sumFunction, applyFunction,_				maximumNumberOfIterations, null)__	};runs,a,gather,sum,apply,iteration,on,the,graph,no,configuration,options,are,provided,param,gather,function,the,gather,function,collects,information,about,adjacent,vertices,and,edges,param,sum,function,the,sum,function,aggregates,the,gathered,information,param,apply,function,the,apply,function,updates,the,vertex,values,with,the,aggregates,param,maximum,number,of,iterations,maximum,number,of,iterations,to,perform,param,m,the,intermediate,type,used,between,gather,sum,and,apply,return,the,updated,graph,after,the,gather,sum,apply,iteration,has,converged,or,after,maximum,number,of,iterations;public,m,graph,k,vv,ev,run,gather,sum,apply,iteration,org,apache,flink,graph,gsa,gather,function,gather,function,sum,function,vv,ev,m,sum,function,apply,function,k,vv,m,apply,function,int,maximum,number,of,iterations,return,this,run,gather,sum,apply,iteration,gather,function,sum,function,apply,function,maximum,number,of,iterations,null
Graph -> public <M> Graph<K, VV, EV> runGatherSumApplyIteration( 			org.apache.flink.graph.gsa.GatherFunction gatherFunction, SumFunction<VV, EV, M> sumFunction, 			ApplyFunction<K, VV, M> applyFunction, int maximumNumberOfIterations);1470042815;Runs a Gather-Sum-Apply iteration on the graph._No configuration options are provided.__@param gatherFunction the gather function collects information about adjacent vertices and edges_@param sumFunction the sum function aggregates the gathered information_@param applyFunction the apply function updates the vertex values with the aggregates_@param maximumNumberOfIterations maximum number of iterations to perform_@param <M> the intermediate type used between gather, sum and apply__@return the updated Graph after the gather-sum-apply iteration has converged or_after maximumNumberOfIterations.;public <M> Graph<K, VV, EV> runGatherSumApplyIteration(_			org.apache.flink.graph.gsa.GatherFunction gatherFunction, SumFunction<VV, EV, M> sumFunction,_			ApplyFunction<K, VV, M> applyFunction, int maximumNumberOfIterations) {__		return this.runGatherSumApplyIteration(gatherFunction, sumFunction, applyFunction,_				maximumNumberOfIterations, null)__	};runs,a,gather,sum,apply,iteration,on,the,graph,no,configuration,options,are,provided,param,gather,function,the,gather,function,collects,information,about,adjacent,vertices,and,edges,param,sum,function,the,sum,function,aggregates,the,gathered,information,param,apply,function,the,apply,function,updates,the,vertex,values,with,the,aggregates,param,maximum,number,of,iterations,maximum,number,of,iterations,to,perform,param,m,the,intermediate,type,used,between,gather,sum,and,apply,return,the,updated,graph,after,the,gather,sum,apply,iteration,has,converged,or,after,maximum,number,of,iterations;public,m,graph,k,vv,ev,run,gather,sum,apply,iteration,org,apache,flink,graph,gsa,gather,function,gather,function,sum,function,vv,ev,m,sum,function,apply,function,k,vv,m,apply,function,int,maximum,number,of,iterations,return,this,run,gather,sum,apply,iteration,gather,function,sum,function,apply,function,maximum,number,of,iterations,null
Graph -> public <NV> Graph<K, VV, NV> mapEdges(final MapFunction<Edge<K, EV>, NV> mapper, TypeInformation<Edge<K, NV>> returnType);1484685504;Apply a function to the attribute of each edge in the graph.__@param mapper the map function to apply._@param returnType the explicit return type._@return a new graph;public <NV> Graph<K, VV, NV> mapEdges(final MapFunction<Edge<K, EV>, NV> mapper, TypeInformation<Edge<K, NV>> returnType) {_		DataSet<Edge<K, NV>> mappedEdges = edges.map(_			new MapFunction<Edge<K, EV>, Edge<K, NV>>() {_				private Edge<K, NV> output = new Edge<>()___				public Edge<K, NV> map(Edge<K, EV> value) throws Exception {_					output.f0 = value.f0__					output.f1 = value.f1__					output.f2 = mapper.map(value)__					return output__				}_			})_			.returns(returnType)_			.withForwardedFields("f0_ f1")_				.name("Map edges")___		return new Graph<>(this.vertices, mappedEdges, this.context)__	};apply,a,function,to,the,attribute,of,each,edge,in,the,graph,param,mapper,the,map,function,to,apply,param,return,type,the,explicit,return,type,return,a,new,graph;public,nv,graph,k,vv,nv,map,edges,final,map,function,edge,k,ev,nv,mapper,type,information,edge,k,nv,return,type,data,set,edge,k,nv,mapped,edges,edges,map,new,map,function,edge,k,ev,edge,k,nv,private,edge,k,nv,output,new,edge,public,edge,k,nv,map,edge,k,ev,value,throws,exception,output,f0,value,f0,output,f1,value,f1,output,f2,mapper,map,value,return,output,returns,return,type,with,forwarded,fields,f0,f1,name,map,edges,return,new,graph,this,vertices,mapped,edges,this,context
Graph -> public <NV> Graph<K, VV, NV> mapEdges(final MapFunction<Edge<K, EV>, NV> mapper, TypeInformation<Edge<K, NV>> returnType);1489068942;Apply a function to the attribute of each edge in the graph.__@param mapper the map function to apply._@param returnType the explicit return type._@return a new graph;public <NV> Graph<K, VV, NV> mapEdges(final MapFunction<Edge<K, EV>, NV> mapper, TypeInformation<Edge<K, NV>> returnType) {_		DataSet<Edge<K, NV>> mappedEdges = edges.map(_			new MapFunction<Edge<K, EV>, Edge<K, NV>>() {_				private Edge<K, NV> output = new Edge<>()___				public Edge<K, NV> map(Edge<K, EV> value) throws Exception {_					output.f0 = value.f0__					output.f1 = value.f1__					output.f2 = mapper.map(value)__					return output__				}_			})_			.returns(returnType)_			.withForwardedFields("f0_ f1")_				.name("Map edges")___		return new Graph<>(this.vertices, mappedEdges, this.context)__	};apply,a,function,to,the,attribute,of,each,edge,in,the,graph,param,mapper,the,map,function,to,apply,param,return,type,the,explicit,return,type,return,a,new,graph;public,nv,graph,k,vv,nv,map,edges,final,map,function,edge,k,ev,nv,mapper,type,information,edge,k,nv,return,type,data,set,edge,k,nv,mapped,edges,edges,map,new,map,function,edge,k,ev,edge,k,nv,private,edge,k,nv,output,new,edge,public,edge,k,nv,map,edge,k,ev,value,throws,exception,output,f0,value,f0,output,f1,value,f1,output,f2,mapper,map,value,return,output,returns,return,type,with,forwarded,fields,f0,f1,name,map,edges,return,new,graph,this,vertices,mapped,edges,this,context
Graph -> public <NV> Graph<K, VV, NV> mapEdges(final MapFunction<Edge<K, EV>, NV> mapper, TypeInformation<Edge<K, NV>> returnType);1490973446;Apply a function to the attribute of each edge in the graph.__@param mapper the map function to apply._@param returnType the explicit return type._@return a new graph;public <NV> Graph<K, VV, NV> mapEdges(final MapFunction<Edge<K, EV>, NV> mapper, TypeInformation<Edge<K, NV>> returnType) {_		DataSet<Edge<K, NV>> mappedEdges = edges.map(_			new MapFunction<Edge<K, EV>, Edge<K, NV>>() {_				private Edge<K, NV> output = new Edge<>()___				public Edge<K, NV> map(Edge<K, EV> value) throws Exception {_					output.f0 = value.f0__					output.f1 = value.f1__					output.f2 = mapper.map(value)__					return output__				}_			})_			.returns(returnType)_			.withForwardedFields("f0_ f1")_				.name("Map edges")___		return new Graph<>(this.vertices, mappedEdges, this.context)__	};apply,a,function,to,the,attribute,of,each,edge,in,the,graph,param,mapper,the,map,function,to,apply,param,return,type,the,explicit,return,type,return,a,new,graph;public,nv,graph,k,vv,nv,map,edges,final,map,function,edge,k,ev,nv,mapper,type,information,edge,k,nv,return,type,data,set,edge,k,nv,mapped,edges,edges,map,new,map,function,edge,k,ev,edge,k,nv,private,edge,k,nv,output,new,edge,public,edge,k,nv,map,edge,k,ev,value,throws,exception,output,f0,value,f0,output,f1,value,f1,output,f2,mapper,map,value,return,output,returns,return,type,with,forwarded,fields,f0,f1,name,map,edges,return,new,graph,this,vertices,mapped,edges,this,context
Graph -> public <NV> Graph<K, VV, NV> mapEdges(final MapFunction<Edge<K, EV>, NV> mapper, TypeInformation<Edge<K, NV>> returnType);1495819075;Apply a function to the attribute of each edge in the graph.__@param mapper the map function to apply._@param returnType the explicit return type._@return a new graph;public <NV> Graph<K, VV, NV> mapEdges(final MapFunction<Edge<K, EV>, NV> mapper, TypeInformation<Edge<K, NV>> returnType) {_		DataSet<Edge<K, NV>> mappedEdges = edges.map(_			new MapFunction<Edge<K, EV>, Edge<K, NV>>() {_				private Edge<K, NV> output = new Edge<>()___				public Edge<K, NV> map(Edge<K, EV> value) throws Exception {_					output.f0 = value.f0__					output.f1 = value.f1__					output.f2 = mapper.map(value)__					return output__				}_			})_			.returns(returnType)_			.withForwardedFields("f0_ f1")_				.name("Map edges")___		return new Graph<>(this.vertices, mappedEdges, this.context)__	};apply,a,function,to,the,attribute,of,each,edge,in,the,graph,param,mapper,the,map,function,to,apply,param,return,type,the,explicit,return,type,return,a,new,graph;public,nv,graph,k,vv,nv,map,edges,final,map,function,edge,k,ev,nv,mapper,type,information,edge,k,nv,return,type,data,set,edge,k,nv,mapped,edges,edges,map,new,map,function,edge,k,ev,edge,k,nv,private,edge,k,nv,output,new,edge,public,edge,k,nv,map,edge,k,ev,value,throws,exception,output,f0,value,f0,output,f1,value,f1,output,f2,mapper,map,value,return,output,returns,return,type,with,forwarded,fields,f0,f1,name,map,edges,return,new,graph,this,vertices,mapped,edges,this,context
Graph -> public <NV> Graph<K, VV, NV> mapEdges(final MapFunction<Edge<K, EV>, NV> mapper, TypeInformation<Edge<K, NV>> returnType);1502111816;Apply a function to the attribute of each edge in the graph.__@param mapper the map function to apply._@param returnType the explicit return type._@return a new graph;public <NV> Graph<K, VV, NV> mapEdges(final MapFunction<Edge<K, EV>, NV> mapper, TypeInformation<Edge<K, NV>> returnType) {_		DataSet<Edge<K, NV>> mappedEdges = edges.map(_			new MapFunction<Edge<K, EV>, Edge<K, NV>>() {_				private Edge<K, NV> output = new Edge<>()___				public Edge<K, NV> map(Edge<K, EV> value) throws Exception {_					output.f0 = value.f0__					output.f1 = value.f1__					output.f2 = mapper.map(value)__					return output__				}_			})_			.returns(returnType)_			.withForwardedFields("f0_ f1")_				.name("Map edges")___		return new Graph<>(this.vertices, mappedEdges, this.context)__	};apply,a,function,to,the,attribute,of,each,edge,in,the,graph,param,mapper,the,map,function,to,apply,param,return,type,the,explicit,return,type,return,a,new,graph;public,nv,graph,k,vv,nv,map,edges,final,map,function,edge,k,ev,nv,mapper,type,information,edge,k,nv,return,type,data,set,edge,k,nv,mapped,edges,edges,map,new,map,function,edge,k,ev,edge,k,nv,private,edge,k,nv,output,new,edge,public,edge,k,nv,map,edge,k,ev,value,throws,exception,output,f0,value,f0,output,f1,value,f1,output,f2,mapper,map,value,return,output,returns,return,type,with,forwarded,fields,f0,f1,name,map,edges,return,new,graph,this,vertices,mapped,edges,this,context
Graph -> public <M> Graph<K, VV, EV> runVertexCentricIteration( 			ComputeFunction<K, VV, EV, M> computeFunction, 			MessageCombiner<K, M> combiner, int maximumNumberOfIterations);1495819075;Runs a {@link VertexCentricIteration} on the graph._No configuration options are provided.__@param computeFunction the vertex compute function_@param combiner an optional message combiner_@param maximumNumberOfIterations maximum number of iterations to perform__@return the updated Graph after the vertex-centric iteration has converged or_after maximumNumberOfIterations.;public <M> Graph<K, VV, EV> runVertexCentricIteration(_			ComputeFunction<K, VV, EV, M> computeFunction,_			MessageCombiner<K, M> combiner, int maximumNumberOfIterations) {__		return this.runVertexCentricIteration(computeFunction, combiner, maximumNumberOfIterations, null)__	};runs,a,link,vertex,centric,iteration,on,the,graph,no,configuration,options,are,provided,param,compute,function,the,vertex,compute,function,param,combiner,an,optional,message,combiner,param,maximum,number,of,iterations,maximum,number,of,iterations,to,perform,return,the,updated,graph,after,the,vertex,centric,iteration,has,converged,or,after,maximum,number,of,iterations;public,m,graph,k,vv,ev,run,vertex,centric,iteration,compute,function,k,vv,ev,m,compute,function,message,combiner,k,m,combiner,int,maximum,number,of,iterations,return,this,run,vertex,centric,iteration,compute,function,combiner,maximum,number,of,iterations,null
Graph -> public <M> Graph<K, VV, EV> runVertexCentricIteration( 			ComputeFunction<K, VV, EV, M> computeFunction, 			MessageCombiner<K, M> combiner, int maximumNumberOfIterations);1502111816;Runs a {@link VertexCentricIteration} on the graph._No configuration options are provided.__@param computeFunction the vertex compute function_@param combiner an optional message combiner_@param maximumNumberOfIterations maximum number of iterations to perform__@return the updated Graph after the vertex-centric iteration has converged or_after maximumNumberOfIterations.;public <M> Graph<K, VV, EV> runVertexCentricIteration(_			ComputeFunction<K, VV, EV, M> computeFunction,_			MessageCombiner<K, M> combiner, int maximumNumberOfIterations) {__		return this.runVertexCentricIteration(computeFunction, combiner, maximumNumberOfIterations, null)__	};runs,a,link,vertex,centric,iteration,on,the,graph,no,configuration,options,are,provided,param,compute,function,the,vertex,compute,function,param,combiner,an,optional,message,combiner,param,maximum,number,of,iterations,maximum,number,of,iterations,to,perform,return,the,updated,graph,after,the,vertex,centric,iteration,has,converged,or,after,maximum,number,of,iterations;public,m,graph,k,vv,ev,run,vertex,centric,iteration,compute,function,k,vv,ev,m,compute,function,message,combiner,k,m,combiner,int,maximum,number,of,iterations,return,this,run,vertex,centric,iteration,compute,function,combiner,maximum,number,of,iterations,null
Graph -> @SuppressWarnings({ "unchecked", "rawtypes" }) 	public <NV> Graph<K, NV, EV> mapVertices(final MapFunction<Vertex<K, VV>, NV> mapper);1444404795;Apply a function to the attribute of each vertex in the graph.__@param mapper the map function to apply._@return a new graph;@SuppressWarnings({ "unchecked", "rawtypes" })_	public <NV> Graph<K, NV, EV> mapVertices(final MapFunction<Vertex<K, VV>, NV> mapper) {__		TypeInformation<K> keyType = ((TupleTypeInfo<?>) vertices.getType()).getTypeAt(0)___		TypeInformation<NV> valueType = TypeExtractor.createTypeInfo(MapFunction.class, mapper.getClass(), 1, null, null)___		TypeInformation<Vertex<K, NV>> returnType = (TypeInformation<Vertex<K, NV>>) new TupleTypeInfo(_				Vertex.class, keyType, valueType)___		return mapVertices(mapper, returnType)__	};apply,a,function,to,the,attribute,of,each,vertex,in,the,graph,param,mapper,the,map,function,to,apply,return,a,new,graph;suppress,warnings,unchecked,rawtypes,public,nv,graph,k,nv,ev,map,vertices,final,map,function,vertex,k,vv,nv,mapper,type,information,k,key,type,tuple,type,info,vertices,get,type,get,type,at,0,type,information,nv,value,type,type,extractor,create,type,info,map,function,class,mapper,get,class,1,null,null,type,information,vertex,k,nv,return,type,type,information,vertex,k,nv,new,tuple,type,info,vertex,class,key,type,value,type,return,map,vertices,mapper,return,type
Graph -> @SuppressWarnings({ "unchecked", "rawtypes" }) 	public <NV> Graph<K, NV, EV> mapVertices(final MapFunction<Vertex<K, VV>, NV> mapper);1445261977;Apply a function to the attribute of each vertex in the graph.__@param mapper the map function to apply._@return a new graph;@SuppressWarnings({ "unchecked", "rawtypes" })_	public <NV> Graph<K, NV, EV> mapVertices(final MapFunction<Vertex<K, VV>, NV> mapper) {__		TypeInformation<K> keyType = ((TupleTypeInfo<?>) vertices.getType()).getTypeAt(0)___		TypeInformation<NV> valueType = TypeExtractor.createTypeInfo(MapFunction.class, mapper.getClass(), 1, null, null)___		TypeInformation<Vertex<K, NV>> returnType = (TypeInformation<Vertex<K, NV>>) new TupleTypeInfo(_				Vertex.class, keyType, valueType)___		return mapVertices(mapper, returnType)__	};apply,a,function,to,the,attribute,of,each,vertex,in,the,graph,param,mapper,the,map,function,to,apply,return,a,new,graph;suppress,warnings,unchecked,rawtypes,public,nv,graph,k,nv,ev,map,vertices,final,map,function,vertex,k,vv,nv,mapper,type,information,k,key,type,tuple,type,info,vertices,get,type,get,type,at,0,type,information,nv,value,type,type,extractor,create,type,info,map,function,class,mapper,get,class,1,null,null,type,information,vertex,k,nv,return,type,type,information,vertex,k,nv,new,tuple,type,info,vertex,class,key,type,value,type,return,map,vertices,mapper,return,type
Graph -> @SuppressWarnings({ "unchecked", "rawtypes" }) 	public <NV> Graph<K, NV, EV> mapVertices(final MapFunction<Vertex<K, VV>, NV> mapper);1445854323;Apply a function to the attribute of each vertex in the graph.__@param mapper the map function to apply._@return a new graph;@SuppressWarnings({ "unchecked", "rawtypes" })_	public <NV> Graph<K, NV, EV> mapVertices(final MapFunction<Vertex<K, VV>, NV> mapper) {__		TypeInformation<K> keyType = ((TupleTypeInfo<?>) vertices.getType()).getTypeAt(0)___		TypeInformation<NV> valueType = TypeExtractor.createTypeInfo(MapFunction.class, mapper.getClass(), 1, null, null)___		TypeInformation<Vertex<K, NV>> returnType = (TypeInformation<Vertex<K, NV>>) new TupleTypeInfo(_				Vertex.class, keyType, valueType)___		return mapVertices(mapper, returnType)__	};apply,a,function,to,the,attribute,of,each,vertex,in,the,graph,param,mapper,the,map,function,to,apply,return,a,new,graph;suppress,warnings,unchecked,rawtypes,public,nv,graph,k,nv,ev,map,vertices,final,map,function,vertex,k,vv,nv,mapper,type,information,k,key,type,tuple,type,info,vertices,get,type,get,type,at,0,type,information,nv,value,type,type,extractor,create,type,info,map,function,class,mapper,get,class,1,null,null,type,information,vertex,k,nv,return,type,type,information,vertex,k,nv,new,tuple,type,info,vertex,class,key,type,value,type,return,map,vertices,mapper,return,type
Graph -> @SuppressWarnings({ "unchecked", "rawtypes" }) 	public <NV> Graph<K, NV, EV> mapVertices(final MapFunction<Vertex<K, VV>, NV> mapper);1446112342;Apply a function to the attribute of each vertex in the graph.__@param mapper the map function to apply._@return a new graph;@SuppressWarnings({ "unchecked", "rawtypes" })_	public <NV> Graph<K, NV, EV> mapVertices(final MapFunction<Vertex<K, VV>, NV> mapper) {__		TypeInformation<K> keyType = ((TupleTypeInfo<?>) vertices.getType()).getTypeAt(0)___		TypeInformation<NV> valueType = TypeExtractor.createTypeInfo(MapFunction.class, mapper.getClass(), 1, null, null)___		TypeInformation<Vertex<K, NV>> returnType = (TypeInformation<Vertex<K, NV>>) new TupleTypeInfo(_				Vertex.class, keyType, valueType)___		return mapVertices(mapper, returnType)__	};apply,a,function,to,the,attribute,of,each,vertex,in,the,graph,param,mapper,the,map,function,to,apply,return,a,new,graph;suppress,warnings,unchecked,rawtypes,public,nv,graph,k,nv,ev,map,vertices,final,map,function,vertex,k,vv,nv,mapper,type,information,k,key,type,tuple,type,info,vertices,get,type,get,type,at,0,type,information,nv,value,type,type,extractor,create,type,info,map,function,class,mapper,get,class,1,null,null,type,information,vertex,k,nv,return,type,type,information,vertex,k,nv,new,tuple,type,info,vertex,class,key,type,value,type,return,map,vertices,mapper,return,type
Graph -> @SuppressWarnings({ "unchecked", "rawtypes" }) 	public <NV> Graph<K, NV, EV> mapVertices(final MapFunction<Vertex<K, VV>, NV> mapper);1447073368;Apply a function to the attribute of each vertex in the graph.__@param mapper the map function to apply._@return a new graph;@SuppressWarnings({ "unchecked", "rawtypes" })_	public <NV> Graph<K, NV, EV> mapVertices(final MapFunction<Vertex<K, VV>, NV> mapper) {__		TypeInformation<K> keyType = ((TupleTypeInfo<?>) vertices.getType()).getTypeAt(0)___		TypeInformation<NV> valueType = TypeExtractor.createTypeInfo(MapFunction.class, mapper.getClass(), 1, null, null)___		TypeInformation<Vertex<K, NV>> returnType = (TypeInformation<Vertex<K, NV>>) new TupleTypeInfo(_				Vertex.class, keyType, valueType)___		return mapVertices(mapper, returnType)__	};apply,a,function,to,the,attribute,of,each,vertex,in,the,graph,param,mapper,the,map,function,to,apply,return,a,new,graph;suppress,warnings,unchecked,rawtypes,public,nv,graph,k,nv,ev,map,vertices,final,map,function,vertex,k,vv,nv,mapper,type,information,k,key,type,tuple,type,info,vertices,get,type,get,type,at,0,type,information,nv,value,type,type,extractor,create,type,info,map,function,class,mapper,get,class,1,null,null,type,information,vertex,k,nv,return,type,type,information,vertex,k,nv,new,tuple,type,info,vertex,class,key,type,value,type,return,map,vertices,mapper,return,type
Graph -> @SuppressWarnings({ "unchecked", "rawtypes" }) 	public <NV> Graph<K, NV, EV> mapVertices(final MapFunction<Vertex<K, VV>, NV> mapper);1454404649;Apply a function to the attribute of each vertex in the graph.__@param mapper the map function to apply._@return a new graph;@SuppressWarnings({ "unchecked", "rawtypes" })_	public <NV> Graph<K, NV, EV> mapVertices(final MapFunction<Vertex<K, VV>, NV> mapper) {__		TypeInformation<K> keyType = ((TupleTypeInfo<?>) vertices.getType()).getTypeAt(0)___		TypeInformation<NV> valueType = TypeExtractor.createTypeInfo(MapFunction.class, mapper.getClass(), 1, null, null)___		TypeInformation<Vertex<K, NV>> returnType = (TypeInformation<Vertex<K, NV>>) new TupleTypeInfo(_				Vertex.class, keyType, valueType)___		return mapVertices(mapper, returnType)__	};apply,a,function,to,the,attribute,of,each,vertex,in,the,graph,param,mapper,the,map,function,to,apply,return,a,new,graph;suppress,warnings,unchecked,rawtypes,public,nv,graph,k,nv,ev,map,vertices,final,map,function,vertex,k,vv,nv,mapper,type,information,k,key,type,tuple,type,info,vertices,get,type,get,type,at,0,type,information,nv,value,type,type,extractor,create,type,info,map,function,class,mapper,get,class,1,null,null,type,information,vertex,k,nv,return,type,type,information,vertex,k,nv,new,tuple,type,info,vertex,class,key,type,value,type,return,map,vertices,mapper,return,type
Graph -> @SuppressWarnings({ "unchecked", "rawtypes" }) 	public <NV> Graph<K, NV, EV> mapVertices(final MapFunction<Vertex<K, VV>, NV> mapper);1458583829;Apply a function to the attribute of each vertex in the graph.__@param mapper the map function to apply._@return a new graph;@SuppressWarnings({ "unchecked", "rawtypes" })_	public <NV> Graph<K, NV, EV> mapVertices(final MapFunction<Vertex<K, VV>, NV> mapper) {__		TypeInformation<K> keyType = ((TupleTypeInfo<?>) vertices.getType()).getTypeAt(0)___		TypeInformation<NV> valueType = TypeExtractor.createTypeInfo(MapFunction.class, mapper.getClass(), 1, null, null)___		TypeInformation<Vertex<K, NV>> returnType = (TypeInformation<Vertex<K, NV>>) new TupleTypeInfo(_				Vertex.class, keyType, valueType)___		return mapVertices(mapper, returnType)__	};apply,a,function,to,the,attribute,of,each,vertex,in,the,graph,param,mapper,the,map,function,to,apply,return,a,new,graph;suppress,warnings,unchecked,rawtypes,public,nv,graph,k,nv,ev,map,vertices,final,map,function,vertex,k,vv,nv,mapper,type,information,k,key,type,tuple,type,info,vertices,get,type,get,type,at,0,type,information,nv,value,type,type,extractor,create,type,info,map,function,class,mapper,get,class,1,null,null,type,information,vertex,k,nv,return,type,type,information,vertex,k,nv,new,tuple,type,info,vertex,class,key,type,value,type,return,map,vertices,mapper,return,type
Graph -> @SuppressWarnings({ "unchecked", "rawtypes" }) 	public <NV> Graph<K, NV, EV> mapVertices(final MapFunction<Vertex<K, VV>, NV> mapper);1458583829;Apply a function to the attribute of each vertex in the graph.__@param mapper the map function to apply._@return a new graph;@SuppressWarnings({ "unchecked", "rawtypes" })_	public <NV> Graph<K, NV, EV> mapVertices(final MapFunction<Vertex<K, VV>, NV> mapper) {__		TypeInformation<K> keyType = ((TupleTypeInfo<?>) vertices.getType()).getTypeAt(0)___		TypeInformation<NV> valueType = TypeExtractor.createTypeInfo(MapFunction.class, mapper.getClass(), 1, null, null)___		TypeInformation<Vertex<K, NV>> returnType = (TypeInformation<Vertex<K, NV>>) new TupleTypeInfo(_				Vertex.class, keyType, valueType)___		return mapVertices(mapper, returnType)__	};apply,a,function,to,the,attribute,of,each,vertex,in,the,graph,param,mapper,the,map,function,to,apply,return,a,new,graph;suppress,warnings,unchecked,rawtypes,public,nv,graph,k,nv,ev,map,vertices,final,map,function,vertex,k,vv,nv,mapper,type,information,k,key,type,tuple,type,info,vertices,get,type,get,type,at,0,type,information,nv,value,type,type,extractor,create,type,info,map,function,class,mapper,get,class,1,null,null,type,information,vertex,k,nv,return,type,type,information,vertex,k,nv,new,tuple,type,info,vertex,class,key,type,value,type,return,map,vertices,mapper,return,type
Graph -> @SuppressWarnings({ "unchecked", "rawtypes" }) 	public <NV> Graph<K, NV, EV> mapVertices(final MapFunction<Vertex<K, VV>, NV> mapper);1462100316;Apply a function to the attribute of each vertex in the graph.__@param mapper the map function to apply._@return a new graph;@SuppressWarnings({ "unchecked", "rawtypes" })_	public <NV> Graph<K, NV, EV> mapVertices(final MapFunction<Vertex<K, VV>, NV> mapper) {__		TypeInformation<K> keyType = ((TupleTypeInfo<?>) vertices.getType()).getTypeAt(0)___		TypeInformation<NV> valueType = TypeExtractor.createTypeInfo(MapFunction.class, mapper.getClass(), 1, null, null)___		TypeInformation<Vertex<K, NV>> returnType = (TypeInformation<Vertex<K, NV>>) new TupleTypeInfo(_				Vertex.class, keyType, valueType)___		return mapVertices(mapper, returnType)__	};apply,a,function,to,the,attribute,of,each,vertex,in,the,graph,param,mapper,the,map,function,to,apply,return,a,new,graph;suppress,warnings,unchecked,rawtypes,public,nv,graph,k,nv,ev,map,vertices,final,map,function,vertex,k,vv,nv,mapper,type,information,k,key,type,tuple,type,info,vertices,get,type,get,type,at,0,type,information,nv,value,type,type,extractor,create,type,info,map,function,class,mapper,get,class,1,null,null,type,information,vertex,k,nv,return,type,type,information,vertex,k,nv,new,tuple,type,info,vertex,class,key,type,value,type,return,map,vertices,mapper,return,type
Graph -> @SuppressWarnings({ "unchecked", "rawtypes" }) 	public <NV> Graph<K, NV, EV> mapVertices(final MapFunction<Vertex<K, VV>, NV> mapper);1462100316;Apply a function to the attribute of each vertex in the graph.__@param mapper the map function to apply._@return a new graph;@SuppressWarnings({ "unchecked", "rawtypes" })_	public <NV> Graph<K, NV, EV> mapVertices(final MapFunction<Vertex<K, VV>, NV> mapper) {__		TypeInformation<K> keyType = ((TupleTypeInfo<?>) vertices.getType()).getTypeAt(0)___		TypeInformation<NV> valueType = TypeExtractor.createTypeInfo(MapFunction.class, mapper.getClass(), 1, null, null)___		TypeInformation<Vertex<K, NV>> returnType = (TypeInformation<Vertex<K, NV>>) new TupleTypeInfo(_				Vertex.class, keyType, valueType)___		return mapVertices(mapper, returnType)__	};apply,a,function,to,the,attribute,of,each,vertex,in,the,graph,param,mapper,the,map,function,to,apply,return,a,new,graph;suppress,warnings,unchecked,rawtypes,public,nv,graph,k,nv,ev,map,vertices,final,map,function,vertex,k,vv,nv,mapper,type,information,k,key,type,tuple,type,info,vertices,get,type,get,type,at,0,type,information,nv,value,type,type,extractor,create,type,info,map,function,class,mapper,get,class,1,null,null,type,information,vertex,k,nv,return,type,type,information,vertex,k,nv,new,tuple,type,info,vertex,class,key,type,value,type,return,map,vertices,mapper,return,type
Graph -> @SuppressWarnings({ "unchecked", "rawtypes" }) 	public <NV> Graph<K, NV, EV> mapVertices(final MapFunction<Vertex<K, VV>, NV> mapper);1462205213;Apply a function to the attribute of each vertex in the graph.__@param mapper the map function to apply._@return a new graph;@SuppressWarnings({ "unchecked", "rawtypes" })_	public <NV> Graph<K, NV, EV> mapVertices(final MapFunction<Vertex<K, VV>, NV> mapper) {__		TypeInformation<K> keyType = ((TupleTypeInfo<?>) vertices.getType()).getTypeAt(0)___		TypeInformation<NV> valueType = TypeExtractor.createTypeInfo(MapFunction.class, mapper.getClass(), 1, null, null)___		TypeInformation<Vertex<K, NV>> returnType = (TypeInformation<Vertex<K, NV>>) new TupleTypeInfo(_				Vertex.class, keyType, valueType)___		return mapVertices(mapper, returnType)__	};apply,a,function,to,the,attribute,of,each,vertex,in,the,graph,param,mapper,the,map,function,to,apply,return,a,new,graph;suppress,warnings,unchecked,rawtypes,public,nv,graph,k,nv,ev,map,vertices,final,map,function,vertex,k,vv,nv,mapper,type,information,k,key,type,tuple,type,info,vertices,get,type,get,type,at,0,type,information,nv,value,type,type,extractor,create,type,info,map,function,class,mapper,get,class,1,null,null,type,information,vertex,k,nv,return,type,type,information,vertex,k,nv,new,tuple,type,info,vertex,class,key,type,value,type,return,map,vertices,mapper,return,type
Graph -> @SuppressWarnings({ "unchecked", "rawtypes" }) 	public <NV> Graph<K, NV, EV> mapVertices(final MapFunction<Vertex<K, VV>, NV> mapper);1462208859;Apply a function to the attribute of each vertex in the graph.__@param mapper the map function to apply._@return a new graph;@SuppressWarnings({ "unchecked", "rawtypes" })_	public <NV> Graph<K, NV, EV> mapVertices(final MapFunction<Vertex<K, VV>, NV> mapper) {__		TypeInformation<K> keyType = ((TupleTypeInfo<?>) vertices.getType()).getTypeAt(0)___		TypeInformation<NV> valueType = TypeExtractor.createTypeInfo(MapFunction.class, mapper.getClass(), 1, null, null)___		TypeInformation<Vertex<K, NV>> returnType = (TypeInformation<Vertex<K, NV>>) new TupleTypeInfo(_				Vertex.class, keyType, valueType)___		return mapVertices(mapper, returnType)__	};apply,a,function,to,the,attribute,of,each,vertex,in,the,graph,param,mapper,the,map,function,to,apply,return,a,new,graph;suppress,warnings,unchecked,rawtypes,public,nv,graph,k,nv,ev,map,vertices,final,map,function,vertex,k,vv,nv,mapper,type,information,k,key,type,tuple,type,info,vertices,get,type,get,type,at,0,type,information,nv,value,type,type,extractor,create,type,info,map,function,class,mapper,get,class,1,null,null,type,information,vertex,k,nv,return,type,type,information,vertex,k,nv,new,tuple,type,info,vertex,class,key,type,value,type,return,map,vertices,mapper,return,type
Graph -> @SuppressWarnings({ "unchecked", "rawtypes" }) 	public <NV> Graph<K, NV, EV> mapVertices(final MapFunction<Vertex<K, VV>, NV> mapper);1462809297;Apply a function to the attribute of each vertex in the graph.__@param mapper the map function to apply._@return a new graph;@SuppressWarnings({ "unchecked", "rawtypes" })_	public <NV> Graph<K, NV, EV> mapVertices(final MapFunction<Vertex<K, VV>, NV> mapper) {__		TypeInformation<K> keyType = ((TupleTypeInfo<?>) vertices.getType()).getTypeAt(0)___		TypeInformation<NV> valueType = TypeExtractor.createTypeInfo(MapFunction.class, mapper.getClass(), 1, null, null)___		TypeInformation<Vertex<K, NV>> returnType = (TypeInformation<Vertex<K, NV>>) new TupleTypeInfo(_				Vertex.class, keyType, valueType)___		return mapVertices(mapper, returnType)__	};apply,a,function,to,the,attribute,of,each,vertex,in,the,graph,param,mapper,the,map,function,to,apply,return,a,new,graph;suppress,warnings,unchecked,rawtypes,public,nv,graph,k,nv,ev,map,vertices,final,map,function,vertex,k,vv,nv,mapper,type,information,k,key,type,tuple,type,info,vertices,get,type,get,type,at,0,type,information,nv,value,type,type,extractor,create,type,info,map,function,class,mapper,get,class,1,null,null,type,information,vertex,k,nv,return,type,type,information,vertex,k,nv,new,tuple,type,info,vertex,class,key,type,value,type,return,map,vertices,mapper,return,type
Graph -> @SuppressWarnings({ "unchecked", "rawtypes" }) 	public <NV> Graph<K, NV, EV> mapVertices(final MapFunction<Vertex<K, VV>, NV> mapper);1465316775;Apply a function to the attribute of each vertex in the graph.__@param mapper the map function to apply._@return a new graph;@SuppressWarnings({ "unchecked", "rawtypes" })_	public <NV> Graph<K, NV, EV> mapVertices(final MapFunction<Vertex<K, VV>, NV> mapper) {__		TypeInformation<K> keyType = ((TupleTypeInfo<?>) vertices.getType()).getTypeAt(0)___		TypeInformation<NV> valueType = TypeExtractor.createTypeInfo(MapFunction.class, mapper.getClass(), 1, null, null)___		TypeInformation<Vertex<K, NV>> returnType = (TypeInformation<Vertex<K, NV>>) new TupleTypeInfo(_				Vertex.class, keyType, valueType)___		return mapVertices(mapper, returnType)__	};apply,a,function,to,the,attribute,of,each,vertex,in,the,graph,param,mapper,the,map,function,to,apply,return,a,new,graph;suppress,warnings,unchecked,rawtypes,public,nv,graph,k,nv,ev,map,vertices,final,map,function,vertex,k,vv,nv,mapper,type,information,k,key,type,tuple,type,info,vertices,get,type,get,type,at,0,type,information,nv,value,type,type,extractor,create,type,info,map,function,class,mapper,get,class,1,null,null,type,information,vertex,k,nv,return,type,type,information,vertex,k,nv,new,tuple,type,info,vertex,class,key,type,value,type,return,map,vertices,mapper,return,type
Graph -> @SuppressWarnings({ "unchecked", "rawtypes" }) 	public <NV> Graph<K, NV, EV> mapVertices(final MapFunction<Vertex<K, VV>, NV> mapper);1466789678;Apply a function to the attribute of each vertex in the graph.__@param mapper the map function to apply._@return a new graph;@SuppressWarnings({ "unchecked", "rawtypes" })_	public <NV> Graph<K, NV, EV> mapVertices(final MapFunction<Vertex<K, VV>, NV> mapper) {__		TypeInformation<K> keyType = ((TupleTypeInfo<?>) vertices.getType()).getTypeAt(0)___		TypeInformation<NV> valueType = TypeExtractor.createTypeInfo(MapFunction.class, mapper.getClass(), 1, null, null)___		TypeInformation<Vertex<K, NV>> returnType = (TypeInformation<Vertex<K, NV>>) new TupleTypeInfo(_				Vertex.class, keyType, valueType)___		return mapVertices(mapper, returnType)__	};apply,a,function,to,the,attribute,of,each,vertex,in,the,graph,param,mapper,the,map,function,to,apply,return,a,new,graph;suppress,warnings,unchecked,rawtypes,public,nv,graph,k,nv,ev,map,vertices,final,map,function,vertex,k,vv,nv,mapper,type,information,k,key,type,tuple,type,info,vertices,get,type,get,type,at,0,type,information,nv,value,type,type,extractor,create,type,info,map,function,class,mapper,get,class,1,null,null,type,information,vertex,k,nv,return,type,type,information,vertex,k,nv,new,tuple,type,info,vertex,class,key,type,value,type,return,map,vertices,mapper,return,type
Graph -> @SuppressWarnings({ "unchecked", "rawtypes" }) 	public <NV> Graph<K, NV, EV> mapVertices(final MapFunction<Vertex<K, VV>, NV> mapper);1467140656;Apply a function to the attribute of each vertex in the graph.__@param mapper the map function to apply._@return a new graph;@SuppressWarnings({ "unchecked", "rawtypes" })_	public <NV> Graph<K, NV, EV> mapVertices(final MapFunction<Vertex<K, VV>, NV> mapper) {__		TypeInformation<K> keyType = ((TupleTypeInfo<?>) vertices.getType()).getTypeAt(0)___		TypeInformation<NV> valueType = TypeExtractor.createTypeInfo(MapFunction.class, mapper.getClass(), 1, null, null)___		TypeInformation<Vertex<K, NV>> returnType = (TypeInformation<Vertex<K, NV>>) new TupleTypeInfo(_				Vertex.class, keyType, valueType)___		return mapVertices(mapper, returnType)__	};apply,a,function,to,the,attribute,of,each,vertex,in,the,graph,param,mapper,the,map,function,to,apply,return,a,new,graph;suppress,warnings,unchecked,rawtypes,public,nv,graph,k,nv,ev,map,vertices,final,map,function,vertex,k,vv,nv,mapper,type,information,k,key,type,tuple,type,info,vertices,get,type,get,type,at,0,type,information,nv,value,type,type,extractor,create,type,info,map,function,class,mapper,get,class,1,null,null,type,information,vertex,k,nv,return,type,type,information,vertex,k,nv,new,tuple,type,info,vertex,class,key,type,value,type,return,map,vertices,mapper,return,type
Graph -> @SuppressWarnings({ "unchecked", "rawtypes" }) 	public <NV> Graph<K, NV, EV> mapVertices(final MapFunction<Vertex<K, VV>, NV> mapper);1467306272;Apply a function to the attribute of each vertex in the graph.__@param mapper the map function to apply._@return a new graph;@SuppressWarnings({ "unchecked", "rawtypes" })_	public <NV> Graph<K, NV, EV> mapVertices(final MapFunction<Vertex<K, VV>, NV> mapper) {__		TypeInformation<K> keyType = ((TupleTypeInfo<?>) vertices.getType()).getTypeAt(0)___		TypeInformation<NV> valueType = TypeExtractor.createTypeInfo(MapFunction.class, mapper.getClass(), 1, null, null)___		TypeInformation<Vertex<K, NV>> returnType = (TypeInformation<Vertex<K, NV>>) new TupleTypeInfo(_				Vertex.class, keyType, valueType)___		return mapVertices(mapper, returnType)__	};apply,a,function,to,the,attribute,of,each,vertex,in,the,graph,param,mapper,the,map,function,to,apply,return,a,new,graph;suppress,warnings,unchecked,rawtypes,public,nv,graph,k,nv,ev,map,vertices,final,map,function,vertex,k,vv,nv,mapper,type,information,k,key,type,tuple,type,info,vertices,get,type,get,type,at,0,type,information,nv,value,type,type,extractor,create,type,info,map,function,class,mapper,get,class,1,null,null,type,information,vertex,k,nv,return,type,type,information,vertex,k,nv,new,tuple,type,info,vertex,class,key,type,value,type,return,map,vertices,mapper,return,type
Graph -> @SuppressWarnings({ "unchecked", "rawtypes" }) 	public <NV> Graph<K, NV, EV> mapVertices(final MapFunction<Vertex<K, VV>, NV> mapper);1470042815;Apply a function to the attribute of each vertex in the graph.__@param mapper the map function to apply._@return a new graph;@SuppressWarnings({ "unchecked", "rawtypes" })_	public <NV> Graph<K, NV, EV> mapVertices(final MapFunction<Vertex<K, VV>, NV> mapper) {__		TypeInformation<K> keyType = ((TupleTypeInfo<?>) vertices.getType()).getTypeAt(0)___		TypeInformation<NV> valueType = TypeExtractor.createTypeInfo(MapFunction.class, mapper.getClass(), 1, null, null)___		TypeInformation<Vertex<K, NV>> returnType = (TypeInformation<Vertex<K, NV>>) new TupleTypeInfo(_				Vertex.class, keyType, valueType)___		return mapVertices(mapper, returnType)__	};apply,a,function,to,the,attribute,of,each,vertex,in,the,graph,param,mapper,the,map,function,to,apply,return,a,new,graph;suppress,warnings,unchecked,rawtypes,public,nv,graph,k,nv,ev,map,vertices,final,map,function,vertex,k,vv,nv,mapper,type,information,k,key,type,tuple,type,info,vertices,get,type,get,type,at,0,type,information,nv,value,type,type,extractor,create,type,info,map,function,class,mapper,get,class,1,null,null,type,information,vertex,k,nv,return,type,type,information,vertex,k,nv,new,tuple,type,info,vertex,class,key,type,value,type,return,map,vertices,mapper,return,type
Graph -> @SuppressWarnings({ "unchecked", "rawtypes" }) 	public <NV> Graph<K, NV, EV> mapVertices(final MapFunction<Vertex<K, VV>, NV> mapper);1475684776;Apply a function to the attribute of each vertex in the graph.__@param mapper the map function to apply._@return a new graph;@SuppressWarnings({ "unchecked", "rawtypes" })_	public <NV> Graph<K, NV, EV> mapVertices(final MapFunction<Vertex<K, VV>, NV> mapper) {__		TypeInformation<K> keyType = ((TupleTypeInfo<?>) vertices.getType()).getTypeAt(0)___		TypeInformation<NV> valueType = TypeExtractor.createTypeInfo(MapFunction.class, mapper.getClass(), 1, null, null)___		TypeInformation<Vertex<K, NV>> returnType = (TypeInformation<Vertex<K, NV>>) new TupleTypeInfo(_				Vertex.class, keyType, valueType)___		return mapVertices(mapper, returnType)__	};apply,a,function,to,the,attribute,of,each,vertex,in,the,graph,param,mapper,the,map,function,to,apply,return,a,new,graph;suppress,warnings,unchecked,rawtypes,public,nv,graph,k,nv,ev,map,vertices,final,map,function,vertex,k,vv,nv,mapper,type,information,k,key,type,tuple,type,info,vertices,get,type,get,type,at,0,type,information,nv,value,type,type,extractor,create,type,info,map,function,class,mapper,get,class,1,null,null,type,information,vertex,k,nv,return,type,type,information,vertex,k,nv,new,tuple,type,info,vertex,class,key,type,value,type,return,map,vertices,mapper,return,type
Graph -> @SuppressWarnings({ "unchecked", "rawtypes" }) 	public <NV> Graph<K, NV, EV> mapVertices(final MapFunction<Vertex<K, VV>, NV> mapper);1475685606;Apply a function to the attribute of each vertex in the graph.__@param mapper the map function to apply._@return a new graph;@SuppressWarnings({ "unchecked", "rawtypes" })_	public <NV> Graph<K, NV, EV> mapVertices(final MapFunction<Vertex<K, VV>, NV> mapper) {__		TypeInformation<K> keyType = ((TupleTypeInfo<?>) vertices.getType()).getTypeAt(0)___		TypeInformation<NV> valueType = TypeExtractor.createTypeInfo(MapFunction.class, mapper.getClass(), 1, null, null)___		TypeInformation<Vertex<K, NV>> returnType = (TypeInformation<Vertex<K, NV>>) new TupleTypeInfo(_				Vertex.class, keyType, valueType)___		return mapVertices(mapper, returnType)__	};apply,a,function,to,the,attribute,of,each,vertex,in,the,graph,param,mapper,the,map,function,to,apply,return,a,new,graph;suppress,warnings,unchecked,rawtypes,public,nv,graph,k,nv,ev,map,vertices,final,map,function,vertex,k,vv,nv,mapper,type,information,k,key,type,tuple,type,info,vertices,get,type,get,type,at,0,type,information,nv,value,type,type,extractor,create,type,info,map,function,class,mapper,get,class,1,null,null,type,information,vertex,k,nv,return,type,type,information,vertex,k,nv,new,tuple,type,info,vertex,class,key,type,value,type,return,map,vertices,mapper,return,type
Graph -> @SuppressWarnings({ "unchecked", "rawtypes" }) 	public <NV> Graph<K, NV, EV> mapVertices(final MapFunction<Vertex<K, VV>, NV> mapper);1481745825;Apply a function to the attribute of each vertex in the graph.__@param mapper the map function to apply._@return a new graph;@SuppressWarnings({ "unchecked", "rawtypes" })_	public <NV> Graph<K, NV, EV> mapVertices(final MapFunction<Vertex<K, VV>, NV> mapper) {__		TypeInformation<K> keyType = ((TupleTypeInfo<?>) vertices.getType()).getTypeAt(0)___		TypeInformation<NV> valueType = TypeExtractor.createTypeInfo(MapFunction.class, mapper.getClass(), 1, null, null)___		TypeInformation<Vertex<K, NV>> returnType = (TypeInformation<Vertex<K, NV>>) new TupleTypeInfo(_				Vertex.class, keyType, valueType)___		return mapVertices(mapper, returnType)__	};apply,a,function,to,the,attribute,of,each,vertex,in,the,graph,param,mapper,the,map,function,to,apply,return,a,new,graph;suppress,warnings,unchecked,rawtypes,public,nv,graph,k,nv,ev,map,vertices,final,map,function,vertex,k,vv,nv,mapper,type,information,k,key,type,tuple,type,info,vertices,get,type,get,type,at,0,type,information,nv,value,type,type,extractor,create,type,info,map,function,class,mapper,get,class,1,null,null,type,information,vertex,k,nv,return,type,type,information,vertex,k,nv,new,tuple,type,info,vertex,class,key,type,value,type,return,map,vertices,mapper,return,type
Graph -> @SuppressWarnings({ "unchecked", "rawtypes" }) 	public <NV> Graph<K, NV, EV> mapVertices(final MapFunction<Vertex<K, VV>, NV> mapper);1481881009;Apply a function to the attribute of each vertex in the graph.__@param mapper the map function to apply._@return a new graph;@SuppressWarnings({ "unchecked", "rawtypes" })_	public <NV> Graph<K, NV, EV> mapVertices(final MapFunction<Vertex<K, VV>, NV> mapper) {__		TypeInformation<K> keyType = ((TupleTypeInfo<?>) vertices.getType()).getTypeAt(0)___		TypeInformation<NV> valueType = TypeExtractor.createTypeInfo(MapFunction.class, mapper.getClass(), 1, vertices.getType(), null)___		TypeInformation<Vertex<K, NV>> returnType = (TypeInformation<Vertex<K, NV>>) new TupleTypeInfo(_				Vertex.class, keyType, valueType)___		return mapVertices(mapper, returnType)__	};apply,a,function,to,the,attribute,of,each,vertex,in,the,graph,param,mapper,the,map,function,to,apply,return,a,new,graph;suppress,warnings,unchecked,rawtypes,public,nv,graph,k,nv,ev,map,vertices,final,map,function,vertex,k,vv,nv,mapper,type,information,k,key,type,tuple,type,info,vertices,get,type,get,type,at,0,type,information,nv,value,type,type,extractor,create,type,info,map,function,class,mapper,get,class,1,vertices,get,type,null,type,information,vertex,k,nv,return,type,type,information,vertex,k,nv,new,tuple,type,info,vertex,class,key,type,value,type,return,map,vertices,mapper,return,type
Graph -> @SuppressWarnings({ "unchecked", "rawtypes" }) 	public <NV> Graph<K, NV, EV> mapVertices(final MapFunction<Vertex<K, VV>, NV> mapper);1484160227;Apply a function to the attribute of each vertex in the graph.__@param mapper the map function to apply._@return a new graph;@SuppressWarnings({ "unchecked", "rawtypes" })_	public <NV> Graph<K, NV, EV> mapVertices(final MapFunction<Vertex<K, VV>, NV> mapper) {__		TypeInformation<K> keyType = ((TupleTypeInfo<?>) vertices.getType()).getTypeAt(0)___		TypeInformation<NV> valueType = TypeExtractor.createTypeInfo(MapFunction.class, mapper.getClass(), 1, vertices.getType(), null)___		TypeInformation<Vertex<K, NV>> returnType = (TypeInformation<Vertex<K, NV>>) new TupleTypeInfo(_				Vertex.class, keyType, valueType)___		return mapVertices(mapper, returnType)__	};apply,a,function,to,the,attribute,of,each,vertex,in,the,graph,param,mapper,the,map,function,to,apply,return,a,new,graph;suppress,warnings,unchecked,rawtypes,public,nv,graph,k,nv,ev,map,vertices,final,map,function,vertex,k,vv,nv,mapper,type,information,k,key,type,tuple,type,info,vertices,get,type,get,type,at,0,type,information,nv,value,type,type,extractor,create,type,info,map,function,class,mapper,get,class,1,vertices,get,type,null,type,information,vertex,k,nv,return,type,type,information,vertex,k,nv,new,tuple,type,info,vertex,class,key,type,value,type,return,map,vertices,mapper,return,type
Graph -> @SuppressWarnings({ "unchecked", "rawtypes" }) 	public <NV> Graph<K, NV, EV> mapVertices(final MapFunction<Vertex<K, VV>, NV> mapper);1484685504;Apply a function to the attribute of each vertex in the graph.__@param mapper the map function to apply._@return a new graph;@SuppressWarnings({ "unchecked", "rawtypes" })_	public <NV> Graph<K, NV, EV> mapVertices(final MapFunction<Vertex<K, VV>, NV> mapper) {__		TypeInformation<K> keyType = ((TupleTypeInfo<?>) vertices.getType()).getTypeAt(0)___		TypeInformation<NV> valueType = TypeExtractor.createTypeInfo(MapFunction.class, mapper.getClass(), 1, vertices.getType(), null)___		TypeInformation<Vertex<K, NV>> returnType = (TypeInformation<Vertex<K, NV>>) new TupleTypeInfo(_				Vertex.class, keyType, valueType)___		return mapVertices(mapper, returnType)__	};apply,a,function,to,the,attribute,of,each,vertex,in,the,graph,param,mapper,the,map,function,to,apply,return,a,new,graph;suppress,warnings,unchecked,rawtypes,public,nv,graph,k,nv,ev,map,vertices,final,map,function,vertex,k,vv,nv,mapper,type,information,k,key,type,tuple,type,info,vertices,get,type,get,type,at,0,type,information,nv,value,type,type,extractor,create,type,info,map,function,class,mapper,get,class,1,vertices,get,type,null,type,information,vertex,k,nv,return,type,type,information,vertex,k,nv,new,tuple,type,info,vertex,class,key,type,value,type,return,map,vertices,mapper,return,type
Graph -> @SuppressWarnings({ "unchecked", "rawtypes" }) 	public <NV> Graph<K, NV, EV> mapVertices(final MapFunction<Vertex<K, VV>, NV> mapper);1489068942;Apply a function to the attribute of each vertex in the graph.__@param mapper the map function to apply._@return a new graph;@SuppressWarnings({ "unchecked", "rawtypes" })_	public <NV> Graph<K, NV, EV> mapVertices(final MapFunction<Vertex<K, VV>, NV> mapper) {__		TypeInformation<K> keyType = ((TupleTypeInfo<?>) vertices.getType()).getTypeAt(0)___		TypeInformation<NV> valueType = TypeExtractor.createTypeInfo(MapFunction.class, mapper.getClass(), 1, vertices.getType(), null)___		TypeInformation<Vertex<K, NV>> returnType = (TypeInformation<Vertex<K, NV>>) new TupleTypeInfo(_				Vertex.class, keyType, valueType)___		return mapVertices(mapper, returnType)__	};apply,a,function,to,the,attribute,of,each,vertex,in,the,graph,param,mapper,the,map,function,to,apply,return,a,new,graph;suppress,warnings,unchecked,rawtypes,public,nv,graph,k,nv,ev,map,vertices,final,map,function,vertex,k,vv,nv,mapper,type,information,k,key,type,tuple,type,info,vertices,get,type,get,type,at,0,type,information,nv,value,type,type,extractor,create,type,info,map,function,class,mapper,get,class,1,vertices,get,type,null,type,information,vertex,k,nv,return,type,type,information,vertex,k,nv,new,tuple,type,info,vertex,class,key,type,value,type,return,map,vertices,mapper,return,type
Graph -> @SuppressWarnings({ "unchecked", "rawtypes" }) 	public <NV> Graph<K, NV, EV> mapVertices(final MapFunction<Vertex<K, VV>, NV> mapper);1490973446;Apply a function to the attribute of each vertex in the graph.__@param mapper the map function to apply._@return a new graph;@SuppressWarnings({ "unchecked", "rawtypes" })_	public <NV> Graph<K, NV, EV> mapVertices(final MapFunction<Vertex<K, VV>, NV> mapper) {__		TypeInformation<K> keyType = ((TupleTypeInfo<?>) vertices.getType()).getTypeAt(0)___		TypeInformation<NV> valueType___		if (mapper instanceof ResultTypeQueryable) {_			valueType = ((ResultTypeQueryable) mapper).getProducedType()__		} else {_			valueType = TypeExtractor.createTypeInfo(MapFunction.class, mapper.getClass(), 1, vertices.getType(), null)__		}__		TypeInformation<Vertex<K, NV>> returnType = (TypeInformation<Vertex<K, NV>>) new TupleTypeInfo(_				Vertex.class, keyType, valueType)___		return mapVertices(mapper, returnType)__	};apply,a,function,to,the,attribute,of,each,vertex,in,the,graph,param,mapper,the,map,function,to,apply,return,a,new,graph;suppress,warnings,unchecked,rawtypes,public,nv,graph,k,nv,ev,map,vertices,final,map,function,vertex,k,vv,nv,mapper,type,information,k,key,type,tuple,type,info,vertices,get,type,get,type,at,0,type,information,nv,value,type,if,mapper,instanceof,result,type,queryable,value,type,result,type,queryable,mapper,get,produced,type,else,value,type,type,extractor,create,type,info,map,function,class,mapper,get,class,1,vertices,get,type,null,type,information,vertex,k,nv,return,type,type,information,vertex,k,nv,new,tuple,type,info,vertex,class,key,type,value,type,return,map,vertices,mapper,return,type
Graph -> @SuppressWarnings({ "unchecked", "rawtypes" }) 	public <NV> Graph<K, NV, EV> mapVertices(final MapFunction<Vertex<K, VV>, NV> mapper);1495819075;Apply a function to the attribute of each vertex in the graph.__@param mapper the map function to apply._@return a new graph;@SuppressWarnings({ "unchecked", "rawtypes" })_	public <NV> Graph<K, NV, EV> mapVertices(final MapFunction<Vertex<K, VV>, NV> mapper) {__		TypeInformation<K> keyType = ((TupleTypeInfo<?>) vertices.getType()).getTypeAt(0)___		TypeInformation<NV> valueType___		if (mapper instanceof ResultTypeQueryable) {_			valueType = ((ResultTypeQueryable) mapper).getProducedType()__		} else {_			valueType = TypeExtractor.createTypeInfo(MapFunction.class, mapper.getClass(), 1, vertices.getType(), null)__		}__		TypeInformation<Vertex<K, NV>> returnType = (TypeInformation<Vertex<K, NV>>) new TupleTypeInfo(_				Vertex.class, keyType, valueType)___		return mapVertices(mapper, returnType)__	};apply,a,function,to,the,attribute,of,each,vertex,in,the,graph,param,mapper,the,map,function,to,apply,return,a,new,graph;suppress,warnings,unchecked,rawtypes,public,nv,graph,k,nv,ev,map,vertices,final,map,function,vertex,k,vv,nv,mapper,type,information,k,key,type,tuple,type,info,vertices,get,type,get,type,at,0,type,information,nv,value,type,if,mapper,instanceof,result,type,queryable,value,type,result,type,queryable,mapper,get,produced,type,else,value,type,type,extractor,create,type,info,map,function,class,mapper,get,class,1,vertices,get,type,null,type,information,vertex,k,nv,return,type,type,information,vertex,k,nv,new,tuple,type,info,vertex,class,key,type,value,type,return,map,vertices,mapper,return,type
Graph -> @SuppressWarnings({ "unchecked", "rawtypes" }) 	public <NV> Graph<K, NV, EV> mapVertices(final MapFunction<Vertex<K, VV>, NV> mapper);1502111816;Apply a function to the attribute of each vertex in the graph.__@param mapper the map function to apply._@return a new graph;@SuppressWarnings({ "unchecked", "rawtypes" })_	public <NV> Graph<K, NV, EV> mapVertices(final MapFunction<Vertex<K, VV>, NV> mapper) {__		TypeInformation<K> keyType = ((TupleTypeInfo<?>) vertices.getType()).getTypeAt(0)___		TypeInformation<NV> valueType___		if (mapper instanceof ResultTypeQueryable) {_			valueType = ((ResultTypeQueryable) mapper).getProducedType()__		} else {_			valueType = TypeExtractor.createTypeInfo(MapFunction.class, mapper.getClass(), 1, vertices.getType(), null)__		}__		TypeInformation<Vertex<K, NV>> returnType = (TypeInformation<Vertex<K, NV>>) new TupleTypeInfo(_				Vertex.class, keyType, valueType)___		return mapVertices(mapper, returnType)__	};apply,a,function,to,the,attribute,of,each,vertex,in,the,graph,param,mapper,the,map,function,to,apply,return,a,new,graph;suppress,warnings,unchecked,rawtypes,public,nv,graph,k,nv,ev,map,vertices,final,map,function,vertex,k,vv,nv,mapper,type,information,k,key,type,tuple,type,info,vertices,get,type,get,type,at,0,type,information,nv,value,type,if,mapper,instanceof,result,type,queryable,value,type,result,type,queryable,mapper,get,produced,type,else,value,type,type,extractor,create,type,info,map,function,class,mapper,get,class,1,vertices,get,type,null,type,information,vertex,k,nv,return,type,type,information,vertex,k,nv,new,tuple,type,info,vertex,class,key,type,value,type,return,map,vertices,mapper,return,type
Graph -> public <NEW> Graph<K, NEW, EV> translateVertexValues(TranslateFunction<VV, NEW> translator) throws Exception;1462809297;Translate {@link Vertex} values using the given {@link MapFunction}.__@param translator implements conversion from {@code VV} to {@code NEW}_@param <NEW> new vertex value type_@return graph with translated vertex values_@throws Exception;public <NEW> Graph<K, NEW, EV> translateVertexValues(TranslateFunction<VV, NEW> translator) throws Exception {_		return run(new TranslateVertexValues<K, VV, NEW, EV>(translator))__	};translate,link,vertex,values,using,the,given,link,map,function,param,translator,implements,conversion,from,code,vv,to,code,new,param,new,new,vertex,value,type,return,graph,with,translated,vertex,values,throws,exception;public,new,graph,k,new,ev,translate,vertex,values,translate,function,vv,new,translator,throws,exception,return,run,new,translate,vertex,values,k,vv,new,ev,translator
Graph -> public <NEW> Graph<K, NEW, EV> translateVertexValues(TranslateFunction<VV, NEW> translator) throws Exception;1465316775;Translate {@link Vertex} values using the given {@link MapFunction}.__@param translator implements conversion from {@code VV} to {@code NEW}_@param <NEW> new vertex value type_@return graph with translated vertex values_@throws Exception;public <NEW> Graph<K, NEW, EV> translateVertexValues(TranslateFunction<VV, NEW> translator) throws Exception {_		return run(new TranslateVertexValues<K, VV, NEW, EV>(translator))__	};translate,link,vertex,values,using,the,given,link,map,function,param,translator,implements,conversion,from,code,vv,to,code,new,param,new,new,vertex,value,type,return,graph,with,translated,vertex,values,throws,exception;public,new,graph,k,new,ev,translate,vertex,values,translate,function,vv,new,translator,throws,exception,return,run,new,translate,vertex,values,k,vv,new,ev,translator
Graph -> public <NEW> Graph<K, NEW, EV> translateVertexValues(TranslateFunction<VV, NEW> translator) throws Exception;1466789678;Translate {@link Vertex} values using the given {@link MapFunction}.__@param translator implements conversion from {@code VV} to {@code NEW}_@param <NEW> new vertex value type_@return graph with translated vertex values_@throws Exception;public <NEW> Graph<K, NEW, EV> translateVertexValues(TranslateFunction<VV, NEW> translator) throws Exception {_		return run(new TranslateVertexValues<K, VV, NEW, EV>(translator))__	};translate,link,vertex,values,using,the,given,link,map,function,param,translator,implements,conversion,from,code,vv,to,code,new,param,new,new,vertex,value,type,return,graph,with,translated,vertex,values,throws,exception;public,new,graph,k,new,ev,translate,vertex,values,translate,function,vv,new,translator,throws,exception,return,run,new,translate,vertex,values,k,vv,new,ev,translator
Graph -> public <NEW> Graph<K, NEW, EV> translateVertexValues(TranslateFunction<VV, NEW> translator) throws Exception;1467140656;Translate {@link Vertex} values using the given {@link MapFunction}.__@param translator implements conversion from {@code VV} to {@code NEW}_@param <NEW> new vertex value type_@return graph with translated vertex values_@throws Exception;public <NEW> Graph<K, NEW, EV> translateVertexValues(TranslateFunction<VV, NEW> translator) throws Exception {_		return run(new TranslateVertexValues<K, VV, NEW, EV>(translator))__	};translate,link,vertex,values,using,the,given,link,map,function,param,translator,implements,conversion,from,code,vv,to,code,new,param,new,new,vertex,value,type,return,graph,with,translated,vertex,values,throws,exception;public,new,graph,k,new,ev,translate,vertex,values,translate,function,vv,new,translator,throws,exception,return,run,new,translate,vertex,values,k,vv,new,ev,translator
Graph -> public <NEW> Graph<K, NEW, EV> translateVertexValues(TranslateFunction<VV, NEW> translator) throws Exception;1467306272;Translate {@link Vertex} values using the given {@link MapFunction}.__@param translator implements conversion from {@code VV} to {@code NEW}_@param <NEW> new vertex value type_@return graph with translated vertex values_@throws Exception;public <NEW> Graph<K, NEW, EV> translateVertexValues(TranslateFunction<VV, NEW> translator) throws Exception {_		return run(new TranslateVertexValues<K, VV, NEW, EV>(translator))__	};translate,link,vertex,values,using,the,given,link,map,function,param,translator,implements,conversion,from,code,vv,to,code,new,param,new,new,vertex,value,type,return,graph,with,translated,vertex,values,throws,exception;public,new,graph,k,new,ev,translate,vertex,values,translate,function,vv,new,translator,throws,exception,return,run,new,translate,vertex,values,k,vv,new,ev,translator
Graph -> public <NEW> Graph<K, NEW, EV> translateVertexValues(TranslateFunction<VV, NEW> translator) throws Exception;1470042815;Translate {@link Vertex} values using the given {@link MapFunction}.__@param translator implements conversion from {@code VV} to {@code NEW}_@param <NEW> new vertex value type_@return graph with translated vertex values_@throws Exception;public <NEW> Graph<K, NEW, EV> translateVertexValues(TranslateFunction<VV, NEW> translator) throws Exception {_		return run(new TranslateVertexValues<K, VV, NEW, EV>(translator))__	};translate,link,vertex,values,using,the,given,link,map,function,param,translator,implements,conversion,from,code,vv,to,code,new,param,new,new,vertex,value,type,return,graph,with,translated,vertex,values,throws,exception;public,new,graph,k,new,ev,translate,vertex,values,translate,function,vv,new,translator,throws,exception,return,run,new,translate,vertex,values,k,vv,new,ev,translator
Graph -> public <NEW> Graph<K, NEW, EV> translateVertexValues(TranslateFunction<VV, NEW> translator) throws Exception;1475684776;Translate {@link Vertex} values using the given {@link MapFunction}.__@param translator implements conversion from {@code VV} to {@code NEW}_@param <NEW> new vertex value type_@return graph with translated vertex values_@throws Exception;public <NEW> Graph<K, NEW, EV> translateVertexValues(TranslateFunction<VV, NEW> translator) throws Exception {_		return run(new TranslateVertexValues<K, VV, NEW, EV>(translator))__	};translate,link,vertex,values,using,the,given,link,map,function,param,translator,implements,conversion,from,code,vv,to,code,new,param,new,new,vertex,value,type,return,graph,with,translated,vertex,values,throws,exception;public,new,graph,k,new,ev,translate,vertex,values,translate,function,vv,new,translator,throws,exception,return,run,new,translate,vertex,values,k,vv,new,ev,translator
Graph -> public <NEW> Graph<K, NEW, EV> translateVertexValues(TranslateFunction<VV, NEW> translator) throws Exception;1475685606;Translate {@link Vertex} values using the given {@link MapFunction}.__@param translator implements conversion from {@code VV} to {@code NEW}_@param <NEW> new vertex value type_@return graph with translated vertex values_@throws Exception;public <NEW> Graph<K, NEW, EV> translateVertexValues(TranslateFunction<VV, NEW> translator) throws Exception {_		return run(new TranslateVertexValues<K, VV, NEW, EV>(translator))__	};translate,link,vertex,values,using,the,given,link,map,function,param,translator,implements,conversion,from,code,vv,to,code,new,param,new,new,vertex,value,type,return,graph,with,translated,vertex,values,throws,exception;public,new,graph,k,new,ev,translate,vertex,values,translate,function,vv,new,translator,throws,exception,return,run,new,translate,vertex,values,k,vv,new,ev,translator
Graph -> public <NEW> Graph<K, NEW, EV> translateVertexValues(TranslateFunction<VV, NEW> translator) throws Exception;1481745825;Translate {@link Vertex} values using the given {@link MapFunction}.__@param translator implements conversion from {@code VV} to {@code NEW}_@param <NEW> new vertex value type_@return graph with translated vertex values_@throws Exception;public <NEW> Graph<K, NEW, EV> translateVertexValues(TranslateFunction<VV, NEW> translator) throws Exception {_		return run(new TranslateVertexValues<K, VV, NEW, EV>(translator))__	};translate,link,vertex,values,using,the,given,link,map,function,param,translator,implements,conversion,from,code,vv,to,code,new,param,new,new,vertex,value,type,return,graph,with,translated,vertex,values,throws,exception;public,new,graph,k,new,ev,translate,vertex,values,translate,function,vv,new,translator,throws,exception,return,run,new,translate,vertex,values,k,vv,new,ev,translator
Graph -> public <NEW> Graph<K, NEW, EV> translateVertexValues(TranslateFunction<VV, NEW> translator) throws Exception;1481881009;Translate {@link Vertex} values using the given {@link MapFunction}.__@param translator implements conversion from {@code VV} to {@code NEW}_@param <NEW> new vertex value type_@return graph with translated vertex values_@throws Exception;public <NEW> Graph<K, NEW, EV> translateVertexValues(TranslateFunction<VV, NEW> translator) throws Exception {_		return run(new TranslateVertexValues<K, VV, NEW, EV>(translator))__	};translate,link,vertex,values,using,the,given,link,map,function,param,translator,implements,conversion,from,code,vv,to,code,new,param,new,new,vertex,value,type,return,graph,with,translated,vertex,values,throws,exception;public,new,graph,k,new,ev,translate,vertex,values,translate,function,vv,new,translator,throws,exception,return,run,new,translate,vertex,values,k,vv,new,ev,translator
Graph -> public <NEW> Graph<K, NEW, EV> translateVertexValues(TranslateFunction<VV, NEW> translator) throws Exception;1484160227;Translate {@link Vertex} values using the given {@link MapFunction}.__@param translator implements conversion from {@code VV} to {@code NEW}_@param <NEW> new vertex value type_@return graph with translated vertex values_@throws Exception;public <NEW> Graph<K, NEW, EV> translateVertexValues(TranslateFunction<VV, NEW> translator) throws Exception {_		return run(new TranslateVertexValues<K, VV, NEW, EV>(translator))__	};translate,link,vertex,values,using,the,given,link,map,function,param,translator,implements,conversion,from,code,vv,to,code,new,param,new,new,vertex,value,type,return,graph,with,translated,vertex,values,throws,exception;public,new,graph,k,new,ev,translate,vertex,values,translate,function,vv,new,translator,throws,exception,return,run,new,translate,vertex,values,k,vv,new,ev,translator
Graph -> public <NEW> Graph<K, NEW, EV> translateVertexValues(TranslateFunction<VV, NEW> translator) throws Exception;1484685504;Translate {@link Vertex} values using the given {@link MapFunction}.__@param translator implements conversion from {@code VV} to {@code NEW}_@param <NEW> new vertex value type_@return graph with translated vertex values_@throws Exception;public <NEW> Graph<K, NEW, EV> translateVertexValues(TranslateFunction<VV, NEW> translator) throws Exception {_		return run(new TranslateVertexValues<K, VV, NEW, EV>(translator))__	};translate,link,vertex,values,using,the,given,link,map,function,param,translator,implements,conversion,from,code,vv,to,code,new,param,new,new,vertex,value,type,return,graph,with,translated,vertex,values,throws,exception;public,new,graph,k,new,ev,translate,vertex,values,translate,function,vv,new,translator,throws,exception,return,run,new,translate,vertex,values,k,vv,new,ev,translator
Graph -> public <NEW> Graph<K, NEW, EV> translateVertexValues(TranslateFunction<VV, NEW> translator) throws Exception;1489068942;Translate {@link Vertex} values using the given {@link MapFunction}.__@param translator implements conversion from {@code VV} to {@code NEW}_@param <NEW> new vertex value type_@return graph with translated vertex values_@throws Exception;public <NEW> Graph<K, NEW, EV> translateVertexValues(TranslateFunction<VV, NEW> translator) throws Exception {_		return run(new TranslateVertexValues<K, VV, NEW, EV>(translator))__	};translate,link,vertex,values,using,the,given,link,map,function,param,translator,implements,conversion,from,code,vv,to,code,new,param,new,new,vertex,value,type,return,graph,with,translated,vertex,values,throws,exception;public,new,graph,k,new,ev,translate,vertex,values,translate,function,vv,new,translator,throws,exception,return,run,new,translate,vertex,values,k,vv,new,ev,translator
Graph -> public <NEW> Graph<K, NEW, EV> translateVertexValues(TranslateFunction<VV, NEW> translator) throws Exception;1490973446;Translate {@link Vertex} values using the given {@link MapFunction}.__@param translator implements conversion from {@code VV} to {@code NEW}_@param <NEW> new vertex value type_@return graph with translated vertex values_@throws Exception;public <NEW> Graph<K, NEW, EV> translateVertexValues(TranslateFunction<VV, NEW> translator) throws Exception {_		return run(new TranslateVertexValues<K, VV, NEW, EV>(translator))__	};translate,link,vertex,values,using,the,given,link,map,function,param,translator,implements,conversion,from,code,vv,to,code,new,param,new,new,vertex,value,type,return,graph,with,translated,vertex,values,throws,exception;public,new,graph,k,new,ev,translate,vertex,values,translate,function,vv,new,translator,throws,exception,return,run,new,translate,vertex,values,k,vv,new,ev,translator
Graph -> public <NEW> Graph<K, NEW, EV> translateVertexValues(TranslateFunction<VV, NEW> translator) throws Exception;1495819075;Translate {@link Vertex} values using the given {@link MapFunction}.__@param translator implements conversion from {@code VV} to {@code NEW}_@param <NEW> new vertex value type_@return graph with translated vertex values_@throws Exception;public <NEW> Graph<K, NEW, EV> translateVertexValues(TranslateFunction<VV, NEW> translator) throws Exception {_		return run(new TranslateVertexValues<K, VV, NEW, EV>(translator))__	};translate,link,vertex,values,using,the,given,link,map,function,param,translator,implements,conversion,from,code,vv,to,code,new,param,new,new,vertex,value,type,return,graph,with,translated,vertex,values,throws,exception;public,new,graph,k,new,ev,translate,vertex,values,translate,function,vv,new,translator,throws,exception,return,run,new,translate,vertex,values,k,vv,new,ev,translator
Graph -> public <NEW> Graph<K, NEW, EV> translateVertexValues(TranslateFunction<VV, NEW> translator) throws Exception;1502111816;Translate {@link Vertex} values using the given {@link MapFunction}.__@param translator implements conversion from {@code VV} to {@code NEW}_@param <NEW> new vertex value type_@return graph with translated vertex values_@throws Exception;public <NEW> Graph<K, NEW, EV> translateVertexValues(TranslateFunction<VV, NEW> translator) throws Exception {_		return run(new TranslateVertexValues<>(translator))__	};translate,link,vertex,values,using,the,given,link,map,function,param,translator,implements,conversion,from,code,vv,to,code,new,param,new,new,vertex,value,type,return,graph,with,translated,vertex,values,throws,exception;public,new,graph,k,new,ev,translate,vertex,values,translate,function,vv,new,translator,throws,exception,return,run,new,translate,vertex,values,translator
Graph -> public DataSet<Edge<K, EV>> getEdges();1444404795;@return the edge DataSet.;public DataSet<Edge<K, EV>> getEdges() {_		return edges__	};return,the,edge,data,set;public,data,set,edge,k,ev,get,edges,return,edges
Graph -> public DataSet<Edge<K, EV>> getEdges();1445261977;@return the edge DataSet.;public DataSet<Edge<K, EV>> getEdges() {_		return edges__	};return,the,edge,data,set;public,data,set,edge,k,ev,get,edges,return,edges
Graph -> public DataSet<Edge<K, EV>> getEdges();1445854323;@return the edge DataSet.;public DataSet<Edge<K, EV>> getEdges() {_		return edges__	};return,the,edge,data,set;public,data,set,edge,k,ev,get,edges,return,edges
Graph -> public DataSet<Edge<K, EV>> getEdges();1446112342;@return the edge DataSet.;public DataSet<Edge<K, EV>> getEdges() {_		return edges__	};return,the,edge,data,set;public,data,set,edge,k,ev,get,edges,return,edges
Graph -> public DataSet<Edge<K, EV>> getEdges();1447073368;@return the edge DataSet.;public DataSet<Edge<K, EV>> getEdges() {_		return edges__	};return,the,edge,data,set;public,data,set,edge,k,ev,get,edges,return,edges
Graph -> public DataSet<Edge<K, EV>> getEdges();1454404649;@return the edge DataSet.;public DataSet<Edge<K, EV>> getEdges() {_		return edges__	};return,the,edge,data,set;public,data,set,edge,k,ev,get,edges,return,edges
Graph -> public DataSet<Edge<K, EV>> getEdges();1458583829;@return the edge DataSet.;public DataSet<Edge<K, EV>> getEdges() {_		return edges__	};return,the,edge,data,set;public,data,set,edge,k,ev,get,edges,return,edges
Graph -> public DataSet<Edge<K, EV>> getEdges();1458583829;@return the edge DataSet.;public DataSet<Edge<K, EV>> getEdges() {_		return edges__	};return,the,edge,data,set;public,data,set,edge,k,ev,get,edges,return,edges
Graph -> public DataSet<Edge<K, EV>> getEdges();1462100316;@return the edge DataSet.;public DataSet<Edge<K, EV>> getEdges() {_		return edges__	};return,the,edge,data,set;public,data,set,edge,k,ev,get,edges,return,edges
Graph -> public DataSet<Edge<K, EV>> getEdges();1462100316;@return the edge DataSet.;public DataSet<Edge<K, EV>> getEdges() {_		return edges__	};return,the,edge,data,set;public,data,set,edge,k,ev,get,edges,return,edges
Graph -> public DataSet<Edge<K, EV>> getEdges();1462205213;@return the edge DataSet.;public DataSet<Edge<K, EV>> getEdges() {_		return edges__	};return,the,edge,data,set;public,data,set,edge,k,ev,get,edges,return,edges
Graph -> public DataSet<Edge<K, EV>> getEdges();1462208859;@return the edge DataSet.;public DataSet<Edge<K, EV>> getEdges() {_		return edges__	};return,the,edge,data,set;public,data,set,edge,k,ev,get,edges,return,edges
Graph -> public DataSet<Edge<K, EV>> getEdges();1462809297;@return the edge DataSet.;public DataSet<Edge<K, EV>> getEdges() {_		return edges__	};return,the,edge,data,set;public,data,set,edge,k,ev,get,edges,return,edges
Graph -> public DataSet<Edge<K, EV>> getEdges();1465316775;@return the edge DataSet.;public DataSet<Edge<K, EV>> getEdges() {_		return edges__	};return,the,edge,data,set;public,data,set,edge,k,ev,get,edges,return,edges
Graph -> public DataSet<Edge<K, EV>> getEdges();1466789678;@return the edge DataSet.;public DataSet<Edge<K, EV>> getEdges() {_		return edges__	};return,the,edge,data,set;public,data,set,edge,k,ev,get,edges,return,edges
Graph -> public DataSet<Edge<K, EV>> getEdges();1467140656;@return the edge DataSet.;public DataSet<Edge<K, EV>> getEdges() {_		return edges__	};return,the,edge,data,set;public,data,set,edge,k,ev,get,edges,return,edges
Graph -> public DataSet<Edge<K, EV>> getEdges();1467306272;@return the edge DataSet.;public DataSet<Edge<K, EV>> getEdges() {_		return edges__	};return,the,edge,data,set;public,data,set,edge,k,ev,get,edges,return,edges
Graph -> public DataSet<Edge<K, EV>> getEdges();1470042815;@return the edge DataSet.;public DataSet<Edge<K, EV>> getEdges() {_		return edges__	};return,the,edge,data,set;public,data,set,edge,k,ev,get,edges,return,edges
Graph -> public DataSet<Edge<K, EV>> getEdges();1475684776;@return the edge DataSet.;public DataSet<Edge<K, EV>> getEdges() {_		return edges__	};return,the,edge,data,set;public,data,set,edge,k,ev,get,edges,return,edges
Graph -> public DataSet<Edge<K, EV>> getEdges();1475685606;@return the edge DataSet.;public DataSet<Edge<K, EV>> getEdges() {_		return edges__	};return,the,edge,data,set;public,data,set,edge,k,ev,get,edges,return,edges
Graph -> public DataSet<Edge<K, EV>> getEdges();1481745825;@return the edge DataSet.;public DataSet<Edge<K, EV>> getEdges() {_		return edges__	};return,the,edge,data,set;public,data,set,edge,k,ev,get,edges,return,edges
Graph -> public DataSet<Edge<K, EV>> getEdges();1481881009;@return the edge DataSet.;public DataSet<Edge<K, EV>> getEdges() {_		return edges__	};return,the,edge,data,set;public,data,set,edge,k,ev,get,edges,return,edges
Graph -> public DataSet<Edge<K, EV>> getEdges();1484160227;@return the edge DataSet.;public DataSet<Edge<K, EV>> getEdges() {_		return edges__	};return,the,edge,data,set;public,data,set,edge,k,ev,get,edges,return,edges
Graph -> public DataSet<Edge<K, EV>> getEdges();1484685504;@return the edge DataSet.;public DataSet<Edge<K, EV>> getEdges() {_		return edges__	};return,the,edge,data,set;public,data,set,edge,k,ev,get,edges,return,edges
Graph -> public DataSet<Edge<K, EV>> getEdges();1489068942;@return the edge DataSet.;public DataSet<Edge<K, EV>> getEdges() {_		return edges__	};return,the,edge,data,set;public,data,set,edge,k,ev,get,edges,return,edges
Graph -> public DataSet<Edge<K, EV>> getEdges();1490973446;@return the edge DataSet.;public DataSet<Edge<K, EV>> getEdges() {_		return edges__	};return,the,edge,data,set;public,data,set,edge,k,ev,get,edges,return,edges
Graph -> public DataSet<Edge<K, EV>> getEdges();1495819075;@return the edge DataSet.;public DataSet<Edge<K, EV>> getEdges() {_		return edges__	};return,the,edge,data,set;public,data,set,edge,k,ev,get,edges,return,edges
Graph -> public DataSet<Edge<K, EV>> getEdges();1502111816;@return the edge DataSet.;public DataSet<Edge<K, EV>> getEdges() {_		return edges__	};return,the,edge,data,set;public,data,set,edge,k,ev,get,edges,return,edges
Graph -> public <NV> Graph<K, NV, EV> mapVertices(final MapFunction<Vertex<K, VV>, NV> mapper, TypeInformation<Vertex<K,NV>> returnType);1444404795;Apply a function to the attribute of each vertex in the graph.__@param mapper the map function to apply._@param returnType the explicit return type._@return a new graph;public <NV> Graph<K, NV, EV> mapVertices(final MapFunction<Vertex<K, VV>, NV> mapper, TypeInformation<Vertex<K,NV>> returnType) {_		DataSet<Vertex<K, NV>> mappedVertices = vertices.map(_				new MapFunction<Vertex<K, VV>, Vertex<K, NV>>() {_					public Vertex<K, NV> map(Vertex<K, VV> value) throws Exception {_						return new Vertex<K, NV>(value.f0, mapper.map(value))__					}_				})_				.returns(returnType)_				.withForwardedFields("f0")___		return new Graph<K, NV, EV>(mappedVertices, this.edges, this.context)__	};apply,a,function,to,the,attribute,of,each,vertex,in,the,graph,param,mapper,the,map,function,to,apply,param,return,type,the,explicit,return,type,return,a,new,graph;public,nv,graph,k,nv,ev,map,vertices,final,map,function,vertex,k,vv,nv,mapper,type,information,vertex,k,nv,return,type,data,set,vertex,k,nv,mapped,vertices,vertices,map,new,map,function,vertex,k,vv,vertex,k,nv,public,vertex,k,nv,map,vertex,k,vv,value,throws,exception,return,new,vertex,k,nv,value,f0,mapper,map,value,returns,return,type,with,forwarded,fields,f0,return,new,graph,k,nv,ev,mapped,vertices,this,edges,this,context
Graph -> public <NV> Graph<K, NV, EV> mapVertices(final MapFunction<Vertex<K, VV>, NV> mapper, TypeInformation<Vertex<K,NV>> returnType);1445261977;Apply a function to the attribute of each vertex in the graph.__@param mapper the map function to apply._@param returnType the explicit return type._@return a new graph;public <NV> Graph<K, NV, EV> mapVertices(final MapFunction<Vertex<K, VV>, NV> mapper, TypeInformation<Vertex<K,NV>> returnType) {_		DataSet<Vertex<K, NV>> mappedVertices = vertices.map(_				new MapFunction<Vertex<K, VV>, Vertex<K, NV>>() {_					public Vertex<K, NV> map(Vertex<K, VV> value) throws Exception {_						return new Vertex<K, NV>(value.f0, mapper.map(value))__					}_				})_				.returns(returnType)_				.withForwardedFields("f0")___		return new Graph<K, NV, EV>(mappedVertices, this.edges, this.context)__	};apply,a,function,to,the,attribute,of,each,vertex,in,the,graph,param,mapper,the,map,function,to,apply,param,return,type,the,explicit,return,type,return,a,new,graph;public,nv,graph,k,nv,ev,map,vertices,final,map,function,vertex,k,vv,nv,mapper,type,information,vertex,k,nv,return,type,data,set,vertex,k,nv,mapped,vertices,vertices,map,new,map,function,vertex,k,vv,vertex,k,nv,public,vertex,k,nv,map,vertex,k,vv,value,throws,exception,return,new,vertex,k,nv,value,f0,mapper,map,value,returns,return,type,with,forwarded,fields,f0,return,new,graph,k,nv,ev,mapped,vertices,this,edges,this,context
Graph -> public <NV> Graph<K, NV, EV> mapVertices(final MapFunction<Vertex<K, VV>, NV> mapper, TypeInformation<Vertex<K,NV>> returnType);1445854323;Apply a function to the attribute of each vertex in the graph.__@param mapper the map function to apply._@param returnType the explicit return type._@return a new graph;public <NV> Graph<K, NV, EV> mapVertices(final MapFunction<Vertex<K, VV>, NV> mapper, TypeInformation<Vertex<K,NV>> returnType) {_		DataSet<Vertex<K, NV>> mappedVertices = vertices.map(_				new MapFunction<Vertex<K, VV>, Vertex<K, NV>>() {_					public Vertex<K, NV> map(Vertex<K, VV> value) throws Exception {_						return new Vertex<K, NV>(value.f0, mapper.map(value))__					}_				})_				.returns(returnType)_				.withForwardedFields("f0")___		return new Graph<K, NV, EV>(mappedVertices, this.edges, this.context)__	};apply,a,function,to,the,attribute,of,each,vertex,in,the,graph,param,mapper,the,map,function,to,apply,param,return,type,the,explicit,return,type,return,a,new,graph;public,nv,graph,k,nv,ev,map,vertices,final,map,function,vertex,k,vv,nv,mapper,type,information,vertex,k,nv,return,type,data,set,vertex,k,nv,mapped,vertices,vertices,map,new,map,function,vertex,k,vv,vertex,k,nv,public,vertex,k,nv,map,vertex,k,vv,value,throws,exception,return,new,vertex,k,nv,value,f0,mapper,map,value,returns,return,type,with,forwarded,fields,f0,return,new,graph,k,nv,ev,mapped,vertices,this,edges,this,context
Graph -> public <NV> Graph<K, NV, EV> mapVertices(final MapFunction<Vertex<K, VV>, NV> mapper, TypeInformation<Vertex<K,NV>> returnType);1446112342;Apply a function to the attribute of each vertex in the graph.__@param mapper the map function to apply._@param returnType the explicit return type._@return a new graph;public <NV> Graph<K, NV, EV> mapVertices(final MapFunction<Vertex<K, VV>, NV> mapper, TypeInformation<Vertex<K,NV>> returnType) {_		DataSet<Vertex<K, NV>> mappedVertices = vertices.map(_				new MapFunction<Vertex<K, VV>, Vertex<K, NV>>() {_					public Vertex<K, NV> map(Vertex<K, VV> value) throws Exception {_						return new Vertex<K, NV>(value.f0, mapper.map(value))__					}_				})_				.returns(returnType)_				.withForwardedFields("f0")___		return new Graph<K, NV, EV>(mappedVertices, this.edges, this.context)__	};apply,a,function,to,the,attribute,of,each,vertex,in,the,graph,param,mapper,the,map,function,to,apply,param,return,type,the,explicit,return,type,return,a,new,graph;public,nv,graph,k,nv,ev,map,vertices,final,map,function,vertex,k,vv,nv,mapper,type,information,vertex,k,nv,return,type,data,set,vertex,k,nv,mapped,vertices,vertices,map,new,map,function,vertex,k,vv,vertex,k,nv,public,vertex,k,nv,map,vertex,k,vv,value,throws,exception,return,new,vertex,k,nv,value,f0,mapper,map,value,returns,return,type,with,forwarded,fields,f0,return,new,graph,k,nv,ev,mapped,vertices,this,edges,this,context
Graph -> public <NV> Graph<K, NV, EV> mapVertices(final MapFunction<Vertex<K, VV>, NV> mapper, TypeInformation<Vertex<K,NV>> returnType);1447073368;Apply a function to the attribute of each vertex in the graph.__@param mapper the map function to apply._@param returnType the explicit return type._@return a new graph;public <NV> Graph<K, NV, EV> mapVertices(final MapFunction<Vertex<K, VV>, NV> mapper, TypeInformation<Vertex<K,NV>> returnType) {_		DataSet<Vertex<K, NV>> mappedVertices = vertices.map(_				new MapFunction<Vertex<K, VV>, Vertex<K, NV>>() {_					public Vertex<K, NV> map(Vertex<K, VV> value) throws Exception {_						return new Vertex<K, NV>(value.f0, mapper.map(value))__					}_				})_				.returns(returnType)_				.withForwardedFields("f0")___		return new Graph<K, NV, EV>(mappedVertices, this.edges, this.context)__	};apply,a,function,to,the,attribute,of,each,vertex,in,the,graph,param,mapper,the,map,function,to,apply,param,return,type,the,explicit,return,type,return,a,new,graph;public,nv,graph,k,nv,ev,map,vertices,final,map,function,vertex,k,vv,nv,mapper,type,information,vertex,k,nv,return,type,data,set,vertex,k,nv,mapped,vertices,vertices,map,new,map,function,vertex,k,vv,vertex,k,nv,public,vertex,k,nv,map,vertex,k,vv,value,throws,exception,return,new,vertex,k,nv,value,f0,mapper,map,value,returns,return,type,with,forwarded,fields,f0,return,new,graph,k,nv,ev,mapped,vertices,this,edges,this,context
Graph -> public <NV> Graph<K, NV, EV> mapVertices(final MapFunction<Vertex<K, VV>, NV> mapper, TypeInformation<Vertex<K,NV>> returnType);1454404649;Apply a function to the attribute of each vertex in the graph.__@param mapper the map function to apply._@param returnType the explicit return type._@return a new graph;public <NV> Graph<K, NV, EV> mapVertices(final MapFunction<Vertex<K, VV>, NV> mapper, TypeInformation<Vertex<K,NV>> returnType) {_		DataSet<Vertex<K, NV>> mappedVertices = vertices.map(_				new MapFunction<Vertex<K, VV>, Vertex<K, NV>>() {_					public Vertex<K, NV> map(Vertex<K, VV> value) throws Exception {_						return new Vertex<K, NV>(value.f0, mapper.map(value))__					}_				})_				.returns(returnType)_				.withForwardedFields("f0")___		return new Graph<K, NV, EV>(mappedVertices, this.edges, this.context)__	};apply,a,function,to,the,attribute,of,each,vertex,in,the,graph,param,mapper,the,map,function,to,apply,param,return,type,the,explicit,return,type,return,a,new,graph;public,nv,graph,k,nv,ev,map,vertices,final,map,function,vertex,k,vv,nv,mapper,type,information,vertex,k,nv,return,type,data,set,vertex,k,nv,mapped,vertices,vertices,map,new,map,function,vertex,k,vv,vertex,k,nv,public,vertex,k,nv,map,vertex,k,vv,value,throws,exception,return,new,vertex,k,nv,value,f0,mapper,map,value,returns,return,type,with,forwarded,fields,f0,return,new,graph,k,nv,ev,mapped,vertices,this,edges,this,context
Graph -> public <NV> Graph<K, NV, EV> mapVertices(final MapFunction<Vertex<K, VV>, NV> mapper, TypeInformation<Vertex<K,NV>> returnType);1458583829;Apply a function to the attribute of each vertex in the graph.__@param mapper the map function to apply._@param returnType the explicit return type._@return a new graph;public <NV> Graph<K, NV, EV> mapVertices(final MapFunction<Vertex<K, VV>, NV> mapper, TypeInformation<Vertex<K,NV>> returnType) {_		DataSet<Vertex<K, NV>> mappedVertices = vertices.map(_				new MapFunction<Vertex<K, VV>, Vertex<K, NV>>() {_					public Vertex<K, NV> map(Vertex<K, VV> value) throws Exception {_						return new Vertex<K, NV>(value.f0, mapper.map(value))__					}_				})_				.returns(returnType)_				.withForwardedFields("f0")___		return new Graph<K, NV, EV>(mappedVertices, this.edges, this.context)__	};apply,a,function,to,the,attribute,of,each,vertex,in,the,graph,param,mapper,the,map,function,to,apply,param,return,type,the,explicit,return,type,return,a,new,graph;public,nv,graph,k,nv,ev,map,vertices,final,map,function,vertex,k,vv,nv,mapper,type,information,vertex,k,nv,return,type,data,set,vertex,k,nv,mapped,vertices,vertices,map,new,map,function,vertex,k,vv,vertex,k,nv,public,vertex,k,nv,map,vertex,k,vv,value,throws,exception,return,new,vertex,k,nv,value,f0,mapper,map,value,returns,return,type,with,forwarded,fields,f0,return,new,graph,k,nv,ev,mapped,vertices,this,edges,this,context
Graph -> public <NV> Graph<K, NV, EV> mapVertices(final MapFunction<Vertex<K, VV>, NV> mapper, TypeInformation<Vertex<K,NV>> returnType);1458583829;Apply a function to the attribute of each vertex in the graph.__@param mapper the map function to apply._@param returnType the explicit return type._@return a new graph;public <NV> Graph<K, NV, EV> mapVertices(final MapFunction<Vertex<K, VV>, NV> mapper, TypeInformation<Vertex<K,NV>> returnType) {_		DataSet<Vertex<K, NV>> mappedVertices = vertices.map(_				new MapFunction<Vertex<K, VV>, Vertex<K, NV>>() {_					public Vertex<K, NV> map(Vertex<K, VV> value) throws Exception {_						return new Vertex<K, NV>(value.f0, mapper.map(value))__					}_				})_				.returns(returnType)_				.withForwardedFields("f0")___		return new Graph<K, NV, EV>(mappedVertices, this.edges, this.context)__	};apply,a,function,to,the,attribute,of,each,vertex,in,the,graph,param,mapper,the,map,function,to,apply,param,return,type,the,explicit,return,type,return,a,new,graph;public,nv,graph,k,nv,ev,map,vertices,final,map,function,vertex,k,vv,nv,mapper,type,information,vertex,k,nv,return,type,data,set,vertex,k,nv,mapped,vertices,vertices,map,new,map,function,vertex,k,vv,vertex,k,nv,public,vertex,k,nv,map,vertex,k,vv,value,throws,exception,return,new,vertex,k,nv,value,f0,mapper,map,value,returns,return,type,with,forwarded,fields,f0,return,new,graph,k,nv,ev,mapped,vertices,this,edges,this,context
Graph -> public <NV> Graph<K, NV, EV> mapVertices(final MapFunction<Vertex<K, VV>, NV> mapper, TypeInformation<Vertex<K,NV>> returnType);1462100316;Apply a function to the attribute of each vertex in the graph.__@param mapper the map function to apply._@param returnType the explicit return type._@return a new graph;public <NV> Graph<K, NV, EV> mapVertices(final MapFunction<Vertex<K, VV>, NV> mapper, TypeInformation<Vertex<K,NV>> returnType) {_		DataSet<Vertex<K, NV>> mappedVertices = vertices.map(_				new MapFunction<Vertex<K, VV>, Vertex<K, NV>>() {_					public Vertex<K, NV> map(Vertex<K, VV> value) throws Exception {_						return new Vertex<K, NV>(value.f0, mapper.map(value))__					}_				})_				.returns(returnType)_				.withForwardedFields("f0")___		return new Graph<K, NV, EV>(mappedVertices, this.edges, this.context)__	};apply,a,function,to,the,attribute,of,each,vertex,in,the,graph,param,mapper,the,map,function,to,apply,param,return,type,the,explicit,return,type,return,a,new,graph;public,nv,graph,k,nv,ev,map,vertices,final,map,function,vertex,k,vv,nv,mapper,type,information,vertex,k,nv,return,type,data,set,vertex,k,nv,mapped,vertices,vertices,map,new,map,function,vertex,k,vv,vertex,k,nv,public,vertex,k,nv,map,vertex,k,vv,value,throws,exception,return,new,vertex,k,nv,value,f0,mapper,map,value,returns,return,type,with,forwarded,fields,f0,return,new,graph,k,nv,ev,mapped,vertices,this,edges,this,context
Graph -> public <NV> Graph<K, NV, EV> mapVertices(final MapFunction<Vertex<K, VV>, NV> mapper, TypeInformation<Vertex<K,NV>> returnType);1462100316;Apply a function to the attribute of each vertex in the graph.__@param mapper the map function to apply._@param returnType the explicit return type._@return a new graph;public <NV> Graph<K, NV, EV> mapVertices(final MapFunction<Vertex<K, VV>, NV> mapper, TypeInformation<Vertex<K,NV>> returnType) {_		DataSet<Vertex<K, NV>> mappedVertices = vertices.map(_				new MapFunction<Vertex<K, VV>, Vertex<K, NV>>() {_					public Vertex<K, NV> map(Vertex<K, VV> value) throws Exception {_						return new Vertex<K, NV>(value.f0, mapper.map(value))__					}_				})_				.returns(returnType)_				.withForwardedFields("f0")___		return new Graph<K, NV, EV>(mappedVertices, this.edges, this.context)__	};apply,a,function,to,the,attribute,of,each,vertex,in,the,graph,param,mapper,the,map,function,to,apply,param,return,type,the,explicit,return,type,return,a,new,graph;public,nv,graph,k,nv,ev,map,vertices,final,map,function,vertex,k,vv,nv,mapper,type,information,vertex,k,nv,return,type,data,set,vertex,k,nv,mapped,vertices,vertices,map,new,map,function,vertex,k,vv,vertex,k,nv,public,vertex,k,nv,map,vertex,k,vv,value,throws,exception,return,new,vertex,k,nv,value,f0,mapper,map,value,returns,return,type,with,forwarded,fields,f0,return,new,graph,k,nv,ev,mapped,vertices,this,edges,this,context
Graph -> public <NV> Graph<K, NV, EV> mapVertices(final MapFunction<Vertex<K, VV>, NV> mapper, TypeInformation<Vertex<K,NV>> returnType);1462205213;Apply a function to the attribute of each vertex in the graph.__@param mapper the map function to apply._@param returnType the explicit return type._@return a new graph;public <NV> Graph<K, NV, EV> mapVertices(final MapFunction<Vertex<K, VV>, NV> mapper, TypeInformation<Vertex<K,NV>> returnType) {_		DataSet<Vertex<K, NV>> mappedVertices = vertices.map(_				new MapFunction<Vertex<K, VV>, Vertex<K, NV>>() {_					public Vertex<K, NV> map(Vertex<K, VV> value) throws Exception {_						return new Vertex<K, NV>(value.f0, mapper.map(value))__					}_				})_				.returns(returnType)_				.withForwardedFields("f0")___		return new Graph<K, NV, EV>(mappedVertices, this.edges, this.context)__	};apply,a,function,to,the,attribute,of,each,vertex,in,the,graph,param,mapper,the,map,function,to,apply,param,return,type,the,explicit,return,type,return,a,new,graph;public,nv,graph,k,nv,ev,map,vertices,final,map,function,vertex,k,vv,nv,mapper,type,information,vertex,k,nv,return,type,data,set,vertex,k,nv,mapped,vertices,vertices,map,new,map,function,vertex,k,vv,vertex,k,nv,public,vertex,k,nv,map,vertex,k,vv,value,throws,exception,return,new,vertex,k,nv,value,f0,mapper,map,value,returns,return,type,with,forwarded,fields,f0,return,new,graph,k,nv,ev,mapped,vertices,this,edges,this,context
Graph -> public <NV> Graph<K, NV, EV> mapVertices(final MapFunction<Vertex<K, VV>, NV> mapper, TypeInformation<Vertex<K,NV>> returnType);1462208859;Apply a function to the attribute of each vertex in the graph.__@param mapper the map function to apply._@param returnType the explicit return type._@return a new graph;public <NV> Graph<K, NV, EV> mapVertices(final MapFunction<Vertex<K, VV>, NV> mapper, TypeInformation<Vertex<K,NV>> returnType) {_		DataSet<Vertex<K, NV>> mappedVertices = vertices.map(_				new MapFunction<Vertex<K, VV>, Vertex<K, NV>>() {_					public Vertex<K, NV> map(Vertex<K, VV> value) throws Exception {_						return new Vertex<K, NV>(value.f0, mapper.map(value))__					}_				})_				.returns(returnType)_				.withForwardedFields("f0")___		return new Graph<K, NV, EV>(mappedVertices, this.edges, this.context)__	};apply,a,function,to,the,attribute,of,each,vertex,in,the,graph,param,mapper,the,map,function,to,apply,param,return,type,the,explicit,return,type,return,a,new,graph;public,nv,graph,k,nv,ev,map,vertices,final,map,function,vertex,k,vv,nv,mapper,type,information,vertex,k,nv,return,type,data,set,vertex,k,nv,mapped,vertices,vertices,map,new,map,function,vertex,k,vv,vertex,k,nv,public,vertex,k,nv,map,vertex,k,vv,value,throws,exception,return,new,vertex,k,nv,value,f0,mapper,map,value,returns,return,type,with,forwarded,fields,f0,return,new,graph,k,nv,ev,mapped,vertices,this,edges,this,context
Graph -> public <NV> Graph<K, NV, EV> mapVertices(final MapFunction<Vertex<K, VV>, NV> mapper, TypeInformation<Vertex<K,NV>> returnType);1462809297;Apply a function to the attribute of each vertex in the graph.__@param mapper the map function to apply._@param returnType the explicit return type._@return a new graph;public <NV> Graph<K, NV, EV> mapVertices(final MapFunction<Vertex<K, VV>, NV> mapper, TypeInformation<Vertex<K,NV>> returnType) {_		DataSet<Vertex<K, NV>> mappedVertices = vertices.map(_				new MapFunction<Vertex<K, VV>, Vertex<K, NV>>() {_					public Vertex<K, NV> map(Vertex<K, VV> value) throws Exception {_						return new Vertex<K, NV>(value.f0, mapper.map(value))__					}_				})_				.returns(returnType)_				.withForwardedFields("f0")___		return new Graph<K, NV, EV>(mappedVertices, this.edges, this.context)__	};apply,a,function,to,the,attribute,of,each,vertex,in,the,graph,param,mapper,the,map,function,to,apply,param,return,type,the,explicit,return,type,return,a,new,graph;public,nv,graph,k,nv,ev,map,vertices,final,map,function,vertex,k,vv,nv,mapper,type,information,vertex,k,nv,return,type,data,set,vertex,k,nv,mapped,vertices,vertices,map,new,map,function,vertex,k,vv,vertex,k,nv,public,vertex,k,nv,map,vertex,k,vv,value,throws,exception,return,new,vertex,k,nv,value,f0,mapper,map,value,returns,return,type,with,forwarded,fields,f0,return,new,graph,k,nv,ev,mapped,vertices,this,edges,this,context
Graph -> public <NV> Graph<K, NV, EV> mapVertices(final MapFunction<Vertex<K, VV>, NV> mapper, TypeInformation<Vertex<K,NV>> returnType);1465316775;Apply a function to the attribute of each vertex in the graph.__@param mapper the map function to apply._@param returnType the explicit return type._@return a new graph;public <NV> Graph<K, NV, EV> mapVertices(final MapFunction<Vertex<K, VV>, NV> mapper, TypeInformation<Vertex<K,NV>> returnType) {_		DataSet<Vertex<K, NV>> mappedVertices = vertices.map(_				new MapFunction<Vertex<K, VV>, Vertex<K, NV>>() {_					public Vertex<K, NV> map(Vertex<K, VV> value) throws Exception {_						return new Vertex<K, NV>(value.f0, mapper.map(value))__					}_				})_				.returns(returnType)_				.withForwardedFields("f0")___		return new Graph<K, NV, EV>(mappedVertices, this.edges, this.context)__	};apply,a,function,to,the,attribute,of,each,vertex,in,the,graph,param,mapper,the,map,function,to,apply,param,return,type,the,explicit,return,type,return,a,new,graph;public,nv,graph,k,nv,ev,map,vertices,final,map,function,vertex,k,vv,nv,mapper,type,information,vertex,k,nv,return,type,data,set,vertex,k,nv,mapped,vertices,vertices,map,new,map,function,vertex,k,vv,vertex,k,nv,public,vertex,k,nv,map,vertex,k,vv,value,throws,exception,return,new,vertex,k,nv,value,f0,mapper,map,value,returns,return,type,with,forwarded,fields,f0,return,new,graph,k,nv,ev,mapped,vertices,this,edges,this,context
Graph -> public <NV> Graph<K, NV, EV> mapVertices(final MapFunction<Vertex<K, VV>, NV> mapper, TypeInformation<Vertex<K,NV>> returnType);1466789678;Apply a function to the attribute of each vertex in the graph.__@param mapper the map function to apply._@param returnType the explicit return type._@return a new graph;public <NV> Graph<K, NV, EV> mapVertices(final MapFunction<Vertex<K, VV>, NV> mapper, TypeInformation<Vertex<K,NV>> returnType) {_		DataSet<Vertex<K, NV>> mappedVertices = vertices.map(_				new MapFunction<Vertex<K, VV>, Vertex<K, NV>>() {_					public Vertex<K, NV> map(Vertex<K, VV> value) throws Exception {_						return new Vertex<K, NV>(value.f0, mapper.map(value))__					}_				})_				.returns(returnType)_				.withForwardedFields("f0")___		return new Graph<K, NV, EV>(mappedVertices, this.edges, this.context)__	};apply,a,function,to,the,attribute,of,each,vertex,in,the,graph,param,mapper,the,map,function,to,apply,param,return,type,the,explicit,return,type,return,a,new,graph;public,nv,graph,k,nv,ev,map,vertices,final,map,function,vertex,k,vv,nv,mapper,type,information,vertex,k,nv,return,type,data,set,vertex,k,nv,mapped,vertices,vertices,map,new,map,function,vertex,k,vv,vertex,k,nv,public,vertex,k,nv,map,vertex,k,vv,value,throws,exception,return,new,vertex,k,nv,value,f0,mapper,map,value,returns,return,type,with,forwarded,fields,f0,return,new,graph,k,nv,ev,mapped,vertices,this,edges,this,context
Graph -> public <NV> Graph<K, NV, EV> mapVertices(final MapFunction<Vertex<K, VV>, NV> mapper, TypeInformation<Vertex<K,NV>> returnType);1467140656;Apply a function to the attribute of each vertex in the graph.__@param mapper the map function to apply._@param returnType the explicit return type._@return a new graph;public <NV> Graph<K, NV, EV> mapVertices(final MapFunction<Vertex<K, VV>, NV> mapper, TypeInformation<Vertex<K,NV>> returnType) {_		DataSet<Vertex<K, NV>> mappedVertices = vertices.map(_				new MapFunction<Vertex<K, VV>, Vertex<K, NV>>() {_					public Vertex<K, NV> map(Vertex<K, VV> value) throws Exception {_						return new Vertex<K, NV>(value.f0, mapper.map(value))__					}_				})_				.returns(returnType)_				.withForwardedFields("f0")___		return new Graph<K, NV, EV>(mappedVertices, this.edges, this.context)__	};apply,a,function,to,the,attribute,of,each,vertex,in,the,graph,param,mapper,the,map,function,to,apply,param,return,type,the,explicit,return,type,return,a,new,graph;public,nv,graph,k,nv,ev,map,vertices,final,map,function,vertex,k,vv,nv,mapper,type,information,vertex,k,nv,return,type,data,set,vertex,k,nv,mapped,vertices,vertices,map,new,map,function,vertex,k,vv,vertex,k,nv,public,vertex,k,nv,map,vertex,k,vv,value,throws,exception,return,new,vertex,k,nv,value,f0,mapper,map,value,returns,return,type,with,forwarded,fields,f0,return,new,graph,k,nv,ev,mapped,vertices,this,edges,this,context
Graph -> public <NV> Graph<K, NV, EV> mapVertices(final MapFunction<Vertex<K, VV>, NV> mapper, TypeInformation<Vertex<K,NV>> returnType);1467306272;Apply a function to the attribute of each vertex in the graph.__@param mapper the map function to apply._@param returnType the explicit return type._@return a new graph;public <NV> Graph<K, NV, EV> mapVertices(final MapFunction<Vertex<K, VV>, NV> mapper, TypeInformation<Vertex<K,NV>> returnType) {_		DataSet<Vertex<K, NV>> mappedVertices = vertices.map(_				new MapFunction<Vertex<K, VV>, Vertex<K, NV>>() {_					public Vertex<K, NV> map(Vertex<K, VV> value) throws Exception {_						return new Vertex<K, NV>(value.f0, mapper.map(value))__					}_				})_				.returns(returnType)_				.withForwardedFields("f0")___		return new Graph<K, NV, EV>(mappedVertices, this.edges, this.context)__	};apply,a,function,to,the,attribute,of,each,vertex,in,the,graph,param,mapper,the,map,function,to,apply,param,return,type,the,explicit,return,type,return,a,new,graph;public,nv,graph,k,nv,ev,map,vertices,final,map,function,vertex,k,vv,nv,mapper,type,information,vertex,k,nv,return,type,data,set,vertex,k,nv,mapped,vertices,vertices,map,new,map,function,vertex,k,vv,vertex,k,nv,public,vertex,k,nv,map,vertex,k,vv,value,throws,exception,return,new,vertex,k,nv,value,f0,mapper,map,value,returns,return,type,with,forwarded,fields,f0,return,new,graph,k,nv,ev,mapped,vertices,this,edges,this,context
Graph -> public <NV> Graph<K, NV, EV> mapVertices(final MapFunction<Vertex<K, VV>, NV> mapper, TypeInformation<Vertex<K,NV>> returnType);1470042815;Apply a function to the attribute of each vertex in the graph.__@param mapper the map function to apply._@param returnType the explicit return type._@return a new graph;public <NV> Graph<K, NV, EV> mapVertices(final MapFunction<Vertex<K, VV>, NV> mapper, TypeInformation<Vertex<K,NV>> returnType) {_		DataSet<Vertex<K, NV>> mappedVertices = vertices.map(_				new MapFunction<Vertex<K, VV>, Vertex<K, NV>>() {_					public Vertex<K, NV> map(Vertex<K, VV> value) throws Exception {_						return new Vertex<K, NV>(value.f0, mapper.map(value))__					}_				})_				.returns(returnType)_				.withForwardedFields("f0")___		return new Graph<K, NV, EV>(mappedVertices, this.edges, this.context)__	};apply,a,function,to,the,attribute,of,each,vertex,in,the,graph,param,mapper,the,map,function,to,apply,param,return,type,the,explicit,return,type,return,a,new,graph;public,nv,graph,k,nv,ev,map,vertices,final,map,function,vertex,k,vv,nv,mapper,type,information,vertex,k,nv,return,type,data,set,vertex,k,nv,mapped,vertices,vertices,map,new,map,function,vertex,k,vv,vertex,k,nv,public,vertex,k,nv,map,vertex,k,vv,value,throws,exception,return,new,vertex,k,nv,value,f0,mapper,map,value,returns,return,type,with,forwarded,fields,f0,return,new,graph,k,nv,ev,mapped,vertices,this,edges,this,context
Graph -> public <NV> Graph<K, NV, EV> mapVertices(final MapFunction<Vertex<K, VV>, NV> mapper, TypeInformation<Vertex<K,NV>> returnType);1475684776;Apply a function to the attribute of each vertex in the graph.__@param mapper the map function to apply._@param returnType the explicit return type._@return a new graph;public <NV> Graph<K, NV, EV> mapVertices(final MapFunction<Vertex<K, VV>, NV> mapper, TypeInformation<Vertex<K,NV>> returnType) {_		DataSet<Vertex<K, NV>> mappedVertices = vertices.map(_				new MapFunction<Vertex<K, VV>, Vertex<K, NV>>() {_					public Vertex<K, NV> map(Vertex<K, VV> value) throws Exception {_						return new Vertex<>(value.f0, mapper.map(value))__					}_				})_				.returns(returnType)_				.withForwardedFields("f0")___		return new Graph<>(mappedVertices, this.edges, this.context)__	};apply,a,function,to,the,attribute,of,each,vertex,in,the,graph,param,mapper,the,map,function,to,apply,param,return,type,the,explicit,return,type,return,a,new,graph;public,nv,graph,k,nv,ev,map,vertices,final,map,function,vertex,k,vv,nv,mapper,type,information,vertex,k,nv,return,type,data,set,vertex,k,nv,mapped,vertices,vertices,map,new,map,function,vertex,k,vv,vertex,k,nv,public,vertex,k,nv,map,vertex,k,vv,value,throws,exception,return,new,vertex,value,f0,mapper,map,value,returns,return,type,with,forwarded,fields,f0,return,new,graph,mapped,vertices,this,edges,this,context
Graph -> public <NV> Graph<K, NV, EV> mapVertices(final MapFunction<Vertex<K, VV>, NV> mapper, TypeInformation<Vertex<K,NV>> returnType);1475685606;Apply a function to the attribute of each vertex in the graph.__@param mapper the map function to apply._@param returnType the explicit return type._@return a new graph;public <NV> Graph<K, NV, EV> mapVertices(final MapFunction<Vertex<K, VV>, NV> mapper, TypeInformation<Vertex<K,NV>> returnType) {_		DataSet<Vertex<K, NV>> mappedVertices = vertices.map(_				new MapFunction<Vertex<K, VV>, Vertex<K, NV>>() {_					public Vertex<K, NV> map(Vertex<K, VV> value) throws Exception {_						return new Vertex<>(value.f0, mapper.map(value))__					}_				})_				.returns(returnType)_				.withForwardedFields("f0")___		return new Graph<>(mappedVertices, this.edges, this.context)__	};apply,a,function,to,the,attribute,of,each,vertex,in,the,graph,param,mapper,the,map,function,to,apply,param,return,type,the,explicit,return,type,return,a,new,graph;public,nv,graph,k,nv,ev,map,vertices,final,map,function,vertex,k,vv,nv,mapper,type,information,vertex,k,nv,return,type,data,set,vertex,k,nv,mapped,vertices,vertices,map,new,map,function,vertex,k,vv,vertex,k,nv,public,vertex,k,nv,map,vertex,k,vv,value,throws,exception,return,new,vertex,value,f0,mapper,map,value,returns,return,type,with,forwarded,fields,f0,return,new,graph,mapped,vertices,this,edges,this,context
Graph -> public <NV> Graph<K, NV, EV> mapVertices(final MapFunction<Vertex<K, VV>, NV> mapper, TypeInformation<Vertex<K,NV>> returnType);1481745825;Apply a function to the attribute of each vertex in the graph.__@param mapper the map function to apply._@param returnType the explicit return type._@return a new graph;public <NV> Graph<K, NV, EV> mapVertices(final MapFunction<Vertex<K, VV>, NV> mapper, TypeInformation<Vertex<K,NV>> returnType) {_		DataSet<Vertex<K, NV>> mappedVertices = vertices.map(_				new MapFunction<Vertex<K, VV>, Vertex<K, NV>>() {_					private Vertex<K, NV> output = new Vertex<>()___					public Vertex<K, NV> map(Vertex<K, VV> value) throws Exception {_						output.f0 = value.f0__						output.f1 = mapper.map(value)__						return output__					}_				})_				.returns(returnType)_				.withForwardedFields("f0")_					.name("Map vertices")___		return new Graph<>(mappedVertices, this.edges, this.context)__	};apply,a,function,to,the,attribute,of,each,vertex,in,the,graph,param,mapper,the,map,function,to,apply,param,return,type,the,explicit,return,type,return,a,new,graph;public,nv,graph,k,nv,ev,map,vertices,final,map,function,vertex,k,vv,nv,mapper,type,information,vertex,k,nv,return,type,data,set,vertex,k,nv,mapped,vertices,vertices,map,new,map,function,vertex,k,vv,vertex,k,nv,private,vertex,k,nv,output,new,vertex,public,vertex,k,nv,map,vertex,k,vv,value,throws,exception,output,f0,value,f0,output,f1,mapper,map,value,return,output,returns,return,type,with,forwarded,fields,f0,name,map,vertices,return,new,graph,mapped,vertices,this,edges,this,context
Graph -> public <NV> Graph<K, NV, EV> mapVertices(final MapFunction<Vertex<K, VV>, NV> mapper, TypeInformation<Vertex<K,NV>> returnType);1481881009;Apply a function to the attribute of each vertex in the graph.__@param mapper the map function to apply._@param returnType the explicit return type._@return a new graph;public <NV> Graph<K, NV, EV> mapVertices(final MapFunction<Vertex<K, VV>, NV> mapper, TypeInformation<Vertex<K,NV>> returnType) {_		DataSet<Vertex<K, NV>> mappedVertices = vertices.map(_				new MapFunction<Vertex<K, VV>, Vertex<K, NV>>() {_					private Vertex<K, NV> output = new Vertex<>()___					public Vertex<K, NV> map(Vertex<K, VV> value) throws Exception {_						output.f0 = value.f0__						output.f1 = mapper.map(value)__						return output__					}_				})_				.returns(returnType)_				.withForwardedFields("f0")_					.name("Map vertices")___		return new Graph<>(mappedVertices, this.edges, this.context)__	};apply,a,function,to,the,attribute,of,each,vertex,in,the,graph,param,mapper,the,map,function,to,apply,param,return,type,the,explicit,return,type,return,a,new,graph;public,nv,graph,k,nv,ev,map,vertices,final,map,function,vertex,k,vv,nv,mapper,type,information,vertex,k,nv,return,type,data,set,vertex,k,nv,mapped,vertices,vertices,map,new,map,function,vertex,k,vv,vertex,k,nv,private,vertex,k,nv,output,new,vertex,public,vertex,k,nv,map,vertex,k,vv,value,throws,exception,output,f0,value,f0,output,f1,mapper,map,value,return,output,returns,return,type,with,forwarded,fields,f0,name,map,vertices,return,new,graph,mapped,vertices,this,edges,this,context
Graph -> public <NV> Graph<K, NV, EV> mapVertices(final MapFunction<Vertex<K, VV>, NV> mapper, TypeInformation<Vertex<K,NV>> returnType);1484160227;Apply a function to the attribute of each vertex in the graph.__@param mapper the map function to apply._@param returnType the explicit return type._@return a new graph;public <NV> Graph<K, NV, EV> mapVertices(final MapFunction<Vertex<K, VV>, NV> mapper, TypeInformation<Vertex<K,NV>> returnType) {_		DataSet<Vertex<K, NV>> mappedVertices = vertices.map(_				new MapFunction<Vertex<K, VV>, Vertex<K, NV>>() {_					private Vertex<K, NV> output = new Vertex<>()___					public Vertex<K, NV> map(Vertex<K, VV> value) throws Exception {_						output.f0 = value.f0__						output.f1 = mapper.map(value)__						return output__					}_				})_				.returns(returnType)_				.withForwardedFields("f0")_					.name("Map vertices")___		return new Graph<>(mappedVertices, this.edges, this.context)__	};apply,a,function,to,the,attribute,of,each,vertex,in,the,graph,param,mapper,the,map,function,to,apply,param,return,type,the,explicit,return,type,return,a,new,graph;public,nv,graph,k,nv,ev,map,vertices,final,map,function,vertex,k,vv,nv,mapper,type,information,vertex,k,nv,return,type,data,set,vertex,k,nv,mapped,vertices,vertices,map,new,map,function,vertex,k,vv,vertex,k,nv,private,vertex,k,nv,output,new,vertex,public,vertex,k,nv,map,vertex,k,vv,value,throws,exception,output,f0,value,f0,output,f1,mapper,map,value,return,output,returns,return,type,with,forwarded,fields,f0,name,map,vertices,return,new,graph,mapped,vertices,this,edges,this,context
Graph -> public <NEW> Graph<K, VV, NEW> translateEdgeValues(TranslateFunction<EV, NEW> translator) throws Exception;1462809297;Translate {@link Edge} values using the given {@link MapFunction}.__@param translator implements conversion from {@code EV} to {@code NEW}_@param <NEW> new edge value type_@return graph with translated edge values_@throws Exception;public <NEW> Graph<K, VV, NEW> translateEdgeValues(TranslateFunction<EV, NEW> translator) throws Exception {_		return run(new TranslateEdgeValues<K, VV, EV, NEW>(translator))__	};translate,link,edge,values,using,the,given,link,map,function,param,translator,implements,conversion,from,code,ev,to,code,new,param,new,new,edge,value,type,return,graph,with,translated,edge,values,throws,exception;public,new,graph,k,vv,new,translate,edge,values,translate,function,ev,new,translator,throws,exception,return,run,new,translate,edge,values,k,vv,ev,new,translator
Graph -> public <NEW> Graph<K, VV, NEW> translateEdgeValues(TranslateFunction<EV, NEW> translator) throws Exception;1465316775;Translate {@link Edge} values using the given {@link MapFunction}.__@param translator implements conversion from {@code EV} to {@code NEW}_@param <NEW> new edge value type_@return graph with translated edge values_@throws Exception;public <NEW> Graph<K, VV, NEW> translateEdgeValues(TranslateFunction<EV, NEW> translator) throws Exception {_		return run(new TranslateEdgeValues<K, VV, EV, NEW>(translator))__	};translate,link,edge,values,using,the,given,link,map,function,param,translator,implements,conversion,from,code,ev,to,code,new,param,new,new,edge,value,type,return,graph,with,translated,edge,values,throws,exception;public,new,graph,k,vv,new,translate,edge,values,translate,function,ev,new,translator,throws,exception,return,run,new,translate,edge,values,k,vv,ev,new,translator
Graph -> public <NEW> Graph<K, VV, NEW> translateEdgeValues(TranslateFunction<EV, NEW> translator) throws Exception;1466789678;Translate {@link Edge} values using the given {@link MapFunction}.__@param translator implements conversion from {@code EV} to {@code NEW}_@param <NEW> new edge value type_@return graph with translated edge values_@throws Exception;public <NEW> Graph<K, VV, NEW> translateEdgeValues(TranslateFunction<EV, NEW> translator) throws Exception {_		return run(new TranslateEdgeValues<K, VV, EV, NEW>(translator))__	};translate,link,edge,values,using,the,given,link,map,function,param,translator,implements,conversion,from,code,ev,to,code,new,param,new,new,edge,value,type,return,graph,with,translated,edge,values,throws,exception;public,new,graph,k,vv,new,translate,edge,values,translate,function,ev,new,translator,throws,exception,return,run,new,translate,edge,values,k,vv,ev,new,translator
Graph -> public <NEW> Graph<K, VV, NEW> translateEdgeValues(TranslateFunction<EV, NEW> translator) throws Exception;1467140656;Translate {@link Edge} values using the given {@link MapFunction}.__@param translator implements conversion from {@code EV} to {@code NEW}_@param <NEW> new edge value type_@return graph with translated edge values_@throws Exception;public <NEW> Graph<K, VV, NEW> translateEdgeValues(TranslateFunction<EV, NEW> translator) throws Exception {_		return run(new TranslateEdgeValues<K, VV, EV, NEW>(translator))__	};translate,link,edge,values,using,the,given,link,map,function,param,translator,implements,conversion,from,code,ev,to,code,new,param,new,new,edge,value,type,return,graph,with,translated,edge,values,throws,exception;public,new,graph,k,vv,new,translate,edge,values,translate,function,ev,new,translator,throws,exception,return,run,new,translate,edge,values,k,vv,ev,new,translator
Graph -> public <NEW> Graph<K, VV, NEW> translateEdgeValues(TranslateFunction<EV, NEW> translator) throws Exception;1467306272;Translate {@link Edge} values using the given {@link MapFunction}.__@param translator implements conversion from {@code EV} to {@code NEW}_@param <NEW> new edge value type_@return graph with translated edge values_@throws Exception;public <NEW> Graph<K, VV, NEW> translateEdgeValues(TranslateFunction<EV, NEW> translator) throws Exception {_		return run(new TranslateEdgeValues<K, VV, EV, NEW>(translator))__	};translate,link,edge,values,using,the,given,link,map,function,param,translator,implements,conversion,from,code,ev,to,code,new,param,new,new,edge,value,type,return,graph,with,translated,edge,values,throws,exception;public,new,graph,k,vv,new,translate,edge,values,translate,function,ev,new,translator,throws,exception,return,run,new,translate,edge,values,k,vv,ev,new,translator
Graph -> public <NEW> Graph<K, VV, NEW> translateEdgeValues(TranslateFunction<EV, NEW> translator) throws Exception;1470042815;Translate {@link Edge} values using the given {@link MapFunction}.__@param translator implements conversion from {@code EV} to {@code NEW}_@param <NEW> new edge value type_@return graph with translated edge values_@throws Exception;public <NEW> Graph<K, VV, NEW> translateEdgeValues(TranslateFunction<EV, NEW> translator) throws Exception {_		return run(new TranslateEdgeValues<K, VV, EV, NEW>(translator))__	};translate,link,edge,values,using,the,given,link,map,function,param,translator,implements,conversion,from,code,ev,to,code,new,param,new,new,edge,value,type,return,graph,with,translated,edge,values,throws,exception;public,new,graph,k,vv,new,translate,edge,values,translate,function,ev,new,translator,throws,exception,return,run,new,translate,edge,values,k,vv,ev,new,translator
Graph -> public <NEW> Graph<K, VV, NEW> translateEdgeValues(TranslateFunction<EV, NEW> translator) throws Exception;1475684776;Translate {@link Edge} values using the given {@link MapFunction}.__@param translator implements conversion from {@code EV} to {@code NEW}_@param <NEW> new edge value type_@return graph with translated edge values_@throws Exception;public <NEW> Graph<K, VV, NEW> translateEdgeValues(TranslateFunction<EV, NEW> translator) throws Exception {_		return run(new TranslateEdgeValues<K, VV, EV, NEW>(translator))__	};translate,link,edge,values,using,the,given,link,map,function,param,translator,implements,conversion,from,code,ev,to,code,new,param,new,new,edge,value,type,return,graph,with,translated,edge,values,throws,exception;public,new,graph,k,vv,new,translate,edge,values,translate,function,ev,new,translator,throws,exception,return,run,new,translate,edge,values,k,vv,ev,new,translator
Graph -> public <NEW> Graph<K, VV, NEW> translateEdgeValues(TranslateFunction<EV, NEW> translator) throws Exception;1475685606;Translate {@link Edge} values using the given {@link MapFunction}.__@param translator implements conversion from {@code EV} to {@code NEW}_@param <NEW> new edge value type_@return graph with translated edge values_@throws Exception;public <NEW> Graph<K, VV, NEW> translateEdgeValues(TranslateFunction<EV, NEW> translator) throws Exception {_		return run(new TranslateEdgeValues<K, VV, EV, NEW>(translator))__	};translate,link,edge,values,using,the,given,link,map,function,param,translator,implements,conversion,from,code,ev,to,code,new,param,new,new,edge,value,type,return,graph,with,translated,edge,values,throws,exception;public,new,graph,k,vv,new,translate,edge,values,translate,function,ev,new,translator,throws,exception,return,run,new,translate,edge,values,k,vv,ev,new,translator
Graph -> public <NEW> Graph<K, VV, NEW> translateEdgeValues(TranslateFunction<EV, NEW> translator) throws Exception;1481745825;Translate {@link Edge} values using the given {@link MapFunction}.__@param translator implements conversion from {@code EV} to {@code NEW}_@param <NEW> new edge value type_@return graph with translated edge values_@throws Exception;public <NEW> Graph<K, VV, NEW> translateEdgeValues(TranslateFunction<EV, NEW> translator) throws Exception {_		return run(new TranslateEdgeValues<K, VV, EV, NEW>(translator))__	};translate,link,edge,values,using,the,given,link,map,function,param,translator,implements,conversion,from,code,ev,to,code,new,param,new,new,edge,value,type,return,graph,with,translated,edge,values,throws,exception;public,new,graph,k,vv,new,translate,edge,values,translate,function,ev,new,translator,throws,exception,return,run,new,translate,edge,values,k,vv,ev,new,translator
Graph -> public <NEW> Graph<K, VV, NEW> translateEdgeValues(TranslateFunction<EV, NEW> translator) throws Exception;1481881009;Translate {@link Edge} values using the given {@link MapFunction}.__@param translator implements conversion from {@code EV} to {@code NEW}_@param <NEW> new edge value type_@return graph with translated edge values_@throws Exception;public <NEW> Graph<K, VV, NEW> translateEdgeValues(TranslateFunction<EV, NEW> translator) throws Exception {_		return run(new TranslateEdgeValues<K, VV, EV, NEW>(translator))__	};translate,link,edge,values,using,the,given,link,map,function,param,translator,implements,conversion,from,code,ev,to,code,new,param,new,new,edge,value,type,return,graph,with,translated,edge,values,throws,exception;public,new,graph,k,vv,new,translate,edge,values,translate,function,ev,new,translator,throws,exception,return,run,new,translate,edge,values,k,vv,ev,new,translator
Graph -> public <NEW> Graph<K, VV, NEW> translateEdgeValues(TranslateFunction<EV, NEW> translator) throws Exception;1484160227;Translate {@link Edge} values using the given {@link MapFunction}.__@param translator implements conversion from {@code EV} to {@code NEW}_@param <NEW> new edge value type_@return graph with translated edge values_@throws Exception;public <NEW> Graph<K, VV, NEW> translateEdgeValues(TranslateFunction<EV, NEW> translator) throws Exception {_		return run(new TranslateEdgeValues<K, VV, EV, NEW>(translator))__	};translate,link,edge,values,using,the,given,link,map,function,param,translator,implements,conversion,from,code,ev,to,code,new,param,new,new,edge,value,type,return,graph,with,translated,edge,values,throws,exception;public,new,graph,k,vv,new,translate,edge,values,translate,function,ev,new,translator,throws,exception,return,run,new,translate,edge,values,k,vv,ev,new,translator
Graph -> public <NEW> Graph<K, VV, NEW> translateEdgeValues(TranslateFunction<EV, NEW> translator) throws Exception;1484685504;Translate {@link Edge} values using the given {@link MapFunction}.__@param translator implements conversion from {@code EV} to {@code NEW}_@param <NEW> new edge value type_@return graph with translated edge values_@throws Exception;public <NEW> Graph<K, VV, NEW> translateEdgeValues(TranslateFunction<EV, NEW> translator) throws Exception {_		return run(new TranslateEdgeValues<K, VV, EV, NEW>(translator))__	};translate,link,edge,values,using,the,given,link,map,function,param,translator,implements,conversion,from,code,ev,to,code,new,param,new,new,edge,value,type,return,graph,with,translated,edge,values,throws,exception;public,new,graph,k,vv,new,translate,edge,values,translate,function,ev,new,translator,throws,exception,return,run,new,translate,edge,values,k,vv,ev,new,translator
Graph -> public <NEW> Graph<K, VV, NEW> translateEdgeValues(TranslateFunction<EV, NEW> translator) throws Exception;1489068942;Translate {@link Edge} values using the given {@link MapFunction}.__@param translator implements conversion from {@code EV} to {@code NEW}_@param <NEW> new edge value type_@return graph with translated edge values_@throws Exception;public <NEW> Graph<K, VV, NEW> translateEdgeValues(TranslateFunction<EV, NEW> translator) throws Exception {_		return run(new TranslateEdgeValues<K, VV, EV, NEW>(translator))__	};translate,link,edge,values,using,the,given,link,map,function,param,translator,implements,conversion,from,code,ev,to,code,new,param,new,new,edge,value,type,return,graph,with,translated,edge,values,throws,exception;public,new,graph,k,vv,new,translate,edge,values,translate,function,ev,new,translator,throws,exception,return,run,new,translate,edge,values,k,vv,ev,new,translator
Graph -> public <NEW> Graph<K, VV, NEW> translateEdgeValues(TranslateFunction<EV, NEW> translator) throws Exception;1490973446;Translate {@link Edge} values using the given {@link MapFunction}.__@param translator implements conversion from {@code EV} to {@code NEW}_@param <NEW> new edge value type_@return graph with translated edge values_@throws Exception;public <NEW> Graph<K, VV, NEW> translateEdgeValues(TranslateFunction<EV, NEW> translator) throws Exception {_		return run(new TranslateEdgeValues<K, VV, EV, NEW>(translator))__	};translate,link,edge,values,using,the,given,link,map,function,param,translator,implements,conversion,from,code,ev,to,code,new,param,new,new,edge,value,type,return,graph,with,translated,edge,values,throws,exception;public,new,graph,k,vv,new,translate,edge,values,translate,function,ev,new,translator,throws,exception,return,run,new,translate,edge,values,k,vv,ev,new,translator
Graph -> public <NEW> Graph<K, VV, NEW> translateEdgeValues(TranslateFunction<EV, NEW> translator) throws Exception;1495819075;Translate {@link Edge} values using the given {@link MapFunction}.__@param translator implements conversion from {@code EV} to {@code NEW}_@param <NEW> new edge value type_@return graph with translated edge values_@throws Exception;public <NEW> Graph<K, VV, NEW> translateEdgeValues(TranslateFunction<EV, NEW> translator) throws Exception {_		return run(new TranslateEdgeValues<K, VV, EV, NEW>(translator))__	};translate,link,edge,values,using,the,given,link,map,function,param,translator,implements,conversion,from,code,ev,to,code,new,param,new,new,edge,value,type,return,graph,with,translated,edge,values,throws,exception;public,new,graph,k,vv,new,translate,edge,values,translate,function,ev,new,translator,throws,exception,return,run,new,translate,edge,values,k,vv,ev,new,translator
Graph -> public <NEW> Graph<K, VV, NEW> translateEdgeValues(TranslateFunction<EV, NEW> translator) throws Exception;1502111816;Translate {@link Edge} values using the given {@link MapFunction}.__@param translator implements conversion from {@code EV} to {@code NEW}_@param <NEW> new edge value type_@return graph with translated edge values_@throws Exception;public <NEW> Graph<K, VV, NEW> translateEdgeValues(TranslateFunction<EV, NEW> translator) throws Exception {_		return run(new TranslateEdgeValues<>(translator))__	};translate,link,edge,values,using,the,given,link,map,function,param,translator,implements,conversion,from,code,ev,to,code,new,param,new,new,edge,value,type,return,graph,with,translated,edge,values,throws,exception;public,new,graph,k,vv,new,translate,edge,values,translate,function,ev,new,translator,throws,exception,return,run,new,translate,edge,values,translator
Graph -> public <NEW> Graph<NEW, VV, EV> translateGraphIds(TranslateFunction<K, NEW> translator) throws Exception;1462809297;Translate {@link Vertex} and {@link Edge} IDs using the given {@link MapFunction}.__@param translator implements conversion from {@code K} to {@code NEW}_@param <NEW> new ID type_@return graph with translated vertex and edge IDs_@throws Exception;public <NEW> Graph<NEW, VV, EV> translateGraphIds(TranslateFunction<K, NEW> translator) throws Exception {_		return run(new TranslateGraphIds<K, NEW, VV, EV>(translator))__	};translate,link,vertex,and,link,edge,ids,using,the,given,link,map,function,param,translator,implements,conversion,from,code,k,to,code,new,param,new,new,id,type,return,graph,with,translated,vertex,and,edge,ids,throws,exception;public,new,graph,new,vv,ev,translate,graph,ids,translate,function,k,new,translator,throws,exception,return,run,new,translate,graph,ids,k,new,vv,ev,translator
Graph -> public <NEW> Graph<NEW, VV, EV> translateGraphIds(TranslateFunction<K, NEW> translator) throws Exception;1465316775;Translate {@link Vertex} and {@link Edge} IDs using the given {@link MapFunction}.__@param translator implements conversion from {@code K} to {@code NEW}_@param <NEW> new ID type_@return graph with translated vertex and edge IDs_@throws Exception;public <NEW> Graph<NEW, VV, EV> translateGraphIds(TranslateFunction<K, NEW> translator) throws Exception {_		return run(new TranslateGraphIds<K, NEW, VV, EV>(translator))__	};translate,link,vertex,and,link,edge,ids,using,the,given,link,map,function,param,translator,implements,conversion,from,code,k,to,code,new,param,new,new,id,type,return,graph,with,translated,vertex,and,edge,ids,throws,exception;public,new,graph,new,vv,ev,translate,graph,ids,translate,function,k,new,translator,throws,exception,return,run,new,translate,graph,ids,k,new,vv,ev,translator
Graph -> public <NEW> Graph<NEW, VV, EV> translateGraphIds(TranslateFunction<K, NEW> translator) throws Exception;1466789678;Translate {@link Vertex} and {@link Edge} IDs using the given {@link MapFunction}.__@param translator implements conversion from {@code K} to {@code NEW}_@param <NEW> new ID type_@return graph with translated vertex and edge IDs_@throws Exception;public <NEW> Graph<NEW, VV, EV> translateGraphIds(TranslateFunction<K, NEW> translator) throws Exception {_		return run(new TranslateGraphIds<K, NEW, VV, EV>(translator))__	};translate,link,vertex,and,link,edge,ids,using,the,given,link,map,function,param,translator,implements,conversion,from,code,k,to,code,new,param,new,new,id,type,return,graph,with,translated,vertex,and,edge,ids,throws,exception;public,new,graph,new,vv,ev,translate,graph,ids,translate,function,k,new,translator,throws,exception,return,run,new,translate,graph,ids,k,new,vv,ev,translator
Graph -> public <NEW> Graph<NEW, VV, EV> translateGraphIds(TranslateFunction<K, NEW> translator) throws Exception;1467140656;Translate {@link Vertex} and {@link Edge} IDs using the given {@link MapFunction}.__@param translator implements conversion from {@code K} to {@code NEW}_@param <NEW> new ID type_@return graph with translated vertex and edge IDs_@throws Exception;public <NEW> Graph<NEW, VV, EV> translateGraphIds(TranslateFunction<K, NEW> translator) throws Exception {_		return run(new TranslateGraphIds<K, NEW, VV, EV>(translator))__	};translate,link,vertex,and,link,edge,ids,using,the,given,link,map,function,param,translator,implements,conversion,from,code,k,to,code,new,param,new,new,id,type,return,graph,with,translated,vertex,and,edge,ids,throws,exception;public,new,graph,new,vv,ev,translate,graph,ids,translate,function,k,new,translator,throws,exception,return,run,new,translate,graph,ids,k,new,vv,ev,translator
Graph -> public <NEW> Graph<NEW, VV, EV> translateGraphIds(TranslateFunction<K, NEW> translator) throws Exception;1467306272;Translate {@link Vertex} and {@link Edge} IDs using the given {@link MapFunction}.__@param translator implements conversion from {@code K} to {@code NEW}_@param <NEW> new ID type_@return graph with translated vertex and edge IDs_@throws Exception;public <NEW> Graph<NEW, VV, EV> translateGraphIds(TranslateFunction<K, NEW> translator) throws Exception {_		return run(new TranslateGraphIds<K, NEW, VV, EV>(translator))__	};translate,link,vertex,and,link,edge,ids,using,the,given,link,map,function,param,translator,implements,conversion,from,code,k,to,code,new,param,new,new,id,type,return,graph,with,translated,vertex,and,edge,ids,throws,exception;public,new,graph,new,vv,ev,translate,graph,ids,translate,function,k,new,translator,throws,exception,return,run,new,translate,graph,ids,k,new,vv,ev,translator
Graph -> public <NEW> Graph<NEW, VV, EV> translateGraphIds(TranslateFunction<K, NEW> translator) throws Exception;1470042815;Translate {@link Vertex} and {@link Edge} IDs using the given {@link MapFunction}.__@param translator implements conversion from {@code K} to {@code NEW}_@param <NEW> new ID type_@return graph with translated vertex and edge IDs_@throws Exception;public <NEW> Graph<NEW, VV, EV> translateGraphIds(TranslateFunction<K, NEW> translator) throws Exception {_		return run(new TranslateGraphIds<K, NEW, VV, EV>(translator))__	};translate,link,vertex,and,link,edge,ids,using,the,given,link,map,function,param,translator,implements,conversion,from,code,k,to,code,new,param,new,new,id,type,return,graph,with,translated,vertex,and,edge,ids,throws,exception;public,new,graph,new,vv,ev,translate,graph,ids,translate,function,k,new,translator,throws,exception,return,run,new,translate,graph,ids,k,new,vv,ev,translator
Graph -> public <NEW> Graph<NEW, VV, EV> translateGraphIds(TranslateFunction<K, NEW> translator) throws Exception;1475684776;Translate {@link Vertex} and {@link Edge} IDs using the given {@link MapFunction}.__@param translator implements conversion from {@code K} to {@code NEW}_@param <NEW> new ID type_@return graph with translated vertex and edge IDs_@throws Exception;public <NEW> Graph<NEW, VV, EV> translateGraphIds(TranslateFunction<K, NEW> translator) throws Exception {_		return run(new TranslateGraphIds<K, NEW, VV, EV>(translator))__	};translate,link,vertex,and,link,edge,ids,using,the,given,link,map,function,param,translator,implements,conversion,from,code,k,to,code,new,param,new,new,id,type,return,graph,with,translated,vertex,and,edge,ids,throws,exception;public,new,graph,new,vv,ev,translate,graph,ids,translate,function,k,new,translator,throws,exception,return,run,new,translate,graph,ids,k,new,vv,ev,translator
Graph -> public <NEW> Graph<NEW, VV, EV> translateGraphIds(TranslateFunction<K, NEW> translator) throws Exception;1475685606;Translate {@link Vertex} and {@link Edge} IDs using the given {@link MapFunction}.__@param translator implements conversion from {@code K} to {@code NEW}_@param <NEW> new ID type_@return graph with translated vertex and edge IDs_@throws Exception;public <NEW> Graph<NEW, VV, EV> translateGraphIds(TranslateFunction<K, NEW> translator) throws Exception {_		return run(new TranslateGraphIds<K, NEW, VV, EV>(translator))__	};translate,link,vertex,and,link,edge,ids,using,the,given,link,map,function,param,translator,implements,conversion,from,code,k,to,code,new,param,new,new,id,type,return,graph,with,translated,vertex,and,edge,ids,throws,exception;public,new,graph,new,vv,ev,translate,graph,ids,translate,function,k,new,translator,throws,exception,return,run,new,translate,graph,ids,k,new,vv,ev,translator
Graph -> public <NEW> Graph<NEW, VV, EV> translateGraphIds(TranslateFunction<K, NEW> translator) throws Exception;1481745825;Translate {@link Vertex} and {@link Edge} IDs using the given {@link MapFunction}.__@param translator implements conversion from {@code K} to {@code NEW}_@param <NEW> new ID type_@return graph with translated vertex and edge IDs_@throws Exception;public <NEW> Graph<NEW, VV, EV> translateGraphIds(TranslateFunction<K, NEW> translator) throws Exception {_		return run(new TranslateGraphIds<K, NEW, VV, EV>(translator))__	};translate,link,vertex,and,link,edge,ids,using,the,given,link,map,function,param,translator,implements,conversion,from,code,k,to,code,new,param,new,new,id,type,return,graph,with,translated,vertex,and,edge,ids,throws,exception;public,new,graph,new,vv,ev,translate,graph,ids,translate,function,k,new,translator,throws,exception,return,run,new,translate,graph,ids,k,new,vv,ev,translator
Graph -> public <NEW> Graph<NEW, VV, EV> translateGraphIds(TranslateFunction<K, NEW> translator) throws Exception;1481881009;Translate {@link Vertex} and {@link Edge} IDs using the given {@link MapFunction}.__@param translator implements conversion from {@code K} to {@code NEW}_@param <NEW> new ID type_@return graph with translated vertex and edge IDs_@throws Exception;public <NEW> Graph<NEW, VV, EV> translateGraphIds(TranslateFunction<K, NEW> translator) throws Exception {_		return run(new TranslateGraphIds<K, NEW, VV, EV>(translator))__	};translate,link,vertex,and,link,edge,ids,using,the,given,link,map,function,param,translator,implements,conversion,from,code,k,to,code,new,param,new,new,id,type,return,graph,with,translated,vertex,and,edge,ids,throws,exception;public,new,graph,new,vv,ev,translate,graph,ids,translate,function,k,new,translator,throws,exception,return,run,new,translate,graph,ids,k,new,vv,ev,translator
Graph -> public <NEW> Graph<NEW, VV, EV> translateGraphIds(TranslateFunction<K, NEW> translator) throws Exception;1484160227;Translate {@link Vertex} and {@link Edge} IDs using the given {@link MapFunction}.__@param translator implements conversion from {@code K} to {@code NEW}_@param <NEW> new ID type_@return graph with translated vertex and edge IDs_@throws Exception;public <NEW> Graph<NEW, VV, EV> translateGraphIds(TranslateFunction<K, NEW> translator) throws Exception {_		return run(new TranslateGraphIds<K, NEW, VV, EV>(translator))__	};translate,link,vertex,and,link,edge,ids,using,the,given,link,map,function,param,translator,implements,conversion,from,code,k,to,code,new,param,new,new,id,type,return,graph,with,translated,vertex,and,edge,ids,throws,exception;public,new,graph,new,vv,ev,translate,graph,ids,translate,function,k,new,translator,throws,exception,return,run,new,translate,graph,ids,k,new,vv,ev,translator
Graph -> public <NEW> Graph<NEW, VV, EV> translateGraphIds(TranslateFunction<K, NEW> translator) throws Exception;1484685504;Translate {@link Vertex} and {@link Edge} IDs using the given {@link MapFunction}.__@param translator implements conversion from {@code K} to {@code NEW}_@param <NEW> new ID type_@return graph with translated vertex and edge IDs_@throws Exception;public <NEW> Graph<NEW, VV, EV> translateGraphIds(TranslateFunction<K, NEW> translator) throws Exception {_		return run(new TranslateGraphIds<K, NEW, VV, EV>(translator))__	};translate,link,vertex,and,link,edge,ids,using,the,given,link,map,function,param,translator,implements,conversion,from,code,k,to,code,new,param,new,new,id,type,return,graph,with,translated,vertex,and,edge,ids,throws,exception;public,new,graph,new,vv,ev,translate,graph,ids,translate,function,k,new,translator,throws,exception,return,run,new,translate,graph,ids,k,new,vv,ev,translator
Graph -> public <NEW> Graph<NEW, VV, EV> translateGraphIds(TranslateFunction<K, NEW> translator) throws Exception;1489068942;Translate {@link Vertex} and {@link Edge} IDs using the given {@link MapFunction}.__@param translator implements conversion from {@code K} to {@code NEW}_@param <NEW> new ID type_@return graph with translated vertex and edge IDs_@throws Exception;public <NEW> Graph<NEW, VV, EV> translateGraphIds(TranslateFunction<K, NEW> translator) throws Exception {_		return run(new TranslateGraphIds<K, NEW, VV, EV>(translator))__	};translate,link,vertex,and,link,edge,ids,using,the,given,link,map,function,param,translator,implements,conversion,from,code,k,to,code,new,param,new,new,id,type,return,graph,with,translated,vertex,and,edge,ids,throws,exception;public,new,graph,new,vv,ev,translate,graph,ids,translate,function,k,new,translator,throws,exception,return,run,new,translate,graph,ids,k,new,vv,ev,translator
Graph -> public <NEW> Graph<NEW, VV, EV> translateGraphIds(TranslateFunction<K, NEW> translator) throws Exception;1490973446;Translate {@link Vertex} and {@link Edge} IDs using the given {@link MapFunction}.__@param translator implements conversion from {@code K} to {@code NEW}_@param <NEW> new ID type_@return graph with translated vertex and edge IDs_@throws Exception;public <NEW> Graph<NEW, VV, EV> translateGraphIds(TranslateFunction<K, NEW> translator) throws Exception {_		return run(new TranslateGraphIds<K, NEW, VV, EV>(translator))__	};translate,link,vertex,and,link,edge,ids,using,the,given,link,map,function,param,translator,implements,conversion,from,code,k,to,code,new,param,new,new,id,type,return,graph,with,translated,vertex,and,edge,ids,throws,exception;public,new,graph,new,vv,ev,translate,graph,ids,translate,function,k,new,translator,throws,exception,return,run,new,translate,graph,ids,k,new,vv,ev,translator
Graph -> public <NEW> Graph<NEW, VV, EV> translateGraphIds(TranslateFunction<K, NEW> translator) throws Exception;1495819075;Translate {@link Vertex} and {@link Edge} IDs using the given {@link MapFunction}.__@param translator implements conversion from {@code K} to {@code NEW}_@param <NEW> new ID type_@return graph with translated vertex and edge IDs_@throws Exception;public <NEW> Graph<NEW, VV, EV> translateGraphIds(TranslateFunction<K, NEW> translator) throws Exception {_		return run(new TranslateGraphIds<K, NEW, VV, EV>(translator))__	};translate,link,vertex,and,link,edge,ids,using,the,given,link,map,function,param,translator,implements,conversion,from,code,k,to,code,new,param,new,new,id,type,return,graph,with,translated,vertex,and,edge,ids,throws,exception;public,new,graph,new,vv,ev,translate,graph,ids,translate,function,k,new,translator,throws,exception,return,run,new,translate,graph,ids,k,new,vv,ev,translator
Graph -> public <NEW> Graph<NEW, VV, EV> translateGraphIds(TranslateFunction<K, NEW> translator) throws Exception;1502111816;Translate {@link Vertex} and {@link Edge} IDs using the given {@link MapFunction}.__@param translator implements conversion from {@code K} to {@code NEW}_@param <NEW> new ID type_@return graph with translated vertex and edge IDs_@throws Exception;public <NEW> Graph<NEW, VV, EV> translateGraphIds(TranslateFunction<K, NEW> translator) throws Exception {_		return run(new TranslateGraphIds<>(translator))__	};translate,link,vertex,and,link,edge,ids,using,the,given,link,map,function,param,translator,implements,conversion,from,code,k,to,code,new,param,new,new,id,type,return,graph,with,translated,vertex,and,edge,ids,throws,exception;public,new,graph,new,vv,ev,translate,graph,ids,translate,function,k,new,translator,throws,exception,return,run,new,translate,graph,ids,translator
Graph -> public ExecutionEnvironment getContext();1444404795;@return the flink execution environment.;public ExecutionEnvironment getContext() {_		return this.context__	};return,the,flink,execution,environment;public,execution,environment,get,context,return,this,context
Graph -> public ExecutionEnvironment getContext();1445261977;@return the flink execution environment.;public ExecutionEnvironment getContext() {_		return this.context__	};return,the,flink,execution,environment;public,execution,environment,get,context,return,this,context
Graph -> public ExecutionEnvironment getContext();1445854323;@return the flink execution environment.;public ExecutionEnvironment getContext() {_		return this.context__	};return,the,flink,execution,environment;public,execution,environment,get,context,return,this,context
Graph -> public ExecutionEnvironment getContext();1446112342;@return the flink execution environment.;public ExecutionEnvironment getContext() {_		return this.context__	};return,the,flink,execution,environment;public,execution,environment,get,context,return,this,context
Graph -> public ExecutionEnvironment getContext();1447073368;@return the flink execution environment.;public ExecutionEnvironment getContext() {_		return this.context__	};return,the,flink,execution,environment;public,execution,environment,get,context,return,this,context
Graph -> public ExecutionEnvironment getContext();1454404649;@return the flink execution environment.;public ExecutionEnvironment getContext() {_		return this.context__	};return,the,flink,execution,environment;public,execution,environment,get,context,return,this,context
Graph -> public ExecutionEnvironment getContext();1458583829;@return the flink execution environment.;public ExecutionEnvironment getContext() {_		return this.context__	};return,the,flink,execution,environment;public,execution,environment,get,context,return,this,context
Graph -> public ExecutionEnvironment getContext();1458583829;@return the flink execution environment.;public ExecutionEnvironment getContext() {_		return this.context__	};return,the,flink,execution,environment;public,execution,environment,get,context,return,this,context
Graph -> public ExecutionEnvironment getContext();1462100316;@return the flink execution environment.;public ExecutionEnvironment getContext() {_		return this.context__	};return,the,flink,execution,environment;public,execution,environment,get,context,return,this,context
Graph -> public ExecutionEnvironment getContext();1462100316;@return the flink execution environment.;public ExecutionEnvironment getContext() {_		return this.context__	};return,the,flink,execution,environment;public,execution,environment,get,context,return,this,context
Graph -> public ExecutionEnvironment getContext();1462205213;@return the flink execution environment.;public ExecutionEnvironment getContext() {_		return this.context__	};return,the,flink,execution,environment;public,execution,environment,get,context,return,this,context
Graph -> public ExecutionEnvironment getContext();1462208859;@return the flink execution environment.;public ExecutionEnvironment getContext() {_		return this.context__	};return,the,flink,execution,environment;public,execution,environment,get,context,return,this,context
Graph -> public ExecutionEnvironment getContext();1462809297;@return the flink execution environment.;public ExecutionEnvironment getContext() {_		return this.context__	};return,the,flink,execution,environment;public,execution,environment,get,context,return,this,context
Graph -> public ExecutionEnvironment getContext();1465316775;@return the flink execution environment.;public ExecutionEnvironment getContext() {_		return this.context__	};return,the,flink,execution,environment;public,execution,environment,get,context,return,this,context
Graph -> public ExecutionEnvironment getContext();1466789678;@return the flink execution environment.;public ExecutionEnvironment getContext() {_		return this.context__	};return,the,flink,execution,environment;public,execution,environment,get,context,return,this,context
Graph -> public ExecutionEnvironment getContext();1467140656;@return the flink execution environment.;public ExecutionEnvironment getContext() {_		return this.context__	};return,the,flink,execution,environment;public,execution,environment,get,context,return,this,context
Graph -> public ExecutionEnvironment getContext();1467306272;@return the flink execution environment.;public ExecutionEnvironment getContext() {_		return this.context__	};return,the,flink,execution,environment;public,execution,environment,get,context,return,this,context
Graph -> public ExecutionEnvironment getContext();1470042815;@return the flink execution environment.;public ExecutionEnvironment getContext() {_		return this.context__	};return,the,flink,execution,environment;public,execution,environment,get,context,return,this,context
Graph -> public ExecutionEnvironment getContext();1475684776;@return the flink execution environment.;public ExecutionEnvironment getContext() {_		return this.context__	};return,the,flink,execution,environment;public,execution,environment,get,context,return,this,context
Graph -> public ExecutionEnvironment getContext();1475685606;@return the flink execution environment.;public ExecutionEnvironment getContext() {_		return this.context__	};return,the,flink,execution,environment;public,execution,environment,get,context,return,this,context
Graph -> public ExecutionEnvironment getContext();1481745825;@return the flink execution environment.;public ExecutionEnvironment getContext() {_		return this.context__	};return,the,flink,execution,environment;public,execution,environment,get,context,return,this,context
Graph -> public ExecutionEnvironment getContext();1481881009;@return the flink execution environment.;public ExecutionEnvironment getContext() {_		return this.context__	};return,the,flink,execution,environment;public,execution,environment,get,context,return,this,context
Graph -> public ExecutionEnvironment getContext();1484160227;@return the flink execution environment.;public ExecutionEnvironment getContext() {_		return this.context__	};return,the,flink,execution,environment;public,execution,environment,get,context,return,this,context
Graph -> public ExecutionEnvironment getContext();1484685504;@return the flink execution environment.;public ExecutionEnvironment getContext() {_		return this.context__	};return,the,flink,execution,environment;public,execution,environment,get,context,return,this,context
Graph -> public ExecutionEnvironment getContext();1489068942;@return the flink execution environment.;public ExecutionEnvironment getContext() {_		return this.context__	};return,the,flink,execution,environment;public,execution,environment,get,context,return,this,context
Graph -> public ExecutionEnvironment getContext();1490973446;@return the flink execution environment.;public ExecutionEnvironment getContext() {_		return this.context__	};return,the,flink,execution,environment;public,execution,environment,get,context,return,this,context
Graph -> public ExecutionEnvironment getContext();1495819075;@return the flink execution environment.;public ExecutionEnvironment getContext() {_		return this.context__	};return,the,flink,execution,environment;public,execution,environment,get,context,return,this,context
Graph -> public ExecutionEnvironment getContext();1502111816;@return the flink execution environment.;public ExecutionEnvironment getContext() {_		return this.context__	};return,the,flink,execution,environment;public,execution,environment,get,context,return,this,context
Graph -> public long numberOfVertices() throws Exception;1444404795;@return a long integer representing the number of vertices;public long numberOfVertices() throws Exception {_		return vertices.count()__	};return,a,long,integer,representing,the,number,of,vertices;public,long,number,of,vertices,throws,exception,return,vertices,count
Graph -> public long numberOfVertices() throws Exception;1445261977;@return a long integer representing the number of vertices;public long numberOfVertices() throws Exception {_		return vertices.count()__	};return,a,long,integer,representing,the,number,of,vertices;public,long,number,of,vertices,throws,exception,return,vertices,count
Graph -> public long numberOfVertices() throws Exception;1445854323;@return a long integer representing the number of vertices;public long numberOfVertices() throws Exception {_		return vertices.count()__	};return,a,long,integer,representing,the,number,of,vertices;public,long,number,of,vertices,throws,exception,return,vertices,count
Graph -> public long numberOfVertices() throws Exception;1446112342;@return a long integer representing the number of vertices;public long numberOfVertices() throws Exception {_		return vertices.count()__	};return,a,long,integer,representing,the,number,of,vertices;public,long,number,of,vertices,throws,exception,return,vertices,count
Graph -> public long numberOfVertices() throws Exception;1447073368;@return a long integer representing the number of vertices;public long numberOfVertices() throws Exception {_		return vertices.count()__	};return,a,long,integer,representing,the,number,of,vertices;public,long,number,of,vertices,throws,exception,return,vertices,count
Graph -> public long numberOfVertices() throws Exception;1454404649;@return a long integer representing the number of vertices;public long numberOfVertices() throws Exception {_		return vertices.count()__	};return,a,long,integer,representing,the,number,of,vertices;public,long,number,of,vertices,throws,exception,return,vertices,count
Graph -> public long numberOfVertices() throws Exception;1458583829;@return a long integer representing the number of vertices;public long numberOfVertices() throws Exception {_		return vertices.count()__	};return,a,long,integer,representing,the,number,of,vertices;public,long,number,of,vertices,throws,exception,return,vertices,count
Graph -> public long numberOfVertices() throws Exception;1458583829;@return a long integer representing the number of vertices;public long numberOfVertices() throws Exception {_		return vertices.count()__	};return,a,long,integer,representing,the,number,of,vertices;public,long,number,of,vertices,throws,exception,return,vertices,count
Graph -> public long numberOfVertices() throws Exception;1462100316;@return a long integer representing the number of vertices;public long numberOfVertices() throws Exception {_		return vertices.count()__	};return,a,long,integer,representing,the,number,of,vertices;public,long,number,of,vertices,throws,exception,return,vertices,count
Graph -> public long numberOfVertices() throws Exception;1462100316;@return a long integer representing the number of vertices;public long numberOfVertices() throws Exception {_		return vertices.count()__	};return,a,long,integer,representing,the,number,of,vertices;public,long,number,of,vertices,throws,exception,return,vertices,count
Graph -> public long numberOfVertices() throws Exception;1462205213;@return a long integer representing the number of vertices;public long numberOfVertices() throws Exception {_		return vertices.count()__	};return,a,long,integer,representing,the,number,of,vertices;public,long,number,of,vertices,throws,exception,return,vertices,count
Graph -> public long numberOfVertices() throws Exception;1462208859;@return a long integer representing the number of vertices;public long numberOfVertices() throws Exception {_		return vertices.count()__	};return,a,long,integer,representing,the,number,of,vertices;public,long,number,of,vertices,throws,exception,return,vertices,count
Graph -> public long numberOfVertices() throws Exception;1462809297;@return a long integer representing the number of vertices;public long numberOfVertices() throws Exception {_		return vertices.count()__	};return,a,long,integer,representing,the,number,of,vertices;public,long,number,of,vertices,throws,exception,return,vertices,count
Graph -> public long numberOfVertices() throws Exception;1465316775;@return a long integer representing the number of vertices;public long numberOfVertices() throws Exception {_		return vertices.count()__	};return,a,long,integer,representing,the,number,of,vertices;public,long,number,of,vertices,throws,exception,return,vertices,count
Graph -> public long numberOfVertices() throws Exception;1466789678;@return a long integer representing the number of vertices;public long numberOfVertices() throws Exception {_		return vertices.count()__	};return,a,long,integer,representing,the,number,of,vertices;public,long,number,of,vertices,throws,exception,return,vertices,count
Graph -> public long numberOfVertices() throws Exception;1467140656;@return a long integer representing the number of vertices;public long numberOfVertices() throws Exception {_		return vertices.count()__	};return,a,long,integer,representing,the,number,of,vertices;public,long,number,of,vertices,throws,exception,return,vertices,count
Graph -> public long numberOfVertices() throws Exception;1467306272;@return a long integer representing the number of vertices;public long numberOfVertices() throws Exception {_		return vertices.count()__	};return,a,long,integer,representing,the,number,of,vertices;public,long,number,of,vertices,throws,exception,return,vertices,count
Graph -> public long numberOfVertices() throws Exception;1470042815;@return a long integer representing the number of vertices;public long numberOfVertices() throws Exception {_		return vertices.count()__	};return,a,long,integer,representing,the,number,of,vertices;public,long,number,of,vertices,throws,exception,return,vertices,count
Graph -> public long numberOfVertices() throws Exception;1475684776;@return a long integer representing the number of vertices;public long numberOfVertices() throws Exception {_		return vertices.count()__	};return,a,long,integer,representing,the,number,of,vertices;public,long,number,of,vertices,throws,exception,return,vertices,count
Graph -> public long numberOfVertices() throws Exception;1475685606;@return a long integer representing the number of vertices;public long numberOfVertices() throws Exception {_		return vertices.count()__	};return,a,long,integer,representing,the,number,of,vertices;public,long,number,of,vertices,throws,exception,return,vertices,count
Graph -> public long numberOfVertices() throws Exception;1481745825;@return a long integer representing the number of vertices;public long numberOfVertices() throws Exception {_		return vertices.count()__	};return,a,long,integer,representing,the,number,of,vertices;public,long,number,of,vertices,throws,exception,return,vertices,count
Graph -> public long numberOfVertices() throws Exception;1481881009;@return a long integer representing the number of vertices;public long numberOfVertices() throws Exception {_		return vertices.count()__	};return,a,long,integer,representing,the,number,of,vertices;public,long,number,of,vertices,throws,exception,return,vertices,count
Graph -> public long numberOfVertices() throws Exception;1484160227;@return a long integer representing the number of vertices;public long numberOfVertices() throws Exception {_		return vertices.count()__	};return,a,long,integer,representing,the,number,of,vertices;public,long,number,of,vertices,throws,exception,return,vertices,count
Graph -> public long numberOfVertices() throws Exception;1484685504;@return a long integer representing the number of vertices;public long numberOfVertices() throws Exception {_		return vertices.count()__	};return,a,long,integer,representing,the,number,of,vertices;public,long,number,of,vertices,throws,exception,return,vertices,count
Graph -> public long numberOfVertices() throws Exception;1489068942;@return a long integer representing the number of vertices;public long numberOfVertices() throws Exception {_		return vertices.count()__	};return,a,long,integer,representing,the,number,of,vertices;public,long,number,of,vertices,throws,exception,return,vertices,count
Graph -> public long numberOfVertices() throws Exception;1490973446;@return a long integer representing the number of vertices;public long numberOfVertices() throws Exception {_		return vertices.count()__	};return,a,long,integer,representing,the,number,of,vertices;public,long,number,of,vertices,throws,exception,return,vertices,count
Graph -> public long numberOfVertices() throws Exception;1495819075;@return a long integer representing the number of vertices;public long numberOfVertices() throws Exception {_		return vertices.count()__	};return,a,long,integer,representing,the,number,of,vertices;public,long,number,of,vertices,throws,exception,return,vertices,count
Graph -> public long numberOfVertices() throws Exception;1502111816;@return a long integer representing the number of vertices;public long numberOfVertices() throws Exception {_		return vertices.count()__	};return,a,long,integer,representing,the,number,of,vertices;public,long,number,of,vertices,throws,exception,return,vertices,count
Graph -> private DataSet<Edge<K, EV>> getDistinctEdgeIntersection(DataSet<Edge<K, EV>> edges);1447073368;Computes the intersection between the edge set and the given edge set. For all matching pairs,_only one edge will be in the resulting data set.__@param edges edges to compute intersection with_@return edge set containing one edge for all matching pairs of the same edge;private DataSet<Edge<K, EV>> getDistinctEdgeIntersection(DataSet<Edge<K, EV>> edges) {_		return this.getEdges()_				.join(edges)_				.where(0, 1, 2)_				.equalTo(0, 1, 2)_				.with(new JoinFunction<Edge<K, EV>, Edge<K, EV>, Edge<K, EV>>() {_					@Override_					public Edge<K, EV> join(Edge<K, EV> first, Edge<K, EV> second) throws Exception {_						return first__					}_				}).withForwardedFieldsFirst("*")_				.distinct()__	};computes,the,intersection,between,the,edge,set,and,the,given,edge,set,for,all,matching,pairs,only,one,edge,will,be,in,the,resulting,data,set,param,edges,edges,to,compute,intersection,with,return,edge,set,containing,one,edge,for,all,matching,pairs,of,the,same,edge;private,data,set,edge,k,ev,get,distinct,edge,intersection,data,set,edge,k,ev,edges,return,this,get,edges,join,edges,where,0,1,2,equal,to,0,1,2,with,new,join,function,edge,k,ev,edge,k,ev,edge,k,ev,override,public,edge,k,ev,join,edge,k,ev,first,edge,k,ev,second,throws,exception,return,first,with,forwarded,fields,first,distinct
Graph -> private DataSet<Edge<K, EV>> getDistinctEdgeIntersection(DataSet<Edge<K, EV>> edges);1454404649;Computes the intersection between the edge set and the given edge set. For all matching pairs,_only one edge will be in the resulting data set.__@param edges edges to compute intersection with_@return edge set containing one edge for all matching pairs of the same edge;private DataSet<Edge<K, EV>> getDistinctEdgeIntersection(DataSet<Edge<K, EV>> edges) {_		return this.getEdges()_				.join(edges)_				.where(0, 1, 2)_				.equalTo(0, 1, 2)_				.with(new JoinFunction<Edge<K, EV>, Edge<K, EV>, Edge<K, EV>>() {_					@Override_					public Edge<K, EV> join(Edge<K, EV> first, Edge<K, EV> second) throws Exception {_						return first__					}_				}).withForwardedFieldsFirst("*")_				.distinct()__	};computes,the,intersection,between,the,edge,set,and,the,given,edge,set,for,all,matching,pairs,only,one,edge,will,be,in,the,resulting,data,set,param,edges,edges,to,compute,intersection,with,return,edge,set,containing,one,edge,for,all,matching,pairs,of,the,same,edge;private,data,set,edge,k,ev,get,distinct,edge,intersection,data,set,edge,k,ev,edges,return,this,get,edges,join,edges,where,0,1,2,equal,to,0,1,2,with,new,join,function,edge,k,ev,edge,k,ev,edge,k,ev,override,public,edge,k,ev,join,edge,k,ev,first,edge,k,ev,second,throws,exception,return,first,with,forwarded,fields,first,distinct
Graph -> private DataSet<Edge<K, EV>> getDistinctEdgeIntersection(DataSet<Edge<K, EV>> edges);1458583829;Computes the intersection between the edge set and the given edge set. For all matching pairs,_only one edge will be in the resulting data set.__@param edges edges to compute intersection with_@return edge set containing one edge for all matching pairs of the same edge;private DataSet<Edge<K, EV>> getDistinctEdgeIntersection(DataSet<Edge<K, EV>> edges) {_		return this.getEdges()_				.join(edges)_				.where(0, 1, 2)_				.equalTo(0, 1, 2)_				.with(new JoinFunction<Edge<K, EV>, Edge<K, EV>, Edge<K, EV>>() {_					@Override_					public Edge<K, EV> join(Edge<K, EV> first, Edge<K, EV> second) throws Exception {_						return first__					}_				}).withForwardedFieldsFirst("*")_				.distinct()__	};computes,the,intersection,between,the,edge,set,and,the,given,edge,set,for,all,matching,pairs,only,one,edge,will,be,in,the,resulting,data,set,param,edges,edges,to,compute,intersection,with,return,edge,set,containing,one,edge,for,all,matching,pairs,of,the,same,edge;private,data,set,edge,k,ev,get,distinct,edge,intersection,data,set,edge,k,ev,edges,return,this,get,edges,join,edges,where,0,1,2,equal,to,0,1,2,with,new,join,function,edge,k,ev,edge,k,ev,edge,k,ev,override,public,edge,k,ev,join,edge,k,ev,first,edge,k,ev,second,throws,exception,return,first,with,forwarded,fields,first,distinct
Graph -> private DataSet<Edge<K, EV>> getDistinctEdgeIntersection(DataSet<Edge<K, EV>> edges);1458583829;Computes the intersection between the edge set and the given edge set. For all matching pairs,_only one edge will be in the resulting data set.__@param edges edges to compute intersection with_@return edge set containing one edge for all matching pairs of the same edge;private DataSet<Edge<K, EV>> getDistinctEdgeIntersection(DataSet<Edge<K, EV>> edges) {_		return this.getEdges()_				.join(edges)_				.where(0, 1, 2)_				.equalTo(0, 1, 2)_				.with(new JoinFunction<Edge<K, EV>, Edge<K, EV>, Edge<K, EV>>() {_					@Override_					public Edge<K, EV> join(Edge<K, EV> first, Edge<K, EV> second) throws Exception {_						return first__					}_				}).withForwardedFieldsFirst("*")_				.distinct()__	};computes,the,intersection,between,the,edge,set,and,the,given,edge,set,for,all,matching,pairs,only,one,edge,will,be,in,the,resulting,data,set,param,edges,edges,to,compute,intersection,with,return,edge,set,containing,one,edge,for,all,matching,pairs,of,the,same,edge;private,data,set,edge,k,ev,get,distinct,edge,intersection,data,set,edge,k,ev,edges,return,this,get,edges,join,edges,where,0,1,2,equal,to,0,1,2,with,new,join,function,edge,k,ev,edge,k,ev,edge,k,ev,override,public,edge,k,ev,join,edge,k,ev,first,edge,k,ev,second,throws,exception,return,first,with,forwarded,fields,first,distinct
Graph -> private DataSet<Edge<K, EV>> getDistinctEdgeIntersection(DataSet<Edge<K, EV>> edges);1462100316;Computes the intersection between the edge set and the given edge set. For all matching pairs,_only one edge will be in the resulting data set.__@param edges edges to compute intersection with_@return edge set containing one edge for all matching pairs of the same edge;private DataSet<Edge<K, EV>> getDistinctEdgeIntersection(DataSet<Edge<K, EV>> edges) {_		return this.getEdges()_				.join(edges)_				.where(0, 1, 2)_				.equalTo(0, 1, 2)_				.with(new JoinFunction<Edge<K, EV>, Edge<K, EV>, Edge<K, EV>>() {_					@Override_					public Edge<K, EV> join(Edge<K, EV> first, Edge<K, EV> second) throws Exception {_						return first__					}_				}).withForwardedFieldsFirst("*")_				.distinct()__	};computes,the,intersection,between,the,edge,set,and,the,given,edge,set,for,all,matching,pairs,only,one,edge,will,be,in,the,resulting,data,set,param,edges,edges,to,compute,intersection,with,return,edge,set,containing,one,edge,for,all,matching,pairs,of,the,same,edge;private,data,set,edge,k,ev,get,distinct,edge,intersection,data,set,edge,k,ev,edges,return,this,get,edges,join,edges,where,0,1,2,equal,to,0,1,2,with,new,join,function,edge,k,ev,edge,k,ev,edge,k,ev,override,public,edge,k,ev,join,edge,k,ev,first,edge,k,ev,second,throws,exception,return,first,with,forwarded,fields,first,distinct
Graph -> private DataSet<Edge<K, EV>> getDistinctEdgeIntersection(DataSet<Edge<K, EV>> edges);1462100316;Computes the intersection between the edge set and the given edge set. For all matching pairs,_only one edge will be in the resulting data set.__@param edges edges to compute intersection with_@return edge set containing one edge for all matching pairs of the same edge;private DataSet<Edge<K, EV>> getDistinctEdgeIntersection(DataSet<Edge<K, EV>> edges) {_		return this.getEdges()_				.join(edges)_				.where(0, 1, 2)_				.equalTo(0, 1, 2)_				.with(new JoinFunction<Edge<K, EV>, Edge<K, EV>, Edge<K, EV>>() {_					@Override_					public Edge<K, EV> join(Edge<K, EV> first, Edge<K, EV> second) throws Exception {_						return first__					}_				}).withForwardedFieldsFirst("*")_				.distinct()__	};computes,the,intersection,between,the,edge,set,and,the,given,edge,set,for,all,matching,pairs,only,one,edge,will,be,in,the,resulting,data,set,param,edges,edges,to,compute,intersection,with,return,edge,set,containing,one,edge,for,all,matching,pairs,of,the,same,edge;private,data,set,edge,k,ev,get,distinct,edge,intersection,data,set,edge,k,ev,edges,return,this,get,edges,join,edges,where,0,1,2,equal,to,0,1,2,with,new,join,function,edge,k,ev,edge,k,ev,edge,k,ev,override,public,edge,k,ev,join,edge,k,ev,first,edge,k,ev,second,throws,exception,return,first,with,forwarded,fields,first,distinct
Graph -> private DataSet<Edge<K, EV>> getDistinctEdgeIntersection(DataSet<Edge<K, EV>> edges);1462205213;Computes the intersection between the edge set and the given edge set. For all matching pairs,_only one edge will be in the resulting data set.__@param edges edges to compute intersection with_@return edge set containing one edge for all matching pairs of the same edge;private DataSet<Edge<K, EV>> getDistinctEdgeIntersection(DataSet<Edge<K, EV>> edges) {_		return this.getEdges()_				.join(edges)_				.where(0, 1, 2)_				.equalTo(0, 1, 2)_				.with(new JoinFunction<Edge<K, EV>, Edge<K, EV>, Edge<K, EV>>() {_					@Override_					public Edge<K, EV> join(Edge<K, EV> first, Edge<K, EV> second) throws Exception {_						return first__					}_				}).withForwardedFieldsFirst("*")_				.distinct()__	};computes,the,intersection,between,the,edge,set,and,the,given,edge,set,for,all,matching,pairs,only,one,edge,will,be,in,the,resulting,data,set,param,edges,edges,to,compute,intersection,with,return,edge,set,containing,one,edge,for,all,matching,pairs,of,the,same,edge;private,data,set,edge,k,ev,get,distinct,edge,intersection,data,set,edge,k,ev,edges,return,this,get,edges,join,edges,where,0,1,2,equal,to,0,1,2,with,new,join,function,edge,k,ev,edge,k,ev,edge,k,ev,override,public,edge,k,ev,join,edge,k,ev,first,edge,k,ev,second,throws,exception,return,first,with,forwarded,fields,first,distinct
Graph -> private DataSet<Edge<K, EV>> getDistinctEdgeIntersection(DataSet<Edge<K, EV>> edges);1462208859;Computes the intersection between the edge set and the given edge set. For all matching pairs,_only one edge will be in the resulting data set.__@param edges edges to compute intersection with_@return edge set containing one edge for all matching pairs of the same edge;private DataSet<Edge<K, EV>> getDistinctEdgeIntersection(DataSet<Edge<K, EV>> edges) {_		return this.getEdges()_				.join(edges)_				.where(0, 1, 2)_				.equalTo(0, 1, 2)_				.with(new JoinFunction<Edge<K, EV>, Edge<K, EV>, Edge<K, EV>>() {_					@Override_					public Edge<K, EV> join(Edge<K, EV> first, Edge<K, EV> second) throws Exception {_						return first__					}_				}).withForwardedFieldsFirst("*")_				.distinct()__	};computes,the,intersection,between,the,edge,set,and,the,given,edge,set,for,all,matching,pairs,only,one,edge,will,be,in,the,resulting,data,set,param,edges,edges,to,compute,intersection,with,return,edge,set,containing,one,edge,for,all,matching,pairs,of,the,same,edge;private,data,set,edge,k,ev,get,distinct,edge,intersection,data,set,edge,k,ev,edges,return,this,get,edges,join,edges,where,0,1,2,equal,to,0,1,2,with,new,join,function,edge,k,ev,edge,k,ev,edge,k,ev,override,public,edge,k,ev,join,edge,k,ev,first,edge,k,ev,second,throws,exception,return,first,with,forwarded,fields,first,distinct
Graph -> private DataSet<Edge<K, EV>> getDistinctEdgeIntersection(DataSet<Edge<K, EV>> edges);1462809297;Computes the intersection between the edge set and the given edge set. For all matching pairs,_only one edge will be in the resulting data set.__@param edges edges to compute intersection with_@return edge set containing one edge for all matching pairs of the same edge;private DataSet<Edge<K, EV>> getDistinctEdgeIntersection(DataSet<Edge<K, EV>> edges) {_		return this.getEdges()_				.join(edges)_				.where(0, 1, 2)_				.equalTo(0, 1, 2)_				.with(new JoinFunction<Edge<K, EV>, Edge<K, EV>, Edge<K, EV>>() {_					@Override_					public Edge<K, EV> join(Edge<K, EV> first, Edge<K, EV> second) throws Exception {_						return first__					}_				}).withForwardedFieldsFirst("*")_				.distinct()__	};computes,the,intersection,between,the,edge,set,and,the,given,edge,set,for,all,matching,pairs,only,one,edge,will,be,in,the,resulting,data,set,param,edges,edges,to,compute,intersection,with,return,edge,set,containing,one,edge,for,all,matching,pairs,of,the,same,edge;private,data,set,edge,k,ev,get,distinct,edge,intersection,data,set,edge,k,ev,edges,return,this,get,edges,join,edges,where,0,1,2,equal,to,0,1,2,with,new,join,function,edge,k,ev,edge,k,ev,edge,k,ev,override,public,edge,k,ev,join,edge,k,ev,first,edge,k,ev,second,throws,exception,return,first,with,forwarded,fields,first,distinct
Graph -> private DataSet<Edge<K, EV>> getDistinctEdgeIntersection(DataSet<Edge<K, EV>> edges);1465316775;Computes the intersection between the edge set and the given edge set. For all matching pairs,_only one edge will be in the resulting data set.__@param edges edges to compute intersection with_@return edge set containing one edge for all matching pairs of the same edge;private DataSet<Edge<K, EV>> getDistinctEdgeIntersection(DataSet<Edge<K, EV>> edges) {_		return this.getEdges()_				.join(edges)_				.where(0, 1, 2)_				.equalTo(0, 1, 2)_				.with(new JoinFunction<Edge<K, EV>, Edge<K, EV>, Edge<K, EV>>() {_					@Override_					public Edge<K, EV> join(Edge<K, EV> first, Edge<K, EV> second) throws Exception {_						return first__					}_				}).withForwardedFieldsFirst("*")_				.distinct()__	};computes,the,intersection,between,the,edge,set,and,the,given,edge,set,for,all,matching,pairs,only,one,edge,will,be,in,the,resulting,data,set,param,edges,edges,to,compute,intersection,with,return,edge,set,containing,one,edge,for,all,matching,pairs,of,the,same,edge;private,data,set,edge,k,ev,get,distinct,edge,intersection,data,set,edge,k,ev,edges,return,this,get,edges,join,edges,where,0,1,2,equal,to,0,1,2,with,new,join,function,edge,k,ev,edge,k,ev,edge,k,ev,override,public,edge,k,ev,join,edge,k,ev,first,edge,k,ev,second,throws,exception,return,first,with,forwarded,fields,first,distinct
Graph -> private DataSet<Edge<K, EV>> getDistinctEdgeIntersection(DataSet<Edge<K, EV>> edges);1466789678;Computes the intersection between the edge set and the given edge set. For all matching pairs,_only one edge will be in the resulting data set.__@param edges edges to compute intersection with_@return edge set containing one edge for all matching pairs of the same edge;private DataSet<Edge<K, EV>> getDistinctEdgeIntersection(DataSet<Edge<K, EV>> edges) {_		return this.getEdges()_				.join(edges)_				.where(0, 1, 2)_				.equalTo(0, 1, 2)_				.with(new JoinFunction<Edge<K, EV>, Edge<K, EV>, Edge<K, EV>>() {_					@Override_					public Edge<K, EV> join(Edge<K, EV> first, Edge<K, EV> second) throws Exception {_						return first__					}_				}).withForwardedFieldsFirst("*")_				.distinct()__	};computes,the,intersection,between,the,edge,set,and,the,given,edge,set,for,all,matching,pairs,only,one,edge,will,be,in,the,resulting,data,set,param,edges,edges,to,compute,intersection,with,return,edge,set,containing,one,edge,for,all,matching,pairs,of,the,same,edge;private,data,set,edge,k,ev,get,distinct,edge,intersection,data,set,edge,k,ev,edges,return,this,get,edges,join,edges,where,0,1,2,equal,to,0,1,2,with,new,join,function,edge,k,ev,edge,k,ev,edge,k,ev,override,public,edge,k,ev,join,edge,k,ev,first,edge,k,ev,second,throws,exception,return,first,with,forwarded,fields,first,distinct
Graph -> private DataSet<Edge<K, EV>> getDistinctEdgeIntersection(DataSet<Edge<K, EV>> edges);1467140656;Computes the intersection between the edge set and the given edge set. For all matching pairs,_only one edge will be in the resulting data set.__@param edges edges to compute intersection with_@return edge set containing one edge for all matching pairs of the same edge;private DataSet<Edge<K, EV>> getDistinctEdgeIntersection(DataSet<Edge<K, EV>> edges) {_		return this.getEdges()_				.join(edges)_				.where(0, 1, 2)_				.equalTo(0, 1, 2)_				.with(new JoinFunction<Edge<K, EV>, Edge<K, EV>, Edge<K, EV>>() {_					@Override_					public Edge<K, EV> join(Edge<K, EV> first, Edge<K, EV> second) throws Exception {_						return first__					}_				}).withForwardedFieldsFirst("*")_				.distinct()__	};computes,the,intersection,between,the,edge,set,and,the,given,edge,set,for,all,matching,pairs,only,one,edge,will,be,in,the,resulting,data,set,param,edges,edges,to,compute,intersection,with,return,edge,set,containing,one,edge,for,all,matching,pairs,of,the,same,edge;private,data,set,edge,k,ev,get,distinct,edge,intersection,data,set,edge,k,ev,edges,return,this,get,edges,join,edges,where,0,1,2,equal,to,0,1,2,with,new,join,function,edge,k,ev,edge,k,ev,edge,k,ev,override,public,edge,k,ev,join,edge,k,ev,first,edge,k,ev,second,throws,exception,return,first,with,forwarded,fields,first,distinct
Graph -> private DataSet<Edge<K, EV>> getDistinctEdgeIntersection(DataSet<Edge<K, EV>> edges);1467306272;Computes the intersection between the edge set and the given edge set. For all matching pairs,_only one edge will be in the resulting data set.__@param edges edges to compute intersection with_@return edge set containing one edge for all matching pairs of the same edge;private DataSet<Edge<K, EV>> getDistinctEdgeIntersection(DataSet<Edge<K, EV>> edges) {_		return this.getEdges()_				.join(edges)_				.where(0, 1, 2)_				.equalTo(0, 1, 2)_				.with(new JoinFunction<Edge<K, EV>, Edge<K, EV>, Edge<K, EV>>() {_					@Override_					public Edge<K, EV> join(Edge<K, EV> first, Edge<K, EV> second) throws Exception {_						return first__					}_				}).withForwardedFieldsFirst("*")_				.distinct()__	};computes,the,intersection,between,the,edge,set,and,the,given,edge,set,for,all,matching,pairs,only,one,edge,will,be,in,the,resulting,data,set,param,edges,edges,to,compute,intersection,with,return,edge,set,containing,one,edge,for,all,matching,pairs,of,the,same,edge;private,data,set,edge,k,ev,get,distinct,edge,intersection,data,set,edge,k,ev,edges,return,this,get,edges,join,edges,where,0,1,2,equal,to,0,1,2,with,new,join,function,edge,k,ev,edge,k,ev,edge,k,ev,override,public,edge,k,ev,join,edge,k,ev,first,edge,k,ev,second,throws,exception,return,first,with,forwarded,fields,first,distinct
Graph -> private DataSet<Edge<K, EV>> getDistinctEdgeIntersection(DataSet<Edge<K, EV>> edges);1470042815;Computes the intersection between the edge set and the given edge set. For all matching pairs,_only one edge will be in the resulting data set.__@param edges edges to compute intersection with_@return edge set containing one edge for all matching pairs of the same edge;private DataSet<Edge<K, EV>> getDistinctEdgeIntersection(DataSet<Edge<K, EV>> edges) {_		return this.getEdges()_				.join(edges)_				.where(0, 1, 2)_				.equalTo(0, 1, 2)_				.with(new JoinFunction<Edge<K, EV>, Edge<K, EV>, Edge<K, EV>>() {_					@Override_					public Edge<K, EV> join(Edge<K, EV> first, Edge<K, EV> second) throws Exception {_						return first__					}_				}).withForwardedFieldsFirst("*")_				.distinct()__	};computes,the,intersection,between,the,edge,set,and,the,given,edge,set,for,all,matching,pairs,only,one,edge,will,be,in,the,resulting,data,set,param,edges,edges,to,compute,intersection,with,return,edge,set,containing,one,edge,for,all,matching,pairs,of,the,same,edge;private,data,set,edge,k,ev,get,distinct,edge,intersection,data,set,edge,k,ev,edges,return,this,get,edges,join,edges,where,0,1,2,equal,to,0,1,2,with,new,join,function,edge,k,ev,edge,k,ev,edge,k,ev,override,public,edge,k,ev,join,edge,k,ev,first,edge,k,ev,second,throws,exception,return,first,with,forwarded,fields,first,distinct
Graph -> private DataSet<Edge<K, EV>> getDistinctEdgeIntersection(DataSet<Edge<K, EV>> edges);1475684776;Computes the intersection between the edge set and the given edge set. For all matching pairs,_only one edge will be in the resulting data set.__@param edges edges to compute intersection with_@return edge set containing one edge for all matching pairs of the same edge;private DataSet<Edge<K, EV>> getDistinctEdgeIntersection(DataSet<Edge<K, EV>> edges) {_		return this.getEdges()_				.join(edges)_				.where(0, 1, 2)_				.equalTo(0, 1, 2)_				.with(new JoinFunction<Edge<K, EV>, Edge<K, EV>, Edge<K, EV>>() {_					@Override_					public Edge<K, EV> join(Edge<K, EV> first, Edge<K, EV> second) throws Exception {_						return first__					}_				}).withForwardedFieldsFirst("*")_				.distinct()__	};computes,the,intersection,between,the,edge,set,and,the,given,edge,set,for,all,matching,pairs,only,one,edge,will,be,in,the,resulting,data,set,param,edges,edges,to,compute,intersection,with,return,edge,set,containing,one,edge,for,all,matching,pairs,of,the,same,edge;private,data,set,edge,k,ev,get,distinct,edge,intersection,data,set,edge,k,ev,edges,return,this,get,edges,join,edges,where,0,1,2,equal,to,0,1,2,with,new,join,function,edge,k,ev,edge,k,ev,edge,k,ev,override,public,edge,k,ev,join,edge,k,ev,first,edge,k,ev,second,throws,exception,return,first,with,forwarded,fields,first,distinct
Graph -> private DataSet<Edge<K, EV>> getDistinctEdgeIntersection(DataSet<Edge<K, EV>> edges);1475685606;Computes the intersection between the edge set and the given edge set. For all matching pairs,_only one edge will be in the resulting data set.__@param edges edges to compute intersection with_@return edge set containing one edge for all matching pairs of the same edge;private DataSet<Edge<K, EV>> getDistinctEdgeIntersection(DataSet<Edge<K, EV>> edges) {_		return this.getEdges()_				.join(edges)_				.where(0, 1, 2)_				.equalTo(0, 1, 2)_				.with(new JoinFunction<Edge<K, EV>, Edge<K, EV>, Edge<K, EV>>() {_					@Override_					public Edge<K, EV> join(Edge<K, EV> first, Edge<K, EV> second) throws Exception {_						return first__					}_				}).withForwardedFieldsFirst("*")_				.distinct()__	};computes,the,intersection,between,the,edge,set,and,the,given,edge,set,for,all,matching,pairs,only,one,edge,will,be,in,the,resulting,data,set,param,edges,edges,to,compute,intersection,with,return,edge,set,containing,one,edge,for,all,matching,pairs,of,the,same,edge;private,data,set,edge,k,ev,get,distinct,edge,intersection,data,set,edge,k,ev,edges,return,this,get,edges,join,edges,where,0,1,2,equal,to,0,1,2,with,new,join,function,edge,k,ev,edge,k,ev,edge,k,ev,override,public,edge,k,ev,join,edge,k,ev,first,edge,k,ev,second,throws,exception,return,first,with,forwarded,fields,first,distinct
Graph -> private DataSet<Edge<K, EV>> getDistinctEdgeIntersection(DataSet<Edge<K, EV>> edges);1481745825;Computes the intersection between the edge set and the given edge set. For all matching pairs,_only one edge will be in the resulting data set.__@param edges edges to compute intersection with_@return edge set containing one edge for all matching pairs of the same edge;private DataSet<Edge<K, EV>> getDistinctEdgeIntersection(DataSet<Edge<K, EV>> edges) {_		return this.getEdges()_				.join(edges)_				.where(0, 1, 2)_				.equalTo(0, 1, 2)_				.with(new JoinFunction<Edge<K, EV>, Edge<K, EV>, Edge<K, EV>>() {_					@Override_					public Edge<K, EV> join(Edge<K, EV> first, Edge<K, EV> second) throws Exception {_						return first__					}_				}).withForwardedFieldsFirst("*").name("Intersect edges")_				.distinct()_					.name("Edges")__	};computes,the,intersection,between,the,edge,set,and,the,given,edge,set,for,all,matching,pairs,only,one,edge,will,be,in,the,resulting,data,set,param,edges,edges,to,compute,intersection,with,return,edge,set,containing,one,edge,for,all,matching,pairs,of,the,same,edge;private,data,set,edge,k,ev,get,distinct,edge,intersection,data,set,edge,k,ev,edges,return,this,get,edges,join,edges,where,0,1,2,equal,to,0,1,2,with,new,join,function,edge,k,ev,edge,k,ev,edge,k,ev,override,public,edge,k,ev,join,edge,k,ev,first,edge,k,ev,second,throws,exception,return,first,with,forwarded,fields,first,name,intersect,edges,distinct,name,edges
Graph -> private DataSet<Edge<K, EV>> getDistinctEdgeIntersection(DataSet<Edge<K, EV>> edges);1481881009;Computes the intersection between the edge set and the given edge set. For all matching pairs,_only one edge will be in the resulting data set.__@param edges edges to compute intersection with_@return edge set containing one edge for all matching pairs of the same edge;private DataSet<Edge<K, EV>> getDistinctEdgeIntersection(DataSet<Edge<K, EV>> edges) {_		return this.getEdges()_				.join(edges)_				.where(0, 1, 2)_				.equalTo(0, 1, 2)_				.with(new JoinFunction<Edge<K, EV>, Edge<K, EV>, Edge<K, EV>>() {_					@Override_					public Edge<K, EV> join(Edge<K, EV> first, Edge<K, EV> second) throws Exception {_						return first__					}_				}).withForwardedFieldsFirst("*").name("Intersect edges")_				.distinct()_					.name("Edges")__	};computes,the,intersection,between,the,edge,set,and,the,given,edge,set,for,all,matching,pairs,only,one,edge,will,be,in,the,resulting,data,set,param,edges,edges,to,compute,intersection,with,return,edge,set,containing,one,edge,for,all,matching,pairs,of,the,same,edge;private,data,set,edge,k,ev,get,distinct,edge,intersection,data,set,edge,k,ev,edges,return,this,get,edges,join,edges,where,0,1,2,equal,to,0,1,2,with,new,join,function,edge,k,ev,edge,k,ev,edge,k,ev,override,public,edge,k,ev,join,edge,k,ev,first,edge,k,ev,second,throws,exception,return,first,with,forwarded,fields,first,name,intersect,edges,distinct,name,edges
Graph -> private DataSet<Edge<K, EV>> getDistinctEdgeIntersection(DataSet<Edge<K, EV>> edges);1484160227;Computes the intersection between the edge set and the given edge set. For all matching pairs,_only one edge will be in the resulting data set.__@param edges edges to compute intersection with_@return edge set containing one edge for all matching pairs of the same edge;private DataSet<Edge<K, EV>> getDistinctEdgeIntersection(DataSet<Edge<K, EV>> edges) {_		return this.getEdges()_				.join(edges)_				.where(0, 1, 2)_				.equalTo(0, 1, 2)_				.with(new JoinFunction<Edge<K, EV>, Edge<K, EV>, Edge<K, EV>>() {_					@Override_					public Edge<K, EV> join(Edge<K, EV> first, Edge<K, EV> second) throws Exception {_						return first__					}_				}).withForwardedFieldsFirst("*").name("Intersect edges")_				.distinct()_					.name("Edges")__	};computes,the,intersection,between,the,edge,set,and,the,given,edge,set,for,all,matching,pairs,only,one,edge,will,be,in,the,resulting,data,set,param,edges,edges,to,compute,intersection,with,return,edge,set,containing,one,edge,for,all,matching,pairs,of,the,same,edge;private,data,set,edge,k,ev,get,distinct,edge,intersection,data,set,edge,k,ev,edges,return,this,get,edges,join,edges,where,0,1,2,equal,to,0,1,2,with,new,join,function,edge,k,ev,edge,k,ev,edge,k,ev,override,public,edge,k,ev,join,edge,k,ev,first,edge,k,ev,second,throws,exception,return,first,with,forwarded,fields,first,name,intersect,edges,distinct,name,edges
Graph -> private DataSet<Edge<K, EV>> getDistinctEdgeIntersection(DataSet<Edge<K, EV>> edges);1484685504;Computes the intersection between the edge set and the given edge set. For all matching pairs,_only one edge will be in the resulting data set.__@param edges edges to compute intersection with_@return edge set containing one edge for all matching pairs of the same edge;private DataSet<Edge<K, EV>> getDistinctEdgeIntersection(DataSet<Edge<K, EV>> edges) {_		return this.getEdges()_				.join(edges)_				.where(0, 1, 2)_				.equalTo(0, 1, 2)_				.with(new JoinFunction<Edge<K, EV>, Edge<K, EV>, Edge<K, EV>>() {_					@Override_					public Edge<K, EV> join(Edge<K, EV> first, Edge<K, EV> second) throws Exception {_						return first__					}_				}).withForwardedFieldsFirst("*").name("Intersect edges")_				.distinct()_					.name("Edges")__	};computes,the,intersection,between,the,edge,set,and,the,given,edge,set,for,all,matching,pairs,only,one,edge,will,be,in,the,resulting,data,set,param,edges,edges,to,compute,intersection,with,return,edge,set,containing,one,edge,for,all,matching,pairs,of,the,same,edge;private,data,set,edge,k,ev,get,distinct,edge,intersection,data,set,edge,k,ev,edges,return,this,get,edges,join,edges,where,0,1,2,equal,to,0,1,2,with,new,join,function,edge,k,ev,edge,k,ev,edge,k,ev,override,public,edge,k,ev,join,edge,k,ev,first,edge,k,ev,second,throws,exception,return,first,with,forwarded,fields,first,name,intersect,edges,distinct,name,edges
Graph -> private DataSet<Edge<K, EV>> getDistinctEdgeIntersection(DataSet<Edge<K, EV>> edges);1489068942;Computes the intersection between the edge set and the given edge set. For all matching pairs,_only one edge will be in the resulting data set.__@param edges edges to compute intersection with_@return edge set containing one edge for all matching pairs of the same edge;private DataSet<Edge<K, EV>> getDistinctEdgeIntersection(DataSet<Edge<K, EV>> edges) {_		return this.getEdges()_				.join(edges)_				.where(0, 1, 2)_				.equalTo(0, 1, 2)_				.with(new JoinFunction<Edge<K, EV>, Edge<K, EV>, Edge<K, EV>>() {_					@Override_					public Edge<K, EV> join(Edge<K, EV> first, Edge<K, EV> second) throws Exception {_						return first__					}_				}).withForwardedFieldsFirst("*").name("Intersect edges")_				.distinct()_					.name("Edges")__	};computes,the,intersection,between,the,edge,set,and,the,given,edge,set,for,all,matching,pairs,only,one,edge,will,be,in,the,resulting,data,set,param,edges,edges,to,compute,intersection,with,return,edge,set,containing,one,edge,for,all,matching,pairs,of,the,same,edge;private,data,set,edge,k,ev,get,distinct,edge,intersection,data,set,edge,k,ev,edges,return,this,get,edges,join,edges,where,0,1,2,equal,to,0,1,2,with,new,join,function,edge,k,ev,edge,k,ev,edge,k,ev,override,public,edge,k,ev,join,edge,k,ev,first,edge,k,ev,second,throws,exception,return,first,with,forwarded,fields,first,name,intersect,edges,distinct,name,edges
Graph -> private DataSet<Edge<K, EV>> getDistinctEdgeIntersection(DataSet<Edge<K, EV>> edges);1490973446;Computes the intersection between the edge set and the given edge set. For all matching pairs,_only one edge will be in the resulting data set.__@param edges edges to compute intersection with_@return edge set containing one edge for all matching pairs of the same edge;private DataSet<Edge<K, EV>> getDistinctEdgeIntersection(DataSet<Edge<K, EV>> edges) {_		return this.getEdges()_				.join(edges)_				.where(0, 1, 2)_				.equalTo(0, 1, 2)_				.with(new JoinFunction<Edge<K, EV>, Edge<K, EV>, Edge<K, EV>>() {_					@Override_					public Edge<K, EV> join(Edge<K, EV> first, Edge<K, EV> second) throws Exception {_						return first__					}_				}).withForwardedFieldsFirst("*").name("Intersect edges")_				.distinct()_					.name("Edges")__	};computes,the,intersection,between,the,edge,set,and,the,given,edge,set,for,all,matching,pairs,only,one,edge,will,be,in,the,resulting,data,set,param,edges,edges,to,compute,intersection,with,return,edge,set,containing,one,edge,for,all,matching,pairs,of,the,same,edge;private,data,set,edge,k,ev,get,distinct,edge,intersection,data,set,edge,k,ev,edges,return,this,get,edges,join,edges,where,0,1,2,equal,to,0,1,2,with,new,join,function,edge,k,ev,edge,k,ev,edge,k,ev,override,public,edge,k,ev,join,edge,k,ev,first,edge,k,ev,second,throws,exception,return,first,with,forwarded,fields,first,name,intersect,edges,distinct,name,edges
Graph -> private DataSet<Edge<K, EV>> getDistinctEdgeIntersection(DataSet<Edge<K, EV>> edges);1495819075;Computes the intersection between the edge set and the given edge set. For all matching pairs,_only one edge will be in the resulting data set.__@param edges edges to compute intersection with_@return edge set containing one edge for all matching pairs of the same edge;private DataSet<Edge<K, EV>> getDistinctEdgeIntersection(DataSet<Edge<K, EV>> edges) {_		return this.getEdges()_				.join(edges)_				.where(0, 1, 2)_				.equalTo(0, 1, 2)_				.with(new JoinFunction<Edge<K, EV>, Edge<K, EV>, Edge<K, EV>>() {_					@Override_					public Edge<K, EV> join(Edge<K, EV> first, Edge<K, EV> second) throws Exception {_						return first__					}_				}).withForwardedFieldsFirst("*").name("Intersect edges")_				.distinct()_					.name("Edges")__	};computes,the,intersection,between,the,edge,set,and,the,given,edge,set,for,all,matching,pairs,only,one,edge,will,be,in,the,resulting,data,set,param,edges,edges,to,compute,intersection,with,return,edge,set,containing,one,edge,for,all,matching,pairs,of,the,same,edge;private,data,set,edge,k,ev,get,distinct,edge,intersection,data,set,edge,k,ev,edges,return,this,get,edges,join,edges,where,0,1,2,equal,to,0,1,2,with,new,join,function,edge,k,ev,edge,k,ev,edge,k,ev,override,public,edge,k,ev,join,edge,k,ev,first,edge,k,ev,second,throws,exception,return,first,with,forwarded,fields,first,name,intersect,edges,distinct,name,edges
Graph -> private DataSet<Edge<K, EV>> getDistinctEdgeIntersection(DataSet<Edge<K, EV>> edges);1502111816;Computes the intersection between the edge set and the given edge set. For all matching pairs,_only one edge will be in the resulting data set.__@param edges edges to compute intersection with_@return edge set containing one edge for all matching pairs of the same edge;private DataSet<Edge<K, EV>> getDistinctEdgeIntersection(DataSet<Edge<K, EV>> edges) {_		return this.getEdges()_				.join(edges)_				.where(0, 1, 2)_				.equalTo(0, 1, 2)_				.with(new JoinFunction<Edge<K, EV>, Edge<K, EV>, Edge<K, EV>>() {_					@Override_					public Edge<K, EV> join(Edge<K, EV> first, Edge<K, EV> second) throws Exception {_						return first__					}_				}).withForwardedFieldsFirst("*").name("Intersect edges")_				.distinct()_					.name("Edges")__	};computes,the,intersection,between,the,edge,set,and,the,given,edge,set,for,all,matching,pairs,only,one,edge,will,be,in,the,resulting,data,set,param,edges,edges,to,compute,intersection,with,return,edge,set,containing,one,edge,for,all,matching,pairs,of,the,same,edge;private,data,set,edge,k,ev,get,distinct,edge,intersection,data,set,edge,k,ev,edges,return,this,get,edges,join,edges,where,0,1,2,equal,to,0,1,2,with,new,join,function,edge,k,ev,edge,k,ev,edge,k,ev,override,public,edge,k,ev,join,edge,k,ev,first,edge,k,ev,second,throws,exception,return,first,with,forwarded,fields,first,name,intersect,edges,distinct,name,edges
Graph -> public DataSet<Tuple2<K, LongValue>> outDegrees();1467140656;Return the out-degree of all vertices in the graph__@return A DataSet of {@code Tuple2<vertexId, outDegree>};public DataSet<Tuple2<K, LongValue>> outDegrees() {__		return vertices.coGroup(edges).where(0).equalTo(0).with(new CountNeighborsCoGroup<K, VV, EV>())__	};return,the,out,degree,of,all,vertices,in,the,graph,return,a,data,set,of,code,tuple2,vertex,id,out,degree;public,data,set,tuple2,k,long,value,out,degrees,return,vertices,co,group,edges,where,0,equal,to,0,with,new,count,neighbors,co,group,k,vv,ev
Graph -> public DataSet<Tuple2<K, LongValue>> outDegrees();1467306272;Return the out-degree of all vertices in the graph__@return A DataSet of {@code Tuple2<vertexId, outDegree>};public DataSet<Tuple2<K, LongValue>> outDegrees() {__		return vertices.coGroup(edges).where(0).equalTo(0).with(new CountNeighborsCoGroup<K, VV, EV>())__	};return,the,out,degree,of,all,vertices,in,the,graph,return,a,data,set,of,code,tuple2,vertex,id,out,degree;public,data,set,tuple2,k,long,value,out,degrees,return,vertices,co,group,edges,where,0,equal,to,0,with,new,count,neighbors,co,group,k,vv,ev
Graph -> public DataSet<Tuple2<K, LongValue>> outDegrees();1470042815;Return the out-degree of all vertices in the graph__@return A DataSet of {@code Tuple2<vertexId, outDegree>};public DataSet<Tuple2<K, LongValue>> outDegrees() {__		return vertices.coGroup(edges).where(0).equalTo(0).with(new CountNeighborsCoGroup<K, VV, EV>())__	};return,the,out,degree,of,all,vertices,in,the,graph,return,a,data,set,of,code,tuple2,vertex,id,out,degree;public,data,set,tuple2,k,long,value,out,degrees,return,vertices,co,group,edges,where,0,equal,to,0,with,new,count,neighbors,co,group,k,vv,ev
Graph -> public DataSet<Tuple2<K, LongValue>> outDegrees();1475684776;Return the out-degree of all vertices in the graph__@return A DataSet of {@code Tuple2<vertexId, outDegree>};public DataSet<Tuple2<K, LongValue>> outDegrees() {__		return vertices.coGroup(edges).where(0).equalTo(0).with(new CountNeighborsCoGroup<K, VV, EV>())__	};return,the,out,degree,of,all,vertices,in,the,graph,return,a,data,set,of,code,tuple2,vertex,id,out,degree;public,data,set,tuple2,k,long,value,out,degrees,return,vertices,co,group,edges,where,0,equal,to,0,with,new,count,neighbors,co,group,k,vv,ev
Graph -> public DataSet<Tuple2<K, LongValue>> outDegrees();1475685606;Return the out-degree of all vertices in the graph__@return A DataSet of {@code Tuple2<vertexId, outDegree>};public DataSet<Tuple2<K, LongValue>> outDegrees() {__		return vertices.coGroup(edges).where(0).equalTo(0).with(new CountNeighborsCoGroup<K, VV, EV>())__	};return,the,out,degree,of,all,vertices,in,the,graph,return,a,data,set,of,code,tuple2,vertex,id,out,degree;public,data,set,tuple2,k,long,value,out,degrees,return,vertices,co,group,edges,where,0,equal,to,0,with,new,count,neighbors,co,group,k,vv,ev
Graph -> public DataSet<Tuple2<K, LongValue>> outDegrees();1481745825;Return the out-degree of all vertices in the graph__@return A DataSet of {@code Tuple2<vertexId, outDegree>};public DataSet<Tuple2<K, LongValue>> outDegrees() {__		return vertices.coGroup(edges).where(0).equalTo(0).with(new CountNeighborsCoGroup<K, VV, EV>())_			.name("Out-degree")__	};return,the,out,degree,of,all,vertices,in,the,graph,return,a,data,set,of,code,tuple2,vertex,id,out,degree;public,data,set,tuple2,k,long,value,out,degrees,return,vertices,co,group,edges,where,0,equal,to,0,with,new,count,neighbors,co,group,k,vv,ev,name,out,degree
Graph -> public DataSet<Tuple2<K, LongValue>> outDegrees();1481881009;Return the out-degree of all vertices in the graph__@return A DataSet of {@code Tuple2<vertexId, outDegree>};public DataSet<Tuple2<K, LongValue>> outDegrees() {__		return vertices.coGroup(edges).where(0).equalTo(0).with(new CountNeighborsCoGroup<K, VV, EV>())_			.name("Out-degree")__	};return,the,out,degree,of,all,vertices,in,the,graph,return,a,data,set,of,code,tuple2,vertex,id,out,degree;public,data,set,tuple2,k,long,value,out,degrees,return,vertices,co,group,edges,where,0,equal,to,0,with,new,count,neighbors,co,group,k,vv,ev,name,out,degree
Graph -> public DataSet<Tuple2<K, LongValue>> outDegrees();1484160227;Return the out-degree of all vertices in the graph__@return A DataSet of {@code Tuple2<vertexId, outDegree>};public DataSet<Tuple2<K, LongValue>> outDegrees() {__		return vertices.coGroup(edges).where(0).equalTo(0).with(new CountNeighborsCoGroup<K, VV, EV>())_			.name("Out-degree")__	};return,the,out,degree,of,all,vertices,in,the,graph,return,a,data,set,of,code,tuple2,vertex,id,out,degree;public,data,set,tuple2,k,long,value,out,degrees,return,vertices,co,group,edges,where,0,equal,to,0,with,new,count,neighbors,co,group,k,vv,ev,name,out,degree
Graph -> public DataSet<Tuple2<K, LongValue>> outDegrees();1484685504;Return the out-degree of all vertices in the graph__@return A DataSet of {@code Tuple2<vertexId, outDegree>};public DataSet<Tuple2<K, LongValue>> outDegrees() {__		return vertices.coGroup(edges).where(0).equalTo(0).with(new CountNeighborsCoGroup<K, VV, EV>())_			.name("Out-degree")__	};return,the,out,degree,of,all,vertices,in,the,graph,return,a,data,set,of,code,tuple2,vertex,id,out,degree;public,data,set,tuple2,k,long,value,out,degrees,return,vertices,co,group,edges,where,0,equal,to,0,with,new,count,neighbors,co,group,k,vv,ev,name,out,degree
Graph -> public DataSet<Tuple2<K, LongValue>> outDegrees();1489068942;Return the out-degree of all vertices in the graph__@return A DataSet of {@code Tuple2<vertexId, outDegree>};public DataSet<Tuple2<K, LongValue>> outDegrees() {__		return vertices.coGroup(edges).where(0).equalTo(0).with(new CountNeighborsCoGroup<K, VV, EV>())_			.name("Out-degree")__	};return,the,out,degree,of,all,vertices,in,the,graph,return,a,data,set,of,code,tuple2,vertex,id,out,degree;public,data,set,tuple2,k,long,value,out,degrees,return,vertices,co,group,edges,where,0,equal,to,0,with,new,count,neighbors,co,group,k,vv,ev,name,out,degree
Graph -> public DataSet<Tuple2<K, LongValue>> outDegrees();1490973446;Return the out-degree of all vertices in the graph__@return A DataSet of {@code Tuple2<vertexId, outDegree>};public DataSet<Tuple2<K, LongValue>> outDegrees() {__		return vertices.coGroup(edges).where(0).equalTo(0).with(new CountNeighborsCoGroup<K, VV, EV>())_			.name("Out-degree")__	};return,the,out,degree,of,all,vertices,in,the,graph,return,a,data,set,of,code,tuple2,vertex,id,out,degree;public,data,set,tuple2,k,long,value,out,degrees,return,vertices,co,group,edges,where,0,equal,to,0,with,new,count,neighbors,co,group,k,vv,ev,name,out,degree
Graph -> public DataSet<Tuple2<K, LongValue>> outDegrees();1495819075;Return the out-degree of all vertices in the graph.__@return A DataSet of {@code Tuple2<vertexId, outDegree>};public DataSet<Tuple2<K, LongValue>> outDegrees() {__		return vertices.coGroup(edges).where(0).equalTo(0).with(new CountNeighborsCoGroup<K, VV, EV>())_			.name("Out-degree")__	};return,the,out,degree,of,all,vertices,in,the,graph,return,a,data,set,of,code,tuple2,vertex,id,out,degree;public,data,set,tuple2,k,long,value,out,degrees,return,vertices,co,group,edges,where,0,equal,to,0,with,new,count,neighbors,co,group,k,vv,ev,name,out,degree
Graph -> public DataSet<Tuple2<K, LongValue>> outDegrees();1502111816;Return the out-degree of all vertices in the graph.__@return A DataSet of {@code Tuple2<vertexId, outDegree>};public DataSet<Tuple2<K, LongValue>> outDegrees() {__		return vertices.coGroup(edges).where(0).equalTo(0).with(new CountNeighborsCoGroup<>())_			.name("Out-degree")__	};return,the,out,degree,of,all,vertices,in,the,graph,return,a,data,set,of,code,tuple2,vertex,id,out,degree;public,data,set,tuple2,k,long,value,out,degrees,return,vertices,co,group,edges,where,0,equal,to,0,with,new,count,neighbors,co,group,name,out,degree
Graph -> public Graph<K, VV, EV> addEdge(Vertex<K, VV> source, Vertex<K, VV> target, EV edgeValue);1444404795;Adds the given edge to the graph. If the source and target vertices do_not exist in the graph, they will also be added.__@param source the source vertex of the edge_@param target the target vertex of the edge_@param edgeValue the edge value_@return the new graph containing the existing vertices and edges plus the_newly added edge;public Graph<K, VV, EV> addEdge(Vertex<K, VV> source, Vertex<K, VV> target, EV edgeValue) {_		Graph<K, VV, EV> partialGraph = fromCollection(Arrays.asList(source, target),_				Arrays.asList(new Edge<K, EV>(source.f0, target.f0, edgeValue)),_				this.context)__		return this.union(partialGraph)__	};adds,the,given,edge,to,the,graph,if,the,source,and,target,vertices,do,not,exist,in,the,graph,they,will,also,be,added,param,source,the,source,vertex,of,the,edge,param,target,the,target,vertex,of,the,edge,param,edge,value,the,edge,value,return,the,new,graph,containing,the,existing,vertices,and,edges,plus,the,newly,added,edge;public,graph,k,vv,ev,add,edge,vertex,k,vv,source,vertex,k,vv,target,ev,edge,value,graph,k,vv,ev,partial,graph,from,collection,arrays,as,list,source,target,arrays,as,list,new,edge,k,ev,source,f0,target,f0,edge,value,this,context,return,this,union,partial,graph
Graph -> public Graph<K, VV, EV> addEdge(Vertex<K, VV> source, Vertex<K, VV> target, EV edgeValue);1445261977;Adds the given edge to the graph. If the source and target vertices do_not exist in the graph, they will also be added.__@param source the source vertex of the edge_@param target the target vertex of the edge_@param edgeValue the edge value_@return the new graph containing the existing vertices and edges plus the_newly added edge;public Graph<K, VV, EV> addEdge(Vertex<K, VV> source, Vertex<K, VV> target, EV edgeValue) {_		Graph<K, VV, EV> partialGraph = fromCollection(Arrays.asList(source, target),_				Arrays.asList(new Edge<K, EV>(source.f0, target.f0, edgeValue)),_				this.context)__		return this.union(partialGraph)__	};adds,the,given,edge,to,the,graph,if,the,source,and,target,vertices,do,not,exist,in,the,graph,they,will,also,be,added,param,source,the,source,vertex,of,the,edge,param,target,the,target,vertex,of,the,edge,param,edge,value,the,edge,value,return,the,new,graph,containing,the,existing,vertices,and,edges,plus,the,newly,added,edge;public,graph,k,vv,ev,add,edge,vertex,k,vv,source,vertex,k,vv,target,ev,edge,value,graph,k,vv,ev,partial,graph,from,collection,arrays,as,list,source,target,arrays,as,list,new,edge,k,ev,source,f0,target,f0,edge,value,this,context,return,this,union,partial,graph
Graph -> public Graph<K, VV, EV> addEdge(Vertex<K, VV> source, Vertex<K, VV> target, EV edgeValue);1445854323;Adds the given edge to the graph. If the source and target vertices do_not exist in the graph, they will also be added.__@param source the source vertex of the edge_@param target the target vertex of the edge_@param edgeValue the edge value_@return the new graph containing the existing vertices and edges plus the_newly added edge;public Graph<K, VV, EV> addEdge(Vertex<K, VV> source, Vertex<K, VV> target, EV edgeValue) {_		Graph<K, VV, EV> partialGraph = fromCollection(Arrays.asList(source, target),_				Arrays.asList(new Edge<K, EV>(source.f0, target.f0, edgeValue)),_				this.context)__		return this.union(partialGraph)__	};adds,the,given,edge,to,the,graph,if,the,source,and,target,vertices,do,not,exist,in,the,graph,they,will,also,be,added,param,source,the,source,vertex,of,the,edge,param,target,the,target,vertex,of,the,edge,param,edge,value,the,edge,value,return,the,new,graph,containing,the,existing,vertices,and,edges,plus,the,newly,added,edge;public,graph,k,vv,ev,add,edge,vertex,k,vv,source,vertex,k,vv,target,ev,edge,value,graph,k,vv,ev,partial,graph,from,collection,arrays,as,list,source,target,arrays,as,list,new,edge,k,ev,source,f0,target,f0,edge,value,this,context,return,this,union,partial,graph
Graph -> public Graph<K, VV, EV> addEdge(Vertex<K, VV> source, Vertex<K, VV> target, EV edgeValue);1446112342;Adds the given edge to the graph. If the source and target vertices do_not exist in the graph, they will also be added.__@param source the source vertex of the edge_@param target the target vertex of the edge_@param edgeValue the edge value_@return the new graph containing the existing vertices and edges plus the_newly added edge;public Graph<K, VV, EV> addEdge(Vertex<K, VV> source, Vertex<K, VV> target, EV edgeValue) {_		Graph<K, VV, EV> partialGraph = fromCollection(Arrays.asList(source, target),_				Arrays.asList(new Edge<K, EV>(source.f0, target.f0, edgeValue)),_				this.context)__		return this.union(partialGraph)__	};adds,the,given,edge,to,the,graph,if,the,source,and,target,vertices,do,not,exist,in,the,graph,they,will,also,be,added,param,source,the,source,vertex,of,the,edge,param,target,the,target,vertex,of,the,edge,param,edge,value,the,edge,value,return,the,new,graph,containing,the,existing,vertices,and,edges,plus,the,newly,added,edge;public,graph,k,vv,ev,add,edge,vertex,k,vv,source,vertex,k,vv,target,ev,edge,value,graph,k,vv,ev,partial,graph,from,collection,arrays,as,list,source,target,arrays,as,list,new,edge,k,ev,source,f0,target,f0,edge,value,this,context,return,this,union,partial,graph
Graph -> public Graph<K, VV, EV> addEdge(Vertex<K, VV> source, Vertex<K, VV> target, EV edgeValue);1447073368;Adds the given edge to the graph. If the source and target vertices do_not exist in the graph, they will also be added.__@param source the source vertex of the edge_@param target the target vertex of the edge_@param edgeValue the edge value_@return the new graph containing the existing vertices and edges plus the_newly added edge;public Graph<K, VV, EV> addEdge(Vertex<K, VV> source, Vertex<K, VV> target, EV edgeValue) {_		Graph<K, VV, EV> partialGraph = fromCollection(Arrays.asList(source, target),_				Arrays.asList(new Edge<K, EV>(source.f0, target.f0, edgeValue)),_				this.context)__		return this.union(partialGraph)__	};adds,the,given,edge,to,the,graph,if,the,source,and,target,vertices,do,not,exist,in,the,graph,they,will,also,be,added,param,source,the,source,vertex,of,the,edge,param,target,the,target,vertex,of,the,edge,param,edge,value,the,edge,value,return,the,new,graph,containing,the,existing,vertices,and,edges,plus,the,newly,added,edge;public,graph,k,vv,ev,add,edge,vertex,k,vv,source,vertex,k,vv,target,ev,edge,value,graph,k,vv,ev,partial,graph,from,collection,arrays,as,list,source,target,arrays,as,list,new,edge,k,ev,source,f0,target,f0,edge,value,this,context,return,this,union,partial,graph
Graph -> public Graph<K, VV, EV> addEdge(Vertex<K, VV> source, Vertex<K, VV> target, EV edgeValue);1454404649;Adds the given edge to the graph. If the source and target vertices do_not exist in the graph, they will also be added.__@param source the source vertex of the edge_@param target the target vertex of the edge_@param edgeValue the edge value_@return the new graph containing the existing vertices and edges plus the_newly added edge;public Graph<K, VV, EV> addEdge(Vertex<K, VV> source, Vertex<K, VV> target, EV edgeValue) {_		Graph<K, VV, EV> partialGraph = fromCollection(Arrays.asList(source, target),_				Arrays.asList(new Edge<K, EV>(source.f0, target.f0, edgeValue)),_				this.context)__		return this.union(partialGraph)__	};adds,the,given,edge,to,the,graph,if,the,source,and,target,vertices,do,not,exist,in,the,graph,they,will,also,be,added,param,source,the,source,vertex,of,the,edge,param,target,the,target,vertex,of,the,edge,param,edge,value,the,edge,value,return,the,new,graph,containing,the,existing,vertices,and,edges,plus,the,newly,added,edge;public,graph,k,vv,ev,add,edge,vertex,k,vv,source,vertex,k,vv,target,ev,edge,value,graph,k,vv,ev,partial,graph,from,collection,arrays,as,list,source,target,arrays,as,list,new,edge,k,ev,source,f0,target,f0,edge,value,this,context,return,this,union,partial,graph
Graph -> public Graph<K, VV, EV> addEdge(Vertex<K, VV> source, Vertex<K, VV> target, EV edgeValue);1458583829;Adds the given edge to the graph. If the source and target vertices do_not exist in the graph, they will also be added.__@param source the source vertex of the edge_@param target the target vertex of the edge_@param edgeValue the edge value_@return the new graph containing the existing vertices and edges plus the_newly added edge;public Graph<K, VV, EV> addEdge(Vertex<K, VV> source, Vertex<K, VV> target, EV edgeValue) {_		Graph<K, VV, EV> partialGraph = fromCollection(Arrays.asList(source, target),_				Arrays.asList(new Edge<K, EV>(source.f0, target.f0, edgeValue)),_				this.context)__		return this.union(partialGraph)__	};adds,the,given,edge,to,the,graph,if,the,source,and,target,vertices,do,not,exist,in,the,graph,they,will,also,be,added,param,source,the,source,vertex,of,the,edge,param,target,the,target,vertex,of,the,edge,param,edge,value,the,edge,value,return,the,new,graph,containing,the,existing,vertices,and,edges,plus,the,newly,added,edge;public,graph,k,vv,ev,add,edge,vertex,k,vv,source,vertex,k,vv,target,ev,edge,value,graph,k,vv,ev,partial,graph,from,collection,arrays,as,list,source,target,arrays,as,list,new,edge,k,ev,source,f0,target,f0,edge,value,this,context,return,this,union,partial,graph
Graph -> public Graph<K, VV, EV> addEdge(Vertex<K, VV> source, Vertex<K, VV> target, EV edgeValue);1458583829;Adds the given edge to the graph. If the source and target vertices do_not exist in the graph, they will also be added.__@param source the source vertex of the edge_@param target the target vertex of the edge_@param edgeValue the edge value_@return the new graph containing the existing vertices and edges plus the_newly added edge;public Graph<K, VV, EV> addEdge(Vertex<K, VV> source, Vertex<K, VV> target, EV edgeValue) {_		Graph<K, VV, EV> partialGraph = fromCollection(Arrays.asList(source, target),_				Arrays.asList(new Edge<K, EV>(source.f0, target.f0, edgeValue)),_				this.context)__		return this.union(partialGraph)__	};adds,the,given,edge,to,the,graph,if,the,source,and,target,vertices,do,not,exist,in,the,graph,they,will,also,be,added,param,source,the,source,vertex,of,the,edge,param,target,the,target,vertex,of,the,edge,param,edge,value,the,edge,value,return,the,new,graph,containing,the,existing,vertices,and,edges,plus,the,newly,added,edge;public,graph,k,vv,ev,add,edge,vertex,k,vv,source,vertex,k,vv,target,ev,edge,value,graph,k,vv,ev,partial,graph,from,collection,arrays,as,list,source,target,arrays,as,list,new,edge,k,ev,source,f0,target,f0,edge,value,this,context,return,this,union,partial,graph
Graph -> public Graph<K, VV, EV> addEdge(Vertex<K, VV> source, Vertex<K, VV> target, EV edgeValue);1462100316;Adds the given edge to the graph. If the source and target vertices do_not exist in the graph, they will also be added.__@param source the source vertex of the edge_@param target the target vertex of the edge_@param edgeValue the edge value_@return the new graph containing the existing vertices and edges plus the_newly added edge;public Graph<K, VV, EV> addEdge(Vertex<K, VV> source, Vertex<K, VV> target, EV edgeValue) {_		Graph<K, VV, EV> partialGraph = fromCollection(Arrays.asList(source, target),_				Arrays.asList(new Edge<K, EV>(source.f0, target.f0, edgeValue)),_				this.context)__		return this.union(partialGraph)__	};adds,the,given,edge,to,the,graph,if,the,source,and,target,vertices,do,not,exist,in,the,graph,they,will,also,be,added,param,source,the,source,vertex,of,the,edge,param,target,the,target,vertex,of,the,edge,param,edge,value,the,edge,value,return,the,new,graph,containing,the,existing,vertices,and,edges,plus,the,newly,added,edge;public,graph,k,vv,ev,add,edge,vertex,k,vv,source,vertex,k,vv,target,ev,edge,value,graph,k,vv,ev,partial,graph,from,collection,arrays,as,list,source,target,arrays,as,list,new,edge,k,ev,source,f0,target,f0,edge,value,this,context,return,this,union,partial,graph
Graph -> public Graph<K, VV, EV> addEdge(Vertex<K, VV> source, Vertex<K, VV> target, EV edgeValue);1462100316;Adds the given edge to the graph. If the source and target vertices do_not exist in the graph, they will also be added.__@param source the source vertex of the edge_@param target the target vertex of the edge_@param edgeValue the edge value_@return the new graph containing the existing vertices and edges plus the_newly added edge;public Graph<K, VV, EV> addEdge(Vertex<K, VV> source, Vertex<K, VV> target, EV edgeValue) {_		Graph<K, VV, EV> partialGraph = fromCollection(Arrays.asList(source, target),_				Arrays.asList(new Edge<K, EV>(source.f0, target.f0, edgeValue)),_				this.context)__		return this.union(partialGraph)__	};adds,the,given,edge,to,the,graph,if,the,source,and,target,vertices,do,not,exist,in,the,graph,they,will,also,be,added,param,source,the,source,vertex,of,the,edge,param,target,the,target,vertex,of,the,edge,param,edge,value,the,edge,value,return,the,new,graph,containing,the,existing,vertices,and,edges,plus,the,newly,added,edge;public,graph,k,vv,ev,add,edge,vertex,k,vv,source,vertex,k,vv,target,ev,edge,value,graph,k,vv,ev,partial,graph,from,collection,arrays,as,list,source,target,arrays,as,list,new,edge,k,ev,source,f0,target,f0,edge,value,this,context,return,this,union,partial,graph
Graph -> public Graph<K, VV, EV> addEdge(Vertex<K, VV> source, Vertex<K, VV> target, EV edgeValue);1462205213;Adds the given edge to the graph. If the source and target vertices do_not exist in the graph, they will also be added.__@param source the source vertex of the edge_@param target the target vertex of the edge_@param edgeValue the edge value_@return the new graph containing the existing vertices and edges plus the_newly added edge;public Graph<K, VV, EV> addEdge(Vertex<K, VV> source, Vertex<K, VV> target, EV edgeValue) {_		Graph<K, VV, EV> partialGraph = fromCollection(Arrays.asList(source, target),_				Arrays.asList(new Edge<K, EV>(source.f0, target.f0, edgeValue)),_				this.context)__		return this.union(partialGraph)__	};adds,the,given,edge,to,the,graph,if,the,source,and,target,vertices,do,not,exist,in,the,graph,they,will,also,be,added,param,source,the,source,vertex,of,the,edge,param,target,the,target,vertex,of,the,edge,param,edge,value,the,edge,value,return,the,new,graph,containing,the,existing,vertices,and,edges,plus,the,newly,added,edge;public,graph,k,vv,ev,add,edge,vertex,k,vv,source,vertex,k,vv,target,ev,edge,value,graph,k,vv,ev,partial,graph,from,collection,arrays,as,list,source,target,arrays,as,list,new,edge,k,ev,source,f0,target,f0,edge,value,this,context,return,this,union,partial,graph
Graph -> public Graph<K, VV, EV> addEdge(Vertex<K, VV> source, Vertex<K, VV> target, EV edgeValue);1462208859;Adds the given edge to the graph. If the source and target vertices do_not exist in the graph, they will also be added.__@param source the source vertex of the edge_@param target the target vertex of the edge_@param edgeValue the edge value_@return the new graph containing the existing vertices and edges plus the_newly added edge;public Graph<K, VV, EV> addEdge(Vertex<K, VV> source, Vertex<K, VV> target, EV edgeValue) {_		Graph<K, VV, EV> partialGraph = fromCollection(Arrays.asList(source, target),_				Arrays.asList(new Edge<K, EV>(source.f0, target.f0, edgeValue)),_				this.context)__		return this.union(partialGraph)__	};adds,the,given,edge,to,the,graph,if,the,source,and,target,vertices,do,not,exist,in,the,graph,they,will,also,be,added,param,source,the,source,vertex,of,the,edge,param,target,the,target,vertex,of,the,edge,param,edge,value,the,edge,value,return,the,new,graph,containing,the,existing,vertices,and,edges,plus,the,newly,added,edge;public,graph,k,vv,ev,add,edge,vertex,k,vv,source,vertex,k,vv,target,ev,edge,value,graph,k,vv,ev,partial,graph,from,collection,arrays,as,list,source,target,arrays,as,list,new,edge,k,ev,source,f0,target,f0,edge,value,this,context,return,this,union,partial,graph
Graph -> public Graph<K, VV, EV> addEdge(Vertex<K, VV> source, Vertex<K, VV> target, EV edgeValue);1462809297;Adds the given edge to the graph. If the source and target vertices do_not exist in the graph, they will also be added.__@param source the source vertex of the edge_@param target the target vertex of the edge_@param edgeValue the edge value_@return the new graph containing the existing vertices and edges plus the_newly added edge;public Graph<K, VV, EV> addEdge(Vertex<K, VV> source, Vertex<K, VV> target, EV edgeValue) {_		Graph<K, VV, EV> partialGraph = fromCollection(Arrays.asList(source, target),_				Arrays.asList(new Edge<K, EV>(source.f0, target.f0, edgeValue)),_				this.context)__		return this.union(partialGraph)__	};adds,the,given,edge,to,the,graph,if,the,source,and,target,vertices,do,not,exist,in,the,graph,they,will,also,be,added,param,source,the,source,vertex,of,the,edge,param,target,the,target,vertex,of,the,edge,param,edge,value,the,edge,value,return,the,new,graph,containing,the,existing,vertices,and,edges,plus,the,newly,added,edge;public,graph,k,vv,ev,add,edge,vertex,k,vv,source,vertex,k,vv,target,ev,edge,value,graph,k,vv,ev,partial,graph,from,collection,arrays,as,list,source,target,arrays,as,list,new,edge,k,ev,source,f0,target,f0,edge,value,this,context,return,this,union,partial,graph
Graph -> public Graph<K, VV, EV> addEdge(Vertex<K, VV> source, Vertex<K, VV> target, EV edgeValue);1465316775;Adds the given edge to the graph. If the source and target vertices do_not exist in the graph, they will also be added.__@param source the source vertex of the edge_@param target the target vertex of the edge_@param edgeValue the edge value_@return the new graph containing the existing vertices and edges plus the_newly added edge;public Graph<K, VV, EV> addEdge(Vertex<K, VV> source, Vertex<K, VV> target, EV edgeValue) {_		Graph<K, VV, EV> partialGraph = fromCollection(Arrays.asList(source, target),_				Arrays.asList(new Edge<K, EV>(source.f0, target.f0, edgeValue)),_				this.context)__		return this.union(partialGraph)__	};adds,the,given,edge,to,the,graph,if,the,source,and,target,vertices,do,not,exist,in,the,graph,they,will,also,be,added,param,source,the,source,vertex,of,the,edge,param,target,the,target,vertex,of,the,edge,param,edge,value,the,edge,value,return,the,new,graph,containing,the,existing,vertices,and,edges,plus,the,newly,added,edge;public,graph,k,vv,ev,add,edge,vertex,k,vv,source,vertex,k,vv,target,ev,edge,value,graph,k,vv,ev,partial,graph,from,collection,arrays,as,list,source,target,arrays,as,list,new,edge,k,ev,source,f0,target,f0,edge,value,this,context,return,this,union,partial,graph
Graph -> public Graph<K, VV, EV> addEdge(Vertex<K, VV> source, Vertex<K, VV> target, EV edgeValue);1466789678;Adds the given edge to the graph. If the source and target vertices do_not exist in the graph, they will also be added.__@param source the source vertex of the edge_@param target the target vertex of the edge_@param edgeValue the edge value_@return the new graph containing the existing vertices and edges plus the_newly added edge;public Graph<K, VV, EV> addEdge(Vertex<K, VV> source, Vertex<K, VV> target, EV edgeValue) {_		Graph<K, VV, EV> partialGraph = fromCollection(Arrays.asList(source, target),_				Arrays.asList(new Edge<K, EV>(source.f0, target.f0, edgeValue)),_				this.context)__		return this.union(partialGraph)__	};adds,the,given,edge,to,the,graph,if,the,source,and,target,vertices,do,not,exist,in,the,graph,they,will,also,be,added,param,source,the,source,vertex,of,the,edge,param,target,the,target,vertex,of,the,edge,param,edge,value,the,edge,value,return,the,new,graph,containing,the,existing,vertices,and,edges,plus,the,newly,added,edge;public,graph,k,vv,ev,add,edge,vertex,k,vv,source,vertex,k,vv,target,ev,edge,value,graph,k,vv,ev,partial,graph,from,collection,arrays,as,list,source,target,arrays,as,list,new,edge,k,ev,source,f0,target,f0,edge,value,this,context,return,this,union,partial,graph
Graph -> public Graph<K, VV, EV> addEdge(Vertex<K, VV> source, Vertex<K, VV> target, EV edgeValue);1467140656;Adds the given edge to the graph. If the source and target vertices do_not exist in the graph, they will also be added.__@param source the source vertex of the edge_@param target the target vertex of the edge_@param edgeValue the edge value_@return the new graph containing the existing vertices and edges plus the_newly added edge;public Graph<K, VV, EV> addEdge(Vertex<K, VV> source, Vertex<K, VV> target, EV edgeValue) {_		Graph<K, VV, EV> partialGraph = fromCollection(Arrays.asList(source, target),_				Arrays.asList(new Edge<K, EV>(source.f0, target.f0, edgeValue)),_				this.context)__		return this.union(partialGraph)__	};adds,the,given,edge,to,the,graph,if,the,source,and,target,vertices,do,not,exist,in,the,graph,they,will,also,be,added,param,source,the,source,vertex,of,the,edge,param,target,the,target,vertex,of,the,edge,param,edge,value,the,edge,value,return,the,new,graph,containing,the,existing,vertices,and,edges,plus,the,newly,added,edge;public,graph,k,vv,ev,add,edge,vertex,k,vv,source,vertex,k,vv,target,ev,edge,value,graph,k,vv,ev,partial,graph,from,collection,arrays,as,list,source,target,arrays,as,list,new,edge,k,ev,source,f0,target,f0,edge,value,this,context,return,this,union,partial,graph
Graph -> public Graph<K, VV, EV> addEdge(Vertex<K, VV> source, Vertex<K, VV> target, EV edgeValue);1467306272;Adds the given edge to the graph. If the source and target vertices do_not exist in the graph, they will also be added.__@param source the source vertex of the edge_@param target the target vertex of the edge_@param edgeValue the edge value_@return the new graph containing the existing vertices and edges plus the_newly added edge;public Graph<K, VV, EV> addEdge(Vertex<K, VV> source, Vertex<K, VV> target, EV edgeValue) {_		Graph<K, VV, EV> partialGraph = fromCollection(Arrays.asList(source, target),_				Arrays.asList(new Edge<K, EV>(source.f0, target.f0, edgeValue)),_				this.context)__		return this.union(partialGraph)__	};adds,the,given,edge,to,the,graph,if,the,source,and,target,vertices,do,not,exist,in,the,graph,they,will,also,be,added,param,source,the,source,vertex,of,the,edge,param,target,the,target,vertex,of,the,edge,param,edge,value,the,edge,value,return,the,new,graph,containing,the,existing,vertices,and,edges,plus,the,newly,added,edge;public,graph,k,vv,ev,add,edge,vertex,k,vv,source,vertex,k,vv,target,ev,edge,value,graph,k,vv,ev,partial,graph,from,collection,arrays,as,list,source,target,arrays,as,list,new,edge,k,ev,source,f0,target,f0,edge,value,this,context,return,this,union,partial,graph
Graph -> public Graph<K, VV, EV> addEdge(Vertex<K, VV> source, Vertex<K, VV> target, EV edgeValue);1470042815;Adds the given edge to the graph. If the source and target vertices do_not exist in the graph, they will also be added.__@param source the source vertex of the edge_@param target the target vertex of the edge_@param edgeValue the edge value_@return the new graph containing the existing vertices and edges plus the_newly added edge;public Graph<K, VV, EV> addEdge(Vertex<K, VV> source, Vertex<K, VV> target, EV edgeValue) {_		Graph<K, VV, EV> partialGraph = fromCollection(Arrays.asList(source, target),_				Arrays.asList(new Edge<K, EV>(source.f0, target.f0, edgeValue)),_				this.context)__		return this.union(partialGraph)__	};adds,the,given,edge,to,the,graph,if,the,source,and,target,vertices,do,not,exist,in,the,graph,they,will,also,be,added,param,source,the,source,vertex,of,the,edge,param,target,the,target,vertex,of,the,edge,param,edge,value,the,edge,value,return,the,new,graph,containing,the,existing,vertices,and,edges,plus,the,newly,added,edge;public,graph,k,vv,ev,add,edge,vertex,k,vv,source,vertex,k,vv,target,ev,edge,value,graph,k,vv,ev,partial,graph,from,collection,arrays,as,list,source,target,arrays,as,list,new,edge,k,ev,source,f0,target,f0,edge,value,this,context,return,this,union,partial,graph
Graph -> public Graph<K, VV, EV> addEdge(Vertex<K, VV> source, Vertex<K, VV> target, EV edgeValue);1475684776;Adds the given edge to the graph. If the source and target vertices do_not exist in the graph, they will also be added.__@param source the source vertex of the edge_@param target the target vertex of the edge_@param edgeValue the edge value_@return the new graph containing the existing vertices and edges plus the_newly added edge;public Graph<K, VV, EV> addEdge(Vertex<K, VV> source, Vertex<K, VV> target, EV edgeValue) {_		Graph<K, VV, EV> partialGraph = fromCollection(Arrays.asList(source, target),_				Collections.singletonList(new Edge<>(source.f0, target.f0, edgeValue)),_				this.context)__		return this.union(partialGraph)__	};adds,the,given,edge,to,the,graph,if,the,source,and,target,vertices,do,not,exist,in,the,graph,they,will,also,be,added,param,source,the,source,vertex,of,the,edge,param,target,the,target,vertex,of,the,edge,param,edge,value,the,edge,value,return,the,new,graph,containing,the,existing,vertices,and,edges,plus,the,newly,added,edge;public,graph,k,vv,ev,add,edge,vertex,k,vv,source,vertex,k,vv,target,ev,edge,value,graph,k,vv,ev,partial,graph,from,collection,arrays,as,list,source,target,collections,singleton,list,new,edge,source,f0,target,f0,edge,value,this,context,return,this,union,partial,graph
Graph -> public Graph<K, VV, EV> addEdge(Vertex<K, VV> source, Vertex<K, VV> target, EV edgeValue);1475685606;Adds the given edge to the graph. If the source and target vertices do_not exist in the graph, they will also be added.__@param source the source vertex of the edge_@param target the target vertex of the edge_@param edgeValue the edge value_@return the new graph containing the existing vertices and edges plus the_newly added edge;public Graph<K, VV, EV> addEdge(Vertex<K, VV> source, Vertex<K, VV> target, EV edgeValue) {_		Graph<K, VV, EV> partialGraph = fromCollection(Arrays.asList(source, target),_				Collections.singletonList(new Edge<>(source.f0, target.f0, edgeValue)),_				this.context)__		return this.union(partialGraph)__	};adds,the,given,edge,to,the,graph,if,the,source,and,target,vertices,do,not,exist,in,the,graph,they,will,also,be,added,param,source,the,source,vertex,of,the,edge,param,target,the,target,vertex,of,the,edge,param,edge,value,the,edge,value,return,the,new,graph,containing,the,existing,vertices,and,edges,plus,the,newly,added,edge;public,graph,k,vv,ev,add,edge,vertex,k,vv,source,vertex,k,vv,target,ev,edge,value,graph,k,vv,ev,partial,graph,from,collection,arrays,as,list,source,target,collections,singleton,list,new,edge,source,f0,target,f0,edge,value,this,context,return,this,union,partial,graph
Graph -> public Graph<K, VV, EV> addEdge(Vertex<K, VV> source, Vertex<K, VV> target, EV edgeValue);1481745825;Adds the given edge to the graph. If the source and target vertices do_not exist in the graph, they will also be added.__@param source the source vertex of the edge_@param target the target vertex of the edge_@param edgeValue the edge value_@return the new graph containing the existing vertices and edges plus the_newly added edge;public Graph<K, VV, EV> addEdge(Vertex<K, VV> source, Vertex<K, VV> target, EV edgeValue) {_		Graph<K, VV, EV> partialGraph = fromCollection(Arrays.asList(source, target),_				Collections.singletonList(new Edge<>(source.f0, target.f0, edgeValue)),_				this.context)__		return this.union(partialGraph)__	};adds,the,given,edge,to,the,graph,if,the,source,and,target,vertices,do,not,exist,in,the,graph,they,will,also,be,added,param,source,the,source,vertex,of,the,edge,param,target,the,target,vertex,of,the,edge,param,edge,value,the,edge,value,return,the,new,graph,containing,the,existing,vertices,and,edges,plus,the,newly,added,edge;public,graph,k,vv,ev,add,edge,vertex,k,vv,source,vertex,k,vv,target,ev,edge,value,graph,k,vv,ev,partial,graph,from,collection,arrays,as,list,source,target,collections,singleton,list,new,edge,source,f0,target,f0,edge,value,this,context,return,this,union,partial,graph
Graph -> public Graph<K, VV, EV> addEdge(Vertex<K, VV> source, Vertex<K, VV> target, EV edgeValue);1481881009;Adds the given edge to the graph. If the source and target vertices do_not exist in the graph, they will also be added.__@param source the source vertex of the edge_@param target the target vertex of the edge_@param edgeValue the edge value_@return the new graph containing the existing vertices and edges plus the_newly added edge;public Graph<K, VV, EV> addEdge(Vertex<K, VV> source, Vertex<K, VV> target, EV edgeValue) {_		Graph<K, VV, EV> partialGraph = fromCollection(Arrays.asList(source, target),_				Collections.singletonList(new Edge<>(source.f0, target.f0, edgeValue)),_				this.context)__		return this.union(partialGraph)__	};adds,the,given,edge,to,the,graph,if,the,source,and,target,vertices,do,not,exist,in,the,graph,they,will,also,be,added,param,source,the,source,vertex,of,the,edge,param,target,the,target,vertex,of,the,edge,param,edge,value,the,edge,value,return,the,new,graph,containing,the,existing,vertices,and,edges,plus,the,newly,added,edge;public,graph,k,vv,ev,add,edge,vertex,k,vv,source,vertex,k,vv,target,ev,edge,value,graph,k,vv,ev,partial,graph,from,collection,arrays,as,list,source,target,collections,singleton,list,new,edge,source,f0,target,f0,edge,value,this,context,return,this,union,partial,graph
Graph -> public Graph<K, VV, EV> addEdge(Vertex<K, VV> source, Vertex<K, VV> target, EV edgeValue);1484160227;Adds the given edge to the graph. If the source and target vertices do_not exist in the graph, they will also be added.__@param source the source vertex of the edge_@param target the target vertex of the edge_@param edgeValue the edge value_@return the new graph containing the existing vertices and edges plus the_newly added edge;public Graph<K, VV, EV> addEdge(Vertex<K, VV> source, Vertex<K, VV> target, EV edgeValue) {_		Graph<K, VV, EV> partialGraph = fromCollection(Arrays.asList(source, target),_				Collections.singletonList(new Edge<>(source.f0, target.f0, edgeValue)),_				this.context)__		return this.union(partialGraph)__	};adds,the,given,edge,to,the,graph,if,the,source,and,target,vertices,do,not,exist,in,the,graph,they,will,also,be,added,param,source,the,source,vertex,of,the,edge,param,target,the,target,vertex,of,the,edge,param,edge,value,the,edge,value,return,the,new,graph,containing,the,existing,vertices,and,edges,plus,the,newly,added,edge;public,graph,k,vv,ev,add,edge,vertex,k,vv,source,vertex,k,vv,target,ev,edge,value,graph,k,vv,ev,partial,graph,from,collection,arrays,as,list,source,target,collections,singleton,list,new,edge,source,f0,target,f0,edge,value,this,context,return,this,union,partial,graph
Graph -> public Graph<K, VV, EV> addEdge(Vertex<K, VV> source, Vertex<K, VV> target, EV edgeValue);1484685504;Adds the given edge to the graph. If the source and target vertices do_not exist in the graph, they will also be added.__@param source the source vertex of the edge_@param target the target vertex of the edge_@param edgeValue the edge value_@return the new graph containing the existing vertices and edges plus the_newly added edge;public Graph<K, VV, EV> addEdge(Vertex<K, VV> source, Vertex<K, VV> target, EV edgeValue) {_		Graph<K, VV, EV> partialGraph = fromCollection(Arrays.asList(source, target),_				Collections.singletonList(new Edge<>(source.f0, target.f0, edgeValue)),_				this.context)__		return this.union(partialGraph)__	};adds,the,given,edge,to,the,graph,if,the,source,and,target,vertices,do,not,exist,in,the,graph,they,will,also,be,added,param,source,the,source,vertex,of,the,edge,param,target,the,target,vertex,of,the,edge,param,edge,value,the,edge,value,return,the,new,graph,containing,the,existing,vertices,and,edges,plus,the,newly,added,edge;public,graph,k,vv,ev,add,edge,vertex,k,vv,source,vertex,k,vv,target,ev,edge,value,graph,k,vv,ev,partial,graph,from,collection,arrays,as,list,source,target,collections,singleton,list,new,edge,source,f0,target,f0,edge,value,this,context,return,this,union,partial,graph
Graph -> public Graph<K, VV, EV> addEdge(Vertex<K, VV> source, Vertex<K, VV> target, EV edgeValue);1489068942;Adds the given edge to the graph. If the source and target vertices do_not exist in the graph, they will also be added.__@param source the source vertex of the edge_@param target the target vertex of the edge_@param edgeValue the edge value_@return the new graph containing the existing vertices and edges plus the_newly added edge;public Graph<K, VV, EV> addEdge(Vertex<K, VV> source, Vertex<K, VV> target, EV edgeValue) {_		Graph<K, VV, EV> partialGraph = fromCollection(Arrays.asList(source, target),_				Collections.singletonList(new Edge<>(source.f0, target.f0, edgeValue)),_				this.context)__		return this.union(partialGraph)__	};adds,the,given,edge,to,the,graph,if,the,source,and,target,vertices,do,not,exist,in,the,graph,they,will,also,be,added,param,source,the,source,vertex,of,the,edge,param,target,the,target,vertex,of,the,edge,param,edge,value,the,edge,value,return,the,new,graph,containing,the,existing,vertices,and,edges,plus,the,newly,added,edge;public,graph,k,vv,ev,add,edge,vertex,k,vv,source,vertex,k,vv,target,ev,edge,value,graph,k,vv,ev,partial,graph,from,collection,arrays,as,list,source,target,collections,singleton,list,new,edge,source,f0,target,f0,edge,value,this,context,return,this,union,partial,graph
Graph -> public Graph<K, VV, EV> addEdge(Vertex<K, VV> source, Vertex<K, VV> target, EV edgeValue);1490973446;Adds the given edge to the graph. If the source and target vertices do_not exist in the graph, they will also be added.__@param source the source vertex of the edge_@param target the target vertex of the edge_@param edgeValue the edge value_@return the new graph containing the existing vertices and edges plus the_newly added edge;public Graph<K, VV, EV> addEdge(Vertex<K, VV> source, Vertex<K, VV> target, EV edgeValue) {_		Graph<K, VV, EV> partialGraph = fromCollection(Arrays.asList(source, target),_				Collections.singletonList(new Edge<>(source.f0, target.f0, edgeValue)),_				this.context)__		return this.union(partialGraph)__	};adds,the,given,edge,to,the,graph,if,the,source,and,target,vertices,do,not,exist,in,the,graph,they,will,also,be,added,param,source,the,source,vertex,of,the,edge,param,target,the,target,vertex,of,the,edge,param,edge,value,the,edge,value,return,the,new,graph,containing,the,existing,vertices,and,edges,plus,the,newly,added,edge;public,graph,k,vv,ev,add,edge,vertex,k,vv,source,vertex,k,vv,target,ev,edge,value,graph,k,vv,ev,partial,graph,from,collection,arrays,as,list,source,target,collections,singleton,list,new,edge,source,f0,target,f0,edge,value,this,context,return,this,union,partial,graph
Graph -> public Graph<K, VV, EV> addEdge(Vertex<K, VV> source, Vertex<K, VV> target, EV edgeValue);1495819075;Adds the given edge to the graph. If the source and target vertices do_not exist in the graph, they will also be added.__@param source the source vertex of the edge_@param target the target vertex of the edge_@param edgeValue the edge value_@return the new graph containing the existing vertices and edges plus the_newly added edge;public Graph<K, VV, EV> addEdge(Vertex<K, VV> source, Vertex<K, VV> target, EV edgeValue) {_		Graph<K, VV, EV> partialGraph = fromCollection(Arrays.asList(source, target),_				Collections.singletonList(new Edge<>(source.f0, target.f0, edgeValue)),_				this.context)__		return this.union(partialGraph)__	};adds,the,given,edge,to,the,graph,if,the,source,and,target,vertices,do,not,exist,in,the,graph,they,will,also,be,added,param,source,the,source,vertex,of,the,edge,param,target,the,target,vertex,of,the,edge,param,edge,value,the,edge,value,return,the,new,graph,containing,the,existing,vertices,and,edges,plus,the,newly,added,edge;public,graph,k,vv,ev,add,edge,vertex,k,vv,source,vertex,k,vv,target,ev,edge,value,graph,k,vv,ev,partial,graph,from,collection,arrays,as,list,source,target,collections,singleton,list,new,edge,source,f0,target,f0,edge,value,this,context,return,this,union,partial,graph
Graph -> public Graph<K, VV, EV> addEdge(Vertex<K, VV> source, Vertex<K, VV> target, EV edgeValue);1502111816;Adds the given edge to the graph. If the source and target vertices do_not exist in the graph, they will also be added.__@param source the source vertex of the edge_@param target the target vertex of the edge_@param edgeValue the edge value_@return the new graph containing the existing vertices and edges plus the_newly added edge;public Graph<K, VV, EV> addEdge(Vertex<K, VV> source, Vertex<K, VV> target, EV edgeValue) {_		Graph<K, VV, EV> partialGraph = fromCollection(Arrays.asList(source, target),_				Collections.singletonList(new Edge<>(source.f0, target.f0, edgeValue)),_				this.context)__		return this.union(partialGraph)__	};adds,the,given,edge,to,the,graph,if,the,source,and,target,vertices,do,not,exist,in,the,graph,they,will,also,be,added,param,source,the,source,vertex,of,the,edge,param,target,the,target,vertex,of,the,edge,param,edge,value,the,edge,value,return,the,new,graph,containing,the,existing,vertices,and,edges,plus,the,newly,added,edge;public,graph,k,vv,ev,add,edge,vertex,k,vv,source,vertex,k,vv,target,ev,edge,value,graph,k,vv,ev,partial,graph,from,collection,arrays,as,list,source,target,collections,singleton,list,new,edge,source,f0,target,f0,edge,value,this,context,return,this,union,partial,graph
Graph -> public <NEW> Graph<NEW, VV, EV> translateGraphIds(MapFunction<K, NEW> translator) throws Exception;1462205213;Translate {@link Vertex} and {@link Edge} IDs using the given {@link MapFunction}.__@param translator implements conversion from {@code K} to {@code NEW}_@param <NEW> new ID type_@return graph with translated vertex and edge IDs_@throws Exception;public <NEW> Graph<NEW, VV, EV> translateGraphIds(MapFunction<K, NEW> translator) throws Exception {_		return run(new TranslateGraphIds<K, NEW, VV, EV>(translator))__	};translate,link,vertex,and,link,edge,ids,using,the,given,link,map,function,param,translator,implements,conversion,from,code,k,to,code,new,param,new,new,id,type,return,graph,with,translated,vertex,and,edge,ids,throws,exception;public,new,graph,new,vv,ev,translate,graph,ids,map,function,k,new,translator,throws,exception,return,run,new,translate,graph,ids,k,new,vv,ev,translator
Graph -> public <NEW> Graph<NEW, VV, EV> translateGraphIds(MapFunction<K, NEW> translator) throws Exception;1462208859;Translate {@link Vertex} and {@link Edge} IDs using the given {@link MapFunction}.__@param translator implements conversion from {@code K} to {@code NEW}_@param <NEW> new ID type_@return graph with translated vertex and edge IDs_@throws Exception;public <NEW> Graph<NEW, VV, EV> translateGraphIds(MapFunction<K, NEW> translator) throws Exception {_		return run(new TranslateGraphIds<K, NEW, VV, EV>(translator))__	};translate,link,vertex,and,link,edge,ids,using,the,given,link,map,function,param,translator,implements,conversion,from,code,k,to,code,new,param,new,new,id,type,return,graph,with,translated,vertex,and,edge,ids,throws,exception;public,new,graph,new,vv,ev,translate,graph,ids,map,function,k,new,translator,throws,exception,return,run,new,translate,graph,ids,k,new,vv,ev,translator
Graph -> public <T> Graph<K, VV, EV> joinWithEdgesOnTarget(DataSet<Tuple2<K, T>> inputDataSet, 			final EdgeJoinFunction<EV, T> edgeJoinFunction);1445261977;Joins the edge DataSet with an input Tuple2 DataSet and applies a user-defined transformation_on the values of the matched records._The target ID of the edges input and the first field of the input DataSet are used as join keys.__@param inputDataSet the DataSet to join with._The first field of the Tuple2 is used as the join key_and the second field is passed as a parameter to the transformation function._@param edgeJoinFunction the transformation function to apply._The first parameter is the current edge value and the second parameter is the value_of the matched Tuple2 from the input DataSet._@param <T> the type of the second field of the input Tuple2 DataSet._@return a new Graph, where the edge values have been updated according to the_result of the edgeJoinFunction.;public <T> Graph<K, VV, EV> joinWithEdgesOnTarget(DataSet<Tuple2<K, T>> inputDataSet,_			final EdgeJoinFunction<EV, T> edgeJoinFunction) {__		DataSet<Edge<K, EV>> resultedEdges = this.getEdges()_				.coGroup(inputDataSet).where(1).equalTo(0)_				.with(new ApplyCoGroupToEdgeValuesOnEitherSourceOrTarget<K, EV, T>(edgeJoinFunction))___		return new Graph<K, VV, EV>(this.vertices, resultedEdges, this.context)__	};joins,the,edge,data,set,with,an,input,tuple2,data,set,and,applies,a,user,defined,transformation,on,the,values,of,the,matched,records,the,target,id,of,the,edges,input,and,the,first,field,of,the,input,data,set,are,used,as,join,keys,param,input,data,set,the,data,set,to,join,with,the,first,field,of,the,tuple2,is,used,as,the,join,key,and,the,second,field,is,passed,as,a,parameter,to,the,transformation,function,param,edge,join,function,the,transformation,function,to,apply,the,first,parameter,is,the,current,edge,value,and,the,second,parameter,is,the,value,of,the,matched,tuple2,from,the,input,data,set,param,t,the,type,of,the,second,field,of,the,input,tuple2,data,set,return,a,new,graph,where,the,edge,values,have,been,updated,according,to,the,result,of,the,edge,join,function;public,t,graph,k,vv,ev,join,with,edges,on,target,data,set,tuple2,k,t,input,data,set,final,edge,join,function,ev,t,edge,join,function,data,set,edge,k,ev,resulted,edges,this,get,edges,co,group,input,data,set,where,1,equal,to,0,with,new,apply,co,group,to,edge,values,on,either,source,or,target,k,ev,t,edge,join,function,return,new,graph,k,vv,ev,this,vertices,resulted,edges,this,context
Graph -> public <T> Graph<K, VV, EV> joinWithEdgesOnTarget(DataSet<Tuple2<K, T>> inputDataSet, 			final EdgeJoinFunction<EV, T> edgeJoinFunction);1445854323;Joins the edge DataSet with an input Tuple2 DataSet and applies a user-defined transformation_on the values of the matched records._The target ID of the edges input and the first field of the input DataSet are used as join keys.__@param inputDataSet the DataSet to join with._The first field of the Tuple2 is used as the join key_and the second field is passed as a parameter to the transformation function._@param edgeJoinFunction the transformation function to apply._The first parameter is the current edge value and the second parameter is the value_of the matched Tuple2 from the input DataSet._@param <T> the type of the second field of the input Tuple2 DataSet._@return a new Graph, where the edge values have been updated according to the_result of the edgeJoinFunction.;public <T> Graph<K, VV, EV> joinWithEdgesOnTarget(DataSet<Tuple2<K, T>> inputDataSet,_			final EdgeJoinFunction<EV, T> edgeJoinFunction) {__		DataSet<Edge<K, EV>> resultedEdges = this.getEdges()_				.coGroup(inputDataSet).where(1).equalTo(0)_				.with(new ApplyCoGroupToEdgeValuesOnEitherSourceOrTarget<K, EV, T>(edgeJoinFunction))___		return new Graph<K, VV, EV>(this.vertices, resultedEdges, this.context)__	};joins,the,edge,data,set,with,an,input,tuple2,data,set,and,applies,a,user,defined,transformation,on,the,values,of,the,matched,records,the,target,id,of,the,edges,input,and,the,first,field,of,the,input,data,set,are,used,as,join,keys,param,input,data,set,the,data,set,to,join,with,the,first,field,of,the,tuple2,is,used,as,the,join,key,and,the,second,field,is,passed,as,a,parameter,to,the,transformation,function,param,edge,join,function,the,transformation,function,to,apply,the,first,parameter,is,the,current,edge,value,and,the,second,parameter,is,the,value,of,the,matched,tuple2,from,the,input,data,set,param,t,the,type,of,the,second,field,of,the,input,tuple2,data,set,return,a,new,graph,where,the,edge,values,have,been,updated,according,to,the,result,of,the,edge,join,function;public,t,graph,k,vv,ev,join,with,edges,on,target,data,set,tuple2,k,t,input,data,set,final,edge,join,function,ev,t,edge,join,function,data,set,edge,k,ev,resulted,edges,this,get,edges,co,group,input,data,set,where,1,equal,to,0,with,new,apply,co,group,to,edge,values,on,either,source,or,target,k,ev,t,edge,join,function,return,new,graph,k,vv,ev,this,vertices,resulted,edges,this,context
Graph -> public <T> Graph<K, VV, EV> joinWithEdgesOnTarget(DataSet<Tuple2<K, T>> inputDataSet, 			final EdgeJoinFunction<EV, T> edgeJoinFunction);1446112342;Joins the edge DataSet with an input Tuple2 DataSet and applies a user-defined transformation_on the values of the matched records._The target ID of the edges input and the first field of the input DataSet are used as join keys.__@param inputDataSet the DataSet to join with._The first field of the Tuple2 is used as the join key_and the second field is passed as a parameter to the transformation function._@param edgeJoinFunction the transformation function to apply._The first parameter is the current edge value and the second parameter is the value_of the matched Tuple2 from the input DataSet._@param <T> the type of the second field of the input Tuple2 DataSet._@return a new Graph, where the edge values have been updated according to the_result of the edgeJoinFunction.;public <T> Graph<K, VV, EV> joinWithEdgesOnTarget(DataSet<Tuple2<K, T>> inputDataSet,_			final EdgeJoinFunction<EV, T> edgeJoinFunction) {__		DataSet<Edge<K, EV>> resultedEdges = this.getEdges()_				.coGroup(inputDataSet).where(1).equalTo(0)_				.with(new ApplyCoGroupToEdgeValuesOnEitherSourceOrTarget<K, EV, T>(edgeJoinFunction))___		return new Graph<K, VV, EV>(this.vertices, resultedEdges, this.context)__	};joins,the,edge,data,set,with,an,input,tuple2,data,set,and,applies,a,user,defined,transformation,on,the,values,of,the,matched,records,the,target,id,of,the,edges,input,and,the,first,field,of,the,input,data,set,are,used,as,join,keys,param,input,data,set,the,data,set,to,join,with,the,first,field,of,the,tuple2,is,used,as,the,join,key,and,the,second,field,is,passed,as,a,parameter,to,the,transformation,function,param,edge,join,function,the,transformation,function,to,apply,the,first,parameter,is,the,current,edge,value,and,the,second,parameter,is,the,value,of,the,matched,tuple2,from,the,input,data,set,param,t,the,type,of,the,second,field,of,the,input,tuple2,data,set,return,a,new,graph,where,the,edge,values,have,been,updated,according,to,the,result,of,the,edge,join,function;public,t,graph,k,vv,ev,join,with,edges,on,target,data,set,tuple2,k,t,input,data,set,final,edge,join,function,ev,t,edge,join,function,data,set,edge,k,ev,resulted,edges,this,get,edges,co,group,input,data,set,where,1,equal,to,0,with,new,apply,co,group,to,edge,values,on,either,source,or,target,k,ev,t,edge,join,function,return,new,graph,k,vv,ev,this,vertices,resulted,edges,this,context
Graph -> public <T> Graph<K, VV, EV> joinWithEdgesOnTarget(DataSet<Tuple2<K, T>> inputDataSet, 			final EdgeJoinFunction<EV, T> edgeJoinFunction);1447073368;Joins the edge DataSet with an input Tuple2 DataSet and applies a user-defined transformation_on the values of the matched records._The target ID of the edges input and the first field of the input DataSet are used as join keys.__@param inputDataSet the DataSet to join with._The first field of the Tuple2 is used as the join key_and the second field is passed as a parameter to the transformation function._@param edgeJoinFunction the transformation function to apply._The first parameter is the current edge value and the second parameter is the value_of the matched Tuple2 from the input DataSet._@param <T> the type of the second field of the input Tuple2 DataSet._@return a new Graph, where the edge values have been updated according to the_result of the edgeJoinFunction.;public <T> Graph<K, VV, EV> joinWithEdgesOnTarget(DataSet<Tuple2<K, T>> inputDataSet,_			final EdgeJoinFunction<EV, T> edgeJoinFunction) {__		DataSet<Edge<K, EV>> resultedEdges = this.getEdges()_				.coGroup(inputDataSet).where(1).equalTo(0)_				.with(new ApplyCoGroupToEdgeValuesOnEitherSourceOrTarget<K, EV, T>(edgeJoinFunction))___		return new Graph<K, VV, EV>(this.vertices, resultedEdges, this.context)__	};joins,the,edge,data,set,with,an,input,tuple2,data,set,and,applies,a,user,defined,transformation,on,the,values,of,the,matched,records,the,target,id,of,the,edges,input,and,the,first,field,of,the,input,data,set,are,used,as,join,keys,param,input,data,set,the,data,set,to,join,with,the,first,field,of,the,tuple2,is,used,as,the,join,key,and,the,second,field,is,passed,as,a,parameter,to,the,transformation,function,param,edge,join,function,the,transformation,function,to,apply,the,first,parameter,is,the,current,edge,value,and,the,second,parameter,is,the,value,of,the,matched,tuple2,from,the,input,data,set,param,t,the,type,of,the,second,field,of,the,input,tuple2,data,set,return,a,new,graph,where,the,edge,values,have,been,updated,according,to,the,result,of,the,edge,join,function;public,t,graph,k,vv,ev,join,with,edges,on,target,data,set,tuple2,k,t,input,data,set,final,edge,join,function,ev,t,edge,join,function,data,set,edge,k,ev,resulted,edges,this,get,edges,co,group,input,data,set,where,1,equal,to,0,with,new,apply,co,group,to,edge,values,on,either,source,or,target,k,ev,t,edge,join,function,return,new,graph,k,vv,ev,this,vertices,resulted,edges,this,context
Graph -> public <T> Graph<K, VV, EV> joinWithEdgesOnTarget(DataSet<Tuple2<K, T>> inputDataSet, 			final EdgeJoinFunction<EV, T> edgeJoinFunction);1454404649;Joins the edge DataSet with an input Tuple2 DataSet and applies a user-defined transformation_on the values of the matched records._The target ID of the edges input and the first field of the input DataSet are used as join keys.__@param inputDataSet the DataSet to join with._The first field of the Tuple2 is used as the join key_and the second field is passed as a parameter to the transformation function._@param edgeJoinFunction the transformation function to apply._The first parameter is the current edge value and the second parameter is the value_of the matched Tuple2 from the input DataSet._@param <T> the type of the second field of the input Tuple2 DataSet._@return a new Graph, where the edge values have been updated according to the_result of the edgeJoinFunction.;public <T> Graph<K, VV, EV> joinWithEdgesOnTarget(DataSet<Tuple2<K, T>> inputDataSet,_			final EdgeJoinFunction<EV, T> edgeJoinFunction) {__		DataSet<Edge<K, EV>> resultedEdges = this.getEdges()_				.coGroup(inputDataSet).where(1).equalTo(0)_				.with(new ApplyCoGroupToEdgeValuesOnEitherSourceOrTarget<K, EV, T>(edgeJoinFunction))___		return new Graph<K, VV, EV>(this.vertices, resultedEdges, this.context)__	};joins,the,edge,data,set,with,an,input,tuple2,data,set,and,applies,a,user,defined,transformation,on,the,values,of,the,matched,records,the,target,id,of,the,edges,input,and,the,first,field,of,the,input,data,set,are,used,as,join,keys,param,input,data,set,the,data,set,to,join,with,the,first,field,of,the,tuple2,is,used,as,the,join,key,and,the,second,field,is,passed,as,a,parameter,to,the,transformation,function,param,edge,join,function,the,transformation,function,to,apply,the,first,parameter,is,the,current,edge,value,and,the,second,parameter,is,the,value,of,the,matched,tuple2,from,the,input,data,set,param,t,the,type,of,the,second,field,of,the,input,tuple2,data,set,return,a,new,graph,where,the,edge,values,have,been,updated,according,to,the,result,of,the,edge,join,function;public,t,graph,k,vv,ev,join,with,edges,on,target,data,set,tuple2,k,t,input,data,set,final,edge,join,function,ev,t,edge,join,function,data,set,edge,k,ev,resulted,edges,this,get,edges,co,group,input,data,set,where,1,equal,to,0,with,new,apply,co,group,to,edge,values,on,either,source,or,target,k,ev,t,edge,join,function,return,new,graph,k,vv,ev,this,vertices,resulted,edges,this,context
Graph -> public <T> Graph<K, VV, EV> joinWithEdgesOnTarget(DataSet<Tuple2<K, T>> inputDataSet, 			final EdgeJoinFunction<EV, T> edgeJoinFunction);1458583829;Joins the edge DataSet with an input Tuple2 DataSet and applies a user-defined transformation_on the values of the matched records._The target ID of the edges input and the first field of the input DataSet are used as join keys.__@param inputDataSet the DataSet to join with._The first field of the Tuple2 is used as the join key_and the second field is passed as a parameter to the transformation function._@param edgeJoinFunction the transformation function to apply._The first parameter is the current edge value and the second parameter is the value_of the matched Tuple2 from the input DataSet._@param <T> the type of the second field of the input Tuple2 DataSet._@return a new Graph, where the edge values have been updated according to the_result of the edgeJoinFunction.;public <T> Graph<K, VV, EV> joinWithEdgesOnTarget(DataSet<Tuple2<K, T>> inputDataSet,_			final EdgeJoinFunction<EV, T> edgeJoinFunction) {__		DataSet<Edge<K, EV>> resultedEdges = this.getEdges()_				.coGroup(inputDataSet).where(1).equalTo(0)_				.with(new ApplyCoGroupToEdgeValuesOnEitherSourceOrTarget<K, EV, T>(edgeJoinFunction))___		return new Graph<K, VV, EV>(this.vertices, resultedEdges, this.context)__	};joins,the,edge,data,set,with,an,input,tuple2,data,set,and,applies,a,user,defined,transformation,on,the,values,of,the,matched,records,the,target,id,of,the,edges,input,and,the,first,field,of,the,input,data,set,are,used,as,join,keys,param,input,data,set,the,data,set,to,join,with,the,first,field,of,the,tuple2,is,used,as,the,join,key,and,the,second,field,is,passed,as,a,parameter,to,the,transformation,function,param,edge,join,function,the,transformation,function,to,apply,the,first,parameter,is,the,current,edge,value,and,the,second,parameter,is,the,value,of,the,matched,tuple2,from,the,input,data,set,param,t,the,type,of,the,second,field,of,the,input,tuple2,data,set,return,a,new,graph,where,the,edge,values,have,been,updated,according,to,the,result,of,the,edge,join,function;public,t,graph,k,vv,ev,join,with,edges,on,target,data,set,tuple2,k,t,input,data,set,final,edge,join,function,ev,t,edge,join,function,data,set,edge,k,ev,resulted,edges,this,get,edges,co,group,input,data,set,where,1,equal,to,0,with,new,apply,co,group,to,edge,values,on,either,source,or,target,k,ev,t,edge,join,function,return,new,graph,k,vv,ev,this,vertices,resulted,edges,this,context
Graph -> public <T> Graph<K, VV, EV> joinWithEdgesOnTarget(DataSet<Tuple2<K, T>> inputDataSet, 			final EdgeJoinFunction<EV, T> edgeJoinFunction);1458583829;Joins the edge DataSet with an input Tuple2 DataSet and applies a user-defined transformation_on the values of the matched records._The target ID of the edges input and the first field of the input DataSet are used as join keys.__@param inputDataSet the DataSet to join with._The first field of the Tuple2 is used as the join key_and the second field is passed as a parameter to the transformation function._@param edgeJoinFunction the transformation function to apply._The first parameter is the current edge value and the second parameter is the value_of the matched Tuple2 from the input DataSet._@param <T> the type of the second field of the input Tuple2 DataSet._@return a new Graph, where the edge values have been updated according to the_result of the edgeJoinFunction.;public <T> Graph<K, VV, EV> joinWithEdgesOnTarget(DataSet<Tuple2<K, T>> inputDataSet,_			final EdgeJoinFunction<EV, T> edgeJoinFunction) {__		DataSet<Edge<K, EV>> resultedEdges = this.getEdges()_				.coGroup(inputDataSet).where(1).equalTo(0)_				.with(new ApplyCoGroupToEdgeValuesOnEitherSourceOrTarget<K, EV, T>(edgeJoinFunction))___		return new Graph<K, VV, EV>(this.vertices, resultedEdges, this.context)__	};joins,the,edge,data,set,with,an,input,tuple2,data,set,and,applies,a,user,defined,transformation,on,the,values,of,the,matched,records,the,target,id,of,the,edges,input,and,the,first,field,of,the,input,data,set,are,used,as,join,keys,param,input,data,set,the,data,set,to,join,with,the,first,field,of,the,tuple2,is,used,as,the,join,key,and,the,second,field,is,passed,as,a,parameter,to,the,transformation,function,param,edge,join,function,the,transformation,function,to,apply,the,first,parameter,is,the,current,edge,value,and,the,second,parameter,is,the,value,of,the,matched,tuple2,from,the,input,data,set,param,t,the,type,of,the,second,field,of,the,input,tuple2,data,set,return,a,new,graph,where,the,edge,values,have,been,updated,according,to,the,result,of,the,edge,join,function;public,t,graph,k,vv,ev,join,with,edges,on,target,data,set,tuple2,k,t,input,data,set,final,edge,join,function,ev,t,edge,join,function,data,set,edge,k,ev,resulted,edges,this,get,edges,co,group,input,data,set,where,1,equal,to,0,with,new,apply,co,group,to,edge,values,on,either,source,or,target,k,ev,t,edge,join,function,return,new,graph,k,vv,ev,this,vertices,resulted,edges,this,context
Graph -> public <T> Graph<K, VV, EV> joinWithEdgesOnTarget(DataSet<Tuple2<K, T>> inputDataSet, 			final EdgeJoinFunction<EV, T> edgeJoinFunction);1462100316;Joins the edge DataSet with an input Tuple2 DataSet and applies a user-defined transformation_on the values of the matched records._The target ID of the edges input and the first field of the input DataSet are used as join keys.__@param inputDataSet the DataSet to join with._The first field of the Tuple2 is used as the join key_and the second field is passed as a parameter to the transformation function._@param edgeJoinFunction the transformation function to apply._The first parameter is the current edge value and the second parameter is the value_of the matched Tuple2 from the input DataSet._@param <T> the type of the second field of the input Tuple2 DataSet._@return a new Graph, where the edge values have been updated according to the_result of the edgeJoinFunction.;public <T> Graph<K, VV, EV> joinWithEdgesOnTarget(DataSet<Tuple2<K, T>> inputDataSet,_			final EdgeJoinFunction<EV, T> edgeJoinFunction) {__		DataSet<Edge<K, EV>> resultedEdges = this.getEdges()_				.coGroup(inputDataSet).where(1).equalTo(0)_				.with(new ApplyCoGroupToEdgeValuesOnEitherSourceOrTarget<K, EV, T>(edgeJoinFunction))___		return new Graph<K, VV, EV>(this.vertices, resultedEdges, this.context)__	};joins,the,edge,data,set,with,an,input,tuple2,data,set,and,applies,a,user,defined,transformation,on,the,values,of,the,matched,records,the,target,id,of,the,edges,input,and,the,first,field,of,the,input,data,set,are,used,as,join,keys,param,input,data,set,the,data,set,to,join,with,the,first,field,of,the,tuple2,is,used,as,the,join,key,and,the,second,field,is,passed,as,a,parameter,to,the,transformation,function,param,edge,join,function,the,transformation,function,to,apply,the,first,parameter,is,the,current,edge,value,and,the,second,parameter,is,the,value,of,the,matched,tuple2,from,the,input,data,set,param,t,the,type,of,the,second,field,of,the,input,tuple2,data,set,return,a,new,graph,where,the,edge,values,have,been,updated,according,to,the,result,of,the,edge,join,function;public,t,graph,k,vv,ev,join,with,edges,on,target,data,set,tuple2,k,t,input,data,set,final,edge,join,function,ev,t,edge,join,function,data,set,edge,k,ev,resulted,edges,this,get,edges,co,group,input,data,set,where,1,equal,to,0,with,new,apply,co,group,to,edge,values,on,either,source,or,target,k,ev,t,edge,join,function,return,new,graph,k,vv,ev,this,vertices,resulted,edges,this,context
Graph -> public <T> Graph<K, VV, EV> joinWithEdgesOnTarget(DataSet<Tuple2<K, T>> inputDataSet, 			final EdgeJoinFunction<EV, T> edgeJoinFunction);1462100316;Joins the edge DataSet with an input Tuple2 DataSet and applies a user-defined transformation_on the values of the matched records._The target ID of the edges input and the first field of the input DataSet are used as join keys.__@param inputDataSet the DataSet to join with._The first field of the Tuple2 is used as the join key_and the second field is passed as a parameter to the transformation function._@param edgeJoinFunction the transformation function to apply._The first parameter is the current edge value and the second parameter is the value_of the matched Tuple2 from the input DataSet._@param <T> the type of the second field of the input Tuple2 DataSet._@return a new Graph, where the edge values have been updated according to the_result of the edgeJoinFunction.;public <T> Graph<K, VV, EV> joinWithEdgesOnTarget(DataSet<Tuple2<K, T>> inputDataSet,_			final EdgeJoinFunction<EV, T> edgeJoinFunction) {__		DataSet<Edge<K, EV>> resultedEdges = this.getEdges()_				.coGroup(inputDataSet).where(1).equalTo(0)_				.with(new ApplyCoGroupToEdgeValuesOnEitherSourceOrTarget<K, EV, T>(edgeJoinFunction))___		return new Graph<K, VV, EV>(this.vertices, resultedEdges, this.context)__	};joins,the,edge,data,set,with,an,input,tuple2,data,set,and,applies,a,user,defined,transformation,on,the,values,of,the,matched,records,the,target,id,of,the,edges,input,and,the,first,field,of,the,input,data,set,are,used,as,join,keys,param,input,data,set,the,data,set,to,join,with,the,first,field,of,the,tuple2,is,used,as,the,join,key,and,the,second,field,is,passed,as,a,parameter,to,the,transformation,function,param,edge,join,function,the,transformation,function,to,apply,the,first,parameter,is,the,current,edge,value,and,the,second,parameter,is,the,value,of,the,matched,tuple2,from,the,input,data,set,param,t,the,type,of,the,second,field,of,the,input,tuple2,data,set,return,a,new,graph,where,the,edge,values,have,been,updated,according,to,the,result,of,the,edge,join,function;public,t,graph,k,vv,ev,join,with,edges,on,target,data,set,tuple2,k,t,input,data,set,final,edge,join,function,ev,t,edge,join,function,data,set,edge,k,ev,resulted,edges,this,get,edges,co,group,input,data,set,where,1,equal,to,0,with,new,apply,co,group,to,edge,values,on,either,source,or,target,k,ev,t,edge,join,function,return,new,graph,k,vv,ev,this,vertices,resulted,edges,this,context
Graph -> public <T> Graph<K, VV, EV> joinWithEdgesOnTarget(DataSet<Tuple2<K, T>> inputDataSet, 			final EdgeJoinFunction<EV, T> edgeJoinFunction);1462205213;Joins the edge DataSet with an input Tuple2 DataSet and applies a user-defined transformation_on the values of the matched records._The target ID of the edges input and the first field of the input DataSet are used as join keys.__@param inputDataSet the DataSet to join with._The first field of the Tuple2 is used as the join key_and the second field is passed as a parameter to the transformation function._@param edgeJoinFunction the transformation function to apply._The first parameter is the current edge value and the second parameter is the value_of the matched Tuple2 from the input DataSet._@param <T> the type of the second field of the input Tuple2 DataSet._@return a new Graph, where the edge values have been updated according to the_result of the edgeJoinFunction.;public <T> Graph<K, VV, EV> joinWithEdgesOnTarget(DataSet<Tuple2<K, T>> inputDataSet,_			final EdgeJoinFunction<EV, T> edgeJoinFunction) {__		DataSet<Edge<K, EV>> resultedEdges = this.getEdges()_				.coGroup(inputDataSet).where(1).equalTo(0)_				.with(new ApplyCoGroupToEdgeValuesOnEitherSourceOrTarget<K, EV, T>(edgeJoinFunction))___		return new Graph<K, VV, EV>(this.vertices, resultedEdges, this.context)__	};joins,the,edge,data,set,with,an,input,tuple2,data,set,and,applies,a,user,defined,transformation,on,the,values,of,the,matched,records,the,target,id,of,the,edges,input,and,the,first,field,of,the,input,data,set,are,used,as,join,keys,param,input,data,set,the,data,set,to,join,with,the,first,field,of,the,tuple2,is,used,as,the,join,key,and,the,second,field,is,passed,as,a,parameter,to,the,transformation,function,param,edge,join,function,the,transformation,function,to,apply,the,first,parameter,is,the,current,edge,value,and,the,second,parameter,is,the,value,of,the,matched,tuple2,from,the,input,data,set,param,t,the,type,of,the,second,field,of,the,input,tuple2,data,set,return,a,new,graph,where,the,edge,values,have,been,updated,according,to,the,result,of,the,edge,join,function;public,t,graph,k,vv,ev,join,with,edges,on,target,data,set,tuple2,k,t,input,data,set,final,edge,join,function,ev,t,edge,join,function,data,set,edge,k,ev,resulted,edges,this,get,edges,co,group,input,data,set,where,1,equal,to,0,with,new,apply,co,group,to,edge,values,on,either,source,or,target,k,ev,t,edge,join,function,return,new,graph,k,vv,ev,this,vertices,resulted,edges,this,context
Graph -> public <T> Graph<K, VV, EV> joinWithEdgesOnTarget(DataSet<Tuple2<K, T>> inputDataSet, 			final EdgeJoinFunction<EV, T> edgeJoinFunction);1462208859;Joins the edge DataSet with an input Tuple2 DataSet and applies a user-defined transformation_on the values of the matched records._The target ID of the edges input and the first field of the input DataSet are used as join keys.__@param inputDataSet the DataSet to join with._The first field of the Tuple2 is used as the join key_and the second field is passed as a parameter to the transformation function._@param edgeJoinFunction the transformation function to apply._The first parameter is the current edge value and the second parameter is the value_of the matched Tuple2 from the input DataSet._@param <T> the type of the second field of the input Tuple2 DataSet._@return a new Graph, where the edge values have been updated according to the_result of the edgeJoinFunction.;public <T> Graph<K, VV, EV> joinWithEdgesOnTarget(DataSet<Tuple2<K, T>> inputDataSet,_			final EdgeJoinFunction<EV, T> edgeJoinFunction) {__		DataSet<Edge<K, EV>> resultedEdges = this.getEdges()_				.coGroup(inputDataSet).where(1).equalTo(0)_				.with(new ApplyCoGroupToEdgeValuesOnEitherSourceOrTarget<K, EV, T>(edgeJoinFunction))___		return new Graph<K, VV, EV>(this.vertices, resultedEdges, this.context)__	};joins,the,edge,data,set,with,an,input,tuple2,data,set,and,applies,a,user,defined,transformation,on,the,values,of,the,matched,records,the,target,id,of,the,edges,input,and,the,first,field,of,the,input,data,set,are,used,as,join,keys,param,input,data,set,the,data,set,to,join,with,the,first,field,of,the,tuple2,is,used,as,the,join,key,and,the,second,field,is,passed,as,a,parameter,to,the,transformation,function,param,edge,join,function,the,transformation,function,to,apply,the,first,parameter,is,the,current,edge,value,and,the,second,parameter,is,the,value,of,the,matched,tuple2,from,the,input,data,set,param,t,the,type,of,the,second,field,of,the,input,tuple2,data,set,return,a,new,graph,where,the,edge,values,have,been,updated,according,to,the,result,of,the,edge,join,function;public,t,graph,k,vv,ev,join,with,edges,on,target,data,set,tuple2,k,t,input,data,set,final,edge,join,function,ev,t,edge,join,function,data,set,edge,k,ev,resulted,edges,this,get,edges,co,group,input,data,set,where,1,equal,to,0,with,new,apply,co,group,to,edge,values,on,either,source,or,target,k,ev,t,edge,join,function,return,new,graph,k,vv,ev,this,vertices,resulted,edges,this,context
Graph -> public <T> Graph<K, VV, EV> joinWithEdgesOnTarget(DataSet<Tuple2<K, T>> inputDataSet, 			final EdgeJoinFunction<EV, T> edgeJoinFunction);1462809297;Joins the edge DataSet with an input Tuple2 DataSet and applies a user-defined transformation_on the values of the matched records._The target ID of the edges input and the first field of the input DataSet are used as join keys.__@param inputDataSet the DataSet to join with._The first field of the Tuple2 is used as the join key_and the second field is passed as a parameter to the transformation function._@param edgeJoinFunction the transformation function to apply._The first parameter is the current edge value and the second parameter is the value_of the matched Tuple2 from the input DataSet._@param <T> the type of the second field of the input Tuple2 DataSet._@return a new Graph, where the edge values have been updated according to the_result of the edgeJoinFunction.;public <T> Graph<K, VV, EV> joinWithEdgesOnTarget(DataSet<Tuple2<K, T>> inputDataSet,_			final EdgeJoinFunction<EV, T> edgeJoinFunction) {__		DataSet<Edge<K, EV>> resultedEdges = this.getEdges()_				.coGroup(inputDataSet).where(1).equalTo(0)_				.with(new ApplyCoGroupToEdgeValuesOnEitherSourceOrTarget<K, EV, T>(edgeJoinFunction))___		return new Graph<K, VV, EV>(this.vertices, resultedEdges, this.context)__	};joins,the,edge,data,set,with,an,input,tuple2,data,set,and,applies,a,user,defined,transformation,on,the,values,of,the,matched,records,the,target,id,of,the,edges,input,and,the,first,field,of,the,input,data,set,are,used,as,join,keys,param,input,data,set,the,data,set,to,join,with,the,first,field,of,the,tuple2,is,used,as,the,join,key,and,the,second,field,is,passed,as,a,parameter,to,the,transformation,function,param,edge,join,function,the,transformation,function,to,apply,the,first,parameter,is,the,current,edge,value,and,the,second,parameter,is,the,value,of,the,matched,tuple2,from,the,input,data,set,param,t,the,type,of,the,second,field,of,the,input,tuple2,data,set,return,a,new,graph,where,the,edge,values,have,been,updated,according,to,the,result,of,the,edge,join,function;public,t,graph,k,vv,ev,join,with,edges,on,target,data,set,tuple2,k,t,input,data,set,final,edge,join,function,ev,t,edge,join,function,data,set,edge,k,ev,resulted,edges,this,get,edges,co,group,input,data,set,where,1,equal,to,0,with,new,apply,co,group,to,edge,values,on,either,source,or,target,k,ev,t,edge,join,function,return,new,graph,k,vv,ev,this,vertices,resulted,edges,this,context
Graph -> public <T> Graph<K, VV, EV> joinWithEdgesOnTarget(DataSet<Tuple2<K, T>> inputDataSet, 			final EdgeJoinFunction<EV, T> edgeJoinFunction);1465316775;Joins the edge DataSet with an input Tuple2 DataSet and applies a user-defined transformation_on the values of the matched records._The target ID of the edges input and the first field of the input DataSet are used as join keys.__@param inputDataSet the DataSet to join with._The first field of the Tuple2 is used as the join key_and the second field is passed as a parameter to the transformation function._@param edgeJoinFunction the transformation function to apply._The first parameter is the current edge value and the second parameter is the value_of the matched Tuple2 from the input DataSet._@param <T> the type of the second field of the input Tuple2 DataSet._@return a new Graph, where the edge values have been updated according to the_result of the edgeJoinFunction.;public <T> Graph<K, VV, EV> joinWithEdgesOnTarget(DataSet<Tuple2<K, T>> inputDataSet,_			final EdgeJoinFunction<EV, T> edgeJoinFunction) {__		DataSet<Edge<K, EV>> resultedEdges = this.getEdges()_				.coGroup(inputDataSet).where(1).equalTo(0)_				.with(new ApplyCoGroupToEdgeValuesOnEitherSourceOrTarget<K, EV, T>(edgeJoinFunction))___		return new Graph<K, VV, EV>(this.vertices, resultedEdges, this.context)__	};joins,the,edge,data,set,with,an,input,tuple2,data,set,and,applies,a,user,defined,transformation,on,the,values,of,the,matched,records,the,target,id,of,the,edges,input,and,the,first,field,of,the,input,data,set,are,used,as,join,keys,param,input,data,set,the,data,set,to,join,with,the,first,field,of,the,tuple2,is,used,as,the,join,key,and,the,second,field,is,passed,as,a,parameter,to,the,transformation,function,param,edge,join,function,the,transformation,function,to,apply,the,first,parameter,is,the,current,edge,value,and,the,second,parameter,is,the,value,of,the,matched,tuple2,from,the,input,data,set,param,t,the,type,of,the,second,field,of,the,input,tuple2,data,set,return,a,new,graph,where,the,edge,values,have,been,updated,according,to,the,result,of,the,edge,join,function;public,t,graph,k,vv,ev,join,with,edges,on,target,data,set,tuple2,k,t,input,data,set,final,edge,join,function,ev,t,edge,join,function,data,set,edge,k,ev,resulted,edges,this,get,edges,co,group,input,data,set,where,1,equal,to,0,with,new,apply,co,group,to,edge,values,on,either,source,or,target,k,ev,t,edge,join,function,return,new,graph,k,vv,ev,this,vertices,resulted,edges,this,context
Graph -> public <T> Graph<K, VV, EV> joinWithEdgesOnTarget(DataSet<Tuple2<K, T>> inputDataSet, 			final EdgeJoinFunction<EV, T> edgeJoinFunction);1466789678;Joins the edge DataSet with an input Tuple2 DataSet and applies a user-defined transformation_on the values of the matched records._The target ID of the edges input and the first field of the input DataSet are used as join keys.__@param inputDataSet the DataSet to join with._The first field of the Tuple2 is used as the join key_and the second field is passed as a parameter to the transformation function._@param edgeJoinFunction the transformation function to apply._The first parameter is the current edge value and the second parameter is the value_of the matched Tuple2 from the input DataSet._@param <T> the type of the second field of the input Tuple2 DataSet._@return a new Graph, where the edge values have been updated according to the_result of the edgeJoinFunction.;public <T> Graph<K, VV, EV> joinWithEdgesOnTarget(DataSet<Tuple2<K, T>> inputDataSet,_			final EdgeJoinFunction<EV, T> edgeJoinFunction) {__		DataSet<Edge<K, EV>> resultedEdges = this.getEdges()_				.coGroup(inputDataSet).where(1).equalTo(0)_				.with(new ApplyCoGroupToEdgeValuesOnEitherSourceOrTarget<K, EV, T>(edgeJoinFunction))___		return new Graph<K, VV, EV>(this.vertices, resultedEdges, this.context)__	};joins,the,edge,data,set,with,an,input,tuple2,data,set,and,applies,a,user,defined,transformation,on,the,values,of,the,matched,records,the,target,id,of,the,edges,input,and,the,first,field,of,the,input,data,set,are,used,as,join,keys,param,input,data,set,the,data,set,to,join,with,the,first,field,of,the,tuple2,is,used,as,the,join,key,and,the,second,field,is,passed,as,a,parameter,to,the,transformation,function,param,edge,join,function,the,transformation,function,to,apply,the,first,parameter,is,the,current,edge,value,and,the,second,parameter,is,the,value,of,the,matched,tuple2,from,the,input,data,set,param,t,the,type,of,the,second,field,of,the,input,tuple2,data,set,return,a,new,graph,where,the,edge,values,have,been,updated,according,to,the,result,of,the,edge,join,function;public,t,graph,k,vv,ev,join,with,edges,on,target,data,set,tuple2,k,t,input,data,set,final,edge,join,function,ev,t,edge,join,function,data,set,edge,k,ev,resulted,edges,this,get,edges,co,group,input,data,set,where,1,equal,to,0,with,new,apply,co,group,to,edge,values,on,either,source,or,target,k,ev,t,edge,join,function,return,new,graph,k,vv,ev,this,vertices,resulted,edges,this,context
Graph -> public <T> Graph<K, VV, EV> joinWithEdgesOnTarget(DataSet<Tuple2<K, T>> inputDataSet, 			final EdgeJoinFunction<EV, T> edgeJoinFunction);1467140656;Joins the edge DataSet with an input Tuple2 DataSet and applies a user-defined transformation_on the values of the matched records._The target ID of the edges input and the first field of the input DataSet are used as join keys.__@param inputDataSet the DataSet to join with._The first field of the Tuple2 is used as the join key_and the second field is passed as a parameter to the transformation function._@param edgeJoinFunction the transformation function to apply._The first parameter is the current edge value and the second parameter is the value_of the matched Tuple2 from the input DataSet._@param <T> the type of the second field of the input Tuple2 DataSet._@return a new Graph, where the edge values have been updated according to the_result of the edgeJoinFunction.;public <T> Graph<K, VV, EV> joinWithEdgesOnTarget(DataSet<Tuple2<K, T>> inputDataSet,_			final EdgeJoinFunction<EV, T> edgeJoinFunction) {__		DataSet<Edge<K, EV>> resultedEdges = this.getEdges()_				.coGroup(inputDataSet).where(1).equalTo(0)_				.with(new ApplyCoGroupToEdgeValuesOnEitherSourceOrTarget<K, EV, T>(edgeJoinFunction))___		return new Graph<K, VV, EV>(this.vertices, resultedEdges, this.context)__	};joins,the,edge,data,set,with,an,input,tuple2,data,set,and,applies,a,user,defined,transformation,on,the,values,of,the,matched,records,the,target,id,of,the,edges,input,and,the,first,field,of,the,input,data,set,are,used,as,join,keys,param,input,data,set,the,data,set,to,join,with,the,first,field,of,the,tuple2,is,used,as,the,join,key,and,the,second,field,is,passed,as,a,parameter,to,the,transformation,function,param,edge,join,function,the,transformation,function,to,apply,the,first,parameter,is,the,current,edge,value,and,the,second,parameter,is,the,value,of,the,matched,tuple2,from,the,input,data,set,param,t,the,type,of,the,second,field,of,the,input,tuple2,data,set,return,a,new,graph,where,the,edge,values,have,been,updated,according,to,the,result,of,the,edge,join,function;public,t,graph,k,vv,ev,join,with,edges,on,target,data,set,tuple2,k,t,input,data,set,final,edge,join,function,ev,t,edge,join,function,data,set,edge,k,ev,resulted,edges,this,get,edges,co,group,input,data,set,where,1,equal,to,0,with,new,apply,co,group,to,edge,values,on,either,source,or,target,k,ev,t,edge,join,function,return,new,graph,k,vv,ev,this,vertices,resulted,edges,this,context
Graph -> public <T> Graph<K, VV, EV> joinWithEdgesOnTarget(DataSet<Tuple2<K, T>> inputDataSet, 			final EdgeJoinFunction<EV, T> edgeJoinFunction);1467306272;Joins the edge DataSet with an input Tuple2 DataSet and applies a user-defined transformation_on the values of the matched records._The target ID of the edges input and the first field of the input DataSet are used as join keys.__@param inputDataSet the DataSet to join with._The first field of the Tuple2 is used as the join key_and the second field is passed as a parameter to the transformation function._@param edgeJoinFunction the transformation function to apply._The first parameter is the current edge value and the second parameter is the value_of the matched Tuple2 from the input DataSet._@param <T> the type of the second field of the input Tuple2 DataSet._@return a new Graph, where the edge values have been updated according to the_result of the edgeJoinFunction.;public <T> Graph<K, VV, EV> joinWithEdgesOnTarget(DataSet<Tuple2<K, T>> inputDataSet,_			final EdgeJoinFunction<EV, T> edgeJoinFunction) {__		DataSet<Edge<K, EV>> resultedEdges = this.getEdges()_				.coGroup(inputDataSet).where(1).equalTo(0)_				.with(new ApplyCoGroupToEdgeValuesOnEitherSourceOrTarget<K, EV, T>(edgeJoinFunction))___		return new Graph<K, VV, EV>(this.vertices, resultedEdges, this.context)__	};joins,the,edge,data,set,with,an,input,tuple2,data,set,and,applies,a,user,defined,transformation,on,the,values,of,the,matched,records,the,target,id,of,the,edges,input,and,the,first,field,of,the,input,data,set,are,used,as,join,keys,param,input,data,set,the,data,set,to,join,with,the,first,field,of,the,tuple2,is,used,as,the,join,key,and,the,second,field,is,passed,as,a,parameter,to,the,transformation,function,param,edge,join,function,the,transformation,function,to,apply,the,first,parameter,is,the,current,edge,value,and,the,second,parameter,is,the,value,of,the,matched,tuple2,from,the,input,data,set,param,t,the,type,of,the,second,field,of,the,input,tuple2,data,set,return,a,new,graph,where,the,edge,values,have,been,updated,according,to,the,result,of,the,edge,join,function;public,t,graph,k,vv,ev,join,with,edges,on,target,data,set,tuple2,k,t,input,data,set,final,edge,join,function,ev,t,edge,join,function,data,set,edge,k,ev,resulted,edges,this,get,edges,co,group,input,data,set,where,1,equal,to,0,with,new,apply,co,group,to,edge,values,on,either,source,or,target,k,ev,t,edge,join,function,return,new,graph,k,vv,ev,this,vertices,resulted,edges,this,context
Graph -> public <T> Graph<K, VV, EV> joinWithEdgesOnTarget(DataSet<Tuple2<K, T>> inputDataSet, 			final EdgeJoinFunction<EV, T> edgeJoinFunction);1470042815;Joins the edge DataSet with an input Tuple2 DataSet and applies a user-defined transformation_on the values of the matched records._The target ID of the edges input and the first field of the input DataSet are used as join keys.__@param inputDataSet the DataSet to join with._The first field of the Tuple2 is used as the join key_and the second field is passed as a parameter to the transformation function._@param edgeJoinFunction the transformation function to apply._The first parameter is the current edge value and the second parameter is the value_of the matched Tuple2 from the input DataSet._@param <T> the type of the second field of the input Tuple2 DataSet._@return a new Graph, where the edge values have been updated according to the_result of the edgeJoinFunction.;public <T> Graph<K, VV, EV> joinWithEdgesOnTarget(DataSet<Tuple2<K, T>> inputDataSet,_			final EdgeJoinFunction<EV, T> edgeJoinFunction) {__		DataSet<Edge<K, EV>> resultedEdges = this.getEdges()_				.coGroup(inputDataSet).where(1).equalTo(0)_				.with(new ApplyCoGroupToEdgeValuesOnEitherSourceOrTarget<K, EV, T>(edgeJoinFunction))___		return new Graph<K, VV, EV>(this.vertices, resultedEdges, this.context)__	};joins,the,edge,data,set,with,an,input,tuple2,data,set,and,applies,a,user,defined,transformation,on,the,values,of,the,matched,records,the,target,id,of,the,edges,input,and,the,first,field,of,the,input,data,set,are,used,as,join,keys,param,input,data,set,the,data,set,to,join,with,the,first,field,of,the,tuple2,is,used,as,the,join,key,and,the,second,field,is,passed,as,a,parameter,to,the,transformation,function,param,edge,join,function,the,transformation,function,to,apply,the,first,parameter,is,the,current,edge,value,and,the,second,parameter,is,the,value,of,the,matched,tuple2,from,the,input,data,set,param,t,the,type,of,the,second,field,of,the,input,tuple2,data,set,return,a,new,graph,where,the,edge,values,have,been,updated,according,to,the,result,of,the,edge,join,function;public,t,graph,k,vv,ev,join,with,edges,on,target,data,set,tuple2,k,t,input,data,set,final,edge,join,function,ev,t,edge,join,function,data,set,edge,k,ev,resulted,edges,this,get,edges,co,group,input,data,set,where,1,equal,to,0,with,new,apply,co,group,to,edge,values,on,either,source,or,target,k,ev,t,edge,join,function,return,new,graph,k,vv,ev,this,vertices,resulted,edges,this,context
Graph -> public <T> Graph<K, VV, EV> joinWithEdgesOnTarget(DataSet<Tuple2<K, T>> inputDataSet, 			final EdgeJoinFunction<EV, T> edgeJoinFunction);1475684776;Joins the edge DataSet with an input Tuple2 DataSet and applies a user-defined transformation_on the values of the matched records._The target ID of the edges input and the first field of the input DataSet are used as join keys.__@param inputDataSet the DataSet to join with._The first field of the Tuple2 is used as the join key_and the second field is passed as a parameter to the transformation function._@param edgeJoinFunction the transformation function to apply._The first parameter is the current edge value and the second parameter is the value_of the matched Tuple2 from the input DataSet._@param <T> the type of the second field of the input Tuple2 DataSet._@return a new Graph, where the edge values have been updated according to the_result of the edgeJoinFunction.;public <T> Graph<K, VV, EV> joinWithEdgesOnTarget(DataSet<Tuple2<K, T>> inputDataSet,_			final EdgeJoinFunction<EV, T> edgeJoinFunction) {__		DataSet<Edge<K, EV>> resultedEdges = this.getEdges()_				.coGroup(inputDataSet).where(1).equalTo(0)_				.with(new ApplyCoGroupToEdgeValuesOnEitherSourceOrTarget<K, EV, T>(edgeJoinFunction))___		return new Graph<>(this.vertices, resultedEdges, this.context)__	};joins,the,edge,data,set,with,an,input,tuple2,data,set,and,applies,a,user,defined,transformation,on,the,values,of,the,matched,records,the,target,id,of,the,edges,input,and,the,first,field,of,the,input,data,set,are,used,as,join,keys,param,input,data,set,the,data,set,to,join,with,the,first,field,of,the,tuple2,is,used,as,the,join,key,and,the,second,field,is,passed,as,a,parameter,to,the,transformation,function,param,edge,join,function,the,transformation,function,to,apply,the,first,parameter,is,the,current,edge,value,and,the,second,parameter,is,the,value,of,the,matched,tuple2,from,the,input,data,set,param,t,the,type,of,the,second,field,of,the,input,tuple2,data,set,return,a,new,graph,where,the,edge,values,have,been,updated,according,to,the,result,of,the,edge,join,function;public,t,graph,k,vv,ev,join,with,edges,on,target,data,set,tuple2,k,t,input,data,set,final,edge,join,function,ev,t,edge,join,function,data,set,edge,k,ev,resulted,edges,this,get,edges,co,group,input,data,set,where,1,equal,to,0,with,new,apply,co,group,to,edge,values,on,either,source,or,target,k,ev,t,edge,join,function,return,new,graph,this,vertices,resulted,edges,this,context
Graph -> public <T> Graph<K, VV, EV> joinWithEdgesOnTarget(DataSet<Tuple2<K, T>> inputDataSet, 			final EdgeJoinFunction<EV, T> edgeJoinFunction);1475685606;Joins the edge DataSet with an input Tuple2 DataSet and applies a user-defined transformation_on the values of the matched records._The target ID of the edges input and the first field of the input DataSet are used as join keys.__@param inputDataSet the DataSet to join with._The first field of the Tuple2 is used as the join key_and the second field is passed as a parameter to the transformation function._@param edgeJoinFunction the transformation function to apply._The first parameter is the current edge value and the second parameter is the value_of the matched Tuple2 from the input DataSet._@param <T> the type of the second field of the input Tuple2 DataSet._@return a new Graph, where the edge values have been updated according to the_result of the edgeJoinFunction.;public <T> Graph<K, VV, EV> joinWithEdgesOnTarget(DataSet<Tuple2<K, T>> inputDataSet,_			final EdgeJoinFunction<EV, T> edgeJoinFunction) {__		DataSet<Edge<K, EV>> resultedEdges = this.getEdges()_				.coGroup(inputDataSet).where(1).equalTo(0)_				.with(new ApplyCoGroupToEdgeValuesOnEitherSourceOrTarget<K, EV, T>(edgeJoinFunction))___		return new Graph<>(this.vertices, resultedEdges, this.context)__	};joins,the,edge,data,set,with,an,input,tuple2,data,set,and,applies,a,user,defined,transformation,on,the,values,of,the,matched,records,the,target,id,of,the,edges,input,and,the,first,field,of,the,input,data,set,are,used,as,join,keys,param,input,data,set,the,data,set,to,join,with,the,first,field,of,the,tuple2,is,used,as,the,join,key,and,the,second,field,is,passed,as,a,parameter,to,the,transformation,function,param,edge,join,function,the,transformation,function,to,apply,the,first,parameter,is,the,current,edge,value,and,the,second,parameter,is,the,value,of,the,matched,tuple2,from,the,input,data,set,param,t,the,type,of,the,second,field,of,the,input,tuple2,data,set,return,a,new,graph,where,the,edge,values,have,been,updated,according,to,the,result,of,the,edge,join,function;public,t,graph,k,vv,ev,join,with,edges,on,target,data,set,tuple2,k,t,input,data,set,final,edge,join,function,ev,t,edge,join,function,data,set,edge,k,ev,resulted,edges,this,get,edges,co,group,input,data,set,where,1,equal,to,0,with,new,apply,co,group,to,edge,values,on,either,source,or,target,k,ev,t,edge,join,function,return,new,graph,this,vertices,resulted,edges,this,context
Graph -> public <T> Graph<K, VV, EV> joinWithEdgesOnTarget(DataSet<Tuple2<K, T>> inputDataSet, 			final EdgeJoinFunction<EV, T> edgeJoinFunction);1481745825;Joins the edge DataSet with an input Tuple2 DataSet and applies a user-defined transformation_on the values of the matched records._The target ID of the edges input and the first field of the input DataSet are used as join keys.__@param inputDataSet the DataSet to join with._The first field of the Tuple2 is used as the join key_and the second field is passed as a parameter to the transformation function._@param edgeJoinFunction the transformation function to apply._The first parameter is the current edge value and the second parameter is the value_of the matched Tuple2 from the input DataSet._@param <T> the type of the second field of the input Tuple2 DataSet._@return a new Graph, where the edge values have been updated according to the_result of the edgeJoinFunction.;public <T> Graph<K, VV, EV> joinWithEdgesOnTarget(DataSet<Tuple2<K, T>> inputDataSet,_			final EdgeJoinFunction<EV, T> edgeJoinFunction) {__		DataSet<Edge<K, EV>> resultedEdges = this.getEdges()_				.coGroup(inputDataSet).where(1).equalTo(0)_				.with(new ApplyCoGroupToEdgeValuesOnEitherSourceOrTarget<K, EV, T>(edgeJoinFunction))_					.name("Join with edges on target")___		return new Graph<>(this.vertices, resultedEdges, this.context)__	};joins,the,edge,data,set,with,an,input,tuple2,data,set,and,applies,a,user,defined,transformation,on,the,values,of,the,matched,records,the,target,id,of,the,edges,input,and,the,first,field,of,the,input,data,set,are,used,as,join,keys,param,input,data,set,the,data,set,to,join,with,the,first,field,of,the,tuple2,is,used,as,the,join,key,and,the,second,field,is,passed,as,a,parameter,to,the,transformation,function,param,edge,join,function,the,transformation,function,to,apply,the,first,parameter,is,the,current,edge,value,and,the,second,parameter,is,the,value,of,the,matched,tuple2,from,the,input,data,set,param,t,the,type,of,the,second,field,of,the,input,tuple2,data,set,return,a,new,graph,where,the,edge,values,have,been,updated,according,to,the,result,of,the,edge,join,function;public,t,graph,k,vv,ev,join,with,edges,on,target,data,set,tuple2,k,t,input,data,set,final,edge,join,function,ev,t,edge,join,function,data,set,edge,k,ev,resulted,edges,this,get,edges,co,group,input,data,set,where,1,equal,to,0,with,new,apply,co,group,to,edge,values,on,either,source,or,target,k,ev,t,edge,join,function,name,join,with,edges,on,target,return,new,graph,this,vertices,resulted,edges,this,context
Graph -> public <T> Graph<K, VV, EV> joinWithEdgesOnTarget(DataSet<Tuple2<K, T>> inputDataSet, 			final EdgeJoinFunction<EV, T> edgeJoinFunction);1481881009;Joins the edge DataSet with an input Tuple2 DataSet and applies a user-defined transformation_on the values of the matched records._The target ID of the edges input and the first field of the input DataSet are used as join keys.__@param inputDataSet the DataSet to join with._The first field of the Tuple2 is used as the join key_and the second field is passed as a parameter to the transformation function._@param edgeJoinFunction the transformation function to apply._The first parameter is the current edge value and the second parameter is the value_of the matched Tuple2 from the input DataSet._@param <T> the type of the second field of the input Tuple2 DataSet._@return a new Graph, where the edge values have been updated according to the_result of the edgeJoinFunction.;public <T> Graph<K, VV, EV> joinWithEdgesOnTarget(DataSet<Tuple2<K, T>> inputDataSet,_			final EdgeJoinFunction<EV, T> edgeJoinFunction) {__		DataSet<Edge<K, EV>> resultedEdges = this.getEdges()_				.coGroup(inputDataSet).where(1).equalTo(0)_				.with(new ApplyCoGroupToEdgeValuesOnEitherSourceOrTarget<K, EV, T>(edgeJoinFunction))_					.name("Join with edges on target")___		return new Graph<>(this.vertices, resultedEdges, this.context)__	};joins,the,edge,data,set,with,an,input,tuple2,data,set,and,applies,a,user,defined,transformation,on,the,values,of,the,matched,records,the,target,id,of,the,edges,input,and,the,first,field,of,the,input,data,set,are,used,as,join,keys,param,input,data,set,the,data,set,to,join,with,the,first,field,of,the,tuple2,is,used,as,the,join,key,and,the,second,field,is,passed,as,a,parameter,to,the,transformation,function,param,edge,join,function,the,transformation,function,to,apply,the,first,parameter,is,the,current,edge,value,and,the,second,parameter,is,the,value,of,the,matched,tuple2,from,the,input,data,set,param,t,the,type,of,the,second,field,of,the,input,tuple2,data,set,return,a,new,graph,where,the,edge,values,have,been,updated,according,to,the,result,of,the,edge,join,function;public,t,graph,k,vv,ev,join,with,edges,on,target,data,set,tuple2,k,t,input,data,set,final,edge,join,function,ev,t,edge,join,function,data,set,edge,k,ev,resulted,edges,this,get,edges,co,group,input,data,set,where,1,equal,to,0,with,new,apply,co,group,to,edge,values,on,either,source,or,target,k,ev,t,edge,join,function,name,join,with,edges,on,target,return,new,graph,this,vertices,resulted,edges,this,context
Graph -> public <T> Graph<K, VV, EV> joinWithEdgesOnTarget(DataSet<Tuple2<K, T>> inputDataSet, 			final EdgeJoinFunction<EV, T> edgeJoinFunction);1484160227;Joins the edge DataSet with an input Tuple2 DataSet and applies a user-defined transformation_on the values of the matched records._The target ID of the edges input and the first field of the input DataSet are used as join keys.__@param inputDataSet the DataSet to join with._The first field of the Tuple2 is used as the join key_and the second field is passed as a parameter to the transformation function._@param edgeJoinFunction the transformation function to apply._The first parameter is the current edge value and the second parameter is the value_of the matched Tuple2 from the input DataSet._@param <T> the type of the second field of the input Tuple2 DataSet._@return a new Graph, where the edge values have been updated according to the_result of the edgeJoinFunction.;public <T> Graph<K, VV, EV> joinWithEdgesOnTarget(DataSet<Tuple2<K, T>> inputDataSet,_			final EdgeJoinFunction<EV, T> edgeJoinFunction) {__		DataSet<Edge<K, EV>> resultedEdges = this.getEdges()_				.coGroup(inputDataSet).where(1).equalTo(0)_				.with(new ApplyCoGroupToEdgeValuesOnEitherSourceOrTarget<K, EV, T>(edgeJoinFunction))_					.name("Join with edges on target")___		return new Graph<>(this.vertices, resultedEdges, this.context)__	};joins,the,edge,data,set,with,an,input,tuple2,data,set,and,applies,a,user,defined,transformation,on,the,values,of,the,matched,records,the,target,id,of,the,edges,input,and,the,first,field,of,the,input,data,set,are,used,as,join,keys,param,input,data,set,the,data,set,to,join,with,the,first,field,of,the,tuple2,is,used,as,the,join,key,and,the,second,field,is,passed,as,a,parameter,to,the,transformation,function,param,edge,join,function,the,transformation,function,to,apply,the,first,parameter,is,the,current,edge,value,and,the,second,parameter,is,the,value,of,the,matched,tuple2,from,the,input,data,set,param,t,the,type,of,the,second,field,of,the,input,tuple2,data,set,return,a,new,graph,where,the,edge,values,have,been,updated,according,to,the,result,of,the,edge,join,function;public,t,graph,k,vv,ev,join,with,edges,on,target,data,set,tuple2,k,t,input,data,set,final,edge,join,function,ev,t,edge,join,function,data,set,edge,k,ev,resulted,edges,this,get,edges,co,group,input,data,set,where,1,equal,to,0,with,new,apply,co,group,to,edge,values,on,either,source,or,target,k,ev,t,edge,join,function,name,join,with,edges,on,target,return,new,graph,this,vertices,resulted,edges,this,context
Graph -> public <T> Graph<K, VV, EV> joinWithEdgesOnTarget(DataSet<Tuple2<K, T>> inputDataSet, 			final EdgeJoinFunction<EV, T> edgeJoinFunction);1484685504;Joins the edge DataSet with an input Tuple2 DataSet and applies a user-defined transformation_on the values of the matched records._The target ID of the edges input and the first field of the input DataSet are used as join keys.__@param inputDataSet the DataSet to join with._The first field of the Tuple2 is used as the join key_and the second field is passed as a parameter to the transformation function._@param edgeJoinFunction the transformation function to apply._The first parameter is the current edge value and the second parameter is the value_of the matched Tuple2 from the input DataSet._@param <T> the type of the second field of the input Tuple2 DataSet._@return a new Graph, where the edge values have been updated according to the_result of the edgeJoinFunction.;public <T> Graph<K, VV, EV> joinWithEdgesOnTarget(DataSet<Tuple2<K, T>> inputDataSet,_			final EdgeJoinFunction<EV, T> edgeJoinFunction) {__		DataSet<Edge<K, EV>> resultedEdges = this.getEdges()_				.coGroup(inputDataSet).where(1).equalTo(0)_				.with(new ApplyCoGroupToEdgeValuesOnEitherSourceOrTarget<K, EV, T>(edgeJoinFunction))_					.name("Join with edges on target")___		return new Graph<>(this.vertices, resultedEdges, this.context)__	};joins,the,edge,data,set,with,an,input,tuple2,data,set,and,applies,a,user,defined,transformation,on,the,values,of,the,matched,records,the,target,id,of,the,edges,input,and,the,first,field,of,the,input,data,set,are,used,as,join,keys,param,input,data,set,the,data,set,to,join,with,the,first,field,of,the,tuple2,is,used,as,the,join,key,and,the,second,field,is,passed,as,a,parameter,to,the,transformation,function,param,edge,join,function,the,transformation,function,to,apply,the,first,parameter,is,the,current,edge,value,and,the,second,parameter,is,the,value,of,the,matched,tuple2,from,the,input,data,set,param,t,the,type,of,the,second,field,of,the,input,tuple2,data,set,return,a,new,graph,where,the,edge,values,have,been,updated,according,to,the,result,of,the,edge,join,function;public,t,graph,k,vv,ev,join,with,edges,on,target,data,set,tuple2,k,t,input,data,set,final,edge,join,function,ev,t,edge,join,function,data,set,edge,k,ev,resulted,edges,this,get,edges,co,group,input,data,set,where,1,equal,to,0,with,new,apply,co,group,to,edge,values,on,either,source,or,target,k,ev,t,edge,join,function,name,join,with,edges,on,target,return,new,graph,this,vertices,resulted,edges,this,context
Graph -> public <T> Graph<K, VV, EV> joinWithEdgesOnTarget(DataSet<Tuple2<K, T>> inputDataSet, 			final EdgeJoinFunction<EV, T> edgeJoinFunction);1489068942;Joins the edge DataSet with an input Tuple2 DataSet and applies a user-defined transformation_on the values of the matched records._The target ID of the edges input and the first field of the input DataSet are used as join keys.__@param inputDataSet the DataSet to join with._The first field of the Tuple2 is used as the join key_and the second field is passed as a parameter to the transformation function._@param edgeJoinFunction the transformation function to apply._The first parameter is the current edge value and the second parameter is the value_of the matched Tuple2 from the input DataSet._@param <T> the type of the second field of the input Tuple2 DataSet._@return a new Graph, where the edge values have been updated according to the_result of the edgeJoinFunction.;public <T> Graph<K, VV, EV> joinWithEdgesOnTarget(DataSet<Tuple2<K, T>> inputDataSet,_			final EdgeJoinFunction<EV, T> edgeJoinFunction) {__		DataSet<Edge<K, EV>> resultedEdges = this.getEdges()_				.coGroup(inputDataSet).where(1).equalTo(0)_				.with(new ApplyCoGroupToEdgeValuesOnEitherSourceOrTarget<K, EV, T>(edgeJoinFunction))_					.name("Join with edges on target")___		return new Graph<>(this.vertices, resultedEdges, this.context)__	};joins,the,edge,data,set,with,an,input,tuple2,data,set,and,applies,a,user,defined,transformation,on,the,values,of,the,matched,records,the,target,id,of,the,edges,input,and,the,first,field,of,the,input,data,set,are,used,as,join,keys,param,input,data,set,the,data,set,to,join,with,the,first,field,of,the,tuple2,is,used,as,the,join,key,and,the,second,field,is,passed,as,a,parameter,to,the,transformation,function,param,edge,join,function,the,transformation,function,to,apply,the,first,parameter,is,the,current,edge,value,and,the,second,parameter,is,the,value,of,the,matched,tuple2,from,the,input,data,set,param,t,the,type,of,the,second,field,of,the,input,tuple2,data,set,return,a,new,graph,where,the,edge,values,have,been,updated,according,to,the,result,of,the,edge,join,function;public,t,graph,k,vv,ev,join,with,edges,on,target,data,set,tuple2,k,t,input,data,set,final,edge,join,function,ev,t,edge,join,function,data,set,edge,k,ev,resulted,edges,this,get,edges,co,group,input,data,set,where,1,equal,to,0,with,new,apply,co,group,to,edge,values,on,either,source,or,target,k,ev,t,edge,join,function,name,join,with,edges,on,target,return,new,graph,this,vertices,resulted,edges,this,context
Graph -> public <T> Graph<K, VV, EV> joinWithEdgesOnTarget(DataSet<Tuple2<K, T>> inputDataSet, 			final EdgeJoinFunction<EV, T> edgeJoinFunction);1490973446;Joins the edge DataSet with an input Tuple2 DataSet and applies a user-defined transformation_on the values of the matched records._The target ID of the edges input and the first field of the input DataSet are used as join keys.__@param inputDataSet the DataSet to join with._The first field of the Tuple2 is used as the join key_and the second field is passed as a parameter to the transformation function._@param edgeJoinFunction the transformation function to apply._The first parameter is the current edge value and the second parameter is the value_of the matched Tuple2 from the input DataSet._@param <T> the type of the second field of the input Tuple2 DataSet._@return a new Graph, where the edge values have been updated according to the_result of the edgeJoinFunction.;public <T> Graph<K, VV, EV> joinWithEdgesOnTarget(DataSet<Tuple2<K, T>> inputDataSet,_			final EdgeJoinFunction<EV, T> edgeJoinFunction) {__		DataSet<Edge<K, EV>> resultedEdges = this.getEdges()_				.coGroup(inputDataSet).where(1).equalTo(0)_				.with(new ApplyCoGroupToEdgeValuesOnEitherSourceOrTarget<K, EV, T>(edgeJoinFunction))_					.name("Join with edges on target")___		return new Graph<>(this.vertices, resultedEdges, this.context)__	};joins,the,edge,data,set,with,an,input,tuple2,data,set,and,applies,a,user,defined,transformation,on,the,values,of,the,matched,records,the,target,id,of,the,edges,input,and,the,first,field,of,the,input,data,set,are,used,as,join,keys,param,input,data,set,the,data,set,to,join,with,the,first,field,of,the,tuple2,is,used,as,the,join,key,and,the,second,field,is,passed,as,a,parameter,to,the,transformation,function,param,edge,join,function,the,transformation,function,to,apply,the,first,parameter,is,the,current,edge,value,and,the,second,parameter,is,the,value,of,the,matched,tuple2,from,the,input,data,set,param,t,the,type,of,the,second,field,of,the,input,tuple2,data,set,return,a,new,graph,where,the,edge,values,have,been,updated,according,to,the,result,of,the,edge,join,function;public,t,graph,k,vv,ev,join,with,edges,on,target,data,set,tuple2,k,t,input,data,set,final,edge,join,function,ev,t,edge,join,function,data,set,edge,k,ev,resulted,edges,this,get,edges,co,group,input,data,set,where,1,equal,to,0,with,new,apply,co,group,to,edge,values,on,either,source,or,target,k,ev,t,edge,join,function,name,join,with,edges,on,target,return,new,graph,this,vertices,resulted,edges,this,context
Graph -> public <T> Graph<K, VV, EV> joinWithEdgesOnTarget(DataSet<Tuple2<K, T>> inputDataSet, 			final EdgeJoinFunction<EV, T> edgeJoinFunction);1495819075;Joins the edge DataSet with an input Tuple2 DataSet and applies a user-defined transformation_on the values of the matched records._The target ID of the edges input and the first field of the input DataSet are used as join keys.__@param inputDataSet the DataSet to join with._The first field of the Tuple2 is used as the join key_and the second field is passed as a parameter to the transformation function._@param edgeJoinFunction the transformation function to apply._The first parameter is the current edge value and the second parameter is the value_of the matched Tuple2 from the input DataSet._@param <T> the type of the second field of the input Tuple2 DataSet._@return a new Graph, where the edge values have been updated according to the_result of the edgeJoinFunction.;public <T> Graph<K, VV, EV> joinWithEdgesOnTarget(DataSet<Tuple2<K, T>> inputDataSet,_			final EdgeJoinFunction<EV, T> edgeJoinFunction) {__		DataSet<Edge<K, EV>> resultedEdges = this.getEdges()_				.coGroup(inputDataSet).where(1).equalTo(0)_				.with(new ApplyCoGroupToEdgeValuesOnEitherSourceOrTarget<K, EV, T>(edgeJoinFunction))_					.name("Join with edges on target")___		return new Graph<>(this.vertices, resultedEdges, this.context)__	};joins,the,edge,data,set,with,an,input,tuple2,data,set,and,applies,a,user,defined,transformation,on,the,values,of,the,matched,records,the,target,id,of,the,edges,input,and,the,first,field,of,the,input,data,set,are,used,as,join,keys,param,input,data,set,the,data,set,to,join,with,the,first,field,of,the,tuple2,is,used,as,the,join,key,and,the,second,field,is,passed,as,a,parameter,to,the,transformation,function,param,edge,join,function,the,transformation,function,to,apply,the,first,parameter,is,the,current,edge,value,and,the,second,parameter,is,the,value,of,the,matched,tuple2,from,the,input,data,set,param,t,the,type,of,the,second,field,of,the,input,tuple2,data,set,return,a,new,graph,where,the,edge,values,have,been,updated,according,to,the,result,of,the,edge,join,function;public,t,graph,k,vv,ev,join,with,edges,on,target,data,set,tuple2,k,t,input,data,set,final,edge,join,function,ev,t,edge,join,function,data,set,edge,k,ev,resulted,edges,this,get,edges,co,group,input,data,set,where,1,equal,to,0,with,new,apply,co,group,to,edge,values,on,either,source,or,target,k,ev,t,edge,join,function,name,join,with,edges,on,target,return,new,graph,this,vertices,resulted,edges,this,context
Graph -> public <T> Graph<K, VV, EV> joinWithEdgesOnTarget(DataSet<Tuple2<K, T>> inputDataSet, 			final EdgeJoinFunction<EV, T> edgeJoinFunction);1502111816;Joins the edge DataSet with an input Tuple2 DataSet and applies a user-defined transformation_on the values of the matched records._The target ID of the edges input and the first field of the input DataSet are used as join keys.__@param inputDataSet the DataSet to join with._The first field of the Tuple2 is used as the join key_and the second field is passed as a parameter to the transformation function._@param edgeJoinFunction the transformation function to apply._The first parameter is the current edge value and the second parameter is the value_of the matched Tuple2 from the input DataSet._@param <T> the type of the second field of the input Tuple2 DataSet._@return a new Graph, where the edge values have been updated according to the_result of the edgeJoinFunction.;public <T> Graph<K, VV, EV> joinWithEdgesOnTarget(DataSet<Tuple2<K, T>> inputDataSet,_			final EdgeJoinFunction<EV, T> edgeJoinFunction) {__		DataSet<Edge<K, EV>> resultedEdges = this.getEdges()_				.coGroup(inputDataSet).where(1).equalTo(0)_				.with(new ApplyCoGroupToEdgeValuesOnEitherSourceOrTarget<>(edgeJoinFunction))_					.name("Join with edges on target")___		return new Graph<>(this.vertices, resultedEdges, this.context)__	};joins,the,edge,data,set,with,an,input,tuple2,data,set,and,applies,a,user,defined,transformation,on,the,values,of,the,matched,records,the,target,id,of,the,edges,input,and,the,first,field,of,the,input,data,set,are,used,as,join,keys,param,input,data,set,the,data,set,to,join,with,the,first,field,of,the,tuple2,is,used,as,the,join,key,and,the,second,field,is,passed,as,a,parameter,to,the,transformation,function,param,edge,join,function,the,transformation,function,to,apply,the,first,parameter,is,the,current,edge,value,and,the,second,parameter,is,the,value,of,the,matched,tuple2,from,the,input,data,set,param,t,the,type,of,the,second,field,of,the,input,tuple2,data,set,return,a,new,graph,where,the,edge,values,have,been,updated,according,to,the,result,of,the,edge,join,function;public,t,graph,k,vv,ev,join,with,edges,on,target,data,set,tuple2,k,t,input,data,set,final,edge,join,function,ev,t,edge,join,function,data,set,edge,k,ev,resulted,edges,this,get,edges,co,group,input,data,set,where,1,equal,to,0,with,new,apply,co,group,to,edge,values,on,either,source,or,target,edge,join,function,name,join,with,edges,on,target,return,new,graph,this,vertices,resulted,edges,this,context
Graph -> public <T> DataSet<T> groupReduceOnNeighbors(NeighborsFunctionWithVertexValue<K, VV, EV, T> neighborsFunction, 			EdgeDirection direction) throws IllegalArgumentException;1445261977;Groups by vertex and computes a GroupReduce transformation over the neighbors (both edges and vertices)_of each vertex. The neighborsFunction applied on the neighbors only has access to both the vertex id_and the vertex value of the grouping vertex.__For each vertex, the neighborsFunction can iterate over all neighbors of this vertex_with the specified direction, and emit any number of output elements, including none.__@param neighborsFunction the group reduce function to apply to the neighboring edges and vertices_of each vertex._@param direction the edge direction (in-, out-, all-)._@param <T> the output type_@return a DataSet containing elements of type T_@throws IllegalArgumentException;public <T> DataSet<T> groupReduceOnNeighbors(NeighborsFunctionWithVertexValue<K, VV, EV, T> neighborsFunction,_			EdgeDirection direction) throws IllegalArgumentException {_		switch (direction) {_		case IN:_			_			DataSet<Tuple2<Edge<K, EV>, Vertex<K, VV>>> edgesWithSources = edges_					.join(this.vertices).where(0).equalTo(0)__			return vertices.coGroup(edgesWithSources)_					.where(0).equalTo("f0.f1")_					.with(new ApplyNeighborCoGroupFunction<K, VV, EV, T>(neighborsFunction))__		case OUT:_			_			DataSet<Tuple2<Edge<K, EV>, Vertex<K, VV>>> edgesWithTargets = edges_					.join(this.vertices).where(1).equalTo(0)__			return vertices.coGroup(edgesWithTargets)_					.where(0).equalTo("f0.f0")_					.with(new ApplyNeighborCoGroupFunction<K, VV, EV, T>(neighborsFunction))__		case ALL:_			_			DataSet<Tuple3<K, Edge<K, EV>, Vertex<K, VV>>> edgesWithNeighbors = edges_					.flatMap(new EmitOneEdgeWithNeighborPerNode<K, EV>())_					.join(this.vertices).where(1).equalTo(0)_					.with(new ProjectEdgeWithNeighbor<K, VV, EV>())___			return vertices.coGroup(edgesWithNeighbors)_					.where(0).equalTo(0)_					.with(new ApplyCoGroupFunctionOnAllNeighbors<K, VV, EV, T>(neighborsFunction))__		default:_			throw new IllegalArgumentException("Illegal edge direction")__		}_	};groups,by,vertex,and,computes,a,group,reduce,transformation,over,the,neighbors,both,edges,and,vertices,of,each,vertex,the,neighbors,function,applied,on,the,neighbors,only,has,access,to,both,the,vertex,id,and,the,vertex,value,of,the,grouping,vertex,for,each,vertex,the,neighbors,function,can,iterate,over,all,neighbors,of,this,vertex,with,the,specified,direction,and,emit,any,number,of,output,elements,including,none,param,neighbors,function,the,group,reduce,function,to,apply,to,the,neighboring,edges,and,vertices,of,each,vertex,param,direction,the,edge,direction,in,out,all,param,t,the,output,type,return,a,data,set,containing,elements,of,type,t,throws,illegal,argument,exception;public,t,data,set,t,group,reduce,on,neighbors,neighbors,function,with,vertex,value,k,vv,ev,t,neighbors,function,edge,direction,direction,throws,illegal,argument,exception,switch,direction,case,in,data,set,tuple2,edge,k,ev,vertex,k,vv,edges,with,sources,edges,join,this,vertices,where,0,equal,to,0,return,vertices,co,group,edges,with,sources,where,0,equal,to,f0,f1,with,new,apply,neighbor,co,group,function,k,vv,ev,t,neighbors,function,case,out,data,set,tuple2,edge,k,ev,vertex,k,vv,edges,with,targets,edges,join,this,vertices,where,1,equal,to,0,return,vertices,co,group,edges,with,targets,where,0,equal,to,f0,f0,with,new,apply,neighbor,co,group,function,k,vv,ev,t,neighbors,function,case,all,data,set,tuple3,k,edge,k,ev,vertex,k,vv,edges,with,neighbors,edges,flat,map,new,emit,one,edge,with,neighbor,per,node,k,ev,join,this,vertices,where,1,equal,to,0,with,new,project,edge,with,neighbor,k,vv,ev,return,vertices,co,group,edges,with,neighbors,where,0,equal,to,0,with,new,apply,co,group,function,on,all,neighbors,k,vv,ev,t,neighbors,function,default,throw,new,illegal,argument,exception,illegal,edge,direction
Graph -> public <T> DataSet<T> groupReduceOnNeighbors(NeighborsFunctionWithVertexValue<K, VV, EV, T> neighborsFunction, 			EdgeDirection direction) throws IllegalArgumentException;1445854323;Groups by vertex and computes a GroupReduce transformation over the neighbors (both edges and vertices)_of each vertex. The neighborsFunction applied on the neighbors only has access to both the vertex id_and the vertex value of the grouping vertex.__For each vertex, the neighborsFunction can iterate over all neighbors of this vertex_with the specified direction, and emit any number of output elements, including none.__@param neighborsFunction the group reduce function to apply to the neighboring edges and vertices_of each vertex._@param direction the edge direction (in-, out-, all-)._@param <T> the output type_@return a DataSet containing elements of type T_@throws IllegalArgumentException;public <T> DataSet<T> groupReduceOnNeighbors(NeighborsFunctionWithVertexValue<K, VV, EV, T> neighborsFunction,_			EdgeDirection direction) throws IllegalArgumentException {_		switch (direction) {_		case IN:_			_			DataSet<Tuple2<Edge<K, EV>, Vertex<K, VV>>> edgesWithSources = edges_					.join(this.vertices).where(0).equalTo(0)__			return vertices.coGroup(edgesWithSources)_					.where(0).equalTo("f0.f1")_					.with(new ApplyNeighborCoGroupFunction<K, VV, EV, T>(neighborsFunction))__		case OUT:_			_			DataSet<Tuple2<Edge<K, EV>, Vertex<K, VV>>> edgesWithTargets = edges_					.join(this.vertices).where(1).equalTo(0)__			return vertices.coGroup(edgesWithTargets)_					.where(0).equalTo("f0.f0")_					.with(new ApplyNeighborCoGroupFunction<K, VV, EV, T>(neighborsFunction))__		case ALL:_			_			DataSet<Tuple3<K, Edge<K, EV>, Vertex<K, VV>>> edgesWithNeighbors = edges_					.flatMap(new EmitOneEdgeWithNeighborPerNode<K, EV>())_					.join(this.vertices).where(1).equalTo(0)_					.with(new ProjectEdgeWithNeighbor<K, VV, EV>())___			return vertices.coGroup(edgesWithNeighbors)_					.where(0).equalTo(0)_					.with(new ApplyCoGroupFunctionOnAllNeighbors<K, VV, EV, T>(neighborsFunction))__		default:_			throw new IllegalArgumentException("Illegal edge direction")__		}_	};groups,by,vertex,and,computes,a,group,reduce,transformation,over,the,neighbors,both,edges,and,vertices,of,each,vertex,the,neighbors,function,applied,on,the,neighbors,only,has,access,to,both,the,vertex,id,and,the,vertex,value,of,the,grouping,vertex,for,each,vertex,the,neighbors,function,can,iterate,over,all,neighbors,of,this,vertex,with,the,specified,direction,and,emit,any,number,of,output,elements,including,none,param,neighbors,function,the,group,reduce,function,to,apply,to,the,neighboring,edges,and,vertices,of,each,vertex,param,direction,the,edge,direction,in,out,all,param,t,the,output,type,return,a,data,set,containing,elements,of,type,t,throws,illegal,argument,exception;public,t,data,set,t,group,reduce,on,neighbors,neighbors,function,with,vertex,value,k,vv,ev,t,neighbors,function,edge,direction,direction,throws,illegal,argument,exception,switch,direction,case,in,data,set,tuple2,edge,k,ev,vertex,k,vv,edges,with,sources,edges,join,this,vertices,where,0,equal,to,0,return,vertices,co,group,edges,with,sources,where,0,equal,to,f0,f1,with,new,apply,neighbor,co,group,function,k,vv,ev,t,neighbors,function,case,out,data,set,tuple2,edge,k,ev,vertex,k,vv,edges,with,targets,edges,join,this,vertices,where,1,equal,to,0,return,vertices,co,group,edges,with,targets,where,0,equal,to,f0,f0,with,new,apply,neighbor,co,group,function,k,vv,ev,t,neighbors,function,case,all,data,set,tuple3,k,edge,k,ev,vertex,k,vv,edges,with,neighbors,edges,flat,map,new,emit,one,edge,with,neighbor,per,node,k,ev,join,this,vertices,where,1,equal,to,0,with,new,project,edge,with,neighbor,k,vv,ev,return,vertices,co,group,edges,with,neighbors,where,0,equal,to,0,with,new,apply,co,group,function,on,all,neighbors,k,vv,ev,t,neighbors,function,default,throw,new,illegal,argument,exception,illegal,edge,direction
Graph -> public <T> DataSet<T> groupReduceOnNeighbors(NeighborsFunctionWithVertexValue<K, VV, EV, T> neighborsFunction, 			EdgeDirection direction) throws IllegalArgumentException;1446112342;Groups by vertex and computes a GroupReduce transformation over the neighbors (both edges and vertices)_of each vertex. The neighborsFunction applied on the neighbors only has access to both the vertex id_and the vertex value of the grouping vertex.__For each vertex, the neighborsFunction can iterate over all neighbors of this vertex_with the specified direction, and emit any number of output elements, including none.__@param neighborsFunction the group reduce function to apply to the neighboring edges and vertices_of each vertex._@param direction the edge direction (in-, out-, all-)._@param <T> the output type_@return a DataSet containing elements of type T_@throws IllegalArgumentException;public <T> DataSet<T> groupReduceOnNeighbors(NeighborsFunctionWithVertexValue<K, VV, EV, T> neighborsFunction,_			EdgeDirection direction) throws IllegalArgumentException {_		switch (direction) {_		case IN:_			_			DataSet<Tuple2<Edge<K, EV>, Vertex<K, VV>>> edgesWithSources = edges_					.join(this.vertices).where(0).equalTo(0)__			return vertices.coGroup(edgesWithSources)_					.where(0).equalTo("f0.f1")_					.with(new ApplyNeighborCoGroupFunction<K, VV, EV, T>(neighborsFunction))__		case OUT:_			_			DataSet<Tuple2<Edge<K, EV>, Vertex<K, VV>>> edgesWithTargets = edges_					.join(this.vertices).where(1).equalTo(0)__			return vertices.coGroup(edgesWithTargets)_					.where(0).equalTo("f0.f0")_					.with(new ApplyNeighborCoGroupFunction<K, VV, EV, T>(neighborsFunction))__		case ALL:_			_			DataSet<Tuple3<K, Edge<K, EV>, Vertex<K, VV>>> edgesWithNeighbors = edges_					.flatMap(new EmitOneEdgeWithNeighborPerNode<K, EV>())_					.join(this.vertices).where(1).equalTo(0)_					.with(new ProjectEdgeWithNeighbor<K, VV, EV>())___			return vertices.coGroup(edgesWithNeighbors)_					.where(0).equalTo(0)_					.with(new ApplyCoGroupFunctionOnAllNeighbors<K, VV, EV, T>(neighborsFunction))__		default:_			throw new IllegalArgumentException("Illegal edge direction")__		}_	};groups,by,vertex,and,computes,a,group,reduce,transformation,over,the,neighbors,both,edges,and,vertices,of,each,vertex,the,neighbors,function,applied,on,the,neighbors,only,has,access,to,both,the,vertex,id,and,the,vertex,value,of,the,grouping,vertex,for,each,vertex,the,neighbors,function,can,iterate,over,all,neighbors,of,this,vertex,with,the,specified,direction,and,emit,any,number,of,output,elements,including,none,param,neighbors,function,the,group,reduce,function,to,apply,to,the,neighboring,edges,and,vertices,of,each,vertex,param,direction,the,edge,direction,in,out,all,param,t,the,output,type,return,a,data,set,containing,elements,of,type,t,throws,illegal,argument,exception;public,t,data,set,t,group,reduce,on,neighbors,neighbors,function,with,vertex,value,k,vv,ev,t,neighbors,function,edge,direction,direction,throws,illegal,argument,exception,switch,direction,case,in,data,set,tuple2,edge,k,ev,vertex,k,vv,edges,with,sources,edges,join,this,vertices,where,0,equal,to,0,return,vertices,co,group,edges,with,sources,where,0,equal,to,f0,f1,with,new,apply,neighbor,co,group,function,k,vv,ev,t,neighbors,function,case,out,data,set,tuple2,edge,k,ev,vertex,k,vv,edges,with,targets,edges,join,this,vertices,where,1,equal,to,0,return,vertices,co,group,edges,with,targets,where,0,equal,to,f0,f0,with,new,apply,neighbor,co,group,function,k,vv,ev,t,neighbors,function,case,all,data,set,tuple3,k,edge,k,ev,vertex,k,vv,edges,with,neighbors,edges,flat,map,new,emit,one,edge,with,neighbor,per,node,k,ev,join,this,vertices,where,1,equal,to,0,with,new,project,edge,with,neighbor,k,vv,ev,return,vertices,co,group,edges,with,neighbors,where,0,equal,to,0,with,new,apply,co,group,function,on,all,neighbors,k,vv,ev,t,neighbors,function,default,throw,new,illegal,argument,exception,illegal,edge,direction
Graph -> public <T> DataSet<T> groupReduceOnNeighbors(NeighborsFunctionWithVertexValue<K, VV, EV, T> neighborsFunction, 			EdgeDirection direction) throws IllegalArgumentException;1447073368;Groups by vertex and computes a GroupReduce transformation over the neighbors (both edges and vertices)_of each vertex. The neighborsFunction applied on the neighbors only has access to both the vertex id_and the vertex value of the grouping vertex.__For each vertex, the neighborsFunction can iterate over all neighbors of this vertex_with the specified direction, and emit any number of output elements, including none.__@param neighborsFunction the group reduce function to apply to the neighboring edges and vertices_of each vertex._@param direction the edge direction (in-, out-, all-)._@param <T> the output type_@return a DataSet containing elements of type T_@throws IllegalArgumentException;public <T> DataSet<T> groupReduceOnNeighbors(NeighborsFunctionWithVertexValue<K, VV, EV, T> neighborsFunction,_			EdgeDirection direction) throws IllegalArgumentException {_		switch (direction) {_		case IN:_			_			DataSet<Tuple2<Edge<K, EV>, Vertex<K, VV>>> edgesWithSources = edges_					.join(this.vertices).where(0).equalTo(0)__			return vertices.coGroup(edgesWithSources)_					.where(0).equalTo("f0.f1")_					.with(new ApplyNeighborCoGroupFunction<K, VV, EV, T>(neighborsFunction))__		case OUT:_			_			DataSet<Tuple2<Edge<K, EV>, Vertex<K, VV>>> edgesWithTargets = edges_					.join(this.vertices).where(1).equalTo(0)__			return vertices.coGroup(edgesWithTargets)_					.where(0).equalTo("f0.f0")_					.with(new ApplyNeighborCoGroupFunction<K, VV, EV, T>(neighborsFunction))__		case ALL:_			_			DataSet<Tuple3<K, Edge<K, EV>, Vertex<K, VV>>> edgesWithNeighbors = edges_					.flatMap(new EmitOneEdgeWithNeighborPerNode<K, EV>())_					.join(this.vertices).where(1).equalTo(0)_					.with(new ProjectEdgeWithNeighbor<K, VV, EV>())___			return vertices.coGroup(edgesWithNeighbors)_					.where(0).equalTo(0)_					.with(new ApplyCoGroupFunctionOnAllNeighbors<K, VV, EV, T>(neighborsFunction))__		default:_			throw new IllegalArgumentException("Illegal edge direction")__		}_	};groups,by,vertex,and,computes,a,group,reduce,transformation,over,the,neighbors,both,edges,and,vertices,of,each,vertex,the,neighbors,function,applied,on,the,neighbors,only,has,access,to,both,the,vertex,id,and,the,vertex,value,of,the,grouping,vertex,for,each,vertex,the,neighbors,function,can,iterate,over,all,neighbors,of,this,vertex,with,the,specified,direction,and,emit,any,number,of,output,elements,including,none,param,neighbors,function,the,group,reduce,function,to,apply,to,the,neighboring,edges,and,vertices,of,each,vertex,param,direction,the,edge,direction,in,out,all,param,t,the,output,type,return,a,data,set,containing,elements,of,type,t,throws,illegal,argument,exception;public,t,data,set,t,group,reduce,on,neighbors,neighbors,function,with,vertex,value,k,vv,ev,t,neighbors,function,edge,direction,direction,throws,illegal,argument,exception,switch,direction,case,in,data,set,tuple2,edge,k,ev,vertex,k,vv,edges,with,sources,edges,join,this,vertices,where,0,equal,to,0,return,vertices,co,group,edges,with,sources,where,0,equal,to,f0,f1,with,new,apply,neighbor,co,group,function,k,vv,ev,t,neighbors,function,case,out,data,set,tuple2,edge,k,ev,vertex,k,vv,edges,with,targets,edges,join,this,vertices,where,1,equal,to,0,return,vertices,co,group,edges,with,targets,where,0,equal,to,f0,f0,with,new,apply,neighbor,co,group,function,k,vv,ev,t,neighbors,function,case,all,data,set,tuple3,k,edge,k,ev,vertex,k,vv,edges,with,neighbors,edges,flat,map,new,emit,one,edge,with,neighbor,per,node,k,ev,join,this,vertices,where,1,equal,to,0,with,new,project,edge,with,neighbor,k,vv,ev,return,vertices,co,group,edges,with,neighbors,where,0,equal,to,0,with,new,apply,co,group,function,on,all,neighbors,k,vv,ev,t,neighbors,function,default,throw,new,illegal,argument,exception,illegal,edge,direction
Graph -> public <T> DataSet<T> groupReduceOnNeighbors(NeighborsFunctionWithVertexValue<K, VV, EV, T> neighborsFunction, 			EdgeDirection direction) throws IllegalArgumentException;1454404649;Groups by vertex and computes a GroupReduce transformation over the neighbors (both edges and vertices)_of each vertex. The neighborsFunction applied on the neighbors only has access to both the vertex id_and the vertex value of the grouping vertex.__For each vertex, the neighborsFunction can iterate over all neighbors of this vertex_with the specified direction, and emit any number of output elements, including none.__@param neighborsFunction the group reduce function to apply to the neighboring edges and vertices_of each vertex._@param direction the edge direction (in-, out-, all-)._@param <T> the output type_@return a DataSet containing elements of type T_@throws IllegalArgumentException;public <T> DataSet<T> groupReduceOnNeighbors(NeighborsFunctionWithVertexValue<K, VV, EV, T> neighborsFunction,_			EdgeDirection direction) throws IllegalArgumentException {_		switch (direction) {_		case IN:_			_			DataSet<Tuple2<Edge<K, EV>, Vertex<K, VV>>> edgesWithSources = edges_					.join(this.vertices).where(0).equalTo(0)__			return vertices.coGroup(edgesWithSources)_					.where(0).equalTo("f0.f1")_					.with(new ApplyNeighborCoGroupFunction<K, VV, EV, T>(neighborsFunction))__		case OUT:_			_			DataSet<Tuple2<Edge<K, EV>, Vertex<K, VV>>> edgesWithTargets = edges_					.join(this.vertices).where(1).equalTo(0)__			return vertices.coGroup(edgesWithTargets)_					.where(0).equalTo("f0.f0")_					.with(new ApplyNeighborCoGroupFunction<K, VV, EV, T>(neighborsFunction))__		case ALL:_			_			DataSet<Tuple3<K, Edge<K, EV>, Vertex<K, VV>>> edgesWithNeighbors = edges_					.flatMap(new EmitOneEdgeWithNeighborPerNode<K, EV>())_					.join(this.vertices).where(1).equalTo(0)_					.with(new ProjectEdgeWithNeighbor<K, VV, EV>())___			return vertices.coGroup(edgesWithNeighbors)_					.where(0).equalTo(0)_					.with(new ApplyCoGroupFunctionOnAllNeighbors<K, VV, EV, T>(neighborsFunction))__		default:_			throw new IllegalArgumentException("Illegal edge direction")__		}_	};groups,by,vertex,and,computes,a,group,reduce,transformation,over,the,neighbors,both,edges,and,vertices,of,each,vertex,the,neighbors,function,applied,on,the,neighbors,only,has,access,to,both,the,vertex,id,and,the,vertex,value,of,the,grouping,vertex,for,each,vertex,the,neighbors,function,can,iterate,over,all,neighbors,of,this,vertex,with,the,specified,direction,and,emit,any,number,of,output,elements,including,none,param,neighbors,function,the,group,reduce,function,to,apply,to,the,neighboring,edges,and,vertices,of,each,vertex,param,direction,the,edge,direction,in,out,all,param,t,the,output,type,return,a,data,set,containing,elements,of,type,t,throws,illegal,argument,exception;public,t,data,set,t,group,reduce,on,neighbors,neighbors,function,with,vertex,value,k,vv,ev,t,neighbors,function,edge,direction,direction,throws,illegal,argument,exception,switch,direction,case,in,data,set,tuple2,edge,k,ev,vertex,k,vv,edges,with,sources,edges,join,this,vertices,where,0,equal,to,0,return,vertices,co,group,edges,with,sources,where,0,equal,to,f0,f1,with,new,apply,neighbor,co,group,function,k,vv,ev,t,neighbors,function,case,out,data,set,tuple2,edge,k,ev,vertex,k,vv,edges,with,targets,edges,join,this,vertices,where,1,equal,to,0,return,vertices,co,group,edges,with,targets,where,0,equal,to,f0,f0,with,new,apply,neighbor,co,group,function,k,vv,ev,t,neighbors,function,case,all,data,set,tuple3,k,edge,k,ev,vertex,k,vv,edges,with,neighbors,edges,flat,map,new,emit,one,edge,with,neighbor,per,node,k,ev,join,this,vertices,where,1,equal,to,0,with,new,project,edge,with,neighbor,k,vv,ev,return,vertices,co,group,edges,with,neighbors,where,0,equal,to,0,with,new,apply,co,group,function,on,all,neighbors,k,vv,ev,t,neighbors,function,default,throw,new,illegal,argument,exception,illegal,edge,direction
Graph -> public <T> DataSet<T> groupReduceOnNeighbors(NeighborsFunctionWithVertexValue<K, VV, EV, T> neighborsFunction, 			EdgeDirection direction) throws IllegalArgumentException;1458583829;Groups by vertex and computes a GroupReduce transformation over the neighbors (both edges and vertices)_of each vertex. The neighborsFunction applied on the neighbors only has access to both the vertex id_and the vertex value of the grouping vertex.__For each vertex, the neighborsFunction can iterate over all neighbors of this vertex_with the specified direction, and emit any number of output elements, including none.__@param neighborsFunction the group reduce function to apply to the neighboring edges and vertices_of each vertex._@param direction the edge direction (in-, out-, all-)._@param <T> the output type_@return a DataSet containing elements of type T_@throws IllegalArgumentException;public <T> DataSet<T> groupReduceOnNeighbors(NeighborsFunctionWithVertexValue<K, VV, EV, T> neighborsFunction,_			EdgeDirection direction) throws IllegalArgumentException {_		switch (direction) {_		case IN:_			_			DataSet<Tuple2<Edge<K, EV>, Vertex<K, VV>>> edgesWithSources = edges_					.join(this.vertices).where(0).equalTo(0)__			return vertices.coGroup(edgesWithSources)_					.where(0).equalTo("f0.f1")_					.with(new ApplyNeighborCoGroupFunction<K, VV, EV, T>(neighborsFunction))__		case OUT:_			_			DataSet<Tuple2<Edge<K, EV>, Vertex<K, VV>>> edgesWithTargets = edges_					.join(this.vertices).where(1).equalTo(0)__			return vertices.coGroup(edgesWithTargets)_					.where(0).equalTo("f0.f0")_					.with(new ApplyNeighborCoGroupFunction<K, VV, EV, T>(neighborsFunction))__		case ALL:_			_			DataSet<Tuple3<K, Edge<K, EV>, Vertex<K, VV>>> edgesWithNeighbors = edges_					.flatMap(new EmitOneEdgeWithNeighborPerNode<K, EV>())_					.join(this.vertices).where(1).equalTo(0)_					.with(new ProjectEdgeWithNeighbor<K, VV, EV>())___			return vertices.coGroup(edgesWithNeighbors)_					.where(0).equalTo(0)_					.with(new ApplyCoGroupFunctionOnAllNeighbors<K, VV, EV, T>(neighborsFunction))__		default:_			throw new IllegalArgumentException("Illegal edge direction")__		}_	};groups,by,vertex,and,computes,a,group,reduce,transformation,over,the,neighbors,both,edges,and,vertices,of,each,vertex,the,neighbors,function,applied,on,the,neighbors,only,has,access,to,both,the,vertex,id,and,the,vertex,value,of,the,grouping,vertex,for,each,vertex,the,neighbors,function,can,iterate,over,all,neighbors,of,this,vertex,with,the,specified,direction,and,emit,any,number,of,output,elements,including,none,param,neighbors,function,the,group,reduce,function,to,apply,to,the,neighboring,edges,and,vertices,of,each,vertex,param,direction,the,edge,direction,in,out,all,param,t,the,output,type,return,a,data,set,containing,elements,of,type,t,throws,illegal,argument,exception;public,t,data,set,t,group,reduce,on,neighbors,neighbors,function,with,vertex,value,k,vv,ev,t,neighbors,function,edge,direction,direction,throws,illegal,argument,exception,switch,direction,case,in,data,set,tuple2,edge,k,ev,vertex,k,vv,edges,with,sources,edges,join,this,vertices,where,0,equal,to,0,return,vertices,co,group,edges,with,sources,where,0,equal,to,f0,f1,with,new,apply,neighbor,co,group,function,k,vv,ev,t,neighbors,function,case,out,data,set,tuple2,edge,k,ev,vertex,k,vv,edges,with,targets,edges,join,this,vertices,where,1,equal,to,0,return,vertices,co,group,edges,with,targets,where,0,equal,to,f0,f0,with,new,apply,neighbor,co,group,function,k,vv,ev,t,neighbors,function,case,all,data,set,tuple3,k,edge,k,ev,vertex,k,vv,edges,with,neighbors,edges,flat,map,new,emit,one,edge,with,neighbor,per,node,k,ev,join,this,vertices,where,1,equal,to,0,with,new,project,edge,with,neighbor,k,vv,ev,return,vertices,co,group,edges,with,neighbors,where,0,equal,to,0,with,new,apply,co,group,function,on,all,neighbors,k,vv,ev,t,neighbors,function,default,throw,new,illegal,argument,exception,illegal,edge,direction
Graph -> public <T> DataSet<T> groupReduceOnNeighbors(NeighborsFunctionWithVertexValue<K, VV, EV, T> neighborsFunction, 			EdgeDirection direction) throws IllegalArgumentException;1458583829;Groups by vertex and computes a GroupReduce transformation over the neighbors (both edges and vertices)_of each vertex. The neighborsFunction applied on the neighbors only has access to both the vertex id_and the vertex value of the grouping vertex.__For each vertex, the neighborsFunction can iterate over all neighbors of this vertex_with the specified direction, and emit any number of output elements, including none.__@param neighborsFunction the group reduce function to apply to the neighboring edges and vertices_of each vertex._@param direction the edge direction (in-, out-, all-)._@param <T> the output type_@return a DataSet containing elements of type T_@throws IllegalArgumentException;public <T> DataSet<T> groupReduceOnNeighbors(NeighborsFunctionWithVertexValue<K, VV, EV, T> neighborsFunction,_			EdgeDirection direction) throws IllegalArgumentException {_		switch (direction) {_		case IN:_			_			DataSet<Tuple2<Edge<K, EV>, Vertex<K, VV>>> edgesWithSources = edges_					.join(this.vertices).where(0).equalTo(0)__			return vertices.coGroup(edgesWithSources)_					.where(0).equalTo("f0.f1")_					.with(new ApplyNeighborCoGroupFunction<K, VV, EV, T>(neighborsFunction))__		case OUT:_			_			DataSet<Tuple2<Edge<K, EV>, Vertex<K, VV>>> edgesWithTargets = edges_					.join(this.vertices).where(1).equalTo(0)__			return vertices.coGroup(edgesWithTargets)_					.where(0).equalTo("f0.f0")_					.with(new ApplyNeighborCoGroupFunction<K, VV, EV, T>(neighborsFunction))__		case ALL:_			_			DataSet<Tuple3<K, Edge<K, EV>, Vertex<K, VV>>> edgesWithNeighbors = edges_					.flatMap(new EmitOneEdgeWithNeighborPerNode<K, EV>())_					.join(this.vertices).where(1).equalTo(0)_					.with(new ProjectEdgeWithNeighbor<K, VV, EV>())___			return vertices.coGroup(edgesWithNeighbors)_					.where(0).equalTo(0)_					.with(new ApplyCoGroupFunctionOnAllNeighbors<K, VV, EV, T>(neighborsFunction))__		default:_			throw new IllegalArgumentException("Illegal edge direction")__		}_	};groups,by,vertex,and,computes,a,group,reduce,transformation,over,the,neighbors,both,edges,and,vertices,of,each,vertex,the,neighbors,function,applied,on,the,neighbors,only,has,access,to,both,the,vertex,id,and,the,vertex,value,of,the,grouping,vertex,for,each,vertex,the,neighbors,function,can,iterate,over,all,neighbors,of,this,vertex,with,the,specified,direction,and,emit,any,number,of,output,elements,including,none,param,neighbors,function,the,group,reduce,function,to,apply,to,the,neighboring,edges,and,vertices,of,each,vertex,param,direction,the,edge,direction,in,out,all,param,t,the,output,type,return,a,data,set,containing,elements,of,type,t,throws,illegal,argument,exception;public,t,data,set,t,group,reduce,on,neighbors,neighbors,function,with,vertex,value,k,vv,ev,t,neighbors,function,edge,direction,direction,throws,illegal,argument,exception,switch,direction,case,in,data,set,tuple2,edge,k,ev,vertex,k,vv,edges,with,sources,edges,join,this,vertices,where,0,equal,to,0,return,vertices,co,group,edges,with,sources,where,0,equal,to,f0,f1,with,new,apply,neighbor,co,group,function,k,vv,ev,t,neighbors,function,case,out,data,set,tuple2,edge,k,ev,vertex,k,vv,edges,with,targets,edges,join,this,vertices,where,1,equal,to,0,return,vertices,co,group,edges,with,targets,where,0,equal,to,f0,f0,with,new,apply,neighbor,co,group,function,k,vv,ev,t,neighbors,function,case,all,data,set,tuple3,k,edge,k,ev,vertex,k,vv,edges,with,neighbors,edges,flat,map,new,emit,one,edge,with,neighbor,per,node,k,ev,join,this,vertices,where,1,equal,to,0,with,new,project,edge,with,neighbor,k,vv,ev,return,vertices,co,group,edges,with,neighbors,where,0,equal,to,0,with,new,apply,co,group,function,on,all,neighbors,k,vv,ev,t,neighbors,function,default,throw,new,illegal,argument,exception,illegal,edge,direction
Graph -> public <T> DataSet<T> groupReduceOnNeighbors(NeighborsFunctionWithVertexValue<K, VV, EV, T> neighborsFunction, 			EdgeDirection direction) throws IllegalArgumentException;1462100316;Groups by vertex and computes a GroupReduce transformation over the neighbors (both edges and vertices)_of each vertex. The neighborsFunction applied on the neighbors only has access to both the vertex id_and the vertex value of the grouping vertex.__For each vertex, the neighborsFunction can iterate over all neighbors of this vertex_with the specified direction, and emit any number of output elements, including none.__@param neighborsFunction the group reduce function to apply to the neighboring edges and vertices_of each vertex._@param direction the edge direction (in-, out-, all-)._@param <T> the output type_@return a DataSet containing elements of type T_@throws IllegalArgumentException;public <T> DataSet<T> groupReduceOnNeighbors(NeighborsFunctionWithVertexValue<K, VV, EV, T> neighborsFunction,_			EdgeDirection direction) throws IllegalArgumentException {_		switch (direction) {_		case IN:_			_			DataSet<Tuple2<Edge<K, EV>, Vertex<K, VV>>> edgesWithSources = edges_					.join(this.vertices).where(0).equalTo(0)__			return vertices.coGroup(edgesWithSources)_					.where(0).equalTo("f0.f1")_					.with(new ApplyNeighborCoGroupFunction<K, VV, EV, T>(neighborsFunction))__		case OUT:_			_			DataSet<Tuple2<Edge<K, EV>, Vertex<K, VV>>> edgesWithTargets = edges_					.join(this.vertices).where(1).equalTo(0)__			return vertices.coGroup(edgesWithTargets)_					.where(0).equalTo("f0.f0")_					.with(new ApplyNeighborCoGroupFunction<K, VV, EV, T>(neighborsFunction))__		case ALL:_			_			DataSet<Tuple3<K, Edge<K, EV>, Vertex<K, VV>>> edgesWithNeighbors = edges_					.flatMap(new EmitOneEdgeWithNeighborPerNode<K, EV>())_					.join(this.vertices).where(1).equalTo(0)_					.with(new ProjectEdgeWithNeighbor<K, VV, EV>())___			return vertices.coGroup(edgesWithNeighbors)_					.where(0).equalTo(0)_					.with(new ApplyCoGroupFunctionOnAllNeighbors<K, VV, EV, T>(neighborsFunction))__		default:_			throw new IllegalArgumentException("Illegal edge direction")__		}_	};groups,by,vertex,and,computes,a,group,reduce,transformation,over,the,neighbors,both,edges,and,vertices,of,each,vertex,the,neighbors,function,applied,on,the,neighbors,only,has,access,to,both,the,vertex,id,and,the,vertex,value,of,the,grouping,vertex,for,each,vertex,the,neighbors,function,can,iterate,over,all,neighbors,of,this,vertex,with,the,specified,direction,and,emit,any,number,of,output,elements,including,none,param,neighbors,function,the,group,reduce,function,to,apply,to,the,neighboring,edges,and,vertices,of,each,vertex,param,direction,the,edge,direction,in,out,all,param,t,the,output,type,return,a,data,set,containing,elements,of,type,t,throws,illegal,argument,exception;public,t,data,set,t,group,reduce,on,neighbors,neighbors,function,with,vertex,value,k,vv,ev,t,neighbors,function,edge,direction,direction,throws,illegal,argument,exception,switch,direction,case,in,data,set,tuple2,edge,k,ev,vertex,k,vv,edges,with,sources,edges,join,this,vertices,where,0,equal,to,0,return,vertices,co,group,edges,with,sources,where,0,equal,to,f0,f1,with,new,apply,neighbor,co,group,function,k,vv,ev,t,neighbors,function,case,out,data,set,tuple2,edge,k,ev,vertex,k,vv,edges,with,targets,edges,join,this,vertices,where,1,equal,to,0,return,vertices,co,group,edges,with,targets,where,0,equal,to,f0,f0,with,new,apply,neighbor,co,group,function,k,vv,ev,t,neighbors,function,case,all,data,set,tuple3,k,edge,k,ev,vertex,k,vv,edges,with,neighbors,edges,flat,map,new,emit,one,edge,with,neighbor,per,node,k,ev,join,this,vertices,where,1,equal,to,0,with,new,project,edge,with,neighbor,k,vv,ev,return,vertices,co,group,edges,with,neighbors,where,0,equal,to,0,with,new,apply,co,group,function,on,all,neighbors,k,vv,ev,t,neighbors,function,default,throw,new,illegal,argument,exception,illegal,edge,direction
Graph -> public <T> DataSet<T> groupReduceOnNeighbors(NeighborsFunctionWithVertexValue<K, VV, EV, T> neighborsFunction, 			EdgeDirection direction) throws IllegalArgumentException;1462100316;Groups by vertex and computes a GroupReduce transformation over the neighbors (both edges and vertices)_of each vertex. The neighborsFunction applied on the neighbors only has access to both the vertex id_and the vertex value of the grouping vertex.__For each vertex, the neighborsFunction can iterate over all neighbors of this vertex_with the specified direction, and emit any number of output elements, including none.__@param neighborsFunction the group reduce function to apply to the neighboring edges and vertices_of each vertex._@param direction the edge direction (in-, out-, all-)._@param <T> the output type_@return a DataSet containing elements of type T_@throws IllegalArgumentException;public <T> DataSet<T> groupReduceOnNeighbors(NeighborsFunctionWithVertexValue<K, VV, EV, T> neighborsFunction,_			EdgeDirection direction) throws IllegalArgumentException {_		switch (direction) {_		case IN:_			_			DataSet<Tuple2<Edge<K, EV>, Vertex<K, VV>>> edgesWithSources = edges_					.join(this.vertices).where(0).equalTo(0)__			return vertices.coGroup(edgesWithSources)_					.where(0).equalTo("f0.f1")_					.with(new ApplyNeighborCoGroupFunction<K, VV, EV, T>(neighborsFunction))__		case OUT:_			_			DataSet<Tuple2<Edge<K, EV>, Vertex<K, VV>>> edgesWithTargets = edges_					.join(this.vertices).where(1).equalTo(0)__			return vertices.coGroup(edgesWithTargets)_					.where(0).equalTo("f0.f0")_					.with(new ApplyNeighborCoGroupFunction<K, VV, EV, T>(neighborsFunction))__		case ALL:_			_			DataSet<Tuple3<K, Edge<K, EV>, Vertex<K, VV>>> edgesWithNeighbors = edges_					.flatMap(new EmitOneEdgeWithNeighborPerNode<K, EV>())_					.join(this.vertices).where(1).equalTo(0)_					.with(new ProjectEdgeWithNeighbor<K, VV, EV>())___			return vertices.coGroup(edgesWithNeighbors)_					.where(0).equalTo(0)_					.with(new ApplyCoGroupFunctionOnAllNeighbors<K, VV, EV, T>(neighborsFunction))__		default:_			throw new IllegalArgumentException("Illegal edge direction")__		}_	};groups,by,vertex,and,computes,a,group,reduce,transformation,over,the,neighbors,both,edges,and,vertices,of,each,vertex,the,neighbors,function,applied,on,the,neighbors,only,has,access,to,both,the,vertex,id,and,the,vertex,value,of,the,grouping,vertex,for,each,vertex,the,neighbors,function,can,iterate,over,all,neighbors,of,this,vertex,with,the,specified,direction,and,emit,any,number,of,output,elements,including,none,param,neighbors,function,the,group,reduce,function,to,apply,to,the,neighboring,edges,and,vertices,of,each,vertex,param,direction,the,edge,direction,in,out,all,param,t,the,output,type,return,a,data,set,containing,elements,of,type,t,throws,illegal,argument,exception;public,t,data,set,t,group,reduce,on,neighbors,neighbors,function,with,vertex,value,k,vv,ev,t,neighbors,function,edge,direction,direction,throws,illegal,argument,exception,switch,direction,case,in,data,set,tuple2,edge,k,ev,vertex,k,vv,edges,with,sources,edges,join,this,vertices,where,0,equal,to,0,return,vertices,co,group,edges,with,sources,where,0,equal,to,f0,f1,with,new,apply,neighbor,co,group,function,k,vv,ev,t,neighbors,function,case,out,data,set,tuple2,edge,k,ev,vertex,k,vv,edges,with,targets,edges,join,this,vertices,where,1,equal,to,0,return,vertices,co,group,edges,with,targets,where,0,equal,to,f0,f0,with,new,apply,neighbor,co,group,function,k,vv,ev,t,neighbors,function,case,all,data,set,tuple3,k,edge,k,ev,vertex,k,vv,edges,with,neighbors,edges,flat,map,new,emit,one,edge,with,neighbor,per,node,k,ev,join,this,vertices,where,1,equal,to,0,with,new,project,edge,with,neighbor,k,vv,ev,return,vertices,co,group,edges,with,neighbors,where,0,equal,to,0,with,new,apply,co,group,function,on,all,neighbors,k,vv,ev,t,neighbors,function,default,throw,new,illegal,argument,exception,illegal,edge,direction
Graph -> public <T> DataSet<T> groupReduceOnNeighbors(NeighborsFunctionWithVertexValue<K, VV, EV, T> neighborsFunction, 			EdgeDirection direction) throws IllegalArgumentException;1462205213;Groups by vertex and computes a GroupReduce transformation over the neighbors (both edges and vertices)_of each vertex. The neighborsFunction applied on the neighbors only has access to both the vertex id_and the vertex value of the grouping vertex.__For each vertex, the neighborsFunction can iterate over all neighbors of this vertex_with the specified direction, and emit any number of output elements, including none.__@param neighborsFunction the group reduce function to apply to the neighboring edges and vertices_of each vertex._@param direction the edge direction (in-, out-, all-)._@param <T> the output type_@return a DataSet containing elements of type T_@throws IllegalArgumentException;public <T> DataSet<T> groupReduceOnNeighbors(NeighborsFunctionWithVertexValue<K, VV, EV, T> neighborsFunction,_			EdgeDirection direction) throws IllegalArgumentException {_		switch (direction) {_		case IN:_			_			DataSet<Tuple2<Edge<K, EV>, Vertex<K, VV>>> edgesWithSources = edges_					.join(this.vertices).where(0).equalTo(0)__			return vertices.coGroup(edgesWithSources)_					.where(0).equalTo("f0.f1")_					.with(new ApplyNeighborCoGroupFunction<K, VV, EV, T>(neighborsFunction))__		case OUT:_			_			DataSet<Tuple2<Edge<K, EV>, Vertex<K, VV>>> edgesWithTargets = edges_					.join(this.vertices).where(1).equalTo(0)__			return vertices.coGroup(edgesWithTargets)_					.where(0).equalTo("f0.f0")_					.with(new ApplyNeighborCoGroupFunction<K, VV, EV, T>(neighborsFunction))__		case ALL:_			_			DataSet<Tuple3<K, Edge<K, EV>, Vertex<K, VV>>> edgesWithNeighbors = edges_					.flatMap(new EmitOneEdgeWithNeighborPerNode<K, EV>())_					.join(this.vertices).where(1).equalTo(0)_					.with(new ProjectEdgeWithNeighbor<K, VV, EV>())___			return vertices.coGroup(edgesWithNeighbors)_					.where(0).equalTo(0)_					.with(new ApplyCoGroupFunctionOnAllNeighbors<K, VV, EV, T>(neighborsFunction))__		default:_			throw new IllegalArgumentException("Illegal edge direction")__		}_	};groups,by,vertex,and,computes,a,group,reduce,transformation,over,the,neighbors,both,edges,and,vertices,of,each,vertex,the,neighbors,function,applied,on,the,neighbors,only,has,access,to,both,the,vertex,id,and,the,vertex,value,of,the,grouping,vertex,for,each,vertex,the,neighbors,function,can,iterate,over,all,neighbors,of,this,vertex,with,the,specified,direction,and,emit,any,number,of,output,elements,including,none,param,neighbors,function,the,group,reduce,function,to,apply,to,the,neighboring,edges,and,vertices,of,each,vertex,param,direction,the,edge,direction,in,out,all,param,t,the,output,type,return,a,data,set,containing,elements,of,type,t,throws,illegal,argument,exception;public,t,data,set,t,group,reduce,on,neighbors,neighbors,function,with,vertex,value,k,vv,ev,t,neighbors,function,edge,direction,direction,throws,illegal,argument,exception,switch,direction,case,in,data,set,tuple2,edge,k,ev,vertex,k,vv,edges,with,sources,edges,join,this,vertices,where,0,equal,to,0,return,vertices,co,group,edges,with,sources,where,0,equal,to,f0,f1,with,new,apply,neighbor,co,group,function,k,vv,ev,t,neighbors,function,case,out,data,set,tuple2,edge,k,ev,vertex,k,vv,edges,with,targets,edges,join,this,vertices,where,1,equal,to,0,return,vertices,co,group,edges,with,targets,where,0,equal,to,f0,f0,with,new,apply,neighbor,co,group,function,k,vv,ev,t,neighbors,function,case,all,data,set,tuple3,k,edge,k,ev,vertex,k,vv,edges,with,neighbors,edges,flat,map,new,emit,one,edge,with,neighbor,per,node,k,ev,join,this,vertices,where,1,equal,to,0,with,new,project,edge,with,neighbor,k,vv,ev,return,vertices,co,group,edges,with,neighbors,where,0,equal,to,0,with,new,apply,co,group,function,on,all,neighbors,k,vv,ev,t,neighbors,function,default,throw,new,illegal,argument,exception,illegal,edge,direction
Graph -> public <T> DataSet<T> groupReduceOnNeighbors(NeighborsFunctionWithVertexValue<K, VV, EV, T> neighborsFunction, 			EdgeDirection direction) throws IllegalArgumentException;1462208859;Groups by vertex and computes a GroupReduce transformation over the neighbors (both edges and vertices)_of each vertex. The neighborsFunction applied on the neighbors only has access to both the vertex id_and the vertex value of the grouping vertex.__For each vertex, the neighborsFunction can iterate over all neighbors of this vertex_with the specified direction, and emit any number of output elements, including none.__@param neighborsFunction the group reduce function to apply to the neighboring edges and vertices_of each vertex._@param direction the edge direction (in-, out-, all-)._@param <T> the output type_@return a DataSet containing elements of type T_@throws IllegalArgumentException;public <T> DataSet<T> groupReduceOnNeighbors(NeighborsFunctionWithVertexValue<K, VV, EV, T> neighborsFunction,_			EdgeDirection direction) throws IllegalArgumentException {_		switch (direction) {_		case IN:_			_			DataSet<Tuple2<Edge<K, EV>, Vertex<K, VV>>> edgesWithSources = edges_					.join(this.vertices).where(0).equalTo(0)__			return vertices.coGroup(edgesWithSources)_					.where(0).equalTo("f0.f1")_					.with(new ApplyNeighborCoGroupFunction<K, VV, EV, T>(neighborsFunction))__		case OUT:_			_			DataSet<Tuple2<Edge<K, EV>, Vertex<K, VV>>> edgesWithTargets = edges_					.join(this.vertices).where(1).equalTo(0)__			return vertices.coGroup(edgesWithTargets)_					.where(0).equalTo("f0.f0")_					.with(new ApplyNeighborCoGroupFunction<K, VV, EV, T>(neighborsFunction))__		case ALL:_			_			DataSet<Tuple3<K, Edge<K, EV>, Vertex<K, VV>>> edgesWithNeighbors = edges_					.flatMap(new EmitOneEdgeWithNeighborPerNode<K, EV>())_					.join(this.vertices).where(1).equalTo(0)_					.with(new ProjectEdgeWithNeighbor<K, VV, EV>())___			return vertices.coGroup(edgesWithNeighbors)_					.where(0).equalTo(0)_					.with(new ApplyCoGroupFunctionOnAllNeighbors<K, VV, EV, T>(neighborsFunction))__		default:_			throw new IllegalArgumentException("Illegal edge direction")__		}_	};groups,by,vertex,and,computes,a,group,reduce,transformation,over,the,neighbors,both,edges,and,vertices,of,each,vertex,the,neighbors,function,applied,on,the,neighbors,only,has,access,to,both,the,vertex,id,and,the,vertex,value,of,the,grouping,vertex,for,each,vertex,the,neighbors,function,can,iterate,over,all,neighbors,of,this,vertex,with,the,specified,direction,and,emit,any,number,of,output,elements,including,none,param,neighbors,function,the,group,reduce,function,to,apply,to,the,neighboring,edges,and,vertices,of,each,vertex,param,direction,the,edge,direction,in,out,all,param,t,the,output,type,return,a,data,set,containing,elements,of,type,t,throws,illegal,argument,exception;public,t,data,set,t,group,reduce,on,neighbors,neighbors,function,with,vertex,value,k,vv,ev,t,neighbors,function,edge,direction,direction,throws,illegal,argument,exception,switch,direction,case,in,data,set,tuple2,edge,k,ev,vertex,k,vv,edges,with,sources,edges,join,this,vertices,where,0,equal,to,0,return,vertices,co,group,edges,with,sources,where,0,equal,to,f0,f1,with,new,apply,neighbor,co,group,function,k,vv,ev,t,neighbors,function,case,out,data,set,tuple2,edge,k,ev,vertex,k,vv,edges,with,targets,edges,join,this,vertices,where,1,equal,to,0,return,vertices,co,group,edges,with,targets,where,0,equal,to,f0,f0,with,new,apply,neighbor,co,group,function,k,vv,ev,t,neighbors,function,case,all,data,set,tuple3,k,edge,k,ev,vertex,k,vv,edges,with,neighbors,edges,flat,map,new,emit,one,edge,with,neighbor,per,node,k,ev,join,this,vertices,where,1,equal,to,0,with,new,project,edge,with,neighbor,k,vv,ev,return,vertices,co,group,edges,with,neighbors,where,0,equal,to,0,with,new,apply,co,group,function,on,all,neighbors,k,vv,ev,t,neighbors,function,default,throw,new,illegal,argument,exception,illegal,edge,direction
Graph -> public <T> DataSet<T> groupReduceOnNeighbors(NeighborsFunctionWithVertexValue<K, VV, EV, T> neighborsFunction, 			EdgeDirection direction) throws IllegalArgumentException;1462809297;Groups by vertex and computes a GroupReduce transformation over the neighbors (both edges and vertices)_of each vertex. The neighborsFunction applied on the neighbors only has access to both the vertex id_and the vertex value of the grouping vertex.__For each vertex, the neighborsFunction can iterate over all neighbors of this vertex_with the specified direction, and emit any number of output elements, including none.__@param neighborsFunction the group reduce function to apply to the neighboring edges and vertices_of each vertex._@param direction the edge direction (in-, out-, all-)._@param <T> the output type_@return a DataSet containing elements of type T_@throws IllegalArgumentException;public <T> DataSet<T> groupReduceOnNeighbors(NeighborsFunctionWithVertexValue<K, VV, EV, T> neighborsFunction,_			EdgeDirection direction) throws IllegalArgumentException {_		switch (direction) {_		case IN:_			_			DataSet<Tuple2<Edge<K, EV>, Vertex<K, VV>>> edgesWithSources = edges_					.join(this.vertices).where(0).equalTo(0)__			return vertices.coGroup(edgesWithSources)_					.where(0).equalTo("f0.f1")_					.with(new ApplyNeighborCoGroupFunction<K, VV, EV, T>(neighborsFunction))__		case OUT:_			_			DataSet<Tuple2<Edge<K, EV>, Vertex<K, VV>>> edgesWithTargets = edges_					.join(this.vertices).where(1).equalTo(0)__			return vertices.coGroup(edgesWithTargets)_					.where(0).equalTo("f0.f0")_					.with(new ApplyNeighborCoGroupFunction<K, VV, EV, T>(neighborsFunction))__		case ALL:_			_			DataSet<Tuple3<K, Edge<K, EV>, Vertex<K, VV>>> edgesWithNeighbors = edges_					.flatMap(new EmitOneEdgeWithNeighborPerNode<K, EV>())_					.join(this.vertices).where(1).equalTo(0)_					.with(new ProjectEdgeWithNeighbor<K, VV, EV>())___			return vertices.coGroup(edgesWithNeighbors)_					.where(0).equalTo(0)_					.with(new ApplyCoGroupFunctionOnAllNeighbors<K, VV, EV, T>(neighborsFunction))__		default:_			throw new IllegalArgumentException("Illegal edge direction")__		}_	};groups,by,vertex,and,computes,a,group,reduce,transformation,over,the,neighbors,both,edges,and,vertices,of,each,vertex,the,neighbors,function,applied,on,the,neighbors,only,has,access,to,both,the,vertex,id,and,the,vertex,value,of,the,grouping,vertex,for,each,vertex,the,neighbors,function,can,iterate,over,all,neighbors,of,this,vertex,with,the,specified,direction,and,emit,any,number,of,output,elements,including,none,param,neighbors,function,the,group,reduce,function,to,apply,to,the,neighboring,edges,and,vertices,of,each,vertex,param,direction,the,edge,direction,in,out,all,param,t,the,output,type,return,a,data,set,containing,elements,of,type,t,throws,illegal,argument,exception;public,t,data,set,t,group,reduce,on,neighbors,neighbors,function,with,vertex,value,k,vv,ev,t,neighbors,function,edge,direction,direction,throws,illegal,argument,exception,switch,direction,case,in,data,set,tuple2,edge,k,ev,vertex,k,vv,edges,with,sources,edges,join,this,vertices,where,0,equal,to,0,return,vertices,co,group,edges,with,sources,where,0,equal,to,f0,f1,with,new,apply,neighbor,co,group,function,k,vv,ev,t,neighbors,function,case,out,data,set,tuple2,edge,k,ev,vertex,k,vv,edges,with,targets,edges,join,this,vertices,where,1,equal,to,0,return,vertices,co,group,edges,with,targets,where,0,equal,to,f0,f0,with,new,apply,neighbor,co,group,function,k,vv,ev,t,neighbors,function,case,all,data,set,tuple3,k,edge,k,ev,vertex,k,vv,edges,with,neighbors,edges,flat,map,new,emit,one,edge,with,neighbor,per,node,k,ev,join,this,vertices,where,1,equal,to,0,with,new,project,edge,with,neighbor,k,vv,ev,return,vertices,co,group,edges,with,neighbors,where,0,equal,to,0,with,new,apply,co,group,function,on,all,neighbors,k,vv,ev,t,neighbors,function,default,throw,new,illegal,argument,exception,illegal,edge,direction
Graph -> public <T> DataSet<T> groupReduceOnNeighbors(NeighborsFunctionWithVertexValue<K, VV, EV, T> neighborsFunction, 			EdgeDirection direction) throws IllegalArgumentException;1465316775;Groups by vertex and computes a GroupReduce transformation over the neighbors (both edges and vertices)_of each vertex. The neighborsFunction applied on the neighbors only has access to both the vertex id_and the vertex value of the grouping vertex.__For each vertex, the neighborsFunction can iterate over all neighbors of this vertex_with the specified direction, and emit any number of output elements, including none.__@param neighborsFunction the group reduce function to apply to the neighboring edges and vertices_of each vertex._@param direction the edge direction (in-, out-, all-)._@param <T> the output type_@return a DataSet containing elements of type T_@throws IllegalArgumentException;public <T> DataSet<T> groupReduceOnNeighbors(NeighborsFunctionWithVertexValue<K, VV, EV, T> neighborsFunction,_			EdgeDirection direction) throws IllegalArgumentException {_		switch (direction) {_		case IN:_			_			DataSet<Tuple2<Edge<K, EV>, Vertex<K, VV>>> edgesWithSources = edges_					.join(this.vertices).where(0).equalTo(0)__			return vertices.coGroup(edgesWithSources)_					.where(0).equalTo("f0.f1")_					.with(new ApplyNeighborCoGroupFunction<K, VV, EV, T>(neighborsFunction))__		case OUT:_			_			DataSet<Tuple2<Edge<K, EV>, Vertex<K, VV>>> edgesWithTargets = edges_					.join(this.vertices).where(1).equalTo(0)__			return vertices.coGroup(edgesWithTargets)_					.where(0).equalTo("f0.f0")_					.with(new ApplyNeighborCoGroupFunction<K, VV, EV, T>(neighborsFunction))__		case ALL:_			_			DataSet<Tuple3<K, Edge<K, EV>, Vertex<K, VV>>> edgesWithNeighbors = edges_					.flatMap(new EmitOneEdgeWithNeighborPerNode<K, EV>())_					.join(this.vertices).where(1).equalTo(0)_					.with(new ProjectEdgeWithNeighbor<K, VV, EV>())___			return vertices.coGroup(edgesWithNeighbors)_					.where(0).equalTo(0)_					.with(new ApplyCoGroupFunctionOnAllNeighbors<K, VV, EV, T>(neighborsFunction))__		default:_			throw new IllegalArgumentException("Illegal edge direction")__		}_	};groups,by,vertex,and,computes,a,group,reduce,transformation,over,the,neighbors,both,edges,and,vertices,of,each,vertex,the,neighbors,function,applied,on,the,neighbors,only,has,access,to,both,the,vertex,id,and,the,vertex,value,of,the,grouping,vertex,for,each,vertex,the,neighbors,function,can,iterate,over,all,neighbors,of,this,vertex,with,the,specified,direction,and,emit,any,number,of,output,elements,including,none,param,neighbors,function,the,group,reduce,function,to,apply,to,the,neighboring,edges,and,vertices,of,each,vertex,param,direction,the,edge,direction,in,out,all,param,t,the,output,type,return,a,data,set,containing,elements,of,type,t,throws,illegal,argument,exception;public,t,data,set,t,group,reduce,on,neighbors,neighbors,function,with,vertex,value,k,vv,ev,t,neighbors,function,edge,direction,direction,throws,illegal,argument,exception,switch,direction,case,in,data,set,tuple2,edge,k,ev,vertex,k,vv,edges,with,sources,edges,join,this,vertices,where,0,equal,to,0,return,vertices,co,group,edges,with,sources,where,0,equal,to,f0,f1,with,new,apply,neighbor,co,group,function,k,vv,ev,t,neighbors,function,case,out,data,set,tuple2,edge,k,ev,vertex,k,vv,edges,with,targets,edges,join,this,vertices,where,1,equal,to,0,return,vertices,co,group,edges,with,targets,where,0,equal,to,f0,f0,with,new,apply,neighbor,co,group,function,k,vv,ev,t,neighbors,function,case,all,data,set,tuple3,k,edge,k,ev,vertex,k,vv,edges,with,neighbors,edges,flat,map,new,emit,one,edge,with,neighbor,per,node,k,ev,join,this,vertices,where,1,equal,to,0,with,new,project,edge,with,neighbor,k,vv,ev,return,vertices,co,group,edges,with,neighbors,where,0,equal,to,0,with,new,apply,co,group,function,on,all,neighbors,k,vv,ev,t,neighbors,function,default,throw,new,illegal,argument,exception,illegal,edge,direction
Graph -> public <T> DataSet<T> groupReduceOnNeighbors(NeighborsFunctionWithVertexValue<K, VV, EV, T> neighborsFunction, 			EdgeDirection direction) throws IllegalArgumentException;1466789678;Groups by vertex and computes a GroupReduce transformation over the neighbors (both edges and vertices)_of each vertex. The neighborsFunction applied on the neighbors only has access to both the vertex id_and the vertex value of the grouping vertex.__For each vertex, the neighborsFunction can iterate over all neighbors of this vertex_with the specified direction, and emit any number of output elements, including none.__@param neighborsFunction the group reduce function to apply to the neighboring edges and vertices_of each vertex._@param direction the edge direction (in-, out-, all-)._@param <T> the output type_@return a DataSet containing elements of type T_@throws IllegalArgumentException;public <T> DataSet<T> groupReduceOnNeighbors(NeighborsFunctionWithVertexValue<K, VV, EV, T> neighborsFunction,_			EdgeDirection direction) throws IllegalArgumentException {_		switch (direction) {_		case IN:_			_			DataSet<Tuple2<Edge<K, EV>, Vertex<K, VV>>> edgesWithSources = edges_					.join(this.vertices).where(0).equalTo(0)__			return vertices.coGroup(edgesWithSources)_					.where(0).equalTo("f0.f1")_					.with(new ApplyNeighborCoGroupFunction<K, VV, EV, T>(neighborsFunction))__		case OUT:_			_			DataSet<Tuple2<Edge<K, EV>, Vertex<K, VV>>> edgesWithTargets = edges_					.join(this.vertices).where(1).equalTo(0)__			return vertices.coGroup(edgesWithTargets)_					.where(0).equalTo("f0.f0")_					.with(new ApplyNeighborCoGroupFunction<K, VV, EV, T>(neighborsFunction))__		case ALL:_			_			DataSet<Tuple3<K, Edge<K, EV>, Vertex<K, VV>>> edgesWithNeighbors = edges_					.flatMap(new EmitOneEdgeWithNeighborPerNode<K, EV>())_					.join(this.vertices).where(1).equalTo(0)_					.with(new ProjectEdgeWithNeighbor<K, VV, EV>())___			return vertices.coGroup(edgesWithNeighbors)_					.where(0).equalTo(0)_					.with(new ApplyCoGroupFunctionOnAllNeighbors<K, VV, EV, T>(neighborsFunction))__		default:_			throw new IllegalArgumentException("Illegal edge direction")__		}_	};groups,by,vertex,and,computes,a,group,reduce,transformation,over,the,neighbors,both,edges,and,vertices,of,each,vertex,the,neighbors,function,applied,on,the,neighbors,only,has,access,to,both,the,vertex,id,and,the,vertex,value,of,the,grouping,vertex,for,each,vertex,the,neighbors,function,can,iterate,over,all,neighbors,of,this,vertex,with,the,specified,direction,and,emit,any,number,of,output,elements,including,none,param,neighbors,function,the,group,reduce,function,to,apply,to,the,neighboring,edges,and,vertices,of,each,vertex,param,direction,the,edge,direction,in,out,all,param,t,the,output,type,return,a,data,set,containing,elements,of,type,t,throws,illegal,argument,exception;public,t,data,set,t,group,reduce,on,neighbors,neighbors,function,with,vertex,value,k,vv,ev,t,neighbors,function,edge,direction,direction,throws,illegal,argument,exception,switch,direction,case,in,data,set,tuple2,edge,k,ev,vertex,k,vv,edges,with,sources,edges,join,this,vertices,where,0,equal,to,0,return,vertices,co,group,edges,with,sources,where,0,equal,to,f0,f1,with,new,apply,neighbor,co,group,function,k,vv,ev,t,neighbors,function,case,out,data,set,tuple2,edge,k,ev,vertex,k,vv,edges,with,targets,edges,join,this,vertices,where,1,equal,to,0,return,vertices,co,group,edges,with,targets,where,0,equal,to,f0,f0,with,new,apply,neighbor,co,group,function,k,vv,ev,t,neighbors,function,case,all,data,set,tuple3,k,edge,k,ev,vertex,k,vv,edges,with,neighbors,edges,flat,map,new,emit,one,edge,with,neighbor,per,node,k,ev,join,this,vertices,where,1,equal,to,0,with,new,project,edge,with,neighbor,k,vv,ev,return,vertices,co,group,edges,with,neighbors,where,0,equal,to,0,with,new,apply,co,group,function,on,all,neighbors,k,vv,ev,t,neighbors,function,default,throw,new,illegal,argument,exception,illegal,edge,direction
Graph -> public <T> DataSet<T> groupReduceOnNeighbors(NeighborsFunctionWithVertexValue<K, VV, EV, T> neighborsFunction, 			EdgeDirection direction) throws IllegalArgumentException;1467140656;Groups by vertex and computes a GroupReduce transformation over the neighbors (both edges and vertices)_of each vertex. The neighborsFunction applied on the neighbors only has access to both the vertex id_and the vertex value of the grouping vertex.__For each vertex, the neighborsFunction can iterate over all neighbors of this vertex_with the specified direction, and emit any number of output elements, including none.__@param neighborsFunction the group reduce function to apply to the neighboring edges and vertices_of each vertex._@param direction the edge direction (in-, out-, all-)._@param <T> the output type_@return a DataSet containing elements of type T_@throws IllegalArgumentException;public <T> DataSet<T> groupReduceOnNeighbors(NeighborsFunctionWithVertexValue<K, VV, EV, T> neighborsFunction,_			EdgeDirection direction) throws IllegalArgumentException {_		switch (direction) {_		case IN:_			_			DataSet<Tuple2<Edge<K, EV>, Vertex<K, VV>>> edgesWithSources = edges_					.join(this.vertices).where(0).equalTo(0)__			return vertices.coGroup(edgesWithSources)_					.where(0).equalTo("f0.f1")_					.with(new ApplyNeighborCoGroupFunction<K, VV, EV, T>(neighborsFunction))__		case OUT:_			_			DataSet<Tuple2<Edge<K, EV>, Vertex<K, VV>>> edgesWithTargets = edges_					.join(this.vertices).where(1).equalTo(0)__			return vertices.coGroup(edgesWithTargets)_					.where(0).equalTo("f0.f0")_					.with(new ApplyNeighborCoGroupFunction<K, VV, EV, T>(neighborsFunction))__		case ALL:_			_			DataSet<Tuple3<K, Edge<K, EV>, Vertex<K, VV>>> edgesWithNeighbors = edges_					.flatMap(new EmitOneEdgeWithNeighborPerNode<K, EV>())_					.join(this.vertices).where(1).equalTo(0)_					.with(new ProjectEdgeWithNeighbor<K, VV, EV>())___			return vertices.coGroup(edgesWithNeighbors)_					.where(0).equalTo(0)_					.with(new ApplyCoGroupFunctionOnAllNeighbors<K, VV, EV, T>(neighborsFunction))__		default:_			throw new IllegalArgumentException("Illegal edge direction")__		}_	};groups,by,vertex,and,computes,a,group,reduce,transformation,over,the,neighbors,both,edges,and,vertices,of,each,vertex,the,neighbors,function,applied,on,the,neighbors,only,has,access,to,both,the,vertex,id,and,the,vertex,value,of,the,grouping,vertex,for,each,vertex,the,neighbors,function,can,iterate,over,all,neighbors,of,this,vertex,with,the,specified,direction,and,emit,any,number,of,output,elements,including,none,param,neighbors,function,the,group,reduce,function,to,apply,to,the,neighboring,edges,and,vertices,of,each,vertex,param,direction,the,edge,direction,in,out,all,param,t,the,output,type,return,a,data,set,containing,elements,of,type,t,throws,illegal,argument,exception;public,t,data,set,t,group,reduce,on,neighbors,neighbors,function,with,vertex,value,k,vv,ev,t,neighbors,function,edge,direction,direction,throws,illegal,argument,exception,switch,direction,case,in,data,set,tuple2,edge,k,ev,vertex,k,vv,edges,with,sources,edges,join,this,vertices,where,0,equal,to,0,return,vertices,co,group,edges,with,sources,where,0,equal,to,f0,f1,with,new,apply,neighbor,co,group,function,k,vv,ev,t,neighbors,function,case,out,data,set,tuple2,edge,k,ev,vertex,k,vv,edges,with,targets,edges,join,this,vertices,where,1,equal,to,0,return,vertices,co,group,edges,with,targets,where,0,equal,to,f0,f0,with,new,apply,neighbor,co,group,function,k,vv,ev,t,neighbors,function,case,all,data,set,tuple3,k,edge,k,ev,vertex,k,vv,edges,with,neighbors,edges,flat,map,new,emit,one,edge,with,neighbor,per,node,k,ev,join,this,vertices,where,1,equal,to,0,with,new,project,edge,with,neighbor,k,vv,ev,return,vertices,co,group,edges,with,neighbors,where,0,equal,to,0,with,new,apply,co,group,function,on,all,neighbors,k,vv,ev,t,neighbors,function,default,throw,new,illegal,argument,exception,illegal,edge,direction
Graph -> public <T> DataSet<T> groupReduceOnNeighbors(NeighborsFunctionWithVertexValue<K, VV, EV, T> neighborsFunction, 			EdgeDirection direction) throws IllegalArgumentException;1467306272;Groups by vertex and computes a GroupReduce transformation over the neighbors (both edges and vertices)_of each vertex. The neighborsFunction applied on the neighbors only has access to both the vertex id_and the vertex value of the grouping vertex.__For each vertex, the neighborsFunction can iterate over all neighbors of this vertex_with the specified direction, and emit any number of output elements, including none.__@param neighborsFunction the group reduce function to apply to the neighboring edges and vertices_of each vertex._@param direction the edge direction (in-, out-, all-)._@param <T> the output type_@return a DataSet containing elements of type T_@throws IllegalArgumentException;public <T> DataSet<T> groupReduceOnNeighbors(NeighborsFunctionWithVertexValue<K, VV, EV, T> neighborsFunction,_			EdgeDirection direction) throws IllegalArgumentException {_		switch (direction) {_		case IN:_			_			DataSet<Tuple2<Edge<K, EV>, Vertex<K, VV>>> edgesWithSources = edges_					.join(this.vertices).where(0).equalTo(0)__			return vertices.coGroup(edgesWithSources)_					.where(0).equalTo("f0.f1")_					.with(new ApplyNeighborCoGroupFunction<K, VV, EV, T>(neighborsFunction))__		case OUT:_			_			DataSet<Tuple2<Edge<K, EV>, Vertex<K, VV>>> edgesWithTargets = edges_					.join(this.vertices).where(1).equalTo(0)__			return vertices.coGroup(edgesWithTargets)_					.where(0).equalTo("f0.f0")_					.with(new ApplyNeighborCoGroupFunction<K, VV, EV, T>(neighborsFunction))__		case ALL:_			_			DataSet<Tuple3<K, Edge<K, EV>, Vertex<K, VV>>> edgesWithNeighbors = edges_					.flatMap(new EmitOneEdgeWithNeighborPerNode<K, EV>())_					.join(this.vertices).where(1).equalTo(0)_					.with(new ProjectEdgeWithNeighbor<K, VV, EV>())___			return vertices.coGroup(edgesWithNeighbors)_					.where(0).equalTo(0)_					.with(new ApplyCoGroupFunctionOnAllNeighbors<K, VV, EV, T>(neighborsFunction))__		default:_			throw new IllegalArgumentException("Illegal edge direction")__		}_	};groups,by,vertex,and,computes,a,group,reduce,transformation,over,the,neighbors,both,edges,and,vertices,of,each,vertex,the,neighbors,function,applied,on,the,neighbors,only,has,access,to,both,the,vertex,id,and,the,vertex,value,of,the,grouping,vertex,for,each,vertex,the,neighbors,function,can,iterate,over,all,neighbors,of,this,vertex,with,the,specified,direction,and,emit,any,number,of,output,elements,including,none,param,neighbors,function,the,group,reduce,function,to,apply,to,the,neighboring,edges,and,vertices,of,each,vertex,param,direction,the,edge,direction,in,out,all,param,t,the,output,type,return,a,data,set,containing,elements,of,type,t,throws,illegal,argument,exception;public,t,data,set,t,group,reduce,on,neighbors,neighbors,function,with,vertex,value,k,vv,ev,t,neighbors,function,edge,direction,direction,throws,illegal,argument,exception,switch,direction,case,in,data,set,tuple2,edge,k,ev,vertex,k,vv,edges,with,sources,edges,join,this,vertices,where,0,equal,to,0,return,vertices,co,group,edges,with,sources,where,0,equal,to,f0,f1,with,new,apply,neighbor,co,group,function,k,vv,ev,t,neighbors,function,case,out,data,set,tuple2,edge,k,ev,vertex,k,vv,edges,with,targets,edges,join,this,vertices,where,1,equal,to,0,return,vertices,co,group,edges,with,targets,where,0,equal,to,f0,f0,with,new,apply,neighbor,co,group,function,k,vv,ev,t,neighbors,function,case,all,data,set,tuple3,k,edge,k,ev,vertex,k,vv,edges,with,neighbors,edges,flat,map,new,emit,one,edge,with,neighbor,per,node,k,ev,join,this,vertices,where,1,equal,to,0,with,new,project,edge,with,neighbor,k,vv,ev,return,vertices,co,group,edges,with,neighbors,where,0,equal,to,0,with,new,apply,co,group,function,on,all,neighbors,k,vv,ev,t,neighbors,function,default,throw,new,illegal,argument,exception,illegal,edge,direction
Graph -> public <T> DataSet<T> groupReduceOnNeighbors(NeighborsFunctionWithVertexValue<K, VV, EV, T> neighborsFunction, 			EdgeDirection direction) throws IllegalArgumentException;1470042815;Groups by vertex and computes a GroupReduce transformation over the neighbors (both edges and vertices)_of each vertex. The neighborsFunction applied on the neighbors only has access to both the vertex id_and the vertex value of the grouping vertex.__For each vertex, the neighborsFunction can iterate over all neighbors of this vertex_with the specified direction, and emit any number of output elements, including none.__@param neighborsFunction the group reduce function to apply to the neighboring edges and vertices_of each vertex._@param direction the edge direction (in-, out-, all-)._@param <T> the output type_@return a DataSet containing elements of type T_@throws IllegalArgumentException;public <T> DataSet<T> groupReduceOnNeighbors(NeighborsFunctionWithVertexValue<K, VV, EV, T> neighborsFunction,_			EdgeDirection direction) throws IllegalArgumentException {_		switch (direction) {_		case IN:_			_			DataSet<Tuple2<Edge<K, EV>, Vertex<K, VV>>> edgesWithSources = edges_					.join(this.vertices).where(0).equalTo(0)__			return vertices.coGroup(edgesWithSources)_					.where(0).equalTo("f0.f1")_					.with(new ApplyNeighborCoGroupFunction<K, VV, EV, T>(neighborsFunction))__		case OUT:_			_			DataSet<Tuple2<Edge<K, EV>, Vertex<K, VV>>> edgesWithTargets = edges_					.join(this.vertices).where(1).equalTo(0)__			return vertices.coGroup(edgesWithTargets)_					.where(0).equalTo("f0.f0")_					.with(new ApplyNeighborCoGroupFunction<K, VV, EV, T>(neighborsFunction))__		case ALL:_			_			DataSet<Tuple3<K, Edge<K, EV>, Vertex<K, VV>>> edgesWithNeighbors = edges_					.flatMap(new EmitOneEdgeWithNeighborPerNode<K, EV>())_					.join(this.vertices).where(1).equalTo(0)_					.with(new ProjectEdgeWithNeighbor<K, VV, EV>())___			return vertices.coGroup(edgesWithNeighbors)_					.where(0).equalTo(0)_					.with(new ApplyCoGroupFunctionOnAllNeighbors<K, VV, EV, T>(neighborsFunction))__		default:_			throw new IllegalArgumentException("Illegal edge direction")__		}_	};groups,by,vertex,and,computes,a,group,reduce,transformation,over,the,neighbors,both,edges,and,vertices,of,each,vertex,the,neighbors,function,applied,on,the,neighbors,only,has,access,to,both,the,vertex,id,and,the,vertex,value,of,the,grouping,vertex,for,each,vertex,the,neighbors,function,can,iterate,over,all,neighbors,of,this,vertex,with,the,specified,direction,and,emit,any,number,of,output,elements,including,none,param,neighbors,function,the,group,reduce,function,to,apply,to,the,neighboring,edges,and,vertices,of,each,vertex,param,direction,the,edge,direction,in,out,all,param,t,the,output,type,return,a,data,set,containing,elements,of,type,t,throws,illegal,argument,exception;public,t,data,set,t,group,reduce,on,neighbors,neighbors,function,with,vertex,value,k,vv,ev,t,neighbors,function,edge,direction,direction,throws,illegal,argument,exception,switch,direction,case,in,data,set,tuple2,edge,k,ev,vertex,k,vv,edges,with,sources,edges,join,this,vertices,where,0,equal,to,0,return,vertices,co,group,edges,with,sources,where,0,equal,to,f0,f1,with,new,apply,neighbor,co,group,function,k,vv,ev,t,neighbors,function,case,out,data,set,tuple2,edge,k,ev,vertex,k,vv,edges,with,targets,edges,join,this,vertices,where,1,equal,to,0,return,vertices,co,group,edges,with,targets,where,0,equal,to,f0,f0,with,new,apply,neighbor,co,group,function,k,vv,ev,t,neighbors,function,case,all,data,set,tuple3,k,edge,k,ev,vertex,k,vv,edges,with,neighbors,edges,flat,map,new,emit,one,edge,with,neighbor,per,node,k,ev,join,this,vertices,where,1,equal,to,0,with,new,project,edge,with,neighbor,k,vv,ev,return,vertices,co,group,edges,with,neighbors,where,0,equal,to,0,with,new,apply,co,group,function,on,all,neighbors,k,vv,ev,t,neighbors,function,default,throw,new,illegal,argument,exception,illegal,edge,direction
Graph -> public <T> DataSet<T> groupReduceOnNeighbors(NeighborsFunctionWithVertexValue<K, VV, EV, T> neighborsFunction, 			EdgeDirection direction) throws IllegalArgumentException;1475684776;Groups by vertex and computes a GroupReduce transformation over the neighbors (both edges and vertices)_of each vertex. The neighborsFunction applied on the neighbors only has access to both the vertex id_and the vertex value of the grouping vertex.__For each vertex, the neighborsFunction can iterate over all neighbors of this vertex_with the specified direction, and emit any number of output elements, including none.__@param neighborsFunction the group reduce function to apply to the neighboring edges and vertices_of each vertex._@param direction the edge direction (in-, out-, all-)._@param <T> the output type_@return a DataSet containing elements of type T_@throws IllegalArgumentException;public <T> DataSet<T> groupReduceOnNeighbors(NeighborsFunctionWithVertexValue<K, VV, EV, T> neighborsFunction,_			EdgeDirection direction) throws IllegalArgumentException {_		switch (direction) {_		case IN:_			_			DataSet<Tuple2<Edge<K, EV>, Vertex<K, VV>>> edgesWithSources = edges_					.join(this.vertices).where(0).equalTo(0)__			return vertices.coGroup(edgesWithSources)_					.where(0).equalTo("f0.f1")_					.with(new ApplyNeighborCoGroupFunction<>(neighborsFunction))__		case OUT:_			_			DataSet<Tuple2<Edge<K, EV>, Vertex<K, VV>>> edgesWithTargets = edges_					.join(this.vertices).where(1).equalTo(0)__			return vertices.coGroup(edgesWithTargets)_					.where(0).equalTo("f0.f0")_					.with(new ApplyNeighborCoGroupFunction<>(neighborsFunction))__		case ALL:_			_			DataSet<Tuple3<K, Edge<K, EV>, Vertex<K, VV>>> edgesWithNeighbors = edges_					.flatMap(new EmitOneEdgeWithNeighborPerNode<K, EV>())_					.join(this.vertices).where(1).equalTo(0)_					.with(new ProjectEdgeWithNeighbor<K, VV, EV>())___			return vertices.coGroup(edgesWithNeighbors)_					.where(0).equalTo(0)_					.with(new ApplyCoGroupFunctionOnAllNeighbors<>(neighborsFunction))__		default:_			throw new IllegalArgumentException("Illegal edge direction")__		}_	};groups,by,vertex,and,computes,a,group,reduce,transformation,over,the,neighbors,both,edges,and,vertices,of,each,vertex,the,neighbors,function,applied,on,the,neighbors,only,has,access,to,both,the,vertex,id,and,the,vertex,value,of,the,grouping,vertex,for,each,vertex,the,neighbors,function,can,iterate,over,all,neighbors,of,this,vertex,with,the,specified,direction,and,emit,any,number,of,output,elements,including,none,param,neighbors,function,the,group,reduce,function,to,apply,to,the,neighboring,edges,and,vertices,of,each,vertex,param,direction,the,edge,direction,in,out,all,param,t,the,output,type,return,a,data,set,containing,elements,of,type,t,throws,illegal,argument,exception;public,t,data,set,t,group,reduce,on,neighbors,neighbors,function,with,vertex,value,k,vv,ev,t,neighbors,function,edge,direction,direction,throws,illegal,argument,exception,switch,direction,case,in,data,set,tuple2,edge,k,ev,vertex,k,vv,edges,with,sources,edges,join,this,vertices,where,0,equal,to,0,return,vertices,co,group,edges,with,sources,where,0,equal,to,f0,f1,with,new,apply,neighbor,co,group,function,neighbors,function,case,out,data,set,tuple2,edge,k,ev,vertex,k,vv,edges,with,targets,edges,join,this,vertices,where,1,equal,to,0,return,vertices,co,group,edges,with,targets,where,0,equal,to,f0,f0,with,new,apply,neighbor,co,group,function,neighbors,function,case,all,data,set,tuple3,k,edge,k,ev,vertex,k,vv,edges,with,neighbors,edges,flat,map,new,emit,one,edge,with,neighbor,per,node,k,ev,join,this,vertices,where,1,equal,to,0,with,new,project,edge,with,neighbor,k,vv,ev,return,vertices,co,group,edges,with,neighbors,where,0,equal,to,0,with,new,apply,co,group,function,on,all,neighbors,neighbors,function,default,throw,new,illegal,argument,exception,illegal,edge,direction
Graph -> public <T> DataSet<T> groupReduceOnNeighbors(NeighborsFunctionWithVertexValue<K, VV, EV, T> neighborsFunction, 			EdgeDirection direction) throws IllegalArgumentException;1475685606;Groups by vertex and computes a GroupReduce transformation over the neighbors (both edges and vertices)_of each vertex. The neighborsFunction applied on the neighbors only has access to both the vertex id_and the vertex value of the grouping vertex.__For each vertex, the neighborsFunction can iterate over all neighbors of this vertex_with the specified direction, and emit any number of output elements, including none.__@param neighborsFunction the group reduce function to apply to the neighboring edges and vertices_of each vertex._@param direction the edge direction (in-, out-, all-)._@param <T> the output type_@return a DataSet containing elements of type T_@throws IllegalArgumentException;public <T> DataSet<T> groupReduceOnNeighbors(NeighborsFunctionWithVertexValue<K, VV, EV, T> neighborsFunction,_			EdgeDirection direction) throws IllegalArgumentException {_		switch (direction) {_		case IN:_			_			DataSet<Tuple2<Edge<K, EV>, Vertex<K, VV>>> edgesWithSources = edges_					.join(this.vertices).where(0).equalTo(0)__			return vertices.coGroup(edgesWithSources)_					.where(0).equalTo("f0.f1")_					.with(new ApplyNeighborCoGroupFunction<>(neighborsFunction))__		case OUT:_			_			DataSet<Tuple2<Edge<K, EV>, Vertex<K, VV>>> edgesWithTargets = edges_					.join(this.vertices).where(1).equalTo(0)__			return vertices.coGroup(edgesWithTargets)_					.where(0).equalTo("f0.f0")_					.with(new ApplyNeighborCoGroupFunction<>(neighborsFunction))__		case ALL:_			_			DataSet<Tuple3<K, Edge<K, EV>, Vertex<K, VV>>> edgesWithNeighbors = edges_					.flatMap(new EmitOneEdgeWithNeighborPerNode<K, EV>())_					.join(this.vertices).where(1).equalTo(0)_					.with(new ProjectEdgeWithNeighbor<K, VV, EV>())___			return vertices.coGroup(edgesWithNeighbors)_					.where(0).equalTo(0)_					.with(new ApplyCoGroupFunctionOnAllNeighbors<>(neighborsFunction))__		default:_			throw new IllegalArgumentException("Illegal edge direction")__		}_	};groups,by,vertex,and,computes,a,group,reduce,transformation,over,the,neighbors,both,edges,and,vertices,of,each,vertex,the,neighbors,function,applied,on,the,neighbors,only,has,access,to,both,the,vertex,id,and,the,vertex,value,of,the,grouping,vertex,for,each,vertex,the,neighbors,function,can,iterate,over,all,neighbors,of,this,vertex,with,the,specified,direction,and,emit,any,number,of,output,elements,including,none,param,neighbors,function,the,group,reduce,function,to,apply,to,the,neighboring,edges,and,vertices,of,each,vertex,param,direction,the,edge,direction,in,out,all,param,t,the,output,type,return,a,data,set,containing,elements,of,type,t,throws,illegal,argument,exception;public,t,data,set,t,group,reduce,on,neighbors,neighbors,function,with,vertex,value,k,vv,ev,t,neighbors,function,edge,direction,direction,throws,illegal,argument,exception,switch,direction,case,in,data,set,tuple2,edge,k,ev,vertex,k,vv,edges,with,sources,edges,join,this,vertices,where,0,equal,to,0,return,vertices,co,group,edges,with,sources,where,0,equal,to,f0,f1,with,new,apply,neighbor,co,group,function,neighbors,function,case,out,data,set,tuple2,edge,k,ev,vertex,k,vv,edges,with,targets,edges,join,this,vertices,where,1,equal,to,0,return,vertices,co,group,edges,with,targets,where,0,equal,to,f0,f0,with,new,apply,neighbor,co,group,function,neighbors,function,case,all,data,set,tuple3,k,edge,k,ev,vertex,k,vv,edges,with,neighbors,edges,flat,map,new,emit,one,edge,with,neighbor,per,node,k,ev,join,this,vertices,where,1,equal,to,0,with,new,project,edge,with,neighbor,k,vv,ev,return,vertices,co,group,edges,with,neighbors,where,0,equal,to,0,with,new,apply,co,group,function,on,all,neighbors,neighbors,function,default,throw,new,illegal,argument,exception,illegal,edge,direction
Graph -> public <T> DataSet<T> groupReduceOnNeighbors(NeighborsFunctionWithVertexValue<K, VV, EV, T> neighborsFunction, 			EdgeDirection direction) throws IllegalArgumentException;1481745825;Groups by vertex and computes a GroupReduce transformation over the neighbors (both edges and vertices)_of each vertex. The neighborsFunction applied on the neighbors only has access to both the vertex id_and the vertex value of the grouping vertex.__For each vertex, the neighborsFunction can iterate over all neighbors of this vertex_with the specified direction, and emit any number of output elements, including none.__@param neighborsFunction the group reduce function to apply to the neighboring edges and vertices_of each vertex._@param direction the edge direction (in-, out-, all-)._@param <T> the output type_@return a DataSet containing elements of type T_@throws IllegalArgumentException;public <T> DataSet<T> groupReduceOnNeighbors(NeighborsFunctionWithVertexValue<K, VV, EV, T> neighborsFunction,_			EdgeDirection direction) throws IllegalArgumentException {_		switch (direction) {_		case IN:_			_			DataSet<Tuple2<Edge<K, EV>, Vertex<K, VV>>> edgesWithSources = edges_					.join(this.vertices).where(0).equalTo(0).name("Edge with source vertex")__			return vertices.coGroup(edgesWithSources)_					.where(0).equalTo("f0.f1")_					.with(new ApplyNeighborCoGroupFunction<>(neighborsFunction)).name("Neighbors function")__		case OUT:_			_			DataSet<Tuple2<Edge<K, EV>, Vertex<K, VV>>> edgesWithTargets = edges_					.join(this.vertices).where(1).equalTo(0).name("Edge with target vertex")__			return vertices.coGroup(edgesWithTargets)_					.where(0).equalTo("f0.f0")_					.with(new ApplyNeighborCoGroupFunction<>(neighborsFunction)).name("Neighbors function")__		case ALL:_			_			DataSet<Tuple3<K, Edge<K, EV>, Vertex<K, VV>>> edgesWithNeighbors = edges_					.flatMap(new EmitOneEdgeWithNeighborPerNode<K, EV>()).name("Forward and reverse edges")_					.join(this.vertices).where(1).equalTo(0)_					.with(new ProjectEdgeWithNeighbor<K, VV, EV>()).name("Edge with vertex")___			return vertices.coGroup(edgesWithNeighbors)_					.where(0).equalTo(0)_					.with(new ApplyCoGroupFunctionOnAllNeighbors<>(neighborsFunction)).name("Neighbors function")__		default:_			throw new IllegalArgumentException("Illegal edge direction")__		}_	};groups,by,vertex,and,computes,a,group,reduce,transformation,over,the,neighbors,both,edges,and,vertices,of,each,vertex,the,neighbors,function,applied,on,the,neighbors,only,has,access,to,both,the,vertex,id,and,the,vertex,value,of,the,grouping,vertex,for,each,vertex,the,neighbors,function,can,iterate,over,all,neighbors,of,this,vertex,with,the,specified,direction,and,emit,any,number,of,output,elements,including,none,param,neighbors,function,the,group,reduce,function,to,apply,to,the,neighboring,edges,and,vertices,of,each,vertex,param,direction,the,edge,direction,in,out,all,param,t,the,output,type,return,a,data,set,containing,elements,of,type,t,throws,illegal,argument,exception;public,t,data,set,t,group,reduce,on,neighbors,neighbors,function,with,vertex,value,k,vv,ev,t,neighbors,function,edge,direction,direction,throws,illegal,argument,exception,switch,direction,case,in,data,set,tuple2,edge,k,ev,vertex,k,vv,edges,with,sources,edges,join,this,vertices,where,0,equal,to,0,name,edge,with,source,vertex,return,vertices,co,group,edges,with,sources,where,0,equal,to,f0,f1,with,new,apply,neighbor,co,group,function,neighbors,function,name,neighbors,function,case,out,data,set,tuple2,edge,k,ev,vertex,k,vv,edges,with,targets,edges,join,this,vertices,where,1,equal,to,0,name,edge,with,target,vertex,return,vertices,co,group,edges,with,targets,where,0,equal,to,f0,f0,with,new,apply,neighbor,co,group,function,neighbors,function,name,neighbors,function,case,all,data,set,tuple3,k,edge,k,ev,vertex,k,vv,edges,with,neighbors,edges,flat,map,new,emit,one,edge,with,neighbor,per,node,k,ev,name,forward,and,reverse,edges,join,this,vertices,where,1,equal,to,0,with,new,project,edge,with,neighbor,k,vv,ev,name,edge,with,vertex,return,vertices,co,group,edges,with,neighbors,where,0,equal,to,0,with,new,apply,co,group,function,on,all,neighbors,neighbors,function,name,neighbors,function,default,throw,new,illegal,argument,exception,illegal,edge,direction
Graph -> public <T> DataSet<T> groupReduceOnNeighbors(NeighborsFunctionWithVertexValue<K, VV, EV, T> neighborsFunction, 			EdgeDirection direction) throws IllegalArgumentException;1481881009;Groups by vertex and computes a GroupReduce transformation over the neighbors (both edges and vertices)_of each vertex. The neighborsFunction applied on the neighbors only has access to both the vertex id_and the vertex value of the grouping vertex.__For each vertex, the neighborsFunction can iterate over all neighbors of this vertex_with the specified direction, and emit any number of output elements, including none.__@param neighborsFunction the group reduce function to apply to the neighboring edges and vertices_of each vertex._@param direction the edge direction (in-, out-, all-)._@param <T> the output type_@return a DataSet containing elements of type T_@throws IllegalArgumentException;public <T> DataSet<T> groupReduceOnNeighbors(NeighborsFunctionWithVertexValue<K, VV, EV, T> neighborsFunction,_			EdgeDirection direction) throws IllegalArgumentException {_		switch (direction) {_		case IN:_			_			DataSet<Tuple2<Edge<K, EV>, Vertex<K, VV>>> edgesWithSources = edges_					.join(this.vertices).where(0).equalTo(0).name("Edge with source vertex")__			return vertices.coGroup(edgesWithSources)_					.where(0).equalTo("f0.f1")_					.with(new ApplyNeighborCoGroupFunction<>(neighborsFunction)).name("Neighbors function")__		case OUT:_			_			DataSet<Tuple2<Edge<K, EV>, Vertex<K, VV>>> edgesWithTargets = edges_					.join(this.vertices).where(1).equalTo(0).name("Edge with target vertex")__			return vertices.coGroup(edgesWithTargets)_					.where(0).equalTo("f0.f0")_					.with(new ApplyNeighborCoGroupFunction<>(neighborsFunction)).name("Neighbors function")__		case ALL:_			_			DataSet<Tuple3<K, Edge<K, EV>, Vertex<K, VV>>> edgesWithNeighbors = edges_					.flatMap(new EmitOneEdgeWithNeighborPerNode<K, EV>()).name("Forward and reverse edges")_					.join(this.vertices).where(1).equalTo(0)_					.with(new ProjectEdgeWithNeighbor<K, VV, EV>()).name("Edge with vertex")___			return vertices.coGroup(edgesWithNeighbors)_					.where(0).equalTo(0)_					.with(new ApplyCoGroupFunctionOnAllNeighbors<>(neighborsFunction)).name("Neighbors function")__		default:_			throw new IllegalArgumentException("Illegal edge direction")__		}_	};groups,by,vertex,and,computes,a,group,reduce,transformation,over,the,neighbors,both,edges,and,vertices,of,each,vertex,the,neighbors,function,applied,on,the,neighbors,only,has,access,to,both,the,vertex,id,and,the,vertex,value,of,the,grouping,vertex,for,each,vertex,the,neighbors,function,can,iterate,over,all,neighbors,of,this,vertex,with,the,specified,direction,and,emit,any,number,of,output,elements,including,none,param,neighbors,function,the,group,reduce,function,to,apply,to,the,neighboring,edges,and,vertices,of,each,vertex,param,direction,the,edge,direction,in,out,all,param,t,the,output,type,return,a,data,set,containing,elements,of,type,t,throws,illegal,argument,exception;public,t,data,set,t,group,reduce,on,neighbors,neighbors,function,with,vertex,value,k,vv,ev,t,neighbors,function,edge,direction,direction,throws,illegal,argument,exception,switch,direction,case,in,data,set,tuple2,edge,k,ev,vertex,k,vv,edges,with,sources,edges,join,this,vertices,where,0,equal,to,0,name,edge,with,source,vertex,return,vertices,co,group,edges,with,sources,where,0,equal,to,f0,f1,with,new,apply,neighbor,co,group,function,neighbors,function,name,neighbors,function,case,out,data,set,tuple2,edge,k,ev,vertex,k,vv,edges,with,targets,edges,join,this,vertices,where,1,equal,to,0,name,edge,with,target,vertex,return,vertices,co,group,edges,with,targets,where,0,equal,to,f0,f0,with,new,apply,neighbor,co,group,function,neighbors,function,name,neighbors,function,case,all,data,set,tuple3,k,edge,k,ev,vertex,k,vv,edges,with,neighbors,edges,flat,map,new,emit,one,edge,with,neighbor,per,node,k,ev,name,forward,and,reverse,edges,join,this,vertices,where,1,equal,to,0,with,new,project,edge,with,neighbor,k,vv,ev,name,edge,with,vertex,return,vertices,co,group,edges,with,neighbors,where,0,equal,to,0,with,new,apply,co,group,function,on,all,neighbors,neighbors,function,name,neighbors,function,default,throw,new,illegal,argument,exception,illegal,edge,direction
Graph -> public <T> DataSet<T> groupReduceOnNeighbors(NeighborsFunctionWithVertexValue<K, VV, EV, T> neighborsFunction, 			EdgeDirection direction) throws IllegalArgumentException;1484160227;Groups by vertex and computes a GroupReduce transformation over the neighbors (both edges and vertices)_of each vertex. The neighborsFunction applied on the neighbors only has access to both the vertex id_and the vertex value of the grouping vertex.__For each vertex, the neighborsFunction can iterate over all neighbors of this vertex_with the specified direction, and emit any number of output elements, including none.__@param neighborsFunction the group reduce function to apply to the neighboring edges and vertices_of each vertex._@param direction the edge direction (in-, out-, all-)._@param <T> the output type_@return a DataSet containing elements of type T_@throws IllegalArgumentException;public <T> DataSet<T> groupReduceOnNeighbors(NeighborsFunctionWithVertexValue<K, VV, EV, T> neighborsFunction,_			EdgeDirection direction) throws IllegalArgumentException {_		switch (direction) {_		case IN:_			_			DataSet<Tuple2<Edge<K, EV>, Vertex<K, VV>>> edgesWithSources = edges_					.join(this.vertices).where(0).equalTo(0).name("Edge with source vertex")__			return vertices.coGroup(edgesWithSources)_					.where(0).equalTo("f0.f1")_					.with(new ApplyNeighborCoGroupFunction<>(neighborsFunction)).name("Neighbors function")__		case OUT:_			_			DataSet<Tuple2<Edge<K, EV>, Vertex<K, VV>>> edgesWithTargets = edges_					.join(this.vertices).where(1).equalTo(0).name("Edge with target vertex")__			return vertices.coGroup(edgesWithTargets)_					.where(0).equalTo("f0.f0")_					.with(new ApplyNeighborCoGroupFunction<>(neighborsFunction)).name("Neighbors function")__		case ALL:_			_			DataSet<Tuple3<K, Edge<K, EV>, Vertex<K, VV>>> edgesWithNeighbors = edges_					.flatMap(new EmitOneEdgeWithNeighborPerNode<K, EV>()).name("Forward and reverse edges")_					.join(this.vertices).where(1).equalTo(0)_					.with(new ProjectEdgeWithNeighbor<K, VV, EV>()).name("Edge with vertex")___			return vertices.coGroup(edgesWithNeighbors)_					.where(0).equalTo(0)_					.with(new ApplyCoGroupFunctionOnAllNeighbors<>(neighborsFunction)).name("Neighbors function")__		default:_			throw new IllegalArgumentException("Illegal edge direction")__		}_	};groups,by,vertex,and,computes,a,group,reduce,transformation,over,the,neighbors,both,edges,and,vertices,of,each,vertex,the,neighbors,function,applied,on,the,neighbors,only,has,access,to,both,the,vertex,id,and,the,vertex,value,of,the,grouping,vertex,for,each,vertex,the,neighbors,function,can,iterate,over,all,neighbors,of,this,vertex,with,the,specified,direction,and,emit,any,number,of,output,elements,including,none,param,neighbors,function,the,group,reduce,function,to,apply,to,the,neighboring,edges,and,vertices,of,each,vertex,param,direction,the,edge,direction,in,out,all,param,t,the,output,type,return,a,data,set,containing,elements,of,type,t,throws,illegal,argument,exception;public,t,data,set,t,group,reduce,on,neighbors,neighbors,function,with,vertex,value,k,vv,ev,t,neighbors,function,edge,direction,direction,throws,illegal,argument,exception,switch,direction,case,in,data,set,tuple2,edge,k,ev,vertex,k,vv,edges,with,sources,edges,join,this,vertices,where,0,equal,to,0,name,edge,with,source,vertex,return,vertices,co,group,edges,with,sources,where,0,equal,to,f0,f1,with,new,apply,neighbor,co,group,function,neighbors,function,name,neighbors,function,case,out,data,set,tuple2,edge,k,ev,vertex,k,vv,edges,with,targets,edges,join,this,vertices,where,1,equal,to,0,name,edge,with,target,vertex,return,vertices,co,group,edges,with,targets,where,0,equal,to,f0,f0,with,new,apply,neighbor,co,group,function,neighbors,function,name,neighbors,function,case,all,data,set,tuple3,k,edge,k,ev,vertex,k,vv,edges,with,neighbors,edges,flat,map,new,emit,one,edge,with,neighbor,per,node,k,ev,name,forward,and,reverse,edges,join,this,vertices,where,1,equal,to,0,with,new,project,edge,with,neighbor,k,vv,ev,name,edge,with,vertex,return,vertices,co,group,edges,with,neighbors,where,0,equal,to,0,with,new,apply,co,group,function,on,all,neighbors,neighbors,function,name,neighbors,function,default,throw,new,illegal,argument,exception,illegal,edge,direction
Graph -> public <T> DataSet<T> groupReduceOnNeighbors(NeighborsFunctionWithVertexValue<K, VV, EV, T> neighborsFunction, 			EdgeDirection direction) throws IllegalArgumentException;1484685504;Groups by vertex and computes a GroupReduce transformation over the neighbors (both edges and vertices)_of each vertex. The neighborsFunction applied on the neighbors only has access to both the vertex id_and the vertex value of the grouping vertex.__For each vertex, the neighborsFunction can iterate over all neighbors of this vertex_with the specified direction, and emit any number of output elements, including none.__@param neighborsFunction the group reduce function to apply to the neighboring edges and vertices_of each vertex._@param direction the edge direction (in-, out-, all-)._@param <T> the output type_@return a DataSet containing elements of type T_@throws IllegalArgumentException;public <T> DataSet<T> groupReduceOnNeighbors(NeighborsFunctionWithVertexValue<K, VV, EV, T> neighborsFunction,_			EdgeDirection direction) throws IllegalArgumentException {_		switch (direction) {_		case IN:_			_			DataSet<Tuple2<Edge<K, EV>, Vertex<K, VV>>> edgesWithSources = edges_					.join(this.vertices).where(0).equalTo(0).name("Edge with source vertex")__			return vertices.coGroup(edgesWithSources)_					.where(0).equalTo("f0.f1")_					.with(new ApplyNeighborCoGroupFunction<>(neighborsFunction)).name("Neighbors function")__		case OUT:_			_			DataSet<Tuple2<Edge<K, EV>, Vertex<K, VV>>> edgesWithTargets = edges_					.join(this.vertices).where(1).equalTo(0).name("Edge with target vertex")__			return vertices.coGroup(edgesWithTargets)_					.where(0).equalTo("f0.f0")_					.with(new ApplyNeighborCoGroupFunction<>(neighborsFunction)).name("Neighbors function")__		case ALL:_			_			DataSet<Tuple3<K, Edge<K, EV>, Vertex<K, VV>>> edgesWithNeighbors = edges_					.flatMap(new EmitOneEdgeWithNeighborPerNode<K, EV>()).name("Forward and reverse edges")_					.join(this.vertices).where(1).equalTo(0)_					.with(new ProjectEdgeWithNeighbor<K, VV, EV>()).name("Edge with vertex")___			return vertices.coGroup(edgesWithNeighbors)_					.where(0).equalTo(0)_					.with(new ApplyCoGroupFunctionOnAllNeighbors<>(neighborsFunction)).name("Neighbors function")__		default:_			throw new IllegalArgumentException("Illegal edge direction")__		}_	};groups,by,vertex,and,computes,a,group,reduce,transformation,over,the,neighbors,both,edges,and,vertices,of,each,vertex,the,neighbors,function,applied,on,the,neighbors,only,has,access,to,both,the,vertex,id,and,the,vertex,value,of,the,grouping,vertex,for,each,vertex,the,neighbors,function,can,iterate,over,all,neighbors,of,this,vertex,with,the,specified,direction,and,emit,any,number,of,output,elements,including,none,param,neighbors,function,the,group,reduce,function,to,apply,to,the,neighboring,edges,and,vertices,of,each,vertex,param,direction,the,edge,direction,in,out,all,param,t,the,output,type,return,a,data,set,containing,elements,of,type,t,throws,illegal,argument,exception;public,t,data,set,t,group,reduce,on,neighbors,neighbors,function,with,vertex,value,k,vv,ev,t,neighbors,function,edge,direction,direction,throws,illegal,argument,exception,switch,direction,case,in,data,set,tuple2,edge,k,ev,vertex,k,vv,edges,with,sources,edges,join,this,vertices,where,0,equal,to,0,name,edge,with,source,vertex,return,vertices,co,group,edges,with,sources,where,0,equal,to,f0,f1,with,new,apply,neighbor,co,group,function,neighbors,function,name,neighbors,function,case,out,data,set,tuple2,edge,k,ev,vertex,k,vv,edges,with,targets,edges,join,this,vertices,where,1,equal,to,0,name,edge,with,target,vertex,return,vertices,co,group,edges,with,targets,where,0,equal,to,f0,f0,with,new,apply,neighbor,co,group,function,neighbors,function,name,neighbors,function,case,all,data,set,tuple3,k,edge,k,ev,vertex,k,vv,edges,with,neighbors,edges,flat,map,new,emit,one,edge,with,neighbor,per,node,k,ev,name,forward,and,reverse,edges,join,this,vertices,where,1,equal,to,0,with,new,project,edge,with,neighbor,k,vv,ev,name,edge,with,vertex,return,vertices,co,group,edges,with,neighbors,where,0,equal,to,0,with,new,apply,co,group,function,on,all,neighbors,neighbors,function,name,neighbors,function,default,throw,new,illegal,argument,exception,illegal,edge,direction
Graph -> public <T> DataSet<T> groupReduceOnNeighbors(NeighborsFunctionWithVertexValue<K, VV, EV, T> neighborsFunction, 			EdgeDirection direction) throws IllegalArgumentException;1489068942;Groups by vertex and computes a GroupReduce transformation over the neighbors (both edges and vertices)_of each vertex. The neighborsFunction applied on the neighbors only has access to both the vertex id_and the vertex value of the grouping vertex.__For each vertex, the neighborsFunction can iterate over all neighbors of this vertex_with the specified direction, and emit any number of output elements, including none.__@param neighborsFunction the group reduce function to apply to the neighboring edges and vertices_of each vertex._@param direction the edge direction (in-, out-, all-)._@param <T> the output type_@return a DataSet containing elements of type T_@throws IllegalArgumentException;public <T> DataSet<T> groupReduceOnNeighbors(NeighborsFunctionWithVertexValue<K, VV, EV, T> neighborsFunction,_			EdgeDirection direction) throws IllegalArgumentException {_		switch (direction) {_		case IN:_			_			DataSet<Tuple2<Edge<K, EV>, Vertex<K, VV>>> edgesWithSources = edges_					.join(this.vertices).where(0).equalTo(0).name("Edge with source vertex")__			return vertices.coGroup(edgesWithSources)_					.where(0).equalTo("f0.f1")_					.with(new ApplyNeighborCoGroupFunction<>(neighborsFunction)).name("Neighbors function")__		case OUT:_			_			DataSet<Tuple2<Edge<K, EV>, Vertex<K, VV>>> edgesWithTargets = edges_					.join(this.vertices).where(1).equalTo(0).name("Edge with target vertex")__			return vertices.coGroup(edgesWithTargets)_					.where(0).equalTo("f0.f0")_					.with(new ApplyNeighborCoGroupFunction<>(neighborsFunction)).name("Neighbors function")__		case ALL:_			_			DataSet<Tuple3<K, Edge<K, EV>, Vertex<K, VV>>> edgesWithNeighbors = edges_					.flatMap(new EmitOneEdgeWithNeighborPerNode<K, EV>()).name("Forward and reverse edges")_					.join(this.vertices).where(1).equalTo(0)_					.with(new ProjectEdgeWithNeighbor<K, VV, EV>()).name("Edge with vertex")___			return vertices.coGroup(edgesWithNeighbors)_					.where(0).equalTo(0)_					.with(new ApplyCoGroupFunctionOnAllNeighbors<>(neighborsFunction)).name("Neighbors function")__		default:_			throw new IllegalArgumentException("Illegal edge direction")__		}_	};groups,by,vertex,and,computes,a,group,reduce,transformation,over,the,neighbors,both,edges,and,vertices,of,each,vertex,the,neighbors,function,applied,on,the,neighbors,only,has,access,to,both,the,vertex,id,and,the,vertex,value,of,the,grouping,vertex,for,each,vertex,the,neighbors,function,can,iterate,over,all,neighbors,of,this,vertex,with,the,specified,direction,and,emit,any,number,of,output,elements,including,none,param,neighbors,function,the,group,reduce,function,to,apply,to,the,neighboring,edges,and,vertices,of,each,vertex,param,direction,the,edge,direction,in,out,all,param,t,the,output,type,return,a,data,set,containing,elements,of,type,t,throws,illegal,argument,exception;public,t,data,set,t,group,reduce,on,neighbors,neighbors,function,with,vertex,value,k,vv,ev,t,neighbors,function,edge,direction,direction,throws,illegal,argument,exception,switch,direction,case,in,data,set,tuple2,edge,k,ev,vertex,k,vv,edges,with,sources,edges,join,this,vertices,where,0,equal,to,0,name,edge,with,source,vertex,return,vertices,co,group,edges,with,sources,where,0,equal,to,f0,f1,with,new,apply,neighbor,co,group,function,neighbors,function,name,neighbors,function,case,out,data,set,tuple2,edge,k,ev,vertex,k,vv,edges,with,targets,edges,join,this,vertices,where,1,equal,to,0,name,edge,with,target,vertex,return,vertices,co,group,edges,with,targets,where,0,equal,to,f0,f0,with,new,apply,neighbor,co,group,function,neighbors,function,name,neighbors,function,case,all,data,set,tuple3,k,edge,k,ev,vertex,k,vv,edges,with,neighbors,edges,flat,map,new,emit,one,edge,with,neighbor,per,node,k,ev,name,forward,and,reverse,edges,join,this,vertices,where,1,equal,to,0,with,new,project,edge,with,neighbor,k,vv,ev,name,edge,with,vertex,return,vertices,co,group,edges,with,neighbors,where,0,equal,to,0,with,new,apply,co,group,function,on,all,neighbors,neighbors,function,name,neighbors,function,default,throw,new,illegal,argument,exception,illegal,edge,direction
Graph -> public <T> DataSet<T> groupReduceOnNeighbors(NeighborsFunctionWithVertexValue<K, VV, EV, T> neighborsFunction, 			EdgeDirection direction) throws IllegalArgumentException;1490973446;Groups by vertex and computes a GroupReduce transformation over the neighbors (both edges and vertices)_of each vertex. The neighborsFunction applied on the neighbors only has access to both the vertex id_and the vertex value of the grouping vertex.__For each vertex, the neighborsFunction can iterate over all neighbors of this vertex_with the specified direction, and emit any number of output elements, including none.__@param neighborsFunction the group reduce function to apply to the neighboring edges and vertices_of each vertex._@param direction the edge direction (in-, out-, all-)._@param <T> the output type_@return a DataSet containing elements of type T_@throws IllegalArgumentException;public <T> DataSet<T> groupReduceOnNeighbors(NeighborsFunctionWithVertexValue<K, VV, EV, T> neighborsFunction,_			EdgeDirection direction) throws IllegalArgumentException {_		switch (direction) {_		case IN:_			_			DataSet<Tuple2<Edge<K, EV>, Vertex<K, VV>>> edgesWithSources = edges_					.join(this.vertices).where(0).equalTo(0).name("Edge with source vertex")__			return vertices.coGroup(edgesWithSources)_					.where(0).equalTo("f0.f1")_					.with(new ApplyNeighborCoGroupFunction<>(neighborsFunction)).name("Neighbors function")__		case OUT:_			_			DataSet<Tuple2<Edge<K, EV>, Vertex<K, VV>>> edgesWithTargets = edges_					.join(this.vertices).where(1).equalTo(0).name("Edge with target vertex")__			return vertices.coGroup(edgesWithTargets)_					.where(0).equalTo("f0.f0")_					.with(new ApplyNeighborCoGroupFunction<>(neighborsFunction)).name("Neighbors function")__		case ALL:_			_			DataSet<Tuple3<K, Edge<K, EV>, Vertex<K, VV>>> edgesWithNeighbors = edges_					.flatMap(new EmitOneEdgeWithNeighborPerNode<K, EV>()).name("Forward and reverse edges")_					.join(this.vertices).where(1).equalTo(0)_					.with(new ProjectEdgeWithNeighbor<K, VV, EV>()).name("Edge with vertex")___			return vertices.coGroup(edgesWithNeighbors)_					.where(0).equalTo(0)_					.with(new ApplyCoGroupFunctionOnAllNeighbors<>(neighborsFunction)).name("Neighbors function")__		default:_			throw new IllegalArgumentException("Illegal edge direction")__		}_	};groups,by,vertex,and,computes,a,group,reduce,transformation,over,the,neighbors,both,edges,and,vertices,of,each,vertex,the,neighbors,function,applied,on,the,neighbors,only,has,access,to,both,the,vertex,id,and,the,vertex,value,of,the,grouping,vertex,for,each,vertex,the,neighbors,function,can,iterate,over,all,neighbors,of,this,vertex,with,the,specified,direction,and,emit,any,number,of,output,elements,including,none,param,neighbors,function,the,group,reduce,function,to,apply,to,the,neighboring,edges,and,vertices,of,each,vertex,param,direction,the,edge,direction,in,out,all,param,t,the,output,type,return,a,data,set,containing,elements,of,type,t,throws,illegal,argument,exception;public,t,data,set,t,group,reduce,on,neighbors,neighbors,function,with,vertex,value,k,vv,ev,t,neighbors,function,edge,direction,direction,throws,illegal,argument,exception,switch,direction,case,in,data,set,tuple2,edge,k,ev,vertex,k,vv,edges,with,sources,edges,join,this,vertices,where,0,equal,to,0,name,edge,with,source,vertex,return,vertices,co,group,edges,with,sources,where,0,equal,to,f0,f1,with,new,apply,neighbor,co,group,function,neighbors,function,name,neighbors,function,case,out,data,set,tuple2,edge,k,ev,vertex,k,vv,edges,with,targets,edges,join,this,vertices,where,1,equal,to,0,name,edge,with,target,vertex,return,vertices,co,group,edges,with,targets,where,0,equal,to,f0,f0,with,new,apply,neighbor,co,group,function,neighbors,function,name,neighbors,function,case,all,data,set,tuple3,k,edge,k,ev,vertex,k,vv,edges,with,neighbors,edges,flat,map,new,emit,one,edge,with,neighbor,per,node,k,ev,name,forward,and,reverse,edges,join,this,vertices,where,1,equal,to,0,with,new,project,edge,with,neighbor,k,vv,ev,name,edge,with,vertex,return,vertices,co,group,edges,with,neighbors,where,0,equal,to,0,with,new,apply,co,group,function,on,all,neighbors,neighbors,function,name,neighbors,function,default,throw,new,illegal,argument,exception,illegal,edge,direction
Graph -> public <T> DataSet<T> groupReduceOnNeighbors(NeighborsFunctionWithVertexValue<K, VV, EV, T> neighborsFunction, 			EdgeDirection direction) throws IllegalArgumentException;1495819075;Groups by vertex and computes a GroupReduce transformation over the neighbors (both edges and vertices)_of each vertex. The neighborsFunction applied on the neighbors only has access to both the vertex id_and the vertex value of the grouping vertex.__<p>For each vertex, the neighborsFunction can iterate over all neighbors of this vertex_with the specified direction, and emit any number of output elements, including none.__@param neighborsFunction the group reduce function to apply to the neighboring edges and vertices_of each vertex._@param direction the edge direction (in-, out-, all-)._@param <T> the output type_@return a DataSet containing elements of type T_@throws IllegalArgumentException;public <T> DataSet<T> groupReduceOnNeighbors(NeighborsFunctionWithVertexValue<K, VV, EV, T> neighborsFunction,_			EdgeDirection direction) throws IllegalArgumentException {_		switch (direction) {_		case IN:_			_			DataSet<Tuple2<Edge<K, EV>, Vertex<K, VV>>> edgesWithSources = edges_					.join(this.vertices).where(0).equalTo(0).name("Edge with source vertex")__			return vertices.coGroup(edgesWithSources)_					.where(0).equalTo("f0.f1")_					.with(new ApplyNeighborCoGroupFunction<>(neighborsFunction)).name("Neighbors function")__		case OUT:_			_			DataSet<Tuple2<Edge<K, EV>, Vertex<K, VV>>> edgesWithTargets = edges_					.join(this.vertices).where(1).equalTo(0).name("Edge with target vertex")__			return vertices.coGroup(edgesWithTargets)_					.where(0).equalTo("f0.f0")_					.with(new ApplyNeighborCoGroupFunction<>(neighborsFunction)).name("Neighbors function")__		case ALL:_			_			DataSet<Tuple3<K, Edge<K, EV>, Vertex<K, VV>>> edgesWithNeighbors = edges_					.flatMap(new EmitOneEdgeWithNeighborPerNode<K, EV>()).name("Forward and reverse edges")_					.join(this.vertices).where(1).equalTo(0)_					.with(new ProjectEdgeWithNeighbor<K, VV, EV>()).name("Edge with vertex")___			return vertices.coGroup(edgesWithNeighbors)_					.where(0).equalTo(0)_					.with(new ApplyCoGroupFunctionOnAllNeighbors<>(neighborsFunction)).name("Neighbors function")__		default:_			throw new IllegalArgumentException("Illegal edge direction")__		}_	};groups,by,vertex,and,computes,a,group,reduce,transformation,over,the,neighbors,both,edges,and,vertices,of,each,vertex,the,neighbors,function,applied,on,the,neighbors,only,has,access,to,both,the,vertex,id,and,the,vertex,value,of,the,grouping,vertex,p,for,each,vertex,the,neighbors,function,can,iterate,over,all,neighbors,of,this,vertex,with,the,specified,direction,and,emit,any,number,of,output,elements,including,none,param,neighbors,function,the,group,reduce,function,to,apply,to,the,neighboring,edges,and,vertices,of,each,vertex,param,direction,the,edge,direction,in,out,all,param,t,the,output,type,return,a,data,set,containing,elements,of,type,t,throws,illegal,argument,exception;public,t,data,set,t,group,reduce,on,neighbors,neighbors,function,with,vertex,value,k,vv,ev,t,neighbors,function,edge,direction,direction,throws,illegal,argument,exception,switch,direction,case,in,data,set,tuple2,edge,k,ev,vertex,k,vv,edges,with,sources,edges,join,this,vertices,where,0,equal,to,0,name,edge,with,source,vertex,return,vertices,co,group,edges,with,sources,where,0,equal,to,f0,f1,with,new,apply,neighbor,co,group,function,neighbors,function,name,neighbors,function,case,out,data,set,tuple2,edge,k,ev,vertex,k,vv,edges,with,targets,edges,join,this,vertices,where,1,equal,to,0,name,edge,with,target,vertex,return,vertices,co,group,edges,with,targets,where,0,equal,to,f0,f0,with,new,apply,neighbor,co,group,function,neighbors,function,name,neighbors,function,case,all,data,set,tuple3,k,edge,k,ev,vertex,k,vv,edges,with,neighbors,edges,flat,map,new,emit,one,edge,with,neighbor,per,node,k,ev,name,forward,and,reverse,edges,join,this,vertices,where,1,equal,to,0,with,new,project,edge,with,neighbor,k,vv,ev,name,edge,with,vertex,return,vertices,co,group,edges,with,neighbors,where,0,equal,to,0,with,new,apply,co,group,function,on,all,neighbors,neighbors,function,name,neighbors,function,default,throw,new,illegal,argument,exception,illegal,edge,direction
Graph -> public <T> DataSet<T> groupReduceOnNeighbors(NeighborsFunctionWithVertexValue<K, VV, EV, T> neighborsFunction, 			EdgeDirection direction) throws IllegalArgumentException;1502111816;Groups by vertex and computes a GroupReduce transformation over the neighbors (both edges and vertices)_of each vertex. The neighborsFunction applied on the neighbors only has access to both the vertex id_and the vertex value of the grouping vertex.__<p>For each vertex, the neighborsFunction can iterate over all neighbors of this vertex_with the specified direction, and emit any number of output elements, including none.__@param neighborsFunction the group reduce function to apply to the neighboring edges and vertices_of each vertex._@param direction the edge direction (in-, out-, all-)._@param <T> the output type_@return a DataSet containing elements of type T_@throws IllegalArgumentException;public <T> DataSet<T> groupReduceOnNeighbors(NeighborsFunctionWithVertexValue<K, VV, EV, T> neighborsFunction,_			EdgeDirection direction) throws IllegalArgumentException {_		switch (direction) {_		case IN:_			_			DataSet<Tuple2<Edge<K, EV>, Vertex<K, VV>>> edgesWithSources = edges_					.join(this.vertices).where(0).equalTo(0).name("Edge with source vertex")__			return vertices.coGroup(edgesWithSources)_					.where(0).equalTo("f0.f1")_					.with(new ApplyNeighborCoGroupFunction<>(neighborsFunction)).name("Neighbors function")__		case OUT:_			_			DataSet<Tuple2<Edge<K, EV>, Vertex<K, VV>>> edgesWithTargets = edges_					.join(this.vertices).where(1).equalTo(0).name("Edge with target vertex")__			return vertices.coGroup(edgesWithTargets)_					.where(0).equalTo("f0.f0")_					.with(new ApplyNeighborCoGroupFunction<>(neighborsFunction)).name("Neighbors function")__		case ALL:_			_			DataSet<Tuple3<K, Edge<K, EV>, Vertex<K, VV>>> edgesWithNeighbors = edges_					.flatMap(new EmitOneEdgeWithNeighborPerNode<>()).name("Forward and reverse edges")_					.join(this.vertices).where(1).equalTo(0)_					.with(new ProjectEdgeWithNeighbor<>()).name("Edge with vertex")___			return vertices.coGroup(edgesWithNeighbors)_					.where(0).equalTo(0)_					.with(new ApplyCoGroupFunctionOnAllNeighbors<>(neighborsFunction)).name("Neighbors function")__		default:_			throw new IllegalArgumentException("Illegal edge direction")__		}_	};groups,by,vertex,and,computes,a,group,reduce,transformation,over,the,neighbors,both,edges,and,vertices,of,each,vertex,the,neighbors,function,applied,on,the,neighbors,only,has,access,to,both,the,vertex,id,and,the,vertex,value,of,the,grouping,vertex,p,for,each,vertex,the,neighbors,function,can,iterate,over,all,neighbors,of,this,vertex,with,the,specified,direction,and,emit,any,number,of,output,elements,including,none,param,neighbors,function,the,group,reduce,function,to,apply,to,the,neighboring,edges,and,vertices,of,each,vertex,param,direction,the,edge,direction,in,out,all,param,t,the,output,type,return,a,data,set,containing,elements,of,type,t,throws,illegal,argument,exception;public,t,data,set,t,group,reduce,on,neighbors,neighbors,function,with,vertex,value,k,vv,ev,t,neighbors,function,edge,direction,direction,throws,illegal,argument,exception,switch,direction,case,in,data,set,tuple2,edge,k,ev,vertex,k,vv,edges,with,sources,edges,join,this,vertices,where,0,equal,to,0,name,edge,with,source,vertex,return,vertices,co,group,edges,with,sources,where,0,equal,to,f0,f1,with,new,apply,neighbor,co,group,function,neighbors,function,name,neighbors,function,case,out,data,set,tuple2,edge,k,ev,vertex,k,vv,edges,with,targets,edges,join,this,vertices,where,1,equal,to,0,name,edge,with,target,vertex,return,vertices,co,group,edges,with,targets,where,0,equal,to,f0,f0,with,new,apply,neighbor,co,group,function,neighbors,function,name,neighbors,function,case,all,data,set,tuple3,k,edge,k,ev,vertex,k,vv,edges,with,neighbors,edges,flat,map,new,emit,one,edge,with,neighbor,per,node,name,forward,and,reverse,edges,join,this,vertices,where,1,equal,to,0,with,new,project,edge,with,neighbor,name,edge,with,vertex,return,vertices,co,group,edges,with,neighbors,where,0,equal,to,0,with,new,apply,co,group,function,on,all,neighbors,neighbors,function,name,neighbors,function,default,throw,new,illegal,argument,exception,illegal,edge,direction
Graph -> public static <K, EV> Graph<K, NullValue, EV> fromTupleDataSet(DataSet<Tuple3<K, K, EV>> edges, 			ExecutionEnvironment context);1444404795;Creates a graph from a DataSet of Tuple objects for edges, vertices are_induced from the edges.__Edges with value are created from Tuple3. Vertices are created_automatically and their values are set to NullValue.__@param edges a DataSet of Tuple3._@param context the flink execution environment._@return the newly created graph.;public static <K, EV> Graph<K, NullValue, EV> fromTupleDataSet(DataSet<Tuple3<K, K, EV>> edges,_			ExecutionEnvironment context) {__		DataSet<Edge<K, EV>> edgeDataSet = edges.map(new Tuple3ToEdgeMap<K, EV>())__		return fromDataSet(edgeDataSet, context)__	};creates,a,graph,from,a,data,set,of,tuple,objects,for,edges,vertices,are,induced,from,the,edges,edges,with,value,are,created,from,tuple3,vertices,are,created,automatically,and,their,values,are,set,to,null,value,param,edges,a,data,set,of,tuple3,param,context,the,flink,execution,environment,return,the,newly,created,graph;public,static,k,ev,graph,k,null,value,ev,from,tuple,data,set,data,set,tuple3,k,k,ev,edges,execution,environment,context,data,set,edge,k,ev,edge,data,set,edges,map,new,tuple3to,edge,map,k,ev,return,from,data,set,edge,data,set,context
Graph -> public static <K, EV> Graph<K, NullValue, EV> fromTupleDataSet(DataSet<Tuple3<K, K, EV>> edges, 			ExecutionEnvironment context);1445261977;Creates a graph from a DataSet of Tuple3 objects for edges._<p>_The first field of the Tuple3 object will become the source ID,_the second field will become the target ID, and the third field will become_the edge value._<p>_Vertices are created automatically and their values are set to NullValue.__@param edges a DataSet of Tuple3 representing the edges._@param context the flink execution environment._@return the newly created graph.;public static <K, EV> Graph<K, NullValue, EV> fromTupleDataSet(DataSet<Tuple3<K, K, EV>> edges,_			ExecutionEnvironment context) {__		DataSet<Edge<K, EV>> edgeDataSet = edges.map(new Tuple3ToEdgeMap<K, EV>())__		return fromDataSet(edgeDataSet, context)__	};creates,a,graph,from,a,data,set,of,tuple3,objects,for,edges,p,the,first,field,of,the,tuple3,object,will,become,the,source,id,the,second,field,will,become,the,target,id,and,the,third,field,will,become,the,edge,value,p,vertices,are,created,automatically,and,their,values,are,set,to,null,value,param,edges,a,data,set,of,tuple3,representing,the,edges,param,context,the,flink,execution,environment,return,the,newly,created,graph;public,static,k,ev,graph,k,null,value,ev,from,tuple,data,set,data,set,tuple3,k,k,ev,edges,execution,environment,context,data,set,edge,k,ev,edge,data,set,edges,map,new,tuple3to,edge,map,k,ev,return,from,data,set,edge,data,set,context
Graph -> public static <K, EV> Graph<K, NullValue, EV> fromTupleDataSet(DataSet<Tuple3<K, K, EV>> edges, 			ExecutionEnvironment context);1445854323;Creates a graph from a DataSet of Tuple3 objects for edges._<p>_The first field of the Tuple3 object will become the source ID,_the second field will become the target ID, and the third field will become_the edge value._<p>_Vertices are created automatically and their values are set to NullValue.__@param edges a DataSet of Tuple3 representing the edges._@param context the flink execution environment._@return the newly created graph.;public static <K, EV> Graph<K, NullValue, EV> fromTupleDataSet(DataSet<Tuple3<K, K, EV>> edges,_			ExecutionEnvironment context) {__		DataSet<Edge<K, EV>> edgeDataSet = edges.map(new Tuple3ToEdgeMap<K, EV>())__		return fromDataSet(edgeDataSet, context)__	};creates,a,graph,from,a,data,set,of,tuple3,objects,for,edges,p,the,first,field,of,the,tuple3,object,will,become,the,source,id,the,second,field,will,become,the,target,id,and,the,third,field,will,become,the,edge,value,p,vertices,are,created,automatically,and,their,values,are,set,to,null,value,param,edges,a,data,set,of,tuple3,representing,the,edges,param,context,the,flink,execution,environment,return,the,newly,created,graph;public,static,k,ev,graph,k,null,value,ev,from,tuple,data,set,data,set,tuple3,k,k,ev,edges,execution,environment,context,data,set,edge,k,ev,edge,data,set,edges,map,new,tuple3to,edge,map,k,ev,return,from,data,set,edge,data,set,context
Graph -> public static <K, EV> Graph<K, NullValue, EV> fromTupleDataSet(DataSet<Tuple3<K, K, EV>> edges, 			ExecutionEnvironment context);1446112342;Creates a graph from a DataSet of Tuple3 objects for edges._<p>_The first field of the Tuple3 object will become the source ID,_the second field will become the target ID, and the third field will become_the edge value._<p>_Vertices are created automatically and their values are set to NullValue.__@param edges a DataSet of Tuple3 representing the edges._@param context the flink execution environment._@return the newly created graph.;public static <K, EV> Graph<K, NullValue, EV> fromTupleDataSet(DataSet<Tuple3<K, K, EV>> edges,_			ExecutionEnvironment context) {__		DataSet<Edge<K, EV>> edgeDataSet = edges.map(new Tuple3ToEdgeMap<K, EV>())__		return fromDataSet(edgeDataSet, context)__	};creates,a,graph,from,a,data,set,of,tuple3,objects,for,edges,p,the,first,field,of,the,tuple3,object,will,become,the,source,id,the,second,field,will,become,the,target,id,and,the,third,field,will,become,the,edge,value,p,vertices,are,created,automatically,and,their,values,are,set,to,null,value,param,edges,a,data,set,of,tuple3,representing,the,edges,param,context,the,flink,execution,environment,return,the,newly,created,graph;public,static,k,ev,graph,k,null,value,ev,from,tuple,data,set,data,set,tuple3,k,k,ev,edges,execution,environment,context,data,set,edge,k,ev,edge,data,set,edges,map,new,tuple3to,edge,map,k,ev,return,from,data,set,edge,data,set,context
Graph -> public static <K, EV> Graph<K, NullValue, EV> fromTupleDataSet(DataSet<Tuple3<K, K, EV>> edges, 			ExecutionEnvironment context);1447073368;Creates a graph from a DataSet of Tuple3 objects for edges._<p>_The first field of the Tuple3 object will become the source ID,_the second field will become the target ID, and the third field will become_the edge value._<p>_Vertices are created automatically and their values are set to NullValue.__@param edges a DataSet of Tuple3 representing the edges._@param context the flink execution environment._@return the newly created graph.;public static <K, EV> Graph<K, NullValue, EV> fromTupleDataSet(DataSet<Tuple3<K, K, EV>> edges,_			ExecutionEnvironment context) {__		DataSet<Edge<K, EV>> edgeDataSet = edges.map(new Tuple3ToEdgeMap<K, EV>())__		return fromDataSet(edgeDataSet, context)__	};creates,a,graph,from,a,data,set,of,tuple3,objects,for,edges,p,the,first,field,of,the,tuple3,object,will,become,the,source,id,the,second,field,will,become,the,target,id,and,the,third,field,will,become,the,edge,value,p,vertices,are,created,automatically,and,their,values,are,set,to,null,value,param,edges,a,data,set,of,tuple3,representing,the,edges,param,context,the,flink,execution,environment,return,the,newly,created,graph;public,static,k,ev,graph,k,null,value,ev,from,tuple,data,set,data,set,tuple3,k,k,ev,edges,execution,environment,context,data,set,edge,k,ev,edge,data,set,edges,map,new,tuple3to,edge,map,k,ev,return,from,data,set,edge,data,set,context
Graph -> public static <K, EV> Graph<K, NullValue, EV> fromTupleDataSet(DataSet<Tuple3<K, K, EV>> edges, 			ExecutionEnvironment context);1454404649;Creates a graph from a DataSet of Tuple3 objects for edges._<p>_The first field of the Tuple3 object will become the source ID,_the second field will become the target ID, and the third field will become_the edge value._<p>_Vertices are created automatically and their values are set to NullValue.__@param edges a DataSet of Tuple3 representing the edges._@param context the flink execution environment._@return the newly created graph.;public static <K, EV> Graph<K, NullValue, EV> fromTupleDataSet(DataSet<Tuple3<K, K, EV>> edges,_			ExecutionEnvironment context) {__		DataSet<Edge<K, EV>> edgeDataSet = edges.map(new Tuple3ToEdgeMap<K, EV>())__		return fromDataSet(edgeDataSet, context)__	};creates,a,graph,from,a,data,set,of,tuple3,objects,for,edges,p,the,first,field,of,the,tuple3,object,will,become,the,source,id,the,second,field,will,become,the,target,id,and,the,third,field,will,become,the,edge,value,p,vertices,are,created,automatically,and,their,values,are,set,to,null,value,param,edges,a,data,set,of,tuple3,representing,the,edges,param,context,the,flink,execution,environment,return,the,newly,created,graph;public,static,k,ev,graph,k,null,value,ev,from,tuple,data,set,data,set,tuple3,k,k,ev,edges,execution,environment,context,data,set,edge,k,ev,edge,data,set,edges,map,new,tuple3to,edge,map,k,ev,return,from,data,set,edge,data,set,context
Graph -> public static <K, EV> Graph<K, NullValue, EV> fromTupleDataSet(DataSet<Tuple3<K, K, EV>> edges, 			ExecutionEnvironment context);1458583829;Creates a graph from a DataSet of Tuple3 objects for edges._<p>_The first field of the Tuple3 object will become the source ID,_the second field will become the target ID, and the third field will become_the edge value._<p>_Vertices are created automatically and their values are set to NullValue.__@param edges a DataSet of Tuple3 representing the edges._@param context the flink execution environment._@return the newly created graph.;public static <K, EV> Graph<K, NullValue, EV> fromTupleDataSet(DataSet<Tuple3<K, K, EV>> edges,_			ExecutionEnvironment context) {__		DataSet<Edge<K, EV>> edgeDataSet = edges.map(new Tuple3ToEdgeMap<K, EV>())__		return fromDataSet(edgeDataSet, context)__	};creates,a,graph,from,a,data,set,of,tuple3,objects,for,edges,p,the,first,field,of,the,tuple3,object,will,become,the,source,id,the,second,field,will,become,the,target,id,and,the,third,field,will,become,the,edge,value,p,vertices,are,created,automatically,and,their,values,are,set,to,null,value,param,edges,a,data,set,of,tuple3,representing,the,edges,param,context,the,flink,execution,environment,return,the,newly,created,graph;public,static,k,ev,graph,k,null,value,ev,from,tuple,data,set,data,set,tuple3,k,k,ev,edges,execution,environment,context,data,set,edge,k,ev,edge,data,set,edges,map,new,tuple3to,edge,map,k,ev,return,from,data,set,edge,data,set,context
Graph -> public static <K, EV> Graph<K, NullValue, EV> fromTupleDataSet(DataSet<Tuple3<K, K, EV>> edges, 			ExecutionEnvironment context);1458583829;Creates a graph from a DataSet of Tuple3 objects for edges._<p>_The first field of the Tuple3 object will become the source ID,_the second field will become the target ID, and the third field will become_the edge value._<p>_Vertices are created automatically and their values are set to NullValue.__@param edges a DataSet of Tuple3 representing the edges._@param context the flink execution environment._@return the newly created graph.;public static <K, EV> Graph<K, NullValue, EV> fromTupleDataSet(DataSet<Tuple3<K, K, EV>> edges,_			ExecutionEnvironment context) {__		DataSet<Edge<K, EV>> edgeDataSet = edges.map(new Tuple3ToEdgeMap<K, EV>())__		return fromDataSet(edgeDataSet, context)__	};creates,a,graph,from,a,data,set,of,tuple3,objects,for,edges,p,the,first,field,of,the,tuple3,object,will,become,the,source,id,the,second,field,will,become,the,target,id,and,the,third,field,will,become,the,edge,value,p,vertices,are,created,automatically,and,their,values,are,set,to,null,value,param,edges,a,data,set,of,tuple3,representing,the,edges,param,context,the,flink,execution,environment,return,the,newly,created,graph;public,static,k,ev,graph,k,null,value,ev,from,tuple,data,set,data,set,tuple3,k,k,ev,edges,execution,environment,context,data,set,edge,k,ev,edge,data,set,edges,map,new,tuple3to,edge,map,k,ev,return,from,data,set,edge,data,set,context
Graph -> public static <K, EV> Graph<K, NullValue, EV> fromTupleDataSet(DataSet<Tuple3<K, K, EV>> edges, 			ExecutionEnvironment context);1462100316;Creates a graph from a DataSet of Tuple3 objects for edges._<p>_The first field of the Tuple3 object will become the source ID,_the second field will become the target ID, and the third field will become_the edge value._<p>_Vertices are created automatically and their values are set to NullValue.__@param edges a DataSet of Tuple3 representing the edges._@param context the flink execution environment._@return the newly created graph.;public static <K, EV> Graph<K, NullValue, EV> fromTupleDataSet(DataSet<Tuple3<K, K, EV>> edges,_			ExecutionEnvironment context) {__		DataSet<Edge<K, EV>> edgeDataSet = edges.map(new Tuple3ToEdgeMap<K, EV>())__		return fromDataSet(edgeDataSet, context)__	};creates,a,graph,from,a,data,set,of,tuple3,objects,for,edges,p,the,first,field,of,the,tuple3,object,will,become,the,source,id,the,second,field,will,become,the,target,id,and,the,third,field,will,become,the,edge,value,p,vertices,are,created,automatically,and,their,values,are,set,to,null,value,param,edges,a,data,set,of,tuple3,representing,the,edges,param,context,the,flink,execution,environment,return,the,newly,created,graph;public,static,k,ev,graph,k,null,value,ev,from,tuple,data,set,data,set,tuple3,k,k,ev,edges,execution,environment,context,data,set,edge,k,ev,edge,data,set,edges,map,new,tuple3to,edge,map,k,ev,return,from,data,set,edge,data,set,context
Graph -> public static <K, EV> Graph<K, NullValue, EV> fromTupleDataSet(DataSet<Tuple3<K, K, EV>> edges, 			ExecutionEnvironment context);1462100316;Creates a graph from a DataSet of Tuple3 objects for edges._<p>_The first field of the Tuple3 object will become the source ID,_the second field will become the target ID, and the third field will become_the edge value._<p>_Vertices are created automatically and their values are set to NullValue.__@param edges a DataSet of Tuple3 representing the edges._@param context the flink execution environment._@return the newly created graph.;public static <K, EV> Graph<K, NullValue, EV> fromTupleDataSet(DataSet<Tuple3<K, K, EV>> edges,_			ExecutionEnvironment context) {__		DataSet<Edge<K, EV>> edgeDataSet = edges.map(new Tuple3ToEdgeMap<K, EV>())__		return fromDataSet(edgeDataSet, context)__	};creates,a,graph,from,a,data,set,of,tuple3,objects,for,edges,p,the,first,field,of,the,tuple3,object,will,become,the,source,id,the,second,field,will,become,the,target,id,and,the,third,field,will,become,the,edge,value,p,vertices,are,created,automatically,and,their,values,are,set,to,null,value,param,edges,a,data,set,of,tuple3,representing,the,edges,param,context,the,flink,execution,environment,return,the,newly,created,graph;public,static,k,ev,graph,k,null,value,ev,from,tuple,data,set,data,set,tuple3,k,k,ev,edges,execution,environment,context,data,set,edge,k,ev,edge,data,set,edges,map,new,tuple3to,edge,map,k,ev,return,from,data,set,edge,data,set,context
Graph -> public static <K, EV> Graph<K, NullValue, EV> fromTupleDataSet(DataSet<Tuple3<K, K, EV>> edges, 			ExecutionEnvironment context);1462205213;Creates a graph from a DataSet of Tuple3 objects for edges._<p>_The first field of the Tuple3 object will become the source ID,_the second field will become the target ID, and the third field will become_the edge value._<p>_Vertices are created automatically and their values are set to NullValue.__@param edges a DataSet of Tuple3 representing the edges._@param context the flink execution environment._@return the newly created graph.;public static <K, EV> Graph<K, NullValue, EV> fromTupleDataSet(DataSet<Tuple3<K, K, EV>> edges,_			ExecutionEnvironment context) {__		DataSet<Edge<K, EV>> edgeDataSet = edges.map(new Tuple3ToEdgeMap<K, EV>())__		return fromDataSet(edgeDataSet, context)__	};creates,a,graph,from,a,data,set,of,tuple3,objects,for,edges,p,the,first,field,of,the,tuple3,object,will,become,the,source,id,the,second,field,will,become,the,target,id,and,the,third,field,will,become,the,edge,value,p,vertices,are,created,automatically,and,their,values,are,set,to,null,value,param,edges,a,data,set,of,tuple3,representing,the,edges,param,context,the,flink,execution,environment,return,the,newly,created,graph;public,static,k,ev,graph,k,null,value,ev,from,tuple,data,set,data,set,tuple3,k,k,ev,edges,execution,environment,context,data,set,edge,k,ev,edge,data,set,edges,map,new,tuple3to,edge,map,k,ev,return,from,data,set,edge,data,set,context
Graph -> public static <K, EV> Graph<K, NullValue, EV> fromTupleDataSet(DataSet<Tuple3<K, K, EV>> edges, 			ExecutionEnvironment context);1462208859;Creates a graph from a DataSet of Tuple3 objects for edges._<p>_The first field of the Tuple3 object will become the source ID,_the second field will become the target ID, and the third field will become_the edge value._<p>_Vertices are created automatically and their values are set to NullValue.__@param edges a DataSet of Tuple3 representing the edges._@param context the flink execution environment._@return the newly created graph.;public static <K, EV> Graph<K, NullValue, EV> fromTupleDataSet(DataSet<Tuple3<K, K, EV>> edges,_			ExecutionEnvironment context) {__		DataSet<Edge<K, EV>> edgeDataSet = edges.map(new Tuple3ToEdgeMap<K, EV>())__		return fromDataSet(edgeDataSet, context)__	};creates,a,graph,from,a,data,set,of,tuple3,objects,for,edges,p,the,first,field,of,the,tuple3,object,will,become,the,source,id,the,second,field,will,become,the,target,id,and,the,third,field,will,become,the,edge,value,p,vertices,are,created,automatically,and,their,values,are,set,to,null,value,param,edges,a,data,set,of,tuple3,representing,the,edges,param,context,the,flink,execution,environment,return,the,newly,created,graph;public,static,k,ev,graph,k,null,value,ev,from,tuple,data,set,data,set,tuple3,k,k,ev,edges,execution,environment,context,data,set,edge,k,ev,edge,data,set,edges,map,new,tuple3to,edge,map,k,ev,return,from,data,set,edge,data,set,context
Graph -> public static <K, EV> Graph<K, NullValue, EV> fromTupleDataSet(DataSet<Tuple3<K, K, EV>> edges, 			ExecutionEnvironment context);1462809297;Creates a graph from a DataSet of Tuple3 objects for edges._<p>_The first field of the Tuple3 object will become the source ID,_the second field will become the target ID, and the third field will become_the edge value._<p>_Vertices are created automatically and their values are set to NullValue.__@param edges a DataSet of Tuple3 representing the edges._@param context the flink execution environment._@return the newly created graph.;public static <K, EV> Graph<K, NullValue, EV> fromTupleDataSet(DataSet<Tuple3<K, K, EV>> edges,_			ExecutionEnvironment context) {__		DataSet<Edge<K, EV>> edgeDataSet = edges.map(new Tuple3ToEdgeMap<K, EV>())__		return fromDataSet(edgeDataSet, context)__	};creates,a,graph,from,a,data,set,of,tuple3,objects,for,edges,p,the,first,field,of,the,tuple3,object,will,become,the,source,id,the,second,field,will,become,the,target,id,and,the,third,field,will,become,the,edge,value,p,vertices,are,created,automatically,and,their,values,are,set,to,null,value,param,edges,a,data,set,of,tuple3,representing,the,edges,param,context,the,flink,execution,environment,return,the,newly,created,graph;public,static,k,ev,graph,k,null,value,ev,from,tuple,data,set,data,set,tuple3,k,k,ev,edges,execution,environment,context,data,set,edge,k,ev,edge,data,set,edges,map,new,tuple3to,edge,map,k,ev,return,from,data,set,edge,data,set,context
Graph -> public static <K, EV> Graph<K, NullValue, EV> fromTupleDataSet(DataSet<Tuple3<K, K, EV>> edges, 			ExecutionEnvironment context);1465316775;Creates a graph from a DataSet of Tuple3 objects for edges._<p>_The first field of the Tuple3 object will become the source ID,_the second field will become the target ID, and the third field will become_the edge value._<p>_Vertices are created automatically and their values are set to NullValue.__@param edges a DataSet of Tuple3 representing the edges._@param context the flink execution environment._@return the newly created graph.;public static <K, EV> Graph<K, NullValue, EV> fromTupleDataSet(DataSet<Tuple3<K, K, EV>> edges,_			ExecutionEnvironment context) {__		DataSet<Edge<K, EV>> edgeDataSet = edges.map(new Tuple3ToEdgeMap<K, EV>())__		return fromDataSet(edgeDataSet, context)__	};creates,a,graph,from,a,data,set,of,tuple3,objects,for,edges,p,the,first,field,of,the,tuple3,object,will,become,the,source,id,the,second,field,will,become,the,target,id,and,the,third,field,will,become,the,edge,value,p,vertices,are,created,automatically,and,their,values,are,set,to,null,value,param,edges,a,data,set,of,tuple3,representing,the,edges,param,context,the,flink,execution,environment,return,the,newly,created,graph;public,static,k,ev,graph,k,null,value,ev,from,tuple,data,set,data,set,tuple3,k,k,ev,edges,execution,environment,context,data,set,edge,k,ev,edge,data,set,edges,map,new,tuple3to,edge,map,k,ev,return,from,data,set,edge,data,set,context
Graph -> public static <K, EV> Graph<K, NullValue, EV> fromTupleDataSet(DataSet<Tuple3<K, K, EV>> edges, 			ExecutionEnvironment context);1466789678;Creates a graph from a DataSet of Tuple3 objects for edges._<p>_The first field of the Tuple3 object will become the source ID,_the second field will become the target ID, and the third field will become_the edge value._<p>_Vertices are created automatically and their values are set to NullValue.__@param edges a DataSet of Tuple3 representing the edges._@param context the flink execution environment._@return the newly created graph.;public static <K, EV> Graph<K, NullValue, EV> fromTupleDataSet(DataSet<Tuple3<K, K, EV>> edges,_			ExecutionEnvironment context) {__		DataSet<Edge<K, EV>> edgeDataSet = edges.map(new Tuple3ToEdgeMap<K, EV>())__		return fromDataSet(edgeDataSet, context)__	};creates,a,graph,from,a,data,set,of,tuple3,objects,for,edges,p,the,first,field,of,the,tuple3,object,will,become,the,source,id,the,second,field,will,become,the,target,id,and,the,third,field,will,become,the,edge,value,p,vertices,are,created,automatically,and,their,values,are,set,to,null,value,param,edges,a,data,set,of,tuple3,representing,the,edges,param,context,the,flink,execution,environment,return,the,newly,created,graph;public,static,k,ev,graph,k,null,value,ev,from,tuple,data,set,data,set,tuple3,k,k,ev,edges,execution,environment,context,data,set,edge,k,ev,edge,data,set,edges,map,new,tuple3to,edge,map,k,ev,return,from,data,set,edge,data,set,context
Graph -> public static <K, EV> Graph<K, NullValue, EV> fromTupleDataSet(DataSet<Tuple3<K, K, EV>> edges, 			ExecutionEnvironment context);1467140656;Creates a graph from a DataSet of Tuple3 objects for edges._<p>_The first field of the Tuple3 object will become the source ID,_the second field will become the target ID, and the third field will become_the edge value._<p>_Vertices are created automatically and their values are set to NullValue.__@param edges a DataSet of Tuple3 representing the edges._@param context the flink execution environment._@return the newly created graph.;public static <K, EV> Graph<K, NullValue, EV> fromTupleDataSet(DataSet<Tuple3<K, K, EV>> edges,_			ExecutionEnvironment context) {__		DataSet<Edge<K, EV>> edgeDataSet = edges.map(new Tuple3ToEdgeMap<K, EV>())__		return fromDataSet(edgeDataSet, context)__	};creates,a,graph,from,a,data,set,of,tuple3,objects,for,edges,p,the,first,field,of,the,tuple3,object,will,become,the,source,id,the,second,field,will,become,the,target,id,and,the,third,field,will,become,the,edge,value,p,vertices,are,created,automatically,and,their,values,are,set,to,null,value,param,edges,a,data,set,of,tuple3,representing,the,edges,param,context,the,flink,execution,environment,return,the,newly,created,graph;public,static,k,ev,graph,k,null,value,ev,from,tuple,data,set,data,set,tuple3,k,k,ev,edges,execution,environment,context,data,set,edge,k,ev,edge,data,set,edges,map,new,tuple3to,edge,map,k,ev,return,from,data,set,edge,data,set,context
Graph -> public static <K, EV> Graph<K, NullValue, EV> fromTupleDataSet(DataSet<Tuple3<K, K, EV>> edges, 			ExecutionEnvironment context);1467306272;Creates a graph from a DataSet of Tuple3 objects for edges._<p>_The first field of the Tuple3 object will become the source ID,_the second field will become the target ID, and the third field will become_the edge value._<p>_Vertices are created automatically and their values are set to NullValue.__@param edges a DataSet of Tuple3 representing the edges._@param context the flink execution environment._@return the newly created graph.;public static <K, EV> Graph<K, NullValue, EV> fromTupleDataSet(DataSet<Tuple3<K, K, EV>> edges,_			ExecutionEnvironment context) {__		DataSet<Edge<K, EV>> edgeDataSet = edges.map(new Tuple3ToEdgeMap<K, EV>())__		return fromDataSet(edgeDataSet, context)__	};creates,a,graph,from,a,data,set,of,tuple3,objects,for,edges,p,the,first,field,of,the,tuple3,object,will,become,the,source,id,the,second,field,will,become,the,target,id,and,the,third,field,will,become,the,edge,value,p,vertices,are,created,automatically,and,their,values,are,set,to,null,value,param,edges,a,data,set,of,tuple3,representing,the,edges,param,context,the,flink,execution,environment,return,the,newly,created,graph;public,static,k,ev,graph,k,null,value,ev,from,tuple,data,set,data,set,tuple3,k,k,ev,edges,execution,environment,context,data,set,edge,k,ev,edge,data,set,edges,map,new,tuple3to,edge,map,k,ev,return,from,data,set,edge,data,set,context
Graph -> public static <K, EV> Graph<K, NullValue, EV> fromTupleDataSet(DataSet<Tuple3<K, K, EV>> edges, 			ExecutionEnvironment context);1470042815;Creates a graph from a DataSet of Tuple3 objects for edges._<p>_The first field of the Tuple3 object will become the source ID,_the second field will become the target ID, and the third field will become_the edge value._<p>_Vertices are created automatically and their values are set to NullValue.__@param edges a DataSet of Tuple3 representing the edges._@param context the flink execution environment._@return the newly created graph.;public static <K, EV> Graph<K, NullValue, EV> fromTupleDataSet(DataSet<Tuple3<K, K, EV>> edges,_			ExecutionEnvironment context) {__		DataSet<Edge<K, EV>> edgeDataSet = edges.map(new Tuple3ToEdgeMap<K, EV>())__		return fromDataSet(edgeDataSet, context)__	};creates,a,graph,from,a,data,set,of,tuple3,objects,for,edges,p,the,first,field,of,the,tuple3,object,will,become,the,source,id,the,second,field,will,become,the,target,id,and,the,third,field,will,become,the,edge,value,p,vertices,are,created,automatically,and,their,values,are,set,to,null,value,param,edges,a,data,set,of,tuple3,representing,the,edges,param,context,the,flink,execution,environment,return,the,newly,created,graph;public,static,k,ev,graph,k,null,value,ev,from,tuple,data,set,data,set,tuple3,k,k,ev,edges,execution,environment,context,data,set,edge,k,ev,edge,data,set,edges,map,new,tuple3to,edge,map,k,ev,return,from,data,set,edge,data,set,context
Graph -> public static <K, EV> Graph<K, NullValue, EV> fromTupleDataSet(DataSet<Tuple3<K, K, EV>> edges, 			ExecutionEnvironment context);1475684776;Creates a graph from a DataSet of Tuple3 objects for edges._<p>_The first field of the Tuple3 object will become the source ID,_the second field will become the target ID, and the third field will become_the edge value._<p>_Vertices are created automatically and their values are set to NullValue.__@param edges a DataSet of Tuple3 representing the edges._@param context the flink execution environment._@return the newly created graph.;public static <K, EV> Graph<K, NullValue, EV> fromTupleDataSet(DataSet<Tuple3<K, K, EV>> edges,_			ExecutionEnvironment context) {__		DataSet<Edge<K, EV>> edgeDataSet = edges.map(new Tuple3ToEdgeMap<K, EV>())__		return fromDataSet(edgeDataSet, context)__	};creates,a,graph,from,a,data,set,of,tuple3,objects,for,edges,p,the,first,field,of,the,tuple3,object,will,become,the,source,id,the,second,field,will,become,the,target,id,and,the,third,field,will,become,the,edge,value,p,vertices,are,created,automatically,and,their,values,are,set,to,null,value,param,edges,a,data,set,of,tuple3,representing,the,edges,param,context,the,flink,execution,environment,return,the,newly,created,graph;public,static,k,ev,graph,k,null,value,ev,from,tuple,data,set,data,set,tuple3,k,k,ev,edges,execution,environment,context,data,set,edge,k,ev,edge,data,set,edges,map,new,tuple3to,edge,map,k,ev,return,from,data,set,edge,data,set,context
Graph -> public static <K, EV> Graph<K, NullValue, EV> fromTupleDataSet(DataSet<Tuple3<K, K, EV>> edges, 			ExecutionEnvironment context);1475685606;Creates a graph from a DataSet of Tuple3 objects for edges._<p>_The first field of the Tuple3 object will become the source ID,_the second field will become the target ID, and the third field will become_the edge value._<p>_Vertices are created automatically and their values are set to NullValue.__@param edges a DataSet of Tuple3 representing the edges._@param context the flink execution environment._@return the newly created graph.;public static <K, EV> Graph<K, NullValue, EV> fromTupleDataSet(DataSet<Tuple3<K, K, EV>> edges,_			ExecutionEnvironment context) {__		DataSet<Edge<K, EV>> edgeDataSet = edges.map(new Tuple3ToEdgeMap<K, EV>())__		return fromDataSet(edgeDataSet, context)__	};creates,a,graph,from,a,data,set,of,tuple3,objects,for,edges,p,the,first,field,of,the,tuple3,object,will,become,the,source,id,the,second,field,will,become,the,target,id,and,the,third,field,will,become,the,edge,value,p,vertices,are,created,automatically,and,their,values,are,set,to,null,value,param,edges,a,data,set,of,tuple3,representing,the,edges,param,context,the,flink,execution,environment,return,the,newly,created,graph;public,static,k,ev,graph,k,null,value,ev,from,tuple,data,set,data,set,tuple3,k,k,ev,edges,execution,environment,context,data,set,edge,k,ev,edge,data,set,edges,map,new,tuple3to,edge,map,k,ev,return,from,data,set,edge,data,set,context
Graph -> public static <K, EV> Graph<K, NullValue, EV> fromTupleDataSet(DataSet<Tuple3<K, K, EV>> edges, 			ExecutionEnvironment context);1481745825;Creates a graph from a DataSet of Tuple3 objects for edges._<p>_The first field of the Tuple3 object will become the source ID,_the second field will become the target ID, and the third field will become_the edge value._<p>_Vertices are created automatically and their values are set to NullValue.__@param edges a DataSet of Tuple3 representing the edges._@param context the flink execution environment._@return the newly created graph.;public static <K, EV> Graph<K, NullValue, EV> fromTupleDataSet(DataSet<Tuple3<K, K, EV>> edges,_			ExecutionEnvironment context) {__		DataSet<Edge<K, EV>> edgeDataSet = edges_			.map(new Tuple3ToEdgeMap<K, EV>())_				.name("Type conversion")___		return fromDataSet(edgeDataSet, context)__	};creates,a,graph,from,a,data,set,of,tuple3,objects,for,edges,p,the,first,field,of,the,tuple3,object,will,become,the,source,id,the,second,field,will,become,the,target,id,and,the,third,field,will,become,the,edge,value,p,vertices,are,created,automatically,and,their,values,are,set,to,null,value,param,edges,a,data,set,of,tuple3,representing,the,edges,param,context,the,flink,execution,environment,return,the,newly,created,graph;public,static,k,ev,graph,k,null,value,ev,from,tuple,data,set,data,set,tuple3,k,k,ev,edges,execution,environment,context,data,set,edge,k,ev,edge,data,set,edges,map,new,tuple3to,edge,map,k,ev,name,type,conversion,return,from,data,set,edge,data,set,context
Graph -> public static <K, EV> Graph<K, NullValue, EV> fromTupleDataSet(DataSet<Tuple3<K, K, EV>> edges, 			ExecutionEnvironment context);1481881009;Creates a graph from a DataSet of Tuple3 objects for edges._<p>_The first field of the Tuple3 object will become the source ID,_the second field will become the target ID, and the third field will become_the edge value._<p>_Vertices are created automatically and their values are set to NullValue.__@param edges a DataSet of Tuple3 representing the edges._@param context the flink execution environment._@return the newly created graph.;public static <K, EV> Graph<K, NullValue, EV> fromTupleDataSet(DataSet<Tuple3<K, K, EV>> edges,_			ExecutionEnvironment context) {__		DataSet<Edge<K, EV>> edgeDataSet = edges_			.map(new Tuple3ToEdgeMap<K, EV>())_				.name("Type conversion")___		return fromDataSet(edgeDataSet, context)__	};creates,a,graph,from,a,data,set,of,tuple3,objects,for,edges,p,the,first,field,of,the,tuple3,object,will,become,the,source,id,the,second,field,will,become,the,target,id,and,the,third,field,will,become,the,edge,value,p,vertices,are,created,automatically,and,their,values,are,set,to,null,value,param,edges,a,data,set,of,tuple3,representing,the,edges,param,context,the,flink,execution,environment,return,the,newly,created,graph;public,static,k,ev,graph,k,null,value,ev,from,tuple,data,set,data,set,tuple3,k,k,ev,edges,execution,environment,context,data,set,edge,k,ev,edge,data,set,edges,map,new,tuple3to,edge,map,k,ev,name,type,conversion,return,from,data,set,edge,data,set,context
Graph -> public static <K, EV> Graph<K, NullValue, EV> fromTupleDataSet(DataSet<Tuple3<K, K, EV>> edges, 			ExecutionEnvironment context);1484160227;Creates a graph from a DataSet of Tuple3 objects for edges._<p>_The first field of the Tuple3 object will become the source ID,_the second field will become the target ID, and the third field will become_the edge value._<p>_Vertices are created automatically and their values are set to NullValue.__@param edges a DataSet of Tuple3 representing the edges._@param context the flink execution environment._@return the newly created graph.;public static <K, EV> Graph<K, NullValue, EV> fromTupleDataSet(DataSet<Tuple3<K, K, EV>> edges,_			ExecutionEnvironment context) {__		DataSet<Edge<K, EV>> edgeDataSet = edges_			.map(new Tuple3ToEdgeMap<K, EV>())_				.name("Type conversion")___		return fromDataSet(edgeDataSet, context)__	};creates,a,graph,from,a,data,set,of,tuple3,objects,for,edges,p,the,first,field,of,the,tuple3,object,will,become,the,source,id,the,second,field,will,become,the,target,id,and,the,third,field,will,become,the,edge,value,p,vertices,are,created,automatically,and,their,values,are,set,to,null,value,param,edges,a,data,set,of,tuple3,representing,the,edges,param,context,the,flink,execution,environment,return,the,newly,created,graph;public,static,k,ev,graph,k,null,value,ev,from,tuple,data,set,data,set,tuple3,k,k,ev,edges,execution,environment,context,data,set,edge,k,ev,edge,data,set,edges,map,new,tuple3to,edge,map,k,ev,name,type,conversion,return,from,data,set,edge,data,set,context
Graph -> public static <K, EV> Graph<K, NullValue, EV> fromTupleDataSet(DataSet<Tuple3<K, K, EV>> edges, 			ExecutionEnvironment context);1484685504;Creates a graph from a DataSet of Tuple3 objects for edges._<p>_The first field of the Tuple3 object will become the source ID,_the second field will become the target ID, and the third field will become_the edge value._<p>_Vertices are created automatically and their values are set to NullValue.__@param edges a DataSet of Tuple3 representing the edges._@param context the flink execution environment._@return the newly created graph.;public static <K, EV> Graph<K, NullValue, EV> fromTupleDataSet(DataSet<Tuple3<K, K, EV>> edges,_			ExecutionEnvironment context) {__		DataSet<Edge<K, EV>> edgeDataSet = edges_			.map(new Tuple3ToEdgeMap<K, EV>())_				.name("Type conversion")___		return fromDataSet(edgeDataSet, context)__	};creates,a,graph,from,a,data,set,of,tuple3,objects,for,edges,p,the,first,field,of,the,tuple3,object,will,become,the,source,id,the,second,field,will,become,the,target,id,and,the,third,field,will,become,the,edge,value,p,vertices,are,created,automatically,and,their,values,are,set,to,null,value,param,edges,a,data,set,of,tuple3,representing,the,edges,param,context,the,flink,execution,environment,return,the,newly,created,graph;public,static,k,ev,graph,k,null,value,ev,from,tuple,data,set,data,set,tuple3,k,k,ev,edges,execution,environment,context,data,set,edge,k,ev,edge,data,set,edges,map,new,tuple3to,edge,map,k,ev,name,type,conversion,return,from,data,set,edge,data,set,context
Graph -> public static <K, EV> Graph<K, NullValue, EV> fromTupleDataSet(DataSet<Tuple3<K, K, EV>> edges, 			ExecutionEnvironment context);1489068942;Creates a graph from a DataSet of Tuple3 objects for edges._<p>_The first field of the Tuple3 object will become the source ID,_the second field will become the target ID, and the third field will become_the edge value._<p>_Vertices are created automatically and their values are set to NullValue.__@param edges a DataSet of Tuple3 representing the edges._@param context the flink execution environment._@return the newly created graph.;public static <K, EV> Graph<K, NullValue, EV> fromTupleDataSet(DataSet<Tuple3<K, K, EV>> edges,_			ExecutionEnvironment context) {__		DataSet<Edge<K, EV>> edgeDataSet = edges_			.map(new Tuple3ToEdgeMap<K, EV>())_				.name("Type conversion")___		return fromDataSet(edgeDataSet, context)__	};creates,a,graph,from,a,data,set,of,tuple3,objects,for,edges,p,the,first,field,of,the,tuple3,object,will,become,the,source,id,the,second,field,will,become,the,target,id,and,the,third,field,will,become,the,edge,value,p,vertices,are,created,automatically,and,their,values,are,set,to,null,value,param,edges,a,data,set,of,tuple3,representing,the,edges,param,context,the,flink,execution,environment,return,the,newly,created,graph;public,static,k,ev,graph,k,null,value,ev,from,tuple,data,set,data,set,tuple3,k,k,ev,edges,execution,environment,context,data,set,edge,k,ev,edge,data,set,edges,map,new,tuple3to,edge,map,k,ev,name,type,conversion,return,from,data,set,edge,data,set,context
Graph -> public static <K, EV> Graph<K, NullValue, EV> fromTupleDataSet(DataSet<Tuple3<K, K, EV>> edges, 			ExecutionEnvironment context);1490973446;Creates a graph from a DataSet of Tuple3 objects for edges._<p>_The first field of the Tuple3 object will become the source ID,_the second field will become the target ID, and the third field will become_the edge value._<p>_Vertices are created automatically and their values are set to NullValue.__@param edges a DataSet of Tuple3 representing the edges._@param context the flink execution environment._@return the newly created graph.;public static <K, EV> Graph<K, NullValue, EV> fromTupleDataSet(DataSet<Tuple3<K, K, EV>> edges,_			ExecutionEnvironment context) {__		DataSet<Edge<K, EV>> edgeDataSet = edges_			.map(new Tuple3ToEdgeMap<K, EV>())_				.name("Type conversion")___		return fromDataSet(edgeDataSet, context)__	};creates,a,graph,from,a,data,set,of,tuple3,objects,for,edges,p,the,first,field,of,the,tuple3,object,will,become,the,source,id,the,second,field,will,become,the,target,id,and,the,third,field,will,become,the,edge,value,p,vertices,are,created,automatically,and,their,values,are,set,to,null,value,param,edges,a,data,set,of,tuple3,representing,the,edges,param,context,the,flink,execution,environment,return,the,newly,created,graph;public,static,k,ev,graph,k,null,value,ev,from,tuple,data,set,data,set,tuple3,k,k,ev,edges,execution,environment,context,data,set,edge,k,ev,edge,data,set,edges,map,new,tuple3to,edge,map,k,ev,name,type,conversion,return,from,data,set,edge,data,set,context
Graph -> public static <K, EV> Graph<K, NullValue, EV> fromTupleDataSet(DataSet<Tuple3<K, K, EV>> edges, 			ExecutionEnvironment context);1495819075;Creates a graph from a DataSet of Tuple3 objects for edges.__<p>The first field of the Tuple3 object will become the source ID,_the second field will become the target ID, and the third field will become_the edge value.__<p>Vertices are created automatically and their values are set to NullValue.__@param edges a DataSet of Tuple3 representing the edges._@param context the flink execution environment._@return the newly created graph.;public static <K, EV> Graph<K, NullValue, EV> fromTupleDataSet(DataSet<Tuple3<K, K, EV>> edges,_			ExecutionEnvironment context) {__		DataSet<Edge<K, EV>> edgeDataSet = edges_			.map(new Tuple3ToEdgeMap<K, EV>())_				.name("Type conversion")___		return fromDataSet(edgeDataSet, context)__	};creates,a,graph,from,a,data,set,of,tuple3,objects,for,edges,p,the,first,field,of,the,tuple3,object,will,become,the,source,id,the,second,field,will,become,the,target,id,and,the,third,field,will,become,the,edge,value,p,vertices,are,created,automatically,and,their,values,are,set,to,null,value,param,edges,a,data,set,of,tuple3,representing,the,edges,param,context,the,flink,execution,environment,return,the,newly,created,graph;public,static,k,ev,graph,k,null,value,ev,from,tuple,data,set,data,set,tuple3,k,k,ev,edges,execution,environment,context,data,set,edge,k,ev,edge,data,set,edges,map,new,tuple3to,edge,map,k,ev,name,type,conversion,return,from,data,set,edge,data,set,context
Graph -> public static <K, EV> Graph<K, NullValue, EV> fromTupleDataSet(DataSet<Tuple3<K, K, EV>> edges, 			ExecutionEnvironment context);1502111816;Creates a graph from a DataSet of Tuple3 objects for edges.__<p>The first field of the Tuple3 object will become the source ID,_the second field will become the target ID, and the third field will become_the edge value.__<p>Vertices are created automatically and their values are set to NullValue.__@param edges a DataSet of Tuple3 representing the edges._@param context the flink execution environment._@return the newly created graph.;public static <K, EV> Graph<K, NullValue, EV> fromTupleDataSet(DataSet<Tuple3<K, K, EV>> edges,_			ExecutionEnvironment context) {__		DataSet<Edge<K, EV>> edgeDataSet = edges_			.map(new Tuple3ToEdgeMap<>())_				.name("Type conversion")___		return fromDataSet(edgeDataSet, context)__	};creates,a,graph,from,a,data,set,of,tuple3,objects,for,edges,p,the,first,field,of,the,tuple3,object,will,become,the,source,id,the,second,field,will,become,the,target,id,and,the,third,field,will,become,the,edge,value,p,vertices,are,created,automatically,and,their,values,are,set,to,null,value,param,edges,a,data,set,of,tuple3,representing,the,edges,param,context,the,flink,execution,environment,return,the,newly,created,graph;public,static,k,ev,graph,k,null,value,ev,from,tuple,data,set,data,set,tuple3,k,k,ev,edges,execution,environment,context,data,set,edge,k,ev,edge,data,set,edges,map,new,tuple3to,edge,map,name,type,conversion,return,from,data,set,edge,data,set,context
Graph -> public static <K> Graph<K, NullValue, NullValue> fromTuple2DataSet(DataSet<Tuple2<K, K>> edges, 			ExecutionEnvironment context);1445261977;Creates a graph from a DataSet of Tuple2 objects for edges._Each Tuple2 will become one Edge, where the source ID will be the first field of the Tuple2_and the target ID will be the second field of the Tuple2._<p>_Edge value types and Vertex values types will be set to NullValue.__@param edges a DataSet of Tuple2._@param context the flink execution environment._@return the newly created graph.;public static <K> Graph<K, NullValue, NullValue> fromTuple2DataSet(DataSet<Tuple2<K, K>> edges,_			ExecutionEnvironment context) {__		DataSet<Edge<K, NullValue>> edgeDataSet = edges.map(_				new MapFunction<Tuple2<K, K>, Edge<K, NullValue>>() {__					public Edge<K, NullValue> map(Tuple2<K, K> input) {_						return new Edge<K, NullValue>(input.f0, input.f1, NullValue.getInstance())__					}_		}).withForwardedFields("f0_ f1")__		return fromDataSet(edgeDataSet, context)__	};creates,a,graph,from,a,data,set,of,tuple2,objects,for,edges,each,tuple2,will,become,one,edge,where,the,source,id,will,be,the,first,field,of,the,tuple2,and,the,target,id,will,be,the,second,field,of,the,tuple2,p,edge,value,types,and,vertex,values,types,will,be,set,to,null,value,param,edges,a,data,set,of,tuple2,param,context,the,flink,execution,environment,return,the,newly,created,graph;public,static,k,graph,k,null,value,null,value,from,tuple2data,set,data,set,tuple2,k,k,edges,execution,environment,context,data,set,edge,k,null,value,edge,data,set,edges,map,new,map,function,tuple2,k,k,edge,k,null,value,public,edge,k,null,value,map,tuple2,k,k,input,return,new,edge,k,null,value,input,f0,input,f1,null,value,get,instance,with,forwarded,fields,f0,f1,return,from,data,set,edge,data,set,context
Graph -> public static <K> Graph<K, NullValue, NullValue> fromTuple2DataSet(DataSet<Tuple2<K, K>> edges, 			ExecutionEnvironment context);1445854323;Creates a graph from a DataSet of Tuple2 objects for edges._Each Tuple2 will become one Edge, where the source ID will be the first field of the Tuple2_and the target ID will be the second field of the Tuple2._<p>_Edge value types and Vertex values types will be set to NullValue.__@param edges a DataSet of Tuple2._@param context the flink execution environment._@return the newly created graph.;public static <K> Graph<K, NullValue, NullValue> fromTuple2DataSet(DataSet<Tuple2<K, K>> edges,_			ExecutionEnvironment context) {__		DataSet<Edge<K, NullValue>> edgeDataSet = edges.map(_				new MapFunction<Tuple2<K, K>, Edge<K, NullValue>>() {__					public Edge<K, NullValue> map(Tuple2<K, K> input) {_						return new Edge<K, NullValue>(input.f0, input.f1, NullValue.getInstance())__					}_		}).withForwardedFields("f0_ f1")__		return fromDataSet(edgeDataSet, context)__	};creates,a,graph,from,a,data,set,of,tuple2,objects,for,edges,each,tuple2,will,become,one,edge,where,the,source,id,will,be,the,first,field,of,the,tuple2,and,the,target,id,will,be,the,second,field,of,the,tuple2,p,edge,value,types,and,vertex,values,types,will,be,set,to,null,value,param,edges,a,data,set,of,tuple2,param,context,the,flink,execution,environment,return,the,newly,created,graph;public,static,k,graph,k,null,value,null,value,from,tuple2data,set,data,set,tuple2,k,k,edges,execution,environment,context,data,set,edge,k,null,value,edge,data,set,edges,map,new,map,function,tuple2,k,k,edge,k,null,value,public,edge,k,null,value,map,tuple2,k,k,input,return,new,edge,k,null,value,input,f0,input,f1,null,value,get,instance,with,forwarded,fields,f0,f1,return,from,data,set,edge,data,set,context
Graph -> public static <K> Graph<K, NullValue, NullValue> fromTuple2DataSet(DataSet<Tuple2<K, K>> edges, 			ExecutionEnvironment context);1446112342;Creates a graph from a DataSet of Tuple2 objects for edges._Each Tuple2 will become one Edge, where the source ID will be the first field of the Tuple2_and the target ID will be the second field of the Tuple2._<p>_Edge value types and Vertex values types will be set to NullValue.__@param edges a DataSet of Tuple2._@param context the flink execution environment._@return the newly created graph.;public static <K> Graph<K, NullValue, NullValue> fromTuple2DataSet(DataSet<Tuple2<K, K>> edges,_			ExecutionEnvironment context) {__		DataSet<Edge<K, NullValue>> edgeDataSet = edges.map(_				new MapFunction<Tuple2<K, K>, Edge<K, NullValue>>() {__					public Edge<K, NullValue> map(Tuple2<K, K> input) {_						return new Edge<K, NullValue>(input.f0, input.f1, NullValue.getInstance())__					}_		}).withForwardedFields("f0_ f1")__		return fromDataSet(edgeDataSet, context)__	};creates,a,graph,from,a,data,set,of,tuple2,objects,for,edges,each,tuple2,will,become,one,edge,where,the,source,id,will,be,the,first,field,of,the,tuple2,and,the,target,id,will,be,the,second,field,of,the,tuple2,p,edge,value,types,and,vertex,values,types,will,be,set,to,null,value,param,edges,a,data,set,of,tuple2,param,context,the,flink,execution,environment,return,the,newly,created,graph;public,static,k,graph,k,null,value,null,value,from,tuple2data,set,data,set,tuple2,k,k,edges,execution,environment,context,data,set,edge,k,null,value,edge,data,set,edges,map,new,map,function,tuple2,k,k,edge,k,null,value,public,edge,k,null,value,map,tuple2,k,k,input,return,new,edge,k,null,value,input,f0,input,f1,null,value,get,instance,with,forwarded,fields,f0,f1,return,from,data,set,edge,data,set,context
Graph -> public static <K> Graph<K, NullValue, NullValue> fromTuple2DataSet(DataSet<Tuple2<K, K>> edges, 			ExecutionEnvironment context);1447073368;Creates a graph from a DataSet of Tuple2 objects for edges._Each Tuple2 will become one Edge, where the source ID will be the first field of the Tuple2_and the target ID will be the second field of the Tuple2._<p>_Edge value types and Vertex values types will be set to NullValue.__@param edges a DataSet of Tuple2._@param context the flink execution environment._@return the newly created graph.;public static <K> Graph<K, NullValue, NullValue> fromTuple2DataSet(DataSet<Tuple2<K, K>> edges,_			ExecutionEnvironment context) {__		DataSet<Edge<K, NullValue>> edgeDataSet = edges.map(_				new MapFunction<Tuple2<K, K>, Edge<K, NullValue>>() {__					public Edge<K, NullValue> map(Tuple2<K, K> input) {_						return new Edge<K, NullValue>(input.f0, input.f1, NullValue.getInstance())__					}_		}).withForwardedFields("f0_ f1")__		return fromDataSet(edgeDataSet, context)__	};creates,a,graph,from,a,data,set,of,tuple2,objects,for,edges,each,tuple2,will,become,one,edge,where,the,source,id,will,be,the,first,field,of,the,tuple2,and,the,target,id,will,be,the,second,field,of,the,tuple2,p,edge,value,types,and,vertex,values,types,will,be,set,to,null,value,param,edges,a,data,set,of,tuple2,param,context,the,flink,execution,environment,return,the,newly,created,graph;public,static,k,graph,k,null,value,null,value,from,tuple2data,set,data,set,tuple2,k,k,edges,execution,environment,context,data,set,edge,k,null,value,edge,data,set,edges,map,new,map,function,tuple2,k,k,edge,k,null,value,public,edge,k,null,value,map,tuple2,k,k,input,return,new,edge,k,null,value,input,f0,input,f1,null,value,get,instance,with,forwarded,fields,f0,f1,return,from,data,set,edge,data,set,context
Graph -> public static <K> Graph<K, NullValue, NullValue> fromTuple2DataSet(DataSet<Tuple2<K, K>> edges, 			ExecutionEnvironment context);1454404649;Creates a graph from a DataSet of Tuple2 objects for edges._Each Tuple2 will become one Edge, where the source ID will be the first field of the Tuple2_and the target ID will be the second field of the Tuple2._<p>_Edge value types and Vertex values types will be set to NullValue.__@param edges a DataSet of Tuple2._@param context the flink execution environment._@return the newly created graph.;public static <K> Graph<K, NullValue, NullValue> fromTuple2DataSet(DataSet<Tuple2<K, K>> edges,_			ExecutionEnvironment context) {__		DataSet<Edge<K, NullValue>> edgeDataSet = edges.map(_				new MapFunction<Tuple2<K, K>, Edge<K, NullValue>>() {__					public Edge<K, NullValue> map(Tuple2<K, K> input) {_						return new Edge<K, NullValue>(input.f0, input.f1, NullValue.getInstance())__					}_		}).withForwardedFields("f0_ f1")__		return fromDataSet(edgeDataSet, context)__	};creates,a,graph,from,a,data,set,of,tuple2,objects,for,edges,each,tuple2,will,become,one,edge,where,the,source,id,will,be,the,first,field,of,the,tuple2,and,the,target,id,will,be,the,second,field,of,the,tuple2,p,edge,value,types,and,vertex,values,types,will,be,set,to,null,value,param,edges,a,data,set,of,tuple2,param,context,the,flink,execution,environment,return,the,newly,created,graph;public,static,k,graph,k,null,value,null,value,from,tuple2data,set,data,set,tuple2,k,k,edges,execution,environment,context,data,set,edge,k,null,value,edge,data,set,edges,map,new,map,function,tuple2,k,k,edge,k,null,value,public,edge,k,null,value,map,tuple2,k,k,input,return,new,edge,k,null,value,input,f0,input,f1,null,value,get,instance,with,forwarded,fields,f0,f1,return,from,data,set,edge,data,set,context
Graph -> public static <K> Graph<K, NullValue, NullValue> fromTuple2DataSet(DataSet<Tuple2<K, K>> edges, 			ExecutionEnvironment context);1458583829;Creates a graph from a DataSet of Tuple2 objects for edges._Each Tuple2 will become one Edge, where the source ID will be the first field of the Tuple2_and the target ID will be the second field of the Tuple2._<p>_Edge value types and Vertex values types will be set to NullValue.__@param edges a DataSet of Tuple2._@param context the flink execution environment._@return the newly created graph.;public static <K> Graph<K, NullValue, NullValue> fromTuple2DataSet(DataSet<Tuple2<K, K>> edges,_			ExecutionEnvironment context) {__		DataSet<Edge<K, NullValue>> edgeDataSet = edges.map(_				new MapFunction<Tuple2<K, K>, Edge<K, NullValue>>() {__					public Edge<K, NullValue> map(Tuple2<K, K> input) {_						return new Edge<K, NullValue>(input.f0, input.f1, NullValue.getInstance())__					}_		}).withForwardedFields("f0_ f1")__		return fromDataSet(edgeDataSet, context)__	};creates,a,graph,from,a,data,set,of,tuple2,objects,for,edges,each,tuple2,will,become,one,edge,where,the,source,id,will,be,the,first,field,of,the,tuple2,and,the,target,id,will,be,the,second,field,of,the,tuple2,p,edge,value,types,and,vertex,values,types,will,be,set,to,null,value,param,edges,a,data,set,of,tuple2,param,context,the,flink,execution,environment,return,the,newly,created,graph;public,static,k,graph,k,null,value,null,value,from,tuple2data,set,data,set,tuple2,k,k,edges,execution,environment,context,data,set,edge,k,null,value,edge,data,set,edges,map,new,map,function,tuple2,k,k,edge,k,null,value,public,edge,k,null,value,map,tuple2,k,k,input,return,new,edge,k,null,value,input,f0,input,f1,null,value,get,instance,with,forwarded,fields,f0,f1,return,from,data,set,edge,data,set,context
Graph -> public static <K> Graph<K, NullValue, NullValue> fromTuple2DataSet(DataSet<Tuple2<K, K>> edges, 			ExecutionEnvironment context);1458583829;Creates a graph from a DataSet of Tuple2 objects for edges._Each Tuple2 will become one Edge, where the source ID will be the first field of the Tuple2_and the target ID will be the second field of the Tuple2._<p>_Edge value types and Vertex values types will be set to NullValue.__@param edges a DataSet of Tuple2._@param context the flink execution environment._@return the newly created graph.;public static <K> Graph<K, NullValue, NullValue> fromTuple2DataSet(DataSet<Tuple2<K, K>> edges,_			ExecutionEnvironment context) {__		DataSet<Edge<K, NullValue>> edgeDataSet = edges.map(_				new MapFunction<Tuple2<K, K>, Edge<K, NullValue>>() {__					public Edge<K, NullValue> map(Tuple2<K, K> input) {_						return new Edge<K, NullValue>(input.f0, input.f1, NullValue.getInstance())__					}_		}).withForwardedFields("f0_ f1")__		return fromDataSet(edgeDataSet, context)__	};creates,a,graph,from,a,data,set,of,tuple2,objects,for,edges,each,tuple2,will,become,one,edge,where,the,source,id,will,be,the,first,field,of,the,tuple2,and,the,target,id,will,be,the,second,field,of,the,tuple2,p,edge,value,types,and,vertex,values,types,will,be,set,to,null,value,param,edges,a,data,set,of,tuple2,param,context,the,flink,execution,environment,return,the,newly,created,graph;public,static,k,graph,k,null,value,null,value,from,tuple2data,set,data,set,tuple2,k,k,edges,execution,environment,context,data,set,edge,k,null,value,edge,data,set,edges,map,new,map,function,tuple2,k,k,edge,k,null,value,public,edge,k,null,value,map,tuple2,k,k,input,return,new,edge,k,null,value,input,f0,input,f1,null,value,get,instance,with,forwarded,fields,f0,f1,return,from,data,set,edge,data,set,context
Graph -> public static <K> Graph<K, NullValue, NullValue> fromTuple2DataSet(DataSet<Tuple2<K, K>> edges, 			ExecutionEnvironment context);1462100316;Creates a graph from a DataSet of Tuple2 objects for edges._Each Tuple2 will become one Edge, where the source ID will be the first field of the Tuple2_and the target ID will be the second field of the Tuple2._<p>_Edge value types and Vertex values types will be set to NullValue.__@param edges a DataSet of Tuple2._@param context the flink execution environment._@return the newly created graph.;public static <K> Graph<K, NullValue, NullValue> fromTuple2DataSet(DataSet<Tuple2<K, K>> edges,_			ExecutionEnvironment context) {__		DataSet<Edge<K, NullValue>> edgeDataSet = edges.map(_				new MapFunction<Tuple2<K, K>, Edge<K, NullValue>>() {__					public Edge<K, NullValue> map(Tuple2<K, K> input) {_						return new Edge<K, NullValue>(input.f0, input.f1, NullValue.getInstance())__					}_		}).withForwardedFields("f0_ f1")__		return fromDataSet(edgeDataSet, context)__	};creates,a,graph,from,a,data,set,of,tuple2,objects,for,edges,each,tuple2,will,become,one,edge,where,the,source,id,will,be,the,first,field,of,the,tuple2,and,the,target,id,will,be,the,second,field,of,the,tuple2,p,edge,value,types,and,vertex,values,types,will,be,set,to,null,value,param,edges,a,data,set,of,tuple2,param,context,the,flink,execution,environment,return,the,newly,created,graph;public,static,k,graph,k,null,value,null,value,from,tuple2data,set,data,set,tuple2,k,k,edges,execution,environment,context,data,set,edge,k,null,value,edge,data,set,edges,map,new,map,function,tuple2,k,k,edge,k,null,value,public,edge,k,null,value,map,tuple2,k,k,input,return,new,edge,k,null,value,input,f0,input,f1,null,value,get,instance,with,forwarded,fields,f0,f1,return,from,data,set,edge,data,set,context
Graph -> public static <K> Graph<K, NullValue, NullValue> fromTuple2DataSet(DataSet<Tuple2<K, K>> edges, 			ExecutionEnvironment context);1462100316;Creates a graph from a DataSet of Tuple2 objects for edges._Each Tuple2 will become one Edge, where the source ID will be the first field of the Tuple2_and the target ID will be the second field of the Tuple2._<p>_Edge value types and Vertex values types will be set to NullValue.__@param edges a DataSet of Tuple2._@param context the flink execution environment._@return the newly created graph.;public static <K> Graph<K, NullValue, NullValue> fromTuple2DataSet(DataSet<Tuple2<K, K>> edges,_			ExecutionEnvironment context) {__		DataSet<Edge<K, NullValue>> edgeDataSet = edges.map(_				new MapFunction<Tuple2<K, K>, Edge<K, NullValue>>() {__					public Edge<K, NullValue> map(Tuple2<K, K> input) {_						return new Edge<K, NullValue>(input.f0, input.f1, NullValue.getInstance())__					}_		}).withForwardedFields("f0_ f1")__		return fromDataSet(edgeDataSet, context)__	};creates,a,graph,from,a,data,set,of,tuple2,objects,for,edges,each,tuple2,will,become,one,edge,where,the,source,id,will,be,the,first,field,of,the,tuple2,and,the,target,id,will,be,the,second,field,of,the,tuple2,p,edge,value,types,and,vertex,values,types,will,be,set,to,null,value,param,edges,a,data,set,of,tuple2,param,context,the,flink,execution,environment,return,the,newly,created,graph;public,static,k,graph,k,null,value,null,value,from,tuple2data,set,data,set,tuple2,k,k,edges,execution,environment,context,data,set,edge,k,null,value,edge,data,set,edges,map,new,map,function,tuple2,k,k,edge,k,null,value,public,edge,k,null,value,map,tuple2,k,k,input,return,new,edge,k,null,value,input,f0,input,f1,null,value,get,instance,with,forwarded,fields,f0,f1,return,from,data,set,edge,data,set,context
Graph -> public static <K> Graph<K, NullValue, NullValue> fromTuple2DataSet(DataSet<Tuple2<K, K>> edges, 			ExecutionEnvironment context);1462205213;Creates a graph from a DataSet of Tuple2 objects for edges._Each Tuple2 will become one Edge, where the source ID will be the first field of the Tuple2_and the target ID will be the second field of the Tuple2._<p>_Edge value types and Vertex values types will be set to NullValue.__@param edges a DataSet of Tuple2._@param context the flink execution environment._@return the newly created graph.;public static <K> Graph<K, NullValue, NullValue> fromTuple2DataSet(DataSet<Tuple2<K, K>> edges,_			ExecutionEnvironment context) {__		DataSet<Edge<K, NullValue>> edgeDataSet = edges.map(_				new MapFunction<Tuple2<K, K>, Edge<K, NullValue>>() {__					public Edge<K, NullValue> map(Tuple2<K, K> input) {_						return new Edge<K, NullValue>(input.f0, input.f1, NullValue.getInstance())__					}_		}).withForwardedFields("f0_ f1")__		return fromDataSet(edgeDataSet, context)__	};creates,a,graph,from,a,data,set,of,tuple2,objects,for,edges,each,tuple2,will,become,one,edge,where,the,source,id,will,be,the,first,field,of,the,tuple2,and,the,target,id,will,be,the,second,field,of,the,tuple2,p,edge,value,types,and,vertex,values,types,will,be,set,to,null,value,param,edges,a,data,set,of,tuple2,param,context,the,flink,execution,environment,return,the,newly,created,graph;public,static,k,graph,k,null,value,null,value,from,tuple2data,set,data,set,tuple2,k,k,edges,execution,environment,context,data,set,edge,k,null,value,edge,data,set,edges,map,new,map,function,tuple2,k,k,edge,k,null,value,public,edge,k,null,value,map,tuple2,k,k,input,return,new,edge,k,null,value,input,f0,input,f1,null,value,get,instance,with,forwarded,fields,f0,f1,return,from,data,set,edge,data,set,context
Graph -> public static <K> Graph<K, NullValue, NullValue> fromTuple2DataSet(DataSet<Tuple2<K, K>> edges, 			ExecutionEnvironment context);1462208859;Creates a graph from a DataSet of Tuple2 objects for edges._Each Tuple2 will become one Edge, where the source ID will be the first field of the Tuple2_and the target ID will be the second field of the Tuple2._<p>_Edge value types and Vertex values types will be set to NullValue.__@param edges a DataSet of Tuple2._@param context the flink execution environment._@return the newly created graph.;public static <K> Graph<K, NullValue, NullValue> fromTuple2DataSet(DataSet<Tuple2<K, K>> edges,_			ExecutionEnvironment context) {__		DataSet<Edge<K, NullValue>> edgeDataSet = edges.map(_				new MapFunction<Tuple2<K, K>, Edge<K, NullValue>>() {__					public Edge<K, NullValue> map(Tuple2<K, K> input) {_						return new Edge<K, NullValue>(input.f0, input.f1, NullValue.getInstance())__					}_		}).withForwardedFields("f0_ f1")__		return fromDataSet(edgeDataSet, context)__	};creates,a,graph,from,a,data,set,of,tuple2,objects,for,edges,each,tuple2,will,become,one,edge,where,the,source,id,will,be,the,first,field,of,the,tuple2,and,the,target,id,will,be,the,second,field,of,the,tuple2,p,edge,value,types,and,vertex,values,types,will,be,set,to,null,value,param,edges,a,data,set,of,tuple2,param,context,the,flink,execution,environment,return,the,newly,created,graph;public,static,k,graph,k,null,value,null,value,from,tuple2data,set,data,set,tuple2,k,k,edges,execution,environment,context,data,set,edge,k,null,value,edge,data,set,edges,map,new,map,function,tuple2,k,k,edge,k,null,value,public,edge,k,null,value,map,tuple2,k,k,input,return,new,edge,k,null,value,input,f0,input,f1,null,value,get,instance,with,forwarded,fields,f0,f1,return,from,data,set,edge,data,set,context
Graph -> public static <K> Graph<K, NullValue, NullValue> fromTuple2DataSet(DataSet<Tuple2<K, K>> edges, 			ExecutionEnvironment context);1462809297;Creates a graph from a DataSet of Tuple2 objects for edges._Each Tuple2 will become one Edge, where the source ID will be the first field of the Tuple2_and the target ID will be the second field of the Tuple2._<p>_Edge value types and Vertex values types will be set to NullValue.__@param edges a DataSet of Tuple2._@param context the flink execution environment._@return the newly created graph.;public static <K> Graph<K, NullValue, NullValue> fromTuple2DataSet(DataSet<Tuple2<K, K>> edges,_			ExecutionEnvironment context) {__		DataSet<Edge<K, NullValue>> edgeDataSet = edges.map(_				new MapFunction<Tuple2<K, K>, Edge<K, NullValue>>() {__					public Edge<K, NullValue> map(Tuple2<K, K> input) {_						return new Edge<K, NullValue>(input.f0, input.f1, NullValue.getInstance())__					}_		}).withForwardedFields("f0_ f1")__		return fromDataSet(edgeDataSet, context)__	};creates,a,graph,from,a,data,set,of,tuple2,objects,for,edges,each,tuple2,will,become,one,edge,where,the,source,id,will,be,the,first,field,of,the,tuple2,and,the,target,id,will,be,the,second,field,of,the,tuple2,p,edge,value,types,and,vertex,values,types,will,be,set,to,null,value,param,edges,a,data,set,of,tuple2,param,context,the,flink,execution,environment,return,the,newly,created,graph;public,static,k,graph,k,null,value,null,value,from,tuple2data,set,data,set,tuple2,k,k,edges,execution,environment,context,data,set,edge,k,null,value,edge,data,set,edges,map,new,map,function,tuple2,k,k,edge,k,null,value,public,edge,k,null,value,map,tuple2,k,k,input,return,new,edge,k,null,value,input,f0,input,f1,null,value,get,instance,with,forwarded,fields,f0,f1,return,from,data,set,edge,data,set,context
Graph -> public static <K> Graph<K, NullValue, NullValue> fromTuple2DataSet(DataSet<Tuple2<K, K>> edges, 			ExecutionEnvironment context);1465316775;Creates a graph from a DataSet of Tuple2 objects for edges._Each Tuple2 will become one Edge, where the source ID will be the first field of the Tuple2_and the target ID will be the second field of the Tuple2._<p>_Edge value types and Vertex values types will be set to NullValue.__@param edges a DataSet of Tuple2._@param context the flink execution environment._@return the newly created graph.;public static <K> Graph<K, NullValue, NullValue> fromTuple2DataSet(DataSet<Tuple2<K, K>> edges,_			ExecutionEnvironment context) {__		DataSet<Edge<K, NullValue>> edgeDataSet = edges.map(_				new MapFunction<Tuple2<K, K>, Edge<K, NullValue>>() {__					public Edge<K, NullValue> map(Tuple2<K, K> input) {_						return new Edge<K, NullValue>(input.f0, input.f1, NullValue.getInstance())__					}_		}).withForwardedFields("f0_ f1")__		return fromDataSet(edgeDataSet, context)__	};creates,a,graph,from,a,data,set,of,tuple2,objects,for,edges,each,tuple2,will,become,one,edge,where,the,source,id,will,be,the,first,field,of,the,tuple2,and,the,target,id,will,be,the,second,field,of,the,tuple2,p,edge,value,types,and,vertex,values,types,will,be,set,to,null,value,param,edges,a,data,set,of,tuple2,param,context,the,flink,execution,environment,return,the,newly,created,graph;public,static,k,graph,k,null,value,null,value,from,tuple2data,set,data,set,tuple2,k,k,edges,execution,environment,context,data,set,edge,k,null,value,edge,data,set,edges,map,new,map,function,tuple2,k,k,edge,k,null,value,public,edge,k,null,value,map,tuple2,k,k,input,return,new,edge,k,null,value,input,f0,input,f1,null,value,get,instance,with,forwarded,fields,f0,f1,return,from,data,set,edge,data,set,context
Graph -> public static <K> Graph<K, NullValue, NullValue> fromTuple2DataSet(DataSet<Tuple2<K, K>> edges, 			ExecutionEnvironment context);1466789678;Creates a graph from a DataSet of Tuple2 objects for edges._Each Tuple2 will become one Edge, where the source ID will be the first field of the Tuple2_and the target ID will be the second field of the Tuple2._<p>_Edge value types and Vertex values types will be set to NullValue.__@param edges a DataSet of Tuple2._@param context the flink execution environment._@return the newly created graph.;public static <K> Graph<K, NullValue, NullValue> fromTuple2DataSet(DataSet<Tuple2<K, K>> edges,_			ExecutionEnvironment context) {__		DataSet<Edge<K, NullValue>> edgeDataSet = edges.map(_				new MapFunction<Tuple2<K, K>, Edge<K, NullValue>>() {__					public Edge<K, NullValue> map(Tuple2<K, K> input) {_						return new Edge<K, NullValue>(input.f0, input.f1, NullValue.getInstance())__					}_		}).withForwardedFields("f0_ f1")__		return fromDataSet(edgeDataSet, context)__	};creates,a,graph,from,a,data,set,of,tuple2,objects,for,edges,each,tuple2,will,become,one,edge,where,the,source,id,will,be,the,first,field,of,the,tuple2,and,the,target,id,will,be,the,second,field,of,the,tuple2,p,edge,value,types,and,vertex,values,types,will,be,set,to,null,value,param,edges,a,data,set,of,tuple2,param,context,the,flink,execution,environment,return,the,newly,created,graph;public,static,k,graph,k,null,value,null,value,from,tuple2data,set,data,set,tuple2,k,k,edges,execution,environment,context,data,set,edge,k,null,value,edge,data,set,edges,map,new,map,function,tuple2,k,k,edge,k,null,value,public,edge,k,null,value,map,tuple2,k,k,input,return,new,edge,k,null,value,input,f0,input,f1,null,value,get,instance,with,forwarded,fields,f0,f1,return,from,data,set,edge,data,set,context
Graph -> public static <K> Graph<K, NullValue, NullValue> fromTuple2DataSet(DataSet<Tuple2<K, K>> edges, 			ExecutionEnvironment context);1467140656;Creates a graph from a DataSet of Tuple2 objects for edges._Each Tuple2 will become one Edge, where the source ID will be the first field of the Tuple2_and the target ID will be the second field of the Tuple2._<p>_Edge value types and Vertex values types will be set to NullValue.__@param edges a DataSet of Tuple2._@param context the flink execution environment._@return the newly created graph.;public static <K> Graph<K, NullValue, NullValue> fromTuple2DataSet(DataSet<Tuple2<K, K>> edges,_			ExecutionEnvironment context) {__		DataSet<Edge<K, NullValue>> edgeDataSet = edges.map(_				new MapFunction<Tuple2<K, K>, Edge<K, NullValue>>() {__					public Edge<K, NullValue> map(Tuple2<K, K> input) {_						return new Edge<K, NullValue>(input.f0, input.f1, NullValue.getInstance())__					}_		}).withForwardedFields("f0_ f1")__		return fromDataSet(edgeDataSet, context)__	};creates,a,graph,from,a,data,set,of,tuple2,objects,for,edges,each,tuple2,will,become,one,edge,where,the,source,id,will,be,the,first,field,of,the,tuple2,and,the,target,id,will,be,the,second,field,of,the,tuple2,p,edge,value,types,and,vertex,values,types,will,be,set,to,null,value,param,edges,a,data,set,of,tuple2,param,context,the,flink,execution,environment,return,the,newly,created,graph;public,static,k,graph,k,null,value,null,value,from,tuple2data,set,data,set,tuple2,k,k,edges,execution,environment,context,data,set,edge,k,null,value,edge,data,set,edges,map,new,map,function,tuple2,k,k,edge,k,null,value,public,edge,k,null,value,map,tuple2,k,k,input,return,new,edge,k,null,value,input,f0,input,f1,null,value,get,instance,with,forwarded,fields,f0,f1,return,from,data,set,edge,data,set,context
Graph -> public static <K> Graph<K, NullValue, NullValue> fromTuple2DataSet(DataSet<Tuple2<K, K>> edges, 			ExecutionEnvironment context);1467306272;Creates a graph from a DataSet of Tuple2 objects for edges._Each Tuple2 will become one Edge, where the source ID will be the first field of the Tuple2_and the target ID will be the second field of the Tuple2._<p>_Edge value types and Vertex values types will be set to NullValue.__@param edges a DataSet of Tuple2._@param context the flink execution environment._@return the newly created graph.;public static <K> Graph<K, NullValue, NullValue> fromTuple2DataSet(DataSet<Tuple2<K, K>> edges,_			ExecutionEnvironment context) {__		DataSet<Edge<K, NullValue>> edgeDataSet = edges.map(_				new MapFunction<Tuple2<K, K>, Edge<K, NullValue>>() {__					public Edge<K, NullValue> map(Tuple2<K, K> input) {_						return new Edge<K, NullValue>(input.f0, input.f1, NullValue.getInstance())__					}_		}).withForwardedFields("f0_ f1")__		return fromDataSet(edgeDataSet, context)__	};creates,a,graph,from,a,data,set,of,tuple2,objects,for,edges,each,tuple2,will,become,one,edge,where,the,source,id,will,be,the,first,field,of,the,tuple2,and,the,target,id,will,be,the,second,field,of,the,tuple2,p,edge,value,types,and,vertex,values,types,will,be,set,to,null,value,param,edges,a,data,set,of,tuple2,param,context,the,flink,execution,environment,return,the,newly,created,graph;public,static,k,graph,k,null,value,null,value,from,tuple2data,set,data,set,tuple2,k,k,edges,execution,environment,context,data,set,edge,k,null,value,edge,data,set,edges,map,new,map,function,tuple2,k,k,edge,k,null,value,public,edge,k,null,value,map,tuple2,k,k,input,return,new,edge,k,null,value,input,f0,input,f1,null,value,get,instance,with,forwarded,fields,f0,f1,return,from,data,set,edge,data,set,context
Graph -> public static <K> Graph<K, NullValue, NullValue> fromTuple2DataSet(DataSet<Tuple2<K, K>> edges, 			ExecutionEnvironment context);1470042815;Creates a graph from a DataSet of Tuple2 objects for edges._Each Tuple2 will become one Edge, where the source ID will be the first field of the Tuple2_and the target ID will be the second field of the Tuple2._<p>_Edge value types and Vertex values types will be set to NullValue.__@param edges a DataSet of Tuple2._@param context the flink execution environment._@return the newly created graph.;public static <K> Graph<K, NullValue, NullValue> fromTuple2DataSet(DataSet<Tuple2<K, K>> edges,_			ExecutionEnvironment context) {__		DataSet<Edge<K, NullValue>> edgeDataSet = edges.map(_				new MapFunction<Tuple2<K, K>, Edge<K, NullValue>>() {__					public Edge<K, NullValue> map(Tuple2<K, K> input) {_						return new Edge<K, NullValue>(input.f0, input.f1, NullValue.getInstance())__					}_		}).withForwardedFields("f0_ f1")__		return fromDataSet(edgeDataSet, context)__	};creates,a,graph,from,a,data,set,of,tuple2,objects,for,edges,each,tuple2,will,become,one,edge,where,the,source,id,will,be,the,first,field,of,the,tuple2,and,the,target,id,will,be,the,second,field,of,the,tuple2,p,edge,value,types,and,vertex,values,types,will,be,set,to,null,value,param,edges,a,data,set,of,tuple2,param,context,the,flink,execution,environment,return,the,newly,created,graph;public,static,k,graph,k,null,value,null,value,from,tuple2data,set,data,set,tuple2,k,k,edges,execution,environment,context,data,set,edge,k,null,value,edge,data,set,edges,map,new,map,function,tuple2,k,k,edge,k,null,value,public,edge,k,null,value,map,tuple2,k,k,input,return,new,edge,k,null,value,input,f0,input,f1,null,value,get,instance,with,forwarded,fields,f0,f1,return,from,data,set,edge,data,set,context
Graph -> public static <K> Graph<K, NullValue, NullValue> fromTuple2DataSet(DataSet<Tuple2<K, K>> edges, 			ExecutionEnvironment context);1475684776;Creates a graph from a DataSet of Tuple2 objects for edges._Each Tuple2 will become one Edge, where the source ID will be the first field of the Tuple2_and the target ID will be the second field of the Tuple2._<p>_Edge value types and Vertex values types will be set to NullValue.__@param edges a DataSet of Tuple2._@param context the flink execution environment._@return the newly created graph.;public static <K> Graph<K, NullValue, NullValue> fromTuple2DataSet(DataSet<Tuple2<K, K>> edges,_			ExecutionEnvironment context) {__		DataSet<Edge<K, NullValue>> edgeDataSet = edges.map(_				new MapFunction<Tuple2<K, K>, Edge<K, NullValue>>() {__					public Edge<K, NullValue> map(Tuple2<K, K> input) {_						return new Edge<>(input.f0, input.f1, NullValue.getInstance())__					}_		}).withForwardedFields("f0_ f1")__		return fromDataSet(edgeDataSet, context)__	};creates,a,graph,from,a,data,set,of,tuple2,objects,for,edges,each,tuple2,will,become,one,edge,where,the,source,id,will,be,the,first,field,of,the,tuple2,and,the,target,id,will,be,the,second,field,of,the,tuple2,p,edge,value,types,and,vertex,values,types,will,be,set,to,null,value,param,edges,a,data,set,of,tuple2,param,context,the,flink,execution,environment,return,the,newly,created,graph;public,static,k,graph,k,null,value,null,value,from,tuple2data,set,data,set,tuple2,k,k,edges,execution,environment,context,data,set,edge,k,null,value,edge,data,set,edges,map,new,map,function,tuple2,k,k,edge,k,null,value,public,edge,k,null,value,map,tuple2,k,k,input,return,new,edge,input,f0,input,f1,null,value,get,instance,with,forwarded,fields,f0,f1,return,from,data,set,edge,data,set,context
Graph -> public static <K> Graph<K, NullValue, NullValue> fromTuple2DataSet(DataSet<Tuple2<K, K>> edges, 			ExecutionEnvironment context);1475685606;Creates a graph from a DataSet of Tuple2 objects for edges._Each Tuple2 will become one Edge, where the source ID will be the first field of the Tuple2_and the target ID will be the second field of the Tuple2._<p>_Edge value types and Vertex values types will be set to NullValue.__@param edges a DataSet of Tuple2._@param context the flink execution environment._@return the newly created graph.;public static <K> Graph<K, NullValue, NullValue> fromTuple2DataSet(DataSet<Tuple2<K, K>> edges,_			ExecutionEnvironment context) {__		DataSet<Edge<K, NullValue>> edgeDataSet = edges.map(_				new MapFunction<Tuple2<K, K>, Edge<K, NullValue>>() {__					public Edge<K, NullValue> map(Tuple2<K, K> input) {_						return new Edge<>(input.f0, input.f1, NullValue.getInstance())__					}_		}).withForwardedFields("f0_ f1")__		return fromDataSet(edgeDataSet, context)__	};creates,a,graph,from,a,data,set,of,tuple2,objects,for,edges,each,tuple2,will,become,one,edge,where,the,source,id,will,be,the,first,field,of,the,tuple2,and,the,target,id,will,be,the,second,field,of,the,tuple2,p,edge,value,types,and,vertex,values,types,will,be,set,to,null,value,param,edges,a,data,set,of,tuple2,param,context,the,flink,execution,environment,return,the,newly,created,graph;public,static,k,graph,k,null,value,null,value,from,tuple2data,set,data,set,tuple2,k,k,edges,execution,environment,context,data,set,edge,k,null,value,edge,data,set,edges,map,new,map,function,tuple2,k,k,edge,k,null,value,public,edge,k,null,value,map,tuple2,k,k,input,return,new,edge,input,f0,input,f1,null,value,get,instance,with,forwarded,fields,f0,f1,return,from,data,set,edge,data,set,context
Graph -> public static <K> Graph<K, NullValue, NullValue> fromTuple2DataSet(DataSet<Tuple2<K, K>> edges, 			ExecutionEnvironment context);1481745825;Creates a graph from a DataSet of Tuple2 objects for edges._Each Tuple2 will become one Edge, where the source ID will be the first field of the Tuple2_and the target ID will be the second field of the Tuple2._<p>_Edge value types and Vertex values types will be set to NullValue.__@param edges a DataSet of Tuple2._@param context the flink execution environment._@return the newly created graph.;public static <K> Graph<K, NullValue, NullValue> fromTuple2DataSet(DataSet<Tuple2<K, K>> edges,_			ExecutionEnvironment context) {__		DataSet<Edge<K, NullValue>> edgeDataSet = edges_			.map(new Tuple2ToEdgeMap<K>())_				.name("To Edge")___		return fromDataSet(edgeDataSet, context)__	};creates,a,graph,from,a,data,set,of,tuple2,objects,for,edges,each,tuple2,will,become,one,edge,where,the,source,id,will,be,the,first,field,of,the,tuple2,and,the,target,id,will,be,the,second,field,of,the,tuple2,p,edge,value,types,and,vertex,values,types,will,be,set,to,null,value,param,edges,a,data,set,of,tuple2,param,context,the,flink,execution,environment,return,the,newly,created,graph;public,static,k,graph,k,null,value,null,value,from,tuple2data,set,data,set,tuple2,k,k,edges,execution,environment,context,data,set,edge,k,null,value,edge,data,set,edges,map,new,tuple2to,edge,map,k,name,to,edge,return,from,data,set,edge,data,set,context
Graph -> public static <K> Graph<K, NullValue, NullValue> fromTuple2DataSet(DataSet<Tuple2<K, K>> edges, 			ExecutionEnvironment context);1481881009;Creates a graph from a DataSet of Tuple2 objects for edges._Each Tuple2 will become one Edge, where the source ID will be the first field of the Tuple2_and the target ID will be the second field of the Tuple2._<p>_Edge value types and Vertex values types will be set to NullValue.__@param edges a DataSet of Tuple2._@param context the flink execution environment._@return the newly created graph.;public static <K> Graph<K, NullValue, NullValue> fromTuple2DataSet(DataSet<Tuple2<K, K>> edges,_			ExecutionEnvironment context) {__		DataSet<Edge<K, NullValue>> edgeDataSet = edges_			.map(new Tuple2ToEdgeMap<K>())_				.name("To Edge")___		return fromDataSet(edgeDataSet, context)__	};creates,a,graph,from,a,data,set,of,tuple2,objects,for,edges,each,tuple2,will,become,one,edge,where,the,source,id,will,be,the,first,field,of,the,tuple2,and,the,target,id,will,be,the,second,field,of,the,tuple2,p,edge,value,types,and,vertex,values,types,will,be,set,to,null,value,param,edges,a,data,set,of,tuple2,param,context,the,flink,execution,environment,return,the,newly,created,graph;public,static,k,graph,k,null,value,null,value,from,tuple2data,set,data,set,tuple2,k,k,edges,execution,environment,context,data,set,edge,k,null,value,edge,data,set,edges,map,new,tuple2to,edge,map,k,name,to,edge,return,from,data,set,edge,data,set,context
Graph -> public static <K> Graph<K, NullValue, NullValue> fromTuple2DataSet(DataSet<Tuple2<K, K>> edges, 			ExecutionEnvironment context);1484160227;Creates a graph from a DataSet of Tuple2 objects for edges._Each Tuple2 will become one Edge, where the source ID will be the first field of the Tuple2_and the target ID will be the second field of the Tuple2._<p>_Edge value types and Vertex values types will be set to NullValue.__@param edges a DataSet of Tuple2._@param context the flink execution environment._@return the newly created graph.;public static <K> Graph<K, NullValue, NullValue> fromTuple2DataSet(DataSet<Tuple2<K, K>> edges,_			ExecutionEnvironment context) {__		DataSet<Edge<K, NullValue>> edgeDataSet = edges_			.map(new Tuple2ToEdgeMap<K>())_				.name("To Edge")___		return fromDataSet(edgeDataSet, context)__	};creates,a,graph,from,a,data,set,of,tuple2,objects,for,edges,each,tuple2,will,become,one,edge,where,the,source,id,will,be,the,first,field,of,the,tuple2,and,the,target,id,will,be,the,second,field,of,the,tuple2,p,edge,value,types,and,vertex,values,types,will,be,set,to,null,value,param,edges,a,data,set,of,tuple2,param,context,the,flink,execution,environment,return,the,newly,created,graph;public,static,k,graph,k,null,value,null,value,from,tuple2data,set,data,set,tuple2,k,k,edges,execution,environment,context,data,set,edge,k,null,value,edge,data,set,edges,map,new,tuple2to,edge,map,k,name,to,edge,return,from,data,set,edge,data,set,context
Graph -> public static <K> Graph<K, NullValue, NullValue> fromTuple2DataSet(DataSet<Tuple2<K, K>> edges, 			ExecutionEnvironment context);1484685504;Creates a graph from a DataSet of Tuple2 objects for edges._Each Tuple2 will become one Edge, where the source ID will be the first field of the Tuple2_and the target ID will be the second field of the Tuple2._<p>_Edge value types and Vertex values types will be set to NullValue.__@param edges a DataSet of Tuple2._@param context the flink execution environment._@return the newly created graph.;public static <K> Graph<K, NullValue, NullValue> fromTuple2DataSet(DataSet<Tuple2<K, K>> edges,_			ExecutionEnvironment context) {__		DataSet<Edge<K, NullValue>> edgeDataSet = edges_			.map(new Tuple2ToEdgeMap<K>())_				.name("To Edge")___		return fromDataSet(edgeDataSet, context)__	};creates,a,graph,from,a,data,set,of,tuple2,objects,for,edges,each,tuple2,will,become,one,edge,where,the,source,id,will,be,the,first,field,of,the,tuple2,and,the,target,id,will,be,the,second,field,of,the,tuple2,p,edge,value,types,and,vertex,values,types,will,be,set,to,null,value,param,edges,a,data,set,of,tuple2,param,context,the,flink,execution,environment,return,the,newly,created,graph;public,static,k,graph,k,null,value,null,value,from,tuple2data,set,data,set,tuple2,k,k,edges,execution,environment,context,data,set,edge,k,null,value,edge,data,set,edges,map,new,tuple2to,edge,map,k,name,to,edge,return,from,data,set,edge,data,set,context
Graph -> public static <K> Graph<K, NullValue, NullValue> fromTuple2DataSet(DataSet<Tuple2<K, K>> edges, 			ExecutionEnvironment context);1489068942;Creates a graph from a DataSet of Tuple2 objects for edges._Each Tuple2 will become one Edge, where the source ID will be the first field of the Tuple2_and the target ID will be the second field of the Tuple2._<p>_Edge value types and Vertex values types will be set to NullValue.__@param edges a DataSet of Tuple2._@param context the flink execution environment._@return the newly created graph.;public static <K> Graph<K, NullValue, NullValue> fromTuple2DataSet(DataSet<Tuple2<K, K>> edges,_			ExecutionEnvironment context) {__		DataSet<Edge<K, NullValue>> edgeDataSet = edges_			.map(new Tuple2ToEdgeMap<K>())_				.name("To Edge")___		return fromDataSet(edgeDataSet, context)__	};creates,a,graph,from,a,data,set,of,tuple2,objects,for,edges,each,tuple2,will,become,one,edge,where,the,source,id,will,be,the,first,field,of,the,tuple2,and,the,target,id,will,be,the,second,field,of,the,tuple2,p,edge,value,types,and,vertex,values,types,will,be,set,to,null,value,param,edges,a,data,set,of,tuple2,param,context,the,flink,execution,environment,return,the,newly,created,graph;public,static,k,graph,k,null,value,null,value,from,tuple2data,set,data,set,tuple2,k,k,edges,execution,environment,context,data,set,edge,k,null,value,edge,data,set,edges,map,new,tuple2to,edge,map,k,name,to,edge,return,from,data,set,edge,data,set,context
Graph -> public static <K> Graph<K, NullValue, NullValue> fromTuple2DataSet(DataSet<Tuple2<K, K>> edges, 			ExecutionEnvironment context);1490973446;Creates a graph from a DataSet of Tuple2 objects for edges._Each Tuple2 will become one Edge, where the source ID will be the first field of the Tuple2_and the target ID will be the second field of the Tuple2._<p>_Edge value types and Vertex values types will be set to NullValue.__@param edges a DataSet of Tuple2._@param context the flink execution environment._@return the newly created graph.;public static <K> Graph<K, NullValue, NullValue> fromTuple2DataSet(DataSet<Tuple2<K, K>> edges,_			ExecutionEnvironment context) {__		DataSet<Edge<K, NullValue>> edgeDataSet = edges_			.map(new Tuple2ToEdgeMap<K>())_				.name("To Edge")___		return fromDataSet(edgeDataSet, context)__	};creates,a,graph,from,a,data,set,of,tuple2,objects,for,edges,each,tuple2,will,become,one,edge,where,the,source,id,will,be,the,first,field,of,the,tuple2,and,the,target,id,will,be,the,second,field,of,the,tuple2,p,edge,value,types,and,vertex,values,types,will,be,set,to,null,value,param,edges,a,data,set,of,tuple2,param,context,the,flink,execution,environment,return,the,newly,created,graph;public,static,k,graph,k,null,value,null,value,from,tuple2data,set,data,set,tuple2,k,k,edges,execution,environment,context,data,set,edge,k,null,value,edge,data,set,edges,map,new,tuple2to,edge,map,k,name,to,edge,return,from,data,set,edge,data,set,context
Graph -> public static <K> Graph<K, NullValue, NullValue> fromTuple2DataSet(DataSet<Tuple2<K, K>> edges, 			ExecutionEnvironment context);1495819075;Creates a graph from a DataSet of Tuple2 objects for edges._Each Tuple2 will become one Edge, where the source ID will be the first field of the Tuple2_and the target ID will be the second field of the Tuple2.__<p>Edge value types and Vertex values types will be set to NullValue.__@param edges a DataSet of Tuple2._@param context the flink execution environment._@return the newly created graph.;public static <K> Graph<K, NullValue, NullValue> fromTuple2DataSet(DataSet<Tuple2<K, K>> edges,_			ExecutionEnvironment context) {__		DataSet<Edge<K, NullValue>> edgeDataSet = edges_			.map(new Tuple2ToEdgeMap<K>())_				.name("To Edge")___		return fromDataSet(edgeDataSet, context)__	};creates,a,graph,from,a,data,set,of,tuple2,objects,for,edges,each,tuple2,will,become,one,edge,where,the,source,id,will,be,the,first,field,of,the,tuple2,and,the,target,id,will,be,the,second,field,of,the,tuple2,p,edge,value,types,and,vertex,values,types,will,be,set,to,null,value,param,edges,a,data,set,of,tuple2,param,context,the,flink,execution,environment,return,the,newly,created,graph;public,static,k,graph,k,null,value,null,value,from,tuple2data,set,data,set,tuple2,k,k,edges,execution,environment,context,data,set,edge,k,null,value,edge,data,set,edges,map,new,tuple2to,edge,map,k,name,to,edge,return,from,data,set,edge,data,set,context
Graph -> public static <K> Graph<K, NullValue, NullValue> fromTuple2DataSet(DataSet<Tuple2<K, K>> edges, 			ExecutionEnvironment context);1502111816;Creates a graph from a DataSet of Tuple2 objects for edges._Each Tuple2 will become one Edge, where the source ID will be the first field of the Tuple2_and the target ID will be the second field of the Tuple2.__<p>Edge value types and Vertex values types will be set to NullValue.__@param edges a DataSet of Tuple2._@param context the flink execution environment._@return the newly created graph.;public static <K> Graph<K, NullValue, NullValue> fromTuple2DataSet(DataSet<Tuple2<K, K>> edges,_			ExecutionEnvironment context) {__		DataSet<Edge<K, NullValue>> edgeDataSet = edges_			.map(new Tuple2ToEdgeMap<>())_				.name("To Edge")___		return fromDataSet(edgeDataSet, context)__	};creates,a,graph,from,a,data,set,of,tuple2,objects,for,edges,each,tuple2,will,become,one,edge,where,the,source,id,will,be,the,first,field,of,the,tuple2,and,the,target,id,will,be,the,second,field,of,the,tuple2,p,edge,value,types,and,vertex,values,types,will,be,set,to,null,value,param,edges,a,data,set,of,tuple2,param,context,the,flink,execution,environment,return,the,newly,created,graph;public,static,k,graph,k,null,value,null,value,from,tuple2data,set,data,set,tuple2,k,k,edges,execution,environment,context,data,set,edge,k,null,value,edge,data,set,edges,map,new,tuple2to,edge,map,name,to,edge,return,from,data,set,edge,data,set,context
Graph -> public static <K, VV, EV> Graph<K, VV, EV> fromTupleDataSet(DataSet<Tuple2<K, VV>> vertices, 			DataSet<Tuple3<K, K, EV>> edges, ExecutionEnvironment context);1444404795;Creates a graph from a DataSet of Tuple objects for vertices and edges.__Vertices with value are created from Tuple2, Edges with value are created_from Tuple3.__@param vertices a DataSet of Tuple2._@param edges a DataSet of Tuple3._@param context the flink execution environment._@return the newly created graph.;public static <K, VV, EV> Graph<K, VV, EV> fromTupleDataSet(DataSet<Tuple2<K, VV>> vertices,_			DataSet<Tuple3<K, K, EV>> edges, ExecutionEnvironment context) {__		DataSet<Vertex<K, VV>> vertexDataSet = vertices.map(new Tuple2ToVertexMap<K, VV>())__		DataSet<Edge<K, EV>> edgeDataSet = edges.map(new Tuple3ToEdgeMap<K, EV>())__		return fromDataSet(vertexDataSet, edgeDataSet, context)__	};creates,a,graph,from,a,data,set,of,tuple,objects,for,vertices,and,edges,vertices,with,value,are,created,from,tuple2,edges,with,value,are,created,from,tuple3,param,vertices,a,data,set,of,tuple2,param,edges,a,data,set,of,tuple3,param,context,the,flink,execution,environment,return,the,newly,created,graph;public,static,k,vv,ev,graph,k,vv,ev,from,tuple,data,set,data,set,tuple2,k,vv,vertices,data,set,tuple3,k,k,ev,edges,execution,environment,context,data,set,vertex,k,vv,vertex,data,set,vertices,map,new,tuple2to,vertex,map,k,vv,data,set,edge,k,ev,edge,data,set,edges,map,new,tuple3to,edge,map,k,ev,return,from,data,set,vertex,data,set,edge,data,set,context
Graph -> public static <K, VV, EV> Graph<K, VV, EV> fromTupleDataSet(DataSet<Tuple2<K, VV>> vertices, 			DataSet<Tuple3<K, K, EV>> edges, ExecutionEnvironment context);1445261977;Creates a graph from a DataSet of Tuple2 objects for vertices and_Tuple3 objects for edges._<p>_The first field of the Tuple2 vertex object will become the vertex ID_and the second field will become the vertex value._The first field of the Tuple3 object for edges will become the source ID,_the second field will become the target ID, and the third field will become_the edge value.__@param vertices a DataSet of Tuple2 representing the vertices._@param edges a DataSet of Tuple3 representing the edges._@param context the flink execution environment._@return the newly created graph.;public static <K, VV, EV> Graph<K, VV, EV> fromTupleDataSet(DataSet<Tuple2<K, VV>> vertices,_			DataSet<Tuple3<K, K, EV>> edges, ExecutionEnvironment context) {__		DataSet<Vertex<K, VV>> vertexDataSet = vertices.map(new Tuple2ToVertexMap<K, VV>())__		DataSet<Edge<K, EV>> edgeDataSet = edges.map(new Tuple3ToEdgeMap<K, EV>())__		return fromDataSet(vertexDataSet, edgeDataSet, context)__	};creates,a,graph,from,a,data,set,of,tuple2,objects,for,vertices,and,tuple3,objects,for,edges,p,the,first,field,of,the,tuple2,vertex,object,will,become,the,vertex,id,and,the,second,field,will,become,the,vertex,value,the,first,field,of,the,tuple3,object,for,edges,will,become,the,source,id,the,second,field,will,become,the,target,id,and,the,third,field,will,become,the,edge,value,param,vertices,a,data,set,of,tuple2,representing,the,vertices,param,edges,a,data,set,of,tuple3,representing,the,edges,param,context,the,flink,execution,environment,return,the,newly,created,graph;public,static,k,vv,ev,graph,k,vv,ev,from,tuple,data,set,data,set,tuple2,k,vv,vertices,data,set,tuple3,k,k,ev,edges,execution,environment,context,data,set,vertex,k,vv,vertex,data,set,vertices,map,new,tuple2to,vertex,map,k,vv,data,set,edge,k,ev,edge,data,set,edges,map,new,tuple3to,edge,map,k,ev,return,from,data,set,vertex,data,set,edge,data,set,context
Graph -> public static <K, VV, EV> Graph<K, VV, EV> fromTupleDataSet(DataSet<Tuple2<K, VV>> vertices, 			DataSet<Tuple3<K, K, EV>> edges, ExecutionEnvironment context);1445854323;Creates a graph from a DataSet of Tuple2 objects for vertices and_Tuple3 objects for edges._<p>_The first field of the Tuple2 vertex object will become the vertex ID_and the second field will become the vertex value._The first field of the Tuple3 object for edges will become the source ID,_the second field will become the target ID, and the third field will become_the edge value.__@param vertices a DataSet of Tuple2 representing the vertices._@param edges a DataSet of Tuple3 representing the edges._@param context the flink execution environment._@return the newly created graph.;public static <K, VV, EV> Graph<K, VV, EV> fromTupleDataSet(DataSet<Tuple2<K, VV>> vertices,_			DataSet<Tuple3<K, K, EV>> edges, ExecutionEnvironment context) {__		DataSet<Vertex<K, VV>> vertexDataSet = vertices.map(new Tuple2ToVertexMap<K, VV>())__		DataSet<Edge<K, EV>> edgeDataSet = edges.map(new Tuple3ToEdgeMap<K, EV>())__		return fromDataSet(vertexDataSet, edgeDataSet, context)__	};creates,a,graph,from,a,data,set,of,tuple2,objects,for,vertices,and,tuple3,objects,for,edges,p,the,first,field,of,the,tuple2,vertex,object,will,become,the,vertex,id,and,the,second,field,will,become,the,vertex,value,the,first,field,of,the,tuple3,object,for,edges,will,become,the,source,id,the,second,field,will,become,the,target,id,and,the,third,field,will,become,the,edge,value,param,vertices,a,data,set,of,tuple2,representing,the,vertices,param,edges,a,data,set,of,tuple3,representing,the,edges,param,context,the,flink,execution,environment,return,the,newly,created,graph;public,static,k,vv,ev,graph,k,vv,ev,from,tuple,data,set,data,set,tuple2,k,vv,vertices,data,set,tuple3,k,k,ev,edges,execution,environment,context,data,set,vertex,k,vv,vertex,data,set,vertices,map,new,tuple2to,vertex,map,k,vv,data,set,edge,k,ev,edge,data,set,edges,map,new,tuple3to,edge,map,k,ev,return,from,data,set,vertex,data,set,edge,data,set,context
Graph -> public static <K, VV, EV> Graph<K, VV, EV> fromTupleDataSet(DataSet<Tuple2<K, VV>> vertices, 			DataSet<Tuple3<K, K, EV>> edges, ExecutionEnvironment context);1446112342;Creates a graph from a DataSet of Tuple2 objects for vertices and_Tuple3 objects for edges._<p>_The first field of the Tuple2 vertex object will become the vertex ID_and the second field will become the vertex value._The first field of the Tuple3 object for edges will become the source ID,_the second field will become the target ID, and the third field will become_the edge value.__@param vertices a DataSet of Tuple2 representing the vertices._@param edges a DataSet of Tuple3 representing the edges._@param context the flink execution environment._@return the newly created graph.;public static <K, VV, EV> Graph<K, VV, EV> fromTupleDataSet(DataSet<Tuple2<K, VV>> vertices,_			DataSet<Tuple3<K, K, EV>> edges, ExecutionEnvironment context) {__		DataSet<Vertex<K, VV>> vertexDataSet = vertices.map(new Tuple2ToVertexMap<K, VV>())__		DataSet<Edge<K, EV>> edgeDataSet = edges.map(new Tuple3ToEdgeMap<K, EV>())__		return fromDataSet(vertexDataSet, edgeDataSet, context)__	};creates,a,graph,from,a,data,set,of,tuple2,objects,for,vertices,and,tuple3,objects,for,edges,p,the,first,field,of,the,tuple2,vertex,object,will,become,the,vertex,id,and,the,second,field,will,become,the,vertex,value,the,first,field,of,the,tuple3,object,for,edges,will,become,the,source,id,the,second,field,will,become,the,target,id,and,the,third,field,will,become,the,edge,value,param,vertices,a,data,set,of,tuple2,representing,the,vertices,param,edges,a,data,set,of,tuple3,representing,the,edges,param,context,the,flink,execution,environment,return,the,newly,created,graph;public,static,k,vv,ev,graph,k,vv,ev,from,tuple,data,set,data,set,tuple2,k,vv,vertices,data,set,tuple3,k,k,ev,edges,execution,environment,context,data,set,vertex,k,vv,vertex,data,set,vertices,map,new,tuple2to,vertex,map,k,vv,data,set,edge,k,ev,edge,data,set,edges,map,new,tuple3to,edge,map,k,ev,return,from,data,set,vertex,data,set,edge,data,set,context
Graph -> public static <K, VV, EV> Graph<K, VV, EV> fromTupleDataSet(DataSet<Tuple2<K, VV>> vertices, 			DataSet<Tuple3<K, K, EV>> edges, ExecutionEnvironment context);1447073368;Creates a graph from a DataSet of Tuple2 objects for vertices and_Tuple3 objects for edges._<p>_The first field of the Tuple2 vertex object will become the vertex ID_and the second field will become the vertex value._The first field of the Tuple3 object for edges will become the source ID,_the second field will become the target ID, and the third field will become_the edge value.__@param vertices a DataSet of Tuple2 representing the vertices._@param edges a DataSet of Tuple3 representing the edges._@param context the flink execution environment._@return the newly created graph.;public static <K, VV, EV> Graph<K, VV, EV> fromTupleDataSet(DataSet<Tuple2<K, VV>> vertices,_			DataSet<Tuple3<K, K, EV>> edges, ExecutionEnvironment context) {__		DataSet<Vertex<K, VV>> vertexDataSet = vertices.map(new Tuple2ToVertexMap<K, VV>())__		DataSet<Edge<K, EV>> edgeDataSet = edges.map(new Tuple3ToEdgeMap<K, EV>())__		return fromDataSet(vertexDataSet, edgeDataSet, context)__	};creates,a,graph,from,a,data,set,of,tuple2,objects,for,vertices,and,tuple3,objects,for,edges,p,the,first,field,of,the,tuple2,vertex,object,will,become,the,vertex,id,and,the,second,field,will,become,the,vertex,value,the,first,field,of,the,tuple3,object,for,edges,will,become,the,source,id,the,second,field,will,become,the,target,id,and,the,third,field,will,become,the,edge,value,param,vertices,a,data,set,of,tuple2,representing,the,vertices,param,edges,a,data,set,of,tuple3,representing,the,edges,param,context,the,flink,execution,environment,return,the,newly,created,graph;public,static,k,vv,ev,graph,k,vv,ev,from,tuple,data,set,data,set,tuple2,k,vv,vertices,data,set,tuple3,k,k,ev,edges,execution,environment,context,data,set,vertex,k,vv,vertex,data,set,vertices,map,new,tuple2to,vertex,map,k,vv,data,set,edge,k,ev,edge,data,set,edges,map,new,tuple3to,edge,map,k,ev,return,from,data,set,vertex,data,set,edge,data,set,context
Graph -> public static <K, VV, EV> Graph<K, VV, EV> fromTupleDataSet(DataSet<Tuple2<K, VV>> vertices, 			DataSet<Tuple3<K, K, EV>> edges, ExecutionEnvironment context);1454404649;Creates a graph from a DataSet of Tuple2 objects for vertices and_Tuple3 objects for edges._<p>_The first field of the Tuple2 vertex object will become the vertex ID_and the second field will become the vertex value._The first field of the Tuple3 object for edges will become the source ID,_the second field will become the target ID, and the third field will become_the edge value.__@param vertices a DataSet of Tuple2 representing the vertices._@param edges a DataSet of Tuple3 representing the edges._@param context the flink execution environment._@return the newly created graph.;public static <K, VV, EV> Graph<K, VV, EV> fromTupleDataSet(DataSet<Tuple2<K, VV>> vertices,_			DataSet<Tuple3<K, K, EV>> edges, ExecutionEnvironment context) {__		DataSet<Vertex<K, VV>> vertexDataSet = vertices.map(new Tuple2ToVertexMap<K, VV>())__		DataSet<Edge<K, EV>> edgeDataSet = edges.map(new Tuple3ToEdgeMap<K, EV>())__		return fromDataSet(vertexDataSet, edgeDataSet, context)__	};creates,a,graph,from,a,data,set,of,tuple2,objects,for,vertices,and,tuple3,objects,for,edges,p,the,first,field,of,the,tuple2,vertex,object,will,become,the,vertex,id,and,the,second,field,will,become,the,vertex,value,the,first,field,of,the,tuple3,object,for,edges,will,become,the,source,id,the,second,field,will,become,the,target,id,and,the,third,field,will,become,the,edge,value,param,vertices,a,data,set,of,tuple2,representing,the,vertices,param,edges,a,data,set,of,tuple3,representing,the,edges,param,context,the,flink,execution,environment,return,the,newly,created,graph;public,static,k,vv,ev,graph,k,vv,ev,from,tuple,data,set,data,set,tuple2,k,vv,vertices,data,set,tuple3,k,k,ev,edges,execution,environment,context,data,set,vertex,k,vv,vertex,data,set,vertices,map,new,tuple2to,vertex,map,k,vv,data,set,edge,k,ev,edge,data,set,edges,map,new,tuple3to,edge,map,k,ev,return,from,data,set,vertex,data,set,edge,data,set,context
Graph -> public static <K, VV, EV> Graph<K, VV, EV> fromTupleDataSet(DataSet<Tuple2<K, VV>> vertices, 			DataSet<Tuple3<K, K, EV>> edges, ExecutionEnvironment context);1458583829;Creates a graph from a DataSet of Tuple2 objects for vertices and_Tuple3 objects for edges._<p>_The first field of the Tuple2 vertex object will become the vertex ID_and the second field will become the vertex value._The first field of the Tuple3 object for edges will become the source ID,_the second field will become the target ID, and the third field will become_the edge value.__@param vertices a DataSet of Tuple2 representing the vertices._@param edges a DataSet of Tuple3 representing the edges._@param context the flink execution environment._@return the newly created graph.;public static <K, VV, EV> Graph<K, VV, EV> fromTupleDataSet(DataSet<Tuple2<K, VV>> vertices,_			DataSet<Tuple3<K, K, EV>> edges, ExecutionEnvironment context) {__		DataSet<Vertex<K, VV>> vertexDataSet = vertices.map(new Tuple2ToVertexMap<K, VV>())__		DataSet<Edge<K, EV>> edgeDataSet = edges.map(new Tuple3ToEdgeMap<K, EV>())__		return fromDataSet(vertexDataSet, edgeDataSet, context)__	};creates,a,graph,from,a,data,set,of,tuple2,objects,for,vertices,and,tuple3,objects,for,edges,p,the,first,field,of,the,tuple2,vertex,object,will,become,the,vertex,id,and,the,second,field,will,become,the,vertex,value,the,first,field,of,the,tuple3,object,for,edges,will,become,the,source,id,the,second,field,will,become,the,target,id,and,the,third,field,will,become,the,edge,value,param,vertices,a,data,set,of,tuple2,representing,the,vertices,param,edges,a,data,set,of,tuple3,representing,the,edges,param,context,the,flink,execution,environment,return,the,newly,created,graph;public,static,k,vv,ev,graph,k,vv,ev,from,tuple,data,set,data,set,tuple2,k,vv,vertices,data,set,tuple3,k,k,ev,edges,execution,environment,context,data,set,vertex,k,vv,vertex,data,set,vertices,map,new,tuple2to,vertex,map,k,vv,data,set,edge,k,ev,edge,data,set,edges,map,new,tuple3to,edge,map,k,ev,return,from,data,set,vertex,data,set,edge,data,set,context
Graph -> public static <K, VV, EV> Graph<K, VV, EV> fromTupleDataSet(DataSet<Tuple2<K, VV>> vertices, 			DataSet<Tuple3<K, K, EV>> edges, ExecutionEnvironment context);1458583829;Creates a graph from a DataSet of Tuple2 objects for vertices and_Tuple3 objects for edges._<p>_The first field of the Tuple2 vertex object will become the vertex ID_and the second field will become the vertex value._The first field of the Tuple3 object for edges will become the source ID,_the second field will become the target ID, and the third field will become_the edge value.__@param vertices a DataSet of Tuple2 representing the vertices._@param edges a DataSet of Tuple3 representing the edges._@param context the flink execution environment._@return the newly created graph.;public static <K, VV, EV> Graph<K, VV, EV> fromTupleDataSet(DataSet<Tuple2<K, VV>> vertices,_			DataSet<Tuple3<K, K, EV>> edges, ExecutionEnvironment context) {__		DataSet<Vertex<K, VV>> vertexDataSet = vertices.map(new Tuple2ToVertexMap<K, VV>())__		DataSet<Edge<K, EV>> edgeDataSet = edges.map(new Tuple3ToEdgeMap<K, EV>())__		return fromDataSet(vertexDataSet, edgeDataSet, context)__	};creates,a,graph,from,a,data,set,of,tuple2,objects,for,vertices,and,tuple3,objects,for,edges,p,the,first,field,of,the,tuple2,vertex,object,will,become,the,vertex,id,and,the,second,field,will,become,the,vertex,value,the,first,field,of,the,tuple3,object,for,edges,will,become,the,source,id,the,second,field,will,become,the,target,id,and,the,third,field,will,become,the,edge,value,param,vertices,a,data,set,of,tuple2,representing,the,vertices,param,edges,a,data,set,of,tuple3,representing,the,edges,param,context,the,flink,execution,environment,return,the,newly,created,graph;public,static,k,vv,ev,graph,k,vv,ev,from,tuple,data,set,data,set,tuple2,k,vv,vertices,data,set,tuple3,k,k,ev,edges,execution,environment,context,data,set,vertex,k,vv,vertex,data,set,vertices,map,new,tuple2to,vertex,map,k,vv,data,set,edge,k,ev,edge,data,set,edges,map,new,tuple3to,edge,map,k,ev,return,from,data,set,vertex,data,set,edge,data,set,context
Graph -> public static <K, VV, EV> Graph<K, VV, EV> fromTupleDataSet(DataSet<Tuple2<K, VV>> vertices, 			DataSet<Tuple3<K, K, EV>> edges, ExecutionEnvironment context);1462100316;Creates a graph from a DataSet of Tuple2 objects for vertices and_Tuple3 objects for edges._<p>_The first field of the Tuple2 vertex object will become the vertex ID_and the second field will become the vertex value._The first field of the Tuple3 object for edges will become the source ID,_the second field will become the target ID, and the third field will become_the edge value.__@param vertices a DataSet of Tuple2 representing the vertices._@param edges a DataSet of Tuple3 representing the edges._@param context the flink execution environment._@return the newly created graph.;public static <K, VV, EV> Graph<K, VV, EV> fromTupleDataSet(DataSet<Tuple2<K, VV>> vertices,_			DataSet<Tuple3<K, K, EV>> edges, ExecutionEnvironment context) {__		DataSet<Vertex<K, VV>> vertexDataSet = vertices.map(new Tuple2ToVertexMap<K, VV>())__		DataSet<Edge<K, EV>> edgeDataSet = edges.map(new Tuple3ToEdgeMap<K, EV>())__		return fromDataSet(vertexDataSet, edgeDataSet, context)__	};creates,a,graph,from,a,data,set,of,tuple2,objects,for,vertices,and,tuple3,objects,for,edges,p,the,first,field,of,the,tuple2,vertex,object,will,become,the,vertex,id,and,the,second,field,will,become,the,vertex,value,the,first,field,of,the,tuple3,object,for,edges,will,become,the,source,id,the,second,field,will,become,the,target,id,and,the,third,field,will,become,the,edge,value,param,vertices,a,data,set,of,tuple2,representing,the,vertices,param,edges,a,data,set,of,tuple3,representing,the,edges,param,context,the,flink,execution,environment,return,the,newly,created,graph;public,static,k,vv,ev,graph,k,vv,ev,from,tuple,data,set,data,set,tuple2,k,vv,vertices,data,set,tuple3,k,k,ev,edges,execution,environment,context,data,set,vertex,k,vv,vertex,data,set,vertices,map,new,tuple2to,vertex,map,k,vv,data,set,edge,k,ev,edge,data,set,edges,map,new,tuple3to,edge,map,k,ev,return,from,data,set,vertex,data,set,edge,data,set,context
Graph -> public static <K, VV, EV> Graph<K, VV, EV> fromTupleDataSet(DataSet<Tuple2<K, VV>> vertices, 			DataSet<Tuple3<K, K, EV>> edges, ExecutionEnvironment context);1462100316;Creates a graph from a DataSet of Tuple2 objects for vertices and_Tuple3 objects for edges._<p>_The first field of the Tuple2 vertex object will become the vertex ID_and the second field will become the vertex value._The first field of the Tuple3 object for edges will become the source ID,_the second field will become the target ID, and the third field will become_the edge value.__@param vertices a DataSet of Tuple2 representing the vertices._@param edges a DataSet of Tuple3 representing the edges._@param context the flink execution environment._@return the newly created graph.;public static <K, VV, EV> Graph<K, VV, EV> fromTupleDataSet(DataSet<Tuple2<K, VV>> vertices,_			DataSet<Tuple3<K, K, EV>> edges, ExecutionEnvironment context) {__		DataSet<Vertex<K, VV>> vertexDataSet = vertices.map(new Tuple2ToVertexMap<K, VV>())__		DataSet<Edge<K, EV>> edgeDataSet = edges.map(new Tuple3ToEdgeMap<K, EV>())__		return fromDataSet(vertexDataSet, edgeDataSet, context)__	};creates,a,graph,from,a,data,set,of,tuple2,objects,for,vertices,and,tuple3,objects,for,edges,p,the,first,field,of,the,tuple2,vertex,object,will,become,the,vertex,id,and,the,second,field,will,become,the,vertex,value,the,first,field,of,the,tuple3,object,for,edges,will,become,the,source,id,the,second,field,will,become,the,target,id,and,the,third,field,will,become,the,edge,value,param,vertices,a,data,set,of,tuple2,representing,the,vertices,param,edges,a,data,set,of,tuple3,representing,the,edges,param,context,the,flink,execution,environment,return,the,newly,created,graph;public,static,k,vv,ev,graph,k,vv,ev,from,tuple,data,set,data,set,tuple2,k,vv,vertices,data,set,tuple3,k,k,ev,edges,execution,environment,context,data,set,vertex,k,vv,vertex,data,set,vertices,map,new,tuple2to,vertex,map,k,vv,data,set,edge,k,ev,edge,data,set,edges,map,new,tuple3to,edge,map,k,ev,return,from,data,set,vertex,data,set,edge,data,set,context
Graph -> public static <K, VV, EV> Graph<K, VV, EV> fromTupleDataSet(DataSet<Tuple2<K, VV>> vertices, 			DataSet<Tuple3<K, K, EV>> edges, ExecutionEnvironment context);1462205213;Creates a graph from a DataSet of Tuple2 objects for vertices and_Tuple3 objects for edges._<p>_The first field of the Tuple2 vertex object will become the vertex ID_and the second field will become the vertex value._The first field of the Tuple3 object for edges will become the source ID,_the second field will become the target ID, and the third field will become_the edge value.__@param vertices a DataSet of Tuple2 representing the vertices._@param edges a DataSet of Tuple3 representing the edges._@param context the flink execution environment._@return the newly created graph.;public static <K, VV, EV> Graph<K, VV, EV> fromTupleDataSet(DataSet<Tuple2<K, VV>> vertices,_			DataSet<Tuple3<K, K, EV>> edges, ExecutionEnvironment context) {__		DataSet<Vertex<K, VV>> vertexDataSet = vertices.map(new Tuple2ToVertexMap<K, VV>())__		DataSet<Edge<K, EV>> edgeDataSet = edges.map(new Tuple3ToEdgeMap<K, EV>())__		return fromDataSet(vertexDataSet, edgeDataSet, context)__	};creates,a,graph,from,a,data,set,of,tuple2,objects,for,vertices,and,tuple3,objects,for,edges,p,the,first,field,of,the,tuple2,vertex,object,will,become,the,vertex,id,and,the,second,field,will,become,the,vertex,value,the,first,field,of,the,tuple3,object,for,edges,will,become,the,source,id,the,second,field,will,become,the,target,id,and,the,third,field,will,become,the,edge,value,param,vertices,a,data,set,of,tuple2,representing,the,vertices,param,edges,a,data,set,of,tuple3,representing,the,edges,param,context,the,flink,execution,environment,return,the,newly,created,graph;public,static,k,vv,ev,graph,k,vv,ev,from,tuple,data,set,data,set,tuple2,k,vv,vertices,data,set,tuple3,k,k,ev,edges,execution,environment,context,data,set,vertex,k,vv,vertex,data,set,vertices,map,new,tuple2to,vertex,map,k,vv,data,set,edge,k,ev,edge,data,set,edges,map,new,tuple3to,edge,map,k,ev,return,from,data,set,vertex,data,set,edge,data,set,context
Graph -> public static <K, VV, EV> Graph<K, VV, EV> fromTupleDataSet(DataSet<Tuple2<K, VV>> vertices, 			DataSet<Tuple3<K, K, EV>> edges, ExecutionEnvironment context);1462208859;Creates a graph from a DataSet of Tuple2 objects for vertices and_Tuple3 objects for edges._<p>_The first field of the Tuple2 vertex object will become the vertex ID_and the second field will become the vertex value._The first field of the Tuple3 object for edges will become the source ID,_the second field will become the target ID, and the third field will become_the edge value.__@param vertices a DataSet of Tuple2 representing the vertices._@param edges a DataSet of Tuple3 representing the edges._@param context the flink execution environment._@return the newly created graph.;public static <K, VV, EV> Graph<K, VV, EV> fromTupleDataSet(DataSet<Tuple2<K, VV>> vertices,_			DataSet<Tuple3<K, K, EV>> edges, ExecutionEnvironment context) {__		DataSet<Vertex<K, VV>> vertexDataSet = vertices.map(new Tuple2ToVertexMap<K, VV>())__		DataSet<Edge<K, EV>> edgeDataSet = edges.map(new Tuple3ToEdgeMap<K, EV>())__		return fromDataSet(vertexDataSet, edgeDataSet, context)__	};creates,a,graph,from,a,data,set,of,tuple2,objects,for,vertices,and,tuple3,objects,for,edges,p,the,first,field,of,the,tuple2,vertex,object,will,become,the,vertex,id,and,the,second,field,will,become,the,vertex,value,the,first,field,of,the,tuple3,object,for,edges,will,become,the,source,id,the,second,field,will,become,the,target,id,and,the,third,field,will,become,the,edge,value,param,vertices,a,data,set,of,tuple2,representing,the,vertices,param,edges,a,data,set,of,tuple3,representing,the,edges,param,context,the,flink,execution,environment,return,the,newly,created,graph;public,static,k,vv,ev,graph,k,vv,ev,from,tuple,data,set,data,set,tuple2,k,vv,vertices,data,set,tuple3,k,k,ev,edges,execution,environment,context,data,set,vertex,k,vv,vertex,data,set,vertices,map,new,tuple2to,vertex,map,k,vv,data,set,edge,k,ev,edge,data,set,edges,map,new,tuple3to,edge,map,k,ev,return,from,data,set,vertex,data,set,edge,data,set,context
Graph -> public static <K, VV, EV> Graph<K, VV, EV> fromTupleDataSet(DataSet<Tuple2<K, VV>> vertices, 			DataSet<Tuple3<K, K, EV>> edges, ExecutionEnvironment context);1462809297;Creates a graph from a DataSet of Tuple2 objects for vertices and_Tuple3 objects for edges._<p>_The first field of the Tuple2 vertex object will become the vertex ID_and the second field will become the vertex value._The first field of the Tuple3 object for edges will become the source ID,_the second field will become the target ID, and the third field will become_the edge value.__@param vertices a DataSet of Tuple2 representing the vertices._@param edges a DataSet of Tuple3 representing the edges._@param context the flink execution environment._@return the newly created graph.;public static <K, VV, EV> Graph<K, VV, EV> fromTupleDataSet(DataSet<Tuple2<K, VV>> vertices,_			DataSet<Tuple3<K, K, EV>> edges, ExecutionEnvironment context) {__		DataSet<Vertex<K, VV>> vertexDataSet = vertices.map(new Tuple2ToVertexMap<K, VV>())__		DataSet<Edge<K, EV>> edgeDataSet = edges.map(new Tuple3ToEdgeMap<K, EV>())__		return fromDataSet(vertexDataSet, edgeDataSet, context)__	};creates,a,graph,from,a,data,set,of,tuple2,objects,for,vertices,and,tuple3,objects,for,edges,p,the,first,field,of,the,tuple2,vertex,object,will,become,the,vertex,id,and,the,second,field,will,become,the,vertex,value,the,first,field,of,the,tuple3,object,for,edges,will,become,the,source,id,the,second,field,will,become,the,target,id,and,the,third,field,will,become,the,edge,value,param,vertices,a,data,set,of,tuple2,representing,the,vertices,param,edges,a,data,set,of,tuple3,representing,the,edges,param,context,the,flink,execution,environment,return,the,newly,created,graph;public,static,k,vv,ev,graph,k,vv,ev,from,tuple,data,set,data,set,tuple2,k,vv,vertices,data,set,tuple3,k,k,ev,edges,execution,environment,context,data,set,vertex,k,vv,vertex,data,set,vertices,map,new,tuple2to,vertex,map,k,vv,data,set,edge,k,ev,edge,data,set,edges,map,new,tuple3to,edge,map,k,ev,return,from,data,set,vertex,data,set,edge,data,set,context
Graph -> public static <K, VV, EV> Graph<K, VV, EV> fromTupleDataSet(DataSet<Tuple2<K, VV>> vertices, 			DataSet<Tuple3<K, K, EV>> edges, ExecutionEnvironment context);1465316775;Creates a graph from a DataSet of Tuple2 objects for vertices and_Tuple3 objects for edges._<p>_The first field of the Tuple2 vertex object will become the vertex ID_and the second field will become the vertex value._The first field of the Tuple3 object for edges will become the source ID,_the second field will become the target ID, and the third field will become_the edge value.__@param vertices a DataSet of Tuple2 representing the vertices._@param edges a DataSet of Tuple3 representing the edges._@param context the flink execution environment._@return the newly created graph.;public static <K, VV, EV> Graph<K, VV, EV> fromTupleDataSet(DataSet<Tuple2<K, VV>> vertices,_			DataSet<Tuple3<K, K, EV>> edges, ExecutionEnvironment context) {__		DataSet<Vertex<K, VV>> vertexDataSet = vertices.map(new Tuple2ToVertexMap<K, VV>())__		DataSet<Edge<K, EV>> edgeDataSet = edges.map(new Tuple3ToEdgeMap<K, EV>())__		return fromDataSet(vertexDataSet, edgeDataSet, context)__	};creates,a,graph,from,a,data,set,of,tuple2,objects,for,vertices,and,tuple3,objects,for,edges,p,the,first,field,of,the,tuple2,vertex,object,will,become,the,vertex,id,and,the,second,field,will,become,the,vertex,value,the,first,field,of,the,tuple3,object,for,edges,will,become,the,source,id,the,second,field,will,become,the,target,id,and,the,third,field,will,become,the,edge,value,param,vertices,a,data,set,of,tuple2,representing,the,vertices,param,edges,a,data,set,of,tuple3,representing,the,edges,param,context,the,flink,execution,environment,return,the,newly,created,graph;public,static,k,vv,ev,graph,k,vv,ev,from,tuple,data,set,data,set,tuple2,k,vv,vertices,data,set,tuple3,k,k,ev,edges,execution,environment,context,data,set,vertex,k,vv,vertex,data,set,vertices,map,new,tuple2to,vertex,map,k,vv,data,set,edge,k,ev,edge,data,set,edges,map,new,tuple3to,edge,map,k,ev,return,from,data,set,vertex,data,set,edge,data,set,context
Graph -> public static <K, VV, EV> Graph<K, VV, EV> fromTupleDataSet(DataSet<Tuple2<K, VV>> vertices, 			DataSet<Tuple3<K, K, EV>> edges, ExecutionEnvironment context);1466789678;Creates a graph from a DataSet of Tuple2 objects for vertices and_Tuple3 objects for edges._<p>_The first field of the Tuple2 vertex object will become the vertex ID_and the second field will become the vertex value._The first field of the Tuple3 object for edges will become the source ID,_the second field will become the target ID, and the third field will become_the edge value.__@param vertices a DataSet of Tuple2 representing the vertices._@param edges a DataSet of Tuple3 representing the edges._@param context the flink execution environment._@return the newly created graph.;public static <K, VV, EV> Graph<K, VV, EV> fromTupleDataSet(DataSet<Tuple2<K, VV>> vertices,_			DataSet<Tuple3<K, K, EV>> edges, ExecutionEnvironment context) {__		DataSet<Vertex<K, VV>> vertexDataSet = vertices.map(new Tuple2ToVertexMap<K, VV>())__		DataSet<Edge<K, EV>> edgeDataSet = edges.map(new Tuple3ToEdgeMap<K, EV>())__		return fromDataSet(vertexDataSet, edgeDataSet, context)__	};creates,a,graph,from,a,data,set,of,tuple2,objects,for,vertices,and,tuple3,objects,for,edges,p,the,first,field,of,the,tuple2,vertex,object,will,become,the,vertex,id,and,the,second,field,will,become,the,vertex,value,the,first,field,of,the,tuple3,object,for,edges,will,become,the,source,id,the,second,field,will,become,the,target,id,and,the,third,field,will,become,the,edge,value,param,vertices,a,data,set,of,tuple2,representing,the,vertices,param,edges,a,data,set,of,tuple3,representing,the,edges,param,context,the,flink,execution,environment,return,the,newly,created,graph;public,static,k,vv,ev,graph,k,vv,ev,from,tuple,data,set,data,set,tuple2,k,vv,vertices,data,set,tuple3,k,k,ev,edges,execution,environment,context,data,set,vertex,k,vv,vertex,data,set,vertices,map,new,tuple2to,vertex,map,k,vv,data,set,edge,k,ev,edge,data,set,edges,map,new,tuple3to,edge,map,k,ev,return,from,data,set,vertex,data,set,edge,data,set,context
Graph -> public static <K, VV, EV> Graph<K, VV, EV> fromTupleDataSet(DataSet<Tuple2<K, VV>> vertices, 			DataSet<Tuple3<K, K, EV>> edges, ExecutionEnvironment context);1467140656;Creates a graph from a DataSet of Tuple2 objects for vertices and_Tuple3 objects for edges._<p>_The first field of the Tuple2 vertex object will become the vertex ID_and the second field will become the vertex value._The first field of the Tuple3 object for edges will become the source ID,_the second field will become the target ID, and the third field will become_the edge value.__@param vertices a DataSet of Tuple2 representing the vertices._@param edges a DataSet of Tuple3 representing the edges._@param context the flink execution environment._@return the newly created graph.;public static <K, VV, EV> Graph<K, VV, EV> fromTupleDataSet(DataSet<Tuple2<K, VV>> vertices,_			DataSet<Tuple3<K, K, EV>> edges, ExecutionEnvironment context) {__		DataSet<Vertex<K, VV>> vertexDataSet = vertices.map(new Tuple2ToVertexMap<K, VV>())__		DataSet<Edge<K, EV>> edgeDataSet = edges.map(new Tuple3ToEdgeMap<K, EV>())__		return fromDataSet(vertexDataSet, edgeDataSet, context)__	};creates,a,graph,from,a,data,set,of,tuple2,objects,for,vertices,and,tuple3,objects,for,edges,p,the,first,field,of,the,tuple2,vertex,object,will,become,the,vertex,id,and,the,second,field,will,become,the,vertex,value,the,first,field,of,the,tuple3,object,for,edges,will,become,the,source,id,the,second,field,will,become,the,target,id,and,the,third,field,will,become,the,edge,value,param,vertices,a,data,set,of,tuple2,representing,the,vertices,param,edges,a,data,set,of,tuple3,representing,the,edges,param,context,the,flink,execution,environment,return,the,newly,created,graph;public,static,k,vv,ev,graph,k,vv,ev,from,tuple,data,set,data,set,tuple2,k,vv,vertices,data,set,tuple3,k,k,ev,edges,execution,environment,context,data,set,vertex,k,vv,vertex,data,set,vertices,map,new,tuple2to,vertex,map,k,vv,data,set,edge,k,ev,edge,data,set,edges,map,new,tuple3to,edge,map,k,ev,return,from,data,set,vertex,data,set,edge,data,set,context
Graph -> public static <K, VV, EV> Graph<K, VV, EV> fromTupleDataSet(DataSet<Tuple2<K, VV>> vertices, 			DataSet<Tuple3<K, K, EV>> edges, ExecutionEnvironment context);1467306272;Creates a graph from a DataSet of Tuple2 objects for vertices and_Tuple3 objects for edges._<p>_The first field of the Tuple2 vertex object will become the vertex ID_and the second field will become the vertex value._The first field of the Tuple3 object for edges will become the source ID,_the second field will become the target ID, and the third field will become_the edge value.__@param vertices a DataSet of Tuple2 representing the vertices._@param edges a DataSet of Tuple3 representing the edges._@param context the flink execution environment._@return the newly created graph.;public static <K, VV, EV> Graph<K, VV, EV> fromTupleDataSet(DataSet<Tuple2<K, VV>> vertices,_			DataSet<Tuple3<K, K, EV>> edges, ExecutionEnvironment context) {__		DataSet<Vertex<K, VV>> vertexDataSet = vertices.map(new Tuple2ToVertexMap<K, VV>())__		DataSet<Edge<K, EV>> edgeDataSet = edges.map(new Tuple3ToEdgeMap<K, EV>())__		return fromDataSet(vertexDataSet, edgeDataSet, context)__	};creates,a,graph,from,a,data,set,of,tuple2,objects,for,vertices,and,tuple3,objects,for,edges,p,the,first,field,of,the,tuple2,vertex,object,will,become,the,vertex,id,and,the,second,field,will,become,the,vertex,value,the,first,field,of,the,tuple3,object,for,edges,will,become,the,source,id,the,second,field,will,become,the,target,id,and,the,third,field,will,become,the,edge,value,param,vertices,a,data,set,of,tuple2,representing,the,vertices,param,edges,a,data,set,of,tuple3,representing,the,edges,param,context,the,flink,execution,environment,return,the,newly,created,graph;public,static,k,vv,ev,graph,k,vv,ev,from,tuple,data,set,data,set,tuple2,k,vv,vertices,data,set,tuple3,k,k,ev,edges,execution,environment,context,data,set,vertex,k,vv,vertex,data,set,vertices,map,new,tuple2to,vertex,map,k,vv,data,set,edge,k,ev,edge,data,set,edges,map,new,tuple3to,edge,map,k,ev,return,from,data,set,vertex,data,set,edge,data,set,context
Graph -> public static <K, VV, EV> Graph<K, VV, EV> fromTupleDataSet(DataSet<Tuple2<K, VV>> vertices, 			DataSet<Tuple3<K, K, EV>> edges, ExecutionEnvironment context);1470042815;Creates a graph from a DataSet of Tuple2 objects for vertices and_Tuple3 objects for edges._<p>_The first field of the Tuple2 vertex object will become the vertex ID_and the second field will become the vertex value._The first field of the Tuple3 object for edges will become the source ID,_the second field will become the target ID, and the third field will become_the edge value.__@param vertices a DataSet of Tuple2 representing the vertices._@param edges a DataSet of Tuple3 representing the edges._@param context the flink execution environment._@return the newly created graph.;public static <K, VV, EV> Graph<K, VV, EV> fromTupleDataSet(DataSet<Tuple2<K, VV>> vertices,_			DataSet<Tuple3<K, K, EV>> edges, ExecutionEnvironment context) {__		DataSet<Vertex<K, VV>> vertexDataSet = vertices.map(new Tuple2ToVertexMap<K, VV>())__		DataSet<Edge<K, EV>> edgeDataSet = edges.map(new Tuple3ToEdgeMap<K, EV>())__		return fromDataSet(vertexDataSet, edgeDataSet, context)__	};creates,a,graph,from,a,data,set,of,tuple2,objects,for,vertices,and,tuple3,objects,for,edges,p,the,first,field,of,the,tuple2,vertex,object,will,become,the,vertex,id,and,the,second,field,will,become,the,vertex,value,the,first,field,of,the,tuple3,object,for,edges,will,become,the,source,id,the,second,field,will,become,the,target,id,and,the,third,field,will,become,the,edge,value,param,vertices,a,data,set,of,tuple2,representing,the,vertices,param,edges,a,data,set,of,tuple3,representing,the,edges,param,context,the,flink,execution,environment,return,the,newly,created,graph;public,static,k,vv,ev,graph,k,vv,ev,from,tuple,data,set,data,set,tuple2,k,vv,vertices,data,set,tuple3,k,k,ev,edges,execution,environment,context,data,set,vertex,k,vv,vertex,data,set,vertices,map,new,tuple2to,vertex,map,k,vv,data,set,edge,k,ev,edge,data,set,edges,map,new,tuple3to,edge,map,k,ev,return,from,data,set,vertex,data,set,edge,data,set,context
Graph -> public static <K, VV, EV> Graph<K, VV, EV> fromTupleDataSet(DataSet<Tuple2<K, VV>> vertices, 			DataSet<Tuple3<K, K, EV>> edges, ExecutionEnvironment context);1475684776;Creates a graph from a DataSet of Tuple2 objects for vertices and_Tuple3 objects for edges._<p>_The first field of the Tuple2 vertex object will become the vertex ID_and the second field will become the vertex value._The first field of the Tuple3 object for edges will become the source ID,_the second field will become the target ID, and the third field will become_the edge value.__@param vertices a DataSet of Tuple2 representing the vertices._@param edges a DataSet of Tuple3 representing the edges._@param context the flink execution environment._@return the newly created graph.;public static <K, VV, EV> Graph<K, VV, EV> fromTupleDataSet(DataSet<Tuple2<K, VV>> vertices,_			DataSet<Tuple3<K, K, EV>> edges, ExecutionEnvironment context) {__		DataSet<Vertex<K, VV>> vertexDataSet = vertices.map(new Tuple2ToVertexMap<K, VV>())__		DataSet<Edge<K, EV>> edgeDataSet = edges.map(new Tuple3ToEdgeMap<K, EV>())__		return fromDataSet(vertexDataSet, edgeDataSet, context)__	};creates,a,graph,from,a,data,set,of,tuple2,objects,for,vertices,and,tuple3,objects,for,edges,p,the,first,field,of,the,tuple2,vertex,object,will,become,the,vertex,id,and,the,second,field,will,become,the,vertex,value,the,first,field,of,the,tuple3,object,for,edges,will,become,the,source,id,the,second,field,will,become,the,target,id,and,the,third,field,will,become,the,edge,value,param,vertices,a,data,set,of,tuple2,representing,the,vertices,param,edges,a,data,set,of,tuple3,representing,the,edges,param,context,the,flink,execution,environment,return,the,newly,created,graph;public,static,k,vv,ev,graph,k,vv,ev,from,tuple,data,set,data,set,tuple2,k,vv,vertices,data,set,tuple3,k,k,ev,edges,execution,environment,context,data,set,vertex,k,vv,vertex,data,set,vertices,map,new,tuple2to,vertex,map,k,vv,data,set,edge,k,ev,edge,data,set,edges,map,new,tuple3to,edge,map,k,ev,return,from,data,set,vertex,data,set,edge,data,set,context
Graph -> public static <K, VV, EV> Graph<K, VV, EV> fromTupleDataSet(DataSet<Tuple2<K, VV>> vertices, 			DataSet<Tuple3<K, K, EV>> edges, ExecutionEnvironment context);1475685606;Creates a graph from a DataSet of Tuple2 objects for vertices and_Tuple3 objects for edges._<p>_The first field of the Tuple2 vertex object will become the vertex ID_and the second field will become the vertex value._The first field of the Tuple3 object for edges will become the source ID,_the second field will become the target ID, and the third field will become_the edge value.__@param vertices a DataSet of Tuple2 representing the vertices._@param edges a DataSet of Tuple3 representing the edges._@param context the flink execution environment._@return the newly created graph.;public static <K, VV, EV> Graph<K, VV, EV> fromTupleDataSet(DataSet<Tuple2<K, VV>> vertices,_			DataSet<Tuple3<K, K, EV>> edges, ExecutionEnvironment context) {__		DataSet<Vertex<K, VV>> vertexDataSet = vertices.map(new Tuple2ToVertexMap<K, VV>())__		DataSet<Edge<K, EV>> edgeDataSet = edges.map(new Tuple3ToEdgeMap<K, EV>())__		return fromDataSet(vertexDataSet, edgeDataSet, context)__	};creates,a,graph,from,a,data,set,of,tuple2,objects,for,vertices,and,tuple3,objects,for,edges,p,the,first,field,of,the,tuple2,vertex,object,will,become,the,vertex,id,and,the,second,field,will,become,the,vertex,value,the,first,field,of,the,tuple3,object,for,edges,will,become,the,source,id,the,second,field,will,become,the,target,id,and,the,third,field,will,become,the,edge,value,param,vertices,a,data,set,of,tuple2,representing,the,vertices,param,edges,a,data,set,of,tuple3,representing,the,edges,param,context,the,flink,execution,environment,return,the,newly,created,graph;public,static,k,vv,ev,graph,k,vv,ev,from,tuple,data,set,data,set,tuple2,k,vv,vertices,data,set,tuple3,k,k,ev,edges,execution,environment,context,data,set,vertex,k,vv,vertex,data,set,vertices,map,new,tuple2to,vertex,map,k,vv,data,set,edge,k,ev,edge,data,set,edges,map,new,tuple3to,edge,map,k,ev,return,from,data,set,vertex,data,set,edge,data,set,context
Graph -> public static <K, VV, EV> Graph<K, VV, EV> fromTupleDataSet(DataSet<Tuple2<K, VV>> vertices, 			DataSet<Tuple3<K, K, EV>> edges, ExecutionEnvironment context);1481745825;Creates a graph from a DataSet of Tuple2 objects for vertices and_Tuple3 objects for edges._<p>_The first field of the Tuple2 vertex object will become the vertex ID_and the second field will become the vertex value._The first field of the Tuple3 object for edges will become the source ID,_the second field will become the target ID, and the third field will become_the edge value.__@param vertices a DataSet of Tuple2 representing the vertices._@param edges a DataSet of Tuple3 representing the edges._@param context the flink execution environment._@return the newly created graph.;public static <K, VV, EV> Graph<K, VV, EV> fromTupleDataSet(DataSet<Tuple2<K, VV>> vertices,_			DataSet<Tuple3<K, K, EV>> edges, ExecutionEnvironment context) {__		DataSet<Vertex<K, VV>> vertexDataSet = vertices_			.map(new Tuple2ToVertexMap<K, VV>())_				.name("Type conversion")___		DataSet<Edge<K, EV>> edgeDataSet = edges_			.map(new Tuple3ToEdgeMap<K, EV>())_				.name("Type conversion")___		return fromDataSet(vertexDataSet, edgeDataSet, context)__	};creates,a,graph,from,a,data,set,of,tuple2,objects,for,vertices,and,tuple3,objects,for,edges,p,the,first,field,of,the,tuple2,vertex,object,will,become,the,vertex,id,and,the,second,field,will,become,the,vertex,value,the,first,field,of,the,tuple3,object,for,edges,will,become,the,source,id,the,second,field,will,become,the,target,id,and,the,third,field,will,become,the,edge,value,param,vertices,a,data,set,of,tuple2,representing,the,vertices,param,edges,a,data,set,of,tuple3,representing,the,edges,param,context,the,flink,execution,environment,return,the,newly,created,graph;public,static,k,vv,ev,graph,k,vv,ev,from,tuple,data,set,data,set,tuple2,k,vv,vertices,data,set,tuple3,k,k,ev,edges,execution,environment,context,data,set,vertex,k,vv,vertex,data,set,vertices,map,new,tuple2to,vertex,map,k,vv,name,type,conversion,data,set,edge,k,ev,edge,data,set,edges,map,new,tuple3to,edge,map,k,ev,name,type,conversion,return,from,data,set,vertex,data,set,edge,data,set,context
Graph -> public static <K, VV, EV> Graph<K, VV, EV> fromTupleDataSet(DataSet<Tuple2<K, VV>> vertices, 			DataSet<Tuple3<K, K, EV>> edges, ExecutionEnvironment context);1481881009;Creates a graph from a DataSet of Tuple2 objects for vertices and_Tuple3 objects for edges._<p>_The first field of the Tuple2 vertex object will become the vertex ID_and the second field will become the vertex value._The first field of the Tuple3 object for edges will become the source ID,_the second field will become the target ID, and the third field will become_the edge value.__@param vertices a DataSet of Tuple2 representing the vertices._@param edges a DataSet of Tuple3 representing the edges._@param context the flink execution environment._@return the newly created graph.;public static <K, VV, EV> Graph<K, VV, EV> fromTupleDataSet(DataSet<Tuple2<K, VV>> vertices,_			DataSet<Tuple3<K, K, EV>> edges, ExecutionEnvironment context) {__		DataSet<Vertex<K, VV>> vertexDataSet = vertices_			.map(new Tuple2ToVertexMap<K, VV>())_				.name("Type conversion")___		DataSet<Edge<K, EV>> edgeDataSet = edges_			.map(new Tuple3ToEdgeMap<K, EV>())_				.name("Type conversion")___		return fromDataSet(vertexDataSet, edgeDataSet, context)__	};creates,a,graph,from,a,data,set,of,tuple2,objects,for,vertices,and,tuple3,objects,for,edges,p,the,first,field,of,the,tuple2,vertex,object,will,become,the,vertex,id,and,the,second,field,will,become,the,vertex,value,the,first,field,of,the,tuple3,object,for,edges,will,become,the,source,id,the,second,field,will,become,the,target,id,and,the,third,field,will,become,the,edge,value,param,vertices,a,data,set,of,tuple2,representing,the,vertices,param,edges,a,data,set,of,tuple3,representing,the,edges,param,context,the,flink,execution,environment,return,the,newly,created,graph;public,static,k,vv,ev,graph,k,vv,ev,from,tuple,data,set,data,set,tuple2,k,vv,vertices,data,set,tuple3,k,k,ev,edges,execution,environment,context,data,set,vertex,k,vv,vertex,data,set,vertices,map,new,tuple2to,vertex,map,k,vv,name,type,conversion,data,set,edge,k,ev,edge,data,set,edges,map,new,tuple3to,edge,map,k,ev,name,type,conversion,return,from,data,set,vertex,data,set,edge,data,set,context
Graph -> public static <K, VV, EV> Graph<K, VV, EV> fromTupleDataSet(DataSet<Tuple2<K, VV>> vertices, 			DataSet<Tuple3<K, K, EV>> edges, ExecutionEnvironment context);1484160227;Creates a graph from a DataSet of Tuple2 objects for vertices and_Tuple3 objects for edges._<p>_The first field of the Tuple2 vertex object will become the vertex ID_and the second field will become the vertex value._The first field of the Tuple3 object for edges will become the source ID,_the second field will become the target ID, and the third field will become_the edge value.__@param vertices a DataSet of Tuple2 representing the vertices._@param edges a DataSet of Tuple3 representing the edges._@param context the flink execution environment._@return the newly created graph.;public static <K, VV, EV> Graph<K, VV, EV> fromTupleDataSet(DataSet<Tuple2<K, VV>> vertices,_			DataSet<Tuple3<K, K, EV>> edges, ExecutionEnvironment context) {__		DataSet<Vertex<K, VV>> vertexDataSet = vertices_			.map(new Tuple2ToVertexMap<K, VV>())_				.name("Type conversion")___		DataSet<Edge<K, EV>> edgeDataSet = edges_			.map(new Tuple3ToEdgeMap<K, EV>())_				.name("Type conversion")___		return fromDataSet(vertexDataSet, edgeDataSet, context)__	};creates,a,graph,from,a,data,set,of,tuple2,objects,for,vertices,and,tuple3,objects,for,edges,p,the,first,field,of,the,tuple2,vertex,object,will,become,the,vertex,id,and,the,second,field,will,become,the,vertex,value,the,first,field,of,the,tuple3,object,for,edges,will,become,the,source,id,the,second,field,will,become,the,target,id,and,the,third,field,will,become,the,edge,value,param,vertices,a,data,set,of,tuple2,representing,the,vertices,param,edges,a,data,set,of,tuple3,representing,the,edges,param,context,the,flink,execution,environment,return,the,newly,created,graph;public,static,k,vv,ev,graph,k,vv,ev,from,tuple,data,set,data,set,tuple2,k,vv,vertices,data,set,tuple3,k,k,ev,edges,execution,environment,context,data,set,vertex,k,vv,vertex,data,set,vertices,map,new,tuple2to,vertex,map,k,vv,name,type,conversion,data,set,edge,k,ev,edge,data,set,edges,map,new,tuple3to,edge,map,k,ev,name,type,conversion,return,from,data,set,vertex,data,set,edge,data,set,context
Graph -> public static <K, VV, EV> Graph<K, VV, EV> fromTupleDataSet(DataSet<Tuple2<K, VV>> vertices, 			DataSet<Tuple3<K, K, EV>> edges, ExecutionEnvironment context);1484685504;Creates a graph from a DataSet of Tuple2 objects for vertices and_Tuple3 objects for edges._<p>_The first field of the Tuple2 vertex object will become the vertex ID_and the second field will become the vertex value._The first field of the Tuple3 object for edges will become the source ID,_the second field will become the target ID, and the third field will become_the edge value.__@param vertices a DataSet of Tuple2 representing the vertices._@param edges a DataSet of Tuple3 representing the edges._@param context the flink execution environment._@return the newly created graph.;public static <K, VV, EV> Graph<K, VV, EV> fromTupleDataSet(DataSet<Tuple2<K, VV>> vertices,_			DataSet<Tuple3<K, K, EV>> edges, ExecutionEnvironment context) {__		DataSet<Vertex<K, VV>> vertexDataSet = vertices_			.map(new Tuple2ToVertexMap<K, VV>())_				.name("Type conversion")___		DataSet<Edge<K, EV>> edgeDataSet = edges_			.map(new Tuple3ToEdgeMap<K, EV>())_				.name("Type conversion")___		return fromDataSet(vertexDataSet, edgeDataSet, context)__	};creates,a,graph,from,a,data,set,of,tuple2,objects,for,vertices,and,tuple3,objects,for,edges,p,the,first,field,of,the,tuple2,vertex,object,will,become,the,vertex,id,and,the,second,field,will,become,the,vertex,value,the,first,field,of,the,tuple3,object,for,edges,will,become,the,source,id,the,second,field,will,become,the,target,id,and,the,third,field,will,become,the,edge,value,param,vertices,a,data,set,of,tuple2,representing,the,vertices,param,edges,a,data,set,of,tuple3,representing,the,edges,param,context,the,flink,execution,environment,return,the,newly,created,graph;public,static,k,vv,ev,graph,k,vv,ev,from,tuple,data,set,data,set,tuple2,k,vv,vertices,data,set,tuple3,k,k,ev,edges,execution,environment,context,data,set,vertex,k,vv,vertex,data,set,vertices,map,new,tuple2to,vertex,map,k,vv,name,type,conversion,data,set,edge,k,ev,edge,data,set,edges,map,new,tuple3to,edge,map,k,ev,name,type,conversion,return,from,data,set,vertex,data,set,edge,data,set,context
Graph -> public static <K, VV, EV> Graph<K, VV, EV> fromTupleDataSet(DataSet<Tuple2<K, VV>> vertices, 			DataSet<Tuple3<K, K, EV>> edges, ExecutionEnvironment context);1489068942;Creates a graph from a DataSet of Tuple2 objects for vertices and_Tuple3 objects for edges._<p>_The first field of the Tuple2 vertex object will become the vertex ID_and the second field will become the vertex value._The first field of the Tuple3 object for edges will become the source ID,_the second field will become the target ID, and the third field will become_the edge value.__@param vertices a DataSet of Tuple2 representing the vertices._@param edges a DataSet of Tuple3 representing the edges._@param context the flink execution environment._@return the newly created graph.;public static <K, VV, EV> Graph<K, VV, EV> fromTupleDataSet(DataSet<Tuple2<K, VV>> vertices,_			DataSet<Tuple3<K, K, EV>> edges, ExecutionEnvironment context) {__		DataSet<Vertex<K, VV>> vertexDataSet = vertices_			.map(new Tuple2ToVertexMap<K, VV>())_				.name("Type conversion")___		DataSet<Edge<K, EV>> edgeDataSet = edges_			.map(new Tuple3ToEdgeMap<K, EV>())_				.name("Type conversion")___		return fromDataSet(vertexDataSet, edgeDataSet, context)__	};creates,a,graph,from,a,data,set,of,tuple2,objects,for,vertices,and,tuple3,objects,for,edges,p,the,first,field,of,the,tuple2,vertex,object,will,become,the,vertex,id,and,the,second,field,will,become,the,vertex,value,the,first,field,of,the,tuple3,object,for,edges,will,become,the,source,id,the,second,field,will,become,the,target,id,and,the,third,field,will,become,the,edge,value,param,vertices,a,data,set,of,tuple2,representing,the,vertices,param,edges,a,data,set,of,tuple3,representing,the,edges,param,context,the,flink,execution,environment,return,the,newly,created,graph;public,static,k,vv,ev,graph,k,vv,ev,from,tuple,data,set,data,set,tuple2,k,vv,vertices,data,set,tuple3,k,k,ev,edges,execution,environment,context,data,set,vertex,k,vv,vertex,data,set,vertices,map,new,tuple2to,vertex,map,k,vv,name,type,conversion,data,set,edge,k,ev,edge,data,set,edges,map,new,tuple3to,edge,map,k,ev,name,type,conversion,return,from,data,set,vertex,data,set,edge,data,set,context
Graph -> public static <K, VV, EV> Graph<K, VV, EV> fromTupleDataSet(DataSet<Tuple2<K, VV>> vertices, 			DataSet<Tuple3<K, K, EV>> edges, ExecutionEnvironment context);1490973446;Creates a graph from a DataSet of Tuple2 objects for vertices and_Tuple3 objects for edges._<p>_The first field of the Tuple2 vertex object will become the vertex ID_and the second field will become the vertex value._The first field of the Tuple3 object for edges will become the source ID,_the second field will become the target ID, and the third field will become_the edge value.__@param vertices a DataSet of Tuple2 representing the vertices._@param edges a DataSet of Tuple3 representing the edges._@param context the flink execution environment._@return the newly created graph.;public static <K, VV, EV> Graph<K, VV, EV> fromTupleDataSet(DataSet<Tuple2<K, VV>> vertices,_			DataSet<Tuple3<K, K, EV>> edges, ExecutionEnvironment context) {__		DataSet<Vertex<K, VV>> vertexDataSet = vertices_			.map(new Tuple2ToVertexMap<K, VV>())_				.name("Type conversion")___		DataSet<Edge<K, EV>> edgeDataSet = edges_			.map(new Tuple3ToEdgeMap<K, EV>())_				.name("Type conversion")___		return fromDataSet(vertexDataSet, edgeDataSet, context)__	};creates,a,graph,from,a,data,set,of,tuple2,objects,for,vertices,and,tuple3,objects,for,edges,p,the,first,field,of,the,tuple2,vertex,object,will,become,the,vertex,id,and,the,second,field,will,become,the,vertex,value,the,first,field,of,the,tuple3,object,for,edges,will,become,the,source,id,the,second,field,will,become,the,target,id,and,the,third,field,will,become,the,edge,value,param,vertices,a,data,set,of,tuple2,representing,the,vertices,param,edges,a,data,set,of,tuple3,representing,the,edges,param,context,the,flink,execution,environment,return,the,newly,created,graph;public,static,k,vv,ev,graph,k,vv,ev,from,tuple,data,set,data,set,tuple2,k,vv,vertices,data,set,tuple3,k,k,ev,edges,execution,environment,context,data,set,vertex,k,vv,vertex,data,set,vertices,map,new,tuple2to,vertex,map,k,vv,name,type,conversion,data,set,edge,k,ev,edge,data,set,edges,map,new,tuple3to,edge,map,k,ev,name,type,conversion,return,from,data,set,vertex,data,set,edge,data,set,context
Graph -> public static <K, VV, EV> Graph<K, VV, EV> fromTupleDataSet(DataSet<Tuple2<K, VV>> vertices, 			DataSet<Tuple3<K, K, EV>> edges, ExecutionEnvironment context);1495819075;Creates a graph from a DataSet of Tuple2 objects for vertices and_Tuple3 objects for edges.__<p>The first field of the Tuple2 vertex object will become the vertex ID_and the second field will become the vertex value._The first field of the Tuple3 object for edges will become the source ID,_the second field will become the target ID, and the third field will become_the edge value.__@param vertices a DataSet of Tuple2 representing the vertices._@param edges a DataSet of Tuple3 representing the edges._@param context the flink execution environment._@return the newly created graph.;public static <K, VV, EV> Graph<K, VV, EV> fromTupleDataSet(DataSet<Tuple2<K, VV>> vertices,_			DataSet<Tuple3<K, K, EV>> edges, ExecutionEnvironment context) {__		DataSet<Vertex<K, VV>> vertexDataSet = vertices_			.map(new Tuple2ToVertexMap<K, VV>())_				.name("Type conversion")___		DataSet<Edge<K, EV>> edgeDataSet = edges_			.map(new Tuple3ToEdgeMap<K, EV>())_				.name("Type conversion")___		return fromDataSet(vertexDataSet, edgeDataSet, context)__	};creates,a,graph,from,a,data,set,of,tuple2,objects,for,vertices,and,tuple3,objects,for,edges,p,the,first,field,of,the,tuple2,vertex,object,will,become,the,vertex,id,and,the,second,field,will,become,the,vertex,value,the,first,field,of,the,tuple3,object,for,edges,will,become,the,source,id,the,second,field,will,become,the,target,id,and,the,third,field,will,become,the,edge,value,param,vertices,a,data,set,of,tuple2,representing,the,vertices,param,edges,a,data,set,of,tuple3,representing,the,edges,param,context,the,flink,execution,environment,return,the,newly,created,graph;public,static,k,vv,ev,graph,k,vv,ev,from,tuple,data,set,data,set,tuple2,k,vv,vertices,data,set,tuple3,k,k,ev,edges,execution,environment,context,data,set,vertex,k,vv,vertex,data,set,vertices,map,new,tuple2to,vertex,map,k,vv,name,type,conversion,data,set,edge,k,ev,edge,data,set,edges,map,new,tuple3to,edge,map,k,ev,name,type,conversion,return,from,data,set,vertex,data,set,edge,data,set,context
Graph -> public static <K, VV, EV> Graph<K, VV, EV> fromTupleDataSet(DataSet<Tuple2<K, VV>> vertices, 			DataSet<Tuple3<K, K, EV>> edges, ExecutionEnvironment context);1502111816;Creates a graph from a DataSet of Tuple2 objects for vertices and_Tuple3 objects for edges.__<p>The first field of the Tuple2 vertex object will become the vertex ID_and the second field will become the vertex value._The first field of the Tuple3 object for edges will become the source ID,_the second field will become the target ID, and the third field will become_the edge value.__@param vertices a DataSet of Tuple2 representing the vertices._@param edges a DataSet of Tuple3 representing the edges._@param context the flink execution environment._@return the newly created graph.;public static <K, VV, EV> Graph<K, VV, EV> fromTupleDataSet(DataSet<Tuple2<K, VV>> vertices,_			DataSet<Tuple3<K, K, EV>> edges, ExecutionEnvironment context) {__		DataSet<Vertex<K, VV>> vertexDataSet = vertices_			.map(new Tuple2ToVertexMap<>())_				.name("Type conversion")___		DataSet<Edge<K, EV>> edgeDataSet = edges_			.map(new Tuple3ToEdgeMap<>())_				.name("Type conversion")___		return fromDataSet(vertexDataSet, edgeDataSet, context)__	};creates,a,graph,from,a,data,set,of,tuple2,objects,for,vertices,and,tuple3,objects,for,edges,p,the,first,field,of,the,tuple2,vertex,object,will,become,the,vertex,id,and,the,second,field,will,become,the,vertex,value,the,first,field,of,the,tuple3,object,for,edges,will,become,the,source,id,the,second,field,will,become,the,target,id,and,the,third,field,will,become,the,edge,value,param,vertices,a,data,set,of,tuple2,representing,the,vertices,param,edges,a,data,set,of,tuple3,representing,the,edges,param,context,the,flink,execution,environment,return,the,newly,created,graph;public,static,k,vv,ev,graph,k,vv,ev,from,tuple,data,set,data,set,tuple2,k,vv,vertices,data,set,tuple3,k,k,ev,edges,execution,environment,context,data,set,vertex,k,vv,vertex,data,set,vertices,map,new,tuple2to,vertex,map,name,type,conversion,data,set,edge,k,ev,edge,data,set,edges,map,new,tuple3to,edge,map,name,type,conversion,return,from,data,set,vertex,data,set,edge,data,set,context
Graph -> public DataSet<K> getVertexIds();1444404795;@return The IDs of the vertices as DataSet;public DataSet<K> getVertexIds() {_		return vertices.map(new ExtractVertexIDMapper<K, VV>())__	};return,the,ids,of,the,vertices,as,data,set;public,data,set,k,get,vertex,ids,return,vertices,map,new,extract,vertex,idmapper,k,vv
Graph -> public DataSet<K> getVertexIds();1445261977;@return The IDs of the vertices as DataSet;public DataSet<K> getVertexIds() {_		return vertices.map(new ExtractVertexIDMapper<K, VV>())__	};return,the,ids,of,the,vertices,as,data,set;public,data,set,k,get,vertex,ids,return,vertices,map,new,extract,vertex,idmapper,k,vv
Graph -> public DataSet<K> getVertexIds();1445854323;@return The IDs of the vertices as DataSet;public DataSet<K> getVertexIds() {_		return vertices.map(new ExtractVertexIDMapper<K, VV>())__	};return,the,ids,of,the,vertices,as,data,set;public,data,set,k,get,vertex,ids,return,vertices,map,new,extract,vertex,idmapper,k,vv
Graph -> public DataSet<K> getVertexIds();1446112342;@return The IDs of the vertices as DataSet;public DataSet<K> getVertexIds() {_		return vertices.map(new ExtractVertexIDMapper<K, VV>())__	};return,the,ids,of,the,vertices,as,data,set;public,data,set,k,get,vertex,ids,return,vertices,map,new,extract,vertex,idmapper,k,vv
Graph -> public DataSet<K> getVertexIds();1447073368;@return The IDs of the vertices as DataSet;public DataSet<K> getVertexIds() {_		return vertices.map(new ExtractVertexIDMapper<K, VV>())__	};return,the,ids,of,the,vertices,as,data,set;public,data,set,k,get,vertex,ids,return,vertices,map,new,extract,vertex,idmapper,k,vv
Graph -> public DataSet<K> getVertexIds();1454404649;@return The IDs of the vertices as DataSet;public DataSet<K> getVertexIds() {_		return vertices.map(new ExtractVertexIDMapper<K, VV>())__	};return,the,ids,of,the,vertices,as,data,set;public,data,set,k,get,vertex,ids,return,vertices,map,new,extract,vertex,idmapper,k,vv
Graph -> public DataSet<K> getVertexIds();1458583829;@return The IDs of the vertices as DataSet;public DataSet<K> getVertexIds() {_		return vertices.map(new ExtractVertexIDMapper<K, VV>())__	};return,the,ids,of,the,vertices,as,data,set;public,data,set,k,get,vertex,ids,return,vertices,map,new,extract,vertex,idmapper,k,vv
Graph -> public DataSet<K> getVertexIds();1458583829;@return The IDs of the vertices as DataSet;public DataSet<K> getVertexIds() {_		return vertices.map(new ExtractVertexIDMapper<K, VV>())__	};return,the,ids,of,the,vertices,as,data,set;public,data,set,k,get,vertex,ids,return,vertices,map,new,extract,vertex,idmapper,k,vv
Graph -> public DataSet<K> getVertexIds();1462100316;@return The IDs of the vertices as DataSet;public DataSet<K> getVertexIds() {_		return vertices.map(new ExtractVertexIDMapper<K, VV>())__	};return,the,ids,of,the,vertices,as,data,set;public,data,set,k,get,vertex,ids,return,vertices,map,new,extract,vertex,idmapper,k,vv
Graph -> public DataSet<K> getVertexIds();1462100316;@return The IDs of the vertices as DataSet;public DataSet<K> getVertexIds() {_		return vertices.map(new ExtractVertexIDMapper<K, VV>())__	};return,the,ids,of,the,vertices,as,data,set;public,data,set,k,get,vertex,ids,return,vertices,map,new,extract,vertex,idmapper,k,vv
Graph -> public DataSet<K> getVertexIds();1462205213;@return The IDs of the vertices as DataSet;public DataSet<K> getVertexIds() {_		return vertices.map(new ExtractVertexIDMapper<K, VV>())__	};return,the,ids,of,the,vertices,as,data,set;public,data,set,k,get,vertex,ids,return,vertices,map,new,extract,vertex,idmapper,k,vv
Graph -> public DataSet<K> getVertexIds();1462208859;@return The IDs of the vertices as DataSet;public DataSet<K> getVertexIds() {_		return vertices.map(new ExtractVertexIDMapper<K, VV>())__	};return,the,ids,of,the,vertices,as,data,set;public,data,set,k,get,vertex,ids,return,vertices,map,new,extract,vertex,idmapper,k,vv
Graph -> public DataSet<K> getVertexIds();1462809297;@return The IDs of the vertices as DataSet;public DataSet<K> getVertexIds() {_		return vertices.map(new ExtractVertexIDMapper<K, VV>())__	};return,the,ids,of,the,vertices,as,data,set;public,data,set,k,get,vertex,ids,return,vertices,map,new,extract,vertex,idmapper,k,vv
Graph -> public DataSet<K> getVertexIds();1465316775;@return The IDs of the vertices as DataSet;public DataSet<K> getVertexIds() {_		return vertices.map(new ExtractVertexIDMapper<K, VV>())__	};return,the,ids,of,the,vertices,as,data,set;public,data,set,k,get,vertex,ids,return,vertices,map,new,extract,vertex,idmapper,k,vv
Graph -> public DataSet<K> getVertexIds();1466789678;@return The IDs of the vertices as DataSet;public DataSet<K> getVertexIds() {_		return vertices.map(new ExtractVertexIDMapper<K, VV>())__	};return,the,ids,of,the,vertices,as,data,set;public,data,set,k,get,vertex,ids,return,vertices,map,new,extract,vertex,idmapper,k,vv
Graph -> public DataSet<K> getVertexIds();1467140656;@return The IDs of the vertices as DataSet;public DataSet<K> getVertexIds() {_		return vertices.map(new ExtractVertexIDMapper<K, VV>())__	};return,the,ids,of,the,vertices,as,data,set;public,data,set,k,get,vertex,ids,return,vertices,map,new,extract,vertex,idmapper,k,vv
Graph -> public DataSet<K> getVertexIds();1467306272;@return The IDs of the vertices as DataSet;public DataSet<K> getVertexIds() {_		return vertices.map(new ExtractVertexIDMapper<K, VV>())__	};return,the,ids,of,the,vertices,as,data,set;public,data,set,k,get,vertex,ids,return,vertices,map,new,extract,vertex,idmapper,k,vv
Graph -> public DataSet<K> getVertexIds();1470042815;@return The IDs of the vertices as DataSet;public DataSet<K> getVertexIds() {_		return vertices.map(new ExtractVertexIDMapper<K, VV>())__	};return,the,ids,of,the,vertices,as,data,set;public,data,set,k,get,vertex,ids,return,vertices,map,new,extract,vertex,idmapper,k,vv
Graph -> public DataSet<K> getVertexIds();1475684776;@return The IDs of the vertices as DataSet;public DataSet<K> getVertexIds() {_		return vertices.map(new ExtractVertexIDMapper<K, VV>())__	};return,the,ids,of,the,vertices,as,data,set;public,data,set,k,get,vertex,ids,return,vertices,map,new,extract,vertex,idmapper,k,vv
Graph -> public DataSet<K> getVertexIds();1475685606;@return The IDs of the vertices as DataSet;public DataSet<K> getVertexIds() {_		return vertices.map(new ExtractVertexIDMapper<K, VV>())__	};return,the,ids,of,the,vertices,as,data,set;public,data,set,k,get,vertex,ids,return,vertices,map,new,extract,vertex,idmapper,k,vv
Graph -> public DataSet<K> getVertexIds();1481745825;@return The IDs of the vertices as DataSet;public DataSet<K> getVertexIds() {_		return vertices.map(new ExtractVertexIDMapper<K, VV>()).name("Vertex IDs")__	};return,the,ids,of,the,vertices,as,data,set;public,data,set,k,get,vertex,ids,return,vertices,map,new,extract,vertex,idmapper,k,vv,name,vertex,ids
Graph -> public DataSet<K> getVertexIds();1481881009;@return The IDs of the vertices as DataSet;public DataSet<K> getVertexIds() {_		return vertices.map(new ExtractVertexIDMapper<K, VV>()).name("Vertex IDs")__	};return,the,ids,of,the,vertices,as,data,set;public,data,set,k,get,vertex,ids,return,vertices,map,new,extract,vertex,idmapper,k,vv,name,vertex,ids
Graph -> public DataSet<K> getVertexIds();1484160227;@return The IDs of the vertices as DataSet;public DataSet<K> getVertexIds() {_		return vertices.map(new ExtractVertexIDMapper<K, VV>()).name("Vertex IDs")__	};return,the,ids,of,the,vertices,as,data,set;public,data,set,k,get,vertex,ids,return,vertices,map,new,extract,vertex,idmapper,k,vv,name,vertex,ids
Graph -> public DataSet<K> getVertexIds();1484685504;@return The IDs of the vertices as DataSet;public DataSet<K> getVertexIds() {_		return vertices.map(new ExtractVertexIDMapper<K, VV>()).name("Vertex IDs")__	};return,the,ids,of,the,vertices,as,data,set;public,data,set,k,get,vertex,ids,return,vertices,map,new,extract,vertex,idmapper,k,vv,name,vertex,ids
Graph -> public DataSet<K> getVertexIds();1489068942;@return The IDs of the vertices as DataSet;public DataSet<K> getVertexIds() {_		return vertices.map(new ExtractVertexIDMapper<K, VV>()).name("Vertex IDs")__	};return,the,ids,of,the,vertices,as,data,set;public,data,set,k,get,vertex,ids,return,vertices,map,new,extract,vertex,idmapper,k,vv,name,vertex,ids
Graph -> public DataSet<K> getVertexIds();1490973446;@return The IDs of the vertices as DataSet;public DataSet<K> getVertexIds() {_		return vertices.map(new ExtractVertexIDMapper<K, VV>()).name("Vertex IDs")__	};return,the,ids,of,the,vertices,as,data,set;public,data,set,k,get,vertex,ids,return,vertices,map,new,extract,vertex,idmapper,k,vv,name,vertex,ids
Graph -> public DataSet<K> getVertexIds();1495819075;@return The IDs of the vertices as DataSet;public DataSet<K> getVertexIds() {_		return vertices.map(new ExtractVertexIDMapper<K, VV>()).name("Vertex IDs")__	};return,the,ids,of,the,vertices,as,data,set;public,data,set,k,get,vertex,ids,return,vertices,map,new,extract,vertex,idmapper,k,vv,name,vertex,ids
Graph -> public DataSet<K> getVertexIds();1502111816;@return The IDs of the vertices as DataSet;public DataSet<K> getVertexIds() {_		return vertices.map(new ExtractVertexIDMapper<>()).name("Vertex IDs")__	};return,the,ids,of,the,vertices,as,data,set;public,data,set,k,get,vertex,ids,return,vertices,map,new,extract,vertex,idmapper,name,vertex,ids
Graph -> public Boolean validate(GraphValidator<K, VV, EV> validator) throws Exception;1444404795;Function that checks whether a Graph is a valid Graph,_as defined by the given {@link GraphValidator}.__@return true if the Graph is valid.;public Boolean validate(GraphValidator<K, VV, EV> validator) throws Exception {_		return validator.validate(this)__	};function,that,checks,whether,a,graph,is,a,valid,graph,as,defined,by,the,given,link,graph,validator,return,true,if,the,graph,is,valid;public,boolean,validate,graph,validator,k,vv,ev,validator,throws,exception,return,validator,validate,this
Graph -> public Boolean validate(GraphValidator<K, VV, EV> validator) throws Exception;1445261977;Function that checks whether a Graph is a valid Graph,_as defined by the given {@link GraphValidator}.__@return true if the Graph is valid.;public Boolean validate(GraphValidator<K, VV, EV> validator) throws Exception {_		return validator.validate(this)__	};function,that,checks,whether,a,graph,is,a,valid,graph,as,defined,by,the,given,link,graph,validator,return,true,if,the,graph,is,valid;public,boolean,validate,graph,validator,k,vv,ev,validator,throws,exception,return,validator,validate,this
Graph -> public Boolean validate(GraphValidator<K, VV, EV> validator) throws Exception;1445854323;Function that checks whether a Graph is a valid Graph,_as defined by the given {@link GraphValidator}.__@return true if the Graph is valid.;public Boolean validate(GraphValidator<K, VV, EV> validator) throws Exception {_		return validator.validate(this)__	};function,that,checks,whether,a,graph,is,a,valid,graph,as,defined,by,the,given,link,graph,validator,return,true,if,the,graph,is,valid;public,boolean,validate,graph,validator,k,vv,ev,validator,throws,exception,return,validator,validate,this
Graph -> public Boolean validate(GraphValidator<K, VV, EV> validator) throws Exception;1446112342;Function that checks whether a Graph is a valid Graph,_as defined by the given {@link GraphValidator}.__@return true if the Graph is valid.;public Boolean validate(GraphValidator<K, VV, EV> validator) throws Exception {_		return validator.validate(this)__	};function,that,checks,whether,a,graph,is,a,valid,graph,as,defined,by,the,given,link,graph,validator,return,true,if,the,graph,is,valid;public,boolean,validate,graph,validator,k,vv,ev,validator,throws,exception,return,validator,validate,this
Graph -> public Boolean validate(GraphValidator<K, VV, EV> validator) throws Exception;1447073368;Function that checks whether a Graph is a valid Graph,_as defined by the given {@link GraphValidator}.__@return true if the Graph is valid.;public Boolean validate(GraphValidator<K, VV, EV> validator) throws Exception {_		return validator.validate(this)__	};function,that,checks,whether,a,graph,is,a,valid,graph,as,defined,by,the,given,link,graph,validator,return,true,if,the,graph,is,valid;public,boolean,validate,graph,validator,k,vv,ev,validator,throws,exception,return,validator,validate,this
Graph -> public Boolean validate(GraphValidator<K, VV, EV> validator) throws Exception;1454404649;Function that checks whether a Graph is a valid Graph,_as defined by the given {@link GraphValidator}.__@return true if the Graph is valid.;public Boolean validate(GraphValidator<K, VV, EV> validator) throws Exception {_		return validator.validate(this)__	};function,that,checks,whether,a,graph,is,a,valid,graph,as,defined,by,the,given,link,graph,validator,return,true,if,the,graph,is,valid;public,boolean,validate,graph,validator,k,vv,ev,validator,throws,exception,return,validator,validate,this
Graph -> public Boolean validate(GraphValidator<K, VV, EV> validator) throws Exception;1458583829;Function that checks whether a Graph is a valid Graph,_as defined by the given {@link GraphValidator}.__@return true if the Graph is valid.;public Boolean validate(GraphValidator<K, VV, EV> validator) throws Exception {_		return validator.validate(this)__	};function,that,checks,whether,a,graph,is,a,valid,graph,as,defined,by,the,given,link,graph,validator,return,true,if,the,graph,is,valid;public,boolean,validate,graph,validator,k,vv,ev,validator,throws,exception,return,validator,validate,this
Graph -> public Boolean validate(GraphValidator<K, VV, EV> validator) throws Exception;1458583829;Function that checks whether a Graph is a valid Graph,_as defined by the given {@link GraphValidator}.__@return true if the Graph is valid.;public Boolean validate(GraphValidator<K, VV, EV> validator) throws Exception {_		return validator.validate(this)__	};function,that,checks,whether,a,graph,is,a,valid,graph,as,defined,by,the,given,link,graph,validator,return,true,if,the,graph,is,valid;public,boolean,validate,graph,validator,k,vv,ev,validator,throws,exception,return,validator,validate,this
Graph -> public Boolean validate(GraphValidator<K, VV, EV> validator) throws Exception;1462100316;Function that checks whether a Graph is a valid Graph,_as defined by the given {@link GraphValidator}.__@return true if the Graph is valid.;public Boolean validate(GraphValidator<K, VV, EV> validator) throws Exception {_		return validator.validate(this)__	};function,that,checks,whether,a,graph,is,a,valid,graph,as,defined,by,the,given,link,graph,validator,return,true,if,the,graph,is,valid;public,boolean,validate,graph,validator,k,vv,ev,validator,throws,exception,return,validator,validate,this
Graph -> public Boolean validate(GraphValidator<K, VV, EV> validator) throws Exception;1462100316;Function that checks whether a Graph is a valid Graph,_as defined by the given {@link GraphValidator}.__@return true if the Graph is valid.;public Boolean validate(GraphValidator<K, VV, EV> validator) throws Exception {_		return validator.validate(this)__	};function,that,checks,whether,a,graph,is,a,valid,graph,as,defined,by,the,given,link,graph,validator,return,true,if,the,graph,is,valid;public,boolean,validate,graph,validator,k,vv,ev,validator,throws,exception,return,validator,validate,this
Graph -> public Boolean validate(GraphValidator<K, VV, EV> validator) throws Exception;1462205213;Function that checks whether a Graph is a valid Graph,_as defined by the given {@link GraphValidator}.__@return true if the Graph is valid.;public Boolean validate(GraphValidator<K, VV, EV> validator) throws Exception {_		return validator.validate(this)__	};function,that,checks,whether,a,graph,is,a,valid,graph,as,defined,by,the,given,link,graph,validator,return,true,if,the,graph,is,valid;public,boolean,validate,graph,validator,k,vv,ev,validator,throws,exception,return,validator,validate,this
Graph -> public Boolean validate(GraphValidator<K, VV, EV> validator) throws Exception;1462208859;Function that checks whether a Graph is a valid Graph,_as defined by the given {@link GraphValidator}.__@return true if the Graph is valid.;public Boolean validate(GraphValidator<K, VV, EV> validator) throws Exception {_		return validator.validate(this)__	};function,that,checks,whether,a,graph,is,a,valid,graph,as,defined,by,the,given,link,graph,validator,return,true,if,the,graph,is,valid;public,boolean,validate,graph,validator,k,vv,ev,validator,throws,exception,return,validator,validate,this
Graph -> public Boolean validate(GraphValidator<K, VV, EV> validator) throws Exception;1462809297;Function that checks whether a Graph is a valid Graph,_as defined by the given {@link GraphValidator}.__@return true if the Graph is valid.;public Boolean validate(GraphValidator<K, VV, EV> validator) throws Exception {_		return validator.validate(this)__	};function,that,checks,whether,a,graph,is,a,valid,graph,as,defined,by,the,given,link,graph,validator,return,true,if,the,graph,is,valid;public,boolean,validate,graph,validator,k,vv,ev,validator,throws,exception,return,validator,validate,this
Graph -> public Boolean validate(GraphValidator<K, VV, EV> validator) throws Exception;1465316775;Function that checks whether a Graph is a valid Graph,_as defined by the given {@link GraphValidator}.__@return true if the Graph is valid.;public Boolean validate(GraphValidator<K, VV, EV> validator) throws Exception {_		return validator.validate(this)__	};function,that,checks,whether,a,graph,is,a,valid,graph,as,defined,by,the,given,link,graph,validator,return,true,if,the,graph,is,valid;public,boolean,validate,graph,validator,k,vv,ev,validator,throws,exception,return,validator,validate,this
Graph -> public Boolean validate(GraphValidator<K, VV, EV> validator) throws Exception;1466789678;Function that checks whether a Graph is a valid Graph,_as defined by the given {@link GraphValidator}.__@return true if the Graph is valid.;public Boolean validate(GraphValidator<K, VV, EV> validator) throws Exception {_		return validator.validate(this)__	};function,that,checks,whether,a,graph,is,a,valid,graph,as,defined,by,the,given,link,graph,validator,return,true,if,the,graph,is,valid;public,boolean,validate,graph,validator,k,vv,ev,validator,throws,exception,return,validator,validate,this
Graph -> public Boolean validate(GraphValidator<K, VV, EV> validator) throws Exception;1467140656;Function that checks whether a Graph is a valid Graph,_as defined by the given {@link GraphValidator}.__@return true if the Graph is valid.;public Boolean validate(GraphValidator<K, VV, EV> validator) throws Exception {_		return validator.validate(this)__	};function,that,checks,whether,a,graph,is,a,valid,graph,as,defined,by,the,given,link,graph,validator,return,true,if,the,graph,is,valid;public,boolean,validate,graph,validator,k,vv,ev,validator,throws,exception,return,validator,validate,this
Graph -> public Boolean validate(GraphValidator<K, VV, EV> validator) throws Exception;1467306272;Function that checks whether a Graph is a valid Graph,_as defined by the given {@link GraphValidator}.__@return true if the Graph is valid.;public Boolean validate(GraphValidator<K, VV, EV> validator) throws Exception {_		return validator.validate(this)__	};function,that,checks,whether,a,graph,is,a,valid,graph,as,defined,by,the,given,link,graph,validator,return,true,if,the,graph,is,valid;public,boolean,validate,graph,validator,k,vv,ev,validator,throws,exception,return,validator,validate,this
Graph -> public Boolean validate(GraphValidator<K, VV, EV> validator) throws Exception;1470042815;Function that checks whether a Graph is a valid Graph,_as defined by the given {@link GraphValidator}.__@return true if the Graph is valid.;public Boolean validate(GraphValidator<K, VV, EV> validator) throws Exception {_		return validator.validate(this)__	};function,that,checks,whether,a,graph,is,a,valid,graph,as,defined,by,the,given,link,graph,validator,return,true,if,the,graph,is,valid;public,boolean,validate,graph,validator,k,vv,ev,validator,throws,exception,return,validator,validate,this
Graph -> public Boolean validate(GraphValidator<K, VV, EV> validator) throws Exception;1475684776;Function that checks whether a Graph is a valid Graph,_as defined by the given {@link GraphValidator}.__@return true if the Graph is valid.;public Boolean validate(GraphValidator<K, VV, EV> validator) throws Exception {_		return validator.validate(this)__	};function,that,checks,whether,a,graph,is,a,valid,graph,as,defined,by,the,given,link,graph,validator,return,true,if,the,graph,is,valid;public,boolean,validate,graph,validator,k,vv,ev,validator,throws,exception,return,validator,validate,this
Graph -> public Boolean validate(GraphValidator<K, VV, EV> validator) throws Exception;1475685606;Function that checks whether a Graph is a valid Graph,_as defined by the given {@link GraphValidator}.__@return true if the Graph is valid.;public Boolean validate(GraphValidator<K, VV, EV> validator) throws Exception {_		return validator.validate(this)__	};function,that,checks,whether,a,graph,is,a,valid,graph,as,defined,by,the,given,link,graph,validator,return,true,if,the,graph,is,valid;public,boolean,validate,graph,validator,k,vv,ev,validator,throws,exception,return,validator,validate,this
Graph -> public Boolean validate(GraphValidator<K, VV, EV> validator) throws Exception;1481745825;Function that checks whether a Graph is a valid Graph,_as defined by the given {@link GraphValidator}.__@return true if the Graph is valid.;public Boolean validate(GraphValidator<K, VV, EV> validator) throws Exception {_		return validator.validate(this)__	};function,that,checks,whether,a,graph,is,a,valid,graph,as,defined,by,the,given,link,graph,validator,return,true,if,the,graph,is,valid;public,boolean,validate,graph,validator,k,vv,ev,validator,throws,exception,return,validator,validate,this
Graph -> public Boolean validate(GraphValidator<K, VV, EV> validator) throws Exception;1481881009;Function that checks whether a Graph is a valid Graph,_as defined by the given {@link GraphValidator}.__@return true if the Graph is valid.;public Boolean validate(GraphValidator<K, VV, EV> validator) throws Exception {_		return validator.validate(this)__	};function,that,checks,whether,a,graph,is,a,valid,graph,as,defined,by,the,given,link,graph,validator,return,true,if,the,graph,is,valid;public,boolean,validate,graph,validator,k,vv,ev,validator,throws,exception,return,validator,validate,this
Graph -> public Boolean validate(GraphValidator<K, VV, EV> validator) throws Exception;1484160227;Function that checks whether a Graph is a valid Graph,_as defined by the given {@link GraphValidator}.__@return true if the Graph is valid.;public Boolean validate(GraphValidator<K, VV, EV> validator) throws Exception {_		return validator.validate(this)__	};function,that,checks,whether,a,graph,is,a,valid,graph,as,defined,by,the,given,link,graph,validator,return,true,if,the,graph,is,valid;public,boolean,validate,graph,validator,k,vv,ev,validator,throws,exception,return,validator,validate,this
Graph -> public Boolean validate(GraphValidator<K, VV, EV> validator) throws Exception;1484685504;Function that checks whether a Graph is a valid Graph,_as defined by the given {@link GraphValidator}.__@return true if the Graph is valid.;public Boolean validate(GraphValidator<K, VV, EV> validator) throws Exception {_		return validator.validate(this)__	};function,that,checks,whether,a,graph,is,a,valid,graph,as,defined,by,the,given,link,graph,validator,return,true,if,the,graph,is,valid;public,boolean,validate,graph,validator,k,vv,ev,validator,throws,exception,return,validator,validate,this
Graph -> public Boolean validate(GraphValidator<K, VV, EV> validator) throws Exception;1489068942;Function that checks whether a Graph is a valid Graph,_as defined by the given {@link GraphValidator}.__@return true if the Graph is valid.;public Boolean validate(GraphValidator<K, VV, EV> validator) throws Exception {_		return validator.validate(this)__	};function,that,checks,whether,a,graph,is,a,valid,graph,as,defined,by,the,given,link,graph,validator,return,true,if,the,graph,is,valid;public,boolean,validate,graph,validator,k,vv,ev,validator,throws,exception,return,validator,validate,this
Graph -> public Boolean validate(GraphValidator<K, VV, EV> validator) throws Exception;1490973446;Function that checks whether a Graph is a valid Graph,_as defined by the given {@link GraphValidator}.__@return true if the Graph is valid.;public Boolean validate(GraphValidator<K, VV, EV> validator) throws Exception {_		return validator.validate(this)__	};function,that,checks,whether,a,graph,is,a,valid,graph,as,defined,by,the,given,link,graph,validator,return,true,if,the,graph,is,valid;public,boolean,validate,graph,validator,k,vv,ev,validator,throws,exception,return,validator,validate,this
Graph -> public Boolean validate(GraphValidator<K, VV, EV> validator) throws Exception;1495819075;Function that checks whether a Graph is a valid Graph,_as defined by the given {@link GraphValidator}.__@return true if the Graph is valid.;public Boolean validate(GraphValidator<K, VV, EV> validator) throws Exception {_		return validator.validate(this)__	};function,that,checks,whether,a,graph,is,a,valid,graph,as,defined,by,the,given,link,graph,validator,return,true,if,the,graph,is,valid;public,boolean,validate,graph,validator,k,vv,ev,validator,throws,exception,return,validator,validate,this
Graph -> public Boolean validate(GraphValidator<K, VV, EV> validator) throws Exception;1502111816;Function that checks whether a Graph is a valid Graph,_as defined by the given {@link GraphValidator}.__@return true if the Graph is valid.;public Boolean validate(GraphValidator<K, VV, EV> validator) throws Exception {_		return validator.validate(this)__	};function,that,checks,whether,a,graph,is,a,valid,graph,as,defined,by,the,given,link,graph,validator,return,true,if,the,graph,is,valid;public,boolean,validate,graph,validator,k,vv,ev,validator,throws,exception,return,validator,validate,this
Graph -> public DataSet<Tuple2<K, Long>> getDegrees();1444404795;Return the degree of all vertices in the graph__@return A DataSet of Tuple2<vertexId, degree>;public DataSet<Tuple2<K, Long>> getDegrees() {_		return outDegrees().union(inDegrees()).groupBy(0).sum(1)__	};return,the,degree,of,all,vertices,in,the,graph,return,a,data,set,of,tuple2,vertex,id,degree;public,data,set,tuple2,k,long,get,degrees,return,out,degrees,union,in,degrees,group,by,0,sum,1
Graph -> public DataSet<Tuple2<K, Long>> getDegrees();1445261977;Return the degree of all vertices in the graph__@return A DataSet of Tuple2<vertexId, degree>;public DataSet<Tuple2<K, Long>> getDegrees() {_		return outDegrees().union(inDegrees()).groupBy(0).sum(1)__	};return,the,degree,of,all,vertices,in,the,graph,return,a,data,set,of,tuple2,vertex,id,degree;public,data,set,tuple2,k,long,get,degrees,return,out,degrees,union,in,degrees,group,by,0,sum,1
Graph -> public DataSet<Tuple2<K, Long>> getDegrees();1445854323;Return the degree of all vertices in the graph__@return A DataSet of Tuple2<vertexId, degree>;public DataSet<Tuple2<K, Long>> getDegrees() {_		return outDegrees().union(inDegrees()).groupBy(0).sum(1)__	};return,the,degree,of,all,vertices,in,the,graph,return,a,data,set,of,tuple2,vertex,id,degree;public,data,set,tuple2,k,long,get,degrees,return,out,degrees,union,in,degrees,group,by,0,sum,1
Graph -> public DataSet<Tuple2<K, Long>> getDegrees();1446112342;Return the degree of all vertices in the graph__@return A DataSet of {@code Tuple2<vertexId, degree>};public DataSet<Tuple2<K, Long>> getDegrees() {_		return outDegrees().union(inDegrees()).groupBy(0).sum(1)__	};return,the,degree,of,all,vertices,in,the,graph,return,a,data,set,of,code,tuple2,vertex,id,degree;public,data,set,tuple2,k,long,get,degrees,return,out,degrees,union,in,degrees,group,by,0,sum,1
Graph -> public DataSet<Tuple2<K, Long>> getDegrees();1447073368;Return the degree of all vertices in the graph__@return A DataSet of {@code Tuple2<vertexId, degree>};public DataSet<Tuple2<K, Long>> getDegrees() {_		return outDegrees().union(inDegrees()).groupBy(0).sum(1)__	};return,the,degree,of,all,vertices,in,the,graph,return,a,data,set,of,code,tuple2,vertex,id,degree;public,data,set,tuple2,k,long,get,degrees,return,out,degrees,union,in,degrees,group,by,0,sum,1
Graph -> public DataSet<Tuple2<K, Long>> getDegrees();1454404649;Return the degree of all vertices in the graph__@return A DataSet of {@code Tuple2<vertexId, degree>};public DataSet<Tuple2<K, Long>> getDegrees() {_		return outDegrees().union(inDegrees()).groupBy(0).sum(1)__	};return,the,degree,of,all,vertices,in,the,graph,return,a,data,set,of,code,tuple2,vertex,id,degree;public,data,set,tuple2,k,long,get,degrees,return,out,degrees,union,in,degrees,group,by,0,sum,1
Graph -> public DataSet<Tuple2<K, Long>> getDegrees();1458583829;Return the degree of all vertices in the graph__@return A DataSet of {@code Tuple2<vertexId, degree>};public DataSet<Tuple2<K, Long>> getDegrees() {_		return outDegrees().union(inDegrees()).groupBy(0).sum(1)__	};return,the,degree,of,all,vertices,in,the,graph,return,a,data,set,of,code,tuple2,vertex,id,degree;public,data,set,tuple2,k,long,get,degrees,return,out,degrees,union,in,degrees,group,by,0,sum,1
Graph -> public DataSet<Tuple2<K, Long>> getDegrees();1458583829;Return the degree of all vertices in the graph__@return A DataSet of {@code Tuple2<vertexId, degree>};public DataSet<Tuple2<K, Long>> getDegrees() {_		return outDegrees().union(inDegrees()).groupBy(0).sum(1)__	};return,the,degree,of,all,vertices,in,the,graph,return,a,data,set,of,code,tuple2,vertex,id,degree;public,data,set,tuple2,k,long,get,degrees,return,out,degrees,union,in,degrees,group,by,0,sum,1
Graph -> public DataSet<Tuple2<K, Long>> getDegrees();1462100316;Return the degree of all vertices in the graph__@return A DataSet of {@code Tuple2<vertexId, degree>};public DataSet<Tuple2<K, Long>> getDegrees() {_		return outDegrees().union(inDegrees()).groupBy(0).sum(1)__	};return,the,degree,of,all,vertices,in,the,graph,return,a,data,set,of,code,tuple2,vertex,id,degree;public,data,set,tuple2,k,long,get,degrees,return,out,degrees,union,in,degrees,group,by,0,sum,1
Graph -> public DataSet<Tuple2<K, Long>> getDegrees();1462100316;Return the degree of all vertices in the graph__@return A DataSet of {@code Tuple2<vertexId, degree>};public DataSet<Tuple2<K, Long>> getDegrees() {_		return outDegrees().union(inDegrees()).groupBy(0).sum(1)__	};return,the,degree,of,all,vertices,in,the,graph,return,a,data,set,of,code,tuple2,vertex,id,degree;public,data,set,tuple2,k,long,get,degrees,return,out,degrees,union,in,degrees,group,by,0,sum,1
Graph -> public DataSet<Tuple2<K, Long>> getDegrees();1462205213;Return the degree of all vertices in the graph__@return A DataSet of {@code Tuple2<vertexId, degree>};public DataSet<Tuple2<K, Long>> getDegrees() {_		return outDegrees().union(inDegrees()).groupBy(0).sum(1)__	};return,the,degree,of,all,vertices,in,the,graph,return,a,data,set,of,code,tuple2,vertex,id,degree;public,data,set,tuple2,k,long,get,degrees,return,out,degrees,union,in,degrees,group,by,0,sum,1
Graph -> public DataSet<Tuple2<K, Long>> getDegrees();1462208859;Return the degree of all vertices in the graph__@return A DataSet of {@code Tuple2<vertexId, degree>};public DataSet<Tuple2<K, Long>> getDegrees() {_		return outDegrees().union(inDegrees()).groupBy(0).sum(1)__	};return,the,degree,of,all,vertices,in,the,graph,return,a,data,set,of,code,tuple2,vertex,id,degree;public,data,set,tuple2,k,long,get,degrees,return,out,degrees,union,in,degrees,group,by,0,sum,1
Graph -> public DataSet<Tuple2<K, Long>> getDegrees();1462809297;Return the degree of all vertices in the graph__@return A DataSet of {@code Tuple2<vertexId, degree>};public DataSet<Tuple2<K, Long>> getDegrees() {_		return outDegrees().union(inDegrees()).groupBy(0).sum(1)__	};return,the,degree,of,all,vertices,in,the,graph,return,a,data,set,of,code,tuple2,vertex,id,degree;public,data,set,tuple2,k,long,get,degrees,return,out,degrees,union,in,degrees,group,by,0,sum,1
Graph -> public DataSet<Tuple2<K, Long>> getDegrees();1465316775;Return the degree of all vertices in the graph__@return A DataSet of {@code Tuple2<vertexId, degree>};public DataSet<Tuple2<K, Long>> getDegrees() {_		return outDegrees().union(inDegrees()).groupBy(0).sum(1)__	};return,the,degree,of,all,vertices,in,the,graph,return,a,data,set,of,code,tuple2,vertex,id,degree;public,data,set,tuple2,k,long,get,degrees,return,out,degrees,union,in,degrees,group,by,0,sum,1
Graph -> public DataSet<Tuple2<K, Long>> getDegrees();1466789678;Return the degree of all vertices in the graph__@return A DataSet of {@code Tuple2<vertexId, degree>};public DataSet<Tuple2<K, Long>> getDegrees() {_		return outDegrees().union(inDegrees()).groupBy(0).sum(1)__	};return,the,degree,of,all,vertices,in,the,graph,return,a,data,set,of,code,tuple2,vertex,id,degree;public,data,set,tuple2,k,long,get,degrees,return,out,degrees,union,in,degrees,group,by,0,sum,1
Graph -> public <T> Graph<K, VV, EV> joinWithEdges(DataSet<Tuple3<K, K, T>> inputDataSet, 			final EdgeJoinFunction<EV, T> edgeJoinFunction);1445261977;Joins the edge DataSet with an input DataSet on the composite key of both_source and target IDs and applies a user-defined transformation on the values_of the matched records. The first two fields of the input DataSet are used as join keys.__@param inputDataSet the DataSet to join with._The first two fields of the Tuple3 are used as the composite join key_and the third field is passed as a parameter to the transformation function._@param edgeJoinFunction the transformation function to apply._The first parameter is the current edge value and the second parameter is the value_of the matched Tuple3 from the input DataSet._@param <T> the type of the third field of the input Tuple3 DataSet._@return a new Graph, where the edge values have been updated according to the_result of the edgeJoinFunction.;public <T> Graph<K, VV, EV> joinWithEdges(DataSet<Tuple3<K, K, T>> inputDataSet,_			final EdgeJoinFunction<EV, T> edgeJoinFunction) {__		DataSet<Edge<K, EV>> resultedEdges = this.getEdges()_				.coGroup(inputDataSet).where(0, 1).equalTo(0, 1)_				.with(new ApplyCoGroupToEdgeValues<K, EV, T>(edgeJoinFunction))__		return new Graph<K, VV, EV>(this.vertices, resultedEdges, this.context)__	};joins,the,edge,data,set,with,an,input,data,set,on,the,composite,key,of,both,source,and,target,ids,and,applies,a,user,defined,transformation,on,the,values,of,the,matched,records,the,first,two,fields,of,the,input,data,set,are,used,as,join,keys,param,input,data,set,the,data,set,to,join,with,the,first,two,fields,of,the,tuple3,are,used,as,the,composite,join,key,and,the,third,field,is,passed,as,a,parameter,to,the,transformation,function,param,edge,join,function,the,transformation,function,to,apply,the,first,parameter,is,the,current,edge,value,and,the,second,parameter,is,the,value,of,the,matched,tuple3,from,the,input,data,set,param,t,the,type,of,the,third,field,of,the,input,tuple3,data,set,return,a,new,graph,where,the,edge,values,have,been,updated,according,to,the,result,of,the,edge,join,function;public,t,graph,k,vv,ev,join,with,edges,data,set,tuple3,k,k,t,input,data,set,final,edge,join,function,ev,t,edge,join,function,data,set,edge,k,ev,resulted,edges,this,get,edges,co,group,input,data,set,where,0,1,equal,to,0,1,with,new,apply,co,group,to,edge,values,k,ev,t,edge,join,function,return,new,graph,k,vv,ev,this,vertices,resulted,edges,this,context
Graph -> public <T> Graph<K, VV, EV> joinWithEdges(DataSet<Tuple3<K, K, T>> inputDataSet, 			final EdgeJoinFunction<EV, T> edgeJoinFunction);1445854323;Joins the edge DataSet with an input DataSet on the composite key of both_source and target IDs and applies a user-defined transformation on the values_of the matched records. The first two fields of the input DataSet are used as join keys.__@param inputDataSet the DataSet to join with._The first two fields of the Tuple3 are used as the composite join key_and the third field is passed as a parameter to the transformation function._@param edgeJoinFunction the transformation function to apply._The first parameter is the current edge value and the second parameter is the value_of the matched Tuple3 from the input DataSet._@param <T> the type of the third field of the input Tuple3 DataSet._@return a new Graph, where the edge values have been updated according to the_result of the edgeJoinFunction.;public <T> Graph<K, VV, EV> joinWithEdges(DataSet<Tuple3<K, K, T>> inputDataSet,_			final EdgeJoinFunction<EV, T> edgeJoinFunction) {__		DataSet<Edge<K, EV>> resultedEdges = this.getEdges()_				.coGroup(inputDataSet).where(0, 1).equalTo(0, 1)_				.with(new ApplyCoGroupToEdgeValues<K, EV, T>(edgeJoinFunction))__		return new Graph<K, VV, EV>(this.vertices, resultedEdges, this.context)__	};joins,the,edge,data,set,with,an,input,data,set,on,the,composite,key,of,both,source,and,target,ids,and,applies,a,user,defined,transformation,on,the,values,of,the,matched,records,the,first,two,fields,of,the,input,data,set,are,used,as,join,keys,param,input,data,set,the,data,set,to,join,with,the,first,two,fields,of,the,tuple3,are,used,as,the,composite,join,key,and,the,third,field,is,passed,as,a,parameter,to,the,transformation,function,param,edge,join,function,the,transformation,function,to,apply,the,first,parameter,is,the,current,edge,value,and,the,second,parameter,is,the,value,of,the,matched,tuple3,from,the,input,data,set,param,t,the,type,of,the,third,field,of,the,input,tuple3,data,set,return,a,new,graph,where,the,edge,values,have,been,updated,according,to,the,result,of,the,edge,join,function;public,t,graph,k,vv,ev,join,with,edges,data,set,tuple3,k,k,t,input,data,set,final,edge,join,function,ev,t,edge,join,function,data,set,edge,k,ev,resulted,edges,this,get,edges,co,group,input,data,set,where,0,1,equal,to,0,1,with,new,apply,co,group,to,edge,values,k,ev,t,edge,join,function,return,new,graph,k,vv,ev,this,vertices,resulted,edges,this,context
Graph -> public <T> Graph<K, VV, EV> joinWithEdges(DataSet<Tuple3<K, K, T>> inputDataSet, 			final EdgeJoinFunction<EV, T> edgeJoinFunction);1446112342;Joins the edge DataSet with an input DataSet on the composite key of both_source and target IDs and applies a user-defined transformation on the values_of the matched records. The first two fields of the input DataSet are used as join keys.__@param inputDataSet the DataSet to join with._The first two fields of the Tuple3 are used as the composite join key_and the third field is passed as a parameter to the transformation function._@param edgeJoinFunction the transformation function to apply._The first parameter is the current edge value and the second parameter is the value_of the matched Tuple3 from the input DataSet._@param <T> the type of the third field of the input Tuple3 DataSet._@return a new Graph, where the edge values have been updated according to the_result of the edgeJoinFunction.;public <T> Graph<K, VV, EV> joinWithEdges(DataSet<Tuple3<K, K, T>> inputDataSet,_			final EdgeJoinFunction<EV, T> edgeJoinFunction) {__		DataSet<Edge<K, EV>> resultedEdges = this.getEdges()_				.coGroup(inputDataSet).where(0, 1).equalTo(0, 1)_				.with(new ApplyCoGroupToEdgeValues<K, EV, T>(edgeJoinFunction))__		return new Graph<K, VV, EV>(this.vertices, resultedEdges, this.context)__	};joins,the,edge,data,set,with,an,input,data,set,on,the,composite,key,of,both,source,and,target,ids,and,applies,a,user,defined,transformation,on,the,values,of,the,matched,records,the,first,two,fields,of,the,input,data,set,are,used,as,join,keys,param,input,data,set,the,data,set,to,join,with,the,first,two,fields,of,the,tuple3,are,used,as,the,composite,join,key,and,the,third,field,is,passed,as,a,parameter,to,the,transformation,function,param,edge,join,function,the,transformation,function,to,apply,the,first,parameter,is,the,current,edge,value,and,the,second,parameter,is,the,value,of,the,matched,tuple3,from,the,input,data,set,param,t,the,type,of,the,third,field,of,the,input,tuple3,data,set,return,a,new,graph,where,the,edge,values,have,been,updated,according,to,the,result,of,the,edge,join,function;public,t,graph,k,vv,ev,join,with,edges,data,set,tuple3,k,k,t,input,data,set,final,edge,join,function,ev,t,edge,join,function,data,set,edge,k,ev,resulted,edges,this,get,edges,co,group,input,data,set,where,0,1,equal,to,0,1,with,new,apply,co,group,to,edge,values,k,ev,t,edge,join,function,return,new,graph,k,vv,ev,this,vertices,resulted,edges,this,context
Graph -> public <T> Graph<K, VV, EV> joinWithEdges(DataSet<Tuple3<K, K, T>> inputDataSet, 			final EdgeJoinFunction<EV, T> edgeJoinFunction);1447073368;Joins the edge DataSet with an input DataSet on the composite key of both_source and target IDs and applies a user-defined transformation on the values_of the matched records. The first two fields of the input DataSet are used as join keys.__@param inputDataSet the DataSet to join with._The first two fields of the Tuple3 are used as the composite join key_and the third field is passed as a parameter to the transformation function._@param edgeJoinFunction the transformation function to apply._The first parameter is the current edge value and the second parameter is the value_of the matched Tuple3 from the input DataSet._@param <T> the type of the third field of the input Tuple3 DataSet._@return a new Graph, where the edge values have been updated according to the_result of the edgeJoinFunction.;public <T> Graph<K, VV, EV> joinWithEdges(DataSet<Tuple3<K, K, T>> inputDataSet,_			final EdgeJoinFunction<EV, T> edgeJoinFunction) {__		DataSet<Edge<K, EV>> resultedEdges = this.getEdges()_				.coGroup(inputDataSet).where(0, 1).equalTo(0, 1)_				.with(new ApplyCoGroupToEdgeValues<K, EV, T>(edgeJoinFunction))__		return new Graph<K, VV, EV>(this.vertices, resultedEdges, this.context)__	};joins,the,edge,data,set,with,an,input,data,set,on,the,composite,key,of,both,source,and,target,ids,and,applies,a,user,defined,transformation,on,the,values,of,the,matched,records,the,first,two,fields,of,the,input,data,set,are,used,as,join,keys,param,input,data,set,the,data,set,to,join,with,the,first,two,fields,of,the,tuple3,are,used,as,the,composite,join,key,and,the,third,field,is,passed,as,a,parameter,to,the,transformation,function,param,edge,join,function,the,transformation,function,to,apply,the,first,parameter,is,the,current,edge,value,and,the,second,parameter,is,the,value,of,the,matched,tuple3,from,the,input,data,set,param,t,the,type,of,the,third,field,of,the,input,tuple3,data,set,return,a,new,graph,where,the,edge,values,have,been,updated,according,to,the,result,of,the,edge,join,function;public,t,graph,k,vv,ev,join,with,edges,data,set,tuple3,k,k,t,input,data,set,final,edge,join,function,ev,t,edge,join,function,data,set,edge,k,ev,resulted,edges,this,get,edges,co,group,input,data,set,where,0,1,equal,to,0,1,with,new,apply,co,group,to,edge,values,k,ev,t,edge,join,function,return,new,graph,k,vv,ev,this,vertices,resulted,edges,this,context
Graph -> public <T> Graph<K, VV, EV> joinWithEdges(DataSet<Tuple3<K, K, T>> inputDataSet, 			final EdgeJoinFunction<EV, T> edgeJoinFunction);1454404649;Joins the edge DataSet with an input DataSet on the composite key of both_source and target IDs and applies a user-defined transformation on the values_of the matched records. The first two fields of the input DataSet are used as join keys.__@param inputDataSet the DataSet to join with._The first two fields of the Tuple3 are used as the composite join key_and the third field is passed as a parameter to the transformation function._@param edgeJoinFunction the transformation function to apply._The first parameter is the current edge value and the second parameter is the value_of the matched Tuple3 from the input DataSet._@param <T> the type of the third field of the input Tuple3 DataSet._@return a new Graph, where the edge values have been updated according to the_result of the edgeJoinFunction.;public <T> Graph<K, VV, EV> joinWithEdges(DataSet<Tuple3<K, K, T>> inputDataSet,_			final EdgeJoinFunction<EV, T> edgeJoinFunction) {__		DataSet<Edge<K, EV>> resultedEdges = this.getEdges()_				.coGroup(inputDataSet).where(0, 1).equalTo(0, 1)_				.with(new ApplyCoGroupToEdgeValues<K, EV, T>(edgeJoinFunction))__		return new Graph<K, VV, EV>(this.vertices, resultedEdges, this.context)__	};joins,the,edge,data,set,with,an,input,data,set,on,the,composite,key,of,both,source,and,target,ids,and,applies,a,user,defined,transformation,on,the,values,of,the,matched,records,the,first,two,fields,of,the,input,data,set,are,used,as,join,keys,param,input,data,set,the,data,set,to,join,with,the,first,two,fields,of,the,tuple3,are,used,as,the,composite,join,key,and,the,third,field,is,passed,as,a,parameter,to,the,transformation,function,param,edge,join,function,the,transformation,function,to,apply,the,first,parameter,is,the,current,edge,value,and,the,second,parameter,is,the,value,of,the,matched,tuple3,from,the,input,data,set,param,t,the,type,of,the,third,field,of,the,input,tuple3,data,set,return,a,new,graph,where,the,edge,values,have,been,updated,according,to,the,result,of,the,edge,join,function;public,t,graph,k,vv,ev,join,with,edges,data,set,tuple3,k,k,t,input,data,set,final,edge,join,function,ev,t,edge,join,function,data,set,edge,k,ev,resulted,edges,this,get,edges,co,group,input,data,set,where,0,1,equal,to,0,1,with,new,apply,co,group,to,edge,values,k,ev,t,edge,join,function,return,new,graph,k,vv,ev,this,vertices,resulted,edges,this,context
Graph -> public <T> Graph<K, VV, EV> joinWithEdges(DataSet<Tuple3<K, K, T>> inputDataSet, 			final EdgeJoinFunction<EV, T> edgeJoinFunction);1458583829;Joins the edge DataSet with an input DataSet on the composite key of both_source and target IDs and applies a user-defined transformation on the values_of the matched records. The first two fields of the input DataSet are used as join keys.__@param inputDataSet the DataSet to join with._The first two fields of the Tuple3 are used as the composite join key_and the third field is passed as a parameter to the transformation function._@param edgeJoinFunction the transformation function to apply._The first parameter is the current edge value and the second parameter is the value_of the matched Tuple3 from the input DataSet._@param <T> the type of the third field of the input Tuple3 DataSet._@return a new Graph, where the edge values have been updated according to the_result of the edgeJoinFunction.;public <T> Graph<K, VV, EV> joinWithEdges(DataSet<Tuple3<K, K, T>> inputDataSet,_			final EdgeJoinFunction<EV, T> edgeJoinFunction) {__		DataSet<Edge<K, EV>> resultedEdges = this.getEdges()_				.coGroup(inputDataSet).where(0, 1).equalTo(0, 1)_				.with(new ApplyCoGroupToEdgeValues<K, EV, T>(edgeJoinFunction))__		return new Graph<K, VV, EV>(this.vertices, resultedEdges, this.context)__	};joins,the,edge,data,set,with,an,input,data,set,on,the,composite,key,of,both,source,and,target,ids,and,applies,a,user,defined,transformation,on,the,values,of,the,matched,records,the,first,two,fields,of,the,input,data,set,are,used,as,join,keys,param,input,data,set,the,data,set,to,join,with,the,first,two,fields,of,the,tuple3,are,used,as,the,composite,join,key,and,the,third,field,is,passed,as,a,parameter,to,the,transformation,function,param,edge,join,function,the,transformation,function,to,apply,the,first,parameter,is,the,current,edge,value,and,the,second,parameter,is,the,value,of,the,matched,tuple3,from,the,input,data,set,param,t,the,type,of,the,third,field,of,the,input,tuple3,data,set,return,a,new,graph,where,the,edge,values,have,been,updated,according,to,the,result,of,the,edge,join,function;public,t,graph,k,vv,ev,join,with,edges,data,set,tuple3,k,k,t,input,data,set,final,edge,join,function,ev,t,edge,join,function,data,set,edge,k,ev,resulted,edges,this,get,edges,co,group,input,data,set,where,0,1,equal,to,0,1,with,new,apply,co,group,to,edge,values,k,ev,t,edge,join,function,return,new,graph,k,vv,ev,this,vertices,resulted,edges,this,context
Graph -> public <T> Graph<K, VV, EV> joinWithEdges(DataSet<Tuple3<K, K, T>> inputDataSet, 			final EdgeJoinFunction<EV, T> edgeJoinFunction);1458583829;Joins the edge DataSet with an input DataSet on the composite key of both_source and target IDs and applies a user-defined transformation on the values_of the matched records. The first two fields of the input DataSet are used as join keys.__@param inputDataSet the DataSet to join with._The first two fields of the Tuple3 are used as the composite join key_and the third field is passed as a parameter to the transformation function._@param edgeJoinFunction the transformation function to apply._The first parameter is the current edge value and the second parameter is the value_of the matched Tuple3 from the input DataSet._@param <T> the type of the third field of the input Tuple3 DataSet._@return a new Graph, where the edge values have been updated according to the_result of the edgeJoinFunction.;public <T> Graph<K, VV, EV> joinWithEdges(DataSet<Tuple3<K, K, T>> inputDataSet,_			final EdgeJoinFunction<EV, T> edgeJoinFunction) {__		DataSet<Edge<K, EV>> resultedEdges = this.getEdges()_				.coGroup(inputDataSet).where(0, 1).equalTo(0, 1)_				.with(new ApplyCoGroupToEdgeValues<K, EV, T>(edgeJoinFunction))__		return new Graph<K, VV, EV>(this.vertices, resultedEdges, this.context)__	};joins,the,edge,data,set,with,an,input,data,set,on,the,composite,key,of,both,source,and,target,ids,and,applies,a,user,defined,transformation,on,the,values,of,the,matched,records,the,first,two,fields,of,the,input,data,set,are,used,as,join,keys,param,input,data,set,the,data,set,to,join,with,the,first,two,fields,of,the,tuple3,are,used,as,the,composite,join,key,and,the,third,field,is,passed,as,a,parameter,to,the,transformation,function,param,edge,join,function,the,transformation,function,to,apply,the,first,parameter,is,the,current,edge,value,and,the,second,parameter,is,the,value,of,the,matched,tuple3,from,the,input,data,set,param,t,the,type,of,the,third,field,of,the,input,tuple3,data,set,return,a,new,graph,where,the,edge,values,have,been,updated,according,to,the,result,of,the,edge,join,function;public,t,graph,k,vv,ev,join,with,edges,data,set,tuple3,k,k,t,input,data,set,final,edge,join,function,ev,t,edge,join,function,data,set,edge,k,ev,resulted,edges,this,get,edges,co,group,input,data,set,where,0,1,equal,to,0,1,with,new,apply,co,group,to,edge,values,k,ev,t,edge,join,function,return,new,graph,k,vv,ev,this,vertices,resulted,edges,this,context
Graph -> public <T> Graph<K, VV, EV> joinWithEdges(DataSet<Tuple3<K, K, T>> inputDataSet, 			final EdgeJoinFunction<EV, T> edgeJoinFunction);1462100316;Joins the edge DataSet with an input DataSet on the composite key of both_source and target IDs and applies a user-defined transformation on the values_of the matched records. The first two fields of the input DataSet are used as join keys.__@param inputDataSet the DataSet to join with._The first two fields of the Tuple3 are used as the composite join key_and the third field is passed as a parameter to the transformation function._@param edgeJoinFunction the transformation function to apply._The first parameter is the current edge value and the second parameter is the value_of the matched Tuple3 from the input DataSet._@param <T> the type of the third field of the input Tuple3 DataSet._@return a new Graph, where the edge values have been updated according to the_result of the edgeJoinFunction.;public <T> Graph<K, VV, EV> joinWithEdges(DataSet<Tuple3<K, K, T>> inputDataSet,_			final EdgeJoinFunction<EV, T> edgeJoinFunction) {__		DataSet<Edge<K, EV>> resultedEdges = this.getEdges()_				.coGroup(inputDataSet).where(0, 1).equalTo(0, 1)_				.with(new ApplyCoGroupToEdgeValues<K, EV, T>(edgeJoinFunction))__		return new Graph<K, VV, EV>(this.vertices, resultedEdges, this.context)__	};joins,the,edge,data,set,with,an,input,data,set,on,the,composite,key,of,both,source,and,target,ids,and,applies,a,user,defined,transformation,on,the,values,of,the,matched,records,the,first,two,fields,of,the,input,data,set,are,used,as,join,keys,param,input,data,set,the,data,set,to,join,with,the,first,two,fields,of,the,tuple3,are,used,as,the,composite,join,key,and,the,third,field,is,passed,as,a,parameter,to,the,transformation,function,param,edge,join,function,the,transformation,function,to,apply,the,first,parameter,is,the,current,edge,value,and,the,second,parameter,is,the,value,of,the,matched,tuple3,from,the,input,data,set,param,t,the,type,of,the,third,field,of,the,input,tuple3,data,set,return,a,new,graph,where,the,edge,values,have,been,updated,according,to,the,result,of,the,edge,join,function;public,t,graph,k,vv,ev,join,with,edges,data,set,tuple3,k,k,t,input,data,set,final,edge,join,function,ev,t,edge,join,function,data,set,edge,k,ev,resulted,edges,this,get,edges,co,group,input,data,set,where,0,1,equal,to,0,1,with,new,apply,co,group,to,edge,values,k,ev,t,edge,join,function,return,new,graph,k,vv,ev,this,vertices,resulted,edges,this,context
Graph -> public <T> Graph<K, VV, EV> joinWithEdges(DataSet<Tuple3<K, K, T>> inputDataSet, 			final EdgeJoinFunction<EV, T> edgeJoinFunction);1462100316;Joins the edge DataSet with an input DataSet on the composite key of both_source and target IDs and applies a user-defined transformation on the values_of the matched records. The first two fields of the input DataSet are used as join keys.__@param inputDataSet the DataSet to join with._The first two fields of the Tuple3 are used as the composite join key_and the third field is passed as a parameter to the transformation function._@param edgeJoinFunction the transformation function to apply._The first parameter is the current edge value and the second parameter is the value_of the matched Tuple3 from the input DataSet._@param <T> the type of the third field of the input Tuple3 DataSet._@return a new Graph, where the edge values have been updated according to the_result of the edgeJoinFunction.;public <T> Graph<K, VV, EV> joinWithEdges(DataSet<Tuple3<K, K, T>> inputDataSet,_			final EdgeJoinFunction<EV, T> edgeJoinFunction) {__		DataSet<Edge<K, EV>> resultedEdges = this.getEdges()_				.coGroup(inputDataSet).where(0, 1).equalTo(0, 1)_				.with(new ApplyCoGroupToEdgeValues<K, EV, T>(edgeJoinFunction))__		return new Graph<K, VV, EV>(this.vertices, resultedEdges, this.context)__	};joins,the,edge,data,set,with,an,input,data,set,on,the,composite,key,of,both,source,and,target,ids,and,applies,a,user,defined,transformation,on,the,values,of,the,matched,records,the,first,two,fields,of,the,input,data,set,are,used,as,join,keys,param,input,data,set,the,data,set,to,join,with,the,first,two,fields,of,the,tuple3,are,used,as,the,composite,join,key,and,the,third,field,is,passed,as,a,parameter,to,the,transformation,function,param,edge,join,function,the,transformation,function,to,apply,the,first,parameter,is,the,current,edge,value,and,the,second,parameter,is,the,value,of,the,matched,tuple3,from,the,input,data,set,param,t,the,type,of,the,third,field,of,the,input,tuple3,data,set,return,a,new,graph,where,the,edge,values,have,been,updated,according,to,the,result,of,the,edge,join,function;public,t,graph,k,vv,ev,join,with,edges,data,set,tuple3,k,k,t,input,data,set,final,edge,join,function,ev,t,edge,join,function,data,set,edge,k,ev,resulted,edges,this,get,edges,co,group,input,data,set,where,0,1,equal,to,0,1,with,new,apply,co,group,to,edge,values,k,ev,t,edge,join,function,return,new,graph,k,vv,ev,this,vertices,resulted,edges,this,context
Graph -> public <T> Graph<K, VV, EV> joinWithEdges(DataSet<Tuple3<K, K, T>> inputDataSet, 			final EdgeJoinFunction<EV, T> edgeJoinFunction);1462205213;Joins the edge DataSet with an input DataSet on the composite key of both_source and target IDs and applies a user-defined transformation on the values_of the matched records. The first two fields of the input DataSet are used as join keys.__@param inputDataSet the DataSet to join with._The first two fields of the Tuple3 are used as the composite join key_and the third field is passed as a parameter to the transformation function._@param edgeJoinFunction the transformation function to apply._The first parameter is the current edge value and the second parameter is the value_of the matched Tuple3 from the input DataSet._@param <T> the type of the third field of the input Tuple3 DataSet._@return a new Graph, where the edge values have been updated according to the_result of the edgeJoinFunction.;public <T> Graph<K, VV, EV> joinWithEdges(DataSet<Tuple3<K, K, T>> inputDataSet,_			final EdgeJoinFunction<EV, T> edgeJoinFunction) {__		DataSet<Edge<K, EV>> resultedEdges = this.getEdges()_				.coGroup(inputDataSet).where(0, 1).equalTo(0, 1)_				.with(new ApplyCoGroupToEdgeValues<K, EV, T>(edgeJoinFunction))__		return new Graph<K, VV, EV>(this.vertices, resultedEdges, this.context)__	};joins,the,edge,data,set,with,an,input,data,set,on,the,composite,key,of,both,source,and,target,ids,and,applies,a,user,defined,transformation,on,the,values,of,the,matched,records,the,first,two,fields,of,the,input,data,set,are,used,as,join,keys,param,input,data,set,the,data,set,to,join,with,the,first,two,fields,of,the,tuple3,are,used,as,the,composite,join,key,and,the,third,field,is,passed,as,a,parameter,to,the,transformation,function,param,edge,join,function,the,transformation,function,to,apply,the,first,parameter,is,the,current,edge,value,and,the,second,parameter,is,the,value,of,the,matched,tuple3,from,the,input,data,set,param,t,the,type,of,the,third,field,of,the,input,tuple3,data,set,return,a,new,graph,where,the,edge,values,have,been,updated,according,to,the,result,of,the,edge,join,function;public,t,graph,k,vv,ev,join,with,edges,data,set,tuple3,k,k,t,input,data,set,final,edge,join,function,ev,t,edge,join,function,data,set,edge,k,ev,resulted,edges,this,get,edges,co,group,input,data,set,where,0,1,equal,to,0,1,with,new,apply,co,group,to,edge,values,k,ev,t,edge,join,function,return,new,graph,k,vv,ev,this,vertices,resulted,edges,this,context
Graph -> public <T> Graph<K, VV, EV> joinWithEdges(DataSet<Tuple3<K, K, T>> inputDataSet, 			final EdgeJoinFunction<EV, T> edgeJoinFunction);1462208859;Joins the edge DataSet with an input DataSet on the composite key of both_source and target IDs and applies a user-defined transformation on the values_of the matched records. The first two fields of the input DataSet are used as join keys.__@param inputDataSet the DataSet to join with._The first two fields of the Tuple3 are used as the composite join key_and the third field is passed as a parameter to the transformation function._@param edgeJoinFunction the transformation function to apply._The first parameter is the current edge value and the second parameter is the value_of the matched Tuple3 from the input DataSet._@param <T> the type of the third field of the input Tuple3 DataSet._@return a new Graph, where the edge values have been updated according to the_result of the edgeJoinFunction.;public <T> Graph<K, VV, EV> joinWithEdges(DataSet<Tuple3<K, K, T>> inputDataSet,_			final EdgeJoinFunction<EV, T> edgeJoinFunction) {__		DataSet<Edge<K, EV>> resultedEdges = this.getEdges()_				.coGroup(inputDataSet).where(0, 1).equalTo(0, 1)_				.with(new ApplyCoGroupToEdgeValues<K, EV, T>(edgeJoinFunction))__		return new Graph<K, VV, EV>(this.vertices, resultedEdges, this.context)__	};joins,the,edge,data,set,with,an,input,data,set,on,the,composite,key,of,both,source,and,target,ids,and,applies,a,user,defined,transformation,on,the,values,of,the,matched,records,the,first,two,fields,of,the,input,data,set,are,used,as,join,keys,param,input,data,set,the,data,set,to,join,with,the,first,two,fields,of,the,tuple3,are,used,as,the,composite,join,key,and,the,third,field,is,passed,as,a,parameter,to,the,transformation,function,param,edge,join,function,the,transformation,function,to,apply,the,first,parameter,is,the,current,edge,value,and,the,second,parameter,is,the,value,of,the,matched,tuple3,from,the,input,data,set,param,t,the,type,of,the,third,field,of,the,input,tuple3,data,set,return,a,new,graph,where,the,edge,values,have,been,updated,according,to,the,result,of,the,edge,join,function;public,t,graph,k,vv,ev,join,with,edges,data,set,tuple3,k,k,t,input,data,set,final,edge,join,function,ev,t,edge,join,function,data,set,edge,k,ev,resulted,edges,this,get,edges,co,group,input,data,set,where,0,1,equal,to,0,1,with,new,apply,co,group,to,edge,values,k,ev,t,edge,join,function,return,new,graph,k,vv,ev,this,vertices,resulted,edges,this,context
Graph -> public <T> Graph<K, VV, EV> joinWithEdges(DataSet<Tuple3<K, K, T>> inputDataSet, 			final EdgeJoinFunction<EV, T> edgeJoinFunction);1462809297;Joins the edge DataSet with an input DataSet on the composite key of both_source and target IDs and applies a user-defined transformation on the values_of the matched records. The first two fields of the input DataSet are used as join keys.__@param inputDataSet the DataSet to join with._The first two fields of the Tuple3 are used as the composite join key_and the third field is passed as a parameter to the transformation function._@param edgeJoinFunction the transformation function to apply._The first parameter is the current edge value and the second parameter is the value_of the matched Tuple3 from the input DataSet._@param <T> the type of the third field of the input Tuple3 DataSet._@return a new Graph, where the edge values have been updated according to the_result of the edgeJoinFunction.;public <T> Graph<K, VV, EV> joinWithEdges(DataSet<Tuple3<K, K, T>> inputDataSet,_			final EdgeJoinFunction<EV, T> edgeJoinFunction) {__		DataSet<Edge<K, EV>> resultedEdges = this.getEdges()_				.coGroup(inputDataSet).where(0, 1).equalTo(0, 1)_				.with(new ApplyCoGroupToEdgeValues<K, EV, T>(edgeJoinFunction))__		return new Graph<K, VV, EV>(this.vertices, resultedEdges, this.context)__	};joins,the,edge,data,set,with,an,input,data,set,on,the,composite,key,of,both,source,and,target,ids,and,applies,a,user,defined,transformation,on,the,values,of,the,matched,records,the,first,two,fields,of,the,input,data,set,are,used,as,join,keys,param,input,data,set,the,data,set,to,join,with,the,first,two,fields,of,the,tuple3,are,used,as,the,composite,join,key,and,the,third,field,is,passed,as,a,parameter,to,the,transformation,function,param,edge,join,function,the,transformation,function,to,apply,the,first,parameter,is,the,current,edge,value,and,the,second,parameter,is,the,value,of,the,matched,tuple3,from,the,input,data,set,param,t,the,type,of,the,third,field,of,the,input,tuple3,data,set,return,a,new,graph,where,the,edge,values,have,been,updated,according,to,the,result,of,the,edge,join,function;public,t,graph,k,vv,ev,join,with,edges,data,set,tuple3,k,k,t,input,data,set,final,edge,join,function,ev,t,edge,join,function,data,set,edge,k,ev,resulted,edges,this,get,edges,co,group,input,data,set,where,0,1,equal,to,0,1,with,new,apply,co,group,to,edge,values,k,ev,t,edge,join,function,return,new,graph,k,vv,ev,this,vertices,resulted,edges,this,context
Graph -> public <T> Graph<K, VV, EV> joinWithEdges(DataSet<Tuple3<K, K, T>> inputDataSet, 			final EdgeJoinFunction<EV, T> edgeJoinFunction);1465316775;Joins the edge DataSet with an input DataSet on the composite key of both_source and target IDs and applies a user-defined transformation on the values_of the matched records. The first two fields of the input DataSet are used as join keys.__@param inputDataSet the DataSet to join with._The first two fields of the Tuple3 are used as the composite join key_and the third field is passed as a parameter to the transformation function._@param edgeJoinFunction the transformation function to apply._The first parameter is the current edge value and the second parameter is the value_of the matched Tuple3 from the input DataSet._@param <T> the type of the third field of the input Tuple3 DataSet._@return a new Graph, where the edge values have been updated according to the_result of the edgeJoinFunction.;public <T> Graph<K, VV, EV> joinWithEdges(DataSet<Tuple3<K, K, T>> inputDataSet,_			final EdgeJoinFunction<EV, T> edgeJoinFunction) {__		DataSet<Edge<K, EV>> resultedEdges = this.getEdges()_				.coGroup(inputDataSet).where(0, 1).equalTo(0, 1)_				.with(new ApplyCoGroupToEdgeValues<K, EV, T>(edgeJoinFunction))__		return new Graph<K, VV, EV>(this.vertices, resultedEdges, this.context)__	};joins,the,edge,data,set,with,an,input,data,set,on,the,composite,key,of,both,source,and,target,ids,and,applies,a,user,defined,transformation,on,the,values,of,the,matched,records,the,first,two,fields,of,the,input,data,set,are,used,as,join,keys,param,input,data,set,the,data,set,to,join,with,the,first,two,fields,of,the,tuple3,are,used,as,the,composite,join,key,and,the,third,field,is,passed,as,a,parameter,to,the,transformation,function,param,edge,join,function,the,transformation,function,to,apply,the,first,parameter,is,the,current,edge,value,and,the,second,parameter,is,the,value,of,the,matched,tuple3,from,the,input,data,set,param,t,the,type,of,the,third,field,of,the,input,tuple3,data,set,return,a,new,graph,where,the,edge,values,have,been,updated,according,to,the,result,of,the,edge,join,function;public,t,graph,k,vv,ev,join,with,edges,data,set,tuple3,k,k,t,input,data,set,final,edge,join,function,ev,t,edge,join,function,data,set,edge,k,ev,resulted,edges,this,get,edges,co,group,input,data,set,where,0,1,equal,to,0,1,with,new,apply,co,group,to,edge,values,k,ev,t,edge,join,function,return,new,graph,k,vv,ev,this,vertices,resulted,edges,this,context
Graph -> public <T> Graph<K, VV, EV> joinWithEdges(DataSet<Tuple3<K, K, T>> inputDataSet, 			final EdgeJoinFunction<EV, T> edgeJoinFunction);1466789678;Joins the edge DataSet with an input DataSet on the composite key of both_source and target IDs and applies a user-defined transformation on the values_of the matched records. The first two fields of the input DataSet are used as join keys.__@param inputDataSet the DataSet to join with._The first two fields of the Tuple3 are used as the composite join key_and the third field is passed as a parameter to the transformation function._@param edgeJoinFunction the transformation function to apply._The first parameter is the current edge value and the second parameter is the value_of the matched Tuple3 from the input DataSet._@param <T> the type of the third field of the input Tuple3 DataSet._@return a new Graph, where the edge values have been updated according to the_result of the edgeJoinFunction.;public <T> Graph<K, VV, EV> joinWithEdges(DataSet<Tuple3<K, K, T>> inputDataSet,_			final EdgeJoinFunction<EV, T> edgeJoinFunction) {__		DataSet<Edge<K, EV>> resultedEdges = this.getEdges()_				.coGroup(inputDataSet).where(0, 1).equalTo(0, 1)_				.with(new ApplyCoGroupToEdgeValues<K, EV, T>(edgeJoinFunction))__		return new Graph<K, VV, EV>(this.vertices, resultedEdges, this.context)__	};joins,the,edge,data,set,with,an,input,data,set,on,the,composite,key,of,both,source,and,target,ids,and,applies,a,user,defined,transformation,on,the,values,of,the,matched,records,the,first,two,fields,of,the,input,data,set,are,used,as,join,keys,param,input,data,set,the,data,set,to,join,with,the,first,two,fields,of,the,tuple3,are,used,as,the,composite,join,key,and,the,third,field,is,passed,as,a,parameter,to,the,transformation,function,param,edge,join,function,the,transformation,function,to,apply,the,first,parameter,is,the,current,edge,value,and,the,second,parameter,is,the,value,of,the,matched,tuple3,from,the,input,data,set,param,t,the,type,of,the,third,field,of,the,input,tuple3,data,set,return,a,new,graph,where,the,edge,values,have,been,updated,according,to,the,result,of,the,edge,join,function;public,t,graph,k,vv,ev,join,with,edges,data,set,tuple3,k,k,t,input,data,set,final,edge,join,function,ev,t,edge,join,function,data,set,edge,k,ev,resulted,edges,this,get,edges,co,group,input,data,set,where,0,1,equal,to,0,1,with,new,apply,co,group,to,edge,values,k,ev,t,edge,join,function,return,new,graph,k,vv,ev,this,vertices,resulted,edges,this,context
Graph -> public <T> Graph<K, VV, EV> joinWithEdges(DataSet<Tuple3<K, K, T>> inputDataSet, 			final EdgeJoinFunction<EV, T> edgeJoinFunction);1467140656;Joins the edge DataSet with an input DataSet on the composite key of both_source and target IDs and applies a user-defined transformation on the values_of the matched records. The first two fields of the input DataSet are used as join keys.__@param inputDataSet the DataSet to join with._The first two fields of the Tuple3 are used as the composite join key_and the third field is passed as a parameter to the transformation function._@param edgeJoinFunction the transformation function to apply._The first parameter is the current edge value and the second parameter is the value_of the matched Tuple3 from the input DataSet._@param <T> the type of the third field of the input Tuple3 DataSet._@return a new Graph, where the edge values have been updated according to the_result of the edgeJoinFunction.;public <T> Graph<K, VV, EV> joinWithEdges(DataSet<Tuple3<K, K, T>> inputDataSet,_			final EdgeJoinFunction<EV, T> edgeJoinFunction) {__		DataSet<Edge<K, EV>> resultedEdges = this.getEdges()_				.coGroup(inputDataSet).where(0, 1).equalTo(0, 1)_				.with(new ApplyCoGroupToEdgeValues<K, EV, T>(edgeJoinFunction))__		return new Graph<K, VV, EV>(this.vertices, resultedEdges, this.context)__	};joins,the,edge,data,set,with,an,input,data,set,on,the,composite,key,of,both,source,and,target,ids,and,applies,a,user,defined,transformation,on,the,values,of,the,matched,records,the,first,two,fields,of,the,input,data,set,are,used,as,join,keys,param,input,data,set,the,data,set,to,join,with,the,first,two,fields,of,the,tuple3,are,used,as,the,composite,join,key,and,the,third,field,is,passed,as,a,parameter,to,the,transformation,function,param,edge,join,function,the,transformation,function,to,apply,the,first,parameter,is,the,current,edge,value,and,the,second,parameter,is,the,value,of,the,matched,tuple3,from,the,input,data,set,param,t,the,type,of,the,third,field,of,the,input,tuple3,data,set,return,a,new,graph,where,the,edge,values,have,been,updated,according,to,the,result,of,the,edge,join,function;public,t,graph,k,vv,ev,join,with,edges,data,set,tuple3,k,k,t,input,data,set,final,edge,join,function,ev,t,edge,join,function,data,set,edge,k,ev,resulted,edges,this,get,edges,co,group,input,data,set,where,0,1,equal,to,0,1,with,new,apply,co,group,to,edge,values,k,ev,t,edge,join,function,return,new,graph,k,vv,ev,this,vertices,resulted,edges,this,context
Graph -> public <T> Graph<K, VV, EV> joinWithEdges(DataSet<Tuple3<K, K, T>> inputDataSet, 			final EdgeJoinFunction<EV, T> edgeJoinFunction);1467306272;Joins the edge DataSet with an input DataSet on the composite key of both_source and target IDs and applies a user-defined transformation on the values_of the matched records. The first two fields of the input DataSet are used as join keys.__@param inputDataSet the DataSet to join with._The first two fields of the Tuple3 are used as the composite join key_and the third field is passed as a parameter to the transformation function._@param edgeJoinFunction the transformation function to apply._The first parameter is the current edge value and the second parameter is the value_of the matched Tuple3 from the input DataSet._@param <T> the type of the third field of the input Tuple3 DataSet._@return a new Graph, where the edge values have been updated according to the_result of the edgeJoinFunction.;public <T> Graph<K, VV, EV> joinWithEdges(DataSet<Tuple3<K, K, T>> inputDataSet,_			final EdgeJoinFunction<EV, T> edgeJoinFunction) {__		DataSet<Edge<K, EV>> resultedEdges = this.getEdges()_				.coGroup(inputDataSet).where(0, 1).equalTo(0, 1)_				.with(new ApplyCoGroupToEdgeValues<K, EV, T>(edgeJoinFunction))__		return new Graph<K, VV, EV>(this.vertices, resultedEdges, this.context)__	};joins,the,edge,data,set,with,an,input,data,set,on,the,composite,key,of,both,source,and,target,ids,and,applies,a,user,defined,transformation,on,the,values,of,the,matched,records,the,first,two,fields,of,the,input,data,set,are,used,as,join,keys,param,input,data,set,the,data,set,to,join,with,the,first,two,fields,of,the,tuple3,are,used,as,the,composite,join,key,and,the,third,field,is,passed,as,a,parameter,to,the,transformation,function,param,edge,join,function,the,transformation,function,to,apply,the,first,parameter,is,the,current,edge,value,and,the,second,parameter,is,the,value,of,the,matched,tuple3,from,the,input,data,set,param,t,the,type,of,the,third,field,of,the,input,tuple3,data,set,return,a,new,graph,where,the,edge,values,have,been,updated,according,to,the,result,of,the,edge,join,function;public,t,graph,k,vv,ev,join,with,edges,data,set,tuple3,k,k,t,input,data,set,final,edge,join,function,ev,t,edge,join,function,data,set,edge,k,ev,resulted,edges,this,get,edges,co,group,input,data,set,where,0,1,equal,to,0,1,with,new,apply,co,group,to,edge,values,k,ev,t,edge,join,function,return,new,graph,k,vv,ev,this,vertices,resulted,edges,this,context
Graph -> public <T> Graph<K, VV, EV> joinWithEdges(DataSet<Tuple3<K, K, T>> inputDataSet, 			final EdgeJoinFunction<EV, T> edgeJoinFunction);1470042815;Joins the edge DataSet with an input DataSet on the composite key of both_source and target IDs and applies a user-defined transformation on the values_of the matched records. The first two fields of the input DataSet are used as join keys.__@param inputDataSet the DataSet to join with._The first two fields of the Tuple3 are used as the composite join key_and the third field is passed as a parameter to the transformation function._@param edgeJoinFunction the transformation function to apply._The first parameter is the current edge value and the second parameter is the value_of the matched Tuple3 from the input DataSet._@param <T> the type of the third field of the input Tuple3 DataSet._@return a new Graph, where the edge values have been updated according to the_result of the edgeJoinFunction.;public <T> Graph<K, VV, EV> joinWithEdges(DataSet<Tuple3<K, K, T>> inputDataSet,_			final EdgeJoinFunction<EV, T> edgeJoinFunction) {__		DataSet<Edge<K, EV>> resultedEdges = this.getEdges()_				.coGroup(inputDataSet).where(0, 1).equalTo(0, 1)_				.with(new ApplyCoGroupToEdgeValues<K, EV, T>(edgeJoinFunction))__		return new Graph<K, VV, EV>(this.vertices, resultedEdges, this.context)__	};joins,the,edge,data,set,with,an,input,data,set,on,the,composite,key,of,both,source,and,target,ids,and,applies,a,user,defined,transformation,on,the,values,of,the,matched,records,the,first,two,fields,of,the,input,data,set,are,used,as,join,keys,param,input,data,set,the,data,set,to,join,with,the,first,two,fields,of,the,tuple3,are,used,as,the,composite,join,key,and,the,third,field,is,passed,as,a,parameter,to,the,transformation,function,param,edge,join,function,the,transformation,function,to,apply,the,first,parameter,is,the,current,edge,value,and,the,second,parameter,is,the,value,of,the,matched,tuple3,from,the,input,data,set,param,t,the,type,of,the,third,field,of,the,input,tuple3,data,set,return,a,new,graph,where,the,edge,values,have,been,updated,according,to,the,result,of,the,edge,join,function;public,t,graph,k,vv,ev,join,with,edges,data,set,tuple3,k,k,t,input,data,set,final,edge,join,function,ev,t,edge,join,function,data,set,edge,k,ev,resulted,edges,this,get,edges,co,group,input,data,set,where,0,1,equal,to,0,1,with,new,apply,co,group,to,edge,values,k,ev,t,edge,join,function,return,new,graph,k,vv,ev,this,vertices,resulted,edges,this,context
Graph -> public <T> Graph<K, VV, EV> joinWithEdges(DataSet<Tuple3<K, K, T>> inputDataSet, 			final EdgeJoinFunction<EV, T> edgeJoinFunction);1475684776;Joins the edge DataSet with an input DataSet on the composite key of both_source and target IDs and applies a user-defined transformation on the values_of the matched records. The first two fields of the input DataSet are used as join keys.__@param inputDataSet the DataSet to join with._The first two fields of the Tuple3 are used as the composite join key_and the third field is passed as a parameter to the transformation function._@param edgeJoinFunction the transformation function to apply._The first parameter is the current edge value and the second parameter is the value_of the matched Tuple3 from the input DataSet._@param <T> the type of the third field of the input Tuple3 DataSet._@return a new Graph, where the edge values have been updated according to the_result of the edgeJoinFunction.;public <T> Graph<K, VV, EV> joinWithEdges(DataSet<Tuple3<K, K, T>> inputDataSet,_			final EdgeJoinFunction<EV, T> edgeJoinFunction) {__		DataSet<Edge<K, EV>> resultedEdges = this.getEdges()_				.coGroup(inputDataSet).where(0, 1).equalTo(0, 1)_				.with(new ApplyCoGroupToEdgeValues<K, EV, T>(edgeJoinFunction))__		return new Graph<>(this.vertices, resultedEdges, this.context)__	};joins,the,edge,data,set,with,an,input,data,set,on,the,composite,key,of,both,source,and,target,ids,and,applies,a,user,defined,transformation,on,the,values,of,the,matched,records,the,first,two,fields,of,the,input,data,set,are,used,as,join,keys,param,input,data,set,the,data,set,to,join,with,the,first,two,fields,of,the,tuple3,are,used,as,the,composite,join,key,and,the,third,field,is,passed,as,a,parameter,to,the,transformation,function,param,edge,join,function,the,transformation,function,to,apply,the,first,parameter,is,the,current,edge,value,and,the,second,parameter,is,the,value,of,the,matched,tuple3,from,the,input,data,set,param,t,the,type,of,the,third,field,of,the,input,tuple3,data,set,return,a,new,graph,where,the,edge,values,have,been,updated,according,to,the,result,of,the,edge,join,function;public,t,graph,k,vv,ev,join,with,edges,data,set,tuple3,k,k,t,input,data,set,final,edge,join,function,ev,t,edge,join,function,data,set,edge,k,ev,resulted,edges,this,get,edges,co,group,input,data,set,where,0,1,equal,to,0,1,with,new,apply,co,group,to,edge,values,k,ev,t,edge,join,function,return,new,graph,this,vertices,resulted,edges,this,context
Graph -> public <T> Graph<K, VV, EV> joinWithEdges(DataSet<Tuple3<K, K, T>> inputDataSet, 			final EdgeJoinFunction<EV, T> edgeJoinFunction);1475685606;Joins the edge DataSet with an input DataSet on the composite key of both_source and target IDs and applies a user-defined transformation on the values_of the matched records. The first two fields of the input DataSet are used as join keys.__@param inputDataSet the DataSet to join with._The first two fields of the Tuple3 are used as the composite join key_and the third field is passed as a parameter to the transformation function._@param edgeJoinFunction the transformation function to apply._The first parameter is the current edge value and the second parameter is the value_of the matched Tuple3 from the input DataSet._@param <T> the type of the third field of the input Tuple3 DataSet._@return a new Graph, where the edge values have been updated according to the_result of the edgeJoinFunction.;public <T> Graph<K, VV, EV> joinWithEdges(DataSet<Tuple3<K, K, T>> inputDataSet,_			final EdgeJoinFunction<EV, T> edgeJoinFunction) {__		DataSet<Edge<K, EV>> resultedEdges = this.getEdges()_				.coGroup(inputDataSet).where(0, 1).equalTo(0, 1)_				.with(new ApplyCoGroupToEdgeValues<K, EV, T>(edgeJoinFunction))__		return new Graph<>(this.vertices, resultedEdges, this.context)__	};joins,the,edge,data,set,with,an,input,data,set,on,the,composite,key,of,both,source,and,target,ids,and,applies,a,user,defined,transformation,on,the,values,of,the,matched,records,the,first,two,fields,of,the,input,data,set,are,used,as,join,keys,param,input,data,set,the,data,set,to,join,with,the,first,two,fields,of,the,tuple3,are,used,as,the,composite,join,key,and,the,third,field,is,passed,as,a,parameter,to,the,transformation,function,param,edge,join,function,the,transformation,function,to,apply,the,first,parameter,is,the,current,edge,value,and,the,second,parameter,is,the,value,of,the,matched,tuple3,from,the,input,data,set,param,t,the,type,of,the,third,field,of,the,input,tuple3,data,set,return,a,new,graph,where,the,edge,values,have,been,updated,according,to,the,result,of,the,edge,join,function;public,t,graph,k,vv,ev,join,with,edges,data,set,tuple3,k,k,t,input,data,set,final,edge,join,function,ev,t,edge,join,function,data,set,edge,k,ev,resulted,edges,this,get,edges,co,group,input,data,set,where,0,1,equal,to,0,1,with,new,apply,co,group,to,edge,values,k,ev,t,edge,join,function,return,new,graph,this,vertices,resulted,edges,this,context
Graph -> public <T> Graph<K, VV, EV> joinWithEdges(DataSet<Tuple3<K, K, T>> inputDataSet, 			final EdgeJoinFunction<EV, T> edgeJoinFunction);1481745825;Joins the edge DataSet with an input DataSet on the composite key of both_source and target IDs and applies a user-defined transformation on the values_of the matched records. The first two fields of the input DataSet are used as join keys.__@param inputDataSet the DataSet to join with._The first two fields of the Tuple3 are used as the composite join key_and the third field is passed as a parameter to the transformation function._@param edgeJoinFunction the transformation function to apply._The first parameter is the current edge value and the second parameter is the value_of the matched Tuple3 from the input DataSet._@param <T> the type of the third field of the input Tuple3 DataSet._@return a new Graph, where the edge values have been updated according to the_result of the edgeJoinFunction.;public <T> Graph<K, VV, EV> joinWithEdges(DataSet<Tuple3<K, K, T>> inputDataSet,_			final EdgeJoinFunction<EV, T> edgeJoinFunction) {__		DataSet<Edge<K, EV>> resultedEdges = this.getEdges()_				.coGroup(inputDataSet).where(0, 1).equalTo(0, 1)_				.with(new ApplyCoGroupToEdgeValues<K, EV, T>(edgeJoinFunction))_					.name("Join with edges")__		return new Graph<>(this.vertices, resultedEdges, this.context)__	};joins,the,edge,data,set,with,an,input,data,set,on,the,composite,key,of,both,source,and,target,ids,and,applies,a,user,defined,transformation,on,the,values,of,the,matched,records,the,first,two,fields,of,the,input,data,set,are,used,as,join,keys,param,input,data,set,the,data,set,to,join,with,the,first,two,fields,of,the,tuple3,are,used,as,the,composite,join,key,and,the,third,field,is,passed,as,a,parameter,to,the,transformation,function,param,edge,join,function,the,transformation,function,to,apply,the,first,parameter,is,the,current,edge,value,and,the,second,parameter,is,the,value,of,the,matched,tuple3,from,the,input,data,set,param,t,the,type,of,the,third,field,of,the,input,tuple3,data,set,return,a,new,graph,where,the,edge,values,have,been,updated,according,to,the,result,of,the,edge,join,function;public,t,graph,k,vv,ev,join,with,edges,data,set,tuple3,k,k,t,input,data,set,final,edge,join,function,ev,t,edge,join,function,data,set,edge,k,ev,resulted,edges,this,get,edges,co,group,input,data,set,where,0,1,equal,to,0,1,with,new,apply,co,group,to,edge,values,k,ev,t,edge,join,function,name,join,with,edges,return,new,graph,this,vertices,resulted,edges,this,context
Graph -> public <T> Graph<K, VV, EV> joinWithEdges(DataSet<Tuple3<K, K, T>> inputDataSet, 			final EdgeJoinFunction<EV, T> edgeJoinFunction);1481881009;Joins the edge DataSet with an input DataSet on the composite key of both_source and target IDs and applies a user-defined transformation on the values_of the matched records. The first two fields of the input DataSet are used as join keys.__@param inputDataSet the DataSet to join with._The first two fields of the Tuple3 are used as the composite join key_and the third field is passed as a parameter to the transformation function._@param edgeJoinFunction the transformation function to apply._The first parameter is the current edge value and the second parameter is the value_of the matched Tuple3 from the input DataSet._@param <T> the type of the third field of the input Tuple3 DataSet._@return a new Graph, where the edge values have been updated according to the_result of the edgeJoinFunction.;public <T> Graph<K, VV, EV> joinWithEdges(DataSet<Tuple3<K, K, T>> inputDataSet,_			final EdgeJoinFunction<EV, T> edgeJoinFunction) {__		DataSet<Edge<K, EV>> resultedEdges = this.getEdges()_				.coGroup(inputDataSet).where(0, 1).equalTo(0, 1)_				.with(new ApplyCoGroupToEdgeValues<K, EV, T>(edgeJoinFunction))_					.name("Join with edges")__		return new Graph<>(this.vertices, resultedEdges, this.context)__	};joins,the,edge,data,set,with,an,input,data,set,on,the,composite,key,of,both,source,and,target,ids,and,applies,a,user,defined,transformation,on,the,values,of,the,matched,records,the,first,two,fields,of,the,input,data,set,are,used,as,join,keys,param,input,data,set,the,data,set,to,join,with,the,first,two,fields,of,the,tuple3,are,used,as,the,composite,join,key,and,the,third,field,is,passed,as,a,parameter,to,the,transformation,function,param,edge,join,function,the,transformation,function,to,apply,the,first,parameter,is,the,current,edge,value,and,the,second,parameter,is,the,value,of,the,matched,tuple3,from,the,input,data,set,param,t,the,type,of,the,third,field,of,the,input,tuple3,data,set,return,a,new,graph,where,the,edge,values,have,been,updated,according,to,the,result,of,the,edge,join,function;public,t,graph,k,vv,ev,join,with,edges,data,set,tuple3,k,k,t,input,data,set,final,edge,join,function,ev,t,edge,join,function,data,set,edge,k,ev,resulted,edges,this,get,edges,co,group,input,data,set,where,0,1,equal,to,0,1,with,new,apply,co,group,to,edge,values,k,ev,t,edge,join,function,name,join,with,edges,return,new,graph,this,vertices,resulted,edges,this,context
Graph -> public <T> Graph<K, VV, EV> joinWithEdges(DataSet<Tuple3<K, K, T>> inputDataSet, 			final EdgeJoinFunction<EV, T> edgeJoinFunction);1484160227;Joins the edge DataSet with an input DataSet on the composite key of both_source and target IDs and applies a user-defined transformation on the values_of the matched records. The first two fields of the input DataSet are used as join keys.__@param inputDataSet the DataSet to join with._The first two fields of the Tuple3 are used as the composite join key_and the third field is passed as a parameter to the transformation function._@param edgeJoinFunction the transformation function to apply._The first parameter is the current edge value and the second parameter is the value_of the matched Tuple3 from the input DataSet._@param <T> the type of the third field of the input Tuple3 DataSet._@return a new Graph, where the edge values have been updated according to the_result of the edgeJoinFunction.;public <T> Graph<K, VV, EV> joinWithEdges(DataSet<Tuple3<K, K, T>> inputDataSet,_			final EdgeJoinFunction<EV, T> edgeJoinFunction) {__		DataSet<Edge<K, EV>> resultedEdges = this.getEdges()_				.coGroup(inputDataSet).where(0, 1).equalTo(0, 1)_				.with(new ApplyCoGroupToEdgeValues<K, EV, T>(edgeJoinFunction))_					.name("Join with edges")__		return new Graph<>(this.vertices, resultedEdges, this.context)__	};joins,the,edge,data,set,with,an,input,data,set,on,the,composite,key,of,both,source,and,target,ids,and,applies,a,user,defined,transformation,on,the,values,of,the,matched,records,the,first,two,fields,of,the,input,data,set,are,used,as,join,keys,param,input,data,set,the,data,set,to,join,with,the,first,two,fields,of,the,tuple3,are,used,as,the,composite,join,key,and,the,third,field,is,passed,as,a,parameter,to,the,transformation,function,param,edge,join,function,the,transformation,function,to,apply,the,first,parameter,is,the,current,edge,value,and,the,second,parameter,is,the,value,of,the,matched,tuple3,from,the,input,data,set,param,t,the,type,of,the,third,field,of,the,input,tuple3,data,set,return,a,new,graph,where,the,edge,values,have,been,updated,according,to,the,result,of,the,edge,join,function;public,t,graph,k,vv,ev,join,with,edges,data,set,tuple3,k,k,t,input,data,set,final,edge,join,function,ev,t,edge,join,function,data,set,edge,k,ev,resulted,edges,this,get,edges,co,group,input,data,set,where,0,1,equal,to,0,1,with,new,apply,co,group,to,edge,values,k,ev,t,edge,join,function,name,join,with,edges,return,new,graph,this,vertices,resulted,edges,this,context
Graph -> public <T> Graph<K, VV, EV> joinWithEdges(DataSet<Tuple3<K, K, T>> inputDataSet, 			final EdgeJoinFunction<EV, T> edgeJoinFunction);1484685504;Joins the edge DataSet with an input DataSet on the composite key of both_source and target IDs and applies a user-defined transformation on the values_of the matched records. The first two fields of the input DataSet are used as join keys.__@param inputDataSet the DataSet to join with._The first two fields of the Tuple3 are used as the composite join key_and the third field is passed as a parameter to the transformation function._@param edgeJoinFunction the transformation function to apply._The first parameter is the current edge value and the second parameter is the value_of the matched Tuple3 from the input DataSet._@param <T> the type of the third field of the input Tuple3 DataSet._@return a new Graph, where the edge values have been updated according to the_result of the edgeJoinFunction.;public <T> Graph<K, VV, EV> joinWithEdges(DataSet<Tuple3<K, K, T>> inputDataSet,_			final EdgeJoinFunction<EV, T> edgeJoinFunction) {__		DataSet<Edge<K, EV>> resultedEdges = this.getEdges()_				.coGroup(inputDataSet).where(0, 1).equalTo(0, 1)_				.with(new ApplyCoGroupToEdgeValues<K, EV, T>(edgeJoinFunction))_					.name("Join with edges")__		return new Graph<>(this.vertices, resultedEdges, this.context)__	};joins,the,edge,data,set,with,an,input,data,set,on,the,composite,key,of,both,source,and,target,ids,and,applies,a,user,defined,transformation,on,the,values,of,the,matched,records,the,first,two,fields,of,the,input,data,set,are,used,as,join,keys,param,input,data,set,the,data,set,to,join,with,the,first,two,fields,of,the,tuple3,are,used,as,the,composite,join,key,and,the,third,field,is,passed,as,a,parameter,to,the,transformation,function,param,edge,join,function,the,transformation,function,to,apply,the,first,parameter,is,the,current,edge,value,and,the,second,parameter,is,the,value,of,the,matched,tuple3,from,the,input,data,set,param,t,the,type,of,the,third,field,of,the,input,tuple3,data,set,return,a,new,graph,where,the,edge,values,have,been,updated,according,to,the,result,of,the,edge,join,function;public,t,graph,k,vv,ev,join,with,edges,data,set,tuple3,k,k,t,input,data,set,final,edge,join,function,ev,t,edge,join,function,data,set,edge,k,ev,resulted,edges,this,get,edges,co,group,input,data,set,where,0,1,equal,to,0,1,with,new,apply,co,group,to,edge,values,k,ev,t,edge,join,function,name,join,with,edges,return,new,graph,this,vertices,resulted,edges,this,context
Graph -> public <T> Graph<K, VV, EV> joinWithEdges(DataSet<Tuple3<K, K, T>> inputDataSet, 			final EdgeJoinFunction<EV, T> edgeJoinFunction);1489068942;Joins the edge DataSet with an input DataSet on the composite key of both_source and target IDs and applies a user-defined transformation on the values_of the matched records. The first two fields of the input DataSet are used as join keys.__@param inputDataSet the DataSet to join with._The first two fields of the Tuple3 are used as the composite join key_and the third field is passed as a parameter to the transformation function._@param edgeJoinFunction the transformation function to apply._The first parameter is the current edge value and the second parameter is the value_of the matched Tuple3 from the input DataSet._@param <T> the type of the third field of the input Tuple3 DataSet._@return a new Graph, where the edge values have been updated according to the_result of the edgeJoinFunction.;public <T> Graph<K, VV, EV> joinWithEdges(DataSet<Tuple3<K, K, T>> inputDataSet,_			final EdgeJoinFunction<EV, T> edgeJoinFunction) {__		DataSet<Edge<K, EV>> resultedEdges = this.getEdges()_				.coGroup(inputDataSet).where(0, 1).equalTo(0, 1)_				.with(new ApplyCoGroupToEdgeValues<K, EV, T>(edgeJoinFunction))_					.name("Join with edges")__		return new Graph<>(this.vertices, resultedEdges, this.context)__	};joins,the,edge,data,set,with,an,input,data,set,on,the,composite,key,of,both,source,and,target,ids,and,applies,a,user,defined,transformation,on,the,values,of,the,matched,records,the,first,two,fields,of,the,input,data,set,are,used,as,join,keys,param,input,data,set,the,data,set,to,join,with,the,first,two,fields,of,the,tuple3,are,used,as,the,composite,join,key,and,the,third,field,is,passed,as,a,parameter,to,the,transformation,function,param,edge,join,function,the,transformation,function,to,apply,the,first,parameter,is,the,current,edge,value,and,the,second,parameter,is,the,value,of,the,matched,tuple3,from,the,input,data,set,param,t,the,type,of,the,third,field,of,the,input,tuple3,data,set,return,a,new,graph,where,the,edge,values,have,been,updated,according,to,the,result,of,the,edge,join,function;public,t,graph,k,vv,ev,join,with,edges,data,set,tuple3,k,k,t,input,data,set,final,edge,join,function,ev,t,edge,join,function,data,set,edge,k,ev,resulted,edges,this,get,edges,co,group,input,data,set,where,0,1,equal,to,0,1,with,new,apply,co,group,to,edge,values,k,ev,t,edge,join,function,name,join,with,edges,return,new,graph,this,vertices,resulted,edges,this,context
Graph -> public <T> Graph<K, VV, EV> joinWithEdges(DataSet<Tuple3<K, K, T>> inputDataSet, 			final EdgeJoinFunction<EV, T> edgeJoinFunction);1490973446;Joins the edge DataSet with an input DataSet on the composite key of both_source and target IDs and applies a user-defined transformation on the values_of the matched records. The first two fields of the input DataSet are used as join keys.__@param inputDataSet the DataSet to join with._The first two fields of the Tuple3 are used as the composite join key_and the third field is passed as a parameter to the transformation function._@param edgeJoinFunction the transformation function to apply._The first parameter is the current edge value and the second parameter is the value_of the matched Tuple3 from the input DataSet._@param <T> the type of the third field of the input Tuple3 DataSet._@return a new Graph, where the edge values have been updated according to the_result of the edgeJoinFunction.;public <T> Graph<K, VV, EV> joinWithEdges(DataSet<Tuple3<K, K, T>> inputDataSet,_			final EdgeJoinFunction<EV, T> edgeJoinFunction) {__		DataSet<Edge<K, EV>> resultedEdges = this.getEdges()_				.coGroup(inputDataSet).where(0, 1).equalTo(0, 1)_				.with(new ApplyCoGroupToEdgeValues<K, EV, T>(edgeJoinFunction))_					.name("Join with edges")__		return new Graph<>(this.vertices, resultedEdges, this.context)__	};joins,the,edge,data,set,with,an,input,data,set,on,the,composite,key,of,both,source,and,target,ids,and,applies,a,user,defined,transformation,on,the,values,of,the,matched,records,the,first,two,fields,of,the,input,data,set,are,used,as,join,keys,param,input,data,set,the,data,set,to,join,with,the,first,two,fields,of,the,tuple3,are,used,as,the,composite,join,key,and,the,third,field,is,passed,as,a,parameter,to,the,transformation,function,param,edge,join,function,the,transformation,function,to,apply,the,first,parameter,is,the,current,edge,value,and,the,second,parameter,is,the,value,of,the,matched,tuple3,from,the,input,data,set,param,t,the,type,of,the,third,field,of,the,input,tuple3,data,set,return,a,new,graph,where,the,edge,values,have,been,updated,according,to,the,result,of,the,edge,join,function;public,t,graph,k,vv,ev,join,with,edges,data,set,tuple3,k,k,t,input,data,set,final,edge,join,function,ev,t,edge,join,function,data,set,edge,k,ev,resulted,edges,this,get,edges,co,group,input,data,set,where,0,1,equal,to,0,1,with,new,apply,co,group,to,edge,values,k,ev,t,edge,join,function,name,join,with,edges,return,new,graph,this,vertices,resulted,edges,this,context
Graph -> public <T> Graph<K, VV, EV> joinWithEdges(DataSet<Tuple3<K, K, T>> inputDataSet, 			final EdgeJoinFunction<EV, T> edgeJoinFunction);1495819075;Joins the edge DataSet with an input DataSet on the composite key of both_source and target IDs and applies a user-defined transformation on the values_of the matched records. The first two fields of the input DataSet are used as join keys.__@param inputDataSet the DataSet to join with._The first two fields of the Tuple3 are used as the composite join key_and the third field is passed as a parameter to the transformation function._@param edgeJoinFunction the transformation function to apply._The first parameter is the current edge value and the second parameter is the value_of the matched Tuple3 from the input DataSet._@param <T> the type of the third field of the input Tuple3 DataSet._@return a new Graph, where the edge values have been updated according to the_result of the edgeJoinFunction.;public <T> Graph<K, VV, EV> joinWithEdges(DataSet<Tuple3<K, K, T>> inputDataSet,_			final EdgeJoinFunction<EV, T> edgeJoinFunction) {__		DataSet<Edge<K, EV>> resultedEdges = this.getEdges()_				.coGroup(inputDataSet).where(0, 1).equalTo(0, 1)_				.with(new ApplyCoGroupToEdgeValues<K, EV, T>(edgeJoinFunction))_					.name("Join with edges")__		return new Graph<>(this.vertices, resultedEdges, this.context)__	};joins,the,edge,data,set,with,an,input,data,set,on,the,composite,key,of,both,source,and,target,ids,and,applies,a,user,defined,transformation,on,the,values,of,the,matched,records,the,first,two,fields,of,the,input,data,set,are,used,as,join,keys,param,input,data,set,the,data,set,to,join,with,the,first,two,fields,of,the,tuple3,are,used,as,the,composite,join,key,and,the,third,field,is,passed,as,a,parameter,to,the,transformation,function,param,edge,join,function,the,transformation,function,to,apply,the,first,parameter,is,the,current,edge,value,and,the,second,parameter,is,the,value,of,the,matched,tuple3,from,the,input,data,set,param,t,the,type,of,the,third,field,of,the,input,tuple3,data,set,return,a,new,graph,where,the,edge,values,have,been,updated,according,to,the,result,of,the,edge,join,function;public,t,graph,k,vv,ev,join,with,edges,data,set,tuple3,k,k,t,input,data,set,final,edge,join,function,ev,t,edge,join,function,data,set,edge,k,ev,resulted,edges,this,get,edges,co,group,input,data,set,where,0,1,equal,to,0,1,with,new,apply,co,group,to,edge,values,k,ev,t,edge,join,function,name,join,with,edges,return,new,graph,this,vertices,resulted,edges,this,context
Graph -> public <T> Graph<K, VV, EV> joinWithEdges(DataSet<Tuple3<K, K, T>> inputDataSet, 			final EdgeJoinFunction<EV, T> edgeJoinFunction);1502111816;Joins the edge DataSet with an input DataSet on the composite key of both_source and target IDs and applies a user-defined transformation on the values_of the matched records. The first two fields of the input DataSet are used as join keys.__@param inputDataSet the DataSet to join with._The first two fields of the Tuple3 are used as the composite join key_and the third field is passed as a parameter to the transformation function._@param edgeJoinFunction the transformation function to apply._The first parameter is the current edge value and the second parameter is the value_of the matched Tuple3 from the input DataSet._@param <T> the type of the third field of the input Tuple3 DataSet._@return a new Graph, where the edge values have been updated according to the_result of the edgeJoinFunction.;public <T> Graph<K, VV, EV> joinWithEdges(DataSet<Tuple3<K, K, T>> inputDataSet,_			final EdgeJoinFunction<EV, T> edgeJoinFunction) {__		DataSet<Edge<K, EV>> resultedEdges = this.getEdges()_				.coGroup(inputDataSet).where(0, 1).equalTo(0, 1)_				.with(new ApplyCoGroupToEdgeValues<>(edgeJoinFunction))_					.name("Join with edges")__		return new Graph<>(this.vertices, resultedEdges, this.context)__	};joins,the,edge,data,set,with,an,input,data,set,on,the,composite,key,of,both,source,and,target,ids,and,applies,a,user,defined,transformation,on,the,values,of,the,matched,records,the,first,two,fields,of,the,input,data,set,are,used,as,join,keys,param,input,data,set,the,data,set,to,join,with,the,first,two,fields,of,the,tuple3,are,used,as,the,composite,join,key,and,the,third,field,is,passed,as,a,parameter,to,the,transformation,function,param,edge,join,function,the,transformation,function,to,apply,the,first,parameter,is,the,current,edge,value,and,the,second,parameter,is,the,value,of,the,matched,tuple3,from,the,input,data,set,param,t,the,type,of,the,third,field,of,the,input,tuple3,data,set,return,a,new,graph,where,the,edge,values,have,been,updated,according,to,the,result,of,the,edge,join,function;public,t,graph,k,vv,ev,join,with,edges,data,set,tuple3,k,k,t,input,data,set,final,edge,join,function,ev,t,edge,join,function,data,set,edge,k,ev,resulted,edges,this,get,edges,co,group,input,data,set,where,0,1,equal,to,0,1,with,new,apply,co,group,to,edge,values,edge,join,function,name,join,with,edges,return,new,graph,this,vertices,resulted,edges,this,context
Graph -> public <M> Graph<K, VV, EV> runVertexCentricIteration( 			ComputeFunction<K, VV, EV, M> computeFunction,  			MessageCombiner<K, M> combiner, int maximumNumberOfIterations);1458583829;Runs a VertexCentric iteration on the graph._No configuration options are provided.__@param computeFunction the vertex update function_@param combiner an optional message combiner_@param maximumNumberOfIterations maximum number of iterations to perform__@return the updated Graph after the vertex-centric iteration has converged or_after maximumNumberOfIterations.;public <M> Graph<K, VV, EV> runVertexCentricIteration(_			ComputeFunction<K, VV, EV, M> computeFunction, _			MessageCombiner<K, M> combiner, int maximumNumberOfIterations) {__		return this.runVertexCentricIteration(computeFunction, combiner, maximumNumberOfIterations, null)__	};runs,a,vertex,centric,iteration,on,the,graph,no,configuration,options,are,provided,param,compute,function,the,vertex,update,function,param,combiner,an,optional,message,combiner,param,maximum,number,of,iterations,maximum,number,of,iterations,to,perform,return,the,updated,graph,after,the,vertex,centric,iteration,has,converged,or,after,maximum,number,of,iterations;public,m,graph,k,vv,ev,run,vertex,centric,iteration,compute,function,k,vv,ev,m,compute,function,message,combiner,k,m,combiner,int,maximum,number,of,iterations,return,this,run,vertex,centric,iteration,compute,function,combiner,maximum,number,of,iterations,null
Graph -> public <M> Graph<K, VV, EV> runVertexCentricIteration( 			ComputeFunction<K, VV, EV, M> computeFunction,  			MessageCombiner<K, M> combiner, int maximumNumberOfIterations);1458583829;Runs a {@link VertexCentricIteration} on the graph._No configuration options are provided.__@param computeFunction the vertex compute function_@param combiner an optional message combiner_@param maximumNumberOfIterations maximum number of iterations to perform__@return the updated Graph after the vertex-centric iteration has converged or_after maximumNumberOfIterations.;public <M> Graph<K, VV, EV> runVertexCentricIteration(_			ComputeFunction<K, VV, EV, M> computeFunction, _			MessageCombiner<K, M> combiner, int maximumNumberOfIterations) {__		return this.runVertexCentricIteration(computeFunction, combiner, maximumNumberOfIterations, null)__	};runs,a,link,vertex,centric,iteration,on,the,graph,no,configuration,options,are,provided,param,compute,function,the,vertex,compute,function,param,combiner,an,optional,message,combiner,param,maximum,number,of,iterations,maximum,number,of,iterations,to,perform,return,the,updated,graph,after,the,vertex,centric,iteration,has,converged,or,after,maximum,number,of,iterations;public,m,graph,k,vv,ev,run,vertex,centric,iteration,compute,function,k,vv,ev,m,compute,function,message,combiner,k,m,combiner,int,maximum,number,of,iterations,return,this,run,vertex,centric,iteration,compute,function,combiner,maximum,number,of,iterations,null
Graph -> public <M> Graph<K, VV, EV> runVertexCentricIteration( 			ComputeFunction<K, VV, EV, M> computeFunction,  			MessageCombiner<K, M> combiner, int maximumNumberOfIterations);1462100316;Runs a {@link VertexCentricIteration} on the graph._No configuration options are provided.__@param computeFunction the vertex compute function_@param combiner an optional message combiner_@param maximumNumberOfIterations maximum number of iterations to perform__@return the updated Graph after the vertex-centric iteration has converged or_after maximumNumberOfIterations.;public <M> Graph<K, VV, EV> runVertexCentricIteration(_			ComputeFunction<K, VV, EV, M> computeFunction, _			MessageCombiner<K, M> combiner, int maximumNumberOfIterations) {__		return this.runVertexCentricIteration(computeFunction, combiner, maximumNumberOfIterations, null)__	};runs,a,link,vertex,centric,iteration,on,the,graph,no,configuration,options,are,provided,param,compute,function,the,vertex,compute,function,param,combiner,an,optional,message,combiner,param,maximum,number,of,iterations,maximum,number,of,iterations,to,perform,return,the,updated,graph,after,the,vertex,centric,iteration,has,converged,or,after,maximum,number,of,iterations;public,m,graph,k,vv,ev,run,vertex,centric,iteration,compute,function,k,vv,ev,m,compute,function,message,combiner,k,m,combiner,int,maximum,number,of,iterations,return,this,run,vertex,centric,iteration,compute,function,combiner,maximum,number,of,iterations,null
Graph -> public <M> Graph<K, VV, EV> runVertexCentricIteration( 			ComputeFunction<K, VV, EV, M> computeFunction,  			MessageCombiner<K, M> combiner, int maximumNumberOfIterations);1462100316;Runs a {@link VertexCentricIteration} on the graph._No configuration options are provided.__@param computeFunction the vertex compute function_@param combiner an optional message combiner_@param maximumNumberOfIterations maximum number of iterations to perform__@return the updated Graph after the vertex-centric iteration has converged or_after maximumNumberOfIterations.;public <M> Graph<K, VV, EV> runVertexCentricIteration(_			ComputeFunction<K, VV, EV, M> computeFunction, _			MessageCombiner<K, M> combiner, int maximumNumberOfIterations) {__		return this.runVertexCentricIteration(computeFunction, combiner, maximumNumberOfIterations, null)__	};runs,a,link,vertex,centric,iteration,on,the,graph,no,configuration,options,are,provided,param,compute,function,the,vertex,compute,function,param,combiner,an,optional,message,combiner,param,maximum,number,of,iterations,maximum,number,of,iterations,to,perform,return,the,updated,graph,after,the,vertex,centric,iteration,has,converged,or,after,maximum,number,of,iterations;public,m,graph,k,vv,ev,run,vertex,centric,iteration,compute,function,k,vv,ev,m,compute,function,message,combiner,k,m,combiner,int,maximum,number,of,iterations,return,this,run,vertex,centric,iteration,compute,function,combiner,maximum,number,of,iterations,null
Graph -> public <M> Graph<K, VV, EV> runVertexCentricIteration( 			ComputeFunction<K, VV, EV, M> computeFunction,  			MessageCombiner<K, M> combiner, int maximumNumberOfIterations);1462205213;Runs a {@link VertexCentricIteration} on the graph._No configuration options are provided.__@param computeFunction the vertex compute function_@param combiner an optional message combiner_@param maximumNumberOfIterations maximum number of iterations to perform__@return the updated Graph after the vertex-centric iteration has converged or_after maximumNumberOfIterations.;public <M> Graph<K, VV, EV> runVertexCentricIteration(_			ComputeFunction<K, VV, EV, M> computeFunction, _			MessageCombiner<K, M> combiner, int maximumNumberOfIterations) {__		return this.runVertexCentricIteration(computeFunction, combiner, maximumNumberOfIterations, null)__	};runs,a,link,vertex,centric,iteration,on,the,graph,no,configuration,options,are,provided,param,compute,function,the,vertex,compute,function,param,combiner,an,optional,message,combiner,param,maximum,number,of,iterations,maximum,number,of,iterations,to,perform,return,the,updated,graph,after,the,vertex,centric,iteration,has,converged,or,after,maximum,number,of,iterations;public,m,graph,k,vv,ev,run,vertex,centric,iteration,compute,function,k,vv,ev,m,compute,function,message,combiner,k,m,combiner,int,maximum,number,of,iterations,return,this,run,vertex,centric,iteration,compute,function,combiner,maximum,number,of,iterations,null
Graph -> public <M> Graph<K, VV, EV> runVertexCentricIteration( 			ComputeFunction<K, VV, EV, M> computeFunction,  			MessageCombiner<K, M> combiner, int maximumNumberOfIterations);1462208859;Runs a {@link VertexCentricIteration} on the graph._No configuration options are provided.__@param computeFunction the vertex compute function_@param combiner an optional message combiner_@param maximumNumberOfIterations maximum number of iterations to perform__@return the updated Graph after the vertex-centric iteration has converged or_after maximumNumberOfIterations.;public <M> Graph<K, VV, EV> runVertexCentricIteration(_			ComputeFunction<K, VV, EV, M> computeFunction, _			MessageCombiner<K, M> combiner, int maximumNumberOfIterations) {__		return this.runVertexCentricIteration(computeFunction, combiner, maximumNumberOfIterations, null)__	};runs,a,link,vertex,centric,iteration,on,the,graph,no,configuration,options,are,provided,param,compute,function,the,vertex,compute,function,param,combiner,an,optional,message,combiner,param,maximum,number,of,iterations,maximum,number,of,iterations,to,perform,return,the,updated,graph,after,the,vertex,centric,iteration,has,converged,or,after,maximum,number,of,iterations;public,m,graph,k,vv,ev,run,vertex,centric,iteration,compute,function,k,vv,ev,m,compute,function,message,combiner,k,m,combiner,int,maximum,number,of,iterations,return,this,run,vertex,centric,iteration,compute,function,combiner,maximum,number,of,iterations,null
Graph -> public <M> Graph<K, VV, EV> runVertexCentricIteration( 			ComputeFunction<K, VV, EV, M> computeFunction,  			MessageCombiner<K, M> combiner, int maximumNumberOfIterations);1462809297;Runs a {@link VertexCentricIteration} on the graph._No configuration options are provided.__@param computeFunction the vertex compute function_@param combiner an optional message combiner_@param maximumNumberOfIterations maximum number of iterations to perform__@return the updated Graph after the vertex-centric iteration has converged or_after maximumNumberOfIterations.;public <M> Graph<K, VV, EV> runVertexCentricIteration(_			ComputeFunction<K, VV, EV, M> computeFunction, _			MessageCombiner<K, M> combiner, int maximumNumberOfIterations) {__		return this.runVertexCentricIteration(computeFunction, combiner, maximumNumberOfIterations, null)__	};runs,a,link,vertex,centric,iteration,on,the,graph,no,configuration,options,are,provided,param,compute,function,the,vertex,compute,function,param,combiner,an,optional,message,combiner,param,maximum,number,of,iterations,maximum,number,of,iterations,to,perform,return,the,updated,graph,after,the,vertex,centric,iteration,has,converged,or,after,maximum,number,of,iterations;public,m,graph,k,vv,ev,run,vertex,centric,iteration,compute,function,k,vv,ev,m,compute,function,message,combiner,k,m,combiner,int,maximum,number,of,iterations,return,this,run,vertex,centric,iteration,compute,function,combiner,maximum,number,of,iterations,null
Graph -> public <M> Graph<K, VV, EV> runVertexCentricIteration( 			ComputeFunction<K, VV, EV, M> computeFunction,  			MessageCombiner<K, M> combiner, int maximumNumberOfIterations);1465316775;Runs a {@link VertexCentricIteration} on the graph._No configuration options are provided.__@param computeFunction the vertex compute function_@param combiner an optional message combiner_@param maximumNumberOfIterations maximum number of iterations to perform__@return the updated Graph after the vertex-centric iteration has converged or_after maximumNumberOfIterations.;public <M> Graph<K, VV, EV> runVertexCentricIteration(_			ComputeFunction<K, VV, EV, M> computeFunction, _			MessageCombiner<K, M> combiner, int maximumNumberOfIterations) {__		return this.runVertexCentricIteration(computeFunction, combiner, maximumNumberOfIterations, null)__	};runs,a,link,vertex,centric,iteration,on,the,graph,no,configuration,options,are,provided,param,compute,function,the,vertex,compute,function,param,combiner,an,optional,message,combiner,param,maximum,number,of,iterations,maximum,number,of,iterations,to,perform,return,the,updated,graph,after,the,vertex,centric,iteration,has,converged,or,after,maximum,number,of,iterations;public,m,graph,k,vv,ev,run,vertex,centric,iteration,compute,function,k,vv,ev,m,compute,function,message,combiner,k,m,combiner,int,maximum,number,of,iterations,return,this,run,vertex,centric,iteration,compute,function,combiner,maximum,number,of,iterations,null
Graph -> public <M> Graph<K, VV, EV> runVertexCentricIteration( 			ComputeFunction<K, VV, EV, M> computeFunction,  			MessageCombiner<K, M> combiner, int maximumNumberOfIterations);1466789678;Runs a {@link VertexCentricIteration} on the graph._No configuration options are provided.__@param computeFunction the vertex compute function_@param combiner an optional message combiner_@param maximumNumberOfIterations maximum number of iterations to perform__@return the updated Graph after the vertex-centric iteration has converged or_after maximumNumberOfIterations.;public <M> Graph<K, VV, EV> runVertexCentricIteration(_			ComputeFunction<K, VV, EV, M> computeFunction, _			MessageCombiner<K, M> combiner, int maximumNumberOfIterations) {__		return this.runVertexCentricIteration(computeFunction, combiner, maximumNumberOfIterations, null)__	};runs,a,link,vertex,centric,iteration,on,the,graph,no,configuration,options,are,provided,param,compute,function,the,vertex,compute,function,param,combiner,an,optional,message,combiner,param,maximum,number,of,iterations,maximum,number,of,iterations,to,perform,return,the,updated,graph,after,the,vertex,centric,iteration,has,converged,or,after,maximum,number,of,iterations;public,m,graph,k,vv,ev,run,vertex,centric,iteration,compute,function,k,vv,ev,m,compute,function,message,combiner,k,m,combiner,int,maximum,number,of,iterations,return,this,run,vertex,centric,iteration,compute,function,combiner,maximum,number,of,iterations,null
Graph -> public <M> Graph<K, VV, EV> runVertexCentricIteration( 			ComputeFunction<K, VV, EV, M> computeFunction,  			MessageCombiner<K, M> combiner, int maximumNumberOfIterations);1467140656;Runs a {@link VertexCentricIteration} on the graph._No configuration options are provided.__@param computeFunction the vertex compute function_@param combiner an optional message combiner_@param maximumNumberOfIterations maximum number of iterations to perform__@return the updated Graph after the vertex-centric iteration has converged or_after maximumNumberOfIterations.;public <M> Graph<K, VV, EV> runVertexCentricIteration(_			ComputeFunction<K, VV, EV, M> computeFunction, _			MessageCombiner<K, M> combiner, int maximumNumberOfIterations) {__		return this.runVertexCentricIteration(computeFunction, combiner, maximumNumberOfIterations, null)__	};runs,a,link,vertex,centric,iteration,on,the,graph,no,configuration,options,are,provided,param,compute,function,the,vertex,compute,function,param,combiner,an,optional,message,combiner,param,maximum,number,of,iterations,maximum,number,of,iterations,to,perform,return,the,updated,graph,after,the,vertex,centric,iteration,has,converged,or,after,maximum,number,of,iterations;public,m,graph,k,vv,ev,run,vertex,centric,iteration,compute,function,k,vv,ev,m,compute,function,message,combiner,k,m,combiner,int,maximum,number,of,iterations,return,this,run,vertex,centric,iteration,compute,function,combiner,maximum,number,of,iterations,null
Graph -> public <M> Graph<K, VV, EV> runVertexCentricIteration( 			ComputeFunction<K, VV, EV, M> computeFunction,  			MessageCombiner<K, M> combiner, int maximumNumberOfIterations);1467306272;Runs a {@link VertexCentricIteration} on the graph._No configuration options are provided.__@param computeFunction the vertex compute function_@param combiner an optional message combiner_@param maximumNumberOfIterations maximum number of iterations to perform__@return the updated Graph after the vertex-centric iteration has converged or_after maximumNumberOfIterations.;public <M> Graph<K, VV, EV> runVertexCentricIteration(_			ComputeFunction<K, VV, EV, M> computeFunction, _			MessageCombiner<K, M> combiner, int maximumNumberOfIterations) {__		return this.runVertexCentricIteration(computeFunction, combiner, maximumNumberOfIterations, null)__	};runs,a,link,vertex,centric,iteration,on,the,graph,no,configuration,options,are,provided,param,compute,function,the,vertex,compute,function,param,combiner,an,optional,message,combiner,param,maximum,number,of,iterations,maximum,number,of,iterations,to,perform,return,the,updated,graph,after,the,vertex,centric,iteration,has,converged,or,after,maximum,number,of,iterations;public,m,graph,k,vv,ev,run,vertex,centric,iteration,compute,function,k,vv,ev,m,compute,function,message,combiner,k,m,combiner,int,maximum,number,of,iterations,return,this,run,vertex,centric,iteration,compute,function,combiner,maximum,number,of,iterations,null
Graph -> public <M> Graph<K, VV, EV> runVertexCentricIteration( 			ComputeFunction<K, VV, EV, M> computeFunction,  			MessageCombiner<K, M> combiner, int maximumNumberOfIterations);1470042815;Runs a {@link VertexCentricIteration} on the graph._No configuration options are provided.__@param computeFunction the vertex compute function_@param combiner an optional message combiner_@param maximumNumberOfIterations maximum number of iterations to perform__@return the updated Graph after the vertex-centric iteration has converged or_after maximumNumberOfIterations.;public <M> Graph<K, VV, EV> runVertexCentricIteration(_			ComputeFunction<K, VV, EV, M> computeFunction, _			MessageCombiner<K, M> combiner, int maximumNumberOfIterations) {__		return this.runVertexCentricIteration(computeFunction, combiner, maximumNumberOfIterations, null)__	};runs,a,link,vertex,centric,iteration,on,the,graph,no,configuration,options,are,provided,param,compute,function,the,vertex,compute,function,param,combiner,an,optional,message,combiner,param,maximum,number,of,iterations,maximum,number,of,iterations,to,perform,return,the,updated,graph,after,the,vertex,centric,iteration,has,converged,or,after,maximum,number,of,iterations;public,m,graph,k,vv,ev,run,vertex,centric,iteration,compute,function,k,vv,ev,m,compute,function,message,combiner,k,m,combiner,int,maximum,number,of,iterations,return,this,run,vertex,centric,iteration,compute,function,combiner,maximum,number,of,iterations,null
Graph -> public <M> Graph<K, VV, EV> runVertexCentricIteration( 			ComputeFunction<K, VV, EV, M> computeFunction,  			MessageCombiner<K, M> combiner, int maximumNumberOfIterations);1475684776;Runs a {@link VertexCentricIteration} on the graph._No configuration options are provided.__@param computeFunction the vertex compute function_@param combiner an optional message combiner_@param maximumNumberOfIterations maximum number of iterations to perform__@return the updated Graph after the vertex-centric iteration has converged or_after maximumNumberOfIterations.;public <M> Graph<K, VV, EV> runVertexCentricIteration(_			ComputeFunction<K, VV, EV, M> computeFunction, _			MessageCombiner<K, M> combiner, int maximumNumberOfIterations) {__		return this.runVertexCentricIteration(computeFunction, combiner, maximumNumberOfIterations, null)__	};runs,a,link,vertex,centric,iteration,on,the,graph,no,configuration,options,are,provided,param,compute,function,the,vertex,compute,function,param,combiner,an,optional,message,combiner,param,maximum,number,of,iterations,maximum,number,of,iterations,to,perform,return,the,updated,graph,after,the,vertex,centric,iteration,has,converged,or,after,maximum,number,of,iterations;public,m,graph,k,vv,ev,run,vertex,centric,iteration,compute,function,k,vv,ev,m,compute,function,message,combiner,k,m,combiner,int,maximum,number,of,iterations,return,this,run,vertex,centric,iteration,compute,function,combiner,maximum,number,of,iterations,null
Graph -> public <M> Graph<K, VV, EV> runVertexCentricIteration( 			ComputeFunction<K, VV, EV, M> computeFunction,  			MessageCombiner<K, M> combiner, int maximumNumberOfIterations);1475685606;Runs a {@link VertexCentricIteration} on the graph._No configuration options are provided.__@param computeFunction the vertex compute function_@param combiner an optional message combiner_@param maximumNumberOfIterations maximum number of iterations to perform__@return the updated Graph after the vertex-centric iteration has converged or_after maximumNumberOfIterations.;public <M> Graph<K, VV, EV> runVertexCentricIteration(_			ComputeFunction<K, VV, EV, M> computeFunction, _			MessageCombiner<K, M> combiner, int maximumNumberOfIterations) {__		return this.runVertexCentricIteration(computeFunction, combiner, maximumNumberOfIterations, null)__	};runs,a,link,vertex,centric,iteration,on,the,graph,no,configuration,options,are,provided,param,compute,function,the,vertex,compute,function,param,combiner,an,optional,message,combiner,param,maximum,number,of,iterations,maximum,number,of,iterations,to,perform,return,the,updated,graph,after,the,vertex,centric,iteration,has,converged,or,after,maximum,number,of,iterations;public,m,graph,k,vv,ev,run,vertex,centric,iteration,compute,function,k,vv,ev,m,compute,function,message,combiner,k,m,combiner,int,maximum,number,of,iterations,return,this,run,vertex,centric,iteration,compute,function,combiner,maximum,number,of,iterations,null
Graph -> public <M> Graph<K, VV, EV> runVertexCentricIteration( 			ComputeFunction<K, VV, EV, M> computeFunction,  			MessageCombiner<K, M> combiner, int maximumNumberOfIterations);1481745825;Runs a {@link VertexCentricIteration} on the graph._No configuration options are provided.__@param computeFunction the vertex compute function_@param combiner an optional message combiner_@param maximumNumberOfIterations maximum number of iterations to perform__@return the updated Graph after the vertex-centric iteration has converged or_after maximumNumberOfIterations.;public <M> Graph<K, VV, EV> runVertexCentricIteration(_			ComputeFunction<K, VV, EV, M> computeFunction, _			MessageCombiner<K, M> combiner, int maximumNumberOfIterations) {__		return this.runVertexCentricIteration(computeFunction, combiner, maximumNumberOfIterations, null)__	};runs,a,link,vertex,centric,iteration,on,the,graph,no,configuration,options,are,provided,param,compute,function,the,vertex,compute,function,param,combiner,an,optional,message,combiner,param,maximum,number,of,iterations,maximum,number,of,iterations,to,perform,return,the,updated,graph,after,the,vertex,centric,iteration,has,converged,or,after,maximum,number,of,iterations;public,m,graph,k,vv,ev,run,vertex,centric,iteration,compute,function,k,vv,ev,m,compute,function,message,combiner,k,m,combiner,int,maximum,number,of,iterations,return,this,run,vertex,centric,iteration,compute,function,combiner,maximum,number,of,iterations,null
Graph -> public <M> Graph<K, VV, EV> runVertexCentricIteration( 			ComputeFunction<K, VV, EV, M> computeFunction,  			MessageCombiner<K, M> combiner, int maximumNumberOfIterations);1481881009;Runs a {@link VertexCentricIteration} on the graph._No configuration options are provided.__@param computeFunction the vertex compute function_@param combiner an optional message combiner_@param maximumNumberOfIterations maximum number of iterations to perform__@return the updated Graph after the vertex-centric iteration has converged or_after maximumNumberOfIterations.;public <M> Graph<K, VV, EV> runVertexCentricIteration(_			ComputeFunction<K, VV, EV, M> computeFunction, _			MessageCombiner<K, M> combiner, int maximumNumberOfIterations) {__		return this.runVertexCentricIteration(computeFunction, combiner, maximumNumberOfIterations, null)__	};runs,a,link,vertex,centric,iteration,on,the,graph,no,configuration,options,are,provided,param,compute,function,the,vertex,compute,function,param,combiner,an,optional,message,combiner,param,maximum,number,of,iterations,maximum,number,of,iterations,to,perform,return,the,updated,graph,after,the,vertex,centric,iteration,has,converged,or,after,maximum,number,of,iterations;public,m,graph,k,vv,ev,run,vertex,centric,iteration,compute,function,k,vv,ev,m,compute,function,message,combiner,k,m,combiner,int,maximum,number,of,iterations,return,this,run,vertex,centric,iteration,compute,function,combiner,maximum,number,of,iterations,null
Graph -> public <M> Graph<K, VV, EV> runVertexCentricIteration( 			ComputeFunction<K, VV, EV, M> computeFunction,  			MessageCombiner<K, M> combiner, int maximumNumberOfIterations);1484160227;Runs a {@link VertexCentricIteration} on the graph._No configuration options are provided.__@param computeFunction the vertex compute function_@param combiner an optional message combiner_@param maximumNumberOfIterations maximum number of iterations to perform__@return the updated Graph after the vertex-centric iteration has converged or_after maximumNumberOfIterations.;public <M> Graph<K, VV, EV> runVertexCentricIteration(_			ComputeFunction<K, VV, EV, M> computeFunction, _			MessageCombiner<K, M> combiner, int maximumNumberOfIterations) {__		return this.runVertexCentricIteration(computeFunction, combiner, maximumNumberOfIterations, null)__	};runs,a,link,vertex,centric,iteration,on,the,graph,no,configuration,options,are,provided,param,compute,function,the,vertex,compute,function,param,combiner,an,optional,message,combiner,param,maximum,number,of,iterations,maximum,number,of,iterations,to,perform,return,the,updated,graph,after,the,vertex,centric,iteration,has,converged,or,after,maximum,number,of,iterations;public,m,graph,k,vv,ev,run,vertex,centric,iteration,compute,function,k,vv,ev,m,compute,function,message,combiner,k,m,combiner,int,maximum,number,of,iterations,return,this,run,vertex,centric,iteration,compute,function,combiner,maximum,number,of,iterations,null
Graph -> public <M> Graph<K, VV, EV> runVertexCentricIteration( 			ComputeFunction<K, VV, EV, M> computeFunction,  			MessageCombiner<K, M> combiner, int maximumNumberOfIterations);1484685504;Runs a {@link VertexCentricIteration} on the graph._No configuration options are provided.__@param computeFunction the vertex compute function_@param combiner an optional message combiner_@param maximumNumberOfIterations maximum number of iterations to perform__@return the updated Graph after the vertex-centric iteration has converged or_after maximumNumberOfIterations.;public <M> Graph<K, VV, EV> runVertexCentricIteration(_			ComputeFunction<K, VV, EV, M> computeFunction, _			MessageCombiner<K, M> combiner, int maximumNumberOfIterations) {__		return this.runVertexCentricIteration(computeFunction, combiner, maximumNumberOfIterations, null)__	};runs,a,link,vertex,centric,iteration,on,the,graph,no,configuration,options,are,provided,param,compute,function,the,vertex,compute,function,param,combiner,an,optional,message,combiner,param,maximum,number,of,iterations,maximum,number,of,iterations,to,perform,return,the,updated,graph,after,the,vertex,centric,iteration,has,converged,or,after,maximum,number,of,iterations;public,m,graph,k,vv,ev,run,vertex,centric,iteration,compute,function,k,vv,ev,m,compute,function,message,combiner,k,m,combiner,int,maximum,number,of,iterations,return,this,run,vertex,centric,iteration,compute,function,combiner,maximum,number,of,iterations,null
Graph -> public <M> Graph<K, VV, EV> runVertexCentricIteration( 			ComputeFunction<K, VV, EV, M> computeFunction,  			MessageCombiner<K, M> combiner, int maximumNumberOfIterations);1489068942;Runs a {@link VertexCentricIteration} on the graph._No configuration options are provided.__@param computeFunction the vertex compute function_@param combiner an optional message combiner_@param maximumNumberOfIterations maximum number of iterations to perform__@return the updated Graph after the vertex-centric iteration has converged or_after maximumNumberOfIterations.;public <M> Graph<K, VV, EV> runVertexCentricIteration(_			ComputeFunction<K, VV, EV, M> computeFunction, _			MessageCombiner<K, M> combiner, int maximumNumberOfIterations) {__		return this.runVertexCentricIteration(computeFunction, combiner, maximumNumberOfIterations, null)__	};runs,a,link,vertex,centric,iteration,on,the,graph,no,configuration,options,are,provided,param,compute,function,the,vertex,compute,function,param,combiner,an,optional,message,combiner,param,maximum,number,of,iterations,maximum,number,of,iterations,to,perform,return,the,updated,graph,after,the,vertex,centric,iteration,has,converged,or,after,maximum,number,of,iterations;public,m,graph,k,vv,ev,run,vertex,centric,iteration,compute,function,k,vv,ev,m,compute,function,message,combiner,k,m,combiner,int,maximum,number,of,iterations,return,this,run,vertex,centric,iteration,compute,function,combiner,maximum,number,of,iterations,null
Graph -> public <M> Graph<K, VV, EV> runVertexCentricIteration( 			ComputeFunction<K, VV, EV, M> computeFunction,  			MessageCombiner<K, M> combiner, int maximumNumberOfIterations);1490973446;Runs a {@link VertexCentricIteration} on the graph._No configuration options are provided.__@param computeFunction the vertex compute function_@param combiner an optional message combiner_@param maximumNumberOfIterations maximum number of iterations to perform__@return the updated Graph after the vertex-centric iteration has converged or_after maximumNumberOfIterations.;public <M> Graph<K, VV, EV> runVertexCentricIteration(_			ComputeFunction<K, VV, EV, M> computeFunction, _			MessageCombiner<K, M> combiner, int maximumNumberOfIterations) {__		return this.runVertexCentricIteration(computeFunction, combiner, maximumNumberOfIterations, null)__	};runs,a,link,vertex,centric,iteration,on,the,graph,no,configuration,options,are,provided,param,compute,function,the,vertex,compute,function,param,combiner,an,optional,message,combiner,param,maximum,number,of,iterations,maximum,number,of,iterations,to,perform,return,the,updated,graph,after,the,vertex,centric,iteration,has,converged,or,after,maximum,number,of,iterations;public,m,graph,k,vv,ev,run,vertex,centric,iteration,compute,function,k,vv,ev,m,compute,function,message,combiner,k,m,combiner,int,maximum,number,of,iterations,return,this,run,vertex,centric,iteration,compute,function,combiner,maximum,number,of,iterations,null
Graph -> public Graph<K, VV, EV> difference(Graph<K, VV, EV> graph);1484685504;Performs Difference on the vertex and edge sets of the input graphs_removes common vertices and edges. If a source/target vertex is removed,_its corresponding edge will also be removed__@param graph the graph to perform difference with_@return a new graph where the common vertices and edges have been removed;public Graph<K, VV, EV> difference(Graph<K, VV, EV> graph) {_		DataSet<Vertex<K, VV>> removeVerticesData = graph.getVertices()__		return this.removeVertices(removeVerticesData)__	};performs,difference,on,the,vertex,and,edge,sets,of,the,input,graphs,removes,common,vertices,and,edges,if,a,source,target,vertex,is,removed,its,corresponding,edge,will,also,be,removed,param,graph,the,graph,to,perform,difference,with,return,a,new,graph,where,the,common,vertices,and,edges,have,been,removed;public,graph,k,vv,ev,difference,graph,k,vv,ev,graph,data,set,vertex,k,vv,remove,vertices,data,graph,get,vertices,return,this,remove,vertices,remove,vertices,data
Graph -> public Graph<K, VV, EV> difference(Graph<K, VV, EV> graph);1489068942;Performs Difference on the vertex and edge sets of the input graphs_removes common vertices and edges. If a source/target vertex is removed,_its corresponding edge will also be removed__@param graph the graph to perform difference with_@return a new graph where the common vertices and edges have been removed;public Graph<K, VV, EV> difference(Graph<K, VV, EV> graph) {_		DataSet<Vertex<K, VV>> removeVerticesData = graph.getVertices()__		return this.removeVertices(removeVerticesData)__	};performs,difference,on,the,vertex,and,edge,sets,of,the,input,graphs,removes,common,vertices,and,edges,if,a,source,target,vertex,is,removed,its,corresponding,edge,will,also,be,removed,param,graph,the,graph,to,perform,difference,with,return,a,new,graph,where,the,common,vertices,and,edges,have,been,removed;public,graph,k,vv,ev,difference,graph,k,vv,ev,graph,data,set,vertex,k,vv,remove,vertices,data,graph,get,vertices,return,this,remove,vertices,remove,vertices,data
Graph -> public Graph<K, VV, EV> difference(Graph<K, VV, EV> graph);1490973446;Performs Difference on the vertex and edge sets of the input graphs_removes common vertices and edges. If a source/target vertex is removed,_its corresponding edge will also be removed__@param graph the graph to perform difference with_@return a new graph where the common vertices and edges have been removed;public Graph<K, VV, EV> difference(Graph<K, VV, EV> graph) {_		DataSet<Vertex<K, VV>> removeVerticesData = graph.getVertices()__		return this.removeVertices(removeVerticesData)__	};performs,difference,on,the,vertex,and,edge,sets,of,the,input,graphs,removes,common,vertices,and,edges,if,a,source,target,vertex,is,removed,its,corresponding,edge,will,also,be,removed,param,graph,the,graph,to,perform,difference,with,return,a,new,graph,where,the,common,vertices,and,edges,have,been,removed;public,graph,k,vv,ev,difference,graph,k,vv,ev,graph,data,set,vertex,k,vv,remove,vertices,data,graph,get,vertices,return,this,remove,vertices,remove,vertices,data
Graph -> public Graph<K, VV, EV> difference(Graph<K, VV, EV> graph);1495819075;Performs Difference on the vertex and edge sets of the input graphs_removes common vertices and edges. If a source/target vertex is removed,_its corresponding edge will also be removed__@param graph the graph to perform difference with_@return a new graph where the common vertices and edges have been removed;public Graph<K, VV, EV> difference(Graph<K, VV, EV> graph) {_		DataSet<Vertex<K, VV>> removeVerticesData = graph.getVertices()__		return this.removeVertices(removeVerticesData)__	};performs,difference,on,the,vertex,and,edge,sets,of,the,input,graphs,removes,common,vertices,and,edges,if,a,source,target,vertex,is,removed,its,corresponding,edge,will,also,be,removed,param,graph,the,graph,to,perform,difference,with,return,a,new,graph,where,the,common,vertices,and,edges,have,been,removed;public,graph,k,vv,ev,difference,graph,k,vv,ev,graph,data,set,vertex,k,vv,remove,vertices,data,graph,get,vertices,return,this,remove,vertices,remove,vertices,data
Graph -> public Graph<K, VV, EV> difference(Graph<K, VV, EV> graph);1502111816;Performs Difference on the vertex and edge sets of the input graphs_removes common vertices and edges. If a source/target vertex is removed,_its corresponding edge will also be removed__@param graph the graph to perform difference with_@return a new graph where the common vertices and edges have been removed;public Graph<K, VV, EV> difference(Graph<K, VV, EV> graph) {_		DataSet<Vertex<K, VV>> removeVerticesData = graph.getVertices()__		return this.removeVertices(removeVerticesData)__	};performs,difference,on,the,vertex,and,edge,sets,of,the,input,graphs,removes,common,vertices,and,edges,if,a,source,target,vertex,is,removed,its,corresponding,edge,will,also,be,removed,param,graph,the,graph,to,perform,difference,with,return,a,new,graph,where,the,common,vertices,and,edges,have,been,removed;public,graph,k,vv,ev,difference,graph,k,vv,ev,graph,data,set,vertex,k,vv,remove,vertices,data,graph,get,vertices,return,this,remove,vertices,remove,vertices,data
Graph -> public <T> DataSet<T> groupReduceOnEdges(EdgesFunction<K, EV, T> edgesFunction, 			EdgeDirection direction, TypeInformation<T> typeInfo) throws IllegalArgumentException;1445261977;Groups by vertex and computes a GroupReduce transformation over the edge values of each vertex._The edgesFunction applied on the edges only has access to the vertex id (not the vertex value)_of the grouping vertex.__For each vertex, the edgesFunction can iterate over all edges of this vertex_with the specified direction, and emit any number of output elements, including none.__@param edgesFunction the group reduce function to apply to the neighboring edges of each vertex._@param direction the edge direction (in-, out-, all-)._@param <T> the output type_@param typeInfo the explicit return type._@return a DataSet containing elements of type T_@throws IllegalArgumentException;public <T> DataSet<T> groupReduceOnEdges(EdgesFunction<K, EV, T> edgesFunction,_			EdgeDirection direction, TypeInformation<T> typeInfo) throws IllegalArgumentException {__		switch (direction) {_			case IN:_				return edges.map(new ProjectVertexIdMap<K, EV>(1))_						.withForwardedFields("f1->f0")_						.groupBy(0).reduceGroup(new ApplyGroupReduceFunction<K, EV, T>(edgesFunction)).returns(typeInfo)__			case OUT:_				return edges.map(new ProjectVertexIdMap<K, EV>(0))_						.withForwardedFields("f0")_						.groupBy(0).reduceGroup(new ApplyGroupReduceFunction<K, EV, T>(edgesFunction)).returns(typeInfo)__			case ALL:_				return edges.flatMap(new EmitOneEdgePerNode<K, VV, EV>())_						.groupBy(0).reduceGroup(new ApplyGroupReduceFunction<K, EV, T>(edgesFunction)).returns(typeInfo)__			default:_				throw new IllegalArgumentException("Illegal edge direction")__		}_	};groups,by,vertex,and,computes,a,group,reduce,transformation,over,the,edge,values,of,each,vertex,the,edges,function,applied,on,the,edges,only,has,access,to,the,vertex,id,not,the,vertex,value,of,the,grouping,vertex,for,each,vertex,the,edges,function,can,iterate,over,all,edges,of,this,vertex,with,the,specified,direction,and,emit,any,number,of,output,elements,including,none,param,edges,function,the,group,reduce,function,to,apply,to,the,neighboring,edges,of,each,vertex,param,direction,the,edge,direction,in,out,all,param,t,the,output,type,param,type,info,the,explicit,return,type,return,a,data,set,containing,elements,of,type,t,throws,illegal,argument,exception;public,t,data,set,t,group,reduce,on,edges,edges,function,k,ev,t,edges,function,edge,direction,direction,type,information,t,type,info,throws,illegal,argument,exception,switch,direction,case,in,return,edges,map,new,project,vertex,id,map,k,ev,1,with,forwarded,fields,f1,f0,group,by,0,reduce,group,new,apply,group,reduce,function,k,ev,t,edges,function,returns,type,info,case,out,return,edges,map,new,project,vertex,id,map,k,ev,0,with,forwarded,fields,f0,group,by,0,reduce,group,new,apply,group,reduce,function,k,ev,t,edges,function,returns,type,info,case,all,return,edges,flat,map,new,emit,one,edge,per,node,k,vv,ev,group,by,0,reduce,group,new,apply,group,reduce,function,k,ev,t,edges,function,returns,type,info,default,throw,new,illegal,argument,exception,illegal,edge,direction
Graph -> public <T> DataSet<T> groupReduceOnEdges(EdgesFunction<K, EV, T> edgesFunction, 			EdgeDirection direction, TypeInformation<T> typeInfo) throws IllegalArgumentException;1445854323;Groups by vertex and computes a GroupReduce transformation over the edge values of each vertex._The edgesFunction applied on the edges only has access to the vertex id (not the vertex value)_of the grouping vertex.__For each vertex, the edgesFunction can iterate over all edges of this vertex_with the specified direction, and emit any number of output elements, including none.__@param edgesFunction the group reduce function to apply to the neighboring edges of each vertex._@param direction the edge direction (in-, out-, all-)._@param <T> the output type_@param typeInfo the explicit return type._@return a DataSet containing elements of type T_@throws IllegalArgumentException;public <T> DataSet<T> groupReduceOnEdges(EdgesFunction<K, EV, T> edgesFunction,_			EdgeDirection direction, TypeInformation<T> typeInfo) throws IllegalArgumentException {__		switch (direction) {_			case IN:_				return edges.map(new ProjectVertexIdMap<K, EV>(1))_						.withForwardedFields("f1->f0")_						.groupBy(0).reduceGroup(new ApplyGroupReduceFunction<K, EV, T>(edgesFunction)).returns(typeInfo)__			case OUT:_				return edges.map(new ProjectVertexIdMap<K, EV>(0))_						.withForwardedFields("f0")_						.groupBy(0).reduceGroup(new ApplyGroupReduceFunction<K, EV, T>(edgesFunction)).returns(typeInfo)__			case ALL:_				return edges.flatMap(new EmitOneEdgePerNode<K, VV, EV>())_						.groupBy(0).reduceGroup(new ApplyGroupReduceFunction<K, EV, T>(edgesFunction)).returns(typeInfo)__			default:_				throw new IllegalArgumentException("Illegal edge direction")__		}_	};groups,by,vertex,and,computes,a,group,reduce,transformation,over,the,edge,values,of,each,vertex,the,edges,function,applied,on,the,edges,only,has,access,to,the,vertex,id,not,the,vertex,value,of,the,grouping,vertex,for,each,vertex,the,edges,function,can,iterate,over,all,edges,of,this,vertex,with,the,specified,direction,and,emit,any,number,of,output,elements,including,none,param,edges,function,the,group,reduce,function,to,apply,to,the,neighboring,edges,of,each,vertex,param,direction,the,edge,direction,in,out,all,param,t,the,output,type,param,type,info,the,explicit,return,type,return,a,data,set,containing,elements,of,type,t,throws,illegal,argument,exception;public,t,data,set,t,group,reduce,on,edges,edges,function,k,ev,t,edges,function,edge,direction,direction,type,information,t,type,info,throws,illegal,argument,exception,switch,direction,case,in,return,edges,map,new,project,vertex,id,map,k,ev,1,with,forwarded,fields,f1,f0,group,by,0,reduce,group,new,apply,group,reduce,function,k,ev,t,edges,function,returns,type,info,case,out,return,edges,map,new,project,vertex,id,map,k,ev,0,with,forwarded,fields,f0,group,by,0,reduce,group,new,apply,group,reduce,function,k,ev,t,edges,function,returns,type,info,case,all,return,edges,flat,map,new,emit,one,edge,per,node,k,vv,ev,group,by,0,reduce,group,new,apply,group,reduce,function,k,ev,t,edges,function,returns,type,info,default,throw,new,illegal,argument,exception,illegal,edge,direction
Graph -> public <T> DataSet<T> groupReduceOnEdges(EdgesFunction<K, EV, T> edgesFunction, 			EdgeDirection direction, TypeInformation<T> typeInfo) throws IllegalArgumentException;1446112342;Groups by vertex and computes a GroupReduce transformation over the edge values of each vertex._The edgesFunction applied on the edges only has access to the vertex id (not the vertex value)_of the grouping vertex.__For each vertex, the edgesFunction can iterate over all edges of this vertex_with the specified direction, and emit any number of output elements, including none.__@param edgesFunction the group reduce function to apply to the neighboring edges of each vertex._@param direction the edge direction (in-, out-, all-)._@param <T> the output type_@param typeInfo the explicit return type._@return a DataSet containing elements of type T_@throws IllegalArgumentException;public <T> DataSet<T> groupReduceOnEdges(EdgesFunction<K, EV, T> edgesFunction,_			EdgeDirection direction, TypeInformation<T> typeInfo) throws IllegalArgumentException {__		switch (direction) {_			case IN:_				return edges.map(new ProjectVertexIdMap<K, EV>(1))_						.withForwardedFields("f1->f0")_						.groupBy(0).reduceGroup(new ApplyGroupReduceFunction<K, EV, T>(edgesFunction)).returns(typeInfo)__			case OUT:_				return edges.map(new ProjectVertexIdMap<K, EV>(0))_						.withForwardedFields("f0")_						.groupBy(0).reduceGroup(new ApplyGroupReduceFunction<K, EV, T>(edgesFunction)).returns(typeInfo)__			case ALL:_				return edges.flatMap(new EmitOneEdgePerNode<K, VV, EV>())_						.groupBy(0).reduceGroup(new ApplyGroupReduceFunction<K, EV, T>(edgesFunction)).returns(typeInfo)__			default:_				throw new IllegalArgumentException("Illegal edge direction")__		}_	};groups,by,vertex,and,computes,a,group,reduce,transformation,over,the,edge,values,of,each,vertex,the,edges,function,applied,on,the,edges,only,has,access,to,the,vertex,id,not,the,vertex,value,of,the,grouping,vertex,for,each,vertex,the,edges,function,can,iterate,over,all,edges,of,this,vertex,with,the,specified,direction,and,emit,any,number,of,output,elements,including,none,param,edges,function,the,group,reduce,function,to,apply,to,the,neighboring,edges,of,each,vertex,param,direction,the,edge,direction,in,out,all,param,t,the,output,type,param,type,info,the,explicit,return,type,return,a,data,set,containing,elements,of,type,t,throws,illegal,argument,exception;public,t,data,set,t,group,reduce,on,edges,edges,function,k,ev,t,edges,function,edge,direction,direction,type,information,t,type,info,throws,illegal,argument,exception,switch,direction,case,in,return,edges,map,new,project,vertex,id,map,k,ev,1,with,forwarded,fields,f1,f0,group,by,0,reduce,group,new,apply,group,reduce,function,k,ev,t,edges,function,returns,type,info,case,out,return,edges,map,new,project,vertex,id,map,k,ev,0,with,forwarded,fields,f0,group,by,0,reduce,group,new,apply,group,reduce,function,k,ev,t,edges,function,returns,type,info,case,all,return,edges,flat,map,new,emit,one,edge,per,node,k,vv,ev,group,by,0,reduce,group,new,apply,group,reduce,function,k,ev,t,edges,function,returns,type,info,default,throw,new,illegal,argument,exception,illegal,edge,direction
Graph -> public <T> DataSet<T> groupReduceOnEdges(EdgesFunction<K, EV, T> edgesFunction, 			EdgeDirection direction, TypeInformation<T> typeInfo) throws IllegalArgumentException;1447073368;Groups by vertex and computes a GroupReduce transformation over the edge values of each vertex._The edgesFunction applied on the edges only has access to the vertex id (not the vertex value)_of the grouping vertex.__For each vertex, the edgesFunction can iterate over all edges of this vertex_with the specified direction, and emit any number of output elements, including none.__@param edgesFunction the group reduce function to apply to the neighboring edges of each vertex._@param direction the edge direction (in-, out-, all-)._@param <T> the output type_@param typeInfo the explicit return type._@return a DataSet containing elements of type T_@throws IllegalArgumentException;public <T> DataSet<T> groupReduceOnEdges(EdgesFunction<K, EV, T> edgesFunction,_			EdgeDirection direction, TypeInformation<T> typeInfo) throws IllegalArgumentException {__		switch (direction) {_			case IN:_				return edges.map(new ProjectVertexIdMap<K, EV>(1))_						.withForwardedFields("f1->f0")_						.groupBy(0).reduceGroup(new ApplyGroupReduceFunction<K, EV, T>(edgesFunction)).returns(typeInfo)__			case OUT:_				return edges.map(new ProjectVertexIdMap<K, EV>(0))_						.withForwardedFields("f0")_						.groupBy(0).reduceGroup(new ApplyGroupReduceFunction<K, EV, T>(edgesFunction)).returns(typeInfo)__			case ALL:_				return edges.flatMap(new EmitOneEdgePerNode<K, VV, EV>())_						.groupBy(0).reduceGroup(new ApplyGroupReduceFunction<K, EV, T>(edgesFunction)).returns(typeInfo)__			default:_				throw new IllegalArgumentException("Illegal edge direction")__		}_	};groups,by,vertex,and,computes,a,group,reduce,transformation,over,the,edge,values,of,each,vertex,the,edges,function,applied,on,the,edges,only,has,access,to,the,vertex,id,not,the,vertex,value,of,the,grouping,vertex,for,each,vertex,the,edges,function,can,iterate,over,all,edges,of,this,vertex,with,the,specified,direction,and,emit,any,number,of,output,elements,including,none,param,edges,function,the,group,reduce,function,to,apply,to,the,neighboring,edges,of,each,vertex,param,direction,the,edge,direction,in,out,all,param,t,the,output,type,param,type,info,the,explicit,return,type,return,a,data,set,containing,elements,of,type,t,throws,illegal,argument,exception;public,t,data,set,t,group,reduce,on,edges,edges,function,k,ev,t,edges,function,edge,direction,direction,type,information,t,type,info,throws,illegal,argument,exception,switch,direction,case,in,return,edges,map,new,project,vertex,id,map,k,ev,1,with,forwarded,fields,f1,f0,group,by,0,reduce,group,new,apply,group,reduce,function,k,ev,t,edges,function,returns,type,info,case,out,return,edges,map,new,project,vertex,id,map,k,ev,0,with,forwarded,fields,f0,group,by,0,reduce,group,new,apply,group,reduce,function,k,ev,t,edges,function,returns,type,info,case,all,return,edges,flat,map,new,emit,one,edge,per,node,k,vv,ev,group,by,0,reduce,group,new,apply,group,reduce,function,k,ev,t,edges,function,returns,type,info,default,throw,new,illegal,argument,exception,illegal,edge,direction
Graph -> public <T> DataSet<T> groupReduceOnEdges(EdgesFunction<K, EV, T> edgesFunction, 			EdgeDirection direction, TypeInformation<T> typeInfo) throws IllegalArgumentException;1454404649;Groups by vertex and computes a GroupReduce transformation over the edge values of each vertex._The edgesFunction applied on the edges only has access to the vertex id (not the vertex value)_of the grouping vertex.__For each vertex, the edgesFunction can iterate over all edges of this vertex_with the specified direction, and emit any number of output elements, including none.__@param edgesFunction the group reduce function to apply to the neighboring edges of each vertex._@param direction the edge direction (in-, out-, all-)._@param <T> the output type_@param typeInfo the explicit return type._@return a DataSet containing elements of type T_@throws IllegalArgumentException;public <T> DataSet<T> groupReduceOnEdges(EdgesFunction<K, EV, T> edgesFunction,_			EdgeDirection direction, TypeInformation<T> typeInfo) throws IllegalArgumentException {__		switch (direction) {_			case IN:_				return edges.map(new ProjectVertexIdMap<K, EV>(1))_						.withForwardedFields("f1->f0")_						.groupBy(0).reduceGroup(new ApplyGroupReduceFunction<K, EV, T>(edgesFunction)).returns(typeInfo)__			case OUT:_				return edges.map(new ProjectVertexIdMap<K, EV>(0))_						.withForwardedFields("f0")_						.groupBy(0).reduceGroup(new ApplyGroupReduceFunction<K, EV, T>(edgesFunction)).returns(typeInfo)__			case ALL:_				return edges.flatMap(new EmitOneEdgePerNode<K, VV, EV>())_						.groupBy(0).reduceGroup(new ApplyGroupReduceFunction<K, EV, T>(edgesFunction)).returns(typeInfo)__			default:_				throw new IllegalArgumentException("Illegal edge direction")__		}_	};groups,by,vertex,and,computes,a,group,reduce,transformation,over,the,edge,values,of,each,vertex,the,edges,function,applied,on,the,edges,only,has,access,to,the,vertex,id,not,the,vertex,value,of,the,grouping,vertex,for,each,vertex,the,edges,function,can,iterate,over,all,edges,of,this,vertex,with,the,specified,direction,and,emit,any,number,of,output,elements,including,none,param,edges,function,the,group,reduce,function,to,apply,to,the,neighboring,edges,of,each,vertex,param,direction,the,edge,direction,in,out,all,param,t,the,output,type,param,type,info,the,explicit,return,type,return,a,data,set,containing,elements,of,type,t,throws,illegal,argument,exception;public,t,data,set,t,group,reduce,on,edges,edges,function,k,ev,t,edges,function,edge,direction,direction,type,information,t,type,info,throws,illegal,argument,exception,switch,direction,case,in,return,edges,map,new,project,vertex,id,map,k,ev,1,with,forwarded,fields,f1,f0,group,by,0,reduce,group,new,apply,group,reduce,function,k,ev,t,edges,function,returns,type,info,case,out,return,edges,map,new,project,vertex,id,map,k,ev,0,with,forwarded,fields,f0,group,by,0,reduce,group,new,apply,group,reduce,function,k,ev,t,edges,function,returns,type,info,case,all,return,edges,flat,map,new,emit,one,edge,per,node,k,vv,ev,group,by,0,reduce,group,new,apply,group,reduce,function,k,ev,t,edges,function,returns,type,info,default,throw,new,illegal,argument,exception,illegal,edge,direction
Graph -> public <T> DataSet<T> groupReduceOnEdges(EdgesFunction<K, EV, T> edgesFunction, 			EdgeDirection direction, TypeInformation<T> typeInfo) throws IllegalArgumentException;1458583829;Groups by vertex and computes a GroupReduce transformation over the edge values of each vertex._The edgesFunction applied on the edges only has access to the vertex id (not the vertex value)_of the grouping vertex.__For each vertex, the edgesFunction can iterate over all edges of this vertex_with the specified direction, and emit any number of output elements, including none.__@param edgesFunction the group reduce function to apply to the neighboring edges of each vertex._@param direction the edge direction (in-, out-, all-)._@param <T> the output type_@param typeInfo the explicit return type._@return a DataSet containing elements of type T_@throws IllegalArgumentException;public <T> DataSet<T> groupReduceOnEdges(EdgesFunction<K, EV, T> edgesFunction,_			EdgeDirection direction, TypeInformation<T> typeInfo) throws IllegalArgumentException {__		switch (direction) {_			case IN:_				return edges.map(new ProjectVertexIdMap<K, EV>(1))_						.withForwardedFields("f1->f0")_						.groupBy(0).reduceGroup(new ApplyGroupReduceFunction<K, EV, T>(edgesFunction)).returns(typeInfo)__			case OUT:_				return edges.map(new ProjectVertexIdMap<K, EV>(0))_						.withForwardedFields("f0")_						.groupBy(0).reduceGroup(new ApplyGroupReduceFunction<K, EV, T>(edgesFunction)).returns(typeInfo)__			case ALL:_				return edges.flatMap(new EmitOneEdgePerNode<K, VV, EV>())_						.groupBy(0).reduceGroup(new ApplyGroupReduceFunction<K, EV, T>(edgesFunction)).returns(typeInfo)__			default:_				throw new IllegalArgumentException("Illegal edge direction")__		}_	};groups,by,vertex,and,computes,a,group,reduce,transformation,over,the,edge,values,of,each,vertex,the,edges,function,applied,on,the,edges,only,has,access,to,the,vertex,id,not,the,vertex,value,of,the,grouping,vertex,for,each,vertex,the,edges,function,can,iterate,over,all,edges,of,this,vertex,with,the,specified,direction,and,emit,any,number,of,output,elements,including,none,param,edges,function,the,group,reduce,function,to,apply,to,the,neighboring,edges,of,each,vertex,param,direction,the,edge,direction,in,out,all,param,t,the,output,type,param,type,info,the,explicit,return,type,return,a,data,set,containing,elements,of,type,t,throws,illegal,argument,exception;public,t,data,set,t,group,reduce,on,edges,edges,function,k,ev,t,edges,function,edge,direction,direction,type,information,t,type,info,throws,illegal,argument,exception,switch,direction,case,in,return,edges,map,new,project,vertex,id,map,k,ev,1,with,forwarded,fields,f1,f0,group,by,0,reduce,group,new,apply,group,reduce,function,k,ev,t,edges,function,returns,type,info,case,out,return,edges,map,new,project,vertex,id,map,k,ev,0,with,forwarded,fields,f0,group,by,0,reduce,group,new,apply,group,reduce,function,k,ev,t,edges,function,returns,type,info,case,all,return,edges,flat,map,new,emit,one,edge,per,node,k,vv,ev,group,by,0,reduce,group,new,apply,group,reduce,function,k,ev,t,edges,function,returns,type,info,default,throw,new,illegal,argument,exception,illegal,edge,direction
Graph -> public <T> DataSet<T> groupReduceOnEdges(EdgesFunction<K, EV, T> edgesFunction, 			EdgeDirection direction, TypeInformation<T> typeInfo) throws IllegalArgumentException;1458583829;Groups by vertex and computes a GroupReduce transformation over the edge values of each vertex._The edgesFunction applied on the edges only has access to the vertex id (not the vertex value)_of the grouping vertex.__For each vertex, the edgesFunction can iterate over all edges of this vertex_with the specified direction, and emit any number of output elements, including none.__@param edgesFunction the group reduce function to apply to the neighboring edges of each vertex._@param direction the edge direction (in-, out-, all-)._@param <T> the output type_@param typeInfo the explicit return type._@return a DataSet containing elements of type T_@throws IllegalArgumentException;public <T> DataSet<T> groupReduceOnEdges(EdgesFunction<K, EV, T> edgesFunction,_			EdgeDirection direction, TypeInformation<T> typeInfo) throws IllegalArgumentException {__		switch (direction) {_			case IN:_				return edges.map(new ProjectVertexIdMap<K, EV>(1))_						.withForwardedFields("f1->f0")_						.groupBy(0).reduceGroup(new ApplyGroupReduceFunction<K, EV, T>(edgesFunction)).returns(typeInfo)__			case OUT:_				return edges.map(new ProjectVertexIdMap<K, EV>(0))_						.withForwardedFields("f0")_						.groupBy(0).reduceGroup(new ApplyGroupReduceFunction<K, EV, T>(edgesFunction)).returns(typeInfo)__			case ALL:_				return edges.flatMap(new EmitOneEdgePerNode<K, VV, EV>())_						.groupBy(0).reduceGroup(new ApplyGroupReduceFunction<K, EV, T>(edgesFunction)).returns(typeInfo)__			default:_				throw new IllegalArgumentException("Illegal edge direction")__		}_	};groups,by,vertex,and,computes,a,group,reduce,transformation,over,the,edge,values,of,each,vertex,the,edges,function,applied,on,the,edges,only,has,access,to,the,vertex,id,not,the,vertex,value,of,the,grouping,vertex,for,each,vertex,the,edges,function,can,iterate,over,all,edges,of,this,vertex,with,the,specified,direction,and,emit,any,number,of,output,elements,including,none,param,edges,function,the,group,reduce,function,to,apply,to,the,neighboring,edges,of,each,vertex,param,direction,the,edge,direction,in,out,all,param,t,the,output,type,param,type,info,the,explicit,return,type,return,a,data,set,containing,elements,of,type,t,throws,illegal,argument,exception;public,t,data,set,t,group,reduce,on,edges,edges,function,k,ev,t,edges,function,edge,direction,direction,type,information,t,type,info,throws,illegal,argument,exception,switch,direction,case,in,return,edges,map,new,project,vertex,id,map,k,ev,1,with,forwarded,fields,f1,f0,group,by,0,reduce,group,new,apply,group,reduce,function,k,ev,t,edges,function,returns,type,info,case,out,return,edges,map,new,project,vertex,id,map,k,ev,0,with,forwarded,fields,f0,group,by,0,reduce,group,new,apply,group,reduce,function,k,ev,t,edges,function,returns,type,info,case,all,return,edges,flat,map,new,emit,one,edge,per,node,k,vv,ev,group,by,0,reduce,group,new,apply,group,reduce,function,k,ev,t,edges,function,returns,type,info,default,throw,new,illegal,argument,exception,illegal,edge,direction
Graph -> public <T> DataSet<T> groupReduceOnEdges(EdgesFunction<K, EV, T> edgesFunction, 			EdgeDirection direction, TypeInformation<T> typeInfo) throws IllegalArgumentException;1462100316;Groups by vertex and computes a GroupReduce transformation over the edge values of each vertex._The edgesFunction applied on the edges only has access to the vertex id (not the vertex value)_of the grouping vertex.__For each vertex, the edgesFunction can iterate over all edges of this vertex_with the specified direction, and emit any number of output elements, including none.__@param edgesFunction the group reduce function to apply to the neighboring edges of each vertex._@param direction the edge direction (in-, out-, all-)._@param <T> the output type_@param typeInfo the explicit return type._@return a DataSet containing elements of type T_@throws IllegalArgumentException;public <T> DataSet<T> groupReduceOnEdges(EdgesFunction<K, EV, T> edgesFunction,_			EdgeDirection direction, TypeInformation<T> typeInfo) throws IllegalArgumentException {__		switch (direction) {_			case IN:_				return edges.map(new ProjectVertexIdMap<K, EV>(1))_						.withForwardedFields("f1->f0")_						.groupBy(0).reduceGroup(new ApplyGroupReduceFunction<K, EV, T>(edgesFunction)).returns(typeInfo)__			case OUT:_				return edges.map(new ProjectVertexIdMap<K, EV>(0))_						.withForwardedFields("f0")_						.groupBy(0).reduceGroup(new ApplyGroupReduceFunction<K, EV, T>(edgesFunction)).returns(typeInfo)__			case ALL:_				return edges.flatMap(new EmitOneEdgePerNode<K, VV, EV>())_						.groupBy(0).reduceGroup(new ApplyGroupReduceFunction<K, EV, T>(edgesFunction)).returns(typeInfo)__			default:_				throw new IllegalArgumentException("Illegal edge direction")__		}_	};groups,by,vertex,and,computes,a,group,reduce,transformation,over,the,edge,values,of,each,vertex,the,edges,function,applied,on,the,edges,only,has,access,to,the,vertex,id,not,the,vertex,value,of,the,grouping,vertex,for,each,vertex,the,edges,function,can,iterate,over,all,edges,of,this,vertex,with,the,specified,direction,and,emit,any,number,of,output,elements,including,none,param,edges,function,the,group,reduce,function,to,apply,to,the,neighboring,edges,of,each,vertex,param,direction,the,edge,direction,in,out,all,param,t,the,output,type,param,type,info,the,explicit,return,type,return,a,data,set,containing,elements,of,type,t,throws,illegal,argument,exception;public,t,data,set,t,group,reduce,on,edges,edges,function,k,ev,t,edges,function,edge,direction,direction,type,information,t,type,info,throws,illegal,argument,exception,switch,direction,case,in,return,edges,map,new,project,vertex,id,map,k,ev,1,with,forwarded,fields,f1,f0,group,by,0,reduce,group,new,apply,group,reduce,function,k,ev,t,edges,function,returns,type,info,case,out,return,edges,map,new,project,vertex,id,map,k,ev,0,with,forwarded,fields,f0,group,by,0,reduce,group,new,apply,group,reduce,function,k,ev,t,edges,function,returns,type,info,case,all,return,edges,flat,map,new,emit,one,edge,per,node,k,vv,ev,group,by,0,reduce,group,new,apply,group,reduce,function,k,ev,t,edges,function,returns,type,info,default,throw,new,illegal,argument,exception,illegal,edge,direction
Graph -> public <T> DataSet<T> groupReduceOnEdges(EdgesFunction<K, EV, T> edgesFunction, 			EdgeDirection direction, TypeInformation<T> typeInfo) throws IllegalArgumentException;1462100316;Groups by vertex and computes a GroupReduce transformation over the edge values of each vertex._The edgesFunction applied on the edges only has access to the vertex id (not the vertex value)_of the grouping vertex.__For each vertex, the edgesFunction can iterate over all edges of this vertex_with the specified direction, and emit any number of output elements, including none.__@param edgesFunction the group reduce function to apply to the neighboring edges of each vertex._@param direction the edge direction (in-, out-, all-)._@param <T> the output type_@param typeInfo the explicit return type._@return a DataSet containing elements of type T_@throws IllegalArgumentException;public <T> DataSet<T> groupReduceOnEdges(EdgesFunction<K, EV, T> edgesFunction,_			EdgeDirection direction, TypeInformation<T> typeInfo) throws IllegalArgumentException {__		switch (direction) {_			case IN:_				return edges.map(new ProjectVertexIdMap<K, EV>(1))_						.withForwardedFields("f1->f0")_						.groupBy(0).reduceGroup(new ApplyGroupReduceFunction<K, EV, T>(edgesFunction)).returns(typeInfo)__			case OUT:_				return edges.map(new ProjectVertexIdMap<K, EV>(0))_						.withForwardedFields("f0")_						.groupBy(0).reduceGroup(new ApplyGroupReduceFunction<K, EV, T>(edgesFunction)).returns(typeInfo)__			case ALL:_				return edges.flatMap(new EmitOneEdgePerNode<K, VV, EV>())_						.groupBy(0).reduceGroup(new ApplyGroupReduceFunction<K, EV, T>(edgesFunction)).returns(typeInfo)__			default:_				throw new IllegalArgumentException("Illegal edge direction")__		}_	};groups,by,vertex,and,computes,a,group,reduce,transformation,over,the,edge,values,of,each,vertex,the,edges,function,applied,on,the,edges,only,has,access,to,the,vertex,id,not,the,vertex,value,of,the,grouping,vertex,for,each,vertex,the,edges,function,can,iterate,over,all,edges,of,this,vertex,with,the,specified,direction,and,emit,any,number,of,output,elements,including,none,param,edges,function,the,group,reduce,function,to,apply,to,the,neighboring,edges,of,each,vertex,param,direction,the,edge,direction,in,out,all,param,t,the,output,type,param,type,info,the,explicit,return,type,return,a,data,set,containing,elements,of,type,t,throws,illegal,argument,exception;public,t,data,set,t,group,reduce,on,edges,edges,function,k,ev,t,edges,function,edge,direction,direction,type,information,t,type,info,throws,illegal,argument,exception,switch,direction,case,in,return,edges,map,new,project,vertex,id,map,k,ev,1,with,forwarded,fields,f1,f0,group,by,0,reduce,group,new,apply,group,reduce,function,k,ev,t,edges,function,returns,type,info,case,out,return,edges,map,new,project,vertex,id,map,k,ev,0,with,forwarded,fields,f0,group,by,0,reduce,group,new,apply,group,reduce,function,k,ev,t,edges,function,returns,type,info,case,all,return,edges,flat,map,new,emit,one,edge,per,node,k,vv,ev,group,by,0,reduce,group,new,apply,group,reduce,function,k,ev,t,edges,function,returns,type,info,default,throw,new,illegal,argument,exception,illegal,edge,direction
Graph -> public <T> DataSet<T> groupReduceOnEdges(EdgesFunction<K, EV, T> edgesFunction, 			EdgeDirection direction, TypeInformation<T> typeInfo) throws IllegalArgumentException;1462205213;Groups by vertex and computes a GroupReduce transformation over the edge values of each vertex._The edgesFunction applied on the edges only has access to the vertex id (not the vertex value)_of the grouping vertex.__For each vertex, the edgesFunction can iterate over all edges of this vertex_with the specified direction, and emit any number of output elements, including none.__@param edgesFunction the group reduce function to apply to the neighboring edges of each vertex._@param direction the edge direction (in-, out-, all-)._@param <T> the output type_@param typeInfo the explicit return type._@return a DataSet containing elements of type T_@throws IllegalArgumentException;public <T> DataSet<T> groupReduceOnEdges(EdgesFunction<K, EV, T> edgesFunction,_			EdgeDirection direction, TypeInformation<T> typeInfo) throws IllegalArgumentException {__		switch (direction) {_			case IN:_				return edges.map(new ProjectVertexIdMap<K, EV>(1))_						.withForwardedFields("f1->f0")_						.groupBy(0).reduceGroup(new ApplyGroupReduceFunction<K, EV, T>(edgesFunction)).returns(typeInfo)__			case OUT:_				return edges.map(new ProjectVertexIdMap<K, EV>(0))_						.withForwardedFields("f0")_						.groupBy(0).reduceGroup(new ApplyGroupReduceFunction<K, EV, T>(edgesFunction)).returns(typeInfo)__			case ALL:_				return edges.flatMap(new EmitOneEdgePerNode<K, VV, EV>())_						.groupBy(0).reduceGroup(new ApplyGroupReduceFunction<K, EV, T>(edgesFunction)).returns(typeInfo)__			default:_				throw new IllegalArgumentException("Illegal edge direction")__		}_	};groups,by,vertex,and,computes,a,group,reduce,transformation,over,the,edge,values,of,each,vertex,the,edges,function,applied,on,the,edges,only,has,access,to,the,vertex,id,not,the,vertex,value,of,the,grouping,vertex,for,each,vertex,the,edges,function,can,iterate,over,all,edges,of,this,vertex,with,the,specified,direction,and,emit,any,number,of,output,elements,including,none,param,edges,function,the,group,reduce,function,to,apply,to,the,neighboring,edges,of,each,vertex,param,direction,the,edge,direction,in,out,all,param,t,the,output,type,param,type,info,the,explicit,return,type,return,a,data,set,containing,elements,of,type,t,throws,illegal,argument,exception;public,t,data,set,t,group,reduce,on,edges,edges,function,k,ev,t,edges,function,edge,direction,direction,type,information,t,type,info,throws,illegal,argument,exception,switch,direction,case,in,return,edges,map,new,project,vertex,id,map,k,ev,1,with,forwarded,fields,f1,f0,group,by,0,reduce,group,new,apply,group,reduce,function,k,ev,t,edges,function,returns,type,info,case,out,return,edges,map,new,project,vertex,id,map,k,ev,0,with,forwarded,fields,f0,group,by,0,reduce,group,new,apply,group,reduce,function,k,ev,t,edges,function,returns,type,info,case,all,return,edges,flat,map,new,emit,one,edge,per,node,k,vv,ev,group,by,0,reduce,group,new,apply,group,reduce,function,k,ev,t,edges,function,returns,type,info,default,throw,new,illegal,argument,exception,illegal,edge,direction
Graph -> public <T> DataSet<T> groupReduceOnEdges(EdgesFunction<K, EV, T> edgesFunction, 			EdgeDirection direction, TypeInformation<T> typeInfo) throws IllegalArgumentException;1462208859;Groups by vertex and computes a GroupReduce transformation over the edge values of each vertex._The edgesFunction applied on the edges only has access to the vertex id (not the vertex value)_of the grouping vertex.__For each vertex, the edgesFunction can iterate over all edges of this vertex_with the specified direction, and emit any number of output elements, including none.__@param edgesFunction the group reduce function to apply to the neighboring edges of each vertex._@param direction the edge direction (in-, out-, all-)._@param <T> the output type_@param typeInfo the explicit return type._@return a DataSet containing elements of type T_@throws IllegalArgumentException;public <T> DataSet<T> groupReduceOnEdges(EdgesFunction<K, EV, T> edgesFunction,_			EdgeDirection direction, TypeInformation<T> typeInfo) throws IllegalArgumentException {__		switch (direction) {_			case IN:_				return edges.map(new ProjectVertexIdMap<K, EV>(1))_						.withForwardedFields("f1->f0")_						.groupBy(0).reduceGroup(new ApplyGroupReduceFunction<K, EV, T>(edgesFunction)).returns(typeInfo)__			case OUT:_				return edges.map(new ProjectVertexIdMap<K, EV>(0))_						.withForwardedFields("f0")_						.groupBy(0).reduceGroup(new ApplyGroupReduceFunction<K, EV, T>(edgesFunction)).returns(typeInfo)__			case ALL:_				return edges.flatMap(new EmitOneEdgePerNode<K, VV, EV>())_						.groupBy(0).reduceGroup(new ApplyGroupReduceFunction<K, EV, T>(edgesFunction)).returns(typeInfo)__			default:_				throw new IllegalArgumentException("Illegal edge direction")__		}_	};groups,by,vertex,and,computes,a,group,reduce,transformation,over,the,edge,values,of,each,vertex,the,edges,function,applied,on,the,edges,only,has,access,to,the,vertex,id,not,the,vertex,value,of,the,grouping,vertex,for,each,vertex,the,edges,function,can,iterate,over,all,edges,of,this,vertex,with,the,specified,direction,and,emit,any,number,of,output,elements,including,none,param,edges,function,the,group,reduce,function,to,apply,to,the,neighboring,edges,of,each,vertex,param,direction,the,edge,direction,in,out,all,param,t,the,output,type,param,type,info,the,explicit,return,type,return,a,data,set,containing,elements,of,type,t,throws,illegal,argument,exception;public,t,data,set,t,group,reduce,on,edges,edges,function,k,ev,t,edges,function,edge,direction,direction,type,information,t,type,info,throws,illegal,argument,exception,switch,direction,case,in,return,edges,map,new,project,vertex,id,map,k,ev,1,with,forwarded,fields,f1,f0,group,by,0,reduce,group,new,apply,group,reduce,function,k,ev,t,edges,function,returns,type,info,case,out,return,edges,map,new,project,vertex,id,map,k,ev,0,with,forwarded,fields,f0,group,by,0,reduce,group,new,apply,group,reduce,function,k,ev,t,edges,function,returns,type,info,case,all,return,edges,flat,map,new,emit,one,edge,per,node,k,vv,ev,group,by,0,reduce,group,new,apply,group,reduce,function,k,ev,t,edges,function,returns,type,info,default,throw,new,illegal,argument,exception,illegal,edge,direction
Graph -> public <T> DataSet<T> groupReduceOnEdges(EdgesFunction<K, EV, T> edgesFunction, 			EdgeDirection direction, TypeInformation<T> typeInfo) throws IllegalArgumentException;1462809297;Groups by vertex and computes a GroupReduce transformation over the edge values of each vertex._The edgesFunction applied on the edges only has access to the vertex id (not the vertex value)_of the grouping vertex.__For each vertex, the edgesFunction can iterate over all edges of this vertex_with the specified direction, and emit any number of output elements, including none.__@param edgesFunction the group reduce function to apply to the neighboring edges of each vertex._@param direction the edge direction (in-, out-, all-)._@param <T> the output type_@param typeInfo the explicit return type._@return a DataSet containing elements of type T_@throws IllegalArgumentException;public <T> DataSet<T> groupReduceOnEdges(EdgesFunction<K, EV, T> edgesFunction,_			EdgeDirection direction, TypeInformation<T> typeInfo) throws IllegalArgumentException {__		switch (direction) {_			case IN:_				return edges.map(new ProjectVertexIdMap<K, EV>(1))_						.withForwardedFields("f1->f0")_						.groupBy(0).reduceGroup(new ApplyGroupReduceFunction<K, EV, T>(edgesFunction)).returns(typeInfo)__			case OUT:_				return edges.map(new ProjectVertexIdMap<K, EV>(0))_						.withForwardedFields("f0")_						.groupBy(0).reduceGroup(new ApplyGroupReduceFunction<K, EV, T>(edgesFunction)).returns(typeInfo)__			case ALL:_				return edges.flatMap(new EmitOneEdgePerNode<K, VV, EV>())_						.groupBy(0).reduceGroup(new ApplyGroupReduceFunction<K, EV, T>(edgesFunction)).returns(typeInfo)__			default:_				throw new IllegalArgumentException("Illegal edge direction")__		}_	};groups,by,vertex,and,computes,a,group,reduce,transformation,over,the,edge,values,of,each,vertex,the,edges,function,applied,on,the,edges,only,has,access,to,the,vertex,id,not,the,vertex,value,of,the,grouping,vertex,for,each,vertex,the,edges,function,can,iterate,over,all,edges,of,this,vertex,with,the,specified,direction,and,emit,any,number,of,output,elements,including,none,param,edges,function,the,group,reduce,function,to,apply,to,the,neighboring,edges,of,each,vertex,param,direction,the,edge,direction,in,out,all,param,t,the,output,type,param,type,info,the,explicit,return,type,return,a,data,set,containing,elements,of,type,t,throws,illegal,argument,exception;public,t,data,set,t,group,reduce,on,edges,edges,function,k,ev,t,edges,function,edge,direction,direction,type,information,t,type,info,throws,illegal,argument,exception,switch,direction,case,in,return,edges,map,new,project,vertex,id,map,k,ev,1,with,forwarded,fields,f1,f0,group,by,0,reduce,group,new,apply,group,reduce,function,k,ev,t,edges,function,returns,type,info,case,out,return,edges,map,new,project,vertex,id,map,k,ev,0,with,forwarded,fields,f0,group,by,0,reduce,group,new,apply,group,reduce,function,k,ev,t,edges,function,returns,type,info,case,all,return,edges,flat,map,new,emit,one,edge,per,node,k,vv,ev,group,by,0,reduce,group,new,apply,group,reduce,function,k,ev,t,edges,function,returns,type,info,default,throw,new,illegal,argument,exception,illegal,edge,direction
Graph -> public <T> DataSet<T> groupReduceOnEdges(EdgesFunction<K, EV, T> edgesFunction, 			EdgeDirection direction, TypeInformation<T> typeInfo) throws IllegalArgumentException;1465316775;Groups by vertex and computes a GroupReduce transformation over the edge values of each vertex._The edgesFunction applied on the edges only has access to the vertex id (not the vertex value)_of the grouping vertex.__For each vertex, the edgesFunction can iterate over all edges of this vertex_with the specified direction, and emit any number of output elements, including none.__@param edgesFunction the group reduce function to apply to the neighboring edges of each vertex._@param direction the edge direction (in-, out-, all-)._@param <T> the output type_@param typeInfo the explicit return type._@return a DataSet containing elements of type T_@throws IllegalArgumentException;public <T> DataSet<T> groupReduceOnEdges(EdgesFunction<K, EV, T> edgesFunction,_			EdgeDirection direction, TypeInformation<T> typeInfo) throws IllegalArgumentException {__		switch (direction) {_			case IN:_				return edges.map(new ProjectVertexIdMap<K, EV>(1))_						.withForwardedFields("f1->f0")_						.groupBy(0).reduceGroup(new ApplyGroupReduceFunction<K, EV, T>(edgesFunction)).returns(typeInfo)__			case OUT:_				return edges.map(new ProjectVertexIdMap<K, EV>(0))_						.withForwardedFields("f0")_						.groupBy(0).reduceGroup(new ApplyGroupReduceFunction<K, EV, T>(edgesFunction)).returns(typeInfo)__			case ALL:_				return edges.flatMap(new EmitOneEdgePerNode<K, VV, EV>())_						.groupBy(0).reduceGroup(new ApplyGroupReduceFunction<K, EV, T>(edgesFunction)).returns(typeInfo)__			default:_				throw new IllegalArgumentException("Illegal edge direction")__		}_	};groups,by,vertex,and,computes,a,group,reduce,transformation,over,the,edge,values,of,each,vertex,the,edges,function,applied,on,the,edges,only,has,access,to,the,vertex,id,not,the,vertex,value,of,the,grouping,vertex,for,each,vertex,the,edges,function,can,iterate,over,all,edges,of,this,vertex,with,the,specified,direction,and,emit,any,number,of,output,elements,including,none,param,edges,function,the,group,reduce,function,to,apply,to,the,neighboring,edges,of,each,vertex,param,direction,the,edge,direction,in,out,all,param,t,the,output,type,param,type,info,the,explicit,return,type,return,a,data,set,containing,elements,of,type,t,throws,illegal,argument,exception;public,t,data,set,t,group,reduce,on,edges,edges,function,k,ev,t,edges,function,edge,direction,direction,type,information,t,type,info,throws,illegal,argument,exception,switch,direction,case,in,return,edges,map,new,project,vertex,id,map,k,ev,1,with,forwarded,fields,f1,f0,group,by,0,reduce,group,new,apply,group,reduce,function,k,ev,t,edges,function,returns,type,info,case,out,return,edges,map,new,project,vertex,id,map,k,ev,0,with,forwarded,fields,f0,group,by,0,reduce,group,new,apply,group,reduce,function,k,ev,t,edges,function,returns,type,info,case,all,return,edges,flat,map,new,emit,one,edge,per,node,k,vv,ev,group,by,0,reduce,group,new,apply,group,reduce,function,k,ev,t,edges,function,returns,type,info,default,throw,new,illegal,argument,exception,illegal,edge,direction
Graph -> public <T> DataSet<T> groupReduceOnEdges(EdgesFunction<K, EV, T> edgesFunction, 			EdgeDirection direction, TypeInformation<T> typeInfo) throws IllegalArgumentException;1466789678;Groups by vertex and computes a GroupReduce transformation over the edge values of each vertex._The edgesFunction applied on the edges only has access to the vertex id (not the vertex value)_of the grouping vertex.__For each vertex, the edgesFunction can iterate over all edges of this vertex_with the specified direction, and emit any number of output elements, including none.__@param edgesFunction the group reduce function to apply to the neighboring edges of each vertex._@param direction the edge direction (in-, out-, all-)._@param <T> the output type_@param typeInfo the explicit return type._@return a DataSet containing elements of type T_@throws IllegalArgumentException;public <T> DataSet<T> groupReduceOnEdges(EdgesFunction<K, EV, T> edgesFunction,_			EdgeDirection direction, TypeInformation<T> typeInfo) throws IllegalArgumentException {__		switch (direction) {_			case IN:_				return edges.map(new ProjectVertexIdMap<K, EV>(1))_						.withForwardedFields("f1->f0")_						.groupBy(0).reduceGroup(new ApplyGroupReduceFunction<K, EV, T>(edgesFunction)).returns(typeInfo)__			case OUT:_				return edges.map(new ProjectVertexIdMap<K, EV>(0))_						.withForwardedFields("f0")_						.groupBy(0).reduceGroup(new ApplyGroupReduceFunction<K, EV, T>(edgesFunction)).returns(typeInfo)__			case ALL:_				return edges.flatMap(new EmitOneEdgePerNode<K, VV, EV>())_						.groupBy(0).reduceGroup(new ApplyGroupReduceFunction<K, EV, T>(edgesFunction)).returns(typeInfo)__			default:_				throw new IllegalArgumentException("Illegal edge direction")__		}_	};groups,by,vertex,and,computes,a,group,reduce,transformation,over,the,edge,values,of,each,vertex,the,edges,function,applied,on,the,edges,only,has,access,to,the,vertex,id,not,the,vertex,value,of,the,grouping,vertex,for,each,vertex,the,edges,function,can,iterate,over,all,edges,of,this,vertex,with,the,specified,direction,and,emit,any,number,of,output,elements,including,none,param,edges,function,the,group,reduce,function,to,apply,to,the,neighboring,edges,of,each,vertex,param,direction,the,edge,direction,in,out,all,param,t,the,output,type,param,type,info,the,explicit,return,type,return,a,data,set,containing,elements,of,type,t,throws,illegal,argument,exception;public,t,data,set,t,group,reduce,on,edges,edges,function,k,ev,t,edges,function,edge,direction,direction,type,information,t,type,info,throws,illegal,argument,exception,switch,direction,case,in,return,edges,map,new,project,vertex,id,map,k,ev,1,with,forwarded,fields,f1,f0,group,by,0,reduce,group,new,apply,group,reduce,function,k,ev,t,edges,function,returns,type,info,case,out,return,edges,map,new,project,vertex,id,map,k,ev,0,with,forwarded,fields,f0,group,by,0,reduce,group,new,apply,group,reduce,function,k,ev,t,edges,function,returns,type,info,case,all,return,edges,flat,map,new,emit,one,edge,per,node,k,vv,ev,group,by,0,reduce,group,new,apply,group,reduce,function,k,ev,t,edges,function,returns,type,info,default,throw,new,illegal,argument,exception,illegal,edge,direction
Graph -> public <T> DataSet<T> groupReduceOnEdges(EdgesFunction<K, EV, T> edgesFunction, 			EdgeDirection direction, TypeInformation<T> typeInfo) throws IllegalArgumentException;1467140656;Groups by vertex and computes a GroupReduce transformation over the edge values of each vertex._The edgesFunction applied on the edges only has access to the vertex id (not the vertex value)_of the grouping vertex.__For each vertex, the edgesFunction can iterate over all edges of this vertex_with the specified direction, and emit any number of output elements, including none.__@param edgesFunction the group reduce function to apply to the neighboring edges of each vertex._@param direction the edge direction (in-, out-, all-)._@param <T> the output type_@param typeInfo the explicit return type._@return a DataSet containing elements of type T_@throws IllegalArgumentException;public <T> DataSet<T> groupReduceOnEdges(EdgesFunction<K, EV, T> edgesFunction,_			EdgeDirection direction, TypeInformation<T> typeInfo) throws IllegalArgumentException {__		switch (direction) {_			case IN:_				return edges.map(new ProjectVertexIdMap<K, EV>(1))_						.withForwardedFields("f1->f0")_						.groupBy(0).reduceGroup(new ApplyGroupReduceFunction<K, EV, T>(edgesFunction)).returns(typeInfo)__			case OUT:_				return edges.map(new ProjectVertexIdMap<K, EV>(0))_						.withForwardedFields("f0")_						.groupBy(0).reduceGroup(new ApplyGroupReduceFunction<K, EV, T>(edgesFunction)).returns(typeInfo)__			case ALL:_				return edges.flatMap(new EmitOneEdgePerNode<K, VV, EV>())_						.groupBy(0).reduceGroup(new ApplyGroupReduceFunction<K, EV, T>(edgesFunction)).returns(typeInfo)__			default:_				throw new IllegalArgumentException("Illegal edge direction")__		}_	};groups,by,vertex,and,computes,a,group,reduce,transformation,over,the,edge,values,of,each,vertex,the,edges,function,applied,on,the,edges,only,has,access,to,the,vertex,id,not,the,vertex,value,of,the,grouping,vertex,for,each,vertex,the,edges,function,can,iterate,over,all,edges,of,this,vertex,with,the,specified,direction,and,emit,any,number,of,output,elements,including,none,param,edges,function,the,group,reduce,function,to,apply,to,the,neighboring,edges,of,each,vertex,param,direction,the,edge,direction,in,out,all,param,t,the,output,type,param,type,info,the,explicit,return,type,return,a,data,set,containing,elements,of,type,t,throws,illegal,argument,exception;public,t,data,set,t,group,reduce,on,edges,edges,function,k,ev,t,edges,function,edge,direction,direction,type,information,t,type,info,throws,illegal,argument,exception,switch,direction,case,in,return,edges,map,new,project,vertex,id,map,k,ev,1,with,forwarded,fields,f1,f0,group,by,0,reduce,group,new,apply,group,reduce,function,k,ev,t,edges,function,returns,type,info,case,out,return,edges,map,new,project,vertex,id,map,k,ev,0,with,forwarded,fields,f0,group,by,0,reduce,group,new,apply,group,reduce,function,k,ev,t,edges,function,returns,type,info,case,all,return,edges,flat,map,new,emit,one,edge,per,node,k,vv,ev,group,by,0,reduce,group,new,apply,group,reduce,function,k,ev,t,edges,function,returns,type,info,default,throw,new,illegal,argument,exception,illegal,edge,direction
Graph -> public <T> DataSet<T> groupReduceOnEdges(EdgesFunction<K, EV, T> edgesFunction, 			EdgeDirection direction, TypeInformation<T> typeInfo) throws IllegalArgumentException;1467306272;Groups by vertex and computes a GroupReduce transformation over the edge values of each vertex._The edgesFunction applied on the edges only has access to the vertex id (not the vertex value)_of the grouping vertex.__For each vertex, the edgesFunction can iterate over all edges of this vertex_with the specified direction, and emit any number of output elements, including none.__@param edgesFunction the group reduce function to apply to the neighboring edges of each vertex._@param direction the edge direction (in-, out-, all-)._@param <T> the output type_@param typeInfo the explicit return type._@return a DataSet containing elements of type T_@throws IllegalArgumentException;public <T> DataSet<T> groupReduceOnEdges(EdgesFunction<K, EV, T> edgesFunction,_			EdgeDirection direction, TypeInformation<T> typeInfo) throws IllegalArgumentException {__		switch (direction) {_			case IN:_				return edges.map(new ProjectVertexIdMap<K, EV>(1))_						.withForwardedFields("f1->f0")_						.groupBy(0).reduceGroup(new ApplyGroupReduceFunction<K, EV, T>(edgesFunction)).returns(typeInfo)__			case OUT:_				return edges.map(new ProjectVertexIdMap<K, EV>(0))_						.withForwardedFields("f0")_						.groupBy(0).reduceGroup(new ApplyGroupReduceFunction<K, EV, T>(edgesFunction)).returns(typeInfo)__			case ALL:_				return edges.flatMap(new EmitOneEdgePerNode<K, VV, EV>())_						.groupBy(0).reduceGroup(new ApplyGroupReduceFunction<K, EV, T>(edgesFunction)).returns(typeInfo)__			default:_				throw new IllegalArgumentException("Illegal edge direction")__		}_	};groups,by,vertex,and,computes,a,group,reduce,transformation,over,the,edge,values,of,each,vertex,the,edges,function,applied,on,the,edges,only,has,access,to,the,vertex,id,not,the,vertex,value,of,the,grouping,vertex,for,each,vertex,the,edges,function,can,iterate,over,all,edges,of,this,vertex,with,the,specified,direction,and,emit,any,number,of,output,elements,including,none,param,edges,function,the,group,reduce,function,to,apply,to,the,neighboring,edges,of,each,vertex,param,direction,the,edge,direction,in,out,all,param,t,the,output,type,param,type,info,the,explicit,return,type,return,a,data,set,containing,elements,of,type,t,throws,illegal,argument,exception;public,t,data,set,t,group,reduce,on,edges,edges,function,k,ev,t,edges,function,edge,direction,direction,type,information,t,type,info,throws,illegal,argument,exception,switch,direction,case,in,return,edges,map,new,project,vertex,id,map,k,ev,1,with,forwarded,fields,f1,f0,group,by,0,reduce,group,new,apply,group,reduce,function,k,ev,t,edges,function,returns,type,info,case,out,return,edges,map,new,project,vertex,id,map,k,ev,0,with,forwarded,fields,f0,group,by,0,reduce,group,new,apply,group,reduce,function,k,ev,t,edges,function,returns,type,info,case,all,return,edges,flat,map,new,emit,one,edge,per,node,k,vv,ev,group,by,0,reduce,group,new,apply,group,reduce,function,k,ev,t,edges,function,returns,type,info,default,throw,new,illegal,argument,exception,illegal,edge,direction
Graph -> public <T> DataSet<T> groupReduceOnEdges(EdgesFunction<K, EV, T> edgesFunction, 			EdgeDirection direction, TypeInformation<T> typeInfo) throws IllegalArgumentException;1470042815;Groups by vertex and computes a GroupReduce transformation over the edge values of each vertex._The edgesFunction applied on the edges only has access to the vertex id (not the vertex value)_of the grouping vertex.__For each vertex, the edgesFunction can iterate over all edges of this vertex_with the specified direction, and emit any number of output elements, including none.__@param edgesFunction the group reduce function to apply to the neighboring edges of each vertex._@param direction the edge direction (in-, out-, all-)._@param <T> the output type_@param typeInfo the explicit return type._@return a DataSet containing elements of type T_@throws IllegalArgumentException;public <T> DataSet<T> groupReduceOnEdges(EdgesFunction<K, EV, T> edgesFunction,_			EdgeDirection direction, TypeInformation<T> typeInfo) throws IllegalArgumentException {__		switch (direction) {_			case IN:_				return edges.map(new ProjectVertexIdMap<K, EV>(1))_						.withForwardedFields("f1->f0")_						.groupBy(0).reduceGroup(new ApplyGroupReduceFunction<K, EV, T>(edgesFunction)).returns(typeInfo)__			case OUT:_				return edges.map(new ProjectVertexIdMap<K, EV>(0))_						.withForwardedFields("f0")_						.groupBy(0).reduceGroup(new ApplyGroupReduceFunction<K, EV, T>(edgesFunction)).returns(typeInfo)__			case ALL:_				return edges.flatMap(new EmitOneEdgePerNode<K, VV, EV>())_						.groupBy(0).reduceGroup(new ApplyGroupReduceFunction<K, EV, T>(edgesFunction)).returns(typeInfo)__			default:_				throw new IllegalArgumentException("Illegal edge direction")__		}_	};groups,by,vertex,and,computes,a,group,reduce,transformation,over,the,edge,values,of,each,vertex,the,edges,function,applied,on,the,edges,only,has,access,to,the,vertex,id,not,the,vertex,value,of,the,grouping,vertex,for,each,vertex,the,edges,function,can,iterate,over,all,edges,of,this,vertex,with,the,specified,direction,and,emit,any,number,of,output,elements,including,none,param,edges,function,the,group,reduce,function,to,apply,to,the,neighboring,edges,of,each,vertex,param,direction,the,edge,direction,in,out,all,param,t,the,output,type,param,type,info,the,explicit,return,type,return,a,data,set,containing,elements,of,type,t,throws,illegal,argument,exception;public,t,data,set,t,group,reduce,on,edges,edges,function,k,ev,t,edges,function,edge,direction,direction,type,information,t,type,info,throws,illegal,argument,exception,switch,direction,case,in,return,edges,map,new,project,vertex,id,map,k,ev,1,with,forwarded,fields,f1,f0,group,by,0,reduce,group,new,apply,group,reduce,function,k,ev,t,edges,function,returns,type,info,case,out,return,edges,map,new,project,vertex,id,map,k,ev,0,with,forwarded,fields,f0,group,by,0,reduce,group,new,apply,group,reduce,function,k,ev,t,edges,function,returns,type,info,case,all,return,edges,flat,map,new,emit,one,edge,per,node,k,vv,ev,group,by,0,reduce,group,new,apply,group,reduce,function,k,ev,t,edges,function,returns,type,info,default,throw,new,illegal,argument,exception,illegal,edge,direction
Graph -> public <T> DataSet<T> groupReduceOnEdges(EdgesFunction<K, EV, T> edgesFunction, 			EdgeDirection direction, TypeInformation<T> typeInfo) throws IllegalArgumentException;1475684776;Groups by vertex and computes a GroupReduce transformation over the edge values of each vertex._The edgesFunction applied on the edges only has access to the vertex id (not the vertex value)_of the grouping vertex.__For each vertex, the edgesFunction can iterate over all edges of this vertex_with the specified direction, and emit any number of output elements, including none.__@param edgesFunction the group reduce function to apply to the neighboring edges of each vertex._@param direction the edge direction (in-, out-, all-)._@param <T> the output type_@param typeInfo the explicit return type._@return a DataSet containing elements of type T_@throws IllegalArgumentException;public <T> DataSet<T> groupReduceOnEdges(EdgesFunction<K, EV, T> edgesFunction,_			EdgeDirection direction, TypeInformation<T> typeInfo) throws IllegalArgumentException {__		switch (direction) {_			case IN:_				return edges.map(new ProjectVertexIdMap<K, EV>(1))_						.withForwardedFields("f1->f0")_						.groupBy(0).reduceGroup(new ApplyGroupReduceFunction<>(edgesFunction)).returns(typeInfo)__			case OUT:_				return edges.map(new ProjectVertexIdMap<K, EV>(0))_						.withForwardedFields("f0")_						.groupBy(0).reduceGroup(new ApplyGroupReduceFunction<>(edgesFunction)).returns(typeInfo)__			case ALL:_				return edges.flatMap(new EmitOneEdgePerNode<K, VV, EV>())_						.groupBy(0).reduceGroup(new ApplyGroupReduceFunction<>(edgesFunction)).returns(typeInfo)__			default:_				throw new IllegalArgumentException("Illegal edge direction")__		}_	};groups,by,vertex,and,computes,a,group,reduce,transformation,over,the,edge,values,of,each,vertex,the,edges,function,applied,on,the,edges,only,has,access,to,the,vertex,id,not,the,vertex,value,of,the,grouping,vertex,for,each,vertex,the,edges,function,can,iterate,over,all,edges,of,this,vertex,with,the,specified,direction,and,emit,any,number,of,output,elements,including,none,param,edges,function,the,group,reduce,function,to,apply,to,the,neighboring,edges,of,each,vertex,param,direction,the,edge,direction,in,out,all,param,t,the,output,type,param,type,info,the,explicit,return,type,return,a,data,set,containing,elements,of,type,t,throws,illegal,argument,exception;public,t,data,set,t,group,reduce,on,edges,edges,function,k,ev,t,edges,function,edge,direction,direction,type,information,t,type,info,throws,illegal,argument,exception,switch,direction,case,in,return,edges,map,new,project,vertex,id,map,k,ev,1,with,forwarded,fields,f1,f0,group,by,0,reduce,group,new,apply,group,reduce,function,edges,function,returns,type,info,case,out,return,edges,map,new,project,vertex,id,map,k,ev,0,with,forwarded,fields,f0,group,by,0,reduce,group,new,apply,group,reduce,function,edges,function,returns,type,info,case,all,return,edges,flat,map,new,emit,one,edge,per,node,k,vv,ev,group,by,0,reduce,group,new,apply,group,reduce,function,edges,function,returns,type,info,default,throw,new,illegal,argument,exception,illegal,edge,direction
Graph -> public <T> DataSet<T> groupReduceOnEdges(EdgesFunction<K, EV, T> edgesFunction, 			EdgeDirection direction, TypeInformation<T> typeInfo) throws IllegalArgumentException;1475685606;Groups by vertex and computes a GroupReduce transformation over the edge values of each vertex._The edgesFunction applied on the edges only has access to the vertex id (not the vertex value)_of the grouping vertex.__For each vertex, the edgesFunction can iterate over all edges of this vertex_with the specified direction, and emit any number of output elements, including none.__@param edgesFunction the group reduce function to apply to the neighboring edges of each vertex._@param direction the edge direction (in-, out-, all-)._@param <T> the output type_@param typeInfo the explicit return type._@return a DataSet containing elements of type T_@throws IllegalArgumentException;public <T> DataSet<T> groupReduceOnEdges(EdgesFunction<K, EV, T> edgesFunction,_			EdgeDirection direction, TypeInformation<T> typeInfo) throws IllegalArgumentException {__		switch (direction) {_			case IN:_				return edges.map(new ProjectVertexIdMap<K, EV>(1))_						.withForwardedFields("f1->f0")_						.groupBy(0).reduceGroup(new ApplyGroupReduceFunction<>(edgesFunction)).returns(typeInfo)__			case OUT:_				return edges.map(new ProjectVertexIdMap<K, EV>(0))_						.withForwardedFields("f0")_						.groupBy(0).reduceGroup(new ApplyGroupReduceFunction<>(edgesFunction)).returns(typeInfo)__			case ALL:_				return edges.flatMap(new EmitOneEdgePerNode<K, VV, EV>())_						.groupBy(0).reduceGroup(new ApplyGroupReduceFunction<>(edgesFunction)).returns(typeInfo)__			default:_				throw new IllegalArgumentException("Illegal edge direction")__		}_	};groups,by,vertex,and,computes,a,group,reduce,transformation,over,the,edge,values,of,each,vertex,the,edges,function,applied,on,the,edges,only,has,access,to,the,vertex,id,not,the,vertex,value,of,the,grouping,vertex,for,each,vertex,the,edges,function,can,iterate,over,all,edges,of,this,vertex,with,the,specified,direction,and,emit,any,number,of,output,elements,including,none,param,edges,function,the,group,reduce,function,to,apply,to,the,neighboring,edges,of,each,vertex,param,direction,the,edge,direction,in,out,all,param,t,the,output,type,param,type,info,the,explicit,return,type,return,a,data,set,containing,elements,of,type,t,throws,illegal,argument,exception;public,t,data,set,t,group,reduce,on,edges,edges,function,k,ev,t,edges,function,edge,direction,direction,type,information,t,type,info,throws,illegal,argument,exception,switch,direction,case,in,return,edges,map,new,project,vertex,id,map,k,ev,1,with,forwarded,fields,f1,f0,group,by,0,reduce,group,new,apply,group,reduce,function,edges,function,returns,type,info,case,out,return,edges,map,new,project,vertex,id,map,k,ev,0,with,forwarded,fields,f0,group,by,0,reduce,group,new,apply,group,reduce,function,edges,function,returns,type,info,case,all,return,edges,flat,map,new,emit,one,edge,per,node,k,vv,ev,group,by,0,reduce,group,new,apply,group,reduce,function,edges,function,returns,type,info,default,throw,new,illegal,argument,exception,illegal,edge,direction
Graph -> public <T> DataSet<T> groupReduceOnEdges(EdgesFunction<K, EV, T> edgesFunction, 			EdgeDirection direction, TypeInformation<T> typeInfo) throws IllegalArgumentException;1481745825;Groups by vertex and computes a GroupReduce transformation over the edge values of each vertex._The edgesFunction applied on the edges only has access to the vertex id (not the vertex value)_of the grouping vertex.__For each vertex, the edgesFunction can iterate over all edges of this vertex_with the specified direction, and emit any number of output elements, including none.__@param edgesFunction the group reduce function to apply to the neighboring edges of each vertex._@param direction the edge direction (in-, out-, all-)._@param <T> the output type_@param typeInfo the explicit return type._@return a DataSet containing elements of type T_@throws IllegalArgumentException;public <T> DataSet<T> groupReduceOnEdges(EdgesFunction<K, EV, T> edgesFunction,_			EdgeDirection direction, TypeInformation<T> typeInfo) throws IllegalArgumentException {__		switch (direction) {_			case IN:_				return edges.map(new ProjectVertexIdMap<K, EV>(1)).name("Vertex ID")_						.withForwardedFields("f1->f0")_						.groupBy(0).reduceGroup(new ApplyGroupReduceFunction<>(edgesFunction))_							.name("GroupReduce on in-edges").returns(typeInfo)__			case OUT:_				return edges.map(new ProjectVertexIdMap<K, EV>(0)).name("Vertex ID")_						.withForwardedFields("f0")_						.groupBy(0).reduceGroup(new ApplyGroupReduceFunction<>(edgesFunction))_							.name("GroupReduce on out-edges").returns(typeInfo)__			case ALL:_				return edges.flatMap(new EmitOneEdgePerNode<K, VV, EV>()).name("Emit edge")_						.groupBy(0).reduceGroup(new ApplyGroupReduceFunction<>(edgesFunction))_							.name("GroupReduce on in- and out-edges").returns(typeInfo)__			default:_				throw new IllegalArgumentException("Illegal edge direction")__		}_	};groups,by,vertex,and,computes,a,group,reduce,transformation,over,the,edge,values,of,each,vertex,the,edges,function,applied,on,the,edges,only,has,access,to,the,vertex,id,not,the,vertex,value,of,the,grouping,vertex,for,each,vertex,the,edges,function,can,iterate,over,all,edges,of,this,vertex,with,the,specified,direction,and,emit,any,number,of,output,elements,including,none,param,edges,function,the,group,reduce,function,to,apply,to,the,neighboring,edges,of,each,vertex,param,direction,the,edge,direction,in,out,all,param,t,the,output,type,param,type,info,the,explicit,return,type,return,a,data,set,containing,elements,of,type,t,throws,illegal,argument,exception;public,t,data,set,t,group,reduce,on,edges,edges,function,k,ev,t,edges,function,edge,direction,direction,type,information,t,type,info,throws,illegal,argument,exception,switch,direction,case,in,return,edges,map,new,project,vertex,id,map,k,ev,1,name,vertex,id,with,forwarded,fields,f1,f0,group,by,0,reduce,group,new,apply,group,reduce,function,edges,function,name,group,reduce,on,in,edges,returns,type,info,case,out,return,edges,map,new,project,vertex,id,map,k,ev,0,name,vertex,id,with,forwarded,fields,f0,group,by,0,reduce,group,new,apply,group,reduce,function,edges,function,name,group,reduce,on,out,edges,returns,type,info,case,all,return,edges,flat,map,new,emit,one,edge,per,node,k,vv,ev,name,emit,edge,group,by,0,reduce,group,new,apply,group,reduce,function,edges,function,name,group,reduce,on,in,and,out,edges,returns,type,info,default,throw,new,illegal,argument,exception,illegal,edge,direction
Graph -> public <T> DataSet<T> groupReduceOnEdges(EdgesFunction<K, EV, T> edgesFunction, 			EdgeDirection direction, TypeInformation<T> typeInfo) throws IllegalArgumentException;1481881009;Groups by vertex and computes a GroupReduce transformation over the edge values of each vertex._The edgesFunction applied on the edges only has access to the vertex id (not the vertex value)_of the grouping vertex.__For each vertex, the edgesFunction can iterate over all edges of this vertex_with the specified direction, and emit any number of output elements, including none.__@param edgesFunction the group reduce function to apply to the neighboring edges of each vertex._@param direction the edge direction (in-, out-, all-)._@param <T> the output type_@param typeInfo the explicit return type._@return a DataSet containing elements of type T_@throws IllegalArgumentException;public <T> DataSet<T> groupReduceOnEdges(EdgesFunction<K, EV, T> edgesFunction,_			EdgeDirection direction, TypeInformation<T> typeInfo) throws IllegalArgumentException {__		switch (direction) {_			case IN:_				return edges.map(new ProjectVertexIdMap<K, EV>(1)).name("Vertex ID")_						.withForwardedFields("f1->f0")_						.groupBy(0).reduceGroup(new ApplyGroupReduceFunction<>(edgesFunction))_							.name("GroupReduce on in-edges").returns(typeInfo)__			case OUT:_				return edges.map(new ProjectVertexIdMap<K, EV>(0)).name("Vertex ID")_						.withForwardedFields("f0")_						.groupBy(0).reduceGroup(new ApplyGroupReduceFunction<>(edgesFunction))_							.name("GroupReduce on out-edges").returns(typeInfo)__			case ALL:_				return edges.flatMap(new EmitOneEdgePerNode<K, EV>()).name("Emit edge")_						.groupBy(0).reduceGroup(new ApplyGroupReduceFunction<>(edgesFunction))_							.name("GroupReduce on in- and out-edges").returns(typeInfo)__			default:_				throw new IllegalArgumentException("Illegal edge direction")__		}_	};groups,by,vertex,and,computes,a,group,reduce,transformation,over,the,edge,values,of,each,vertex,the,edges,function,applied,on,the,edges,only,has,access,to,the,vertex,id,not,the,vertex,value,of,the,grouping,vertex,for,each,vertex,the,edges,function,can,iterate,over,all,edges,of,this,vertex,with,the,specified,direction,and,emit,any,number,of,output,elements,including,none,param,edges,function,the,group,reduce,function,to,apply,to,the,neighboring,edges,of,each,vertex,param,direction,the,edge,direction,in,out,all,param,t,the,output,type,param,type,info,the,explicit,return,type,return,a,data,set,containing,elements,of,type,t,throws,illegal,argument,exception;public,t,data,set,t,group,reduce,on,edges,edges,function,k,ev,t,edges,function,edge,direction,direction,type,information,t,type,info,throws,illegal,argument,exception,switch,direction,case,in,return,edges,map,new,project,vertex,id,map,k,ev,1,name,vertex,id,with,forwarded,fields,f1,f0,group,by,0,reduce,group,new,apply,group,reduce,function,edges,function,name,group,reduce,on,in,edges,returns,type,info,case,out,return,edges,map,new,project,vertex,id,map,k,ev,0,name,vertex,id,with,forwarded,fields,f0,group,by,0,reduce,group,new,apply,group,reduce,function,edges,function,name,group,reduce,on,out,edges,returns,type,info,case,all,return,edges,flat,map,new,emit,one,edge,per,node,k,ev,name,emit,edge,group,by,0,reduce,group,new,apply,group,reduce,function,edges,function,name,group,reduce,on,in,and,out,edges,returns,type,info,default,throw,new,illegal,argument,exception,illegal,edge,direction
Graph -> public <T> DataSet<T> groupReduceOnEdges(EdgesFunction<K, EV, T> edgesFunction, 			EdgeDirection direction, TypeInformation<T> typeInfo) throws IllegalArgumentException;1484160227;Groups by vertex and computes a GroupReduce transformation over the edge values of each vertex._The edgesFunction applied on the edges only has access to the vertex id (not the vertex value)_of the grouping vertex.__For each vertex, the edgesFunction can iterate over all edges of this vertex_with the specified direction, and emit any number of output elements, including none.__@param edgesFunction the group reduce function to apply to the neighboring edges of each vertex._@param direction the edge direction (in-, out-, all-)._@param <T> the output type_@param typeInfo the explicit return type._@return a DataSet containing elements of type T_@throws IllegalArgumentException;public <T> DataSet<T> groupReduceOnEdges(EdgesFunction<K, EV, T> edgesFunction,_			EdgeDirection direction, TypeInformation<T> typeInfo) throws IllegalArgumentException {__		switch (direction) {_			case IN:_				return edges.map(new ProjectVertexIdMap<K, EV>(1)).name("Vertex ID")_						.withForwardedFields("f1->f0")_						.groupBy(0).reduceGroup(new ApplyGroupReduceFunction<>(edgesFunction))_							.name("GroupReduce on in-edges").returns(typeInfo)__			case OUT:_				return edges.map(new ProjectVertexIdMap<K, EV>(0)).name("Vertex ID")_						.withForwardedFields("f0")_						.groupBy(0).reduceGroup(new ApplyGroupReduceFunction<>(edgesFunction))_							.name("GroupReduce on out-edges").returns(typeInfo)__			case ALL:_				return edges.flatMap(new EmitOneEdgePerNode<K, EV>()).name("Emit edge")_						.groupBy(0).reduceGroup(new ApplyGroupReduceFunction<>(edgesFunction))_							.name("GroupReduce on in- and out-edges").returns(typeInfo)__			default:_				throw new IllegalArgumentException("Illegal edge direction")__		}_	};groups,by,vertex,and,computes,a,group,reduce,transformation,over,the,edge,values,of,each,vertex,the,edges,function,applied,on,the,edges,only,has,access,to,the,vertex,id,not,the,vertex,value,of,the,grouping,vertex,for,each,vertex,the,edges,function,can,iterate,over,all,edges,of,this,vertex,with,the,specified,direction,and,emit,any,number,of,output,elements,including,none,param,edges,function,the,group,reduce,function,to,apply,to,the,neighboring,edges,of,each,vertex,param,direction,the,edge,direction,in,out,all,param,t,the,output,type,param,type,info,the,explicit,return,type,return,a,data,set,containing,elements,of,type,t,throws,illegal,argument,exception;public,t,data,set,t,group,reduce,on,edges,edges,function,k,ev,t,edges,function,edge,direction,direction,type,information,t,type,info,throws,illegal,argument,exception,switch,direction,case,in,return,edges,map,new,project,vertex,id,map,k,ev,1,name,vertex,id,with,forwarded,fields,f1,f0,group,by,0,reduce,group,new,apply,group,reduce,function,edges,function,name,group,reduce,on,in,edges,returns,type,info,case,out,return,edges,map,new,project,vertex,id,map,k,ev,0,name,vertex,id,with,forwarded,fields,f0,group,by,0,reduce,group,new,apply,group,reduce,function,edges,function,name,group,reduce,on,out,edges,returns,type,info,case,all,return,edges,flat,map,new,emit,one,edge,per,node,k,ev,name,emit,edge,group,by,0,reduce,group,new,apply,group,reduce,function,edges,function,name,group,reduce,on,in,and,out,edges,returns,type,info,default,throw,new,illegal,argument,exception,illegal,edge,direction
Graph -> public <T> DataSet<T> groupReduceOnEdges(EdgesFunction<K, EV, T> edgesFunction, 			EdgeDirection direction, TypeInformation<T> typeInfo) throws IllegalArgumentException;1484685504;Groups by vertex and computes a GroupReduce transformation over the edge values of each vertex._The edgesFunction applied on the edges only has access to the vertex id (not the vertex value)_of the grouping vertex.__For each vertex, the edgesFunction can iterate over all edges of this vertex_with the specified direction, and emit any number of output elements, including none.__@param edgesFunction the group reduce function to apply to the neighboring edges of each vertex._@param direction the edge direction (in-, out-, all-)._@param <T> the output type_@param typeInfo the explicit return type._@return a DataSet containing elements of type T_@throws IllegalArgumentException;public <T> DataSet<T> groupReduceOnEdges(EdgesFunction<K, EV, T> edgesFunction,_			EdgeDirection direction, TypeInformation<T> typeInfo) throws IllegalArgumentException {__		switch (direction) {_			case IN:_				return edges.map(new ProjectVertexIdMap<K, EV>(1)).name("Vertex ID")_						.withForwardedFields("f1->f0")_						.groupBy(0).reduceGroup(new ApplyGroupReduceFunction<>(edgesFunction))_							.name("GroupReduce on in-edges").returns(typeInfo)__			case OUT:_				return edges.map(new ProjectVertexIdMap<K, EV>(0)).name("Vertex ID")_						.withForwardedFields("f0")_						.groupBy(0).reduceGroup(new ApplyGroupReduceFunction<>(edgesFunction))_							.name("GroupReduce on out-edges").returns(typeInfo)__			case ALL:_				return edges.flatMap(new EmitOneEdgePerNode<K, EV>()).name("Emit edge")_						.groupBy(0).reduceGroup(new ApplyGroupReduceFunction<>(edgesFunction))_							.name("GroupReduce on in- and out-edges").returns(typeInfo)__			default:_				throw new IllegalArgumentException("Illegal edge direction")__		}_	};groups,by,vertex,and,computes,a,group,reduce,transformation,over,the,edge,values,of,each,vertex,the,edges,function,applied,on,the,edges,only,has,access,to,the,vertex,id,not,the,vertex,value,of,the,grouping,vertex,for,each,vertex,the,edges,function,can,iterate,over,all,edges,of,this,vertex,with,the,specified,direction,and,emit,any,number,of,output,elements,including,none,param,edges,function,the,group,reduce,function,to,apply,to,the,neighboring,edges,of,each,vertex,param,direction,the,edge,direction,in,out,all,param,t,the,output,type,param,type,info,the,explicit,return,type,return,a,data,set,containing,elements,of,type,t,throws,illegal,argument,exception;public,t,data,set,t,group,reduce,on,edges,edges,function,k,ev,t,edges,function,edge,direction,direction,type,information,t,type,info,throws,illegal,argument,exception,switch,direction,case,in,return,edges,map,new,project,vertex,id,map,k,ev,1,name,vertex,id,with,forwarded,fields,f1,f0,group,by,0,reduce,group,new,apply,group,reduce,function,edges,function,name,group,reduce,on,in,edges,returns,type,info,case,out,return,edges,map,new,project,vertex,id,map,k,ev,0,name,vertex,id,with,forwarded,fields,f0,group,by,0,reduce,group,new,apply,group,reduce,function,edges,function,name,group,reduce,on,out,edges,returns,type,info,case,all,return,edges,flat,map,new,emit,one,edge,per,node,k,ev,name,emit,edge,group,by,0,reduce,group,new,apply,group,reduce,function,edges,function,name,group,reduce,on,in,and,out,edges,returns,type,info,default,throw,new,illegal,argument,exception,illegal,edge,direction
Graph -> public <T> DataSet<T> groupReduceOnEdges(EdgesFunction<K, EV, T> edgesFunction, 			EdgeDirection direction, TypeInformation<T> typeInfo) throws IllegalArgumentException;1489068942;Groups by vertex and computes a GroupReduce transformation over the edge values of each vertex._The edgesFunction applied on the edges only has access to the vertex id (not the vertex value)_of the grouping vertex.__For each vertex, the edgesFunction can iterate over all edges of this vertex_with the specified direction, and emit any number of output elements, including none.__@param edgesFunction the group reduce function to apply to the neighboring edges of each vertex._@param direction the edge direction (in-, out-, all-)._@param <T> the output type_@param typeInfo the explicit return type._@return a DataSet containing elements of type T_@throws IllegalArgumentException;public <T> DataSet<T> groupReduceOnEdges(EdgesFunction<K, EV, T> edgesFunction,_			EdgeDirection direction, TypeInformation<T> typeInfo) throws IllegalArgumentException {__		switch (direction) {_			case IN:_				return edges.map(new ProjectVertexIdMap<K, EV>(1)).name("Vertex ID")_						.withForwardedFields("f1->f0")_						.groupBy(0).reduceGroup(new ApplyGroupReduceFunction<>(edgesFunction))_							.name("GroupReduce on in-edges").returns(typeInfo)__			case OUT:_				return edges.map(new ProjectVertexIdMap<K, EV>(0)).name("Vertex ID")_						.withForwardedFields("f0")_						.groupBy(0).reduceGroup(new ApplyGroupReduceFunction<>(edgesFunction))_							.name("GroupReduce on out-edges").returns(typeInfo)__			case ALL:_				return edges.flatMap(new EmitOneEdgePerNode<K, EV>()).name("Emit edge")_						.groupBy(0).reduceGroup(new ApplyGroupReduceFunction<>(edgesFunction))_							.name("GroupReduce on in- and out-edges").returns(typeInfo)__			default:_				throw new IllegalArgumentException("Illegal edge direction")__		}_	};groups,by,vertex,and,computes,a,group,reduce,transformation,over,the,edge,values,of,each,vertex,the,edges,function,applied,on,the,edges,only,has,access,to,the,vertex,id,not,the,vertex,value,of,the,grouping,vertex,for,each,vertex,the,edges,function,can,iterate,over,all,edges,of,this,vertex,with,the,specified,direction,and,emit,any,number,of,output,elements,including,none,param,edges,function,the,group,reduce,function,to,apply,to,the,neighboring,edges,of,each,vertex,param,direction,the,edge,direction,in,out,all,param,t,the,output,type,param,type,info,the,explicit,return,type,return,a,data,set,containing,elements,of,type,t,throws,illegal,argument,exception;public,t,data,set,t,group,reduce,on,edges,edges,function,k,ev,t,edges,function,edge,direction,direction,type,information,t,type,info,throws,illegal,argument,exception,switch,direction,case,in,return,edges,map,new,project,vertex,id,map,k,ev,1,name,vertex,id,with,forwarded,fields,f1,f0,group,by,0,reduce,group,new,apply,group,reduce,function,edges,function,name,group,reduce,on,in,edges,returns,type,info,case,out,return,edges,map,new,project,vertex,id,map,k,ev,0,name,vertex,id,with,forwarded,fields,f0,group,by,0,reduce,group,new,apply,group,reduce,function,edges,function,name,group,reduce,on,out,edges,returns,type,info,case,all,return,edges,flat,map,new,emit,one,edge,per,node,k,ev,name,emit,edge,group,by,0,reduce,group,new,apply,group,reduce,function,edges,function,name,group,reduce,on,in,and,out,edges,returns,type,info,default,throw,new,illegal,argument,exception,illegal,edge,direction
Graph -> public <T> DataSet<T> groupReduceOnEdges(EdgesFunction<K, EV, T> edgesFunction, 			EdgeDirection direction, TypeInformation<T> typeInfo) throws IllegalArgumentException;1490973446;Groups by vertex and computes a GroupReduce transformation over the edge values of each vertex._The edgesFunction applied on the edges only has access to the vertex id (not the vertex value)_of the grouping vertex.__For each vertex, the edgesFunction can iterate over all edges of this vertex_with the specified direction, and emit any number of output elements, including none.__@param edgesFunction the group reduce function to apply to the neighboring edges of each vertex._@param direction the edge direction (in-, out-, all-)._@param <T> the output type_@param typeInfo the explicit return type._@return a DataSet containing elements of type T_@throws IllegalArgumentException;public <T> DataSet<T> groupReduceOnEdges(EdgesFunction<K, EV, T> edgesFunction,_			EdgeDirection direction, TypeInformation<T> typeInfo) throws IllegalArgumentException {__		switch (direction) {_			case IN:_				return edges.map(new ProjectVertexIdMap<K, EV>(1)).name("Vertex ID")_						.withForwardedFields("f1->f0")_						.groupBy(0).reduceGroup(new ApplyGroupReduceFunction<>(edgesFunction))_							.name("GroupReduce on in-edges").returns(typeInfo)__			case OUT:_				return edges.map(new ProjectVertexIdMap<K, EV>(0)).name("Vertex ID")_						.withForwardedFields("f0")_						.groupBy(0).reduceGroup(new ApplyGroupReduceFunction<>(edgesFunction))_							.name("GroupReduce on out-edges").returns(typeInfo)__			case ALL:_				return edges.flatMap(new EmitOneEdgePerNode<K, EV>()).name("Emit edge")_						.groupBy(0).reduceGroup(new ApplyGroupReduceFunction<>(edgesFunction))_							.name("GroupReduce on in- and out-edges").returns(typeInfo)__			default:_				throw new IllegalArgumentException("Illegal edge direction")__		}_	};groups,by,vertex,and,computes,a,group,reduce,transformation,over,the,edge,values,of,each,vertex,the,edges,function,applied,on,the,edges,only,has,access,to,the,vertex,id,not,the,vertex,value,of,the,grouping,vertex,for,each,vertex,the,edges,function,can,iterate,over,all,edges,of,this,vertex,with,the,specified,direction,and,emit,any,number,of,output,elements,including,none,param,edges,function,the,group,reduce,function,to,apply,to,the,neighboring,edges,of,each,vertex,param,direction,the,edge,direction,in,out,all,param,t,the,output,type,param,type,info,the,explicit,return,type,return,a,data,set,containing,elements,of,type,t,throws,illegal,argument,exception;public,t,data,set,t,group,reduce,on,edges,edges,function,k,ev,t,edges,function,edge,direction,direction,type,information,t,type,info,throws,illegal,argument,exception,switch,direction,case,in,return,edges,map,new,project,vertex,id,map,k,ev,1,name,vertex,id,with,forwarded,fields,f1,f0,group,by,0,reduce,group,new,apply,group,reduce,function,edges,function,name,group,reduce,on,in,edges,returns,type,info,case,out,return,edges,map,new,project,vertex,id,map,k,ev,0,name,vertex,id,with,forwarded,fields,f0,group,by,0,reduce,group,new,apply,group,reduce,function,edges,function,name,group,reduce,on,out,edges,returns,type,info,case,all,return,edges,flat,map,new,emit,one,edge,per,node,k,ev,name,emit,edge,group,by,0,reduce,group,new,apply,group,reduce,function,edges,function,name,group,reduce,on,in,and,out,edges,returns,type,info,default,throw,new,illegal,argument,exception,illegal,edge,direction
Graph -> public <T> DataSet<T> groupReduceOnEdges(EdgesFunction<K, EV, T> edgesFunction, 			EdgeDirection direction, TypeInformation<T> typeInfo) throws IllegalArgumentException;1495819075;Groups by vertex and computes a GroupReduce transformation over the edge values of each vertex._The edgesFunction applied on the edges only has access to the vertex id (not the vertex value)_of the grouping vertex.__<p>For each vertex, the edgesFunction can iterate over all edges of this vertex_with the specified direction, and emit any number of output elements, including none.__@param edgesFunction the group reduce function to apply to the neighboring edges of each vertex._@param direction the edge direction (in-, out-, all-)._@param <T> the output type_@param typeInfo the explicit return type._@return a DataSet containing elements of type T_@throws IllegalArgumentException;public <T> DataSet<T> groupReduceOnEdges(EdgesFunction<K, EV, T> edgesFunction,_			EdgeDirection direction, TypeInformation<T> typeInfo) throws IllegalArgumentException {__		switch (direction) {_			case IN:_				return edges.map(new ProjectVertexIdMap<K, EV>(1)).name("Vertex ID")_						.withForwardedFields("f1->f0")_						.groupBy(0).reduceGroup(new ApplyGroupReduceFunction<>(edgesFunction))_							.name("GroupReduce on in-edges").returns(typeInfo)__			case OUT:_				return edges.map(new ProjectVertexIdMap<K, EV>(0)).name("Vertex ID")_						.withForwardedFields("f0")_						.groupBy(0).reduceGroup(new ApplyGroupReduceFunction<>(edgesFunction))_							.name("GroupReduce on out-edges").returns(typeInfo)__			case ALL:_				return edges.flatMap(new EmitOneEdgePerNode<K, EV>()).name("Emit edge")_						.groupBy(0).reduceGroup(new ApplyGroupReduceFunction<>(edgesFunction))_							.name("GroupReduce on in- and out-edges").returns(typeInfo)__			default:_				throw new IllegalArgumentException("Illegal edge direction")__		}_	};groups,by,vertex,and,computes,a,group,reduce,transformation,over,the,edge,values,of,each,vertex,the,edges,function,applied,on,the,edges,only,has,access,to,the,vertex,id,not,the,vertex,value,of,the,grouping,vertex,p,for,each,vertex,the,edges,function,can,iterate,over,all,edges,of,this,vertex,with,the,specified,direction,and,emit,any,number,of,output,elements,including,none,param,edges,function,the,group,reduce,function,to,apply,to,the,neighboring,edges,of,each,vertex,param,direction,the,edge,direction,in,out,all,param,t,the,output,type,param,type,info,the,explicit,return,type,return,a,data,set,containing,elements,of,type,t,throws,illegal,argument,exception;public,t,data,set,t,group,reduce,on,edges,edges,function,k,ev,t,edges,function,edge,direction,direction,type,information,t,type,info,throws,illegal,argument,exception,switch,direction,case,in,return,edges,map,new,project,vertex,id,map,k,ev,1,name,vertex,id,with,forwarded,fields,f1,f0,group,by,0,reduce,group,new,apply,group,reduce,function,edges,function,name,group,reduce,on,in,edges,returns,type,info,case,out,return,edges,map,new,project,vertex,id,map,k,ev,0,name,vertex,id,with,forwarded,fields,f0,group,by,0,reduce,group,new,apply,group,reduce,function,edges,function,name,group,reduce,on,out,edges,returns,type,info,case,all,return,edges,flat,map,new,emit,one,edge,per,node,k,ev,name,emit,edge,group,by,0,reduce,group,new,apply,group,reduce,function,edges,function,name,group,reduce,on,in,and,out,edges,returns,type,info,default,throw,new,illegal,argument,exception,illegal,edge,direction
Graph -> public <T> DataSet<T> groupReduceOnEdges(EdgesFunction<K, EV, T> edgesFunction, 			EdgeDirection direction, TypeInformation<T> typeInfo) throws IllegalArgumentException;1502111816;Groups by vertex and computes a GroupReduce transformation over the edge values of each vertex._The edgesFunction applied on the edges only has access to the vertex id (not the vertex value)_of the grouping vertex.__<p>For each vertex, the edgesFunction can iterate over all edges of this vertex_with the specified direction, and emit any number of output elements, including none.__@param edgesFunction the group reduce function to apply to the neighboring edges of each vertex._@param direction the edge direction (in-, out-, all-)._@param <T> the output type_@param typeInfo the explicit return type._@return a DataSet containing elements of type T_@throws IllegalArgumentException;public <T> DataSet<T> groupReduceOnEdges(EdgesFunction<K, EV, T> edgesFunction,_			EdgeDirection direction, TypeInformation<T> typeInfo) throws IllegalArgumentException {__		switch (direction) {_			case IN:_				return edges.map(new ProjectVertexIdMap<>(1)).name("Vertex ID")_						.withForwardedFields("f1->f0")_						.groupBy(0).reduceGroup(new ApplyGroupReduceFunction<>(edgesFunction))_							.name("GroupReduce on in-edges").returns(typeInfo)__			case OUT:_				return edges.map(new ProjectVertexIdMap<>(0)).name("Vertex ID")_						.withForwardedFields("f0")_						.groupBy(0).reduceGroup(new ApplyGroupReduceFunction<>(edgesFunction))_							.name("GroupReduce on out-edges").returns(typeInfo)__			case ALL:_				return edges.flatMap(new EmitOneEdgePerNode<>()).name("Emit edge")_						.groupBy(0).reduceGroup(new ApplyGroupReduceFunction<>(edgesFunction))_							.name("GroupReduce on in- and out-edges").returns(typeInfo)__			default:_				throw new IllegalArgumentException("Illegal edge direction")__		}_	};groups,by,vertex,and,computes,a,group,reduce,transformation,over,the,edge,values,of,each,vertex,the,edges,function,applied,on,the,edges,only,has,access,to,the,vertex,id,not,the,vertex,value,of,the,grouping,vertex,p,for,each,vertex,the,edges,function,can,iterate,over,all,edges,of,this,vertex,with,the,specified,direction,and,emit,any,number,of,output,elements,including,none,param,edges,function,the,group,reduce,function,to,apply,to,the,neighboring,edges,of,each,vertex,param,direction,the,edge,direction,in,out,all,param,t,the,output,type,param,type,info,the,explicit,return,type,return,a,data,set,containing,elements,of,type,t,throws,illegal,argument,exception;public,t,data,set,t,group,reduce,on,edges,edges,function,k,ev,t,edges,function,edge,direction,direction,type,information,t,type,info,throws,illegal,argument,exception,switch,direction,case,in,return,edges,map,new,project,vertex,id,map,1,name,vertex,id,with,forwarded,fields,f1,f0,group,by,0,reduce,group,new,apply,group,reduce,function,edges,function,name,group,reduce,on,in,edges,returns,type,info,case,out,return,edges,map,new,project,vertex,id,map,0,name,vertex,id,with,forwarded,fields,f0,group,by,0,reduce,group,new,apply,group,reduce,function,edges,function,name,group,reduce,on,out,edges,returns,type,info,case,all,return,edges,flat,map,new,emit,one,edge,per,node,name,emit,edge,group,by,0,reduce,group,new,apply,group,reduce,function,edges,function,name,group,reduce,on,in,and,out,edges,returns,type,info,default,throw,new,illegal,argument,exception,illegal,edge,direction
Graph -> public <T> DataSet<T> groupReduceOnNeighbors(NeighborsFunctionWithVertexValue<K, VV, EV, T> neighborsFunction, 			EdgeDirection direction, TypeInformation<T> typeInfo) throws IllegalArgumentException;1445261977;Groups by vertex and computes a GroupReduce transformation over the neighbors (both edges and vertices)_of each vertex. The neighborsFunction applied on the neighbors only has access to both the vertex id_and the vertex value of the grouping vertex.__For each vertex, the neighborsFunction can iterate over all neighbors of this vertex_with the specified direction, and emit any number of output elements, including none.__@param neighborsFunction the group reduce function to apply to the neighboring edges and vertices_of each vertex._@param direction the edge direction (in-, out-, all-)._@param <T> the output type_@param typeInfo the explicit return type_@return a DataSet containing elements of type T_@throws IllegalArgumentException;public <T> DataSet<T> groupReduceOnNeighbors(NeighborsFunctionWithVertexValue<K, VV, EV, T> neighborsFunction,_			EdgeDirection direction, TypeInformation<T> typeInfo) throws IllegalArgumentException {_		switch (direction) {_			case IN:_				_				DataSet<Tuple2<Edge<K, EV>, Vertex<K, VV>>> edgesWithSources = edges_						.join(this.vertices).where(0).equalTo(0)__				return vertices.coGroup(edgesWithSources)_						.where(0).equalTo("f0.f1")_						.with(new ApplyNeighborCoGroupFunction<K, VV, EV, T>(neighborsFunction)).returns(typeInfo)__			case OUT:_				_				DataSet<Tuple2<Edge<K, EV>, Vertex<K, VV>>> edgesWithTargets = edges_						.join(this.vertices).where(1).equalTo(0)__				return vertices.coGroup(edgesWithTargets)_						.where(0).equalTo("f0.f0")_						.with(new ApplyNeighborCoGroupFunction<K, VV, EV, T>(neighborsFunction)).returns(typeInfo)__			case ALL:_				_				DataSet<Tuple3<K, Edge<K, EV>, Vertex<K, VV>>> edgesWithNeighbors = edges_						.flatMap(new EmitOneEdgeWithNeighborPerNode<K, EV>())_						.join(this.vertices).where(1).equalTo(0)_						.with(new ProjectEdgeWithNeighbor<K, VV, EV>())___				return vertices.coGroup(edgesWithNeighbors)_						.where(0).equalTo(0)_						.with(new ApplyCoGroupFunctionOnAllNeighbors<K, VV, EV, T>(neighborsFunction)).returns(typeInfo)__			default:_				throw new IllegalArgumentException("Illegal edge direction")__		}_	};groups,by,vertex,and,computes,a,group,reduce,transformation,over,the,neighbors,both,edges,and,vertices,of,each,vertex,the,neighbors,function,applied,on,the,neighbors,only,has,access,to,both,the,vertex,id,and,the,vertex,value,of,the,grouping,vertex,for,each,vertex,the,neighbors,function,can,iterate,over,all,neighbors,of,this,vertex,with,the,specified,direction,and,emit,any,number,of,output,elements,including,none,param,neighbors,function,the,group,reduce,function,to,apply,to,the,neighboring,edges,and,vertices,of,each,vertex,param,direction,the,edge,direction,in,out,all,param,t,the,output,type,param,type,info,the,explicit,return,type,return,a,data,set,containing,elements,of,type,t,throws,illegal,argument,exception;public,t,data,set,t,group,reduce,on,neighbors,neighbors,function,with,vertex,value,k,vv,ev,t,neighbors,function,edge,direction,direction,type,information,t,type,info,throws,illegal,argument,exception,switch,direction,case,in,data,set,tuple2,edge,k,ev,vertex,k,vv,edges,with,sources,edges,join,this,vertices,where,0,equal,to,0,return,vertices,co,group,edges,with,sources,where,0,equal,to,f0,f1,with,new,apply,neighbor,co,group,function,k,vv,ev,t,neighbors,function,returns,type,info,case,out,data,set,tuple2,edge,k,ev,vertex,k,vv,edges,with,targets,edges,join,this,vertices,where,1,equal,to,0,return,vertices,co,group,edges,with,targets,where,0,equal,to,f0,f0,with,new,apply,neighbor,co,group,function,k,vv,ev,t,neighbors,function,returns,type,info,case,all,data,set,tuple3,k,edge,k,ev,vertex,k,vv,edges,with,neighbors,edges,flat,map,new,emit,one,edge,with,neighbor,per,node,k,ev,join,this,vertices,where,1,equal,to,0,with,new,project,edge,with,neighbor,k,vv,ev,return,vertices,co,group,edges,with,neighbors,where,0,equal,to,0,with,new,apply,co,group,function,on,all,neighbors,k,vv,ev,t,neighbors,function,returns,type,info,default,throw,new,illegal,argument,exception,illegal,edge,direction
Graph -> public <T> DataSet<T> groupReduceOnNeighbors(NeighborsFunctionWithVertexValue<K, VV, EV, T> neighborsFunction, 			EdgeDirection direction, TypeInformation<T> typeInfo) throws IllegalArgumentException;1445854323;Groups by vertex and computes a GroupReduce transformation over the neighbors (both edges and vertices)_of each vertex. The neighborsFunction applied on the neighbors only has access to both the vertex id_and the vertex value of the grouping vertex.__For each vertex, the neighborsFunction can iterate over all neighbors of this vertex_with the specified direction, and emit any number of output elements, including none.__@param neighborsFunction the group reduce function to apply to the neighboring edges and vertices_of each vertex._@param direction the edge direction (in-, out-, all-)._@param <T> the output type_@param typeInfo the explicit return type_@return a DataSet containing elements of type T_@throws IllegalArgumentException;public <T> DataSet<T> groupReduceOnNeighbors(NeighborsFunctionWithVertexValue<K, VV, EV, T> neighborsFunction,_			EdgeDirection direction, TypeInformation<T> typeInfo) throws IllegalArgumentException {_		switch (direction) {_			case IN:_				_				DataSet<Tuple2<Edge<K, EV>, Vertex<K, VV>>> edgesWithSources = edges_						.join(this.vertices).where(0).equalTo(0)__				return vertices.coGroup(edgesWithSources)_						.where(0).equalTo("f0.f1")_						.with(new ApplyNeighborCoGroupFunction<K, VV, EV, T>(neighborsFunction)).returns(typeInfo)__			case OUT:_				_				DataSet<Tuple2<Edge<K, EV>, Vertex<K, VV>>> edgesWithTargets = edges_						.join(this.vertices).where(1).equalTo(0)__				return vertices.coGroup(edgesWithTargets)_						.where(0).equalTo("f0.f0")_						.with(new ApplyNeighborCoGroupFunction<K, VV, EV, T>(neighborsFunction)).returns(typeInfo)__			case ALL:_				_				DataSet<Tuple3<K, Edge<K, EV>, Vertex<K, VV>>> edgesWithNeighbors = edges_						.flatMap(new EmitOneEdgeWithNeighborPerNode<K, EV>())_						.join(this.vertices).where(1).equalTo(0)_						.with(new ProjectEdgeWithNeighbor<K, VV, EV>())___				return vertices.coGroup(edgesWithNeighbors)_						.where(0).equalTo(0)_						.with(new ApplyCoGroupFunctionOnAllNeighbors<K, VV, EV, T>(neighborsFunction)).returns(typeInfo)__			default:_				throw new IllegalArgumentException("Illegal edge direction")__		}_	};groups,by,vertex,and,computes,a,group,reduce,transformation,over,the,neighbors,both,edges,and,vertices,of,each,vertex,the,neighbors,function,applied,on,the,neighbors,only,has,access,to,both,the,vertex,id,and,the,vertex,value,of,the,grouping,vertex,for,each,vertex,the,neighbors,function,can,iterate,over,all,neighbors,of,this,vertex,with,the,specified,direction,and,emit,any,number,of,output,elements,including,none,param,neighbors,function,the,group,reduce,function,to,apply,to,the,neighboring,edges,and,vertices,of,each,vertex,param,direction,the,edge,direction,in,out,all,param,t,the,output,type,param,type,info,the,explicit,return,type,return,a,data,set,containing,elements,of,type,t,throws,illegal,argument,exception;public,t,data,set,t,group,reduce,on,neighbors,neighbors,function,with,vertex,value,k,vv,ev,t,neighbors,function,edge,direction,direction,type,information,t,type,info,throws,illegal,argument,exception,switch,direction,case,in,data,set,tuple2,edge,k,ev,vertex,k,vv,edges,with,sources,edges,join,this,vertices,where,0,equal,to,0,return,vertices,co,group,edges,with,sources,where,0,equal,to,f0,f1,with,new,apply,neighbor,co,group,function,k,vv,ev,t,neighbors,function,returns,type,info,case,out,data,set,tuple2,edge,k,ev,vertex,k,vv,edges,with,targets,edges,join,this,vertices,where,1,equal,to,0,return,vertices,co,group,edges,with,targets,where,0,equal,to,f0,f0,with,new,apply,neighbor,co,group,function,k,vv,ev,t,neighbors,function,returns,type,info,case,all,data,set,tuple3,k,edge,k,ev,vertex,k,vv,edges,with,neighbors,edges,flat,map,new,emit,one,edge,with,neighbor,per,node,k,ev,join,this,vertices,where,1,equal,to,0,with,new,project,edge,with,neighbor,k,vv,ev,return,vertices,co,group,edges,with,neighbors,where,0,equal,to,0,with,new,apply,co,group,function,on,all,neighbors,k,vv,ev,t,neighbors,function,returns,type,info,default,throw,new,illegal,argument,exception,illegal,edge,direction
Graph -> public <T> DataSet<T> groupReduceOnNeighbors(NeighborsFunctionWithVertexValue<K, VV, EV, T> neighborsFunction, 			EdgeDirection direction, TypeInformation<T> typeInfo) throws IllegalArgumentException;1446112342;Groups by vertex and computes a GroupReduce transformation over the neighbors (both edges and vertices)_of each vertex. The neighborsFunction applied on the neighbors only has access to both the vertex id_and the vertex value of the grouping vertex.__For each vertex, the neighborsFunction can iterate over all neighbors of this vertex_with the specified direction, and emit any number of output elements, including none.__@param neighborsFunction the group reduce function to apply to the neighboring edges and vertices_of each vertex._@param direction the edge direction (in-, out-, all-)._@param <T> the output type_@param typeInfo the explicit return type_@return a DataSet containing elements of type T_@throws IllegalArgumentException;public <T> DataSet<T> groupReduceOnNeighbors(NeighborsFunctionWithVertexValue<K, VV, EV, T> neighborsFunction,_			EdgeDirection direction, TypeInformation<T> typeInfo) throws IllegalArgumentException {_		switch (direction) {_			case IN:_				_				DataSet<Tuple2<Edge<K, EV>, Vertex<K, VV>>> edgesWithSources = edges_						.join(this.vertices).where(0).equalTo(0)__				return vertices.coGroup(edgesWithSources)_						.where(0).equalTo("f0.f1")_						.with(new ApplyNeighborCoGroupFunction<K, VV, EV, T>(neighborsFunction)).returns(typeInfo)__			case OUT:_				_				DataSet<Tuple2<Edge<K, EV>, Vertex<K, VV>>> edgesWithTargets = edges_						.join(this.vertices).where(1).equalTo(0)__				return vertices.coGroup(edgesWithTargets)_						.where(0).equalTo("f0.f0")_						.with(new ApplyNeighborCoGroupFunction<K, VV, EV, T>(neighborsFunction)).returns(typeInfo)__			case ALL:_				_				DataSet<Tuple3<K, Edge<K, EV>, Vertex<K, VV>>> edgesWithNeighbors = edges_						.flatMap(new EmitOneEdgeWithNeighborPerNode<K, EV>())_						.join(this.vertices).where(1).equalTo(0)_						.with(new ProjectEdgeWithNeighbor<K, VV, EV>())___				return vertices.coGroup(edgesWithNeighbors)_						.where(0).equalTo(0)_						.with(new ApplyCoGroupFunctionOnAllNeighbors<K, VV, EV, T>(neighborsFunction)).returns(typeInfo)__			default:_				throw new IllegalArgumentException("Illegal edge direction")__		}_	};groups,by,vertex,and,computes,a,group,reduce,transformation,over,the,neighbors,both,edges,and,vertices,of,each,vertex,the,neighbors,function,applied,on,the,neighbors,only,has,access,to,both,the,vertex,id,and,the,vertex,value,of,the,grouping,vertex,for,each,vertex,the,neighbors,function,can,iterate,over,all,neighbors,of,this,vertex,with,the,specified,direction,and,emit,any,number,of,output,elements,including,none,param,neighbors,function,the,group,reduce,function,to,apply,to,the,neighboring,edges,and,vertices,of,each,vertex,param,direction,the,edge,direction,in,out,all,param,t,the,output,type,param,type,info,the,explicit,return,type,return,a,data,set,containing,elements,of,type,t,throws,illegal,argument,exception;public,t,data,set,t,group,reduce,on,neighbors,neighbors,function,with,vertex,value,k,vv,ev,t,neighbors,function,edge,direction,direction,type,information,t,type,info,throws,illegal,argument,exception,switch,direction,case,in,data,set,tuple2,edge,k,ev,vertex,k,vv,edges,with,sources,edges,join,this,vertices,where,0,equal,to,0,return,vertices,co,group,edges,with,sources,where,0,equal,to,f0,f1,with,new,apply,neighbor,co,group,function,k,vv,ev,t,neighbors,function,returns,type,info,case,out,data,set,tuple2,edge,k,ev,vertex,k,vv,edges,with,targets,edges,join,this,vertices,where,1,equal,to,0,return,vertices,co,group,edges,with,targets,where,0,equal,to,f0,f0,with,new,apply,neighbor,co,group,function,k,vv,ev,t,neighbors,function,returns,type,info,case,all,data,set,tuple3,k,edge,k,ev,vertex,k,vv,edges,with,neighbors,edges,flat,map,new,emit,one,edge,with,neighbor,per,node,k,ev,join,this,vertices,where,1,equal,to,0,with,new,project,edge,with,neighbor,k,vv,ev,return,vertices,co,group,edges,with,neighbors,where,0,equal,to,0,with,new,apply,co,group,function,on,all,neighbors,k,vv,ev,t,neighbors,function,returns,type,info,default,throw,new,illegal,argument,exception,illegal,edge,direction
Graph -> public <T> DataSet<T> groupReduceOnNeighbors(NeighborsFunctionWithVertexValue<K, VV, EV, T> neighborsFunction, 			EdgeDirection direction, TypeInformation<T> typeInfo) throws IllegalArgumentException;1447073368;Groups by vertex and computes a GroupReduce transformation over the neighbors (both edges and vertices)_of each vertex. The neighborsFunction applied on the neighbors only has access to both the vertex id_and the vertex value of the grouping vertex.__For each vertex, the neighborsFunction can iterate over all neighbors of this vertex_with the specified direction, and emit any number of output elements, including none.__@param neighborsFunction the group reduce function to apply to the neighboring edges and vertices_of each vertex._@param direction the edge direction (in-, out-, all-)._@param <T> the output type_@param typeInfo the explicit return type_@return a DataSet containing elements of type T_@throws IllegalArgumentException;public <T> DataSet<T> groupReduceOnNeighbors(NeighborsFunctionWithVertexValue<K, VV, EV, T> neighborsFunction,_			EdgeDirection direction, TypeInformation<T> typeInfo) throws IllegalArgumentException {_		switch (direction) {_			case IN:_				_				DataSet<Tuple2<Edge<K, EV>, Vertex<K, VV>>> edgesWithSources = edges_						.join(this.vertices).where(0).equalTo(0)__				return vertices.coGroup(edgesWithSources)_						.where(0).equalTo("f0.f1")_						.with(new ApplyNeighborCoGroupFunction<K, VV, EV, T>(neighborsFunction)).returns(typeInfo)__			case OUT:_				_				DataSet<Tuple2<Edge<K, EV>, Vertex<K, VV>>> edgesWithTargets = edges_						.join(this.vertices).where(1).equalTo(0)__				return vertices.coGroup(edgesWithTargets)_						.where(0).equalTo("f0.f0")_						.with(new ApplyNeighborCoGroupFunction<K, VV, EV, T>(neighborsFunction)).returns(typeInfo)__			case ALL:_				_				DataSet<Tuple3<K, Edge<K, EV>, Vertex<K, VV>>> edgesWithNeighbors = edges_						.flatMap(new EmitOneEdgeWithNeighborPerNode<K, EV>())_						.join(this.vertices).where(1).equalTo(0)_						.with(new ProjectEdgeWithNeighbor<K, VV, EV>())___				return vertices.coGroup(edgesWithNeighbors)_						.where(0).equalTo(0)_						.with(new ApplyCoGroupFunctionOnAllNeighbors<K, VV, EV, T>(neighborsFunction)).returns(typeInfo)__			default:_				throw new IllegalArgumentException("Illegal edge direction")__		}_	};groups,by,vertex,and,computes,a,group,reduce,transformation,over,the,neighbors,both,edges,and,vertices,of,each,vertex,the,neighbors,function,applied,on,the,neighbors,only,has,access,to,both,the,vertex,id,and,the,vertex,value,of,the,grouping,vertex,for,each,vertex,the,neighbors,function,can,iterate,over,all,neighbors,of,this,vertex,with,the,specified,direction,and,emit,any,number,of,output,elements,including,none,param,neighbors,function,the,group,reduce,function,to,apply,to,the,neighboring,edges,and,vertices,of,each,vertex,param,direction,the,edge,direction,in,out,all,param,t,the,output,type,param,type,info,the,explicit,return,type,return,a,data,set,containing,elements,of,type,t,throws,illegal,argument,exception;public,t,data,set,t,group,reduce,on,neighbors,neighbors,function,with,vertex,value,k,vv,ev,t,neighbors,function,edge,direction,direction,type,information,t,type,info,throws,illegal,argument,exception,switch,direction,case,in,data,set,tuple2,edge,k,ev,vertex,k,vv,edges,with,sources,edges,join,this,vertices,where,0,equal,to,0,return,vertices,co,group,edges,with,sources,where,0,equal,to,f0,f1,with,new,apply,neighbor,co,group,function,k,vv,ev,t,neighbors,function,returns,type,info,case,out,data,set,tuple2,edge,k,ev,vertex,k,vv,edges,with,targets,edges,join,this,vertices,where,1,equal,to,0,return,vertices,co,group,edges,with,targets,where,0,equal,to,f0,f0,with,new,apply,neighbor,co,group,function,k,vv,ev,t,neighbors,function,returns,type,info,case,all,data,set,tuple3,k,edge,k,ev,vertex,k,vv,edges,with,neighbors,edges,flat,map,new,emit,one,edge,with,neighbor,per,node,k,ev,join,this,vertices,where,1,equal,to,0,with,new,project,edge,with,neighbor,k,vv,ev,return,vertices,co,group,edges,with,neighbors,where,0,equal,to,0,with,new,apply,co,group,function,on,all,neighbors,k,vv,ev,t,neighbors,function,returns,type,info,default,throw,new,illegal,argument,exception,illegal,edge,direction
Graph -> public <T> DataSet<T> groupReduceOnNeighbors(NeighborsFunctionWithVertexValue<K, VV, EV, T> neighborsFunction, 			EdgeDirection direction, TypeInformation<T> typeInfo) throws IllegalArgumentException;1454404649;Groups by vertex and computes a GroupReduce transformation over the neighbors (both edges and vertices)_of each vertex. The neighborsFunction applied on the neighbors only has access to both the vertex id_and the vertex value of the grouping vertex.__For each vertex, the neighborsFunction can iterate over all neighbors of this vertex_with the specified direction, and emit any number of output elements, including none.__@param neighborsFunction the group reduce function to apply to the neighboring edges and vertices_of each vertex._@param direction the edge direction (in-, out-, all-)._@param <T> the output type_@param typeInfo the explicit return type_@return a DataSet containing elements of type T_@throws IllegalArgumentException;public <T> DataSet<T> groupReduceOnNeighbors(NeighborsFunctionWithVertexValue<K, VV, EV, T> neighborsFunction,_			EdgeDirection direction, TypeInformation<T> typeInfo) throws IllegalArgumentException {_		switch (direction) {_			case IN:_				_				DataSet<Tuple2<Edge<K, EV>, Vertex<K, VV>>> edgesWithSources = edges_						.join(this.vertices).where(0).equalTo(0)__				return vertices.coGroup(edgesWithSources)_						.where(0).equalTo("f0.f1")_						.with(new ApplyNeighborCoGroupFunction<K, VV, EV, T>(neighborsFunction)).returns(typeInfo)__			case OUT:_				_				DataSet<Tuple2<Edge<K, EV>, Vertex<K, VV>>> edgesWithTargets = edges_						.join(this.vertices).where(1).equalTo(0)__				return vertices.coGroup(edgesWithTargets)_						.where(0).equalTo("f0.f0")_						.with(new ApplyNeighborCoGroupFunction<K, VV, EV, T>(neighborsFunction)).returns(typeInfo)__			case ALL:_				_				DataSet<Tuple3<K, Edge<K, EV>, Vertex<K, VV>>> edgesWithNeighbors = edges_						.flatMap(new EmitOneEdgeWithNeighborPerNode<K, EV>())_						.join(this.vertices).where(1).equalTo(0)_						.with(new ProjectEdgeWithNeighbor<K, VV, EV>())___				return vertices.coGroup(edgesWithNeighbors)_						.where(0).equalTo(0)_						.with(new ApplyCoGroupFunctionOnAllNeighbors<K, VV, EV, T>(neighborsFunction)).returns(typeInfo)__			default:_				throw new IllegalArgumentException("Illegal edge direction")__		}_	};groups,by,vertex,and,computes,a,group,reduce,transformation,over,the,neighbors,both,edges,and,vertices,of,each,vertex,the,neighbors,function,applied,on,the,neighbors,only,has,access,to,both,the,vertex,id,and,the,vertex,value,of,the,grouping,vertex,for,each,vertex,the,neighbors,function,can,iterate,over,all,neighbors,of,this,vertex,with,the,specified,direction,and,emit,any,number,of,output,elements,including,none,param,neighbors,function,the,group,reduce,function,to,apply,to,the,neighboring,edges,and,vertices,of,each,vertex,param,direction,the,edge,direction,in,out,all,param,t,the,output,type,param,type,info,the,explicit,return,type,return,a,data,set,containing,elements,of,type,t,throws,illegal,argument,exception;public,t,data,set,t,group,reduce,on,neighbors,neighbors,function,with,vertex,value,k,vv,ev,t,neighbors,function,edge,direction,direction,type,information,t,type,info,throws,illegal,argument,exception,switch,direction,case,in,data,set,tuple2,edge,k,ev,vertex,k,vv,edges,with,sources,edges,join,this,vertices,where,0,equal,to,0,return,vertices,co,group,edges,with,sources,where,0,equal,to,f0,f1,with,new,apply,neighbor,co,group,function,k,vv,ev,t,neighbors,function,returns,type,info,case,out,data,set,tuple2,edge,k,ev,vertex,k,vv,edges,with,targets,edges,join,this,vertices,where,1,equal,to,0,return,vertices,co,group,edges,with,targets,where,0,equal,to,f0,f0,with,new,apply,neighbor,co,group,function,k,vv,ev,t,neighbors,function,returns,type,info,case,all,data,set,tuple3,k,edge,k,ev,vertex,k,vv,edges,with,neighbors,edges,flat,map,new,emit,one,edge,with,neighbor,per,node,k,ev,join,this,vertices,where,1,equal,to,0,with,new,project,edge,with,neighbor,k,vv,ev,return,vertices,co,group,edges,with,neighbors,where,0,equal,to,0,with,new,apply,co,group,function,on,all,neighbors,k,vv,ev,t,neighbors,function,returns,type,info,default,throw,new,illegal,argument,exception,illegal,edge,direction
Graph -> public <T> DataSet<T> groupReduceOnNeighbors(NeighborsFunctionWithVertexValue<K, VV, EV, T> neighborsFunction, 			EdgeDirection direction, TypeInformation<T> typeInfo) throws IllegalArgumentException;1458583829;Groups by vertex and computes a GroupReduce transformation over the neighbors (both edges and vertices)_of each vertex. The neighborsFunction applied on the neighbors only has access to both the vertex id_and the vertex value of the grouping vertex.__For each vertex, the neighborsFunction can iterate over all neighbors of this vertex_with the specified direction, and emit any number of output elements, including none.__@param neighborsFunction the group reduce function to apply to the neighboring edges and vertices_of each vertex._@param direction the edge direction (in-, out-, all-)._@param <T> the output type_@param typeInfo the explicit return type_@return a DataSet containing elements of type T_@throws IllegalArgumentException;public <T> DataSet<T> groupReduceOnNeighbors(NeighborsFunctionWithVertexValue<K, VV, EV, T> neighborsFunction,_			EdgeDirection direction, TypeInformation<T> typeInfo) throws IllegalArgumentException {_		switch (direction) {_			case IN:_				_				DataSet<Tuple2<Edge<K, EV>, Vertex<K, VV>>> edgesWithSources = edges_						.join(this.vertices).where(0).equalTo(0)__				return vertices.coGroup(edgesWithSources)_						.where(0).equalTo("f0.f1")_						.with(new ApplyNeighborCoGroupFunction<K, VV, EV, T>(neighborsFunction)).returns(typeInfo)__			case OUT:_				_				DataSet<Tuple2<Edge<K, EV>, Vertex<K, VV>>> edgesWithTargets = edges_						.join(this.vertices).where(1).equalTo(0)__				return vertices.coGroup(edgesWithTargets)_						.where(0).equalTo("f0.f0")_						.with(new ApplyNeighborCoGroupFunction<K, VV, EV, T>(neighborsFunction)).returns(typeInfo)__			case ALL:_				_				DataSet<Tuple3<K, Edge<K, EV>, Vertex<K, VV>>> edgesWithNeighbors = edges_						.flatMap(new EmitOneEdgeWithNeighborPerNode<K, EV>())_						.join(this.vertices).where(1).equalTo(0)_						.with(new ProjectEdgeWithNeighbor<K, VV, EV>())___				return vertices.coGroup(edgesWithNeighbors)_						.where(0).equalTo(0)_						.with(new ApplyCoGroupFunctionOnAllNeighbors<K, VV, EV, T>(neighborsFunction)).returns(typeInfo)__			default:_				throw new IllegalArgumentException("Illegal edge direction")__		}_	};groups,by,vertex,and,computes,a,group,reduce,transformation,over,the,neighbors,both,edges,and,vertices,of,each,vertex,the,neighbors,function,applied,on,the,neighbors,only,has,access,to,both,the,vertex,id,and,the,vertex,value,of,the,grouping,vertex,for,each,vertex,the,neighbors,function,can,iterate,over,all,neighbors,of,this,vertex,with,the,specified,direction,and,emit,any,number,of,output,elements,including,none,param,neighbors,function,the,group,reduce,function,to,apply,to,the,neighboring,edges,and,vertices,of,each,vertex,param,direction,the,edge,direction,in,out,all,param,t,the,output,type,param,type,info,the,explicit,return,type,return,a,data,set,containing,elements,of,type,t,throws,illegal,argument,exception;public,t,data,set,t,group,reduce,on,neighbors,neighbors,function,with,vertex,value,k,vv,ev,t,neighbors,function,edge,direction,direction,type,information,t,type,info,throws,illegal,argument,exception,switch,direction,case,in,data,set,tuple2,edge,k,ev,vertex,k,vv,edges,with,sources,edges,join,this,vertices,where,0,equal,to,0,return,vertices,co,group,edges,with,sources,where,0,equal,to,f0,f1,with,new,apply,neighbor,co,group,function,k,vv,ev,t,neighbors,function,returns,type,info,case,out,data,set,tuple2,edge,k,ev,vertex,k,vv,edges,with,targets,edges,join,this,vertices,where,1,equal,to,0,return,vertices,co,group,edges,with,targets,where,0,equal,to,f0,f0,with,new,apply,neighbor,co,group,function,k,vv,ev,t,neighbors,function,returns,type,info,case,all,data,set,tuple3,k,edge,k,ev,vertex,k,vv,edges,with,neighbors,edges,flat,map,new,emit,one,edge,with,neighbor,per,node,k,ev,join,this,vertices,where,1,equal,to,0,with,new,project,edge,with,neighbor,k,vv,ev,return,vertices,co,group,edges,with,neighbors,where,0,equal,to,0,with,new,apply,co,group,function,on,all,neighbors,k,vv,ev,t,neighbors,function,returns,type,info,default,throw,new,illegal,argument,exception,illegal,edge,direction
Graph -> public <T> DataSet<T> groupReduceOnNeighbors(NeighborsFunctionWithVertexValue<K, VV, EV, T> neighborsFunction, 			EdgeDirection direction, TypeInformation<T> typeInfo) throws IllegalArgumentException;1458583829;Groups by vertex and computes a GroupReduce transformation over the neighbors (both edges and vertices)_of each vertex. The neighborsFunction applied on the neighbors only has access to both the vertex id_and the vertex value of the grouping vertex.__For each vertex, the neighborsFunction can iterate over all neighbors of this vertex_with the specified direction, and emit any number of output elements, including none.__@param neighborsFunction the group reduce function to apply to the neighboring edges and vertices_of each vertex._@param direction the edge direction (in-, out-, all-)._@param <T> the output type_@param typeInfo the explicit return type_@return a DataSet containing elements of type T_@throws IllegalArgumentException;public <T> DataSet<T> groupReduceOnNeighbors(NeighborsFunctionWithVertexValue<K, VV, EV, T> neighborsFunction,_			EdgeDirection direction, TypeInformation<T> typeInfo) throws IllegalArgumentException {_		switch (direction) {_			case IN:_				_				DataSet<Tuple2<Edge<K, EV>, Vertex<K, VV>>> edgesWithSources = edges_						.join(this.vertices).where(0).equalTo(0)__				return vertices.coGroup(edgesWithSources)_						.where(0).equalTo("f0.f1")_						.with(new ApplyNeighborCoGroupFunction<K, VV, EV, T>(neighborsFunction)).returns(typeInfo)__			case OUT:_				_				DataSet<Tuple2<Edge<K, EV>, Vertex<K, VV>>> edgesWithTargets = edges_						.join(this.vertices).where(1).equalTo(0)__				return vertices.coGroup(edgesWithTargets)_						.where(0).equalTo("f0.f0")_						.with(new ApplyNeighborCoGroupFunction<K, VV, EV, T>(neighborsFunction)).returns(typeInfo)__			case ALL:_				_				DataSet<Tuple3<K, Edge<K, EV>, Vertex<K, VV>>> edgesWithNeighbors = edges_						.flatMap(new EmitOneEdgeWithNeighborPerNode<K, EV>())_						.join(this.vertices).where(1).equalTo(0)_						.with(new ProjectEdgeWithNeighbor<K, VV, EV>())___				return vertices.coGroup(edgesWithNeighbors)_						.where(0).equalTo(0)_						.with(new ApplyCoGroupFunctionOnAllNeighbors<K, VV, EV, T>(neighborsFunction)).returns(typeInfo)__			default:_				throw new IllegalArgumentException("Illegal edge direction")__		}_	};groups,by,vertex,and,computes,a,group,reduce,transformation,over,the,neighbors,both,edges,and,vertices,of,each,vertex,the,neighbors,function,applied,on,the,neighbors,only,has,access,to,both,the,vertex,id,and,the,vertex,value,of,the,grouping,vertex,for,each,vertex,the,neighbors,function,can,iterate,over,all,neighbors,of,this,vertex,with,the,specified,direction,and,emit,any,number,of,output,elements,including,none,param,neighbors,function,the,group,reduce,function,to,apply,to,the,neighboring,edges,and,vertices,of,each,vertex,param,direction,the,edge,direction,in,out,all,param,t,the,output,type,param,type,info,the,explicit,return,type,return,a,data,set,containing,elements,of,type,t,throws,illegal,argument,exception;public,t,data,set,t,group,reduce,on,neighbors,neighbors,function,with,vertex,value,k,vv,ev,t,neighbors,function,edge,direction,direction,type,information,t,type,info,throws,illegal,argument,exception,switch,direction,case,in,data,set,tuple2,edge,k,ev,vertex,k,vv,edges,with,sources,edges,join,this,vertices,where,0,equal,to,0,return,vertices,co,group,edges,with,sources,where,0,equal,to,f0,f1,with,new,apply,neighbor,co,group,function,k,vv,ev,t,neighbors,function,returns,type,info,case,out,data,set,tuple2,edge,k,ev,vertex,k,vv,edges,with,targets,edges,join,this,vertices,where,1,equal,to,0,return,vertices,co,group,edges,with,targets,where,0,equal,to,f0,f0,with,new,apply,neighbor,co,group,function,k,vv,ev,t,neighbors,function,returns,type,info,case,all,data,set,tuple3,k,edge,k,ev,vertex,k,vv,edges,with,neighbors,edges,flat,map,new,emit,one,edge,with,neighbor,per,node,k,ev,join,this,vertices,where,1,equal,to,0,with,new,project,edge,with,neighbor,k,vv,ev,return,vertices,co,group,edges,with,neighbors,where,0,equal,to,0,with,new,apply,co,group,function,on,all,neighbors,k,vv,ev,t,neighbors,function,returns,type,info,default,throw,new,illegal,argument,exception,illegal,edge,direction
Graph -> public <T> DataSet<T> groupReduceOnNeighbors(NeighborsFunctionWithVertexValue<K, VV, EV, T> neighborsFunction, 			EdgeDirection direction, TypeInformation<T> typeInfo) throws IllegalArgumentException;1462100316;Groups by vertex and computes a GroupReduce transformation over the neighbors (both edges and vertices)_of each vertex. The neighborsFunction applied on the neighbors only has access to both the vertex id_and the vertex value of the grouping vertex.__For each vertex, the neighborsFunction can iterate over all neighbors of this vertex_with the specified direction, and emit any number of output elements, including none.__@param neighborsFunction the group reduce function to apply to the neighboring edges and vertices_of each vertex._@param direction the edge direction (in-, out-, all-)._@param <T> the output type_@param typeInfo the explicit return type_@return a DataSet containing elements of type T_@throws IllegalArgumentException;public <T> DataSet<T> groupReduceOnNeighbors(NeighborsFunctionWithVertexValue<K, VV, EV, T> neighborsFunction,_			EdgeDirection direction, TypeInformation<T> typeInfo) throws IllegalArgumentException {_		switch (direction) {_			case IN:_				_				DataSet<Tuple2<Edge<K, EV>, Vertex<K, VV>>> edgesWithSources = edges_						.join(this.vertices).where(0).equalTo(0)__				return vertices.coGroup(edgesWithSources)_						.where(0).equalTo("f0.f1")_						.with(new ApplyNeighborCoGroupFunction<K, VV, EV, T>(neighborsFunction)).returns(typeInfo)__			case OUT:_				_				DataSet<Tuple2<Edge<K, EV>, Vertex<K, VV>>> edgesWithTargets = edges_						.join(this.vertices).where(1).equalTo(0)__				return vertices.coGroup(edgesWithTargets)_						.where(0).equalTo("f0.f0")_						.with(new ApplyNeighborCoGroupFunction<K, VV, EV, T>(neighborsFunction)).returns(typeInfo)__			case ALL:_				_				DataSet<Tuple3<K, Edge<K, EV>, Vertex<K, VV>>> edgesWithNeighbors = edges_						.flatMap(new EmitOneEdgeWithNeighborPerNode<K, EV>())_						.join(this.vertices).where(1).equalTo(0)_						.with(new ProjectEdgeWithNeighbor<K, VV, EV>())___				return vertices.coGroup(edgesWithNeighbors)_						.where(0).equalTo(0)_						.with(new ApplyCoGroupFunctionOnAllNeighbors<K, VV, EV, T>(neighborsFunction)).returns(typeInfo)__			default:_				throw new IllegalArgumentException("Illegal edge direction")__		}_	};groups,by,vertex,and,computes,a,group,reduce,transformation,over,the,neighbors,both,edges,and,vertices,of,each,vertex,the,neighbors,function,applied,on,the,neighbors,only,has,access,to,both,the,vertex,id,and,the,vertex,value,of,the,grouping,vertex,for,each,vertex,the,neighbors,function,can,iterate,over,all,neighbors,of,this,vertex,with,the,specified,direction,and,emit,any,number,of,output,elements,including,none,param,neighbors,function,the,group,reduce,function,to,apply,to,the,neighboring,edges,and,vertices,of,each,vertex,param,direction,the,edge,direction,in,out,all,param,t,the,output,type,param,type,info,the,explicit,return,type,return,a,data,set,containing,elements,of,type,t,throws,illegal,argument,exception;public,t,data,set,t,group,reduce,on,neighbors,neighbors,function,with,vertex,value,k,vv,ev,t,neighbors,function,edge,direction,direction,type,information,t,type,info,throws,illegal,argument,exception,switch,direction,case,in,data,set,tuple2,edge,k,ev,vertex,k,vv,edges,with,sources,edges,join,this,vertices,where,0,equal,to,0,return,vertices,co,group,edges,with,sources,where,0,equal,to,f0,f1,with,new,apply,neighbor,co,group,function,k,vv,ev,t,neighbors,function,returns,type,info,case,out,data,set,tuple2,edge,k,ev,vertex,k,vv,edges,with,targets,edges,join,this,vertices,where,1,equal,to,0,return,vertices,co,group,edges,with,targets,where,0,equal,to,f0,f0,with,new,apply,neighbor,co,group,function,k,vv,ev,t,neighbors,function,returns,type,info,case,all,data,set,tuple3,k,edge,k,ev,vertex,k,vv,edges,with,neighbors,edges,flat,map,new,emit,one,edge,with,neighbor,per,node,k,ev,join,this,vertices,where,1,equal,to,0,with,new,project,edge,with,neighbor,k,vv,ev,return,vertices,co,group,edges,with,neighbors,where,0,equal,to,0,with,new,apply,co,group,function,on,all,neighbors,k,vv,ev,t,neighbors,function,returns,type,info,default,throw,new,illegal,argument,exception,illegal,edge,direction
Graph -> public <T> DataSet<T> groupReduceOnNeighbors(NeighborsFunctionWithVertexValue<K, VV, EV, T> neighborsFunction, 			EdgeDirection direction, TypeInformation<T> typeInfo) throws IllegalArgumentException;1462100316;Groups by vertex and computes a GroupReduce transformation over the neighbors (both edges and vertices)_of each vertex. The neighborsFunction applied on the neighbors only has access to both the vertex id_and the vertex value of the grouping vertex.__For each vertex, the neighborsFunction can iterate over all neighbors of this vertex_with the specified direction, and emit any number of output elements, including none.__@param neighborsFunction the group reduce function to apply to the neighboring edges and vertices_of each vertex._@param direction the edge direction (in-, out-, all-)._@param <T> the output type_@param typeInfo the explicit return type_@return a DataSet containing elements of type T_@throws IllegalArgumentException;public <T> DataSet<T> groupReduceOnNeighbors(NeighborsFunctionWithVertexValue<K, VV, EV, T> neighborsFunction,_			EdgeDirection direction, TypeInformation<T> typeInfo) throws IllegalArgumentException {_		switch (direction) {_			case IN:_				_				DataSet<Tuple2<Edge<K, EV>, Vertex<K, VV>>> edgesWithSources = edges_						.join(this.vertices).where(0).equalTo(0)__				return vertices.coGroup(edgesWithSources)_						.where(0).equalTo("f0.f1")_						.with(new ApplyNeighborCoGroupFunction<K, VV, EV, T>(neighborsFunction)).returns(typeInfo)__			case OUT:_				_				DataSet<Tuple2<Edge<K, EV>, Vertex<K, VV>>> edgesWithTargets = edges_						.join(this.vertices).where(1).equalTo(0)__				return vertices.coGroup(edgesWithTargets)_						.where(0).equalTo("f0.f0")_						.with(new ApplyNeighborCoGroupFunction<K, VV, EV, T>(neighborsFunction)).returns(typeInfo)__			case ALL:_				_				DataSet<Tuple3<K, Edge<K, EV>, Vertex<K, VV>>> edgesWithNeighbors = edges_						.flatMap(new EmitOneEdgeWithNeighborPerNode<K, EV>())_						.join(this.vertices).where(1).equalTo(0)_						.with(new ProjectEdgeWithNeighbor<K, VV, EV>())___				return vertices.coGroup(edgesWithNeighbors)_						.where(0).equalTo(0)_						.with(new ApplyCoGroupFunctionOnAllNeighbors<K, VV, EV, T>(neighborsFunction)).returns(typeInfo)__			default:_				throw new IllegalArgumentException("Illegal edge direction")__		}_	};groups,by,vertex,and,computes,a,group,reduce,transformation,over,the,neighbors,both,edges,and,vertices,of,each,vertex,the,neighbors,function,applied,on,the,neighbors,only,has,access,to,both,the,vertex,id,and,the,vertex,value,of,the,grouping,vertex,for,each,vertex,the,neighbors,function,can,iterate,over,all,neighbors,of,this,vertex,with,the,specified,direction,and,emit,any,number,of,output,elements,including,none,param,neighbors,function,the,group,reduce,function,to,apply,to,the,neighboring,edges,and,vertices,of,each,vertex,param,direction,the,edge,direction,in,out,all,param,t,the,output,type,param,type,info,the,explicit,return,type,return,a,data,set,containing,elements,of,type,t,throws,illegal,argument,exception;public,t,data,set,t,group,reduce,on,neighbors,neighbors,function,with,vertex,value,k,vv,ev,t,neighbors,function,edge,direction,direction,type,information,t,type,info,throws,illegal,argument,exception,switch,direction,case,in,data,set,tuple2,edge,k,ev,vertex,k,vv,edges,with,sources,edges,join,this,vertices,where,0,equal,to,0,return,vertices,co,group,edges,with,sources,where,0,equal,to,f0,f1,with,new,apply,neighbor,co,group,function,k,vv,ev,t,neighbors,function,returns,type,info,case,out,data,set,tuple2,edge,k,ev,vertex,k,vv,edges,with,targets,edges,join,this,vertices,where,1,equal,to,0,return,vertices,co,group,edges,with,targets,where,0,equal,to,f0,f0,with,new,apply,neighbor,co,group,function,k,vv,ev,t,neighbors,function,returns,type,info,case,all,data,set,tuple3,k,edge,k,ev,vertex,k,vv,edges,with,neighbors,edges,flat,map,new,emit,one,edge,with,neighbor,per,node,k,ev,join,this,vertices,where,1,equal,to,0,with,new,project,edge,with,neighbor,k,vv,ev,return,vertices,co,group,edges,with,neighbors,where,0,equal,to,0,with,new,apply,co,group,function,on,all,neighbors,k,vv,ev,t,neighbors,function,returns,type,info,default,throw,new,illegal,argument,exception,illegal,edge,direction
Graph -> public <T> DataSet<T> groupReduceOnNeighbors(NeighborsFunctionWithVertexValue<K, VV, EV, T> neighborsFunction, 			EdgeDirection direction, TypeInformation<T> typeInfo) throws IllegalArgumentException;1462205213;Groups by vertex and computes a GroupReduce transformation over the neighbors (both edges and vertices)_of each vertex. The neighborsFunction applied on the neighbors only has access to both the vertex id_and the vertex value of the grouping vertex.__For each vertex, the neighborsFunction can iterate over all neighbors of this vertex_with the specified direction, and emit any number of output elements, including none.__@param neighborsFunction the group reduce function to apply to the neighboring edges and vertices_of each vertex._@param direction the edge direction (in-, out-, all-)._@param <T> the output type_@param typeInfo the explicit return type_@return a DataSet containing elements of type T_@throws IllegalArgumentException;public <T> DataSet<T> groupReduceOnNeighbors(NeighborsFunctionWithVertexValue<K, VV, EV, T> neighborsFunction,_			EdgeDirection direction, TypeInformation<T> typeInfo) throws IllegalArgumentException {_		switch (direction) {_			case IN:_				_				DataSet<Tuple2<Edge<K, EV>, Vertex<K, VV>>> edgesWithSources = edges_						.join(this.vertices).where(0).equalTo(0)__				return vertices.coGroup(edgesWithSources)_						.where(0).equalTo("f0.f1")_						.with(new ApplyNeighborCoGroupFunction<K, VV, EV, T>(neighborsFunction)).returns(typeInfo)__			case OUT:_				_				DataSet<Tuple2<Edge<K, EV>, Vertex<K, VV>>> edgesWithTargets = edges_						.join(this.vertices).where(1).equalTo(0)__				return vertices.coGroup(edgesWithTargets)_						.where(0).equalTo("f0.f0")_						.with(new ApplyNeighborCoGroupFunction<K, VV, EV, T>(neighborsFunction)).returns(typeInfo)__			case ALL:_				_				DataSet<Tuple3<K, Edge<K, EV>, Vertex<K, VV>>> edgesWithNeighbors = edges_						.flatMap(new EmitOneEdgeWithNeighborPerNode<K, EV>())_						.join(this.vertices).where(1).equalTo(0)_						.with(new ProjectEdgeWithNeighbor<K, VV, EV>())___				return vertices.coGroup(edgesWithNeighbors)_						.where(0).equalTo(0)_						.with(new ApplyCoGroupFunctionOnAllNeighbors<K, VV, EV, T>(neighborsFunction)).returns(typeInfo)__			default:_				throw new IllegalArgumentException("Illegal edge direction")__		}_	};groups,by,vertex,and,computes,a,group,reduce,transformation,over,the,neighbors,both,edges,and,vertices,of,each,vertex,the,neighbors,function,applied,on,the,neighbors,only,has,access,to,both,the,vertex,id,and,the,vertex,value,of,the,grouping,vertex,for,each,vertex,the,neighbors,function,can,iterate,over,all,neighbors,of,this,vertex,with,the,specified,direction,and,emit,any,number,of,output,elements,including,none,param,neighbors,function,the,group,reduce,function,to,apply,to,the,neighboring,edges,and,vertices,of,each,vertex,param,direction,the,edge,direction,in,out,all,param,t,the,output,type,param,type,info,the,explicit,return,type,return,a,data,set,containing,elements,of,type,t,throws,illegal,argument,exception;public,t,data,set,t,group,reduce,on,neighbors,neighbors,function,with,vertex,value,k,vv,ev,t,neighbors,function,edge,direction,direction,type,information,t,type,info,throws,illegal,argument,exception,switch,direction,case,in,data,set,tuple2,edge,k,ev,vertex,k,vv,edges,with,sources,edges,join,this,vertices,where,0,equal,to,0,return,vertices,co,group,edges,with,sources,where,0,equal,to,f0,f1,with,new,apply,neighbor,co,group,function,k,vv,ev,t,neighbors,function,returns,type,info,case,out,data,set,tuple2,edge,k,ev,vertex,k,vv,edges,with,targets,edges,join,this,vertices,where,1,equal,to,0,return,vertices,co,group,edges,with,targets,where,0,equal,to,f0,f0,with,new,apply,neighbor,co,group,function,k,vv,ev,t,neighbors,function,returns,type,info,case,all,data,set,tuple3,k,edge,k,ev,vertex,k,vv,edges,with,neighbors,edges,flat,map,new,emit,one,edge,with,neighbor,per,node,k,ev,join,this,vertices,where,1,equal,to,0,with,new,project,edge,with,neighbor,k,vv,ev,return,vertices,co,group,edges,with,neighbors,where,0,equal,to,0,with,new,apply,co,group,function,on,all,neighbors,k,vv,ev,t,neighbors,function,returns,type,info,default,throw,new,illegal,argument,exception,illegal,edge,direction
Graph -> public <T> DataSet<T> groupReduceOnNeighbors(NeighborsFunctionWithVertexValue<K, VV, EV, T> neighborsFunction, 			EdgeDirection direction, TypeInformation<T> typeInfo) throws IllegalArgumentException;1462208859;Groups by vertex and computes a GroupReduce transformation over the neighbors (both edges and vertices)_of each vertex. The neighborsFunction applied on the neighbors only has access to both the vertex id_and the vertex value of the grouping vertex.__For each vertex, the neighborsFunction can iterate over all neighbors of this vertex_with the specified direction, and emit any number of output elements, including none.__@param neighborsFunction the group reduce function to apply to the neighboring edges and vertices_of each vertex._@param direction the edge direction (in-, out-, all-)._@param <T> the output type_@param typeInfo the explicit return type_@return a DataSet containing elements of type T_@throws IllegalArgumentException;public <T> DataSet<T> groupReduceOnNeighbors(NeighborsFunctionWithVertexValue<K, VV, EV, T> neighborsFunction,_			EdgeDirection direction, TypeInformation<T> typeInfo) throws IllegalArgumentException {_		switch (direction) {_			case IN:_				_				DataSet<Tuple2<Edge<K, EV>, Vertex<K, VV>>> edgesWithSources = edges_						.join(this.vertices).where(0).equalTo(0)__				return vertices.coGroup(edgesWithSources)_						.where(0).equalTo("f0.f1")_						.with(new ApplyNeighborCoGroupFunction<K, VV, EV, T>(neighborsFunction)).returns(typeInfo)__			case OUT:_				_				DataSet<Tuple2<Edge<K, EV>, Vertex<K, VV>>> edgesWithTargets = edges_						.join(this.vertices).where(1).equalTo(0)__				return vertices.coGroup(edgesWithTargets)_						.where(0).equalTo("f0.f0")_						.with(new ApplyNeighborCoGroupFunction<K, VV, EV, T>(neighborsFunction)).returns(typeInfo)__			case ALL:_				_				DataSet<Tuple3<K, Edge<K, EV>, Vertex<K, VV>>> edgesWithNeighbors = edges_						.flatMap(new EmitOneEdgeWithNeighborPerNode<K, EV>())_						.join(this.vertices).where(1).equalTo(0)_						.with(new ProjectEdgeWithNeighbor<K, VV, EV>())___				return vertices.coGroup(edgesWithNeighbors)_						.where(0).equalTo(0)_						.with(new ApplyCoGroupFunctionOnAllNeighbors<K, VV, EV, T>(neighborsFunction)).returns(typeInfo)__			default:_				throw new IllegalArgumentException("Illegal edge direction")__		}_	};groups,by,vertex,and,computes,a,group,reduce,transformation,over,the,neighbors,both,edges,and,vertices,of,each,vertex,the,neighbors,function,applied,on,the,neighbors,only,has,access,to,both,the,vertex,id,and,the,vertex,value,of,the,grouping,vertex,for,each,vertex,the,neighbors,function,can,iterate,over,all,neighbors,of,this,vertex,with,the,specified,direction,and,emit,any,number,of,output,elements,including,none,param,neighbors,function,the,group,reduce,function,to,apply,to,the,neighboring,edges,and,vertices,of,each,vertex,param,direction,the,edge,direction,in,out,all,param,t,the,output,type,param,type,info,the,explicit,return,type,return,a,data,set,containing,elements,of,type,t,throws,illegal,argument,exception;public,t,data,set,t,group,reduce,on,neighbors,neighbors,function,with,vertex,value,k,vv,ev,t,neighbors,function,edge,direction,direction,type,information,t,type,info,throws,illegal,argument,exception,switch,direction,case,in,data,set,tuple2,edge,k,ev,vertex,k,vv,edges,with,sources,edges,join,this,vertices,where,0,equal,to,0,return,vertices,co,group,edges,with,sources,where,0,equal,to,f0,f1,with,new,apply,neighbor,co,group,function,k,vv,ev,t,neighbors,function,returns,type,info,case,out,data,set,tuple2,edge,k,ev,vertex,k,vv,edges,with,targets,edges,join,this,vertices,where,1,equal,to,0,return,vertices,co,group,edges,with,targets,where,0,equal,to,f0,f0,with,new,apply,neighbor,co,group,function,k,vv,ev,t,neighbors,function,returns,type,info,case,all,data,set,tuple3,k,edge,k,ev,vertex,k,vv,edges,with,neighbors,edges,flat,map,new,emit,one,edge,with,neighbor,per,node,k,ev,join,this,vertices,where,1,equal,to,0,with,new,project,edge,with,neighbor,k,vv,ev,return,vertices,co,group,edges,with,neighbors,where,0,equal,to,0,with,new,apply,co,group,function,on,all,neighbors,k,vv,ev,t,neighbors,function,returns,type,info,default,throw,new,illegal,argument,exception,illegal,edge,direction
Graph -> public <T> DataSet<T> groupReduceOnNeighbors(NeighborsFunctionWithVertexValue<K, VV, EV, T> neighborsFunction, 			EdgeDirection direction, TypeInformation<T> typeInfo) throws IllegalArgumentException;1462809297;Groups by vertex and computes a GroupReduce transformation over the neighbors (both edges and vertices)_of each vertex. The neighborsFunction applied on the neighbors only has access to both the vertex id_and the vertex value of the grouping vertex.__For each vertex, the neighborsFunction can iterate over all neighbors of this vertex_with the specified direction, and emit any number of output elements, including none.__@param neighborsFunction the group reduce function to apply to the neighboring edges and vertices_of each vertex._@param direction the edge direction (in-, out-, all-)._@param <T> the output type_@param typeInfo the explicit return type_@return a DataSet containing elements of type T_@throws IllegalArgumentException;public <T> DataSet<T> groupReduceOnNeighbors(NeighborsFunctionWithVertexValue<K, VV, EV, T> neighborsFunction,_			EdgeDirection direction, TypeInformation<T> typeInfo) throws IllegalArgumentException {_		switch (direction) {_			case IN:_				_				DataSet<Tuple2<Edge<K, EV>, Vertex<K, VV>>> edgesWithSources = edges_						.join(this.vertices).where(0).equalTo(0)__				return vertices.coGroup(edgesWithSources)_						.where(0).equalTo("f0.f1")_						.with(new ApplyNeighborCoGroupFunction<K, VV, EV, T>(neighborsFunction)).returns(typeInfo)__			case OUT:_				_				DataSet<Tuple2<Edge<K, EV>, Vertex<K, VV>>> edgesWithTargets = edges_						.join(this.vertices).where(1).equalTo(0)__				return vertices.coGroup(edgesWithTargets)_						.where(0).equalTo("f0.f0")_						.with(new ApplyNeighborCoGroupFunction<K, VV, EV, T>(neighborsFunction)).returns(typeInfo)__			case ALL:_				_				DataSet<Tuple3<K, Edge<K, EV>, Vertex<K, VV>>> edgesWithNeighbors = edges_						.flatMap(new EmitOneEdgeWithNeighborPerNode<K, EV>())_						.join(this.vertices).where(1).equalTo(0)_						.with(new ProjectEdgeWithNeighbor<K, VV, EV>())___				return vertices.coGroup(edgesWithNeighbors)_						.where(0).equalTo(0)_						.with(new ApplyCoGroupFunctionOnAllNeighbors<K, VV, EV, T>(neighborsFunction)).returns(typeInfo)__			default:_				throw new IllegalArgumentException("Illegal edge direction")__		}_	};groups,by,vertex,and,computes,a,group,reduce,transformation,over,the,neighbors,both,edges,and,vertices,of,each,vertex,the,neighbors,function,applied,on,the,neighbors,only,has,access,to,both,the,vertex,id,and,the,vertex,value,of,the,grouping,vertex,for,each,vertex,the,neighbors,function,can,iterate,over,all,neighbors,of,this,vertex,with,the,specified,direction,and,emit,any,number,of,output,elements,including,none,param,neighbors,function,the,group,reduce,function,to,apply,to,the,neighboring,edges,and,vertices,of,each,vertex,param,direction,the,edge,direction,in,out,all,param,t,the,output,type,param,type,info,the,explicit,return,type,return,a,data,set,containing,elements,of,type,t,throws,illegal,argument,exception;public,t,data,set,t,group,reduce,on,neighbors,neighbors,function,with,vertex,value,k,vv,ev,t,neighbors,function,edge,direction,direction,type,information,t,type,info,throws,illegal,argument,exception,switch,direction,case,in,data,set,tuple2,edge,k,ev,vertex,k,vv,edges,with,sources,edges,join,this,vertices,where,0,equal,to,0,return,vertices,co,group,edges,with,sources,where,0,equal,to,f0,f1,with,new,apply,neighbor,co,group,function,k,vv,ev,t,neighbors,function,returns,type,info,case,out,data,set,tuple2,edge,k,ev,vertex,k,vv,edges,with,targets,edges,join,this,vertices,where,1,equal,to,0,return,vertices,co,group,edges,with,targets,where,0,equal,to,f0,f0,with,new,apply,neighbor,co,group,function,k,vv,ev,t,neighbors,function,returns,type,info,case,all,data,set,tuple3,k,edge,k,ev,vertex,k,vv,edges,with,neighbors,edges,flat,map,new,emit,one,edge,with,neighbor,per,node,k,ev,join,this,vertices,where,1,equal,to,0,with,new,project,edge,with,neighbor,k,vv,ev,return,vertices,co,group,edges,with,neighbors,where,0,equal,to,0,with,new,apply,co,group,function,on,all,neighbors,k,vv,ev,t,neighbors,function,returns,type,info,default,throw,new,illegal,argument,exception,illegal,edge,direction
Graph -> public <T> DataSet<T> groupReduceOnNeighbors(NeighborsFunctionWithVertexValue<K, VV, EV, T> neighborsFunction, 			EdgeDirection direction, TypeInformation<T> typeInfo) throws IllegalArgumentException;1465316775;Groups by vertex and computes a GroupReduce transformation over the neighbors (both edges and vertices)_of each vertex. The neighborsFunction applied on the neighbors only has access to both the vertex id_and the vertex value of the grouping vertex.__For each vertex, the neighborsFunction can iterate over all neighbors of this vertex_with the specified direction, and emit any number of output elements, including none.__@param neighborsFunction the group reduce function to apply to the neighboring edges and vertices_of each vertex._@param direction the edge direction (in-, out-, all-)._@param <T> the output type_@param typeInfo the explicit return type_@return a DataSet containing elements of type T_@throws IllegalArgumentException;public <T> DataSet<T> groupReduceOnNeighbors(NeighborsFunctionWithVertexValue<K, VV, EV, T> neighborsFunction,_			EdgeDirection direction, TypeInformation<T> typeInfo) throws IllegalArgumentException {_		switch (direction) {_			case IN:_				_				DataSet<Tuple2<Edge<K, EV>, Vertex<K, VV>>> edgesWithSources = edges_						.join(this.vertices).where(0).equalTo(0)__				return vertices.coGroup(edgesWithSources)_						.where(0).equalTo("f0.f1")_						.with(new ApplyNeighborCoGroupFunction<K, VV, EV, T>(neighborsFunction)).returns(typeInfo)__			case OUT:_				_				DataSet<Tuple2<Edge<K, EV>, Vertex<K, VV>>> edgesWithTargets = edges_						.join(this.vertices).where(1).equalTo(0)__				return vertices.coGroup(edgesWithTargets)_						.where(0).equalTo("f0.f0")_						.with(new ApplyNeighborCoGroupFunction<K, VV, EV, T>(neighborsFunction)).returns(typeInfo)__			case ALL:_				_				DataSet<Tuple3<K, Edge<K, EV>, Vertex<K, VV>>> edgesWithNeighbors = edges_						.flatMap(new EmitOneEdgeWithNeighborPerNode<K, EV>())_						.join(this.vertices).where(1).equalTo(0)_						.with(new ProjectEdgeWithNeighbor<K, VV, EV>())___				return vertices.coGroup(edgesWithNeighbors)_						.where(0).equalTo(0)_						.with(new ApplyCoGroupFunctionOnAllNeighbors<K, VV, EV, T>(neighborsFunction)).returns(typeInfo)__			default:_				throw new IllegalArgumentException("Illegal edge direction")__		}_	};groups,by,vertex,and,computes,a,group,reduce,transformation,over,the,neighbors,both,edges,and,vertices,of,each,vertex,the,neighbors,function,applied,on,the,neighbors,only,has,access,to,both,the,vertex,id,and,the,vertex,value,of,the,grouping,vertex,for,each,vertex,the,neighbors,function,can,iterate,over,all,neighbors,of,this,vertex,with,the,specified,direction,and,emit,any,number,of,output,elements,including,none,param,neighbors,function,the,group,reduce,function,to,apply,to,the,neighboring,edges,and,vertices,of,each,vertex,param,direction,the,edge,direction,in,out,all,param,t,the,output,type,param,type,info,the,explicit,return,type,return,a,data,set,containing,elements,of,type,t,throws,illegal,argument,exception;public,t,data,set,t,group,reduce,on,neighbors,neighbors,function,with,vertex,value,k,vv,ev,t,neighbors,function,edge,direction,direction,type,information,t,type,info,throws,illegal,argument,exception,switch,direction,case,in,data,set,tuple2,edge,k,ev,vertex,k,vv,edges,with,sources,edges,join,this,vertices,where,0,equal,to,0,return,vertices,co,group,edges,with,sources,where,0,equal,to,f0,f1,with,new,apply,neighbor,co,group,function,k,vv,ev,t,neighbors,function,returns,type,info,case,out,data,set,tuple2,edge,k,ev,vertex,k,vv,edges,with,targets,edges,join,this,vertices,where,1,equal,to,0,return,vertices,co,group,edges,with,targets,where,0,equal,to,f0,f0,with,new,apply,neighbor,co,group,function,k,vv,ev,t,neighbors,function,returns,type,info,case,all,data,set,tuple3,k,edge,k,ev,vertex,k,vv,edges,with,neighbors,edges,flat,map,new,emit,one,edge,with,neighbor,per,node,k,ev,join,this,vertices,where,1,equal,to,0,with,new,project,edge,with,neighbor,k,vv,ev,return,vertices,co,group,edges,with,neighbors,where,0,equal,to,0,with,new,apply,co,group,function,on,all,neighbors,k,vv,ev,t,neighbors,function,returns,type,info,default,throw,new,illegal,argument,exception,illegal,edge,direction
Graph -> public <T> DataSet<T> groupReduceOnNeighbors(NeighborsFunctionWithVertexValue<K, VV, EV, T> neighborsFunction, 			EdgeDirection direction, TypeInformation<T> typeInfo) throws IllegalArgumentException;1466789678;Groups by vertex and computes a GroupReduce transformation over the neighbors (both edges and vertices)_of each vertex. The neighborsFunction applied on the neighbors only has access to both the vertex id_and the vertex value of the grouping vertex.__For each vertex, the neighborsFunction can iterate over all neighbors of this vertex_with the specified direction, and emit any number of output elements, including none.__@param neighborsFunction the group reduce function to apply to the neighboring edges and vertices_of each vertex._@param direction the edge direction (in-, out-, all-)._@param <T> the output type_@param typeInfo the explicit return type_@return a DataSet containing elements of type T_@throws IllegalArgumentException;public <T> DataSet<T> groupReduceOnNeighbors(NeighborsFunctionWithVertexValue<K, VV, EV, T> neighborsFunction,_			EdgeDirection direction, TypeInformation<T> typeInfo) throws IllegalArgumentException {_		switch (direction) {_			case IN:_				_				DataSet<Tuple2<Edge<K, EV>, Vertex<K, VV>>> edgesWithSources = edges_						.join(this.vertices).where(0).equalTo(0)__				return vertices.coGroup(edgesWithSources)_						.where(0).equalTo("f0.f1")_						.with(new ApplyNeighborCoGroupFunction<K, VV, EV, T>(neighborsFunction)).returns(typeInfo)__			case OUT:_				_				DataSet<Tuple2<Edge<K, EV>, Vertex<K, VV>>> edgesWithTargets = edges_						.join(this.vertices).where(1).equalTo(0)__				return vertices.coGroup(edgesWithTargets)_						.where(0).equalTo("f0.f0")_						.with(new ApplyNeighborCoGroupFunction<K, VV, EV, T>(neighborsFunction)).returns(typeInfo)__			case ALL:_				_				DataSet<Tuple3<K, Edge<K, EV>, Vertex<K, VV>>> edgesWithNeighbors = edges_						.flatMap(new EmitOneEdgeWithNeighborPerNode<K, EV>())_						.join(this.vertices).where(1).equalTo(0)_						.with(new ProjectEdgeWithNeighbor<K, VV, EV>())___				return vertices.coGroup(edgesWithNeighbors)_						.where(0).equalTo(0)_						.with(new ApplyCoGroupFunctionOnAllNeighbors<K, VV, EV, T>(neighborsFunction)).returns(typeInfo)__			default:_				throw new IllegalArgumentException("Illegal edge direction")__		}_	};groups,by,vertex,and,computes,a,group,reduce,transformation,over,the,neighbors,both,edges,and,vertices,of,each,vertex,the,neighbors,function,applied,on,the,neighbors,only,has,access,to,both,the,vertex,id,and,the,vertex,value,of,the,grouping,vertex,for,each,vertex,the,neighbors,function,can,iterate,over,all,neighbors,of,this,vertex,with,the,specified,direction,and,emit,any,number,of,output,elements,including,none,param,neighbors,function,the,group,reduce,function,to,apply,to,the,neighboring,edges,and,vertices,of,each,vertex,param,direction,the,edge,direction,in,out,all,param,t,the,output,type,param,type,info,the,explicit,return,type,return,a,data,set,containing,elements,of,type,t,throws,illegal,argument,exception;public,t,data,set,t,group,reduce,on,neighbors,neighbors,function,with,vertex,value,k,vv,ev,t,neighbors,function,edge,direction,direction,type,information,t,type,info,throws,illegal,argument,exception,switch,direction,case,in,data,set,tuple2,edge,k,ev,vertex,k,vv,edges,with,sources,edges,join,this,vertices,where,0,equal,to,0,return,vertices,co,group,edges,with,sources,where,0,equal,to,f0,f1,with,new,apply,neighbor,co,group,function,k,vv,ev,t,neighbors,function,returns,type,info,case,out,data,set,tuple2,edge,k,ev,vertex,k,vv,edges,with,targets,edges,join,this,vertices,where,1,equal,to,0,return,vertices,co,group,edges,with,targets,where,0,equal,to,f0,f0,with,new,apply,neighbor,co,group,function,k,vv,ev,t,neighbors,function,returns,type,info,case,all,data,set,tuple3,k,edge,k,ev,vertex,k,vv,edges,with,neighbors,edges,flat,map,new,emit,one,edge,with,neighbor,per,node,k,ev,join,this,vertices,where,1,equal,to,0,with,new,project,edge,with,neighbor,k,vv,ev,return,vertices,co,group,edges,with,neighbors,where,0,equal,to,0,with,new,apply,co,group,function,on,all,neighbors,k,vv,ev,t,neighbors,function,returns,type,info,default,throw,new,illegal,argument,exception,illegal,edge,direction
Graph -> public <T> DataSet<T> groupReduceOnNeighbors(NeighborsFunctionWithVertexValue<K, VV, EV, T> neighborsFunction, 			EdgeDirection direction, TypeInformation<T> typeInfo) throws IllegalArgumentException;1467140656;Groups by vertex and computes a GroupReduce transformation over the neighbors (both edges and vertices)_of each vertex. The neighborsFunction applied on the neighbors only has access to both the vertex id_and the vertex value of the grouping vertex.__For each vertex, the neighborsFunction can iterate over all neighbors of this vertex_with the specified direction, and emit any number of output elements, including none.__@param neighborsFunction the group reduce function to apply to the neighboring edges and vertices_of each vertex._@param direction the edge direction (in-, out-, all-)._@param <T> the output type_@param typeInfo the explicit return type_@return a DataSet containing elements of type T_@throws IllegalArgumentException;public <T> DataSet<T> groupReduceOnNeighbors(NeighborsFunctionWithVertexValue<K, VV, EV, T> neighborsFunction,_			EdgeDirection direction, TypeInformation<T> typeInfo) throws IllegalArgumentException {_		switch (direction) {_			case IN:_				_				DataSet<Tuple2<Edge<K, EV>, Vertex<K, VV>>> edgesWithSources = edges_						.join(this.vertices).where(0).equalTo(0)__				return vertices.coGroup(edgesWithSources)_						.where(0).equalTo("f0.f1")_						.with(new ApplyNeighborCoGroupFunction<K, VV, EV, T>(neighborsFunction)).returns(typeInfo)__			case OUT:_				_				DataSet<Tuple2<Edge<K, EV>, Vertex<K, VV>>> edgesWithTargets = edges_						.join(this.vertices).where(1).equalTo(0)__				return vertices.coGroup(edgesWithTargets)_						.where(0).equalTo("f0.f0")_						.with(new ApplyNeighborCoGroupFunction<K, VV, EV, T>(neighborsFunction)).returns(typeInfo)__			case ALL:_				_				DataSet<Tuple3<K, Edge<K, EV>, Vertex<K, VV>>> edgesWithNeighbors = edges_						.flatMap(new EmitOneEdgeWithNeighborPerNode<K, EV>())_						.join(this.vertices).where(1).equalTo(0)_						.with(new ProjectEdgeWithNeighbor<K, VV, EV>())___				return vertices.coGroup(edgesWithNeighbors)_						.where(0).equalTo(0)_						.with(new ApplyCoGroupFunctionOnAllNeighbors<K, VV, EV, T>(neighborsFunction)).returns(typeInfo)__			default:_				throw new IllegalArgumentException("Illegal edge direction")__		}_	};groups,by,vertex,and,computes,a,group,reduce,transformation,over,the,neighbors,both,edges,and,vertices,of,each,vertex,the,neighbors,function,applied,on,the,neighbors,only,has,access,to,both,the,vertex,id,and,the,vertex,value,of,the,grouping,vertex,for,each,vertex,the,neighbors,function,can,iterate,over,all,neighbors,of,this,vertex,with,the,specified,direction,and,emit,any,number,of,output,elements,including,none,param,neighbors,function,the,group,reduce,function,to,apply,to,the,neighboring,edges,and,vertices,of,each,vertex,param,direction,the,edge,direction,in,out,all,param,t,the,output,type,param,type,info,the,explicit,return,type,return,a,data,set,containing,elements,of,type,t,throws,illegal,argument,exception;public,t,data,set,t,group,reduce,on,neighbors,neighbors,function,with,vertex,value,k,vv,ev,t,neighbors,function,edge,direction,direction,type,information,t,type,info,throws,illegal,argument,exception,switch,direction,case,in,data,set,tuple2,edge,k,ev,vertex,k,vv,edges,with,sources,edges,join,this,vertices,where,0,equal,to,0,return,vertices,co,group,edges,with,sources,where,0,equal,to,f0,f1,with,new,apply,neighbor,co,group,function,k,vv,ev,t,neighbors,function,returns,type,info,case,out,data,set,tuple2,edge,k,ev,vertex,k,vv,edges,with,targets,edges,join,this,vertices,where,1,equal,to,0,return,vertices,co,group,edges,with,targets,where,0,equal,to,f0,f0,with,new,apply,neighbor,co,group,function,k,vv,ev,t,neighbors,function,returns,type,info,case,all,data,set,tuple3,k,edge,k,ev,vertex,k,vv,edges,with,neighbors,edges,flat,map,new,emit,one,edge,with,neighbor,per,node,k,ev,join,this,vertices,where,1,equal,to,0,with,new,project,edge,with,neighbor,k,vv,ev,return,vertices,co,group,edges,with,neighbors,where,0,equal,to,0,with,new,apply,co,group,function,on,all,neighbors,k,vv,ev,t,neighbors,function,returns,type,info,default,throw,new,illegal,argument,exception,illegal,edge,direction
Graph -> public <T> DataSet<T> groupReduceOnNeighbors(NeighborsFunctionWithVertexValue<K, VV, EV, T> neighborsFunction, 			EdgeDirection direction, TypeInformation<T> typeInfo) throws IllegalArgumentException;1467306272;Groups by vertex and computes a GroupReduce transformation over the neighbors (both edges and vertices)_of each vertex. The neighborsFunction applied on the neighbors only has access to both the vertex id_and the vertex value of the grouping vertex.__For each vertex, the neighborsFunction can iterate over all neighbors of this vertex_with the specified direction, and emit any number of output elements, including none.__@param neighborsFunction the group reduce function to apply to the neighboring edges and vertices_of each vertex._@param direction the edge direction (in-, out-, all-)._@param <T> the output type_@param typeInfo the explicit return type_@return a DataSet containing elements of type T_@throws IllegalArgumentException;public <T> DataSet<T> groupReduceOnNeighbors(NeighborsFunctionWithVertexValue<K, VV, EV, T> neighborsFunction,_			EdgeDirection direction, TypeInformation<T> typeInfo) throws IllegalArgumentException {_		switch (direction) {_			case IN:_				_				DataSet<Tuple2<Edge<K, EV>, Vertex<K, VV>>> edgesWithSources = edges_						.join(this.vertices).where(0).equalTo(0)__				return vertices.coGroup(edgesWithSources)_						.where(0).equalTo("f0.f1")_						.with(new ApplyNeighborCoGroupFunction<K, VV, EV, T>(neighborsFunction)).returns(typeInfo)__			case OUT:_				_				DataSet<Tuple2<Edge<K, EV>, Vertex<K, VV>>> edgesWithTargets = edges_						.join(this.vertices).where(1).equalTo(0)__				return vertices.coGroup(edgesWithTargets)_						.where(0).equalTo("f0.f0")_						.with(new ApplyNeighborCoGroupFunction<K, VV, EV, T>(neighborsFunction)).returns(typeInfo)__			case ALL:_				_				DataSet<Tuple3<K, Edge<K, EV>, Vertex<K, VV>>> edgesWithNeighbors = edges_						.flatMap(new EmitOneEdgeWithNeighborPerNode<K, EV>())_						.join(this.vertices).where(1).equalTo(0)_						.with(new ProjectEdgeWithNeighbor<K, VV, EV>())___				return vertices.coGroup(edgesWithNeighbors)_						.where(0).equalTo(0)_						.with(new ApplyCoGroupFunctionOnAllNeighbors<K, VV, EV, T>(neighborsFunction)).returns(typeInfo)__			default:_				throw new IllegalArgumentException("Illegal edge direction")__		}_	};groups,by,vertex,and,computes,a,group,reduce,transformation,over,the,neighbors,both,edges,and,vertices,of,each,vertex,the,neighbors,function,applied,on,the,neighbors,only,has,access,to,both,the,vertex,id,and,the,vertex,value,of,the,grouping,vertex,for,each,vertex,the,neighbors,function,can,iterate,over,all,neighbors,of,this,vertex,with,the,specified,direction,and,emit,any,number,of,output,elements,including,none,param,neighbors,function,the,group,reduce,function,to,apply,to,the,neighboring,edges,and,vertices,of,each,vertex,param,direction,the,edge,direction,in,out,all,param,t,the,output,type,param,type,info,the,explicit,return,type,return,a,data,set,containing,elements,of,type,t,throws,illegal,argument,exception;public,t,data,set,t,group,reduce,on,neighbors,neighbors,function,with,vertex,value,k,vv,ev,t,neighbors,function,edge,direction,direction,type,information,t,type,info,throws,illegal,argument,exception,switch,direction,case,in,data,set,tuple2,edge,k,ev,vertex,k,vv,edges,with,sources,edges,join,this,vertices,where,0,equal,to,0,return,vertices,co,group,edges,with,sources,where,0,equal,to,f0,f1,with,new,apply,neighbor,co,group,function,k,vv,ev,t,neighbors,function,returns,type,info,case,out,data,set,tuple2,edge,k,ev,vertex,k,vv,edges,with,targets,edges,join,this,vertices,where,1,equal,to,0,return,vertices,co,group,edges,with,targets,where,0,equal,to,f0,f0,with,new,apply,neighbor,co,group,function,k,vv,ev,t,neighbors,function,returns,type,info,case,all,data,set,tuple3,k,edge,k,ev,vertex,k,vv,edges,with,neighbors,edges,flat,map,new,emit,one,edge,with,neighbor,per,node,k,ev,join,this,vertices,where,1,equal,to,0,with,new,project,edge,with,neighbor,k,vv,ev,return,vertices,co,group,edges,with,neighbors,where,0,equal,to,0,with,new,apply,co,group,function,on,all,neighbors,k,vv,ev,t,neighbors,function,returns,type,info,default,throw,new,illegal,argument,exception,illegal,edge,direction
Graph -> public <T> DataSet<T> groupReduceOnNeighbors(NeighborsFunctionWithVertexValue<K, VV, EV, T> neighborsFunction, 			EdgeDirection direction, TypeInformation<T> typeInfo) throws IllegalArgumentException;1470042815;Groups by vertex and computes a GroupReduce transformation over the neighbors (both edges and vertices)_of each vertex. The neighborsFunction applied on the neighbors only has access to both the vertex id_and the vertex value of the grouping vertex.__For each vertex, the neighborsFunction can iterate over all neighbors of this vertex_with the specified direction, and emit any number of output elements, including none.__@param neighborsFunction the group reduce function to apply to the neighboring edges and vertices_of each vertex._@param direction the edge direction (in-, out-, all-)._@param <T> the output type_@param typeInfo the explicit return type_@return a DataSet containing elements of type T_@throws IllegalArgumentException;public <T> DataSet<T> groupReduceOnNeighbors(NeighborsFunctionWithVertexValue<K, VV, EV, T> neighborsFunction,_			EdgeDirection direction, TypeInformation<T> typeInfo) throws IllegalArgumentException {_		switch (direction) {_			case IN:_				_				DataSet<Tuple2<Edge<K, EV>, Vertex<K, VV>>> edgesWithSources = edges_						.join(this.vertices).where(0).equalTo(0)__				return vertices.coGroup(edgesWithSources)_						.where(0).equalTo("f0.f1")_						.with(new ApplyNeighborCoGroupFunction<K, VV, EV, T>(neighborsFunction)).returns(typeInfo)__			case OUT:_				_				DataSet<Tuple2<Edge<K, EV>, Vertex<K, VV>>> edgesWithTargets = edges_						.join(this.vertices).where(1).equalTo(0)__				return vertices.coGroup(edgesWithTargets)_						.where(0).equalTo("f0.f0")_						.with(new ApplyNeighborCoGroupFunction<K, VV, EV, T>(neighborsFunction)).returns(typeInfo)__			case ALL:_				_				DataSet<Tuple3<K, Edge<K, EV>, Vertex<K, VV>>> edgesWithNeighbors = edges_						.flatMap(new EmitOneEdgeWithNeighborPerNode<K, EV>())_						.join(this.vertices).where(1).equalTo(0)_						.with(new ProjectEdgeWithNeighbor<K, VV, EV>())___				return vertices.coGroup(edgesWithNeighbors)_						.where(0).equalTo(0)_						.with(new ApplyCoGroupFunctionOnAllNeighbors<K, VV, EV, T>(neighborsFunction)).returns(typeInfo)__			default:_				throw new IllegalArgumentException("Illegal edge direction")__		}_	};groups,by,vertex,and,computes,a,group,reduce,transformation,over,the,neighbors,both,edges,and,vertices,of,each,vertex,the,neighbors,function,applied,on,the,neighbors,only,has,access,to,both,the,vertex,id,and,the,vertex,value,of,the,grouping,vertex,for,each,vertex,the,neighbors,function,can,iterate,over,all,neighbors,of,this,vertex,with,the,specified,direction,and,emit,any,number,of,output,elements,including,none,param,neighbors,function,the,group,reduce,function,to,apply,to,the,neighboring,edges,and,vertices,of,each,vertex,param,direction,the,edge,direction,in,out,all,param,t,the,output,type,param,type,info,the,explicit,return,type,return,a,data,set,containing,elements,of,type,t,throws,illegal,argument,exception;public,t,data,set,t,group,reduce,on,neighbors,neighbors,function,with,vertex,value,k,vv,ev,t,neighbors,function,edge,direction,direction,type,information,t,type,info,throws,illegal,argument,exception,switch,direction,case,in,data,set,tuple2,edge,k,ev,vertex,k,vv,edges,with,sources,edges,join,this,vertices,where,0,equal,to,0,return,vertices,co,group,edges,with,sources,where,0,equal,to,f0,f1,with,new,apply,neighbor,co,group,function,k,vv,ev,t,neighbors,function,returns,type,info,case,out,data,set,tuple2,edge,k,ev,vertex,k,vv,edges,with,targets,edges,join,this,vertices,where,1,equal,to,0,return,vertices,co,group,edges,with,targets,where,0,equal,to,f0,f0,with,new,apply,neighbor,co,group,function,k,vv,ev,t,neighbors,function,returns,type,info,case,all,data,set,tuple3,k,edge,k,ev,vertex,k,vv,edges,with,neighbors,edges,flat,map,new,emit,one,edge,with,neighbor,per,node,k,ev,join,this,vertices,where,1,equal,to,0,with,new,project,edge,with,neighbor,k,vv,ev,return,vertices,co,group,edges,with,neighbors,where,0,equal,to,0,with,new,apply,co,group,function,on,all,neighbors,k,vv,ev,t,neighbors,function,returns,type,info,default,throw,new,illegal,argument,exception,illegal,edge,direction
Graph -> public <T> DataSet<T> groupReduceOnNeighbors(NeighborsFunctionWithVertexValue<K, VV, EV, T> neighborsFunction, 			EdgeDirection direction, TypeInformation<T> typeInfo) throws IllegalArgumentException;1475684776;Groups by vertex and computes a GroupReduce transformation over the neighbors (both edges and vertices)_of each vertex. The neighborsFunction applied on the neighbors only has access to both the vertex id_and the vertex value of the grouping vertex.__For each vertex, the neighborsFunction can iterate over all neighbors of this vertex_with the specified direction, and emit any number of output elements, including none.__@param neighborsFunction the group reduce function to apply to the neighboring edges and vertices_of each vertex._@param direction the edge direction (in-, out-, all-)._@param <T> the output type_@param typeInfo the explicit return type_@return a DataSet containing elements of type T_@throws IllegalArgumentException;public <T> DataSet<T> groupReduceOnNeighbors(NeighborsFunctionWithVertexValue<K, VV, EV, T> neighborsFunction,_			EdgeDirection direction, TypeInformation<T> typeInfo) throws IllegalArgumentException {_		switch (direction) {_			case IN:_				_				DataSet<Tuple2<Edge<K, EV>, Vertex<K, VV>>> edgesWithSources = edges_						.join(this.vertices).where(0).equalTo(0)__				return vertices.coGroup(edgesWithSources)_						.where(0).equalTo("f0.f1")_						.with(new ApplyNeighborCoGroupFunction<>(neighborsFunction)).returns(typeInfo)__			case OUT:_				_				DataSet<Tuple2<Edge<K, EV>, Vertex<K, VV>>> edgesWithTargets = edges_						.join(this.vertices).where(1).equalTo(0)__				return vertices.coGroup(edgesWithTargets)_						.where(0).equalTo("f0.f0")_						.with(new ApplyNeighborCoGroupFunction<>(neighborsFunction)).returns(typeInfo)__			case ALL:_				_				DataSet<Tuple3<K, Edge<K, EV>, Vertex<K, VV>>> edgesWithNeighbors = edges_						.flatMap(new EmitOneEdgeWithNeighborPerNode<K, EV>())_						.join(this.vertices).where(1).equalTo(0)_						.with(new ProjectEdgeWithNeighbor<K, VV, EV>())___				return vertices.coGroup(edgesWithNeighbors)_						.where(0).equalTo(0)_						.with(new ApplyCoGroupFunctionOnAllNeighbors<>(neighborsFunction)).returns(typeInfo)__			default:_				throw new IllegalArgumentException("Illegal edge direction")__		}_	};groups,by,vertex,and,computes,a,group,reduce,transformation,over,the,neighbors,both,edges,and,vertices,of,each,vertex,the,neighbors,function,applied,on,the,neighbors,only,has,access,to,both,the,vertex,id,and,the,vertex,value,of,the,grouping,vertex,for,each,vertex,the,neighbors,function,can,iterate,over,all,neighbors,of,this,vertex,with,the,specified,direction,and,emit,any,number,of,output,elements,including,none,param,neighbors,function,the,group,reduce,function,to,apply,to,the,neighboring,edges,and,vertices,of,each,vertex,param,direction,the,edge,direction,in,out,all,param,t,the,output,type,param,type,info,the,explicit,return,type,return,a,data,set,containing,elements,of,type,t,throws,illegal,argument,exception;public,t,data,set,t,group,reduce,on,neighbors,neighbors,function,with,vertex,value,k,vv,ev,t,neighbors,function,edge,direction,direction,type,information,t,type,info,throws,illegal,argument,exception,switch,direction,case,in,data,set,tuple2,edge,k,ev,vertex,k,vv,edges,with,sources,edges,join,this,vertices,where,0,equal,to,0,return,vertices,co,group,edges,with,sources,where,0,equal,to,f0,f1,with,new,apply,neighbor,co,group,function,neighbors,function,returns,type,info,case,out,data,set,tuple2,edge,k,ev,vertex,k,vv,edges,with,targets,edges,join,this,vertices,where,1,equal,to,0,return,vertices,co,group,edges,with,targets,where,0,equal,to,f0,f0,with,new,apply,neighbor,co,group,function,neighbors,function,returns,type,info,case,all,data,set,tuple3,k,edge,k,ev,vertex,k,vv,edges,with,neighbors,edges,flat,map,new,emit,one,edge,with,neighbor,per,node,k,ev,join,this,vertices,where,1,equal,to,0,with,new,project,edge,with,neighbor,k,vv,ev,return,vertices,co,group,edges,with,neighbors,where,0,equal,to,0,with,new,apply,co,group,function,on,all,neighbors,neighbors,function,returns,type,info,default,throw,new,illegal,argument,exception,illegal,edge,direction
Graph -> public <T> DataSet<T> groupReduceOnNeighbors(NeighborsFunctionWithVertexValue<K, VV, EV, T> neighborsFunction, 			EdgeDirection direction, TypeInformation<T> typeInfo) throws IllegalArgumentException;1475685606;Groups by vertex and computes a GroupReduce transformation over the neighbors (both edges and vertices)_of each vertex. The neighborsFunction applied on the neighbors only has access to both the vertex id_and the vertex value of the grouping vertex.__For each vertex, the neighborsFunction can iterate over all neighbors of this vertex_with the specified direction, and emit any number of output elements, including none.__@param neighborsFunction the group reduce function to apply to the neighboring edges and vertices_of each vertex._@param direction the edge direction (in-, out-, all-)._@param <T> the output type_@param typeInfo the explicit return type_@return a DataSet containing elements of type T_@throws IllegalArgumentException;public <T> DataSet<T> groupReduceOnNeighbors(NeighborsFunctionWithVertexValue<K, VV, EV, T> neighborsFunction,_			EdgeDirection direction, TypeInformation<T> typeInfo) throws IllegalArgumentException {_		switch (direction) {_			case IN:_				_				DataSet<Tuple2<Edge<K, EV>, Vertex<K, VV>>> edgesWithSources = edges_						.join(this.vertices).where(0).equalTo(0)__				return vertices.coGroup(edgesWithSources)_						.where(0).equalTo("f0.f1")_						.with(new ApplyNeighborCoGroupFunction<>(neighborsFunction)).returns(typeInfo)__			case OUT:_				_				DataSet<Tuple2<Edge<K, EV>, Vertex<K, VV>>> edgesWithTargets = edges_						.join(this.vertices).where(1).equalTo(0)__				return vertices.coGroup(edgesWithTargets)_						.where(0).equalTo("f0.f0")_						.with(new ApplyNeighborCoGroupFunction<>(neighborsFunction)).returns(typeInfo)__			case ALL:_				_				DataSet<Tuple3<K, Edge<K, EV>, Vertex<K, VV>>> edgesWithNeighbors = edges_						.flatMap(new EmitOneEdgeWithNeighborPerNode<K, EV>())_						.join(this.vertices).where(1).equalTo(0)_						.with(new ProjectEdgeWithNeighbor<K, VV, EV>())___				return vertices.coGroup(edgesWithNeighbors)_						.where(0).equalTo(0)_						.with(new ApplyCoGroupFunctionOnAllNeighbors<>(neighborsFunction)).returns(typeInfo)__			default:_				throw new IllegalArgumentException("Illegal edge direction")__		}_	};groups,by,vertex,and,computes,a,group,reduce,transformation,over,the,neighbors,both,edges,and,vertices,of,each,vertex,the,neighbors,function,applied,on,the,neighbors,only,has,access,to,both,the,vertex,id,and,the,vertex,value,of,the,grouping,vertex,for,each,vertex,the,neighbors,function,can,iterate,over,all,neighbors,of,this,vertex,with,the,specified,direction,and,emit,any,number,of,output,elements,including,none,param,neighbors,function,the,group,reduce,function,to,apply,to,the,neighboring,edges,and,vertices,of,each,vertex,param,direction,the,edge,direction,in,out,all,param,t,the,output,type,param,type,info,the,explicit,return,type,return,a,data,set,containing,elements,of,type,t,throws,illegal,argument,exception;public,t,data,set,t,group,reduce,on,neighbors,neighbors,function,with,vertex,value,k,vv,ev,t,neighbors,function,edge,direction,direction,type,information,t,type,info,throws,illegal,argument,exception,switch,direction,case,in,data,set,tuple2,edge,k,ev,vertex,k,vv,edges,with,sources,edges,join,this,vertices,where,0,equal,to,0,return,vertices,co,group,edges,with,sources,where,0,equal,to,f0,f1,with,new,apply,neighbor,co,group,function,neighbors,function,returns,type,info,case,out,data,set,tuple2,edge,k,ev,vertex,k,vv,edges,with,targets,edges,join,this,vertices,where,1,equal,to,0,return,vertices,co,group,edges,with,targets,where,0,equal,to,f0,f0,with,new,apply,neighbor,co,group,function,neighbors,function,returns,type,info,case,all,data,set,tuple3,k,edge,k,ev,vertex,k,vv,edges,with,neighbors,edges,flat,map,new,emit,one,edge,with,neighbor,per,node,k,ev,join,this,vertices,where,1,equal,to,0,with,new,project,edge,with,neighbor,k,vv,ev,return,vertices,co,group,edges,with,neighbors,where,0,equal,to,0,with,new,apply,co,group,function,on,all,neighbors,neighbors,function,returns,type,info,default,throw,new,illegal,argument,exception,illegal,edge,direction
Graph -> public <T> DataSet<T> groupReduceOnNeighbors(NeighborsFunctionWithVertexValue<K, VV, EV, T> neighborsFunction, 			EdgeDirection direction, TypeInformation<T> typeInfo) throws IllegalArgumentException;1481745825;Groups by vertex and computes a GroupReduce transformation over the neighbors (both edges and vertices)_of each vertex. The neighborsFunction applied on the neighbors only has access to both the vertex id_and the vertex value of the grouping vertex.__For each vertex, the neighborsFunction can iterate over all neighbors of this vertex_with the specified direction, and emit any number of output elements, including none.__@param neighborsFunction the group reduce function to apply to the neighboring edges and vertices_of each vertex._@param direction the edge direction (in-, out-, all-)._@param <T> the output type_@param typeInfo the explicit return type_@return a DataSet containing elements of type T_@throws IllegalArgumentException;public <T> DataSet<T> groupReduceOnNeighbors(NeighborsFunctionWithVertexValue<K, VV, EV, T> neighborsFunction,_			EdgeDirection direction, TypeInformation<T> typeInfo) throws IllegalArgumentException {_		switch (direction) {_			case IN:_				_				DataSet<Tuple2<Edge<K, EV>, Vertex<K, VV>>> edgesWithSources = edges_						.join(this.vertices).where(0).equalTo(0).name("Edge with source vertex")__				return vertices.coGroup(edgesWithSources)_						.where(0).equalTo("f0.f1")_						.with(new ApplyNeighborCoGroupFunction<>(neighborsFunction))_							.name("Neighbors function").returns(typeInfo)__			case OUT:_				_				DataSet<Tuple2<Edge<K, EV>, Vertex<K, VV>>> edgesWithTargets = edges_						.join(this.vertices).where(1).equalTo(0).name("Edge with target vertex")__				return vertices.coGroup(edgesWithTargets)_						.where(0).equalTo("f0.f0")_						.with(new ApplyNeighborCoGroupFunction<>(neighborsFunction))_							.name("Neighbors function").returns(typeInfo)__			case ALL:_				_				DataSet<Tuple3<K, Edge<K, EV>, Vertex<K, VV>>> edgesWithNeighbors = edges_						.flatMap(new EmitOneEdgeWithNeighborPerNode<K, EV>()).name("Forward and reverse edges")_						.join(this.vertices).where(1).equalTo(0)_						.with(new ProjectEdgeWithNeighbor<K, VV, EV>()).name("Edge with vertex")___				return vertices.coGroup(edgesWithNeighbors)_						.where(0).equalTo(0)_						.with(new ApplyCoGroupFunctionOnAllNeighbors<>(neighborsFunction))_							.name("Neighbors function").returns(typeInfo)__			default:_				throw new IllegalArgumentException("Illegal edge direction")__		}_	};groups,by,vertex,and,computes,a,group,reduce,transformation,over,the,neighbors,both,edges,and,vertices,of,each,vertex,the,neighbors,function,applied,on,the,neighbors,only,has,access,to,both,the,vertex,id,and,the,vertex,value,of,the,grouping,vertex,for,each,vertex,the,neighbors,function,can,iterate,over,all,neighbors,of,this,vertex,with,the,specified,direction,and,emit,any,number,of,output,elements,including,none,param,neighbors,function,the,group,reduce,function,to,apply,to,the,neighboring,edges,and,vertices,of,each,vertex,param,direction,the,edge,direction,in,out,all,param,t,the,output,type,param,type,info,the,explicit,return,type,return,a,data,set,containing,elements,of,type,t,throws,illegal,argument,exception;public,t,data,set,t,group,reduce,on,neighbors,neighbors,function,with,vertex,value,k,vv,ev,t,neighbors,function,edge,direction,direction,type,information,t,type,info,throws,illegal,argument,exception,switch,direction,case,in,data,set,tuple2,edge,k,ev,vertex,k,vv,edges,with,sources,edges,join,this,vertices,where,0,equal,to,0,name,edge,with,source,vertex,return,vertices,co,group,edges,with,sources,where,0,equal,to,f0,f1,with,new,apply,neighbor,co,group,function,neighbors,function,name,neighbors,function,returns,type,info,case,out,data,set,tuple2,edge,k,ev,vertex,k,vv,edges,with,targets,edges,join,this,vertices,where,1,equal,to,0,name,edge,with,target,vertex,return,vertices,co,group,edges,with,targets,where,0,equal,to,f0,f0,with,new,apply,neighbor,co,group,function,neighbors,function,name,neighbors,function,returns,type,info,case,all,data,set,tuple3,k,edge,k,ev,vertex,k,vv,edges,with,neighbors,edges,flat,map,new,emit,one,edge,with,neighbor,per,node,k,ev,name,forward,and,reverse,edges,join,this,vertices,where,1,equal,to,0,with,new,project,edge,with,neighbor,k,vv,ev,name,edge,with,vertex,return,vertices,co,group,edges,with,neighbors,where,0,equal,to,0,with,new,apply,co,group,function,on,all,neighbors,neighbors,function,name,neighbors,function,returns,type,info,default,throw,new,illegal,argument,exception,illegal,edge,direction
Graph -> public <T> DataSet<T> groupReduceOnNeighbors(NeighborsFunctionWithVertexValue<K, VV, EV, T> neighborsFunction, 			EdgeDirection direction, TypeInformation<T> typeInfo) throws IllegalArgumentException;1481881009;Groups by vertex and computes a GroupReduce transformation over the neighbors (both edges and vertices)_of each vertex. The neighborsFunction applied on the neighbors only has access to both the vertex id_and the vertex value of the grouping vertex.__For each vertex, the neighborsFunction can iterate over all neighbors of this vertex_with the specified direction, and emit any number of output elements, including none.__@param neighborsFunction the group reduce function to apply to the neighboring edges and vertices_of each vertex._@param direction the edge direction (in-, out-, all-)._@param <T> the output type_@param typeInfo the explicit return type_@return a DataSet containing elements of type T_@throws IllegalArgumentException;public <T> DataSet<T> groupReduceOnNeighbors(NeighborsFunctionWithVertexValue<K, VV, EV, T> neighborsFunction,_			EdgeDirection direction, TypeInformation<T> typeInfo) throws IllegalArgumentException {_		switch (direction) {_			case IN:_				_				DataSet<Tuple2<Edge<K, EV>, Vertex<K, VV>>> edgesWithSources = edges_						.join(this.vertices).where(0).equalTo(0).name("Edge with source vertex")__				return vertices.coGroup(edgesWithSources)_						.where(0).equalTo("f0.f1")_						.with(new ApplyNeighborCoGroupFunction<>(neighborsFunction))_							.name("Neighbors function").returns(typeInfo)__			case OUT:_				_				DataSet<Tuple2<Edge<K, EV>, Vertex<K, VV>>> edgesWithTargets = edges_						.join(this.vertices).where(1).equalTo(0).name("Edge with target vertex")__				return vertices.coGroup(edgesWithTargets)_						.where(0).equalTo("f0.f0")_						.with(new ApplyNeighborCoGroupFunction<>(neighborsFunction))_							.name("Neighbors function").returns(typeInfo)__			case ALL:_				_				DataSet<Tuple3<K, Edge<K, EV>, Vertex<K, VV>>> edgesWithNeighbors = edges_						.flatMap(new EmitOneEdgeWithNeighborPerNode<K, EV>()).name("Forward and reverse edges")_						.join(this.vertices).where(1).equalTo(0)_						.with(new ProjectEdgeWithNeighbor<K, VV, EV>()).name("Edge with vertex")___				return vertices.coGroup(edgesWithNeighbors)_						.where(0).equalTo(0)_						.with(new ApplyCoGroupFunctionOnAllNeighbors<>(neighborsFunction))_							.name("Neighbors function").returns(typeInfo)__			default:_				throw new IllegalArgumentException("Illegal edge direction")__		}_	};groups,by,vertex,and,computes,a,group,reduce,transformation,over,the,neighbors,both,edges,and,vertices,of,each,vertex,the,neighbors,function,applied,on,the,neighbors,only,has,access,to,both,the,vertex,id,and,the,vertex,value,of,the,grouping,vertex,for,each,vertex,the,neighbors,function,can,iterate,over,all,neighbors,of,this,vertex,with,the,specified,direction,and,emit,any,number,of,output,elements,including,none,param,neighbors,function,the,group,reduce,function,to,apply,to,the,neighboring,edges,and,vertices,of,each,vertex,param,direction,the,edge,direction,in,out,all,param,t,the,output,type,param,type,info,the,explicit,return,type,return,a,data,set,containing,elements,of,type,t,throws,illegal,argument,exception;public,t,data,set,t,group,reduce,on,neighbors,neighbors,function,with,vertex,value,k,vv,ev,t,neighbors,function,edge,direction,direction,type,information,t,type,info,throws,illegal,argument,exception,switch,direction,case,in,data,set,tuple2,edge,k,ev,vertex,k,vv,edges,with,sources,edges,join,this,vertices,where,0,equal,to,0,name,edge,with,source,vertex,return,vertices,co,group,edges,with,sources,where,0,equal,to,f0,f1,with,new,apply,neighbor,co,group,function,neighbors,function,name,neighbors,function,returns,type,info,case,out,data,set,tuple2,edge,k,ev,vertex,k,vv,edges,with,targets,edges,join,this,vertices,where,1,equal,to,0,name,edge,with,target,vertex,return,vertices,co,group,edges,with,targets,where,0,equal,to,f0,f0,with,new,apply,neighbor,co,group,function,neighbors,function,name,neighbors,function,returns,type,info,case,all,data,set,tuple3,k,edge,k,ev,vertex,k,vv,edges,with,neighbors,edges,flat,map,new,emit,one,edge,with,neighbor,per,node,k,ev,name,forward,and,reverse,edges,join,this,vertices,where,1,equal,to,0,with,new,project,edge,with,neighbor,k,vv,ev,name,edge,with,vertex,return,vertices,co,group,edges,with,neighbors,where,0,equal,to,0,with,new,apply,co,group,function,on,all,neighbors,neighbors,function,name,neighbors,function,returns,type,info,default,throw,new,illegal,argument,exception,illegal,edge,direction
Graph -> public <T> DataSet<T> groupReduceOnNeighbors(NeighborsFunctionWithVertexValue<K, VV, EV, T> neighborsFunction, 			EdgeDirection direction, TypeInformation<T> typeInfo) throws IllegalArgumentException;1484160227;Groups by vertex and computes a GroupReduce transformation over the neighbors (both edges and vertices)_of each vertex. The neighborsFunction applied on the neighbors only has access to both the vertex id_and the vertex value of the grouping vertex.__For each vertex, the neighborsFunction can iterate over all neighbors of this vertex_with the specified direction, and emit any number of output elements, including none.__@param neighborsFunction the group reduce function to apply to the neighboring edges and vertices_of each vertex._@param direction the edge direction (in-, out-, all-)._@param <T> the output type_@param typeInfo the explicit return type_@return a DataSet containing elements of type T_@throws IllegalArgumentException;public <T> DataSet<T> groupReduceOnNeighbors(NeighborsFunctionWithVertexValue<K, VV, EV, T> neighborsFunction,_			EdgeDirection direction, TypeInformation<T> typeInfo) throws IllegalArgumentException {_		switch (direction) {_			case IN:_				_				DataSet<Tuple2<Edge<K, EV>, Vertex<K, VV>>> edgesWithSources = edges_						.join(this.vertices).where(0).equalTo(0).name("Edge with source vertex")__				return vertices.coGroup(edgesWithSources)_						.where(0).equalTo("f0.f1")_						.with(new ApplyNeighborCoGroupFunction<>(neighborsFunction))_							.name("Neighbors function").returns(typeInfo)__			case OUT:_				_				DataSet<Tuple2<Edge<K, EV>, Vertex<K, VV>>> edgesWithTargets = edges_						.join(this.vertices).where(1).equalTo(0).name("Edge with target vertex")__				return vertices.coGroup(edgesWithTargets)_						.where(0).equalTo("f0.f0")_						.with(new ApplyNeighborCoGroupFunction<>(neighborsFunction))_							.name("Neighbors function").returns(typeInfo)__			case ALL:_				_				DataSet<Tuple3<K, Edge<K, EV>, Vertex<K, VV>>> edgesWithNeighbors = edges_						.flatMap(new EmitOneEdgeWithNeighborPerNode<K, EV>()).name("Forward and reverse edges")_						.join(this.vertices).where(1).equalTo(0)_						.with(new ProjectEdgeWithNeighbor<K, VV, EV>()).name("Edge with vertex")___				return vertices.coGroup(edgesWithNeighbors)_						.where(0).equalTo(0)_						.with(new ApplyCoGroupFunctionOnAllNeighbors<>(neighborsFunction))_							.name("Neighbors function").returns(typeInfo)__			default:_				throw new IllegalArgumentException("Illegal edge direction")__		}_	};groups,by,vertex,and,computes,a,group,reduce,transformation,over,the,neighbors,both,edges,and,vertices,of,each,vertex,the,neighbors,function,applied,on,the,neighbors,only,has,access,to,both,the,vertex,id,and,the,vertex,value,of,the,grouping,vertex,for,each,vertex,the,neighbors,function,can,iterate,over,all,neighbors,of,this,vertex,with,the,specified,direction,and,emit,any,number,of,output,elements,including,none,param,neighbors,function,the,group,reduce,function,to,apply,to,the,neighboring,edges,and,vertices,of,each,vertex,param,direction,the,edge,direction,in,out,all,param,t,the,output,type,param,type,info,the,explicit,return,type,return,a,data,set,containing,elements,of,type,t,throws,illegal,argument,exception;public,t,data,set,t,group,reduce,on,neighbors,neighbors,function,with,vertex,value,k,vv,ev,t,neighbors,function,edge,direction,direction,type,information,t,type,info,throws,illegal,argument,exception,switch,direction,case,in,data,set,tuple2,edge,k,ev,vertex,k,vv,edges,with,sources,edges,join,this,vertices,where,0,equal,to,0,name,edge,with,source,vertex,return,vertices,co,group,edges,with,sources,where,0,equal,to,f0,f1,with,new,apply,neighbor,co,group,function,neighbors,function,name,neighbors,function,returns,type,info,case,out,data,set,tuple2,edge,k,ev,vertex,k,vv,edges,with,targets,edges,join,this,vertices,where,1,equal,to,0,name,edge,with,target,vertex,return,vertices,co,group,edges,with,targets,where,0,equal,to,f0,f0,with,new,apply,neighbor,co,group,function,neighbors,function,name,neighbors,function,returns,type,info,case,all,data,set,tuple3,k,edge,k,ev,vertex,k,vv,edges,with,neighbors,edges,flat,map,new,emit,one,edge,with,neighbor,per,node,k,ev,name,forward,and,reverse,edges,join,this,vertices,where,1,equal,to,0,with,new,project,edge,with,neighbor,k,vv,ev,name,edge,with,vertex,return,vertices,co,group,edges,with,neighbors,where,0,equal,to,0,with,new,apply,co,group,function,on,all,neighbors,neighbors,function,name,neighbors,function,returns,type,info,default,throw,new,illegal,argument,exception,illegal,edge,direction
Graph -> public <T> DataSet<T> groupReduceOnNeighbors(NeighborsFunctionWithVertexValue<K, VV, EV, T> neighborsFunction, 			EdgeDirection direction, TypeInformation<T> typeInfo) throws IllegalArgumentException;1484685504;Groups by vertex and computes a GroupReduce transformation over the neighbors (both edges and vertices)_of each vertex. The neighborsFunction applied on the neighbors only has access to both the vertex id_and the vertex value of the grouping vertex.__For each vertex, the neighborsFunction can iterate over all neighbors of this vertex_with the specified direction, and emit any number of output elements, including none.__@param neighborsFunction the group reduce function to apply to the neighboring edges and vertices_of each vertex._@param direction the edge direction (in-, out-, all-)._@param <T> the output type_@param typeInfo the explicit return type_@return a DataSet containing elements of type T_@throws IllegalArgumentException;public <T> DataSet<T> groupReduceOnNeighbors(NeighborsFunctionWithVertexValue<K, VV, EV, T> neighborsFunction,_			EdgeDirection direction, TypeInformation<T> typeInfo) throws IllegalArgumentException {_		switch (direction) {_			case IN:_				_				DataSet<Tuple2<Edge<K, EV>, Vertex<K, VV>>> edgesWithSources = edges_						.join(this.vertices).where(0).equalTo(0).name("Edge with source vertex")__				return vertices.coGroup(edgesWithSources)_						.where(0).equalTo("f0.f1")_						.with(new ApplyNeighborCoGroupFunction<>(neighborsFunction))_							.name("Neighbors function").returns(typeInfo)__			case OUT:_				_				DataSet<Tuple2<Edge<K, EV>, Vertex<K, VV>>> edgesWithTargets = edges_						.join(this.vertices).where(1).equalTo(0).name("Edge with target vertex")__				return vertices.coGroup(edgesWithTargets)_						.where(0).equalTo("f0.f0")_						.with(new ApplyNeighborCoGroupFunction<>(neighborsFunction))_							.name("Neighbors function").returns(typeInfo)__			case ALL:_				_				DataSet<Tuple3<K, Edge<K, EV>, Vertex<K, VV>>> edgesWithNeighbors = edges_						.flatMap(new EmitOneEdgeWithNeighborPerNode<K, EV>()).name("Forward and reverse edges")_						.join(this.vertices).where(1).equalTo(0)_						.with(new ProjectEdgeWithNeighbor<K, VV, EV>()).name("Edge with vertex")___				return vertices.coGroup(edgesWithNeighbors)_						.where(0).equalTo(0)_						.with(new ApplyCoGroupFunctionOnAllNeighbors<>(neighborsFunction))_							.name("Neighbors function").returns(typeInfo)__			default:_				throw new IllegalArgumentException("Illegal edge direction")__		}_	};groups,by,vertex,and,computes,a,group,reduce,transformation,over,the,neighbors,both,edges,and,vertices,of,each,vertex,the,neighbors,function,applied,on,the,neighbors,only,has,access,to,both,the,vertex,id,and,the,vertex,value,of,the,grouping,vertex,for,each,vertex,the,neighbors,function,can,iterate,over,all,neighbors,of,this,vertex,with,the,specified,direction,and,emit,any,number,of,output,elements,including,none,param,neighbors,function,the,group,reduce,function,to,apply,to,the,neighboring,edges,and,vertices,of,each,vertex,param,direction,the,edge,direction,in,out,all,param,t,the,output,type,param,type,info,the,explicit,return,type,return,a,data,set,containing,elements,of,type,t,throws,illegal,argument,exception;public,t,data,set,t,group,reduce,on,neighbors,neighbors,function,with,vertex,value,k,vv,ev,t,neighbors,function,edge,direction,direction,type,information,t,type,info,throws,illegal,argument,exception,switch,direction,case,in,data,set,tuple2,edge,k,ev,vertex,k,vv,edges,with,sources,edges,join,this,vertices,where,0,equal,to,0,name,edge,with,source,vertex,return,vertices,co,group,edges,with,sources,where,0,equal,to,f0,f1,with,new,apply,neighbor,co,group,function,neighbors,function,name,neighbors,function,returns,type,info,case,out,data,set,tuple2,edge,k,ev,vertex,k,vv,edges,with,targets,edges,join,this,vertices,where,1,equal,to,0,name,edge,with,target,vertex,return,vertices,co,group,edges,with,targets,where,0,equal,to,f0,f0,with,new,apply,neighbor,co,group,function,neighbors,function,name,neighbors,function,returns,type,info,case,all,data,set,tuple3,k,edge,k,ev,vertex,k,vv,edges,with,neighbors,edges,flat,map,new,emit,one,edge,with,neighbor,per,node,k,ev,name,forward,and,reverse,edges,join,this,vertices,where,1,equal,to,0,with,new,project,edge,with,neighbor,k,vv,ev,name,edge,with,vertex,return,vertices,co,group,edges,with,neighbors,where,0,equal,to,0,with,new,apply,co,group,function,on,all,neighbors,neighbors,function,name,neighbors,function,returns,type,info,default,throw,new,illegal,argument,exception,illegal,edge,direction
Graph -> public <T> DataSet<T> groupReduceOnNeighbors(NeighborsFunctionWithVertexValue<K, VV, EV, T> neighborsFunction, 			EdgeDirection direction, TypeInformation<T> typeInfo) throws IllegalArgumentException;1489068942;Groups by vertex and computes a GroupReduce transformation over the neighbors (both edges and vertices)_of each vertex. The neighborsFunction applied on the neighbors only has access to both the vertex id_and the vertex value of the grouping vertex.__For each vertex, the neighborsFunction can iterate over all neighbors of this vertex_with the specified direction, and emit any number of output elements, including none.__@param neighborsFunction the group reduce function to apply to the neighboring edges and vertices_of each vertex._@param direction the edge direction (in-, out-, all-)._@param <T> the output type_@param typeInfo the explicit return type_@return a DataSet containing elements of type T_@throws IllegalArgumentException;public <T> DataSet<T> groupReduceOnNeighbors(NeighborsFunctionWithVertexValue<K, VV, EV, T> neighborsFunction,_			EdgeDirection direction, TypeInformation<T> typeInfo) throws IllegalArgumentException {_		switch (direction) {_			case IN:_				_				DataSet<Tuple2<Edge<K, EV>, Vertex<K, VV>>> edgesWithSources = edges_						.join(this.vertices).where(0).equalTo(0).name("Edge with source vertex")__				return vertices.coGroup(edgesWithSources)_						.where(0).equalTo("f0.f1")_						.with(new ApplyNeighborCoGroupFunction<>(neighborsFunction))_							.name("Neighbors function").returns(typeInfo)__			case OUT:_				_				DataSet<Tuple2<Edge<K, EV>, Vertex<K, VV>>> edgesWithTargets = edges_						.join(this.vertices).where(1).equalTo(0).name("Edge with target vertex")__				return vertices.coGroup(edgesWithTargets)_						.where(0).equalTo("f0.f0")_						.with(new ApplyNeighborCoGroupFunction<>(neighborsFunction))_							.name("Neighbors function").returns(typeInfo)__			case ALL:_				_				DataSet<Tuple3<K, Edge<K, EV>, Vertex<K, VV>>> edgesWithNeighbors = edges_						.flatMap(new EmitOneEdgeWithNeighborPerNode<K, EV>()).name("Forward and reverse edges")_						.join(this.vertices).where(1).equalTo(0)_						.with(new ProjectEdgeWithNeighbor<K, VV, EV>()).name("Edge with vertex")___				return vertices.coGroup(edgesWithNeighbors)_						.where(0).equalTo(0)_						.with(new ApplyCoGroupFunctionOnAllNeighbors<>(neighborsFunction))_							.name("Neighbors function").returns(typeInfo)__			default:_				throw new IllegalArgumentException("Illegal edge direction")__		}_	};groups,by,vertex,and,computes,a,group,reduce,transformation,over,the,neighbors,both,edges,and,vertices,of,each,vertex,the,neighbors,function,applied,on,the,neighbors,only,has,access,to,both,the,vertex,id,and,the,vertex,value,of,the,grouping,vertex,for,each,vertex,the,neighbors,function,can,iterate,over,all,neighbors,of,this,vertex,with,the,specified,direction,and,emit,any,number,of,output,elements,including,none,param,neighbors,function,the,group,reduce,function,to,apply,to,the,neighboring,edges,and,vertices,of,each,vertex,param,direction,the,edge,direction,in,out,all,param,t,the,output,type,param,type,info,the,explicit,return,type,return,a,data,set,containing,elements,of,type,t,throws,illegal,argument,exception;public,t,data,set,t,group,reduce,on,neighbors,neighbors,function,with,vertex,value,k,vv,ev,t,neighbors,function,edge,direction,direction,type,information,t,type,info,throws,illegal,argument,exception,switch,direction,case,in,data,set,tuple2,edge,k,ev,vertex,k,vv,edges,with,sources,edges,join,this,vertices,where,0,equal,to,0,name,edge,with,source,vertex,return,vertices,co,group,edges,with,sources,where,0,equal,to,f0,f1,with,new,apply,neighbor,co,group,function,neighbors,function,name,neighbors,function,returns,type,info,case,out,data,set,tuple2,edge,k,ev,vertex,k,vv,edges,with,targets,edges,join,this,vertices,where,1,equal,to,0,name,edge,with,target,vertex,return,vertices,co,group,edges,with,targets,where,0,equal,to,f0,f0,with,new,apply,neighbor,co,group,function,neighbors,function,name,neighbors,function,returns,type,info,case,all,data,set,tuple3,k,edge,k,ev,vertex,k,vv,edges,with,neighbors,edges,flat,map,new,emit,one,edge,with,neighbor,per,node,k,ev,name,forward,and,reverse,edges,join,this,vertices,where,1,equal,to,0,with,new,project,edge,with,neighbor,k,vv,ev,name,edge,with,vertex,return,vertices,co,group,edges,with,neighbors,where,0,equal,to,0,with,new,apply,co,group,function,on,all,neighbors,neighbors,function,name,neighbors,function,returns,type,info,default,throw,new,illegal,argument,exception,illegal,edge,direction
Graph -> public <T> DataSet<T> groupReduceOnNeighbors(NeighborsFunctionWithVertexValue<K, VV, EV, T> neighborsFunction, 			EdgeDirection direction, TypeInformation<T> typeInfo) throws IllegalArgumentException;1490973446;Groups by vertex and computes a GroupReduce transformation over the neighbors (both edges and vertices)_of each vertex. The neighborsFunction applied on the neighbors only has access to both the vertex id_and the vertex value of the grouping vertex.__For each vertex, the neighborsFunction can iterate over all neighbors of this vertex_with the specified direction, and emit any number of output elements, including none.__@param neighborsFunction the group reduce function to apply to the neighboring edges and vertices_of each vertex._@param direction the edge direction (in-, out-, all-)._@param <T> the output type_@param typeInfo the explicit return type_@return a DataSet containing elements of type T_@throws IllegalArgumentException;public <T> DataSet<T> groupReduceOnNeighbors(NeighborsFunctionWithVertexValue<K, VV, EV, T> neighborsFunction,_			EdgeDirection direction, TypeInformation<T> typeInfo) throws IllegalArgumentException {_		switch (direction) {_			case IN:_				_				DataSet<Tuple2<Edge<K, EV>, Vertex<K, VV>>> edgesWithSources = edges_						.join(this.vertices).where(0).equalTo(0).name("Edge with source vertex")__				return vertices.coGroup(edgesWithSources)_						.where(0).equalTo("f0.f1")_						.with(new ApplyNeighborCoGroupFunction<>(neighborsFunction))_							.name("Neighbors function").returns(typeInfo)__			case OUT:_				_				DataSet<Tuple2<Edge<K, EV>, Vertex<K, VV>>> edgesWithTargets = edges_						.join(this.vertices).where(1).equalTo(0).name("Edge with target vertex")__				return vertices.coGroup(edgesWithTargets)_						.where(0).equalTo("f0.f0")_						.with(new ApplyNeighborCoGroupFunction<>(neighborsFunction))_							.name("Neighbors function").returns(typeInfo)__			case ALL:_				_				DataSet<Tuple3<K, Edge<K, EV>, Vertex<K, VV>>> edgesWithNeighbors = edges_						.flatMap(new EmitOneEdgeWithNeighborPerNode<K, EV>()).name("Forward and reverse edges")_						.join(this.vertices).where(1).equalTo(0)_						.with(new ProjectEdgeWithNeighbor<K, VV, EV>()).name("Edge with vertex")___				return vertices.coGroup(edgesWithNeighbors)_						.where(0).equalTo(0)_						.with(new ApplyCoGroupFunctionOnAllNeighbors<>(neighborsFunction))_							.name("Neighbors function").returns(typeInfo)__			default:_				throw new IllegalArgumentException("Illegal edge direction")__		}_	};groups,by,vertex,and,computes,a,group,reduce,transformation,over,the,neighbors,both,edges,and,vertices,of,each,vertex,the,neighbors,function,applied,on,the,neighbors,only,has,access,to,both,the,vertex,id,and,the,vertex,value,of,the,grouping,vertex,for,each,vertex,the,neighbors,function,can,iterate,over,all,neighbors,of,this,vertex,with,the,specified,direction,and,emit,any,number,of,output,elements,including,none,param,neighbors,function,the,group,reduce,function,to,apply,to,the,neighboring,edges,and,vertices,of,each,vertex,param,direction,the,edge,direction,in,out,all,param,t,the,output,type,param,type,info,the,explicit,return,type,return,a,data,set,containing,elements,of,type,t,throws,illegal,argument,exception;public,t,data,set,t,group,reduce,on,neighbors,neighbors,function,with,vertex,value,k,vv,ev,t,neighbors,function,edge,direction,direction,type,information,t,type,info,throws,illegal,argument,exception,switch,direction,case,in,data,set,tuple2,edge,k,ev,vertex,k,vv,edges,with,sources,edges,join,this,vertices,where,0,equal,to,0,name,edge,with,source,vertex,return,vertices,co,group,edges,with,sources,where,0,equal,to,f0,f1,with,new,apply,neighbor,co,group,function,neighbors,function,name,neighbors,function,returns,type,info,case,out,data,set,tuple2,edge,k,ev,vertex,k,vv,edges,with,targets,edges,join,this,vertices,where,1,equal,to,0,name,edge,with,target,vertex,return,vertices,co,group,edges,with,targets,where,0,equal,to,f0,f0,with,new,apply,neighbor,co,group,function,neighbors,function,name,neighbors,function,returns,type,info,case,all,data,set,tuple3,k,edge,k,ev,vertex,k,vv,edges,with,neighbors,edges,flat,map,new,emit,one,edge,with,neighbor,per,node,k,ev,name,forward,and,reverse,edges,join,this,vertices,where,1,equal,to,0,with,new,project,edge,with,neighbor,k,vv,ev,name,edge,with,vertex,return,vertices,co,group,edges,with,neighbors,where,0,equal,to,0,with,new,apply,co,group,function,on,all,neighbors,neighbors,function,name,neighbors,function,returns,type,info,default,throw,new,illegal,argument,exception,illegal,edge,direction
Graph -> public <T> DataSet<T> groupReduceOnNeighbors(NeighborsFunctionWithVertexValue<K, VV, EV, T> neighborsFunction, 			EdgeDirection direction, TypeInformation<T> typeInfo) throws IllegalArgumentException;1495819075;Groups by vertex and computes a GroupReduce transformation over the neighbors (both edges and vertices)_of each vertex. The neighborsFunction applied on the neighbors only has access to both the vertex id_and the vertex value of the grouping vertex.__<p>For each vertex, the neighborsFunction can iterate over all neighbors of this vertex_with the specified direction, and emit any number of output elements, including none.__@param neighborsFunction the group reduce function to apply to the neighboring edges and vertices_of each vertex._@param direction the edge direction (in-, out-, all-)._@param <T> the output type_@param typeInfo the explicit return type_@return a DataSet containing elements of type T_@throws IllegalArgumentException;public <T> DataSet<T> groupReduceOnNeighbors(NeighborsFunctionWithVertexValue<K, VV, EV, T> neighborsFunction,_			EdgeDirection direction, TypeInformation<T> typeInfo) throws IllegalArgumentException {_		switch (direction) {_			case IN:_				_				DataSet<Tuple2<Edge<K, EV>, Vertex<K, VV>>> edgesWithSources = edges_						.join(this.vertices).where(0).equalTo(0).name("Edge with source vertex")__				return vertices.coGroup(edgesWithSources)_						.where(0).equalTo("f0.f1")_						.with(new ApplyNeighborCoGroupFunction<>(neighborsFunction))_							.name("Neighbors function").returns(typeInfo)__			case OUT:_				_				DataSet<Tuple2<Edge<K, EV>, Vertex<K, VV>>> edgesWithTargets = edges_						.join(this.vertices).where(1).equalTo(0).name("Edge with target vertex")__				return vertices.coGroup(edgesWithTargets)_						.where(0).equalTo("f0.f0")_						.with(new ApplyNeighborCoGroupFunction<>(neighborsFunction))_							.name("Neighbors function").returns(typeInfo)__			case ALL:_				_				DataSet<Tuple3<K, Edge<K, EV>, Vertex<K, VV>>> edgesWithNeighbors = edges_						.flatMap(new EmitOneEdgeWithNeighborPerNode<K, EV>()).name("Forward and reverse edges")_						.join(this.vertices).where(1).equalTo(0)_						.with(new ProjectEdgeWithNeighbor<K, VV, EV>()).name("Edge with vertex")___				return vertices.coGroup(edgesWithNeighbors)_						.where(0).equalTo(0)_						.with(new ApplyCoGroupFunctionOnAllNeighbors<>(neighborsFunction))_							.name("Neighbors function").returns(typeInfo)__			default:_				throw new IllegalArgumentException("Illegal edge direction")__		}_	};groups,by,vertex,and,computes,a,group,reduce,transformation,over,the,neighbors,both,edges,and,vertices,of,each,vertex,the,neighbors,function,applied,on,the,neighbors,only,has,access,to,both,the,vertex,id,and,the,vertex,value,of,the,grouping,vertex,p,for,each,vertex,the,neighbors,function,can,iterate,over,all,neighbors,of,this,vertex,with,the,specified,direction,and,emit,any,number,of,output,elements,including,none,param,neighbors,function,the,group,reduce,function,to,apply,to,the,neighboring,edges,and,vertices,of,each,vertex,param,direction,the,edge,direction,in,out,all,param,t,the,output,type,param,type,info,the,explicit,return,type,return,a,data,set,containing,elements,of,type,t,throws,illegal,argument,exception;public,t,data,set,t,group,reduce,on,neighbors,neighbors,function,with,vertex,value,k,vv,ev,t,neighbors,function,edge,direction,direction,type,information,t,type,info,throws,illegal,argument,exception,switch,direction,case,in,data,set,tuple2,edge,k,ev,vertex,k,vv,edges,with,sources,edges,join,this,vertices,where,0,equal,to,0,name,edge,with,source,vertex,return,vertices,co,group,edges,with,sources,where,0,equal,to,f0,f1,with,new,apply,neighbor,co,group,function,neighbors,function,name,neighbors,function,returns,type,info,case,out,data,set,tuple2,edge,k,ev,vertex,k,vv,edges,with,targets,edges,join,this,vertices,where,1,equal,to,0,name,edge,with,target,vertex,return,vertices,co,group,edges,with,targets,where,0,equal,to,f0,f0,with,new,apply,neighbor,co,group,function,neighbors,function,name,neighbors,function,returns,type,info,case,all,data,set,tuple3,k,edge,k,ev,vertex,k,vv,edges,with,neighbors,edges,flat,map,new,emit,one,edge,with,neighbor,per,node,k,ev,name,forward,and,reverse,edges,join,this,vertices,where,1,equal,to,0,with,new,project,edge,with,neighbor,k,vv,ev,name,edge,with,vertex,return,vertices,co,group,edges,with,neighbors,where,0,equal,to,0,with,new,apply,co,group,function,on,all,neighbors,neighbors,function,name,neighbors,function,returns,type,info,default,throw,new,illegal,argument,exception,illegal,edge,direction
Graph -> public <T> DataSet<T> groupReduceOnNeighbors(NeighborsFunctionWithVertexValue<K, VV, EV, T> neighborsFunction, 			EdgeDirection direction, TypeInformation<T> typeInfo) throws IllegalArgumentException;1502111816;Groups by vertex and computes a GroupReduce transformation over the neighbors (both edges and vertices)_of each vertex. The neighborsFunction applied on the neighbors only has access to both the vertex id_and the vertex value of the grouping vertex.__<p>For each vertex, the neighborsFunction can iterate over all neighbors of this vertex_with the specified direction, and emit any number of output elements, including none.__@param neighborsFunction the group reduce function to apply to the neighboring edges and vertices_of each vertex._@param direction the edge direction (in-, out-, all-)._@param <T> the output type_@param typeInfo the explicit return type_@return a DataSet containing elements of type T_@throws IllegalArgumentException;public <T> DataSet<T> groupReduceOnNeighbors(NeighborsFunctionWithVertexValue<K, VV, EV, T> neighborsFunction,_			EdgeDirection direction, TypeInformation<T> typeInfo) throws IllegalArgumentException {_		switch (direction) {_			case IN:_				_				DataSet<Tuple2<Edge<K, EV>, Vertex<K, VV>>> edgesWithSources = edges_						.join(this.vertices).where(0).equalTo(0).name("Edge with source vertex")__				return vertices.coGroup(edgesWithSources)_						.where(0).equalTo("f0.f1")_						.with(new ApplyNeighborCoGroupFunction<>(neighborsFunction))_							.name("Neighbors function").returns(typeInfo)__			case OUT:_				_				DataSet<Tuple2<Edge<K, EV>, Vertex<K, VV>>> edgesWithTargets = edges_						.join(this.vertices).where(1).equalTo(0).name("Edge with target vertex")__				return vertices.coGroup(edgesWithTargets)_						.where(0).equalTo("f0.f0")_						.with(new ApplyNeighborCoGroupFunction<>(neighborsFunction))_							.name("Neighbors function").returns(typeInfo)__			case ALL:_				_				DataSet<Tuple3<K, Edge<K, EV>, Vertex<K, VV>>> edgesWithNeighbors = edges_						.flatMap(new EmitOneEdgeWithNeighborPerNode<>()).name("Forward and reverse edges")_						.join(this.vertices).where(1).equalTo(0)_						.with(new ProjectEdgeWithNeighbor<>()).name("Edge with vertex")___				return vertices.coGroup(edgesWithNeighbors)_						.where(0).equalTo(0)_						.with(new ApplyCoGroupFunctionOnAllNeighbors<>(neighborsFunction))_							.name("Neighbors function").returns(typeInfo)__			default:_				throw new IllegalArgumentException("Illegal edge direction")__		}_	};groups,by,vertex,and,computes,a,group,reduce,transformation,over,the,neighbors,both,edges,and,vertices,of,each,vertex,the,neighbors,function,applied,on,the,neighbors,only,has,access,to,both,the,vertex,id,and,the,vertex,value,of,the,grouping,vertex,p,for,each,vertex,the,neighbors,function,can,iterate,over,all,neighbors,of,this,vertex,with,the,specified,direction,and,emit,any,number,of,output,elements,including,none,param,neighbors,function,the,group,reduce,function,to,apply,to,the,neighboring,edges,and,vertices,of,each,vertex,param,direction,the,edge,direction,in,out,all,param,t,the,output,type,param,type,info,the,explicit,return,type,return,a,data,set,containing,elements,of,type,t,throws,illegal,argument,exception;public,t,data,set,t,group,reduce,on,neighbors,neighbors,function,with,vertex,value,k,vv,ev,t,neighbors,function,edge,direction,direction,type,information,t,type,info,throws,illegal,argument,exception,switch,direction,case,in,data,set,tuple2,edge,k,ev,vertex,k,vv,edges,with,sources,edges,join,this,vertices,where,0,equal,to,0,name,edge,with,source,vertex,return,vertices,co,group,edges,with,sources,where,0,equal,to,f0,f1,with,new,apply,neighbor,co,group,function,neighbors,function,name,neighbors,function,returns,type,info,case,out,data,set,tuple2,edge,k,ev,vertex,k,vv,edges,with,targets,edges,join,this,vertices,where,1,equal,to,0,name,edge,with,target,vertex,return,vertices,co,group,edges,with,targets,where,0,equal,to,f0,f0,with,new,apply,neighbor,co,group,function,neighbors,function,name,neighbors,function,returns,type,info,case,all,data,set,tuple3,k,edge,k,ev,vertex,k,vv,edges,with,neighbors,edges,flat,map,new,emit,one,edge,with,neighbor,per,node,name,forward,and,reverse,edges,join,this,vertices,where,1,equal,to,0,with,new,project,edge,with,neighbor,name,edge,with,vertex,return,vertices,co,group,edges,with,neighbors,where,0,equal,to,0,with,new,apply,co,group,function,on,all,neighbors,neighbors,function,name,neighbors,function,returns,type,info,default,throw,new,illegal,argument,exception,illegal,edge,direction
Graph -> public DataSet<Tuple3<K, K, EV>> getEdgesAsTuple3();1444404795;@return the edge DataSet as Tuple3.;public DataSet<Tuple3<K, K, EV>> getEdgesAsTuple3() {_		return edges.map(new EdgeToTuple3Map<K, EV>())__	};return,the,edge,data,set,as,tuple3;public,data,set,tuple3,k,k,ev,get,edges,as,tuple3,return,edges,map,new,edge,to,tuple3map,k,ev
Graph -> public DataSet<Tuple3<K, K, EV>> getEdgesAsTuple3();1445261977;@return the edge DataSet as Tuple3.;public DataSet<Tuple3<K, K, EV>> getEdgesAsTuple3() {_		return edges.map(new EdgeToTuple3Map<K, EV>())__	};return,the,edge,data,set,as,tuple3;public,data,set,tuple3,k,k,ev,get,edges,as,tuple3,return,edges,map,new,edge,to,tuple3map,k,ev
Graph -> public DataSet<Tuple3<K, K, EV>> getEdgesAsTuple3();1445854323;@return the edge DataSet as Tuple3.;public DataSet<Tuple3<K, K, EV>> getEdgesAsTuple3() {_		return edges.map(new EdgeToTuple3Map<K, EV>())__	};return,the,edge,data,set,as,tuple3;public,data,set,tuple3,k,k,ev,get,edges,as,tuple3,return,edges,map,new,edge,to,tuple3map,k,ev
Graph -> public DataSet<Tuple3<K, K, EV>> getEdgesAsTuple3();1446112342;@return the edge DataSet as Tuple3.;public DataSet<Tuple3<K, K, EV>> getEdgesAsTuple3() {_		return edges.map(new EdgeToTuple3Map<K, EV>())__	};return,the,edge,data,set,as,tuple3;public,data,set,tuple3,k,k,ev,get,edges,as,tuple3,return,edges,map,new,edge,to,tuple3map,k,ev
Graph -> public DataSet<Tuple3<K, K, EV>> getEdgesAsTuple3();1447073368;@return the edge DataSet as Tuple3.;public DataSet<Tuple3<K, K, EV>> getEdgesAsTuple3() {_		return edges.map(new EdgeToTuple3Map<K, EV>())__	};return,the,edge,data,set,as,tuple3;public,data,set,tuple3,k,k,ev,get,edges,as,tuple3,return,edges,map,new,edge,to,tuple3map,k,ev
Graph -> public DataSet<Tuple3<K, K, EV>> getEdgesAsTuple3();1454404649;@return the edge DataSet as Tuple3.;public DataSet<Tuple3<K, K, EV>> getEdgesAsTuple3() {_		return edges.map(new EdgeToTuple3Map<K, EV>())__	};return,the,edge,data,set,as,tuple3;public,data,set,tuple3,k,k,ev,get,edges,as,tuple3,return,edges,map,new,edge,to,tuple3map,k,ev
Graph -> public DataSet<Tuple3<K, K, EV>> getEdgesAsTuple3();1458583829;@return the edge DataSet as Tuple3.;public DataSet<Tuple3<K, K, EV>> getEdgesAsTuple3() {_		return edges.map(new EdgeToTuple3Map<K, EV>())__	};return,the,edge,data,set,as,tuple3;public,data,set,tuple3,k,k,ev,get,edges,as,tuple3,return,edges,map,new,edge,to,tuple3map,k,ev
Graph -> public DataSet<Tuple3<K, K, EV>> getEdgesAsTuple3();1458583829;@return the edge DataSet as Tuple3.;public DataSet<Tuple3<K, K, EV>> getEdgesAsTuple3() {_		return edges.map(new EdgeToTuple3Map<K, EV>())__	};return,the,edge,data,set,as,tuple3;public,data,set,tuple3,k,k,ev,get,edges,as,tuple3,return,edges,map,new,edge,to,tuple3map,k,ev
Graph -> public DataSet<Tuple3<K, K, EV>> getEdgesAsTuple3();1462100316;@return the edge DataSet as Tuple3.;public DataSet<Tuple3<K, K, EV>> getEdgesAsTuple3() {_		return edges.map(new EdgeToTuple3Map<K, EV>())__	};return,the,edge,data,set,as,tuple3;public,data,set,tuple3,k,k,ev,get,edges,as,tuple3,return,edges,map,new,edge,to,tuple3map,k,ev
Graph -> public DataSet<Tuple3<K, K, EV>> getEdgesAsTuple3();1462100316;@return the edge DataSet as Tuple3.;public DataSet<Tuple3<K, K, EV>> getEdgesAsTuple3() {_		return edges.map(new EdgeToTuple3Map<K, EV>())__	};return,the,edge,data,set,as,tuple3;public,data,set,tuple3,k,k,ev,get,edges,as,tuple3,return,edges,map,new,edge,to,tuple3map,k,ev
Graph -> public DataSet<Tuple3<K, K, EV>> getEdgesAsTuple3();1462205213;@return the edge DataSet as Tuple3.;public DataSet<Tuple3<K, K, EV>> getEdgesAsTuple3() {_		return edges.map(new EdgeToTuple3Map<K, EV>())__	};return,the,edge,data,set,as,tuple3;public,data,set,tuple3,k,k,ev,get,edges,as,tuple3,return,edges,map,new,edge,to,tuple3map,k,ev
Graph -> public DataSet<Tuple3<K, K, EV>> getEdgesAsTuple3();1462208859;@return the edge DataSet as Tuple3.;public DataSet<Tuple3<K, K, EV>> getEdgesAsTuple3() {_		return edges.map(new EdgeToTuple3Map<K, EV>())__	};return,the,edge,data,set,as,tuple3;public,data,set,tuple3,k,k,ev,get,edges,as,tuple3,return,edges,map,new,edge,to,tuple3map,k,ev
Graph -> public DataSet<Tuple3<K, K, EV>> getEdgesAsTuple3();1462809297;@return the edge DataSet as Tuple3.;public DataSet<Tuple3<K, K, EV>> getEdgesAsTuple3() {_		return edges.map(new EdgeToTuple3Map<K, EV>())__	};return,the,edge,data,set,as,tuple3;public,data,set,tuple3,k,k,ev,get,edges,as,tuple3,return,edges,map,new,edge,to,tuple3map,k,ev
Graph -> public DataSet<Tuple3<K, K, EV>> getEdgesAsTuple3();1465316775;@return the edge DataSet as Tuple3.;public DataSet<Tuple3<K, K, EV>> getEdgesAsTuple3() {_		return edges.map(new EdgeToTuple3Map<K, EV>())__	};return,the,edge,data,set,as,tuple3;public,data,set,tuple3,k,k,ev,get,edges,as,tuple3,return,edges,map,new,edge,to,tuple3map,k,ev
Graph -> public DataSet<Tuple3<K, K, EV>> getEdgesAsTuple3();1466789678;@return the edge DataSet as Tuple3.;public DataSet<Tuple3<K, K, EV>> getEdgesAsTuple3() {_		return edges.map(new EdgeToTuple3Map<K, EV>())__	};return,the,edge,data,set,as,tuple3;public,data,set,tuple3,k,k,ev,get,edges,as,tuple3,return,edges,map,new,edge,to,tuple3map,k,ev
Graph -> public DataSet<Tuple3<K, K, EV>> getEdgesAsTuple3();1467140656;@return the edge DataSet as Tuple3.;public DataSet<Tuple3<K, K, EV>> getEdgesAsTuple3() {_		return edges.map(new EdgeToTuple3Map<K, EV>())__	};return,the,edge,data,set,as,tuple3;public,data,set,tuple3,k,k,ev,get,edges,as,tuple3,return,edges,map,new,edge,to,tuple3map,k,ev
Graph -> public DataSet<Tuple3<K, K, EV>> getEdgesAsTuple3();1467306272;@return the edge DataSet as Tuple3.;public DataSet<Tuple3<K, K, EV>> getEdgesAsTuple3() {_		return edges.map(new EdgeToTuple3Map<K, EV>())__	};return,the,edge,data,set,as,tuple3;public,data,set,tuple3,k,k,ev,get,edges,as,tuple3,return,edges,map,new,edge,to,tuple3map,k,ev
Graph -> public DataSet<Tuple3<K, K, EV>> getEdgesAsTuple3();1470042815;@return the edge DataSet as Tuple3.;public DataSet<Tuple3<K, K, EV>> getEdgesAsTuple3() {_		return edges.map(new EdgeToTuple3Map<K, EV>())__	};return,the,edge,data,set,as,tuple3;public,data,set,tuple3,k,k,ev,get,edges,as,tuple3,return,edges,map,new,edge,to,tuple3map,k,ev
Graph -> public DataSet<Tuple3<K, K, EV>> getEdgesAsTuple3();1475684776;@return the edge DataSet as Tuple3.;public DataSet<Tuple3<K, K, EV>> getEdgesAsTuple3() {_		return edges.map(new EdgeToTuple3Map<K, EV>())__	};return,the,edge,data,set,as,tuple3;public,data,set,tuple3,k,k,ev,get,edges,as,tuple3,return,edges,map,new,edge,to,tuple3map,k,ev
Graph -> public DataSet<Tuple3<K, K, EV>> getEdgesAsTuple3();1475685606;@return the edge DataSet as Tuple3.;public DataSet<Tuple3<K, K, EV>> getEdgesAsTuple3() {_		return edges.map(new EdgeToTuple3Map<K, EV>())__	};return,the,edge,data,set,as,tuple3;public,data,set,tuple3,k,k,ev,get,edges,as,tuple3,return,edges,map,new,edge,to,tuple3map,k,ev
Graph -> public DataSet<Tuple3<K, K, EV>> getEdgesAsTuple3();1481745825;@return the edge DataSet as Tuple3.;public DataSet<Tuple3<K, K, EV>> getEdgesAsTuple3() {_		return edges.map(new EdgeToTuple3Map<K, EV>())__	};return,the,edge,data,set,as,tuple3;public,data,set,tuple3,k,k,ev,get,edges,as,tuple3,return,edges,map,new,edge,to,tuple3map,k,ev
Graph -> public DataSet<Tuple3<K, K, EV>> getEdgesAsTuple3();1481881009;@return the edge DataSet as Tuple3.;public DataSet<Tuple3<K, K, EV>> getEdgesAsTuple3() {_		return edges.map(new EdgeToTuple3Map<K, EV>())__	};return,the,edge,data,set,as,tuple3;public,data,set,tuple3,k,k,ev,get,edges,as,tuple3,return,edges,map,new,edge,to,tuple3map,k,ev
Graph -> public DataSet<Tuple3<K, K, EV>> getEdgesAsTuple3();1484160227;@return the edge DataSet as Tuple3.;public DataSet<Tuple3<K, K, EV>> getEdgesAsTuple3() {_		return edges.map(new EdgeToTuple3Map<K, EV>())__	};return,the,edge,data,set,as,tuple3;public,data,set,tuple3,k,k,ev,get,edges,as,tuple3,return,edges,map,new,edge,to,tuple3map,k,ev
Graph -> public DataSet<Tuple3<K, K, EV>> getEdgesAsTuple3();1484685504;@return the edge DataSet as Tuple3.;public DataSet<Tuple3<K, K, EV>> getEdgesAsTuple3() {_		return edges.map(new EdgeToTuple3Map<K, EV>())__	};return,the,edge,data,set,as,tuple3;public,data,set,tuple3,k,k,ev,get,edges,as,tuple3,return,edges,map,new,edge,to,tuple3map,k,ev
Graph -> public DataSet<Tuple3<K, K, EV>> getEdgesAsTuple3();1489068942;@return the edge DataSet as Tuple3.;public DataSet<Tuple3<K, K, EV>> getEdgesAsTuple3() {_		return edges.map(new EdgeToTuple3Map<K, EV>())__	};return,the,edge,data,set,as,tuple3;public,data,set,tuple3,k,k,ev,get,edges,as,tuple3,return,edges,map,new,edge,to,tuple3map,k,ev
Graph -> public DataSet<Tuple3<K, K, EV>> getEdgesAsTuple3();1490973446;@return the edge DataSet as Tuple3.;public DataSet<Tuple3<K, K, EV>> getEdgesAsTuple3() {_		return edges.map(new EdgeToTuple3Map<K, EV>())__	};return,the,edge,data,set,as,tuple3;public,data,set,tuple3,k,k,ev,get,edges,as,tuple3,return,edges,map,new,edge,to,tuple3map,k,ev
Graph -> public DataSet<Tuple3<K, K, EV>> getEdgesAsTuple3();1495819075;@return the edge DataSet as Tuple3.;public DataSet<Tuple3<K, K, EV>> getEdgesAsTuple3() {_		return edges.map(new EdgeToTuple3Map<K, EV>())__	};return,the,edge,data,set,as,tuple3;public,data,set,tuple3,k,k,ev,get,edges,as,tuple3,return,edges,map,new,edge,to,tuple3map,k,ev
Graph -> public DataSet<Tuple3<K, K, EV>> getEdgesAsTuple3();1502111816;@return the edge DataSet as Tuple3.;public DataSet<Tuple3<K, K, EV>> getEdgesAsTuple3() {_		return edges.map(new EdgeToTuple3Map<>())__	};return,the,edge,data,set,as,tuple3;public,data,set,tuple3,k,k,ev,get,edges,as,tuple3,return,edges,map,new,edge,to,tuple3map
Graph -> public <T> GraphAnalytic<K, VV, EV, T> run(GraphAnalytic<K, VV, EV, T> analytic) throws Exception;1466789678;A {@code GraphAnalytic} is similar to a {@link GraphAlgorithm} but is terminal_and results are retrieved via accumulators.  A Flink program has a single_point of execution. A {@code GraphAnalytic} defers execution to the user to_allow composing multiple analytics and algorithms into a single program.__@param analytic the analytic to run on the Graph_@param <T> the result type_@throws Exception;public <T> GraphAnalytic<K, VV, EV, T> run(GraphAnalytic<K, VV, EV, T> analytic) throws Exception {_		analytic.run(this)__		return analytic__	};a,code,graph,analytic,is,similar,to,a,link,graph,algorithm,but,is,terminal,and,results,are,retrieved,via,accumulators,a,flink,program,has,a,single,point,of,execution,a,code,graph,analytic,defers,execution,to,the,user,to,allow,composing,multiple,analytics,and,algorithms,into,a,single,program,param,analytic,the,analytic,to,run,on,the,graph,param,t,the,result,type,throws,exception;public,t,graph,analytic,k,vv,ev,t,run,graph,analytic,k,vv,ev,t,analytic,throws,exception,analytic,run,this,return,analytic
Graph -> public <T> GraphAnalytic<K, VV, EV, T> run(GraphAnalytic<K, VV, EV, T> analytic) throws Exception;1467140656;A {@code GraphAnalytic} is similar to a {@link GraphAlgorithm} but is terminal_and results are retrieved via accumulators.  A Flink program has a single_point of execution. A {@code GraphAnalytic} defers execution to the user to_allow composing multiple analytics and algorithms into a single program.__@param analytic the analytic to run on the Graph_@param <T> the result type_@throws Exception;public <T> GraphAnalytic<K, VV, EV, T> run(GraphAnalytic<K, VV, EV, T> analytic) throws Exception {_		analytic.run(this)__		return analytic__	};a,code,graph,analytic,is,similar,to,a,link,graph,algorithm,but,is,terminal,and,results,are,retrieved,via,accumulators,a,flink,program,has,a,single,point,of,execution,a,code,graph,analytic,defers,execution,to,the,user,to,allow,composing,multiple,analytics,and,algorithms,into,a,single,program,param,analytic,the,analytic,to,run,on,the,graph,param,t,the,result,type,throws,exception;public,t,graph,analytic,k,vv,ev,t,run,graph,analytic,k,vv,ev,t,analytic,throws,exception,analytic,run,this,return,analytic
Graph -> public <T> GraphAnalytic<K, VV, EV, T> run(GraphAnalytic<K, VV, EV, T> analytic) throws Exception;1467306272;A {@code GraphAnalytic} is similar to a {@link GraphAlgorithm} but is terminal_and results are retrieved via accumulators.  A Flink program has a single_point of execution. A {@code GraphAnalytic} defers execution to the user to_allow composing multiple analytics and algorithms into a single program.__@param analytic the analytic to run on the Graph_@param <T> the result type_@throws Exception;public <T> GraphAnalytic<K, VV, EV, T> run(GraphAnalytic<K, VV, EV, T> analytic) throws Exception {_		analytic.run(this)__		return analytic__	};a,code,graph,analytic,is,similar,to,a,link,graph,algorithm,but,is,terminal,and,results,are,retrieved,via,accumulators,a,flink,program,has,a,single,point,of,execution,a,code,graph,analytic,defers,execution,to,the,user,to,allow,composing,multiple,analytics,and,algorithms,into,a,single,program,param,analytic,the,analytic,to,run,on,the,graph,param,t,the,result,type,throws,exception;public,t,graph,analytic,k,vv,ev,t,run,graph,analytic,k,vv,ev,t,analytic,throws,exception,analytic,run,this,return,analytic
Graph -> public <T> GraphAnalytic<K, VV, EV, T> run(GraphAnalytic<K, VV, EV, T> analytic) throws Exception;1470042815;A {@code GraphAnalytic} is similar to a {@link GraphAlgorithm} but is terminal_and results are retrieved via accumulators.  A Flink program has a single_point of execution. A {@code GraphAnalytic} defers execution to the user to_allow composing multiple analytics and algorithms into a single program.__@param analytic the analytic to run on the Graph_@param <T> the result type_@throws Exception;public <T> GraphAnalytic<K, VV, EV, T> run(GraphAnalytic<K, VV, EV, T> analytic) throws Exception {_		analytic.run(this)__		return analytic__	};a,code,graph,analytic,is,similar,to,a,link,graph,algorithm,but,is,terminal,and,results,are,retrieved,via,accumulators,a,flink,program,has,a,single,point,of,execution,a,code,graph,analytic,defers,execution,to,the,user,to,allow,composing,multiple,analytics,and,algorithms,into,a,single,program,param,analytic,the,analytic,to,run,on,the,graph,param,t,the,result,type,throws,exception;public,t,graph,analytic,k,vv,ev,t,run,graph,analytic,k,vv,ev,t,analytic,throws,exception,analytic,run,this,return,analytic
Graph -> public <T> GraphAnalytic<K, VV, EV, T> run(GraphAnalytic<K, VV, EV, T> analytic) throws Exception;1475684776;A {@code GraphAnalytic} is similar to a {@link GraphAlgorithm} but is terminal_and results are retrieved via accumulators.  A Flink program has a single_point of execution. A {@code GraphAnalytic} defers execution to the user to_allow composing multiple analytics and algorithms into a single program.__@param analytic the analytic to run on the Graph_@param <T> the result type_@throws Exception;public <T> GraphAnalytic<K, VV, EV, T> run(GraphAnalytic<K, VV, EV, T> analytic) throws Exception {_		analytic.run(this)__		return analytic__	};a,code,graph,analytic,is,similar,to,a,link,graph,algorithm,but,is,terminal,and,results,are,retrieved,via,accumulators,a,flink,program,has,a,single,point,of,execution,a,code,graph,analytic,defers,execution,to,the,user,to,allow,composing,multiple,analytics,and,algorithms,into,a,single,program,param,analytic,the,analytic,to,run,on,the,graph,param,t,the,result,type,throws,exception;public,t,graph,analytic,k,vv,ev,t,run,graph,analytic,k,vv,ev,t,analytic,throws,exception,analytic,run,this,return,analytic
Graph -> public <T> GraphAnalytic<K, VV, EV, T> run(GraphAnalytic<K, VV, EV, T> analytic) throws Exception;1475685606;A {@code GraphAnalytic} is similar to a {@link GraphAlgorithm} but is terminal_and results are retrieved via accumulators.  A Flink program has a single_point of execution. A {@code GraphAnalytic} defers execution to the user to_allow composing multiple analytics and algorithms into a single program.__@param analytic the analytic to run on the Graph_@param <T> the result type_@throws Exception;public <T> GraphAnalytic<K, VV, EV, T> run(GraphAnalytic<K, VV, EV, T> analytic) throws Exception {_		analytic.run(this)__		return analytic__	};a,code,graph,analytic,is,similar,to,a,link,graph,algorithm,but,is,terminal,and,results,are,retrieved,via,accumulators,a,flink,program,has,a,single,point,of,execution,a,code,graph,analytic,defers,execution,to,the,user,to,allow,composing,multiple,analytics,and,algorithms,into,a,single,program,param,analytic,the,analytic,to,run,on,the,graph,param,t,the,result,type,throws,exception;public,t,graph,analytic,k,vv,ev,t,run,graph,analytic,k,vv,ev,t,analytic,throws,exception,analytic,run,this,return,analytic
Graph -> public <T> GraphAnalytic<K, VV, EV, T> run(GraphAnalytic<K, VV, EV, T> analytic) throws Exception;1481745825;A {@code GraphAnalytic} is similar to a {@link GraphAlgorithm} but is terminal_and results are retrieved via accumulators.  A Flink program has a single_point of execution. A {@code GraphAnalytic} defers execution to the user to_allow composing multiple analytics and algorithms into a single program.__@param analytic the analytic to run on the Graph_@param <T> the result type_@throws Exception;public <T> GraphAnalytic<K, VV, EV, T> run(GraphAnalytic<K, VV, EV, T> analytic) throws Exception {_		analytic.run(this)__		return analytic__	};a,code,graph,analytic,is,similar,to,a,link,graph,algorithm,but,is,terminal,and,results,are,retrieved,via,accumulators,a,flink,program,has,a,single,point,of,execution,a,code,graph,analytic,defers,execution,to,the,user,to,allow,composing,multiple,analytics,and,algorithms,into,a,single,program,param,analytic,the,analytic,to,run,on,the,graph,param,t,the,result,type,throws,exception;public,t,graph,analytic,k,vv,ev,t,run,graph,analytic,k,vv,ev,t,analytic,throws,exception,analytic,run,this,return,analytic
Graph -> public <T> GraphAnalytic<K, VV, EV, T> run(GraphAnalytic<K, VV, EV, T> analytic) throws Exception;1481881009;A {@code GraphAnalytic} is similar to a {@link GraphAlgorithm} but is terminal_and results are retrieved via accumulators.  A Flink program has a single_point of execution. A {@code GraphAnalytic} defers execution to the user to_allow composing multiple analytics and algorithms into a single program.__@param analytic the analytic to run on the Graph_@param <T> the result type_@throws Exception;public <T> GraphAnalytic<K, VV, EV, T> run(GraphAnalytic<K, VV, EV, T> analytic) throws Exception {_		analytic.run(this)__		return analytic__	};a,code,graph,analytic,is,similar,to,a,link,graph,algorithm,but,is,terminal,and,results,are,retrieved,via,accumulators,a,flink,program,has,a,single,point,of,execution,a,code,graph,analytic,defers,execution,to,the,user,to,allow,composing,multiple,analytics,and,algorithms,into,a,single,program,param,analytic,the,analytic,to,run,on,the,graph,param,t,the,result,type,throws,exception;public,t,graph,analytic,k,vv,ev,t,run,graph,analytic,k,vv,ev,t,analytic,throws,exception,analytic,run,this,return,analytic
Graph -> public <T> GraphAnalytic<K, VV, EV, T> run(GraphAnalytic<K, VV, EV, T> analytic) throws Exception;1484160227;A {@code GraphAnalytic} is similar to a {@link GraphAlgorithm} but is terminal_and results are retrieved via accumulators.  A Flink program has a single_point of execution. A {@code GraphAnalytic} defers execution to the user to_allow composing multiple analytics and algorithms into a single program.__@param analytic the analytic to run on the Graph_@param <T> the result type_@throws Exception;public <T> GraphAnalytic<K, VV, EV, T> run(GraphAnalytic<K, VV, EV, T> analytic) throws Exception {_		analytic.run(this)__		return analytic__	};a,code,graph,analytic,is,similar,to,a,link,graph,algorithm,but,is,terminal,and,results,are,retrieved,via,accumulators,a,flink,program,has,a,single,point,of,execution,a,code,graph,analytic,defers,execution,to,the,user,to,allow,composing,multiple,analytics,and,algorithms,into,a,single,program,param,analytic,the,analytic,to,run,on,the,graph,param,t,the,result,type,throws,exception;public,t,graph,analytic,k,vv,ev,t,run,graph,analytic,k,vv,ev,t,analytic,throws,exception,analytic,run,this,return,analytic
Graph -> public <T> GraphAnalytic<K, VV, EV, T> run(GraphAnalytic<K, VV, EV, T> analytic) throws Exception;1484685504;A {@code GraphAnalytic} is similar to a {@link GraphAlgorithm} but is terminal_and results are retrieved via accumulators.  A Flink program has a single_point of execution. A {@code GraphAnalytic} defers execution to the user to_allow composing multiple analytics and algorithms into a single program.__@param analytic the analytic to run on the Graph_@param <T> the result type_@throws Exception;public <T> GraphAnalytic<K, VV, EV, T> run(GraphAnalytic<K, VV, EV, T> analytic) throws Exception {_		analytic.run(this)__		return analytic__	};a,code,graph,analytic,is,similar,to,a,link,graph,algorithm,but,is,terminal,and,results,are,retrieved,via,accumulators,a,flink,program,has,a,single,point,of,execution,a,code,graph,analytic,defers,execution,to,the,user,to,allow,composing,multiple,analytics,and,algorithms,into,a,single,program,param,analytic,the,analytic,to,run,on,the,graph,param,t,the,result,type,throws,exception;public,t,graph,analytic,k,vv,ev,t,run,graph,analytic,k,vv,ev,t,analytic,throws,exception,analytic,run,this,return,analytic
Graph -> public <T> GraphAnalytic<K, VV, EV, T> run(GraphAnalytic<K, VV, EV, T> analytic) throws Exception;1489068942;A {@code GraphAnalytic} is similar to a {@link GraphAlgorithm} but is terminal_and results are retrieved via accumulators.  A Flink program has a single_point of execution. A {@code GraphAnalytic} defers execution to the user to_allow composing multiple analytics and algorithms into a single program.__@param analytic the analytic to run on the Graph_@param <T> the result type_@throws Exception;public <T> GraphAnalytic<K, VV, EV, T> run(GraphAnalytic<K, VV, EV, T> analytic) throws Exception {_		analytic.run(this)__		return analytic__	};a,code,graph,analytic,is,similar,to,a,link,graph,algorithm,but,is,terminal,and,results,are,retrieved,via,accumulators,a,flink,program,has,a,single,point,of,execution,a,code,graph,analytic,defers,execution,to,the,user,to,allow,composing,multiple,analytics,and,algorithms,into,a,single,program,param,analytic,the,analytic,to,run,on,the,graph,param,t,the,result,type,throws,exception;public,t,graph,analytic,k,vv,ev,t,run,graph,analytic,k,vv,ev,t,analytic,throws,exception,analytic,run,this,return,analytic
Graph -> public <T> GraphAnalytic<K, VV, EV, T> run(GraphAnalytic<K, VV, EV, T> analytic) throws Exception;1490973446;A {@code GraphAnalytic} is similar to a {@link GraphAlgorithm} but is terminal_and results are retrieved via accumulators.  A Flink program has a single_point of execution. A {@code GraphAnalytic} defers execution to the user to_allow composing multiple analytics and algorithms into a single program.__@param analytic the analytic to run on the Graph_@param <T> the result type_@throws Exception;public <T> GraphAnalytic<K, VV, EV, T> run(GraphAnalytic<K, VV, EV, T> analytic) throws Exception {_		analytic.run(this)__		return analytic__	};a,code,graph,analytic,is,similar,to,a,link,graph,algorithm,but,is,terminal,and,results,are,retrieved,via,accumulators,a,flink,program,has,a,single,point,of,execution,a,code,graph,analytic,defers,execution,to,the,user,to,allow,composing,multiple,analytics,and,algorithms,into,a,single,program,param,analytic,the,analytic,to,run,on,the,graph,param,t,the,result,type,throws,exception;public,t,graph,analytic,k,vv,ev,t,run,graph,analytic,k,vv,ev,t,analytic,throws,exception,analytic,run,this,return,analytic
Graph -> public <T> GraphAnalytic<K, VV, EV, T> run(GraphAnalytic<K, VV, EV, T> analytic) throws Exception;1495819075;A {@code GraphAnalytic} is similar to a {@link GraphAlgorithm} but is terminal_and results are retrieved via accumulators.  A Flink program has a single_point of execution. A {@code GraphAnalytic} defers execution to the user to_allow composing multiple analytics and algorithms into a single program.__@param analytic the analytic to run on the Graph_@param <T> the result type_@throws Exception;public <T> GraphAnalytic<K, VV, EV, T> run(GraphAnalytic<K, VV, EV, T> analytic) throws Exception {_		analytic.run(this)__		return analytic__	};a,code,graph,analytic,is,similar,to,a,link,graph,algorithm,but,is,terminal,and,results,are,retrieved,via,accumulators,a,flink,program,has,a,single,point,of,execution,a,code,graph,analytic,defers,execution,to,the,user,to,allow,composing,multiple,analytics,and,algorithms,into,a,single,program,param,analytic,the,analytic,to,run,on,the,graph,param,t,the,result,type,throws,exception;public,t,graph,analytic,k,vv,ev,t,run,graph,analytic,k,vv,ev,t,analytic,throws,exception,analytic,run,this,return,analytic
Graph -> public <T> GraphAnalytic<K, VV, EV, T> run(GraphAnalytic<K, VV, EV, T> analytic) throws Exception;1502111816;A {@code GraphAnalytic} is similar to a {@link GraphAlgorithm} but is terminal_and results are retrieved via accumulators.  A Flink program has a single_point of execution. A {@code GraphAnalytic} defers execution to the user to_allow composing multiple analytics and algorithms into a single program.__@param analytic the analytic to run on the Graph_@param <T> the result type_@throws Exception;public <T> GraphAnalytic<K, VV, EV, T> run(GraphAnalytic<K, VV, EV, T> analytic) throws Exception {_		analytic.run(this)__		return analytic__	};a,code,graph,analytic,is,similar,to,a,link,graph,algorithm,but,is,terminal,and,results,are,retrieved,via,accumulators,a,flink,program,has,a,single,point,of,execution,a,code,graph,analytic,defers,execution,to,the,user,to,allow,composing,multiple,analytics,and,algorithms,into,a,single,program,param,analytic,the,analytic,to,run,on,the,graph,param,t,the,result,type,throws,exception;public,t,graph,analytic,k,vv,ev,t,run,graph,analytic,k,vv,ev,t,analytic,throws,exception,analytic,run,this,return,analytic
Graph -> public static <K, VV, EV> Graph<K, VV, EV> fromDataSet(DataSet<Edge<K, EV>> edges, 			final MapFunction<K, VV> vertexValueInitializer, ExecutionEnvironment context);1445261977;Creates a graph from a DataSet of edges._Vertices are created automatically and their values are set_by applying the provided map function to the vertex IDs.__@param edges a DataSet of edges._@param vertexValueInitializer the mapper function that initializes the vertex values._It allows to apply a map transformation on the vertex ID to produce an initial vertex value._@param context the flink execution environment._@return the newly created graph.;public static <K, VV, EV> Graph<K, VV, EV> fromDataSet(DataSet<Edge<K, EV>> edges,_			final MapFunction<K, VV> vertexValueInitializer, ExecutionEnvironment context) {__		TypeInformation<K> keyType = ((TupleTypeInfo<?>) edges.getType()).getTypeAt(0)___		TypeInformation<VV> valueType = TypeExtractor.createTypeInfo(_				MapFunction.class, vertexValueInitializer.getClass(), 1, null, null)___		@SuppressWarnings({ "unchecked", "rawtypes" })_		TypeInformation<Vertex<K, VV>> returnType = (TypeInformation<Vertex<K, VV>>) new TupleTypeInfo(_				Vertex.class, keyType, valueType)___		DataSet<Vertex<K, VV>> vertices = edges_				.flatMap(new EmitSrcAndTargetAsTuple1<K, EV>()).distinct()_				.map(new MapFunction<Tuple1<K>, Vertex<K, VV>>() {_					public Vertex<K, VV> map(Tuple1<K> value) throws Exception {_						return new Vertex<K, VV>(value.f0, vertexValueInitializer.map(value.f0))__					}_				}).returns(returnType).withForwardedFields("f0")___		return new Graph<K, VV, EV>(vertices, edges, context)__	};creates,a,graph,from,a,data,set,of,edges,vertices,are,created,automatically,and,their,values,are,set,by,applying,the,provided,map,function,to,the,vertex,ids,param,edges,a,data,set,of,edges,param,vertex,value,initializer,the,mapper,function,that,initializes,the,vertex,values,it,allows,to,apply,a,map,transformation,on,the,vertex,id,to,produce,an,initial,vertex,value,param,context,the,flink,execution,environment,return,the,newly,created,graph;public,static,k,vv,ev,graph,k,vv,ev,from,data,set,data,set,edge,k,ev,edges,final,map,function,k,vv,vertex,value,initializer,execution,environment,context,type,information,k,key,type,tuple,type,info,edges,get,type,get,type,at,0,type,information,vv,value,type,type,extractor,create,type,info,map,function,class,vertex,value,initializer,get,class,1,null,null,suppress,warnings,unchecked,rawtypes,type,information,vertex,k,vv,return,type,type,information,vertex,k,vv,new,tuple,type,info,vertex,class,key,type,value,type,data,set,vertex,k,vv,vertices,edges,flat,map,new,emit,src,and,target,as,tuple1,k,ev,distinct,map,new,map,function,tuple1,k,vertex,k,vv,public,vertex,k,vv,map,tuple1,k,value,throws,exception,return,new,vertex,k,vv,value,f0,vertex,value,initializer,map,value,f0,returns,return,type,with,forwarded,fields,f0,return,new,graph,k,vv,ev,vertices,edges,context
Graph -> public static <K, VV, EV> Graph<K, VV, EV> fromDataSet(DataSet<Edge<K, EV>> edges, 			final MapFunction<K, VV> vertexValueInitializer, ExecutionEnvironment context);1445854323;Creates a graph from a DataSet of edges._Vertices are created automatically and their values are set_by applying the provided map function to the vertex IDs.__@param edges a DataSet of edges._@param vertexValueInitializer the mapper function that initializes the vertex values._It allows to apply a map transformation on the vertex ID to produce an initial vertex value._@param context the flink execution environment._@return the newly created graph.;public static <K, VV, EV> Graph<K, VV, EV> fromDataSet(DataSet<Edge<K, EV>> edges,_			final MapFunction<K, VV> vertexValueInitializer, ExecutionEnvironment context) {__		TypeInformation<K> keyType = ((TupleTypeInfo<?>) edges.getType()).getTypeAt(0)___		TypeInformation<VV> valueType = TypeExtractor.createTypeInfo(_				MapFunction.class, vertexValueInitializer.getClass(), 1, null, null)___		@SuppressWarnings({ "unchecked", "rawtypes" })_		TypeInformation<Vertex<K, VV>> returnType = (TypeInformation<Vertex<K, VV>>) new TupleTypeInfo(_				Vertex.class, keyType, valueType)___		DataSet<Vertex<K, VV>> vertices = edges_				.flatMap(new EmitSrcAndTargetAsTuple1<K, EV>()).distinct()_				.map(new MapFunction<Tuple1<K>, Vertex<K, VV>>() {_					public Vertex<K, VV> map(Tuple1<K> value) throws Exception {_						return new Vertex<K, VV>(value.f0, vertexValueInitializer.map(value.f0))__					}_				}).returns(returnType).withForwardedFields("f0")___		return new Graph<K, VV, EV>(vertices, edges, context)__	};creates,a,graph,from,a,data,set,of,edges,vertices,are,created,automatically,and,their,values,are,set,by,applying,the,provided,map,function,to,the,vertex,ids,param,edges,a,data,set,of,edges,param,vertex,value,initializer,the,mapper,function,that,initializes,the,vertex,values,it,allows,to,apply,a,map,transformation,on,the,vertex,id,to,produce,an,initial,vertex,value,param,context,the,flink,execution,environment,return,the,newly,created,graph;public,static,k,vv,ev,graph,k,vv,ev,from,data,set,data,set,edge,k,ev,edges,final,map,function,k,vv,vertex,value,initializer,execution,environment,context,type,information,k,key,type,tuple,type,info,edges,get,type,get,type,at,0,type,information,vv,value,type,type,extractor,create,type,info,map,function,class,vertex,value,initializer,get,class,1,null,null,suppress,warnings,unchecked,rawtypes,type,information,vertex,k,vv,return,type,type,information,vertex,k,vv,new,tuple,type,info,vertex,class,key,type,value,type,data,set,vertex,k,vv,vertices,edges,flat,map,new,emit,src,and,target,as,tuple1,k,ev,distinct,map,new,map,function,tuple1,k,vertex,k,vv,public,vertex,k,vv,map,tuple1,k,value,throws,exception,return,new,vertex,k,vv,value,f0,vertex,value,initializer,map,value,f0,returns,return,type,with,forwarded,fields,f0,return,new,graph,k,vv,ev,vertices,edges,context
Graph -> public static <K, VV, EV> Graph<K, VV, EV> fromDataSet(DataSet<Edge<K, EV>> edges, 			final MapFunction<K, VV> vertexValueInitializer, ExecutionEnvironment context);1446112342;Creates a graph from a DataSet of edges._Vertices are created automatically and their values are set_by applying the provided map function to the vertex IDs.__@param edges a DataSet of edges._@param vertexValueInitializer the mapper function that initializes the vertex values._It allows to apply a map transformation on the vertex ID to produce an initial vertex value._@param context the flink execution environment._@return the newly created graph.;public static <K, VV, EV> Graph<K, VV, EV> fromDataSet(DataSet<Edge<K, EV>> edges,_			final MapFunction<K, VV> vertexValueInitializer, ExecutionEnvironment context) {__		TypeInformation<K> keyType = ((TupleTypeInfo<?>) edges.getType()).getTypeAt(0)___		TypeInformation<VV> valueType = TypeExtractor.createTypeInfo(_				MapFunction.class, vertexValueInitializer.getClass(), 1, null, null)___		@SuppressWarnings({ "unchecked", "rawtypes" })_		TypeInformation<Vertex<K, VV>> returnType = (TypeInformation<Vertex<K, VV>>) new TupleTypeInfo(_				Vertex.class, keyType, valueType)___		DataSet<Vertex<K, VV>> vertices = edges_				.flatMap(new EmitSrcAndTargetAsTuple1<K, EV>()).distinct()_				.map(new MapFunction<Tuple1<K>, Vertex<K, VV>>() {_					public Vertex<K, VV> map(Tuple1<K> value) throws Exception {_						return new Vertex<K, VV>(value.f0, vertexValueInitializer.map(value.f0))__					}_				}).returns(returnType).withForwardedFields("f0")___		return new Graph<K, VV, EV>(vertices, edges, context)__	};creates,a,graph,from,a,data,set,of,edges,vertices,are,created,automatically,and,their,values,are,set,by,applying,the,provided,map,function,to,the,vertex,ids,param,edges,a,data,set,of,edges,param,vertex,value,initializer,the,mapper,function,that,initializes,the,vertex,values,it,allows,to,apply,a,map,transformation,on,the,vertex,id,to,produce,an,initial,vertex,value,param,context,the,flink,execution,environment,return,the,newly,created,graph;public,static,k,vv,ev,graph,k,vv,ev,from,data,set,data,set,edge,k,ev,edges,final,map,function,k,vv,vertex,value,initializer,execution,environment,context,type,information,k,key,type,tuple,type,info,edges,get,type,get,type,at,0,type,information,vv,value,type,type,extractor,create,type,info,map,function,class,vertex,value,initializer,get,class,1,null,null,suppress,warnings,unchecked,rawtypes,type,information,vertex,k,vv,return,type,type,information,vertex,k,vv,new,tuple,type,info,vertex,class,key,type,value,type,data,set,vertex,k,vv,vertices,edges,flat,map,new,emit,src,and,target,as,tuple1,k,ev,distinct,map,new,map,function,tuple1,k,vertex,k,vv,public,vertex,k,vv,map,tuple1,k,value,throws,exception,return,new,vertex,k,vv,value,f0,vertex,value,initializer,map,value,f0,returns,return,type,with,forwarded,fields,f0,return,new,graph,k,vv,ev,vertices,edges,context
Graph -> public static <K, VV, EV> Graph<K, VV, EV> fromDataSet(DataSet<Edge<K, EV>> edges, 			final MapFunction<K, VV> vertexValueInitializer, ExecutionEnvironment context);1447073368;Creates a graph from a DataSet of edges._Vertices are created automatically and their values are set_by applying the provided map function to the vertex IDs.__@param edges a DataSet of edges._@param vertexValueInitializer the mapper function that initializes the vertex values._It allows to apply a map transformation on the vertex ID to produce an initial vertex value._@param context the flink execution environment._@return the newly created graph.;public static <K, VV, EV> Graph<K, VV, EV> fromDataSet(DataSet<Edge<K, EV>> edges,_			final MapFunction<K, VV> vertexValueInitializer, ExecutionEnvironment context) {__		TypeInformation<K> keyType = ((TupleTypeInfo<?>) edges.getType()).getTypeAt(0)___		TypeInformation<VV> valueType = TypeExtractor.createTypeInfo(_				MapFunction.class, vertexValueInitializer.getClass(), 1, null, null)___		@SuppressWarnings({ "unchecked", "rawtypes" })_		TypeInformation<Vertex<K, VV>> returnType = (TypeInformation<Vertex<K, VV>>) new TupleTypeInfo(_				Vertex.class, keyType, valueType)___		DataSet<Vertex<K, VV>> vertices = edges_				.flatMap(new EmitSrcAndTargetAsTuple1<K, EV>()).distinct()_				.map(new MapFunction<Tuple1<K>, Vertex<K, VV>>() {_					public Vertex<K, VV> map(Tuple1<K> value) throws Exception {_						return new Vertex<K, VV>(value.f0, vertexValueInitializer.map(value.f0))__					}_				}).returns(returnType).withForwardedFields("f0")___		return new Graph<K, VV, EV>(vertices, edges, context)__	};creates,a,graph,from,a,data,set,of,edges,vertices,are,created,automatically,and,their,values,are,set,by,applying,the,provided,map,function,to,the,vertex,ids,param,edges,a,data,set,of,edges,param,vertex,value,initializer,the,mapper,function,that,initializes,the,vertex,values,it,allows,to,apply,a,map,transformation,on,the,vertex,id,to,produce,an,initial,vertex,value,param,context,the,flink,execution,environment,return,the,newly,created,graph;public,static,k,vv,ev,graph,k,vv,ev,from,data,set,data,set,edge,k,ev,edges,final,map,function,k,vv,vertex,value,initializer,execution,environment,context,type,information,k,key,type,tuple,type,info,edges,get,type,get,type,at,0,type,information,vv,value,type,type,extractor,create,type,info,map,function,class,vertex,value,initializer,get,class,1,null,null,suppress,warnings,unchecked,rawtypes,type,information,vertex,k,vv,return,type,type,information,vertex,k,vv,new,tuple,type,info,vertex,class,key,type,value,type,data,set,vertex,k,vv,vertices,edges,flat,map,new,emit,src,and,target,as,tuple1,k,ev,distinct,map,new,map,function,tuple1,k,vertex,k,vv,public,vertex,k,vv,map,tuple1,k,value,throws,exception,return,new,vertex,k,vv,value,f0,vertex,value,initializer,map,value,f0,returns,return,type,with,forwarded,fields,f0,return,new,graph,k,vv,ev,vertices,edges,context
Graph -> public static <K, VV, EV> Graph<K, VV, EV> fromDataSet(DataSet<Edge<K, EV>> edges, 			final MapFunction<K, VV> vertexValueInitializer, ExecutionEnvironment context);1454404649;Creates a graph from a DataSet of edges._Vertices are created automatically and their values are set_by applying the provided map function to the vertex IDs.__@param edges a DataSet of edges._@param vertexValueInitializer the mapper function that initializes the vertex values._It allows to apply a map transformation on the vertex ID to produce an initial vertex value._@param context the flink execution environment._@return the newly created graph.;public static <K, VV, EV> Graph<K, VV, EV> fromDataSet(DataSet<Edge<K, EV>> edges,_			final MapFunction<K, VV> vertexValueInitializer, ExecutionEnvironment context) {__		TypeInformation<K> keyType = ((TupleTypeInfo<?>) edges.getType()).getTypeAt(0)___		TypeInformation<VV> valueType = TypeExtractor.createTypeInfo(_				MapFunction.class, vertexValueInitializer.getClass(), 1, null, null)___		@SuppressWarnings({ "unchecked", "rawtypes" })_		TypeInformation<Vertex<K, VV>> returnType = (TypeInformation<Vertex<K, VV>>) new TupleTypeInfo(_				Vertex.class, keyType, valueType)___		DataSet<Vertex<K, VV>> vertices = edges_				.flatMap(new EmitSrcAndTargetAsTuple1<K, EV>()).distinct()_				.map(new MapFunction<Tuple1<K>, Vertex<K, VV>>() {_					public Vertex<K, VV> map(Tuple1<K> value) throws Exception {_						return new Vertex<K, VV>(value.f0, vertexValueInitializer.map(value.f0))__					}_				}).returns(returnType).withForwardedFields("f0")___		return new Graph<K, VV, EV>(vertices, edges, context)__	};creates,a,graph,from,a,data,set,of,edges,vertices,are,created,automatically,and,their,values,are,set,by,applying,the,provided,map,function,to,the,vertex,ids,param,edges,a,data,set,of,edges,param,vertex,value,initializer,the,mapper,function,that,initializes,the,vertex,values,it,allows,to,apply,a,map,transformation,on,the,vertex,id,to,produce,an,initial,vertex,value,param,context,the,flink,execution,environment,return,the,newly,created,graph;public,static,k,vv,ev,graph,k,vv,ev,from,data,set,data,set,edge,k,ev,edges,final,map,function,k,vv,vertex,value,initializer,execution,environment,context,type,information,k,key,type,tuple,type,info,edges,get,type,get,type,at,0,type,information,vv,value,type,type,extractor,create,type,info,map,function,class,vertex,value,initializer,get,class,1,null,null,suppress,warnings,unchecked,rawtypes,type,information,vertex,k,vv,return,type,type,information,vertex,k,vv,new,tuple,type,info,vertex,class,key,type,value,type,data,set,vertex,k,vv,vertices,edges,flat,map,new,emit,src,and,target,as,tuple1,k,ev,distinct,map,new,map,function,tuple1,k,vertex,k,vv,public,vertex,k,vv,map,tuple1,k,value,throws,exception,return,new,vertex,k,vv,value,f0,vertex,value,initializer,map,value,f0,returns,return,type,with,forwarded,fields,f0,return,new,graph,k,vv,ev,vertices,edges,context
Graph -> public static <K, VV, EV> Graph<K, VV, EV> fromDataSet(DataSet<Edge<K, EV>> edges, 			final MapFunction<K, VV> vertexValueInitializer, ExecutionEnvironment context);1458583829;Creates a graph from a DataSet of edges._Vertices are created automatically and their values are set_by applying the provided map function to the vertex IDs.__@param edges a DataSet of edges._@param vertexValueInitializer the mapper function that initializes the vertex values._It allows to apply a map transformation on the vertex ID to produce an initial vertex value._@param context the flink execution environment._@return the newly created graph.;public static <K, VV, EV> Graph<K, VV, EV> fromDataSet(DataSet<Edge<K, EV>> edges,_			final MapFunction<K, VV> vertexValueInitializer, ExecutionEnvironment context) {__		TypeInformation<K> keyType = ((TupleTypeInfo<?>) edges.getType()).getTypeAt(0)___		TypeInformation<VV> valueType = TypeExtractor.createTypeInfo(_				MapFunction.class, vertexValueInitializer.getClass(), 1, null, null)___		@SuppressWarnings({ "unchecked", "rawtypes" })_		TypeInformation<Vertex<K, VV>> returnType = (TypeInformation<Vertex<K, VV>>) new TupleTypeInfo(_				Vertex.class, keyType, valueType)___		DataSet<Vertex<K, VV>> vertices = edges_				.flatMap(new EmitSrcAndTargetAsTuple1<K, EV>()).distinct()_				.map(new MapFunction<Tuple1<K>, Vertex<K, VV>>() {_					public Vertex<K, VV> map(Tuple1<K> value) throws Exception {_						return new Vertex<K, VV>(value.f0, vertexValueInitializer.map(value.f0))__					}_				}).returns(returnType).withForwardedFields("f0")___		return new Graph<K, VV, EV>(vertices, edges, context)__	};creates,a,graph,from,a,data,set,of,edges,vertices,are,created,automatically,and,their,values,are,set,by,applying,the,provided,map,function,to,the,vertex,ids,param,edges,a,data,set,of,edges,param,vertex,value,initializer,the,mapper,function,that,initializes,the,vertex,values,it,allows,to,apply,a,map,transformation,on,the,vertex,id,to,produce,an,initial,vertex,value,param,context,the,flink,execution,environment,return,the,newly,created,graph;public,static,k,vv,ev,graph,k,vv,ev,from,data,set,data,set,edge,k,ev,edges,final,map,function,k,vv,vertex,value,initializer,execution,environment,context,type,information,k,key,type,tuple,type,info,edges,get,type,get,type,at,0,type,information,vv,value,type,type,extractor,create,type,info,map,function,class,vertex,value,initializer,get,class,1,null,null,suppress,warnings,unchecked,rawtypes,type,information,vertex,k,vv,return,type,type,information,vertex,k,vv,new,tuple,type,info,vertex,class,key,type,value,type,data,set,vertex,k,vv,vertices,edges,flat,map,new,emit,src,and,target,as,tuple1,k,ev,distinct,map,new,map,function,tuple1,k,vertex,k,vv,public,vertex,k,vv,map,tuple1,k,value,throws,exception,return,new,vertex,k,vv,value,f0,vertex,value,initializer,map,value,f0,returns,return,type,with,forwarded,fields,f0,return,new,graph,k,vv,ev,vertices,edges,context
Graph -> public static <K, VV, EV> Graph<K, VV, EV> fromDataSet(DataSet<Edge<K, EV>> edges, 			final MapFunction<K, VV> vertexValueInitializer, ExecutionEnvironment context);1458583829;Creates a graph from a DataSet of edges._Vertices are created automatically and their values are set_by applying the provided map function to the vertex IDs.__@param edges a DataSet of edges._@param vertexValueInitializer the mapper function that initializes the vertex values._It allows to apply a map transformation on the vertex ID to produce an initial vertex value._@param context the flink execution environment._@return the newly created graph.;public static <K, VV, EV> Graph<K, VV, EV> fromDataSet(DataSet<Edge<K, EV>> edges,_			final MapFunction<K, VV> vertexValueInitializer, ExecutionEnvironment context) {__		TypeInformation<K> keyType = ((TupleTypeInfo<?>) edges.getType()).getTypeAt(0)___		TypeInformation<VV> valueType = TypeExtractor.createTypeInfo(_				MapFunction.class, vertexValueInitializer.getClass(), 1, null, null)___		@SuppressWarnings({ "unchecked", "rawtypes" })_		TypeInformation<Vertex<K, VV>> returnType = (TypeInformation<Vertex<K, VV>>) new TupleTypeInfo(_				Vertex.class, keyType, valueType)___		DataSet<Vertex<K, VV>> vertices = edges_				.flatMap(new EmitSrcAndTargetAsTuple1<K, EV>()).distinct()_				.map(new MapFunction<Tuple1<K>, Vertex<K, VV>>() {_					public Vertex<K, VV> map(Tuple1<K> value) throws Exception {_						return new Vertex<K, VV>(value.f0, vertexValueInitializer.map(value.f0))__					}_				}).returns(returnType).withForwardedFields("f0")___		return new Graph<K, VV, EV>(vertices, edges, context)__	};creates,a,graph,from,a,data,set,of,edges,vertices,are,created,automatically,and,their,values,are,set,by,applying,the,provided,map,function,to,the,vertex,ids,param,edges,a,data,set,of,edges,param,vertex,value,initializer,the,mapper,function,that,initializes,the,vertex,values,it,allows,to,apply,a,map,transformation,on,the,vertex,id,to,produce,an,initial,vertex,value,param,context,the,flink,execution,environment,return,the,newly,created,graph;public,static,k,vv,ev,graph,k,vv,ev,from,data,set,data,set,edge,k,ev,edges,final,map,function,k,vv,vertex,value,initializer,execution,environment,context,type,information,k,key,type,tuple,type,info,edges,get,type,get,type,at,0,type,information,vv,value,type,type,extractor,create,type,info,map,function,class,vertex,value,initializer,get,class,1,null,null,suppress,warnings,unchecked,rawtypes,type,information,vertex,k,vv,return,type,type,information,vertex,k,vv,new,tuple,type,info,vertex,class,key,type,value,type,data,set,vertex,k,vv,vertices,edges,flat,map,new,emit,src,and,target,as,tuple1,k,ev,distinct,map,new,map,function,tuple1,k,vertex,k,vv,public,vertex,k,vv,map,tuple1,k,value,throws,exception,return,new,vertex,k,vv,value,f0,vertex,value,initializer,map,value,f0,returns,return,type,with,forwarded,fields,f0,return,new,graph,k,vv,ev,vertices,edges,context
Graph -> public static <K, VV, EV> Graph<K, VV, EV> fromDataSet(DataSet<Edge<K, EV>> edges, 			final MapFunction<K, VV> vertexValueInitializer, ExecutionEnvironment context);1462100316;Creates a graph from a DataSet of edges._Vertices are created automatically and their values are set_by applying the provided map function to the vertex IDs.__@param edges a DataSet of edges._@param vertexValueInitializer the mapper function that initializes the vertex values._It allows to apply a map transformation on the vertex ID to produce an initial vertex value._@param context the flink execution environment._@return the newly created graph.;public static <K, VV, EV> Graph<K, VV, EV> fromDataSet(DataSet<Edge<K, EV>> edges,_			final MapFunction<K, VV> vertexValueInitializer, ExecutionEnvironment context) {__		TypeInformation<K> keyType = ((TupleTypeInfo<?>) edges.getType()).getTypeAt(0)___		TypeInformation<VV> valueType = TypeExtractor.createTypeInfo(_				MapFunction.class, vertexValueInitializer.getClass(), 1, null, null)___		@SuppressWarnings({ "unchecked", "rawtypes" })_		TypeInformation<Vertex<K, VV>> returnType = (TypeInformation<Vertex<K, VV>>) new TupleTypeInfo(_				Vertex.class, keyType, valueType)___		DataSet<Vertex<K, VV>> vertices = edges_				.flatMap(new EmitSrcAndTargetAsTuple1<K, EV>()).distinct()_				.map(new MapFunction<Tuple1<K>, Vertex<K, VV>>() {_					public Vertex<K, VV> map(Tuple1<K> value) throws Exception {_						return new Vertex<K, VV>(value.f0, vertexValueInitializer.map(value.f0))__					}_				}).returns(returnType).withForwardedFields("f0")___		return new Graph<K, VV, EV>(vertices, edges, context)__	};creates,a,graph,from,a,data,set,of,edges,vertices,are,created,automatically,and,their,values,are,set,by,applying,the,provided,map,function,to,the,vertex,ids,param,edges,a,data,set,of,edges,param,vertex,value,initializer,the,mapper,function,that,initializes,the,vertex,values,it,allows,to,apply,a,map,transformation,on,the,vertex,id,to,produce,an,initial,vertex,value,param,context,the,flink,execution,environment,return,the,newly,created,graph;public,static,k,vv,ev,graph,k,vv,ev,from,data,set,data,set,edge,k,ev,edges,final,map,function,k,vv,vertex,value,initializer,execution,environment,context,type,information,k,key,type,tuple,type,info,edges,get,type,get,type,at,0,type,information,vv,value,type,type,extractor,create,type,info,map,function,class,vertex,value,initializer,get,class,1,null,null,suppress,warnings,unchecked,rawtypes,type,information,vertex,k,vv,return,type,type,information,vertex,k,vv,new,tuple,type,info,vertex,class,key,type,value,type,data,set,vertex,k,vv,vertices,edges,flat,map,new,emit,src,and,target,as,tuple1,k,ev,distinct,map,new,map,function,tuple1,k,vertex,k,vv,public,vertex,k,vv,map,tuple1,k,value,throws,exception,return,new,vertex,k,vv,value,f0,vertex,value,initializer,map,value,f0,returns,return,type,with,forwarded,fields,f0,return,new,graph,k,vv,ev,vertices,edges,context
Graph -> public static <K, VV, EV> Graph<K, VV, EV> fromDataSet(DataSet<Edge<K, EV>> edges, 			final MapFunction<K, VV> vertexValueInitializer, ExecutionEnvironment context);1462100316;Creates a graph from a DataSet of edges._Vertices are created automatically and their values are set_by applying the provided map function to the vertex IDs.__@param edges a DataSet of edges._@param vertexValueInitializer the mapper function that initializes the vertex values._It allows to apply a map transformation on the vertex ID to produce an initial vertex value._@param context the flink execution environment._@return the newly created graph.;public static <K, VV, EV> Graph<K, VV, EV> fromDataSet(DataSet<Edge<K, EV>> edges,_			final MapFunction<K, VV> vertexValueInitializer, ExecutionEnvironment context) {__		TypeInformation<K> keyType = ((TupleTypeInfo<?>) edges.getType()).getTypeAt(0)___		TypeInformation<VV> valueType = TypeExtractor.createTypeInfo(_				MapFunction.class, vertexValueInitializer.getClass(), 1, null, null)___		@SuppressWarnings({ "unchecked", "rawtypes" })_		TypeInformation<Vertex<K, VV>> returnType = (TypeInformation<Vertex<K, VV>>) new TupleTypeInfo(_				Vertex.class, keyType, valueType)___		DataSet<Vertex<K, VV>> vertices = edges_				.flatMap(new EmitSrcAndTargetAsTuple1<K, EV>()).distinct()_				.map(new MapFunction<Tuple1<K>, Vertex<K, VV>>() {_					public Vertex<K, VV> map(Tuple1<K> value) throws Exception {_						return new Vertex<K, VV>(value.f0, vertexValueInitializer.map(value.f0))__					}_				}).returns(returnType).withForwardedFields("f0")___		return new Graph<K, VV, EV>(vertices, edges, context)__	};creates,a,graph,from,a,data,set,of,edges,vertices,are,created,automatically,and,their,values,are,set,by,applying,the,provided,map,function,to,the,vertex,ids,param,edges,a,data,set,of,edges,param,vertex,value,initializer,the,mapper,function,that,initializes,the,vertex,values,it,allows,to,apply,a,map,transformation,on,the,vertex,id,to,produce,an,initial,vertex,value,param,context,the,flink,execution,environment,return,the,newly,created,graph;public,static,k,vv,ev,graph,k,vv,ev,from,data,set,data,set,edge,k,ev,edges,final,map,function,k,vv,vertex,value,initializer,execution,environment,context,type,information,k,key,type,tuple,type,info,edges,get,type,get,type,at,0,type,information,vv,value,type,type,extractor,create,type,info,map,function,class,vertex,value,initializer,get,class,1,null,null,suppress,warnings,unchecked,rawtypes,type,information,vertex,k,vv,return,type,type,information,vertex,k,vv,new,tuple,type,info,vertex,class,key,type,value,type,data,set,vertex,k,vv,vertices,edges,flat,map,new,emit,src,and,target,as,tuple1,k,ev,distinct,map,new,map,function,tuple1,k,vertex,k,vv,public,vertex,k,vv,map,tuple1,k,value,throws,exception,return,new,vertex,k,vv,value,f0,vertex,value,initializer,map,value,f0,returns,return,type,with,forwarded,fields,f0,return,new,graph,k,vv,ev,vertices,edges,context
Graph -> public static <K, VV, EV> Graph<K, VV, EV> fromDataSet(DataSet<Edge<K, EV>> edges, 			final MapFunction<K, VV> vertexValueInitializer, ExecutionEnvironment context);1462205213;Creates a graph from a DataSet of edges._Vertices are created automatically and their values are set_by applying the provided map function to the vertex IDs.__@param edges a DataSet of edges._@param vertexValueInitializer the mapper function that initializes the vertex values._It allows to apply a map transformation on the vertex ID to produce an initial vertex value._@param context the flink execution environment._@return the newly created graph.;public static <K, VV, EV> Graph<K, VV, EV> fromDataSet(DataSet<Edge<K, EV>> edges,_			final MapFunction<K, VV> vertexValueInitializer, ExecutionEnvironment context) {__		TypeInformation<K> keyType = ((TupleTypeInfo<?>) edges.getType()).getTypeAt(0)___		TypeInformation<VV> valueType = TypeExtractor.createTypeInfo(_				MapFunction.class, vertexValueInitializer.getClass(), 1, null, null)___		@SuppressWarnings({ "unchecked", "rawtypes" })_		TypeInformation<Vertex<K, VV>> returnType = (TypeInformation<Vertex<K, VV>>) new TupleTypeInfo(_				Vertex.class, keyType, valueType)___		DataSet<Vertex<K, VV>> vertices = edges_				.flatMap(new EmitSrcAndTargetAsTuple1<K, EV>()).distinct()_				.map(new MapFunction<Tuple1<K>, Vertex<K, VV>>() {_					public Vertex<K, VV> map(Tuple1<K> value) throws Exception {_						return new Vertex<K, VV>(value.f0, vertexValueInitializer.map(value.f0))__					}_				}).returns(returnType).withForwardedFields("f0")___		return new Graph<K, VV, EV>(vertices, edges, context)__	};creates,a,graph,from,a,data,set,of,edges,vertices,are,created,automatically,and,their,values,are,set,by,applying,the,provided,map,function,to,the,vertex,ids,param,edges,a,data,set,of,edges,param,vertex,value,initializer,the,mapper,function,that,initializes,the,vertex,values,it,allows,to,apply,a,map,transformation,on,the,vertex,id,to,produce,an,initial,vertex,value,param,context,the,flink,execution,environment,return,the,newly,created,graph;public,static,k,vv,ev,graph,k,vv,ev,from,data,set,data,set,edge,k,ev,edges,final,map,function,k,vv,vertex,value,initializer,execution,environment,context,type,information,k,key,type,tuple,type,info,edges,get,type,get,type,at,0,type,information,vv,value,type,type,extractor,create,type,info,map,function,class,vertex,value,initializer,get,class,1,null,null,suppress,warnings,unchecked,rawtypes,type,information,vertex,k,vv,return,type,type,information,vertex,k,vv,new,tuple,type,info,vertex,class,key,type,value,type,data,set,vertex,k,vv,vertices,edges,flat,map,new,emit,src,and,target,as,tuple1,k,ev,distinct,map,new,map,function,tuple1,k,vertex,k,vv,public,vertex,k,vv,map,tuple1,k,value,throws,exception,return,new,vertex,k,vv,value,f0,vertex,value,initializer,map,value,f0,returns,return,type,with,forwarded,fields,f0,return,new,graph,k,vv,ev,vertices,edges,context
Graph -> public static <K, VV, EV> Graph<K, VV, EV> fromDataSet(DataSet<Edge<K, EV>> edges, 			final MapFunction<K, VV> vertexValueInitializer, ExecutionEnvironment context);1462208859;Creates a graph from a DataSet of edges._Vertices are created automatically and their values are set_by applying the provided map function to the vertex IDs.__@param edges a DataSet of edges._@param vertexValueInitializer the mapper function that initializes the vertex values._It allows to apply a map transformation on the vertex ID to produce an initial vertex value._@param context the flink execution environment._@return the newly created graph.;public static <K, VV, EV> Graph<K, VV, EV> fromDataSet(DataSet<Edge<K, EV>> edges,_			final MapFunction<K, VV> vertexValueInitializer, ExecutionEnvironment context) {__		TypeInformation<K> keyType = ((TupleTypeInfo<?>) edges.getType()).getTypeAt(0)___		TypeInformation<VV> valueType = TypeExtractor.createTypeInfo(_				MapFunction.class, vertexValueInitializer.getClass(), 1, null, null)___		@SuppressWarnings({ "unchecked", "rawtypes" })_		TypeInformation<Vertex<K, VV>> returnType = (TypeInformation<Vertex<K, VV>>) new TupleTypeInfo(_				Vertex.class, keyType, valueType)___		DataSet<Vertex<K, VV>> vertices = edges_				.flatMap(new EmitSrcAndTargetAsTuple1<K, EV>()).distinct()_				.map(new MapFunction<Tuple1<K>, Vertex<K, VV>>() {_					public Vertex<K, VV> map(Tuple1<K> value) throws Exception {_						return new Vertex<K, VV>(value.f0, vertexValueInitializer.map(value.f0))__					}_				}).returns(returnType).withForwardedFields("f0")___		return new Graph<K, VV, EV>(vertices, edges, context)__	};creates,a,graph,from,a,data,set,of,edges,vertices,are,created,automatically,and,their,values,are,set,by,applying,the,provided,map,function,to,the,vertex,ids,param,edges,a,data,set,of,edges,param,vertex,value,initializer,the,mapper,function,that,initializes,the,vertex,values,it,allows,to,apply,a,map,transformation,on,the,vertex,id,to,produce,an,initial,vertex,value,param,context,the,flink,execution,environment,return,the,newly,created,graph;public,static,k,vv,ev,graph,k,vv,ev,from,data,set,data,set,edge,k,ev,edges,final,map,function,k,vv,vertex,value,initializer,execution,environment,context,type,information,k,key,type,tuple,type,info,edges,get,type,get,type,at,0,type,information,vv,value,type,type,extractor,create,type,info,map,function,class,vertex,value,initializer,get,class,1,null,null,suppress,warnings,unchecked,rawtypes,type,information,vertex,k,vv,return,type,type,information,vertex,k,vv,new,tuple,type,info,vertex,class,key,type,value,type,data,set,vertex,k,vv,vertices,edges,flat,map,new,emit,src,and,target,as,tuple1,k,ev,distinct,map,new,map,function,tuple1,k,vertex,k,vv,public,vertex,k,vv,map,tuple1,k,value,throws,exception,return,new,vertex,k,vv,value,f0,vertex,value,initializer,map,value,f0,returns,return,type,with,forwarded,fields,f0,return,new,graph,k,vv,ev,vertices,edges,context
Graph -> public static <K, VV, EV> Graph<K, VV, EV> fromDataSet(DataSet<Edge<K, EV>> edges, 			final MapFunction<K, VV> vertexValueInitializer, ExecutionEnvironment context);1462809297;Creates a graph from a DataSet of edges._Vertices are created automatically and their values are set_by applying the provided map function to the vertex IDs.__@param edges a DataSet of edges._@param vertexValueInitializer the mapper function that initializes the vertex values._It allows to apply a map transformation on the vertex ID to produce an initial vertex value._@param context the flink execution environment._@return the newly created graph.;public static <K, VV, EV> Graph<K, VV, EV> fromDataSet(DataSet<Edge<K, EV>> edges,_			final MapFunction<K, VV> vertexValueInitializer, ExecutionEnvironment context) {__		TypeInformation<K> keyType = ((TupleTypeInfo<?>) edges.getType()).getTypeAt(0)___		TypeInformation<VV> valueType = TypeExtractor.createTypeInfo(_				MapFunction.class, vertexValueInitializer.getClass(), 1, null, null)___		@SuppressWarnings({ "unchecked", "rawtypes" })_		TypeInformation<Vertex<K, VV>> returnType = (TypeInformation<Vertex<K, VV>>) new TupleTypeInfo(_				Vertex.class, keyType, valueType)___		DataSet<Vertex<K, VV>> vertices = edges_				.flatMap(new EmitSrcAndTargetAsTuple1<K, EV>()).distinct()_				.map(new MapFunction<Tuple1<K>, Vertex<K, VV>>() {_					public Vertex<K, VV> map(Tuple1<K> value) throws Exception {_						return new Vertex<K, VV>(value.f0, vertexValueInitializer.map(value.f0))__					}_				}).returns(returnType).withForwardedFields("f0")___		return new Graph<K, VV, EV>(vertices, edges, context)__	};creates,a,graph,from,a,data,set,of,edges,vertices,are,created,automatically,and,their,values,are,set,by,applying,the,provided,map,function,to,the,vertex,ids,param,edges,a,data,set,of,edges,param,vertex,value,initializer,the,mapper,function,that,initializes,the,vertex,values,it,allows,to,apply,a,map,transformation,on,the,vertex,id,to,produce,an,initial,vertex,value,param,context,the,flink,execution,environment,return,the,newly,created,graph;public,static,k,vv,ev,graph,k,vv,ev,from,data,set,data,set,edge,k,ev,edges,final,map,function,k,vv,vertex,value,initializer,execution,environment,context,type,information,k,key,type,tuple,type,info,edges,get,type,get,type,at,0,type,information,vv,value,type,type,extractor,create,type,info,map,function,class,vertex,value,initializer,get,class,1,null,null,suppress,warnings,unchecked,rawtypes,type,information,vertex,k,vv,return,type,type,information,vertex,k,vv,new,tuple,type,info,vertex,class,key,type,value,type,data,set,vertex,k,vv,vertices,edges,flat,map,new,emit,src,and,target,as,tuple1,k,ev,distinct,map,new,map,function,tuple1,k,vertex,k,vv,public,vertex,k,vv,map,tuple1,k,value,throws,exception,return,new,vertex,k,vv,value,f0,vertex,value,initializer,map,value,f0,returns,return,type,with,forwarded,fields,f0,return,new,graph,k,vv,ev,vertices,edges,context
Graph -> public static <K, VV, EV> Graph<K, VV, EV> fromDataSet(DataSet<Edge<K, EV>> edges, 			final MapFunction<K, VV> vertexValueInitializer, ExecutionEnvironment context);1465316775;Creates a graph from a DataSet of edges._Vertices are created automatically and their values are set_by applying the provided map function to the vertex IDs.__@param edges a DataSet of edges._@param vertexValueInitializer the mapper function that initializes the vertex values._It allows to apply a map transformation on the vertex ID to produce an initial vertex value._@param context the flink execution environment._@return the newly created graph.;public static <K, VV, EV> Graph<K, VV, EV> fromDataSet(DataSet<Edge<K, EV>> edges,_			final MapFunction<K, VV> vertexValueInitializer, ExecutionEnvironment context) {__		TypeInformation<K> keyType = ((TupleTypeInfo<?>) edges.getType()).getTypeAt(0)___		TypeInformation<VV> valueType = TypeExtractor.createTypeInfo(_				MapFunction.class, vertexValueInitializer.getClass(), 1, null, null)___		@SuppressWarnings({ "unchecked", "rawtypes" })_		TypeInformation<Vertex<K, VV>> returnType = (TypeInformation<Vertex<K, VV>>) new TupleTypeInfo(_				Vertex.class, keyType, valueType)___		DataSet<Vertex<K, VV>> vertices = edges_				.flatMap(new EmitSrcAndTargetAsTuple1<K, EV>()).distinct()_				.map(new MapFunction<Tuple1<K>, Vertex<K, VV>>() {_					public Vertex<K, VV> map(Tuple1<K> value) throws Exception {_						return new Vertex<K, VV>(value.f0, vertexValueInitializer.map(value.f0))__					}_				}).returns(returnType).withForwardedFields("f0")___		return new Graph<K, VV, EV>(vertices, edges, context)__	};creates,a,graph,from,a,data,set,of,edges,vertices,are,created,automatically,and,their,values,are,set,by,applying,the,provided,map,function,to,the,vertex,ids,param,edges,a,data,set,of,edges,param,vertex,value,initializer,the,mapper,function,that,initializes,the,vertex,values,it,allows,to,apply,a,map,transformation,on,the,vertex,id,to,produce,an,initial,vertex,value,param,context,the,flink,execution,environment,return,the,newly,created,graph;public,static,k,vv,ev,graph,k,vv,ev,from,data,set,data,set,edge,k,ev,edges,final,map,function,k,vv,vertex,value,initializer,execution,environment,context,type,information,k,key,type,tuple,type,info,edges,get,type,get,type,at,0,type,information,vv,value,type,type,extractor,create,type,info,map,function,class,vertex,value,initializer,get,class,1,null,null,suppress,warnings,unchecked,rawtypes,type,information,vertex,k,vv,return,type,type,information,vertex,k,vv,new,tuple,type,info,vertex,class,key,type,value,type,data,set,vertex,k,vv,vertices,edges,flat,map,new,emit,src,and,target,as,tuple1,k,ev,distinct,map,new,map,function,tuple1,k,vertex,k,vv,public,vertex,k,vv,map,tuple1,k,value,throws,exception,return,new,vertex,k,vv,value,f0,vertex,value,initializer,map,value,f0,returns,return,type,with,forwarded,fields,f0,return,new,graph,k,vv,ev,vertices,edges,context
Graph -> public static <K, VV, EV> Graph<K, VV, EV> fromDataSet(DataSet<Edge<K, EV>> edges, 			final MapFunction<K, VV> vertexValueInitializer, ExecutionEnvironment context);1466789678;Creates a graph from a DataSet of edges._Vertices are created automatically and their values are set_by applying the provided map function to the vertex IDs.__@param edges a DataSet of edges._@param vertexValueInitializer the mapper function that initializes the vertex values._It allows to apply a map transformation on the vertex ID to produce an initial vertex value._@param context the flink execution environment._@return the newly created graph.;public static <K, VV, EV> Graph<K, VV, EV> fromDataSet(DataSet<Edge<K, EV>> edges,_			final MapFunction<K, VV> vertexValueInitializer, ExecutionEnvironment context) {__		TypeInformation<K> keyType = ((TupleTypeInfo<?>) edges.getType()).getTypeAt(0)___		TypeInformation<VV> valueType = TypeExtractor.createTypeInfo(_				MapFunction.class, vertexValueInitializer.getClass(), 1, null, null)___		@SuppressWarnings({ "unchecked", "rawtypes" })_		TypeInformation<Vertex<K, VV>> returnType = (TypeInformation<Vertex<K, VV>>) new TupleTypeInfo(_				Vertex.class, keyType, valueType)___		DataSet<Vertex<K, VV>> vertices = edges_				.flatMap(new EmitSrcAndTargetAsTuple1<K, EV>()).distinct()_				.map(new MapFunction<Tuple1<K>, Vertex<K, VV>>() {_					public Vertex<K, VV> map(Tuple1<K> value) throws Exception {_						return new Vertex<K, VV>(value.f0, vertexValueInitializer.map(value.f0))__					}_				}).returns(returnType).withForwardedFields("f0")___		return new Graph<K, VV, EV>(vertices, edges, context)__	};creates,a,graph,from,a,data,set,of,edges,vertices,are,created,automatically,and,their,values,are,set,by,applying,the,provided,map,function,to,the,vertex,ids,param,edges,a,data,set,of,edges,param,vertex,value,initializer,the,mapper,function,that,initializes,the,vertex,values,it,allows,to,apply,a,map,transformation,on,the,vertex,id,to,produce,an,initial,vertex,value,param,context,the,flink,execution,environment,return,the,newly,created,graph;public,static,k,vv,ev,graph,k,vv,ev,from,data,set,data,set,edge,k,ev,edges,final,map,function,k,vv,vertex,value,initializer,execution,environment,context,type,information,k,key,type,tuple,type,info,edges,get,type,get,type,at,0,type,information,vv,value,type,type,extractor,create,type,info,map,function,class,vertex,value,initializer,get,class,1,null,null,suppress,warnings,unchecked,rawtypes,type,information,vertex,k,vv,return,type,type,information,vertex,k,vv,new,tuple,type,info,vertex,class,key,type,value,type,data,set,vertex,k,vv,vertices,edges,flat,map,new,emit,src,and,target,as,tuple1,k,ev,distinct,map,new,map,function,tuple1,k,vertex,k,vv,public,vertex,k,vv,map,tuple1,k,value,throws,exception,return,new,vertex,k,vv,value,f0,vertex,value,initializer,map,value,f0,returns,return,type,with,forwarded,fields,f0,return,new,graph,k,vv,ev,vertices,edges,context
Graph -> public static <K, VV, EV> Graph<K, VV, EV> fromDataSet(DataSet<Edge<K, EV>> edges, 			final MapFunction<K, VV> vertexValueInitializer, ExecutionEnvironment context);1467140656;Creates a graph from a DataSet of edges._Vertices are created automatically and their values are set_by applying the provided map function to the vertex IDs.__@param edges a DataSet of edges._@param vertexValueInitializer the mapper function that initializes the vertex values._It allows to apply a map transformation on the vertex ID to produce an initial vertex value._@param context the flink execution environment._@return the newly created graph.;public static <K, VV, EV> Graph<K, VV, EV> fromDataSet(DataSet<Edge<K, EV>> edges,_			final MapFunction<K, VV> vertexValueInitializer, ExecutionEnvironment context) {__		TypeInformation<K> keyType = ((TupleTypeInfo<?>) edges.getType()).getTypeAt(0)___		TypeInformation<VV> valueType = TypeExtractor.createTypeInfo(_				MapFunction.class, vertexValueInitializer.getClass(), 1, null, null)___		@SuppressWarnings({ "unchecked", "rawtypes" })_		TypeInformation<Vertex<K, VV>> returnType = (TypeInformation<Vertex<K, VV>>) new TupleTypeInfo(_				Vertex.class, keyType, valueType)___		DataSet<Vertex<K, VV>> vertices = edges_				.flatMap(new EmitSrcAndTargetAsTuple1<K, EV>()).distinct()_				.map(new MapFunction<Tuple1<K>, Vertex<K, VV>>() {_					public Vertex<K, VV> map(Tuple1<K> value) throws Exception {_						return new Vertex<K, VV>(value.f0, vertexValueInitializer.map(value.f0))__					}_				}).returns(returnType).withForwardedFields("f0")___		return new Graph<K, VV, EV>(vertices, edges, context)__	};creates,a,graph,from,a,data,set,of,edges,vertices,are,created,automatically,and,their,values,are,set,by,applying,the,provided,map,function,to,the,vertex,ids,param,edges,a,data,set,of,edges,param,vertex,value,initializer,the,mapper,function,that,initializes,the,vertex,values,it,allows,to,apply,a,map,transformation,on,the,vertex,id,to,produce,an,initial,vertex,value,param,context,the,flink,execution,environment,return,the,newly,created,graph;public,static,k,vv,ev,graph,k,vv,ev,from,data,set,data,set,edge,k,ev,edges,final,map,function,k,vv,vertex,value,initializer,execution,environment,context,type,information,k,key,type,tuple,type,info,edges,get,type,get,type,at,0,type,information,vv,value,type,type,extractor,create,type,info,map,function,class,vertex,value,initializer,get,class,1,null,null,suppress,warnings,unchecked,rawtypes,type,information,vertex,k,vv,return,type,type,information,vertex,k,vv,new,tuple,type,info,vertex,class,key,type,value,type,data,set,vertex,k,vv,vertices,edges,flat,map,new,emit,src,and,target,as,tuple1,k,ev,distinct,map,new,map,function,tuple1,k,vertex,k,vv,public,vertex,k,vv,map,tuple1,k,value,throws,exception,return,new,vertex,k,vv,value,f0,vertex,value,initializer,map,value,f0,returns,return,type,with,forwarded,fields,f0,return,new,graph,k,vv,ev,vertices,edges,context
Graph -> public static <K, VV, EV> Graph<K, VV, EV> fromDataSet(DataSet<Edge<K, EV>> edges, 			final MapFunction<K, VV> vertexValueInitializer, ExecutionEnvironment context);1467306272;Creates a graph from a DataSet of edges._Vertices are created automatically and their values are set_by applying the provided map function to the vertex IDs.__@param edges a DataSet of edges._@param vertexValueInitializer the mapper function that initializes the vertex values._It allows to apply a map transformation on the vertex ID to produce an initial vertex value._@param context the flink execution environment._@return the newly created graph.;public static <K, VV, EV> Graph<K, VV, EV> fromDataSet(DataSet<Edge<K, EV>> edges,_			final MapFunction<K, VV> vertexValueInitializer, ExecutionEnvironment context) {__		TypeInformation<K> keyType = ((TupleTypeInfo<?>) edges.getType()).getTypeAt(0)___		TypeInformation<VV> valueType = TypeExtractor.createTypeInfo(_				MapFunction.class, vertexValueInitializer.getClass(), 1, null, null)___		@SuppressWarnings({ "unchecked", "rawtypes" })_		TypeInformation<Vertex<K, VV>> returnType = (TypeInformation<Vertex<K, VV>>) new TupleTypeInfo(_				Vertex.class, keyType, valueType)___		DataSet<Vertex<K, VV>> vertices = edges_				.flatMap(new EmitSrcAndTargetAsTuple1<K, EV>()).distinct()_				.map(new MapFunction<Tuple1<K>, Vertex<K, VV>>() {_					public Vertex<K, VV> map(Tuple1<K> value) throws Exception {_						return new Vertex<K, VV>(value.f0, vertexValueInitializer.map(value.f0))__					}_				}).returns(returnType).withForwardedFields("f0")___		return new Graph<K, VV, EV>(vertices, edges, context)__	};creates,a,graph,from,a,data,set,of,edges,vertices,are,created,automatically,and,their,values,are,set,by,applying,the,provided,map,function,to,the,vertex,ids,param,edges,a,data,set,of,edges,param,vertex,value,initializer,the,mapper,function,that,initializes,the,vertex,values,it,allows,to,apply,a,map,transformation,on,the,vertex,id,to,produce,an,initial,vertex,value,param,context,the,flink,execution,environment,return,the,newly,created,graph;public,static,k,vv,ev,graph,k,vv,ev,from,data,set,data,set,edge,k,ev,edges,final,map,function,k,vv,vertex,value,initializer,execution,environment,context,type,information,k,key,type,tuple,type,info,edges,get,type,get,type,at,0,type,information,vv,value,type,type,extractor,create,type,info,map,function,class,vertex,value,initializer,get,class,1,null,null,suppress,warnings,unchecked,rawtypes,type,information,vertex,k,vv,return,type,type,information,vertex,k,vv,new,tuple,type,info,vertex,class,key,type,value,type,data,set,vertex,k,vv,vertices,edges,flat,map,new,emit,src,and,target,as,tuple1,k,ev,distinct,map,new,map,function,tuple1,k,vertex,k,vv,public,vertex,k,vv,map,tuple1,k,value,throws,exception,return,new,vertex,k,vv,value,f0,vertex,value,initializer,map,value,f0,returns,return,type,with,forwarded,fields,f0,return,new,graph,k,vv,ev,vertices,edges,context
Graph -> public static <K, VV, EV> Graph<K, VV, EV> fromDataSet(DataSet<Edge<K, EV>> edges, 			final MapFunction<K, VV> vertexValueInitializer, ExecutionEnvironment context);1470042815;Creates a graph from a DataSet of edges._Vertices are created automatically and their values are set_by applying the provided map function to the vertex IDs.__@param edges a DataSet of edges._@param vertexValueInitializer the mapper function that initializes the vertex values._It allows to apply a map transformation on the vertex ID to produce an initial vertex value._@param context the flink execution environment._@return the newly created graph.;public static <K, VV, EV> Graph<K, VV, EV> fromDataSet(DataSet<Edge<K, EV>> edges,_			final MapFunction<K, VV> vertexValueInitializer, ExecutionEnvironment context) {__		TypeInformation<K> keyType = ((TupleTypeInfo<?>) edges.getType()).getTypeAt(0)___		TypeInformation<VV> valueType = TypeExtractor.createTypeInfo(_				MapFunction.class, vertexValueInitializer.getClass(), 1, null, null)___		@SuppressWarnings({ "unchecked", "rawtypes" })_		TypeInformation<Vertex<K, VV>> returnType = (TypeInformation<Vertex<K, VV>>) new TupleTypeInfo(_				Vertex.class, keyType, valueType)___		DataSet<Vertex<K, VV>> vertices = edges_				.flatMap(new EmitSrcAndTargetAsTuple1<K, EV>()).distinct()_				.map(new MapFunction<Tuple1<K>, Vertex<K, VV>>() {_					public Vertex<K, VV> map(Tuple1<K> value) throws Exception {_						return new Vertex<K, VV>(value.f0, vertexValueInitializer.map(value.f0))__					}_				}).returns(returnType).withForwardedFields("f0")___		return new Graph<K, VV, EV>(vertices, edges, context)__	};creates,a,graph,from,a,data,set,of,edges,vertices,are,created,automatically,and,their,values,are,set,by,applying,the,provided,map,function,to,the,vertex,ids,param,edges,a,data,set,of,edges,param,vertex,value,initializer,the,mapper,function,that,initializes,the,vertex,values,it,allows,to,apply,a,map,transformation,on,the,vertex,id,to,produce,an,initial,vertex,value,param,context,the,flink,execution,environment,return,the,newly,created,graph;public,static,k,vv,ev,graph,k,vv,ev,from,data,set,data,set,edge,k,ev,edges,final,map,function,k,vv,vertex,value,initializer,execution,environment,context,type,information,k,key,type,tuple,type,info,edges,get,type,get,type,at,0,type,information,vv,value,type,type,extractor,create,type,info,map,function,class,vertex,value,initializer,get,class,1,null,null,suppress,warnings,unchecked,rawtypes,type,information,vertex,k,vv,return,type,type,information,vertex,k,vv,new,tuple,type,info,vertex,class,key,type,value,type,data,set,vertex,k,vv,vertices,edges,flat,map,new,emit,src,and,target,as,tuple1,k,ev,distinct,map,new,map,function,tuple1,k,vertex,k,vv,public,vertex,k,vv,map,tuple1,k,value,throws,exception,return,new,vertex,k,vv,value,f0,vertex,value,initializer,map,value,f0,returns,return,type,with,forwarded,fields,f0,return,new,graph,k,vv,ev,vertices,edges,context
Graph -> public static <K, VV, EV> Graph<K, VV, EV> fromDataSet(DataSet<Edge<K, EV>> edges, 			final MapFunction<K, VV> vertexValueInitializer, ExecutionEnvironment context);1475684776;Creates a graph from a DataSet of edges._Vertices are created automatically and their values are set_by applying the provided map function to the vertex IDs.__@param edges a DataSet of edges._@param vertexValueInitializer the mapper function that initializes the vertex values._It allows to apply a map transformation on the vertex ID to produce an initial vertex value._@param context the flink execution environment._@return the newly created graph.;public static <K, VV, EV> Graph<K, VV, EV> fromDataSet(DataSet<Edge<K, EV>> edges,_			final MapFunction<K, VV> vertexValueInitializer, ExecutionEnvironment context) {__		TypeInformation<K> keyType = ((TupleTypeInfo<?>) edges.getType()).getTypeAt(0)___		TypeInformation<VV> valueType = TypeExtractor.createTypeInfo(_				MapFunction.class, vertexValueInitializer.getClass(), 1, null, null)___		@SuppressWarnings({ "unchecked", "rawtypes" })_		TypeInformation<Vertex<K, VV>> returnType = (TypeInformation<Vertex<K, VV>>) new TupleTypeInfo(_				Vertex.class, keyType, valueType)___		DataSet<Vertex<K, VV>> vertices = edges_				.flatMap(new EmitSrcAndTargetAsTuple1<K, EV>()).distinct()_				.map(new MapFunction<Tuple1<K>, Vertex<K, VV>>() {_					public Vertex<K, VV> map(Tuple1<K> value) throws Exception {_						return new Vertex<>(value.f0, vertexValueInitializer.map(value.f0))__					}_				}).returns(returnType).withForwardedFields("f0")___		return new Graph<>(vertices, edges, context)__	};creates,a,graph,from,a,data,set,of,edges,vertices,are,created,automatically,and,their,values,are,set,by,applying,the,provided,map,function,to,the,vertex,ids,param,edges,a,data,set,of,edges,param,vertex,value,initializer,the,mapper,function,that,initializes,the,vertex,values,it,allows,to,apply,a,map,transformation,on,the,vertex,id,to,produce,an,initial,vertex,value,param,context,the,flink,execution,environment,return,the,newly,created,graph;public,static,k,vv,ev,graph,k,vv,ev,from,data,set,data,set,edge,k,ev,edges,final,map,function,k,vv,vertex,value,initializer,execution,environment,context,type,information,k,key,type,tuple,type,info,edges,get,type,get,type,at,0,type,information,vv,value,type,type,extractor,create,type,info,map,function,class,vertex,value,initializer,get,class,1,null,null,suppress,warnings,unchecked,rawtypes,type,information,vertex,k,vv,return,type,type,information,vertex,k,vv,new,tuple,type,info,vertex,class,key,type,value,type,data,set,vertex,k,vv,vertices,edges,flat,map,new,emit,src,and,target,as,tuple1,k,ev,distinct,map,new,map,function,tuple1,k,vertex,k,vv,public,vertex,k,vv,map,tuple1,k,value,throws,exception,return,new,vertex,value,f0,vertex,value,initializer,map,value,f0,returns,return,type,with,forwarded,fields,f0,return,new,graph,vertices,edges,context
Graph -> public static <K, VV, EV> Graph<K, VV, EV> fromDataSet(DataSet<Edge<K, EV>> edges, 			final MapFunction<K, VV> vertexValueInitializer, ExecutionEnvironment context);1475685606;Creates a graph from a DataSet of edges._Vertices are created automatically and their values are set_by applying the provided map function to the vertex IDs.__@param edges a DataSet of edges._@param vertexValueInitializer the mapper function that initializes the vertex values._It allows to apply a map transformation on the vertex ID to produce an initial vertex value._@param context the flink execution environment._@return the newly created graph.;public static <K, VV, EV> Graph<K, VV, EV> fromDataSet(DataSet<Edge<K, EV>> edges,_			final MapFunction<K, VV> vertexValueInitializer, ExecutionEnvironment context) {__		TypeInformation<K> keyType = ((TupleTypeInfo<?>) edges.getType()).getTypeAt(0)___		TypeInformation<VV> valueType = TypeExtractor.createTypeInfo(_				MapFunction.class, vertexValueInitializer.getClass(), 1, null, null)___		@SuppressWarnings({ "unchecked", "rawtypes" })_		TypeInformation<Vertex<K, VV>> returnType = (TypeInformation<Vertex<K, VV>>) new TupleTypeInfo(_				Vertex.class, keyType, valueType)___		DataSet<Vertex<K, VV>> vertices = edges_				.flatMap(new EmitSrcAndTargetAsTuple1<K, EV>()).distinct()_				.map(new MapFunction<Tuple1<K>, Vertex<K, VV>>() {_					public Vertex<K, VV> map(Tuple1<K> value) throws Exception {_						return new Vertex<>(value.f0, vertexValueInitializer.map(value.f0))__					}_				}).returns(returnType).withForwardedFields("f0")___		return new Graph<>(vertices, edges, context)__	};creates,a,graph,from,a,data,set,of,edges,vertices,are,created,automatically,and,their,values,are,set,by,applying,the,provided,map,function,to,the,vertex,ids,param,edges,a,data,set,of,edges,param,vertex,value,initializer,the,mapper,function,that,initializes,the,vertex,values,it,allows,to,apply,a,map,transformation,on,the,vertex,id,to,produce,an,initial,vertex,value,param,context,the,flink,execution,environment,return,the,newly,created,graph;public,static,k,vv,ev,graph,k,vv,ev,from,data,set,data,set,edge,k,ev,edges,final,map,function,k,vv,vertex,value,initializer,execution,environment,context,type,information,k,key,type,tuple,type,info,edges,get,type,get,type,at,0,type,information,vv,value,type,type,extractor,create,type,info,map,function,class,vertex,value,initializer,get,class,1,null,null,suppress,warnings,unchecked,rawtypes,type,information,vertex,k,vv,return,type,type,information,vertex,k,vv,new,tuple,type,info,vertex,class,key,type,value,type,data,set,vertex,k,vv,vertices,edges,flat,map,new,emit,src,and,target,as,tuple1,k,ev,distinct,map,new,map,function,tuple1,k,vertex,k,vv,public,vertex,k,vv,map,tuple1,k,value,throws,exception,return,new,vertex,value,f0,vertex,value,initializer,map,value,f0,returns,return,type,with,forwarded,fields,f0,return,new,graph,vertices,edges,context
Graph -> public static <K, VV, EV> Graph<K, VV, EV> fromDataSet(DataSet<Edge<K, EV>> edges, 			final MapFunction<K, VV> vertexValueInitializer, ExecutionEnvironment context);1481745825;Creates a graph from a DataSet of edges._Vertices are created automatically and their values are set_by applying the provided map function to the vertex IDs.__@param edges a DataSet of edges._@param vertexValueInitializer the mapper function that initializes the vertex values._It allows to apply a map transformation on the vertex ID to produce an initial vertex value._@param context the flink execution environment._@return the newly created graph.;public static <K, VV, EV> Graph<K, VV, EV> fromDataSet(DataSet<Edge<K, EV>> edges,_			final MapFunction<K, VV> vertexValueInitializer, ExecutionEnvironment context) {__		TypeInformation<K> keyType = ((TupleTypeInfo<?>) edges.getType()).getTypeAt(0)___		TypeInformation<VV> valueType = TypeExtractor.createTypeInfo(_				MapFunction.class, vertexValueInitializer.getClass(), 1, null, null)___		@SuppressWarnings({ "unchecked", "rawtypes" })_		TypeInformation<Vertex<K, VV>> returnType = (TypeInformation<Vertex<K, VV>>) new TupleTypeInfo(_				Vertex.class, keyType, valueType)___		DataSet<Vertex<K, VV>> vertices = edges_			.flatMap(new EmitSrcAndTargetAsTuple1<K, EV>())_				.name("Source and target IDs")_			.distinct()_				.name("IDs")_			.map(new MapFunction<Tuple1<K>, Vertex<K, VV>>() {_				private Vertex<K, VV> output = new Vertex<>()___				public Vertex<K, VV> map(Tuple1<K> value) throws Exception {_					output.f0 = value.f0__					output.f1 = vertexValueInitializer.map(value.f0)__					return output__				}_			}).returns(returnType).withForwardedFields("f0").name("Initialize vertex values")___		return new Graph<>(vertices, edges, context)__	};creates,a,graph,from,a,data,set,of,edges,vertices,are,created,automatically,and,their,values,are,set,by,applying,the,provided,map,function,to,the,vertex,ids,param,edges,a,data,set,of,edges,param,vertex,value,initializer,the,mapper,function,that,initializes,the,vertex,values,it,allows,to,apply,a,map,transformation,on,the,vertex,id,to,produce,an,initial,vertex,value,param,context,the,flink,execution,environment,return,the,newly,created,graph;public,static,k,vv,ev,graph,k,vv,ev,from,data,set,data,set,edge,k,ev,edges,final,map,function,k,vv,vertex,value,initializer,execution,environment,context,type,information,k,key,type,tuple,type,info,edges,get,type,get,type,at,0,type,information,vv,value,type,type,extractor,create,type,info,map,function,class,vertex,value,initializer,get,class,1,null,null,suppress,warnings,unchecked,rawtypes,type,information,vertex,k,vv,return,type,type,information,vertex,k,vv,new,tuple,type,info,vertex,class,key,type,value,type,data,set,vertex,k,vv,vertices,edges,flat,map,new,emit,src,and,target,as,tuple1,k,ev,name,source,and,target,ids,distinct,name,ids,map,new,map,function,tuple1,k,vertex,k,vv,private,vertex,k,vv,output,new,vertex,public,vertex,k,vv,map,tuple1,k,value,throws,exception,output,f0,value,f0,output,f1,vertex,value,initializer,map,value,f0,return,output,returns,return,type,with,forwarded,fields,f0,name,initialize,vertex,values,return,new,graph,vertices,edges,context
Graph -> public static <K, VV, EV> Graph<K, VV, EV> fromDataSet(DataSet<Edge<K, EV>> edges, 			final MapFunction<K, VV> vertexValueInitializer, ExecutionEnvironment context);1481881009;Creates a graph from a DataSet of edges._Vertices are created automatically and their values are set_by applying the provided map function to the vertex IDs.__@param edges a DataSet of edges._@param vertexValueInitializer the mapper function that initializes the vertex values._It allows to apply a map transformation on the vertex ID to produce an initial vertex value._@param context the flink execution environment._@return the newly created graph.;public static <K, VV, EV> Graph<K, VV, EV> fromDataSet(DataSet<Edge<K, EV>> edges,_			final MapFunction<K, VV> vertexValueInitializer, ExecutionEnvironment context) {__		TypeInformation<K> keyType = ((TupleTypeInfo<?>) edges.getType()).getTypeAt(0)___		TypeInformation<VV> valueType = TypeExtractor.createTypeInfo(_				MapFunction.class, vertexValueInitializer.getClass(), 1, keyType, null)___		@SuppressWarnings({ "unchecked", "rawtypes" })_		TypeInformation<Vertex<K, VV>> returnType = (TypeInformation<Vertex<K, VV>>) new TupleTypeInfo(_				Vertex.class, keyType, valueType)___		DataSet<Vertex<K, VV>> vertices = edges_			.flatMap(new EmitSrcAndTargetAsTuple1<K, EV>())_				.name("Source and target IDs")_			.distinct()_				.name("IDs")_			.map(new MapFunction<Tuple1<K>, Vertex<K, VV>>() {_				private Vertex<K, VV> output = new Vertex<>()___				public Vertex<K, VV> map(Tuple1<K> value) throws Exception {_					output.f0 = value.f0__					output.f1 = vertexValueInitializer.map(value.f0)__					return output__				}_			}).returns(returnType).withForwardedFields("f0").name("Initialize vertex values")___		return new Graph<>(vertices, edges, context)__	};creates,a,graph,from,a,data,set,of,edges,vertices,are,created,automatically,and,their,values,are,set,by,applying,the,provided,map,function,to,the,vertex,ids,param,edges,a,data,set,of,edges,param,vertex,value,initializer,the,mapper,function,that,initializes,the,vertex,values,it,allows,to,apply,a,map,transformation,on,the,vertex,id,to,produce,an,initial,vertex,value,param,context,the,flink,execution,environment,return,the,newly,created,graph;public,static,k,vv,ev,graph,k,vv,ev,from,data,set,data,set,edge,k,ev,edges,final,map,function,k,vv,vertex,value,initializer,execution,environment,context,type,information,k,key,type,tuple,type,info,edges,get,type,get,type,at,0,type,information,vv,value,type,type,extractor,create,type,info,map,function,class,vertex,value,initializer,get,class,1,key,type,null,suppress,warnings,unchecked,rawtypes,type,information,vertex,k,vv,return,type,type,information,vertex,k,vv,new,tuple,type,info,vertex,class,key,type,value,type,data,set,vertex,k,vv,vertices,edges,flat,map,new,emit,src,and,target,as,tuple1,k,ev,name,source,and,target,ids,distinct,name,ids,map,new,map,function,tuple1,k,vertex,k,vv,private,vertex,k,vv,output,new,vertex,public,vertex,k,vv,map,tuple1,k,value,throws,exception,output,f0,value,f0,output,f1,vertex,value,initializer,map,value,f0,return,output,returns,return,type,with,forwarded,fields,f0,name,initialize,vertex,values,return,new,graph,vertices,edges,context
Graph -> public static <K, VV, EV> Graph<K, VV, EV> fromDataSet(DataSet<Edge<K, EV>> edges, 			final MapFunction<K, VV> vertexValueInitializer, ExecutionEnvironment context);1484160227;Creates a graph from a DataSet of edges._Vertices are created automatically and their values are set_by applying the provided map function to the vertex IDs.__@param edges a DataSet of edges._@param vertexValueInitializer the mapper function that initializes the vertex values._It allows to apply a map transformation on the vertex ID to produce an initial vertex value._@param context the flink execution environment._@return the newly created graph.;public static <K, VV, EV> Graph<K, VV, EV> fromDataSet(DataSet<Edge<K, EV>> edges,_			final MapFunction<K, VV> vertexValueInitializer, ExecutionEnvironment context) {__		TypeInformation<K> keyType = ((TupleTypeInfo<?>) edges.getType()).getTypeAt(0)___		TypeInformation<VV> valueType = TypeExtractor.createTypeInfo(_				MapFunction.class, vertexValueInitializer.getClass(), 1, keyType, null)___		@SuppressWarnings({ "unchecked", "rawtypes" })_		TypeInformation<Vertex<K, VV>> returnType = (TypeInformation<Vertex<K, VV>>) new TupleTypeInfo(_				Vertex.class, keyType, valueType)___		DataSet<Vertex<K, VV>> vertices = edges_			.flatMap(new EmitSrcAndTargetAsTuple1<K, EV>())_				.name("Source and target IDs")_			.distinct()_				.name("IDs")_			.map(new MapFunction<Tuple1<K>, Vertex<K, VV>>() {_				private Vertex<K, VV> output = new Vertex<>()___				public Vertex<K, VV> map(Tuple1<K> value) throws Exception {_					output.f0 = value.f0__					output.f1 = vertexValueInitializer.map(value.f0)__					return output__				}_			}).returns(returnType).withForwardedFields("f0").name("Initialize vertex values")___		return new Graph<>(vertices, edges, context)__	};creates,a,graph,from,a,data,set,of,edges,vertices,are,created,automatically,and,their,values,are,set,by,applying,the,provided,map,function,to,the,vertex,ids,param,edges,a,data,set,of,edges,param,vertex,value,initializer,the,mapper,function,that,initializes,the,vertex,values,it,allows,to,apply,a,map,transformation,on,the,vertex,id,to,produce,an,initial,vertex,value,param,context,the,flink,execution,environment,return,the,newly,created,graph;public,static,k,vv,ev,graph,k,vv,ev,from,data,set,data,set,edge,k,ev,edges,final,map,function,k,vv,vertex,value,initializer,execution,environment,context,type,information,k,key,type,tuple,type,info,edges,get,type,get,type,at,0,type,information,vv,value,type,type,extractor,create,type,info,map,function,class,vertex,value,initializer,get,class,1,key,type,null,suppress,warnings,unchecked,rawtypes,type,information,vertex,k,vv,return,type,type,information,vertex,k,vv,new,tuple,type,info,vertex,class,key,type,value,type,data,set,vertex,k,vv,vertices,edges,flat,map,new,emit,src,and,target,as,tuple1,k,ev,name,source,and,target,ids,distinct,name,ids,map,new,map,function,tuple1,k,vertex,k,vv,private,vertex,k,vv,output,new,vertex,public,vertex,k,vv,map,tuple1,k,value,throws,exception,output,f0,value,f0,output,f1,vertex,value,initializer,map,value,f0,return,output,returns,return,type,with,forwarded,fields,f0,name,initialize,vertex,values,return,new,graph,vertices,edges,context
Graph -> public static <K, VV, EV> Graph<K, VV, EV> fromDataSet(DataSet<Edge<K, EV>> edges, 			final MapFunction<K, VV> vertexValueInitializer, ExecutionEnvironment context);1484685504;Creates a graph from a DataSet of edges._Vertices are created automatically and their values are set_by applying the provided map function to the vertex IDs.__@param edges a DataSet of edges._@param vertexValueInitializer the mapper function that initializes the vertex values._It allows to apply a map transformation on the vertex ID to produce an initial vertex value._@param context the flink execution environment._@return the newly created graph.;public static <K, VV, EV> Graph<K, VV, EV> fromDataSet(DataSet<Edge<K, EV>> edges,_			final MapFunction<K, VV> vertexValueInitializer, ExecutionEnvironment context) {__		TypeInformation<K> keyType = ((TupleTypeInfo<?>) edges.getType()).getTypeAt(0)___		TypeInformation<VV> valueType = TypeExtractor.createTypeInfo(_				MapFunction.class, vertexValueInitializer.getClass(), 1, keyType, null)___		@SuppressWarnings({ "unchecked", "rawtypes" })_		TypeInformation<Vertex<K, VV>> returnType = (TypeInformation<Vertex<K, VV>>) new TupleTypeInfo(_				Vertex.class, keyType, valueType)___		DataSet<Vertex<K, VV>> vertices = edges_			.flatMap(new EmitSrcAndTargetAsTuple1<K, EV>())_				.name("Source and target IDs")_			.distinct()_				.name("IDs")_			.map(new MapFunction<Tuple1<K>, Vertex<K, VV>>() {_				private Vertex<K, VV> output = new Vertex<>()___				public Vertex<K, VV> map(Tuple1<K> value) throws Exception {_					output.f0 = value.f0__					output.f1 = vertexValueInitializer.map(value.f0)__					return output__				}_			}).returns(returnType).withForwardedFields("f0").name("Initialize vertex values")___		return new Graph<>(vertices, edges, context)__	};creates,a,graph,from,a,data,set,of,edges,vertices,are,created,automatically,and,their,values,are,set,by,applying,the,provided,map,function,to,the,vertex,ids,param,edges,a,data,set,of,edges,param,vertex,value,initializer,the,mapper,function,that,initializes,the,vertex,values,it,allows,to,apply,a,map,transformation,on,the,vertex,id,to,produce,an,initial,vertex,value,param,context,the,flink,execution,environment,return,the,newly,created,graph;public,static,k,vv,ev,graph,k,vv,ev,from,data,set,data,set,edge,k,ev,edges,final,map,function,k,vv,vertex,value,initializer,execution,environment,context,type,information,k,key,type,tuple,type,info,edges,get,type,get,type,at,0,type,information,vv,value,type,type,extractor,create,type,info,map,function,class,vertex,value,initializer,get,class,1,key,type,null,suppress,warnings,unchecked,rawtypes,type,information,vertex,k,vv,return,type,type,information,vertex,k,vv,new,tuple,type,info,vertex,class,key,type,value,type,data,set,vertex,k,vv,vertices,edges,flat,map,new,emit,src,and,target,as,tuple1,k,ev,name,source,and,target,ids,distinct,name,ids,map,new,map,function,tuple1,k,vertex,k,vv,private,vertex,k,vv,output,new,vertex,public,vertex,k,vv,map,tuple1,k,value,throws,exception,output,f0,value,f0,output,f1,vertex,value,initializer,map,value,f0,return,output,returns,return,type,with,forwarded,fields,f0,name,initialize,vertex,values,return,new,graph,vertices,edges,context
Graph -> public static <K, VV, EV> Graph<K, VV, EV> fromDataSet(DataSet<Edge<K, EV>> edges, 			final MapFunction<K, VV> vertexValueInitializer, ExecutionEnvironment context);1489068942;Creates a graph from a DataSet of edges._Vertices are created automatically and their values are set_by applying the provided map function to the vertex IDs.__@param edges a DataSet of edges._@param vertexValueInitializer the mapper function that initializes the vertex values._It allows to apply a map transformation on the vertex ID to produce an initial vertex value._@param context the flink execution environment._@return the newly created graph.;public static <K, VV, EV> Graph<K, VV, EV> fromDataSet(DataSet<Edge<K, EV>> edges,_			final MapFunction<K, VV> vertexValueInitializer, ExecutionEnvironment context) {__		TypeInformation<K> keyType = ((TupleTypeInfo<?>) edges.getType()).getTypeAt(0)___		TypeInformation<VV> valueType = TypeExtractor.createTypeInfo(_				MapFunction.class, vertexValueInitializer.getClass(), 1, keyType, null)___		@SuppressWarnings({ "unchecked", "rawtypes" })_		TypeInformation<Vertex<K, VV>> returnType = (TypeInformation<Vertex<K, VV>>) new TupleTypeInfo(_				Vertex.class, keyType, valueType)___		DataSet<Vertex<K, VV>> vertices = edges_			.flatMap(new EmitSrcAndTargetAsTuple1<K, EV>())_				.name("Source and target IDs")_			.distinct()_				.name("IDs")_			.map(new MapFunction<Tuple1<K>, Vertex<K, VV>>() {_				private Vertex<K, VV> output = new Vertex<>()___				public Vertex<K, VV> map(Tuple1<K> value) throws Exception {_					output.f0 = value.f0__					output.f1 = vertexValueInitializer.map(value.f0)__					return output__				}_			}).returns(returnType).withForwardedFields("f0").name("Initialize vertex values")___		return new Graph<>(vertices, edges, context)__	};creates,a,graph,from,a,data,set,of,edges,vertices,are,created,automatically,and,their,values,are,set,by,applying,the,provided,map,function,to,the,vertex,ids,param,edges,a,data,set,of,edges,param,vertex,value,initializer,the,mapper,function,that,initializes,the,vertex,values,it,allows,to,apply,a,map,transformation,on,the,vertex,id,to,produce,an,initial,vertex,value,param,context,the,flink,execution,environment,return,the,newly,created,graph;public,static,k,vv,ev,graph,k,vv,ev,from,data,set,data,set,edge,k,ev,edges,final,map,function,k,vv,vertex,value,initializer,execution,environment,context,type,information,k,key,type,tuple,type,info,edges,get,type,get,type,at,0,type,information,vv,value,type,type,extractor,create,type,info,map,function,class,vertex,value,initializer,get,class,1,key,type,null,suppress,warnings,unchecked,rawtypes,type,information,vertex,k,vv,return,type,type,information,vertex,k,vv,new,tuple,type,info,vertex,class,key,type,value,type,data,set,vertex,k,vv,vertices,edges,flat,map,new,emit,src,and,target,as,tuple1,k,ev,name,source,and,target,ids,distinct,name,ids,map,new,map,function,tuple1,k,vertex,k,vv,private,vertex,k,vv,output,new,vertex,public,vertex,k,vv,map,tuple1,k,value,throws,exception,output,f0,value,f0,output,f1,vertex,value,initializer,map,value,f0,return,output,returns,return,type,with,forwarded,fields,f0,name,initialize,vertex,values,return,new,graph,vertices,edges,context
Graph -> public static <K, VV, EV> Graph<K, VV, EV> fromDataSet(DataSet<Edge<K, EV>> edges, 			final MapFunction<K, VV> vertexValueInitializer, ExecutionEnvironment context);1490973446;Creates a graph from a DataSet of edges._Vertices are created automatically and their values are set_by applying the provided map function to the vertex IDs.__@param edges a DataSet of edges._@param vertexValueInitializer the mapper function that initializes the vertex values._It allows to apply a map transformation on the vertex ID to produce an initial vertex value._@param context the flink execution environment._@return the newly created graph.;public static <K, VV, EV> Graph<K, VV, EV> fromDataSet(DataSet<Edge<K, EV>> edges,_			final MapFunction<K, VV> vertexValueInitializer, ExecutionEnvironment context) {__		TypeInformation<K> keyType = ((TupleTypeInfo<?>) edges.getType()).getTypeAt(0)___		TypeInformation<VV> valueType = TypeExtractor.createTypeInfo(_				MapFunction.class, vertexValueInitializer.getClass(), 1, keyType, null)___		@SuppressWarnings({ "unchecked", "rawtypes" })_		TypeInformation<Vertex<K, VV>> returnType = (TypeInformation<Vertex<K, VV>>) new TupleTypeInfo(_				Vertex.class, keyType, valueType)___		DataSet<Vertex<K, VV>> vertices = edges_			.flatMap(new EmitSrcAndTargetAsTuple1<K, EV>())_				.name("Source and target IDs")_			.distinct()_				.name("IDs")_			.map(new MapFunction<Tuple1<K>, Vertex<K, VV>>() {_				private Vertex<K, VV> output = new Vertex<>()___				public Vertex<K, VV> map(Tuple1<K> value) throws Exception {_					output.f0 = value.f0__					output.f1 = vertexValueInitializer.map(value.f0)__					return output__				}_			}).returns(returnType).withForwardedFields("f0").name("Initialize vertex values")___		return new Graph<>(vertices, edges, context)__	};creates,a,graph,from,a,data,set,of,edges,vertices,are,created,automatically,and,their,values,are,set,by,applying,the,provided,map,function,to,the,vertex,ids,param,edges,a,data,set,of,edges,param,vertex,value,initializer,the,mapper,function,that,initializes,the,vertex,values,it,allows,to,apply,a,map,transformation,on,the,vertex,id,to,produce,an,initial,vertex,value,param,context,the,flink,execution,environment,return,the,newly,created,graph;public,static,k,vv,ev,graph,k,vv,ev,from,data,set,data,set,edge,k,ev,edges,final,map,function,k,vv,vertex,value,initializer,execution,environment,context,type,information,k,key,type,tuple,type,info,edges,get,type,get,type,at,0,type,information,vv,value,type,type,extractor,create,type,info,map,function,class,vertex,value,initializer,get,class,1,key,type,null,suppress,warnings,unchecked,rawtypes,type,information,vertex,k,vv,return,type,type,information,vertex,k,vv,new,tuple,type,info,vertex,class,key,type,value,type,data,set,vertex,k,vv,vertices,edges,flat,map,new,emit,src,and,target,as,tuple1,k,ev,name,source,and,target,ids,distinct,name,ids,map,new,map,function,tuple1,k,vertex,k,vv,private,vertex,k,vv,output,new,vertex,public,vertex,k,vv,map,tuple1,k,value,throws,exception,output,f0,value,f0,output,f1,vertex,value,initializer,map,value,f0,return,output,returns,return,type,with,forwarded,fields,f0,name,initialize,vertex,values,return,new,graph,vertices,edges,context
Graph -> public static <K, VV, EV> Graph<K, VV, EV> fromDataSet(DataSet<Edge<K, EV>> edges, 			final MapFunction<K, VV> vertexValueInitializer, ExecutionEnvironment context);1495819075;Creates a graph from a DataSet of edges._Vertices are created automatically and their values are set_by applying the provided map function to the vertex IDs.__@param edges a DataSet of edges._@param vertexValueInitializer the mapper function that initializes the vertex values._It allows to apply a map transformation on the vertex ID to produce an initial vertex value._@param context the flink execution environment._@return the newly created graph.;public static <K, VV, EV> Graph<K, VV, EV> fromDataSet(DataSet<Edge<K, EV>> edges,_			final MapFunction<K, VV> vertexValueInitializer, ExecutionEnvironment context) {__		TypeInformation<K> keyType = ((TupleTypeInfo<?>) edges.getType()).getTypeAt(0)___		TypeInformation<VV> valueType = TypeExtractor.createTypeInfo(_				MapFunction.class, vertexValueInitializer.getClass(), 1, keyType, null)___		@SuppressWarnings({ "unchecked", "rawtypes" })_		TypeInformation<Vertex<K, VV>> returnType = (TypeInformation<Vertex<K, VV>>) new TupleTypeInfo(_				Vertex.class, keyType, valueType)___		DataSet<Vertex<K, VV>> vertices = edges_			.flatMap(new EmitSrcAndTargetAsTuple1<K, EV>())_				.name("Source and target IDs")_			.distinct()_				.name("IDs")_			.map(new MapFunction<Tuple1<K>, Vertex<K, VV>>() {_				private Vertex<K, VV> output = new Vertex<>()___				public Vertex<K, VV> map(Tuple1<K> value) throws Exception {_					output.f0 = value.f0__					output.f1 = vertexValueInitializer.map(value.f0)__					return output__				}_			}).returns(returnType).withForwardedFields("f0").name("Initialize vertex values")___		return new Graph<>(vertices, edges, context)__	};creates,a,graph,from,a,data,set,of,edges,vertices,are,created,automatically,and,their,values,are,set,by,applying,the,provided,map,function,to,the,vertex,ids,param,edges,a,data,set,of,edges,param,vertex,value,initializer,the,mapper,function,that,initializes,the,vertex,values,it,allows,to,apply,a,map,transformation,on,the,vertex,id,to,produce,an,initial,vertex,value,param,context,the,flink,execution,environment,return,the,newly,created,graph;public,static,k,vv,ev,graph,k,vv,ev,from,data,set,data,set,edge,k,ev,edges,final,map,function,k,vv,vertex,value,initializer,execution,environment,context,type,information,k,key,type,tuple,type,info,edges,get,type,get,type,at,0,type,information,vv,value,type,type,extractor,create,type,info,map,function,class,vertex,value,initializer,get,class,1,key,type,null,suppress,warnings,unchecked,rawtypes,type,information,vertex,k,vv,return,type,type,information,vertex,k,vv,new,tuple,type,info,vertex,class,key,type,value,type,data,set,vertex,k,vv,vertices,edges,flat,map,new,emit,src,and,target,as,tuple1,k,ev,name,source,and,target,ids,distinct,name,ids,map,new,map,function,tuple1,k,vertex,k,vv,private,vertex,k,vv,output,new,vertex,public,vertex,k,vv,map,tuple1,k,value,throws,exception,output,f0,value,f0,output,f1,vertex,value,initializer,map,value,f0,return,output,returns,return,type,with,forwarded,fields,f0,name,initialize,vertex,values,return,new,graph,vertices,edges,context
Graph -> public static <K, VV, EV> Graph<K, VV, EV> fromDataSet(DataSet<Edge<K, EV>> edges, 			final MapFunction<K, VV> vertexValueInitializer, ExecutionEnvironment context);1502111816;Creates a graph from a DataSet of edges._Vertices are created automatically and their values are set_by applying the provided map function to the vertex IDs.__@param edges a DataSet of edges._@param vertexValueInitializer the mapper function that initializes the vertex values._It allows to apply a map transformation on the vertex ID to produce an initial vertex value._@param context the flink execution environment._@return the newly created graph.;public static <K, VV, EV> Graph<K, VV, EV> fromDataSet(DataSet<Edge<K, EV>> edges,_			final MapFunction<K, VV> vertexValueInitializer, ExecutionEnvironment context) {__		TypeInformation<K> keyType = ((TupleTypeInfo<?>) edges.getType()).getTypeAt(0)___		TypeInformation<VV> valueType = TypeExtractor.createTypeInfo(_				MapFunction.class, vertexValueInitializer.getClass(), 1, keyType, null)___		@SuppressWarnings({ "unchecked", "rawtypes" })_		TypeInformation<Vertex<K, VV>> returnType = (TypeInformation<Vertex<K, VV>>) new TupleTypeInfo(_				Vertex.class, keyType, valueType)___		DataSet<Vertex<K, VV>> vertices = edges_			.flatMap(new EmitSrcAndTargetAsTuple1<>())_				.name("Source and target IDs")_			.distinct()_				.name("IDs")_			.map(new MapFunction<Tuple1<K>, Vertex<K, VV>>() {_				private Vertex<K, VV> output = new Vertex<>()___				public Vertex<K, VV> map(Tuple1<K> value) throws Exception {_					output.f0 = value.f0__					output.f1 = vertexValueInitializer.map(value.f0)__					return output__				}_			}).returns(returnType).withForwardedFields("f0").name("Initialize vertex values")___		return new Graph<>(vertices, edges, context)__	};creates,a,graph,from,a,data,set,of,edges,vertices,are,created,automatically,and,their,values,are,set,by,applying,the,provided,map,function,to,the,vertex,ids,param,edges,a,data,set,of,edges,param,vertex,value,initializer,the,mapper,function,that,initializes,the,vertex,values,it,allows,to,apply,a,map,transformation,on,the,vertex,id,to,produce,an,initial,vertex,value,param,context,the,flink,execution,environment,return,the,newly,created,graph;public,static,k,vv,ev,graph,k,vv,ev,from,data,set,data,set,edge,k,ev,edges,final,map,function,k,vv,vertex,value,initializer,execution,environment,context,type,information,k,key,type,tuple,type,info,edges,get,type,get,type,at,0,type,information,vv,value,type,type,extractor,create,type,info,map,function,class,vertex,value,initializer,get,class,1,key,type,null,suppress,warnings,unchecked,rawtypes,type,information,vertex,k,vv,return,type,type,information,vertex,k,vv,new,tuple,type,info,vertex,class,key,type,value,type,data,set,vertex,k,vv,vertices,edges,flat,map,new,emit,src,and,target,as,tuple1,name,source,and,target,ids,distinct,name,ids,map,new,map,function,tuple1,k,vertex,k,vv,private,vertex,k,vv,output,new,vertex,public,vertex,k,vv,map,tuple1,k,value,throws,exception,output,f0,value,f0,output,f1,vertex,value,initializer,map,value,f0,return,output,returns,return,type,with,forwarded,fields,f0,name,initialize,vertex,values,return,new,graph,vertices,edges,context
Graph -> public DataSet<Tuple2<K, Long>> outDegrees();1444404795;Return the out-degree of all vertices in the graph__@return A DataSet of Tuple2<vertexId, outDegree>;public DataSet<Tuple2<K, Long>> outDegrees() {__		return vertices.coGroup(edges).where(0).equalTo(0).with(new CountNeighborsCoGroup<K, VV, EV>())__	};return,the,out,degree,of,all,vertices,in,the,graph,return,a,data,set,of,tuple2,vertex,id,out,degree;public,data,set,tuple2,k,long,out,degrees,return,vertices,co,group,edges,where,0,equal,to,0,with,new,count,neighbors,co,group,k,vv,ev
Graph -> public DataSet<Tuple2<K, Long>> outDegrees();1445261977;Return the out-degree of all vertices in the graph__@return A DataSet of Tuple2<vertexId, outDegree>;public DataSet<Tuple2<K, Long>> outDegrees() {__		return vertices.coGroup(edges).where(0).equalTo(0).with(new CountNeighborsCoGroup<K, VV, EV>())__	};return,the,out,degree,of,all,vertices,in,the,graph,return,a,data,set,of,tuple2,vertex,id,out,degree;public,data,set,tuple2,k,long,out,degrees,return,vertices,co,group,edges,where,0,equal,to,0,with,new,count,neighbors,co,group,k,vv,ev
Graph -> public DataSet<Tuple2<K, Long>> outDegrees();1445854323;Return the out-degree of all vertices in the graph__@return A DataSet of Tuple2<vertexId, outDegree>;public DataSet<Tuple2<K, Long>> outDegrees() {__		return vertices.coGroup(edges).where(0).equalTo(0).with(new CountNeighborsCoGroup<K, VV, EV>())__	};return,the,out,degree,of,all,vertices,in,the,graph,return,a,data,set,of,tuple2,vertex,id,out,degree;public,data,set,tuple2,k,long,out,degrees,return,vertices,co,group,edges,where,0,equal,to,0,with,new,count,neighbors,co,group,k,vv,ev
Graph -> public DataSet<Tuple2<K, Long>> outDegrees();1446112342;Return the out-degree of all vertices in the graph__@return A DataSet of {@code Tuple2<vertexId, outDegree>};public DataSet<Tuple2<K, Long>> outDegrees() {__		return vertices.coGroup(edges).where(0).equalTo(0).with(new CountNeighborsCoGroup<K, VV, EV>())__	};return,the,out,degree,of,all,vertices,in,the,graph,return,a,data,set,of,code,tuple2,vertex,id,out,degree;public,data,set,tuple2,k,long,out,degrees,return,vertices,co,group,edges,where,0,equal,to,0,with,new,count,neighbors,co,group,k,vv,ev
Graph -> public DataSet<Tuple2<K, Long>> outDegrees();1447073368;Return the out-degree of all vertices in the graph__@return A DataSet of {@code Tuple2<vertexId, outDegree>};public DataSet<Tuple2<K, Long>> outDegrees() {__		return vertices.coGroup(edges).where(0).equalTo(0).with(new CountNeighborsCoGroup<K, VV, EV>())__	};return,the,out,degree,of,all,vertices,in,the,graph,return,a,data,set,of,code,tuple2,vertex,id,out,degree;public,data,set,tuple2,k,long,out,degrees,return,vertices,co,group,edges,where,0,equal,to,0,with,new,count,neighbors,co,group,k,vv,ev
Graph -> public DataSet<Tuple2<K, Long>> outDegrees();1454404649;Return the out-degree of all vertices in the graph__@return A DataSet of {@code Tuple2<vertexId, outDegree>};public DataSet<Tuple2<K, Long>> outDegrees() {__		return vertices.coGroup(edges).where(0).equalTo(0).with(new CountNeighborsCoGroup<K, VV, EV>())__	};return,the,out,degree,of,all,vertices,in,the,graph,return,a,data,set,of,code,tuple2,vertex,id,out,degree;public,data,set,tuple2,k,long,out,degrees,return,vertices,co,group,edges,where,0,equal,to,0,with,new,count,neighbors,co,group,k,vv,ev
Graph -> public DataSet<Tuple2<K, Long>> outDegrees();1458583829;Return the out-degree of all vertices in the graph__@return A DataSet of {@code Tuple2<vertexId, outDegree>};public DataSet<Tuple2<K, Long>> outDegrees() {__		return vertices.coGroup(edges).where(0).equalTo(0).with(new CountNeighborsCoGroup<K, VV, EV>())__	};return,the,out,degree,of,all,vertices,in,the,graph,return,a,data,set,of,code,tuple2,vertex,id,out,degree;public,data,set,tuple2,k,long,out,degrees,return,vertices,co,group,edges,where,0,equal,to,0,with,new,count,neighbors,co,group,k,vv,ev
Graph -> public DataSet<Tuple2<K, Long>> outDegrees();1458583829;Return the out-degree of all vertices in the graph__@return A DataSet of {@code Tuple2<vertexId, outDegree>};public DataSet<Tuple2<K, Long>> outDegrees() {__		return vertices.coGroup(edges).where(0).equalTo(0).with(new CountNeighborsCoGroup<K, VV, EV>())__	};return,the,out,degree,of,all,vertices,in,the,graph,return,a,data,set,of,code,tuple2,vertex,id,out,degree;public,data,set,tuple2,k,long,out,degrees,return,vertices,co,group,edges,where,0,equal,to,0,with,new,count,neighbors,co,group,k,vv,ev
Graph -> public DataSet<Tuple2<K, Long>> outDegrees();1462100316;Return the out-degree of all vertices in the graph__@return A DataSet of {@code Tuple2<vertexId, outDegree>};public DataSet<Tuple2<K, Long>> outDegrees() {__		return vertices.coGroup(edges).where(0).equalTo(0).with(new CountNeighborsCoGroup<K, VV, EV>())__	};return,the,out,degree,of,all,vertices,in,the,graph,return,a,data,set,of,code,tuple2,vertex,id,out,degree;public,data,set,tuple2,k,long,out,degrees,return,vertices,co,group,edges,where,0,equal,to,0,with,new,count,neighbors,co,group,k,vv,ev
Graph -> public DataSet<Tuple2<K, Long>> outDegrees();1462100316;Return the out-degree of all vertices in the graph__@return A DataSet of {@code Tuple2<vertexId, outDegree>};public DataSet<Tuple2<K, Long>> outDegrees() {__		return vertices.coGroup(edges).where(0).equalTo(0).with(new CountNeighborsCoGroup<K, VV, EV>())__	};return,the,out,degree,of,all,vertices,in,the,graph,return,a,data,set,of,code,tuple2,vertex,id,out,degree;public,data,set,tuple2,k,long,out,degrees,return,vertices,co,group,edges,where,0,equal,to,0,with,new,count,neighbors,co,group,k,vv,ev
Graph -> public DataSet<Tuple2<K, Long>> outDegrees();1462205213;Return the out-degree of all vertices in the graph__@return A DataSet of {@code Tuple2<vertexId, outDegree>};public DataSet<Tuple2<K, Long>> outDegrees() {__		return vertices.coGroup(edges).where(0).equalTo(0).with(new CountNeighborsCoGroup<K, VV, EV>())__	};return,the,out,degree,of,all,vertices,in,the,graph,return,a,data,set,of,code,tuple2,vertex,id,out,degree;public,data,set,tuple2,k,long,out,degrees,return,vertices,co,group,edges,where,0,equal,to,0,with,new,count,neighbors,co,group,k,vv,ev
Graph -> public DataSet<Tuple2<K, Long>> outDegrees();1462208859;Return the out-degree of all vertices in the graph__@return A DataSet of {@code Tuple2<vertexId, outDegree>};public DataSet<Tuple2<K, Long>> outDegrees() {__		return vertices.coGroup(edges).where(0).equalTo(0).with(new CountNeighborsCoGroup<K, VV, EV>())__	};return,the,out,degree,of,all,vertices,in,the,graph,return,a,data,set,of,code,tuple2,vertex,id,out,degree;public,data,set,tuple2,k,long,out,degrees,return,vertices,co,group,edges,where,0,equal,to,0,with,new,count,neighbors,co,group,k,vv,ev
Graph -> public DataSet<Tuple2<K, Long>> outDegrees();1462809297;Return the out-degree of all vertices in the graph__@return A DataSet of {@code Tuple2<vertexId, outDegree>};public DataSet<Tuple2<K, Long>> outDegrees() {__		return vertices.coGroup(edges).where(0).equalTo(0).with(new CountNeighborsCoGroup<K, VV, EV>())__	};return,the,out,degree,of,all,vertices,in,the,graph,return,a,data,set,of,code,tuple2,vertex,id,out,degree;public,data,set,tuple2,k,long,out,degrees,return,vertices,co,group,edges,where,0,equal,to,0,with,new,count,neighbors,co,group,k,vv,ev
Graph -> public DataSet<Tuple2<K, Long>> outDegrees();1465316775;Return the out-degree of all vertices in the graph__@return A DataSet of {@code Tuple2<vertexId, outDegree>};public DataSet<Tuple2<K, Long>> outDegrees() {__		return vertices.coGroup(edges).where(0).equalTo(0).with(new CountNeighborsCoGroup<K, VV, EV>())__	};return,the,out,degree,of,all,vertices,in,the,graph,return,a,data,set,of,code,tuple2,vertex,id,out,degree;public,data,set,tuple2,k,long,out,degrees,return,vertices,co,group,edges,where,0,equal,to,0,with,new,count,neighbors,co,group,k,vv,ev
Graph -> public DataSet<Tuple2<K, Long>> outDegrees();1466789678;Return the out-degree of all vertices in the graph__@return A DataSet of {@code Tuple2<vertexId, outDegree>};public DataSet<Tuple2<K, Long>> outDegrees() {__		return vertices.coGroup(edges).where(0).equalTo(0).with(new CountNeighborsCoGroup<K, VV, EV>())__	};return,the,out,degree,of,all,vertices,in,the,graph,return,a,data,set,of,code,tuple2,vertex,id,out,degree;public,data,set,tuple2,k,long,out,degrees,return,vertices,co,group,edges,where,0,equal,to,0,with,new,count,neighbors,co,group,k,vv,ev
Graph -> public static <K, EV> Graph<K, NullValue, EV> fromDataSet( 			DataSet<Edge<K, EV>> edges, ExecutionEnvironment context);1444404795;Creates a graph from a DataSet of edges, vertices are induced from the_edges. Vertices are created automatically and their values are set to_NullValue.__@param edges a DataSet of edges._@param context the flink execution environment._@return the newly created graph.;public static <K, EV> Graph<K, NullValue, EV> fromDataSet(_			DataSet<Edge<K, EV>> edges, ExecutionEnvironment context) {__		DataSet<Vertex<K, NullValue>> vertices = edges.flatMap(new EmitSrcAndTarget<K, EV>()).distinct()___		return new Graph<K, NullValue, EV>(vertices, edges, context)__	};creates,a,graph,from,a,data,set,of,edges,vertices,are,induced,from,the,edges,vertices,are,created,automatically,and,their,values,are,set,to,null,value,param,edges,a,data,set,of,edges,param,context,the,flink,execution,environment,return,the,newly,created,graph;public,static,k,ev,graph,k,null,value,ev,from,data,set,data,set,edge,k,ev,edges,execution,environment,context,data,set,vertex,k,null,value,vertices,edges,flat,map,new,emit,src,and,target,k,ev,distinct,return,new,graph,k,null,value,ev,vertices,edges,context
Graph -> public static <K, EV> Graph<K, NullValue, EV> fromDataSet( 			DataSet<Edge<K, EV>> edges, ExecutionEnvironment context);1445261977;Creates a graph from a DataSet of edges._Vertices are created automatically and their values are set to_NullValue.__@param edges a DataSet of edges._@param context the flink execution environment._@return the newly created graph.;public static <K, EV> Graph<K, NullValue, EV> fromDataSet(_			DataSet<Edge<K, EV>> edges, ExecutionEnvironment context) {__		DataSet<Vertex<K, NullValue>> vertices = edges.flatMap(new EmitSrcAndTarget<K, EV>()).distinct()___		return new Graph<K, NullValue, EV>(vertices, edges, context)__	};creates,a,graph,from,a,data,set,of,edges,vertices,are,created,automatically,and,their,values,are,set,to,null,value,param,edges,a,data,set,of,edges,param,context,the,flink,execution,environment,return,the,newly,created,graph;public,static,k,ev,graph,k,null,value,ev,from,data,set,data,set,edge,k,ev,edges,execution,environment,context,data,set,vertex,k,null,value,vertices,edges,flat,map,new,emit,src,and,target,k,ev,distinct,return,new,graph,k,null,value,ev,vertices,edges,context
Graph -> public static <K, EV> Graph<K, NullValue, EV> fromDataSet( 			DataSet<Edge<K, EV>> edges, ExecutionEnvironment context);1445854323;Creates a graph from a DataSet of edges._Vertices are created automatically and their values are set to_NullValue.__@param edges a DataSet of edges._@param context the flink execution environment._@return the newly created graph.;public static <K, EV> Graph<K, NullValue, EV> fromDataSet(_			DataSet<Edge<K, EV>> edges, ExecutionEnvironment context) {__		DataSet<Vertex<K, NullValue>> vertices = edges.flatMap(new EmitSrcAndTarget<K, EV>()).distinct()___		return new Graph<K, NullValue, EV>(vertices, edges, context)__	};creates,a,graph,from,a,data,set,of,edges,vertices,are,created,automatically,and,their,values,are,set,to,null,value,param,edges,a,data,set,of,edges,param,context,the,flink,execution,environment,return,the,newly,created,graph;public,static,k,ev,graph,k,null,value,ev,from,data,set,data,set,edge,k,ev,edges,execution,environment,context,data,set,vertex,k,null,value,vertices,edges,flat,map,new,emit,src,and,target,k,ev,distinct,return,new,graph,k,null,value,ev,vertices,edges,context
Graph -> public static <K, EV> Graph<K, NullValue, EV> fromDataSet( 			DataSet<Edge<K, EV>> edges, ExecutionEnvironment context);1446112342;Creates a graph from a DataSet of edges._Vertices are created automatically and their values are set to_NullValue.__@param edges a DataSet of edges._@param context the flink execution environment._@return the newly created graph.;public static <K, EV> Graph<K, NullValue, EV> fromDataSet(_			DataSet<Edge<K, EV>> edges, ExecutionEnvironment context) {__		DataSet<Vertex<K, NullValue>> vertices = edges.flatMap(new EmitSrcAndTarget<K, EV>()).distinct()___		return new Graph<K, NullValue, EV>(vertices, edges, context)__	};creates,a,graph,from,a,data,set,of,edges,vertices,are,created,automatically,and,their,values,are,set,to,null,value,param,edges,a,data,set,of,edges,param,context,the,flink,execution,environment,return,the,newly,created,graph;public,static,k,ev,graph,k,null,value,ev,from,data,set,data,set,edge,k,ev,edges,execution,environment,context,data,set,vertex,k,null,value,vertices,edges,flat,map,new,emit,src,and,target,k,ev,distinct,return,new,graph,k,null,value,ev,vertices,edges,context
Graph -> public static <K, EV> Graph<K, NullValue, EV> fromDataSet( 			DataSet<Edge<K, EV>> edges, ExecutionEnvironment context);1447073368;Creates a graph from a DataSet of edges._Vertices are created automatically and their values are set to_NullValue.__@param edges a DataSet of edges._@param context the flink execution environment._@return the newly created graph.;public static <K, EV> Graph<K, NullValue, EV> fromDataSet(_			DataSet<Edge<K, EV>> edges, ExecutionEnvironment context) {__		DataSet<Vertex<K, NullValue>> vertices = edges.flatMap(new EmitSrcAndTarget<K, EV>()).distinct()___		return new Graph<K, NullValue, EV>(vertices, edges, context)__	};creates,a,graph,from,a,data,set,of,edges,vertices,are,created,automatically,and,their,values,are,set,to,null,value,param,edges,a,data,set,of,edges,param,context,the,flink,execution,environment,return,the,newly,created,graph;public,static,k,ev,graph,k,null,value,ev,from,data,set,data,set,edge,k,ev,edges,execution,environment,context,data,set,vertex,k,null,value,vertices,edges,flat,map,new,emit,src,and,target,k,ev,distinct,return,new,graph,k,null,value,ev,vertices,edges,context
Graph -> public static <K, EV> Graph<K, NullValue, EV> fromDataSet( 			DataSet<Edge<K, EV>> edges, ExecutionEnvironment context);1454404649;Creates a graph from a DataSet of edges._Vertices are created automatically and their values are set to_NullValue.__@param edges a DataSet of edges._@param context the flink execution environment._@return the newly created graph.;public static <K, EV> Graph<K, NullValue, EV> fromDataSet(_			DataSet<Edge<K, EV>> edges, ExecutionEnvironment context) {__		DataSet<Vertex<K, NullValue>> vertices = edges.flatMap(new EmitSrcAndTarget<K, EV>()).distinct()___		return new Graph<K, NullValue, EV>(vertices, edges, context)__	};creates,a,graph,from,a,data,set,of,edges,vertices,are,created,automatically,and,their,values,are,set,to,null,value,param,edges,a,data,set,of,edges,param,context,the,flink,execution,environment,return,the,newly,created,graph;public,static,k,ev,graph,k,null,value,ev,from,data,set,data,set,edge,k,ev,edges,execution,environment,context,data,set,vertex,k,null,value,vertices,edges,flat,map,new,emit,src,and,target,k,ev,distinct,return,new,graph,k,null,value,ev,vertices,edges,context
Graph -> public static <K, EV> Graph<K, NullValue, EV> fromDataSet( 			DataSet<Edge<K, EV>> edges, ExecutionEnvironment context);1458583829;Creates a graph from a DataSet of edges._Vertices are created automatically and their values are set to_NullValue.__@param edges a DataSet of edges._@param context the flink execution environment._@return the newly created graph.;public static <K, EV> Graph<K, NullValue, EV> fromDataSet(_			DataSet<Edge<K, EV>> edges, ExecutionEnvironment context) {__		DataSet<Vertex<K, NullValue>> vertices = edges.flatMap(new EmitSrcAndTarget<K, EV>()).distinct()___		return new Graph<K, NullValue, EV>(vertices, edges, context)__	};creates,a,graph,from,a,data,set,of,edges,vertices,are,created,automatically,and,their,values,are,set,to,null,value,param,edges,a,data,set,of,edges,param,context,the,flink,execution,environment,return,the,newly,created,graph;public,static,k,ev,graph,k,null,value,ev,from,data,set,data,set,edge,k,ev,edges,execution,environment,context,data,set,vertex,k,null,value,vertices,edges,flat,map,new,emit,src,and,target,k,ev,distinct,return,new,graph,k,null,value,ev,vertices,edges,context
Graph -> public static <K, EV> Graph<K, NullValue, EV> fromDataSet( 			DataSet<Edge<K, EV>> edges, ExecutionEnvironment context);1458583829;Creates a graph from a DataSet of edges._Vertices are created automatically and their values are set to_NullValue.__@param edges a DataSet of edges._@param context the flink execution environment._@return the newly created graph.;public static <K, EV> Graph<K, NullValue, EV> fromDataSet(_			DataSet<Edge<K, EV>> edges, ExecutionEnvironment context) {__		DataSet<Vertex<K, NullValue>> vertices = edges.flatMap(new EmitSrcAndTarget<K, EV>()).distinct()___		return new Graph<K, NullValue, EV>(vertices, edges, context)__	};creates,a,graph,from,a,data,set,of,edges,vertices,are,created,automatically,and,their,values,are,set,to,null,value,param,edges,a,data,set,of,edges,param,context,the,flink,execution,environment,return,the,newly,created,graph;public,static,k,ev,graph,k,null,value,ev,from,data,set,data,set,edge,k,ev,edges,execution,environment,context,data,set,vertex,k,null,value,vertices,edges,flat,map,new,emit,src,and,target,k,ev,distinct,return,new,graph,k,null,value,ev,vertices,edges,context
Graph -> public static <K, EV> Graph<K, NullValue, EV> fromDataSet( 			DataSet<Edge<K, EV>> edges, ExecutionEnvironment context);1462100316;Creates a graph from a DataSet of edges._Vertices are created automatically and their values are set to_NullValue.__@param edges a DataSet of edges._@param context the flink execution environment._@return the newly created graph.;public static <K, EV> Graph<K, NullValue, EV> fromDataSet(_			DataSet<Edge<K, EV>> edges, ExecutionEnvironment context) {__		DataSet<Vertex<K, NullValue>> vertices = edges.flatMap(new EmitSrcAndTarget<K, EV>()).distinct()___		return new Graph<K, NullValue, EV>(vertices, edges, context)__	};creates,a,graph,from,a,data,set,of,edges,vertices,are,created,automatically,and,their,values,are,set,to,null,value,param,edges,a,data,set,of,edges,param,context,the,flink,execution,environment,return,the,newly,created,graph;public,static,k,ev,graph,k,null,value,ev,from,data,set,data,set,edge,k,ev,edges,execution,environment,context,data,set,vertex,k,null,value,vertices,edges,flat,map,new,emit,src,and,target,k,ev,distinct,return,new,graph,k,null,value,ev,vertices,edges,context
Graph -> public static <K, EV> Graph<K, NullValue, EV> fromDataSet( 			DataSet<Edge<K, EV>> edges, ExecutionEnvironment context);1462100316;Creates a graph from a DataSet of edges._Vertices are created automatically and their values are set to_NullValue.__@param edges a DataSet of edges._@param context the flink execution environment._@return the newly created graph.;public static <K, EV> Graph<K, NullValue, EV> fromDataSet(_			DataSet<Edge<K, EV>> edges, ExecutionEnvironment context) {__		DataSet<Vertex<K, NullValue>> vertices = edges.flatMap(new EmitSrcAndTarget<K, EV>()).distinct()___		return new Graph<K, NullValue, EV>(vertices, edges, context)__	};creates,a,graph,from,a,data,set,of,edges,vertices,are,created,automatically,and,their,values,are,set,to,null,value,param,edges,a,data,set,of,edges,param,context,the,flink,execution,environment,return,the,newly,created,graph;public,static,k,ev,graph,k,null,value,ev,from,data,set,data,set,edge,k,ev,edges,execution,environment,context,data,set,vertex,k,null,value,vertices,edges,flat,map,new,emit,src,and,target,k,ev,distinct,return,new,graph,k,null,value,ev,vertices,edges,context
Graph -> public static <K, EV> Graph<K, NullValue, EV> fromDataSet( 			DataSet<Edge<K, EV>> edges, ExecutionEnvironment context);1462205213;Creates a graph from a DataSet of edges._Vertices are created automatically and their values are set to_NullValue.__@param edges a DataSet of edges._@param context the flink execution environment._@return the newly created graph.;public static <K, EV> Graph<K, NullValue, EV> fromDataSet(_			DataSet<Edge<K, EV>> edges, ExecutionEnvironment context) {__		DataSet<Vertex<K, NullValue>> vertices = edges.flatMap(new EmitSrcAndTarget<K, EV>()).distinct()___		return new Graph<K, NullValue, EV>(vertices, edges, context)__	};creates,a,graph,from,a,data,set,of,edges,vertices,are,created,automatically,and,their,values,are,set,to,null,value,param,edges,a,data,set,of,edges,param,context,the,flink,execution,environment,return,the,newly,created,graph;public,static,k,ev,graph,k,null,value,ev,from,data,set,data,set,edge,k,ev,edges,execution,environment,context,data,set,vertex,k,null,value,vertices,edges,flat,map,new,emit,src,and,target,k,ev,distinct,return,new,graph,k,null,value,ev,vertices,edges,context
Graph -> public static <K, EV> Graph<K, NullValue, EV> fromDataSet( 			DataSet<Edge<K, EV>> edges, ExecutionEnvironment context);1462208859;Creates a graph from a DataSet of edges._Vertices are created automatically and their values are set to_NullValue.__@param edges a DataSet of edges._@param context the flink execution environment._@return the newly created graph.;public static <K, EV> Graph<K, NullValue, EV> fromDataSet(_			DataSet<Edge<K, EV>> edges, ExecutionEnvironment context) {__		DataSet<Vertex<K, NullValue>> vertices = edges.flatMap(new EmitSrcAndTarget<K, EV>()).distinct()___		return new Graph<K, NullValue, EV>(vertices, edges, context)__	};creates,a,graph,from,a,data,set,of,edges,vertices,are,created,automatically,and,their,values,are,set,to,null,value,param,edges,a,data,set,of,edges,param,context,the,flink,execution,environment,return,the,newly,created,graph;public,static,k,ev,graph,k,null,value,ev,from,data,set,data,set,edge,k,ev,edges,execution,environment,context,data,set,vertex,k,null,value,vertices,edges,flat,map,new,emit,src,and,target,k,ev,distinct,return,new,graph,k,null,value,ev,vertices,edges,context
Graph -> public static <K, EV> Graph<K, NullValue, EV> fromDataSet( 			DataSet<Edge<K, EV>> edges, ExecutionEnvironment context);1462809297;Creates a graph from a DataSet of edges._Vertices are created automatically and their values are set to_NullValue.__@param edges a DataSet of edges._@param context the flink execution environment._@return the newly created graph.;public static <K, EV> Graph<K, NullValue, EV> fromDataSet(_			DataSet<Edge<K, EV>> edges, ExecutionEnvironment context) {__		DataSet<Vertex<K, NullValue>> vertices = edges.flatMap(new EmitSrcAndTarget<K, EV>()).distinct()___		return new Graph<K, NullValue, EV>(vertices, edges, context)__	};creates,a,graph,from,a,data,set,of,edges,vertices,are,created,automatically,and,their,values,are,set,to,null,value,param,edges,a,data,set,of,edges,param,context,the,flink,execution,environment,return,the,newly,created,graph;public,static,k,ev,graph,k,null,value,ev,from,data,set,data,set,edge,k,ev,edges,execution,environment,context,data,set,vertex,k,null,value,vertices,edges,flat,map,new,emit,src,and,target,k,ev,distinct,return,new,graph,k,null,value,ev,vertices,edges,context
Graph -> public static <K, EV> Graph<K, NullValue, EV> fromDataSet( 			DataSet<Edge<K, EV>> edges, ExecutionEnvironment context);1465316775;Creates a graph from a DataSet of edges._Vertices are created automatically and their values are set to_NullValue.__@param edges a DataSet of edges._@param context the flink execution environment._@return the newly created graph.;public static <K, EV> Graph<K, NullValue, EV> fromDataSet(_			DataSet<Edge<K, EV>> edges, ExecutionEnvironment context) {__		DataSet<Vertex<K, NullValue>> vertices = edges.flatMap(new EmitSrcAndTarget<K, EV>()).distinct()___		return new Graph<K, NullValue, EV>(vertices, edges, context)__	};creates,a,graph,from,a,data,set,of,edges,vertices,are,created,automatically,and,their,values,are,set,to,null,value,param,edges,a,data,set,of,edges,param,context,the,flink,execution,environment,return,the,newly,created,graph;public,static,k,ev,graph,k,null,value,ev,from,data,set,data,set,edge,k,ev,edges,execution,environment,context,data,set,vertex,k,null,value,vertices,edges,flat,map,new,emit,src,and,target,k,ev,distinct,return,new,graph,k,null,value,ev,vertices,edges,context
Graph -> public static <K, EV> Graph<K, NullValue, EV> fromDataSet( 			DataSet<Edge<K, EV>> edges, ExecutionEnvironment context);1466789678;Creates a graph from a DataSet of edges._Vertices are created automatically and their values are set to_NullValue.__@param edges a DataSet of edges._@param context the flink execution environment._@return the newly created graph.;public static <K, EV> Graph<K, NullValue, EV> fromDataSet(_			DataSet<Edge<K, EV>> edges, ExecutionEnvironment context) {__		DataSet<Vertex<K, NullValue>> vertices = edges.flatMap(new EmitSrcAndTarget<K, EV>()).distinct()___		return new Graph<K, NullValue, EV>(vertices, edges, context)__	};creates,a,graph,from,a,data,set,of,edges,vertices,are,created,automatically,and,their,values,are,set,to,null,value,param,edges,a,data,set,of,edges,param,context,the,flink,execution,environment,return,the,newly,created,graph;public,static,k,ev,graph,k,null,value,ev,from,data,set,data,set,edge,k,ev,edges,execution,environment,context,data,set,vertex,k,null,value,vertices,edges,flat,map,new,emit,src,and,target,k,ev,distinct,return,new,graph,k,null,value,ev,vertices,edges,context
Graph -> public static <K, EV> Graph<K, NullValue, EV> fromDataSet( 			DataSet<Edge<K, EV>> edges, ExecutionEnvironment context);1467140656;Creates a graph from a DataSet of edges._Vertices are created automatically and their values are set to_NullValue.__@param edges a DataSet of edges._@param context the flink execution environment._@return the newly created graph.;public static <K, EV> Graph<K, NullValue, EV> fromDataSet(_			DataSet<Edge<K, EV>> edges, ExecutionEnvironment context) {__		DataSet<Vertex<K, NullValue>> vertices = edges.flatMap(new EmitSrcAndTarget<K, EV>()).distinct()___		return new Graph<K, NullValue, EV>(vertices, edges, context)__	};creates,a,graph,from,a,data,set,of,edges,vertices,are,created,automatically,and,their,values,are,set,to,null,value,param,edges,a,data,set,of,edges,param,context,the,flink,execution,environment,return,the,newly,created,graph;public,static,k,ev,graph,k,null,value,ev,from,data,set,data,set,edge,k,ev,edges,execution,environment,context,data,set,vertex,k,null,value,vertices,edges,flat,map,new,emit,src,and,target,k,ev,distinct,return,new,graph,k,null,value,ev,vertices,edges,context
Graph -> public static <K, EV> Graph<K, NullValue, EV> fromDataSet( 			DataSet<Edge<K, EV>> edges, ExecutionEnvironment context);1467306272;Creates a graph from a DataSet of edges._Vertices are created automatically and their values are set to_NullValue.__@param edges a DataSet of edges._@param context the flink execution environment._@return the newly created graph.;public static <K, EV> Graph<K, NullValue, EV> fromDataSet(_			DataSet<Edge<K, EV>> edges, ExecutionEnvironment context) {__		DataSet<Vertex<K, NullValue>> vertices = edges.flatMap(new EmitSrcAndTarget<K, EV>()).distinct()___		return new Graph<K, NullValue, EV>(vertices, edges, context)__	};creates,a,graph,from,a,data,set,of,edges,vertices,are,created,automatically,and,their,values,are,set,to,null,value,param,edges,a,data,set,of,edges,param,context,the,flink,execution,environment,return,the,newly,created,graph;public,static,k,ev,graph,k,null,value,ev,from,data,set,data,set,edge,k,ev,edges,execution,environment,context,data,set,vertex,k,null,value,vertices,edges,flat,map,new,emit,src,and,target,k,ev,distinct,return,new,graph,k,null,value,ev,vertices,edges,context
Graph -> public static <K, EV> Graph<K, NullValue, EV> fromDataSet( 			DataSet<Edge<K, EV>> edges, ExecutionEnvironment context);1470042815;Creates a graph from a DataSet of edges._Vertices are created automatically and their values are set to_NullValue.__@param edges a DataSet of edges._@param context the flink execution environment._@return the newly created graph.;public static <K, EV> Graph<K, NullValue, EV> fromDataSet(_			DataSet<Edge<K, EV>> edges, ExecutionEnvironment context) {__		DataSet<Vertex<K, NullValue>> vertices = edges.flatMap(new EmitSrcAndTarget<K, EV>()).distinct()___		return new Graph<K, NullValue, EV>(vertices, edges, context)__	};creates,a,graph,from,a,data,set,of,edges,vertices,are,created,automatically,and,their,values,are,set,to,null,value,param,edges,a,data,set,of,edges,param,context,the,flink,execution,environment,return,the,newly,created,graph;public,static,k,ev,graph,k,null,value,ev,from,data,set,data,set,edge,k,ev,edges,execution,environment,context,data,set,vertex,k,null,value,vertices,edges,flat,map,new,emit,src,and,target,k,ev,distinct,return,new,graph,k,null,value,ev,vertices,edges,context
Graph -> public static <K, EV> Graph<K, NullValue, EV> fromDataSet( 			DataSet<Edge<K, EV>> edges, ExecutionEnvironment context);1475684776;Creates a graph from a DataSet of edges._Vertices are created automatically and their values are set to_NullValue.__@param edges a DataSet of edges._@param context the flink execution environment._@return the newly created graph.;public static <K, EV> Graph<K, NullValue, EV> fromDataSet(_			DataSet<Edge<K, EV>> edges, ExecutionEnvironment context) {__		DataSet<Vertex<K, NullValue>> vertices = edges.flatMap(new EmitSrcAndTarget<K, EV>()).distinct()___		return new Graph<>(vertices, edges, context)__	};creates,a,graph,from,a,data,set,of,edges,vertices,are,created,automatically,and,their,values,are,set,to,null,value,param,edges,a,data,set,of,edges,param,context,the,flink,execution,environment,return,the,newly,created,graph;public,static,k,ev,graph,k,null,value,ev,from,data,set,data,set,edge,k,ev,edges,execution,environment,context,data,set,vertex,k,null,value,vertices,edges,flat,map,new,emit,src,and,target,k,ev,distinct,return,new,graph,vertices,edges,context
Graph -> public static <K, EV> Graph<K, NullValue, EV> fromDataSet( 			DataSet<Edge<K, EV>> edges, ExecutionEnvironment context);1475685606;Creates a graph from a DataSet of edges._Vertices are created automatically and their values are set to_NullValue.__@param edges a DataSet of edges._@param context the flink execution environment._@return the newly created graph.;public static <K, EV> Graph<K, NullValue, EV> fromDataSet(_			DataSet<Edge<K, EV>> edges, ExecutionEnvironment context) {__		DataSet<Vertex<K, NullValue>> vertices = edges.flatMap(new EmitSrcAndTarget<K, EV>()).distinct()___		return new Graph<>(vertices, edges, context)__	};creates,a,graph,from,a,data,set,of,edges,vertices,are,created,automatically,and,their,values,are,set,to,null,value,param,edges,a,data,set,of,edges,param,context,the,flink,execution,environment,return,the,newly,created,graph;public,static,k,ev,graph,k,null,value,ev,from,data,set,data,set,edge,k,ev,edges,execution,environment,context,data,set,vertex,k,null,value,vertices,edges,flat,map,new,emit,src,and,target,k,ev,distinct,return,new,graph,vertices,edges,context
Graph -> public static <K, EV> Graph<K, NullValue, EV> fromDataSet( 			DataSet<Edge<K, EV>> edges, ExecutionEnvironment context);1481745825;Creates a graph from a DataSet of edges._Vertices are created automatically and their values are set to_NullValue.__@param edges a DataSet of edges._@param context the flink execution environment._@return the newly created graph.;public static <K, EV> Graph<K, NullValue, EV> fromDataSet(_			DataSet<Edge<K, EV>> edges, ExecutionEnvironment context) {__		DataSet<Vertex<K, NullValue>> vertices = edges_			.flatMap(new EmitSrcAndTarget<K, EV>())_				.name("Source and target IDs")_			.distinct()_				.name("IDs")___		return new Graph<>(vertices, edges, context)__	};creates,a,graph,from,a,data,set,of,edges,vertices,are,created,automatically,and,their,values,are,set,to,null,value,param,edges,a,data,set,of,edges,param,context,the,flink,execution,environment,return,the,newly,created,graph;public,static,k,ev,graph,k,null,value,ev,from,data,set,data,set,edge,k,ev,edges,execution,environment,context,data,set,vertex,k,null,value,vertices,edges,flat,map,new,emit,src,and,target,k,ev,name,source,and,target,ids,distinct,name,ids,return,new,graph,vertices,edges,context
Graph -> public static <K, EV> Graph<K, NullValue, EV> fromDataSet( 			DataSet<Edge<K, EV>> edges, ExecutionEnvironment context);1481881009;Creates a graph from a DataSet of edges._Vertices are created automatically and their values are set to_NullValue.__@param edges a DataSet of edges._@param context the flink execution environment._@return the newly created graph.;public static <K, EV> Graph<K, NullValue, EV> fromDataSet(_			DataSet<Edge<K, EV>> edges, ExecutionEnvironment context) {__		DataSet<Vertex<K, NullValue>> vertices = edges_			.flatMap(new EmitSrcAndTarget<K, EV>())_				.name("Source and target IDs")_			.distinct()_				.name("IDs")___		return new Graph<>(vertices, edges, context)__	};creates,a,graph,from,a,data,set,of,edges,vertices,are,created,automatically,and,their,values,are,set,to,null,value,param,edges,a,data,set,of,edges,param,context,the,flink,execution,environment,return,the,newly,created,graph;public,static,k,ev,graph,k,null,value,ev,from,data,set,data,set,edge,k,ev,edges,execution,environment,context,data,set,vertex,k,null,value,vertices,edges,flat,map,new,emit,src,and,target,k,ev,name,source,and,target,ids,distinct,name,ids,return,new,graph,vertices,edges,context
Graph -> public static <K, EV> Graph<K, NullValue, EV> fromDataSet( 			DataSet<Edge<K, EV>> edges, ExecutionEnvironment context);1484160227;Creates a graph from a DataSet of edges._Vertices are created automatically and their values are set to_NullValue.__@param edges a DataSet of edges._@param context the flink execution environment._@return the newly created graph.;public static <K, EV> Graph<K, NullValue, EV> fromDataSet(_			DataSet<Edge<K, EV>> edges, ExecutionEnvironment context) {__		DataSet<Vertex<K, NullValue>> vertices = edges_			.flatMap(new EmitSrcAndTarget<K, EV>())_				.name("Source and target IDs")_			.distinct()_				.name("IDs")___		return new Graph<>(vertices, edges, context)__	};creates,a,graph,from,a,data,set,of,edges,vertices,are,created,automatically,and,their,values,are,set,to,null,value,param,edges,a,data,set,of,edges,param,context,the,flink,execution,environment,return,the,newly,created,graph;public,static,k,ev,graph,k,null,value,ev,from,data,set,data,set,edge,k,ev,edges,execution,environment,context,data,set,vertex,k,null,value,vertices,edges,flat,map,new,emit,src,and,target,k,ev,name,source,and,target,ids,distinct,name,ids,return,new,graph,vertices,edges,context
Graph -> public static <K, EV> Graph<K, NullValue, EV> fromDataSet( 			DataSet<Edge<K, EV>> edges, ExecutionEnvironment context);1484685504;Creates a graph from a DataSet of edges._Vertices are created automatically and their values are set to_NullValue.__@param edges a DataSet of edges._@param context the flink execution environment._@return the newly created graph.;public static <K, EV> Graph<K, NullValue, EV> fromDataSet(_			DataSet<Edge<K, EV>> edges, ExecutionEnvironment context) {__		DataSet<Vertex<K, NullValue>> vertices = edges_			.flatMap(new EmitSrcAndTarget<K, EV>())_				.name("Source and target IDs")_			.distinct()_				.name("IDs")___		return new Graph<>(vertices, edges, context)__	};creates,a,graph,from,a,data,set,of,edges,vertices,are,created,automatically,and,their,values,are,set,to,null,value,param,edges,a,data,set,of,edges,param,context,the,flink,execution,environment,return,the,newly,created,graph;public,static,k,ev,graph,k,null,value,ev,from,data,set,data,set,edge,k,ev,edges,execution,environment,context,data,set,vertex,k,null,value,vertices,edges,flat,map,new,emit,src,and,target,k,ev,name,source,and,target,ids,distinct,name,ids,return,new,graph,vertices,edges,context
Graph -> public static <K, EV> Graph<K, NullValue, EV> fromDataSet( 			DataSet<Edge<K, EV>> edges, ExecutionEnvironment context);1489068942;Creates a graph from a DataSet of edges._Vertices are created automatically and their values are set to_NullValue.__@param edges a DataSet of edges._@param context the flink execution environment._@return the newly created graph.;public static <K, EV> Graph<K, NullValue, EV> fromDataSet(_			DataSet<Edge<K, EV>> edges, ExecutionEnvironment context) {__		DataSet<Vertex<K, NullValue>> vertices = edges_			.flatMap(new EmitSrcAndTarget<K, EV>())_				.name("Source and target IDs")_			.distinct()_				.name("IDs")___		return new Graph<>(vertices, edges, context)__	};creates,a,graph,from,a,data,set,of,edges,vertices,are,created,automatically,and,their,values,are,set,to,null,value,param,edges,a,data,set,of,edges,param,context,the,flink,execution,environment,return,the,newly,created,graph;public,static,k,ev,graph,k,null,value,ev,from,data,set,data,set,edge,k,ev,edges,execution,environment,context,data,set,vertex,k,null,value,vertices,edges,flat,map,new,emit,src,and,target,k,ev,name,source,and,target,ids,distinct,name,ids,return,new,graph,vertices,edges,context
Graph -> public static <K, EV> Graph<K, NullValue, EV> fromDataSet( 			DataSet<Edge<K, EV>> edges, ExecutionEnvironment context);1490973446;Creates a graph from a DataSet of edges._Vertices are created automatically and their values are set to_NullValue.__@param edges a DataSet of edges._@param context the flink execution environment._@return the newly created graph.;public static <K, EV> Graph<K, NullValue, EV> fromDataSet(_			DataSet<Edge<K, EV>> edges, ExecutionEnvironment context) {__		DataSet<Vertex<K, NullValue>> vertices = edges_			.flatMap(new EmitSrcAndTarget<K, EV>())_				.name("Source and target IDs")_			.distinct()_				.name("IDs")___		return new Graph<>(vertices, edges, context)__	};creates,a,graph,from,a,data,set,of,edges,vertices,are,created,automatically,and,their,values,are,set,to,null,value,param,edges,a,data,set,of,edges,param,context,the,flink,execution,environment,return,the,newly,created,graph;public,static,k,ev,graph,k,null,value,ev,from,data,set,data,set,edge,k,ev,edges,execution,environment,context,data,set,vertex,k,null,value,vertices,edges,flat,map,new,emit,src,and,target,k,ev,name,source,and,target,ids,distinct,name,ids,return,new,graph,vertices,edges,context
Graph -> public static <K, EV> Graph<K, NullValue, EV> fromDataSet( 			DataSet<Edge<K, EV>> edges, ExecutionEnvironment context);1495819075;Creates a graph from a DataSet of edges._Vertices are created automatically and their values are set to_NullValue.__@param edges a DataSet of edges._@param context the flink execution environment._@return the newly created graph.;public static <K, EV> Graph<K, NullValue, EV> fromDataSet(_			DataSet<Edge<K, EV>> edges, ExecutionEnvironment context) {__		DataSet<Vertex<K, NullValue>> vertices = edges_			.flatMap(new EmitSrcAndTarget<K, EV>())_				.name("Source and target IDs")_			.distinct()_				.name("IDs")___		return new Graph<>(vertices, edges, context)__	};creates,a,graph,from,a,data,set,of,edges,vertices,are,created,automatically,and,their,values,are,set,to,null,value,param,edges,a,data,set,of,edges,param,context,the,flink,execution,environment,return,the,newly,created,graph;public,static,k,ev,graph,k,null,value,ev,from,data,set,data,set,edge,k,ev,edges,execution,environment,context,data,set,vertex,k,null,value,vertices,edges,flat,map,new,emit,src,and,target,k,ev,name,source,and,target,ids,distinct,name,ids,return,new,graph,vertices,edges,context
Graph -> public static <K, EV> Graph<K, NullValue, EV> fromDataSet( 			DataSet<Edge<K, EV>> edges, ExecutionEnvironment context);1502111816;Creates a graph from a DataSet of edges._Vertices are created automatically and their values are set to_NullValue.__@param edges a DataSet of edges._@param context the flink execution environment._@return the newly created graph.;public static <K, EV> Graph<K, NullValue, EV> fromDataSet(_			DataSet<Edge<K, EV>> edges, ExecutionEnvironment context) {__		DataSet<Vertex<K, NullValue>> vertices = edges_			.flatMap(new EmitSrcAndTarget<>())_				.name("Source and target IDs")_			.distinct()_				.name("IDs")___		return new Graph<>(vertices, edges, context)__	};creates,a,graph,from,a,data,set,of,edges,vertices,are,created,automatically,and,their,values,are,set,to,null,value,param,edges,a,data,set,of,edges,param,context,the,flink,execution,environment,return,the,newly,created,graph;public,static,k,ev,graph,k,null,value,ev,from,data,set,data,set,edge,k,ev,edges,execution,environment,context,data,set,vertex,k,null,value,vertices,edges,flat,map,new,emit,src,and,target,name,source,and,target,ids,distinct,name,ids,return,new,graph,vertices,edges,context
Graph -> public <T> T run(GraphAlgorithm<K, VV, EV, T> algorithm) throws Exception;1444404795;@param algorithm the algorithm to run on the Graph_@param <T> the return type_@return the result of the graph algorithm_@throws Exception;public <T> T run(GraphAlgorithm<K, VV, EV, T> algorithm) throws Exception {_		return algorithm.run(this)__	};param,algorithm,the,algorithm,to,run,on,the,graph,param,t,the,return,type,return,the,result,of,the,graph,algorithm,throws,exception;public,t,t,run,graph,algorithm,k,vv,ev,t,algorithm,throws,exception,return,algorithm,run,this
Graph -> public <T> T run(GraphAlgorithm<K, VV, EV, T> algorithm) throws Exception;1445261977;@param algorithm the algorithm to run on the Graph_@param <T> the return type_@return the result of the graph algorithm_@throws Exception;public <T> T run(GraphAlgorithm<K, VV, EV, T> algorithm) throws Exception {_		return algorithm.run(this)__	};param,algorithm,the,algorithm,to,run,on,the,graph,param,t,the,return,type,return,the,result,of,the,graph,algorithm,throws,exception;public,t,t,run,graph,algorithm,k,vv,ev,t,algorithm,throws,exception,return,algorithm,run,this
Graph -> public <T> T run(GraphAlgorithm<K, VV, EV, T> algorithm) throws Exception;1445854323;@param algorithm the algorithm to run on the Graph_@param <T> the return type_@return the result of the graph algorithm_@throws Exception;public <T> T run(GraphAlgorithm<K, VV, EV, T> algorithm) throws Exception {_		return algorithm.run(this)__	};param,algorithm,the,algorithm,to,run,on,the,graph,param,t,the,return,type,return,the,result,of,the,graph,algorithm,throws,exception;public,t,t,run,graph,algorithm,k,vv,ev,t,algorithm,throws,exception,return,algorithm,run,this
Graph -> public <T> T run(GraphAlgorithm<K, VV, EV, T> algorithm) throws Exception;1446112342;@param algorithm the algorithm to run on the Graph_@param <T> the return type_@return the result of the graph algorithm_@throws Exception;public <T> T run(GraphAlgorithm<K, VV, EV, T> algorithm) throws Exception {_		return algorithm.run(this)__	};param,algorithm,the,algorithm,to,run,on,the,graph,param,t,the,return,type,return,the,result,of,the,graph,algorithm,throws,exception;public,t,t,run,graph,algorithm,k,vv,ev,t,algorithm,throws,exception,return,algorithm,run,this
Graph -> public <T> T run(GraphAlgorithm<K, VV, EV, T> algorithm) throws Exception;1447073368;@param algorithm the algorithm to run on the Graph_@param <T> the return type_@return the result of the graph algorithm_@throws Exception;public <T> T run(GraphAlgorithm<K, VV, EV, T> algorithm) throws Exception {_		return algorithm.run(this)__	};param,algorithm,the,algorithm,to,run,on,the,graph,param,t,the,return,type,return,the,result,of,the,graph,algorithm,throws,exception;public,t,t,run,graph,algorithm,k,vv,ev,t,algorithm,throws,exception,return,algorithm,run,this
Graph -> public <T> T run(GraphAlgorithm<K, VV, EV, T> algorithm) throws Exception;1454404649;@param algorithm the algorithm to run on the Graph_@param <T> the return type_@return the result of the graph algorithm_@throws Exception;public <T> T run(GraphAlgorithm<K, VV, EV, T> algorithm) throws Exception {_		return algorithm.run(this)__	};param,algorithm,the,algorithm,to,run,on,the,graph,param,t,the,return,type,return,the,result,of,the,graph,algorithm,throws,exception;public,t,t,run,graph,algorithm,k,vv,ev,t,algorithm,throws,exception,return,algorithm,run,this
Graph -> public <T> T run(GraphAlgorithm<K, VV, EV, T> algorithm) throws Exception;1458583829;@param algorithm the algorithm to run on the Graph_@param <T> the return type_@return the result of the graph algorithm_@throws Exception;public <T> T run(GraphAlgorithm<K, VV, EV, T> algorithm) throws Exception {_		return algorithm.run(this)__	};param,algorithm,the,algorithm,to,run,on,the,graph,param,t,the,return,type,return,the,result,of,the,graph,algorithm,throws,exception;public,t,t,run,graph,algorithm,k,vv,ev,t,algorithm,throws,exception,return,algorithm,run,this
Graph -> public <T> T run(GraphAlgorithm<K, VV, EV, T> algorithm) throws Exception;1458583829;@param algorithm the algorithm to run on the Graph_@param <T> the return type_@return the result of the graph algorithm_@throws Exception;public <T> T run(GraphAlgorithm<K, VV, EV, T> algorithm) throws Exception {_		return algorithm.run(this)__	};param,algorithm,the,algorithm,to,run,on,the,graph,param,t,the,return,type,return,the,result,of,the,graph,algorithm,throws,exception;public,t,t,run,graph,algorithm,k,vv,ev,t,algorithm,throws,exception,return,algorithm,run,this
Graph -> public <T> T run(GraphAlgorithm<K, VV, EV, T> algorithm) throws Exception;1462100316;@param algorithm the algorithm to run on the Graph_@param <T> the return type_@return the result of the graph algorithm_@throws Exception;public <T> T run(GraphAlgorithm<K, VV, EV, T> algorithm) throws Exception {_		return algorithm.run(this)__	};param,algorithm,the,algorithm,to,run,on,the,graph,param,t,the,return,type,return,the,result,of,the,graph,algorithm,throws,exception;public,t,t,run,graph,algorithm,k,vv,ev,t,algorithm,throws,exception,return,algorithm,run,this
Graph -> public <T> T run(GraphAlgorithm<K, VV, EV, T> algorithm) throws Exception;1462100316;@param algorithm the algorithm to run on the Graph_@param <T> the return type_@return the result of the graph algorithm_@throws Exception;public <T> T run(GraphAlgorithm<K, VV, EV, T> algorithm) throws Exception {_		return algorithm.run(this)__	};param,algorithm,the,algorithm,to,run,on,the,graph,param,t,the,return,type,return,the,result,of,the,graph,algorithm,throws,exception;public,t,t,run,graph,algorithm,k,vv,ev,t,algorithm,throws,exception,return,algorithm,run,this
Graph -> public <T> T run(GraphAlgorithm<K, VV, EV, T> algorithm) throws Exception;1462205213;@param algorithm the algorithm to run on the Graph_@param <T> the return type_@return the result of the graph algorithm_@throws Exception;public <T> T run(GraphAlgorithm<K, VV, EV, T> algorithm) throws Exception {_		return algorithm.run(this)__	};param,algorithm,the,algorithm,to,run,on,the,graph,param,t,the,return,type,return,the,result,of,the,graph,algorithm,throws,exception;public,t,t,run,graph,algorithm,k,vv,ev,t,algorithm,throws,exception,return,algorithm,run,this
Graph -> public <T> T run(GraphAlgorithm<K, VV, EV, T> algorithm) throws Exception;1462208859;@param algorithm the algorithm to run on the Graph_@param <T> the return type_@return the result of the graph algorithm_@throws Exception;public <T> T run(GraphAlgorithm<K, VV, EV, T> algorithm) throws Exception {_		return algorithm.run(this)__	};param,algorithm,the,algorithm,to,run,on,the,graph,param,t,the,return,type,return,the,result,of,the,graph,algorithm,throws,exception;public,t,t,run,graph,algorithm,k,vv,ev,t,algorithm,throws,exception,return,algorithm,run,this
Graph -> public <T> T run(GraphAlgorithm<K, VV, EV, T> algorithm) throws Exception;1462809297;@param algorithm the algorithm to run on the Graph_@param <T> the return type_@return the result of the graph algorithm_@throws Exception;public <T> T run(GraphAlgorithm<K, VV, EV, T> algorithm) throws Exception {_		return algorithm.run(this)__	};param,algorithm,the,algorithm,to,run,on,the,graph,param,t,the,return,type,return,the,result,of,the,graph,algorithm,throws,exception;public,t,t,run,graph,algorithm,k,vv,ev,t,algorithm,throws,exception,return,algorithm,run,this
Graph -> public <T> T run(GraphAlgorithm<K, VV, EV, T> algorithm) throws Exception;1465316775;@param algorithm the algorithm to run on the Graph_@param <T> the return type_@return the result of the graph algorithm_@throws Exception;public <T> T run(GraphAlgorithm<K, VV, EV, T> algorithm) throws Exception {_		return algorithm.run(this)__	};param,algorithm,the,algorithm,to,run,on,the,graph,param,t,the,return,type,return,the,result,of,the,graph,algorithm,throws,exception;public,t,t,run,graph,algorithm,k,vv,ev,t,algorithm,throws,exception,return,algorithm,run,this
Graph -> public <T> T run(GraphAlgorithm<K, VV, EV, T> algorithm) throws Exception;1466789678;@param algorithm the algorithm to run on the Graph_@param <T> the return type_@return the result of the graph algorithm_@throws Exception;public <T> T run(GraphAlgorithm<K, VV, EV, T> algorithm) throws Exception {_		return algorithm.run(this)__	};param,algorithm,the,algorithm,to,run,on,the,graph,param,t,the,return,type,return,the,result,of,the,graph,algorithm,throws,exception;public,t,t,run,graph,algorithm,k,vv,ev,t,algorithm,throws,exception,return,algorithm,run,this
Graph -> public <T> T run(GraphAlgorithm<K, VV, EV, T> algorithm) throws Exception;1467140656;@param algorithm the algorithm to run on the Graph_@param <T> the return type_@return the result of the graph algorithm_@throws Exception;public <T> T run(GraphAlgorithm<K, VV, EV, T> algorithm) throws Exception {_		return algorithm.run(this)__	};param,algorithm,the,algorithm,to,run,on,the,graph,param,t,the,return,type,return,the,result,of,the,graph,algorithm,throws,exception;public,t,t,run,graph,algorithm,k,vv,ev,t,algorithm,throws,exception,return,algorithm,run,this
Graph -> public <T> T run(GraphAlgorithm<K, VV, EV, T> algorithm) throws Exception;1467306272;@param algorithm the algorithm to run on the Graph_@param <T> the return type_@return the result of the graph algorithm_@throws Exception;public <T> T run(GraphAlgorithm<K, VV, EV, T> algorithm) throws Exception {_		return algorithm.run(this)__	};param,algorithm,the,algorithm,to,run,on,the,graph,param,t,the,return,type,return,the,result,of,the,graph,algorithm,throws,exception;public,t,t,run,graph,algorithm,k,vv,ev,t,algorithm,throws,exception,return,algorithm,run,this
Graph -> public <T> T run(GraphAlgorithm<K, VV, EV, T> algorithm) throws Exception;1470042815;@param algorithm the algorithm to run on the Graph_@param <T> the return type_@return the result of the graph algorithm_@throws Exception;public <T> T run(GraphAlgorithm<K, VV, EV, T> algorithm) throws Exception {_		return algorithm.run(this)__	};param,algorithm,the,algorithm,to,run,on,the,graph,param,t,the,return,type,return,the,result,of,the,graph,algorithm,throws,exception;public,t,t,run,graph,algorithm,k,vv,ev,t,algorithm,throws,exception,return,algorithm,run,this
Graph -> public <T> T run(GraphAlgorithm<K, VV, EV, T> algorithm) throws Exception;1475684776;@param algorithm the algorithm to run on the Graph_@param <T> the return type_@return the result of the graph algorithm_@throws Exception;public <T> T run(GraphAlgorithm<K, VV, EV, T> algorithm) throws Exception {_		return algorithm.run(this)__	};param,algorithm,the,algorithm,to,run,on,the,graph,param,t,the,return,type,return,the,result,of,the,graph,algorithm,throws,exception;public,t,t,run,graph,algorithm,k,vv,ev,t,algorithm,throws,exception,return,algorithm,run,this
Graph -> public <T> T run(GraphAlgorithm<K, VV, EV, T> algorithm) throws Exception;1475685606;@param algorithm the algorithm to run on the Graph_@param <T> the return type_@return the result of the graph algorithm_@throws Exception;public <T> T run(GraphAlgorithm<K, VV, EV, T> algorithm) throws Exception {_		return algorithm.run(this)__	};param,algorithm,the,algorithm,to,run,on,the,graph,param,t,the,return,type,return,the,result,of,the,graph,algorithm,throws,exception;public,t,t,run,graph,algorithm,k,vv,ev,t,algorithm,throws,exception,return,algorithm,run,this
Graph -> public <T> T run(GraphAlgorithm<K, VV, EV, T> algorithm) throws Exception;1481745825;@param algorithm the algorithm to run on the Graph_@param <T> the return type_@return the result of the graph algorithm_@throws Exception;public <T> T run(GraphAlgorithm<K, VV, EV, T> algorithm) throws Exception {_		return algorithm.run(this)__	};param,algorithm,the,algorithm,to,run,on,the,graph,param,t,the,return,type,return,the,result,of,the,graph,algorithm,throws,exception;public,t,t,run,graph,algorithm,k,vv,ev,t,algorithm,throws,exception,return,algorithm,run,this
Graph -> public <T> T run(GraphAlgorithm<K, VV, EV, T> algorithm) throws Exception;1481881009;@param algorithm the algorithm to run on the Graph_@param <T> the return type_@return the result of the graph algorithm_@throws Exception;public <T> T run(GraphAlgorithm<K, VV, EV, T> algorithm) throws Exception {_		return algorithm.run(this)__	};param,algorithm,the,algorithm,to,run,on,the,graph,param,t,the,return,type,return,the,result,of,the,graph,algorithm,throws,exception;public,t,t,run,graph,algorithm,k,vv,ev,t,algorithm,throws,exception,return,algorithm,run,this
Graph -> public <T> T run(GraphAlgorithm<K, VV, EV, T> algorithm) throws Exception;1484160227;@param algorithm the algorithm to run on the Graph_@param <T> the return type_@return the result of the graph algorithm_@throws Exception;public <T> T run(GraphAlgorithm<K, VV, EV, T> algorithm) throws Exception {_		return algorithm.run(this)__	};param,algorithm,the,algorithm,to,run,on,the,graph,param,t,the,return,type,return,the,result,of,the,graph,algorithm,throws,exception;public,t,t,run,graph,algorithm,k,vv,ev,t,algorithm,throws,exception,return,algorithm,run,this
Graph -> public <T> T run(GraphAlgorithm<K, VV, EV, T> algorithm) throws Exception;1484685504;@param algorithm the algorithm to run on the Graph_@param <T> the return type_@return the result of the graph algorithm_@throws Exception;public <T> T run(GraphAlgorithm<K, VV, EV, T> algorithm) throws Exception {_		return algorithm.run(this)__	};param,algorithm,the,algorithm,to,run,on,the,graph,param,t,the,return,type,return,the,result,of,the,graph,algorithm,throws,exception;public,t,t,run,graph,algorithm,k,vv,ev,t,algorithm,throws,exception,return,algorithm,run,this
Graph -> public <T> T run(GraphAlgorithm<K, VV, EV, T> algorithm) throws Exception;1489068942;@param algorithm the algorithm to run on the Graph_@param <T> the return type_@return the result of the graph algorithm_@throws Exception;public <T> T run(GraphAlgorithm<K, VV, EV, T> algorithm) throws Exception {_		return algorithm.run(this)__	};param,algorithm,the,algorithm,to,run,on,the,graph,param,t,the,return,type,return,the,result,of,the,graph,algorithm,throws,exception;public,t,t,run,graph,algorithm,k,vv,ev,t,algorithm,throws,exception,return,algorithm,run,this
Graph -> public <T> T run(GraphAlgorithm<K, VV, EV, T> algorithm) throws Exception;1490973446;@param algorithm the algorithm to run on the Graph_@param <T> the return type_@return the result of the graph algorithm_@throws Exception;public <T> T run(GraphAlgorithm<K, VV, EV, T> algorithm) throws Exception {_		return algorithm.run(this)__	};param,algorithm,the,algorithm,to,run,on,the,graph,param,t,the,return,type,return,the,result,of,the,graph,algorithm,throws,exception;public,t,t,run,graph,algorithm,k,vv,ev,t,algorithm,throws,exception,return,algorithm,run,this
Graph -> public <T> T run(GraphAlgorithm<K, VV, EV, T> algorithm) throws Exception;1495819075;@param algorithm the algorithm to run on the Graph_@param <T> the return type_@return the result of the graph algorithm_@throws Exception;public <T> T run(GraphAlgorithm<K, VV, EV, T> algorithm) throws Exception {_		return algorithm.run(this)__	};param,algorithm,the,algorithm,to,run,on,the,graph,param,t,the,return,type,return,the,result,of,the,graph,algorithm,throws,exception;public,t,t,run,graph,algorithm,k,vv,ev,t,algorithm,throws,exception,return,algorithm,run,this
Graph -> public <T> T run(GraphAlgorithm<K, VV, EV, T> algorithm) throws Exception;1502111816;@param algorithm the algorithm to run on the Graph_@param <T> the return type_@return the result of the graph algorithm_@throws Exception;public <T> T run(GraphAlgorithm<K, VV, EV, T> algorithm) throws Exception {_		return algorithm.run(this)__	};param,algorithm,the,algorithm,to,run,on,the,graph,param,t,the,return,type,return,the,result,of,the,graph,algorithm,throws,exception;public,t,t,run,graph,algorithm,k,vv,ev,t,algorithm,throws,exception,return,algorithm,run,this
Graph -> public <T> Graph<K, VV, EV> joinWithVertices(DataSet<Tuple2<K, T>> inputDataSet, 			final VertexJoinFunction<VV, T> vertexJoinFunction);1495819075;Joins the vertex DataSet of this graph with an input Tuple2 DataSet and applies_a user-defined transformation on the values of the matched records._The vertex ID and the first field of the Tuple2 DataSet are used as the join keys.__@param inputDataSet the Tuple2 DataSet to join with._The first field of the Tuple2 is used as the join key and the second field is passed_as a parameter to the transformation function._@param vertexJoinFunction the transformation function to apply._The first parameter is the current vertex value and the second parameter is the value_of the matched Tuple2 from the input DataSet._@return a new Graph, where the vertex values have been updated according to the_result of the vertexJoinFunction.__@param <T> the type of the second field of the input Tuple2 DataSet.;public <T> Graph<K, VV, EV> joinWithVertices(DataSet<Tuple2<K, T>> inputDataSet,_			final VertexJoinFunction<VV, T> vertexJoinFunction) {__		DataSet<Vertex<K, VV>> resultedVertices = this.getVertices()_				.coGroup(inputDataSet).where(0).equalTo(0)_				.with(new ApplyCoGroupToVertexValues<K, VV, T>(vertexJoinFunction))_					.name("Join with vertices")__		return new Graph<>(resultedVertices, this.edges, this.context)__	};joins,the,vertex,data,set,of,this,graph,with,an,input,tuple2,data,set,and,applies,a,user,defined,transformation,on,the,values,of,the,matched,records,the,vertex,id,and,the,first,field,of,the,tuple2,data,set,are,used,as,the,join,keys,param,input,data,set,the,tuple2,data,set,to,join,with,the,first,field,of,the,tuple2,is,used,as,the,join,key,and,the,second,field,is,passed,as,a,parameter,to,the,transformation,function,param,vertex,join,function,the,transformation,function,to,apply,the,first,parameter,is,the,current,vertex,value,and,the,second,parameter,is,the,value,of,the,matched,tuple2,from,the,input,data,set,return,a,new,graph,where,the,vertex,values,have,been,updated,according,to,the,result,of,the,vertex,join,function,param,t,the,type,of,the,second,field,of,the,input,tuple2,data,set;public,t,graph,k,vv,ev,join,with,vertices,data,set,tuple2,k,t,input,data,set,final,vertex,join,function,vv,t,vertex,join,function,data,set,vertex,k,vv,resulted,vertices,this,get,vertices,co,group,input,data,set,where,0,equal,to,0,with,new,apply,co,group,to,vertex,values,k,vv,t,vertex,join,function,name,join,with,vertices,return,new,graph,resulted,vertices,this,edges,this,context
Graph -> public <T> Graph<K, VV, EV> joinWithVertices(DataSet<Tuple2<K, T>> inputDataSet, 			final VertexJoinFunction<VV, T> vertexJoinFunction);1502111816;Joins the vertex DataSet of this graph with an input Tuple2 DataSet and applies_a user-defined transformation on the values of the matched records._The vertex ID and the first field of the Tuple2 DataSet are used as the join keys.__@param inputDataSet the Tuple2 DataSet to join with._The first field of the Tuple2 is used as the join key and the second field is passed_as a parameter to the transformation function._@param vertexJoinFunction the transformation function to apply._The first parameter is the current vertex value and the second parameter is the value_of the matched Tuple2 from the input DataSet._@return a new Graph, where the vertex values have been updated according to the_result of the vertexJoinFunction.__@param <T> the type of the second field of the input Tuple2 DataSet.;public <T> Graph<K, VV, EV> joinWithVertices(DataSet<Tuple2<K, T>> inputDataSet,_			final VertexJoinFunction<VV, T> vertexJoinFunction) {__		DataSet<Vertex<K, VV>> resultedVertices = this.getVertices()_				.coGroup(inputDataSet).where(0).equalTo(0)_				.with(new ApplyCoGroupToVertexValues<>(vertexJoinFunction))_					.name("Join with vertices")__		return new Graph<>(resultedVertices, this.edges, this.context)__	};joins,the,vertex,data,set,of,this,graph,with,an,input,tuple2,data,set,and,applies,a,user,defined,transformation,on,the,values,of,the,matched,records,the,vertex,id,and,the,first,field,of,the,tuple2,data,set,are,used,as,the,join,keys,param,input,data,set,the,tuple2,data,set,to,join,with,the,first,field,of,the,tuple2,is,used,as,the,join,key,and,the,second,field,is,passed,as,a,parameter,to,the,transformation,function,param,vertex,join,function,the,transformation,function,to,apply,the,first,parameter,is,the,current,vertex,value,and,the,second,parameter,is,the,value,of,the,matched,tuple2,from,the,input,data,set,return,a,new,graph,where,the,vertex,values,have,been,updated,according,to,the,result,of,the,vertex,join,function,param,t,the,type,of,the,second,field,of,the,input,tuple2,data,set;public,t,graph,k,vv,ev,join,with,vertices,data,set,tuple2,k,t,input,data,set,final,vertex,join,function,vv,t,vertex,join,function,data,set,vertex,k,vv,resulted,vertices,this,get,vertices,co,group,input,data,set,where,0,equal,to,0,with,new,apply,co,group,to,vertex,values,vertex,join,function,name,join,with,vertices,return,new,graph,resulted,vertices,this,edges,this,context
Graph -> public <T> Graph<K, VV, EV> joinWithVertices(DataSet<Tuple2<K, T>> inputDataSet,  			final VertexJoinFunction<VV, T> vertexJoinFunction);1445261977;Joins the vertex DataSet of this graph with an input Tuple2 DataSet and applies_a user-defined transformation on the values of the matched records._The vertex ID and the first field of the Tuple2 DataSet are used as the join keys.__@param inputDataSet the Tuple2 DataSet to join with._The first field of the Tuple2 is used as the join key and the second field is passed_as a parameter to the transformation function._@param vertexJoinFunction the transformation function to apply._The first parameter is the current vertex value and the second parameter is the value_of the matched Tuple2 from the input DataSet._@return a new Graph, where the vertex values have been updated according to the_result of the vertexJoinFunction.__@param <T> the type of the second field of the input Tuple2 DataSet.;public <T> Graph<K, VV, EV> joinWithVertices(DataSet<Tuple2<K, T>> inputDataSet, _			final VertexJoinFunction<VV, T> vertexJoinFunction) {__		DataSet<Vertex<K, VV>> resultedVertices = this.getVertices()_				.coGroup(inputDataSet).where(0).equalTo(0)_				.with(new ApplyCoGroupToVertexValues<K, VV, T>(vertexJoinFunction))__		return new Graph<K, VV, EV>(resultedVertices, this.edges, this.context)__	};joins,the,vertex,data,set,of,this,graph,with,an,input,tuple2,data,set,and,applies,a,user,defined,transformation,on,the,values,of,the,matched,records,the,vertex,id,and,the,first,field,of,the,tuple2,data,set,are,used,as,the,join,keys,param,input,data,set,the,tuple2,data,set,to,join,with,the,first,field,of,the,tuple2,is,used,as,the,join,key,and,the,second,field,is,passed,as,a,parameter,to,the,transformation,function,param,vertex,join,function,the,transformation,function,to,apply,the,first,parameter,is,the,current,vertex,value,and,the,second,parameter,is,the,value,of,the,matched,tuple2,from,the,input,data,set,return,a,new,graph,where,the,vertex,values,have,been,updated,according,to,the,result,of,the,vertex,join,function,param,t,the,type,of,the,second,field,of,the,input,tuple2,data,set;public,t,graph,k,vv,ev,join,with,vertices,data,set,tuple2,k,t,input,data,set,final,vertex,join,function,vv,t,vertex,join,function,data,set,vertex,k,vv,resulted,vertices,this,get,vertices,co,group,input,data,set,where,0,equal,to,0,with,new,apply,co,group,to,vertex,values,k,vv,t,vertex,join,function,return,new,graph,k,vv,ev,resulted,vertices,this,edges,this,context
Graph -> public <T> Graph<K, VV, EV> joinWithVertices(DataSet<Tuple2<K, T>> inputDataSet,  			final VertexJoinFunction<VV, T> vertexJoinFunction);1445854323;Joins the vertex DataSet of this graph with an input Tuple2 DataSet and applies_a user-defined transformation on the values of the matched records._The vertex ID and the first field of the Tuple2 DataSet are used as the join keys.__@param inputDataSet the Tuple2 DataSet to join with._The first field of the Tuple2 is used as the join key and the second field is passed_as a parameter to the transformation function._@param vertexJoinFunction the transformation function to apply._The first parameter is the current vertex value and the second parameter is the value_of the matched Tuple2 from the input DataSet._@return a new Graph, where the vertex values have been updated according to the_result of the vertexJoinFunction.__@param <T> the type of the second field of the input Tuple2 DataSet.;public <T> Graph<K, VV, EV> joinWithVertices(DataSet<Tuple2<K, T>> inputDataSet, _			final VertexJoinFunction<VV, T> vertexJoinFunction) {__		DataSet<Vertex<K, VV>> resultedVertices = this.getVertices()_				.coGroup(inputDataSet).where(0).equalTo(0)_				.with(new ApplyCoGroupToVertexValues<K, VV, T>(vertexJoinFunction))__		return new Graph<K, VV, EV>(resultedVertices, this.edges, this.context)__	};joins,the,vertex,data,set,of,this,graph,with,an,input,tuple2,data,set,and,applies,a,user,defined,transformation,on,the,values,of,the,matched,records,the,vertex,id,and,the,first,field,of,the,tuple2,data,set,are,used,as,the,join,keys,param,input,data,set,the,tuple2,data,set,to,join,with,the,first,field,of,the,tuple2,is,used,as,the,join,key,and,the,second,field,is,passed,as,a,parameter,to,the,transformation,function,param,vertex,join,function,the,transformation,function,to,apply,the,first,parameter,is,the,current,vertex,value,and,the,second,parameter,is,the,value,of,the,matched,tuple2,from,the,input,data,set,return,a,new,graph,where,the,vertex,values,have,been,updated,according,to,the,result,of,the,vertex,join,function,param,t,the,type,of,the,second,field,of,the,input,tuple2,data,set;public,t,graph,k,vv,ev,join,with,vertices,data,set,tuple2,k,t,input,data,set,final,vertex,join,function,vv,t,vertex,join,function,data,set,vertex,k,vv,resulted,vertices,this,get,vertices,co,group,input,data,set,where,0,equal,to,0,with,new,apply,co,group,to,vertex,values,k,vv,t,vertex,join,function,return,new,graph,k,vv,ev,resulted,vertices,this,edges,this,context
Graph -> public <T> Graph<K, VV, EV> joinWithVertices(DataSet<Tuple2<K, T>> inputDataSet,  			final VertexJoinFunction<VV, T> vertexJoinFunction);1446112342;Joins the vertex DataSet of this graph with an input Tuple2 DataSet and applies_a user-defined transformation on the values of the matched records._The vertex ID and the first field of the Tuple2 DataSet are used as the join keys.__@param inputDataSet the Tuple2 DataSet to join with._The first field of the Tuple2 is used as the join key and the second field is passed_as a parameter to the transformation function._@param vertexJoinFunction the transformation function to apply._The first parameter is the current vertex value and the second parameter is the value_of the matched Tuple2 from the input DataSet._@return a new Graph, where the vertex values have been updated according to the_result of the vertexJoinFunction.__@param <T> the type of the second field of the input Tuple2 DataSet.;public <T> Graph<K, VV, EV> joinWithVertices(DataSet<Tuple2<K, T>> inputDataSet, _			final VertexJoinFunction<VV, T> vertexJoinFunction) {__		DataSet<Vertex<K, VV>> resultedVertices = this.getVertices()_				.coGroup(inputDataSet).where(0).equalTo(0)_				.with(new ApplyCoGroupToVertexValues<K, VV, T>(vertexJoinFunction))__		return new Graph<K, VV, EV>(resultedVertices, this.edges, this.context)__	};joins,the,vertex,data,set,of,this,graph,with,an,input,tuple2,data,set,and,applies,a,user,defined,transformation,on,the,values,of,the,matched,records,the,vertex,id,and,the,first,field,of,the,tuple2,data,set,are,used,as,the,join,keys,param,input,data,set,the,tuple2,data,set,to,join,with,the,first,field,of,the,tuple2,is,used,as,the,join,key,and,the,second,field,is,passed,as,a,parameter,to,the,transformation,function,param,vertex,join,function,the,transformation,function,to,apply,the,first,parameter,is,the,current,vertex,value,and,the,second,parameter,is,the,value,of,the,matched,tuple2,from,the,input,data,set,return,a,new,graph,where,the,vertex,values,have,been,updated,according,to,the,result,of,the,vertex,join,function,param,t,the,type,of,the,second,field,of,the,input,tuple2,data,set;public,t,graph,k,vv,ev,join,with,vertices,data,set,tuple2,k,t,input,data,set,final,vertex,join,function,vv,t,vertex,join,function,data,set,vertex,k,vv,resulted,vertices,this,get,vertices,co,group,input,data,set,where,0,equal,to,0,with,new,apply,co,group,to,vertex,values,k,vv,t,vertex,join,function,return,new,graph,k,vv,ev,resulted,vertices,this,edges,this,context
Graph -> public <T> Graph<K, VV, EV> joinWithVertices(DataSet<Tuple2<K, T>> inputDataSet,  			final VertexJoinFunction<VV, T> vertexJoinFunction);1447073368;Joins the vertex DataSet of this graph with an input Tuple2 DataSet and applies_a user-defined transformation on the values of the matched records._The vertex ID and the first field of the Tuple2 DataSet are used as the join keys.__@param inputDataSet the Tuple2 DataSet to join with._The first field of the Tuple2 is used as the join key and the second field is passed_as a parameter to the transformation function._@param vertexJoinFunction the transformation function to apply._The first parameter is the current vertex value and the second parameter is the value_of the matched Tuple2 from the input DataSet._@return a new Graph, where the vertex values have been updated according to the_result of the vertexJoinFunction.__@param <T> the type of the second field of the input Tuple2 DataSet.;public <T> Graph<K, VV, EV> joinWithVertices(DataSet<Tuple2<K, T>> inputDataSet, _			final VertexJoinFunction<VV, T> vertexJoinFunction) {__		DataSet<Vertex<K, VV>> resultedVertices = this.getVertices()_				.coGroup(inputDataSet).where(0).equalTo(0)_				.with(new ApplyCoGroupToVertexValues<K, VV, T>(vertexJoinFunction))__		return new Graph<K, VV, EV>(resultedVertices, this.edges, this.context)__	};joins,the,vertex,data,set,of,this,graph,with,an,input,tuple2,data,set,and,applies,a,user,defined,transformation,on,the,values,of,the,matched,records,the,vertex,id,and,the,first,field,of,the,tuple2,data,set,are,used,as,the,join,keys,param,input,data,set,the,tuple2,data,set,to,join,with,the,first,field,of,the,tuple2,is,used,as,the,join,key,and,the,second,field,is,passed,as,a,parameter,to,the,transformation,function,param,vertex,join,function,the,transformation,function,to,apply,the,first,parameter,is,the,current,vertex,value,and,the,second,parameter,is,the,value,of,the,matched,tuple2,from,the,input,data,set,return,a,new,graph,where,the,vertex,values,have,been,updated,according,to,the,result,of,the,vertex,join,function,param,t,the,type,of,the,second,field,of,the,input,tuple2,data,set;public,t,graph,k,vv,ev,join,with,vertices,data,set,tuple2,k,t,input,data,set,final,vertex,join,function,vv,t,vertex,join,function,data,set,vertex,k,vv,resulted,vertices,this,get,vertices,co,group,input,data,set,where,0,equal,to,0,with,new,apply,co,group,to,vertex,values,k,vv,t,vertex,join,function,return,new,graph,k,vv,ev,resulted,vertices,this,edges,this,context
Graph -> public <T> Graph<K, VV, EV> joinWithVertices(DataSet<Tuple2<K, T>> inputDataSet,  			final VertexJoinFunction<VV, T> vertexJoinFunction);1454404649;Joins the vertex DataSet of this graph with an input Tuple2 DataSet and applies_a user-defined transformation on the values of the matched records._The vertex ID and the first field of the Tuple2 DataSet are used as the join keys.__@param inputDataSet the Tuple2 DataSet to join with._The first field of the Tuple2 is used as the join key and the second field is passed_as a parameter to the transformation function._@param vertexJoinFunction the transformation function to apply._The first parameter is the current vertex value and the second parameter is the value_of the matched Tuple2 from the input DataSet._@return a new Graph, where the vertex values have been updated according to the_result of the vertexJoinFunction.__@param <T> the type of the second field of the input Tuple2 DataSet.;public <T> Graph<K, VV, EV> joinWithVertices(DataSet<Tuple2<K, T>> inputDataSet, _			final VertexJoinFunction<VV, T> vertexJoinFunction) {__		DataSet<Vertex<K, VV>> resultedVertices = this.getVertices()_				.coGroup(inputDataSet).where(0).equalTo(0)_				.with(new ApplyCoGroupToVertexValues<K, VV, T>(vertexJoinFunction))__		return new Graph<K, VV, EV>(resultedVertices, this.edges, this.context)__	};joins,the,vertex,data,set,of,this,graph,with,an,input,tuple2,data,set,and,applies,a,user,defined,transformation,on,the,values,of,the,matched,records,the,vertex,id,and,the,first,field,of,the,tuple2,data,set,are,used,as,the,join,keys,param,input,data,set,the,tuple2,data,set,to,join,with,the,first,field,of,the,tuple2,is,used,as,the,join,key,and,the,second,field,is,passed,as,a,parameter,to,the,transformation,function,param,vertex,join,function,the,transformation,function,to,apply,the,first,parameter,is,the,current,vertex,value,and,the,second,parameter,is,the,value,of,the,matched,tuple2,from,the,input,data,set,return,a,new,graph,where,the,vertex,values,have,been,updated,according,to,the,result,of,the,vertex,join,function,param,t,the,type,of,the,second,field,of,the,input,tuple2,data,set;public,t,graph,k,vv,ev,join,with,vertices,data,set,tuple2,k,t,input,data,set,final,vertex,join,function,vv,t,vertex,join,function,data,set,vertex,k,vv,resulted,vertices,this,get,vertices,co,group,input,data,set,where,0,equal,to,0,with,new,apply,co,group,to,vertex,values,k,vv,t,vertex,join,function,return,new,graph,k,vv,ev,resulted,vertices,this,edges,this,context
Graph -> public <T> Graph<K, VV, EV> joinWithVertices(DataSet<Tuple2<K, T>> inputDataSet,  			final VertexJoinFunction<VV, T> vertexJoinFunction);1458583829;Joins the vertex DataSet of this graph with an input Tuple2 DataSet and applies_a user-defined transformation on the values of the matched records._The vertex ID and the first field of the Tuple2 DataSet are used as the join keys.__@param inputDataSet the Tuple2 DataSet to join with._The first field of the Tuple2 is used as the join key and the second field is passed_as a parameter to the transformation function._@param vertexJoinFunction the transformation function to apply._The first parameter is the current vertex value and the second parameter is the value_of the matched Tuple2 from the input DataSet._@return a new Graph, where the vertex values have been updated according to the_result of the vertexJoinFunction.__@param <T> the type of the second field of the input Tuple2 DataSet.;public <T> Graph<K, VV, EV> joinWithVertices(DataSet<Tuple2<K, T>> inputDataSet, _			final VertexJoinFunction<VV, T> vertexJoinFunction) {__		DataSet<Vertex<K, VV>> resultedVertices = this.getVertices()_				.coGroup(inputDataSet).where(0).equalTo(0)_				.with(new ApplyCoGroupToVertexValues<K, VV, T>(vertexJoinFunction))__		return new Graph<K, VV, EV>(resultedVertices, this.edges, this.context)__	};joins,the,vertex,data,set,of,this,graph,with,an,input,tuple2,data,set,and,applies,a,user,defined,transformation,on,the,values,of,the,matched,records,the,vertex,id,and,the,first,field,of,the,tuple2,data,set,are,used,as,the,join,keys,param,input,data,set,the,tuple2,data,set,to,join,with,the,first,field,of,the,tuple2,is,used,as,the,join,key,and,the,second,field,is,passed,as,a,parameter,to,the,transformation,function,param,vertex,join,function,the,transformation,function,to,apply,the,first,parameter,is,the,current,vertex,value,and,the,second,parameter,is,the,value,of,the,matched,tuple2,from,the,input,data,set,return,a,new,graph,where,the,vertex,values,have,been,updated,according,to,the,result,of,the,vertex,join,function,param,t,the,type,of,the,second,field,of,the,input,tuple2,data,set;public,t,graph,k,vv,ev,join,with,vertices,data,set,tuple2,k,t,input,data,set,final,vertex,join,function,vv,t,vertex,join,function,data,set,vertex,k,vv,resulted,vertices,this,get,vertices,co,group,input,data,set,where,0,equal,to,0,with,new,apply,co,group,to,vertex,values,k,vv,t,vertex,join,function,return,new,graph,k,vv,ev,resulted,vertices,this,edges,this,context
Graph -> public <T> Graph<K, VV, EV> joinWithVertices(DataSet<Tuple2<K, T>> inputDataSet,  			final VertexJoinFunction<VV, T> vertexJoinFunction);1458583829;Joins the vertex DataSet of this graph with an input Tuple2 DataSet and applies_a user-defined transformation on the values of the matched records._The vertex ID and the first field of the Tuple2 DataSet are used as the join keys.__@param inputDataSet the Tuple2 DataSet to join with._The first field of the Tuple2 is used as the join key and the second field is passed_as a parameter to the transformation function._@param vertexJoinFunction the transformation function to apply._The first parameter is the current vertex value and the second parameter is the value_of the matched Tuple2 from the input DataSet._@return a new Graph, where the vertex values have been updated according to the_result of the vertexJoinFunction.__@param <T> the type of the second field of the input Tuple2 DataSet.;public <T> Graph<K, VV, EV> joinWithVertices(DataSet<Tuple2<K, T>> inputDataSet, _			final VertexJoinFunction<VV, T> vertexJoinFunction) {__		DataSet<Vertex<K, VV>> resultedVertices = this.getVertices()_				.coGroup(inputDataSet).where(0).equalTo(0)_				.with(new ApplyCoGroupToVertexValues<K, VV, T>(vertexJoinFunction))__		return new Graph<K, VV, EV>(resultedVertices, this.edges, this.context)__	};joins,the,vertex,data,set,of,this,graph,with,an,input,tuple2,data,set,and,applies,a,user,defined,transformation,on,the,values,of,the,matched,records,the,vertex,id,and,the,first,field,of,the,tuple2,data,set,are,used,as,the,join,keys,param,input,data,set,the,tuple2,data,set,to,join,with,the,first,field,of,the,tuple2,is,used,as,the,join,key,and,the,second,field,is,passed,as,a,parameter,to,the,transformation,function,param,vertex,join,function,the,transformation,function,to,apply,the,first,parameter,is,the,current,vertex,value,and,the,second,parameter,is,the,value,of,the,matched,tuple2,from,the,input,data,set,return,a,new,graph,where,the,vertex,values,have,been,updated,according,to,the,result,of,the,vertex,join,function,param,t,the,type,of,the,second,field,of,the,input,tuple2,data,set;public,t,graph,k,vv,ev,join,with,vertices,data,set,tuple2,k,t,input,data,set,final,vertex,join,function,vv,t,vertex,join,function,data,set,vertex,k,vv,resulted,vertices,this,get,vertices,co,group,input,data,set,where,0,equal,to,0,with,new,apply,co,group,to,vertex,values,k,vv,t,vertex,join,function,return,new,graph,k,vv,ev,resulted,vertices,this,edges,this,context
Graph -> public <T> Graph<K, VV, EV> joinWithVertices(DataSet<Tuple2<K, T>> inputDataSet,  			final VertexJoinFunction<VV, T> vertexJoinFunction);1462100316;Joins the vertex DataSet of this graph with an input Tuple2 DataSet and applies_a user-defined transformation on the values of the matched records._The vertex ID and the first field of the Tuple2 DataSet are used as the join keys.__@param inputDataSet the Tuple2 DataSet to join with._The first field of the Tuple2 is used as the join key and the second field is passed_as a parameter to the transformation function._@param vertexJoinFunction the transformation function to apply._The first parameter is the current vertex value and the second parameter is the value_of the matched Tuple2 from the input DataSet._@return a new Graph, where the vertex values have been updated according to the_result of the vertexJoinFunction.__@param <T> the type of the second field of the input Tuple2 DataSet.;public <T> Graph<K, VV, EV> joinWithVertices(DataSet<Tuple2<K, T>> inputDataSet, _			final VertexJoinFunction<VV, T> vertexJoinFunction) {__		DataSet<Vertex<K, VV>> resultedVertices = this.getVertices()_				.coGroup(inputDataSet).where(0).equalTo(0)_				.with(new ApplyCoGroupToVertexValues<K, VV, T>(vertexJoinFunction))__		return new Graph<K, VV, EV>(resultedVertices, this.edges, this.context)__	};joins,the,vertex,data,set,of,this,graph,with,an,input,tuple2,data,set,and,applies,a,user,defined,transformation,on,the,values,of,the,matched,records,the,vertex,id,and,the,first,field,of,the,tuple2,data,set,are,used,as,the,join,keys,param,input,data,set,the,tuple2,data,set,to,join,with,the,first,field,of,the,tuple2,is,used,as,the,join,key,and,the,second,field,is,passed,as,a,parameter,to,the,transformation,function,param,vertex,join,function,the,transformation,function,to,apply,the,first,parameter,is,the,current,vertex,value,and,the,second,parameter,is,the,value,of,the,matched,tuple2,from,the,input,data,set,return,a,new,graph,where,the,vertex,values,have,been,updated,according,to,the,result,of,the,vertex,join,function,param,t,the,type,of,the,second,field,of,the,input,tuple2,data,set;public,t,graph,k,vv,ev,join,with,vertices,data,set,tuple2,k,t,input,data,set,final,vertex,join,function,vv,t,vertex,join,function,data,set,vertex,k,vv,resulted,vertices,this,get,vertices,co,group,input,data,set,where,0,equal,to,0,with,new,apply,co,group,to,vertex,values,k,vv,t,vertex,join,function,return,new,graph,k,vv,ev,resulted,vertices,this,edges,this,context
Graph -> public <T> Graph<K, VV, EV> joinWithVertices(DataSet<Tuple2<K, T>> inputDataSet,  			final VertexJoinFunction<VV, T> vertexJoinFunction);1462100316;Joins the vertex DataSet of this graph with an input Tuple2 DataSet and applies_a user-defined transformation on the values of the matched records._The vertex ID and the first field of the Tuple2 DataSet are used as the join keys.__@param inputDataSet the Tuple2 DataSet to join with._The first field of the Tuple2 is used as the join key and the second field is passed_as a parameter to the transformation function._@param vertexJoinFunction the transformation function to apply._The first parameter is the current vertex value and the second parameter is the value_of the matched Tuple2 from the input DataSet._@return a new Graph, where the vertex values have been updated according to the_result of the vertexJoinFunction.__@param <T> the type of the second field of the input Tuple2 DataSet.;public <T> Graph<K, VV, EV> joinWithVertices(DataSet<Tuple2<K, T>> inputDataSet, _			final VertexJoinFunction<VV, T> vertexJoinFunction) {__		DataSet<Vertex<K, VV>> resultedVertices = this.getVertices()_				.coGroup(inputDataSet).where(0).equalTo(0)_				.with(new ApplyCoGroupToVertexValues<K, VV, T>(vertexJoinFunction))__		return new Graph<K, VV, EV>(resultedVertices, this.edges, this.context)__	};joins,the,vertex,data,set,of,this,graph,with,an,input,tuple2,data,set,and,applies,a,user,defined,transformation,on,the,values,of,the,matched,records,the,vertex,id,and,the,first,field,of,the,tuple2,data,set,are,used,as,the,join,keys,param,input,data,set,the,tuple2,data,set,to,join,with,the,first,field,of,the,tuple2,is,used,as,the,join,key,and,the,second,field,is,passed,as,a,parameter,to,the,transformation,function,param,vertex,join,function,the,transformation,function,to,apply,the,first,parameter,is,the,current,vertex,value,and,the,second,parameter,is,the,value,of,the,matched,tuple2,from,the,input,data,set,return,a,new,graph,where,the,vertex,values,have,been,updated,according,to,the,result,of,the,vertex,join,function,param,t,the,type,of,the,second,field,of,the,input,tuple2,data,set;public,t,graph,k,vv,ev,join,with,vertices,data,set,tuple2,k,t,input,data,set,final,vertex,join,function,vv,t,vertex,join,function,data,set,vertex,k,vv,resulted,vertices,this,get,vertices,co,group,input,data,set,where,0,equal,to,0,with,new,apply,co,group,to,vertex,values,k,vv,t,vertex,join,function,return,new,graph,k,vv,ev,resulted,vertices,this,edges,this,context
Graph -> public <T> Graph<K, VV, EV> joinWithVertices(DataSet<Tuple2<K, T>> inputDataSet,  			final VertexJoinFunction<VV, T> vertexJoinFunction);1462205213;Joins the vertex DataSet of this graph with an input Tuple2 DataSet and applies_a user-defined transformation on the values of the matched records._The vertex ID and the first field of the Tuple2 DataSet are used as the join keys.__@param inputDataSet the Tuple2 DataSet to join with._The first field of the Tuple2 is used as the join key and the second field is passed_as a parameter to the transformation function._@param vertexJoinFunction the transformation function to apply._The first parameter is the current vertex value and the second parameter is the value_of the matched Tuple2 from the input DataSet._@return a new Graph, where the vertex values have been updated according to the_result of the vertexJoinFunction.__@param <T> the type of the second field of the input Tuple2 DataSet.;public <T> Graph<K, VV, EV> joinWithVertices(DataSet<Tuple2<K, T>> inputDataSet, _			final VertexJoinFunction<VV, T> vertexJoinFunction) {__		DataSet<Vertex<K, VV>> resultedVertices = this.getVertices()_				.coGroup(inputDataSet).where(0).equalTo(0)_				.with(new ApplyCoGroupToVertexValues<K, VV, T>(vertexJoinFunction))__		return new Graph<K, VV, EV>(resultedVertices, this.edges, this.context)__	};joins,the,vertex,data,set,of,this,graph,with,an,input,tuple2,data,set,and,applies,a,user,defined,transformation,on,the,values,of,the,matched,records,the,vertex,id,and,the,first,field,of,the,tuple2,data,set,are,used,as,the,join,keys,param,input,data,set,the,tuple2,data,set,to,join,with,the,first,field,of,the,tuple2,is,used,as,the,join,key,and,the,second,field,is,passed,as,a,parameter,to,the,transformation,function,param,vertex,join,function,the,transformation,function,to,apply,the,first,parameter,is,the,current,vertex,value,and,the,second,parameter,is,the,value,of,the,matched,tuple2,from,the,input,data,set,return,a,new,graph,where,the,vertex,values,have,been,updated,according,to,the,result,of,the,vertex,join,function,param,t,the,type,of,the,second,field,of,the,input,tuple2,data,set;public,t,graph,k,vv,ev,join,with,vertices,data,set,tuple2,k,t,input,data,set,final,vertex,join,function,vv,t,vertex,join,function,data,set,vertex,k,vv,resulted,vertices,this,get,vertices,co,group,input,data,set,where,0,equal,to,0,with,new,apply,co,group,to,vertex,values,k,vv,t,vertex,join,function,return,new,graph,k,vv,ev,resulted,vertices,this,edges,this,context
Graph -> public <T> Graph<K, VV, EV> joinWithVertices(DataSet<Tuple2<K, T>> inputDataSet,  			final VertexJoinFunction<VV, T> vertexJoinFunction);1462208859;Joins the vertex DataSet of this graph with an input Tuple2 DataSet and applies_a user-defined transformation on the values of the matched records._The vertex ID and the first field of the Tuple2 DataSet are used as the join keys.__@param inputDataSet the Tuple2 DataSet to join with._The first field of the Tuple2 is used as the join key and the second field is passed_as a parameter to the transformation function._@param vertexJoinFunction the transformation function to apply._The first parameter is the current vertex value and the second parameter is the value_of the matched Tuple2 from the input DataSet._@return a new Graph, where the vertex values have been updated according to the_result of the vertexJoinFunction.__@param <T> the type of the second field of the input Tuple2 DataSet.;public <T> Graph<K, VV, EV> joinWithVertices(DataSet<Tuple2<K, T>> inputDataSet, _			final VertexJoinFunction<VV, T> vertexJoinFunction) {__		DataSet<Vertex<K, VV>> resultedVertices = this.getVertices()_				.coGroup(inputDataSet).where(0).equalTo(0)_				.with(new ApplyCoGroupToVertexValues<K, VV, T>(vertexJoinFunction))__		return new Graph<K, VV, EV>(resultedVertices, this.edges, this.context)__	};joins,the,vertex,data,set,of,this,graph,with,an,input,tuple2,data,set,and,applies,a,user,defined,transformation,on,the,values,of,the,matched,records,the,vertex,id,and,the,first,field,of,the,tuple2,data,set,are,used,as,the,join,keys,param,input,data,set,the,tuple2,data,set,to,join,with,the,first,field,of,the,tuple2,is,used,as,the,join,key,and,the,second,field,is,passed,as,a,parameter,to,the,transformation,function,param,vertex,join,function,the,transformation,function,to,apply,the,first,parameter,is,the,current,vertex,value,and,the,second,parameter,is,the,value,of,the,matched,tuple2,from,the,input,data,set,return,a,new,graph,where,the,vertex,values,have,been,updated,according,to,the,result,of,the,vertex,join,function,param,t,the,type,of,the,second,field,of,the,input,tuple2,data,set;public,t,graph,k,vv,ev,join,with,vertices,data,set,tuple2,k,t,input,data,set,final,vertex,join,function,vv,t,vertex,join,function,data,set,vertex,k,vv,resulted,vertices,this,get,vertices,co,group,input,data,set,where,0,equal,to,0,with,new,apply,co,group,to,vertex,values,k,vv,t,vertex,join,function,return,new,graph,k,vv,ev,resulted,vertices,this,edges,this,context
Graph -> public <T> Graph<K, VV, EV> joinWithVertices(DataSet<Tuple2<K, T>> inputDataSet,  			final VertexJoinFunction<VV, T> vertexJoinFunction);1462809297;Joins the vertex DataSet of this graph with an input Tuple2 DataSet and applies_a user-defined transformation on the values of the matched records._The vertex ID and the first field of the Tuple2 DataSet are used as the join keys.__@param inputDataSet the Tuple2 DataSet to join with._The first field of the Tuple2 is used as the join key and the second field is passed_as a parameter to the transformation function._@param vertexJoinFunction the transformation function to apply._The first parameter is the current vertex value and the second parameter is the value_of the matched Tuple2 from the input DataSet._@return a new Graph, where the vertex values have been updated according to the_result of the vertexJoinFunction.__@param <T> the type of the second field of the input Tuple2 DataSet.;public <T> Graph<K, VV, EV> joinWithVertices(DataSet<Tuple2<K, T>> inputDataSet, _			final VertexJoinFunction<VV, T> vertexJoinFunction) {__		DataSet<Vertex<K, VV>> resultedVertices = this.getVertices()_				.coGroup(inputDataSet).where(0).equalTo(0)_				.with(new ApplyCoGroupToVertexValues<K, VV, T>(vertexJoinFunction))__		return new Graph<K, VV, EV>(resultedVertices, this.edges, this.context)__	};joins,the,vertex,data,set,of,this,graph,with,an,input,tuple2,data,set,and,applies,a,user,defined,transformation,on,the,values,of,the,matched,records,the,vertex,id,and,the,first,field,of,the,tuple2,data,set,are,used,as,the,join,keys,param,input,data,set,the,tuple2,data,set,to,join,with,the,first,field,of,the,tuple2,is,used,as,the,join,key,and,the,second,field,is,passed,as,a,parameter,to,the,transformation,function,param,vertex,join,function,the,transformation,function,to,apply,the,first,parameter,is,the,current,vertex,value,and,the,second,parameter,is,the,value,of,the,matched,tuple2,from,the,input,data,set,return,a,new,graph,where,the,vertex,values,have,been,updated,according,to,the,result,of,the,vertex,join,function,param,t,the,type,of,the,second,field,of,the,input,tuple2,data,set;public,t,graph,k,vv,ev,join,with,vertices,data,set,tuple2,k,t,input,data,set,final,vertex,join,function,vv,t,vertex,join,function,data,set,vertex,k,vv,resulted,vertices,this,get,vertices,co,group,input,data,set,where,0,equal,to,0,with,new,apply,co,group,to,vertex,values,k,vv,t,vertex,join,function,return,new,graph,k,vv,ev,resulted,vertices,this,edges,this,context
Graph -> public <T> Graph<K, VV, EV> joinWithVertices(DataSet<Tuple2<K, T>> inputDataSet,  			final VertexJoinFunction<VV, T> vertexJoinFunction);1465316775;Joins the vertex DataSet of this graph with an input Tuple2 DataSet and applies_a user-defined transformation on the values of the matched records._The vertex ID and the first field of the Tuple2 DataSet are used as the join keys.__@param inputDataSet the Tuple2 DataSet to join with._The first field of the Tuple2 is used as the join key and the second field is passed_as a parameter to the transformation function._@param vertexJoinFunction the transformation function to apply._The first parameter is the current vertex value and the second parameter is the value_of the matched Tuple2 from the input DataSet._@return a new Graph, where the vertex values have been updated according to the_result of the vertexJoinFunction.__@param <T> the type of the second field of the input Tuple2 DataSet.;public <T> Graph<K, VV, EV> joinWithVertices(DataSet<Tuple2<K, T>> inputDataSet, _			final VertexJoinFunction<VV, T> vertexJoinFunction) {__		DataSet<Vertex<K, VV>> resultedVertices = this.getVertices()_				.coGroup(inputDataSet).where(0).equalTo(0)_				.with(new ApplyCoGroupToVertexValues<K, VV, T>(vertexJoinFunction))__		return new Graph<K, VV, EV>(resultedVertices, this.edges, this.context)__	};joins,the,vertex,data,set,of,this,graph,with,an,input,tuple2,data,set,and,applies,a,user,defined,transformation,on,the,values,of,the,matched,records,the,vertex,id,and,the,first,field,of,the,tuple2,data,set,are,used,as,the,join,keys,param,input,data,set,the,tuple2,data,set,to,join,with,the,first,field,of,the,tuple2,is,used,as,the,join,key,and,the,second,field,is,passed,as,a,parameter,to,the,transformation,function,param,vertex,join,function,the,transformation,function,to,apply,the,first,parameter,is,the,current,vertex,value,and,the,second,parameter,is,the,value,of,the,matched,tuple2,from,the,input,data,set,return,a,new,graph,where,the,vertex,values,have,been,updated,according,to,the,result,of,the,vertex,join,function,param,t,the,type,of,the,second,field,of,the,input,tuple2,data,set;public,t,graph,k,vv,ev,join,with,vertices,data,set,tuple2,k,t,input,data,set,final,vertex,join,function,vv,t,vertex,join,function,data,set,vertex,k,vv,resulted,vertices,this,get,vertices,co,group,input,data,set,where,0,equal,to,0,with,new,apply,co,group,to,vertex,values,k,vv,t,vertex,join,function,return,new,graph,k,vv,ev,resulted,vertices,this,edges,this,context
Graph -> public <T> Graph<K, VV, EV> joinWithVertices(DataSet<Tuple2<K, T>> inputDataSet,  			final VertexJoinFunction<VV, T> vertexJoinFunction);1466789678;Joins the vertex DataSet of this graph with an input Tuple2 DataSet and applies_a user-defined transformation on the values of the matched records._The vertex ID and the first field of the Tuple2 DataSet are used as the join keys.__@param inputDataSet the Tuple2 DataSet to join with._The first field of the Tuple2 is used as the join key and the second field is passed_as a parameter to the transformation function._@param vertexJoinFunction the transformation function to apply._The first parameter is the current vertex value and the second parameter is the value_of the matched Tuple2 from the input DataSet._@return a new Graph, where the vertex values have been updated according to the_result of the vertexJoinFunction.__@param <T> the type of the second field of the input Tuple2 DataSet.;public <T> Graph<K, VV, EV> joinWithVertices(DataSet<Tuple2<K, T>> inputDataSet, _			final VertexJoinFunction<VV, T> vertexJoinFunction) {__		DataSet<Vertex<K, VV>> resultedVertices = this.getVertices()_				.coGroup(inputDataSet).where(0).equalTo(0)_				.with(new ApplyCoGroupToVertexValues<K, VV, T>(vertexJoinFunction))__		return new Graph<K, VV, EV>(resultedVertices, this.edges, this.context)__	};joins,the,vertex,data,set,of,this,graph,with,an,input,tuple2,data,set,and,applies,a,user,defined,transformation,on,the,values,of,the,matched,records,the,vertex,id,and,the,first,field,of,the,tuple2,data,set,are,used,as,the,join,keys,param,input,data,set,the,tuple2,data,set,to,join,with,the,first,field,of,the,tuple2,is,used,as,the,join,key,and,the,second,field,is,passed,as,a,parameter,to,the,transformation,function,param,vertex,join,function,the,transformation,function,to,apply,the,first,parameter,is,the,current,vertex,value,and,the,second,parameter,is,the,value,of,the,matched,tuple2,from,the,input,data,set,return,a,new,graph,where,the,vertex,values,have,been,updated,according,to,the,result,of,the,vertex,join,function,param,t,the,type,of,the,second,field,of,the,input,tuple2,data,set;public,t,graph,k,vv,ev,join,with,vertices,data,set,tuple2,k,t,input,data,set,final,vertex,join,function,vv,t,vertex,join,function,data,set,vertex,k,vv,resulted,vertices,this,get,vertices,co,group,input,data,set,where,0,equal,to,0,with,new,apply,co,group,to,vertex,values,k,vv,t,vertex,join,function,return,new,graph,k,vv,ev,resulted,vertices,this,edges,this,context
Graph -> public <T> Graph<K, VV, EV> joinWithVertices(DataSet<Tuple2<K, T>> inputDataSet,  			final VertexJoinFunction<VV, T> vertexJoinFunction);1467140656;Joins the vertex DataSet of this graph with an input Tuple2 DataSet and applies_a user-defined transformation on the values of the matched records._The vertex ID and the first field of the Tuple2 DataSet are used as the join keys.__@param inputDataSet the Tuple2 DataSet to join with._The first field of the Tuple2 is used as the join key and the second field is passed_as a parameter to the transformation function._@param vertexJoinFunction the transformation function to apply._The first parameter is the current vertex value and the second parameter is the value_of the matched Tuple2 from the input DataSet._@return a new Graph, where the vertex values have been updated according to the_result of the vertexJoinFunction.__@param <T> the type of the second field of the input Tuple2 DataSet.;public <T> Graph<K, VV, EV> joinWithVertices(DataSet<Tuple2<K, T>> inputDataSet, _			final VertexJoinFunction<VV, T> vertexJoinFunction) {__		DataSet<Vertex<K, VV>> resultedVertices = this.getVertices()_				.coGroup(inputDataSet).where(0).equalTo(0)_				.with(new ApplyCoGroupToVertexValues<K, VV, T>(vertexJoinFunction))__		return new Graph<K, VV, EV>(resultedVertices, this.edges, this.context)__	};joins,the,vertex,data,set,of,this,graph,with,an,input,tuple2,data,set,and,applies,a,user,defined,transformation,on,the,values,of,the,matched,records,the,vertex,id,and,the,first,field,of,the,tuple2,data,set,are,used,as,the,join,keys,param,input,data,set,the,tuple2,data,set,to,join,with,the,first,field,of,the,tuple2,is,used,as,the,join,key,and,the,second,field,is,passed,as,a,parameter,to,the,transformation,function,param,vertex,join,function,the,transformation,function,to,apply,the,first,parameter,is,the,current,vertex,value,and,the,second,parameter,is,the,value,of,the,matched,tuple2,from,the,input,data,set,return,a,new,graph,where,the,vertex,values,have,been,updated,according,to,the,result,of,the,vertex,join,function,param,t,the,type,of,the,second,field,of,the,input,tuple2,data,set;public,t,graph,k,vv,ev,join,with,vertices,data,set,tuple2,k,t,input,data,set,final,vertex,join,function,vv,t,vertex,join,function,data,set,vertex,k,vv,resulted,vertices,this,get,vertices,co,group,input,data,set,where,0,equal,to,0,with,new,apply,co,group,to,vertex,values,k,vv,t,vertex,join,function,return,new,graph,k,vv,ev,resulted,vertices,this,edges,this,context
Graph -> public <T> Graph<K, VV, EV> joinWithVertices(DataSet<Tuple2<K, T>> inputDataSet,  			final VertexJoinFunction<VV, T> vertexJoinFunction);1467306272;Joins the vertex DataSet of this graph with an input Tuple2 DataSet and applies_a user-defined transformation on the values of the matched records._The vertex ID and the first field of the Tuple2 DataSet are used as the join keys.__@param inputDataSet the Tuple2 DataSet to join with._The first field of the Tuple2 is used as the join key and the second field is passed_as a parameter to the transformation function._@param vertexJoinFunction the transformation function to apply._The first parameter is the current vertex value and the second parameter is the value_of the matched Tuple2 from the input DataSet._@return a new Graph, where the vertex values have been updated according to the_result of the vertexJoinFunction.__@param <T> the type of the second field of the input Tuple2 DataSet.;public <T> Graph<K, VV, EV> joinWithVertices(DataSet<Tuple2<K, T>> inputDataSet, _			final VertexJoinFunction<VV, T> vertexJoinFunction) {__		DataSet<Vertex<K, VV>> resultedVertices = this.getVertices()_				.coGroup(inputDataSet).where(0).equalTo(0)_				.with(new ApplyCoGroupToVertexValues<K, VV, T>(vertexJoinFunction))__		return new Graph<K, VV, EV>(resultedVertices, this.edges, this.context)__	};joins,the,vertex,data,set,of,this,graph,with,an,input,tuple2,data,set,and,applies,a,user,defined,transformation,on,the,values,of,the,matched,records,the,vertex,id,and,the,first,field,of,the,tuple2,data,set,are,used,as,the,join,keys,param,input,data,set,the,tuple2,data,set,to,join,with,the,first,field,of,the,tuple2,is,used,as,the,join,key,and,the,second,field,is,passed,as,a,parameter,to,the,transformation,function,param,vertex,join,function,the,transformation,function,to,apply,the,first,parameter,is,the,current,vertex,value,and,the,second,parameter,is,the,value,of,the,matched,tuple2,from,the,input,data,set,return,a,new,graph,where,the,vertex,values,have,been,updated,according,to,the,result,of,the,vertex,join,function,param,t,the,type,of,the,second,field,of,the,input,tuple2,data,set;public,t,graph,k,vv,ev,join,with,vertices,data,set,tuple2,k,t,input,data,set,final,vertex,join,function,vv,t,vertex,join,function,data,set,vertex,k,vv,resulted,vertices,this,get,vertices,co,group,input,data,set,where,0,equal,to,0,with,new,apply,co,group,to,vertex,values,k,vv,t,vertex,join,function,return,new,graph,k,vv,ev,resulted,vertices,this,edges,this,context
Graph -> public <T> Graph<K, VV, EV> joinWithVertices(DataSet<Tuple2<K, T>> inputDataSet,  			final VertexJoinFunction<VV, T> vertexJoinFunction);1470042815;Joins the vertex DataSet of this graph with an input Tuple2 DataSet and applies_a user-defined transformation on the values of the matched records._The vertex ID and the first field of the Tuple2 DataSet are used as the join keys.__@param inputDataSet the Tuple2 DataSet to join with._The first field of the Tuple2 is used as the join key and the second field is passed_as a parameter to the transformation function._@param vertexJoinFunction the transformation function to apply._The first parameter is the current vertex value and the second parameter is the value_of the matched Tuple2 from the input DataSet._@return a new Graph, where the vertex values have been updated according to the_result of the vertexJoinFunction.__@param <T> the type of the second field of the input Tuple2 DataSet.;public <T> Graph<K, VV, EV> joinWithVertices(DataSet<Tuple2<K, T>> inputDataSet, _			final VertexJoinFunction<VV, T> vertexJoinFunction) {__		DataSet<Vertex<K, VV>> resultedVertices = this.getVertices()_				.coGroup(inputDataSet).where(0).equalTo(0)_				.with(new ApplyCoGroupToVertexValues<K, VV, T>(vertexJoinFunction))__		return new Graph<K, VV, EV>(resultedVertices, this.edges, this.context)__	};joins,the,vertex,data,set,of,this,graph,with,an,input,tuple2,data,set,and,applies,a,user,defined,transformation,on,the,values,of,the,matched,records,the,vertex,id,and,the,first,field,of,the,tuple2,data,set,are,used,as,the,join,keys,param,input,data,set,the,tuple2,data,set,to,join,with,the,first,field,of,the,tuple2,is,used,as,the,join,key,and,the,second,field,is,passed,as,a,parameter,to,the,transformation,function,param,vertex,join,function,the,transformation,function,to,apply,the,first,parameter,is,the,current,vertex,value,and,the,second,parameter,is,the,value,of,the,matched,tuple2,from,the,input,data,set,return,a,new,graph,where,the,vertex,values,have,been,updated,according,to,the,result,of,the,vertex,join,function,param,t,the,type,of,the,second,field,of,the,input,tuple2,data,set;public,t,graph,k,vv,ev,join,with,vertices,data,set,tuple2,k,t,input,data,set,final,vertex,join,function,vv,t,vertex,join,function,data,set,vertex,k,vv,resulted,vertices,this,get,vertices,co,group,input,data,set,where,0,equal,to,0,with,new,apply,co,group,to,vertex,values,k,vv,t,vertex,join,function,return,new,graph,k,vv,ev,resulted,vertices,this,edges,this,context
Graph -> public <T> Graph<K, VV, EV> joinWithVertices(DataSet<Tuple2<K, T>> inputDataSet,  			final VertexJoinFunction<VV, T> vertexJoinFunction);1475684776;Joins the vertex DataSet of this graph with an input Tuple2 DataSet and applies_a user-defined transformation on the values of the matched records._The vertex ID and the first field of the Tuple2 DataSet are used as the join keys.__@param inputDataSet the Tuple2 DataSet to join with._The first field of the Tuple2 is used as the join key and the second field is passed_as a parameter to the transformation function._@param vertexJoinFunction the transformation function to apply._The first parameter is the current vertex value and the second parameter is the value_of the matched Tuple2 from the input DataSet._@return a new Graph, where the vertex values have been updated according to the_result of the vertexJoinFunction.__@param <T> the type of the second field of the input Tuple2 DataSet.;public <T> Graph<K, VV, EV> joinWithVertices(DataSet<Tuple2<K, T>> inputDataSet, _			final VertexJoinFunction<VV, T> vertexJoinFunction) {__		DataSet<Vertex<K, VV>> resultedVertices = this.getVertices()_				.coGroup(inputDataSet).where(0).equalTo(0)_				.with(new ApplyCoGroupToVertexValues<K, VV, T>(vertexJoinFunction))__		return new Graph<>(resultedVertices, this.edges, this.context)__	};joins,the,vertex,data,set,of,this,graph,with,an,input,tuple2,data,set,and,applies,a,user,defined,transformation,on,the,values,of,the,matched,records,the,vertex,id,and,the,first,field,of,the,tuple2,data,set,are,used,as,the,join,keys,param,input,data,set,the,tuple2,data,set,to,join,with,the,first,field,of,the,tuple2,is,used,as,the,join,key,and,the,second,field,is,passed,as,a,parameter,to,the,transformation,function,param,vertex,join,function,the,transformation,function,to,apply,the,first,parameter,is,the,current,vertex,value,and,the,second,parameter,is,the,value,of,the,matched,tuple2,from,the,input,data,set,return,a,new,graph,where,the,vertex,values,have,been,updated,according,to,the,result,of,the,vertex,join,function,param,t,the,type,of,the,second,field,of,the,input,tuple2,data,set;public,t,graph,k,vv,ev,join,with,vertices,data,set,tuple2,k,t,input,data,set,final,vertex,join,function,vv,t,vertex,join,function,data,set,vertex,k,vv,resulted,vertices,this,get,vertices,co,group,input,data,set,where,0,equal,to,0,with,new,apply,co,group,to,vertex,values,k,vv,t,vertex,join,function,return,new,graph,resulted,vertices,this,edges,this,context
Graph -> public <T> Graph<K, VV, EV> joinWithVertices(DataSet<Tuple2<K, T>> inputDataSet,  			final VertexJoinFunction<VV, T> vertexJoinFunction);1475685606;Joins the vertex DataSet of this graph with an input Tuple2 DataSet and applies_a user-defined transformation on the values of the matched records._The vertex ID and the first field of the Tuple2 DataSet are used as the join keys.__@param inputDataSet the Tuple2 DataSet to join with._The first field of the Tuple2 is used as the join key and the second field is passed_as a parameter to the transformation function._@param vertexJoinFunction the transformation function to apply._The first parameter is the current vertex value and the second parameter is the value_of the matched Tuple2 from the input DataSet._@return a new Graph, where the vertex values have been updated according to the_result of the vertexJoinFunction.__@param <T> the type of the second field of the input Tuple2 DataSet.;public <T> Graph<K, VV, EV> joinWithVertices(DataSet<Tuple2<K, T>> inputDataSet, _			final VertexJoinFunction<VV, T> vertexJoinFunction) {__		DataSet<Vertex<K, VV>> resultedVertices = this.getVertices()_				.coGroup(inputDataSet).where(0).equalTo(0)_				.with(new ApplyCoGroupToVertexValues<K, VV, T>(vertexJoinFunction))__		return new Graph<>(resultedVertices, this.edges, this.context)__	};joins,the,vertex,data,set,of,this,graph,with,an,input,tuple2,data,set,and,applies,a,user,defined,transformation,on,the,values,of,the,matched,records,the,vertex,id,and,the,first,field,of,the,tuple2,data,set,are,used,as,the,join,keys,param,input,data,set,the,tuple2,data,set,to,join,with,the,first,field,of,the,tuple2,is,used,as,the,join,key,and,the,second,field,is,passed,as,a,parameter,to,the,transformation,function,param,vertex,join,function,the,transformation,function,to,apply,the,first,parameter,is,the,current,vertex,value,and,the,second,parameter,is,the,value,of,the,matched,tuple2,from,the,input,data,set,return,a,new,graph,where,the,vertex,values,have,been,updated,according,to,the,result,of,the,vertex,join,function,param,t,the,type,of,the,second,field,of,the,input,tuple2,data,set;public,t,graph,k,vv,ev,join,with,vertices,data,set,tuple2,k,t,input,data,set,final,vertex,join,function,vv,t,vertex,join,function,data,set,vertex,k,vv,resulted,vertices,this,get,vertices,co,group,input,data,set,where,0,equal,to,0,with,new,apply,co,group,to,vertex,values,k,vv,t,vertex,join,function,return,new,graph,resulted,vertices,this,edges,this,context
Graph -> public <T> Graph<K, VV, EV> joinWithVertices(DataSet<Tuple2<K, T>> inputDataSet,  			final VertexJoinFunction<VV, T> vertexJoinFunction);1481745825;Joins the vertex DataSet of this graph with an input Tuple2 DataSet and applies_a user-defined transformation on the values of the matched records._The vertex ID and the first field of the Tuple2 DataSet are used as the join keys.__@param inputDataSet the Tuple2 DataSet to join with._The first field of the Tuple2 is used as the join key and the second field is passed_as a parameter to the transformation function._@param vertexJoinFunction the transformation function to apply._The first parameter is the current vertex value and the second parameter is the value_of the matched Tuple2 from the input DataSet._@return a new Graph, where the vertex values have been updated according to the_result of the vertexJoinFunction.__@param <T> the type of the second field of the input Tuple2 DataSet.;public <T> Graph<K, VV, EV> joinWithVertices(DataSet<Tuple2<K, T>> inputDataSet, _			final VertexJoinFunction<VV, T> vertexJoinFunction) {__		DataSet<Vertex<K, VV>> resultedVertices = this.getVertices()_				.coGroup(inputDataSet).where(0).equalTo(0)_				.with(new ApplyCoGroupToVertexValues<K, VV, T>(vertexJoinFunction))_					.name("Join with vertices")__		return new Graph<>(resultedVertices, this.edges, this.context)__	};joins,the,vertex,data,set,of,this,graph,with,an,input,tuple2,data,set,and,applies,a,user,defined,transformation,on,the,values,of,the,matched,records,the,vertex,id,and,the,first,field,of,the,tuple2,data,set,are,used,as,the,join,keys,param,input,data,set,the,tuple2,data,set,to,join,with,the,first,field,of,the,tuple2,is,used,as,the,join,key,and,the,second,field,is,passed,as,a,parameter,to,the,transformation,function,param,vertex,join,function,the,transformation,function,to,apply,the,first,parameter,is,the,current,vertex,value,and,the,second,parameter,is,the,value,of,the,matched,tuple2,from,the,input,data,set,return,a,new,graph,where,the,vertex,values,have,been,updated,according,to,the,result,of,the,vertex,join,function,param,t,the,type,of,the,second,field,of,the,input,tuple2,data,set;public,t,graph,k,vv,ev,join,with,vertices,data,set,tuple2,k,t,input,data,set,final,vertex,join,function,vv,t,vertex,join,function,data,set,vertex,k,vv,resulted,vertices,this,get,vertices,co,group,input,data,set,where,0,equal,to,0,with,new,apply,co,group,to,vertex,values,k,vv,t,vertex,join,function,name,join,with,vertices,return,new,graph,resulted,vertices,this,edges,this,context
Graph -> public <T> Graph<K, VV, EV> joinWithVertices(DataSet<Tuple2<K, T>> inputDataSet,  			final VertexJoinFunction<VV, T> vertexJoinFunction);1481881009;Joins the vertex DataSet of this graph with an input Tuple2 DataSet and applies_a user-defined transformation on the values of the matched records._The vertex ID and the first field of the Tuple2 DataSet are used as the join keys.__@param inputDataSet the Tuple2 DataSet to join with._The first field of the Tuple2 is used as the join key and the second field is passed_as a parameter to the transformation function._@param vertexJoinFunction the transformation function to apply._The first parameter is the current vertex value and the second parameter is the value_of the matched Tuple2 from the input DataSet._@return a new Graph, where the vertex values have been updated according to the_result of the vertexJoinFunction.__@param <T> the type of the second field of the input Tuple2 DataSet.;public <T> Graph<K, VV, EV> joinWithVertices(DataSet<Tuple2<K, T>> inputDataSet, _			final VertexJoinFunction<VV, T> vertexJoinFunction) {__		DataSet<Vertex<K, VV>> resultedVertices = this.getVertices()_				.coGroup(inputDataSet).where(0).equalTo(0)_				.with(new ApplyCoGroupToVertexValues<K, VV, T>(vertexJoinFunction))_					.name("Join with vertices")__		return new Graph<>(resultedVertices, this.edges, this.context)__	};joins,the,vertex,data,set,of,this,graph,with,an,input,tuple2,data,set,and,applies,a,user,defined,transformation,on,the,values,of,the,matched,records,the,vertex,id,and,the,first,field,of,the,tuple2,data,set,are,used,as,the,join,keys,param,input,data,set,the,tuple2,data,set,to,join,with,the,first,field,of,the,tuple2,is,used,as,the,join,key,and,the,second,field,is,passed,as,a,parameter,to,the,transformation,function,param,vertex,join,function,the,transformation,function,to,apply,the,first,parameter,is,the,current,vertex,value,and,the,second,parameter,is,the,value,of,the,matched,tuple2,from,the,input,data,set,return,a,new,graph,where,the,vertex,values,have,been,updated,according,to,the,result,of,the,vertex,join,function,param,t,the,type,of,the,second,field,of,the,input,tuple2,data,set;public,t,graph,k,vv,ev,join,with,vertices,data,set,tuple2,k,t,input,data,set,final,vertex,join,function,vv,t,vertex,join,function,data,set,vertex,k,vv,resulted,vertices,this,get,vertices,co,group,input,data,set,where,0,equal,to,0,with,new,apply,co,group,to,vertex,values,k,vv,t,vertex,join,function,name,join,with,vertices,return,new,graph,resulted,vertices,this,edges,this,context
Graph -> public <T> Graph<K, VV, EV> joinWithVertices(DataSet<Tuple2<K, T>> inputDataSet,  			final VertexJoinFunction<VV, T> vertexJoinFunction);1484160227;Joins the vertex DataSet of this graph with an input Tuple2 DataSet and applies_a user-defined transformation on the values of the matched records._The vertex ID and the first field of the Tuple2 DataSet are used as the join keys.__@param inputDataSet the Tuple2 DataSet to join with._The first field of the Tuple2 is used as the join key and the second field is passed_as a parameter to the transformation function._@param vertexJoinFunction the transformation function to apply._The first parameter is the current vertex value and the second parameter is the value_of the matched Tuple2 from the input DataSet._@return a new Graph, where the vertex values have been updated according to the_result of the vertexJoinFunction.__@param <T> the type of the second field of the input Tuple2 DataSet.;public <T> Graph<K, VV, EV> joinWithVertices(DataSet<Tuple2<K, T>> inputDataSet, _			final VertexJoinFunction<VV, T> vertexJoinFunction) {__		DataSet<Vertex<K, VV>> resultedVertices = this.getVertices()_				.coGroup(inputDataSet).where(0).equalTo(0)_				.with(new ApplyCoGroupToVertexValues<K, VV, T>(vertexJoinFunction))_					.name("Join with vertices")__		return new Graph<>(resultedVertices, this.edges, this.context)__	};joins,the,vertex,data,set,of,this,graph,with,an,input,tuple2,data,set,and,applies,a,user,defined,transformation,on,the,values,of,the,matched,records,the,vertex,id,and,the,first,field,of,the,tuple2,data,set,are,used,as,the,join,keys,param,input,data,set,the,tuple2,data,set,to,join,with,the,first,field,of,the,tuple2,is,used,as,the,join,key,and,the,second,field,is,passed,as,a,parameter,to,the,transformation,function,param,vertex,join,function,the,transformation,function,to,apply,the,first,parameter,is,the,current,vertex,value,and,the,second,parameter,is,the,value,of,the,matched,tuple2,from,the,input,data,set,return,a,new,graph,where,the,vertex,values,have,been,updated,according,to,the,result,of,the,vertex,join,function,param,t,the,type,of,the,second,field,of,the,input,tuple2,data,set;public,t,graph,k,vv,ev,join,with,vertices,data,set,tuple2,k,t,input,data,set,final,vertex,join,function,vv,t,vertex,join,function,data,set,vertex,k,vv,resulted,vertices,this,get,vertices,co,group,input,data,set,where,0,equal,to,0,with,new,apply,co,group,to,vertex,values,k,vv,t,vertex,join,function,name,join,with,vertices,return,new,graph,resulted,vertices,this,edges,this,context
Graph -> public <T> Graph<K, VV, EV> joinWithVertices(DataSet<Tuple2<K, T>> inputDataSet,  			final VertexJoinFunction<VV, T> vertexJoinFunction);1484685504;Joins the vertex DataSet of this graph with an input Tuple2 DataSet and applies_a user-defined transformation on the values of the matched records._The vertex ID and the first field of the Tuple2 DataSet are used as the join keys.__@param inputDataSet the Tuple2 DataSet to join with._The first field of the Tuple2 is used as the join key and the second field is passed_as a parameter to the transformation function._@param vertexJoinFunction the transformation function to apply._The first parameter is the current vertex value and the second parameter is the value_of the matched Tuple2 from the input DataSet._@return a new Graph, where the vertex values have been updated according to the_result of the vertexJoinFunction.__@param <T> the type of the second field of the input Tuple2 DataSet.;public <T> Graph<K, VV, EV> joinWithVertices(DataSet<Tuple2<K, T>> inputDataSet, _			final VertexJoinFunction<VV, T> vertexJoinFunction) {__		DataSet<Vertex<K, VV>> resultedVertices = this.getVertices()_				.coGroup(inputDataSet).where(0).equalTo(0)_				.with(new ApplyCoGroupToVertexValues<K, VV, T>(vertexJoinFunction))_					.name("Join with vertices")__		return new Graph<>(resultedVertices, this.edges, this.context)__	};joins,the,vertex,data,set,of,this,graph,with,an,input,tuple2,data,set,and,applies,a,user,defined,transformation,on,the,values,of,the,matched,records,the,vertex,id,and,the,first,field,of,the,tuple2,data,set,are,used,as,the,join,keys,param,input,data,set,the,tuple2,data,set,to,join,with,the,first,field,of,the,tuple2,is,used,as,the,join,key,and,the,second,field,is,passed,as,a,parameter,to,the,transformation,function,param,vertex,join,function,the,transformation,function,to,apply,the,first,parameter,is,the,current,vertex,value,and,the,second,parameter,is,the,value,of,the,matched,tuple2,from,the,input,data,set,return,a,new,graph,where,the,vertex,values,have,been,updated,according,to,the,result,of,the,vertex,join,function,param,t,the,type,of,the,second,field,of,the,input,tuple2,data,set;public,t,graph,k,vv,ev,join,with,vertices,data,set,tuple2,k,t,input,data,set,final,vertex,join,function,vv,t,vertex,join,function,data,set,vertex,k,vv,resulted,vertices,this,get,vertices,co,group,input,data,set,where,0,equal,to,0,with,new,apply,co,group,to,vertex,values,k,vv,t,vertex,join,function,name,join,with,vertices,return,new,graph,resulted,vertices,this,edges,this,context
Graph -> public <T> Graph<K, VV, EV> joinWithVertices(DataSet<Tuple2<K, T>> inputDataSet,  			final VertexJoinFunction<VV, T> vertexJoinFunction);1489068942;Joins the vertex DataSet of this graph with an input Tuple2 DataSet and applies_a user-defined transformation on the values of the matched records._The vertex ID and the first field of the Tuple2 DataSet are used as the join keys.__@param inputDataSet the Tuple2 DataSet to join with._The first field of the Tuple2 is used as the join key and the second field is passed_as a parameter to the transformation function._@param vertexJoinFunction the transformation function to apply._The first parameter is the current vertex value and the second parameter is the value_of the matched Tuple2 from the input DataSet._@return a new Graph, where the vertex values have been updated according to the_result of the vertexJoinFunction.__@param <T> the type of the second field of the input Tuple2 DataSet.;public <T> Graph<K, VV, EV> joinWithVertices(DataSet<Tuple2<K, T>> inputDataSet, _			final VertexJoinFunction<VV, T> vertexJoinFunction) {__		DataSet<Vertex<K, VV>> resultedVertices = this.getVertices()_				.coGroup(inputDataSet).where(0).equalTo(0)_				.with(new ApplyCoGroupToVertexValues<K, VV, T>(vertexJoinFunction))_					.name("Join with vertices")__		return new Graph<>(resultedVertices, this.edges, this.context)__	};joins,the,vertex,data,set,of,this,graph,with,an,input,tuple2,data,set,and,applies,a,user,defined,transformation,on,the,values,of,the,matched,records,the,vertex,id,and,the,first,field,of,the,tuple2,data,set,are,used,as,the,join,keys,param,input,data,set,the,tuple2,data,set,to,join,with,the,first,field,of,the,tuple2,is,used,as,the,join,key,and,the,second,field,is,passed,as,a,parameter,to,the,transformation,function,param,vertex,join,function,the,transformation,function,to,apply,the,first,parameter,is,the,current,vertex,value,and,the,second,parameter,is,the,value,of,the,matched,tuple2,from,the,input,data,set,return,a,new,graph,where,the,vertex,values,have,been,updated,according,to,the,result,of,the,vertex,join,function,param,t,the,type,of,the,second,field,of,the,input,tuple2,data,set;public,t,graph,k,vv,ev,join,with,vertices,data,set,tuple2,k,t,input,data,set,final,vertex,join,function,vv,t,vertex,join,function,data,set,vertex,k,vv,resulted,vertices,this,get,vertices,co,group,input,data,set,where,0,equal,to,0,with,new,apply,co,group,to,vertex,values,k,vv,t,vertex,join,function,name,join,with,vertices,return,new,graph,resulted,vertices,this,edges,this,context
Graph -> public <T> Graph<K, VV, EV> joinWithVertices(DataSet<Tuple2<K, T>> inputDataSet,  			final VertexJoinFunction<VV, T> vertexJoinFunction);1490973446;Joins the vertex DataSet of this graph with an input Tuple2 DataSet and applies_a user-defined transformation on the values of the matched records._The vertex ID and the first field of the Tuple2 DataSet are used as the join keys.__@param inputDataSet the Tuple2 DataSet to join with._The first field of the Tuple2 is used as the join key and the second field is passed_as a parameter to the transformation function._@param vertexJoinFunction the transformation function to apply._The first parameter is the current vertex value and the second parameter is the value_of the matched Tuple2 from the input DataSet._@return a new Graph, where the vertex values have been updated according to the_result of the vertexJoinFunction.__@param <T> the type of the second field of the input Tuple2 DataSet.;public <T> Graph<K, VV, EV> joinWithVertices(DataSet<Tuple2<K, T>> inputDataSet, _			final VertexJoinFunction<VV, T> vertexJoinFunction) {__		DataSet<Vertex<K, VV>> resultedVertices = this.getVertices()_				.coGroup(inputDataSet).where(0).equalTo(0)_				.with(new ApplyCoGroupToVertexValues<K, VV, T>(vertexJoinFunction))_					.name("Join with vertices")__		return new Graph<>(resultedVertices, this.edges, this.context)__	};joins,the,vertex,data,set,of,this,graph,with,an,input,tuple2,data,set,and,applies,a,user,defined,transformation,on,the,values,of,the,matched,records,the,vertex,id,and,the,first,field,of,the,tuple2,data,set,are,used,as,the,join,keys,param,input,data,set,the,tuple2,data,set,to,join,with,the,first,field,of,the,tuple2,is,used,as,the,join,key,and,the,second,field,is,passed,as,a,parameter,to,the,transformation,function,param,vertex,join,function,the,transformation,function,to,apply,the,first,parameter,is,the,current,vertex,value,and,the,second,parameter,is,the,value,of,the,matched,tuple2,from,the,input,data,set,return,a,new,graph,where,the,vertex,values,have,been,updated,according,to,the,result,of,the,vertex,join,function,param,t,the,type,of,the,second,field,of,the,input,tuple2,data,set;public,t,graph,k,vv,ev,join,with,vertices,data,set,tuple2,k,t,input,data,set,final,vertex,join,function,vv,t,vertex,join,function,data,set,vertex,k,vv,resulted,vertices,this,get,vertices,co,group,input,data,set,where,0,equal,to,0,with,new,apply,co,group,to,vertex,values,k,vv,t,vertex,join,function,name,join,with,vertices,return,new,graph,resulted,vertices,this,edges,this,context
Graph -> public DataSet<Tuple2<K, Long>> inDegrees();1444404795;Return the in-degree of all vertices in the graph__@return A DataSet of Tuple2<vertexId, inDegree>;public DataSet<Tuple2<K, Long>> inDegrees() {__		return vertices.coGroup(edges).where(0).equalTo(1).with(new CountNeighborsCoGroup<K, VV, EV>())__	};return,the,in,degree,of,all,vertices,in,the,graph,return,a,data,set,of,tuple2,vertex,id,in,degree;public,data,set,tuple2,k,long,in,degrees,return,vertices,co,group,edges,where,0,equal,to,1,with,new,count,neighbors,co,group,k,vv,ev
Graph -> public DataSet<Tuple2<K, Long>> inDegrees();1445261977;Return the in-degree of all vertices in the graph__@return A DataSet of Tuple2<vertexId, inDegree>;public DataSet<Tuple2<K, Long>> inDegrees() {__		return vertices.coGroup(edges).where(0).equalTo(1).with(new CountNeighborsCoGroup<K, VV, EV>())__	};return,the,in,degree,of,all,vertices,in,the,graph,return,a,data,set,of,tuple2,vertex,id,in,degree;public,data,set,tuple2,k,long,in,degrees,return,vertices,co,group,edges,where,0,equal,to,1,with,new,count,neighbors,co,group,k,vv,ev
Graph -> public DataSet<Tuple2<K, Long>> inDegrees();1445854323;Return the in-degree of all vertices in the graph__@return A DataSet of Tuple2<vertexId, inDegree>;public DataSet<Tuple2<K, Long>> inDegrees() {__		return vertices.coGroup(edges).where(0).equalTo(1).with(new CountNeighborsCoGroup<K, VV, EV>())__	};return,the,in,degree,of,all,vertices,in,the,graph,return,a,data,set,of,tuple2,vertex,id,in,degree;public,data,set,tuple2,k,long,in,degrees,return,vertices,co,group,edges,where,0,equal,to,1,with,new,count,neighbors,co,group,k,vv,ev
Graph -> public DataSet<Tuple2<K, Long>> inDegrees();1446112342;Return the in-degree of all vertices in the graph__@return A DataSet of {@code Tuple2<vertexId, inDegree>};public DataSet<Tuple2<K, Long>> inDegrees() {__		return vertices.coGroup(edges).where(0).equalTo(1).with(new CountNeighborsCoGroup<K, VV, EV>())__	};return,the,in,degree,of,all,vertices,in,the,graph,return,a,data,set,of,code,tuple2,vertex,id,in,degree;public,data,set,tuple2,k,long,in,degrees,return,vertices,co,group,edges,where,0,equal,to,1,with,new,count,neighbors,co,group,k,vv,ev
Graph -> public DataSet<Tuple2<K, Long>> inDegrees();1447073368;Return the in-degree of all vertices in the graph__@return A DataSet of {@code Tuple2<vertexId, inDegree>};public DataSet<Tuple2<K, Long>> inDegrees() {__		return vertices.coGroup(edges).where(0).equalTo(1).with(new CountNeighborsCoGroup<K, VV, EV>())__	};return,the,in,degree,of,all,vertices,in,the,graph,return,a,data,set,of,code,tuple2,vertex,id,in,degree;public,data,set,tuple2,k,long,in,degrees,return,vertices,co,group,edges,where,0,equal,to,1,with,new,count,neighbors,co,group,k,vv,ev
Graph -> public DataSet<Tuple2<K, Long>> inDegrees();1454404649;Return the in-degree of all vertices in the graph__@return A DataSet of {@code Tuple2<vertexId, inDegree>};public DataSet<Tuple2<K, Long>> inDegrees() {__		return vertices.coGroup(edges).where(0).equalTo(1).with(new CountNeighborsCoGroup<K, VV, EV>())__	};return,the,in,degree,of,all,vertices,in,the,graph,return,a,data,set,of,code,tuple2,vertex,id,in,degree;public,data,set,tuple2,k,long,in,degrees,return,vertices,co,group,edges,where,0,equal,to,1,with,new,count,neighbors,co,group,k,vv,ev
Graph -> public DataSet<Tuple2<K, Long>> inDegrees();1458583829;Return the in-degree of all vertices in the graph__@return A DataSet of {@code Tuple2<vertexId, inDegree>};public DataSet<Tuple2<K, Long>> inDegrees() {__		return vertices.coGroup(edges).where(0).equalTo(1).with(new CountNeighborsCoGroup<K, VV, EV>())__	};return,the,in,degree,of,all,vertices,in,the,graph,return,a,data,set,of,code,tuple2,vertex,id,in,degree;public,data,set,tuple2,k,long,in,degrees,return,vertices,co,group,edges,where,0,equal,to,1,with,new,count,neighbors,co,group,k,vv,ev
Graph -> public DataSet<Tuple2<K, Long>> inDegrees();1458583829;Return the in-degree of all vertices in the graph__@return A DataSet of {@code Tuple2<vertexId, inDegree>};public DataSet<Tuple2<K, Long>> inDegrees() {__		return vertices.coGroup(edges).where(0).equalTo(1).with(new CountNeighborsCoGroup<K, VV, EV>())__	};return,the,in,degree,of,all,vertices,in,the,graph,return,a,data,set,of,code,tuple2,vertex,id,in,degree;public,data,set,tuple2,k,long,in,degrees,return,vertices,co,group,edges,where,0,equal,to,1,with,new,count,neighbors,co,group,k,vv,ev
Graph -> public DataSet<Tuple2<K, Long>> inDegrees();1462100316;Return the in-degree of all vertices in the graph__@return A DataSet of {@code Tuple2<vertexId, inDegree>};public DataSet<Tuple2<K, Long>> inDegrees() {__		return vertices.coGroup(edges).where(0).equalTo(1).with(new CountNeighborsCoGroup<K, VV, EV>())__	};return,the,in,degree,of,all,vertices,in,the,graph,return,a,data,set,of,code,tuple2,vertex,id,in,degree;public,data,set,tuple2,k,long,in,degrees,return,vertices,co,group,edges,where,0,equal,to,1,with,new,count,neighbors,co,group,k,vv,ev
Graph -> public DataSet<Tuple2<K, Long>> inDegrees();1462100316;Return the in-degree of all vertices in the graph__@return A DataSet of {@code Tuple2<vertexId, inDegree>};public DataSet<Tuple2<K, Long>> inDegrees() {__		return vertices.coGroup(edges).where(0).equalTo(1).with(new CountNeighborsCoGroup<K, VV, EV>())__	};return,the,in,degree,of,all,vertices,in,the,graph,return,a,data,set,of,code,tuple2,vertex,id,in,degree;public,data,set,tuple2,k,long,in,degrees,return,vertices,co,group,edges,where,0,equal,to,1,with,new,count,neighbors,co,group,k,vv,ev
Graph -> public DataSet<Tuple2<K, Long>> inDegrees();1462205213;Return the in-degree of all vertices in the graph__@return A DataSet of {@code Tuple2<vertexId, inDegree>};public DataSet<Tuple2<K, Long>> inDegrees() {__		return vertices.coGroup(edges).where(0).equalTo(1).with(new CountNeighborsCoGroup<K, VV, EV>())__	};return,the,in,degree,of,all,vertices,in,the,graph,return,a,data,set,of,code,tuple2,vertex,id,in,degree;public,data,set,tuple2,k,long,in,degrees,return,vertices,co,group,edges,where,0,equal,to,1,with,new,count,neighbors,co,group,k,vv,ev
Graph -> public DataSet<Tuple2<K, Long>> inDegrees();1462208859;Return the in-degree of all vertices in the graph__@return A DataSet of {@code Tuple2<vertexId, inDegree>};public DataSet<Tuple2<K, Long>> inDegrees() {__		return vertices.coGroup(edges).where(0).equalTo(1).with(new CountNeighborsCoGroup<K, VV, EV>())__	};return,the,in,degree,of,all,vertices,in,the,graph,return,a,data,set,of,code,tuple2,vertex,id,in,degree;public,data,set,tuple2,k,long,in,degrees,return,vertices,co,group,edges,where,0,equal,to,1,with,new,count,neighbors,co,group,k,vv,ev
Graph -> public DataSet<Tuple2<K, Long>> inDegrees();1462809297;Return the in-degree of all vertices in the graph__@return A DataSet of {@code Tuple2<vertexId, inDegree>};public DataSet<Tuple2<K, Long>> inDegrees() {__		return vertices.coGroup(edges).where(0).equalTo(1).with(new CountNeighborsCoGroup<K, VV, EV>())__	};return,the,in,degree,of,all,vertices,in,the,graph,return,a,data,set,of,code,tuple2,vertex,id,in,degree;public,data,set,tuple2,k,long,in,degrees,return,vertices,co,group,edges,where,0,equal,to,1,with,new,count,neighbors,co,group,k,vv,ev
Graph -> public DataSet<Tuple2<K, Long>> inDegrees();1465316775;Return the in-degree of all vertices in the graph__@return A DataSet of {@code Tuple2<vertexId, inDegree>};public DataSet<Tuple2<K, Long>> inDegrees() {__		return vertices.coGroup(edges).where(0).equalTo(1).with(new CountNeighborsCoGroup<K, VV, EV>())__	};return,the,in,degree,of,all,vertices,in,the,graph,return,a,data,set,of,code,tuple2,vertex,id,in,degree;public,data,set,tuple2,k,long,in,degrees,return,vertices,co,group,edges,where,0,equal,to,1,with,new,count,neighbors,co,group,k,vv,ev
Graph -> public DataSet<Tuple2<K, Long>> inDegrees();1466789678;Return the in-degree of all vertices in the graph__@return A DataSet of {@code Tuple2<vertexId, inDegree>};public DataSet<Tuple2<K, Long>> inDegrees() {__		return vertices.coGroup(edges).where(0).equalTo(1).with(new CountNeighborsCoGroup<K, VV, EV>())__	};return,the,in,degree,of,all,vertices,in,the,graph,return,a,data,set,of,code,tuple2,vertex,id,in,degree;public,data,set,tuple2,k,long,in,degrees,return,vertices,co,group,edges,where,0,equal,to,1,with,new,count,neighbors,co,group,k,vv,ev
Graph -> public <T> DataSet<T> groupReduceOnEdges(EdgesFunctionWithVertexValue<K, VV, EV, T> edgesFunction, 			EdgeDirection direction) throws IllegalArgumentException;1445261977;Groups by vertex and computes a GroupReduce transformation over the edge values of each vertex._The edgesFunction applied on the edges has access to both the id and the value_of the grouping vertex.__For each vertex, the edgesFunction can iterate over all edges of this vertex_with the specified direction, and emit any number of output elements, including none.__@param edgesFunction the group reduce function to apply to the neighboring edges of each vertex._@param direction the edge direction (in-, out-, all-)._@param <T> the output type_@return a DataSet containing elements of type T_@throws IllegalArgumentException;public <T> DataSet<T> groupReduceOnEdges(EdgesFunctionWithVertexValue<K, VV, EV, T> edgesFunction,_			EdgeDirection direction) throws IllegalArgumentException {__		switch (direction) {_		case IN:_			return vertices.coGroup(edges).where(0).equalTo(1)_					.with(new ApplyCoGroupFunction<K, VV, EV, T>(edgesFunction))__		case OUT:_			return vertices.coGroup(edges).where(0).equalTo(0)_					.with(new ApplyCoGroupFunction<K, VV, EV, T>(edgesFunction))__		case ALL:_			return vertices.coGroup(edges.flatMap(new EmitOneEdgePerNode<K, VV, EV>()))_					.where(0).equalTo(0).with(new ApplyCoGroupFunctionOnAllEdges<K, VV, EV, T>(edgesFunction))__		default:_			throw new IllegalArgumentException("Illegal edge direction")__		}_	};groups,by,vertex,and,computes,a,group,reduce,transformation,over,the,edge,values,of,each,vertex,the,edges,function,applied,on,the,edges,has,access,to,both,the,id,and,the,value,of,the,grouping,vertex,for,each,vertex,the,edges,function,can,iterate,over,all,edges,of,this,vertex,with,the,specified,direction,and,emit,any,number,of,output,elements,including,none,param,edges,function,the,group,reduce,function,to,apply,to,the,neighboring,edges,of,each,vertex,param,direction,the,edge,direction,in,out,all,param,t,the,output,type,return,a,data,set,containing,elements,of,type,t,throws,illegal,argument,exception;public,t,data,set,t,group,reduce,on,edges,edges,function,with,vertex,value,k,vv,ev,t,edges,function,edge,direction,direction,throws,illegal,argument,exception,switch,direction,case,in,return,vertices,co,group,edges,where,0,equal,to,1,with,new,apply,co,group,function,k,vv,ev,t,edges,function,case,out,return,vertices,co,group,edges,where,0,equal,to,0,with,new,apply,co,group,function,k,vv,ev,t,edges,function,case,all,return,vertices,co,group,edges,flat,map,new,emit,one,edge,per,node,k,vv,ev,where,0,equal,to,0,with,new,apply,co,group,function,on,all,edges,k,vv,ev,t,edges,function,default,throw,new,illegal,argument,exception,illegal,edge,direction
Graph -> public <T> DataSet<T> groupReduceOnEdges(EdgesFunctionWithVertexValue<K, VV, EV, T> edgesFunction, 			EdgeDirection direction) throws IllegalArgumentException;1445854323;Groups by vertex and computes a GroupReduce transformation over the edge values of each vertex._The edgesFunction applied on the edges has access to both the id and the value_of the grouping vertex.__For each vertex, the edgesFunction can iterate over all edges of this vertex_with the specified direction, and emit any number of output elements, including none.__@param edgesFunction the group reduce function to apply to the neighboring edges of each vertex._@param direction the edge direction (in-, out-, all-)._@param <T> the output type_@return a DataSet containing elements of type T_@throws IllegalArgumentException;public <T> DataSet<T> groupReduceOnEdges(EdgesFunctionWithVertexValue<K, VV, EV, T> edgesFunction,_			EdgeDirection direction) throws IllegalArgumentException {__		switch (direction) {_		case IN:_			return vertices.coGroup(edges).where(0).equalTo(1)_					.with(new ApplyCoGroupFunction<K, VV, EV, T>(edgesFunction))__		case OUT:_			return vertices.coGroup(edges).where(0).equalTo(0)_					.with(new ApplyCoGroupFunction<K, VV, EV, T>(edgesFunction))__		case ALL:_			return vertices.coGroup(edges.flatMap(new EmitOneEdgePerNode<K, VV, EV>()))_					.where(0).equalTo(0).with(new ApplyCoGroupFunctionOnAllEdges<K, VV, EV, T>(edgesFunction))__		default:_			throw new IllegalArgumentException("Illegal edge direction")__		}_	};groups,by,vertex,and,computes,a,group,reduce,transformation,over,the,edge,values,of,each,vertex,the,edges,function,applied,on,the,edges,has,access,to,both,the,id,and,the,value,of,the,grouping,vertex,for,each,vertex,the,edges,function,can,iterate,over,all,edges,of,this,vertex,with,the,specified,direction,and,emit,any,number,of,output,elements,including,none,param,edges,function,the,group,reduce,function,to,apply,to,the,neighboring,edges,of,each,vertex,param,direction,the,edge,direction,in,out,all,param,t,the,output,type,return,a,data,set,containing,elements,of,type,t,throws,illegal,argument,exception;public,t,data,set,t,group,reduce,on,edges,edges,function,with,vertex,value,k,vv,ev,t,edges,function,edge,direction,direction,throws,illegal,argument,exception,switch,direction,case,in,return,vertices,co,group,edges,where,0,equal,to,1,with,new,apply,co,group,function,k,vv,ev,t,edges,function,case,out,return,vertices,co,group,edges,where,0,equal,to,0,with,new,apply,co,group,function,k,vv,ev,t,edges,function,case,all,return,vertices,co,group,edges,flat,map,new,emit,one,edge,per,node,k,vv,ev,where,0,equal,to,0,with,new,apply,co,group,function,on,all,edges,k,vv,ev,t,edges,function,default,throw,new,illegal,argument,exception,illegal,edge,direction
Graph -> public <T> DataSet<T> groupReduceOnEdges(EdgesFunctionWithVertexValue<K, VV, EV, T> edgesFunction, 			EdgeDirection direction) throws IllegalArgumentException;1446112342;Groups by vertex and computes a GroupReduce transformation over the edge values of each vertex._The edgesFunction applied on the edges has access to both the id and the value_of the grouping vertex.__For each vertex, the edgesFunction can iterate over all edges of this vertex_with the specified direction, and emit any number of output elements, including none.__@param edgesFunction the group reduce function to apply to the neighboring edges of each vertex._@param direction the edge direction (in-, out-, all-)._@param <T> the output type_@return a DataSet containing elements of type T_@throws IllegalArgumentException;public <T> DataSet<T> groupReduceOnEdges(EdgesFunctionWithVertexValue<K, VV, EV, T> edgesFunction,_			EdgeDirection direction) throws IllegalArgumentException {__		switch (direction) {_		case IN:_			return vertices.coGroup(edges).where(0).equalTo(1)_					.with(new ApplyCoGroupFunction<K, VV, EV, T>(edgesFunction))__		case OUT:_			return vertices.coGroup(edges).where(0).equalTo(0)_					.with(new ApplyCoGroupFunction<K, VV, EV, T>(edgesFunction))__		case ALL:_			return vertices.coGroup(edges.flatMap(new EmitOneEdgePerNode<K, VV, EV>()))_					.where(0).equalTo(0).with(new ApplyCoGroupFunctionOnAllEdges<K, VV, EV, T>(edgesFunction))__		default:_			throw new IllegalArgumentException("Illegal edge direction")__		}_	};groups,by,vertex,and,computes,a,group,reduce,transformation,over,the,edge,values,of,each,vertex,the,edges,function,applied,on,the,edges,has,access,to,both,the,id,and,the,value,of,the,grouping,vertex,for,each,vertex,the,edges,function,can,iterate,over,all,edges,of,this,vertex,with,the,specified,direction,and,emit,any,number,of,output,elements,including,none,param,edges,function,the,group,reduce,function,to,apply,to,the,neighboring,edges,of,each,vertex,param,direction,the,edge,direction,in,out,all,param,t,the,output,type,return,a,data,set,containing,elements,of,type,t,throws,illegal,argument,exception;public,t,data,set,t,group,reduce,on,edges,edges,function,with,vertex,value,k,vv,ev,t,edges,function,edge,direction,direction,throws,illegal,argument,exception,switch,direction,case,in,return,vertices,co,group,edges,where,0,equal,to,1,with,new,apply,co,group,function,k,vv,ev,t,edges,function,case,out,return,vertices,co,group,edges,where,0,equal,to,0,with,new,apply,co,group,function,k,vv,ev,t,edges,function,case,all,return,vertices,co,group,edges,flat,map,new,emit,one,edge,per,node,k,vv,ev,where,0,equal,to,0,with,new,apply,co,group,function,on,all,edges,k,vv,ev,t,edges,function,default,throw,new,illegal,argument,exception,illegal,edge,direction
Graph -> public <T> DataSet<T> groupReduceOnEdges(EdgesFunctionWithVertexValue<K, VV, EV, T> edgesFunction, 			EdgeDirection direction) throws IllegalArgumentException;1447073368;Groups by vertex and computes a GroupReduce transformation over the edge values of each vertex._The edgesFunction applied on the edges has access to both the id and the value_of the grouping vertex.__For each vertex, the edgesFunction can iterate over all edges of this vertex_with the specified direction, and emit any number of output elements, including none.__@param edgesFunction the group reduce function to apply to the neighboring edges of each vertex._@param direction the edge direction (in-, out-, all-)._@param <T> the output type_@return a DataSet containing elements of type T_@throws IllegalArgumentException;public <T> DataSet<T> groupReduceOnEdges(EdgesFunctionWithVertexValue<K, VV, EV, T> edgesFunction,_			EdgeDirection direction) throws IllegalArgumentException {__		switch (direction) {_		case IN:_			return vertices.coGroup(edges).where(0).equalTo(1)_					.with(new ApplyCoGroupFunction<K, VV, EV, T>(edgesFunction))__		case OUT:_			return vertices.coGroup(edges).where(0).equalTo(0)_					.with(new ApplyCoGroupFunction<K, VV, EV, T>(edgesFunction))__		case ALL:_			return vertices.coGroup(edges.flatMap(new EmitOneEdgePerNode<K, VV, EV>()))_					.where(0).equalTo(0).with(new ApplyCoGroupFunctionOnAllEdges<K, VV, EV, T>(edgesFunction))__		default:_			throw new IllegalArgumentException("Illegal edge direction")__		}_	};groups,by,vertex,and,computes,a,group,reduce,transformation,over,the,edge,values,of,each,vertex,the,edges,function,applied,on,the,edges,has,access,to,both,the,id,and,the,value,of,the,grouping,vertex,for,each,vertex,the,edges,function,can,iterate,over,all,edges,of,this,vertex,with,the,specified,direction,and,emit,any,number,of,output,elements,including,none,param,edges,function,the,group,reduce,function,to,apply,to,the,neighboring,edges,of,each,vertex,param,direction,the,edge,direction,in,out,all,param,t,the,output,type,return,a,data,set,containing,elements,of,type,t,throws,illegal,argument,exception;public,t,data,set,t,group,reduce,on,edges,edges,function,with,vertex,value,k,vv,ev,t,edges,function,edge,direction,direction,throws,illegal,argument,exception,switch,direction,case,in,return,vertices,co,group,edges,where,0,equal,to,1,with,new,apply,co,group,function,k,vv,ev,t,edges,function,case,out,return,vertices,co,group,edges,where,0,equal,to,0,with,new,apply,co,group,function,k,vv,ev,t,edges,function,case,all,return,vertices,co,group,edges,flat,map,new,emit,one,edge,per,node,k,vv,ev,where,0,equal,to,0,with,new,apply,co,group,function,on,all,edges,k,vv,ev,t,edges,function,default,throw,new,illegal,argument,exception,illegal,edge,direction
Graph -> public <T> DataSet<T> groupReduceOnEdges(EdgesFunctionWithVertexValue<K, VV, EV, T> edgesFunction, 			EdgeDirection direction) throws IllegalArgumentException;1454404649;Groups by vertex and computes a GroupReduce transformation over the edge values of each vertex._The edgesFunction applied on the edges has access to both the id and the value_of the grouping vertex.__For each vertex, the edgesFunction can iterate over all edges of this vertex_with the specified direction, and emit any number of output elements, including none.__@param edgesFunction the group reduce function to apply to the neighboring edges of each vertex._@param direction the edge direction (in-, out-, all-)._@param <T> the output type_@return a DataSet containing elements of type T_@throws IllegalArgumentException;public <T> DataSet<T> groupReduceOnEdges(EdgesFunctionWithVertexValue<K, VV, EV, T> edgesFunction,_			EdgeDirection direction) throws IllegalArgumentException {__		switch (direction) {_		case IN:_			return vertices.coGroup(edges).where(0).equalTo(1)_					.with(new ApplyCoGroupFunction<K, VV, EV, T>(edgesFunction))__		case OUT:_			return vertices.coGroup(edges).where(0).equalTo(0)_					.with(new ApplyCoGroupFunction<K, VV, EV, T>(edgesFunction))__		case ALL:_			return vertices.coGroup(edges.flatMap(new EmitOneEdgePerNode<K, VV, EV>()))_					.where(0).equalTo(0).with(new ApplyCoGroupFunctionOnAllEdges<K, VV, EV, T>(edgesFunction))__		default:_			throw new IllegalArgumentException("Illegal edge direction")__		}_	};groups,by,vertex,and,computes,a,group,reduce,transformation,over,the,edge,values,of,each,vertex,the,edges,function,applied,on,the,edges,has,access,to,both,the,id,and,the,value,of,the,grouping,vertex,for,each,vertex,the,edges,function,can,iterate,over,all,edges,of,this,vertex,with,the,specified,direction,and,emit,any,number,of,output,elements,including,none,param,edges,function,the,group,reduce,function,to,apply,to,the,neighboring,edges,of,each,vertex,param,direction,the,edge,direction,in,out,all,param,t,the,output,type,return,a,data,set,containing,elements,of,type,t,throws,illegal,argument,exception;public,t,data,set,t,group,reduce,on,edges,edges,function,with,vertex,value,k,vv,ev,t,edges,function,edge,direction,direction,throws,illegal,argument,exception,switch,direction,case,in,return,vertices,co,group,edges,where,0,equal,to,1,with,new,apply,co,group,function,k,vv,ev,t,edges,function,case,out,return,vertices,co,group,edges,where,0,equal,to,0,with,new,apply,co,group,function,k,vv,ev,t,edges,function,case,all,return,vertices,co,group,edges,flat,map,new,emit,one,edge,per,node,k,vv,ev,where,0,equal,to,0,with,new,apply,co,group,function,on,all,edges,k,vv,ev,t,edges,function,default,throw,new,illegal,argument,exception,illegal,edge,direction
Graph -> public <T> DataSet<T> groupReduceOnEdges(EdgesFunctionWithVertexValue<K, VV, EV, T> edgesFunction, 			EdgeDirection direction) throws IllegalArgumentException;1458583829;Groups by vertex and computes a GroupReduce transformation over the edge values of each vertex._The edgesFunction applied on the edges has access to both the id and the value_of the grouping vertex.__For each vertex, the edgesFunction can iterate over all edges of this vertex_with the specified direction, and emit any number of output elements, including none.__@param edgesFunction the group reduce function to apply to the neighboring edges of each vertex._@param direction the edge direction (in-, out-, all-)._@param <T> the output type_@return a DataSet containing elements of type T_@throws IllegalArgumentException;public <T> DataSet<T> groupReduceOnEdges(EdgesFunctionWithVertexValue<K, VV, EV, T> edgesFunction,_			EdgeDirection direction) throws IllegalArgumentException {__		switch (direction) {_		case IN:_			return vertices.coGroup(edges).where(0).equalTo(1)_					.with(new ApplyCoGroupFunction<K, VV, EV, T>(edgesFunction))__		case OUT:_			return vertices.coGroup(edges).where(0).equalTo(0)_					.with(new ApplyCoGroupFunction<K, VV, EV, T>(edgesFunction))__		case ALL:_			return vertices.coGroup(edges.flatMap(new EmitOneEdgePerNode<K, VV, EV>()))_					.where(0).equalTo(0).with(new ApplyCoGroupFunctionOnAllEdges<K, VV, EV, T>(edgesFunction))__		default:_			throw new IllegalArgumentException("Illegal edge direction")__		}_	};groups,by,vertex,and,computes,a,group,reduce,transformation,over,the,edge,values,of,each,vertex,the,edges,function,applied,on,the,edges,has,access,to,both,the,id,and,the,value,of,the,grouping,vertex,for,each,vertex,the,edges,function,can,iterate,over,all,edges,of,this,vertex,with,the,specified,direction,and,emit,any,number,of,output,elements,including,none,param,edges,function,the,group,reduce,function,to,apply,to,the,neighboring,edges,of,each,vertex,param,direction,the,edge,direction,in,out,all,param,t,the,output,type,return,a,data,set,containing,elements,of,type,t,throws,illegal,argument,exception;public,t,data,set,t,group,reduce,on,edges,edges,function,with,vertex,value,k,vv,ev,t,edges,function,edge,direction,direction,throws,illegal,argument,exception,switch,direction,case,in,return,vertices,co,group,edges,where,0,equal,to,1,with,new,apply,co,group,function,k,vv,ev,t,edges,function,case,out,return,vertices,co,group,edges,where,0,equal,to,0,with,new,apply,co,group,function,k,vv,ev,t,edges,function,case,all,return,vertices,co,group,edges,flat,map,new,emit,one,edge,per,node,k,vv,ev,where,0,equal,to,0,with,new,apply,co,group,function,on,all,edges,k,vv,ev,t,edges,function,default,throw,new,illegal,argument,exception,illegal,edge,direction
Graph -> public <T> DataSet<T> groupReduceOnEdges(EdgesFunctionWithVertexValue<K, VV, EV, T> edgesFunction, 			EdgeDirection direction) throws IllegalArgumentException;1458583829;Groups by vertex and computes a GroupReduce transformation over the edge values of each vertex._The edgesFunction applied on the edges has access to both the id and the value_of the grouping vertex.__For each vertex, the edgesFunction can iterate over all edges of this vertex_with the specified direction, and emit any number of output elements, including none.__@param edgesFunction the group reduce function to apply to the neighboring edges of each vertex._@param direction the edge direction (in-, out-, all-)._@param <T> the output type_@return a DataSet containing elements of type T_@throws IllegalArgumentException;public <T> DataSet<T> groupReduceOnEdges(EdgesFunctionWithVertexValue<K, VV, EV, T> edgesFunction,_			EdgeDirection direction) throws IllegalArgumentException {__		switch (direction) {_		case IN:_			return vertices.coGroup(edges).where(0).equalTo(1)_					.with(new ApplyCoGroupFunction<K, VV, EV, T>(edgesFunction))__		case OUT:_			return vertices.coGroup(edges).where(0).equalTo(0)_					.with(new ApplyCoGroupFunction<K, VV, EV, T>(edgesFunction))__		case ALL:_			return vertices.coGroup(edges.flatMap(new EmitOneEdgePerNode<K, VV, EV>()))_					.where(0).equalTo(0).with(new ApplyCoGroupFunctionOnAllEdges<K, VV, EV, T>(edgesFunction))__		default:_			throw new IllegalArgumentException("Illegal edge direction")__		}_	};groups,by,vertex,and,computes,a,group,reduce,transformation,over,the,edge,values,of,each,vertex,the,edges,function,applied,on,the,edges,has,access,to,both,the,id,and,the,value,of,the,grouping,vertex,for,each,vertex,the,edges,function,can,iterate,over,all,edges,of,this,vertex,with,the,specified,direction,and,emit,any,number,of,output,elements,including,none,param,edges,function,the,group,reduce,function,to,apply,to,the,neighboring,edges,of,each,vertex,param,direction,the,edge,direction,in,out,all,param,t,the,output,type,return,a,data,set,containing,elements,of,type,t,throws,illegal,argument,exception;public,t,data,set,t,group,reduce,on,edges,edges,function,with,vertex,value,k,vv,ev,t,edges,function,edge,direction,direction,throws,illegal,argument,exception,switch,direction,case,in,return,vertices,co,group,edges,where,0,equal,to,1,with,new,apply,co,group,function,k,vv,ev,t,edges,function,case,out,return,vertices,co,group,edges,where,0,equal,to,0,with,new,apply,co,group,function,k,vv,ev,t,edges,function,case,all,return,vertices,co,group,edges,flat,map,new,emit,one,edge,per,node,k,vv,ev,where,0,equal,to,0,with,new,apply,co,group,function,on,all,edges,k,vv,ev,t,edges,function,default,throw,new,illegal,argument,exception,illegal,edge,direction
Graph -> public <T> DataSet<T> groupReduceOnEdges(EdgesFunctionWithVertexValue<K, VV, EV, T> edgesFunction, 			EdgeDirection direction) throws IllegalArgumentException;1462100316;Groups by vertex and computes a GroupReduce transformation over the edge values of each vertex._The edgesFunction applied on the edges has access to both the id and the value_of the grouping vertex.__For each vertex, the edgesFunction can iterate over all edges of this vertex_with the specified direction, and emit any number of output elements, including none.__@param edgesFunction the group reduce function to apply to the neighboring edges of each vertex._@param direction the edge direction (in-, out-, all-)._@param <T> the output type_@return a DataSet containing elements of type T_@throws IllegalArgumentException;public <T> DataSet<T> groupReduceOnEdges(EdgesFunctionWithVertexValue<K, VV, EV, T> edgesFunction,_			EdgeDirection direction) throws IllegalArgumentException {__		switch (direction) {_		case IN:_			return vertices.coGroup(edges).where(0).equalTo(1)_					.with(new ApplyCoGroupFunction<K, VV, EV, T>(edgesFunction))__		case OUT:_			return vertices.coGroup(edges).where(0).equalTo(0)_					.with(new ApplyCoGroupFunction<K, VV, EV, T>(edgesFunction))__		case ALL:_			return vertices.coGroup(edges.flatMap(new EmitOneEdgePerNode<K, VV, EV>()))_					.where(0).equalTo(0).with(new ApplyCoGroupFunctionOnAllEdges<K, VV, EV, T>(edgesFunction))__		default:_			throw new IllegalArgumentException("Illegal edge direction")__		}_	};groups,by,vertex,and,computes,a,group,reduce,transformation,over,the,edge,values,of,each,vertex,the,edges,function,applied,on,the,edges,has,access,to,both,the,id,and,the,value,of,the,grouping,vertex,for,each,vertex,the,edges,function,can,iterate,over,all,edges,of,this,vertex,with,the,specified,direction,and,emit,any,number,of,output,elements,including,none,param,edges,function,the,group,reduce,function,to,apply,to,the,neighboring,edges,of,each,vertex,param,direction,the,edge,direction,in,out,all,param,t,the,output,type,return,a,data,set,containing,elements,of,type,t,throws,illegal,argument,exception;public,t,data,set,t,group,reduce,on,edges,edges,function,with,vertex,value,k,vv,ev,t,edges,function,edge,direction,direction,throws,illegal,argument,exception,switch,direction,case,in,return,vertices,co,group,edges,where,0,equal,to,1,with,new,apply,co,group,function,k,vv,ev,t,edges,function,case,out,return,vertices,co,group,edges,where,0,equal,to,0,with,new,apply,co,group,function,k,vv,ev,t,edges,function,case,all,return,vertices,co,group,edges,flat,map,new,emit,one,edge,per,node,k,vv,ev,where,0,equal,to,0,with,new,apply,co,group,function,on,all,edges,k,vv,ev,t,edges,function,default,throw,new,illegal,argument,exception,illegal,edge,direction
Graph -> public <T> DataSet<T> groupReduceOnEdges(EdgesFunctionWithVertexValue<K, VV, EV, T> edgesFunction, 			EdgeDirection direction) throws IllegalArgumentException;1462100316;Groups by vertex and computes a GroupReduce transformation over the edge values of each vertex._The edgesFunction applied on the edges has access to both the id and the value_of the grouping vertex.__For each vertex, the edgesFunction can iterate over all edges of this vertex_with the specified direction, and emit any number of output elements, including none.__@param edgesFunction the group reduce function to apply to the neighboring edges of each vertex._@param direction the edge direction (in-, out-, all-)._@param <T> the output type_@return a DataSet containing elements of type T_@throws IllegalArgumentException;public <T> DataSet<T> groupReduceOnEdges(EdgesFunctionWithVertexValue<K, VV, EV, T> edgesFunction,_			EdgeDirection direction) throws IllegalArgumentException {__		switch (direction) {_		case IN:_			return vertices.coGroup(edges).where(0).equalTo(1)_					.with(new ApplyCoGroupFunction<K, VV, EV, T>(edgesFunction))__		case OUT:_			return vertices.coGroup(edges).where(0).equalTo(0)_					.with(new ApplyCoGroupFunction<K, VV, EV, T>(edgesFunction))__		case ALL:_			return vertices.coGroup(edges.flatMap(new EmitOneEdgePerNode<K, VV, EV>()))_					.where(0).equalTo(0).with(new ApplyCoGroupFunctionOnAllEdges<K, VV, EV, T>(edgesFunction))__		default:_			throw new IllegalArgumentException("Illegal edge direction")__		}_	};groups,by,vertex,and,computes,a,group,reduce,transformation,over,the,edge,values,of,each,vertex,the,edges,function,applied,on,the,edges,has,access,to,both,the,id,and,the,value,of,the,grouping,vertex,for,each,vertex,the,edges,function,can,iterate,over,all,edges,of,this,vertex,with,the,specified,direction,and,emit,any,number,of,output,elements,including,none,param,edges,function,the,group,reduce,function,to,apply,to,the,neighboring,edges,of,each,vertex,param,direction,the,edge,direction,in,out,all,param,t,the,output,type,return,a,data,set,containing,elements,of,type,t,throws,illegal,argument,exception;public,t,data,set,t,group,reduce,on,edges,edges,function,with,vertex,value,k,vv,ev,t,edges,function,edge,direction,direction,throws,illegal,argument,exception,switch,direction,case,in,return,vertices,co,group,edges,where,0,equal,to,1,with,new,apply,co,group,function,k,vv,ev,t,edges,function,case,out,return,vertices,co,group,edges,where,0,equal,to,0,with,new,apply,co,group,function,k,vv,ev,t,edges,function,case,all,return,vertices,co,group,edges,flat,map,new,emit,one,edge,per,node,k,vv,ev,where,0,equal,to,0,with,new,apply,co,group,function,on,all,edges,k,vv,ev,t,edges,function,default,throw,new,illegal,argument,exception,illegal,edge,direction
Graph -> public <T> DataSet<T> groupReduceOnEdges(EdgesFunctionWithVertexValue<K, VV, EV, T> edgesFunction, 			EdgeDirection direction) throws IllegalArgumentException;1462205213;Groups by vertex and computes a GroupReduce transformation over the edge values of each vertex._The edgesFunction applied on the edges has access to both the id and the value_of the grouping vertex.__For each vertex, the edgesFunction can iterate over all edges of this vertex_with the specified direction, and emit any number of output elements, including none.__@param edgesFunction the group reduce function to apply to the neighboring edges of each vertex._@param direction the edge direction (in-, out-, all-)._@param <T> the output type_@return a DataSet containing elements of type T_@throws IllegalArgumentException;public <T> DataSet<T> groupReduceOnEdges(EdgesFunctionWithVertexValue<K, VV, EV, T> edgesFunction,_			EdgeDirection direction) throws IllegalArgumentException {__		switch (direction) {_		case IN:_			return vertices.coGroup(edges).where(0).equalTo(1)_					.with(new ApplyCoGroupFunction<K, VV, EV, T>(edgesFunction))__		case OUT:_			return vertices.coGroup(edges).where(0).equalTo(0)_					.with(new ApplyCoGroupFunction<K, VV, EV, T>(edgesFunction))__		case ALL:_			return vertices.coGroup(edges.flatMap(new EmitOneEdgePerNode<K, VV, EV>()))_					.where(0).equalTo(0).with(new ApplyCoGroupFunctionOnAllEdges<K, VV, EV, T>(edgesFunction))__		default:_			throw new IllegalArgumentException("Illegal edge direction")__		}_	};groups,by,vertex,and,computes,a,group,reduce,transformation,over,the,edge,values,of,each,vertex,the,edges,function,applied,on,the,edges,has,access,to,both,the,id,and,the,value,of,the,grouping,vertex,for,each,vertex,the,edges,function,can,iterate,over,all,edges,of,this,vertex,with,the,specified,direction,and,emit,any,number,of,output,elements,including,none,param,edges,function,the,group,reduce,function,to,apply,to,the,neighboring,edges,of,each,vertex,param,direction,the,edge,direction,in,out,all,param,t,the,output,type,return,a,data,set,containing,elements,of,type,t,throws,illegal,argument,exception;public,t,data,set,t,group,reduce,on,edges,edges,function,with,vertex,value,k,vv,ev,t,edges,function,edge,direction,direction,throws,illegal,argument,exception,switch,direction,case,in,return,vertices,co,group,edges,where,0,equal,to,1,with,new,apply,co,group,function,k,vv,ev,t,edges,function,case,out,return,vertices,co,group,edges,where,0,equal,to,0,with,new,apply,co,group,function,k,vv,ev,t,edges,function,case,all,return,vertices,co,group,edges,flat,map,new,emit,one,edge,per,node,k,vv,ev,where,0,equal,to,0,with,new,apply,co,group,function,on,all,edges,k,vv,ev,t,edges,function,default,throw,new,illegal,argument,exception,illegal,edge,direction
Graph -> public <T> DataSet<T> groupReduceOnEdges(EdgesFunctionWithVertexValue<K, VV, EV, T> edgesFunction, 			EdgeDirection direction) throws IllegalArgumentException;1462208859;Groups by vertex and computes a GroupReduce transformation over the edge values of each vertex._The edgesFunction applied on the edges has access to both the id and the value_of the grouping vertex.__For each vertex, the edgesFunction can iterate over all edges of this vertex_with the specified direction, and emit any number of output elements, including none.__@param edgesFunction the group reduce function to apply to the neighboring edges of each vertex._@param direction the edge direction (in-, out-, all-)._@param <T> the output type_@return a DataSet containing elements of type T_@throws IllegalArgumentException;public <T> DataSet<T> groupReduceOnEdges(EdgesFunctionWithVertexValue<K, VV, EV, T> edgesFunction,_			EdgeDirection direction) throws IllegalArgumentException {__		switch (direction) {_		case IN:_			return vertices.coGroup(edges).where(0).equalTo(1)_					.with(new ApplyCoGroupFunction<K, VV, EV, T>(edgesFunction))__		case OUT:_			return vertices.coGroup(edges).where(0).equalTo(0)_					.with(new ApplyCoGroupFunction<K, VV, EV, T>(edgesFunction))__		case ALL:_			return vertices.coGroup(edges.flatMap(new EmitOneEdgePerNode<K, VV, EV>()))_					.where(0).equalTo(0).with(new ApplyCoGroupFunctionOnAllEdges<K, VV, EV, T>(edgesFunction))__		default:_			throw new IllegalArgumentException("Illegal edge direction")__		}_	};groups,by,vertex,and,computes,a,group,reduce,transformation,over,the,edge,values,of,each,vertex,the,edges,function,applied,on,the,edges,has,access,to,both,the,id,and,the,value,of,the,grouping,vertex,for,each,vertex,the,edges,function,can,iterate,over,all,edges,of,this,vertex,with,the,specified,direction,and,emit,any,number,of,output,elements,including,none,param,edges,function,the,group,reduce,function,to,apply,to,the,neighboring,edges,of,each,vertex,param,direction,the,edge,direction,in,out,all,param,t,the,output,type,return,a,data,set,containing,elements,of,type,t,throws,illegal,argument,exception;public,t,data,set,t,group,reduce,on,edges,edges,function,with,vertex,value,k,vv,ev,t,edges,function,edge,direction,direction,throws,illegal,argument,exception,switch,direction,case,in,return,vertices,co,group,edges,where,0,equal,to,1,with,new,apply,co,group,function,k,vv,ev,t,edges,function,case,out,return,vertices,co,group,edges,where,0,equal,to,0,with,new,apply,co,group,function,k,vv,ev,t,edges,function,case,all,return,vertices,co,group,edges,flat,map,new,emit,one,edge,per,node,k,vv,ev,where,0,equal,to,0,with,new,apply,co,group,function,on,all,edges,k,vv,ev,t,edges,function,default,throw,new,illegal,argument,exception,illegal,edge,direction
Graph -> public <T> DataSet<T> groupReduceOnEdges(EdgesFunctionWithVertexValue<K, VV, EV, T> edgesFunction, 			EdgeDirection direction) throws IllegalArgumentException;1462809297;Groups by vertex and computes a GroupReduce transformation over the edge values of each vertex._The edgesFunction applied on the edges has access to both the id and the value_of the grouping vertex.__For each vertex, the edgesFunction can iterate over all edges of this vertex_with the specified direction, and emit any number of output elements, including none.__@param edgesFunction the group reduce function to apply to the neighboring edges of each vertex._@param direction the edge direction (in-, out-, all-)._@param <T> the output type_@return a DataSet containing elements of type T_@throws IllegalArgumentException;public <T> DataSet<T> groupReduceOnEdges(EdgesFunctionWithVertexValue<K, VV, EV, T> edgesFunction,_			EdgeDirection direction) throws IllegalArgumentException {__		switch (direction) {_		case IN:_			return vertices.coGroup(edges).where(0).equalTo(1)_					.with(new ApplyCoGroupFunction<K, VV, EV, T>(edgesFunction))__		case OUT:_			return vertices.coGroup(edges).where(0).equalTo(0)_					.with(new ApplyCoGroupFunction<K, VV, EV, T>(edgesFunction))__		case ALL:_			return vertices.coGroup(edges.flatMap(new EmitOneEdgePerNode<K, VV, EV>()))_					.where(0).equalTo(0).with(new ApplyCoGroupFunctionOnAllEdges<K, VV, EV, T>(edgesFunction))__		default:_			throw new IllegalArgumentException("Illegal edge direction")__		}_	};groups,by,vertex,and,computes,a,group,reduce,transformation,over,the,edge,values,of,each,vertex,the,edges,function,applied,on,the,edges,has,access,to,both,the,id,and,the,value,of,the,grouping,vertex,for,each,vertex,the,edges,function,can,iterate,over,all,edges,of,this,vertex,with,the,specified,direction,and,emit,any,number,of,output,elements,including,none,param,edges,function,the,group,reduce,function,to,apply,to,the,neighboring,edges,of,each,vertex,param,direction,the,edge,direction,in,out,all,param,t,the,output,type,return,a,data,set,containing,elements,of,type,t,throws,illegal,argument,exception;public,t,data,set,t,group,reduce,on,edges,edges,function,with,vertex,value,k,vv,ev,t,edges,function,edge,direction,direction,throws,illegal,argument,exception,switch,direction,case,in,return,vertices,co,group,edges,where,0,equal,to,1,with,new,apply,co,group,function,k,vv,ev,t,edges,function,case,out,return,vertices,co,group,edges,where,0,equal,to,0,with,new,apply,co,group,function,k,vv,ev,t,edges,function,case,all,return,vertices,co,group,edges,flat,map,new,emit,one,edge,per,node,k,vv,ev,where,0,equal,to,0,with,new,apply,co,group,function,on,all,edges,k,vv,ev,t,edges,function,default,throw,new,illegal,argument,exception,illegal,edge,direction
Graph -> public <T> DataSet<T> groupReduceOnEdges(EdgesFunctionWithVertexValue<K, VV, EV, T> edgesFunction, 			EdgeDirection direction) throws IllegalArgumentException;1465316775;Groups by vertex and computes a GroupReduce transformation over the edge values of each vertex._The edgesFunction applied on the edges has access to both the id and the value_of the grouping vertex.__For each vertex, the edgesFunction can iterate over all edges of this vertex_with the specified direction, and emit any number of output elements, including none.__@param edgesFunction the group reduce function to apply to the neighboring edges of each vertex._@param direction the edge direction (in-, out-, all-)._@param <T> the output type_@return a DataSet containing elements of type T_@throws IllegalArgumentException;public <T> DataSet<T> groupReduceOnEdges(EdgesFunctionWithVertexValue<K, VV, EV, T> edgesFunction,_			EdgeDirection direction) throws IllegalArgumentException {__		switch (direction) {_		case IN:_			return vertices.coGroup(edges).where(0).equalTo(1)_					.with(new ApplyCoGroupFunction<K, VV, EV, T>(edgesFunction))__		case OUT:_			return vertices.coGroup(edges).where(0).equalTo(0)_					.with(new ApplyCoGroupFunction<K, VV, EV, T>(edgesFunction))__		case ALL:_			return vertices.coGroup(edges.flatMap(new EmitOneEdgePerNode<K, VV, EV>()))_					.where(0).equalTo(0).with(new ApplyCoGroupFunctionOnAllEdges<K, VV, EV, T>(edgesFunction))__		default:_			throw new IllegalArgumentException("Illegal edge direction")__		}_	};groups,by,vertex,and,computes,a,group,reduce,transformation,over,the,edge,values,of,each,vertex,the,edges,function,applied,on,the,edges,has,access,to,both,the,id,and,the,value,of,the,grouping,vertex,for,each,vertex,the,edges,function,can,iterate,over,all,edges,of,this,vertex,with,the,specified,direction,and,emit,any,number,of,output,elements,including,none,param,edges,function,the,group,reduce,function,to,apply,to,the,neighboring,edges,of,each,vertex,param,direction,the,edge,direction,in,out,all,param,t,the,output,type,return,a,data,set,containing,elements,of,type,t,throws,illegal,argument,exception;public,t,data,set,t,group,reduce,on,edges,edges,function,with,vertex,value,k,vv,ev,t,edges,function,edge,direction,direction,throws,illegal,argument,exception,switch,direction,case,in,return,vertices,co,group,edges,where,0,equal,to,1,with,new,apply,co,group,function,k,vv,ev,t,edges,function,case,out,return,vertices,co,group,edges,where,0,equal,to,0,with,new,apply,co,group,function,k,vv,ev,t,edges,function,case,all,return,vertices,co,group,edges,flat,map,new,emit,one,edge,per,node,k,vv,ev,where,0,equal,to,0,with,new,apply,co,group,function,on,all,edges,k,vv,ev,t,edges,function,default,throw,new,illegal,argument,exception,illegal,edge,direction
Graph -> public <T> DataSet<T> groupReduceOnEdges(EdgesFunctionWithVertexValue<K, VV, EV, T> edgesFunction, 			EdgeDirection direction) throws IllegalArgumentException;1466789678;Groups by vertex and computes a GroupReduce transformation over the edge values of each vertex._The edgesFunction applied on the edges has access to both the id and the value_of the grouping vertex.__For each vertex, the edgesFunction can iterate over all edges of this vertex_with the specified direction, and emit any number of output elements, including none.__@param edgesFunction the group reduce function to apply to the neighboring edges of each vertex._@param direction the edge direction (in-, out-, all-)._@param <T> the output type_@return a DataSet containing elements of type T_@throws IllegalArgumentException;public <T> DataSet<T> groupReduceOnEdges(EdgesFunctionWithVertexValue<K, VV, EV, T> edgesFunction,_			EdgeDirection direction) throws IllegalArgumentException {__		switch (direction) {_		case IN:_			return vertices.coGroup(edges).where(0).equalTo(1)_					.with(new ApplyCoGroupFunction<K, VV, EV, T>(edgesFunction))__		case OUT:_			return vertices.coGroup(edges).where(0).equalTo(0)_					.with(new ApplyCoGroupFunction<K, VV, EV, T>(edgesFunction))__		case ALL:_			return vertices.coGroup(edges.flatMap(new EmitOneEdgePerNode<K, VV, EV>()))_					.where(0).equalTo(0).with(new ApplyCoGroupFunctionOnAllEdges<K, VV, EV, T>(edgesFunction))__		default:_			throw new IllegalArgumentException("Illegal edge direction")__		}_	};groups,by,vertex,and,computes,a,group,reduce,transformation,over,the,edge,values,of,each,vertex,the,edges,function,applied,on,the,edges,has,access,to,both,the,id,and,the,value,of,the,grouping,vertex,for,each,vertex,the,edges,function,can,iterate,over,all,edges,of,this,vertex,with,the,specified,direction,and,emit,any,number,of,output,elements,including,none,param,edges,function,the,group,reduce,function,to,apply,to,the,neighboring,edges,of,each,vertex,param,direction,the,edge,direction,in,out,all,param,t,the,output,type,return,a,data,set,containing,elements,of,type,t,throws,illegal,argument,exception;public,t,data,set,t,group,reduce,on,edges,edges,function,with,vertex,value,k,vv,ev,t,edges,function,edge,direction,direction,throws,illegal,argument,exception,switch,direction,case,in,return,vertices,co,group,edges,where,0,equal,to,1,with,new,apply,co,group,function,k,vv,ev,t,edges,function,case,out,return,vertices,co,group,edges,where,0,equal,to,0,with,new,apply,co,group,function,k,vv,ev,t,edges,function,case,all,return,vertices,co,group,edges,flat,map,new,emit,one,edge,per,node,k,vv,ev,where,0,equal,to,0,with,new,apply,co,group,function,on,all,edges,k,vv,ev,t,edges,function,default,throw,new,illegal,argument,exception,illegal,edge,direction
Graph -> public <T> DataSet<T> groupReduceOnEdges(EdgesFunctionWithVertexValue<K, VV, EV, T> edgesFunction, 			EdgeDirection direction) throws IllegalArgumentException;1467140656;Groups by vertex and computes a GroupReduce transformation over the edge values of each vertex._The edgesFunction applied on the edges has access to both the id and the value_of the grouping vertex.__For each vertex, the edgesFunction can iterate over all edges of this vertex_with the specified direction, and emit any number of output elements, including none.__@param edgesFunction the group reduce function to apply to the neighboring edges of each vertex._@param direction the edge direction (in-, out-, all-)._@param <T> the output type_@return a DataSet containing elements of type T_@throws IllegalArgumentException;public <T> DataSet<T> groupReduceOnEdges(EdgesFunctionWithVertexValue<K, VV, EV, T> edgesFunction,_			EdgeDirection direction) throws IllegalArgumentException {__		switch (direction) {_		case IN:_			return vertices.coGroup(edges).where(0).equalTo(1)_					.with(new ApplyCoGroupFunction<K, VV, EV, T>(edgesFunction))__		case OUT:_			return vertices.coGroup(edges).where(0).equalTo(0)_					.with(new ApplyCoGroupFunction<K, VV, EV, T>(edgesFunction))__		case ALL:_			return vertices.coGroup(edges.flatMap(new EmitOneEdgePerNode<K, VV, EV>()))_					.where(0).equalTo(0).with(new ApplyCoGroupFunctionOnAllEdges<K, VV, EV, T>(edgesFunction))__		default:_			throw new IllegalArgumentException("Illegal edge direction")__		}_	};groups,by,vertex,and,computes,a,group,reduce,transformation,over,the,edge,values,of,each,vertex,the,edges,function,applied,on,the,edges,has,access,to,both,the,id,and,the,value,of,the,grouping,vertex,for,each,vertex,the,edges,function,can,iterate,over,all,edges,of,this,vertex,with,the,specified,direction,and,emit,any,number,of,output,elements,including,none,param,edges,function,the,group,reduce,function,to,apply,to,the,neighboring,edges,of,each,vertex,param,direction,the,edge,direction,in,out,all,param,t,the,output,type,return,a,data,set,containing,elements,of,type,t,throws,illegal,argument,exception;public,t,data,set,t,group,reduce,on,edges,edges,function,with,vertex,value,k,vv,ev,t,edges,function,edge,direction,direction,throws,illegal,argument,exception,switch,direction,case,in,return,vertices,co,group,edges,where,0,equal,to,1,with,new,apply,co,group,function,k,vv,ev,t,edges,function,case,out,return,vertices,co,group,edges,where,0,equal,to,0,with,new,apply,co,group,function,k,vv,ev,t,edges,function,case,all,return,vertices,co,group,edges,flat,map,new,emit,one,edge,per,node,k,vv,ev,where,0,equal,to,0,with,new,apply,co,group,function,on,all,edges,k,vv,ev,t,edges,function,default,throw,new,illegal,argument,exception,illegal,edge,direction
Graph -> public <T> DataSet<T> groupReduceOnEdges(EdgesFunctionWithVertexValue<K, VV, EV, T> edgesFunction, 			EdgeDirection direction) throws IllegalArgumentException;1467306272;Groups by vertex and computes a GroupReduce transformation over the edge values of each vertex._The edgesFunction applied on the edges has access to both the id and the value_of the grouping vertex.__For each vertex, the edgesFunction can iterate over all edges of this vertex_with the specified direction, and emit any number of output elements, including none.__@param edgesFunction the group reduce function to apply to the neighboring edges of each vertex._@param direction the edge direction (in-, out-, all-)._@param <T> the output type_@return a DataSet containing elements of type T_@throws IllegalArgumentException;public <T> DataSet<T> groupReduceOnEdges(EdgesFunctionWithVertexValue<K, VV, EV, T> edgesFunction,_			EdgeDirection direction) throws IllegalArgumentException {__		switch (direction) {_		case IN:_			return vertices.coGroup(edges).where(0).equalTo(1)_					.with(new ApplyCoGroupFunction<K, VV, EV, T>(edgesFunction))__		case OUT:_			return vertices.coGroup(edges).where(0).equalTo(0)_					.with(new ApplyCoGroupFunction<K, VV, EV, T>(edgesFunction))__		case ALL:_			return vertices.coGroup(edges.flatMap(new EmitOneEdgePerNode<K, VV, EV>()))_					.where(0).equalTo(0).with(new ApplyCoGroupFunctionOnAllEdges<K, VV, EV, T>(edgesFunction))__		default:_			throw new IllegalArgumentException("Illegal edge direction")__		}_	};groups,by,vertex,and,computes,a,group,reduce,transformation,over,the,edge,values,of,each,vertex,the,edges,function,applied,on,the,edges,has,access,to,both,the,id,and,the,value,of,the,grouping,vertex,for,each,vertex,the,edges,function,can,iterate,over,all,edges,of,this,vertex,with,the,specified,direction,and,emit,any,number,of,output,elements,including,none,param,edges,function,the,group,reduce,function,to,apply,to,the,neighboring,edges,of,each,vertex,param,direction,the,edge,direction,in,out,all,param,t,the,output,type,return,a,data,set,containing,elements,of,type,t,throws,illegal,argument,exception;public,t,data,set,t,group,reduce,on,edges,edges,function,with,vertex,value,k,vv,ev,t,edges,function,edge,direction,direction,throws,illegal,argument,exception,switch,direction,case,in,return,vertices,co,group,edges,where,0,equal,to,1,with,new,apply,co,group,function,k,vv,ev,t,edges,function,case,out,return,vertices,co,group,edges,where,0,equal,to,0,with,new,apply,co,group,function,k,vv,ev,t,edges,function,case,all,return,vertices,co,group,edges,flat,map,new,emit,one,edge,per,node,k,vv,ev,where,0,equal,to,0,with,new,apply,co,group,function,on,all,edges,k,vv,ev,t,edges,function,default,throw,new,illegal,argument,exception,illegal,edge,direction
Graph -> public <T> DataSet<T> groupReduceOnEdges(EdgesFunctionWithVertexValue<K, VV, EV, T> edgesFunction, 			EdgeDirection direction) throws IllegalArgumentException;1470042815;Groups by vertex and computes a GroupReduce transformation over the edge values of each vertex._The edgesFunction applied on the edges has access to both the id and the value_of the grouping vertex.__For each vertex, the edgesFunction can iterate over all edges of this vertex_with the specified direction, and emit any number of output elements, including none.__@param edgesFunction the group reduce function to apply to the neighboring edges of each vertex._@param direction the edge direction (in-, out-, all-)._@param <T> the output type_@return a DataSet containing elements of type T_@throws IllegalArgumentException;public <T> DataSet<T> groupReduceOnEdges(EdgesFunctionWithVertexValue<K, VV, EV, T> edgesFunction,_			EdgeDirection direction) throws IllegalArgumentException {__		switch (direction) {_		case IN:_			return vertices.coGroup(edges).where(0).equalTo(1)_					.with(new ApplyCoGroupFunction<K, VV, EV, T>(edgesFunction))__		case OUT:_			return vertices.coGroup(edges).where(0).equalTo(0)_					.with(new ApplyCoGroupFunction<K, VV, EV, T>(edgesFunction))__		case ALL:_			return vertices.coGroup(edges.flatMap(new EmitOneEdgePerNode<K, VV, EV>()))_					.where(0).equalTo(0).with(new ApplyCoGroupFunctionOnAllEdges<K, VV, EV, T>(edgesFunction))__		default:_			throw new IllegalArgumentException("Illegal edge direction")__		}_	};groups,by,vertex,and,computes,a,group,reduce,transformation,over,the,edge,values,of,each,vertex,the,edges,function,applied,on,the,edges,has,access,to,both,the,id,and,the,value,of,the,grouping,vertex,for,each,vertex,the,edges,function,can,iterate,over,all,edges,of,this,vertex,with,the,specified,direction,and,emit,any,number,of,output,elements,including,none,param,edges,function,the,group,reduce,function,to,apply,to,the,neighboring,edges,of,each,vertex,param,direction,the,edge,direction,in,out,all,param,t,the,output,type,return,a,data,set,containing,elements,of,type,t,throws,illegal,argument,exception;public,t,data,set,t,group,reduce,on,edges,edges,function,with,vertex,value,k,vv,ev,t,edges,function,edge,direction,direction,throws,illegal,argument,exception,switch,direction,case,in,return,vertices,co,group,edges,where,0,equal,to,1,with,new,apply,co,group,function,k,vv,ev,t,edges,function,case,out,return,vertices,co,group,edges,where,0,equal,to,0,with,new,apply,co,group,function,k,vv,ev,t,edges,function,case,all,return,vertices,co,group,edges,flat,map,new,emit,one,edge,per,node,k,vv,ev,where,0,equal,to,0,with,new,apply,co,group,function,on,all,edges,k,vv,ev,t,edges,function,default,throw,new,illegal,argument,exception,illegal,edge,direction
Graph -> public <T> DataSet<T> groupReduceOnEdges(EdgesFunctionWithVertexValue<K, VV, EV, T> edgesFunction, 			EdgeDirection direction) throws IllegalArgumentException;1475684776;Groups by vertex and computes a GroupReduce transformation over the edge values of each vertex._The edgesFunction applied on the edges has access to both the id and the value_of the grouping vertex.__For each vertex, the edgesFunction can iterate over all edges of this vertex_with the specified direction, and emit any number of output elements, including none.__@param edgesFunction the group reduce function to apply to the neighboring edges of each vertex._@param direction the edge direction (in-, out-, all-)._@param <T> the output type_@return a DataSet containing elements of type T_@throws IllegalArgumentException;public <T> DataSet<T> groupReduceOnEdges(EdgesFunctionWithVertexValue<K, VV, EV, T> edgesFunction,_			EdgeDirection direction) throws IllegalArgumentException {__		switch (direction) {_		case IN:_			return vertices.coGroup(edges).where(0).equalTo(1)_					.with(new ApplyCoGroupFunction<>(edgesFunction))__		case OUT:_			return vertices.coGroup(edges).where(0).equalTo(0)_					.with(new ApplyCoGroupFunction<>(edgesFunction))__		case ALL:_			return vertices.coGroup(edges.flatMap(new EmitOneEdgePerNode<K, VV, EV>()))_					.where(0).equalTo(0).with(new ApplyCoGroupFunctionOnAllEdges<>(edgesFunction))__		default:_			throw new IllegalArgumentException("Illegal edge direction")__		}_	};groups,by,vertex,and,computes,a,group,reduce,transformation,over,the,edge,values,of,each,vertex,the,edges,function,applied,on,the,edges,has,access,to,both,the,id,and,the,value,of,the,grouping,vertex,for,each,vertex,the,edges,function,can,iterate,over,all,edges,of,this,vertex,with,the,specified,direction,and,emit,any,number,of,output,elements,including,none,param,edges,function,the,group,reduce,function,to,apply,to,the,neighboring,edges,of,each,vertex,param,direction,the,edge,direction,in,out,all,param,t,the,output,type,return,a,data,set,containing,elements,of,type,t,throws,illegal,argument,exception;public,t,data,set,t,group,reduce,on,edges,edges,function,with,vertex,value,k,vv,ev,t,edges,function,edge,direction,direction,throws,illegal,argument,exception,switch,direction,case,in,return,vertices,co,group,edges,where,0,equal,to,1,with,new,apply,co,group,function,edges,function,case,out,return,vertices,co,group,edges,where,0,equal,to,0,with,new,apply,co,group,function,edges,function,case,all,return,vertices,co,group,edges,flat,map,new,emit,one,edge,per,node,k,vv,ev,where,0,equal,to,0,with,new,apply,co,group,function,on,all,edges,edges,function,default,throw,new,illegal,argument,exception,illegal,edge,direction
Graph -> public <T> DataSet<T> groupReduceOnEdges(EdgesFunctionWithVertexValue<K, VV, EV, T> edgesFunction, 			EdgeDirection direction) throws IllegalArgumentException;1475685606;Groups by vertex and computes a GroupReduce transformation over the edge values of each vertex._The edgesFunction applied on the edges has access to both the id and the value_of the grouping vertex.__For each vertex, the edgesFunction can iterate over all edges of this vertex_with the specified direction, and emit any number of output elements, including none.__@param edgesFunction the group reduce function to apply to the neighboring edges of each vertex._@param direction the edge direction (in-, out-, all-)._@param <T> the output type_@return a DataSet containing elements of type T_@throws IllegalArgumentException;public <T> DataSet<T> groupReduceOnEdges(EdgesFunctionWithVertexValue<K, VV, EV, T> edgesFunction,_			EdgeDirection direction) throws IllegalArgumentException {__		switch (direction) {_		case IN:_			return vertices.coGroup(edges).where(0).equalTo(1)_					.with(new ApplyCoGroupFunction<>(edgesFunction))__		case OUT:_			return vertices.coGroup(edges).where(0).equalTo(0)_					.with(new ApplyCoGroupFunction<>(edgesFunction))__		case ALL:_			return vertices.coGroup(edges.flatMap(new EmitOneEdgePerNode<K, VV, EV>()))_					.where(0).equalTo(0).with(new ApplyCoGroupFunctionOnAllEdges<>(edgesFunction))__		default:_			throw new IllegalArgumentException("Illegal edge direction")__		}_	};groups,by,vertex,and,computes,a,group,reduce,transformation,over,the,edge,values,of,each,vertex,the,edges,function,applied,on,the,edges,has,access,to,both,the,id,and,the,value,of,the,grouping,vertex,for,each,vertex,the,edges,function,can,iterate,over,all,edges,of,this,vertex,with,the,specified,direction,and,emit,any,number,of,output,elements,including,none,param,edges,function,the,group,reduce,function,to,apply,to,the,neighboring,edges,of,each,vertex,param,direction,the,edge,direction,in,out,all,param,t,the,output,type,return,a,data,set,containing,elements,of,type,t,throws,illegal,argument,exception;public,t,data,set,t,group,reduce,on,edges,edges,function,with,vertex,value,k,vv,ev,t,edges,function,edge,direction,direction,throws,illegal,argument,exception,switch,direction,case,in,return,vertices,co,group,edges,where,0,equal,to,1,with,new,apply,co,group,function,edges,function,case,out,return,vertices,co,group,edges,where,0,equal,to,0,with,new,apply,co,group,function,edges,function,case,all,return,vertices,co,group,edges,flat,map,new,emit,one,edge,per,node,k,vv,ev,where,0,equal,to,0,with,new,apply,co,group,function,on,all,edges,edges,function,default,throw,new,illegal,argument,exception,illegal,edge,direction
Graph -> public <T> DataSet<T> groupReduceOnEdges(EdgesFunctionWithVertexValue<K, VV, EV, T> edgesFunction, 			EdgeDirection direction) throws IllegalArgumentException;1481745825;Groups by vertex and computes a GroupReduce transformation over the edge values of each vertex._The edgesFunction applied on the edges has access to both the id and the value_of the grouping vertex.__For each vertex, the edgesFunction can iterate over all edges of this vertex_with the specified direction, and emit any number of output elements, including none.__@param edgesFunction the group reduce function to apply to the neighboring edges of each vertex._@param direction the edge direction (in-, out-, all-)._@param <T> the output type_@return a DataSet containing elements of type T_@throws IllegalArgumentException;public <T> DataSet<T> groupReduceOnEdges(EdgesFunctionWithVertexValue<K, VV, EV, T> edgesFunction,_			EdgeDirection direction) throws IllegalArgumentException {__		switch (direction) {_		case IN:_			return vertices.coGroup(edges).where(0).equalTo(1)_					.with(new ApplyCoGroupFunction<>(edgesFunction)).name("GroupReduce on in-edges")__		case OUT:_			return vertices.coGroup(edges).where(0).equalTo(0)_					.with(new ApplyCoGroupFunction<>(edgesFunction)).name("GroupReduce on out-edges")__		case ALL:_			return vertices.coGroup(edges.flatMap(new EmitOneEdgePerNode<K, VV, EV>())_						.name("Emit edge"))_					.where(0).equalTo(0).with(new ApplyCoGroupFunctionOnAllEdges<>(edgesFunction))_						.name("GroupReduce on in- and out-edges")__		default:_			throw new IllegalArgumentException("Illegal edge direction")__		}_	};groups,by,vertex,and,computes,a,group,reduce,transformation,over,the,edge,values,of,each,vertex,the,edges,function,applied,on,the,edges,has,access,to,both,the,id,and,the,value,of,the,grouping,vertex,for,each,vertex,the,edges,function,can,iterate,over,all,edges,of,this,vertex,with,the,specified,direction,and,emit,any,number,of,output,elements,including,none,param,edges,function,the,group,reduce,function,to,apply,to,the,neighboring,edges,of,each,vertex,param,direction,the,edge,direction,in,out,all,param,t,the,output,type,return,a,data,set,containing,elements,of,type,t,throws,illegal,argument,exception;public,t,data,set,t,group,reduce,on,edges,edges,function,with,vertex,value,k,vv,ev,t,edges,function,edge,direction,direction,throws,illegal,argument,exception,switch,direction,case,in,return,vertices,co,group,edges,where,0,equal,to,1,with,new,apply,co,group,function,edges,function,name,group,reduce,on,in,edges,case,out,return,vertices,co,group,edges,where,0,equal,to,0,with,new,apply,co,group,function,edges,function,name,group,reduce,on,out,edges,case,all,return,vertices,co,group,edges,flat,map,new,emit,one,edge,per,node,k,vv,ev,name,emit,edge,where,0,equal,to,0,with,new,apply,co,group,function,on,all,edges,edges,function,name,group,reduce,on,in,and,out,edges,default,throw,new,illegal,argument,exception,illegal,edge,direction
Graph -> public <T> DataSet<T> groupReduceOnEdges(EdgesFunctionWithVertexValue<K, VV, EV, T> edgesFunction, 			EdgeDirection direction) throws IllegalArgumentException;1481881009;Groups by vertex and computes a GroupReduce transformation over the edge values of each vertex._The edgesFunction applied on the edges has access to both the id and the value_of the grouping vertex.__For each vertex, the edgesFunction can iterate over all edges of this vertex_with the specified direction, and emit any number of output elements, including none.__@param edgesFunction the group reduce function to apply to the neighboring edges of each vertex._@param direction the edge direction (in-, out-, all-)._@param <T> the output type_@return a DataSet containing elements of type T_@throws IllegalArgumentException;public <T> DataSet<T> groupReduceOnEdges(EdgesFunctionWithVertexValue<K, VV, EV, T> edgesFunction,_			EdgeDirection direction) throws IllegalArgumentException {__		switch (direction) {_		case IN:_			return vertices.coGroup(edges).where(0).equalTo(1)_					.with(new ApplyCoGroupFunction<>(edgesFunction)).name("GroupReduce on in-edges")__		case OUT:_			return vertices.coGroup(edges).where(0).equalTo(0)_					.with(new ApplyCoGroupFunction<>(edgesFunction)).name("GroupReduce on out-edges")__		case ALL:_			return vertices.coGroup(edges.flatMap(new EmitOneEdgePerNode<K, EV>())_						.name("Emit edge"))_					.where(0).equalTo(0).with(new ApplyCoGroupFunctionOnAllEdges<>(edgesFunction))_						.name("GroupReduce on in- and out-edges")__		default:_			throw new IllegalArgumentException("Illegal edge direction")__		}_	};groups,by,vertex,and,computes,a,group,reduce,transformation,over,the,edge,values,of,each,vertex,the,edges,function,applied,on,the,edges,has,access,to,both,the,id,and,the,value,of,the,grouping,vertex,for,each,vertex,the,edges,function,can,iterate,over,all,edges,of,this,vertex,with,the,specified,direction,and,emit,any,number,of,output,elements,including,none,param,edges,function,the,group,reduce,function,to,apply,to,the,neighboring,edges,of,each,vertex,param,direction,the,edge,direction,in,out,all,param,t,the,output,type,return,a,data,set,containing,elements,of,type,t,throws,illegal,argument,exception;public,t,data,set,t,group,reduce,on,edges,edges,function,with,vertex,value,k,vv,ev,t,edges,function,edge,direction,direction,throws,illegal,argument,exception,switch,direction,case,in,return,vertices,co,group,edges,where,0,equal,to,1,with,new,apply,co,group,function,edges,function,name,group,reduce,on,in,edges,case,out,return,vertices,co,group,edges,where,0,equal,to,0,with,new,apply,co,group,function,edges,function,name,group,reduce,on,out,edges,case,all,return,vertices,co,group,edges,flat,map,new,emit,one,edge,per,node,k,ev,name,emit,edge,where,0,equal,to,0,with,new,apply,co,group,function,on,all,edges,edges,function,name,group,reduce,on,in,and,out,edges,default,throw,new,illegal,argument,exception,illegal,edge,direction
Graph -> public <T> DataSet<T> groupReduceOnEdges(EdgesFunctionWithVertexValue<K, VV, EV, T> edgesFunction, 			EdgeDirection direction) throws IllegalArgumentException;1484160227;Groups by vertex and computes a GroupReduce transformation over the edge values of each vertex._The edgesFunction applied on the edges has access to both the id and the value_of the grouping vertex.__For each vertex, the edgesFunction can iterate over all edges of this vertex_with the specified direction, and emit any number of output elements, including none.__@param edgesFunction the group reduce function to apply to the neighboring edges of each vertex._@param direction the edge direction (in-, out-, all-)._@param <T> the output type_@return a DataSet containing elements of type T_@throws IllegalArgumentException;public <T> DataSet<T> groupReduceOnEdges(EdgesFunctionWithVertexValue<K, VV, EV, T> edgesFunction,_			EdgeDirection direction) throws IllegalArgumentException {__		switch (direction) {_		case IN:_			return vertices.coGroup(edges).where(0).equalTo(1)_					.with(new ApplyCoGroupFunction<>(edgesFunction)).name("GroupReduce on in-edges")__		case OUT:_			return vertices.coGroup(edges).where(0).equalTo(0)_					.with(new ApplyCoGroupFunction<>(edgesFunction)).name("GroupReduce on out-edges")__		case ALL:_			return vertices.coGroup(edges.flatMap(new EmitOneEdgePerNode<K, EV>())_						.name("Emit edge"))_					.where(0).equalTo(0).with(new ApplyCoGroupFunctionOnAllEdges<>(edgesFunction))_						.name("GroupReduce on in- and out-edges")__		default:_			throw new IllegalArgumentException("Illegal edge direction")__		}_	};groups,by,vertex,and,computes,a,group,reduce,transformation,over,the,edge,values,of,each,vertex,the,edges,function,applied,on,the,edges,has,access,to,both,the,id,and,the,value,of,the,grouping,vertex,for,each,vertex,the,edges,function,can,iterate,over,all,edges,of,this,vertex,with,the,specified,direction,and,emit,any,number,of,output,elements,including,none,param,edges,function,the,group,reduce,function,to,apply,to,the,neighboring,edges,of,each,vertex,param,direction,the,edge,direction,in,out,all,param,t,the,output,type,return,a,data,set,containing,elements,of,type,t,throws,illegal,argument,exception;public,t,data,set,t,group,reduce,on,edges,edges,function,with,vertex,value,k,vv,ev,t,edges,function,edge,direction,direction,throws,illegal,argument,exception,switch,direction,case,in,return,vertices,co,group,edges,where,0,equal,to,1,with,new,apply,co,group,function,edges,function,name,group,reduce,on,in,edges,case,out,return,vertices,co,group,edges,where,0,equal,to,0,with,new,apply,co,group,function,edges,function,name,group,reduce,on,out,edges,case,all,return,vertices,co,group,edges,flat,map,new,emit,one,edge,per,node,k,ev,name,emit,edge,where,0,equal,to,0,with,new,apply,co,group,function,on,all,edges,edges,function,name,group,reduce,on,in,and,out,edges,default,throw,new,illegal,argument,exception,illegal,edge,direction
Graph -> public <T> DataSet<T> groupReduceOnEdges(EdgesFunctionWithVertexValue<K, VV, EV, T> edgesFunction, 			EdgeDirection direction) throws IllegalArgumentException;1484685504;Groups by vertex and computes a GroupReduce transformation over the edge values of each vertex._The edgesFunction applied on the edges has access to both the id and the value_of the grouping vertex.__For each vertex, the edgesFunction can iterate over all edges of this vertex_with the specified direction, and emit any number of output elements, including none.__@param edgesFunction the group reduce function to apply to the neighboring edges of each vertex._@param direction the edge direction (in-, out-, all-)._@param <T> the output type_@return a DataSet containing elements of type T_@throws IllegalArgumentException;public <T> DataSet<T> groupReduceOnEdges(EdgesFunctionWithVertexValue<K, VV, EV, T> edgesFunction,_			EdgeDirection direction) throws IllegalArgumentException {__		switch (direction) {_		case IN:_			return vertices.coGroup(edges).where(0).equalTo(1)_					.with(new ApplyCoGroupFunction<>(edgesFunction)).name("GroupReduce on in-edges")__		case OUT:_			return vertices.coGroup(edges).where(0).equalTo(0)_					.with(new ApplyCoGroupFunction<>(edgesFunction)).name("GroupReduce on out-edges")__		case ALL:_			return vertices.coGroup(edges.flatMap(new EmitOneEdgePerNode<K, EV>())_						.name("Emit edge"))_					.where(0).equalTo(0).with(new ApplyCoGroupFunctionOnAllEdges<>(edgesFunction))_						.name("GroupReduce on in- and out-edges")__		default:_			throw new IllegalArgumentException("Illegal edge direction")__		}_	};groups,by,vertex,and,computes,a,group,reduce,transformation,over,the,edge,values,of,each,vertex,the,edges,function,applied,on,the,edges,has,access,to,both,the,id,and,the,value,of,the,grouping,vertex,for,each,vertex,the,edges,function,can,iterate,over,all,edges,of,this,vertex,with,the,specified,direction,and,emit,any,number,of,output,elements,including,none,param,edges,function,the,group,reduce,function,to,apply,to,the,neighboring,edges,of,each,vertex,param,direction,the,edge,direction,in,out,all,param,t,the,output,type,return,a,data,set,containing,elements,of,type,t,throws,illegal,argument,exception;public,t,data,set,t,group,reduce,on,edges,edges,function,with,vertex,value,k,vv,ev,t,edges,function,edge,direction,direction,throws,illegal,argument,exception,switch,direction,case,in,return,vertices,co,group,edges,where,0,equal,to,1,with,new,apply,co,group,function,edges,function,name,group,reduce,on,in,edges,case,out,return,vertices,co,group,edges,where,0,equal,to,0,with,new,apply,co,group,function,edges,function,name,group,reduce,on,out,edges,case,all,return,vertices,co,group,edges,flat,map,new,emit,one,edge,per,node,k,ev,name,emit,edge,where,0,equal,to,0,with,new,apply,co,group,function,on,all,edges,edges,function,name,group,reduce,on,in,and,out,edges,default,throw,new,illegal,argument,exception,illegal,edge,direction
Graph -> public <T> DataSet<T> groupReduceOnEdges(EdgesFunctionWithVertexValue<K, VV, EV, T> edgesFunction, 			EdgeDirection direction) throws IllegalArgumentException;1489068942;Groups by vertex and computes a GroupReduce transformation over the edge values of each vertex._The edgesFunction applied on the edges has access to both the id and the value_of the grouping vertex.__For each vertex, the edgesFunction can iterate over all edges of this vertex_with the specified direction, and emit any number of output elements, including none.__@param edgesFunction the group reduce function to apply to the neighboring edges of each vertex._@param direction the edge direction (in-, out-, all-)._@param <T> the output type_@return a DataSet containing elements of type T_@throws IllegalArgumentException;public <T> DataSet<T> groupReduceOnEdges(EdgesFunctionWithVertexValue<K, VV, EV, T> edgesFunction,_			EdgeDirection direction) throws IllegalArgumentException {__		switch (direction) {_		case IN:_			return vertices.coGroup(edges).where(0).equalTo(1)_					.with(new ApplyCoGroupFunction<>(edgesFunction)).name("GroupReduce on in-edges")__		case OUT:_			return vertices.coGroup(edges).where(0).equalTo(0)_					.with(new ApplyCoGroupFunction<>(edgesFunction)).name("GroupReduce on out-edges")__		case ALL:_			return vertices.coGroup(edges.flatMap(new EmitOneEdgePerNode<K, EV>())_						.name("Emit edge"))_					.where(0).equalTo(0).with(new ApplyCoGroupFunctionOnAllEdges<>(edgesFunction))_						.name("GroupReduce on in- and out-edges")__		default:_			throw new IllegalArgumentException("Illegal edge direction")__		}_	};groups,by,vertex,and,computes,a,group,reduce,transformation,over,the,edge,values,of,each,vertex,the,edges,function,applied,on,the,edges,has,access,to,both,the,id,and,the,value,of,the,grouping,vertex,for,each,vertex,the,edges,function,can,iterate,over,all,edges,of,this,vertex,with,the,specified,direction,and,emit,any,number,of,output,elements,including,none,param,edges,function,the,group,reduce,function,to,apply,to,the,neighboring,edges,of,each,vertex,param,direction,the,edge,direction,in,out,all,param,t,the,output,type,return,a,data,set,containing,elements,of,type,t,throws,illegal,argument,exception;public,t,data,set,t,group,reduce,on,edges,edges,function,with,vertex,value,k,vv,ev,t,edges,function,edge,direction,direction,throws,illegal,argument,exception,switch,direction,case,in,return,vertices,co,group,edges,where,0,equal,to,1,with,new,apply,co,group,function,edges,function,name,group,reduce,on,in,edges,case,out,return,vertices,co,group,edges,where,0,equal,to,0,with,new,apply,co,group,function,edges,function,name,group,reduce,on,out,edges,case,all,return,vertices,co,group,edges,flat,map,new,emit,one,edge,per,node,k,ev,name,emit,edge,where,0,equal,to,0,with,new,apply,co,group,function,on,all,edges,edges,function,name,group,reduce,on,in,and,out,edges,default,throw,new,illegal,argument,exception,illegal,edge,direction
Graph -> public <T> DataSet<T> groupReduceOnEdges(EdgesFunctionWithVertexValue<K, VV, EV, T> edgesFunction, 			EdgeDirection direction) throws IllegalArgumentException;1490973446;Groups by vertex and computes a GroupReduce transformation over the edge values of each vertex._The edgesFunction applied on the edges has access to both the id and the value_of the grouping vertex.__For each vertex, the edgesFunction can iterate over all edges of this vertex_with the specified direction, and emit any number of output elements, including none.__@param edgesFunction the group reduce function to apply to the neighboring edges of each vertex._@param direction the edge direction (in-, out-, all-)._@param <T> the output type_@return a DataSet containing elements of type T_@throws IllegalArgumentException;public <T> DataSet<T> groupReduceOnEdges(EdgesFunctionWithVertexValue<K, VV, EV, T> edgesFunction,_			EdgeDirection direction) throws IllegalArgumentException {__		switch (direction) {_		case IN:_			return vertices.coGroup(edges).where(0).equalTo(1)_					.with(new ApplyCoGroupFunction<>(edgesFunction)).name("GroupReduce on in-edges")__		case OUT:_			return vertices.coGroup(edges).where(0).equalTo(0)_					.with(new ApplyCoGroupFunction<>(edgesFunction)).name("GroupReduce on out-edges")__		case ALL:_			return vertices.coGroup(edges.flatMap(new EmitOneEdgePerNode<K, EV>())_						.name("Emit edge"))_					.where(0).equalTo(0).with(new ApplyCoGroupFunctionOnAllEdges<>(edgesFunction))_						.name("GroupReduce on in- and out-edges")__		default:_			throw new IllegalArgumentException("Illegal edge direction")__		}_	};groups,by,vertex,and,computes,a,group,reduce,transformation,over,the,edge,values,of,each,vertex,the,edges,function,applied,on,the,edges,has,access,to,both,the,id,and,the,value,of,the,grouping,vertex,for,each,vertex,the,edges,function,can,iterate,over,all,edges,of,this,vertex,with,the,specified,direction,and,emit,any,number,of,output,elements,including,none,param,edges,function,the,group,reduce,function,to,apply,to,the,neighboring,edges,of,each,vertex,param,direction,the,edge,direction,in,out,all,param,t,the,output,type,return,a,data,set,containing,elements,of,type,t,throws,illegal,argument,exception;public,t,data,set,t,group,reduce,on,edges,edges,function,with,vertex,value,k,vv,ev,t,edges,function,edge,direction,direction,throws,illegal,argument,exception,switch,direction,case,in,return,vertices,co,group,edges,where,0,equal,to,1,with,new,apply,co,group,function,edges,function,name,group,reduce,on,in,edges,case,out,return,vertices,co,group,edges,where,0,equal,to,0,with,new,apply,co,group,function,edges,function,name,group,reduce,on,out,edges,case,all,return,vertices,co,group,edges,flat,map,new,emit,one,edge,per,node,k,ev,name,emit,edge,where,0,equal,to,0,with,new,apply,co,group,function,on,all,edges,edges,function,name,group,reduce,on,in,and,out,edges,default,throw,new,illegal,argument,exception,illegal,edge,direction
Graph -> public <T> DataSet<T> groupReduceOnEdges(EdgesFunctionWithVertexValue<K, VV, EV, T> edgesFunction, 			EdgeDirection direction) throws IllegalArgumentException;1495819075;Groups by vertex and computes a GroupReduce transformation over the edge values of each vertex._The edgesFunction applied on the edges has access to both the id and the value_of the grouping vertex.__<p>For each vertex, the edgesFunction can iterate over all edges of this vertex_with the specified direction, and emit any number of output elements, including none.__@param edgesFunction the group reduce function to apply to the neighboring edges of each vertex._@param direction the edge direction (in-, out-, all-)._@param <T> the output type_@return a DataSet containing elements of type T_@throws IllegalArgumentException;public <T> DataSet<T> groupReduceOnEdges(EdgesFunctionWithVertexValue<K, VV, EV, T> edgesFunction,_			EdgeDirection direction) throws IllegalArgumentException {__		switch (direction) {_		case IN:_			return vertices.coGroup(edges).where(0).equalTo(1)_					.with(new ApplyCoGroupFunction<>(edgesFunction)).name("GroupReduce on in-edges")__		case OUT:_			return vertices.coGroup(edges).where(0).equalTo(0)_					.with(new ApplyCoGroupFunction<>(edgesFunction)).name("GroupReduce on out-edges")__		case ALL:_			return vertices.coGroup(edges.flatMap(new EmitOneEdgePerNode<K, EV>())_						.name("Emit edge"))_					.where(0).equalTo(0).with(new ApplyCoGroupFunctionOnAllEdges<>(edgesFunction))_						.name("GroupReduce on in- and out-edges")__		default:_			throw new IllegalArgumentException("Illegal edge direction")__		}_	};groups,by,vertex,and,computes,a,group,reduce,transformation,over,the,edge,values,of,each,vertex,the,edges,function,applied,on,the,edges,has,access,to,both,the,id,and,the,value,of,the,grouping,vertex,p,for,each,vertex,the,edges,function,can,iterate,over,all,edges,of,this,vertex,with,the,specified,direction,and,emit,any,number,of,output,elements,including,none,param,edges,function,the,group,reduce,function,to,apply,to,the,neighboring,edges,of,each,vertex,param,direction,the,edge,direction,in,out,all,param,t,the,output,type,return,a,data,set,containing,elements,of,type,t,throws,illegal,argument,exception;public,t,data,set,t,group,reduce,on,edges,edges,function,with,vertex,value,k,vv,ev,t,edges,function,edge,direction,direction,throws,illegal,argument,exception,switch,direction,case,in,return,vertices,co,group,edges,where,0,equal,to,1,with,new,apply,co,group,function,edges,function,name,group,reduce,on,in,edges,case,out,return,vertices,co,group,edges,where,0,equal,to,0,with,new,apply,co,group,function,edges,function,name,group,reduce,on,out,edges,case,all,return,vertices,co,group,edges,flat,map,new,emit,one,edge,per,node,k,ev,name,emit,edge,where,0,equal,to,0,with,new,apply,co,group,function,on,all,edges,edges,function,name,group,reduce,on,in,and,out,edges,default,throw,new,illegal,argument,exception,illegal,edge,direction
Graph -> public <T> DataSet<T> groupReduceOnEdges(EdgesFunctionWithVertexValue<K, VV, EV, T> edgesFunction, 			EdgeDirection direction) throws IllegalArgumentException;1502111816;Groups by vertex and computes a GroupReduce transformation over the edge values of each vertex._The edgesFunction applied on the edges has access to both the id and the value_of the grouping vertex.__<p>For each vertex, the edgesFunction can iterate over all edges of this vertex_with the specified direction, and emit any number of output elements, including none.__@param edgesFunction the group reduce function to apply to the neighboring edges of each vertex._@param direction the edge direction (in-, out-, all-)._@param <T> the output type_@return a DataSet containing elements of type T_@throws IllegalArgumentException;public <T> DataSet<T> groupReduceOnEdges(EdgesFunctionWithVertexValue<K, VV, EV, T> edgesFunction,_			EdgeDirection direction) throws IllegalArgumentException {__		switch (direction) {_		case IN:_			return vertices.coGroup(edges).where(0).equalTo(1)_					.with(new ApplyCoGroupFunction<>(edgesFunction)).name("GroupReduce on in-edges")__		case OUT:_			return vertices.coGroup(edges).where(0).equalTo(0)_					.with(new ApplyCoGroupFunction<>(edgesFunction)).name("GroupReduce on out-edges")__		case ALL:_			return vertices.coGroup(edges.flatMap(new EmitOneEdgePerNode<>())_						.name("Emit edge"))_					.where(0).equalTo(0).with(new ApplyCoGroupFunctionOnAllEdges<>(edgesFunction))_						.name("GroupReduce on in- and out-edges")__		default:_			throw new IllegalArgumentException("Illegal edge direction")__		}_	};groups,by,vertex,and,computes,a,group,reduce,transformation,over,the,edge,values,of,each,vertex,the,edges,function,applied,on,the,edges,has,access,to,both,the,id,and,the,value,of,the,grouping,vertex,p,for,each,vertex,the,edges,function,can,iterate,over,all,edges,of,this,vertex,with,the,specified,direction,and,emit,any,number,of,output,elements,including,none,param,edges,function,the,group,reduce,function,to,apply,to,the,neighboring,edges,of,each,vertex,param,direction,the,edge,direction,in,out,all,param,t,the,output,type,return,a,data,set,containing,elements,of,type,t,throws,illegal,argument,exception;public,t,data,set,t,group,reduce,on,edges,edges,function,with,vertex,value,k,vv,ev,t,edges,function,edge,direction,direction,throws,illegal,argument,exception,switch,direction,case,in,return,vertices,co,group,edges,where,0,equal,to,1,with,new,apply,co,group,function,edges,function,name,group,reduce,on,in,edges,case,out,return,vertices,co,group,edges,where,0,equal,to,0,with,new,apply,co,group,function,edges,function,name,group,reduce,on,out,edges,case,all,return,vertices,co,group,edges,flat,map,new,emit,one,edge,per,node,name,emit,edge,where,0,equal,to,0,with,new,apply,co,group,function,on,all,edges,edges,function,name,group,reduce,on,in,and,out,edges,default,throw,new,illegal,argument,exception,illegal,edge,direction
Graph -> public Graph<K,VV,EV> difference(Graph<K,VV,EV> graph);1444404795;Performs Difference on the vertex and edge sets of the input graphs_removes common vertices and edges. If a source/target vertex is removed, its corresponding edge will also be removed_@param graph the graph to perform difference with_@return a new graph where the common vertices and edges have been removed;public Graph<K,VV,EV> difference(Graph<K,VV,EV> graph) {_		DataSet<Vertex<K,VV>> removeVerticesData = graph.getVertices()__		return this.removeVertices(removeVerticesData)__	};performs,difference,on,the,vertex,and,edge,sets,of,the,input,graphs,removes,common,vertices,and,edges,if,a,source,target,vertex,is,removed,its,corresponding,edge,will,also,be,removed,param,graph,the,graph,to,perform,difference,with,return,a,new,graph,where,the,common,vertices,and,edges,have,been,removed;public,graph,k,vv,ev,difference,graph,k,vv,ev,graph,data,set,vertex,k,vv,remove,vertices,data,graph,get,vertices,return,this,remove,vertices,remove,vertices,data
Graph -> public Graph<K,VV,EV> difference(Graph<K,VV,EV> graph);1445261977;Performs Difference on the vertex and edge sets of the input graphs_removes common vertices and edges. If a source/target vertex is removed, its corresponding edge will also be removed_@param graph the graph to perform difference with_@return a new graph where the common vertices and edges have been removed;public Graph<K,VV,EV> difference(Graph<K,VV,EV> graph) {_		DataSet<Vertex<K,VV>> removeVerticesData = graph.getVertices()__		return this.removeVertices(removeVerticesData)__	};performs,difference,on,the,vertex,and,edge,sets,of,the,input,graphs,removes,common,vertices,and,edges,if,a,source,target,vertex,is,removed,its,corresponding,edge,will,also,be,removed,param,graph,the,graph,to,perform,difference,with,return,a,new,graph,where,the,common,vertices,and,edges,have,been,removed;public,graph,k,vv,ev,difference,graph,k,vv,ev,graph,data,set,vertex,k,vv,remove,vertices,data,graph,get,vertices,return,this,remove,vertices,remove,vertices,data
Graph -> public Graph<K,VV,EV> difference(Graph<K,VV,EV> graph);1445854323;Performs Difference on the vertex and edge sets of the input graphs_removes common vertices and edges. If a source/target vertex is removed,_its corresponding edge will also be removed__@param graph the graph to perform difference with_@return a new graph where the common vertices and edges have been removed;public Graph<K,VV,EV> difference(Graph<K,VV,EV> graph) {_		DataSet<Vertex<K,VV>> removeVerticesData = graph.getVertices()__		return this.removeVertices(removeVerticesData)__	};performs,difference,on,the,vertex,and,edge,sets,of,the,input,graphs,removes,common,vertices,and,edges,if,a,source,target,vertex,is,removed,its,corresponding,edge,will,also,be,removed,param,graph,the,graph,to,perform,difference,with,return,a,new,graph,where,the,common,vertices,and,edges,have,been,removed;public,graph,k,vv,ev,difference,graph,k,vv,ev,graph,data,set,vertex,k,vv,remove,vertices,data,graph,get,vertices,return,this,remove,vertices,remove,vertices,data
Graph -> public Graph<K,VV,EV> difference(Graph<K,VV,EV> graph);1446112342;Performs Difference on the vertex and edge sets of the input graphs_removes common vertices and edges. If a source/target vertex is removed,_its corresponding edge will also be removed__@param graph the graph to perform difference with_@return a new graph where the common vertices and edges have been removed;public Graph<K,VV,EV> difference(Graph<K,VV,EV> graph) {_		DataSet<Vertex<K,VV>> removeVerticesData = graph.getVertices()__		return this.removeVertices(removeVerticesData)__	};performs,difference,on,the,vertex,and,edge,sets,of,the,input,graphs,removes,common,vertices,and,edges,if,a,source,target,vertex,is,removed,its,corresponding,edge,will,also,be,removed,param,graph,the,graph,to,perform,difference,with,return,a,new,graph,where,the,common,vertices,and,edges,have,been,removed;public,graph,k,vv,ev,difference,graph,k,vv,ev,graph,data,set,vertex,k,vv,remove,vertices,data,graph,get,vertices,return,this,remove,vertices,remove,vertices,data
Graph -> public Graph<K,VV,EV> difference(Graph<K,VV,EV> graph);1447073368;Performs Difference on the vertex and edge sets of the input graphs_removes common vertices and edges. If a source/target vertex is removed,_its corresponding edge will also be removed__@param graph the graph to perform difference with_@return a new graph where the common vertices and edges have been removed;public Graph<K,VV,EV> difference(Graph<K,VV,EV> graph) {_		DataSet<Vertex<K,VV>> removeVerticesData = graph.getVertices()__		return this.removeVertices(removeVerticesData)__	};performs,difference,on,the,vertex,and,edge,sets,of,the,input,graphs,removes,common,vertices,and,edges,if,a,source,target,vertex,is,removed,its,corresponding,edge,will,also,be,removed,param,graph,the,graph,to,perform,difference,with,return,a,new,graph,where,the,common,vertices,and,edges,have,been,removed;public,graph,k,vv,ev,difference,graph,k,vv,ev,graph,data,set,vertex,k,vv,remove,vertices,data,graph,get,vertices,return,this,remove,vertices,remove,vertices,data
Graph -> public Graph<K,VV,EV> difference(Graph<K,VV,EV> graph);1454404649;Performs Difference on the vertex and edge sets of the input graphs_removes common vertices and edges. If a source/target vertex is removed,_its corresponding edge will also be removed__@param graph the graph to perform difference with_@return a new graph where the common vertices and edges have been removed;public Graph<K,VV,EV> difference(Graph<K,VV,EV> graph) {_		DataSet<Vertex<K,VV>> removeVerticesData = graph.getVertices()__		return this.removeVertices(removeVerticesData)__	};performs,difference,on,the,vertex,and,edge,sets,of,the,input,graphs,removes,common,vertices,and,edges,if,a,source,target,vertex,is,removed,its,corresponding,edge,will,also,be,removed,param,graph,the,graph,to,perform,difference,with,return,a,new,graph,where,the,common,vertices,and,edges,have,been,removed;public,graph,k,vv,ev,difference,graph,k,vv,ev,graph,data,set,vertex,k,vv,remove,vertices,data,graph,get,vertices,return,this,remove,vertices,remove,vertices,data
Graph -> public Graph<K,VV,EV> difference(Graph<K,VV,EV> graph);1458583829;Performs Difference on the vertex and edge sets of the input graphs_removes common vertices and edges. If a source/target vertex is removed,_its corresponding edge will also be removed__@param graph the graph to perform difference with_@return a new graph where the common vertices and edges have been removed;public Graph<K,VV,EV> difference(Graph<K,VV,EV> graph) {_		DataSet<Vertex<K,VV>> removeVerticesData = graph.getVertices()__		return this.removeVertices(removeVerticesData)__	};performs,difference,on,the,vertex,and,edge,sets,of,the,input,graphs,removes,common,vertices,and,edges,if,a,source,target,vertex,is,removed,its,corresponding,edge,will,also,be,removed,param,graph,the,graph,to,perform,difference,with,return,a,new,graph,where,the,common,vertices,and,edges,have,been,removed;public,graph,k,vv,ev,difference,graph,k,vv,ev,graph,data,set,vertex,k,vv,remove,vertices,data,graph,get,vertices,return,this,remove,vertices,remove,vertices,data
Graph -> public Graph<K,VV,EV> difference(Graph<K,VV,EV> graph);1458583829;Performs Difference on the vertex and edge sets of the input graphs_removes common vertices and edges. If a source/target vertex is removed,_its corresponding edge will also be removed__@param graph the graph to perform difference with_@return a new graph where the common vertices and edges have been removed;public Graph<K,VV,EV> difference(Graph<K,VV,EV> graph) {_		DataSet<Vertex<K,VV>> removeVerticesData = graph.getVertices()__		return this.removeVertices(removeVerticesData)__	};performs,difference,on,the,vertex,and,edge,sets,of,the,input,graphs,removes,common,vertices,and,edges,if,a,source,target,vertex,is,removed,its,corresponding,edge,will,also,be,removed,param,graph,the,graph,to,perform,difference,with,return,a,new,graph,where,the,common,vertices,and,edges,have,been,removed;public,graph,k,vv,ev,difference,graph,k,vv,ev,graph,data,set,vertex,k,vv,remove,vertices,data,graph,get,vertices,return,this,remove,vertices,remove,vertices,data
Graph -> public Graph<K,VV,EV> difference(Graph<K,VV,EV> graph);1462100316;Performs Difference on the vertex and edge sets of the input graphs_removes common vertices and edges. If a source/target vertex is removed,_its corresponding edge will also be removed__@param graph the graph to perform difference with_@return a new graph where the common vertices and edges have been removed;public Graph<K,VV,EV> difference(Graph<K,VV,EV> graph) {_		DataSet<Vertex<K,VV>> removeVerticesData = graph.getVertices()__		return this.removeVertices(removeVerticesData)__	};performs,difference,on,the,vertex,and,edge,sets,of,the,input,graphs,removes,common,vertices,and,edges,if,a,source,target,vertex,is,removed,its,corresponding,edge,will,also,be,removed,param,graph,the,graph,to,perform,difference,with,return,a,new,graph,where,the,common,vertices,and,edges,have,been,removed;public,graph,k,vv,ev,difference,graph,k,vv,ev,graph,data,set,vertex,k,vv,remove,vertices,data,graph,get,vertices,return,this,remove,vertices,remove,vertices,data
Graph -> public Graph<K,VV,EV> difference(Graph<K,VV,EV> graph);1462100316;Performs Difference on the vertex and edge sets of the input graphs_removes common vertices and edges. If a source/target vertex is removed,_its corresponding edge will also be removed__@param graph the graph to perform difference with_@return a new graph where the common vertices and edges have been removed;public Graph<K,VV,EV> difference(Graph<K,VV,EV> graph) {_		DataSet<Vertex<K,VV>> removeVerticesData = graph.getVertices()__		return this.removeVertices(removeVerticesData)__	};performs,difference,on,the,vertex,and,edge,sets,of,the,input,graphs,removes,common,vertices,and,edges,if,a,source,target,vertex,is,removed,its,corresponding,edge,will,also,be,removed,param,graph,the,graph,to,perform,difference,with,return,a,new,graph,where,the,common,vertices,and,edges,have,been,removed;public,graph,k,vv,ev,difference,graph,k,vv,ev,graph,data,set,vertex,k,vv,remove,vertices,data,graph,get,vertices,return,this,remove,vertices,remove,vertices,data
Graph -> public Graph<K,VV,EV> difference(Graph<K,VV,EV> graph);1462205213;Performs Difference on the vertex and edge sets of the input graphs_removes common vertices and edges. If a source/target vertex is removed,_its corresponding edge will also be removed__@param graph the graph to perform difference with_@return a new graph where the common vertices and edges have been removed;public Graph<K,VV,EV> difference(Graph<K,VV,EV> graph) {_		DataSet<Vertex<K,VV>> removeVerticesData = graph.getVertices()__		return this.removeVertices(removeVerticesData)__	};performs,difference,on,the,vertex,and,edge,sets,of,the,input,graphs,removes,common,vertices,and,edges,if,a,source,target,vertex,is,removed,its,corresponding,edge,will,also,be,removed,param,graph,the,graph,to,perform,difference,with,return,a,new,graph,where,the,common,vertices,and,edges,have,been,removed;public,graph,k,vv,ev,difference,graph,k,vv,ev,graph,data,set,vertex,k,vv,remove,vertices,data,graph,get,vertices,return,this,remove,vertices,remove,vertices,data
Graph -> public Graph<K,VV,EV> difference(Graph<K,VV,EV> graph);1462208859;Performs Difference on the vertex and edge sets of the input graphs_removes common vertices and edges. If a source/target vertex is removed,_its corresponding edge will also be removed__@param graph the graph to perform difference with_@return a new graph where the common vertices and edges have been removed;public Graph<K,VV,EV> difference(Graph<K,VV,EV> graph) {_		DataSet<Vertex<K,VV>> removeVerticesData = graph.getVertices()__		return this.removeVertices(removeVerticesData)__	};performs,difference,on,the,vertex,and,edge,sets,of,the,input,graphs,removes,common,vertices,and,edges,if,a,source,target,vertex,is,removed,its,corresponding,edge,will,also,be,removed,param,graph,the,graph,to,perform,difference,with,return,a,new,graph,where,the,common,vertices,and,edges,have,been,removed;public,graph,k,vv,ev,difference,graph,k,vv,ev,graph,data,set,vertex,k,vv,remove,vertices,data,graph,get,vertices,return,this,remove,vertices,remove,vertices,data
Graph -> public Graph<K,VV,EV> difference(Graph<K,VV,EV> graph);1462809297;Performs Difference on the vertex and edge sets of the input graphs_removes common vertices and edges. If a source/target vertex is removed,_its corresponding edge will also be removed__@param graph the graph to perform difference with_@return a new graph where the common vertices and edges have been removed;public Graph<K,VV,EV> difference(Graph<K,VV,EV> graph) {_		DataSet<Vertex<K,VV>> removeVerticesData = graph.getVertices()__		return this.removeVertices(removeVerticesData)__	};performs,difference,on,the,vertex,and,edge,sets,of,the,input,graphs,removes,common,vertices,and,edges,if,a,source,target,vertex,is,removed,its,corresponding,edge,will,also,be,removed,param,graph,the,graph,to,perform,difference,with,return,a,new,graph,where,the,common,vertices,and,edges,have,been,removed;public,graph,k,vv,ev,difference,graph,k,vv,ev,graph,data,set,vertex,k,vv,remove,vertices,data,graph,get,vertices,return,this,remove,vertices,remove,vertices,data
Graph -> public Graph<K,VV,EV> difference(Graph<K,VV,EV> graph);1465316775;Performs Difference on the vertex and edge sets of the input graphs_removes common vertices and edges. If a source/target vertex is removed,_its corresponding edge will also be removed__@param graph the graph to perform difference with_@return a new graph where the common vertices and edges have been removed;public Graph<K,VV,EV> difference(Graph<K,VV,EV> graph) {_		DataSet<Vertex<K,VV>> removeVerticesData = graph.getVertices()__		return this.removeVertices(removeVerticesData)__	};performs,difference,on,the,vertex,and,edge,sets,of,the,input,graphs,removes,common,vertices,and,edges,if,a,source,target,vertex,is,removed,its,corresponding,edge,will,also,be,removed,param,graph,the,graph,to,perform,difference,with,return,a,new,graph,where,the,common,vertices,and,edges,have,been,removed;public,graph,k,vv,ev,difference,graph,k,vv,ev,graph,data,set,vertex,k,vv,remove,vertices,data,graph,get,vertices,return,this,remove,vertices,remove,vertices,data
Graph -> public Graph<K,VV,EV> difference(Graph<K,VV,EV> graph);1466789678;Performs Difference on the vertex and edge sets of the input graphs_removes common vertices and edges. If a source/target vertex is removed,_its corresponding edge will also be removed__@param graph the graph to perform difference with_@return a new graph where the common vertices and edges have been removed;public Graph<K,VV,EV> difference(Graph<K,VV,EV> graph) {_		DataSet<Vertex<K,VV>> removeVerticesData = graph.getVertices()__		return this.removeVertices(removeVerticesData)__	};performs,difference,on,the,vertex,and,edge,sets,of,the,input,graphs,removes,common,vertices,and,edges,if,a,source,target,vertex,is,removed,its,corresponding,edge,will,also,be,removed,param,graph,the,graph,to,perform,difference,with,return,a,new,graph,where,the,common,vertices,and,edges,have,been,removed;public,graph,k,vv,ev,difference,graph,k,vv,ev,graph,data,set,vertex,k,vv,remove,vertices,data,graph,get,vertices,return,this,remove,vertices,remove,vertices,data
Graph -> public Graph<K,VV,EV> difference(Graph<K,VV,EV> graph);1467140656;Performs Difference on the vertex and edge sets of the input graphs_removes common vertices and edges. If a source/target vertex is removed,_its corresponding edge will also be removed__@param graph the graph to perform difference with_@return a new graph where the common vertices and edges have been removed;public Graph<K,VV,EV> difference(Graph<K,VV,EV> graph) {_		DataSet<Vertex<K,VV>> removeVerticesData = graph.getVertices()__		return this.removeVertices(removeVerticesData)__	};performs,difference,on,the,vertex,and,edge,sets,of,the,input,graphs,removes,common,vertices,and,edges,if,a,source,target,vertex,is,removed,its,corresponding,edge,will,also,be,removed,param,graph,the,graph,to,perform,difference,with,return,a,new,graph,where,the,common,vertices,and,edges,have,been,removed;public,graph,k,vv,ev,difference,graph,k,vv,ev,graph,data,set,vertex,k,vv,remove,vertices,data,graph,get,vertices,return,this,remove,vertices,remove,vertices,data
Graph -> public Graph<K,VV,EV> difference(Graph<K,VV,EV> graph);1467306272;Performs Difference on the vertex and edge sets of the input graphs_removes common vertices and edges. If a source/target vertex is removed,_its corresponding edge will also be removed__@param graph the graph to perform difference with_@return a new graph where the common vertices and edges have been removed;public Graph<K,VV,EV> difference(Graph<K,VV,EV> graph) {_		DataSet<Vertex<K,VV>> removeVerticesData = graph.getVertices()__		return this.removeVertices(removeVerticesData)__	};performs,difference,on,the,vertex,and,edge,sets,of,the,input,graphs,removes,common,vertices,and,edges,if,a,source,target,vertex,is,removed,its,corresponding,edge,will,also,be,removed,param,graph,the,graph,to,perform,difference,with,return,a,new,graph,where,the,common,vertices,and,edges,have,been,removed;public,graph,k,vv,ev,difference,graph,k,vv,ev,graph,data,set,vertex,k,vv,remove,vertices,data,graph,get,vertices,return,this,remove,vertices,remove,vertices,data
Graph -> public Graph<K,VV,EV> difference(Graph<K,VV,EV> graph);1470042815;Performs Difference on the vertex and edge sets of the input graphs_removes common vertices and edges. If a source/target vertex is removed,_its corresponding edge will also be removed__@param graph the graph to perform difference with_@return a new graph where the common vertices and edges have been removed;public Graph<K,VV,EV> difference(Graph<K,VV,EV> graph) {_		DataSet<Vertex<K,VV>> removeVerticesData = graph.getVertices()__		return this.removeVertices(removeVerticesData)__	};performs,difference,on,the,vertex,and,edge,sets,of,the,input,graphs,removes,common,vertices,and,edges,if,a,source,target,vertex,is,removed,its,corresponding,edge,will,also,be,removed,param,graph,the,graph,to,perform,difference,with,return,a,new,graph,where,the,common,vertices,and,edges,have,been,removed;public,graph,k,vv,ev,difference,graph,k,vv,ev,graph,data,set,vertex,k,vv,remove,vertices,data,graph,get,vertices,return,this,remove,vertices,remove,vertices,data
Graph -> public Graph<K,VV,EV> difference(Graph<K,VV,EV> graph);1475684776;Performs Difference on the vertex and edge sets of the input graphs_removes common vertices and edges. If a source/target vertex is removed,_its corresponding edge will also be removed__@param graph the graph to perform difference with_@return a new graph where the common vertices and edges have been removed;public Graph<K,VV,EV> difference(Graph<K,VV,EV> graph) {_		DataSet<Vertex<K,VV>> removeVerticesData = graph.getVertices()__		return this.removeVertices(removeVerticesData)__	};performs,difference,on,the,vertex,and,edge,sets,of,the,input,graphs,removes,common,vertices,and,edges,if,a,source,target,vertex,is,removed,its,corresponding,edge,will,also,be,removed,param,graph,the,graph,to,perform,difference,with,return,a,new,graph,where,the,common,vertices,and,edges,have,been,removed;public,graph,k,vv,ev,difference,graph,k,vv,ev,graph,data,set,vertex,k,vv,remove,vertices,data,graph,get,vertices,return,this,remove,vertices,remove,vertices,data
Graph -> public Graph<K,VV,EV> difference(Graph<K,VV,EV> graph);1475685606;Performs Difference on the vertex and edge sets of the input graphs_removes common vertices and edges. If a source/target vertex is removed,_its corresponding edge will also be removed__@param graph the graph to perform difference with_@return a new graph where the common vertices and edges have been removed;public Graph<K,VV,EV> difference(Graph<K,VV,EV> graph) {_		DataSet<Vertex<K,VV>> removeVerticesData = graph.getVertices()__		return this.removeVertices(removeVerticesData)__	};performs,difference,on,the,vertex,and,edge,sets,of,the,input,graphs,removes,common,vertices,and,edges,if,a,source,target,vertex,is,removed,its,corresponding,edge,will,also,be,removed,param,graph,the,graph,to,perform,difference,with,return,a,new,graph,where,the,common,vertices,and,edges,have,been,removed;public,graph,k,vv,ev,difference,graph,k,vv,ev,graph,data,set,vertex,k,vv,remove,vertices,data,graph,get,vertices,return,this,remove,vertices,remove,vertices,data
Graph -> public Graph<K,VV,EV> difference(Graph<K,VV,EV> graph);1481745825;Performs Difference on the vertex and edge sets of the input graphs_removes common vertices and edges. If a source/target vertex is removed,_its corresponding edge will also be removed__@param graph the graph to perform difference with_@return a new graph where the common vertices and edges have been removed;public Graph<K,VV,EV> difference(Graph<K,VV,EV> graph) {_		DataSet<Vertex<K,VV>> removeVerticesData = graph.getVertices()__		return this.removeVertices(removeVerticesData)__	};performs,difference,on,the,vertex,and,edge,sets,of,the,input,graphs,removes,common,vertices,and,edges,if,a,source,target,vertex,is,removed,its,corresponding,edge,will,also,be,removed,param,graph,the,graph,to,perform,difference,with,return,a,new,graph,where,the,common,vertices,and,edges,have,been,removed;public,graph,k,vv,ev,difference,graph,k,vv,ev,graph,data,set,vertex,k,vv,remove,vertices,data,graph,get,vertices,return,this,remove,vertices,remove,vertices,data
Graph -> public Graph<K,VV,EV> difference(Graph<K,VV,EV> graph);1481881009;Performs Difference on the vertex and edge sets of the input graphs_removes common vertices and edges. If a source/target vertex is removed,_its corresponding edge will also be removed__@param graph the graph to perform difference with_@return a new graph where the common vertices and edges have been removed;public Graph<K,VV,EV> difference(Graph<K,VV,EV> graph) {_		DataSet<Vertex<K,VV>> removeVerticesData = graph.getVertices()__		return this.removeVertices(removeVerticesData)__	};performs,difference,on,the,vertex,and,edge,sets,of,the,input,graphs,removes,common,vertices,and,edges,if,a,source,target,vertex,is,removed,its,corresponding,edge,will,also,be,removed,param,graph,the,graph,to,perform,difference,with,return,a,new,graph,where,the,common,vertices,and,edges,have,been,removed;public,graph,k,vv,ev,difference,graph,k,vv,ev,graph,data,set,vertex,k,vv,remove,vertices,data,graph,get,vertices,return,this,remove,vertices,remove,vertices,data
Graph -> public Graph<K,VV,EV> difference(Graph<K,VV,EV> graph);1484160227;Performs Difference on the vertex and edge sets of the input graphs_removes common vertices and edges. If a source/target vertex is removed,_its corresponding edge will also be removed__@param graph the graph to perform difference with_@return a new graph where the common vertices and edges have been removed;public Graph<K,VV,EV> difference(Graph<K,VV,EV> graph) {_		DataSet<Vertex<K,VV>> removeVerticesData = graph.getVertices()__		return this.removeVertices(removeVerticesData)__	};performs,difference,on,the,vertex,and,edge,sets,of,the,input,graphs,removes,common,vertices,and,edges,if,a,source,target,vertex,is,removed,its,corresponding,edge,will,also,be,removed,param,graph,the,graph,to,perform,difference,with,return,a,new,graph,where,the,common,vertices,and,edges,have,been,removed;public,graph,k,vv,ev,difference,graph,k,vv,ev,graph,data,set,vertex,k,vv,remove,vertices,data,graph,get,vertices,return,this,remove,vertices,remove,vertices,data
Graph -> public DataSet<Vertex<K, VV>> getVertices();1444404795;@return the vertex DataSet.;public DataSet<Vertex<K, VV>> getVertices() {_		return vertices__	};return,the,vertex,data,set;public,data,set,vertex,k,vv,get,vertices,return,vertices
Graph -> public DataSet<Vertex<K, VV>> getVertices();1445261977;@return the vertex DataSet.;public DataSet<Vertex<K, VV>> getVertices() {_		return vertices__	};return,the,vertex,data,set;public,data,set,vertex,k,vv,get,vertices,return,vertices
Graph -> public DataSet<Vertex<K, VV>> getVertices();1445854323;@return the vertex DataSet.;public DataSet<Vertex<K, VV>> getVertices() {_		return vertices__	};return,the,vertex,data,set;public,data,set,vertex,k,vv,get,vertices,return,vertices
Graph -> public DataSet<Vertex<K, VV>> getVertices();1446112342;@return the vertex DataSet.;public DataSet<Vertex<K, VV>> getVertices() {_		return vertices__	};return,the,vertex,data,set;public,data,set,vertex,k,vv,get,vertices,return,vertices
Graph -> public DataSet<Vertex<K, VV>> getVertices();1447073368;@return the vertex DataSet.;public DataSet<Vertex<K, VV>> getVertices() {_		return vertices__	};return,the,vertex,data,set;public,data,set,vertex,k,vv,get,vertices,return,vertices
Graph -> public DataSet<Vertex<K, VV>> getVertices();1454404649;@return the vertex DataSet.;public DataSet<Vertex<K, VV>> getVertices() {_		return vertices__	};return,the,vertex,data,set;public,data,set,vertex,k,vv,get,vertices,return,vertices
Graph -> public DataSet<Vertex<K, VV>> getVertices();1458583829;@return the vertex DataSet.;public DataSet<Vertex<K, VV>> getVertices() {_		return vertices__	};return,the,vertex,data,set;public,data,set,vertex,k,vv,get,vertices,return,vertices
Graph -> public DataSet<Vertex<K, VV>> getVertices();1458583829;@return the vertex DataSet.;public DataSet<Vertex<K, VV>> getVertices() {_		return vertices__	};return,the,vertex,data,set;public,data,set,vertex,k,vv,get,vertices,return,vertices
Graph -> public DataSet<Vertex<K, VV>> getVertices();1462100316;@return the vertex DataSet.;public DataSet<Vertex<K, VV>> getVertices() {_		return vertices__	};return,the,vertex,data,set;public,data,set,vertex,k,vv,get,vertices,return,vertices
Graph -> public DataSet<Vertex<K, VV>> getVertices();1462100316;@return the vertex DataSet.;public DataSet<Vertex<K, VV>> getVertices() {_		return vertices__	};return,the,vertex,data,set;public,data,set,vertex,k,vv,get,vertices,return,vertices
Graph -> public DataSet<Vertex<K, VV>> getVertices();1462205213;@return the vertex DataSet.;public DataSet<Vertex<K, VV>> getVertices() {_		return vertices__	};return,the,vertex,data,set;public,data,set,vertex,k,vv,get,vertices,return,vertices
Graph -> public DataSet<Vertex<K, VV>> getVertices();1462208859;@return the vertex DataSet.;public DataSet<Vertex<K, VV>> getVertices() {_		return vertices__	};return,the,vertex,data,set;public,data,set,vertex,k,vv,get,vertices,return,vertices
Graph -> public DataSet<Vertex<K, VV>> getVertices();1462809297;@return the vertex DataSet.;public DataSet<Vertex<K, VV>> getVertices() {_		return vertices__	};return,the,vertex,data,set;public,data,set,vertex,k,vv,get,vertices,return,vertices
Graph -> public DataSet<Vertex<K, VV>> getVertices();1465316775;@return the vertex DataSet.;public DataSet<Vertex<K, VV>> getVertices() {_		return vertices__	};return,the,vertex,data,set;public,data,set,vertex,k,vv,get,vertices,return,vertices
Graph -> public DataSet<Vertex<K, VV>> getVertices();1466789678;@return the vertex DataSet.;public DataSet<Vertex<K, VV>> getVertices() {_		return vertices__	};return,the,vertex,data,set;public,data,set,vertex,k,vv,get,vertices,return,vertices
Graph -> public DataSet<Vertex<K, VV>> getVertices();1467140656;@return the vertex DataSet.;public DataSet<Vertex<K, VV>> getVertices() {_		return vertices__	};return,the,vertex,data,set;public,data,set,vertex,k,vv,get,vertices,return,vertices
Graph -> public DataSet<Vertex<K, VV>> getVertices();1467306272;@return the vertex DataSet.;public DataSet<Vertex<K, VV>> getVertices() {_		return vertices__	};return,the,vertex,data,set;public,data,set,vertex,k,vv,get,vertices,return,vertices
Graph -> public DataSet<Vertex<K, VV>> getVertices();1470042815;@return the vertex DataSet.;public DataSet<Vertex<K, VV>> getVertices() {_		return vertices__	};return,the,vertex,data,set;public,data,set,vertex,k,vv,get,vertices,return,vertices
Graph -> public DataSet<Vertex<K, VV>> getVertices();1475684776;@return the vertex DataSet.;public DataSet<Vertex<K, VV>> getVertices() {_		return vertices__	};return,the,vertex,data,set;public,data,set,vertex,k,vv,get,vertices,return,vertices
Graph -> public DataSet<Vertex<K, VV>> getVertices();1475685606;@return the vertex DataSet.;public DataSet<Vertex<K, VV>> getVertices() {_		return vertices__	};return,the,vertex,data,set;public,data,set,vertex,k,vv,get,vertices,return,vertices
Graph -> public DataSet<Vertex<K, VV>> getVertices();1481745825;@return the vertex DataSet.;public DataSet<Vertex<K, VV>> getVertices() {_		return vertices__	};return,the,vertex,data,set;public,data,set,vertex,k,vv,get,vertices,return,vertices
Graph -> public DataSet<Vertex<K, VV>> getVertices();1481881009;@return the vertex DataSet.;public DataSet<Vertex<K, VV>> getVertices() {_		return vertices__	};return,the,vertex,data,set;public,data,set,vertex,k,vv,get,vertices,return,vertices
Graph -> public DataSet<Vertex<K, VV>> getVertices();1484160227;@return the vertex DataSet.;public DataSet<Vertex<K, VV>> getVertices() {_		return vertices__	};return,the,vertex,data,set;public,data,set,vertex,k,vv,get,vertices,return,vertices
Graph -> public DataSet<Vertex<K, VV>> getVertices();1484685504;@return the vertex DataSet.;public DataSet<Vertex<K, VV>> getVertices() {_		return vertices__	};return,the,vertex,data,set;public,data,set,vertex,k,vv,get,vertices,return,vertices
Graph -> public DataSet<Vertex<K, VV>> getVertices();1489068942;@return the vertex DataSet.;public DataSet<Vertex<K, VV>> getVertices() {_		return vertices__	};return,the,vertex,data,set;public,data,set,vertex,k,vv,get,vertices,return,vertices
Graph -> public DataSet<Vertex<K, VV>> getVertices();1490973446;@return the vertex DataSet.;public DataSet<Vertex<K, VV>> getVertices() {_		return vertices__	};return,the,vertex,data,set;public,data,set,vertex,k,vv,get,vertices,return,vertices
Graph -> public DataSet<Vertex<K, VV>> getVertices();1495819075;@return the vertex DataSet.;public DataSet<Vertex<K, VV>> getVertices() {_		return vertices__	};return,the,vertex,data,set;public,data,set,vertex,k,vv,get,vertices,return,vertices
Graph -> public DataSet<Vertex<K, VV>> getVertices();1502111816;@return the vertex DataSet.;public DataSet<Vertex<K, VV>> getVertices() {_		return vertices__	};return,the,vertex,data,set;public,data,set,vertex,k,vv,get,vertices,return,vertices
Graph -> public Graph<K, VV, EV> removeVertex(Vertex<K, VV> vertex);1444404795;Removes the given vertex and its edges from the graph.__@param vertex the vertex to remove_@return the new graph containing the existing vertices and edges without_the removed vertex and its edges;public Graph<K, VV, EV> removeVertex(Vertex<K, VV> vertex) {__		List<Vertex<K, VV>> vertexToBeRemoved = new ArrayList<Vertex<K, VV>>()__		vertexToBeRemoved.add(vertex)___		return removeVertices(vertexToBeRemoved)__	};removes,the,given,vertex,and,its,edges,from,the,graph,param,vertex,the,vertex,to,remove,return,the,new,graph,containing,the,existing,vertices,and,edges,without,the,removed,vertex,and,its,edges;public,graph,k,vv,ev,remove,vertex,vertex,k,vv,vertex,list,vertex,k,vv,vertex,to,be,removed,new,array,list,vertex,k,vv,vertex,to,be,removed,add,vertex,return,remove,vertices,vertex,to,be,removed
Graph -> public Graph<K, VV, EV> removeVertex(Vertex<K, VV> vertex);1445261977;Removes the given vertex and its edges from the graph.__@param vertex the vertex to remove_@return the new graph containing the existing vertices and edges without_the removed vertex and its edges;public Graph<K, VV, EV> removeVertex(Vertex<K, VV> vertex) {__		List<Vertex<K, VV>> vertexToBeRemoved = new ArrayList<Vertex<K, VV>>()__		vertexToBeRemoved.add(vertex)___		return removeVertices(vertexToBeRemoved)__	};removes,the,given,vertex,and,its,edges,from,the,graph,param,vertex,the,vertex,to,remove,return,the,new,graph,containing,the,existing,vertices,and,edges,without,the,removed,vertex,and,its,edges;public,graph,k,vv,ev,remove,vertex,vertex,k,vv,vertex,list,vertex,k,vv,vertex,to,be,removed,new,array,list,vertex,k,vv,vertex,to,be,removed,add,vertex,return,remove,vertices,vertex,to,be,removed
Graph -> public Graph<K, VV, EV> removeVertex(Vertex<K, VV> vertex);1445854323;Removes the given vertex and its edges from the graph.__@param vertex the vertex to remove_@return the new graph containing the existing vertices and edges without_the removed vertex and its edges;public Graph<K, VV, EV> removeVertex(Vertex<K, VV> vertex) {__		List<Vertex<K, VV>> vertexToBeRemoved = new ArrayList<Vertex<K, VV>>()__		vertexToBeRemoved.add(vertex)___		return removeVertices(vertexToBeRemoved)__	};removes,the,given,vertex,and,its,edges,from,the,graph,param,vertex,the,vertex,to,remove,return,the,new,graph,containing,the,existing,vertices,and,edges,without,the,removed,vertex,and,its,edges;public,graph,k,vv,ev,remove,vertex,vertex,k,vv,vertex,list,vertex,k,vv,vertex,to,be,removed,new,array,list,vertex,k,vv,vertex,to,be,removed,add,vertex,return,remove,vertices,vertex,to,be,removed
Graph -> public Graph<K, VV, EV> removeVertex(Vertex<K, VV> vertex);1446112342;Removes the given vertex and its edges from the graph.__@param vertex the vertex to remove_@return the new graph containing the existing vertices and edges without_the removed vertex and its edges;public Graph<K, VV, EV> removeVertex(Vertex<K, VV> vertex) {__		List<Vertex<K, VV>> vertexToBeRemoved = new ArrayList<Vertex<K, VV>>()__		vertexToBeRemoved.add(vertex)___		return removeVertices(vertexToBeRemoved)__	};removes,the,given,vertex,and,its,edges,from,the,graph,param,vertex,the,vertex,to,remove,return,the,new,graph,containing,the,existing,vertices,and,edges,without,the,removed,vertex,and,its,edges;public,graph,k,vv,ev,remove,vertex,vertex,k,vv,vertex,list,vertex,k,vv,vertex,to,be,removed,new,array,list,vertex,k,vv,vertex,to,be,removed,add,vertex,return,remove,vertices,vertex,to,be,removed
Graph -> public Graph<K, VV, EV> removeVertex(Vertex<K, VV> vertex);1447073368;Removes the given vertex and its edges from the graph.__@param vertex the vertex to remove_@return the new graph containing the existing vertices and edges without_the removed vertex and its edges;public Graph<K, VV, EV> removeVertex(Vertex<K, VV> vertex) {__		List<Vertex<K, VV>> vertexToBeRemoved = new ArrayList<Vertex<K, VV>>()__		vertexToBeRemoved.add(vertex)___		return removeVertices(vertexToBeRemoved)__	};removes,the,given,vertex,and,its,edges,from,the,graph,param,vertex,the,vertex,to,remove,return,the,new,graph,containing,the,existing,vertices,and,edges,without,the,removed,vertex,and,its,edges;public,graph,k,vv,ev,remove,vertex,vertex,k,vv,vertex,list,vertex,k,vv,vertex,to,be,removed,new,array,list,vertex,k,vv,vertex,to,be,removed,add,vertex,return,remove,vertices,vertex,to,be,removed
Graph -> public Graph<K, VV, EV> removeVertex(Vertex<K, VV> vertex);1454404649;Removes the given vertex and its edges from the graph.__@param vertex the vertex to remove_@return the new graph containing the existing vertices and edges without_the removed vertex and its edges;public Graph<K, VV, EV> removeVertex(Vertex<K, VV> vertex) {__		List<Vertex<K, VV>> vertexToBeRemoved = new ArrayList<Vertex<K, VV>>()__		vertexToBeRemoved.add(vertex)___		return removeVertices(vertexToBeRemoved)__	};removes,the,given,vertex,and,its,edges,from,the,graph,param,vertex,the,vertex,to,remove,return,the,new,graph,containing,the,existing,vertices,and,edges,without,the,removed,vertex,and,its,edges;public,graph,k,vv,ev,remove,vertex,vertex,k,vv,vertex,list,vertex,k,vv,vertex,to,be,removed,new,array,list,vertex,k,vv,vertex,to,be,removed,add,vertex,return,remove,vertices,vertex,to,be,removed
Graph -> public Graph<K, VV, EV> removeVertex(Vertex<K, VV> vertex);1458583829;Removes the given vertex and its edges from the graph.__@param vertex the vertex to remove_@return the new graph containing the existing vertices and edges without_the removed vertex and its edges;public Graph<K, VV, EV> removeVertex(Vertex<K, VV> vertex) {__		List<Vertex<K, VV>> vertexToBeRemoved = new ArrayList<Vertex<K, VV>>()__		vertexToBeRemoved.add(vertex)___		return removeVertices(vertexToBeRemoved)__	};removes,the,given,vertex,and,its,edges,from,the,graph,param,vertex,the,vertex,to,remove,return,the,new,graph,containing,the,existing,vertices,and,edges,without,the,removed,vertex,and,its,edges;public,graph,k,vv,ev,remove,vertex,vertex,k,vv,vertex,list,vertex,k,vv,vertex,to,be,removed,new,array,list,vertex,k,vv,vertex,to,be,removed,add,vertex,return,remove,vertices,vertex,to,be,removed
Graph -> public Graph<K, VV, EV> removeVertex(Vertex<K, VV> vertex);1458583829;Removes the given vertex and its edges from the graph.__@param vertex the vertex to remove_@return the new graph containing the existing vertices and edges without_the removed vertex and its edges;public Graph<K, VV, EV> removeVertex(Vertex<K, VV> vertex) {__		List<Vertex<K, VV>> vertexToBeRemoved = new ArrayList<Vertex<K, VV>>()__		vertexToBeRemoved.add(vertex)___		return removeVertices(vertexToBeRemoved)__	};removes,the,given,vertex,and,its,edges,from,the,graph,param,vertex,the,vertex,to,remove,return,the,new,graph,containing,the,existing,vertices,and,edges,without,the,removed,vertex,and,its,edges;public,graph,k,vv,ev,remove,vertex,vertex,k,vv,vertex,list,vertex,k,vv,vertex,to,be,removed,new,array,list,vertex,k,vv,vertex,to,be,removed,add,vertex,return,remove,vertices,vertex,to,be,removed
Graph -> public Graph<K, VV, EV> removeVertex(Vertex<K, VV> vertex);1462100316;Removes the given vertex and its edges from the graph.__@param vertex the vertex to remove_@return the new graph containing the existing vertices and edges without_the removed vertex and its edges;public Graph<K, VV, EV> removeVertex(Vertex<K, VV> vertex) {__		List<Vertex<K, VV>> vertexToBeRemoved = new ArrayList<Vertex<K, VV>>()__		vertexToBeRemoved.add(vertex)___		return removeVertices(vertexToBeRemoved)__	};removes,the,given,vertex,and,its,edges,from,the,graph,param,vertex,the,vertex,to,remove,return,the,new,graph,containing,the,existing,vertices,and,edges,without,the,removed,vertex,and,its,edges;public,graph,k,vv,ev,remove,vertex,vertex,k,vv,vertex,list,vertex,k,vv,vertex,to,be,removed,new,array,list,vertex,k,vv,vertex,to,be,removed,add,vertex,return,remove,vertices,vertex,to,be,removed
Graph -> public Graph<K, VV, EV> removeVertex(Vertex<K, VV> vertex);1462100316;Removes the given vertex and its edges from the graph.__@param vertex the vertex to remove_@return the new graph containing the existing vertices and edges without_the removed vertex and its edges;public Graph<K, VV, EV> removeVertex(Vertex<K, VV> vertex) {__		List<Vertex<K, VV>> vertexToBeRemoved = new ArrayList<Vertex<K, VV>>()__		vertexToBeRemoved.add(vertex)___		return removeVertices(vertexToBeRemoved)__	};removes,the,given,vertex,and,its,edges,from,the,graph,param,vertex,the,vertex,to,remove,return,the,new,graph,containing,the,existing,vertices,and,edges,without,the,removed,vertex,and,its,edges;public,graph,k,vv,ev,remove,vertex,vertex,k,vv,vertex,list,vertex,k,vv,vertex,to,be,removed,new,array,list,vertex,k,vv,vertex,to,be,removed,add,vertex,return,remove,vertices,vertex,to,be,removed
Graph -> public Graph<K, VV, EV> removeVertex(Vertex<K, VV> vertex);1462205213;Removes the given vertex and its edges from the graph.__@param vertex the vertex to remove_@return the new graph containing the existing vertices and edges without_the removed vertex and its edges;public Graph<K, VV, EV> removeVertex(Vertex<K, VV> vertex) {__		List<Vertex<K, VV>> vertexToBeRemoved = new ArrayList<Vertex<K, VV>>()__		vertexToBeRemoved.add(vertex)___		return removeVertices(vertexToBeRemoved)__	};removes,the,given,vertex,and,its,edges,from,the,graph,param,vertex,the,vertex,to,remove,return,the,new,graph,containing,the,existing,vertices,and,edges,without,the,removed,vertex,and,its,edges;public,graph,k,vv,ev,remove,vertex,vertex,k,vv,vertex,list,vertex,k,vv,vertex,to,be,removed,new,array,list,vertex,k,vv,vertex,to,be,removed,add,vertex,return,remove,vertices,vertex,to,be,removed
Graph -> public Graph<K, VV, EV> removeVertex(Vertex<K, VV> vertex);1462208859;Removes the given vertex and its edges from the graph.__@param vertex the vertex to remove_@return the new graph containing the existing vertices and edges without_the removed vertex and its edges;public Graph<K, VV, EV> removeVertex(Vertex<K, VV> vertex) {__		List<Vertex<K, VV>> vertexToBeRemoved = new ArrayList<Vertex<K, VV>>()__		vertexToBeRemoved.add(vertex)___		return removeVertices(vertexToBeRemoved)__	};removes,the,given,vertex,and,its,edges,from,the,graph,param,vertex,the,vertex,to,remove,return,the,new,graph,containing,the,existing,vertices,and,edges,without,the,removed,vertex,and,its,edges;public,graph,k,vv,ev,remove,vertex,vertex,k,vv,vertex,list,vertex,k,vv,vertex,to,be,removed,new,array,list,vertex,k,vv,vertex,to,be,removed,add,vertex,return,remove,vertices,vertex,to,be,removed
Graph -> public Graph<K, VV, EV> removeVertex(Vertex<K, VV> vertex);1462809297;Removes the given vertex and its edges from the graph.__@param vertex the vertex to remove_@return the new graph containing the existing vertices and edges without_the removed vertex and its edges;public Graph<K, VV, EV> removeVertex(Vertex<K, VV> vertex) {__		List<Vertex<K, VV>> vertexToBeRemoved = new ArrayList<Vertex<K, VV>>()__		vertexToBeRemoved.add(vertex)___		return removeVertices(vertexToBeRemoved)__	};removes,the,given,vertex,and,its,edges,from,the,graph,param,vertex,the,vertex,to,remove,return,the,new,graph,containing,the,existing,vertices,and,edges,without,the,removed,vertex,and,its,edges;public,graph,k,vv,ev,remove,vertex,vertex,k,vv,vertex,list,vertex,k,vv,vertex,to,be,removed,new,array,list,vertex,k,vv,vertex,to,be,removed,add,vertex,return,remove,vertices,vertex,to,be,removed
Graph -> public Graph<K, VV, EV> removeVertex(Vertex<K, VV> vertex);1465316775;Removes the given vertex and its edges from the graph.__@param vertex the vertex to remove_@return the new graph containing the existing vertices and edges without_the removed vertex and its edges;public Graph<K, VV, EV> removeVertex(Vertex<K, VV> vertex) {__		List<Vertex<K, VV>> vertexToBeRemoved = new ArrayList<Vertex<K, VV>>()__		vertexToBeRemoved.add(vertex)___		return removeVertices(vertexToBeRemoved)__	};removes,the,given,vertex,and,its,edges,from,the,graph,param,vertex,the,vertex,to,remove,return,the,new,graph,containing,the,existing,vertices,and,edges,without,the,removed,vertex,and,its,edges;public,graph,k,vv,ev,remove,vertex,vertex,k,vv,vertex,list,vertex,k,vv,vertex,to,be,removed,new,array,list,vertex,k,vv,vertex,to,be,removed,add,vertex,return,remove,vertices,vertex,to,be,removed
Graph -> public Graph<K, VV, EV> removeVertex(Vertex<K, VV> vertex);1466789678;Removes the given vertex and its edges from the graph.__@param vertex the vertex to remove_@return the new graph containing the existing vertices and edges without_the removed vertex and its edges;public Graph<K, VV, EV> removeVertex(Vertex<K, VV> vertex) {__		List<Vertex<K, VV>> vertexToBeRemoved = new ArrayList<Vertex<K, VV>>()__		vertexToBeRemoved.add(vertex)___		return removeVertices(vertexToBeRemoved)__	};removes,the,given,vertex,and,its,edges,from,the,graph,param,vertex,the,vertex,to,remove,return,the,new,graph,containing,the,existing,vertices,and,edges,without,the,removed,vertex,and,its,edges;public,graph,k,vv,ev,remove,vertex,vertex,k,vv,vertex,list,vertex,k,vv,vertex,to,be,removed,new,array,list,vertex,k,vv,vertex,to,be,removed,add,vertex,return,remove,vertices,vertex,to,be,removed
Graph -> public Graph<K, VV, EV> removeVertex(Vertex<K, VV> vertex);1467140656;Removes the given vertex and its edges from the graph.__@param vertex the vertex to remove_@return the new graph containing the existing vertices and edges without_the removed vertex and its edges;public Graph<K, VV, EV> removeVertex(Vertex<K, VV> vertex) {__		List<Vertex<K, VV>> vertexToBeRemoved = new ArrayList<Vertex<K, VV>>()__		vertexToBeRemoved.add(vertex)___		return removeVertices(vertexToBeRemoved)__	};removes,the,given,vertex,and,its,edges,from,the,graph,param,vertex,the,vertex,to,remove,return,the,new,graph,containing,the,existing,vertices,and,edges,without,the,removed,vertex,and,its,edges;public,graph,k,vv,ev,remove,vertex,vertex,k,vv,vertex,list,vertex,k,vv,vertex,to,be,removed,new,array,list,vertex,k,vv,vertex,to,be,removed,add,vertex,return,remove,vertices,vertex,to,be,removed
Graph -> public Graph<K, VV, EV> removeVertex(Vertex<K, VV> vertex);1467306272;Removes the given vertex and its edges from the graph.__@param vertex the vertex to remove_@return the new graph containing the existing vertices and edges without_the removed vertex and its edges;public Graph<K, VV, EV> removeVertex(Vertex<K, VV> vertex) {__		List<Vertex<K, VV>> vertexToBeRemoved = new ArrayList<Vertex<K, VV>>()__		vertexToBeRemoved.add(vertex)___		return removeVertices(vertexToBeRemoved)__	};removes,the,given,vertex,and,its,edges,from,the,graph,param,vertex,the,vertex,to,remove,return,the,new,graph,containing,the,existing,vertices,and,edges,without,the,removed,vertex,and,its,edges;public,graph,k,vv,ev,remove,vertex,vertex,k,vv,vertex,list,vertex,k,vv,vertex,to,be,removed,new,array,list,vertex,k,vv,vertex,to,be,removed,add,vertex,return,remove,vertices,vertex,to,be,removed
Graph -> public Graph<K, VV, EV> removeVertex(Vertex<K, VV> vertex);1470042815;Removes the given vertex and its edges from the graph.__@param vertex the vertex to remove_@return the new graph containing the existing vertices and edges without_the removed vertex and its edges;public Graph<K, VV, EV> removeVertex(Vertex<K, VV> vertex) {__		List<Vertex<K, VV>> vertexToBeRemoved = new ArrayList<Vertex<K, VV>>()__		vertexToBeRemoved.add(vertex)___		return removeVertices(vertexToBeRemoved)__	};removes,the,given,vertex,and,its,edges,from,the,graph,param,vertex,the,vertex,to,remove,return,the,new,graph,containing,the,existing,vertices,and,edges,without,the,removed,vertex,and,its,edges;public,graph,k,vv,ev,remove,vertex,vertex,k,vv,vertex,list,vertex,k,vv,vertex,to,be,removed,new,array,list,vertex,k,vv,vertex,to,be,removed,add,vertex,return,remove,vertices,vertex,to,be,removed
Graph -> public Graph<K, VV, EV> removeVertex(Vertex<K, VV> vertex);1475684776;Removes the given vertex and its edges from the graph.__@param vertex the vertex to remove_@return the new graph containing the existing vertices and edges without_the removed vertex and its edges;public Graph<K, VV, EV> removeVertex(Vertex<K, VV> vertex) {__		List<Vertex<K, VV>> vertexToBeRemoved = new ArrayList<>()__		vertexToBeRemoved.add(vertex)___		return removeVertices(vertexToBeRemoved)__	};removes,the,given,vertex,and,its,edges,from,the,graph,param,vertex,the,vertex,to,remove,return,the,new,graph,containing,the,existing,vertices,and,edges,without,the,removed,vertex,and,its,edges;public,graph,k,vv,ev,remove,vertex,vertex,k,vv,vertex,list,vertex,k,vv,vertex,to,be,removed,new,array,list,vertex,to,be,removed,add,vertex,return,remove,vertices,vertex,to,be,removed
Graph -> public Graph<K, VV, EV> removeVertex(Vertex<K, VV> vertex);1475685606;Removes the given vertex and its edges from the graph.__@param vertex the vertex to remove_@return the new graph containing the existing vertices and edges without_the removed vertex and its edges;public Graph<K, VV, EV> removeVertex(Vertex<K, VV> vertex) {__		List<Vertex<K, VV>> vertexToBeRemoved = new ArrayList<>()__		vertexToBeRemoved.add(vertex)___		return removeVertices(vertexToBeRemoved)__	};removes,the,given,vertex,and,its,edges,from,the,graph,param,vertex,the,vertex,to,remove,return,the,new,graph,containing,the,existing,vertices,and,edges,without,the,removed,vertex,and,its,edges;public,graph,k,vv,ev,remove,vertex,vertex,k,vv,vertex,list,vertex,k,vv,vertex,to,be,removed,new,array,list,vertex,to,be,removed,add,vertex,return,remove,vertices,vertex,to,be,removed
Graph -> public Graph<K, VV, EV> removeVertex(Vertex<K, VV> vertex);1481745825;Removes the given vertex and its edges from the graph.__@param vertex the vertex to remove_@return the new graph containing the existing vertices and edges without_the removed vertex and its edges;public Graph<K, VV, EV> removeVertex(Vertex<K, VV> vertex) {__		List<Vertex<K, VV>> vertexToBeRemoved = new ArrayList<>()__		vertexToBeRemoved.add(vertex)___		return removeVertices(vertexToBeRemoved)__	};removes,the,given,vertex,and,its,edges,from,the,graph,param,vertex,the,vertex,to,remove,return,the,new,graph,containing,the,existing,vertices,and,edges,without,the,removed,vertex,and,its,edges;public,graph,k,vv,ev,remove,vertex,vertex,k,vv,vertex,list,vertex,k,vv,vertex,to,be,removed,new,array,list,vertex,to,be,removed,add,vertex,return,remove,vertices,vertex,to,be,removed
Graph -> public Graph<K, VV, EV> removeVertex(Vertex<K, VV> vertex);1481881009;Removes the given vertex and its edges from the graph.__@param vertex the vertex to remove_@return the new graph containing the existing vertices and edges without_the removed vertex and its edges;public Graph<K, VV, EV> removeVertex(Vertex<K, VV> vertex) {__		List<Vertex<K, VV>> vertexToBeRemoved = new ArrayList<>()__		vertexToBeRemoved.add(vertex)___		return removeVertices(vertexToBeRemoved)__	};removes,the,given,vertex,and,its,edges,from,the,graph,param,vertex,the,vertex,to,remove,return,the,new,graph,containing,the,existing,vertices,and,edges,without,the,removed,vertex,and,its,edges;public,graph,k,vv,ev,remove,vertex,vertex,k,vv,vertex,list,vertex,k,vv,vertex,to,be,removed,new,array,list,vertex,to,be,removed,add,vertex,return,remove,vertices,vertex,to,be,removed
Graph -> public Graph<K, VV, EV> removeVertex(Vertex<K, VV> vertex);1484160227;Removes the given vertex and its edges from the graph.__@param vertex the vertex to remove_@return the new graph containing the existing vertices and edges without_the removed vertex and its edges;public Graph<K, VV, EV> removeVertex(Vertex<K, VV> vertex) {__		List<Vertex<K, VV>> vertexToBeRemoved = new ArrayList<>()__		vertexToBeRemoved.add(vertex)___		return removeVertices(vertexToBeRemoved)__	};removes,the,given,vertex,and,its,edges,from,the,graph,param,vertex,the,vertex,to,remove,return,the,new,graph,containing,the,existing,vertices,and,edges,without,the,removed,vertex,and,its,edges;public,graph,k,vv,ev,remove,vertex,vertex,k,vv,vertex,list,vertex,k,vv,vertex,to,be,removed,new,array,list,vertex,to,be,removed,add,vertex,return,remove,vertices,vertex,to,be,removed
Graph -> public Graph<K, VV, EV> removeVertex(Vertex<K, VV> vertex);1484685504;Removes the given vertex and its edges from the graph.__@param vertex the vertex to remove_@return the new graph containing the existing vertices and edges without_the removed vertex and its edges;public Graph<K, VV, EV> removeVertex(Vertex<K, VV> vertex) {__		List<Vertex<K, VV>> vertexToBeRemoved = new ArrayList<>()__		vertexToBeRemoved.add(vertex)___		return removeVertices(vertexToBeRemoved)__	};removes,the,given,vertex,and,its,edges,from,the,graph,param,vertex,the,vertex,to,remove,return,the,new,graph,containing,the,existing,vertices,and,edges,without,the,removed,vertex,and,its,edges;public,graph,k,vv,ev,remove,vertex,vertex,k,vv,vertex,list,vertex,k,vv,vertex,to,be,removed,new,array,list,vertex,to,be,removed,add,vertex,return,remove,vertices,vertex,to,be,removed
Graph -> public Graph<K, VV, EV> removeVertex(Vertex<K, VV> vertex);1489068942;Removes the given vertex and its edges from the graph.__@param vertex the vertex to remove_@return the new graph containing the existing vertices and edges without_the removed vertex and its edges;public Graph<K, VV, EV> removeVertex(Vertex<K, VV> vertex) {__		List<Vertex<K, VV>> vertexToBeRemoved = new ArrayList<>()__		vertexToBeRemoved.add(vertex)___		return removeVertices(vertexToBeRemoved)__	};removes,the,given,vertex,and,its,edges,from,the,graph,param,vertex,the,vertex,to,remove,return,the,new,graph,containing,the,existing,vertices,and,edges,without,the,removed,vertex,and,its,edges;public,graph,k,vv,ev,remove,vertex,vertex,k,vv,vertex,list,vertex,k,vv,vertex,to,be,removed,new,array,list,vertex,to,be,removed,add,vertex,return,remove,vertices,vertex,to,be,removed
Graph -> public Graph<K, VV, EV> removeVertex(Vertex<K, VV> vertex);1490973446;Removes the given vertex and its edges from the graph.__@param vertex the vertex to remove_@return the new graph containing the existing vertices and edges without_the removed vertex and its edges;public Graph<K, VV, EV> removeVertex(Vertex<K, VV> vertex) {__		List<Vertex<K, VV>> vertexToBeRemoved = new ArrayList<>()__		vertexToBeRemoved.add(vertex)___		return removeVertices(vertexToBeRemoved)__	};removes,the,given,vertex,and,its,edges,from,the,graph,param,vertex,the,vertex,to,remove,return,the,new,graph,containing,the,existing,vertices,and,edges,without,the,removed,vertex,and,its,edges;public,graph,k,vv,ev,remove,vertex,vertex,k,vv,vertex,list,vertex,k,vv,vertex,to,be,removed,new,array,list,vertex,to,be,removed,add,vertex,return,remove,vertices,vertex,to,be,removed
Graph -> public Graph<K, VV, EV> removeVertex(Vertex<K, VV> vertex);1495819075;Removes the given vertex and its edges from the graph.__@param vertex the vertex to remove_@return the new graph containing the existing vertices and edges without_the removed vertex and its edges;public Graph<K, VV, EV> removeVertex(Vertex<K, VV> vertex) {__		List<Vertex<K, VV>> vertexToBeRemoved = new ArrayList<>()__		vertexToBeRemoved.add(vertex)___		return removeVertices(vertexToBeRemoved)__	};removes,the,given,vertex,and,its,edges,from,the,graph,param,vertex,the,vertex,to,remove,return,the,new,graph,containing,the,existing,vertices,and,edges,without,the,removed,vertex,and,its,edges;public,graph,k,vv,ev,remove,vertex,vertex,k,vv,vertex,list,vertex,k,vv,vertex,to,be,removed,new,array,list,vertex,to,be,removed,add,vertex,return,remove,vertices,vertex,to,be,removed
Graph -> public Graph<K, VV, EV> removeVertex(Vertex<K, VV> vertex);1502111816;Removes the given vertex and its edges from the graph.__@param vertex the vertex to remove_@return the new graph containing the existing vertices and edges without_the removed vertex and its edges;public Graph<K, VV, EV> removeVertex(Vertex<K, VV> vertex) {__		List<Vertex<K, VV>> vertexToBeRemoved = new ArrayList<>()__		vertexToBeRemoved.add(vertex)___		return removeVertices(vertexToBeRemoved)__	};removes,the,given,vertex,and,its,edges,from,the,graph,param,vertex,the,vertex,to,remove,return,the,new,graph,containing,the,existing,vertices,and,edges,without,the,removed,vertex,and,its,edges;public,graph,k,vv,ev,remove,vertex,vertex,k,vv,vertex,list,vertex,k,vv,vertex,to,be,removed,new,array,list,vertex,to,be,removed,add,vertex,return,remove,vertices,vertex,to,be,removed
Graph -> public <M> Graph<K, VV, EV> runGatherSumApplyIteration( 			org.apache.flink.graph.gsa.GatherFunction<VV, EV, M> gatherFunction, SumFunction<VV, EV, M> sumFunction, 			ApplyFunction<K, VV, M> applyFunction, int maximumNumberOfIterations, 			GSAConfiguration parameters);1475684776;Runs a Gather-Sum-Apply iteration on the graph with configuration options.__@param gatherFunction the gather function collects information about adjacent vertices and edges_@param sumFunction the sum function aggregates the gathered information_@param applyFunction the apply function updates the vertex values with the aggregates_@param maximumNumberOfIterations maximum number of iterations to perform_@param parameters the iteration configuration parameters_@param <M> the intermediate type used between gather, sum and apply__@return the updated Graph after the gather-sum-apply iteration has converged or_after maximumNumberOfIterations.;public <M> Graph<K, VV, EV> runGatherSumApplyIteration(_			org.apache.flink.graph.gsa.GatherFunction<VV, EV, M> gatherFunction, SumFunction<VV, EV, M> sumFunction,_			ApplyFunction<K, VV, M> applyFunction, int maximumNumberOfIterations,_			GSAConfiguration parameters) {__		GatherSumApplyIteration<K, VV, EV, M> iteration = GatherSumApplyIteration.withEdges(_				edges, gatherFunction, sumFunction, applyFunction, maximumNumberOfIterations)___		iteration.configure(parameters)___		DataSet<Vertex<K, VV>> newVertices = vertices.runOperation(iteration)___		return new Graph<>(newVertices, this.edges, this.context)__	};runs,a,gather,sum,apply,iteration,on,the,graph,with,configuration,options,param,gather,function,the,gather,function,collects,information,about,adjacent,vertices,and,edges,param,sum,function,the,sum,function,aggregates,the,gathered,information,param,apply,function,the,apply,function,updates,the,vertex,values,with,the,aggregates,param,maximum,number,of,iterations,maximum,number,of,iterations,to,perform,param,parameters,the,iteration,configuration,parameters,param,m,the,intermediate,type,used,between,gather,sum,and,apply,return,the,updated,graph,after,the,gather,sum,apply,iteration,has,converged,or,after,maximum,number,of,iterations;public,m,graph,k,vv,ev,run,gather,sum,apply,iteration,org,apache,flink,graph,gsa,gather,function,vv,ev,m,gather,function,sum,function,vv,ev,m,sum,function,apply,function,k,vv,m,apply,function,int,maximum,number,of,iterations,gsaconfiguration,parameters,gather,sum,apply,iteration,k,vv,ev,m,iteration,gather,sum,apply,iteration,with,edges,edges,gather,function,sum,function,apply,function,maximum,number,of,iterations,iteration,configure,parameters,data,set,vertex,k,vv,new,vertices,vertices,run,operation,iteration,return,new,graph,new,vertices,this,edges,this,context
Graph -> public <M> Graph<K, VV, EV> runGatherSumApplyIteration( 			org.apache.flink.graph.gsa.GatherFunction<VV, EV, M> gatherFunction, SumFunction<VV, EV, M> sumFunction, 			ApplyFunction<K, VV, M> applyFunction, int maximumNumberOfIterations, 			GSAConfiguration parameters);1475685606;Runs a Gather-Sum-Apply iteration on the graph with configuration options.__@param gatherFunction the gather function collects information about adjacent vertices and edges_@param sumFunction the sum function aggregates the gathered information_@param applyFunction the apply function updates the vertex values with the aggregates_@param maximumNumberOfIterations maximum number of iterations to perform_@param parameters the iteration configuration parameters_@param <M> the intermediate type used between gather, sum and apply__@return the updated Graph after the gather-sum-apply iteration has converged or_after maximumNumberOfIterations.;public <M> Graph<K, VV, EV> runGatherSumApplyIteration(_			org.apache.flink.graph.gsa.GatherFunction<VV, EV, M> gatherFunction, SumFunction<VV, EV, M> sumFunction,_			ApplyFunction<K, VV, M> applyFunction, int maximumNumberOfIterations,_			GSAConfiguration parameters) {__		GatherSumApplyIteration<K, VV, EV, M> iteration = GatherSumApplyIteration.withEdges(_				edges, gatherFunction, sumFunction, applyFunction, maximumNumberOfIterations)___		iteration.configure(parameters)___		DataSet<Vertex<K, VV>> newVertices = vertices.runOperation(iteration)___		return new Graph<>(newVertices, this.edges, this.context)__	};runs,a,gather,sum,apply,iteration,on,the,graph,with,configuration,options,param,gather,function,the,gather,function,collects,information,about,adjacent,vertices,and,edges,param,sum,function,the,sum,function,aggregates,the,gathered,information,param,apply,function,the,apply,function,updates,the,vertex,values,with,the,aggregates,param,maximum,number,of,iterations,maximum,number,of,iterations,to,perform,param,parameters,the,iteration,configuration,parameters,param,m,the,intermediate,type,used,between,gather,sum,and,apply,return,the,updated,graph,after,the,gather,sum,apply,iteration,has,converged,or,after,maximum,number,of,iterations;public,m,graph,k,vv,ev,run,gather,sum,apply,iteration,org,apache,flink,graph,gsa,gather,function,vv,ev,m,gather,function,sum,function,vv,ev,m,sum,function,apply,function,k,vv,m,apply,function,int,maximum,number,of,iterations,gsaconfiguration,parameters,gather,sum,apply,iteration,k,vv,ev,m,iteration,gather,sum,apply,iteration,with,edges,edges,gather,function,sum,function,apply,function,maximum,number,of,iterations,iteration,configure,parameters,data,set,vertex,k,vv,new,vertices,vertices,run,operation,iteration,return,new,graph,new,vertices,this,edges,this,context
Graph -> public <M> Graph<K, VV, EV> runGatherSumApplyIteration( 			org.apache.flink.graph.gsa.GatherFunction<VV, EV, M> gatherFunction, SumFunction<VV, EV, M> sumFunction, 			ApplyFunction<K, VV, M> applyFunction, int maximumNumberOfIterations, 			GSAConfiguration parameters);1481745825;Runs a Gather-Sum-Apply iteration on the graph with configuration options.__@param gatherFunction the gather function collects information about adjacent vertices and edges_@param sumFunction the sum function aggregates the gathered information_@param applyFunction the apply function updates the vertex values with the aggregates_@param maximumNumberOfIterations maximum number of iterations to perform_@param parameters the iteration configuration parameters_@param <M> the intermediate type used between gather, sum and apply__@return the updated Graph after the gather-sum-apply iteration has converged or_after maximumNumberOfIterations.;public <M> Graph<K, VV, EV> runGatherSumApplyIteration(_			org.apache.flink.graph.gsa.GatherFunction<VV, EV, M> gatherFunction, SumFunction<VV, EV, M> sumFunction,_			ApplyFunction<K, VV, M> applyFunction, int maximumNumberOfIterations,_			GSAConfiguration parameters) {__		GatherSumApplyIteration<K, VV, EV, M> iteration = GatherSumApplyIteration.withEdges(_				edges, gatherFunction, sumFunction, applyFunction, maximumNumberOfIterations)___		iteration.configure(parameters)___		DataSet<Vertex<K, VV>> newVertices = vertices.runOperation(iteration)___		return new Graph<>(newVertices, this.edges, this.context)__	};runs,a,gather,sum,apply,iteration,on,the,graph,with,configuration,options,param,gather,function,the,gather,function,collects,information,about,adjacent,vertices,and,edges,param,sum,function,the,sum,function,aggregates,the,gathered,information,param,apply,function,the,apply,function,updates,the,vertex,values,with,the,aggregates,param,maximum,number,of,iterations,maximum,number,of,iterations,to,perform,param,parameters,the,iteration,configuration,parameters,param,m,the,intermediate,type,used,between,gather,sum,and,apply,return,the,updated,graph,after,the,gather,sum,apply,iteration,has,converged,or,after,maximum,number,of,iterations;public,m,graph,k,vv,ev,run,gather,sum,apply,iteration,org,apache,flink,graph,gsa,gather,function,vv,ev,m,gather,function,sum,function,vv,ev,m,sum,function,apply,function,k,vv,m,apply,function,int,maximum,number,of,iterations,gsaconfiguration,parameters,gather,sum,apply,iteration,k,vv,ev,m,iteration,gather,sum,apply,iteration,with,edges,edges,gather,function,sum,function,apply,function,maximum,number,of,iterations,iteration,configure,parameters,data,set,vertex,k,vv,new,vertices,vertices,run,operation,iteration,return,new,graph,new,vertices,this,edges,this,context
Graph -> public <M> Graph<K, VV, EV> runGatherSumApplyIteration( 			org.apache.flink.graph.gsa.GatherFunction<VV, EV, M> gatherFunction, SumFunction<VV, EV, M> sumFunction, 			ApplyFunction<K, VV, M> applyFunction, int maximumNumberOfIterations, 			GSAConfiguration parameters);1481881009;Runs a Gather-Sum-Apply iteration on the graph with configuration options.__@param gatherFunction the gather function collects information about adjacent vertices and edges_@param sumFunction the sum function aggregates the gathered information_@param applyFunction the apply function updates the vertex values with the aggregates_@param maximumNumberOfIterations maximum number of iterations to perform_@param parameters the iteration configuration parameters_@param <M> the intermediate type used between gather, sum and apply__@return the updated Graph after the gather-sum-apply iteration has converged or_after maximumNumberOfIterations.;public <M> Graph<K, VV, EV> runGatherSumApplyIteration(_			org.apache.flink.graph.gsa.GatherFunction<VV, EV, M> gatherFunction, SumFunction<VV, EV, M> sumFunction,_			ApplyFunction<K, VV, M> applyFunction, int maximumNumberOfIterations,_			GSAConfiguration parameters) {__		GatherSumApplyIteration<K, VV, EV, M> iteration = GatherSumApplyIteration.withEdges(_				edges, gatherFunction, sumFunction, applyFunction, maximumNumberOfIterations)___		iteration.configure(parameters)___		DataSet<Vertex<K, VV>> newVertices = vertices.runOperation(iteration)___		return new Graph<>(newVertices, this.edges, this.context)__	};runs,a,gather,sum,apply,iteration,on,the,graph,with,configuration,options,param,gather,function,the,gather,function,collects,information,about,adjacent,vertices,and,edges,param,sum,function,the,sum,function,aggregates,the,gathered,information,param,apply,function,the,apply,function,updates,the,vertex,values,with,the,aggregates,param,maximum,number,of,iterations,maximum,number,of,iterations,to,perform,param,parameters,the,iteration,configuration,parameters,param,m,the,intermediate,type,used,between,gather,sum,and,apply,return,the,updated,graph,after,the,gather,sum,apply,iteration,has,converged,or,after,maximum,number,of,iterations;public,m,graph,k,vv,ev,run,gather,sum,apply,iteration,org,apache,flink,graph,gsa,gather,function,vv,ev,m,gather,function,sum,function,vv,ev,m,sum,function,apply,function,k,vv,m,apply,function,int,maximum,number,of,iterations,gsaconfiguration,parameters,gather,sum,apply,iteration,k,vv,ev,m,iteration,gather,sum,apply,iteration,with,edges,edges,gather,function,sum,function,apply,function,maximum,number,of,iterations,iteration,configure,parameters,data,set,vertex,k,vv,new,vertices,vertices,run,operation,iteration,return,new,graph,new,vertices,this,edges,this,context
Graph -> public <M> Graph<K, VV, EV> runGatherSumApplyIteration( 			org.apache.flink.graph.gsa.GatherFunction<VV, EV, M> gatherFunction, SumFunction<VV, EV, M> sumFunction, 			ApplyFunction<K, VV, M> applyFunction, int maximumNumberOfIterations, 			GSAConfiguration parameters);1484160227;Runs a Gather-Sum-Apply iteration on the graph with configuration options.__@param gatherFunction the gather function collects information about adjacent vertices and edges_@param sumFunction the sum function aggregates the gathered information_@param applyFunction the apply function updates the vertex values with the aggregates_@param maximumNumberOfIterations maximum number of iterations to perform_@param parameters the iteration configuration parameters_@param <M> the intermediate type used between gather, sum and apply__@return the updated Graph after the gather-sum-apply iteration has converged or_after maximumNumberOfIterations.;public <M> Graph<K, VV, EV> runGatherSumApplyIteration(_			org.apache.flink.graph.gsa.GatherFunction<VV, EV, M> gatherFunction, SumFunction<VV, EV, M> sumFunction,_			ApplyFunction<K, VV, M> applyFunction, int maximumNumberOfIterations,_			GSAConfiguration parameters) {__		GatherSumApplyIteration<K, VV, EV, M> iteration = GatherSumApplyIteration.withEdges(_				edges, gatherFunction, sumFunction, applyFunction, maximumNumberOfIterations)___		iteration.configure(parameters)___		DataSet<Vertex<K, VV>> newVertices = vertices.runOperation(iteration)___		return new Graph<>(newVertices, this.edges, this.context)__	};runs,a,gather,sum,apply,iteration,on,the,graph,with,configuration,options,param,gather,function,the,gather,function,collects,information,about,adjacent,vertices,and,edges,param,sum,function,the,sum,function,aggregates,the,gathered,information,param,apply,function,the,apply,function,updates,the,vertex,values,with,the,aggregates,param,maximum,number,of,iterations,maximum,number,of,iterations,to,perform,param,parameters,the,iteration,configuration,parameters,param,m,the,intermediate,type,used,between,gather,sum,and,apply,return,the,updated,graph,after,the,gather,sum,apply,iteration,has,converged,or,after,maximum,number,of,iterations;public,m,graph,k,vv,ev,run,gather,sum,apply,iteration,org,apache,flink,graph,gsa,gather,function,vv,ev,m,gather,function,sum,function,vv,ev,m,sum,function,apply,function,k,vv,m,apply,function,int,maximum,number,of,iterations,gsaconfiguration,parameters,gather,sum,apply,iteration,k,vv,ev,m,iteration,gather,sum,apply,iteration,with,edges,edges,gather,function,sum,function,apply,function,maximum,number,of,iterations,iteration,configure,parameters,data,set,vertex,k,vv,new,vertices,vertices,run,operation,iteration,return,new,graph,new,vertices,this,edges,this,context
Graph -> public <M> Graph<K, VV, EV> runGatherSumApplyIteration( 			org.apache.flink.graph.gsa.GatherFunction<VV, EV, M> gatherFunction, SumFunction<VV, EV, M> sumFunction, 			ApplyFunction<K, VV, M> applyFunction, int maximumNumberOfIterations, 			GSAConfiguration parameters);1484685504;Runs a Gather-Sum-Apply iteration on the graph with configuration options.__@param gatherFunction the gather function collects information about adjacent vertices and edges_@param sumFunction the sum function aggregates the gathered information_@param applyFunction the apply function updates the vertex values with the aggregates_@param maximumNumberOfIterations maximum number of iterations to perform_@param parameters the iteration configuration parameters_@param <M> the intermediate type used between gather, sum and apply__@return the updated Graph after the gather-sum-apply iteration has converged or_after maximumNumberOfIterations.;public <M> Graph<K, VV, EV> runGatherSumApplyIteration(_			org.apache.flink.graph.gsa.GatherFunction<VV, EV, M> gatherFunction, SumFunction<VV, EV, M> sumFunction,_			ApplyFunction<K, VV, M> applyFunction, int maximumNumberOfIterations,_			GSAConfiguration parameters) {__		GatherSumApplyIteration<K, VV, EV, M> iteration = GatherSumApplyIteration.withEdges(_				edges, gatherFunction, sumFunction, applyFunction, maximumNumberOfIterations)___		iteration.configure(parameters)___		DataSet<Vertex<K, VV>> newVertices = vertices.runOperation(iteration)___		return new Graph<>(newVertices, this.edges, this.context)__	};runs,a,gather,sum,apply,iteration,on,the,graph,with,configuration,options,param,gather,function,the,gather,function,collects,information,about,adjacent,vertices,and,edges,param,sum,function,the,sum,function,aggregates,the,gathered,information,param,apply,function,the,apply,function,updates,the,vertex,values,with,the,aggregates,param,maximum,number,of,iterations,maximum,number,of,iterations,to,perform,param,parameters,the,iteration,configuration,parameters,param,m,the,intermediate,type,used,between,gather,sum,and,apply,return,the,updated,graph,after,the,gather,sum,apply,iteration,has,converged,or,after,maximum,number,of,iterations;public,m,graph,k,vv,ev,run,gather,sum,apply,iteration,org,apache,flink,graph,gsa,gather,function,vv,ev,m,gather,function,sum,function,vv,ev,m,sum,function,apply,function,k,vv,m,apply,function,int,maximum,number,of,iterations,gsaconfiguration,parameters,gather,sum,apply,iteration,k,vv,ev,m,iteration,gather,sum,apply,iteration,with,edges,edges,gather,function,sum,function,apply,function,maximum,number,of,iterations,iteration,configure,parameters,data,set,vertex,k,vv,new,vertices,vertices,run,operation,iteration,return,new,graph,new,vertices,this,edges,this,context
Graph -> public <M> Graph<K, VV, EV> runGatherSumApplyIteration( 			org.apache.flink.graph.gsa.GatherFunction<VV, EV, M> gatherFunction, SumFunction<VV, EV, M> sumFunction, 			ApplyFunction<K, VV, M> applyFunction, int maximumNumberOfIterations, 			GSAConfiguration parameters);1489068942;Runs a Gather-Sum-Apply iteration on the graph with configuration options.__@param gatherFunction the gather function collects information about adjacent vertices and edges_@param sumFunction the sum function aggregates the gathered information_@param applyFunction the apply function updates the vertex values with the aggregates_@param maximumNumberOfIterations maximum number of iterations to perform_@param parameters the iteration configuration parameters_@param <M> the intermediate type used between gather, sum and apply__@return the updated Graph after the gather-sum-apply iteration has converged or_after maximumNumberOfIterations.;public <M> Graph<K, VV, EV> runGatherSumApplyIteration(_			org.apache.flink.graph.gsa.GatherFunction<VV, EV, M> gatherFunction, SumFunction<VV, EV, M> sumFunction,_			ApplyFunction<K, VV, M> applyFunction, int maximumNumberOfIterations,_			GSAConfiguration parameters) {__		GatherSumApplyIteration<K, VV, EV, M> iteration = GatherSumApplyIteration.withEdges(_				edges, gatherFunction, sumFunction, applyFunction, maximumNumberOfIterations)___		iteration.configure(parameters)___		DataSet<Vertex<K, VV>> newVertices = vertices.runOperation(iteration)___		return new Graph<>(newVertices, this.edges, this.context)__	};runs,a,gather,sum,apply,iteration,on,the,graph,with,configuration,options,param,gather,function,the,gather,function,collects,information,about,adjacent,vertices,and,edges,param,sum,function,the,sum,function,aggregates,the,gathered,information,param,apply,function,the,apply,function,updates,the,vertex,values,with,the,aggregates,param,maximum,number,of,iterations,maximum,number,of,iterations,to,perform,param,parameters,the,iteration,configuration,parameters,param,m,the,intermediate,type,used,between,gather,sum,and,apply,return,the,updated,graph,after,the,gather,sum,apply,iteration,has,converged,or,after,maximum,number,of,iterations;public,m,graph,k,vv,ev,run,gather,sum,apply,iteration,org,apache,flink,graph,gsa,gather,function,vv,ev,m,gather,function,sum,function,vv,ev,m,sum,function,apply,function,k,vv,m,apply,function,int,maximum,number,of,iterations,gsaconfiguration,parameters,gather,sum,apply,iteration,k,vv,ev,m,iteration,gather,sum,apply,iteration,with,edges,edges,gather,function,sum,function,apply,function,maximum,number,of,iterations,iteration,configure,parameters,data,set,vertex,k,vv,new,vertices,vertices,run,operation,iteration,return,new,graph,new,vertices,this,edges,this,context
Graph -> public <M> Graph<K, VV, EV> runGatherSumApplyIteration( 			org.apache.flink.graph.gsa.GatherFunction<VV, EV, M> gatherFunction, SumFunction<VV, EV, M> sumFunction, 			ApplyFunction<K, VV, M> applyFunction, int maximumNumberOfIterations, 			GSAConfiguration parameters);1490973446;Runs a Gather-Sum-Apply iteration on the graph with configuration options.__@param gatherFunction the gather function collects information about adjacent vertices and edges_@param sumFunction the sum function aggregates the gathered information_@param applyFunction the apply function updates the vertex values with the aggregates_@param maximumNumberOfIterations maximum number of iterations to perform_@param parameters the iteration configuration parameters_@param <M> the intermediate type used between gather, sum and apply__@return the updated Graph after the gather-sum-apply iteration has converged or_after maximumNumberOfIterations.;public <M> Graph<K, VV, EV> runGatherSumApplyIteration(_			org.apache.flink.graph.gsa.GatherFunction<VV, EV, M> gatherFunction, SumFunction<VV, EV, M> sumFunction,_			ApplyFunction<K, VV, M> applyFunction, int maximumNumberOfIterations,_			GSAConfiguration parameters) {__		GatherSumApplyIteration<K, VV, EV, M> iteration = GatherSumApplyIteration.withEdges(_				edges, gatherFunction, sumFunction, applyFunction, maximumNumberOfIterations)___		iteration.configure(parameters)___		DataSet<Vertex<K, VV>> newVertices = vertices.runOperation(iteration)___		return new Graph<>(newVertices, this.edges, this.context)__	};runs,a,gather,sum,apply,iteration,on,the,graph,with,configuration,options,param,gather,function,the,gather,function,collects,information,about,adjacent,vertices,and,edges,param,sum,function,the,sum,function,aggregates,the,gathered,information,param,apply,function,the,apply,function,updates,the,vertex,values,with,the,aggregates,param,maximum,number,of,iterations,maximum,number,of,iterations,to,perform,param,parameters,the,iteration,configuration,parameters,param,m,the,intermediate,type,used,between,gather,sum,and,apply,return,the,updated,graph,after,the,gather,sum,apply,iteration,has,converged,or,after,maximum,number,of,iterations;public,m,graph,k,vv,ev,run,gather,sum,apply,iteration,org,apache,flink,graph,gsa,gather,function,vv,ev,m,gather,function,sum,function,vv,ev,m,sum,function,apply,function,k,vv,m,apply,function,int,maximum,number,of,iterations,gsaconfiguration,parameters,gather,sum,apply,iteration,k,vv,ev,m,iteration,gather,sum,apply,iteration,with,edges,edges,gather,function,sum,function,apply,function,maximum,number,of,iterations,iteration,configure,parameters,data,set,vertex,k,vv,new,vertices,vertices,run,operation,iteration,return,new,graph,new,vertices,this,edges,this,context
Graph -> public <M> Graph<K, VV, EV> runGatherSumApplyIteration( 			org.apache.flink.graph.gsa.GatherFunction<VV, EV, M> gatherFunction, SumFunction<VV, EV, M> sumFunction, 			ApplyFunction<K, VV, M> applyFunction, int maximumNumberOfIterations, 			GSAConfiguration parameters);1495819075;Runs a Gather-Sum-Apply iteration on the graph with configuration options.__@param gatherFunction the gather function collects information about adjacent vertices and edges_@param sumFunction the sum function aggregates the gathered information_@param applyFunction the apply function updates the vertex values with the aggregates_@param maximumNumberOfIterations maximum number of iterations to perform_@param parameters the iteration configuration parameters_@param <M> the intermediate type used between gather, sum and apply__@return the updated Graph after the gather-sum-apply iteration has converged or_after maximumNumberOfIterations.;public <M> Graph<K, VV, EV> runGatherSumApplyIteration(_			org.apache.flink.graph.gsa.GatherFunction<VV, EV, M> gatherFunction, SumFunction<VV, EV, M> sumFunction,_			ApplyFunction<K, VV, M> applyFunction, int maximumNumberOfIterations,_			GSAConfiguration parameters) {__		GatherSumApplyIteration<K, VV, EV, M> iteration = GatherSumApplyIteration.withEdges(_				edges, gatherFunction, sumFunction, applyFunction, maximumNumberOfIterations)___		iteration.configure(parameters)___		DataSet<Vertex<K, VV>> newVertices = vertices.runOperation(iteration)___		return new Graph<>(newVertices, this.edges, this.context)__	};runs,a,gather,sum,apply,iteration,on,the,graph,with,configuration,options,param,gather,function,the,gather,function,collects,information,about,adjacent,vertices,and,edges,param,sum,function,the,sum,function,aggregates,the,gathered,information,param,apply,function,the,apply,function,updates,the,vertex,values,with,the,aggregates,param,maximum,number,of,iterations,maximum,number,of,iterations,to,perform,param,parameters,the,iteration,configuration,parameters,param,m,the,intermediate,type,used,between,gather,sum,and,apply,return,the,updated,graph,after,the,gather,sum,apply,iteration,has,converged,or,after,maximum,number,of,iterations;public,m,graph,k,vv,ev,run,gather,sum,apply,iteration,org,apache,flink,graph,gsa,gather,function,vv,ev,m,gather,function,sum,function,vv,ev,m,sum,function,apply,function,k,vv,m,apply,function,int,maximum,number,of,iterations,gsaconfiguration,parameters,gather,sum,apply,iteration,k,vv,ev,m,iteration,gather,sum,apply,iteration,with,edges,edges,gather,function,sum,function,apply,function,maximum,number,of,iterations,iteration,configure,parameters,data,set,vertex,k,vv,new,vertices,vertices,run,operation,iteration,return,new,graph,new,vertices,this,edges,this,context
Graph -> public <M> Graph<K, VV, EV> runGatherSumApplyIteration( 			org.apache.flink.graph.gsa.GatherFunction<VV, EV, M> gatherFunction, SumFunction<VV, EV, M> sumFunction, 			ApplyFunction<K, VV, M> applyFunction, int maximumNumberOfIterations, 			GSAConfiguration parameters);1502111816;Runs a Gather-Sum-Apply iteration on the graph with configuration options.__@param gatherFunction the gather function collects information about adjacent vertices and edges_@param sumFunction the sum function aggregates the gathered information_@param applyFunction the apply function updates the vertex values with the aggregates_@param maximumNumberOfIterations maximum number of iterations to perform_@param parameters the iteration configuration parameters_@param <M> the intermediate type used between gather, sum and apply__@return the updated Graph after the gather-sum-apply iteration has converged or_after maximumNumberOfIterations.;public <M> Graph<K, VV, EV> runGatherSumApplyIteration(_			org.apache.flink.graph.gsa.GatherFunction<VV, EV, M> gatherFunction, SumFunction<VV, EV, M> sumFunction,_			ApplyFunction<K, VV, M> applyFunction, int maximumNumberOfIterations,_			GSAConfiguration parameters) {__		GatherSumApplyIteration<K, VV, EV, M> iteration = GatherSumApplyIteration.withEdges(_				edges, gatherFunction, sumFunction, applyFunction, maximumNumberOfIterations)___		iteration.configure(parameters)___		DataSet<Vertex<K, VV>> newVertices = vertices.runOperation(iteration)___		return new Graph<>(newVertices, this.edges, this.context)__	};runs,a,gather,sum,apply,iteration,on,the,graph,with,configuration,options,param,gather,function,the,gather,function,collects,information,about,adjacent,vertices,and,edges,param,sum,function,the,sum,function,aggregates,the,gathered,information,param,apply,function,the,apply,function,updates,the,vertex,values,with,the,aggregates,param,maximum,number,of,iterations,maximum,number,of,iterations,to,perform,param,parameters,the,iteration,configuration,parameters,param,m,the,intermediate,type,used,between,gather,sum,and,apply,return,the,updated,graph,after,the,gather,sum,apply,iteration,has,converged,or,after,maximum,number,of,iterations;public,m,graph,k,vv,ev,run,gather,sum,apply,iteration,org,apache,flink,graph,gsa,gather,function,vv,ev,m,gather,function,sum,function,vv,ev,m,sum,function,apply,function,k,vv,m,apply,function,int,maximum,number,of,iterations,gsaconfiguration,parameters,gather,sum,apply,iteration,k,vv,ev,m,iteration,gather,sum,apply,iteration,with,edges,edges,gather,function,sum,function,apply,function,maximum,number,of,iterations,iteration,configure,parameters,data,set,vertex,k,vv,new,vertices,vertices,run,operation,iteration,return,new,graph,new,vertices,this,edges,this,context
Graph -> public <M> Graph<K, VV, EV> runVertexCentricIteration( 			ComputeFunction<K, VV, EV, M> computeFunction, 			MessageCombiner<K, M> combiner, int maximumNumberOfIterations, 			VertexCentricConfiguration parameters);1458583829;Runs a VetexCentric iteration on the graph with configuration options.__@param computeFunction the vertex update function_@param combiner an optional message combiner_@param maximumNumberOfIterations maximum number of iterations to perform_@param parameters the iteration configuration parameters__@return the updated Graph after the vertex-centric iteration has converged or_after maximumNumberOfIterations.;public <M> Graph<K, VV, EV> runVertexCentricIteration(_			ComputeFunction<K, VV, EV, M> computeFunction,_			MessageCombiner<K, M> combiner, int maximumNumberOfIterations,_			VertexCentricConfiguration parameters) {__		VertexCentricIteration<K, VV, EV, M> iteration = VertexCentricIteration.withEdges(_				edges, computeFunction, maximumNumberOfIterations)__		iteration.configure(parameters)__		DataSet<Vertex<K, VV>> newVertices = this.getVertices().runOperation(iteration)__		return new Graph<K, VV, EV>(newVertices, this.edges, this.context)__	};runs,a,vetex,centric,iteration,on,the,graph,with,configuration,options,param,compute,function,the,vertex,update,function,param,combiner,an,optional,message,combiner,param,maximum,number,of,iterations,maximum,number,of,iterations,to,perform,param,parameters,the,iteration,configuration,parameters,return,the,updated,graph,after,the,vertex,centric,iteration,has,converged,or,after,maximum,number,of,iterations;public,m,graph,k,vv,ev,run,vertex,centric,iteration,compute,function,k,vv,ev,m,compute,function,message,combiner,k,m,combiner,int,maximum,number,of,iterations,vertex,centric,configuration,parameters,vertex,centric,iteration,k,vv,ev,m,iteration,vertex,centric,iteration,with,edges,edges,compute,function,maximum,number,of,iterations,iteration,configure,parameters,data,set,vertex,k,vv,new,vertices,this,get,vertices,run,operation,iteration,return,new,graph,k,vv,ev,new,vertices,this,edges,this,context
Graph -> public <M> Graph<K, VV, EV> runVertexCentricIteration( 			ComputeFunction<K, VV, EV, M> computeFunction, 			MessageCombiner<K, M> combiner, int maximumNumberOfIterations, 			VertexCentricConfiguration parameters);1458583829;Runs a {@link VertexCentricIteration} on the graph with configuration options.__@param computeFunction the vertex compute function_@param combiner an optional message combiner_@param maximumNumberOfIterations maximum number of iterations to perform_@param parameters the {@link VertexCentricConfiguration} parameters__@return the updated Graph after the vertex-centric iteration has converged or_after maximumNumberOfIterations.;public <M> Graph<K, VV, EV> runVertexCentricIteration(_			ComputeFunction<K, VV, EV, M> computeFunction,_			MessageCombiner<K, M> combiner, int maximumNumberOfIterations,_			VertexCentricConfiguration parameters) {__		VertexCentricIteration<K, VV, EV, M> iteration = VertexCentricIteration.withEdges(_				edges, computeFunction, maximumNumberOfIterations)__		iteration.configure(parameters)__		DataSet<Vertex<K, VV>> newVertices = this.getVertices().runOperation(iteration)__		return new Graph<K, VV, EV>(newVertices, this.edges, this.context)__	};runs,a,link,vertex,centric,iteration,on,the,graph,with,configuration,options,param,compute,function,the,vertex,compute,function,param,combiner,an,optional,message,combiner,param,maximum,number,of,iterations,maximum,number,of,iterations,to,perform,param,parameters,the,link,vertex,centric,configuration,parameters,return,the,updated,graph,after,the,vertex,centric,iteration,has,converged,or,after,maximum,number,of,iterations;public,m,graph,k,vv,ev,run,vertex,centric,iteration,compute,function,k,vv,ev,m,compute,function,message,combiner,k,m,combiner,int,maximum,number,of,iterations,vertex,centric,configuration,parameters,vertex,centric,iteration,k,vv,ev,m,iteration,vertex,centric,iteration,with,edges,edges,compute,function,maximum,number,of,iterations,iteration,configure,parameters,data,set,vertex,k,vv,new,vertices,this,get,vertices,run,operation,iteration,return,new,graph,k,vv,ev,new,vertices,this,edges,this,context
Graph -> public <M> Graph<K, VV, EV> runVertexCentricIteration( 			ComputeFunction<K, VV, EV, M> computeFunction, 			MessageCombiner<K, M> combiner, int maximumNumberOfIterations, 			VertexCentricConfiguration parameters);1462100316;Runs a {@link VertexCentricIteration} on the graph with configuration options.__@param computeFunction the vertex compute function_@param combiner an optional message combiner_@param maximumNumberOfIterations maximum number of iterations to perform_@param parameters the {@link VertexCentricConfiguration} parameters__@return the updated Graph after the vertex-centric iteration has converged or_after maximumNumberOfIterations.;public <M> Graph<K, VV, EV> runVertexCentricIteration(_			ComputeFunction<K, VV, EV, M> computeFunction,_			MessageCombiner<K, M> combiner, int maximumNumberOfIterations,_			VertexCentricConfiguration parameters) {__		VertexCentricIteration<K, VV, EV, M> iteration = VertexCentricIteration.withEdges(_				edges, computeFunction, maximumNumberOfIterations)__		iteration.configure(parameters)__		DataSet<Vertex<K, VV>> newVertices = this.getVertices().runOperation(iteration)__		return new Graph<K, VV, EV>(newVertices, this.edges, this.context)__	};runs,a,link,vertex,centric,iteration,on,the,graph,with,configuration,options,param,compute,function,the,vertex,compute,function,param,combiner,an,optional,message,combiner,param,maximum,number,of,iterations,maximum,number,of,iterations,to,perform,param,parameters,the,link,vertex,centric,configuration,parameters,return,the,updated,graph,after,the,vertex,centric,iteration,has,converged,or,after,maximum,number,of,iterations;public,m,graph,k,vv,ev,run,vertex,centric,iteration,compute,function,k,vv,ev,m,compute,function,message,combiner,k,m,combiner,int,maximum,number,of,iterations,vertex,centric,configuration,parameters,vertex,centric,iteration,k,vv,ev,m,iteration,vertex,centric,iteration,with,edges,edges,compute,function,maximum,number,of,iterations,iteration,configure,parameters,data,set,vertex,k,vv,new,vertices,this,get,vertices,run,operation,iteration,return,new,graph,k,vv,ev,new,vertices,this,edges,this,context
Graph -> public <M> Graph<K, VV, EV> runVertexCentricIteration( 			ComputeFunction<K, VV, EV, M> computeFunction, 			MessageCombiner<K, M> combiner, int maximumNumberOfIterations, 			VertexCentricConfiguration parameters);1462100316;Runs a {@link VertexCentricIteration} on the graph with configuration options.__@param computeFunction the vertex compute function_@param combiner an optional message combiner_@param maximumNumberOfIterations maximum number of iterations to perform_@param parameters the {@link VertexCentricConfiguration} parameters__@return the updated Graph after the vertex-centric iteration has converged or_after maximumNumberOfIterations.;public <M> Graph<K, VV, EV> runVertexCentricIteration(_			ComputeFunction<K, VV, EV, M> computeFunction,_			MessageCombiner<K, M> combiner, int maximumNumberOfIterations,_			VertexCentricConfiguration parameters) {__		VertexCentricIteration<K, VV, EV, M> iteration = VertexCentricIteration.withEdges(_				edges, computeFunction, maximumNumberOfIterations)__		iteration.configure(parameters)__		DataSet<Vertex<K, VV>> newVertices = this.getVertices().runOperation(iteration)__		return new Graph<K, VV, EV>(newVertices, this.edges, this.context)__	};runs,a,link,vertex,centric,iteration,on,the,graph,with,configuration,options,param,compute,function,the,vertex,compute,function,param,combiner,an,optional,message,combiner,param,maximum,number,of,iterations,maximum,number,of,iterations,to,perform,param,parameters,the,link,vertex,centric,configuration,parameters,return,the,updated,graph,after,the,vertex,centric,iteration,has,converged,or,after,maximum,number,of,iterations;public,m,graph,k,vv,ev,run,vertex,centric,iteration,compute,function,k,vv,ev,m,compute,function,message,combiner,k,m,combiner,int,maximum,number,of,iterations,vertex,centric,configuration,parameters,vertex,centric,iteration,k,vv,ev,m,iteration,vertex,centric,iteration,with,edges,edges,compute,function,maximum,number,of,iterations,iteration,configure,parameters,data,set,vertex,k,vv,new,vertices,this,get,vertices,run,operation,iteration,return,new,graph,k,vv,ev,new,vertices,this,edges,this,context
Graph -> public <M> Graph<K, VV, EV> runVertexCentricIteration( 			ComputeFunction<K, VV, EV, M> computeFunction, 			MessageCombiner<K, M> combiner, int maximumNumberOfIterations, 			VertexCentricConfiguration parameters);1462205213;Runs a {@link VertexCentricIteration} on the graph with configuration options.__@param computeFunction the vertex compute function_@param combiner an optional message combiner_@param maximumNumberOfIterations maximum number of iterations to perform_@param parameters the {@link VertexCentricConfiguration} parameters__@return the updated Graph after the vertex-centric iteration has converged or_after maximumNumberOfIterations.;public <M> Graph<K, VV, EV> runVertexCentricIteration(_			ComputeFunction<K, VV, EV, M> computeFunction,_			MessageCombiner<K, M> combiner, int maximumNumberOfIterations,_			VertexCentricConfiguration parameters) {__		VertexCentricIteration<K, VV, EV, M> iteration = VertexCentricIteration.withEdges(_				edges, computeFunction, maximumNumberOfIterations)__		iteration.configure(parameters)__		DataSet<Vertex<K, VV>> newVertices = this.getVertices().runOperation(iteration)__		return new Graph<K, VV, EV>(newVertices, this.edges, this.context)__	};runs,a,link,vertex,centric,iteration,on,the,graph,with,configuration,options,param,compute,function,the,vertex,compute,function,param,combiner,an,optional,message,combiner,param,maximum,number,of,iterations,maximum,number,of,iterations,to,perform,param,parameters,the,link,vertex,centric,configuration,parameters,return,the,updated,graph,after,the,vertex,centric,iteration,has,converged,or,after,maximum,number,of,iterations;public,m,graph,k,vv,ev,run,vertex,centric,iteration,compute,function,k,vv,ev,m,compute,function,message,combiner,k,m,combiner,int,maximum,number,of,iterations,vertex,centric,configuration,parameters,vertex,centric,iteration,k,vv,ev,m,iteration,vertex,centric,iteration,with,edges,edges,compute,function,maximum,number,of,iterations,iteration,configure,parameters,data,set,vertex,k,vv,new,vertices,this,get,vertices,run,operation,iteration,return,new,graph,k,vv,ev,new,vertices,this,edges,this,context
Graph -> public <M> Graph<K, VV, EV> runVertexCentricIteration( 			ComputeFunction<K, VV, EV, M> computeFunction, 			MessageCombiner<K, M> combiner, int maximumNumberOfIterations, 			VertexCentricConfiguration parameters);1462208859;Runs a {@link VertexCentricIteration} on the graph with configuration options.__@param computeFunction the vertex compute function_@param combiner an optional message combiner_@param maximumNumberOfIterations maximum number of iterations to perform_@param parameters the {@link VertexCentricConfiguration} parameters__@return the updated Graph after the vertex-centric iteration has converged or_after maximumNumberOfIterations.;public <M> Graph<K, VV, EV> runVertexCentricIteration(_			ComputeFunction<K, VV, EV, M> computeFunction,_			MessageCombiner<K, M> combiner, int maximumNumberOfIterations,_			VertexCentricConfiguration parameters) {__		VertexCentricIteration<K, VV, EV, M> iteration = VertexCentricIteration.withEdges(_				edges, computeFunction, maximumNumberOfIterations)__		iteration.configure(parameters)__		DataSet<Vertex<K, VV>> newVertices = this.getVertices().runOperation(iteration)__		return new Graph<K, VV, EV>(newVertices, this.edges, this.context)__	};runs,a,link,vertex,centric,iteration,on,the,graph,with,configuration,options,param,compute,function,the,vertex,compute,function,param,combiner,an,optional,message,combiner,param,maximum,number,of,iterations,maximum,number,of,iterations,to,perform,param,parameters,the,link,vertex,centric,configuration,parameters,return,the,updated,graph,after,the,vertex,centric,iteration,has,converged,or,after,maximum,number,of,iterations;public,m,graph,k,vv,ev,run,vertex,centric,iteration,compute,function,k,vv,ev,m,compute,function,message,combiner,k,m,combiner,int,maximum,number,of,iterations,vertex,centric,configuration,parameters,vertex,centric,iteration,k,vv,ev,m,iteration,vertex,centric,iteration,with,edges,edges,compute,function,maximum,number,of,iterations,iteration,configure,parameters,data,set,vertex,k,vv,new,vertices,this,get,vertices,run,operation,iteration,return,new,graph,k,vv,ev,new,vertices,this,edges,this,context
Graph -> public <M> Graph<K, VV, EV> runVertexCentricIteration( 			ComputeFunction<K, VV, EV, M> computeFunction, 			MessageCombiner<K, M> combiner, int maximumNumberOfIterations, 			VertexCentricConfiguration parameters);1462809297;Runs a {@link VertexCentricIteration} on the graph with configuration options.__@param computeFunction the vertex compute function_@param combiner an optional message combiner_@param maximumNumberOfIterations maximum number of iterations to perform_@param parameters the {@link VertexCentricConfiguration} parameters__@return the updated Graph after the vertex-centric iteration has converged or_after maximumNumberOfIterations.;public <M> Graph<K, VV, EV> runVertexCentricIteration(_			ComputeFunction<K, VV, EV, M> computeFunction,_			MessageCombiner<K, M> combiner, int maximumNumberOfIterations,_			VertexCentricConfiguration parameters) {__		VertexCentricIteration<K, VV, EV, M> iteration = VertexCentricIteration.withEdges(_				edges, computeFunction, maximumNumberOfIterations)__		iteration.configure(parameters)__		DataSet<Vertex<K, VV>> newVertices = this.getVertices().runOperation(iteration)__		return new Graph<K, VV, EV>(newVertices, this.edges, this.context)__	};runs,a,link,vertex,centric,iteration,on,the,graph,with,configuration,options,param,compute,function,the,vertex,compute,function,param,combiner,an,optional,message,combiner,param,maximum,number,of,iterations,maximum,number,of,iterations,to,perform,param,parameters,the,link,vertex,centric,configuration,parameters,return,the,updated,graph,after,the,vertex,centric,iteration,has,converged,or,after,maximum,number,of,iterations;public,m,graph,k,vv,ev,run,vertex,centric,iteration,compute,function,k,vv,ev,m,compute,function,message,combiner,k,m,combiner,int,maximum,number,of,iterations,vertex,centric,configuration,parameters,vertex,centric,iteration,k,vv,ev,m,iteration,vertex,centric,iteration,with,edges,edges,compute,function,maximum,number,of,iterations,iteration,configure,parameters,data,set,vertex,k,vv,new,vertices,this,get,vertices,run,operation,iteration,return,new,graph,k,vv,ev,new,vertices,this,edges,this,context
Graph -> public <M> Graph<K, VV, EV> runVertexCentricIteration( 			ComputeFunction<K, VV, EV, M> computeFunction, 			MessageCombiner<K, M> combiner, int maximumNumberOfIterations, 			VertexCentricConfiguration parameters);1465316775;Runs a {@link VertexCentricIteration} on the graph with configuration options.__@param computeFunction the vertex compute function_@param combiner an optional message combiner_@param maximumNumberOfIterations maximum number of iterations to perform_@param parameters the {@link VertexCentricConfiguration} parameters__@return the updated Graph after the vertex-centric iteration has converged or_after maximumNumberOfIterations.;public <M> Graph<K, VV, EV> runVertexCentricIteration(_			ComputeFunction<K, VV, EV, M> computeFunction,_			MessageCombiner<K, M> combiner, int maximumNumberOfIterations,_			VertexCentricConfiguration parameters) {__		VertexCentricIteration<K, VV, EV, M> iteration = VertexCentricIteration.withEdges(_				edges, computeFunction, maximumNumberOfIterations)__		iteration.configure(parameters)__		DataSet<Vertex<K, VV>> newVertices = this.getVertices().runOperation(iteration)__		return new Graph<K, VV, EV>(newVertices, this.edges, this.context)__	};runs,a,link,vertex,centric,iteration,on,the,graph,with,configuration,options,param,compute,function,the,vertex,compute,function,param,combiner,an,optional,message,combiner,param,maximum,number,of,iterations,maximum,number,of,iterations,to,perform,param,parameters,the,link,vertex,centric,configuration,parameters,return,the,updated,graph,after,the,vertex,centric,iteration,has,converged,or,after,maximum,number,of,iterations;public,m,graph,k,vv,ev,run,vertex,centric,iteration,compute,function,k,vv,ev,m,compute,function,message,combiner,k,m,combiner,int,maximum,number,of,iterations,vertex,centric,configuration,parameters,vertex,centric,iteration,k,vv,ev,m,iteration,vertex,centric,iteration,with,edges,edges,compute,function,maximum,number,of,iterations,iteration,configure,parameters,data,set,vertex,k,vv,new,vertices,this,get,vertices,run,operation,iteration,return,new,graph,k,vv,ev,new,vertices,this,edges,this,context
Graph -> public <M> Graph<K, VV, EV> runVertexCentricIteration( 			ComputeFunction<K, VV, EV, M> computeFunction, 			MessageCombiner<K, M> combiner, int maximumNumberOfIterations, 			VertexCentricConfiguration parameters);1466789678;Runs a {@link VertexCentricIteration} on the graph with configuration options.__@param computeFunction the vertex compute function_@param combiner an optional message combiner_@param maximumNumberOfIterations maximum number of iterations to perform_@param parameters the {@link VertexCentricConfiguration} parameters__@return the updated Graph after the vertex-centric iteration has converged or_after maximumNumberOfIterations.;public <M> Graph<K, VV, EV> runVertexCentricIteration(_			ComputeFunction<K, VV, EV, M> computeFunction,_			MessageCombiner<K, M> combiner, int maximumNumberOfIterations,_			VertexCentricConfiguration parameters) {__		VertexCentricIteration<K, VV, EV, M> iteration = VertexCentricIteration.withEdges(_				edges, computeFunction, maximumNumberOfIterations)__		iteration.configure(parameters)__		DataSet<Vertex<K, VV>> newVertices = this.getVertices().runOperation(iteration)__		return new Graph<K, VV, EV>(newVertices, this.edges, this.context)__	};runs,a,link,vertex,centric,iteration,on,the,graph,with,configuration,options,param,compute,function,the,vertex,compute,function,param,combiner,an,optional,message,combiner,param,maximum,number,of,iterations,maximum,number,of,iterations,to,perform,param,parameters,the,link,vertex,centric,configuration,parameters,return,the,updated,graph,after,the,vertex,centric,iteration,has,converged,or,after,maximum,number,of,iterations;public,m,graph,k,vv,ev,run,vertex,centric,iteration,compute,function,k,vv,ev,m,compute,function,message,combiner,k,m,combiner,int,maximum,number,of,iterations,vertex,centric,configuration,parameters,vertex,centric,iteration,k,vv,ev,m,iteration,vertex,centric,iteration,with,edges,edges,compute,function,maximum,number,of,iterations,iteration,configure,parameters,data,set,vertex,k,vv,new,vertices,this,get,vertices,run,operation,iteration,return,new,graph,k,vv,ev,new,vertices,this,edges,this,context
Graph -> public <M> Graph<K, VV, EV> runVertexCentricIteration( 			ComputeFunction<K, VV, EV, M> computeFunction, 			MessageCombiner<K, M> combiner, int maximumNumberOfIterations, 			VertexCentricConfiguration parameters);1467140656;Runs a {@link VertexCentricIteration} on the graph with configuration options.__@param computeFunction the vertex compute function_@param combiner an optional message combiner_@param maximumNumberOfIterations maximum number of iterations to perform_@param parameters the {@link VertexCentricConfiguration} parameters__@return the updated Graph after the vertex-centric iteration has converged or_after maximumNumberOfIterations.;public <M> Graph<K, VV, EV> runVertexCentricIteration(_			ComputeFunction<K, VV, EV, M> computeFunction,_			MessageCombiner<K, M> combiner, int maximumNumberOfIterations,_			VertexCentricConfiguration parameters) {__		VertexCentricIteration<K, VV, EV, M> iteration = VertexCentricIteration.withEdges(_				edges, computeFunction, maximumNumberOfIterations)__		iteration.configure(parameters)__		DataSet<Vertex<K, VV>> newVertices = this.getVertices().runOperation(iteration)__		return new Graph<K, VV, EV>(newVertices, this.edges, this.context)__	};runs,a,link,vertex,centric,iteration,on,the,graph,with,configuration,options,param,compute,function,the,vertex,compute,function,param,combiner,an,optional,message,combiner,param,maximum,number,of,iterations,maximum,number,of,iterations,to,perform,param,parameters,the,link,vertex,centric,configuration,parameters,return,the,updated,graph,after,the,vertex,centric,iteration,has,converged,or,after,maximum,number,of,iterations;public,m,graph,k,vv,ev,run,vertex,centric,iteration,compute,function,k,vv,ev,m,compute,function,message,combiner,k,m,combiner,int,maximum,number,of,iterations,vertex,centric,configuration,parameters,vertex,centric,iteration,k,vv,ev,m,iteration,vertex,centric,iteration,with,edges,edges,compute,function,maximum,number,of,iterations,iteration,configure,parameters,data,set,vertex,k,vv,new,vertices,this,get,vertices,run,operation,iteration,return,new,graph,k,vv,ev,new,vertices,this,edges,this,context
Graph -> public <M> Graph<K, VV, EV> runVertexCentricIteration( 			ComputeFunction<K, VV, EV, M> computeFunction, 			MessageCombiner<K, M> combiner, int maximumNumberOfIterations, 			VertexCentricConfiguration parameters);1467306272;Runs a {@link VertexCentricIteration} on the graph with configuration options.__@param computeFunction the vertex compute function_@param combiner an optional message combiner_@param maximumNumberOfIterations maximum number of iterations to perform_@param parameters the {@link VertexCentricConfiguration} parameters__@return the updated Graph after the vertex-centric iteration has converged or_after maximumNumberOfIterations.;public <M> Graph<K, VV, EV> runVertexCentricIteration(_			ComputeFunction<K, VV, EV, M> computeFunction,_			MessageCombiner<K, M> combiner, int maximumNumberOfIterations,_			VertexCentricConfiguration parameters) {__		VertexCentricIteration<K, VV, EV, M> iteration = VertexCentricIteration.withEdges(_				edges, computeFunction, maximumNumberOfIterations)__		iteration.configure(parameters)__		DataSet<Vertex<K, VV>> newVertices = this.getVertices().runOperation(iteration)__		return new Graph<K, VV, EV>(newVertices, this.edges, this.context)__	};runs,a,link,vertex,centric,iteration,on,the,graph,with,configuration,options,param,compute,function,the,vertex,compute,function,param,combiner,an,optional,message,combiner,param,maximum,number,of,iterations,maximum,number,of,iterations,to,perform,param,parameters,the,link,vertex,centric,configuration,parameters,return,the,updated,graph,after,the,vertex,centric,iteration,has,converged,or,after,maximum,number,of,iterations;public,m,graph,k,vv,ev,run,vertex,centric,iteration,compute,function,k,vv,ev,m,compute,function,message,combiner,k,m,combiner,int,maximum,number,of,iterations,vertex,centric,configuration,parameters,vertex,centric,iteration,k,vv,ev,m,iteration,vertex,centric,iteration,with,edges,edges,compute,function,maximum,number,of,iterations,iteration,configure,parameters,data,set,vertex,k,vv,new,vertices,this,get,vertices,run,operation,iteration,return,new,graph,k,vv,ev,new,vertices,this,edges,this,context
Graph -> public <M> Graph<K, VV, EV> runVertexCentricIteration( 			ComputeFunction<K, VV, EV, M> computeFunction, 			MessageCombiner<K, M> combiner, int maximumNumberOfIterations, 			VertexCentricConfiguration parameters);1470042815;Runs a {@link VertexCentricIteration} on the graph with configuration options.__@param computeFunction the vertex compute function_@param combiner an optional message combiner_@param maximumNumberOfIterations maximum number of iterations to perform_@param parameters the {@link VertexCentricConfiguration} parameters__@return the updated Graph after the vertex-centric iteration has converged or_after maximumNumberOfIterations.;public <M> Graph<K, VV, EV> runVertexCentricIteration(_			ComputeFunction<K, VV, EV, M> computeFunction,_			MessageCombiner<K, M> combiner, int maximumNumberOfIterations,_			VertexCentricConfiguration parameters) {__		VertexCentricIteration<K, VV, EV, M> iteration = VertexCentricIteration.withEdges(_				edges, computeFunction, maximumNumberOfIterations)__		iteration.configure(parameters)__		DataSet<Vertex<K, VV>> newVertices = this.getVertices().runOperation(iteration)__		return new Graph<K, VV, EV>(newVertices, this.edges, this.context)__	};runs,a,link,vertex,centric,iteration,on,the,graph,with,configuration,options,param,compute,function,the,vertex,compute,function,param,combiner,an,optional,message,combiner,param,maximum,number,of,iterations,maximum,number,of,iterations,to,perform,param,parameters,the,link,vertex,centric,configuration,parameters,return,the,updated,graph,after,the,vertex,centric,iteration,has,converged,or,after,maximum,number,of,iterations;public,m,graph,k,vv,ev,run,vertex,centric,iteration,compute,function,k,vv,ev,m,compute,function,message,combiner,k,m,combiner,int,maximum,number,of,iterations,vertex,centric,configuration,parameters,vertex,centric,iteration,k,vv,ev,m,iteration,vertex,centric,iteration,with,edges,edges,compute,function,maximum,number,of,iterations,iteration,configure,parameters,data,set,vertex,k,vv,new,vertices,this,get,vertices,run,operation,iteration,return,new,graph,k,vv,ev,new,vertices,this,edges,this,context
Graph -> public <M> Graph<K, VV, EV> runVertexCentricIteration( 			ComputeFunction<K, VV, EV, M> computeFunction, 			MessageCombiner<K, M> combiner, int maximumNumberOfIterations, 			VertexCentricConfiguration parameters);1475684776;Runs a {@link VertexCentricIteration} on the graph with configuration options.__@param computeFunction the vertex compute function_@param combiner an optional message combiner_@param maximumNumberOfIterations maximum number of iterations to perform_@param parameters the {@link VertexCentricConfiguration} parameters__@return the updated Graph after the vertex-centric iteration has converged or_after maximumNumberOfIterations.;public <M> Graph<K, VV, EV> runVertexCentricIteration(_			ComputeFunction<K, VV, EV, M> computeFunction,_			MessageCombiner<K, M> combiner, int maximumNumberOfIterations,_			VertexCentricConfiguration parameters) {__		VertexCentricIteration<K, VV, EV, M> iteration = VertexCentricIteration.withEdges(_				edges, computeFunction, combiner, maximumNumberOfIterations)__		iteration.configure(parameters)__		DataSet<Vertex<K, VV>> newVertices = this.getVertices().runOperation(iteration)__		return new Graph<>(newVertices, this.edges, this.context)__	};runs,a,link,vertex,centric,iteration,on,the,graph,with,configuration,options,param,compute,function,the,vertex,compute,function,param,combiner,an,optional,message,combiner,param,maximum,number,of,iterations,maximum,number,of,iterations,to,perform,param,parameters,the,link,vertex,centric,configuration,parameters,return,the,updated,graph,after,the,vertex,centric,iteration,has,converged,or,after,maximum,number,of,iterations;public,m,graph,k,vv,ev,run,vertex,centric,iteration,compute,function,k,vv,ev,m,compute,function,message,combiner,k,m,combiner,int,maximum,number,of,iterations,vertex,centric,configuration,parameters,vertex,centric,iteration,k,vv,ev,m,iteration,vertex,centric,iteration,with,edges,edges,compute,function,combiner,maximum,number,of,iterations,iteration,configure,parameters,data,set,vertex,k,vv,new,vertices,this,get,vertices,run,operation,iteration,return,new,graph,new,vertices,this,edges,this,context
Graph -> public <M> Graph<K, VV, EV> runVertexCentricIteration( 			ComputeFunction<K, VV, EV, M> computeFunction, 			MessageCombiner<K, M> combiner, int maximumNumberOfIterations, 			VertexCentricConfiguration parameters);1475685606;Runs a {@link VertexCentricIteration} on the graph with configuration options.__@param computeFunction the vertex compute function_@param combiner an optional message combiner_@param maximumNumberOfIterations maximum number of iterations to perform_@param parameters the {@link VertexCentricConfiguration} parameters__@return the updated Graph after the vertex-centric iteration has converged or_after maximumNumberOfIterations.;public <M> Graph<K, VV, EV> runVertexCentricIteration(_			ComputeFunction<K, VV, EV, M> computeFunction,_			MessageCombiner<K, M> combiner, int maximumNumberOfIterations,_			VertexCentricConfiguration parameters) {__		VertexCentricIteration<K, VV, EV, M> iteration = VertexCentricIteration.withEdges(_				edges, computeFunction, combiner, maximumNumberOfIterations)__		iteration.configure(parameters)__		DataSet<Vertex<K, VV>> newVertices = this.getVertices().runOperation(iteration)__		return new Graph<>(newVertices, this.edges, this.context)__	};runs,a,link,vertex,centric,iteration,on,the,graph,with,configuration,options,param,compute,function,the,vertex,compute,function,param,combiner,an,optional,message,combiner,param,maximum,number,of,iterations,maximum,number,of,iterations,to,perform,param,parameters,the,link,vertex,centric,configuration,parameters,return,the,updated,graph,after,the,vertex,centric,iteration,has,converged,or,after,maximum,number,of,iterations;public,m,graph,k,vv,ev,run,vertex,centric,iteration,compute,function,k,vv,ev,m,compute,function,message,combiner,k,m,combiner,int,maximum,number,of,iterations,vertex,centric,configuration,parameters,vertex,centric,iteration,k,vv,ev,m,iteration,vertex,centric,iteration,with,edges,edges,compute,function,combiner,maximum,number,of,iterations,iteration,configure,parameters,data,set,vertex,k,vv,new,vertices,this,get,vertices,run,operation,iteration,return,new,graph,new,vertices,this,edges,this,context
Graph -> public <M> Graph<K, VV, EV> runVertexCentricIteration( 			ComputeFunction<K, VV, EV, M> computeFunction, 			MessageCombiner<K, M> combiner, int maximumNumberOfIterations, 			VertexCentricConfiguration parameters);1481745825;Runs a {@link VertexCentricIteration} on the graph with configuration options.__@param computeFunction the vertex compute function_@param combiner an optional message combiner_@param maximumNumberOfIterations maximum number of iterations to perform_@param parameters the {@link VertexCentricConfiguration} parameters__@return the updated Graph after the vertex-centric iteration has converged or_after maximumNumberOfIterations.;public <M> Graph<K, VV, EV> runVertexCentricIteration(_			ComputeFunction<K, VV, EV, M> computeFunction,_			MessageCombiner<K, M> combiner, int maximumNumberOfIterations,_			VertexCentricConfiguration parameters) {__		VertexCentricIteration<K, VV, EV, M> iteration = VertexCentricIteration.withEdges(_				edges, computeFunction, combiner, maximumNumberOfIterations)__		iteration.configure(parameters)__		DataSet<Vertex<K, VV>> newVertices = this.getVertices().runOperation(iteration)__		return new Graph<>(newVertices, this.edges, this.context)__	};runs,a,link,vertex,centric,iteration,on,the,graph,with,configuration,options,param,compute,function,the,vertex,compute,function,param,combiner,an,optional,message,combiner,param,maximum,number,of,iterations,maximum,number,of,iterations,to,perform,param,parameters,the,link,vertex,centric,configuration,parameters,return,the,updated,graph,after,the,vertex,centric,iteration,has,converged,or,after,maximum,number,of,iterations;public,m,graph,k,vv,ev,run,vertex,centric,iteration,compute,function,k,vv,ev,m,compute,function,message,combiner,k,m,combiner,int,maximum,number,of,iterations,vertex,centric,configuration,parameters,vertex,centric,iteration,k,vv,ev,m,iteration,vertex,centric,iteration,with,edges,edges,compute,function,combiner,maximum,number,of,iterations,iteration,configure,parameters,data,set,vertex,k,vv,new,vertices,this,get,vertices,run,operation,iteration,return,new,graph,new,vertices,this,edges,this,context
Graph -> public <M> Graph<K, VV, EV> runVertexCentricIteration( 			ComputeFunction<K, VV, EV, M> computeFunction, 			MessageCombiner<K, M> combiner, int maximumNumberOfIterations, 			VertexCentricConfiguration parameters);1481881009;Runs a {@link VertexCentricIteration} on the graph with configuration options.__@param computeFunction the vertex compute function_@param combiner an optional message combiner_@param maximumNumberOfIterations maximum number of iterations to perform_@param parameters the {@link VertexCentricConfiguration} parameters__@return the updated Graph after the vertex-centric iteration has converged or_after maximumNumberOfIterations.;public <M> Graph<K, VV, EV> runVertexCentricIteration(_			ComputeFunction<K, VV, EV, M> computeFunction,_			MessageCombiner<K, M> combiner, int maximumNumberOfIterations,_			VertexCentricConfiguration parameters) {__		VertexCentricIteration<K, VV, EV, M> iteration = VertexCentricIteration.withEdges(_				edges, computeFunction, combiner, maximumNumberOfIterations)__		iteration.configure(parameters)__		DataSet<Vertex<K, VV>> newVertices = this.getVertices().runOperation(iteration)__		return new Graph<>(newVertices, this.edges, this.context)__	};runs,a,link,vertex,centric,iteration,on,the,graph,with,configuration,options,param,compute,function,the,vertex,compute,function,param,combiner,an,optional,message,combiner,param,maximum,number,of,iterations,maximum,number,of,iterations,to,perform,param,parameters,the,link,vertex,centric,configuration,parameters,return,the,updated,graph,after,the,vertex,centric,iteration,has,converged,or,after,maximum,number,of,iterations;public,m,graph,k,vv,ev,run,vertex,centric,iteration,compute,function,k,vv,ev,m,compute,function,message,combiner,k,m,combiner,int,maximum,number,of,iterations,vertex,centric,configuration,parameters,vertex,centric,iteration,k,vv,ev,m,iteration,vertex,centric,iteration,with,edges,edges,compute,function,combiner,maximum,number,of,iterations,iteration,configure,parameters,data,set,vertex,k,vv,new,vertices,this,get,vertices,run,operation,iteration,return,new,graph,new,vertices,this,edges,this,context
Graph -> public <M> Graph<K, VV, EV> runVertexCentricIteration( 			ComputeFunction<K, VV, EV, M> computeFunction, 			MessageCombiner<K, M> combiner, int maximumNumberOfIterations, 			VertexCentricConfiguration parameters);1484160227;Runs a {@link VertexCentricIteration} on the graph with configuration options.__@param computeFunction the vertex compute function_@param combiner an optional message combiner_@param maximumNumberOfIterations maximum number of iterations to perform_@param parameters the {@link VertexCentricConfiguration} parameters__@return the updated Graph after the vertex-centric iteration has converged or_after maximumNumberOfIterations.;public <M> Graph<K, VV, EV> runVertexCentricIteration(_			ComputeFunction<K, VV, EV, M> computeFunction,_			MessageCombiner<K, M> combiner, int maximumNumberOfIterations,_			VertexCentricConfiguration parameters) {__		VertexCentricIteration<K, VV, EV, M> iteration = VertexCentricIteration.withEdges(_				edges, computeFunction, combiner, maximumNumberOfIterations)__		iteration.configure(parameters)__		DataSet<Vertex<K, VV>> newVertices = this.getVertices().runOperation(iteration)__		return new Graph<>(newVertices, this.edges, this.context)__	};runs,a,link,vertex,centric,iteration,on,the,graph,with,configuration,options,param,compute,function,the,vertex,compute,function,param,combiner,an,optional,message,combiner,param,maximum,number,of,iterations,maximum,number,of,iterations,to,perform,param,parameters,the,link,vertex,centric,configuration,parameters,return,the,updated,graph,after,the,vertex,centric,iteration,has,converged,or,after,maximum,number,of,iterations;public,m,graph,k,vv,ev,run,vertex,centric,iteration,compute,function,k,vv,ev,m,compute,function,message,combiner,k,m,combiner,int,maximum,number,of,iterations,vertex,centric,configuration,parameters,vertex,centric,iteration,k,vv,ev,m,iteration,vertex,centric,iteration,with,edges,edges,compute,function,combiner,maximum,number,of,iterations,iteration,configure,parameters,data,set,vertex,k,vv,new,vertices,this,get,vertices,run,operation,iteration,return,new,graph,new,vertices,this,edges,this,context
Graph -> public <M> Graph<K, VV, EV> runVertexCentricIteration( 			ComputeFunction<K, VV, EV, M> computeFunction, 			MessageCombiner<K, M> combiner, int maximumNumberOfIterations, 			VertexCentricConfiguration parameters);1484685504;Runs a {@link VertexCentricIteration} on the graph with configuration options.__@param computeFunction the vertex compute function_@param combiner an optional message combiner_@param maximumNumberOfIterations maximum number of iterations to perform_@param parameters the {@link VertexCentricConfiguration} parameters__@return the updated Graph after the vertex-centric iteration has converged or_after maximumNumberOfIterations.;public <M> Graph<K, VV, EV> runVertexCentricIteration(_			ComputeFunction<K, VV, EV, M> computeFunction,_			MessageCombiner<K, M> combiner, int maximumNumberOfIterations,_			VertexCentricConfiguration parameters) {__		VertexCentricIteration<K, VV, EV, M> iteration = VertexCentricIteration.withEdges(_				edges, computeFunction, combiner, maximumNumberOfIterations)__		iteration.configure(parameters)__		DataSet<Vertex<K, VV>> newVertices = this.getVertices().runOperation(iteration)__		return new Graph<>(newVertices, this.edges, this.context)__	};runs,a,link,vertex,centric,iteration,on,the,graph,with,configuration,options,param,compute,function,the,vertex,compute,function,param,combiner,an,optional,message,combiner,param,maximum,number,of,iterations,maximum,number,of,iterations,to,perform,param,parameters,the,link,vertex,centric,configuration,parameters,return,the,updated,graph,after,the,vertex,centric,iteration,has,converged,or,after,maximum,number,of,iterations;public,m,graph,k,vv,ev,run,vertex,centric,iteration,compute,function,k,vv,ev,m,compute,function,message,combiner,k,m,combiner,int,maximum,number,of,iterations,vertex,centric,configuration,parameters,vertex,centric,iteration,k,vv,ev,m,iteration,vertex,centric,iteration,with,edges,edges,compute,function,combiner,maximum,number,of,iterations,iteration,configure,parameters,data,set,vertex,k,vv,new,vertices,this,get,vertices,run,operation,iteration,return,new,graph,new,vertices,this,edges,this,context
Graph -> public <M> Graph<K, VV, EV> runVertexCentricIteration( 			ComputeFunction<K, VV, EV, M> computeFunction, 			MessageCombiner<K, M> combiner, int maximumNumberOfIterations, 			VertexCentricConfiguration parameters);1489068942;Runs a {@link VertexCentricIteration} on the graph with configuration options.__@param computeFunction the vertex compute function_@param combiner an optional message combiner_@param maximumNumberOfIterations maximum number of iterations to perform_@param parameters the {@link VertexCentricConfiguration} parameters__@return the updated Graph after the vertex-centric iteration has converged or_after maximumNumberOfIterations.;public <M> Graph<K, VV, EV> runVertexCentricIteration(_			ComputeFunction<K, VV, EV, M> computeFunction,_			MessageCombiner<K, M> combiner, int maximumNumberOfIterations,_			VertexCentricConfiguration parameters) {__		VertexCentricIteration<K, VV, EV, M> iteration = VertexCentricIteration.withEdges(_				edges, computeFunction, combiner, maximumNumberOfIterations)__		iteration.configure(parameters)__		DataSet<Vertex<K, VV>> newVertices = this.getVertices().runOperation(iteration)__		return new Graph<>(newVertices, this.edges, this.context)__	};runs,a,link,vertex,centric,iteration,on,the,graph,with,configuration,options,param,compute,function,the,vertex,compute,function,param,combiner,an,optional,message,combiner,param,maximum,number,of,iterations,maximum,number,of,iterations,to,perform,param,parameters,the,link,vertex,centric,configuration,parameters,return,the,updated,graph,after,the,vertex,centric,iteration,has,converged,or,after,maximum,number,of,iterations;public,m,graph,k,vv,ev,run,vertex,centric,iteration,compute,function,k,vv,ev,m,compute,function,message,combiner,k,m,combiner,int,maximum,number,of,iterations,vertex,centric,configuration,parameters,vertex,centric,iteration,k,vv,ev,m,iteration,vertex,centric,iteration,with,edges,edges,compute,function,combiner,maximum,number,of,iterations,iteration,configure,parameters,data,set,vertex,k,vv,new,vertices,this,get,vertices,run,operation,iteration,return,new,graph,new,vertices,this,edges,this,context
Graph -> public <M> Graph<K, VV, EV> runVertexCentricIteration( 			ComputeFunction<K, VV, EV, M> computeFunction, 			MessageCombiner<K, M> combiner, int maximumNumberOfIterations, 			VertexCentricConfiguration parameters);1490973446;Runs a {@link VertexCentricIteration} on the graph with configuration options.__@param computeFunction the vertex compute function_@param combiner an optional message combiner_@param maximumNumberOfIterations maximum number of iterations to perform_@param parameters the {@link VertexCentricConfiguration} parameters__@return the updated Graph after the vertex-centric iteration has converged or_after maximumNumberOfIterations.;public <M> Graph<K, VV, EV> runVertexCentricIteration(_			ComputeFunction<K, VV, EV, M> computeFunction,_			MessageCombiner<K, M> combiner, int maximumNumberOfIterations,_			VertexCentricConfiguration parameters) {__		VertexCentricIteration<K, VV, EV, M> iteration = VertexCentricIteration.withEdges(_				edges, computeFunction, combiner, maximumNumberOfIterations)__		iteration.configure(parameters)__		DataSet<Vertex<K, VV>> newVertices = this.getVertices().runOperation(iteration)__		return new Graph<>(newVertices, this.edges, this.context)__	};runs,a,link,vertex,centric,iteration,on,the,graph,with,configuration,options,param,compute,function,the,vertex,compute,function,param,combiner,an,optional,message,combiner,param,maximum,number,of,iterations,maximum,number,of,iterations,to,perform,param,parameters,the,link,vertex,centric,configuration,parameters,return,the,updated,graph,after,the,vertex,centric,iteration,has,converged,or,after,maximum,number,of,iterations;public,m,graph,k,vv,ev,run,vertex,centric,iteration,compute,function,k,vv,ev,m,compute,function,message,combiner,k,m,combiner,int,maximum,number,of,iterations,vertex,centric,configuration,parameters,vertex,centric,iteration,k,vv,ev,m,iteration,vertex,centric,iteration,with,edges,edges,compute,function,combiner,maximum,number,of,iterations,iteration,configure,parameters,data,set,vertex,k,vv,new,vertices,this,get,vertices,run,operation,iteration,return,new,graph,new,vertices,this,edges,this,context
Graph -> public <M> Graph<K, VV, EV> runVertexCentricIteration( 			ComputeFunction<K, VV, EV, M> computeFunction, 			MessageCombiner<K, M> combiner, int maximumNumberOfIterations, 			VertexCentricConfiguration parameters);1495819075;Runs a {@link VertexCentricIteration} on the graph with configuration options.__@param computeFunction the vertex compute function_@param combiner an optional message combiner_@param maximumNumberOfIterations maximum number of iterations to perform_@param parameters the {@link VertexCentricConfiguration} parameters__@return the updated Graph after the vertex-centric iteration has converged or_after maximumNumberOfIterations.;public <M> Graph<K, VV, EV> runVertexCentricIteration(_			ComputeFunction<K, VV, EV, M> computeFunction,_			MessageCombiner<K, M> combiner, int maximumNumberOfIterations,_			VertexCentricConfiguration parameters) {__		VertexCentricIteration<K, VV, EV, M> iteration = VertexCentricIteration.withEdges(_				edges, computeFunction, combiner, maximumNumberOfIterations)__		iteration.configure(parameters)__		DataSet<Vertex<K, VV>> newVertices = this.getVertices().runOperation(iteration)__		return new Graph<>(newVertices, this.edges, this.context)__	};runs,a,link,vertex,centric,iteration,on,the,graph,with,configuration,options,param,compute,function,the,vertex,compute,function,param,combiner,an,optional,message,combiner,param,maximum,number,of,iterations,maximum,number,of,iterations,to,perform,param,parameters,the,link,vertex,centric,configuration,parameters,return,the,updated,graph,after,the,vertex,centric,iteration,has,converged,or,after,maximum,number,of,iterations;public,m,graph,k,vv,ev,run,vertex,centric,iteration,compute,function,k,vv,ev,m,compute,function,message,combiner,k,m,combiner,int,maximum,number,of,iterations,vertex,centric,configuration,parameters,vertex,centric,iteration,k,vv,ev,m,iteration,vertex,centric,iteration,with,edges,edges,compute,function,combiner,maximum,number,of,iterations,iteration,configure,parameters,data,set,vertex,k,vv,new,vertices,this,get,vertices,run,operation,iteration,return,new,graph,new,vertices,this,edges,this,context
Graph -> public <M> Graph<K, VV, EV> runVertexCentricIteration( 			ComputeFunction<K, VV, EV, M> computeFunction, 			MessageCombiner<K, M> combiner, int maximumNumberOfIterations, 			VertexCentricConfiguration parameters);1502111816;Runs a {@link VertexCentricIteration} on the graph with configuration options.__@param computeFunction the vertex compute function_@param combiner an optional message combiner_@param maximumNumberOfIterations maximum number of iterations to perform_@param parameters the {@link VertexCentricConfiguration} parameters__@return the updated Graph after the vertex-centric iteration has converged or_after maximumNumberOfIterations.;public <M> Graph<K, VV, EV> runVertexCentricIteration(_			ComputeFunction<K, VV, EV, M> computeFunction,_			MessageCombiner<K, M> combiner, int maximumNumberOfIterations,_			VertexCentricConfiguration parameters) {__		VertexCentricIteration<K, VV, EV, M> iteration = VertexCentricIteration.withEdges(_				edges, computeFunction, combiner, maximumNumberOfIterations)__		iteration.configure(parameters)__		DataSet<Vertex<K, VV>> newVertices = this.getVertices().runOperation(iteration)__		return new Graph<>(newVertices, this.edges, this.context)__	};runs,a,link,vertex,centric,iteration,on,the,graph,with,configuration,options,param,compute,function,the,vertex,compute,function,param,combiner,an,optional,message,combiner,param,maximum,number,of,iterations,maximum,number,of,iterations,to,perform,param,parameters,the,link,vertex,centric,configuration,parameters,return,the,updated,graph,after,the,vertex,centric,iteration,has,converged,or,after,maximum,number,of,iterations;public,m,graph,k,vv,ev,run,vertex,centric,iteration,compute,function,k,vv,ev,m,compute,function,message,combiner,k,m,combiner,int,maximum,number,of,iterations,vertex,centric,configuration,parameters,vertex,centric,iteration,k,vv,ev,m,iteration,vertex,centric,iteration,with,edges,edges,compute,function,combiner,maximum,number,of,iterations,iteration,configure,parameters,data,set,vertex,k,vv,new,vertices,this,get,vertices,run,operation,iteration,return,new,graph,new,vertices,this,edges,this,context
Graph -> public DataSet<Tuple2<K, LongValue>> inDegrees();1467140656;Return the in-degree of all vertices in the graph__@return A DataSet of {@code Tuple2<vertexId, inDegree>};public DataSet<Tuple2<K, LongValue>> inDegrees() {__		return vertices.coGroup(edges).where(0).equalTo(1).with(new CountNeighborsCoGroup<K, VV, EV>())__	};return,the,in,degree,of,all,vertices,in,the,graph,return,a,data,set,of,code,tuple2,vertex,id,in,degree;public,data,set,tuple2,k,long,value,in,degrees,return,vertices,co,group,edges,where,0,equal,to,1,with,new,count,neighbors,co,group,k,vv,ev
Graph -> public DataSet<Tuple2<K, LongValue>> inDegrees();1467306272;Return the in-degree of all vertices in the graph__@return A DataSet of {@code Tuple2<vertexId, inDegree>};public DataSet<Tuple2<K, LongValue>> inDegrees() {__		return vertices.coGroup(edges).where(0).equalTo(1).with(new CountNeighborsCoGroup<K, VV, EV>())__	};return,the,in,degree,of,all,vertices,in,the,graph,return,a,data,set,of,code,tuple2,vertex,id,in,degree;public,data,set,tuple2,k,long,value,in,degrees,return,vertices,co,group,edges,where,0,equal,to,1,with,new,count,neighbors,co,group,k,vv,ev
Graph -> public DataSet<Tuple2<K, LongValue>> inDegrees();1470042815;Return the in-degree of all vertices in the graph__@return A DataSet of {@code Tuple2<vertexId, inDegree>};public DataSet<Tuple2<K, LongValue>> inDegrees() {__		return vertices.coGroup(edges).where(0).equalTo(1).with(new CountNeighborsCoGroup<K, VV, EV>())__	};return,the,in,degree,of,all,vertices,in,the,graph,return,a,data,set,of,code,tuple2,vertex,id,in,degree;public,data,set,tuple2,k,long,value,in,degrees,return,vertices,co,group,edges,where,0,equal,to,1,with,new,count,neighbors,co,group,k,vv,ev
Graph -> public DataSet<Tuple2<K, LongValue>> inDegrees();1475684776;Return the in-degree of all vertices in the graph__@return A DataSet of {@code Tuple2<vertexId, inDegree>};public DataSet<Tuple2<K, LongValue>> inDegrees() {__		return vertices.coGroup(edges).where(0).equalTo(1).with(new CountNeighborsCoGroup<K, VV, EV>())__	};return,the,in,degree,of,all,vertices,in,the,graph,return,a,data,set,of,code,tuple2,vertex,id,in,degree;public,data,set,tuple2,k,long,value,in,degrees,return,vertices,co,group,edges,where,0,equal,to,1,with,new,count,neighbors,co,group,k,vv,ev
Graph -> public DataSet<Tuple2<K, LongValue>> inDegrees();1475685606;Return the in-degree of all vertices in the graph__@return A DataSet of {@code Tuple2<vertexId, inDegree>};public DataSet<Tuple2<K, LongValue>> inDegrees() {__		return vertices.coGroup(edges).where(0).equalTo(1).with(new CountNeighborsCoGroup<K, VV, EV>())__	};return,the,in,degree,of,all,vertices,in,the,graph,return,a,data,set,of,code,tuple2,vertex,id,in,degree;public,data,set,tuple2,k,long,value,in,degrees,return,vertices,co,group,edges,where,0,equal,to,1,with,new,count,neighbors,co,group,k,vv,ev
Graph -> public DataSet<Tuple2<K, LongValue>> inDegrees();1481745825;Return the in-degree of all vertices in the graph__@return A DataSet of {@code Tuple2<vertexId, inDegree>};public DataSet<Tuple2<K, LongValue>> inDegrees() {__		return vertices.coGroup(edges).where(0).equalTo(1).with(new CountNeighborsCoGroup<K, VV, EV>())_			.name("In-degree")__	};return,the,in,degree,of,all,vertices,in,the,graph,return,a,data,set,of,code,tuple2,vertex,id,in,degree;public,data,set,tuple2,k,long,value,in,degrees,return,vertices,co,group,edges,where,0,equal,to,1,with,new,count,neighbors,co,group,k,vv,ev,name,in,degree
Graph -> public DataSet<Tuple2<K, LongValue>> inDegrees();1481881009;Return the in-degree of all vertices in the graph__@return A DataSet of {@code Tuple2<vertexId, inDegree>};public DataSet<Tuple2<K, LongValue>> inDegrees() {__		return vertices.coGroup(edges).where(0).equalTo(1).with(new CountNeighborsCoGroup<K, VV, EV>())_			.name("In-degree")__	};return,the,in,degree,of,all,vertices,in,the,graph,return,a,data,set,of,code,tuple2,vertex,id,in,degree;public,data,set,tuple2,k,long,value,in,degrees,return,vertices,co,group,edges,where,0,equal,to,1,with,new,count,neighbors,co,group,k,vv,ev,name,in,degree
Graph -> public DataSet<Tuple2<K, LongValue>> inDegrees();1484160227;Return the in-degree of all vertices in the graph__@return A DataSet of {@code Tuple2<vertexId, inDegree>};public DataSet<Tuple2<K, LongValue>> inDegrees() {__		return vertices.coGroup(edges).where(0).equalTo(1).with(new CountNeighborsCoGroup<K, VV, EV>())_			.name("In-degree")__	};return,the,in,degree,of,all,vertices,in,the,graph,return,a,data,set,of,code,tuple2,vertex,id,in,degree;public,data,set,tuple2,k,long,value,in,degrees,return,vertices,co,group,edges,where,0,equal,to,1,with,new,count,neighbors,co,group,k,vv,ev,name,in,degree
Graph -> public DataSet<Tuple2<K, LongValue>> inDegrees();1484685504;Return the in-degree of all vertices in the graph__@return A DataSet of {@code Tuple2<vertexId, inDegree>};public DataSet<Tuple2<K, LongValue>> inDegrees() {__		return vertices.coGroup(edges).where(0).equalTo(1).with(new CountNeighborsCoGroup<K, VV, EV>())_			.name("In-degree")__	};return,the,in,degree,of,all,vertices,in,the,graph,return,a,data,set,of,code,tuple2,vertex,id,in,degree;public,data,set,tuple2,k,long,value,in,degrees,return,vertices,co,group,edges,where,0,equal,to,1,with,new,count,neighbors,co,group,k,vv,ev,name,in,degree
Graph -> public DataSet<Tuple2<K, LongValue>> inDegrees();1489068942;Return the in-degree of all vertices in the graph__@return A DataSet of {@code Tuple2<vertexId, inDegree>};public DataSet<Tuple2<K, LongValue>> inDegrees() {__		return vertices.coGroup(edges).where(0).equalTo(1).with(new CountNeighborsCoGroup<K, VV, EV>())_			.name("In-degree")__	};return,the,in,degree,of,all,vertices,in,the,graph,return,a,data,set,of,code,tuple2,vertex,id,in,degree;public,data,set,tuple2,k,long,value,in,degrees,return,vertices,co,group,edges,where,0,equal,to,1,with,new,count,neighbors,co,group,k,vv,ev,name,in,degree
Graph -> public DataSet<Tuple2<K, LongValue>> inDegrees();1490973446;Return the in-degree of all vertices in the graph__@return A DataSet of {@code Tuple2<vertexId, inDegree>};public DataSet<Tuple2<K, LongValue>> inDegrees() {__		return vertices.coGroup(edges).where(0).equalTo(1).with(new CountNeighborsCoGroup<K, VV, EV>())_			.name("In-degree")__	};return,the,in,degree,of,all,vertices,in,the,graph,return,a,data,set,of,code,tuple2,vertex,id,in,degree;public,data,set,tuple2,k,long,value,in,degrees,return,vertices,co,group,edges,where,0,equal,to,1,with,new,count,neighbors,co,group,k,vv,ev,name,in,degree
Graph -> public DataSet<Tuple2<K, LongValue>> inDegrees();1495819075;Return the in-degree of all vertices in the graph.__@return A DataSet of {@code Tuple2<vertexId, inDegree>};public DataSet<Tuple2<K, LongValue>> inDegrees() {__		return vertices.coGroup(edges).where(0).equalTo(1).with(new CountNeighborsCoGroup<K, VV, EV>())_			.name("In-degree")__	};return,the,in,degree,of,all,vertices,in,the,graph,return,a,data,set,of,code,tuple2,vertex,id,in,degree;public,data,set,tuple2,k,long,value,in,degrees,return,vertices,co,group,edges,where,0,equal,to,1,with,new,count,neighbors,co,group,k,vv,ev,name,in,degree
Graph -> public DataSet<Tuple2<K, LongValue>> inDegrees();1502111816;Return the in-degree of all vertices in the graph.__@return A DataSet of {@code Tuple2<vertexId, inDegree>};public DataSet<Tuple2<K, LongValue>> inDegrees() {__		return vertices.coGroup(edges).where(0).equalTo(1).with(new CountNeighborsCoGroup<>())_			.name("In-degree")__	};return,the,in,degree,of,all,vertices,in,the,graph,return,a,data,set,of,code,tuple2,vertex,id,in,degree;public,data,set,tuple2,k,long,value,in,degrees,return,vertices,co,group,edges,where,0,equal,to,1,with,new,count,neighbors,co,group,name,in,degree
