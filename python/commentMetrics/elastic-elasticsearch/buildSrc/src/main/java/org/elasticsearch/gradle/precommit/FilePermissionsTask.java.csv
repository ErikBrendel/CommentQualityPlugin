commented;modifiers;parameterAmount;loc;comment;code
false;private,static;1;12;;private static boolean isExecutableFile(File file) {     try {         Set<PosixFilePermission> permissions = Files.getFileAttributeView(file.toPath(), PosixFileAttributeView.class).readAttributes().permissions().         return permissions.contains(PosixFilePermission.OTHERS_EXECUTE) || permissions.contains(PosixFilePermission.OWNER_EXECUTE) || permissions.contains(PosixFilePermission.GROUP_EXECUTE).     } catch (IOException e) {         throw new IllegalStateException("unable to read the file " + file + " attributes", e).     } }
true;public;0;8;/**  * Returns the files this task will check  */ ;/**  * Returns the files this task will check  */ @InputFiles @SkipWhenEmpty public FileCollection getFiles() {     return Boilerplate.getJavaSourceSets(getProject()).stream().map(sourceSet -> sourceSet.getAllSource().matching(filesFilter)).reduce(FileTree::plus).orElse(getProject().files().getAsFileTree()). }
false;public;0;17;;@TaskAction public void checkInvalidPermissions() throws IOException {     if (Os.isFamily(Os.FAMILY_WINDOWS)) {         throw new StopExecutionException().     }     List<String> failures = getFiles().getFiles().stream().filter(FilePermissionsTask::isExecutableFile).map(file -> "Source file is executable: " + file).collect(Collectors.toList()).     if (!failures.isEmpty()) {         throw new GradleException("Found invalid file permissions:\n" + String.join("\n", failures)).     }     outputMarker.getParentFile().mkdirs().     Files.write(outputMarker.toPath(), "done".getBytes("UTF-8")). }
false;public;0;4;;@OutputFile public File getOutputMarker() {     return outputMarker. }
