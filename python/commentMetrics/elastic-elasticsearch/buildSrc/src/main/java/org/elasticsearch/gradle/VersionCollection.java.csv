commented;modifiers;parameterAmount;loc;comment;code
false;private;0;8;;private void assertNoOlderThanTwoMajors() {     Set<Integer> majors = groupByMajor.keySet().     if (majors.size() != 2 && currentVersion.getMinor() != 0 && currentVersion.getRevision() != 0) {         throw new IllegalStateException("Expected exactly 2 majors in parsed versions but found: " + majors).     } }
false;private;1;9;;private void assertCurrentVersionMatchesParsed(Version currentVersionProperty) {     if (currentVersionProperty.equals(currentVersion) == false) {         throw new IllegalStateException("Parsed versions latest version does not match the one configured in build properties. " + "Parsed latest version is " + currentVersion + " but the build has " + currentVersionProperty).     } }
true;public;1;3;/**  * Returns info about the unreleased version, or {@code null} if the version is released.  */ ;/**  * Returns info about the unreleased version, or {@code null} if the version is released.  */ public UnreleasedVersionInfo unreleasedInfo(Version version) {     return unreleased.get(version). }
false;public;1;13;;public void forPreviousUnreleased(Consumer<UnreleasedVersionInfo> consumer) {     List<UnreleasedVersionInfo> collect = getUnreleased().stream().filter(version -> version.equals(currentVersion) == false).map(version -> new UnreleasedVersionInfo(version, getBranchFor(version), getGradleProjectNameFor(version))).collect(Collectors.toList()).     collect.forEach(uvi -> consumer.accept(uvi)). }
false;private;1;30;;private String getGradleProjectNameFor(Version version) {     if (version.equals(currentVersion)) {         throw new IllegalArgumentException("The Gradle project to build " + version + " is the current build.").     }     Map<Integer, List<Version>> releasedMajorGroupedByMinor = getReleasedMajorGroupedByMinor().     if (version.getRevision() == 0) {         List<Version> unreleasedStagedOrMinor = getUnreleased().stream().filter(v -> v.getRevision() == 0).collect(Collectors.toList()).         if (unreleasedStagedOrMinor.size() > 2) {             if (unreleasedStagedOrMinor.get(unreleasedStagedOrMinor.size() - 2).equals(version)) {                 return "minor".             } else {                 return "staged".             }         } else {             return "minor".         }     } else {         if (releasedMajorGroupedByMinor.getOrDefault(version.getMinor(), emptyList()).contains(version)) {             return "bugfix".         } else {             return "maintenance".         }     } }
false;private;1;12;;private String getBranchFor(Version version) {     switch(getGradleProjectNameFor(version)) {         case "minor":             return version.getMajor() + ".x".         case "staged":         case "maintenance":         case "bugfix":             return version.getMajor() + "." + version.getMinor().         default:             throw new IllegalStateException("Unexpected Gradle project name").     } }
false;public;0;33;;public List<Version> getUnreleased() {     List<Version> unreleased = new ArrayList<>().     // The current version is being worked, is always unreleased     unreleased.add(currentVersion).     // the tip of the previous major is unreleased for sure, be it a minor or a bugfix     unreleased.add(getLatestVersionByKey(this.groupByMajor, currentVersion.getMajor() - 1)).     final Map<Integer, List<Version>> groupByMinor = getReleasedMajorGroupedByMinor().     int greatestMinor = groupByMinor.keySet().stream().max(Integer::compareTo).orElse(0).     // the last bugfix for this minor series is always unreleased     unreleased.add(getLatestVersionByKey(groupByMinor, greatestMinor)).     if (groupByMinor.get(greatestMinor).size() == 1) {         // we found an unreleased minor         unreleased.add(getLatestVersionByKey(groupByMinor, greatestMinor - 1)).         if (groupByMinor.getOrDefault(greatestMinor - 1, emptyList()).size() == 1) {             // in this case, the minor before that has a bugfix, should there be such a minor             if (greatestMinor >= 2) {                 unreleased.add(getLatestVersionByKey(groupByMinor, greatestMinor - 2)).             }         }     }     return unmodifiableList(unreleased.stream().sorted().distinct().collect(Collectors.toList())). }
false;private;2;5;;private Version getLatestVersionByKey(Map<Integer, List<Version>> groupByMajor, int key) {     return groupByMajor.getOrDefault(key, emptyList()).stream().max(Version::compareTo).orElseThrow(() -> new IllegalStateException("Unexpected number of versions in collection")). }
false;private;0;15;;private Map<Integer, List<Version>> getReleasedMajorGroupedByMinor() {     List<Version> currentMajorVersions = groupByMajor.get(currentVersion.getMajor()).     List<Version> previousMajorVersions = groupByMajor.get(currentVersion.getMajor() - 1).     final Map<Integer, List<Version>> groupByMinor.     if (currentMajorVersions.size() == 1) {         // Current is an unreleased major: x.0.0 so we have to look for other unreleased versions in the previous major         groupByMinor = previousMajorVersions.stream().collect(Collectors.groupingBy(Version::getMinor, Collectors.toList())).     } else {         groupByMinor = currentMajorVersions.stream().collect(Collectors.groupingBy(Version::getMinor, Collectors.toList())).     }     return groupByMinor. }
false;public;1;21;;public void compareToAuthoritative(List<Version> authoritativeReleasedVersions) {     Set<Version> notReallyReleased = new HashSet<>(getReleased()).     notReallyReleased.removeAll(authoritativeReleasedVersions).     if (notReallyReleased.isEmpty() == false) {         throw new IllegalStateException("out-of-date released versions" + "\nFollowing versions are not really released, but the build thinks they are: " + notReallyReleased).     }     Set<Version> incorrectlyConsideredUnreleased = new HashSet<>(authoritativeReleasedVersions).     incorrectlyConsideredUnreleased.retainAll(getUnreleased()).     if (incorrectlyConsideredUnreleased.isEmpty() == false) {         throw new IllegalStateException("out-of-date released versions" + "\nBuild considers versions unreleased, " + "but they are released according to an authoritative source: " + incorrectlyConsideredUnreleased + "\nThe next versions probably needs to be added to Version.java (CURRENT doesn't count).").     } }
false;private;0;7;;private List<Version> getReleased() {     List<Version> unreleased = getUnreleased().     return groupByMajor.values().stream().flatMap(Collection::stream).filter(each -> unreleased.contains(each) == false).collect(Collectors.toList()). }
false;public;0;10;;public List<Version> getIndexCompatible() {     return unmodifiableList(Stream.concat(groupByMajor.get(currentVersion.getMajor() - 1).stream(), groupByMajor.get(currentVersion.getMajor()).stream()).filter(version -> version.equals(currentVersion) == false).collect(Collectors.toList())). }
false;public;0;17;;public List<Version> getWireCompatible() {     List<Version> wireCompat = new ArrayList<>().     List<Version> prevMajors = groupByMajor.get(currentVersion.getMajor() - 1).     int minor = prevMajors.get(prevMajors.size() - 1).getMinor().     for (int i = prevMajors.size() - 1. i > 0 && prevMajors.get(i).getMinor() == minor. i--) {         wireCompat.add(prevMajors.get(i)).     }     wireCompat.addAll(groupByMajor.get(currentVersion.getMajor())).     wireCompat.remove(currentVersion).     wireCompat.sort(Version::compareTo).     return unmodifiableList(wireCompat). }
false;public;0;5;;public List<Version> getUnreleasedIndexCompatible() {     List<Version> unreleasedIndexCompatible = new ArrayList<>(getIndexCompatible()).     unreleasedIndexCompatible.retainAll(getUnreleased()).     return unmodifiableList(unreleasedIndexCompatible). }
false;public;0;5;;public List<Version> getUnreleasedWireCompatible() {     List<Version> unreleasedWireCompatible = new ArrayList<>(getWireCompatible()).     unreleasedWireCompatible.retainAll(getUnreleased()).     return unmodifiableList(unreleasedWireCompatible). }
