commented;modifiers;parameterAmount;loc;comment;code
false;public;0;3;;public String getName() {     return name. }
false;public;0;3;;public String getVersion() {     return version. }
false;public;1;5;;public void setVersion(String version) {     requireNonNull(version, "null version passed when configuring test cluster `" + this + "`").     checkFrozen().     this.version = version. }
false;public;0;3;;public Distribution getDistribution() {     return distribution. }
false;public;1;5;;public void setDistribution(Distribution distribution) {     requireNonNull(distribution, "null distribution passed when configuring test cluster `" + this + "`").     checkFrozen().     this.distribution = distribution. }
false;public;0;7;;public void freeze() {     requireNonNull(distribution, "null distribution passed when configuring test cluster `" + this + "`").     requireNonNull(version, "null version passed when configuring test cluster `" + this + "`").     requireNonNull(javaHome, "null javaHome passed when configuring test cluster `" + this + "`").     logger.info("Locking configuration of `{}`", this).     configurationFrozen.set(true). }
false;public;1;8;;public void setJavaHome(File javaHome) {     requireNonNull(javaHome, "null javaHome passed when configuring test cluster `" + this + "`").     checkFrozen().     if (javaHome.exists() == false) {         throw new TestClustersException("java home for `" + this + "` does not exists: `" + javaHome + "`").     }     this.javaHome = javaHome. }
false;public;0;3;;public File getJavaHome() {     return javaHome. }
false;private;2;18;;private void waitForUri(String description, String uri) {     waitConditions.put(description, (node) -> {         try {             URL url = new URL("http://" + this.getHttpPortInternal().get(0) + uri).             HttpURLConnection con = (HttpURLConnection) url.openConnection().             con.setRequestMethod("GET").             con.setConnectTimeout(500).             con.setReadTimeout(500).             try (BufferedReader reader = new BufferedReader(new InputStreamReader(con.getInputStream()))) {                 String response = reader.lines().collect(Collectors.joining("\n")).                 logger.info("{} -> {} ->\n{}", this, uri, response).             }             return true.         } catch (IOException e) {             throw new IllegalStateException("Connection attempt to " + this + " failed", e).         }     }). }
false;synchronized;0;20;;synchronized void start() {     logger.info("Starting `{}`", this).     Path distroArtifact = artifactsExtractDir.resolve(distribution.getFileExtension()).resolve(distribution.getFileName() + "-" + getVersion()).     if (Files.exists(distroArtifact) == false) {         throw new TestClustersException("Can not start " + this + ", missing: " + distroArtifact).     }     if (Files.isDirectory(distroArtifact) == false) {         throw new TestClustersException("Can not start " + this + ", is not a directory: " + distroArtifact).     }     services.sync(spec -> {         spec.from(distroArtifact.resolve("config").toFile()).         spec.into(configFile.getParent()).     }).     configure().     startElasticsearchProcess(distroArtifact). }
false;private;1;29;;private void startElasticsearchProcess(Path distroArtifact) {     logger.info("Running `bin/elasticsearch` in `{}` for {}", workingDir, this).     final ProcessBuilder processBuilder = new ProcessBuilder().     if (OperatingSystem.current().isWindows()) {         processBuilder.command("cmd", "/c", distroArtifact.resolve("\\bin\\elasticsearch.bat").toAbsolutePath().toString()).     } else {         processBuilder.command(distroArtifact.resolve("bin/elasticsearch").toAbsolutePath().toString()).     }     try {         processBuilder.directory(workingDir.toFile()).         Map<String, String> environment = processBuilder.environment().         // Don't inherit anything from the environment for as that would  lack reproductability         environment.clear().         environment.put("JAVA_HOME", getJavaHome().getAbsolutePath()).         environment.put("ES_PATH_CONF", configFile.getParent().toAbsolutePath().toString()).         environment.put("ES_JAVA_OPTIONS", "-Xms512m -Xmx512m").         // don't buffer all in memory, make sure we don't block on the default pipes         processBuilder.redirectError(ProcessBuilder.Redirect.appendTo(esStderrFile.toFile())).         processBuilder.redirectOutput(ProcessBuilder.Redirect.appendTo(esStdoutFile.toFile())).         esProcess = processBuilder.start().     } catch (IOException e) {         throw new TestClustersException("Failed to start ES process for " + this, e).     } }
false;public;0;4;;public String getHttpSocketURI() {     waitForAllConditions().     return getHttpPortInternal().get(0). }
false;public;0;4;;public String getTransportPortURI() {     waitForAllConditions().     return getTransportPortInternal().get(0). }
false;synchronized;1;16;;synchronized void stop(boolean tailLogs) {     if (esProcess == null && tailLogs) {         // Another exception here would eat the orriginal.         return.     }     logger.info("Stopping `{}`, tailLogs: {}", this, tailLogs).     requireNonNull(esProcess, "Can't stop `" + this + "` as it was not started or already stopped.").     // Test clusters are not reused, don't spend time on a graceful shutdown     stopHandle(esProcess.toHandle(), true).     if (tailLogs) {         logFileContents("Standard output of node", esStdoutFile).         logFileContents("Standard error of node", esStderrFile).     }     esProcess = null. }
false;private;2;33;;private void stopHandle(ProcessHandle processHandle, boolean forcibly) {     // Stop all children first, ES could actually be a child when there's some wrapper process like on Windows.     if (processHandle.isAlive() == false) {         logger.info("Process was not running when we tried to terminate it.").         return.     }     // Stop all children first, ES could actually be a child when there's some wrapper process like on Windows.     processHandle.children().forEach(each -> stopHandle(each, forcibly)).     logProcessInfo("Terminating elasticsearch process" + (forcibly ? " forcibly " : "gracefully") + ":", processHandle.info()).     if (forcibly) {         processHandle.destroyForcibly().     } else {         processHandle.destroy().         waitForProcessToExit(processHandle).         if (processHandle.isAlive() == false) {             return.         }         logger.info("process did not terminate after {} {}, stopping it forcefully", ES_DESTROY_TIMEOUT, ES_DESTROY_TIMEOUT_UNIT).         processHandle.destroyForcibly().     }     waitForProcessToExit(processHandle).     if (processHandle.isAlive()) {         throw new TestClustersException("Was not able to terminate elasticsearch process").     } }
false;private;2;8;;private void logProcessInfo(String prefix, ProcessHandle.Info info) {     logger.info(prefix + " commandLine:`{}` command:`{}` args:`{}`", info.commandLine().orElse("-"), info.command().orElse("-"), Arrays.stream(info.arguments().orElse(new String[] {})).map(each -> "'" + each + "'").collect(Collectors.joining(" "))). }
false;private;2;10;;private void logFileContents(String description, Path from) {     logger.error("{} `{}`", description, this).     try (Stream<String> lines = Files.lines(from, StandardCharsets.UTF_8)) {         lines.map(line -> "  " + line).forEach(logger::error).     } catch (IOException e) {         throw new UncheckedIOException(e).     } }
false;private;1;12;;private void waitForProcessToExit(ProcessHandle processHandle) {     try {         processHandle.onExit().get(ES_DESTROY_TIMEOUT, ES_DESTROY_TIMEOUT_UNIT).     } catch (InterruptedException e) {         logger.info("Interrupted while waiting for ES process", e).         Thread.currentThread().interrupt().     } catch (ExecutionException e) {         logger.info("Failure while waiting for process to exist", e).     } catch (TimeoutException e) {         logger.info("Timed out waiting for process to exit", e).     } }
false;private;0;47;;private void configure() {     try {         Files.createDirectories(configFile.getParent()).         Files.createDirectories(confPathRepo).         Files.createDirectories(confPathData).         Files.createDirectories(confPathLogs).     } catch (IOException e) {         throw new UncheckedIOException(e).     }     LinkedHashMap<String, String> config = new LinkedHashMap<>().     String nodeName = safeName(name).     config.put("cluster.name", nodeName).     config.put("node.name", nodeName).     config.put("path.repo", confPathRepo.toAbsolutePath().toString()).     config.put("path.data", confPathData.toAbsolutePath().toString()).     config.put("path.logs", confPathLogs.toAbsolutePath().toString()).     config.put("path.shared_data", workingDir.resolve("sharedData").toString()).     config.put("node.attr.testattr", "test").     config.put("node.portsfile", "true").     config.put("http.port", "0").     config.put("transport.tcp.port", "0").     // Default the watermarks to absurdly low to prevent the tests from failing on nodes without enough disk space     config.put("cluster.routing.allocation.disk.watermark.low", "1b").     config.put("cluster.routing.allocation.disk.watermark.high", "1b").     // increase script compilation limit since tests can rapid-fire script compilations     config.put("script.max_compilations_rate", "2048/1m").     if (Version.fromString(version).getMajor() >= 6) {         config.put("cluster.routing.allocation.disk.watermark.flood_stage", "1b").     }     if (Version.fromString(version).getMajor() >= 7) {         config.put("cluster.initial_master_nodes", "[" + nodeName + "]").     }     try {         Files.write(configFile, config.entrySet().stream().map(entry -> entry.getKey() + ": " + entry.getValue()).collect(Collectors.joining("\n")).getBytes(StandardCharsets.UTF_8)).     } catch (IOException e) {         throw new UncheckedIOException("Could not write config file: " + configFile, e).     }     logger.info("Written config file:{} for {}", configFile, this). }
false;private;0;5;;private void checkFrozen() {     if (configurationFrozen.get()) {         throw new IllegalStateException("Configuration can not be altered, already locked").     } }
false;private,static;1;5;;private static String safeName(String name) {     return name.replaceAll("^[^a-zA-Z0-9]+", "").replaceAll("[^a-zA-Z0-9]+", "-"). }
false;private;0;9;;private List<String> getTransportPortInternal() {     try {         return readPortsFile(transportPortFile).     } catch (IOException e) {         throw new UncheckedIOException("Failed to read transport ports file: " + transportPortFile + " for " + this, e).     } }
false;private;0;9;;private List<String> getHttpPortInternal() {     try {         return readPortsFile(httpPortsFile).     } catch (IOException e) {         throw new UncheckedIOException("Failed to read http ports file: " + httpPortsFile + " for " + this, e).     } }
false;private;1;5;;private List<String> readPortsFile(Path file) throws IOException {     try (Stream<String> lines = Files.lines(file, StandardCharsets.UTF_8)) {         return lines.map(String::trim).collect(Collectors.toList()).     } }
false;private;0;54;;private void waitForAllConditions() {     requireNonNull(esProcess, "Can't wait for `" + this + "` as it was stopped.").     long startedAt = System.currentTimeMillis().     logger.info("Starting to wait for cluster to come up").     waitConditions.forEach((description, predicate) -> {         long thisConditionStartedAt = System.currentTimeMillis().         boolean conditionMet = false.         Throwable lastException = null.         while (System.currentTimeMillis() - startedAt < MILLISECONDS.convert(NODE_UP_TIMEOUT, NODE_UP_TIMEOUT_UNIT)) {             if (esProcess.isAlive() == false) {                 throw new TestClustersException("process was found dead while waiting for " + description + ", " + this).             }             try {                 if (predicate.test(this)) {                     conditionMet = true.                     break.                 }             } catch (TestClustersException e) {                 throw new TestClustersException(e).             } catch (Exception e) {                 if (lastException == null) {                     lastException = e.                 } else {                     e.addSuppressed(lastException).                     lastException = e.                 }             }             try {                 Thread.sleep(500).             } catch (InterruptedException e) {                 Thread.currentThread().interrupt().             }         }         if (conditionMet == false) {             String message = "`" + this + "` failed to wait for " + description + " after " + NODE_UP_TIMEOUT + " " + NODE_UP_TIMEOUT_UNIT.             if (lastException == null) {                 throw new TestClustersException(message).             } else {                 throw new TestClustersException(message, lastException).             }         }         logger.info("{}: {} took {} seconds", this, description, SECONDS.convert(System.currentTimeMillis() - thisConditionStartedAt, MILLISECONDS)).     }). }
false;public;1;8;;@Override public boolean equals(Object o) {     if (this == o)         return true.     if (o == null || getClass() != o.getClass())         return false.     ElasticsearchNode that = (ElasticsearchNode) o.     return Objects.equals(name, that.name) && Objects.equals(path, that.path). }
false;public;0;4;;@Override public int hashCode() {     return Objects.hash(name, path). }
false;public;0;4;;@Override public String toString() {     return "node{" + path + ":" + name + "}". }
