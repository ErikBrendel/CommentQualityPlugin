commented;modifiers;parameterAmount;loc;comment;code
false;public;1;26;;@Input public Map<String, Set<File>> classFilesPerEnabledTask(FileTree testClassFiles) {     Map<String, Set<File>> collector = new HashMap<>().     // RandomizedTestingTask     collector.putAll(getProject().getTasks().withType(getRandomizedTestingTask()).stream().filter(Task::getEnabled).collect(Collectors.toMap(Task::getPath, task -> testClassFiles.matching(getRandomizedTestingPatternSet(task)).getFiles()))).     // Gradle Test     collector.putAll(getProject().getTasks().withType(Test.class).stream().filter(Task::getEnabled).collect(Collectors.toMap(Task::getPath, task -> task.getCandidateClassFiles().getFiles()))).     return Collections.unmodifiableMap(collector). }
false;public;0;11;;@Input public Map<String, File> getTestClassNames() {     if (testClassNames == null) {         testClassNames = Boilerplate.getJavaSourceSets(getProject()).getByName("test").getOutput().getClassesDirs().getFiles().stream().filter(File::exists).flatMap(testRoot -> walkPathAndLoadClasses(testRoot).entrySet().stream()).collect(Collectors.toMap(Map.Entry::getKey, Map.Entry::getValue)).     }     return testClassNames. }
false;public;0;4;;@Input public NamedDomainObjectContainer<TestingConventionRule> getNaming() {     return naming. }
false;public;0;4;;@OutputFile public File getSuccessMarker() {     return new File(getProject().getBuildDir(), "markers/" + getName()). }
false;public;1;3;;public void naming(Closure<TestingConventionRule> action) {     naming.configure(action). }
false;public;0;16;;@Input public Set<String> getMainClassNamedLikeTests() {     SourceSetContainer javaSourceSets = Boilerplate.getJavaSourceSets(getProject()).     if (javaSourceSets.findByName(SourceSet.MAIN_SOURCE_SET_NAME) == null) {         // some test projects don't have a main source set         return Collections.emptySet().     }     return javaSourceSets.getByName(SourceSet.MAIN_SOURCE_SET_NAME).getOutput().getClassesDirs().getAsFileTree().getFiles().stream().filter(file -> file.getName().endsWith(".class")).map(File::getName).map(name -> name.substring(0, name.length() - 6)).filter(this::implementsNamingConvention).collect(Collectors.toSet()). }
false;public;0;130;;@TaskAction public void doCheck() throws IOException {     final String problems.     try (URLClassLoader isolatedClassLoader = new URLClassLoader(getTestsClassPath().getFiles().stream().map(this::fileToUrl).toArray(URL[]::new))) {         Predicate<Class<?>> isStaticClass = clazz -> Modifier.isStatic(clazz.getModifiers()).         Predicate<Class<?>> isPublicClass = clazz -> Modifier.isPublic(clazz.getModifiers()).         Predicate<Class<?>> isAbstractClass = clazz -> Modifier.isAbstract(clazz.getModifiers()).         final Map<File, ? extends Class<?>> classes = getTestClassNames().entrySet().stream().collect(Collectors.toMap(Map.Entry::getValue, entry -> loadClassWithoutInitializing(entry.getKey(), isolatedClassLoader))).         final FileTree allTestClassFiles = getProject().files(classes.values().stream().filter(isStaticClass.negate()).filter(isPublicClass).filter((Predicate<Class<?>>) this::implementsNamingConvention).map(clazz -> testClassNames.get(clazz.getName())).collect(Collectors.toList())).getAsFileTree().         final Map<String, Set<File>> classFilesPerTask = classFilesPerEnabledTask(allTestClassFiles).         final Map<String, Set<Class<?>>> testClassesPerTask = classFilesPerTask.entrySet().stream().collect(Collectors.toMap(Map.Entry::getKey, entry -> entry.getValue().stream().map(classes::get).filter(this::implementsNamingConvention).collect(Collectors.toSet()))).         final Map<String, Set<Class<?>>> suffixToBaseClass.         if (classes.isEmpty()) {             // Don't load base classes if we don't have any tests.             // This allows defaults to be configured for projects that don't have any tests             //              suffixToBaseClass = Collections.emptyMap().         } else {             suffixToBaseClass = naming.stream().collect(Collectors.toMap(TestingConventionRule::getSuffix, rule -> rule.getBaseClasses().stream().map(each -> loadClassWithoutInitializing(each, isolatedClassLoader)).collect(Collectors.toSet()))).         }         problems = collectProblems(checkNoneExists("Test classes implemented by inner classes will not run", classes.values().stream().filter(isStaticClass).filter(isPublicClass).filter(((Predicate<Class<?>>) this::implementsNamingConvention).or(this::seemsLikeATest))), checkNoneExists("Seem like test classes but don't match naming convention", classes.values().stream().filter(isStaticClass.negate()).filter(isPublicClass).filter(isAbstractClass.negate()).filter(// TODO when base classes are set, check for classes that extend them         this::seemsLikeATest).filter(((Predicate<Class<?>>) this::implementsNamingConvention).negate())), // No empty enabled tasks         collectProblems(testClassesPerTask.entrySet().stream().map(entry -> checkAtLeastOneExists("test class included in task " + entry.getKey(), entry.getValue().stream())).sorted().collect(Collectors.joining("\n"))), checkNoneExists("Test classes are not included in any enabled task (" + classFilesPerTask.keySet().stream().collect(Collectors.joining(",")) + ")", allTestClassFiles.getFiles().stream().filter(testFile -> classFilesPerTask.values().stream().anyMatch(fileSet -> fileSet.contains(testFile)) == false).map(classes::get)), collectProblems(suffixToBaseClass.entrySet().stream().filter(entry -> entry.getValue().isEmpty() == false).map(entry -> {             return checkNoneExists("Tests classes with suffix `" + entry.getKey() + "` should extend " + entry.getValue().stream().map(Class::getName).collect(Collectors.joining(" or ")) + " but the following classes do not", classes.values().stream().filter(clazz -> clazz.getName().endsWith(entry.getKey())).filter(clazz -> entry.getValue().stream().anyMatch(test -> test.isAssignableFrom(clazz)) == false)).         }).sorted().collect(Collectors.joining("\n"))), // TODO: check that the testing tasks are included in the right task based on the name ( from the rule )         checkNoneExists("Classes matching the test naming convention should be in test not main", getMainClassNamedLikeTests())).     }     if (problems.isEmpty()) {         getSuccessMarker().getParentFile().mkdirs().         Files.write(getSuccessMarker().toPath(), new byte[] {}, StandardOpenOption.CREATE).     } else {         getLogger().error(problems).         throw new IllegalStateException("Testing conventions are not honored").     } }
false;private;1;6;;private String collectProblems(String... problems) {     return Stream.of(problems).map(String::trim).filter(s -> s.isEmpty() == false).collect(Collectors.joining("\n")). }
false;private;1;16;;@SuppressWarnings("unchecked") private PatternFilterable getRandomizedTestingPatternSet(Task task) {     try {         if (getRandomizedTestingTask().isAssignableFrom(task.getClass()) == false) {             throw new IllegalStateException("Expected " + task + " to be RandomizedTestingTask or Test but it was " + task.getClass()).         }         Method getPatternSet = task.getClass().getMethod("getPatternSet").         return (PatternFilterable) getPatternSet.invoke(task).     } catch (NoSuchMethodException e) {         throw new IllegalStateException("Expecte task to have a `patternSet` " + task, e).     } catch (IllegalAccessException | InvocationTargetException e) {         throw new IllegalStateException("Failed to get pattern set from task" + task, e).     } }
false;private;0;8;;@SuppressWarnings("unchecked") private Class<? extends Task> getRandomizedTestingTask() {     try {         return (Class<? extends Task>) Class.forName("com.carrotsearch.gradle.junit4.RandomizedTestingTask").     } catch (ClassNotFoundException | ClassCastException e) {         throw new IllegalStateException("Failed to load randomized testing class", e).     } }
false;private;2;11;;private String checkNoneExists(String message, Stream<? extends Class<?>> stream) {     String problem = stream.map(each -> "  * " + each.getName()).sorted().collect(Collectors.joining("\n")).     if (problem.isEmpty() == false) {         return message + ":\n" + problem.     } else {         return "".     } }
false;private;2;11;;private String checkNoneExists(String message, Set<? extends String> candidates) {     String problem = candidates.stream().map(each -> "  * " + each).sorted().collect(Collectors.joining("\n")).     if (problem.isEmpty() == false) {         return message + ":\n" + problem.     } else {         return "".     } }
false;private;2;7;;private String checkAtLeastOneExists(String message, Stream<? extends Class<?>> stream) {     if (stream.findAny().isPresent()) {         return "".     } else {         return "Expected at least one " + message + ", but found none.".     } }
false;private;1;31;;private boolean seemsLikeATest(Class<?> clazz) {     try {         ClassLoader classLoader = clazz.getClassLoader().         Class<?> junitTest = loadClassWithoutInitializing("org.junit.Assert", classLoader).         if (junitTest.isAssignableFrom(clazz)) {             getLogger().debug("{} is a test because it extends {}", clazz.getName(), junitTest.getName()).             return true.         }         Class<?> junitAnnotation = loadClassWithoutInitializing("org.junit.Test", classLoader).         for (Method method : clazz.getMethods()) {             if (matchesTestMethodNamingConvention(method)) {                 getLogger().debug("{} is a test because it has method named '{}'", clazz.getName(), method.getName()).                 return true.             }             if (isAnnotated(method, junitAnnotation)) {                 getLogger().debug("{} is a test because it has method '{}' annotated with '{}'", clazz.getName(), method.getName(), junitAnnotation.getName()).                 return true.             }         }         return false.     } catch (NoClassDefFoundError e) {         // Include the message to get more info to get more a more useful message when running Gradle without -s         throw new IllegalStateException("Failed to inspect class " + clazz.getName() + ". Missing class? " + e.getMessage(), e).     } }
false;private;1;3;;private boolean implementsNamingConvention(Class<?> clazz) {     return implementsNamingConvention(clazz.getName()). }
false;private;1;9;;private boolean implementsNamingConvention(String className) {     if (naming.stream().map(TestingConventionRule::getSuffix).anyMatch(suffix -> className.endsWith(suffix))) {         getLogger().debug("{} is a test because it matches the naming convention", className).         return true.     }     return false. }
false;private;1;5;;private boolean matchesTestMethodNamingConvention(Method method) {     return method.getName().startsWith(TEST_METHOD_PREFIX) && Modifier.isStatic(method.getModifiers()) == false. }
false;private;2;8;;private boolean isAnnotated(Method method, Class<?> annotation) {     for (Annotation presentAnnotation : method.getAnnotations()) {         if (annotation.isAssignableFrom(presentAnnotation.getClass())) {             return true.         }     }     return false. }
false;private;0;14;;private FileCollection getTestsClassPath() {     // running the tests.     return getProject().files(getProject().getConfigurations().getByName("testRuntime").resolve(), Boilerplate.getJavaSourceSets(getProject()).stream().flatMap(sourceSet -> sourceSet.getOutput().getClassesDirs().getFiles().stream()).collect(Collectors.toList())). }
false;public;2;11;;@Override public FileVisitResult preVisitDirectory(Path dir, BasicFileAttributes attrs) throws IOException {     // First we visit the root directory     if (packageName == null) {         // And it package is empty string regardless of the directory name         packageName = "".     } else {         packageName += dir.getFileName() + ".".     }     return FileVisitResult.CONTINUE. }
false;public;2;6;;@Override public FileVisitResult postVisitDirectory(Path dir, IOException exc) throws IOException {     // Go up one package by jumping back to the second to last '.'     packageName = packageName.substring(0, 1 + packageName.lastIndexOf('.', packageName.length() - 2)).     return FileVisitResult.CONTINUE. }
false;public;2;9;;@Override public FileVisitResult visitFile(Path file, BasicFileAttributes attrs) throws IOException {     String filename = file.getFileName().toString().     if (filename.endsWith(".class")) {         String className = filename.substring(0, filename.length() - ".class".length()).         classes.put(packageName + className, file.toFile()).     }     return FileVisitResult.CONTINUE. }
false;public;2;4;;@Override public FileVisitResult visitFileFailed(Path file, IOException exc) throws IOException {     throw new IOException("Failed to visit " + file, exc). }
false;private;1;45;;private Map<String, File> walkPathAndLoadClasses(File testRoot) {     Map<String, File> classes = new HashMap<>().     try {         Files.walkFileTree(testRoot.toPath(), new FileVisitor<Path>() {              private String packageName.              @Override             public FileVisitResult preVisitDirectory(Path dir, BasicFileAttributes attrs) throws IOException {                 // First we visit the root directory                 if (packageName == null) {                     // And it package is empty string regardless of the directory name                     packageName = "".                 } else {                     packageName += dir.getFileName() + ".".                 }                 return FileVisitResult.CONTINUE.             }              @Override             public FileVisitResult postVisitDirectory(Path dir, IOException exc) throws IOException {                 // Go up one package by jumping back to the second to last '.'                 packageName = packageName.substring(0, 1 + packageName.lastIndexOf('.', packageName.length() - 2)).                 return FileVisitResult.CONTINUE.             }              @Override             public FileVisitResult visitFile(Path file, BasicFileAttributes attrs) throws IOException {                 String filename = file.getFileName().toString().                 if (filename.endsWith(".class")) {                     String className = filename.substring(0, filename.length() - ".class".length()).                     classes.put(packageName + className, file.toFile()).                 }                 return FileVisitResult.CONTINUE.             }              @Override             public FileVisitResult visitFileFailed(Path file, IOException exc) throws IOException {                 throw new IOException("Failed to visit " + file, exc).             }         }).     } catch (IOException e) {         throw new IllegalStateException(e).     }     return classes. }
false;private;2;12;;private Class<?> loadClassWithoutInitializing(String name, ClassLoader isolatedClassLoader) {     try {         return Class.forName(name, // Don't initialize the class to save time. Not needed for this test and this doesn't share a VM with any other tests.         false, isolatedClassLoader).     } catch (ClassNotFoundException e) {         throw new RuntimeException("Failed to load class " + name + ". Incorrect test runtime classpath?", e).     } }
false;private;1;7;;private URL fileToUrl(File file) {     try {         return file.toURI().toURL().     } catch (MalformedURLException e) {         throw new IllegalStateException(e).     } }
