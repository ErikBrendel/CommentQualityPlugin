commented;modifiers;parameterAmount;loc;comment;code
false;public;0;4;;@OutputDirectory public DirectoryProperty getOutputDir() {     return outputDir. }
false;public;0;5;;@Input @SkipWhenEmpty public Set<String> getResources() {     return Collections.unmodifiableSet(resources). }
false;public;0;6;;@Classpath public String getResourcesClasspath() {     // This will make sure the task is not considered up to date if the resources are changed.     logger.info("Classpath: {}", System.getProperty("java.class.path")).     return System.getProperty("java.class.path"). }
false;public;1;3;;public void setOutputDir(DirectoryProperty outputDir) {     this.outputDir = outputDir. }
false;public;1;9;;public File copy(String resource) {     if (getState().getExecuted() || getState().getExecuting()) {         throw new GradleException("buildResources can't be configured after the task ran. " + "Make sure task is not used after configuration time").     }     resources.add(resource).     return outputDir.file(resource).get().getAsFile(). }
false;public;0;19;;@TaskAction public void doExport() {     if (resources.isEmpty()) {         throw new StopExecutionException().     }     resources.stream().parallel().forEach(resourcePath -> {         Path destination = outputDir.get().file(resourcePath).getAsFile().toPath().         try (InputStream is = getClass().getClassLoader().getResourceAsStream(resourcePath)) {             Files.createDirectories(destination.getParent()).             if (is == null) {                 throw new GradleException("Can't export `" + resourcePath + "` from build-tools: not found").             }             Files.copy(is, destination, StandardCopyOption.REPLACE_EXISTING).         } catch (IOException e) {             throw new GradleException("Can't write resource `" + resourcePath + "` to " + destination, e).         }     }). }
