commented;modifiers;parameterAmount;loc;comment;code
false;public;1;83;;@Override public void apply(Project project) {     TaskContainer tasks = project.getTasks().     TestFixtureExtension extension = project.getExtensions().create("testFixtures", TestFixtureExtension.class, project).     if (project.file(DOCKER_COMPOSE_YML).exists()) {         // convenience boilerplate with build plugin         // Can't reference tasks that are implemented in Groovy, use reflection  instead         disableTaskByType(tasks, getTaskClass("org.elasticsearch.gradle.precommit.LicenseHeadersTask")).         disableTaskByType(tasks, ThirdPartyAuditTask.class).         disableTaskByType(tasks, JarHellTask.class).         Task buildFixture = project.getTasks().create("buildFixture").         Task pullFixture = project.getTasks().create("pullFixture").         Task preProcessFixture = project.getTasks().create("preProcessFixture").         buildFixture.dependsOn(preProcessFixture).         pullFixture.dependsOn(preProcessFixture).         Task postProcessFixture = project.getTasks().create("postProcessFixture").         if (dockerComposeSupported(project) == false) {             preProcessFixture.setEnabled(false).             postProcessFixture.setEnabled(false).             buildFixture.setEnabled(false).             pullFixture.setEnabled(false).             return.         }         project.apply(spec -> spec.plugin(BasePlugin.class)).         project.apply(spec -> spec.plugin(DockerComposePlugin.class)).         ComposeExtension composeExtension = project.getExtensions().getByType(ComposeExtension.class).         composeExtension.setUseComposeFiles(Collections.singletonList(DOCKER_COMPOSE_YML)).         composeExtension.setRemoveContainers(true).         composeExtension.setExecutable(project.file("/usr/local/bin/docker-compose").exists() ? "/usr/local/bin/docker-compose" : "/usr/bin/docker-compose").         buildFixture.dependsOn(tasks.getByName("composeUp")).         pullFixture.dependsOn(tasks.getByName("composePull")).         tasks.getByName("composeUp").mustRunAfter(preProcessFixture).         tasks.getByName("composePull").mustRunAfter(preProcessFixture).         postProcessFixture.dependsOn(buildFixture).         configureServiceInfoForTask(postProcessFixture, project, (name, port) -> postProcessFixture.getExtensions().getByType(ExtraPropertiesExtension.class).set(name, port)).     }     extension.fixtures.all(fixtureProject -> project.evaluationDependsOn(fixtureProject.getPath())).     if (dockerComposeSupported(project) == false) {         project.getLogger().warn("Tests for {} require docker-compose at /usr/local/bin/docker-compose or /usr/bin/docker-compose " + "but none could be found so these will be skipped", project.getPath()).         disableTaskByType(tasks, getTaskClass("com.carrotsearch.gradle.junit4.RandomizedTestingTask")).         // conventions are not honored when the tasks are disabled         disableTaskByType(tasks, TestingConventionsTasks.class).         disableTaskByType(tasks, ComposeUp.class).         return.     }     tasks.withType(getTaskClass("com.carrotsearch.gradle.junit4.RandomizedTestingTask"), task -> extension.fixtures.all(fixtureProject -> {         fixtureProject.getTasks().matching(it -> it.getName().equals("buildFixture")).all(buildFixture -> task.dependsOn(buildFixture)).         fixtureProject.getTasks().matching(it -> it.getName().equals("composeDown")).all(composeDown -> task.finalizedBy(composeDown)).         configureServiceInfoForTask(task, fixtureProject, (name, port) -> setSystemProperty(task, name, port)).     })). }
false;private;3;27;;private void configureServiceInfoForTask(Task task, Project fixtureProject, BiConsumer<String, Integer> consumer) {     // Configure ports for the tests as system properties.     // We only know these at execution time so we need to do it in doFirst     task.doFirst(theTask -> fixtureProject.getExtensions().getByType(ComposeExtension.class).getServicesInfos().forEach((service, infos) -> {         infos.getTcpPorts().forEach((container, host) -> {             String name = "test.fixtures." + service + ".tcp." + container.             theTask.getLogger().info("port mapping property: {}={}", name, host).             consumer.accept(name, host).         }).         infos.getUdpPorts().forEach((container, host) -> {             String name = "test.fixtures." + service + ".udp." + container.             theTask.getLogger().info("port mapping property: {}={}", name, host).             consumer.accept(name, host).         }).     })). }
false;public;1;9;;@Input public boolean dockerComposeSupported(Project project) {     if (OperatingSystem.current().isWindows()) {         return false.     }     final boolean hasDockerCompose = project.file("/usr/local/bin/docker-compose").exists() || project.file("/usr/bin/docker-compose").exists().     return hasDockerCompose && Boolean.parseBoolean(System.getProperty("tests.fixture.enabled", "true")). }
false;private;3;10;;private void setSystemProperty(Task task, String name, Object value) {     try {         Method systemProperty = task.getClass().getMethod("systemProperty", String.class, Object.class).         systemProperty.invoke(task, name, value).     } catch (NoSuchMethodException e) {         throw new IllegalArgumentException("Could not find systemProperty method on RandomizedTestingTask", e).     } catch (IllegalAccessException | InvocationTargetException e) {         throw new IllegalArgumentException("Could not call systemProperty method on RandomizedTestingTask", e).     } }
false;private;2;3;;private void disableTaskByType(TaskContainer tasks, Class<? extends Task> type) {     tasks.withType(type, task -> task.setEnabled(false)). }
false;private;1;13;;@SuppressWarnings("unchecked") private Class<? extends DefaultTask> getTaskClass(String type) {     Class<?> aClass.     try {         aClass = Class.forName(type).         if (DefaultTask.class.isAssignableFrom(aClass) == false) {             throw new IllegalArgumentException("Not a task type: " + type).         }     } catch (ClassNotFoundException e) {         throw new IllegalArgumentException("No such task: " + type).     }     return (Class<? extends DefaultTask>) aClass. }
