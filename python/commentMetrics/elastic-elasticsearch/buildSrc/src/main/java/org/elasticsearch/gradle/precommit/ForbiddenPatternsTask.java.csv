commented;modifiers;parameterAmount;loc;comment;code
false;public;0;9;;@InputFiles @SkipWhenEmpty public FileCollection files() {     return getProject().getConvention().getPlugin(JavaPluginConvention.class).getSourceSets().stream().map(sourceSet -> sourceSet.getAllSource().matching(filesFilter)).reduce(FileTree::plus).orElse(getProject().files().getAsFileTree()). }
false;public;0;33;;@TaskAction public void checkInvalidPatterns() throws IOException {     Pattern allPatterns = Pattern.compile("(" + String.join(")|(", getPatterns().values()) + ")").     List<String> failures = new ArrayList<>().     for (File f : files()) {         List<String> lines.         try (Stream<String> stream = Files.lines(f.toPath(), StandardCharsets.UTF_8)) {             lines = stream.collect(Collectors.toList()).         } catch (UncheckedIOException e) {             throw new IllegalArgumentException("Failed to read " + f + " as UTF_8", e).         }         List<Integer> invalidLines = IntStream.range(0, lines.size()).filter(i -> allPatterns.matcher(lines.get(i)).find()).boxed().collect(Collectors.toList()).         String path = getProject().getRootProject().getProjectDir().toURI().relativize(f.toURI()).toString().         failures = invalidLines.stream().map(l -> new AbstractMap.SimpleEntry<>(l + 1, lines.get(l))).flatMap(kv -> patterns.entrySet().stream().filter(p -> Pattern.compile(p.getValue()).matcher(kv.getValue()).find()).map(p -> "- " + p.getKey() + " on line " + kv.getKey() + " of " + path)).collect(Collectors.toList()).     }     if (failures.isEmpty() == false) {         throw new GradleException("Found invalid patterns:\n" + String.join("\n", failures)).     }     File outputMarker = getOutputMarker().     outputMarker.getParentFile().mkdirs().     Files.write(outputMarker.toPath(), "done".getBytes(StandardCharsets.UTF_8)). }
false;public;0;4;;@OutputFile public File getOutputMarker() {     return new File(getProject().getBuildDir(), "markers/" + getName()). }
false;public;0;4;;@Input public Map<String, String> getPatterns() {     return Collections.unmodifiableMap(patterns). }
false;public;1;3;;public void exclude(String... excludes) {     filesFilter.exclude(excludes). }
false;public;1;16;;public void rule(Map<String, String> props) {     String name = props.remove("name").     if (name == null) {         throw new InvalidUserDataException("Missing [name] for invalid pattern rule").     }     String pattern = props.remove("pattern").     if (pattern == null) {         throw new InvalidUserDataException("Missing [pattern] for invalid pattern rule").     }     if (props.isEmpty() == false) {         throw new InvalidUserDataException("Unknown arguments for ForbiddenPatterns rule mapping: " + props.keySet().toString()).     }     // TODO: fail if pattern contains a newline, it won't work (currently)     patterns.put(name, pattern). }
