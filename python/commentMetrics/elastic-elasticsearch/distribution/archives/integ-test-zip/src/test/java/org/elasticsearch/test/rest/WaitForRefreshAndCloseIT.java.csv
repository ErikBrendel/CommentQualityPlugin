commented;modifiers;parameterAmount;loc;comment;code
false;public;0;6;;@Before public void setupIndex() throws IOException {     Request request = new Request("PUT", "/test").     request.setJsonEntity("{\"settings\":{\"refresh_interval\":-1}}").     client().performRequest(request). }
false;public;0;4;;@After public void cleanupIndex() throws IOException {     client().performRequest(new Request("DELETE", "/test")). }
false;private;0;3;;private String docPath() {     return "test/_doc/1". }
false;public;0;5;;public void testIndexAndThenClose() throws Exception {     Request request = new Request("PUT", docPath()).     request.setJsonEntity("{\"test\":\"test\"}").     closeWhileListenerEngaged(start(request)). }
false;public;0;8;;public void testUpdateAndThenClose() throws Exception {     Request createDoc = new Request("PUT", docPath()).     createDoc.setJsonEntity("{\"test\":\"test\"}").     client().performRequest(createDoc).     Request updateDoc = new Request("POST", "test/_update/1").     updateDoc.setJsonEntity("{\"doc\":{\"name\":\"test\"}}").     closeWhileListenerEngaged(start(updateDoc)). }
false;public;0;6;;public void testDeleteAndThenClose() throws Exception {     Request request = new Request("PUT", docPath()).     request.setJsonEntity("{\"test\":\"test\"}").     client().performRequest(request).     closeWhileListenerEngaged(start(new Request("DELETE", docPath()))). }
false;private;1;41;;private void closeWhileListenerEngaged(ActionFuture<String> future) throws Exception {     // Wait for the refresh listener to start waiting     assertBusy(() -> {         Map<String, Object> stats.         try {             stats = entityAsMap(client().performRequest(new Request("GET", "/test/_stats/refresh"))).         } catch (IOException e) {             throw new RuntimeException(e).         }         Map<?, ?> indices = (Map<?, ?>) stats.get("indices").         Map<?, ?> theIndex = (Map<?, ?>) indices.get("test").         Map<?, ?> total = (Map<?, ?>) theIndex.get("total").         Map<?, ?> refresh = (Map<?, ?>) total.get("refresh").         int listeners = (Integer) refresh.get("listeners").         assertEquals(1, listeners).     }).     // Close the index. That should flush the listener.     client().performRequest(new Request("POST", "/test/_close")).     /*          * The request may fail, but we really, really, really want to make          * sure that it doesn't time out.          */     try {         future.get(1, TimeUnit.MINUTES).     } catch (ExecutionException ee) {         /*              * If it *does* fail it should fail with a FORBIDDEN error because              * it attempts to take an action on a closed index. Again, it'd be              * nice if all requests waiting for refresh came back even though              * the index is closed and most do, but sometimes they bump into              * the index being closed. At least they don't hang forever. That'd              * be a nightmare.              */         assertThat(ee.getCause(), instanceOf(ResponseException.class)).         ResponseException re = (ResponseException) ee.getCause().         assertEquals(403, re.getResponse().getStatusLine().getStatusCode()).         assertThat(EntityUtils.toString(re.getResponse().getEntity()), containsString("FORBIDDEN/4/index closed")).     } }
false;public;1;8;;@Override public void onSuccess(Response response) {     try {         future.onResponse(EntityUtils.toString(response.getEntity())).     } catch (IOException e) {         future.onFailure(e).     } }
false;public;1;4;;@Override public void onFailure(Exception exception) {     future.onFailure(exception). }
false;private;1;21;;private ActionFuture<String> start(Request request) {     PlainActionFuture<String> future = new PlainActionFuture<>().     request.addParameter("refresh", "wait_for").     request.addParameter("error_trace", "").     client().performRequestAsync(request, new ResponseListener() {          @Override         public void onSuccess(Response response) {             try {                 future.onResponse(EntityUtils.toString(response.getEntity())).             } catch (IOException e) {                 future.onFailure(e).             }         }          @Override         public void onFailure(Exception exception) {             future.onFailure(exception).         }     }).     return future. }
