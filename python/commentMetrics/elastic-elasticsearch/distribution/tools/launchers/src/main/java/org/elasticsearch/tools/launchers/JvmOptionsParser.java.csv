# id;timestamp;commentText;codeText;commentWords;codeWords
JvmOptionsParser -> InvalidLineConsumer -> void accept(int lineNumber, String line)_;1524684173;Invoked when a line in the JVM options does not match the specified syntax.;void accept(int lineNumber, String line)_;invoked,when,a,line,in,the,jvm,options,does,not,match,the,specified,syntax;void,accept,int,line,number,string,line
JvmOptionsParser -> InvalidLineConsumer -> void accept(int lineNumber, String line)_;1528706846;Invoked when a line in the JVM options does not match the specified syntax.;void accept(int lineNumber, String line)_;invoked,when,a,line,in,the,jvm,options,does,not,match,the,specified,syntax;void,accept,int,line,number,string,line
JvmOptionsParser -> InvalidLineConsumer -> void accept(int lineNumber, String line)_;1529508649;Invoked when a line in the JVM options does not match the specified syntax.;void accept(int lineNumber, String line)_;invoked,when,a,line,in,the,jvm,options,does,not,match,the,specified,syntax;void,accept,int,line,number,string,line
JvmOptionsParser -> InvalidLineConsumer -> void accept(int lineNumber, String line)_;1539615817;Invoked when a line in the JVM options does not match the specified syntax.;void accept(int lineNumber, String line)_;invoked,when,a,line,in,the,jvm,options,does,not,match,the,specified,syntax;void,accept,int,line,number,string,line
JvmOptionsParser -> JvmOptionConsumer -> void accept(String jvmOption)_;1524684173;Invoked when a line in the JVM options file matches the specified syntax and the specified major version._@param jvmOption the matching JVM option;void accept(String jvmOption)_;invoked,when,a,line,in,the,jvm,options,file,matches,the,specified,syntax,and,the,specified,major,version,param,jvm,option,the,matching,jvm,option;void,accept,string,jvm,option
JvmOptionsParser -> JvmOptionConsumer -> void accept(String jvmOption)_;1528706846;Invoked when a line in the JVM options file matches the specified syntax and the specified major version._@param jvmOption the matching JVM option;void accept(String jvmOption)_;invoked,when,a,line,in,the,jvm,options,file,matches,the,specified,syntax,and,the,specified,major,version,param,jvm,option,the,matching,jvm,option;void,accept,string,jvm,option
JvmOptionsParser -> JvmOptionConsumer -> void accept(String jvmOption)_;1529508649;Invoked when a line in the JVM options file matches the specified syntax and the specified major version._@param jvmOption the matching JVM option;void accept(String jvmOption)_;invoked,when,a,line,in,the,jvm,options,file,matches,the,specified,syntax,and,the,specified,major,version,param,jvm,option,the,matching,jvm,option;void,accept,string,jvm,option
JvmOptionsParser -> JvmOptionConsumer -> void accept(String jvmOption)_;1539615817;Invoked when a line in the JVM options file matches the specified syntax and the specified major version._@param jvmOption the matching JVM option;void accept(String jvmOption)_;invoked,when,a,line,in,the,jvm,options,file,matches,the,specified,syntax,and,the,specified,major,version,param,jvm,option,the,matching,jvm,option;void,accept,string,jvm,option
JvmOptionsParser -> static void parse(             final int javaMajorVersion,             final BufferedReader br,             final JvmOptionConsumer jvmOptionConsumer,             final InvalidLineConsumer invalidLineConsumer) throws IOException;1524684173;Parse the line-delimited JVM options from the specified buffered reader for the specified Java major version._Valid JVM options are:_<ul>_<li>_a line starting with a dash is treated as a JVM option that applies to all versions_</li>_<li>_a line starting with a number followed by a colon is treated as a JVM option that applies to the matching Java major version_only_</li>_<li>_a line starting with a number followed by a dash followed by a colon is treated as a JVM option that applies to the matching_Java specified major version and all larger Java major versions_</li>_<li>_a line starting with a number followed by a dash followed by a number followed by a colon is treated as a JVM option that_applies to the specified range of matching Java major versions_</li>_</ul>__For example, if the specified Java major version is 8, the following JVM options will be accepted:_<ul>_<li>_{@code -XX:+PrintGCDateStamps}_</li>_<li>_{@code 8:-XX:+PrintGCDateStamps}_</li>_<li>_{@code 8-:-XX:+PrintGCDateStamps}_</li>_<li>_{@code 7-8:-XX:+PrintGCDateStamps}_</li>_</ul>_and the following JVM options will not be accepted:_<ul>_<li>_{@code 9:-Xlog:age*=trace,gc*,safepoint:file=logs/gc.log:utctime,pid,tags:filecount=32,filesize=64m}_</li>_<li>_{@code 9-:-Xlog:age*=trace,gc*,safepoint:file=logs/gc.log:utctime,pid,tags:filecount=32,filesize=64m}_</li>_<li>_{@code 9-10:-Xlog:age*=trace,gc*,safepoint:file=logs/gc.log:utctime,pid,tags:filecount=32,filesize=64m}_</li>_</ul>__If the version syntax specified on a line matches the specified JVM options, the JVM option callback will be invoked with the JVM_option. If the line does not match the specified syntax for the JVM options, the invalid line callback will be invoked with the_contents of the entire line.__@param javaMajorVersion the Java major version to match JVM options against_@param br the buffered reader to read line-delimited JVM options from_@param jvmOptionConsumer the callback that accepts matching JVM options_@param invalidLineConsumer a callback that accepts invalid JVM options_@throws IOException if an I/O exception occurs reading from the buffered reader;static void parse(_            final int javaMajorVersion,_            final BufferedReader br,_            final JvmOptionConsumer jvmOptionConsumer,_            final InvalidLineConsumer invalidLineConsumer) throws IOException {_        int lineNumber = 0__        while (true) {_            final String line = br.readLine()__            lineNumber++__            if (line == null) {_                break__            }_            if (line.startsWith("#")) {_                _                continue__            }_            if (line.matches("\\s*")) {_                _                continue__            }_            final Matcher matcher = PATTERN.matcher(line)__            if (matcher.matches()) {_                final String start = matcher.group("start")__                final String end = matcher.group("end")__                if (start == null) {_                    _                    jvmOptionConsumer.accept(line)__                } else {_                    final int lower__                    try {_                        lower = Integer.parseInt(start)__                    } catch (final NumberFormatException e) {_                        invalidLineConsumer.accept(lineNumber, line)__                        continue__                    }_                    final int upper__                    if (matcher.group("range") == null) {_                        _                        upper = lower__                    } else if (end == null) {_                        _                        upper = Integer.MAX_VALUE__                    } else {_                        _                        try {_                            upper = Integer.parseInt(end)__                        } catch (final NumberFormatException e) {_                            invalidLineConsumer.accept(lineNumber, line)__                            continue__                        }_                        if (upper < lower) {_                            invalidLineConsumer.accept(lineNumber, line)__                            continue__                        }_                    }_                    if (lower <= javaMajorVersion && javaMajorVersion <= upper) {_                        jvmOptionConsumer.accept(matcher.group("option"))__                    }_                }_            } else {_                invalidLineConsumer.accept(lineNumber, line)__            }_        }_    };parse,the,line,delimited,jvm,options,from,the,specified,buffered,reader,for,the,specified,java,major,version,valid,jvm,options,are,ul,li,a,line,starting,with,a,dash,is,treated,as,a,jvm,option,that,applies,to,all,versions,li,li,a,line,starting,with,a,number,followed,by,a,colon,is,treated,as,a,jvm,option,that,applies,to,the,matching,java,major,version,only,li,li,a,line,starting,with,a,number,followed,by,a,dash,followed,by,a,colon,is,treated,as,a,jvm,option,that,applies,to,the,matching,java,specified,major,version,and,all,larger,java,major,versions,li,li,a,line,starting,with,a,number,followed,by,a,dash,followed,by,a,number,followed,by,a,colon,is,treated,as,a,jvm,option,that,applies,to,the,specified,range,of,matching,java,major,versions,li,ul,for,example,if,the,specified,java,major,version,is,8,the,following,jvm,options,will,be,accepted,ul,li,code,xx,print,gcdate,stamps,li,li,code,8,xx,print,gcdate,stamps,li,li,code,8,xx,print,gcdate,stamps,li,li,code,7,8,xx,print,gcdate,stamps,li,ul,and,the,following,jvm,options,will,not,be,accepted,ul,li,code,9,xlog,age,trace,gc,safepoint,file,logs,gc,log,utctime,pid,tags,filecount,32,filesize,64m,li,li,code,9,xlog,age,trace,gc,safepoint,file,logs,gc,log,utctime,pid,tags,filecount,32,filesize,64m,li,li,code,9,10,xlog,age,trace,gc,safepoint,file,logs,gc,log,utctime,pid,tags,filecount,32,filesize,64m,li,ul,if,the,version,syntax,specified,on,a,line,matches,the,specified,jvm,options,the,jvm,option,callback,will,be,invoked,with,the,jvm,option,if,the,line,does,not,match,the,specified,syntax,for,the,jvm,options,the,invalid,line,callback,will,be,invoked,with,the,contents,of,the,entire,line,param,java,major,version,the,java,major,version,to,match,jvm,options,against,param,br,the,buffered,reader,to,read,line,delimited,jvm,options,from,param,jvm,option,consumer,the,callback,that,accepts,matching,jvm,options,param,invalid,line,consumer,a,callback,that,accepts,invalid,jvm,options,throws,ioexception,if,an,i,o,exception,occurs,reading,from,the,buffered,reader;static,void,parse,final,int,java,major,version,final,buffered,reader,br,final,jvm,option,consumer,jvm,option,consumer,final,invalid,line,consumer,invalid,line,consumer,throws,ioexception,int,line,number,0,while,true,final,string,line,br,read,line,line,number,if,line,null,break,if,line,starts,with,continue,if,line,matches,s,continue,final,matcher,matcher,pattern,matcher,line,if,matcher,matches,final,string,start,matcher,group,start,final,string,end,matcher,group,end,if,start,null,jvm,option,consumer,accept,line,else,final,int,lower,try,lower,integer,parse,int,start,catch,final,number,format,exception,e,invalid,line,consumer,accept,line,number,line,continue,final,int,upper,if,matcher,group,range,null,upper,lower,else,if,end,null,upper,integer,else,try,upper,integer,parse,int,end,catch,final,number,format,exception,e,invalid,line,consumer,accept,line,number,line,continue,if,upper,lower,invalid,line,consumer,accept,line,number,line,continue,if,lower,java,major,version,java,major,version,upper,jvm,option,consumer,accept,matcher,group,option,else,invalid,line,consumer,accept,line,number,line
JvmOptionsParser -> static void parse(             final int javaMajorVersion,             final BufferedReader br,             final JvmOptionConsumer jvmOptionConsumer,             final InvalidLineConsumer invalidLineConsumer) throws IOException;1528706846;Parse the line-delimited JVM options from the specified buffered reader for the specified Java major version._Valid JVM options are:_<ul>_<li>_a line starting with a dash is treated as a JVM option that applies to all versions_</li>_<li>_a line starting with a number followed by a colon is treated as a JVM option that applies to the matching Java major version_only_</li>_<li>_a line starting with a number followed by a dash followed by a colon is treated as a JVM option that applies to the matching_Java specified major version and all larger Java major versions_</li>_<li>_a line starting with a number followed by a dash followed by a number followed by a colon is treated as a JVM option that_applies to the specified range of matching Java major versions_</li>_</ul>__For example, if the specified Java major version is 8, the following JVM options will be accepted:_<ul>_<li>_{@code -XX:+PrintGCDateStamps}_</li>_<li>_{@code 8:-XX:+PrintGCDateStamps}_</li>_<li>_{@code 8-:-XX:+PrintGCDateStamps}_</li>_<li>_{@code 7-8:-XX:+PrintGCDateStamps}_</li>_</ul>_and the following JVM options will not be accepted:_<ul>_<li>_{@code 9:-Xlog:age*=trace,gc*,safepoint:file=logs/gc.log:utctime,pid,tags:filecount=32,filesize=64m}_</li>_<li>_{@code 9-:-Xlog:age*=trace,gc*,safepoint:file=logs/gc.log:utctime,pid,tags:filecount=32,filesize=64m}_</li>_<li>_{@code 9-10:-Xlog:age*=trace,gc*,safepoint:file=logs/gc.log:utctime,pid,tags:filecount=32,filesize=64m}_</li>_</ul>__If the version syntax specified on a line matches the specified JVM options, the JVM option callback will be invoked with the JVM_option. If the line does not match the specified syntax for the JVM options, the invalid line callback will be invoked with the_contents of the entire line.__@param javaMajorVersion the Java major version to match JVM options against_@param br the buffered reader to read line-delimited JVM options from_@param jvmOptionConsumer the callback that accepts matching JVM options_@param invalidLineConsumer a callback that accepts invalid JVM options_@throws IOException if an I/O exception occurs reading from the buffered reader;static void parse(_            final int javaMajorVersion,_            final BufferedReader br,_            final JvmOptionConsumer jvmOptionConsumer,_            final InvalidLineConsumer invalidLineConsumer) throws IOException {_        int lineNumber = 0__        while (true) {_            final String line = br.readLine()__            lineNumber++__            if (line == null) {_                break__            }_            if (line.startsWith("#")) {_                _                continue__            }_            if (line.matches("\\s*")) {_                _                continue__            }_            final Matcher matcher = PATTERN.matcher(line)__            if (matcher.matches()) {_                final String start = matcher.group("start")__                final String end = matcher.group("end")__                if (start == null) {_                    _                    jvmOptionConsumer.accept(line)__                } else {_                    final int lower__                    try {_                        lower = Integer.parseInt(start)__                    } catch (final NumberFormatException e) {_                        invalidLineConsumer.accept(lineNumber, line)__                        continue__                    }_                    final int upper__                    if (matcher.group("range") == null) {_                        _                        upper = lower__                    } else if (end == null) {_                        _                        upper = Integer.MAX_VALUE__                    } else {_                        _                        try {_                            upper = Integer.parseInt(end)__                        } catch (final NumberFormatException e) {_                            invalidLineConsumer.accept(lineNumber, line)__                            continue__                        }_                        if (upper < lower) {_                            invalidLineConsumer.accept(lineNumber, line)__                            continue__                        }_                    }_                    if (lower <= javaMajorVersion && javaMajorVersion <= upper) {_                        jvmOptionConsumer.accept(matcher.group("option"))__                    }_                }_            } else {_                invalidLineConsumer.accept(lineNumber, line)__            }_        }_    };parse,the,line,delimited,jvm,options,from,the,specified,buffered,reader,for,the,specified,java,major,version,valid,jvm,options,are,ul,li,a,line,starting,with,a,dash,is,treated,as,a,jvm,option,that,applies,to,all,versions,li,li,a,line,starting,with,a,number,followed,by,a,colon,is,treated,as,a,jvm,option,that,applies,to,the,matching,java,major,version,only,li,li,a,line,starting,with,a,number,followed,by,a,dash,followed,by,a,colon,is,treated,as,a,jvm,option,that,applies,to,the,matching,java,specified,major,version,and,all,larger,java,major,versions,li,li,a,line,starting,with,a,number,followed,by,a,dash,followed,by,a,number,followed,by,a,colon,is,treated,as,a,jvm,option,that,applies,to,the,specified,range,of,matching,java,major,versions,li,ul,for,example,if,the,specified,java,major,version,is,8,the,following,jvm,options,will,be,accepted,ul,li,code,xx,print,gcdate,stamps,li,li,code,8,xx,print,gcdate,stamps,li,li,code,8,xx,print,gcdate,stamps,li,li,code,7,8,xx,print,gcdate,stamps,li,ul,and,the,following,jvm,options,will,not,be,accepted,ul,li,code,9,xlog,age,trace,gc,safepoint,file,logs,gc,log,utctime,pid,tags,filecount,32,filesize,64m,li,li,code,9,xlog,age,trace,gc,safepoint,file,logs,gc,log,utctime,pid,tags,filecount,32,filesize,64m,li,li,code,9,10,xlog,age,trace,gc,safepoint,file,logs,gc,log,utctime,pid,tags,filecount,32,filesize,64m,li,ul,if,the,version,syntax,specified,on,a,line,matches,the,specified,jvm,options,the,jvm,option,callback,will,be,invoked,with,the,jvm,option,if,the,line,does,not,match,the,specified,syntax,for,the,jvm,options,the,invalid,line,callback,will,be,invoked,with,the,contents,of,the,entire,line,param,java,major,version,the,java,major,version,to,match,jvm,options,against,param,br,the,buffered,reader,to,read,line,delimited,jvm,options,from,param,jvm,option,consumer,the,callback,that,accepts,matching,jvm,options,param,invalid,line,consumer,a,callback,that,accepts,invalid,jvm,options,throws,ioexception,if,an,i,o,exception,occurs,reading,from,the,buffered,reader;static,void,parse,final,int,java,major,version,final,buffered,reader,br,final,jvm,option,consumer,jvm,option,consumer,final,invalid,line,consumer,invalid,line,consumer,throws,ioexception,int,line,number,0,while,true,final,string,line,br,read,line,line,number,if,line,null,break,if,line,starts,with,continue,if,line,matches,s,continue,final,matcher,matcher,pattern,matcher,line,if,matcher,matches,final,string,start,matcher,group,start,final,string,end,matcher,group,end,if,start,null,jvm,option,consumer,accept,line,else,final,int,lower,try,lower,integer,parse,int,start,catch,final,number,format,exception,e,invalid,line,consumer,accept,line,number,line,continue,final,int,upper,if,matcher,group,range,null,upper,lower,else,if,end,null,upper,integer,else,try,upper,integer,parse,int,end,catch,final,number,format,exception,e,invalid,line,consumer,accept,line,number,line,continue,if,upper,lower,invalid,line,consumer,accept,line,number,line,continue,if,lower,java,major,version,java,major,version,upper,jvm,option,consumer,accept,matcher,group,option,else,invalid,line,consumer,accept,line,number,line
JvmOptionsParser -> static void parse(             final int javaMajorVersion,             final BufferedReader br,             final JvmOptionConsumer jvmOptionConsumer,             final InvalidLineConsumer invalidLineConsumer) throws IOException;1529508649;Parse the line-delimited JVM options from the specified buffered reader for the specified Java major version._Valid JVM options are:_<ul>_<li>_a line starting with a dash is treated as a JVM option that applies to all versions_</li>_<li>_a line starting with a number followed by a colon is treated as a JVM option that applies to the matching Java major version_only_</li>_<li>_a line starting with a number followed by a dash followed by a colon is treated as a JVM option that applies to the matching_Java specified major version and all larger Java major versions_</li>_<li>_a line starting with a number followed by a dash followed by a number followed by a colon is treated as a JVM option that_applies to the specified range of matching Java major versions_</li>_</ul>__For example, if the specified Java major version is 8, the following JVM options will be accepted:_<ul>_<li>_{@code -XX:+PrintGCDateStamps}_</li>_<li>_{@code 8:-XX:+PrintGCDateStamps}_</li>_<li>_{@code 8-:-XX:+PrintGCDateStamps}_</li>_<li>_{@code 7-8:-XX:+PrintGCDateStamps}_</li>_</ul>_and the following JVM options will not be accepted:_<ul>_<li>_{@code 9:-Xlog:age*=trace,gc*,safepoint:file=logs/gc.log:utctime,pid,tags:filecount=32,filesize=64m}_</li>_<li>_{@code 9-:-Xlog:age*=trace,gc*,safepoint:file=logs/gc.log:utctime,pid,tags:filecount=32,filesize=64m}_</li>_<li>_{@code 9-10:-Xlog:age*=trace,gc*,safepoint:file=logs/gc.log:utctime,pid,tags:filecount=32,filesize=64m}_</li>_</ul>__If the version syntax specified on a line matches the specified JVM options, the JVM option callback will be invoked with the JVM_option. If the line does not match the specified syntax for the JVM options, the invalid line callback will be invoked with the_contents of the entire line.__@param javaMajorVersion the Java major version to match JVM options against_@param br the buffered reader to read line-delimited JVM options from_@param jvmOptionConsumer the callback that accepts matching JVM options_@param invalidLineConsumer a callback that accepts invalid JVM options_@throws IOException if an I/O exception occurs reading from the buffered reader;static void parse(_            final int javaMajorVersion,_            final BufferedReader br,_            final JvmOptionConsumer jvmOptionConsumer,_            final InvalidLineConsumer invalidLineConsumer) throws IOException {_        int lineNumber = 0__        while (true) {_            final String line = br.readLine()__            lineNumber++__            if (line == null) {_                break__            }_            if (line.startsWith("#")) {_                _                continue__            }_            if (line.matches("\\s*")) {_                _                continue__            }_            final Matcher matcher = PATTERN.matcher(line)__            if (matcher.matches()) {_                final String start = matcher.group("start")__                final String end = matcher.group("end")__                if (start == null) {_                    _                    jvmOptionConsumer.accept(line)__                } else {_                    final int lower__                    try {_                        lower = Integer.parseInt(start)__                    } catch (final NumberFormatException e) {_                        invalidLineConsumer.accept(lineNumber, line)__                        continue__                    }_                    final int upper__                    if (matcher.group("range") == null) {_                        _                        upper = lower__                    } else if (end == null) {_                        _                        upper = Integer.MAX_VALUE__                    } else {_                        _                        try {_                            upper = Integer.parseInt(end)__                        } catch (final NumberFormatException e) {_                            invalidLineConsumer.accept(lineNumber, line)__                            continue__                        }_                        if (upper < lower) {_                            invalidLineConsumer.accept(lineNumber, line)__                            continue__                        }_                    }_                    if (lower <= javaMajorVersion && javaMajorVersion <= upper) {_                        jvmOptionConsumer.accept(matcher.group("option"))__                    }_                }_            } else {_                invalidLineConsumer.accept(lineNumber, line)__            }_        }_    };parse,the,line,delimited,jvm,options,from,the,specified,buffered,reader,for,the,specified,java,major,version,valid,jvm,options,are,ul,li,a,line,starting,with,a,dash,is,treated,as,a,jvm,option,that,applies,to,all,versions,li,li,a,line,starting,with,a,number,followed,by,a,colon,is,treated,as,a,jvm,option,that,applies,to,the,matching,java,major,version,only,li,li,a,line,starting,with,a,number,followed,by,a,dash,followed,by,a,colon,is,treated,as,a,jvm,option,that,applies,to,the,matching,java,specified,major,version,and,all,larger,java,major,versions,li,li,a,line,starting,with,a,number,followed,by,a,dash,followed,by,a,number,followed,by,a,colon,is,treated,as,a,jvm,option,that,applies,to,the,specified,range,of,matching,java,major,versions,li,ul,for,example,if,the,specified,java,major,version,is,8,the,following,jvm,options,will,be,accepted,ul,li,code,xx,print,gcdate,stamps,li,li,code,8,xx,print,gcdate,stamps,li,li,code,8,xx,print,gcdate,stamps,li,li,code,7,8,xx,print,gcdate,stamps,li,ul,and,the,following,jvm,options,will,not,be,accepted,ul,li,code,9,xlog,age,trace,gc,safepoint,file,logs,gc,log,utctime,pid,tags,filecount,32,filesize,64m,li,li,code,9,xlog,age,trace,gc,safepoint,file,logs,gc,log,utctime,pid,tags,filecount,32,filesize,64m,li,li,code,9,10,xlog,age,trace,gc,safepoint,file,logs,gc,log,utctime,pid,tags,filecount,32,filesize,64m,li,ul,if,the,version,syntax,specified,on,a,line,matches,the,specified,jvm,options,the,jvm,option,callback,will,be,invoked,with,the,jvm,option,if,the,line,does,not,match,the,specified,syntax,for,the,jvm,options,the,invalid,line,callback,will,be,invoked,with,the,contents,of,the,entire,line,param,java,major,version,the,java,major,version,to,match,jvm,options,against,param,br,the,buffered,reader,to,read,line,delimited,jvm,options,from,param,jvm,option,consumer,the,callback,that,accepts,matching,jvm,options,param,invalid,line,consumer,a,callback,that,accepts,invalid,jvm,options,throws,ioexception,if,an,i,o,exception,occurs,reading,from,the,buffered,reader;static,void,parse,final,int,java,major,version,final,buffered,reader,br,final,jvm,option,consumer,jvm,option,consumer,final,invalid,line,consumer,invalid,line,consumer,throws,ioexception,int,line,number,0,while,true,final,string,line,br,read,line,line,number,if,line,null,break,if,line,starts,with,continue,if,line,matches,s,continue,final,matcher,matcher,pattern,matcher,line,if,matcher,matches,final,string,start,matcher,group,start,final,string,end,matcher,group,end,if,start,null,jvm,option,consumer,accept,line,else,final,int,lower,try,lower,integer,parse,int,start,catch,final,number,format,exception,e,invalid,line,consumer,accept,line,number,line,continue,final,int,upper,if,matcher,group,range,null,upper,lower,else,if,end,null,upper,integer,else,try,upper,integer,parse,int,end,catch,final,number,format,exception,e,invalid,line,consumer,accept,line,number,line,continue,if,upper,lower,invalid,line,consumer,accept,line,number,line,continue,if,lower,java,major,version,java,major,version,upper,jvm,option,consumer,accept,matcher,group,option,else,invalid,line,consumer,accept,line,number,line
JvmOptionsParser -> static void parse(             final int javaMajorVersion,             final BufferedReader br,             final JvmOptionConsumer jvmOptionConsumer,             final InvalidLineConsumer invalidLineConsumer) throws IOException;1539615817;Parse the line-delimited JVM options from the specified buffered reader for the specified Java major version._Valid JVM options are:_<ul>_<li>_a line starting with a dash is treated as a JVM option that applies to all versions_</li>_<li>_a line starting with a number followed by a colon is treated as a JVM option that applies to the matching Java major version_only_</li>_<li>_a line starting with a number followed by a dash followed by a colon is treated as a JVM option that applies to the matching_Java specified major version and all larger Java major versions_</li>_<li>_a line starting with a number followed by a dash followed by a number followed by a colon is treated as a JVM option that_applies to the specified range of matching Java major versions_</li>_</ul>__For example, if the specified Java major version is 8, the following JVM options will be accepted:_<ul>_<li>_{@code -XX:+PrintGCDateStamps}_</li>_<li>_{@code 8:-XX:+PrintGCDateStamps}_</li>_<li>_{@code 8-:-XX:+PrintGCDateStamps}_</li>_<li>_{@code 7-8:-XX:+PrintGCDateStamps}_</li>_</ul>_and the following JVM options will not be accepted:_<ul>_<li>_{@code 9:-Xlog:age*=trace,gc*,safepoint:file=logs/gc.log:utctime,pid,tags:filecount=32,filesize=64m}_</li>_<li>_{@code 9-:-Xlog:age*=trace,gc*,safepoint:file=logs/gc.log:utctime,pid,tags:filecount=32,filesize=64m}_</li>_<li>_{@code 9-10:-Xlog:age*=trace,gc*,safepoint:file=logs/gc.log:utctime,pid,tags:filecount=32,filesize=64m}_</li>_</ul>__If the version syntax specified on a line matches the specified JVM options, the JVM option callback will be invoked with the JVM_option. If the line does not match the specified syntax for the JVM options, the invalid line callback will be invoked with the_contents of the entire line.__@param javaMajorVersion the Java major version to match JVM options against_@param br the buffered reader to read line-delimited JVM options from_@param jvmOptionConsumer the callback that accepts matching JVM options_@param invalidLineConsumer a callback that accepts invalid JVM options_@throws IOException if an I/O exception occurs reading from the buffered reader;static void parse(_            final int javaMajorVersion,_            final BufferedReader br,_            final JvmOptionConsumer jvmOptionConsumer,_            final InvalidLineConsumer invalidLineConsumer) throws IOException {_        int lineNumber = 0__        while (true) {_            final String line = br.readLine()__            lineNumber++__            if (line == null) {_                break__            }_            if (line.startsWith("#")) {_                _                continue__            }_            if (line.matches("\\s*")) {_                _                continue__            }_            final Matcher matcher = PATTERN.matcher(line)__            if (matcher.matches()) {_                final String start = matcher.group("start")__                final String end = matcher.group("end")__                if (start == null) {_                    _                    jvmOptionConsumer.accept(line)__                } else {_                    final int lower__                    try {_                        lower = Integer.parseInt(start)__                    } catch (final NumberFormatException e) {_                        invalidLineConsumer.accept(lineNumber, line)__                        continue__                    }_                    final int upper__                    if (matcher.group("range") == null) {_                        _                        upper = lower__                    } else if (end == null) {_                        _                        upper = Integer.MAX_VALUE__                    } else {_                        _                        try {_                            upper = Integer.parseInt(end)__                        } catch (final NumberFormatException e) {_                            invalidLineConsumer.accept(lineNumber, line)__                            continue__                        }_                        if (upper < lower) {_                            invalidLineConsumer.accept(lineNumber, line)__                            continue__                        }_                    }_                    if (lower <= javaMajorVersion && javaMajorVersion <= upper) {_                        jvmOptionConsumer.accept(matcher.group("option"))__                    }_                }_            } else {_                invalidLineConsumer.accept(lineNumber, line)__            }_        }_    };parse,the,line,delimited,jvm,options,from,the,specified,buffered,reader,for,the,specified,java,major,version,valid,jvm,options,are,ul,li,a,line,starting,with,a,dash,is,treated,as,a,jvm,option,that,applies,to,all,versions,li,li,a,line,starting,with,a,number,followed,by,a,colon,is,treated,as,a,jvm,option,that,applies,to,the,matching,java,major,version,only,li,li,a,line,starting,with,a,number,followed,by,a,dash,followed,by,a,colon,is,treated,as,a,jvm,option,that,applies,to,the,matching,java,specified,major,version,and,all,larger,java,major,versions,li,li,a,line,starting,with,a,number,followed,by,a,dash,followed,by,a,number,followed,by,a,colon,is,treated,as,a,jvm,option,that,applies,to,the,specified,range,of,matching,java,major,versions,li,ul,for,example,if,the,specified,java,major,version,is,8,the,following,jvm,options,will,be,accepted,ul,li,code,xx,print,gcdate,stamps,li,li,code,8,xx,print,gcdate,stamps,li,li,code,8,xx,print,gcdate,stamps,li,li,code,7,8,xx,print,gcdate,stamps,li,ul,and,the,following,jvm,options,will,not,be,accepted,ul,li,code,9,xlog,age,trace,gc,safepoint,file,logs,gc,log,utctime,pid,tags,filecount,32,filesize,64m,li,li,code,9,xlog,age,trace,gc,safepoint,file,logs,gc,log,utctime,pid,tags,filecount,32,filesize,64m,li,li,code,9,10,xlog,age,trace,gc,safepoint,file,logs,gc,log,utctime,pid,tags,filecount,32,filesize,64m,li,ul,if,the,version,syntax,specified,on,a,line,matches,the,specified,jvm,options,the,jvm,option,callback,will,be,invoked,with,the,jvm,option,if,the,line,does,not,match,the,specified,syntax,for,the,jvm,options,the,invalid,line,callback,will,be,invoked,with,the,contents,of,the,entire,line,param,java,major,version,the,java,major,version,to,match,jvm,options,against,param,br,the,buffered,reader,to,read,line,delimited,jvm,options,from,param,jvm,option,consumer,the,callback,that,accepts,matching,jvm,options,param,invalid,line,consumer,a,callback,that,accepts,invalid,jvm,options,throws,ioexception,if,an,i,o,exception,occurs,reading,from,the,buffered,reader;static,void,parse,final,int,java,major,version,final,buffered,reader,br,final,jvm,option,consumer,jvm,option,consumer,final,invalid,line,consumer,invalid,line,consumer,throws,ioexception,int,line,number,0,while,true,final,string,line,br,read,line,line,number,if,line,null,break,if,line,starts,with,continue,if,line,matches,s,continue,final,matcher,matcher,pattern,matcher,line,if,matcher,matches,final,string,start,matcher,group,start,final,string,end,matcher,group,end,if,start,null,jvm,option,consumer,accept,line,else,final,int,lower,try,lower,integer,parse,int,start,catch,final,number,format,exception,e,invalid,line,consumer,accept,line,number,line,continue,final,int,upper,if,matcher,group,range,null,upper,lower,else,if,end,null,upper,integer,else,try,upper,integer,parse,int,end,catch,final,number,format,exception,e,invalid,line,consumer,accept,line,number,line,continue,if,upper,lower,invalid,line,consumer,accept,line,number,line,continue,if,lower,java,major,version,java,major,version,upper,jvm,option,consumer,accept,matcher,group,option,else,invalid,line,consumer,accept,line,number,line
JvmOptionsParser -> static String spaceDelimitJvmOptions(final List<String> jvmOptions);1524684173;Delimits the specified JVM options by spaces.__@param jvmOptions the JVM options_@return a single-line string containing the specified JVM options in the order they appear delimited by spaces;static String spaceDelimitJvmOptions(final List<String> jvmOptions) {_        final StringBuilder spaceDelimitedJvmOptionsBuilder = new StringBuilder()__        final Iterator<String> it = jvmOptions.iterator()__        while (it.hasNext()) {_            spaceDelimitedJvmOptionsBuilder.append(it.next())__            if (it.hasNext()) {_                spaceDelimitedJvmOptionsBuilder.append(" ")__            }_        }_        return spaceDelimitedJvmOptionsBuilder.toString()__    };delimits,the,specified,jvm,options,by,spaces,param,jvm,options,the,jvm,options,return,a,single,line,string,containing,the,specified,jvm,options,in,the,order,they,appear,delimited,by,spaces;static,string,space,delimit,jvm,options,final,list,string,jvm,options,final,string,builder,space,delimited,jvm,options,builder,new,string,builder,final,iterator,string,it,jvm,options,iterator,while,it,has,next,space,delimited,jvm,options,builder,append,it,next,if,it,has,next,space,delimited,jvm,options,builder,append,return,space,delimited,jvm,options,builder,to,string
JvmOptionsParser -> static String spaceDelimitJvmOptions(final List<String> jvmOptions);1528706846;Delimits the specified JVM options by spaces.__@param jvmOptions the JVM options_@return a single-line string containing the specified JVM options in the order they appear delimited by spaces;static String spaceDelimitJvmOptions(final List<String> jvmOptions) {_        final StringBuilder spaceDelimitedJvmOptionsBuilder = new StringBuilder()__        final Iterator<String> it = jvmOptions.iterator()__        while (it.hasNext()) {_            spaceDelimitedJvmOptionsBuilder.append(it.next())__            if (it.hasNext()) {_                spaceDelimitedJvmOptionsBuilder.append(" ")__            }_        }_        return spaceDelimitedJvmOptionsBuilder.toString()__    };delimits,the,specified,jvm,options,by,spaces,param,jvm,options,the,jvm,options,return,a,single,line,string,containing,the,specified,jvm,options,in,the,order,they,appear,delimited,by,spaces;static,string,space,delimit,jvm,options,final,list,string,jvm,options,final,string,builder,space,delimited,jvm,options,builder,new,string,builder,final,iterator,string,it,jvm,options,iterator,while,it,has,next,space,delimited,jvm,options,builder,append,it,next,if,it,has,next,space,delimited,jvm,options,builder,append,return,space,delimited,jvm,options,builder,to,string
JvmOptionsParser -> static String spaceDelimitJvmOptions(final List<String> jvmOptions);1529508649;Delimits the specified JVM options by spaces.__@param jvmOptions the JVM options_@return a single-line string containing the specified JVM options in the order they appear delimited by spaces;static String spaceDelimitJvmOptions(final List<String> jvmOptions) {_        final StringBuilder spaceDelimitedJvmOptionsBuilder = new StringBuilder()__        final Iterator<String> it = jvmOptions.iterator()__        while (it.hasNext()) {_            spaceDelimitedJvmOptionsBuilder.append(it.next())__            if (it.hasNext()) {_                spaceDelimitedJvmOptionsBuilder.append(" ")__            }_        }_        return spaceDelimitedJvmOptionsBuilder.toString()__    };delimits,the,specified,jvm,options,by,spaces,param,jvm,options,the,jvm,options,return,a,single,line,string,containing,the,specified,jvm,options,in,the,order,they,appear,delimited,by,spaces;static,string,space,delimit,jvm,options,final,list,string,jvm,options,final,string,builder,space,delimited,jvm,options,builder,new,string,builder,final,iterator,string,it,jvm,options,iterator,while,it,has,next,space,delimited,jvm,options,builder,append,it,next,if,it,has,next,space,delimited,jvm,options,builder,append,return,space,delimited,jvm,options,builder,to,string
JvmOptionsParser -> static String spaceDelimitJvmOptions(final List<String> jvmOptions);1539615817;Delimits the specified JVM options by spaces.__@param jvmOptions the JVM options_@return a single-line string containing the specified JVM options in the order they appear delimited by spaces;static String spaceDelimitJvmOptions(final List<String> jvmOptions) {_        final StringBuilder spaceDelimitedJvmOptionsBuilder = new StringBuilder()__        final Iterator<String> it = jvmOptions.iterator()__        while (it.hasNext()) {_            spaceDelimitedJvmOptionsBuilder.append(it.next())__            if (it.hasNext()) {_                spaceDelimitedJvmOptionsBuilder.append(" ")__            }_        }_        return spaceDelimitedJvmOptionsBuilder.toString()__    };delimits,the,specified,jvm,options,by,spaces,param,jvm,options,the,jvm,options,return,a,single,line,string,containing,the,specified,jvm,options,in,the,order,they,appear,delimited,by,spaces;static,string,space,delimit,jvm,options,final,list,string,jvm,options,final,string,builder,space,delimited,jvm,options,builder,new,string,builder,final,iterator,string,it,jvm,options,iterator,while,it,has,next,space,delimited,jvm,options,builder,append,it,next,if,it,has,next,space,delimited,jvm,options,builder,append,return,space,delimited,jvm,options,builder,to,string
JvmOptionsParser -> public static void main(final String[] args) throws IOException;1524684173;The main entry point. The exit code is 0 if the JVM options were successfully parsed, otherwise the exit code is 1. If an improperly_formatted line is discovered, the line is output to standard error.__@param args the args to the program which should consist of a single option, the path to the JVM options;public static void main(final String[] args) throws IOException {_        if (args.length != 1) {_            throw new IllegalArgumentException("expected one argument specifying path to jvm.options but was " + Arrays.toString(args))__        }_        final List<String> jvmOptions = new ArrayList<>()__        final SortedMap<Integer, String> invalidLines = new TreeMap<>()__        try (InputStream is = Files.newInputStream(Paths.get(args[0]))__             Reader reader = new InputStreamReader(is, Charset.forName("UTF-8"))__             BufferedReader br = new BufferedReader(reader)) {_            parse(_                    JavaVersion.majorVersion(JavaVersion.CURRENT),_                    br,_                    new JvmOptionConsumer() {_                        @Override_                        public void accept(final String jvmOption) {_                            jvmOptions.add(jvmOption)__                        }_                    },_                    new InvalidLineConsumer() {_                        @Override_                        public void accept(final int lineNumber, final String line) {_                            invalidLines.put(lineNumber, line)__                        }_                    })__        }__        if (invalidLines.isEmpty()) {_            final String spaceDelimitedJvmOptions = spaceDelimitJvmOptions(jvmOptions)__            Launchers.outPrintln(spaceDelimitedJvmOptions)__            Launchers.exit(0)__        } else {_            final String errorMessage = String.format(_                    Locale.ROOT,_                    "encountered [%d] error%s parsing [%s]",_                    invalidLines.size(),_                    invalidLines.size() == 1 ? "" : "s",_                    args[0])__            Launchers.errPrintln(errorMessage)__            int count = 0__            for (final Map.Entry<Integer, String> entry : invalidLines.entrySet()) {_                count++__                final String message = String.format(_                        Locale.ROOT,_                        "[%d]: encountered improperly formatted JVM option line [%s] on line number [%d]",_                        count,_                        entry.getValue(),_                        entry.getKey())__                Launchers.errPrintln(message)__            }_            Launchers.exit(1)__        }_    };the,main,entry,point,the,exit,code,is,0,if,the,jvm,options,were,successfully,parsed,otherwise,the,exit,code,is,1,if,an,improperly,formatted,line,is,discovered,the,line,is,output,to,standard,error,param,args,the,args,to,the,program,which,should,consist,of,a,single,option,the,path,to,the,jvm,options;public,static,void,main,final,string,args,throws,ioexception,if,args,length,1,throw,new,illegal,argument,exception,expected,one,argument,specifying,path,to,jvm,options,but,was,arrays,to,string,args,final,list,string,jvm,options,new,array,list,final,sorted,map,integer,string,invalid,lines,new,tree,map,try,input,stream,is,files,new,input,stream,paths,get,args,0,reader,reader,new,input,stream,reader,is,charset,for,name,utf,8,buffered,reader,br,new,buffered,reader,reader,parse,java,version,major,version,java,version,current,br,new,jvm,option,consumer,override,public,void,accept,final,string,jvm,option,jvm,options,add,jvm,option,new,invalid,line,consumer,override,public,void,accept,final,int,line,number,final,string,line,invalid,lines,put,line,number,line,if,invalid,lines,is,empty,final,string,space,delimited,jvm,options,space,delimit,jvm,options,jvm,options,launchers,out,println,space,delimited,jvm,options,launchers,exit,0,else,final,string,error,message,string,format,locale,root,encountered,d,error,s,parsing,s,invalid,lines,size,invalid,lines,size,1,s,args,0,launchers,err,println,error,message,int,count,0,for,final,map,entry,integer,string,entry,invalid,lines,entry,set,count,final,string,message,string,format,locale,root,d,encountered,improperly,formatted,jvm,option,line,s,on,line,number,d,count,entry,get,value,entry,get,key,launchers,err,println,message,launchers,exit,1
JvmOptionsParser -> public static void main(final String[] args) throws IOException;1528706846;The main entry point. The exit code is 0 if the JVM options were successfully parsed, otherwise the exit code is 1. If an improperly_formatted line is discovered, the line is output to standard error.__@param args the args to the program which should consist of a single option, the path to the JVM options;public static void main(final String[] args) throws IOException {_        if (args.length != 1) {_            throw new IllegalArgumentException("expected one argument specifying path to jvm.options but was " + Arrays.toString(args))__        }_        final List<String> jvmOptions = new ArrayList<>()__        final SortedMap<Integer, String> invalidLines = new TreeMap<>()__        try (InputStream is = Files.newInputStream(Paths.get(args[0]))__             Reader reader = new InputStreamReader(is, Charset.forName("UTF-8"))__             BufferedReader br = new BufferedReader(reader)) {_            parse(_                    JavaVersion.majorVersion(JavaVersion.CURRENT),_                    br,_                    new JvmOptionConsumer() {_                        @Override_                        public void accept(final String jvmOption) {_                            jvmOptions.add(jvmOption)__                        }_                    },_                    new InvalidLineConsumer() {_                        @Override_                        public void accept(final int lineNumber, final String line) {_                            invalidLines.put(lineNumber, line)__                        }_                    })__        }__        if (invalidLines.isEmpty()) {_            final String spaceDelimitedJvmOptions = spaceDelimitJvmOptions(jvmOptions)__            Launchers.outPrintln(spaceDelimitedJvmOptions)__            Launchers.exit(0)__        } else {_            final String errorMessage = String.format(_                    Locale.ROOT,_                    "encountered [%d] error%s parsing [%s]",_                    invalidLines.size(),_                    invalidLines.size() == 1 ? "" : "s",_                    args[0])__            Launchers.errPrintln(errorMessage)__            int count = 0__            for (final Map.Entry<Integer, String> entry : invalidLines.entrySet()) {_                count++__                final String message = String.format(_                        Locale.ROOT,_                        "[%d]: encountered improperly formatted JVM option line [%s] on line number [%d]",_                        count,_                        entry.getValue(),_                        entry.getKey())__                Launchers.errPrintln(message)__            }_            Launchers.exit(1)__        }_    };the,main,entry,point,the,exit,code,is,0,if,the,jvm,options,were,successfully,parsed,otherwise,the,exit,code,is,1,if,an,improperly,formatted,line,is,discovered,the,line,is,output,to,standard,error,param,args,the,args,to,the,program,which,should,consist,of,a,single,option,the,path,to,the,jvm,options;public,static,void,main,final,string,args,throws,ioexception,if,args,length,1,throw,new,illegal,argument,exception,expected,one,argument,specifying,path,to,jvm,options,but,was,arrays,to,string,args,final,list,string,jvm,options,new,array,list,final,sorted,map,integer,string,invalid,lines,new,tree,map,try,input,stream,is,files,new,input,stream,paths,get,args,0,reader,reader,new,input,stream,reader,is,charset,for,name,utf,8,buffered,reader,br,new,buffered,reader,reader,parse,java,version,major,version,java,version,current,br,new,jvm,option,consumer,override,public,void,accept,final,string,jvm,option,jvm,options,add,jvm,option,new,invalid,line,consumer,override,public,void,accept,final,int,line,number,final,string,line,invalid,lines,put,line,number,line,if,invalid,lines,is,empty,final,string,space,delimited,jvm,options,space,delimit,jvm,options,jvm,options,launchers,out,println,space,delimited,jvm,options,launchers,exit,0,else,final,string,error,message,string,format,locale,root,encountered,d,error,s,parsing,s,invalid,lines,size,invalid,lines,size,1,s,args,0,launchers,err,println,error,message,int,count,0,for,final,map,entry,integer,string,entry,invalid,lines,entry,set,count,final,string,message,string,format,locale,root,d,encountered,improperly,formatted,jvm,option,line,s,on,line,number,d,count,entry,get,value,entry,get,key,launchers,err,println,message,launchers,exit,1
JvmOptionsParser -> public static void main(final String[] args) throws IOException;1529508649;The main entry point. The exit code is 0 if the JVM options were successfully parsed, otherwise the exit code is 1. If an improperly_formatted line is discovered, the line is output to standard error.__@param args the args to the program which should consist of a single option, the path to the JVM options;public static void main(final String[] args) throws IOException {_        if (args.length != 1) {_            throw new IllegalArgumentException("expected one argument specifying path to jvm.options but was " + Arrays.toString(args))__        }_        final List<String> jvmOptions = new ArrayList<>()__        final SortedMap<Integer, String> invalidLines = new TreeMap<>()__        try (InputStream is = Files.newInputStream(Paths.get(args[0]))__             Reader reader = new InputStreamReader(is, Charset.forName("UTF-8"))__             BufferedReader br = new BufferedReader(reader)) {_            parse(_                    JavaVersion.majorVersion(JavaVersion.CURRENT),_                    br,_                    new JvmOptionConsumer() {_                        @Override_                        public void accept(final String jvmOption) {_                            jvmOptions.add(jvmOption)__                        }_                    },_                    new InvalidLineConsumer() {_                        @Override_                        public void accept(final int lineNumber, final String line) {_                            invalidLines.put(lineNumber, line)__                        }_                    })__        }__        if (invalidLines.isEmpty()) {_            List<String> ergonomicJvmOptions = JvmErgonomics.choose(jvmOptions)__            jvmOptions.addAll(ergonomicJvmOptions)__            final String spaceDelimitedJvmOptions = spaceDelimitJvmOptions(jvmOptions)__            Launchers.outPrintln(spaceDelimitedJvmOptions)__            Launchers.exit(0)__        } else {_            final String errorMessage = String.format(_                    Locale.ROOT,_                    "encountered [%d] error%s parsing [%s]",_                    invalidLines.size(),_                    invalidLines.size() == 1 ? "" : "s",_                    args[0])__            Launchers.errPrintln(errorMessage)__            int count = 0__            for (final Map.Entry<Integer, String> entry : invalidLines.entrySet()) {_                count++__                final String message = String.format(_                        Locale.ROOT,_                        "[%d]: encountered improperly formatted JVM option line [%s] on line number [%d]",_                        count,_                        entry.getValue(),_                        entry.getKey())__                Launchers.errPrintln(message)__            }_            Launchers.exit(1)__        }_    };the,main,entry,point,the,exit,code,is,0,if,the,jvm,options,were,successfully,parsed,otherwise,the,exit,code,is,1,if,an,improperly,formatted,line,is,discovered,the,line,is,output,to,standard,error,param,args,the,args,to,the,program,which,should,consist,of,a,single,option,the,path,to,the,jvm,options;public,static,void,main,final,string,args,throws,ioexception,if,args,length,1,throw,new,illegal,argument,exception,expected,one,argument,specifying,path,to,jvm,options,but,was,arrays,to,string,args,final,list,string,jvm,options,new,array,list,final,sorted,map,integer,string,invalid,lines,new,tree,map,try,input,stream,is,files,new,input,stream,paths,get,args,0,reader,reader,new,input,stream,reader,is,charset,for,name,utf,8,buffered,reader,br,new,buffered,reader,reader,parse,java,version,major,version,java,version,current,br,new,jvm,option,consumer,override,public,void,accept,final,string,jvm,option,jvm,options,add,jvm,option,new,invalid,line,consumer,override,public,void,accept,final,int,line,number,final,string,line,invalid,lines,put,line,number,line,if,invalid,lines,is,empty,list,string,ergonomic,jvm,options,jvm,ergonomics,choose,jvm,options,jvm,options,add,all,ergonomic,jvm,options,final,string,space,delimited,jvm,options,space,delimit,jvm,options,jvm,options,launchers,out,println,space,delimited,jvm,options,launchers,exit,0,else,final,string,error,message,string,format,locale,root,encountered,d,error,s,parsing,s,invalid,lines,size,invalid,lines,size,1,s,args,0,launchers,err,println,error,message,int,count,0,for,final,map,entry,integer,string,entry,invalid,lines,entry,set,count,final,string,message,string,format,locale,root,d,encountered,improperly,formatted,jvm,option,line,s,on,line,number,d,count,entry,get,value,entry,get,key,launchers,err,println,message,launchers,exit,1
JvmOptionsParser -> public static void main(final String[] args) throws IOException;1539615817;The main entry point. The exit code is 0 if the JVM options were successfully parsed, otherwise the exit code is 1. If an improperly_formatted line is discovered, the line is output to standard error.__@param args the args to the program which should consist of a single option, the path to the JVM options;public static void main(final String[] args) throws IOException {_        if (args.length != 1) {_            throw new IllegalArgumentException("expected one argument specifying path to jvm.options but was " + Arrays.toString(args))__        }_        final List<String> jvmOptions = new ArrayList<>()__        final SortedMap<Integer, String> invalidLines = new TreeMap<>()__        try (InputStream is = Files.newInputStream(Paths.get(args[0]))__             Reader reader = new InputStreamReader(is, Charset.forName("UTF-8"))__             BufferedReader br = new BufferedReader(reader)) {_            parse(_                    JavaVersion.majorVersion(JavaVersion.CURRENT),_                    br,_                    new JvmOptionConsumer() {_                        @Override_                        public void accept(final String jvmOption) {_                            jvmOptions.add(jvmOption)__                        }_                    },_                    new InvalidLineConsumer() {_                        @Override_                        public void accept(final int lineNumber, final String line) {_                            invalidLines.put(lineNumber, line)__                        }_                    })__        }__        if (invalidLines.isEmpty()) {_            List<String> ergonomicJvmOptions = JvmErgonomics.choose(jvmOptions)__            jvmOptions.addAll(ergonomicJvmOptions)__            final String spaceDelimitedJvmOptions = spaceDelimitJvmOptions(jvmOptions)__            Launchers.outPrintln(spaceDelimitedJvmOptions)__            Launchers.exit(0)__        } else {_            final String errorMessage = String.format(_                    Locale.ROOT,_                    "encountered [%d] error%s parsing [%s]",_                    invalidLines.size(),_                    invalidLines.size() == 1 ? "" : "s",_                    args[0])__            Launchers.errPrintln(errorMessage)__            int count = 0__            for (final Map.Entry<Integer, String> entry : invalidLines.entrySet()) {_                count++__                final String message = String.format(_                        Locale.ROOT,_                        "[%d]: encountered improperly formatted JVM option line [%s] on line number [%d]",_                        count,_                        entry.getValue(),_                        entry.getKey())__                Launchers.errPrintln(message)__            }_            Launchers.exit(1)__        }_    };the,main,entry,point,the,exit,code,is,0,if,the,jvm,options,were,successfully,parsed,otherwise,the,exit,code,is,1,if,an,improperly,formatted,line,is,discovered,the,line,is,output,to,standard,error,param,args,the,args,to,the,program,which,should,consist,of,a,single,option,the,path,to,the,jvm,options;public,static,void,main,final,string,args,throws,ioexception,if,args,length,1,throw,new,illegal,argument,exception,expected,one,argument,specifying,path,to,jvm,options,but,was,arrays,to,string,args,final,list,string,jvm,options,new,array,list,final,sorted,map,integer,string,invalid,lines,new,tree,map,try,input,stream,is,files,new,input,stream,paths,get,args,0,reader,reader,new,input,stream,reader,is,charset,for,name,utf,8,buffered,reader,br,new,buffered,reader,reader,parse,java,version,major,version,java,version,current,br,new,jvm,option,consumer,override,public,void,accept,final,string,jvm,option,jvm,options,add,jvm,option,new,invalid,line,consumer,override,public,void,accept,final,int,line,number,final,string,line,invalid,lines,put,line,number,line,if,invalid,lines,is,empty,list,string,ergonomic,jvm,options,jvm,ergonomics,choose,jvm,options,jvm,options,add,all,ergonomic,jvm,options,final,string,space,delimited,jvm,options,space,delimit,jvm,options,jvm,options,launchers,out,println,space,delimited,jvm,options,launchers,exit,0,else,final,string,error,message,string,format,locale,root,encountered,d,error,s,parsing,s,invalid,lines,size,invalid,lines,size,1,s,args,0,launchers,err,println,error,message,int,count,0,for,final,map,entry,integer,string,entry,invalid,lines,entry,set,count,final,string,message,string,format,locale,root,d,encountered,improperly,formatted,jvm,option,line,s,on,line,number,d,count,entry,get,value,entry,get,key,launchers,err,println,message,launchers,exit,1
