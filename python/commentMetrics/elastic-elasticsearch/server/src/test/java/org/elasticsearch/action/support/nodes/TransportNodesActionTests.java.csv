commented;modifiers;parameterAmount;loc;comment;code
false;public;0;10;;public void testRequestIsSentToEachNode() throws Exception {     TransportNodesAction action = getTestTransportNodesAction().     TestNodesRequest request = new TestNodesRequest().     PlainActionFuture<TestNodesResponse> listener = new PlainActionFuture<>().     action.new AsyncAction(null, request, listener).start().     Map<String, List<CapturingTransport.CapturedRequest>> capturedRequests = transport.getCapturedRequestsByTargetNodeAndClear().     int numNodes = clusterService.state().getNodes().getSize().     // check a request was sent to the right number of nodes     assertEquals(numNodes, capturedRequests.size()). }
false;public;0;19;;public void testNodesSelectors() {     TransportNodesAction action = getTestTransportNodesAction().     int numSelectors = randomIntBetween(1, 5).     Set<String> nodeSelectors = new HashSet<>().     for (int i = 0. i < numSelectors. i++) {         nodeSelectors.add(randomFrom(NodeSelector.values()).selector).     }     int numNodeIds = randomIntBetween(0, 3).     String[] nodeIds = clusterService.state().nodes().getNodes().keys().toArray(String.class).     for (int i = 0. i < numNodeIds. i++) {         String nodeId = randomFrom(nodeIds).         nodeSelectors.add(nodeId).     }     String[] finalNodesIds = nodeSelectors.toArray(new String[nodeSelectors.size()]).     TestNodesRequest request = new TestNodesRequest(finalNodesIds).     action.new AsyncAction(null, request, new PlainActionFuture<>()).start().     Map<String, List<CapturingTransport.CapturedRequest>> capturedRequests = transport.getCapturedRequestsByTargetNodeAndClear().     assertEquals(clusterService.state().nodes().resolveNodes(finalNodesIds).length, capturedRequests.size()). }
false;public;0;4;;public void testNewResponseNullArray() {     TransportNodesAction action = getTestTransportNodesAction().     expectThrows(NullPointerException.class, () -> action.newResponse(new TestNodesRequest(), null)). }
false;public;0;29;;public void testNewResponse() {     TestTransportNodesAction action = getTestTransportNodesAction().     TestNodesRequest request = new TestNodesRequest().     List<TestNodeResponse> expectedNodeResponses = mockList(TestNodeResponse::new, randomIntBetween(0, 2)).     expectedNodeResponses.add(new TestNodeResponse()).     List<BaseNodeResponse> nodeResponses = new ArrayList<>(expectedNodeResponses).     // This should be ignored:     nodeResponses.add(new OtherNodeResponse()).     List<FailedNodeException> failures = mockList(() -> new FailedNodeException(randomAlphaOfLength(8), randomAlphaOfLength(8), new IllegalStateException(randomAlphaOfLength(8))), randomIntBetween(0, 2)).     List<Object> allResponses = new ArrayList<>(expectedNodeResponses).     allResponses.addAll(failures).     Collections.shuffle(allResponses, random()).     AtomicReferenceArray<?> atomicArray = new AtomicReferenceArray<>(allResponses.toArray()).     TestNodesResponse response = action.newResponse(request, atomicArray).     assertSame(request, response.request).     // note: I shuffled the overall list, so it's not possible to guarantee that it's in the right order     assertTrue(expectedNodeResponses.containsAll(response.getNodes())).     assertTrue(failures.containsAll(response.failures())). }
false;public;0;12;;public void testCustomResolving() throws Exception {     TransportNodesAction action = getDataNodesOnlyTransportNodesAction(transportService).     TestNodesRequest request = new TestNodesRequest(randomBoolean() ? null : generateRandomStringArray(10, 5, false, true)).     PlainActionFuture<TestNodesResponse> listener = new PlainActionFuture<>().     action.new AsyncAction(null, request, listener).start().     Map<String, List<CapturingTransport.CapturedRequest>> capturedRequests = transport.getCapturedRequestsByTargetNodeAndClear().     // check requests were only sent to data nodes     for (String nodeTarget : capturedRequests.keySet()) {         assertTrue(clusterService.state().nodes().get(nodeTarget).isDataNode()).     }     assertEquals(clusterService.state().nodes().getDataNodes().size(), capturedRequests.size()). }
false;private;2;7;;private <T> List<T> mockList(Supplier<T> supplier, int size) {     List<T> failures = new ArrayList<>(size).     for (int i = 0. i < size. ++i) {         failures.add(supplier.get()).     }     return failures. }
false;public,static;0;4;;@BeforeClass public static void startThreadPool() {     THREAD_POOL = new TestThreadPool(TransportBroadcastByNodeActionTests.class.getSimpleName()). }
false;public,static;0;6;;@AfterClass public static void destroyThreadPool() {     ThreadPool.terminate(THREAD_POOL, 30, TimeUnit.SECONDS).     // since static must set to null to be eligible for collection     THREAD_POOL = null. }
false;public;0;29;;@Before public void setUp() throws Exception {     super.setUp().     transport = new CapturingTransport().     clusterService = createClusterService(THREAD_POOL).     transportService = transport.createTransportService(clusterService.getSettings(), THREAD_POOL, TransportService.NOOP_TRANSPORT_INTERCEPTOR, x -> clusterService.localNode(), null, Collections.emptySet()).     transportService.start().     transportService.acceptIncomingRequests().     int numNodes = randomIntBetween(3, 10).     DiscoveryNodes.Builder discoBuilder = DiscoveryNodes.builder().     List<DiscoveryNode> discoveryNodes = new ArrayList<>().     for (int i = 0. i < numNodes. i++) {         Map<String, String> attributes = new HashMap<>().         Set<DiscoveryNode.Role> roles = new HashSet<>(randomSubsetOf(Arrays.asList(DiscoveryNode.Role.values()))).         if (frequently()) {             attributes.put("custom", randomBoolean() ? "match" : randomAlphaOfLengthBetween(3, 5)).         }         final DiscoveryNode node = newNode(i, attributes, roles).         discoBuilder = discoBuilder.add(node).         discoveryNodes.add(node).     }     discoBuilder.localNodeId(randomFrom(discoveryNodes).getId()).     discoBuilder.masterNodeId(randomFrom(discoveryNodes).getId()).     ClusterState.Builder stateBuilder = ClusterState.builder(clusterService.getClusterName()).     stateBuilder.nodes(discoBuilder).     ClusterState clusterState = stateBuilder.build().     setState(clusterService, clusterState). }
false;public;0;6;;@After public void tearDown() throws Exception {     super.tearDown().     clusterService.close().     transport.close(). }
false;public;0;11;;public TestTransportNodesAction getTestTransportNodesAction() {     return new TestTransportNodesAction(THREAD_POOL, clusterService, transportService, new ActionFilters(Collections.emptySet()), TestNodesRequest::new, TestNodeRequest::new, ThreadPool.Names.SAME). }
false;public;1;11;;public DataNodesOnlyTransportNodesAction getDataNodesOnlyTransportNodesAction(TransportService transportService) {     return new DataNodesOnlyTransportNodesAction(THREAD_POOL, clusterService, transportService, new ActionFilters(Collections.emptySet()), TestNodesRequest::new, TestNodeRequest::new, ThreadPool.Names.SAME). }
false;private,static;3;4;;private static DiscoveryNode newNode(int nodeId, Map<String, String> attributes, Set<DiscoveryNode.Role> roles) {     String node = "node_" + nodeId.     return new DiscoveryNode(node, node, buildNewFakeTransportAddress(), attributes, roles, Version.CURRENT). }
false;protected;3;5;;@Override protected TestNodesResponse newResponse(TestNodesRequest request, List<TestNodeResponse> responses, List<FailedNodeException> failures) {     return new TestNodesResponse(clusterService.getClusterName(), request, responses, failures). }
false;protected;2;4;;@Override protected TestNodeRequest newNodeRequest(String nodeId, TestNodesRequest request) {     return new TestNodeRequest(). }
false;protected;0;4;;@Override protected TestNodeResponse newNodeResponse() {     return new TestNodeResponse(). }
false;protected;1;4;;@Override protected TestNodeResponse nodeOperation(TestNodeRequest request) {     return new TestNodeResponse(). }
false;protected;2;4;;@Override protected void resolveRequest(TestNodesRequest request, ClusterState clusterState) {     request.setConcreteNodes(clusterState.nodes().getDataNodes().values().toArray(DiscoveryNode.class)). }
false;protected;1;4;;@Override protected List<TestNodeResponse> readNodesFrom(StreamInput in) throws IOException {     return in.readStreamableList(TestNodeResponse::new). }
false;protected;2;4;;@Override protected void writeNodesTo(StreamOutput out, List<TestNodeResponse> nodes) throws IOException {     out.writeStreamableList(nodes). }
