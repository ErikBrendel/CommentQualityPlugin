# id;timestamp;commentText;codeText;commentWords;codeWords
MapperServiceTests -> public void testForbidMultipleTypesWithConflictingMappings() throws IOException;1524684173;This test checks that the multi-type validation is done before we do any other kind of validation on the mapping that's added,_see https://github.com/elastic/elasticsearch/issues/29313;public void testForbidMultipleTypesWithConflictingMappings() throws IOException {_        String mapping = Strings.toString(XContentFactory.jsonBuilder().startObject().startObject("type")_            .startObject("properties").startObject("field1").field("type", "integer_range").endObject().endObject().endObject().endObject())__        MapperService mapperService = createIndex("test").mapperService()__        mapperService.merge("type", new CompressedXContent(mapping), MergeReason.MAPPING_UPDATE)___        String mapping2 = Strings.toString(XContentFactory.jsonBuilder().startObject().startObject("type2")_            .startObject("properties").startObject("field1").field("type", "integer").endObject().endObject().endObject().endObject())__        IllegalArgumentException e = expectThrows(IllegalArgumentException.class,_            () -> mapperService.merge("type2", new CompressedXContent(mapping2), MergeReason.MAPPING_UPDATE))__        assertThat(e.getMessage(), Matchers.startsWith("Rejecting mapping update to [test] as the final mapping would have more than 1 type: "))__    };this,test,checks,that,the,multi,type,validation,is,done,before,we,do,any,other,kind,of,validation,on,the,mapping,that,s,added,see,https,github,com,elastic,elasticsearch,issues,29313;public,void,test,forbid,multiple,types,with,conflicting,mappings,throws,ioexception,string,mapping,strings,to,string,xcontent,factory,json,builder,start,object,start,object,type,start,object,properties,start,object,field1,field,type,end,object,end,object,end,object,end,object,mapper,service,mapper,service,create,index,test,mapper,service,mapper,service,merge,type,new,compressed,xcontent,mapping,merge,reason,string,mapping2,strings,to,string,xcontent,factory,json,builder,start,object,start,object,type2,start,object,properties,start,object,field1,field,type,integer,end,object,end,object,end,object,end,object,illegal,argument,exception,e,expect,throws,illegal,argument,exception,class,mapper,service,merge,type2,new,compressed,xcontent,mapping2,merge,reason,assert,that,e,get,message,matchers,starts,with,rejecting,mapping,update,to,test,as,the,final,mapping,would,have,more,than,1,type
MapperServiceTests -> public void testForbidMultipleTypesWithConflictingMappings() throws IOException;1528762805;This test checks that the multi-type validation is done before we do any other kind of validation on the mapping that's added,_see https://github.com/elastic/elasticsearch/issues/29313;public void testForbidMultipleTypesWithConflictingMappings() throws IOException {_        String mapping = Strings.toString(XContentFactory.jsonBuilder().startObject().startObject("type")_            .startObject("properties").startObject("field1").field("type", "integer_range").endObject().endObject().endObject().endObject())__        MapperService mapperService = createIndex("test").mapperService()__        mapperService.merge("type", new CompressedXContent(mapping), MergeReason.MAPPING_UPDATE)___        String mapping2 = Strings.toString(XContentFactory.jsonBuilder().startObject().startObject("type2")_            .startObject("properties").startObject("field1").field("type", "integer").endObject().endObject().endObject().endObject())__        IllegalArgumentException e = expectThrows(IllegalArgumentException.class,_            () -> mapperService.merge("type2", new CompressedXContent(mapping2), MergeReason.MAPPING_UPDATE))__        assertThat(e.getMessage(), Matchers.startsWith("Rejecting mapping update to [test] as the final mapping would have more than 1 type: "))__    };this,test,checks,that,the,multi,type,validation,is,done,before,we,do,any,other,kind,of,validation,on,the,mapping,that,s,added,see,https,github,com,elastic,elasticsearch,issues,29313;public,void,test,forbid,multiple,types,with,conflicting,mappings,throws,ioexception,string,mapping,strings,to,string,xcontent,factory,json,builder,start,object,start,object,type,start,object,properties,start,object,field1,field,type,end,object,end,object,end,object,end,object,mapper,service,mapper,service,create,index,test,mapper,service,mapper,service,merge,type,new,compressed,xcontent,mapping,merge,reason,string,mapping2,strings,to,string,xcontent,factory,json,builder,start,object,start,object,type2,start,object,properties,start,object,field1,field,type,integer,end,object,end,object,end,object,end,object,illegal,argument,exception,e,expect,throws,illegal,argument,exception,class,mapper,service,merge,type2,new,compressed,xcontent,mapping2,merge,reason,assert,that,e,get,message,matchers,starts,with,rejecting,mapping,update,to,test,as,the,final,mapping,would,have,more,than,1,type
MapperServiceTests -> public void testForbidMultipleTypesWithConflictingMappings() throws IOException;1531937412;This test checks that the multi-type validation is done before we do any other kind of validation on the mapping that's added,_see https://github.com/elastic/elasticsearch/issues/29313;public void testForbidMultipleTypesWithConflictingMappings() throws IOException {_        String mapping = Strings.toString(XContentFactory.jsonBuilder().startObject().startObject("type")_            .startObject("properties").startObject("field1").field("type", "integer_range").endObject().endObject().endObject().endObject())__        MapperService mapperService = createIndex("test").mapperService()__        mapperService.merge("type", new CompressedXContent(mapping), MergeReason.MAPPING_UPDATE)___        String mapping2 = Strings.toString(XContentFactory.jsonBuilder().startObject().startObject("type2")_            .startObject("properties").startObject("field1").field("type", "integer").endObject().endObject().endObject().endObject())__        IllegalArgumentException e = expectThrows(IllegalArgumentException.class,_            () -> mapperService.merge("type2", new CompressedXContent(mapping2), MergeReason.MAPPING_UPDATE))__        assertThat(e.getMessage(), Matchers.startsWith("Rejecting mapping update to [test] as the final mapping would have more than 1 type: "))__    };this,test,checks,that,the,multi,type,validation,is,done,before,we,do,any,other,kind,of,validation,on,the,mapping,that,s,added,see,https,github,com,elastic,elasticsearch,issues,29313;public,void,test,forbid,multiple,types,with,conflicting,mappings,throws,ioexception,string,mapping,strings,to,string,xcontent,factory,json,builder,start,object,start,object,type,start,object,properties,start,object,field1,field,type,end,object,end,object,end,object,end,object,mapper,service,mapper,service,create,index,test,mapper,service,mapper,service,merge,type,new,compressed,xcontent,mapping,merge,reason,string,mapping2,strings,to,string,xcontent,factory,json,builder,start,object,start,object,type2,start,object,properties,start,object,field1,field,type,integer,end,object,end,object,end,object,end,object,illegal,argument,exception,e,expect,throws,illegal,argument,exception,class,mapper,service,merge,type2,new,compressed,xcontent,mapping2,merge,reason,assert,that,e,get,message,matchers,starts,with,rejecting,mapping,update,to,test,as,the,final,mapping,would,have,more,than,1,type
MapperServiceTests -> public void testForbidMultipleTypesWithConflictingMappings() throws IOException;1532353780;This test checks that the multi-type validation is done before we do any other kind of validation on the mapping that's added,_see https://github.com/elastic/elasticsearch/issues/29313;public void testForbidMultipleTypesWithConflictingMappings() throws IOException {_        String mapping = Strings.toString(XContentFactory.jsonBuilder().startObject().startObject("type")_            .startObject("properties").startObject("field1").field("type", "integer_range").endObject().endObject().endObject().endObject())__        MapperService mapperService = createIndex("test").mapperService()__        mapperService.merge("type", new CompressedXContent(mapping), MergeReason.MAPPING_UPDATE)___        String mapping2 = Strings.toString(XContentFactory.jsonBuilder().startObject().startObject("type2")_            .startObject("properties").startObject("field1").field("type", "integer").endObject().endObject().endObject().endObject())__        IllegalArgumentException e = expectThrows(IllegalArgumentException.class,_            () -> mapperService.merge("type2", new CompressedXContent(mapping2), MergeReason.MAPPING_UPDATE))__        assertThat(e.getMessage(), Matchers.startsWith("Rejecting mapping update to [test] as the final mapping would have more than 1 type: "))__    };this,test,checks,that,the,multi,type,validation,is,done,before,we,do,any,other,kind,of,validation,on,the,mapping,that,s,added,see,https,github,com,elastic,elasticsearch,issues,29313;public,void,test,forbid,multiple,types,with,conflicting,mappings,throws,ioexception,string,mapping,strings,to,string,xcontent,factory,json,builder,start,object,start,object,type,start,object,properties,start,object,field1,field,type,end,object,end,object,end,object,end,object,mapper,service,mapper,service,create,index,test,mapper,service,mapper,service,merge,type,new,compressed,xcontent,mapping,merge,reason,string,mapping2,strings,to,string,xcontent,factory,json,builder,start,object,start,object,type2,start,object,properties,start,object,field1,field,type,integer,end,object,end,object,end,object,end,object,illegal,argument,exception,e,expect,throws,illegal,argument,exception,class,mapper,service,merge,type2,new,compressed,xcontent,mapping2,merge,reason,assert,that,e,get,message,matchers,starts,with,rejecting,mapping,update,to,test,as,the,final,mapping,would,have,more,than,1,type
MapperServiceTests -> public void testForbidMultipleTypesWithConflictingMappings() throws IOException;1535383145;This test checks that the multi-type validation is done before we do any other kind of validation on the mapping that's added,_see https://github.com/elastic/elasticsearch/issues/29313;public void testForbidMultipleTypesWithConflictingMappings() throws IOException {_        String mapping = Strings.toString(XContentFactory.jsonBuilder().startObject().startObject("type")_            .startObject("properties").startObject("field1").field("type", "integer_range").endObject().endObject().endObject().endObject())__        MapperService mapperService = createIndex("test").mapperService()__        mapperService.merge("type", new CompressedXContent(mapping), MergeReason.MAPPING_UPDATE)___        String mapping2 = Strings.toString(XContentFactory.jsonBuilder().startObject().startObject("type2")_            .startObject("properties").startObject("field1").field("type", "integer").endObject().endObject().endObject().endObject())__        IllegalArgumentException e = expectThrows(IllegalArgumentException.class,_            () -> mapperService.merge("type2", new CompressedXContent(mapping2), MergeReason.MAPPING_UPDATE))__        assertThat(e.getMessage(), Matchers.startsWith("Rejecting mapping update to [test] as the final mapping would have more than 1 type: "))__    };this,test,checks,that,the,multi,type,validation,is,done,before,we,do,any,other,kind,of,validation,on,the,mapping,that,s,added,see,https,github,com,elastic,elasticsearch,issues,29313;public,void,test,forbid,multiple,types,with,conflicting,mappings,throws,ioexception,string,mapping,strings,to,string,xcontent,factory,json,builder,start,object,start,object,type,start,object,properties,start,object,field1,field,type,end,object,end,object,end,object,end,object,mapper,service,mapper,service,create,index,test,mapper,service,mapper,service,merge,type,new,compressed,xcontent,mapping,merge,reason,string,mapping2,strings,to,string,xcontent,factory,json,builder,start,object,start,object,type2,start,object,properties,start,object,field1,field,type,integer,end,object,end,object,end,object,end,object,illegal,argument,exception,e,expect,throws,illegal,argument,exception,class,mapper,service,merge,type2,new,compressed,xcontent,mapping2,merge,reason,assert,that,e,get,message,matchers,starts,with,rejecting,mapping,update,to,test,as,the,final,mapping,would,have,more,than,1,type
MapperServiceTests -> public void testForbidMultipleTypesWithConflictingMappings() throws IOException;1536137328;This test checks that the multi-type validation is done before we do any other kind of validation on the mapping that's added,_see https://github.com/elastic/elasticsearch/issues/29313;public void testForbidMultipleTypesWithConflictingMappings() throws IOException {_        String mapping = Strings.toString(XContentFactory.jsonBuilder().startObject().startObject("type")_            .startObject("properties").startObject("field1").field("type", "integer_range").endObject().endObject().endObject().endObject())__        MapperService mapperService = createIndex("test").mapperService()__        mapperService.merge("type", new CompressedXContent(mapping), MergeReason.MAPPING_UPDATE)___        String mapping2 = Strings.toString(XContentFactory.jsonBuilder().startObject().startObject("type2")_            .startObject("properties").startObject("field1").field("type", "integer").endObject().endObject().endObject().endObject())__        IllegalArgumentException e = expectThrows(IllegalArgumentException.class,_            () -> mapperService.merge("type2", new CompressedXContent(mapping2), MergeReason.MAPPING_UPDATE))__        assertThat(e.getMessage(), Matchers.startsWith("Rejecting mapping update to [test] as the final mapping would have more than 1 type: "))__    };this,test,checks,that,the,multi,type,validation,is,done,before,we,do,any,other,kind,of,validation,on,the,mapping,that,s,added,see,https,github,com,elastic,elasticsearch,issues,29313;public,void,test,forbid,multiple,types,with,conflicting,mappings,throws,ioexception,string,mapping,strings,to,string,xcontent,factory,json,builder,start,object,start,object,type,start,object,properties,start,object,field1,field,type,end,object,end,object,end,object,end,object,mapper,service,mapper,service,create,index,test,mapper,service,mapper,service,merge,type,new,compressed,xcontent,mapping,merge,reason,string,mapping2,strings,to,string,xcontent,factory,json,builder,start,object,start,object,type2,start,object,properties,start,object,field1,field,type,integer,end,object,end,object,end,object,end,object,illegal,argument,exception,e,expect,throws,illegal,argument,exception,class,mapper,service,merge,type2,new,compressed,xcontent,mapping2,merge,reason,assert,that,e,get,message,matchers,starts,with,rejecting,mapping,update,to,test,as,the,final,mapping,would,have,more,than,1,type
MapperServiceTests -> public void testForbidMultipleTypesWithConflictingMappings() throws IOException;1536177418;This test checks that the multi-type validation is done before we do any other kind of validation on the mapping that's added,_see https://github.com/elastic/elasticsearch/issues/29313;public void testForbidMultipleTypesWithConflictingMappings() throws IOException {_        String mapping = Strings.toString(XContentFactory.jsonBuilder().startObject().startObject("type")_            .startObject("properties").startObject("field1").field("type", "integer_range").endObject().endObject().endObject().endObject())__        MapperService mapperService = createIndex("test").mapperService()__        mapperService.merge("type", new CompressedXContent(mapping), MergeReason.MAPPING_UPDATE)___        String mapping2 = Strings.toString(XContentFactory.jsonBuilder().startObject().startObject("type2")_            .startObject("properties").startObject("field1").field("type", "integer").endObject().endObject().endObject().endObject())__        IllegalArgumentException e = expectThrows(IllegalArgumentException.class,_            () -> mapperService.merge("type2", new CompressedXContent(mapping2), MergeReason.MAPPING_UPDATE))__        assertThat(e.getMessage(), Matchers.startsWith("Rejecting mapping update to [test] as the final mapping would have more than 1 type: "))__    };this,test,checks,that,the,multi,type,validation,is,done,before,we,do,any,other,kind,of,validation,on,the,mapping,that,s,added,see,https,github,com,elastic,elasticsearch,issues,29313;public,void,test,forbid,multiple,types,with,conflicting,mappings,throws,ioexception,string,mapping,strings,to,string,xcontent,factory,json,builder,start,object,start,object,type,start,object,properties,start,object,field1,field,type,end,object,end,object,end,object,end,object,mapper,service,mapper,service,create,index,test,mapper,service,mapper,service,merge,type,new,compressed,xcontent,mapping,merge,reason,string,mapping2,strings,to,string,xcontent,factory,json,builder,start,object,start,object,type2,start,object,properties,start,object,field1,field,type,integer,end,object,end,object,end,object,end,object,illegal,argument,exception,e,expect,throws,illegal,argument,exception,class,mapper,service,merge,type2,new,compressed,xcontent,mapping2,merge,reason,assert,that,e,get,message,matchers,starts,with,rejecting,mapping,update,to,test,as,the,final,mapping,would,have,more,than,1,type
MapperServiceTests -> public void testForbidMultipleTypesWithConflictingMappings() throws IOException;1541008027;This test checks that the multi-type validation is done before we do any other kind of validation on the mapping that's added,_see https://github.com/elastic/elasticsearch/issues/29313;public void testForbidMultipleTypesWithConflictingMappings() throws IOException {_        String mapping = Strings.toString(XContentFactory.jsonBuilder().startObject().startObject("type")_            .startObject("properties").startObject("field1").field("type", "integer_range")_            .endObject().endObject().endObject().endObject())__        MapperService mapperService = createIndex("test").mapperService()__        mapperService.merge("type", new CompressedXContent(mapping), MergeReason.MAPPING_UPDATE)___        String mapping2 = Strings.toString(XContentFactory.jsonBuilder().startObject().startObject("type2")_            .startObject("properties").startObject("field1").field("type", "integer")_            .endObject().endObject().endObject().endObject())__        IllegalArgumentException e = expectThrows(IllegalArgumentException.class,_            () -> mapperService.merge("type2", new CompressedXContent(mapping2), MergeReason.MAPPING_UPDATE))__        assertThat(e.getMessage(), startsWith("Rejecting mapping update to [test] as the final mapping would have more than 1 type: "))__    };this,test,checks,that,the,multi,type,validation,is,done,before,we,do,any,other,kind,of,validation,on,the,mapping,that,s,added,see,https,github,com,elastic,elasticsearch,issues,29313;public,void,test,forbid,multiple,types,with,conflicting,mappings,throws,ioexception,string,mapping,strings,to,string,xcontent,factory,json,builder,start,object,start,object,type,start,object,properties,start,object,field1,field,type,end,object,end,object,end,object,end,object,mapper,service,mapper,service,create,index,test,mapper,service,mapper,service,merge,type,new,compressed,xcontent,mapping,merge,reason,string,mapping2,strings,to,string,xcontent,factory,json,builder,start,object,start,object,type2,start,object,properties,start,object,field1,field,type,integer,end,object,end,object,end,object,end,object,illegal,argument,exception,e,expect,throws,illegal,argument,exception,class,mapper,service,merge,type2,new,compressed,xcontent,mapping2,merge,reason,assert,that,e,get,message,starts,with,rejecting,mapping,update,to,test,as,the,final,mapping,would,have,more,than,1,type
MapperServiceTests -> public void testForbidMultipleTypesWithConflictingMappings() throws IOException;1546545188;This test checks that the multi-type validation is done before we do any other kind of validation on the mapping that's added,_see https://github.com/elastic/elasticsearch/issues/29313;public void testForbidMultipleTypesWithConflictingMappings() throws IOException {_        String mapping = Strings.toString(XContentFactory.jsonBuilder().startObject().startObject("type")_            .startObject("properties").startObject("field1").field("type", "integer_range")_            .endObject().endObject().endObject().endObject())__        MapperService mapperService = createIndex("test").mapperService()__        mapperService.merge("type", new CompressedXContent(mapping), MergeReason.MAPPING_UPDATE)___        String mapping2 = Strings.toString(XContentFactory.jsonBuilder().startObject().startObject("type2")_            .startObject("properties").startObject("field1").field("type", "integer")_            .endObject().endObject().endObject().endObject())__        IllegalArgumentException e = expectThrows(IllegalArgumentException.class,_            () -> mapperService.merge("type2", new CompressedXContent(mapping2), MergeReason.MAPPING_UPDATE))__        assertThat(e.getMessage(), startsWith("Rejecting mapping update to [test] as the final mapping would have more than 1 type: "))__    };this,test,checks,that,the,multi,type,validation,is,done,before,we,do,any,other,kind,of,validation,on,the,mapping,that,s,added,see,https,github,com,elastic,elasticsearch,issues,29313;public,void,test,forbid,multiple,types,with,conflicting,mappings,throws,ioexception,string,mapping,strings,to,string,xcontent,factory,json,builder,start,object,start,object,type,start,object,properties,start,object,field1,field,type,end,object,end,object,end,object,end,object,mapper,service,mapper,service,create,index,test,mapper,service,mapper,service,merge,type,new,compressed,xcontent,mapping,merge,reason,string,mapping2,strings,to,string,xcontent,factory,json,builder,start,object,start,object,type2,start,object,properties,start,object,field1,field,type,integer,end,object,end,object,end,object,end,object,illegal,argument,exception,e,expect,throws,illegal,argument,exception,class,mapper,service,merge,type2,new,compressed,xcontent,mapping2,merge,reason,assert,that,e,get,message,starts,with,rejecting,mapping,update,to,test,as,the,final,mapping,would,have,more,than,1,type
MapperServiceTests -> public void testTotalFieldsLimit() throws Throwable;1536177418;Test that we can have at least the number of fields in new mappings that are defined by "index.mapping.total_fields.limit"._Any additional field should trigger an IllegalArgumentException.;public void testTotalFieldsLimit() throws Throwable {_        int totalFieldsLimit = randomIntBetween(1, 10)__        Settings settings = Settings.builder().put(MapperService.INDEX_MAPPING_TOTAL_FIELDS_LIMIT_SETTING.getKey(), totalFieldsLimit).build()__        createIndex("test1", settings).mapperService().merge("type", createMappingSpecifyingNumberOfFields(totalFieldsLimit),_                MergeReason.MAPPING_UPDATE)___        _        IllegalArgumentException e = expectThrows(IllegalArgumentException.class, () -> {_            createIndex("test2", settings).mapperService().merge("type", createMappingSpecifyingNumberOfFields(totalFieldsLimit + 1),_                    MergeReason.MAPPING_UPDATE)__        })__        assertTrue(e.getMessage(),_                e.getMessage().contains("Limit of total fields [" + totalFieldsLimit + "] in index [test2] has been exceeded"))__    };test,that,we,can,have,at,least,the,number,of,fields,in,new,mappings,that,are,defined,by,index,mapping,limit,any,additional,field,should,trigger,an,illegal,argument,exception;public,void,test,total,fields,limit,throws,throwable,int,total,fields,limit,random,int,between,1,10,settings,settings,settings,builder,put,mapper,service,get,key,total,fields,limit,build,create,index,test1,settings,mapper,service,merge,type,create,mapping,specifying,number,of,fields,total,fields,limit,merge,reason,illegal,argument,exception,e,expect,throws,illegal,argument,exception,class,create,index,test2,settings,mapper,service,merge,type,create,mapping,specifying,number,of,fields,total,fields,limit,1,merge,reason,assert,true,e,get,message,e,get,message,contains,limit,of,total,fields,total,fields,limit,in,index,test2,has,been,exceeded
MapperServiceTests -> public void testTotalFieldsLimit() throws Throwable;1541008027;Test that we can have at least the number of fields in new mappings that are defined by "index.mapping.total_fields.limit"._Any additional field should trigger an IllegalArgumentException.;public void testTotalFieldsLimit() throws Throwable {_        int totalFieldsLimit = randomIntBetween(1, 10)__        Settings settings = Settings.builder().put(MapperService.INDEX_MAPPING_TOTAL_FIELDS_LIMIT_SETTING.getKey(), totalFieldsLimit)_            .build()__        createIndex("test1", settings).mapperService().merge("type", createMappingSpecifyingNumberOfFields(totalFieldsLimit),_                MergeReason.MAPPING_UPDATE)___        _        IllegalArgumentException e = expectThrows(IllegalArgumentException.class, () -> {_            createIndex("test2", settings).mapperService().merge("type",_                createMappingSpecifyingNumberOfFields(totalFieldsLimit + 1), MergeReason.MAPPING_UPDATE)__        })__        assertTrue(e.getMessage(),_                e.getMessage().contains("Limit of total fields [" + totalFieldsLimit + "] in index [test2] has been exceeded"))__    };test,that,we,can,have,at,least,the,number,of,fields,in,new,mappings,that,are,defined,by,index,mapping,limit,any,additional,field,should,trigger,an,illegal,argument,exception;public,void,test,total,fields,limit,throws,throwable,int,total,fields,limit,random,int,between,1,10,settings,settings,settings,builder,put,mapper,service,get,key,total,fields,limit,build,create,index,test1,settings,mapper,service,merge,type,create,mapping,specifying,number,of,fields,total,fields,limit,merge,reason,illegal,argument,exception,e,expect,throws,illegal,argument,exception,class,create,index,test2,settings,mapper,service,merge,type,create,mapping,specifying,number,of,fields,total,fields,limit,1,merge,reason,assert,true,e,get,message,e,get,message,contains,limit,of,total,fields,total,fields,limit,in,index,test2,has,been,exceeded
MapperServiceTests -> public void testTotalFieldsLimit() throws Throwable;1546545188;Test that we can have at least the number of fields in new mappings that are defined by "index.mapping.total_fields.limit"._Any additional field should trigger an IllegalArgumentException.;public void testTotalFieldsLimit() throws Throwable {_        int totalFieldsLimit = randomIntBetween(1, 10)__        Settings settings = Settings.builder().put(MapperService.INDEX_MAPPING_TOTAL_FIELDS_LIMIT_SETTING.getKey(), totalFieldsLimit)_            .build()__        createIndex("test1", settings).mapperService().merge("type", createMappingSpecifyingNumberOfFields(totalFieldsLimit),_                MergeReason.MAPPING_UPDATE)___        _        IllegalArgumentException e = expectThrows(IllegalArgumentException.class, () -> {_            createIndex("test2", settings).mapperService().merge("type",_                createMappingSpecifyingNumberOfFields(totalFieldsLimit + 1), MergeReason.MAPPING_UPDATE)__        })__        assertTrue(e.getMessage(),_                e.getMessage().contains("Limit of total fields [" + totalFieldsLimit + "] in index [test2] has been exceeded"))__    };test,that,we,can,have,at,least,the,number,of,fields,in,new,mappings,that,are,defined,by,index,mapping,limit,any,additional,field,should,trigger,an,illegal,argument,exception;public,void,test,total,fields,limit,throws,throwable,int,total,fields,limit,random,int,between,1,10,settings,settings,settings,builder,put,mapper,service,get,key,total,fields,limit,build,create,index,test1,settings,mapper,service,merge,type,create,mapping,specifying,number,of,fields,total,fields,limit,merge,reason,illegal,argument,exception,e,expect,throws,illegal,argument,exception,class,create,index,test2,settings,mapper,service,merge,type,create,mapping,specifying,number,of,fields,total,fields,limit,1,merge,reason,assert,true,e,get,message,e,get,message,contains,limit,of,total,fields,total,fields,limit,in,index,test2,has,been,exceeded
