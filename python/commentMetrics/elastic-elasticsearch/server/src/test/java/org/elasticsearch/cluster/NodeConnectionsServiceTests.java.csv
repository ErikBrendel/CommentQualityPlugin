commented;modifiers;parameterAmount;loc;comment;code
false;private;0;9;;private List<DiscoveryNode> generateNodes() {     List<DiscoveryNode> nodes = new ArrayList<>().     for (int i = randomIntBetween(20, 50). i > 0. i--) {         Set<DiscoveryNode.Role> roles = new HashSet<>(randomSubsetOf(Arrays.asList(DiscoveryNode.Role.values()))).         nodes.add(new DiscoveryNode("node_" + i, "" + i, buildNewFakeTransportAddress(), Collections.emptyMap(), roles, Version.CURRENT)).     }     return nodes. }
false;private;1;7;;private ClusterState clusterStateFromNodes(List<DiscoveryNode> nodes) {     final DiscoveryNodes.Builder builder = DiscoveryNodes.builder().     for (DiscoveryNode node : nodes) {         builder.add(node).     }     return ClusterState.builder(new ClusterName("test")).nodes(builder).build(). }
false;public;0;22;;public void testConnectAndDisconnect() {     List<DiscoveryNode> nodes = generateNodes().     NodeConnectionsService service = new NodeConnectionsService(Settings.EMPTY, threadPool, transportService).     ClusterState current = clusterStateFromNodes(Collections.emptyList()).     ClusterChangedEvent event = new ClusterChangedEvent("test", clusterStateFromNodes(randomSubsetOf(nodes)), current).     service.connectToNodes(event.state().nodes()).     assertConnected(event.state().nodes()).     service.disconnectFromNodesExcept(event.state().nodes()).     assertConnectedExactlyToNodes(event.state()).     current = event.state().     event = new ClusterChangedEvent("test", clusterStateFromNodes(randomSubsetOf(nodes)), current).     service.connectToNodes(event.state().nodes()).     assertConnected(event.state().nodes()).     service.disconnectFromNodesExcept(event.state().nodes()).     assertConnectedExactlyToNodes(event.state()). }
false;public;0;24;;public void testReconnect() {     List<DiscoveryNode> nodes = generateNodes().     NodeConnectionsService service = new NodeConnectionsService(Settings.EMPTY, threadPool, transportService).     ClusterState current = clusterStateFromNodes(Collections.emptyList()).     ClusterChangedEvent event = new ClusterChangedEvent("test", clusterStateFromNodes(randomSubsetOf(nodes)), current).     transport.randomConnectionExceptions = true.     service.connectToNodes(event.state().nodes()).     for (int i = 0. i < 3. i++) {         // simulate disconnects         for (DiscoveryNode node : randomSubsetOf(nodes)) {             transportService.disconnectFromNode(node).         }         service.new ConnectionChecker().run().     }     // disable exceptions so things can be restored     transport.randomConnectionExceptions = false.     service.new ConnectionChecker().run().     assertConnectedExactlyToNodes(event.state()). }
false;private;1;4;;private void assertConnectedExactlyToNodes(ClusterState state) {     assertConnected(state.nodes()).     assertThat(transportService.getConnectionManager().size(), equalTo(state.nodes().getSize())). }
false;private;1;5;;private void assertConnected(Iterable<DiscoveryNode> nodes) {     for (DiscoveryNode node : nodes) {         assertTrue("not connected to " + node, transportService.nodeConnected(node)).     } }
false;public;0;13;;@Override @Before public void setUp() throws Exception {     super.setUp().     this.threadPool = new TestThreadPool(getClass().getName()).     this.transport = new MockTransport().     transportService = new NoHandshakeTransportService(Settings.EMPTY, transport, threadPool, TransportService.NOOP_TRANSPORT_INTERCEPTOR, boundAddress -> DiscoveryNode.createLocal(Settings.EMPTY, buildNewFakeTransportAddress(), UUIDs.randomBase64UUID()), null, Collections.emptySet()).     transportService.start().     transportService.acceptIncomingRequests(). }
false;public;0;8;;@Override @After public void tearDown() throws Exception {     transportService.stop().     ThreadPool.terminate(threadPool, 30, TimeUnit.SECONDS).     threadPool = null.     super.tearDown(). }
false;public;3;4;;@Override public HandshakeResponse handshake(Transport.Connection connection, long timeout, Predicate<ClusterName> clusterNamePredicate) {     return new HandshakeResponse(connection.getNode(), new ClusterName(""), Version.CURRENT). }
false;public;1;3;;@Override public <Request extends TransportRequest> void registerRequestHandler(RequestHandlerRegistry<Request> reg) { }
false;public;1;4;;@Override public RequestHandlerRegistry getRequestHandler(String action) {     return null. }
false;public;1;3;;@Override public void addMessageListener(TransportMessageListener listener) { }
false;public;1;4;;@Override public boolean removeMessageListener(TransportMessageListener listener) {     throw new UnsupportedOperationException(). }
false;public;0;4;;@Override public BoundTransportAddress boundAddress() {     return null. }
false;public;0;4;;@Override public Map<String, BoundTransportAddress> profileBoundAddresses() {     return null. }
false;public;2;4;;@Override public TransportAddress[] addressesFromString(String address, int perAddressLimit) {     return new TransportAddress[0]. }
false;public;0;4;;@Override public DiscoveryNode getNode() {     return node. }
false;public;4;5;;@Override public void sendRequest(long requestId, String action, TransportRequest request, TransportRequestOptions options) throws TransportException { }
false;public;1;4;;@Override public void addCloseListener(ActionListener<Void> listener) { }
false;public;0;4;;@Override public void close() { }
false;public;0;4;;@Override public boolean isClosed() {     return false. }
false;public;3;37;;@Override public Releasable openConnection(DiscoveryNode node, ConnectionProfile profile, ActionListener<Connection> listener) {     if (profile == null) {         if (randomConnectionExceptions && randomBoolean()) {             listener.onFailure(new ConnectTransportException(node, "simulated")).             return () -> {             }.         }     }     listener.onResponse(new Connection() {          @Override         public DiscoveryNode getNode() {             return node.         }          @Override         public void sendRequest(long requestId, String action, TransportRequest request, TransportRequestOptions options) throws TransportException {         }          @Override         public void addCloseListener(ActionListener<Void> listener) {         }          @Override         public void close() {         }          @Override         public boolean isClosed() {             return false.         }     }).     return () -> {     }. }
false;public;0;4;;@Override public List<String> getLocalAddresses() {     return null. }
false;public;0;4;;@Override public Lifecycle.State lifecycleState() {     return null. }
false;public;1;3;;@Override public void addLifecycleListener(LifecycleListener listener) { }
false;public;1;3;;@Override public void removeLifecycleListener(LifecycleListener listener) { }
false;public;0;3;;@Override public void start() { }
false;public;0;3;;@Override public void stop() { }
false;public;0;3;;@Override public void close() { }
false;public;0;4;;@Override public TransportStats getStats() {     throw new UnsupportedOperationException(). }
false;public;0;4;;@Override public ResponseHandlers getResponseHandlers() {     return responseHandlers. }
