# id;timestamp;commentText;codeText;commentWords;codeWords
IndicesStoreIntegrationIT -> public static BlockClusterStateProcessing relocateAndBlockCompletion(Logger logger, String index, int shard, String nodeFrom,                                                                          String nodeTo) throws InterruptedException;1524684173;relocate a shard and block cluster state processing on the relocation target node to activate the shard;public static BlockClusterStateProcessing relocateAndBlockCompletion(Logger logger, String index, int shard, String nodeFrom,_                                                                         String nodeTo) throws InterruptedException {_        BlockClusterStateProcessing disruption = new BlockClusterStateProcessing(nodeTo, random())__        internalCluster().setDisruptionScheme(disruption)__        MockTransportService transportService = (MockTransportService) internalCluster().getInstance(TransportService.class, nodeTo)__        ClusterService clusterService = internalCluster().getInstance(ClusterService.class, nodeTo)__        CountDownLatch beginRelocationLatch = new CountDownLatch(1)__        CountDownLatch receivedShardExistsRequestLatch = new CountDownLatch(1)__        _        transportService.addTracer(new MockTransportService.Tracer() {_            @Override_            public void receivedRequest(long requestId, String action) {_                if (action.equals(PeerRecoveryTargetService.Actions.FILES_INFO)) {_                    logger.info("received: {}, relocation starts", action)__                    beginRelocationLatch.countDown()__                } else if (action.equals(IndicesStore.ACTION_SHARD_EXISTS)) {_                    _                    _                    _                    receivedShardExistsRequestLatch.countDown()__                    logger.info("received: {}, relocation done", action)__                } else if (action.equals(PeerRecoveryTargetService.Actions.WAIT_CLUSTERSTATE)) {_                    logger.info("received: {}, waiting on cluster state", action)__                    _                    _                    _                    _                    try {_                        assertBusy(() -> assertTrue(_                            clusterService.state().routingTable().index(index).shard(shard).primaryShard().relocating()))__                    } catch (Exception e) {_                        throw new RuntimeException(e)__                    }_                }_            }_        })__        internalCluster().client().admin().cluster().prepareReroute().add(new MoveAllocationCommand(index, shard, nodeFrom, nodeTo)).get()__        logger.info("--> waiting for relocation to start")__        beginRelocationLatch.await()__        logger.info("--> starting disruption")__        disruption.startDisrupting()__        logger.info("--> waiting for relocation to finish")__        receivedShardExistsRequestLatch.await()__        logger.info("--> relocation completed (but cluster state processing block still in place)")__        return disruption__    };relocate,a,shard,and,block,cluster,state,processing,on,the,relocation,target,node,to,activate,the,shard;public,static,block,cluster,state,processing,relocate,and,block,completion,logger,logger,string,index,int,shard,string,node,from,string,node,to,throws,interrupted,exception,block,cluster,state,processing,disruption,new,block,cluster,state,processing,node,to,random,internal,cluster,set,disruption,scheme,disruption,mock,transport,service,transport,service,mock,transport,service,internal,cluster,get,instance,transport,service,class,node,to,cluster,service,cluster,service,internal,cluster,get,instance,cluster,service,class,node,to,count,down,latch,begin,relocation,latch,new,count,down,latch,1,count,down,latch,received,shard,exists,request,latch,new,count,down,latch,1,transport,service,add,tracer,new,mock,transport,service,tracer,override,public,void,received,request,long,request,id,string,action,if,action,equals,peer,recovery,target,service,actions,logger,info,received,relocation,starts,action,begin,relocation,latch,count,down,else,if,action,equals,indices,store,received,shard,exists,request,latch,count,down,logger,info,received,relocation,done,action,else,if,action,equals,peer,recovery,target,service,actions,logger,info,received,waiting,on,cluster,state,action,try,assert,busy,assert,true,cluster,service,state,routing,table,index,index,shard,shard,primary,shard,relocating,catch,exception,e,throw,new,runtime,exception,e,internal,cluster,client,admin,cluster,prepare,reroute,add,new,move,allocation,command,index,shard,node,from,node,to,get,logger,info,waiting,for,relocation,to,start,begin,relocation,latch,await,logger,info,starting,disruption,disruption,start,disrupting,logger,info,waiting,for,relocation,to,finish,received,shard,exists,request,latch,await,logger,info,relocation,completed,but,cluster,state,processing,block,still,in,place,return,disruption
IndicesStoreIntegrationIT -> public static BlockClusterStateProcessing relocateAndBlockCompletion(Logger logger, String index, int shard, String nodeFrom,                                                                          String nodeTo) throws InterruptedException;1527152864;relocate a shard and block cluster state processing on the relocation target node to activate the shard;public static BlockClusterStateProcessing relocateAndBlockCompletion(Logger logger, String index, int shard, String nodeFrom,_                                                                         String nodeTo) throws InterruptedException {_        BlockClusterStateProcessing disruption = new BlockClusterStateProcessing(nodeTo, random())__        internalCluster().setDisruptionScheme(disruption)__        MockTransportService transportService = (MockTransportService) internalCluster().getInstance(TransportService.class, nodeTo)__        ClusterService clusterService = internalCluster().getInstance(ClusterService.class, nodeTo)__        CountDownLatch beginRelocationLatch = new CountDownLatch(1)__        CountDownLatch receivedShardExistsRequestLatch = new CountDownLatch(1)__        _        transportService.addTracer(new MockTransportService.Tracer() {_            @Override_            public void receivedRequest(long requestId, String action) {_                if (action.equals(PeerRecoveryTargetService.Actions.FILES_INFO)) {_                    logger.info("received: {}, relocation starts", action)__                    beginRelocationLatch.countDown()__                } else if (action.equals(IndicesStore.ACTION_SHARD_EXISTS)) {_                    _                    _                    _                    receivedShardExistsRequestLatch.countDown()__                    logger.info("received: {}, relocation done", action)__                } else if (action.equals(PeerRecoveryTargetService.Actions.WAIT_CLUSTERSTATE)) {_                    logger.info("received: {}, waiting on cluster state", action)__                    _                    _                    _                    _                    try {_                        assertBusy(() -> assertTrue(_                            clusterService.state().routingTable().index(index).shard(shard).primaryShard().relocating()))__                    } catch (Exception e) {_                        throw new RuntimeException(e)__                    }_                }_            }_        })__        internalCluster().client().admin().cluster().prepareReroute().add(new MoveAllocationCommand(index, shard, nodeFrom, nodeTo)).get()__        logger.info("--> waiting for relocation to start")__        beginRelocationLatch.await()__        logger.info("--> starting disruption")__        disruption.startDisrupting()__        logger.info("--> waiting for relocation to finish")__        receivedShardExistsRequestLatch.await()__        logger.info("--> relocation completed (but cluster state processing block still in place)")__        return disruption__    };relocate,a,shard,and,block,cluster,state,processing,on,the,relocation,target,node,to,activate,the,shard;public,static,block,cluster,state,processing,relocate,and,block,completion,logger,logger,string,index,int,shard,string,node,from,string,node,to,throws,interrupted,exception,block,cluster,state,processing,disruption,new,block,cluster,state,processing,node,to,random,internal,cluster,set,disruption,scheme,disruption,mock,transport,service,transport,service,mock,transport,service,internal,cluster,get,instance,transport,service,class,node,to,cluster,service,cluster,service,internal,cluster,get,instance,cluster,service,class,node,to,count,down,latch,begin,relocation,latch,new,count,down,latch,1,count,down,latch,received,shard,exists,request,latch,new,count,down,latch,1,transport,service,add,tracer,new,mock,transport,service,tracer,override,public,void,received,request,long,request,id,string,action,if,action,equals,peer,recovery,target,service,actions,logger,info,received,relocation,starts,action,begin,relocation,latch,count,down,else,if,action,equals,indices,store,received,shard,exists,request,latch,count,down,logger,info,received,relocation,done,action,else,if,action,equals,peer,recovery,target,service,actions,logger,info,received,waiting,on,cluster,state,action,try,assert,busy,assert,true,cluster,service,state,routing,table,index,index,shard,shard,primary,shard,relocating,catch,exception,e,throw,new,runtime,exception,e,internal,cluster,client,admin,cluster,prepare,reroute,add,new,move,allocation,command,index,shard,node,from,node,to,get,logger,info,waiting,for,relocation,to,start,begin,relocation,latch,await,logger,info,starting,disruption,disruption,start,disrupting,logger,info,waiting,for,relocation,to,finish,received,shard,exists,request,latch,await,logger,info,relocation,completed,but,cluster,state,processing,block,still,in,place,return,disruption
IndicesStoreIntegrationIT -> public static BlockClusterStateProcessing relocateAndBlockCompletion(Logger logger, String index, int shard, String nodeFrom,                                                                          String nodeTo) throws InterruptedException;1528762805;relocate a shard and block cluster state processing on the relocation target node to activate the shard;public static BlockClusterStateProcessing relocateAndBlockCompletion(Logger logger, String index, int shard, String nodeFrom,_                                                                         String nodeTo) throws InterruptedException {_        BlockClusterStateProcessing disruption = new BlockClusterStateProcessing(nodeTo, random())__        internalCluster().setDisruptionScheme(disruption)__        MockTransportService transportService = (MockTransportService) internalCluster().getInstance(TransportService.class, nodeTo)__        ClusterService clusterService = internalCluster().getInstance(ClusterService.class, nodeTo)__        CountDownLatch beginRelocationLatch = new CountDownLatch(1)__        CountDownLatch receivedShardExistsRequestLatch = new CountDownLatch(1)__        _        transportService.addTracer(new MockTransportService.Tracer() {_            @Override_            public void receivedRequest(long requestId, String action) {_                if (action.equals(PeerRecoveryTargetService.Actions.FILES_INFO)) {_                    logger.info("received: {}, relocation starts", action)__                    beginRelocationLatch.countDown()__                } else if (action.equals(IndicesStore.ACTION_SHARD_EXISTS)) {_                    _                    _                    _                    receivedShardExistsRequestLatch.countDown()__                    logger.info("received: {}, relocation done", action)__                } else if (action.equals(PeerRecoveryTargetService.Actions.WAIT_CLUSTERSTATE)) {_                    logger.info("received: {}, waiting on cluster state", action)__                    _                    _                    _                    _                    try {_                        assertBusy(() -> assertTrue(_                            clusterService.state().routingTable().index(index).shard(shard).primaryShard().relocating()))__                    } catch (Exception e) {_                        throw new RuntimeException(e)__                    }_                }_            }_        })__        internalCluster().client().admin().cluster().prepareReroute().add(new MoveAllocationCommand(index, shard, nodeFrom, nodeTo)).get()__        logger.info("--> waiting for relocation to start")__        beginRelocationLatch.await()__        logger.info("--> starting disruption")__        disruption.startDisrupting()__        logger.info("--> waiting for relocation to finish")__        receivedShardExistsRequestLatch.await()__        logger.info("--> relocation completed (but cluster state processing block still in place)")__        return disruption__    };relocate,a,shard,and,block,cluster,state,processing,on,the,relocation,target,node,to,activate,the,shard;public,static,block,cluster,state,processing,relocate,and,block,completion,logger,logger,string,index,int,shard,string,node,from,string,node,to,throws,interrupted,exception,block,cluster,state,processing,disruption,new,block,cluster,state,processing,node,to,random,internal,cluster,set,disruption,scheme,disruption,mock,transport,service,transport,service,mock,transport,service,internal,cluster,get,instance,transport,service,class,node,to,cluster,service,cluster,service,internal,cluster,get,instance,cluster,service,class,node,to,count,down,latch,begin,relocation,latch,new,count,down,latch,1,count,down,latch,received,shard,exists,request,latch,new,count,down,latch,1,transport,service,add,tracer,new,mock,transport,service,tracer,override,public,void,received,request,long,request,id,string,action,if,action,equals,peer,recovery,target,service,actions,logger,info,received,relocation,starts,action,begin,relocation,latch,count,down,else,if,action,equals,indices,store,received,shard,exists,request,latch,count,down,logger,info,received,relocation,done,action,else,if,action,equals,peer,recovery,target,service,actions,logger,info,received,waiting,on,cluster,state,action,try,assert,busy,assert,true,cluster,service,state,routing,table,index,index,shard,shard,primary,shard,relocating,catch,exception,e,throw,new,runtime,exception,e,internal,cluster,client,admin,cluster,prepare,reroute,add,new,move,allocation,command,index,shard,node,from,node,to,get,logger,info,waiting,for,relocation,to,start,begin,relocation,latch,await,logger,info,starting,disruption,disruption,start,disrupting,logger,info,waiting,for,relocation,to,finish,received,shard,exists,request,latch,await,logger,info,relocation,completed,but,cluster,state,processing,block,still,in,place,return,disruption
IndicesStoreIntegrationIT -> public static BlockClusterStateProcessing relocateAndBlockCompletion(Logger logger, String index, int shard, String nodeFrom,                                                                          String nodeTo) throws InterruptedException;1534203100;relocate a shard and block cluster state processing on the relocation target node to activate the shard;public static BlockClusterStateProcessing relocateAndBlockCompletion(Logger logger, String index, int shard, String nodeFrom,_                                                                         String nodeTo) throws InterruptedException {_        BlockClusterStateProcessing disruption = new BlockClusterStateProcessing(nodeTo, random())__        internalCluster().setDisruptionScheme(disruption)__        MockTransportService transportService = (MockTransportService) internalCluster().getInstance(TransportService.class, nodeTo)__        ClusterService clusterService = internalCluster().getInstance(ClusterService.class, nodeTo)__        CountDownLatch beginRelocationLatch = new CountDownLatch(1)__        CountDownLatch receivedShardExistsRequestLatch = new CountDownLatch(1)__        _        transportService.addTracer(new MockTransportService.Tracer() {_            @Override_            public void receivedRequest(long requestId, String action) {_                if (action.equals(PeerRecoveryTargetService.Actions.FILES_INFO)) {_                    logger.info("received: {}, relocation starts", action)__                    beginRelocationLatch.countDown()__                } else if (action.equals(IndicesStore.ACTION_SHARD_EXISTS)) {_                    _                    _                    _                    receivedShardExistsRequestLatch.countDown()__                    logger.info("received: {}, relocation done", action)__                } else if (action.equals(PeerRecoveryTargetService.Actions.WAIT_CLUSTERSTATE)) {_                    logger.info("received: {}, waiting on cluster state", action)__                    _                    _                    _                    _                    try {_                        assertBusy(() -> assertTrue(_                            clusterService.state().routingTable().index(index).shard(shard).primaryShard().relocating()))__                    } catch (Exception e) {_                        throw new RuntimeException(e)__                    }_                }_            }_        })__        internalCluster().client().admin().cluster().prepareReroute().add(new MoveAllocationCommand(index, shard, nodeFrom, nodeTo)).get()__        logger.info("--> waiting for relocation to start")__        beginRelocationLatch.await()__        logger.info("--> starting disruption")__        disruption.startDisrupting()__        logger.info("--> waiting for relocation to finish")__        receivedShardExistsRequestLatch.await()__        logger.info("--> relocation completed (but cluster state processing block still in place)")__        return disruption__    };relocate,a,shard,and,block,cluster,state,processing,on,the,relocation,target,node,to,activate,the,shard;public,static,block,cluster,state,processing,relocate,and,block,completion,logger,logger,string,index,int,shard,string,node,from,string,node,to,throws,interrupted,exception,block,cluster,state,processing,disruption,new,block,cluster,state,processing,node,to,random,internal,cluster,set,disruption,scheme,disruption,mock,transport,service,transport,service,mock,transport,service,internal,cluster,get,instance,transport,service,class,node,to,cluster,service,cluster,service,internal,cluster,get,instance,cluster,service,class,node,to,count,down,latch,begin,relocation,latch,new,count,down,latch,1,count,down,latch,received,shard,exists,request,latch,new,count,down,latch,1,transport,service,add,tracer,new,mock,transport,service,tracer,override,public,void,received,request,long,request,id,string,action,if,action,equals,peer,recovery,target,service,actions,logger,info,received,relocation,starts,action,begin,relocation,latch,count,down,else,if,action,equals,indices,store,received,shard,exists,request,latch,count,down,logger,info,received,relocation,done,action,else,if,action,equals,peer,recovery,target,service,actions,logger,info,received,waiting,on,cluster,state,action,try,assert,busy,assert,true,cluster,service,state,routing,table,index,index,shard,shard,primary,shard,relocating,catch,exception,e,throw,new,runtime,exception,e,internal,cluster,client,admin,cluster,prepare,reroute,add,new,move,allocation,command,index,shard,node,from,node,to,get,logger,info,waiting,for,relocation,to,start,begin,relocation,latch,await,logger,info,starting,disruption,disruption,start,disrupting,logger,info,waiting,for,relocation,to,finish,received,shard,exists,request,latch,await,logger,info,relocation,completed,but,cluster,state,processing,block,still,in,place,return,disruption
IndicesStoreIntegrationIT -> public static BlockClusterStateProcessing relocateAndBlockCompletion(Logger logger, String index, int shard, String nodeFrom,                                                                          String nodeTo) throws InterruptedException;1538067637;relocate a shard and block cluster state processing on the relocation target node to activate the shard;public static BlockClusterStateProcessing relocateAndBlockCompletion(Logger logger, String index, int shard, String nodeFrom,_                                                                         String nodeTo) throws InterruptedException {_        BlockClusterStateProcessing disruption = new BlockClusterStateProcessing(nodeTo, random())__        internalCluster().setDisruptionScheme(disruption)__        MockTransportService transportService = (MockTransportService) internalCluster().getInstance(TransportService.class, nodeTo)__        ClusterService clusterService = internalCluster().getInstance(ClusterService.class, nodeTo)__        CountDownLatch beginRelocationLatch = new CountDownLatch(1)__        CountDownLatch receivedShardExistsRequestLatch = new CountDownLatch(1)__        _        transportService.addTracer(new MockTransportService.Tracer() {_            @Override_            public void receivedRequest(long requestId, String action) {_                if (action.equals(PeerRecoveryTargetService.Actions.FILES_INFO)) {_                    logger.info("received: {}, relocation starts", action)__                    beginRelocationLatch.countDown()__                } else if (action.equals(IndicesStore.ACTION_SHARD_EXISTS)) {_                    _                    _                    _                    receivedShardExistsRequestLatch.countDown()__                    logger.info("received: {}, relocation done", action)__                } else if (action.equals(PeerRecoveryTargetService.Actions.WAIT_CLUSTERSTATE)) {_                    logger.info("received: {}, waiting on cluster state", action)__                    _                    _                    _                    _                    try {_                        assertBusy(() -> assertTrue(_                            clusterService.state().routingTable().index(index).shard(shard).primaryShard().relocating()))__                    } catch (Exception e) {_                        throw new RuntimeException(e)__                    }_                }_            }_        })__        internalCluster().client().admin().cluster().prepareReroute().add(new MoveAllocationCommand(index, shard, nodeFrom, nodeTo)).get()__        logger.info("--> waiting for relocation to start")__        beginRelocationLatch.await()__        logger.info("--> starting disruption")__        disruption.startDisrupting()__        logger.info("--> waiting for relocation to finish")__        receivedShardExistsRequestLatch.await()__        logger.info("--> relocation completed (but cluster state processing block still in place)")__        return disruption__    };relocate,a,shard,and,block,cluster,state,processing,on,the,relocation,target,node,to,activate,the,shard;public,static,block,cluster,state,processing,relocate,and,block,completion,logger,logger,string,index,int,shard,string,node,from,string,node,to,throws,interrupted,exception,block,cluster,state,processing,disruption,new,block,cluster,state,processing,node,to,random,internal,cluster,set,disruption,scheme,disruption,mock,transport,service,transport,service,mock,transport,service,internal,cluster,get,instance,transport,service,class,node,to,cluster,service,cluster,service,internal,cluster,get,instance,cluster,service,class,node,to,count,down,latch,begin,relocation,latch,new,count,down,latch,1,count,down,latch,received,shard,exists,request,latch,new,count,down,latch,1,transport,service,add,tracer,new,mock,transport,service,tracer,override,public,void,received,request,long,request,id,string,action,if,action,equals,peer,recovery,target,service,actions,logger,info,received,relocation,starts,action,begin,relocation,latch,count,down,else,if,action,equals,indices,store,received,shard,exists,request,latch,count,down,logger,info,received,relocation,done,action,else,if,action,equals,peer,recovery,target,service,actions,logger,info,received,waiting,on,cluster,state,action,try,assert,busy,assert,true,cluster,service,state,routing,table,index,index,shard,shard,primary,shard,relocating,catch,exception,e,throw,new,runtime,exception,e,internal,cluster,client,admin,cluster,prepare,reroute,add,new,move,allocation,command,index,shard,node,from,node,to,get,logger,info,waiting,for,relocation,to,start,begin,relocation,latch,await,logger,info,starting,disruption,disruption,start,disrupting,logger,info,waiting,for,relocation,to,finish,received,shard,exists,request,latch,await,logger,info,relocation,completed,but,cluster,state,processing,block,still,in,place,return,disruption
IndicesStoreIntegrationIT -> public static BlockClusterStateProcessing relocateAndBlockCompletion(Logger logger, String index, int shard, String nodeFrom,                                                                          String nodeTo) throws InterruptedException;1542609384;relocate a shard and block cluster state processing on the relocation target node to activate the shard;public static BlockClusterStateProcessing relocateAndBlockCompletion(Logger logger, String index, int shard, String nodeFrom,_                                                                         String nodeTo) throws InterruptedException {_        BlockClusterStateProcessing disruption = new BlockClusterStateProcessing(nodeTo, random())__        internalCluster().setDisruptionScheme(disruption)__        MockTransportService transportService = (MockTransportService) internalCluster().getInstance(TransportService.class, nodeTo)__        ClusterService clusterService = internalCluster().getInstance(ClusterService.class, nodeTo)__        CountDownLatch beginRelocationLatch = new CountDownLatch(1)__        CountDownLatch receivedShardExistsRequestLatch = new CountDownLatch(1)__        _        transportService.addTracer(new MockTransportService.Tracer() {_            @Override_            public void receivedRequest(long requestId, String action) {_                if (action.equals(PeerRecoveryTargetService.Actions.FILES_INFO)) {_                    logger.info("received: {}, relocation starts", action)__                    beginRelocationLatch.countDown()__                } else if (action.equals(IndicesStore.ACTION_SHARD_EXISTS)) {_                    _                    _                    _                    receivedShardExistsRequestLatch.countDown()__                    logger.info("received: {}, relocation done", action)__                } else if (action.equals(PeerRecoveryTargetService.Actions.WAIT_CLUSTERSTATE)) {_                    logger.info("received: {}, waiting on cluster state", action)__                    _                    _                    _                    _                    try {_                        assertBusy(() -> assertTrue(_                            clusterService.state().routingTable().index(index).shard(shard).primaryShard().relocating()))__                    } catch (Exception e) {_                        throw new RuntimeException(e)__                    }_                }_            }_        })__        internalCluster().client().admin().cluster().prepareReroute().add(new MoveAllocationCommand(index, shard, nodeFrom, nodeTo)).get()__        logger.info("--> waiting for relocation to start")__        beginRelocationLatch.await()__        logger.info("--> starting disruption")__        disruption.startDisrupting()__        logger.info("--> waiting for relocation to finish")__        receivedShardExistsRequestLatch.await()__        logger.info("--> relocation completed (but cluster state processing block still in place)")__        return disruption__    };relocate,a,shard,and,block,cluster,state,processing,on,the,relocation,target,node,to,activate,the,shard;public,static,block,cluster,state,processing,relocate,and,block,completion,logger,logger,string,index,int,shard,string,node,from,string,node,to,throws,interrupted,exception,block,cluster,state,processing,disruption,new,block,cluster,state,processing,node,to,random,internal,cluster,set,disruption,scheme,disruption,mock,transport,service,transport,service,mock,transport,service,internal,cluster,get,instance,transport,service,class,node,to,cluster,service,cluster,service,internal,cluster,get,instance,cluster,service,class,node,to,count,down,latch,begin,relocation,latch,new,count,down,latch,1,count,down,latch,received,shard,exists,request,latch,new,count,down,latch,1,transport,service,add,tracer,new,mock,transport,service,tracer,override,public,void,received,request,long,request,id,string,action,if,action,equals,peer,recovery,target,service,actions,logger,info,received,relocation,starts,action,begin,relocation,latch,count,down,else,if,action,equals,indices,store,received,shard,exists,request,latch,count,down,logger,info,received,relocation,done,action,else,if,action,equals,peer,recovery,target,service,actions,logger,info,received,waiting,on,cluster,state,action,try,assert,busy,assert,true,cluster,service,state,routing,table,index,index,shard,shard,primary,shard,relocating,catch,exception,e,throw,new,runtime,exception,e,internal,cluster,client,admin,cluster,prepare,reroute,add,new,move,allocation,command,index,shard,node,from,node,to,get,logger,info,waiting,for,relocation,to,start,begin,relocation,latch,await,logger,info,starting,disruption,disruption,start,disrupting,logger,info,waiting,for,relocation,to,finish,received,shard,exists,request,latch,await,logger,info,relocation,completed,but,cluster,state,processing,block,still,in,place,return,disruption
IndicesStoreIntegrationIT -> public static BlockClusterStateProcessing relocateAndBlockCompletion(Logger logger, String index, int shard, String nodeFrom,                                                                          String nodeTo) throws InterruptedException;1550831438;relocate a shard and block cluster state processing on the relocation target node to activate the shard;public static BlockClusterStateProcessing relocateAndBlockCompletion(Logger logger, String index, int shard, String nodeFrom,_                                                                         String nodeTo) throws InterruptedException {_        BlockClusterStateProcessing disruption = new BlockClusterStateProcessing(nodeTo, random())__        internalCluster().setDisruptionScheme(disruption)__        MockTransportService transportService = (MockTransportService) internalCluster().getInstance(TransportService.class, nodeTo)__        ClusterService clusterService = internalCluster().getInstance(ClusterService.class, nodeTo)__        CountDownLatch beginRelocationLatch = new CountDownLatch(1)__        CountDownLatch receivedShardExistsRequestLatch = new CountDownLatch(1)__        _        transportService.addTracer(new MockTransportService.Tracer() {_            @Override_            public void receivedRequest(long requestId, String action) {_                if (action.equals(PeerRecoveryTargetService.Actions.FILES_INFO)) {_                    logger.info("received: {}, relocation starts", action)__                    beginRelocationLatch.countDown()__                } else if (action.equals(IndicesStore.ACTION_SHARD_EXISTS)) {_                    _                    _                    _                    receivedShardExistsRequestLatch.countDown()__                    logger.info("received: {}, relocation done", action)__                } else if (action.equals(PeerRecoveryTargetService.Actions.WAIT_CLUSTERSTATE)) {_                    logger.info("received: {}, waiting on cluster state", action)__                    _                    _                    _                    _                    try {_                        assertBusy(() -> assertTrue(_                            clusterService.state().routingTable().index(index).shard(shard).primaryShard().relocating()))__                    } catch (Exception e) {_                        throw new RuntimeException(e)__                    }_                }_            }_        })__        internalCluster().client().admin().cluster().prepareReroute().add(new MoveAllocationCommand(index, shard, nodeFrom, nodeTo)).get()__        logger.info("--> waiting for relocation to start")__        beginRelocationLatch.await()__        logger.info("--> starting disruption")__        disruption.startDisrupting()__        logger.info("--> waiting for relocation to finish")__        receivedShardExistsRequestLatch.await()__        logger.info("--> relocation completed (but cluster state processing block still in place)")__        return disruption__    };relocate,a,shard,and,block,cluster,state,processing,on,the,relocation,target,node,to,activate,the,shard;public,static,block,cluster,state,processing,relocate,and,block,completion,logger,logger,string,index,int,shard,string,node,from,string,node,to,throws,interrupted,exception,block,cluster,state,processing,disruption,new,block,cluster,state,processing,node,to,random,internal,cluster,set,disruption,scheme,disruption,mock,transport,service,transport,service,mock,transport,service,internal,cluster,get,instance,transport,service,class,node,to,cluster,service,cluster,service,internal,cluster,get,instance,cluster,service,class,node,to,count,down,latch,begin,relocation,latch,new,count,down,latch,1,count,down,latch,received,shard,exists,request,latch,new,count,down,latch,1,transport,service,add,tracer,new,mock,transport,service,tracer,override,public,void,received,request,long,request,id,string,action,if,action,equals,peer,recovery,target,service,actions,logger,info,received,relocation,starts,action,begin,relocation,latch,count,down,else,if,action,equals,indices,store,received,shard,exists,request,latch,count,down,logger,info,received,relocation,done,action,else,if,action,equals,peer,recovery,target,service,actions,logger,info,received,waiting,on,cluster,state,action,try,assert,busy,assert,true,cluster,service,state,routing,table,index,index,shard,shard,primary,shard,relocating,catch,exception,e,throw,new,runtime,exception,e,internal,cluster,client,admin,cluster,prepare,reroute,add,new,move,allocation,command,index,shard,node,from,node,to,get,logger,info,waiting,for,relocation,to,start,begin,relocation,latch,await,logger,info,starting,disruption,disruption,start,disrupting,logger,info,waiting,for,relocation,to,finish,received,shard,exists,request,latch,await,logger,info,relocation,completed,but,cluster,state,processing,block,still,in,place,return,disruption
