commented;modifiers;parameterAmount;loc;comment;code
false;protected;3;16;;@Override protected void executePhaseOnShard(SearchShardIterator shardIt, ShardRouting shard, SearchActionListener<TestSearchPhaseResult> listener) {     seenShard.computeIfAbsent(shard.shardId(), (i) -> {         // only count this once per replica         numRequests.incrementAndGet().         return Boolean.TRUE.     }).     new Thread(() -> {         Transport.Connection connection = getConnection(null, shard.currentNodeId()).         TestSearchPhaseResult testSearchPhaseResult = new TestSearchPhaseResult(contextIdGenerator.incrementAndGet(), connection.getNode()).         listener.onResponse(testSearchPhaseResult).     }).start(). }
false;public;0;4;;@Override public void run() {     assertTrue(searchPhaseDidRun.compareAndSet(false, true)). }
false;protected;2;9;;@Override protected SearchPhase getNextPhase(SearchPhaseResults<TestSearchPhaseResult> results, SearchPhaseContext context) {     return new SearchPhase("test") {          @Override         public void run() {             assertTrue(searchPhaseDidRun.compareAndSet(false, true)).         }     }. }
false;protected;2;5;;@Override protected void executeNext(Runnable runnable, Thread originalThread) {     super.executeNext(runnable, originalThread).     latch.countDown(). }
false;public;0;94;;public void testSkipSearchShards() throws InterruptedException {     SearchRequest request = new SearchRequest().     request.allowPartialSearchResults(true).     int numShards = 10.     ActionListener<SearchResponse> responseListener = ActionListener.wrap(response -> {     }, (e) -> {         throw new AssertionError("unexpected", e).     }).     DiscoveryNode primaryNode = new DiscoveryNode("node_1", buildNewFakeTransportAddress(), Version.CURRENT).     DiscoveryNode replicaNode = new DiscoveryNode("node_2", buildNewFakeTransportAddress(), Version.CURRENT).     AtomicInteger contextIdGenerator = new AtomicInteger(0).     GroupShardsIterator<SearchShardIterator> shardsIter = getShardsIter("idx", new OriginalIndices(new String[] { "idx" }, SearchRequest.DEFAULT_INDICES_OPTIONS), numShards, randomBoolean(), primaryNode, replicaNode).     int numSkipped = 0.     for (SearchShardIterator iter : shardsIter) {         if (iter.shardId().id() % 2 == 0) {             iter.resetAndSkip().             numSkipped++.         }     }     CountDownLatch latch = new CountDownLatch(numShards - numSkipped).     AtomicBoolean searchPhaseDidRun = new AtomicBoolean(false).     SearchTransportService transportService = new SearchTransportService(null, null).     Map<String, Transport.Connection> lookup = new HashMap<>().     Map<ShardId, Boolean> seenShard = new ConcurrentHashMap<>().     lookup.put(primaryNode.getId(), new MockConnection(primaryNode)).     lookup.put(replicaNode.getId(), new MockConnection(replicaNode)).     Map<String, AliasFilter> aliasFilters = Collections.singletonMap("_na_", new AliasFilter(null, Strings.EMPTY_ARRAY)).     AtomicInteger numRequests = new AtomicInteger(0).     AbstractSearchAsyncAction<TestSearchPhaseResult> asyncAction = new AbstractSearchAsyncAction<TestSearchPhaseResult>("test", logger, transportService, (cluster, node) -> {         assert cluster == null : "cluster was not null: " + cluster.         return lookup.get(node).     }, aliasFilters, Collections.emptyMap(), Collections.emptyMap(), null, request, responseListener, shardsIter, new TransportSearchAction.SearchTimeProvider(0, 0, () -> 0), 0, null, new InitialSearchPhase.ArraySearchPhaseResults<>(shardsIter.size()), request.getMaxConcurrentShardRequests(), SearchResponse.Clusters.EMPTY) {          @Override         protected void executePhaseOnShard(SearchShardIterator shardIt, ShardRouting shard, SearchActionListener<TestSearchPhaseResult> listener) {             seenShard.computeIfAbsent(shard.shardId(), (i) -> {                 // only count this once per replica                 numRequests.incrementAndGet().                 return Boolean.TRUE.             }).             new Thread(() -> {                 Transport.Connection connection = getConnection(null, shard.currentNodeId()).                 TestSearchPhaseResult testSearchPhaseResult = new TestSearchPhaseResult(contextIdGenerator.incrementAndGet(), connection.getNode()).                 listener.onResponse(testSearchPhaseResult).             }).start().         }          @Override         protected SearchPhase getNextPhase(SearchPhaseResults<TestSearchPhaseResult> results, SearchPhaseContext context) {             return new SearchPhase("test") {                  @Override                 public void run() {                     assertTrue(searchPhaseDidRun.compareAndSet(false, true)).                 }             }.         }          @Override         protected void executeNext(Runnable runnable, Thread originalThread) {             super.executeNext(runnable, originalThread).             latch.countDown().         }     }.     asyncAction.start().     latch.await().     assertTrue(searchPhaseDidRun.get()).     SearchResponse searchResponse = asyncAction.buildSearchResponse(null, null).     assertEquals(shardsIter.size() - numSkipped, numRequests.get()).     assertEquals(0, searchResponse.getFailedShards()).     assertEquals(numSkipped, searchResponse.getSkippedShards()).     assertEquals(shardsIter.size(), searchResponse.getSuccessfulShards()). }
false;protected;3;24;;@Override protected void executePhaseOnShard(SearchShardIterator shardIt, ShardRouting shard, SearchActionListener<TestSearchPhaseResult> listener) {     seenShard.computeIfAbsent(shard.shardId(), (i) -> {         // only count this once per shard copy         numRequests.incrementAndGet().         return Boolean.TRUE.     }).     new Thread(() -> {         try {             awaitInitialRequests.await().         } catch (InterruptedException e) {             throw new AssertionError(e).         }         Transport.Connection connection = getConnection(null, shard.currentNodeId()).         TestSearchPhaseResult testSearchPhaseResult = new TestSearchPhaseResult(contextIdGenerator.incrementAndGet(), connection.getNode()).         if (shardFailures[shard.shardId().id()]) {             listener.onFailure(new RuntimeException()).         } else {             listener.onResponse(testSearchPhaseResult).         }     }).start(). }
false;public;0;4;;@Override public void run() {     assertTrue(searchPhaseDidRun.compareAndSet(false, true)). }
false;protected;2;9;;@Override protected SearchPhase getNextPhase(SearchPhaseResults<TestSearchPhaseResult> results, SearchPhaseContext context) {     return new SearchPhase("test") {          @Override         public void run() {             assertTrue(searchPhaseDidRun.compareAndSet(false, true)).         }     }. }
false;protected;2;5;;@Override protected void executeNext(Runnable runnable, Thread originalThread) {     super.executeNext(runnable, originalThread).     latch.countDown(). }
false;public;0;110;;public void testLimitConcurrentShardRequests() throws InterruptedException {     SearchRequest request = new SearchRequest().     request.allowPartialSearchResults(true).     int numConcurrent = randomIntBetween(1, 5).     request.setMaxConcurrentShardRequests(numConcurrent).     boolean doReplicas = randomBoolean().     int numShards = randomIntBetween(5, 10).     int numShardAttempts = numShards.     Boolean[] shardFailures = new Boolean[numShards].     // at least one response otherwise the entire request fails     shardFailures[randomIntBetween(0, shardFailures.length - 1)] = false.     for (int i = 0. i < shardFailures.length. i++) {         if (shardFailures[i] == null) {             boolean failure = randomBoolean().             shardFailures[i] = failure.             if (failure && doReplicas) {                 numShardAttempts++.             }         }     }     CountDownLatch latch = new CountDownLatch(numShardAttempts).     AtomicBoolean searchPhaseDidRun = new AtomicBoolean(false).     ActionListener<SearchResponse> responseListener = ActionListener.wrap(response -> {     }, (e) -> {         throw new AssertionError("unexpected", e).     }).     DiscoveryNode primaryNode = new DiscoveryNode("node_1", buildNewFakeTransportAddress(), Version.CURRENT).     // for the sake of this test we place the replica on the same node. ie. this is not a mistake since we limit per node now     DiscoveryNode replicaNode = new DiscoveryNode("node_1", buildNewFakeTransportAddress(), Version.CURRENT).     AtomicInteger contextIdGenerator = new AtomicInteger(0).     GroupShardsIterator<SearchShardIterator> shardsIter = getShardsIter("idx", new OriginalIndices(new String[] { "idx" }, SearchRequest.DEFAULT_INDICES_OPTIONS), numShards, doReplicas, primaryNode, replicaNode).     SearchTransportService transportService = new SearchTransportService(null, null).     Map<String, Transport.Connection> lookup = new HashMap<>().     Map<ShardId, Boolean> seenShard = new ConcurrentHashMap<>().     lookup.put(primaryNode.getId(), new MockConnection(primaryNode)).     lookup.put(replicaNode.getId(), new MockConnection(replicaNode)).     Map<String, AliasFilter> aliasFilters = Collections.singletonMap("_na_", new AliasFilter(null, Strings.EMPTY_ARRAY)).     CountDownLatch awaitInitialRequests = new CountDownLatch(1).     AtomicInteger numRequests = new AtomicInteger(0).     AbstractSearchAsyncAction<TestSearchPhaseResult> asyncAction = new AbstractSearchAsyncAction<TestSearchPhaseResult>("test", logger, transportService, (cluster, node) -> {         assert cluster == null : "cluster was not null: " + cluster.         return lookup.get(node).     }, aliasFilters, Collections.emptyMap(), Collections.emptyMap(), null, request, responseListener, shardsIter, new TransportSearchAction.SearchTimeProvider(0, 0, () -> 0), 0, null, new InitialSearchPhase.ArraySearchPhaseResults<>(shardsIter.size()), request.getMaxConcurrentShardRequests(), SearchResponse.Clusters.EMPTY) {          @Override         protected void executePhaseOnShard(SearchShardIterator shardIt, ShardRouting shard, SearchActionListener<TestSearchPhaseResult> listener) {             seenShard.computeIfAbsent(shard.shardId(), (i) -> {                 // only count this once per shard copy                 numRequests.incrementAndGet().                 return Boolean.TRUE.             }).             new Thread(() -> {                 try {                     awaitInitialRequests.await().                 } catch (InterruptedException e) {                     throw new AssertionError(e).                 }                 Transport.Connection connection = getConnection(null, shard.currentNodeId()).                 TestSearchPhaseResult testSearchPhaseResult = new TestSearchPhaseResult(contextIdGenerator.incrementAndGet(), connection.getNode()).                 if (shardFailures[shard.shardId().id()]) {                     listener.onFailure(new RuntimeException()).                 } else {                     listener.onResponse(testSearchPhaseResult).                 }             }).start().         }          @Override         protected SearchPhase getNextPhase(SearchPhaseResults<TestSearchPhaseResult> results, SearchPhaseContext context) {             return new SearchPhase("test") {                  @Override                 public void run() {                     assertTrue(searchPhaseDidRun.compareAndSet(false, true)).                 }             }.         }          @Override         protected void executeNext(Runnable runnable, Thread originalThread) {             super.executeNext(runnable, originalThread).             latch.countDown().         }     }.     asyncAction.start().     assertEquals(numConcurrent, numRequests.get()).     awaitInitialRequests.countDown().     latch.await().     assertTrue(searchPhaseDidRun.get()).     assertEquals(numShards, numRequests.get()). }
false;public;3;6;;@Override public void sendFreeContext(Transport.Connection connection, long contextId, OriginalIndices originalIndices) {     numFreedContext.incrementAndGet().     assertTrue(nodeToContextMap.containsKey(connection.getNode())).     assertTrue(nodeToContextMap.get(connection.getNode()).remove(contextId)). }
false;protected;3;15;;@Override protected void executePhaseOnShard(SearchShardIterator shardIt, ShardRouting shard, SearchActionListener<TestSearchPhaseResult> listener) {     assertTrue("shard: " + shard.shardId() + " has been queried twice", response.queried.add(shard.shardId())).     Transport.Connection connection = getConnection(null, shard.currentNodeId()).     TestSearchPhaseResult testSearchPhaseResult = new TestSearchPhaseResult(contextIdGenerator.incrementAndGet(), connection.getNode()).     Set<Long> ids = nodeToContextMap.computeIfAbsent(connection.getNode(), (n) -> newConcurrentSet()).     ids.add(testSearchPhaseResult.getRequestId()).     if (randomBoolean()) {         listener.onResponse(testSearchPhaseResult).     } else {         new Thread(() -> listener.onResponse(testSearchPhaseResult)).start().     } }
false;public;0;9;;@Override public void run() {     for (int i = 0. i < results.getNumShards(). i++) {         TestSearchPhaseResult result = results.getAtomicArray().get(i).         assertEquals(result.node.getId(), result.getSearchShardTarget().getNodeId()).         sendReleaseSearchContext(result.getRequestId(), new MockConnection(result.node), OriginalIndices.NONE).     }     responseListener.onResponse(response). }
false;protected;2;14;;@Override protected SearchPhase getNextPhase(SearchPhaseResults<TestSearchPhaseResult> results, SearchPhaseContext context) {     return new SearchPhase("test") {          @Override         public void run() {             for (int i = 0. i < results.getNumShards(). i++) {                 TestSearchPhaseResult result = results.getAtomicArray().get(i).                 assertEquals(result.node.getId(), result.getSearchShardTarget().getNodeId()).                 sendReleaseSearchContext(result.getRequestId(), new MockConnection(result.node), OriginalIndices.NONE).             }             responseListener.onResponse(response).         }     }. }
false;protected;2;5;;@Override protected void executeNext(Runnable runnable, Thread originalThread) {     super.executeNext(runnable, originalThread).     latch.countDown(). }
false;public;0;105;;public void testFanOutAndCollect() throws InterruptedException {     SearchRequest request = new SearchRequest().     request.allowPartialSearchResults(true).     request.setMaxConcurrentShardRequests(randomIntBetween(1, 100)).     AtomicReference<TestSearchResponse> response = new AtomicReference<>().     ActionListener<SearchResponse> responseListener = ActionListener.wrap(searchResponse -> response.set((TestSearchResponse) searchResponse), (e) -> {         throw new AssertionError("unexpected", e).     }).     DiscoveryNode primaryNode = new DiscoveryNode("node_1", buildNewFakeTransportAddress(), Version.CURRENT).     DiscoveryNode replicaNode = new DiscoveryNode("node_2", buildNewFakeTransportAddress(), Version.CURRENT).     Map<DiscoveryNode, Set<Long>> nodeToContextMap = newConcurrentMap().     AtomicInteger contextIdGenerator = new AtomicInteger(0).     int numShards = randomIntBetween(1, 10).     GroupShardsIterator<SearchShardIterator> shardsIter = getShardsIter("idx", new OriginalIndices(new String[] { "idx" }, SearchRequest.DEFAULT_INDICES_OPTIONS), numShards, randomBoolean(), primaryNode, replicaNode).     AtomicInteger numFreedContext = new AtomicInteger().     SearchTransportService transportService = new SearchTransportService(null, null) {          @Override         public void sendFreeContext(Transport.Connection connection, long contextId, OriginalIndices originalIndices) {             numFreedContext.incrementAndGet().             assertTrue(nodeToContextMap.containsKey(connection.getNode())).             assertTrue(nodeToContextMap.get(connection.getNode()).remove(contextId)).         }     }.     Map<String, Transport.Connection> lookup = new HashMap<>().     lookup.put(primaryNode.getId(), new MockConnection(primaryNode)).     lookup.put(replicaNode.getId(), new MockConnection(replicaNode)).     Map<String, AliasFilter> aliasFilters = Collections.singletonMap("_na_", new AliasFilter(null, Strings.EMPTY_ARRAY)).     ExecutorService executor = Executors.newFixedThreadPool(randomIntBetween(1, Runtime.getRuntime().availableProcessors())).     final CountDownLatch latch = new CountDownLatch(numShards).     AbstractSearchAsyncAction<TestSearchPhaseResult> asyncAction = new AbstractSearchAsyncAction<TestSearchPhaseResult>("test", logger, transportService, (cluster, node) -> {         assert cluster == null : "cluster was not null: " + cluster.         return lookup.get(node).     }, aliasFilters, Collections.emptyMap(), Collections.emptyMap(), executor, request, responseListener, shardsIter, new TransportSearchAction.SearchTimeProvider(0, 0, () -> 0), 0, null, new InitialSearchPhase.ArraySearchPhaseResults<>(shardsIter.size()), request.getMaxConcurrentShardRequests(), SearchResponse.Clusters.EMPTY) {          TestSearchResponse response = new TestSearchResponse().          @Override         protected void executePhaseOnShard(SearchShardIterator shardIt, ShardRouting shard, SearchActionListener<TestSearchPhaseResult> listener) {             assertTrue("shard: " + shard.shardId() + " has been queried twice", response.queried.add(shard.shardId())).             Transport.Connection connection = getConnection(null, shard.currentNodeId()).             TestSearchPhaseResult testSearchPhaseResult = new TestSearchPhaseResult(contextIdGenerator.incrementAndGet(), connection.getNode()).             Set<Long> ids = nodeToContextMap.computeIfAbsent(connection.getNode(), (n) -> newConcurrentSet()).             ids.add(testSearchPhaseResult.getRequestId()).             if (randomBoolean()) {                 listener.onResponse(testSearchPhaseResult).             } else {                 new Thread(() -> listener.onResponse(testSearchPhaseResult)).start().             }         }          @Override         protected SearchPhase getNextPhase(SearchPhaseResults<TestSearchPhaseResult> results, SearchPhaseContext context) {             return new SearchPhase("test") {                  @Override                 public void run() {                     for (int i = 0. i < results.getNumShards(). i++) {                         TestSearchPhaseResult result = results.getAtomicArray().get(i).                         assertEquals(result.node.getId(), result.getSearchShardTarget().getNodeId()).                         sendReleaseSearchContext(result.getRequestId(), new MockConnection(result.node), OriginalIndices.NONE).                     }                     responseListener.onResponse(response).                 }             }.         }          @Override         protected void executeNext(Runnable runnable, Thread originalThread) {             super.executeNext(runnable, originalThread).             latch.countDown().         }     }.     asyncAction.start().     latch.await().     assertNotNull(response.get()).     assertFalse(nodeToContextMap.isEmpty()).     assertTrue(nodeToContextMap.toString(), nodeToContextMap.containsKey(primaryNode) || nodeToContextMap.containsKey(replicaNode)).     assertEquals(shardsIter.size(), numFreedContext.get()).     if (nodeToContextMap.containsKey(primaryNode)) {         assertTrue(nodeToContextMap.get(primaryNode).toString(), nodeToContextMap.get(primaryNode).isEmpty()).     } else {         assertTrue(nodeToContextMap.get(replicaNode).toString(), nodeToContextMap.get(replicaNode).isEmpty()).     }     executor.shutdown(). }
false;static;6;34;;static GroupShardsIterator<SearchShardIterator> getShardsIter(String index, OriginalIndices originalIndices, int numShards, boolean doReplicas, DiscoveryNode primaryNode, DiscoveryNode replicaNode) {     ArrayList<SearchShardIterator> list = new ArrayList<>().     for (int i = 0. i < numShards. i++) {         ArrayList<ShardRouting> started = new ArrayList<>().         ArrayList<ShardRouting> initializing = new ArrayList<>().         ArrayList<ShardRouting> unassigned = new ArrayList<>().         ShardRouting routing = ShardRouting.newUnassigned(new ShardId(new Index(index, "_na_"), i), true, RecoverySource.EmptyStoreRecoverySource.INSTANCE, new UnassignedInfo(UnassignedInfo.Reason.INDEX_CREATED, "foobar")).         routing = routing.initialize(primaryNode.getId(), i + "p", 0).         routing.started().         started.add(routing).         if (doReplicas) {             routing = ShardRouting.newUnassigned(new ShardId(new Index(index, "_na_"), i), false, RecoverySource.PeerRecoverySource.INSTANCE, new UnassignedInfo(UnassignedInfo.Reason.INDEX_CREATED, "foobar")).             if (replicaNode != null) {                 routing = routing.initialize(replicaNode.getId(), i + "r", 0).                 if (randomBoolean()) {                     routing.started().                     started.add(routing).                 } else {                     initializing.add(routing).                 }             } else {                 // unused yet                 unassigned.add(routing).             }         }         Collections.shuffle(started, random()).         started.addAll(initializing).         list.add(new SearchShardIterator(null, new ShardId(new Index(index, "_na_"), i), started, originalIndices)).     }     return new GroupShardsIterator<>(list). }
false;public;1;4;;@Override public void readFrom(StreamInput in) throws IOException { }
false;public;1;4;;@Override public void writeTo(StreamOutput out) throws IOException { }
false;public;0;4;;@Override public DiscoveryNode getNode() {     return node. }
false;public;4;5;;@Override public void sendRequest(long requestId, String action, TransportRequest request, TransportRequestOptions options) throws IOException, TransportException {     throw new UnsupportedOperationException(). }
false;public;1;4;;@Override public void addCloseListener(ActionListener<Void> listener) { }
false;public;0;4;;@Override public boolean isClosed() {     return false. }
false;public;0;4;;@Override public void close() {     throw new UnsupportedOperationException(). }
