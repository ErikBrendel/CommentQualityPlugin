commented;modifiers;parameterAmount;loc;comment;code
false;protected;1;4;;@Override protected boolean isPublishQuorum(CoordinationState.VoteCollection votes) {     return coordinationState.isPublishQuorum(votes). }
false;protected;2;4;;@Override protected Optional<ApplyCommitRequest> handlePublishResponse(DiscoveryNode sourceNode, PublishResponse publishResponse) {     return coordinationState.handlePublishResponse(sourceNode, publishResponse). }
false;public;3;16;;public MockPublication publish(ClusterState clusterState, Discovery.AckListener ackListener, Set<DiscoveryNode> faultyNodes) {     PublishRequest publishRequest = coordinationState.handleClientValue(clusterState).     MockPublication currentPublication = new MockPublication(publishRequest, ackListener, () -> 0L) {          @Override         protected boolean isPublishQuorum(CoordinationState.VoteCollection votes) {             return coordinationState.isPublishQuorum(votes).         }          @Override         protected Optional<ApplyCommitRequest> handlePublishResponse(DiscoveryNode sourceNode, PublishResponse publishResponse) {             return coordinationState.handlePublishResponse(sourceNode, publishResponse).         }     }.     currentPublication.start(faultyNodes).     return currentPublication. }
false;protected;1;6;;@Override protected void onCompletion(boolean committed) {     assertFalse(completed).     completed = true.     this.committed = committed. }
false;protected;1;4;;@Override protected void onJoin(Join join) {     assertNull(joins.put(join.getSourceNode(), join)). }
false;protected;1;4;;@Override protected void onMissingJoin(DiscoveryNode discoveryNode) {     assertTrue(missingJoins.add(discoveryNode)). }
false;protected;3;6;;@Override protected void sendPublishRequest(DiscoveryNode destination, PublishRequest publishRequest, ActionListener<PublishWithJoinResponse> responseActionListener) {     assertSame(publishRequest, this.publishRequest).     assertNull(pendingPublications.put(destination, responseActionListener)). }
false;protected;3;10;;@Override protected void sendApplyCommit(DiscoveryNode destination, ApplyCommitRequest applyCommit, ActionListener<TransportResponse.Empty> responseActionListener) {     if (this.applyCommit == null) {         this.applyCommit = applyCommit.     } else {         assertSame(applyCommit, this.applyCommit).     }     assertNull(pendingCommits.put(destination, responseActionListener)). }
false;private;1;8;;private void initializeCluster(VotingConfiguration initialConfig) {     node1.coordinationState.setInitialState(CoordinationStateTests.clusterState(0L, 0L, n1, initialConfig, initialConfig, 0L)).     StartJoinRequest startJoinRequest = new StartJoinRequest(n1, 1L).     node1.coordinationState.handleJoin(node1.coordinationState.handleStartJoin(startJoinRequest)).     node1.coordinationState.handleJoin(node2.coordinationState.handleStartJoin(startJoinRequest)).     node1.coordinationState.handleJoin(node3.coordinationState.handleStartJoin(startJoinRequest)).     assertTrue(node1.coordinationState.electionWon()). }
false;public;0;75;;public void testSimpleClusterStatePublishing() throws InterruptedException {     VotingConfiguration singleNodeConfig = new VotingConfiguration(Sets.newHashSet(n1.getId())).     initializeCluster(singleNodeConfig).     AssertingAckListener ackListener = new AssertingAckListener(nodes.size()).     DiscoveryNodes discoveryNodes = DiscoveryNodes.builder().add(n1).add(n2).add(n3).localNodeId(n1.getId()).build().     MockPublication publication = node1.publish(CoordinationStateTests.clusterState(1L, 2L, discoveryNodes, singleNodeConfig, singleNodeConfig, 42L), ackListener, Collections.emptySet()).     assertThat(publication.pendingPublications.keySet(), equalTo(discoNodes)).     assertThat(publication.completedNodes(), empty()).     assertTrue(publication.pendingCommits.isEmpty()).     AtomicBoolean processedNode1PublishResponse = new AtomicBoolean().     boolean delayProcessingNode2PublishResponse = randomBoolean().     publication.pendingPublications.entrySet().stream().collect(shuffle()).forEach(e -> {         if (delayProcessingNode2PublishResponse && e.getKey().equals(n2)) {             return.         }         PublishResponse publishResponse = nodeResolver.apply(e.getKey()).coordinationState.handlePublishRequest(publication.publishRequest).         assertNotEquals(processedNode1PublishResponse.get(), publication.pendingCommits.isEmpty()).         assertFalse(publication.joins.containsKey(e.getKey())).         PublishWithJoinResponse publishWithJoinResponse = new PublishWithJoinResponse(publishResponse, randomBoolean() ? Optional.empty() : Optional.of(new Join(e.getKey(), randomFrom(n1, n2, n3), publishResponse.getTerm(), randomNonNegativeLong(), randomNonNegativeLong()))).         e.getValue().onResponse(publishWithJoinResponse).         if (publishWithJoinResponse.getJoin().isPresent()) {             assertTrue(publication.joins.containsKey(e.getKey())).             assertFalse(publication.missingJoins.contains(e.getKey())).             assertEquals(publishWithJoinResponse.getJoin().get(), publication.joins.get(e.getKey())).         } else {             assertFalse(publication.joins.containsKey(e.getKey())).             assertTrue(publication.missingJoins.contains(e.getKey())).         }         if (e.getKey().equals(n1)) {             processedNode1PublishResponse.set(true).         }         assertNotEquals(processedNode1PublishResponse.get(), publication.pendingCommits.isEmpty()).     }).     if (delayProcessingNode2PublishResponse) {         assertThat(publication.pendingCommits.keySet(), equalTo(Sets.newHashSet(n1, n3))).     } else {         assertThat(publication.pendingCommits.keySet(), equalTo(discoNodes)).     }     assertNotNull(publication.applyCommit).     assertEquals(publication.applyCommit.getTerm(), publication.publishRequest.getAcceptedState().term()).     assertEquals(publication.applyCommit.getVersion(), publication.publishRequest.getAcceptedState().version()).     publication.pendingCommits.entrySet().stream().collect(shuffle()).forEach(e -> {         assertFalse(publication.completed).         assertFalse(publication.committed).         nodeResolver.apply(e.getKey()).coordinationState.handleCommit(publication.applyCommit).         e.getValue().onResponse(TransportResponse.Empty.INSTANCE).     }).     if (delayProcessingNode2PublishResponse) {         assertFalse(publication.completed).         assertFalse(publication.committed).         PublishResponse publishResponse = nodeResolver.apply(n2).coordinationState.handlePublishRequest(publication.publishRequest).         publication.pendingPublications.get(n2).onResponse(new PublishWithJoinResponse(publishResponse, Optional.empty())).         assertThat(publication.pendingCommits.keySet(), equalTo(discoNodes)).         assertFalse(publication.completed).         assertFalse(publication.committed).         assertThat(publication.completedNodes(), containsInAnyOrder(n1, n3)).         publication.pendingCommits.get(n2).onResponse(TransportResponse.Empty.INSTANCE).     }     assertTrue(publication.completed).     assertThat(publication.completedNodes(), containsInAnyOrder(n1, n2, n3)).     assertTrue(publication.committed).     assertThat(ackListener.await(0L, TimeUnit.SECONDS), containsInAnyOrder(n1, n2, n3)). }
false;public;0;42;;public void testClusterStatePublishingWithFaultyNodeBeforeCommit() throws InterruptedException {     VotingConfiguration singleNodeConfig = new VotingConfiguration(Sets.newHashSet(n1.getId())).     initializeCluster(singleNodeConfig).     AssertingAckListener ackListener = new AssertingAckListener(nodes.size()).     DiscoveryNodes discoveryNodes = DiscoveryNodes.builder().add(n1).add(n2).add(n3).localNodeId(n1.getId()).build().     // number of publish actions + initial faulty nodes injection     AtomicInteger remainingActions = new AtomicInteger(4).     int injectFaultAt = randomInt(remainingActions.get() - 1).     logger.info("Injecting fault at: {}", injectFaultAt).     Set<DiscoveryNode> initialFaultyNodes = remainingActions.decrementAndGet() == injectFaultAt ? Collections.singleton(n2) : Collections.emptySet().     MockPublication publication = node1.publish(CoordinationStateTests.clusterState(1L, 2L, discoveryNodes, singleNodeConfig, singleNodeConfig, 42L), ackListener, initialFaultyNodes).     publication.pendingPublications.entrySet().stream().collect(shuffle()).forEach(e -> {         if (remainingActions.decrementAndGet() == injectFaultAt) {             publication.onFaultyNode(n2).         }         if (e.getKey().equals(n2) == false || randomBoolean()) {             PublishResponse publishResponse = nodeResolver.apply(e.getKey()).coordinationState.handlePublishRequest(publication.publishRequest).             e.getValue().onResponse(new PublishWithJoinResponse(publishResponse, Optional.empty())).         }     }).     publication.pendingCommits.entrySet().stream().collect(shuffle()).forEach(e -> {         nodeResolver.apply(e.getKey()).coordinationState.handleCommit(publication.applyCommit).         e.getValue().onResponse(TransportResponse.Empty.INSTANCE).     }).     assertTrue(publication.completed).     assertTrue(publication.committed).     // has no influence     publication.onFaultyNode(randomFrom(n1, n3)).     List<Tuple<DiscoveryNode, Throwable>> errors = ackListener.awaitErrors(0L, TimeUnit.SECONDS).     assertThat(errors.size(), equalTo(1)).     assertThat(errors.get(0).v1(), equalTo(n2)).     assertThat(errors.get(0).v2().getMessage(), containsString("faulty node")). }
false;public;0;52;;public void testClusterStatePublishingWithFaultyNodeAfterCommit() throws InterruptedException {     VotingConfiguration singleNodeConfig = new VotingConfiguration(Sets.newHashSet(n1.getId())).     initializeCluster(singleNodeConfig).     AssertingAckListener ackListener = new AssertingAckListener(nodes.size()).     DiscoveryNodes discoveryNodes = DiscoveryNodes.builder().add(n1).add(n2).add(n3).localNodeId(n1.getId()).build().     boolean publicationDidNotMakeItToNode2 = randomBoolean().     AtomicInteger remainingActions = new AtomicInteger(publicationDidNotMakeItToNode2 ? 2 : 3).     int injectFaultAt = randomInt(remainingActions.get() - 1).     logger.info("Injecting fault at: {}, publicationDidNotMakeItToNode2: {}", injectFaultAt, publicationDidNotMakeItToNode2).     MockPublication publication = node1.publish(CoordinationStateTests.clusterState(1L, 2L, discoveryNodes, singleNodeConfig, singleNodeConfig, 42L), ackListener, Collections.emptySet()).     publication.pendingPublications.entrySet().stream().collect(shuffle()).forEach(e -> {         if (e.getKey().equals(n2) == false || publicationDidNotMakeItToNode2 == false) {             PublishResponse publishResponse = nodeResolver.apply(e.getKey()).coordinationState.handlePublishRequest(publication.publishRequest).             e.getValue().onResponse(new PublishWithJoinResponse(publishResponse, Optional.empty())).         }     }).     publication.pendingCommits.entrySet().stream().collect(shuffle()).forEach(e -> {         if (e.getKey().equals(n2)) {             // we must fail node before committing for the node, otherwise failing the node is ignored             publication.onFaultyNode(n2).         }         if (remainingActions.decrementAndGet() == injectFaultAt) {             publication.onFaultyNode(n2).         }         if (e.getKey().equals(n2) == false || randomBoolean()) {             nodeResolver.apply(e.getKey()).coordinationState.handleCommit(publication.applyCommit).             e.getValue().onResponse(TransportResponse.Empty.INSTANCE).         }     }).     // we need to complete publication by failing the node     if (publicationDidNotMakeItToNode2 && remainingActions.get() > injectFaultAt) {         publication.onFaultyNode(n2).     }     assertTrue(publication.completed).     assertTrue(publication.committed).     // has no influence     publication.onFaultyNode(randomFrom(n1, n3)).     List<Tuple<DiscoveryNode, Throwable>> errors = ackListener.awaitErrors(0L, TimeUnit.SECONDS).     assertThat(errors.size(), equalTo(1)).     assertThat(errors.get(0).v1(), equalTo(n2)).     assertThat(errors.get(0).v2().getMessage(), containsString("faulty node")). }
false;public;0;38;;public void testClusterStatePublishingFailsOrTimesOutBeforeCommit() throws InterruptedException {     VotingConfiguration config = new VotingConfiguration(Sets.newHashSet(n1.getId(), n2.getId())).     initializeCluster(config).     AssertingAckListener ackListener = new AssertingAckListener(nodes.size()).     DiscoveryNodes discoveryNodes = DiscoveryNodes.builder().add(n1).add(n2).add(n3).localNodeId(n1.getId()).build().     MockPublication publication = node1.publish(CoordinationStateTests.clusterState(1L, 2L, discoveryNodes, config, config, 42L), ackListener, Collections.emptySet()).     boolean timeOut = randomBoolean().     publication.pendingPublications.entrySet().stream().collect(shuffle()).forEach(e -> {         if (e.getKey().equals(n2)) {             if (timeOut) {                 publication.cancel("timed out").             } else {                 e.getValue().onFailure(new TransportException(new Exception("dummy failure"))).             }             assertTrue(publication.completed).             assertFalse(publication.committed).         } else if (randomBoolean()) {             PublishResponse publishResponse = nodeResolver.apply(e.getKey()).coordinationState.handlePublishRequest(publication.publishRequest).             e.getValue().onResponse(new PublishWithJoinResponse(publishResponse, Optional.empty())).         }     }).     assertThat(publication.pendingCommits.keySet(), equalTo(Collections.emptySet())).     assertNull(publication.applyCommit).     assertTrue(publication.completed).     assertFalse(publication.committed).     List<Tuple<DiscoveryNode, Throwable>> errors = ackListener.awaitErrors(0L, TimeUnit.SECONDS).     assertThat(errors.size(), equalTo(3)).     assertThat(errors.stream().map(Tuple::v1).collect(Collectors.toList()), containsInAnyOrder(n1, n2, n3)).     errors.stream().forEach(tuple -> assertThat(tuple.v2().getMessage(), containsString(timeOut ? "timed out" : tuple.v1().equals(n2) ? "dummy failure" : "non-failed nodes do not form a quorum"))). }
false;public;0;15;;public void testPublishingToMastersFirst() {     VotingConfiguration singleNodeConfig = new VotingConfiguration(Sets.newHashSet(n1.getId())).     initializeCluster(singleNodeConfig).     DiscoveryNodes.Builder discoNodesBuilder = DiscoveryNodes.builder().     randomNodes(10).forEach(dn -> discoNodesBuilder.add(dn)).     DiscoveryNodes discoveryNodes = discoNodesBuilder.add(n1).localNodeId(n1.getId()).build().     MockPublication publication = node1.publish(CoordinationStateTests.clusterState(1L, 2L, discoveryNodes, singleNodeConfig, singleNodeConfig, 42L), null, Collections.emptySet()).     List<DiscoveryNode> publicationTargets = new ArrayList<>(publication.pendingPublications.keySet()).     List<DiscoveryNode> sortedPublicationTargets = new ArrayList<>(publicationTargets).     Collections.sort(sortedPublicationTargets, Comparator.comparing(n -> n.isMasterNode() == false)).     assertEquals(sortedPublicationTargets, publicationTargets). }
false;public;0;55;;public void testClusterStatePublishingTimesOutAfterCommit() throws InterruptedException {     VotingConfiguration config = new VotingConfiguration(randomBoolean() ? Sets.newHashSet(n1.getId(), n2.getId()) : Sets.newHashSet(n1.getId(), n2.getId(), n3.getId())).     initializeCluster(config).     AssertingAckListener ackListener = new AssertingAckListener(nodes.size()).     DiscoveryNodes discoveryNodes = DiscoveryNodes.builder().add(n1).add(n2).add(n3).localNodeId(n1.getId()).build().     MockPublication publication = node1.publish(CoordinationStateTests.clusterState(1L, 2L, discoveryNodes, config, config, 42L), ackListener, Collections.emptySet()).     boolean publishedToN3 = randomBoolean().     publication.pendingPublications.entrySet().stream().collect(shuffle()).forEach(e -> {         if (e.getKey().equals(n3) == false || publishedToN3) {             PublishResponse publishResponse = nodeResolver.apply(e.getKey()).coordinationState.handlePublishRequest(publication.publishRequest).             e.getValue().onResponse(new PublishWithJoinResponse(publishResponse, Optional.empty())).         }     }).     assertNotNull(publication.applyCommit).     Set<DiscoveryNode> committingNodes = new HashSet<>(randomSubsetOf(discoNodes)).     if (publishedToN3 == false) {         committingNodes.remove(n3).     }     logger.info("Committing nodes: {}", committingNodes).     publication.pendingCommits.entrySet().stream().collect(shuffle()).forEach(e -> {         if (committingNodes.contains(e.getKey())) {             nodeResolver.apply(e.getKey()).coordinationState.handleCommit(publication.applyCommit).             e.getValue().onResponse(TransportResponse.Empty.INSTANCE).         }     }).     publication.cancel("timed out").     assertTrue(publication.completed).     assertTrue(publication.committed).     assertEquals(committingNodes, ackListener.await(0L, TimeUnit.SECONDS)).     // check that acking still works after publication completed     if (publishedToN3 == false) {         publication.pendingPublications.get(n3).onResponse(new PublishWithJoinResponse(node3.coordinationState.handlePublishRequest(publication.publishRequest), Optional.empty())).     }     assertEquals(discoNodes, publication.pendingCommits.keySet()).     Set<DiscoveryNode> nonCommittedNodes = Sets.difference(discoNodes, committingNodes).     logger.info("Non-committed nodes: {}", nonCommittedNodes).     nonCommittedNodes.stream().collect(shuffle()).forEach(n -> publication.pendingCommits.get(n).onResponse(TransportResponse.Empty.INSTANCE)).     assertEquals(discoNodes, ackListener.await(0L, TimeUnit.SECONDS)). }
false;private,static;1;13;;private static List<DiscoveryNode> randomNodes(final int numNodes) {     List<DiscoveryNode> nodesList = new ArrayList<>().     for (int i = 0. i < numNodes. i++) {         Map<String, String> attributes = new HashMap<>().         if (frequently()) {             attributes.put("custom", randomBoolean() ? "match" : randomAlphaOfLengthBetween(3, 5)).         }         final DiscoveryNode node = newNode(i, attributes, new HashSet<>(randomSubsetOf(Arrays.asList(DiscoveryNode.Role.values())))).         nodesList.add(node).     }     return nodesList. }
false;private,static;3;4;;private static DiscoveryNode newNode(int nodeId, Map<String, String> attributes, Set<DiscoveryNode.Role> roles) {     return new DiscoveryNode("name_" + nodeId, "node_" + nodeId, buildNewFakeTransportAddress(), attributes, roles, Version.CURRENT). }
false;public,static;0;7;;public static <T> Collector<T, ?, Stream<T>> shuffle() {     return Collectors.collectingAndThen(Collectors.toList(), ts -> {         Collections.shuffle(ts, random()).         return ts.stream().     }). }
