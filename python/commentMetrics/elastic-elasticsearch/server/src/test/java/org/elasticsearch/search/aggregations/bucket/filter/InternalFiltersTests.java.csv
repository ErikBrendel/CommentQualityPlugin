commented;modifiers;parameterAmount;loc;comment;code
false;public;0;15;;@Override public void setUp() throws Exception {     super.setUp().     keyed = randomBoolean().     keys = new ArrayList<>().     int numBuckets = randomNumberOfBuckets().     for (int i = 0. i < numBuckets. i++) {         if (keyed) {             keys.add(randomAlphaOfLength(5)).         } else {             // this is what the FiltersAggregationBuilder ctor does when not providing KeyedFilter             keys.add(String.valueOf(i)).         }     } }
false;protected;4;11;;@Override protected InternalFilters createTestInstance(String name, List<PipelineAggregator> pipelineAggregators, Map<String, Object> metaData, InternalAggregations aggregations) {     final List<InternalFilters.InternalBucket> buckets = new ArrayList<>().     for (int i = 0. i < keys.size(). ++i) {         String key = keys.get(i).         int docCount = randomIntBetween(0, 1000).         buckets.add(new InternalFilters.InternalBucket(key, docCount, aggregations, keyed)).     }     return new InternalFilters(name, buckets, keyed, pipelineAggregators, metaData). }
false;protected;2;16;;@Override protected void assertReduced(InternalFilters reduced, List<InternalFilters> inputs) {     final Map<String, Long> expectedCounts = new TreeMap<>().     for (InternalFilters input : inputs) {         for (InternalFilters.InternalBucket bucket : input.getBuckets()) {             expectedCounts.compute(bucket.getKeyAsString(), (key, oldValue) -> (oldValue == null ? 0 : oldValue) + bucket.getDocCount()).         }     }     final Map<String, Long> actualCounts = new TreeMap<>().     for (InternalFilters.InternalBucket bucket : reduced.getBuckets()) {         actualCounts.compute(bucket.getKeyAsString(), (key, oldValue) -> (oldValue == null ? 0 : oldValue) + bucket.getDocCount()).     }     assertEquals(expectedCounts, actualCounts). }
false;protected;0;4;;@Override protected Reader<InternalFilters> instanceReader() {     return InternalFilters::new. }
false;protected;0;4;;@Override protected Class<? extends ParsedMultiBucketAggregation> implementationClass() {     return ParsedFilters.class. }
false;protected;1;26;;@Override protected InternalFilters mutateInstance(InternalFilters instance) {     String name = instance.getName().     List<InternalBucket> buckets = instance.getBuckets().     List<PipelineAggregator> pipelineAggregators = instance.pipelineAggregators().     Map<String, Object> metaData = instance.getMetaData().     switch(between(0, 2)) {         case 0:             name += randomAlphaOfLength(5).             break.         case 1:             buckets = new ArrayList<>(buckets).             buckets.add(new InternalFilters.InternalBucket("test", randomIntBetween(0, 1000), InternalAggregations.EMPTY, keyed)).             break.         case 2:         default:             if (metaData == null) {                 metaData = new HashMap<>(1).             } else {                 metaData = new HashMap<>(instance.getMetaData()).             }             metaData.put(randomAlphaOfLength(15), randomInt()).             break.     }     return new InternalFilters(name, buckets, keyed, pipelineAggregators, metaData). }
