commented;modifiers;parameterAmount;loc;comment;code
false;;0;3;;int value() {     return value. }
false;public;0;4;;@Override public EnumSet<MetaData.XContentContext> context() {     return MetaData.ALL_CONTEXTS. }
false;public;1;4;;@Override public Diff<MetaData.Custom> diff(final MetaData.Custom previousState) {     return null. }
false;public;1;4;;@Override public void writeTo(final StreamOutput out) throws IOException {     out.writeInt(value). }
false;public;2;5;;@Override public XContentBuilder toXContent(XContentBuilder builder, Params params) throws IOException {     builder.field(VALUE.getPreferredName(), value).     return builder. }
false;public;0;4;;@Override public String getWriteableName() {     return TYPE. }
false;public;0;4;;@Override public Version getMinimalSupportedVersion() {     return Version.CURRENT. }
false;public;0;4;;@Override public Optional<String> getRequiredFeature() {     return Optional.of("node"). }
false;public;0;4;;@Override public String getWriteableName() {     return TYPE. }
false;public;0;4;;@Override public Version getMinimalSupportedVersion() {     return Version.CURRENT. }
false;public;0;4;;@Override public Optional<String> getRequiredFeature() {     return requiredFeature. }
false;protected;3;5;;protected <T extends MetaData.Custom> void registerMetaDataCustom(final String name, final Writeable.Reader<T> reader, final CheckedFunction<XContentParser, T, IOException> parser) {     namedWritables.add(new NamedWriteableRegistry.Entry(MetaData.Custom.class, name, reader)).     namedXContents.add(new NamedXContentRegistry.Entry(MetaData.Custom.class, new ParseField(name), parser)). }
false;protected,abstract;0;1;;protected abstract void registerBuiltinWritables().
false;protected,abstract;0;1;;protected abstract String getType().
false;protected,abstract;0;1;;protected abstract Custom getInstance().
false;public;0;4;;@Override public List<NamedWriteableRegistry.Entry> getNamedWriteables() {     return namedWritables. }
false;public;0;4;;@Override public List<NamedXContentRegistry.Entry> getNamedXContent() {     return namedXContents. }
false;public;1;10;;@Override public ClusterState execute(ClusterState currentState) {     if (currentState.custom(getType()) == null) {         final MetaData.Builder builder = MetaData.builder(currentState.metaData()).         builder.putCustom(getType(), getInstance()).         return ClusterState.builder(currentState).metaData(builder).build().     } else {         return currentState.     } }
false;public;2;4;;@Override public void onFailure(String source, Exception e) {     throw new AssertionError(e). }
false;public;9;47;;@Override public Collection<Object> createComponents(final Client client, final ClusterService clusterService, final ThreadPool threadPool, final ResourceWatcherService resourceWatcherService, final ScriptService scriptService, final NamedXContentRegistry xContentRegistry, final Environment environment, final NodeEnvironment nodeEnvironment, final NamedWriteableRegistry namedWriteableRegistry) {     clusterService.addListener(event -> {         final ClusterState state = event.state().         if (state.getBlocks().hasGlobalBlock(STATE_NOT_RECOVERED_BLOCK)) {             return.         }         final MetaData metaData = state.metaData().         if (state.nodes().isLocalNodeElectedMaster()) {             if (metaData.custom(getType()) == null) {                 if (installed.compareAndSet(false, true)) {                     clusterService.submitStateUpdateTask("install-metadata-custom", new ClusterStateUpdateTask(Priority.URGENT) {                          @Override                         public ClusterState execute(ClusterState currentState) {                             if (currentState.custom(getType()) == null) {                                 final MetaData.Builder builder = MetaData.builder(currentState.metaData()).                                 builder.putCustom(getType(), getInstance()).                                 return ClusterState.builder(currentState).metaData(builder).build().                             } else {                                 return currentState.                             }                         }                          @Override                         public void onFailure(String source, Exception e) {                             throw new AssertionError(e).                         }                     }).                 }             }         }     }).     return Collections.emptyList(). }
false;public;0;3;;public Optional<String> getFeature() {     return Optional.of("node"). }
false;protected;0;9;;@Override protected void registerBuiltinWritables() {     registerMetaDataCustom(NodeCustom.TYPE, NodeCustom::new, parser -> {         throw new IOException(new UnsupportedOperationException()).     }). }
false;protected;0;4;;@Override protected String getType() {     return NodeCustom.TYPE. }
false;protected;0;4;;@Override protected Custom getInstance() {     return new NodeCustom(VALUE). }
false;protected;0;4;;@Override protected Optional<String> getFeature() {     return Optional.of("node-and-transport-client"). }
false;protected;0;9;;@Override protected void registerBuiltinWritables() {     registerMetaDataCustom(NodeAndTransportClientCustom.TYPE, NodeAndTransportClientCustom::new, parser -> {         throw new IOException(new UnsupportedOperationException()).     }). }
false;protected;0;4;;@Override protected String getType() {     return NodeAndTransportClientCustom.TYPE. }
false;protected;0;4;;@Override protected Custom getInstance() {     return new NodeAndTransportClientCustom(VALUE). }
false;protected;0;4;;@Override protected Collection<Class<? extends Plugin>> nodePlugins() {     return Arrays.asList(NodePlugin.class, NodeAndTransportClientPlugin.class). }
false;protected;0;4;;@Override protected Collection<Class<? extends Plugin>> transportClientPlugins() {     return Collections.singletonList(NodeAndTransportClientPlugin.class). }
false;public;0;14;;public void testOptionalCustoms() throws Exception {     // ensure that the customs are injected into the cluster state     assertBusy(() -> assertTrue(clusterService().state().metaData().customs().containsKey(NodeCustom.TYPE))).     assertBusy(() -> assertTrue(clusterService().state().metaData().customs().containsKey(NodeAndTransportClientCustom.TYPE))).     final ClusterStateResponse state = internalCluster().transportClient().admin().cluster().prepareState().get().     final ImmutableOpenMap<String, MetaData.Custom> customs = state.getState().metaData().customs().     final Set<String> keys = new HashSet<>(Arrays.asList(customs.keys().toArray(String.class))).     assertThat(keys, hasItem(IndexGraveyard.TYPE)).     assertThat(keys, not(hasItem(NodeCustom.TYPE))).     assertThat(keys, hasItem(NodeAndTransportClientCustom.TYPE)).     final MetaData.Custom actual = customs.get(NodeAndTransportClientCustom.TYPE).     assertThat(actual, instanceOf(NodeAndTransportClientCustom.class)).     assertThat(((NodeAndTransportClientCustom) actual).value(), equalTo(NodeAndTransportClientPlugin.VALUE)). }
