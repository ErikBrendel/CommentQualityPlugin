commented;modifiers;parameterAmount;loc;comment;code
false;public;2;4;;@Override public Map<String, Repository.Factory> getRepositories(Environment env, NamedXContentRegistry namedXContentRegistry) {     return Collections.singletonMap("mock", (metadata) -> new MockRepository(metadata, env, namedXContentRegistry)). }
false;public;0;4;;@Override public List<Setting<?>> getSettings() {     return Arrays.asList(USERNAME_SETTING, PASSWORD_SETTING). }
false;public;0;3;;public long getFailureCount() {     return failureCounter.get(). }
false;public;3;7;;@Override public void initializeSnapshot(SnapshotId snapshotId, List<IndexId> indices, MetaData clusterMetadata) {     if (blockOnInitialization) {         blockExecution().     }     super.initializeSnapshot(snapshotId, indices, clusterMetadata). }
false;private,static;2;12;;private static RepositoryMetaData overrideSettings(RepositoryMetaData metadata, Environment environment) {     // this is super duper hacky     if (metadata.settings().getAsBoolean("localize_location", false)) {         Path location = PathUtils.get(metadata.settings().get("location")).         location = location.resolve(Integer.toString(environment.hashCode())).         return new RepositoryMetaData(metadata.name(), metadata.type(), Settings.builder().put(metadata.settings()).put("location", location.toAbsolutePath()).build()).     } else {         return metadata.     } }
false;private;0;3;;private long incrementAndGetFailureCount() {     return failureCounter.incrementAndGet(). }
false;protected;0;5;;@Override protected void doStop() {     unblock().     super.doStop(). }
false;protected;0;4;;@Override protected BlobStore createBlobStore() throws Exception {     return new MockBlobStore(super.createBlobStore()). }
false;public,synchronized;0;10;;public synchronized void unblock() {     blocked = false.     // Clean blocking flags, so we wouldn't try to block again     blockOnDataFiles = false.     blockOnControlFiles = false.     blockOnInitialization = false.     blockOnWriteIndexFile = false.     blockAndFailOnWriteSnapFile = false.     this.notifyAll(). }
false;public;1;3;;public void blockOnDataFiles(boolean blocked) {     blockOnDataFiles = blocked. }
false;public;1;3;;public void setBlockAndFailOnWriteSnapFiles(boolean blocked) {     blockAndFailOnWriteSnapFile = blocked. }
false;public;1;3;;public void setBlockOnWriteIndexFile(boolean blocked) {     blockOnWriteIndexFile = blocked. }
false;public;0;3;;public boolean blocked() {     return blocked. }
false;private,synchronized;0;16;;private synchronized boolean blockExecution() {     logger.debug("[{}] Blocking execution", metadata.name()).     boolean wasBlocked = false.     try {         while (blockOnDataFiles || blockOnControlFiles || blockOnInitialization || blockOnWriteIndexFile || blockAndFailOnWriteSnapFile) {             blocked = true.             this.wait().             wasBlocked = true.         }     } catch (InterruptedException ex) {         Thread.currentThread().interrupt().     }     logger.debug("[{}] Unblocking execution", metadata.name()).     return wasBlocked. }
false;private;1;10;;private long incrementAndGet(String path) {     AtomicLong value = accessCounts.get(path).     if (value == null) {         value = accessCounts.putIfAbsent(path, new AtomicLong(1)).     }     if (value != null) {         return value.incrementAndGet().     }     return 1. }
false;public;1;4;;@Override public BlobContainer blobContainer(BlobPath path) {     return new MockBlobContainer(super.blobContainer(path)). }
false;private;2;10;;private boolean shouldFail(String blobName, double probability) {     if (probability > 0.0) {         String path = path().add(blobName).buildAsString() + randomPrefix.         path += "/" + incrementAndGet(path).         logger.info("checking [{}] [{}]", path, Math.abs(hashCode(path)) < Integer.MAX_VALUE * probability).         return Math.abs(hashCode(path)) < Integer.MAX_VALUE * probability.     } else {         return false.     } }
false;private;1;11;;private int hashCode(String path) {     try {         digest = MessageDigest.getInstance("MD5").         byte[] bytes = digest.digest(path.getBytes("UTF-8")).         int i = 0.         return ((bytes[i++] & 0xFF) << 24) | ((bytes[i++] & 0xFF) << 16) | ((bytes[i++] & 0xFF) << 8) | (bytes[i++] & 0xFF).     } catch (NoSuchAlgorithmException | UnsupportedEncodingException ex) {         throw new ElasticsearchException("cannot calculate hashcode", ex).     } }
false;private;1;23;;private void maybeIOExceptionOrBlock(String blobName) throws IOException {     if (blobName.startsWith("__")) {         if (shouldFail(blobName, randomDataFileIOExceptionRate) && (incrementAndGetFailureCount() < maximumNumberOfFailures)) {             logger.info("throwing random IOException for file [{}] at path [{}]", blobName, path()).             if (useLuceneCorruptionException) {                 throw new CorruptIndexException("Random corruption", "random file").             } else {                 throw new IOException("Random IOException").             }         } else if (blockOnDataFiles) {             blockExecutionAndMaybeWait(blobName).         }     } else {         if (shouldFail(blobName, randomControlIOExceptionRate) && (incrementAndGetFailureCount() < maximumNumberOfFailures)) {             logger.info("throwing random IOException for file [{}] at path [{}]", blobName, path()).             throw new IOException("Random IOException").         } else if (blockOnControlFiles) {             blockExecutionAndMaybeWait(blobName).         } else if (blobName.startsWith("snap-") && blockAndFailOnWriteSnapFile) {             blockExecutionAndFail(blobName).         }     } }
false;private;1;12;;private void blockExecutionAndMaybeWait(final String blobName) {     logger.info("[{}] blocking I/O operation for file [{}] at path [{}]", metadata.name(), blobName, path()).     if (blockExecution() && waitAfterUnblock > 0) {         try {             // Delay operation after unblocking             // So, we can start node shutdown while this operation is still running.             Thread.sleep(waitAfterUnblock).         } catch (InterruptedException ex) {         //          }     } }
true;private;1;5;/**  * Blocks an I/O operation on the blob fails and throws an exception when unblocked  */ ;/**  * Blocks an I/O operation on the blob fails and throws an exception when unblocked  */ private void blockExecutionAndFail(final String blobName) throws IOException {     logger.info("blocking I/O operation for file [{}] at path [{}]", blobName, path()).     blockExecution().     throw new IOException("exception after block"). }
false;public;1;4;;@Override public boolean blobExists(String blobName) {     return super.blobExists(blobName). }
false;public;1;5;;@Override public InputStream readBlob(String name) throws IOException {     maybeIOExceptionOrBlock(name).     return super.readBlob(name). }
false;public;1;5;;@Override public void deleteBlob(String blobName) throws IOException {     maybeIOExceptionOrBlock(blobName).     super.deleteBlob(blobName). }
false;public;1;5;;@Override public void deleteBlobIgnoringIfNotExists(String blobName) throws IOException {     maybeIOExceptionOrBlock(blobName).     super.deleteBlobIgnoringIfNotExists(blobName). }
false;public;0;5;;@Override public Map<String, BlobMetaData> listBlobs() throws IOException {     maybeIOExceptionOrBlock("").     return super.listBlobs(). }
false;public;1;5;;@Override public Map<String, BlobMetaData> listBlobsByPrefix(String blobNamePrefix) throws IOException {     maybeIOExceptionOrBlock(blobNamePrefix).     return super.listBlobsByPrefix(blobNamePrefix). }
false;public;4;11;;@Override public void writeBlob(String blobName, InputStream inputStream, long blobSize, boolean failIfAlreadyExists) throws IOException {     maybeIOExceptionOrBlock(blobName).     super.writeBlob(blobName, inputStream, blobSize, failIfAlreadyExists).     if (RandomizedContext.current().getRandom().nextBoolean()) {         // for network based repositories, the blob may have been written but we may still         // get an error with the client connection, so an IOException here simulates this         maybeIOExceptionOrBlock(blobName).     } }
false;public;4;18;;@Override public void writeBlobAtomic(final String blobName, final InputStream inputStream, final long blobSize, final boolean failIfAlreadyExists) throws IOException {     final Random random = RandomizedContext.current().getRandom().     if ((delegate() instanceof FsBlobContainer) && (random.nextBoolean())) {         // Simulate a failure between the write and move operation in FsBlobContainer         final String tempBlobName = FsBlobContainer.tempBlobName(blobName).         super.writeBlob(tempBlobName, inputStream, blobSize, failIfAlreadyExists).         maybeIOExceptionOrBlock(blobName).         final FsBlobContainer fsBlobContainer = (FsBlobContainer) delegate().         fsBlobContainer.moveBlobAtomic(tempBlobName, blobName, failIfAlreadyExists).     } else {         // Atomic write since it is potentially supported         // by the delegating blob container         maybeIOExceptionOrBlock(blobName).         super.writeBlobAtomic(blobName, inputStream, blobSize, failIfAlreadyExists).     } }
