commented;modifiers;parameterAmount;loc;comment;code
false;public;1;4;;@Override public void onFailure(Exception e) {     logger.error("unexpected error", e). }
false;protected;0;9;;@Override protected void doRun() throws Exception {     barrier.await().     if (fail) {         handler.onFailure(node, new Exception("bla")).     } else {         handler.onResponse(node).     } }
false;public;0;56;;public void testConcurrentAccess() throws InterruptedException {     int nodeCount = scaledRandomIntBetween(10, 20).     DiscoveryNode[] allNodes = new DiscoveryNode[nodeCount].     for (int i = 0. i < nodeCount. i++) {         DiscoveryNode node = new DiscoveryNode("node_" + i, buildNewFakeTransportAddress(), emptyMap(), emptySet(), Version.CURRENT).         allNodes[i] = node.     }     BlockingClusterStatePublishResponseHandler handler = new BlockingClusterStatePublishResponseHandler(new HashSet<>(Arrays.asList(allNodes))).     int firstRound = randomIntBetween(5, nodeCount - 1).     Thread[] threads = new Thread[firstRound].     CyclicBarrier barrier = new CyclicBarrier(firstRound).     Set<DiscoveryNode> expectedFailures = new HashSet<>().     Set<DiscoveryNode> completedNodes = new HashSet<>().     for (int i = 0. i < threads.length. i++) {         final DiscoveryNode node = allNodes[i].         completedNodes.add(node).         final boolean fail = randomBoolean().         if (fail) {             expectedFailures.add(node).         }         threads[i] = new Thread(new PublishResponder(fail, node, barrier, logger, handler)).         threads[i].start().     }     // wait on the threads to finish     for (Thread t : threads) {         t.join().     }     // verify that the publisher times out     assertFalse("expected handler wait to timeout as not all nodes responded", handler.awaitAllNodes(new TimeValue(10))).     Set<DiscoveryNode> pendingNodes = new HashSet<>(Arrays.asList(handler.pendingNodes())).     assertThat(completedNodes, not(contains(pendingNodes.toArray(new DiscoveryNode[0])))).     assertThat(completedNodes.size() + pendingNodes.size(), equalTo(allNodes.length)).     int secondRound = allNodes.length - firstRound.     threads = new Thread[secondRound].     barrier = new CyclicBarrier(secondRound).     for (int i = 0. i < threads.length. i++) {         final DiscoveryNode node = allNodes[firstRound + i].         final boolean fail = randomBoolean().         if (fail) {             expectedFailures.add(node).         }         threads[i] = new Thread(new PublishResponder(fail, node, barrier, logger, handler)).         threads[i].start().     }     // wait on the threads to finish     for (Thread t : threads) {         t.join().     }     assertTrue("expected handler not to timeout as all nodes responded", handler.awaitAllNodes(new TimeValue(10))).     assertThat(handler.pendingNodes(), arrayWithSize(0)).     assertThat(handler.getFailedNodes(), equalTo(expectedFailures)). }
