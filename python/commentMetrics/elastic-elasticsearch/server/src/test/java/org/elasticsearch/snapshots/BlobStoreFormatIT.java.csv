commented;modifiers;parameterAmount;loc;comment;code
false;public;0;3;;public String getText() {     return text. }
false;public,static;1;29;;public static BlobObj fromXContent(XContentParser parser) throws IOException {     String text = null.     XContentParser.Token token = parser.currentToken().     if (token == null) {         token = parser.nextToken().     }     if (token == XContentParser.Token.START_OBJECT) {         while ((token = parser.nextToken()) != XContentParser.Token.END_OBJECT) {             if (token != XContentParser.Token.FIELD_NAME) {                 throw new ElasticsearchParseException("unexpected token [{}]", token).             }             String currentFieldName = parser.currentName().             token = parser.nextToken().             if (token.isValue()) {                 if ("text".equals(currentFieldName)) {                     text = parser.text().                 } else {                     throw new ElasticsearchParseException("unexpected field [{}]", currentFieldName).                 }             } else {                 throw new ElasticsearchParseException("unexpected token [{}]", token).             }         }     }     if (text == null) {         throw new ElasticsearchParseException("missing mandatory parameter text").     }     return new BlobObj(text). }
false;public;2;5;;@Override public XContentBuilder toXContent(XContentBuilder builder, ToXContent.Params params) throws IOException {     builder.field("text", getText()).     return builder. }
false;public;0;23;;public void testBlobStoreOperations() throws IOException {     BlobStore blobStore = createTestBlobStore().     BlobContainer blobContainer = blobStore.blobContainer(BlobPath.cleanPath()).     ChecksumBlobStoreFormat<BlobObj> checksumJSON = new ChecksumBlobStoreFormat<>(BLOB_CODEC, "%s", BlobObj::fromXContent, xContentRegistry(), false, XContentType.JSON).     ChecksumBlobStoreFormat<BlobObj> checksumSMILE = new ChecksumBlobStoreFormat<>(BLOB_CODEC, "%s", BlobObj::fromXContent, xContentRegistry(), false, XContentType.SMILE).     ChecksumBlobStoreFormat<BlobObj> checksumSMILECompressed = new ChecksumBlobStoreFormat<>(BLOB_CODEC, "%s", BlobObj::fromXContent, xContentRegistry(), true, XContentType.SMILE).     // Write blobs in different formats     checksumJSON.write(new BlobObj("checksum json"), blobContainer, "check-json").     checksumSMILE.write(new BlobObj("checksum smile"), blobContainer, "check-smile").     checksumSMILECompressed.write(new BlobObj("checksum smile compressed"), blobContainer, "check-smile-comp").     // Assert that all checksum blobs can be read by all formats     assertEquals(checksumJSON.read(blobContainer, "check-json").getText(), "checksum json").     assertEquals(checksumSMILE.read(blobContainer, "check-json").getText(), "checksum json").     assertEquals(checksumJSON.read(blobContainer, "check-smile").getText(), "checksum smile").     assertEquals(checksumSMILE.read(blobContainer, "check-smile").getText(), "checksum smile").     assertEquals(checksumJSON.read(blobContainer, "check-smile-comp").getText(), "checksum smile compressed").     assertEquals(checksumSMILE.read(blobContainer, "check-smile-comp").getText(), "checksum smile compressed"). }
false;public;0;18;;public void testCompressionIsApplied() throws IOException {     BlobStore blobStore = createTestBlobStore().     BlobContainer blobContainer = blobStore.blobContainer(BlobPath.cleanPath()).     StringBuilder veryRedundantText = new StringBuilder().     for (int i = 0. i < randomIntBetween(100, 300). i++) {         veryRedundantText.append("Blah ").     }     ChecksumBlobStoreFormat<BlobObj> checksumFormat = new ChecksumBlobStoreFormat<>(BLOB_CODEC, "%s", BlobObj::fromXContent, xContentRegistry(), false, randomBoolean() ? XContentType.SMILE : XContentType.JSON).     ChecksumBlobStoreFormat<BlobObj> checksumFormatComp = new ChecksumBlobStoreFormat<>(BLOB_CODEC, "%s", BlobObj::fromXContent, xContentRegistry(), true, randomBoolean() ? XContentType.SMILE : XContentType.JSON).     BlobObj blobObj = new BlobObj(veryRedundantText.toString()).     checksumFormatComp.write(blobObj, blobContainer, "blob-comp").     checksumFormat.write(blobObj, blobContainer, "blob-not-comp").     Map<String, BlobMetaData> blobs = blobContainer.listBlobsByPrefix("blob-").     assertEquals(blobs.size(), 2).     assertThat(blobs.get("blob-not-comp").length(), greaterThan(blobs.get("blob-comp").length())). }
false;public;0;19;;public void testBlobCorruption() throws IOException {     BlobStore blobStore = createTestBlobStore().     BlobContainer blobContainer = blobStore.blobContainer(BlobPath.cleanPath()).     String testString = randomAlphaOfLength(randomInt(10000)).     BlobObj blobObj = new BlobObj(testString).     ChecksumBlobStoreFormat<BlobObj> checksumFormat = new ChecksumBlobStoreFormat<>(BLOB_CODEC, "%s", BlobObj::fromXContent, xContentRegistry(), randomBoolean(), randomBoolean() ? XContentType.SMILE : XContentType.JSON).     checksumFormat.write(blobObj, blobContainer, "test-path").     assertEquals(checksumFormat.read(blobContainer, "test-path").getText(), testString).     randomCorruption(blobContainer, "test-path").     try {         checksumFormat.read(blobContainer, "test-path").         fail("Should have failed due to corruption").     } catch (ElasticsearchCorruptionException ex) {         assertThat(ex.getMessage(), containsString("test-path")).     } catch (EOFException ex) {     // This can happen if corrupt the byte length     } }
false;public;2;12;;@Override public XContentBuilder toXContent(XContentBuilder builder, ToXContent.Params params) throws IOException {     super.toXContent(builder, params).     // Block before finishing writing     try {         block.countDown().         unblock.await(5, TimeUnit.SECONDS).     } catch (InterruptedException ex) {         Thread.currentThread().interrupt().     }     return builder. }
false;public;0;5;;@Override public Void call() throws Exception {     checksumFormat.writeAtomic(blobObj, blobContainer, "test-blob").     return null. }
false;public;0;40;;public void testAtomicWrite() throws Exception {     final BlobStore blobStore = createTestBlobStore().     final BlobContainer blobContainer = blobStore.blobContainer(BlobPath.cleanPath()).     String testString = randomAlphaOfLength(randomInt(10000)).     final CountDownLatch block = new CountDownLatch(1).     final CountDownLatch unblock = new CountDownLatch(1).     final BlobObj blobObj = new BlobObj(testString) {          @Override         public XContentBuilder toXContent(XContentBuilder builder, ToXContent.Params params) throws IOException {             super.toXContent(builder, params).             // Block before finishing writing             try {                 block.countDown().                 unblock.await(5, TimeUnit.SECONDS).             } catch (InterruptedException ex) {                 Thread.currentThread().interrupt().             }             return builder.         }     }.     final ChecksumBlobStoreFormat<BlobObj> checksumFormat = new ChecksumBlobStoreFormat<>(BLOB_CODEC, "%s", BlobObj::fromXContent, xContentRegistry(), randomBoolean(), randomBoolean() ? XContentType.SMILE : XContentType.JSON).     ExecutorService threadPool = Executors.newFixedThreadPool(1).     try {         Future<Void> future = threadPool.submit(new Callable<Void>() {              @Override             public Void call() throws Exception {                 checksumFormat.writeAtomic(blobObj, blobContainer, "test-blob").                 return null.             }         }).         block.await(5, TimeUnit.SECONDS).         assertFalse(blobContainer.blobExists("test-blob")).         unblock.countDown().         future.get().         assertTrue(blobContainer.blobExists("test-blob")).     } finally {         threadPool.shutdown().     } }
false;public;4;5;;@Override public void writeBlobAtomic(String blobName, InputStream inputStream, long blobSize, boolean failIfAlreadyExists) throws IOException {     throw new IOException("Exception thrown in writeBlobAtomic() for " + blobName). }
false;public;0;25;;public void testAtomicWriteFailures() throws Exception {     final String name = randomAlphaOfLength(10).     final BlobObj blobObj = new BlobObj("test").     final ChecksumBlobStoreFormat<BlobObj> checksumFormat = new ChecksumBlobStoreFormat<>(BLOB_CODEC, "%s", BlobObj::fromXContent, xContentRegistry(), randomBoolean(), randomBoolean() ? XContentType.SMILE : XContentType.JSON).     final BlobStore blobStore = createTestBlobStore().     final BlobContainer blobContainer = blobStore.blobContainer(BlobPath.cleanPath()).     {         IOException writeBlobException = expectThrows(IOException.class, () -> {             BlobContainer wrapper = new BlobContainerWrapper(blobContainer) {                  @Override                 public void writeBlobAtomic(String blobName, InputStream inputStream, long blobSize, boolean failIfAlreadyExists) throws IOException {                     throw new IOException("Exception thrown in writeBlobAtomic() for " + blobName).                 }             }.             checksumFormat.writeAtomic(blobObj, wrapper, name).         }).         assertEquals("Exception thrown in writeBlobAtomic() for " + name, writeBlobException.getMessage()).         assertEquals(0, writeBlobException.getSuppressed().length).     } }
false;protected;0;4;;protected BlobStore createTestBlobStore() throws IOException {     Settings settings = Settings.builder().build().     return new FsBlobStore(settings, randomRepoPath()). }
false;protected;2;15;;protected void randomCorruption(BlobContainer blobContainer, String blobName) throws IOException {     byte[] buffer = new byte[(int) blobContainer.listBlobsByPrefix(blobName).get(blobName).length()].     long originalChecksum = checksum(buffer).     try (InputStream inputStream = blobContainer.readBlob(blobName)) {         Streams.readFully(inputStream, buffer).     }     do {         int location = randomIntBetween(0, buffer.length - 1).         buffer[location] = (byte) (buffer[location] ^ 42).     } while (originalChecksum == checksum(buffer)).     BytesArray bytesArray = new BytesArray(buffer).     try (StreamInput stream = bytesArray.streamInput()) {         blobContainer.writeBlob(blobName, stream, bytesArray.length(), false).     } }
false;private;1;8;;private long checksum(byte[] buffer) throws IOException {     try (BytesStreamOutput streamOutput = new BytesStreamOutput()) {         try (BufferedChecksumStreamOutput checksumOutput = new BufferedChecksumStreamOutput(streamOutput)) {             checksumOutput.write(buffer).             return checksumOutput.getChecksum().         }     } }
