commented;modifiers;parameterAmount;loc;comment;code
false;public;0;6;;@Before @Override public void setUp() throws Exception {     super.setUp().     threadPool = new TestThreadPool(getTestName()). }
false;public;0;6;;@After @Override public void tearDown() throws Exception {     threadPool.shutdown().     super.tearDown(). }
false;public;0;4;;@Override public TaskManager getTaskManager() {     return taskManager. }
false;public;2;14;;@Override public void search(final SearchRequest request, final ActionListener<SearchResponse> listener) {     requests.add(request).     int currentConcurrentSearches = counter.incrementAndGet().     if (currentConcurrentSearches > maxAllowedConcurrentSearches) {         errorHolder.set(new AssertionError("Current concurrent search [" + currentConcurrentSearches + "] is higher than is allowed [" + maxAllowedConcurrentSearches + "]")).     }     final ExecutorService executorService = rarely() ? rarelyExecutor : commonExecutor.     executorService.execute(() -> {         counter.decrementAndGet().         listener.onResponse(new SearchResponse()).     }). }
false;public;0;72;;public void testBatchExecute() throws Exception {     // Initialize dependencies of TransportMultiSearchAction     Settings settings = Settings.builder().put("node.name", TransportMultiSearchActionTests.class.getSimpleName()).build().     ActionFilters actionFilters = mock(ActionFilters.class).     when(actionFilters.filters()).thenReturn(new ActionFilter[0]).     ThreadPool threadPool = new ThreadPool(settings).     TransportService transportService = new TransportService(Settings.EMPTY, mock(Transport.class), threadPool, TransportService.NOOP_TRANSPORT_INTERCEPTOR, boundAddress -> DiscoveryNode.createLocal(settings, boundAddress.publishAddress(), UUIDs.randomBase64UUID()), null, Collections.emptySet()) {          @Override         public TaskManager getTaskManager() {             return taskManager.         }     }.     ClusterService clusterService = mock(ClusterService.class).     when(clusterService.state()).thenReturn(ClusterState.builder(new ClusterName("test")).build()).     // Keep track of the number of concurrent searches started by multi search api,     // and if there are more searches than is allowed create an error and remember that.     int maxAllowedConcurrentSearches = scaledRandomIntBetween(1, 16).     AtomicInteger counter = new AtomicInteger().     AtomicReference<AssertionError> errorHolder = new AtomicReference<>().     // randomize whether or not requests are executed asynchronously     final List<String> threadPoolNames = Arrays.asList(ThreadPool.Names.GENERIC, ThreadPool.Names.SAME).     Randomness.shuffle(threadPoolNames).     final ExecutorService commonExecutor = threadPool.executor(threadPoolNames.get(0)).     final ExecutorService rarelyExecutor = threadPool.executor(threadPoolNames.get(1)).     final Set<SearchRequest> requests = Collections.newSetFromMap(Collections.synchronizedMap(new IdentityHashMap<>())).     NodeClient client = new NodeClient(settings, threadPool) {          @Override         public void search(final SearchRequest request, final ActionListener<SearchResponse> listener) {             requests.add(request).             int currentConcurrentSearches = counter.incrementAndGet().             if (currentConcurrentSearches > maxAllowedConcurrentSearches) {                 errorHolder.set(new AssertionError("Current concurrent search [" + currentConcurrentSearches + "] is higher than is allowed [" + maxAllowedConcurrentSearches + "]")).             }             final ExecutorService executorService = rarely() ? rarelyExecutor : commonExecutor.             executorService.execute(() -> {                 counter.decrementAndGet().                 listener.onResponse(new SearchResponse()).             }).         }     }.     TransportMultiSearchAction action = new TransportMultiSearchAction(threadPool, actionFilters, transportService, clusterService, 10, System::nanoTime, client).     // Execute the multi search api and fail if we find an error after executing:     try {         /*              * Allow for a large number of search requests in a single batch as previous implementations could stack overflow if the number              * of requests in a single batch was large              */         int numSearchRequests = scaledRandomIntBetween(1, 8192).         MultiSearchRequest multiSearchRequest = new MultiSearchRequest().         multiSearchRequest.maxConcurrentSearchRequests(maxAllowedConcurrentSearches).         for (int i = 0. i < numSearchRequests. i++) {             multiSearchRequest.add(new SearchRequest()).         }         MultiSearchResponse response = ActionTestUtils.executeBlocking(action, multiSearchRequest).         assertThat(response.getResponses().length, equalTo(numSearchRequests)).         assertThat(requests.size(), equalTo(numSearchRequests)).         assertThat(errorHolder.get(), nullValue()).     } finally {         assertTrue(ESTestCase.terminate(threadPool)).     } }
false;public;0;20;;public void testDefaultMaxConcurrentSearches() {     int numDataNodes = randomIntBetween(1, 10).     DiscoveryNodes.Builder builder = DiscoveryNodes.builder().     for (int i = 0. i < numDataNodes. i++) {         builder.add(new DiscoveryNode("_id" + i, buildNewFakeTransportAddress(), Collections.emptyMap(), Collections.singleton(DiscoveryNode.Role.DATA), Version.CURRENT)).     }     builder.add(new DiscoveryNode("master", buildNewFakeTransportAddress(), Collections.emptyMap(), Collections.singleton(DiscoveryNode.Role.MASTER), Version.CURRENT)).     builder.add(new DiscoveryNode("ingest", buildNewFakeTransportAddress(), Collections.emptyMap(), Collections.singleton(DiscoveryNode.Role.INGEST), Version.CURRENT)).     ClusterState state = ClusterState.builder(new ClusterName("_name")).nodes(builder).build().     int result = TransportMultiSearchAction.defaultMaxConcurrentSearches(10, state).     assertThat(result, equalTo(10 * numDataNodes)).     state = ClusterState.builder(new ClusterName("_name")).build().     result = TransportMultiSearchAction.defaultMaxConcurrentSearches(10, state).     assertThat(result, equalTo(1)). }
