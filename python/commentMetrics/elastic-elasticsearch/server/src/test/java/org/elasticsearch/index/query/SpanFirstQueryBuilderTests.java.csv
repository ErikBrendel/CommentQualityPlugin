commented;modifiers;parameterAmount;loc;comment;code
false;protected;0;5;;@Override protected SpanFirstQueryBuilder doCreateTestQueryBuilder() {     SpanTermQueryBuilder[] spanTermQueries = new SpanTermQueryBuilderTests().createSpanTermQueryBuilders(1).     return new SpanFirstQueryBuilder(spanTermQueries[0], randomIntBetween(0, 1000)). }
false;protected;3;4;;@Override protected void doAssertLuceneQuery(SpanFirstQueryBuilder queryBuilder, Query query, SearchContext context) throws IOException {     assertThat(query, instanceOf(SpanFirstQuery.class)). }
true;public;0;25;/**  * test exception on missing `end` and `match` parameter in parser  */ ;/**  * test exception on missing `end` and `match` parameter in parser  */ public void testParseEnd() throws IOException {     {         XContentBuilder builder = XContentFactory.jsonBuilder().         builder.startObject().         builder.startObject(SpanFirstQueryBuilder.NAME).         builder.field("match").         spanTermQuery("description", "jumped").toXContent(builder, null).         builder.endObject().         builder.endObject().         ParsingException e = expectThrows(ParsingException.class, () -> parseQuery(Strings.toString(builder))).         assertTrue(e.getMessage().contains("span_first must have [end] set")).     }     {         XContentBuilder builder = XContentFactory.jsonBuilder().         builder.startObject().         builder.startObject(SpanFirstQueryBuilder.NAME).         builder.field("end", 10).         builder.endObject().         builder.endObject().         ParsingException e = expectThrows(ParsingException.class, () -> parseQuery(Strings.toString(builder))).         assertTrue(e.getMessage().contains("span_first must have [match] span query clause")).     } }
false;public;0;23;;public void testFromJson() throws IOException {     String json = "{\n" + "  \"span_first\" : {\n" + "    \"match\" : {\n" + "      \"span_term\" : {\n" + "        \"user\" : {\n" + "          \"value\" : \"kimchy\",\n" + "          \"boost\" : 1.0\n" + "        }\n" + "      }\n" + "    },\n" + "    \"end\" : 3,\n" + "    \"boost\" : 1.0\n" + "  }\n" + "}".     SpanFirstQueryBuilder parsed = (SpanFirstQueryBuilder) parseQuery(json).     checkGeneratedJson(json, parsed).     assertEquals(json, 3, parsed.end()).     assertEquals(json, "kimchy", ((SpanTermQueryBuilder) parsed.innerQuery()).value()). }
false;public;0;21;;public void testFromJsonWithNonDefaultBoostInMatchQuery() {     String json = "{\n" + "  \"span_first\" : {\n" + "    \"match\" : {\n" + "      \"span_term\" : {\n" + "        \"user\" : {\n" + "          \"value\" : \"kimchy\",\n" + "          \"boost\" : 2.0\n" + "        }\n" + "      }\n" + "    },\n" + "    \"end\" : 3,\n" + "    \"boost\" : 1.0\n" + "  }\n" + "}".     Exception exception = expectThrows(ParsingException.class, () -> parseQuery(json)).     assertThat(exception.getMessage(), equalTo("span_first [match] as a nested span clause can't have non-default boost value [2.0]")). }
