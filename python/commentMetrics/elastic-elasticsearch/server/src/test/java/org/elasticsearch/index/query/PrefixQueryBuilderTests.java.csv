commented;modifiers;parameterAmount;loc;comment;code
false;protected;0;8;;@Override protected PrefixQueryBuilder doCreateTestQueryBuilder() {     PrefixQueryBuilder query = randomPrefixQuery().     if (randomBoolean()) {         query.rewrite(getRandomRewriteMethod()).     }     return query. }
false;protected;0;12;;@Override protected Map<String, PrefixQueryBuilder> getAlternateVersions() {     Map<String, PrefixQueryBuilder> alternateVersions = new HashMap<>().     PrefixQueryBuilder prefixQuery = randomPrefixQuery().     String contentString = "{\n" + "    \"prefix\" : {\n" + "        \"" + prefixQuery.fieldName() + "\" : \"" + prefixQuery.value() + "\"\n" + "    }\n" + "}".     alternateVersions.put(contentString, prefixQuery).     return alternateVersions. }
false;private,static;0;7;;private static PrefixQueryBuilder randomPrefixQuery() {     String fieldName = randomFrom(STRING_FIELD_NAME, STRING_ALIAS_FIELD_NAME, randomAlphaOfLengthBetween(1, 10)).     String value = randomAlphaOfLengthBetween(1, 10).     return new PrefixQueryBuilder(fieldName, value). }
false;protected;3;9;;@Override protected void doAssertLuceneQuery(PrefixQueryBuilder queryBuilder, Query query, SearchContext context) throws IOException {     assertThat(query, instanceOf(PrefixQuery.class)).     PrefixQuery prefixQuery = (PrefixQuery) query.     String expectedFieldName = expectedFieldName(queryBuilder.fieldName()).     assertThat(prefixQuery.getPrefix().field(), equalTo(expectedFieldName)).     assertThat(prefixQuery.getPrefix().text(), equalTo(queryBuilder.value())). }
false;public;0;9;;public void testIllegalArguments() {     IllegalArgumentException e = expectThrows(IllegalArgumentException.class, () -> new PrefixQueryBuilder(null, "text")).     assertEquals("field name is null or empty", e.getMessage()).     e = expectThrows(IllegalArgumentException.class, () -> new PrefixQueryBuilder("", "text")).     assertEquals("field name is null or empty", e.getMessage()).     e = expectThrows(IllegalArgumentException.class, () -> new PrefixQueryBuilder("field", null)).     assertEquals("value cannot be null", e.getMessage()). }
false;public;0;8;;public void testBlendedRewriteMethod() throws IOException {     String rewrite = "top_terms_blended_freqs_10".     Query parsedQuery = parseQuery(prefixQuery("field", "val").rewrite(rewrite)).toQuery(createShardContext()).     assertThat(parsedQuery, instanceOf(PrefixQuery.class)).     PrefixQuery prefixQuery = (PrefixQuery) parsedQuery.     assertThat(prefixQuery.getPrefix(), equalTo(new Term("field", "val"))).     assertThat(prefixQuery.getRewriteMethod(), instanceOf(MultiTermQuery.TopTermsBlendedFreqScoringRewrite.class)). }
false;public;0;11;;public void testFromJson() throws IOException {     String json = "{    \"prefix\" : { \"user\" :  { \"value\" : \"ki\", \"boost\" : 2.0 } }}".     PrefixQueryBuilder parsed = (PrefixQueryBuilder) parseQuery(json).     checkGeneratedJson(json, parsed).     assertEquals(json, "ki", parsed.value()).     assertEquals(json, 2.0, parsed.boost(), 0.00001).     assertEquals(json, "user", parsed.fieldName()). }
false;public;0;8;;public void testNumeric() throws Exception {     PrefixQueryBuilder query = prefixQuery(INT_FIELD_NAME, "12*").     QueryShardContext context = createShardContext().     QueryShardException e = expectThrows(QueryShardException.class, () -> query.toQuery(context)).     assertEquals("Can only use prefix queries on keyword and text fields - not on [mapped_int] which is of type [integer]", e.getMessage()). }
false;public;0;25;;public void testParseFailsWithMultipleFields() throws IOException {     String json = "{\n" + "    \"prefix\": {\n" + "      \"user1\": {\n" + "        \"value\": \"ki\"\n" + "      },\n" + "      \"user2\": {\n" + "        \"value\": \"ki\"\n" + "      }\n" + "    }\n" + "}".     ParsingException e = expectThrows(ParsingException.class, () -> parseQuery(json)).     assertEquals("[prefix] query doesn't support multiple fields, found [user1] and [user2]", e.getMessage()).     String shortJson = "{\n" + "    \"prefix\": {\n" + "      \"user1\": \"ki\",\n" + "      \"user2\": \"ki\"\n" + "    }\n" + "}".     e = expectThrows(ParsingException.class, () -> parseQuery(shortJson)).     assertEquals("[prefix] query doesn't support multiple fields, found [user1] and [user2]", e.getMessage()). }
