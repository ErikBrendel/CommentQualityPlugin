commented;modifiers;parameterAmount;loc;comment;code
false;public,static;0;6;;@BeforeClass public static void init() {     SearchModule searchModule = new SearchModule(Settings.EMPTY, false, emptyList()).     namedWriteableRegistry = new NamedWriteableRegistry(searchModule.getNamedWriteables()).     xContentRegistry = new NamedXContentRegistry(searchModule.getNamedXContents()). }
false;public,static;0;5;;@AfterClass public static void afterClass() {     namedWriteableRegistry = null.     xContentRegistry = null. }
false;public,static;0;3;;public static CollapseBuilder randomCollapseBuilder() {     return randomCollapseBuilder(true). }
false;public,static;1;18;;public static CollapseBuilder randomCollapseBuilder(boolean multiInnerHits) {     CollapseBuilder builder = new CollapseBuilder(randomAlphaOfLength(10)).     builder.setMaxConcurrentGroupRequests(randomIntBetween(1, 48)).     int numInnerHits = randomIntBetween(0, multiInnerHits ? 5 : 1).     if (numInnerHits == 1) {         InnerHitBuilder innerHit = InnerHitBuilderTests.randomInnerHits().         builder.setInnerHits(innerHit).     } else if (numInnerHits > 1) {         List<InnerHitBuilder> innerHits = new ArrayList<>(numInnerHits).         for (int i = 0. i < numInnerHits. i++) {             innerHits.add(InnerHitBuilderTests.randomInnerHits()).         }         builder.setInnerHits(innerHits).     }     return builder. }
false;protected;0;4;;@Override protected CollapseBuilder createTestInstance() {     return randomCollapseBuilder(). }
false;protected;0;4;;@Override protected Writeable.Reader<CollapseBuilder> instanceReader() {     return CollapseBuilder::new. }
false;protected;1;25;;@Override protected CollapseBuilder mutateInstance(CollapseBuilder instance) throws IOException {     CollapseBuilder newBuilder.     switch(between(0, 2)) {         case 0:             newBuilder = new CollapseBuilder(instance.getField() + randomAlphaOfLength(10)).             newBuilder.setMaxConcurrentGroupRequests(instance.getMaxConcurrentGroupRequests()).             newBuilder.setInnerHits(instance.getInnerHits()).             break.         case 1:             newBuilder = copyInstance(instance).             newBuilder.setMaxConcurrentGroupRequests(instance.getMaxConcurrentGroupRequests() + between(1, 20)).             break.         case 2:         default:             newBuilder = copyInstance(instance).             List<InnerHitBuilder> innerHits = newBuilder.getInnerHits().             for (int i = 0. i < between(1, 5). i++) {                 innerHits.add(InnerHitBuilderTests.randomInnerHits()).             }             newBuilder.setInnerHits(innerHits).             break.     }     return newBuilder. }
false;protected;0;4;;@Override protected NamedWriteableRegistry getNamedWriteableRegistry() {     return namedWriteableRegistry. }
false;protected;0;4;;@Override protected NamedXContentRegistry xContentRegistry() {     return xContentRegistry. }
false;private;0;9;;private SearchContext mockSearchContext() {     SearchContext context = mock(SearchContext.class).     QueryShardContext shardContext = mock(QueryShardContext.class).     when(context.getQueryShardContext()).thenReturn(shardContext).     when(context.scrollContext()).thenReturn(null).     when(context.rescore()).thenReturn(null).     when(context.searchAfter()).thenReturn(null).     return context. }
false;public;0;37;;public void testBuild() throws IOException {     Directory dir = new RAMDirectory().     try (IndexWriter writer = new IndexWriter(dir, newIndexWriterConfig(new MockAnalyzer(random())))) {         writer.commit().     }     SearchContext searchContext = mockSearchContext().     try (IndexReader reader = DirectoryReader.open(dir)) {         when(searchContext.getQueryShardContext().getIndexReader()).thenReturn(reader).         MappedFieldType numberFieldType = new NumberFieldMapper.NumberFieldType(NumberFieldMapper.NumberType.LONG).         MappedFieldType keywordFieldType = new KeywordFieldMapper.KeywordFieldType().         for (MappedFieldType fieldType : new MappedFieldType[] { numberFieldType, keywordFieldType }) {             fieldType.setName("field").             fieldType.setHasDocValues(true).             when(searchContext.getQueryShardContext().fieldMapper("field")).thenReturn(fieldType).             CollapseBuilder builder = new CollapseBuilder("field").             CollapseContext collapseContext = builder.build(searchContext).             assertEquals(collapseContext.getFieldType(), fieldType).             fieldType.setIndexOptions(IndexOptions.NONE).             collapseContext = builder.build(searchContext).             assertEquals(collapseContext.getFieldType(), fieldType).             fieldType.setHasDocValues(false).             SearchContextException exc = expectThrows(SearchContextException.class, () -> builder.build(searchContext)).             assertEquals(exc.getMessage(), "cannot collapse on field `field` without `doc_values`").             fieldType.setHasDocValues(true).             builder.setInnerHits(new InnerHitBuilder()).             exc = expectThrows(SearchContextException.class, () -> builder.build(searchContext)).             assertEquals(exc.getMessage(), "cannot expand `inner_hits` for collapse field `field`, " + "only indexed field can retrieve `inner_hits`").         }     } }
false;public;0;4;;@Override public MappedFieldType clone() {     return null. }
false;public;0;4;;@Override public String typeName() {     return null. }
false;public;2;4;;@Override public Query termQuery(Object value, QueryShardContext context) {     return null. }
false;public;1;3;;public Query existsQuery(QueryShardContext context) {     return null. }
false;public;0;37;;public void testBuildWithSearchContextExceptions() {     SearchContext context = mockSearchContext().     {         CollapseBuilder builder = new CollapseBuilder("unknown_field").         SearchContextException exc = expectThrows(SearchContextException.class, () -> builder.build(context)).         assertEquals(exc.getMessage(), "no mapping found for `unknown_field` in order to collapse on").     }     {         MappedFieldType fieldType = new MappedFieldType() {              @Override             public MappedFieldType clone() {                 return null.             }              @Override             public String typeName() {                 return null.             }              @Override             public Query termQuery(Object value, QueryShardContext context) {                 return null.             }              public Query existsQuery(QueryShardContext context) {                 return null.             }         }.         fieldType.setName("field").         fieldType.setHasDocValues(true).         when(context.getQueryShardContext().fieldMapper("field")).thenReturn(fieldType).         CollapseBuilder builder = new CollapseBuilder("field").         SearchContextException exc = expectThrows(SearchContextException.class, () -> builder.build(context)).         assertEquals(exc.getMessage(), "unknown type for collapse field `field`, only keywords and numbers are accepted").     } }
false;protected;1;4;;@Override protected CollapseBuilder doParseInstance(XContentParser parser) {     return CollapseBuilder.fromXContent(parser). }
false;protected;0;5;;@Override protected String[] getShuffleFieldsExceptions() {     // disable xcontent shuffling on the highlight builder     return new String[] { "fields" }. }
