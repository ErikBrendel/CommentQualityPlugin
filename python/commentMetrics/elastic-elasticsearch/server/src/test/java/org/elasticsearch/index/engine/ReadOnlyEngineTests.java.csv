commented;modifiers;parameterAmount;loc;comment;code
false;public;0;71;;public void testReadOnlyEngine() throws Exception {     IOUtils.close(engine, store).     Engine readOnlyEngine = null.     final AtomicLong globalCheckpoint = new AtomicLong(SequenceNumbers.NO_OPS_PERFORMED).     try (Store store = createStore()) {         EngineConfig config = config(defaultSettings, store, createTempDir(), newMergePolicy(), null, null, globalCheckpoint::get).         int numDocs = scaledRandomIntBetween(10, 1000).         final SeqNoStats lastSeqNoStats.         final List<DocIdSeqNoAndTerm> lastDocIds.         try (InternalEngine engine = createEngine(config)) {             Engine.Get get = null.             for (int i = 0. i < numDocs. i++) {                 if (rarely()) {                     // gap in sequence number                     continue.                 }                 ParsedDocument doc = testParsedDocument(Integer.toString(i), null, testDocument(), new BytesArray("{}"), null).                 engine.index(new Engine.Index(newUid(doc), doc, i, primaryTerm.get(), 1, null, Engine.Operation.Origin.REPLICA, System.nanoTime(), -1, false, SequenceNumbers.UNASSIGNED_SEQ_NO, 0)).                 if (get == null || rarely()) {                     get = newGet(randomBoolean(), doc).                 }                 if (rarely()) {                     engine.flush().                 }                 globalCheckpoint.set(randomLongBetween(globalCheckpoint.get(), engine.getLocalCheckpoint())).             }             engine.syncTranslog().             engine.flush().             readOnlyEngine = new ReadOnlyEngine(engine.engineConfig, engine.getSeqNoStats(globalCheckpoint.get()), engine.getTranslogStats(), false, Function.identity()).             lastSeqNoStats = engine.getSeqNoStats(globalCheckpoint.get()).             lastDocIds = getDocIds(engine, true).             assertThat(readOnlyEngine.getLocalCheckpoint(), equalTo(lastSeqNoStats.getLocalCheckpoint())).             assertThat(readOnlyEngine.getSeqNoStats(globalCheckpoint.get()).getMaxSeqNo(), equalTo(lastSeqNoStats.getMaxSeqNo())).             assertThat(getDocIds(readOnlyEngine, false), equalTo(lastDocIds)).             for (int i = 0. i < numDocs. i++) {                 if (randomBoolean()) {                     String delId = Integer.toString(i).                     engine.delete(new Engine.Delete("test", delId, newUid(delId), primaryTerm.get())).                 }                 if (rarely()) {                     engine.flush().                 }             }             Engine.Searcher external = readOnlyEngine.acquireSearcher("test", Engine.SearcherScope.EXTERNAL).             Engine.Searcher internal = readOnlyEngine.acquireSearcher("test", Engine.SearcherScope.INTERNAL).             assertSame(external.reader(), internal.reader()).             IOUtils.close(external, internal).             // the locked down engine should still point to the previous commit             assertThat(readOnlyEngine.getLocalCheckpoint(), equalTo(lastSeqNoStats.getLocalCheckpoint())).             assertThat(readOnlyEngine.getSeqNoStats(globalCheckpoint.get()).getMaxSeqNo(), equalTo(lastSeqNoStats.getMaxSeqNo())).             assertThat(getDocIds(readOnlyEngine, false), equalTo(lastDocIds)).             try (Engine.GetResult getResult = readOnlyEngine.get(get, readOnlyEngine::acquireSearcher)) {                 assertTrue(getResult.exists()).             }         }         // Close and reopen the main engine         InternalEngineTests.trimUnsafeCommits(config).         try (InternalEngine recoveringEngine = new InternalEngine(config)) {             recoveringEngine.initializeMaxSeqNoOfUpdatesOrDeletes().             recoveringEngine.recoverFromTranslog(translogHandler, Long.MAX_VALUE).             // the locked down engine should still point to the previous commit             assertThat(readOnlyEngine.getLocalCheckpoint(), equalTo(lastSeqNoStats.getLocalCheckpoint())).             assertThat(readOnlyEngine.getSeqNoStats(globalCheckpoint.get()).getMaxSeqNo(), equalTo(lastSeqNoStats.getMaxSeqNo())).             assertThat(getDocIds(readOnlyEngine, false), equalTo(lastDocIds)).         }     } finally {         IOUtils.close(readOnlyEngine).     } }
false;public;0;30;;public void testFlushes() throws IOException {     IOUtils.close(engine, store).     Engine readOnlyEngine = null.     final AtomicLong globalCheckpoint = new AtomicLong(SequenceNumbers.NO_OPS_PERFORMED).     try (Store store = createStore()) {         EngineConfig config = config(defaultSettings, store, createTempDir(), newMergePolicy(), null, null, globalCheckpoint::get).         int numDocs = scaledRandomIntBetween(10, 1000).         try (InternalEngine engine = createEngine(config)) {             for (int i = 0. i < numDocs. i++) {                 if (rarely()) {                     // gap in sequence number                     continue.                 }                 ParsedDocument doc = testParsedDocument(Integer.toString(i), null, testDocument(), new BytesArray("{}"), null).                 engine.index(new Engine.Index(newUid(doc), doc, i, primaryTerm.get(), 1, null, Engine.Operation.Origin.REPLICA, System.nanoTime(), -1, false, SequenceNumbers.UNASSIGNED_SEQ_NO, 0)).                 if (rarely()) {                     engine.flush().                 }                 globalCheckpoint.set(i).             }             engine.syncTranslog().             engine.flushAndClose().             readOnlyEngine = new ReadOnlyEngine(engine.engineConfig, null, null, true, Function.identity()).             Engine.CommitId flush = readOnlyEngine.flush(randomBoolean(), randomBoolean()).             assertEquals(flush, readOnlyEngine.flush(randomBoolean(), randomBoolean())).         } finally {             IOUtils.close(readOnlyEngine).         }     } }
false;protected;2;4;;@Override protected void assertMaxSeqNoEqualsToGlobalCheckpoint(final long maxSeqNo, final long globalCheckpoint) { // we don't want the assertion to trip in this test }
false;public;0;33;;public void testEnsureMaxSeqNoIsEqualToGlobalCheckpoint() throws IOException {     IOUtils.close(engine, store).     Engine readOnlyEngine = null.     final AtomicLong globalCheckpoint = new AtomicLong(SequenceNumbers.NO_OPS_PERFORMED).     try (Store store = createStore()) {         EngineConfig config = config(defaultSettings, store, createTempDir(), newMergePolicy(), null, null, globalCheckpoint::get).         final int numDocs = scaledRandomIntBetween(10, 100).         try (InternalEngine engine = createEngine(config)) {             long maxSeqNo = SequenceNumbers.NO_OPS_PERFORMED.             for (int i = 0. i < numDocs. i++) {                 ParsedDocument doc = testParsedDocument(Integer.toString(i), null, testDocument(), new BytesArray("{}"), null).                 engine.index(new Engine.Index(newUid(doc), doc, i, primaryTerm.get(), 1, null, Engine.Operation.Origin.REPLICA, System.nanoTime(), -1, false, SequenceNumbers.UNASSIGNED_SEQ_NO, 0)).                 maxSeqNo = engine.getLocalCheckpoint().             }             globalCheckpoint.set(engine.getLocalCheckpoint() - 1).             engine.syncTranslog().             engine.flushAndClose().             IllegalStateException exception = expectThrows(IllegalStateException.class, () -> new ReadOnlyEngine(engine.engineConfig, null, null, true, Function.identity()) {                  @Override                 protected void assertMaxSeqNoEqualsToGlobalCheckpoint(final long maxSeqNo, final long globalCheckpoint) {                 // we don't want the assertion to trip in this test                 }             }).             assertThat(exception.getMessage(), equalTo("Maximum sequence number [" + maxSeqNo + "] from last commit does not match global checkpoint [" + globalCheckpoint.get() + "]")).         } finally {             IOUtils.close(readOnlyEngine).         }     } }
false;public;0;16;;public void testReadOnly() throws IOException {     IOUtils.close(engine, store).     final AtomicLong globalCheckpoint = new AtomicLong(SequenceNumbers.NO_OPS_PERFORMED).     try (Store store = createStore()) {         EngineConfig config = config(defaultSettings, store, createTempDir(), newMergePolicy(), null, null, globalCheckpoint::get).         store.createEmpty(Version.CURRENT.luceneVersion).         try (ReadOnlyEngine readOnlyEngine = new ReadOnlyEngine(config, null, null, true, Function.identity())) {             Class<? extends Throwable> expectedException = LuceneTestCase.TEST_ASSERTS_ENABLED ? AssertionError.class : UnsupportedOperationException.class.             expectThrows(expectedException, () -> readOnlyEngine.index(null)).             expectThrows(expectedException, () -> readOnlyEngine.delete(null)).             expectThrows(expectedException, () -> readOnlyEngine.noOp(null)).             expectThrows(UnsupportedOperationException.class, () -> readOnlyEngine.syncFlush(null, null)).         }     } }
true;public;0;16;/**  * Test that {@link ReadOnlyEngine#verifyEngineBeforeIndexClosing()} never fails  * whatever the value of the global checkpoint to check is.  */ ;/**  * Test that {@link ReadOnlyEngine#verifyEngineBeforeIndexClosing()} never fails  * whatever the value of the global checkpoint to check is.  */ public void testVerifyShardBeforeIndexClosingIsNoOp() throws IOException {     IOUtils.close(engine, store).     final AtomicLong globalCheckpoint = new AtomicLong(SequenceNumbers.NO_OPS_PERFORMED).     try (Store store = createStore()) {         EngineConfig config = config(defaultSettings, store, createTempDir(), newMergePolicy(), null, null, globalCheckpoint::get).         store.createEmpty(Version.CURRENT.luceneVersion).         try (ReadOnlyEngine readOnlyEngine = new ReadOnlyEngine(config, null, null, true, Function.identity())) {             globalCheckpoint.set(randomNonNegativeLong()).             try {                 readOnlyEngine.verifyEngineBeforeIndexClosing().             } catch (final IllegalStateException e) {                 fail("Read-only engine pre-closing verifications failed").             }         }     } }
false;public;0;31;;public void testRecoverFromTranslogAppliesNoOperations() throws IOException {     IOUtils.close(engine, store).     final AtomicLong globalCheckpoint = new AtomicLong(SequenceNumbers.NO_OPS_PERFORMED).     try (Store store = createStore()) {         EngineConfig config = config(defaultSettings, store, createTempDir(), newMergePolicy(), null, null, globalCheckpoint::get).         int numDocs = scaledRandomIntBetween(10, 1000).         try (InternalEngine engine = createEngine(config)) {             for (int i = 0. i < numDocs. i++) {                 if (rarely()) {                     // gap in sequence number                     continue.                 }                 ParsedDocument doc = testParsedDocument(Integer.toString(i), null, testDocument(), new BytesArray("{}"), null).                 engine.index(new Engine.Index(newUid(doc), doc, i, primaryTerm.get(), 1, null, Engine.Operation.Origin.REPLICA, System.nanoTime(), -1, false, SequenceNumbers.UNASSIGNED_SEQ_NO, 0)).                 if (rarely()) {                     engine.flush().                 }                 globalCheckpoint.set(i).             }             engine.syncTranslog().             engine.flushAndClose().         }         try (ReadOnlyEngine readOnlyEngine = new ReadOnlyEngine(config, null, null, true, Function.identity())) {             final TranslogHandler translogHandler = new TranslogHandler(xContentRegistry(), config.getIndexSettings()).             readOnlyEngine.initializeMaxSeqNoOfUpdatesOrDeletes().             readOnlyEngine.recoverFromTranslog(translogHandler, randomNonNegativeLong()).             assertThat(translogHandler.appliedOperations(), equalTo(0L)).         }     } }
