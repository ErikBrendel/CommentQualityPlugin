commented;modifiers;parameterAmount;loc;comment;code
false;public;1;4;;@Override public void onResponse(Object o) {     listenerCalled.countDown(). }
false;public;1;5;;@Override public void onFailure(Exception e) {     error.set(e).     listenerCalled.countDown(). }
false;public;1;5;;@Override public void onFailure(Exception e) {     error.set(e).     listenerCalled.countDown(). }
false;protected;0;4;;@Override protected void doRun() throws Exception {     future.onResponse(response). }
false;public;0;46;;public void testListenerIsCallableFromNetworkThreads() throws Throwable {     ThreadPool threadPool = new TestThreadPool("testListenerIsCallableFromNetworkThreads").     try {         final PlainListenableActionFuture<Object> future.         if (randomBoolean()) {             future = PlainListenableActionFuture.newDispatchingListenableFuture(threadPool).         } else {             future = PlainListenableActionFuture.newListenableFuture().         }         final CountDownLatch listenerCalled = new CountDownLatch(1).         final AtomicReference<Throwable> error = new AtomicReference<>().         final Object response = new Object().         future.addListener(new ActionListener<Object>() {              @Override             public void onResponse(Object o) {                 listenerCalled.countDown().             }              @Override             public void onFailure(Exception e) {                 error.set(e).                 listenerCalled.countDown().             }         }).         Thread networkThread = new Thread(new AbstractRunnable() {              @Override             public void onFailure(Exception e) {                 error.set(e).                 listenerCalled.countDown().             }              @Override             protected void doRun() throws Exception {                 future.onResponse(response).             }         }, Transports.TEST_MOCK_TRANSPORT_THREAD_PREFIX + "_testListenerIsCallableFromNetworkThread").         networkThread.start().         networkThread.join().         listenerCalled.await().         if (error.get() != null) {             throw error.get().         }     } finally {         ThreadPool.terminate(threadPool, 10, TimeUnit.SECONDS).     } }
