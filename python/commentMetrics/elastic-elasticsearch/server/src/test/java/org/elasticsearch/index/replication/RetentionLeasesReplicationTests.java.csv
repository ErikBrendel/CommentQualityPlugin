commented;modifiers;parameterAmount;loc;comment;code
false;public;0;28;;public void testSimpleSyncRetentionLeases() throws Exception {     Settings settings = Settings.builder().put(IndexSettings.INDEX_SOFT_DELETES_SETTING.getKey(), true).build().     try (ReplicationGroup group = createGroup(between(0, 2), settings)) {         group.startAll().         List<RetentionLease> leases = new ArrayList<>().         int iterations = between(1, 100).         CountDownLatch latch = new CountDownLatch(iterations).         for (int i = 0. i < iterations. i++) {             if (leases.isEmpty() == false && rarely()) {                 RetentionLease leaseToRemove = randomFrom(leases).                 leases.remove(leaseToRemove).                 group.removeRetentionLease(leaseToRemove.id(), ActionListener.wrap(latch::countDown)).             } else {                 RetentionLease newLease = group.addRetentionLease(Integer.toString(i), randomNonNegativeLong(), "test-" + i, ActionListener.wrap(latch::countDown)).                 leases.add(newLease).             }         }         RetentionLeases leasesOnPrimary = group.getPrimary().getRetentionLeases().         assertThat(leasesOnPrimary.version(), equalTo((long) iterations)).         assertThat(leasesOnPrimary.primaryTerm(), equalTo(group.getPrimary().getOperationPrimaryTerm())).         assertThat(leasesOnPrimary.leases(), containsInAnyOrder(leases.toArray(new RetentionLease[0]))).         latch.await().         for (IndexShard replica : group.getReplicas()) {             assertThat(replica.getRetentionLeases(), equalTo(leasesOnPrimary)).         }     } }
false;protected;3;4;;@Override protected void syncRetentionLeases(ShardId shardId, RetentionLeases leases, ActionListener<ReplicationResponse> listener) {     listener.onResponse(new SyncRetentionLeasesResponse(new RetentionLeaseSyncAction.Request(shardId, leases))). }
false;public;0;26;;public void testOutOfOrderRetentionLeasesRequests() throws Exception {     Settings settings = Settings.builder().put(IndexSettings.INDEX_SOFT_DELETES_SETTING.getKey(), true).build().     int numberOfReplicas = between(1, 2).     IndexMetaData indexMetaData = buildIndexMetaData(numberOfReplicas, settings, indexMapping).     try (ReplicationGroup group = new ReplicationGroup(indexMetaData) {          @Override         protected void syncRetentionLeases(ShardId shardId, RetentionLeases leases, ActionListener<ReplicationResponse> listener) {             listener.onResponse(new SyncRetentionLeasesResponse(new RetentionLeaseSyncAction.Request(shardId, leases))).         }     }) {         group.startAll().         int numLeases = between(1, 10).         List<RetentionLeaseSyncAction.Request> requests = new ArrayList<>().         for (int i = 0. i < numLeases. i++) {             PlainActionFuture<ReplicationResponse> future = new PlainActionFuture<>().             group.addRetentionLease(Integer.toString(i), randomNonNegativeLong(), "test-" + i, future).             requests.add(((SyncRetentionLeasesResponse) future.actionGet()).syncRequest).         }         RetentionLeases leasesOnPrimary = group.getPrimary().getRetentionLeases().         for (IndexShard replica : group.getReplicas()) {             Randomness.shuffle(requests).             requests.forEach(request -> group.executeRetentionLeasesSyncRequestOnReplica(request, replica)).             assertThat(replica.getRetentionLeases(), equalTo(leasesOnPrimary)).         }     } }
false;protected;3;4;;@Override protected void syncRetentionLeases(ShardId shardId, RetentionLeases leases, ActionListener<ReplicationResponse> listener) {     listener.onResponse(new SyncRetentionLeasesResponse(new RetentionLeaseSyncAction.Request(shardId, leases))). }
false;public;0;43;;public void testSyncRetentionLeasesWithPrimaryPromotion() throws Exception {     Settings settings = Settings.builder().put(IndexSettings.INDEX_SOFT_DELETES_SETTING.getKey(), true).build().     int numberOfReplicas = between(2, 4).     IndexMetaData indexMetaData = buildIndexMetaData(numberOfReplicas, settings, indexMapping).     try (ReplicationGroup group = new ReplicationGroup(indexMetaData) {          @Override         protected void syncRetentionLeases(ShardId shardId, RetentionLeases leases, ActionListener<ReplicationResponse> listener) {             listener.onResponse(new SyncRetentionLeasesResponse(new RetentionLeaseSyncAction.Request(shardId, leases))).         }     }) {         group.startAll().         int numLeases = between(1, 100).         IndexShard newPrimary = randomFrom(group.getReplicas()).         RetentionLeases latestRetentionLeasesOnNewPrimary = RetentionLeases.EMPTY.         for (int i = 0. i < numLeases. i++) {             PlainActionFuture<ReplicationResponse> addLeaseFuture = new PlainActionFuture<>().             group.addRetentionLease(Integer.toString(i), randomNonNegativeLong(), "test-" + i, addLeaseFuture).             RetentionLeaseSyncAction.Request request = ((SyncRetentionLeasesResponse) addLeaseFuture.actionGet()).syncRequest.             for (IndexShard replica : randomSubsetOf(group.getReplicas())) {                 group.executeRetentionLeasesSyncRequestOnReplica(request, replica).                 if (newPrimary == replica) {                     latestRetentionLeasesOnNewPrimary = request.getRetentionLeases().                 }             }         }         group.promoteReplicaToPrimary(newPrimary).get().         // we need to make changes to retention leases to sync it to replicas         // since we don't sync retention leases when promoting a new primary.         PlainActionFuture<ReplicationResponse> newLeaseFuture = new PlainActionFuture<>().         group.addRetentionLease("new-lease-after-promotion", randomNonNegativeLong(), "test", newLeaseFuture).         RetentionLeases leasesOnPrimary = group.getPrimary().getRetentionLeases().         assertThat(leasesOnPrimary.primaryTerm(), equalTo(group.getPrimary().getOperationPrimaryTerm())).         assertThat(leasesOnPrimary.version(), equalTo(latestRetentionLeasesOnNewPrimary.version() + 1L)).         assertThat(leasesOnPrimary.leases(), hasSize(latestRetentionLeasesOnNewPrimary.leases().size() + 1)).         RetentionLeaseSyncAction.Request request = ((SyncRetentionLeasesResponse) newLeaseFuture.actionGet()).syncRequest.         for (IndexShard replica : group.getReplicas()) {             group.executeRetentionLeasesSyncRequestOnReplica(request, replica).         }         for (IndexShard replica : group.getReplicas()) {             assertThat(replica.getRetentionLeases(), equalTo(leasesOnPrimary)).         }     } }
