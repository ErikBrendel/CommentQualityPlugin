commented;modifiers;parameterAmount;loc;comment;code
false;protected;0;4;;@Override protected Collection<Class<? extends Plugin>> getPlugins() {     return Arrays.asList(TestTaskPlugin.class). }
true;protected;0;8;/**  * Lower the queue sizes to be small enough that both bulk and searches will time out and have to be retried.  */ ;/**  * Lower the queue sizes to be small enough that both bulk and searches will time out and have to be retried.  */ @Override protected Settings nodeSettings() {     return Settings.builder().put(super.nodeSettings()).put("thread_pool.write.size", 2).put("thread_pool.write.queue_size", 0).build(). }
false;public;0;52;;public void testRetry() throws Exception {     logger.info("block the write executor").     CyclicBarrier barrier = new CyclicBarrier(2).     getInstanceFromNode(ThreadPool.class).executor(ThreadPool.Names.WRITE).execute(() -> {         try {             barrier.await().             logger.info("blocking the write executor").             barrier.await().             logger.info("unblocked the write executor").         } catch (Exception e) {             throw new RuntimeException(e).         }     }).     barrier.await().     Task task.     PlainListenableActionFuture<TestTaskPlugin.NodesResponse> future = PlainListenableActionFuture.newListenableFuture().     try {         logger.info("start a task that will store its results").         TestTaskPlugin.NodesRequest req = new TestTaskPlugin.NodesRequest("foo").         req.setShouldStoreResult(true).         req.setShouldBlock(false).         task = nodeClient().executeLocally(TestTaskPlugin.TestTaskAction.INSTANCE, req, future).         logger.info("verify that the task has started and is still running").         assertBusy(() -> {             GetTaskResponse runningTask = client().admin().cluster().prepareGetTask(new TaskId(nodeClient().getLocalNodeId(), task.getId())).get().             assertNotNull(runningTask.getTask()).             assertFalse(runningTask.getTask().isCompleted()).             assertEquals(emptyMap(), runningTask.getTask().getErrorAsMap()).             assertEquals(emptyMap(), runningTask.getTask().getResponseAsMap()).             assertFalse(future.isDone()).         }).     } finally {         logger.info("unblock the write executor").         barrier.await().     }     logger.info("wait for the task to finish").     future.get(10, TimeUnit.SECONDS).     logger.info("check that it was written successfully").     GetTaskResponse finishedTask = client().admin().cluster().prepareGetTask(new TaskId(nodeClient().getLocalNodeId(), task.getId())).get().     assertTrue(finishedTask.getTask().isCompleted()).     assertEquals(emptyMap(), finishedTask.getTask().getErrorAsMap()).     assertEquals(singletonMap("failure_count", 0), finishedTask.getTask().getResponseAsMap()). }
true;private;0;8;/**  * Get the {@linkplain NodeClient} local to the node being tested.  */ ;/**  * Get the {@linkplain NodeClient} local to the node being tested.  */ private NodeClient nodeClient() {     /*          * Luckilly our test infrastructure already returns it, but we can't          * change the return type in the superclass because it is wrapped other          * places.          */     return (NodeClient) client(). }
