commented;modifiers;parameterAmount;loc;comment;code
false;protected;0;4;;@Override protected int maxNumberOfBuckets() {     return 10. }
false;public;0;24;;@Override public void setUp() throws Exception {     super.setUp().     keys = new ArrayList<>().     // InternalAdjacencyMatrix represents the upper triangular matrix:     // 2 filters (matrix of 2x2) generates 3 buckets     // 3 filters generates 6 buckets     // 4 filters generates 10 buckets     int numFilters = randomIntBetween(2, 4).     String[] filters = new String[numFilters].     for (int i = 0. i < numFilters. i++) {         filters[i] = randomAlphaOfLength(5).     }     for (int i = 0. i < filters.length. i++) {         keys.add(filters[i]).         for (int j = i + 1. j < filters.length. j++) {             if (filters[i].compareTo(filters[j]) <= 0) {                 keys.add(filters[i] + "&" + filters[j]).             } else {                 keys.add(filters[j] + "&" + filters[i]).             }         }     } }
false;protected;4;11;;@Override protected InternalAdjacencyMatrix createTestInstance(String name, List<PipelineAggregator> pipelineAggregators, Map<String, Object> metaData, InternalAggregations aggregations) {     final List<InternalAdjacencyMatrix.InternalBucket> buckets = new ArrayList<>().     for (int i = 0. i < keys.size(). ++i) {         String key = keys.get(i).         int docCount = randomIntBetween(0, 1000).         buckets.add(new InternalAdjacencyMatrix.InternalBucket(key, docCount, aggregations)).     }     return new InternalAdjacencyMatrix(name, buckets, pipelineAggregators, metaData). }
false;protected;2;18;;@Override protected void assertReduced(InternalAdjacencyMatrix reduced, List<InternalAdjacencyMatrix> inputs) {     final Map<String, Long> expectedCounts = new TreeMap<>().     for (InternalAdjacencyMatrix input : inputs) {         for (InternalAdjacencyMatrix.InternalBucket bucket : input.getBuckets()) {             if (bucket.getDocCount() > 0) {                 expectedCounts.compute(bucket.getKeyAsString(), (key, oldValue) -> (oldValue == null ? 0 : oldValue) + bucket.getDocCount()).             }         }     }     final Map<String, Long> actualCounts = new TreeMap<>().     for (InternalAdjacencyMatrix.InternalBucket bucket : reduced.getBuckets()) {         actualCounts.compute(bucket.getKeyAsString(), (key, oldValue) -> (oldValue == null ? 0 : oldValue) + bucket.getDocCount()).     }     assertEquals(expectedCounts, actualCounts). }
false;protected;0;4;;@Override protected Reader<InternalAdjacencyMatrix> instanceReader() {     return InternalAdjacencyMatrix::new. }
false;protected;0;4;;@Override protected Class<? extends ParsedMultiBucketAggregation> implementationClass() {     return ParsedAdjacencyMatrix.class. }
false;protected;1;28;;@Override protected InternalAdjacencyMatrix mutateInstance(InternalAdjacencyMatrix instance) {     String name = instance.getName().     List<InternalAdjacencyMatrix.InternalBucket> buckets = instance.getBuckets().     List<PipelineAggregator> pipelineAggregators = instance.pipelineAggregators().     Map<String, Object> metaData = instance.getMetaData().     switch(between(0, 2)) {         case 0:             name += randomAlphaOfLength(5).             break.         case 1:             buckets = new ArrayList<>(buckets).             buckets.add(new InternalAdjacencyMatrix.InternalBucket(randomAlphaOfLength(10), randomNonNegativeLong(), InternalAggregations.EMPTY)).             break.         case 2:             if (metaData == null) {                 metaData = new HashMap<>(1).             } else {                 metaData = new HashMap<>(instance.getMetaData()).             }             metaData.put(randomAlphaOfLength(15), randomInt()).             break.         default:             throw new AssertionError("Illegal randomisation branch").     }     return new InternalAdjacencyMatrix(name, buckets, pipelineAggregators, metaData). }
