commented;modifiers;parameterAmount;loc;comment;code
false;public;0;6;;@Before public void createTask() {     task = new BulkByScrollTask(1, "test_type", "test_action", "test", TaskId.EMPTY_TASK_ID, Collections.emptyMap()).     task.setWorker(Float.POSITIVE_INFINITY, null).     workerState = task.getWorkerState(). }
false;public;0;6;;public void testBasicData() {     assertEquals(1, task.getId()).     assertEquals("test_type", task.getType()).     assertEquals("test_action", task.getAction()).     assertEquals("test", task.getDescription()). }
false;public;0;63;;public void testProgress() {     long created = 0.     long updated = 0.     long deleted = 0.     long versionConflicts = 0.     long noops = 0.     int batch = 0.     BulkByScrollTask.Status status = task.getStatus().     assertEquals(0, status.getTotal()).     assertEquals(created, status.getCreated()).     assertEquals(updated, status.getUpdated()).     assertEquals(deleted, status.getDeleted()).     assertEquals(versionConflicts, status.getVersionConflicts()).     assertEquals(batch, status.getBatches()).     assertEquals(noops, status.getNoops()).     long totalHits = randomIntBetween(10, 1000).     workerState.setTotal(totalHits).     for (long p = 0. p < totalHits. p++) {         status = task.getStatus().         assertEquals(totalHits, status.getTotal()).         assertEquals(created, status.getCreated()).         assertEquals(updated, status.getUpdated()).         assertEquals(deleted, status.getDeleted()).         assertEquals(versionConflicts, status.getVersionConflicts()).         assertEquals(batch, status.getBatches()).         assertEquals(noops, status.getNoops()).         if (randomBoolean()) {             created++.             workerState.countCreated().         } else if (randomBoolean()) {             updated++.             workerState.countUpdated().         } else {             deleted++.             workerState.countDeleted().         }         if (rarely()) {             versionConflicts++.             workerState.countVersionConflict().         }         if (rarely()) {             batch++.             workerState.countBatch().         }         if (rarely()) {             noops++.             workerState.countNoop().         }     }     status = task.getStatus().     assertEquals(totalHits, status.getTotal()).     assertEquals(created, status.getCreated()).     assertEquals(updated, status.getUpdated()).     assertEquals(deleted, status.getDeleted()).     assertEquals(versionConflicts, status.getVersionConflicts()).     assertEquals(batch, status.getBatches()).     assertEquals(noops, status.getNoops()). }
false;public;3;5;;@Override public ScheduledCancellable schedule(Runnable command, TimeValue delay, String name) {     assertThat(delay.nanos(), both(greaterThanOrEqualTo(0L)).and(lessThanOrEqualTo(maxDelay.nanos()))).     return super.schedule(command, delay, name). }
false;protected;0;7;;@Override protected void doRun() throws Exception {     boolean oldValue = done.getAndSet(true).     if (oldValue) {         throw new RuntimeException("Ran twice oh no!").     } }
false;public;1;4;;@Override public void onFailure(Exception e) {     errors.add(e). }
true;public;0;66;/**  * Furiously rethrottles a delayed request to make sure that we never run it twice.  */ ;/**  * Furiously rethrottles a delayed request to make sure that we never run it twice.  */ public void testDelayAndRethrottle() throws IOException, InterruptedException {     List<Throwable> errors = new CopyOnWriteArrayList<>().     AtomicBoolean done = new AtomicBoolean().     int threads = between(1, 10).     CyclicBarrier waitForShutdown = new CyclicBarrier(threads).     /*          * We never end up waiting this long because the test rethrottles over and over again, ratcheting down the delay a random amount          * each time.          */     float originalRequestsPerSecond = (float) randomDoubleBetween(1, 10000, true).     workerState.rethrottle(originalRequestsPerSecond).     TimeValue maxDelay = timeValueSeconds(between(1, 5)).     assertThat(maxDelay.nanos(), greaterThanOrEqualTo(0L)).     int batchSizeForMaxDelay = (int) (maxDelay.seconds() * originalRequestsPerSecond).     ThreadPool threadPool = new TestThreadPool(getTestName()) {          @Override         public ScheduledCancellable schedule(Runnable command, TimeValue delay, String name) {             assertThat(delay.nanos(), both(greaterThanOrEqualTo(0L)).and(lessThanOrEqualTo(maxDelay.nanos()))).             return super.schedule(command, delay, name).         }     }.     try {         workerState.delayPrepareBulkRequest(threadPool, timeValueNanos(System.nanoTime()), batchSizeForMaxDelay, new AbstractRunnable() {              @Override             protected void doRun() throws Exception {                 boolean oldValue = done.getAndSet(true).                 if (oldValue) {                     throw new RuntimeException("Ran twice oh no!").                 }             }              @Override             public void onFailure(Exception e) {                 errors.add(e).             }         }).         // Rethrottle on a random number of threads, one of which is this thread.         Runnable test = () -> {             try {                 int rethrottles = 0.                 while (false == done.get()) {                     float requestsPerSecond = (float) randomDoubleBetween(0, originalRequestsPerSecond * 2, true).                     workerState.rethrottle(requestsPerSecond).                     rethrottles += 1.                 }                 logger.info("Rethrottled [{}] times", rethrottles).                 waitForShutdown.await().             } catch (Exception e) {                 errors.add(e).             }         }.         for (int i = 1. i < threads. i++) {             threadPool.generic().execute(test).         }         test.run().     } finally {         // Other threads should finish up quickly as they are checking the same AtomicBoolean.         threadPool.shutdown().         threadPool.awaitTermination(10, TimeUnit.SECONDS).     }     assertThat(errors, empty()). }
false;public;1;4;;@Override public long getDelay(TimeUnit unit) {     return -1. }
false;public;1;4;;@Override public int compareTo(Delayed o) {     throw new UnsupportedOperationException(). }
false;public;0;4;;@Override public boolean cancel() {     throw new UnsupportedOperationException(). }
false;public;0;4;;@Override public boolean isCancelled() {     throw new UnsupportedOperationException(). }
false;public;3;23;;public ScheduledCancellable schedule(Runnable command, TimeValue delay, String name) {     return new ScheduledCancellable() {          @Override         public long getDelay(TimeUnit unit) {             return -1.         }          @Override         public int compareTo(Delayed o) {             throw new UnsupportedOperationException().         }          @Override         public boolean cancel() {             throw new UnsupportedOperationException().         }          @Override         public boolean isCancelled() {             throw new UnsupportedOperationException().         }     }. }
false;protected;0;3;;@Override protected void doRun() throws Exception { }
false;public;1;4;;@Override public void onFailure(Exception e) {     throw new UnsupportedOperationException(). }
false;public;0;44;;public void testDelayNeverNegative() throws IOException {     // Thread pool that returns a ScheduledFuture that claims to have a negative delay     ThreadPool threadPool = new TestThreadPool("test") {          public ScheduledCancellable schedule(Runnable command, TimeValue delay, String name) {             return new ScheduledCancellable() {                  @Override                 public long getDelay(TimeUnit unit) {                     return -1.                 }                  @Override                 public int compareTo(Delayed o) {                     throw new UnsupportedOperationException().                 }                  @Override                 public boolean cancel() {                     throw new UnsupportedOperationException().                 }                  @Override                 public boolean isCancelled() {                     throw new UnsupportedOperationException().                 }             }.         }     }.     try {         // Have the task use the thread pool to delay a task that does nothing         workerState.delayPrepareBulkRequest(threadPool, timeValueSeconds(0), 1, new AbstractRunnable() {              @Override             protected void doRun() throws Exception {             }              @Override             public void onFailure(Exception e) {                 throw new UnsupportedOperationException().             }         }).         // Even though the future returns a negative delay we just return 0 because the time is up.         assertEquals(timeValueSeconds(0), task.getStatus().getThrottledUntil()).     } finally {         threadPool.shutdown().     } }
false;public;0;9;;public void testPerfectlyThrottledBatchTime() {     workerState.rethrottle(Float.POSITIVE_INFINITY).     assertThat((double) workerState.perfectlyThrottledBatchTime(randomInt()), closeTo(0f, 0f)).     int total = between(0, 1000000).     workerState.rethrottle(1).     assertThat((double) workerState.perfectlyThrottledBatchTime(total), closeTo(TimeUnit.SECONDS.toNanos(total), TimeUnit.SECONDS.toNanos(1))). }
