commented;modifiers;parameterAmount;loc;comment;code
false;protected;0;62;;@Override protected DateHistogramAggregationBuilder createTestAggregatorBuilder() {     DateHistogramAggregationBuilder factory = new DateHistogramAggregationBuilder(randomAlphaOfLengthBetween(3, 10)).     factory.field(INT_FIELD_NAME).     if (randomBoolean()) {         factory.interval(randomIntBetween(1, 100000)).     } else {         if (randomBoolean()) {             factory.dateHistogramInterval(randomFrom(DateHistogramInterval.YEAR, DateHistogramInterval.QUARTER, DateHistogramInterval.MONTH, DateHistogramInterval.WEEK, DateHistogramInterval.DAY, DateHistogramInterval.HOUR, DateHistogramInterval.MINUTE, DateHistogramInterval.SECOND)).         } else {             int branch = randomInt(4).             switch(branch) {                 case 0:                     factory.dateHistogramInterval(DateHistogramInterval.seconds(randomIntBetween(1, 1000))).                     break.                 case 1:                     factory.dateHistogramInterval(DateHistogramInterval.minutes(randomIntBetween(1, 1000))).                     break.                 case 2:                     factory.dateHistogramInterval(DateHistogramInterval.hours(randomIntBetween(1, 1000))).                     break.                 case 3:                     factory.dateHistogramInterval(DateHistogramInterval.days(randomIntBetween(1, 1000))).                     break.                 case 4:                     factory.dateHistogramInterval(DateHistogramInterval.weeks(randomIntBetween(1, 1000))).                     break.                 default:                     throw new IllegalStateException("invalid branch: " + branch).             }         }     }     if (randomBoolean()) {         factory.extendedBounds(ExtendedBoundsTests.randomExtendedBounds()).     }     if (randomBoolean()) {         factory.format("###.##").     }     if (randomBoolean()) {         factory.keyed(randomBoolean()).     }     if (randomBoolean()) {         factory.minDocCount(randomIntBetween(0, 100)).     }     if (randomBoolean()) {         factory.missing(randomIntBetween(0, 10)).     }     if (randomBoolean()) {         factory.offset(randomIntBetween(0, 100000)).     }     if (randomBoolean()) {         List<BucketOrder> order = randomOrder().         if (order.size() == 1 && randomBoolean()) {             factory.order(order.get(0)).         } else {             factory.order(order).         }     }     return factory. }
false;private;0;26;;private List<BucketOrder> randomOrder() {     List<BucketOrder> orders = new ArrayList<>().     switch(randomInt(4)) {         case 0:             orders.add(BucketOrder.key(randomBoolean())).             break.         case 1:             orders.add(BucketOrder.count(randomBoolean())).             break.         case 2:             orders.add(BucketOrder.aggregation(randomAlphaOfLengthBetween(3, 20), randomBoolean())).             break.         case 3:             orders.add(BucketOrder.aggregation(randomAlphaOfLengthBetween(3, 20), randomAlphaOfLengthBetween(3, 20), randomBoolean())).             break.         case 4:             int numOrders = randomIntBetween(1, 3).             for (int i = 0. i < numOrders. i++) {                 orders.addAll(randomOrder()).             }             break.         default:             fail().     }     return orders. }
false;private,static;2;6;;private static Document documentForDate(String field, long millis) {     Document doc = new Document().     doc.add(new LongPoint(field, millis)).     doc.add(new SortedNumericDocValuesField(field, millis)).     return doc. }
false;public;0;63;;public void testRewriteTimeZone() throws IOException {     DateFormatter format = DateFormatter.forPattern("strict_date_optional_time").     try (Directory dir = newDirectory().         IndexWriter w = new IndexWriter(dir, newIndexWriterConfig())) {         long millis1 = DateFormatters.from(format.parse("2018-03-11T11:55:00")).toInstant().toEpochMilli().         w.addDocument(documentForDate(DATE_FIELD_NAME, millis1)).         long millis2 = DateFormatters.from(format.parse("2017-10-30T18:13:00")).toInstant().toEpochMilli().         w.addDocument(documentForDate(DATE_FIELD_NAME, millis2)).         try (IndexReader readerThatDoesntCross = DirectoryReader.open(w)) {             long millis3 = DateFormatters.from(format.parse("2018-03-25T02:44:00")).toInstant().toEpochMilli().             w.addDocument(documentForDate(DATE_FIELD_NAME, millis3)).             try (IndexReader readerThatCrosses = DirectoryReader.open(w)) {                 QueryShardContext shardContextThatDoesntCross = createShardContext(readerThatDoesntCross).                 QueryShardContext shardContextThatCrosses = createShardContext(readerThatCrosses).                 DateHistogramAggregationBuilder builder = new DateHistogramAggregationBuilder("my_date_histo").                 builder.field(DATE_FIELD_NAME).                 builder.dateHistogramInterval(DateHistogramInterval.DAY).                 // no timeZone => no rewrite                 assertNull(builder.rewriteTimeZone(shardContextThatDoesntCross)).                 assertNull(builder.rewriteTimeZone(shardContextThatCrosses)).                 // fixed timeZone => no rewrite                 ZoneId tz = ZoneOffset.ofHours(1).                 builder.timeZone(tz).                 assertSame(tz, builder.rewriteTimeZone(shardContextThatDoesntCross)).                 assertSame(tz, builder.rewriteTimeZone(shardContextThatCrosses)).                 // daylight-saving-times => rewrite if doesn't cross                 tz = ZoneId.of("Europe/Paris").                 builder.timeZone(tz).                 assertEquals(ZoneOffset.ofHours(1), builder.rewriteTimeZone(shardContextThatDoesntCross)).                 assertSame(tz, builder.rewriteTimeZone(shardContextThatCrosses)).                 // Rounded values are no longer all within the same transitions => no rewrite                 builder.dateHistogramInterval(DateHistogramInterval.MONTH).                 assertSame(tz, builder.rewriteTimeZone(shardContextThatDoesntCross)).                 assertSame(tz, builder.rewriteTimeZone(shardContextThatCrosses)).                 builder = new DateHistogramAggregationBuilder("my_date_histo").                 builder.field(DATE_FIELD_NAME).                 builder.timeZone(tz).                 // ~ 1 day                 builder.interval(1000L * 60 * 60 * 24).                 assertEquals(ZoneOffset.ofHours(1), builder.rewriteTimeZone(shardContextThatDoesntCross)).                 assertSame(tz, builder.rewriteTimeZone(shardContextThatCrosses)).                 // Because the interval is large, rounded values are not                 // within the same transitions as the values => no rewrite                 // ~ 1 month                 builder.interval(1000L * 60 * 60 * 24 * 30).                 assertSame(tz, builder.rewriteTimeZone(shardContextThatDoesntCross)).                 assertSame(tz, builder.rewriteTimeZone(shardContextThatCrosses)).             }         }     } }
