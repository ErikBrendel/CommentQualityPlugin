commented;modifiers;parameterAmount;loc;comment;code
false;public;0;11;;@Before public void startResolver() {     threadPool = new TestThreadPool("node").     transportAddresses = new ArrayList<>().     TransportService transportService = mock(TransportService.class).     when(transportService.getThreadPool()).thenReturn(threadPool).     seedHostsResolver = new SeedHostsResolver("test_node", Settings.EMPTY, transportService, hostsResolver -> transportAddresses).     seedHostsResolver.start(). }
false;public;0;5;;@After public void stopResolver() {     seedHostsResolver.stop().     threadPool.shutdown(). }
false;public;0;29;;public void testResolvesAddressesInBackgroundAndIgnoresConcurrentCalls() throws Exception {     final AtomicReference<List<TransportAddress>> resolvedAddressesRef = new AtomicReference<>().     final CountDownLatch startLatch = new CountDownLatch(1).     final CountDownLatch endLatch = new CountDownLatch(1).     final int addressCount = randomIntBetween(0, 5).     for (int i = 0. i < addressCount. i++) {         transportAddresses.add(buildNewFakeTransportAddress()).     }     seedHostsResolver.resolveConfiguredHosts(resolvedAddresses -> {         try {             assertTrue(startLatch.await(30, TimeUnit.SECONDS)).         } catch (InterruptedException e) {             throw new AssertionError(e).         }         resolvedAddressesRef.set(resolvedAddresses).         endLatch.countDown().     }).     seedHostsResolver.resolveConfiguredHosts(resolvedAddresses -> {         throw new AssertionError("unexpected concurrent resolution").     }).     assertThat(resolvedAddressesRef.get(), nullValue()).     startLatch.countDown().     assertTrue(endLatch.await(30, TimeUnit.SECONDS)).     assertThat(resolvedAddressesRef.get(), equalTo(transportAddresses)). }
