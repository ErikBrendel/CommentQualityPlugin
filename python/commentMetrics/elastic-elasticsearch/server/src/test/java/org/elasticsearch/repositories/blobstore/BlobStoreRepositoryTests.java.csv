commented;modifiers;parameterAmount;loc;comment;code
false;protected;0;3;;protected Collection<Class<? extends Plugin>> getPlugins() {     return Arrays.asList(FsLikeRepoPlugin.class). }
false;protected;0;4;;@Override protected void assertSnapshotOrGenericThread() { // eliminate thread name check as we access blobStore on test/main threads }
false;public;2;10;;@Override public Map<String, Repository.Factory> getRepositories(Environment env, NamedXContentRegistry namedXContentRegistry) {     return Collections.singletonMap(REPO_TYPE, (metadata) -> new FsRepository(metadata, env, namedXContentRegistry) {          @Override         protected void assertSnapshotOrGenericThread() {         // eliminate thread name check as we access blobStore on test/main threads         }     }). }
false;public;0;52;;public void testRetrieveSnapshots() throws Exception {     final Client client = client().     final Path location = ESIntegTestCase.randomRepoPath(node().settings()).     final String repositoryName = "test-repo".     logger.info("-->  creating repository").     AcknowledgedResponse putRepositoryResponse = client.admin().cluster().preparePutRepository(repositoryName).setType(REPO_TYPE).setSettings(Settings.builder().put(node().settings()).put("location", location)).get().     assertThat(putRepositoryResponse.isAcknowledged(), equalTo(true)).     logger.info("--> creating an index and indexing documents").     final String indexName = "test-idx".     createIndex(indexName).     ensureGreen().     int numDocs = randomIntBetween(10, 20).     for (int i = 0. i < numDocs. i++) {         String id = Integer.toString(i).         client().prepareIndex(indexName, "type1", id).setSource("text", "sometext").get().     }     client().admin().indices().prepareFlush(indexName).get().     logger.info("--> create first snapshot").     CreateSnapshotResponse createSnapshotResponse = client.admin().cluster().prepareCreateSnapshot(repositoryName, "test-snap-1").setWaitForCompletion(true).setIndices(indexName).get().     final SnapshotId snapshotId1 = createSnapshotResponse.getSnapshotInfo().snapshotId().     logger.info("--> create second snapshot").     createSnapshotResponse = client.admin().cluster().prepareCreateSnapshot(repositoryName, "test-snap-2").setWaitForCompletion(true).setIndices(indexName).get().     final SnapshotId snapshotId2 = createSnapshotResponse.getSnapshotInfo().snapshotId().     logger.info("--> make sure the node's repository can resolve the snapshots").     final RepositoriesService repositoriesService = getInstanceFromNode(RepositoriesService.class).     final BlobStoreRepository repository = (BlobStoreRepository) repositoriesService.repository(repositoryName).     final List<SnapshotId> originalSnapshots = Arrays.asList(snapshotId1, snapshotId2).     List<SnapshotId> snapshotIds = repository.getRepositoryData().getSnapshotIds().stream().sorted((s1, s2) -> s1.getName().compareTo(s2.getName())).collect(Collectors.toList()).     assertThat(snapshotIds, equalTo(originalSnapshots)). }
false;public;0;23;;public void testReadAndWriteSnapshotsThroughIndexFile() throws Exception {     final BlobStoreRepository repository = setupRepo().     // write to and read from a index file with no entries     assertThat(repository.getRepositoryData().getSnapshotIds().size(), equalTo(0)).     final RepositoryData emptyData = RepositoryData.EMPTY.     repository.writeIndexGen(emptyData, emptyData.getGenId()).     RepositoryData repoData = repository.getRepositoryData().     assertEquals(repoData, emptyData).     assertEquals(repoData.getIndices().size(), 0).     assertEquals(repoData.getSnapshotIds().size(), 0).     assertEquals(0L, repoData.getGenId()).     // write to and read from an index file with snapshots but no indices     repoData = addRandomSnapshotsToRepoData(repoData, false).     repository.writeIndexGen(repoData, repoData.getGenId()).     assertEquals(repoData, repository.getRepositoryData()).     // write to and read from a index file with random repository data     repoData = addRandomSnapshotsToRepoData(repository.getRepositoryData(), true).     repository.writeIndexGen(repoData, repoData.getGenId()).     assertEquals(repoData, repository.getRepositoryData()). }
false;public;0;24;;public void testIndexGenerationalFiles() throws Exception {     final BlobStoreRepository repository = setupRepo().     // write to index generational file     RepositoryData repositoryData = generateRandomRepoData().     repository.writeIndexGen(repositoryData, repositoryData.getGenId()).     assertThat(repository.getRepositoryData(), equalTo(repositoryData)).     assertThat(repository.latestIndexBlobId(), equalTo(0L)).     assertThat(repository.readSnapshotIndexLatestBlob(), equalTo(0L)).     // adding more and writing to a new index generational file     repositoryData = addRandomSnapshotsToRepoData(repository.getRepositoryData(), true).     repository.writeIndexGen(repositoryData, repositoryData.getGenId()).     assertEquals(repository.getRepositoryData(), repositoryData).     assertThat(repository.latestIndexBlobId(), equalTo(1L)).     assertThat(repository.readSnapshotIndexLatestBlob(), equalTo(1L)).     // removing a snapshot and writing to a new index generational file     repositoryData = repository.getRepositoryData().removeSnapshot(repositoryData.getSnapshotIds().iterator().next()).     repository.writeIndexGen(repositoryData, repositoryData.getGenId()).     assertEquals(repository.getRepositoryData(), repositoryData).     assertThat(repository.latestIndexBlobId(), equalTo(2L)).     assertThat(repository.readSnapshotIndexLatestBlob(), equalTo(2L)). }
false;public;0;11;;public void testRepositoryDataConcurrentModificationNotAllowed() throws IOException {     final BlobStoreRepository repository = setupRepo().     // write to index generational file     RepositoryData repositoryData = generateRandomRepoData().     repository.writeIndexGen(repositoryData, repositoryData.getGenId()).     // write repo data again to index generational file, errors because we already wrote to the     // N+1 generation from which this repository data instance was created     expectThrows(RepositoryException.class, () -> repository.writeIndexGen(repositoryData, repositoryData.getGenId())). }
false;public;0;26;;public void testReadAndWriteIncompatibleSnapshots() throws Exception {     final BlobStoreRepository repository = setupRepo().     // write to and read from incompatible snapshots file with no entries     assertEquals(0, repository.getRepositoryData().getIncompatibleSnapshotIds().size()).     RepositoryData emptyData = RepositoryData.EMPTY.     repository.writeIndexGen(emptyData, emptyData.getGenId()).     repository.writeIncompatibleSnapshots(emptyData).     RepositoryData readData = repository.getRepositoryData().     assertEquals(emptyData, readData).     assertEquals(0, readData.getIndices().size()).     assertEquals(0, readData.getSnapshotIds().size()).     // write to and read from incompatible snapshots with some number of entries     final int numSnapshots = randomIntBetween(1, 20).     final List<SnapshotId> snapshotIds = new ArrayList<>(numSnapshots).     for (int i = 0. i < numSnapshots. i++) {         snapshotIds.add(new SnapshotId(randomAlphaOfLength(8), UUIDs.randomBase64UUID())).     }     RepositoryData repositoryData = new RepositoryData(readData.getGenId(), Collections.emptyMap(), Collections.emptyMap(), Collections.emptyMap(), snapshotIds).     repository.blobContainer().deleteBlob("incompatible-snapshots").     repository.writeIncompatibleSnapshots(repositoryData).     readData = repository.getRepositoryData().     assertEquals(repositoryData.getIncompatibleSnapshotIds(), readData.getIncompatibleSnapshotIds()). }
false;public;0;11;;public void testIncompatibleSnapshotsBlobExists() throws Exception {     final BlobStoreRepository repository = setupRepo().     RepositoryData emptyData = RepositoryData.EMPTY.     repository.writeIndexGen(emptyData, emptyData.getGenId()).     RepositoryData repoData = repository.getRepositoryData().     assertEquals(emptyData, repoData).     assertTrue(repository.blobContainer().blobExists("incompatible-snapshots")).     repoData = addRandomSnapshotsToRepoData(repository.getRepositoryData(), true).     repository.writeIndexGen(repoData, repoData.getGenId()).     assertEquals(0, repository.getRepositoryData().getIncompatibleSnapshotIds().size()). }
false;public;0;13;;public void testBadChunksize() throws Exception {     final Client client = client().     final Path location = ESIntegTestCase.randomRepoPath(node().settings()).     final String repositoryName = "test-repo".     expectThrows(RepositoryException.class, () -> client.admin().cluster().preparePutRepository(repositoryName).setType(REPO_TYPE).setSettings(Settings.builder().put(node().settings()).put("location", location).put("chunk_size", randomLongBetween(-10, 0), ByteSizeUnit.BYTES)).get()). }
false;private;0;24;;private BlobStoreRepository setupRepo() {     final Client client = client().     final Path location = ESIntegTestCase.randomRepoPath(node().settings()).     final String repositoryName = "test-repo".     Settings.Builder repoSettings = Settings.builder().put(node().settings()).put("location", location).     boolean compress = randomBoolean().     if (compress) {         repoSettings.put(BlobStoreRepository.COMPRESS_SETTING.getKey(), true).     }     AcknowledgedResponse putRepositoryResponse = client.admin().cluster().preparePutRepository(repositoryName).setType(REPO_TYPE).setSettings(repoSettings).get().     assertThat(putRepositoryResponse.isAcknowledged(), equalTo(true)).     final RepositoriesService repositoriesService = getInstanceFromNode(RepositoriesService.class).     final BlobStoreRepository repository = (BlobStoreRepository) repositoriesService.repository(repositoryName).     assertThat("getBlobContainer has to be lazy initialized", repository.getBlobContainer(), nullValue()).     assertEquals("Compress must be set to", compress, repository.isCompress()).     return repository. }
false;private;2;14;;private RepositoryData addRandomSnapshotsToRepoData(RepositoryData repoData, boolean inclIndices) {     int numSnapshots = randomIntBetween(1, 20).     for (int i = 0. i < numSnapshots. i++) {         SnapshotId snapshotId = new SnapshotId(randomAlphaOfLength(8), UUIDs.randomBase64UUID()).         int numIndices = inclIndices ? randomIntBetween(0, 20) : 0.         List<IndexId> indexIds = new ArrayList<>(numIndices).         for (int j = 0. j < numIndices. j++) {             indexIds.add(new IndexId(randomAlphaOfLength(8), UUIDs.randomBase64UUID())).         }         repoData = repoData.addSnapshot(snapshotId, randomFrom(SnapshotState.SUCCESS, SnapshotState.PARTIAL, SnapshotState.FAILED), indexIds).     }     return repoData. }
