commented;modifiers;parameterAmount;loc;comment;code
false;public;0;4;;@Override public List<ActionHandler<? extends ActionRequest, ? extends ActionResponse>> getActions() {     return Collections.singletonList(new ActionHandler<>(TestTaskAction.INSTANCE, TransportTestTaskAction.class)). }
false;public;4;7;;@Override public List<PersistentTasksExecutor<?>> getPersistentTasksExecutor(ClusterService clusterService, ThreadPool threadPool, Client client, SettingsModule settingsModule) {     return Collections.singletonList(new TestPersistentTasksExecutor(clusterService)). }
false;public;0;7;;@Override public List<NamedWriteableRegistry.Entry> getNamedWriteables() {     return Arrays.asList(new NamedWriteableRegistry.Entry(PersistentTaskParams.class, TestPersistentTasksExecutor.NAME, TestParams::new), new NamedWriteableRegistry.Entry(PersistentTaskState.class, TestPersistentTasksExecutor.NAME, State::new)). }
false;public;0;9;;@Override public List<NamedXContentRegistry.Entry> getNamedXContent() {     return Arrays.asList(new NamedXContentRegistry.Entry(PersistentTaskParams.class, new ParseField(TestPersistentTasksExecutor.NAME), TestParams::fromXContent), new NamedXContentRegistry.Entry(PersistentTaskState.class, new ParseField(TestPersistentTasksExecutor.NAME), State::fromXContent)). }
false;public;0;4;;@Override public String getWriteableName() {     return TestPersistentTasksExecutor.NAME. }
false;public;1;3;;public void setExecutorNodeAttr(String executorNodeAttr) {     this.executorNodeAttr = executorNodeAttr. }
false;public;1;3;;public void setTestParam(String testParam) {     this.testParam = testParam. }
false;public;0;3;;public String getExecutorNodeAttr() {     return executorNodeAttr. }
false;public;0;3;;public String getTestParam() {     return testParam. }
false;public;1;8;;@Override public void writeTo(StreamOutput out) throws IOException {     out.writeOptionalString(executorNodeAttr).     out.writeOptionalString(responseNode).     out.writeOptionalString(testParam).     Version.writeVersion(minVersion, out).     out.writeOptionalString(feature.orElse(null)). }
false;public;2;7;;@Override public XContentBuilder toXContent(XContentBuilder builder, Params params) throws IOException {     builder.startObject().     builder.field("param", testParam).     builder.endObject().     return builder. }
false;public,static;1;3;;public static TestParams fromXContent(XContentParser parser) throws IOException {     return REQUEST_PARSER.parse(parser, null). }
false;public;1;9;;@Override public boolean equals(Object o) {     if (this == o)         return true.     if (o == null || getClass() != o.getClass())         return false.     TestParams that = (TestParams) o.     return Objects.equals(executorNodeAttr, that.executorNodeAttr) && Objects.equals(responseNode, that.responseNode) && Objects.equals(testParam, that.testParam). }
false;public;0;4;;@Override public int hashCode() {     return Objects.hash(executorNodeAttr, responseNode, testParam). }
false;public;0;4;;@Override public Version getMinimalSupportedVersion() {     return minVersion. }
false;public;0;4;;@Override public Optional<String> getRequiredFeature() {     return feature. }
false;public;0;4;;@Override public String getWriteableName() {     return TestPersistentTasksExecutor.NAME. }
false;public;2;7;;@Override public XContentBuilder toXContent(XContentBuilder builder, Params params) throws IOException {     builder.startObject().     builder.field("phase", phase).     builder.endObject().     return builder. }
false;public,static;1;3;;public static PersistentTaskState fromXContent(XContentParser parser) throws IOException {     return STATE_PARSER.parse(parser, null). }
false;public;0;4;;@Override public boolean isFragment() {     return false. }
false;public;1;4;;@Override public void writeTo(StreamOutput out) throws IOException {     out.writeString(phase). }
false;public;0;4;;@Override public String toString() {     return Strings.toString(this). }
true;public;1;8;// Implements equals and hashcode for testing ;// Implements equals and hashcode for testing @Override public boolean equals(Object obj) {     if (obj == null || obj.getClass() != State.class) {         return false.     }     State other = (State) obj.     return phase.equals(other.phase). }
false;public;0;4;;@Override public int hashCode() {     return phase.hashCode(). }
false;public,static;1;3;;public static void setNonClusterStateCondition(boolean nonClusterStateCondition) {     TestPersistentTasksExecutor.nonClusterStateCondition = nonClusterStateCondition. }
false;public;2;17;;@Override public Assignment getAssignment(TestParams params, ClusterState clusterState) {     if (nonClusterStateCondition == false) {         return new Assignment(null, "non cluster state condition prevents assignment").     }     if (params == null || params.getExecutorNodeAttr() == null) {         return super.getAssignment(params, clusterState).     } else {         DiscoveryNode executorNode = selectLeastLoadedNode(clusterState, discoveryNode -> params.getExecutorNodeAttr().equals(discoveryNode.getAttributes().get("test_attr"))).         if (executorNode != null) {             return new Assignment(executorNode.getId(), "test assignment").         } else {             return NO_NODE_FOUND.         }     } }
false;public;1;5;;@Override public void onResponse(PersistentTask<?> persistentTask) {     logger.info("updating was successful").     latch.countDown(). }
false;public;1;6;;@Override public void onFailure(Exception e) {     logger.info("updating failed", e).     latch.countDown().     fail(e.toString()). }
false;protected;3;61;;@Override protected void nodeOperation(AllocatedPersistentTask task, TestParams params, PersistentTaskState state) {     logger.info("started node operation for the task {}", task).     try {         TestTask testTask = (TestTask) task.         AtomicInteger phase = new AtomicInteger().         while (true) {             // wait for something to happen             assertTrue(awaitBusy(() -> testTask.isCancelled() || testTask.getOperation() != null || // speedup finishing on closed nodes             clusterService.lifecycleState() != Lifecycle.State.STARTED, 30, // This can take a while during large cluster restart             TimeUnit.SECONDS)).             if (clusterService.lifecycleState() != Lifecycle.State.STARTED) {                 return.             }             if ("finish".equals(testTask.getOperation())) {                 task.markAsCompleted().                 return.             } else if ("fail".equals(testTask.getOperation())) {                 task.markAsFailed(new RuntimeException("Simulating failure")).                 return.             } else if ("update_status".equals(testTask.getOperation())) {                 testTask.setOperation(null).                 CountDownLatch latch = new CountDownLatch(1).                 State newState = new State("phase " + phase.incrementAndGet()).                 logger.info("updating the task state to {}", newState).                 task.updatePersistentTaskState(newState, new ActionListener<PersistentTask<?>>() {                      @Override                     public void onResponse(PersistentTask<?> persistentTask) {                         logger.info("updating was successful").                         latch.countDown().                     }                      @Override                     public void onFailure(Exception e) {                         logger.info("updating failed", e).                         latch.countDown().                         fail(e.toString()).                     }                 }).                 assertTrue(latch.await(10, TimeUnit.SECONDS)).             } else if (testTask.isCancelled()) {                 // Cancellation make cause different ways for the task to finish                 if (randomBoolean()) {                     if (randomBoolean()) {                         task.markAsFailed(new TaskCancelledException(testTask.getReasonCancelled())).                     } else {                         task.markAsCompleted().                     }                 } else {                     task.markAsFailed(new RuntimeException(testTask.getReasonCancelled())).                 }                 return.             } else {                 fail("We really shouldn't be here").             }         }     } catch (InterruptedException e) {         task.markAsFailed(e).     } }
false;protected;6;5;;@Override protected AllocatedPersistentTask createTask(long id, String type, String action, TaskId parentTaskId, PersistentTask<TestParams> task, Map<String, String> headers) {     return new TestTask(id, type, action, getDescription(task), parentTaskId, headers). }
false;public;0;4;;@Override public TestTasksResponse newResponse() {     throw new UnsupportedOperationException("usage of Streamable is to be replaced by Writeable"). }
false;public;0;4;;@Override public Writeable.Reader<TestTasksResponse> getResponseReader() {     return TestTasksResponse::new. }
false;public;0;3;;public String getOperation() {     return operation. }
false;public;1;3;;public void setOperation(String operation) {     this.operation = operation. }
false;public;0;4;;@Override public String toString() {     return "TestTask[" + this.getId() + ", " + this.getParentTaskId() + ", " + this.getOperation() + "]". }
false;public;1;4;;@Override public void writeTo(StreamOutput out) throws IOException {     out.writeBoolean(true). }
false;public;1;5;;@Override public void writeTo(StreamOutput out) throws IOException {     super.writeTo(out).     out.writeOptionalString(operation). }
false;public;1;3;;public void setOperation(String operation) {     this.operation = operation. }
false;public;0;3;;public String getOperation() {     return operation. }
false;public;1;4;;public TestTasksRequestBuilder setOperation(String operation) {     request.setOperation(operation).     return this. }
false;public;1;5;;@Override public void writeTo(StreamOutput out) throws IOException {     super.writeTo(out).     out.writeList(tasks). }
false;public;0;3;;public List<TestTaskResponse> getTasks() {     return tasks. }
false;protected;4;6;;@Override protected TestTasksResponse newResponse(TestTasksRequest request, List<TestTaskResponse> tasks, List<TaskOperationFailure> taskOperationFailures, List<FailedNodeException> failedNodeExceptions) {     return new TestTasksResponse(tasks, taskOperationFailures, failedNodeExceptions). }
false;protected;3;5;;@Override protected void taskOperation(TestTasksRequest request, TestTask task, ActionListener<TestTaskResponse> listener) {     task.setOperation(request.operation).     listener.onResponse(new TestTaskResponse()). }
