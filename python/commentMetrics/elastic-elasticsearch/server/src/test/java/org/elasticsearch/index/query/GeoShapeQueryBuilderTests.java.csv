commented;modifiers;parameterAmount;loc;comment;code
false;protected;0;3;;protected String fieldName() {     return GEO_SHAPE_FIELD_NAME. }
false;protected;0;9;;@Override protected Settings createTestIndexSettings() {     // force the new shape impl     Version version = VersionUtils.randomVersionBetween(random(), Version.V_6_6_0, Version.CURRENT).     return Settings.builder().put(super.createTestIndexSettings()).put(IndexMetaData.SETTING_VERSION_CREATED, version).build(). }
false;protected;0;4;;@Override protected GeoShapeQueryBuilder doCreateTestQueryBuilder() {     return doCreateTestQueryBuilder(randomBoolean()). }
false;protected;1;41;;protected GeoShapeQueryBuilder doCreateTestQueryBuilder(boolean indexedShape) {     // LatLonShape does not support MultiPoint queries     RandomShapeGenerator.ShapeType shapeType = randomFrom(ShapeType.POINT, ShapeType.LINESTRING, ShapeType.MULTILINESTRING, ShapeType.POLYGON).     ShapeBuilder<?, ?, ?> shape = RandomShapeGenerator.createShapeWithin(random(), null, shapeType).     GeoShapeQueryBuilder builder.     clearShapeFields().     if (indexedShape == false) {         builder = new GeoShapeQueryBuilder(fieldName(), shape).     } else {         indexedShapeToReturn = shape.         indexedShapeId = randomAlphaOfLengthBetween(3, 20).         indexedShapeType = randomBoolean() ? randomAlphaOfLengthBetween(3, 20) : null.         builder = new GeoShapeQueryBuilder(fieldName(), indexedShapeId, indexedShapeType).         if (randomBoolean()) {             indexedShapeIndex = randomAlphaOfLengthBetween(3, 20).             builder.indexedShapeIndex(indexedShapeIndex).         }         if (randomBoolean()) {             indexedShapePath = randomAlphaOfLengthBetween(3, 20).             builder.indexedShapePath(indexedShapePath).         }         if (randomBoolean()) {             indexedShapeRouting = randomAlphaOfLengthBetween(3, 20).             builder.indexedShapeRouting(indexedShapeRouting).         }     }     if (randomBoolean()) {         if (shapeType == ShapeType.LINESTRING || shapeType == ShapeType.MULTILINESTRING) {             builder.relation(randomFrom(ShapeRelation.DISJOINT, ShapeRelation.INTERSECTS)).         } else {             // LatLonShape does not support CONTAINS:             builder.relation(randomFrom(ShapeRelation.DISJOINT, ShapeRelation.INTERSECTS, ShapeRelation.WITHIN)).         }     }     if (randomBoolean()) {         builder.ignoreUnmapped(randomBoolean()).     }     return builder. }
false;protected;1;27;;@Override protected GetResponse executeGet(GetRequest getRequest) {     String indexedType = indexedShapeType != null ? indexedShapeType : MapperService.SINGLE_MAPPING_NAME.     assertThat(indexedShapeToReturn, notNullValue()).     assertThat(indexedShapeId, notNullValue()).     assertThat(getRequest.id(), equalTo(indexedShapeId)).     assertThat(getRequest.type(), equalTo(indexedType)).     assertThat(getRequest.routing(), equalTo(indexedShapeRouting)).     String expectedShapeIndex = indexedShapeIndex == null ? GeoShapeQueryBuilder.DEFAULT_SHAPE_INDEX_NAME : indexedShapeIndex.     assertThat(getRequest.index(), equalTo(expectedShapeIndex)).     String expectedShapePath = indexedShapePath == null ? GeoShapeQueryBuilder.DEFAULT_SHAPE_FIELD_NAME : indexedShapePath.     String json.     try {         XContentBuilder builder = XContentFactory.jsonBuilder().prettyPrint().         builder.startObject().         builder.field(expectedShapePath, indexedShapeToReturn).         builder.field(randomAlphaOfLengthBetween(10, 20), "something").         builder.endObject().         json = Strings.toString(builder).     } catch (IOException ex) {         throw new ElasticsearchException("boom", ex).     }     return new GetResponse(new GetResult(indexedShapeIndex, indexedType, indexedShapeId, 0, 1, 0, true, new BytesArray(json), null)). }
false;public;0;9;;@After public void clearShapeFields() {     indexedShapeToReturn = null.     indexedShapeId = null.     indexedShapeType = null.     indexedShapePath = null.     indexedShapeIndex = null.     indexedShapeRouting = null. }
false;protected;3;8;;@Override protected void doAssertLuceneQuery(GeoShapeQueryBuilder queryBuilder, Query query, SearchContext context) throws IOException {     // Logic for doToQuery is complex and is hard to test here. Need to rely     // on Integration tests to determine if created query is correct     // TODO improve GeoShapeQueryBuilder.doToQuery() method to make it     // easier to test here     assertThat(query, anyOf(instanceOf(BooleanQuery.class), instanceOf(ConstantScoreQuery.class))). }
false;public;0;5;;public void testNoFieldName() throws Exception {     ShapeBuilder<?, ?, ?> shape = RandomShapeGenerator.createShapeWithin(random(), null).     IllegalArgumentException e = expectThrows(IllegalArgumentException.class, () -> new GeoShapeQueryBuilder(null, shape)).     assertEquals("fieldName is required", e.getMessage()). }
false;public;0;3;;public void testNoShape() throws IOException {     expectThrows(IllegalArgumentException.class, () -> new GeoShapeQueryBuilder(fieldName(), (ShapeBuilder) null)). }
false;public;0;5;;public void testNoIndexedShape() throws IOException {     IllegalArgumentException e = expectThrows(IllegalArgumentException.class, () -> new GeoShapeQueryBuilder(fieldName(), null, "type")).     assertEquals("either shape or indexedShapeId is required", e.getMessage()). }
false;public;0;6;;public void testNoRelation() throws IOException {     ShapeBuilder<?, ?, ?> shape = RandomShapeGenerator.createShapeWithin(random(), null).     GeoShapeQueryBuilder builder = new GeoShapeQueryBuilder(fieldName(), shape).     IllegalArgumentException e = expectThrows(IllegalArgumentException.class, () -> builder.relation(null)).     assertEquals("No Shape Relation defined", e.getMessage()). }
true;public;0;5;// see #3878 ;// see #3878 public void testThatXContentSerializationInsideOfArrayWorks() throws Exception {     EnvelopeBuilder envelopeBuilder = new EnvelopeBuilder(new Coordinate(0, 0), new Coordinate(10, 10)).     GeoShapeQueryBuilder geoQuery = QueryBuilders.geoShapeQuery("searchGeometry", envelopeBuilder).     JsonXContent.contentBuilder().startArray().value(geoQuery).endArray(). }
false;public;0;19;;public void testFromJson() throws IOException {     String json = "{\n" + "  \"geo_shape\" : {\n" + "    \"location\" : {\n" + "      \"shape\" : {\n" + "        \"type\" : \"envelope\",\n" + "        \"coordinates\" : [ [ 13.0, 53.0 ], [ 14.0, 52.0 ] ]\n" + "      },\n" + "      \"relation\" : \"intersects\"\n" + "    },\n" + "    \"ignore_unmapped\" : false,\n" + "    \"boost\" : 42.0\n" + "  }\n" + "}".     GeoShapeQueryBuilder parsed = (GeoShapeQueryBuilder) parseQuery(json).     checkGeneratedJson(json, parsed).     assertEquals(json, 42.0, parsed.boost(), 0.0001). }
false;public;0;12;;@Override public void testMustRewrite() throws IOException {     GeoShapeQueryBuilder query = doCreateTestQueryBuilder(true).     UnsupportedOperationException e = expectThrows(UnsupportedOperationException.class, () -> query.toQuery(createShardContext())).     assertEquals("query must be rewritten first", e.getMessage()).     QueryBuilder rewrite = rewriteAndFetch(query, createShardContext()).     GeoShapeQueryBuilder geoShapeQueryBuilder = new GeoShapeQueryBuilder(fieldName(), indexedShapeToReturn).     geoShapeQueryBuilder.strategy(query.strategy()).     geoShapeQueryBuilder.relation(query.relation()).     assertEquals(geoShapeQueryBuilder, rewrite). }
false;public;0;16;;public void testMultipleRewrite() throws IOException {     GeoShapeQueryBuilder shape = doCreateTestQueryBuilder(true).     QueryBuilder builder = new BoolQueryBuilder().should(shape).should(shape).     builder = rewriteAndFetch(builder, createShardContext()).     GeoShapeQueryBuilder expectedShape = new GeoShapeQueryBuilder(fieldName(), indexedShapeToReturn).     expectedShape.strategy(shape.strategy()).     expectedShape.relation(shape.relation()).     QueryBuilder expected = new BoolQueryBuilder().should(expectedShape).should(expectedShape).     assertEquals(expected, builder). }
false;public;0;14;;public void testIgnoreUnmapped() throws IOException {     ShapeType shapeType = ShapeType.randomType(random()).     ShapeBuilder<?, ?, ?> shape = RandomShapeGenerator.createShapeWithin(random(), null, shapeType).     final GeoShapeQueryBuilder queryBuilder = new GeoShapeQueryBuilder("unmapped", shape).     queryBuilder.ignoreUnmapped(true).     Query query = queryBuilder.toQuery(createShardContext()).     assertThat(query, notNullValue()).     assertThat(query, instanceOf(MatchNoDocsQuery.class)).     final GeoShapeQueryBuilder failingQueryBuilder = new GeoShapeQueryBuilder("unmapped", shape).     failingQueryBuilder.ignoreUnmapped(false).     QueryShardException e = expectThrows(QueryShardException.class, () -> failingQueryBuilder.toQuery(createShardContext())).     assertThat(e.getMessage(), containsString("failed to find geo_shape field [unmapped]")). }
false;public;0;7;;public void testWrongFieldType() throws IOException {     ShapeType shapeType = ShapeType.randomType(random()).     ShapeBuilder<?, ?, ?> shape = RandomShapeGenerator.createShapeWithin(random(), null, shapeType).     final GeoShapeQueryBuilder queryBuilder = new GeoShapeQueryBuilder(STRING_FIELD_NAME, shape).     QueryShardException e = expectThrows(QueryShardException.class, () -> queryBuilder.toQuery(createShardContext())).     assertThat(e.getMessage(), containsString("Field [mapped_string] is not of type [geo_shape] but of type [text]")). }
false;public;0;8;;public void testSerializationFailsUnlessFetched() throws IOException {     QueryBuilder builder = doCreateTestQueryBuilder(true).     QueryBuilder queryBuilder = Rewriteable.rewrite(builder, createShardContext()).     IllegalStateException ise = expectThrows(IllegalStateException.class, () -> queryBuilder.writeTo(new BytesStreamOutput(10))).     assertEquals(ise.getMessage(), "supplier must be null, can't serialize suppliers, missing a rewriteAndFetch?").     builder = rewriteAndFetch(builder, createShardContext()).     builder.writeTo(new BytesStreamOutput(10)). }
false;protected;1;11;;@Override protected QueryBuilder parseQuery(XContentParser parser) throws IOException {     QueryBuilder query = super.parseQuery(parser).     assertThat(query, instanceOf(GeoShapeQueryBuilder.class)).     GeoShapeQueryBuilder shapeQuery = (GeoShapeQueryBuilder) query.     if (shapeQuery.indexedShapeType() != null) {         assertWarnings(GeoShapeQueryBuilder.TYPES_DEPRECATION_MESSAGE).     }     return query. }
