commented;modifiers;parameterAmount;loc;comment;code
false;;0;4;;@Override long getMaxMapCount() {     return maxMapCount.get(). }
false;private;1;8;;private void assertFailure(final BootstrapCheck.BootstrapCheckResult result) {     assertTrue(result.isFailure()).     assertThat(result.getMessage(), equalTo("max virtual memory areas vm.max_map_count [" + maxMapCount.get() + "] is too low, " + "increase to at least [" + BootstrapChecks.MaxMapCountCheck.LIMIT + "]")). }
false;public;0;3;;public void testMaxMapCountCheckBelowLimit() {     assertFailure(check.check(emptyContext)). }
false;public;0;15;;public void testMaxMapCountCheckBelowLimitAndMemoryMapAllowed() {     /*          * There are two ways that memory maps are allowed:          *  - by default          *  - mmap is explicitly allowed          * We want to test that if mmap is allowed then the max map count check is enforced.          */     final List<Settings> settingsThatAllowMemoryMap = new ArrayList<>().     settingsThatAllowMemoryMap.add(Settings.EMPTY).     settingsThatAllowMemoryMap.add(Settings.builder().put("node.store.allow_mmap", true).build()).     for (final Settings settingThatAllowsMemoryMap : settingsThatAllowMemoryMap) {         assertFailure(check.check(createTestContext(settingThatAllowsMemoryMap, MetaData.EMPTY_META_DATA))).     } }
false;public;0;7;;public void testMaxMapCountCheckNotEnforcedIfMemoryMapNotAllowed() {     // nothing should happen if current vm.max_map_count is under the limit but mmap is not allowed     final Settings settings = Settings.builder().put("node.store.allow_mmap", false).build().     final BootstrapContext context = createTestContext(settings, MetaData.EMPTY_META_DATA).     final BootstrapCheck.BootstrapCheckResult result = check.check(context).     assertTrue(result.isSuccess()). }
false;public;0;6;;public void testMaxMapCountCheckAboveLimit() {     // nothing should happen if current vm.max_map_count exceeds the limit     maxMapCount.set(randomIntBetween(Math.toIntExact(BootstrapChecks.MaxMapCountCheck.LIMIT) + 1, Integer.MAX_VALUE)).     final BootstrapCheck.BootstrapCheckResult result = check.check(emptyContext).     assertTrue(result.isSuccess()). }
false;public;0;6;;public void testMaxMapCountCheckMaxMapCountNotAvailable() {     // nothing should happen if current vm.max_map_count is not available     maxMapCount.set(-1).     final BootstrapCheck.BootstrapCheckResult result = check.check(emptyContext).     assertTrue(result.isSuccess()). }
false;public;0;6;;public void testGetMaxMapCountOnLinux() {     if (Constants.LINUX) {         final BootstrapChecks.MaxMapCountCheck check = new BootstrapChecks.MaxMapCountCheck().         assertThat(check.getMaxMapCount(), greaterThan(0L)).     } }
false;;1;5;;@Override BufferedReader getBufferedReader(Path path) throws IOException {     assertEquals(path, procSysVmMaxMapCountPath).     return reader. }
false;public;0;62;;public void testGetMaxMapCount() throws IOException, IllegalAccessException {     final long procSysVmMaxMapCount = randomIntBetween(1, Integer.MAX_VALUE).     final BufferedReader reader = mock(BufferedReader.class).     when(reader.readLine()).thenReturn(Long.toString(procSysVmMaxMapCount)).     final Path procSysVmMaxMapCountPath = PathUtils.get("/proc/sys/vm/max_map_count").     BootstrapChecks.MaxMapCountCheck check = new BootstrapChecks.MaxMapCountCheck() {          @Override         BufferedReader getBufferedReader(Path path) throws IOException {             assertEquals(path, procSysVmMaxMapCountPath).             return reader.         }     }.     assertThat(check.getMaxMapCount(), equalTo(procSysVmMaxMapCount)).     verify(reader).close().     {         reset(reader).         final IOException ioException = new IOException("fatal").         when(reader.readLine()).thenThrow(ioException).         final Logger logger = LogManager.getLogger("testGetMaxMapCountIOException").         final MockLogAppender appender = new MockLogAppender().         appender.start().         appender.addExpectation(new ParameterizedMessageLoggingExpectation("expected logged I/O exception", "testGetMaxMapCountIOException", Level.WARN, "I/O exception while trying to read [{}]", new Object[] { procSysVmMaxMapCountPath }, e -> ioException == e)).         Loggers.addAppender(logger, appender).         assertThat(check.getMaxMapCount(logger), equalTo(-1L)).         appender.assertAllExpectationsMatched().         verify(reader).close().         Loggers.removeAppender(logger, appender).         appender.stop().     }     {         reset(reader).         when(reader.readLine()).thenReturn("eof").         final Logger logger = LogManager.getLogger("testGetMaxMapCountNumberFormatException").         final MockLogAppender appender = new MockLogAppender().         appender.start().         appender.addExpectation(new ParameterizedMessageLoggingExpectation("expected logged number format exception", "testGetMaxMapCountNumberFormatException", Level.WARN, "unable to parse vm.max_map_count [{}]", new Object[] { "eof" }, e -> e instanceof NumberFormatException && e.getMessage().equals("For input string: \"eof\""))).         Loggers.addAppender(logger, appender).         assertThat(check.getMaxMapCount(logger), equalTo(-1L)).         appender.assertAllExpectationsMatched().         verify(reader).close().         Loggers.removeAppender(logger, appender).         appender.stop().     } }
false;public;1;11;;@Override public void match(final LogEvent event) {     if (event.getLevel().equals(level) && event.getLoggerName().equals(loggerName) && event.getMessage() instanceof ParameterizedMessage) {         final ParameterizedMessage message = (ParameterizedMessage) event.getMessage().         saw = message.getFormat().equals(messagePattern) && Arrays.deepEquals(arguments, message.getParameters()) && throwablePredicate.test(event.getThrown()).     } }
false;public;0;4;;@Override public void assertMatched() {     assertTrue(name, saw). }
false;public;0;7;;public void testMaxMapCountCheckRead() throws IOException {     final String rawProcSysVmMaxMapCount = Long.toString(randomIntBetween(1, Integer.MAX_VALUE)).     final BufferedReader reader = mock(BufferedReader.class).     when(reader.readLine()).thenReturn(rawProcSysVmMaxMapCount).     final BootstrapChecks.MaxMapCountCheck check = new BootstrapChecks.MaxMapCountCheck().     assertThat(check.readProcSysVmMaxMapCount(reader), equalTo(rawProcSysVmMaxMapCount)). }
false;public;0;5;;public void testMaxMapCountCheckParse() {     final long procSysVmMaxMapCount = randomIntBetween(1, Integer.MAX_VALUE).     final BootstrapChecks.MaxMapCountCheck check = new BootstrapChecks.MaxMapCountCheck().     assertThat(check.parseProcSysVmMaxMapCount(Long.toString(procSysVmMaxMapCount)), equalTo(procSysVmMaxMapCount)). }
