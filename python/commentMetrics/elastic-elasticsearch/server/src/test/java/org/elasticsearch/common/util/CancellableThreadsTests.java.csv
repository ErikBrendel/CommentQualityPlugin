commented;modifiers;parameterAmount;loc;comment;code
false;public;0;22;;@Override public void run() throws InterruptedException {     assertFalse("interrupt thread should have been clear", Thread.currentThread().isInterrupted()).     if (plan.exceptBeforeCancel) {         throw new CustomException("thread [" + plan.id + "] pre-cancel exception").     } else if (plan.exitBeforeCancel) {         return.     }     readyForCancel.countDown().     try {         if (plan.busySpin) {             while (!Thread.currentThread().isInterrupted()) {             }         } else {             Thread.sleep(50000).         }     } finally {         if (plan.exceptAfterCancel) {             throw new CustomException("thread [" + plan.id + "] post-cancel exception").         }     } }
false;public;0;23;;@Override public void run() throws IOException, InterruptedException {     assertFalse("interrupt thread should have been clear", Thread.currentThread().isInterrupted()).     if (plan.exceptBeforeCancel) {         throw new IOCustomException("thread [" + plan.id + "] pre-cancel exception").     } else if (plan.exitBeforeCancel) {         return.     }     readyForCancel.countDown().     try {         if (plan.busySpin) {             while (!Thread.currentThread().isInterrupted()) {             }         } else {             Thread.sleep(50000).         }     } finally {         if (plan.exceptAfterCancel) {             throw new IOCustomException("thread [" + plan.id + "] post-cancel exception").         }     } }
false;public;0;91;;public void testCancellableThreads() throws InterruptedException {     Thread[] threads = new Thread[randomIntBetween(3, 10)].     final TestPlan[] plans = new TestPlan[threads.length].     final Exception[] exceptions = new Exception[threads.length].     final boolean[] interrupted = new boolean[threads.length].     final CancellableThreads cancellableThreads = new CancellableThreads().     final CountDownLatch readyForCancel = new CountDownLatch(threads.length).     for (int i = 0. i < threads.length. i++) {         final TestPlan plan = new TestPlan(i).         plans[i] = plan.         threads[i] = new Thread(() -> {             try {                 if (plan.presetInterrupt) {                     Thread.currentThread().interrupt().                 }                 if (plan.ioOp) {                     if (plan.ioException) {                         cancellableThreads.executeIO(new TestIORunnable(plan, readyForCancel)).                     } else {                         cancellableThreads.executeIO(new TestRunnable(plan, readyForCancel)).                     }                 } else {                     cancellableThreads.execute(new TestRunnable(plan, readyForCancel)).                 }             } catch (Exception e) {                 exceptions[plan.id] = e.             }             if (plan.exceptBeforeCancel || plan.exitBeforeCancel) {                 // we have to mark we're ready now (actually done).                 readyForCancel.countDown().             }             interrupted[plan.id] = Thread.currentThread().isInterrupted().         }).         threads[i].setDaemon(true).         threads[i].start().     }     readyForCancel.await().     final boolean throwInOnCancel = randomBoolean().     final AtomicInteger invokeTimes = new AtomicInteger().     cancellableThreads.setOnCancel((reason, beforeCancelException) -> {         invokeTimes.getAndIncrement().         if (throwInOnCancel) {             ThrowOnCancelException e = new ThrowOnCancelException().             if (beforeCancelException != null) {                 e.addSuppressed(beforeCancelException).             }             throw e.         }     }).     cancellableThreads.cancel("test").     for (Thread thread : threads) {         thread.join(20000).         assertFalse(thread.isAlive()).     }     for (int i = 0. i < threads.length. i++) {         TestPlan plan = plans[i].         final Class<?> exceptionClass = plan.ioException ? IOCustomException.class : CustomException.class.         if (plan.exceptBeforeCancel) {             assertThat(exceptions[i], Matchers.instanceOf(exceptionClass)).         } else if (plan.exitBeforeCancel) {             assertNull(exceptions[i]).         } else {             // in all other cases, we expect a cancellation exception.             if (throwInOnCancel) {                 assertThat(exceptions[i], Matchers.instanceOf(ThrowOnCancelException.class)).             } else {                 assertThat(exceptions[i], Matchers.instanceOf(ExecutionCancelledException.class)).             }             if (plan.exceptAfterCancel) {                 assertThat(exceptions[i].getSuppressed(), Matchers.arrayContaining(Matchers.instanceOf(exceptionClass))).             } else {                 assertThat(exceptions[i].getSuppressed(), Matchers.emptyArray()).             }         }         assertThat(interrupted[plan.id], equalTo(plan.presetInterrupt)).     }     assertThat(invokeTimes.longValue(), equalTo(Arrays.stream(plans).filter(p -> p.exceptBeforeCancel == false && p.exitBeforeCancel == false).count())).     if (throwInOnCancel) {         expectThrows(ThrowOnCancelException.class, cancellableThreads::checkForCancel).     } else {         expectThrows(ExecutionCancelledException.class, cancellableThreads::checkForCancel).     }     assertThat(invokeTimes.longValue(), equalTo(Arrays.stream(plans).filter(p -> p.exceptBeforeCancel == false && p.exitBeforeCancel == false).count() + 1)). }
