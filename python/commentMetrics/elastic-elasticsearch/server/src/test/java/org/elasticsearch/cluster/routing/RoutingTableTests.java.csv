# id;timestamp;commentText;codeText;commentWords;codeWords
RoutingTableTests -> public static IndexMetaData updateActiveAllocations(IndexRoutingTable indexRoutingTable, IndexMetaData indexMetaData);1524684173;reverse engineer the in sync aid based on the given indexRoutingTable *;public static IndexMetaData updateActiveAllocations(IndexRoutingTable indexRoutingTable, IndexMetaData indexMetaData) {_        IndexMetaData.Builder imdBuilder = IndexMetaData.builder(indexMetaData)__        for (IndexShardRoutingTable shardTable : indexRoutingTable) {_            for (ShardRouting shardRouting : shardTable) {_                Set<String> insyncAids = shardTable.activeShards().stream().map(_                    shr -> shr.allocationId().getId()).collect(Collectors.toSet())__                final ShardRouting primaryShard = shardTable.primaryShard()__                if (primaryShard.initializing() && primaryShard.recoverySource().getType() == RecoverySource.Type.EXISTING_STORE) {_                    _                    insyncAids.add(primaryShard.allocationId().getId())__                }_                imdBuilder.putInSyncAllocationIds(shardRouting.id(), insyncAids)__            }_        }_        return imdBuilder.build()__    };reverse,engineer,the,in,sync,aid,based,on,the,given,index,routing,table;public,static,index,meta,data,update,active,allocations,index,routing,table,index,routing,table,index,meta,data,index,meta,data,index,meta,data,builder,imd,builder,index,meta,data,builder,index,meta,data,for,index,shard,routing,table,shard,table,index,routing,table,for,shard,routing,shard,routing,shard,table,set,string,insync,aids,shard,table,active,shards,stream,map,shr,shr,allocation,id,get,id,collect,collectors,to,set,final,shard,routing,primary,shard,shard,table,primary,shard,if,primary,shard,initializing,primary,shard,recovery,source,get,type,recovery,source,type,insync,aids,add,primary,shard,allocation,id,get,id,imd,builder,put,in,sync,allocation,ids,shard,routing,id,insync,aids,return,imd,builder,build
RoutingTableTests -> public static IndexMetaData updateActiveAllocations(IndexRoutingTable indexRoutingTable, IndexMetaData indexMetaData);1524780945;reverse engineer the in sync aid based on the given indexRoutingTable *;public static IndexMetaData updateActiveAllocations(IndexRoutingTable indexRoutingTable, IndexMetaData indexMetaData) {_        IndexMetaData.Builder imdBuilder = IndexMetaData.builder(indexMetaData)__        for (IndexShardRoutingTable shardTable : indexRoutingTable) {_            for (ShardRouting shardRouting : shardTable) {_                Set<String> insyncAids = shardTable.activeShards().stream().map(_                    shr -> shr.allocationId().getId()).collect(Collectors.toSet())__                final ShardRouting primaryShard = shardTable.primaryShard()__                if (primaryShard.initializing() && primaryShard.recoverySource().getType() == RecoverySource.Type.EXISTING_STORE) {_                    _                    insyncAids.add(primaryShard.allocationId().getId())__                }_                imdBuilder.putInSyncAllocationIds(shardRouting.id(), insyncAids)__            }_        }_        return imdBuilder.build()__    };reverse,engineer,the,in,sync,aid,based,on,the,given,index,routing,table;public,static,index,meta,data,update,active,allocations,index,routing,table,index,routing,table,index,meta,data,index,meta,data,index,meta,data,builder,imd,builder,index,meta,data,builder,index,meta,data,for,index,shard,routing,table,shard,table,index,routing,table,for,shard,routing,shard,routing,shard,table,set,string,insync,aids,shard,table,active,shards,stream,map,shr,shr,allocation,id,get,id,collect,collectors,to,set,final,shard,routing,primary,shard,shard,table,primary,shard,if,primary,shard,initializing,primary,shard,recovery,source,get,type,recovery,source,type,insync,aids,add,primary,shard,allocation,id,get,id,imd,builder,put,in,sync,allocation,ids,shard,routing,id,insync,aids,return,imd,builder,build
RoutingTableTests -> public static IndexMetaData updateActiveAllocations(IndexRoutingTable indexRoutingTable, IndexMetaData indexMetaData);1539723533;reverse engineer the in sync aid based on the given indexRoutingTable *;public static IndexMetaData updateActiveAllocations(IndexRoutingTable indexRoutingTable, IndexMetaData indexMetaData) {_        IndexMetaData.Builder imdBuilder = IndexMetaData.builder(indexMetaData)__        for (IndexShardRoutingTable shardTable : indexRoutingTable) {_            for (ShardRouting shardRouting : shardTable) {_                Set<String> insyncAids = shardTable.activeShards().stream().map(_                    shr -> shr.allocationId().getId()).collect(Collectors.toSet())__                final ShardRouting primaryShard = shardTable.primaryShard()__                if (primaryShard.initializing() && primaryShard.recoverySource().getType() == RecoverySource.Type.EXISTING_STORE) {_                    _                    insyncAids.add(primaryShard.allocationId().getId())__                }_                imdBuilder.putInSyncAllocationIds(shardRouting.id(), insyncAids)__            }_        }_        return imdBuilder.build()__    };reverse,engineer,the,in,sync,aid,based,on,the,given,index,routing,table;public,static,index,meta,data,update,active,allocations,index,routing,table,index,routing,table,index,meta,data,index,meta,data,index,meta,data,builder,imd,builder,index,meta,data,builder,index,meta,data,for,index,shard,routing,table,shard,table,index,routing,table,for,shard,routing,shard,routing,shard,table,set,string,insync,aids,shard,table,active,shards,stream,map,shr,shr,allocation,id,get,id,collect,collectors,to,set,final,shard,routing,primary,shard,shard,table,primary,shard,if,primary,shard,initializing,primary,shard,recovery,source,get,type,recovery,source,type,insync,aids,add,primary,shard,allocation,id,get,id,imd,builder,put,in,sync,allocation,ids,shard,routing,id,insync,aids,return,imd,builder,build
RoutingTableTests -> public static IndexMetaData updateActiveAllocations(IndexRoutingTable indexRoutingTable, IndexMetaData indexMetaData);1540847035;reverse engineer the in sync aid based on the given indexRoutingTable *;public static IndexMetaData updateActiveAllocations(IndexRoutingTable indexRoutingTable, IndexMetaData indexMetaData) {_        IndexMetaData.Builder imdBuilder = IndexMetaData.builder(indexMetaData)__        for (IndexShardRoutingTable shardTable : indexRoutingTable) {_            for (ShardRouting shardRouting : shardTable) {_                Set<String> insyncAids = shardTable.activeShards().stream().map(_                    shr -> shr.allocationId().getId()).collect(Collectors.toSet())__                final ShardRouting primaryShard = shardTable.primaryShard()__                if (primaryShard.initializing() && primaryShard.recoverySource().getType() == RecoverySource.Type.EXISTING_STORE) {_                    _                    insyncAids.add(primaryShard.allocationId().getId())__                }_                imdBuilder.putInSyncAllocationIds(shardRouting.id(), insyncAids)__            }_        }_        return imdBuilder.build()__    };reverse,engineer,the,in,sync,aid,based,on,the,given,index,routing,table;public,static,index,meta,data,update,active,allocations,index,routing,table,index,routing,table,index,meta,data,index,meta,data,index,meta,data,builder,imd,builder,index,meta,data,builder,index,meta,data,for,index,shard,routing,table,shard,table,index,routing,table,for,shard,routing,shard,routing,shard,table,set,string,insync,aids,shard,table,active,shards,stream,map,shr,shr,allocation,id,get,id,collect,collectors,to,set,final,shard,routing,primary,shard,shard,table,primary,shard,if,primary,shard,initializing,primary,shard,recovery,source,get,type,recovery,source,type,insync,aids,add,primary,shard,allocation,id,get,id,imd,builder,put,in,sync,allocation,ids,shard,routing,id,insync,aids,return,imd,builder,build
RoutingTableTests -> private void initPrimaries();1524684173;puts primary shard routings into initializing state;private void initPrimaries() {_        logger.info("adding {} nodes and performing rerouting", this.numberOfReplicas + 1)__        Builder discoBuilder = DiscoveryNodes.builder()__        for (int i = 0_ i < this.numberOfReplicas + 1_ i++) {_            discoBuilder = discoBuilder.add(newNode("node" + i))__        }_        this.clusterState = ClusterState.builder(clusterState).nodes(discoBuilder).build()__        ClusterState rerouteResult = ALLOCATION_SERVICE.reroute(clusterState, "reroute")__        assertThat(rerouteResult, not(equalTo(this.clusterState)))__        this.clusterState = rerouteResult__    };puts,primary,shard,routings,into,initializing,state;private,void,init,primaries,logger,info,adding,nodes,and,performing,rerouting,this,number,of,replicas,1,builder,disco,builder,discovery,nodes,builder,for,int,i,0,i,this,number,of,replicas,1,i,disco,builder,disco,builder,add,new,node,node,i,this,cluster,state,cluster,state,builder,cluster,state,nodes,disco,builder,build,cluster,state,reroute,result,reroute,cluster,state,reroute,assert,that,reroute,result,not,equal,to,this,cluster,state,this,cluster,state,reroute,result
RoutingTableTests -> private void initPrimaries();1524780945;puts primary shard indexRoutings into initializing state;private void initPrimaries() {_        logger.info("adding {} nodes and performing rerouting", this.numberOfReplicas + 1)__        Builder discoBuilder = DiscoveryNodes.builder()__        for (int i = 0_ i < this.numberOfReplicas + 1_ i++) {_            discoBuilder = discoBuilder.add(newNode("node" + i))__        }_        this.clusterState = ClusterState.builder(clusterState).nodes(discoBuilder).build()__        ClusterState rerouteResult = ALLOCATION_SERVICE.reroute(clusterState, "reroute")__        assertThat(rerouteResult, not(equalTo(this.clusterState)))__        this.clusterState = rerouteResult__    };puts,primary,shard,index,routings,into,initializing,state;private,void,init,primaries,logger,info,adding,nodes,and,performing,rerouting,this,number,of,replicas,1,builder,disco,builder,discovery,nodes,builder,for,int,i,0,i,this,number,of,replicas,1,i,disco,builder,disco,builder,add,new,node,node,i,this,cluster,state,cluster,state,builder,cluster,state,nodes,disco,builder,build,cluster,state,reroute,result,reroute,cluster,state,reroute,assert,that,reroute,result,not,equal,to,this,cluster,state,this,cluster,state,reroute,result
RoutingTableTests -> private void initPrimaries();1539723533;puts primary shard indexRoutings into initializing state;private void initPrimaries() {_        logger.info("adding {} nodes and performing rerouting", this.numberOfReplicas + 1)__        Builder discoBuilder = DiscoveryNodes.builder()__        for (int i = 0_ i < this.numberOfReplicas + 1_ i++) {_            discoBuilder = discoBuilder.add(newNode("node" + i))__        }_        this.clusterState = ClusterState.builder(clusterState).nodes(discoBuilder).build()__        ClusterState rerouteResult = ALLOCATION_SERVICE.reroute(clusterState, "reroute")__        assertThat(rerouteResult, not(equalTo(this.clusterState)))__        this.clusterState = rerouteResult__    };puts,primary,shard,index,routings,into,initializing,state;private,void,init,primaries,logger,info,adding,nodes,and,performing,rerouting,this,number,of,replicas,1,builder,disco,builder,discovery,nodes,builder,for,int,i,0,i,this,number,of,replicas,1,i,disco,builder,disco,builder,add,new,node,node,i,this,cluster,state,cluster,state,builder,cluster,state,nodes,disco,builder,build,cluster,state,reroute,result,reroute,cluster,state,reroute,assert,that,reroute,result,not,equal,to,this,cluster,state,this,cluster,state,reroute,result
RoutingTableTests -> private void initPrimaries();1540847035;puts primary shard indexRoutings into initializing state;private void initPrimaries() {_        logger.info("adding {} nodes and performing rerouting", this.numberOfReplicas + 1)__        Builder discoBuilder = DiscoveryNodes.builder()__        for (int i = 0_ i < this.numberOfReplicas + 1_ i++) {_            discoBuilder = discoBuilder.add(newNode("node" + i))__        }_        this.clusterState = ClusterState.builder(clusterState).nodes(discoBuilder).build()__        ClusterState rerouteResult = ALLOCATION_SERVICE.reroute(clusterState, "reroute")__        assertThat(rerouteResult, not(equalTo(this.clusterState)))__        this.clusterState = rerouteResult__    };puts,primary,shard,index,routings,into,initializing,state;private,void,init,primaries,logger,info,adding,nodes,and,performing,rerouting,this,number,of,replicas,1,builder,disco,builder,discovery,nodes,builder,for,int,i,0,i,this,number,of,replicas,1,i,disco,builder,disco,builder,add,new,node,node,i,this,cluster,state,cluster,state,builder,cluster,state,nodes,disco,builder,build,cluster,state,reroute,result,reroute,cluster,state,reroute,assert,that,reroute,result,not,equal,to,this,cluster,state,this,cluster,state,reroute,result
