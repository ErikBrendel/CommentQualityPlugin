commented;modifiers;parameterAmount;loc;comment;code
false;public;1;17;;@Override public void onResponse(NodesReloadSecureSettingsResponse nodesReloadResponse) {     try {         assertThat(nodesReloadResponse, notNullValue()).         final Map<String, NodesReloadSecureSettingsResponse.NodeResponse> nodesMap = nodesReloadResponse.getNodesMap().         assertThat(nodesMap.size(), equalTo(cluster().size())).         for (final NodesReloadSecureSettingsResponse.NodeResponse nodeResponse : nodesReloadResponse.getNodes()) {             assertThat(nodeResponse.reloadException(), notNullValue()).             assertThat(nodeResponse.reloadException(), instanceOf(IllegalStateException.class)).             assertThat(nodeResponse.reloadException().getMessage(), containsString("Keystore is missing")).         }     } catch (final AssertionError e) {         reloadSettingsError.set(e).     } finally {         latch.countDown().     } }
false;public;1;5;;@Override public void onFailure(Exception e) {     reloadSettingsError.set(new AssertionError("Nodes request failed", e)).     latch.countDown(). }
false;public;0;43;;public void testMissingKeystoreFile() throws Exception {     final PluginsService pluginsService = internalCluster().getInstance(PluginsService.class).     final MockReloadablePlugin mockReloadablePlugin = pluginsService.filterPlugins(MockReloadablePlugin.class).stream().findFirst().get().     final Environment environment = internalCluster().getInstance(Environment.class).     final AtomicReference<AssertionError> reloadSettingsError = new AtomicReference<>().     // keystore file should be missing for this test case     Files.deleteIfExists(KeyStoreWrapper.keystorePath(environment.configFile())).     final int initialReloadCount = mockReloadablePlugin.getReloadCount().     final CountDownLatch latch = new CountDownLatch(1).     client().admin().cluster().prepareReloadSecureSettings().execute(new ActionListener<NodesReloadSecureSettingsResponse>() {          @Override         public void onResponse(NodesReloadSecureSettingsResponse nodesReloadResponse) {             try {                 assertThat(nodesReloadResponse, notNullValue()).                 final Map<String, NodesReloadSecureSettingsResponse.NodeResponse> nodesMap = nodesReloadResponse.getNodesMap().                 assertThat(nodesMap.size(), equalTo(cluster().size())).                 for (final NodesReloadSecureSettingsResponse.NodeResponse nodeResponse : nodesReloadResponse.getNodes()) {                     assertThat(nodeResponse.reloadException(), notNullValue()).                     assertThat(nodeResponse.reloadException(), instanceOf(IllegalStateException.class)).                     assertThat(nodeResponse.reloadException().getMessage(), containsString("Keystore is missing")).                 }             } catch (final AssertionError e) {                 reloadSettingsError.set(e).             } finally {                 latch.countDown().             }         }          @Override         public void onFailure(Exception e) {             reloadSettingsError.set(new AssertionError("Nodes request failed", e)).             latch.countDown().         }     }).     latch.await().     if (reloadSettingsError.get() != null) {         throw reloadSettingsError.get().     }     // in the missing keystore case no reload should be triggered     assertThat(mockReloadablePlugin.getReloadCount(), equalTo(initialReloadCount)). }
false;public;1;15;;@Override public void onResponse(NodesReloadSecureSettingsResponse nodesReloadResponse) {     try {         assertThat(nodesReloadResponse, notNullValue()).         final Map<String, NodesReloadSecureSettingsResponse.NodeResponse> nodesMap = nodesReloadResponse.getNodesMap().         assertThat(nodesMap.size(), equalTo(cluster().size())).         for (final NodesReloadSecureSettingsResponse.NodeResponse nodeResponse : nodesReloadResponse.getNodes()) {             assertThat(nodeResponse.reloadException(), notNullValue()).         }     } catch (final AssertionError e) {         reloadSettingsError.set(e).     } finally {         latch.countDown().     } }
false;public;1;5;;@Override public void onFailure(Exception e) {     reloadSettingsError.set(new AssertionError("Nodes request failed", e)).     latch.countDown(). }
false;public;0;46;;public void testInvalidKeystoreFile() throws Exception {     final PluginsService pluginsService = internalCluster().getInstance(PluginsService.class).     final MockReloadablePlugin mockReloadablePlugin = pluginsService.filterPlugins(MockReloadablePlugin.class).stream().findFirst().get().     final Environment environment = internalCluster().getInstance(Environment.class).     final AtomicReference<AssertionError> reloadSettingsError = new AtomicReference<>().     final int initialReloadCount = mockReloadablePlugin.getReloadCount().     // invalid "keystore" file should be present in the config dir     try (InputStream keystore = ReloadSecureSettingsIT.class.getResourceAsStream("invalid.txt.keystore")) {         if (Files.exists(environment.configFile()) == false) {             Files.createDirectory(environment.configFile()).         }         Files.copy(keystore, KeyStoreWrapper.keystorePath(environment.configFile()), StandardCopyOption.REPLACE_EXISTING).     }     final CountDownLatch latch = new CountDownLatch(1).     client().admin().cluster().prepareReloadSecureSettings().execute(new ActionListener<NodesReloadSecureSettingsResponse>() {          @Override         public void onResponse(NodesReloadSecureSettingsResponse nodesReloadResponse) {             try {                 assertThat(nodesReloadResponse, notNullValue()).                 final Map<String, NodesReloadSecureSettingsResponse.NodeResponse> nodesMap = nodesReloadResponse.getNodesMap().                 assertThat(nodesMap.size(), equalTo(cluster().size())).                 for (final NodesReloadSecureSettingsResponse.NodeResponse nodeResponse : nodesReloadResponse.getNodes()) {                     assertThat(nodeResponse.reloadException(), notNullValue()).                 }             } catch (final AssertionError e) {                 reloadSettingsError.set(e).             } finally {                 latch.countDown().             }         }          @Override         public void onFailure(Exception e) {             reloadSettingsError.set(new AssertionError("Nodes request failed", e)).             latch.countDown().         }     }).     latch.await().     if (reloadSettingsError.get() != null) {         throw reloadSettingsError.get().     }     // in the invalid keystore format case no reload should be triggered     assertThat(mockReloadablePlugin.getReloadCount(), equalTo(initialReloadCount)). }
false;public;1;16;;@Override public void onResponse(NodesReloadSecureSettingsResponse nodesReloadResponse) {     try {         assertThat(nodesReloadResponse, notNullValue()).         final Map<String, NodesReloadSecureSettingsResponse.NodeResponse> nodesMap = nodesReloadResponse.getNodesMap().         assertThat(nodesMap.size(), equalTo(cluster().size())).         for (final NodesReloadSecureSettingsResponse.NodeResponse nodeResponse : nodesReloadResponse.getNodes()) {             assertThat(nodeResponse.reloadException(), notNullValue()).             assertThat(nodeResponse.reloadException().getMessage(), containsString("If shouldThrow I throw")).         }     } catch (final AssertionError e) {         reloadSettingsError.set(e).     } finally {         latch.countDown().     } }
false;public;1;5;;@Override public void onFailure(Exception e) {     reloadSettingsError.set(new AssertionError("Nodes request failed", e)).     latch.countDown(). }
false;public;0;55;;public void testMisbehavingPlugin() throws Exception {     final Environment environment = internalCluster().getInstance(Environment.class).     final PluginsService pluginsService = internalCluster().getInstance(PluginsService.class).     final MockReloadablePlugin mockReloadablePlugin = pluginsService.filterPlugins(MockReloadablePlugin.class).stream().findFirst().get().     // make plugins throw on reload     for (final String nodeName : internalCluster().getNodeNames()) {         internalCluster().getInstance(PluginsService.class, nodeName).filterPlugins(MisbehavingReloadablePlugin.class).stream().findFirst().get().setShouldThrow(true).     }     final AtomicReference<AssertionError> reloadSettingsError = new AtomicReference<>().     final int initialReloadCount = mockReloadablePlugin.getReloadCount().     // "some" keystore should be present     final SecureSettings secureSettings = writeEmptyKeystore(environment, new char[0]).     // read seed setting value from the test case (not from the node)     final String seedValue = KeyStoreWrapper.SEED_SETTING.get(Settings.builder().put(environment.settings()).setSecureSettings(secureSettings).build()).toString().     final CountDownLatch latch = new CountDownLatch(1).     client().admin().cluster().prepareReloadSecureSettings().execute(new ActionListener<NodesReloadSecureSettingsResponse>() {          @Override         public void onResponse(NodesReloadSecureSettingsResponse nodesReloadResponse) {             try {                 assertThat(nodesReloadResponse, notNullValue()).                 final Map<String, NodesReloadSecureSettingsResponse.NodeResponse> nodesMap = nodesReloadResponse.getNodesMap().                 assertThat(nodesMap.size(), equalTo(cluster().size())).                 for (final NodesReloadSecureSettingsResponse.NodeResponse nodeResponse : nodesReloadResponse.getNodes()) {                     assertThat(nodeResponse.reloadException(), notNullValue()).                     assertThat(nodeResponse.reloadException().getMessage(), containsString("If shouldThrow I throw")).                 }             } catch (final AssertionError e) {                 reloadSettingsError.set(e).             } finally {                 latch.countDown().             }         }          @Override         public void onFailure(Exception e) {             reloadSettingsError.set(new AssertionError("Nodes request failed", e)).             latch.countDown().         }     }).     latch.await().     if (reloadSettingsError.get() != null) {         throw reloadSettingsError.get().     }     // even if one plugin fails to reload (throws Exception), others should be     // unperturbed     assertThat(mockReloadablePlugin.getReloadCount() - initialReloadCount, equalTo(1)).     // mock plugin should have been reloaded successfully     assertThat(mockReloadablePlugin.getSeedValue(), equalTo(seedValue)). }
false;public;0;19;;public void testReloadWhileKeystoreChanged() throws Exception {     final PluginsService pluginsService = internalCluster().getInstance(PluginsService.class).     final MockReloadablePlugin mockReloadablePlugin = pluginsService.filterPlugins(MockReloadablePlugin.class).stream().findFirst().get().     final Environment environment = internalCluster().getInstance(Environment.class).     final int initialReloadCount = mockReloadablePlugin.getReloadCount().     for (int i = 0. i < randomIntBetween(4, 8). i++) {         // write keystore         final SecureSettings secureSettings = writeEmptyKeystore(environment, new char[0]).         // read seed setting value from the test case (not from the node)         final String seedValue = KeyStoreWrapper.SEED_SETTING.get(Settings.builder().put(environment.settings()).setSecureSettings(secureSettings).build()).toString().         // reload call         successfulReloadCall().         assertThat(mockReloadablePlugin.getSeedValue(), equalTo(seedValue)).         assertThat(mockReloadablePlugin.getReloadCount() - initialReloadCount, equalTo(i + 1)).     } }
false;protected;0;7;;@Override protected Collection<Class<? extends Plugin>> nodePlugins() {     final List<Class<? extends Plugin>> plugins = Arrays.asList(MockReloadablePlugin.class, MisbehavingReloadablePlugin.class).     // shuffle as reload is called in order     Collections.shuffle(plugins, random()).     return plugins. }
false;public;1;15;;@Override public void onResponse(NodesReloadSecureSettingsResponse nodesReloadResponse) {     try {         assertThat(nodesReloadResponse, notNullValue()).         final Map<String, NodesReloadSecureSettingsResponse.NodeResponse> nodesMap = nodesReloadResponse.getNodesMap().         assertThat(nodesMap.size(), equalTo(cluster().size())).         for (final NodesReloadSecureSettingsResponse.NodeResponse nodeResponse : nodesReloadResponse.getNodes()) {             assertThat(nodeResponse.reloadException(), nullValue()).         }     } catch (final AssertionError e) {         reloadSettingsError.set(e).     } finally {         latch.countDown().     } }
false;public;1;5;;@Override public void onFailure(Exception e) {     reloadSettingsError.set(new AssertionError("Nodes request failed", e)).     latch.countDown(). }
false;private;0;32;;private void successfulReloadCall() throws InterruptedException {     final AtomicReference<AssertionError> reloadSettingsError = new AtomicReference<>().     final CountDownLatch latch = new CountDownLatch(1).     client().admin().cluster().prepareReloadSecureSettings().execute(new ActionListener<NodesReloadSecureSettingsResponse>() {          @Override         public void onResponse(NodesReloadSecureSettingsResponse nodesReloadResponse) {             try {                 assertThat(nodesReloadResponse, notNullValue()).                 final Map<String, NodesReloadSecureSettingsResponse.NodeResponse> nodesMap = nodesReloadResponse.getNodesMap().                 assertThat(nodesMap.size(), equalTo(cluster().size())).                 for (final NodesReloadSecureSettingsResponse.NodeResponse nodeResponse : nodesReloadResponse.getNodes()) {                     assertThat(nodeResponse.reloadException(), nullValue()).                 }             } catch (final AssertionError e) {                 reloadSettingsError.set(e).             } finally {                 latch.countDown().             }         }          @Override         public void onFailure(Exception e) {             reloadSettingsError.set(new AssertionError("Nodes request failed", e)).             latch.countDown().         }     }).     latch.await().     if (reloadSettingsError.get() != null) {         throw reloadSettingsError.get().     } }
false;private;2;15;;private SecureSettings writeEmptyKeystore(Environment environment, char[] password) throws Exception {     final KeyStoreWrapper keyStoreWrapper = KeyStoreWrapper.create().     try {         keyStoreWrapper.save(environment.configFile(), password).     } catch (final AccessControlException e) {         if (e.getPermission() instanceof RuntimePermission && e.getPermission().getName().equals("accessUserInformation")) {         // this is expected: the save method is extra diligent and wants to make sure         // the keystore is readable, not relying on umask and whatnot. It's ok, we don't         // care about this in tests.         } else {             throw e.         }     }     return keyStoreWrapper. }
false;public;1;4;;@Override public void reload(Settings settings) throws Exception {     reloadCount++. }
false;public;0;3;;public int getReloadCount() {     return reloadCount. }
false;public;1;5;;@Override public void reload(Settings settings) throws Exception {     super.reload(settings).     this.seedValue = KeyStoreWrapper.SEED_SETTING.get(settings).toString(). }
false;public;0;3;;public String getSeedValue() {     return seedValue. }
false;public,synchronized;1;8;;@Override public synchronized void reload(Settings settings) throws Exception {     super.reload(settings).     if (shouldThrow) {         shouldThrow = false.         throw new Exception("If shouldThrow I throw").     } }
false;public,synchronized;1;3;;public synchronized void setShouldThrow(boolean shouldThrow) {     this.shouldThrow = shouldThrow. }
