# id;timestamp;commentText;codeText;commentWords;codeWords
ReplicationTrackerTests -> public void testRaceUpdatingGlobalCheckpoint() throws InterruptedException, BrokenBarrierException;1524684173;If we do not update the global checkpoint in {@link ReplicationTracker#markAllocationIdAsInSync(String, long)} after adding the_allocation ID to the in-sync set and removing it from pending, the local checkpoint update that freed the thread waiting for the_local checkpoint to advance could miss updating the global checkpoint in a race if the waiting thread did not add the allocation_ID to the in-sync set and remove it from the pending set before the local checkpoint updating thread executed the global checkpoint_update. This test fails without an additional call to {@link ReplicationTracker#updateGlobalCheckpointOnPrimary()} after_removing the allocation ID from the pending set in {@link ReplicationTracker#markAllocationIdAsInSync(String, long)} (even if a_call is added after notifying all waiters in {@link ReplicationTracker#updateLocalCheckpoint(String, long)}).__@throws InterruptedException   if the main test thread was interrupted while waiting_@throws BrokenBarrierException if the barrier was broken while the main test thread was waiting;public void testRaceUpdatingGlobalCheckpoint() throws InterruptedException, BrokenBarrierException {__        final AllocationId active = AllocationId.newInitializing()__        final AllocationId initializing = AllocationId.newInitializing()__        final CyclicBarrier barrier = new CyclicBarrier(4)___        final int activeLocalCheckpoint = randomIntBetween(0, Integer.MAX_VALUE - 1)__        final ReplicationTracker tracker = newTracker(active)__        tracker.updateFromMaster(_                randomNonNegativeLong(),_                Collections.singleton(active.getId()),_                routingTable(Collections.singleton(initializing), active),_                emptySet())__        tracker.activatePrimaryMode(activeLocalCheckpoint)__        final int nextActiveLocalCheckpoint = randomIntBetween(activeLocalCheckpoint + 1, Integer.MAX_VALUE)__        final Thread activeThread = new Thread(() -> {_            try {_                barrier.await()__            } catch (final BrokenBarrierException | InterruptedException e) {_                throw new RuntimeException(e)__            }_            tracker.updateLocalCheckpoint(active.getId(), nextActiveLocalCheckpoint)__        })___        final int initializingLocalCheckpoint = randomIntBetween(0, nextActiveLocalCheckpoint - 1)__        final Thread initializingThread = new Thread(() -> {_            try {_                barrier.await()__            } catch (final BrokenBarrierException | InterruptedException e) {_                throw new RuntimeException(e)__            }_            tracker.updateLocalCheckpoint(initializing.getId(), nextActiveLocalCheckpoint)__        })___        final Thread markingThread = new Thread(() -> {_            try {_                barrier.await()__                tracker.initiateTracking(initializing.getId())__                tracker.markAllocationIdAsInSync(initializing.getId(), initializingLocalCheckpoint - 1)__            } catch (final BrokenBarrierException | InterruptedException e) {_                throw new RuntimeException(e)__            }_        })___        activeThread.start()__        initializingThread.start()__        markingThread.start()__        barrier.await()___        activeThread.join()__        initializingThread.join()__        markingThread.join()___        assertThat(tracker.getGlobalCheckpoint(), equalTo((long) nextActiveLocalCheckpoint))__    };if,we,do,not,update,the,global,checkpoint,in,link,replication,tracker,mark,allocation,id,as,in,sync,string,long,after,adding,the,allocation,id,to,the,in,sync,set,and,removing,it,from,pending,the,local,checkpoint,update,that,freed,the,thread,waiting,for,the,local,checkpoint,to,advance,could,miss,updating,the,global,checkpoint,in,a,race,if,the,waiting,thread,did,not,add,the,allocation,id,to,the,in,sync,set,and,remove,it,from,the,pending,set,before,the,local,checkpoint,updating,thread,executed,the,global,checkpoint,update,this,test,fails,without,an,additional,call,to,link,replication,tracker,update,global,checkpoint,on,primary,after,removing,the,allocation,id,from,the,pending,set,in,link,replication,tracker,mark,allocation,id,as,in,sync,string,long,even,if,a,call,is,added,after,notifying,all,waiters,in,link,replication,tracker,update,local,checkpoint,string,long,throws,interrupted,exception,if,the,main,test,thread,was,interrupted,while,waiting,throws,broken,barrier,exception,if,the,barrier,was,broken,while,the,main,test,thread,was,waiting;public,void,test,race,updating,global,checkpoint,throws,interrupted,exception,broken,barrier,exception,final,allocation,id,active,allocation,id,new,initializing,final,allocation,id,initializing,allocation,id,new,initializing,final,cyclic,barrier,barrier,new,cyclic,barrier,4,final,int,active,local,checkpoint,random,int,between,0,integer,1,final,replication,tracker,tracker,new,tracker,active,tracker,update,from,master,random,non,negative,long,collections,singleton,active,get,id,routing,table,collections,singleton,initializing,active,empty,set,tracker,activate,primary,mode,active,local,checkpoint,final,int,next,active,local,checkpoint,random,int,between,active,local,checkpoint,1,integer,final,thread,active,thread,new,thread,try,barrier,await,catch,final,broken,barrier,exception,interrupted,exception,e,throw,new,runtime,exception,e,tracker,update,local,checkpoint,active,get,id,next,active,local,checkpoint,final,int,initializing,local,checkpoint,random,int,between,0,next,active,local,checkpoint,1,final,thread,initializing,thread,new,thread,try,barrier,await,catch,final,broken,barrier,exception,interrupted,exception,e,throw,new,runtime,exception,e,tracker,update,local,checkpoint,initializing,get,id,next,active,local,checkpoint,final,thread,marking,thread,new,thread,try,barrier,await,tracker,initiate,tracking,initializing,get,id,tracker,mark,allocation,id,as,in,sync,initializing,get,id,initializing,local,checkpoint,1,catch,final,broken,barrier,exception,interrupted,exception,e,throw,new,runtime,exception,e,active,thread,start,initializing,thread,start,marking,thread,start,barrier,await,active,thread,join,initializing,thread,join,marking,thread,join,assert,that,tracker,get,global,checkpoint,equal,to,long,next,active,local,checkpoint
ReplicationTrackerTests -> public void testRaceUpdatingGlobalCheckpoint() throws InterruptedException, BrokenBarrierException;1525334055;If we do not update the global checkpoint in {@link ReplicationTracker#markAllocationIdAsInSync(String, long)} after adding the_allocation ID to the in-sync set and removing it from pending, the local checkpoint update that freed the thread waiting for the_local checkpoint to advance could miss updating the global checkpoint in a race if the waiting thread did not add the allocation_ID to the in-sync set and remove it from the pending set before the local checkpoint updating thread executed the global checkpoint_update. This test fails without an additional call to {@link ReplicationTracker#updateGlobalCheckpointOnPrimary()} after_removing the allocation ID from the pending set in {@link ReplicationTracker#markAllocationIdAsInSync(String, long)} (even if a_call is added after notifying all waiters in {@link ReplicationTracker#updateLocalCheckpoint(String, long)}).__@throws InterruptedException   if the main test thread was interrupted while waiting_@throws BrokenBarrierException if the barrier was broken while the main test thread was waiting;public void testRaceUpdatingGlobalCheckpoint() throws InterruptedException, BrokenBarrierException {__        final AllocationId active = AllocationId.newInitializing()__        final AllocationId initializing = AllocationId.newInitializing()__        final CyclicBarrier barrier = new CyclicBarrier(4)___        final int activeLocalCheckpoint = randomIntBetween(0, Integer.MAX_VALUE - 1)__        final ReplicationTracker tracker = newTracker(active)__        tracker.updateFromMaster(_                randomNonNegativeLong(),_                Collections.singleton(active.getId()),_                routingTable(Collections.singleton(initializing), active),_                emptySet())__        tracker.activatePrimaryMode(activeLocalCheckpoint)__        final int nextActiveLocalCheckpoint = randomIntBetween(activeLocalCheckpoint + 1, Integer.MAX_VALUE)__        final Thread activeThread = new Thread(() -> {_            try {_                barrier.await()__            } catch (final BrokenBarrierException | InterruptedException e) {_                throw new RuntimeException(e)__            }_            tracker.updateLocalCheckpoint(active.getId(), nextActiveLocalCheckpoint)__        })___        final int initializingLocalCheckpoint = randomIntBetween(0, nextActiveLocalCheckpoint - 1)__        final Thread initializingThread = new Thread(() -> {_            try {_                barrier.await()__            } catch (final BrokenBarrierException | InterruptedException e) {_                throw new RuntimeException(e)__            }_            tracker.updateLocalCheckpoint(initializing.getId(), nextActiveLocalCheckpoint)__        })___        final Thread markingThread = new Thread(() -> {_            try {_                barrier.await()__                tracker.initiateTracking(initializing.getId())__                tracker.markAllocationIdAsInSync(initializing.getId(), initializingLocalCheckpoint - 1)__            } catch (final BrokenBarrierException | InterruptedException e) {_                throw new RuntimeException(e)__            }_        })___        activeThread.start()__        initializingThread.start()__        markingThread.start()__        barrier.await()___        activeThread.join()__        initializingThread.join()__        markingThread.join()___        assertThat(tracker.getGlobalCheckpoint(), equalTo((long) nextActiveLocalCheckpoint))__    };if,we,do,not,update,the,global,checkpoint,in,link,replication,tracker,mark,allocation,id,as,in,sync,string,long,after,adding,the,allocation,id,to,the,in,sync,set,and,removing,it,from,pending,the,local,checkpoint,update,that,freed,the,thread,waiting,for,the,local,checkpoint,to,advance,could,miss,updating,the,global,checkpoint,in,a,race,if,the,waiting,thread,did,not,add,the,allocation,id,to,the,in,sync,set,and,remove,it,from,the,pending,set,before,the,local,checkpoint,updating,thread,executed,the,global,checkpoint,update,this,test,fails,without,an,additional,call,to,link,replication,tracker,update,global,checkpoint,on,primary,after,removing,the,allocation,id,from,the,pending,set,in,link,replication,tracker,mark,allocation,id,as,in,sync,string,long,even,if,a,call,is,added,after,notifying,all,waiters,in,link,replication,tracker,update,local,checkpoint,string,long,throws,interrupted,exception,if,the,main,test,thread,was,interrupted,while,waiting,throws,broken,barrier,exception,if,the,barrier,was,broken,while,the,main,test,thread,was,waiting;public,void,test,race,updating,global,checkpoint,throws,interrupted,exception,broken,barrier,exception,final,allocation,id,active,allocation,id,new,initializing,final,allocation,id,initializing,allocation,id,new,initializing,final,cyclic,barrier,barrier,new,cyclic,barrier,4,final,int,active,local,checkpoint,random,int,between,0,integer,1,final,replication,tracker,tracker,new,tracker,active,tracker,update,from,master,random,non,negative,long,collections,singleton,active,get,id,routing,table,collections,singleton,initializing,active,empty,set,tracker,activate,primary,mode,active,local,checkpoint,final,int,next,active,local,checkpoint,random,int,between,active,local,checkpoint,1,integer,final,thread,active,thread,new,thread,try,barrier,await,catch,final,broken,barrier,exception,interrupted,exception,e,throw,new,runtime,exception,e,tracker,update,local,checkpoint,active,get,id,next,active,local,checkpoint,final,int,initializing,local,checkpoint,random,int,between,0,next,active,local,checkpoint,1,final,thread,initializing,thread,new,thread,try,barrier,await,catch,final,broken,barrier,exception,interrupted,exception,e,throw,new,runtime,exception,e,tracker,update,local,checkpoint,initializing,get,id,next,active,local,checkpoint,final,thread,marking,thread,new,thread,try,barrier,await,tracker,initiate,tracking,initializing,get,id,tracker,mark,allocation,id,as,in,sync,initializing,get,id,initializing,local,checkpoint,1,catch,final,broken,barrier,exception,interrupted,exception,e,throw,new,runtime,exception,e,active,thread,start,initializing,thread,start,marking,thread,start,barrier,await,active,thread,join,initializing,thread,join,marking,thread,join,assert,that,tracker,get,global,checkpoint,equal,to,long,next,active,local,checkpoint
ReplicationTrackerTests -> public void testRaceUpdatingGlobalCheckpoint() throws InterruptedException, BrokenBarrierException;1533295538;If we do not update the global checkpoint in {@link ReplicationTracker#markAllocationIdAsInSync(String, long)} after adding the_allocation ID to the in-sync set and removing it from pending, the local checkpoint update that freed the thread waiting for the_local checkpoint to advance could miss updating the global checkpoint in a race if the waiting thread did not add the allocation_ID to the in-sync set and remove it from the pending set before the local checkpoint updating thread executed the global checkpoint_update. This test fails without an additional call to {@link ReplicationTracker#updateGlobalCheckpointOnPrimary()} after_removing the allocation ID from the pending set in {@link ReplicationTracker#markAllocationIdAsInSync(String, long)} (even if a_call is added after notifying all waiters in {@link ReplicationTracker#updateLocalCheckpoint(String, long)}).__@throws InterruptedException   if the main test thread was interrupted while waiting_@throws BrokenBarrierException if the barrier was broken while the main test thread was waiting;public void testRaceUpdatingGlobalCheckpoint() throws InterruptedException, BrokenBarrierException {__        final AllocationId active = AllocationId.newInitializing()__        final AllocationId initializing = AllocationId.newInitializing()__        final CyclicBarrier barrier = new CyclicBarrier(4)___        final int activeLocalCheckpoint = randomIntBetween(0, Integer.MAX_VALUE - 1)__        final ReplicationTracker tracker = newTracker(active)__        tracker.updateFromMaster(_                randomNonNegativeLong(),_                Collections.singleton(active.getId()),_                routingTable(Collections.singleton(initializing), active),_                emptySet())__        tracker.activatePrimaryMode(activeLocalCheckpoint)__        final int nextActiveLocalCheckpoint = randomIntBetween(activeLocalCheckpoint + 1, Integer.MAX_VALUE)__        final Thread activeThread = new Thread(() -> {_            try {_                barrier.await()__            } catch (final BrokenBarrierException | InterruptedException e) {_                throw new RuntimeException(e)__            }_            tracker.updateLocalCheckpoint(active.getId(), nextActiveLocalCheckpoint)__        })___        final int initializingLocalCheckpoint = randomIntBetween(0, nextActiveLocalCheckpoint - 1)__        final Thread initializingThread = new Thread(() -> {_            try {_                barrier.await()__            } catch (final BrokenBarrierException | InterruptedException e) {_                throw new RuntimeException(e)__            }_            tracker.updateLocalCheckpoint(initializing.getId(), nextActiveLocalCheckpoint)__        })___        final Thread markingThread = new Thread(() -> {_            try {_                barrier.await()__                tracker.initiateTracking(initializing.getId())__                tracker.markAllocationIdAsInSync(initializing.getId(), initializingLocalCheckpoint - 1)__            } catch (final BrokenBarrierException | InterruptedException e) {_                throw new RuntimeException(e)__            }_        })___        activeThread.start()__        initializingThread.start()__        markingThread.start()__        barrier.await()___        activeThread.join()__        initializingThread.join()__        markingThread.join()___        assertThat(tracker.getGlobalCheckpoint(), equalTo((long) nextActiveLocalCheckpoint))__    };if,we,do,not,update,the,global,checkpoint,in,link,replication,tracker,mark,allocation,id,as,in,sync,string,long,after,adding,the,allocation,id,to,the,in,sync,set,and,removing,it,from,pending,the,local,checkpoint,update,that,freed,the,thread,waiting,for,the,local,checkpoint,to,advance,could,miss,updating,the,global,checkpoint,in,a,race,if,the,waiting,thread,did,not,add,the,allocation,id,to,the,in,sync,set,and,remove,it,from,the,pending,set,before,the,local,checkpoint,updating,thread,executed,the,global,checkpoint,update,this,test,fails,without,an,additional,call,to,link,replication,tracker,update,global,checkpoint,on,primary,after,removing,the,allocation,id,from,the,pending,set,in,link,replication,tracker,mark,allocation,id,as,in,sync,string,long,even,if,a,call,is,added,after,notifying,all,waiters,in,link,replication,tracker,update,local,checkpoint,string,long,throws,interrupted,exception,if,the,main,test,thread,was,interrupted,while,waiting,throws,broken,barrier,exception,if,the,barrier,was,broken,while,the,main,test,thread,was,waiting;public,void,test,race,updating,global,checkpoint,throws,interrupted,exception,broken,barrier,exception,final,allocation,id,active,allocation,id,new,initializing,final,allocation,id,initializing,allocation,id,new,initializing,final,cyclic,barrier,barrier,new,cyclic,barrier,4,final,int,active,local,checkpoint,random,int,between,0,integer,1,final,replication,tracker,tracker,new,tracker,active,tracker,update,from,master,random,non,negative,long,collections,singleton,active,get,id,routing,table,collections,singleton,initializing,active,empty,set,tracker,activate,primary,mode,active,local,checkpoint,final,int,next,active,local,checkpoint,random,int,between,active,local,checkpoint,1,integer,final,thread,active,thread,new,thread,try,barrier,await,catch,final,broken,barrier,exception,interrupted,exception,e,throw,new,runtime,exception,e,tracker,update,local,checkpoint,active,get,id,next,active,local,checkpoint,final,int,initializing,local,checkpoint,random,int,between,0,next,active,local,checkpoint,1,final,thread,initializing,thread,new,thread,try,barrier,await,catch,final,broken,barrier,exception,interrupted,exception,e,throw,new,runtime,exception,e,tracker,update,local,checkpoint,initializing,get,id,next,active,local,checkpoint,final,thread,marking,thread,new,thread,try,barrier,await,tracker,initiate,tracking,initializing,get,id,tracker,mark,allocation,id,as,in,sync,initializing,get,id,initializing,local,checkpoint,1,catch,final,broken,barrier,exception,interrupted,exception,e,throw,new,runtime,exception,e,active,thread,start,initializing,thread,start,marking,thread,start,barrier,await,active,thread,join,initializing,thread,join,marking,thread,join,assert,that,tracker,get,global,checkpoint,equal,to,long,next,active,local,checkpoint
ReplicationTrackerTests -> public void testRaceUpdatingGlobalCheckpoint() throws InterruptedException, BrokenBarrierException;1533738061;If we do not update the global checkpoint in {@link ReplicationTracker#markAllocationIdAsInSync(String, long)} after adding the_allocation ID to the in-sync set and removing it from pending, the local checkpoint update that freed the thread waiting for the_local checkpoint to advance could miss updating the global checkpoint in a race if the waiting thread did not add the allocation_ID to the in-sync set and remove it from the pending set before the local checkpoint updating thread executed the global checkpoint_update. This test fails without an additional call to {@link ReplicationTracker#updateGlobalCheckpointOnPrimary()} after_removing the allocation ID from the pending set in {@link ReplicationTracker#markAllocationIdAsInSync(String, long)} (even if a_call is added after notifying all waiters in {@link ReplicationTracker#updateLocalCheckpoint(String, long)}).__@throws InterruptedException   if the main test thread was interrupted while waiting_@throws BrokenBarrierException if the barrier was broken while the main test thread was waiting;public void testRaceUpdatingGlobalCheckpoint() throws InterruptedException, BrokenBarrierException {__        final AllocationId active = AllocationId.newInitializing()__        final AllocationId initializing = AllocationId.newInitializing()__        final CyclicBarrier barrier = new CyclicBarrier(4)___        final int activeLocalCheckpoint = randomIntBetween(0, Integer.MAX_VALUE - 1)__        final ReplicationTracker tracker = newTracker(active)__        tracker.updateFromMaster(_                randomNonNegativeLong(),_                Collections.singleton(active.getId()),_                routingTable(Collections.singleton(initializing), active),_                emptySet())__        tracker.activatePrimaryMode(activeLocalCheckpoint)__        final int nextActiveLocalCheckpoint = randomIntBetween(activeLocalCheckpoint + 1, Integer.MAX_VALUE)__        final Thread activeThread = new Thread(() -> {_            try {_                barrier.await()__            } catch (final BrokenBarrierException | InterruptedException e) {_                throw new RuntimeException(e)__            }_            tracker.updateLocalCheckpoint(active.getId(), nextActiveLocalCheckpoint)__        })___        final int initializingLocalCheckpoint = randomIntBetween(0, nextActiveLocalCheckpoint - 1)__        final Thread initializingThread = new Thread(() -> {_            try {_                barrier.await()__            } catch (final BrokenBarrierException | InterruptedException e) {_                throw new RuntimeException(e)__            }_            tracker.updateLocalCheckpoint(initializing.getId(), nextActiveLocalCheckpoint)__        })___        final Thread markingThread = new Thread(() -> {_            try {_                barrier.await()__                tracker.initiateTracking(initializing.getId())__                tracker.markAllocationIdAsInSync(initializing.getId(), initializingLocalCheckpoint - 1)__            } catch (final BrokenBarrierException | InterruptedException e) {_                throw new RuntimeException(e)__            }_        })___        activeThread.start()__        initializingThread.start()__        markingThread.start()__        barrier.await()___        activeThread.join()__        initializingThread.join()__        markingThread.join()___        assertThat(tracker.getGlobalCheckpoint(), equalTo((long) nextActiveLocalCheckpoint))__    };if,we,do,not,update,the,global,checkpoint,in,link,replication,tracker,mark,allocation,id,as,in,sync,string,long,after,adding,the,allocation,id,to,the,in,sync,set,and,removing,it,from,pending,the,local,checkpoint,update,that,freed,the,thread,waiting,for,the,local,checkpoint,to,advance,could,miss,updating,the,global,checkpoint,in,a,race,if,the,waiting,thread,did,not,add,the,allocation,id,to,the,in,sync,set,and,remove,it,from,the,pending,set,before,the,local,checkpoint,updating,thread,executed,the,global,checkpoint,update,this,test,fails,without,an,additional,call,to,link,replication,tracker,update,global,checkpoint,on,primary,after,removing,the,allocation,id,from,the,pending,set,in,link,replication,tracker,mark,allocation,id,as,in,sync,string,long,even,if,a,call,is,added,after,notifying,all,waiters,in,link,replication,tracker,update,local,checkpoint,string,long,throws,interrupted,exception,if,the,main,test,thread,was,interrupted,while,waiting,throws,broken,barrier,exception,if,the,barrier,was,broken,while,the,main,test,thread,was,waiting;public,void,test,race,updating,global,checkpoint,throws,interrupted,exception,broken,barrier,exception,final,allocation,id,active,allocation,id,new,initializing,final,allocation,id,initializing,allocation,id,new,initializing,final,cyclic,barrier,barrier,new,cyclic,barrier,4,final,int,active,local,checkpoint,random,int,between,0,integer,1,final,replication,tracker,tracker,new,tracker,active,tracker,update,from,master,random,non,negative,long,collections,singleton,active,get,id,routing,table,collections,singleton,initializing,active,empty,set,tracker,activate,primary,mode,active,local,checkpoint,final,int,next,active,local,checkpoint,random,int,between,active,local,checkpoint,1,integer,final,thread,active,thread,new,thread,try,barrier,await,catch,final,broken,barrier,exception,interrupted,exception,e,throw,new,runtime,exception,e,tracker,update,local,checkpoint,active,get,id,next,active,local,checkpoint,final,int,initializing,local,checkpoint,random,int,between,0,next,active,local,checkpoint,1,final,thread,initializing,thread,new,thread,try,barrier,await,catch,final,broken,barrier,exception,interrupted,exception,e,throw,new,runtime,exception,e,tracker,update,local,checkpoint,initializing,get,id,next,active,local,checkpoint,final,thread,marking,thread,new,thread,try,barrier,await,tracker,initiate,tracking,initializing,get,id,tracker,mark,allocation,id,as,in,sync,initializing,get,id,initializing,local,checkpoint,1,catch,final,broken,barrier,exception,interrupted,exception,e,throw,new,runtime,exception,e,active,thread,start,initializing,thread,start,marking,thread,start,barrier,await,active,thread,join,initializing,thread,join,marking,thread,join,assert,that,tracker,get,global,checkpoint,equal,to,long,next,active,local,checkpoint
ReplicationTrackerTests -> public void testRaceUpdatingGlobalCheckpoint() throws InterruptedException, BrokenBarrierException;1539951844;If we do not update the global checkpoint in {@link ReplicationTracker#markAllocationIdAsInSync(String, long)} after adding the_allocation ID to the in-sync set and removing it from pending, the local checkpoint update that freed the thread waiting for the_local checkpoint to advance could miss updating the global checkpoint in a race if the waiting thread did not add the allocation_ID to the in-sync set and remove it from the pending set before the local checkpoint updating thread executed the global checkpoint_update. This test fails without an additional call to {@link ReplicationTracker#updateGlobalCheckpointOnPrimary()} after_removing the allocation ID from the pending set in {@link ReplicationTracker#markAllocationIdAsInSync(String, long)} (even if a_call is added after notifying all waiters in {@link ReplicationTracker#updateLocalCheckpoint(String, long)}).__@throws InterruptedException   if the main test thread was interrupted while waiting_@throws BrokenBarrierException if the barrier was broken while the main test thread was waiting;public void testRaceUpdatingGlobalCheckpoint() throws InterruptedException, BrokenBarrierException {__        final AllocationId active = AllocationId.newInitializing()__        final AllocationId initializing = AllocationId.newInitializing()__        final CyclicBarrier barrier = new CyclicBarrier(4)___        final int activeLocalCheckpoint = randomIntBetween(0, Integer.MAX_VALUE - 1)__        final ReplicationTracker tracker = newTracker(active)__        tracker.updateFromMaster(_                randomNonNegativeLong(),_                Collections.singleton(active.getId()),_                routingTable(Collections.singleton(initializing), active),_                emptySet())__        tracker.activatePrimaryMode(activeLocalCheckpoint)__        final int nextActiveLocalCheckpoint = randomIntBetween(activeLocalCheckpoint + 1, Integer.MAX_VALUE)__        final Thread activeThread = new Thread(() -> {_            try {_                barrier.await()__            } catch (final BrokenBarrierException | InterruptedException e) {_                throw new RuntimeException(e)__            }_            tracker.updateLocalCheckpoint(active.getId(), nextActiveLocalCheckpoint)__        })___        final int initializingLocalCheckpoint = randomIntBetween(0, nextActiveLocalCheckpoint - 1)__        final Thread initializingThread = new Thread(() -> {_            try {_                barrier.await()__            } catch (final BrokenBarrierException | InterruptedException e) {_                throw new RuntimeException(e)__            }_            tracker.updateLocalCheckpoint(initializing.getId(), nextActiveLocalCheckpoint)__        })___        final Thread markingThread = new Thread(() -> {_            try {_                barrier.await()__                tracker.initiateTracking(initializing.getId())__                tracker.markAllocationIdAsInSync(initializing.getId(), initializingLocalCheckpoint - 1)__            } catch (final BrokenBarrierException | InterruptedException e) {_                throw new RuntimeException(e)__            }_        })___        activeThread.start()__        initializingThread.start()__        markingThread.start()__        barrier.await()___        activeThread.join()__        initializingThread.join()__        markingThread.join()___        assertThat(tracker.getGlobalCheckpoint(), equalTo((long) nextActiveLocalCheckpoint))__    };if,we,do,not,update,the,global,checkpoint,in,link,replication,tracker,mark,allocation,id,as,in,sync,string,long,after,adding,the,allocation,id,to,the,in,sync,set,and,removing,it,from,pending,the,local,checkpoint,update,that,freed,the,thread,waiting,for,the,local,checkpoint,to,advance,could,miss,updating,the,global,checkpoint,in,a,race,if,the,waiting,thread,did,not,add,the,allocation,id,to,the,in,sync,set,and,remove,it,from,the,pending,set,before,the,local,checkpoint,updating,thread,executed,the,global,checkpoint,update,this,test,fails,without,an,additional,call,to,link,replication,tracker,update,global,checkpoint,on,primary,after,removing,the,allocation,id,from,the,pending,set,in,link,replication,tracker,mark,allocation,id,as,in,sync,string,long,even,if,a,call,is,added,after,notifying,all,waiters,in,link,replication,tracker,update,local,checkpoint,string,long,throws,interrupted,exception,if,the,main,test,thread,was,interrupted,while,waiting,throws,broken,barrier,exception,if,the,barrier,was,broken,while,the,main,test,thread,was,waiting;public,void,test,race,updating,global,checkpoint,throws,interrupted,exception,broken,barrier,exception,final,allocation,id,active,allocation,id,new,initializing,final,allocation,id,initializing,allocation,id,new,initializing,final,cyclic,barrier,barrier,new,cyclic,barrier,4,final,int,active,local,checkpoint,random,int,between,0,integer,1,final,replication,tracker,tracker,new,tracker,active,tracker,update,from,master,random,non,negative,long,collections,singleton,active,get,id,routing,table,collections,singleton,initializing,active,empty,set,tracker,activate,primary,mode,active,local,checkpoint,final,int,next,active,local,checkpoint,random,int,between,active,local,checkpoint,1,integer,final,thread,active,thread,new,thread,try,barrier,await,catch,final,broken,barrier,exception,interrupted,exception,e,throw,new,runtime,exception,e,tracker,update,local,checkpoint,active,get,id,next,active,local,checkpoint,final,int,initializing,local,checkpoint,random,int,between,0,next,active,local,checkpoint,1,final,thread,initializing,thread,new,thread,try,barrier,await,catch,final,broken,barrier,exception,interrupted,exception,e,throw,new,runtime,exception,e,tracker,update,local,checkpoint,initializing,get,id,next,active,local,checkpoint,final,thread,marking,thread,new,thread,try,barrier,await,tracker,initiate,tracking,initializing,get,id,tracker,mark,allocation,id,as,in,sync,initializing,get,id,initializing,local,checkpoint,1,catch,final,broken,barrier,exception,interrupted,exception,e,throw,new,runtime,exception,e,active,thread,start,initializing,thread,start,marking,thread,start,barrier,await,active,thread,join,initializing,thread,join,marking,thread,join,assert,that,tracker,get,global,checkpoint,equal,to,long,next,active,local,checkpoint
ReplicationTrackerTests -> public void testRaceUpdatingGlobalCheckpoint() throws InterruptedException, BrokenBarrierException;1546875837;If we do not update the global checkpoint in {@link ReplicationTracker#markAllocationIdAsInSync(String, long)} after adding the_allocation ID to the in-sync set and removing it from pending, the local checkpoint update that freed the thread waiting for the_local checkpoint to advance could miss updating the global checkpoint in a race if the waiting thread did not add the allocation_ID to the in-sync set and remove it from the pending set before the local checkpoint updating thread executed the global checkpoint_update. This test fails without an additional call to {@link ReplicationTracker#updateGlobalCheckpointOnPrimary()} after_removing the allocation ID from the pending set in {@link ReplicationTracker#markAllocationIdAsInSync(String, long)} (even if a_call is added after notifying all waiters in {@link ReplicationTracker#updateLocalCheckpoint(String, long)}).__@throws InterruptedException   if the main test thread was interrupted while waiting_@throws BrokenBarrierException if the barrier was broken while the main test thread was waiting;public void testRaceUpdatingGlobalCheckpoint() throws InterruptedException, BrokenBarrierException {__        final AllocationId active = AllocationId.newInitializing()__        final AllocationId initializing = AllocationId.newInitializing()__        final CyclicBarrier barrier = new CyclicBarrier(4)___        final int activeLocalCheckpoint = randomIntBetween(0, Integer.MAX_VALUE - 1)__        final ReplicationTracker tracker = newTracker(active)__        tracker.updateFromMaster(_                randomNonNegativeLong(),_                Collections.singleton(active.getId()),_                routingTable(Collections.singleton(initializing), active),_                emptySet())__        tracker.activatePrimaryMode(activeLocalCheckpoint)__        final int nextActiveLocalCheckpoint = randomIntBetween(activeLocalCheckpoint + 1, Integer.MAX_VALUE)__        final Thread activeThread = new Thread(() -> {_            try {_                barrier.await()__            } catch (final BrokenBarrierException | InterruptedException e) {_                throw new RuntimeException(e)__            }_            tracker.updateLocalCheckpoint(active.getId(), nextActiveLocalCheckpoint)__        })___        final int initializingLocalCheckpoint = randomIntBetween(0, nextActiveLocalCheckpoint - 1)__        final Thread initializingThread = new Thread(() -> {_            try {_                barrier.await()__            } catch (final BrokenBarrierException | InterruptedException e) {_                throw new RuntimeException(e)__            }_            tracker.updateLocalCheckpoint(initializing.getId(), nextActiveLocalCheckpoint)__        })___        final Thread markingThread = new Thread(() -> {_            try {_                barrier.await()__                tracker.initiateTracking(initializing.getId())__                tracker.markAllocationIdAsInSync(initializing.getId(), initializingLocalCheckpoint - 1)__            } catch (final BrokenBarrierException | InterruptedException e) {_                throw new RuntimeException(e)__            }_        })___        activeThread.start()__        initializingThread.start()__        markingThread.start()__        barrier.await()___        activeThread.join()__        initializingThread.join()__        markingThread.join()___        assertThat(tracker.getGlobalCheckpoint(), equalTo((long) nextActiveLocalCheckpoint))__    };if,we,do,not,update,the,global,checkpoint,in,link,replication,tracker,mark,allocation,id,as,in,sync,string,long,after,adding,the,allocation,id,to,the,in,sync,set,and,removing,it,from,pending,the,local,checkpoint,update,that,freed,the,thread,waiting,for,the,local,checkpoint,to,advance,could,miss,updating,the,global,checkpoint,in,a,race,if,the,waiting,thread,did,not,add,the,allocation,id,to,the,in,sync,set,and,remove,it,from,the,pending,set,before,the,local,checkpoint,updating,thread,executed,the,global,checkpoint,update,this,test,fails,without,an,additional,call,to,link,replication,tracker,update,global,checkpoint,on,primary,after,removing,the,allocation,id,from,the,pending,set,in,link,replication,tracker,mark,allocation,id,as,in,sync,string,long,even,if,a,call,is,added,after,notifying,all,waiters,in,link,replication,tracker,update,local,checkpoint,string,long,throws,interrupted,exception,if,the,main,test,thread,was,interrupted,while,waiting,throws,broken,barrier,exception,if,the,barrier,was,broken,while,the,main,test,thread,was,waiting;public,void,test,race,updating,global,checkpoint,throws,interrupted,exception,broken,barrier,exception,final,allocation,id,active,allocation,id,new,initializing,final,allocation,id,initializing,allocation,id,new,initializing,final,cyclic,barrier,barrier,new,cyclic,barrier,4,final,int,active,local,checkpoint,random,int,between,0,integer,1,final,replication,tracker,tracker,new,tracker,active,tracker,update,from,master,random,non,negative,long,collections,singleton,active,get,id,routing,table,collections,singleton,initializing,active,empty,set,tracker,activate,primary,mode,active,local,checkpoint,final,int,next,active,local,checkpoint,random,int,between,active,local,checkpoint,1,integer,final,thread,active,thread,new,thread,try,barrier,await,catch,final,broken,barrier,exception,interrupted,exception,e,throw,new,runtime,exception,e,tracker,update,local,checkpoint,active,get,id,next,active,local,checkpoint,final,int,initializing,local,checkpoint,random,int,between,0,next,active,local,checkpoint,1,final,thread,initializing,thread,new,thread,try,barrier,await,catch,final,broken,barrier,exception,interrupted,exception,e,throw,new,runtime,exception,e,tracker,update,local,checkpoint,initializing,get,id,next,active,local,checkpoint,final,thread,marking,thread,new,thread,try,barrier,await,tracker,initiate,tracking,initializing,get,id,tracker,mark,allocation,id,as,in,sync,initializing,get,id,initializing,local,checkpoint,1,catch,final,broken,barrier,exception,interrupted,exception,e,throw,new,runtime,exception,e,active,thread,start,initializing,thread,start,marking,thread,start,barrier,await,active,thread,join,initializing,thread,join,marking,thread,join,assert,that,tracker,get,global,checkpoint,equal,to,long,next,active,local,checkpoint
ReplicationTrackerTests -> public void testRaceUpdatingGlobalCheckpoint() throws InterruptedException, BrokenBarrierException;1546927432;If we do not update the global checkpoint in {@link ReplicationTracker#markAllocationIdAsInSync(String, long)} after adding the_allocation ID to the in-sync set and removing it from pending, the local checkpoint update that freed the thread waiting for the_local checkpoint to advance could miss updating the global checkpoint in a race if the waiting thread did not add the allocation_ID to the in-sync set and remove it from the pending set before the local checkpoint updating thread executed the global checkpoint_update. This test fails without an additional call to {@link ReplicationTracker#updateGlobalCheckpointOnPrimary()} after_removing the allocation ID from the pending set in {@link ReplicationTracker#markAllocationIdAsInSync(String, long)} (even if a_call is added after notifying all waiters in {@link ReplicationTracker#updateLocalCheckpoint(String, long)}).__@throws InterruptedException   if the main test thread was interrupted while waiting_@throws BrokenBarrierException if the barrier was broken while the main test thread was waiting;public void testRaceUpdatingGlobalCheckpoint() throws InterruptedException, BrokenBarrierException {__        final AllocationId active = AllocationId.newInitializing()__        final AllocationId initializing = AllocationId.newInitializing()__        final CyclicBarrier barrier = new CyclicBarrier(4)___        final int activeLocalCheckpoint = randomIntBetween(0, Integer.MAX_VALUE - 1)__        final ReplicationTracker tracker = newTracker(active)__        tracker.updateFromMaster(_                randomNonNegativeLong(),_                Collections.singleton(active.getId()),_                routingTable(Collections.singleton(initializing), active),_                emptySet())__        tracker.activatePrimaryMode(activeLocalCheckpoint)__        final int nextActiveLocalCheckpoint = randomIntBetween(activeLocalCheckpoint + 1, Integer.MAX_VALUE)__        final Thread activeThread = new Thread(() -> {_            try {_                barrier.await()__            } catch (final BrokenBarrierException | InterruptedException e) {_                throw new RuntimeException(e)__            }_            tracker.updateLocalCheckpoint(active.getId(), nextActiveLocalCheckpoint)__        })___        final int initializingLocalCheckpoint = randomIntBetween(0, nextActiveLocalCheckpoint - 1)__        final Thread initializingThread = new Thread(() -> {_            try {_                barrier.await()__            } catch (final BrokenBarrierException | InterruptedException e) {_                throw new RuntimeException(e)__            }_            tracker.updateLocalCheckpoint(initializing.getId(), nextActiveLocalCheckpoint)__        })___        final Thread markingThread = new Thread(() -> {_            try {_                barrier.await()__                tracker.initiateTracking(initializing.getId())__                tracker.markAllocationIdAsInSync(initializing.getId(), initializingLocalCheckpoint - 1)__            } catch (final BrokenBarrierException | InterruptedException e) {_                throw new RuntimeException(e)__            }_        })___        activeThread.start()__        initializingThread.start()__        markingThread.start()__        barrier.await()___        activeThread.join()__        initializingThread.join()__        markingThread.join()___        assertThat(tracker.getGlobalCheckpoint(), equalTo((long) nextActiveLocalCheckpoint))__    };if,we,do,not,update,the,global,checkpoint,in,link,replication,tracker,mark,allocation,id,as,in,sync,string,long,after,adding,the,allocation,id,to,the,in,sync,set,and,removing,it,from,pending,the,local,checkpoint,update,that,freed,the,thread,waiting,for,the,local,checkpoint,to,advance,could,miss,updating,the,global,checkpoint,in,a,race,if,the,waiting,thread,did,not,add,the,allocation,id,to,the,in,sync,set,and,remove,it,from,the,pending,set,before,the,local,checkpoint,updating,thread,executed,the,global,checkpoint,update,this,test,fails,without,an,additional,call,to,link,replication,tracker,update,global,checkpoint,on,primary,after,removing,the,allocation,id,from,the,pending,set,in,link,replication,tracker,mark,allocation,id,as,in,sync,string,long,even,if,a,call,is,added,after,notifying,all,waiters,in,link,replication,tracker,update,local,checkpoint,string,long,throws,interrupted,exception,if,the,main,test,thread,was,interrupted,while,waiting,throws,broken,barrier,exception,if,the,barrier,was,broken,while,the,main,test,thread,was,waiting;public,void,test,race,updating,global,checkpoint,throws,interrupted,exception,broken,barrier,exception,final,allocation,id,active,allocation,id,new,initializing,final,allocation,id,initializing,allocation,id,new,initializing,final,cyclic,barrier,barrier,new,cyclic,barrier,4,final,int,active,local,checkpoint,random,int,between,0,integer,1,final,replication,tracker,tracker,new,tracker,active,tracker,update,from,master,random,non,negative,long,collections,singleton,active,get,id,routing,table,collections,singleton,initializing,active,empty,set,tracker,activate,primary,mode,active,local,checkpoint,final,int,next,active,local,checkpoint,random,int,between,active,local,checkpoint,1,integer,final,thread,active,thread,new,thread,try,barrier,await,catch,final,broken,barrier,exception,interrupted,exception,e,throw,new,runtime,exception,e,tracker,update,local,checkpoint,active,get,id,next,active,local,checkpoint,final,int,initializing,local,checkpoint,random,int,between,0,next,active,local,checkpoint,1,final,thread,initializing,thread,new,thread,try,barrier,await,catch,final,broken,barrier,exception,interrupted,exception,e,throw,new,runtime,exception,e,tracker,update,local,checkpoint,initializing,get,id,next,active,local,checkpoint,final,thread,marking,thread,new,thread,try,barrier,await,tracker,initiate,tracking,initializing,get,id,tracker,mark,allocation,id,as,in,sync,initializing,get,id,initializing,local,checkpoint,1,catch,final,broken,barrier,exception,interrupted,exception,e,throw,new,runtime,exception,e,active,thread,start,initializing,thread,start,marking,thread,start,barrier,await,active,thread,join,initializing,thread,join,marking,thread,join,assert,that,tracker,get,global,checkpoint,equal,to,long,next,active,local,checkpoint
ReplicationTrackerTests -> public void testRaceUpdatingGlobalCheckpoint() throws InterruptedException, BrokenBarrierException;1548593396;If we do not update the global checkpoint in {@link ReplicationTracker#markAllocationIdAsInSync(String, long)} after adding the_allocation ID to the in-sync set and removing it from pending, the local checkpoint update that freed the thread waiting for the_local checkpoint to advance could miss updating the global checkpoint in a race if the waiting thread did not add the allocation_ID to the in-sync set and remove it from the pending set before the local checkpoint updating thread executed the global checkpoint_update. This test fails without an additional call to {@link ReplicationTracker#updateGlobalCheckpointOnPrimary()} after_removing the allocation ID from the pending set in {@link ReplicationTracker#markAllocationIdAsInSync(String, long)} (even if a_call is added after notifying all waiters in {@link ReplicationTracker#updateLocalCheckpoint(String, long)}).__@throws InterruptedException   if the main test thread was interrupted while waiting_@throws BrokenBarrierException if the barrier was broken while the main test thread was waiting;public void testRaceUpdatingGlobalCheckpoint() throws InterruptedException, BrokenBarrierException {__        final AllocationId active = AllocationId.newInitializing()__        final AllocationId initializing = AllocationId.newInitializing()__        final CyclicBarrier barrier = new CyclicBarrier(4)___        final int activeLocalCheckpoint = randomIntBetween(0, Integer.MAX_VALUE - 1)__        final ReplicationTracker tracker = newTracker(active)__        tracker.updateFromMaster(_                randomNonNegativeLong(),_                Collections.singleton(active.getId()),_                routingTable(Collections.singleton(initializing), active),_                emptySet())__        tracker.activatePrimaryMode(activeLocalCheckpoint)__        final int nextActiveLocalCheckpoint = randomIntBetween(activeLocalCheckpoint + 1, Integer.MAX_VALUE)__        final Thread activeThread = new Thread(() -> {_            try {_                barrier.await()__            } catch (final BrokenBarrierException | InterruptedException e) {_                throw new RuntimeException(e)__            }_            tracker.updateLocalCheckpoint(active.getId(), nextActiveLocalCheckpoint)__        })___        final int initializingLocalCheckpoint = randomIntBetween(0, nextActiveLocalCheckpoint - 1)__        final Thread initializingThread = new Thread(() -> {_            try {_                barrier.await()__            } catch (final BrokenBarrierException | InterruptedException e) {_                throw new RuntimeException(e)__            }_            tracker.updateLocalCheckpoint(initializing.getId(), nextActiveLocalCheckpoint)__        })___        final Thread markingThread = new Thread(() -> {_            try {_                barrier.await()__                tracker.initiateTracking(initializing.getId())__                tracker.markAllocationIdAsInSync(initializing.getId(), initializingLocalCheckpoint - 1)__            } catch (final BrokenBarrierException | InterruptedException e) {_                throw new RuntimeException(e)__            }_        })___        activeThread.start()__        initializingThread.start()__        markingThread.start()__        barrier.await()___        activeThread.join()__        initializingThread.join()__        markingThread.join()___        assertThat(tracker.getGlobalCheckpoint(), equalTo((long) nextActiveLocalCheckpoint))__    };if,we,do,not,update,the,global,checkpoint,in,link,replication,tracker,mark,allocation,id,as,in,sync,string,long,after,adding,the,allocation,id,to,the,in,sync,set,and,removing,it,from,pending,the,local,checkpoint,update,that,freed,the,thread,waiting,for,the,local,checkpoint,to,advance,could,miss,updating,the,global,checkpoint,in,a,race,if,the,waiting,thread,did,not,add,the,allocation,id,to,the,in,sync,set,and,remove,it,from,the,pending,set,before,the,local,checkpoint,updating,thread,executed,the,global,checkpoint,update,this,test,fails,without,an,additional,call,to,link,replication,tracker,update,global,checkpoint,on,primary,after,removing,the,allocation,id,from,the,pending,set,in,link,replication,tracker,mark,allocation,id,as,in,sync,string,long,even,if,a,call,is,added,after,notifying,all,waiters,in,link,replication,tracker,update,local,checkpoint,string,long,throws,interrupted,exception,if,the,main,test,thread,was,interrupted,while,waiting,throws,broken,barrier,exception,if,the,barrier,was,broken,while,the,main,test,thread,was,waiting;public,void,test,race,updating,global,checkpoint,throws,interrupted,exception,broken,barrier,exception,final,allocation,id,active,allocation,id,new,initializing,final,allocation,id,initializing,allocation,id,new,initializing,final,cyclic,barrier,barrier,new,cyclic,barrier,4,final,int,active,local,checkpoint,random,int,between,0,integer,1,final,replication,tracker,tracker,new,tracker,active,tracker,update,from,master,random,non,negative,long,collections,singleton,active,get,id,routing,table,collections,singleton,initializing,active,empty,set,tracker,activate,primary,mode,active,local,checkpoint,final,int,next,active,local,checkpoint,random,int,between,active,local,checkpoint,1,integer,final,thread,active,thread,new,thread,try,barrier,await,catch,final,broken,barrier,exception,interrupted,exception,e,throw,new,runtime,exception,e,tracker,update,local,checkpoint,active,get,id,next,active,local,checkpoint,final,int,initializing,local,checkpoint,random,int,between,0,next,active,local,checkpoint,1,final,thread,initializing,thread,new,thread,try,barrier,await,catch,final,broken,barrier,exception,interrupted,exception,e,throw,new,runtime,exception,e,tracker,update,local,checkpoint,initializing,get,id,next,active,local,checkpoint,final,thread,marking,thread,new,thread,try,barrier,await,tracker,initiate,tracking,initializing,get,id,tracker,mark,allocation,id,as,in,sync,initializing,get,id,initializing,local,checkpoint,1,catch,final,broken,barrier,exception,interrupted,exception,e,throw,new,runtime,exception,e,active,thread,start,initializing,thread,start,marking,thread,start,barrier,await,active,thread,join,initializing,thread,join,marking,thread,join,assert,that,tracker,get,global,checkpoint,equal,to,long,next,active,local,checkpoint
ReplicationTrackerTests -> public void testRaceUpdatingGlobalCheckpoint() throws InterruptedException, BrokenBarrierException;1548944389;If we do not update the global checkpoint in {@link ReplicationTracker#markAllocationIdAsInSync(String, long)} after adding the_allocation ID to the in-sync set and removing it from pending, the local checkpoint update that freed the thread waiting for the_local checkpoint to advance could miss updating the global checkpoint in a race if the waiting thread did not add the allocation_ID to the in-sync set and remove it from the pending set before the local checkpoint updating thread executed the global checkpoint_update. This test fails without an additional call to {@link ReplicationTracker#updateGlobalCheckpointOnPrimary()} after_removing the allocation ID from the pending set in {@link ReplicationTracker#markAllocationIdAsInSync(String, long)} (even if a_call is added after notifying all waiters in {@link ReplicationTracker#updateLocalCheckpoint(String, long)}).__@throws InterruptedException   if the main test thread was interrupted while waiting_@throws BrokenBarrierException if the barrier was broken while the main test thread was waiting;public void testRaceUpdatingGlobalCheckpoint() throws InterruptedException, BrokenBarrierException {__        final AllocationId active = AllocationId.newInitializing()__        final AllocationId initializing = AllocationId.newInitializing()__        final CyclicBarrier barrier = new CyclicBarrier(4)___        final int activeLocalCheckpoint = randomIntBetween(0, Integer.MAX_VALUE - 1)__        final ReplicationTracker tracker = newTracker(active)__        tracker.updateFromMaster(_                randomNonNegativeLong(),_                Collections.singleton(active.getId()),_                routingTable(Collections.singleton(initializing), active),_                emptySet())__        tracker.activatePrimaryMode(activeLocalCheckpoint)__        final int nextActiveLocalCheckpoint = randomIntBetween(activeLocalCheckpoint + 1, Integer.MAX_VALUE)__        final Thread activeThread = new Thread(() -> {_            try {_                barrier.await()__            } catch (final BrokenBarrierException | InterruptedException e) {_                throw new RuntimeException(e)__            }_            tracker.updateLocalCheckpoint(active.getId(), nextActiveLocalCheckpoint)__        })___        final int initializingLocalCheckpoint = randomIntBetween(0, nextActiveLocalCheckpoint - 1)__        final Thread initializingThread = new Thread(() -> {_            try {_                barrier.await()__            } catch (final BrokenBarrierException | InterruptedException e) {_                throw new RuntimeException(e)__            }_            tracker.updateLocalCheckpoint(initializing.getId(), nextActiveLocalCheckpoint)__        })___        final Thread markingThread = new Thread(() -> {_            try {_                barrier.await()__                tracker.initiateTracking(initializing.getId())__                tracker.markAllocationIdAsInSync(initializing.getId(), initializingLocalCheckpoint - 1)__            } catch (final BrokenBarrierException | InterruptedException e) {_                throw new RuntimeException(e)__            }_        })___        activeThread.start()__        initializingThread.start()__        markingThread.start()__        barrier.await()___        activeThread.join()__        initializingThread.join()__        markingThread.join()___        assertThat(tracker.getGlobalCheckpoint(), equalTo((long) nextActiveLocalCheckpoint))__    };if,we,do,not,update,the,global,checkpoint,in,link,replication,tracker,mark,allocation,id,as,in,sync,string,long,after,adding,the,allocation,id,to,the,in,sync,set,and,removing,it,from,pending,the,local,checkpoint,update,that,freed,the,thread,waiting,for,the,local,checkpoint,to,advance,could,miss,updating,the,global,checkpoint,in,a,race,if,the,waiting,thread,did,not,add,the,allocation,id,to,the,in,sync,set,and,remove,it,from,the,pending,set,before,the,local,checkpoint,updating,thread,executed,the,global,checkpoint,update,this,test,fails,without,an,additional,call,to,link,replication,tracker,update,global,checkpoint,on,primary,after,removing,the,allocation,id,from,the,pending,set,in,link,replication,tracker,mark,allocation,id,as,in,sync,string,long,even,if,a,call,is,added,after,notifying,all,waiters,in,link,replication,tracker,update,local,checkpoint,string,long,throws,interrupted,exception,if,the,main,test,thread,was,interrupted,while,waiting,throws,broken,barrier,exception,if,the,barrier,was,broken,while,the,main,test,thread,was,waiting;public,void,test,race,updating,global,checkpoint,throws,interrupted,exception,broken,barrier,exception,final,allocation,id,active,allocation,id,new,initializing,final,allocation,id,initializing,allocation,id,new,initializing,final,cyclic,barrier,barrier,new,cyclic,barrier,4,final,int,active,local,checkpoint,random,int,between,0,integer,1,final,replication,tracker,tracker,new,tracker,active,tracker,update,from,master,random,non,negative,long,collections,singleton,active,get,id,routing,table,collections,singleton,initializing,active,empty,set,tracker,activate,primary,mode,active,local,checkpoint,final,int,next,active,local,checkpoint,random,int,between,active,local,checkpoint,1,integer,final,thread,active,thread,new,thread,try,barrier,await,catch,final,broken,barrier,exception,interrupted,exception,e,throw,new,runtime,exception,e,tracker,update,local,checkpoint,active,get,id,next,active,local,checkpoint,final,int,initializing,local,checkpoint,random,int,between,0,next,active,local,checkpoint,1,final,thread,initializing,thread,new,thread,try,barrier,await,catch,final,broken,barrier,exception,interrupted,exception,e,throw,new,runtime,exception,e,tracker,update,local,checkpoint,initializing,get,id,next,active,local,checkpoint,final,thread,marking,thread,new,thread,try,barrier,await,tracker,initiate,tracking,initializing,get,id,tracker,mark,allocation,id,as,in,sync,initializing,get,id,initializing,local,checkpoint,1,catch,final,broken,barrier,exception,interrupted,exception,e,throw,new,runtime,exception,e,active,thread,start,initializing,thread,start,marking,thread,start,barrier,await,active,thread,join,initializing,thread,join,marking,thread,join,assert,that,tracker,get,global,checkpoint,equal,to,long,next,active,local,checkpoint
ReplicationTrackerTests -> public void testRaceUpdatingGlobalCheckpoint() throws InterruptedException, BrokenBarrierException;1549059559;If we do not update the global checkpoint in {@link ReplicationTracker#markAllocationIdAsInSync(String, long)} after adding the_allocation ID to the in-sync set and removing it from pending, the local checkpoint update that freed the thread waiting for the_local checkpoint to advance could miss updating the global checkpoint in a race if the waiting thread did not add the allocation_ID to the in-sync set and remove it from the pending set before the local checkpoint updating thread executed the global checkpoint_update. This test fails without an additional call to {@link ReplicationTracker#updateGlobalCheckpointOnPrimary()} after_removing the allocation ID from the pending set in {@link ReplicationTracker#markAllocationIdAsInSync(String, long)} (even if a_call is added after notifying all waiters in {@link ReplicationTracker#updateLocalCheckpoint(String, long)}).__@throws InterruptedException   if the main test thread was interrupted while waiting_@throws BrokenBarrierException if the barrier was broken while the main test thread was waiting;public void testRaceUpdatingGlobalCheckpoint() throws InterruptedException, BrokenBarrierException {__        final AllocationId active = AllocationId.newInitializing()__        final AllocationId initializing = AllocationId.newInitializing()__        final CyclicBarrier barrier = new CyclicBarrier(4)___        final int activeLocalCheckpoint = randomIntBetween(0, Integer.MAX_VALUE - 1)__        final ReplicationTracker tracker = newTracker(active)__        tracker.updateFromMaster(_                randomNonNegativeLong(),_                Collections.singleton(active.getId()),_                routingTable(Collections.singleton(initializing), active),_                emptySet())__        tracker.activatePrimaryMode(activeLocalCheckpoint)__        final int nextActiveLocalCheckpoint = randomIntBetween(activeLocalCheckpoint + 1, Integer.MAX_VALUE)__        final Thread activeThread = new Thread(() -> {_            try {_                barrier.await()__            } catch (final BrokenBarrierException | InterruptedException e) {_                throw new RuntimeException(e)__            }_            tracker.updateLocalCheckpoint(active.getId(), nextActiveLocalCheckpoint)__        })___        final int initializingLocalCheckpoint = randomIntBetween(0, nextActiveLocalCheckpoint - 1)__        final Thread initializingThread = new Thread(() -> {_            try {_                barrier.await()__            } catch (final BrokenBarrierException | InterruptedException e) {_                throw new RuntimeException(e)__            }_            tracker.updateLocalCheckpoint(initializing.getId(), nextActiveLocalCheckpoint)__        })___        final Thread markingThread = new Thread(() -> {_            try {_                barrier.await()__                tracker.initiateTracking(initializing.getId())__                tracker.markAllocationIdAsInSync(initializing.getId(), initializingLocalCheckpoint - 1)__            } catch (final BrokenBarrierException | InterruptedException e) {_                throw new RuntimeException(e)__            }_        })___        activeThread.start()__        initializingThread.start()__        markingThread.start()__        barrier.await()___        activeThread.join()__        initializingThread.join()__        markingThread.join()___        assertThat(tracker.getGlobalCheckpoint(), equalTo((long) nextActiveLocalCheckpoint))__    };if,we,do,not,update,the,global,checkpoint,in,link,replication,tracker,mark,allocation,id,as,in,sync,string,long,after,adding,the,allocation,id,to,the,in,sync,set,and,removing,it,from,pending,the,local,checkpoint,update,that,freed,the,thread,waiting,for,the,local,checkpoint,to,advance,could,miss,updating,the,global,checkpoint,in,a,race,if,the,waiting,thread,did,not,add,the,allocation,id,to,the,in,sync,set,and,remove,it,from,the,pending,set,before,the,local,checkpoint,updating,thread,executed,the,global,checkpoint,update,this,test,fails,without,an,additional,call,to,link,replication,tracker,update,global,checkpoint,on,primary,after,removing,the,allocation,id,from,the,pending,set,in,link,replication,tracker,mark,allocation,id,as,in,sync,string,long,even,if,a,call,is,added,after,notifying,all,waiters,in,link,replication,tracker,update,local,checkpoint,string,long,throws,interrupted,exception,if,the,main,test,thread,was,interrupted,while,waiting,throws,broken,barrier,exception,if,the,barrier,was,broken,while,the,main,test,thread,was,waiting;public,void,test,race,updating,global,checkpoint,throws,interrupted,exception,broken,barrier,exception,final,allocation,id,active,allocation,id,new,initializing,final,allocation,id,initializing,allocation,id,new,initializing,final,cyclic,barrier,barrier,new,cyclic,barrier,4,final,int,active,local,checkpoint,random,int,between,0,integer,1,final,replication,tracker,tracker,new,tracker,active,tracker,update,from,master,random,non,negative,long,collections,singleton,active,get,id,routing,table,collections,singleton,initializing,active,empty,set,tracker,activate,primary,mode,active,local,checkpoint,final,int,next,active,local,checkpoint,random,int,between,active,local,checkpoint,1,integer,final,thread,active,thread,new,thread,try,barrier,await,catch,final,broken,barrier,exception,interrupted,exception,e,throw,new,runtime,exception,e,tracker,update,local,checkpoint,active,get,id,next,active,local,checkpoint,final,int,initializing,local,checkpoint,random,int,between,0,next,active,local,checkpoint,1,final,thread,initializing,thread,new,thread,try,barrier,await,catch,final,broken,barrier,exception,interrupted,exception,e,throw,new,runtime,exception,e,tracker,update,local,checkpoint,initializing,get,id,next,active,local,checkpoint,final,thread,marking,thread,new,thread,try,barrier,await,tracker,initiate,tracking,initializing,get,id,tracker,mark,allocation,id,as,in,sync,initializing,get,id,initializing,local,checkpoint,1,catch,final,broken,barrier,exception,interrupted,exception,e,throw,new,runtime,exception,e,active,thread,start,initializing,thread,start,marking,thread,start,barrier,await,active,thread,join,initializing,thread,join,marking,thread,join,assert,that,tracker,get,global,checkpoint,equal,to,long,next,active,local,checkpoint
