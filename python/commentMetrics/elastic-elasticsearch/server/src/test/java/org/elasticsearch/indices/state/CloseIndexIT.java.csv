commented;modifiers;parameterAmount;loc;comment;code
false;public;0;4;;public void testCloseMissingIndex() {     IndexNotFoundException e = expectThrows(IndexNotFoundException.class, () -> client().admin().indices().prepareClose("test").get()).     assertThat(e.getMessage(), is("no such index [test]")). }
false;public;0;6;;public void testCloseOneMissingIndex() {     createIndex("test1").     final IndexNotFoundException e = expectThrows(IndexNotFoundException.class, () -> client().admin().indices().prepareClose("test1", "test2").get()).     assertThat(e.getMessage(), is("no such index [test2]")). }
false;public;0;5;;public void testCloseOneMissingIndexIgnoreMissing() throws Exception {     createIndex("test1").     assertBusy(() -> assertAcked(client().admin().indices().prepareClose("test1", "test2").setIndicesOptions(lenientExpandOpen()))).     assertIndexIsClosed("test1"). }
false;public;0;5;;public void testCloseNoIndex() {     final ActionRequestValidationException e = expectThrows(ActionRequestValidationException.class, () -> client().admin().indices().prepareClose().get()).     assertThat(e.getMessage(), containsString("index is missing")). }
false;public;0;5;;public void testCloseNullIndex() {     final ActionRequestValidationException e = expectThrows(ActionRequestValidationException.class, () -> client().admin().indices().prepareClose((String[]) null).get()).     assertThat(e.getMessage(), containsString("index is missing")). }
false;public;0;14;;public void testCloseIndex() throws Exception {     final String indexName = randomAlphaOfLength(10).toLowerCase(Locale.ROOT).     createIndex(indexName).     final int nbDocs = randomIntBetween(0, 50).     indexRandom(randomBoolean(), false, randomBoolean(), IntStream.range(0, nbDocs).mapToObj(i -> client().prepareIndex(indexName, "_doc", String.valueOf(i)).setSource("num", i)).collect(toList())).     assertBusy(() -> assertAcked(client().admin().indices().prepareClose(indexName))).     assertIndexIsClosed(indexName).     assertAcked(client().admin().indices().prepareOpen(indexName)).     assertHitCount(client().prepareSearch(indexName).setSize(0).get(), nbDocs). }
false;public;0;17;;public void testCloseAlreadyClosedIndex() throws Exception {     final String indexName = randomAlphaOfLength(10).toLowerCase(Locale.ROOT).     createIndex(indexName).     if (randomBoolean()) {         indexRandom(randomBoolean(), false, randomBoolean(), IntStream.range(0, randomIntBetween(1, 10)).mapToObj(i -> client().prepareIndex(indexName, "_doc", String.valueOf(i)).setSource("num", i)).collect(toList())).     }     // First close should be acked     assertBusy(() -> assertAcked(client().admin().indices().prepareClose(indexName))).     assertIndexIsClosed(indexName).     // Second close should be acked too     final ActiveShardCount activeShardCount = randomFrom(ActiveShardCount.NONE, ActiveShardCount.DEFAULT, ActiveShardCount.ALL).     assertBusy(() -> assertAcked(client().admin().indices().prepareClose(indexName).setWaitForActiveShards(activeShardCount))).     assertIndexIsClosed(indexName). }
false;public;0;13;;public void testCloseUnassignedIndex() throws Exception {     final String indexName = randomAlphaOfLength(10).toLowerCase(Locale.ROOT).     assertAcked(prepareCreate(indexName).setWaitForActiveShards(ActiveShardCount.NONE).setSettings(Settings.builder().put("index.routing.allocation.include._name", "nothing").build())).     final ClusterState clusterState = client().admin().cluster().prepareState().get().getState().     assertThat(clusterState.metaData().indices().get(indexName).getState(), is(IndexMetaData.State.OPEN)).     assertThat(clusterState.routingTable().allShards().stream().allMatch(ShardRouting::unassigned), is(true)).     assertBusy(() -> assertAcked(client().admin().indices().prepareClose(indexName).setWaitForActiveShards(ActiveShardCount.NONE))).     assertIndexIsClosed(indexName). }
false;public;0;34;;public void testConcurrentClose() throws InterruptedException {     final String indexName = randomAlphaOfLength(10).toLowerCase(Locale.ROOT).     createIndex(indexName).     final int nbDocs = randomIntBetween(10, 50).     indexRandom(randomBoolean(), false, randomBoolean(), IntStream.range(0, nbDocs).mapToObj(i -> client().prepareIndex(indexName, "_doc", String.valueOf(i)).setSource("num", i)).collect(toList())).     ensureYellowAndNoInitializingShards(indexName).     final CountDownLatch startClosing = new CountDownLatch(1).     final Thread[] threads = new Thread[randomIntBetween(2, 5)].     for (int i = 0. i < threads.length. i++) {         threads[i] = new Thread(() -> {             try {                 startClosing.await().             } catch (InterruptedException e) {                 throw new AssertionError(e).             }             try {                 client().admin().indices().prepareClose(indexName).get().             } catch (final Exception e) {                 assertException(e, indexName).             }         }).         threads[i].start().     }     startClosing.countDown().     for (Thread thread : threads) {         thread.join().     }     assertIndexIsClosed(indexName). }
false;public;0;25;;public void testCloseWhileIndexingDocuments() throws Exception {     final String indexName = randomAlphaOfLength(10).toLowerCase(Locale.ROOT).     createIndex(indexName).     int nbDocs = 0.     try (BackgroundIndexer indexer = new BackgroundIndexer(indexName, "_doc", client(), MAX_DOCS)) {         indexer.setAssertNoFailuresOnStop(false).         waitForDocs(randomIntBetween(10, 50), indexer).         assertBusy(() -> assertAcked(client().admin().indices().prepareClose(indexName))).         indexer.stop().         nbDocs += indexer.totalIndexedDocs().         final Throwable[] failures = indexer.getFailures().         if (failures != null) {             for (Throwable failure : failures) {                 assertException(failure, indexName).             }         }     }     assertIndexIsClosed(indexName).     assertAcked(client().admin().indices().prepareOpen(indexName)).     assertHitCount(client().prepareSearch(indexName).setSize(0).setTrackTotalHitsUpTo(TRACK_TOTAL_HITS_ACCURATE).get(), nbDocs). }
false;public;0;53;;public void testCloseWhileDeletingIndices() throws Exception {     final String[] indices = new String[randomIntBetween(3, 10)].     for (int i = 0. i < indices.length. i++) {         final String indexName = randomAlphaOfLength(10).toLowerCase(Locale.ROOT).         createIndex(indexName).         if (randomBoolean()) {             indexRandom(randomBoolean(), false, randomBoolean(), IntStream.range(0, 10).mapToObj(n -> client().prepareIndex(indexName, "_doc", String.valueOf(n)).setSource("num", n)).collect(toList())).         }         indices[i] = indexName.     }     assertThat(client().admin().cluster().prepareState().get().getState().metaData().indices().size(), equalTo(indices.length)).     final List<Thread> threads = new ArrayList<>().     final CountDownLatch latch = new CountDownLatch(1).     for (final String indexToDelete : indices) {         threads.add(new Thread(() -> {             try {                 latch.await().             } catch (InterruptedException e) {                 throw new AssertionError(e).             }             try {                 assertAcked(client().admin().indices().prepareDelete(indexToDelete)).             } catch (final Exception e) {                 assertException(e, indexToDelete).             }         })).     }     for (final String indexToClose : indices) {         threads.add(new Thread(() -> {             try {                 latch.await().             } catch (InterruptedException e) {                 throw new AssertionError(e).             }             try {                 client().admin().indices().prepareClose(indexToClose).get().             } catch (final Exception e) {                 assertException(e, indexToClose).             }         })).     }     for (Thread thread : threads) {         thread.start().     }     latch.countDown().     for (Thread thread : threads) {         thread.join().     } }
false;public;0;59;;public void testConcurrentClosesAndOpens() throws Exception {     final String indexName = randomAlphaOfLength(10).toLowerCase(Locale.ROOT).     createIndex(indexName).     final BackgroundIndexer indexer = new BackgroundIndexer(indexName, "_doc", client(), MAX_DOCS).     waitForDocs(1, indexer).     final CountDownLatch latch = new CountDownLatch(1).     final Runnable waitForLatch = () -> {         try {             latch.await().         } catch (final InterruptedException e) {             throw new AssertionError(e).         }     }.     final List<Thread> threads = new ArrayList<>().     for (int i = 0. i < randomIntBetween(1, 3). i++) {         threads.add(new Thread(() -> {             try {                 waitForLatch.run().                 client().admin().indices().prepareClose(indexName).get().             } catch (final Exception e) {                 throw new AssertionError(e).             }         })).     }     for (int i = 0. i < randomIntBetween(1, 3). i++) {         threads.add(new Thread(() -> {             try {                 waitForLatch.run().                 assertAcked(client().admin().indices().prepareOpen(indexName).get()).             } catch (final Exception e) {                 throw new AssertionError(e).             }         })).     }     for (Thread thread : threads) {         thread.start().     }     latch.countDown().     for (Thread thread : threads) {         thread.join().     }     indexer.setAssertNoFailuresOnStop(false).     indexer.stop().     final ClusterState clusterState = client().admin().cluster().prepareState().get().getState().     if (clusterState.metaData().indices().get(indexName).getState() == IndexMetaData.State.CLOSE) {         assertIndexIsClosed(indexName).         assertAcked(client().admin().indices().prepareOpen(indexName)).     }     refresh(indexName).     assertIndexIsOpened(indexName).     assertHitCount(client().prepareSearch(indexName).setSize(0).setTrackTotalHitsUpTo(TRACK_TOTAL_HITS_ACCURATE).get(), indexer.totalIndexedDocs()). }
false;public;0;18;;public void testCloseIndexWaitForActiveShards() throws Exception {     final String indexName = randomAlphaOfLength(10).toLowerCase(Locale.ROOT).     createIndex(indexName, Settings.builder().put(IndexMetaData.SETTING_NUMBER_OF_SHARDS, 2).put(IndexMetaData.SETTING_NUMBER_OF_REPLICAS, // no replicas to avoid recoveries that could fail the index closing     0).build()).     final int nbDocs = randomIntBetween(0, 50).     indexRandom(randomBoolean(), false, randomBoolean(), IntStream.range(0, nbDocs).mapToObj(i -> client().prepareIndex(indexName, "_doc", String.valueOf(i)).setSource("num", i)).collect(toList())).     ensureGreen(indexName).     final CloseIndexResponse closeIndexResponse = client().admin().indices().prepareClose(indexName).get().     assertThat(client().admin().cluster().prepareHealth(indexName).get().getStatus(), is(ClusterHealthStatus.GREEN)).     assertTrue(closeIndexResponse.isAcknowledged()).     assertTrue(closeIndexResponse.isShardsAcknowledged()).     assertIndexIsClosed(indexName). }
false;static;1;15;;static void assertIndexIsClosed(final String... indices) {     final ClusterState clusterState = client().admin().cluster().prepareState().get().getState().     for (String index : indices) {         final IndexMetaData indexMetaData = clusterState.metaData().indices().get(index).         assertThat(indexMetaData.getState(), is(IndexMetaData.State.CLOSE)).         final Settings indexSettings = indexMetaData.getSettings().         assertThat(indexSettings.hasValue(MetaDataIndexStateService.VERIFIED_BEFORE_CLOSE_SETTING.getKey()), is(true)).         assertThat(indexSettings.getAsBoolean(MetaDataIndexStateService.VERIFIED_BEFORE_CLOSE_SETTING.getKey(), false), is(true)).         assertThat(clusterState.routingTable().index(index), notNullValue()).         assertThat(clusterState.blocks().hasIndexBlock(index, MetaDataIndexStateService.INDEX_CLOSED_BLOCK), is(true)).         assertThat("Index " + index + " must have only 1 block with [id=" + MetaDataIndexStateService.INDEX_CLOSED_BLOCK_ID + "]", clusterState.blocks().indices().getOrDefault(index, emptySet()).stream().filter(clusterBlock -> clusterBlock.id() == MetaDataIndexStateService.INDEX_CLOSED_BLOCK_ID).count(), equalTo(1L)).     } }
false;static;1;10;;static void assertIndexIsOpened(final String... indices) {     final ClusterState clusterState = client().admin().cluster().prepareState().get().getState().     for (String index : indices) {         final IndexMetaData indexMetaData = clusterState.metaData().indices().get(index).         assertThat(indexMetaData.getState(), is(IndexMetaData.State.OPEN)).         assertThat(indexMetaData.getSettings().hasValue(MetaDataIndexStateService.VERIFIED_BEFORE_CLOSE_SETTING.getKey()), is(false)).         assertThat(clusterState.routingTable().index(index), notNullValue()).         assertThat(clusterState.blocks().hasIndexBlock(index, MetaDataIndexStateService.INDEX_CLOSED_BLOCK), is(false)).     } }
false;static;2;18;;static void assertException(final Throwable throwable, final String indexName) {     final Throwable t = ExceptionsHelper.unwrapCause(throwable).     if (t instanceof ClusterBlockException) {         ClusterBlockException clusterBlockException = (ClusterBlockException) t.         assertThat(clusterBlockException.blocks(), hasSize(1)).         assertTrue(clusterBlockException.blocks().stream().allMatch(b -> b.id() == MetaDataIndexStateService.INDEX_CLOSED_BLOCK_ID)).     } else if (t instanceof IndexClosedException) {         IndexClosedException indexClosedException = (IndexClosedException) t.         assertThat(indexClosedException.getIndex(), notNullValue()).         assertThat(indexClosedException.getIndex().getName(), equalTo(indexName)).     } else if (t instanceof IndexNotFoundException) {         IndexNotFoundException indexNotFoundException = (IndexNotFoundException) t.         assertThat(indexNotFoundException.getIndex(), notNullValue()).         assertThat(indexNotFoundException.getIndex().getName(), equalTo(indexName)).     } else {         fail("Unexpected exception: " + t).     } }
