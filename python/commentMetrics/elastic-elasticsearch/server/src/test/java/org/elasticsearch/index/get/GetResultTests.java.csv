commented;modifiers;parameterAmount;loc;comment;code
false;public;0;20;;public void testToAndFromXContent() throws Exception {     XContentType xContentType = randomFrom(XContentType.values()).     Tuple<GetResult, GetResult> tuple = randomGetResult(xContentType).     GetResult getResult = tuple.v1().     GetResult expectedGetResult = tuple.v2().     boolean humanReadable = randomBoolean().     BytesReference originalBytes = toShuffledXContent(getResult, xContentType, ToXContent.EMPTY_PARAMS, humanReadable, "_source").     // test that we can parse what we print out     GetResult parsedGetResult.     try (XContentParser parser = createParser(xContentType.xContent(), originalBytes)) {         parsedGetResult = GetResult.fromXContent(parser).         assertNull(parser.nextToken()).     }     assertEquals(expectedGetResult, parsedGetResult).     // print the parsed object out and test that the output is the same as the original output     BytesReference finalBytes = toXContent(parsedGetResult, xContentType, humanReadable).     assertToXContentEquivalent(originalBytes, finalBytes, xContentType).     // check that the source stays unchanged, no shuffling of keys nor anything like that     assertEquals(expectedGetResult.sourceAsString(), parsedGetResult.sourceAsString()). }
false;public;0;16;;public void testToXContent() throws IOException {     {         GetResult getResult = new GetResult("index", "type", "id", 0, 1, 1, true, new BytesArray("{ \"field1\" : " + "\"value1\", \"field2\":\"value2\"}"), singletonMap("field1", new DocumentField("field1", singletonList("value1")))).         String output = Strings.toString(getResult).         assertEquals("{\"_index\":\"index\",\"_type\":\"type\",\"_id\":\"id\",\"_version\":1,\"_seq_no\":0,\"_primary_term\":1," + "\"found\":true,\"_source\":{ \"field1\" : \"value1\", \"field2\":\"value2\"},\"fields\":{\"field1\":[\"value1\"]}}", output).     }     {         GetResult getResult = new GetResult("index", "type", "id", UNASSIGNED_SEQ_NO, 0, 1, false, null, null).         String output = Strings.toString(getResult).         assertEquals("{\"_index\":\"index\",\"_type\":\"type\",\"_id\":\"id\",\"found\":false}", output).     } }
false;public;0;26;;public void testToAndFromXContentEmbedded() throws Exception {     XContentType xContentType = randomFrom(XContentType.values()).     Tuple<GetResult, GetResult> tuple = randomGetResult(xContentType).     GetResult getResult = tuple.v1().     // We don't expect to retrieve the index/type/id of the GetResult because they are not rendered     // by the toXContentEmbedded method.     GetResult expectedGetResult = new GetResult(null, null, null, tuple.v2().getSeqNo(), tuple.v2().getPrimaryTerm(), -1, tuple.v2().isExists(), tuple.v2().sourceRef(), tuple.v2().getFields()).     boolean humanReadable = randomBoolean().     BytesReference originalBytes = toXContentEmbedded(getResult, xContentType, humanReadable).     // Test that we can parse the result of toXContentEmbedded()     GetResult parsedEmbeddedGetResult.     try (XContentParser parser = createParser(xContentType.xContent(), originalBytes)) {         ensureExpectedToken(XContentParser.Token.START_OBJECT, parser.nextToken(), parser::getTokenLocation).         parsedEmbeddedGetResult = GetResult.fromXContentEmbedded(parser).         assertNull(parser.nextToken()).     }     assertEquals(expectedGetResult, parsedEmbeddedGetResult).     // print the parsed object out and test that the output is the same as the original output     BytesReference finalBytes = toXContentEmbedded(parsedEmbeddedGetResult, xContentType, humanReadable).     assertToXContentEquivalent(originalBytes, finalBytes, xContentType).     // check that the source stays unchanged, no shuffling of keys nor anything like that     assertEquals(expectedGetResult.sourceAsString(), parsedEmbeddedGetResult.sourceAsString()). }
false;public;0;12;;public void testToXContentEmbedded() throws IOException {     Map<String, DocumentField> fields = new HashMap<>().     fields.put("foo", new DocumentField("foo", singletonList("bar"))).     fields.put("baz", new DocumentField("baz", Arrays.asList("baz_0", "baz_1"))).     GetResult getResult = new GetResult("index", "type", "id", 0, 1, 2, true, new BytesArray("{\"foo\":\"bar\",\"baz\":[\"baz_0\",\"baz_1\"]}"), fields).     BytesReference originalBytes = toXContentEmbedded(getResult, XContentType.JSON, false).     assertEquals("{\"_seq_no\":0,\"_primary_term\":1,\"found\":true,\"_source\":{\"foo\":\"bar\",\"baz\":[\"baz_0\",\"baz_1\"]}," + "\"fields\":{\"foo\":[\"bar\"],\"baz\":[\"baz_0\",\"baz_1\"]}}", originalBytes.utf8ToString()). }
false;public;0;6;;public void testToXContentEmbeddedNotFound() throws IOException {     GetResult getResult = new GetResult("index", "type", "id", UNASSIGNED_SEQ_NO, 0, 1, false, null, null).     BytesReference originalBytes = toXContentEmbedded(getResult, XContentType.JSON, false).     assertEquals("{\"found\":false}", originalBytes.utf8ToString()). }
false;public;0;10;;public void testGetSourceAsBytes() {     XContentType xContentType = randomFrom(XContentType.values()).     Tuple<GetResult, GetResult> tuple = randomGetResult(xContentType).     GetResult getResult = tuple.v1().     if (getResult.isExists() && getResult.isSourceEmpty() == false) {         assertNotNull(getResult.sourceRef()).     } else {         assertNull(getResult.sourceRef()).     } }
false;public;0;3;;public void testEqualsAndHashcode() {     checkEqualsAndHashCode(randomGetResult(XContentType.JSON).v1(), GetResultTests::copyGetResult, GetResultTests::mutateGetResult). }
false;public,static;1;5;;public static GetResult copyGetResult(GetResult getResult) {     return new GetResult(getResult.getIndex(), getResult.getType(), getResult.getId(), getResult.getSeqNo(), getResult.getPrimaryTerm(), getResult.getVersion(), getResult.isExists(), getResult.internalSourceRef(), getResult.getFields()). }
false;public,static;1;26;;public static GetResult mutateGetResult(GetResult getResult) {     List<Supplier<GetResult>> mutations = new ArrayList<>().     mutations.add(() -> new GetResult(randomUnicodeOfLength(15), getResult.getType(), getResult.getId(), getResult.getSeqNo(), getResult.getPrimaryTerm(), getResult.getVersion(), getResult.isExists(), getResult.internalSourceRef(), getResult.getFields())).     mutations.add(() -> new GetResult(getResult.getIndex(), randomUnicodeOfLength(15), getResult.getId(), getResult.getSeqNo(), getResult.getPrimaryTerm(), getResult.getVersion(), getResult.isExists(), getResult.internalSourceRef(), getResult.getFields())).     mutations.add(() -> new GetResult(getResult.getIndex(), getResult.getType(), randomUnicodeOfLength(15), getResult.getSeqNo(), getResult.getPrimaryTerm(), getResult.getVersion(), getResult.isExists(), getResult.internalSourceRef(), getResult.getFields())).     mutations.add(() -> new GetResult(getResult.getIndex(), getResult.getType(), getResult.getId(), getResult.getSeqNo(), getResult.getPrimaryTerm(), randomNonNegativeLong(), getResult.isExists(), getResult.internalSourceRef(), getResult.getFields())).     mutations.add(() -> new GetResult(getResult.getIndex(), getResult.getType(), getResult.getId(), getResult.isExists() ? UNASSIGNED_SEQ_NO : getResult.getSeqNo(), getResult.isExists() ? 0 : getResult.getPrimaryTerm(), getResult.getVersion(), getResult.isExists() == false, getResult.internalSourceRef(), getResult.getFields())).     mutations.add(() -> new GetResult(getResult.getIndex(), getResult.getType(), getResult.getId(), getResult.getSeqNo(), getResult.getPrimaryTerm(), getResult.getVersion(), getResult.isExists(), RandomObjects.randomSource(random()), getResult.getFields())).     mutations.add(() -> new GetResult(getResult.getIndex(), getResult.getType(), getResult.getId(), getResult.getSeqNo(), getResult.getPrimaryTerm(), getResult.getVersion(), getResult.isExists(), getResult.internalSourceRef(), randomDocumentFields(XContentType.JSON).v1())).     return randomFrom(mutations).get(). }
false;public,static;1;34;;public static Tuple<GetResult, GetResult> randomGetResult(XContentType xContentType) {     final String index = randomAlphaOfLengthBetween(3, 10).     final String type = randomAlphaOfLengthBetween(3, 10).     final String id = randomAlphaOfLengthBetween(3, 10).     final long version.     final long seqNo.     final long primaryTerm.     final boolean exists.     BytesReference source = null.     Map<String, DocumentField> fields = null.     Map<String, DocumentField> expectedFields = null.     if (frequently()) {         version = randomNonNegativeLong().         seqNo = randomNonNegativeLong().         primaryTerm = randomLongBetween(1, 100).         exists = true.         if (frequently()) {             source = RandomObjects.randomSource(random()).         }         if (randomBoolean()) {             Tuple<Map<String, DocumentField>, Map<String, DocumentField>> tuple = randomDocumentFields(xContentType).             fields = tuple.v1().             expectedFields = tuple.v2().         }     } else {         seqNo = UNASSIGNED_SEQ_NO.         primaryTerm = UNASSIGNED_PRIMARY_TERM.         version = -1.         exists = false.     }     GetResult getResult = new GetResult(index, type, id, seqNo, primaryTerm, version, exists, source, fields).     GetResult expectedGetResult = new GetResult(index, type, id, seqNo, primaryTerm, version, exists, source, expectedFields).     return Tuple.tuple(getResult, expectedGetResult). }
false;public,static;1;14;;public static Tuple<Map<String, DocumentField>, Map<String, DocumentField>> randomDocumentFields(XContentType xContentType) {     int numFields = randomIntBetween(2, 10).     Map<String, DocumentField> fields = new HashMap<>(numFields).     Map<String, DocumentField> expectedFields = new HashMap<>(numFields).     while (fields.size() < numFields) {         Tuple<DocumentField, DocumentField> tuple = randomDocumentField(xContentType).         DocumentField getField = tuple.v1().         DocumentField expectedGetField = tuple.v2().         if (fields.putIfAbsent(getField.getName(), getField) == null) {             assertNull(expectedFields.putIfAbsent(expectedGetField.getName(), expectedGetField)).         }     }     return Tuple.tuple(fields, expectedFields). }
false;private,static;3;4;;private static BytesReference toXContentEmbedded(GetResult getResult, XContentType xContentType, boolean humanReadable) throws IOException {     return XContentHelper.toXContent(getResult::toXContentEmbedded, xContentType, humanReadable). }
