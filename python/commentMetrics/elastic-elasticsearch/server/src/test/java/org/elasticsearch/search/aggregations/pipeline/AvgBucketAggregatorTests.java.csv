commented;modifiers;parameterAmount;loc;comment;code
true;public;0;59;/**  * Test for issue #30608.  Under the following circumstances:  *  * A. Multi-bucket agg in the first entry of our internal list  * B. Regular agg as the immediate child of the multi-bucket in A  * C. Regular agg with the same name as B at the top level, listed as the second entry in our internal list  * D. Finally, a pipeline agg with the path down to B  *  * BucketMetrics reduction would throw a class cast exception due to bad subpathing.  This test ensures  * it is fixed.  *  * Note: we have this test inside of the `avg_bucket` package so that we can get access to the package-private  * `doReduce()` needed for testing this  */ ;/**  * Test for issue #30608.  Under the following circumstances:  *  * A. Multi-bucket agg in the first entry of our internal list  * B. Regular agg as the immediate child of the multi-bucket in A  * C. Regular agg with the same name as B at the top level, listed as the second entry in our internal list  * D. Finally, a pipeline agg with the path down to B  *  * BucketMetrics reduction would throw a class cast exception due to bad subpathing.  This test ensures  * it is fixed.  *  * Note: we have this test inside of the `avg_bucket` package so that we can get access to the package-private  * `doReduce()` needed for testing this  */ public void testSameAggNames() throws IOException {     Query query = new MatchAllDocsQuery().     AvgAggregationBuilder avgBuilder = new AvgAggregationBuilder("foo").field(VALUE_FIELD).     DateHistogramAggregationBuilder histo = new DateHistogramAggregationBuilder("histo").dateHistogramInterval(DateHistogramInterval.YEAR).field(DATE_FIELD).subAggregation(new AvgAggregationBuilder("foo").field(VALUE_FIELD)).     AvgBucketPipelineAggregationBuilder avgBucketBuilder = new AvgBucketPipelineAggregationBuilder("the_avg_bucket", "histo>foo").     try (Directory directory = newDirectory()) {         try (RandomIndexWriter indexWriter = new RandomIndexWriter(random(), directory)) {             Document document = new Document().             for (String date : dataset) {                 if (frequently()) {                     indexWriter.commit().                 }                 document.add(new SortedNumericDocValuesField(DATE_FIELD, asLong(date))).                 document.add(new SortedNumericDocValuesField(VALUE_FIELD, randomInt())).                 indexWriter.addDocument(document).                 document.clear().             }         }         InternalAvg avgResult.         InternalDateHistogram histogramResult.         try (IndexReader indexReader = DirectoryReader.open(directory)) {             IndexSearcher indexSearcher = newSearcher(indexReader, true, true).             DateFieldMapper.Builder builder = new DateFieldMapper.Builder("histo").             DateFieldMapper.DateFieldType fieldType = builder.fieldType().             fieldType.setHasDocValues(true).             fieldType.setName(DATE_FIELD).             MappedFieldType valueFieldType = new NumberFieldMapper.NumberFieldType(NumberFieldMapper.NumberType.LONG).             valueFieldType.setName(VALUE_FIELD).             valueFieldType.setHasDocValues(true).             avgResult = searchAndReduce(indexSearcher, query, avgBuilder, 10000, null, new MappedFieldType[] { fieldType, valueFieldType }).             histogramResult = searchAndReduce(indexSearcher, query, histo, 10000, null, new MappedFieldType[] { fieldType, valueFieldType }).         }         // Finally, reduce the pipeline agg         PipelineAggregator avgBucketAgg = avgBucketBuilder.createInternal(Collections.emptyMap()).         List<Aggregation> reducedAggs = new ArrayList<>(2).         // Histo has to go first to exercise the bug         reducedAggs.add(histogramResult).         reducedAggs.add(avgResult).         Aggregations aggregations = new Aggregations(reducedAggs).         InternalAggregation pipelineResult = ((AvgBucketPipelineAggregator) avgBucketAgg).doReduce(aggregations, null).         assertNotNull(pipelineResult).     } }
false;private,static;1;3;;private static long asLong(String dateTime) {     return DateFormatters.from(DateFieldMapper.DEFAULT_DATE_TIME_FORMATTER.parse(dateTime)).toInstant().toEpochMilli(). }
