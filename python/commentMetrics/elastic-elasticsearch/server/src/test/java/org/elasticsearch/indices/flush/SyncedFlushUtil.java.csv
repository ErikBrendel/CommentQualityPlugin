commented;modifiers;parameterAmount;loc;comment;code
true;public,static;3;26;/**  * Blocking version of {@link SyncedFlushService#attemptSyncedFlush(ShardId, ActionListener)}  */ ;/**  * Blocking version of {@link SyncedFlushService#attemptSyncedFlush(ShardId, ActionListener)}  */ public static ShardsSyncedFlushResult attemptSyncedFlush(Logger logger, InternalTestCluster cluster, ShardId shardId) throws Exception {     /*          * When the last indexing operation is completed, we will fire a global checkpoint sync.          * Since a global checkpoint sync request is a replication request, it will acquire an index          * shard permit on the primary when executing. If this happens at the same time while we are          * issuing the synced-flush, the synced-flush request will fail as it thinks there are          * in-flight operations. We can avoid such situation by continuing issuing another synced-flush          * if the synced-flush failed due to the ongoing operations on the primary.          */     SyncedFlushService service = cluster.getInstance(SyncedFlushService.class).     AtomicReference<LatchedListener<ShardsSyncedFlushResult>> listenerHolder = new AtomicReference<>().     assertBusy(() -> {         LatchedListener<ShardsSyncedFlushResult> listener = new LatchedListener<>().         listenerHolder.set(listener).         service.attemptSyncedFlush(shardId, listener).         listener.latch.await().         if (listener.result != null && listener.result.failureReason() != null && listener.result.failureReason().contains("ongoing operations on primary")) {             // cause the assert busy to retry             throw new AssertionError(listener.result.failureReason()).         }     }).     if (listenerHolder.get().error != null) {         throw ExceptionsHelper.convertToElastic(listenerHolder.get().error).     }     return listenerHolder.get().result. }
false;public;1;5;;@Override public void onResponse(T result) {     this.result = result.     latch.countDown(). }
false;public;1;5;;@Override public void onFailure(Exception e) {     error = e.     latch.countDown(). }
true;public,static;4;16;/**  * Blocking version of {@link SyncedFlushService#sendPreSyncRequests(List, ClusterState, ShardId, ActionListener)}  */ ;/**  * Blocking version of {@link SyncedFlushService#sendPreSyncRequests(List, ClusterState, ShardId, ActionListener)}  */ public static Map<String, SyncedFlushService.PreSyncedFlushResponse> sendPreSyncRequests(SyncedFlushService service, List<ShardRouting> activeShards, ClusterState state, ShardId shardId) {     LatchedListener<Map<String, SyncedFlushService.PreSyncedFlushResponse>> listener = new LatchedListener<>().     service.sendPreSyncRequests(activeShards, state, shardId, listener).     try {         listener.latch.await().     } catch (InterruptedException e) {         Thread.currentThread().interrupt().     }     if (listener.error != null) {         throw ExceptionsHelper.convertToElastic(listener.error).     }     return listener.result. }
