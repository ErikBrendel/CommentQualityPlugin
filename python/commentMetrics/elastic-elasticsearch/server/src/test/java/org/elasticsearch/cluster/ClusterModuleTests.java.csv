commented;modifiers;parameterAmount;loc;comment;code
false;public;1;4;;@Override public void allocate(RoutingAllocation allocation) { // noop }
false;public;2;4;;@Override public ShardAllocationDecision decideShardAllocation(ShardRouting shard, RoutingAllocation allocation) {     throw new UnsupportedOperationException("explain API not supported on FakeShardsAllocator"). }
false;public;0;8;;public void testRegisterClusterDynamicSettingDuplicate() {     try {         new SettingsModule(Settings.EMPTY, EnableAllocationDecider.CLUSTER_ROUTING_ALLOCATION_ENABLE_SETTING).     } catch (IllegalArgumentException e) {         assertEquals(e.getMessage(), "Cannot register setting [" + EnableAllocationDecider.CLUSTER_ROUTING_ALLOCATION_ENABLE_SETTING.getKey() + "] twice").     } }
false;public;0;5;;public void testRegisterClusterDynamicSetting() {     SettingsModule module = new SettingsModule(Settings.EMPTY, Setting.boolSetting("foo.bar", false, Property.Dynamic, Property.NodeScope)).     assertInstanceBinding(module, ClusterSettings.class, service -> service.isDynamicSetting("foo.bar")). }
false;public;0;8;;public void testRegisterIndexDynamicSettingDuplicate() {     try {         new SettingsModule(Settings.EMPTY, EnableAllocationDecider.INDEX_ROUTING_ALLOCATION_ENABLE_SETTING).     } catch (IllegalArgumentException e) {         assertEquals(e.getMessage(), "Cannot register setting [" + EnableAllocationDecider.INDEX_ROUTING_ALLOCATION_ENABLE_SETTING.getKey() + "] twice").     } }
false;public;0;5;;public void testRegisterIndexDynamicSetting() {     SettingsModule module = new SettingsModule(Settings.EMPTY, Setting.boolSetting("index.foo.bar", false, Property.Dynamic, Property.IndexScope)).     assertInstanceBinding(module, IndexScopedSettings.class, service -> service.isDynamicSetting("index.foo.bar")). }
false;public;2;4;;@Override public Collection<AllocationDecider> createAllocationDeciders(Settings settings, ClusterSettings clusterSettings) {     return Collections.singletonList(new EnableAllocationDecider(settings, clusterSettings)). }
false;public;0;12;;public void testRegisterAllocationDeciderDuplicate() {     IllegalArgumentException e = expectThrows(IllegalArgumentException.class, () -> new ClusterModule(Settings.EMPTY, clusterService, Collections.<ClusterPlugin>singletonList(new ClusterPlugin() {          @Override         public Collection<AllocationDecider> createAllocationDeciders(Settings settings, ClusterSettings clusterSettings) {             return Collections.singletonList(new EnableAllocationDecider(settings, clusterSettings)).         }     }), clusterInfoService)).     assertEquals(e.getMessage(), "Cannot specify allocation decider [" + EnableAllocationDecider.class.getName() + "] twice"). }
false;public;2;4;;@Override public Collection<AllocationDecider> createAllocationDeciders(Settings settings, ClusterSettings clusterSettings) {     return Collections.singletonList(new FakeAllocationDecider()). }
false;public;0;10;;public void testRegisterAllocationDecider() {     ClusterModule module = new ClusterModule(Settings.EMPTY, clusterService, Collections.singletonList(new ClusterPlugin() {          @Override         public Collection<AllocationDecider> createAllocationDeciders(Settings settings, ClusterSettings clusterSettings) {             return Collections.singletonList(new FakeAllocationDecider()).         }     }), clusterInfoService).     assertTrue(module.deciderList.stream().anyMatch(d -> d.getClass().equals(FakeAllocationDecider.class))). }
false;public;2;4;;@Override public Map<String, Supplier<ShardsAllocator>> getShardsAllocators(Settings settings, ClusterSettings clusterSettings) {     return Collections.singletonMap(name, supplier). }
false;private;3;10;;private ClusterModule newClusterModuleWithShardsAllocator(Settings settings, String name, Supplier<ShardsAllocator> supplier) {     return new ClusterModule(settings, clusterService, Collections.singletonList(new ClusterPlugin() {          @Override         public Map<String, Supplier<ShardsAllocator>> getShardsAllocators(Settings settings, ClusterSettings clusterSettings) {             return Collections.singletonMap(name, supplier).         }     }), clusterInfoService). }
false;public;0;5;;public void testRegisterShardsAllocator() {     Settings settings = Settings.builder().put(ClusterModule.SHARDS_ALLOCATOR_TYPE_SETTING.getKey(), "custom").build().     ClusterModule module = newClusterModuleWithShardsAllocator(settings, "custom", FakeShardsAllocator::new).     assertEquals(FakeShardsAllocator.class, module.shardsAllocator.getClass()). }
false;public;0;5;;public void testRegisterShardsAllocatorAlreadyRegistered() {     IllegalArgumentException e = expectThrows(IllegalArgumentException.class, () -> newClusterModuleWithShardsAllocator(Settings.EMPTY, ClusterModule.BALANCED_ALLOCATOR, FakeShardsAllocator::new)).     assertEquals("ShardsAllocator [" + ClusterModule.BALANCED_ALLOCATOR + "] already defined", e.getMessage()). }
false;public;0;6;;public void testUnknownShardsAllocator() {     Settings settings = Settings.builder().put(ClusterModule.SHARDS_ALLOCATOR_TYPE_SETTING.getKey(), "dne").build().     IllegalArgumentException e = expectThrows(IllegalArgumentException.class, () -> new ClusterModule(settings, clusterService, Collections.emptyList(), clusterInfoService)).     assertEquals("Unknown ShardsAllocator [dne]", e.getMessage()). }
false;public;0;4;;public void testShardsAllocatorFactoryNull() {     Settings settings = Settings.builder().put(ClusterModule.SHARDS_ALLOCATOR_TYPE_SETTING.getKey(), "bad").build().     expectThrows(NullPointerException.class, () -> newClusterModuleWithShardsAllocator(settings, "bad", () -> null)). }
true;public;0;27;// changed in the test too. ;// makes sure that the allocation deciders are setup in the correct order, such that the // slower allocation deciders come last and we can exit early if there is a NO decision without // running them. If the order of the deciders is changed for a valid reason, the order should be // changed in the test too. public void testAllocationDeciderOrder() {     List<Class<? extends AllocationDecider>> expectedDeciders = Arrays.asList(MaxRetryAllocationDecider.class, ResizeAllocationDecider.class, ReplicaAfterPrimaryActiveAllocationDecider.class, RebalanceOnlyWhenActiveAllocationDecider.class, ClusterRebalanceAllocationDecider.class, ConcurrentRebalanceAllocationDecider.class, EnableAllocationDecider.class, NodeVersionAllocationDecider.class, SnapshotInProgressAllocationDecider.class, RestoreInProgressAllocationDecider.class, FilterAllocationDecider.class, SameShardAllocationDecider.class, DiskThresholdDecider.class, ThrottlingAllocationDecider.class, ShardsLimitAllocationDecider.class, AwarenessAllocationDecider.class).     Collection<AllocationDecider> deciders = ClusterModule.createAllocationDeciders(Settings.EMPTY, new ClusterSettings(Settings.EMPTY, ClusterSettings.BUILT_IN_CLUSTER_SETTINGS), Collections.emptyList()).     Iterator<AllocationDecider> iter = deciders.iterator().     int idx = 0.     while (iter.hasNext()) {         AllocationDecider decider = iter.next().         assertSame(decider.getClass(), expectedDeciders.get(idx++)).     } }
false;public;0;24;;public void testPre63CustomsFiltering() {     final String whiteListedClusterCustom = randomFrom(ClusterModule.PRE_6_3_CLUSTER_CUSTOMS_WHITE_LIST).     final String whiteListedMetaDataCustom = randomFrom(ClusterModule.PRE_6_3_METADATA_CUSTOMS_WHITE_LIST).     final ClusterState clusterState = ClusterState.builder(ClusterName.DEFAULT).putCustom(whiteListedClusterCustom, new RestoreInProgress.Builder().build()).putCustom("other", new RestoreInProgress.Builder().build()).metaData(MetaData.builder().putCustom(whiteListedMetaDataCustom, new RepositoriesMetaData(Collections.emptyList())).putCustom("other", new RepositoriesMetaData(Collections.emptyList())).build()).build().     assertNotNull(clusterState.custom(whiteListedClusterCustom)).     assertNotNull(clusterState.custom("other")).     assertNotNull(clusterState.metaData().custom(whiteListedMetaDataCustom)).     assertNotNull(clusterState.metaData().custom("other")).     final ClusterState fixedClusterState = ClusterModule.filterCustomsForPre63Clients(clusterState).     assertNotNull(fixedClusterState.custom(whiteListedClusterCustom)).     assertNull(fixedClusterState.custom("other")).     assertNotNull(fixedClusterState.metaData().custom(whiteListedMetaDataCustom)).     assertNull(fixedClusterState.metaData().custom("other")). }
