commented;modifiers;parameterAmount;loc;comment;code
false;public;0;4;;@Override public Object initialState() {     return false. }
false;public;3;18;;@Override public Optional<Object> nextState(Object currentState, Object input, Object output) {     if (input != null) {         throw new AssertionError("invalid history: input must be null").     }     if (output instanceof Boolean == false) {         throw new AssertionError("invalid history: output must be boolean").     }     if (false == (boolean) currentState) {         if (false == (boolean) output) {             return Optional.empty().         }         return Optional.of(true).     } else if (false == (boolean) output) {         return Optional.of(currentState).     }     return Optional.empty(). }
false;public;0;7;;public void testLockConsistent() {     assertThat(lockSpec.initialState(), equalTo(false)).     assertThat(lockSpec.nextState(false, null, true), equalTo(Optional.of(true))).     assertThat(lockSpec.nextState(false, null, false), equalTo(Optional.empty())).     assertThat(lockSpec.nextState(true, null, false), equalTo(Optional.of(true))).     assertThat(lockSpec.nextState(true, null, true), equalTo(Optional.empty())). }
false;public;0;8;;public void testLockWithLinearizableHistory1() {     final History history = new History().     // 0: acquire lock     int call0 = history.invoke(null).     // 0: lock acquisition succeeded     history.respond(call0, true).     // 1: acquire lock     int call1 = history.invoke(null).     // 0: lock acquisition failed     history.respond(call1, false).     assertTrue(checker.isLinearizable(lockSpec, history)). }
false;public;0;8;;public void testLockWithLinearizableHistory2() {     final History history = new History().     // 0: acquire lock     int call0 = history.invoke(null).     // 1: acquire lock     int call1 = history.invoke(null).     // 0: lock acquisition failed     history.respond(call0, false).     // 0: lock acquisition succeeded     history.respond(call1, true).     assertTrue(checker.isLinearizable(lockSpec, history)). }
false;public;0;8;;public void testLockWithLinearizableHistory3() {     final History history = new History().     // 0: acquire lock     int call0 = history.invoke(null).     // 1: acquire lock     int call1 = history.invoke(null).     // 0: lock acquisition succeeded     history.respond(call0, true).     // 0: lock acquisition failed     history.respond(call1, false).     assertTrue(checker.isLinearizable(lockSpec, history)). }
false;public;0;8;;public void testLockWithNonLinearizableHistory() {     final History history = new History().     // 0: acquire lock     int call0 = history.invoke(null).     // 0: lock acquisition failed     history.respond(call0, false).     // 1: acquire lock     int call1 = history.invoke(null).     // 0: lock acquisition succeeded     history.respond(call1, true).     assertFalse(checker.isLinearizable(lockSpec, history)). }
false;public;0;4;;@Override public Object initialState() {     return 0. }
false;public;3;12;;@Override public Optional<Object> nextState(Object currentState, Object input, Object output) {     if ((input == null) == (output == null)) {         throw new AssertionError("invalid history: exactly one of input or output must be null").     }     if (input != null) {         return Optional.of(input).     } else if (output.equals(currentState)) {         return Optional.of(currentState).     }     return Optional.empty(). }
false;public;0;6;;public void testRegisterConsistent() {     assertThat(registerSpec.initialState(), equalTo(0)).     assertThat(registerSpec.nextState(7, 42, null), equalTo(Optional.of(42))).     assertThat(registerSpec.nextState(7, null, 7), equalTo(Optional.of(7))).     assertThat(registerSpec.nextState(7, null, 42), equalTo(Optional.empty())). }
false;public;0;14;;public void testRegisterWithLinearizableHistory() {     final History history = new History().     // 0: invoke write 42     int call0 = history.invoke(42).     // 1: invoke read     int call1 = history.invoke(null).     // 2: invoke read     int call2 = history.invoke(null).     // 2: read returns 0     history.respond(call2, 0).     // 1: read returns 42     history.respond(call1, 42).     expectThrows(IllegalArgumentException.class, () -> checker.isLinearizable(registerSpec, history)).     assertTrue(checker.isLinearizable(registerSpec, history, i -> null)).     // 0: write returns     history.respond(call0, null).     assertTrue(checker.isLinearizable(registerSpec, history)). }
false;public;0;14;;public void testRegisterWithNonLinearizableHistory() {     final History history = new History().     // 0: invoke write 42     int call0 = history.invoke(42).     // 1: invoke read     int call1 = history.invoke(null).     // 1: read returns 42     history.respond(call1, 42).     // 2: invoke read     int call2 = history.invoke(null).     // 2: read returns 0, not allowed     history.respond(call2, 0).     expectThrows(IllegalArgumentException.class, () -> checker.isLinearizable(registerSpec, history)).     assertFalse(checker.isLinearizable(registerSpec, history, i -> null)).     // 0: write returns     history.respond(call0, null).     assertFalse(checker.isLinearizable(registerSpec, history)). }
false;public;0;16;;public void testRegisterObservedSequenceOfUpdatesWitLinearizableHistory() {     final History history = new History().     // 0: invoke write 42     int call0 = history.invoke(42).     // 1: invoke write 43     int call1 = history.invoke(43).     // 2: invoke read     int call2 = history.invoke(null).     // 1: read returns 42     history.respond(call2, 42).     // 3: invoke read     int call3 = history.invoke(null).     // 3: read returns 43     history.respond(call3, 43).     // 4: invoke read     int call4 = history.invoke(null).     // 4: read returns 43     history.respond(call4, 43).     // 0: write returns     history.respond(call0, null).     // 1: write returns     history.respond(call1, null).     assertTrue(checker.isLinearizable(registerSpec, history)). }
false;public;0;16;;public void testRegisterObservedSequenceOfUpdatesWithNonLinearizableHistory() {     final History history = new History().     // 0: invoke write 42     int call0 = history.invoke(42).     // 1: invoke write 43     int call1 = history.invoke(43).     // 2: invoke read     int call2 = history.invoke(null).     // 1: read returns 42     history.respond(call2, 42).     // 3: invoke read     int call3 = history.invoke(null).     // 3: read returns 43     history.respond(call3, 43).     // 4: invoke read     int call4 = history.invoke(null).     // 4: read returns 42, not allowed     history.respond(call4, 42).     // 0: write returns     history.respond(call0, null).     // 1: write returns     history.respond(call1, null).     assertFalse(checker.isLinearizable(registerSpec, history)). }
false;public;1;4;;@Override public Object getKey(Object value) {     return ((Tuple) value).v1(). }
false;public;1;4;;@Override public Object getValue(Object value) {     return ((Tuple) value).v2(). }
false;public;0;4;;@Override public Object initialState() {     return registerSpec.initialState(). }
false;public;3;4;;@Override public Optional<Object> nextState(Object currentState, Object input, Object output) {     return registerSpec.nextState(currentState, input, output). }
false;public;0;20;;public void testMultiRegisterWithLinearizableHistory() {     final History history = new History().     // 0: invoke write 42 on key x     int callX0 = history.invoke(new Tuple<>("x", 42)).     // 1: invoke read on key x     int callX1 = history.invoke(new Tuple<>("x", null)).     // 0: invoke write 42 on key y     int callY0 = history.invoke(new Tuple<>("y", 42)).     // 1: invoke read on key y     int callY1 = history.invoke(new Tuple<>("y", null)).     // 2: invoke read on key x     int callX2 = history.invoke(new Tuple<>("x", null)).     // 2: invoke read on key y     int callY2 = history.invoke(new Tuple<>("y", null)).     // 2: read returns 0 on key x     history.respond(callX2, 0).     // 2: read returns 0 on key y     history.respond(callY2, 0).     // 1: read returns 42 on key y     history.respond(callY1, 42).     // 1: read returns 42 on key x     history.respond(callX1, 42).     expectThrows(IllegalArgumentException.class, () -> checker.isLinearizable(multiRegisterSpec, history)).     assertTrue(checker.isLinearizable(multiRegisterSpec, history, i -> null)).     // 0: write returns on key x     history.respond(callX0, null).     // 0: write returns on key y     history.respond(callY0, null).     assertTrue(checker.isLinearizable(multiRegisterSpec, history)). }
false;public;0;20;;public void testMultiRegisterWithNonLinearizableHistory() {     final History history = new History().     // 0: invoke write 42 on key x     int callX0 = history.invoke(new Tuple<>("x", 42)).     // 1: invoke read on key x     int callX1 = history.invoke(new Tuple<>("x", null)).     // 0: invoke write 42 on key y     int callY0 = history.invoke(new Tuple<>("y", 42)).     // 1: invoke read on key y     int callY1 = history.invoke(new Tuple<>("y", null)).     // 2: invoke read on key x     int callX2 = history.invoke(new Tuple<>("x", null)).     // 1: read returns 42 on key y     history.respond(callY1, 42).     // 2: invoke read on key y     int callY2 = history.invoke(new Tuple<>("y", null)).     // 2: read returns 0 on key x     history.respond(callX2, 0).     // 2: read returns 0 on key y, not allowed     history.respond(callY2, 0).     // 1: read returns 42 on key x     history.respond(callX1, 42).     expectThrows(IllegalArgumentException.class, () -> checker.isLinearizable(multiRegisterSpec, history)).     assertFalse(checker.isLinearizable(multiRegisterSpec, history, i -> null)).     // 0: write returns on key x     history.respond(callX0, null).     // 0: write returns on key y     history.respond(callY0, null).     assertFalse(checker.isLinearizable(multiRegisterSpec, history)). }
