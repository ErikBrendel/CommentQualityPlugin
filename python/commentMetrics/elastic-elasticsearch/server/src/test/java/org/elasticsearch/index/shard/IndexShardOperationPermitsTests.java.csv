# id;timestamp;commentText;codeText;commentWords;codeWords
IndexShardOperationPermitsTests -> private Runnable controlledAcquire(             final CyclicBarrier barrier,             final CountDownLatch operationExecutingLatch,             final CountDownLatch operationLatch,             final CountDownLatch operationCompleteLatch);1524684173;Returns an operation that acquires a permit and synchronizes in the following manner:_<ul>_<li>waits on the {@code barrier} before acquiring a permit</li>_<li>counts down the {@code operationExecutingLatch} when it acquires the permit</li>_<li>waits on the {@code operationLatch} before releasing the permit</li>_<li>counts down the {@code operationCompleteLatch} after releasing the permit</li>_</ul>__@param barrier                 the barrier to wait on_@param operationExecutingLatch the latch to countdown after acquiring the permit_@param operationLatch          the latch to wait on before releasing the permit_@param operationCompleteLatch  the latch to countdown after releasing the permit_@return a controllable runnable that acquires a permit;private Runnable controlledAcquire(_            final CyclicBarrier barrier,_            final CountDownLatch operationExecutingLatch,_            final CountDownLatch operationLatch,_            final CountDownLatch operationCompleteLatch) {_        return () -> {_            try {_                barrier.await()__            } catch (final BrokenBarrierException | InterruptedException e) {_                throw new RuntimeException(e)__            }_            permits.acquire(_                    new ActionListener<Releasable>() {_                        @Override_                        public void onResponse(Releasable releasable) {_                            operationExecutingLatch.countDown()__                            try {_                                operationLatch.await()__                            } catch (final InterruptedException e) {_                                throw new RuntimeException(e)__                            }_                            releasable.close()__                            operationCompleteLatch.countDown()__                        }__                        @Override_                        public void onFailure(Exception e) {_                            throw new RuntimeException(e)__                        }_                    },_                    ThreadPool.Names.GENERIC,_                    false, "")__        }__    };returns,an,operation,that,acquires,a,permit,and,synchronizes,in,the,following,manner,ul,li,waits,on,the,code,barrier,before,acquiring,a,permit,li,li,counts,down,the,code,operation,executing,latch,when,it,acquires,the,permit,li,li,waits,on,the,code,operation,latch,before,releasing,the,permit,li,li,counts,down,the,code,operation,complete,latch,after,releasing,the,permit,li,ul,param,barrier,the,barrier,to,wait,on,param,operation,executing,latch,the,latch,to,countdown,after,acquiring,the,permit,param,operation,latch,the,latch,to,wait,on,before,releasing,the,permit,param,operation,complete,latch,the,latch,to,countdown,after,releasing,the,permit,return,a,controllable,runnable,that,acquires,a,permit;private,runnable,controlled,acquire,final,cyclic,barrier,barrier,final,count,down,latch,operation,executing,latch,final,count,down,latch,operation,latch,final,count,down,latch,operation,complete,latch,return,try,barrier,await,catch,final,broken,barrier,exception,interrupted,exception,e,throw,new,runtime,exception,e,permits,acquire,new,action,listener,releasable,override,public,void,on,response,releasable,releasable,operation,executing,latch,count,down,try,operation,latch,await,catch,final,interrupted,exception,e,throw,new,runtime,exception,e,releasable,close,operation,complete,latch,count,down,override,public,void,on,failure,exception,e,throw,new,runtime,exception,e,thread,pool,names,generic,false
IndexShardOperationPermitsTests -> private Runnable controlledAcquire(             final CyclicBarrier barrier,             final CountDownLatch operationExecutingLatch,             final CountDownLatch operationLatch,             final CountDownLatch operationCompleteLatch);1533295538;Returns an operation that acquires a permit and synchronizes in the following manner:_<ul>_<li>waits on the {@code barrier} before acquiring a permit</li>_<li>counts down the {@code operationExecutingLatch} when it acquires the permit</li>_<li>waits on the {@code operationLatch} before releasing the permit</li>_<li>counts down the {@code operationCompleteLatch} after releasing the permit</li>_</ul>__@param barrier                 the barrier to wait on_@param operationExecutingLatch the latch to countdown after acquiring the permit_@param operationLatch          the latch to wait on before releasing the permit_@param operationCompleteLatch  the latch to countdown after releasing the permit_@return a controllable runnable that acquires a permit;private Runnable controlledAcquire(_            final CyclicBarrier barrier,_            final CountDownLatch operationExecutingLatch,_            final CountDownLatch operationLatch,_            final CountDownLatch operationCompleteLatch) {_        return () -> {_            try {_                barrier.await()__            } catch (final BrokenBarrierException | InterruptedException e) {_                throw new RuntimeException(e)__            }_            permits.acquire(_                    new ActionListener<Releasable>() {_                        @Override_                        public void onResponse(Releasable releasable) {_                            operationExecutingLatch.countDown()__                            try {_                                operationLatch.await()__                            } catch (final InterruptedException e) {_                                throw new RuntimeException(e)__                            }_                            releasable.close()__                            operationCompleteLatch.countDown()__                        }__                        @Override_                        public void onFailure(Exception e) {_                            throw new RuntimeException(e)__                        }_                    },_                    ThreadPool.Names.GENERIC,_                    false, "")__        }__    };returns,an,operation,that,acquires,a,permit,and,synchronizes,in,the,following,manner,ul,li,waits,on,the,code,barrier,before,acquiring,a,permit,li,li,counts,down,the,code,operation,executing,latch,when,it,acquires,the,permit,li,li,waits,on,the,code,operation,latch,before,releasing,the,permit,li,li,counts,down,the,code,operation,complete,latch,after,releasing,the,permit,li,ul,param,barrier,the,barrier,to,wait,on,param,operation,executing,latch,the,latch,to,countdown,after,acquiring,the,permit,param,operation,latch,the,latch,to,wait,on,before,releasing,the,permit,param,operation,complete,latch,the,latch,to,countdown,after,releasing,the,permit,return,a,controllable,runnable,that,acquires,a,permit;private,runnable,controlled,acquire,final,cyclic,barrier,barrier,final,count,down,latch,operation,executing,latch,final,count,down,latch,operation,latch,final,count,down,latch,operation,complete,latch,return,try,barrier,await,catch,final,broken,barrier,exception,interrupted,exception,e,throw,new,runtime,exception,e,permits,acquire,new,action,listener,releasable,override,public,void,on,response,releasable,releasable,operation,executing,latch,count,down,try,operation,latch,await,catch,final,interrupted,exception,e,throw,new,runtime,exception,e,releasable,close,operation,complete,latch,count,down,override,public,void,on,failure,exception,e,throw,new,runtime,exception,e,thread,pool,names,generic,false
IndexShardOperationPermitsTests -> private Runnable controlledAcquire(             final CyclicBarrier barrier,             final CountDownLatch operationExecutingLatch,             final CountDownLatch operationLatch,             final CountDownLatch operationCompleteLatch);1541665413;Returns an operation that acquires a permit and synchronizes in the following manner:_<ul>_<li>waits on the {@code barrier} before acquiring a permit</li>_<li>counts down the {@code operationExecutingLatch} when it acquires the permit</li>_<li>waits on the {@code operationLatch} before releasing the permit</li>_<li>counts down the {@code operationCompleteLatch} after releasing the permit</li>_</ul>__@param barrier                 the barrier to wait on_@param operationExecutingLatch the latch to countdown after acquiring the permit_@param operationLatch          the latch to wait on before releasing the permit_@param operationCompleteLatch  the latch to countdown after releasing the permit_@return a controllable runnable that acquires a permit;private Runnable controlledAcquire(_            final CyclicBarrier barrier,_            final CountDownLatch operationExecutingLatch,_            final CountDownLatch operationLatch,_            final CountDownLatch operationCompleteLatch) {_        return () -> {_            try {_                barrier.await()__            } catch (final BrokenBarrierException | InterruptedException e) {_                throw new RuntimeException(e)__            }_            permits.acquire(_                    new ActionListener<Releasable>() {_                        @Override_                        public void onResponse(Releasable releasable) {_                            operationExecutingLatch.countDown()__                            try {_                                operationLatch.await()__                            } catch (final InterruptedException e) {_                                throw new RuntimeException(e)__                            }_                            releasable.close()__                            operationCompleteLatch.countDown()__                        }__                        @Override_                        public void onFailure(Exception e) {_                            throw new RuntimeException(e)__                        }_                    },_                    ThreadPool.Names.GENERIC,_                    false, "")__        }__    };returns,an,operation,that,acquires,a,permit,and,synchronizes,in,the,following,manner,ul,li,waits,on,the,code,barrier,before,acquiring,a,permit,li,li,counts,down,the,code,operation,executing,latch,when,it,acquires,the,permit,li,li,waits,on,the,code,operation,latch,before,releasing,the,permit,li,li,counts,down,the,code,operation,complete,latch,after,releasing,the,permit,li,ul,param,barrier,the,barrier,to,wait,on,param,operation,executing,latch,the,latch,to,countdown,after,acquiring,the,permit,param,operation,latch,the,latch,to,wait,on,before,releasing,the,permit,param,operation,complete,latch,the,latch,to,countdown,after,releasing,the,permit,return,a,controllable,runnable,that,acquires,a,permit;private,runnable,controlled,acquire,final,cyclic,barrier,barrier,final,count,down,latch,operation,executing,latch,final,count,down,latch,operation,latch,final,count,down,latch,operation,complete,latch,return,try,barrier,await,catch,final,broken,barrier,exception,interrupted,exception,e,throw,new,runtime,exception,e,permits,acquire,new,action,listener,releasable,override,public,void,on,response,releasable,releasable,operation,executing,latch,count,down,try,operation,latch,await,catch,final,interrupted,exception,e,throw,new,runtime,exception,e,releasable,close,operation,complete,latch,count,down,override,public,void,on,failure,exception,e,throw,new,runtime,exception,e,thread,pool,names,generic,false
IndexShardOperationPermitsTests -> public void testThreadContextPreservedIfBlock() throws ExecutionException, InterruptedException, TimeoutException;1524684173;Tests that the ThreadContext is restored when a operation is executed after it has been delayed due to a block;public void testThreadContextPreservedIfBlock() throws ExecutionException, InterruptedException, TimeoutException {_        final ThreadContext context = threadPool.getThreadContext()__        final Function<ActionListener<Releasable>, Boolean> contextChecker = (listener) -> {_            if ("bar".equals(context.getHeader("foo")) == false) {_                listener.onFailure(new IllegalStateException("context did not have value [bar] for header [foo]. Actual value [" +_                    context.getHeader("foo") + "]"))__            } else if ("baz".equals(context.getTransient("bar")) == false) {_                listener.onFailure(new IllegalStateException("context did not have value [baz] for transient [bar]. Actual value [" +_                    context.getTransient("bar") + "]"))__            } else {_                return true__            }_            return false__        }__        PlainActionFuture<Releasable> future = new PlainActionFuture<Releasable>() {_            @Override_            public void onResponse(Releasable releasable) {_                if (contextChecker.apply(this)) {_                    super.onResponse(releasable)__                }_            }_        }__        PlainActionFuture<Releasable> future2 = new PlainActionFuture<Releasable>() {_            @Override_            public void onResponse(Releasable releasable) {_                if (contextChecker.apply(this)) {_                    super.onResponse(releasable)__                }_            }_        }___        try (Releasable ignored = blockAndWait()) {_            _            _            try (ThreadContext.StoredContext ignore = context.newStoredContext(false)) {_                context.putHeader("foo", "bar")__                context.putTransient("bar", "baz")__                _                permits.acquire(future, ThreadPool.Names.GENERIC, true, "")__                permits.acquire(future2, null, true, "")__            }_            assertFalse(future.isDone())__        }_        future.get(1, TimeUnit.HOURS).close()__        future2.get(1, TimeUnit.HOURS).close()__    };tests,that,the,thread,context,is,restored,when,a,operation,is,executed,after,it,has,been,delayed,due,to,a,block;public,void,test,thread,context,preserved,if,block,throws,execution,exception,interrupted,exception,timeout,exception,final,thread,context,context,thread,pool,get,thread,context,final,function,action,listener,releasable,boolean,context,checker,listener,if,bar,equals,context,get,header,foo,false,listener,on,failure,new,illegal,state,exception,context,did,not,have,value,bar,for,header,foo,actual,value,context,get,header,foo,else,if,baz,equals,context,get,transient,bar,false,listener,on,failure,new,illegal,state,exception,context,did,not,have,value,baz,for,transient,bar,actual,value,context,get,transient,bar,else,return,true,return,false,plain,action,future,releasable,future,new,plain,action,future,releasable,override,public,void,on,response,releasable,releasable,if,context,checker,apply,this,super,on,response,releasable,plain,action,future,releasable,future2,new,plain,action,future,releasable,override,public,void,on,response,releasable,releasable,if,context,checker,apply,this,super,on,response,releasable,try,releasable,ignored,block,and,wait,try,thread,context,stored,context,ignore,context,new,stored,context,false,context,put,header,foo,bar,context,put,transient,bar,baz,permits,acquire,future,thread,pool,names,generic,true,permits,acquire,future2,null,true,assert,false,future,is,done,future,get,1,time,unit,hours,close,future2,get,1,time,unit,hours,close
IndexShardOperationPermitsTests -> public void testThreadContextPreservedIfBlock() throws ExecutionException, InterruptedException, TimeoutException;1533295538;Tests that the ThreadContext is restored when a operation is executed after it has been delayed due to a block;public void testThreadContextPreservedIfBlock() throws ExecutionException, InterruptedException, TimeoutException {_        final ThreadContext context = threadPool.getThreadContext()__        final Function<ActionListener<Releasable>, Boolean> contextChecker = (listener) -> {_            if ("bar".equals(context.getHeader("foo")) == false) {_                listener.onFailure(new IllegalStateException("context did not have value [bar] for header [foo]. Actual value [" +_                    context.getHeader("foo") + "]"))__            } else if ("baz".equals(context.getTransient("bar")) == false) {_                listener.onFailure(new IllegalStateException("context did not have value [baz] for transient [bar]. Actual value [" +_                    context.getTransient("bar") + "]"))__            } else {_                return true__            }_            return false__        }__        PlainActionFuture<Releasable> future = new PlainActionFuture<Releasable>() {_            @Override_            public void onResponse(Releasable releasable) {_                if (contextChecker.apply(this)) {_                    super.onResponse(releasable)__                }_            }_        }__        PlainActionFuture<Releasable> future2 = new PlainActionFuture<Releasable>() {_            @Override_            public void onResponse(Releasable releasable) {_                if (contextChecker.apply(this)) {_                    super.onResponse(releasable)__                }_            }_        }___        try (Releasable ignored = blockAndWait()) {_            _            _            try (ThreadContext.StoredContext ignore = context.newStoredContext(false)) {_                context.putHeader("foo", "bar")__                context.putTransient("bar", "baz")__                _                permits.acquire(future, ThreadPool.Names.GENERIC, true, "")__                permits.acquire(future2, null, true, "")__            }_            assertFalse(future.isDone())__        }_        future.get(1, TimeUnit.HOURS).close()__        future2.get(1, TimeUnit.HOURS).close()__    };tests,that,the,thread,context,is,restored,when,a,operation,is,executed,after,it,has,been,delayed,due,to,a,block;public,void,test,thread,context,preserved,if,block,throws,execution,exception,interrupted,exception,timeout,exception,final,thread,context,context,thread,pool,get,thread,context,final,function,action,listener,releasable,boolean,context,checker,listener,if,bar,equals,context,get,header,foo,false,listener,on,failure,new,illegal,state,exception,context,did,not,have,value,bar,for,header,foo,actual,value,context,get,header,foo,else,if,baz,equals,context,get,transient,bar,false,listener,on,failure,new,illegal,state,exception,context,did,not,have,value,baz,for,transient,bar,actual,value,context,get,transient,bar,else,return,true,return,false,plain,action,future,releasable,future,new,plain,action,future,releasable,override,public,void,on,response,releasable,releasable,if,context,checker,apply,this,super,on,response,releasable,plain,action,future,releasable,future2,new,plain,action,future,releasable,override,public,void,on,response,releasable,releasable,if,context,checker,apply,this,super,on,response,releasable,try,releasable,ignored,block,and,wait,try,thread,context,stored,context,ignore,context,new,stored,context,false,context,put,header,foo,bar,context,put,transient,bar,baz,permits,acquire,future,thread,pool,names,generic,true,permits,acquire,future2,null,true,assert,false,future,is,done,future,get,1,time,unit,hours,close,future2,get,1,time,unit,hours,close
IndexShardOperationPermitsTests -> public void testThreadContextPreservedIfBlock() throws ExecutionException, InterruptedException, TimeoutException;1541665413;Tests that the ThreadContext is restored when a operation is executed after it has been delayed due to a block;public void testThreadContextPreservedIfBlock() throws ExecutionException, InterruptedException, TimeoutException {_        final ThreadContext context = threadPool.getThreadContext()__        final Function<ActionListener<Releasable>, Boolean> contextChecker = (listener) -> {_            if ("bar".equals(context.getHeader("foo")) == false) {_                listener.onFailure(new IllegalStateException("context did not have value [bar] for header [foo]. Actual value [" +_                    context.getHeader("foo") + "]"))__            } else if ("baz".equals(context.getTransient("bar")) == false) {_                listener.onFailure(new IllegalStateException("context did not have value [baz] for transient [bar]. Actual value [" +_                    context.getTransient("bar") + "]"))__            } else {_                return true__            }_            return false__        }__        PlainActionFuture<Releasable> future = new PlainActionFuture<Releasable>() {_            @Override_            public void onResponse(Releasable releasable) {_                if (contextChecker.apply(this)) {_                    super.onResponse(releasable)__                }_            }_        }__        PlainActionFuture<Releasable> future2 = new PlainActionFuture<Releasable>() {_            @Override_            public void onResponse(Releasable releasable) {_                if (contextChecker.apply(this)) {_                    super.onResponse(releasable)__                }_            }_        }___        try (Releasable ignored = blockAndWait()) {_            _            _            try (ThreadContext.StoredContext ignore = context.newStoredContext(false)) {_                context.putHeader("foo", "bar")__                context.putTransient("bar", "baz")__                _                permits.acquire(future, ThreadPool.Names.GENERIC, true, "")__                permits.acquire(future2, null, true, "")__            }_            assertFalse(future.isDone())__        }_        future.get(1, TimeUnit.HOURS).close()__        future2.get(1, TimeUnit.HOURS).close()__    };tests,that,the,thread,context,is,restored,when,a,operation,is,executed,after,it,has,been,delayed,due,to,a,block;public,void,test,thread,context,preserved,if,block,throws,execution,exception,interrupted,exception,timeout,exception,final,thread,context,context,thread,pool,get,thread,context,final,function,action,listener,releasable,boolean,context,checker,listener,if,bar,equals,context,get,header,foo,false,listener,on,failure,new,illegal,state,exception,context,did,not,have,value,bar,for,header,foo,actual,value,context,get,header,foo,else,if,baz,equals,context,get,transient,bar,false,listener,on,failure,new,illegal,state,exception,context,did,not,have,value,baz,for,transient,bar,actual,value,context,get,transient,bar,else,return,true,return,false,plain,action,future,releasable,future,new,plain,action,future,releasable,override,public,void,on,response,releasable,releasable,if,context,checker,apply,this,super,on,response,releasable,plain,action,future,releasable,future2,new,plain,action,future,releasable,override,public,void,on,response,releasable,releasable,if,context,checker,apply,this,super,on,response,releasable,try,releasable,ignored,block,and,wait,try,thread,context,stored,context,ignore,context,new,stored,context,false,context,put,header,foo,bar,context,put,transient,bar,baz,permits,acquire,future,thread,pool,names,generic,true,permits,acquire,future2,null,true,assert,false,future,is,done,future,get,1,time,unit,hours,close,future2,get,1,time,unit,hours,close
