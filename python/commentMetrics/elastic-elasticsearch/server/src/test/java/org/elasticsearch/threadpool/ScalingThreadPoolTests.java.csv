commented;modifiers;parameterAmount;loc;comment;code
false;public;0;58;;public void testScalingThreadPoolConfiguration() throws InterruptedException {     final String threadPoolName = randomThreadPool(ThreadPool.ThreadPoolType.SCALING).     final Settings.Builder builder = Settings.builder().     final int core.     if (randomBoolean()) {         core = randomIntBetween(0, 8).         builder.put("thread_pool." + threadPoolName + ".core", core).     } else {         // the defaults         core = "generic".equals(threadPoolName) ? 4 : 1.     }     final int maxBasedOnNumberOfProcessors.     if (randomBoolean()) {         final int processors = randomIntBetween(1, 64).         maxBasedOnNumberOfProcessors = expectedSize(threadPoolName, processors).         builder.put("processors", processors).     } else {         maxBasedOnNumberOfProcessors = expectedSize(threadPoolName, Runtime.getRuntime().availableProcessors()).     }     final int expectedMax.     if (maxBasedOnNumberOfProcessors < core || randomBoolean()) {         expectedMax = randomIntBetween(Math.max(1, core), 16).         builder.put("thread_pool." + threadPoolName + ".max", expectedMax).     } else {         expectedMax = maxBasedOnNumberOfProcessors.     }     final long keepAlive.     if (randomBoolean()) {         keepAlive = randomIntBetween(1, 300).         builder.put("thread_pool." + threadPoolName + ".keep_alive", keepAlive + "s").     } else {         // the defaults         keepAlive = "generic".equals(threadPoolName) ? 30 : 300.     }     runScalingThreadPoolTest(builder.build(), (clusterSettings, threadPool) -> {         final Executor executor = threadPool.executor(threadPoolName).         assertThat(executor, instanceOf(EsThreadPoolExecutor.class)).         final EsThreadPoolExecutor esThreadPoolExecutor = (EsThreadPoolExecutor) executor.         final ThreadPool.Info info = info(threadPool, threadPoolName).         assertThat(info.getName(), equalTo(threadPoolName)).         assertThat(info.getThreadPoolType(), equalTo(ThreadPool.ThreadPoolType.SCALING)).         assertThat(info.getKeepAlive().seconds(), equalTo(keepAlive)).         assertThat(esThreadPoolExecutor.getKeepAliveTime(TimeUnit.SECONDS), equalTo(keepAlive)).         assertNull(info.getQueueSize()).         assertThat(esThreadPoolExecutor.getQueue().remainingCapacity(), equalTo(Integer.MAX_VALUE)).         assertThat(info.getMin(), equalTo(core)).         assertThat(esThreadPoolExecutor.getCorePoolSize(), equalTo(core)).         assertThat(info.getMax(), equalTo(expectedMax)).         assertThat(esThreadPoolExecutor.getMaximumPoolSize(), equalTo(expectedMax)).     }). }
false;private;2;12;;private int expectedSize(final String threadPoolName, final int numberOfProcessors) {     final Map<String, Function<Integer, Integer>> sizes = new HashMap<>().     sizes.put(ThreadPool.Names.GENERIC, n -> ThreadPool.boundedBy(4 * n, 128, 512)).     sizes.put(ThreadPool.Names.MANAGEMENT, n -> 5).     sizes.put(ThreadPool.Names.FLUSH, ThreadPool::halfNumberOfProcessorsMaxFive).     sizes.put(ThreadPool.Names.REFRESH, ThreadPool::halfNumberOfProcessorsMaxTen).     sizes.put(ThreadPool.Names.WARMER, ThreadPool::halfNumberOfProcessorsMaxFive).     sizes.put(ThreadPool.Names.SNAPSHOT, ThreadPool::halfNumberOfProcessorsMaxFive).     sizes.put(ThreadPool.Names.FETCH_SHARD_STARTED, ThreadPool::twiceNumberOfProcessors).     sizes.put(ThreadPool.Names.FETCH_SHARD_STORE, ThreadPool::twiceNumberOfProcessors).     return sizes.get(threadPoolName).apply(numberOfProcessors). }
false;public;0;29;;public void testScalingThreadPoolIsBounded() throws InterruptedException {     final String threadPoolName = randomThreadPool(ThreadPool.ThreadPoolType.SCALING).     final int size = randomIntBetween(32, 512).     final Settings settings = Settings.builder().put("thread_pool." + threadPoolName + ".max", size).build().     runScalingThreadPoolTest(settings, (clusterSettings, threadPool) -> {         final CountDownLatch latch = new CountDownLatch(1).         final int numberOfTasks = 2 * size.         final CountDownLatch taskLatch = new CountDownLatch(numberOfTasks).         for (int i = 0. i < numberOfTasks. i++) {             threadPool.executor(threadPoolName).execute(() -> {                 try {                     latch.await().                     taskLatch.countDown().                 } catch (final InterruptedException e) {                     throw new RuntimeException(e).                 }             }).         }         final ThreadPoolStats.Stats stats = stats(threadPool, threadPoolName).         assertThat(stats.getQueue(), equalTo(numberOfTasks - size)).         assertThat(stats.getLargest(), equalTo(size)).         latch.countDown().         try {             taskLatch.await().         } catch (InterruptedException e) {             throw new RuntimeException(e).         }     }). }
false;public;0;40;;public void testScalingThreadPoolThreadsAreTerminatedAfterKeepAlive() throws InterruptedException {     final String threadPoolName = randomThreadPool(ThreadPool.ThreadPoolType.SCALING).     final int min = "generic".equals(threadPoolName) ? 4 : 1.     final Settings settings = Settings.builder().put("thread_pool." + threadPoolName + ".max", 128).put("thread_pool." + threadPoolName + ".keep_alive", "1ms").build().     runScalingThreadPoolTest(settings, ((clusterSettings, threadPool) -> {         final CountDownLatch latch = new CountDownLatch(1).         final CountDownLatch taskLatch = new CountDownLatch(128).         for (int i = 0. i < 128. i++) {             threadPool.executor(threadPoolName).execute(() -> {                 try {                     latch.await().                     taskLatch.countDown().                 } catch (final InterruptedException e) {                     throw new RuntimeException(e).                 }             }).         }         int threads = stats(threadPool, threadPoolName).getThreads().         assertEquals(128, threads).         latch.countDown().         // down         do {             spinForAtLeastOneMillisecond().         } while (stats(threadPool, threadPoolName).getThreads() > min).         try {             taskLatch.await().         } catch (InterruptedException e) {             throw new RuntimeException(e).         }     })). }
false;public;2;14;;public void runScalingThreadPoolTest(final Settings settings, final BiConsumer<ClusterSettings, ThreadPool> consumer) throws InterruptedException {     ThreadPool threadPool = null.     try {         final String test = Thread.currentThread().getStackTrace()[2].getMethodName().         final Settings nodeSettings = Settings.builder().put(settings).put("node.name", test).build().         threadPool = new ThreadPool(nodeSettings).         final ClusterSettings clusterSettings = new ClusterSettings(nodeSettings, ClusterSettings.BUILT_IN_CLUSTER_SETTINGS).         consumer.accept(clusterSettings, threadPool).     } finally {         terminateThreadPoolIfNeeded(threadPool).     } }
