commented;modifiers;parameterAmount;loc;comment;code
false;;0;5;;@Override long nanoTime() {     nanoTimeCallCounter.incrementAndGet().     return time += 1. }
false;public;0;22;;public void testTimingInterval() {     final AtomicLong nanoTimeCallCounter = new AtomicLong().     Timer t = new Timer() {          long time = 50.          @Override         long nanoTime() {             nanoTimeCallCounter.incrementAndGet().             return time += 1.         }     }.     for (int i = 0. i < 100000. ++i) {         t.start().         t.stop().         if (i < 256) {             // for the first 256 calls, nanoTime() is called             // once for `start` and once for `stop`             assertEquals((i + 1) * 2, nanoTimeCallCounter.get()).         }     }     // only called nanoTime() 3356 times, which is significantly less than 100000     assertEquals(3356L, nanoTimeCallCounter.get()). }
false;;0;4;;@Override long nanoTime() {     return time += 42. }
false;public;0;16;;public void testExtrapolate() {     Timer t = new Timer() {          long time = 50.          @Override         long nanoTime() {             return time += 42.         }     }.     for (int i = 1. i < 100000. ++i) {         t.start().         t.stop().         assertEquals(i, t.getCount()).         // Make sure the cumulated timing is 42 times the number of calls as expected         assertEquals(i * 42L, t.getApproximateTiming()).     } }
