commented;modifiers;parameterAmount;loc;comment;code
false;public;0;36;;@Override public void setUp() throws Exception {     super.setUp().     format = randomNumericDocValueFormat().     List<Tuple<Double, Double>> listOfRanges = new ArrayList<>().     if (rarely()) {         listOfRanges.add(Tuple.tuple(Double.NEGATIVE_INFINITY, Double.POSITIVE_INFINITY)).     }     if (rarely()) {         listOfRanges.add(Tuple.tuple(Double.NEGATIVE_INFINITY, randomDouble())).     }     if (rarely()) {         listOfRanges.add(Tuple.tuple(randomDouble(), Double.POSITIVE_INFINITY)).     }     final int interval = randomFrom(1, 5, 10, 25, 50, 100).     final int numRanges = Math.max(0, randomNumberOfBuckets() - listOfRanges.size()).     final double max = (double) numRanges * interval.     for (int i = 0. numRanges - listOfRanges.size() > 0. i++) {         double from = i * interval.         double to = from + interval.         Tuple<Double, Double> range.         if (randomBoolean()) {             range = Tuple.tuple(from, to).         } else {             // Add some overlapping range             range = Tuple.tuple(randomFrom(0.0, max / 3), randomFrom(max, max / 2, max / 3 * 2)).         }         listOfRanges.add(range).     }     Collections.shuffle(listOfRanges, random()).     ranges = Collections.unmodifiableList(listOfRanges). }
false;protected;5;16;;@Override protected InternalRange createTestInstance(String name, List<PipelineAggregator> pipelineAggregators, Map<String, Object> metaData, InternalAggregations aggregations, boolean keyed) {     final List<InternalRange.Bucket> buckets = new ArrayList<>().     for (int i = 0. i < ranges.size(). ++i) {         Tuple<Double, Double> range = ranges.get(i).         int docCount = randomIntBetween(0, 1000).         double from = range.v1().         double to = range.v2().         buckets.add(new InternalRange.Bucket("range_" + i, from, to, docCount, aggregations, keyed, format)).     }     return new InternalRange<>(name, buckets, format, keyed, pipelineAggregators, metaData). }
false;protected;0;4;;@Override protected Writeable.Reader<InternalRange> instanceReader() {     return InternalRange::new. }
false;protected;0;4;;@Override protected Class<? extends ParsedMultiBucketAggregation> implementationClass() {     return ParsedRange.class. }
false;protected;0;4;;@Override protected Class<? extends InternalMultiBucketAggregation.InternalBucket> internalRangeBucketClass() {     return InternalRange.Bucket.class. }
false;protected;0;4;;@Override protected Class<? extends ParsedMultiBucketAggregation.ParsedBucket> parsedRangeBucketClass() {     return ParsedRange.ParsedBucket.class. }
false;protected;1;34;;@Override protected InternalRange mutateInstance(InternalRange instance) {     String name = instance.getName().     DocValueFormat format = instance.format.     boolean keyed = instance.keyed.     List<InternalRange.Bucket> buckets = instance.getBuckets().     List<PipelineAggregator> pipelineAggregators = instance.pipelineAggregators().     Map<String, Object> metaData = instance.getMetaData().     switch(between(0, 3)) {         case 0:             name += randomAlphaOfLength(5).             break.         case 1:             keyed = keyed == false.             break.         case 2:             buckets = new ArrayList<>(buckets).             double from = randomDouble().             buckets.add(new InternalRange.Bucket("range_a", from, from + randomDouble(), randomNonNegativeLong(), InternalAggregations.EMPTY, false, format)).             break.         case 3:             if (metaData == null) {                 metaData = new HashMap<>(1).             } else {                 metaData = new HashMap<>(instance.getMetaData()).             }             metaData.put(randomAlphaOfLength(15), randomInt()).             break.         default:             throw new AssertionError("Illegal randomisation branch").     }     return new InternalRange<>(name, buckets, format, keyed, pipelineAggregators, metaData). }
