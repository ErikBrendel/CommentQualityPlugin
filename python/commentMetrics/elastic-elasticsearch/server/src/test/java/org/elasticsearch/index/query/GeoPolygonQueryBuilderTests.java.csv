commented;modifiers;parameterAmount;loc;comment;code
false;protected;0;14;;@Override protected GeoPolygonQueryBuilder doCreateTestQueryBuilder() {     String fieldName = randomFrom(GEO_POINT_FIELD_NAME, GEO_POINT_ALIAS_FIELD_NAME).     List<GeoPoint> polygon = randomPolygon().     GeoPolygonQueryBuilder builder = new GeoPolygonQueryBuilder(fieldName, polygon).     if (randomBoolean()) {         builder.setValidationMethod(randomFrom(GeoValidationMethod.values())).     }     if (randomBoolean()) {         builder.ignoreUnmapped(randomBoolean()).     }     return builder. }
false;protected;3;4;;@Override protected void doAssertLuceneQuery(GeoPolygonQueryBuilder queryBuilder, Query query, SearchContext context) throws IOException { // todo LatLonPointInPolygon is package private }
false;private,static;0;16;;private static List<GeoPoint> randomPolygon() {     ShapeBuilder<?, ?, ?> shapeBuilder = null.     // in this case keep trying until we successfully generate one     while (shapeBuilder == null) {         shapeBuilder = RandomShapeGenerator.createShapeWithin(random(), null, ShapeType.POLYGON).     }     JtsGeometry shape = (JtsGeometry) shapeBuilder.buildS4J().     Coordinate[] coordinates = shape.getGeom().getCoordinates().     ArrayList<GeoPoint> polygonPoints = new ArrayList<>().     for (Coordinate coord : coordinates) {         polygonPoints.add(new GeoPoint(coord.y, coord.x)).     }     return polygonPoints. }
false;public;0;4;;public void testNullFieldName() {     IllegalArgumentException e = expectThrows(IllegalArgumentException.class, () -> new GeoPolygonQueryBuilder(null, randomPolygon())).     assertEquals("fieldName must not be null", e.getMessage()). }
false;public;0;8;;public void testEmptyPolygon() {     IllegalArgumentException e = expectThrows(IllegalArgumentException.class, () -> new GeoPolygonQueryBuilder(GEO_POINT_FIELD_NAME, Collections.emptyList())).     assertEquals("polygon must not be null or empty", e.getMessage()).     e = expectThrows(IllegalArgumentException.class, () -> new GeoPolygonQueryBuilder(GEO_POINT_FIELD_NAME, null)).     assertEquals("polygon must not be null or empty", e.getMessage()). }
false;public;0;9;;public void testInvalidClosedPolygon() {     List<GeoPoint> points = new ArrayList<>().     points.add(new GeoPoint(0, 90)).     points.add(new GeoPoint(90, 90)).     points.add(new GeoPoint(0, 90)).     IllegalArgumentException e = expectThrows(IllegalArgumentException.class, () -> new GeoPolygonQueryBuilder(GEO_POINT_FIELD_NAME, points)).     assertEquals("too few points defined for geo_polygon query", e.getMessage()). }
false;public;0;8;;public void testInvalidOpenPolygon() {     List<GeoPoint> points = new ArrayList<>().     points.add(new GeoPoint(0, 90)).     points.add(new GeoPoint(90, 90)).     IllegalArgumentException e = expectThrows(IllegalArgumentException.class, () -> new GeoPolygonQueryBuilder(GEO_POINT_FIELD_NAME, points)).     assertEquals("too few points defined for geo_polygon query", e.getMessage()). }
false;public;0;13;;public void testParsingAndToQueryParsingExceptions() throws IOException {     String[] brokenFiles = new String[] { "/org/elasticsearch/index/query/geo_polygon_exception_1.json", "/org/elasticsearch/index/query/geo_polygon_exception_2.json", "/org/elasticsearch/index/query/geo_polygon_exception_3.json", "/org/elasticsearch/index/query/geo_polygon_exception_4.json", "/org/elasticsearch/index/query/geo_polygon_exception_5.json" }.     for (String brokenFile : brokenFiles) {         String query = copyToStringFromClasspath(brokenFile).         expectThrows(ParsingException.class, () -> parseQuery(query)).     } }
false;public;0;14;;public void testParsingAndToQuery1() throws IOException {     String query = "{\n" + "    \"geo_polygon\":{\n" + "        \"" + GEO_POINT_FIELD_NAME + "\":{\n" + "            \"points\":[\n" + "                [-70, 40],\n" + "                [-80, 30],\n" + "                [-90, 20]\n" + "            ]\n" + "        }\n" + "    }\n" + "}\n".     assertGeoPolygonQuery(query). }
false;public;0;23;;public void testParsingAndToQuery2() throws IOException {     String query = "{\n" + "    \"geo_polygon\":{\n" + "        \"" + GEO_POINT_FIELD_NAME + "\":{\n" + "            \"points\":[\n" + "                {\n" + "                    \"lat\":40,\n" + "                    \"lon\":-70\n" + "                },\n" + "                {\n" + "                    \"lat\":30,\n" + "                    \"lon\":-80\n" + "                },\n" + "                {\n" + "                    \"lat\":20,\n" + "                    \"lon\":-90\n" + "                }\n" + "            ]\n" + "        }\n" + "    }\n" + "}\n".     assertGeoPolygonQuery(query). }
false;public;0;14;;public void testParsingAndToQuery3() throws IOException {     String query = "{\n" + "    \"geo_polygon\":{\n" + "        \"" + GEO_POINT_FIELD_NAME + "\":{\n" + "            \"points\":[\n" + "                \"40, -70\",\n" + "                \"30, -80\",\n" + "                \"20, -90\"\n" + "            ]\n" + "        }\n" + "    }\n" + "}\n".     assertGeoPolygonQuery(query). }
false;public;0;14;;public void testParsingAndToQuery4() throws IOException {     String query = "{\n" + "    \"geo_polygon\":{\n" + "        \"" + GEO_POINT_FIELD_NAME + "\":{\n" + "            \"points\":[\n" + "                \"drn5x1g8cu2y\",\n" + "                \"30, -80\",\n" + "                \"20, -90\"\n" + "            ]\n" + "        }\n" + "    }\n" + "}\n".     assertGeoPolygonQuery(query). }
false;private;1;6;;private void assertGeoPolygonQuery(String query) throws IOException {     QueryShardContext context = createShardContext().     parseQuery(query).toQuery(context). // TODO LatLonPointInPolygon is package private, need a closeTo check on the query // since some points can be computed from the geohash }
false;public;0;16;;public void testFromJson() throws IOException {     String json = "{\n" + "  \"geo_polygon\" : {\n" + "    \"person.location\" : {\n" + "      \"points\" : [ [ -70.0, 40.0 ], [ -80.0, 30.0 ], [ -90.0, 20.0 ], [ -70.0, 40.0 ] ]\n" + "    },\n" + "    \"validation_method\" : \"STRICT\",\n" + "    \"ignore_unmapped\" : false,\n" + "    \"boost\" : 1.0\n" + "  }\n" + "}".     GeoPolygonQueryBuilder parsed = (GeoPolygonQueryBuilder) parseQuery(json).     checkGeneratedJson(json, parsed).     assertEquals(json, 4, parsed.points().size()). }
false;public;0;13;;public void testIgnoreUnmapped() throws IOException {     List<GeoPoint> polygon = randomPolygon().     final GeoPolygonQueryBuilder queryBuilder = new GeoPolygonQueryBuilder("unmapped", polygon).     queryBuilder.ignoreUnmapped(true).     Query query = queryBuilder.toQuery(createShardContext()).     assertThat(query, notNullValue()).     assertThat(query, instanceOf(MatchNoDocsQuery.class)).     final GeoPolygonQueryBuilder failingQueryBuilder = new GeoPolygonQueryBuilder("unmapped", polygon).     failingQueryBuilder.ignoreUnmapped(false).     QueryShardException e = expectThrows(QueryShardException.class, () -> failingQueryBuilder.toQuery(createShardContext())).     assertThat(e.getMessage(), containsString("failed to find geo_point field [unmapped]")). }
false;public;0;32;;public void testPointValidation() throws IOException {     QueryShardContext context = createShardContext().     String queryInvalidLat = "{\n" + "    \"geo_polygon\":{\n" + "        \"" + GEO_POINT_FIELD_NAME + "\":{\n" + "            \"points\":[\n" + "                [-70, 140],\n" + "                [-80, 30],\n" + "                [-90, 20]\n" + "            ]\n" + "        }\n" + "    }\n" + "}\n".     QueryShardException e1 = expectThrows(QueryShardException.class, () -> parseQuery(queryInvalidLat).toQuery(context)).     assertThat(e1.getMessage(), containsString("illegal latitude value [140.0] for [geo_polygon]")).     String queryInvalidLon = "{\n" + "    \"geo_polygon\":{\n" + "        \"" + GEO_POINT_FIELD_NAME + "\":{\n" + "            \"points\":[\n" + "                [-70, 40],\n" + "                [-80, 30],\n" + "                [-190, 20]\n" + "            ]\n" + "        }\n" + "    }\n" + "}\n".     QueryShardException e2 = expectThrows(QueryShardException.class, () -> parseQuery(queryInvalidLon).toQuery(context)).     assertThat(e2.getMessage(), containsString("illegal longitude value [-190.0] for [geo_polygon]")). }
