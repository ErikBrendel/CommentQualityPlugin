commented;modifiers;parameterAmount;loc;comment;code
false;protected,abstract;0;1;;protected abstract String getFieldDataType().
false;protected;0;3;;protected boolean hasDocValues() {     return false. }
false;public;1;3;;public <IFD extends IndexFieldData<?>> IFD getForField(String fieldName) {     return getForField(getFieldDataType(), fieldName, hasDocValues()). }
false;public;2;3;;public <IFD extends IndexFieldData<?>> IFD getForField(String type, String fieldName) {     return getForField(type, fieldName, hasDocValues()). }
false;protected;0;4;;@Override protected Collection<Class<? extends Plugin>> getPlugins() {     return pluginList(InternalSettingsPlugin.class). }
false;public;3;36;;public <IFD extends IndexFieldData<?>> IFD getForField(String type, String fieldName, boolean docValues) {     final MappedFieldType fieldType.     final BuilderContext context = new BuilderContext(indexService.getIndexSettings().getSettings(), new ContentPath(1)).     if (type.equals("string")) {         if (docValues) {             fieldType = new KeywordFieldMapper.Builder(fieldName).build(context).fieldType().         } else {             fieldType = new TextFieldMapper.Builder(fieldName).fielddata(true).build(context).fieldType().         }     } else if (type.equals("float")) {         fieldType = new NumberFieldMapper.Builder(fieldName, NumberFieldMapper.NumberType.FLOAT).docValues(docValues).build(context).fieldType().     } else if (type.equals("double")) {         fieldType = new NumberFieldMapper.Builder(fieldName, NumberFieldMapper.NumberType.DOUBLE).docValues(docValues).build(context).fieldType().     } else if (type.equals("long")) {         fieldType = new NumberFieldMapper.Builder(fieldName, NumberFieldMapper.NumberType.LONG).docValues(docValues).build(context).fieldType().     } else if (type.equals("int")) {         fieldType = new NumberFieldMapper.Builder(fieldName, NumberFieldMapper.NumberType.INTEGER).docValues(docValues).build(context).fieldType().     } else if (type.equals("short")) {         fieldType = new NumberFieldMapper.Builder(fieldName, NumberFieldMapper.NumberType.SHORT).docValues(docValues).build(context).fieldType().     } else if (type.equals("byte")) {         fieldType = new NumberFieldMapper.Builder(fieldName, NumberFieldMapper.NumberType.BYTE).docValues(docValues).build(context).fieldType().     } else if (type.equals("geo_point")) {         fieldType = new GeoPointFieldMapper.Builder(fieldName).docValues(docValues).build(context).fieldType().     } else if (type.equals("binary")) {         fieldType = new BinaryFieldMapper.Builder(fieldName).docValues(docValues).build(context).fieldType().     } else {         throw new UnsupportedOperationException(type).     }     return shardContext.getForField(fieldType). }
false;public;0;11;;@Before public void setup() throws Exception {     indexService = createIndex("test", Settings.builder().build()).     mapperService = indexService.mapperService().     indicesFieldDataCache = getInstanceFromNode(IndicesService.class).getIndicesFieldDataCache().     // LogByteSizeMP to preserve doc ID order     writer = new IndexWriter(new RAMDirectory(), new IndexWriterConfig(new StandardAnalyzer()).setMergePolicy(new LogByteSizeMergePolicy())).     shardContext = indexService.newQueryShardContext(0, null, () -> 0, null). }
false;protected,final;0;8;;protected final List<LeafReaderContext> refreshReader() throws Exception {     if (readerContexts != null && topLevelReader != null) {         topLevelReader.close().     }     topLevelReader = ElasticsearchDirectoryReader.wrap(DirectoryReader.open(writer), new ShardId("foo", "_na_", 1)).     readerContexts = topLevelReader.leaves().     return readerContexts. }
false;public;0;10;;@Override @After public void tearDown() throws Exception {     super.tearDown().     if (topLevelReader != null) {         topLevelReader.close().     }     writer.close().     shardContext = null. }
false;protected;3;4;;protected Nested createNested(IndexSearcher searcher, Query parentFilter, Query childFilter) throws IOException {     BitsetFilterCache s = indexService.cache().bitsetFilterCache().     return new Nested(s.getBitSetProducer(parentFilter), childFilter, null). }
false;public;0;20;;public void testEmpty() throws Exception {     Document d = new Document().     d.add(new StringField("field", "value", Field.Store.NO)).     writer.addDocument(d).     refreshReader().     IndexFieldData<?> fieldData = getForField("non_existing_field").     int max = randomInt(7).     for (LeafReaderContext readerContext : readerContexts) {         AtomicFieldData previous = null.         for (int i = 0. i < max. i++) {             AtomicFieldData current = fieldData.load(readerContext).             assertThat(current.ramBytesUsed(), equalTo(0L)).             if (previous != null) {                 assertThat(current, not(sameInstance(previous))).             }             previous = current.         }     } }
