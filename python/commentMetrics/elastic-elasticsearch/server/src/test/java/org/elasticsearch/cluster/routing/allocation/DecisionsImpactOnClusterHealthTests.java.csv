commented;modifiers;parameterAmount;loc;comment;code
false;public;0;11;;public void testPrimaryShardNoDecisionOnIndexCreation() throws IOException {     final String indexName = "test-idx".     Settings settings = Settings.builder().put(Environment.PATH_HOME_SETTING.getKey(), createTempDir().toAbsolutePath().toString()).build().     AllocationDecider decider = new TestAllocateDecision(Decision.NO).     // if deciders say NO to allocating a primary shard, then the cluster health should be RED     runAllocationTest(settings, indexName, Collections.singleton(decider), ClusterHealthStatus.RED). }
true;public;2;4;// returns only YES or NO, never THROTTLE ;// the only allocation decider that implements this is ShardsLimitAllocationDecider and it always // returns only YES or NO, never THROTTLE @Override public Decision canAllocate(RoutingNode node, RoutingAllocation allocation) {     return randomBoolean() ? Decision.YES : Decision.NO. }
false;public;0;18;;public void testPrimaryShardThrottleDecisionOnIndexCreation() throws IOException {     final String indexName = "test-idx".     Settings settings = Settings.builder().put(Environment.PATH_HOME_SETTING.getKey(), createTempDir().toAbsolutePath().toString()).build().     AllocationDecider decider = new TestAllocateDecision(Decision.THROTTLE) {          // the only allocation decider that implements this is ShardsLimitAllocationDecider and it always         // returns only YES or NO, never THROTTLE         @Override         public Decision canAllocate(RoutingNode node, RoutingAllocation allocation) {             return randomBoolean() ? Decision.YES : Decision.NO.         }     }.     // if deciders THROTTLE allocating a primary shard, stay in YELLOW state     runAllocationTest(settings, indexName, Collections.singleton(decider), ClusterHealthStatus.YELLOW). }
false;public;3;8;;@Override public Decision canAllocate(ShardRouting shardRouting, RoutingNode node, RoutingAllocation allocation) {     if (node.getByShardId(shardRouting.shardId()) == null) {         return Decision.YES.     } else {         return Decision.NO.     } }
false;public;0;25;;public void testPrimaryShardYesDecisionOnIndexCreation() throws IOException {     final String indexName = "test-idx".     Settings settings = Settings.builder().put(Environment.PATH_HOME_SETTING.getKey(), createTempDir().toAbsolutePath().toString()).build().     AllocationDecider decider = new TestAllocateDecision(Decision.YES) {          @Override         public Decision canAllocate(ShardRouting shardRouting, RoutingNode node, RoutingAllocation allocation) {             if (node.getByShardId(shardRouting.shardId()) == null) {                 return Decision.YES.             } else {                 return Decision.NO.             }         }     }.     // if deciders say YES to allocating primary shards, stay in YELLOW state     ClusterState clusterState = runAllocationTest(settings, indexName, Collections.singleton(decider), ClusterHealthStatus.YELLOW).     // make sure primaries are initialized     RoutingTable routingTable = clusterState.routingTable().     for (IndexShardRoutingTable indexShardRoutingTable : routingTable.index(indexName)) {         assertTrue(indexShardRoutingTable.primaryShard().initializing()).     } }
false;private;4;46;;private ClusterState runAllocationTest(final Settings settings, final String indexName, final Set<AllocationDecider> allocationDeciders, final ClusterHealthStatus expectedStatus) throws IOException {     final String clusterName = "test-cluster".     final AllocationService allocationService = newAllocationService(settings, allocationDeciders).     logger.info("Building initial routing table").     final int numShards = randomIntBetween(1, 5).     MetaData metaData = MetaData.builder().put(IndexMetaData.builder(indexName).settings(settings(Version.CURRENT)).numberOfShards(numShards).numberOfReplicas(1)).build().     RoutingTable routingTable = RoutingTable.builder().addAsNew(metaData.index(indexName)).build().     ClusterState clusterState = ClusterState.builder(new ClusterName(clusterName)).metaData(metaData).routingTable(routingTable).build().     logger.info("--> adding nodes").     // we need at least as many nodes as shards for the THROTTLE case, because     // once a shard has been throttled on a node, that node no longer accepts     // any allocations on it     final DiscoveryNodes.Builder discoveryNodes = DiscoveryNodes.builder().     for (int i = 0. i < numShards. i++) {         discoveryNodes.add(newNode("node" + i)).     }     clusterState = ClusterState.builder(clusterState).nodes(discoveryNodes).build().     logger.info("--> do the reroute").     routingTable = allocationService.reroute(clusterState, "reroute").routingTable().     clusterState = ClusterState.builder(clusterState).routingTable(routingTable).build().     logger.info("--> assert cluster health").     ClusterStateHealth health = new ClusterStateHealth(clusterState).     assertThat(health.getStatus(), equalTo(expectedStatus)).     return clusterState. }
false;private,static;2;6;;private static AllocationService newAllocationService(Settings settings, Set<AllocationDecider> deciders) {     return new AllocationService(new AllocationDeciders(deciders), new TestGatewayAllocator(), new BalancedShardsAllocator(settings), EmptyClusterInfoService.INSTANCE). }
