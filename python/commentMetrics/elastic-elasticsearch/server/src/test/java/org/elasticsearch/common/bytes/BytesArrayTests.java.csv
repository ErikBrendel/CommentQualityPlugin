commented;modifiers;parameterAmount;loc;comment;code
false;protected;1;4;;@Override protected BytesReference newBytesReference(int length) throws IOException {     return newBytesReference(length, randomInt(length)). }
false;protected;1;4;;@Override protected BytesReference newBytesReferenceWithOffsetOfZero(int length) throws IOException {     return newBytesReference(length, 0). }
false;private;2;13;;private BytesReference newBytesReference(int length, int offset) throws IOException {     // we know bytes stream output always creates a paged bytes reference, we use it to create randomized content     final BytesStreamOutput out = new BytesStreamOutput(length + offset).     for (int i = 0. i < length + offset. i++) {         out.writeByte((byte) random().nextInt(1 << 8)).     }     assertEquals(length + offset, out.size()).     BytesArray ref = new BytesArray(out.bytes().toBytesRef().bytes, offset, length).     assertEquals(length, ref.length()).     assertTrue(ref instanceof BytesArray).     assertThat(ref.length(), Matchers.equalTo(length)).     return ref. }
false;public;0;11;;public void testArray() throws IOException {     int[] sizes = { 0, randomInt(PAGE_SIZE), PAGE_SIZE, randomIntBetween(2, PAGE_SIZE * randomIntBetween(2, 5)) }.     for (int i = 0. i < sizes.length. i++) {         BytesArray pbr = (BytesArray) newBytesReference(sizes[i]).         byte[] array = pbr.array().         assertNotNull(array).         assertEquals(sizes[i], array.length - pbr.offset()).         assertSame(array, pbr.array()).     } }
false;public;0;5;;public void testArrayOffset() throws IOException {     int length = randomInt(PAGE_SIZE * randomIntBetween(2, 5)).     BytesArray pbr = (BytesArray) newBytesReferenceWithOffsetOfZero(length).     assertEquals(0, pbr.offset()). }
