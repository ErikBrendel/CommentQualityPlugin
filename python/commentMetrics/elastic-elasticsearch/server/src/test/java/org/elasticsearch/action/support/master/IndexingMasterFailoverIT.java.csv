commented;modifiers;parameterAmount;loc;comment;code
false;protected;0;6;;@Override protected Collection<Class<? extends Plugin>> nodePlugins() {     final HashSet<Class<? extends Plugin>> classes = new HashSet<>(super.nodePlugins()).     classes.add(MockTransportService.TestPlugin.class).     return classes. }
false;public;0;17;;@Override public void run() {     try {         barrier.await().     } catch (InterruptedException e) {         logger.warn("Barrier interrupted", e).         return.     } catch (BrokenBarrierException e) {         logger.warn("Broken barrier", e).         return.     }     for (int i = 0. i < 10. i++) {         // index data with mapping changes         IndexResponse response = client(dataNode).prepareIndex("myindex", "mytype").setSource("field_" + i, "val").get().         assertEquals(DocWriteResponse.Result.CREATED, response.getResult()).     } }
true;public;0;75;/**  * Indexing operations which entail mapping changes require a blocking request to the master node to update the mapping.  * If the master node is being disrupted or if it cannot commit cluster state changes, it needs to retry within timeout limits.  * This retry logic is implemented in TransportMasterNodeAction and tested by the following master failover scenario.  */ ;/**  * Indexing operations which entail mapping changes require a blocking request to the master node to update the mapping.  * If the master node is being disrupted or if it cannot commit cluster state changes, it needs to retry within timeout limits.  * This retry logic is implemented in TransportMasterNodeAction and tested by the following master failover scenario.  */ @TestLogging("_root:DEBUG") public void testMasterFailoverDuringIndexingWithMappingChanges() throws Throwable {     logger.info("--> start 4 nodes, 3 master, 1 data").     final Settings sharedSettings = Settings.builder().put("cluster.join.timeout", // still long to induce failures but not too long so test won't time out     "10s").build().     internalCluster().setBootstrapMasterNodeIndex(2).     internalCluster().startMasterOnlyNodes(3, sharedSettings).     String dataNode = internalCluster().startDataOnlyNode(sharedSettings).     logger.info("--> wait for all nodes to join the cluster").     ensureStableCluster(4).     // We index data with mapping changes into cluster and have master failover at same time     client().admin().indices().prepareCreate("myindex").setSettings(Settings.builder().put("index.number_of_shards", 1).put("index.number_of_replicas", 0)).get().     ensureGreen("myindex").     final CyclicBarrier barrier = new CyclicBarrier(2).     Thread indexingThread = new Thread(new Runnable() {          @Override         public void run() {             try {                 barrier.await().             } catch (InterruptedException e) {                 logger.warn("Barrier interrupted", e).                 return.             } catch (BrokenBarrierException e) {                 logger.warn("Broken barrier", e).                 return.             }             for (int i = 0. i < 10. i++) {                 // index data with mapping changes                 IndexResponse response = client(dataNode).prepareIndex("myindex", "mytype").setSource("field_" + i, "val").get().                 assertEquals(DocWriteResponse.Result.CREATED, response.getResult()).             }         }     }).     indexingThread.setName("indexingThread").     indexingThread.start().     barrier.await().     // interrupt communication between master and other nodes in cluster     String master = internalCluster().getMasterName().     Set<String> otherNodes = new HashSet<>(Arrays.asList(internalCluster().getNodeNames())).     otherNodes.remove(master).     NetworkDisruption partition = new NetworkDisruption(new TwoPartitions(Collections.singleton(master), otherNodes), new NetworkDisconnect()).     internalCluster().setDisruptionScheme(partition).     logger.info("--> disrupting network").     partition.startDisrupting().     logger.info("--> waiting for new master to be elected").     ensureStableCluster(3, dataNode).     partition.stopDisrupting().     logger.info("--> waiting to heal").     ensureStableCluster(4).     indexingThread.join().     ensureGreen("myindex").     refresh().     assertThat(client().prepareSearch("myindex").get().getHits().getTotalHits().value, equalTo(10L)). }
